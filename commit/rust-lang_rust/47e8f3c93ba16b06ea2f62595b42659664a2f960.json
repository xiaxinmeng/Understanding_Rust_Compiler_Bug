{"sha": "47e8f3c93ba16b06ea2f62595b42659664a2f960", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQ3ZThmM2M5M2JhMTZiMDZlYTJmNjI1OTViNDI2NTk2NjRhMmY5NjA=", "commit": {"author": {"name": "Mikhail Modin", "email": "mikhailm1@gmail.com", "date": "2020-03-29T12:24:35Z"}, "committer": {"name": "Mikhail Modin", "email": "mikhailm1@gmail.com", "date": "2020-04-01T08:39:33Z"}, "message": "Adds sort for RecordLit comparison in SSR", "tree": {"sha": "597d14f117c4dc7efcadbfde714b05ae02907762", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/597d14f117c4dc7efcadbfde714b05ae02907762"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/47e8f3c93ba16b06ea2f62595b42659664a2f960", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/47e8f3c93ba16b06ea2f62595b42659664a2f960", "html_url": "https://github.com/rust-lang/rust/commit/47e8f3c93ba16b06ea2f62595b42659664a2f960", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/47e8f3c93ba16b06ea2f62595b42659664a2f960/comments", "author": {"login": "mikhail-m1", "id": 5663581, "node_id": "MDQ6VXNlcjU2NjM1ODE=", "avatar_url": "https://avatars.githubusercontent.com/u/5663581?v=4", "gravatar_id": "", "url": "https://api.github.com/users/mikhail-m1", "html_url": "https://github.com/mikhail-m1", "followers_url": "https://api.github.com/users/mikhail-m1/followers", "following_url": "https://api.github.com/users/mikhail-m1/following{/other_user}", "gists_url": "https://api.github.com/users/mikhail-m1/gists{/gist_id}", "starred_url": "https://api.github.com/users/mikhail-m1/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/mikhail-m1/subscriptions", "organizations_url": "https://api.github.com/users/mikhail-m1/orgs", "repos_url": "https://api.github.com/users/mikhail-m1/repos", "events_url": "https://api.github.com/users/mikhail-m1/events{/privacy}", "received_events_url": "https://api.github.com/users/mikhail-m1/received_events", "type": "User", "site_admin": false}, "committer": {"login": "mikhail-m1", "id": 5663581, "node_id": "MDQ6VXNlcjU2NjM1ODE=", "avatar_url": "https://avatars.githubusercontent.com/u/5663581?v=4", "gravatar_id": "", "url": "https://api.github.com/users/mikhail-m1", "html_url": "https://github.com/mikhail-m1", "followers_url": "https://api.github.com/users/mikhail-m1/followers", "following_url": "https://api.github.com/users/mikhail-m1/following{/other_user}", "gists_url": "https://api.github.com/users/mikhail-m1/gists{/gist_id}", "starred_url": "https://api.github.com/users/mikhail-m1/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/mikhail-m1/subscriptions", "organizations_url": "https://api.github.com/users/mikhail-m1/orgs", "repos_url": "https://api.github.com/users/mikhail-m1/repos", "events_url": "https://api.github.com/users/mikhail-m1/events{/privacy}", "received_events_url": "https://api.github.com/users/mikhail-m1/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1c2d4135db867efe335a0654d86429bea7bb9caf", "url": "https://api.github.com/repos/rust-lang/rust/commits/1c2d4135db867efe335a0654d86429bea7bb9caf", "html_url": "https://github.com/rust-lang/rust/commit/1c2d4135db867efe335a0654d86429bea7bb9caf"}], "stats": {"total": 116, "additions": 90, "deletions": 26}, "files": [{"sha": "1abb891c17486ce05d4ad12e8b19c34fed0f47a1", "filename": "crates/ra_ide/src/ssr.rs", "status": "modified", "additions": 90, "deletions": 26, "changes": 116, "blob_url": "https://github.com/rust-lang/rust/blob/47e8f3c93ba16b06ea2f62595b42659664a2f960/crates%2Fra_ide%2Fsrc%2Fssr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/47e8f3c93ba16b06ea2f62595b42659664a2f960/crates%2Fra_ide%2Fsrc%2Fssr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Fssr.rs?ref=47e8f3c93ba16b06ea2f62595b42659664a2f960", "patch": "@@ -5,7 +5,7 @@ use ra_db::{SourceDatabase, SourceDatabaseExt};\n use ra_ide_db::symbol_index::SymbolsDatabase;\n use ra_ide_db::RootDatabase;\n use ra_syntax::ast::make::try_expr_from_text;\n-use ra_syntax::ast::{AstToken, Comment};\n+use ra_syntax::ast::{AstToken, Comment, RecordField, RecordLit};\n use ra_syntax::{AstNode, SyntaxElement, SyntaxNode};\n use ra_text_edit::{TextEdit, TextEditBuilder};\n use rustc_hash::FxHashMap;\n@@ -186,47 +186,102 @@ fn create_name<'a>(name: &str, vars: &'a mut Vec<Var>) -> Result<&'a str, SsrErr\n }\n \n fn find(pattern: &SsrPattern, code: &SyntaxNode) -> SsrMatches {\n+    fn check_record_lit(\n+        pattern: RecordLit,\n+        code: RecordLit,\n+        placeholders: &[Var],\n+        match_: Match,\n+    ) -> Option<Match> {\n+        let match_ = check_opt_nodes(pattern.path(), code.path(), placeholders, match_)?;\n+\n+        let mut pattern_fields =\n+            pattern.record_field_list().map(|x| x.fields().collect()).unwrap_or(vec![]);\n+        let mut code_fields =\n+            code.record_field_list().map(|x| x.fields().collect()).unwrap_or(vec![]);\n+\n+        if pattern_fields.len() != code_fields.len() {\n+            return None;\n+        }\n+\n+        let by_name = |a: &RecordField, b: &RecordField| {\n+            a.name_ref()\n+                .map(|x| x.syntax().text().to_string())\n+                .cmp(&b.name_ref().map(|x| x.syntax().text().to_string()))\n+        };\n+        pattern_fields.sort_by(by_name);\n+        code_fields.sort_by(by_name);\n+\n+        pattern_fields.into_iter().zip(code_fields.into_iter()).fold(\n+            Some(match_),\n+            |accum, (a, b)| {\n+                accum.and_then(|match_| check_opt_nodes(Some(a), Some(b), placeholders, match_))\n+            },\n+        )\n+    }\n+\n+    fn check_opt_nodes(\n+        pattern: Option<impl AstNode>,\n+        code: Option<impl AstNode>,\n+        placeholders: &[Var],\n+        match_: Match,\n+    ) -> Option<Match> {\n+        match (pattern, code) {\n+            (Some(pattern), Some(code)) => check(\n+                &SyntaxElement::from(pattern.syntax().clone()),\n+                &SyntaxElement::from(code.syntax().clone()),\n+                placeholders,\n+                match_,\n+            ),\n+            (None, None) => Some(match_),\n+            _ => None,\n+        }\n+    }\n+\n     fn check(\n         pattern: &SyntaxElement,\n         code: &SyntaxElement,\n         placeholders: &[Var],\n         mut match_: Match,\n     ) -> Option<Match> {\n-        match (pattern, code) {\n-            (SyntaxElement::Token(ref pattern), SyntaxElement::Token(ref code)) => {\n+        match (&pattern, &code) {\n+            (SyntaxElement::Token(pattern), SyntaxElement::Token(code)) => {\n                 if pattern.text() == code.text() {\n                     Some(match_)\n                 } else {\n                     None\n                 }\n             }\n-            (SyntaxElement::Node(ref pattern), SyntaxElement::Node(ref code)) => {\n+            (SyntaxElement::Node(pattern), SyntaxElement::Node(code)) => {\n                 if placeholders.iter().any(|n| n.0.as_str() == pattern.text()) {\n                     match_.binding.insert(Var(pattern.text().to_string()), code.clone());\n                     Some(match_)\n                 } else {\n-                    let mut pattern_children = pattern\n-                        .children_with_tokens()\n-                        .filter(|element| !element.kind().is_trivia());\n-                    let mut code_children =\n-                        code.children_with_tokens().filter(|element| !element.kind().is_trivia());\n-                    let new_ignored_comments = code.children_with_tokens().filter_map(|element| {\n-                        element.as_token().and_then(|token| Comment::cast(token.clone()))\n-                    });\n-                    match_.ignored_comments.extend(new_ignored_comments);\n-                    let match_from_children = pattern_children\n-                        .by_ref()\n-                        .zip(code_children.by_ref())\n-                        .fold(Some(match_), |accum, (a, b)| {\n-                            accum.and_then(|match_| check(&a, &b, placeholders, match_))\n-                        });\n-                    match_from_children.and_then(|match_| {\n-                        if pattern_children.count() == 0 && code_children.count() == 0 {\n-                            Some(match_)\n-                        } else {\n-                            None\n-                        }\n-                    })\n+                    if let (Some(pattern), Some(code)) =\n+                        (RecordLit::cast(pattern.clone()), RecordLit::cast(code.clone()))\n+                    {\n+                        check_record_lit(pattern, code, placeholders, match_)\n+                    } else {\n+                        let mut pattern_children = pattern\n+                            .children_with_tokens()\n+                            .filter(|element| !element.kind().is_trivia());\n+                        let mut code_children = code\n+                            .children_with_tokens()\n+                            .filter(|element| !element.kind().is_trivia());\n+                        let new_ignored_comments =\n+                            code.children_with_tokens().filter_map(|element| {\n+                                element.as_token().and_then(|token| Comment::cast(token.clone()))\n+                            });\n+                        match_.ignored_comments.extend(new_ignored_comments);\n+                        pattern_children\n+                            .by_ref()\n+                            .zip(code_children.by_ref())\n+                            .fold(Some(match_), |accum, (a, b)| {\n+                                accum.and_then(|match_| check(&a, &b, placeholders, match_))\n+                            })\n+                            .filter(|_| {\n+                                pattern_children.next().is_none() && code_children.next().is_none()\n+                            })\n+                    }\n                 }\n             }\n             _ => None,\n@@ -434,4 +489,13 @@ mod tests {\n             \"fn main() { bar(5)/* using 5 */ }\",\n         )\n     }\n+\n+    #[test]\n+    fn ssr_struct_lit() {\n+        assert_ssr_transform(\n+            \"foo{a: $a:expr, b: $b:expr} ==>> foo::new($a, $b)\",\n+            \"fn main() { foo{b:2, a:1} }\",\n+            \"fn main() { foo::new(1, 2) }\",\n+        )\n+    }\n }"}]}