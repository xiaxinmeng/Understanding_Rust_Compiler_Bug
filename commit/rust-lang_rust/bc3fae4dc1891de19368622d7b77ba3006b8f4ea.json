{"sha": "bc3fae4dc1891de19368622d7b77ba3006b8f4ea", "node_id": "C_kwDOAAsO6NoAKGJjM2ZhZTRkYzE4OTFkZTE5MzY4NjIyZDdiNzdiYTMwMDZiOGY0ZWE", "commit": {"author": {"name": "Paolo Barbolini", "email": "paolo.barbolini@m4ss.net", "date": "2022-06-11T22:54:20Z"}, "committer": {"name": "Paolo Barbolini", "email": "paolo.barbolini@m4ss.net", "date": "2022-06-17T22:03:54Z"}, "message": "Add VecDeque::extend from TrustedLen specialization", "tree": {"sha": "453a251c4758ffbe8915ec023c55cb381a5838ad", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/453a251c4758ffbe8915ec023c55cb381a5838ad"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/bc3fae4dc1891de19368622d7b77ba3006b8f4ea", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/bc3fae4dc1891de19368622d7b77ba3006b8f4ea", "html_url": "https://github.com/rust-lang/rust/commit/bc3fae4dc1891de19368622d7b77ba3006b8f4ea", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/bc3fae4dc1891de19368622d7b77ba3006b8f4ea/comments", "author": {"login": "paolobarbolini", "id": 6215781, "node_id": "MDQ6VXNlcjYyMTU3ODE=", "avatar_url": "https://avatars.githubusercontent.com/u/6215781?v=4", "gravatar_id": "", "url": "https://api.github.com/users/paolobarbolini", "html_url": "https://github.com/paolobarbolini", "followers_url": "https://api.github.com/users/paolobarbolini/followers", "following_url": "https://api.github.com/users/paolobarbolini/following{/other_user}", "gists_url": "https://api.github.com/users/paolobarbolini/gists{/gist_id}", "starred_url": "https://api.github.com/users/paolobarbolini/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/paolobarbolini/subscriptions", "organizations_url": "https://api.github.com/users/paolobarbolini/orgs", "repos_url": "https://api.github.com/users/paolobarbolini/repos", "events_url": "https://api.github.com/users/paolobarbolini/events{/privacy}", "received_events_url": "https://api.github.com/users/paolobarbolini/received_events", "type": "User", "site_admin": false}, "committer": {"login": "paolobarbolini", "id": 6215781, "node_id": "MDQ6VXNlcjYyMTU3ODE=", "avatar_url": "https://avatars.githubusercontent.com/u/6215781?v=4", "gravatar_id": "", "url": "https://api.github.com/users/paolobarbolini", "html_url": "https://github.com/paolobarbolini", "followers_url": "https://api.github.com/users/paolobarbolini/followers", "following_url": "https://api.github.com/users/paolobarbolini/following{/other_user}", "gists_url": "https://api.github.com/users/paolobarbolini/gists{/gist_id}", "starred_url": "https://api.github.com/users/paolobarbolini/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/paolobarbolini/subscriptions", "organizations_url": "https://api.github.com/users/paolobarbolini/orgs", "repos_url": "https://api.github.com/users/paolobarbolini/repos", "events_url": "https://api.github.com/users/paolobarbolini/events{/privacy}", "received_events_url": "https://api.github.com/users/paolobarbolini/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ac2c21a62338f916cac8b58de808013e3eb7a9f0", "url": "https://api.github.com/repos/rust-lang/rust/commits/ac2c21a62338f916cac8b58de808013e3eb7a9f0", "html_url": "https://github.com/rust-lang/rust/commit/ac2c21a62338f916cac8b58de808013e3eb7a9f0"}], "stats": {"total": 175, "additions": 175, "deletions": 0}, "files": [{"sha": "f92e5759b6f9efa6fcfadd1637b05a0cc8d45b5b", "filename": "library/alloc/src/collections/vec_deque/mod.rs", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/bc3fae4dc1891de19368622d7b77ba3006b8f4ea/library%2Falloc%2Fsrc%2Fcollections%2Fvec_deque%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc3fae4dc1891de19368622d7b77ba3006b8f4ea/library%2Falloc%2Fsrc%2Fcollections%2Fvec_deque%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fcollections%2Fvec_deque%2Fmod.rs?ref=bc3fae4dc1891de19368622d7b77ba3006b8f4ea", "patch": "@@ -453,6 +453,25 @@ impl<T, A: Allocator> VecDeque<T, A> {\n         }\n     }\n \n+    /// Writes all values from `iter` to `dst`.\n+    ///\n+    /// # Safety\n+    ///\n+    /// Assumes no wrapping around happens.\n+    /// Assumes capacity is sufficient.\n+    #[inline]\n+    unsafe fn write_iter(\n+        &mut self,\n+        dst: usize,\n+        iter: impl Iterator<Item = T>,\n+        written: &mut usize,\n+    ) {\n+        iter.enumerate().for_each(|(i, element)| unsafe {\n+            self.buffer_write(dst + i, element);\n+            *written += 1;\n+        });\n+    }\n+\n     /// Frobs the head and tail sections around to handle the fact that we\n     /// just reallocated. Unsafe because it trusts old_capacity.\n     #[inline]"}, {"sha": "cea2b7543ce445691cffe998f3040131c3d1d947", "filename": "library/alloc/src/collections/vec_deque/spec_extend.rs", "status": "modified", "additions": 59, "deletions": 0, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/bc3fae4dc1891de19368622d7b77ba3006b8f4ea/library%2Falloc%2Fsrc%2Fcollections%2Fvec_deque%2Fspec_extend.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc3fae4dc1891de19368622d7b77ba3006b8f4ea/library%2Falloc%2Fsrc%2Fcollections%2Fvec_deque%2Fspec_extend.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fcollections%2Fvec_deque%2Fspec_extend.rs?ref=bc3fae4dc1891de19368622d7b77ba3006b8f4ea", "patch": "@@ -1,5 +1,6 @@\n use crate::alloc::Allocator;\n use crate::vec;\n+use core::iter::TrustedLen;\n use core::slice;\n \n use super::VecDeque;\n@@ -34,6 +35,64 @@ where\n     }\n }\n \n+impl<T, I, A: Allocator> SpecExtend<T, I> for VecDeque<T, A>\n+where\n+    I: TrustedLen<Item = T>,\n+{\n+    default fn spec_extend(&mut self, mut iter: I) {\n+        // This is the case for a TrustedLen iterator.\n+        let (low, high) = iter.size_hint();\n+        if let Some(additional) = high {\n+            debug_assert_eq!(\n+                low,\n+                additional,\n+                \"TrustedLen iterator's size hint is not exact: {:?}\",\n+                (low, high)\n+            );\n+            self.reserve(additional);\n+\n+            struct WrapAddOnDrop<'a, T, A: Allocator> {\n+                vec_deque: &'a mut VecDeque<T, A>,\n+                written: usize,\n+            }\n+\n+            impl<'a, T, A: Allocator> Drop for WrapAddOnDrop<'a, T, A> {\n+                fn drop(&mut self) {\n+                    self.vec_deque.head =\n+                        self.vec_deque.wrap_add(self.vec_deque.head, self.written);\n+                }\n+            }\n+\n+            let mut wrapper = WrapAddOnDrop { vec_deque: self, written: 0 };\n+\n+            let head_room = wrapper.vec_deque.cap() - wrapper.vec_deque.head;\n+            unsafe {\n+                wrapper.vec_deque.write_iter(\n+                    wrapper.vec_deque.head,\n+                    ByRefSized(&mut iter).take(head_room),\n+                    &mut wrapper.written,\n+                );\n+\n+                if additional > head_room {\n+                    wrapper.vec_deque.write_iter(0, iter, &mut wrapper.written);\n+                }\n+            }\n+\n+            debug_assert_eq!(\n+                additional, wrapper.written,\n+                \"The number of items written to VecDeque doesn't match the TrustedLen size hint\"\n+            );\n+        } else {\n+            // Per TrustedLen contract a `None` upper bound means that the iterator length\n+            // truly exceeds usize::MAX, which would eventually lead to a capacity overflow anyway.\n+            // Since the other branch already panics eagerly (via `reserve()`) we do the same here.\n+            // This avoids additional codegen for a fallback code path which would eventually\n+            // panic anyway.\n+            panic!(\"capacity overflow\");\n+        }\n+    }\n+}\n+\n impl<T, A: Allocator> SpecExtend<T, vec::IntoIter<T>> for VecDeque<T, A> {\n     fn spec_extend(&mut self, mut iterator: vec::IntoIter<T>) {\n         let slice = iterator.as_slice();"}, {"sha": "1f2daef213c3b78a2cf2fb02d56f05a9f446b947", "filename": "library/alloc/src/collections/vec_deque/tests.rs", "status": "modified", "additions": 97, "deletions": 0, "changes": 97, "blob_url": "https://github.com/rust-lang/rust/blob/bc3fae4dc1891de19368622d7b77ba3006b8f4ea/library%2Falloc%2Fsrc%2Fcollections%2Fvec_deque%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc3fae4dc1891de19368622d7b77ba3006b8f4ea/library%2Falloc%2Fsrc%2Fcollections%2Fvec_deque%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fcollections%2Fvec_deque%2Ftests.rs?ref=bc3fae4dc1891de19368622d7b77ba3006b8f4ea", "patch": "@@ -1,3 +1,5 @@\n+use core::iter::TrustedLen;\n+\n use super::*;\n \n #[bench]\n@@ -791,6 +793,101 @@ fn test_from_vec() {\n     assert_eq!(vd.len(), vec.len());\n }\n \n+#[test]\n+fn test_extend_basic() {\n+    test_extend_impl(false);\n+}\n+\n+#[test]\n+fn test_extend_trusted_len() {\n+    test_extend_impl(true);\n+}\n+\n+fn test_extend_impl(trusted_len: bool) {\n+    struct VecDequeTester {\n+        test: VecDeque<usize>,\n+        expected: VecDeque<usize>,\n+        trusted_len: bool,\n+    }\n+\n+    impl VecDequeTester {\n+        fn new(trusted_len: bool) -> Self {\n+            Self { test: VecDeque::new(), expected: VecDeque::new(), trusted_len }\n+        }\n+\n+        fn test_extend<I>(&mut self, iter: I)\n+        where\n+            I: Iterator<Item = usize> + TrustedLen + Clone,\n+        {\n+            struct BasicIterator<I>(I);\n+            impl<I> Iterator for BasicIterator<I>\n+            where\n+                I: Iterator<Item = usize>,\n+            {\n+                type Item = usize;\n+\n+                fn next(&mut self) -> Option<Self::Item> {\n+                    self.0.next()\n+                }\n+            }\n+\n+            if self.trusted_len {\n+                self.test.extend(iter.clone());\n+            } else {\n+                self.test.extend(BasicIterator(iter.clone()));\n+            }\n+\n+            for item in iter {\n+                self.expected.push_back(item)\n+            }\n+\n+            assert_eq!(self.test, self.expected);\n+            let (a1, b1) = self.test.as_slices();\n+            let (a2, b2) = self.expected.as_slices();\n+            assert_eq!(a1, a2);\n+            assert_eq!(b1, b2);\n+        }\n+\n+        fn drain<R: RangeBounds<usize> + Clone>(&mut self, range: R) {\n+            self.test.drain(range.clone());\n+            self.expected.drain(range);\n+\n+            assert_eq!(self.test, self.expected);\n+        }\n+\n+        fn clear(&mut self) {\n+            self.test.clear();\n+            self.expected.clear();\n+        }\n+\n+        fn remaining_capacity(&self) -> usize {\n+            self.test.capacity() - self.test.len()\n+        }\n+    }\n+\n+    let mut tester = VecDequeTester::new(trusted_len);\n+\n+    // Initial capacity\n+    tester.test_extend(0..tester.remaining_capacity() - 1);\n+\n+    // Grow\n+    tester.test_extend(1024..2048);\n+\n+    // Wrap around\n+    tester.drain(..128);\n+\n+    tester.test_extend(0..tester.remaining_capacity() - 1);\n+\n+    // Continue\n+    tester.drain(256..);\n+    tester.test_extend(4096..8196);\n+\n+    tester.clear();\n+\n+    // Start again\n+    tester.test_extend(0..32);\n+}\n+\n #[test]\n #[should_panic = \"capacity overflow\"]\n fn test_from_vec_zst_overflow() {"}]}