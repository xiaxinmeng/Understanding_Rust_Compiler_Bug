{"sha": "a50ccd980a9f9038e83918fe936c2640044d1ab5", "node_id": "MDY6Q29tbWl0NzI0NzEyOmE1MGNjZDk4MGE5ZjkwMzhlODM5MThmZTkzNmMyNjQwMDQ0ZDFhYjU=", "commit": {"author": {"name": "Yuki Okushi", "email": "huyuumi.dev@gmail.com", "date": "2020-02-12T09:55:46Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2020-02-12T09:55:46Z"}, "message": "Rollup merge of #69027 - TimDiekmann:zeroed-alloc, r=Amanieu\n\nAdd missing `_zeroed` varants to `AllocRef`\n\nThe majority of the allocator wg has decided to add the missing `_zeroed` variants to `AllocRef`:\n\n> these should be added since they can be efficiently implemented with the `mremap` system call on Linux. `mremap` allows you to move/grow/shrink a memory mapping, and any new pages added for growth are guaranteed to be zeroed.\n>\n> If `AllocRef` does not have these methods then the user will have to manually write zeroes to the added memory since the API makes no guarantees on their contents.\n\nFor the full discussion please see https://github.com/rust-lang/wg-allocators/issues/14.\n\nThis PR provides default implementations for `realloc_zeroed`, `alloc_excess_zeroed`, `realloc_excess_zeroed`, and `grow_in_place_zeroed`.\n\nr? @Amanieu", "tree": {"sha": "bedecd502f88aea2a7c70bf6317df4ab6cef9c0f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/bedecd502f88aea2a7c70bf6317df4ab6cef9c0f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a50ccd980a9f9038e83918fe936c2640044d1ab5", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJeQ8uiCRBK7hj4Ov3rIwAAdHIIAEu9GTt/rsPu7E3yaLgxq39p\ndsPSlcs0fNgtyS00W0F7270YeK1a+b66gq6XrR4SpNN/n36b93cA9qX6k57eu1Vd\nWbWbIUSKzT6gO9qiR8B0dZVmuovGz2IRjmV7dWH0mbfeU74qDtmbIeGEC+6yr1IC\na3AvMJPt02yXi+VxsADetH56ku+ITH9ZhRr7efT/eaXLYjEIV3+I23DUYUMkMlao\nQJcV+fH4uTCL/MpDWR2OiPGScw5Mmk/oO9JQOX33zkmDXDXsFY7Agbje7OaCnFud\ncfrnp+mWQn4JmzUN2ucgyEsmdHhsy7xt6Z4Twbldo4Ex2ZHK9RDRax36uuZgimQ=\n=zhlm\n-----END PGP SIGNATURE-----\n", "payload": "tree bedecd502f88aea2a7c70bf6317df4ab6cef9c0f\nparent 9bc003da11ce9eb227514b26384f3dd8273c4b90\nparent 97d1f8d9bbb6ae25d22f5193006becf37a57d226\nauthor Yuki Okushi <huyuumi.dev@gmail.com> 1581501346 +0900\ncommitter GitHub <noreply@github.com> 1581501346 +0900\n\nRollup merge of #69027 - TimDiekmann:zeroed-alloc, r=Amanieu\n\nAdd missing `_zeroed` varants to `AllocRef`\n\nThe majority of the allocator wg has decided to add the missing `_zeroed` variants to `AllocRef`:\n\n> these should be added since they can be efficiently implemented with the `mremap` system call on Linux. `mremap` allows you to move/grow/shrink a memory mapping, and any new pages added for growth are guaranteed to be zeroed.\n>\n> If `AllocRef` does not have these methods then the user will have to manually write zeroes to the added memory since the API makes no guarantees on their contents.\n\nFor the full discussion please see https://github.com/rust-lang/wg-allocators/issues/14.\n\nThis PR provides default implementations for `realloc_zeroed`, `alloc_excess_zeroed`, `realloc_excess_zeroed`, and `grow_in_place_zeroed`.\n\nr? @Amanieu\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a50ccd980a9f9038e83918fe936c2640044d1ab5", "html_url": "https://github.com/rust-lang/rust/commit/a50ccd980a9f9038e83918fe936c2640044d1ab5", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a50ccd980a9f9038e83918fe936c2640044d1ab5/comments", "author": {"login": "JohnTitor", "id": 25030997, "node_id": "MDQ6VXNlcjI1MDMwOTk3", "avatar_url": "https://avatars.githubusercontent.com/u/25030997?v=4", "gravatar_id": "", "url": "https://api.github.com/users/JohnTitor", "html_url": "https://github.com/JohnTitor", "followers_url": "https://api.github.com/users/JohnTitor/followers", "following_url": "https://api.github.com/users/JohnTitor/following{/other_user}", "gists_url": "https://api.github.com/users/JohnTitor/gists{/gist_id}", "starred_url": "https://api.github.com/users/JohnTitor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/JohnTitor/subscriptions", "organizations_url": "https://api.github.com/users/JohnTitor/orgs", "repos_url": "https://api.github.com/users/JohnTitor/repos", "events_url": "https://api.github.com/users/JohnTitor/events{/privacy}", "received_events_url": "https://api.github.com/users/JohnTitor/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9bc003da11ce9eb227514b26384f3dd8273c4b90", "url": "https://api.github.com/repos/rust-lang/rust/commits/9bc003da11ce9eb227514b26384f3dd8273c4b90", "html_url": "https://github.com/rust-lang/rust/commit/9bc003da11ce9eb227514b26384f3dd8273c4b90"}, {"sha": "97d1f8d9bbb6ae25d22f5193006becf37a57d226", "url": "https://api.github.com/repos/rust-lang/rust/commits/97d1f8d9bbb6ae25d22f5193006becf37a57d226", "html_url": "https://github.com/rust-lang/rust/commit/97d1f8d9bbb6ae25d22f5193006becf37a57d226"}], "stats": {"total": 137, "additions": 137, "deletions": 0}, "files": [{"sha": "71f7f971eabaf8c07145b1a7af81cc18a7adc88e", "filename": "src/libcore/alloc.rs", "status": "modified", "additions": 137, "deletions": 0, "changes": 137, "blob_url": "https://github.com/rust-lang/rust/blob/a50ccd980a9f9038e83918fe936c2640044d1ab5/src%2Flibcore%2Falloc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a50ccd980a9f9038e83918fe936c2640044d1ab5/src%2Flibcore%2Falloc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Falloc.rs?ref=a50ccd980a9f9038e83918fe936c2640044d1ab5", "patch": "@@ -847,6 +847,59 @@ pub unsafe trait AllocRef {\n         result\n     }\n \n+    /// Behaves like `realloc`, but also ensures that the new contents\n+    /// are set to zero before being returned.\n+    ///\n+    /// # Safety\n+    ///\n+    /// This function is unsafe for the same reasons that `realloc` is.\n+    ///\n+    /// # Errors\n+    ///\n+    /// Returns `Err` only if the new layout\n+    /// does not meet the allocator's size\n+    /// and alignment constraints of the allocator, or if reallocation\n+    /// otherwise fails.\n+    ///\n+    /// Implementations are encouraged to return `Err` on memory\n+    /// exhaustion rather than panicking or aborting, but this is not\n+    /// a strict requirement. (Specifically: it is *legal* to\n+    /// implement this trait atop an underlying native allocation\n+    /// library that aborts on memory exhaustion.)\n+    ///\n+    /// Clients wishing to abort computation in response to a\n+    /// reallocation error are encouraged to call the [`handle_alloc_error`] function,\n+    /// rather than directly invoking `panic!` or similar.\n+    ///\n+    /// [`handle_alloc_error`]: ../../alloc/alloc/fn.handle_alloc_error.html\n+    unsafe fn realloc_zeroed(\n+        &mut self,\n+        ptr: NonNull<u8>,\n+        layout: Layout,\n+        new_size: usize,\n+    ) -> Result<NonNull<u8>, AllocErr> {\n+        let old_size = layout.size();\n+\n+        if new_size >= old_size {\n+            if let Ok(()) = self.grow_in_place_zeroed(ptr, layout, new_size) {\n+                return Ok(ptr);\n+            }\n+        } else if new_size < old_size {\n+            if let Ok(()) = self.shrink_in_place(ptr, layout, new_size) {\n+                return Ok(ptr);\n+            }\n+        }\n+\n+        // otherwise, fall back on alloc + copy + dealloc.\n+        let new_layout = Layout::from_size_align_unchecked(new_size, layout.align());\n+        let result = self.alloc_zeroed(new_layout);\n+        if let Ok(new_ptr) = result {\n+            ptr::copy_nonoverlapping(ptr.as_ptr(), new_ptr.as_ptr(), cmp::min(old_size, new_size));\n+            self.dealloc(ptr, layout);\n+        }\n+        result\n+    }\n+\n     /// Behaves like `alloc`, but also ensures that the contents\n     /// are set to zero before being returned.\n     ///\n@@ -898,6 +951,31 @@ pub unsafe trait AllocRef {\n         self.alloc(layout).map(|p| Excess(p, usable_size.1))\n     }\n \n+    /// Behaves like `alloc`, but also returns the whole size of\n+    /// the returned block. For some `layout` inputs, like arrays, this\n+    /// may include extra storage usable for additional data.\n+    /// Also it ensures that the contents are set to zero before being returned.\n+    ///\n+    /// # Safety\n+    ///\n+    /// This function is unsafe for the same reasons that `alloc` is.\n+    ///\n+    /// # Errors\n+    ///\n+    /// Returning `Err` indicates that either memory is exhausted or\n+    /// `layout` does not meet allocator's size or alignment\n+    /// constraints, just as in `alloc`.\n+    ///\n+    /// Clients wishing to abort computation in response to an\n+    /// allocation error are encouraged to call the [`handle_alloc_error`] function,\n+    /// rather than directly invoking `panic!` or similar.\n+    ///\n+    /// [`handle_alloc_error`]: ../../alloc/alloc/fn.handle_alloc_error.html\n+    unsafe fn alloc_excess_zeroed(&mut self, layout: Layout) -> Result<Excess, AllocErr> {\n+        let usable_size = self.usable_size(&layout);\n+        self.alloc_zeroed(layout).map(|p| Excess(p, usable_size.1))\n+    }\n+\n     /// Behaves like `realloc`, but also returns the whole size of\n     /// the returned block. For some `layout` inputs, like arrays, this\n     /// may include extra storage usable for additional data.\n@@ -928,6 +1006,37 @@ pub unsafe trait AllocRef {\n         self.realloc(ptr, layout, new_size).map(|p| Excess(p, usable_size.1))\n     }\n \n+    /// Behaves like `realloc`, but also returns the whole size of\n+    /// the returned block. For some `layout` inputs, like arrays, this\n+    /// may include extra storage usable for additional data.\n+    /// Also it ensures that the contents are set to zero before being returned.\n+    ///\n+    /// # Safety\n+    ///\n+    /// This function is unsafe for the same reasons that `realloc` is.\n+    ///\n+    /// # Errors\n+    ///\n+    /// Returning `Err` indicates that either memory is exhausted or\n+    /// `layout` does not meet allocator's size or alignment\n+    /// constraints, just as in `realloc`.\n+    ///\n+    /// Clients wishing to abort computation in response to a\n+    /// reallocation error are encouraged to call the [`handle_alloc_error`] function,\n+    /// rather than directly invoking `panic!` or similar.\n+    ///\n+    /// [`handle_alloc_error`]: ../../alloc/alloc/fn.handle_alloc_error.html\n+    unsafe fn realloc_excess_zeroed(\n+        &mut self,\n+        ptr: NonNull<u8>,\n+        layout: Layout,\n+        new_size: usize,\n+    ) -> Result<Excess, AllocErr> {\n+        let new_layout = Layout::from_size_align_unchecked(new_size, layout.align());\n+        let usable_size = self.usable_size(&new_layout);\n+        self.realloc_zeroed(ptr, layout, new_size).map(|p| Excess(p, usable_size.1))\n+    }\n+\n     /// Attempts to extend the allocation referenced by `ptr` to fit `new_size`.\n     ///\n     /// If this returns `Ok`, then the allocator has asserted that the\n@@ -977,6 +1086,34 @@ pub unsafe trait AllocRef {\n         if new_size <= u { Ok(()) } else { Err(CannotReallocInPlace) }\n     }\n \n+    /// Behaves like `grow_in_place`, but also ensures that the new\n+    /// contents are set to zero before being returned.\n+    ///\n+    /// # Safety\n+    ///\n+    /// This function is unsafe for the same reasons that `grow_in_place` is.\n+    ///\n+    /// # Errors\n+    ///\n+    /// Returns `Err(CannotReallocInPlace)` when the allocator is\n+    /// unable to assert that the memory block referenced by `ptr`\n+    /// could fit `layout`.\n+    ///\n+    /// Note that one cannot pass `CannotReallocInPlace` to the `handle_alloc_error`\n+    /// function; clients are expected either to be able to recover from\n+    /// `grow_in_place` failures without aborting, or to fall back on\n+    /// another reallocation method before resorting to an abort.\n+    unsafe fn grow_in_place_zeroed(\n+        &mut self,\n+        ptr: NonNull<u8>,\n+        layout: Layout,\n+        new_size: usize,\n+    ) -> Result<(), CannotReallocInPlace> {\n+        self.grow_in_place(ptr, layout, new_size)?;\n+        ptr.as_ptr().add(layout.size()).write_bytes(0, new_size - layout.size());\n+        Ok(())\n+    }\n+\n     /// Attempts to shrink the allocation referenced by `ptr` to fit `new_size`.\n     ///\n     /// If this returns `Ok`, then the allocator has asserted that the"}]}