{"sha": "fd495a0654611a6d784bae4698e5838b121e8004", "node_id": "C_kwDOAAsO6NoAKGZkNDk1YTA2NTQ2MTFhNmQ3ODRiYWU0Njk4ZTU4MzhiMTIxZTgwMDQ", "commit": {"author": {"name": "flip1995", "email": "philipp.krones@embecosm.com", "date": "2022-02-24T18:32:17Z"}, "committer": {"name": "flip1995", "email": "philipp.krones@embecosm.com", "date": "2022-02-24T18:32:17Z"}, "message": "Merge remote-tracking branch 'upstream/master' into rustup", "tree": {"sha": "a7a11154828bcf770d722a4a2bca307cadaa97e8", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a7a11154828bcf770d722a4a2bca307cadaa97e8"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/fd495a0654611a6d784bae4698e5838b121e8004", "comment_count": 0, "verification": {"verified": false, "reason": "bad_email", "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCAAdFiEEij1UXJ/PQTcb99vTHKDfKvWdaKUFAmIXzzQACgkQHKDfKvWd\naKWMBhAA0cR4kCG4a/iqJzabYnZnWoeggniRhi7Us0KtW2nV2wOICBijhmaVPe89\ngQLIAwkoxD4j+ZESyPPsAjUoGQw9MLm4zMr6deuUcl3h2wBydGmA5BJAme3cKOk3\nUTu1pQjScG70iMXKaYVOvp2+e13erAHaiu0HCyWBKA/6b2pNo9UxbBDpn52FkOZl\nViVzuVxm9RuPakxRMbnPvrxtpgntt+yBboMO3fl4SbsqcWHcRz8EvH5K+TPGbWCq\nKhmRKUMVzU1SsJrwDKB9dKa3cD7btHRANWlXIlCpDSYMYjvZu8O90yQ9Ha22iyoT\nzhrOKFNjmI/B+n/Ou9IKz0CP/gpS7fM5/oI55cBmnpglOHdN5NdeuCptcPKQ5ohW\n/fjyXMoPzm5HziW3k0frJzgrQ3aBNMnYYucesLEoBVPvnGEoaQ0QopABBvqtIx/w\n2vKK6oDmx8yUUyWQe3IsFwkAGWzgD5uPopcdG6oVI2nkclYG+JTigLAtnp81hKDo\nBH6DPC0LQ7nYgLzduv/u7qqWQXrBAy0k3YYHlzXyTfvLW3FRy2STsY9ns31wGjBj\nRTsB8V3HzJD+NZyVX6NEhJWGYBMtf1VL97frrIYUXrioTvT17AnWVJnaBzRMj9iM\nIb58M3phxhGhfuaE8zl1NisNj1tC1rw+FOI+EgZmdQFqdkcNIjY=\n=ZRzK\n-----END PGP SIGNATURE-----", "payload": "tree a7a11154828bcf770d722a4a2bca307cadaa97e8\nparent e390e6c46914b54ea2ffa901f3c6b046b9a7b7d4\nparent 042892a0815fe0fec72ea1a07348d99ca08bf944\nauthor flip1995 <philipp.krones@embecosm.com> 1645727537 +0100\ncommitter flip1995 <philipp.krones@embecosm.com> 1645727537 +0100\n\nMerge remote-tracking branch 'upstream/master' into rustup\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/fd495a0654611a6d784bae4698e5838b121e8004", "html_url": "https://github.com/rust-lang/rust/commit/fd495a0654611a6d784bae4698e5838b121e8004", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/fd495a0654611a6d784bae4698e5838b121e8004/comments", "author": {"login": "flip1995", "id": 9744647, "node_id": "MDQ6VXNlcjk3NDQ2NDc=", "avatar_url": "https://avatars.githubusercontent.com/u/9744647?v=4", "gravatar_id": "", "url": "https://api.github.com/users/flip1995", "html_url": "https://github.com/flip1995", "followers_url": "https://api.github.com/users/flip1995/followers", "following_url": "https://api.github.com/users/flip1995/following{/other_user}", "gists_url": "https://api.github.com/users/flip1995/gists{/gist_id}", "starred_url": "https://api.github.com/users/flip1995/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/flip1995/subscriptions", "organizations_url": "https://api.github.com/users/flip1995/orgs", "repos_url": "https://api.github.com/users/flip1995/repos", "events_url": "https://api.github.com/users/flip1995/events{/privacy}", "received_events_url": "https://api.github.com/users/flip1995/received_events", "type": "User", "site_admin": false}, "committer": {"login": "flip1995", "id": 9744647, "node_id": "MDQ6VXNlcjk3NDQ2NDc=", "avatar_url": "https://avatars.githubusercontent.com/u/9744647?v=4", "gravatar_id": "", "url": "https://api.github.com/users/flip1995", "html_url": "https://github.com/flip1995", "followers_url": "https://api.github.com/users/flip1995/followers", "following_url": "https://api.github.com/users/flip1995/following{/other_user}", "gists_url": "https://api.github.com/users/flip1995/gists{/gist_id}", "starred_url": "https://api.github.com/users/flip1995/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/flip1995/subscriptions", "organizations_url": "https://api.github.com/users/flip1995/orgs", "repos_url": "https://api.github.com/users/flip1995/repos", "events_url": "https://api.github.com/users/flip1995/events{/privacy}", "received_events_url": "https://api.github.com/users/flip1995/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e390e6c46914b54ea2ffa901f3c6b046b9a7b7d4", "url": "https://api.github.com/repos/rust-lang/rust/commits/e390e6c46914b54ea2ffa901f3c6b046b9a7b7d4", "html_url": "https://github.com/rust-lang/rust/commit/e390e6c46914b54ea2ffa901f3c6b046b9a7b7d4"}, {"sha": "042892a0815fe0fec72ea1a07348d99ca08bf944", "url": "https://api.github.com/repos/rust-lang/rust/commits/042892a0815fe0fec72ea1a07348d99ca08bf944", "html_url": "https://github.com/rust-lang/rust/commit/042892a0815fe0fec72ea1a07348d99ca08bf944"}], "stats": {"total": 4541, "additions": 3184, "deletions": 1357}, "files": [{"sha": "1b52a6fcd05e979540ef2b559058779a8df04fef", "filename": "CHANGELOG.md", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/fd495a0654611a6d784bae4698e5838b121e8004/CHANGELOG.md", "raw_url": "https://github.com/rust-lang/rust/raw/fd495a0654611a6d784bae4698e5838b121e8004/CHANGELOG.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/CHANGELOG.md?ref=fd495a0654611a6d784bae4698e5838b121e8004", "patch": "@@ -1438,7 +1438,7 @@ Released 2020-11-19\n * [`manual_strip`] [#6038](https://github.com/rust-lang/rust-clippy/pull/6038)\n * [`map_err_ignore`] [#5998](https://github.com/rust-lang/rust-clippy/pull/5998)\n * [`rc_buffer`] [#6044](https://github.com/rust-lang/rust-clippy/pull/6044)\n-* [`to_string_in_display`] [#5831](https://github.com/rust-lang/rust-clippy/pull/5831)\n+* `to_string_in_display` [#5831](https://github.com/rust-lang/rust-clippy/pull/5831)\n * `single_char_push_str` [#5881](https://github.com/rust-lang/rust-clippy/pull/5881)\n \n ### Moves and Deprecations\n@@ -1481,7 +1481,7 @@ Released 2020-11-19\n   [#5949](https://github.com/rust-lang/rust-clippy/pull/5949)\n * [`doc_markdown`]: allow using \"GraphQL\" without backticks\n   [#5996](https://github.com/rust-lang/rust-clippy/pull/5996)\n-* [`to_string_in_display`]: avoid linting when calling `to_string()` on anything that is not `self`\n+* `to_string_in_display`: avoid linting when calling `to_string()` on anything that is not `self`\n   [#5971](https://github.com/rust-lang/rust-clippy/pull/5971)\n * [`indexing_slicing`] and [`out_of_bounds_indexing`] treat references to arrays as arrays\n   [#6034](https://github.com/rust-lang/rust-clippy/pull/6034)\n@@ -3068,6 +3068,7 @@ Released 2018-09-13\n [`bytes_nth`]: https://rust-lang.github.io/rust-clippy/master/index.html#bytes_nth\n [`cargo_common_metadata`]: https://rust-lang.github.io/rust-clippy/master/index.html#cargo_common_metadata\n [`case_sensitive_file_extension_comparisons`]: https://rust-lang.github.io/rust-clippy/master/index.html#case_sensitive_file_extension_comparisons\n+[`cast_enum_truncation`]: https://rust-lang.github.io/rust-clippy/master/index.html#cast_enum_truncation\n [`cast_lossless`]: https://rust-lang.github.io/rust-clippy/master/index.html#cast_lossless\n [`cast_possible_truncation`]: https://rust-lang.github.io/rust-clippy/master/index.html#cast_possible_truncation\n [`cast_possible_wrap`]: https://rust-lang.github.io/rust-clippy/master/index.html#cast_possible_wrap\n@@ -3105,6 +3106,7 @@ Released 2018-09-13\n [`deprecated_cfg_attr`]: https://rust-lang.github.io/rust-clippy/master/index.html#deprecated_cfg_attr\n [`deprecated_semver`]: https://rust-lang.github.io/rust-clippy/master/index.html#deprecated_semver\n [`deref_addrof`]: https://rust-lang.github.io/rust-clippy/master/index.html#deref_addrof\n+[`deref_by_slicing`]: https://rust-lang.github.io/rust-clippy/master/index.html#deref_by_slicing\n [`derivable_impls`]: https://rust-lang.github.io/rust-clippy/master/index.html#derivable_impls\n [`derive_hash_xor_eq`]: https://rust-lang.github.io/rust-clippy/master/index.html#derive_hash_xor_eq\n [`derive_ord_xor_partial_ord`]: https://rust-lang.github.io/rust-clippy/master/index.html#derive_ord_xor_partial_ord\n@@ -3385,6 +3387,7 @@ Released 2018-09-13\n [`range_zip_with_len`]: https://rust-lang.github.io/rust-clippy/master/index.html#range_zip_with_len\n [`rc_buffer`]: https://rust-lang.github.io/rust-clippy/master/index.html#rc_buffer\n [`rc_mutex`]: https://rust-lang.github.io/rust-clippy/master/index.html#rc_mutex\n+[`recursive_format_impl`]: https://rust-lang.github.io/rust-clippy/master/index.html#recursive_format_impl\n [`redundant_allocation`]: https://rust-lang.github.io/rust-clippy/master/index.html#redundant_allocation\n [`redundant_clone`]: https://rust-lang.github.io/rust-clippy/master/index.html#redundant_clone\n [`redundant_closure`]: https://rust-lang.github.io/rust-clippy/master/index.html#redundant_closure\n@@ -3459,7 +3462,6 @@ Released 2018-09-13\n [`tabs_in_doc_comments`]: https://rust-lang.github.io/rust-clippy/master/index.html#tabs_in_doc_comments\n [`temporary_assignment`]: https://rust-lang.github.io/rust-clippy/master/index.html#temporary_assignment\n [`to_digit_is_some`]: https://rust-lang.github.io/rust-clippy/master/index.html#to_digit_is_some\n-[`to_string_in_display`]: https://rust-lang.github.io/rust-clippy/master/index.html#to_string_in_display\n [`to_string_in_format_args`]: https://rust-lang.github.io/rust-clippy/master/index.html#to_string_in_format_args\n [`todo`]: https://rust-lang.github.io/rust-clippy/master/index.html#todo\n [`too_many_arguments`]: https://rust-lang.github.io/rust-clippy/master/index.html#too_many_arguments"}, {"sha": "ef5b0a0cd7830f579af767382aee825158195f27", "filename": "Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/fd495a0654611a6d784bae4698e5838b121e8004/Cargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/fd495a0654611a6d784bae4698e5838b121e8004/Cargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.toml?ref=fd495a0654611a6d784bae4698e5838b121e8004", "patch": "@@ -50,6 +50,7 @@ syn = { version = \"1.0\", features = [\"full\"] }\n futures = \"0.3\"\n parking_lot = \"0.11.2\"\n tokio = { version = \"1\", features = [\"io-util\"] }\n+num_cpus = \"1.13\"\n \n [build-dependencies]\n rustc_tools_util = { version = \"0.2\", path = \"rustc_tools_util\" }"}, {"sha": "f0979840ff8d8ab9d55d0a1426b5905ee10d23ec", "filename": "clippy_lints/src/await_holding_invalid.rs", "status": "modified", "additions": 82, "deletions": 37, "changes": 119, "blob_url": "https://github.com/rust-lang/rust/blob/fd495a0654611a6d784bae4698e5838b121e8004/clippy_lints%2Fsrc%2Fawait_holding_invalid.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd495a0654611a6d784bae4698e5838b121e8004/clippy_lints%2Fsrc%2Fawait_holding_invalid.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fawait_holding_invalid.rs?ref=fd495a0654611a6d784bae4698e5838b121e8004", "patch": "@@ -1,4 +1,4 @@\n-use clippy_utils::diagnostics::span_lint_and_note;\n+use clippy_utils::diagnostics::span_lint_and_then;\n use clippy_utils::{match_def_path, paths};\n use rustc_hir::def_id::DefId;\n use rustc_hir::{AsyncGeneratorKind, Body, BodyId, GeneratorKind};\n@@ -9,8 +9,7 @@ use rustc_span::Span;\n \n declare_clippy_lint! {\n     /// ### What it does\n-    /// Checks for calls to await while holding a\n-    /// non-async-aware MutexGuard.\n+    /// Checks for calls to await while holding a non-async-aware MutexGuard.\n     ///\n     /// ### Why is this bad?\n     /// The Mutex types found in std::sync and parking_lot\n@@ -22,77 +21,110 @@ declare_clippy_lint! {\n     /// either by introducing a scope or an explicit call to Drop::drop.\n     ///\n     /// ### Known problems\n-    /// Will report false positive for explicitly dropped guards ([#6446](https://github.com/rust-lang/rust-clippy/issues/6446)).\n+    /// Will report false positive for explicitly dropped guards\n+    /// ([#6446](https://github.com/rust-lang/rust-clippy/issues/6446)). A workaround for this is\n+    /// to wrap the `.lock()` call in a block instead of explicitly dropping the guard.\n     ///\n     /// ### Example\n-    /// ```rust,ignore\n-    /// use std::sync::Mutex;\n-    ///\n+    /// ```rust\n+    /// # use std::sync::Mutex;\n+    /// # async fn baz() {}\n     /// async fn foo(x: &Mutex<u32>) {\n-    ///   let guard = x.lock().unwrap();\n+    ///   let mut guard = x.lock().unwrap();\n     ///   *guard += 1;\n-    ///   bar.await;\n+    ///   baz().await;\n+    /// }\n+    ///\n+    /// async fn bar(x: &Mutex<u32>) {\n+    ///   let mut guard = x.lock().unwrap();\n+    ///   *guard += 1;\n+    ///   drop(guard); // explicit drop\n+    ///   baz().await;\n     /// }\n     /// ```\n     ///\n     /// Use instead:\n-    /// ```rust,ignore\n-    /// use std::sync::Mutex;\n-    ///\n+    /// ```rust\n+    /// # use std::sync::Mutex;\n+    /// # async fn baz() {}\n     /// async fn foo(x: &Mutex<u32>) {\n     ///   {\n-    ///     let guard = x.lock().unwrap();\n+    ///     let mut guard = x.lock().unwrap();\n     ///     *guard += 1;\n     ///   }\n-    ///   bar.await;\n+    ///   baz().await;\n+    /// }\n+    ///\n+    /// async fn bar(x: &Mutex<u32>) {\n+    ///   {\n+    ///     let mut guard = x.lock().unwrap();\n+    ///     *guard += 1;\n+    ///   } // guard dropped here at end of scope\n+    ///   baz().await;\n     /// }\n     /// ```\n     #[clippy::version = \"1.45.0\"]\n     pub AWAIT_HOLDING_LOCK,\n-    pedantic,\n-    \"Inside an async function, holding a MutexGuard while calling await\"\n+    suspicious,\n+    \"inside an async function, holding a `MutexGuard` while calling `await`\"\n }\n \n declare_clippy_lint! {\n     /// ### What it does\n-    /// Checks for calls to await while holding a\n-    /// `RefCell` `Ref` or `RefMut`.\n+    /// Checks for calls to await while holding a `RefCell` `Ref` or `RefMut`.\n     ///\n     /// ### Why is this bad?\n     /// `RefCell` refs only check for exclusive mutable access\n     /// at runtime. Holding onto a `RefCell` ref across an `await` suspension point\n     /// risks panics from a mutable ref shared while other refs are outstanding.\n     ///\n     /// ### Known problems\n-    /// Will report false positive for explicitly dropped refs ([#6353](https://github.com/rust-lang/rust-clippy/issues/6353)).\n+    /// Will report false positive for explicitly dropped refs\n+    /// ([#6353](https://github.com/rust-lang/rust-clippy/issues/6353)). A workaround for this is\n+    /// to wrap the `.borrow[_mut]()` call in a block instead of explicitly dropping the ref.\n     ///\n     /// ### Example\n-    /// ```rust,ignore\n-    /// use std::cell::RefCell;\n-    ///\n+    /// ```rust\n+    /// # use std::cell::RefCell;\n+    /// # async fn baz() {}\n     /// async fn foo(x: &RefCell<u32>) {\n     ///   let mut y = x.borrow_mut();\n     ///   *y += 1;\n-    ///   bar.await;\n+    ///   baz().await;\n+    /// }\n+    ///\n+    /// async fn bar(x: &RefCell<u32>) {\n+    ///   let mut y = x.borrow_mut();\n+    ///   *y += 1;\n+    ///   drop(y); // explicit drop\n+    ///   baz().await;\n     /// }\n     /// ```\n     ///\n     /// Use instead:\n-    /// ```rust,ignore\n-    /// use std::cell::RefCell;\n-    ///\n+    /// ```rust\n+    /// # use std::cell::RefCell;\n+    /// # async fn baz() {}\n     /// async fn foo(x: &RefCell<u32>) {\n     ///   {\n     ///      let mut y = x.borrow_mut();\n     ///      *y += 1;\n     ///   }\n-    ///   bar.await;\n+    ///   baz().await;\n+    /// }\n+    ///\n+    /// async fn bar(x: &RefCell<u32>) {\n+    ///   {\n+    ///     let mut y = x.borrow_mut();\n+    ///     *y += 1;\n+    ///   } // y dropped here at end of scope\n+    ///   baz().await;\n     /// }\n     /// ```\n     #[clippy::version = \"1.49.0\"]\n     pub AWAIT_HOLDING_REFCELL_REF,\n-    pedantic,\n-    \"Inside an async function, holding a RefCell ref while calling await\"\n+    suspicious,\n+    \"inside an async function, holding a `RefCell` ref while calling `await`\"\n }\n \n declare_lint_pass!(AwaitHolding => [AWAIT_HOLDING_LOCK, AWAIT_HOLDING_REFCELL_REF]);\n@@ -118,23 +150,36 @@ fn check_interior_types(cx: &LateContext<'_>, ty_causes: &[GeneratorInteriorType\n     for ty_cause in ty_causes {\n         if let rustc_middle::ty::Adt(adt, _) = ty_cause.ty.kind() {\n             if is_mutex_guard(cx, adt.did) {\n-                span_lint_and_note(\n+                span_lint_and_then(\n                     cx,\n                     AWAIT_HOLDING_LOCK,\n                     ty_cause.span,\n-                    \"this MutexGuard is held across an 'await' point. Consider using an async-aware Mutex type or ensuring the MutexGuard is dropped before calling await\",\n-                    ty_cause.scope_span.or(Some(span)),\n-                    \"these are all the await points this lock is held through\",\n+                    \"this `MutexGuard` is held across an `await` point\",\n+                    |diag| {\n+                        diag.help(\n+                            \"consider using an async-aware `Mutex` type or ensuring the \\\n+                                `MutexGuard` is dropped before calling await\",\n+                        );\n+                        diag.span_note(\n+                            ty_cause.scope_span.unwrap_or(span),\n+                            \"these are all the `await` points this lock is held through\",\n+                        );\n+                    },\n                 );\n             }\n             if is_refcell_ref(cx, adt.did) {\n-                span_lint_and_note(\n+                span_lint_and_then(\n                     cx,\n                     AWAIT_HOLDING_REFCELL_REF,\n                     ty_cause.span,\n-                    \"this RefCell Ref is held across an 'await' point. Consider ensuring the Ref is dropped before calling await\",\n-                    ty_cause.scope_span.or(Some(span)),\n-                    \"these are all the await points this ref is held through\",\n+                    \"this `RefCell` reference is held across an `await` point\",\n+                    |diag| {\n+                        diag.help(\"ensure the reference is dropped before calling `await`\");\n+                        diag.span_note(\n+                            ty_cause.scope_span.unwrap_or(span),\n+                            \"these are all the `await` points this reference is held through\",\n+                        );\n+                    },\n                 );\n             }\n         }"}, {"sha": "e0442dda479d75c89023dde50eb2ca669a955356", "filename": "clippy_lints/src/cargo/common_metadata.rs", "status": "added", "additions": 54, "deletions": 0, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/fd495a0654611a6d784bae4698e5838b121e8004/clippy_lints%2Fsrc%2Fcargo%2Fcommon_metadata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd495a0654611a6d784bae4698e5838b121e8004/clippy_lints%2Fsrc%2Fcargo%2Fcommon_metadata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fcargo%2Fcommon_metadata.rs?ref=fd495a0654611a6d784bae4698e5838b121e8004", "patch": "@@ -0,0 +1,54 @@\n+//! lint on missing cargo common metadata\n+\n+use cargo_metadata::Metadata;\n+use clippy_utils::diagnostics::span_lint;\n+use rustc_lint::LateContext;\n+use rustc_span::source_map::DUMMY_SP;\n+\n+use super::CARGO_COMMON_METADATA;\n+\n+pub(super) fn check(cx: &LateContext<'_>, metadata: &Metadata, ignore_publish: bool) {\n+    for package in &metadata.packages {\n+        // only run the lint if publish is `None` (`publish = true` or skipped entirely)\n+        // or if the vector isn't empty (`publish = [\"something\"]`)\n+        if package.publish.as_ref().filter(|publish| publish.is_empty()).is_none() || ignore_publish {\n+            if is_empty_str(&package.description) {\n+                missing_warning(cx, package, \"package.description\");\n+            }\n+\n+            if is_empty_str(&package.license) && is_empty_str(&package.license_file) {\n+                missing_warning(cx, package, \"either package.license or package.license_file\");\n+            }\n+\n+            if is_empty_str(&package.repository) {\n+                missing_warning(cx, package, \"package.repository\");\n+            }\n+\n+            if is_empty_str(&package.readme) {\n+                missing_warning(cx, package, \"package.readme\");\n+            }\n+\n+            if is_empty_vec(&package.keywords) {\n+                missing_warning(cx, package, \"package.keywords\");\n+            }\n+\n+            if is_empty_vec(&package.categories) {\n+                missing_warning(cx, package, \"package.categories\");\n+            }\n+        }\n+    }\n+}\n+\n+fn missing_warning(cx: &LateContext<'_>, package: &cargo_metadata::Package, field: &str) {\n+    let message = format!(\"package `{}` is missing `{}` metadata\", package.name, field);\n+    span_lint(cx, CARGO_COMMON_METADATA, DUMMY_SP, &message);\n+}\n+\n+fn is_empty_str<T: AsRef<std::ffi::OsStr>>(value: &Option<T>) -> bool {\n+    value.as_ref().map_or(true, |s| s.as_ref().is_empty())\n+}\n+\n+fn is_empty_vec(value: &[String]) -> bool {\n+    // This works because empty iterators return true\n+    value.iter().all(String::is_empty)\n+}"}, {"sha": "79a469a4258bbcc4643153e2d84eb64a814becfc", "filename": "clippy_lints/src/cargo/feature_name.rs", "status": "added", "additions": 92, "deletions": 0, "changes": 92, "blob_url": "https://github.com/rust-lang/rust/blob/fd495a0654611a6d784bae4698e5838b121e8004/clippy_lints%2Fsrc%2Fcargo%2Ffeature_name.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd495a0654611a6d784bae4698e5838b121e8004/clippy_lints%2Fsrc%2Fcargo%2Ffeature_name.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fcargo%2Ffeature_name.rs?ref=fd495a0654611a6d784bae4698e5838b121e8004", "patch": "@@ -0,0 +1,92 @@\n+use cargo_metadata::Metadata;\n+use clippy_utils::diagnostics::span_lint_and_help;\n+use rustc_lint::LateContext;\n+use rustc_span::source_map::DUMMY_SP;\n+\n+use super::{NEGATIVE_FEATURE_NAMES, REDUNDANT_FEATURE_NAMES};\n+\n+static PREFIXES: [&str; 8] = [\"no-\", \"no_\", \"not-\", \"not_\", \"use-\", \"use_\", \"with-\", \"with_\"];\n+static SUFFIXES: [&str; 2] = [\"-support\", \"_support\"];\n+\n+pub(super) fn check(cx: &LateContext<'_>, metadata: &Metadata) {\n+    for package in &metadata.packages {\n+        let mut features: Vec<&String> = package.features.keys().collect();\n+        features.sort();\n+        for feature in features {\n+            let prefix_opt = {\n+                let i = PREFIXES.partition_point(|prefix| prefix < &feature.as_str());\n+                if i > 0 && feature.starts_with(PREFIXES[i - 1]) {\n+                    Some(PREFIXES[i - 1])\n+                } else {\n+                    None\n+                }\n+            };\n+            if let Some(prefix) = prefix_opt {\n+                lint(cx, feature, prefix, true);\n+            }\n+\n+            let suffix_opt: Option<&str> = {\n+                let i = SUFFIXES.partition_point(|suffix| {\n+                    suffix.bytes().rev().cmp(feature.bytes().rev()) == std::cmp::Ordering::Less\n+                });\n+                if i > 0 && feature.ends_with(SUFFIXES[i - 1]) {\n+                    Some(SUFFIXES[i - 1])\n+                } else {\n+                    None\n+                }\n+            };\n+            if let Some(suffix) = suffix_opt {\n+                lint(cx, feature, suffix, false);\n+            }\n+        }\n+    }\n+}\n+\n+fn is_negative_prefix(s: &str) -> bool {\n+    s.starts_with(\"no\")\n+}\n+\n+fn lint(cx: &LateContext<'_>, feature: &str, substring: &str, is_prefix: bool) {\n+    let is_negative = is_prefix && is_negative_prefix(substring);\n+    span_lint_and_help(\n+        cx,\n+        if is_negative {\n+            NEGATIVE_FEATURE_NAMES\n+        } else {\n+            REDUNDANT_FEATURE_NAMES\n+        },\n+        DUMMY_SP,\n+        &format!(\n+            \"the \\\"{}\\\" {} in the feature name \\\"{}\\\" is {}\",\n+            substring,\n+            if is_prefix { \"prefix\" } else { \"suffix\" },\n+            feature,\n+            if is_negative { \"negative\" } else { \"redundant\" }\n+        ),\n+        None,\n+        &format!(\n+            \"consider renaming the feature to \\\"{}\\\"{}\",\n+            if is_prefix {\n+                feature.strip_prefix(substring)\n+            } else {\n+                feature.strip_suffix(substring)\n+            }\n+            .unwrap(),\n+            if is_negative {\n+                \", but make sure the feature adds functionality\"\n+            } else {\n+                \"\"\n+            }\n+        ),\n+    );\n+}\n+\n+#[test]\n+fn test_prefixes_sorted() {\n+    let mut sorted_prefixes = PREFIXES;\n+    sorted_prefixes.sort_unstable();\n+    assert_eq!(PREFIXES, sorted_prefixes);\n+    let mut sorted_suffixes = SUFFIXES;\n+    sorted_suffixes.sort_by(|a, b| a.bytes().rev().cmp(b.bytes().rev()));\n+    assert_eq!(SUFFIXES, sorted_suffixes);\n+}"}, {"sha": "abe95c6663f70eb6a614c4335fc96dfbeec2f356", "filename": "clippy_lints/src/cargo/mod.rs", "status": "added", "additions": 221, "deletions": 0, "changes": 221, "blob_url": "https://github.com/rust-lang/rust/blob/fd495a0654611a6d784bae4698e5838b121e8004/clippy_lints%2Fsrc%2Fcargo%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd495a0654611a6d784bae4698e5838b121e8004/clippy_lints%2Fsrc%2Fcargo%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fcargo%2Fmod.rs?ref=fd495a0654611a6d784bae4698e5838b121e8004", "patch": "@@ -0,0 +1,221 @@\n+use cargo_metadata::MetadataCommand;\n+use clippy_utils::diagnostics::span_lint;\n+use clippy_utils::is_lint_allowed;\n+use rustc_hir::hir_id::CRATE_HIR_ID;\n+use rustc_lint::{LateContext, LateLintPass, Lint};\n+use rustc_session::{declare_tool_lint, impl_lint_pass};\n+use rustc_span::DUMMY_SP;\n+\n+mod common_metadata;\n+mod feature_name;\n+mod multiple_crate_versions;\n+mod wildcard_dependencies;\n+\n+declare_clippy_lint! {\n+    /// ### What it does\n+    /// Checks to see if all common metadata is defined in\n+    /// `Cargo.toml`. See: https://rust-lang-nursery.github.io/api-guidelines/documentation.html#cargotoml-includes-all-common-metadata-c-metadata\n+    ///\n+    /// ### Why is this bad?\n+    /// It will be more difficult for users to discover the\n+    /// purpose of the crate, and key information related to it.\n+    ///\n+    /// ### Example\n+    /// ```toml\n+    /// # This `Cargo.toml` is missing a description field:\n+    /// [package]\n+    /// name = \"clippy\"\n+    /// version = \"0.0.212\"\n+    /// repository = \"https://github.com/rust-lang/rust-clippy\"\n+    /// readme = \"README.md\"\n+    /// license = \"MIT OR Apache-2.0\"\n+    /// keywords = [\"clippy\", \"lint\", \"plugin\"]\n+    /// categories = [\"development-tools\", \"development-tools::cargo-plugins\"]\n+    /// ```\n+    ///\n+    /// Should include a description field like:\n+    ///\n+    /// ```toml\n+    /// # This `Cargo.toml` includes all common metadata\n+    /// [package]\n+    /// name = \"clippy\"\n+    /// version = \"0.0.212\"\n+    /// description = \"A bunch of helpful lints to avoid common pitfalls in Rust\"\n+    /// repository = \"https://github.com/rust-lang/rust-clippy\"\n+    /// readme = \"README.md\"\n+    /// license = \"MIT OR Apache-2.0\"\n+    /// keywords = [\"clippy\", \"lint\", \"plugin\"]\n+    /// categories = [\"development-tools\", \"development-tools::cargo-plugins\"]\n+    /// ```\n+    #[clippy::version = \"1.32.0\"]\n+    pub CARGO_COMMON_METADATA,\n+    cargo,\n+    \"common metadata is defined in `Cargo.toml`\"\n+}\n+\n+declare_clippy_lint! {\n+    /// ### What it does\n+    /// Checks for feature names with prefix `use-`, `with-` or suffix `-support`\n+    ///\n+    /// ### Why is this bad?\n+    /// These prefixes and suffixes have no significant meaning.\n+    ///\n+    /// ### Example\n+    /// ```toml\n+    /// # The `Cargo.toml` with feature name redundancy\n+    /// [features]\n+    /// default = [\"use-abc\", \"with-def\", \"ghi-support\"]\n+    /// use-abc = []  // redundant\n+    /// with-def = []   // redundant\n+    /// ghi-support = []   // redundant\n+    /// ```\n+    ///\n+    /// Use instead:\n+    /// ```toml\n+    /// [features]\n+    /// default = [\"abc\", \"def\", \"ghi\"]\n+    /// abc = []\n+    /// def = []\n+    /// ghi = []\n+    /// ```\n+    ///\n+    #[clippy::version = \"1.57.0\"]\n+    pub REDUNDANT_FEATURE_NAMES,\n+    cargo,\n+    \"usage of a redundant feature name\"\n+}\n+\n+declare_clippy_lint! {\n+    /// ### What it does\n+    /// Checks for negative feature names with prefix `no-` or `not-`\n+    ///\n+    /// ### Why is this bad?\n+    /// Features are supposed to be additive, and negatively-named features violate it.\n+    ///\n+    /// ### Example\n+    /// ```toml\n+    /// # The `Cargo.toml` with negative feature names\n+    /// [features]\n+    /// default = []\n+    /// no-abc = []\n+    /// not-def = []\n+    ///\n+    /// ```\n+    /// Use instead:\n+    /// ```toml\n+    /// [features]\n+    /// default = [\"abc\", \"def\"]\n+    /// abc = []\n+    /// def = []\n+    ///\n+    /// ```\n+    #[clippy::version = \"1.57.0\"]\n+    pub NEGATIVE_FEATURE_NAMES,\n+    cargo,\n+    \"usage of a negative feature name\"\n+}\n+\n+declare_clippy_lint! {\n+    /// ### What it does\n+    /// Checks to see if multiple versions of a crate are being\n+    /// used.\n+    ///\n+    /// ### Why is this bad?\n+    /// This bloats the size of targets, and can lead to\n+    /// confusing error messages when structs or traits are used interchangeably\n+    /// between different versions of a crate.\n+    ///\n+    /// ### Known problems\n+    /// Because this can be caused purely by the dependencies\n+    /// themselves, it's not always possible to fix this issue.\n+    ///\n+    /// ### Example\n+    /// ```toml\n+    /// # This will pull in both winapi v0.3.x and v0.2.x, triggering a warning.\n+    /// [dependencies]\n+    /// ctrlc = \"=3.1.0\"\n+    /// ansi_term = \"=0.11.0\"\n+    /// ```\n+    #[clippy::version = \"pre 1.29.0\"]\n+    pub MULTIPLE_CRATE_VERSIONS,\n+    cargo,\n+    \"multiple versions of the same crate being used\"\n+}\n+\n+declare_clippy_lint! {\n+    /// ### What it does\n+    /// Checks for wildcard dependencies in the `Cargo.toml`.\n+    ///\n+    /// ### Why is this bad?\n+    /// [As the edition guide says](https://rust-lang-nursery.github.io/edition-guide/rust-2018/cargo-and-crates-io/crates-io-disallows-wildcard-dependencies.html),\n+    /// it is highly unlikely that you work with any possible version of your dependency,\n+    /// and wildcard dependencies would cause unnecessary breakage in the ecosystem.\n+    ///\n+    /// ### Example\n+    /// ```toml\n+    /// [dependencies]\n+    /// regex = \"*\"\n+    /// ```\n+    #[clippy::version = \"1.32.0\"]\n+    pub WILDCARD_DEPENDENCIES,\n+    cargo,\n+    \"wildcard dependencies being used\"\n+}\n+\n+pub struct Cargo {\n+    pub ignore_publish: bool,\n+}\n+\n+impl_lint_pass!(Cargo => [\n+    CARGO_COMMON_METADATA,\n+    REDUNDANT_FEATURE_NAMES,\n+    NEGATIVE_FEATURE_NAMES,\n+    MULTIPLE_CRATE_VERSIONS,\n+    WILDCARD_DEPENDENCIES\n+]);\n+\n+impl LateLintPass<'_> for Cargo {\n+    fn check_crate(&mut self, cx: &LateContext<'_>) {\n+        static NO_DEPS_LINTS: &[&Lint] = &[\n+            CARGO_COMMON_METADATA,\n+            REDUNDANT_FEATURE_NAMES,\n+            NEGATIVE_FEATURE_NAMES,\n+            WILDCARD_DEPENDENCIES,\n+        ];\n+        static WITH_DEPS_LINTS: &[&Lint] = &[MULTIPLE_CRATE_VERSIONS];\n+\n+        if !NO_DEPS_LINTS\n+            .iter()\n+            .all(|&lint| is_lint_allowed(cx, lint, CRATE_HIR_ID))\n+        {\n+            match MetadataCommand::new().no_deps().exec() {\n+                Ok(metadata) => {\n+                    common_metadata::check(cx, &metadata, self.ignore_publish);\n+                    feature_name::check(cx, &metadata);\n+                    wildcard_dependencies::check(cx, &metadata);\n+                },\n+                Err(e) => {\n+                    for lint in NO_DEPS_LINTS {\n+                        span_lint(cx, lint, DUMMY_SP, &format!(\"could not read cargo metadata: {}\", e));\n+                    }\n+                },\n+            }\n+        }\n+\n+        if !WITH_DEPS_LINTS\n+            .iter()\n+            .all(|&lint| is_lint_allowed(cx, lint, CRATE_HIR_ID))\n+        {\n+            match MetadataCommand::new().exec() {\n+                Ok(metadata) => {\n+                    multiple_crate_versions::check(cx, &metadata);\n+                },\n+                Err(e) => {\n+                    for lint in WITH_DEPS_LINTS {\n+                        span_lint(cx, lint, DUMMY_SP, &format!(\"could not read cargo metadata: {}\", e));\n+                    }\n+                },\n+            }\n+        }\n+    }\n+}"}, {"sha": "76fd0819a39a5f5225e7b7b44feb0dfa1a1f203e", "filename": "clippy_lints/src/cargo/multiple_crate_versions.rs", "status": "added", "additions": 63, "deletions": 0, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/fd495a0654611a6d784bae4698e5838b121e8004/clippy_lints%2Fsrc%2Fcargo%2Fmultiple_crate_versions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd495a0654611a6d784bae4698e5838b121e8004/clippy_lints%2Fsrc%2Fcargo%2Fmultiple_crate_versions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fcargo%2Fmultiple_crate_versions.rs?ref=fd495a0654611a6d784bae4698e5838b121e8004", "patch": "@@ -0,0 +1,63 @@\n+//! lint on multiple versions of a crate being used\n+\n+use cargo_metadata::{DependencyKind, Metadata, Node, Package, PackageId};\n+use clippy_utils::diagnostics::span_lint;\n+use if_chain::if_chain;\n+use itertools::Itertools;\n+use rustc_hir::def_id::LOCAL_CRATE;\n+use rustc_lint::LateContext;\n+use rustc_span::source_map::DUMMY_SP;\n+\n+use super::MULTIPLE_CRATE_VERSIONS;\n+\n+pub(super) fn check(cx: &LateContext<'_>, metadata: &Metadata) {\n+    let local_name = cx.tcx.crate_name(LOCAL_CRATE);\n+    let mut packages = metadata.packages.clone();\n+    packages.sort_by(|a, b| a.name.cmp(&b.name));\n+\n+    if_chain! {\n+        if let Some(resolve) = &metadata.resolve;\n+        if let Some(local_id) = packages\n+            .iter()\n+            .find_map(|p| if p.name == local_name.as_str() { Some(&p.id) } else { None });\n+        then {\n+            for (name, group) in &packages.iter().group_by(|p| p.name.clone()) {\n+                let group: Vec<&Package> = group.collect();\n+\n+                if group.len() <= 1 {\n+                    continue;\n+                }\n+\n+                if group.iter().all(|p| is_normal_dep(&resolve.nodes, local_id, &p.id)) {\n+                    let mut versions: Vec<_> = group.into_iter().map(|p| &p.version).collect();\n+                    versions.sort();\n+                    let versions = versions.iter().join(\", \");\n+\n+                    span_lint(\n+                        cx,\n+                        MULTIPLE_CRATE_VERSIONS,\n+                        DUMMY_SP,\n+                        &format!(\"multiple versions for dependency `{}`: {}\", name, versions),\n+                    );\n+                }\n+            }\n+        }\n+    }\n+}\n+\n+fn is_normal_dep(nodes: &[Node], local_id: &PackageId, dep_id: &PackageId) -> bool {\n+    fn depends_on(node: &Node, dep_id: &PackageId) -> bool {\n+        node.deps.iter().any(|dep| {\n+            dep.pkg == *dep_id\n+                && dep\n+                    .dep_kinds\n+                    .iter()\n+                    .any(|info| matches!(info.kind, DependencyKind::Normal))\n+        })\n+    }\n+\n+    nodes\n+        .iter()\n+        .filter(|node| depends_on(node, dep_id))\n+        .any(|node| node.id == *local_id || is_normal_dep(nodes, local_id, &node.id))\n+}"}, {"sha": "7fa6acbf557b1efb7f293a9ee1947df122ee88bc", "filename": "clippy_lints/src/cargo/wildcard_dependencies.rs", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/fd495a0654611a6d784bae4698e5838b121e8004/clippy_lints%2Fsrc%2Fcargo%2Fwildcard_dependencies.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd495a0654611a6d784bae4698e5838b121e8004/clippy_lints%2Fsrc%2Fcargo%2Fwildcard_dependencies.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fcargo%2Fwildcard_dependencies.rs?ref=fd495a0654611a6d784bae4698e5838b121e8004", "patch": "@@ -0,0 +1,27 @@\n+use cargo_metadata::Metadata;\n+use clippy_utils::diagnostics::span_lint;\n+use if_chain::if_chain;\n+use rustc_lint::LateContext;\n+use rustc_span::source_map::DUMMY_SP;\n+\n+use super::WILDCARD_DEPENDENCIES;\n+\n+pub(super) fn check(cx: &LateContext<'_>, metadata: &Metadata) {\n+    for dep in &metadata.packages[0].dependencies {\n+        // VersionReq::any() does not work\n+        if_chain! {\n+            if let Ok(wildcard_ver) = semver::VersionReq::parse(\"*\");\n+            if let Some(ref source) = dep.source;\n+            if !source.starts_with(\"git\");\n+            if dep.req == wildcard_ver;\n+            then {\n+                span_lint(\n+                    cx,\n+                    WILDCARD_DEPENDENCIES,\n+                    DUMMY_SP,\n+                    &format!(\"wildcard dependency for `{}`\", dep.name),\n+                );\n+            }\n+        }\n+    }\n+}"}, {"sha": "23f79fdc68238ec24ecb1fe5dd2c6e7c08dd3279", "filename": "clippy_lints/src/cargo_common_metadata.rs", "status": "removed", "additions": 0, "deletions": 118, "changes": 118, "blob_url": "https://github.com/rust-lang/rust/blob/e390e6c46914b54ea2ffa901f3c6b046b9a7b7d4/clippy_lints%2Fsrc%2Fcargo_common_metadata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e390e6c46914b54ea2ffa901f3c6b046b9a7b7d4/clippy_lints%2Fsrc%2Fcargo_common_metadata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fcargo_common_metadata.rs?ref=e390e6c46914b54ea2ffa901f3c6b046b9a7b7d4", "patch": "@@ -1,118 +0,0 @@\n-//! lint on missing cargo common metadata\n-\n-use clippy_utils::{diagnostics::span_lint, is_lint_allowed};\n-use rustc_hir::hir_id::CRATE_HIR_ID;\n-use rustc_lint::{LateContext, LateLintPass};\n-use rustc_session::{declare_tool_lint, impl_lint_pass};\n-use rustc_span::source_map::DUMMY_SP;\n-\n-declare_clippy_lint! {\n-    /// ### What it does\n-    /// Checks to see if all common metadata is defined in\n-    /// `Cargo.toml`. See: https://rust-lang-nursery.github.io/api-guidelines/documentation.html#cargotoml-includes-all-common-metadata-c-metadata\n-    ///\n-    /// ### Why is this bad?\n-    /// It will be more difficult for users to discover the\n-    /// purpose of the crate, and key information related to it.\n-    ///\n-    /// ### Example\n-    /// ```toml\n-    /// # This `Cargo.toml` is missing a description field:\n-    /// [package]\n-    /// name = \"clippy\"\n-    /// version = \"0.0.212\"\n-    /// repository = \"https://github.com/rust-lang/rust-clippy\"\n-    /// readme = \"README.md\"\n-    /// license = \"MIT OR Apache-2.0\"\n-    /// keywords = [\"clippy\", \"lint\", \"plugin\"]\n-    /// categories = [\"development-tools\", \"development-tools::cargo-plugins\"]\n-    /// ```\n-    ///\n-    /// Should include a description field like:\n-    ///\n-    /// ```toml\n-    /// # This `Cargo.toml` includes all common metadata\n-    /// [package]\n-    /// name = \"clippy\"\n-    /// version = \"0.0.212\"\n-    /// description = \"A bunch of helpful lints to avoid common pitfalls in Rust\"\n-    /// repository = \"https://github.com/rust-lang/rust-clippy\"\n-    /// readme = \"README.md\"\n-    /// license = \"MIT OR Apache-2.0\"\n-    /// keywords = [\"clippy\", \"lint\", \"plugin\"]\n-    /// categories = [\"development-tools\", \"development-tools::cargo-plugins\"]\n-    /// ```\n-    #[clippy::version = \"1.32.0\"]\n-    pub CARGO_COMMON_METADATA,\n-    cargo,\n-    \"common metadata is defined in `Cargo.toml`\"\n-}\n-\n-#[derive(Copy, Clone, Debug)]\n-pub struct CargoCommonMetadata {\n-    ignore_publish: bool,\n-}\n-\n-impl CargoCommonMetadata {\n-    pub fn new(ignore_publish: bool) -> Self {\n-        Self { ignore_publish }\n-    }\n-}\n-\n-impl_lint_pass!(CargoCommonMetadata => [\n-    CARGO_COMMON_METADATA\n-]);\n-\n-fn missing_warning(cx: &LateContext<'_>, package: &cargo_metadata::Package, field: &str) {\n-    let message = format!(\"package `{}` is missing `{}` metadata\", package.name, field);\n-    span_lint(cx, CARGO_COMMON_METADATA, DUMMY_SP, &message);\n-}\n-\n-fn is_empty_str<T: AsRef<std::ffi::OsStr>>(value: &Option<T>) -> bool {\n-    value.as_ref().map_or(true, |s| s.as_ref().is_empty())\n-}\n-\n-fn is_empty_vec(value: &[String]) -> bool {\n-    // This works because empty iterators return true\n-    value.iter().all(String::is_empty)\n-}\n-\n-impl LateLintPass<'_> for CargoCommonMetadata {\n-    fn check_crate(&mut self, cx: &LateContext<'_>) {\n-        if is_lint_allowed(cx, CARGO_COMMON_METADATA, CRATE_HIR_ID) {\n-            return;\n-        }\n-\n-        let metadata = unwrap_cargo_metadata!(cx, CARGO_COMMON_METADATA, false);\n-\n-        for package in metadata.packages {\n-            // only run the lint if publish is `None` (`publish = true` or skipped entirely)\n-            // or if the vector isn't empty (`publish = [\"something\"]`)\n-            if package.publish.as_ref().filter(|publish| publish.is_empty()).is_none() || self.ignore_publish {\n-                if is_empty_str(&package.description) {\n-                    missing_warning(cx, &package, \"package.description\");\n-                }\n-\n-                if is_empty_str(&package.license) && is_empty_str(&package.license_file) {\n-                    missing_warning(cx, &package, \"either package.license or package.license_file\");\n-                }\n-\n-                if is_empty_str(&package.repository) {\n-                    missing_warning(cx, &package, \"package.repository\");\n-                }\n-\n-                if is_empty_str(&package.readme) {\n-                    missing_warning(cx, &package, \"package.readme\");\n-                }\n-\n-                if is_empty_vec(&package.keywords) {\n-                    missing_warning(cx, &package, \"package.keywords\");\n-                }\n-\n-                if is_empty_vec(&package.categories) {\n-                    missing_warning(cx, &package, \"package.categories\");\n-                }\n-            }\n-        }\n-    }\n-}"}, {"sha": "9b189ea1ef8fb102396b7cefa76829bcff426ee5", "filename": "clippy_lints/src/casts/cast_possible_truncation.rs", "status": "modified", "additions": 56, "deletions": 12, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/fd495a0654611a6d784bae4698e5838b121e8004/clippy_lints%2Fsrc%2Fcasts%2Fcast_possible_truncation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd495a0654611a6d784bae4698e5838b121e8004/clippy_lints%2Fsrc%2Fcasts%2Fcast_possible_truncation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fcasts%2Fcast_possible_truncation.rs?ref=fd495a0654611a6d784bae4698e5838b121e8004", "patch": "@@ -1,12 +1,15 @@\n use clippy_utils::consts::{constant, Constant};\n use clippy_utils::diagnostics::span_lint;\n use clippy_utils::expr_or_init;\n-use clippy_utils::ty::is_isize_or_usize;\n+use clippy_utils::ty::{get_discriminant_value, is_isize_or_usize};\n+use rustc_ast::ast;\n+use rustc_attr::IntType;\n+use rustc_hir::def::{DefKind, Res};\n use rustc_hir::{BinOpKind, Expr, ExprKind};\n use rustc_lint::LateContext;\n use rustc_middle::ty::{self, FloatTy, Ty};\n \n-use super::{utils, CAST_POSSIBLE_TRUNCATION};\n+use super::{utils, CAST_ENUM_TRUNCATION, CAST_POSSIBLE_TRUNCATION};\n \n fn constant_int(cx: &LateContext<'_>, expr: &Expr<'_>) -> Option<u128> {\n     if let Some((Constant::Int(c), _)) = constant(cx, cx.typeck_results(), expr) {\n@@ -75,8 +78,8 @@ fn apply_reductions(cx: &LateContext<'_>, nbits: u64, expr: &Expr<'_>, signed: b\n }\n \n pub(super) fn check(cx: &LateContext<'_>, expr: &Expr<'_>, cast_expr: &Expr<'_>, cast_from: Ty<'_>, cast_to: Ty<'_>) {\n-    let msg = match (cast_from.is_integral(), cast_to.is_integral()) {\n-        (true, true) => {\n+    let msg = match (cast_from.kind(), cast_to.is_integral()) {\n+        (ty::Int(_) | ty::Uint(_), true) => {\n             let from_nbits = apply_reductions(\n                 cx,\n                 utils::int_ty_to_nbits(cast_from, cx.tcx),\n@@ -108,19 +111,60 @@ pub(super) fn check(cx: &LateContext<'_>, expr: &Expr<'_>, cast_expr: &Expr<'_>,\n             )\n         },\n \n-        (false, true) => {\n-            format!(\"casting `{}` to `{}` may truncate the value\", cast_from, cast_to)\n-        },\n-\n-        (_, _) => {\n-            if matches!(cast_from.kind(), &ty::Float(FloatTy::F64))\n-                && matches!(cast_to.kind(), &ty::Float(FloatTy::F32))\n+        (ty::Adt(def, _), true) if def.is_enum() => {\n+            let (from_nbits, variant) = if let ExprKind::Path(p) = &cast_expr.kind\n+                && let Res::Def(DefKind::Ctor(..), id) = cx.qpath_res(p, cast_expr.hir_id)\n             {\n-                \"casting `f64` to `f32` may truncate the value\".to_string()\n+                let i = def.variant_index_with_ctor_id(id);\n+                let variant = &def.variants[i];\n+                let nbits = utils::enum_value_nbits(get_discriminant_value(cx.tcx, def, i));\n+                (nbits, Some(variant))\n             } else {\n+                (utils::enum_ty_to_nbits(def, cx.tcx), None)\n+            };\n+            let to_nbits = utils::int_ty_to_nbits(cast_to, cx.tcx);\n+\n+            let cast_from_ptr_size = def.repr.int.map_or(true, |ty| {\n+                matches!(\n+                    ty,\n+                    IntType::SignedInt(ast::IntTy::Isize) | IntType::UnsignedInt(ast::UintTy::Usize)\n+                )\n+            });\n+            let suffix = match (cast_from_ptr_size, is_isize_or_usize(cast_to)) {\n+                (false, false) if from_nbits > to_nbits => \"\",\n+                (true, false) if from_nbits > to_nbits => \"\",\n+                (false, true) if from_nbits > 64 => \"\",\n+                (false, true) if from_nbits > 32 => \" on targets with 32-bit wide pointers\",\n+                _ => return,\n+            };\n+\n+            if let Some(variant) = variant {\n+                span_lint(\n+                    cx,\n+                    CAST_ENUM_TRUNCATION,\n+                    expr.span,\n+                    &format!(\n+                        \"casting `{}::{}` to `{}` will truncate the value{}\",\n+                        cast_from, variant.name, cast_to, suffix,\n+                    ),\n+                );\n                 return;\n             }\n+            format!(\n+                \"casting `{}` to `{}` may truncate the value{}\",\n+                cast_from, cast_to, suffix,\n+            )\n         },\n+\n+        (ty::Float(_), true) => {\n+            format!(\"casting `{}` to `{}` may truncate the value\", cast_from, cast_to)\n+        },\n+\n+        (ty::Float(FloatTy::F64), false) if matches!(cast_to.kind(), &ty::Float(FloatTy::F32)) => {\n+            \"casting `f64` to `f32` may truncate the value\".to_string()\n+        },\n+\n+        _ => return,\n     };\n \n     span_lint(cx, CAST_POSSIBLE_TRUNCATION, expr.span, &msg);"}, {"sha": "a4ef1344ab9511beb75790081393d1e456c98040", "filename": "clippy_lints/src/casts/cast_ptr_alignment.rs", "status": "modified", "additions": 1, "deletions": 17, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/fd495a0654611a6d784bae4698e5838b121e8004/clippy_lints%2Fsrc%2Fcasts%2Fcast_ptr_alignment.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd495a0654611a6d784bae4698e5838b121e8004/clippy_lints%2Fsrc%2Fcasts%2Fcast_ptr_alignment.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fcasts%2Fcast_ptr_alignment.rs?ref=fd495a0654611a6d784bae4698e5838b121e8004", "patch": "@@ -1,11 +1,11 @@\n use clippy_utils::diagnostics::span_lint;\n use clippy_utils::is_hir_ty_cfg_dependant;\n+use clippy_utils::ty::is_c_void;\n use if_chain::if_chain;\n use rustc_hir::{Expr, ExprKind, GenericArg};\n use rustc_lint::LateContext;\n use rustc_middle::ty::layout::LayoutOf;\n use rustc_middle::ty::{self, Ty};\n-use rustc_span::symbol::sym;\n \n use super::CAST_PTR_ALIGNMENT;\n \n@@ -62,19 +62,3 @@ fn lint_cast_ptr_alignment<'tcx>(cx: &LateContext<'tcx>, expr: &Expr<'_>, cast_f\n         }\n     }\n }\n-\n-/// Check if the given type is either `core::ffi::c_void` or\n-/// one of the platform specific `libc::<platform>::c_void` of libc.\n-fn is_c_void(cx: &LateContext<'_>, ty: Ty<'_>) -> bool {\n-    if let ty::Adt(adt, _) = ty.kind() {\n-        let names = cx.get_def_path(adt.did);\n-\n-        if names.is_empty() {\n-            return false;\n-        }\n-        if names[0] == sym::libc || names[0] == sym::core && *names.last().unwrap() == sym!(c_void) {\n-            return true;\n-        }\n-    }\n-    false\n-}"}, {"sha": "f2077c569c04121a1232d7d3b483dc927f2069e2", "filename": "clippy_lints/src/casts/mod.rs", "status": "modified", "additions": 25, "deletions": 3, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/fd495a0654611a6d784bae4698e5838b121e8004/clippy_lints%2Fsrc%2Fcasts%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd495a0654611a6d784bae4698e5838b121e8004/clippy_lints%2Fsrc%2Fcasts%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fcasts%2Fmod.rs?ref=fd495a0654611a6d784bae4698e5838b121e8004", "patch": "@@ -390,6 +390,25 @@ declare_clippy_lint! {\n     \"casting using `as` from and to raw pointers that doesn't change its mutability, where `pointer::cast` could take the place of `as`\"\n }\n \n+declare_clippy_lint! {\n+    /// ### What it does\n+    /// Checks for casts from an enum type to an integral type which will definitely truncate the\n+    /// value.\n+    ///\n+    /// ### Why is this bad?\n+    /// The resulting integral value will not match the value of the variant it came from.\n+    ///\n+    /// ### Example\n+    /// ```rust\n+    /// enum E { X = 256 };\n+    /// let _ = E::X as u8;\n+    /// ```\n+    #[clippy::version = \"1.60.0\"]\n+    pub CAST_ENUM_TRUNCATION,\n+    suspicious,\n+    \"casts from an enum type to an integral type which will truncate the value\"\n+}\n+\n pub struct Casts {\n     msrv: Option<RustcVersion>,\n }\n@@ -415,10 +434,15 @@ impl_lint_pass!(Casts => [\n     FN_TO_NUMERIC_CAST_WITH_TRUNCATION,\n     CHAR_LIT_AS_U8,\n     PTR_AS_PTR,\n+    CAST_ENUM_TRUNCATION,\n ]);\n \n impl<'tcx> LateLintPass<'tcx> for Casts {\n     fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) {\n+        if !in_external_macro(cx.sess(), expr.span) {\n+            ptr_as_ptr::check(cx, expr, &self.msrv);\n+        }\n+\n         if expr.span.from_expansion() {\n             return;\n         }\n@@ -441,21 +465,19 @@ impl<'tcx> LateLintPass<'tcx> for Casts {\n             fn_to_numeric_cast_with_truncation::check(cx, expr, cast_expr, cast_from, cast_to);\n \n             if cast_to.is_numeric() && !in_external_macro(cx.sess(), expr.span) {\n+                cast_possible_truncation::check(cx, expr, cast_expr, cast_from, cast_to);\n                 if cast_from.is_numeric() {\n-                    cast_possible_truncation::check(cx, expr, cast_expr, cast_from, cast_to);\n                     cast_possible_wrap::check(cx, expr, cast_from, cast_to);\n                     cast_precision_loss::check(cx, expr, cast_from, cast_to);\n                     cast_sign_loss::check(cx, expr, cast_expr, cast_from, cast_to);\n                 }\n-\n                 cast_lossless::check(cx, expr, cast_expr, cast_from, cast_to, &self.msrv);\n             }\n         }\n \n         cast_ref_to_mut::check(cx, expr);\n         cast_ptr_alignment::check(cx, expr);\n         char_lit_as_u8::check(cx, expr);\n-        ptr_as_ptr::check(cx, expr, &self.msrv);\n     }\n \n     extract_msrv_attr!(LateContext);"}, {"sha": "bbed766c47a8526f45c9ec90fd34b3b6b57b18e9", "filename": "clippy_lints/src/casts/utils.rs", "status": "modified", "additions": 51, "deletions": 1, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/fd495a0654611a6d784bae4698e5838b121e8004/clippy_lints%2Fsrc%2Fcasts%2Futils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd495a0654611a6d784bae4698e5838b121e8004/clippy_lints%2Fsrc%2Fcasts%2Futils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fcasts%2Futils.rs?ref=fd495a0654611a6d784bae4698e5838b121e8004", "patch": "@@ -1,4 +1,5 @@\n-use rustc_middle::ty::{self, IntTy, Ty, TyCtxt, UintTy};\n+use clippy_utils::ty::{read_explicit_enum_value, EnumValue};\n+use rustc_middle::ty::{self, AdtDef, IntTy, Ty, TyCtxt, UintTy, VariantDiscr};\n \n /// Returns the size in bits of an integral type.\n /// Will return 0 if the type is not an int or uint variant\n@@ -23,3 +24,52 @@ pub(super) fn int_ty_to_nbits(typ: Ty<'_>, tcx: TyCtxt<'_>) -> u64 {\n         _ => 0,\n     }\n }\n+\n+pub(super) fn enum_value_nbits(value: EnumValue) -> u64 {\n+    match value {\n+        EnumValue::Unsigned(x) => 128 - x.leading_zeros(),\n+        EnumValue::Signed(x) if x < 0 => 128 - (-(x + 1)).leading_zeros() + 1,\n+        EnumValue::Signed(x) => 128 - x.leading_zeros(),\n+    }\n+    .into()\n+}\n+\n+pub(super) fn enum_ty_to_nbits(adt: &AdtDef, tcx: TyCtxt<'_>) -> u64 {\n+    let mut explicit = 0i128;\n+    let (start, end) = adt\n+        .variants\n+        .iter()\n+        .fold((0, i128::MIN), |(start, end), variant| match variant.discr {\n+            VariantDiscr::Relative(x) => match explicit.checked_add(i128::from(x)) {\n+                Some(x) => (start, end.max(x)),\n+                None => (i128::MIN, end),\n+            },\n+            VariantDiscr::Explicit(id) => match read_explicit_enum_value(tcx, id) {\n+                Some(EnumValue::Signed(x)) => {\n+                    explicit = x;\n+                    (start.min(x), end.max(x))\n+                },\n+                Some(EnumValue::Unsigned(x)) => match i128::try_from(x) {\n+                    Ok(x) => {\n+                        explicit = x;\n+                        (start, end.max(x))\n+                    },\n+                    Err(_) => (i128::MIN, end),\n+                },\n+                None => (start, end),\n+            },\n+        });\n+\n+    if start > end {\n+        // No variants.\n+        0\n+    } else {\n+        let neg_bits = if start < 0 {\n+            128 - (-(start + 1)).leading_zeros() + 1\n+        } else {\n+            0\n+        };\n+        let pos_bits = if end > 0 { 128 - end.leading_zeros() } else { 0 };\n+        neg_bits.max(pos_bits).into()\n+    }\n+}"}, {"sha": "df1a4128af35957aa8cb5bf8fa02d37b905611cd", "filename": "clippy_lints/src/dbg_macro.rs", "status": "modified", "additions": 52, "deletions": 45, "changes": 97, "blob_url": "https://github.com/rust-lang/rust/blob/fd495a0654611a6d784bae4698e5838b121e8004/clippy_lints%2Fsrc%2Fdbg_macro.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd495a0654611a6d784bae4698e5838b121e8004/clippy_lints%2Fsrc%2Fdbg_macro.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fdbg_macro.rs?ref=fd495a0654611a6d784bae4698e5838b121e8004", "patch": "@@ -1,11 +1,11 @@\n-use clippy_utils::diagnostics::{span_lint_and_help, span_lint_and_sugg};\n-use clippy_utils::source::snippet_opt;\n-use rustc_ast::ast;\n-use rustc_ast::tokenstream::TokenStream;\n+use clippy_utils::diagnostics::span_lint_and_sugg;\n+use clippy_utils::macros::root_macro_call_first_node;\n+use clippy_utils::source::snippet_with_applicability;\n use rustc_errors::Applicability;\n-use rustc_lint::{EarlyContext, EarlyLintPass};\n+use rustc_hir::{Expr, ExprKind};\n+use rustc_lint::{LateContext, LateLintPass};\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n-use rustc_span::source_map::Span;\n+use rustc_span::sym;\n \n declare_clippy_lint! {\n     /// ### What it does\n@@ -15,14 +15,6 @@ declare_clippy_lint! {\n     /// `dbg!` macro is intended as a debugging tool. It\n     /// should not be in version control.\n     ///\n-    /// ### Known problems\n-    /// * The lint level is unaffected by crate attributes. The level can still\n-    ///   be set for functions, modules and other items. To change the level for\n-    ///   the entire crate, please use command line flags. More information and a\n-    ///   configuration example can be found in [clippy#6610].\n-    ///\n-    /// [clippy#6610]: https://github.com/rust-lang/rust-clippy/issues/6610#issuecomment-977120558\n-    ///\n     /// ### Example\n     /// ```rust,ignore\n     /// // Bad\n@@ -39,37 +31,52 @@ declare_clippy_lint! {\n \n declare_lint_pass!(DbgMacro => [DBG_MACRO]);\n \n-impl EarlyLintPass for DbgMacro {\n-    fn check_mac(&mut self, cx: &EarlyContext<'_>, mac: &ast::MacCall) {\n-        if mac.path == sym!(dbg) {\n-            if let Some(sugg) = tts_span(mac.args.inner_tokens()).and_then(|span| snippet_opt(cx, span)) {\n-                span_lint_and_sugg(\n-                    cx,\n-                    DBG_MACRO,\n-                    mac.span(),\n-                    \"`dbg!` macro is intended as a debugging tool\",\n-                    \"ensure to avoid having uses of it in version control\",\n-                    sugg,\n-                    Applicability::MaybeIncorrect,\n-                );\n-            } else {\n-                span_lint_and_help(\n-                    cx,\n-                    DBG_MACRO,\n-                    mac.span(),\n-                    \"`dbg!` macro is intended as a debugging tool\",\n-                    None,\n-                    \"ensure to avoid having uses of it in version control\",\n-                );\n-            }\n+impl LateLintPass<'_> for DbgMacro {\n+    fn check_expr(&mut self, cx: &LateContext<'_>, expr: &Expr<'_>) {\n+        let Some(macro_call) = root_macro_call_first_node(cx, expr) else { return };\n+        if cx.tcx.is_diagnostic_item(sym::dbg_macro, macro_call.def_id) {\n+            let mut applicability = Applicability::MachineApplicable;\n+            let suggestion = match expr.peel_drop_temps().kind {\n+                // dbg!()\n+                ExprKind::Block(_, _) => String::new(),\n+                // dbg!(1)\n+                ExprKind::Match(val, ..) => {\n+                    snippet_with_applicability(cx, val.span.source_callsite(), \"..\", &mut applicability).to_string()\n+                },\n+                // dbg!(2, 3)\n+                ExprKind::Tup(\n+                    [\n+                        Expr {\n+                            kind: ExprKind::Match(first, ..),\n+                            ..\n+                        },\n+                        ..,\n+                        Expr {\n+                            kind: ExprKind::Match(last, ..),\n+                            ..\n+                        },\n+                    ],\n+                ) => {\n+                    let snippet = snippet_with_applicability(\n+                        cx,\n+                        first.span.source_callsite().to(last.span.source_callsite()),\n+                        \"..\",\n+                        &mut applicability,\n+                    );\n+                    format!(\"({snippet})\")\n+                },\n+                _ => return,\n+            };\n+\n+            span_lint_and_sugg(\n+                cx,\n+                DBG_MACRO,\n+                macro_call.span,\n+                \"`dbg!` macro is intended as a debugging tool\",\n+                \"ensure to avoid having uses of it in version control\",\n+                suggestion,\n+                applicability,\n+            );\n         }\n     }\n }\n-\n-// Get span enclosing entire the token stream.\n-fn tts_span(tts: TokenStream) -> Option<Span> {\n-    let mut cursor = tts.into_trees();\n-    let first = cursor.next()?.span();\n-    let span = cursor.last().map_or(first, |tree| first.to(tree.span()));\n-    Some(span)\n-}"}, {"sha": "06e6bf986c2a9458e6417ec0ec9fe2991bed7626", "filename": "clippy_lints/src/default.rs", "status": "modified", "additions": 15, "deletions": 1, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/fd495a0654611a6d784bae4698e5838b121e8004/clippy_lints%2Fsrc%2Fdefault.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd495a0654611a6d784bae4698e5838b121e8004/clippy_lints%2Fsrc%2Fdefault.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fdefault.rs?ref=fd495a0654611a6d784bae4698e5838b121e8004", "patch": "@@ -1,7 +1,7 @@\n use clippy_utils::diagnostics::{span_lint_and_note, span_lint_and_sugg};\n use clippy_utils::source::snippet_with_macro_callsite;\n use clippy_utils::ty::{has_drop, is_copy};\n-use clippy_utils::{any_parent_is_automatically_derived, contains_name, match_def_path, paths};\n+use clippy_utils::{any_parent_is_automatically_derived, contains_name, get_parent_expr, match_def_path, paths};\n use if_chain::if_chain;\n use rustc_data_structures::fx::FxHashSet;\n use rustc_errors::Applicability;\n@@ -88,6 +88,7 @@ impl<'tcx> LateLintPass<'tcx> for Default {\n             if let ExprKind::Path(ref qpath) = path.kind;\n             if let Some(def_id) = cx.qpath_res(qpath, path.hir_id).opt_def_id();\n             if match_def_path(cx, def_id, &paths::DEFAULT_TRAIT_METHOD);\n+            if !is_update_syntax_base(cx, expr);\n             // Detect and ignore <Foo as Default>::default() because these calls do explicitly name the type.\n             if let QPath::Resolved(None, _path) = qpath;\n             let expr_ty = cx.typeck_results().expr_ty(expr);\n@@ -290,3 +291,16 @@ fn field_reassigned_by_stmt<'tcx>(this: &Stmt<'tcx>, binding_name: Symbol) -> Op\n         }\n     }\n }\n+\n+/// Returns whether `expr` is the update syntax base: `Foo { a: 1, .. base }`\n+fn is_update_syntax_base<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) -> bool {\n+    if_chain! {\n+        if let Some(parent) = get_parent_expr(cx, expr);\n+        if let ExprKind::Struct(_, _, Some(base)) = parent.kind;\n+        then {\n+            base.hir_id == expr.hir_id\n+        } else {\n+            false\n+        }\n+    }\n+}"}, {"sha": "7277e4080c5c0763ffa132a28a48dc4fd394486d", "filename": "clippy_lints/src/derive.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/fd495a0654611a6d784bae4698e5838b121e8004/clippy_lints%2Fsrc%2Fderive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd495a0654611a6d784bae4698e5838b121e8004/clippy_lints%2Fsrc%2Fderive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fderive.rs?ref=fd495a0654611a6d784bae4698e5838b121e8004", "patch": "@@ -1,7 +1,7 @@\n use clippy_utils::diagnostics::{span_lint_and_help, span_lint_and_note, span_lint_and_then};\n use clippy_utils::paths;\n use clippy_utils::ty::{implements_trait, is_copy};\n-use clippy_utils::{get_trait_def_id, is_automatically_derived, is_lint_allowed, match_def_path};\n+use clippy_utils::{is_automatically_derived, is_lint_allowed, match_def_path};\n use if_chain::if_chain;\n use rustc_hir::intravisit::{walk_expr, walk_fn, walk_item, FnKind, Visitor};\n use rustc_hir::{\n@@ -12,6 +12,7 @@ use rustc_middle::hir::nested_filter;\n use rustc_middle::ty::{self, Ty};\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n use rustc_span::source_map::Span;\n+use rustc_span::sym;\n \n declare_clippy_lint! {\n     /// ### What it does\n@@ -196,7 +197,7 @@ fn check_hash_peq<'tcx>(\n     if_chain! {\n         if let Some(peq_trait_def_id) = cx.tcx.lang_items().eq_trait();\n         if let Some(def_id) = trait_ref.trait_def_id();\n-        if match_def_path(cx, def_id, &paths::HASH);\n+        if cx.tcx.is_diagnostic_item(sym::Hash, def_id);\n         then {\n             // Look for the PartialEq implementations for `ty`\n             cx.tcx.for_each_relevant_impl(peq_trait_def_id, ty, |impl_id| {\n@@ -247,7 +248,7 @@ fn check_ord_partial_ord<'tcx>(\n     ord_is_automatically_derived: bool,\n ) {\n     if_chain! {\n-        if let Some(ord_trait_def_id) = get_trait_def_id(cx, &paths::ORD);\n+        if let Some(ord_trait_def_id) = cx.tcx.get_diagnostic_item(sym::Ord);\n         if let Some(partial_ord_trait_def_id) = cx.tcx.lang_items().partial_ord_trait();\n         if let Some(def_id) = &trait_ref.trait_def_id();\n         if *def_id == ord_trait_def_id;"}, {"sha": "09318f74527c2bf16485add7c10f1cf70981f30e", "filename": "clippy_lints/src/duration_subsec.rs", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/fd495a0654611a6d784bae4698e5838b121e8004/clippy_lints%2Fsrc%2Fduration_subsec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd495a0654611a6d784bae4698e5838b121e8004/clippy_lints%2Fsrc%2Fduration_subsec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fduration_subsec.rs?ref=fd495a0654611a6d784bae4698e5838b121e8004", "patch": "@@ -1,15 +1,14 @@\n+use clippy_utils::consts::{constant, Constant};\n+use clippy_utils::diagnostics::span_lint_and_sugg;\n use clippy_utils::source::snippet_with_applicability;\n-use clippy_utils::ty::match_type;\n+use clippy_utils::ty::is_type_diagnostic_item;\n use if_chain::if_chain;\n use rustc_errors::Applicability;\n use rustc_hir::{BinOpKind, Expr, ExprKind};\n use rustc_lint::{LateContext, LateLintPass};\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n use rustc_span::source_map::Spanned;\n-\n-use clippy_utils::consts::{constant, Constant};\n-use clippy_utils::diagnostics::span_lint_and_sugg;\n-use clippy_utils::paths;\n+use rustc_span::sym;\n \n declare_clippy_lint! {\n     /// ### What it does\n@@ -46,7 +45,7 @@ impl<'tcx> LateLintPass<'tcx> for DurationSubsec {\n         if_chain! {\n             if let ExprKind::Binary(Spanned { node: BinOpKind::Div, .. }, left, right) = expr.kind;\n             if let ExprKind::MethodCall(method_path, args, _) = left.kind;\n-            if match_type(cx, cx.typeck_results().expr_ty(&args[0]).peel_refs(), &paths::DURATION);\n+            if is_type_diagnostic_item(cx, cx.typeck_results().expr_ty(&args[0]).peel_refs(), sym::Duration);\n             if let Some((Constant::Int(divisor), _)) = constant(cx, cx.typeck_results(), right);\n             then {\n                 let suggested_fn = match (method_path.ident.as_str(), divisor) {"}, {"sha": "6490231fed8a7195ee6c1b9cd62ed1554d43cac0", "filename": "clippy_lints/src/eq_op.rs", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/fd495a0654611a6d784bae4698e5838b121e8004/clippy_lints%2Fsrc%2Feq_op.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd495a0654611a6d784bae4698e5838b121e8004/clippy_lints%2Fsrc%2Feq_op.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Feq_op.rs?ref=fd495a0654611a6d784bae4698e5838b121e8004", "patch": "@@ -6,9 +6,7 @@ use clippy_utils::ty::{implements_trait, is_copy};\n use clippy_utils::{ast_utils::is_useless_with_eq_exprs, eq_expr_value, is_in_test_function};\n use if_chain::if_chain;\n use rustc_errors::Applicability;\n-use rustc_hir::{\n-    def::Res, def_id::DefId, BinOpKind, BorrowKind, Expr, ExprKind, GenericArg, ItemKind, QPath, TyKind,\n-};\n+use rustc_hir::{def::Res, def_id::DefId, BinOpKind, BorrowKind, Expr, ExprKind, GenericArg, ItemKind, QPath, TyKind};\n use rustc_lint::{LateContext, LateLintPass};\n use rustc_middle::ty::{self, Ty};\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n@@ -279,7 +277,11 @@ impl<'tcx> LateLintPass<'tcx> for EqOp {\n     }\n }\n \n-fn in_impl<'tcx>(cx: &LateContext<'tcx>, e: &'tcx Expr<'_>, bin_op: DefId) -> Option<(&'tcx rustc_hir::Ty<'tcx>, &'tcx rustc_hir::Ty<'tcx>)> {\n+fn in_impl<'tcx>(\n+    cx: &LateContext<'tcx>,\n+    e: &'tcx Expr<'_>,\n+    bin_op: DefId,\n+) -> Option<(&'tcx rustc_hir::Ty<'tcx>, &'tcx rustc_hir::Ty<'tcx>)> {\n     if_chain! {\n         if let Some(block) = get_enclosing_block(cx, e.hir_id);\n         if let Some(impl_def_id) = cx.tcx.impl_of_method(block.hir_id.owner.to_def_id());"}, {"sha": "d23c0c225e192e84fc4ad27b0e6a5d3ac613713d", "filename": "clippy_lints/src/eta_reduction.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/fd495a0654611a6d784bae4698e5838b121e8004/clippy_lints%2Fsrc%2Feta_reduction.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd495a0654611a6d784bae4698e5838b121e8004/clippy_lints%2Fsrc%2Feta_reduction.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Feta_reduction.rs?ref=fd495a0654611a6d784bae4698e5838b121e8004", "patch": "@@ -10,6 +10,7 @@ use rustc_hir::def_id::DefId;\n use rustc_hir::{Expr, ExprKind, Param, PatKind, Unsafety};\n use rustc_lint::{LateContext, LateLintPass};\n use rustc_middle::ty::adjustment::{Adjust, Adjustment, AutoBorrow};\n+use rustc_middle::ty::binding::BindingMode;\n use rustc_middle::ty::subst::Subst;\n use rustc_middle::ty::{self, ClosureKind, Ty, TypeFoldable};\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n@@ -169,11 +170,17 @@ fn check_inputs(cx: &LateContext<'_>, params: &[Param<'_>], call_args: &[Expr<'_\n     if params.len() != call_args.len() {\n         return false;\n     }\n+    let binding_modes = cx.typeck_results().pat_binding_modes();\n     std::iter::zip(params, call_args).all(|(param, arg)| {\n         match param.pat.kind {\n             PatKind::Binding(_, id, ..) if path_to_local_id(arg, id) => {},\n             _ => return false,\n         }\n+        // checks that parameters are not bound as `ref` or `ref mut`\n+        if let Some(BindingMode::BindByReference(_)) = binding_modes.get(param.pat.hir_id) {\n+            return false;\n+        }\n+\n         match *cx.typeck_results().expr_adjustments(arg) {\n             [] => true,\n             ["}, {"sha": "dc6bef52ddd9fb3256168e3cec80fd9a2bfb0af1", "filename": "clippy_lints/src/feature_name.rs", "status": "removed", "additions": 0, "deletions": 166, "changes": 166, "blob_url": "https://github.com/rust-lang/rust/blob/e390e6c46914b54ea2ffa901f3c6b046b9a7b7d4/clippy_lints%2Fsrc%2Ffeature_name.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e390e6c46914b54ea2ffa901f3c6b046b9a7b7d4/clippy_lints%2Fsrc%2Ffeature_name.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Ffeature_name.rs?ref=e390e6c46914b54ea2ffa901f3c6b046b9a7b7d4", "patch": "@@ -1,166 +0,0 @@\n-use clippy_utils::diagnostics::span_lint_and_help;\n-use clippy_utils::{diagnostics::span_lint, is_lint_allowed};\n-use rustc_hir::CRATE_HIR_ID;\n-use rustc_lint::{LateContext, LateLintPass};\n-use rustc_session::{declare_lint_pass, declare_tool_lint};\n-use rustc_span::source_map::DUMMY_SP;\n-\n-declare_clippy_lint! {\n-    /// ### What it does\n-    /// Checks for feature names with prefix `use-`, `with-` or suffix `-support`\n-    ///\n-    /// ### Why is this bad?\n-    /// These prefixes and suffixes have no significant meaning.\n-    ///\n-    /// ### Example\n-    /// ```toml\n-    /// # The `Cargo.toml` with feature name redundancy\n-    /// [features]\n-    /// default = [\"use-abc\", \"with-def\", \"ghi-support\"]\n-    /// use-abc = []  // redundant\n-    /// with-def = []   // redundant\n-    /// ghi-support = []   // redundant\n-    /// ```\n-    ///\n-    /// Use instead:\n-    /// ```toml\n-    /// [features]\n-    /// default = [\"abc\", \"def\", \"ghi\"]\n-    /// abc = []\n-    /// def = []\n-    /// ghi = []\n-    /// ```\n-    ///\n-    #[clippy::version = \"1.57.0\"]\n-    pub REDUNDANT_FEATURE_NAMES,\n-    cargo,\n-    \"usage of a redundant feature name\"\n-}\n-\n-declare_clippy_lint! {\n-    /// ### What it does\n-    /// Checks for negative feature names with prefix `no-` or `not-`\n-    ///\n-    /// ### Why is this bad?\n-    /// Features are supposed to be additive, and negatively-named features violate it.\n-    ///\n-    /// ### Example\n-    /// ```toml\n-    /// # The `Cargo.toml` with negative feature names\n-    /// [features]\n-    /// default = []\n-    /// no-abc = []\n-    /// not-def = []\n-    ///\n-    /// ```\n-    /// Use instead:\n-    /// ```toml\n-    /// [features]\n-    /// default = [\"abc\", \"def\"]\n-    /// abc = []\n-    /// def = []\n-    ///\n-    /// ```\n-    #[clippy::version = \"1.57.0\"]\n-    pub NEGATIVE_FEATURE_NAMES,\n-    cargo,\n-    \"usage of a negative feature name\"\n-}\n-\n-declare_lint_pass!(FeatureName => [REDUNDANT_FEATURE_NAMES, NEGATIVE_FEATURE_NAMES]);\n-\n-static PREFIXES: [&str; 8] = [\"no-\", \"no_\", \"not-\", \"not_\", \"use-\", \"use_\", \"with-\", \"with_\"];\n-static SUFFIXES: [&str; 2] = [\"-support\", \"_support\"];\n-\n-fn is_negative_prefix(s: &str) -> bool {\n-    s.starts_with(\"no\")\n-}\n-\n-fn lint(cx: &LateContext<'_>, feature: &str, substring: &str, is_prefix: bool) {\n-    let is_negative = is_prefix && is_negative_prefix(substring);\n-    span_lint_and_help(\n-        cx,\n-        if is_negative {\n-            NEGATIVE_FEATURE_NAMES\n-        } else {\n-            REDUNDANT_FEATURE_NAMES\n-        },\n-        DUMMY_SP,\n-        &format!(\n-            \"the \\\"{}\\\" {} in the feature name \\\"{}\\\" is {}\",\n-            substring,\n-            if is_prefix { \"prefix\" } else { \"suffix\" },\n-            feature,\n-            if is_negative { \"negative\" } else { \"redundant\" }\n-        ),\n-        None,\n-        &format!(\n-            \"consider renaming the feature to \\\"{}\\\"{}\",\n-            if is_prefix {\n-                feature.strip_prefix(substring)\n-            } else {\n-                feature.strip_suffix(substring)\n-            }\n-            .unwrap(),\n-            if is_negative {\n-                \", but make sure the feature adds functionality\"\n-            } else {\n-                \"\"\n-            }\n-        ),\n-    );\n-}\n-\n-impl LateLintPass<'_> for FeatureName {\n-    fn check_crate(&mut self, cx: &LateContext<'_>) {\n-        if is_lint_allowed(cx, REDUNDANT_FEATURE_NAMES, CRATE_HIR_ID)\n-            && is_lint_allowed(cx, NEGATIVE_FEATURE_NAMES, CRATE_HIR_ID)\n-        {\n-            return;\n-        }\n-\n-        let metadata = unwrap_cargo_metadata!(cx, REDUNDANT_FEATURE_NAMES, false);\n-\n-        for package in metadata.packages {\n-            let mut features: Vec<&String> = package.features.keys().collect();\n-            features.sort();\n-            for feature in features {\n-                let prefix_opt = {\n-                    let i = PREFIXES.partition_point(|prefix| prefix < &feature.as_str());\n-                    if i > 0 && feature.starts_with(PREFIXES[i - 1]) {\n-                        Some(PREFIXES[i - 1])\n-                    } else {\n-                        None\n-                    }\n-                };\n-                if let Some(prefix) = prefix_opt {\n-                    lint(cx, feature, prefix, true);\n-                }\n-\n-                let suffix_opt: Option<&str> = {\n-                    let i = SUFFIXES.partition_point(|suffix| {\n-                        suffix.bytes().rev().cmp(feature.bytes().rev()) == std::cmp::Ordering::Less\n-                    });\n-                    if i > 0 && feature.ends_with(SUFFIXES[i - 1]) {\n-                        Some(SUFFIXES[i - 1])\n-                    } else {\n-                        None\n-                    }\n-                };\n-                if let Some(suffix) = suffix_opt {\n-                    lint(cx, feature, suffix, false);\n-                }\n-            }\n-        }\n-    }\n-}\n-\n-#[test]\n-fn test_prefixes_sorted() {\n-    let mut sorted_prefixes = PREFIXES;\n-    sorted_prefixes.sort_unstable();\n-    assert_eq!(PREFIXES, sorted_prefixes);\n-    let mut sorted_suffixes = SUFFIXES;\n-    sorted_suffixes.sort_by(|a, b| a.bytes().rev().cmp(b.bytes().rev()));\n-    assert_eq!(SUFFIXES, sorted_suffixes);\n-}"}, {"sha": "1e6feaac26c3ab77e604572bd461efcc27803ca3", "filename": "clippy_lints/src/format_args.rs", "status": "modified", "additions": 3, "deletions": 23, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/fd495a0654611a6d784bae4698e5838b121e8004/clippy_lints%2Fsrc%2Fformat_args.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd495a0654611a6d784bae4698e5838b121e8004/clippy_lints%2Fsrc%2Fformat_args.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fformat_args.rs?ref=fd495a0654611a6d784bae4698e5838b121e8004", "patch": "@@ -1,8 +1,8 @@\n use clippy_utils::diagnostics::{span_lint_and_sugg, span_lint_and_then};\n-use clippy_utils::macros::{FormatArgsArg, FormatArgsExpn};\n+use clippy_utils::is_diag_trait_item;\n+use clippy_utils::macros::{is_format_macro, FormatArgsArg, FormatArgsExpn};\n use clippy_utils::source::snippet_opt;\n use clippy_utils::ty::implements_trait;\n-use clippy_utils::{is_diag_trait_item, match_def_path, paths};\n use if_chain::if_chain;\n use rustc_errors::Applicability;\n use rustc_hir::{Expr, ExprKind};\n@@ -65,34 +65,14 @@ declare_clippy_lint! {\n \n declare_lint_pass!(FormatArgs => [FORMAT_IN_FORMAT_ARGS, TO_STRING_IN_FORMAT_ARGS]);\n \n-const FORMAT_MACRO_PATHS: &[&[&str]] = &[\n-    &paths::FORMAT_ARGS_MACRO,\n-    &paths::ASSERT_EQ_MACRO,\n-    &paths::ASSERT_MACRO,\n-    &paths::ASSERT_NE_MACRO,\n-    &paths::EPRINT_MACRO,\n-    &paths::EPRINTLN_MACRO,\n-    &paths::PRINT_MACRO,\n-    &paths::PRINTLN_MACRO,\n-    &paths::WRITE_MACRO,\n-    &paths::WRITELN_MACRO,\n-];\n-\n-const FORMAT_MACRO_DIAG_ITEMS: &[Symbol] = &[sym::format_macro, sym::std_panic_macro];\n-\n impl<'tcx> LateLintPass<'tcx> for FormatArgs {\n     fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &'tcx Expr<'tcx>) {\n         if_chain! {\n             if let Some(format_args) = FormatArgsExpn::parse(cx, expr);\n             let expr_expn_data = expr.span.ctxt().outer_expn_data();\n             let outermost_expn_data = outermost_expn_data(expr_expn_data);\n             if let Some(macro_def_id) = outermost_expn_data.macro_def_id;\n-            if FORMAT_MACRO_PATHS\n-                .iter()\n-                .any(|path| match_def_path(cx, macro_def_id, path))\n-                || FORMAT_MACRO_DIAG_ITEMS\n-                    .iter()\n-                    .any(|diag_item| cx.tcx.is_diagnostic_item(*diag_item, macro_def_id));\n+            if is_format_macro(cx, macro_def_id);\n             if let ExpnKind::Macro(_, name) = outermost_expn_data.kind;\n             if let Some(args) = format_args.args();\n             then {"}, {"sha": "b2b9889f5dc74c21431c6bac8c98d842849044b7", "filename": "clippy_lints/src/infinite_iter.rs", "status": "modified", "additions": 7, "deletions": 4, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/fd495a0654611a6d784bae4698e5838b121e8004/clippy_lints%2Fsrc%2Finfinite_iter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd495a0654611a6d784bae4698e5838b121e8004/clippy_lints%2Fsrc%2Finfinite_iter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Finfinite_iter.rs?ref=fd495a0654611a6d784bae4698e5838b121e8004", "patch": "@@ -1,6 +1,6 @@\n use clippy_utils::diagnostics::span_lint;\n use clippy_utils::ty::{implements_trait, is_type_diagnostic_item};\n-use clippy_utils::{get_trait_def_id, higher, match_def_path, path_def_id, paths};\n+use clippy_utils::{higher, match_def_path, path_def_id, paths};\n use rustc_hir::{BorrowKind, Expr, ExprKind};\n use rustc_lint::{LateContext, LateLintPass};\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n@@ -229,9 +229,12 @@ fn complete_infinite_iter(cx: &LateContext<'_>, expr: &Expr<'_>) -> Finiteness {\n                 }\n             }\n             if method.ident.name == sym!(last) && args.len() == 1 {\n-                let not_double_ended = get_trait_def_id(cx, &paths::DOUBLE_ENDED_ITERATOR).map_or(false, |id| {\n-                    !implements_trait(cx, cx.typeck_results().expr_ty(&args[0]), id, &[])\n-                });\n+                let not_double_ended = cx\n+                    .tcx\n+                    .get_diagnostic_item(sym::DoubleEndedIterator)\n+                    .map_or(false, |id| {\n+                        !implements_trait(cx, cx.typeck_results().expr_ty(&args[0]), id, &[])\n+                    });\n                 if not_double_ended {\n                     return is_infinite(cx, &args[0]);\n                 }"}, {"sha": "c6f8470cd7db72cd6531ec12d80552ddf7f1cfd8", "filename": "clippy_lints/src/lib.register_all.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/fd495a0654611a6d784bae4698e5838b121e8004/clippy_lints%2Fsrc%2Flib.register_all.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd495a0654611a6d784bae4698e5838b121e8004/clippy_lints%2Fsrc%2Flib.register_all.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flib.register_all.rs?ref=fd495a0654611a6d784bae4698e5838b121e8004", "patch": "@@ -14,13 +14,16 @@ store.register_group(true, \"clippy::all\", Some(\"clippy_all\"), vec![\n     LintId::of(attrs::DEPRECATED_SEMVER),\n     LintId::of(attrs::MISMATCHED_TARGET_OS),\n     LintId::of(attrs::USELESS_ATTRIBUTE),\n+    LintId::of(await_holding_invalid::AWAIT_HOLDING_LOCK),\n+    LintId::of(await_holding_invalid::AWAIT_HOLDING_REFCELL_REF),\n     LintId::of(bit_mask::BAD_BIT_MASK),\n     LintId::of(bit_mask::INEFFECTIVE_BIT_MASK),\n     LintId::of(blacklisted_name::BLACKLISTED_NAME),\n     LintId::of(blocks_in_if_conditions::BLOCKS_IN_IF_CONDITIONS),\n     LintId::of(bool_assert_comparison::BOOL_ASSERT_COMPARISON),\n     LintId::of(booleans::LOGIC_BUG),\n     LintId::of(booleans::NONMINIMAL_BOOL),\n+    LintId::of(casts::CAST_ENUM_TRUNCATION),\n     LintId::of(casts::CAST_REF_TO_MUT),\n     LintId::of(casts::CHAR_LIT_AS_U8),\n     LintId::of(casts::FN_TO_NUMERIC_CAST),\n@@ -241,6 +244,7 @@ store.register_group(true, \"clippy::all\", Some(\"clippy_all\"), vec![\n     LintId::of(ranges::MANUAL_RANGE_CONTAINS),\n     LintId::of(ranges::RANGE_ZIP_WITH_LEN),\n     LintId::of(ranges::REVERSED_EMPTY_RANGES),\n+    LintId::of(recursive_format_impl::RECURSIVE_FORMAT_IMPL),\n     LintId::of(redundant_clone::REDUNDANT_CLONE),\n     LintId::of(redundant_closure_call::REDUNDANT_CLOSURE_CALL),\n     LintId::of(redundant_field_names::REDUNDANT_FIELD_NAMES),\n@@ -267,7 +271,6 @@ store.register_group(true, \"clippy::all\", Some(\"clippy_all\"), vec![\n     LintId::of(tabs_in_doc_comments::TABS_IN_DOC_COMMENTS),\n     LintId::of(temporary_assignment::TEMPORARY_ASSIGNMENT),\n     LintId::of(to_digit_is_some::TO_DIGIT_IS_SOME),\n-    LintId::of(to_string_in_display::TO_STRING_IN_DISPLAY),\n     LintId::of(transmute::CROSSPOINTER_TRANSMUTE),\n     LintId::of(transmute::TRANSMUTES_EXPRESSIBLE_AS_PTR_CASTS),\n     LintId::of(transmute::TRANSMUTE_BYTES_TO_STR),\n@@ -277,6 +280,7 @@ store.register_group(true, \"clippy::all\", Some(\"clippy_all\"), vec![\n     LintId::of(transmute::TRANSMUTE_INT_TO_FLOAT),\n     LintId::of(transmute::TRANSMUTE_NUM_TO_BYTES),\n     LintId::of(transmute::TRANSMUTE_PTR_TO_REF),\n+    LintId::of(transmute::TRANSMUTE_UNDEFINED_REPR),\n     LintId::of(transmute::UNSOUND_COLLECTION_TRANSMUTE),\n     LintId::of(transmute::WRONG_TRANSMUTE),\n     LintId::of(transmuting_null::TRANSMUTING_NULL),"}, {"sha": "c890523fe5aebc1808dba4de08d1d4956f2fca28", "filename": "clippy_lints/src/lib.register_cargo.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/fd495a0654611a6d784bae4698e5838b121e8004/clippy_lints%2Fsrc%2Flib.register_cargo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd495a0654611a6d784bae4698e5838b121e8004/clippy_lints%2Fsrc%2Flib.register_cargo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flib.register_cargo.rs?ref=fd495a0654611a6d784bae4698e5838b121e8004", "patch": "@@ -3,9 +3,9 @@\n // Manual edits will be overwritten.\n \n store.register_group(true, \"clippy::cargo\", Some(\"clippy_cargo\"), vec![\n-    LintId::of(cargo_common_metadata::CARGO_COMMON_METADATA),\n-    LintId::of(feature_name::NEGATIVE_FEATURE_NAMES),\n-    LintId::of(feature_name::REDUNDANT_FEATURE_NAMES),\n-    LintId::of(multiple_crate_versions::MULTIPLE_CRATE_VERSIONS),\n-    LintId::of(wildcard_dependencies::WILDCARD_DEPENDENCIES),\n+    LintId::of(cargo::CARGO_COMMON_METADATA),\n+    LintId::of(cargo::MULTIPLE_CRATE_VERSIONS),\n+    LintId::of(cargo::NEGATIVE_FEATURE_NAMES),\n+    LintId::of(cargo::REDUNDANT_FEATURE_NAMES),\n+    LintId::of(cargo::WILDCARD_DEPENDENCIES),\n ])"}, {"sha": "18fe44282ed0e70020a8f456db67d1da00a558d6", "filename": "clippy_lints/src/lib.register_correctness.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/fd495a0654611a6d784bae4698e5838b121e8004/clippy_lints%2Fsrc%2Flib.register_correctness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd495a0654611a6d784bae4698e5838b121e8004/clippy_lints%2Fsrc%2Flib.register_correctness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flib.register_correctness.rs?ref=fd495a0654611a6d784bae4698e5838b121e8004", "patch": "@@ -52,12 +52,13 @@ store.register_group(true, \"clippy::correctness\", Some(\"clippy_correctness\"), ve\n     LintId::of(ptr::INVALID_NULL_PTR_USAGE),\n     LintId::of(ptr::MUT_FROM_REF),\n     LintId::of(ranges::REVERSED_EMPTY_RANGES),\n+    LintId::of(recursive_format_impl::RECURSIVE_FORMAT_IMPL),\n     LintId::of(regex::INVALID_REGEX),\n     LintId::of(self_assignment::SELF_ASSIGNMENT),\n     LintId::of(serde_api::SERDE_API_MISUSE),\n     LintId::of(size_of_in_element_count::SIZE_OF_IN_ELEMENT_COUNT),\n     LintId::of(swap::ALMOST_SWAPPED),\n-    LintId::of(to_string_in_display::TO_STRING_IN_DISPLAY),\n+    LintId::of(transmute::TRANSMUTE_UNDEFINED_REPR),\n     LintId::of(transmute::UNSOUND_COLLECTION_TRANSMUTE),\n     LintId::of(transmute::WRONG_TRANSMUTE),\n     LintId::of(transmuting_null::TRANSMUTING_NULL),"}, {"sha": "75ef1b0a9d511125944d69610376da6e0ac5dad1", "filename": "clippy_lints/src/lib.register_lints.rs", "status": "modified", "additions": 8, "deletions": 6, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/fd495a0654611a6d784bae4698e5838b121e8004/clippy_lints%2Fsrc%2Flib.register_lints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd495a0654611a6d784bae4698e5838b121e8004/clippy_lints%2Fsrc%2Flib.register_lints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flib.register_lints.rs?ref=fd495a0654611a6d784bae4698e5838b121e8004", "patch": "@@ -61,8 +61,13 @@ store.register_lints(&[\n     booleans::NONMINIMAL_BOOL,\n     borrow_as_ptr::BORROW_AS_PTR,\n     bytecount::NAIVE_BYTECOUNT,\n-    cargo_common_metadata::CARGO_COMMON_METADATA,\n+    cargo::CARGO_COMMON_METADATA,\n+    cargo::MULTIPLE_CRATE_VERSIONS,\n+    cargo::NEGATIVE_FEATURE_NAMES,\n+    cargo::REDUNDANT_FEATURE_NAMES,\n+    cargo::WILDCARD_DEPENDENCIES,\n     case_sensitive_file_extension_comparisons::CASE_SENSITIVE_FILE_EXTENSION_COMPARISONS,\n+    casts::CAST_ENUM_TRUNCATION,\n     casts::CAST_LOSSLESS,\n     casts::CAST_POSSIBLE_TRUNCATION,\n     casts::CAST_POSSIBLE_WRAP,\n@@ -139,8 +144,6 @@ store.register_lints(&[\n     exit::EXIT,\n     explicit_write::EXPLICIT_WRITE,\n     fallible_impl_from::FALLIBLE_IMPL_FROM,\n-    feature_name::NEGATIVE_FEATURE_NAMES,\n-    feature_name::REDUNDANT_FEATURE_NAMES,\n     float_equality_without_abs::FLOAT_EQUALITY_WITHOUT_ABS,\n     float_literal::EXCESSIVE_PRECISION,\n     float_literal::LOSSY_FLOAT_LITERAL,\n@@ -353,7 +356,6 @@ store.register_lints(&[\n     module_style::MOD_MODULE_FILES,\n     module_style::SELF_NAMED_MODULE_FILES,\n     modulo_arithmetic::MODULO_ARITHMETIC,\n-    multiple_crate_versions::MULTIPLE_CRATE_VERSIONS,\n     mut_key::MUTABLE_KEY_TYPE,\n     mut_mut::MUT_MUT,\n     mut_mutex_lock::MUT_MUTEX_LOCK,\n@@ -415,11 +417,13 @@ store.register_lints(&[\n     ranges::RANGE_PLUS_ONE,\n     ranges::RANGE_ZIP_WITH_LEN,\n     ranges::REVERSED_EMPTY_RANGES,\n+    recursive_format_impl::RECURSIVE_FORMAT_IMPL,\n     redundant_clone::REDUNDANT_CLONE,\n     redundant_closure_call::REDUNDANT_CLOSURE_CALL,\n     redundant_else::REDUNDANT_ELSE,\n     redundant_field_names::REDUNDANT_FIELD_NAMES,\n     redundant_pub_crate::REDUNDANT_PUB_CRATE,\n+    redundant_slicing::DEREF_BY_SLICING,\n     redundant_slicing::REDUNDANT_SLICING,\n     redundant_static_lifetimes::REDUNDANT_STATIC_LIFETIMES,\n     ref_option_ref::REF_OPTION_REF,\n@@ -459,7 +463,6 @@ store.register_lints(&[\n     tabs_in_doc_comments::TABS_IN_DOC_COMMENTS,\n     temporary_assignment::TEMPORARY_ASSIGNMENT,\n     to_digit_is_some::TO_DIGIT_IS_SOME,\n-    to_string_in_display::TO_STRING_IN_DISPLAY,\n     trailing_empty_array::TRAILING_EMPTY_ARRAY,\n     trait_bounds::TRAIT_DUPLICATION_IN_BOUNDS,\n     trait_bounds::TYPE_REPETITION_IN_BOUNDS,\n@@ -520,7 +523,6 @@ store.register_lints(&[\n     vec_init_then_push::VEC_INIT_THEN_PUSH,\n     vec_resize_to_zero::VEC_RESIZE_TO_ZERO,\n     verbose_file_reads::VERBOSE_FILE_READS,\n-    wildcard_dependencies::WILDCARD_DEPENDENCIES,\n     wildcard_imports::ENUM_GLOB_USE,\n     wildcard_imports::WILDCARD_IMPORTS,\n     write::PRINTLN_EMPTY_STRING,"}, {"sha": "a7353790100267681b11ae92b234125b48571dfe", "filename": "clippy_lints/src/lib.register_nursery.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/fd495a0654611a6d784bae4698e5838b121e8004/clippy_lints%2Fsrc%2Flib.register_nursery.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd495a0654611a6d784bae4698e5838b121e8004/clippy_lints%2Fsrc%2Flib.register_nursery.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flib.register_nursery.rs?ref=fd495a0654611a6d784bae4698e5838b121e8004", "patch": "@@ -26,7 +26,6 @@ store.register_group(true, \"clippy::nursery\", Some(\"clippy_nursery\"), vec![\n     LintId::of(strings::STRING_LIT_AS_BYTES),\n     LintId::of(suspicious_operation_groupings::SUSPICIOUS_OPERATION_GROUPINGS),\n     LintId::of(trailing_empty_array::TRAILING_EMPTY_ARRAY),\n-    LintId::of(transmute::TRANSMUTE_UNDEFINED_REPR),\n     LintId::of(transmute::USELESS_TRANSMUTE),\n     LintId::of(use_self::USE_SELF),\n ])"}, {"sha": "00d305131810df7418ae29eb519c660cbd954746", "filename": "clippy_lints/src/lib.register_pedantic.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fd495a0654611a6d784bae4698e5838b121e8004/clippy_lints%2Fsrc%2Flib.register_pedantic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd495a0654611a6d784bae4698e5838b121e8004/clippy_lints%2Fsrc%2Flib.register_pedantic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flib.register_pedantic.rs?ref=fd495a0654611a6d784bae4698e5838b121e8004", "patch": "@@ -4,8 +4,6 @@\n \n store.register_group(true, \"clippy::pedantic\", Some(\"clippy_pedantic\"), vec![\n     LintId::of(attrs::INLINE_ALWAYS),\n-    LintId::of(await_holding_invalid::AWAIT_HOLDING_LOCK),\n-    LintId::of(await_holding_invalid::AWAIT_HOLDING_REFCELL_REF),\n     LintId::of(bit_mask::VERBOSE_BIT_MASK),\n     LintId::of(borrow_as_ptr::BORROW_AS_PTR),\n     LintId::of(bytecount::NAIVE_BYTECOUNT),"}, {"sha": "f89f35b885c15a377c772e103254c0b0884aeebf", "filename": "clippy_lints/src/lib.register_restriction.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/fd495a0654611a6d784bae4698e5838b121e8004/clippy_lints%2Fsrc%2Flib.register_restriction.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd495a0654611a6d784bae4698e5838b121e8004/clippy_lints%2Fsrc%2Flib.register_restriction.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flib.register_restriction.rs?ref=fd495a0654611a6d784bae4698e5838b121e8004", "patch": "@@ -51,6 +51,7 @@ store.register_group(true, \"clippy::restriction\", Some(\"clippy_restriction\"), ve\n     LintId::of(panic_unimplemented::UNIMPLEMENTED),\n     LintId::of(panic_unimplemented::UNREACHABLE),\n     LintId::of(pattern_type_mismatch::PATTERN_TYPE_MISMATCH),\n+    LintId::of(redundant_slicing::DEREF_BY_SLICING),\n     LintId::of(same_name_method::SAME_NAME_METHOD),\n     LintId::of(shadow::SHADOW_REUSE),\n     LintId::of(shadow::SHADOW_SAME),"}, {"sha": "6a8859e19d71d1c15adbe0a77f2522f3ff035cef", "filename": "clippy_lints/src/lib.register_suspicious.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/fd495a0654611a6d784bae4698e5838b121e8004/clippy_lints%2Fsrc%2Flib.register_suspicious.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd495a0654611a6d784bae4698e5838b121e8004/clippy_lints%2Fsrc%2Flib.register_suspicious.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flib.register_suspicious.rs?ref=fd495a0654611a6d784bae4698e5838b121e8004", "patch": "@@ -5,6 +5,9 @@\n store.register_group(true, \"clippy::suspicious\", Some(\"clippy_suspicious\"), vec![\n     LintId::of(assign_ops::MISREFACTORED_ASSIGN_OP),\n     LintId::of(attrs::BLANKET_CLIPPY_RESTRICTION_LINTS),\n+    LintId::of(await_holding_invalid::AWAIT_HOLDING_LOCK),\n+    LintId::of(await_holding_invalid::AWAIT_HOLDING_REFCELL_REF),\n+    LintId::of(casts::CAST_ENUM_TRUNCATION),\n     LintId::of(eval_order_dependence::EVAL_ORDER_DEPENDENCE),\n     LintId::of(float_equality_without_abs::FLOAT_EQUALITY_WITHOUT_ABS),\n     LintId::of(formatting::SUSPICIOUS_ASSIGNMENT_FORMATTING),"}, {"sha": "a21a87899aa168689289b78588d7479c9153943a", "filename": "clippy_lints/src/lib.rs", "status": "modified", "additions": 14, "deletions": 13, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/fd495a0654611a6d784bae4698e5838b121e8004/clippy_lints%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd495a0654611a6d784bae4698e5838b121e8004/clippy_lints%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flib.rs?ref=fd495a0654611a6d784bae4698e5838b121e8004", "patch": "@@ -5,6 +5,7 @@\n #![feature(control_flow_enum)]\n #![feature(drain_filter)]\n #![feature(iter_intersperse)]\n+#![feature(let_chains)]\n #![feature(let_else)]\n #![feature(once_cell)]\n #![feature(rustc_private)]\n@@ -18,12 +19,13 @@\n // warn on rustc internal lints\n #![warn(rustc::internal)]\n // Disable this rustc lint for now, as it was also done in rustc\n-#![cfg_attr(not(bootstrap), allow(rustc::potential_query_instability))]\n+#![allow(rustc::potential_query_instability)]\n \n // FIXME: switch to something more ergonomic here, once available.\n // (Currently there is no way to opt into sysroot crates without `extern crate`.)\n extern crate rustc_ast;\n extern crate rustc_ast_pretty;\n+extern crate rustc_attr;\n extern crate rustc_data_structures;\n extern crate rustc_driver;\n extern crate rustc_errors;\n@@ -177,7 +179,7 @@ mod bool_assert_comparison;\n mod booleans;\n mod borrow_as_ptr;\n mod bytecount;\n-mod cargo_common_metadata;\n+mod cargo;\n mod case_sensitive_file_extension_comparisons;\n mod casts;\n mod checked_conversions;\n@@ -219,7 +221,6 @@ mod exhaustive_items;\n mod exit;\n mod explicit_write;\n mod fallible_impl_from;\n-mod feature_name;\n mod float_equality_without_abs;\n mod float_literal;\n mod floating_point_arithmetic;\n@@ -289,7 +290,6 @@ mod missing_enforced_import_rename;\n mod missing_inline;\n mod module_style;\n mod modulo_arithmetic;\n-mod multiple_crate_versions;\n mod mut_key;\n mod mut_mut;\n mod mut_mutex_lock;\n@@ -333,6 +333,7 @@ mod ptr_eq;\n mod ptr_offset_with_cast;\n mod question_mark;\n mod ranges;\n+mod recursive_format_impl;\n mod redundant_clone;\n mod redundant_closure_call;\n mod redundant_else;\n@@ -365,7 +366,6 @@ mod swap;\n mod tabs_in_doc_comments;\n mod temporary_assignment;\n mod to_digit_is_some;\n-mod to_string_in_display;\n mod trailing_empty_array;\n mod trait_bounds;\n mod transmute;\n@@ -398,7 +398,6 @@ mod vec;\n mod vec_init_then_push;\n mod vec_resize_to_zero;\n mod verbose_file_reads;\n-mod wildcard_dependencies;\n mod wildcard_imports;\n mod write;\n mod zero_div_zero;\n@@ -431,7 +430,6 @@ pub fn register_pre_expansion_lints(store: &mut rustc_lint::LintStore, sess: &Se\n \n     store.register_pre_expansion_pass(|| Box::new(write::Write::default()));\n     store.register_pre_expansion_pass(move || Box::new(attrs::EarlyAttributes { msrv }));\n-    store.register_pre_expansion_pass(|| Box::new(dbg_macro::DbgMacro));\n }\n \n #[doc(hidden)]\n@@ -707,7 +705,7 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n     store.register_late_pass(|| Box::new(modulo_arithmetic::ModuloArithmetic));\n     store.register_early_pass(|| Box::new(reference::DerefAddrOf));\n     store.register_early_pass(|| Box::new(double_parens::DoubleParens));\n-    store.register_late_pass(|| Box::new(to_string_in_display::ToStringInDisplay::new()));\n+    store.register_late_pass(|| Box::new(recursive_format_impl::RecursiveFormatImpl::new()));\n     store.register_early_pass(|| Box::new(unsafe_removed_from_name::UnsafeNameRemoval));\n     store.register_early_pass(|| Box::new(else_if_without_else::ElseIfWithoutElse));\n     store.register_early_pass(|| Box::new(int_plus_one::IntPlusOne));\n@@ -724,10 +722,6 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n     store.register_early_pass(|| Box::new(redundant_else::RedundantElse));\n     store.register_late_pass(|| Box::new(create_dir::CreateDir));\n     store.register_early_pass(|| Box::new(needless_arbitrary_self_type::NeedlessArbitrarySelfType));\n-    let cargo_ignore_publish = conf.cargo_ignore_publish;\n-    store.register_late_pass(move || Box::new(cargo_common_metadata::CargoCommonMetadata::new(cargo_ignore_publish)));\n-    store.register_late_pass(|| Box::new(multiple_crate_versions::MultipleCrateVersions));\n-    store.register_late_pass(|| Box::new(wildcard_dependencies::WildcardDependencies));\n     let literal_representation_lint_fraction_readability = conf.unreadable_literal_lint_fractions;\n     store.register_early_pass(move || {\n         Box::new(literal_representation::LiteralDigitGrouping::new(\n@@ -842,7 +836,6 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n     store.register_early_pass(move || Box::new(disallowed_script_idents::DisallowedScriptIdents::new(&scripts)));\n     store.register_late_pass(|| Box::new(strlen_on_c_strings::StrlenOnCStrings));\n     store.register_late_pass(move || Box::new(self_named_constructors::SelfNamedConstructors));\n-    store.register_late_pass(move || Box::new(feature_name::FeatureName));\n     store.register_late_pass(move || Box::new(iter_not_returning_iterator::IterNotReturningIterator));\n     store.register_late_pass(move || Box::new(manual_assert::ManualAssert));\n     let enable_raw_pointer_heuristic_for_send = conf.enable_raw_pointer_heuristic_for_send;\n@@ -863,6 +856,13 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n     store.register_late_pass(move || Box::new(borrow_as_ptr::BorrowAsPtr::new(msrv)));\n     store.register_late_pass(move || Box::new(manual_bits::ManualBits::new(msrv)));\n     store.register_late_pass(|| Box::new(default_union_representation::DefaultUnionRepresentation));\n+    store.register_late_pass(|| Box::new(dbg_macro::DbgMacro));\n+    let cargo_ignore_publish = conf.cargo_ignore_publish;\n+    store.register_late_pass(move || {\n+        Box::new(cargo::Cargo {\n+            ignore_publish: cargo_ignore_publish,\n+        })\n+    });\n     // add lints here, do not remove this comment, it's used in `new_lint`\n }\n \n@@ -939,6 +939,7 @@ pub fn register_renamed(ls: &mut rustc_lint::LintStore) {\n     ls.register_renamed(\"clippy::disallowed_type\", \"clippy::disallowed_types\");\n     ls.register_renamed(\"clippy::disallowed_method\", \"clippy::disallowed_methods\");\n     ls.register_renamed(\"clippy::ref_in_deref\", \"clippy::needless_borrow\");\n+    ls.register_renamed(\"clippy::to_string_in_display\", \"clippy::recursive_format_impl\");\n \n     // uplifted lints\n     ls.register_renamed(\"clippy::invalid_ref\", \"invalid_value\");"}, {"sha": "76c5cfadc2c1a9f931beec847dc5768aa7c6cfd4", "filename": "clippy_lints/src/macro_use.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/fd495a0654611a6d784bae4698e5838b121e8004/clippy_lints%2Fsrc%2Fmacro_use.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd495a0654611a6d784bae4698e5838b121e8004/clippy_lints%2Fsrc%2Fmacro_use.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmacro_use.rs?ref=fd495a0654611a6d784bae4698e5838b121e8004", "patch": "@@ -35,7 +35,8 @@ struct PathAndSpan {\n     span: Span,\n }\n \n-/// `MacroRefData` includes the name of the macro.\n+/// `MacroRefData` includes the name of the macro\n+/// and the path from `SourceMap::span_to_filename`.\n #[derive(Debug, Clone)]\n pub struct MacroRefData {\n     name: String,"}, {"sha": "2e1f7646eb400b3924ff813738c90091205e139f", "filename": "clippy_lints/src/matches/match_like_matches.rs", "status": "modified", "additions": 24, "deletions": 21, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/fd495a0654611a6d784bae4698e5838b121e8004/clippy_lints%2Fsrc%2Fmatches%2Fmatch_like_matches.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd495a0654611a6d784bae4698e5838b121e8004/clippy_lints%2Fsrc%2Fmatches%2Fmatch_like_matches.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmatches%2Fmatch_like_matches.rs?ref=fd495a0654611a6d784bae4698e5838b121e8004", "patch": "@@ -3,49 +3,52 @@ use clippy_utils::source::snippet_with_applicability;\n use clippy_utils::{higher, is_wild};\n use rustc_ast::{Attribute, LitKind};\n use rustc_errors::Applicability;\n-use rustc_hir::{BorrowKind, Expr, ExprKind, Guard, MatchSource, Pat};\n+use rustc_hir::{Arm, BorrowKind, Expr, ExprKind, Guard, Pat};\n use rustc_lint::LateContext;\n use rustc_middle::ty;\n use rustc_span::source_map::Spanned;\n \n use super::MATCH_LIKE_MATCHES_MACRO;\n \n /// Lint a `match` or `if let .. { .. } else { .. }` expr that could be replaced by `matches!`\n-pub(crate) fn check<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) -> bool {\n+pub(crate) fn check<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) {\n     if let Some(higher::IfLet {\n         let_pat,\n         let_expr,\n         if_then,\n         if_else: Some(if_else),\n     }) = higher::IfLet::hir(cx, expr)\n     {\n-        return find_matches_sugg(\n+        find_matches_sugg(\n             cx,\n             let_expr,\n             IntoIterator::into_iter([(&[][..], Some(let_pat), if_then, None), (&[][..], None, if_else, None)]),\n             expr,\n             true,\n         );\n     }\n+}\n \n-    if let ExprKind::Match(scrut, arms, MatchSource::Normal) = expr.kind {\n-        return find_matches_sugg(\n-            cx,\n-            scrut,\n-            arms.iter().map(|arm| {\n-                (\n-                    cx.tcx.hir().attrs(arm.hir_id),\n-                    Some(arm.pat),\n-                    arm.body,\n-                    arm.guard.as_ref(),\n-                )\n-            }),\n-            expr,\n-            false,\n-        );\n-    }\n-\n-    false\n+pub(super) fn check_match<'tcx>(\n+    cx: &LateContext<'tcx>,\n+    e: &'tcx Expr<'_>,\n+    scrutinee: &'tcx Expr<'_>,\n+    arms: &'tcx [Arm<'tcx>],\n+) -> bool {\n+    find_matches_sugg(\n+        cx,\n+        scrutinee,\n+        arms.iter().map(|arm| {\n+            (\n+                cx.tcx.hir().attrs(arm.hir_id),\n+                Some(arm.pat),\n+                arm.body,\n+                arm.guard.as_ref(),\n+            )\n+        }),\n+        e,\n+        false,\n+    )\n }\n \n /// Lint a `match` or `if let` for replacement by `matches!`"}, {"sha": "d11dda57e6fd94c2676a4ef1a0fc2d95bc4d8feb", "filename": "clippy_lints/src/matches/match_same_arms.rs", "status": "modified", "additions": 75, "deletions": 77, "changes": 152, "blob_url": "https://github.com/rust-lang/rust/blob/fd495a0654611a6d784bae4698e5838b121e8004/clippy_lints%2Fsrc%2Fmatches%2Fmatch_same_arms.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd495a0654611a6d784bae4698e5838b121e8004/clippy_lints%2Fsrc%2Fmatches%2Fmatch_same_arms.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmatches%2Fmatch_same_arms.rs?ref=fd495a0654611a6d784bae4698e5838b121e8004", "patch": "@@ -1,96 +1,94 @@\n use clippy_utils::diagnostics::span_lint_and_then;\n use clippy_utils::source::snippet;\n use clippy_utils::{path_to_local, search_same, SpanlessEq, SpanlessHash};\n-use rustc_hir::{Arm, Expr, ExprKind, HirId, HirIdMap, HirIdSet, MatchSource, Pat, PatKind};\n+use rustc_hir::{Arm, Expr, HirId, HirIdMap, HirIdSet, Pat, PatKind};\n use rustc_lint::LateContext;\n use std::collections::hash_map::Entry;\n \n use super::MATCH_SAME_ARMS;\n \n-pub(crate) fn check<'tcx>(cx: &LateContext<'tcx>, expr: &Expr<'_>) {\n-    if let ExprKind::Match(_, arms, MatchSource::Normal) = expr.kind {\n-        let hash = |&(_, arm): &(usize, &Arm<'_>)| -> u64 {\n-            let mut h = SpanlessHash::new(cx);\n-            h.hash_expr(arm.body);\n-            h.finish()\n-        };\n+pub(crate) fn check<'tcx>(cx: &LateContext<'tcx>, arms: &'tcx [Arm<'_>]) {\n+    let hash = |&(_, arm): &(usize, &Arm<'_>)| -> u64 {\n+        let mut h = SpanlessHash::new(cx);\n+        h.hash_expr(arm.body);\n+        h.finish()\n+    };\n \n-        let eq = |&(lindex, lhs): &(usize, &Arm<'_>), &(rindex, rhs): &(usize, &Arm<'_>)| -> bool {\n-            let min_index = usize::min(lindex, rindex);\n-            let max_index = usize::max(lindex, rindex);\n+    let eq = |&(lindex, lhs): &(usize, &Arm<'_>), &(rindex, rhs): &(usize, &Arm<'_>)| -> bool {\n+        let min_index = usize::min(lindex, rindex);\n+        let max_index = usize::max(lindex, rindex);\n \n-            let mut local_map: HirIdMap<HirId> = HirIdMap::default();\n-            let eq_fallback = |a: &Expr<'_>, b: &Expr<'_>| {\n-                if_chain! {\n-                    if let Some(a_id) = path_to_local(a);\n-                    if let Some(b_id) = path_to_local(b);\n-                    let entry = match local_map.entry(a_id) {\n-                        Entry::Vacant(entry) => entry,\n-                        // check if using the same bindings as before\n-                        Entry::Occupied(entry) => return *entry.get() == b_id,\n-                    };\n-                    // the names technically don't have to match; this makes the lint more conservative\n-                    if cx.tcx.hir().name(a_id) == cx.tcx.hir().name(b_id);\n-                    if cx.typeck_results().expr_ty(a) == cx.typeck_results().expr_ty(b);\n-                    if pat_contains_local(lhs.pat, a_id);\n-                    if pat_contains_local(rhs.pat, b_id);\n-                    then {\n-                        entry.insert(b_id);\n-                        true\n-                    } else {\n-                        false\n-                    }\n+        let mut local_map: HirIdMap<HirId> = HirIdMap::default();\n+        let eq_fallback = |a: &Expr<'_>, b: &Expr<'_>| {\n+            if_chain! {\n+                if let Some(a_id) = path_to_local(a);\n+                if let Some(b_id) = path_to_local(b);\n+                let entry = match local_map.entry(a_id) {\n+                    Entry::Vacant(entry) => entry,\n+                    // check if using the same bindings as before\n+                    Entry::Occupied(entry) => return *entry.get() == b_id,\n+                };\n+                // the names technically don't have to match; this makes the lint more conservative\n+                if cx.tcx.hir().name(a_id) == cx.tcx.hir().name(b_id);\n+                if cx.typeck_results().expr_ty(a) == cx.typeck_results().expr_ty(b);\n+                if pat_contains_local(lhs.pat, a_id);\n+                if pat_contains_local(rhs.pat, b_id);\n+                then {\n+                    entry.insert(b_id);\n+                    true\n+                } else {\n+                    false\n                 }\n-            };\n-            // Arms with a guard are ignored, those can\u2019t always be merged together\n-            // This is also the case for arms in-between each there is an arm with a guard\n-            (min_index..=max_index).all(|index| arms[index].guard.is_none())\n-                && SpanlessEq::new(cx)\n-                    .expr_fallback(eq_fallback)\n-                    .eq_expr(lhs.body, rhs.body)\n-                // these checks could be removed to allow unused bindings\n-                && bindings_eq(lhs.pat, local_map.keys().copied().collect())\n-                && bindings_eq(rhs.pat, local_map.values().copied().collect())\n+            }\n         };\n+        // Arms with a guard are ignored, those can\u2019t always be merged together\n+        // This is also the case for arms in-between each there is an arm with a guard\n+        (min_index..=max_index).all(|index| arms[index].guard.is_none())\n+            && SpanlessEq::new(cx)\n+                .expr_fallback(eq_fallback)\n+                .eq_expr(lhs.body, rhs.body)\n+            // these checks could be removed to allow unused bindings\n+            && bindings_eq(lhs.pat, local_map.keys().copied().collect())\n+            && bindings_eq(rhs.pat, local_map.values().copied().collect())\n+    };\n \n-        let indexed_arms: Vec<(usize, &Arm<'_>)> = arms.iter().enumerate().collect();\n-        for (&(_, i), &(_, j)) in search_same(&indexed_arms, hash, eq) {\n-            span_lint_and_then(\n-                cx,\n-                MATCH_SAME_ARMS,\n-                j.body.span,\n-                \"this `match` has identical arm bodies\",\n-                |diag| {\n-                    diag.span_note(i.body.span, \"same as this\");\n+    let indexed_arms: Vec<(usize, &Arm<'_>)> = arms.iter().enumerate().collect();\n+    for (&(_, i), &(_, j)) in search_same(&indexed_arms, hash, eq) {\n+        span_lint_and_then(\n+            cx,\n+            MATCH_SAME_ARMS,\n+            j.body.span,\n+            \"this `match` has identical arm bodies\",\n+            |diag| {\n+                diag.span_note(i.body.span, \"same as this\");\n \n-                    // Note: this does not use `span_suggestion` on purpose:\n-                    // there is no clean way\n-                    // to remove the other arm. Building a span and suggest to replace it to \"\"\n-                    // makes an even more confusing error message. Also in order not to make up a\n-                    // span for the whole pattern, the suggestion is only shown when there is only\n-                    // one pattern. The user should know about `|` if they are already using it\u2026\n+                // Note: this does not use `span_suggestion` on purpose:\n+                // there is no clean way\n+                // to remove the other arm. Building a span and suggest to replace it to \"\"\n+                // makes an even more confusing error message. Also in order not to make up a\n+                // span for the whole pattern, the suggestion is only shown when there is only\n+                // one pattern. The user should know about `|` if they are already using it\u2026\n \n-                    let lhs = snippet(cx, i.pat.span, \"<pat1>\");\n-                    let rhs = snippet(cx, j.pat.span, \"<pat2>\");\n+                let lhs = snippet(cx, i.pat.span, \"<pat1>\");\n+                let rhs = snippet(cx, j.pat.span, \"<pat2>\");\n \n-                    if let PatKind::Wild = j.pat.kind {\n-                        // if the last arm is _, then i could be integrated into _\n-                        // note that i.pat cannot be _, because that would mean that we're\n-                        // hiding all the subsequent arms, and rust won't compile\n-                        diag.span_note(\n-                            i.body.span,\n-                            &format!(\n-                                \"`{}` has the same arm body as the `_` wildcard, consider removing it\",\n-                                lhs\n-                            ),\n-                        );\n-                    } else {\n-                        diag.span_help(i.pat.span, &format!(\"consider refactoring into `{} | {}`\", lhs, rhs,))\n-                            .help(\"...or consider changing the match arm bodies\");\n-                    }\n-                },\n-            );\n-        }\n+                if let PatKind::Wild = j.pat.kind {\n+                    // if the last arm is _, then i could be integrated into _\n+                    // note that i.pat cannot be _, because that would mean that we're\n+                    // hiding all the subsequent arms, and rust won't compile\n+                    diag.span_note(\n+                        i.body.span,\n+                        &format!(\n+                            \"`{}` has the same arm body as the `_` wildcard, consider removing it\",\n+                            lhs\n+                        ),\n+                    );\n+                } else {\n+                    diag.span_help(i.pat.span, &format!(\"consider refactoring into `{} | {}`\", lhs, rhs,))\n+                        .help(\"...or consider changing the match arm bodies\");\n+                }\n+            },\n+        );\n     }\n }\n "}, {"sha": "39fe54648fbc754c37f5fba926d8ba9d45a54f45", "filename": "clippy_lints/src/matches/match_single_binding.rs", "status": "modified", "additions": 1, "deletions": 18, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/fd495a0654611a6d784bae4698e5838b121e8004/clippy_lints%2Fsrc%2Fmatches%2Fmatch_single_binding.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd495a0654611a6d784bae4698e5838b121e8004/clippy_lints%2Fsrc%2Fmatches%2Fmatch_single_binding.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmatches%2Fmatch_single_binding.rs?ref=fd495a0654611a6d784bae4698e5838b121e8004", "patch": "@@ -1,5 +1,5 @@\n use clippy_utils::diagnostics::span_lint_and_sugg;\n-use clippy_utils::source::{indent_of, snippet_block, snippet_opt, snippet_with_applicability};\n+use clippy_utils::source::{indent_of, snippet_block, snippet_with_applicability};\n use clippy_utils::sugg::Sugg;\n use clippy_utils::{get_parent_expr, is_refutable, peel_blocks};\n use rustc_errors::Applicability;\n@@ -14,23 +14,6 @@ pub(crate) fn check<'a>(cx: &LateContext<'a>, ex: &Expr<'a>, arms: &[Arm<'_>], e\n         return;\n     }\n \n-    // HACK:\n-    // This is a hack to deal with arms that are excluded by macros like `#[cfg]`. It is only used here\n-    // to prevent false positives as there is currently no better way to detect if code was excluded by\n-    // a macro. See PR #6435\n-    if_chain! {\n-        if let Some(match_snippet) = snippet_opt(cx, expr.span);\n-        if let Some(arm_snippet) = snippet_opt(cx, arms[0].span);\n-        if let Some(ex_snippet) = snippet_opt(cx, ex.span);\n-        let rest_snippet = match_snippet.replace(&arm_snippet, \"\").replace(&ex_snippet, \"\");\n-        if rest_snippet.contains(\"=>\");\n-        then {\n-            // The code it self contains another thick arrow \"=>\"\n-            // -> Either another arm or a comment\n-            return;\n-        }\n-    }\n-\n     let matched_vars = ex.span;\n     let bind_names = arms[0].pat.span;\n     let match_body = peel_blocks(arms[0].body);"}, {"sha": "92179eb6f0e60e5f7c8a90bdd1e6daa7b54d742c", "filename": "clippy_lints/src/matches/mod.rs", "status": "modified", "additions": 122, "deletions": 22, "changes": 144, "blob_url": "https://github.com/rust-lang/rust/blob/fd495a0654611a6d784bae4698e5838b121e8004/clippy_lints%2Fsrc%2Fmatches%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd495a0654611a6d784bae4698e5838b121e8004/clippy_lints%2Fsrc%2Fmatches%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmatches%2Fmod.rs?ref=fd495a0654611a6d784bae4698e5838b121e8004", "patch": "@@ -1,8 +1,11 @@\n+use clippy_utils::source::{snippet_opt, walk_span_to_context};\n use clippy_utils::{meets_msrv, msrvs};\n-use rustc_hir::{Expr, ExprKind, Local, MatchSource, Pat};\n+use rustc_hir::{Arm, Expr, ExprKind, Local, MatchSource, Pat};\n+use rustc_lexer::{tokenize, TokenKind};\n use rustc_lint::{LateContext, LateLintPass};\n use rustc_semver::RustcVersion;\n use rustc_session::{declare_tool_lint, impl_lint_pass};\n+use rustc_span::{Span, SpanData, SyntaxContext};\n \n mod infalliable_detructuring_match;\n mod match_as_ref;\n@@ -604,33 +607,39 @@ impl<'tcx> LateLintPass<'tcx> for Matches {\n             return;\n         }\n \n-        redundant_pattern_match::check(cx, expr);\n+        if let ExprKind::Match(ex, arms, source) = expr.kind {\n+            if !contains_cfg_arm(cx, expr, ex, arms) {\n+                if source == MatchSource::Normal {\n+                    if !(meets_msrv(self.msrv.as_ref(), &msrvs::MATCHES_MACRO)\n+                        && match_like_matches::check_match(cx, expr, ex, arms))\n+                    {\n+                        match_same_arms::check(cx, arms);\n+                    }\n \n-        if meets_msrv(self.msrv.as_ref(), &msrvs::MATCHES_MACRO) {\n-            if !match_like_matches::check(cx, expr) {\n-                match_same_arms::check(cx, expr);\n+                    redundant_pattern_match::check_match(cx, expr, ex, arms);\n+                    single_match::check(cx, ex, arms, expr);\n+                    match_bool::check(cx, ex, arms, expr);\n+                    overlapping_arms::check(cx, ex, arms);\n+                    match_wild_enum::check(cx, ex, arms);\n+                    match_as_ref::check(cx, ex, arms, expr);\n+\n+                    if self.infallible_destructuring_match_linted {\n+                        self.infallible_destructuring_match_linted = false;\n+                    } else {\n+                        match_single_binding::check(cx, ex, arms, expr);\n+                    }\n+                }\n+                match_ref_pats::check(cx, ex, arms.iter().map(|el| el.pat), expr);\n             }\n-        } else {\n-            match_same_arms::check(cx, expr);\n-        }\n \n-        if let ExprKind::Match(ex, arms, MatchSource::Normal) = expr.kind {\n-            single_match::check(cx, ex, arms, expr);\n-            match_bool::check(cx, ex, arms, expr);\n-            overlapping_arms::check(cx, ex, arms);\n+            // These don't depend on a relationship between multiple arms\n             match_wild_err_arm::check(cx, ex, arms);\n-            match_wild_enum::check(cx, ex, arms);\n-            match_as_ref::check(cx, ex, arms, expr);\n             wild_in_or_pats::check(cx, arms);\n-\n-            if self.infallible_destructuring_match_linted {\n-                self.infallible_destructuring_match_linted = false;\n-            } else {\n-                match_single_binding::check(cx, ex, arms, expr);\n+        } else {\n+            if meets_msrv(self.msrv.as_ref(), &msrvs::MATCHES_MACRO) {\n+                match_like_matches::check(cx, expr);\n             }\n-        }\n-        if let ExprKind::Match(ex, arms, _) = expr.kind {\n-            match_ref_pats::check(cx, ex, arms.iter().map(|el| el.pat), expr);\n+            redundant_pattern_match::check(cx, expr);\n         }\n     }\n \n@@ -644,3 +653,94 @@ impl<'tcx> LateLintPass<'tcx> for Matches {\n \n     extract_msrv_attr!(LateContext);\n }\n+\n+/// Checks if there are any arms with a `#[cfg(..)]` attribute.\n+fn contains_cfg_arm(cx: &LateContext<'_>, e: &Expr<'_>, scrutinee: &Expr<'_>, arms: &[Arm<'_>]) -> bool {\n+    let Some(scrutinee_span) = walk_span_to_context(scrutinee.span, SyntaxContext::root()) else {\n+        // Shouldn't happen, but treat this as though a `cfg` attribute were found\n+        return true;\n+    };\n+\n+    let start = scrutinee_span.hi();\n+    let mut arm_spans = arms.iter().map(|arm| {\n+        let data = arm.span.data();\n+        (data.ctxt == SyntaxContext::root()).then(|| (data.lo, data.hi))\n+    });\n+    let end = e.span.hi();\n+\n+    // Walk through all the non-code space before each match arm. The space trailing the final arm is\n+    // handled after the `try_fold` e.g.\n+    //\n+    // match foo {\n+    // _________^-                      everything between the scrutinee and arm1\n+    //|    arm1 => (),\n+    //|---^___________^                 everything before arm2\n+    //|    #[cfg(feature = \"enabled\")]\n+    //|    arm2 => some_code(),\n+    //|---^____________________^        everything before arm3\n+    //|    // some comment about arm3\n+    //|    arm3 => some_code(),\n+    //|---^____________________^        everything after arm3\n+    //|    #[cfg(feature = \"disabled\")]\n+    //|    arm4 = some_code(),\n+    //|};\n+    //|^\n+    let found = arm_spans.try_fold(start, |start, range| {\n+        let Some((end, next_start)) = range else {\n+            // Shouldn't happen as macros can't expand to match arms, but treat this as though a `cfg` attribute were\n+            // found.\n+            return Err(());\n+        };\n+        let span = SpanData {\n+            lo: start,\n+            hi: end,\n+            ctxt: SyntaxContext::root(),\n+            parent: None,\n+        }\n+        .span();\n+        (!span_contains_cfg(cx, span)).then(|| next_start).ok_or(())\n+    });\n+    match found {\n+        Ok(start) => {\n+            let span = SpanData {\n+                lo: start,\n+                hi: end,\n+                ctxt: SyntaxContext::root(),\n+                parent: None,\n+            }\n+            .span();\n+            span_contains_cfg(cx, span)\n+        },\n+        Err(()) => true,\n+    }\n+}\n+\n+/// Checks if the given span contains a `#[cfg(..)]` attribute\n+fn span_contains_cfg(cx: &LateContext<'_>, s: Span) -> bool {\n+    let Some(snip) = snippet_opt(cx, s) else {\n+        // Assume true. This would require either an invalid span, or one which crosses file boundaries.\n+        return true;\n+    };\n+    let mut pos = 0usize;\n+    let mut iter = tokenize(&snip).map(|t| {\n+        let start = pos;\n+        pos += t.len;\n+        (t.kind, start..pos)\n+    });\n+\n+    // Search for the token sequence [`#`, `[`, `cfg`]\n+    while iter.any(|(t, _)| matches!(t, TokenKind::Pound)) {\n+        let mut iter = iter.by_ref().skip_while(|(t, _)| {\n+            matches!(\n+                t,\n+                TokenKind::Whitespace | TokenKind::LineComment { .. } | TokenKind::BlockComment { .. }\n+            )\n+        });\n+        if matches!(iter.next(), Some((TokenKind::OpenBracket, _)))\n+            && matches!(iter.next(), Some((TokenKind::Ident, range)) if &snip[range.clone()] == \"cfg\")\n+        {\n+            return true;\n+        }\n+    }\n+    false\n+}"}, {"sha": "777ec9b75bc24705494bf68c10fe2be018f83401", "filename": "clippy_lints/src/matches/redundant_pattern_match.rs", "status": "modified", "additions": 5, "deletions": 9, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/fd495a0654611a6d784bae4698e5838b121e8004/clippy_lints%2Fsrc%2Fmatches%2Fredundant_pattern_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd495a0654611a6d784bae4698e5838b121e8004/clippy_lints%2Fsrc%2Fmatches%2Fredundant_pattern_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmatches%2Fredundant_pattern_match.rs?ref=fd495a0654611a6d784bae4698e5838b121e8004", "patch": "@@ -12,13 +12,13 @@ use rustc_errors::Applicability;\n use rustc_hir::LangItem::{OptionNone, PollPending};\n use rustc_hir::{\n     intravisit::{walk_expr, Visitor},\n-    Arm, Block, Expr, ExprKind, LangItem, MatchSource, Node, Pat, PatKind, QPath, UnOp,\n+    Arm, Block, Expr, ExprKind, LangItem, Node, Pat, PatKind, QPath, UnOp,\n };\n use rustc_lint::LateContext;\n use rustc_middle::ty::{self, subst::GenericArgKind, DefIdTree, Ty};\n use rustc_span::sym;\n \n-pub fn check<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) {\n+pub(super) fn check<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) {\n     if let Some(higher::IfLet {\n         if_else,\n         let_pat,\n@@ -27,11 +27,7 @@ pub fn check<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) {\n     }) = higher::IfLet::hir(cx, expr)\n     {\n         find_sugg_for_if_let(cx, expr, let_pat, let_expr, \"if\", if_else.is_some());\n-    }\n-    if let ExprKind::Match(op, arms, MatchSource::Normal) = &expr.kind {\n-        find_sugg_for_match(cx, expr, op, arms);\n-    }\n-    if let Some(higher::WhileLet { let_pat, let_expr, .. }) = higher::WhileLet::hir(expr) {\n+    } else if let Some(higher::WhileLet { let_pat, let_expr, .. }) = higher::WhileLet::hir(expr) {\n         find_sugg_for_if_let(cx, expr, let_pat, let_expr, \"while\", false);\n     }\n }\n@@ -59,7 +55,7 @@ fn type_needs_ordered_drop_inner<'tcx>(cx: &LateContext<'tcx>, ty: Ty<'tcx>, see\n         // Check if any component type has any.\n         match ty.kind() {\n             ty::Tuple(fields) => fields.iter().any(|ty| type_needs_ordered_drop_inner(cx, ty, seen)),\n-            &ty::Array(ty, _) => type_needs_ordered_drop_inner(cx, ty, seen),\n+            ty::Array(ty, _) => type_needs_ordered_drop_inner(cx, *ty, seen),\n             ty::Adt(adt, subs) => adt\n                 .all_fields()\n                 .map(|f| f.ty(cx.tcx, subs))\n@@ -304,7 +300,7 @@ fn find_sugg_for_if_let<'tcx>(\n     );\n }\n \n-fn find_sugg_for_match<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>, op: &Expr<'_>, arms: &[Arm<'_>]) {\n+pub(super) fn check_match<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>, op: &Expr<'_>, arms: &[Arm<'_>]) {\n     if arms.len() == 2 {\n         let node_pair = (&arms[0].pat.kind, &arms[1].pat.kind);\n "}, {"sha": "65d1f440b76391031109a7dbb7a1049cb9d869b3", "filename": "clippy_lints/src/minmax.rs", "status": "modified", "additions": 6, "deletions": 9, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/fd495a0654611a6d784bae4698e5838b121e8004/clippy_lints%2Fsrc%2Fminmax.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd495a0654611a6d784bae4698e5838b121e8004/clippy_lints%2Fsrc%2Fminmax.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fminmax.rs?ref=fd495a0654611a6d784bae4698e5838b121e8004", "patch": "@@ -1,10 +1,11 @@\n use clippy_utils::consts::{constant_simple, Constant};\n use clippy_utils::diagnostics::span_lint;\n-use clippy_utils::{match_def_path, match_trait_method, paths};\n+use clippy_utils::{match_trait_method, paths};\n use if_chain::if_chain;\n use rustc_hir::{Expr, ExprKind};\n use rustc_lint::{LateContext, LateLintPass};\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n+use rustc_span::sym;\n use std::cmp::Ordering;\n \n declare_clippy_lint! {\n@@ -73,14 +74,10 @@ fn min_max<'a>(cx: &LateContext<'_>, expr: &'a Expr<'a>) -> Option<(MinMax, Cons\n                 cx.typeck_results()\n                     .qpath_res(qpath, path.hir_id)\n                     .opt_def_id()\n-                    .and_then(|def_id| {\n-                        if match_def_path(cx, def_id, &paths::CMP_MIN) {\n-                            fetch_const(cx, args, MinMax::Min)\n-                        } else if match_def_path(cx, def_id, &paths::CMP_MAX) {\n-                            fetch_const(cx, args, MinMax::Max)\n-                        } else {\n-                            None\n-                        }\n+                    .and_then(|def_id| match cx.tcx.get_diagnostic_name(def_id) {\n+                        Some(sym::cmp_min) => fetch_const(cx, args, MinMax::Min),\n+                        Some(sym::cmp_max) => fetch_const(cx, args, MinMax::Max),\n+                        _ => None,\n                     })\n             } else {\n                 None"}, {"sha": "db6aab0671bd08d7a58a9a0a02675072d6d45c7e", "filename": "clippy_lints/src/missing_doc.rs", "status": "modified", "additions": 19, "deletions": 2, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/fd495a0654611a6d784bae4698e5838b121e8004/clippy_lints%2Fsrc%2Fmissing_doc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd495a0654611a6d784bae4698e5838b121e8004/clippy_lints%2Fsrc%2Fmissing_doc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmissing_doc.rs?ref=fd495a0654611a6d784bae4698e5838b121e8004", "patch": "@@ -7,7 +7,8 @@\n \n use clippy_utils::attrs::is_doc_hidden;\n use clippy_utils::diagnostics::span_lint;\n-use rustc_ast::ast;\n+use if_chain::if_chain;\n+use rustc_ast::ast::{self, MetaItem, MetaItemKind};\n use rustc_hir as hir;\n use rustc_lint::{LateContext, LateLintPass, LintContext};\n use rustc_middle::ty;\n@@ -57,6 +58,20 @@ impl MissingDoc {\n         *self.doc_hidden_stack.last().expect(\"empty doc_hidden_stack\")\n     }\n \n+    fn has_include(meta: Option<MetaItem>) -> bool {\n+        if_chain! {\n+            if let Some(meta) = meta;\n+            if let MetaItemKind::List(list) = meta.kind;\n+            if let Some(meta) = list.get(0);\n+            if let Some(name) = meta.ident();\n+            then {\n+                name.name == sym::include\n+            } else {\n+                false\n+            }\n+        }\n+    }\n+\n     fn check_missing_docs_attrs(\n         &self,\n         cx: &LateContext<'_>,\n@@ -80,7 +95,9 @@ impl MissingDoc {\n             return;\n         }\n \n-        let has_doc = attrs.iter().any(|a| a.doc_str().is_some());\n+        let has_doc = attrs\n+            .iter()\n+            .any(|a| a.doc_str().is_some() || Self::has_include(a.meta()));\n         if !has_doc {\n             span_lint(\n                 cx,"}, {"sha": "1f9db39cf8ca6a7e9742a2761d4bb89b466614f6", "filename": "clippy_lints/src/multiple_crate_versions.rs", "status": "removed", "additions": 0, "deletions": 101, "changes": 101, "blob_url": "https://github.com/rust-lang/rust/blob/e390e6c46914b54ea2ffa901f3c6b046b9a7b7d4/clippy_lints%2Fsrc%2Fmultiple_crate_versions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e390e6c46914b54ea2ffa901f3c6b046b9a7b7d4/clippy_lints%2Fsrc%2Fmultiple_crate_versions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmultiple_crate_versions.rs?ref=e390e6c46914b54ea2ffa901f3c6b046b9a7b7d4", "patch": "@@ -1,101 +0,0 @@\n-//! lint on multiple versions of a crate being used\n-\n-use clippy_utils::diagnostics::span_lint;\n-use clippy_utils::is_lint_allowed;\n-use rustc_hir::def_id::LOCAL_CRATE;\n-use rustc_hir::CRATE_HIR_ID;\n-use rustc_lint::{LateContext, LateLintPass};\n-use rustc_session::{declare_lint_pass, declare_tool_lint};\n-use rustc_span::source_map::DUMMY_SP;\n-\n-use cargo_metadata::{DependencyKind, Node, Package, PackageId};\n-use if_chain::if_chain;\n-use itertools::Itertools;\n-\n-declare_clippy_lint! {\n-    /// ### What it does\n-    /// Checks to see if multiple versions of a crate are being\n-    /// used.\n-    ///\n-    /// ### Why is this bad?\n-    /// This bloats the size of targets, and can lead to\n-    /// confusing error messages when structs or traits are used interchangeably\n-    /// between different versions of a crate.\n-    ///\n-    /// ### Known problems\n-    /// Because this can be caused purely by the dependencies\n-    /// themselves, it's not always possible to fix this issue.\n-    ///\n-    /// ### Example\n-    /// ```toml\n-    /// # This will pull in both winapi v0.3.x and v0.2.x, triggering a warning.\n-    /// [dependencies]\n-    /// ctrlc = \"=3.1.0\"\n-    /// ansi_term = \"=0.11.0\"\n-    /// ```\n-    #[clippy::version = \"pre 1.29.0\"]\n-    pub MULTIPLE_CRATE_VERSIONS,\n-    cargo,\n-    \"multiple versions of the same crate being used\"\n-}\n-\n-declare_lint_pass!(MultipleCrateVersions => [MULTIPLE_CRATE_VERSIONS]);\n-\n-impl LateLintPass<'_> for MultipleCrateVersions {\n-    fn check_crate(&mut self, cx: &LateContext<'_>) {\n-        if is_lint_allowed(cx, MULTIPLE_CRATE_VERSIONS, CRATE_HIR_ID) {\n-            return;\n-        }\n-\n-        let metadata = unwrap_cargo_metadata!(cx, MULTIPLE_CRATE_VERSIONS, true);\n-        let local_name = cx.tcx.crate_name(LOCAL_CRATE);\n-        let mut packages = metadata.packages;\n-        packages.sort_by(|a, b| a.name.cmp(&b.name));\n-\n-        if_chain! {\n-            if let Some(resolve) = &metadata.resolve;\n-            if let Some(local_id) = packages\n-                .iter()\n-                .find_map(|p| if p.name == local_name.as_str() { Some(&p.id) } else { None });\n-            then {\n-                for (name, group) in &packages.iter().group_by(|p| p.name.clone()) {\n-                    let group: Vec<&Package> = group.collect();\n-\n-                    if group.len() <= 1 {\n-                        continue;\n-                    }\n-\n-                    if group.iter().all(|p| is_normal_dep(&resolve.nodes, local_id, &p.id)) {\n-                        let mut versions: Vec<_> = group.into_iter().map(|p| &p.version).collect();\n-                        versions.sort();\n-                        let versions = versions.iter().join(\", \");\n-\n-                        span_lint(\n-                            cx,\n-                            MULTIPLE_CRATE_VERSIONS,\n-                            DUMMY_SP,\n-                            &format!(\"multiple versions for dependency `{}`: {}\", name, versions),\n-                        );\n-                    }\n-                }\n-            }\n-        }\n-    }\n-}\n-\n-fn is_normal_dep(nodes: &[Node], local_id: &PackageId, dep_id: &PackageId) -> bool {\n-    fn depends_on(node: &Node, dep_id: &PackageId) -> bool {\n-        node.deps.iter().any(|dep| {\n-            dep.pkg == *dep_id\n-                && dep\n-                    .dep_kinds\n-                    .iter()\n-                    .any(|info| matches!(info.kind, DependencyKind::Normal))\n-        })\n-    }\n-\n-    nodes\n-        .iter()\n-        .filter(|node| depends_on(node, dep_id))\n-        .any(|node| node.id == *local_id || is_normal_dep(nodes, local_id, &node.id))\n-}"}, {"sha": "4ba68c8eacd2474f7cbb00c27212e21793f771cf", "filename": "clippy_lints/src/mutable_debug_assertion.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fd495a0654611a6d784bae4698e5838b121e8004/clippy_lints%2Fsrc%2Fmutable_debug_assertion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd495a0654611a6d784bae4698e5838b121e8004/clippy_lints%2Fsrc%2Fmutable_debug_assertion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmutable_debug_assertion.rs?ref=fd495a0654611a6d784bae4698e5838b121e8004", "patch": "@@ -92,10 +92,6 @@ impl<'a, 'tcx> Visitor<'tcx> for MutArgVisitor<'a, 'tcx> {\n                 self.found = true;\n                 return;\n             },\n-            ExprKind::If(..) => {\n-                self.found = true;\n-                return;\n-            },\n             ExprKind::Path(_) => {\n                 if let Some(adj) = self.cx.typeck_results().adjustments().get(expr.hir_id) {\n                     if adj"}, {"sha": "47121ad84f2c9af791edfeb2b77ca8ce9863b987", "filename": "clippy_lints/src/new_without_default.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/fd495a0654611a6d784bae4698e5838b121e8004/clippy_lints%2Fsrc%2Fnew_without_default.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd495a0654611a6d784bae4698e5838b121e8004/clippy_lints%2Fsrc%2Fnew_without_default.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fnew_without_default.rs?ref=fd495a0654611a6d784bae4698e5838b121e8004", "patch": "@@ -13,7 +13,7 @@ use rustc_span::sym;\n \n declare_clippy_lint! {\n     /// ### What it does\n-    /// Checks for types with a `fn new() -> Self` method and no\n+    /// Checks for public types with a `pub fn new() -> Self` method and no\n     /// implementation of\n     /// [`Default`](https://doc.rust-lang.org/std/default/trait.Default.html).\n     ///\n@@ -24,10 +24,10 @@ declare_clippy_lint! {\n     ///\n     /// ### Example\n     /// ```ignore\n-    /// struct Foo(Bar);\n+    /// pub struct Foo(Bar);\n     ///\n     /// impl Foo {\n-    ///     fn new() -> Self {\n+    ///     pub fn new() -> Self {\n     ///         Foo(Bar::new())\n     ///     }\n     /// }\n@@ -36,7 +36,7 @@ declare_clippy_lint! {\n     /// To fix the lint, add a `Default` implementation that delegates to `new`:\n     ///\n     /// ```ignore\n-    /// struct Foo(Bar);\n+    /// pub struct Foo(Bar);\n     ///\n     /// impl Default for Foo {\n     ///     fn default() -> Self {\n@@ -47,7 +47,7 @@ declare_clippy_lint! {\n     #[clippy::version = \"pre 1.29.0\"]\n     pub NEW_WITHOUT_DEFAULT,\n     style,\n-    \"`fn new() -> Self` method without `Default` implementation\"\n+    \"`pub fn new() -> Self` method without `Default` implementation\"\n }\n \n #[derive(Clone, Default)]"}, {"sha": "e213c208794c1d4d0dd43c6a995de040b99bfa9a", "filename": "clippy_lints/src/ranges.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fd495a0654611a6d784bae4698e5838b121e8004/clippy_lints%2Fsrc%2Franges.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd495a0654611a6d784bae4698e5838b121e8004/clippy_lints%2Fsrc%2Franges.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Franges.rs?ref=fd495a0654611a6d784bae4698e5838b121e8004", "patch": "@@ -330,7 +330,7 @@ fn check_range_zip_with_len(cx: &LateContext<'_>, path: &PathSegment<'_>, args:\n         // `.iter()` and `.len()` called on same `Path`\n         if let ExprKind::Path(QPath::Resolved(_, iter_path)) = iter_args[0].kind;\n         if let ExprKind::Path(QPath::Resolved(_, len_path)) = len_args[0].kind;\n-        if SpanlessEq::new(cx).eq_path_segments(&iter_path.segments, &len_path.segments);\n+        if SpanlessEq::new(cx).eq_path_segments(iter_path.segments, len_path.segments);\n         then {\n             span_lint(cx,\n                 RANGE_ZIP_WITH_LEN,"}, {"sha": "5bb9740749b6c0b3032a945813646c24ef08ff7c", "filename": "clippy_lints/src/recursive_format_impl.rs", "status": "added", "additions": 190, "deletions": 0, "changes": 190, "blob_url": "https://github.com/rust-lang/rust/blob/fd495a0654611a6d784bae4698e5838b121e8004/clippy_lints%2Fsrc%2Frecursive_format_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd495a0654611a6d784bae4698e5838b121e8004/clippy_lints%2Fsrc%2Frecursive_format_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Frecursive_format_impl.rs?ref=fd495a0654611a6d784bae4698e5838b121e8004", "patch": "@@ -0,0 +1,190 @@\n+use clippy_utils::diagnostics::span_lint;\n+use clippy_utils::macros::{is_format_macro, root_macro_call_first_node, FormatArgsArg, FormatArgsExpn};\n+use clippy_utils::{is_diag_trait_item, path_to_local, peel_ref_operators};\n+use if_chain::if_chain;\n+use rustc_hir::{Expr, ExprKind, Impl, Item, ItemKind, QPath};\n+use rustc_lint::{LateContext, LateLintPass};\n+use rustc_session::{declare_tool_lint, impl_lint_pass};\n+use rustc_span::{sym, symbol::kw, Symbol};\n+\n+#[derive(Clone, Copy)]\n+enum FormatTrait {\n+    Debug,\n+    Display,\n+}\n+\n+impl FormatTrait {\n+    fn name(self) -> Symbol {\n+        match self {\n+            FormatTrait::Debug => sym::Debug,\n+            FormatTrait::Display => sym::Display,\n+        }\n+    }\n+}\n+\n+declare_clippy_lint! {\n+    /// ### What it does\n+    /// Checks for format trait implementations (e.g. `Display`) with a recursive call to itself\n+    /// which uses `self` as a parameter.\n+    /// This is typically done indirectly with the `write!` macro or with `to_string()`.\n+    ///\n+    /// ### Why is this bad?\n+    /// This will lead to infinite recursion and a stack overflow.\n+    ///\n+    /// ### Example\n+    ///\n+    /// ```rust\n+    /// use std::fmt;\n+    ///\n+    /// struct Structure(i32);\n+    /// impl fmt::Display for Structure {\n+    ///     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+    ///         write!(f, \"{}\", self.to_string())\n+    ///     }\n+    /// }\n+    ///\n+    /// ```\n+    /// Use instead:\n+    /// ```rust\n+    /// use std::fmt;\n+    ///\n+    /// struct Structure(i32);\n+    /// impl fmt::Display for Structure {\n+    ///     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+    ///         write!(f, \"{}\", self.0)\n+    ///     }\n+    /// }\n+    /// ```\n+    #[clippy::version = \"1.48.0\"]\n+    pub RECURSIVE_FORMAT_IMPL,\n+    correctness,\n+    \"Format trait method called while implementing the same Format trait\"\n+}\n+\n+#[derive(Default)]\n+pub struct RecursiveFormatImpl {\n+    // Whether we are inside Display or Debug trait impl - None for neither\n+    format_trait_impl: Option<FormatTrait>,\n+}\n+\n+impl RecursiveFormatImpl {\n+    pub fn new() -> Self {\n+        Self {\n+            format_trait_impl: None,\n+        }\n+    }\n+}\n+\n+impl_lint_pass!(RecursiveFormatImpl => [RECURSIVE_FORMAT_IMPL]);\n+\n+impl<'tcx> LateLintPass<'tcx> for RecursiveFormatImpl {\n+    fn check_item(&mut self, cx: &LateContext<'_>, item: &Item<'_>) {\n+        if let Some(format_trait_impl) = is_format_trait_impl(cx, item) {\n+            self.format_trait_impl = Some(format_trait_impl);\n+        }\n+    }\n+\n+    fn check_item_post(&mut self, cx: &LateContext<'_>, item: &Item<'_>) {\n+        // Assume no nested Impl of Debug and Display within eachother\n+        if is_format_trait_impl(cx, item).is_some() {\n+            self.format_trait_impl = None;\n+        }\n+    }\n+\n+    fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) {\n+        match self.format_trait_impl {\n+            Some(FormatTrait::Display) => {\n+                check_to_string_in_display(cx, expr);\n+                check_self_in_format_args(cx, expr, FormatTrait::Display);\n+            },\n+            Some(FormatTrait::Debug) => {\n+                check_self_in_format_args(cx, expr, FormatTrait::Debug);\n+            },\n+            None => {},\n+        }\n+    }\n+}\n+\n+fn check_to_string_in_display(cx: &LateContext<'_>, expr: &Expr<'_>) {\n+    if_chain! {\n+        // Get the hir_id of the object we are calling the method on\n+        if let ExprKind::MethodCall(path, [ref self_arg, ..], _) = expr.kind;\n+        // Is the method to_string() ?\n+        if path.ident.name == sym!(to_string);\n+        // Is the method a part of the ToString trait? (i.e. not to_string() implemented\n+        // separately)\n+        if let Some(expr_def_id) = cx.typeck_results().type_dependent_def_id(expr.hir_id);\n+        if is_diag_trait_item(cx, expr_def_id, sym::ToString);\n+        // Is the method is called on self\n+        if let ExprKind::Path(QPath::Resolved(_, path)) = self_arg.kind;\n+        if let [segment] = path.segments;\n+        if segment.ident.name == kw::SelfLower;\n+        then {\n+            span_lint(\n+                cx,\n+                RECURSIVE_FORMAT_IMPL,\n+                expr.span,\n+                \"using `self.to_string` in `fmt::Display` implementation will cause infinite recursion\",\n+            );\n+        }\n+    }\n+}\n+\n+fn check_self_in_format_args<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>, impl_trait: FormatTrait) {\n+    // Check each arg in format calls - do we ever use Display on self (directly or via deref)?\n+    if_chain! {\n+        if let Some(outer_macro) = root_macro_call_first_node(cx, expr);\n+        if let macro_def_id = outer_macro.def_id;\n+        if let Some(format_args) = FormatArgsExpn::find_nested(cx, expr, outer_macro.expn);\n+        if is_format_macro(cx, macro_def_id);\n+        if let Some(args) = format_args.args();\n+        then {\n+            for arg in args {\n+                if arg.format_trait != impl_trait.name() {\n+                    continue;\n+                }\n+                check_format_arg_self(cx, expr, &arg, impl_trait);\n+            }\n+        }\n+    }\n+}\n+\n+fn check_format_arg_self(cx: &LateContext<'_>, expr: &Expr<'_>, arg: &FormatArgsArg<'_>, impl_trait: FormatTrait) {\n+    // Handle multiple dereferencing of references e.g. &&self\n+    // Handle dereference of &self -> self that is equivalent (i.e. via *self in fmt() impl)\n+    // Since the argument to fmt is itself a reference: &self\n+    let reference = peel_ref_operators(cx, arg.value);\n+    let map = cx.tcx.hir();\n+    // Is the reference self?\n+    let symbol_ident = impl_trait.name().to_ident_string();\n+    if path_to_local(reference).map(|x| map.name(x)) == Some(kw::SelfLower) {\n+        span_lint(\n+            cx,\n+            RECURSIVE_FORMAT_IMPL,\n+            expr.span,\n+            &format!(\n+                \"using `self` as `{}` in `impl {}` will cause infinite recursion\",\n+                &symbol_ident, &symbol_ident\n+            ),\n+        );\n+    }\n+}\n+\n+fn is_format_trait_impl(cx: &LateContext<'_>, item: &Item<'_>) -> Option<FormatTrait> {\n+    if_chain! {\n+        // Are we at an Impl?\n+        if let ItemKind::Impl(Impl { of_trait: Some(trait_ref), .. }) = &item.kind;\n+        if let Some(did) = trait_ref.trait_def_id();\n+        if let Some(name) = cx.tcx.get_diagnostic_name(did);\n+        then {\n+            // Is Impl for Debug or Display?\n+            match name {\n+                sym::Debug => Some(FormatTrait::Debug),\n+                sym::Display => Some(FormatTrait::Display),\n+                _ => None,\n+            }\n+        } else {\n+            None\n+        }\n+    }\n+}"}, {"sha": "25a9072ef6e0cf0a2ccd2eb395ec90d49c6cf3c0", "filename": "clippy_lints/src/redundant_slicing.rs", "status": "modified", "additions": 102, "deletions": 22, "changes": 124, "blob_url": "https://github.com/rust-lang/rust/blob/fd495a0654611a6d784bae4698e5838b121e8004/clippy_lints%2Fsrc%2Fredundant_slicing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd495a0654611a6d784bae4698e5838b121e8004/clippy_lints%2Fsrc%2Fredundant_slicing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fredundant_slicing.rs?ref=fd495a0654611a6d784bae4698e5838b121e8004", "patch": "@@ -1,11 +1,14 @@\n use clippy_utils::diagnostics::span_lint_and_sugg;\n use clippy_utils::get_parent_expr;\n use clippy_utils::source::snippet_with_context;\n-use clippy_utils::ty::is_type_lang_item;\n+use clippy_utils::ty::{is_type_lang_item, peel_mid_ty_refs};\n use if_chain::if_chain;\n+use rustc_ast::util::parser::PREC_PREFIX;\n use rustc_errors::Applicability;\n use rustc_hir::{BorrowKind, Expr, ExprKind, LangItem, Mutability};\n-use rustc_lint::{LateContext, LateLintPass};\n+use rustc_lint::{LateContext, LateLintPass, Lint};\n+use rustc_middle::ty::adjustment::{Adjust, AutoBorrow, AutoBorrowMutability};\n+use rustc_middle::ty::subst::GenericArg;\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n \n declare_clippy_lint! {\n@@ -39,7 +42,34 @@ declare_clippy_lint! {\n     \"redundant slicing of the whole range of a type\"\n }\n \n-declare_lint_pass!(RedundantSlicing => [REDUNDANT_SLICING]);\n+declare_clippy_lint! {\n+    /// ### What it does\n+    /// Checks for slicing expressions which are equivalent to dereferencing the\n+    /// value.\n+    ///\n+    /// ### Why is this bad?\n+    /// Some people may prefer to dereference rather than slice.\n+    ///\n+    /// ### Example\n+    /// ```rust\n+    /// let vec = vec![1, 2, 3];\n+    /// let slice = &vec[..];\n+    /// ```\n+    /// Use instead:\n+    /// ```rust\n+    /// let vec = vec![1, 2, 3];\n+    /// let slice = &*vec;\n+    /// ```\n+    #[clippy::version = \"1.60.0\"]\n+    pub DEREF_BY_SLICING,\n+    restriction,\n+    \"slicing instead of dereferencing\"\n+}\n+\n+declare_lint_pass!(RedundantSlicing => [REDUNDANT_SLICING, DEREF_BY_SLICING]);\n+\n+static REDUNDANT_SLICING_LINT: (&Lint, &str) = (REDUNDANT_SLICING, \"redundant slicing of the whole range\");\n+static DEREF_BY_SLICING_LINT: (&Lint, &str) = (DEREF_BY_SLICING, \"slicing when dereferencing would work\");\n \n impl<'tcx> LateLintPass<'tcx> for RedundantSlicing {\n     fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) {\n@@ -53,34 +83,84 @@ impl<'tcx> LateLintPass<'tcx> for RedundantSlicing {\n             if addressee.span.ctxt() == ctxt;\n             if let ExprKind::Index(indexed, range) = addressee.kind;\n             if is_type_lang_item(cx, cx.typeck_results().expr_ty_adjusted(range), LangItem::RangeFull);\n-            if cx.typeck_results().expr_ty(expr) == cx.typeck_results().expr_ty(indexed);\n             then {\n+                let (expr_ty, expr_ref_count) = peel_mid_ty_refs(cx.typeck_results().expr_ty(expr));\n+                let (indexed_ty, indexed_ref_count) = peel_mid_ty_refs(cx.typeck_results().expr_ty(indexed));\n+                let parent_expr = get_parent_expr(cx, expr);\n+                let needs_parens_for_prefix = parent_expr.map_or(false, |parent| {\n+                    parent.precedence().order() > PREC_PREFIX\n+                });\n                 let mut app = Applicability::MachineApplicable;\n-                let snip = snippet_with_context(cx, indexed.span, ctxt, \"..\", &mut app).0;\n \n-                let (reborrow_str, help_str) = if mutability == Mutability::Mut {\n-                    // The slice was used to reborrow the mutable reference.\n-                    (\"&mut *\", \"reborrow the original value instead\")\n-                } else if matches!(\n-                    get_parent_expr(cx, expr),\n-                    Some(Expr {\n-                        kind: ExprKind::AddrOf(BorrowKind::Ref, Mutability::Mut, _),\n-                        ..\n-                    })\n-                ) {\n-                    // The slice was used to make a temporary reference.\n-                    (\"&*\", \"reborrow the original value instead\")\n+                let ((lint, msg), help, sugg) = if expr_ty == indexed_ty {\n+                    if expr_ref_count > indexed_ref_count {\n+                        // Indexing takes self by reference and can't return a reference to that\n+                        // reference as it's a local variable. The only way this could happen is if\n+                        // `self` contains a reference to the `Self` type. If this occurs then the\n+                        // lint no longer applies as it's essentially a field access, which is not\n+                        // redundant.\n+                        return;\n+                    }\n+                    let deref_count = indexed_ref_count - expr_ref_count;\n+\n+                    let (lint, reborrow_str, help_str) = if mutability == Mutability::Mut {\n+                        // The slice was used to reborrow the mutable reference.\n+                        (DEREF_BY_SLICING_LINT, \"&mut *\", \"reborrow the original value instead\")\n+                    } else if matches!(\n+                        parent_expr,\n+                        Some(Expr {\n+                            kind: ExprKind::AddrOf(BorrowKind::Ref, Mutability::Mut, _),\n+                            ..\n+                        })\n+                    ) || cx.typeck_results().expr_adjustments(expr).first().map_or(false, |a| {\n+                        matches!(a.kind, Adjust::Borrow(AutoBorrow::Ref(_, AutoBorrowMutability::Mut { .. })))\n+                    }) {\n+                        // The slice was used to make a temporary reference.\n+                        (DEREF_BY_SLICING_LINT, \"&*\", \"reborrow the original value instead\")\n+                    } else if deref_count != 0 {\n+                        (DEREF_BY_SLICING_LINT, \"\", \"dereference the original value instead\")\n+                    } else {\n+                        (REDUNDANT_SLICING_LINT, \"\", \"use the original value instead\")\n+                    };\n+\n+                    let snip = snippet_with_context(cx, indexed.span, ctxt, \"..\", &mut app).0;\n+                    let sugg = if (deref_count != 0 || !reborrow_str.is_empty()) && needs_parens_for_prefix {\n+                        format!(\"({}{}{})\", reborrow_str, \"*\".repeat(deref_count), snip)\n+                    } else {\n+                        format!(\"{}{}{}\", reborrow_str, \"*\".repeat(deref_count), snip)\n+                    };\n+\n+                    (lint, help_str, sugg)\n+                } else if let Some(target_id) = cx.tcx.lang_items().deref_target() {\n+                    if let Ok(deref_ty) = cx.tcx.try_normalize_erasing_regions(\n+                        cx.param_env,\n+                        cx.tcx.mk_projection(target_id, cx.tcx.mk_substs([GenericArg::from(indexed_ty)].into_iter())),\n+                    ) {\n+                        if deref_ty == expr_ty {\n+                            let snip = snippet_with_context(cx, indexed.span, ctxt, \"..\", &mut app).0;\n+                            let sugg = if needs_parens_for_prefix {\n+                                format!(\"(&{}{}*{})\", mutability.prefix_str(), \"*\".repeat(indexed_ref_count), snip)\n+                            } else {\n+                                format!(\"&{}{}*{}\", mutability.prefix_str(), \"*\".repeat(indexed_ref_count), snip)\n+                            };\n+                            (DEREF_BY_SLICING_LINT, \"dereference the original value instead\", sugg)\n+                        } else {\n+                            return;\n+                        }\n+                    } else {\n+                        return;\n+                    }\n                 } else {\n-                    (\"\", \"use the original value instead\")\n+                    return;\n                 };\n \n                 span_lint_and_sugg(\n                     cx,\n-                    REDUNDANT_SLICING,\n+                    lint,\n                     expr.span,\n-                    \"redundant slicing of the whole range\",\n-                    help_str,\n-                    format!(\"{}{}\", reborrow_str, snip),\n+                    msg,\n+                    help,\n+                    sugg,\n                     app,\n                 );\n             }"}, {"sha": "03060d78fc5af39d325068a721a991b9e96a7e83", "filename": "clippy_lints/src/to_string_in_display.rs", "status": "removed", "additions": 0, "deletions": 123, "changes": 123, "blob_url": "https://github.com/rust-lang/rust/blob/e390e6c46914b54ea2ffa901f3c6b046b9a7b7d4/clippy_lints%2Fsrc%2Fto_string_in_display.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e390e6c46914b54ea2ffa901f3c6b046b9a7b7d4/clippy_lints%2Fsrc%2Fto_string_in_display.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fto_string_in_display.rs?ref=e390e6c46914b54ea2ffa901f3c6b046b9a7b7d4", "patch": "@@ -1,123 +0,0 @@\n-use clippy_utils::diagnostics::span_lint;\n-use clippy_utils::{is_diag_trait_item, match_def_path, path_to_local_id, paths};\n-use if_chain::if_chain;\n-use rustc_hir::{Expr, ExprKind, HirId, Impl, ImplItem, ImplItemKind, Item, ItemKind};\n-use rustc_lint::{LateContext, LateLintPass};\n-use rustc_session::{declare_tool_lint, impl_lint_pass};\n-use rustc_span::symbol::sym;\n-\n-declare_clippy_lint! {\n-    /// ### What it does\n-    /// Checks for uses of `to_string()` in `Display` traits.\n-    ///\n-    /// ### Why is this bad?\n-    /// Usually `to_string` is implemented indirectly\n-    /// via `Display`. Hence using it while implementing `Display` would\n-    /// lead to infinite recursion.\n-    ///\n-    /// ### Example\n-    ///\n-    /// ```rust\n-    /// use std::fmt;\n-    ///\n-    /// struct Structure(i32);\n-    /// impl fmt::Display for Structure {\n-    ///     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-    ///         write!(f, \"{}\", self.to_string())\n-    ///     }\n-    /// }\n-    ///\n-    /// ```\n-    /// Use instead:\n-    /// ```rust\n-    /// use std::fmt;\n-    ///\n-    /// struct Structure(i32);\n-    /// impl fmt::Display for Structure {\n-    ///     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-    ///         write!(f, \"{}\", self.0)\n-    ///     }\n-    /// }\n-    /// ```\n-    #[clippy::version = \"1.48.0\"]\n-    pub TO_STRING_IN_DISPLAY,\n-    correctness,\n-    \"`to_string` method used while implementing `Display` trait\"\n-}\n-\n-#[derive(Default)]\n-pub struct ToStringInDisplay {\n-    in_display_impl: bool,\n-    self_hir_id: Option<HirId>,\n-}\n-\n-impl ToStringInDisplay {\n-    pub fn new() -> Self {\n-        Self {\n-            in_display_impl: false,\n-            self_hir_id: None,\n-        }\n-    }\n-}\n-\n-impl_lint_pass!(ToStringInDisplay => [TO_STRING_IN_DISPLAY]);\n-\n-impl LateLintPass<'_> for ToStringInDisplay {\n-    fn check_item(&mut self, cx: &LateContext<'_>, item: &Item<'_>) {\n-        if is_display_impl(cx, item) {\n-            self.in_display_impl = true;\n-        }\n-    }\n-\n-    fn check_item_post(&mut self, cx: &LateContext<'_>, item: &Item<'_>) {\n-        if is_display_impl(cx, item) {\n-            self.in_display_impl = false;\n-            self.self_hir_id = None;\n-        }\n-    }\n-\n-    fn check_impl_item(&mut self, cx: &LateContext<'_>, impl_item: &ImplItem<'_>) {\n-        if_chain! {\n-            if self.in_display_impl;\n-            if let ImplItemKind::Fn(.., body_id) = &impl_item.kind;\n-            let body = cx.tcx.hir().body(*body_id);\n-            if !body.params.is_empty();\n-            then {\n-                let self_param = &body.params[0];\n-                self.self_hir_id = Some(self_param.pat.hir_id);\n-            }\n-        }\n-    }\n-\n-    fn check_expr(&mut self, cx: &LateContext<'_>, expr: &Expr<'_>) {\n-        if_chain! {\n-            if self.in_display_impl;\n-            if let Some(self_hir_id) = self.self_hir_id;\n-            if let ExprKind::MethodCall(path, [ref self_arg, ..], _) = expr.kind;\n-            if path.ident.name == sym!(to_string);\n-            if let Some(expr_def_id) = cx.typeck_results().type_dependent_def_id(expr.hir_id);\n-            if is_diag_trait_item(cx, expr_def_id, sym::ToString);\n-            if path_to_local_id(self_arg, self_hir_id);\n-            then {\n-                span_lint(\n-                    cx,\n-                    TO_STRING_IN_DISPLAY,\n-                    expr.span,\n-                    \"using `to_string` in `fmt::Display` implementation might lead to infinite recursion\",\n-                );\n-            }\n-        }\n-    }\n-}\n-\n-fn is_display_impl(cx: &LateContext<'_>, item: &Item<'_>) -> bool {\n-    if_chain! {\n-        if let ItemKind::Impl(Impl { of_trait: Some(trait_ref), .. }) = &item.kind;\n-        if let Some(did) = trait_ref.trait_def_id();\n-        then {\n-            match_def_path(cx, did, &paths::DISPLAY_TRAIT)\n-        } else {\n-            false\n-        }\n-    }\n-}"}, {"sha": "be9d538c36267cf8fd3243dc9283b5724f18f64c", "filename": "clippy_lints/src/trait_bounds.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/fd495a0654611a6d784bae4698e5838b121e8004/clippy_lints%2Fsrc%2Ftrait_bounds.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd495a0654611a6d784bae4698e5838b121e8004/clippy_lints%2Fsrc%2Ftrait_bounds.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Ftrait_bounds.rs?ref=fd495a0654611a6d784bae4698e5838b121e8004", "patch": "@@ -98,8 +98,9 @@ impl<'tcx> LateLintPass<'tcx> for TraitBounds {\n                 if let WherePredicate::BoundPredicate(ref bound_predicate) = predicate;\n                 if !bound_predicate.span.from_expansion();\n                 if let TyKind::Path(QPath::Resolved(_, Path { segments, .. })) = bound_predicate.bounded_ty.kind;\n-                if let Some(PathSegment { res: Some(Res::SelfTy{ trait_: Some(def_id), alias_to: _ }), .. }) = segments.first();\n-\n+                if let Some(PathSegment {\n+                    res: Some(Res::SelfTy{ trait_: Some(def_id), alias_to: _ }), ..\n+                }) = segments.first();\n                 if let Some(\n                     Node::Item(\n                         Item {"}, {"sha": "22a8c53a5852e805476cfc2603b446fabb5e496c", "filename": "clippy_lints/src/transmute/mod.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/fd495a0654611a6d784bae4698e5838b121e8004/clippy_lints%2Fsrc%2Ftransmute%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd495a0654611a6d784bae4698e5838b121e8004/clippy_lints%2Fsrc%2Ftransmute%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Ftransmute%2Fmod.rs?ref=fd495a0654611a6d784bae4698e5838b121e8004", "patch": "@@ -358,7 +358,8 @@ declare_clippy_lint! {\n \n declare_clippy_lint! {\n     /// ### What it does\n-    /// Checks for transmutes either to or from a type which does not have a defined representation.\n+    /// Checks for transmutes between types which do not have a representation defined relative to\n+    /// each other.\n     ///\n     /// ### Why is this bad?\n     /// The results of such a transmute are not defined.\n@@ -376,7 +377,7 @@ declare_clippy_lint! {\n     /// ```\n     #[clippy::version = \"1.60.0\"]\n     pub TRANSMUTE_UNDEFINED_REPR,\n-    nursery,\n+    correctness,\n     \"transmute to or from a type with an undefined representation\"\n }\n "}, {"sha": "05eadab3e6ccdcc500f881b62668bbc1a53a2a08", "filename": "clippy_lints/src/transmute/transmute_undefined_repr.rs", "status": "modified", "additions": 88, "deletions": 46, "changes": 134, "blob_url": "https://github.com/rust-lang/rust/blob/fd495a0654611a6d784bae4698e5838b121e8004/clippy_lints%2Fsrc%2Ftransmute%2Ftransmute_undefined_repr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd495a0654611a6d784bae4698e5838b121e8004/clippy_lints%2Fsrc%2Ftransmute%2Ftransmute_undefined_repr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Ftransmute%2Ftransmute_undefined_repr.rs?ref=fd495a0654611a6d784bae4698e5838b121e8004", "patch": "@@ -1,5 +1,6 @@\n use super::TRANSMUTE_UNDEFINED_REPR;\n use clippy_utils::diagnostics::span_lint_and_then;\n+use clippy_utils::ty::is_c_void;\n use rustc_hir::Expr;\n use rustc_lint::LateContext;\n use rustc_middle::ty::subst::Subst;\n@@ -18,33 +19,55 @@ pub(super) fn check<'tcx>(\n \n     while from_ty != to_ty {\n         match reduce_refs(cx, e.span, from_ty, to_ty) {\n-            ReducedTys::FromFatPtr { unsized_ty, .. } => {\n-                span_lint_and_then(\n-                    cx,\n-                    TRANSMUTE_UNDEFINED_REPR,\n-                    e.span,\n-                    &format!(\"transmute from `{}` which has an undefined layout\", from_ty_orig),\n-                    |diag| {\n-                        if from_ty_orig.peel_refs() != unsized_ty {\n-                            diag.note(&format!(\"the contained type `&{}` has an undefined layout\", unsized_ty));\n-                        }\n-                    },\n-                );\n-                return true;\n+            ReducedTys::FromFatPtr {\n+                unsized_ty,\n+                to_ty: to_sub_ty,\n+            } => match reduce_ty(cx, to_sub_ty) {\n+                ReducedTy::IntArray | ReducedTy::TypeErasure => break,\n+                ReducedTy::Ref(to_sub_ty) => {\n+                    from_ty = unsized_ty;\n+                    to_ty = to_sub_ty;\n+                    continue;\n+                },\n+                _ => {\n+                    span_lint_and_then(\n+                        cx,\n+                        TRANSMUTE_UNDEFINED_REPR,\n+                        e.span,\n+                        &format!(\"transmute from `{}` which has an undefined layout\", from_ty_orig),\n+                        |diag| {\n+                            if from_ty_orig.peel_refs() != unsized_ty {\n+                                diag.note(&format!(\"the contained type `&{}` has an undefined layout\", unsized_ty));\n+                            }\n+                        },\n+                    );\n+                    return true;\n+                },\n             },\n-            ReducedTys::ToFatPtr { unsized_ty, .. } => {\n-                span_lint_and_then(\n-                    cx,\n-                    TRANSMUTE_UNDEFINED_REPR,\n-                    e.span,\n-                    &format!(\"transmute to `{}` which has an undefined layout\", to_ty_orig),\n-                    |diag| {\n-                        if to_ty_orig.peel_refs() != unsized_ty {\n-                            diag.note(&format!(\"the contained type `&{}` has an undefined layout\", unsized_ty));\n-                        }\n-                    },\n-                );\n-                return true;\n+            ReducedTys::ToFatPtr {\n+                unsized_ty,\n+                from_ty: from_sub_ty,\n+            } => match reduce_ty(cx, from_sub_ty) {\n+                ReducedTy::IntArray | ReducedTy::TypeErasure => break,\n+                ReducedTy::Ref(from_sub_ty) => {\n+                    from_ty = from_sub_ty;\n+                    to_ty = unsized_ty;\n+                    continue;\n+                },\n+                _ => {\n+                    span_lint_and_then(\n+                        cx,\n+                        TRANSMUTE_UNDEFINED_REPR,\n+                        e.span,\n+                        &format!(\"transmute to `{}` which has an undefined layout\", to_ty_orig),\n+                        |diag| {\n+                            if to_ty_orig.peel_refs() != unsized_ty {\n+                                diag.note(&format!(\"the contained type `&{}` has an undefined layout\", unsized_ty));\n+                            }\n+                        },\n+                    );\n+                    return true;\n+                },\n             },\n             ReducedTys::ToPtr {\n                 from_ty: from_sub_ty,\n@@ -100,7 +123,8 @@ pub(super) fn check<'tcx>(\n                 from_ty: from_sub_ty,\n                 to_ty: to_sub_ty,\n             } => match (reduce_ty(cx, from_sub_ty), reduce_ty(cx, to_sub_ty)) {\n-                (ReducedTy::IntArray, _) | (_, ReducedTy::IntArray) => return false,\n+                (ReducedTy::IntArray | ReducedTy::TypeErasure, _)\n+                | (_, ReducedTy::IntArray | ReducedTy::TypeErasure) => return false,\n                 (ReducedTy::UnorderedFields(from_ty), ReducedTy::UnorderedFields(to_ty)) if from_ty != to_ty => {\n                     span_lint_and_then(\n                         cx,\n@@ -184,13 +208,14 @@ pub(super) fn check<'tcx>(\n }\n \n enum ReducedTys<'tcx> {\n-    FromFatPtr { unsized_ty: Ty<'tcx> },\n-    ToFatPtr { unsized_ty: Ty<'tcx> },\n+    FromFatPtr { unsized_ty: Ty<'tcx>, to_ty: Ty<'tcx> },\n+    ToFatPtr { unsized_ty: Ty<'tcx>, from_ty: Ty<'tcx> },\n     ToPtr { from_ty: Ty<'tcx>, to_ty: Ty<'tcx> },\n     FromPtr { from_ty: Ty<'tcx>, to_ty: Ty<'tcx> },\n     Other { from_ty: Ty<'tcx>, to_ty: Ty<'tcx> },\n }\n \n+/// Remove references so long as both types are references.\n fn reduce_refs<'tcx>(\n     cx: &LateContext<'tcx>,\n     span: Span,\n@@ -200,27 +225,27 @@ fn reduce_refs<'tcx>(\n     loop {\n         return match (from_ty.kind(), to_ty.kind()) {\n             (\n-                &ty::Ref(_, from_sub_ty, _) | &ty::RawPtr(TypeAndMut { ty: from_sub_ty, .. }),\n-                &ty::Ref(_, to_sub_ty, _) | &ty::RawPtr(TypeAndMut { ty: to_sub_ty, .. }),\n+                &(ty::Ref(_, from_sub_ty, _) | ty::RawPtr(TypeAndMut { ty: from_sub_ty, .. })),\n+                &(ty::Ref(_, to_sub_ty, _) | ty::RawPtr(TypeAndMut { ty: to_sub_ty, .. })),\n             ) => {\n                 from_ty = from_sub_ty;\n                 to_ty = to_sub_ty;\n                 continue;\n             },\n-            (&ty::Ref(_, unsized_ty, _) | &ty::RawPtr(TypeAndMut { ty: unsized_ty, .. }), _)\n+            (&(ty::Ref(_, unsized_ty, _) | ty::RawPtr(TypeAndMut { ty: unsized_ty, .. })), _)\n                 if !unsized_ty.is_sized(cx.tcx.at(span), cx.param_env) =>\n             {\n-                ReducedTys::FromFatPtr { unsized_ty }\n+                ReducedTys::FromFatPtr { unsized_ty, to_ty }\n             },\n-            (_, &ty::Ref(_, unsized_ty, _) | &ty::RawPtr(TypeAndMut { ty: unsized_ty, .. }))\n+            (_, &(ty::Ref(_, unsized_ty, _) | ty::RawPtr(TypeAndMut { ty: unsized_ty, .. })))\n                 if !unsized_ty.is_sized(cx.tcx.at(span), cx.param_env) =>\n             {\n-                ReducedTys::ToFatPtr { unsized_ty }\n+                ReducedTys::ToFatPtr { unsized_ty, from_ty }\n             },\n-            (&ty::Ref(_, from_ty, _) | &ty::RawPtr(TypeAndMut { ty: from_ty, .. }), _) => {\n+            (&(ty::Ref(_, from_ty, _) | ty::RawPtr(TypeAndMut { ty: from_ty, .. })), _) => {\n                 ReducedTys::FromPtr { from_ty, to_ty }\n             },\n-            (_, &ty::Ref(_, to_ty, _) | &ty::RawPtr(TypeAndMut { ty: to_ty, .. })) => {\n+            (_, &(ty::Ref(_, to_ty, _) | ty::RawPtr(TypeAndMut { ty: to_ty, .. }))) => {\n                 ReducedTys::ToPtr { from_ty, to_ty }\n             },\n             _ => ReducedTys::Other { from_ty, to_ty },\n@@ -229,13 +254,23 @@ fn reduce_refs<'tcx>(\n }\n \n enum ReducedTy<'tcx> {\n+    /// The type can be used for type erasure.\n+    TypeErasure,\n+    /// The type is a struct containing either zero non-zero sized fields, or multiple non-zero\n+    /// sized fields with a defined order.\n     OrderedFields(Ty<'tcx>),\n+    /// The type is a struct containing multiple non-zero sized fields with no defined order.\n     UnorderedFields(Ty<'tcx>),\n+    /// The type is a reference to the contained type.\n     Ref(Ty<'tcx>),\n-    Other(Ty<'tcx>),\n+    /// The type is an array of a primitive integer type. These can be used as storage for a value\n+    /// of another type.\n     IntArray,\n+    /// Any other type.\n+    Other(Ty<'tcx>),\n }\n \n+/// Reduce structs containing a single non-zero sized field to it's contained type.\n fn reduce_ty<'tcx>(cx: &LateContext<'tcx>, mut ty: Ty<'tcx>) -> ReducedTy<'tcx> {\n     loop {\n         ty = cx.tcx.try_normalize_erasing_regions(cx.param_env, ty).unwrap_or(ty);\n@@ -245,8 +280,9 @@ fn reduce_ty<'tcx>(cx: &LateContext<'tcx>, mut ty: Ty<'tcx>) -> ReducedTy<'tcx>\n                 ty = sub_ty;\n                 continue;\n             },\n+            ty::Tuple(args) if args.is_empty() => ReducedTy::TypeErasure,\n             ty::Tuple(args) => {\n-                let Some(sized_ty) =  args.iter().find(|&ty| !is_zero_sized_ty(cx, ty)) else {\n+                let Some(sized_ty) = args.iter().find(|&ty| !is_zero_sized_ty(cx, ty)) else {\n                     return ReducedTy::OrderedFields(ty);\n                 };\n                 if args.iter().all(|ty| is_zero_sized_ty(cx, ty)) {\n@@ -256,24 +292,30 @@ fn reduce_ty<'tcx>(cx: &LateContext<'tcx>, mut ty: Ty<'tcx>) -> ReducedTy<'tcx>\n                 ReducedTy::UnorderedFields(ty)\n             },\n             ty::Adt(def, substs) if def.is_struct() => {\n-                if def.repr.inhibit_struct_field_reordering_opt() {\n-                    return ReducedTy::OrderedFields(ty);\n-                }\n                 let mut iter = def\n                     .non_enum_variant()\n                     .fields\n                     .iter()\n                     .map(|f| cx.tcx.type_of(f.did).subst(cx.tcx, substs));\n-                let Some(sized_ty) = iter.find(|ty| !is_zero_sized_ty(cx, *ty)) else {\n-                    return ReducedTy::OrderedFields(ty);\n+                let Some(sized_ty) = iter.find(|&ty| !is_zero_sized_ty(cx, ty)) else {\n+                    return ReducedTy::TypeErasure;\n                 };\n                 if iter.all(|ty| is_zero_sized_ty(cx, ty)) {\n                     ty = sized_ty;\n                     continue;\n                 }\n-                ReducedTy::UnorderedFields(ty)\n+                if def.repr.inhibit_struct_field_reordering_opt() {\n+                    ReducedTy::OrderedFields(ty)\n+                } else {\n+                    ReducedTy::UnorderedFields(ty)\n+                }\n+            },\n+            ty::Adt(def, _) if def.is_enum() && (def.variants.is_empty() || is_c_void(cx, ty)) => {\n+                ReducedTy::TypeErasure\n             },\n-            ty::Ref(..) | ty::RawPtr(_) => ReducedTy::Ref(ty),\n+            ty::Foreign(_) => ReducedTy::TypeErasure,\n+            ty::Ref(_, ty, _) => ReducedTy::Ref(ty),\n+            ty::RawPtr(ty) => ReducedTy::Ref(ty.ty),\n             _ => ReducedTy::Other(ty),\n         };\n     }"}, {"sha": "7c06906293b167f373356698b2d9af026c33e581", "filename": "clippy_lints/src/types/borrowed_box.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fd495a0654611a6d784bae4698e5838b121e8004/clippy_lints%2Fsrc%2Ftypes%2Fborrowed_box.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd495a0654611a6d784bae4698e5838b121e8004/clippy_lints%2Fsrc%2Ftypes%2Fborrowed_box.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Ftypes%2Fborrowed_box.rs?ref=fd495a0654611a6d784bae4698e5838b121e8004", "patch": "@@ -1,11 +1,11 @@\n use clippy_utils::diagnostics::span_lint_and_sugg;\n use clippy_utils::source::snippet;\n-use clippy_utils::{match_def_path, paths};\n use if_chain::if_chain;\n use rustc_errors::Applicability;\n use rustc_hir::{self as hir, GenericArg, GenericBounds, GenericParamKind};\n use rustc_hir::{HirId, Lifetime, MutTy, Mutability, Node, QPath, TyKind};\n use rustc_lint::LateContext;\n+use rustc_span::sym;\n \n use super::BORROWED_BOX;\n \n@@ -89,7 +89,7 @@ fn is_any_trait(cx: &LateContext<'_>, t: &hir::Ty<'_>) -> bool {\n         if let Some(trait_did) = traits[0].trait_ref.trait_def_id();\n         // Only Send/Sync can be used as additional traits, so it is enough to\n         // check only the first trait.\n-        if match_def_path(cx, trait_did, &paths::ANY_TRAIT);\n+        if cx.tcx.is_diagnostic_item(sym::Any, trait_did);\n         then {\n             return true;\n         }"}, {"sha": "4433d5f5bf1463046f27e0feafc039fcc10dd8ea", "filename": "clippy_lints/src/utils/internal_lints.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fd495a0654611a6d784bae4698e5838b121e8004/clippy_lints%2Fsrc%2Futils%2Finternal_lints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd495a0654611a6d784bae4698e5838b121e8004/clippy_lints%2Fsrc%2Futils%2Finternal_lints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Finternal_lints.rs?ref=fd495a0654611a6d784bae4698e5838b121e8004", "patch": "@@ -1305,7 +1305,7 @@ fn if_chain_local_span(cx: &LateContext<'_>, local: &Local<'_>, if_chain_span: S\n     }\n     span.adjust(if_chain_span.ctxt().outer_expn());\n     let sm = cx.sess().source_map();\n-    let span = sm.span_extend_to_prev_str(span, \"let\", false);\n+    let span = sm.span_extend_to_prev_str(span, \"let\", false, true).unwrap_or(span);\n     let span = sm.span_extend_to_next_char(span, ';', false);\n     Span::new(\n         span.lo() - BytePos(3),"}, {"sha": "80d7b8a1b6df559820863c39c0199f9abb88615c", "filename": "clippy_lints/src/wildcard_dependencies.rs", "status": "removed", "additions": 0, "deletions": 57, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/e390e6c46914b54ea2ffa901f3c6b046b9a7b7d4/clippy_lints%2Fsrc%2Fwildcard_dependencies.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e390e6c46914b54ea2ffa901f3c6b046b9a7b7d4/clippy_lints%2Fsrc%2Fwildcard_dependencies.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fwildcard_dependencies.rs?ref=e390e6c46914b54ea2ffa901f3c6b046b9a7b7d4", "patch": "@@ -1,57 +0,0 @@\n-use clippy_utils::{diagnostics::span_lint, is_lint_allowed};\n-use rustc_hir::hir_id::CRATE_HIR_ID;\n-use rustc_lint::{LateContext, LateLintPass};\n-use rustc_session::{declare_lint_pass, declare_tool_lint};\n-use rustc_span::source_map::DUMMY_SP;\n-\n-use if_chain::if_chain;\n-\n-declare_clippy_lint! {\n-    /// ### What it does\n-    /// Checks for wildcard dependencies in the `Cargo.toml`.\n-    ///\n-    /// ### Why is this bad?\n-    /// [As the edition guide says](https://rust-lang-nursery.github.io/edition-guide/rust-2018/cargo-and-crates-io/crates-io-disallows-wildcard-dependencies.html),\n-    /// it is highly unlikely that you work with any possible version of your dependency,\n-    /// and wildcard dependencies would cause unnecessary breakage in the ecosystem.\n-    ///\n-    /// ### Example\n-    /// ```toml\n-    /// [dependencies]\n-    /// regex = \"*\"\n-    /// ```\n-    #[clippy::version = \"1.32.0\"]\n-    pub WILDCARD_DEPENDENCIES,\n-    cargo,\n-    \"wildcard dependencies being used\"\n-}\n-\n-declare_lint_pass!(WildcardDependencies => [WILDCARD_DEPENDENCIES]);\n-\n-impl LateLintPass<'_> for WildcardDependencies {\n-    fn check_crate(&mut self, cx: &LateContext<'_>) {\n-        if is_lint_allowed(cx, WILDCARD_DEPENDENCIES, CRATE_HIR_ID) {\n-            return;\n-        }\n-\n-        let metadata = unwrap_cargo_metadata!(cx, WILDCARD_DEPENDENCIES, false);\n-\n-        for dep in &metadata.packages[0].dependencies {\n-            // VersionReq::any() does not work\n-            if_chain! {\n-                if let Ok(wildcard_ver) = semver::VersionReq::parse(\"*\");\n-                if let Some(ref source) = dep.source;\n-                if !source.starts_with(\"git\");\n-                if dep.req == wildcard_ver;\n-                then {\n-                    span_lint(\n-                        cx,\n-                        WILDCARD_DEPENDENCIES,\n-                        DUMMY_SP,\n-                        &format!(\"wildcard dependency for `{}`\", dep.name),\n-                    );\n-                }\n-            }\n-        }\n-    }\n-}"}, {"sha": "397783e309e85b135e5c1d4c25b25e86e1b34219", "filename": "clippy_utils/src/lib.rs", "status": "modified", "additions": 1, "deletions": 18, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/fd495a0654611a6d784bae4698e5838b121e8004/clippy_utils%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd495a0654611a6d784bae4698e5838b121e8004/clippy_utils%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_utils%2Fsrc%2Flib.rs?ref=fd495a0654611a6d784bae4698e5838b121e8004", "patch": "@@ -1,6 +1,7 @@\n #![feature(box_patterns)]\n #![feature(control_flow_enum)]\n #![feature(let_else)]\n+#![feature(let_chains)]\n #![feature(once_cell)]\n #![feature(rustc_private)]\n #![recursion_limit = \"512\"]\n@@ -2042,24 +2043,6 @@ pub fn peel_ref_operators<'hir>(cx: &LateContext<'_>, mut expr: &'hir Expr<'hir>\n     expr\n }\n \n-#[macro_export]\n-macro_rules! unwrap_cargo_metadata {\n-    ($cx: ident, $lint: ident, $deps: expr) => {{\n-        let mut command = cargo_metadata::MetadataCommand::new();\n-        if !$deps {\n-            command.no_deps();\n-        }\n-\n-        match command.exec() {\n-            Ok(metadata) => metadata,\n-            Err(err) => {\n-                span_lint($cx, $lint, DUMMY_SP, &format!(\"could not read cargo metadata: {}\", err));\n-                return;\n-            },\n-        }\n-    }};\n-}\n-\n pub fn is_hir_ty_cfg_dependant(cx: &LateContext<'_>, ty: &hir::Ty<'_>) -> bool {\n     if let TyKind::Path(QPath::Resolved(_, path)) = ty.kind {\n         if let Res::Def(_, def_id) = path.res {"}, {"sha": "256f884ae1994787a773e91c69d283087032875d", "filename": "clippy_utils/src/macros.rs", "status": "modified", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/fd495a0654611a6d784bae4698e5838b121e8004/clippy_utils%2Fsrc%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd495a0654611a6d784bae4698e5838b121e8004/clippy_utils%2Fsrc%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_utils%2Fsrc%2Fmacros.rs?ref=fd495a0654611a6d784bae4698e5838b121e8004", "patch": "@@ -1,6 +1,7 @@\n #![allow(clippy::similar_names)] // `expr` and `expn`\n \n use crate::visitors::expr_visitor_no_bodies;\n+use crate::{match_def_path, paths};\n \n use arrayvec::ArrayVec;\n use if_chain::if_chain;\n@@ -13,6 +14,31 @@ use rustc_span::hygiene::{self, MacroKind, SyntaxContext};\n use rustc_span::{sym, ExpnData, ExpnId, ExpnKind, Span, Symbol};\n use std::ops::ControlFlow;\n \n+const FORMAT_MACRO_PATHS: &[&[&str]] = &[\n+    &paths::FORMAT_ARGS_MACRO,\n+    &paths::ASSERT_EQ_MACRO,\n+    &paths::ASSERT_MACRO,\n+    &paths::ASSERT_NE_MACRO,\n+    &paths::EPRINT_MACRO,\n+    &paths::EPRINTLN_MACRO,\n+    &paths::PRINT_MACRO,\n+    &paths::PRINTLN_MACRO,\n+    &paths::WRITE_MACRO,\n+    &paths::WRITELN_MACRO,\n+];\n+\n+const FORMAT_MACRO_DIAG_ITEMS: &[Symbol] = &[sym::format_macro, sym::std_panic_macro];\n+\n+/// Returns true if a given Macro `DefId` is a format macro (e.g. `println!`)\n+pub fn is_format_macro(cx: &LateContext<'_>, macro_def_id: DefId) -> bool {\n+    FORMAT_MACRO_PATHS\n+        .iter()\n+        .any(|path| match_def_path(cx, macro_def_id, path))\n+        || FORMAT_MACRO_DIAG_ITEMS\n+            .iter()\n+            .any(|diag_item| cx.tcx.is_diagnostic_item(*diag_item, macro_def_id))\n+}\n+\n /// A macro call, like `vec![1, 2, 3]`.\n ///\n /// Use `tcx.item_name(macro_call.def_id)` to get the macro name."}, {"sha": "b54bd3a4fef0b0186b34433a4e910484d6def13b", "filename": "clippy_utils/src/paths.rs", "status": "modified", "additions": 4, "deletions": 10, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/fd495a0654611a6d784bae4698e5838b121e8004/clippy_utils%2Fsrc%2Fpaths.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd495a0654611a6d784bae4698e5838b121e8004/clippy_utils%2Fsrc%2Fpaths.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_utils%2Fsrc%2Fpaths.rs?ref=fd495a0654611a6d784bae4698e5838b121e8004", "patch": "@@ -4,7 +4,6 @@\n //! Whenever possible, please consider diagnostic items over hardcoded paths.\n //! See <https://github.com/rust-lang/rust-clippy/issues/5393> for more information.\n \n-pub const ANY_TRAIT: [&str; 3] = [\"core\", \"any\", \"Any\"];\n #[cfg(feature = \"internal\")]\n pub const APPLICABILITY: [&str; 2] = [\"rustc_lint_defs\", \"Applicability\"];\n #[cfg(feature = \"internal\")]\n@@ -32,19 +31,16 @@ pub const BTREEMAP_CONTAINS_KEY: [&str; 6] = [\"alloc\", \"collections\", \"btree\", \"\n pub const BTREEMAP_ENTRY: [&str; 6] = [\"alloc\", \"collections\", \"btree\", \"map\", \"entry\", \"Entry\"];\n pub const BTREEMAP_INSERT: [&str; 6] = [\"alloc\", \"collections\", \"btree\", \"map\", \"BTreeMap\", \"insert\"];\n pub const CLONE_TRAIT_METHOD: [&str; 4] = [\"core\", \"clone\", \"Clone\", \"clone\"];\n-pub const CMP_MAX: [&str; 3] = [\"core\", \"cmp\", \"max\"];\n-pub const CMP_MIN: [&str; 3] = [\"core\", \"cmp\", \"min\"];\n pub const COW: [&str; 3] = [\"alloc\", \"borrow\", \"Cow\"];\n pub const CSTRING_AS_C_STR: [&str; 5] = [\"std\", \"ffi\", \"c_str\", \"CString\", \"as_c_str\"];\n+pub const DEBUG_TRAIT: [&str; 3] = [\"core\", \"fmt\", \"Debug\"];\n pub const DEFAULT_TRAIT_METHOD: [&str; 4] = [\"core\", \"default\", \"Default\", \"default\"];\n pub const DEREF_MUT_TRAIT_METHOD: [&str; 5] = [\"core\", \"ops\", \"deref\", \"DerefMut\", \"deref_mut\"];\n /// Preferably use the diagnostic item `sym::deref_method` where possible\n pub const DEREF_TRAIT_METHOD: [&str; 5] = [\"core\", \"ops\", \"deref\", \"Deref\", \"deref\"];\n pub const DIR_BUILDER: [&str; 3] = [\"std\", \"fs\", \"DirBuilder\"];\n pub const DISPLAY_TRAIT: [&str; 3] = [\"core\", \"fmt\", \"Display\"];\n-pub const DOUBLE_ENDED_ITERATOR: [&str; 4] = [\"core\", \"iter\", \"traits\", \"DoubleEndedIterator\"];\n pub const DROP: [&str; 3] = [\"core\", \"mem\", \"drop\"];\n-pub const DURATION: [&str; 3] = [\"core\", \"time\", \"Duration\"];\n #[cfg(feature = \"internal\")]\n pub const EARLY_CONTEXT: [&str; 2] = [\"rustc_lint\", \"EarlyContext\"];\n #[allow(clippy::invalid_paths)] // `check_path` does not seem to work for macros\n@@ -59,15 +55,13 @@ pub const FILE_TYPE: [&str; 3] = [\"std\", \"fs\", \"FileType\"];\n #[allow(clippy::invalid_paths)] // `check_path` does not seem to work for macros\n pub const FORMAT_ARGS_MACRO: [&str; 4] = [\"core\", \"macros\", \"builtin\", \"format_args\"];\n pub const FROM_FROM: [&str; 4] = [\"core\", \"convert\", \"From\", \"from\"];\n-pub const FROM_ITERATOR: [&str; 5] = [\"core\", \"iter\", \"traits\", \"collect\", \"FromIterator\"];\n pub const FROM_ITERATOR_METHOD: [&str; 6] = [\"core\", \"iter\", \"traits\", \"collect\", \"FromIterator\", \"from_iter\"];\n pub const FROM_STR_METHOD: [&str; 5] = [\"core\", \"str\", \"traits\", \"FromStr\", \"from_str\"];\n pub const FUTURE_FROM_GENERATOR: [&str; 3] = [\"core\", \"future\", \"from_generator\"];\n #[allow(clippy::invalid_paths)] // internal lints do not know about all external crates\n pub const FUTURES_IO_ASYNCREADEXT: [&str; 3] = [\"futures_util\", \"io\", \"AsyncReadExt\"];\n #[allow(clippy::invalid_paths)] // internal lints do not know about all external crates\n pub const FUTURES_IO_ASYNCWRITEEXT: [&str; 3] = [\"futures_util\", \"io\", \"AsyncWriteExt\"];\n-pub const HASH: [&str; 3] = [\"core\", \"hash\", \"Hash\"];\n pub const HASHMAP_CONTAINS_KEY: [&str; 6] = [\"std\", \"collections\", \"hash\", \"map\", \"HashMap\", \"contains_key\"];\n pub const HASHMAP_ENTRY: [&str; 5] = [\"std\", \"collections\", \"hash\", \"map\", \"Entry\"];\n pub const HASHMAP_INSERT: [&str; 6] = [\"std\", \"collections\", \"hash\", \"map\", \"HashMap\", \"insert\"];\n@@ -111,9 +105,9 @@ pub const OS_STRING_AS_OS_STR: [&str; 5] = [\"std\", \"ffi\", \"os_str\", \"OsString\",\n pub const OS_STR_TO_OS_STRING: [&str; 5] = [\"std\", \"ffi\", \"os_str\", \"OsStr\", \"to_os_string\"];\n pub const PARKING_LOT_RAWMUTEX: [&str; 3] = [\"parking_lot\", \"raw_mutex\", \"RawMutex\"];\n pub const PARKING_LOT_RAWRWLOCK: [&str; 3] = [\"parking_lot\", \"raw_rwlock\", \"RawRwLock\"];\n-pub const PARKING_LOT_MUTEX_GUARD: [&str; 2] = [\"parking_lot\", \"MutexGuard\"];\n-pub const PARKING_LOT_RWLOCK_READ_GUARD: [&str; 2] = [\"parking_lot\", \"RwLockReadGuard\"];\n-pub const PARKING_LOT_RWLOCK_WRITE_GUARD: [&str; 2] = [\"parking_lot\", \"RwLockWriteGuard\"];\n+pub const PARKING_LOT_MUTEX_GUARD: [&str; 3] = [\"lock_api\", \"mutex\", \"MutexGuard\"];\n+pub const PARKING_LOT_RWLOCK_READ_GUARD: [&str; 3] = [\"lock_api\", \"rwlock\", \"RwLockReadGuard\"];\n+pub const PARKING_LOT_RWLOCK_WRITE_GUARD: [&str; 3] = [\"lock_api\", \"rwlock\", \"RwLockWriteGuard\"];\n pub const PATH_BUF_AS_PATH: [&str; 4] = [\"std\", \"path\", \"PathBuf\", \"as_path\"];\n pub const PATH_TO_PATH_BUF: [&str; 4] = [\"std\", \"path\", \"Path\", \"to_path_buf\"];\n pub const PERMISSIONS: [&str; 3] = [\"std\", \"fs\", \"Permissions\"];"}, {"sha": "0646d1524a767310ee26d879649a16a441d8ee5e", "filename": "clippy_utils/src/ty.rs", "status": "modified", "additions": 72, "deletions": 1, "changes": 73, "blob_url": "https://github.com/rust-lang/rust/blob/fd495a0654611a6d784bae4698e5838b121e8004/clippy_utils%2Fsrc%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd495a0654611a6d784bae4698e5838b121e8004/clippy_utils%2Fsrc%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_utils%2Fsrc%2Fty.rs?ref=fd495a0654611a6d784bae4698e5838b121e8004", "patch": "@@ -10,12 +10,14 @@ use rustc_hir::def_id::DefId;\n use rustc_hir::{Expr, TyKind, Unsafety};\n use rustc_infer::infer::TyCtxtInferExt;\n use rustc_lint::LateContext;\n+use rustc_middle::mir::interpret::{ConstValue, Scalar};\n use rustc_middle::ty::subst::{GenericArg, GenericArgKind, Subst};\n use rustc_middle::ty::{\n-    self, AdtDef, Binder, FnSig, IntTy, Predicate, PredicateKind, Ty, TyCtxt, TypeFoldable, UintTy,\n+    self, AdtDef, Binder, FnSig, IntTy, Predicate, PredicateKind, Ty, TyCtxt, TypeFoldable, UintTy, VariantDiscr,\n };\n use rustc_span::symbol::Ident;\n use rustc_span::{sym, Span, Symbol, DUMMY_SP};\n+use rustc_target::abi::{Size, VariantIdx};\n use rustc_trait_selection::infer::InferCtxtExt;\n use rustc_trait_selection::traits::query::normalize::AtExt;\n use std::iter;\n@@ -515,3 +517,72 @@ pub fn expr_sig<'tcx>(cx: &LateContext<'tcx>, expr: &Expr<'_>) -> Option<ExprFnS\n         }\n     }\n }\n+\n+#[derive(Clone, Copy)]\n+pub enum EnumValue {\n+    Unsigned(u128),\n+    Signed(i128),\n+}\n+impl core::ops::Add<u32> for EnumValue {\n+    type Output = Self;\n+    fn add(self, n: u32) -> Self::Output {\n+        match self {\n+            Self::Unsigned(x) => Self::Unsigned(x + u128::from(n)),\n+            Self::Signed(x) => Self::Signed(x + i128::from(n)),\n+        }\n+    }\n+}\n+\n+/// Attempts to read the given constant as though it were an an enum value.\n+#[allow(clippy::cast_possible_truncation, clippy::cast_possible_wrap)]\n+pub fn read_explicit_enum_value(tcx: TyCtxt<'_>, id: DefId) -> Option<EnumValue> {\n+    if let Ok(ConstValue::Scalar(Scalar::Int(value))) = tcx.const_eval_poly(id) {\n+        match tcx.type_of(id).kind() {\n+            ty::Int(_) => Some(EnumValue::Signed(match value.size().bytes() {\n+                1 => i128::from(value.assert_bits(Size::from_bytes(1)) as u8 as i8),\n+                2 => i128::from(value.assert_bits(Size::from_bytes(2)) as u16 as i16),\n+                4 => i128::from(value.assert_bits(Size::from_bytes(4)) as u32 as i32),\n+                8 => i128::from(value.assert_bits(Size::from_bytes(8)) as u64 as i64),\n+                16 => value.assert_bits(Size::from_bytes(16)) as i128,\n+                _ => return None,\n+            })),\n+            ty::Uint(_) => Some(EnumValue::Unsigned(match value.size().bytes() {\n+                1 => value.assert_bits(Size::from_bytes(1)),\n+                2 => value.assert_bits(Size::from_bytes(2)),\n+                4 => value.assert_bits(Size::from_bytes(4)),\n+                8 => value.assert_bits(Size::from_bytes(8)),\n+                16 => value.assert_bits(Size::from_bytes(16)),\n+                _ => return None,\n+            })),\n+            _ => None,\n+        }\n+    } else {\n+        None\n+    }\n+}\n+\n+/// Gets the value of the given variant.\n+pub fn get_discriminant_value(tcx: TyCtxt<'_>, adt: &'_ AdtDef, i: VariantIdx) -> EnumValue {\n+    let variant = &adt.variants[i];\n+    match variant.discr {\n+        VariantDiscr::Explicit(id) => read_explicit_enum_value(tcx, id).unwrap(),\n+        VariantDiscr::Relative(x) => match adt.variants[(i.as_usize() - x as usize).into()].discr {\n+            VariantDiscr::Explicit(id) => read_explicit_enum_value(tcx, id).unwrap() + x,\n+            VariantDiscr::Relative(_) => EnumValue::Unsigned(x.into()),\n+        },\n+    }\n+}\n+\n+/// Check if the given type is either `core::ffi::c_void`, `std::os::raw::c_void`, or one of the\n+/// platform specific `libc::<platform>::c_void` types in libc.\n+pub fn is_c_void(cx: &LateContext<'_>, ty: Ty<'_>) -> bool {\n+    if let ty::Adt(adt, _) = ty.kind()\n+        && let &[krate, .., name] = &*cx.get_def_path(adt.did)\n+        && let sym::libc | sym::core | sym::std = krate\n+        && name.as_str() == \"c_void\"\n+    {\n+        true\n+    } else {\n+        false\n+    }\n+}"}, {"sha": "6bc74bc1e9aada60c2755bc51415ee8edb986854", "filename": "tests/compile-test.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/fd495a0654611a6d784bae4698e5838b121e8004/tests%2Fcompile-test.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd495a0654611a6d784bae4698e5838b121e8004/tests%2Fcompile-test.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-test.rs?ref=fd495a0654611a6d784bae4698e5838b121e8004", "patch": "@@ -162,6 +162,11 @@ fn run_ui() {\n     let config = base_config(\"ui\");\n     // use tests/clippy.toml\n     let _g = VarGuard::set(\"CARGO_MANIFEST_DIR\", fs::canonicalize(\"tests\").unwrap());\n+    let _threads = VarGuard::set(\n+        \"RUST_TEST_THREADS\",\n+        // if RUST_TEST_THREADS is set, adhere to it, otherwise override it\n+        env::var(\"RUST_TEST_THREADS\").unwrap_or_else(|_| num_cpus::get().to_string()),\n+    );\n     compiletest::run_tests(&config);\n }\n "}, {"sha": "9f283337c7e132d8d6d23de3c28ac50614d243ef", "filename": "tests/ui/auxiliary/macro_rules.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/fd495a0654611a6d784bae4698e5838b121e8004/tests%2Fui%2Fauxiliary%2Fmacro_rules.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd495a0654611a6d784bae4698e5838b121e8004/tests%2Fui%2Fauxiliary%2Fmacro_rules.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fauxiliary%2Fmacro_rules.rs?ref=fd495a0654611a6d784bae4698e5838b121e8004", "patch": "@@ -120,3 +120,10 @@ macro_rules! mut_mut {\n         let mut_mut_ty: &mut &mut u32 = &mut &mut 1u32;\n     };\n }\n+\n+#[macro_export]\n+macro_rules! ptr_as_ptr_cast {\n+    ($ptr: ident) => {\n+        $ptr as *const i32\n+    };\n+}"}, {"sha": "57e5b55045b95de03495fa9a9ca22db68a6657b1", "filename": "tests/ui/await_holding_lock.rs", "status": "modified", "additions": 167, "deletions": 39, "changes": 206, "blob_url": "https://github.com/rust-lang/rust/blob/fd495a0654611a6d784bae4698e5838b121e8004/tests%2Fui%2Fawait_holding_lock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd495a0654611a6d784bae4698e5838b121e8004/tests%2Fui%2Fawait_holding_lock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fawait_holding_lock.rs?ref=fd495a0654611a6d784bae4698e5838b121e8004", "patch": "@@ -1,64 +1,192 @@\n #![warn(clippy::await_holding_lock)]\n \n-use std::sync::Mutex;\n+// When adding or modifying a test, please do the same for parking_lot::Mutex.\n+mod std_mutex {\n+    use super::baz;\n+    use std::sync::{Mutex, RwLock};\n \n-async fn bad(x: &Mutex<u32>) -> u32 {\n-    let guard = x.lock().unwrap();\n-    baz().await\n-}\n+    pub async fn bad(x: &Mutex<u32>) -> u32 {\n+        let guard = x.lock().unwrap();\n+        baz().await\n+    }\n \n-async fn good(x: &Mutex<u32>) -> u32 {\n-    {\n+    pub async fn good(x: &Mutex<u32>) -> u32 {\n+        {\n+            let guard = x.lock().unwrap();\n+            let y = *guard + 1;\n+        }\n+        baz().await;\n         let guard = x.lock().unwrap();\n-        let y = *guard + 1;\n+        47\n     }\n-    baz().await;\n-    let guard = x.lock().unwrap();\n-    47\n-}\n \n-async fn baz() -> u32 {\n-    42\n-}\n+    pub async fn bad_rw(x: &RwLock<u32>) -> u32 {\n+        let guard = x.read().unwrap();\n+        baz().await\n+    }\n \n-async fn also_bad(x: &Mutex<u32>) -> u32 {\n-    let first = baz().await;\n+    pub async fn bad_rw_write(x: &RwLock<u32>) -> u32 {\n+        let mut guard = x.write().unwrap();\n+        baz().await\n+    }\n \n-    let guard = x.lock().unwrap();\n+    pub async fn good_rw(x: &RwLock<u32>) -> u32 {\n+        {\n+            let guard = x.read().unwrap();\n+            let y = *guard + 1;\n+        }\n+        {\n+            let mut guard = x.write().unwrap();\n+            *guard += 1;\n+        }\n+        baz().await;\n+        let guard = x.read().unwrap();\n+        47\n+    }\n \n-    let second = baz().await;\n+    pub async fn also_bad(x: &Mutex<u32>) -> u32 {\n+        let first = baz().await;\n \n-    let third = baz().await;\n+        let guard = x.lock().unwrap();\n \n-    first + second + third\n+        let second = baz().await;\n+\n+        let third = baz().await;\n+\n+        first + second + third\n+    }\n+\n+    pub async fn not_good(x: &Mutex<u32>) -> u32 {\n+        let first = baz().await;\n+\n+        let second = {\n+            let guard = x.lock().unwrap();\n+            baz().await\n+        };\n+\n+        let third = baz().await;\n+\n+        first + second + third\n+    }\n+\n+    #[allow(clippy::manual_async_fn)]\n+    pub fn block_bad(x: &Mutex<u32>) -> impl std::future::Future<Output = u32> + '_ {\n+        async move {\n+            let guard = x.lock().unwrap();\n+            baz().await\n+        }\n+    }\n }\n \n-async fn not_good(x: &Mutex<u32>) -> u32 {\n-    let first = baz().await;\n+// When adding or modifying a test, please do the same for std::Mutex.\n+mod parking_lot_mutex {\n+    use super::baz;\n+    use parking_lot::{Mutex, RwLock};\n \n-    let second = {\n-        let guard = x.lock().unwrap();\n+    pub async fn bad(x: &Mutex<u32>) -> u32 {\n+        let guard = x.lock();\n         baz().await\n-    };\n+    }\n \n-    let third = baz().await;\n+    pub async fn good(x: &Mutex<u32>) -> u32 {\n+        {\n+            let guard = x.lock();\n+            let y = *guard + 1;\n+        }\n+        baz().await;\n+        let guard = x.lock();\n+        47\n+    }\n \n-    first + second + third\n-}\n+    pub async fn bad_rw(x: &RwLock<u32>) -> u32 {\n+        let guard = x.read();\n+        baz().await\n+    }\n \n-#[allow(clippy::manual_async_fn)]\n-fn block_bad(x: &Mutex<u32>) -> impl std::future::Future<Output = u32> + '_ {\n-    async move {\n-        let guard = x.lock().unwrap();\n+    pub async fn bad_rw_write(x: &RwLock<u32>) -> u32 {\n+        let mut guard = x.write();\n         baz().await\n     }\n+\n+    pub async fn good_rw(x: &RwLock<u32>) -> u32 {\n+        {\n+            let guard = x.read();\n+            let y = *guard + 1;\n+        }\n+        {\n+            let mut guard = x.write();\n+            *guard += 1;\n+        }\n+        baz().await;\n+        let guard = x.read();\n+        47\n+    }\n+\n+    pub async fn also_bad(x: &Mutex<u32>) -> u32 {\n+        let first = baz().await;\n+\n+        let guard = x.lock();\n+\n+        let second = baz().await;\n+\n+        let third = baz().await;\n+\n+        first + second + third\n+    }\n+\n+    pub async fn not_good(x: &Mutex<u32>) -> u32 {\n+        let first = baz().await;\n+\n+        let second = {\n+            let guard = x.lock();\n+            baz().await\n+        };\n+\n+        let third = baz().await;\n+\n+        first + second + third\n+    }\n+\n+    #[allow(clippy::manual_async_fn)]\n+    pub fn block_bad(x: &Mutex<u32>) -> impl std::future::Future<Output = u32> + '_ {\n+        async move {\n+            let guard = x.lock();\n+            baz().await\n+        }\n+    }\n+}\n+\n+async fn baz() -> u32 {\n+    42\n+}\n+\n+async fn no_await(x: std::sync::Mutex<u32>) {\n+    let mut guard = x.lock().unwrap();\n+    *guard += 1;\n+}\n+\n+// FIXME: FP, because the `MutexGuard` is dropped before crossing the await point. This is\n+// something the needs to be fixed in rustc. There's already drop-tracking, but this is currently\n+// disabled, see rust-lang/rust#93751. This case isn't picked up by drop-tracking though. If the\n+// `*guard += 1` is removed it is picked up.\n+async fn dropped_before_await(x: std::sync::Mutex<u32>) {\n+    let mut guard = x.lock().unwrap();\n+    *guard += 1;\n+    drop(guard);\n+    baz().await;\n }\n \n fn main() {\n-    let m = Mutex::new(100);\n-    good(&m);\n-    bad(&m);\n-    also_bad(&m);\n-    not_good(&m);\n-    block_bad(&m);\n+    let m = std::sync::Mutex::new(100);\n+    std_mutex::good(&m);\n+    std_mutex::bad(&m);\n+    std_mutex::also_bad(&m);\n+    std_mutex::not_good(&m);\n+    std_mutex::block_bad(&m);\n+\n+    let m = parking_lot::Mutex::new(100);\n+    parking_lot_mutex::good(&m);\n+    parking_lot_mutex::bad(&m);\n+    parking_lot_mutex::also_bad(&m);\n+    parking_lot_mutex::not_good(&m);\n }"}, {"sha": "976da8d924247897317bed03461c579077a855cd", "filename": "tests/ui/await_holding_lock.stderr", "status": "modified", "additions": 180, "deletions": 35, "changes": 215, "blob_url": "https://github.com/rust-lang/rust/blob/fd495a0654611a6d784bae4698e5838b121e8004/tests%2Fui%2Fawait_holding_lock.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/fd495a0654611a6d784bae4698e5838b121e8004/tests%2Fui%2Fawait_holding_lock.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fawait_holding_lock.stderr?ref=fd495a0654611a6d784bae4698e5838b121e8004", "patch": "@@ -1,63 +1,208 @@\n-error: this MutexGuard is held across an 'await' point. Consider using an async-aware Mutex type or ensuring the MutexGuard is dropped before calling await\n-  --> $DIR/await_holding_lock.rs:6:9\n+error: this `MutexGuard` is held across an `await` point\n+  --> $DIR/await_holding_lock.rs:9:13\n    |\n-LL |     let guard = x.lock().unwrap();\n-   |         ^^^^^\n+LL |         let guard = x.lock().unwrap();\n+   |             ^^^^^\n    |\n    = note: `-D clippy::await-holding-lock` implied by `-D warnings`\n-note: these are all the await points this lock is held through\n-  --> $DIR/await_holding_lock.rs:6:5\n+   = help: consider using an async-aware `Mutex` type or ensuring the `MutexGuard` is dropped before calling await\n+note: these are all the `await` points this lock is held through\n+  --> $DIR/await_holding_lock.rs:9:9\n    |\n-LL | /     let guard = x.lock().unwrap();\n-LL | |     baz().await\n-LL | | }\n-   | |_^\n+LL | /         let guard = x.lock().unwrap();\n+LL | |         baz().await\n+LL | |     }\n+   | |_____^\n \n-error: this MutexGuard is held across an 'await' point. Consider using an async-aware Mutex type or ensuring the MutexGuard is dropped before calling await\n-  --> $DIR/await_holding_lock.rs:27:9\n+error: this `MutexGuard` is held across an `await` point\n+  --> $DIR/await_holding_lock.rs:24:13\n    |\n-LL |     let guard = x.lock().unwrap();\n-   |         ^^^^^\n+LL |         let guard = x.read().unwrap();\n+   |             ^^^^^\n    |\n-note: these are all the await points this lock is held through\n-  --> $DIR/await_holding_lock.rs:27:5\n+   = help: consider using an async-aware `Mutex` type or ensuring the `MutexGuard` is dropped before calling await\n+note: these are all the `await` points this lock is held through\n+  --> $DIR/await_holding_lock.rs:24:9\n    |\n-LL | /     let guard = x.lock().unwrap();\n+LL | /         let guard = x.read().unwrap();\n+LL | |         baz().await\n+LL | |     }\n+   | |_____^\n+\n+error: this `MutexGuard` is held across an `await` point\n+  --> $DIR/await_holding_lock.rs:29:13\n+   |\n+LL |         let mut guard = x.write().unwrap();\n+   |             ^^^^^^^^^\n+   |\n+   = help: consider using an async-aware `Mutex` type or ensuring the `MutexGuard` is dropped before calling await\n+note: these are all the `await` points this lock is held through\n+  --> $DIR/await_holding_lock.rs:29:9\n+   |\n+LL | /         let mut guard = x.write().unwrap();\n+LL | |         baz().await\n+LL | |     }\n+   | |_____^\n+\n+error: this `MutexGuard` is held across an `await` point\n+  --> $DIR/await_holding_lock.rs:50:13\n+   |\n+LL |         let guard = x.lock().unwrap();\n+   |             ^^^^^\n+   |\n+   = help: consider using an async-aware `Mutex` type or ensuring the `MutexGuard` is dropped before calling await\n+note: these are all the `await` points this lock is held through\n+  --> $DIR/await_holding_lock.rs:50:9\n+   |\n+LL | /         let guard = x.lock().unwrap();\n LL | |\n-LL | |     let second = baz().await;\n+LL | |         let second = baz().await;\n LL | |\n ...  |\n-LL | |     first + second + third\n-LL | | }\n-   | |_^\n+LL | |         first + second + third\n+LL | |     }\n+   | |_____^\n \n-error: this MutexGuard is held across an 'await' point. Consider using an async-aware Mutex type or ensuring the MutexGuard is dropped before calling await\n-  --> $DIR/await_holding_lock.rs:40:13\n+error: this `MutexGuard` is held across an `await` point\n+  --> $DIR/await_holding_lock.rs:63:17\n    |\n-LL |         let guard = x.lock().unwrap();\n+LL |             let guard = x.lock().unwrap();\n+   |                 ^^^^^\n+   |\n+   = help: consider using an async-aware `Mutex` type or ensuring the `MutexGuard` is dropped before calling await\n+note: these are all the `await` points this lock is held through\n+  --> $DIR/await_holding_lock.rs:63:13\n+   |\n+LL | /             let guard = x.lock().unwrap();\n+LL | |             baz().await\n+LL | |         };\n+   | |_________^\n+\n+error: this `MutexGuard` is held across an `await` point\n+  --> $DIR/await_holding_lock.rs:75:17\n+   |\n+LL |             let guard = x.lock().unwrap();\n+   |                 ^^^^^\n+   |\n+   = help: consider using an async-aware `Mutex` type or ensuring the `MutexGuard` is dropped before calling await\n+note: these are all the `await` points this lock is held through\n+  --> $DIR/await_holding_lock.rs:75:13\n+   |\n+LL | /             let guard = x.lock().unwrap();\n+LL | |             baz().await\n+LL | |         }\n+   | |_________^\n+\n+error: this `MutexGuard` is held across an `await` point\n+  --> $DIR/await_holding_lock.rs:87:13\n+   |\n+LL |         let guard = x.lock();\n    |             ^^^^^\n    |\n-note: these are all the await points this lock is held through\n-  --> $DIR/await_holding_lock.rs:40:9\n+   = help: consider using an async-aware `Mutex` type or ensuring the `MutexGuard` is dropped before calling await\n+note: these are all the `await` points this lock is held through\n+  --> $DIR/await_holding_lock.rs:87:9\n    |\n-LL | /         let guard = x.lock().unwrap();\n+LL | /         let guard = x.lock();\n LL | |         baz().await\n-LL | |     };\n+LL | |     }\n    | |_____^\n \n-error: this MutexGuard is held across an 'await' point. Consider using an async-aware Mutex type or ensuring the MutexGuard is dropped before calling await\n-  --> $DIR/await_holding_lock.rs:52:13\n+error: this `MutexGuard` is held across an `await` point\n+  --> $DIR/await_holding_lock.rs:102:13\n    |\n-LL |         let guard = x.lock().unwrap();\n+LL |         let guard = x.read();\n    |             ^^^^^\n    |\n-note: these are all the await points this lock is held through\n-  --> $DIR/await_holding_lock.rs:52:9\n+   = help: consider using an async-aware `Mutex` type or ensuring the `MutexGuard` is dropped before calling await\n+note: these are all the `await` points this lock is held through\n+  --> $DIR/await_holding_lock.rs:102:9\n    |\n-LL | /         let guard = x.lock().unwrap();\n+LL | /         let guard = x.read();\n LL | |         baz().await\n LL | |     }\n    | |_____^\n \n-error: aborting due to 4 previous errors\n+error: this `MutexGuard` is held across an `await` point\n+  --> $DIR/await_holding_lock.rs:107:13\n+   |\n+LL |         let mut guard = x.write();\n+   |             ^^^^^^^^^\n+   |\n+   = help: consider using an async-aware `Mutex` type or ensuring the `MutexGuard` is dropped before calling await\n+note: these are all the `await` points this lock is held through\n+  --> $DIR/await_holding_lock.rs:107:9\n+   |\n+LL | /         let mut guard = x.write();\n+LL | |         baz().await\n+LL | |     }\n+   | |_____^\n+\n+error: this `MutexGuard` is held across an `await` point\n+  --> $DIR/await_holding_lock.rs:128:13\n+   |\n+LL |         let guard = x.lock();\n+   |             ^^^^^\n+   |\n+   = help: consider using an async-aware `Mutex` type or ensuring the `MutexGuard` is dropped before calling await\n+note: these are all the `await` points this lock is held through\n+  --> $DIR/await_holding_lock.rs:128:9\n+   |\n+LL | /         let guard = x.lock();\n+LL | |\n+LL | |         let second = baz().await;\n+LL | |\n+...  |\n+LL | |         first + second + third\n+LL | |     }\n+   | |_____^\n+\n+error: this `MutexGuard` is held across an `await` point\n+  --> $DIR/await_holding_lock.rs:141:17\n+   |\n+LL |             let guard = x.lock();\n+   |                 ^^^^^\n+   |\n+   = help: consider using an async-aware `Mutex` type or ensuring the `MutexGuard` is dropped before calling await\n+note: these are all the `await` points this lock is held through\n+  --> $DIR/await_holding_lock.rs:141:13\n+   |\n+LL | /             let guard = x.lock();\n+LL | |             baz().await\n+LL | |         };\n+   | |_________^\n+\n+error: this `MutexGuard` is held across an `await` point\n+  --> $DIR/await_holding_lock.rs:153:17\n+   |\n+LL |             let guard = x.lock();\n+   |                 ^^^^^\n+   |\n+   = help: consider using an async-aware `Mutex` type or ensuring the `MutexGuard` is dropped before calling await\n+note: these are all the `await` points this lock is held through\n+  --> $DIR/await_holding_lock.rs:153:13\n+   |\n+LL | /             let guard = x.lock();\n+LL | |             baz().await\n+LL | |         }\n+   | |_________^\n+\n+error: this `MutexGuard` is held across an `await` point\n+  --> $DIR/await_holding_lock.rs:173:9\n+   |\n+LL |     let mut guard = x.lock().unwrap();\n+   |         ^^^^^^^^^\n+   |\n+   = help: consider using an async-aware `Mutex` type or ensuring the `MutexGuard` is dropped before calling await\n+note: these are all the `await` points this lock is held through\n+  --> $DIR/await_holding_lock.rs:173:5\n+   |\n+LL | /     let mut guard = x.lock().unwrap();\n+LL | |     *guard += 1;\n+LL | |     drop(guard);\n+LL | |     baz().await;\n+LL | | }\n+   | |_^\n+\n+error: aborting due to 13 previous errors\n "}, {"sha": "4339fca735dd4554eabcc0d7a9ad6a0963fc2d31", "filename": "tests/ui/await_holding_refcell_ref.stderr", "status": "modified", "additions": 18, "deletions": 12, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/fd495a0654611a6d784bae4698e5838b121e8004/tests%2Fui%2Fawait_holding_refcell_ref.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/fd495a0654611a6d784bae4698e5838b121e8004/tests%2Fui%2Fawait_holding_refcell_ref.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fawait_holding_refcell_ref.stderr?ref=fd495a0654611a6d784bae4698e5838b121e8004", "patch": "@@ -1,39 +1,42 @@\n-error: this RefCell Ref is held across an 'await' point. Consider ensuring the Ref is dropped before calling await\n+error: this `RefCell` reference is held across an `await` point\n   --> $DIR/await_holding_refcell_ref.rs:6:9\n    |\n LL |     let b = x.borrow();\n    |         ^\n    |\n    = note: `-D clippy::await-holding-refcell-ref` implied by `-D warnings`\n-note: these are all the await points this ref is held through\n+   = help: ensure the reference is dropped before calling `await`\n+note: these are all the `await` points this reference is held through\n   --> $DIR/await_holding_refcell_ref.rs:6:5\n    |\n LL | /     let b = x.borrow();\n LL | |     baz().await\n LL | | }\n    | |_^\n \n-error: this RefCell Ref is held across an 'await' point. Consider ensuring the Ref is dropped before calling await\n+error: this `RefCell` reference is held across an `await` point\n   --> $DIR/await_holding_refcell_ref.rs:11:9\n    |\n LL |     let b = x.borrow_mut();\n    |         ^\n    |\n-note: these are all the await points this ref is held through\n+   = help: ensure the reference is dropped before calling `await`\n+note: these are all the `await` points this reference is held through\n   --> $DIR/await_holding_refcell_ref.rs:11:5\n    |\n LL | /     let b = x.borrow_mut();\n LL | |     baz().await\n LL | | }\n    | |_^\n \n-error: this RefCell Ref is held across an 'await' point. Consider ensuring the Ref is dropped before calling await\n+error: this `RefCell` reference is held across an `await` point\n   --> $DIR/await_holding_refcell_ref.rs:32:9\n    |\n LL |     let b = x.borrow_mut();\n    |         ^\n    |\n-note: these are all the await points this ref is held through\n+   = help: ensure the reference is dropped before calling `await`\n+note: these are all the `await` points this reference is held through\n   --> $DIR/await_holding_refcell_ref.rs:32:5\n    |\n LL | /     let b = x.borrow_mut();\n@@ -45,13 +48,14 @@ LL | |     first + second + third\n LL | | }\n    | |_^\n \n-error: this RefCell Ref is held across an 'await' point. Consider ensuring the Ref is dropped before calling await\n+error: this `RefCell` reference is held across an `await` point\n   --> $DIR/await_holding_refcell_ref.rs:44:9\n    |\n LL |     let b = x.borrow_mut();\n    |         ^\n    |\n-note: these are all the await points this ref is held through\n+   = help: ensure the reference is dropped before calling `await`\n+note: these are all the `await` points this reference is held through\n   --> $DIR/await_holding_refcell_ref.rs:44:5\n    |\n LL | /     let b = x.borrow_mut();\n@@ -63,27 +67,29 @@ LL | |     first + second + third\n LL | | }\n    | |_^\n \n-error: this RefCell Ref is held across an 'await' point. Consider ensuring the Ref is dropped before calling await\n+error: this `RefCell` reference is held across an `await` point\n   --> $DIR/await_holding_refcell_ref.rs:59:13\n    |\n LL |         let b = x.borrow_mut();\n    |             ^\n    |\n-note: these are all the await points this ref is held through\n+   = help: ensure the reference is dropped before calling `await`\n+note: these are all the `await` points this reference is held through\n   --> $DIR/await_holding_refcell_ref.rs:59:9\n    |\n LL | /         let b = x.borrow_mut();\n LL | |         baz().await\n LL | |     };\n    | |_____^\n \n-error: this RefCell Ref is held across an 'await' point. Consider ensuring the Ref is dropped before calling await\n+error: this `RefCell` reference is held across an `await` point\n   --> $DIR/await_holding_refcell_ref.rs:71:13\n    |\n LL |         let b = x.borrow_mut();\n    |             ^\n    |\n-note: these are all the await points this ref is held through\n+   = help: ensure the reference is dropped before calling `await`\n+note: these are all the `await` points this reference is held through\n   --> $DIR/await_holding_refcell_ref.rs:71:9\n    |\n LL | /         let b = x.borrow_mut();"}, {"sha": "2e31ad3172ee8cef1a5271c27c2fd8367b7d417c", "filename": "tests/ui/cast.rs", "status": "modified", "additions": 136, "deletions": 0, "changes": 136, "blob_url": "https://github.com/rust-lang/rust/blob/fd495a0654611a6d784bae4698e5838b121e8004/tests%2Fui%2Fcast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd495a0654611a6d784bae4698e5838b121e8004/tests%2Fui%2Fcast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fcast.rs?ref=fd495a0654611a6d784bae4698e5838b121e8004", "patch": "@@ -1,3 +1,6 @@\n+#![feature(repr128)]\n+#![allow(incomplete_features)]\n+\n #[warn(\n     clippy::cast_precision_loss,\n     clippy::cast_possible_truncation,\n@@ -115,4 +118,137 @@ fn main() {\n     }) as u8;\n     999999u64.clamp(0, 255) as u8;\n     999999u64.clamp(0, 256) as u8; // should still be linted\n+\n+    #[derive(Clone, Copy)]\n+    enum E1 {\n+        A,\n+        B,\n+        C,\n+    }\n+    impl E1 {\n+        fn test(self) {\n+            let _ = self as u8; // Don't lint. `0..=2` fits in u8\n+        }\n+    }\n+\n+    #[derive(Clone, Copy)]\n+    enum E2 {\n+        A = 255,\n+        B,\n+    }\n+    impl E2 {\n+        fn test(self) {\n+            let _ = self as u8;\n+            let _ = Self::B as u8;\n+            let _ = self as i16; // Don't lint. `255..=256` fits in i16\n+            let _ = Self::A as u8; // Don't lint.\n+        }\n+    }\n+\n+    #[derive(Clone, Copy)]\n+    enum E3 {\n+        A = -1,\n+        B,\n+        C = 50,\n+    }\n+    impl E3 {\n+        fn test(self) {\n+            let _ = self as i8; // Don't lint. `-1..=50` fits in i8\n+        }\n+    }\n+\n+    #[derive(Clone, Copy)]\n+    enum E4 {\n+        A = -128,\n+        B,\n+    }\n+    impl E4 {\n+        fn test(self) {\n+            let _ = self as i8; // Don't lint. `-128..=-127` fits in i8\n+        }\n+    }\n+\n+    #[derive(Clone, Copy)]\n+    enum E5 {\n+        A = -129,\n+        B = 127,\n+    }\n+    impl E5 {\n+        fn test(self) {\n+            let _ = self as i8;\n+            let _ = Self::A as i8;\n+            let _ = self as i16; // Don't lint. `-129..=127` fits in i16\n+            let _ = Self::B as u8; // Don't lint.\n+        }\n+    }\n+\n+    #[derive(Clone, Copy)]\n+    #[repr(u32)]\n+    enum E6 {\n+        A = u16::MAX as u32,\n+        B,\n+    }\n+    impl E6 {\n+        fn test(self) {\n+            let _ = self as i16;\n+            let _ = Self::A as u16; // Don't lint. `2^16-1` fits in u16\n+            let _ = self as u32; // Don't lint. `2^16-1..=2^16` fits in u32\n+            let _ = Self::A as u16; // Don't lint.\n+        }\n+    }\n+\n+    #[derive(Clone, Copy)]\n+    #[repr(u64)]\n+    enum E7 {\n+        A = u32::MAX as u64,\n+        B,\n+    }\n+    impl E7 {\n+        fn test(self) {\n+            let _ = self as usize;\n+            let _ = Self::A as usize; // Don't lint.\n+            let _ = self as u64; // Don't lint. `2^32-1..=2^32` fits in u64\n+        }\n+    }\n+\n+    #[derive(Clone, Copy)]\n+    #[repr(i128)]\n+    enum E8 {\n+        A = i128::MIN,\n+        B,\n+        C = 0,\n+        D = i128::MAX,\n+    }\n+    impl E8 {\n+        fn test(self) {\n+            let _ = self as i128; // Don't lint. `-(2^127)..=2^127-1` fits it i128\n+        }\n+    }\n+\n+    #[derive(Clone, Copy)]\n+    #[repr(u128)]\n+    enum E9 {\n+        A,\n+        B = u128::MAX,\n+    }\n+    impl E9 {\n+        fn test(self) {\n+            let _ = Self::A as u8; // Don't lint.\n+            let _ = self as u128; // Don't lint. `0..=2^128-1` fits in u128\n+        }\n+    }\n+\n+    #[derive(Clone, Copy)]\n+    #[repr(usize)]\n+    enum E10 {\n+        A,\n+        B = u32::MAX as usize,\n+    }\n+    impl E10 {\n+        fn test(self) {\n+            let _ = self as u16;\n+            let _ = Self::B as u32; // Don't lint.\n+            let _ = self as u64; // Don't lint.\n+        }\n+    }\n }"}, {"sha": "7a68c0984f140dda78c8c6d5b927b6867b76beac", "filename": "tests/ui/cast.stderr", "status": "modified", "additions": 69, "deletions": 25, "changes": 94, "blob_url": "https://github.com/rust-lang/rust/blob/fd495a0654611a6d784bae4698e5838b121e8004/tests%2Fui%2Fcast.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/fd495a0654611a6d784bae4698e5838b121e8004/tests%2Fui%2Fcast.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fcast.stderr?ref=fd495a0654611a6d784bae4698e5838b121e8004", "patch": "@@ -1,154 +1,198 @@\n error: casting `i32` to `f32` causes a loss of precision (`i32` is 32 bits wide, but `f32`'s mantissa is only 23 bits wide)\n-  --> $DIR/cast.rs:11:5\n+  --> $DIR/cast.rs:14:5\n    |\n LL |     x0 as f32;\n    |     ^^^^^^^^^\n    |\n    = note: `-D clippy::cast-precision-loss` implied by `-D warnings`\n \n error: casting `i64` to `f32` causes a loss of precision (`i64` is 64 bits wide, but `f32`'s mantissa is only 23 bits wide)\n-  --> $DIR/cast.rs:13:5\n+  --> $DIR/cast.rs:16:5\n    |\n LL |     x1 as f32;\n    |     ^^^^^^^^^\n \n error: casting `i64` to `f64` causes a loss of precision (`i64` is 64 bits wide, but `f64`'s mantissa is only 52 bits wide)\n-  --> $DIR/cast.rs:14:5\n+  --> $DIR/cast.rs:17:5\n    |\n LL |     x1 as f64;\n    |     ^^^^^^^^^\n \n error: casting `u32` to `f32` causes a loss of precision (`u32` is 32 bits wide, but `f32`'s mantissa is only 23 bits wide)\n-  --> $DIR/cast.rs:16:5\n+  --> $DIR/cast.rs:19:5\n    |\n LL |     x2 as f32;\n    |     ^^^^^^^^^\n \n error: casting `u64` to `f32` causes a loss of precision (`u64` is 64 bits wide, but `f32`'s mantissa is only 23 bits wide)\n-  --> $DIR/cast.rs:18:5\n+  --> $DIR/cast.rs:21:5\n    |\n LL |     x3 as f32;\n    |     ^^^^^^^^^\n \n error: casting `u64` to `f64` causes a loss of precision (`u64` is 64 bits wide, but `f64`'s mantissa is only 52 bits wide)\n-  --> $DIR/cast.rs:19:5\n+  --> $DIR/cast.rs:22:5\n    |\n LL |     x3 as f64;\n    |     ^^^^^^^^^\n \n error: casting `f32` to `i32` may truncate the value\n-  --> $DIR/cast.rs:21:5\n+  --> $DIR/cast.rs:24:5\n    |\n LL |     1f32 as i32;\n    |     ^^^^^^^^^^^\n    |\n    = note: `-D clippy::cast-possible-truncation` implied by `-D warnings`\n \n error: casting `f32` to `u32` may truncate the value\n-  --> $DIR/cast.rs:22:5\n+  --> $DIR/cast.rs:25:5\n    |\n LL |     1f32 as u32;\n    |     ^^^^^^^^^^^\n \n error: casting `f32` to `u32` may lose the sign of the value\n-  --> $DIR/cast.rs:22:5\n+  --> $DIR/cast.rs:25:5\n    |\n LL |     1f32 as u32;\n    |     ^^^^^^^^^^^\n    |\n    = note: `-D clippy::cast-sign-loss` implied by `-D warnings`\n \n error: casting `f64` to `f32` may truncate the value\n-  --> $DIR/cast.rs:23:5\n+  --> $DIR/cast.rs:26:5\n    |\n LL |     1f64 as f32;\n    |     ^^^^^^^^^^^\n \n error: casting `i32` to `i8` may truncate the value\n-  --> $DIR/cast.rs:24:5\n+  --> $DIR/cast.rs:27:5\n    |\n LL |     1i32 as i8;\n    |     ^^^^^^^^^^\n \n error: casting `i32` to `u8` may truncate the value\n-  --> $DIR/cast.rs:25:5\n+  --> $DIR/cast.rs:28:5\n    |\n LL |     1i32 as u8;\n    |     ^^^^^^^^^^\n \n error: casting `f64` to `isize` may truncate the value\n-  --> $DIR/cast.rs:26:5\n+  --> $DIR/cast.rs:29:5\n    |\n LL |     1f64 as isize;\n    |     ^^^^^^^^^^^^^\n \n error: casting `f64` to `usize` may truncate the value\n-  --> $DIR/cast.rs:27:5\n+  --> $DIR/cast.rs:30:5\n    |\n LL |     1f64 as usize;\n    |     ^^^^^^^^^^^^^\n \n error: casting `f64` to `usize` may lose the sign of the value\n-  --> $DIR/cast.rs:27:5\n+  --> $DIR/cast.rs:30:5\n    |\n LL |     1f64 as usize;\n    |     ^^^^^^^^^^^^^\n \n error: casting `u8` to `i8` may wrap around the value\n-  --> $DIR/cast.rs:29:5\n+  --> $DIR/cast.rs:32:5\n    |\n LL |     1u8 as i8;\n    |     ^^^^^^^^^\n    |\n    = note: `-D clippy::cast-possible-wrap` implied by `-D warnings`\n \n error: casting `u16` to `i16` may wrap around the value\n-  --> $DIR/cast.rs:30:5\n+  --> $DIR/cast.rs:33:5\n    |\n LL |     1u16 as i16;\n    |     ^^^^^^^^^^^\n \n error: casting `u32` to `i32` may wrap around the value\n-  --> $DIR/cast.rs:31:5\n+  --> $DIR/cast.rs:34:5\n    |\n LL |     1u32 as i32;\n    |     ^^^^^^^^^^^\n \n error: casting `u64` to `i64` may wrap around the value\n-  --> $DIR/cast.rs:32:5\n+  --> $DIR/cast.rs:35:5\n    |\n LL |     1u64 as i64;\n    |     ^^^^^^^^^^^\n \n error: casting `usize` to `isize` may wrap around the value\n-  --> $DIR/cast.rs:33:5\n+  --> $DIR/cast.rs:36:5\n    |\n LL |     1usize as isize;\n    |     ^^^^^^^^^^^^^^^\n \n error: casting `i32` to `u32` may lose the sign of the value\n-  --> $DIR/cast.rs:36:5\n+  --> $DIR/cast.rs:39:5\n    |\n LL |     -1i32 as u32;\n    |     ^^^^^^^^^^^^\n \n error: casting `isize` to `usize` may lose the sign of the value\n-  --> $DIR/cast.rs:38:5\n+  --> $DIR/cast.rs:41:5\n    |\n LL |     -1isize as usize;\n    |     ^^^^^^^^^^^^^^^^\n \n error: casting `i64` to `i8` may truncate the value\n-  --> $DIR/cast.rs:105:5\n+  --> $DIR/cast.rs:108:5\n    |\n LL |     (-99999999999i64).min(1) as i8; // should be linted because signed\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: casting `u64` to `u8` may truncate the value\n-  --> $DIR/cast.rs:117:5\n+  --> $DIR/cast.rs:120:5\n    |\n LL |     999999u64.clamp(0, 256) as u8; // should still be linted\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n-error: aborting due to 24 previous errors\n+error: casting `main::E2` to `u8` may truncate the value\n+  --> $DIR/cast.rs:141:21\n+   |\n+LL |             let _ = self as u8;\n+   |                     ^^^^^^^^^^\n+\n+error: casting `main::E2::B` to `u8` will truncate the value\n+  --> $DIR/cast.rs:142:21\n+   |\n+LL |             let _ = Self::B as u8;\n+   |                     ^^^^^^^^^^^^^\n+   |\n+   = note: `-D clippy::cast-enum-truncation` implied by `-D warnings`\n+\n+error: casting `main::E5` to `i8` may truncate the value\n+  --> $DIR/cast.rs:178:21\n+   |\n+LL |             let _ = self as i8;\n+   |                     ^^^^^^^^^^\n+\n+error: casting `main::E5::A` to `i8` will truncate the value\n+  --> $DIR/cast.rs:179:21\n+   |\n+LL |             let _ = Self::A as i8;\n+   |                     ^^^^^^^^^^^^^\n+\n+error: casting `main::E6` to `i16` may truncate the value\n+  --> $DIR/cast.rs:193:21\n+   |\n+LL |             let _ = self as i16;\n+   |                     ^^^^^^^^^^^\n+\n+error: casting `main::E7` to `usize` may truncate the value on targets with 32-bit wide pointers\n+  --> $DIR/cast.rs:208:21\n+   |\n+LL |             let _ = self as usize;\n+   |                     ^^^^^^^^^^^^^\n+\n+error: casting `main::E10` to `u16` may truncate the value\n+  --> $DIR/cast.rs:249:21\n+   |\n+LL |             let _ = self as u16;\n+   |                     ^^^^^^^^^^^\n+\n+error: aborting due to 31 previous errors\n "}, {"sha": "9b03c9b47832f60e1626b6477d404ec8fab87157", "filename": "tests/ui/dbg_macro.rs", "status": "modified", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/fd495a0654611a6d784bae4698e5838b121e8004/tests%2Fui%2Fdbg_macro.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd495a0654611a6d784bae4698e5838b121e8004/tests%2Fui%2Fdbg_macro.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fdbg_macro.rs?ref=fd495a0654611a6d784bae4698e5838b121e8004", "patch": "@@ -16,4 +16,27 @@ fn main() {\n     dbg!(42);\n     dbg!(dbg!(dbg!(42)));\n     foo(3) + dbg!(factorial(4));\n+    dbg!(1, 2, dbg!(3, 4));\n+    dbg!(1, 2, 3, 4, 5);\n+}\n+\n+mod issue7274 {\n+    trait Thing<'b> {\n+        fn foo(&self);\n+    }\n+\n+    macro_rules! define_thing {\n+        ($thing:ident, $body:expr) => {\n+            impl<'a> Thing<'a> for $thing {\n+                fn foo<'b>(&self) {\n+                    $body\n+                }\n+            }\n+        };\n+    }\n+\n+    struct MyThing;\n+    define_thing!(MyThing, {\n+        dbg!(2);\n+    });\n }"}, {"sha": "8ee1b328720d919f2e9629bae91bd8ae5ca8e4bc", "filename": "tests/ui/dbg_macro.stderr", "status": "modified", "additions": 34, "deletions": 1, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/fd495a0654611a6d784bae4698e5838b121e8004/tests%2Fui%2Fdbg_macro.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/fd495a0654611a6d784bae4698e5838b121e8004/tests%2Fui%2Fdbg_macro.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fdbg_macro.stderr?ref=fd495a0654611a6d784bae4698e5838b121e8004", "patch": "@@ -76,5 +76,38 @@ help: ensure to avoid having uses of it in version control\n LL |     foo(3) + factorial(4);\n    |              ~~~~~~~~~~~~\n \n-error: aborting due to 7 previous errors\n+error: `dbg!` macro is intended as a debugging tool\n+  --> $DIR/dbg_macro.rs:19:5\n+   |\n+LL |     dbg!(1, 2, dbg!(3, 4));\n+   |     ^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+help: ensure to avoid having uses of it in version control\n+   |\n+LL |     (1, 2, dbg!(3, 4));\n+   |     ~~~~~~~~~~~~~~~~~~\n+\n+error: `dbg!` macro is intended as a debugging tool\n+  --> $DIR/dbg_macro.rs:20:5\n+   |\n+LL |     dbg!(1, 2, 3, 4, 5);\n+   |     ^^^^^^^^^^^^^^^^^^^\n+   |\n+help: ensure to avoid having uses of it in version control\n+   |\n+LL |     (1, 2, 3, 4, 5);\n+   |     ~~~~~~~~~~~~~~~\n+\n+error: `dbg!` macro is intended as a debugging tool\n+  --> $DIR/dbg_macro.rs:40:9\n+   |\n+LL |         dbg!(2);\n+   |         ^^^^^^^\n+   |\n+help: ensure to avoid having uses of it in version control\n+   |\n+LL |         2;\n+   |         ~\n+\n+error: aborting due to 10 previous errors\n "}, {"sha": "264dd4efaeb8699648f3818c20f845704ac963c9", "filename": "tests/ui/default_trait_access.fixed", "status": "modified", "additions": 13, "deletions": 2, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/fd495a0654611a6d784bae4698e5838b121e8004/tests%2Fui%2Fdefault_trait_access.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/fd495a0654611a6d784bae4698e5838b121e8004/tests%2Fui%2Fdefault_trait_access.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fdefault_trait_access.fixed?ref=fd495a0654611a6d784bae4698e5838b121e8004", "patch": "@@ -46,9 +46,14 @@ fn main() {\n \n     let s19 = <DerivedDefault as Default>::default();\n \n+    let s20 = UpdateSyntax {\n+        s: \"foo\",\n+        ..Default::default()\n+    };\n+\n     println!(\n-        \"[{}] [{}] [{}] [{}] [{}] [{}] [{}] [{}] [{}] [{:?}] [{:?}] [{:?}] [{:?}] [{:?}] [{:?}] [{:?}] [{:?}] [{:?}], [{:?}]\",\n-        s1, s2, s3, s4, s5, s6, s7, s8, s9, s10, s11, s12, s13, s14, s15, s16, s17, s18, s19,\n+        \"[{}] [{}] [{}] [{}] [{}] [{}] [{}] [{}] [{}] [{:?}] [{:?}] [{:?}] [{:?}] [{:?}] [{:?}] [{:?}] [{:?}] [{:?}] [{:?}] [{:?}]\",\n+        s1, s2, s3, s4, s5, s6, s7, s8, s9, s10, s11, s12, s13, s14, s15, s16, s17, s18, s19, s20,\n     );\n }\n \n@@ -86,3 +91,9 @@ struct ArrayDerivedDefault {\n \n #[derive(Debug, Default)]\n struct TupleStructDerivedDefault(String);\n+\n+#[derive(Debug, Default)]\n+struct UpdateSyntax {\n+    pub s: &'static str,\n+    pub u: u64,\n+}"}, {"sha": "a0930fab8e7c89db4214ab966975f9dd0381c506", "filename": "tests/ui/default_trait_access.rs", "status": "modified", "additions": 13, "deletions": 2, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/fd495a0654611a6d784bae4698e5838b121e8004/tests%2Fui%2Fdefault_trait_access.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd495a0654611a6d784bae4698e5838b121e8004/tests%2Fui%2Fdefault_trait_access.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fdefault_trait_access.rs?ref=fd495a0654611a6d784bae4698e5838b121e8004", "patch": "@@ -46,9 +46,14 @@ fn main() {\n \n     let s19 = <DerivedDefault as Default>::default();\n \n+    let s20 = UpdateSyntax {\n+        s: \"foo\",\n+        ..Default::default()\n+    };\n+\n     println!(\n-        \"[{}] [{}] [{}] [{}] [{}] [{}] [{}] [{}] [{}] [{:?}] [{:?}] [{:?}] [{:?}] [{:?}] [{:?}] [{:?}] [{:?}] [{:?}], [{:?}]\",\n-        s1, s2, s3, s4, s5, s6, s7, s8, s9, s10, s11, s12, s13, s14, s15, s16, s17, s18, s19,\n+        \"[{}] [{}] [{}] [{}] [{}] [{}] [{}] [{}] [{}] [{:?}] [{:?}] [{:?}] [{:?}] [{:?}] [{:?}] [{:?}] [{:?}] [{:?}] [{:?}] [{:?}]\",\n+        s1, s2, s3, s4, s5, s6, s7, s8, s9, s10, s11, s12, s13, s14, s15, s16, s17, s18, s19, s20,\n     );\n }\n \n@@ -86,3 +91,9 @@ struct ArrayDerivedDefault {\n \n #[derive(Debug, Default)]\n struct TupleStructDerivedDefault(String);\n+\n+#[derive(Debug, Default)]\n+struct UpdateSyntax {\n+    pub s: &'static str,\n+    pub u: u64,\n+}"}, {"sha": "b26276218b78c7e0c110cb4c1831689a27372afb", "filename": "tests/ui/deref_by_slicing.fixed", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/fd495a0654611a6d784bae4698e5838b121e8004/tests%2Fui%2Fderef_by_slicing.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/fd495a0654611a6d784bae4698e5838b121e8004/tests%2Fui%2Fderef_by_slicing.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fderef_by_slicing.fixed?ref=fd495a0654611a6d784bae4698e5838b121e8004", "patch": "@@ -0,0 +1,29 @@\n+// run-rustfix\n+\n+#![warn(clippy::deref_by_slicing)]\n+\n+use std::io::Read;\n+\n+fn main() {\n+    let mut vec = vec![0];\n+    let _ = &*vec;\n+    let _ = &mut *vec;\n+\n+    let ref_vec = &mut vec;\n+    let _ = &**ref_vec;\n+    let mut_slice = &mut **ref_vec;\n+    let _ = &mut *mut_slice; // Err, re-borrows slice\n+\n+    let s = String::new();\n+    let _ = &*s;\n+\n+    static S: &[u8] = &[0, 1, 2];\n+    let _ = &mut &*S; // Err, re-borrows slice\n+\n+    let slice: &[u32] = &[0u32, 1u32];\n+    let slice_ref = &slice;\n+    let _ = *slice_ref; // Err, derefs slice\n+\n+    let bytes: &[u8] = &[];\n+    let _ = (&*bytes).read_to_end(&mut vec![]).unwrap(); // Err, re-borrows slice\n+}"}, {"sha": "6aa1408ba17698854ad1f9bcf361694b6aa5343e", "filename": "tests/ui/deref_by_slicing.rs", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/fd495a0654611a6d784bae4698e5838b121e8004/tests%2Fui%2Fderef_by_slicing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd495a0654611a6d784bae4698e5838b121e8004/tests%2Fui%2Fderef_by_slicing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fderef_by_slicing.rs?ref=fd495a0654611a6d784bae4698e5838b121e8004", "patch": "@@ -0,0 +1,29 @@\n+// run-rustfix\n+\n+#![warn(clippy::deref_by_slicing)]\n+\n+use std::io::Read;\n+\n+fn main() {\n+    let mut vec = vec![0];\n+    let _ = &vec[..];\n+    let _ = &mut vec[..];\n+\n+    let ref_vec = &mut vec;\n+    let _ = &ref_vec[..];\n+    let mut_slice = &mut ref_vec[..];\n+    let _ = &mut mut_slice[..]; // Err, re-borrows slice\n+\n+    let s = String::new();\n+    let _ = &s[..];\n+\n+    static S: &[u8] = &[0, 1, 2];\n+    let _ = &mut &S[..]; // Err, re-borrows slice\n+\n+    let slice: &[u32] = &[0u32, 1u32];\n+    let slice_ref = &slice;\n+    let _ = &slice_ref[..]; // Err, derefs slice\n+\n+    let bytes: &[u8] = &[];\n+    let _ = (&bytes[..]).read_to_end(&mut vec![]).unwrap(); // Err, re-borrows slice\n+}"}, {"sha": "ffd76de378df1d314b7d95fa04cf96f6efaac800", "filename": "tests/ui/deref_by_slicing.stderr", "status": "added", "additions": 58, "deletions": 0, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/fd495a0654611a6d784bae4698e5838b121e8004/tests%2Fui%2Fderef_by_slicing.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/fd495a0654611a6d784bae4698e5838b121e8004/tests%2Fui%2Fderef_by_slicing.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fderef_by_slicing.stderr?ref=fd495a0654611a6d784bae4698e5838b121e8004", "patch": "@@ -0,0 +1,58 @@\n+error: slicing when dereferencing would work\n+  --> $DIR/deref_by_slicing.rs:9:13\n+   |\n+LL |     let _ = &vec[..];\n+   |             ^^^^^^^^ help: dereference the original value instead: `&*vec`\n+   |\n+   = note: `-D clippy::deref-by-slicing` implied by `-D warnings`\n+\n+error: slicing when dereferencing would work\n+  --> $DIR/deref_by_slicing.rs:10:13\n+   |\n+LL |     let _ = &mut vec[..];\n+   |             ^^^^^^^^^^^^ help: dereference the original value instead: `&mut *vec`\n+\n+error: slicing when dereferencing would work\n+  --> $DIR/deref_by_slicing.rs:13:13\n+   |\n+LL |     let _ = &ref_vec[..];\n+   |             ^^^^^^^^^^^^ help: dereference the original value instead: `&**ref_vec`\n+\n+error: slicing when dereferencing would work\n+  --> $DIR/deref_by_slicing.rs:14:21\n+   |\n+LL |     let mut_slice = &mut ref_vec[..];\n+   |                     ^^^^^^^^^^^^^^^^ help: dereference the original value instead: `&mut **ref_vec`\n+\n+error: slicing when dereferencing would work\n+  --> $DIR/deref_by_slicing.rs:15:13\n+   |\n+LL |     let _ = &mut mut_slice[..]; // Err, re-borrows slice\n+   |             ^^^^^^^^^^^^^^^^^^ help: reborrow the original value instead: `&mut *mut_slice`\n+\n+error: slicing when dereferencing would work\n+  --> $DIR/deref_by_slicing.rs:18:13\n+   |\n+LL |     let _ = &s[..];\n+   |             ^^^^^^ help: dereference the original value instead: `&*s`\n+\n+error: slicing when dereferencing would work\n+  --> $DIR/deref_by_slicing.rs:21:18\n+   |\n+LL |     let _ = &mut &S[..]; // Err, re-borrows slice\n+   |                  ^^^^^^ help: reborrow the original value instead: `&*S`\n+\n+error: slicing when dereferencing would work\n+  --> $DIR/deref_by_slicing.rs:25:13\n+   |\n+LL |     let _ = &slice_ref[..]; // Err, derefs slice\n+   |             ^^^^^^^^^^^^^^ help: dereference the original value instead: `*slice_ref`\n+\n+error: slicing when dereferencing would work\n+  --> $DIR/deref_by_slicing.rs:28:13\n+   |\n+LL |     let _ = (&bytes[..]).read_to_end(&mut vec![]).unwrap(); // Err, re-borrows slice\n+   |             ^^^^^^^^^^^^ help: reborrow the original value instead: `(&*bytes)`\n+\n+error: aborting due to 9 previous errors\n+"}, {"sha": "5aedbea381f2317d80c661cc20f7ffbc07748eae", "filename": "tests/ui/eta.fixed", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/fd495a0654611a6d784bae4698e5838b121e8004/tests%2Fui%2Feta.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/fd495a0654611a6d784bae4698e5838b121e8004/tests%2Fui%2Feta.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Feta.fixed?ref=fd495a0654611a6d784bae4698e5838b121e8004", "patch": "@@ -256,3 +256,22 @@ fn arc_fp() {\n     (0..5).map(|n| arc(n));\n     Some(4).map(|n| ref_arc(n));\n }\n+\n+// #8460 Don't replace closures with params bounded as `ref`\n+mod bind_by_ref {\n+    struct A;\n+    struct B;\n+\n+    impl From<&A> for B {\n+        fn from(A: &A) -> Self {\n+            B\n+        }\n+    }\n+\n+    fn test() {\n+        // should not lint\n+        Some(A).map(|a| B::from(&a));\n+        // should not lint\n+        Some(A).map(|ref a| B::from(a));\n+    }\n+}"}, {"sha": "5fdf7fb9771697e2330265458903ac5c12528f94", "filename": "tests/ui/eta.rs", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/fd495a0654611a6d784bae4698e5838b121e8004/tests%2Fui%2Feta.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd495a0654611a6d784bae4698e5838b121e8004/tests%2Fui%2Feta.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Feta.rs?ref=fd495a0654611a6d784bae4698e5838b121e8004", "patch": "@@ -256,3 +256,22 @@ fn arc_fp() {\n     (0..5).map(|n| arc(n));\n     Some(4).map(|n| ref_arc(n));\n }\n+\n+// #8460 Don't replace closures with params bounded as `ref`\n+mod bind_by_ref {\n+    struct A;\n+    struct B;\n+\n+    impl From<&A> for B {\n+        fn from(A: &A) -> Self {\n+            B\n+        }\n+    }\n+\n+    fn test() {\n+        // should not lint\n+        Some(A).map(|a| B::from(&a));\n+        // should not lint\n+        Some(A).map(|ref a| B::from(a));\n+    }\n+}"}, {"sha": "ddfa1e741ada439e347229fe090e7ad508a9dffe", "filename": "tests/ui/match_as_ref.fixed", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/fd495a0654611a6d784bae4698e5838b121e8004/tests%2Fui%2Fmatch_as_ref.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/fd495a0654611a6d784bae4698e5838b121e8004/tests%2Fui%2Fmatch_as_ref.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmatch_as_ref.fixed?ref=fd495a0654611a6d784bae4698e5838b121e8004", "patch": "@@ -32,4 +32,12 @@ mod issue4437 {\n     }\n }\n \n-fn main() {}\n+fn main() {\n+    // Don't lint\n+    let _ = match Some(0) {\n+        #[cfg(feature = \"foo\")]\n+        Some(ref x) if *x > 50 => None,\n+        Some(ref x) => Some(x),\n+        None => None,\n+    };\n+}"}, {"sha": "025d475ae13dba80d01d37a0c4f73689fd68d6cb", "filename": "tests/ui/match_as_ref.rs", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/fd495a0654611a6d784bae4698e5838b121e8004/tests%2Fui%2Fmatch_as_ref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd495a0654611a6d784bae4698e5838b121e8004/tests%2Fui%2Fmatch_as_ref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmatch_as_ref.rs?ref=fd495a0654611a6d784bae4698e5838b121e8004", "patch": "@@ -41,4 +41,12 @@ mod issue4437 {\n     }\n }\n \n-fn main() {}\n+fn main() {\n+    // Don't lint\n+    let _ = match Some(0) {\n+        #[cfg(feature = \"foo\")]\n+        Some(ref x) if *x > 50 => None,\n+        Some(ref x) => Some(x),\n+        None => None,\n+    };\n+}"}, {"sha": "bcc999a49428daf281a2317026c5ef83da37a2b5", "filename": "tests/ui/match_bool.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/fd495a0654611a6d784bae4698e5838b121e8004/tests%2Fui%2Fmatch_bool.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd495a0654611a6d784bae4698e5838b121e8004/tests%2Fui%2Fmatch_bool.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmatch_bool.rs?ref=fd495a0654611a6d784bae4698e5838b121e8004", "patch": "@@ -50,6 +50,14 @@ fn match_bool() {\n         11..=20 => 2,\n         _ => 3,\n     };\n+\n+    // Don't lint\n+    let _ = match test {\n+        #[cfg(feature = \"foo\")]\n+        true if option == 5 => 10,\n+        true => 0,\n+        false => 1,\n+    };\n }\n \n fn main() {}"}, {"sha": "36f233f33460720759355d78d1c0cf26623d7713", "filename": "tests/ui/match_expr_like_matches_macro.fixed", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/fd495a0654611a6d784bae4698e5838b121e8004/tests%2Fui%2Fmatch_expr_like_matches_macro.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/fd495a0654611a6d784bae4698e5838b121e8004/tests%2Fui%2Fmatch_expr_like_matches_macro.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmatch_expr_like_matches_macro.fixed?ref=fd495a0654611a6d784bae4698e5838b121e8004", "patch": "@@ -146,4 +146,19 @@ fn main() {\n         let _res = matches!(&val, &Some(ref _a));\n         fun(val);\n     }\n+\n+    {\n+        enum E {\n+            A,\n+            B,\n+            C,\n+        }\n+\n+        let _ = match E::A {\n+            E::B => true,\n+            #[cfg(feature = \"foo\")]\n+            E::A => true,\n+            _ => false,\n+        };\n+    }\n }"}, {"sha": "750f69fa5088f6fa45898030bfca0d56ee486a81", "filename": "tests/ui/match_expr_like_matches_macro.rs", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/fd495a0654611a6d784bae4698e5838b121e8004/tests%2Fui%2Fmatch_expr_like_matches_macro.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd495a0654611a6d784bae4698e5838b121e8004/tests%2Fui%2Fmatch_expr_like_matches_macro.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmatch_expr_like_matches_macro.rs?ref=fd495a0654611a6d784bae4698e5838b121e8004", "patch": "@@ -181,4 +181,19 @@ fn main() {\n         };\n         fun(val);\n     }\n+\n+    {\n+        enum E {\n+            A,\n+            B,\n+            C,\n+        }\n+\n+        let _ = match E::A {\n+            E::B => true,\n+            #[cfg(feature = \"foo\")]\n+            E::A => true,\n+            _ => false,\n+        };\n+    }\n }"}, {"sha": "67e1d518483c2cf6b61ca152b368506619cc9008", "filename": "tests/ui/match_same_arms2.rs", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/fd495a0654611a6d784bae4698e5838b121e8004/tests%2Fui%2Fmatch_same_arms2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd495a0654611a6d784bae4698e5838b121e8004/tests%2Fui%2Fmatch_same_arms2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmatch_same_arms2.rs?ref=fd495a0654611a6d784bae4698e5838b121e8004", "patch": "@@ -166,4 +166,12 @@ fn match_expr_like_matches_macro_priority() {\n     };\n }\n \n-fn main() {}\n+fn main() {\n+    let _ = match Some(0) {\n+        Some(0) => 0,\n+        Some(1) => 1,\n+        #[cfg(feature = \"foo\")]\n+        Some(2) => 2,\n+        _ => 1,\n+    };\n+}"}, {"sha": "b8dc8179f7d7d1c841a5df8475ebed31a52f0014", "filename": "tests/ui/match_single_binding.fixed", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/fd495a0654611a6d784bae4698e5838b121e8004/tests%2Fui%2Fmatch_single_binding.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/fd495a0654611a6d784bae4698e5838b121e8004/tests%2Fui%2Fmatch_single_binding.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmatch_single_binding.fixed?ref=fd495a0654611a6d784bae4698e5838b121e8004", "patch": "@@ -106,10 +106,8 @@ fn main() {\n         0 => println!(\"Array index start\"),\n         _ => println!(\"Not an array index start\"),\n     }\n-    // False negative\n+\n+    // Lint\n     let x = 1;\n-    match x {\n-        // =>\n-        _ => println!(\"Not an array index start\"),\n-    }\n+    println!(\"Not an array index start\");\n }"}, {"sha": "fe63dcd63f2bb97d5fcd69f62f3b4d74f5a0c037", "filename": "tests/ui/match_single_binding.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/fd495a0654611a6d784bae4698e5838b121e8004/tests%2Fui%2Fmatch_single_binding.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd495a0654611a6d784bae4698e5838b121e8004/tests%2Fui%2Fmatch_single_binding.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmatch_single_binding.rs?ref=fd495a0654611a6d784bae4698e5838b121e8004", "patch": "@@ -118,7 +118,8 @@ fn main() {\n         0 => println!(\"Array index start\"),\n         _ => println!(\"Not an array index start\"),\n     }\n-    // False negative\n+\n+    // Lint\n     let x = 1;\n     match x {\n         // =>"}, {"sha": "d939291f53c40758821783da7bdbc38255ff8542", "filename": "tests/ui/match_single_binding.stderr", "status": "modified", "additions": 10, "deletions": 1, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/fd495a0654611a6d784bae4698e5838b121e8004/tests%2Fui%2Fmatch_single_binding.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/fd495a0654611a6d784bae4698e5838b121e8004/tests%2Fui%2Fmatch_single_binding.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmatch_single_binding.stderr?ref=fd495a0654611a6d784bae4698e5838b121e8004", "patch": "@@ -167,5 +167,14 @@ LL +             unwrapped\n LL ~         })\n    |\n \n-error: aborting due to 11 previous errors\n+error: this match could be replaced by its body itself\n+  --> $DIR/match_single_binding.rs:124:5\n+   |\n+LL | /     match x {\n+LL | |         // =>\n+LL | |         _ => println!(\"Not an array index start\"),\n+LL | |     }\n+   | |_____^ help: consider using the match body instead: `println!(\"Not an array index start\");`\n+\n+error: aborting due to 12 previous errors\n "}, {"sha": "c76e3b424383e2552591742e08acb054645ffc1e", "filename": "tests/ui/new_without_default.rs", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/fd495a0654611a6d784bae4698e5838b121e8004/tests%2Fui%2Fnew_without_default.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd495a0654611a6d784bae4698e5838b121e8004/tests%2Fui%2Fnew_without_default.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fnew_without_default.rs?ref=fd495a0654611a6d784bae4698e5838b121e8004", "patch": "@@ -90,6 +90,22 @@ impl Private {\n     } // We don't lint private items\n }\n \n+struct PrivateStruct;\n+\n+impl PrivateStruct {\n+    pub fn new() -> PrivateStruct {\n+        unimplemented!()\n+    } // We don't lint public items on private structs\n+}\n+\n+pub struct PrivateItem;\n+\n+impl PrivateItem {\n+    fn new() -> PrivateItem {\n+        unimplemented!()\n+    } // We don't lint private items on public structs\n+}\n+\n struct Const;\n \n impl Const {"}, {"sha": "19572dfe8b0753bdb597ca3959314eede3bd0685", "filename": "tests/ui/new_without_default.stderr", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/fd495a0654611a6d784bae4698e5838b121e8004/tests%2Fui%2Fnew_without_default.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/fd495a0654611a6d784bae4698e5838b121e8004/tests%2Fui%2Fnew_without_default.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fnew_without_default.stderr?ref=fd495a0654611a6d784bae4698e5838b121e8004", "patch": "@@ -51,7 +51,7 @@ LL + }\n    |\n \n error: you should consider adding a `Default` implementation for `NewNotEqualToDerive`\n-  --> $DIR/new_without_default.rs:156:5\n+  --> $DIR/new_without_default.rs:172:5\n    |\n LL | /     pub fn new() -> Self {\n LL | |         NewNotEqualToDerive { foo: 1 }\n@@ -68,7 +68,7 @@ LL + }\n    |\n \n error: you should consider adding a `Default` implementation for `FooGenerics<T>`\n-  --> $DIR/new_without_default.rs:164:5\n+  --> $DIR/new_without_default.rs:180:5\n    |\n LL | /     pub fn new() -> Self {\n LL | |         Self(Default::default())\n@@ -85,7 +85,7 @@ LL + }\n    |\n \n error: you should consider adding a `Default` implementation for `BarGenerics<T>`\n-  --> $DIR/new_without_default.rs:171:5\n+  --> $DIR/new_without_default.rs:187:5\n    |\n LL | /     pub fn new() -> Self {\n LL | |         Self(Default::default())\n@@ -102,7 +102,7 @@ LL + }\n    |\n \n error: you should consider adding a `Default` implementation for `Foo<T>`\n-  --> $DIR/new_without_default.rs:182:9\n+  --> $DIR/new_without_default.rs:198:9\n    |\n LL | /         pub fn new() -> Self {\n LL | |             todo!()"}, {"sha": "bea6be66a8e025ef2f4468b5bb41e556c4c4614c", "filename": "tests/ui/ptr_as_ptr.fixed", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/fd495a0654611a6d784bae4698e5838b121e8004/tests%2Fui%2Fptr_as_ptr.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/fd495a0654611a6d784bae4698e5838b121e8004/tests%2Fui%2Fptr_as_ptr.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fptr_as_ptr.fixed?ref=fd495a0654611a6d784bae4698e5838b121e8004", "patch": "@@ -1,8 +1,17 @@\n // run-rustfix\n+// aux-build:macro_rules.rs\n \n #![warn(clippy::ptr_as_ptr)]\n #![feature(custom_inner_attributes)]\n \n+extern crate macro_rules;\n+\n+macro_rules! cast_it {\n+    ($ptr: ident) => {\n+        $ptr.cast::<i32>()\n+    };\n+}\n+\n fn main() {\n     let ptr: *const u32 = &42_u32;\n     let mut_ptr: *mut u32 = &mut 42_u32;\n@@ -28,6 +37,12 @@ fn main() {\n     // Ensure the lint doesn't produce unnecessary turbofish for inferred types.\n     let _: *const i32 = ptr.cast();\n     let _: *mut i32 = mut_ptr.cast();\n+\n+    // Make sure the lint is triggered inside a macro\n+    let _ = cast_it!(ptr);\n+\n+    // Do not lint inside macros from external crates\n+    let _ = macro_rules::ptr_as_ptr_cast!(ptr);\n }\n \n fn _msrv_1_37() {"}, {"sha": "ca2616b0069a07003d5d99e6505f0c86922b9e4c", "filename": "tests/ui/ptr_as_ptr.rs", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/fd495a0654611a6d784bae4698e5838b121e8004/tests%2Fui%2Fptr_as_ptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd495a0654611a6d784bae4698e5838b121e8004/tests%2Fui%2Fptr_as_ptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fptr_as_ptr.rs?ref=fd495a0654611a6d784bae4698e5838b121e8004", "patch": "@@ -1,8 +1,17 @@\n // run-rustfix\n+// aux-build:macro_rules.rs\n \n #![warn(clippy::ptr_as_ptr)]\n #![feature(custom_inner_attributes)]\n \n+extern crate macro_rules;\n+\n+macro_rules! cast_it {\n+    ($ptr: ident) => {\n+        $ptr as *const i32\n+    };\n+}\n+\n fn main() {\n     let ptr: *const u32 = &42_u32;\n     let mut_ptr: *mut u32 = &mut 42_u32;\n@@ -28,6 +37,12 @@ fn main() {\n     // Ensure the lint doesn't produce unnecessary turbofish for inferred types.\n     let _: *const i32 = ptr as *const _;\n     let _: *mut i32 = mut_ptr as _;\n+\n+    // Make sure the lint is triggered inside a macro\n+    let _ = cast_it!(ptr);\n+\n+    // Do not lint inside macros from external crates\n+    let _ = macro_rules::ptr_as_ptr_cast!(ptr);\n }\n \n fn _msrv_1_37() {"}, {"sha": "c58c55cfd83a15c5ac671f19f37ff4f64be212a8", "filename": "tests/ui/ptr_as_ptr.stderr", "status": "modified", "additions": 19, "deletions": 8, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/fd495a0654611a6d784bae4698e5838b121e8004/tests%2Fui%2Fptr_as_ptr.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/fd495a0654611a6d784bae4698e5838b121e8004/tests%2Fui%2Fptr_as_ptr.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fptr_as_ptr.stderr?ref=fd495a0654611a6d784bae4698e5838b121e8004", "patch": "@@ -1,46 +1,57 @@\n error: `as` casting between raw pointers without changing its mutability\n-  --> $DIR/ptr_as_ptr.rs:10:13\n+  --> $DIR/ptr_as_ptr.rs:19:13\n    |\n LL |     let _ = ptr as *const i32;\n    |             ^^^^^^^^^^^^^^^^^ help: try `pointer::cast`, a safer alternative: `ptr.cast::<i32>()`\n    |\n    = note: `-D clippy::ptr-as-ptr` implied by `-D warnings`\n \n error: `as` casting between raw pointers without changing its mutability\n-  --> $DIR/ptr_as_ptr.rs:11:13\n+  --> $DIR/ptr_as_ptr.rs:20:13\n    |\n LL |     let _ = mut_ptr as *mut i32;\n    |             ^^^^^^^^^^^^^^^^^^^ help: try `pointer::cast`, a safer alternative: `mut_ptr.cast::<i32>()`\n \n error: `as` casting between raw pointers without changing its mutability\n-  --> $DIR/ptr_as_ptr.rs:16:17\n+  --> $DIR/ptr_as_ptr.rs:25:17\n    |\n LL |         let _ = *ptr_ptr as *const i32;\n    |                 ^^^^^^^^^^^^^^^^^^^^^^ help: try `pointer::cast`, a safer alternative: `(*ptr_ptr).cast::<i32>()`\n \n error: `as` casting between raw pointers without changing its mutability\n-  --> $DIR/ptr_as_ptr.rs:29:25\n+  --> $DIR/ptr_as_ptr.rs:38:25\n    |\n LL |     let _: *const i32 = ptr as *const _;\n    |                         ^^^^^^^^^^^^^^^ help: try `pointer::cast`, a safer alternative: `ptr.cast()`\n \n error: `as` casting between raw pointers without changing its mutability\n-  --> $DIR/ptr_as_ptr.rs:30:23\n+  --> $DIR/ptr_as_ptr.rs:39:23\n    |\n LL |     let _: *mut i32 = mut_ptr as _;\n    |                       ^^^^^^^^^^^^ help: try `pointer::cast`, a safer alternative: `mut_ptr.cast()`\n \n error: `as` casting between raw pointers without changing its mutability\n-  --> $DIR/ptr_as_ptr.rs:48:13\n+  --> $DIR/ptr_as_ptr.rs:11:9\n+   |\n+LL |         $ptr as *const i32\n+   |         ^^^^^^^^^^^^^^^^^^ help: try `pointer::cast`, a safer alternative: `$ptr.cast::<i32>()`\n+...\n+LL |     let _ = cast_it!(ptr);\n+   |             ------------- in this macro invocation\n+   |\n+   = note: this error originates in the macro `cast_it` (in Nightly builds, run with -Z macro-backtrace for more info)\n+\n+error: `as` casting between raw pointers without changing its mutability\n+  --> $DIR/ptr_as_ptr.rs:63:13\n    |\n LL |     let _ = ptr as *const i32;\n    |             ^^^^^^^^^^^^^^^^^ help: try `pointer::cast`, a safer alternative: `ptr.cast::<i32>()`\n \n error: `as` casting between raw pointers without changing its mutability\n-  --> $DIR/ptr_as_ptr.rs:49:13\n+  --> $DIR/ptr_as_ptr.rs:64:13\n    |\n LL |     let _ = mut_ptr as *mut i32;\n    |             ^^^^^^^^^^^^^^^^^^^ help: try `pointer::cast`, a safer alternative: `mut_ptr.cast::<i32>()`\n \n-error: aborting due to 7 previous errors\n+error: aborting due to 8 previous errors\n "}, {"sha": "9241bf7ed74025b8508ace83be7a2819fe66d09e", "filename": "tests/ui/recursive_format_impl.rs", "status": "added", "additions": 321, "deletions": 0, "changes": 321, "blob_url": "https://github.com/rust-lang/rust/blob/fd495a0654611a6d784bae4698e5838b121e8004/tests%2Fui%2Frecursive_format_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd495a0654611a6d784bae4698e5838b121e8004/tests%2Fui%2Frecursive_format_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Frecursive_format_impl.rs?ref=fd495a0654611a6d784bae4698e5838b121e8004", "patch": "@@ -0,0 +1,321 @@\n+#![warn(clippy::recursive_format_impl)]\n+#![allow(\n+    clippy::inherent_to_string_shadow_display,\n+    clippy::to_string_in_format_args,\n+    clippy::deref_addrof\n+)]\n+\n+use std::fmt;\n+\n+struct A;\n+impl A {\n+    fn fmt(&self) {\n+        self.to_string();\n+    }\n+}\n+\n+trait B {\n+    fn fmt(&self) {}\n+}\n+\n+impl B for A {\n+    fn fmt(&self) {\n+        self.to_string();\n+    }\n+}\n+\n+impl fmt::Display for A {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        write!(f, \"{}\", self.to_string())\n+    }\n+}\n+\n+fn fmt(a: A) {\n+    a.to_string();\n+}\n+\n+struct C;\n+\n+impl C {\n+    // Doesn't trigger if to_string defined separately\n+    // i.e. not using ToString trait (from Display)\n+    fn to_string(&self) -> String {\n+        String::from(\"I am C\")\n+    }\n+}\n+\n+impl fmt::Display for C {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        write!(f, \"{}\", self.to_string())\n+    }\n+}\n+\n+enum D {\n+    E(String),\n+    F,\n+}\n+\n+impl std::fmt::Display for D {\n+    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n+        match &self {\n+            Self::E(string) => write!(f, \"E {}\", string.to_string()),\n+            Self::F => write!(f, \"F\"),\n+        }\n+    }\n+}\n+\n+// Check for use of self as Display, in Display impl\n+// Triggers on direct use of self\n+struct G {}\n+\n+impl std::fmt::Display for G {\n+    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n+        write!(f, \"{}\", self)\n+    }\n+}\n+\n+// Triggers on reference to self\n+struct H {}\n+\n+impl std::fmt::Display for H {\n+    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n+        write!(f, \"{}\", &self)\n+    }\n+}\n+\n+impl std::fmt::Debug for H {\n+    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n+        write!(f, \"{:?}\", &self)\n+    }\n+}\n+\n+// Triggers on multiple reference to self\n+struct H2 {}\n+\n+impl std::fmt::Display for H2 {\n+    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n+        write!(f, \"{}\", &&&self)\n+    }\n+}\n+\n+// Doesn't trigger on correct deref\n+struct I {}\n+\n+impl std::ops::Deref for I {\n+    type Target = str;\n+\n+    fn deref(&self) -> &Self::Target {\n+        \"test\"\n+    }\n+}\n+\n+impl std::fmt::Display for I {\n+    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {\n+        write!(f, \"{}\", &**self)\n+    }\n+}\n+\n+impl std::fmt::Debug for I {\n+    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {\n+        write!(f, \"{:?}\", &**self)\n+    }\n+}\n+\n+// Doesn't trigger on multiple correct deref\n+struct I2 {}\n+\n+impl std::ops::Deref for I2 {\n+    type Target = str;\n+\n+    fn deref(&self) -> &Self::Target {\n+        \"test\"\n+    }\n+}\n+\n+impl std::fmt::Display for I2 {\n+    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {\n+        write!(f, \"{}\", **&&&**self)\n+    }\n+}\n+\n+// Doesn't trigger on multiple correct deref\n+struct I3 {}\n+\n+impl std::ops::Deref for I3 {\n+    type Target = str;\n+\n+    fn deref(&self) -> &Self::Target {\n+        \"test\"\n+    }\n+}\n+\n+impl std::fmt::Display for I3 {\n+    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {\n+        write!(f, \"{}\", &&**&&&**self)\n+    }\n+}\n+\n+// Does trigger when deref resolves to self\n+struct J {}\n+\n+impl std::ops::Deref for J {\n+    type Target = str;\n+\n+    fn deref(&self) -> &Self::Target {\n+        \"test\"\n+    }\n+}\n+\n+impl std::fmt::Display for J {\n+    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {\n+        write!(f, \"{}\", &*self)\n+    }\n+}\n+\n+impl std::fmt::Debug for J {\n+    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {\n+        write!(f, \"{:?}\", &*self)\n+    }\n+}\n+\n+struct J2 {}\n+\n+impl std::ops::Deref for J2 {\n+    type Target = str;\n+\n+    fn deref(&self) -> &Self::Target {\n+        \"test\"\n+    }\n+}\n+\n+impl std::fmt::Display for J2 {\n+    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {\n+        write!(f, \"{}\", *self)\n+    }\n+}\n+\n+struct J3 {}\n+\n+impl std::ops::Deref for J3 {\n+    type Target = str;\n+\n+    fn deref(&self) -> &Self::Target {\n+        \"test\"\n+    }\n+}\n+\n+impl std::fmt::Display for J3 {\n+    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {\n+        write!(f, \"{}\", **&&*self)\n+    }\n+}\n+\n+struct J4 {}\n+\n+impl std::ops::Deref for J4 {\n+    type Target = str;\n+\n+    fn deref(&self) -> &Self::Target {\n+        \"test\"\n+    }\n+}\n+\n+impl std::fmt::Display for J4 {\n+    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {\n+        write!(f, \"{}\", &&**&&*self)\n+    }\n+}\n+\n+// Doesn't trigger on Debug from Display\n+struct K {}\n+\n+impl std::fmt::Debug for K {\n+    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {\n+        write!(f, \"test\")\n+    }\n+}\n+\n+impl std::fmt::Display for K {\n+    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {\n+        write!(f, \"{:?}\", self)\n+    }\n+}\n+\n+// Doesn't trigger on Display from Debug\n+struct K2 {}\n+\n+impl std::fmt::Debug for K2 {\n+    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {\n+        write!(f, \"{}\", self)\n+    }\n+}\n+\n+impl std::fmt::Display for K2 {\n+    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {\n+        write!(f, \"test\")\n+    }\n+}\n+\n+// Doesn't trigger on struct fields\n+struct L {\n+    field1: u32,\n+    field2: i32,\n+}\n+\n+impl std::fmt::Display for L {\n+    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {\n+        write!(f, \"{},{}\", self.field1, self.field2)\n+    }\n+}\n+\n+impl std::fmt::Debug for L {\n+    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {\n+        write!(f, \"{:?},{:?}\", self.field1, self.field2)\n+    }\n+}\n+\n+// Doesn't trigger on nested enum matching\n+enum Tree {\n+    Leaf,\n+    Node(Vec<Tree>),\n+}\n+\n+impl std::fmt::Display for Tree {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        match self {\n+            Tree::Leaf => write!(f, \"*\"),\n+            Tree::Node(children) => {\n+                write!(f, \"(\")?;\n+                for child in children.iter() {\n+                    write!(f, \"{},\", child)?;\n+                }\n+                write!(f, \")\")\n+            },\n+        }\n+    }\n+}\n+\n+impl std::fmt::Debug for Tree {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        match self {\n+            Tree::Leaf => write!(f, \"*\"),\n+            Tree::Node(children) => {\n+                write!(f, \"(\")?;\n+                for child in children.iter() {\n+                    write!(f, \"{:?},\", child)?;\n+                }\n+                write!(f, \")\")\n+            },\n+        }\n+    }\n+}\n+\n+fn main() {\n+    let a = A;\n+    a.to_string();\n+    a.fmt();\n+    fmt(a);\n+\n+    let c = C;\n+    c.to_string();\n+}"}, {"sha": "6171696ed69d4f7432cb0bd7488bc4f00ae18f80", "filename": "tests/ui/recursive_format_impl.stderr", "status": "added", "additions": 91, "deletions": 0, "changes": 91, "blob_url": "https://github.com/rust-lang/rust/blob/fd495a0654611a6d784bae4698e5838b121e8004/tests%2Fui%2Frecursive_format_impl.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/fd495a0654611a6d784bae4698e5838b121e8004/tests%2Fui%2Frecursive_format_impl.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Frecursive_format_impl.stderr?ref=fd495a0654611a6d784bae4698e5838b121e8004", "patch": "@@ -0,0 +1,91 @@\n+error: using `self.to_string` in `fmt::Display` implementation will cause infinite recursion\n+  --> $DIR/recursive_format_impl.rs:29:25\n+   |\n+LL |         write!(f, \"{}\", self.to_string())\n+   |                         ^^^^^^^^^^^^^^^^\n+   |\n+   = note: `-D clippy::recursive-format-impl` implied by `-D warnings`\n+\n+error: unnecessary use of `to_string`\n+  --> $DIR/recursive_format_impl.rs:61:50\n+   |\n+LL |             Self::E(string) => write!(f, \"E {}\", string.to_string()),\n+   |                                                  ^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: `-D clippy::unnecessary-to-owned` implied by `-D warnings`\n+   = note: this error originates in the macro `$crate::format_args` (in Nightly builds, run with -Z macro-backtrace for more info)\n+\n+error: using `self` as `Display` in `impl Display` will cause infinite recursion\n+  --> $DIR/recursive_format_impl.rs:73:9\n+   |\n+LL |         write!(f, \"{}\", self)\n+   |         ^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: this error originates in the macro `write` (in Nightly builds, run with -Z macro-backtrace for more info)\n+\n+error: using `self` as `Display` in `impl Display` will cause infinite recursion\n+  --> $DIR/recursive_format_impl.rs:82:9\n+   |\n+LL |         write!(f, \"{}\", &self)\n+   |         ^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: this error originates in the macro `write` (in Nightly builds, run with -Z macro-backtrace for more info)\n+\n+error: using `self` as `Debug` in `impl Debug` will cause infinite recursion\n+  --> $DIR/recursive_format_impl.rs:88:9\n+   |\n+LL |         write!(f, \"{:?}\", &self)\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: this error originates in the macro `write` (in Nightly builds, run with -Z macro-backtrace for more info)\n+\n+error: using `self` as `Display` in `impl Display` will cause infinite recursion\n+  --> $DIR/recursive_format_impl.rs:97:9\n+   |\n+LL |         write!(f, \"{}\", &&&self)\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: this error originates in the macro `write` (in Nightly builds, run with -Z macro-backtrace for more info)\n+\n+error: using `self` as `Display` in `impl Display` will cause infinite recursion\n+  --> $DIR/recursive_format_impl.rs:171:9\n+   |\n+LL |         write!(f, \"{}\", &*self)\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: this error originates in the macro `write` (in Nightly builds, run with -Z macro-backtrace for more info)\n+\n+error: using `self` as `Debug` in `impl Debug` will cause infinite recursion\n+  --> $DIR/recursive_format_impl.rs:177:9\n+   |\n+LL |         write!(f, \"{:?}\", &*self)\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: this error originates in the macro `write` (in Nightly builds, run with -Z macro-backtrace for more info)\n+\n+error: using `self` as `Display` in `impl Display` will cause infinite recursion\n+  --> $DIR/recursive_format_impl.rs:193:9\n+   |\n+LL |         write!(f, \"{}\", *self)\n+   |         ^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: this error originates in the macro `write` (in Nightly builds, run with -Z macro-backtrace for more info)\n+\n+error: using `self` as `Display` in `impl Display` will cause infinite recursion\n+  --> $DIR/recursive_format_impl.rs:209:9\n+   |\n+LL |         write!(f, \"{}\", **&&*self)\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: this error originates in the macro `write` (in Nightly builds, run with -Z macro-backtrace for more info)\n+\n+error: using `self` as `Display` in `impl Display` will cause infinite recursion\n+  --> $DIR/recursive_format_impl.rs:225:9\n+   |\n+LL |         write!(f, \"{}\", &&**&&*self)\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: this error originates in the macro `write` (in Nightly builds, run with -Z macro-backtrace for more info)\n+\n+error: aborting due to 11 previous errors\n+"}, {"sha": "8dd8d3092378e1dd225e7c8171f345e91b354498", "filename": "tests/ui/redundant_slicing.fixed", "status": "added", "additions": 46, "deletions": 0, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/fd495a0654611a6d784bae4698e5838b121e8004/tests%2Fui%2Fredundant_slicing.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/fd495a0654611a6d784bae4698e5838b121e8004/tests%2Fui%2Fredundant_slicing.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fredundant_slicing.fixed?ref=fd495a0654611a6d784bae4698e5838b121e8004", "patch": "@@ -0,0 +1,46 @@\n+// run-rustfix\n+\n+#![allow(unused, clippy::deref_by_slicing)]\n+#![warn(clippy::redundant_slicing)]\n+\n+use std::io::Read;\n+\n+fn main() {\n+    let slice: &[u32] = &[0];\n+    let _ = slice; // Redundant slice\n+\n+    let v = vec![0];\n+    let _ = &v[..]; // Ok, results in `&[_]`\n+    let _ = (&*v); // Outer borrow is redundant\n+\n+    static S: &[u8] = &[0, 1, 2];\n+    let _ = &mut &S[..]; // Ok, re-borrows slice\n+\n+    let mut vec = vec![0];\n+    let mut_slice = &mut vec[..]; // Ok, results in `&mut [_]`\n+    let _ = &mut mut_slice[..]; // Ok, re-borrows slice\n+\n+    let ref_vec = &vec;\n+    let _ = &ref_vec[..]; // Ok, results in `&[_]`\n+\n+    macro_rules! m {\n+        ($e:expr) => {\n+            $e\n+        };\n+    }\n+    let _ = slice;\n+\n+    macro_rules! m2 {\n+        ($e:expr) => {\n+            &$e[..]\n+        };\n+    }\n+    let _ = m2!(slice); // Don't lint in a macro\n+\n+    let slice_ref = &slice;\n+    let _ = &slice_ref[..]; // Ok, derefs slice\n+\n+    // Issue #7972\n+    let bytes: &[u8] = &[];\n+    let _ = (&bytes[..]).read_to_end(&mut vec![]).unwrap(); // Ok, re-borrows slice\n+}"}, {"sha": "51c16dd8d65a2b67fb33256d564259193790dafd", "filename": "tests/ui/redundant_slicing.rs", "status": "modified", "additions": 21, "deletions": 7, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/fd495a0654611a6d784bae4698e5838b121e8004/tests%2Fui%2Fredundant_slicing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd495a0654611a6d784bae4698e5838b121e8004/tests%2Fui%2Fredundant_slicing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fredundant_slicing.rs?ref=fd495a0654611a6d784bae4698e5838b121e8004", "patch": "@@ -1,20 +1,27 @@\n-#![allow(unused)]\n+// run-rustfix\n+\n+#![allow(unused, clippy::deref_by_slicing)]\n #![warn(clippy::redundant_slicing)]\n \n+use std::io::Read;\n+\n fn main() {\n     let slice: &[u32] = &[0];\n-    let _ = &slice[..];\n+    let _ = &slice[..]; // Redundant slice\n \n     let v = vec![0];\n-    let _ = &v[..]; // Changes the type\n-    let _ = &(&v[..])[..]; // Outer borrow is redundant\n+    let _ = &v[..]; // Ok, results in `&[_]`\n+    let _ = &(&*v)[..]; // Outer borrow is redundant\n \n     static S: &[u8] = &[0, 1, 2];\n-    let err = &mut &S[..]; // Should reborrow instead of slice\n+    let _ = &mut &S[..]; // Ok, re-borrows slice\n \n     let mut vec = vec![0];\n-    let mut_slice = &mut *vec;\n-    let _ = &mut mut_slice[..]; // Should reborrow instead of slice\n+    let mut_slice = &mut vec[..]; // Ok, results in `&mut [_]`\n+    let _ = &mut mut_slice[..]; // Ok, re-borrows slice\n+\n+    let ref_vec = &vec;\n+    let _ = &ref_vec[..]; // Ok, results in `&[_]`\n \n     macro_rules! m {\n         ($e:expr) => {\n@@ -29,4 +36,11 @@ fn main() {\n         };\n     }\n     let _ = m2!(slice); // Don't lint in a macro\n+\n+    let slice_ref = &slice;\n+    let _ = &slice_ref[..]; // Ok, derefs slice\n+\n+    // Issue #7972\n+    let bytes: &[u8] = &[];\n+    let _ = (&bytes[..]).read_to_end(&mut vec![]).unwrap(); // Ok, re-borrows slice\n }"}, {"sha": "82367143c07fa40f395768d038a734e0bfeaa619", "filename": "tests/ui/redundant_slicing.stderr", "status": "modified", "additions": 7, "deletions": 19, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/fd495a0654611a6d784bae4698e5838b121e8004/tests%2Fui%2Fredundant_slicing.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/fd495a0654611a6d784bae4698e5838b121e8004/tests%2Fui%2Fredundant_slicing.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fredundant_slicing.stderr?ref=fd495a0654611a6d784bae4698e5838b121e8004", "patch": "@@ -1,34 +1,22 @@\n error: redundant slicing of the whole range\n-  --> $DIR/redundant_slicing.rs:6:13\n+  --> $DIR/redundant_slicing.rs:10:13\n    |\n-LL |     let _ = &slice[..];\n+LL |     let _ = &slice[..]; // Redundant slice\n    |             ^^^^^^^^^^ help: use the original value instead: `slice`\n    |\n    = note: `-D clippy::redundant-slicing` implied by `-D warnings`\n \n error: redundant slicing of the whole range\n-  --> $DIR/redundant_slicing.rs:10:13\n-   |\n-LL |     let _ = &(&v[..])[..]; // Outer borrow is redundant\n-   |             ^^^^^^^^^^^^^ help: use the original value instead: `(&v[..])`\n-\n-error: redundant slicing of the whole range\n-  --> $DIR/redundant_slicing.rs:13:20\n-   |\n-LL |     let err = &mut &S[..]; // Should reborrow instead of slice\n-   |                    ^^^^^^ help: reborrow the original value instead: `&*S`\n-\n-error: redundant slicing of the whole range\n-  --> $DIR/redundant_slicing.rs:17:13\n+  --> $DIR/redundant_slicing.rs:14:13\n    |\n-LL |     let _ = &mut mut_slice[..]; // Should reborrow instead of slice\n-   |             ^^^^^^^^^^^^^^^^^^ help: reborrow the original value instead: `&mut *mut_slice`\n+LL |     let _ = &(&*v)[..]; // Outer borrow is redundant\n+   |             ^^^^^^^^^^ help: use the original value instead: `(&*v)`\n \n error: redundant slicing of the whole range\n-  --> $DIR/redundant_slicing.rs:24:13\n+  --> $DIR/redundant_slicing.rs:31:13\n    |\n LL |     let _ = &m!(slice)[..];\n    |             ^^^^^^^^^^^^^^ help: use the original value instead: `slice`\n \n-error: aborting due to 5 previous errors\n+error: aborting due to 3 previous errors\n "}, {"sha": "24a0c812291982371e67496695f2eb1b8275abe5", "filename": "tests/ui/rename.fixed", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fd495a0654611a6d784bae4698e5838b121e8004/tests%2Fui%2Frename.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/fd495a0654611a6d784bae4698e5838b121e8004/tests%2Fui%2Frename.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Frename.fixed?ref=fd495a0654611a6d784bae4698e5838b121e8004", "patch": "@@ -20,6 +20,7 @@\n #![allow(clippy::match_result_ok)]\n #![allow(clippy::disallowed_types)]\n #![allow(clippy::disallowed_methods)]\n+#![allow(clippy::recursive_format_impl)]\n // uplifted lints\n #![allow(invalid_value)]\n #![allow(array_into_iter)]\n@@ -55,6 +56,7 @@\n #![warn(clippy::disallowed_types)]\n #![warn(clippy::disallowed_methods)]\n #![warn(clippy::needless_borrow)]\n+#![warn(clippy::recursive_format_impl)]\n // uplifted lints\n #![warn(invalid_value)]\n #![warn(array_into_iter)]"}, {"sha": "ea64234c680d37f5ef8b7951100723a5a33a3054", "filename": "tests/ui/rename.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fd495a0654611a6d784bae4698e5838b121e8004/tests%2Fui%2Frename.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd495a0654611a6d784bae4698e5838b121e8004/tests%2Fui%2Frename.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Frename.rs?ref=fd495a0654611a6d784bae4698e5838b121e8004", "patch": "@@ -20,6 +20,7 @@\n #![allow(clippy::match_result_ok)]\n #![allow(clippy::disallowed_types)]\n #![allow(clippy::disallowed_methods)]\n+#![allow(clippy::recursive_format_impl)]\n // uplifted lints\n #![allow(invalid_value)]\n #![allow(array_into_iter)]\n@@ -55,6 +56,7 @@\n #![warn(clippy::disallowed_type)]\n #![warn(clippy::disallowed_method)]\n #![warn(clippy::ref_in_deref)]\n+#![warn(clippy::to_string_in_display)]\n // uplifted lints\n #![warn(clippy::invalid_ref)]\n #![warn(clippy::into_iter_on_array)]"}, {"sha": "8b132a7838470cbd90aba6f1e1c36be73274e8bc", "filename": "tests/ui/rename.stderr", "status": "modified", "additions": 40, "deletions": 34, "changes": 74, "blob_url": "https://github.com/rust-lang/rust/blob/fd495a0654611a6d784bae4698e5838b121e8004/tests%2Fui%2Frename.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/fd495a0654611a6d784bae4698e5838b121e8004/tests%2Fui%2Frename.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Frename.stderr?ref=fd495a0654611a6d784bae4698e5838b121e8004", "patch": "@@ -1,202 +1,208 @@\n error: lint `clippy::stutter` has been renamed to `clippy::module_name_repetitions`\n-  --> $DIR/rename.rs:34:9\n+  --> $DIR/rename.rs:35:9\n    |\n LL | #![warn(clippy::stutter)]\n    |         ^^^^^^^^^^^^^^^ help: use the new name: `clippy::module_name_repetitions`\n    |\n    = note: `-D renamed-and-removed-lints` implied by `-D warnings`\n \n error: lint `clippy::new_without_default_derive` has been renamed to `clippy::new_without_default`\n-  --> $DIR/rename.rs:35:9\n+  --> $DIR/rename.rs:36:9\n    |\n LL | #![warn(clippy::new_without_default_derive)]\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: use the new name: `clippy::new_without_default`\n \n error: lint `clippy::const_static_lifetime` has been renamed to `clippy::redundant_static_lifetimes`\n-  --> $DIR/rename.rs:36:9\n+  --> $DIR/rename.rs:37:9\n    |\n LL | #![warn(clippy::const_static_lifetime)]\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: use the new name: `clippy::redundant_static_lifetimes`\n \n error: lint `clippy::cyclomatic_complexity` has been renamed to `clippy::cognitive_complexity`\n-  --> $DIR/rename.rs:37:9\n+  --> $DIR/rename.rs:38:9\n    |\n LL | #![warn(clippy::cyclomatic_complexity)]\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: use the new name: `clippy::cognitive_complexity`\n \n error: lint `clippy::option_and_then_some` has been renamed to `clippy::bind_instead_of_map`\n-  --> $DIR/rename.rs:38:9\n+  --> $DIR/rename.rs:39:9\n    |\n LL | #![warn(clippy::option_and_then_some)]\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: use the new name: `clippy::bind_instead_of_map`\n \n error: lint `clippy::box_vec` has been renamed to `clippy::box_collection`\n-  --> $DIR/rename.rs:39:9\n+  --> $DIR/rename.rs:40:9\n    |\n LL | #![warn(clippy::box_vec)]\n    |         ^^^^^^^^^^^^^^^ help: use the new name: `clippy::box_collection`\n \n error: lint `clippy::block_in_if_condition_expr` has been renamed to `clippy::blocks_in_if_conditions`\n-  --> $DIR/rename.rs:40:9\n+  --> $DIR/rename.rs:41:9\n    |\n LL | #![warn(clippy::block_in_if_condition_expr)]\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: use the new name: `clippy::blocks_in_if_conditions`\n \n error: lint `clippy::block_in_if_condition_stmt` has been renamed to `clippy::blocks_in_if_conditions`\n-  --> $DIR/rename.rs:41:9\n+  --> $DIR/rename.rs:42:9\n    |\n LL | #![warn(clippy::block_in_if_condition_stmt)]\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: use the new name: `clippy::blocks_in_if_conditions`\n \n error: lint `clippy::option_map_unwrap_or` has been renamed to `clippy::map_unwrap_or`\n-  --> $DIR/rename.rs:42:9\n+  --> $DIR/rename.rs:43:9\n    |\n LL | #![warn(clippy::option_map_unwrap_or)]\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: use the new name: `clippy::map_unwrap_or`\n \n error: lint `clippy::option_map_unwrap_or_else` has been renamed to `clippy::map_unwrap_or`\n-  --> $DIR/rename.rs:43:9\n+  --> $DIR/rename.rs:44:9\n    |\n LL | #![warn(clippy::option_map_unwrap_or_else)]\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: use the new name: `clippy::map_unwrap_or`\n \n error: lint `clippy::result_map_unwrap_or_else` has been renamed to `clippy::map_unwrap_or`\n-  --> $DIR/rename.rs:44:9\n+  --> $DIR/rename.rs:45:9\n    |\n LL | #![warn(clippy::result_map_unwrap_or_else)]\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: use the new name: `clippy::map_unwrap_or`\n \n error: lint `clippy::option_unwrap_used` has been renamed to `clippy::unwrap_used`\n-  --> $DIR/rename.rs:45:9\n+  --> $DIR/rename.rs:46:9\n    |\n LL | #![warn(clippy::option_unwrap_used)]\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^ help: use the new name: `clippy::unwrap_used`\n \n error: lint `clippy::result_unwrap_used` has been renamed to `clippy::unwrap_used`\n-  --> $DIR/rename.rs:46:9\n+  --> $DIR/rename.rs:47:9\n    |\n LL | #![warn(clippy::result_unwrap_used)]\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^ help: use the new name: `clippy::unwrap_used`\n \n error: lint `clippy::option_expect_used` has been renamed to `clippy::expect_used`\n-  --> $DIR/rename.rs:47:9\n+  --> $DIR/rename.rs:48:9\n    |\n LL | #![warn(clippy::option_expect_used)]\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^ help: use the new name: `clippy::expect_used`\n \n error: lint `clippy::result_expect_used` has been renamed to `clippy::expect_used`\n-  --> $DIR/rename.rs:48:9\n+  --> $DIR/rename.rs:49:9\n    |\n LL | #![warn(clippy::result_expect_used)]\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^ help: use the new name: `clippy::expect_used`\n \n error: lint `clippy::for_loop_over_option` has been renamed to `clippy::for_loops_over_fallibles`\n-  --> $DIR/rename.rs:49:9\n+  --> $DIR/rename.rs:50:9\n    |\n LL | #![warn(clippy::for_loop_over_option)]\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: use the new name: `clippy::for_loops_over_fallibles`\n \n error: lint `clippy::for_loop_over_result` has been renamed to `clippy::for_loops_over_fallibles`\n-  --> $DIR/rename.rs:50:9\n+  --> $DIR/rename.rs:51:9\n    |\n LL | #![warn(clippy::for_loop_over_result)]\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: use the new name: `clippy::for_loops_over_fallibles`\n \n error: lint `clippy::identity_conversion` has been renamed to `clippy::useless_conversion`\n-  --> $DIR/rename.rs:51:9\n+  --> $DIR/rename.rs:52:9\n    |\n LL | #![warn(clippy::identity_conversion)]\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: use the new name: `clippy::useless_conversion`\n \n error: lint `clippy::zero_width_space` has been renamed to `clippy::invisible_characters`\n-  --> $DIR/rename.rs:52:9\n+  --> $DIR/rename.rs:53:9\n    |\n LL | #![warn(clippy::zero_width_space)]\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^ help: use the new name: `clippy::invisible_characters`\n \n error: lint `clippy::single_char_push_str` has been renamed to `clippy::single_char_add_str`\n-  --> $DIR/rename.rs:53:9\n+  --> $DIR/rename.rs:54:9\n    |\n LL | #![warn(clippy::single_char_push_str)]\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: use the new name: `clippy::single_char_add_str`\n \n error: lint `clippy::if_let_some_result` has been renamed to `clippy::match_result_ok`\n-  --> $DIR/rename.rs:54:9\n+  --> $DIR/rename.rs:55:9\n    |\n LL | #![warn(clippy::if_let_some_result)]\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^ help: use the new name: `clippy::match_result_ok`\n \n error: lint `clippy::disallowed_type` has been renamed to `clippy::disallowed_types`\n-  --> $DIR/rename.rs:55:9\n+  --> $DIR/rename.rs:56:9\n    |\n LL | #![warn(clippy::disallowed_type)]\n    |         ^^^^^^^^^^^^^^^^^^^^^^^ help: use the new name: `clippy::disallowed_types`\n \n error: lint `clippy::disallowed_method` has been renamed to `clippy::disallowed_methods`\n-  --> $DIR/rename.rs:56:9\n+  --> $DIR/rename.rs:57:9\n    |\n LL | #![warn(clippy::disallowed_method)]\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^ help: use the new name: `clippy::disallowed_methods`\n \n error: lint `clippy::ref_in_deref` has been renamed to `clippy::needless_borrow`\n-  --> $DIR/rename.rs:57:9\n+  --> $DIR/rename.rs:58:9\n    |\n LL | #![warn(clippy::ref_in_deref)]\n    |         ^^^^^^^^^^^^^^^^^^^^ help: use the new name: `clippy::needless_borrow`\n \n-error: lint `clippy::invalid_ref` has been renamed to `invalid_value`\n+error: lint `clippy::to_string_in_display` has been renamed to `clippy::recursive_format_impl`\n   --> $DIR/rename.rs:59:9\n    |\n+LL | #![warn(clippy::to_string_in_display)]\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: use the new name: `clippy::recursive_format_impl`\n+\n+error: lint `clippy::invalid_ref` has been renamed to `invalid_value`\n+  --> $DIR/rename.rs:61:9\n+   |\n LL | #![warn(clippy::invalid_ref)]\n    |         ^^^^^^^^^^^^^^^^^^^ help: use the new name: `invalid_value`\n \n error: lint `clippy::into_iter_on_array` has been renamed to `array_into_iter`\n-  --> $DIR/rename.rs:60:9\n+  --> $DIR/rename.rs:62:9\n    |\n LL | #![warn(clippy::into_iter_on_array)]\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^ help: use the new name: `array_into_iter`\n \n error: lint `clippy::unused_label` has been renamed to `unused_labels`\n-  --> $DIR/rename.rs:61:9\n+  --> $DIR/rename.rs:63:9\n    |\n LL | #![warn(clippy::unused_label)]\n    |         ^^^^^^^^^^^^^^^^^^^^ help: use the new name: `unused_labels`\n \n error: lint `clippy::drop_bounds` has been renamed to `drop_bounds`\n-  --> $DIR/rename.rs:62:9\n+  --> $DIR/rename.rs:64:9\n    |\n LL | #![warn(clippy::drop_bounds)]\n    |         ^^^^^^^^^^^^^^^^^^^ help: use the new name: `drop_bounds`\n \n error: lint `clippy::temporary_cstring_as_ptr` has been renamed to `temporary_cstring_as_ptr`\n-  --> $DIR/rename.rs:63:9\n+  --> $DIR/rename.rs:65:9\n    |\n LL | #![warn(clippy::temporary_cstring_as_ptr)]\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: use the new name: `temporary_cstring_as_ptr`\n \n error: lint `clippy::panic_params` has been renamed to `non_fmt_panics`\n-  --> $DIR/rename.rs:64:9\n+  --> $DIR/rename.rs:66:9\n    |\n LL | #![warn(clippy::panic_params)]\n    |         ^^^^^^^^^^^^^^^^^^^^ help: use the new name: `non_fmt_panics`\n \n error: lint `clippy::unknown_clippy_lints` has been renamed to `unknown_lints`\n-  --> $DIR/rename.rs:65:9\n+  --> $DIR/rename.rs:67:9\n    |\n LL | #![warn(clippy::unknown_clippy_lints)]\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: use the new name: `unknown_lints`\n \n error: lint `clippy::invalid_atomic_ordering` has been renamed to `invalid_atomic_ordering`\n-  --> $DIR/rename.rs:66:9\n+  --> $DIR/rename.rs:68:9\n    |\n LL | #![warn(clippy::invalid_atomic_ordering)]\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: use the new name: `invalid_atomic_ordering`\n \n error: lint `clippy::mem_discriminant_non_enum` has been renamed to `enum_intrinsics_non_enums`\n-  --> $DIR/rename.rs:67:9\n+  --> $DIR/rename.rs:69:9\n    |\n LL | #![warn(clippy::mem_discriminant_non_enum)]\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: use the new name: `enum_intrinsics_non_enums`\n \n-error: aborting due to 33 previous errors\n+error: aborting due to 34 previous errors\n "}, {"sha": "dd148edf5292d0c0e130d75f4736abbbce9a8404", "filename": "tests/ui/single_match.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/fd495a0654611a6d784bae4698e5838b121e8004/tests%2Fui%2Fsingle_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd495a0654611a6d784bae4698e5838b121e8004/tests%2Fui%2Fsingle_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fsingle_match.rs?ref=fd495a0654611a6d784bae4698e5838b121e8004", "patch": "@@ -234,4 +234,12 @@ macro_rules! single_match {\n \n fn main() {\n     single_match!(5);\n+\n+    // Don't lint\n+    let _ = match Some(0) {\n+        #[cfg(feature = \"foo\")]\n+        Some(10) => 11,\n+        Some(x) => x,\n+        _ => 0,\n+    };\n }"}, {"sha": "ac4c1bc65979fb5f38661d3f8ac37487ef802e89", "filename": "tests/ui/temporary_assignment.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/fd495a0654611a6d784bae4698e5838b121e8004/tests%2Fui%2Ftemporary_assignment.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd495a0654611a6d784bae4698e5838b121e8004/tests%2Fui%2Ftemporary_assignment.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ftemporary_assignment.rs?ref=fd495a0654611a6d784bae4698e5838b121e8004", "patch": "@@ -1,5 +1,4 @@\n #![warn(clippy::temporary_assignment)]\n-#![allow(const_item_mutation)]\n \n use std::ops::{Deref, DerefMut};\n "}, {"sha": "7d79901a28d1be70a17f22f33806278c09b0e340", "filename": "tests/ui/temporary_assignment.stderr", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/fd495a0654611a6d784bae4698e5838b121e8004/tests%2Fui%2Ftemporary_assignment.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/fd495a0654611a6d784bae4698e5838b121e8004/tests%2Fui%2Ftemporary_assignment.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ftemporary_assignment.stderr?ref=fd495a0654611a6d784bae4698e5838b121e8004", "patch": "@@ -1,13 +1,13 @@\n error: assignment to temporary\n-  --> $DIR/temporary_assignment.rs:48:5\n+  --> $DIR/temporary_assignment.rs:47:5\n    |\n LL |     Struct { field: 0 }.field = 1;\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n    = note: `-D clippy::temporary-assignment` implied by `-D warnings`\n \n error: assignment to temporary\n-  --> $DIR/temporary_assignment.rs:49:5\n+  --> $DIR/temporary_assignment.rs:48:5\n    |\n LL | /     MultiStruct {\n LL | |         structure: Struct { field: 0 },\n@@ -17,13 +17,13 @@ LL | |     .field = 1;\n    | |______________^\n \n error: assignment to temporary\n-  --> $DIR/temporary_assignment.rs:54:5\n+  --> $DIR/temporary_assignment.rs:53:5\n    |\n LL |     ArrayStruct { array: [0] }.array[0] = 1;\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: assignment to temporary\n-  --> $DIR/temporary_assignment.rs:55:5\n+  --> $DIR/temporary_assignment.rs:54:5\n    |\n LL |     (0, 0).0 = 1;\n    |     ^^^^^^^^^^^^"}, {"sha": "3ccdcd1117b5a5d47dcf87f95b30acbdba631e13", "filename": "tests/ui/to_string_in_display.rs", "status": "removed", "additions": 0, "deletions": 69, "changes": 69, "blob_url": "https://github.com/rust-lang/rust/blob/e390e6c46914b54ea2ffa901f3c6b046b9a7b7d4/tests%2Fui%2Fto_string_in_display.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e390e6c46914b54ea2ffa901f3c6b046b9a7b7d4/tests%2Fui%2Fto_string_in_display.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fto_string_in_display.rs?ref=e390e6c46914b54ea2ffa901f3c6b046b9a7b7d4", "patch": "@@ -1,69 +0,0 @@\n-#![warn(clippy::to_string_in_display)]\n-#![allow(clippy::inherent_to_string_shadow_display, clippy::to_string_in_format_args)]\n-\n-use std::fmt;\n-\n-struct A;\n-impl A {\n-    fn fmt(&self) {\n-        self.to_string();\n-    }\n-}\n-\n-trait B {\n-    fn fmt(&self) {}\n-}\n-\n-impl B for A {\n-    fn fmt(&self) {\n-        self.to_string();\n-    }\n-}\n-\n-impl fmt::Display for A {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        write!(f, \"{}\", self.to_string())\n-    }\n-}\n-\n-fn fmt(a: A) {\n-    a.to_string();\n-}\n-\n-struct C;\n-\n-impl C {\n-    fn to_string(&self) -> String {\n-        String::from(\"I am C\")\n-    }\n-}\n-\n-impl fmt::Display for C {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        write!(f, \"{}\", self.to_string())\n-    }\n-}\n-\n-enum D {\n-    E(String),\n-    F,\n-}\n-\n-impl std::fmt::Display for D {\n-    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n-        match &self {\n-            Self::E(string) => write!(f, \"E {}\", string.to_string()),\n-            Self::F => write!(f, \"F\"),\n-        }\n-    }\n-}\n-\n-fn main() {\n-    let a = A;\n-    a.to_string();\n-    a.fmt();\n-    fmt(a);\n-\n-    let c = C;\n-    c.to_string();\n-}"}, {"sha": "80189ca1f0aeeedc70fb70c0ffe4b75d509f12c3", "filename": "tests/ui/to_string_in_display.stderr", "status": "removed", "additions": 0, "deletions": 19, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/e390e6c46914b54ea2ffa901f3c6b046b9a7b7d4/tests%2Fui%2Fto_string_in_display.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e390e6c46914b54ea2ffa901f3c6b046b9a7b7d4/tests%2Fui%2Fto_string_in_display.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fto_string_in_display.stderr?ref=e390e6c46914b54ea2ffa901f3c6b046b9a7b7d4", "patch": "@@ -1,19 +0,0 @@\n-error: using `to_string` in `fmt::Display` implementation might lead to infinite recursion\n-  --> $DIR/to_string_in_display.rs:25:25\n-   |\n-LL |         write!(f, \"{}\", self.to_string())\n-   |                         ^^^^^^^^^^^^^^^^\n-   |\n-   = note: `-D clippy::to-string-in-display` implied by `-D warnings`\n-\n-error: unnecessary use of `to_string`\n-  --> $DIR/to_string_in_display.rs:55:50\n-   |\n-LL |             Self::E(string) => write!(f, \"E {}\", string.to_string()),\n-   |                                                  ^^^^^^^^^^^^^^^^^^\n-   |\n-   = note: `-D clippy::unnecessary-to-owned` implied by `-D warnings`\n-   = note: this error originates in the macro `$crate::format_args` (in Nightly builds, run with -Z macro-backtrace for more info)\n-\n-error: aborting due to 2 previous errors\n-"}, {"sha": "b163d6056343d5b34e2e57f520c083a629db24ed", "filename": "tests/ui/transmute_undefined_repr.rs", "status": "modified", "additions": 66, "deletions": 19, "changes": 85, "blob_url": "https://github.com/rust-lang/rust/blob/fd495a0654611a6d784bae4698e5838b121e8004/tests%2Fui%2Ftransmute_undefined_repr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd495a0654611a6d784bae4698e5838b121e8004/tests%2Fui%2Ftransmute_undefined_repr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ftransmute_undefined_repr.rs?ref=fd495a0654611a6d784bae4698e5838b121e8004", "patch": "@@ -1,5 +1,8 @@\n #![warn(clippy::transmute_undefined_repr)]\n-#![allow(clippy::unit_arg)]\n+#![allow(clippy::unit_arg, clippy::transmute_ptr_to_ref)]\n+\n+use core::ffi::c_void;\n+use core::mem::{size_of, transmute};\n \n fn value<T>() -> T {\n     unimplemented!()\n@@ -14,31 +17,75 @@ struct Ty2C<T, U>(T, U);\n \n fn main() {\n     unsafe {\n-        let _: () = core::mem::transmute(value::<Empty>());\n-        let _: Empty = core::mem::transmute(value::<()>());\n+        let _: () = transmute(value::<Empty>());\n+        let _: Empty = transmute(value::<()>());\n+\n+        let _: Ty<u32> = transmute(value::<u32>());\n+        let _: Ty<u32> = transmute(value::<u32>());\n+\n+        let _: Ty2C<u32, i32> = transmute(value::<Ty2<u32, i32>>()); // Lint, Ty2 is unordered\n+        let _: Ty2<u32, i32> = transmute(value::<Ty2C<u32, i32>>()); // Lint, Ty2 is unordered\n+\n+        let _: Ty2<u32, i32> = transmute(value::<Ty<Ty2<u32, i32>>>()); // Ok, Ty2 types are the same\n+        let _: Ty<Ty2<u32, i32>> = transmute(value::<Ty2<u32, i32>>()); // Ok, Ty2 types are the same\n+\n+        let _: Ty2<u32, f32> = transmute(value::<Ty<Ty2<u32, i32>>>()); // Lint, different Ty2 instances\n+        let _: Ty<Ty2<u32, i32>> = transmute(value::<Ty2<u32, f32>>()); // Lint, different Ty2 instances\n+\n+        let _: Ty<&()> = transmute(value::<&()>());\n+        let _: &() = transmute(value::<Ty<&()>>());\n+\n+        let _: &Ty2<u32, f32> = transmute(value::<Ty<&Ty2<u32, i32>>>()); // Lint, different Ty2 instances\n+        let _: Ty<&Ty2<u32, i32>> = transmute(value::<&Ty2<u32, f32>>()); // Lint, different Ty2 instances\n+\n+        let _: Ty<usize> = transmute(value::<&Ty2<u32, i32>>()); // Ok, pointer to usize conversion\n+        let _: &Ty2<u32, i32> = transmute(value::<Ty<usize>>()); // Ok, pointer to usize conversion\n+\n+        let _: Ty<[u8; 8]> = transmute(value::<Ty2<u32, i32>>()); // Ok, transmute to byte array\n+        let _: Ty2<u32, i32> = transmute(value::<Ty<[u8; 8]>>()); // Ok, transmute from byte array\n+\n+        // issue #8417\n+        let _: Ty2C<Ty2<u32, i32>, ()> = transmute(value::<Ty2<u32, i32>>()); // Ok, Ty2 types are the same\n+        let _: Ty2<u32, i32> = transmute(value::<Ty2C<Ty2<u32, i32>, ()>>()); // Ok, Ty2 types are the same\n+\n+        let _: &'static mut Ty2<u32, u32> = transmute(value::<Box<Ty2<u32, u32>>>()); // Ok, Ty2 types are the same\n+        let _: Box<Ty2<u32, u32>> = transmute(value::<&'static mut Ty2<u32, u32>>()); // Ok, Ty2 types are the same\n+        let _: *mut Ty2<u32, u32> = transmute(value::<Box<Ty2<u32, u32>>>()); // Ok, Ty2 types are the same\n+        let _: Box<Ty2<u32, u32>> = transmute(value::<*mut Ty2<u32, u32>>()); // Ok, Ty2 types are the same\n+\n+        let _: &'static mut Ty2<u32, f32> = transmute(value::<Box<Ty2<u32, u32>>>()); // Lint, different Ty2 instances\n+        let _: Box<Ty2<u32, u32>> = transmute(value::<&'static mut Ty2<u32, f32>>()); // Lint, different Ty2 instances\n+\n+        let _: *const () = transmute(value::<Ty<&Ty2<u32, f32>>>()); // Ok, type erasure\n+        let _: Ty<&Ty2<u32, f32>> = transmute(value::<*const ()>()); // Ok, reverse type erasure\n \n-        let _: Ty<u32> = core::mem::transmute(value::<u32>());\n-        let _: Ty<u32> = core::mem::transmute(value::<u32>());\n+        let _: *const c_void = transmute(value::<Ty<&Ty2<u32, f32>>>()); // Ok, type erasure\n+        let _: Ty<&Ty2<u32, f32>> = transmute(value::<*const c_void>()); // Ok, reverse type erasure\n \n-        let _: Ty2C<u32, i32> = core::mem::transmute(value::<Ty2<u32, i32>>()); // Lint, Ty2 is unordered\n-        let _: Ty2<u32, i32> = core::mem::transmute(value::<Ty2C<u32, i32>>()); // Lint, Ty2 is unordered\n+        enum Erase {}\n+        let _: *const Erase = transmute(value::<Ty<&Ty2<u32, f32>>>()); // Ok, type erasure\n+        let _: Ty<&Ty2<u32, f32>> = transmute(value::<*const Erase>()); // Ok, reverse type erasure\n \n-        let _: Ty2<u32, i32> = core::mem::transmute(value::<Ty<Ty2<u32, i32>>>()); // Ok, Ty2 types are the same\n-        let _: Ty<Ty2<u32, i32>> = core::mem::transmute(value::<Ty2<u32, i32>>()); // Ok, Ty2 types are the same\n+        struct Erase2(\n+            [u8; 0],\n+            core::marker::PhantomData<(*mut u8, core::marker::PhantomPinned)>,\n+        );\n+        let _: *const Erase2 = transmute(value::<Ty<&Ty2<u32, f32>>>()); // Ok, type erasure\n+        let _: Ty<&Ty2<u32, f32>> = transmute(value::<*const Erase2>()); // Ok, reverse type erasure\n \n-        let _: Ty2<u32, f32> = core::mem::transmute(value::<Ty<Ty2<u32, i32>>>()); // Lint, different Ty2 instances\n-        let _: Ty<Ty2<u32, i32>> = core::mem::transmute(value::<Ty2<u32, f32>>()); // Lint, different Ty2 instances\n+        let _: *const () = transmute(value::<&&[u8]>()); // Ok, type erasure\n+        let _: &&[u8] = transmute(value::<*const ()>()); // Ok, reverse type erasure\n \n-        let _: Ty<&()> = core::mem::transmute(value::<&()>());\n-        let _: &() = core::mem::transmute(value::<Ty<&()>>());\n+        let _: *mut c_void = transmute(value::<&mut &[u8]>()); // Ok, type erasure\n+        let _: &mut &[u8] = transmute(value::<*mut c_void>()); // Ok, reverse type erasure\n \n-        let _: &Ty2<u32, f32> = core::mem::transmute(value::<Ty<&Ty2<u32, i32>>>()); // Lint, different Ty2 instances\n-        let _: Ty<&Ty2<u32, i32>> = core::mem::transmute(value::<&Ty2<u32, f32>>()); // Lint, different Ty2 instances\n+        let _: [u8; size_of::<&[u8]>()] = transmute(value::<&[u8]>()); // Ok, transmute to byte array\n+        let _: &[u8] = transmute(value::<[u8; size_of::<&[u8]>()]>()); // Ok, transmute from byte array\n \n-        let _: Ty<usize> = core::mem::transmute(value::<&Ty2<u32, i32>>()); // Ok, pointer to usize conversion\n-        let _: &Ty2<u32, i32> = core::mem::transmute(value::<Ty<usize>>()); // Ok, pointer to usize conversion\n+        let _: [usize; 2] = transmute(value::<&[u8]>()); // Ok, transmute to int array\n+        let _: &[u8] = transmute(value::<[usize; 2]>()); // Ok, transmute from int array\n \n-        let _: Ty<[u8; 8]> = core::mem::transmute(value::<Ty2<u32, i32>>()); // Ok, transmute to byte array\n-        let _: Ty2<u32, i32> = core::mem::transmute(value::<Ty<[u8; 8]>>()); // Ok, transmute from byte array\n+        let _: *const [u8] = transmute(value::<Box<[u8]>>()); // Ok\n+        let _: Box<[u8]> = transmute(value::<*mut [u8]>()); // Ok\n     }\n }"}, {"sha": "42d544fc954c5b31034bb0dc2f0ace0f16ee1444", "filename": "tests/ui/transmute_undefined_repr.stderr", "status": "modified", "additions": 41, "deletions": 21, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/fd495a0654611a6d784bae4698e5838b121e8004/tests%2Fui%2Ftransmute_undefined_repr.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/fd495a0654611a6d784bae4698e5838b121e8004/tests%2Fui%2Ftransmute_undefined_repr.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ftransmute_undefined_repr.stderr?ref=fd495a0654611a6d784bae4698e5838b121e8004", "patch": "@@ -1,44 +1,64 @@\n error: transmute from `Ty2<u32, i32>` which has an undefined layout\n-  --> $DIR/transmute_undefined_repr.rs:23:33\n+  --> $DIR/transmute_undefined_repr.rs:26:33\n    |\n-LL |         let _: Ty2C<u32, i32> = core::mem::transmute(value::<Ty2<u32, i32>>()); // Lint, Ty2 is unordered\n-   |                                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+LL |         let _: Ty2C<u32, i32> = transmute(value::<Ty2<u32, i32>>()); // Lint, Ty2 is unordered\n+   |                                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n    = note: `-D clippy::transmute-undefined-repr` implied by `-D warnings`\n \n error: transmute into `Ty2<u32, i32>` which has an undefined layout\n-  --> $DIR/transmute_undefined_repr.rs:24:32\n+  --> $DIR/transmute_undefined_repr.rs:27:32\n    |\n-LL |         let _: Ty2<u32, i32> = core::mem::transmute(value::<Ty2C<u32, i32>>()); // Lint, Ty2 is unordered\n-   |                                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+LL |         let _: Ty2<u32, i32> = transmute(value::<Ty2C<u32, i32>>()); // Lint, Ty2 is unordered\n+   |                                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: transmute from `Ty<Ty2<u32, i32>>` to `Ty2<u32, f32>`, both of which have an undefined layout\n-  --> $DIR/transmute_undefined_repr.rs:29:32\n+  --> $DIR/transmute_undefined_repr.rs:32:32\n    |\n-LL |         let _: Ty2<u32, f32> = core::mem::transmute(value::<Ty<Ty2<u32, i32>>>()); // Lint, different Ty2 instances\n-   |                                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+LL |         let _: Ty2<u32, f32> = transmute(value::<Ty<Ty2<u32, i32>>>()); // Lint, different Ty2 instances\n+   |                                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n    = note: two instances of the same generic type (`Ty2`) may have different layouts\n \n error: transmute from `Ty2<u32, f32>` to `Ty<Ty2<u32, i32>>`, both of which have an undefined layout\n-  --> $DIR/transmute_undefined_repr.rs:30:36\n+  --> $DIR/transmute_undefined_repr.rs:33:36\n    |\n-LL |         let _: Ty<Ty2<u32, i32>> = core::mem::transmute(value::<Ty2<u32, f32>>()); // Lint, different Ty2 instances\n-   |                                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+LL |         let _: Ty<Ty2<u32, i32>> = transmute(value::<Ty2<u32, f32>>()); // Lint, different Ty2 instances\n+   |                                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n    = note: two instances of the same generic type (`Ty2`) may have different layouts\n \n-error: transmute to `&Ty2<u32, f32>` which has an undefined layout\n-  --> $DIR/transmute_undefined_repr.rs:35:33\n+error: transmute from `Ty<&Ty2<u32, i32>>` to `&Ty2<u32, f32>`, both of which have an undefined layout\n+  --> $DIR/transmute_undefined_repr.rs:38:33\n    |\n-LL |         let _: &Ty2<u32, f32> = core::mem::transmute(value::<Ty<&Ty2<u32, i32>>>()); // Lint, different Ty2 instances\n-   |                                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+LL |         let _: &Ty2<u32, f32> = transmute(value::<Ty<&Ty2<u32, i32>>>()); // Lint, different Ty2 instances\n+   |                                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: two instances of the same generic type (`Ty2`) may have different layouts\n+\n+error: transmute from `&Ty2<u32, f32>` to `Ty<&Ty2<u32, i32>>`, both of which have an undefined layout\n+  --> $DIR/transmute_undefined_repr.rs:39:37\n+   |\n+LL |         let _: Ty<&Ty2<u32, i32>> = transmute(value::<&Ty2<u32, f32>>()); // Lint, different Ty2 instances\n+   |                                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: two instances of the same generic type (`Ty2`) may have different layouts\n \n-error: transmute from `&Ty2<u32, f32>` which has an undefined layout\n-  --> $DIR/transmute_undefined_repr.rs:36:37\n+error: transmute from `std::boxed::Box<Ty2<u32, u32>>` to `&mut Ty2<u32, f32>`, both of which have an undefined layout\n+  --> $DIR/transmute_undefined_repr.rs:56:45\n    |\n-LL |         let _: Ty<&Ty2<u32, i32>> = core::mem::transmute(value::<&Ty2<u32, f32>>()); // Lint, different Ty2 instances\n-   |                                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+LL |         let _: &'static mut Ty2<u32, f32> = transmute(value::<Box<Ty2<u32, u32>>>()); // Lint, different Ty2 instances\n+   |                                             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: two instances of the same generic type (`Ty2`) may have different layouts\n+\n+error: transmute from `&mut Ty2<u32, f32>` to `std::boxed::Box<Ty2<u32, u32>>`, both of which have an undefined layout\n+  --> $DIR/transmute_undefined_repr.rs:57:37\n+   |\n+LL |         let _: Box<Ty2<u32, u32>> = transmute(value::<&'static mut Ty2<u32, f32>>()); // Lint, different Ty2 instances\n+   |                                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: two instances of the same generic type (`Ty2`) may have different layouts\n \n-error: aborting due to 6 previous errors\n+error: aborting due to 8 previous errors\n "}]}