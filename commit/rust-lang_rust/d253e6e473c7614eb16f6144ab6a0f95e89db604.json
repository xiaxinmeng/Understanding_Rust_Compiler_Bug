{"sha": "d253e6e473c7614eb16f6144ab6a0f95e89db604", "node_id": "C_kwDOAAsO6NoAKGQyNTNlNmU0NzNjNzYxNGViMTZmNjE0NGFiNmEwZjk1ZTg5ZGI2MDQ", "commit": {"author": {"name": "Michael Woerister", "email": "michaelwoerister@posteo", "date": "2022-01-13T17:13:54Z"}, "committer": {"name": "Michael Woerister", "email": "michaelwoerister@posteo", "date": "2022-01-24T12:41:32Z"}, "message": "[debuginfo] Fix and unify handling of fat pointers in debuginfo.", "tree": {"sha": "3ad4f50188a4c91b38d937cfc54f421dcc0f9144", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3ad4f50188a4c91b38d937cfc54f421dcc0f9144"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d253e6e473c7614eb16f6144ab6a0f95e89db604", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d253e6e473c7614eb16f6144ab6a0f95e89db604", "html_url": "https://github.com/rust-lang/rust/commit/d253e6e473c7614eb16f6144ab6a0f95e89db604", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d253e6e473c7614eb16f6144ab6a0f95e89db604/comments", "author": {"login": "michaelwoerister", "id": 1825894, "node_id": "MDQ6VXNlcjE4MjU4OTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1825894?v=4", "gravatar_id": "", "url": "https://api.github.com/users/michaelwoerister", "html_url": "https://github.com/michaelwoerister", "followers_url": "https://api.github.com/users/michaelwoerister/followers", "following_url": "https://api.github.com/users/michaelwoerister/following{/other_user}", "gists_url": "https://api.github.com/users/michaelwoerister/gists{/gist_id}", "starred_url": "https://api.github.com/users/michaelwoerister/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/michaelwoerister/subscriptions", "organizations_url": "https://api.github.com/users/michaelwoerister/orgs", "repos_url": "https://api.github.com/users/michaelwoerister/repos", "events_url": "https://api.github.com/users/michaelwoerister/events{/privacy}", "received_events_url": "https://api.github.com/users/michaelwoerister/received_events", "type": "User", "site_admin": false}, "committer": {"login": "michaelwoerister", "id": 1825894, "node_id": "MDQ6VXNlcjE4MjU4OTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1825894?v=4", "gravatar_id": "", "url": "https://api.github.com/users/michaelwoerister", "html_url": "https://github.com/michaelwoerister", "followers_url": "https://api.github.com/users/michaelwoerister/followers", "following_url": "https://api.github.com/users/michaelwoerister/following{/other_user}", "gists_url": "https://api.github.com/users/michaelwoerister/gists{/gist_id}", "starred_url": "https://api.github.com/users/michaelwoerister/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/michaelwoerister/subscriptions", "organizations_url": "https://api.github.com/users/michaelwoerister/orgs", "repos_url": "https://api.github.com/users/michaelwoerister/repos", "events_url": "https://api.github.com/users/michaelwoerister/events{/privacy}", "received_events_url": "https://api.github.com/users/michaelwoerister/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ef119d704d87a05435ea97ef4161529142313a9b", "url": "https://api.github.com/repos/rust-lang/rust/commits/ef119d704d87a05435ea97ef4161529142313a9b", "html_url": "https://github.com/rust-lang/rust/commit/ef119d704d87a05435ea97ef4161529142313a9b"}], "stats": {"total": 453, "additions": 273, "deletions": 180}, "files": [{"sha": "2f49e2087c31e61c95682318a4f325e8f15c892b", "filename": "compiler/rustc_codegen_llvm/src/debuginfo/metadata.rs", "status": "modified", "additions": 180, "deletions": 173, "changes": 353, "blob_url": "https://github.com/rust-lang/rust/blob/d253e6e473c7614eb16f6144ab6a0f95e89db604/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdebuginfo%2Fmetadata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d253e6e473c7614eb16f6144ab6a0f95e89db604/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdebuginfo%2Fmetadata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdebuginfo%2Fmetadata.rs?ref=d253e6e473c7614eb16f6144ab6a0f95e89db604", "patch": "@@ -10,6 +10,8 @@ use super::CrateDebugContext;\n \n use crate::abi;\n use crate::common::CodegenCx;\n+use crate::debuginfo::utils::fat_pointer_kind;\n+use crate::debuginfo::utils::FatPtrKind;\n use crate::llvm;\n use crate::llvm::debuginfo::{\n     DIArray, DICompositeType, DIDescriptor, DIFile, DIFlags, DILexicalBlock, DIScope, DIType,\n@@ -376,22 +378,24 @@ macro_rules! return_if_metadata_created_in_meantime {\n     };\n }\n \n-fn fixed_vec_metadata<'ll, 'tcx>(\n+/// Creates debuginfo for a fixed size array (e.g. `[u64; 123]`).\n+/// For slices (that is, \"arrays\" of unknown size) use [slice_type_metadata].\n+fn fixed_size_array_metadata<'ll, 'tcx>(\n     cx: &CodegenCx<'ll, 'tcx>,\n     unique_type_id: UniqueTypeId,\n-    array_or_slice_type: Ty<'tcx>,\n-    element_type: Ty<'tcx>,\n+    array_type: Ty<'tcx>,\n ) -> MetadataCreationResult<'ll> {\n+    let ty::Array(element_type, len) = array_type.kind() else {\n+        bug!(\"fixed_size_array_metadata() called with non-ty::Array type `{:?}`\", array_type)\n+    };\n+\n     let element_type_metadata = type_metadata(cx, element_type);\n \n     return_if_metadata_created_in_meantime!(cx, unique_type_id);\n \n-    let (size, align) = cx.size_and_align_of(array_or_slice_type);\n+    let (size, align) = cx.size_and_align_of(array_type);\n \n-    let upper_bound = match array_or_slice_type.kind() {\n-        ty::Array(_, len) => len.eval_usize(cx.tcx, ty::ParamEnv::reveal_all()) as c_longlong,\n-        _ => -1,\n-    };\n+    let upper_bound = len.eval_usize(cx.tcx, ty::ParamEnv::reveal_all()) as c_longlong;\n \n     let subrange =\n         unsafe { Some(llvm::LLVMRustDIBuilderGetOrCreateSubrange(DIB(cx), 0, upper_bound)) };\n@@ -410,55 +414,111 @@ fn fixed_vec_metadata<'ll, 'tcx>(\n     MetadataCreationResult::new(metadata, false)\n }\n \n-fn vec_slice_metadata<'ll, 'tcx>(\n+/// Creates debuginfo for built-in pointer-like things:\n+///\n+///  - ty::Ref\n+///  - ty::RawPtr\n+///  - ty::Adt in the case it's Box\n+///\n+/// At some point we might want to remove the special handling of Box\n+/// and treat it the same as other smart pointers (like Rc, Arc, ...).\n+fn pointer_or_reference_metadata<'ll, 'tcx>(\n     cx: &CodegenCx<'ll, 'tcx>,\n-    slice_ptr_type: Ty<'tcx>,\n-    element_type: Ty<'tcx>,\n+    ptr_type: Ty<'tcx>,\n+    pointee_type: Ty<'tcx>,\n     unique_type_id: UniqueTypeId,\n ) -> MetadataCreationResult<'ll> {\n-    let data_ptr_type = cx.tcx.mk_imm_ptr(element_type);\n-\n-    let data_ptr_metadata = type_metadata(cx, data_ptr_type);\n+    let pointee_type_metadata = type_metadata(cx, pointee_type);\n \n     return_if_metadata_created_in_meantime!(cx, unique_type_id);\n \n-    let slice_type_name = compute_debuginfo_type_name(cx.tcx, slice_ptr_type, true);\n-\n-    let (pointer_size, pointer_align) = cx.size_and_align_of(data_ptr_type);\n-    let (usize_size, usize_align) = cx.size_and_align_of(cx.tcx.types.usize);\n-\n-    let member_descriptions = vec![\n-        MemberDescription {\n-            name: \"data_ptr\".to_owned(),\n-            type_metadata: data_ptr_metadata,\n-            offset: Size::ZERO,\n-            size: pointer_size,\n-            align: pointer_align,\n-            flags: DIFlags::FlagZero,\n-            discriminant: None,\n-            source_info: None,\n-        },\n-        MemberDescription {\n-            name: \"length\".to_owned(),\n-            type_metadata: type_metadata(cx, cx.tcx.types.usize),\n-            offset: pointer_size,\n-            size: usize_size,\n-            align: usize_align,\n-            flags: DIFlags::FlagZero,\n-            discriminant: None,\n-            source_info: None,\n-        },\n-    ];\n+    let (thin_pointer_size, thin_pointer_align) =\n+        cx.size_and_align_of(cx.tcx.mk_imm_ptr(cx.tcx.types.unit));\n+    let ptr_type_debuginfo_name = compute_debuginfo_type_name(cx.tcx, ptr_type, true);\n \n-    let metadata = composite_type_metadata(\n-        cx,\n-        slice_ptr_type,\n-        &slice_type_name,\n-        unique_type_id,\n-        member_descriptions,\n-        NO_SCOPE_METADATA,\n-    );\n-    MetadataCreationResult::new(metadata, false)\n+    let pointer_type_metadata = match fat_pointer_kind(cx, pointee_type) {\n+        None => {\n+            // This is a thin pointer. Create a regular pointer type and give it the correct name.\n+            debug_assert_eq!(\n+                (thin_pointer_size, thin_pointer_align),\n+                cx.size_and_align_of(ptr_type)\n+            );\n+\n+            unsafe {\n+                llvm::LLVMRustDIBuilderCreatePointerType(\n+                    DIB(cx),\n+                    pointee_type_metadata,\n+                    thin_pointer_size.bits(),\n+                    thin_pointer_align.bits() as u32,\n+                    0, // Ignore DWARF address space.\n+                    ptr_type_debuginfo_name.as_ptr().cast(),\n+                    ptr_type_debuginfo_name.len(),\n+                )\n+            }\n+        }\n+        Some(fat_pointer_kind) => {\n+            let layout = cx.layout_of(ptr_type);\n+\n+            let addr_field = layout.field(cx, abi::FAT_PTR_ADDR);\n+            let extra_field = layout.field(cx, abi::FAT_PTR_EXTRA);\n+\n+            let (addr_field_name, extra_field_name) = match fat_pointer_kind {\n+                FatPtrKind::Dyn => (\"pointer\", \"vtable\"),\n+                FatPtrKind::Slice => (\"data_ptr\", \"length\"),\n+            };\n+\n+            debug_assert_eq!(abi::FAT_PTR_ADDR, 0);\n+            debug_assert_eq!(abi::FAT_PTR_EXTRA, 1);\n+\n+            // The data pointer type is a regular, thin pointer, regardless of whether this is a slice\n+            // or a trait object.\n+            let data_ptr_type_metadata = unsafe {\n+                llvm::LLVMRustDIBuilderCreatePointerType(\n+                    DIB(cx),\n+                    pointee_type_metadata,\n+                    addr_field.size.bits(),\n+                    addr_field.align.abi.bits() as u32,\n+                    0, // Ignore DWARF address space.\n+                    std::ptr::null(),\n+                    0,\n+                )\n+            };\n+\n+            let member_descriptions = vec![\n+                MemberDescription {\n+                    name: addr_field_name.into(),\n+                    type_metadata: data_ptr_type_metadata,\n+                    offset: layout.fields.offset(abi::FAT_PTR_ADDR),\n+                    size: addr_field.size,\n+                    align: addr_field.align.abi,\n+                    flags: DIFlags::FlagArtificial,\n+                    discriminant: None,\n+                    source_info: None,\n+                },\n+                MemberDescription {\n+                    name: extra_field_name.into(),\n+                    type_metadata: type_metadata(cx, extra_field.ty),\n+                    offset: layout.fields.offset(abi::FAT_PTR_EXTRA),\n+                    size: extra_field.size,\n+                    align: extra_field.align.abi,\n+                    flags: DIFlags::FlagArtificial,\n+                    discriminant: None,\n+                    source_info: None,\n+                },\n+            ];\n+\n+            composite_type_metadata(\n+                cx,\n+                ptr_type,\n+                &ptr_type_debuginfo_name,\n+                unique_type_id,\n+                member_descriptions,\n+                NO_SCOPE_METADATA,\n+            )\n+        }\n+    };\n+\n+    MetadataCreationResult { metadata: pointer_type_metadata, already_stored_in_typemap: false }\n }\n \n fn subroutine_type_metadata<'ll, 'tcx>(\n@@ -495,83 +555,57 @@ fn subroutine_type_metadata<'ll, 'tcx>(\n     )\n }\n \n-// FIXME(1563): This is all a bit of a hack because 'trait pointer' is an ill-\n-// defined concept. For the case of an actual trait pointer (i.e., `Box<Trait>`,\n-// `&Trait`), `trait_object_type` should be the whole thing (e.g, `Box<Trait>`) and\n-// `trait_type` should be the actual trait (e.g., `Trait`). Where the trait is part\n-// of a DST struct, there is no `trait_object_type` and the results of this\n-// function will be a little bit weird.\n-fn trait_pointer_metadata<'ll, 'tcx>(\n+// Create debuginfo for `dyn SomeTrait` types. Currently these are empty structs\n+// we with the correct type name (e.g. \"dyn SomeTrait<Foo, Item=u32> + Sync\").\n+fn dyn_type_metadata<'ll, 'tcx>(\n     cx: &CodegenCx<'ll, 'tcx>,\n-    trait_type: Ty<'tcx>,\n-    trait_object_type: Option<Ty<'tcx>>,\n+    dyn_type: Ty<'tcx>,\n     unique_type_id: UniqueTypeId,\n ) -> &'ll DIType {\n-    // The implementation provided here is a stub. It makes sure that the trait\n-    // type is assigned the correct name, size, namespace, and source location.\n-    // However, it does not describe the trait's methods.\n-\n-    let (containing_scope, trait_type_name) = match trait_object_type {\n-        Some(trait_object_type) => match trait_object_type.kind() {\n-            ty::Adt(def, _) => (\n-                Some(get_namespace_for_item(cx, def.did)),\n-                compute_debuginfo_type_name(cx.tcx, trait_object_type, false),\n-            ),\n-            ty::RawPtr(_) | ty::Ref(..) => {\n-                (NO_SCOPE_METADATA, compute_debuginfo_type_name(cx.tcx, trait_object_type, true))\n-            }\n-            _ => {\n-                bug!(\n-                    \"debuginfo: unexpected trait-object type in \\\n-                      trait_pointer_metadata(): {:?}\",\n-                    trait_object_type\n-                );\n-            }\n-        },\n+    if let ty::Dynamic(..) = dyn_type.kind() {\n+        let type_name = compute_debuginfo_type_name(cx.tcx, dyn_type, true);\n+        composite_type_metadata(cx, dyn_type, &type_name, unique_type_id, vec![], NO_SCOPE_METADATA)\n+    } else {\n+        bug!(\"Only ty::Dynamic is valid for dyn_type_metadata(). Found {:?} instead.\", dyn_type)\n+    }\n+}\n \n-        // No object type, use the trait type directly (no scope here since the type\n-        // will be wrapped in the dyn$ synthetic type).\n-        None => (NO_SCOPE_METADATA, compute_debuginfo_type_name(cx.tcx, trait_type, true)),\n+// Create debuginfo for `[T]` and `str`. These are unsized.\n+//\n+// Note: We currently emit just emit the debuginfo for the element type here\n+//       (i.e. `T` for slices and `u8` for `str`), so that we end up with\n+//       `*const T` for the `data_ptr` field of the corresponding fat-pointer\n+//       debuginfo of `&[T]`.\n+//\n+//       It would be preferable and more accurate if we emitted a DIArray of T\n+//       without an upper bound instead. That is, LLVM already supports emitting\n+//       debuginfo of arrays of unknown size. But GDB currently seems to end up\n+//       in an infinite loop when confronted with such a type.\n+//\n+//       As a side effect of the current encoding every instance of a type like\n+//       `struct Foo { unsized_field: [u8] }` will look like\n+//       `struct Foo { unsized_field: u8 }` in debuginfo. If the length of the\n+//       slice is zero, then accessing `unsized_field` in the debugger would\n+//       result in an out-of-bounds access.\n+fn slice_type_metadata<'ll, 'tcx>(\n+    cx: &CodegenCx<'ll, 'tcx>,\n+    slice_type: Ty<'tcx>,\n+    unique_type_id: UniqueTypeId,\n+) -> MetadataCreationResult<'ll> {\n+    let element_type = match slice_type.kind() {\n+        ty::Slice(element_type) => element_type,\n+        ty::Str => cx.tcx.types.u8,\n+        _ => {\n+            bug!(\n+                \"Only ty::Slice is valid for slice_type_metadata(). Found {:?} instead.\",\n+                slice_type\n+            )\n+        }\n     };\n \n-    let layout = cx.layout_of(cx.tcx.mk_mut_ptr(trait_type));\n-\n-    assert_eq!(abi::FAT_PTR_ADDR, 0);\n-    assert_eq!(abi::FAT_PTR_EXTRA, 1);\n-\n-    let data_ptr_field = layout.field(cx, 0);\n-    let vtable_field = layout.field(cx, 1);\n-    let member_descriptions = vec![\n-        MemberDescription {\n-            name: \"pointer\".to_owned(),\n-            type_metadata: type_metadata(cx, cx.tcx.mk_mut_ptr(cx.tcx.types.u8)),\n-            offset: layout.fields.offset(0),\n-            size: data_ptr_field.size,\n-            align: data_ptr_field.align.abi,\n-            flags: DIFlags::FlagArtificial,\n-            discriminant: None,\n-            source_info: None,\n-        },\n-        MemberDescription {\n-            name: \"vtable\".to_owned(),\n-            type_metadata: type_metadata(cx, vtable_field.ty),\n-            offset: layout.fields.offset(1),\n-            size: vtable_field.size,\n-            align: vtable_field.align.abi,\n-            flags: DIFlags::FlagArtificial,\n-            discriminant: None,\n-            source_info: None,\n-        },\n-    ];\n-\n-    composite_type_metadata(\n-        cx,\n-        trait_object_type.unwrap_or(trait_type),\n-        &trait_type_name,\n-        unique_type_id,\n-        member_descriptions,\n-        containing_scope,\n-    )\n+    let element_type_metadata = type_metadata(cx, element_type);\n+    return_if_metadata_created_in_meantime!(cx, unique_type_id);\n+    MetadataCreationResult { metadata: element_type_metadata, already_stored_in_typemap: false }\n }\n \n pub fn type_metadata<'ll, 'tcx>(cx: &CodegenCx<'ll, 'tcx>, t: Ty<'tcx>) -> &'ll DIType {\n@@ -610,49 +644,27 @@ pub fn type_metadata<'ll, 'tcx>(cx: &CodegenCx<'ll, 'tcx>, t: Ty<'tcx>) -> &'ll\n \n     debug!(\"type_metadata: {:?}\", t);\n \n-    let ptr_metadata = |ty: Ty<'tcx>| match *ty.kind() {\n-        ty::Slice(typ) => Ok(vec_slice_metadata(cx, t, typ, unique_type_id)),\n-        ty::Str => Ok(vec_slice_metadata(cx, t, cx.tcx.types.u8, unique_type_id)),\n-        ty::Dynamic(..) => Ok(MetadataCreationResult::new(\n-            trait_pointer_metadata(cx, ty, Some(t), unique_type_id),\n-            false,\n-        )),\n-        _ => {\n-            let pointee_metadata = type_metadata(cx, ty);\n-\n-            if let Some(metadata) =\n-                debug_context(cx).type_map.borrow().find_metadata_for_unique_id(unique_type_id)\n-            {\n-                return Err(metadata);\n-            }\n-\n-            Ok(MetadataCreationResult::new(pointer_type_metadata(cx, t, pointee_metadata), false))\n-        }\n-    };\n-\n     let MetadataCreationResult { metadata, already_stored_in_typemap } = match *t.kind() {\n         ty::Never | ty::Bool | ty::Char | ty::Int(_) | ty::Uint(_) | ty::Float(_) => {\n             MetadataCreationResult::new(basic_type_metadata(cx, t), false)\n         }\n         ty::Tuple(elements) if elements.is_empty() => {\n             MetadataCreationResult::new(basic_type_metadata(cx, t), false)\n         }\n-        ty::Array(typ, _) | ty::Slice(typ) => fixed_vec_metadata(cx, unique_type_id, t, typ),\n-        ty::Str => fixed_vec_metadata(cx, unique_type_id, t, cx.tcx.types.i8),\n+        ty::Array(..) => fixed_size_array_metadata(cx, unique_type_id, t),\n+        ty::Slice(_) | ty::Str => slice_type_metadata(cx, t, unique_type_id),\n         ty::Dynamic(..) => {\n-            MetadataCreationResult::new(trait_pointer_metadata(cx, t, None, unique_type_id), false)\n+            MetadataCreationResult::new(dyn_type_metadata(cx, t, unique_type_id), false)\n         }\n         ty::Foreign(..) => {\n             MetadataCreationResult::new(foreign_type_metadata(cx, t, unique_type_id), false)\n         }\n-        ty::RawPtr(ty::TypeAndMut { ty, .. }) | ty::Ref(_, ty, _) => match ptr_metadata(ty) {\n-            Ok(res) => res,\n-            Err(metadata) => return metadata,\n-        },\n-        ty::Adt(def, _) if def.is_box() => match ptr_metadata(t.boxed_ty()) {\n-            Ok(res) => res,\n-            Err(metadata) => return metadata,\n-        },\n+        ty::RawPtr(ty::TypeAndMut { ty: pointee_type, .. }) | ty::Ref(_, pointee_type, _) => {\n+            pointer_or_reference_metadata(cx, t, pointee_type, unique_type_id)\n+        }\n+        ty::Adt(def, _) if def.is_box() => {\n+            pointer_or_reference_metadata(cx, t, t.boxed_ty(), unique_type_id)\n+        }\n         ty::FnDef(..) | ty::FnPtr(_) => {\n             if let Some(metadata) =\n                 debug_context(cx).type_map.borrow().find_metadata_for_unique_id(unique_type_id)\n@@ -694,7 +706,22 @@ pub fn type_metadata<'ll, 'tcx>(cx: &CodegenCx<'ll, 'tcx>, t: Ty<'tcx>) -> &'ll\n             type_map.borrow_mut().remove_type(t);\n \n             // This is actually a function pointer, so wrap it in pointer DI.\n-            MetadataCreationResult::new(pointer_type_metadata(cx, t, fn_metadata), false)\n+            let (pointer_size, pointer_align) =\n+                cx.size_and_align_of(cx.tcx.mk_imm_ptr(cx.tcx.mk_unit()));\n+            let name = compute_debuginfo_type_name(cx.tcx, t, false);\n+            let md = unsafe {\n+                llvm::LLVMRustDIBuilderCreatePointerType(\n+                    DIB(cx),\n+                    fn_metadata,\n+                    pointer_size.bits(),\n+                    pointer_align.bits() as u32,\n+                    0, // Ignore DWARF address space.\n+                    name.as_ptr().cast(),\n+                    name.len(),\n+                )\n+            };\n+\n+            MetadataCreationResult::new(md, false)\n         }\n         ty::Closure(def_id, substs) => {\n             let upvar_tys: Vec<_> = substs.as_closure().upvar_tys().collect();\n@@ -959,26 +986,6 @@ fn foreign_type_metadata<'ll, 'tcx>(\n     create_struct_stub(cx, t, &name, unique_type_id, NO_SCOPE_METADATA, DIFlags::FlagZero)\n }\n \n-fn pointer_type_metadata<'ll, 'tcx>(\n-    cx: &CodegenCx<'ll, 'tcx>,\n-    pointer_type: Ty<'tcx>,\n-    pointee_type_metadata: &'ll DIType,\n-) -> &'ll DIType {\n-    let (pointer_size, pointer_align) = cx.size_and_align_of(pointer_type);\n-    let name = compute_debuginfo_type_name(cx.tcx, pointer_type, false);\n-    unsafe {\n-        llvm::LLVMRustDIBuilderCreatePointerType(\n-            DIB(cx),\n-            pointee_type_metadata,\n-            pointer_size.bits(),\n-            pointer_align.bits() as u32,\n-            0, // Ignore DWARF address space.\n-            name.as_ptr().cast(),\n-            name.len(),\n-        )\n-    }\n-}\n-\n fn param_type_metadata<'ll, 'tcx>(cx: &CodegenCx<'ll, 'tcx>, t: Ty<'tcx>) -> &'ll DIType {\n     debug!(\"param_type_metadata: {:?}\", t);\n     let name = format!(\"{:?}\", t);"}, {"sha": "6dd0d58efe328a8fab015378a4b54b5b89ed27ce", "filename": "compiler/rustc_codegen_llvm/src/debuginfo/utils.rs", "status": "modified", "additions": 58, "deletions": 1, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/d253e6e473c7614eb16f6144ab6a0f95e89db604/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdebuginfo%2Futils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d253e6e473c7614eb16f6144ab6a0f95e89db604/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdebuginfo%2Futils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdebuginfo%2Futils.rs?ref=d253e6e473c7614eb16f6144ab6a0f95e89db604", "patch": "@@ -4,7 +4,9 @@ use super::namespace::item_namespace;\n use super::CrateDebugContext;\n \n use rustc_hir::def_id::DefId;\n-use rustc_middle::ty::DefIdTree;\n+use rustc_middle::ty::layout::LayoutOf;\n+use rustc_middle::ty::{self, DefIdTree, Ty};\n+use rustc_target::abi::VariantIdx;\n \n use crate::common::CodegenCx;\n use crate::llvm;\n@@ -46,3 +48,58 @@ pub fn DIB<'a, 'll>(cx: &'a CodegenCx<'ll, '_>) -> &'a DIBuilder<'ll> {\n pub fn get_namespace_for_item<'ll>(cx: &CodegenCx<'ll, '_>, def_id: DefId) -> &'ll DIScope {\n     item_namespace(cx, cx.tcx.parent(def_id).expect(\"get_namespace_for_item: missing parent?\"))\n }\n+\n+#[derive(Debug, PartialEq, Eq)]\n+pub(crate) enum FatPtrKind {\n+    Slice,\n+    Dyn,\n+}\n+\n+/// Determines if `pointee_ty` is slice-like or trait-object-like, i.e.\n+/// if the second field of the fat pointer is a length or a vtable-pointer.\n+/// If `pointee_ty` does not require a fat pointer (because it is Sized) then\n+/// the function returns `None`.\n+pub(crate) fn fat_pointer_kind<'ll, 'tcx>(\n+    cx: &CodegenCx<'ll, 'tcx>,\n+    pointee_ty: Ty<'tcx>,\n+) -> Option<FatPtrKind> {\n+    let layout = cx.layout_of(pointee_ty);\n+\n+    if !layout.is_unsized() {\n+        return None;\n+    }\n+\n+    match *pointee_ty.kind() {\n+        ty::Str | ty::Slice(_) => Some(FatPtrKind::Slice),\n+        ty::Dynamic(..) => Some(FatPtrKind::Dyn),\n+        ty::Adt(adt_def, _) => {\n+            assert!(adt_def.is_struct());\n+            assert!(adt_def.variants.len() == 1);\n+            let variant = &adt_def.variants[VariantIdx::from_usize(0)];\n+            assert!(!variant.fields.is_empty());\n+            let last_field_index = variant.fields.len() - 1;\n+\n+            debug_assert!(\n+                (0..last_field_index)\n+                    .all(|field_index| { !layout.field(cx, field_index).is_unsized() })\n+            );\n+\n+            let unsized_field = layout.field(cx, last_field_index);\n+            assert!(unsized_field.is_unsized());\n+            fat_pointer_kind(cx, unsized_field.ty)\n+        }\n+        ty::Foreign(_) => {\n+            // Assert that pointers to foreign types really are thin:\n+            debug_assert_eq!(\n+                cx.size_of(cx.tcx.mk_imm_ptr(pointee_ty)),\n+                cx.size_of(cx.tcx.mk_imm_ptr(cx.tcx.types.u8))\n+            );\n+            None\n+        }\n+        _ => {\n+            // For all other pointee types we should already have returned None\n+            // at the beginning of the function.\n+            panic!(\"fat_pointer_kind() - Encountered unexpected `pointee_ty`: {:?}\", pointee_ty)\n+        }\n+    }\n+}"}, {"sha": "272f1319ad1800227d1fd90c5a851945c3eac877", "filename": "compiler/rustc_codegen_llvm/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/d253e6e473c7614eb16f6144ab6a0f95e89db604/compiler%2Frustc_codegen_llvm%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d253e6e473c7614eb16f6144ab6a0f95e89db604/compiler%2Frustc_codegen_llvm%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Flib.rs?ref=d253e6e473c7614eb16f6144ab6a0f95e89db604", "patch": "@@ -10,6 +10,7 @@\n #![feature(let_else)]\n #![feature(extern_types)]\n #![feature(nll)]\n+#![feature(let_else)]\n #![recursion_limit = \"256\"]\n \n use back::write::{create_informational_target_machine, create_target_machine};"}, {"sha": "1d1f3c0c76ece6b30a475dbf5010727dd1de1695", "filename": "src/test/debuginfo/unsized.rs", "status": "modified", "additions": 34, "deletions": 6, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/d253e6e473c7614eb16f6144ab6a0f95e89db604/src%2Ftest%2Fdebuginfo%2Funsized.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d253e6e473c7614eb16f6144ab6a0f95e89db604/src%2Ftest%2Fdebuginfo%2Funsized.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebuginfo%2Funsized.rs?ref=d253e6e473c7614eb16f6144ab6a0f95e89db604", "patch": "@@ -4,13 +4,36 @@\n \n // gdb-command:run\n \n-// gdb-command:print *a\n-// gdbg-check:$1 = {value = [...] \"abc\"}\n-// gdbr-check:$1 = unsized::Foo<[u8]> {value: [...]}\n+// gdb-command:print a\n+// gdbg-check:$1 = {data_ptr: [...], length: 4}\n+// gdbr-check:$1 = &unsized::Foo<[u8]> {data_ptr: [...], length: 4}\n \n-// gdb-command:print *b\n-// gdbg-check:$2 = {value = {value = [...] \"abc\"}}\n-// gdbr-check:$2 = unsized::Foo<unsized::Foo<[u8]>> {value: unsized::Foo<[u8]> {value: [...]}}\n+// gdb-command:print b\n+// gdbg-check:$2 = {data_ptr: [...], length: 4}\n+// gdbr-check:$2 = &unsized::Foo<unsized::Foo<[u8]>> {data_ptr: [...], length: 4}\n+\n+// gdb-command:print c\n+// gdbg-check:$3 = {pointer: [...], vtable: [...]}\n+// gdbr-check:$3 = &unsized::Foo<dyn core::fmt::Debug> {pointer: [...], vtable: [...]}\n+\n+\n+// === CDB TESTS ===================================================================================\n+\n+// cdb-command: g\n+// cdb-command:dx a\n+// cdb-check:a                [Type: ref$<unsized::Foo<slice$<u8> > >]\n+// cdb-check:    [+0x000] data_ptr         : 0x[...] [Type: unsized::Foo<slice$<u8> > *]\n+// cdb-check:    [+0x008] length           : 0x4 [Type: unsigned __int64]\n+\n+// cdb-command:dx b\n+// cdb-check:b                [Type: ref$<unsized::Foo<unsized::Foo<slice$<u8> > > >]\n+// cdb-check:    [+0x000] data_ptr         : 0x[...] [Type: unsized::Foo<unsized::Foo<slice$<u8> > > *]\n+// cdb-check:    [+0x008] length           : 0x4 [Type: unsigned __int64]\n+\n+// cdb-command:dx c\n+// cdb-check:c                [Type: ref$<unsized::Foo<dyn$<core::fmt::Debug> > >]\n+// cdb-check:    [+0x000] pointer          : 0x[...] [Type: unsized::Foo<dyn$<core::fmt::Debug> > *]\n+// cdb-check:    [+0x008] vtable           : 0x[...] [Type: unsigned __int64 (*)[3]]\n \n \n #![feature(omit_gdb_pretty_printer_section)]\n@@ -26,8 +49,13 @@ fn main() {\n             value: *b\"abc\\0\"\n         }\n     };\n+\n+    // We expect `a`, `b`, and `c` to all be fat pointers.\n+    // `a` and `b` should be slice-like and thus have a `data_ptr` and `length` field.\n+    // `c` should be trait-object-like and thus have a `pointer` and `vtable` field.\n     let a: &Foo<[u8]> = &foo.value;\n     let b: &Foo<Foo<[u8]>> = &foo;\n+    let c: &Foo<dyn std::fmt::Debug> = &Foo { value: 7i32 };\n \n     zzz(); // #break\n }"}]}