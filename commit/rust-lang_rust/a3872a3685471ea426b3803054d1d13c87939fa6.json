{"sha": "a3872a3685471ea426b3803054d1d13c87939fa6", "node_id": "MDY6Q29tbWl0NzI0NzEyOmEzODcyYTM2ODU0NzFlYTQyNmIzODAzMDU0ZDFkMTNjODc5MzlmYTY=", "commit": {"author": {"name": "Kieran Hunt", "email": "kieran.hunt92@gmail.com", "date": "2015-07-29T20:38:43Z"}, "committer": {"name": "Kieran Hunt", "email": "kieran.hunt92@gmail.com", "date": "2015-07-29T20:38:43Z"}, "message": "Consolidating loop information to a single page. Per PR #27305", "tree": {"sha": "7015b9ac767a5fda16f86ad582af983ad56d3170", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7015b9ac767a5fda16f86ad582af983ad56d3170"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a3872a3685471ea426b3803054d1d13c87939fa6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a3872a3685471ea426b3803054d1d13c87939fa6", "html_url": "https://github.com/rust-lang/rust/commit/a3872a3685471ea426b3803054d1d13c87939fa6", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a3872a3685471ea426b3803054d1d13c87939fa6/comments", "author": {"login": "KieranHunt", "id": 4106917, "node_id": "MDQ6VXNlcjQxMDY5MTc=", "avatar_url": "https://avatars.githubusercontent.com/u/4106917?v=4", "gravatar_id": "", "url": "https://api.github.com/users/KieranHunt", "html_url": "https://github.com/KieranHunt", "followers_url": "https://api.github.com/users/KieranHunt/followers", "following_url": "https://api.github.com/users/KieranHunt/following{/other_user}", "gists_url": "https://api.github.com/users/KieranHunt/gists{/gist_id}", "starred_url": "https://api.github.com/users/KieranHunt/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/KieranHunt/subscriptions", "organizations_url": "https://api.github.com/users/KieranHunt/orgs", "repos_url": "https://api.github.com/users/KieranHunt/repos", "events_url": "https://api.github.com/users/KieranHunt/events{/privacy}", "received_events_url": "https://api.github.com/users/KieranHunt/received_events", "type": "User", "site_admin": false}, "committer": {"login": "KieranHunt", "id": 4106917, "node_id": "MDQ6VXNlcjQxMDY5MTc=", "avatar_url": "https://avatars.githubusercontent.com/u/4106917?v=4", "gravatar_id": "", "url": "https://api.github.com/users/KieranHunt", "html_url": "https://github.com/KieranHunt", "followers_url": "https://api.github.com/users/KieranHunt/followers", "following_url": "https://api.github.com/users/KieranHunt/following{/other_user}", "gists_url": "https://api.github.com/users/KieranHunt/gists{/gist_id}", "starred_url": "https://api.github.com/users/KieranHunt/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/KieranHunt/subscriptions", "organizations_url": "https://api.github.com/users/KieranHunt/orgs", "repos_url": "https://api.github.com/users/KieranHunt/repos", "events_url": "https://api.github.com/users/KieranHunt/events{/privacy}", "received_events_url": "https://api.github.com/users/KieranHunt/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b36551b0e2cecaef8908cb11b63aff1256a377f5", "url": "https://api.github.com/repos/rust-lang/rust/commits/b36551b0e2cecaef8908cb11b63aff1256a377f5", "html_url": "https://github.com/rust-lang/rust/commit/b36551b0e2cecaef8908cb11b63aff1256a377f5"}], "stats": {"total": 415, "additions": 213, "deletions": 202}, "files": [{"sha": "24686e772e3c303515cb4d55bf1b4a64c6fc9de2", "filename": "src/doc/trpl/SUMMARY.md", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a3872a3685471ea426b3803054d1d13c87939fa6/src%2Fdoc%2Ftrpl%2FSUMMARY.md", "raw_url": "https://github.com/rust-lang/rust/raw/a3872a3685471ea426b3803054d1d13c87939fa6/src%2Fdoc%2Ftrpl%2FSUMMARY.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2FSUMMARY.md?ref=a3872a3685471ea426b3803054d1d13c87939fa6", "patch": "@@ -26,9 +26,7 @@\n     * [Primitive Types](primitive-types.md)\n     * [Comments](comments.md)\n     * [if](if.md)\n-    * [infinite loops](infinite-loops.md)\n-    * [for loops](for-loops.md)\n-    * [while loops](while-loops.md)\n+    * [Loops](loops.md)\n     * [Ownership](ownership.md)\n     * [References and Borrowing](references-and-borrowing.md)\n     * [Lifetimes](lifetimes.md)"}, {"sha": "2866cee3a1a63bb4546b7c3d833ed0f9453ede9c", "filename": "src/doc/trpl/for-loops.md", "status": "removed", "additions": 0, "deletions": 85, "changes": 85, "blob_url": "https://github.com/rust-lang/rust/blob/b36551b0e2cecaef8908cb11b63aff1256a377f5/src%2Fdoc%2Ftrpl%2Ffor-loops.md", "raw_url": "https://github.com/rust-lang/rust/raw/b36551b0e2cecaef8908cb11b63aff1256a377f5/src%2Fdoc%2Ftrpl%2Ffor-loops.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Ffor-loops.md?ref=b36551b0e2cecaef8908cb11b63aff1256a377f5", "patch": "@@ -1,85 +0,0 @@\n-% for Loops\n-\n-The `for` loop is used to loop a particular number of times. Rust\u2019s `for` loops\n-work a bit differently than in other systems languages, however. Rust\u2019s `for`\n-loop doesn\u2019t look like this \u201cC-style\u201d `for` loop:\n-\n-```c\n-for (x = 0; x < 10; x++) {\n-    printf( \"%d\\n\", x );\n-}\n-```\n-\n-Instead, it looks like this:\n-\n-```rust\n-for x in 0..10 {\n-    println!(\"{}\", x); // x: i32\n-}\n-```\n-\n-In slightly more abstract terms,\n-\n-```ignore\n-for var in expression {\n-    code\n-}\n-```\n-\n-The expression is an [iterator][iterator]. The iterator gives back a series of\n-elements. Each element is one iteration of the loop. That value is then bound\n-to the name `var`, which is valid for the loop body. Once the body is over, the\n-next value is fetched from the iterator, and we loop another time. When there\n-are no more values, the `for` loop is over.\n-\n-[iterator]: iterators.html\n-\n-In our example, `0..10` is an expression that takes a start and an end position,\n-and gives an iterator over those values. The upper bound is exclusive, though,\n-so our loop will print `0` through `9`, not `10`.\n-\n-Rust does not have the \u201cC-style\u201d `for` loop on purpose. Manually controlling\n-each element of the loop is complicated and error prone, even for experienced C\n-developers.\n-\n-# Enumerate\n-\n-When you need to keep track of how many times you already looped, you can use the `.enumerate()` function.\n-\n-## On ranges:\n-\n-```rust\n-for (i,j) in (5..10).enumerate() {\n-    println!(\"i = {} and j = {}\", i, j);\n-}\n-```\n-\n-Outputs:\n-\n-```text\n-i = 0 and j = 5\n-i = 1 and j = 6\n-i = 2 and j = 7\n-i = 3 and j = 8\n-i = 4 and j = 9\n-```\n-\n-Don't forget to add the parentheses around the range.\n-\n-## On iterators:\n-\n-```rust\n-# let lines = \"hello\\nworld\".lines();\n-for (linenumber, line) in lines.enumerate() {\n-    println!(\"{}: {}\", linenumber, line);\n-}\n-```\n-\n-Outputs:\n-\n-```text\n-0: Content of line one\n-1: Content of line two\n-2: Content of line tree\n-3: Content of line four\n-```"}, {"sha": "823b3b44885aec1a4e85aee56140fd9632b89691", "filename": "src/doc/trpl/infinite-loops.md", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a3872a3685471ea426b3803054d1d13c87939fa6/src%2Fdoc%2Ftrpl%2Finfinite-loops.md", "raw_url": "https://github.com/rust-lang/rust/raw/a3872a3685471ea426b3803054d1d13c87939fa6/src%2Fdoc%2Ftrpl%2Finfinite-loops.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Finfinite-loops.md?ref=a3872a3685471ea426b3803054d1d13c87939fa6", "patch": "@@ -2,15 +2,15 @@\n \n The infinite `loop` is the simplest form of `loop` available in Rust. Using the keyword `loop`, Rust provides a way to loop until a `break` or `return` is issued. Rust's infinite `loop`s look like this:\n \n-```\n+```rust\n loop {\n     println!(\"Loop forever!\");\n }\n ```\n \n Leaving a infinite `loop` can be achieved using a break statement as follows:\n \n-```\n+```rust\n let mut i = 0;\n loop {\n     if i == 10 {\n@@ -25,7 +25,7 @@ loop {\n \n Labels can be assigned to `loop`s to so that, in the case of nested `loop`s, an outer `loop` may be left early when certain criteria are met in an inner `loop`.\n \n-```\n+```rust\n let mut i = 0;\n 'outer: loop {\n     'inner: loop {"}, {"sha": "91ff832a19a51534e06ba07faefd76ef9b6c6875", "filename": "src/doc/trpl/loops.md", "status": "added", "additions": 209, "deletions": 0, "changes": 209, "blob_url": "https://github.com/rust-lang/rust/blob/a3872a3685471ea426b3803054d1d13c87939fa6/src%2Fdoc%2Ftrpl%2Floops.md", "raw_url": "https://github.com/rust-lang/rust/raw/a3872a3685471ea426b3803054d1d13c87939fa6/src%2Fdoc%2Ftrpl%2Floops.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Floops.md?ref=a3872a3685471ea426b3803054d1d13c87939fa6", "patch": "@@ -0,0 +1,209 @@\n+% Loops\n+\n+Rust currently provides three approaches to performing some kind of iterative activity. They are: `loop`, `while` and `for`. Each approach has its own set of uses.\n+\n+## loop\n+\n+The infinite `loop` is the simplest form of loop available in Rust. Using the keyword `loop`, Rust provides a way to loop indefinitely until some terminating statement is reached. Rust's infinite `loop`s look like this:\n+\n+```rust\n+loop {\n+    println!(\"Loop forever!\");\n+}\n+```\n+\n+## while\n+\n+Rust also has a `while` loop. It looks like this:\n+\n+```rust\n+let mut x = 5; // mut x: i32\n+let mut done = false; // mut done: bool\n+\n+while !done {\n+    x += x - 3;\n+\n+    println!(\"{}\", x);\n+\n+    if x % 5 == 0 {\n+        done = true;\n+    }\n+}\n+```\n+\n+`while` loops are the correct choice when you\u2019re not sure how many times\n+you need to loop.\n+\n+If you need an infinite loop, you may be tempted to write this:\n+\n+```rust,ignore\n+while true {\n+```\n+\n+However, `loop` is far better suited to handle this case:\n+\n+```rust,ignore\n+loop {\n+```\n+\n+Rust\u2019s control-flow analysis treats this construct differently than a `while\n+true`, since we know that it will always loop. In general, the more information\n+we can give to the compiler, the better it can do with safety and code\n+generation, so you should always prefer `loop` when you plan to loop\n+infinitely.\n+\n+## for\n+\n+The `for` loop is used to loop a particular number of times. Rust\u2019s `for` loops\n+work a bit differently than in other systems languages, however. Rust\u2019s `for`\n+loop doesn\u2019t look like this \u201cC-style\u201d `for` loop:\n+\n+```c\n+for (x = 0; x < 10; x++) {\n+    printf( \"%d\\n\", x );\n+}\n+```\n+\n+Instead, it looks like this:\n+\n+```rust\n+for x in 0..10 {\n+    println!(\"{}\", x); // x: i32\n+}\n+```\n+\n+In slightly more abstract terms,\n+\n+```ignore\n+for var in expression {\n+    code\n+}\n+```\n+\n+The expression is an [iterator][iterator]. The iterator gives back a series of\n+elements. Each element is one iteration of the loop. That value is then bound\n+to the name `var`, which is valid for the loop body. Once the body is over, the\n+next value is fetched from the iterator, and we loop another time. When there\n+are no more values, the `for` loop is over.\n+\n+[iterator]: iterators.html\n+\n+In our example, `0..10` is an expression that takes a start and an end position,\n+and gives an iterator over those values. The upper bound is exclusive, though,\n+so our loop will print `0` through `9`, not `10`.\n+\n+Rust does not have the \u201cC-style\u201d `for` loop on purpose. Manually controlling\n+each element of the loop is complicated and error prone, even for experienced C\n+developers.\n+\n+### Enumerate\n+\n+When you need to keep track of how many times you already looped, you can use the `.enumerate()` function.\n+\n+#### On ranges:\n+\n+```rust\n+for (i,j) in (5..10).enumerate() {\n+    println!(\"i = {} and j = {}\", i, j);\n+}\n+```\n+\n+Outputs:\n+\n+```text\n+i = 0 and j = 5\n+i = 1 and j = 6\n+i = 2 and j = 7\n+i = 3 and j = 8\n+i = 4 and j = 9\n+```\n+\n+Don't forget to add the parentheses around the range.\n+\n+#### On iterators:\n+\n+```rust\n+# let lines = \"hello\\nworld\".lines();\n+for (linenumber, line) in lines.enumerate() {\n+    println!(\"{}: {}\", linenumber, line);\n+}\n+```\n+\n+Outputs:\n+\n+```text\n+0: Content of line one\n+1: Content of line two\n+2: Content of line tree\n+3: Content of line four\n+```\n+\n+## Ending iteration early\n+\n+Let\u2019s take a look at that `while` loop we had earlier:\n+\n+```rust\n+let mut x = 5;\n+let mut done = false;\n+\n+while !done {\n+    x += x - 3;\n+\n+    println!(\"{}\", x);\n+\n+    if x % 5 == 0 {\n+        done = true;\n+    }\n+}\n+```\n+\n+We had to keep a dedicated `mut` boolean variable binding, `done`, to know\n+when we should exit out of the loop. Rust has two keywords to help us with\n+modifying iteration: `break` and `continue`.\n+\n+In this case, we can write the loop in a better way with `break`:\n+\n+```rust\n+let mut x = 5;\n+\n+loop {\n+    x += x - 3;\n+\n+    println!(\"{}\", x);\n+\n+    if x % 5 == 0 { break; }\n+}\n+```\n+\n+We now loop forever with `loop` and use `break` to break out early. Issuing an explicit `return` statement will also serve to terminate the loop early.\n+\n+`continue` is similar, but instead of ending the loop, goes to the next\n+iteration. This will only print the odd numbers:\n+\n+```rust\n+for x in 0..10 {\n+    if x % 2 == 0 { continue; }\n+\n+    println!(\"{}\", x);\n+}\n+```\n+\n+## Loop labels\n+\n+You may also encounter situations where you have nested loops and need to\n+specify which one your `break` or `continue` statement is for. Like most\n+other languages, by default a `break` or `continue` will apply to innermost\n+loop. In a sitation where you would like to a `break` or `continue` for one\n+of the outer loops, you can use labels to specify which loop the `break` or\n+ `continue` statement applies to. This will only print when both `x` and `y` are\n+ odd:\n+\n+```rust\n+'outer: for x in 0..10 {\n+    'inner: for y in 0..10 {\n+        if x % 2 == 0 { continue 'outer; } // continues the loop over x\n+        if y % 2 == 0 { continue 'inner; } // continues the loop over y\n+        println!(\"x: {}, y: {}\", x, y);\n+    }\n+}\n+```"}, {"sha": "124ebc7d69ddcb5343a708ad50b26a413cf7783a", "filename": "src/doc/trpl/while-loops.md", "status": "removed", "additions": 0, "deletions": 111, "changes": 111, "blob_url": "https://github.com/rust-lang/rust/blob/b36551b0e2cecaef8908cb11b63aff1256a377f5/src%2Fdoc%2Ftrpl%2Fwhile-loops.md", "raw_url": "https://github.com/rust-lang/rust/raw/b36551b0e2cecaef8908cb11b63aff1256a377f5/src%2Fdoc%2Ftrpl%2Fwhile-loops.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Fwhile-loops.md?ref=b36551b0e2cecaef8908cb11b63aff1256a377f5", "patch": "@@ -1,111 +0,0 @@\n-% while Loops\n-\n-Rust also has a `while` loop. It looks like this:\n-\n-```rust\n-let mut x = 5; // mut x: i32\n-let mut done = false; // mut done: bool\n-\n-while !done {\n-    x += x - 3;\n-\n-    println!(\"{}\", x);\n-\n-    if x % 5 == 0 {\n-        done = true;\n-    }\n-}\n-```\n-\n-`while` loops are the correct choice when you\u2019re not sure how many times\n-you need to loop.\n-\n-If you need an infinite loop, you may be tempted to write this:\n-\n-```rust,ignore\n-while true {\n-```\n-\n-However, Rust has a dedicated keyword, `loop`, to handle this case:\n-\n-```rust,ignore\n-loop {\n-```\n-\n-Rust\u2019s control-flow analysis treats this construct differently than a `while\n-true`, since we know that it will always loop. In general, the more information\n-we can give to the compiler, the better it can do with safety and code\n-generation, so you should always prefer `loop` when you plan to loop\n-infinitely.\n-\n-## Ending iteration early\n-\n-Let\u2019s take a look at that `while` loop we had earlier:\n-\n-```rust\n-let mut x = 5;\n-let mut done = false;\n-\n-while !done {\n-    x += x - 3;\n-\n-    println!(\"{}\", x);\n-\n-    if x % 5 == 0 {\n-        done = true;\n-    }\n-}\n-```\n-\n-We had to keep a dedicated `mut` boolean variable binding, `done`, to know\n-when we should exit out of the loop. Rust has two keywords to help us with\n-modifying iteration: `break` and `continue`.\n-\n-In this case, we can write the loop in a better way with `break`:\n-\n-```rust\n-let mut x = 5;\n-\n-loop {\n-    x += x - 3;\n-\n-    println!(\"{}\", x);\n-\n-    if x % 5 == 0 { break; }\n-}\n-```\n-\n-We now loop forever with `loop` and use `break` to break out early.\n-\n-`continue` is similar, but instead of ending the loop, goes to the next\n-iteration. This will only print the odd numbers:\n-\n-```rust\n-for x in 0..10 {\n-    if x % 2 == 0 { continue; }\n-\n-    println!(\"{}\", x);\n-}\n-```\n-\n-You may also encounter situations where you have nested loops and need to \n-specify which one your `break` or `continue` statement is for. Like most \n-other languages, by default a `break` or `continue` will apply to innermost \n-loop. In a sitation where you would like to a `break` or `continue` for one \n-of the outer loops, you can use labels to specify which loop the `break` or\n- `continue` statement applies to. This will only print when both `x` and `y` are\n- odd:\n-\n-```rust\n-'outer: for x in 0..10 {\n-    'inner: for y in 0..10 {\n-        if x % 2 == 0 { continue 'outer; } // continues the loop over x\n-        if y % 2 == 0 { continue 'inner; } // continues the loop over y\n-        println!(\"x: {}, y: {}\", x, y);\n-    }\n-}\n-```\n-\n-Both `continue` and `break` are valid in both `while` loops and [`for` loops][for].\n-\n-[for]: for-loops.html"}]}