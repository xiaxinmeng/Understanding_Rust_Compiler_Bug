{"sha": "cf5c1ab0b6ce335525ed5a71af1b8b7df637abe0", "node_id": "MDY6Q29tbWl0NzI0NzEyOmNmNWMxYWIwYjZjZTMzNTUyNWVkNWE3MWFmMWI4YjdkZjYzN2FiZTA=", "commit": {"author": {"name": "mcarton", "email": "cartonmartin+git@gmail.com", "date": "2016-04-26T11:31:52Z"}, "committer": {"name": "mcarton", "email": "cartonmartin+git@gmail.com", "date": "2016-04-26T11:31:52Z"}, "message": "Fix paths resolution\n\nPut more paths into the `utils::paths` module.", "tree": {"sha": "b6ac258bafdc67aa994127d4d039df4fde3310cb", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b6ac258bafdc67aa994127d4d039df4fde3310cb"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/cf5c1ab0b6ce335525ed5a71af1b8b7df637abe0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/cf5c1ab0b6ce335525ed5a71af1b8b7df637abe0", "html_url": "https://github.com/rust-lang/rust/commit/cf5c1ab0b6ce335525ed5a71af1b8b7df637abe0", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/cf5c1ab0b6ce335525ed5a71af1b8b7df637abe0/comments", "author": {"login": "mcarton", "id": 3751788, "node_id": "MDQ6VXNlcjM3NTE3ODg=", "avatar_url": "https://avatars.githubusercontent.com/u/3751788?v=4", "gravatar_id": "", "url": "https://api.github.com/users/mcarton", "html_url": "https://github.com/mcarton", "followers_url": "https://api.github.com/users/mcarton/followers", "following_url": "https://api.github.com/users/mcarton/following{/other_user}", "gists_url": "https://api.github.com/users/mcarton/gists{/gist_id}", "starred_url": "https://api.github.com/users/mcarton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/mcarton/subscriptions", "organizations_url": "https://api.github.com/users/mcarton/orgs", "repos_url": "https://api.github.com/users/mcarton/repos", "events_url": "https://api.github.com/users/mcarton/events{/privacy}", "received_events_url": "https://api.github.com/users/mcarton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "mcarton", "id": 3751788, "node_id": "MDQ6VXNlcjM3NTE3ODg=", "avatar_url": "https://avatars.githubusercontent.com/u/3751788?v=4", "gravatar_id": "", "url": "https://api.github.com/users/mcarton", "html_url": "https://github.com/mcarton", "followers_url": "https://api.github.com/users/mcarton/followers", "following_url": "https://api.github.com/users/mcarton/following{/other_user}", "gists_url": "https://api.github.com/users/mcarton/gists{/gist_id}", "starred_url": "https://api.github.com/users/mcarton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/mcarton/subscriptions", "organizations_url": "https://api.github.com/users/mcarton/orgs", "repos_url": "https://api.github.com/users/mcarton/repos", "events_url": "https://api.github.com/users/mcarton/events{/privacy}", "received_events_url": "https://api.github.com/users/mcarton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "08818de9b7f0a51bf71fc863ae7798be9e19b1c5", "url": "https://api.github.com/repos/rust-lang/rust/commits/08818de9b7f0a51bf71fc863ae7798be9e19b1c5", "html_url": "https://github.com/rust-lang/rust/commit/08818de9b7f0a51bf71fc863ae7798be9e19b1c5"}], "stats": {"total": 127, "additions": 80, "deletions": 47}, "files": [{"sha": "70abb7a1aac7f3c35728c2ed491c66860991688b", "filename": "src/loops.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/cf5c1ab0b6ce335525ed5a71af1b8b7df637abe0/src%2Floops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf5c1ab0b6ce335525ed5a71af1b8b7df637abe0/src%2Floops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Floops.rs?ref=cf5c1ab0b6ce335525ed5a71af1b8b7df637abe0", "patch": "@@ -285,7 +285,7 @@ impl LateLintPass for LoopsPass {\n                 let iter_expr = &method_args[0];\n                 if let Some(lhs_constructor) = path.segments.last() {\n                     if method_name.node.as_str() == \"next\" &&\n-                       match_trait_method(cx, match_expr, &[\"core\", \"iter\", \"Iterator\"]) &&\n+                       match_trait_method(cx, match_expr, &paths::ITERATOR) &&\n                        lhs_constructor.identifier.name.as_str() == \"Some\" &&\n                        !is_iterator_used_after_while_let(cx, iter_expr) {\n                         let iterator = snippet(cx, method_args[0].span, \"_\");\n@@ -305,7 +305,7 @@ impl LateLintPass for LoopsPass {\n         if let StmtSemi(ref expr, _) = stmt.node {\n             if let ExprMethodCall(ref method, _, ref args) = expr.node {\n                 if args.len() == 1 && method.node.as_str() == \"collect\" &&\n-                   match_trait_method(cx, expr, &[\"core\", \"iter\", \"Iterator\"]) {\n+                   match_trait_method(cx, expr, &paths::ITERATOR) {\n                     span_lint(cx,\n                               UNUSED_COLLECT,\n                               expr.span,\n@@ -488,7 +488,7 @@ fn check_for_loop_arg(cx: &LateContext, pat: &Pat, arg: &Expr, expr: &Expr) {\n                                        object,\n                                        method_name));\n                 }\n-            } else if method_name.as_str() == \"next\" && match_trait_method(cx, arg, &[\"core\", \"iter\", \"Iterator\"]) {\n+            } else if method_name.as_str() == \"next\" && match_trait_method(cx, arg, &paths::ITERATOR) {\n                 span_lint(cx,\n                           ITER_NEXT_LOOP,\n                           expr.span,\n@@ -739,11 +739,11 @@ fn is_ref_iterable_type(cx: &LateContext, e: &Expr) -> bool {\n     match_type(cx, ty, &paths::VEC) ||\n     match_type(cx, ty, &paths::LINKED_LIST) ||\n     match_type(cx, ty, &paths::HASHMAP) ||\n-    match_type(cx, ty, &[\"std\", \"collections\", \"hash\", \"set\", \"HashSet\"]) ||\n-    match_type(cx, ty, &[\"collections\", \"vec_deque\", \"VecDeque\"]) ||\n-    match_type(cx, ty, &[\"collections\", \"binary_heap\", \"BinaryHeap\"]) ||\n+    match_type(cx, ty, &paths::HASHSET) ||\n+    match_type(cx, ty, &paths::VEC_DEQUE) ||\n+    match_type(cx, ty, &paths::BINARY_HEAP) ||\n     match_type(cx, ty, &paths::BTREEMAP) ||\n-    match_type(cx, ty, &[\"collections\", \"btree\", \"set\", \"BTreeSet\"])\n+    match_type(cx, ty, &paths::BTREESET)\n }\n \n fn is_iterable_array(ty: ty::Ty) -> bool {"}, {"sha": "1a0620d883455d5dea64ad9cc62d0fbc43e38650", "filename": "src/map_clone.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cf5c1ab0b6ce335525ed5a71af1b8b7df637abe0/src%2Fmap_clone.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf5c1ab0b6ce335525ed5a71af1b8b7df637abe0/src%2Fmap_clone.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fmap_clone.rs?ref=cf5c1ab0b6ce335525ed5a71af1b8b7df637abe0", "patch": "@@ -96,7 +96,7 @@ fn expr_eq_ident(expr: &Expr, id: Ident) -> bool {\n }\n \n fn get_type_name(cx: &LateContext, expr: &Expr, arg: &Expr) -> Option<&'static str> {\n-    if match_trait_method(cx, expr, &[\"core\", \"iter\", \"Iterator\"]) {\n+    if match_trait_method(cx, expr, &paths::ITERATOR) {\n         Some(\"iterator\")\n     } else if match_type(cx, walk_ptrs_ty(cx.tcx.expr_ty(arg)), &paths::OPTION) {\n         Some(\"Option\")"}, {"sha": "e25154bd38b653b133a980dfe30624cf0c4fa4f5", "filename": "src/methods.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/cf5c1ab0b6ce335525ed5a71af1b8b7df637abe0/src%2Fmethods.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf5c1ab0b6ce335525ed5a71af1b8b7df637abe0/src%2Fmethods.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fmethods.rs?ref=cf5c1ab0b6ce335525ed5a71af1b8b7df637abe0", "patch": "@@ -752,7 +752,7 @@ fn lint_map_unwrap_or_else(cx: &LateContext, expr: &Expr, map_args: &MethodArgs,\n /// lint use of `filter().next() for Iterators`\n fn lint_filter_next(cx: &LateContext, expr: &Expr, filter_args: &MethodArgs) {\n     // lint if caller of `.filter().next()` is an Iterator\n-    if match_trait_method(cx, expr, &[\"core\", \"iter\", \"Iterator\"]) {\n+    if match_trait_method(cx, expr, &paths::ITERATOR) {\n         let msg = \"called `filter(p).next()` on an Iterator. This is more succinctly expressed by calling `.find(p)` \\\n                    instead.\";\n         let filter_snippet = snippet(cx, filter_args[1].span, \"..\");\n@@ -776,7 +776,7 @@ fn lint_filter_next(cx: &LateContext, expr: &Expr, filter_args: &MethodArgs) {\n fn lint_search_is_some(cx: &LateContext, expr: &Expr, search_method: &str, search_args: &MethodArgs,\n                        is_some_args: &MethodArgs) {\n     // lint if caller of search is an Iterator\n-    if match_trait_method(cx, &*is_some_args[0], &[\"core\", \"iter\", \"Iterator\"]) {\n+    if match_trait_method(cx, &*is_some_args[0], &paths::ITERATOR) {\n         let msg = format!(\"called `is_some()` after searching an iterator with {}. This is more succinctly expressed \\\n                            by calling `any()`.\",\n                           search_method);"}, {"sha": "eaba19b08e418fc9a843da6adff49a1c05de7dd1", "filename": "src/minmax.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/cf5c1ab0b6ce335525ed5a71af1b8b7df637abe0/src%2Fminmax.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf5c1ab0b6ce335525ed5a71af1b8b7df637abe0/src%2Fminmax.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fminmax.rs?ref=cf5c1ab0b6ce335525ed5a71af1b8b7df637abe0", "patch": "@@ -3,7 +3,7 @@ use rustc::lint::*;\n use rustc::hir::*;\n use std::cmp::{PartialOrd, Ordering};\n use syntax::ptr::P;\n-use utils::{match_def_path, span_lint};\n+use utils::{match_def_path, paths, span_lint};\n \n /// **What it does:** This lint checks for expressions where `std::cmp::min` and `max` are used to clamp values, but switched so that the result is constant.\n ///\n@@ -57,9 +57,9 @@ fn min_max<'a>(cx: &LateContext, expr: &'a Expr) -> Option<(MinMax, Constant, &'\n         if let ExprPath(None, _) = path.node {\n             let def_id = cx.tcx.def_map.borrow()[&path.id].def_id();\n \n-            if match_def_path(cx, def_id, &[\"core\", \"cmp\", \"min\"]) {\n+            if match_def_path(cx, def_id, &paths::CMP_MIN) {\n                 fetch_const(args, MinMax::Min)\n-            } else if match_def_path(cx, def_id, &[\"core\", \"cmp\", \"max\"]) {\n+            } else if match_def_path(cx, def_id, &paths::CMP_MAX) {\n                 fetch_const(args, MinMax::Max)\n             } else {\n                 None"}, {"sha": "e96212a9cefa3151fb5ec9e06d38a07c8eb99c03", "filename": "src/ranges.rs", "status": "modified", "additions": 8, "deletions": 5, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/cf5c1ab0b6ce335525ed5a71af1b8b7df637abe0/src%2Franges.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf5c1ab0b6ce335525ed5a71af1b8b7df637abe0/src%2Franges.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Franges.rs?ref=cf5c1ab0b6ce335525ed5a71af1b8b7df637abe0", "patch": "@@ -1,7 +1,7 @@\n use rustc::lint::*;\n use rustc::hir::*;\n use syntax::codemap::Spanned;\n-use utils::{is_integer_literal, match_type, snippet, span_lint, unsugar_range, UnsugaredRange};\n+use utils::{is_integer_literal, match_type, paths, snippet, span_lint, unsugar_range, UnsugaredRange};\n \n /// **What it does:** This lint checks for iterating over ranges with a `.step_by(0)`, which never terminates.\n ///\n@@ -39,7 +39,7 @@ impl LateLintPass for StepByZero {\n     fn check_expr(&mut self, cx: &LateContext, expr: &Expr) {\n         if let ExprMethodCall(Spanned { node: ref name, .. }, _, ref args) = expr.node {\n             // Range with step_by(0).\n-            if name.as_str() == \"step_by\" && args.len() == 2 && is_range(cx, &args[0]) &&\n+            if name.as_str() == \"step_by\" && args.len() == 2 && has_step_by(cx, &args[0]) &&\n                is_integer_literal(&args[1], 0) {\n                 span_lint(cx,\n                           RANGE_STEP_BY_ZERO,\n@@ -77,10 +77,13 @@ impl LateLintPass for StepByZero {\n     }\n }\n \n-fn is_range(cx: &LateContext, expr: &Expr) -> bool {\n+fn has_step_by(cx: &LateContext, expr: &Expr) -> bool {\n     // No need for walk_ptrs_ty here because step_by moves self, so it\n     // can't be called on a borrowed range.\n     let ty = cx.tcx.expr_ty(expr);\n-    // Note: RangeTo and RangeFull don't have step_by\n-    match_type(cx, ty, &[\"core\", \"ops\", \"Range\"]) || match_type(cx, ty, &[\"core\", \"ops\", \"RangeFrom\"])\n+\n+    // Note: `RangeTo`, `RangeToInclusive` and `RangeFull` don't have step_by\n+    match_type(cx, ty, &paths::RANGE)\n+        || match_type(cx, ty, &paths::RANGE_FROM)\n+        || match_type(cx, ty, &paths::RANGE_INCLUSIVE)\n }"}, {"sha": "83247a59174930fb40e639d7540ba844fcc8bc0d", "filename": "src/utils/mod.rs", "status": "modified", "additions": 31, "deletions": 18, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/cf5c1ab0b6ce335525ed5a71af1b8b7df637abe0/src%2Futils%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf5c1ab0b6ce335525ed5a71af1b8b7df637abe0/src%2Futils%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Futils%2Fmod.rs?ref=cf5c1ab0b6ce335525ed5a71af1b8b7df637abe0", "patch": "@@ -122,23 +122,33 @@ pub fn in_external_macro<T: LintContext>(cx: &T, span: Span) -> bool {\n /// ```\n /// match_def_path(cx, id, &[\"core\", \"option\", \"Option\"])\n /// ```\n+///\n+/// See also the `paths` module.\n pub fn match_def_path(cx: &LateContext, def_id: DefId, path: &[&str]) -> bool {\n-    let krate = &cx.tcx.crate_name(def_id.krate);\n-    if krate != &path[0] {\n-        return false;\n+    use syntax::parse::token;\n+\n+    struct AbsolutePathBuffer {\n+        names: Vec<token::InternedString>,\n     }\n \n-    let path = &path[1..];\n-    let other = cx.tcx.def_path(def_id).data;\n+    impl ty::item_path::ItemPathBuffer for AbsolutePathBuffer {\n+        fn root_mode(&self) -> &ty::item_path::RootMode {\n+            const ABSOLUTE: &'static ty::item_path::RootMode = &ty::item_path::RootMode::Absolute;\n+            ABSOLUTE\n+        }\n \n-    if other.len() != path.len() {\n-        return false;\n+        fn push(&mut self, text: &str) {\n+            self.names.push(token::intern(text).as_str());\n+        }\n     }\n \n-    other.into_iter()\n-         .map(|e| e.data)\n-         .zip(path)\n-         .all(|(nm, p)| nm.as_interned_str() == *p)\n+    let mut apb = AbsolutePathBuffer {\n+        names: vec![],\n+    };\n+\n+    cx.tcx.push_item_path(&mut apb, def_id);\n+\n+    apb.names == path\n }\n \n /// Check if type is struct or enum type with given def path.\n@@ -730,9 +740,12 @@ pub fn unsugar_range(expr: &Expr) -> Option<UnsugaredRange> {\n         Some(unwrap_unstable(expr))\n     }\n \n-    match unwrap_unstable(&expr).node {\n+    // The range syntax is expanded to literal paths starting with `core` or `std` depending on\n+    // `#[no_std]`. Testing both instead of resolving the paths.\n+\n+    match unwrap_unstable(expr).node {\n         ExprPath(None, ref path) => {\n-            if match_path(path, &paths::RANGE_FULL) {\n+            if match_path(path, &paths::RANGE_FULL_STD) || match_path(path, &paths::RANGE_FULL) {\n                 Some(UnsugaredRange {\n                     start: None,\n                     end: None,\n@@ -743,31 +756,31 @@ pub fn unsugar_range(expr: &Expr) -> Option<UnsugaredRange> {\n             }\n         }\n         ExprStruct(ref path, ref fields, None) => {\n-            if match_path(path, &paths::RANGE_FROM) {\n+            if match_path(path, &paths::RANGE_FROM_STD) || match_path(path, &paths::RANGE_FROM) {\n                 Some(UnsugaredRange {\n                     start: get_field(\"start\", fields),\n                     end: None,\n                     limits: RangeLimits::HalfOpen,\n                 })\n-            } else if match_path(path, &paths::RANGE_INCLUSIVE_NON_EMPTY) {\n+            } else if match_path(path, &paths::RANGE_INCLUSIVE_NON_EMPTY_STD) || match_path(path, &paths::RANGE_INCLUSIVE_NON_EMPTY) {\n                 Some(UnsugaredRange {\n                     start: get_field(\"start\", fields),\n                     end: get_field(\"end\", fields),\n                     limits: RangeLimits::Closed,\n                 })\n-            } else if match_path(path, &paths::RANGE) {\n+            } else if match_path(path, &paths::RANGE_STD) || match_path(path, &paths::RANGE) {\n                 Some(UnsugaredRange {\n                     start: get_field(\"start\", fields),\n                     end: get_field(\"end\", fields),\n                     limits: RangeLimits::HalfOpen,\n                 })\n-            } else if match_path(path, &paths::RANGE_TO_INCLUSIVE) {\n+            } else if match_path(path, &paths::RANGE_TO_INCLUSIVE_STD) || match_path(path, &paths::RANGE_TO_INCLUSIVE) {\n                 Some(UnsugaredRange {\n                     start: None,\n                     end: get_field(\"end\", fields),\n                     limits: RangeLimits::Closed,\n                 })\n-            } else if match_path(path, &paths::RANGE_TO) {\n+            } else if match_path(path, &paths::RANGE_TO_STD) || match_path(path, &paths::RANGE_TO) {\n                 Some(UnsugaredRange {\n                     start: None,\n                     end: get_field(\"end\", fields),"}, {"sha": "7da75c3cd55aca1a1ea86f5be3758ee8426aa42e", "filename": "src/utils/paths.rs", "status": "modified", "additions": 26, "deletions": 11, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/cf5c1ab0b6ce335525ed5a71af1b8b7df637abe0/src%2Futils%2Fpaths.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf5c1ab0b6ce335525ed5a71af1b8b7df637abe0/src%2Futils%2Fpaths.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Futils%2Fpaths.rs?ref=cf5c1ab0b6ce335525ed5a71af1b8b7df637abe0", "patch": "@@ -1,12 +1,16 @@\n //! This module contains paths to types and functions Clippy needs to know about.\n \n pub const BEGIN_UNWIND: [&'static str; 3] = [\"std\", \"rt\", \"begin_unwind\"];\n-pub const BOX_NEW: [&'static str; 4] = [\"std\", \"boxed\", \"Box\", \"new\"];\n+pub const BINARY_HEAP: [&'static str; 3] = [\"collections\", \"binary_heap\", \"BinaryHeap\"];\n pub const BOX: [&'static str; 3] = [\"std\", \"boxed\", \"Box\"];\n-pub const BTREEMAP_ENTRY: [&'static str; 4] = [\"collections\", \"btree\", \"map\", \"Entry\"];\n+pub const BOX_NEW: [&'static str; 4] = [\"std\", \"boxed\", \"Box\", \"new\"];\n pub const BTREEMAP: [&'static str; 4] = [\"collections\", \"btree\", \"map\", \"BTreeMap\"];\n+pub const BTREEMAP_ENTRY: [&'static str; 4] = [\"collections\", \"btree\", \"map\", \"Entry\"];\n+pub const BTREESET: [&'static str; 4] = [\"collections\", \"btree\", \"set\", \"BTreeSet\"];\n pub const CLONE: [&'static str; 3] = [\"clone\", \"Clone\", \"clone\"];\n pub const CLONE_TRAIT: [&'static str; 2] = [\"clone\", \"Clone\"];\n+pub const CMP_MAX: [&'static str; 3] = [\"core\", \"cmp\", \"max\"];\n+pub const CMP_MIN: [&'static str; 3] = [\"core\", \"cmp\", \"min\"];\n pub const COW: [&'static str; 3] = [\"collections\", \"borrow\", \"Cow\"];\n pub const CSTRING_NEW: [&'static str; 4] = [\"std\", \"ffi\", \"CString\", \"new\"];\n pub const DEBUG_FMT_METHOD: [&'static str; 4] = [\"std\", \"fmt\", \"Debug\", \"fmt\"];\n@@ -15,25 +19,36 @@ pub const DISPLAY_FMT_METHOD: [&'static str; 4] = [\"std\", \"fmt\", \"Display\", \"fmt\n pub const DROP: [&'static str; 3] = [\"core\", \"mem\", \"drop\"];\n pub const FMT_ARGUMENTS_NEWV1: [&'static str; 4] = [\"std\", \"fmt\", \"Arguments\", \"new_v1\"];\n pub const FMT_ARGUMENTV1_NEW: [&'static str; 4] = [\"std\", \"fmt\", \"ArgumentV1\", \"new\"];\n-pub const HASHMAP_ENTRY: [&'static str; 5] = [\"std\", \"collections\", \"hash\", \"map\", \"Entry\"];\n-pub const HASHMAP: [&'static str; 5] = [\"std\", \"collections\", \"hash\", \"map\", \"HashMap\"];\n pub const HASH: [&'static str; 2] = [\"hash\", \"Hash\"];\n+pub const HASHMAP: [&'static str; 5] = [\"std\", \"collections\", \"hash\", \"map\", \"HashMap\"];\n+pub const HASHMAP_ENTRY: [&'static str; 5] = [\"std\", \"collections\", \"hash\", \"map\", \"Entry\"];\n+pub const HASHSET: [&'static str; 5] = [\"std\", \"collections\", \"hash\", \"set\", \"HashSet\"];\n pub const IO_PRINT: [&'static str; 3] = [\"std\", \"io\", \"_print\"];\n+pub const ITERATOR: [&'static str; 4] = [\"core\", \"iter\", \"iterator\", \"Iterator\"];\n pub const LINKED_LIST: [&'static str; 3] = [\"collections\", \"linked_list\", \"LinkedList\"];\n pub const MEM_FORGET: [&'static str; 3] = [\"core\", \"mem\", \"forget\"];\n pub const MUTEX: [&'static str; 4] = [\"std\", \"sync\", \"mutex\", \"Mutex\"];\n pub const OPEN_OPTIONS: [&'static str; 3] = [\"std\", \"fs\", \"OpenOptions\"];\n pub const OPTION: [&'static str; 3] = [\"core\", \"option\", \"Option\"];\n-pub const RANGE_FROM: [&'static str; 3] = [\"std\", \"ops\", \"RangeFrom\"];\n-pub const RANGE_FULL: [&'static str; 3] = [\"std\", \"ops\", \"RangeFull\"];\n-pub const RANGE_INCLUSIVE_NON_EMPTY: [&'static str; 4] = [\"std\", \"ops\", \"RangeInclusive\", \"NonEmpty\"];\n-pub const RANGE: [&'static str; 3] = [\"std\", \"ops\", \"Range\"];\n-pub const RANGE_TO_INCLUSIVE: [&'static str; 3] = [\"std\", \"ops\", \"RangeToInclusive\"];\n-pub const RANGE_TO: [&'static str; 3] = [\"std\", \"ops\", \"RangeTo\"];\n+pub const RANGE: [&'static str; 3] = [\"core\", \"ops\", \"Range\"];\n+pub const RANGE_FROM: [&'static str; 3] = [\"core\", \"ops\", \"RangeFrom\"];\n+pub const RANGE_FROM_STD: [&'static str; 3] = [\"std\", \"ops\", \"RangeFrom\"];\n+pub const RANGE_FULL: [&'static str; 3] = [\"core\", \"ops\", \"RangeFull\"];\n+pub const RANGE_FULL_STD: [&'static str; 3] = [\"std\", \"ops\", \"RangeFull\"];\n+pub const RANGE_INCLUSIVE: [&'static str; 3] = [\"core\", \"ops\", \"RangeInclusive\"];\n+pub const RANGE_INCLUSIVE_NON_EMPTY: [&'static str; 4] = [\"core\", \"ops\", \"RangeInclusive\", \"NonEmpty\"];\n+pub const RANGE_INCLUSIVE_NON_EMPTY_STD: [&'static str; 4] = [\"std\", \"ops\", \"RangeInclusive\", \"NonEmpty\"];\n+pub const RANGE_INCLUSIVE_STD: [&'static str; 3] = [\"std\", \"ops\", \"RangeInclusive\"];\n+pub const RANGE_STD: [&'static str; 3] = [\"std\", \"ops\", \"Range\"];\n+pub const RANGE_TO: [&'static str; 3] = [\"core\", \"ops\", \"RangeTo\"];\n+pub const RANGE_TO_INCLUSIVE: [&'static str; 3] = [\"core\", \"ops\", \"RangeToInclusive\"];\n+pub const RANGE_TO_INCLUSIVE_STD: [&'static str; 3] = [\"std\", \"ops\", \"RangeToInclusive\"];\n+pub const RANGE_TO_STD: [&'static str; 3] = [\"std\", \"ops\", \"RangeTo\"];\n pub const REGEX: [&'static str; 3] = [\"regex\", \"re_unicode\", \"Regex\"];\n pub const REGEX_NEW: [&'static str; 3] = [\"regex\", \"Regex\", \"new\"];\n pub const RESULT: [&'static str; 3] = [\"core\", \"result\", \"Result\"];\n pub const STRING: [&'static str; 3] = [\"collections\", \"string\", \"String\"];\n pub const TRANSMUTE: [&'static str; 4] = [\"core\", \"intrinsics\", \"\", \"transmute\"];\n-pub const VEC_FROM_ELEM: [&'static str; 3] = [\"std\", \"vec\", \"from_elem\"];\n pub const VEC: [&'static str; 3] = [\"collections\", \"vec\", \"Vec\"];\n+pub const VEC_DEQUE: [&'static str; 3] = [\"collections\", \"vec_deque\", \"VecDeque\"];\n+pub const VEC_FROM_ELEM: [&'static str; 3] = [\"std\", \"vec\", \"from_elem\"];"}, {"sha": "fc12155ce9cb816b7d0569d9a9a5ba66511b2890", "filename": "tests/compile-fail/range.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cf5c1ab0b6ce335525ed5a71af1b8b7df637abe0/tests%2Fcompile-fail%2Frange.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf5c1ab0b6ce335525ed5a71af1b8b7df637abe0/tests%2Fcompile-fail%2Frange.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Frange.rs?ref=cf5c1ab0b6ce335525ed5a71af1b8b7df637abe0", "patch": "@@ -1,4 +1,5 @@\n #![feature(step_by)]\n+#![feature(inclusive_range_syntax)]\n #![feature(plugin)]\n #![plugin(clippy)]\n \n@@ -14,6 +15,7 @@ fn main() {\n     (0..1).step_by(1);\n \n     (1..).step_by(0); //~ERROR Range::step_by(0) produces an infinite iterator\n+    (1...2).step_by(0); //~ERROR Range::step_by(0) produces an infinite iterator\n \n     let x = 0..1;\n     x.step_by(0); //~ERROR Range::step_by(0) produces an infinite iterator"}]}