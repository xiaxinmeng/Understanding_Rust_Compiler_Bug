{"sha": "5955e23343e606daf0341cb7ea66b8b436868ba6", "node_id": "MDY6Q29tbWl0NzI0NzEyOjU5NTVlMjMzNDNlNjA2ZGFmMDM0MWNiN2VhNjZiOGI0MzY4NjhiYTY=", "commit": {"author": {"name": "Graydon Hoare", "email": "graydon@mozilla.com", "date": "2010-11-21T09:16:16Z"}, "committer": {"name": "Graydon Hoare", "email": "graydon@mozilla.com", "date": "2010-11-21T09:16:16Z"}, "message": "Typecheck assignment exprs, redo decl checking, propagate ty_vars. Enable another test.", "tree": {"sha": "0609b63451bb79561bdd997981a17be815dd79b6", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0609b63451bb79561bdd997981a17be815dd79b6"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5955e23343e606daf0341cb7ea66b8b436868ba6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5955e23343e606daf0341cb7ea66b8b436868ba6", "html_url": "https://github.com/rust-lang/rust/commit/5955e23343e606daf0341cb7ea66b8b436868ba6", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5955e23343e606daf0341cb7ea66b8b436868ba6/comments", "author": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "committer": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "79a3811ab81ee14810fa9b7fe86ba0f0501c7399", "url": "https://api.github.com/repos/rust-lang/rust/commits/79a3811ab81ee14810fa9b7fe86ba0f0501c7399", "html_url": "https://github.com/rust-lang/rust/commit/79a3811ab81ee14810fa9b7fe86ba0f0501c7399"}], "stats": {"total": 150, "additions": 97, "deletions": 53}, "files": [{"sha": "bcf16f5759c08eab4390e867265df2a4d04150d9", "filename": "src/Makefile", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/5955e23343e606daf0341cb7ea66b8b436868ba6/src%2FMakefile", "raw_url": "https://github.com/rust-lang/rust/raw/5955e23343e606daf0341cb7ea66b8b436868ba6/src%2FMakefile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2FMakefile?ref=5955e23343e606daf0341cb7ea66b8b436868ba6", "patch": "@@ -525,6 +525,7 @@ TEST_XFAILS_SELF := $(filter-out \\\n                         hello.rs \\\n                         int.rs \\\n                         item-name-overload.rs \\\n+                        lazy-init.rs \\\n                         multiline-comment.rs \\\n                         ), \\\n                       $(wildcard test/*/*.rs test/*/*.rc))"}, {"sha": "64d7e11148fe742df4c2fc1b6224d2e1f3ef3a75", "filename": "src/comp/middle/typeck.rs", "status": "modified", "additions": 96, "deletions": 53, "changes": 149, "blob_url": "https://github.com/rust-lang/rust/blob/5955e23343e606daf0341cb7ea66b8b436868ba6/src%2Fcomp%2Fmiddle%2Ftypeck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5955e23343e606daf0341cb7ea66b8b436868ba6/src%2Fcomp%2Fmiddle%2Ftypeck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftypeck.rs?ref=5955e23343e606daf0341cb7ea66b8b436868ba6", "patch": "@@ -17,6 +17,7 @@ import std.option.some;\n type ty_table = hashmap[ast.def_id, @ty];\n type env = rec(session.session sess,\n                @ty_table item_types,\n+               hashmap[int,@ty] bindings,\n                mutable int next_var_id);\n \n type arg = rec(ast.mode mode, @ty ty);\n@@ -245,6 +246,7 @@ fn ast_ty_to_ty(ty_getter getter, &@ast.ty ast_ty) -> @ty {\n // ast_ty_to_ty.\n fn ast_ty_to_ty_env(@env e, &@ast.ty ast_ty) -> @ty {\n     fn getter(@env e, ast.def_id id) -> @ty {\n+        check (e.item_types.contains_key(id));\n         ret e.item_types.get(id);\n     }\n     auto f = bind getter(e, _);\n@@ -285,6 +287,7 @@ fn collect_item_types(@ast.crate crate) -> tup(@ast.crate, @ty_table) {\n     fn trans_ty_item_id_to_ty(@hashmap[ast.def_id,@ast.item] id_to_ty_item,\n                               @ty_table item_to_ty,\n                               ast.def_id id) -> @ty {\n+        check (id_to_ty_item.contains_key(id));\n         auto item = id_to_ty_item.get(id);\n         ret trans_ty_item_to_ty(id_to_ty_item, item_to_ty, item);\n     }\n@@ -317,6 +320,7 @@ fn collect_item_types(@ast.crate crate) -> tup(@ast.crate, @ty_table) {\n             case (ast.item_ty(?ident, ?referent_ty, ?def_id, _)) {\n                 if (item_to_ty.contains_key(def_id)) {\n                     // Avoid repeating work.\n+                    check (item_to_ty.contains_key(def_id));\n                     ret item_to_ty.get(def_id);\n                 }\n \n@@ -423,7 +427,7 @@ fn type_of(@ast.expr expr) -> @ty {\n \n // Type unification\n \n-fn unify(@ty expected, @ty actual) -> unify_result {\n+fn unify(&@env e, @ty expected, @ty actual) -> unify_result {\n     // Wraps the given type in an appropriate cname.\n     //\n     // TODO: This doesn't do anything yet. We should carry the cname up from\n@@ -440,7 +444,7 @@ fn unify(@ty expected, @ty actual) -> unify_result {\n         ret ures_err(terr_mismatch, expected, actual);\n     }\n \n-    fn unify_step(@ty expected, @ty actual, &hashmap[int,@ty] bindings)\n+    fn unify_step(&@env e, @ty expected, @ty actual)\n             -> unify_result {\n         // TODO: rewrite this using tuple pattern matching when available, to\n         // avoid all this rightward drift and spikiness.\n@@ -456,8 +460,7 @@ fn unify(@ty expected, @ty actual) -> unify_result {\n             case (ty_box(?expected_sub)) {\n                 alt (actual.struct) {\n                     case (ty_box(?actual_sub)) {\n-                        auto result = unify_step(expected_sub, actual_sub,\n-                                                 bindings);\n+                        auto result = unify_step(e, expected_sub, actual_sub);\n                         alt (result) {\n                             case (ures_ok(?result_sub)) {\n                                 ret ures_ok(plain_ty(ty_box(result_sub)));\n@@ -479,8 +482,7 @@ fn unify(@ty expected, @ty actual) -> unify_result {\n             case (ty_vec(?expected_sub)) {\n                 alt (actual.struct) {\n                     case (ty_vec(?actual_sub)) {\n-                        auto result = unify_step(expected_sub, actual_sub,\n-                                                 bindings);\n+                        auto result = unify_step(e, expected_sub, actual_sub);\n                         alt (result) {\n                             case (ures_ok(?result_sub)) {\n                                 ret ures_ok(plain_ty(ty_vec(result_sub)));\n@@ -524,9 +526,8 @@ fn unify(@ty expected, @ty actual) -> unify_result {\n                                 ret ures_err(err, expected, actual);\n                             }\n \n-                            auto result = unify_step(expected_elem._1,\n-                                                     actual_elem._1,\n-                                                     bindings);\n+                            auto result = unify_step(e, expected_elem._1,\n+                                                     actual_elem._1);\n                             alt (result) {\n                                 case (ures_ok(?rty)) {\n                                     result_elems += vec(tup(expected_elem._0,\n@@ -576,9 +577,8 @@ fn unify(@ty expected, @ty actual) -> unify_result {\n                                 result_mode = ast.val;\n                             }\n \n-                            auto result = unify_step(expected_input.ty,\n-                                                     actual_input.ty,\n-                                                     bindings);\n+                            auto result = unify_step(e, expected_input.ty,\n+                                                     actual_input.ty);\n \n                             alt (result) {\n                                 case (ures_ok(?rty)) {\n@@ -596,8 +596,8 @@ fn unify(@ty expected, @ty actual) -> unify_result {\n \n                         // Check the output.\n                         auto result_out;\n-                        auto result = unify_step(expected_output,\n-                                                 actual_output, bindings);\n+                        auto result = unify_step(e, expected_output,\n+                                                 actual_output);\n                         alt (result) {\n                             case (ures_ok(?rty)) {\n                                 result_out = rty;\n@@ -618,12 +618,13 @@ fn unify(@ty expected, @ty actual) -> unify_result {\n             }\n \n             case (ty_var(?expected_id)) {\n-                if (bindings.contains_key(expected_id)) {\n-                     auto binding = bindings.get(expected_id);\n-                     ret unify_step(binding, actual, bindings);\n+                if (e.bindings.contains_key(expected_id)) {\n+                    check (e.bindings.contains_key(expected_id));\n+                    auto binding = e.bindings.get(expected_id);\n+                    ret unify_step(e, binding, actual);\n                 }\n \n-                bindings.insert(expected_id, actual);\n+                e.bindings.insert(expected_id, actual);\n                 ret ures_ok(actual);\n             }\n         }\n@@ -632,19 +633,13 @@ fn unify(@ty expected, @ty actual) -> unify_result {\n         fail;\n     }\n \n-    fn hash_int(&int x) -> uint { ret x as uint; }\n-    fn eq_int(&int a, &int b) -> bool { ret a == b; }\n-    auto hasher = hash_int;\n-    auto eqer = eq_int;\n-    auto bindings = map.mk_hashmap[int,@ty](hasher, eqer);\n-\n-    ret unify_step(expected, actual, bindings);\n+    ret unify_step(e, expected, actual);\n }\n \n // Requires that the two types unify, and prints an error message if they\n // don't. Returns the unified type.\n fn demand(&@env e, &span sp, @ty expected, @ty actual) -> @ty {\n-    alt (unify(expected, actual)) {\n+    alt (unify(e, expected, actual)) {\n         case (ures_ok(?ty)) {\n             ret ty;\n         }\n@@ -666,30 +661,45 @@ fn demand(&@env e, &span sp, @ty expected, @ty actual) -> @ty {\n // with the previously-stored type for this local.\n fn demand_local(&@env e, &span sp, &@ty_table locals, ast.def_id local_id,\n                 @ty t) {\n+    check (locals.contains_key(local_id));\n     auto prev_ty = locals.get(local_id);\n     auto unified_ty = demand(e, sp, prev_ty, t);\n     locals.insert(local_id, unified_ty);\n }\n \n // Returns true if the two types unify and false if they don't.\n-fn are_compatible(@ty expected, @ty actual) -> bool {\n-    alt (unify(expected, actual)) {\n+fn are_compatible(&@env e, @ty expected, @ty actual) -> bool {\n+    alt (unify(e, expected, actual)) {\n         case (ures_ok(_))        { ret true;  }\n         case (ures_err(_, _, _)) { ret false; }\n     }\n }\n \n // Writeback: the phase that writes inferred types back into the AST.\n \n-fn writeback_local(&@ty_table locals, &span sp, @ast.local local)\n+fn resolve_vars(@env e, @ty t) -> @ty {\n+    alt (t.struct) {\n+        case (ty_var(?v)) {\n+            check (e.bindings.contains_key(v));\n+            ret resolve_vars(e, e.bindings.get(v));\n+        }\n+    }\n+    ret t;\n+}\n+\n+fn writeback_local(@env e, &@ty_table locals, &span sp, @ast.local local)\n         -> @ast.decl {\n-    auto local_wb = @rec(ann=ast.ann_type(locals.get(local.id)) with *local);\n+    if (!locals.contains_key(local.id)) {\n+        e.sess.err(\"unable to determine type of local: \" + local.ident);\n+    }\n+    auto local_ty = resolve_vars(e, locals.get(local.id));\n+    auto local_wb = @rec(ann=ast.ann_type(local_ty) with *local);\n     ret @fold.respan[ast.decl_](sp, ast.decl_local(local_wb));\n }\n \n fn writeback(&@env e, &@ty_table locals, &ast.block block) -> ast.block {\n     auto fld = fold.new_identity_fold[@ty_table]();\n-    auto f = writeback_local;   // FIXME: trans_const_lval bug\n+    auto f = bind writeback_local(e, _, _, _);\n     fld = @rec(fold_decl_local = f with *fld);\n     ret fold.fold_block[@ty_table](locals, fld, block);\n }\n@@ -753,8 +763,14 @@ fn check_expr(&@env e, &@ty_table locals, @ast.expr expr) -> @ast.expr {\n         case (ast.expr_name(?name, ?defopt, _)) {\n             auto ty = @rec(struct=ty_nil, cname=none[str]);\n             alt (option.get[ast.def](defopt)) {\n-                case (ast.def_arg(?id)) { ty = locals.get(id); }\n-                case (ast.def_local(?id)) { ty = locals.get(id); }\n+                case (ast.def_arg(?id)) {\n+                    check (locals.contains_key(id));\n+                    ty = locals.get(id);\n+                }\n+                case (ast.def_local(?id)) {\n+                    check (locals.contains_key(id));\n+                    ty = locals.get(id);\n+                }\n                 case (_) {\n                     // FIXME: handle other names.\n                     e.sess.unimpl(\"definition variant for: \"\n@@ -767,6 +783,17 @@ fn check_expr(&@env e, &@ty_table locals, @ast.expr expr) -> @ast.expr {\n                                                       ast.ann_type(ty)));\n         }\n \n+        case (ast.expr_assign(?lhs, ?rhs, _)) {\n+            auto lhs_1 = check_expr(e, locals, lhs);\n+            auto rhs_1 = check_expr(e, locals, rhs);\n+            auto lhs_t = type_of(lhs_1);\n+            auto rhs_t = type_of(rhs_1);\n+            demand(e, expr.span, lhs_t, rhs_t);\n+            ret @fold.respan[ast.expr_](expr.span,\n+                                        ast.expr_assign(lhs_1, rhs_1,\n+                                                        ast.ann_type(rhs_t)));\n+        }\n+\n         case (_) {\n             // TODO\n             ret expr;\n@@ -780,29 +807,36 @@ fn check_stmt(@env e, @ty_table locals, @ty ret_ty, &@ast.stmt stmt)\n         case (ast.stmt_decl(?decl)) {\n             alt (decl.node) {\n                 case (ast.decl_local(?local)) {\n-                    alt (local.init) {\n-                        case (none[@ast.expr]) {\n-                            // empty\n+\n+                    auto local_ty;\n+                    alt (local.ty) {\n+                        case (none[@ast.ty]) {\n+                            // Auto slot. Assign a ty_var.\n+                            local_ty = plain_ty(ty_var(e.next_var_id));\n+                            e.next_var_id += 1;\n+                        }\n+\n+                        case (some[@ast.ty](?ast_ty)) {\n+                            local_ty = ast_ty_to_ty_env(e, ast_ty);\n                         }\n+                    }\n+                    locals.insert(local.id, local_ty);\n \n+                    auto rhs_ty = local_ty;\n+                    auto init = local.init;\n+                    alt (local.init) {\n                         case (some[@ast.expr](?expr)) {\n                             auto expr_t = check_expr(e, locals, expr);\n-                            locals.insert(local.id, type_of(expr_t));\n-\n-                            alt (local.ty) {\n-                                case (none[@ast.ty]) {\n-                                    // Nothing to do. We'll figure out the\n-                                    // type later.\n-                                }\n-\n-                                case (some[@ast.ty](?ast_ty)) {\n-                                    auto ty = ast_ty_to_ty_env(e, ast_ty);\n-                                    demand_local(e, decl.span, locals,\n-                                                 local.id, ty);\n-                                }\n-                            }\n+                            rhs_ty = type_of(expr_t);\n+                            init = some[@ast.expr](expr_t);\n                         }\n                     }\n+                    demand(e, decl.span, local_ty, rhs_ty);\n+                    auto local_1 = @rec(init = init with *local);\n+                    auto decl_1 = @rec(node=ast.decl_local(local_1)\n+                                       with *decl);\n+                    ret @fold.respan[ast.stmt_](stmt.span,\n+                                                ast.stmt_decl(decl_1));\n                 }\n \n                 case (ast.decl_item(_)) {\n@@ -816,7 +850,7 @@ fn check_stmt(@env e, @ty_table locals, @ty ret_ty, &@ast.stmt stmt)\n         case (ast.stmt_ret(?expr_opt)) {\n             alt (expr_opt) {\n                 case (none[@ast.expr]) {\n-                    if (!are_compatible(ret_ty, plain_ty(ty_nil))) {\n+                    if (!are_compatible(e, ret_ty, plain_ty(ty_nil))) {\n                         e.sess.err(\"ret; in function returning non-void\");\n                     }\n \n@@ -846,7 +880,7 @@ fn check_stmt(@env e, @ty_table locals, @ty ret_ty, &@ast.stmt stmt)\n \n         case (ast.stmt_expr(?expr)) {\n             auto expr_t = check_expr(e, locals, expr);\n-            if (!are_compatible(type_of(expr_t), plain_ty(ty_nil))) {\n+            if (!are_compatible(e, type_of(expr_t), plain_ty(ty_nil))) {\n                 // TODO: real warning function\n                 log \"warning: expression used as statement should have \" +\n                     \"void type\";\n@@ -891,7 +925,16 @@ fn check_fn(&@env e, &span sp, ast.ident ident, &ast._fn f, ast.def_id id,\n \n fn check_crate(session.session sess, @ast.crate crate) -> @ast.crate {\n     auto result = collect_item_types(crate);\n-    auto e = @rec(sess=sess, item_types=result._1, mutable next_var_id=0);\n+\n+    fn hash_int(&int x) -> uint { ret x as uint; }\n+    fn eq_int(&int a, &int b) -> bool { ret a == b; }\n+    auto hasher = hash_int;\n+    auto eqer = eq_int;\n+\n+    auto e = @rec(sess=sess,\n+                  item_types=result._1,\n+                  bindings = map.mk_hashmap[int,@ty](hasher, eqer),\n+                  mutable next_var_id=0);\n \n     auto fld = fold.new_identity_fold[@env]();\n     auto f = check_fn;  // FIXME: trans_const_lval bug"}]}