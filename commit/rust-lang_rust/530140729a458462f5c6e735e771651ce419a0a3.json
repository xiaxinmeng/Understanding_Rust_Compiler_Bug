{"sha": "530140729a458462f5c6e735e771651ce419a0a3", "node_id": "MDY6Q29tbWl0NzI0NzEyOjUzMDE0MDcyOWE0NTg0NjJmNWM2ZTczNWU3NzE2NTFjZTQxOWEwYTM=", "commit": {"author": {"name": "Nicholas Nethercote", "email": "nnethercote@mozilla.com", "date": "2020-08-03T09:37:22Z"}, "committer": {"name": "Nicholas Nethercote", "email": "nnethercote@mozilla.com", "date": "2020-08-05T00:42:42Z"}, "message": "Avoid an unnecessary thread creation at rustdoc startup.\n\nrustdoc's `main()` immediately spawns a thread, M, with a large stack\n(16MiB or 32MiB) on which it runs `main_args()`. `main_args()` does a\nsmall amount of options processing and then calls\n`setup_callbacks_and_run_in_default_thread_pool_with_globals()`, which\nspawns it own thread, and M is not used further.\n\nSo, thread M seems unnecessary. However, it does serve a purpose: if the\noptions processing in `main_args()` panics, that panic is caught when M\nis joined. So M can't simply be removed.\n\nHowever, `main_options()`, which is called by `main_args()`, has a\n`catch_fatal_errors()` call within it. We can move that call to `main()`\nand change it to the very similar `catch_with_exit_code()`. With that in\nplace, M can be removed, and panics from options processing will still\nbe caught appropriately.\n\nEven better, this makes rustdoc's `main()` match rustc's `main()`, which\nalso uses `catch_with_exit_code()`.\n\n(Also note that the use of a 16MiB/32MiB stack was eliminated from rustc\nin #55617.)", "tree": {"sha": "af75919b617161f88ca4f045a20808e36097cbbc", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/af75919b617161f88ca4f045a20808e36097cbbc"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/530140729a458462f5c6e735e771651ce419a0a3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/530140729a458462f5c6e735e771651ce419a0a3", "html_url": "https://github.com/rust-lang/rust/commit/530140729a458462f5c6e735e771651ce419a0a3", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/530140729a458462f5c6e735e771651ce419a0a3/comments", "author": {"login": "nnethercote", "id": 1940286, "node_id": "MDQ6VXNlcjE5NDAyODY=", "avatar_url": "https://avatars.githubusercontent.com/u/1940286?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nnethercote", "html_url": "https://github.com/nnethercote", "followers_url": "https://api.github.com/users/nnethercote/followers", "following_url": "https://api.github.com/users/nnethercote/following{/other_user}", "gists_url": "https://api.github.com/users/nnethercote/gists{/gist_id}", "starred_url": "https://api.github.com/users/nnethercote/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nnethercote/subscriptions", "organizations_url": "https://api.github.com/users/nnethercote/orgs", "repos_url": "https://api.github.com/users/nnethercote/repos", "events_url": "https://api.github.com/users/nnethercote/events{/privacy}", "received_events_url": "https://api.github.com/users/nnethercote/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nnethercote", "id": 1940286, "node_id": "MDQ6VXNlcjE5NDAyODY=", "avatar_url": "https://avatars.githubusercontent.com/u/1940286?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nnethercote", "html_url": "https://github.com/nnethercote", "followers_url": "https://api.github.com/users/nnethercote/followers", "following_url": "https://api.github.com/users/nnethercote/following{/other_user}", "gists_url": "https://api.github.com/users/nnethercote/gists{/gist_id}", "starred_url": "https://api.github.com/users/nnethercote/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nnethercote/subscriptions", "organizations_url": "https://api.github.com/users/nnethercote/orgs", "repos_url": "https://api.github.com/users/nnethercote/repos", "events_url": "https://api.github.com/users/nnethercote/events{/privacy}", "received_events_url": "https://api.github.com/users/nnethercote/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8244b1b11488a336a485f07fd6550b973009a931", "url": "https://api.github.com/repos/rust-lang/rust/commits/8244b1b11488a336a485f07fd6550b973009a931", "html_url": "https://github.com/rust-lang/rust/commit/8244b1b11488a336a485f07fd6550b973009a931"}], "stats": {"total": 101, "additions": 46, "deletions": 55}, "files": [{"sha": "a12ba50d6c3c21442a3cc15a1645b7e1bb48a163", "filename": "src/librustdoc/lib.rs", "status": "modified", "additions": 46, "deletions": 55, "changes": 101, "blob_url": "https://github.com/rust-lang/rust/blob/530140729a458462f5c6e735e771651ce419a0a3/src%2Flibrustdoc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/530140729a458462f5c6e735e771651ce419a0a3/src%2Flibrustdoc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Flib.rs?ref=530140729a458462f5c6e735e771651ce419a0a3", "patch": "@@ -47,9 +47,9 @@ extern crate log;\n \n use std::default::Default;\n use std::env;\n-use std::panic;\n use std::process;\n \n+use rustc_errors::ErrorReported;\n use rustc_session::config::{make_crate_type_option, ErrorOutputType, RustcOptGroup};\n use rustc_session::getopts;\n use rustc_session::{early_error, early_warn};\n@@ -82,22 +82,14 @@ struct Output {\n }\n \n pub fn main() {\n-    let thread_stack_size: usize = if cfg!(target_os = \"haiku\") {\n-        16_000_000 // 16MB on Haiku\n-    } else {\n-        32_000_000 // 32MB on other platforms\n-    };\n     rustc_driver::set_sigpipe_handler();\n     rustc_driver::install_ice_hook();\n     rustc_driver::init_env_logger(\"RUSTDOC_LOG\");\n-\n-    let res = std::thread::Builder::new()\n-        .stack_size(thread_stack_size)\n-        .spawn(move || get_args().map(|args| main_args(&args)).unwrap_or(1))\n-        .unwrap()\n-        .join()\n-        .unwrap_or(rustc_driver::EXIT_FAILURE);\n-    process::exit(res);\n+    let exit_code = rustc_driver::catch_with_exit_code(|| match get_args() {\n+        Some(args) => main_args(&args),\n+        _ => Err(ErrorReported),\n+    });\n+    process::exit(exit_code);\n }\n \n fn get_args() -> Option<Vec<String>> {\n@@ -418,7 +410,10 @@ fn usage(argv0: &str) {\n     println!(\"{}\", options.usage(&format!(\"{} [options] <input>\", argv0)));\n }\n \n-fn main_args(args: &[String]) -> i32 {\n+/// A result type used by several functions under `main()`.\n+type MainResult = Result<(), ErrorReported>;\n+\n+fn main_args(args: &[String]) -> MainResult {\n     let mut options = getopts::Options::new();\n     for option in opts() {\n         (option.apply)(&mut options);\n@@ -429,24 +424,27 @@ fn main_args(args: &[String]) -> i32 {\n             early_error(ErrorOutputType::default(), &err.to_string());\n         }\n     };\n+\n+    // Note that we discard any distinction between different non-zero exit\n+    // codes from `from_matches` here.\n     let options = match config::Options::from_matches(&matches) {\n         Ok(opts) => opts,\n-        Err(code) => return code,\n+        Err(code) => return if code == 0 { Ok(()) } else { Err(ErrorReported) },\n     };\n     rustc_interface::interface::setup_callbacks_and_run_in_default_thread_pool_with_globals(\n         options.edition,\n         move || main_options(options),\n     )\n }\n \n-fn wrap_return(diag: &rustc_errors::Handler, res: Result<(), String>) -> i32 {\n+fn wrap_return(diag: &rustc_errors::Handler, res: Result<(), String>) -> MainResult {\n     match res {\n-        Ok(()) => 0,\n+        Ok(()) => Ok(()),\n         Err(err) => {\n             if !err.is_empty() {\n                 diag.struct_err(&err).emit();\n             }\n-            1\n+            Err(ErrorReported)\n         }\n     }\n }\n@@ -457,9 +455,9 @@ fn run_renderer<T: formats::FormatRenderer>(\n     render_info: config::RenderInfo,\n     diag: &rustc_errors::Handler,\n     edition: rustc_span::edition::Edition,\n-) -> i32 {\n+) -> MainResult {\n     match formats::run_format::<T>(krate, renderopts, render_info, &diag, edition) {\n-        Ok(_) => rustc_driver::EXIT_SUCCESS,\n+        Ok(_) => Ok(()),\n         Err(e) => {\n             let mut msg = diag.struct_err(&format!(\"couldn't generate documentation: {}\", e.error));\n             let file = e.file.display().to_string();\n@@ -468,12 +466,12 @@ fn run_renderer<T: formats::FormatRenderer>(\n             } else {\n                 msg.note(&format!(\"failed to create or modify \\\"{}\\\"\", file)).emit()\n             }\n-            rustc_driver::EXIT_FAILURE\n+            Err(ErrorReported)\n         }\n     }\n }\n \n-fn main_options(options: config::Options) -> i32 {\n+fn main_options(options: config::Options) -> MainResult {\n     let diag = core::new_handler(options.error_format, None, &options.debugging_options);\n \n     match (options.should_test, options.markdown_input()) {\n@@ -500,44 +498,37 @@ fn main_options(options: config::Options) -> i32 {\n     // compiler all the way through the analysis passes. The rustdoc output is\n     // then generated from the cleaned AST of the crate. This runs all the\n     // plug/cleaning passes.\n-    let result = rustc_driver::catch_fatal_errors(move || {\n-        let crate_name = options.crate_name.clone();\n-        let crate_version = options.crate_version.clone();\n-        let output_format = options.output_format;\n-        let (mut krate, renderinfo, renderopts) = core::run_core(options);\n+    let crate_name = options.crate_name.clone();\n+    let crate_version = options.crate_version.clone();\n+    let output_format = options.output_format;\n+    let (mut krate, renderinfo, renderopts) = core::run_core(options);\n \n-        info!(\"finished with rustc\");\n+    info!(\"finished with rustc\");\n \n-        if let Some(name) = crate_name {\n-            krate.name = name\n-        }\n+    if let Some(name) = crate_name {\n+        krate.name = name\n+    }\n \n-        krate.version = crate_version;\n+    krate.version = crate_version;\n \n-        let out = Output { krate, renderinfo, renderopts };\n+    let out = Output { krate, renderinfo, renderopts };\n \n-        if show_coverage {\n-            // if we ran coverage, bail early, we don't need to also generate docs at this point\n-            // (also we didn't load in any of the useful passes)\n-            return rustc_driver::EXIT_SUCCESS;\n-        }\n+    if show_coverage {\n+        // if we ran coverage, bail early, we don't need to also generate docs at this point\n+        // (also we didn't load in any of the useful passes)\n+        return Ok(());\n+    }\n \n-        let Output { krate, renderinfo, renderopts } = out;\n-        info!(\"going to format\");\n-        let (error_format, edition, debugging_options) = diag_opts;\n-        let diag = core::new_handler(error_format, None, &debugging_options);\n-        match output_format {\n-            None | Some(config::OutputFormat::Html) => {\n-                run_renderer::<html::render::Context>(krate, renderopts, renderinfo, &diag, edition)\n-            }\n-            Some(config::OutputFormat::Json) => {\n-                run_renderer::<json::JsonRenderer>(krate, renderopts, renderinfo, &diag, edition)\n-            }\n+    let Output { krate, renderinfo, renderopts } = out;\n+    info!(\"going to format\");\n+    let (error_format, edition, debugging_options) = diag_opts;\n+    let diag = core::new_handler(error_format, None, &debugging_options);\n+    match output_format {\n+        None | Some(config::OutputFormat::Html) => {\n+            run_renderer::<html::render::Context>(krate, renderopts, renderinfo, &diag, edition)\n+        }\n+        Some(config::OutputFormat::Json) => {\n+            run_renderer::<json::JsonRenderer>(krate, renderopts, renderinfo, &diag, edition)\n         }\n-    });\n-\n-    match result {\n-        Ok(output) => output,\n-        Err(_) => panic::resume_unwind(Box::new(rustc_errors::FatalErrorMarker)),\n     }\n }"}]}