{"sha": "89107d5469dfe978efafe57d70b6f1525b060d46", "node_id": "C_kwDOAAsO6NoAKDg5MTA3ZDU0NjlkZmU5NzhlZmFmZTU3ZDcwYjZmMTUyNWIwNjBkNDY", "commit": {"author": {"name": "unexge", "email": "unexge@gmail.com", "date": "2022-09-04T17:28:04Z"}, "committer": {"name": "unexge", "email": "unexge@gmail.com", "date": "2022-09-26T18:04:57Z"}, "message": "Emit unconfigured code diagnostics for fields", "tree": {"sha": "9bec72452b550a10c40ad10504267ae7f66cfa41", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9bec72452b550a10c40ad10504267ae7f66cfa41"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/89107d5469dfe978efafe57d70b6f1525b060d46", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/89107d5469dfe978efafe57d70b6f1525b060d46", "html_url": "https://github.com/rust-lang/rust/commit/89107d5469dfe978efafe57d70b6f1525b060d46", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/89107d5469dfe978efafe57d70b6f1525b060d46/comments", "author": {"login": "unexge", "id": 16212576, "node_id": "MDQ6VXNlcjE2MjEyNTc2", "avatar_url": "https://avatars.githubusercontent.com/u/16212576?v=4", "gravatar_id": "", "url": "https://api.github.com/users/unexge", "html_url": "https://github.com/unexge", "followers_url": "https://api.github.com/users/unexge/followers", "following_url": "https://api.github.com/users/unexge/following{/other_user}", "gists_url": "https://api.github.com/users/unexge/gists{/gist_id}", "starred_url": "https://api.github.com/users/unexge/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/unexge/subscriptions", "organizations_url": "https://api.github.com/users/unexge/orgs", "repos_url": "https://api.github.com/users/unexge/repos", "events_url": "https://api.github.com/users/unexge/events{/privacy}", "received_events_url": "https://api.github.com/users/unexge/received_events", "type": "User", "site_admin": false}, "committer": {"login": "unexge", "id": 16212576, "node_id": "MDQ6VXNlcjE2MjEyNTc2", "avatar_url": "https://avatars.githubusercontent.com/u/16212576?v=4", "gravatar_id": "", "url": "https://api.github.com/users/unexge", "html_url": "https://github.com/unexge", "followers_url": "https://api.github.com/users/unexge/followers", "following_url": "https://api.github.com/users/unexge/following{/other_user}", "gists_url": "https://api.github.com/users/unexge/gists{/gist_id}", "starred_url": "https://api.github.com/users/unexge/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/unexge/subscriptions", "organizations_url": "https://api.github.com/users/unexge/orgs", "repos_url": "https://api.github.com/users/unexge/repos", "events_url": "https://api.github.com/users/unexge/events{/privacy}", "received_events_url": "https://api.github.com/users/unexge/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1a24003eb6bc8377e76cd9f70bf6700bc842e99b", "url": "https://api.github.com/repos/rust-lang/rust/commits/1a24003eb6bc8377e76cd9f70bf6700bc842e99b", "html_url": "https://github.com/rust-lang/rust/commit/1a24003eb6bc8377e76cd9f70bf6700bc842e99b"}], "stats": {"total": 763, "additions": 730, "deletions": 33}, "files": [{"sha": "570344596def80a2c62711c72ba2b1fa11358dbf", "filename": "crates/hir-def/src/item_tree.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/89107d5469dfe978efafe57d70b6f1525b060d46/crates%2Fhir-def%2Fsrc%2Fitem_tree.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89107d5469dfe978efafe57d70b6f1525b060d46/crates%2Fhir-def%2Fsrc%2Fitem_tree.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-def%2Fsrc%2Fitem_tree.rs?ref=89107d5469dfe978efafe57d70b6f1525b060d46", "patch": "@@ -943,6 +943,7 @@ impl AssocItem {\n pub struct Variant {\n     pub name: Name,\n     pub fields: Fields,\n+    pub ast_id: FileAstId<ast::Variant>,\n }\n \n #[derive(Debug, Clone, PartialEq, Eq)]\n@@ -952,10 +953,17 @@ pub enum Fields {\n     Unit,\n }\n \n+#[derive(Debug, Clone, PartialEq, Eq)]\n+pub enum FieldAstId {\n+    Record(FileAstId<ast::RecordField>),\n+    Tuple(FileAstId<ast::TupleField>),\n+}\n+\n /// A single field of an enum variant or struct\n #[derive(Debug, Clone, PartialEq, Eq)]\n pub struct Field {\n     pub name: Name,\n     pub type_ref: Interned<TypeRef>,\n     pub visibility: RawVisibilityId,\n+    pub ast_id: FieldAstId,\n }"}, {"sha": "077a1b619dd5a056cd89c79a14e260b32aafc7ed", "filename": "crates/hir-def/src/item_tree/lower.rs", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/89107d5469dfe978efafe57d70b6f1525b060d46/crates%2Fhir-def%2Fsrc%2Fitem_tree%2Flower.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89107d5469dfe978efafe57d70b6f1525b060d46/crates%2Fhir-def%2Fsrc%2Fitem_tree%2Flower.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-def%2Fsrc%2Fitem_tree%2Flower.rs?ref=89107d5469dfe978efafe57d70b6f1525b060d46", "patch": "@@ -184,7 +184,8 @@ impl<'a> Ctx<'a> {\n         let name = field.name()?.as_name();\n         let visibility = self.lower_visibility(field);\n         let type_ref = self.lower_type_ref_opt(field.ty());\n-        let res = Field { name, type_ref, visibility };\n+        let ast_id = FieldAstId::Record(self.source_ast_id_map.ast_id(field));\n+        let res = Field { name, type_ref, visibility, ast_id };\n         Some(res)\n     }\n \n@@ -203,7 +204,8 @@ impl<'a> Ctx<'a> {\n         let name = Name::new_tuple_field(idx);\n         let visibility = self.lower_visibility(field);\n         let type_ref = self.lower_type_ref_opt(field.ty());\n-        Field { name, type_ref, visibility }\n+        let ast_id = FieldAstId::Tuple(self.source_ast_id_map.ast_id(field));\n+        Field { name, type_ref, visibility, ast_id }\n     }\n \n     fn lower_union(&mut self, union: &ast::Union) -> Option<FileItemTreeId<Union>> {\n@@ -247,7 +249,8 @@ impl<'a> Ctx<'a> {\n     fn lower_variant(&mut self, variant: &ast::Variant) -> Option<Variant> {\n         let name = variant.name()?.as_name();\n         let fields = self.lower_fields(&variant.kind());\n-        let res = Variant { name, fields };\n+        let ast_id = self.source_ast_id_map.ast_id(variant);\n+        let res = Variant { name, fields, ast_id };\n         Some(res)\n     }\n "}, {"sha": "da1643152c2fe09f3683aeb495b67f3371e3c4ff", "filename": "crates/hir-def/src/item_tree/pretty.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/89107d5469dfe978efafe57d70b6f1525b060d46/crates%2Fhir-def%2Fsrc%2Fitem_tree%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89107d5469dfe978efafe57d70b6f1525b060d46/crates%2Fhir-def%2Fsrc%2Fitem_tree%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-def%2Fsrc%2Fitem_tree%2Fpretty.rs?ref=89107d5469dfe978efafe57d70b6f1525b060d46", "patch": "@@ -115,7 +115,7 @@ impl<'a> Printer<'a> {\n                 w!(self, \"{{\");\n                 self.indented(|this| {\n                     for field in fields.clone() {\n-                        let Field { visibility, name, type_ref } = &this.tree[field];\n+                        let Field { visibility, name, type_ref, ast_id: _ } = &this.tree[field];\n                         this.print_attrs_of(field);\n                         this.print_visibility(*visibility);\n                         w!(this, \"{}: \", name);\n@@ -129,7 +129,7 @@ impl<'a> Printer<'a> {\n                 w!(self, \"(\");\n                 self.indented(|this| {\n                     for field in fields.clone() {\n-                        let Field { visibility, name, type_ref } = &this.tree[field];\n+                        let Field { visibility, name, type_ref, ast_id: _ } = &this.tree[field];\n                         this.print_attrs_of(field);\n                         this.print_visibility(*visibility);\n                         w!(this, \"{}: \", name);\n@@ -323,7 +323,7 @@ impl<'a> Printer<'a> {\n                 self.print_where_clause_and_opening_brace(generic_params);\n                 self.indented(|this| {\n                     for variant in variants.clone() {\n-                        let Variant { name, fields } = &this.tree[variant];\n+                        let Variant { name, fields, ast_id: _ } = &this.tree[variant];\n                         this.print_attrs_of(variant);\n                         w!(this, \"{}\", name);\n                         this.print_fields(fields);"}, {"sha": "5f0cf9c4ac896f1269a8f1347451f612af17a76c", "filename": "crates/hir-def/src/nameres/collector.rs", "status": "modified", "additions": 77, "deletions": 22, "changes": 99, "blob_url": "https://github.com/rust-lang/rust/blob/89107d5469dfe978efafe57d70b6f1525b060d46/crates%2Fhir-def%2Fsrc%2Fnameres%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89107d5469dfe978efafe57d70b6f1525b060d46/crates%2Fhir-def%2Fsrc%2Fnameres%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-def%2Fsrc%2Fnameres%2Fcollector.rs?ref=89107d5469dfe978efafe57d70b6f1525b060d46", "patch": "@@ -32,8 +32,8 @@ use crate::{\n     derive_macro_as_call_id,\n     item_scope::{ImportType, PerNsGlobImports},\n     item_tree::{\n-        self, Fields, FileItemTreeId, ImportKind, ItemTree, ItemTreeId, ItemTreeNode, MacroCall,\n-        MacroDef, MacroRules, Mod, ModItem, ModKind, TreeId,\n+        self, FieldAstId, Fields, FileItemTreeId, ImportKind, ItemTree, ItemTreeId, ItemTreeNode,\n+        MacroCall, MacroDef, MacroRules, Mod, ModItem, ModKind, TreeId,\n     },\n     macro_call_as_call_id, macro_id_to_def_id,\n     nameres::{\n@@ -1511,7 +1511,10 @@ impl ModCollector<'_, '_> {\n             let attrs = self.item_tree.attrs(self.def_collector.db, krate, item.into());\n             if let Some(cfg) = attrs.cfg() {\n                 if !self.is_cfg_enabled(&cfg) {\n-                    self.emit_unconfigured_diagnostic(item, &cfg);\n+                    self.emit_unconfigured_diagnostic(\n+                        InFile::new(self.file_id(), item.ast_id(&self.item_tree).upcast()),\n+                        &cfg,\n+                    );\n                     continue;\n                 }\n             }\n@@ -1523,22 +1526,20 @@ impl ModCollector<'_, '_> {\n             }\n \n             let db = self.def_collector.db;\n-            let module = self.def_collector.def_map.module_id(self.module_id);\n-            let def_map = &mut self.def_collector.def_map;\n+            let module_id = self.module_id;\n+            let module = self.def_collector.def_map.module_id(module_id);\n             let update_def =\n                 |def_collector: &mut DefCollector<'_>, id, name: &Name, vis, has_constructor| {\n-                    def_collector.def_map.modules[self.module_id].scope.declare(id);\n+                    def_collector.def_map.modules[module_id].scope.declare(id);\n                     def_collector.update(\n-                        self.module_id,\n+                        module_id,\n                         &[(Some(name.clone()), PerNs::from_def(id, vis, has_constructor))],\n                         vis,\n                         ImportType::Named,\n                     )\n                 };\n             let resolve_vis = |def_map: &DefMap, visibility| {\n-                def_map\n-                    .resolve_visibility(db, self.module_id, visibility)\n-                    .unwrap_or(Visibility::Public)\n+                def_map.resolve_visibility(db, module_id, visibility).unwrap_or(Visibility::Public)\n             };\n \n             match item {\n@@ -1594,6 +1595,7 @@ impl ModCollector<'_, '_> {\n                     let fn_id =\n                         FunctionLoc { container, id: ItemTreeId::new(self.tree_id, id) }.intern(db);\n \n+                    let def_map = &self.def_collector.def_map;\n                     let vis = resolve_vis(def_map, &self.item_tree[it.visibility]);\n                     if self.def_collector.is_proc_macro {\n                         if self.module_id == def_map.root {\n@@ -1614,7 +1616,10 @@ impl ModCollector<'_, '_> {\n                 ModItem::Struct(id) => {\n                     let it = &self.item_tree[id];\n \n-                    let vis = resolve_vis(def_map, &self.item_tree[it.visibility]);\n+                    self.process_fields(&it.fields);\n+\n+                    let vis =\n+                        resolve_vis(&self.def_collector.def_map, &self.item_tree[it.visibility]);\n                     update_def(\n                         self.def_collector,\n                         StructLoc { container: module, id: ItemTreeId::new(self.tree_id, id) }\n@@ -1628,7 +1633,10 @@ impl ModCollector<'_, '_> {\n                 ModItem::Union(id) => {\n                     let it = &self.item_tree[id];\n \n-                    let vis = resolve_vis(def_map, &self.item_tree[it.visibility]);\n+                    self.process_fields(&it.fields);\n+\n+                    let vis =\n+                        resolve_vis(&self.def_collector.def_map, &self.item_tree[it.visibility]);\n                     update_def(\n                         self.def_collector,\n                         UnionLoc { container: module, id: ItemTreeId::new(self.tree_id, id) }\n@@ -1642,7 +1650,21 @@ impl ModCollector<'_, '_> {\n                 ModItem::Enum(id) => {\n                     let it = &self.item_tree[id];\n \n-                    let vis = resolve_vis(def_map, &self.item_tree[it.visibility]);\n+                    for id in it.variants.clone() {\n+                        let variant = &self.item_tree[id];\n+                        let attrs = self.item_tree.attrs(self.def_collector.db, krate, id.into());\n+                        if let Some(cfg) = attrs.cfg() {\n+                            if !self.is_cfg_enabled(&cfg) {\n+                                self.emit_unconfigured_diagnostic(\n+                                    InFile::new(self.file_id(), variant.ast_id.upcast()),\n+                                    &cfg,\n+                                );\n+                            }\n+                        }\n+                    }\n+\n+                    let vis =\n+                        resolve_vis(&self.def_collector.def_map, &self.item_tree[it.visibility]);\n                     update_def(\n                         self.def_collector,\n                         EnumLoc { container: module, id: ItemTreeId::new(self.tree_id, id) }\n@@ -1660,7 +1682,10 @@ impl ModCollector<'_, '_> {\n \n                     match &it.name {\n                         Some(name) => {\n-                            let vis = resolve_vis(def_map, &self.item_tree[it.visibility]);\n+                            let vis = resolve_vis(\n+                                &self.def_collector.def_map,\n+                                &self.item_tree[it.visibility],\n+                            );\n                             update_def(self.def_collector, const_id.into(), name, vis, false);\n                         }\n                         None => {\n@@ -1674,7 +1699,8 @@ impl ModCollector<'_, '_> {\n                 ModItem::Static(id) => {\n                     let it = &self.item_tree[id];\n \n-                    let vis = resolve_vis(def_map, &self.item_tree[it.visibility]);\n+                    let vis =\n+                        resolve_vis(&self.def_collector.def_map, &self.item_tree[it.visibility]);\n                     update_def(\n                         self.def_collector,\n                         StaticLoc { container, id: ItemTreeId::new(self.tree_id, id) }\n@@ -1688,7 +1714,8 @@ impl ModCollector<'_, '_> {\n                 ModItem::Trait(id) => {\n                     let it = &self.item_tree[id];\n \n-                    let vis = resolve_vis(def_map, &self.item_tree[it.visibility]);\n+                    let vis =\n+                        resolve_vis(&self.def_collector.def_map, &self.item_tree[it.visibility]);\n                     update_def(\n                         self.def_collector,\n                         TraitLoc { container: module, id: ItemTreeId::new(self.tree_id, id) }\n@@ -1702,7 +1729,8 @@ impl ModCollector<'_, '_> {\n                 ModItem::TypeAlias(id) => {\n                     let it = &self.item_tree[id];\n \n-                    let vis = resolve_vis(def_map, &self.item_tree[it.visibility]);\n+                    let vis =\n+                        resolve_vis(&self.def_collector.def_map, &self.item_tree[it.visibility]);\n                     update_def(\n                         self.def_collector,\n                         TypeAliasLoc { container, id: ItemTreeId::new(self.tree_id, id) }\n@@ -2115,17 +2143,44 @@ impl ModCollector<'_, '_> {\n         }\n     }\n \n+    fn process_fields(&mut self, fields: &Fields) {\n+        match fields {\n+            Fields::Record(range) | Fields::Tuple(range) => {\n+                for id in range.clone() {\n+                    let field = &self.item_tree[id];\n+                    let attrs = self.item_tree.attrs(\n+                        self.def_collector.db,\n+                        self.def_collector.def_map.krate,\n+                        id.into(),\n+                    );\n+                    if let Some(cfg) = attrs.cfg() {\n+                        if !self.is_cfg_enabled(&cfg) {\n+                            self.emit_unconfigured_diagnostic(\n+                                InFile::new(\n+                                    self.file_id(),\n+                                    match field.ast_id {\n+                                        FieldAstId::Record(it) => it.upcast(),\n+                                        FieldAstId::Tuple(it) => it.upcast(),\n+                                    },\n+                                ),\n+                                &cfg,\n+                            );\n+                        }\n+                    }\n+                }\n+            }\n+            Fields::Unit => {}\n+        }\n+    }\n+\n     fn is_cfg_enabled(&self, cfg: &CfgExpr) -> bool {\n         self.def_collector.cfg_options.check(cfg) != Some(false)\n     }\n \n-    fn emit_unconfigured_diagnostic(&mut self, item: ModItem, cfg: &CfgExpr) {\n-        let ast_id = item.ast_id(self.item_tree);\n-\n-        let ast_id = InFile::new(self.file_id(), ast_id);\n+    fn emit_unconfigured_diagnostic(&mut self, ast: AstId<ast::AnyHasAttrs>, cfg: &CfgExpr) {\n         self.def_collector.def_map.diagnostics.push(DefDiagnostic::unconfigured_code(\n             self.module_id,\n-            ast_id,\n+            ast,\n             cfg.clone(),\n             self.def_collector.cfg_options.clone(),\n         ));"}, {"sha": "066142291981dd9debf879d8a1ece627f2292a32", "filename": "crates/hir-def/src/nameres/diagnostics.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/89107d5469dfe978efafe57d70b6f1525b060d46/crates%2Fhir-def%2Fsrc%2Fnameres%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89107d5469dfe978efafe57d70b6f1525b060d46/crates%2Fhir-def%2Fsrc%2Fnameres%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-def%2Fsrc%2Fnameres%2Fdiagnostics.rs?ref=89107d5469dfe978efafe57d70b6f1525b060d46", "patch": "@@ -4,7 +4,7 @@ use base_db::CrateId;\n use cfg::{CfgExpr, CfgOptions};\n use hir_expand::MacroCallKind;\n use la_arena::Idx;\n-use syntax::ast;\n+use syntax::ast::{self, AnyHasAttrs};\n \n use crate::{\n     attr::AttrId,\n@@ -22,7 +22,7 @@ pub enum DefDiagnosticKind {\n \n     UnresolvedImport { id: ItemTreeId<item_tree::Import>, index: Idx<ast::UseTree> },\n \n-    UnconfiguredCode { ast: AstId<ast::Item>, cfg: CfgExpr, opts: CfgOptions },\n+    UnconfiguredCode { ast: AstId<AnyHasAttrs>, cfg: CfgExpr, opts: CfgOptions },\n \n     UnresolvedProcMacro { ast: MacroCallKind, krate: CrateId },\n \n@@ -75,7 +75,7 @@ impl DefDiagnostic {\n \n     pub fn unconfigured_code(\n         container: LocalModuleId,\n-        ast: AstId<ast::Item>,\n+        ast: AstId<ast::AnyHasAttrs>,\n         cfg: CfgExpr,\n         opts: CfgOptions,\n     ) -> Self {"}, {"sha": "2b27db0e950630e34601f19640d691f27bad5835", "filename": "crates/hir-expand/src/ast_id_map.rs", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/89107d5469dfe978efafe57d70b6f1525b060d46/crates%2Fhir-expand%2Fsrc%2Fast_id_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89107d5469dfe978efafe57d70b6f1525b060d46/crates%2Fhir-expand%2Fsrc%2Fast_id_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-expand%2Fsrc%2Fast_id_map.rs?ref=89107d5469dfe978efafe57d70b6f1525b060d46", "patch": "@@ -93,7 +93,12 @@ impl AstIdMap {\n         // trait does not change ids of top-level items, which helps caching.\n         bdfs(node, |it| {\n             let kind = it.kind();\n-            if ast::Item::can_cast(kind) || ast::BlockExpr::can_cast(kind) {\n+            if ast::Item::can_cast(kind)\n+                || ast::BlockExpr::can_cast(kind)\n+                || ast::Variant::can_cast(kind)\n+                || ast::RecordField::can_cast(kind)\n+                || ast::TupleField::can_cast(kind)\n+            {\n                 res.alloc(&it);\n                 true\n             } else {"}, {"sha": "c5dc60f1ec5f962e319af3c48191fe2769984243", "filename": "crates/hir/src/diagnostics.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/89107d5469dfe978efafe57d70b6f1525b060d46/crates%2Fhir%2Fsrc%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89107d5469dfe978efafe57d70b6f1525b060d46/crates%2Fhir%2Fsrc%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir%2Fsrc%2Fdiagnostics.rs?ref=89107d5469dfe978efafe57d70b6f1525b060d46", "patch": "@@ -1,7 +1,7 @@\n //! Re-export diagnostics such that clients of `hir` don't have to depend on\n //! low-level crates.\n //!\n-//! This probably isn't the best way to do this -- ideally, diagnistics should\n+//! This probably isn't the best way to do this -- ideally, diagnostics should\n //! be expressed in terms of hir types themselves.\n use base_db::CrateId;\n use cfg::{CfgExpr, CfgOptions};"}, {"sha": "c22e25b0637de1d66229af5d8d7e502728b88eb9", "filename": "crates/ide-diagnostics/src/handlers/inactive_code.rs", "status": "modified", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/89107d5469dfe978efafe57d70b6f1525b060d46/crates%2Fide-diagnostics%2Fsrc%2Fhandlers%2Finactive_code.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89107d5469dfe978efafe57d70b6f1525b060d46/crates%2Fide-diagnostics%2Fsrc%2Fhandlers%2Finactive_code.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-diagnostics%2Fsrc%2Fhandlers%2Finactive_code.rs?ref=89107d5469dfe978efafe57d70b6f1525b060d46", "patch": "@@ -137,6 +137,31 @@ trait Bar {\n \n     #[cfg_attr(not(never), inline, cfg(no))] fn h() {}\n   //^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ weak: code is inactive due to #[cfg] directives: no is disabled\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn inactive_fields() {\n+        check(\n+            r#\"\n+enum Foo {\n+  #[cfg(a)] Bar,\n+//^^^^^^^^^^^^^ weak: code is inactive due to #[cfg] directives: a is disabled\n+}\n+\n+struct Baz {\n+  #[cfg(a)] baz: String,\n+//^^^^^^^^^^^^^^^^^^^^^ weak: code is inactive due to #[cfg] directives: a is disabled\n+}\n+\n+struct Qux(#[cfg(a)] String);\n+         //^^^^^^^^^^^^^^^^ weak: code is inactive due to #[cfg] directives: a is disabled\n+\n+union FooBar {\n+  #[cfg(a)] baz: u32,\n+//^^^^^^^^^^^^^^^^^^ weak: code is inactive due to #[cfg] directives: a is disabled\n+}\n \"#,\n         );\n     }"}, {"sha": "f4664f3aaeae3908df5fc7f80fcb8de180878f0b", "filename": "crates/syntax/src/ast/generated/nodes.rs", "status": "modified", "additions": 567, "deletions": 0, "changes": 567, "blob_url": "https://github.com/rust-lang/rust/blob/89107d5469dfe978efafe57d70b6f1525b060d46/crates%2Fsyntax%2Fsrc%2Fast%2Fgenerated%2Fnodes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89107d5469dfe978efafe57d70b6f1525b060d46/crates%2Fsyntax%2Fsrc%2Fast%2Fgenerated%2Fnodes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fsyntax%2Fsrc%2Fast%2Fgenerated%2Fnodes.rs?ref=89107d5469dfe978efafe57d70b6f1525b060d46", "patch": "@@ -3894,6 +3894,12 @@ impl AstNode for AnyHasArgList {\n     }\n     fn syntax(&self) -> &SyntaxNode { &self.syntax }\n }\n+impl From<CallExpr> for AnyHasArgList {\n+    fn from(node: CallExpr) -> AnyHasArgList { AnyHasArgList::new(node) }\n+}\n+impl From<MethodCallExpr> for AnyHasArgList {\n+    fn from(node: MethodCallExpr) -> AnyHasArgList { AnyHasArgList::new(node) }\n+}\n impl AnyHasAttrs {\n     #[inline]\n     pub fn new<T: ast::HasAttrs>(node: T) -> AnyHasAttrs {\n@@ -3978,6 +3984,207 @@ impl AstNode for AnyHasAttrs {\n     }\n     fn syntax(&self) -> &SyntaxNode { &self.syntax }\n }\n+impl From<MacroCall> for AnyHasAttrs {\n+    fn from(node: MacroCall) -> AnyHasAttrs { AnyHasAttrs::new(node) }\n+}\n+impl From<SourceFile> for AnyHasAttrs {\n+    fn from(node: SourceFile) -> AnyHasAttrs { AnyHasAttrs::new(node) }\n+}\n+impl From<Const> for AnyHasAttrs {\n+    fn from(node: Const) -> AnyHasAttrs { AnyHasAttrs::new(node) }\n+}\n+impl From<Enum> for AnyHasAttrs {\n+    fn from(node: Enum) -> AnyHasAttrs { AnyHasAttrs::new(node) }\n+}\n+impl From<ExternBlock> for AnyHasAttrs {\n+    fn from(node: ExternBlock) -> AnyHasAttrs { AnyHasAttrs::new(node) }\n+}\n+impl From<ExternCrate> for AnyHasAttrs {\n+    fn from(node: ExternCrate) -> AnyHasAttrs { AnyHasAttrs::new(node) }\n+}\n+impl From<Fn> for AnyHasAttrs {\n+    fn from(node: Fn) -> AnyHasAttrs { AnyHasAttrs::new(node) }\n+}\n+impl From<Impl> for AnyHasAttrs {\n+    fn from(node: Impl) -> AnyHasAttrs { AnyHasAttrs::new(node) }\n+}\n+impl From<MacroRules> for AnyHasAttrs {\n+    fn from(node: MacroRules) -> AnyHasAttrs { AnyHasAttrs::new(node) }\n+}\n+impl From<MacroDef> for AnyHasAttrs {\n+    fn from(node: MacroDef) -> AnyHasAttrs { AnyHasAttrs::new(node) }\n+}\n+impl From<Module> for AnyHasAttrs {\n+    fn from(node: Module) -> AnyHasAttrs { AnyHasAttrs::new(node) }\n+}\n+impl From<Static> for AnyHasAttrs {\n+    fn from(node: Static) -> AnyHasAttrs { AnyHasAttrs::new(node) }\n+}\n+impl From<Struct> for AnyHasAttrs {\n+    fn from(node: Struct) -> AnyHasAttrs { AnyHasAttrs::new(node) }\n+}\n+impl From<Trait> for AnyHasAttrs {\n+    fn from(node: Trait) -> AnyHasAttrs { AnyHasAttrs::new(node) }\n+}\n+impl From<TypeAlias> for AnyHasAttrs {\n+    fn from(node: TypeAlias) -> AnyHasAttrs { AnyHasAttrs::new(node) }\n+}\n+impl From<Union> for AnyHasAttrs {\n+    fn from(node: Union) -> AnyHasAttrs { AnyHasAttrs::new(node) }\n+}\n+impl From<Use> for AnyHasAttrs {\n+    fn from(node: Use) -> AnyHasAttrs { AnyHasAttrs::new(node) }\n+}\n+impl From<ItemList> for AnyHasAttrs {\n+    fn from(node: ItemList) -> AnyHasAttrs { AnyHasAttrs::new(node) }\n+}\n+impl From<BlockExpr> for AnyHasAttrs {\n+    fn from(node: BlockExpr) -> AnyHasAttrs { AnyHasAttrs::new(node) }\n+}\n+impl From<SelfParam> for AnyHasAttrs {\n+    fn from(node: SelfParam) -> AnyHasAttrs { AnyHasAttrs::new(node) }\n+}\n+impl From<Param> for AnyHasAttrs {\n+    fn from(node: Param) -> AnyHasAttrs { AnyHasAttrs::new(node) }\n+}\n+impl From<RecordField> for AnyHasAttrs {\n+    fn from(node: RecordField) -> AnyHasAttrs { AnyHasAttrs::new(node) }\n+}\n+impl From<TupleField> for AnyHasAttrs {\n+    fn from(node: TupleField) -> AnyHasAttrs { AnyHasAttrs::new(node) }\n+}\n+impl From<Variant> for AnyHasAttrs {\n+    fn from(node: Variant) -> AnyHasAttrs { AnyHasAttrs::new(node) }\n+}\n+impl From<AssocItemList> for AnyHasAttrs {\n+    fn from(node: AssocItemList) -> AnyHasAttrs { AnyHasAttrs::new(node) }\n+}\n+impl From<ExternItemList> for AnyHasAttrs {\n+    fn from(node: ExternItemList) -> AnyHasAttrs { AnyHasAttrs::new(node) }\n+}\n+impl From<ConstParam> for AnyHasAttrs {\n+    fn from(node: ConstParam) -> AnyHasAttrs { AnyHasAttrs::new(node) }\n+}\n+impl From<LifetimeParam> for AnyHasAttrs {\n+    fn from(node: LifetimeParam) -> AnyHasAttrs { AnyHasAttrs::new(node) }\n+}\n+impl From<TypeParam> for AnyHasAttrs {\n+    fn from(node: TypeParam) -> AnyHasAttrs { AnyHasAttrs::new(node) }\n+}\n+impl From<LetStmt> for AnyHasAttrs {\n+    fn from(node: LetStmt) -> AnyHasAttrs { AnyHasAttrs::new(node) }\n+}\n+impl From<ArrayExpr> for AnyHasAttrs {\n+    fn from(node: ArrayExpr) -> AnyHasAttrs { AnyHasAttrs::new(node) }\n+}\n+impl From<AwaitExpr> for AnyHasAttrs {\n+    fn from(node: AwaitExpr) -> AnyHasAttrs { AnyHasAttrs::new(node) }\n+}\n+impl From<BinExpr> for AnyHasAttrs {\n+    fn from(node: BinExpr) -> AnyHasAttrs { AnyHasAttrs::new(node) }\n+}\n+impl From<BoxExpr> for AnyHasAttrs {\n+    fn from(node: BoxExpr) -> AnyHasAttrs { AnyHasAttrs::new(node) }\n+}\n+impl From<BreakExpr> for AnyHasAttrs {\n+    fn from(node: BreakExpr) -> AnyHasAttrs { AnyHasAttrs::new(node) }\n+}\n+impl From<CallExpr> for AnyHasAttrs {\n+    fn from(node: CallExpr) -> AnyHasAttrs { AnyHasAttrs::new(node) }\n+}\n+impl From<CastExpr> for AnyHasAttrs {\n+    fn from(node: CastExpr) -> AnyHasAttrs { AnyHasAttrs::new(node) }\n+}\n+impl From<ClosureExpr> for AnyHasAttrs {\n+    fn from(node: ClosureExpr) -> AnyHasAttrs { AnyHasAttrs::new(node) }\n+}\n+impl From<ContinueExpr> for AnyHasAttrs {\n+    fn from(node: ContinueExpr) -> AnyHasAttrs { AnyHasAttrs::new(node) }\n+}\n+impl From<FieldExpr> for AnyHasAttrs {\n+    fn from(node: FieldExpr) -> AnyHasAttrs { AnyHasAttrs::new(node) }\n+}\n+impl From<ForExpr> for AnyHasAttrs {\n+    fn from(node: ForExpr) -> AnyHasAttrs { AnyHasAttrs::new(node) }\n+}\n+impl From<IfExpr> for AnyHasAttrs {\n+    fn from(node: IfExpr) -> AnyHasAttrs { AnyHasAttrs::new(node) }\n+}\n+impl From<IndexExpr> for AnyHasAttrs {\n+    fn from(node: IndexExpr) -> AnyHasAttrs { AnyHasAttrs::new(node) }\n+}\n+impl From<Literal> for AnyHasAttrs {\n+    fn from(node: Literal) -> AnyHasAttrs { AnyHasAttrs::new(node) }\n+}\n+impl From<LoopExpr> for AnyHasAttrs {\n+    fn from(node: LoopExpr) -> AnyHasAttrs { AnyHasAttrs::new(node) }\n+}\n+impl From<MatchExpr> for AnyHasAttrs {\n+    fn from(node: MatchExpr) -> AnyHasAttrs { AnyHasAttrs::new(node) }\n+}\n+impl From<MethodCallExpr> for AnyHasAttrs {\n+    fn from(node: MethodCallExpr) -> AnyHasAttrs { AnyHasAttrs::new(node) }\n+}\n+impl From<ParenExpr> for AnyHasAttrs {\n+    fn from(node: ParenExpr) -> AnyHasAttrs { AnyHasAttrs::new(node) }\n+}\n+impl From<PathExpr> for AnyHasAttrs {\n+    fn from(node: PathExpr) -> AnyHasAttrs { AnyHasAttrs::new(node) }\n+}\n+impl From<PrefixExpr> for AnyHasAttrs {\n+    fn from(node: PrefixExpr) -> AnyHasAttrs { AnyHasAttrs::new(node) }\n+}\n+impl From<RangeExpr> for AnyHasAttrs {\n+    fn from(node: RangeExpr) -> AnyHasAttrs { AnyHasAttrs::new(node) }\n+}\n+impl From<RefExpr> for AnyHasAttrs {\n+    fn from(node: RefExpr) -> AnyHasAttrs { AnyHasAttrs::new(node) }\n+}\n+impl From<ReturnExpr> for AnyHasAttrs {\n+    fn from(node: ReturnExpr) -> AnyHasAttrs { AnyHasAttrs::new(node) }\n+}\n+impl From<TryExpr> for AnyHasAttrs {\n+    fn from(node: TryExpr) -> AnyHasAttrs { AnyHasAttrs::new(node) }\n+}\n+impl From<TupleExpr> for AnyHasAttrs {\n+    fn from(node: TupleExpr) -> AnyHasAttrs { AnyHasAttrs::new(node) }\n+}\n+impl From<WhileExpr> for AnyHasAttrs {\n+    fn from(node: WhileExpr) -> AnyHasAttrs { AnyHasAttrs::new(node) }\n+}\n+impl From<YieldExpr> for AnyHasAttrs {\n+    fn from(node: YieldExpr) -> AnyHasAttrs { AnyHasAttrs::new(node) }\n+}\n+impl From<LetExpr> for AnyHasAttrs {\n+    fn from(node: LetExpr) -> AnyHasAttrs { AnyHasAttrs::new(node) }\n+}\n+impl From<UnderscoreExpr> for AnyHasAttrs {\n+    fn from(node: UnderscoreExpr) -> AnyHasAttrs { AnyHasAttrs::new(node) }\n+}\n+impl From<StmtList> for AnyHasAttrs {\n+    fn from(node: StmtList) -> AnyHasAttrs { AnyHasAttrs::new(node) }\n+}\n+impl From<RecordExprFieldList> for AnyHasAttrs {\n+    fn from(node: RecordExprFieldList) -> AnyHasAttrs { AnyHasAttrs::new(node) }\n+}\n+impl From<RecordExprField> for AnyHasAttrs {\n+    fn from(node: RecordExprField) -> AnyHasAttrs { AnyHasAttrs::new(node) }\n+}\n+impl From<MatchArmList> for AnyHasAttrs {\n+    fn from(node: MatchArmList) -> AnyHasAttrs { AnyHasAttrs::new(node) }\n+}\n+impl From<MatchArm> for AnyHasAttrs {\n+    fn from(node: MatchArm) -> AnyHasAttrs { AnyHasAttrs::new(node) }\n+}\n+impl From<IdentPat> for AnyHasAttrs {\n+    fn from(node: IdentPat) -> AnyHasAttrs { AnyHasAttrs::new(node) }\n+}\n+impl From<RestPat> for AnyHasAttrs {\n+    fn from(node: RestPat) -> AnyHasAttrs { AnyHasAttrs::new(node) }\n+}\n+impl From<RecordPatField> for AnyHasAttrs {\n+    fn from(node: RecordPatField) -> AnyHasAttrs { AnyHasAttrs::new(node) }\n+}\n impl AnyHasDocComments {\n     #[inline]\n     pub fn new<T: ast::HasDocComments>(node: T) -> AnyHasDocComments {\n@@ -4015,6 +4222,66 @@ impl AstNode for AnyHasDocComments {\n     }\n     fn syntax(&self) -> &SyntaxNode { &self.syntax }\n }\n+impl From<MacroCall> for AnyHasDocComments {\n+    fn from(node: MacroCall) -> AnyHasDocComments { AnyHasDocComments::new(node) }\n+}\n+impl From<SourceFile> for AnyHasDocComments {\n+    fn from(node: SourceFile) -> AnyHasDocComments { AnyHasDocComments::new(node) }\n+}\n+impl From<Const> for AnyHasDocComments {\n+    fn from(node: Const) -> AnyHasDocComments { AnyHasDocComments::new(node) }\n+}\n+impl From<Enum> for AnyHasDocComments {\n+    fn from(node: Enum) -> AnyHasDocComments { AnyHasDocComments::new(node) }\n+}\n+impl From<ExternBlock> for AnyHasDocComments {\n+    fn from(node: ExternBlock) -> AnyHasDocComments { AnyHasDocComments::new(node) }\n+}\n+impl From<ExternCrate> for AnyHasDocComments {\n+    fn from(node: ExternCrate) -> AnyHasDocComments { AnyHasDocComments::new(node) }\n+}\n+impl From<Fn> for AnyHasDocComments {\n+    fn from(node: Fn) -> AnyHasDocComments { AnyHasDocComments::new(node) }\n+}\n+impl From<Impl> for AnyHasDocComments {\n+    fn from(node: Impl) -> AnyHasDocComments { AnyHasDocComments::new(node) }\n+}\n+impl From<MacroRules> for AnyHasDocComments {\n+    fn from(node: MacroRules) -> AnyHasDocComments { AnyHasDocComments::new(node) }\n+}\n+impl From<MacroDef> for AnyHasDocComments {\n+    fn from(node: MacroDef) -> AnyHasDocComments { AnyHasDocComments::new(node) }\n+}\n+impl From<Module> for AnyHasDocComments {\n+    fn from(node: Module) -> AnyHasDocComments { AnyHasDocComments::new(node) }\n+}\n+impl From<Static> for AnyHasDocComments {\n+    fn from(node: Static) -> AnyHasDocComments { AnyHasDocComments::new(node) }\n+}\n+impl From<Struct> for AnyHasDocComments {\n+    fn from(node: Struct) -> AnyHasDocComments { AnyHasDocComments::new(node) }\n+}\n+impl From<Trait> for AnyHasDocComments {\n+    fn from(node: Trait) -> AnyHasDocComments { AnyHasDocComments::new(node) }\n+}\n+impl From<TypeAlias> for AnyHasDocComments {\n+    fn from(node: TypeAlias) -> AnyHasDocComments { AnyHasDocComments::new(node) }\n+}\n+impl From<Union> for AnyHasDocComments {\n+    fn from(node: Union) -> AnyHasDocComments { AnyHasDocComments::new(node) }\n+}\n+impl From<Use> for AnyHasDocComments {\n+    fn from(node: Use) -> AnyHasDocComments { AnyHasDocComments::new(node) }\n+}\n+impl From<RecordField> for AnyHasDocComments {\n+    fn from(node: RecordField) -> AnyHasDocComments { AnyHasDocComments::new(node) }\n+}\n+impl From<TupleField> for AnyHasDocComments {\n+    fn from(node: TupleField) -> AnyHasDocComments { AnyHasDocComments::new(node) }\n+}\n+impl From<Variant> for AnyHasDocComments {\n+    fn from(node: Variant) -> AnyHasDocComments { AnyHasDocComments::new(node) }\n+}\n impl AnyHasGenericParams {\n     #[inline]\n     pub fn new<T: ast::HasGenericParams>(node: T) -> AnyHasGenericParams {\n@@ -4030,6 +4297,27 @@ impl AstNode for AnyHasGenericParams {\n     }\n     fn syntax(&self) -> &SyntaxNode { &self.syntax }\n }\n+impl From<Enum> for AnyHasGenericParams {\n+    fn from(node: Enum) -> AnyHasGenericParams { AnyHasGenericParams::new(node) }\n+}\n+impl From<Fn> for AnyHasGenericParams {\n+    fn from(node: Fn) -> AnyHasGenericParams { AnyHasGenericParams::new(node) }\n+}\n+impl From<Impl> for AnyHasGenericParams {\n+    fn from(node: Impl) -> AnyHasGenericParams { AnyHasGenericParams::new(node) }\n+}\n+impl From<Struct> for AnyHasGenericParams {\n+    fn from(node: Struct) -> AnyHasGenericParams { AnyHasGenericParams::new(node) }\n+}\n+impl From<Trait> for AnyHasGenericParams {\n+    fn from(node: Trait) -> AnyHasGenericParams { AnyHasGenericParams::new(node) }\n+}\n+impl From<TypeAlias> for AnyHasGenericParams {\n+    fn from(node: TypeAlias) -> AnyHasGenericParams { AnyHasGenericParams::new(node) }\n+}\n+impl From<Union> for AnyHasGenericParams {\n+    fn from(node: Union) -> AnyHasGenericParams { AnyHasGenericParams::new(node) }\n+}\n impl AnyHasLoopBody {\n     #[inline]\n     pub fn new<T: ast::HasLoopBody>(node: T) -> AnyHasLoopBody {\n@@ -4043,6 +4331,15 @@ impl AstNode for AnyHasLoopBody {\n     }\n     fn syntax(&self) -> &SyntaxNode { &self.syntax }\n }\n+impl From<ForExpr> for AnyHasLoopBody {\n+    fn from(node: ForExpr) -> AnyHasLoopBody { AnyHasLoopBody::new(node) }\n+}\n+impl From<LoopExpr> for AnyHasLoopBody {\n+    fn from(node: LoopExpr) -> AnyHasLoopBody { AnyHasLoopBody::new(node) }\n+}\n+impl From<WhileExpr> for AnyHasLoopBody {\n+    fn from(node: WhileExpr) -> AnyHasLoopBody { AnyHasLoopBody::new(node) }\n+}\n impl AnyHasModuleItem {\n     #[inline]\n     pub fn new<T: ast::HasModuleItem>(node: T) -> AnyHasModuleItem {\n@@ -4056,6 +4353,15 @@ impl AstNode for AnyHasModuleItem {\n     }\n     fn syntax(&self) -> &SyntaxNode { &self.syntax }\n }\n+impl From<MacroItems> for AnyHasModuleItem {\n+    fn from(node: MacroItems) -> AnyHasModuleItem { AnyHasModuleItem::new(node) }\n+}\n+impl From<SourceFile> for AnyHasModuleItem {\n+    fn from(node: SourceFile) -> AnyHasModuleItem { AnyHasModuleItem::new(node) }\n+}\n+impl From<ItemList> for AnyHasModuleItem {\n+    fn from(node: ItemList) -> AnyHasModuleItem { AnyHasModuleItem::new(node) }\n+}\n impl AnyHasName {\n     #[inline]\n     pub fn new<T: ast::HasName>(node: T) -> AnyHasName {\n@@ -4091,6 +4397,60 @@ impl AstNode for AnyHasName {\n     }\n     fn syntax(&self) -> &SyntaxNode { &self.syntax }\n }\n+impl From<Const> for AnyHasName {\n+    fn from(node: Const) -> AnyHasName { AnyHasName::new(node) }\n+}\n+impl From<Enum> for AnyHasName {\n+    fn from(node: Enum) -> AnyHasName { AnyHasName::new(node) }\n+}\n+impl From<Fn> for AnyHasName {\n+    fn from(node: Fn) -> AnyHasName { AnyHasName::new(node) }\n+}\n+impl From<MacroRules> for AnyHasName {\n+    fn from(node: MacroRules) -> AnyHasName { AnyHasName::new(node) }\n+}\n+impl From<MacroDef> for AnyHasName {\n+    fn from(node: MacroDef) -> AnyHasName { AnyHasName::new(node) }\n+}\n+impl From<Module> for AnyHasName {\n+    fn from(node: Module) -> AnyHasName { AnyHasName::new(node) }\n+}\n+impl From<Static> for AnyHasName {\n+    fn from(node: Static) -> AnyHasName { AnyHasName::new(node) }\n+}\n+impl From<Struct> for AnyHasName {\n+    fn from(node: Struct) -> AnyHasName { AnyHasName::new(node) }\n+}\n+impl From<Trait> for AnyHasName {\n+    fn from(node: Trait) -> AnyHasName { AnyHasName::new(node) }\n+}\n+impl From<TypeAlias> for AnyHasName {\n+    fn from(node: TypeAlias) -> AnyHasName { AnyHasName::new(node) }\n+}\n+impl From<Union> for AnyHasName {\n+    fn from(node: Union) -> AnyHasName { AnyHasName::new(node) }\n+}\n+impl From<Rename> for AnyHasName {\n+    fn from(node: Rename) -> AnyHasName { AnyHasName::new(node) }\n+}\n+impl From<SelfParam> for AnyHasName {\n+    fn from(node: SelfParam) -> AnyHasName { AnyHasName::new(node) }\n+}\n+impl From<RecordField> for AnyHasName {\n+    fn from(node: RecordField) -> AnyHasName { AnyHasName::new(node) }\n+}\n+impl From<Variant> for AnyHasName {\n+    fn from(node: Variant) -> AnyHasName { AnyHasName::new(node) }\n+}\n+impl From<ConstParam> for AnyHasName {\n+    fn from(node: ConstParam) -> AnyHasName { AnyHasName::new(node) }\n+}\n+impl From<TypeParam> for AnyHasName {\n+    fn from(node: TypeParam) -> AnyHasName { AnyHasName::new(node) }\n+}\n+impl From<IdentPat> for AnyHasName {\n+    fn from(node: IdentPat) -> AnyHasName { AnyHasName::new(node) }\n+}\n impl AnyHasTypeBounds {\n     #[inline]\n     pub fn new<T: ast::HasTypeBounds>(node: T) -> AnyHasTypeBounds {\n@@ -4109,6 +4469,24 @@ impl AstNode for AnyHasTypeBounds {\n     }\n     fn syntax(&self) -> &SyntaxNode { &self.syntax }\n }\n+impl From<AssocTypeArg> for AnyHasTypeBounds {\n+    fn from(node: AssocTypeArg) -> AnyHasTypeBounds { AnyHasTypeBounds::new(node) }\n+}\n+impl From<Trait> for AnyHasTypeBounds {\n+    fn from(node: Trait) -> AnyHasTypeBounds { AnyHasTypeBounds::new(node) }\n+}\n+impl From<TypeAlias> for AnyHasTypeBounds {\n+    fn from(node: TypeAlias) -> AnyHasTypeBounds { AnyHasTypeBounds::new(node) }\n+}\n+impl From<LifetimeParam> for AnyHasTypeBounds {\n+    fn from(node: LifetimeParam) -> AnyHasTypeBounds { AnyHasTypeBounds::new(node) }\n+}\n+impl From<TypeParam> for AnyHasTypeBounds {\n+    fn from(node: TypeParam) -> AnyHasTypeBounds { AnyHasTypeBounds::new(node) }\n+}\n+impl From<WherePred> for AnyHasTypeBounds {\n+    fn from(node: WherePred) -> AnyHasTypeBounds { AnyHasTypeBounds::new(node) }\n+}\n impl AnyHasVisibility {\n     #[inline]\n     pub fn new<T: ast::HasVisibility>(node: T) -> AnyHasVisibility {\n@@ -4143,6 +4521,195 @@ impl AstNode for AnyHasVisibility {\n     }\n     fn syntax(&self) -> &SyntaxNode { &self.syntax }\n }\n+impl From<Const> for AnyHasVisibility {\n+    fn from(node: Const) -> AnyHasVisibility { AnyHasVisibility::new(node) }\n+}\n+impl From<Enum> for AnyHasVisibility {\n+    fn from(node: Enum) -> AnyHasVisibility { AnyHasVisibility::new(node) }\n+}\n+impl From<ExternCrate> for AnyHasVisibility {\n+    fn from(node: ExternCrate) -> AnyHasVisibility { AnyHasVisibility::new(node) }\n+}\n+impl From<Fn> for AnyHasVisibility {\n+    fn from(node: Fn) -> AnyHasVisibility { AnyHasVisibility::new(node) }\n+}\n+impl From<Impl> for AnyHasVisibility {\n+    fn from(node: Impl) -> AnyHasVisibility { AnyHasVisibility::new(node) }\n+}\n+impl From<MacroRules> for AnyHasVisibility {\n+    fn from(node: MacroRules) -> AnyHasVisibility { AnyHasVisibility::new(node) }\n+}\n+impl From<MacroDef> for AnyHasVisibility {\n+    fn from(node: MacroDef) -> AnyHasVisibility { AnyHasVisibility::new(node) }\n+}\n+impl From<Module> for AnyHasVisibility {\n+    fn from(node: Module) -> AnyHasVisibility { AnyHasVisibility::new(node) }\n+}\n+impl From<Static> for AnyHasVisibility {\n+    fn from(node: Static) -> AnyHasVisibility { AnyHasVisibility::new(node) }\n+}\n+impl From<Struct> for AnyHasVisibility {\n+    fn from(node: Struct) -> AnyHasVisibility { AnyHasVisibility::new(node) }\n+}\n+impl From<Trait> for AnyHasVisibility {\n+    fn from(node: Trait) -> AnyHasVisibility { AnyHasVisibility::new(node) }\n+}\n+impl From<TypeAlias> for AnyHasVisibility {\n+    fn from(node: TypeAlias) -> AnyHasVisibility { AnyHasVisibility::new(node) }\n+}\n+impl From<Union> for AnyHasVisibility {\n+    fn from(node: Union) -> AnyHasVisibility { AnyHasVisibility::new(node) }\n+}\n+impl From<Use> for AnyHasVisibility {\n+    fn from(node: Use) -> AnyHasVisibility { AnyHasVisibility::new(node) }\n+}\n+impl From<RecordField> for AnyHasVisibility {\n+    fn from(node: RecordField) -> AnyHasVisibility { AnyHasVisibility::new(node) }\n+}\n+impl From<TupleField> for AnyHasVisibility {\n+    fn from(node: TupleField) -> AnyHasVisibility { AnyHasVisibility::new(node) }\n+}\n+impl From<Variant> for AnyHasVisibility {\n+    fn from(node: Variant) -> AnyHasVisibility { AnyHasVisibility::new(node) }\n+}\n+impl From<Item> for AnyHasAttrs {\n+    fn from(node: Item) -> AnyHasAttrs {\n+        match node {\n+            Item::Const(it) => AnyHasAttrs::new(it),\n+            Item::Enum(it) => AnyHasAttrs::new(it),\n+            Item::ExternBlock(it) => AnyHasAttrs::new(it),\n+            Item::ExternCrate(it) => AnyHasAttrs::new(it),\n+            Item::Fn(it) => AnyHasAttrs::new(it),\n+            Item::Impl(it) => AnyHasAttrs::new(it),\n+            Item::MacroCall(it) => AnyHasAttrs::new(it),\n+            Item::MacroRules(it) => AnyHasAttrs::new(it),\n+            Item::MacroDef(it) => AnyHasAttrs::new(it),\n+            Item::Module(it) => AnyHasAttrs::new(it),\n+            Item::Static(it) => AnyHasAttrs::new(it),\n+            Item::Struct(it) => AnyHasAttrs::new(it),\n+            Item::Trait(it) => AnyHasAttrs::new(it),\n+            Item::TypeAlias(it) => AnyHasAttrs::new(it),\n+            Item::Union(it) => AnyHasAttrs::new(it),\n+            Item::Use(it) => AnyHasAttrs::new(it),\n+        }\n+    }\n+}\n+impl From<Adt> for AnyHasAttrs {\n+    fn from(node: Adt) -> AnyHasAttrs {\n+        match node {\n+            Adt::Enum(it) => AnyHasAttrs::new(it),\n+            Adt::Struct(it) => AnyHasAttrs::new(it),\n+            Adt::Union(it) => AnyHasAttrs::new(it),\n+        }\n+    }\n+}\n+impl From<AssocItem> for AnyHasAttrs {\n+    fn from(node: AssocItem) -> AnyHasAttrs {\n+        match node {\n+            AssocItem::Const(it) => AnyHasAttrs::new(it),\n+            AssocItem::Fn(it) => AnyHasAttrs::new(it),\n+            AssocItem::MacroCall(it) => AnyHasAttrs::new(it),\n+            AssocItem::TypeAlias(it) => AnyHasAttrs::new(it),\n+        }\n+    }\n+}\n+impl From<ExternItem> for AnyHasAttrs {\n+    fn from(node: ExternItem) -> AnyHasAttrs {\n+        match node {\n+            ExternItem::Fn(it) => AnyHasAttrs::new(it),\n+            ExternItem::MacroCall(it) => AnyHasAttrs::new(it),\n+            ExternItem::Static(it) => AnyHasAttrs::new(it),\n+            ExternItem::TypeAlias(it) => AnyHasAttrs::new(it),\n+        }\n+    }\n+}\n+impl From<GenericParam> for AnyHasAttrs {\n+    fn from(node: GenericParam) -> AnyHasAttrs {\n+        match node {\n+            GenericParam::ConstParam(it) => AnyHasAttrs::new(it),\n+            GenericParam::LifetimeParam(it) => AnyHasAttrs::new(it),\n+            GenericParam::TypeParam(it) => AnyHasAttrs::new(it),\n+        }\n+    }\n+}\n+impl From<Item> for AnyHasDocComments {\n+    fn from(node: Item) -> AnyHasDocComments {\n+        match node {\n+            Item::Const(it) => AnyHasDocComments::new(it),\n+            Item::Enum(it) => AnyHasDocComments::new(it),\n+            Item::ExternBlock(it) => AnyHasDocComments::new(it),\n+            Item::ExternCrate(it) => AnyHasDocComments::new(it),\n+            Item::Fn(it) => AnyHasDocComments::new(it),\n+            Item::Impl(it) => AnyHasDocComments::new(it),\n+            Item::MacroCall(it) => AnyHasDocComments::new(it),\n+            Item::MacroRules(it) => AnyHasDocComments::new(it),\n+            Item::MacroDef(it) => AnyHasDocComments::new(it),\n+            Item::Module(it) => AnyHasDocComments::new(it),\n+            Item::Static(it) => AnyHasDocComments::new(it),\n+            Item::Struct(it) => AnyHasDocComments::new(it),\n+            Item::Trait(it) => AnyHasDocComments::new(it),\n+            Item::TypeAlias(it) => AnyHasDocComments::new(it),\n+            Item::Union(it) => AnyHasDocComments::new(it),\n+            Item::Use(it) => AnyHasDocComments::new(it),\n+        }\n+    }\n+}\n+impl From<Adt> for AnyHasDocComments {\n+    fn from(node: Adt) -> AnyHasDocComments {\n+        match node {\n+            Adt::Enum(it) => AnyHasDocComments::new(it),\n+            Adt::Struct(it) => AnyHasDocComments::new(it),\n+            Adt::Union(it) => AnyHasDocComments::new(it),\n+        }\n+    }\n+}\n+impl From<AssocItem> for AnyHasDocComments {\n+    fn from(node: AssocItem) -> AnyHasDocComments {\n+        match node {\n+            AssocItem::Const(it) => AnyHasDocComments::new(it),\n+            AssocItem::Fn(it) => AnyHasDocComments::new(it),\n+            AssocItem::MacroCall(it) => AnyHasDocComments::new(it),\n+            AssocItem::TypeAlias(it) => AnyHasDocComments::new(it),\n+        }\n+    }\n+}\n+impl From<ExternItem> for AnyHasDocComments {\n+    fn from(node: ExternItem) -> AnyHasDocComments {\n+        match node {\n+            ExternItem::Fn(it) => AnyHasDocComments::new(it),\n+            ExternItem::MacroCall(it) => AnyHasDocComments::new(it),\n+            ExternItem::Static(it) => AnyHasDocComments::new(it),\n+            ExternItem::TypeAlias(it) => AnyHasDocComments::new(it),\n+        }\n+    }\n+}\n+impl From<Adt> for AnyHasGenericParams {\n+    fn from(node: Adt) -> AnyHasGenericParams {\n+        match node {\n+            Adt::Enum(it) => AnyHasGenericParams::new(it),\n+            Adt::Struct(it) => AnyHasGenericParams::new(it),\n+            Adt::Union(it) => AnyHasGenericParams::new(it),\n+        }\n+    }\n+}\n+impl From<Adt> for AnyHasName {\n+    fn from(node: Adt) -> AnyHasName {\n+        match node {\n+            Adt::Enum(it) => AnyHasName::new(it),\n+            Adt::Struct(it) => AnyHasName::new(it),\n+            Adt::Union(it) => AnyHasName::new(it),\n+        }\n+    }\n+}\n+impl From<Adt> for AnyHasVisibility {\n+    fn from(node: Adt) -> AnyHasVisibility {\n+        match node {\n+            Adt::Enum(it) => AnyHasVisibility::new(it),\n+            Adt::Struct(it) => AnyHasVisibility::new(it),\n+            Adt::Union(it) => AnyHasVisibility::new(it),\n+        }\n+    }\n+}\n impl std::fmt::Display for GenericArg {\n     fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n         std::fmt::Display::fmt(self.syntax(), f)"}, {"sha": "56d7c98d58a3e62a5825498098cd6f8c8ad04e67", "filename": "crates/syntax/src/tests/sourcegen_ast.rs", "status": "modified", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/89107d5469dfe978efafe57d70b6f1525b060d46/crates%2Fsyntax%2Fsrc%2Ftests%2Fsourcegen_ast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89107d5469dfe978efafe57d70b6f1525b060d46/crates%2Fsyntax%2Fsrc%2Ftests%2Fsourcegen_ast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fsyntax%2Fsrc%2Ftests%2Fsourcegen_ast.rs?ref=89107d5469dfe978efafe57d70b6f1525b060d46", "patch": "@@ -229,6 +229,7 @@ fn generate_nodes(kinds: KindsSrc<'_>, grammar: &AstSrc) -> String {\n                 .iter()\n                 .map(|name| format_ident!(\"{}\", to_upper_snake_case(&name.name.to_string())))\n                 .collect();\n+            let node_names: Vec<_> = nodes.iter().map(|n| format_ident!(\"{}\", n.name)).collect();\n \n             (\n                 quote! {\n@@ -259,11 +260,43 @@ fn generate_nodes(kinds: KindsSrc<'_>, grammar: &AstSrc) -> String {\n                             &self.syntax\n                         }\n                     }\n+\n+                    #(\n+                        impl From<#node_names> for #name {\n+                            fn from(node: #node_names) -> #name {\n+                                #name::new(node)\n+                            }\n+                        }\n+                    )*\n                 },\n             )\n         })\n         .unzip();\n \n+    let any_enum_boilerplate_impls: Vec<_> = grammar\n+        .enums\n+        .iter()\n+        .flat_map(|en| en.traits.iter().map(move |t| (t, en)))\n+        .sorted_by_key(|(k, _)| *k)\n+        .map(|(target_name, en)| {\n+            let target_name = format_ident!(\"Any{}\", target_name);\n+            let enum_name = format_ident!(\"{}\", en.name);\n+            let variants: Vec<_> = en.variants.iter().map(|var| format_ident!(\"{}\", var)).collect();\n+\n+            quote! {\n+                impl From<#enum_name> for #target_name {\n+                    fn from(node: #enum_name) -> #target_name {\n+                        match node {\n+                            #(\n+                                #enum_name::#variants(it) => #target_name::new(it),\n+                            )*\n+                        }\n+                    }\n+                }\n+            }\n+        })\n+        .collect();\n+\n     let enum_names = grammar.enums.iter().map(|it| &it.name);\n     let node_names = grammar.nodes.iter().map(|it| &it.name);\n \n@@ -305,6 +338,7 @@ fn generate_nodes(kinds: KindsSrc<'_>, grammar: &AstSrc) -> String {\n         #(#node_boilerplate_impls)*\n         #(#enum_boilerplate_impls)*\n         #(#any_node_boilerplate_impls)*\n+        #(#any_enum_boilerplate_impls)*\n         #(#display_impls)*\n     };\n "}]}