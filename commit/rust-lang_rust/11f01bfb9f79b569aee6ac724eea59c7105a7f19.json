{"sha": "11f01bfb9f79b569aee6ac724eea59c7105a7f19", "node_id": "MDY6Q29tbWl0NzI0NzEyOjExZjAxYmZiOWY3OWI1NjlhZWU2YWM3MjRlZWE1OWM3MTA1YTdmMTk=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-05-22T22:57:48Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-05-22T22:57:48Z"}, "message": "Auto merge of #61044 - Centril:rollup-ztsgb9p, r=Centril\n\nRollup of 8 pull requests\n\nSuccessful merges:\n\n - #60300 (Allow null-pointer-optimized enums in FFI if their underlying representation is FFI safe)\n - #60773 (Always try to project predicates when finding auto traits in rustdoc)\n - #60809 (Add FAQ for NLL migration)\n - #61023 (Migrate from recursion to iterate on qualify consts visitor impl)\n - #61029 (Simplify RefCell minimum_spanning_tree example)\n - #61030 (Make maybe_codegen_consume_direct iterate instead of doing recursion)\n - #61034 (rustc_metadata: parametrize schema::CrateRoot by 'tcx and rip out old unused incremental infra.)\n - #61037 (Update clippy submodule)\n\nFailed merges:\n\nr? @ghost", "tree": {"sha": "98c0858868a7f91e62eb087072cb4332a0fa0e18", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/98c0858868a7f91e62eb087072cb4332a0fa0e18"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/11f01bfb9f79b569aee6ac724eea59c7105a7f19", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/11f01bfb9f79b569aee6ac724eea59c7105a7f19", "html_url": "https://github.com/rust-lang/rust/commit/11f01bfb9f79b569aee6ac724eea59c7105a7f19", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/11f01bfb9f79b569aee6ac724eea59c7105a7f19/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "37ff5d388f8c004ca248adb635f1cc84d347eda0", "url": "https://api.github.com/repos/rust-lang/rust/commits/37ff5d388f8c004ca248adb635f1cc84d347eda0", "html_url": "https://github.com/rust-lang/rust/commit/37ff5d388f8c004ca248adb635f1cc84d347eda0"}, {"sha": "68065173c72ae426fcae9a708cabb739eab8110a", "url": "https://api.github.com/repos/rust-lang/rust/commits/68065173c72ae426fcae9a708cabb739eab8110a", "html_url": "https://github.com/rust-lang/rust/commit/68065173c72ae426fcae9a708cabb739eab8110a"}], "stats": {"total": 1420, "additions": 582, "deletions": 838}, "files": [{"sha": "9672cf4ffed36860db66de3fac8a5c2d5768ceeb", "filename": "src/libcore/cell.rs", "status": "modified", "additions": 22, "deletions": 24, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/11f01bfb9f79b569aee6ac724eea59c7105a7f19/src%2Flibcore%2Fcell.rs", "raw_url": "https://github.com/rust-lang/rust/raw/11f01bfb9f79b569aee6ac724eea59c7105a7f19/src%2Flibcore%2Fcell.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fcell.rs?ref=11f01bfb9f79b569aee6ac724eea59c7105a7f19", "patch": "@@ -67,16 +67,26 @@\n //! mutability:\n //!\n //! ```\n+//! use std::cell::{RefCell, RefMut};\n //! use std::collections::HashMap;\n-//! use std::cell::RefCell;\n //! use std::rc::Rc;\n //!\n //! fn main() {\n //!     let shared_map: Rc<RefCell<_>> = Rc::new(RefCell::new(HashMap::new()));\n-//!     shared_map.borrow_mut().insert(\"africa\", 92388);\n-//!     shared_map.borrow_mut().insert(\"kyoto\", 11837);\n-//!     shared_map.borrow_mut().insert(\"piccadilly\", 11826);\n-//!     shared_map.borrow_mut().insert(\"marbles\", 38);\n+//!     // Create a new block to limit the scope of the dynamic borrow\n+//!     {\n+//!         let mut map: RefMut<_> = shared_map.borrow_mut();\n+//!         map.insert(\"africa\", 92388);\n+//!         map.insert(\"kyoto\", 11837);\n+//!         map.insert(\"piccadilly\", 11826);\n+//!         map.insert(\"marbles\", 38);\n+//!     }\n+//!\n+//!     // Note that if we had not let the previous borrow of the cache fall out\n+//!     // of scope then the subsequent borrow would cause a dynamic thread panic.\n+//!     // This is the major hazard of using `RefCell`.\n+//!     let total: i32 = shared_map.borrow().values().sum();\n+//!     println!(\"{}\", total);\n //! }\n //! ```\n //!\n@@ -102,27 +112,15 @@\n //!\n //! impl Graph {\n //!     fn minimum_spanning_tree(&self) -> Vec<(i32, i32)> {\n-//!         // Create a new scope to contain the lifetime of the\n-//!         // dynamic borrow\n-//!         {\n-//!             // Take a reference to the inside of cache cell\n-//!             let mut cache = self.span_tree_cache.borrow_mut();\n-//!             if cache.is_some() {\n-//!                 return cache.as_ref().unwrap().clone();\n-//!             }\n-//!\n-//!             let span_tree = self.calc_span_tree();\n-//!             *cache = Some(span_tree);\n-//!         }\n+//!         self.span_tree_cache.borrow_mut()\n+//!             .get_or_insert_with(|| self.calc_span_tree())\n+//!             .clone()\n+//!     }\n //!\n-//!         // Recursive call to return the just-cached value.\n-//!         // Note that if we had not let the previous borrow\n-//!         // of the cache fall out of scope then the subsequent\n-//!         // recursive borrow would cause a dynamic thread panic.\n-//!         // This is the major hazard of using `RefCell`.\n-//!         self.minimum_spanning_tree()\n+//!     fn calc_span_tree(&self) -> Vec<(i32, i32)> {\n+//!         // Expensive computation goes here\n+//!         vec![]\n //!     }\n-//! #   fn calc_span_tree(&self) -> Vec<(i32, i32)> { vec![] }\n //! }\n //! ```\n //!"}, {"sha": "932c0eaa4c7b1ede320ad45c12243fb25f68f27e", "filename": "src/libcore/num/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/11f01bfb9f79b569aee6ac724eea59c7105a7f19/src%2Flibcore%2Fnum%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/11f01bfb9f79b569aee6ac724eea59c7105a7f19/src%2Flibcore%2Fnum%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fmod.rs?ref=11f01bfb9f79b569aee6ac724eea59c7105a7f19", "patch": "@@ -50,6 +50,7 @@ assert_eq!(size_of::<Option<core::num::\", stringify!($Ty), \">>(), size_of::<\", s\n                 #[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd, Hash)]\n                 #[repr(transparent)]\n                 #[rustc_layout_scalar_valid_range_start(1)]\n+                #[cfg_attr(not(stage0), rustc_nonnull_optimization_guaranteed)]\n                 pub struct $Ty($Int);\n             }\n "}, {"sha": "4bb4d3ee46660796840a2e89ba73d03eb37be558", "filename": "src/libcore/ptr.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/11f01bfb9f79b569aee6ac724eea59c7105a7f19/src%2Flibcore%2Fptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/11f01bfb9f79b569aee6ac724eea59c7105a7f19/src%2Flibcore%2Fptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fptr.rs?ref=11f01bfb9f79b569aee6ac724eea59c7105a7f19", "patch": "@@ -2938,6 +2938,7 @@ impl<'a, T: ?Sized> From<NonNull<T>> for Unique<T> {\n #[stable(feature = \"nonnull\", since = \"1.25.0\")]\n #[repr(transparent)]\n #[rustc_layout_scalar_valid_range_start(1)]\n+#[cfg_attr(not(stage0), rustc_nonnull_optimization_guaranteed)]\n pub struct NonNull<T: ?Sized> {\n     pointer: *const T,\n }"}, {"sha": "2fa896962daf9f6c5442241ee41188b62bdd0409", "filename": "src/librustc/traits/auto_trait.rs", "status": "modified", "additions": 68, "deletions": 17, "changes": 85, "blob_url": "https://github.com/rust-lang/rust/blob/11f01bfb9f79b569aee6ac724eea59c7105a7f19/src%2Flibrustc%2Ftraits%2Fauto_trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/11f01bfb9f79b569aee6ac724eea59c7105a7f19/src%2Flibrustc%2Ftraits%2Fauto_trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fauto_trait.rs?ref=11f01bfb9f79b569aee6ac724eea59c7105a7f19", "patch": "@@ -700,22 +700,64 @@ impl<'a, 'tcx> AutoTraitFinder<'a, 'tcx> {\n                             }\n                     }\n \n-                    // We can only call poly_project_and_unify_type when our predicate's\n-                    // Ty contains an inference variable - otherwise, there won't be anything to\n-                    // unify\n-                    if p.ty().skip_binder().has_infer_types() {\n-                        debug!(\"Projecting and unifying projection predicate {:?}\",\n-                               predicate);\n-                        match poly_project_and_unify_type(select, &obligation.with(p)) {\n-                            Err(e) => {\n-                                debug!(\n-                                    \"evaluate_nested_obligations: Unable to unify predicate \\\n-                                     '{:?}' '{:?}', bailing out\",\n-                                    ty, e\n-                                );\n-                                return false;\n-                            }\n-                            Ok(Some(v)) => {\n+                    // There are three possible cases when we project a predicate:\n+                    //\n+                    // 1. We encounter an error. This means that it's impossible for\n+                    // our current type to implement the auto trait - there's bound\n+                    // that we could add to our ParamEnv that would 'fix' this kind\n+                    // of error, as it's not caused by an unimplemented type.\n+                    //\n+                    // 2. We succesfully project the predicate (Ok(Some(_))), generating\n+                    //  some subobligations. We then process these subobligations\n+                    //  like any other generated sub-obligations.\n+                    //\n+                    // 3. We receieve an 'ambiguous' result (Ok(None))\n+                    // If we were actually trying to compile a crate,\n+                    // we would need to re-process this obligation later.\n+                    // However, all we care about is finding out what bounds\n+                    // are needed for our type to implement a particular auto trait.\n+                    // We've already added this obligation to our computed ParamEnv\n+                    // above (if it was necessary). Therefore, we don't need\n+                    // to do any further processing of the obligation.\n+                    //\n+                    // Note that we *must* try to project *all* projection predicates\n+                    // we encounter, even ones without inference variable.\n+                    // This ensures that we detect any projection errors,\n+                    // which indicate that our type can *never* implement the given\n+                    // auto trait. In that case, we will generate an explicit negative\n+                    // impl (e.g. 'impl !Send for MyType'). However, we don't\n+                    // try to process any of the generated subobligations -\n+                    // they contain no new information, since we already know\n+                    // that our type implements the projected-through trait,\n+                    // and can lead to weird region issues.\n+                    //\n+                    // Normally, we'll generate a negative impl as a result of encountering\n+                    // a type with an explicit negative impl of an auto trait\n+                    // (for example, raw pointers have !Send and !Sync impls)\n+                    // However, through some **interesting** manipulations of the type\n+                    // system, it's actually possible to write a type that never\n+                    // implements an auto trait due to a projection error, not a normal\n+                    // negative impl error. To properly handle this case, we need\n+                    // to ensure that we catch any potential projection errors,\n+                    // and turn them into an explicit negative impl for our type.\n+                    debug!(\"Projecting and unifying projection predicate {:?}\",\n+                           predicate);\n+\n+                    match poly_project_and_unify_type(select, &obligation.with(p)) {\n+                        Err(e) => {\n+                            debug!(\n+                                \"evaluate_nested_obligations: Unable to unify predicate \\\n+                                 '{:?}' '{:?}', bailing out\",\n+                                ty, e\n+                            );\n+                            return false;\n+                        }\n+                        Ok(Some(v)) => {\n+                            // We only care about sub-obligations\n+                            // when we started out trying to unify\n+                            // some inference variables. See the comment above\n+                            // for more infomration\n+                            if p.ty().skip_binder().has_infer_types() {\n                                 if !self.evaluate_nested_obligations(\n                                     ty,\n                                     v.clone().iter().cloned(),\n@@ -728,7 +770,16 @@ impl<'a, 'tcx> AutoTraitFinder<'a, 'tcx> {\n                                     return false;\n                                 }\n                             }\n-                            Ok(None) => {\n+                        }\n+                        Ok(None) => {\n+                            // It's ok not to make progress when hvave no inference variables -\n+                            // in that case, we were only performing unifcation to check if an\n+                            // error occured (which would indicate that it's impossible for our\n+                            // type to implement the auto trait).\n+                            // However, we should always make progress (either by generating\n+                            // subobligations or getting an error) when we started off with\n+                            // inference variables\n+                            if p.ty().skip_binder().has_infer_types() {\n                                 panic!(\"Unexpected result when selecting {:?} {:?}\", ty, obligation)\n                             }\n                         }"}, {"sha": "3db05b7214d659578533a4cc4ca701dc8ef9d5ce", "filename": "src/librustc_codegen_ssa/mir/operand.rs", "status": "modified", "additions": 36, "deletions": 34, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/11f01bfb9f79b569aee6ac724eea59c7105a7f19/src%2Flibrustc_codegen_ssa%2Fmir%2Foperand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/11f01bfb9f79b569aee6ac724eea59c7105a7f19/src%2Flibrustc_codegen_ssa%2Fmir%2Foperand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fmir%2Foperand.rs?ref=11f01bfb9f79b569aee6ac724eea59c7105a7f19", "patch": "@@ -380,45 +380,47 @@ impl<'a, 'tcx: 'a, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n     ) -> Option<OperandRef<'tcx, Bx::Value>> {\n         debug!(\"maybe_codegen_consume_direct(place={:?})\", place);\n \n-        // watch out for locals that do not have an\n-        // alloca; they are handled somewhat differently\n-        if let mir::Place::Base(mir::PlaceBase::Local(index)) = *place {\n-            match self.locals[index] {\n-                LocalRef::Operand(Some(o)) => {\n-                    return Some(o);\n-                }\n-                LocalRef::Operand(None) => {\n-                    bug!(\"use of {:?} before def\", place);\n-                }\n-                LocalRef::Place(..) | LocalRef::UnsizedPlace(..) => {\n-                    // use path below\n-                }\n-            }\n-        }\n+        place.iterate(|place_base, place_projection| {\n+            if let mir::PlaceBase::Local(index) = place_base {\n+                match self.locals[*index] {\n+                    LocalRef::Operand(Some(mut o)) => {\n+                        // Moves out of scalar and scalar pair fields are trivial.\n+                        for proj in place_projection {\n+                            match proj.elem {\n+                                mir::ProjectionElem::Field(ref f, _) => {\n+                                    o = o.extract_field(bx, f.index());\n+                                }\n+                                mir::ProjectionElem::Index(_) |\n+                                mir::ProjectionElem::ConstantIndex { .. } => {\n+                                    // ZSTs don't require any actual memory access.\n+                                    // FIXME(eddyb) deduplicate this with the identical\n+                                    // checks in `codegen_consume` and `extract_field`.\n+                                    let elem = o.layout.field(bx.cx(), 0);\n+                                    if elem.is_zst() {\n+                                        o = OperandRef::new_zst(bx, elem);\n+                                    } else {\n+                                        return None;\n+                                    }\n+                                }\n+                                _ => return None,\n+                            }\n+                        }\n \n-        // Moves out of scalar and scalar pair fields are trivial.\n-        if let &mir::Place::Projection(ref proj) = place {\n-            if let Some(o) = self.maybe_codegen_consume_direct(bx, &proj.base) {\n-                match proj.elem {\n-                    mir::ProjectionElem::Field(ref f, _) => {\n-                        return Some(o.extract_field(bx, f.index()));\n+                        Some(o)\n                     }\n-                    mir::ProjectionElem::Index(_) |\n-                    mir::ProjectionElem::ConstantIndex { .. } => {\n-                        // ZSTs don't require any actual memory access.\n-                        // FIXME(eddyb) deduplicate this with the identical\n-                        // checks in `codegen_consume` and `extract_field`.\n-                        let elem = o.layout.field(bx.cx(), 0);\n-                        if elem.is_zst() {\n-                            return Some(OperandRef::new_zst(bx, elem));\n-                        }\n+                    LocalRef::Operand(None) => {\n+                        bug!(\"use of {:?} before def\", place);\n+                    }\n+                    LocalRef::Place(..) | LocalRef::UnsizedPlace(..) => {\n+                        // watch out for locals that do not have an\n+                        // alloca; they are handled somewhat differently\n+                        None\n                     }\n-                    _ => {}\n                 }\n+            } else {\n+                None\n             }\n-        }\n-\n-        None\n+        })\n     }\n \n     pub fn codegen_consume("}, {"sha": "ac18e131c4a3d7aafcf62cb5a1dd0e6b02d6546f", "filename": "src/librustc_lint/types.rs", "status": "modified", "additions": 70, "deletions": 38, "changes": 108, "blob_url": "https://github.com/rust-lang/rust/blob/11f01bfb9f79b569aee6ac724eea59c7105a7f19/src%2Flibrustc_lint%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/11f01bfb9f79b569aee6ac724eea59c7105a7f19/src%2Flibrustc_lint%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Ftypes.rs?ref=11f01bfb9f79b569aee6ac724eea59c7105a7f19", "patch": "@@ -1,10 +1,11 @@\n #![allow(non_snake_case)]\n \n use rustc::hir::{ExprKind, Node};\n+use crate::hir::def_id::DefId;\n use rustc::hir::lowering::is_range_literal;\n use rustc::ty::subst::SubstsRef;\n use rustc::ty::{self, AdtKind, ParamEnv, Ty, TyCtxt};\n-use rustc::ty::layout::{self, IntegerExt, LayoutOf, VariantIdx};\n+use rustc::ty::layout::{self, IntegerExt, LayoutOf, VariantIdx, SizeSkeleton};\n use rustc::{lint, util};\n use rustc_data_structures::indexed_vec::Idx;\n use util::nodemap::FxHashSet;\n@@ -14,11 +15,11 @@ use lint::{LintPass, LateLintPass};\n use std::cmp;\n use std::{i8, i16, i32, i64, u8, u16, u32, u64, f32, f64};\n \n-use syntax::{ast, attr};\n+use syntax::{ast, attr, source_map};\n use syntax::errors::Applicability;\n+use syntax::symbol::sym;\n use rustc_target::spec::abi::Abi;\n use syntax_pos::Span;\n-use syntax::source_map;\n \n use rustc::hir;\n \n@@ -522,42 +523,79 @@ enum FfiResult<'tcx> {\n     },\n }\n \n+fn is_zst<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, did: DefId, ty: Ty<'tcx>) -> bool {\n+    tcx.layout_of(tcx.param_env(did).and(ty)).map(|layout| layout.is_zst()).unwrap_or(false)\n+}\n+\n+fn ty_is_known_nonnull<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, ty: Ty<'tcx>) -> bool {\n+    match ty.sty {\n+        ty::FnPtr(_) => true,\n+        ty::Ref(..) => true,\n+        ty::Adt(field_def, substs) if field_def.repr.transparent() && field_def.is_struct() => {\n+            for field in &field_def.non_enum_variant().fields {\n+                let field_ty = tcx.normalize_erasing_regions(\n+                    ParamEnv::reveal_all(),\n+                    field.ty(tcx, substs),\n+                );\n+                if is_zst(tcx, field.did, field_ty) {\n+                    continue;\n+                }\n+\n+                let attrs = tcx.get_attrs(field_def.did);\n+                if attrs.iter().any(|a| a.check_name(sym::rustc_nonnull_optimization_guaranteed)) ||\n+                    ty_is_known_nonnull(tcx, field_ty) {\n+                    return true;\n+                }\n+            }\n+\n+            false\n+        }\n+        _ => false,\n+    }\n+}\n+\n /// Check if this enum can be safely exported based on the\n /// \"nullable pointer optimization\". Currently restricted\n-/// to function pointers and references, but could be\n-/// expanded to cover NonZero raw pointers and newtypes.\n+/// to function pointers, references, core::num::NonZero*,\n+/// core::ptr::NonNull, and #[repr(transparent)] newtypes.\n /// FIXME: This duplicates code in codegen.\n fn is_repr_nullable_ptr<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                                  def: &'tcx ty::AdtDef,\n+                                  ty: Ty<'tcx>,\n+                                  ty_def: &'tcx ty::AdtDef,\n                                   substs: SubstsRef<'tcx>)\n                                   -> bool {\n-    if def.variants.len() == 2 {\n-        let data_idx;\n+    if ty_def.variants.len() != 2 {\n+        return false;\n+    }\n \n-        let zero = VariantIdx::new(0);\n-        let one = VariantIdx::new(1);\n+    let get_variant_fields = |index| &ty_def.variants[VariantIdx::new(index)].fields;\n+    let variant_fields = [get_variant_fields(0), get_variant_fields(1)];\n+    let fields = if variant_fields[0].is_empty() {\n+        &variant_fields[1]\n+    } else if variant_fields[1].is_empty() {\n+        &variant_fields[0]\n+    } else {\n+        return false;\n+    };\n \n-        if def.variants[zero].fields.is_empty() {\n-            data_idx = one;\n-        } else if def.variants[one].fields.is_empty() {\n-            data_idx = zero;\n-        } else {\n-            return false;\n-        }\n+    if fields.len() != 1 {\n+        return false;\n+    }\n \n-        if def.variants[data_idx].fields.len() == 1 {\n-            match def.variants[data_idx].fields[0].ty(tcx, substs).sty {\n-                ty::FnPtr(_) => {\n-                    return true;\n-                }\n-                ty::Ref(..) => {\n-                    return true;\n-                }\n-                _ => {}\n-            }\n-        }\n+    let field_ty = fields[0].ty(tcx, substs);\n+    if !ty_is_known_nonnull(tcx, field_ty) {\n+        return false;\n     }\n-    false\n+\n+    // At this point, the field's type is known to be nonnull and the parent enum is Option-like.\n+    // If the computed size for the field and the enum are different, the nonnull optimization isn't\n+    // being applied (and we've got a problem somewhere).\n+    let compute_size_skeleton = |t| SizeSkeleton::compute(t, tcx, ParamEnv::reveal_all()).unwrap();\n+    if !compute_size_skeleton(ty).same_size(compute_size_skeleton(field_ty)) {\n+        bug!(\"improper_ctypes: Option nonnull optimization not applied?\");\n+    }\n+\n+    true\n }\n \n impl<'a, 'tcx> ImproperCTypesVisitor<'a, 'tcx> {\n@@ -612,14 +650,8 @@ impl<'a, 'tcx> ImproperCTypesVisitor<'a, 'tcx> {\n                             );\n                             // repr(transparent) types are allowed to have arbitrary ZSTs, not just\n                             // PhantomData -- skip checking all ZST fields\n-                            if def.repr.transparent() {\n-                                let is_zst = cx\n-                                    .layout_of(cx.param_env(field.did).and(field_ty))\n-                                    .map(|layout| layout.is_zst())\n-                                    .unwrap_or(false);\n-                                if is_zst {\n-                                    continue;\n-                                }\n+                            if def.repr.transparent() && is_zst(cx, field.did, field_ty) {\n+                                continue;\n                             }\n                             let r = self.check_type_for_ffi(cache, field_ty);\n                             match r {\n@@ -682,7 +714,7 @@ impl<'a, 'tcx> ImproperCTypesVisitor<'a, 'tcx> {\n                         // discriminant.\n                         if !def.repr.c() && def.repr.int.is_none() {\n                             // Special-case types like `Option<extern fn()>`.\n-                            if !is_repr_nullable_ptr(cx, def, substs) {\n+                            if !is_repr_nullable_ptr(cx, ty, def, substs) {\n                                 return FfiUnsafe {\n                                     ty: ty,\n                                     reason: \"enum has no representation hint\","}, {"sha": "991bebc647d0f7ca48822c1af358f2010ba1c2e7", "filename": "src/librustc_metadata/creader.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/11f01bfb9f79b569aee6ac724eea59c7105a7f19/src%2Flibrustc_metadata%2Fcreader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/11f01bfb9f79b569aee6ac724eea59c7105a7f19/src%2Flibrustc_metadata%2Fcreader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fcreader.rs?ref=11f01bfb9f79b569aee6ac724eea59c7105a7f19", "patch": "@@ -162,7 +162,7 @@ impl<'a> CrateLoader<'a> {\n \n     fn verify_no_symbol_conflicts(&self,\n                                   span: Span,\n-                                  root: &CrateRoot) {\n+                                  root: &CrateRoot<'_>) {\n         // Check for (potential) conflicts with the local crate\n         if self.local_crate_name == root.name &&\n            self.sess.local_crate_disambiguator() == root.disambiguator {\n@@ -476,7 +476,7 @@ impl<'a> CrateLoader<'a> {\n     // Go through the crate metadata and load any crates that it references\n     fn resolve_crate_deps(&mut self,\n                           root: &Option<CratePaths>,\n-                          crate_root: &CrateRoot,\n+                          crate_root: &CrateRoot<'_>,\n                           metadata: &MetadataBlob,\n                           krate: CrateNum,\n                           span: Span,\n@@ -582,7 +582,7 @@ impl<'a> CrateLoader<'a> {\n     /// implemented as dynamic libraries, but we have a possible future where\n     /// custom derive (and other macro-1.1 style features) are implemented via\n     /// executables and custom IPC.\n-    fn load_derive_macros(&mut self, root: &CrateRoot, dylib: Option<PathBuf>, span: Span)\n+    fn load_derive_macros(&mut self, root: &CrateRoot<'_>, dylib: Option<PathBuf>, span: Span)\n                           -> Vec<(ast::Name, Lrc<SyntaxExtension>)> {\n         use std::{env, mem};\n         use crate::dynamic_lib::DynamicLibrary;"}, {"sha": "5d8fabc7e69aeac1d01c3fc74c311948d3d2078a", "filename": "src/librustc_metadata/cstore.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/11f01bfb9f79b569aee6ac724eea59c7105a7f19/src%2Flibrustc_metadata%2Fcstore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/11f01bfb9f79b569aee6ac724eea59c7105a7f19/src%2Flibrustc_metadata%2Fcstore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fcstore.rs?ref=11f01bfb9f79b569aee6ac724eea59c7105a7f19", "patch": "@@ -64,7 +64,11 @@ pub struct CrateMetadata {\n     /// Used for decoding interpret::AllocIds in a cached & thread-safe manner.\n     pub alloc_decoding_state: AllocDecodingState,\n \n-    pub root: schema::CrateRoot,\n+    // NOTE(eddyb) we pass `'static` to a `'tcx` parameter because this\n+    // lifetime is only used behind `Lazy` / `LazySeq`, and therefore\n+    // acts like an universal (`for<'tcx>`), that is paired up with\n+    // whichever `TyCtxt` is being used to decode those values.\n+    pub root: schema::CrateRoot<'static>,\n \n     /// For each public item in this crate, we encode a key. When the\n     /// crate is loaded, we read all the keys and put them in this"}, {"sha": "49f93c4014dc06ad40724f724d9372bb346820dc", "filename": "src/librustc_metadata/cstore_impl.rs", "status": "modified", "additions": 1, "deletions": 6, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/11f01bfb9f79b569aee6ac724eea59c7105a7f19/src%2Flibrustc_metadata%2Fcstore_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/11f01bfb9f79b569aee6ac724eea59c7105a7f19/src%2Flibrustc_metadata%2Fcstore_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fcstore_impl.rs?ref=11f01bfb9f79b569aee6ac724eea59c7105a7f19", "patch": "@@ -246,12 +246,7 @@ provide! { <'tcx> tcx, def_id, other, cdata,\n \n     used_crate_source => { Lrc::new(cdata.source.clone()) }\n \n-    exported_symbols => {\n-        let cnum = cdata.cnum;\n-        assert!(cnum != LOCAL_CRATE);\n-\n-        Arc::new(cdata.exported_symbols(tcx))\n-    }\n+    exported_symbols => { Arc::new(cdata.exported_symbols(tcx)) }\n }\n \n pub fn provide<'tcx>(providers: &mut Providers<'tcx>) {"}, {"sha": "a89cfe42eaaf45f96a604c2a48107ee35eae6b88", "filename": "src/librustc_metadata/decoder.rs", "status": "modified", "additions": 5, "deletions": 8, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/11f01bfb9f79b569aee6ac724eea59c7105a7f19/src%2Flibrustc_metadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/11f01bfb9f79b569aee6ac724eea59c7105a7f19/src%2Flibrustc_metadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fdecoder.rs?ref=11f01bfb9f79b569aee6ac724eea59c7105a7f19", "patch": "@@ -365,7 +365,7 @@ for DecodeContext<'a, 'tcx> {\n \n implement_ty_decoder!( DecodeContext<'a, 'tcx> );\n \n-impl<'a, 'tcx> MetadataBlob {\n+impl<'tcx> MetadataBlob {\n     pub fn is_compatible(&self) -> bool {\n         self.raw_bytes().starts_with(METADATA_HEADER)\n     }\n@@ -374,7 +374,7 @@ impl<'a, 'tcx> MetadataBlob {\n         Lazy::with_position(METADATA_HEADER.len() + 4).decode(self)\n     }\n \n-    pub fn get_root(&self) -> CrateRoot {\n+    pub fn get_root(&self) -> CrateRoot<'tcx> {\n         let slice = self.raw_bytes();\n         let offset = METADATA_HEADER.len();\n         let pos = (((slice[offset + 0] as u32) << 24) | ((slice[offset + 1] as u32) << 16) |\n@@ -444,7 +444,7 @@ impl<'tcx> EntryKind<'tcx> {\n ///  |- proc macro #0 (DefIndex 1:N)\n ///  |- proc macro #1 (DefIndex 1:N+1)\n ///  \\- ...\n-crate fn proc_macro_def_path_table(crate_root: &CrateRoot,\n+crate fn proc_macro_def_path_table(crate_root: &CrateRoot<'_>,\n                                    proc_macros: &[(ast::Name, Lrc<SyntaxExtension>)])\n                                    -> DefPathTable\n {\n@@ -475,7 +475,7 @@ impl<'a, 'tcx> CrateMetadata {\n \n     fn maybe_entry(&self, item_id: DefIndex) -> Option<Lazy<Entry<'tcx>>> {\n         assert!(!self.is_proc_macro(item_id));\n-        self.root.index.lookup(self.blob.raw_bytes(), item_id)\n+        self.root.entries_index.lookup(self.blob.raw_bytes(), item_id)\n     }\n \n     fn entry(&self, item_id: DefIndex) -> Entry<'tcx> {\n@@ -1126,10 +1126,7 @@ impl<'a, 'tcx> CrateMetadata {\n             // link those in so we skip those crates.\n             vec![]\n         } else {\n-            let lazy_seq: LazySeq<(ExportedSymbol<'tcx>, SymbolExportLevel)> =\n-                LazySeq::with_position_and_length(self.root.exported_symbols.position,\n-                                                  self.root.exported_symbols.len);\n-            lazy_seq.decode((self, tcx)).collect()\n+            self.root.exported_symbols.decode((self, tcx)).collect()\n         }\n     }\n "}, {"sha": "6711e54053a178a8575d1d13a20d68731b554130", "filename": "src/librustc_metadata/encoder.rs", "status": "modified", "additions": 127, "deletions": 162, "changes": 289, "blob_url": "https://github.com/rust-lang/rust/blob/11f01bfb9f79b569aee6ac724eea59c7105a7f19/src%2Flibrustc_metadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/11f01bfb9f79b569aee6ac724eea59c7105a7f19/src%2Flibrustc_metadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fencoder.rs?ref=11f01bfb9f79b569aee6ac724eea59c7105a7f19", "patch": "@@ -1,6 +1,4 @@\n use crate::index::Index;\n-use crate::index_builder::{FromId, IndexBuilder, Untracked};\n-use crate::isolated_encoder::IsolatedEncoder;\n use crate::schema::*;\n \n use rustc::middle::cstore::{LinkagePreference, NativeLibrary,\n@@ -46,6 +44,8 @@ pub struct EncodeContext<'a, 'tcx: 'a> {\n     opaque: opaque::Encoder,\n     pub tcx: TyCtxt<'a, 'tcx, 'tcx>,\n \n+    entries_index: Index<'tcx>,\n+\n     lazy_state: LazyState,\n     type_shorthands: FxHashMap<Ty<'tcx>, usize>,\n     predicate_shorthands: FxHashMap<ty::Predicate<'tcx>, usize>,\n@@ -300,28 +300,34 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n         })\n     }\n \n-    // Encodes something that corresponds to a single DepNode::GlobalMetaData\n-    // and registers the Fingerprint in the `metadata_hashes` map.\n-    pub fn tracked<'x, DATA, R>(&'x mut self,\n-                                op: fn(&mut IsolatedEncoder<'x, 'a, 'tcx>, DATA) -> R,\n-                                data: DATA)\n-                                -> R {\n-        op(&mut IsolatedEncoder::new(self), data)\n+    /// Emit the data for a `DefId` to the metadata. The function to\n+    /// emit the data is `op`, and it will be given `data` as\n+    /// arguments. This `record` function will call `op` to generate\n+    /// the `Entry` (which may point to other encoded information)\n+    /// and will then record the `Lazy<Entry>` for use in the index.\n+    // FIXME(eddyb) remove this.\n+    pub fn record<DATA>(&mut self,\n+                        id: DefId,\n+                        op: impl FnOnce(&mut Self, DATA) -> Entry<'tcx>,\n+                        data: DATA)\n+    {\n+        assert!(id.is_local());\n+\n+        let entry = op(self, data);\n+        let entry = self.lazy(&entry);\n+        self.entries_index.record(id, entry);\n     }\n \n-    fn encode_info_for_items(&mut self) -> Index {\n+    fn encode_info_for_items(&mut self) {\n         let krate = self.tcx.hir().krate();\n-        let mut index = IndexBuilder::new(self);\n         let vis = Spanned { span: syntax_pos::DUMMY_SP, node: hir::VisibilityKind::Public };\n-        index.record(DefId::local(CRATE_DEF_INDEX),\n-                     IsolatedEncoder::encode_info_for_mod,\n-                     FromId(hir::CRATE_HIR_ID, (&krate.module, &krate.attrs, &vis)));\n-        let mut visitor = EncodeVisitor { index };\n-        krate.visit_all_item_likes(&mut visitor.as_deep_visitor());\n+        self.record(DefId::local(CRATE_DEF_INDEX),\n+                     EncodeContext::encode_info_for_mod,\n+                     (hir::CRATE_HIR_ID, &krate.module, &krate.attrs, &vis));\n+        krate.visit_all_item_likes(&mut self.as_deep_visitor());\n         for macro_def in &krate.exported_macros {\n-            visitor.visit_macro_def(macro_def);\n+            self.visit_macro_def(macro_def);\n         }\n-        visitor.index.into_items()\n     }\n \n     fn encode_def_path_table(&mut self) -> Lazy<DefPathTable> {\n@@ -371,38 +377,30 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n         self.lazy_seq_ref(adapted.iter().map(|rc| &**rc))\n     }\n \n-    fn encode_crate_root(&mut self) -> Lazy<CrateRoot> {\n+    fn encode_crate_root(&mut self) -> Lazy<CrateRoot<'tcx>> {\n         let mut i = self.position();\n \n-        let crate_deps = self.tracked(IsolatedEncoder::encode_crate_deps, ());\n-        let dylib_dependency_formats = self.tracked(\n-            IsolatedEncoder::encode_dylib_dependency_formats,\n-            ());\n+        let crate_deps = self.encode_crate_deps();\n+        let dylib_dependency_formats = self.encode_dylib_dependency_formats();\n         let dep_bytes = self.position() - i;\n \n         // Encode the lib features.\n         i = self.position();\n-        let lib_features = self.tracked(IsolatedEncoder::encode_lib_features, ());\n+        let lib_features = self.encode_lib_features();\n         let lib_feature_bytes = self.position() - i;\n \n         // Encode the language items.\n         i = self.position();\n-        let lang_items = self.tracked(IsolatedEncoder::encode_lang_items, ());\n-        let lang_items_missing = self.tracked(\n-            IsolatedEncoder::encode_lang_items_missing,\n-            ());\n+        let lang_items = self.encode_lang_items();\n+        let lang_items_missing = self.encode_lang_items_missing();\n         let lang_item_bytes = self.position() - i;\n \n         // Encode the native libraries used\n         i = self.position();\n-        let native_libraries = self.tracked(\n-            IsolatedEncoder::encode_native_libraries,\n-            ());\n+        let native_libraries = self.encode_native_libraries();\n         let native_lib_bytes = self.position() - i;\n \n-        let foreign_modules = self.tracked(\n-            IsolatedEncoder::encode_foreign_modules,\n-            ());\n+        let foreign_modules = self.encode_foreign_modules();\n \n         // Encode source_map\n         i = self.position();\n@@ -416,22 +414,20 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n \n         // Encode the def IDs of impls, for coherence checking.\n         i = self.position();\n-        let impls = self.tracked(IsolatedEncoder::encode_impls, ());\n+        let impls = self.encode_impls();\n         let impl_bytes = self.position() - i;\n \n         // Encode exported symbols info.\n         i = self.position();\n         let exported_symbols = self.tcx.exported_symbols(LOCAL_CRATE);\n-        let exported_symbols = self.tracked(\n-            IsolatedEncoder::encode_exported_symbols,\n-            &exported_symbols);\n+        let exported_symbols = self.encode_exported_symbols(&exported_symbols);\n         let exported_symbols_bytes = self.position() - i;\n \n         let tcx = self.tcx;\n \n         // Encode the items.\n         i = self.position();\n-        let items = self.encode_info_for_items();\n+        self.encode_info_for_items();\n         let item_bytes = self.position() - i;\n \n         // Encode the allocation index\n@@ -462,10 +458,9 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n             self.lazy_seq(interpret_alloc_index)\n         };\n \n-        // Index the items\n         i = self.position();\n-        let index = items.write_index(&mut self.opaque);\n-        let index_bytes = self.position() - i;\n+        let entries_index = self.entries_index.write_index(&mut self.opaque);\n+        let entries_index_bytes = self.position() - i;\n \n         let attrs = tcx.hir().krate_attrs();\n         let is_proc_macro = tcx.sess.crate_types.borrow().contains(&CrateType::ProcMacro);\n@@ -516,7 +511,7 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n             impls,\n             exported_symbols,\n             interpret_alloc_index,\n-            index,\n+            entries_index,\n         });\n \n         let total_bytes = self.position();\n@@ -539,7 +534,7 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n             println!(\"    exp. symbols bytes: {}\", exported_symbols_bytes);\n             println!(\"  def-path table bytes: {}\", def_path_table_bytes);\n             println!(\"            item bytes: {}\", item_bytes);\n-            println!(\"           index bytes: {}\", index_bytes);\n+            println!(\"   entries index bytes: {}\", entries_index_bytes);\n             println!(\"            zero bytes: {}\", zero_bytes);\n             println!(\"           total bytes: {}\", total_bytes);\n         }\n@@ -548,40 +543,29 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n     }\n }\n \n-// These are methods for encoding various things. They are meant to be used with\n-// IndexBuilder::record() and EncodeContext::tracked(). They actually\n-// would not have to be methods of IsolatedEncoder (free standing functions\n-// taking IsolatedEncoder as first argument would be just fine) but by making\n-// them methods we don't have to repeat the lengthy `<'a, 'b: 'a, 'tcx: 'b>`\n-// clause again and again.\n-impl<'a, 'b: 'a, 'tcx: 'b> IsolatedEncoder<'a, 'b, 'tcx> {\n+impl EncodeContext<'_, 'tcx> {\n     fn encode_variances_of(&mut self, def_id: DefId) -> LazySeq<ty::Variance> {\n-        debug!(\"IsolatedEncoder::encode_variances_of({:?})\", def_id);\n+        debug!(\"EncodeContext::encode_variances_of({:?})\", def_id);\n         let tcx = self.tcx;\n-        self.lazy_seq_from_slice(&tcx.variances_of(def_id))\n+        self.lazy_seq_ref(&tcx.variances_of(def_id)[..])\n     }\n \n     fn encode_item_type(&mut self, def_id: DefId) -> Lazy<Ty<'tcx>> {\n         let tcx = self.tcx;\n         let ty = tcx.type_of(def_id);\n-        debug!(\"IsolatedEncoder::encode_item_type({:?}) => {:?}\", def_id, ty);\n+        debug!(\"EncodeContext::encode_item_type({:?}) => {:?}\", def_id, ty);\n         self.lazy(&ty)\n     }\n \n-    /// Encode data for the given variant of the given ADT. The\n-    /// index of the variant is untracked: this is ok because we\n-    /// will have to lookup the adt-def by its id, and that gives us\n-    /// the right to access any information in the adt-def (including,\n-    /// e.g., the length of the various vectors).\n     fn encode_enum_variant_info(\n         &mut self,\n-        (enum_did, Untracked(index)): (DefId, Untracked<VariantIdx>),\n+        (enum_did, index): (DefId, VariantIdx),\n     ) -> Entry<'tcx> {\n         let tcx = self.tcx;\n         let def = tcx.adt_def(enum_did);\n         let variant = &def.variants[index];\n         let def_id = variant.def_id;\n-        debug!(\"IsolatedEncoder::encode_enum_variant_info({:?})\", def_id);\n+        debug!(\"EncodeContext::encode_enum_variant_info({:?})\", def_id);\n \n         let data = VariantData {\n             ctor_kind: variant.ctor_kind,\n@@ -625,17 +609,15 @@ impl<'a, 'b: 'a, 'tcx: 'b> IsolatedEncoder<'a, 'b, 'tcx> {\n         }\n     }\n \n-    /// Encode the constructor for the given variant of the given ADT. See\n-    /// `encode_enum_variant_info` for an explanation about why the index is untracked.\n     fn encode_enum_variant_ctor(\n         &mut self,\n-        (enum_did, Untracked(index)): (DefId, Untracked<VariantIdx>),\n+        (enum_did, index): (DefId, VariantIdx),\n     ) -> Entry<'tcx> {\n         let tcx = self.tcx;\n         let def = tcx.adt_def(enum_did);\n         let variant = &def.variants[index];\n         let def_id = variant.ctor_def_id.unwrap();\n-        debug!(\"IsolatedEncoder::encode_enum_variant_ctor({:?})\", def_id);\n+        debug!(\"EncodeContext::encode_enum_variant_ctor({:?})\", def_id);\n \n         let data = VariantData {\n             ctor_kind: variant.ctor_kind,\n@@ -681,18 +663,17 @@ impl<'a, 'b: 'a, 'tcx: 'b> IsolatedEncoder<'a, 'b, 'tcx> {\n         }\n     }\n \n-    fn encode_info_for_mod(&mut self,\n-                           FromId(id, (md, attrs, vis)): FromId<(&hir::Mod,\n-                                                                 &[ast::Attribute],\n-                                                                 &hir::Visibility)>)\n-                           -> Entry<'tcx> {\n+    fn encode_info_for_mod(\n+        &mut self,\n+        (id, md, attrs, vis): (hir::HirId, &hir::Mod, &[ast::Attribute], &hir::Visibility),\n+    ) -> Entry<'tcx> {\n         let tcx = self.tcx;\n         let def_id = tcx.hir().local_def_id_from_hir_id(id);\n-        debug!(\"IsolatedEncoder::encode_info_for_mod({:?})\", def_id);\n+        debug!(\"EncodeContext::encode_info_for_mod({:?})\", def_id);\n \n         let data = ModData {\n             reexports: match tcx.module_exports(def_id) {\n-                Some(ref exports) => self.lazy_seq_from_slice(exports.as_slice()),\n+                Some(ref exports) => self.lazy_seq_ref(&exports[..]),\n                 _ => LazySeq::empty(),\n             },\n         };\n@@ -719,23 +700,16 @@ impl<'a, 'b: 'a, 'tcx: 'b> IsolatedEncoder<'a, 'b, 'tcx> {\n         }\n     }\n \n-    /// Encode data for the given field of the given variant of the\n-    /// given ADT. The indices of the variant/field are untracked:\n-    /// this is ok because we will have to lookup the adt-def by its\n-    /// id, and that gives us the right to access any information in\n-    /// the adt-def (including, e.g., the length of the various\n-    /// vectors).\n-    fn encode_field(&mut self,\n-                    (adt_def_id, Untracked((variant_index, field_index))): (DefId,\n-                                                                            Untracked<(VariantIdx,\n-                                                                                       usize)>))\n-                    -> Entry<'tcx> {\n+    fn encode_field(\n+        &mut self,\n+        (adt_def_id, variant_index, field_index): (DefId, VariantIdx, usize),\n+    ) -> Entry<'tcx> {\n         let tcx = self.tcx;\n         let variant = &tcx.adt_def(adt_def_id).variants[variant_index];\n         let field = &variant.fields[field_index];\n \n         let def_id = field.did;\n-        debug!(\"IsolatedEncoder::encode_field({:?})\", def_id);\n+        debug!(\"EncodeContext::encode_field({:?})\", def_id);\n \n         let variant_id = tcx.hir().as_local_hir_id(variant.def_id).unwrap();\n         let variant_data = tcx.hir().expect_variant_data(variant_id);\n@@ -761,7 +735,7 @@ impl<'a, 'b: 'a, 'tcx: 'b> IsolatedEncoder<'a, 'b, 'tcx> {\n     }\n \n     fn encode_struct_ctor(&mut self, (adt_def_id, def_id): (DefId, DefId)) -> Entry<'tcx> {\n-        debug!(\"IsolatedEncoder::encode_struct_ctor({:?})\", def_id);\n+        debug!(\"EncodeContext::encode_struct_ctor({:?})\", def_id);\n         let tcx = self.tcx;\n         let adt_def = tcx.adt_def(adt_def_id);\n         let variant = adt_def.non_enum_variant();\n@@ -821,25 +795,25 @@ impl<'a, 'b: 'a, 'tcx: 'b> IsolatedEncoder<'a, 'b, 'tcx> {\n     }\n \n     fn encode_generics(&mut self, def_id: DefId) -> Lazy<ty::Generics> {\n-        debug!(\"IsolatedEncoder::encode_generics({:?})\", def_id);\n+        debug!(\"EncodeContext::encode_generics({:?})\", def_id);\n         let tcx = self.tcx;\n         self.lazy(tcx.generics_of(def_id))\n     }\n \n     fn encode_predicates(&mut self, def_id: DefId) -> Lazy<ty::GenericPredicates<'tcx>> {\n-        debug!(\"IsolatedEncoder::encode_predicates({:?})\", def_id);\n+        debug!(\"EncodeContext::encode_predicates({:?})\", def_id);\n         let tcx = self.tcx;\n         self.lazy(&tcx.predicates_of(def_id))\n     }\n \n     fn encode_predicates_defined_on(&mut self, def_id: DefId) -> Lazy<ty::GenericPredicates<'tcx>> {\n-        debug!(\"IsolatedEncoder::encode_predicates_defined_on({:?})\", def_id);\n+        debug!(\"EncodeContext::encode_predicates_defined_on({:?})\", def_id);\n         let tcx = self.tcx;\n         self.lazy(&tcx.predicates_defined_on(def_id))\n     }\n \n     fn encode_info_for_trait_item(&mut self, def_id: DefId) -> Entry<'tcx> {\n-        debug!(\"IsolatedEncoder::encode_info_for_trait_item({:?})\", def_id);\n+        debug!(\"EncodeContext::encode_info_for_trait_item({:?})\", def_id);\n         let tcx = self.tcx;\n \n         let hir_id = tcx.hir().as_local_hir_id(def_id).unwrap();\n@@ -949,7 +923,7 @@ impl<'a, 'b: 'a, 'tcx: 'b> IsolatedEncoder<'a, 'b, 'tcx> {\n     }\n \n     fn encode_info_for_impl_item(&mut self, def_id: DefId) -> Entry<'tcx> {\n-        debug!(\"IsolatedEncoder::encode_info_for_impl_item({:?})\", def_id);\n+        debug!(\"EncodeContext::encode_info_for_impl_item({:?})\", def_id);\n         let tcx = self.tcx;\n \n         let hir_id = self.tcx.hir().as_local_hir_id(def_id).unwrap();\n@@ -1064,7 +1038,7 @@ impl<'a, 'b: 'a, 'tcx: 'b> IsolatedEncoder<'a, 'b, 'tcx> {\n \n     // Encodes the inherent implementations of a structure, enumeration, or trait.\n     fn encode_inherent_implementations(&mut self, def_id: DefId) -> LazySeq<DefIndex> {\n-        debug!(\"IsolatedEncoder::encode_inherent_implementations({:?})\", def_id);\n+        debug!(\"EncodeContext::encode_inherent_implementations({:?})\", def_id);\n         let implementations = self.tcx.inherent_impls(def_id);\n         if implementations.is_empty() {\n             LazySeq::empty()\n@@ -1077,12 +1051,12 @@ impl<'a, 'b: 'a, 'tcx: 'b> IsolatedEncoder<'a, 'b, 'tcx> {\n     }\n \n     fn encode_stability(&mut self, def_id: DefId) -> Option<Lazy<attr::Stability>> {\n-        debug!(\"IsolatedEncoder::encode_stability({:?})\", def_id);\n+        debug!(\"EncodeContext::encode_stability({:?})\", def_id);\n         self.tcx.lookup_stability(def_id).map(|stab| self.lazy(stab))\n     }\n \n     fn encode_deprecation(&mut self, def_id: DefId) -> Option<Lazy<attr::Deprecation>> {\n-        debug!(\"IsolatedEncoder::encode_deprecation({:?})\", def_id);\n+        debug!(\"EncodeContext::encode_deprecation({:?})\", def_id);\n         self.tcx.lookup_deprecation(def_id).map(|depr| self.lazy(&depr))\n     }\n \n@@ -1096,7 +1070,7 @@ impl<'a, 'b: 'a, 'tcx: 'b> IsolatedEncoder<'a, 'b, 'tcx> {\n     fn encode_info_for_item(&mut self, (def_id, item): (DefId, &'tcx hir::Item)) -> Entry<'tcx> {\n         let tcx = self.tcx;\n \n-        debug!(\"IsolatedEncoder::encode_info_for_item({:?})\", def_id);\n+        debug!(\"EncodeContext::encode_info_for_item({:?})\", def_id);\n \n         let kind = match item.node {\n             hir::ItemKind::Static(_, hir::MutMutable, _) => EntryKind::MutStatic,\n@@ -1118,7 +1092,7 @@ impl<'a, 'b: 'a, 'tcx: 'b> IsolatedEncoder<'a, 'b, 'tcx> {\n                 EntryKind::Fn(self.lazy(&data))\n             }\n             hir::ItemKind::Mod(ref m) => {\n-                return self.encode_info_for_mod(FromId(item.hir_id, (m, &item.attrs, &item.vis)));\n+                return self.encode_info_for_mod((item.hir_id, m, &item.attrs, &item.vis));\n             }\n             hir::ItemKind::ForeignMod(_) => EntryKind::ForeignMod,\n             hir::ItemKind::GlobalAsm(..) => EntryKind::GlobalAsm,\n@@ -1391,22 +1365,22 @@ impl<'a, 'b: 'a, 'tcx: 'b> IsolatedEncoder<'a, 'b, 'tcx> {\n \n     fn encode_info_for_ty_param(\n         &mut self,\n-        (def_id, Untracked(encode_type)): (DefId, Untracked<bool>),\n+        (def_id, encode_type): (DefId, bool),\n     ) -> Entry<'tcx> {\n-        debug!(\"IsolatedEncoder::encode_info_for_ty_param({:?})\", def_id);\n+        debug!(\"EncodeContext::encode_info_for_ty_param({:?})\", def_id);\n         self.encode_info_for_generic_param(def_id, EntryKind::TypeParam, encode_type)\n     }\n \n     fn encode_info_for_const_param(\n         &mut self,\n         def_id: DefId,\n     ) -> Entry<'tcx> {\n-        debug!(\"IsolatedEncoder::encode_info_for_const_param({:?})\", def_id);\n+        debug!(\"EncodeContext::encode_info_for_const_param({:?})\", def_id);\n         self.encode_info_for_generic_param(def_id, EntryKind::ConstParam, true)\n     }\n \n     fn encode_info_for_closure(&mut self, def_id: DefId) -> Entry<'tcx> {\n-        debug!(\"IsolatedEncoder::encode_info_for_closure({:?})\", def_id);\n+        debug!(\"EncodeContext::encode_info_for_closure({:?})\", def_id);\n         let tcx = self.tcx;\n \n         let tables = self.tcx.typeck_tables_of(def_id);\n@@ -1450,7 +1424,7 @@ impl<'a, 'b: 'a, 'tcx: 'b> IsolatedEncoder<'a, 'b, 'tcx> {\n     }\n \n     fn encode_info_for_anon_const(&mut self, def_id: DefId) -> Entry<'tcx> {\n-        debug!(\"IsolatedEncoder::encode_info_for_anon_const({:?})\", def_id);\n+        debug!(\"EncodeContext::encode_info_for_anon_const({:?})\", def_id);\n         let tcx = self.tcx;\n         let id = tcx.hir().as_local_hir_id(def_id).unwrap();\n         let body_id = tcx.hir().body_owned_by(id);\n@@ -1478,23 +1452,20 @@ impl<'a, 'b: 'a, 'tcx: 'b> IsolatedEncoder<'a, 'b, 'tcx> {\n     }\n \n     fn encode_attributes(&mut self, attrs: &[ast::Attribute]) -> LazySeq<ast::Attribute> {\n-        // NOTE: This must use lazy_seq_from_slice(), not lazy_seq() because\n-        //       we rely on the HashStable specialization for [Attribute]\n-        //       to properly filter things out.\n-        self.lazy_seq_from_slice(attrs)\n+        self.lazy_seq_ref(attrs)\n     }\n \n-    fn encode_native_libraries(&mut self, _: ()) -> LazySeq<NativeLibrary> {\n+    fn encode_native_libraries(&mut self) -> LazySeq<NativeLibrary> {\n         let used_libraries = self.tcx.native_libraries(LOCAL_CRATE);\n         self.lazy_seq(used_libraries.iter().cloned())\n     }\n \n-    fn encode_foreign_modules(&mut self, _: ()) -> LazySeq<ForeignModule> {\n+    fn encode_foreign_modules(&mut self) -> LazySeq<ForeignModule> {\n         let foreign_modules = self.tcx.foreign_modules(LOCAL_CRATE);\n         self.lazy_seq(foreign_modules.iter().cloned())\n     }\n \n-    fn encode_crate_deps(&mut self, _: ()) -> LazySeq<CrateDep> {\n+    fn encode_crate_deps(&mut self) -> LazySeq<CrateDep> {\n         let crates = self.tcx.crates();\n \n         let mut deps = crates\n@@ -1528,13 +1499,13 @@ impl<'a, 'b: 'a, 'tcx: 'b> IsolatedEncoder<'a, 'b, 'tcx> {\n         self.lazy_seq_ref(deps.iter().map(|&(_, ref dep)| dep))\n     }\n \n-    fn encode_lib_features(&mut self, _: ()) -> LazySeq<(ast::Name, Option<ast::Name>)> {\n+    fn encode_lib_features(&mut self) -> LazySeq<(ast::Name, Option<ast::Name>)> {\n         let tcx = self.tcx;\n         let lib_features = tcx.lib_features();\n         self.lazy_seq(lib_features.to_vec())\n     }\n \n-    fn encode_lang_items(&mut self, _: ()) -> LazySeq<(DefIndex, usize)> {\n+    fn encode_lang_items(&mut self) -> LazySeq<(DefIndex, usize)> {\n         let tcx = self.tcx;\n         let lang_items = tcx.lang_items();\n         let lang_items = lang_items.items().iter();\n@@ -1548,14 +1519,14 @@ impl<'a, 'b: 'a, 'tcx: 'b> IsolatedEncoder<'a, 'b, 'tcx> {\n         }))\n     }\n \n-    fn encode_lang_items_missing(&mut self, _: ()) -> LazySeq<lang_items::LangItem> {\n+    fn encode_lang_items_missing(&mut self) -> LazySeq<lang_items::LangItem> {\n         let tcx = self.tcx;\n         self.lazy_seq_ref(&tcx.lang_items().missing)\n     }\n \n     /// Encodes an index, mapping each trait to its (local) implementations.\n-    fn encode_impls(&mut self, _: ()) -> LazySeq<TraitImpls> {\n-        debug!(\"IsolatedEncoder::encode_impls()\");\n+    fn encode_impls(&mut self) -> LazySeq<TraitImpls> {\n+        debug!(\"EncodeContext::encode_impls()\");\n         let tcx = self.tcx;\n         let mut visitor = ImplVisitor {\n             tcx,\n@@ -1580,12 +1551,12 @@ impl<'a, 'b: 'a, 'tcx: 'b> IsolatedEncoder<'a, 'b, 'tcx> {\n \n                 TraitImpls {\n                     trait_id: (trait_def_id.krate.as_u32(), trait_def_id.index),\n-                    impls: self.lazy_seq_from_slice(&impls[..]),\n+                    impls: self.lazy_seq_ref(&impls),\n                 }\n             })\n             .collect();\n \n-        self.lazy_seq_from_slice(&all_impls[..])\n+        self.lazy_seq_ref(&all_impls)\n     }\n \n     // Encodes all symbols exported from this crate into the metadata.\n@@ -1595,13 +1566,13 @@ impl<'a, 'b: 'a, 'tcx: 'b> IsolatedEncoder<'a, 'b, 'tcx> {\n     // symbol associated with them (they weren't translated) or if they're an FFI\n     // definition (as that's not defined in this crate).\n     fn encode_exported_symbols(&mut self,\n-                               exported_symbols: &[(ExportedSymbol<'_>, SymbolExportLevel)])\n-                               -> EncodedExportedSymbols {\n+                               exported_symbols: &[(ExportedSymbol<'tcx>, SymbolExportLevel)])\n+                               -> LazySeq<(ExportedSymbol<'tcx>, SymbolExportLevel)> {\n         // The metadata symbol name is special. It should not show up in\n         // downstream crates.\n         let metadata_symbol_name = SymbolName::new(&metadata_symbol_name(self.tcx));\n \n-        let lazy_seq = self.lazy_seq(exported_symbols\n+        self.lazy_seq(exported_symbols\n             .iter()\n             .filter(|&&(ref exported_symbol, _)| {\n                 match *exported_symbol {\n@@ -1611,15 +1582,10 @@ impl<'a, 'b: 'a, 'tcx: 'b> IsolatedEncoder<'a, 'b, 'tcx> {\n                     _ => true,\n                 }\n             })\n-            .cloned());\n-\n-        EncodedExportedSymbols {\n-            len: lazy_seq.len,\n-            position: lazy_seq.position,\n-        }\n+            .cloned())\n     }\n \n-    fn encode_dylib_dependency_formats(&mut self, _: ()) -> LazySeq<Option<LinkagePreference>> {\n+    fn encode_dylib_dependency_formats(&mut self) -> LazySeq<Option<LinkagePreference>> {\n         match self.tcx.sess.dependency_formats.borrow().get(&config::CrateType::Dylib) {\n             Some(arr) => {\n                 self.lazy_seq(arr.iter().map(|slot| {\n@@ -1641,7 +1607,7 @@ impl<'a, 'b: 'a, 'tcx: 'b> IsolatedEncoder<'a, 'b, 'tcx> {\n                                     -> Entry<'tcx> {\n         let tcx = self.tcx;\n \n-        debug!(\"IsolatedEncoder::encode_info_for_foreign_item({:?})\", def_id);\n+        debug!(\"EncodeContext::encode_info_for_foreign_item({:?})\", def_id);\n \n         let kind = match nitem.node {\n             hir::ForeignItemKind::Fn(_, ref names, _) => {\n@@ -1681,33 +1647,29 @@ impl<'a, 'b: 'a, 'tcx: 'b> IsolatedEncoder<'a, 'b, 'tcx> {\n     }\n }\n \n-struct EncodeVisitor<'a, 'b: 'a, 'tcx: 'b> {\n-    index: IndexBuilder<'a, 'b, 'tcx>,\n-}\n-\n-impl<'a, 'b, 'tcx> Visitor<'tcx> for EncodeVisitor<'a, 'b, 'tcx> {\n+impl Visitor<'tcx> for EncodeContext<'_, 'tcx> {\n     fn nested_visit_map<'this>(&'this mut self) -> NestedVisitorMap<'this, 'tcx> {\n-        NestedVisitorMap::OnlyBodies(&self.index.tcx.hir())\n+        NestedVisitorMap::OnlyBodies(&self.tcx.hir())\n     }\n     fn visit_expr(&mut self, ex: &'tcx hir::Expr) {\n         intravisit::walk_expr(self, ex);\n-        self.index.encode_info_for_expr(ex);\n+        self.encode_info_for_expr(ex);\n     }\n     fn visit_item(&mut self, item: &'tcx hir::Item) {\n         intravisit::walk_item(self, item);\n-        let def_id = self.index.tcx.hir().local_def_id_from_hir_id(item.hir_id);\n+        let def_id = self.tcx.hir().local_def_id_from_hir_id(item.hir_id);\n         match item.node {\n             hir::ItemKind::ExternCrate(_) |\n-            hir::ItemKind::Use(..) => (), // ignore these\n-            _ => self.index.record(def_id, IsolatedEncoder::encode_info_for_item, (def_id, item)),\n+            hir::ItemKind::Use(..) => {} // ignore these\n+            _ => self.record(def_id, EncodeContext::encode_info_for_item, (def_id, item)),\n         }\n-        self.index.encode_addl_info_for_item(item);\n+        self.encode_addl_info_for_item(item);\n     }\n     fn visit_foreign_item(&mut self, ni: &'tcx hir::ForeignItem) {\n         intravisit::walk_foreign_item(self, ni);\n-        let def_id = self.index.tcx.hir().local_def_id_from_hir_id(ni.hir_id);\n-        self.index.record(def_id,\n-                          IsolatedEncoder::encode_info_for_foreign_item,\n+        let def_id = self.tcx.hir().local_def_id_from_hir_id(ni.hir_id);\n+        self.record(def_id,\n+                          EncodeContext::encode_info_for_foreign_item,\n                           (def_id, ni));\n     }\n     fn visit_variant(&mut self,\n@@ -1717,32 +1679,32 @@ impl<'a, 'b, 'tcx> Visitor<'tcx> for EncodeVisitor<'a, 'b, 'tcx> {\n         intravisit::walk_variant(self, v, g, id);\n \n         if let Some(ref discr) = v.node.disr_expr {\n-            let def_id = self.index.tcx.hir().local_def_id_from_hir_id(discr.hir_id);\n-            self.index.record(def_id, IsolatedEncoder::encode_info_for_anon_const, def_id);\n+            let def_id = self.tcx.hir().local_def_id_from_hir_id(discr.hir_id);\n+            self.record(def_id, EncodeContext::encode_info_for_anon_const, def_id);\n         }\n     }\n     fn visit_generics(&mut self, generics: &'tcx hir::Generics) {\n         intravisit::walk_generics(self, generics);\n-        self.index.encode_info_for_generics(generics);\n+        self.encode_info_for_generics(generics);\n     }\n     fn visit_ty(&mut self, ty: &'tcx hir::Ty) {\n         intravisit::walk_ty(self, ty);\n-        self.index.encode_info_for_ty(ty);\n+        self.encode_info_for_ty(ty);\n     }\n     fn visit_macro_def(&mut self, macro_def: &'tcx hir::MacroDef) {\n-        let def_id = self.index.tcx.hir().local_def_id_from_hir_id(macro_def.hir_id);\n-        self.index.record(def_id, IsolatedEncoder::encode_info_for_macro_def, macro_def);\n+        let def_id = self.tcx.hir().local_def_id_from_hir_id(macro_def.hir_id);\n+        self.record(def_id, EncodeContext::encode_info_for_macro_def, macro_def);\n     }\n }\n \n-impl<'a, 'b, 'tcx> IndexBuilder<'a, 'b, 'tcx> {\n+impl EncodeContext<'_, 'tcx> {\n     fn encode_fields(&mut self, adt_def_id: DefId) {\n         let def = self.tcx.adt_def(adt_def_id);\n         for (variant_index, variant) in def.variants.iter_enumerated() {\n             for (field_index, field) in variant.fields.iter().enumerate() {\n                 self.record(field.did,\n-                            IsolatedEncoder::encode_field,\n-                            (adt_def_id, Untracked((variant_index, field_index))));\n+                            EncodeContext::encode_field,\n+                            (adt_def_id, variant_index, field_index));\n             }\n         }\n     }\n@@ -1755,12 +1717,12 @@ impl<'a, 'b, 'tcx> IndexBuilder<'a, 'b, 'tcx> {\n                 GenericParamKind::Type { ref default, .. } => {\n                     self.record(\n                         def_id,\n-                        IsolatedEncoder::encode_info_for_ty_param,\n-                        (def_id, Untracked(default.is_some())),\n+                        EncodeContext::encode_info_for_ty_param,\n+                        (def_id, default.is_some()),\n                     );\n                 }\n                 GenericParamKind::Const { .. } => {\n-                    self.record(def_id, IsolatedEncoder::encode_info_for_const_param, def_id);\n+                    self.record(def_id, EncodeContext::encode_info_for_const_param, def_id);\n                 }\n             }\n         }\n@@ -1770,7 +1732,7 @@ impl<'a, 'b, 'tcx> IndexBuilder<'a, 'b, 'tcx> {\n         match ty.node {\n             hir::TyKind::Array(_, ref length) => {\n                 let def_id = self.tcx.hir().local_def_id_from_hir_id(length.hir_id);\n-                self.record(def_id, IsolatedEncoder::encode_info_for_anon_const, def_id);\n+                self.record(def_id, EncodeContext::encode_info_for_anon_const, def_id);\n             }\n             _ => {}\n         }\n@@ -1780,7 +1742,7 @@ impl<'a, 'b, 'tcx> IndexBuilder<'a, 'b, 'tcx> {\n         match expr.node {\n             hir::ExprKind::Closure(..) => {\n                 let def_id = self.tcx.hir().local_def_id_from_hir_id(expr.hir_id);\n-                self.record(def_id, IsolatedEncoder::encode_info_for_closure, def_id);\n+                self.record(def_id, EncodeContext::encode_info_for_closure, def_id);\n             }\n             _ => {}\n         }\n@@ -1812,13 +1774,13 @@ impl<'a, 'b, 'tcx> IndexBuilder<'a, 'b, 'tcx> {\n                 let def = self.tcx.adt_def(def_id);\n                 for (i, variant) in def.variants.iter_enumerated() {\n                     self.record(variant.def_id,\n-                                IsolatedEncoder::encode_enum_variant_info,\n-                                (def_id, Untracked(i)));\n+                                EncodeContext::encode_enum_variant_info,\n+                                (def_id, i));\n \n                     if let Some(ctor_def_id) = variant.ctor_def_id {\n                         self.record(ctor_def_id,\n-                                    IsolatedEncoder::encode_enum_variant_ctor,\n-                                    (def_id, Untracked(i)));\n+                                    EncodeContext::encode_enum_variant_ctor,\n+                                    (def_id, i));\n                     }\n                 }\n             }\n@@ -1829,7 +1791,7 @@ impl<'a, 'b, 'tcx> IndexBuilder<'a, 'b, 'tcx> {\n                 if let Some(ctor_hir_id) = struct_def.ctor_hir_id() {\n                     let ctor_def_id = self.tcx.hir().local_def_id_from_hir_id(ctor_hir_id);\n                     self.record(ctor_def_id,\n-                                IsolatedEncoder::encode_struct_ctor,\n+                                EncodeContext::encode_struct_ctor,\n                                 (def_id, ctor_def_id));\n                 }\n             }\n@@ -1839,14 +1801,14 @@ impl<'a, 'b, 'tcx> IndexBuilder<'a, 'b, 'tcx> {\n             hir::ItemKind::Impl(..) => {\n                 for &trait_item_def_id in self.tcx.associated_item_def_ids(def_id).iter() {\n                     self.record(trait_item_def_id,\n-                                IsolatedEncoder::encode_info_for_impl_item,\n+                                EncodeContext::encode_info_for_impl_item,\n                                 trait_item_def_id);\n                 }\n             }\n             hir::ItemKind::Trait(..) => {\n                 for &item_def_id in self.tcx.associated_item_def_ids(def_id).iter() {\n                     self.record(item_def_id,\n-                                IsolatedEncoder::encode_info_for_trait_item,\n+                                EncodeContext::encode_info_for_trait_item,\n                                 item_def_id);\n                 }\n             }\n@@ -1911,10 +1873,13 @@ pub fn encode_metadata<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>)\n     // Will be filled with the root position after encoding everything.\n     encoder.emit_raw_bytes(&[0, 0, 0, 0]);\n \n-    let (root, mut result) = {\n+    // Since encoding metadata is not in a query, and nothing is cached,\n+    // there's no need to do dep-graph tracking for any of it.\n+    let (root, mut result) = tcx.dep_graph.with_ignore(move || {\n         let mut ecx = EncodeContext {\n             opaque: encoder,\n             tcx,\n+            entries_index: Index::new(tcx.hir().definitions().def_index_count()),\n             lazy_state: LazyState::NoNode,\n             type_shorthands: Default::default(),\n             predicate_shorthands: Default::default(),\n@@ -1930,7 +1895,7 @@ pub fn encode_metadata<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>)\n         // culminating in the `CrateRoot` which points to all of it.\n         let root = ecx.encode_crate_root();\n         (root, ecx.opaque.into_inner())\n-    };\n+    });\n \n     // Encode the root position.\n     let header = METADATA_HEADER.len();"}, {"sha": "dd2f59922ef9238ca34d6276dce219ab8fed9f03", "filename": "src/librustc_metadata/index.rs", "status": "modified", "additions": 10, "deletions": 7, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/11f01bfb9f79b569aee6ac724eea59c7105a7f19/src%2Flibrustc_metadata%2Findex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/11f01bfb9f79b569aee6ac724eea59c7105a7f19/src%2Flibrustc_metadata%2Findex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Findex.rs?ref=11f01bfb9f79b569aee6ac724eea59c7105a7f19", "patch": "@@ -2,6 +2,7 @@ use crate::schema::*;\n \n use rustc::hir::def_id::{DefId, DefIndex};\n use rustc_serialize::opaque::Encoder;\n+use std::marker::PhantomData;\n use std::u32;\n use log::debug;\n \n@@ -74,23 +75,25 @@ impl FixedSizeEncoding for u32 {\n /// `u32::MAX`. Whenever an index is visited, we fill in the\n /// appropriate spot by calling `record_position`. We should never\n /// visit the same index twice.\n-pub struct Index {\n+pub struct Index<'tcx> {\n     positions: Vec<u8>,\n+    _marker: PhantomData<&'tcx ()>,\n }\n \n-impl Index {\n-    pub fn new(max_index: usize) -> Index {\n+impl Index<'tcx> {\n+    pub fn new(max_index: usize) -> Self {\n         Index {\n             positions: vec![0xff; max_index * 4],\n+            _marker: PhantomData,\n         }\n     }\n \n-    pub fn record(&mut self, def_id: DefId, entry: Lazy<Entry<'_>>) {\n+    pub fn record(&mut self, def_id: DefId, entry: Lazy<Entry<'tcx>>) {\n         assert!(def_id.is_local());\n         self.record_index(def_id.index, entry);\n     }\n \n-    pub fn record_index(&mut self, item: DefIndex, entry: Lazy<Entry<'_>>) {\n+    pub fn record_index(&mut self, item: DefIndex, entry: Lazy<Entry<'tcx>>) {\n         assert!(entry.position < (u32::MAX as usize));\n         let position = entry.position as u32;\n         let array_index = item.index();\n@@ -105,7 +108,7 @@ impl Index {\n         position.write_to_bytes_at(positions, array_index)\n     }\n \n-    pub fn write_index(&self, buf: &mut Encoder) -> LazySeq<Index> {\n+    pub fn write_index(&self, buf: &mut Encoder) -> LazySeq<Self> {\n         let pos = buf.position();\n \n         // First we write the length of the lower range ...\n@@ -116,7 +119,7 @@ impl Index {\n     }\n }\n \n-impl<'tcx> LazySeq<Index> {\n+impl LazySeq<Index<'tcx>> {\n     /// Given the metadata, extract out the offset of a particular\n     /// DefIndex (if any).\n     #[inline(never)]"}, {"sha": "e780693a5a92dda349899727efea5fc4424fa8bf", "filename": "src/librustc_metadata/index_builder.rs", "status": "removed", "additions": 0, "deletions": 224, "changes": 224, "blob_url": "https://github.com/rust-lang/rust/blob/37ff5d388f8c004ca248adb635f1cc84d347eda0/src%2Flibrustc_metadata%2Findex_builder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37ff5d388f8c004ca248adb635f1cc84d347eda0/src%2Flibrustc_metadata%2Findex_builder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Findex_builder.rs?ref=37ff5d388f8c004ca248adb635f1cc84d347eda0", "patch": "@@ -1,224 +0,0 @@\n-//! Builder types for generating the \"item data\" section of the\n-//! metadata. This section winds up looking like this:\n-//!\n-//! ```\n-//! <common::data> // big list of item-like things...\n-//!    <common::data_item> // ...for most `DefId`s, there is an entry.\n-//!    </common::data_item>\n-//! </common::data>\n-//! ```\n-//!\n-//! As we generate this listing, we collect the offset of each\n-//! `data_item` entry and store it in an index. Then, when we load the\n-//! metadata, we can skip right to the metadata for a particular item.\n-//!\n-//! In addition to the offset, we need to track the data that was used\n-//! to generate the contents of each `data_item`. This is so that we\n-//! can figure out which HIR nodes contributed to that data for\n-//! incremental compilation purposes.\n-//!\n-//! The `IndexBuilder` facilitates both of these. It is created\n-//! with an `EncodingContext` (`ecx`), which it encapsulates.\n-//! It has one main method, `record()`. You invoke `record`\n-//! like so to create a new `data_item` element in the list:\n-//!\n-//! ```\n-//! index.record(some_def_id, callback_fn, data)\n-//! ```\n-//!\n-//! What record will do is to (a) record the current offset, (b) emit\n-//! the `common::data_item` tag, and then call `callback_fn` with the\n-//! given data as well as the `EncodingContext`. Once `callback_fn`\n-//! returns, the `common::data_item` tag will be closed.\n-//!\n-//! `EncodingContext` does not offer the `record` method, so that we\n-//! can ensure that `common::data_item` elements are never nested.\n-//!\n-//! In addition, while the `callback_fn` is executing, we will push a\n-//! task `MetaData(some_def_id)`, which can then observe the\n-//! reads/writes that occur in the task. For this reason, the `data`\n-//! argument that is given to the `callback_fn` must implement the\n-//! trait `DepGraphRead`, which indicates how to register reads on the\n-//! data in this new task (note that many types of data, such as\n-//! `DefId`, do not currently require any reads to be registered,\n-//! since they are not derived from a HIR node). This is also why we\n-//! give a callback fn, rather than taking a closure: it allows us to\n-//! easily control precisely what data is given to that fn.\n-\n-use crate::encoder::EncodeContext;\n-use crate::index::Index;\n-use crate::schema::*;\n-use crate::isolated_encoder::IsolatedEncoder;\n-\n-use rustc::hir;\n-use rustc::hir::def_id::DefId;\n-use rustc::ty::TyCtxt;\n-use syntax::ast;\n-\n-use std::ops::{Deref, DerefMut};\n-\n-/// Builder that can encode new items, adding them into the index.\n-/// Item encoding cannot be nested.\n-pub struct IndexBuilder<'a, 'b: 'a, 'tcx: 'b> {\n-    items: Index,\n-    pub ecx: &'a mut EncodeContext<'b, 'tcx>,\n-}\n-\n-impl<'a, 'b, 'tcx> Deref for IndexBuilder<'a, 'b, 'tcx> {\n-    type Target = EncodeContext<'b, 'tcx>;\n-    fn deref(&self) -> &Self::Target {\n-        self.ecx\n-    }\n-}\n-\n-impl<'a, 'b, 'tcx> DerefMut for IndexBuilder<'a, 'b, 'tcx> {\n-    fn deref_mut(&mut self) -> &mut Self::Target {\n-        self.ecx\n-    }\n-}\n-\n-impl<'a, 'b, 'tcx> IndexBuilder<'a, 'b, 'tcx> {\n-    pub fn new(ecx: &'a mut EncodeContext<'b, 'tcx>) -> Self {\n-        IndexBuilder {\n-            items: Index::new(ecx.tcx.hir().definitions().def_index_count()),\n-            ecx,\n-        }\n-    }\n-\n-    /// Emit the data for a `DefId` to the metadata. The function to\n-    /// emit the data is `op`, and it will be given `data` as\n-    /// arguments. This `record` function will call `op` to generate\n-    /// the `Entry` (which may point to other encoded information)\n-    /// and will then record the `Lazy<Entry>` for use in the index.\n-    ///\n-    /// In addition, it will setup a dep-graph task to track what data\n-    /// `op` accesses to generate the metadata, which is later used by\n-    /// incremental compilation to compute a hash for the metadata and\n-    /// track changes.\n-    ///\n-    /// The reason that `op` is a function pointer, and not a closure,\n-    /// is that we want to be able to completely track all data it has\n-    /// access to, so that we can be sure that `DATA: DepGraphRead`\n-    /// holds, and that it is therefore not gaining \"secret\" access to\n-    /// bits of HIR or other state that would not be trackd by the\n-    /// content system.\n-    pub fn record<'x, DATA>(&'x mut self,\n-                            id: DefId,\n-                            op: fn(&mut IsolatedEncoder<'x, 'b, 'tcx>, DATA) -> Entry<'tcx>,\n-                            data: DATA)\n-        where DATA: DepGraphRead\n-    {\n-        assert!(id.is_local());\n-\n-        // We don't track this since we are explicitly computing the incr. comp.\n-        // hashes anyway. In theory we could do some tracking here and use it to\n-        // avoid rehashing things (and instead cache the hashes) but it's\n-        // unclear whether that would be a win since hashing is cheap enough.\n-        self.ecx.tcx.dep_graph.with_ignore(move || {\n-            let mut entry_builder = IsolatedEncoder::new(self.ecx);\n-            let entry = op(&mut entry_builder, data);\n-            let entry = entry_builder.lazy(&entry);\n-\n-            self.items.record(id, entry);\n-        })\n-    }\n-\n-    pub fn into_items(self) -> Index {\n-        self.items\n-    }\n-}\n-\n-/// Trait used for data that can be passed from outside a dep-graph\n-/// task. The data must either be of some safe type, such as a\n-/// `DefId` index, or implement the `read` method so that it can add\n-/// a read of whatever dep-graph nodes are appropriate.\n-pub trait DepGraphRead {\n-    fn read(&self, tcx: TyCtxt<'_, '_, '_>);\n-}\n-\n-impl DepGraphRead for DefId {\n-    fn read(&self, _tcx: TyCtxt<'_, '_, '_>) {}\n-}\n-\n-impl DepGraphRead for ast::NodeId {\n-    fn read(&self, _tcx: TyCtxt<'_, '_, '_>) {}\n-}\n-\n-impl<T> DepGraphRead for Option<T>\n-    where T: DepGraphRead\n-{\n-    fn read(&self, tcx: TyCtxt<'_, '_, '_>) {\n-        match *self {\n-            Some(ref v) => v.read(tcx),\n-            None => (),\n-        }\n-    }\n-}\n-\n-impl<T> DepGraphRead for [T]\n-    where T: DepGraphRead\n-{\n-    fn read(&self, tcx: TyCtxt<'_, '_, '_>) {\n-        for i in self {\n-            i.read(tcx);\n-        }\n-    }\n-}\n-\n-macro_rules! read_tuple {\n-    ($($name:ident),*) => {\n-        impl<$($name),*> DepGraphRead for ($($name),*)\n-            where $($name: DepGraphRead),*\n-        {\n-            #[allow(non_snake_case)]\n-            fn read(&self, tcx: TyCtxt<'_, '_, '_>) {\n-                let &($(ref $name),*) = self;\n-                $($name.read(tcx);)*\n-            }\n-        }\n-    }\n-}\n-read_tuple!(A, B);\n-read_tuple!(A, B, C);\n-\n-macro_rules! read_hir {\n-    ($t:ty) => {\n-        impl<'tcx> DepGraphRead for &'tcx $t {\n-            fn read(&self, tcx: TyCtxt<'_, '_, '_>) {\n-                tcx.hir().read(self.hir_id);\n-            }\n-        }\n-    }\n-}\n-read_hir!(hir::Item);\n-read_hir!(hir::ImplItem);\n-read_hir!(hir::TraitItem);\n-read_hir!(hir::ForeignItem);\n-read_hir!(hir::MacroDef);\n-\n-/// Leaks access to a value of type T without any tracking. This is\n-/// suitable for ambiguous types like `usize`, which *could* represent\n-/// tracked data (e.g., if you read it out of a HIR node) or might not\n-/// (e.g., if it's an index). Adding in an `Untracked` is an\n-/// assertion, essentially, that the data does not need to be tracked\n-/// (or that read edges will be added by some other way).\n-///\n-/// A good idea is to add to each use of `Untracked` an explanation of\n-/// why this value is ok.\n-pub struct Untracked<T>(pub T);\n-\n-impl<T> DepGraphRead for Untracked<T> {\n-    fn read(&self, _tcx: TyCtxt<'_, '_, '_>) {}\n-}\n-\n-/// Newtype that can be used to package up misc data extracted from a\n-/// HIR node that doesn't carry its own ID. This will allow an\n-/// arbitrary `T` to be passed in, but register a read on the given\n-/// `NodeId`.\n-pub struct FromId<T>(pub hir::HirId, pub T);\n-\n-impl<T> DepGraphRead for FromId<T> {\n-    fn read(&self, tcx: TyCtxt<'_, '_, '_>) {\n-        tcx.hir().read(self.0);\n-    }\n-}"}, {"sha": "e879a73e650bb026b0e9c902a703c4185a6f9544", "filename": "src/librustc_metadata/isolated_encoder.rs", "status": "removed", "additions": 0, "deletions": 48, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/37ff5d388f8c004ca248adb635f1cc84d347eda0/src%2Flibrustc_metadata%2Fisolated_encoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37ff5d388f8c004ca248adb635f1cc84d347eda0/src%2Flibrustc_metadata%2Fisolated_encoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fisolated_encoder.rs?ref=37ff5d388f8c004ca248adb635f1cc84d347eda0", "patch": "@@ -1,48 +0,0 @@\n-use crate::encoder::EncodeContext;\n-use crate::schema::{Lazy, LazySeq};\n-use rustc::ty::TyCtxt;\n-use rustc_serialize::Encodable;\n-\n-/// The IsolatedEncoder provides facilities to write to crate metadata while\n-/// making sure that anything going through it is also feed into an ICH hasher.\n-pub struct IsolatedEncoder<'a, 'b: 'a, 'tcx: 'b> {\n-    pub tcx: TyCtxt<'b, 'tcx, 'tcx>,\n-    ecx: &'a mut EncodeContext<'b, 'tcx>,\n-}\n-\n-impl<'a, 'b: 'a, 'tcx: 'b> IsolatedEncoder<'a, 'b, 'tcx> {\n-\n-    pub fn new(ecx: &'a mut EncodeContext<'b, 'tcx>) -> Self {\n-        let tcx = ecx.tcx;\n-        IsolatedEncoder {\n-            tcx,\n-            ecx,\n-        }\n-    }\n-\n-    pub fn lazy<T>(&mut self, value: &T) -> Lazy<T>\n-        where T: Encodable\n-    {\n-        self.ecx.lazy(value)\n-    }\n-\n-    pub fn lazy_seq<I, T>(&mut self, iter: I) -> LazySeq<T>\n-        where I: IntoIterator<Item = T>,\n-              T: Encodable\n-    {\n-        self.ecx.lazy_seq(iter)\n-    }\n-\n-    pub fn lazy_seq_ref<'x, I, T>(&mut self, iter: I) -> LazySeq<T>\n-        where I: IntoIterator<Item = &'x T>,\n-              T: 'x + Encodable\n-    {\n-        self.ecx.lazy_seq_ref(iter)\n-    }\n-\n-    pub fn lazy_seq_from_slice<T>(&mut self, slice: &[T]) -> LazySeq<T>\n-        where T: Encodable\n-    {\n-        self.ecx.lazy_seq_ref(slice.iter())\n-    }\n-}"}, {"sha": "e0b92341575cc98252776ec0609a6f175739f485", "filename": "src/librustc_metadata/lib.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/11f01bfb9f79b569aee6ac724eea59c7105a7f19/src%2Flibrustc_metadata%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/11f01bfb9f79b569aee6ac724eea59c7105a7f19/src%2Flibrustc_metadata%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Flib.rs?ref=11f01bfb9f79b569aee6ac724eea59c7105a7f19", "patch": "@@ -2,6 +2,7 @@\n \n #![feature(box_patterns)]\n #![feature(drain_filter)]\n+#![feature(in_band_lifetimes)]\n #![feature(libc)]\n #![feature(nll)]\n #![feature(proc_macro_internals)]\n@@ -28,12 +29,10 @@ extern crate rustc_data_structures;\n \n mod error_codes;\n \n-mod index_builder;\n mod index;\n mod encoder;\n mod decoder;\n mod cstore_impl;\n-mod isolated_encoder;\n mod schema;\n mod native_libs;\n mod link_args;"}, {"sha": "0ad3251540716306a31594dde118597f6e190e42", "filename": "src/librustc_metadata/schema.rs", "status": "modified", "additions": 5, "deletions": 204, "changes": 209, "blob_url": "https://github.com/rust-lang/rust/blob/11f01bfb9f79b569aee6ac724eea59c7105a7f19/src%2Flibrustc_metadata%2Fschema.rs", "raw_url": "https://github.com/rust-lang/rust/raw/11f01bfb9f79b569aee6ac724eea59c7105a7f19/src%2Flibrustc_metadata%2Fschema.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fschema.rs?ref=11f01bfb9f79b569aee6ac724eea59c7105a7f19", "patch": "@@ -2,8 +2,8 @@ use crate::index;\n \n use rustc::hir;\n use rustc::hir::def::{self, CtorKind};\n-use rustc::hir::def_id::{DefIndex, DefId, CrateNum};\n-use rustc::ich::StableHashingContext;\n+use rustc::hir::def_id::{DefIndex, DefId};\n+use rustc::middle::exported_symbols::{ExportedSymbol, SymbolExportLevel};\n use rustc::middle::cstore::{DepKind, LinkagePreference, NativeLibrary, ForeignModule};\n use rustc::middle::lang_items;\n use rustc::mir;\n@@ -19,10 +19,6 @@ use syntax::symbol::Symbol;\n use syntax_pos::{self, Span};\n \n use std::marker::PhantomData;\n-use std::mem;\n-\n-use rustc_data_structures::stable_hasher::{StableHasher, HashStable,\n-                                           StableHasherResult};\n \n pub fn rustc_version() -> String {\n     format!(\"rustc {}\",\n@@ -91,15 +87,6 @@ impl<T> Clone for Lazy<T> {\n impl<T> serialize::UseSpecializedEncodable for Lazy<T> {}\n impl<T> serialize::UseSpecializedDecodable for Lazy<T> {}\n \n-impl<CTX, T> HashStable<CTX> for Lazy<T> {\n-    fn hash_stable<W: StableHasherResult>(&self,\n-                                          _: &mut CTX,\n-                                          _: &mut StableHasher<W>) {\n-        // There's nothing to do. Whatever got encoded within this Lazy<>\n-        // wrapper has already been hashed.\n-    }\n-}\n-\n /// A sequence of type T referred to by its absolute position\n /// in the metadata and length, and which can be decoded lazily.\n /// The sequence is a single node for the purposes of `Lazy`.\n@@ -148,15 +135,6 @@ impl<T> Clone for LazySeq<T> {\n impl<T> serialize::UseSpecializedEncodable for LazySeq<T> {}\n impl<T> serialize::UseSpecializedDecodable for LazySeq<T> {}\n \n-impl<CTX, T> HashStable<CTX> for LazySeq<T> {\n-    fn hash_stable<W: StableHasherResult>(&self,\n-                                          _: &mut CTX,\n-                                          _: &mut StableHasher<W>) {\n-        // There's nothing to do. Whatever got encoded within this Lazy<>\n-        // wrapper has already been hashed.\n-    }\n-}\n-\n /// Encoding / decoding state for `Lazy` and `LazySeq`.\n #[derive(Copy, Clone, PartialEq, Eq, Debug)]\n pub enum LazyState {\n@@ -174,7 +152,7 @@ pub enum LazyState {\n }\n \n #[derive(RustcEncodable, RustcDecodable)]\n-pub struct CrateRoot {\n+pub struct CrateRoot<'tcx> {\n     pub name: Symbol,\n     pub triple: TargetTriple,\n     pub extra_filename: String,\n@@ -199,10 +177,10 @@ pub struct CrateRoot {\n     pub source_map: LazySeq<syntax_pos::SourceFile>,\n     pub def_path_table: Lazy<hir::map::definitions::DefPathTable>,\n     pub impls: LazySeq<TraitImpls>,\n-    pub exported_symbols: EncodedExportedSymbols,\n+    pub exported_symbols: LazySeq<(ExportedSymbol<'tcx>, SymbolExportLevel)>,\n     pub interpret_alloc_index: LazySeq<u32>,\n \n-    pub index: LazySeq<index::Index>,\n+    pub entries_index: LazySeq<index::Index<'tcx>>,\n \n     pub compiler_builtins: bool,\n     pub needs_allocator: bool,\n@@ -221,36 +199,12 @@ pub struct CrateDep {\n     pub extra_filename: String,\n }\n \n-impl_stable_hash_for!(struct CrateDep {\n-    name,\n-    hash,\n-    kind,\n-    extra_filename\n-});\n-\n #[derive(RustcEncodable, RustcDecodable)]\n pub struct TraitImpls {\n     pub trait_id: (u32, DefIndex),\n     pub impls: LazySeq<DefIndex>,\n }\n \n-impl<'a, 'gcx> HashStable<StableHashingContext<'a>> for TraitImpls {\n-    fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'a>,\n-                                          hasher: &mut StableHasher<W>) {\n-        let TraitImpls {\n-            trait_id: (krate, def_index),\n-            ref impls,\n-        } = *self;\n-\n-        DefId {\n-            krate: CrateNum::from_u32(krate),\n-            index: def_index\n-        }.hash_stable(hcx, hasher);\n-        impls.hash_stable(hcx, hasher);\n-    }\n-}\n-\n #[derive(RustcEncodable, RustcDecodable)]\n pub struct Entry<'tcx> {\n     pub kind: EntryKind<'tcx>,\n@@ -271,23 +225,6 @@ pub struct Entry<'tcx> {\n     pub mir: Option<Lazy<mir::Mir<'tcx>>>,\n }\n \n-impl_stable_hash_for!(struct Entry<'tcx> {\n-    kind,\n-    visibility,\n-    span,\n-    attributes,\n-    children,\n-    stability,\n-    deprecation,\n-    ty,\n-    inherent_impls,\n-    variances,\n-    generics,\n-    predicates,\n-    predicates_defined_on,\n-    mir\n-});\n-\n #[derive(Copy, Clone, RustcEncodable, RustcDecodable)]\n pub enum EntryKind<'tcx> {\n     Const(ConstQualif, Lazy<RenderedConst>),\n@@ -322,129 +259,36 @@ pub enum EntryKind<'tcx> {\n     TraitAlias(Lazy<TraitAliasData<'tcx>>),\n }\n \n-impl<'a, 'gcx> HashStable<StableHashingContext<'a>> for EntryKind<'gcx> {\n-    fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'a>,\n-                                          hasher: &mut StableHasher<W>) {\n-        mem::discriminant(self).hash_stable(hcx, hasher);\n-        match *self {\n-            EntryKind::ImmStatic        |\n-            EntryKind::MutStatic        |\n-            EntryKind::ForeignImmStatic |\n-            EntryKind::ForeignMutStatic |\n-            EntryKind::ForeignMod       |\n-            EntryKind::GlobalAsm        |\n-            EntryKind::ForeignType      |\n-            EntryKind::Field |\n-            EntryKind::Existential |\n-            EntryKind::Type |\n-            EntryKind::TypeParam |\n-            EntryKind::ConstParam => {\n-                // Nothing else to hash here.\n-            }\n-            EntryKind::Const(qualif, ref const_data) => {\n-                qualif.hash_stable(hcx, hasher);\n-                const_data.hash_stable(hcx, hasher);\n-            }\n-            EntryKind::Enum(ref repr_options) => {\n-                repr_options.hash_stable(hcx, hasher);\n-            }\n-            EntryKind::Variant(ref variant_data) => {\n-                variant_data.hash_stable(hcx, hasher);\n-            }\n-            EntryKind::Struct(ref variant_data, ref repr_options) |\n-            EntryKind::Union(ref variant_data, ref repr_options)  => {\n-                variant_data.hash_stable(hcx, hasher);\n-                repr_options.hash_stable(hcx, hasher);\n-            }\n-            EntryKind::Fn(ref fn_data) |\n-            EntryKind::ForeignFn(ref fn_data) => {\n-                fn_data.hash_stable(hcx, hasher);\n-            }\n-            EntryKind::Mod(ref mod_data) => {\n-                mod_data.hash_stable(hcx, hasher);\n-            }\n-            EntryKind::MacroDef(ref macro_def) => {\n-                macro_def.hash_stable(hcx, hasher);\n-            }\n-            EntryKind::Generator(data) => {\n-                data.hash_stable(hcx, hasher);\n-            }\n-            EntryKind::Closure(closure_data) => {\n-                closure_data.hash_stable(hcx, hasher);\n-            }\n-            EntryKind::Trait(ref trait_data) => {\n-                trait_data.hash_stable(hcx, hasher);\n-            }\n-            EntryKind::TraitAlias(ref trait_alias_data) => {\n-                trait_alias_data.hash_stable(hcx, hasher);\n-            }\n-            EntryKind::Impl(ref impl_data) => {\n-                impl_data.hash_stable(hcx, hasher);\n-            }\n-            EntryKind::Method(ref method_data) => {\n-                method_data.hash_stable(hcx, hasher);\n-            }\n-            EntryKind::AssociatedExistential(associated_container) |\n-            EntryKind::AssociatedType(associated_container) => {\n-                associated_container.hash_stable(hcx, hasher);\n-            }\n-            EntryKind::AssociatedConst(associated_container, qualif, ref const_data) => {\n-                associated_container.hash_stable(hcx, hasher);\n-                qualif.hash_stable(hcx, hasher);\n-                const_data.hash_stable(hcx, hasher);\n-            }\n-        }\n-    }\n-}\n-\n /// Additional data for EntryKind::Const and EntryKind::AssociatedConst\n #[derive(Clone, Copy, RustcEncodable, RustcDecodable)]\n pub struct ConstQualif {\n     pub mir: u8,\n     pub ast_promotable: bool,\n }\n \n-impl_stable_hash_for!(struct ConstQualif { mir, ast_promotable });\n-\n /// Contains a constant which has been rendered to a String.\n /// Used by rustdoc.\n #[derive(RustcEncodable, RustcDecodable)]\n pub struct RenderedConst(pub String);\n \n-impl<'a> HashStable<StableHashingContext<'a>> for RenderedConst {\n-    #[inline]\n-    fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'a>,\n-                                          hasher: &mut StableHasher<W>) {\n-        self.0.hash_stable(hcx, hasher);\n-    }\n-}\n-\n #[derive(RustcEncodable, RustcDecodable)]\n pub struct ModData {\n     pub reexports: LazySeq<def::Export<hir::HirId>>,\n }\n \n-impl_stable_hash_for!(struct ModData { reexports });\n-\n #[derive(RustcEncodable, RustcDecodable)]\n pub struct MacroDef {\n     pub body: String,\n     pub legacy: bool,\n }\n \n-impl_stable_hash_for!(struct MacroDef { body, legacy });\n-\n #[derive(RustcEncodable, RustcDecodable)]\n pub struct FnData<'tcx> {\n     pub constness: hir::Constness,\n     pub arg_names: LazySeq<ast::Name>,\n     pub sig: Lazy<ty::PolyFnSig<'tcx>>,\n }\n \n-impl_stable_hash_for!(struct FnData<'tcx> { constness, arg_names, sig });\n-\n #[derive(RustcEncodable, RustcDecodable)]\n pub struct VariantData<'tcx> {\n     pub ctor_kind: CtorKind,\n@@ -456,13 +300,6 @@ pub struct VariantData<'tcx> {\n     pub ctor_sig: Option<Lazy<ty::PolyFnSig<'tcx>>>,\n }\n \n-impl_stable_hash_for!(struct VariantData<'tcx> {\n-    ctor_kind,\n-    discr,\n-    ctor,\n-    ctor_sig\n-});\n-\n #[derive(RustcEncodable, RustcDecodable)]\n pub struct TraitData<'tcx> {\n     pub unsafety: hir::Unsafety,\n@@ -472,23 +309,11 @@ pub struct TraitData<'tcx> {\n     pub super_predicates: Lazy<ty::GenericPredicates<'tcx>>,\n }\n \n-impl_stable_hash_for!(struct TraitData<'tcx> {\n-    unsafety,\n-    paren_sugar,\n-    has_auto_impl,\n-    is_marker,\n-    super_predicates\n-});\n-\n #[derive(RustcEncodable, RustcDecodable)]\n pub struct TraitAliasData<'tcx> {\n     pub super_predicates: Lazy<ty::GenericPredicates<'tcx>>,\n }\n \n-impl_stable_hash_for!(struct TraitAliasData<'tcx> {\n-    super_predicates\n-});\n-\n #[derive(RustcEncodable, RustcDecodable)]\n pub struct ImplData<'tcx> {\n     pub polarity: hir::ImplPolarity,\n@@ -500,14 +325,6 @@ pub struct ImplData<'tcx> {\n     pub trait_ref: Option<Lazy<ty::TraitRef<'tcx>>>,\n }\n \n-impl_stable_hash_for!(struct ImplData<'tcx> {\n-    polarity,\n-    defaultness,\n-    parent_impl,\n-    coerce_unsized_info,\n-    trait_ref\n-});\n-\n \n /// Describes whether the container of an associated item\n /// is a trait or an impl and whether, in a trait, it has\n@@ -520,13 +337,6 @@ pub enum AssociatedContainer {\n     ImplFinal,\n }\n \n-impl_stable_hash_for!(enum crate::schema::AssociatedContainer {\n-    TraitRequired,\n-    TraitWithDefault,\n-    ImplDefault,\n-    ImplFinal\n-});\n-\n impl AssociatedContainer {\n     pub fn with_def_id(&self, def_id: DefId) -> ty::AssociatedItemContainer {\n         match *self {\n@@ -560,26 +370,17 @@ pub struct MethodData<'tcx> {\n     pub container: AssociatedContainer,\n     pub has_self: bool,\n }\n-impl_stable_hash_for!(struct MethodData<'tcx> { fn_data, container, has_self });\n \n #[derive(RustcEncodable, RustcDecodable)]\n pub struct ClosureData<'tcx> {\n     pub sig: Lazy<ty::PolyFnSig<'tcx>>,\n }\n-impl_stable_hash_for!(struct ClosureData<'tcx> { sig });\n \n #[derive(RustcEncodable, RustcDecodable)]\n pub struct GeneratorData<'tcx> {\n     pub layout: mir::GeneratorLayout<'tcx>,\n }\n-impl_stable_hash_for!(struct GeneratorData<'tcx> { layout });\n \n // Tags used for encoding Spans:\n pub const TAG_VALID_SPAN: u8 = 0;\n pub const TAG_INVALID_SPAN: u8 = 1;\n-\n-#[derive(RustcEncodable, RustcDecodable)]\n-pub struct EncodedExportedSymbols {\n-    pub position: usize,\n-    pub len: usize,\n-}"}, {"sha": "cf02878ec82ed28db372f7877d2b2c1626c9781c", "filename": "src/librustc_mir/borrow_check/mod.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/11f01bfb9f79b569aee6ac724eea59c7105a7f19/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/11f01bfb9f79b569aee6ac724eea59c7105a7f19/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs?ref=11f01bfb9f79b569aee6ac724eea59c7105a7f19", "patch": "@@ -439,10 +439,11 @@ fn downgrade_if_error(diag: &mut Diagnostic) {\n         diag.warn(\n             \"this error has been downgraded to a warning for backwards \\\n             compatibility with previous releases\",\n-        );\n-        diag.warn(\n+        ).warn(\n             \"this represents potential undefined behavior in your code and \\\n             this warning will become a hard error in the future\",\n+        ).note(\n+            \"for more information, try `rustc --explain E0729`\"\n         );\n     }\n }"}, {"sha": "4807782c66347e55b8321b84b695be61ba6de47e", "filename": "src/librustc_mir/error_codes.rs", "status": "modified", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/11f01bfb9f79b569aee6ac724eea59c7105a7f19/src%2Flibrustc_mir%2Ferror_codes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/11f01bfb9f79b569aee6ac724eea59c7105a7f19/src%2Flibrustc_mir%2Ferror_codes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ferror_codes.rs?ref=11f01bfb9f79b569aee6ac724eea59c7105a7f19", "patch": "@@ -2424,6 +2424,38 @@ const fn foo() -> impl T {\n ```\n \"##,\n \n+E0729: r##\"\n+Support for Non-Lexical Lifetimes (NLL) has been included in the Rust compiler\n+since 1.31, and has been enabled on the 2015 edition since 1.36. The new borrow\n+checker for NLL uncovered some bugs in the old borrow checker, which in some\n+cases allowed unsound code to compile, resulting in memory safety issues.\n+\n+### What do I do?\n+\n+Change your code so the warning does no longer trigger. For backwards\n+compatibility, this unsound code may still compile (with a warning) right now.\n+However, at some point in the future, the compiler will no longer accept this\n+code and will throw a hard error.\n+\n+### Shouldn't you fix the old borrow checker?\n+\n+The old borrow checker has known soundness issues that are basically impossible\n+to fix. The new NLL-based borrow checker is the fix.\n+\n+### Can I turn these warnings into errors by denying a lint?\n+\n+No.\n+\n+### When are these warnings going to turn into errors?\n+\n+No formal timeline for turning the warnings into errors has been set. See\n+[GitHub issue 58781](https://github.com/rust-lang/rust/issues/58781) for more\n+information.\n+\n+### Why do I get this message with code that doesn't involve borrowing?\n+\n+There are some known bugs that trigger this message.\n+\"##,\n }\n \n register_diagnostics! {"}, {"sha": "12357cb10a991bfae20895b513bfa40ef7bdd0b4", "filename": "src/librustc_mir/transform/qualify_consts.rs", "status": "modified", "additions": 48, "deletions": 46, "changes": 94, "blob_url": "https://github.com/rust-lang/rust/blob/11f01bfb9f79b569aee6ac724eea59c7105a7f19/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/11f01bfb9f79b569aee6ac724eea59c7105a7f19/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs?ref=11f01bfb9f79b569aee6ac724eea59c7105a7f19", "patch": "@@ -930,58 +930,60 @@ impl<'a, 'tcx> Visitor<'tcx> for Checker<'a, 'tcx> {\n                     context: PlaceContext,\n                     location: Location) {\n         debug!(\"visit_place: place={:?} context={:?} location={:?}\", place, context, location);\n-        self.super_place(place, context, location);\n-        match *place {\n-            Place::Base(PlaceBase::Local(_)) => {}\n-            Place::Base(PlaceBase::Static(box Static{ kind: StaticKind::Promoted(_), .. })) => {\n-                unreachable!()\n-            }\n-            Place::Base(PlaceBase::Static(box Static{ kind: StaticKind::Static(def_id), .. })) => {\n-                if self.tcx\n-                       .get_attrs(def_id)\n-                       .iter()\n-                       .any(|attr| attr.check_name(sym::thread_local)) {\n-                    if self.mode != Mode::Fn {\n-                        span_err!(self.tcx.sess, self.span, E0625,\n-                                  \"thread-local statics cannot be \\\n-                                   accessed at compile-time\");\n-                    }\n-                    return;\n+        place.iterate(|place_base, place_projections| {\n+            match place_base {\n+                PlaceBase::Local(_) => {}\n+                PlaceBase::Static(box Static{ kind: StaticKind::Promoted(_), .. }) => {\n+                    unreachable!()\n                 }\n+                PlaceBase::Static(box Static{ kind: StaticKind::Static(def_id), .. }) => {\n+                    if self.tcx\n+                           .get_attrs(*def_id)\n+                           .iter()\n+                           .any(|attr| attr.check_name(sym::thread_local)) {\n+                        if self.mode != Mode::Fn {\n+                            span_err!(self.tcx.sess, self.span, E0625,\n+                                      \"thread-local statics cannot be \\\n+                                       accessed at compile-time\");\n+                        }\n+                        return;\n+                    }\n \n-                // Only allow statics (not consts) to refer to other statics.\n-                if self.mode == Mode::Static || self.mode == Mode::StaticMut {\n-                    if self.mode == Mode::Static && context.is_mutating_use() {\n-                        // this is not strictly necessary as miri will also bail out\n-                        // For interior mutability we can't really catch this statically as that\n-                        // goes through raw pointers and intermediate temporaries, so miri has\n-                        // to catch this anyway\n-                        self.tcx.sess.span_err(\n-                            self.span,\n-                            \"cannot mutate statics in the initializer of another static\",\n-                        );\n+                    // Only allow statics (not consts) to refer to other statics.\n+                    if self.mode == Mode::Static || self.mode == Mode::StaticMut {\n+                        if self.mode == Mode::Static && context.is_mutating_use() {\n+                            // this is not strictly necessary as miri will also bail out\n+                            // For interior mutability we can't really catch this statically as that\n+                            // goes through raw pointers and intermediate temporaries, so miri has\n+                            // to catch this anyway\n+                            self.tcx.sess.span_err(\n+                                self.span,\n+                                \"cannot mutate statics in the initializer of another static\",\n+                            );\n+                        }\n+                        return;\n                     }\n-                    return;\n-                }\n-                unleash_miri!(self);\n+                    unleash_miri!(self);\n \n-                if self.mode != Mode::Fn {\n-                    let mut err = struct_span_err!(self.tcx.sess, self.span, E0013,\n-                                                   \"{}s cannot refer to statics, use \\\n-                                                    a constant instead\", self.mode);\n-                    if self.tcx.sess.teach(&err.get_code().unwrap()) {\n-                        err.note(\n-                            \"Static and const variables can refer to other const variables. But a \\\n-                             const variable cannot refer to a static variable.\"\n-                        );\n-                        err.help(\n-                            \"To fix this, the value can be extracted as a const and then used.\"\n-                        );\n+                    if self.mode != Mode::Fn {\n+                        let mut err = struct_span_err!(self.tcx.sess, self.span, E0013,\n+                                                       \"{}s cannot refer to statics, use \\\n+                                                        a constant instead\", self.mode);\n+                        if self.tcx.sess.teach(&err.get_code().unwrap()) {\n+                            err.note(\n+                                \"Static and const variables can refer to other const variables. \\\n+                                 But a const variable cannot refer to a static variable.\"\n+                            );\n+                            err.help(\n+                                \"To fix this, the value can be extracted as a const and then used.\"\n+                            );\n+                        }\n+                        err.emit()\n                     }\n-                    err.emit()\n                 }\n             }\n-            Place::Projection(ref proj) => {\n+\n+            for proj in place_projections {\n                 match proj.elem {\n                     ProjectionElem::Deref => {\n                         if context.is_mutating_use() {\n@@ -1041,7 +1043,7 @@ impl<'a, 'tcx> Visitor<'tcx> for Checker<'a, 'tcx> {\n                     }\n                 }\n             }\n-        }\n+        });\n     }\n \n     fn visit_operand(&mut self, operand: &Operand<'tcx>, location: Location) {"}, {"sha": "b27f5b1495cb8207cd37e5373c1f6642d8cc1927", "filename": "src/libsyntax/feature_gate.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/11f01bfb9f79b569aee6ac724eea59c7105a7f19/src%2Flibsyntax%2Ffeature_gate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/11f01bfb9f79b569aee6ac724eea59c7105a7f19/src%2Flibsyntax%2Ffeature_gate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffeature_gate.rs?ref=11f01bfb9f79b569aee6ac724eea59c7105a7f19", "patch": "@@ -1134,6 +1134,13 @@ pub const BUILTIN_ATTRIBUTES: &[BuiltinAttribute] = &[\n             is just used to enable niche optimizations in libcore \\\n             and will never be stable\",\n         cfg_fn!(rustc_attrs))),\n+    (sym::rustc_nonnull_optimization_guaranteed, Whitelisted, template!(Word),\n+    Gated(Stability::Unstable,\n+        sym::rustc_attrs,\n+        \"the `#[rustc_nonnull_optimization_guaranteed]` attribute \\\n+            is just used to enable niche optimizations in libcore \\\n+            and will never be stable\",\n+        cfg_fn!(rustc_attrs))),\n     (sym::rustc_regions, Normal, template!(Word), Gated(Stability::Unstable,\n                                     sym::rustc_attrs,\n                                     \"the `#[rustc_regions]` attribute \\"}, {"sha": "b59244283d7392981940ae57dd7742f8c44726b7", "filename": "src/libsyntax_pos/symbol.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/11f01bfb9f79b569aee6ac724eea59c7105a7f19/src%2Flibsyntax_pos%2Fsymbol.rs", "raw_url": "https://github.com/rust-lang/rust/raw/11f01bfb9f79b569aee6ac724eea59c7105a7f19/src%2Flibsyntax_pos%2Fsymbol.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_pos%2Fsymbol.rs?ref=11f01bfb9f79b569aee6ac724eea59c7105a7f19", "patch": "@@ -491,6 +491,7 @@ symbols! {\n         rustc_layout_scalar_valid_range_end,\n         rustc_layout_scalar_valid_range_start,\n         rustc_mir,\n+        rustc_nonnull_optimization_guaranteed,\n         rustc_object_lifetime_default,\n         rustc_on_unimplemented,\n         rustc_outlives,"}, {"sha": "6acc86277385de125041e9e09f4f45c7dbadadd4", "filename": "src/test/rustdoc/issue-60726.rs", "status": "added", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/11f01bfb9f79b569aee6ac724eea59c7105a7f19/src%2Ftest%2Frustdoc%2Fissue-60726.rs", "raw_url": "https://github.com/rust-lang/rust/raw/11f01bfb9f79b569aee6ac724eea59c7105a7f19/src%2Ftest%2Frustdoc%2Fissue-60726.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fissue-60726.rs?ref=11f01bfb9f79b569aee6ac724eea59c7105a7f19", "patch": "@@ -0,0 +1,35 @@\n+use std::marker::PhantomData;\n+\n+pub struct True;\n+pub struct False;\n+\n+pub trait InterfaceType{\n+    type Send;\n+}\n+\n+\n+pub struct FooInterface<T>(PhantomData<fn()->T>);\n+\n+impl<T> InterfaceType for FooInterface<T> {\n+    type Send=False;\n+}\n+\n+\n+pub struct DynTrait<I>{\n+    _interface:PhantomData<fn()->I>,\n+    _unsync_unsend:PhantomData<::std::rc::Rc<()>>,\n+}\n+\n+unsafe impl<I> Send for DynTrait<I>\n+where\n+    I:InterfaceType<Send=True>\n+{}\n+\n+// @has issue_60726/struct.IntoIter.html\n+// @has - '//*[@id=\"synthetic-implementations-list\"]/*[@class=\"impl\"]//code' \"impl<T> !Send for \\\n+// IntoIter<T>\"\n+// @has - '//*[@id=\"synthetic-implementations-list\"]/*[@class=\"impl\"]//code' \"impl<T> !Sync for \\\n+// IntoIter<T>\"\n+pub struct IntoIter<T>{\n+    hello:DynTrait<FooInterface<T>>,\n+}"}, {"sha": "e2d3e417ac3ac8777abf79ae5fe69ddc520ded08", "filename": "src/test/ui/borrowck/borrowck-anon-fields-variant.stderr", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/11f01bfb9f79b569aee6ac724eea59c7105a7f19/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-anon-fields-variant.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/11f01bfb9f79b569aee6ac724eea59c7105a7f19/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-anon-fields-variant.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-anon-fields-variant.stderr?ref=11f01bfb9f79b569aee6ac724eea59c7105a7f19", "patch": "@@ -12,6 +12,7 @@ LL |     *a += 1;\n    |\n    = warning: this error has been downgraded to a warning for backwards compatibility with previous releases\n    = warning: this represents potential undefined behavior in your code and this warning will become a hard error in the future\n+   = note: for more information, try `rustc --explain E0729`\n \n error[E0503]: cannot use `y` because it was mutably borrowed\n   --> $DIR/borrowck-anon-fields-variant.rs:37:7"}, {"sha": "14b9b50f0c32a6352eeed0c16209e1aabf13411c", "filename": "src/test/ui/borrowck/borrowck-describe-lvalue.stderr", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/11f01bfb9f79b569aee6ac724eea59c7105a7f19/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-describe-lvalue.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/11f01bfb9f79b569aee6ac724eea59c7105a7f19/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-describe-lvalue.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-describe-lvalue.stderr?ref=11f01bfb9f79b569aee6ac724eea59c7105a7f19", "patch": "@@ -341,6 +341,7 @@ LL |             drop(x);\n    |\n    = warning: this error has been downgraded to a warning for backwards compatibility with previous releases\n    = warning: this represents potential undefined behavior in your code and this warning will become a hard error in the future\n+   = note: for more information, try `rustc --explain E0729`\n \n warning[E0502]: cannot borrow `*block.current` as immutable because it is also borrowed as mutable\n   --> $DIR/borrowck-describe-lvalue.rs:227:33\n@@ -355,6 +356,7 @@ LL |             drop(x);\n    |\n    = warning: this error has been downgraded to a warning for backwards compatibility with previous releases\n    = warning: this represents potential undefined behavior in your code and this warning will become a hard error in the future\n+   = note: for more information, try `rustc --explain E0729`\n \n error[E0382]: use of moved value: `x`\n   --> $DIR/borrowck-describe-lvalue.rs:282:22"}, {"sha": "461fb7d11a58aa4f4f986b11607ec1c659190331", "filename": "src/test/ui/borrowck/borrowck-migrate-to-nll.edition.stderr", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/11f01bfb9f79b569aee6ac724eea59c7105a7f19/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-migrate-to-nll.edition.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/11f01bfb9f79b569aee6ac724eea59c7105a7f19/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-migrate-to-nll.edition.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-migrate-to-nll.edition.stderr?ref=11f01bfb9f79b569aee6ac724eea59c7105a7f19", "patch": "@@ -6,4 +6,5 @@ LL |                 (|| { let bar = foo; bar.take() })();\n    |\n    = warning: this error has been downgraded to a warning for backwards compatibility with previous releases\n    = warning: this represents potential undefined behavior in your code and this warning will become a hard error in the future\n+   = note: for more information, try `rustc --explain E0729`\n "}, {"sha": "461fb7d11a58aa4f4f986b11607ec1c659190331", "filename": "src/test/ui/borrowck/borrowck-migrate-to-nll.zflag.stderr", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/11f01bfb9f79b569aee6ac724eea59c7105a7f19/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-migrate-to-nll.zflag.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/11f01bfb9f79b569aee6ac724eea59c7105a7f19/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-migrate-to-nll.zflag.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-migrate-to-nll.zflag.stderr?ref=11f01bfb9f79b569aee6ac724eea59c7105a7f19", "patch": "@@ -6,4 +6,5 @@ LL |                 (|| { let bar = foo; bar.take() })();\n    |\n    = warning: this error has been downgraded to a warning for backwards compatibility with previous releases\n    = warning: this represents potential undefined behavior in your code and this warning will become a hard error in the future\n+   = note: for more information, try `rustc --explain E0729`\n "}, {"sha": "ac6bed6137fa304577dd009cb862b0e3cf908be8", "filename": "src/test/ui/borrowck/borrowck-mutate-in-guard.stderr", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/11f01bfb9f79b569aee6ac724eea59c7105a7f19/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-mutate-in-guard.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/11f01bfb9f79b569aee6ac724eea59c7105a7f19/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-mutate-in-guard.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-mutate-in-guard.stderr?ref=11f01bfb9f79b569aee6ac724eea59c7105a7f19", "patch": "@@ -28,6 +28,7 @@ LL |         Enum::A(_) if { x = Enum::B(false); false } => 1,\n    |\n    = warning: this error has been downgraded to a warning for backwards compatibility with previous releases\n    = warning: this represents potential undefined behavior in your code and this warning will become a hard error in the future\n+   = note: for more information, try `rustc --explain E0729`\n \n warning[E0510]: cannot mutably borrow `x` in match guard\n   --> $DIR/borrowck-mutate-in-guard.rs:15:33\n@@ -40,6 +41,7 @@ LL |         Enum::A(_) if { let y = &mut x; *y = Enum::B(false); false } => 1,\n    |\n    = warning: this error has been downgraded to a warning for backwards compatibility with previous releases\n    = warning: this represents potential undefined behavior in your code and this warning will become a hard error in the future\n+   = note: for more information, try `rustc --explain E0729`\n \n error: aborting due to 3 previous errors\n "}, {"sha": "2ca76667bd118fb5c1bc2a95c329ad4d347594d4", "filename": "src/test/ui/consts/const_let_refutable.stderr", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/11f01bfb9f79b569aee6ac724eea59c7105a7f19/src%2Ftest%2Fui%2Fconsts%2Fconst_let_refutable.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/11f01bfb9f79b569aee6ac724eea59c7105a7f19/src%2Ftest%2Fui%2Fconsts%2Fconst_let_refutable.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst_let_refutable.stderr?ref=11f01bfb9f79b569aee6ac724eea59c7105a7f19", "patch": "@@ -21,6 +21,7 @@ LL |     a + b\n    |\n    = warning: this error has been downgraded to a warning for backwards compatibility with previous releases\n    = warning: this represents potential undefined behavior in your code and this warning will become a hard error in the future\n+   = note: for more information, try `rustc --explain E0729`\n \n warning[E0381]: use of possibly uninitialized variable: `b`\n   --> $DIR/const_let_refutable.rs:4:9\n@@ -30,6 +31,7 @@ LL |     a + b\n    |\n    = warning: this error has been downgraded to a warning for backwards compatibility with previous releases\n    = warning: this represents potential undefined behavior in your code and this warning will become a hard error in the future\n+   = note: for more information, try `rustc --explain E0729`\n \n error: aborting due to 2 previous errors\n "}, {"sha": "93b57bc24a82f0cbba7ed9527b7c44a4771860d4", "filename": "src/test/ui/consts/min_const_fn/min_const_fn.stderr", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/11f01bfb9f79b569aee6ac724eea59c7105a7f19/src%2Ftest%2Fui%2Fconsts%2Fmin_const_fn%2Fmin_const_fn.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/11f01bfb9f79b569aee6ac724eea59c7105a7f19/src%2Ftest%2Fui%2Fconsts%2Fmin_const_fn%2Fmin_const_fn.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fmin_const_fn%2Fmin_const_fn.stderr?ref=11f01bfb9f79b569aee6ac724eea59c7105a7f19", "patch": "@@ -297,6 +297,7 @@ LL | const fn no_dyn_trait_ret() -> &'static dyn std::fmt::Debug { &() }\n    |\n    = warning: this error has been downgraded to a warning for backwards compatibility with previous releases\n    = warning: this represents potential undefined behavior in your code and this warning will become a hard error in the future\n+   = note: for more information, try `rustc --explain E0729`\n \n error[E0723]: trait bounds other than `Sized` on const fn parameters are unstable\n   --> $DIR/min_const_fn.rs:144:41"}, {"sha": "9ded93c16727ba5e881e22f37e1e56ffafc360e5", "filename": "src/test/ui/consts/min_const_fn/min_const_fn_dyn.stderr", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/11f01bfb9f79b569aee6ac724eea59c7105a7f19/src%2Ftest%2Fui%2Fconsts%2Fmin_const_fn%2Fmin_const_fn_dyn.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/11f01bfb9f79b569aee6ac724eea59c7105a7f19/src%2Ftest%2Fui%2Fconsts%2Fmin_const_fn%2Fmin_const_fn_dyn.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fmin_const_fn%2Fmin_const_fn_dyn.stderr?ref=11f01bfb9f79b569aee6ac724eea59c7105a7f19", "patch": "@@ -27,6 +27,7 @@ LL | const fn no_inner_dyn_trait_ret() -> Hide { Hide(HasDyn { field: &0 }) }\n    |\n    = warning: this error has been downgraded to a warning for backwards compatibility with previous releases\n    = warning: this represents potential undefined behavior in your code and this warning will become a hard error in the future\n+   = note: for more information, try `rustc --explain E0729`\n \n error: aborting due to 2 previous errors\n "}, {"sha": "9911dd4683b6664a69b47d9e7b3a85fb6eb96194", "filename": "src/test/ui/empty/empty-never-array.stderr", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/11f01bfb9f79b569aee6ac724eea59c7105a7f19/src%2Ftest%2Fui%2Fempty%2Fempty-never-array.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/11f01bfb9f79b569aee6ac724eea59c7105a7f19/src%2Ftest%2Fui%2Fempty%2Fempty-never-array.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fempty%2Fempty-never-array.stderr?ref=11f01bfb9f79b569aee6ac724eea59c7105a7f19", "patch": "@@ -19,6 +19,7 @@ LL |     u\n    |\n    = warning: this error has been downgraded to a warning for backwards compatibility with previous releases\n    = warning: this represents potential undefined behavior in your code and this warning will become a hard error in the future\n+   = note: for more information, try `rustc --explain E0729`\n \n error: aborting due to previous error\n "}, {"sha": "37542d52dc2ce10dbe8dcf474f42e7497b0c34f6", "filename": "src/test/ui/feature-gates/feature-gate-nll.stderr", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/11f01bfb9f79b569aee6ac724eea59c7105a7f19/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/11f01bfb9f79b569aee6ac724eea59c7105a7f19/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-nll.stderr?ref=11f01bfb9f79b569aee6ac724eea59c7105a7f19", "patch": "@@ -11,6 +11,7 @@ LL |     m;\n    |\n    = warning: this error has been downgraded to a warning for backwards compatibility with previous releases\n    = warning: this represents potential undefined behavior in your code and this warning will become a hard error in the future\n+   = note: for more information, try `rustc --explain E0729`\n \n error: compilation successful\n   --> $DIR/feature-gate-nll.rs:10:1"}, {"sha": "9f5c92349e06f25bb9e77e1c50426002d7e590a2", "filename": "src/test/ui/feature-gates/feature-gate-rustc-attrs-1.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/11f01bfb9f79b569aee6ac724eea59c7105a7f19/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-rustc-attrs-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/11f01bfb9f79b569aee6ac724eea59c7105a7f19/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-rustc-attrs-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-rustc-attrs-1.rs?ref=11f01bfb9f79b569aee6ac724eea59c7105a7f19", "patch": "@@ -4,5 +4,6 @@\n \n #[rustc_variance] //~ ERROR the `#[rustc_variance]` attribute is just used for rustc unit tests and will never be stable\n #[rustc_error] //~ ERROR the `#[rustc_error]` attribute is just used for rustc unit tests and will never be stable\n+#[rustc_nonnull_optimization_guaranteed] //~ ERROR the `#[rustc_nonnull_optimization_guaranteed]` attribute is just used to enable niche optimizations in libcore and will never be stable\n \n fn main() {}"}, {"sha": "ed98484e13c4a53813a0d204f33dd866b2dc3d90", "filename": "src/test/ui/feature-gates/feature-gate-rustc-attrs-1.stderr", "status": "modified", "additions": 10, "deletions": 1, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/11f01bfb9f79b569aee6ac724eea59c7105a7f19/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-rustc-attrs-1.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/11f01bfb9f79b569aee6ac724eea59c7105a7f19/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-rustc-attrs-1.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-rustc-attrs-1.stderr?ref=11f01bfb9f79b569aee6ac724eea59c7105a7f19", "patch": "@@ -16,6 +16,15 @@ LL | #[rustc_error]\n    = note: for more information, see https://github.com/rust-lang/rust/issues/29642\n    = help: add #![feature(rustc_attrs)] to the crate attributes to enable\n \n-error: aborting due to 2 previous errors\n+error[E0658]: the `#[rustc_nonnull_optimization_guaranteed]` attribute is just used to enable niche optimizations in libcore and will never be stable\n+  --> $DIR/feature-gate-rustc-attrs-1.rs:7:1\n+   |\n+LL | #[rustc_nonnull_optimization_guaranteed]\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: for more information, see https://github.com/rust-lang/rust/issues/29642\n+   = help: add #![feature(rustc_attrs)] to the crate attributes to enable\n+\n+error: aborting due to 3 previous errors\n \n For more information about this error, try `rustc --explain E0658`."}, {"sha": "7b11d85ead8749fe86741c4ed9a3577e9c174e0a", "filename": "src/test/ui/issues/issue-15381.stderr", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/11f01bfb9f79b569aee6ac724eea59c7105a7f19/src%2Ftest%2Fui%2Fissues%2Fissue-15381.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/11f01bfb9f79b569aee6ac724eea59c7105a7f19/src%2Ftest%2Fui%2Fissues%2Fissue-15381.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-15381.stderr?ref=11f01bfb9f79b569aee6ac724eea59c7105a7f19", "patch": "@@ -12,6 +12,7 @@ LL |         println!(\"y={}\", y);\n    |\n    = warning: this error has been downgraded to a warning for backwards compatibility with previous releases\n    = warning: this represents potential undefined behavior in your code and this warning will become a hard error in the future\n+   = note: for more information, try `rustc --explain E0729`\n \n error: aborting due to previous error\n "}, {"sha": "28aaa2a797e056262772e32e0a1aa527460c4807", "filename": "src/test/ui/issues/issue-40510-1.migrate.stderr", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/11f01bfb9f79b569aee6ac724eea59c7105a7f19/src%2Ftest%2Fui%2Fissues%2Fissue-40510-1.migrate.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/11f01bfb9f79b569aee6ac724eea59c7105a7f19/src%2Ftest%2Fui%2Fissues%2Fissue-40510-1.migrate.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-40510-1.migrate.stderr?ref=11f01bfb9f79b569aee6ac724eea59c7105a7f19", "patch": "@@ -10,6 +10,7 @@ LL |         &mut x\n    = note: ...therefore, they cannot allow references to captured variables to escape\n    = warning: this error has been downgraded to a warning for backwards compatibility with previous releases\n    = warning: this represents potential undefined behavior in your code and this warning will become a hard error in the future\n+   = note: for more information, try `rustc --explain E0729`\n \n error: compilation successful\n   --> $DIR/issue-40510-1.rs:20:1"}, {"sha": "f00690efc312cff1fe54c06f34ed52523ed8f867", "filename": "src/test/ui/issues/issue-40510-3.migrate.stderr", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/11f01bfb9f79b569aee6ac724eea59c7105a7f19/src%2Ftest%2Fui%2Fissues%2Fissue-40510-3.migrate.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/11f01bfb9f79b569aee6ac724eea59c7105a7f19/src%2Ftest%2Fui%2Fissues%2Fissue-40510-3.migrate.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-40510-3.migrate.stderr?ref=11f01bfb9f79b569aee6ac724eea59c7105a7f19", "patch": "@@ -12,6 +12,7 @@ LL | |         }\n    = note: ...therefore, they cannot allow references to captured variables to escape\n    = warning: this error has been downgraded to a warning for backwards compatibility with previous releases\n    = warning: this represents potential undefined behavior in your code and this warning will become a hard error in the future\n+   = note: for more information, try `rustc --explain E0729`\n \n error: compilation successful\n   --> $DIR/issue-40510-3.rs:22:1"}, {"sha": "479b724ad18f153411b4e9888f5d0cd7f62f4e2a", "filename": "src/test/ui/issues/issue-45696-scribble-on-boxed-borrow.migrate.stderr", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/11f01bfb9f79b569aee6ac724eea59c7105a7f19/src%2Ftest%2Fui%2Fissues%2Fissue-45696-scribble-on-boxed-borrow.migrate.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/11f01bfb9f79b569aee6ac724eea59c7105a7f19/src%2Ftest%2Fui%2Fissues%2Fissue-45696-scribble-on-boxed-borrow.migrate.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-45696-scribble-on-boxed-borrow.migrate.stderr?ref=11f01bfb9f79b569aee6ac724eea59c7105a7f19", "patch": "@@ -11,6 +11,7 @@ LL | }\n    |\n    = warning: this error has been downgraded to a warning for backwards compatibility with previous releases\n    = warning: this represents potential undefined behavior in your code and this warning will become a hard error in the future\n+   = note: for more information, try `rustc --explain E0729`\n \n warning[E0713]: borrow may still be in use when destructor runs\n   --> $DIR/issue-45696-scribble-on-boxed-borrow.rs:62:5\n@@ -25,6 +26,7 @@ LL | }\n    |\n    = warning: this error has been downgraded to a warning for backwards compatibility with previous releases\n    = warning: this represents potential undefined behavior in your code and this warning will become a hard error in the future\n+   = note: for more information, try `rustc --explain E0729`\n \n warning[E0713]: borrow may still be in use when destructor runs\n   --> $DIR/issue-45696-scribble-on-boxed-borrow.rs:73:5\n@@ -39,6 +41,7 @@ LL | }\n    |\n    = warning: this error has been downgraded to a warning for backwards compatibility with previous releases\n    = warning: this represents potential undefined behavior in your code and this warning will become a hard error in the future\n+   = note: for more information, try `rustc --explain E0729`\n \n error: compilation successful\n   --> $DIR/issue-45696-scribble-on-boxed-borrow.rs:80:1"}, {"sha": "d5f1af88e133a002acc3de6855887de669f1bdcc", "filename": "src/test/ui/issues/issue-49824.stderr", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/11f01bfb9f79b569aee6ac724eea59c7105a7f19/src%2Ftest%2Fui%2Fissues%2Fissue-49824.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/11f01bfb9f79b569aee6ac724eea59c7105a7f19/src%2Ftest%2Fui%2Fissues%2Fissue-49824.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-49824.stderr?ref=11f01bfb9f79b569aee6ac724eea59c7105a7f19", "patch": "@@ -15,6 +15,7 @@ LL | |         }\n    = note: ...therefore, they cannot allow references to captured variables to escape\n    = warning: this error has been downgraded to a warning for backwards compatibility with previous releases\n    = warning: this represents potential undefined behavior in your code and this warning will become a hard error in the future\n+   = note: for more information, try `rustc --explain E0729`\n \n error: compilation successful\n   --> $DIR/issue-49824.rs:6:1"}, {"sha": "d3e11d2f7ed6478ef826d3f72dec65f0746396ce", "filename": "src/test/ui/lint/lint-ctypes-enum.rs", "status": "modified", "additions": 30, "deletions": 3, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/11f01bfb9f79b569aee6ac724eea59c7105a7f19/src%2Ftest%2Fui%2Flint%2Flint-ctypes-enum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/11f01bfb9f79b569aee6ac724eea59c7105a7f19/src%2Ftest%2Fui%2Flint%2Flint-ctypes-enum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flint%2Flint-ctypes-enum.rs?ref=11f01bfb9f79b569aee6ac724eea59c7105a7f19", "patch": "@@ -1,6 +1,8 @@\n #![deny(improper_ctypes)]\n #![allow(dead_code)]\n \n+use std::num;\n+\n enum Z { }\n enum U { A }\n enum B { C, D }\n@@ -15,14 +17,39 @@ enum U8 { A, B, C }\n #[repr(isize)]\n enum Isize { A, B, C }\n \n+#[repr(transparent)]\n+struct Transparent<T>(T, std::marker::PhantomData<Z>);\n+\n+struct Rust<T>(T);\n+\n extern {\n    fn zf(x: Z);\n    fn uf(x: U); //~ ERROR enum has no representation hint\n    fn bf(x: B); //~ ERROR enum has no representation hint\n    fn tf(x: T); //~ ERROR enum has no representation hint\n-   fn reprc(x: ReprC);\n-   fn u8(x: U8);\n-   fn isize(x: Isize);\n+   fn repr_c(x: ReprC);\n+   fn repr_u8(x: U8);\n+   fn repr_isize(x: Isize);\n+   fn option_ref(x: Option<&'static u8>);\n+   fn option_fn(x: Option<extern \"C\" fn()>);\n+   fn nonnull(x: Option<std::ptr::NonNull<u8>>);\n+   fn nonzero_u8(x: Option<num::NonZeroU8>);\n+   fn nonzero_u16(x: Option<num::NonZeroU16>);\n+   fn nonzero_u32(x: Option<num::NonZeroU32>);\n+   fn nonzero_u64(x: Option<num::NonZeroU64>);\n+   fn nonzero_u128(x: Option<num::NonZeroU128>);\n+   //~^ ERROR 128-bit integers don't currently have a known stable ABI\n+   fn nonzero_usize(x: Option<num::NonZeroUsize>);\n+   fn nonzero_i8(x: Option<num::NonZeroI8>);\n+   fn nonzero_i16(x: Option<num::NonZeroI16>);\n+   fn nonzero_i32(x: Option<num::NonZeroI32>);\n+   fn nonzero_i64(x: Option<num::NonZeroI64>);\n+   fn nonzero_i128(x: Option<num::NonZeroI128>);\n+   //~^ ERROR 128-bit integers don't currently have a known stable ABI\n+   fn nonzero_isize(x: Option<num::NonZeroIsize>);\n+   fn repr_transparent(x: Option<Transparent<num::NonZeroU8>>);\n+   fn repr_rust(x: Option<Rust<num::NonZeroU8>>); //~ ERROR enum has no representation hint\n+   fn no_result(x: Result<(), num::NonZeroI32>); //~ ERROR enum has no representation hint\n }\n \n pub fn main() { }"}, {"sha": "6b807f48aaa82576ff092c38d8e555889404cdc1", "filename": "src/test/ui/lint/lint-ctypes-enum.stderr", "status": "modified", "additions": 35, "deletions": 7, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/11f01bfb9f79b569aee6ac724eea59c7105a7f19/src%2Ftest%2Fui%2Flint%2Flint-ctypes-enum.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/11f01bfb9f79b569aee6ac724eea59c7105a7f19/src%2Ftest%2Fui%2Flint%2Flint-ctypes-enum.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flint%2Flint-ctypes-enum.stderr?ref=11f01bfb9f79b569aee6ac724eea59c7105a7f19", "patch": "@@ -1,5 +1,5 @@\n error: `extern` block uses type `U` which is not FFI-safe: enum has no representation hint\n-  --> $DIR/lint-ctypes-enum.rs:20:13\n+  --> $DIR/lint-ctypes-enum.rs:27:13\n    |\n LL |    fn uf(x: U);\n    |             ^\n@@ -11,36 +11,64 @@ LL | #![deny(improper_ctypes)]\n    |         ^^^^^^^^^^^^^^^\n    = help: consider adding a #[repr(...)] attribute to this enum\n note: type defined here\n-  --> $DIR/lint-ctypes-enum.rs:5:1\n+  --> $DIR/lint-ctypes-enum.rs:7:1\n    |\n LL | enum U { A }\n    | ^^^^^^^^^^^^\n \n error: `extern` block uses type `B` which is not FFI-safe: enum has no representation hint\n-  --> $DIR/lint-ctypes-enum.rs:21:13\n+  --> $DIR/lint-ctypes-enum.rs:28:13\n    |\n LL |    fn bf(x: B);\n    |             ^\n    |\n    = help: consider adding a #[repr(...)] attribute to this enum\n note: type defined here\n-  --> $DIR/lint-ctypes-enum.rs:6:1\n+  --> $DIR/lint-ctypes-enum.rs:8:1\n    |\n LL | enum B { C, D }\n    | ^^^^^^^^^^^^^^^\n \n error: `extern` block uses type `T` which is not FFI-safe: enum has no representation hint\n-  --> $DIR/lint-ctypes-enum.rs:22:13\n+  --> $DIR/lint-ctypes-enum.rs:29:13\n    |\n LL |    fn tf(x: T);\n    |             ^\n    |\n    = help: consider adding a #[repr(...)] attribute to this enum\n note: type defined here\n-  --> $DIR/lint-ctypes-enum.rs:7:1\n+  --> $DIR/lint-ctypes-enum.rs:9:1\n    |\n LL | enum T { E, F, G }\n    | ^^^^^^^^^^^^^^^^^^\n \n-error: aborting due to 3 previous errors\n+error: `extern` block uses type `u128` which is not FFI-safe: 128-bit integers don't currently have a known stable ABI\n+  --> $DIR/lint-ctypes-enum.rs:40:23\n+   |\n+LL |    fn nonzero_u128(x: Option<num::NonZeroU128>);\n+   |                       ^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: `extern` block uses type `i128` which is not FFI-safe: 128-bit integers don't currently have a known stable ABI\n+  --> $DIR/lint-ctypes-enum.rs:47:23\n+   |\n+LL |    fn nonzero_i128(x: Option<num::NonZeroI128>);\n+   |                       ^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: `extern` block uses type `std::option::Option<Rust<std::num::NonZeroU8>>` which is not FFI-safe: enum has no representation hint\n+  --> $DIR/lint-ctypes-enum.rs:51:20\n+   |\n+LL |    fn repr_rust(x: Option<Rust<num::NonZeroU8>>);\n+   |                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = help: consider adding a #[repr(...)] attribute to this enum\n+\n+error: `extern` block uses type `std::result::Result<(), std::num::NonZeroI32>` which is not FFI-safe: enum has no representation hint\n+  --> $DIR/lint-ctypes-enum.rs:52:20\n+   |\n+LL |    fn no_result(x: Result<(), num::NonZeroI32>);\n+   |                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = help: consider adding a #[repr(...)] attribute to this enum\n+\n+error: aborting due to 7 previous errors\n "}, {"sha": "70452a930ee70ec8af606d70fc453cf999addd48", "filename": "src/test/ui/pattern/pattern-bindings-after-at.stderr", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/11f01bfb9f79b569aee6ac724eea59c7105a7f19/src%2Ftest%2Fui%2Fpattern%2Fpattern-bindings-after-at.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/11f01bfb9f79b569aee6ac724eea59c7105a7f19/src%2Ftest%2Fui%2Fpattern%2Fpattern-bindings-after-at.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpattern%2Fpattern-bindings-after-at.stderr?ref=11f01bfb9f79b569aee6ac724eea59c7105a7f19", "patch": "@@ -18,6 +18,7 @@ LL |             **z = None;\n    |\n    = warning: this error has been downgraded to a warning for backwards compatibility with previous releases\n    = warning: this represents potential undefined behavior in your code and this warning will become a hard error in the future\n+   = note: for more information, try `rustc --explain E0729`\n \n error: aborting due to previous error\n "}, {"sha": "9203f893fdbf777bd4d2278d3265e4dc04c06517", "filename": "src/test/ui/recursion/recursive-types-are-not-uninhabited.stderr", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/11f01bfb9f79b569aee6ac724eea59c7105a7f19/src%2Ftest%2Fui%2Frecursion%2Frecursive-types-are-not-uninhabited.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/11f01bfb9f79b569aee6ac724eea59c7105a7f19/src%2Ftest%2Fui%2Frecursion%2Frecursive-types-are-not-uninhabited.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frecursion%2Frecursive-types-are-not-uninhabited.stderr?ref=11f01bfb9f79b569aee6ac724eea59c7105a7f19", "patch": "@@ -12,6 +12,7 @@ LL |     x\n    |\n    = warning: this error has been downgraded to a warning for backwards compatibility with previous releases\n    = warning: this represents potential undefined behavior in your code and this warning will become a hard error in the future\n+   = note: for more information, try `rustc --explain E0729`\n \n error: aborting due to previous error\n "}, {"sha": "6869109e67fc06c4deba374cfefc7b91c92781eb", "filename": "src/test/ui/thread-local-in-ctfe.stderr", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/11f01bfb9f79b569aee6ac724eea59c7105a7f19/src%2Ftest%2Fui%2Fthread-local-in-ctfe.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/11f01bfb9f79b569aee6ac724eea59c7105a7f19/src%2Ftest%2Fui%2Fthread-local-in-ctfe.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fthread-local-in-ctfe.stderr?ref=11f01bfb9f79b569aee6ac724eea59c7105a7f19", "patch": "@@ -20,6 +20,7 @@ LL | static C: &u32 = &A;\n    |\n    = warning: this error has been downgraded to a warning for backwards compatibility with previous releases\n    = warning: this represents potential undefined behavior in your code and this warning will become a hard error in the future\n+   = note: for more information, try `rustc --explain E0729`\n \n error[E0625]: thread-local statics cannot be accessed at compile-time\n   --> $DIR/thread-local-in-ctfe.rs:15:16\n@@ -43,6 +44,7 @@ LL | const E: &u32 = &A;\n    |\n    = warning: this error has been downgraded to a warning for backwards compatibility with previous releases\n    = warning: this represents potential undefined behavior in your code and this warning will become a hard error in the future\n+   = note: for more information, try `rustc --explain E0729`\n \n error[E0625]: thread-local statics cannot be accessed at compile-time\n   --> $DIR/thread-local-in-ctfe.rs:25:5"}, {"sha": "a8eeb7cdb135da1cd582c6093c1739732727a4a2", "filename": "src/tools/clippy", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": null, "raw_url": null, "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy?ref=11f01bfb9f79b569aee6ac724eea59c7105a7f19", "patch": "@@ -1 +1 @@\n-Subproject commit 60a609acaed3bf2b3ec6ab995bccf0f03bc26060\n+Subproject commit a8eeb7cdb135da1cd582c6093c1739732727a4a2"}]}