{"sha": "f2f7fb3ae1f64517c0b30371e2457cac2e2c1248", "node_id": "MDY6Q29tbWl0NzI0NzEyOmYyZjdmYjNhZTFmNjQ1MTdjMGIzMDM3MWUyNDU3Y2FjMmUyYzEyNDg=", "commit": {"author": {"name": "Graydon Hoare", "email": "graydon@mozilla.com", "date": "2013-07-16T01:50:32Z"}, "committer": {"name": "Graydon Hoare", "email": "graydon@mozilla.com", "date": "2013-07-16T16:33:54Z"}, "message": "extra: Add metrics functions to test.", "tree": {"sha": "47045a58f3b1227d6fbec0515734992ad502ae1c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/47045a58f3b1227d6fbec0515734992ad502ae1c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f2f7fb3ae1f64517c0b30371e2457cac2e2c1248", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f2f7fb3ae1f64517c0b30371e2457cac2e2c1248", "html_url": "https://github.com/rust-lang/rust/commit/f2f7fb3ae1f64517c0b30371e2457cac2e2c1248", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f2f7fb3ae1f64517c0b30371e2457cac2e2c1248/comments", "author": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "committer": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "77823c907b272836108175dee546fb846b925465", "url": "https://api.github.com/repos/rust-lang/rust/commits/77823c907b272836108175dee546fb846b925465", "html_url": "https://github.com/rust-lang/rust/commit/77823c907b272836108175dee546fb846b925465"}], "stats": {"total": 91, "additions": 72, "deletions": 19}, "files": [{"sha": "eef3df41b459eb51015de4745f06be97975b0ecc", "filename": "src/libextra/test.rs", "status": "modified", "additions": 72, "deletions": 19, "changes": 91, "blob_url": "https://github.com/rust-lang/rust/blob/f2f7fb3ae1f64517c0b30371e2457cac2e2c1248/src%2Flibextra%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f2f7fb3ae1f64517c0b30371e2457cac2e2c1248/src%2Flibextra%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Ftest.rs?ref=f2f7fb3ae1f64517c0b30371e2457cac2e2c1248", "patch": "@@ -64,7 +64,9 @@ impl ToStr for TestName {\n pub enum TestFn {\n     StaticTestFn(extern fn()),\n     StaticBenchFn(extern fn(&mut BenchHarness)),\n+    StaticMetricFn(~fn(&mut MetricMap)),\n     DynTestFn(~fn()),\n+    DynMetricFn(~fn(&mut MetricMap)),\n     DynBenchFn(~fn(&mut BenchHarness))\n }\n \n@@ -95,6 +97,7 @@ pub struct Metric {\n     noise: f64\n }\n \n+#[deriving(Eq)]\n pub struct MetricMap(TreeMap<~str,Metric>);\n \n /// Analysis of a single change in metric\n@@ -218,7 +221,13 @@ pub struct BenchSamples {\n }\n \n #[deriving(Eq)]\n-pub enum TestResult { TrOk, TrFailed, TrIgnored, TrBench(BenchSamples) }\n+pub enum TestResult {\n+    TrOk,\n+    TrFailed,\n+    TrIgnored,\n+    TrMetrics(MetricMap),\n+    TrBench(BenchSamples)\n+}\n \n struct ConsoleTestState {\n     out: @io::Writer,\n@@ -229,7 +238,7 @@ struct ConsoleTestState {\n     passed: uint,\n     failed: uint,\n     ignored: uint,\n-    benchmarked: uint,\n+    measured: uint,\n     metrics: MetricMap,\n     failures: ~[TestDesc]\n }\n@@ -261,7 +270,7 @@ impl ConsoleTestState {\n             passed: 0u,\n             failed: 0u,\n             ignored: 0u,\n-            benchmarked: 0u,\n+            measured: 0u,\n             metrics: MetricMap::new(),\n             failures: ~[]\n         }\n@@ -279,11 +288,14 @@ impl ConsoleTestState {\n         self.write_pretty(\"ignored\", term::color::YELLOW);\n     }\n \n+    pub fn write_metric(&self) {\n+        self.write_pretty(\"metric\", term::color::CYAN);\n+    }\n+\n     pub fn write_bench(&self) {\n         self.write_pretty(\"bench\", term::color::CYAN);\n     }\n \n-\n     pub fn write_added(&self) {\n         self.write_pretty(\"added\", term::color::GREEN);\n     }\n@@ -332,6 +344,10 @@ impl ConsoleTestState {\n             TrOk => self.write_ok(),\n             TrFailed => self.write_failed(),\n             TrIgnored => self.write_ignored(),\n+            TrMetrics(ref mm) => {\n+                self.write_metric();\n+                self.out.write_str(\": \" + fmt_metrics(mm));\n+            }\n             TrBench(ref bs) => {\n                 self.write_bench();\n                 self.out.write_str(\": \" + fmt_bench_samples(bs))\n@@ -349,6 +365,7 @@ impl ConsoleTestState {\n                                         TrOk => ~\"ok\",\n                                         TrFailed => ~\"failed\",\n                                         TrIgnored => ~\"ignored\",\n+                                        TrMetrics(ref mm) => fmt_metrics(mm),\n                                         TrBench(ref bs) => fmt_bench_samples(bs)\n                                     }, test.name.to_str()));\n             }\n@@ -416,7 +433,7 @@ impl ConsoleTestState {\n     pub fn write_run_finish(&self,\n                             ratchet_metrics: &Option<Path>,\n                             ratchet_pct: Option<f64>) -> bool {\n-        assert!(self.passed + self.failed + self.ignored + self.benchmarked == self.total);\n+        assert!(self.passed + self.failed + self.ignored + self.measured == self.total);\n \n         let ratchet_success = match *ratchet_metrics {\n             None => true,\n@@ -448,12 +465,23 @@ impl ConsoleTestState {\n         } else {\n             self.write_failed();\n         }\n-        self.out.write_str(fmt!(\". %u passed; %u failed; %u ignored, %u benchmarked\\n\\n\",\n-                                self.passed, self.failed, self.ignored, self.benchmarked));\n+        self.out.write_str(fmt!(\". %u passed; %u failed; %u ignored; %u measured\\n\\n\",\n+                                self.passed, self.failed, self.ignored, self.measured));\n         return success;\n     }\n }\n \n+pub fn fmt_metrics(mm: &MetricMap) -> ~str {\n+    use std::iterator::IteratorUtil;\n+    let v : ~[~str] = mm.iter()\n+        .transform(|(k,v)| fmt!(\"%s: %f (+/- %f)\",\n+                                *k,\n+                                v.value as float,\n+                                v.noise as float))\n+        .collect();\n+    v.connect(\", \")\n+}\n+\n pub fn fmt_bench_samples(bs: &BenchSamples) -> ~str {\n     if bs.mb_s != 0 {\n         fmt!(\"%u ns/iter (+/- %u) = %u MB/s\",\n@@ -481,11 +509,19 @@ pub fn run_tests_console(opts: &TestOpts,\n                 match result {\n                     TrOk => st.passed += 1,\n                     TrIgnored => st.ignored += 1,\n+                    TrMetrics(mm) => {\n+                        let tname = test.name.to_str();\n+                        for mm.iter().advance() |(k,v)| {\n+                            st.metrics.insert_metric(tname + \".\" + *k,\n+                                                     v.value, v.noise);\n+                        }\n+                        st.measured += 1\n+                    }\n                     TrBench(bs) => {\n                         st.metrics.insert_metric(test.name.to_str(),\n                                                  bs.ns_iter_summ.median,\n                                                  bs.ns_iter_summ.max - bs.ns_iter_summ.min);\n-                        st.benchmarked += 1\n+                        st.measured += 1\n                     }\n                     TrFailed => {\n                         st.failed += 1;\n@@ -533,7 +569,7 @@ fn should_sort_failures_before_printing_them() {\n             passed: 0u,\n             failed: 0u,\n             ignored: 0u,\n-            benchmarked: 0u,\n+            measured: 0u,\n             metrics: MetricMap::new(),\n             failures: ~[test_b, test_a]\n         };\n@@ -565,11 +601,11 @@ fn run_tests(opts: &TestOpts,\n \n     callback(TeFiltered(filtered_descs));\n \n-    let (filtered_tests, filtered_benchs) =\n+    let (filtered_tests, filtered_benchs_and_metrics) =\n         do filtered_tests.partition |e| {\n         match e.testfn {\n             StaticTestFn(_) | DynTestFn(_) => true,\n-            StaticBenchFn(_) | DynBenchFn(_) => false\n+            _ => false\n         }\n     };\n \n@@ -607,7 +643,8 @@ fn run_tests(opts: &TestOpts,\n     }\n \n     // All benchmarks run at the end, in serial.\n-    for filtered_benchs.consume_iter().advance |b| {\n+    // (this includes metric fns)\n+    for filtered_benchs_and_metrics.consume_iter().advance |b| {\n         callback(TeWait(copy b.desc));\n         run_test(!opts.run_benchmarks, b, ch.clone());\n         let (test, result) = p.recv();\n@@ -730,6 +767,18 @@ pub fn run_test(force_ignore: bool,\n             monitor_ch.send((desc, TrBench(bs)));\n             return;\n         }\n+        DynMetricFn(f) => {\n+            let mut mm = MetricMap::new();\n+            f(&mut mm);\n+            monitor_ch.send((desc, TrMetrics(mm)));\n+            return;\n+        }\n+        StaticMetricFn(f) => {\n+            let mut mm = MetricMap::new();\n+            f(&mut mm);\n+            monitor_ch.send((desc, TrMetrics(mm)));\n+            return;\n+        }\n         DynTestFn(f) => run_test_inner(desc, monitor_ch, f),\n         StaticTestFn(f) => run_test_inner(desc, monitor_ch, || f())\n     }\n@@ -757,12 +806,12 @@ impl ToJson for Metric {\n \n impl MetricMap {\n \n-    fn new() -> MetricMap {\n+    pub fn new() -> MetricMap {\n         MetricMap(TreeMap::new())\n     }\n \n     /// Load MetricDiff from a file.\n-    fn load(p: &Path) -> MetricMap {\n+    pub fn load(p: &Path) -> MetricMap {\n         assert!(os::path_exists(p));\n         let f = io::file_reader(p).get();\n         let mut decoder = json::Decoder(json::from_reader(f).get());\n@@ -793,7 +842,7 @@ impl MetricMap {\n                         None => f64::max(vold.noise.abs(), v.noise.abs()),\n                         Some(pct) => vold.value * pct / 100.0\n                     };\n-                    if delta.abs() < noise {\n+                    if delta.abs() <= noise {\n                         LikelyNoise\n                     } else {\n                         let pct = delta.abs() / vold.value * 100.0;\n@@ -1245,10 +1294,14 @@ mod tests {\n         assert_eq!(*(diff1.find(&~\"in-both-noise\").get()), LikelyNoise);\n         assert_eq!(*(diff1.find(&~\"in-first-noise\").get()), MetricRemoved);\n         assert_eq!(*(diff1.find(&~\"in-second-noise\").get()), MetricAdded);\n-        assert_eq!(*(diff1.find(&~\"in-both-want-downwards-but-regressed\").get()), Regression(100.0));\n-        assert_eq!(*(diff1.find(&~\"in-both-want-downwards-and-improved\").get()), Improvement(50.0));\n-        assert_eq!(*(diff1.find(&~\"in-both-want-upwards-but-regressed\").get()), Regression(50.0));\n-        assert_eq!(*(diff1.find(&~\"in-both-want-upwards-and-improved\").get()), Improvement(100.0));\n+        assert_eq!(*(diff1.find(&~\"in-both-want-downwards-but-regressed\").get()),\n+                   Regression(100.0));\n+        assert_eq!(*(diff1.find(&~\"in-both-want-downwards-and-improved\").get()),\n+                   Improvement(50.0));\n+        assert_eq!(*(diff1.find(&~\"in-both-want-upwards-but-regressed\").get()),\n+                   Regression(50.0));\n+        assert_eq!(*(diff1.find(&~\"in-both-want-upwards-and-improved\").get()),\n+                   Improvement(100.0));\n         assert_eq!(diff1.len(), 7);\n \n         let diff2 = m2.compare_to_old(&m1, Some(200.0));"}]}