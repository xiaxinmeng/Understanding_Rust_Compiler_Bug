{"sha": "2b879a08b503f3ea45e7206c6bcd47d966603598", "node_id": "MDY6Q29tbWl0NzI0NzEyOjJiODc5YTA4YjUwM2YzZWE0NWU3MjA2YzZiY2Q0N2Q5NjY2MDM1OTg=", "commit": {"author": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2015-01-22T02:13:08Z"}, "committer": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2015-01-22T21:47:53Z"}, "message": "Make test harness use unstable APIs without allow(unstable)", "tree": {"sha": "ba4b03baab6e1895fde54421dff400f8ecc409c3", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ba4b03baab6e1895fde54421dff400f8ecc409c3"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2b879a08b503f3ea45e7206c6bcd47d966603598", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2b879a08b503f3ea45e7206c6bcd47d966603598", "html_url": "https://github.com/rust-lang/rust/commit/2b879a08b503f3ea45e7206c6bcd47d966603598", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2b879a08b503f3ea45e7206c6bcd47d966603598/comments", "author": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "committer": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "41278c5441f484a68a20ca12d93cab368a2a943f", "url": "https://api.github.com/repos/rust-lang/rust/commits/41278c5441f484a68a20ca12d93cab368a2a943f", "html_url": "https://github.com/rust-lang/rust/commit/41278c5441f484a68a20ca12d93cab368a2a943f"}], "stats": {"total": 94, "additions": 79, "deletions": 15}, "files": [{"sha": "c7d7b57e66efa0e3e8ea095bc0eef2574fbcb61d", "filename": "src/libsyntax/test.rs", "status": "modified", "additions": 79, "deletions": 15, "changes": 94, "blob_url": "https://github.com/rust-lang/rust/blob/2b879a08b503f3ea45e7206c6bcd47d966603598/src%2Flibsyntax%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2b879a08b503f3ea45e7206c6bcd47d966603598/src%2Flibsyntax%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ftest.rs?ref=2b879a08b503f3ea45e7206c6bcd47d966603598", "patch": "@@ -282,6 +282,24 @@ fn strip_test_functions(krate: ast::Crate) -> ast::Crate {\n     })\n }\n \n+/// Craft a span that will be ignored by the stability lint's\n+/// call to codemap's is_internal check.\n+/// The expanded code calls some unstable functions in the test crate.\n+fn ignored_span(cx: &TestCtxt, sp: Span) -> Span {\n+    let info = ExpnInfo {\n+        call_site: DUMMY_SP,\n+        callee: NameAndSpan {\n+            name: \"test\".to_string(),\n+            format: MacroAttribute,\n+            span: None\n+        }\n+    };\n+    let expn_id = cx.sess.span_diagnostic.cm.record_expansion(info);\n+    let mut sp = sp;\n+    sp.expn_id = expn_id;\n+    return sp;\n+}\n+\n #[derive(PartialEq)]\n enum HasTestSignature {\n     Yes,\n@@ -408,6 +426,64 @@ fn mk_std(cx: &TestCtxt) -> ast::ViewItem {\n     }\n }\n \n+fn mk_main(cx: &mut TestCtxt) -> P<ast::Item> {\n+    // Writing this out by hand with 'ignored_span':\n+    //        pub fn main() {\n+    //            #![main]\n+    //            use std::slice::AsSlice;\n+    //            test::test_main_static(::std::os::args().as_slice(), TESTS);\n+    //        }\n+\n+    let sp = ignored_span(cx, DUMMY_SP);\n+    let ecx = &cx.ext_cx;\n+\n+    // std::slice::AsSlice\n+    let as_slice_path = ecx.path(sp, vec![token::str_to_ident(\"std\"),\n+                                          token::str_to_ident(\"slice\"),\n+                                          token::str_to_ident(\"AsSlice\")]);\n+    // test::test_main_static\n+    let test_main_path = ecx.path(sp, vec![token::str_to_ident(\"test\"),\n+                                           token::str_to_ident(\"test_main_static\")]);\n+    // ::std::os::args\n+    let os_args_path = ecx.path_global(sp, vec![token::str_to_ident(\"std\"),\n+                                                token::str_to_ident(\"os\"),\n+                                                token::str_to_ident(\"args\")]);\n+    // use std::slice::AsSlice\n+    let as_slice_path = P(nospan(ast::ViewPathSimple(token::str_to_ident(\"AsSlice\"),\n+                                                     as_slice_path, ast::DUMMY_NODE_ID)));\n+    let use_as_slice = ecx.view_use(sp, ast::Inherited, as_slice_path);\n+    // ::std::os::args()\n+    let os_args_path_expr = ecx.expr_path(os_args_path);\n+    let call_os_args = ecx.expr_call(sp, os_args_path_expr, vec![]);\n+    // ::std::os::args().as_slice()\n+    let call_as_slice = ecx.expr_method_call(sp, call_os_args,\n+                                             token::str_to_ident(\"as_slice\"), vec![]);\n+    // test::test_main_static(...)\n+    let test_main_path_expr = ecx.expr_path(test_main_path);\n+    let tests_ident_expr = ecx.expr_ident(sp, token::str_to_ident(\"TESTS\"));\n+    let call_test_main = ecx.expr_call(sp, test_main_path_expr,\n+                                       vec![call_as_slice, tests_ident_expr]);\n+    let call_test_main = ecx.stmt_expr(call_test_main);\n+    // #![main]\n+    let main_meta = ecx.meta_word(sp, token::intern_and_get_ident(\"main\"));\n+    let main_attr = ecx.attribute(sp, main_meta);\n+    // pub fn main() { ... }\n+    let main_ret_ty = ecx.ty(sp, ast::TyTup(vec![]));\n+    let main_body = ecx.block_all(sp, vec![use_as_slice], vec![call_test_main], None);\n+    let main = ast::ItemFn(ecx.fn_decl(vec![], main_ret_ty),\n+                           ast::Unsafety::Normal, ::abi::Rust, empty_generics(), main_body);\n+    let main = P(ast::Item {\n+        ident: token::str_to_ident(\"main\"),\n+        attrs: vec![main_attr],\n+        id: ast::DUMMY_NODE_ID,\n+        node: main,\n+        vis: ast::Public,\n+        span: sp\n+    });\n+\n+    return main;\n+}\n+\n fn mk_test_module(cx: &mut TestCtxt) -> (P<ast::Item>, Option<ast::ViewItem>) {\n     // Link to test crate\n     let view_items = vec!(mk_std(cx));\n@@ -417,13 +493,7 @@ fn mk_test_module(cx: &mut TestCtxt) -> (P<ast::Item>, Option<ast::ViewItem>) {\n \n     // The synthesized main function which will call the console test runner\n     // with our list of tests\n-    let mainfn = (quote_item!(&mut cx.ext_cx,\n-        pub fn main() {\n-            #![main]\n-            use std::slice::AsSlice;\n-            test::test_main_static(::std::os::args().as_slice(), TESTS);\n-        }\n-    )).unwrap();\n+    let mainfn = mk_main(cx);\n \n     let testmod = ast::Mod {\n         inner: DUMMY_SP,\n@@ -433,19 +503,13 @@ fn mk_test_module(cx: &mut TestCtxt) -> (P<ast::Item>, Option<ast::ViewItem>) {\n     let item_ = ast::ItemMod(testmod);\n \n     let mod_ident = token::gensym_ident(\"__test\");\n-    let allow_unstable = {\n-        let unstable = P(nospan(ast::MetaWord(InternedString::new(\"unstable\"))));\n-        let allow = P(nospan(ast::MetaList(InternedString::new(\"allow\"),\n-                                           vec![unstable])));\n-        attr::mk_attr_inner(attr::mk_attr_id(), allow)\n-    };\n     let item = ast::Item {\n         ident: mod_ident,\n         id: ast::DUMMY_NODE_ID,\n         node: item_,\n         vis: ast::Public,\n         span: DUMMY_SP,\n-        attrs: vec![allow_unstable],\n+        attrs: vec![],\n     };\n     let reexport = cx.reexport_test_harness_main.as_ref().map(|s| {\n         // building `use <ident> = __test::main`\n@@ -538,7 +602,7 @@ fn mk_test_desc_and_fn_rec(cx: &TestCtxt, test: &Test) -> P<ast::Expr> {\n     // __test_reexports, causing it to be reinterned, losing the\n     // gensym information.\n \n-    let span = test.span;\n+    let span = ignored_span(cx, test.span);\n     let path = test.path.clone();\n     let ecx = &cx.ext_cx;\n     let self_id = ecx.ident_of(\"self\");"}]}