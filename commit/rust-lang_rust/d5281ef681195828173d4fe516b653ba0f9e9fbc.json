{"sha": "d5281ef681195828173d4fe516b653ba0f9e9fbc", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQ1MjgxZWY2ODExOTU4MjgxNzNkNGZlNTE2YjY1M2JhMGY5ZTlmYmM=", "commit": {"author": {"name": "Jeffrey Seyfried", "email": "jeffrey.seyfried@gmail.com", "date": "2016-10-11T03:41:18Z"}, "committer": {"name": "Jeffrey Seyfried", "email": "jeffrey.seyfried@gmail.com", "date": "2016-10-11T03:41:18Z"}, "message": "Merge branch 'persistent_macro_scopes' into cleanup_expanded_macro_use_scopes", "tree": {"sha": "9dbe1062b81fdbc416862dfc82a7bf5a65c491f6", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9dbe1062b81fdbc416862dfc82a7bf5a65c491f6"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d5281ef681195828173d4fe516b653ba0f9e9fbc", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d5281ef681195828173d4fe516b653ba0f9e9fbc", "html_url": "https://github.com/rust-lang/rust/commit/d5281ef681195828173d4fe516b653ba0f9e9fbc", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d5281ef681195828173d4fe516b653ba0f9e9fbc/comments", "author": {"login": "jseyfried", "id": 8652869, "node_id": "MDQ6VXNlcjg2NTI4Njk=", "avatar_url": "https://avatars.githubusercontent.com/u/8652869?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jseyfried", "html_url": "https://github.com/jseyfried", "followers_url": "https://api.github.com/users/jseyfried/followers", "following_url": "https://api.github.com/users/jseyfried/following{/other_user}", "gists_url": "https://api.github.com/users/jseyfried/gists{/gist_id}", "starred_url": "https://api.github.com/users/jseyfried/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jseyfried/subscriptions", "organizations_url": "https://api.github.com/users/jseyfried/orgs", "repos_url": "https://api.github.com/users/jseyfried/repos", "events_url": "https://api.github.com/users/jseyfried/events{/privacy}", "received_events_url": "https://api.github.com/users/jseyfried/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jseyfried", "id": 8652869, "node_id": "MDQ6VXNlcjg2NTI4Njk=", "avatar_url": "https://avatars.githubusercontent.com/u/8652869?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jseyfried", "html_url": "https://github.com/jseyfried", "followers_url": "https://api.github.com/users/jseyfried/followers", "following_url": "https://api.github.com/users/jseyfried/following{/other_user}", "gists_url": "https://api.github.com/users/jseyfried/gists{/gist_id}", "starred_url": "https://api.github.com/users/jseyfried/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jseyfried/subscriptions", "organizations_url": "https://api.github.com/users/jseyfried/orgs", "repos_url": "https://api.github.com/users/jseyfried/repos", "events_url": "https://api.github.com/users/jseyfried/events{/privacy}", "received_events_url": "https://api.github.com/users/jseyfried/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a7bfb1aba9d089a0464c03b3841e889c6ee7c4f1", "url": "https://api.github.com/repos/rust-lang/rust/commits/a7bfb1aba9d089a0464c03b3841e889c6ee7c4f1", "html_url": "https://github.com/rust-lang/rust/commit/a7bfb1aba9d089a0464c03b3841e889c6ee7c4f1"}, {"sha": "6808b0a2b77448585dff3e0bfdd72a16ed5dab9b", "url": "https://api.github.com/repos/rust-lang/rust/commits/6808b0a2b77448585dff3e0bfdd72a16ed5dab9b", "html_url": "https://github.com/rust-lang/rust/commit/6808b0a2b77448585dff3e0bfdd72a16ed5dab9b"}], "stats": {"total": 481, "additions": 282, "deletions": 199}, "files": [{"sha": "2290428264221205d3397bfdf8938ad39cdc9b2c", "filename": "src/librustc/hir/lowering.rs", "status": "modified", "additions": 1, "deletions": 7, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/d5281ef681195828173d4fe516b653ba0f9e9fbc/src%2Flibrustc%2Fhir%2Flowering.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d5281ef681195828173d4fe516b653ba0f9e9fbc/src%2Flibrustc%2Fhir%2Flowering.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Flowering.rs?ref=d5281ef681195828173d4fe516b653ba0f9e9fbc", "patch": "@@ -95,13 +95,7 @@ pub fn lower_crate(sess: &Session,\n     let _ignore = sess.dep_graph.in_ignore();\n \n     LoweringContext {\n-        crate_root: if std_inject::no_core(krate) {\n-            None\n-        } else if std_inject::no_std(krate) {\n-            Some(\"core\")\n-        } else {\n-            Some(\"std\")\n-        },\n+        crate_root: std_inject::injected_crate_name(krate),\n         sess: sess,\n         parent_def: None,\n         resolver: resolver,"}, {"sha": "e8ab2f3a2405b541553dfa908585ca297c4b998f", "filename": "src/librustc_driver/driver.rs", "status": "modified", "additions": 9, "deletions": 3, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/d5281ef681195828173d4fe516b653ba0f9e9fbc/src%2Flibrustc_driver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d5281ef681195828173d4fe516b653ba0f9e9fbc/src%2Flibrustc_driver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Fdriver.rs?ref=d5281ef681195828173d4fe516b653ba0f9e9fbc", "patch": "@@ -649,7 +649,7 @@ pub fn phase_2_configure_and_expand<'a, F>(sess: &Session,\n     let resolver_arenas = Resolver::arenas();\n     let mut resolver =\n         Resolver::new(sess, &krate, make_glob_map, &mut crate_loader, &resolver_arenas);\n-    syntax_ext::register_builtins(&mut resolver, sess.features.borrow().quote);\n+    syntax_ext::register_builtins(&mut resolver, syntax_exts, sess.features.borrow().quote);\n \n     krate = time(time_passes, \"expansion\", || {\n         // Windows dlls do not have rpaths, so they don't know how to find their\n@@ -686,11 +686,17 @@ pub fn phase_2_configure_and_expand<'a, F>(sess: &Session,\n             ..syntax::ext::expand::ExpansionConfig::default(crate_name.to_string())\n         };\n         let mut ecx = ExtCtxt::new(&sess.parse_sess, krate.config.clone(), cfg, &mut resolver);\n-        let ret = syntax::ext::expand::expand_crate(&mut ecx, syntax_exts, krate);\n+        let err_count = ecx.parse_sess.span_diagnostic.err_count();\n+\n+        let krate = ecx.monotonic_expander().expand_crate(krate);\n+\n+        if ecx.parse_sess.span_diagnostic.err_count() - ecx.resolve_err_count > err_count {\n+            ecx.parse_sess.span_diagnostic.abort_if_errors();\n+        }\n         if cfg!(windows) {\n             env::set_var(\"PATH\", &old_path);\n         }\n-        ret\n+        krate\n     });\n \n     krate.exported_macros = mem::replace(&mut resolver.exported_macros, Vec::new());"}, {"sha": "12e56131597132539f1820dadc6f21aec35aa391", "filename": "src/librustc_resolve/build_reduced_graph.rs", "status": "modified", "additions": 40, "deletions": 29, "changes": 69, "blob_url": "https://github.com/rust-lang/rust/blob/d5281ef681195828173d4fe516b653ba0f9e9fbc/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d5281ef681195828173d4fe516b653ba0f9e9fbc/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs?ref=d5281ef681195828173d4fe516b653ba0f9e9fbc", "patch": "@@ -13,7 +13,7 @@\n //! Here we build the \"reduced graph\": the graph of the module tree without\n //! any imports resolved.\n \n-use macros;\n+use macros::{InvocationData, LegacyImports, LegacyScope};\n use resolve_imports::ImportDirectiveSubclass::{self, GlobImport};\n use {Module, ModuleS, ModuleKind};\n use Namespace::{self, TypeNS, ValueNS};\n@@ -84,7 +84,7 @@ impl<'b> Resolver<'b> {\n     }\n \n     /// Constructs the reduced graph for one item.\n-    fn build_reduced_graph_for_item(&mut self, item: &Item, expansion: Mark) {\n+    fn build_reduced_graph_for_item(&mut self, item: &Item, legacy_imports: &mut LegacyImports) {\n         let parent = self.current_module;\n         let name = item.ident.name;\n         let sp = item.span;\n@@ -200,16 +200,9 @@ impl<'b> Resolver<'b> {\n                         LoadedMacroKind::Def(mut def) => {\n                             let name = def.ident.name;\n                             if def.use_locally {\n-                                let ext = macro_rules::compile(&self.session.parse_sess, &def);\n-                                let shadowing =\n-                                    self.resolve_macro_name(Mark::root(), name, false).is_some();\n-                                self.expansion_data[&Mark::root()].module.macros.borrow_mut()\n-                                    .insert(name, macros::NameBinding {\n-                                        ext: Rc::new(ext),\n-                                        expansion: expansion,\n-                                        shadowing: shadowing,\n-                                        span: loaded_macro.import_site,\n-                                    });\n+                                let ext =\n+                                    Rc::new(macro_rules::compile(&self.session.parse_sess, &def));\n+                                legacy_imports.insert(name, (ext, loaded_macro.import_site));\n                                 self.macro_names.insert(name);\n                             }\n                             if def.export {\n@@ -250,7 +243,6 @@ impl<'b> Resolver<'b> {\n                         attr::contains_name(&item.attrs, \"no_implicit_prelude\")\n                     },\n                     normal_ancestor_id: Some(item.id),\n-                    macros_escape: self.contains_macro_use(&item.attrs),\n                     ..ModuleS::new(Some(parent), ModuleKind::Def(def, name))\n                 });\n                 self.define(parent, name, TypeNS, (module, sp, vis));\n@@ -520,45 +512,62 @@ impl<'b> Resolver<'b> {\n \n pub struct BuildReducedGraphVisitor<'a, 'b: 'a> {\n     pub resolver: &'a mut Resolver<'b>,\n-    pub expansion: Mark,\n+    pub legacy_scope: LegacyScope<'b>,\n+    pub legacy_imports: LegacyImports,\n }\n \n impl<'a, 'b> BuildReducedGraphVisitor<'a, 'b> {\n-    fn visit_invoc(&mut self, id: ast::NodeId) {\n-        self.resolver.expansion_data.get_mut(&Mark::from_placeholder_id(id)).unwrap().module =\n-            self.resolver.current_module;\n+    fn visit_invoc(&mut self, id: ast::NodeId) -> &'b InvocationData<'b> {\n+        let invocation = self.resolver.invocations[&Mark::from_placeholder_id(id)];\n+        invocation.module.set(self.resolver.current_module);\n+        invocation.legacy_scope.set(self.legacy_scope);\n+        invocation\n     }\n }\n \n macro_rules! method {\n     ($visit:ident: $ty:ty, $invoc:path, $walk:ident) => {\n         fn $visit(&mut self, node: &$ty) {\n-            match node.node {\n-                $invoc(..) => self.visit_invoc(node.id),\n-                _ => visit::$walk(self, node),\n+            if let $invoc(..) = node.node {\n+                self.visit_invoc(node.id);\n+            } else {\n+                visit::$walk(self, node);\n             }\n         }\n     }\n }\n \n impl<'a, 'b> Visitor for BuildReducedGraphVisitor<'a, 'b> {\n     method!(visit_impl_item: ast::ImplItem, ast::ImplItemKind::Macro, walk_impl_item);\n-    method!(visit_stmt:      ast::Stmt,     ast::StmtKind::Mac,       walk_stmt);\n     method!(visit_expr:      ast::Expr,     ast::ExprKind::Mac,       walk_expr);\n     method!(visit_pat:       ast::Pat,      ast::PatKind::Mac,        walk_pat);\n     method!(visit_ty:        ast::Ty,       ast::TyKind::Mac,         walk_ty);\n \n     fn visit_item(&mut self, item: &Item) {\n-        match item.node {\n+        let macro_use = match item.node {\n             ItemKind::Mac(..) if item.id == ast::DUMMY_NODE_ID => return, // Scope placeholder\n-            ItemKind::Mac(..) => return self.visit_invoc(item.id),\n-            _ => {}\n-        }\n+            ItemKind::Mac(..) => {\n+                return self.legacy_scope = LegacyScope::Expansion(self.visit_invoc(item.id));\n+            }\n+            ItemKind::Mod(..) => self.resolver.contains_macro_use(&item.attrs),\n+            _ => false,\n+        };\n \n-        let parent = self.resolver.current_module;\n-        self.resolver.build_reduced_graph_for_item(item, self.expansion);\n+        let (parent, legacy_scope) = (self.resolver.current_module, self.legacy_scope);\n+        self.resolver.build_reduced_graph_for_item(item, &mut self.legacy_imports);\n         visit::walk_item(self, item);\n         self.resolver.current_module = parent;\n+        if !macro_use {\n+            self.legacy_scope = legacy_scope;\n+        }\n+    }\n+\n+    fn visit_stmt(&mut self, stmt: &ast::Stmt) {\n+        if let ast::StmtKind::Mac(..) = stmt.node {\n+            self.legacy_scope = LegacyScope::Expansion(self.visit_invoc(stmt.id));\n+        } else {\n+            visit::walk_stmt(self, stmt);\n+        }\n     }\n \n     fn visit_foreign_item(&mut self, foreign_item: &ForeignItem) {\n@@ -567,18 +576,20 @@ impl<'a, 'b> Visitor for BuildReducedGraphVisitor<'a, 'b> {\n     }\n \n     fn visit_block(&mut self, block: &Block) {\n-        let parent = self.resolver.current_module;\n+        let (parent, legacy_scope) = (self.resolver.current_module, self.legacy_scope);\n         self.resolver.build_reduced_graph_for_block(block);\n         visit::walk_block(self, block);\n         self.resolver.current_module = parent;\n+        self.legacy_scope = legacy_scope;\n     }\n \n     fn visit_trait_item(&mut self, item: &TraitItem) {\n         let parent = self.resolver.current_module;\n         let def_id = parent.def_id().unwrap();\n \n         if let TraitItemKind::Macro(_) = item.node {\n-            return self.visit_invoc(item.id);\n+            self.visit_invoc(item.id);\n+            return\n         }\n \n         // Add the item to the trait info."}, {"sha": "fb18615263cf34fcee61eb51bb63ac71143e3a06", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 38, "deletions": 12, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/d5281ef681195828173d4fe516b653ba0f9e9fbc/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d5281ef681195828173d4fe516b653ba0f9e9fbc/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=d5281ef681195828173d4fe516b653ba0f9e9fbc", "patch": "@@ -57,6 +57,7 @@ use syntax::ext::base::MultiItemModifier;\n use syntax::ext::hygiene::Mark;\n use syntax::ast::{self, FloatTy};\n use syntax::ast::{CRATE_NODE_ID, Name, NodeId, IntTy, UintTy};\n+use syntax::ext::base::SyntaxExtension;\n use syntax::parse::token::{self, keywords};\n use syntax::util::lev_distance::find_best_match_for_name;\n \n@@ -77,6 +78,7 @@ use std::mem::replace;\n use std::rc::Rc;\n \n use resolve_imports::{ImportDirective, NameResolution};\n+use macros::{InvocationData, LegacyBinding, LegacyScope};\n \n // NB: This module needs to be declared first so diagnostics are\n // registered before they are used.\n@@ -791,9 +793,6 @@ pub struct ModuleS<'a> {\n     // access the children must be preceded with a\n     // `populate_module_if_necessary` call.\n     populated: Cell<bool>,\n-\n-    macros: RefCell<FnvHashMap<Name, macros::NameBinding>>,\n-    macros_escape: bool,\n }\n \n pub type Module<'a> = &'a ModuleS<'a>;\n@@ -811,8 +810,6 @@ impl<'a> ModuleS<'a> {\n             globs: RefCell::new((Vec::new())),\n             traits: RefCell::new(None),\n             populated: Cell::new(true),\n-            macros: RefCell::new(FnvHashMap()),\n-            macros_escape: false,\n         }\n     }\n \n@@ -1076,7 +1073,7 @@ pub struct Resolver<'a> {\n \n     privacy_errors: Vec<PrivacyError<'a>>,\n     ambiguity_errors: Vec<AmbiguityError<'a>>,\n-    macro_shadowing_errors: FnvHashSet<Span>,\n+    disallowed_shadowing: Vec<(Name, Span, LegacyScope<'a>)>,\n \n     arenas: &'a ResolverArenas<'a>,\n     dummy_binding: &'a NameBinding<'a>,\n@@ -1086,9 +1083,10 @@ pub struct Resolver<'a> {\n     pub derive_modes: FnvHashMap<Name, Rc<MultiItemModifier>>,\n     crate_loader: &'a mut CrateLoader,\n     macro_names: FnvHashSet<Name>,\n+    builtin_macros: FnvHashMap<Name, Rc<SyntaxExtension>>,\n \n     // Maps the `Mark` of an expansion to its containing module or block.\n-    expansion_data: FnvHashMap<Mark, macros::ExpansionData<'a>>,\n+    invocations: FnvHashMap<Mark, &'a InvocationData<'a>>,\n }\n \n pub struct ResolverArenas<'a> {\n@@ -1097,6 +1095,8 @@ pub struct ResolverArenas<'a> {\n     name_bindings: arena::TypedArena<NameBinding<'a>>,\n     import_directives: arena::TypedArena<ImportDirective<'a>>,\n     name_resolutions: arena::TypedArena<RefCell<NameResolution<'a>>>,\n+    invocation_data: arena::TypedArena<InvocationData<'a>>,\n+    legacy_bindings: arena::TypedArena<LegacyBinding<'a>>,\n }\n \n impl<'a> ResolverArenas<'a> {\n@@ -1120,6 +1120,13 @@ impl<'a> ResolverArenas<'a> {\n     fn alloc_name_resolution(&'a self) -> &'a RefCell<NameResolution<'a>> {\n         self.name_resolutions.alloc(Default::default())\n     }\n+    fn alloc_invocation_data(&'a self, expansion_data: InvocationData<'a>)\n+                             -> &'a InvocationData<'a> {\n+        self.invocation_data.alloc(expansion_data)\n+    }\n+    fn alloc_legacy_binding(&'a self, binding: LegacyBinding<'a>) -> &'a LegacyBinding<'a> {\n+        self.legacy_bindings.alloc(binding)\n+    }\n }\n \n impl<'a> ty::NodeIdTree for Resolver<'a> {\n@@ -1205,8 +1212,9 @@ impl<'a> Resolver<'a> {\n         let mut definitions = Definitions::new();\n         DefCollector::new(&mut definitions).collect_root();\n \n-        let mut expansion_data = FnvHashMap();\n-        expansion_data.insert(Mark::root(), macros::ExpansionData::root(graph_root));\n+        let mut invocations = FnvHashMap();\n+        invocations.insert(Mark::root(),\n+                           arenas.alloc_invocation_data(InvocationData::root(graph_root)));\n \n         Resolver {\n             session: session,\n@@ -1252,7 +1260,7 @@ impl<'a> Resolver<'a> {\n \n             privacy_errors: Vec::new(),\n             ambiguity_errors: Vec::new(),\n-            macro_shadowing_errors: FnvHashSet(),\n+            disallowed_shadowing: Vec::new(),\n \n             arenas: arenas,\n             dummy_binding: arenas.alloc_name_binding(NameBinding {\n@@ -1266,7 +1274,8 @@ impl<'a> Resolver<'a> {\n             derive_modes: FnvHashMap(),\n             crate_loader: crate_loader,\n             macro_names: FnvHashSet(),\n-            expansion_data: expansion_data,\n+            builtin_macros: FnvHashMap(),\n+            invocations: invocations,\n         }\n     }\n \n@@ -1277,6 +1286,8 @@ impl<'a> Resolver<'a> {\n             name_bindings: arena::TypedArena::new(),\n             import_directives: arena::TypedArena::new(),\n             name_resolutions: arena::TypedArena::new(),\n+            invocation_data: arena::TypedArena::new(),\n+            legacy_bindings: arena::TypedArena::new(),\n         }\n     }\n \n@@ -3342,7 +3353,8 @@ impl<'a> Resolver<'a> {\n         vis.is_accessible_from(module.normal_ancestor_id.unwrap(), self)\n     }\n \n-    fn report_errors(&self) {\n+    fn report_errors(&mut self) {\n+        self.report_shadowing_errors();\n         let mut reported_spans = FnvHashSet();\n \n         for &AmbiguityError { span, name, b1, b2 } in &self.ambiguity_errors {\n@@ -3370,6 +3382,20 @@ impl<'a> Resolver<'a> {\n         }\n     }\n \n+    fn report_shadowing_errors(&mut self) {\n+        let mut reported_errors = FnvHashSet();\n+        for (name, span, scope) in replace(&mut self.disallowed_shadowing, Vec::new()) {\n+            if self.resolve_macro_name(scope, name, false).is_some() &&\n+               reported_errors.insert((name, span)) {\n+                let msg = format!(\"`{}` is already in scope\", name);\n+                self.session.struct_span_err(span, &msg)\n+                    .note(\"macro-expanded `macro_rules!`s and `#[macro_use]`s \\\n+                           may not shadow existing macros (see RFC 1560)\")\n+                    .emit();\n+            }\n+        }\n+    }\n+\n     fn report_conflict(&self,\n                        parent: Module,\n                        name: Name,"}, {"sha": "1c36b2452a4eaafb0ed1cfeebee97f6669e7f8a9", "filename": "src/librustc_resolve/macros.rs", "status": "modified", "additions": 146, "deletions": 76, "changes": 222, "blob_url": "https://github.com/rust-lang/rust/blob/d5281ef681195828173d4fe516b653ba0f9e9fbc/src%2Flibrustc_resolve%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d5281ef681195828173d4fe516b653ba0f9e9fbc/src%2Flibrustc_resolve%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fmacros.rs?ref=d5281ef681195828173d4fe516b653ba0f9e9fbc", "patch": "@@ -12,47 +12,79 @@ use {Module, Resolver};\n use build_reduced_graph::BuildReducedGraphVisitor;\n use rustc::hir::def_id::{CRATE_DEF_INDEX, DefIndex};\n use rustc::hir::map::{self, DefCollector};\n+use rustc::util::nodemap::FnvHashMap;\n+use std::cell::Cell;\n use std::rc::Rc;\n use syntax::ast;\n use syntax::errors::DiagnosticBuilder;\n use syntax::ext::base::{self, MultiModifier, MultiDecorator, MultiItemModifier};\n use syntax::ext::base::{NormalTT, SyntaxExtension};\n use syntax::ext::expand::{Expansion, Invocation, InvocationKind};\n-use syntax::ext::hygiene::{Mark, SyntaxContext};\n+use syntax::ext::hygiene::Mark;\n use syntax::ext::tt::macro_rules;\n use syntax::parse::token::intern;\n use syntax::util::lev_distance::find_best_match_for_name;\n-use syntax_pos::{Span, DUMMY_SP};\n-\n-// FIXME(jseyfried) Merge with `::NameBinding`.\n-pub struct NameBinding {\n-    pub ext: Rc<SyntaxExtension>,\n-    pub expansion: Mark,\n-    pub shadowing: bool,\n-    pub span: Span,\n-}\n+use syntax_pos::Span;\n \n #[derive(Clone)]\n-pub struct ExpansionData<'a> {\n-    backtrace: SyntaxContext,\n-    pub module: Module<'a>,\n+pub struct InvocationData<'a> {\n+    pub module: Cell<Module<'a>>,\n     def_index: DefIndex,\n     // True if this expansion is in a `const_integer` position, for example `[u32; m!()]`.\n     // c.f. `DefCollector::visit_ast_const_integer`.\n     const_integer: bool,\n+    // The scope in which the invocation path is resolved.\n+    pub legacy_scope: Cell<LegacyScope<'a>>,\n+    // The smallest scope that includes this invocation's expansion,\n+    // or `Empty` if this invocation has not been expanded yet.\n+    pub expansion: Cell<LegacyScope<'a>>,\n }\n \n-impl<'a> ExpansionData<'a> {\n+impl<'a> InvocationData<'a> {\n     pub fn root(graph_root: Module<'a>) -> Self {\n-        ExpansionData {\n-            backtrace: SyntaxContext::empty(),\n-            module: graph_root,\n+        InvocationData {\n+            module: Cell::new(graph_root),\n             def_index: CRATE_DEF_INDEX,\n             const_integer: false,\n+            legacy_scope: Cell::new(LegacyScope::Empty),\n+            expansion: Cell::new(LegacyScope::Empty),\n         }\n     }\n }\n \n+#[derive(Copy, Clone)]\n+pub enum LegacyScope<'a> {\n+    Empty,\n+    Invocation(&'a InvocationData<'a>), // The scope of the invocation, not including its expansion\n+    Expansion(&'a InvocationData<'a>), // The scope of the invocation, including its expansion\n+    Binding(&'a LegacyBinding<'a>),\n+}\n+\n+impl<'a> LegacyScope<'a> {\n+    fn simplify_expansion(mut invoc: &'a InvocationData<'a>) -> Self {\n+        while let LegacyScope::Invocation(_) = invoc.expansion.get() {\n+            match invoc.legacy_scope.get() {\n+                LegacyScope::Expansion(new_invoc) => invoc = new_invoc,\n+                LegacyScope::Binding(_) => break,\n+                scope @ _ => return scope,\n+            }\n+        }\n+        LegacyScope::Expansion(invoc)\n+    }\n+}\n+\n+pub struct LegacyBinding<'a> {\n+    parent: LegacyScope<'a>,\n+    kind: LegacyBindingKind,\n+}\n+\n+pub enum LegacyBindingKind {\n+    MacroRules(ast::Name, Rc<SyntaxExtension>, Span),\n+    MacroUse(LegacyImports),\n+}\n+\n+pub type LegacyImports = FnvHashMap<ast::Name, (Rc<SyntaxExtension>, Span)>;\n+\n impl<'a> base::Resolver for Resolver<'a> {\n     fn next_node_id(&mut self) -> ast::NodeId {\n         self.session.next_node_id()\n@@ -61,37 +93,51 @@ impl<'a> base::Resolver for Resolver<'a> {\n     fn get_module_scope(&mut self, id: ast::NodeId) -> Mark {\n         let mark = Mark::fresh();\n         let module = self.module_map[&id];\n-        self.expansion_data.insert(mark, ExpansionData {\n-            backtrace: SyntaxContext::empty(),\n-            module: module,\n+        self.invocations.insert(mark, self.arenas.alloc_invocation_data(InvocationData {\n+            module: Cell::new(module),\n             def_index: module.def_id().unwrap().index,\n             const_integer: false,\n-        });\n+            legacy_scope: Cell::new(LegacyScope::Empty),\n+            expansion: Cell::new(LegacyScope::Empty),\n+        }));\n         mark\n     }\n \n     fn visit_expansion(&mut self, mark: Mark, expansion: &Expansion) {\n-        self.collect_def_ids(mark, expansion);\n-        self.current_module = self.expansion_data[&mark].module;\n-        expansion.visit_with(&mut BuildReducedGraphVisitor { resolver: self, expansion: mark });\n+        let invocation = self.invocations[&mark];\n+        self.collect_def_ids(invocation, expansion);\n+\n+        self.current_module = invocation.module.get();\n+        let mut visitor = BuildReducedGraphVisitor {\n+            resolver: self,\n+            legacy_scope: LegacyScope::Invocation(invocation),\n+            legacy_imports: FnvHashMap(),\n+        };\n+        expansion.visit_with(&mut visitor);\n+        invocation.expansion.set(visitor.legacy_scope);\n+\n+        if !visitor.legacy_imports.is_empty() {\n+            invocation.legacy_scope.set({\n+                LegacyScope::Binding(self.arenas.alloc_legacy_binding(LegacyBinding {\n+                    parent: invocation.legacy_scope.get(),\n+                    kind: LegacyBindingKind::MacroUse(visitor.legacy_imports),\n+                }))\n+            });\n+        }\n     }\n \n     fn add_macro(&mut self, scope: Mark, mut def: ast::MacroDef) {\n         if &def.ident.name.as_str() == \"macro_rules\" {\n             self.session.span_err(def.span, \"user-defined macros may not be named `macro_rules`\");\n         }\n         if def.use_locally {\n-            let ExpansionData { mut module, backtrace, .. } = self.expansion_data[&scope];\n-            while module.macros_escape {\n-                module = module.parent.unwrap();\n-            }\n-            let binding = NameBinding {\n-                ext: Rc::new(macro_rules::compile(&self.session.parse_sess, &def)),\n-                expansion: backtrace.data().prev_ctxt.data().outer_mark,\n-                shadowing: self.resolve_macro_name(scope, def.ident.name, false).is_some(),\n-                span: def.span,\n-            };\n-            module.macros.borrow_mut().insert(def.ident.name, binding);\n+            let invocation = self.invocations[&scope];\n+            let ext = Rc::new(macro_rules::compile(&self.session.parse_sess, &def));\n+            let binding = self.arenas.alloc_legacy_binding(LegacyBinding {\n+                parent: invocation.legacy_scope.get(),\n+                kind: LegacyBindingKind::MacroRules(def.ident.name, ext, def.span),\n+            });\n+            invocation.legacy_scope.set(LegacyScope::Binding(binding));\n             self.macro_names.insert(def.ident.name);\n         }\n         if def.export {\n@@ -104,12 +150,7 @@ impl<'a> base::Resolver for Resolver<'a> {\n         if let NormalTT(..) = *ext {\n             self.macro_names.insert(ident.name);\n         }\n-        self.graph_root.macros.borrow_mut().insert(ident.name, NameBinding {\n-            ext: ext,\n-            expansion: Mark::root(),\n-            shadowing: false,\n-            span: DUMMY_SP,\n-        });\n+        self.builtin_macros.insert(ident.name, ext);\n     }\n \n     fn add_expansions_at_stmt(&mut self, id: ast::NodeId, macros: Vec<Mark>) {\n@@ -119,8 +160,8 @@ impl<'a> base::Resolver for Resolver<'a> {\n     fn find_attr_invoc(&mut self, attrs: &mut Vec<ast::Attribute>) -> Option<ast::Attribute> {\n         for i in 0..attrs.len() {\n             let name = intern(&attrs[i].name());\n-            match self.expansion_data[&Mark::root()].module.macros.borrow().get(&name) {\n-                Some(binding) => match *binding.ext {\n+            match self.builtin_macros.get(&name) {\n+                Some(ext) => match **ext {\n                     MultiModifier(..) | MultiDecorator(..) | SyntaxExtension::AttrProcMacro(..) => {\n                         return Some(attrs.remove(i))\n                     }\n@@ -147,7 +188,11 @@ impl<'a> base::Resolver for Resolver<'a> {\n             InvocationKind::Attr { ref attr, .. } => (intern(&*attr.name()), attr.span),\n         };\n \n-        self.resolve_macro_name(scope, name, true).or_else(|| {\n+        let invocation = self.invocations[&scope];\n+        if let LegacyScope::Expansion(parent) = invocation.legacy_scope.get() {\n+            invocation.legacy_scope.set(LegacyScope::simplify_expansion(parent));\n+        }\n+        self.resolve_macro_name(invocation.legacy_scope.get(), name, true).or_else(|| {\n             let mut err =\n                 self.session.struct_span_err(span, &format!(\"macro undefined: '{}!'\", name));\n             self.suggest_macro_name(&name.as_str(), &mut err);\n@@ -162,36 +207,57 @@ impl<'a> base::Resolver for Resolver<'a> {\n }\n \n impl<'a> Resolver<'a> {\n-    pub fn resolve_macro_name(&mut self, scope: Mark, name: ast::Name, record_used: bool)\n+    pub fn resolve_macro_name(&mut self,\n+                              mut scope: LegacyScope<'a>,\n+                              name: ast::Name,\n+                              record_used: bool)\n                               -> Option<Rc<SyntaxExtension>> {\n-        let ExpansionData { mut module, backtrace, .. } = self.expansion_data[&scope];\n+        let check_shadowing = |this: &mut Self, relative_depth, scope, span| {\n+            if record_used && relative_depth > 0 {\n+                this.disallowed_shadowing.push((name, span, scope));\n+            }\n+        };\n+\n+        let mut relative_depth: u32 = 0;\n         loop {\n-            if let Some(binding) = module.macros.borrow().get(&name) {\n-                let mut backtrace = backtrace.data();\n-                while binding.expansion != backtrace.outer_mark {\n-                    if backtrace.outer_mark != Mark::root() {\n-                        backtrace = backtrace.prev_ctxt.data();\n-                        continue\n+            scope = match scope {\n+                LegacyScope::Empty => break,\n+                LegacyScope::Expansion(invocation) => {\n+                    if let LegacyScope::Empty = invocation.expansion.get() {\n+                        invocation.legacy_scope.get()\n+                    } else {\n+                        relative_depth += 1;\n+                        invocation.expansion.get()\n                     }\n-\n-                    if record_used && binding.shadowing &&\n-                       self.macro_shadowing_errors.insert(binding.span) {\n-                        let msg = format!(\"`{}` is already in scope\", name);\n-                        self.session.struct_span_err(binding.span, &msg)\n-                            .note(\"macro-expanded `macro_rules!`s and `#[macro_use]`s \\\n-                                   may not shadow existing macros (see RFC 1560)\")\n-                            .emit();\n+                }\n+                LegacyScope::Invocation(invocation) => {\n+                    let new_relative_depth = relative_depth.saturating_sub(1);\n+                    let mut scope = invocation.legacy_scope.get();\n+                    if let LegacyScope::Binding(binding) = scope {\n+                        match binding.kind {\n+                            LegacyBindingKind::MacroUse(ref imports) => {\n+                                if let Some(&(ref ext, span)) = imports.get(&name) {\n+                                    check_shadowing(self, relative_depth, binding.parent, span);\n+                                    return Some(ext.clone());\n+                                }\n+                            },\n+                            LegacyBindingKind::MacroRules(name_, ref ext, span) => {\n+                                if name_ == name {\n+                                    check_shadowing(self, new_relative_depth, binding.parent, span);\n+                                    return Some(ext.clone());\n+                                }\n+                            }\n+                        }\n+                        scope = binding.parent\n                     }\n-                    break\n+                    relative_depth = new_relative_depth;\n+                    scope\n                 }\n-                return Some(binding.ext.clone());\n-            }\n-            match module.parent {\n-                Some(parent) => module = parent,\n-                None => break,\n-            }\n+                _ => unreachable!(),\n+            };\n         }\n-        None\n+\n+        self.builtin_macros.get(&name).cloned()\n     }\n \n     fn suggest_macro_name(&mut self, name: &str, err: &mut DiagnosticBuilder<'a>) {\n@@ -204,15 +270,19 @@ impl<'a> Resolver<'a> {\n         }\n     }\n \n-    fn collect_def_ids(&mut self, mark: Mark, expansion: &Expansion) {\n-        let expansion_data = &mut self.expansion_data;\n-        let ExpansionData { backtrace, def_index, const_integer, module } = expansion_data[&mark];\n+    fn collect_def_ids(&mut self, invocation: &'a InvocationData<'a>, expansion: &Expansion) {\n+        let Resolver { ref mut invocations, arenas, graph_root, .. } = *self;\n+        let InvocationData { def_index, const_integer, .. } = *invocation;\n+\n         let visit_macro_invoc = &mut |invoc: map::MacroInvocationData| {\n-            expansion_data.entry(invoc.mark).or_insert(ExpansionData {\n-                backtrace: backtrace.apply_mark(invoc.mark),\n-                def_index: invoc.def_index,\n-                const_integer: invoc.const_integer,\n-                module: module,\n+            invocations.entry(invoc.mark).or_insert_with(|| {\n+                arenas.alloc_invocation_data(InvocationData {\n+                    def_index: invoc.def_index,\n+                    const_integer: invoc.const_integer,\n+                    module: Cell::new(graph_root),\n+                    expansion: Cell::new(LegacyScope::Empty),\n+                    legacy_scope: Cell::new(LegacyScope::Empty),\n+                })\n             });\n         };\n "}, {"sha": "923d5d05439e462ea304d46c3066e4dea718dda8", "filename": "src/libsyntax/ext/base.rs", "status": "modified", "additions": 0, "deletions": 23, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/d5281ef681195828173d4fe516b653ba0f9e9fbc/src%2Flibsyntax%2Fext%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d5281ef681195828173d4fe516b653ba0f9e9fbc/src%2Flibsyntax%2Fext%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbase.rs?ref=d5281ef681195828173d4fe516b653ba0f9e9fbc", "patch": "@@ -22,7 +22,6 @@ use parse::{self, parser};\n use parse::token;\n use parse::token::{InternedString, str_to_ident};\n use ptr::P;\n-use std_inject;\n use util::small_vector::SmallVector;\n \n use std::path::PathBuf;\n@@ -737,28 +736,6 @@ impl<'a> ExtCtxt<'a> {\n     pub fn name_of(&self, st: &str) -> ast::Name {\n         token::intern(st)\n     }\n-\n-    pub fn initialize(&mut self, user_exts: Vec<NamedSyntaxExtension>, krate: &ast::Crate) {\n-        if std_inject::no_core(&krate) {\n-            self.crate_root = None;\n-        } else if std_inject::no_std(&krate) {\n-            self.crate_root = Some(\"core\");\n-        } else {\n-            self.crate_root = Some(\"std\");\n-        }\n-\n-        for (name, extension) in user_exts {\n-            let ident = ast::Ident::with_empty_ctxt(name);\n-            self.resolver.add_ext(ident, Rc::new(extension));\n-        }\n-\n-        let mut module = ModuleData {\n-            mod_path: vec![token::str_to_ident(&self.ecfg.crate_name)],\n-            directory: PathBuf::from(self.parse_sess.codemap().span_to_filename(krate.span)),\n-        };\n-        module.directory.pop();\n-        self.current_expansion.module = Rc::new(module);\n-    }\n }\n \n /// Extract a string literal from the macro expanded version of `expr`,"}, {"sha": "ab7ffe36673ac1568855c2e34b40e637a1e33a68", "filename": "src/libsyntax/ext/expand.rs", "status": "modified", "additions": 19, "deletions": 30, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/d5281ef681195828173d4fe516b653ba0f9e9fbc/src%2Flibsyntax%2Fext%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d5281ef681195828173d4fe516b653ba0f9e9fbc/src%2Flibsyntax%2Fext%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fexpand.rs?ref=d5281ef681195828173d4fe516b653ba0f9e9fbc", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use ast::{Block, Crate, Ident, Mac_, PatKind};\n+use ast::{Block, Ident, Mac_, PatKind};\n use ast::{Name, MacStmtStyle, StmtKind, ItemKind};\n use ast;\n use ext::hygiene::Mark;\n@@ -26,6 +26,7 @@ use parse::parser::Parser;\n use parse::token::{self, intern, keywords};\n use print::pprust;\n use ptr::P;\n+use std_inject;\n use tokenstream::{TokenTree, TokenStream};\n use util::small_vector::SmallVector;\n use visit::Visitor;\n@@ -186,8 +187,14 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n         MacroExpander { cx: cx, monotonic: monotonic }\n     }\n \n-    fn expand_crate(&mut self, mut krate: ast::Crate) -> ast::Crate {\n-        let err_count = self.cx.parse_sess.span_diagnostic.err_count();\n+    pub fn expand_crate(&mut self, mut krate: ast::Crate) -> ast::Crate {\n+        self.cx.crate_root = std_inject::injected_crate_name(&krate);\n+        let mut module = ModuleData {\n+            mod_path: vec![token::str_to_ident(&self.cx.ecfg.crate_name)],\n+            directory: PathBuf::from(self.cx.codemap().span_to_filename(krate.span)),\n+        };\n+        module.directory.pop();\n+        self.cx.current_expansion.module = Rc::new(module);\n \n         let krate_item = Expansion::Items(SmallVector::one(P(ast::Item {\n             attrs: krate.attrs,\n@@ -206,10 +213,6 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n             _ => unreachable!(),\n         };\n \n-        if self.cx.parse_sess.span_diagnostic.err_count() - self.cx.resolve_err_count > err_count {\n-            self.cx.parse_sess.span_diagnostic.abort_if_errors();\n-        }\n-\n         krate\n     }\n \n@@ -221,7 +224,7 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n         let (expansion, mut invocations) = self.collect_invocations(expansion);\n         invocations.reverse();\n \n-        let mut expansions = vec![vec![(0, expansion)]];\n+        let mut expansions = Vec::new();\n         while let Some(invoc) = invocations.pop() {\n             let ExpansionData { depth, mark, .. } = invoc.expansion_data;\n             self.cx.current_expansion = invoc.expansion_data.clone();\n@@ -233,13 +236,12 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n                 None => invoc.expansion_kind.dummy(invoc.span()),\n             };\n \n-            self.cx.current_expansion.depth = depth + 1;\n             let (expansion, new_invocations) = self.collect_invocations(expansion);\n \n-            if expansions.len() == depth {\n+            if expansions.len() < depth {\n                 expansions.push(Vec::new());\n             }\n-            expansions[depth].push((mark.as_u32(), expansion));\n+            expansions[depth - 1].push((mark.as_u32(), expansion));\n             if !self.cx.ecfg.single_step {\n                 invocations.extend(new_invocations.into_iter().rev());\n             }\n@@ -250,12 +252,11 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n         let mut placeholder_expander = PlaceholderExpander::new(self.cx, self.monotonic);\n         while let Some(expansions) = expansions.pop() {\n             for (mark, expansion) in expansions.into_iter().rev() {\n-                let expansion = expansion.fold_with(&mut placeholder_expander);\n                 placeholder_expander.add(ast::NodeId::from_u32(mark), expansion);\n             }\n         }\n \n-        placeholder_expander.remove(ast::NodeId::from_u32(0))\n+        expansion.fold_with(&mut placeholder_expander)\n     }\n \n     fn collect_invocations(&mut self, expansion: Expansion) -> (Expansion, Vec<Invocation>) {\n@@ -538,7 +539,11 @@ impl<'a, 'b> InvocationCollector<'a, 'b> {\n         self.invocations.push(Invocation {\n             kind: kind,\n             expansion_kind: expansion_kind,\n-            expansion_data: ExpansionData { mark: mark, ..self.cx.current_expansion.clone() },\n+            expansion_data: ExpansionData {\n+                mark: mark,\n+                depth: self.cx.current_expansion.depth + 1,\n+                ..self.cx.current_expansion.clone()\n+            },\n         });\n         placeholder(expansion_kind, ast::NodeId::from_u32(mark.as_u32()))\n     }\n@@ -866,22 +871,6 @@ impl<'feat> ExpansionConfig<'feat> {\n     }\n }\n \n-pub fn expand_crate(cx: &mut ExtCtxt,\n-                    user_exts: Vec<NamedSyntaxExtension>,\n-                    c: Crate) -> Crate {\n-    cx.initialize(user_exts, &c);\n-    cx.monotonic_expander().expand_crate(c)\n-}\n-\n-// Expands crate using supplied MacroExpander - allows for\n-// non-standard expansion behaviour (e.g. step-wise).\n-pub fn expand_crate_with_expander(expander: &mut MacroExpander,\n-                                  user_exts: Vec<NamedSyntaxExtension>,\n-                                  c: Crate) -> Crate {\n-    expander.cx.initialize(user_exts, &c);\n-    expander.expand_crate(c)\n-}\n-\n // A Marker adds the given mark to the syntax context and\n // sets spans' `expn_id` to the given expn_id (unless it is `None`).\n struct Marker { mark: Mark, expn_id: Option<ExpnId> }"}, {"sha": "e323dd2f623276c16de3cfd6682194867f5c1ec1", "filename": "src/libsyntax/ext/placeholders.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/d5281ef681195828173d4fe516b653ba0f9e9fbc/src%2Flibsyntax%2Fext%2Fplaceholders.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d5281ef681195828173d4fe516b653ba0f9e9fbc/src%2Flibsyntax%2Fext%2Fplaceholders.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fplaceholders.rs?ref=d5281ef681195828173d4fe516b653ba0f9e9fbc", "patch": "@@ -88,10 +88,11 @@ impl<'a, 'b> PlaceholderExpander<'a, 'b> {\n     }\n \n     pub fn add(&mut self, id: ast::NodeId, expansion: Expansion) {\n+        let expansion = expansion.fold_with(self);\n         self.expansions.insert(id, expansion);\n     }\n \n-    pub fn remove(&mut self, id: ast::NodeId) -> Expansion {\n+    fn remove(&mut self, id: ast::NodeId) -> Expansion {\n         self.expansions.remove(&id).unwrap()\n     }\n }"}, {"sha": "ecb437f31a5ad03d6462ed034d20a3a86a49fa28", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d5281ef681195828173d4fe516b653ba0f9e9fbc/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d5281ef681195828173d4fe516b653ba0f9e9fbc/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=d5281ef681195828173d4fe516b653ba0f9e9fbc", "patch": "@@ -112,7 +112,7 @@ pub fn print_crate<'a>(cm: &'a CodeMap,\n                                       out,\n                                       ann,\n                                       is_expanded);\n-    if is_expanded && !std_inject::no_std(krate) {\n+    if is_expanded && !std_inject::injected_crate_name(krate).is_none() {\n         // We need to print `#![no_std]` (and its feature gate) so that\n         // compiling pretty-printed source won't inject libstd again.\n         // However we don't want these attributes in the AST because"}, {"sha": "1b63a2b70763aff5da297077c8134a958490c0d9", "filename": "src/libsyntax/std_inject.rs", "status": "modified", "additions": 12, "deletions": 10, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/d5281ef681195828173d4fe516b653ba0f9e9fbc/src%2Flibsyntax%2Fstd_inject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d5281ef681195828173d4fe516b653ba0f9e9fbc/src%2Flibsyntax%2Fstd_inject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fstd_inject.rs?ref=d5281ef681195828173d4fe516b653ba0f9e9fbc", "patch": "@@ -34,23 +34,25 @@ fn ignored_span(sess: &ParseSess, sp: Span) -> Span {\n     return sp;\n }\n \n-pub fn no_core(krate: &ast::Crate) -> bool {\n-    attr::contains_name(&krate.attrs, \"no_core\")\n-}\n-\n-pub fn no_std(krate: &ast::Crate) -> bool {\n-    attr::contains_name(&krate.attrs, \"no_std\") || no_core(krate)\n+pub fn injected_crate_name(krate: &ast::Crate) -> Option<&'static str> {\n+    if attr::contains_name(&krate.attrs, \"no_core\") {\n+        None\n+    } else if attr::contains_name(&krate.attrs, \"no_std\") {\n+        Some(\"core\")\n+    } else {\n+        Some(\"std\")\n+    }\n }\n \n pub fn maybe_inject_crates_ref(sess: &ParseSess,\n                                mut krate: ast::Crate,\n                                alt_std_name: Option<String>)\n                                -> ast::Crate {\n-    if no_core(&krate) {\n-        return krate;\n-    }\n+    let name = match injected_crate_name(&krate) {\n+        Some(name) => name,\n+        None => return krate,\n+    };\n \n-    let name = if no_std(&krate) { \"core\" } else { \"std\" };\n     let crate_name = token::intern(&alt_std_name.unwrap_or(name.to_string()));\n \n     krate.module.items.insert(0, P(ast::Item {"}, {"sha": "f336b26ae41f2f3b63dc4cbcc99cc13ab2af94e0", "filename": "src/libsyntax_ext/lib.rs", "status": "modified", "additions": 14, "deletions": 7, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/d5281ef681195828173d4fe516b653ba0f9e9fbc/src%2Flibsyntax_ext%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d5281ef681195828173d4fe516b653ba0f9e9fbc/src%2Flibsyntax_ext%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Flib.rs?ref=d5281ef681195828173d4fe516b653ba0f9e9fbc", "patch": "@@ -50,20 +50,23 @@ pub mod deriving;\n \n use std::rc::Rc;\n use syntax::ast;\n-use syntax::ext::base::{MacroExpanderFn, NormalTT, IdentTT, MultiModifier};\n+use syntax::ext::base::{MacroExpanderFn, NormalTT, IdentTT, MultiModifier, NamedSyntaxExtension};\n use syntax::ext::tt::macro_rules::MacroRulesExpander;\n use syntax::parse::token::intern;\n \n-pub fn register_builtins(resolver: &mut syntax::ext::base::Resolver, enable_quotes: bool) {\n+pub fn register_builtins(resolver: &mut syntax::ext::base::Resolver,\n+                         user_exts: Vec<NamedSyntaxExtension>,\n+                         enable_quotes: bool) {\n     let mut register = |name, ext| {\n-        resolver.add_ext(ast::Ident::with_empty_ctxt(intern(name)), Rc::new(ext));\n+        resolver.add_ext(ast::Ident::with_empty_ctxt(name), Rc::new(ext));\n     };\n \n-    register(\"macro_rules\", IdentTT(Box::new(MacroRulesExpander), None, false));\n+    register(intern(\"macro_rules\"), IdentTT(Box::new(MacroRulesExpander), None, false));\n \n     macro_rules! register {\n         ($( $name:ident: $f:expr, )*) => { $(\n-            register(stringify!($name), NormalTT(Box::new($f as MacroExpanderFn), None, false));\n+            register(intern(stringify!($name)),\n+                     NormalTT(Box::new($f as MacroExpanderFn), None, false));\n         )* }\n     }\n \n@@ -108,7 +111,11 @@ pub fn register_builtins(resolver: &mut syntax::ext::base::Resolver, enable_quot\n     }\n \n     // format_args uses `unstable` things internally.\n-    register(\"format_args\", NormalTT(Box::new(format::expand_format_args), None, true));\n+    register(intern(\"format_args\"), NormalTT(Box::new(format::expand_format_args), None, true));\n \n-    register(\"derive\", MultiModifier(Box::new(deriving::expand_derive)));\n+    register(intern(\"derive\"), MultiModifier(Box::new(deriving::expand_derive)));\n+\n+    for (name, ext) in user_exts {\n+        register(name, ext);\n+    }\n }"}]}