{"sha": "7d32533eabb5321a0b2690bf16d07077b4f91562", "node_id": "MDY6Q29tbWl0NzI0NzEyOjdkMzI1MzNlYWJiNTMyMWEwYjI2OTBiZjE2ZDA3MDc3YjRmOTE1NjI=", "commit": {"author": {"name": "Ariel Ben-Yehuda", "email": "arielb1@mail.tau.ac.il", "date": "2015-08-07T10:48:29Z"}, "committer": {"name": "Ariel Ben-Yehuda", "email": "arielb1@mail.tau.ac.il", "date": "2015-08-07T10:48:29Z"}, "message": "add documentation", "tree": {"sha": "397204ac87882115e2d0336a0e298349fa6af2ca", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/397204ac87882115e2d0336a0e298349fa6af2ca"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7d32533eabb5321a0b2690bf16d07077b4f91562", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7d32533eabb5321a0b2690bf16d07077b4f91562", "html_url": "https://github.com/rust-lang/rust/commit/7d32533eabb5321a0b2690bf16d07077b4f91562", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7d32533eabb5321a0b2690bf16d07077b4f91562/comments", "author": null, "committer": null, "parents": [{"sha": "015300109d96a70d63ee12c012cc5170defbf133", "url": "https://api.github.com/repos/rust-lang/rust/commits/015300109d96a70d63ee12c012cc5170defbf133", "html_url": "https://github.com/rust-lang/rust/commit/015300109d96a70d63ee12c012cc5170defbf133"}], "stats": {"total": 87, "additions": 57, "deletions": 30}, "files": [{"sha": "86fe1f8b0b52056316cef9eba89658990941980b", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 57, "deletions": 30, "changes": 87, "blob_url": "https://github.com/rust-lang/rust/blob/7d32533eabb5321a0b2690bf16d07077b4f91562/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d32533eabb5321a0b2690bf16d07077b4f91562/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=7d32533eabb5321a0b2690bf16d07077b4f91562", "patch": "@@ -3192,40 +3192,56 @@ pub type ADTDef<'tcx> = ADTDef_<'tcx, 'static>;\n pub type VariantDef<'tcx> = VariantDef_<'tcx, 'static>;\n pub type FieldDef<'tcx> = FieldDef_<'tcx, 'static>;\n \n-pub struct VariantDef_<'tcx, 'lt: 'tcx> {\n+pub struct VariantDef_<'tcx, 'container: 'tcx> {\n     pub did: DefId,\n     pub name: Name, // struct's name if this is a struct\n     pub disr_val: Disr,\n-    pub fields: Vec<FieldDef_<'tcx, 'lt>>\n+    pub fields: Vec<FieldDef_<'tcx, 'container>>\n }\n \n-pub struct FieldDef_<'tcx, 'lt: 'tcx> {\n+pub struct FieldDef_<'tcx, 'container: 'tcx> {\n+    /// The field's DefId. NOTE: the fields of tuple-like enum variants\n+    /// are not real items, and don't have entries in tcache etc.\n     pub did: DefId,\n-    // special_idents::unnamed_field.name\n-    // if this is a tuple-like field\n+    /// special_idents::unnamed_field.name\n+    /// if this is a tuple-like field\n     pub name: Name,\n     pub vis: ast::Visibility,\n-    // TyIVar is used here to allow for\n-    ty: TyIVar<'tcx, 'lt>\n+    /// TyIVar is used here to allow for variance (see the doc at\n+    /// ADTDef_).\n+    ty: TyIVar<'tcx, 'container>\n }\n \n-/// The definition of an abstract data type - a struct or enum. 'lt\n-/// is here so 'tcx can be variant.\n-pub struct ADTDef_<'tcx, 'lt: 'tcx> {\n+/// The definition of an abstract data type - a struct or enum.\n+///\n+/// These are all interned (by intern_adt_def) into the adt_defs\n+/// table.\n+///\n+/// Because of the possibility of nested tcx-s, this type\n+/// needs 2 lifetimes: the traditional variant lifetime ('tcx)\n+/// bounding the lifetime of the inner types is of course necessary.\n+/// However, it is not sufficient - types from a child tcx must\n+/// not be leaked into the master tcx by being stored in an ADTDef_.\n+///\n+/// The 'container lifetime ensures that by outliving the container\n+/// tcx and preventing shorter-lived types from being inserted. When\n+/// write access is not needed, the 'container lifetime can be\n+/// erased to 'static, which can be done by the ADTDef wrapper.\n+pub struct ADTDef_<'tcx, 'container: 'tcx> {\n     pub did: DefId,\n-    pub variants: Vec<VariantDef_<'tcx, 'lt>>,\n+    pub variants: Vec<VariantDef_<'tcx, 'container>>,\n     flags: Cell<ADTFlags>,\n }\n \n-impl<'tcx, 'lt> PartialEq for ADTDef_<'tcx, 'lt> {\n+impl<'tcx, 'container> PartialEq for ADTDef_<'tcx, 'container> {\n     // ADTDef are always interned and this is part of TyS equality\n     #[inline]\n     fn eq(&self, other: &Self) -> bool { self as *const _ == other as *const _ }\n }\n \n-impl<'tcx, 'lt> Eq for ADTDef_<'tcx, 'lt> {}\n+impl<'tcx, 'container> Eq for ADTDef_<'tcx, 'container> {}\n \n-impl<'tcx, 'lt> Hash for ADTDef_<'tcx, 'lt> {\n+impl<'tcx, 'container> Hash for ADTDef_<'tcx, 'container> {\n     #[inline]\n     fn hash<H: Hasher>(&self, s: &mut H) {\n         (self as *const ADTDef).hash(s)\n@@ -3239,11 +3255,11 @@ pub enum ADTKind { Struct, Enum }\n #[derive(Copy, Clone, Debug, Eq, PartialEq)]\n pub enum VariantKind { Dict, Tuple, Unit }\n \n-impl<'tcx, 'lt> ADTDef_<'tcx, 'lt> {\n+impl<'tcx, 'container> ADTDef_<'tcx, 'container> {\n     fn new(tcx: &ctxt<'tcx>,\n            did: DefId,\n            kind: ADTKind,\n-           variants: Vec<VariantDef_<'tcx, 'lt>>) -> Self {\n+           variants: Vec<VariantDef_<'tcx, 'container>>) -> Self {\n         let mut flags = ADTFlags::NO_ADT_FLAGS;\n         let attrs = tcx.get_attrs(did);\n         if attrs.iter().any(|item| item.check_name(\"fundamental\")) {\n@@ -3272,6 +3288,7 @@ impl<'tcx, 'lt> ADTDef_<'tcx, 'lt> {\n         self.flags.set(self.flags.get() | ADTFlags::IS_DTORCK_VALID)\n     }\n \n+    /// Returns the kind of the ADT - Struct or Enum.\n     #[inline]\n     pub fn adt_kind(&self) -> ADTKind {\n         if self.flags.get().intersects(ADTFlags::IS_ENUM) {\n@@ -3281,6 +3298,9 @@ impl<'tcx, 'lt> ADTDef_<'tcx, 'lt> {\n         }\n     }\n \n+    /// Returns whether this is a dtorck type. If this returns\n+    /// true, this type being safe for destruction requires it to be\n+    /// alive; Otherwise, only the contents are required to be.\n     #[inline]\n     pub fn is_dtorck(&'tcx self, tcx: &ctxt<'tcx>) -> bool {\n         if !self.flags.get().intersects(ADTFlags::IS_DTORCK_VALID) {\n@@ -3289,6 +3309,8 @@ impl<'tcx, 'lt> ADTDef_<'tcx, 'lt> {\n         self.flags.get().intersects(ADTFlags::IS_DTORCK)\n     }\n \n+    /// Returns whether this type is #[fundamental] for the purposes\n+    /// of coherence checking.\n     #[inline]\n     pub fn is_fundamental(&self) -> bool {\n         self.flags.get().intersects(ADTFlags::IS_FUNDAMENTAL)\n@@ -3299,17 +3321,20 @@ impl<'tcx, 'lt> ADTDef_<'tcx, 'lt> {\n         self.flags.get().intersects(ADTFlags::IS_SIMD)\n     }\n \n+    /// Returns true if this is PhantomData<T>.\n     #[inline]\n     pub fn is_phantom_data(&self) -> bool {\n         self.flags.get().intersects(ADTFlags::IS_PHANTOM_DATA)\n     }\n \n-    #[inline(never)]\n+    /// Returns whether this type has a destructor.\n     pub fn has_dtor(&self, tcx: &ctxt<'tcx>) -> bool {\n         tcx.destructor_for_type.borrow().contains_key(&self.did)\n     }\n \n-    pub fn struct_variant(&self) -> &ty::VariantDef_<'tcx, 'lt> {\n+    /// Asserts this is a struct and returns the struct's unique\n+    /// variant.\n+    pub fn struct_variant(&self) -> &ty::VariantDef_<'tcx, 'container> {\n         assert!(self.adt_kind() == ADTKind::Struct);\n         &self.variants[0]\n     }\n@@ -3324,13 +3349,15 @@ impl<'tcx, 'lt> ADTDef_<'tcx, 'lt> {\n         tcx.lookup_predicates(self.did)\n     }\n \n+    /// Returns an iterator over all fields contained\n+    /// by this ADT.\n     #[inline]\n     pub fn all_fields(&self) ->\n             iter::FlatMap<\n-                slice::Iter<VariantDef_<'tcx, 'lt>>,\n-                slice::Iter<FieldDef_<'tcx, 'lt>>,\n-                for<'s> fn(&'s VariantDef_<'tcx, 'lt>)\n-                    -> slice::Iter<'s, FieldDef_<'tcx, 'lt>>\n+                slice::Iter<VariantDef_<'tcx, 'container>>,\n+                slice::Iter<FieldDef_<'tcx, 'container>>,\n+                for<'s> fn(&'s VariantDef_<'tcx, 'container>)\n+                    -> slice::Iter<'s, FieldDef_<'tcx, 'container>>\n             > {\n         self.variants.iter().flat_map(VariantDef_::fields_iter)\n     }\n@@ -3350,14 +3377,14 @@ impl<'tcx, 'lt> ADTDef_<'tcx, 'lt> {\n             self.variants.iter().all(|v| v.fields.is_empty())\n     }\n \n-    pub fn variant_with_id(&self, vid: DefId) -> &VariantDef_<'tcx, 'lt> {\n+    pub fn variant_with_id(&self, vid: DefId) -> &VariantDef_<'tcx, 'container> {\n         self.variants\n             .iter()\n             .find(|v| v.did == vid)\n             .expect(\"variant_with_id: unknown variant\")\n     }\n \n-    pub fn variant_of_def(&self, def: def::Def) -> &VariantDef_<'tcx, 'lt> {\n+    pub fn variant_of_def(&self, def: def::Def) -> &VariantDef_<'tcx, 'container> {\n         match def {\n             def::DefVariant(_, vid, _) => self.variant_with_id(vid),\n             def::DefStruct(..) | def::DefTy(..) => self.struct_variant(),\n@@ -3366,9 +3393,9 @@ impl<'tcx, 'lt> ADTDef_<'tcx, 'lt> {\n     }\n }\n \n-impl<'tcx, 'lt> VariantDef_<'tcx, 'lt> {\n+impl<'tcx, 'container> VariantDef_<'tcx, 'container> {\n     #[inline]\n-    fn fields_iter(&self) -> slice::Iter<FieldDef_<'tcx, 'lt>> {\n+    fn fields_iter(&self) -> slice::Iter<FieldDef_<'tcx, 'container>> {\n         self.fields.iter()\n     }\n \n@@ -3387,17 +3414,17 @@ impl<'tcx, 'lt> VariantDef_<'tcx, 'lt> {\n     }\n \n     #[inline]\n-    pub fn find_field_named(&self, name: ast::Name) -> Option<&FieldDef_<'tcx, 'lt>> {\n+    pub fn find_field_named(&self, name: ast::Name) -> Option<&FieldDef_<'tcx, 'container>> {\n         self.fields.iter().find(|f| f.name == name)\n     }\n \n     #[inline]\n-    pub fn field_named(&self, name: ast::Name) -> &FieldDef_<'tcx, 'lt> {\n+    pub fn field_named(&self, name: ast::Name) -> &FieldDef_<'tcx, 'container> {\n         self.find_field_named(name).unwrap()\n     }\n }\n \n-impl<'tcx, 'lt> FieldDef_<'tcx, 'lt> {\n+impl<'tcx, 'container> FieldDef_<'tcx, 'container> {\n     pub fn new(did: DefId,\n                name: Name,\n                vis: ast::Visibility) -> Self {\n@@ -3417,7 +3444,7 @@ impl<'tcx, 'lt> FieldDef_<'tcx, 'lt> {\n         self.ty.unwrap()\n     }\n \n-    pub fn fulfill_ty(&self, ty: Ty<'lt>) {\n+    pub fn fulfill_ty(&self, ty: Ty<'container>) {\n         self.ty.fulfill(ty);\n     }\n }"}]}