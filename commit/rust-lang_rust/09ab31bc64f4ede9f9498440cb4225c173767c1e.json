{"sha": "09ab31bc64f4ede9f9498440cb4225c173767c1e", "node_id": "MDY6Q29tbWl0NzI0NzEyOjA5YWIzMWJjNjRmNGVkZTlmOTQ5ODQ0MGNiNDIyNWMxNzM3NjdjMWU=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-07-08T22:03:26Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-07-08T22:03:26Z"}, "message": "Auto merge of #61224 - aloucks:drain_filter, r=Gankro\n\nPrevent Vec::drain_filter from double dropping on panic\n\nFixes: #60977\n\nThe changes in this PR prevent leaking and double-panicking in addition to double-drop.\n\nTracking issue: #43244", "tree": {"sha": "ed67d1a0bd7bf9a8ca4ef9c150ec5f9b427e0f59", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ed67d1a0bd7bf9a8ca4ef9c150ec5f9b427e0f59"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/09ab31bc64f4ede9f9498440cb4225c173767c1e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/09ab31bc64f4ede9f9498440cb4225c173767c1e", "html_url": "https://github.com/rust-lang/rust/commit/09ab31bc64f4ede9f9498440cb4225c173767c1e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/09ab31bc64f4ede9f9498440cb4225c173767c1e/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "78ca1bda3522b14bc0336bc01dd1d49fdba2cda7", "url": "https://api.github.com/repos/rust-lang/rust/commits/78ca1bda3522b14bc0336bc01dd1d49fdba2cda7", "html_url": "https://github.com/rust-lang/rust/commit/78ca1bda3522b14bc0336bc01dd1d49fdba2cda7"}, {"sha": "df5b32ee9b98838c1cccc93f75f941ecafc9d086", "url": "https://api.github.com/repos/rust-lang/rust/commits/df5b32ee9b98838c1cccc93f75f941ecafc9d086", "html_url": "https://github.com/rust-lang/rust/commit/df5b32ee9b98838c1cccc93f75f941ecafc9d086"}], "stats": {"total": 178, "additions": 169, "deletions": 9}, "files": [{"sha": "6e8ffe18522a06b683050016b256c1da3f2ced98", "filename": "src/liballoc/tests/vec.rs", "status": "modified", "additions": 109, "deletions": 0, "changes": 109, "blob_url": "https://github.com/rust-lang/rust/blob/09ab31bc64f4ede9f9498440cb4225c173767c1e/src%2Fliballoc%2Ftests%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/09ab31bc64f4ede9f9498440cb4225c173767c1e/src%2Fliballoc%2Ftests%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Ftests%2Fvec.rs?ref=09ab31bc64f4ede9f9498440cb4225c173767c1e", "patch": "@@ -944,6 +944,115 @@ fn drain_filter_complex() {\n     }\n }\n \n+#[test]\n+#[cfg(not(miri))] // Miri does not support catching panics\n+fn drain_filter_consumed_panic() {\n+    use std::rc::Rc;\n+    use std::sync::Mutex;\n+\n+    struct Check {\n+        index: usize,\n+        drop_counts: Rc<Mutex<Vec<usize>>>,\n+    };\n+\n+    impl Drop for Check {\n+        fn drop(&mut self) {\n+            self.drop_counts.lock().unwrap()[self.index] += 1;\n+            println!(\"drop: {}\", self.index);\n+        }\n+    }\n+\n+    let check_count = 10;\n+    let drop_counts = Rc::new(Mutex::new(vec![0_usize; check_count]));\n+    let mut data: Vec<Check> = (0..check_count)\n+        .map(|index| Check { index, drop_counts: Rc::clone(&drop_counts) })\n+        .collect();\n+\n+    let _ = std::panic::catch_unwind(move || {\n+        let filter = |c: &mut Check| {\n+            if c.index == 2 {\n+                panic!(\"panic at index: {}\", c.index);\n+            }\n+            // Verify that if the filter could panic again on another element\n+            // that it would not cause a double panic and all elements of the\n+            // vec would still be dropped exactly once.\n+            if c.index == 4 {\n+                panic!(\"panic at index: {}\", c.index);\n+            }\n+            c.index < 6\n+        };\n+        let drain = data.drain_filter(filter);\n+\n+        // NOTE: The DrainFilter is explictly consumed\n+        drain.for_each(drop);\n+    });\n+\n+    let drop_counts = drop_counts.lock().unwrap();\n+    assert_eq!(check_count, drop_counts.len());\n+\n+    for (index, count) in drop_counts.iter().cloned().enumerate() {\n+        assert_eq!(1, count, \"unexpected drop count at index: {} (count: {})\", index, count);\n+    }\n+}\n+\n+#[test]\n+#[cfg(not(miri))] // Miri does not support catching panics\n+fn drain_filter_unconsumed_panic() {\n+    use std::rc::Rc;\n+    use std::sync::Mutex;\n+\n+    struct Check {\n+        index: usize,\n+        drop_counts: Rc<Mutex<Vec<usize>>>,\n+    };\n+\n+    impl Drop for Check {\n+        fn drop(&mut self) {\n+            self.drop_counts.lock().unwrap()[self.index] += 1;\n+            println!(\"drop: {}\", self.index);\n+        }\n+    }\n+\n+    let check_count = 10;\n+    let drop_counts = Rc::new(Mutex::new(vec![0_usize; check_count]));\n+    let mut data: Vec<Check> = (0..check_count)\n+        .map(|index| Check { index, drop_counts: Rc::clone(&drop_counts) })\n+        .collect();\n+\n+    let _ = std::panic::catch_unwind(move || {\n+        let filter = |c: &mut Check| {\n+            if c.index == 2 {\n+                panic!(\"panic at index: {}\", c.index);\n+            }\n+            // Verify that if the filter could panic again on another element\n+            // that it would not cause a double panic and all elements of the\n+            // vec would still be dropped exactly once.\n+            if c.index == 4 {\n+                panic!(\"panic at index: {}\", c.index);\n+            }\n+            c.index < 6\n+        };\n+        let _drain = data.drain_filter(filter);\n+\n+        // NOTE: The DrainFilter is dropped without being consumed\n+    });\n+\n+    let drop_counts = drop_counts.lock().unwrap();\n+    assert_eq!(check_count, drop_counts.len());\n+\n+    for (index, count) in drop_counts.iter().cloned().enumerate() {\n+        assert_eq!(1, count, \"unexpected drop count at index: {} (count: {})\", index, count);\n+    }\n+}\n+\n+#[test]\n+fn drain_filter_unconsumed() {\n+    let mut vec = vec![1, 2, 3, 4];\n+    let drain = vec.drain_filter(|&mut x| x % 2 != 0);\n+    drop(drain);\n+    assert_eq!(vec, [2, 4]);\n+}\n+\n #[test]\n fn test_reserve_exact() {\n     // This is all the same as test_reserve"}, {"sha": "173946b312a59916ce5cccf4c724d1456094d123", "filename": "src/liballoc/vec.rs", "status": "modified", "additions": 60, "deletions": 9, "changes": 69, "blob_url": "https://github.com/rust-lang/rust/blob/09ab31bc64f4ede9f9498440cb4225c173767c1e/src%2Fliballoc%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/09ab31bc64f4ede9f9498440cb4225c173767c1e/src%2Fliballoc%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fvec.rs?ref=09ab31bc64f4ede9f9498440cb4225c173767c1e", "patch": "@@ -2152,6 +2152,7 @@ impl<T> Vec<T> {\n             del: 0,\n             old_len,\n             pred: filter,\n+            panic_flag: false,\n         }\n     }\n }\n@@ -2779,10 +2780,20 @@ pub struct DrainFilter<'a, T, F>\n     where F: FnMut(&mut T) -> bool,\n {\n     vec: &'a mut Vec<T>,\n+    /// The index of the item that will be inspected by the next call to `next`.\n     idx: usize,\n+    /// The number of items that have been drained (removed) thus far.\n     del: usize,\n+    /// The original length of `vec` prior to draining.\n     old_len: usize,\n+    /// The filter test predicate.\n     pred: F,\n+    /// A flag that indicates a panic has occured in the filter test prodicate.\n+    /// This is used as a hint in the drop implmentation to prevent consumption\n+    /// of the remainder of the `DrainFilter`. Any unprocessed items will be\n+    /// backshifted in the `vec`, but no further items will be dropped or\n+    /// tested by the filter predicate.\n+    panic_flag: bool,\n }\n \n #[unstable(feature = \"drain_filter\", reason = \"recently added\", issue = \"43244\")]\n@@ -2793,20 +2804,23 @@ impl<T, F> Iterator for DrainFilter<'_, T, F>\n \n     fn next(&mut self) -> Option<T> {\n         unsafe {\n-            while self.idx != self.old_len {\n+            while self.idx < self.old_len {\n                 let i = self.idx;\n-                self.idx += 1;\n                 let v = slice::from_raw_parts_mut(self.vec.as_mut_ptr(), self.old_len);\n-                if (self.pred)(&mut v[i]) {\n+                self.panic_flag = true;\n+                let drained = (self.pred)(&mut v[i]);\n+                self.panic_flag = false;\n+                // Update the index *after* the predicate is called. If the index\n+                // is updated prior and the predicate panics, the element at this\n+                // index would be leaked.\n+                self.idx += 1;\n+                if drained {\n                     self.del += 1;\n                     return Some(ptr::read(&v[i]));\n                 } else if self.del > 0 {\n                     let del = self.del;\n                     let src: *const T = &v[i];\n                     let dst: *mut T = &mut v[i - del];\n-                    // This is safe because self.vec has length 0\n-                    // thus its elements will not have Drop::drop\n-                    // called on them in the event of a panic.\n                     ptr::copy_nonoverlapping(src, dst, 1);\n                 }\n             }\n@@ -2824,9 +2838,46 @@ impl<T, F> Drop for DrainFilter<'_, T, F>\n     where F: FnMut(&mut T) -> bool,\n {\n     fn drop(&mut self) {\n-        self.for_each(drop);\n-        unsafe {\n-            self.vec.set_len(self.old_len - self.del);\n+        struct BackshiftOnDrop<'a, 'b, T, F>\n+            where\n+                F: FnMut(&mut T) -> bool,\n+        {\n+            drain: &'b mut DrainFilter<'a, T, F>,\n+        }\n+\n+        impl<'a, 'b, T, F> Drop for BackshiftOnDrop<'a, 'b, T, F>\n+            where\n+                F: FnMut(&mut T) -> bool\n+        {\n+            fn drop(&mut self) {\n+                unsafe {\n+                    if self.drain.idx < self.drain.old_len && self.drain.del > 0 {\n+                        // This is a pretty messed up state, and there isn't really an\n+                        // obviously right thing to do. We don't want to keep trying\n+                        // to execute `pred`, so we just backshift all the unprocessed\n+                        // elements and tell the vec that they still exist. The backshift\n+                        // is required to prevent a double-drop of the last successfully\n+                        // drained item prior to a panic in the predicate.\n+                        let ptr = self.drain.vec.as_mut_ptr();\n+                        let src = ptr.add(self.drain.idx);\n+                        let dst = src.sub(self.drain.del);\n+                        let tail_len = self.drain.old_len - self.drain.idx;\n+                        src.copy_to(dst, tail_len);\n+                    }\n+                    self.drain.vec.set_len(self.drain.old_len - self.drain.del);\n+                }\n+            }\n+        }\n+\n+        let backshift = BackshiftOnDrop {\n+            drain: self\n+        };\n+\n+        // Attempt to consume any remaining elements if the filter predicate\n+        // has not yet panicked. We'll backshift any remaining elements\n+        // whether we've already panicked or if the consumption here panics.\n+        if !backshift.drain.panic_flag {\n+            backshift.drain.for_each(drop);\n         }\n     }\n }"}]}