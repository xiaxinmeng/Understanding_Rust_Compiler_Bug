{"sha": "c7dbe7a830100c70d59994fd940bf75bb6e39b39", "node_id": "MDY6Q29tbWl0NzI0NzEyOmM3ZGJlN2E4MzAxMDBjNzBkNTk5OTRmZDk0MGJmNzViYjZlMzliMzk=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-09-12T13:29:56Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-09-12T13:29:56Z"}, "message": "Auto merge of #88881 - Manishearth:rollup-alohfwx, r=Manishearth\n\nRollup of 7 pull requests\n\nSuccessful merges:\n\n - #88336 ( Detect stricter constraints on gats where clauses in impls vs trait)\n - #88677 (rustc: Remove local variable IDs from `Export`s)\n - #88699 (Remove extra unshallow from cherry-pick checker)\n - #88709 (generic_const_exprs: use thir for abstract consts instead of mir)\n - #88711 (Rework DepthFirstSearch API)\n - #88810 (rustdoc: Cleanup `clean` part 1)\n - #88813 (explicitly link to external `ena` docs)\n\nFailed merges:\n\nr? `@ghost`\n`@rustbot` modify labels: rollup", "tree": {"sha": "a2588214f00d5970ce090c65cafad1b53b9f5814", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a2588214f00d5970ce090c65cafad1b53b9f5814"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c7dbe7a830100c70d59994fd940bf75bb6e39b39", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c7dbe7a830100c70d59994fd940bf75bb6e39b39", "html_url": "https://github.com/rust-lang/rust/commit/c7dbe7a830100c70d59994fd940bf75bb6e39b39", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c7dbe7a830100c70d59994fd940bf75bb6e39b39/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9ef27bf7dc50a8b51435579b4f2e86f7ee3f7a94", "url": "https://api.github.com/repos/rust-lang/rust/commits/9ef27bf7dc50a8b51435579b4f2e86f7ee3f7a94", "html_url": "https://github.com/rust-lang/rust/commit/9ef27bf7dc50a8b51435579b4f2e86f7ee3f7a94"}, {"sha": "146aee66b1cc33ce0db4bc7ffe01d88145d6fb1f", "url": "https://api.github.com/repos/rust-lang/rust/commits/146aee66b1cc33ce0db4bc7ffe01d88145d6fb1f", "html_url": "https://github.com/rust-lang/rust/commit/146aee66b1cc33ce0db4bc7ffe01d88145d6fb1f"}], "stats": {"total": 1264, "additions": 688, "deletions": 576}, "files": [{"sha": "a9db3497b23908a50548e9a24ab74f189feed37d", "filename": "compiler/rustc_data_structures/src/graph/iterate/mod.rs", "status": "modified", "additions": 52, "deletions": 2, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/c7dbe7a830100c70d59994fd940bf75bb6e39b39/compiler%2Frustc_data_structures%2Fsrc%2Fgraph%2Fiterate%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7dbe7a830100c70d59994fd940bf75bb6e39b39/compiler%2Frustc_data_structures%2Fsrc%2Fgraph%2Fiterate%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_data_structures%2Fsrc%2Fgraph%2Fiterate%2Fmod.rs?ref=c7dbe7a830100c70d59994fd940bf75bb6e39b39", "patch": "@@ -83,8 +83,58 @@ impl<G> DepthFirstSearch<'graph, G>\n where\n     G: ?Sized + DirectedGraph + WithNumNodes + WithSuccessors,\n {\n-    pub fn new(graph: &'graph G, start_node: G::Node) -> Self {\n-        Self { graph, stack: vec![start_node], visited: BitSet::new_empty(graph.num_nodes()) }\n+    pub fn new(graph: &'graph G) -> Self {\n+        Self { graph, stack: vec![], visited: BitSet::new_empty(graph.num_nodes()) }\n+    }\n+\n+    /// Version of `push_start_node` that is convenient for chained\n+    /// use.\n+    pub fn with_start_node(mut self, start_node: G::Node) -> Self {\n+        self.push_start_node(start_node);\n+        self\n+    }\n+\n+    /// Pushes another start node onto the stack. If the node\n+    /// has not already been visited, then you will be able to\n+    /// walk its successors (and so forth) after the current\n+    /// contents of the stack are drained. If multiple start nodes\n+    /// are added into the walk, then their mutual successors\n+    /// will all be walked. You can use this method once the\n+    /// iterator has been completely drained to add additional\n+    /// start nodes.\n+    pub fn push_start_node(&mut self, start_node: G::Node) {\n+        if self.visited.insert(start_node) {\n+            self.stack.push(start_node);\n+        }\n+    }\n+\n+    /// Searches all nodes reachable from the current start nodes.\n+    /// This is equivalent to just invoke `next` repeatedly until\n+    /// you get a `None` result.\n+    pub fn complete_search(&mut self) {\n+        while let Some(_) = self.next() {}\n+    }\n+\n+    /// Returns true if node has been visited thus far.\n+    /// A node is considered \"visited\" once it is pushed\n+    /// onto the internal stack; it may not yet have been yielded\n+    /// from the iterator. This method is best used after\n+    /// the iterator is completely drained.\n+    pub fn visited(&self, node: G::Node) -> bool {\n+        self.visited.contains(node)\n+    }\n+}\n+\n+impl<G> std::fmt::Debug for DepthFirstSearch<'_, G>\n+where\n+    G: ?Sized + DirectedGraph + WithNumNodes + WithSuccessors,\n+{\n+    fn fmt(&self, fmt: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n+        let mut f = fmt.debug_set();\n+        for n in self.visited.iter() {\n+            f.entry(&n);\n+        }\n+        f.finish()\n     }\n }\n "}, {"sha": "c498c289337f1a1eebe77955943ab88812ae2b9c", "filename": "compiler/rustc_data_structures/src/graph/iterate/tests.rs", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/c7dbe7a830100c70d59994fd940bf75bb6e39b39/compiler%2Frustc_data_structures%2Fsrc%2Fgraph%2Fiterate%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7dbe7a830100c70d59994fd940bf75bb6e39b39/compiler%2Frustc_data_structures%2Fsrc%2Fgraph%2Fiterate%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_data_structures%2Fsrc%2Fgraph%2Fiterate%2Ftests.rs?ref=c7dbe7a830100c70d59994fd940bf75bb6e39b39", "patch": "@@ -20,3 +20,19 @@ fn is_cyclic() {\n     assert!(!is_cyclic(&diamond_acyclic));\n     assert!(is_cyclic(&diamond_cyclic));\n }\n+\n+#[test]\n+fn dfs() {\n+    let graph = TestGraph::new(0, &[(0, 1), (0, 2), (1, 3), (2, 3), (3, 0)]);\n+\n+    let result: Vec<usize> = DepthFirstSearch::new(&graph).with_start_node(0).collect();\n+    assert_eq!(result, vec![0, 2, 3, 1]);\n+}\n+\n+#[test]\n+fn dfs_debug() {\n+    let graph = TestGraph::new(0, &[(0, 1), (0, 2), (1, 3), (2, 3), (3, 0)]);\n+    let mut dfs = DepthFirstSearch::new(&graph).with_start_node(0);\n+    dfs.complete_search();\n+    assert_eq!(format!(\"{{0, 1, 2, 3}}\"), format!(\"{:?}\", dfs));\n+}"}, {"sha": "3560df6e5e204548dc2966179e26052d90298bfb", "filename": "compiler/rustc_data_structures/src/graph/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c7dbe7a830100c70d59994fd940bf75bb6e39b39/compiler%2Frustc_data_structures%2Fsrc%2Fgraph%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7dbe7a830100c70d59994fd940bf75bb6e39b39/compiler%2Frustc_data_structures%2Fsrc%2Fgraph%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_data_structures%2Fsrc%2Fgraph%2Fmod.rs?ref=c7dbe7a830100c70d59994fd940bf75bb6e39b39", "patch": "@@ -32,7 +32,7 @@ where\n     where\n         Self: WithNumNodes,\n     {\n-        iterate::DepthFirstSearch::new(self, from)\n+        iterate::DepthFirstSearch::new(self).with_start_node(from)\n     }\n }\n "}, {"sha": "dd6a17b92aef303b85fc4eae0e0b6391e86b5d63", "filename": "compiler/rustc_data_structures/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/c7dbe7a830100c70d59994fd940bf75bb6e39b39/compiler%2Frustc_data_structures%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7dbe7a830100c70d59994fd940bf75bb6e39b39/compiler%2Frustc_data_structures%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_data_structures%2Fsrc%2Flib.rs?ref=c7dbe7a830100c70d59994fd940bf75bb6e39b39", "patch": "@@ -21,6 +21,7 @@\n #![feature(iter_map_while)]\n #![feature(maybe_uninit_uninit_array)]\n #![feature(min_specialization)]\n+#![feature(never_type)]\n #![feature(type_alias_impl_trait)]\n #![feature(new_uninit)]\n #![feature(nll)]"}, {"sha": "354f9dd93cc4d4e491f6a15feffcdbf491a837dd", "filename": "compiler/rustc_data_structures/src/stable_hasher.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c7dbe7a830100c70d59994fd940bf75bb6e39b39/compiler%2Frustc_data_structures%2Fsrc%2Fstable_hasher.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7dbe7a830100c70d59994fd940bf75bb6e39b39/compiler%2Frustc_data_structures%2Fsrc%2Fstable_hasher.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_data_structures%2Fsrc%2Fstable_hasher.rs?ref=c7dbe7a830100c70d59994fd940bf75bb6e39b39", "patch": "@@ -209,6 +209,12 @@ impl_stable_hash_via_hash!(i128);\n impl_stable_hash_via_hash!(char);\n impl_stable_hash_via_hash!(());\n \n+impl<CTX> HashStable<CTX> for ! {\n+    fn hash_stable(&self, _ctx: &mut CTX, _hasher: &mut StableHasher) {\n+        unreachable!()\n+    }\n+}\n+\n impl<CTX> HashStable<CTX> for ::std::num::NonZeroU32 {\n     fn hash_stable(&self, ctx: &mut CTX, hasher: &mut StableHasher) {\n         self.get().hash_stable(ctx, hasher)"}, {"sha": "cb668eb35e093da9b2194eef756f4208e436c677", "filename": "compiler/rustc_hir/src/def.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/c7dbe7a830100c70d59994fd940bf75bb6e39b39/compiler%2Frustc_hir%2Fsrc%2Fdef.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7dbe7a830100c70d59994fd940bf75bb6e39b39/compiler%2Frustc_hir%2Fsrc%2Fdef.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir%2Fsrc%2Fdef.rs?ref=c7dbe7a830100c70d59994fd940bf75bb6e39b39", "patch": "@@ -598,6 +598,11 @@ impl<Id> Res<Id> {\n         }\n     }\n \n+    #[track_caller]\n+    pub fn expect_non_local<OtherId>(self) -> Res<OtherId> {\n+        self.map_id(|_| panic!(\"unexpected `Res::Local`\"))\n+    }\n+\n     pub fn macro_kind(self) -> Option<MacroKind> {\n         match self {\n             Res::Def(DefKind::Macro(kind), _) => Some(kind),"}, {"sha": "43aa8a6efcec4df5db4a056cbf43078244d0eafb", "filename": "compiler/rustc_infer/src/infer/error_reporting/nice_region_error/trait_impl_difference.rs", "status": "modified", "additions": 58, "deletions": 30, "changes": 88, "blob_url": "https://github.com/rust-lang/rust/blob/c7dbe7a830100c70d59994fd940bf75bb6e39b39/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Ftrait_impl_difference.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7dbe7a830100c70d59994fd940bf75bb6e39b39/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Ftrait_impl_difference.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Ftrait_impl_difference.rs?ref=c7dbe7a830100c70d59994fd940bf75bb6e39b39", "patch": "@@ -2,7 +2,7 @@\n \n use crate::infer::error_reporting::nice_region_error::NiceRegionError;\n use crate::infer::lexical_region_resolve::RegionResolutionError;\n-use crate::infer::{Subtype, ValuePairs};\n+use crate::infer::{SubregionOrigin, Subtype, ValuePairs};\n use crate::traits::ObligationCauseCode::CompareImplMethodObligation;\n use rustc_errors::ErrorReported;\n use rustc_hir as hir;\n@@ -11,44 +11,53 @@ use rustc_hir::def_id::DefId;\n use rustc_hir::intravisit::Visitor;\n use rustc_middle::ty::error::ExpectedFound;\n use rustc_middle::ty::{self, Ty, TyCtxt};\n-use rustc_span::{MultiSpan, Span};\n+use rustc_span::{MultiSpan, Span, Symbol};\n \n impl<'a, 'tcx> NiceRegionError<'a, 'tcx> {\n     /// Print the error message for lifetime errors when the `impl` doesn't conform to the `trait`.\n     pub(super) fn try_report_impl_not_conforming_to_trait(&self) -> Option<ErrorReported> {\n-        if let Some(ref error) = self.error {\n-            debug!(\"try_report_impl_not_conforming_to_trait {:?}\", error);\n-            if let RegionResolutionError::SubSupConflict(\n-                _,\n-                var_origin,\n-                sub_origin,\n-                _sub,\n-                sup_origin,\n-                _sup,\n-            ) = error.clone()\n-            {\n-                if let (&Subtype(ref sup_trace), &Subtype(ref sub_trace)) =\n-                    (&sup_origin, &sub_origin)\n+        let error = self.error.as_ref()?;\n+        debug!(\"try_report_impl_not_conforming_to_trait {:?}\", error);\n+        if let RegionResolutionError::SubSupConflict(\n+            _,\n+            var_origin,\n+            sub_origin,\n+            _sub,\n+            sup_origin,\n+            _sup,\n+        ) = error.clone()\n+        {\n+            if let (&Subtype(ref sup_trace), &Subtype(ref sub_trace)) = (&sup_origin, &sub_origin) {\n+                if let (\n+                    ValuePairs::Types(sub_expected_found),\n+                    ValuePairs::Types(sup_expected_found),\n+                    CompareImplMethodObligation { trait_item_def_id, .. },\n+                ) = (&sub_trace.values, &sup_trace.values, &sub_trace.cause.code)\n                 {\n-                    if let (\n-                        ValuePairs::Types(sub_expected_found),\n-                        ValuePairs::Types(sup_expected_found),\n-                        CompareImplMethodObligation { trait_item_def_id, .. },\n-                    ) = (&sub_trace.values, &sup_trace.values, &sub_trace.cause.code)\n-                    {\n-                        if sup_expected_found == sub_expected_found {\n-                            self.emit_err(\n-                                var_origin.span(),\n-                                sub_expected_found.expected,\n-                                sub_expected_found.found,\n-                                *trait_item_def_id,\n-                            );\n-                            return Some(ErrorReported);\n-                        }\n+                    if sup_expected_found == sub_expected_found {\n+                        self.emit_err(\n+                            var_origin.span(),\n+                            sub_expected_found.expected,\n+                            sub_expected_found.found,\n+                            *trait_item_def_id,\n+                        );\n+                        return Some(ErrorReported);\n                     }\n                 }\n             }\n         }\n+        if let RegionResolutionError::ConcreteFailure(origin, _, _) = error.clone() {\n+            if let SubregionOrigin::CompareImplTypeObligation {\n+                span,\n+                item_name,\n+                impl_item_def_id,\n+                trait_item_def_id,\n+            } = origin\n+            {\n+                self.emit_associated_type_err(span, item_name, impl_item_def_id, trait_item_def_id);\n+                return Some(ErrorReported);\n+            }\n+        }\n         None\n     }\n \n@@ -107,6 +116,25 @@ impl<'a, 'tcx> NiceRegionError<'a, 'tcx> {\n         }\n         err.emit();\n     }\n+\n+    fn emit_associated_type_err(\n+        &self,\n+        span: Span,\n+        item_name: Symbol,\n+        impl_item_def_id: DefId,\n+        trait_item_def_id: DefId,\n+    ) {\n+        let impl_sp = self.tcx().def_span(impl_item_def_id);\n+        let trait_sp = self.tcx().def_span(trait_item_def_id);\n+        let mut err = self\n+            .tcx()\n+            .sess\n+            .struct_span_err(span, &format!(\"`impl` associated type signature for `{}` doesn't match `trait` associated type signature\", item_name));\n+        err.span_label(impl_sp, &format!(\"found\"));\n+        err.span_label(trait_sp, &format!(\"expected\"));\n+\n+        err.emit();\n+    }\n }\n \n struct TypeParamSpanVisitor<'tcx> {"}, {"sha": "5f99a23f86e88b1d2df0045f1f0264e585b27fe2", "filename": "compiler/rustc_infer/src/infer/error_reporting/note.rs", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/c7dbe7a830100c70d59994fd940bf75bb6e39b39/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnote.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7dbe7a830100c70d59994fd940bf75bb6e39b39/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnote.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnote.rs?ref=c7dbe7a830100c70d59994fd940bf75bb6e39b39", "patch": "@@ -99,6 +99,12 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                     \"...so that the definition in impl matches the definition from the trait\",\n                 );\n             }\n+            infer::CompareImplTypeObligation { span, .. } => {\n+                label_or_note(\n+                    span,\n+                    \"...so that the definition in impl matches the definition from the trait\",\n+                );\n+            }\n         }\n     }\n \n@@ -356,6 +362,18 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                 trait_item_def_id,\n                 &format!(\"`{}: {}`\", sup, sub),\n             ),\n+            infer::CompareImplTypeObligation {\n+                span,\n+                item_name,\n+                impl_item_def_id,\n+                trait_item_def_id,\n+            } => self.report_extra_impl_obligation(\n+                span,\n+                item_name,\n+                impl_item_def_id,\n+                trait_item_def_id,\n+                &format!(\"`{}: {}`\", sup, sub),\n+            ),\n         }\n     }\n "}, {"sha": "354b8e26d53d5dcaa466a9adc0208f598bfa3a85", "filename": "compiler/rustc_infer/src/infer/mod.rs", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/c7dbe7a830100c70d59994fd940bf75bb6e39b39/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7dbe7a830100c70d59994fd940bf75bb6e39b39/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fmod.rs?ref=c7dbe7a830100c70d59994fd940bf75bb6e39b39", "patch": "@@ -427,6 +427,15 @@ pub enum SubregionOrigin<'tcx> {\n         impl_item_def_id: DefId,\n         trait_item_def_id: DefId,\n     },\n+\n+    /// Comparing the signature and requirements of an impl associated type\n+    /// against the containing trait\n+    CompareImplTypeObligation {\n+        span: Span,\n+        item_name: Symbol,\n+        impl_item_def_id: DefId,\n+        trait_item_def_id: DefId,\n+    },\n }\n \n // `SubregionOrigin` is used a lot. Make sure it doesn't unintentionally get bigger.\n@@ -1810,6 +1819,7 @@ impl<'tcx> SubregionOrigin<'tcx> {\n             ReferenceOutlivesReferent(_, a) => a,\n             CallReturn(a) => a,\n             CompareImplMethodObligation { span, .. } => span,\n+            CompareImplTypeObligation { span, .. } => span,\n         }\n     }\n \n@@ -1833,6 +1843,17 @@ impl<'tcx> SubregionOrigin<'tcx> {\n                 trait_item_def_id,\n             },\n \n+            traits::ObligationCauseCode::CompareImplTypeObligation {\n+                item_name,\n+                impl_item_def_id,\n+                trait_item_def_id,\n+            } => SubregionOrigin::CompareImplTypeObligation {\n+                span: cause.span,\n+                item_name,\n+                impl_item_def_id,\n+                trait_item_def_id,\n+            },\n+\n             _ => default(),\n         }\n     }"}, {"sha": "2a0332a11242ee757e4cd3ebb45ff3ab034b98fc", "filename": "compiler/rustc_metadata/src/rmeta/decoder.rs", "status": "modified", "additions": 6, "deletions": 8, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/c7dbe7a830100c70d59994fd940bf75bb6e39b39/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7dbe7a830100c70d59994fd940bf75bb6e39b39/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder.rs?ref=c7dbe7a830100c70d59994fd940bf75bb6e39b39", "patch": "@@ -26,6 +26,7 @@ use rustc_middle::middle::cstore::{ForeignModule, LinkagePreference, NativeLib};\n use rustc_middle::middle::exported_symbols::{ExportedSymbol, SymbolExportLevel};\n use rustc_middle::mir::interpret::{AllocDecodingSession, AllocDecodingState};\n use rustc_middle::mir::{self, Body, Promoted};\n+use rustc_middle::thir;\n use rustc_middle::ty::codec::TyDecoder;\n use rustc_middle::ty::{self, Ty, TyCtxt, Visibility};\n use rustc_serialize::{opaque, Decodable, Decoder};\n@@ -541,7 +542,7 @@ impl<'a, 'tcx> Decodable<DecodeContext<'a, 'tcx>> for Span {\n     }\n }\n \n-impl<'a, 'tcx> Decodable<DecodeContext<'a, 'tcx>> for &'tcx [mir::abstract_const::Node<'tcx>] {\n+impl<'a, 'tcx> Decodable<DecodeContext<'a, 'tcx>> for &'tcx [thir::abstract_const::Node<'tcx>] {\n     fn decode(d: &mut DecodeContext<'a, 'tcx>) -> Result<Self, String> {\n         ty::codec::RefDecodable::decode(d)\n     }\n@@ -1020,10 +1021,7 @@ impl<'a, 'tcx> CrateMetadataRef<'a> {\n     }\n \n     /// Iterates over each child of the given item.\n-    fn each_child_of_item<F>(&self, id: DefIndex, mut callback: F, sess: &Session)\n-    where\n-        F: FnMut(Export<hir::HirId>),\n-    {\n+    fn each_child_of_item(&self, id: DefIndex, mut callback: impl FnMut(Export), sess: &Session) {\n         if let Some(data) = &self.root.proc_macro_data {\n             /* If we are loading as a proc macro, we want to return the view of this crate\n              * as a proc macro crate.\n@@ -1199,14 +1197,14 @@ impl<'a, 'tcx> CrateMetadataRef<'a> {\n             .decode((self, tcx))\n     }\n \n-    fn get_mir_abstract_const(\n+    fn get_thir_abstract_const(\n         &self,\n         tcx: TyCtxt<'tcx>,\n         id: DefIndex,\n-    ) -> Result<Option<&'tcx [mir::abstract_const::Node<'tcx>]>, ErrorReported> {\n+    ) -> Result<Option<&'tcx [thir::abstract_const::Node<'tcx>]>, ErrorReported> {\n         self.root\n             .tables\n-            .mir_abstract_consts\n+            .thir_abstract_consts\n             .get(self, id)\n             .map_or(Ok(None), |v| Ok(Some(v.decode((self, tcx)))))\n     }"}, {"sha": "50074803bbeef140c1dfda3f6bb1c70145362740", "filename": "compiler/rustc_metadata/src/rmeta/decoder/cstore_impl.rs", "status": "modified", "additions": 18, "deletions": 24, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/c7dbe7a830100c70d59994fd940bf75bb6e39b39/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder%2Fcstore_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7dbe7a830100c70d59994fd940bf75bb6e39b39/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder%2Fcstore_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder%2Fcstore_impl.rs?ref=c7dbe7a830100c70d59994fd940bf75bb6e39b39", "patch": "@@ -5,7 +5,6 @@ use crate::rmeta::encoder;\n \n use rustc_ast as ast;\n use rustc_data_structures::stable_map::FxHashMap;\n-use rustc_hir as hir;\n use rustc_hir::def::{CtorKind, DefKind};\n use rustc_hir::def_id::{CrateNum, DefId, DefIdMap, CRATE_DEF_INDEX, LOCAL_CRATE};\n use rustc_hir::definitions::{DefKey, DefPath, DefPathHash};\n@@ -117,7 +116,7 @@ provide! { <'tcx> tcx, def_id, other, cdata,\n     optimized_mir => { tcx.arena.alloc(cdata.get_optimized_mir(tcx, def_id.index)) }\n     mir_for_ctfe => { tcx.arena.alloc(cdata.get_mir_for_ctfe(tcx, def_id.index)) }\n     promoted_mir => { tcx.arena.alloc(cdata.get_promoted_mir(tcx, def_id.index)) }\n-    mir_abstract_const => { cdata.get_mir_abstract_const(tcx, def_id.index) }\n+    thir_abstract_const => { cdata.get_thir_abstract_const(tcx, def_id.index) }\n     unused_generic_params => { cdata.get_unused_generic_params(def_id.index) }\n     const_param_default => { tcx.mk_const(cdata.get_const_param_default(tcx, def_id.index)) }\n     mir_const_qualif => { cdata.mir_const_qualif(def_id.index) }\n@@ -326,28 +325,27 @@ pub fn provide(providers: &mut Providers) {\n             // (restrict scope of mutable-borrow of `visible_parent_map`)\n             {\n                 let visible_parent_map = &mut visible_parent_map;\n-                let mut add_child =\n-                    |bfs_queue: &mut VecDeque<_>, child: &Export<hir::HirId>, parent: DefId| {\n-                        if child.vis != ty::Visibility::Public {\n-                            return;\n-                        }\n+                let mut add_child = |bfs_queue: &mut VecDeque<_>, child: &Export, parent: DefId| {\n+                    if child.vis != ty::Visibility::Public {\n+                        return;\n+                    }\n \n-                        if let Some(child) = child.res.opt_def_id() {\n-                            match visible_parent_map.entry(child) {\n-                                Entry::Occupied(mut entry) => {\n-                                    // If `child` is defined in crate `cnum`, ensure\n-                                    // that it is mapped to a parent in `cnum`.\n-                                    if child.is_local() && entry.get().is_local() {\n-                                        entry.insert(parent);\n-                                    }\n-                                }\n-                                Entry::Vacant(entry) => {\n+                    if let Some(child) = child.res.opt_def_id() {\n+                        match visible_parent_map.entry(child) {\n+                            Entry::Occupied(mut entry) => {\n+                                // If `child` is defined in crate `cnum`, ensure\n+                                // that it is mapped to a parent in `cnum`.\n+                                if child.is_local() && entry.get().is_local() {\n                                     entry.insert(parent);\n-                                    bfs_queue.push_back(child);\n                                 }\n                             }\n+                            Entry::Vacant(entry) => {\n+                                entry.insert(parent);\n+                                bfs_queue.push_back(child);\n+                            }\n                         }\n-                    };\n+                    }\n+                };\n \n                 while let Some(def) = bfs_queue.pop_front() {\n                     for child in tcx.item_children(def).iter() {\n@@ -393,11 +391,7 @@ impl CStore {\n         self.get_crate_data(def.krate).get_visibility(def.index)\n     }\n \n-    pub fn item_children_untracked(\n-        &self,\n-        def_id: DefId,\n-        sess: &Session,\n-    ) -> Vec<Export<hir::HirId>> {\n+    pub fn item_children_untracked(&self, def_id: DefId, sess: &Session) -> Vec<Export> {\n         let mut result = vec![];\n         self.get_crate_data(def_id.krate).each_child_of_item(\n             def_id.index,"}, {"sha": "1b24e5eae98fba84fb0961609096aeb36a249d42", "filename": "compiler/rustc_metadata/src/rmeta/encoder.rs", "status": "modified", "additions": 6, "deletions": 11, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/c7dbe7a830100c70d59994fd940bf75bb6e39b39/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7dbe7a830100c70d59994fd940bf75bb6e39b39/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fencoder.rs?ref=c7dbe7a830100c70d59994fd940bf75bb6e39b39", "patch": "@@ -23,6 +23,7 @@ use rustc_middle::middle::exported_symbols::{\n     metadata_symbol_name, ExportedSymbol, SymbolExportLevel,\n };\n use rustc_middle::mir::interpret;\n+use rustc_middle::thir;\n use rustc_middle::traits::specialization_graph;\n use rustc_middle::ty::codec::TyEncoder;\n use rustc_middle::ty::{self, SymbolName, Ty, TyCtxt};\n@@ -344,7 +345,7 @@ impl<'a, 'tcx> TyEncoder<'tcx> for EncodeContext<'a, 'tcx> {\n     }\n }\n \n-impl<'a, 'tcx> Encodable<EncodeContext<'a, 'tcx>> for &'tcx [mir::abstract_const::Node<'tcx>] {\n+impl<'a, 'tcx> Encodable<EncodeContext<'a, 'tcx>> for &'tcx [thir::abstract_const::Node<'tcx>] {\n     fn encode(&self, s: &mut EncodeContext<'a, 'tcx>) -> opaque::EncodeResult {\n         (**self).encode(s)\n     }\n@@ -1065,14 +1066,7 @@ impl EncodeContext<'a, 'tcx> {\n         // items - we encode information about proc-macros later on.\n         let reexports = if !self.is_proc_macro {\n             match tcx.module_exports(local_def_id) {\n-                Some(exports) => {\n-                    let hir = self.tcx.hir();\n-                    self.lazy(\n-                        exports\n-                            .iter()\n-                            .map(|export| export.map_id(|id| hir.local_def_id_to_hir_id(id))),\n-                    )\n-                }\n+                Some(exports) => self.lazy(exports),\n                 _ => Lazy::empty(),\n             }\n         } else {\n@@ -1304,9 +1298,10 @@ impl EncodeContext<'a, 'tcx> {\n             if encode_const {\n                 record!(self.tables.mir_for_ctfe[def_id.to_def_id()] <- self.tcx.mir_for_ctfe(def_id));\n \n-                let abstract_const = self.tcx.mir_abstract_const(def_id);\n+                // FIXME(generic_const_exprs): this feels wrong to have in `encode_mir`\n+                let abstract_const = self.tcx.thir_abstract_const(def_id);\n                 if let Ok(Some(abstract_const)) = abstract_const {\n-                    record!(self.tables.mir_abstract_consts[def_id.to_def_id()] <- abstract_const);\n+                    record!(self.tables.thir_abstract_consts[def_id.to_def_id()] <- abstract_const);\n                 }\n             }\n             record!(self.tables.promoted_mir[def_id.to_def_id()] <- self.tcx.promoted_mir(def_id));"}, {"sha": "575ab04ab24c256d1adc8d6580a56a92573d5034", "filename": "compiler/rustc_metadata/src/rmeta/mod.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/c7dbe7a830100c70d59994fd940bf75bb6e39b39/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7dbe7a830100c70d59994fd940bf75bb6e39b39/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fmod.rs?ref=c7dbe7a830100c70d59994fd940bf75bb6e39b39", "patch": "@@ -15,6 +15,7 @@ use rustc_middle::hir::exports::Export;\n use rustc_middle::middle::cstore::{CrateDepKind, ForeignModule, LinkagePreference, NativeLib};\n use rustc_middle::middle::exported_symbols::{ExportedSymbol, SymbolExportLevel};\n use rustc_middle::mir;\n+use rustc_middle::thir;\n use rustc_middle::ty::{self, ReprOptions, Ty};\n use rustc_serialize::opaque::Encoder;\n use rustc_session::config::SymbolManglingVersion;\n@@ -305,7 +306,7 @@ define_tables! {\n     mir: Table<DefIndex, Lazy!(mir::Body<'tcx>)>,\n     mir_for_ctfe: Table<DefIndex, Lazy!(mir::Body<'tcx>)>,\n     promoted_mir: Table<DefIndex, Lazy!(IndexVec<mir::Promoted, mir::Body<'tcx>>)>,\n-    mir_abstract_consts: Table<DefIndex, Lazy!(&'tcx [mir::abstract_const::Node<'tcx>])>,\n+    thir_abstract_consts: Table<DefIndex, Lazy!(&'tcx [thir::abstract_const::Node<'tcx>])>,\n     const_defaults: Table<DefIndex, Lazy<rustc_middle::ty::Const<'tcx>>>,\n     unused_generic_params: Table<DefIndex, Lazy<FiniteBitSet<u32>>>,\n     // `def_keys` and `def_path_hashes` represent a lazy version of a\n@@ -359,7 +360,7 @@ struct RenderedConst(String);\n \n #[derive(MetadataEncodable, MetadataDecodable)]\n struct ModData {\n-    reexports: Lazy<[Export<hir::HirId>]>,\n+    reexports: Lazy<[Export]>,\n     expansion: ExpnId,\n }\n "}, {"sha": "f37b976fba68d3d6d450cee0c1cb4b9b353bb2ac", "filename": "compiler/rustc_middle/src/hir/exports.rs", "status": "modified", "additions": 4, "deletions": 9, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/c7dbe7a830100c70d59994fd940bf75bb6e39b39/compiler%2Frustc_middle%2Fsrc%2Fhir%2Fexports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7dbe7a830100c70d59994fd940bf75bb6e39b39/compiler%2Frustc_middle%2Fsrc%2Fhir%2Fexports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fhir%2Fexports.rs?ref=c7dbe7a830100c70d59994fd940bf75bb6e39b39", "patch": "@@ -11,23 +11,18 @@ use std::fmt::Debug;\n \n /// This is the replacement export map. It maps a module to all of the exports\n /// within.\n-pub type ExportMap<Id> = FxHashMap<LocalDefId, Vec<Export<Id>>>;\n+pub type ExportMap = FxHashMap<LocalDefId, Vec<Export>>;\n \n #[derive(Copy, Clone, Debug, TyEncodable, TyDecodable, HashStable)]\n-pub struct Export<Id> {\n+pub struct Export {\n     /// The name of the target.\n     pub ident: Ident,\n     /// The resolution of the target.\n-    pub res: Res<Id>,\n+    /// Local variables cannot be exported, so this `Res` doesn't need the ID parameter.\n+    pub res: Res<!>,\n     /// The span of the target.\n     pub span: Span,\n     /// The visibility of the export.\n     /// We include non-`pub` exports for hygienic macros that get used from extern crates.\n     pub vis: ty::Visibility,\n }\n-\n-impl<Id> Export<Id> {\n-    pub fn map_id<R>(self, map: impl FnMut(Id) -> R) -> Export<R> {\n-        Export { ident: self.ident, res: self.res.map_id(map), span: self.span, vis: self.vis }\n-    }\n-}"}, {"sha": "1ef10241143b83ed0ca19f0c51abff8f84ff0419", "filename": "compiler/rustc_middle/src/mir/abstract_const.rs", "status": "removed", "additions": 0, "deletions": 38, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/9ef27bf7dc50a8b51435579b4f2e86f7ee3f7a94/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fabstract_const.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9ef27bf7dc50a8b51435579b4f2e86f7ee3f7a94/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fabstract_const.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fabstract_const.rs?ref=9ef27bf7dc50a8b51435579b4f2e86f7ee3f7a94", "patch": "@@ -1,38 +0,0 @@\n-//! A subset of a mir body used for const evaluatability checking.\n-use crate::mir::{self, CastKind};\n-use crate::ty::{self, Ty};\n-\n-rustc_index::newtype_index! {\n-    /// An index into an `AbstractConst`.\n-    pub struct NodeId {\n-        derive [HashStable]\n-        DEBUG_FORMAT = \"n{}\",\n-    }\n-}\n-\n-/// A node of an `AbstractConst`.\n-#[derive(Debug, Clone, Copy, PartialEq, Eq, HashStable, TyEncodable, TyDecodable)]\n-pub enum Node<'tcx> {\n-    Leaf(&'tcx ty::Const<'tcx>),\n-    Binop(mir::BinOp, NodeId, NodeId),\n-    UnaryOp(mir::UnOp, NodeId),\n-    FunctionCall(NodeId, &'tcx [NodeId]),\n-    Cast(CastKind, NodeId, Ty<'tcx>),\n-}\n-\n-#[derive(Debug, Copy, Clone, PartialEq, Eq, HashStable, TyEncodable, TyDecodable)]\n-pub enum NotConstEvaluatable {\n-    Error(rustc_errors::ErrorReported),\n-    MentionsInfer,\n-    MentionsParam,\n-}\n-\n-impl From<rustc_errors::ErrorReported> for NotConstEvaluatable {\n-    fn from(e: rustc_errors::ErrorReported) -> NotConstEvaluatable {\n-        NotConstEvaluatable::Error(e)\n-    }\n-}\n-\n-TrivialTypeFoldableAndLiftImpls! {\n-    NotConstEvaluatable,\n-}"}, {"sha": "ebdf354b90538c83091ce9e2d4f3edb5bd0b0ffa", "filename": "compiler/rustc_middle/src/mir/mod.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/c7dbe7a830100c70d59994fd940bf75bb6e39b39/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7dbe7a830100c70d59994fd940bf75bb6e39b39/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fmod.rs?ref=c7dbe7a830100c70d59994fd940bf75bb6e39b39", "patch": "@@ -40,7 +40,6 @@ use self::graph_cyclic_cache::GraphIsCyclicCache;\n use self::predecessors::{PredecessorCache, Predecessors};\n pub use self::query::*;\n \n-pub mod abstract_const;\n pub mod coverage;\n mod generic_graph;\n pub mod generic_graphviz;"}, {"sha": "567f65e83d98c5fa3e9e934e028cb2c162d47b35", "filename": "compiler/rustc_middle/src/mir/query.rs", "status": "modified", "additions": 1, "deletions": 13, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/c7dbe7a830100c70d59994fd940bf75bb6e39b39/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fquery.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7dbe7a830100c70d59994fd940bf75bb6e39b39/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fquery.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fquery.rs?ref=c7dbe7a830100c70d59994fd940bf75bb6e39b39", "patch": "@@ -1,6 +1,6 @@\n //! Values computed by queries that use MIR.\n \n-use crate::mir::{abstract_const, Body, Promoted};\n+use crate::mir::{Body, Promoted};\n use crate::ty::{self, Ty, TyCtxt};\n use rustc_data_structures::sync::Lrc;\n use rustc_data_structures::vec_map::VecMap;\n@@ -431,16 +431,4 @@ impl<'tcx> TyCtxt<'tcx> {\n             self.mir_for_ctfe(def.did)\n         }\n     }\n-\n-    #[inline]\n-    pub fn mir_abstract_const_opt_const_arg(\n-        self,\n-        def: ty::WithOptConstParam<DefId>,\n-    ) -> Result<Option<&'tcx [abstract_const::Node<'tcx>]>, ErrorReported> {\n-        if let Some((did, param_did)) = def.as_const_arg() {\n-            self.mir_abstract_const_of_const_arg((did, param_did))\n-        } else {\n-            self.mir_abstract_const(def.did)\n-        }\n-    }\n }"}, {"sha": "5748e5319e0a6c8a4cd365fc3f6eaf4cdc0a8e52", "filename": "compiler/rustc_middle/src/query/mod.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/c7dbe7a830100c70d59994fd940bf75bb6e39b39/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7dbe7a830100c70d59994fd940bf75bb6e39b39/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs?ref=c7dbe7a830100c70d59994fd940bf75bb6e39b39", "patch": "@@ -303,17 +303,17 @@ rustc_queries! {\n     }\n \n     /// Try to build an abstract representation of the given constant.\n-    query mir_abstract_const(\n+    query thir_abstract_const(\n         key: DefId\n-    ) -> Result<Option<&'tcx [mir::abstract_const::Node<'tcx>]>, ErrorReported> {\n+    ) -> Result<Option<&'tcx [thir::abstract_const::Node<'tcx>]>, ErrorReported> {\n         desc {\n             |tcx| \"building an abstract representation for {}\", tcx.def_path_str(key),\n         }\n     }\n     /// Try to build an abstract representation of the given constant.\n-    query mir_abstract_const_of_const_arg(\n+    query thir_abstract_const_of_const_arg(\n         key: (LocalDefId, DefId)\n-    ) -> Result<Option<&'tcx [mir::abstract_const::Node<'tcx>]>, ErrorReported> {\n+    ) -> Result<Option<&'tcx [thir::abstract_const::Node<'tcx>]>, ErrorReported> {\n         desc {\n             |tcx|\n             \"building an abstract representation for the const argument {}\",\n@@ -1189,7 +1189,7 @@ rustc_queries! {\n         desc { \"traits in scope at a block\" }\n     }\n \n-    query module_exports(def_id: LocalDefId) -> Option<&'tcx [Export<LocalDefId>]> {\n+    query module_exports(def_id: LocalDefId) -> Option<&'tcx [Export]> {\n         desc { |tcx| \"looking up items exported by `{}`\", tcx.def_path_str(def_id.to_def_id()) }\n     }\n \n@@ -1401,7 +1401,7 @@ rustc_queries! {\n         eval_always\n         desc { \"fetching what a crate is named\" }\n     }\n-    query item_children(def_id: DefId) -> &'tcx [Export<hir::HirId>] {\n+    query item_children(def_id: DefId) -> &'tcx [Export] {\n         desc { |tcx| \"collecting child items of `{}`\", tcx.def_path_str(def_id) }\n     }\n     query extern_mod_stmt_cnum(def_id: LocalDefId) -> Option<CrateNum> {"}, {"sha": "8d6fd1e729d3b52b5e4ec75dc6bd775317101924", "filename": "compiler/rustc_middle/src/thir.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/c7dbe7a830100c70d59994fd940bf75bb6e39b39/compiler%2Frustc_middle%2Fsrc%2Fthir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7dbe7a830100c70d59994fd940bf75bb6e39b39/compiler%2Frustc_middle%2Fsrc%2Fthir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fthir.rs?ref=c7dbe7a830100c70d59994fd940bf75bb6e39b39", "patch": "@@ -33,6 +33,9 @@ use rustc_target::asm::InlineAsmRegOrRegClass;\n use std::fmt;\n use std::ops::Index;\n \n+pub mod abstract_const;\n+pub mod visit;\n+\n newtype_index! {\n     /// An index to an [`Arm`] stored in [`Thir::arms`]\n     #[derive(HashStable)]"}, {"sha": "f80beadd6e5515e40d9f956d63301432ecb88782", "filename": "compiler/rustc_middle/src/thir/abstract_const.rs", "status": "added", "additions": 61, "deletions": 0, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/c7dbe7a830100c70d59994fd940bf75bb6e39b39/compiler%2Frustc_middle%2Fsrc%2Fthir%2Fabstract_const.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7dbe7a830100c70d59994fd940bf75bb6e39b39/compiler%2Frustc_middle%2Fsrc%2Fthir%2Fabstract_const.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fthir%2Fabstract_const.rs?ref=c7dbe7a830100c70d59994fd940bf75bb6e39b39", "patch": "@@ -0,0 +1,61 @@\n+//! A subset of a mir body used for const evaluatability checking.\n+use crate::mir;\n+use crate::ty::{self, Ty, TyCtxt};\n+use rustc_errors::ErrorReported;\n+\n+rustc_index::newtype_index! {\n+    /// An index into an `AbstractConst`.\n+    pub struct NodeId {\n+        derive [HashStable]\n+        DEBUG_FORMAT = \"n{}\",\n+    }\n+}\n+\n+#[derive(Debug, Clone, Copy, PartialEq, Eq, HashStable, TyEncodable, TyDecodable)]\n+pub enum CastKind {\n+    /// thir::ExprKind::As\n+    As,\n+    /// thir::ExprKind::Use\n+    Use,\n+}\n+\n+/// A node of an `AbstractConst`.\n+#[derive(Debug, Clone, Copy, PartialEq, Eq, HashStable, TyEncodable, TyDecodable)]\n+pub enum Node<'tcx> {\n+    Leaf(&'tcx ty::Const<'tcx>),\n+    Binop(mir::BinOp, NodeId, NodeId),\n+    UnaryOp(mir::UnOp, NodeId),\n+    FunctionCall(NodeId, &'tcx [NodeId]),\n+    Cast(CastKind, NodeId, Ty<'tcx>),\n+}\n+\n+#[derive(Debug, Copy, Clone, PartialEq, Eq, HashStable, TyEncodable, TyDecodable)]\n+pub enum NotConstEvaluatable {\n+    Error(ErrorReported),\n+    MentionsInfer,\n+    MentionsParam,\n+}\n+\n+impl From<ErrorReported> for NotConstEvaluatable {\n+    fn from(e: ErrorReported) -> NotConstEvaluatable {\n+        NotConstEvaluatable::Error(e)\n+    }\n+}\n+\n+TrivialTypeFoldableAndLiftImpls! {\n+    NotConstEvaluatable,\n+}\n+\n+impl<'tcx> TyCtxt<'tcx> {\n+    #[inline]\n+    pub fn thir_abstract_const_opt_const_arg(\n+        self,\n+        def: ty::WithOptConstParam<rustc_hir::def_id::DefId>,\n+    ) -> Result<Option<&'tcx [Node<'tcx>]>, ErrorReported> {\n+        if let Some((did, param_did)) = def.as_const_arg() {\n+            self.thir_abstract_const_of_const_arg((did, param_did))\n+        } else {\n+            self.thir_abstract_const(def.did)\n+        }\n+    }\n+}"}, {"sha": "7fc15e02fcd307511041e4743d8e851ca78382e4", "filename": "compiler/rustc_middle/src/thir/visit.rs", "status": "renamed", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c7dbe7a830100c70d59994fd940bf75bb6e39b39/compiler%2Frustc_middle%2Fsrc%2Fthir%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7dbe7a830100c70d59994fd940bf75bb6e39b39/compiler%2Frustc_middle%2Fsrc%2Fthir%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fthir%2Fvisit.rs?ref=c7dbe7a830100c70d59994fd940bf75bb6e39b39", "patch": "@@ -1,4 +1,6 @@\n-use rustc_middle::thir::{self, *};\n+use super::{\n+    Arm, Block, Expr, ExprKind, Guard, InlineAsmOperand, Pat, PatKind, Stmt, StmtKind, Thir,\n+};\n use rustc_middle::ty::Const;\n \n pub trait Visitor<'a, 'tcx: 'a>: Sized {\n@@ -101,7 +103,7 @@ pub fn walk_expr<'a, 'tcx: 'a, V: Visitor<'a, 'tcx>>(visitor: &mut V, expr: &Exp\n                 visitor.visit_expr(&visitor.thir()[field]);\n             }\n         }\n-        Adt(box thir::Adt {\n+        Adt(box crate::thir::Adt {\n             ref fields,\n             ref base,\n             adt_def: _,", "previous_filename": "compiler/rustc_mir_build/src/thir/visit.rs"}, {"sha": "e21a2d1034cdd3e923e8bba1838fc515dca6832a", "filename": "compiler/rustc_middle/src/traits/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c7dbe7a830100c70d59994fd940bf75bb6e39b39/compiler%2Frustc_middle%2Fsrc%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7dbe7a830100c70d59994fd940bf75bb6e39b39/compiler%2Frustc_middle%2Fsrc%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Ftraits%2Fmod.rs?ref=c7dbe7a830100c70d59994fd940bf75bb6e39b39", "patch": "@@ -9,7 +9,7 @@ pub mod specialization_graph;\n mod structural_impls;\n \n use crate::infer::canonical::Canonical;\n-use crate::mir::abstract_const::NotConstEvaluatable;\n+use crate::thir::abstract_const::NotConstEvaluatable;\n use crate::ty::subst::SubstsRef;\n use crate::ty::{self, AdtKind, Ty, TyCtxt};\n "}, {"sha": "8b70692960df9374645d95e5ab188486c04a26db", "filename": "compiler/rustc_middle/src/ty/codec.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/c7dbe7a830100c70d59994fd940bf75bb6e39b39/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcodec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7dbe7a830100c70d59994fd940bf75bb6e39b39/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcodec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcodec.rs?ref=c7dbe7a830100c70d59994fd940bf75bb6e39b39", "patch": "@@ -12,6 +12,7 @@ use crate::mir::{\n     self,\n     interpret::{AllocId, Allocation},\n };\n+use crate::thir;\n use crate::ty::subst::SubstsRef;\n use crate::ty::{self, List, Ty, TyCtxt};\n use rustc_data_structures::fx::FxHashMap;\n@@ -362,7 +363,7 @@ impl<'tcx, D: TyDecoder<'tcx>> RefDecodable<'tcx, D> for [(ty::Predicate<'tcx>,\n     }\n }\n \n-impl<'tcx, D: TyDecoder<'tcx>> RefDecodable<'tcx, D> for [mir::abstract_const::Node<'tcx>] {\n+impl<'tcx, D: TyDecoder<'tcx>> RefDecodable<'tcx, D> for [thir::abstract_const::Node<'tcx>] {\n     fn decode(decoder: &mut D) -> Result<&'tcx Self, D::Error> {\n         Ok(decoder.tcx().arena.alloc_from_iter(\n             (0..decoder.read_usize()?)\n@@ -372,7 +373,7 @@ impl<'tcx, D: TyDecoder<'tcx>> RefDecodable<'tcx, D> for [mir::abstract_const::N\n     }\n }\n \n-impl<'tcx, D: TyDecoder<'tcx>> RefDecodable<'tcx, D> for [mir::abstract_const::NodeId] {\n+impl<'tcx, D: TyDecoder<'tcx>> RefDecodable<'tcx, D> for [thir::abstract_const::NodeId] {\n     fn decode(decoder: &mut D) -> Result<&'tcx Self, D::Error> {\n         Ok(decoder.tcx().arena.alloc_from_iter(\n             (0..decoder.read_usize()?)"}, {"sha": "cd1e38445ae8c7a4c12194b5eb38ae79009e82ea", "filename": "compiler/rustc_middle/src/ty/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c7dbe7a830100c70d59994fd940bf75bb6e39b39/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7dbe7a830100c70d59994fd940bf75bb6e39b39/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs?ref=c7dbe7a830100c70d59994fd940bf75bb6e39b39", "patch": "@@ -127,7 +127,7 @@ pub struct ResolverOutputs {\n     pub extern_crate_map: FxHashMap<LocalDefId, CrateNum>,\n     pub maybe_unused_trait_imports: FxHashSet<LocalDefId>,\n     pub maybe_unused_extern_crates: Vec<(LocalDefId, Span)>,\n-    pub export_map: ExportMap<LocalDefId>,\n+    pub export_map: ExportMap,\n     pub glob_map: FxHashMap<LocalDefId, FxHashSet<Symbol>>,\n     /// Extern prelude entries. The value is `true` if the entry was introduced\n     /// via `extern crate` item and not `--extern` option or compiler built-in."}, {"sha": "0ee740a6463593de96e159b1ffd434919aaa75d8", "filename": "compiler/rustc_mir_build/src/build/mod.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c7dbe7a830100c70d59994fd940bf75bb6e39b39/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7dbe7a830100c70d59994fd940bf75bb6e39b39/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmod.rs?ref=c7dbe7a830100c70d59994fd940bf75bb6e39b39", "patch": "@@ -47,10 +47,12 @@ fn mir_build(tcx: TyCtxt<'_>, def: ty::WithOptConstParam<LocalDefId>) -> Body<'_\n     // Ensure unsafeck is ran before we steal the THIR.\n     match def {\n         ty::WithOptConstParam { did, const_param_did: Some(const_param_did) } => {\n-            tcx.ensure().thir_check_unsafety_for_const_arg((did, const_param_did))\n+            tcx.ensure().thir_check_unsafety_for_const_arg((did, const_param_did));\n+            tcx.ensure().thir_abstract_const_of_const_arg((did, const_param_did));\n         }\n         ty::WithOptConstParam { did, const_param_did: None } => {\n-            tcx.ensure().thir_check_unsafety(did)\n+            tcx.ensure().thir_check_unsafety(did);\n+            tcx.ensure().thir_abstract_const(did);\n         }\n     }\n "}, {"sha": "0e82b187201422d4983f105718266d74e946fb1d", "filename": "compiler/rustc_mir_build/src/check_unsafety.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c7dbe7a830100c70d59994fd940bf75bb6e39b39/compiler%2Frustc_mir_build%2Fsrc%2Fcheck_unsafety.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7dbe7a830100c70d59994fd940bf75bb6e39b39/compiler%2Frustc_mir_build%2Fsrc%2Fcheck_unsafety.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fcheck_unsafety.rs?ref=c7dbe7a830100c70d59994fd940bf75bb6e39b39", "patch": "@@ -1,5 +1,5 @@\n use crate::build::ExprCategory;\n-use crate::thir::visit::{self, Visitor};\n+use rustc_middle::thir::visit::{self, Visitor};\n \n use rustc_errors::struct_span_err;\n use rustc_hir as hir;"}, {"sha": "ddbe1b0b69c1eb9dba9686063215b7c4086f9618", "filename": "compiler/rustc_mir_build/src/thir/mod.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/c7dbe7a830100c70d59994fd940bf75bb6e39b39/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7dbe7a830100c70d59994fd940bf75bb6e39b39/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fmod.rs?ref=c7dbe7a830100c70d59994fd940bf75bb6e39b39", "patch": "@@ -11,4 +11,3 @@ crate mod cx;\n crate mod pattern;\n \n mod util;\n-pub mod visit;"}, {"sha": "90d7cbee976d0d1dcbcec069bcb6eb627da1eb9f", "filename": "compiler/rustc_mir_transform/src/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/c7dbe7a830100c70d59994fd940bf75bb6e39b39/compiler%2Frustc_mir_transform%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7dbe7a830100c70d59994fd940bf75bb6e39b39/compiler%2Frustc_mir_transform%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Flib.rs?ref=c7dbe7a830100c70d59994fd940bf75bb6e39b39", "patch": "@@ -306,7 +306,6 @@ fn mir_promoted(\n     // this point, before we steal the mir-const result.\n     // Also this means promotion can rely on all const checks having been done.\n     let _ = tcx.mir_const_qualif_opt_const_arg(def);\n-    let _ = tcx.mir_abstract_const_opt_const_arg(def.to_global());\n     let mut body = tcx.mir_const(def).steal();\n \n     let mut required_consts = Vec::new();"}, {"sha": "391e43054239d2d9929acd6c89ab01eb9989a357", "filename": "compiler/rustc_privacy/src/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c7dbe7a830100c70d59994fd940bf75bb6e39b39/compiler%2Frustc_privacy%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7dbe7a830100c70d59994fd940bf75bb6e39b39/compiler%2Frustc_privacy%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_privacy%2Fsrc%2Flib.rs?ref=c7dbe7a830100c70d59994fd940bf75bb6e39b39", "patch": "@@ -19,8 +19,8 @@ use rustc_hir::{AssocItemKind, HirIdSet, Node, PatKind};\n use rustc_middle::bug;\n use rustc_middle::hir::map::Map;\n use rustc_middle::middle::privacy::{AccessLevel, AccessLevels};\n-use rustc_middle::mir::abstract_const::Node as ACNode;\n use rustc_middle::span_bug;\n+use rustc_middle::thir::abstract_const::Node as ACNode;\n use rustc_middle::ty::fold::TypeVisitor;\n use rustc_middle::ty::query::Providers;\n use rustc_middle::ty::subst::{InternalSubsts, Subst};"}, {"sha": "bfd36bfb2db2321902c5c09ba6bcdc14d44cdd8f", "filename": "compiler/rustc_query_impl/src/on_disk_cache.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/c7dbe7a830100c70d59994fd940bf75bb6e39b39/compiler%2Frustc_query_impl%2Fsrc%2Fon_disk_cache.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7dbe7a830100c70d59994fd940bf75bb6e39b39/compiler%2Frustc_query_impl%2Fsrc%2Fon_disk_cache.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_query_impl%2Fsrc%2Fon_disk_cache.rs?ref=c7dbe7a830100c70d59994fd940bf75bb6e39b39", "patch": "@@ -9,6 +9,7 @@ use rustc_index::vec::{Idx, IndexVec};\n use rustc_middle::dep_graph::{DepNode, DepNodeIndex, SerializedDepNodeIndex};\n use rustc_middle::mir::interpret::{AllocDecodingSession, AllocDecodingState};\n use rustc_middle::mir::{self, interpret};\n+use rustc_middle::thir;\n use rustc_middle::ty::codec::{RefDecodable, TyDecoder, TyEncoder};\n use rustc_middle::ty::{self, Ty, TyCtxt};\n use rustc_query_system::dep_graph::DepContext;\n@@ -921,7 +922,7 @@ impl<'a, 'tcx> Decodable<CacheDecoder<'a, 'tcx>>\n     }\n }\n \n-impl<'a, 'tcx> Decodable<CacheDecoder<'a, 'tcx>> for &'tcx [mir::abstract_const::Node<'tcx>] {\n+impl<'a, 'tcx> Decodable<CacheDecoder<'a, 'tcx>> for &'tcx [thir::abstract_const::Node<'tcx>] {\n     fn decode(d: &mut CacheDecoder<'a, 'tcx>) -> Result<Self, String> {\n         RefDecodable::decode(d)\n     }"}, {"sha": "55f2b04c4f1c1f6f258238e5bb8d14829eb5e41b", "filename": "compiler/rustc_resolve/src/build_reduced_graph.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c7dbe7a830100c70d59994fd940bf75bb6e39b39/compiler%2Frustc_resolve%2Fsrc%2Fbuild_reduced_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7dbe7a830100c70d59994fd940bf75bb6e39b39/compiler%2Frustc_resolve%2Fsrc%2Fbuild_reduced_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Fbuild_reduced_graph.rs?ref=c7dbe7a830100c70d59994fd940bf75bb6e39b39", "patch": "@@ -228,7 +228,6 @@ impl<'a> Resolver<'a> {\n     crate fn build_reduced_graph_external(&mut self, module: Module<'a>) {\n         let def_id = module.def_id().expect(\"unpopulated module without a def-id\");\n         for child in self.cstore().item_children_untracked(def_id, self.session) {\n-            let child = child.map_id(|_| panic!(\"unexpected id\"));\n             let parent_scope = ParentScope::module(module, self);\n             BuildReducedGraphVisitor { r: self, parent_scope }\n                 .build_reduced_graph_for_external_crate_res(child);\n@@ -946,9 +945,10 @@ impl<'a, 'b> BuildReducedGraphVisitor<'a, 'b> {\n     }\n \n     /// Builds the reduced graph for a single item in an external crate.\n-    fn build_reduced_graph_for_external_crate_res(&mut self, child: Export<NodeId>) {\n+    fn build_reduced_graph_for_external_crate_res(&mut self, child: Export) {\n         let parent = self.parent_scope.module;\n         let Export { ident, res, vis, span } = child;\n+        let res = res.expect_non_local();\n         let expansion = self.parent_scope.expansion;\n         // Record primary definitions.\n         match res {"}, {"sha": "d4782edbc134645305d35091a0c252aa6b163de8", "filename": "compiler/rustc_resolve/src/imports.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/c7dbe7a830100c70d59994fd940bf75bb6e39b39/compiler%2Frustc_resolve%2Fsrc%2Fimports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7dbe7a830100c70d59994fd940bf75bb6e39b39/compiler%2Frustc_resolve%2Fsrc%2Fimports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Fimports.rs?ref=c7dbe7a830100c70d59994fd940bf75bb6e39b39", "patch": "@@ -11,7 +11,6 @@ use crate::{NameBinding, NameBindingKind, PathResult, PrivacyError, ToNameBindin\n \n use rustc_ast::unwrap_or;\n use rustc_ast::NodeId;\n-use rustc_ast_lowering::ResolverAstLowering;\n use rustc_data_structures::fx::FxHashSet;\n use rustc_data_structures::ptr_key::PtrKey;\n use rustc_errors::{pluralize, struct_span_err, Applicability};\n@@ -1387,13 +1386,13 @@ impl<'a, 'b> ImportResolver<'a, 'b> {\n \n         let mut reexports = Vec::new();\n \n-        module.for_each_child(self.r, |this, ident, _, binding| {\n+        module.for_each_child(self.r, |_, ident, _, binding| {\n             // Filter away ambiguous imports and anything that has def-site hygiene.\n             // FIXME: Implement actual cross-crate hygiene.\n             let is_good_import =\n                 binding.is_import() && !binding.is_ambiguity() && !ident.span.from_expansion();\n             if is_good_import || binding.is_macro_def() {\n-                let res = binding.res().map_id(|id| this.local_def_id(id));\n+                let res = binding.res().expect_non_local();\n                 if res != def::Res::Err {\n                     reexports.push(Export { ident, res, span: binding.span, vis: binding.vis });\n                 }"}, {"sha": "d76ba80e42eab75a95eeddd5a836b802714ab616", "filename": "compiler/rustc_resolve/src/lib.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/c7dbe7a830100c70d59994fd940bf75bb6e39b39/compiler%2Frustc_resolve%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7dbe7a830100c70d59994fd940bf75bb6e39b39/compiler%2Frustc_resolve%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Flib.rs?ref=c7dbe7a830100c70d59994fd940bf75bb6e39b39", "patch": "@@ -14,6 +14,7 @@\n #![feature(crate_visibility_modifier)]\n #![feature(format_args_capture)]\n #![feature(iter_zip)]\n+#![feature(never_type)]\n #![feature(nll)]\n #![recursion_limit = \"256\"]\n #![allow(rustdoc::private_intra_doc_links)]\n@@ -911,7 +912,7 @@ pub struct Resolver<'a> {\n \n     /// `CrateNum` resolutions of `extern crate` items.\n     extern_crate_map: FxHashMap<LocalDefId, CrateNum>,\n-    export_map: ExportMap<LocalDefId>,\n+    export_map: ExportMap,\n     trait_map: Option<NodeMap<Vec<TraitCandidate>>>,\n \n     /// A map from nodes to anonymous modules."}, {"sha": "e32e4493726dbb7d279c66e1451a10d99ccfc41b", "filename": "compiler/rustc_serialize/src/serialize.rs", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/c7dbe7a830100c70d59994fd940bf75bb6e39b39/compiler%2Frustc_serialize%2Fsrc%2Fserialize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7dbe7a830100c70d59994fd940bf75bb6e39b39/compiler%2Frustc_serialize%2Fsrc%2Fserialize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_serialize%2Fsrc%2Fserialize.rs?ref=c7dbe7a830100c70d59994fd940bf75bb6e39b39", "patch": "@@ -366,6 +366,18 @@ direct_serialize_impls! {\n     char emit_char read_char\n }\n \n+impl<S: Encoder> Encodable<S> for ! {\n+    fn encode(&self, _s: &mut S) -> Result<(), S::Error> {\n+        unreachable!()\n+    }\n+}\n+\n+impl<D: Decoder> Decodable<D> for ! {\n+    fn decode(_d: &mut D) -> Result<!, D::Error> {\n+        unreachable!()\n+    }\n+}\n+\n impl<S: Encoder> Encodable<S> for ::std::num::NonZeroU32 {\n     fn encode(&self, s: &mut S) -> Result<(), S::Error> {\n         s.emit_u32(self.get())"}, {"sha": "24fa5007f1ecdc446f528a307edd28f11ec0efd7", "filename": "compiler/rustc_trait_selection/src/traits/const_evaluatable.rs", "status": "modified", "additions": 167, "deletions": 258, "changes": 425, "blob_url": "https://github.com/rust-lang/rust/blob/c7dbe7a830100c70d59994fd940bf75bb6e39b39/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fconst_evaluatable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7dbe7a830100c70d59994fd940bf75bb6e39b39/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fconst_evaluatable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fconst_evaluatable.rs?ref=c7dbe7a830100c70d59994fd940bf75bb6e39b39", "patch": "@@ -6,16 +6,16 @@\n //! this is not as easy.\n //!\n //! In this case we try to build an abstract representation of this constant using\n-//! `mir_abstract_const` which can then be checked for structural equality with other\n+//! `thir_abstract_const` which can then be checked for structural equality with other\n //! generic constants mentioned in the `caller_bounds` of the current environment.\n use rustc_errors::ErrorReported;\n use rustc_hir::def::DefKind;\n-use rustc_index::bit_set::BitSet;\n use rustc_index::vec::IndexVec;\n use rustc_infer::infer::InferCtxt;\n-use rustc_middle::mir::abstract_const::{Node, NodeId, NotConstEvaluatable};\n+use rustc_middle::mir;\n use rustc_middle::mir::interpret::ErrorHandled;\n-use rustc_middle::mir::{self, Rvalue, StatementKind, TerminatorKind};\n+use rustc_middle::thir;\n+use rustc_middle::thir::abstract_const::{self, Node, NodeId, NotConstEvaluatable};\n use rustc_middle::ty::subst::{Subst, SubstsRef};\n use rustc_middle::ty::{self, TyCtxt, TypeFoldable};\n use rustc_session::lint;\n@@ -196,7 +196,7 @@ impl<'tcx> AbstractConst<'tcx> {\n         tcx: TyCtxt<'tcx>,\n         uv: ty::Unevaluated<'tcx, ()>,\n     ) -> Result<Option<AbstractConst<'tcx>>, ErrorReported> {\n-        let inner = tcx.mir_abstract_const_opt_const_arg(uv.def)?;\n+        let inner = tcx.thir_abstract_const_opt_const_arg(uv.def)?;\n         debug!(\"AbstractConst::new({:?}) = {:?}\", uv, inner);\n         Ok(inner.map(|inner| AbstractConst { inner, substs: uv.substs(tcx) }))\n     }\n@@ -223,35 +223,24 @@ impl<'tcx> AbstractConst<'tcx> {\n     }\n }\n \n-#[derive(Debug, Clone, Copy, PartialEq, Eq)]\n-struct WorkNode<'tcx> {\n-    node: Node<'tcx>,\n-    span: Span,\n-    used: bool,\n-}\n-\n struct AbstractConstBuilder<'a, 'tcx> {\n     tcx: TyCtxt<'tcx>,\n-    body: &'a mir::Body<'tcx>,\n+    body_id: thir::ExprId,\n+    body: &'a thir::Thir<'tcx>,\n     /// The current WIP node tree.\n-    ///\n-    /// We require all nodes to be used in the final abstract const,\n-    /// so we store this here. Note that we also consider nodes as used\n-    /// if they are mentioned in an assert, so some used nodes are never\n-    /// actually reachable by walking the [`AbstractConst`].\n-    nodes: IndexVec<NodeId, WorkNode<'tcx>>,\n-    locals: IndexVec<mir::Local, NodeId>,\n-    /// We only allow field accesses if they access\n-    /// the result of a checked operation.\n-    checked_op_locals: BitSet<mir::Local>,\n+    nodes: IndexVec<NodeId, Node<'tcx>>,\n }\n \n impl<'a, 'tcx> AbstractConstBuilder<'a, 'tcx> {\n+    fn root_span(&self) -> Span {\n+        self.body.exprs[self.body_id].span\n+    }\n+\n     fn error(&mut self, span: Option<Span>, msg: &str) -> Result<!, ErrorReported> {\n         self.tcx\n             .sess\n-            .struct_span_err(self.body.span, \"overly complex generic constant\")\n-            .span_label(span.unwrap_or(self.body.span), msg)\n+            .struct_span_err(self.root_span(), \"overly complex generic constant\")\n+            .span_label(span.unwrap_or(self.root_span()), msg)\n             .help(\"consider moving this anonymous constant into a `const` function\")\n             .emit();\n \n@@ -260,98 +249,49 @@ impl<'a, 'tcx> AbstractConstBuilder<'a, 'tcx> {\n \n     fn new(\n         tcx: TyCtxt<'tcx>,\n-        body: &'a mir::Body<'tcx>,\n+        (body, body_id): (&'a thir::Thir<'tcx>, thir::ExprId),\n     ) -> Result<Option<AbstractConstBuilder<'a, 'tcx>>, ErrorReported> {\n-        let mut builder = AbstractConstBuilder {\n-            tcx,\n-            body,\n-            nodes: IndexVec::new(),\n-            locals: IndexVec::from_elem(NodeId::MAX, &body.local_decls),\n-            checked_op_locals: BitSet::new_empty(body.local_decls.len()),\n-        };\n-\n-        // We don't have to look at concrete constants, as we\n-        // can just evaluate them.\n-        if !body.is_polymorphic {\n-            return Ok(None);\n-        }\n+        let builder = AbstractConstBuilder { tcx, body_id, body, nodes: IndexVec::new() };\n \n-        // We only allow consts without control flow, so\n-        // we check for cycles here which simplifies the\n-        // rest of this implementation.\n-        if body.is_cfg_cyclic() {\n-            builder.error(None, \"cyclic anonymous constants are forbidden\")?;\n+        struct IsThirPolymorphic<'a, 'tcx> {\n+            is_poly: bool,\n+            thir: &'a thir::Thir<'tcx>,\n+            tcx: TyCtxt<'tcx>,\n         }\n \n-        Ok(Some(builder))\n-    }\n-\n-    fn add_node(&mut self, node: Node<'tcx>, span: Span) -> NodeId {\n-        // Mark used nodes.\n-        match node {\n-            Node::Leaf(_) => (),\n-            Node::Binop(_, lhs, rhs) => {\n-                self.nodes[lhs].used = true;\n-                self.nodes[rhs].used = true;\n-            }\n-            Node::UnaryOp(_, input) => {\n-                self.nodes[input].used = true;\n-            }\n-            Node::FunctionCall(func, nodes) => {\n-                self.nodes[func].used = true;\n-                nodes.iter().for_each(|&n| self.nodes[n].used = true);\n+        use thir::visit;\n+        impl<'a, 'tcx: 'a> visit::Visitor<'a, 'tcx> for IsThirPolymorphic<'a, 'tcx> {\n+            fn thir(&self) -> &'a thir::Thir<'tcx> {\n+                &self.thir\n             }\n-            Node::Cast(_, operand, _) => {\n-                self.nodes[operand].used = true;\n+\n+            fn visit_expr(&mut self, expr: &thir::Expr<'tcx>) {\n+                self.is_poly |= expr.ty.definitely_has_param_types_or_consts(self.tcx);\n+                if self.is_poly == false {\n+                    visit::walk_expr(self, expr)\n+                }\n             }\n-        }\n \n-        // Nodes start as unused.\n-        self.nodes.push(WorkNode { node, span, used: false })\n-    }\n+            fn visit_pat(&mut self, pat: &thir::Pat<'tcx>) {\n+                self.is_poly |= pat.ty.definitely_has_param_types_or_consts(self.tcx);\n+                if self.is_poly == false {\n+                    visit::walk_pat(self, pat);\n+                }\n+            }\n \n-    fn place_to_local(\n-        &mut self,\n-        span: Span,\n-        p: &mir::Place<'tcx>,\n-    ) -> Result<mir::Local, ErrorReported> {\n-        const ZERO_FIELD: mir::Field = mir::Field::from_usize(0);\n-        // Do not allow any projections.\n-        //\n-        // One exception are field accesses on the result of checked operations,\n-        // which are required to support things like `1 + 2`.\n-        if let Some(p) = p.as_local() {\n-            debug_assert!(!self.checked_op_locals.contains(p));\n-            Ok(p)\n-        } else if let &[mir::ProjectionElem::Field(ZERO_FIELD, _)] = p.projection.as_ref() {\n-            // Only allow field accesses if the given local\n-            // contains the result of a checked operation.\n-            if self.checked_op_locals.contains(p.local) {\n-                Ok(p.local)\n-            } else {\n-                self.error(Some(span), \"unsupported projection\")?;\n+            fn visit_const(&mut self, ct: &'tcx ty::Const<'tcx>) {\n+                self.is_poly |= ct.definitely_has_param_types_or_consts(self.tcx);\n             }\n-        } else {\n-            self.error(Some(span), \"unsupported projection\")?;\n         }\n-    }\n \n-    fn operand_to_node(\n-        &mut self,\n-        span: Span,\n-        op: &mir::Operand<'tcx>,\n-    ) -> Result<NodeId, ErrorReported> {\n-        debug!(\"operand_to_node: op={:?}\", op);\n-        match op {\n-            mir::Operand::Copy(p) | mir::Operand::Move(p) => {\n-                let local = self.place_to_local(span, p)?;\n-                Ok(self.locals[local])\n-            }\n-            mir::Operand::Constant(ct) => match ct.literal {\n-                mir::ConstantKind::Ty(ct) => Ok(self.add_node(Node::Leaf(ct), span)),\n-                mir::ConstantKind::Val(..) => self.error(Some(span), \"unsupported constant\")?,\n-            },\n+        let mut is_poly_vis = IsThirPolymorphic { is_poly: false, thir: body, tcx };\n+        visit::walk_expr(&mut is_poly_vis, &body[body_id]);\n+        debug!(\"AbstractConstBuilder: is_poly={}\", is_poly_vis.is_poly);\n+        if is_poly_vis.is_poly == false {\n+            return Ok(None);\n         }\n+\n+        Ok(Some(builder))\n     }\n \n     /// We do not allow all binary operations in abstract consts, so filter disallowed ones.\n@@ -373,170 +313,126 @@ impl<'a, 'tcx> AbstractConstBuilder<'a, 'tcx> {\n         }\n     }\n \n-    fn build_statement(&mut self, stmt: &mir::Statement<'tcx>) -> Result<(), ErrorReported> {\n-        debug!(\"AbstractConstBuilder: stmt={:?}\", stmt);\n-        let span = stmt.source_info.span;\n-        match stmt.kind {\n-            StatementKind::Assign(box (ref place, ref rvalue)) => {\n-                let local = self.place_to_local(span, place)?;\n-                match *rvalue {\n-                    Rvalue::Use(ref operand) => {\n-                        self.locals[local] = self.operand_to_node(span, operand)?;\n-                        Ok(())\n-                    }\n-                    Rvalue::BinaryOp(op, box (ref lhs, ref rhs)) if Self::check_binop(op) => {\n-                        let lhs = self.operand_to_node(span, lhs)?;\n-                        let rhs = self.operand_to_node(span, rhs)?;\n-                        self.locals[local] = self.add_node(Node::Binop(op, lhs, rhs), span);\n-                        if op.is_checkable() {\n-                            bug!(\"unexpected unchecked checkable binary operation\");\n-                        } else {\n-                            Ok(())\n-                        }\n-                    }\n-                    Rvalue::CheckedBinaryOp(op, box (ref lhs, ref rhs))\n-                        if Self::check_binop(op) =>\n-                    {\n-                        let lhs = self.operand_to_node(span, lhs)?;\n-                        let rhs = self.operand_to_node(span, rhs)?;\n-                        self.locals[local] = self.add_node(Node::Binop(op, lhs, rhs), span);\n-                        self.checked_op_locals.insert(local);\n-                        Ok(())\n-                    }\n-                    Rvalue::UnaryOp(op, ref operand) if Self::check_unop(op) => {\n-                        let operand = self.operand_to_node(span, operand)?;\n-                        self.locals[local] = self.add_node(Node::UnaryOp(op, operand), span);\n-                        Ok(())\n-                    }\n-                    Rvalue::Cast(cast_kind, ref operand, ty) => {\n-                        let operand = self.operand_to_node(span, operand)?;\n-                        self.locals[local] =\n-                            self.add_node(Node::Cast(cast_kind, operand, ty), span);\n-                        Ok(())\n-                    }\n-                    _ => self.error(Some(span), \"unsupported rvalue\")?,\n-                }\n-            }\n-            // These are not actually relevant for us here, so we can ignore them.\n-            StatementKind::AscribeUserType(..)\n-            | StatementKind::StorageLive(_)\n-            | StatementKind::StorageDead(_) => Ok(()),\n-            _ => self.error(Some(stmt.source_info.span), \"unsupported statement\")?,\n-        }\n-    }\n-\n-    /// Possible return values:\n-    ///\n-    /// - `None`: unsupported terminator, stop building\n-    /// - `Some(None)`: supported terminator, finish building\n-    /// - `Some(Some(block))`: support terminator, build `block` next\n-    fn build_terminator(\n-        &mut self,\n-        terminator: &mir::Terminator<'tcx>,\n-    ) -> Result<Option<mir::BasicBlock>, ErrorReported> {\n-        debug!(\"AbstractConstBuilder: terminator={:?}\", terminator);\n-        match terminator.kind {\n-            TerminatorKind::Goto { target } => Ok(Some(target)),\n-            TerminatorKind::Return => Ok(None),\n-            TerminatorKind::Call {\n-                ref func,\n-                ref args,\n-                destination: Some((ref place, target)),\n-                // We do not care about `cleanup` here. Any branch which\n-                // uses `cleanup` will fail const-eval and they therefore\n-                // do not matter when checking for const evaluatability.\n-                //\n-                // Do note that even if `panic::catch_unwind` is made const,\n-                // we still do not have to care about this, as we do not look\n-                // into functions.\n-                cleanup: _,\n-                // Do not allow overloaded operators for now,\n-                // we probably do want to allow this in the future.\n-                //\n-                // This is currently fairly irrelevant as it requires `const Trait`s.\n-                from_hir_call: true,\n-                fn_span,\n-            } => {\n-                let local = self.place_to_local(fn_span, place)?;\n-                let func = self.operand_to_node(fn_span, func)?;\n-                let args = self.tcx.arena.alloc_from_iter(\n-                    args.iter()\n-                        .map(|arg| self.operand_to_node(terminator.source_info.span, arg))\n-                        .collect::<Result<Vec<NodeId>, _>>()?,\n-                );\n-                self.locals[local] = self.add_node(Node::FunctionCall(func, args), fn_span);\n-                Ok(Some(target))\n-            }\n-            TerminatorKind::Assert { ref cond, expected: false, target, .. } => {\n-                let p = match cond {\n-                    mir::Operand::Copy(p) | mir::Operand::Move(p) => p,\n-                    mir::Operand::Constant(_) => bug!(\"unexpected assert\"),\n-                };\n-\n-                const ONE_FIELD: mir::Field = mir::Field::from_usize(1);\n-                debug!(\"proj: {:?}\", p.projection);\n-                if let Some(p) = p.as_local() {\n-                    debug_assert!(!self.checked_op_locals.contains(p));\n-                    // Mark locals directly used in asserts as used.\n-                    //\n-                    // This is needed because division does not use `CheckedBinop` but instead\n-                    // adds an explicit assert for `divisor != 0`.\n-                    self.nodes[self.locals[p]].used = true;\n-                    return Ok(Some(target));\n-                } else if let &[mir::ProjectionElem::Field(ONE_FIELD, _)] = p.projection.as_ref() {\n-                    // Only allow asserts checking the result of a checked operation.\n-                    if self.checked_op_locals.contains(p.local) {\n-                        return Ok(Some(target));\n-                    }\n-                }\n-\n-                self.error(Some(terminator.source_info.span), \"unsupported assertion\")?;\n-            }\n-            _ => self.error(Some(terminator.source_info.span), \"unsupported terminator\")?,\n-        }\n-    }\n-\n-    /// Builds the abstract const by walking the mir from start to finish\n-    /// and bailing out when encountering an unsupported operation.\n+    /// Builds the abstract const by walking the thir and bailing out when\n+    /// encountering an unspported operation.\n     fn build(mut self) -> Result<&'tcx [Node<'tcx>], ErrorReported> {\n-        let mut block = &self.body.basic_blocks()[mir::START_BLOCK];\n-        // We checked for a cyclic cfg above, so this should terminate.\n-        loop {\n-            debug!(\"AbstractConstBuilder: block={:?}\", block);\n-            for stmt in block.statements.iter() {\n-                self.build_statement(stmt)?;\n-            }\n+        debug!(\"Abstractconstbuilder::build: body={:?}\", &*self.body);\n+        self.recurse_build(self.body_id)?;\n \n-            if let Some(next) = self.build_terminator(block.terminator())? {\n-                block = &self.body.basic_blocks()[next];\n-            } else {\n-                break;\n-            }\n-        }\n-\n-        assert_eq!(self.locals[mir::RETURN_PLACE], self.nodes.last().unwrap());\n         for n in self.nodes.iter() {\n-            if let Node::Leaf(ty::Const { val: ty::ConstKind::Unevaluated(ct), ty: _ }) = n.node {\n+            if let Node::Leaf(ty::Const { val: ty::ConstKind::Unevaluated(ct), ty: _ }) = n {\n                 // `AbstractConst`s should not contain any promoteds as they require references which\n                 // are not allowed.\n                 assert_eq!(ct.promoted, None);\n             }\n         }\n \n-        self.nodes[self.locals[mir::RETURN_PLACE]].used = true;\n-        if let Some(&unused) = self.nodes.iter().find(|n| !n.used) {\n-            self.error(Some(unused.span), \"dead code\")?;\n-        }\n+        Ok(self.tcx.arena.alloc_from_iter(self.nodes.into_iter()))\n+    }\n \n-        Ok(self.tcx.arena.alloc_from_iter(self.nodes.into_iter().map(|n| n.node)))\n+    fn recurse_build(&mut self, node: thir::ExprId) -> Result<NodeId, ErrorReported> {\n+        use thir::ExprKind;\n+        let node = &self.body.exprs[node];\n+        debug!(\"recurse_build: node={:?}\", node);\n+        Ok(match &node.kind {\n+            // I dont know if handling of these 3 is correct\n+            &ExprKind::Scope { value, .. } => self.recurse_build(value)?,\n+            &ExprKind::PlaceTypeAscription { source, .. } |\n+            &ExprKind::ValueTypeAscription { source, .. } => self.recurse_build(source)?,\n+\n+            // subtle: associated consts are literals this arm handles\n+            // `<T as Trait>::ASSOC` as well as `12`\n+            &ExprKind::Literal { literal, .. } => self.nodes.push(Node::Leaf(literal)),\n+\n+            ExprKind::Call { fun, args,  .. } => {\n+                let fun = self.recurse_build(*fun)?;\n+\n+                let mut new_args = Vec::<NodeId>::with_capacity(args.len());\n+                for &id in args.iter() {\n+                    new_args.push(self.recurse_build(id)?);\n+                }\n+                let new_args = self.tcx.arena.alloc_slice(&new_args);\n+                self.nodes.push(Node::FunctionCall(fun, new_args))\n+            },\n+            &ExprKind::Binary { op, lhs, rhs } if Self::check_binop(op) => {\n+                let lhs = self.recurse_build(lhs)?;\n+                let rhs = self.recurse_build(rhs)?;\n+                self.nodes.push(Node::Binop(op, lhs, rhs))\n+            }\n+            &ExprKind::Unary { op, arg } if Self::check_unop(op) => {\n+                let arg = self.recurse_build(arg)?;\n+                self.nodes.push(Node::UnaryOp(op, arg))\n+            },\n+            // This is necessary so that the following compiles:\n+            //\n+            // ```\n+            // fn foo<const N: usize>(a: [(); N + 1]) {\n+            //     bar::<{ N + 1 }>();\n+            // }\n+            // ```\n+            ExprKind::Block { body: thir::Block { stmts: box [], expr: Some(e), .. }} => self.recurse_build(*e)?,\n+            // `ExprKind::Use` happens when a `hir::ExprKind::Cast` is a\n+            // \"coercion cast\" i.e. using a coercion or is a no-op.\n+            // This is important so that `N as usize as usize` doesnt unify with `N as usize`. (untested)\n+            &ExprKind::Use { source } => {\n+                let arg = self.recurse_build(source)?;\n+                self.nodes.push(Node::Cast(abstract_const::CastKind::Use, arg, node.ty))\n+            },\n+            &ExprKind::Cast { source } => {\n+                let arg = self.recurse_build(source)?;\n+                self.nodes.push(Node::Cast(abstract_const::CastKind::As, arg, node.ty))\n+            },\n+\n+            // FIXME(generic_const_exprs): We may want to support these.\n+            ExprKind::AddressOf { .. }\n+            | ExprKind::Borrow { .. }\n+            | ExprKind::Deref { .. }\n+            | ExprKind::Repeat { .. }\n+            | ExprKind::Array { .. }\n+            | ExprKind::Block { .. }\n+            | ExprKind::NeverToAny { .. }\n+            | ExprKind::Tuple { .. }\n+            | ExprKind::Index { .. }\n+            | ExprKind::Field { .. }\n+            | ExprKind::ConstBlock { .. }\n+            | ExprKind::Adt(_) => self.error(\n+                    Some(node.span),\n+                    \"unsupported operation in generic constant, this may be supported in the future\",\n+                )?,\n+\n+            ExprKind::Match { .. }\n+            // we dont permit let stmts so `VarRef` and `UpvarRef` cant happen\n+            | ExprKind::VarRef { .. }\n+            | ExprKind::UpvarRef { .. }\n+            | ExprKind::Closure { .. }\n+            | ExprKind::Let { .. } // let expressions imply control flow\n+            | ExprKind::Loop { .. }\n+            | ExprKind::Assign { .. }\n+            | ExprKind::StaticRef { .. }\n+            | ExprKind::LogicalOp { .. }\n+            // we handle valid unary/binary ops above\n+            | ExprKind::Unary { .. }\n+            | ExprKind::Binary { .. }\n+            | ExprKind::Break { .. }\n+            | ExprKind::Continue { .. }\n+            | ExprKind::If { .. }\n+            | ExprKind::Pointer { .. } // dont know if this is correct\n+            | ExprKind::ThreadLocalRef(_)\n+            | ExprKind::LlvmInlineAsm { .. }\n+            | ExprKind::Return { .. }\n+            | ExprKind::Box { .. } // allocations not allowed in constants\n+            | ExprKind::AssignOp { .. }\n+            | ExprKind::InlineAsm { .. }\n+            | ExprKind::Yield { .. } => self.error(Some(node.span), \"unsupported operation in generic constant\")?,\n+        })\n     }\n }\n \n /// Builds an abstract const, do not use this directly, but use `AbstractConst::new` instead.\n-pub(super) fn mir_abstract_const<'tcx>(\n+pub(super) fn thir_abstract_const<'tcx>(\n     tcx: TyCtxt<'tcx>,\n     def: ty::WithOptConstParam<LocalDefId>,\n-) -> Result<Option<&'tcx [mir::abstract_const::Node<'tcx>]>, ErrorReported> {\n+) -> Result<Option<&'tcx [thir::abstract_const::Node<'tcx>]>, ErrorReported> {\n     if tcx.features().generic_const_exprs {\n         match tcx.def_kind(def.did) {\n             // FIXME(generic_const_exprs): We currently only do this for anonymous constants,\n@@ -547,8 +443,16 @@ pub(super) fn mir_abstract_const<'tcx>(\n             DefKind::AnonConst => (),\n             _ => return Ok(None),\n         }\n-        let body = tcx.mir_const(def).borrow();\n-        AbstractConstBuilder::new(tcx, &body)?.map(AbstractConstBuilder::build).transpose()\n+\n+        let body = tcx.thir_body(def);\n+        if body.0.borrow().exprs.is_empty() {\n+            // type error in constant, there is no thir\n+            return Err(ErrorReported);\n+        }\n+\n+        AbstractConstBuilder::new(tcx, (&*body.0.borrow(), body.1))?\n+            .map(AbstractConstBuilder::build)\n+            .transpose()\n     } else {\n         Ok(None)\n     }\n@@ -682,11 +586,16 @@ pub(super) fn try_unify<'tcx>(\n                 && iter::zip(a_args, b_args)\n                     .all(|(&an, &bn)| try_unify(tcx, a.subtree(an), b.subtree(bn)))\n         }\n-        (Node::Cast(a_cast_kind, a_operand, a_ty), Node::Cast(b_cast_kind, b_operand, b_ty))\n-            if (a_ty == b_ty) && (a_cast_kind == b_cast_kind) =>\n+        (Node::Cast(a_kind, a_operand, a_ty), Node::Cast(b_kind, b_operand, b_ty))\n+            if (a_ty == b_ty) && (a_kind == b_kind) =>\n         {\n             try_unify(tcx, a.subtree(a_operand), b.subtree(b_operand))\n         }\n-        _ => false,\n+        // use this over `_ => false` to make adding variants to `Node` less error prone\n+        (Node::Cast(..), _)\n+        | (Node::FunctionCall(..), _)\n+        | (Node::UnaryOp(..), _)\n+        | (Node::Binop(..), _)\n+        | (Node::Leaf(..), _) => false,\n     }\n }"}, {"sha": "761b217c78f4e49c8734b8c638ef963c68763ee9", "filename": "compiler/rustc_trait_selection/src/traits/error_reporting/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c7dbe7a830100c70d59994fd940bf75bb6e39b39/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7dbe7a830100c70d59994fd940bf75bb6e39b39/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fmod.rs?ref=c7dbe7a830100c70d59994fd940bf75bb6e39b39", "patch": "@@ -19,7 +19,7 @@ use rustc_hir::intravisit::Visitor;\n use rustc_hir::GenericParam;\n use rustc_hir::Item;\n use rustc_hir::Node;\n-use rustc_middle::mir::abstract_const::NotConstEvaluatable;\n+use rustc_middle::thir::abstract_const::NotConstEvaluatable;\n use rustc_middle::ty::error::ExpectedFound;\n use rustc_middle::ty::fold::TypeFolder;\n use rustc_middle::ty::{"}, {"sha": "b376f4292924963574d690c85d6426119479fa89", "filename": "compiler/rustc_trait_selection/src/traits/fulfill.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c7dbe7a830100c70d59994fd940bf75bb6e39b39/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ffulfill.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7dbe7a830100c70d59994fd940bf75bb6e39b39/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ffulfill.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ffulfill.rs?ref=c7dbe7a830100c70d59994fd940bf75bb6e39b39", "patch": "@@ -5,8 +5,8 @@ use rustc_data_structures::obligation_forest::{ObligationForest, ObligationProce\n use rustc_errors::ErrorReported;\n use rustc_hir as hir;\n use rustc_infer::traits::{SelectionError, TraitEngine, TraitEngineExt as _, TraitObligation};\n-use rustc_middle::mir::abstract_const::NotConstEvaluatable;\n use rustc_middle::mir::interpret::ErrorHandled;\n+use rustc_middle::thir::abstract_const::NotConstEvaluatable;\n use rustc_middle::ty::error::{ExpectedFound, TypeError};\n use rustc_middle::ty::subst::SubstsRef;\n use rustc_middle::ty::ToPredicate;"}, {"sha": "ef208c44471cbadf52d2b5dcdea6af83fc019092", "filename": "compiler/rustc_trait_selection/src/traits/mod.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/c7dbe7a830100c70d59994fd940bf75bb6e39b39/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7dbe7a830100c70d59994fd940bf75bb6e39b39/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fmod.rs?ref=c7dbe7a830100c70d59994fd940bf75bb6e39b39", "patch": "@@ -827,16 +827,16 @@ pub fn provide(providers: &mut ty::query::Providers) {\n         vtable_entries,\n         vtable_trait_upcasting_coercion_new_vptr_slot,\n         subst_and_check_impossible_predicates,\n-        mir_abstract_const: |tcx, def_id| {\n+        thir_abstract_const: |tcx, def_id| {\n             let def_id = def_id.expect_local();\n             if let Some(def) = ty::WithOptConstParam::try_lookup(def_id, tcx) {\n-                tcx.mir_abstract_const_of_const_arg(def)\n+                tcx.thir_abstract_const_of_const_arg(def)\n             } else {\n-                const_evaluatable::mir_abstract_const(tcx, ty::WithOptConstParam::unknown(def_id))\n+                const_evaluatable::thir_abstract_const(tcx, ty::WithOptConstParam::unknown(def_id))\n             }\n         },\n-        mir_abstract_const_of_const_arg: |tcx, (did, param_did)| {\n-            const_evaluatable::mir_abstract_const(\n+        thir_abstract_const_of_const_arg: |tcx, (did, param_did)| {\n+            const_evaluatable::thir_abstract_const(\n                 tcx,\n                 ty::WithOptConstParam { did, const_param_did: Some(param_did) },\n             )"}, {"sha": "4922cf45a4a109565db5478fb7b53c8a3b5c3e8d", "filename": "compiler/rustc_trait_selection/src/traits/object_safety.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c7dbe7a830100c70d59994fd940bf75bb6e39b39/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fobject_safety.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7dbe7a830100c70d59994fd940bf75bb6e39b39/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fobject_safety.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fobject_safety.rs?ref=c7dbe7a830100c70d59994fd940bf75bb6e39b39", "patch": "@@ -836,7 +836,7 @@ fn contains_illegal_self_type_reference<'tcx, T: TypeFoldable<'tcx>>(\n             //\n             // This shouldn't really matter though as we can't really use any\n             // constants which are not considered const evaluatable.\n-            use rustc_middle::mir::abstract_const::Node;\n+            use rustc_middle::thir::abstract_const::Node;\n             if let Ok(Some(ct)) = AbstractConst::new(self.tcx, uv.shrink()) {\n                 const_evaluatable::walk_abstract_const(self.tcx, ct, |node| match node.root() {\n                     Node::Leaf(leaf) => {"}, {"sha": "f5be8bf0949e6ff12caff47d9269a7ca6c2519da", "filename": "compiler/rustc_trait_selection/src/traits/select/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c7dbe7a830100c70d59994fd940bf75bb6e39b39/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7dbe7a830100c70d59994fd940bf75bb6e39b39/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fmod.rs?ref=c7dbe7a830100c70d59994fd940bf75bb6e39b39", "patch": "@@ -34,8 +34,8 @@ use rustc_hir as hir;\n use rustc_hir::def_id::DefId;\n use rustc_infer::infer::LateBoundRegionConversionTime;\n use rustc_middle::dep_graph::{DepKind, DepNodeIndex};\n-use rustc_middle::mir::abstract_const::NotConstEvaluatable;\n use rustc_middle::mir::interpret::ErrorHandled;\n+use rustc_middle::thir::abstract_const::NotConstEvaluatable;\n use rustc_middle::ty::fast_reject;\n use rustc_middle::ty::print::with_no_trimmed_paths;\n use rustc_middle::ty::relate::TypeRelation;"}, {"sha": "9744f4f6483c75f8fcaf72f9db79c36cbf204219", "filename": "compiler/rustc_typeck/src/check/method/suggest.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c7dbe7a830100c70d59994fd940bf75bb6e39b39/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fsuggest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7dbe7a830100c70d59994fd940bf75bb6e39b39/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fsuggest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fsuggest.rs?ref=c7dbe7a830100c70d59994fd940bf75bb6e39b39", "patch": "@@ -1655,7 +1655,7 @@ fn compute_all_traits(tcx: TyCtxt<'_>, (): ()) -> &[DefId] {\n         tcx: TyCtxt<'_>,\n         traits: &mut Vec<DefId>,\n         external_mods: &mut FxHashSet<DefId>,\n-        res: Res,\n+        res: Res<!>,\n     ) {\n         match res {\n             Res::Def(DefKind::Trait | DefKind::TraitAlias, def_id) => {"}, {"sha": "fbc7f19cb731cfe309fc419250b51aa1919032e3", "filename": "src/bootstrap/doc.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/c7dbe7a830100c70d59994fd940bf75bb6e39b39/src%2Fbootstrap%2Fdoc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7dbe7a830100c70d59994fd940bf75bb6e39b39/src%2Fbootstrap%2Fdoc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fdoc.rs?ref=c7dbe7a830100c70d59994fd940bf75bb6e39b39", "patch": "@@ -590,10 +590,18 @@ impl Step for Rustc {\n         cargo.rustdocflag(\"-Znormalize-docs\");\n         cargo.rustdocflag(\"--show-type-layout\");\n         compile::rustc_cargo(builder, &mut cargo, target);\n+        cargo.arg(\"-Zunstable-options\");\n         cargo.arg(\"-Zskip-rustdoc-fingerprint\");\n \n         // Only include compiler crates, no dependencies of those, such as `libc`.\n+        // Do link to dependencies on `docs.rs` however using `rustdoc-map`.\n         cargo.arg(\"--no-deps\");\n+        cargo.arg(\"-Zrustdoc-map\");\n+\n+        // FIXME: `-Zrustdoc-map` does not yet correctly work for transitive dependencies,\n+        // once this is no longer an issue the special case for `ena` can be removed.\n+        cargo.rustdocflag(\"--extern-html-root-url\");\n+        cargo.rustdocflag(\"ena=https://docs.rs/ena/latest/\");\n \n         // Find dependencies for top level crates.\n         let mut compiler_crates = HashSet::new();"}, {"sha": "d3da6d1ac915a3a24dd5ca14f0ef582c20042c8b", "filename": "src/ci/scripts/verify-backported-commits.sh", "status": "modified", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/c7dbe7a830100c70d59994fd940bf75bb6e39b39/src%2Fci%2Fscripts%2Fverify-backported-commits.sh", "raw_url": "https://github.com/rust-lang/rust/raw/c7dbe7a830100c70d59994fd940bf75bb6e39b39/src%2Fci%2Fscripts%2Fverify-backported-commits.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fscripts%2Fverify-backported-commits.sh?ref=c7dbe7a830100c70d59994fd940bf75bb6e39b39", "patch": "@@ -18,14 +18,6 @@ verify_backported_commits_main() {\n     exit 0\n   fi\n \n-  echo 'git: unshallowing the repository so we can check commits'\n-  git fetch \\\n-    --no-tags \\\n-    --no-recurse-submodules \\\n-    --progress \\\n-    --prune \\\n-    --unshallow\n-\n   if [[ $ci_base_branch == \"beta\" ]]; then\n     verify_cherries master \"$BETA_LIMIT\" \\\n       || exit 1"}, {"sha": "29834c82b3de32a20d02e3a54aeec942089ddc50", "filename": "src/librustdoc/clean/inline.rs", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/c7dbe7a830100c70d59994fd940bf75bb6e39b39/src%2Flibrustdoc%2Fclean%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7dbe7a830100c70d59994fd940bf75bb6e39b39/src%2Flibrustdoc%2Fclean%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Finline.rs?ref=c7dbe7a830100c70d59994fd940bf75bb6e39b39", "patch": "@@ -482,12 +482,13 @@ fn build_module(\n     // visit each node at most once.\n     for &item in cx.tcx.item_children(did).iter() {\n         if item.vis == ty::Visibility::Public {\n-            if let Some(def_id) = item.res.mod_def_id() {\n+            let res = item.res.expect_non_local();\n+            if let Some(def_id) = res.mod_def_id() {\n                 if did == def_id || !visited.insert(def_id) {\n                     continue;\n                 }\n             }\n-            if let Res::PrimTy(p) = item.res {\n+            if let Res::PrimTy(p) = res {\n                 // Primitive types can't be inlined so generate an import instead.\n                 let prim_ty = clean::PrimitiveType::from(p);\n                 items.push(clean::Item {\n@@ -500,7 +501,7 @@ fn build_module(\n                         clean::ImportSource {\n                             path: clean::Path {\n                                 global: false,\n-                                res: item.res,\n+                                res,\n                                 segments: vec![clean::PathSegment {\n                                     name: prim_ty.as_sym(),\n                                     args: clean::GenericArgs::AngleBracketed {\n@@ -515,9 +516,7 @@ fn build_module(\n                     ))),\n                     cfg: None,\n                 });\n-            } else if let Some(i) =\n-                try_inline(cx, did, None, item.res, item.ident.name, None, visited)\n-            {\n+            } else if let Some(i) = try_inline(cx, did, None, res, item.ident.name, None, visited) {\n                 items.extend(i)\n             }\n         }"}, {"sha": "e281bbc59c255c26e0b707e225d6356e5e60e6df", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 10, "deletions": 26, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/c7dbe7a830100c70d59994fd940bf75bb6e39b39/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7dbe7a830100c70d59994fd940bf75bb6e39b39/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=c7dbe7a830100c70d59994fd940bf75bb6e39b39", "patch": "@@ -164,14 +164,7 @@ impl Clean<Type> for (ty::TraitRef<'_>, &[TypeBinding]) {\n             );\n         }\n         inline::record_extern_fqn(cx, trait_ref.def_id, kind);\n-        let path = external_path(\n-            cx,\n-            cx.tcx.item_name(trait_ref.def_id),\n-            Some(trait_ref.def_id),\n-            true,\n-            bounds.to_vec(),\n-            trait_ref.substs,\n-        );\n+        let path = external_path(cx, trait_ref.def_id, true, bounds.to_vec(), trait_ref.substs);\n \n         debug!(\"ty::TraitRef\\n  subst: {:?}\\n\", trait_ref.substs);\n \n@@ -906,7 +899,7 @@ impl Clean<bool> for hir::IsAuto {\n impl Clean<Type> for hir::TraitRef<'_> {\n     fn clean(&self, cx: &mut DocContext<'_>) -> Type {\n         let path = self.path.clean(cx);\n-        resolve_type(cx, path, self.hir_ref_id)\n+        resolve_type(cx, path)\n     }\n }\n \n@@ -1164,7 +1157,7 @@ impl Clean<Item> for ty::AssocItem {\n \n fn clean_qpath(hir_ty: &hir::Ty<'_>, cx: &mut DocContext<'_>) -> Type {\n     use rustc_hir::GenericParamCount;\n-    let hir::Ty { hir_id, span, ref kind } = *hir_ty;\n+    let hir::Ty { hir_id: _, span, ref kind } = *hir_ty;\n     let qpath = match kind {\n         hir::TyKind::Path(qpath) => qpath,\n         _ => unreachable!(),\n@@ -1271,7 +1264,7 @@ fn clean_qpath(hir_ty: &hir::Ty<'_>, cx: &mut DocContext<'_>) -> Type {\n                 return cx.enter_alias(ty_substs, lt_substs, ct_substs, |cx| ty.clean(cx));\n             }\n             let path = path.clean(cx);\n-            resolve_type(cx, path, hir_id)\n+            resolve_type(cx, path)\n         }\n         hir::QPath::Resolved(Some(ref qself), ref p) => {\n             // Try to normalize `<X as Y>::T` to a type\n@@ -1292,7 +1285,7 @@ fn clean_qpath(hir_ty: &hir::Ty<'_>, cx: &mut DocContext<'_>) -> Type {\n                 name: p.segments.last().expect(\"segments were empty\").ident.name,\n                 self_def_id: Some(DefId::local(qself.hir_id.owner.local_def_index)),\n                 self_type: Box::new(qself.clean(cx)),\n-                trait_: Box::new(resolve_type(cx, trait_path, hir_id)),\n+                trait_: Box::new(resolve_type(cx, trait_path)),\n             }\n         }\n         hir::QPath::TypeRelative(ref qself, ref segment) => {\n@@ -1308,7 +1301,7 @@ fn clean_qpath(hir_ty: &hir::Ty<'_>, cx: &mut DocContext<'_>) -> Type {\n                 name: segment.ident.name,\n                 self_def_id: res.opt_def_id(),\n                 self_type: Box::new(qself.clean(cx)),\n-                trait_: Box::new(resolve_type(cx, trait_path, hir_id)),\n+                trait_: Box::new(resolve_type(cx, trait_path)),\n             }\n         }\n         hir::QPath::LangItem(..) => bug!(\"clean: requiring documentation of lang item\"),\n@@ -1448,19 +1441,12 @@ impl<'tcx> Clean<Type> for Ty<'tcx> {\n                     AdtKind::Enum => ItemType::Enum,\n                 };\n                 inline::record_extern_fqn(cx, did, kind);\n-                let path = external_path(cx, cx.tcx.item_name(did), None, false, vec![], substs);\n+                let path = external_path(cx, did, false, vec![], substs);\n                 ResolvedPath { path, did, is_generic: false }\n             }\n             ty::Foreign(did) => {\n                 inline::record_extern_fqn(cx, did, ItemType::ForeignType);\n-                let path = external_path(\n-                    cx,\n-                    cx.tcx.item_name(did),\n-                    None,\n-                    false,\n-                    vec![],\n-                    InternalSubsts::empty(),\n-                );\n+                let path = external_path(cx, did, false, vec![], InternalSubsts::empty());\n                 ResolvedPath { path, did, is_generic: false }\n             }\n             ty::Dynamic(ref obj, ref reg) => {\n@@ -1484,8 +1470,7 @@ impl<'tcx> Clean<Type> for Ty<'tcx> {\n \n                 for did in dids {\n                     let empty = cx.tcx.intern_substs(&[]);\n-                    let path =\n-                        external_path(cx, cx.tcx.item_name(did), Some(did), false, vec![], empty);\n+                    let path = external_path(cx, did, false, vec![], empty);\n                     inline::record_extern_fqn(cx, did, ItemType::Trait);\n                     let bound = PolyTrait {\n                         trait_: ResolvedPath { path, did, is_generic: false },\n@@ -1502,8 +1487,7 @@ impl<'tcx> Clean<Type> for Ty<'tcx> {\n                     });\n                 }\n \n-                let path =\n-                    external_path(cx, cx.tcx.item_name(did), Some(did), false, bindings, substs);\n+                let path = external_path(cx, did, false, bindings, substs);\n                 bounds.insert(\n                     0,\n                     PolyTrait {"}, {"sha": "b3c320555f9e53e08e030134b440432ed4722cab", "filename": "src/librustdoc/clean/types.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/c7dbe7a830100c70d59994fd940bf75bb6e39b39/src%2Flibrustdoc%2Fclean%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7dbe7a830100c70d59994fd940bf75bb6e39b39/src%2Flibrustdoc%2Fclean%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Ftypes.rs?ref=c7dbe7a830100c70d59994fd940bf75bb6e39b39", "patch": "@@ -212,7 +212,7 @@ impl ExternalCrate {\n     crate fn keywords(&self, tcx: TyCtxt<'_>) -> ThinVec<(DefId, Symbol)> {\n         let root = self.def_id();\n \n-        let as_keyword = |res: Res| {\n+        let as_keyword = |res: Res<!>| {\n             if let Res::Def(DefKind::Mod, def_id) = res {\n                 let attrs = tcx.get_attrs(def_id);\n                 let mut keyword = None;\n@@ -243,7 +243,8 @@ impl ExternalCrate {\n                         hir::ItemKind::Use(ref path, hir::UseKind::Single)\n                             if item.vis.node.is_pub() =>\n                         {\n-                            as_keyword(path.res).map(|(_, prim)| (id.def_id.to_def_id(), prim))\n+                            as_keyword(path.res.expect_non_local())\n+                                .map(|(_, prim)| (id.def_id.to_def_id(), prim))\n                         }\n                         _ => None,\n                     }\n@@ -274,7 +275,7 @@ impl ExternalCrate {\n         // Also note that this does not attempt to deal with modules tagged\n         // duplicately for the same primitive. This is handled later on when\n         // rendering by delegating everything to a hash map.\n-        let as_primitive = |res: Res| {\n+        let as_primitive = |res: Res<!>| {\n             if let Res::Def(DefKind::Mod, def_id) = res {\n                 let attrs = tcx.get_attrs(def_id);\n                 let mut prim = None;\n@@ -309,7 +310,7 @@ impl ExternalCrate {\n                         hir::ItemKind::Use(ref path, hir::UseKind::Single)\n                             if item.vis.node.is_pub() =>\n                         {\n-                            as_primitive(path.res).map(|(_, prim)| {\n+                            as_primitive(path.res.expect_non_local()).map(|(_, prim)| {\n                                 // Pretend the primitive is local.\n                                 (id.def_id.to_def_id(), prim)\n                             })\n@@ -1110,7 +1111,7 @@ impl GenericBound {\n     crate fn maybe_sized(cx: &mut DocContext<'_>) -> GenericBound {\n         let did = cx.tcx.require_lang_item(LangItem::Sized, None);\n         let empty = cx.tcx.intern_substs(&[]);\n-        let path = external_path(cx, cx.tcx.item_name(did), Some(did), false, vec![], empty);\n+        let path = external_path(cx, did, false, vec![], empty);\n         inline::record_extern_fqn(cx, did, ItemType::Trait);\n         GenericBound::TraitBound(\n             PolyTrait {"}, {"sha": "b0021d1234cd610ecdabb6494631ef10624dcffd", "filename": "src/librustdoc/clean/utils.rs", "status": "modified", "additions": 23, "deletions": 31, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/c7dbe7a830100c70d59994fd940bf75bb6e39b39/src%2Flibrustdoc%2Fclean%2Futils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7dbe7a830100c70d59994fd940bf75bb6e39b39/src%2Flibrustdoc%2Fclean%2Futils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Futils.rs?ref=c7dbe7a830100c70d59994fd940bf75bb6e39b39", "patch": "@@ -29,10 +29,6 @@ crate fn krate(cx: &mut DocContext<'_>) -> Crate {\n     let krate = cx.tcx.hir().krate();\n     let module = crate::visit_ast::RustdocVisitor::new(cx).visit(krate);\n \n-    cx.cache.deref_trait_did = cx.tcx.lang_items().deref_trait();\n-    cx.cache.deref_mut_trait_did = cx.tcx.lang_items().deref_mut_trait();\n-    cx.cache.owned_box_did = cx.tcx.lang_items().owned_box();\n-\n     let mut externs = Vec::new();\n     for &cnum in cx.tcx.crates(()).iter() {\n         externs.push(ExternalCrate { crate_num: cnum });\n@@ -97,7 +93,7 @@ crate fn krate(cx: &mut DocContext<'_>) -> Crate {\n \n fn external_generic_args(\n     cx: &mut DocContext<'_>,\n-    trait_did: Option<DefId>,\n+    did: DefId,\n     has_self: bool,\n     bindings: Vec<TypeBinding>,\n     substs: SubstsRef<'_>,\n@@ -125,42 +121,38 @@ fn external_generic_args(\n         })\n         .collect();\n \n-    match trait_did {\n-        // Attempt to sugar an external path like Fn<(A, B,), C> to Fn(A, B) -> C\n-        Some(did) if cx.tcx.fn_trait_kind_from_lang_item(did).is_some() => {\n-            assert!(ty_kind.is_some());\n-            let inputs = match ty_kind {\n-                Some(ty::Tuple(ref tys)) => tys.iter().map(|t| t.expect_ty().clean(cx)).collect(),\n-                _ => return GenericArgs::AngleBracketed { args, bindings },\n-            };\n-            let output = None;\n-            // FIXME(#20299) return type comes from a projection now\n-            // match types[1].kind {\n-            //     ty::Tuple(ref v) if v.is_empty() => None, // -> ()\n-            //     _ => Some(types[1].clean(cx))\n-            // };\n-            GenericArgs::Parenthesized { inputs, output }\n-        }\n-        _ => GenericArgs::AngleBracketed { args, bindings },\n+    if cx.tcx.fn_trait_kind_from_lang_item(did).is_some() {\n+        let inputs = match ty_kind.unwrap() {\n+            ty::Tuple(tys) => tys.iter().map(|t| t.expect_ty().clean(cx)).collect(),\n+            _ => return GenericArgs::AngleBracketed { args, bindings },\n+        };\n+        let output = None;\n+        // FIXME(#20299) return type comes from a projection now\n+        // match types[1].kind {\n+        //     ty::Tuple(ref v) if v.is_empty() => None, // -> ()\n+        //     _ => Some(types[1].clean(cx))\n+        // };\n+        GenericArgs::Parenthesized { inputs, output }\n+    } else {\n+        GenericArgs::AngleBracketed { args, bindings }\n     }\n }\n \n-// trait_did should be set to a trait's DefId if called on a TraitRef, in order to sugar\n-// from Fn<(A, B,), C> to Fn(A, B) -> C\n pub(super) fn external_path(\n     cx: &mut DocContext<'_>,\n-    name: Symbol,\n-    trait_did: Option<DefId>,\n+    did: DefId,\n     has_self: bool,\n     bindings: Vec<TypeBinding>,\n     substs: SubstsRef<'_>,\n ) -> Path {\n+    let def_kind = cx.tcx.def_kind(did);\n+    let name = cx.tcx.item_name(did);\n     Path {\n         global: false,\n-        res: Res::Err,\n+        res: Res::Def(def_kind, did),\n         segments: vec![PathSegment {\n             name,\n-            args: external_generic_args(cx, trait_did, has_self, bindings, substs),\n+            args: external_generic_args(cx, did, has_self, bindings, substs),\n         }],\n     }\n }\n@@ -409,16 +401,16 @@ crate fn print_const_expr(tcx: TyCtxt<'_>, body: hir::BodyId) -> String {\n }\n \n /// Given a type Path, resolve it to a Type using the TyCtxt\n-crate fn resolve_type(cx: &mut DocContext<'_>, path: Path, id: hir::HirId) -> Type {\n-    debug!(\"resolve_type({:?},{:?})\", path, id);\n+crate fn resolve_type(cx: &mut DocContext<'_>, path: Path) -> Type {\n+    debug!(\"resolve_type({:?})\", path);\n \n     let is_generic = match path.res {\n         Res::PrimTy(p) => return Primitive(PrimitiveType::from(p)),\n         Res::SelfTy(..) if path.segments.len() == 1 => {\n             return Generic(kw::SelfUpper);\n         }\n         Res::Def(DefKind::TyParam, _) if path.segments.len() == 1 => {\n-            return Generic(Symbol::intern(&path.whole_name()));\n+            return Generic(path.segments[0].name);\n         }\n         Res::SelfTy(..) | Res::Def(DefKind::TyParam | DefKind::AssocTy, _) => true,\n         _ => false,"}, {"sha": "bcfcc3d70395c1e3b996a50df2b1ed44af66c4da", "filename": "src/librustdoc/formats/cache.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/c7dbe7a830100c70d59994fd940bf75bb6e39b39/src%2Flibrustdoc%2Fformats%2Fcache.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7dbe7a830100c70d59994fd940bf75bb6e39b39/src%2Flibrustdoc%2Fformats%2Fcache.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fformats%2Fcache.rs?ref=c7dbe7a830100c70d59994fd940bf75bb6e39b39", "patch": "@@ -98,9 +98,6 @@ crate struct Cache {\n     stripped_mod: bool,\n \n     crate search_index: Vec<IndexItem>,\n-    crate deref_trait_did: Option<DefId>,\n-    crate deref_mut_trait_did: Option<DefId>,\n-    crate owned_box_did: Option<DefId>,\n \n     // In rare case where a structure is defined in one module but implemented\n     // in another, if the implementing module is parsed before defining module,"}, {"sha": "1f27357f6c6eaf938c219dae0a3320594cd2849d", "filename": "src/librustdoc/html/render/mod.rs", "status": "modified", "additions": 24, "deletions": 22, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/c7dbe7a830100c70d59994fd940bf75bb6e39b39/src%2Flibrustdoc%2Fhtml%2Frender%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7dbe7a830100c70d59994fd940bf75bb6e39b39/src%2Flibrustdoc%2Fhtml%2Frender%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender%2Fmod.rs?ref=c7dbe7a830100c70d59994fd940bf75bb6e39b39", "patch": "@@ -51,6 +51,7 @@ use rustc_hir::def::CtorKind;\n use rustc_hir::def_id::DefId;\n use rustc_hir::Mutability;\n use rustc_middle::middle::stability;\n+use rustc_middle::ty::TyCtxt;\n use rustc_span::symbol::{kw, sym, Symbol};\n use serde::ser::SerializeSeq;\n use serde::{Serialize, Serializer};\n@@ -1067,13 +1068,13 @@ fn render_assoc_items(\n         return;\n     }\n     if !traits.is_empty() {\n-        let deref_impl = traits\n-            .iter()\n-            .find(|t| t.inner_impl().trait_.def_id_full(cache) == cache.deref_trait_did);\n+        let deref_impl = traits.iter().find(|t| {\n+            t.inner_impl().trait_.def_id_full(cache) == cx.tcx().lang_items().deref_trait()\n+        });\n         if let Some(impl_) = deref_impl {\n-            let has_deref_mut = traits\n-                .iter()\n-                .any(|t| t.inner_impl().trait_.def_id_full(cache) == cache.deref_mut_trait_did);\n+            let has_deref_mut = traits.iter().any(|t| {\n+                t.inner_impl().trait_.def_id_full(cache) == cx.tcx().lang_items().deref_mut_trait()\n+            });\n             render_deref_methods(w, cx, impl_, containing_item, has_deref_mut);\n         }\n         let (synthetic, concrete): (Vec<&&Impl>, Vec<&&Impl>) =\n@@ -1163,7 +1164,7 @@ fn render_deref_methods(\n     }\n }\n \n-fn should_render_item(item: &clean::Item, deref_mut_: bool, cache: &Cache) -> bool {\n+fn should_render_item(item: &clean::Item, deref_mut_: bool, tcx: TyCtxt<'_>) -> bool {\n     let self_type_opt = match *item.kind {\n         clean::MethodItem(ref method, _) => method.decl.self_type(),\n         clean::TyMethodItem(ref method) => method.decl.self_type(),\n@@ -1177,7 +1178,7 @@ fn should_render_item(item: &clean::Item, deref_mut_: bool, cache: &Cache) -> bo\n                 (mutability == Mutability::Mut, false, false)\n             }\n             SelfTy::SelfExplicit(clean::ResolvedPath { did, .. }) => {\n-                (false, Some(did) == cache.owned_box_did, false)\n+                (false, Some(did) == tcx.lang_items().owned_box(), false)\n             }\n             SelfTy::SelfValue => (false, false, true),\n             _ => (false, false, false),\n@@ -1300,7 +1301,7 @@ fn render_impl(\n             && match render_mode {\n                 RenderMode::Normal => true,\n                 RenderMode::ForDeref { mut_: deref_mut_ } => {\n-                    should_render_item(&item, deref_mut_, cx.cache())\n+                    should_render_item(&item, deref_mut_, cx.tcx())\n                 }\n             };\n \n@@ -1798,13 +1799,13 @@ fn get_methods(\n     for_deref: bool,\n     used_links: &mut FxHashSet<String>,\n     deref_mut: bool,\n-    cache: &Cache,\n+    tcx: TyCtxt<'_>,\n ) -> Vec<String> {\n     i.items\n         .iter()\n         .filter_map(|item| match item.name {\n             Some(ref name) if !name.is_empty() && item.is_method() => {\n-                if !for_deref || should_render_item(item, deref_mut, cache) {\n+                if !for_deref || should_render_item(item, deref_mut, tcx) {\n                     Some(format!(\n                         \"<a href=\\\"#{}\\\">{}</a>\",\n                         get_next_url(used_links, format!(\"method.{}\", name)),\n@@ -1866,7 +1867,9 @@ fn sidebar_assoc_items(cx: &Context<'_>, out: &mut Buffer, it: &clean::Item) {\n             let mut ret = v\n                 .iter()\n                 .filter(|i| i.inner_impl().trait_.is_none())\n-                .flat_map(move |i| get_methods(i.inner_impl(), false, used_links_bor, false, cache))\n+                .flat_map(move |i| {\n+                    get_methods(i.inner_impl(), false, used_links_bor, false, cx.tcx())\n+                })\n                 .collect::<Vec<_>>();\n             if !ret.is_empty() {\n                 // We want links' order to be reproducible so we don't use unstable sort.\n@@ -1884,11 +1887,9 @@ fn sidebar_assoc_items(cx: &Context<'_>, out: &mut Buffer, it: &clean::Item) {\n         }\n \n         if v.iter().any(|i| i.inner_impl().trait_.is_some()) {\n-            if let Some(impl_) = v\n-                .iter()\n-                .filter(|i| i.inner_impl().trait_.is_some())\n-                .find(|i| i.inner_impl().trait_.def_id_full(cache) == cache.deref_trait_did)\n-            {\n+            if let Some(impl_) = v.iter().filter(|i| i.inner_impl().trait_.is_some()).find(|i| {\n+                i.inner_impl().trait_.def_id_full(cache) == cx.tcx().lang_items().deref_trait()\n+            }) {\n                 sidebar_deref_methods(cx, out, impl_, v);\n             }\n \n@@ -1986,10 +1987,9 @@ fn sidebar_deref_methods(cx: &Context<'_>, out: &mut Buffer, impl_: &Impl, v: &V\n                 }\n             }\n         }\n-        let deref_mut = v\n-            .iter()\n-            .filter(|i| i.inner_impl().trait_.is_some())\n-            .any(|i| i.inner_impl().trait_.def_id_full(c) == c.deref_mut_trait_did);\n+        let deref_mut = v.iter().filter(|i| i.inner_impl().trait_.is_some()).any(|i| {\n+            i.inner_impl().trait_.def_id_full(c) == cx.tcx().lang_items().deref_mut_trait()\n+        });\n         let inner_impl = target\n             .def_id_full(c)\n             .or_else(|| {\n@@ -2002,7 +2002,9 @@ fn sidebar_deref_methods(cx: &Context<'_>, out: &mut Buffer, impl_: &Impl, v: &V\n             let mut ret = impls\n                 .iter()\n                 .filter(|i| i.inner_impl().trait_.is_none())\n-                .flat_map(|i| get_methods(i.inner_impl(), true, &mut used_links, deref_mut, c))\n+                .flat_map(|i| {\n+                    get_methods(i.inner_impl(), true, &mut used_links, deref_mut, cx.tcx())\n+                })\n                 .collect::<Vec<_>>();\n             if !ret.is_empty() {\n                 write!("}, {"sha": "3e98ba08fb9ca376dbb5b4e4b0d307811f909e6d", "filename": "src/librustdoc/visit_lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c7dbe7a830100c70d59994fd940bf75bb6e39b39/src%2Flibrustdoc%2Fvisit_lib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7dbe7a830100c70d59994fd940bf75bb6e39b39/src%2Flibrustdoc%2Fvisit_lib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fvisit_lib.rs?ref=c7dbe7a830100c70d59994fd940bf75bb6e39b39", "patch": "@@ -67,7 +67,7 @@ impl<'a, 'tcx> LibEmbargoVisitor<'a, 'tcx> {\n         }\n     }\n \n-    fn visit_item(&mut self, res: Res) {\n+    fn visit_item(&mut self, res: Res<!>) {\n         let def_id = res.def_id();\n         let vis = self.tcx.visibility(def_id);\n         let inherited_item_level = if vis == Visibility::Public { self.prev_level } else { None };"}, {"sha": "16ab876e829ef8f25f4d82d79529e4c89c84f3ca", "filename": "src/test/rustdoc/synthetic_auto/no-redundancy.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c7dbe7a830100c70d59994fd940bf75bb6e39b39/src%2Ftest%2Frustdoc%2Fsynthetic_auto%2Fno-redundancy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7dbe7a830100c70d59994fd940bf75bb6e39b39/src%2Ftest%2Frustdoc%2Fsynthetic_auto%2Fno-redundancy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fsynthetic_auto%2Fno-redundancy.rs?ref=c7dbe7a830100c70d59994fd940bf75bb6e39b39", "patch": "@@ -10,7 +10,7 @@ where\n \n // @has no_redundancy/struct.Outer.html\n // @has - '//*[@id=\"synthetic-implementations-list\"]//*[@class=\"impl has-srclink\"]//h3[@class=\"code-header in-band\"]' \\\n-// \"impl<T> Send for Outer<T> where T: Copy + Send\"\n+// \"impl<T> Send for Outer<T> where T: Send + Copy\"\n pub struct Outer<T> {\n     inner_field: Inner<T>,\n }"}, {"sha": "916d60c0e0def2d5b54841668e15d14fa5799258", "filename": "src/test/ui/const-generics/generic_const_exprs/abstract-consts-as-cast-5.rs", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/c7dbe7a830100c70d59994fd940bf75bb6e39b39/src%2Ftest%2Fui%2Fconst-generics%2Fgeneric_const_exprs%2Fabstract-consts-as-cast-5.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7dbe7a830100c70d59994fd940bf75bb6e39b39/src%2Ftest%2Fui%2Fconst-generics%2Fgeneric_const_exprs%2Fabstract-consts-as-cast-5.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fgeneric_const_exprs%2Fabstract-consts-as-cast-5.rs?ref=c7dbe7a830100c70d59994fd940bf75bb6e39b39", "patch": "@@ -0,0 +1,11 @@\n+#![feature(generic_const_exprs)]\n+#![allow(incomplete_features)]\n+\n+fn foo<const N: u8>(a: [(); N as usize]) {\n+    bar::<{ N as usize as usize }>();\n+    //~^ error: unconstrained generic constant\n+}\n+\n+fn bar<const N: usize>() {}\n+\n+fn main() {}"}, {"sha": "d48b639dbdee33033719841f0ba082cbda0ec89a", "filename": "src/test/ui/const-generics/generic_const_exprs/abstract-consts-as-cast-5.stderr", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/c7dbe7a830100c70d59994fd940bf75bb6e39b39/src%2Ftest%2Fui%2Fconst-generics%2Fgeneric_const_exprs%2Fabstract-consts-as-cast-5.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c7dbe7a830100c70d59994fd940bf75bb6e39b39/src%2Ftest%2Fui%2Fconst-generics%2Fgeneric_const_exprs%2Fabstract-consts-as-cast-5.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fgeneric_const_exprs%2Fabstract-consts-as-cast-5.stderr?ref=c7dbe7a830100c70d59994fd940bf75bb6e39b39", "patch": "@@ -0,0 +1,10 @@\n+error: unconstrained generic constant\n+  --> $DIR/abstract-consts-as-cast-5.rs:5:11\n+   |\n+LL |     bar::<{ N as usize as usize }>();\n+   |           ^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = help: try adding a `where` bound using this expression: `where [(); { N as usize as usize }]:`\n+\n+error: aborting due to previous error\n+"}, {"sha": "9b3c32a93977906a7900691bc744ffb3c7fc4a7e", "filename": "src/test/ui/const-generics/generic_const_exprs/array-size-in-generic-struct-param.full.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c7dbe7a830100c70d59994fd940bf75bb6e39b39/src%2Ftest%2Fui%2Fconst-generics%2Fgeneric_const_exprs%2Farray-size-in-generic-struct-param.full.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c7dbe7a830100c70d59994fd940bf75bb6e39b39/src%2Ftest%2Fui%2Fconst-generics%2Fgeneric_const_exprs%2Farray-size-in-generic-struct-param.full.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fgeneric_const_exprs%2Farray-size-in-generic-struct-param.full.stderr?ref=c7dbe7a830100c70d59994fd940bf75bb6e39b39", "patch": "@@ -10,7 +10,7 @@ error: overly complex generic constant\n   --> $DIR/array-size-in-generic-struct-param.rs:19:15\n    |\n LL |     arr: [u8; CFG.arr_size],\n-   |               ^^^^^^^^^^^^ unsupported projection\n+   |               ^^^^^^^^^^^^ unsupported operation in generic constant, this may be supported in the future\n    |\n    = help: consider moving this anonymous constant into a `const` function\n "}, {"sha": "95dae4ecc0431c50915ae669d481376177510eac", "filename": "src/test/ui/const-generics/generic_const_exprs/closures.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c7dbe7a830100c70d59994fd940bf75bb6e39b39/src%2Ftest%2Fui%2Fconst-generics%2Fgeneric_const_exprs%2Fclosures.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c7dbe7a830100c70d59994fd940bf75bb6e39b39/src%2Ftest%2Fui%2Fconst-generics%2Fgeneric_const_exprs%2Fclosures.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fgeneric_const_exprs%2Fclosures.stderr?ref=c7dbe7a830100c70d59994fd940bf75bb6e39b39", "patch": "@@ -4,7 +4,7 @@ error: overly complex generic constant\n LL | fn test<const N: usize>() -> [u8; N + (|| 42)()] {}\n    |                                   ^^^^-------^^\n    |                                       |\n-   |                                       unsupported rvalue\n+   |                                       unsupported operation in generic constant, this may be supported in the future\n    |\n    = help: consider moving this anonymous constant into a `const` function\n "}, {"sha": "c9f847995223abd909743e26980a13488c04b7c3", "filename": "src/test/ui/const-generics/generic_const_exprs/let-bindings.stderr", "status": "modified", "additions": 2, "deletions": 6, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/c7dbe7a830100c70d59994fd940bf75bb6e39b39/src%2Ftest%2Fui%2Fconst-generics%2Fgeneric_const_exprs%2Flet-bindings.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c7dbe7a830100c70d59994fd940bf75bb6e39b39/src%2Ftest%2Fui%2Fconst-generics%2Fgeneric_const_exprs%2Flet-bindings.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fgeneric_const_exprs%2Flet-bindings.stderr?ref=c7dbe7a830100c70d59994fd940bf75bb6e39b39", "patch": "@@ -2,19 +2,15 @@ error: overly complex generic constant\n   --> $DIR/let-bindings.rs:6:68\n    |\n LL | fn test<const N: usize>() -> [u8; { let x = N; N + 1 }] where [u8; { let x = N; N + 1 }]: Default {\n-   |                                                                    ^^^^^^-^^^^^^^^^^^^^\n-   |                                                                          |\n-   |                                                                          unsupported statement\n+   |                                                                    ^^^^^^^^^^^^^^^^^^^^ unsupported operation in generic constant, this may be supported in the future\n    |\n    = help: consider moving this anonymous constant into a `const` function\n \n error: overly complex generic constant\n   --> $DIR/let-bindings.rs:6:35\n    |\n LL | fn test<const N: usize>() -> [u8; { let x = N; N + 1 }] where [u8; { let x = N; N + 1 }]: Default {\n-   |                                   ^^^^^^-^^^^^^^^^^^^^\n-   |                                         |\n-   |                                         unsupported statement\n+   |                                   ^^^^^^^^^^^^^^^^^^^^ unsupported operation in generic constant, this may be supported in the future\n    |\n    = help: consider moving this anonymous constant into a `const` function\n "}, {"sha": "c0404d35b08879d5ae9ddb009f38e0b3d1a9b0ce", "filename": "src/test/ui/const-generics/generic_const_exprs/unify-op-with-fn-call.rs", "status": "added", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/c7dbe7a830100c70d59994fd940bf75bb6e39b39/src%2Ftest%2Fui%2Fconst-generics%2Fgeneric_const_exprs%2Funify-op-with-fn-call.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7dbe7a830100c70d59994fd940bf75bb6e39b39/src%2Ftest%2Fui%2Fconst-generics%2Fgeneric_const_exprs%2Funify-op-with-fn-call.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fgeneric_const_exprs%2Funify-op-with-fn-call.rs?ref=c7dbe7a830100c70d59994fd940bf75bb6e39b39", "patch": "@@ -0,0 +1,35 @@\n+#![feature(generic_const_exprs, adt_const_params, const_trait_impl)]\n+#![allow(incomplete_features)]\n+\n+// test `N + N` unifies with explicit function calls for non-builtin-types\n+#[derive(PartialEq, Eq)]\n+struct Foo(u8);\n+\n+impl const std::ops::Add for Foo {\n+    type Output = Self;\n+\n+    fn add(self, rhs: Self) -> Self::Output {\n+        self\n+    }\n+}\n+\n+struct Evaluatable<const N: Foo>;\n+\n+fn foo<const N: Foo>(a: Evaluatable<{ N + N }>) {\n+    bar::<{ std::ops::Add::add(N, N) }>();\n+}\n+\n+fn bar<const N: Foo>() {}\n+\n+// test that `N + N` unifies with explicit function calls for builin-types\n+struct Evaluatable2<const N: usize>;\n+\n+fn foo2<const N: usize>(a: Evaluatable2<{ N + N }>) {\n+    bar2::<{ std::ops::Add::add(N, N) }>();\n+    //~^ error: unconstrained generic constant\n+    // FIXME(generic_const_exprs) make this not an error\n+}\n+\n+fn bar2<const N: usize>() {}\n+\n+fn main() {}"}, {"sha": "d18c7916f5f6f3336f611ddb4755db2b308583a7", "filename": "src/test/ui/const-generics/generic_const_exprs/unify-op-with-fn-call.stderr", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/c7dbe7a830100c70d59994fd940bf75bb6e39b39/src%2Ftest%2Fui%2Fconst-generics%2Fgeneric_const_exprs%2Funify-op-with-fn-call.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c7dbe7a830100c70d59994fd940bf75bb6e39b39/src%2Ftest%2Fui%2Fconst-generics%2Fgeneric_const_exprs%2Funify-op-with-fn-call.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fgeneric_const_exprs%2Funify-op-with-fn-call.stderr?ref=c7dbe7a830100c70d59994fd940bf75bb6e39b39", "patch": "@@ -0,0 +1,10 @@\n+error: unconstrained generic constant\n+  --> $DIR/unify-op-with-fn-call.rs:28:12\n+   |\n+LL |     bar2::<{ std::ops::Add::add(N, N) }>();\n+   |            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = help: try adding a `where` bound using this expression: `where [(); { std::ops::Add::add(N, N) }]:`\n+\n+error: aborting due to previous error\n+"}, {"sha": "3da91b19a5ed95c95dc85830599f0972d10a7de3", "filename": "src/test/ui/const-generics/generic_const_exprs/unused_expr.stderr", "status": "modified", "additions": 3, "deletions": 9, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/c7dbe7a830100c70d59994fd940bf75bb6e39b39/src%2Ftest%2Fui%2Fconst-generics%2Fgeneric_const_exprs%2Funused_expr.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c7dbe7a830100c70d59994fd940bf75bb6e39b39/src%2Ftest%2Fui%2Fconst-generics%2Fgeneric_const_exprs%2Funused_expr.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fgeneric_const_exprs%2Funused_expr.stderr?ref=c7dbe7a830100c70d59994fd940bf75bb6e39b39", "patch": "@@ -2,29 +2,23 @@ error: overly complex generic constant\n   --> $DIR/unused_expr.rs:4:34\n    |\n LL | fn add<const N: usize>() -> [u8; { N + 1; 5 }] {\n-   |                                  ^^-----^^^^^\n-   |                                    |\n-   |                                    dead code\n+   |                                  ^^^^^^^^^^^^ unsupported operation in generic constant, this may be supported in the future\n    |\n    = help: consider moving this anonymous constant into a `const` function\n \n error: overly complex generic constant\n   --> $DIR/unused_expr.rs:9:34\n    |\n LL | fn div<const N: usize>() -> [u8; { N / 1; 5 }] {\n-   |                                  ^^-----^^^^^\n-   |                                    |\n-   |                                    dead code\n+   |                                  ^^^^^^^^^^^^ unsupported operation in generic constant, this may be supported in the future\n    |\n    = help: consider moving this anonymous constant into a `const` function\n \n error: overly complex generic constant\n   --> $DIR/unused_expr.rs:16:38\n    |\n LL | fn fn_call<const N: usize>() -> [u8; { foo(N); 5 }] {\n-   |                                      ^^------^^^^^\n-   |                                        |\n-   |                                        dead code\n+   |                                      ^^^^^^^^^^^^^ unsupported operation in generic constant, this may be supported in the future\n    |\n    = help: consider moving this anonymous constant into a `const` function\n "}, {"sha": "d7b52063dc4db24c8bfea069cb12a9a6b54a15c3", "filename": "src/test/ui/const-generics/issues/issue-67375.full.stderr", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c7dbe7a830100c70d59994fd940bf75bb6e39b39/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-67375.full.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c7dbe7a830100c70d59994fd940bf75bb6e39b39/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-67375.full.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-67375.full.stderr?ref=c7dbe7a830100c70d59994fd940bf75bb6e39b39", "patch": "@@ -2,9 +2,9 @@ error: overly complex generic constant\n   --> $DIR/issue-67375.rs:7:17\n    |\n LL |     inner: [(); { [|_: &T| {}; 0].len() }],\n-   |                 ^^^----------^^^^^^^^^^^^\n-   |                    |\n-   |                    unsupported rvalue\n+   |                 ^^---------------^^^^^^^^\n+   |                   |\n+   |                   unsupported operation in generic constant\n    |\n    = help: consider moving this anonymous constant into a `const` function\n "}, {"sha": "fe0351a829220368f24a0aaab9d6f0e40d93f76f", "filename": "src/test/ui/const-generics/issues/issue-67945-2.full.stderr", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/c7dbe7a830100c70d59994fd940bf75bb6e39b39/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-67945-2.full.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c7dbe7a830100c70d59994fd940bf75bb6e39b39/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-67945-2.full.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-67945-2.full.stderr?ref=c7dbe7a830100c70d59994fd940bf75bb6e39b39", "patch": "@@ -5,11 +5,10 @@ LL |       A: [(); {\n    |  _____________^\n LL | |\n LL | |         let x: Option<Box<Self>> = None;\n-   | |                                    ---- unsupported rvalue\n LL | |\n LL | |         0\n LL | |     }],\n-   | |_____^\n+   | |_____^ unsupported operation in generic constant, this may be supported in the future\n    |\n    = help: consider moving this anonymous constant into a `const` function\n "}, {"sha": "27c135cb7cf82abd5d9a41d7d61576ead8a8ab15", "filename": "src/test/ui/generic-associated-types/impl_bounds.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c7dbe7a830100c70d59994fd940bf75bb6e39b39/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fimpl_bounds.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7dbe7a830100c70d59994fd940bf75bb6e39b39/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fimpl_bounds.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fimpl_bounds.rs?ref=c7dbe7a830100c70d59994fd940bf75bb6e39b39", "patch": "@@ -15,7 +15,7 @@ impl<T> Foo for Fooy<T> {\n     type A<'a> where Self: 'static = (&'a ());\n     //~^ ERROR the parameter type `T` may not live long enough\n     type B<'a, 'b> where 'b: 'a = (&'a(), &'b ());\n-    //~^ ERROR lifetime bound not satisfied\n+    //~^ ERROR `impl` associated type\n     //~| ERROR lifetime bound not satisfied\n     type C where Self: Copy = String;\n     //~^ ERROR the trait bound `T: Copy` is not satisfied"}, {"sha": "73415e0faac88898b8a28fe0958b0154206150f4", "filename": "src/test/ui/generic-associated-types/impl_bounds.stderr", "status": "modified", "additions": 6, "deletions": 14, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/c7dbe7a830100c70d59994fd940bf75bb6e39b39/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fimpl_bounds.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c7dbe7a830100c70d59994fd940bf75bb6e39b39/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fimpl_bounds.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fimpl_bounds.stderr?ref=c7dbe7a830100c70d59994fd940bf75bb6e39b39", "patch": "@@ -5,24 +5,16 @@ LL |     type A<'a> where Self: 'static = (&'a ());\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n    = help: consider adding an explicit lifetime bound `T: 'static`...\n-   = note: ...so that the type `Fooy<T>` will meet its required lifetime bounds\n+   = note: ...so that the definition in impl matches the definition from the trait\n \n-error[E0478]: lifetime bound not satisfied\n+error: `impl` associated type signature for `B` doesn't match `trait` associated type signature\n   --> $DIR/impl_bounds.rs:17:5\n    |\n+LL |     type B<'a, 'b> where 'a: 'b;\n+   |     ---------------------------- expected\n+...\n LL |     type B<'a, 'b> where 'b: 'a = (&'a(), &'b ());\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n-   |\n-note: lifetime parameter instantiated with the lifetime `'b` as defined on the associated item at 17:16\n-  --> $DIR/impl_bounds.rs:17:16\n-   |\n-LL |     type B<'a, 'b> where 'b: 'a = (&'a(), &'b ());\n-   |                ^^\n-note: but lifetime parameter must outlive the lifetime `'a` as defined on the associated item at 17:12\n-  --> $DIR/impl_bounds.rs:17:12\n-   |\n-LL |     type B<'a, 'b> where 'b: 'a = (&'a(), &'b ());\n-   |            ^^\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ found\n \n error[E0478]: lifetime bound not satisfied\n   --> $DIR/impl_bounds.rs:17:5"}, {"sha": "e1ff772921104a1cc506b48eb784dfdec5fa03f1", "filename": "src/test/ui/generic-associated-types/issue-86787.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c7dbe7a830100c70d59994fd940bf75bb6e39b39/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fissue-86787.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c7dbe7a830100c70d59994fd940bf75bb6e39b39/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fissue-86787.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fissue-86787.stderr?ref=c7dbe7a830100c70d59994fd940bf75bb6e39b39", "patch": "@@ -9,7 +9,7 @@ LL | |     <Left as HasChildrenOf>::T: 'a,\n LL | |     <Right as HasChildrenOf>::T: 'a\n    | |                                    - help: consider adding a where clause: `, <Left as HasChildrenOf>::T: 'a`\n LL | |     = Either<&'a Left::T, &'a Right::T>;\n-   | |________________________________________^ ...so that the type `<Left as HasChildrenOf>::T` will meet its required lifetime bounds\n+   | |________________________________________^ ...so that the definition in impl matches the definition from the trait\n \n error[E0309]: the associated type `<Right as HasChildrenOf>::T` may not live long enough\n   --> $DIR/issue-86787.rs:23:5\n@@ -22,7 +22,7 @@ LL | |     <Left as HasChildrenOf>::T: 'a,\n LL | |     <Right as HasChildrenOf>::T: 'a\n    | |                                    - help: consider adding a where clause: `, <Right as HasChildrenOf>::T: 'a`\n LL | |     = Either<&'a Left::T, &'a Right::T>;\n-   | |________________________________________^ ...so that the type `<Right as HasChildrenOf>::T` will meet its required lifetime bounds\n+   | |________________________________________^ ...so that the definition in impl matches the definition from the trait\n \n error: aborting due to 2 previous errors\n "}, {"sha": "ad9f2e3e4ec4a8273d8248c7d7ec43c0d6b6e79c", "filename": "src/test/ui/generic-associated-types/missing-where-clause-on-trait.rs", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/c7dbe7a830100c70d59994fd940bf75bb6e39b39/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fmissing-where-clause-on-trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7dbe7a830100c70d59994fd940bf75bb6e39b39/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fmissing-where-clause-on-trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fmissing-where-clause-on-trait.rs?ref=c7dbe7a830100c70d59994fd940bf75bb6e39b39", "patch": "@@ -0,0 +1,13 @@\n+// check-fail\n+\n+#![feature(generic_associated_types)]\n+\n+trait Foo {\n+    type Assoc<'a, 'b>;\n+}\n+impl Foo for () {\n+    type Assoc<'a, 'b> where 'a: 'b = ();\n+    //~^ `impl` associated type\n+}\n+\n+fn main() {}"}, {"sha": "0e183c8d69a4c0e6a531ba034b7bddfef4036156", "filename": "src/test/ui/generic-associated-types/missing-where-clause-on-trait.stderr", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/c7dbe7a830100c70d59994fd940bf75bb6e39b39/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fmissing-where-clause-on-trait.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c7dbe7a830100c70d59994fd940bf75bb6e39b39/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fmissing-where-clause-on-trait.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fmissing-where-clause-on-trait.stderr?ref=c7dbe7a830100c70d59994fd940bf75bb6e39b39", "patch": "@@ -0,0 +1,11 @@\n+error: `impl` associated type signature for `Assoc` doesn't match `trait` associated type signature\n+  --> $DIR/missing-where-clause-on-trait.rs:9:5\n+   |\n+LL |     type Assoc<'a, 'b>;\n+   |     ------------------- expected\n+...\n+LL |     type Assoc<'a, 'b> where 'a: 'b = ();\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ found\n+\n+error: aborting due to previous error\n+"}, {"sha": "3a94f47298390a22ef1fc51459b443691fffc70c", "filename": "src/tools/clippy/clippy_utils/src/lib.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c7dbe7a830100c70d59994fd940bf75bb6e39b39/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7dbe7a830100c70d59994fd940bf75bb6e39b39/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Flib.rs?ref=c7dbe7a830100c70d59994fd940bf75bb6e39b39", "patch": "@@ -520,7 +520,7 @@ pub fn path_to_res(cx: &LateContext<'_>, path: &[&str]) -> Res {\n             }\n         };\n     }\n-    fn item_child_by_name<'tcx>(tcx: TyCtxt<'tcx>, def_id: DefId, name: &str) -> Option<&'tcx Export<HirId>> {\n+    fn item_child_by_name<'tcx>(tcx: TyCtxt<'tcx>, def_id: DefId, name: &str) -> Option<&'tcx Export> {\n         tcx.item_children(def_id)\n             .iter()\n             .find(|item| item.ident.name.as_str() == name)\n@@ -557,7 +557,7 @@ pub fn path_to_res(cx: &LateContext<'_>, path: &[&str]) -> Res {\n                 None\n             }\n         });\n-    try_res!(last).res\n+    try_res!(last).res.expect_non_local()\n }\n \n /// Convenience function to get the `DefId` of a trait by path."}]}