{"sha": "7fdd058c609e9cc727b44a63fd4d9d1ad3cef206", "node_id": "MDY6Q29tbWl0NzI0NzEyOjdmZGQwNThjNjA5ZTljYzcyN2I0NGE2M2ZkNGQ5ZDFhZDNjZWYyMDY=", "commit": {"author": {"name": "bjorn3", "email": "bjorn3@users.noreply.github.com", "date": "2019-07-27T15:48:24Z"}, "committer": {"name": "bjorn3", "email": "bjorn3@users.noreply.github.com", "date": "2019-07-29T09:03:55Z"}, "message": "Emulate some simd intrinsics", "tree": {"sha": "1306021ca8272bdb8f87332d308712e20474872e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1306021ca8272bdb8f87332d308712e20474872e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7fdd058c609e9cc727b44a63fd4d9d1ad3cef206", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7fdd058c609e9cc727b44a63fd4d9d1ad3cef206", "html_url": "https://github.com/rust-lang/rust/commit/7fdd058c609e9cc727b44a63fd4d9d1ad3cef206", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7fdd058c609e9cc727b44a63fd4d9d1ad3cef206/comments", "author": {"login": "bjorn3", "id": 17426603, "node_id": "MDQ6VXNlcjE3NDI2NjAz", "avatar_url": "https://avatars.githubusercontent.com/u/17426603?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bjorn3", "html_url": "https://github.com/bjorn3", "followers_url": "https://api.github.com/users/bjorn3/followers", "following_url": "https://api.github.com/users/bjorn3/following{/other_user}", "gists_url": "https://api.github.com/users/bjorn3/gists{/gist_id}", "starred_url": "https://api.github.com/users/bjorn3/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bjorn3/subscriptions", "organizations_url": "https://api.github.com/users/bjorn3/orgs", "repos_url": "https://api.github.com/users/bjorn3/repos", "events_url": "https://api.github.com/users/bjorn3/events{/privacy}", "received_events_url": "https://api.github.com/users/bjorn3/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bjorn3", "id": 17426603, "node_id": "MDQ6VXNlcjE3NDI2NjAz", "avatar_url": "https://avatars.githubusercontent.com/u/17426603?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bjorn3", "html_url": "https://github.com/bjorn3", "followers_url": "https://api.github.com/users/bjorn3/followers", "following_url": "https://api.github.com/users/bjorn3/following{/other_user}", "gists_url": "https://api.github.com/users/bjorn3/gists{/gist_id}", "starred_url": "https://api.github.com/users/bjorn3/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bjorn3/subscriptions", "organizations_url": "https://api.github.com/users/bjorn3/orgs", "repos_url": "https://api.github.com/users/bjorn3/repos", "events_url": "https://api.github.com/users/bjorn3/events{/privacy}", "received_events_url": "https://api.github.com/users/bjorn3/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3f7660788042796773fd12e80dccd9af997f7242", "url": "https://api.github.com/repos/rust-lang/rust/commits/3f7660788042796773fd12e80dccd9af997f7242", "html_url": "https://github.com/rust-lang/rust/commit/3f7660788042796773fd12e80dccd9af997f7242"}], "stats": {"total": 143, "additions": 137, "deletions": 6}, "files": [{"sha": "7deaddd7df7c76de5c006672676c652c601c91df", "filename": "example/std_example.rs", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/7fdd058c609e9cc727b44a63fd4d9d1ad3cef206/example%2Fstd_example.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7fdd058c609e9cc727b44a63fd4d9d1ad3cef206/example%2Fstd_example.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/example%2Fstd_example.rs?ref=7fdd058c609e9cc727b44a63fd4d9d1ad3cef206", "patch": "@@ -3,6 +3,7 @@\n use std::io::Write;\n use std::intrinsics;\n \n+\n fn main() {\n     let _ = ::std::iter::repeat('a' as u8).take(10).collect::<Vec<_>>();\n     let stderr = ::std::io::stderr();\n@@ -43,6 +44,21 @@ fn main() {\n     assert_eq!(0xFEDCBA987654321123456789ABCDEFu128 >> 64, 0xFEDCBA98765432u128);\n     assert_eq!(0xFEDCBA987654321123456789ABCDEFu128 as i128 >> 64, 0xFEDCBA98765432i128);\n     assert_eq!(353985398u128 * 932490u128, 330087843781020u128);\n+\n+    unsafe {\n+        test_simd();\n+    }\n+}\n+\n+#[target_feature(enable = \"sse2\")]\n+unsafe fn test_simd() {\n+    use std::arch::x86_64::*;\n+\n+    let x = _mm_setzero_si128();\n+    let y = _mm_set1_epi16(7);\n+    let or = _mm_or_si128(x, y);\n+\n+    assert_eq!(std::mem::transmute::<_, [u16; 8]>(or), [7, 7, 7, 7, 7, 7, 7, 7]);\n }\n \n #[derive(PartialEq)]"}, {"sha": "8efeb0b4acc391bae54e74c9ae2f7909b06d2a51", "filename": "src/intrinsics.rs", "status": "modified", "additions": 121, "deletions": 6, "changes": 127, "blob_url": "https://github.com/rust-lang/rust/blob/7fdd058c609e9cc727b44a63fd4d9d1ad3cef206/src%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7fdd058c609e9cc727b44a63fd4d9d1ad3cef206/src%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fintrinsics.rs?ref=7fdd058c609e9cc727b44a63fd4d9d1ad3cef206", "patch": "@@ -116,6 +116,64 @@ macro_rules! atomic_minmax {\n     };\n }\n \n+fn lane_type_and_count<'tcx>(\n+    fx: &FunctionCx<'_, 'tcx, impl Backend>,\n+    layout: TyLayout<'tcx>,\n+    intrinsic: &str,\n+) -> (TyLayout<'tcx>, usize) {\n+    let lane_count = match layout.fields {\n+        layout::FieldPlacement::Array { stride: _, count } => usize::try_from(count).unwrap(),\n+        _ => panic!(\"Non vector type {:?} passed to or returned from simd_* intrinsic {}\", layout.ty, intrinsic),\n+    };\n+    let lane_layout = layout.field(fx, 0);\n+    (lane_layout, lane_count)\n+}\n+\n+fn simd_for_each_lane<'tcx, B: Backend>(\n+    fx: &mut FunctionCx<'_, 'tcx, B>,\n+    intrinsic: &str,\n+    x: CValue<'tcx>,\n+    y: CValue<'tcx>,\n+    ret: CPlace<'tcx>,\n+    f: impl Fn(&mut FunctionCx<'_, 'tcx, B>, TyLayout<'tcx>, TyLayout<'tcx>, Value, Value) -> CValue<'tcx>,\n+) {\n+    assert_eq!(x.layout(), y.layout());\n+    let layout = x.layout();\n+\n+    let (lane_layout, lane_count) = lane_type_and_count(fx, layout, intrinsic);\n+    let (ret_lane_layout, ret_lane_count) = lane_type_and_count(fx, ret.layout(), intrinsic);\n+    assert_eq!(lane_count, ret_lane_count);\n+\n+    for lane in 0..lane_count {\n+        let lane = mir::Field::new(lane);\n+        let x_lane = x.value_field(fx, lane).load_scalar(fx);\n+        let y_lane = y.value_field(fx, lane).load_scalar(fx);\n+\n+        let res_lane = f(fx, lane_layout, ret_lane_layout, x_lane, y_lane);\n+\n+        ret.place_field(fx, lane).write_cvalue(fx, res_lane);\n+    }\n+}\n+\n+macro_rules! simd_binop {\n+    ($fx:expr, $intrinsic:expr, $op:ident($x:ident, $y:ident) -> $ret:ident) => {\n+        simd_for_each_lane($fx, $intrinsic, $x, $y, $ret, |fx, _lane_layout, ret_lane_layout, x_lane, y_lane| {\n+            let res_lane = fx.bcx.ins().$op(x_lane, y_lane);\n+            CValue::by_val(res_lane, ret_lane_layout)\n+        });\n+    };\n+    ($fx:expr, $intrinsic:expr, $op_u:ident|$op_s:ident($x:ident, $y:ident) -> $ret:ident) => {\n+        simd_for_each_lane($fx, $intrinsic, $x, $y, $ret, |fx, lane_layout, ret_lane_layout, x_lane, y_lane| {\n+            let res_lane = match lane_layout.ty.sty {\n+                ty::Uint(_) => fx.bcx.ins().$op_u(x_lane, y_lane),\n+                ty::Int(_) => fx.bcx.ins().$op_s(x_lane, y_lane),\n+                _ => unreachable!(\"{:?}\", lane_layout.ty),\n+            };\n+            CValue::by_val(res_lane, ret_lane_layout)\n+        });\n+    };\n+}\n+\n pub fn codegen_intrinsic_call<'a, 'tcx: 'a>(\n     fx: &mut FunctionCx<'a, 'tcx, impl Backend>,\n     def_id: DefId,\n@@ -180,12 +238,6 @@ pub fn codegen_intrinsic_call<'a, 'tcx: 'a>(\n         cosf64(flt) -> f64 => cos,\n         tanf32(flt) -> f32 => tanf,\n         tanf64(flt) -> f64 => tan,\n-\n-        // minmax\n-        minnumf32(a, b) -> f32 => fminf,\n-        minnumf64(a, b) -> f64 => fmin,\n-        maxnumf32(a, b) -> f32 => fmaxf,\n-        maxnumf64(a, b) -> f64 => fmax,\n     }\n \n     intrinsic_match! {\n@@ -675,6 +727,69 @@ pub fn codegen_intrinsic_call<'a, 'tcx: 'a>(\n         _ if intrinsic.starts_with(\"atomic_umin\"), <T> (v ptr, v src) {\n             atomic_minmax!(fx, IntCC::UnsignedLessThan, <T> (ptr, src) -> ret);\n         };\n+\n+        minnumf32, (v a, v b) {\n+            let val = fx.bcx.ins().fmin(a, b);\n+            let val = CValue::by_val(val, fx.layout_of(fx.tcx.types.f32));\n+            ret.write_cvalue(fx, val);\n+        };\n+        minnumf64, (v a, v b) {\n+            let val = fx.bcx.ins().fmin(a, b);\n+            let val = CValue::by_val(val, fx.layout_of(fx.tcx.types.f64));\n+            ret.write_cvalue(fx, val);\n+        };\n+        maxnumf32, (v a, v b) {\n+            let val = fx.bcx.ins().fmax(a, b);\n+            let val = CValue::by_val(val, fx.layout_of(fx.tcx.types.f32));\n+            ret.write_cvalue(fx, val);\n+        };\n+        maxnumf64, (v a, v b) {\n+            let val = fx.bcx.ins().fmax(a, b);\n+            let val = CValue::by_val(val, fx.layout_of(fx.tcx.types.f64));\n+            ret.write_cvalue(fx, val);\n+        };\n+\n+        simd_cast, (c x) {\n+            ret.write_cvalue(fx, x.unchecked_cast_to(ret.layout()));\n+        };\n+\n+        simd_add, (c x, c y) {\n+            simd_binop!(fx, intrinsic, iadd(x, y) -> ret);\n+        };\n+        simd_sub, (c x, c y) {\n+            simd_binop!(fx, intrinsic, isub(x, y) -> ret);\n+        };\n+        simd_mul, (c x, c y) {\n+            simd_binop!(fx, intrinsic, imul(x, y) -> ret);\n+        };\n+        simd_div, (c x, c y) {\n+            simd_binop!(fx, intrinsic, udiv|sdiv(x, y) -> ret);\n+        };\n+        simd_rem, (c x, c y) {\n+            simd_binop!(fx, intrinsic, urem|srem(x, y) -> ret);\n+        };\n+        simd_shl, (c x, c y) {\n+            simd_binop!(fx, intrinsic, ishl(x, y) -> ret);\n+        };\n+        simd_shr, (c x, c y) {\n+            simd_binop!(fx, intrinsic, ushr|sshr(x, y) -> ret);\n+        };\n+        simd_and, (c x, c y) {\n+            simd_binop!(fx, intrinsic, band(x, y) -> ret);\n+        };\n+        simd_or, (c x, c y) {\n+            simd_binop!(fx, intrinsic, bor(x, y) -> ret);\n+        };\n+        simd_bxor, (c x, c y) {\n+            simd_binop!(fx, intrinsic, bxor(x, y) -> ret);\n+        };\n+\n+        simd_fmin, (c x, c y) {\n+            simd_binop!(fx, intrinsic, fmin(x, y) -> ret);\n+        };\n+        simd_fmax, (c x, c y) {\n+            simd_binop!(fx, intrinsic, fmax(x, y) -> ret);\n+        };\n     }\n \n     if let Some((_, dest)) = destination {"}]}