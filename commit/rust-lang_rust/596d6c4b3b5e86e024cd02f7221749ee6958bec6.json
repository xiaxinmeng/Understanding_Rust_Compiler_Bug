{"sha": "596d6c4b3b5e86e024cd02f7221749ee6958bec6", "node_id": "MDY6Q29tbWl0NzI0NzEyOjU5NmQ2YzRiM2I1ZTg2ZTAyNGNkMDJmNzIyMTc0OWVlNjk1OGJlYzY=", "commit": {"author": {"name": "Matthew Jasper", "email": "mjjasper1@gmail.com", "date": "2020-07-24T20:59:43Z"}, "committer": {"name": "Matthew Jasper", "email": "mjjasper1@gmail.com", "date": "2020-10-06T10:19:31Z"}, "message": "Avoid cycle with projections from object types\n\nNormalizing `<dyn Iterator<Item = ()> as Iterator>::Item` no longer\nrequires selecting `dyn Iterator<Item = ()>: Iterator`. This was\npreviously worked around by using a special type-folder to normalize\nthings.", "tree": {"sha": "0b4424c4e35cf9bf356ea0637d3d603ab4d26795", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0b4424c4e35cf9bf356ea0637d3d603ab4d26795"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/596d6c4b3b5e86e024cd02f7221749ee6958bec6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/596d6c4b3b5e86e024cd02f7221749ee6958bec6", "html_url": "https://github.com/rust-lang/rust/commit/596d6c4b3b5e86e024cd02f7221749ee6958bec6", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/596d6c4b3b5e86e024cd02f7221749ee6958bec6/comments", "author": {"login": "matthewjasper", "id": 20113453, "node_id": "MDQ6VXNlcjIwMTEzNDUz", "avatar_url": "https://avatars.githubusercontent.com/u/20113453?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matthewjasper", "html_url": "https://github.com/matthewjasper", "followers_url": "https://api.github.com/users/matthewjasper/followers", "following_url": "https://api.github.com/users/matthewjasper/following{/other_user}", "gists_url": "https://api.github.com/users/matthewjasper/gists{/gist_id}", "starred_url": "https://api.github.com/users/matthewjasper/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matthewjasper/subscriptions", "organizations_url": "https://api.github.com/users/matthewjasper/orgs", "repos_url": "https://api.github.com/users/matthewjasper/repos", "events_url": "https://api.github.com/users/matthewjasper/events{/privacy}", "received_events_url": "https://api.github.com/users/matthewjasper/received_events", "type": "User", "site_admin": false}, "committer": {"login": "matthewjasper", "id": 20113453, "node_id": "MDQ6VXNlcjIwMTEzNDUz", "avatar_url": "https://avatars.githubusercontent.com/u/20113453?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matthewjasper", "html_url": "https://github.com/matthewjasper", "followers_url": "https://api.github.com/users/matthewjasper/followers", "following_url": "https://api.github.com/users/matthewjasper/following{/other_user}", "gists_url": "https://api.github.com/users/matthewjasper/gists{/gist_id}", "starred_url": "https://api.github.com/users/matthewjasper/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matthewjasper/subscriptions", "organizations_url": "https://api.github.com/users/matthewjasper/orgs", "repos_url": "https://api.github.com/users/matthewjasper/repos", "events_url": "https://api.github.com/users/matthewjasper/events{/privacy}", "received_events_url": "https://api.github.com/users/matthewjasper/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "34e5a4992c920ce9e68c333621f3d4c967c012c4", "url": "https://api.github.com/repos/rust-lang/rust/commits/34e5a4992c920ce9e68c333621f3d4c967c012c4", "html_url": "https://github.com/rust-lang/rust/commit/34e5a4992c920ce9e68c333621f3d4c967c012c4"}], "stats": {"total": 543, "additions": 193, "deletions": 350}, "files": [{"sha": "71a4623cd629b08f8129c97e467a3e737fe32b8d", "filename": "compiler/rustc_trait_selection/src/traits/project.rs", "status": "modified", "additions": 77, "deletions": 130, "changes": 207, "blob_url": "https://github.com/rust-lang/rust/blob/596d6c4b3b5e86e024cd02f7221749ee6958bec6/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fproject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/596d6c4b3b5e86e024cd02f7221749ee6958bec6/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fproject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fproject.rs?ref=596d6c4b3b5e86e024cd02f7221749ee6958bec6", "patch": "@@ -1,6 +1,5 @@\n //! Code for projecting associated types out of trait references.\n \n-use super::elaborate_predicates;\n use super::specialization_graph;\n use super::translate_substs;\n use super::util;\n@@ -53,13 +52,16 @@ pub enum ProjectionTyError<'tcx> {\n \n #[derive(PartialEq, Eq, Debug)]\n enum ProjectionTyCandidate<'tcx> {\n-    // from a where-clause in the env or object type\n+    /// From a where-clause in the env or object type\n     ParamEnv(ty::PolyProjectionPredicate<'tcx>),\n \n-    // from the definition of `Trait` when you have something like <<A as Trait>::B as Trait2>::C\n+    /// From the definition of `Trait` when you have something like <<A as Trait>::B as Trait2>::C\n     TraitDef(ty::PolyProjectionPredicate<'tcx>),\n \n-    // from a \"impl\" (or a \"pseudo-impl\" returned by select)\n+    /// Bounds specified on an object type\n+    Object(ty::PolyProjectionPredicate<'tcx>),\n+\n+    /// From a \"impl\" (or a \"pseudo-impl\" returned by select)\n     Select(Selection<'tcx>),\n }\n \n@@ -561,14 +563,6 @@ fn opt_normalize_projection_type<'a, 'b, 'tcx>(\n             } else {\n                 obligations.extend(ty.obligations);\n             }\n-\n-            obligations.push(get_paranoid_cache_value_obligation(\n-                infcx,\n-                param_env,\n-                projection_ty,\n-                cause,\n-                depth,\n-            ));\n             return Ok(Some(ty.value));\n         }\n         Err(ProjectionCacheEntry::Error) => {\n@@ -703,45 +697,6 @@ fn prune_cache_value_obligations<'a, 'tcx>(\n     NormalizedTy { value: result.value, obligations }\n }\n \n-/// Whenever we give back a cache result for a projection like `<T as\n-/// Trait>::Item ==> X`, we *always* include the obligation to prove\n-/// that `T: Trait` (we may also include some other obligations). This\n-/// may or may not be necessary -- in principle, all the obligations\n-/// that must be proven to show that `T: Trait` were also returned\n-/// when the cache was first populated. But there are some vague concerns,\n-/// and so we take the precautionary measure of including `T: Trait` in\n-/// the result:\n-///\n-/// Concern #1. The current setup is fragile. Perhaps someone could\n-/// have failed to prove the concerns from when the cache was\n-/// populated, but also not have used a snapshot, in which case the\n-/// cache could remain populated even though `T: Trait` has not been\n-/// shown. In this case, the \"other code\" is at fault -- when you\n-/// project something, you are supposed to either have a snapshot or\n-/// else prove all the resulting obligations -- but it's still easy to\n-/// get wrong.\n-///\n-/// Concern #2. Even within the snapshot, if those original\n-/// obligations are not yet proven, then we are able to do projections\n-/// that may yet turn out to be wrong. This *may* lead to some sort\n-/// of trouble, though we don't have a concrete example of how that\n-/// can occur yet. But it seems risky at best.\n-fn get_paranoid_cache_value_obligation<'a, 'tcx>(\n-    infcx: &'a InferCtxt<'a, 'tcx>,\n-    param_env: ty::ParamEnv<'tcx>,\n-    projection_ty: ty::ProjectionTy<'tcx>,\n-    cause: ObligationCause<'tcx>,\n-    depth: usize,\n-) -> PredicateObligation<'tcx> {\n-    let trait_ref = projection_ty.trait_ref(infcx.tcx).to_poly_trait_ref();\n-    Obligation {\n-        cause,\n-        recursion_depth: depth,\n-        param_env,\n-        predicate: trait_ref.without_const().to_predicate(infcx.tcx),\n-    }\n-}\n-\n /// If we are projecting `<T as Trait>::Item`, but `T: Trait` does not\n /// hold. In various error cases, we cannot generate a valid\n /// normalized projection. Therefore, we create an inference variable\n@@ -848,12 +803,21 @@ fn project_type<'cx, 'tcx>(\n \n     assemble_candidates_from_trait_def(selcx, obligation, &obligation_trait_ref, &mut candidates);\n \n-    assemble_candidates_from_impls(selcx, obligation, &obligation_trait_ref, &mut candidates);\n+    assemble_candidates_from_object_ty(selcx, obligation, &obligation_trait_ref, &mut candidates);\n+\n+    if let ProjectionTyCandidateSet::Single(ProjectionTyCandidate::Object(_)) = candidates {\n+        // Avoid normalization cycle from selection (see\n+        // `assemble_candidates_from_object_ty`).\n+        // FIXME(lazy_normalization): Lazy normalization should save us from\n+        // having to do special case this.\n+    } else {\n+        assemble_candidates_from_impls(selcx, obligation, &obligation_trait_ref, &mut candidates);\n+    };\n \n     match candidates {\n-        ProjectionTyCandidateSet::Single(candidate) => Ok(ProjectedTy::Progress(\n-            confirm_candidate(selcx, obligation, &obligation_trait_ref, candidate),\n-        )),\n+        ProjectionTyCandidateSet::Single(candidate) => {\n+            Ok(ProjectedTy::Progress(confirm_candidate(selcx, obligation, candidate)))\n+        }\n         ProjectionTyCandidateSet::None => Ok(ProjectedTy::NoProgress(\n             selcx\n                 .tcx()\n@@ -932,6 +896,53 @@ fn assemble_candidates_from_trait_def<'cx, 'tcx>(\n     )\n }\n \n+/// In the case of a trait object like\n+/// `<dyn Iterator<Item = ()> as Iterator>::Item` we can use the existential\n+/// predicate in the trait object.\n+///\n+/// We don't go through the select candidate for these bounds to avoid cycles:\n+/// In the above case, `dyn Iterator<Item = ()>: Iterator` would create a\n+/// nested obligation of `<dyn Iterator<Item = ()> as Iterator>::Item: Sized`,\n+/// this then has to be normalized without having to prove\n+/// `dyn Iterator<Item = ()>: Iterator` again.\n+fn assemble_candidates_from_object_ty<'cx, 'tcx>(\n+    selcx: &mut SelectionContext<'cx, 'tcx>,\n+    obligation: &ProjectionTyObligation<'tcx>,\n+    obligation_trait_ref: &ty::TraitRef<'tcx>,\n+    candidate_set: &mut ProjectionTyCandidateSet<'tcx>,\n+) {\n+    debug!(\"assemble_candidates_from_object_ty(..)\");\n+\n+    let tcx = selcx.tcx();\n+\n+    let self_ty = obligation_trait_ref.self_ty();\n+    let object_ty = selcx.infcx().shallow_resolve(self_ty);\n+    let data = match object_ty.kind {\n+        ty::Dynamic(ref data, ..) => data,\n+        ty::Infer(ty::TyVar(_)) => {\n+            // If the self-type is an inference variable, then it MAY wind up\n+            // being an object type, so induce an ambiguity.\n+            candidate_set.mark_ambiguous();\n+            return;\n+        }\n+        _ => return,\n+    };\n+    let env_predicates = data\n+        .projection_bounds()\n+        .filter(|bound| bound.item_def_id() == obligation.predicate.item_def_id)\n+        .map(|p| p.with_self_ty(tcx, object_ty).to_predicate(tcx));\n+\n+    assemble_candidates_from_predicates(\n+        selcx,\n+        obligation,\n+        obligation_trait_ref,\n+        candidate_set,\n+        ProjectionTyCandidate::Object,\n+        env_predicates,\n+        false,\n+    );\n+}\n+\n fn assemble_candidates_from_predicates<'cx, 'tcx>(\n     selcx: &mut SelectionContext<'cx, 'tcx>,\n     obligation: &ProjectionTyObligation<'tcx>,\n@@ -1000,7 +1011,6 @@ fn assemble_candidates_from_impls<'cx, 'tcx>(\n             super::ImplSource::Closure(_)\n             | super::ImplSource::Generator(_)\n             | super::ImplSource::FnPointer(_)\n-            | super::ImplSource::Object(_)\n             | super::ImplSource::TraitAlias(_) => {\n                 debug!(\"assemble_candidates_from_impls: impl_source={:?}\", impl_source);\n                 true\n@@ -1125,6 +1135,12 @@ fn assemble_candidates_from_impls<'cx, 'tcx>(\n                 // in `assemble_candidates_from_param_env`.\n                 false\n             }\n+            super::ImplSource::Object(_) => {\n+                // Handled by the `Object` projection candidate. See\n+                // `assemble_candidates_from_object_ty` for an explanation of\n+                // why we special case object types.\n+                false\n+            }\n             super::ImplSource::AutoImpl(..) | super::ImplSource::Builtin(..) => {\n                 // These traits have no associated types.\n                 selcx.tcx().sess.delay_span_bug(\n@@ -1150,13 +1166,13 @@ fn assemble_candidates_from_impls<'cx, 'tcx>(\n fn confirm_candidate<'cx, 'tcx>(\n     selcx: &mut SelectionContext<'cx, 'tcx>,\n     obligation: &ProjectionTyObligation<'tcx>,\n-    obligation_trait_ref: &ty::TraitRef<'tcx>,\n     candidate: ProjectionTyCandidate<'tcx>,\n ) -> Progress<'tcx> {\n     debug!(\"confirm_candidate(candidate={:?}, obligation={:?})\", candidate, obligation);\n \n     let mut progress = match candidate {\n-        ProjectionTyCandidate::ParamEnv(poly_projection) => {\n+        ProjectionTyCandidate::ParamEnv(poly_projection)\n+        | ProjectionTyCandidate::Object(poly_projection) => {\n             confirm_param_env_candidate(selcx, obligation, poly_projection, false)\n         }\n \n@@ -1165,7 +1181,7 @@ fn confirm_candidate<'cx, 'tcx>(\n         }\n \n         ProjectionTyCandidate::Select(impl_source) => {\n-            confirm_select_candidate(selcx, obligation, obligation_trait_ref, impl_source)\n+            confirm_select_candidate(selcx, obligation, impl_source)\n         }\n     };\n     // When checking for cycle during evaluation, we compare predicates with\n@@ -1182,7 +1198,6 @@ fn confirm_candidate<'cx, 'tcx>(\n fn confirm_select_candidate<'cx, 'tcx>(\n     selcx: &mut SelectionContext<'cx, 'tcx>,\n     obligation: &ProjectionTyObligation<'tcx>,\n-    obligation_trait_ref: &ty::TraitRef<'tcx>,\n     impl_source: Selection<'tcx>,\n ) -> Progress<'tcx> {\n     match impl_source {\n@@ -1193,10 +1208,8 @@ fn confirm_select_candidate<'cx, 'tcx>(\n         super::ImplSource::DiscriminantKind(data) => {\n             confirm_discriminant_kind_candidate(selcx, obligation, data)\n         }\n-        super::ImplSource::Object(_) => {\n-            confirm_object_candidate(selcx, obligation, obligation_trait_ref)\n-        }\n-        super::ImplSource::AutoImpl(..)\n+        super::ImplSource::Object(_)\n+        | super::ImplSource::AutoImpl(..)\n         | super::ImplSource::Param(..)\n         | super::ImplSource::Builtin(..)\n         | super::ImplSource::TraitAlias(..) =>\n@@ -1211,72 +1224,6 @@ fn confirm_select_candidate<'cx, 'tcx>(\n     }\n }\n \n-fn confirm_object_candidate<'cx, 'tcx>(\n-    selcx: &mut SelectionContext<'cx, 'tcx>,\n-    obligation: &ProjectionTyObligation<'tcx>,\n-    obligation_trait_ref: &ty::TraitRef<'tcx>,\n-) -> Progress<'tcx> {\n-    let self_ty = obligation_trait_ref.self_ty();\n-    let object_ty = selcx.infcx().shallow_resolve(self_ty);\n-    debug!(\"confirm_object_candidate(object_ty={:?})\", object_ty);\n-    let data = match object_ty.kind() {\n-        ty::Dynamic(data, ..) => data,\n-        _ => span_bug!(\n-            obligation.cause.span,\n-            \"confirm_object_candidate called with non-object: {:?}\",\n-            object_ty\n-        ),\n-    };\n-    let env_predicates = data\n-        .projection_bounds()\n-        .map(|p| p.with_self_ty(selcx.tcx(), object_ty).to_predicate(selcx.tcx()));\n-    let env_predicate = {\n-        let env_predicates = elaborate_predicates(selcx.tcx(), env_predicates);\n-\n-        // select only those projections that are actually projecting an\n-        // item with the correct name\n-\n-        let env_predicates = env_predicates.filter_map(|o| match o.predicate.skip_binders() {\n-            ty::PredicateAtom::Projection(data)\n-                if data.projection_ty.item_def_id == obligation.predicate.item_def_id =>\n-            {\n-                Some(ty::Binder::bind(data))\n-            }\n-            _ => None,\n-        });\n-\n-        // select those with a relevant trait-ref\n-        let mut env_predicates = env_predicates.filter(|data| {\n-            let data_poly_trait_ref = data.to_poly_trait_ref(selcx.tcx());\n-            let obligation_poly_trait_ref = obligation_trait_ref.to_poly_trait_ref();\n-            selcx.infcx().probe(|_| {\n-                selcx\n-                    .infcx()\n-                    .at(&obligation.cause, obligation.param_env)\n-                    .sup(obligation_poly_trait_ref, data_poly_trait_ref)\n-                    .is_ok()\n-            })\n-        });\n-\n-        // select the first matching one; there really ought to be one or\n-        // else the object type is not WF, since an object type should\n-        // include all of its projections explicitly\n-        match env_predicates.next() {\n-            Some(env_predicate) => env_predicate,\n-            None => {\n-                debug!(\n-                    \"confirm_object_candidate: no env-predicate \\\n-                     found in object type `{:?}`; ill-formed\",\n-                    object_ty\n-                );\n-                return Progress::error(selcx.tcx());\n-            }\n-        }\n-    };\n-\n-    confirm_param_env_candidate(selcx, obligation, env_predicate, false)\n-}\n-\n fn confirm_generator_candidate<'cx, 'tcx>(\n     selcx: &mut SelectionContext<'cx, 'tcx>,\n     obligation: &ProjectionTyObligation<'tcx>,"}, {"sha": "1e68554fecf530e300ce754aa9c2daf9d3b20b5c", "filename": "compiler/rustc_trait_selection/src/traits/select/confirmation.rs", "status": "modified", "additions": 41, "deletions": 135, "changes": 176, "blob_url": "https://github.com/rust-lang/rust/blob/596d6c4b3b5e86e024cd02f7221749ee6958bec6/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fconfirmation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/596d6c4b3b5e86e024cd02f7221749ee6958bec6/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fconfirmation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fconfirmation.rs?ref=596d6c4b3b5e86e024cd02f7221749ee6958bec6", "patch": "@@ -9,11 +9,10 @@\n use rustc_data_structures::stack::ensure_sufficient_stack;\n use rustc_hir::lang_items::LangItem;\n use rustc_index::bit_set::GrowableBitSet;\n+use rustc_infer::infer::InferOk;\n use rustc_infer::infer::LateBoundRegionConversionTime::HigherRankedType;\n-use rustc_infer::infer::{self, InferOk};\n-use rustc_middle::ty::fold::TypeFolder;\n use rustc_middle::ty::subst::{GenericArg, GenericArgKind, Subst, SubstsRef};\n-use rustc_middle::ty::{self, Ty, TyCtxt, TypeFoldable};\n+use rustc_middle::ty::{self, Ty};\n use rustc_middle::ty::{ToPolyTraitRef, ToPredicate, WithConstness};\n use rustc_span::def_id::DefId;\n \n@@ -434,100 +433,54 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n             vtable_base = nonmatching.map(|t| super::util::count_own_vtable_entries(tcx, t)).sum();\n         }\n \n-        // Check supertraits hold\n-        nested.extend(util::supertraits(tcx, obligation_trait_ref).skip(1).map(|super_trait| {\n-            Obligation::new(\n-                obligation.cause.clone(),\n-                obligation.param_env,\n-                super_trait.without_const().to_predicate(tcx),\n-            )\n-        }));\n-\n         let upcast_trait_ref = upcast_trait_ref.unwrap();\n \n+        // Check supertraits hold\n+        nested.extend(\n+            tcx.super_predicates_of(trait_predicate.def_id())\n+                .instantiate(tcx, trait_predicate.trait_ref.substs)\n+                .predicates\n+                .into_iter()\n+                .map(|super_trait| {\n+                    Obligation::new(obligation.cause.clone(), obligation.param_env, super_trait)\n+                }),\n+        );\n+\n         let assoc_types: Vec<_> = tcx\n-            .associated_items(upcast_trait_ref.def_id())\n+            .associated_items(trait_predicate.def_id())\n             .in_definition_order()\n             .filter_map(\n                 |item| if item.kind == ty::AssocKind::Type { Some(item.def_id) } else { None },\n             )\n             .collect();\n \n-        if !assoc_types.is_empty() {\n-            let predicates: Vec<_> =\n-                data.iter()\n-                    .filter_map(|pred| match pred {\n-                        ty::ExistentialPredicate::Projection(proj) => {\n-                            if assoc_types.contains(&proj.item_def_id) {\n-                                match self.infcx.commit_if_ok(|_| {\n-                                    self.infcx\n-                                        .at(&obligation.cause, obligation.param_env)\n-                                        .sup(\n-                                            ty::Binder::dummy(\n-                                                proj.trait_ref(tcx).with_self_ty(tcx, self_ty),\n-                                            ),\n-                                            upcast_trait_ref,\n-                                        )\n-                                        .map(|InferOk { obligations, .. }| obligations)\n-                                        .map_err(|_| ())\n-                                }) {\n-                                    Ok(obligations) => {\n-                                        nested.extend(obligations);\n-                                        Some(proj)\n-                                    }\n-                                    Err(_) => None,\n-                                }\n-                            } else {\n-                                None\n-                            }\n-                        }\n-                        ty::ExistentialPredicate::AutoTrait(_)\n-                        | ty::ExistentialPredicate::Trait(_) => None,\n-                    })\n-                    .collect();\n-\n-            let upcast_trait_ref = upcast_trait_ref\n-                .no_bound_vars()\n-                .expect(\"sup shouldn't return binder with bound vars\");\n-            let mut normalizer = ObjectAssociatedTypeNormalizer {\n-                infcx: self.infcx,\n-                object_ty: self_ty,\n-                object_bounds: &predicates,\n-                param_env: obligation.param_env,\n-                cause: &obligation.cause,\n-                nested: &mut nested,\n-            };\n-            for assoc_type in assoc_types {\n-                if !tcx.generics_of(assoc_type).params.is_empty() {\n-                    // FIXME(generic_associated_types) generate placeholders to\n-                    // extend the trait substs.\n-                    tcx.sess.span_fatal(\n-                        obligation.cause.span,\n-                        \"generic associated types in trait objects are not supported yet\",\n-                    );\n-                }\n-                // This maybe belongs in wf, but that can't (doesn't) handle\n-                // higher-ranked things.\n-                // Prevent, e.g., `dyn Iterator<Item = str>`.\n-                for bound in self.tcx().item_bounds(assoc_type) {\n-                    let subst_bound = bound.subst(tcx, upcast_trait_ref.substs);\n-                    // Normalize projections the trait object manually to\n-                    // avoid evaluation overflow.\n-                    let object_normalized = subst_bound.fold_with(&mut normalizer);\n-                    let normalized_bound = normalize_with_depth_to(\n-                        self,\n-                        obligation.param_env,\n-                        obligation.cause.clone(),\n-                        obligation.recursion_depth + 1,\n-                        &object_normalized,\n-                        normalizer.nested,\n-                    );\n-                    normalizer.nested.push(Obligation::new(\n-                        obligation.cause.clone(),\n-                        obligation.param_env.clone(),\n-                        normalized_bound,\n-                    ));\n-                }\n+        for assoc_type in assoc_types {\n+            if !tcx.generics_of(assoc_type).params.is_empty() {\n+                // FIXME(generic_associated_types) generate placeholders to\n+                // extend the trait substs.\n+                tcx.sess.span_fatal(\n+                    obligation.cause.span,\n+                    \"generic associated types in trait objects are not supported yet\",\n+                );\n+            }\n+            // This maybe belongs in wf, but that can't (doesn't) handle\n+            // higher-ranked things.\n+            // Prevent, e.g., `dyn Iterator<Item = str>`.\n+            for bound in self.tcx().item_bounds(assoc_type) {\n+                let subst_bound = bound.subst(tcx, trait_predicate.trait_ref.substs);\n+                let normalized_bound = normalize_with_depth_to(\n+                    self,\n+                    obligation.param_env,\n+                    obligation.cause.clone(),\n+                    obligation.recursion_depth + 1,\n+                    &subst_bound,\n+                    &mut nested,\n+                );\n+                nested.push(Obligation::new(\n+                    obligation.cause.clone(),\n+                    obligation.param_env.clone(),\n+                    normalized_bound,\n+                ));\n             }\n         }\n \n@@ -972,50 +925,3 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         Ok(ImplSourceBuiltinData { nested })\n     }\n }\n-\n-struct ObjectAssociatedTypeNormalizer<'a, 'tcx> {\n-    infcx: &'a infer::InferCtxt<'a, 'tcx>,\n-    object_ty: Ty<'tcx>,\n-    object_bounds: &'a [ty::ExistentialProjection<'tcx>],\n-    param_env: ty::ParamEnv<'tcx>,\n-    cause: &'a ObligationCause<'tcx>,\n-    nested: &'a mut Vec<PredicateObligation<'tcx>>,\n-}\n-\n-impl<'tcx> TypeFolder<'tcx> for ObjectAssociatedTypeNormalizer<'_, 'tcx> {\n-    fn tcx<'a>(&'a self) -> TyCtxt<'tcx> {\n-        self.infcx.tcx\n-    }\n-\n-    fn fold_ty(&mut self, t: Ty<'tcx>) -> Ty<'tcx> {\n-        if !t.has_projections() {\n-            return t;\n-        }\n-        if let ty::Projection(proj) = t.kind {\n-            if let ty::Dynamic(..) = proj.self_ty().kind {\n-                for bound in self.object_bounds {\n-                    if proj.item_def_id == bound.item_def_id {\n-                        // FIXME(generic_associated_types): This isn't relating\n-                        // the substs for the associated type.\n-                        match self.infcx.commit_if_ok(|_| {\n-                            self.infcx.at(self.cause, self.param_env).sub(\n-                                bound\n-                                    .with_self_ty(self.infcx.tcx, self.object_ty)\n-                                    .projection_ty\n-                                    .trait_ref(self.infcx.tcx),\n-                                proj.trait_ref(self.infcx.tcx),\n-                            )\n-                        }) {\n-                            Ok(InferOk { value: (), obligations }) => {\n-                                self.nested.extend(obligations);\n-                                return bound.ty;\n-                            }\n-                            Err(_) => {}\n-                        }\n-                    }\n-                }\n-            }\n-        }\n-        t.super_fold_with(self)\n-    }\n-}"}, {"sha": "d0c0e658c921f2dd948e65c59f9545db53c6cff4", "filename": "compiler/rustc_trait_selection/src/traits/select/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/596d6c4b3b5e86e024cd02f7221749ee6958bec6/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/596d6c4b3b5e86e024cd02f7221749ee6958bec6/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fmod.rs?ref=596d6c4b3b5e86e024cd02f7221749ee6958bec6", "patch": "@@ -441,8 +441,8 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n     ) -> Result<EvaluationResult, OverflowError> {\n         debug!(\n             \"evaluate_predicate_recursively(obligation={:?}, previous_stack={:?})\",\n-            previous_stack.head(),\n-            obligation\n+            obligation,\n+            previous_stack.head()\n         );\n \n         // `previous_stack` stores a `TraitObligation`, while `obligation` is"}, {"sha": "6de08f66d7536920d7e11f80a45e3848de497ab0", "filename": "src/test/ui/regions/regions-enum-not-wf.rs", "status": "modified", "additions": 12, "deletions": 11, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/596d6c4b3b5e86e024cd02f7221749ee6958bec6/src%2Ftest%2Fui%2Fregions%2Fregions-enum-not-wf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/596d6c4b3b5e86e024cd02f7221749ee6958bec6/src%2Ftest%2Fui%2Fregions%2Fregions-enum-not-wf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fregions%2Fregions-enum-not-wf.rs?ref=596d6c4b3b5e86e024cd02f7221749ee6958bec6", "patch": "@@ -5,36 +5,37 @@\n #![allow(dead_code)]\n \n trait Dummy<'a> {\n-  type Out;\n+    type Out;\n }\n impl<'a, T> Dummy<'a> for T\n-where T: 'a\n+where\n+    T: 'a,\n {\n-  type Out = ();\n+    type Out = ();\n }\n type RequireOutlives<'a, T> = <T as Dummy<'a>>::Out;\n \n enum Ref1<'a, T> {\n-    Ref1Variant1(RequireOutlives<'a, T>) //~ ERROR the parameter type `T` may not live long enough\n+    Ref1Variant1(RequireOutlives<'a, T>), //~ ERROR the parameter type `T` may not live long enough\n }\n \n enum Ref2<'a, T> {\n     Ref2Variant1,\n     Ref2Variant2(isize, RequireOutlives<'a, T>), //~ ERROR the parameter type `T` may not live long enough\n }\n \n-enum RefOk<'a, T:'a> {\n-    RefOkVariant1(&'a T)\n+enum RefOk<'a, T: 'a> {\n+    RefOkVariant1(&'a T),\n }\n \n // This is now well formed. RFC 2093\n enum RefIndirect<'a, T> {\n-    RefIndirectVariant1(isize, RefOk<'a,T>)\n+    RefIndirectVariant1(isize, RefOk<'a, T>),\n }\n \n-enum RefDouble<'a, 'b, T> { //~ ERROR the parameter type `T` may not live long enough [E0309]\n-    RefDoubleVariant1(&'a RequireOutlives<'b, T>)\n-        //~^ the parameter type `T` may not live long enough [E0309]\n+enum RefDouble<'a, 'b, T> {\n+    RefDoubleVariant1(&'a RequireOutlives<'b, T>),\n+    //~^ the parameter type `T` may not live long enough [E0309]\n }\n \n-fn main() { }\n+fn main() {}"}, {"sha": "36686eaf92f3213baf668f4f6bc4ecaf9c749696", "filename": "src/test/ui/regions/regions-enum-not-wf.stderr", "status": "modified", "additions": 6, "deletions": 18, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/596d6c4b3b5e86e024cd02f7221749ee6958bec6/src%2Ftest%2Fui%2Fregions%2Fregions-enum-not-wf.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/596d6c4b3b5e86e024cd02f7221749ee6958bec6/src%2Ftest%2Fui%2Fregions%2Fregions-enum-not-wf.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fregions%2Fregions-enum-not-wf.stderr?ref=596d6c4b3b5e86e024cd02f7221749ee6958bec6", "patch": "@@ -1,13 +1,13 @@\n error[E0309]: the parameter type `T` may not live long enough\n-  --> $DIR/regions-enum-not-wf.rs:18:18\n+  --> $DIR/regions-enum-not-wf.rs:19:18\n    |\n LL | enum Ref1<'a, T> {\n    |               - help: consider adding an explicit lifetime bound...: `T: 'a`\n-LL |     Ref1Variant1(RequireOutlives<'a, T>)\n+LL |     Ref1Variant1(RequireOutlives<'a, T>),\n    |                  ^^^^^^^^^^^^^^^^^^^^^^ ...so that the type `T` will meet its required lifetime bounds\n \n error[E0309]: the parameter type `T` may not live long enough\n-  --> $DIR/regions-enum-not-wf.rs:23:25\n+  --> $DIR/regions-enum-not-wf.rs:24:25\n    |\n LL | enum Ref2<'a, T> {\n    |               - help: consider adding an explicit lifetime bound...: `T: 'a`\n@@ -16,25 +16,13 @@ LL |     Ref2Variant2(isize, RequireOutlives<'a, T>),\n    |                         ^^^^^^^^^^^^^^^^^^^^^^ ...so that the type `T` will meet its required lifetime bounds\n \n error[E0309]: the parameter type `T` may not live long enough\n-  --> $DIR/regions-enum-not-wf.rs:35:1\n-   |\n-LL |   enum RefDouble<'a, 'b, T> {\n-   |   ^                      - help: consider adding an explicit lifetime bound...: `T: 'b`\n-   |  _|\n-   | |\n-LL | |     RefDoubleVariant1(&'a RequireOutlives<'b, T>)\n-LL | |\n-LL | | }\n-   | |_^ ...so that the type `T` will meet its required lifetime bounds\n-\n-error[E0309]: the parameter type `T` may not live long enough\n-  --> $DIR/regions-enum-not-wf.rs:36:23\n+  --> $DIR/regions-enum-not-wf.rs:37:23\n    |\n LL | enum RefDouble<'a, 'b, T> {\n    |                        - help: consider adding an explicit lifetime bound...: `T: 'b`\n-LL |     RefDoubleVariant1(&'a RequireOutlives<'b, T>)\n+LL |     RefDoubleVariant1(&'a RequireOutlives<'b, T>),\n    |                       ^^^^^^^^^^^^^^^^^^^^^^^^^^ ...so that the type `T` will meet its required lifetime bounds\n \n-error: aborting due to 4 previous errors\n+error: aborting due to 3 previous errors\n \n For more information about this error, try `rustc --explain E0309`."}, {"sha": "9912e88c2ec57546cf7a75be8e3fb03d8a2823ac", "filename": "src/test/ui/regions/regions-normalize-in-where-clause-list.rs", "status": "modified", "additions": 10, "deletions": 7, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/596d6c4b3b5e86e024cd02f7221749ee6958bec6/src%2Ftest%2Fui%2Fregions%2Fregions-normalize-in-where-clause-list.rs", "raw_url": "https://github.com/rust-lang/rust/raw/596d6c4b3b5e86e024cd02f7221749ee6958bec6/src%2Ftest%2Fui%2Fregions%2Fregions-normalize-in-where-clause-list.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fregions%2Fregions-normalize-in-where-clause-list.rs?ref=596d6c4b3b5e86e024cd02f7221749ee6958bec6", "patch": "@@ -6,24 +6,27 @@ trait Project<'a, 'b> {\n }\n \n impl<'a, 'b> Project<'a, 'b> for ()\n-    where 'a: 'b\n+where\n+    'a: 'b,\n {\n     type Item = ();\n }\n \n // No error here, we have 'a: 'b. We used to report an error here\n // though, see https://github.com/rust-lang/rust/issues/45937.\n fn foo<'a: 'b, 'b>()\n-    where <() as Project<'a, 'b>>::Item : Eq\n+where\n+    <() as Project<'a, 'b>>::Item: Eq,\n {\n }\n \n // Here we get an error: we need `'a: 'b`.\n-fn bar<'a, 'b>() //~ ERROR cannot infer\n-                 //~| ERROR cannot infer\n-                 //~| ERROR cannot infer\n-    where <() as Project<'a, 'b>>::Item : Eq\n+fn bar<'a, 'b>()\n+//~^ ERROR cannot infer\n+//~| ERROR cannot infer\n+where\n+    <() as Project<'a, 'b>>::Item: Eq,\n {\n }\n \n-fn main() { }\n+fn main() {}"}, {"sha": "24bf64261e9d2decde0766e360c04c1033c048e8", "filename": "src/test/ui/regions/regions-normalize-in-where-clause-list.stderr", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/596d6c4b3b5e86e024cd02f7221749ee6958bec6/src%2Ftest%2Fui%2Fregions%2Fregions-normalize-in-where-clause-list.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/596d6c4b3b5e86e024cd02f7221749ee6958bec6/src%2Ftest%2Fui%2Fregions%2Fregions-normalize-in-where-clause-list.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fregions%2Fregions-normalize-in-where-clause-list.stderr?ref=596d6c4b3b5e86e024cd02f7221749ee6958bec6", "patch": "@@ -1,24 +1,24 @@\n error[E0495]: cannot infer an appropriate lifetime for lifetime parameter `'a` due to conflicting requirements\n-  --> $DIR/regions-normalize-in-where-clause-list.rs:22:1\n+  --> $DIR/regions-normalize-in-where-clause-list.rs:24:1\n    |\n LL | / fn bar<'a, 'b>()\n LL | |\n LL | |\n LL | |     where <() as Project<'a, 'b>>::Item : Eq\n    | |____________________________________________^\n    |\n-note: first, the lifetime cannot outlive the lifetime `'a` as defined on the function body at 22:8...\n-  --> $DIR/regions-normalize-in-where-clause-list.rs:22:8\n+note: first, the lifetime cannot outlive the lifetime `'a` as defined on the function body at 24:8...\n+  --> $DIR/regions-normalize-in-where-clause-list.rs:24:8\n    |\n LL | fn bar<'a, 'b>()\n    |        ^^\n-note: ...but the lifetime must also be valid for the lifetime `'b` as defined on the function body at 22:12...\n-  --> $DIR/regions-normalize-in-where-clause-list.rs:22:12\n+note: ...but the lifetime must also be valid for the lifetime `'b` as defined on the function body at 24:12...\n+  --> $DIR/regions-normalize-in-where-clause-list.rs:24:12\n    |\n LL | fn bar<'a, 'b>()\n    |            ^^\n note: ...so that the types are compatible\n-  --> $DIR/regions-normalize-in-where-clause-list.rs:22:1\n+  --> $DIR/regions-normalize-in-where-clause-list.rs:24:1\n    |\n LL | / fn bar<'a, 'b>()\n LL | |\n@@ -64,24 +64,24 @@ error[E0495]: cannot infer an appropriate lifetime for lifetime parameter `'a` d\n LL | fn bar<'a, 'b>()\n    |    ^^^\n    |\n-note: first, the lifetime cannot outlive the lifetime `'a` as defined on the function body at 22:8...\n-  --> $DIR/regions-normalize-in-where-clause-list.rs:22:8\n+note: first, the lifetime cannot outlive the lifetime `'a` as defined on the function body at 24:8...\n+  --> $DIR/regions-normalize-in-where-clause-list.rs:24:8\n    |\n LL | fn bar<'a, 'b>()\n    |        ^^\n-note: ...but the lifetime must also be valid for the lifetime `'b` as defined on the function body at 22:12...\n-  --> $DIR/regions-normalize-in-where-clause-list.rs:22:12\n+note: ...but the lifetime must also be valid for the lifetime `'b` as defined on the function body at 24:12...\n+  --> $DIR/regions-normalize-in-where-clause-list.rs:24:12\n    |\n LL | fn bar<'a, 'b>()\n    |            ^^\n note: ...so that the types are compatible\n-  --> $DIR/regions-normalize-in-where-clause-list.rs:22:4\n+  --> $DIR/regions-normalize-in-where-clause-list.rs:24:4\n    |\n LL | fn bar<'a, 'b>()\n    |    ^^^\n    = note: expected `Project<'a, 'b>`\n               found `Project<'_, '_>`\n \n-error: aborting due to 3 previous errors\n+error: aborting due to 2 previous errors\n \n For more information about this error, try `rustc --explain E0495`."}, {"sha": "6de08f66d7536920d7e11f80a45e3848de497ab0", "filename": "src/test/ui/rfc-2093-infer-outlives/regions-enum-not-wf.rs", "status": "modified", "additions": 12, "deletions": 11, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/596d6c4b3b5e86e024cd02f7221749ee6958bec6/src%2Ftest%2Fui%2Frfc-2093-infer-outlives%2Fregions-enum-not-wf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/596d6c4b3b5e86e024cd02f7221749ee6958bec6/src%2Ftest%2Fui%2Frfc-2093-infer-outlives%2Fregions-enum-not-wf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc-2093-infer-outlives%2Fregions-enum-not-wf.rs?ref=596d6c4b3b5e86e024cd02f7221749ee6958bec6", "patch": "@@ -5,36 +5,37 @@\n #![allow(dead_code)]\n \n trait Dummy<'a> {\n-  type Out;\n+    type Out;\n }\n impl<'a, T> Dummy<'a> for T\n-where T: 'a\n+where\n+    T: 'a,\n {\n-  type Out = ();\n+    type Out = ();\n }\n type RequireOutlives<'a, T> = <T as Dummy<'a>>::Out;\n \n enum Ref1<'a, T> {\n-    Ref1Variant1(RequireOutlives<'a, T>) //~ ERROR the parameter type `T` may not live long enough\n+    Ref1Variant1(RequireOutlives<'a, T>), //~ ERROR the parameter type `T` may not live long enough\n }\n \n enum Ref2<'a, T> {\n     Ref2Variant1,\n     Ref2Variant2(isize, RequireOutlives<'a, T>), //~ ERROR the parameter type `T` may not live long enough\n }\n \n-enum RefOk<'a, T:'a> {\n-    RefOkVariant1(&'a T)\n+enum RefOk<'a, T: 'a> {\n+    RefOkVariant1(&'a T),\n }\n \n // This is now well formed. RFC 2093\n enum RefIndirect<'a, T> {\n-    RefIndirectVariant1(isize, RefOk<'a,T>)\n+    RefIndirectVariant1(isize, RefOk<'a, T>),\n }\n \n-enum RefDouble<'a, 'b, T> { //~ ERROR the parameter type `T` may not live long enough [E0309]\n-    RefDoubleVariant1(&'a RequireOutlives<'b, T>)\n-        //~^ the parameter type `T` may not live long enough [E0309]\n+enum RefDouble<'a, 'b, T> {\n+    RefDoubleVariant1(&'a RequireOutlives<'b, T>),\n+    //~^ the parameter type `T` may not live long enough [E0309]\n }\n \n-fn main() { }\n+fn main() {}"}, {"sha": "36686eaf92f3213baf668f4f6bc4ecaf9c749696", "filename": "src/test/ui/rfc-2093-infer-outlives/regions-enum-not-wf.stderr", "status": "modified", "additions": 6, "deletions": 18, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/596d6c4b3b5e86e024cd02f7221749ee6958bec6/src%2Ftest%2Fui%2Frfc-2093-infer-outlives%2Fregions-enum-not-wf.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/596d6c4b3b5e86e024cd02f7221749ee6958bec6/src%2Ftest%2Fui%2Frfc-2093-infer-outlives%2Fregions-enum-not-wf.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc-2093-infer-outlives%2Fregions-enum-not-wf.stderr?ref=596d6c4b3b5e86e024cd02f7221749ee6958bec6", "patch": "@@ -1,13 +1,13 @@\n error[E0309]: the parameter type `T` may not live long enough\n-  --> $DIR/regions-enum-not-wf.rs:18:18\n+  --> $DIR/regions-enum-not-wf.rs:19:18\n    |\n LL | enum Ref1<'a, T> {\n    |               - help: consider adding an explicit lifetime bound...: `T: 'a`\n-LL |     Ref1Variant1(RequireOutlives<'a, T>)\n+LL |     Ref1Variant1(RequireOutlives<'a, T>),\n    |                  ^^^^^^^^^^^^^^^^^^^^^^ ...so that the type `T` will meet its required lifetime bounds\n \n error[E0309]: the parameter type `T` may not live long enough\n-  --> $DIR/regions-enum-not-wf.rs:23:25\n+  --> $DIR/regions-enum-not-wf.rs:24:25\n    |\n LL | enum Ref2<'a, T> {\n    |               - help: consider adding an explicit lifetime bound...: `T: 'a`\n@@ -16,25 +16,13 @@ LL |     Ref2Variant2(isize, RequireOutlives<'a, T>),\n    |                         ^^^^^^^^^^^^^^^^^^^^^^ ...so that the type `T` will meet its required lifetime bounds\n \n error[E0309]: the parameter type `T` may not live long enough\n-  --> $DIR/regions-enum-not-wf.rs:35:1\n-   |\n-LL |   enum RefDouble<'a, 'b, T> {\n-   |   ^                      - help: consider adding an explicit lifetime bound...: `T: 'b`\n-   |  _|\n-   | |\n-LL | |     RefDoubleVariant1(&'a RequireOutlives<'b, T>)\n-LL | |\n-LL | | }\n-   | |_^ ...so that the type `T` will meet its required lifetime bounds\n-\n-error[E0309]: the parameter type `T` may not live long enough\n-  --> $DIR/regions-enum-not-wf.rs:36:23\n+  --> $DIR/regions-enum-not-wf.rs:37:23\n    |\n LL | enum RefDouble<'a, 'b, T> {\n    |                        - help: consider adding an explicit lifetime bound...: `T: 'b`\n-LL |     RefDoubleVariant1(&'a RequireOutlives<'b, T>)\n+LL |     RefDoubleVariant1(&'a RequireOutlives<'b, T>),\n    |                       ^^^^^^^^^^^^^^^^^^^^^^^^^^ ...so that the type `T` will meet its required lifetime bounds\n \n-error: aborting due to 4 previous errors\n+error: aborting due to 3 previous errors\n \n For more information about this error, try `rustc --explain E0309`."}, {"sha": "98bfcb8d67b516eafb8948ee05d6a0c8a48f32bb", "filename": "src/test/ui/traits/cycle-cache-err-60010.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/596d6c4b3b5e86e024cd02f7221749ee6958bec6/src%2Ftest%2Fui%2Ftraits%2Fcycle-cache-err-60010.rs", "raw_url": "https://github.com/rust-lang/rust/raw/596d6c4b3b5e86e024cd02f7221749ee6958bec6/src%2Ftest%2Fui%2Ftraits%2Fcycle-cache-err-60010.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftraits%2Fcycle-cache-err-60010.rs?ref=596d6c4b3b5e86e024cd02f7221749ee6958bec6", "patch": "@@ -24,7 +24,7 @@ struct Runtime<DB: Database> {\n     _storage: Box<DB::Storage>,\n }\n struct SalsaStorage {\n-    _parse: <ParseQuery as Query<RootDatabase>>::Data, //~ ERROR overflow\n+    _parse: <ParseQuery as Query<RootDatabase>>::Data,\n }\n \n impl Database for RootDatabase {\n@@ -67,6 +67,7 @@ pub(crate) fn goto_implementation(db: &RootDatabase) -> u32 {\n     // we used to fail to report an error here because we got the\n     // caching wrong.\n     SourceDatabase::parse(db);\n+    //~^ ERROR overflow\n     22\n }\n "}, {"sha": "738b052a11ebb0d3403ca5ab35992f3e01d1d9f6", "filename": "src/test/ui/traits/cycle-cache-err-60010.stderr", "status": "modified", "additions": 13, "deletions": 5, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/596d6c4b3b5e86e024cd02f7221749ee6958bec6/src%2Ftest%2Fui%2Ftraits%2Fcycle-cache-err-60010.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/596d6c4b3b5e86e024cd02f7221749ee6958bec6/src%2Ftest%2Fui%2Ftraits%2Fcycle-cache-err-60010.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftraits%2Fcycle-cache-err-60010.stderr?ref=596d6c4b3b5e86e024cd02f7221749ee6958bec6", "patch": "@@ -1,10 +1,18 @@\n-error[E0275]: overflow evaluating the requirement `RootDatabase: SourceDatabase`\n-  --> $DIR/cycle-cache-err-60010.rs:27:13\n+error[E0275]: overflow evaluating the requirement `SalsaStorage: std::panic::RefUnwindSafe`\n+  --> $DIR/cycle-cache-err-60010.rs:69:5\n    |\n-LL |     _parse: <ParseQuery as Query<RootDatabase>>::Data,\n-   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+LL |     fn parse(&self) {\n+   |     --------------- required by `SourceDatabase::parse`\n+...\n+LL |     SourceDatabase::parse(db);\n+   |     ^^^^^^^^^^^^^^^^^^^^^\n    |\n-   = note: required because of the requirements on the impl of `Query<RootDatabase>` for `ParseQuery`\n+   = note: required because it appears within the type `*const SalsaStorage`\n+   = note: required because it appears within the type `std::ptr::Unique<SalsaStorage>`\n+   = note: required because it appears within the type `std::boxed::Box<SalsaStorage>`\n+   = note: required because it appears within the type `Runtime<RootDatabase>`\n+   = note: required because it appears within the type `RootDatabase`\n+   = note: required because of the requirements on the impl of `SourceDatabase` for `RootDatabase`\n \n error[E0275]: overflow evaluating the requirement `Runtime<RootDatabase>: RefUnwindSafe`\n   --> $DIR/cycle-cache-err-60010.rs:31:20"}]}