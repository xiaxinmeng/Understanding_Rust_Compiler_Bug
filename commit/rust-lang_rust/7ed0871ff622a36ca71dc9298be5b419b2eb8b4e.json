{"sha": "7ed0871ff622a36ca71dc9298be5b419b2eb8b4e", "node_id": "C_kwDOAAsO6NoAKDdlZDA4NzFmZjYyMmEzNmNhNzFkYzkyOThiZTViNDE5YjJlYjhiNGU", "commit": {"author": {"name": "Maybe Waffle", "email": "waffle.lapkin@gmail.com", "date": "2022-12-13T00:06:00Z"}, "committer": {"name": "Maybe Waffle", "email": "waffle.lapkin@gmail.com", "date": "2022-12-13T00:06:00Z"}, "message": "Fix \"needs parens\" check in `remove_parentheses` assist", "tree": {"sha": "d7e749cbaa37e63713bdb6f0de7d3e2f28f931a2", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d7e749cbaa37e63713bdb6f0de7d3e2f28f931a2"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7ed0871ff622a36ca71dc9298be5b419b2eb8b4e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7ed0871ff622a36ca71dc9298be5b419b2eb8b4e", "html_url": "https://github.com/rust-lang/rust/commit/7ed0871ff622a36ca71dc9298be5b419b2eb8b4e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7ed0871ff622a36ca71dc9298be5b419b2eb8b4e/comments", "author": {"login": "WaffleLapkin", "id": 38225716, "node_id": "MDQ6VXNlcjM4MjI1NzE2", "avatar_url": "https://avatars.githubusercontent.com/u/38225716?v=4", "gravatar_id": "", "url": "https://api.github.com/users/WaffleLapkin", "html_url": "https://github.com/WaffleLapkin", "followers_url": "https://api.github.com/users/WaffleLapkin/followers", "following_url": "https://api.github.com/users/WaffleLapkin/following{/other_user}", "gists_url": "https://api.github.com/users/WaffleLapkin/gists{/gist_id}", "starred_url": "https://api.github.com/users/WaffleLapkin/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/WaffleLapkin/subscriptions", "organizations_url": "https://api.github.com/users/WaffleLapkin/orgs", "repos_url": "https://api.github.com/users/WaffleLapkin/repos", "events_url": "https://api.github.com/users/WaffleLapkin/events{/privacy}", "received_events_url": "https://api.github.com/users/WaffleLapkin/received_events", "type": "User", "site_admin": false}, "committer": {"login": "WaffleLapkin", "id": 38225716, "node_id": "MDQ6VXNlcjM4MjI1NzE2", "avatar_url": "https://avatars.githubusercontent.com/u/38225716?v=4", "gravatar_id": "", "url": "https://api.github.com/users/WaffleLapkin", "html_url": "https://github.com/WaffleLapkin", "followers_url": "https://api.github.com/users/WaffleLapkin/followers", "following_url": "https://api.github.com/users/WaffleLapkin/following{/other_user}", "gists_url": "https://api.github.com/users/WaffleLapkin/gists{/gist_id}", "starred_url": "https://api.github.com/users/WaffleLapkin/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/WaffleLapkin/subscriptions", "organizations_url": "https://api.github.com/users/WaffleLapkin/orgs", "repos_url": "https://api.github.com/users/WaffleLapkin/repos", "events_url": "https://api.github.com/users/WaffleLapkin/events{/privacy}", "received_events_url": "https://api.github.com/users/WaffleLapkin/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4596847a88abb0d5077c5111c3093e724673d7a0", "url": "https://api.github.com/repos/rust-lang/rust/commits/4596847a88abb0d5077c5111c3093e724673d7a0", "html_url": "https://github.com/rust-lang/rust/commit/4596847a88abb0d5077c5111c3093e724673d7a0"}], "stats": {"total": 537, "additions": 440, "deletions": 97}, "files": [{"sha": "e9c7c6bae9cee150e5a9ea6803da848b3d2c0622", "filename": "crates/ide-assists/src/handlers/remove_parentheses.rs", "status": "modified", "additions": 133, "deletions": 3, "changes": 136, "blob_url": "https://github.com/rust-lang/rust/blob/7ed0871ff622a36ca71dc9298be5b419b2eb8b4e/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fremove_parentheses.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7ed0871ff622a36ca71dc9298be5b419b2eb8b4e/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fremove_parentheses.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fremove_parentheses.rs?ref=7ed0871ff622a36ca71dc9298be5b419b2eb8b4e", "patch": "@@ -29,9 +29,8 @@ pub(crate) fn remove_parentheses(acc: &mut Assists, ctx: &AssistContext<'_>) ->\n \n     let expr = parens.expr()?;\n \n-    let parent = ast::Expr::cast(parens.syntax().parent()?);\n-    let is_ok_to_remove = expr.precedence() >= parent.as_ref().and_then(ast::Expr::precedence);\n-    if !is_ok_to_remove {\n+    let parent = parens.syntax().parent()?;\n+    if expr.needs_parens_in(parent) {\n         return None;\n     }\n \n@@ -58,6 +57,31 @@ mod tests {\n         check_assist(remove_parentheses, r#\"fn f() { (2$0) + 2; }\"#, r#\"fn f() { 2 + 2; }\"#);\n     }\n \n+    #[test]\n+    fn remove_parens_closure() {\n+        check_assist(remove_parentheses, r#\"fn f() { &$0(|| 42) }\"#, r#\"fn f() { &|| 42 }\"#);\n+\n+        check_assist_not_applicable(remove_parentheses, r#\"fn f() { $0(|| 42).f() }\"#);\n+    }\n+\n+    #[test]\n+    fn remove_parens_if_let_chains() {\n+        check_assist_not_applicable(\n+            remove_parentheses,\n+            r#\"fn f() { if let true = $0(true && true) {} }\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn remove_parens_associativity() {\n+        check_assist(\n+            remove_parentheses,\n+            r#\"fn f() { $0(2 + 2) + 2; }\"#,\n+            r#\"fn f() { 2 + 2 + 2; }\"#,\n+        );\n+        check_assist_not_applicable(remove_parentheses, r#\"fn f() { 2 + $0(2 + 2); }\"#);\n+    }\n+\n     #[test]\n     fn remove_parens_precedence() {\n         check_assist(\n@@ -88,4 +112,110 @@ mod tests {\n         check_assist_not_applicable(remove_parentheses, r#\"fn f() { (2 +$0 2) }\"#);\n         check_assist_not_applicable(remove_parentheses, r#\"fn f() {$0 (2 + 2) }\"#);\n     }\n+\n+    #[test]\n+    fn remove_parens_doesnt_apply_when_expr_would_be_turned_into_a_statement() {\n+        check_assist_not_applicable(remove_parentheses, r#\"fn x() -> u8 { $0({ 0 } + 1) }\"#);\n+        check_assist_not_applicable(\n+            remove_parentheses,\n+            r#\"fn x() -> u8 { $0(if true { 0 } else { 1 } + 1) }\"#,\n+        );\n+        check_assist_not_applicable(remove_parentheses, r#\"fn x() -> u8 { $0(loop {} + 1) }\"#);\n+    }\n+\n+    #[test]\n+    fn remove_parens_doesnt_apply_weird_syntax_and_adge_cases() {\n+        // removing `()` would break code because {} would be counted as the loop/if body\n+        check_assist_not_applicable(remove_parentheses, r#\"fn f() { for _ in $0(0..{3}) {} }\"#);\n+        check_assist_not_applicable(remove_parentheses, r#\"fn f() { for _ in $0(S {}) {} }\"#);\n+        check_assist_not_applicable(remove_parentheses, r#\"fn f() { if $0(S {} == 2) {} }\"#);\n+        check_assist_not_applicable(remove_parentheses, r#\"fn f() { if $0(return) {} }\"#);\n+    }\n+\n+    #[test]\n+    fn remove_parens_return_with_value_followed_by_block() {\n+        check_assist(\n+            remove_parentheses,\n+            r#\"fn f() { if $0(return ()) {} }\"#,\n+            r#\"fn f() { if return () {} }\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn remove_exprs_let_else_restrictions() {\n+        // `}` is not allowed before `else` here\n+        check_assist_not_applicable(\n+            remove_parentheses,\n+            r#\"fn f() { let _ = $0(S{}) else { return }; }\"#,\n+        );\n+\n+        // logic operators can't directly appear in the let-else\n+        check_assist_not_applicable(\n+            remove_parentheses,\n+            r#\"fn f() { let _ = $0(false || false) else { return }; }\"#,\n+        );\n+        check_assist_not_applicable(\n+            remove_parentheses,\n+            r#\"fn f() { let _ = $0(true && true) else { return }; }\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn remove_parens_weird_places() {\n+        check_assist(\n+            remove_parentheses,\n+            r#\"fn f() { match () { _=>$0(()) } }\"#,\n+            r#\"fn f() { match () { _=>() } }\"#,\n+        );\n+\n+        check_assist(\n+            remove_parentheses,\n+            r#\"fn x() -> u8 { { [$0({ 0 } + 1)] } }\"#,\n+            r#\"fn x() -> u8 { { [{ 0 } + 1] } }\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn remove_parens_return_dot_f() {\n+        check_assist(\n+            remove_parentheses,\n+            r#\"fn f() { $0(return).f() }\"#,\n+            r#\"fn f() { return.f() }\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn remove_parens_prefix_then_return_something() {\n+        check_assist(\n+            remove_parentheses,\n+            r#\"fn f() { &$0(return ()) }\"#,\n+            r#\"fn f() { &return () }\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn remove_parens_double_paren_stmt() {\n+        check_assist(\n+            remove_parentheses,\n+            r#\"fn x() -> u8 { $0(({ 0 } + 1)) }\"#,\n+            r#\"fn x() -> u8 { ({ 0 } + 1) }\"#,\n+        );\n+\n+        check_assist(\n+            remove_parentheses,\n+            r#\"fn x() -> u8 { (($0{ 0 } + 1)) }\"#,\n+            r#\"fn x() -> u8 { ({ 0 } + 1) }\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn remove_parens_im_tired_of_naming_tests() {\n+        check_assist(\n+            remove_parentheses,\n+            r#\"fn f() { 2 + $0(return 2) }\"#,\n+            r#\"fn f() { 2 + return 2 }\"#,\n+        );\n+\n+        check_assist_not_applicable(remove_parentheses, r#\"fn f() { $0(return 2) + 2 }\"#);\n+    }\n }"}, {"sha": "53b31098e40fa1109e92f454f742f07f268791c5", "filename": "crates/syntax/src/ast/prec.rs", "status": "modified", "additions": 307, "deletions": 94, "changes": 401, "blob_url": "https://github.com/rust-lang/rust/blob/7ed0871ff622a36ca71dc9298be5b419b2eb8b4e/crates%2Fsyntax%2Fsrc%2Fast%2Fprec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7ed0871ff622a36ca71dc9298be5b419b2eb8b4e/crates%2Fsyntax%2Fsrc%2Fast%2Fprec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fsyntax%2Fsrc%2Fast%2Fprec.rs?ref=7ed0871ff622a36ca71dc9298be5b419b2eb8b4e", "patch": "@@ -1,115 +1,328 @@\n //! Precedence representation.\n \n-use crate::ast::{self, BinExpr, Expr};\n-\n-/// Precedence of an expression.\n-#[derive(Debug, Copy, Clone, Ord, PartialOrd, Eq, PartialEq)]\n-pub enum ExprPrecedence {\n-    // N.B.: Order is important\n-    Closure,\n-    Jump,\n-    Range,\n-    Bin(BinOpPresedence),\n-    Prefix,\n-    Postfix,\n-    Paren,\n-}\n-\n-/// Precedence of a binary operator.\n-#[derive(Debug, Copy, Clone, Ord, PartialOrd, Eq, PartialEq)]\n-pub enum BinOpPresedence {\n-    // N.B.: Order is important\n-    /// `=`, `+=`, `-=`, `*=`, `/=`, `%=`, `|=`, `&=`\n-    Assign,\n-    /// `||`\n-    LOr,\n-    /// `&&`\n-    LAnd,\n-    /// `<`, `<=`, `>`, `>=`, `==` and `!=`\n-    Cmp,\n-    /// `|`\n-    BitOr,\n-    /// `^`\n-    BitXor,\n-    /// `&`\n-    BitAnd,\n-    /// `<<` and `>>`\n-    Shift,\n-    /// `+` and `-`\n-    Add,\n-    /// `*`, `/` and `%`\n-    Mul,\n-    /// `as`\n-    As,\n-}\n+use crate::{\n+    ast::{self, BinaryOp, Expr, HasArgList},\n+    match_ast, AstNode, SyntaxNode,\n+};\n \n impl Expr {\n-    /// Returns precedence of this expression.\n-    /// Usefull to preserve semantics in assists.\n-    ///\n-    /// Returns `None` if this is a [`BinExpr`] and its [`op_kind`] returns `None`.\n-    ///\n-    /// [`op_kind`]: BinExpr::op_kind\n-    /// [`BinExpr`]: Expr::BinExpr\n-    pub fn precedence(&self) -> Option<ExprPrecedence> {\n-        // Copied from <https://github.com/rust-lang/rust/blob/b6852428a8ea9728369b64b9964cad8e258403d3/compiler/rustc_ast/src/util/parser.rs#L296>\n+    // Implementation is based on\n+    // - https://doc.rust-lang.org/reference/expressions.html#expression-precedence\n+    // - https://matklad.github.io/2020/04/13/simple-but-powerful-pratt-parsing.html\n+    // - rustc source, including, but not limited to\n+    //   - https://github.com/rust-lang/rust/blob/b6852428a8ea9728369b64b9964cad8e258403d3/compiler/rustc_ast/src/util/parser.rs#L296\n+\n+    /// Returns `true` if `self` would need to be wrapped in parentheses given that its parent is `parent`.\n+    pub fn needs_parens_in(&self, parent: SyntaxNode) -> bool {\n+        match_ast! {\n+            match parent {\n+                ast::Expr(e) => self.needs_parens_in_expr(&e),\n+                ast::Stmt(e) => self.needs_parens_in_stmt(Some(&e)),\n+                ast::StmtList(_) => self.needs_parens_in_stmt(None),\n+                ast::ArgList(_) => false,\n+                ast::MatchArm(_) => false,\n+                _ => unimplemented!()\n+            }\n+        }\n+    }\n+\n+    fn needs_parens_in_expr(&self, parent: &Expr) -> bool {\n+        // Special-case block weirdness\n+        if parent.child_is_followed_by_a_block() {\n+            use Expr::*;\n+            match self {\n+                // Cases like `if return {}` (need parens or else `{}` is returned, instead of being `if`'s body)\n+                ReturnExpr(e) if e.expr().is_none() => return true,\n+                BreakExpr(e) if e.expr().is_none() => return true,\n+                YieldExpr(e) if e.expr().is_none() => return true,\n+\n+                // Same but with `..{}`\n+                RangeExpr(e) if matches!(e.end(), Some(BlockExpr(..))) => return true,\n+\n+                // Similarly with struct literals, e.g. `if S{} == 1 {}`\n+                _ if self.contains_exterior_struct_lit() => return true,\n+                _ => {}\n+            }\n+        }\n+\n+        // Special-case `return.f()`\n+        if self.is_ret_like_with_no_value() && parent.is_postfix() {\n+            return false;\n+        }\n+\n+        if self.is_paren_like()\n+            || parent.is_paren_like()\n+            || self.is_prefix() && (parent.is_prefix() || !self.is_ordered_before(parent))\n+            || self.is_postfix() && (parent.is_postfix() || self.is_ordered_before(parent))\n+        {\n+            return false;\n+        }\n+\n+        let (left, right, inv) = match self.is_ordered_before(parent) {\n+            true => (self, parent, false),\n+            false => (parent, self, true),\n+        };\n+\n+        let (_, left_right_bp) = left.binding_power();\n+        let (right_left_bp, _) = right.binding_power();\n+\n+        (left_right_bp < right_left_bp) ^ inv\n+    }\n+\n+    fn needs_parens_in_stmt(&self, stmt: Option<&ast::Stmt>) -> bool {\n         use Expr::*;\n \n-        let prec = match self {\n-            ClosureExpr(_) => ExprPrecedence::Closure,\n+        // Prevent false-positives in cases like `fn x() -> u8 { ({ 0 } + 1) }`,\n+        // `{ { 0 } + 1 }` won't parse -- `{ 0 }` would be parsed as a self-contained stmt,\n+        // leaving `+ 1` as a parse error.\n+        let mut innermost = self.clone();\n+        loop {\n+            let next = match &innermost {\n+                BinExpr(e) => e.lhs(),\n+                CallExpr(e) => e.expr(),\n+                CastExpr(e) => e.expr(),\n+                IndexExpr(e) => e.base(),\n+                _ => break,\n+            };\n \n-            ContinueExpr(_) | ReturnExpr(_) | YieldExpr(_) | BreakExpr(_) => ExprPrecedence::Jump,\n+            if let Some(next) = next {\n+                innermost = next;\n+                if !innermost.requires_semi_to_be_stmt() {\n+                    return true;\n+                }\n+            } else {\n+                break;\n+            }\n+        }\n \n-            RangeExpr(_) => ExprPrecedence::Range,\n+        // Not every expression can be followed by `else` in the `let-else`\n+        if let Some(ast::Stmt::LetStmt(e)) = stmt {\n+            if e.let_else().is_some() {\n+                match self {\n+                    BinExpr(e)\n+                        if e.op_kind()\n+                            .map(|op| matches!(op, BinaryOp::LogicOp(_)))\n+                            .unwrap_or(false) =>\n+                    {\n+                        return true\n+                    }\n+                    _ if self.clone().trailing_brace().is_some() => return true,\n+                    _ => {}\n+                }\n+            }\n+        }\n \n-            BinExpr(bin_expr) => return bin_expr.precedence().map(ExprPrecedence::Bin),\n-            CastExpr(_) => ExprPrecedence::Bin(BinOpPresedence::As),\n+        false\n+    }\n+\n+    /// Returns left and right so-called \"binding powers\" of this expression.\n+    fn binding_power(&self) -> (u8, u8) {\n+        use ast::{ArithOp::*, BinaryOp::*, Expr::*, LogicOp::*};\n+\n+        let dps = match self {\n+            // (0, 0)   -- paren-like/nullary\n+            // (0, N)   -- prefix\n+            // (N, 0)   -- postfix\n+            // (N, N)   -- infix, requires parens\n+            // (N, N+1) -- infix, left to right associative\n+            // (N+1, N) -- infix, right to left associative\n+            // N is odd\n+            //\n+            ContinueExpr(_) => (0, 0),\n+\n+            ClosureExpr(_) | ReturnExpr(_) | YieldExpr(_) | BreakExpr(_) => (0, 1),\n+\n+            RangeExpr(_) => (5, 5),\n+\n+            BinExpr(e) => {\n+                // Return a dummy value if we don't know the op\n+                let Some(op) = e.op_kind() else { return (0, 0) };\n+                match op {\n+                    Assignment { .. } => (4, 3),\n+                    //\n+                    // Ranges are here in order :)\n+                    //\n+                    LogicOp(op) => match op {\n+                        Or => (7, 8),\n+                        And => (9, 10),\n+                    },\n+                    CmpOp(_) => (11, 11),\n+                    ArithOp(op) => match op {\n+                        BitOr => (13, 14),\n+                        BitXor => (15, 16),\n+                        BitAnd => (17, 18),\n+                        Shl | Shr => (19, 20),\n+                        Add | Sub => (21, 22),\n+                        Mul | Div | Rem => (23, 24),\n+                    },\n+                }\n+            }\n+\n+            CastExpr(_) => (25, 26),\n+\n+            BoxExpr(_) | RefExpr(_) | LetExpr(_) | PrefixExpr(_) => (0, 27),\n \n-            BoxExpr(_) | RefExpr(_) | LetExpr(_) | PrefixExpr(_) => ExprPrecedence::Prefix,\n+            AwaitExpr(_) | CallExpr(_) | MethodCallExpr(_) | IndexExpr(_) | TryExpr(_)\n+            | MacroExpr(_) => (29, 0),\n \n-            AwaitExpr(_) | CallExpr(_) | MethodCallExpr(_) | FieldExpr(_) | IndexExpr(_)\n-            | TryExpr(_) | MacroExpr(_) => ExprPrecedence::Postfix,\n+            FieldExpr(_) => (31, 32),\n \n             ArrayExpr(_) | TupleExpr(_) | Literal(_) | PathExpr(_) | ParenExpr(_) | IfExpr(_)\n             | WhileExpr(_) | ForExpr(_) | LoopExpr(_) | MatchExpr(_) | BlockExpr(_)\n-            | RecordExpr(_) | UnderscoreExpr(_) => ExprPrecedence::Paren,\n+            | RecordExpr(_) | UnderscoreExpr(_) => (0, 0),\n         };\n \n-        Some(prec)\n+        dps\n     }\n-}\n \n-impl BinExpr {\n-    /// Returns precedence of this binary expression.\n-    /// Usefull to preserve semantics in assists.\n-    ///\n-    /// Returns `None` if [`op_kind`] returns `None`.\n-    ///\n-    /// [`op_kind`]: BinExpr::op_kind\n-    pub fn precedence(&self) -> Option<BinOpPresedence> {\n-        use ast::{ArithOp::*, BinaryOp::*, LogicOp::*};\n-\n-        let prec = match self.op_kind()? {\n-            LogicOp(op) => match op {\n-                And => BinOpPresedence::LAnd,\n-                Or => BinOpPresedence::LOr,\n-            },\n-            ArithOp(op) => match op {\n-                Add => BinOpPresedence::Add,\n-                Mul => BinOpPresedence::Mul,\n-                Sub => BinOpPresedence::Add,\n-                Div => BinOpPresedence::Mul,\n-                Rem => BinOpPresedence::Mul,\n-                Shl => BinOpPresedence::Shift,\n-                Shr => BinOpPresedence::Shift,\n-                BitXor => BinOpPresedence::BitXor,\n-                BitOr => BinOpPresedence::BitOr,\n-                BitAnd => BinOpPresedence::BitAnd,\n-            },\n-            CmpOp(_) => BinOpPresedence::Cmp,\n-            Assignment { .. } => BinOpPresedence::Assign,\n-        };\n+    fn is_paren_like(&self) -> bool {\n+        matches!(self.binding_power(), (0, 0))\n+    }\n+\n+    fn is_prefix(&self) -> bool {\n+        matches!(self.binding_power(), (0, 1..))\n+    }\n+\n+    fn is_postfix(&self) -> bool {\n+        matches!(self.binding_power(), (1.., 0))\n+    }\n+\n+    /// Returns `true` if this expression can't be a standalone statement.\n+    fn requires_semi_to_be_stmt(&self) -> bool {\n+        use Expr::*;\n+        !matches!(\n+            self,\n+            IfExpr(..) | MatchExpr(..) | BlockExpr(..) | WhileExpr(..) | LoopExpr(..) | ForExpr(..)\n+        )\n+    }\n+\n+    /// If an expression ends with `}`, returns the innermost expression ending in this `}`.\n+    fn trailing_brace(mut self) -> Option<Expr> {\n+        use Expr::*;\n+\n+        loop {\n+            let rhs = match self {\n+                RefExpr(e) => e.expr(),\n+                BinExpr(e) => e.rhs(),\n+                BoxExpr(e) => e.expr(),\n+                BreakExpr(e) => e.expr(),\n+                LetExpr(e) => e.expr(),\n+                RangeExpr(e) => e.end(),\n+                ReturnExpr(e) => e.expr(),\n+                PrefixExpr(e) => e.expr(),\n+                YieldExpr(e) => e.expr(),\n+                ClosureExpr(e) => e.body(),\n+\n+                BlockExpr(..) | ForExpr(..) | IfExpr(..) | LoopExpr(..) | MatchExpr(..)\n+                | RecordExpr(..) | WhileExpr(..) => break Some(self),\n+                _ => break None,\n+            };\n+\n+            self = rhs?;\n+        }\n+    }\n+\n+    /// Expressions that syntactically contain an \"exterior\" struct literal i.e., not surrounded by any\n+    /// parens or other delimiters, e.g., `X { y: 1 }`, `X { y: 1 }.method()`, `foo == X { y: 1 }` and\n+    /// `X { y: 1 } == foo` all do, but `(X { y: 1 }) == foo` does not.\n+    fn contains_exterior_struct_lit(&self) -> bool {\n+        return contains_exterior_struct_lit_inner(self).is_some();\n+\n+        fn contains_exterior_struct_lit_inner(expr: &Expr) -> Option<()> {\n+            use Expr::*;\n+\n+            match expr {\n+                RecordExpr(..) => Some(()),\n+\n+                // X { y: 1 } + X { y: 2 }\n+                BinExpr(e) => e\n+                    .lhs()\n+                    .as_ref()\n+                    .and_then(contains_exterior_struct_lit_inner)\n+                    .or_else(|| e.rhs().as_ref().and_then(contains_exterior_struct_lit_inner)),\n+\n+                // `&X { y: 1 }`, `X { y: 1 }.y`, `X { y: 1 }.bar(...)`, etc\n+                IndexExpr(e) => contains_exterior_struct_lit_inner(&e.base()?),\n+                AwaitExpr(e) => contains_exterior_struct_lit_inner(&e.expr()?),\n+                PrefixExpr(e) => contains_exterior_struct_lit_inner(&e.expr()?),\n+                CastExpr(e) => contains_exterior_struct_lit_inner(&e.expr()?),\n+                FieldExpr(e) => contains_exterior_struct_lit_inner(&e.expr()?),\n+                MethodCallExpr(e) => contains_exterior_struct_lit_inner(&e.receiver()?),\n+\n+                _ => None,\n+            }\n+        }\n+    }\n+\n+    /// Returns true if self is one of `return`, `break`, `continue` or `yield` with **no associated value**.\n+    fn is_ret_like_with_no_value(&self) -> bool {\n+        use Expr::*;\n+\n+        match self {\n+            ReturnExpr(e) => e.expr().is_none(),\n+            BreakExpr(e) => e.expr().is_none(),\n+            ContinueExpr(_) => true,\n+            YieldExpr(e) => e.expr().is_none(),\n+            _ => false,\n+        }\n+    }\n+\n+    fn is_ordered_before(&self, other: &Expr) -> bool {\n+        use Expr::*;\n+\n+        return order(self) < order(other);\n+\n+        /// Returns text range that can be used to compare two expression for order (which goes first).\n+        fn order(this: &Expr) -> rowan::TextSize {\n+            // For non-paren-like operators: get the operator itself\n+            let token = match this {\n+                RangeExpr(e) => e.op_token(),\n+                BinExpr(e) => e.op_token(),\n+                CastExpr(e) => e.as_token(),\n+                FieldExpr(e) => e.dot_token(),\n+                AwaitExpr(e) => e.dot_token(),\n+                BoxExpr(e) => e.box_token(),\n+                BreakExpr(e) => e.break_token(),\n+                CallExpr(e) => e.arg_list().and_then(|args| args.l_paren_token()),\n+                ClosureExpr(e) => e.param_list().and_then(|params| params.l_paren_token()),\n+                ContinueExpr(e) => e.continue_token(),\n+                IndexExpr(e) => e.l_brack_token(),\n+                MethodCallExpr(e) => e.dot_token(),\n+                PrefixExpr(e) => e.op_token(),\n+                RefExpr(e) => e.amp_token(),\n+                ReturnExpr(e) => e.return_token(),\n+                TryExpr(e) => e.question_mark_token(),\n+                YieldExpr(e) => e.yield_token(),\n+                LetExpr(e) => e.let_token(),\n+\n+                ArrayExpr(_) | TupleExpr(_) | Literal(_) | PathExpr(_) | ParenExpr(_)\n+                | IfExpr(_) | WhileExpr(_) | ForExpr(_) | LoopExpr(_) | MatchExpr(_)\n+                | BlockExpr(_) | RecordExpr(_) | UnderscoreExpr(_) | MacroExpr(_) => None,\n+            };\n+\n+            token.map(|t| t.text_range()).unwrap_or_else(|| this.syntax().text_range()).start()\n+        }\n+    }\n+\n+    fn child_is_followed_by_a_block(&self) -> bool {\n+        use Expr::*;\n+\n+        match self {\n+            ArrayExpr(_) | AwaitExpr(_) | BlockExpr(_) | CallExpr(_) | CastExpr(_)\n+            | ClosureExpr(_) | FieldExpr(_) | IndexExpr(_) | Literal(_) | LoopExpr(_)\n+            | MacroExpr(_) | MethodCallExpr(_) | ParenExpr(_) | PathExpr(_) | RecordExpr(_)\n+            | TryExpr(_) | TupleExpr(_) | UnderscoreExpr(_) => false,\n+\n+            // For BinExpr and RangeExpr this is technically wrong -- the child can be on the left...\n+            BinExpr(_) | RangeExpr(_) | BoxExpr(_) | BreakExpr(_) | ContinueExpr(_)\n+            | PrefixExpr(_) | RefExpr(_) | ReturnExpr(_) | YieldExpr(_) | LetExpr(_) => self\n+                .syntax()\n+                .parent()\n+                .and_then(Expr::cast)\n+                .map(|e| e.child_is_followed_by_a_block())\n+                .unwrap_or(false),\n \n-        Some(prec)\n+            ForExpr(_) | IfExpr(_) | MatchExpr(_) | WhileExpr(_) => true,\n+        }\n     }\n }"}]}