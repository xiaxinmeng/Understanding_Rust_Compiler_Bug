{"sha": "44db7c3b5af658370e5e55d8b7f6338cce225538", "node_id": "C_kwDOAAsO6NoAKDQ0ZGI3YzNiNWFmNjU4MzcwZTVlNTVkOGI3ZjYzMzhjY2UyMjU1Mzg", "commit": {"author": {"name": "Matthias Kr\u00fcger", "email": "matthias.krueger@famsik.de", "date": "2023-04-14T05:58:40Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2023-04-14T05:58:40Z"}, "message": "Rollup merge of #110180 - lcnr:canonicalize, r=compiler-errors\n\ndon't uniquify regions when canonicalizing\n\nuniquifying causes a bunch of issues, most notably it causes `AliasEq(<?x as Trait<'a>>::Assoc, <?x as Trait<'a>>::Assoc)` to result in ambiguity because both `normalizes-to` paths result in ambiguity and substs equate should trivially succeed but doesn't because we uniquified `'a` to two different regions.\n\nI originally added uniquification to make it easier to deal with requirement 6 from the dev-guide: https://rustc-dev-guide.rust-lang.org/solve/trait-solving.html#requirements\n\n> ### 6. Trait solving must be (free) lifetime agnostic\n>\n> Trait solving during codegen should have the same result as during typeck. As we erase\n> all free regions during codegen we must not rely on them during typeck. A noteworthy example\n> is special behavior for `'static`.\n\ncc https://github.com/rust-lang/rustc-dev-guide/pull/1671\n\nRelying on regions being identical may cause ICE during MIR typeck, but even without this PR we can end up relying on that as type inference vars can resolve to types which contain an identical region. Let's land this and deal with any ICE that crop up as we go. Will look at this issue again before stabilization.\n\nr? ```@compiler-errors```", "tree": {"sha": "344d4300eef7300b52f7a4b8057c21d54ed9e06a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/344d4300eef7300b52f7a4b8057c21d54ed9e06a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/44db7c3b5af658370e5e55d8b7f6338cce225538", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJkOOuQCRBK7hj4Ov3rIwAAG1sIAF/EoDKpo18dfqfn2p6rNQGW\n1pwvL0YnjSXdvNflbrff+DEre9dG50PnFIc3wS7juWbIr2CYb5OjOxlyi7BI2dro\na2LQjfjhccU62Kjr7u99qaZ7Xy4rFFRzJDm4tLLa79ZFUuRsY11l1gqtObFYMZiT\n0tr1RFZtAeJP0ozZgZVaxrBDFV8gOVuCFW7t9VifQ32Z/bNEEDoWgux+LpP0Wzdn\naPAy34ddwpdktdzNrRFqXcrRaSx2wmwOWnEymCpHkbzEqfUDSop0sjLTucfOesni\n7IXjiCBn4i5tfkX9zrTO1HaVaUkHBboZ2jJxWqeLa/rlcXdDVmoMwIcyZNLsynk=\n=EMY3\n-----END PGP SIGNATURE-----\n", "payload": "tree 344d4300eef7300b52f7a4b8057c21d54ed9e06a\nparent 2e39e15e40d988f5d412b67dc1c2338aeb53a384\nparent c68c6c3942d8c3aab4d9e9406a0a4473218f8cea\nauthor Matthias Kr\u00fcger <matthias.krueger@famsik.de> 1681451920 +0200\ncommitter GitHub <noreply@github.com> 1681451920 +0200\n\nRollup merge of #110180 - lcnr:canonicalize, r=compiler-errors\n\ndon't uniquify regions when canonicalizing\n\nuniquifying causes a bunch of issues, most notably it causes `AliasEq(<?x as Trait<'a>>::Assoc, <?x as Trait<'a>>::Assoc)` to result in ambiguity because both `normalizes-to` paths result in ambiguity and substs equate should trivially succeed but doesn't because we uniquified `'a` to two different regions.\n\nI originally added uniquification to make it easier to deal with requirement 6 from the dev-guide: https://rustc-dev-guide.rust-lang.org/solve/trait-solving.html#requirements\n\n> ### 6. Trait solving must be (free) lifetime agnostic\n>\n> Trait solving during codegen should have the same result as during typeck. As we erase\n> all free regions during codegen we must not rely on them during typeck. A noteworthy example\n> is special behavior for `'static`.\n\ncc https://github.com/rust-lang/rustc-dev-guide/pull/1671\n\nRelying on regions being identical may cause ICE during MIR typeck, but even without this PR we can end up relying on that as type inference vars can resolve to types which contain an identical region. Let's land this and deal with any ICE that crop up as we go. Will look at this issue again before stabilization.\n\nr? ```@compiler-errors```\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/44db7c3b5af658370e5e55d8b7f6338cce225538", "html_url": "https://github.com/rust-lang/rust/commit/44db7c3b5af658370e5e55d8b7f6338cce225538", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/44db7c3b5af658370e5e55d8b7f6338cce225538/comments", "author": {"login": "matthiaskrgr", "id": 476013, "node_id": "MDQ6VXNlcjQ3NjAxMw==", "avatar_url": "https://avatars.githubusercontent.com/u/476013?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matthiaskrgr", "html_url": "https://github.com/matthiaskrgr", "followers_url": "https://api.github.com/users/matthiaskrgr/followers", "following_url": "https://api.github.com/users/matthiaskrgr/following{/other_user}", "gists_url": "https://api.github.com/users/matthiaskrgr/gists{/gist_id}", "starred_url": "https://api.github.com/users/matthiaskrgr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matthiaskrgr/subscriptions", "organizations_url": "https://api.github.com/users/matthiaskrgr/orgs", "repos_url": "https://api.github.com/users/matthiaskrgr/repos", "events_url": "https://api.github.com/users/matthiaskrgr/events{/privacy}", "received_events_url": "https://api.github.com/users/matthiaskrgr/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2e39e15e40d988f5d412b67dc1c2338aeb53a384", "url": "https://api.github.com/repos/rust-lang/rust/commits/2e39e15e40d988f5d412b67dc1c2338aeb53a384", "html_url": "https://github.com/rust-lang/rust/commit/2e39e15e40d988f5d412b67dc1c2338aeb53a384"}, {"sha": "c68c6c3942d8c3aab4d9e9406a0a4473218f8cea", "url": "https://api.github.com/repos/rust-lang/rust/commits/c68c6c3942d8c3aab4d9e9406a0a4473218f8cea", "html_url": "https://github.com/rust-lang/rust/commit/c68c6c3942d8c3aab4d9e9406a0a4473218f8cea"}], "stats": {"total": 364, "additions": 23, "deletions": 341}, "files": [{"sha": "976849696e33a92b68b016e2759696c29822fc54", "filename": "compiler/rustc_trait_selection/src/solve/canonicalize.rs", "status": "modified", "additions": 11, "deletions": 14, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/44db7c3b5af658370e5e55d8b7f6338cce225538/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fcanonicalize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44db7c3b5af658370e5e55d8b7f6338cce225538/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fcanonicalize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fcanonicalize.rs?ref=44db7c3b5af658370e5e55d8b7f6338cce225538", "patch": "@@ -125,8 +125,9 @@ impl<'a, 'tcx> Canonicalizer<'a, 'tcx> {\n         // - var_infos: [E0, U1, E1, U1, E1, E6, U6], curr_compressed_uv: 1, next_orig_uv: 6\n         // - var_infos: [E0, U1, E1, U1, E1, E2, U2], curr_compressed_uv: 2, next_orig_uv: -\n         //\n-        // This algorithm runs in `O(n\u00b2)` where `n` is the number of different universe\n-        // indices in the input. This should be fine as `n` is expected to be small.\n+        // This algorithm runs in `O(nm)` where `n` is the number of different universe\n+        // indices in the input and `m` is the number of canonical variables.\n+        // This should be fine as both `n` and `m` are expected to be small.\n         let mut curr_compressed_uv = ty::UniverseIndex::ROOT;\n         let mut existential_in_new_uv = false;\n         let mut next_orig_uv = Some(ty::UniverseIndex::ROOT);\n@@ -245,18 +246,14 @@ impl<'tcx> TypeFolder<TyCtxt<'tcx>> for Canonicalizer<'_, 'tcx> {\n             ty::ReError(_) => return r,\n         };\n \n-        let existing_bound_var = match self.canonicalize_mode {\n-            CanonicalizeMode::Input => None,\n-            CanonicalizeMode::Response { .. } => {\n-                self.variables.iter().position(|&v| v == r.into()).map(ty::BoundVar::from)\n-            }\n-        };\n-        let var = existing_bound_var.unwrap_or_else(|| {\n-            let var = ty::BoundVar::from(self.variables.len());\n-            self.variables.push(r.into());\n-            self.primitive_var_infos.push(CanonicalVarInfo { kind });\n-            var\n-        });\n+        let var = ty::BoundVar::from(\n+            self.variables.iter().position(|&v| v == r.into()).unwrap_or_else(|| {\n+                let var = self.variables.len();\n+                self.variables.push(r.into());\n+                self.primitive_var_infos.push(CanonicalVarInfo { kind });\n+                var\n+            }),\n+        );\n         let br = ty::BoundRegion { var, kind: BrAnon(None) };\n         self.interner().mk_re_late_bound(self.binder_index, br)\n     }"}, {"sha": "6449337eea4e7ee1978dfa0b2faa654027b1054f", "filename": "tests/ui/regions/issue-2718.rs", "status": "removed", "additions": 0, "deletions": 327, "changes": 327, "blob_url": "https://github.com/rust-lang/rust/blob/2e39e15e40d988f5d412b67dc1c2338aeb53a384/tests%2Fui%2Fregions%2Fissue-2718.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e39e15e40d988f5d412b67dc1c2338aeb53a384/tests%2Fui%2Fregions%2Fissue-2718.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fregions%2Fissue-2718.rs?ref=2e39e15e40d988f5d412b67dc1c2338aeb53a384", "patch": "@@ -1,327 +0,0 @@\n-// run-pass\n-#![allow(dead_code)]\n-#![allow(unused_unsafe)]\n-#![allow(unused_imports)]\n-#![allow(non_camel_case_types)]\n-\n-pub type Task = isize;\n-\n-// tjc: I don't know why\n-pub mod pipes {\n-    use self::state::{empty, full, blocked, terminated};\n-    use super::Task;\n-    use std::mem::{forget, transmute};\n-    use std::mem::{replace, swap};\n-    use std::mem;\n-    use std::thread;\n-    use std::marker::Send;\n-\n-    pub struct Stuff<T> {\n-        state: state,\n-        blocked_task: Option<Task>,\n-        payload: Option<T>\n-    }\n-\n-    #[derive(PartialEq, Debug)]\n-    #[repr(isize)]\n-    pub enum state {\n-        empty,\n-        full,\n-        blocked,\n-        terminated\n-    }\n-\n-    pub struct packet<T> {\n-        state: state,\n-        blocked_task: Option<Task>,\n-        payload: Option<T>\n-    }\n-\n-    unsafe impl<T:Send> Send for packet<T> {}\n-\n-    pub fn packet<T:Send>() -> *const packet<T> {\n-        unsafe {\n-            let p: *const packet<T> = mem::transmute(Box::new(Stuff{\n-                state: empty,\n-                blocked_task: None::<Task>,\n-                payload: None::<T>\n-            }));\n-            p\n-        }\n-    }\n-\n-    mod rusti {\n-      pub fn atomic_xchg(_dst: &mut isize, _src: isize) -> isize { panic!(); }\n-      pub fn atomic_xchg_acq(_dst: &mut isize, _src: isize) -> isize { panic!(); }\n-      pub fn atomic_xchg_rel(_dst: &mut isize, _src: isize) -> isize { panic!(); }\n-    }\n-\n-    // We should consider moving this to ::std::unsafe, although I\n-    // suspect graydon would want us to use void pointers instead.\n-    pub unsafe fn uniquify<T>(x: *const T) -> Box<T> {\n-        mem::transmute(x)\n-    }\n-\n-    pub fn swap_state_acq(dst: &mut state, src: state) -> state {\n-        unsafe {\n-            transmute(rusti::atomic_xchg_acq(transmute(dst), src as isize))\n-        }\n-    }\n-\n-    pub fn swap_state_rel(dst: &mut state, src: state) -> state {\n-        unsafe {\n-            transmute(rusti::atomic_xchg_rel(transmute(dst), src as isize))\n-        }\n-    }\n-\n-    pub fn send<T:Send>(mut p: send_packet<T>, payload: T) {\n-        let p = p.unwrap();\n-        let mut p = unsafe { uniquify(p) };\n-        assert!((*p).payload.is_none());\n-        (*p).payload = Some(payload);\n-        let old_state = swap_state_rel(&mut (*p).state, full);\n-        match old_state {\n-          empty => {\n-            // Yay, fastpath.\n-\n-            // The receiver will eventually clean this up.\n-            unsafe { forget(p); }\n-          }\n-          full => { panic!(\"duplicate send\") }\n-          blocked => {\n-\n-            // The receiver will eventually clean this up.\n-            unsafe { forget(p); }\n-          }\n-          terminated => {\n-            // The receiver will never receive this. Rely on drop_glue\n-            // to clean everything up.\n-          }\n-        }\n-    }\n-\n-    pub fn recv<T:Send>(mut p: recv_packet<T>) -> Option<T> {\n-        let p = p.unwrap();\n-        let mut p = unsafe { uniquify(p) };\n-        loop {\n-            let old_state = swap_state_acq(&mut (*p).state,\n-                                           blocked);\n-            match old_state {\n-              empty | blocked => { thread::yield_now(); }\n-              full => {\n-                let payload = replace(&mut p.payload, None);\n-                return Some(payload.unwrap())\n-              }\n-              terminated => {\n-                assert_eq!(old_state, terminated);\n-                return None;\n-              }\n-            }\n-        }\n-    }\n-\n-    pub fn sender_terminate<T:Send>(p: *const packet<T>) {\n-        let mut p = unsafe { uniquify(p) };\n-        match swap_state_rel(&mut (*p).state, terminated) {\n-          empty | blocked => {\n-            // The receiver will eventually clean up.\n-            unsafe { forget(p) }\n-          }\n-          full => {\n-            // This is impossible\n-            panic!(\"you dun goofed\")\n-          }\n-          terminated => {\n-            // I have to clean up, use drop_glue\n-          }\n-        }\n-    }\n-\n-    pub fn receiver_terminate<T:Send>(p: *const packet<T>) {\n-        let mut p = unsafe { uniquify(p) };\n-        match swap_state_rel(&mut (*p).state, terminated) {\n-          empty => {\n-            // the sender will clean up\n-            unsafe { forget(p) }\n-          }\n-          blocked => {\n-            // this shouldn't happen.\n-            panic!(\"terminating a blocked packet\")\n-          }\n-          terminated | full => {\n-            // I have to clean up, use drop_glue\n-          }\n-        }\n-    }\n-\n-    pub struct send_packet<T:Send> {\n-        p: Option<*const packet<T>>,\n-    }\n-\n-    impl<T:Send> Drop for send_packet<T> {\n-        fn drop(&mut self) {\n-            unsafe {\n-                if self.p != None {\n-                    let self_p: &mut Option<*const packet<T>> =\n-                        mem::transmute(&mut self.p);\n-                    let p = replace(self_p, None);\n-                    sender_terminate(p.unwrap())\n-                }\n-            }\n-        }\n-    }\n-\n-    impl<T:Send> send_packet<T> {\n-        pub fn unwrap(&mut self) -> *const packet<T> {\n-            replace(&mut self.p, None).unwrap()\n-        }\n-    }\n-\n-    pub fn send_packet<T:Send>(p: *const packet<T>) -> send_packet<T> {\n-        send_packet {\n-            p: Some(p)\n-        }\n-    }\n-\n-    pub struct recv_packet<T:Send> {\n-        p: Option<*const packet<T>>,\n-    }\n-\n-    impl<T:Send> Drop for recv_packet<T> {\n-        fn drop(&mut self) {\n-            unsafe {\n-                if self.p != None {\n-                    let self_p: &mut Option<*const packet<T>> =\n-                        mem::transmute(&mut self.p);\n-                    let p = replace(self_p, None);\n-                    receiver_terminate(p.unwrap())\n-                }\n-            }\n-        }\n-    }\n-\n-    impl<T:Send> recv_packet<T> {\n-        pub fn unwrap(&mut self) -> *const packet<T> {\n-            replace(&mut self.p, None).unwrap()\n-        }\n-    }\n-\n-    pub fn recv_packet<T:Send>(p: *const packet<T>) -> recv_packet<T> {\n-        recv_packet {\n-            p: Some(p)\n-        }\n-    }\n-\n-    pub fn entangle<T:Send>() -> (send_packet<T>, recv_packet<T>) {\n-        let p = packet();\n-        (send_packet(p), recv_packet(p))\n-    }\n-}\n-\n-pub mod pingpong {\n-    use std::mem;\n-\n-    pub struct ping(::pipes::send_packet<pong>);\n-\n-    unsafe impl Send for ping {}\n-\n-    pub struct pong(::pipes::send_packet<ping>);\n-\n-    unsafe impl Send for pong {}\n-\n-    pub fn liberate_ping(p: ping) -> ::pipes::send_packet<pong> {\n-        unsafe {\n-            let _addr : *const ::pipes::send_packet<pong> = match &p {\n-              &ping(ref x) => { mem::transmute(x) }\n-            };\n-            panic!()\n-        }\n-    }\n-\n-    pub fn liberate_pong(p: pong) -> ::pipes::send_packet<ping> {\n-        unsafe {\n-            let _addr : *const ::pipes::send_packet<ping> = match &p {\n-              &pong(ref x) => { mem::transmute(x) }\n-            };\n-            panic!()\n-        }\n-    }\n-\n-    pub fn init() -> (client::ping, server::ping) {\n-        ::pipes::entangle()\n-    }\n-\n-    pub mod client {\n-        use pingpong;\n-\n-        pub type ping = ::pipes::send_packet<pingpong::ping>;\n-        pub type pong = ::pipes::recv_packet<pingpong::pong>;\n-\n-        pub fn do_ping(c: ping) -> pong {\n-            let (sp, rp) = ::pipes::entangle();\n-\n-            ::pipes::send(c, pingpong::ping(sp));\n-            rp\n-        }\n-\n-        pub fn do_pong(c: pong) -> (ping, ()) {\n-            let packet = ::pipes::recv(c);\n-            if packet.is_none() {\n-                panic!(\"sender closed the connection\")\n-            }\n-            (pingpong::liberate_pong(packet.unwrap()), ())\n-        }\n-    }\n-\n-    pub mod server {\n-        use pingpong;\n-\n-        pub type ping = ::pipes::recv_packet<pingpong::ping>;\n-        pub type pong = ::pipes::send_packet<pingpong::pong>;\n-\n-        pub fn do_ping(c: ping) -> (pong, ()) {\n-            let packet = ::pipes::recv(c);\n-            if packet.is_none() {\n-                panic!(\"sender closed the connection\")\n-            }\n-            (pingpong::liberate_ping(packet.unwrap()), ())\n-        }\n-\n-        pub fn do_pong(c: pong) -> ping {\n-            let (sp, rp) = ::pipes::entangle();\n-            ::pipes::send(c, pingpong::pong(sp));\n-            rp\n-        }\n-    }\n-}\n-\n-fn client(chan: pingpong::client::ping) {\n-    let chan = pingpong::client::do_ping(chan);\n-    println!(\"Sent ping\");\n-    let (_chan, _data) = pingpong::client::do_pong(chan);\n-    println!(\"Received pong\");\n-}\n-\n-fn server(chan: pingpong::server::ping) {\n-    let (chan, _data) = pingpong::server::do_ping(chan);\n-    println!(\"Received ping\");\n-    let _chan = pingpong::server::do_pong(chan);\n-    println!(\"Sent pong\");\n-}\n-\n-pub fn main() {\n-  /*\n-//    Commented out because of option::get error\n-\n-    let (client_, server_) = pingpong::init();\n-\n-    task::spawn {|client_|\n-        let client__ = client_.take();\n-        client(client__);\n-    };\n-    task::spawn {|server_|\n-        let server__ = server_.take();\n-        server(server_\u02ca);\n-    };\n-  */\n-}"}, {"sha": "8fb62323aa5a7637136396d833a0f25d2481d5fd", "filename": "tests/ui/traits/new-solver/iter-filter-projection.rs", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/44db7c3b5af658370e5e55d8b7f6338cce225538/tests%2Fui%2Ftraits%2Fnew-solver%2Fiter-filter-projection.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44db7c3b5af658370e5e55d8b7f6338cce225538/tests%2Fui%2Ftraits%2Fnew-solver%2Fiter-filter-projection.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ftraits%2Fnew-solver%2Fiter-filter-projection.rs?ref=44db7c3b5af658370e5e55d8b7f6338cce225538", "patch": "@@ -0,0 +1,12 @@\n+// compile-flags: -Ztrait-solver=next\n+// check-pass\n+\n+use std::{iter, slice};\n+\n+struct Attr;\n+\n+fn test<'a, T: Iterator<Item = &'a Attr>>() {}\n+\n+fn main() {\n+    test::<iter::Filter<slice::Iter<'_, Attr>, fn(&&Attr) -> bool>>();\n+}"}]}