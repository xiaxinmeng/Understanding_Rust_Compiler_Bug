{"sha": "c7df1f530b8a88f471e60e933868e7ddf456974d", "node_id": "MDY6Q29tbWl0NzI0NzEyOmM3ZGYxZjUzMGI4YTg4ZjQ3MWU2MGU5MzM4NjhlN2RkZjQ1Njk3NGQ=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-09-26T18:16:55Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-09-26T18:16:55Z"}, "message": "Auto merge of #54453 - nikomatsakis:nll-issue-53121-shred-outlives, r=pnkfelix\n\nrework how we handle outlives relationships\n\nWhen we encounter an outlives relationship involving a projection, we use to over-constrain in some cases with region constraints. We also used to evaluate whether the where-clauses in the environment might apply **before** running inference.\n\nWe now avoid doing both of those things:\n\n- If there are where-clauses in the environment that might be useful, we add no constraints.\n- After inference is done, we check if we wound up inferring values compatible with the where-clause, and make use of them if so.\n\nI realize now that this PR includes some meandering commits and refactorings from when I expected to go in a different direction. If desired, I could try to remove some of those.\n\nFixes #53121\nFixes #53789\n\nr? @pnkfelix", "tree": {"sha": "22288860be8301603259bc04dd40ca13cf77b1f2", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/22288860be8301603259bc04dd40ca13cf77b1f2"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c7df1f530b8a88f471e60e933868e7ddf456974d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c7df1f530b8a88f471e60e933868e7ddf456974d", "html_url": "https://github.com/rust-lang/rust/commit/c7df1f530b8a88f471e60e933868e7ddf456974d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c7df1f530b8a88f471e60e933868e7ddf456974d/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6846f22a13c7c896e86714736d597128fdfea94d", "url": "https://api.github.com/repos/rust-lang/rust/commits/6846f22a13c7c896e86714736d597128fdfea94d", "html_url": "https://github.com/rust-lang/rust/commit/6846f22a13c7c896e86714736d597128fdfea94d"}, {"sha": "f23fd4bc029fccbcb3e56507cac8cde90a81128c", "url": "https://api.github.com/repos/rust-lang/rust/commits/f23fd4bc029fccbcb3e56507cac8cde90a81128c", "html_url": "https://github.com/rust-lang/rust/commit/f23fd4bc029fccbcb3e56507cac8cde90a81128c"}], "stats": {"total": 4176, "additions": 2573, "deletions": 1603}, "files": [{"sha": "e3bbdab4fd9659db1a3b0f64fc82f2e397045684", "filename": "src/librustc/infer/error_reporting/mod.rs", "status": "modified", "additions": 73, "deletions": 76, "changes": 149, "blob_url": "https://github.com/rust-lang/rust/blob/c7df1f530b8a88f471e60e933868e7ddf456974d/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7df1f530b8a88f471e60e933868e7ddf456974d/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fmod.rs?ref=c7df1f530b8a88f471e60e933868e7ddf456974d", "patch": "@@ -55,23 +55,22 @@\n //! ported to this system, and which relies on string concatenation at the\n //! time of error detection.\n \n-use infer;\n-use super::{InferCtxt, RegionVariableOrigin, SubregionOrigin, TypeTrace, ValuePairs};\n-use super::region_constraints::GenericKind;\n use super::lexical_region_resolve::RegionResolutionError;\n+use super::region_constraints::GenericKind;\n+use super::{InferCtxt, RegionVariableOrigin, SubregionOrigin, TypeTrace, ValuePairs};\n+use infer::{self, SuppressRegionErrors};\n \n-use std::{cmp, fmt};\n+use errors::{Applicability, DiagnosticBuilder, DiagnosticStyledString};\n use hir;\n-use hir::Node;\n use hir::def_id::DefId;\n+use hir::Node;\n use middle::region;\n-use traits::{ObligationCause, ObligationCauseCode};\n-use ty::{self, subst::Subst, Region, Ty, TyCtxt, TypeFoldable, TyKind};\n-use ty::error::TypeError;\n-use session::config::BorrowckMode;\n+use std::{cmp, fmt};\n use syntax::ast::DUMMY_NODE_ID;\n use syntax_pos::{Pos, Span};\n-use errors::{Applicability, DiagnosticBuilder, DiagnosticStyledString};\n+use traits::{ObligationCause, ObligationCauseCode};\n+use ty::error::TypeError;\n+use ty::{self, subst::Subst, Region, Ty, TyCtxt, TyKind, TypeFoldable};\n \n mod note;\n \n@@ -153,8 +152,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n             }\n \n             // We shouldn't encounter an error message with ReClosureBound.\n-            ty::ReCanonical(..) |\n-            ty::ReClosureBound(..) => {\n+            ty::ReCanonical(..) | ty::ReClosureBound(..) => {\n                 bug!(\"encountered unexpected ReClosureBound: {:?}\", region,);\n             }\n         };\n@@ -176,9 +174,9 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n \n     fn msg_span_from_free_region(self, region: ty::Region<'tcx>) -> (String, Option<Span>) {\n         match *region {\n-            ty::ReEarlyBound(_) | ty::ReFree(_)  => {\n+            ty::ReEarlyBound(_) | ty::ReFree(_) => {\n                 self.msg_span_from_early_bound_and_free_regions(region)\n-            },\n+            }\n             ty::ReStatic => (\"the static lifetime\".to_owned(), None),\n             _ => bug!(\"{:?}\", region),\n         }\n@@ -197,25 +195,28 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n             Some(Node::Item(it)) => Self::item_scope_tag(&it),\n             Some(Node::TraitItem(it)) => Self::trait_item_scope_tag(&it),\n             Some(Node::ImplItem(it)) => Self::impl_item_scope_tag(&it),\n-            _ => unreachable!()\n+            _ => unreachable!(),\n         };\n         let (prefix, span) = match *region {\n             ty::ReEarlyBound(ref br) => {\n                 let mut sp = cm.def_span(self.hir.span(node));\n-                if let Some(param) = self.hir.get_generics(scope).and_then(|generics| {\n-                    generics.get_named(&br.name)\n-                }) {\n+                if let Some(param) = self.hir\n+                    .get_generics(scope)\n+                    .and_then(|generics| generics.get_named(&br.name))\n+                {\n                     sp = param.span;\n                 }\n                 (format!(\"the lifetime {} as defined on\", br.name), sp)\n             }\n             ty::ReFree(ty::FreeRegion {\n-                bound_region: ty::BoundRegion::BrNamed(_, ref name), ..\n+                bound_region: ty::BoundRegion::BrNamed(_, ref name),\n+                ..\n             }) => {\n                 let mut sp = cm.def_span(self.hir.span(node));\n-                if let Some(param) = self.hir.get_generics(scope).and_then(|generics| {\n-                    generics.get_named(&name)\n-                }) {\n+                if let Some(param) = self.hir\n+                    .get_generics(scope)\n+                    .and_then(|generics| generics.get_named(&name))\n+                {\n                     sp = param.span;\n                 }\n                 (format!(\"the lifetime {} as defined on\", name), sp)\n@@ -278,9 +279,9 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n     fn impl_item_scope_tag(item: &hir::ImplItem) -> &'static str {\n         match item.node {\n             hir::ImplItemKind::Method(..) => \"method body\",\n-            hir::ImplItemKind::Const(..) |\n-            hir::ImplItemKind::Existential(..) |\n-            hir::ImplItemKind::Type(..) => \"associated item\",\n+            hir::ImplItemKind::Const(..)\n+            | hir::ImplItemKind::Existential(..)\n+            | hir::ImplItemKind::Type(..) => \"associated item\",\n         }\n     }\n \n@@ -298,20 +299,16 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n         &self,\n         region_scope_tree: &region::ScopeTree,\n         errors: &Vec<RegionResolutionError<'tcx>>,\n-        will_later_be_reported_by_nll: bool,\n+        suppress: SuppressRegionErrors,\n     ) {\n-        debug!(\"report_region_errors(): {} errors to start\", errors.len());\n-\n-        // If the errors will later be reported by NLL, choose wether to display them or not based\n-        // on the borrowck mode\n-        if will_later_be_reported_by_nll {\n-            match self.tcx.borrowck_mode() {\n-                // If we're on AST or Migrate mode, report AST region errors\n-                BorrowckMode::Ast | BorrowckMode::Migrate => {},\n-                // If we're on MIR or Compare mode, don't report AST region errors as they should\n-                // be reported by NLL\n-                BorrowckMode::Compare | BorrowckMode::Mir => return,\n-            }\n+        debug!(\n+            \"report_region_errors(): {} errors to start, suppress = {:?}\",\n+            errors.len(),\n+            suppress\n+        );\n+\n+        if suppress.suppressed() {\n+            return;\n         }\n \n         // try to pre-process the errors, which will group some of them\n@@ -482,17 +479,18 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                     } else {\n                         err.span_label(arm_span, msg);\n                     }\n-                },\n-                hir::MatchSource::TryDesugar => { // Issue #51632\n+                }\n+                hir::MatchSource::TryDesugar => {\n+                    // Issue #51632\n                     if let Ok(try_snippet) = self.tcx.sess.source_map().span_to_snippet(arm_span) {\n                         err.span_suggestion_with_applicability(\n                             arm_span,\n                             \"try wrapping with a success variant\",\n                             format!(\"Ok({})\", try_snippet),\n-                            Applicability::MachineApplicable\n+                            Applicability::MachineApplicable,\n                         );\n                     }\n-                },\n+                }\n                 _ => {\n                     let msg = \"match arm with an incompatible type\";\n                     if self.tcx.sess.source_map().is_multiline(arm_span) {\n@@ -641,16 +639,21 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n     fn strip_generic_default_params(\n         &self,\n         def_id: DefId,\n-        substs: &ty::subst::Substs<'tcx>\n+        substs: &ty::subst::Substs<'tcx>,\n     ) -> &'tcx ty::subst::Substs<'tcx> {\n         let generics = self.tcx.generics_of(def_id);\n         let mut num_supplied_defaults = 0;\n-        let mut type_params = generics.params.iter().rev().filter_map(|param| match param.kind {\n-            ty::GenericParamDefKind::Lifetime => None,\n-            ty::GenericParamDefKind::Type { has_default, .. } => {\n-                Some((param.def_id, has_default))\n-            }\n-        }).peekable();\n+        let mut type_params = generics\n+            .params\n+            .iter()\n+            .rev()\n+            .filter_map(|param| match param.kind {\n+                ty::GenericParamDefKind::Lifetime => None,\n+                ty::GenericParamDefKind::Type { has_default, .. } => {\n+                    Some((param.def_id, has_default))\n+                }\n+            })\n+            .peekable();\n         let has_default = {\n             let has_default = type_params.peek().map(|(_, has_default)| has_default);\n             *has_default.unwrap_or(&false)\n@@ -684,10 +687,9 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                 | (&ty::Infer(ty::InferTy::IntVar(_)), &ty::Infer(ty::InferTy::IntVar(_)))\n                 | (&ty::Float(_), &ty::Infer(ty::InferTy::FloatVar(_)))\n                 | (&ty::Infer(ty::InferTy::FloatVar(_)), &ty::Float(_))\n-                | (\n-                    &ty::Infer(ty::InferTy::FloatVar(_)),\n-                    &ty::Infer(ty::InferTy::FloatVar(_)),\n-                ) => true,\n+                | (&ty::Infer(ty::InferTy::FloatVar(_)), &ty::Infer(ty::InferTy::FloatVar(_))) => {\n+                    true\n+                }\n                 _ => false,\n             }\n         }\n@@ -703,11 +705,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                 \"&{}{}{}\",\n                 r,\n                 if r == \"\" { \"\" } else { \" \" },\n-                if mutbl == hir::MutMutable {\n-                    \"mut \"\n-                } else {\n-                    \"\"\n-                }\n+                if mutbl == hir::MutMutable { \"mut \" } else { \"\" }\n             ));\n             s.push_normal(ty.to_string());\n         }\n@@ -738,9 +736,12 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                     let common_len = cmp::min(len1, len2);\n                     let remainder1: Vec<_> = sub1.types().skip(common_len).collect();\n                     let remainder2: Vec<_> = sub2.types().skip(common_len).collect();\n-                    let common_default_params =\n-                        remainder1.iter().rev().zip(remainder2.iter().rev())\n-                                               .filter(|(a, b)| a == b).count();\n+                    let common_default_params = remainder1\n+                        .iter()\n+                        .rev()\n+                        .zip(remainder2.iter().rev())\n+                        .filter(|(a, b)| a == b)\n+                        .count();\n                     let len = sub1.len() - common_default_params;\n \n                     // Only draw `<...>` if there're lifetime/type arguments.\n@@ -866,8 +867,9 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n             }\n \n             // When encountering &T != &mut T, highlight only the borrow\n-            (&ty::Ref(r1, ref_ty1, mutbl1),\n-             &ty::Ref(r2, ref_ty2, mutbl2)) if equals(&ref_ty1, &ref_ty2) => {\n+            (&ty::Ref(r1, ref_ty1, mutbl1), &ty::Ref(r2, ref_ty2, mutbl2))\n+                if equals(&ref_ty1, &ref_ty2) =>\n+            {\n                 let mut values = (DiagnosticStyledString::new(), DiagnosticStyledString::new());\n                 push_ty_ref(&r1, ref_ty1, mutbl1, &mut values.0);\n                 push_ty_ref(&r2, ref_ty2, mutbl2, &mut values.1);\n@@ -1068,11 +1070,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n         bound_kind: GenericKind<'tcx>,\n         sub: Region<'tcx>,\n     ) {\n-        self.construct_generic_bound_failure(region_scope_tree,\n-                                             span,\n-                                             origin,\n-                                             bound_kind,\n-                                             sub)\n+        self.construct_generic_bound_failure(region_scope_tree, span, origin, bound_kind, sub)\n             .emit()\n     }\n \n@@ -1083,8 +1081,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n         origin: Option<SubregionOrigin<'tcx>>,\n         bound_kind: GenericKind<'tcx>,\n         sub: Region<'tcx>,\n-    ) -> DiagnosticBuilder<'a>\n-    {\n+    ) -> DiagnosticBuilder<'a> {\n         // Attempt to obtain the span of the parameter so we can\n         // suggest adding an explicit lifetime bound to it.\n         let type_param_span = match (self.in_progress_tables, bound_kind) {\n@@ -1161,8 +1158,10 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                 let tail = if has_lifetimes { \" + \" } else { \"\" };\n                 let suggestion = format!(\"{}: {}{}\", bound_kind, sub, tail);\n                 err.span_suggestion_short_with_applicability(\n-                    sp, consider, suggestion,\n-                    Applicability::MaybeIncorrect // Issue #41966\n+                    sp,\n+                    consider,\n+                    suggestion,\n+                    Applicability::MaybeIncorrect, // Issue #41966\n                 );\n             } else {\n                 err.help(consider);\n@@ -1358,12 +1357,10 @@ impl<'tcx> ObligationCause<'tcx> {\n         match self.code {\n             CompareImplMethodObligation { .. } => Error0308(\"method not compatible with trait\"),\n             MatchExpressionArm { source, .. } => Error0308(match source {\n-                hir::MatchSource::IfLetDesugar { .. } => {\n-                    \"`if let` arms have incompatible types\"\n-                },\n+                hir::MatchSource::IfLetDesugar { .. } => \"`if let` arms have incompatible types\",\n                 hir::MatchSource::TryDesugar => {\n                     \"try expression alternatives have incompatible types\"\n-                },\n+                }\n                 _ => \"match arms have incompatible types\",\n             }),\n             IfExpression => Error0308(\"if and else have incompatible types\"),"}, {"sha": "a8fbfc3b64dfd1e1d63ec40bc02b415bc3bdf882", "filename": "src/librustc/infer/lexical_region_resolve/mod.rs", "status": "modified", "additions": 64, "deletions": 63, "changes": 127, "blob_url": "https://github.com/rust-lang/rust/blob/c7df1f530b8a88f471e60e933868e7ddf456974d/src%2Flibrustc%2Finfer%2Flexical_region_resolve%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7df1f530b8a88f471e60e933868e7ddf456974d/src%2Flibrustc%2Finfer%2Flexical_region_resolve%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Flexical_region_resolve%2Fmod.rs?ref=c7df1f530b8a88f471e60e933868e7ddf456974d", "patch": "@@ -10,23 +10,26 @@\n \n //! The code to do lexical region resolution.\n \n-use infer::SubregionOrigin;\n-use infer::RegionVariableOrigin;\n use infer::region_constraints::Constraint;\n use infer::region_constraints::GenericKind;\n use infer::region_constraints::RegionConstraintData;\n use infer::region_constraints::VarInfos;\n use infer::region_constraints::VerifyBound;\n+use infer::RegionVariableOrigin;\n+use infer::SubregionOrigin;\n use middle::free_region::RegionRelations;\n-use rustc_data_structures::indexed_vec::{Idx, IndexVec};\n use rustc_data_structures::fx::FxHashSet;\n-use rustc_data_structures::graph::implementation::{Graph, Direction, NodeIndex, INCOMING, OUTGOING};\n+use rustc_data_structures::graph::implementation::{\n+    Direction, Graph, NodeIndex, INCOMING, OUTGOING,\n+};\n+use rustc_data_structures::indexed_vec::{Idx, IndexVec};\n use std::fmt;\n use std::u32;\n-use ty::{self, TyCtxt};\n-use ty::{Region, RegionVid};\n+use ty::fold::TypeFoldable;\n+use ty::{self, Ty, TyCtxt};\n use ty::{ReEarlyBound, ReEmpty, ReErased, ReFree, ReStatic};\n use ty::{ReLateBound, ReScope, ReSkolemized, ReVar};\n+use ty::{Region, RegionVid};\n \n mod graphviz;\n \n@@ -108,11 +111,15 @@ struct LexicalResolver<'cx, 'gcx: 'tcx, 'tcx: 'cx> {\n }\n \n impl<'cx, 'gcx, 'tcx> LexicalResolver<'cx, 'gcx, 'tcx> {\n+    fn tcx(&self) -> TyCtxt<'cx, 'gcx, 'tcx> {\n+        self.region_rels.tcx\n+    }\n+\n     fn infer_variable_values(\n         &mut self,\n         errors: &mut Vec<RegionResolutionError<'tcx>>,\n     ) -> LexicalRegionResolutions<'tcx> {\n-        let mut var_data = self.construct_var_data(self.region_rels.tcx);\n+        let mut var_data = self.construct_var_data(self.tcx());\n \n         // Dorky hack to cause `dump_constraints` to only get called\n         // if debug mode is enabled:\n@@ -239,9 +246,7 @@ impl<'cx, 'gcx, 'tcx> LexicalResolver<'cx, 'gcx, 'tcx> {\n \n                 debug!(\n                     \"Expanding value of {:?} from {:?} to {:?}\",\n-                    b_vid,\n-                    cur_region,\n-                    lub\n+                    b_vid, cur_region, lub\n                 );\n \n                 *b_data = VarValue::Value(lub);\n@@ -254,18 +259,17 @@ impl<'cx, 'gcx, 'tcx> LexicalResolver<'cx, 'gcx, 'tcx> {\n         }\n     }\n \n-\n     fn lub_concrete_regions(&self, a: Region<'tcx>, b: Region<'tcx>) -> Region<'tcx> {\n-        let tcx = self.region_rels.tcx;\n+        let tcx = self.tcx();\n         match (a, b) {\n-            (&ty::ReCanonical(..), _) |\n-            (_, &ty::ReCanonical(..)) |\n-            (&ty::ReClosureBound(..), _) |\n-            (_, &ty::ReClosureBound(..)) |\n-            (&ReLateBound(..), _) |\n-            (_, &ReLateBound(..)) |\n-            (&ReErased, _) |\n-            (_, &ReErased) => {\n+            (&ty::ReCanonical(..), _)\n+            | (_, &ty::ReCanonical(..))\n+            | (&ty::ReClosureBound(..), _)\n+            | (_, &ty::ReClosureBound(..))\n+            | (&ReLateBound(..), _)\n+            | (_, &ReLateBound(..))\n+            | (&ReErased, _)\n+            | (_, &ReErased) => {\n                 bug!(\"cannot relate region: LUB({:?}, {:?})\", a, b);\n             }\n \n@@ -287,20 +291,20 @@ impl<'cx, 'gcx, 'tcx> LexicalResolver<'cx, 'gcx, 'tcx> {\n                 );\n             }\n \n-            (&ReEarlyBound(_), &ReScope(s_id)) |\n-            (&ReScope(s_id), &ReEarlyBound(_)) |\n-            (&ReFree(_), &ReScope(s_id)) |\n-            (&ReScope(s_id), &ReFree(_)) => {\n+            (&ReEarlyBound(_), &ReScope(s_id))\n+            | (&ReScope(s_id), &ReEarlyBound(_))\n+            | (&ReFree(_), &ReScope(s_id))\n+            | (&ReScope(s_id), &ReFree(_)) => {\n                 // A \"free\" region can be interpreted as \"some region\n                 // at least as big as fr.scope\".  So, we can\n                 // reasonably compare free regions and scopes:\n                 let fr_scope = match (a, b) {\n                     (&ReEarlyBound(ref br), _) | (_, &ReEarlyBound(ref br)) => self.region_rels\n                         .region_scope_tree\n-                        .early_free_scope(self.region_rels.tcx, br),\n+                        .early_free_scope(self.tcx(), br),\n                     (&ReFree(ref fr), _) | (_, &ReFree(ref fr)) => self.region_rels\n                         .region_scope_tree\n-                        .free_scope(self.region_rels.tcx, fr),\n+                        .free_scope(self.tcx(), fr),\n                     _ => bug!(),\n                 };\n                 let r_id = self.region_rels\n@@ -332,10 +336,10 @@ impl<'cx, 'gcx, 'tcx> LexicalResolver<'cx, 'gcx, 'tcx> {\n                 tcx.mk_region(ReScope(lub))\n             }\n \n-            (&ReEarlyBound(_), &ReEarlyBound(_)) |\n-            (&ReFree(_), &ReEarlyBound(_)) |\n-            (&ReEarlyBound(_), &ReFree(_)) |\n-            (&ReFree(_), &ReFree(_)) => self.region_rels.lub_free_regions(a, b),\n+            (&ReEarlyBound(_), &ReEarlyBound(_))\n+            | (&ReFree(_), &ReEarlyBound(_))\n+            | (&ReEarlyBound(_), &ReFree(_))\n+            | (&ReFree(_), &ReFree(_)) => self.region_rels.lub_free_regions(a, b),\n \n             // For these types, we cannot define any additional\n             // relationship:\n@@ -358,8 +362,7 @@ impl<'cx, 'gcx, 'tcx> LexicalResolver<'cx, 'gcx, 'tcx> {\n         for (constraint, origin) in &self.data.constraints {\n             debug!(\n                 \"collect_errors: constraint={:?} origin={:?}\",\n-                constraint,\n-                origin\n+                constraint, origin\n             );\n             match *constraint {\n                 Constraint::RegSubVar(..) | Constraint::VarSubVar(..) => {\n@@ -374,9 +377,7 @@ impl<'cx, 'gcx, 'tcx> LexicalResolver<'cx, 'gcx, 'tcx> {\n                     debug!(\n                         \"collect_errors: region error at {:?}: \\\n                          cannot verify that {:?} <= {:?}\",\n-                        origin,\n-                        sub,\n-                        sup\n+                        origin, sub, sup\n                     );\n \n                     errors.push(RegionResolutionError::ConcreteFailure(\n@@ -402,10 +403,7 @@ impl<'cx, 'gcx, 'tcx> LexicalResolver<'cx, 'gcx, 'tcx> {\n                         debug!(\n                             \"collect_errors: region error at {:?}: \\\n                              cannot verify that {:?}={:?} <= {:?}\",\n-                            origin,\n-                            a_vid,\n-                            a_region,\n-                            b_region\n+                            origin, a_vid, a_region, b_region\n                         );\n                         *a_data = VarValue::ErrorValue;\n                     }\n@@ -415,24 +413,23 @@ impl<'cx, 'gcx, 'tcx> LexicalResolver<'cx, 'gcx, 'tcx> {\n \n         for verify in &self.data.verifys {\n             debug!(\"collect_errors: verify={:?}\", verify);\n-            let sub = var_data.normalize(verify.region);\n+            let sub = var_data.normalize(self.tcx(), verify.region);\n \n             // This was an inference variable which didn't get\n             // constrained, therefore it can be assume to hold.\n             if let ty::ReEmpty = *sub {\n                 continue;\n             }\n \n-            if self.bound_is_met(&verify.bound, var_data, sub) {\n+            let verify_kind_ty = verify.kind.to_ty(self.tcx());\n+            if self.bound_is_met(&verify.bound, var_data, verify_kind_ty, sub) {\n                 continue;\n             }\n \n             debug!(\n                 \"collect_errors: region error at {:?}: \\\n                  cannot verify that {:?} <= {:?}\",\n-                verify.origin,\n-                verify.region,\n-                verify.bound\n+                verify.origin, verify.region, verify.bound\n             );\n \n             errors.push(RegionResolutionError::GenericBoundFailure(\n@@ -580,10 +577,7 @@ impl<'cx, 'gcx, 'tcx> LexicalResolver<'cx, 'gcx, 'tcx> {\n                     debug!(\n                         \"region inference error at {:?} for {:?}: SubSupConflict sub: {:?} \\\n                          sup: {:?}\",\n-                        origin,\n-                        node_idx,\n-                        lower_bound.region,\n-                        upper_bound.region\n+                        origin, node_idx, lower_bound.region, upper_bound.region\n                     );\n                     errors.push(RegionResolutionError::SubSupConflict(\n                         origin,\n@@ -645,8 +639,7 @@ impl<'cx, 'gcx, 'tcx> LexicalResolver<'cx, 'gcx, 'tcx> {\n \n             debug!(\n                 \"collect_concrete_regions(orig_node_idx={:?}, node_idx={:?})\",\n-                orig_node_idx,\n-                node_idx\n+                orig_node_idx, node_idx\n             );\n \n             process_edges(&self.data, &mut state, graph, node_idx, dir);\n@@ -721,20 +714,26 @@ impl<'cx, 'gcx, 'tcx> LexicalResolver<'cx, 'gcx, 'tcx> {\n         &self,\n         bound: &VerifyBound<'tcx>,\n         var_values: &LexicalRegionResolutions<'tcx>,\n+        generic_ty: Ty<'tcx>,\n         min: ty::Region<'tcx>,\n     ) -> bool {\n         match bound {\n-            VerifyBound::AnyRegion(rs) => rs.iter()\n-                .map(|&r| var_values.normalize(r))\n-                .any(|r| self.region_rels.is_subregion_of(min, r)),\n+            VerifyBound::IfEq(k, b) => {\n+                (var_values.normalize(self.region_rels.tcx, *k) == generic_ty)\n+                    && self.bound_is_met(b, var_values, generic_ty, min)\n+            }\n \n-            VerifyBound::AllRegions(rs) => rs.iter()\n-                .map(|&r| var_values.normalize(r))\n-                .all(|r| self.region_rels.is_subregion_of(min, r)),\n+            VerifyBound::OutlivedBy(r) =>\n+                self.region_rels.is_subregion_of(\n+                    min,\n+                    var_values.normalize(self.tcx(), r),\n+                ),\n \n-            VerifyBound::AnyBound(bs) => bs.iter().any(|b| self.bound_is_met(b, var_values, min)),\n+            VerifyBound::AnyBound(bs) => bs.iter()\n+                .any(|b| self.bound_is_met(b, var_values, generic_ty, min)),\n \n-            VerifyBound::AllBounds(bs) => bs.iter().all(|b| self.bound_is_met(b, var_values, min)),\n+            VerifyBound::AllBounds(bs) => bs.iter()\n+                .all(|b| self.bound_is_met(b, var_values, generic_ty, min)),\n         }\n     }\n }\n@@ -745,13 +744,15 @@ impl<'tcx> fmt::Debug for RegionAndOrigin<'tcx> {\n     }\n }\n \n-\n impl<'tcx> LexicalRegionResolutions<'tcx> {\n-    fn normalize(&self, r: ty::Region<'tcx>) -> ty::Region<'tcx> {\n-        match *r {\n-            ty::ReVar(rid) => self.resolve_var(rid),\n+    fn normalize<T>(&self, tcx: TyCtxt<'_, '_, 'tcx>, value: T) -> T\n+    where\n+        T: TypeFoldable<'tcx>,\n+    {\n+        tcx.fold_regions(&value, &mut false, |r, _db| match r {\n+            ty::ReVar(rid) => self.resolve_var(*rid),\n             _ => r,\n-        }\n+        })\n     }\n \n     fn value(&self, rid: RegionVid) -> &VarValue<'tcx> {"}, {"sha": "dc10ec03feef04c1ae2056b3ad28dc2fe637487e", "filename": "src/librustc/infer/mod.rs", "status": "modified", "additions": 36, "deletions": 30, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/c7df1f530b8a88f471e60e933868e7ddf456974d/src%2Flibrustc%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7df1f530b8a88f471e60e933868e7ddf456974d/src%2Flibrustc%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fmod.rs?ref=c7df1f530b8a88f471e60e933868e7ddf456974d", "patch": "@@ -24,6 +24,7 @@ use middle::free_region::RegionRelations;\n use middle::lang_items;\n use middle::region;\n use rustc_data_structures::unify as ut;\n+use session::config::BorrowckMode;\n use std::cell::{Cell, Ref, RefCell, RefMut};\n use std::collections::BTreeMap;\n use std::fmt;\n@@ -80,6 +81,38 @@ pub type Bound<T> = Option<T>;\n pub type UnitResult<'tcx> = RelateResult<'tcx, ()>; // \"unify result\"\n pub type FixupResult<T> = Result<T, FixupError>; // \"fixup result\"\n \n+/// A flag that is used to suppress region errors. This is normally\n+/// false, but sometimes -- when we are doing region checks that the\n+/// NLL borrow checker will also do -- it might be set to true.\n+#[derive(Copy, Clone, Default, Debug)]\n+pub struct SuppressRegionErrors {\n+    suppressed: bool\n+}\n+\n+impl SuppressRegionErrors {\n+    pub fn suppressed(self) -> bool {\n+        self.suppressed\n+    }\n+\n+    /// Indicates that the MIR borrowck will repeat these region\n+    /// checks, so we should ignore errors if NLL is (unconditionally)\n+    /// enabled.\n+    pub fn when_nll_is_enabled(tcx: TyCtxt<'_, '_, '_>) -> Self {\n+        match tcx.borrowck_mode() {\n+            // If we're on AST or Migrate mode, report AST region errors\n+            BorrowckMode::Ast | BorrowckMode::Migrate => SuppressRegionErrors {\n+                suppressed: false\n+            },\n+\n+            // If we're on MIR or Compare mode, don't report AST region errors as they should\n+            // be reported by NLL\n+            BorrowckMode::Compare | BorrowckMode::Mir => SuppressRegionErrors {\n+                suppressed: true\n+            },\n+        }\n+    }\n+}\n+\n pub struct InferCtxt<'a, 'gcx: 'a + 'tcx, 'tcx: 'a> {\n     pub tcx: TyCtxt<'a, 'gcx, 'tcx>,\n \n@@ -408,7 +441,7 @@ pub enum FixupError {\n pub struct RegionObligation<'tcx> {\n     pub sub_region: ty::Region<'tcx>,\n     pub sup_type: Ty<'tcx>,\n-    pub cause: ObligationCause<'tcx>,\n+    pub origin: SubregionOrigin<'tcx>,\n }\n \n impl fmt::Display for FixupError {\n@@ -1039,34 +1072,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n         region_context: DefId,\n         region_map: &region::ScopeTree,\n         outlives_env: &OutlivesEnvironment<'tcx>,\n-    ) {\n-        self.resolve_regions_and_report_errors_inner(\n-            region_context,\n-            region_map,\n-            outlives_env,\n-            false,\n-        )\n-    }\n-\n-    /// Like `resolve_regions_and_report_errors`, but skips error\n-    /// reporting if NLL is enabled.  This is used for fn bodies where\n-    /// the same error may later be reported by the NLL-based\n-    /// inference.\n-    pub fn resolve_regions_and_report_errors_unless_nll(\n-        &self,\n-        region_context: DefId,\n-        region_map: &region::ScopeTree,\n-        outlives_env: &OutlivesEnvironment<'tcx>,\n-    ) {\n-        self.resolve_regions_and_report_errors_inner(region_context, region_map, outlives_env, true)\n-    }\n-\n-    fn resolve_regions_and_report_errors_inner(\n-        &self,\n-        region_context: DefId,\n-        region_map: &region::ScopeTree,\n-        outlives_env: &OutlivesEnvironment<'tcx>,\n-        will_later_be_reported_by_nll: bool,\n+        suppress: SuppressRegionErrors,\n     ) {\n         assert!(\n             self.is_tainted_by_errors() || self.region_obligations.borrow().is_empty(),\n@@ -1098,7 +1104,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n             // this infcx was in use.  This is totally hokey but\n             // otherwise we have a hard time separating legit region\n             // errors from silly ones.\n-            self.report_region_errors(region_map, &errors, will_later_be_reported_by_nll);\n+            self.report_region_errors(region_map, &errors, suppress);\n         }\n     }\n "}, {"sha": "631ff58d3e37e3e87e0574c3d925ad0b5966612b", "filename": "src/librustc/infer/outlives/env.rs", "status": "modified", "additions": 62, "deletions": 15, "changes": 77, "blob_url": "https://github.com/rust-lang/rust/blob/c7df1f530b8a88f471e60e933868e7ddf456974d/src%2Flibrustc%2Finfer%2Foutlives%2Fenv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7df1f530b8a88f471e60e933868e7ddf456974d/src%2Flibrustc%2Finfer%2Foutlives%2Fenv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Foutlives%2Fenv.rs?ref=c7df1f530b8a88f471e60e933868e7ddf456974d", "patch": "@@ -8,13 +8,13 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use infer::{GenericKind, InferCtxt};\n use infer::outlives::free_region_map::FreeRegionMap;\n-use traits::query::outlives_bounds::{self, OutlivesBound};\n-use ty::{self, Ty};\n-\n+use infer::{GenericKind, InferCtxt};\n+use rustc_data_structures::fx::FxHashMap;\n use syntax::ast;\n use syntax_pos::Span;\n+use traits::query::outlives_bounds::{self, OutlivesBound};\n+use ty::{self, Ty};\n \n /// The `OutlivesEnvironment` collects information about what outlives\n /// what in a given type-checking setting. For example, if we have a\n@@ -39,15 +39,51 @@ use syntax_pos::Span;\n pub struct OutlivesEnvironment<'tcx> {\n     param_env: ty::ParamEnv<'tcx>,\n     free_region_map: FreeRegionMap<'tcx>,\n-    region_bound_pairs: Vec<(ty::Region<'tcx>, GenericKind<'tcx>)>,\n+\n+    // Contains, for each body B that we are checking (that is, the fn\n+    // item, but also any nested closures), the set of implied region\n+    // bounds that are in scope in that particular body.\n+    //\n+    // Example:\n+    //\n+    // ```\n+    // fn foo<'a, 'b, T>(x: &'a T, y: &'b ()) {\n+    //   bar(x, y, |y: &'b T| { .. } // body B1)\n+    // } // body B0\n+    // ```\n+    //\n+    // Here, for body B0, the list would be `[T: 'a]`, because we\n+    // infer that `T` must outlive `'a` from the implied bounds on the\n+    // fn declaration.\n+    //\n+    // For the body B1, the list would be `[T: 'a, T: 'b]`, because we\n+    // also can see that -- within the closure body! -- `T` must\n+    // outlive `'b`. This is not necessarily true outside the closure\n+    // body, since the closure may never be called.\n+    //\n+    // We collect this map as we descend the tree. We then use the\n+    // results when proving outlives obligations like `T: 'x` later\n+    // (e.g., if `T: 'x` must be proven within the body B1, then we\n+    // know it is true if either `'a: 'x` or `'b: 'x`).\n+    region_bound_pairs_map: FxHashMap<ast::NodeId, RegionBoundPairs<'tcx>>,\n+\n+    // Used to compute `region_bound_pairs_map`: contains the set of\n+    // in-scope region-bound pairs thus far.\n+    region_bound_pairs_accum: RegionBoundPairs<'tcx>,\n }\n \n+/// \"Region-bound pairs\" tracks outlives relations that are known to\n+/// be true, either because of explicit where clauses like `T: 'a` or\n+/// because of implied bounds.\n+pub type RegionBoundPairs<'tcx> = Vec<(ty::Region<'tcx>, GenericKind<'tcx>)>;\n+\n impl<'a, 'gcx: 'tcx, 'tcx: 'a> OutlivesEnvironment<'tcx> {\n     pub fn new(param_env: ty::ParamEnv<'tcx>) -> Self {\n         let mut env = OutlivesEnvironment {\n             param_env,\n             free_region_map: FreeRegionMap::new(),\n-            region_bound_pairs: vec![],\n+            region_bound_pairs_map: FxHashMap::default(),\n+            region_bound_pairs_accum: vec![],\n         };\n \n         env.add_outlives_bounds(None, outlives_bounds::explicit_outlives_bounds(param_env));\n@@ -61,8 +97,8 @@ impl<'a, 'gcx: 'tcx, 'tcx: 'a> OutlivesEnvironment<'tcx> {\n     }\n \n     /// Borrows current value of the `region_bound_pairs`.\n-    pub fn region_bound_pairs(&self) -> &[(ty::Region<'tcx>, GenericKind<'tcx>)] {\n-        &self.region_bound_pairs\n+    pub fn region_bound_pairs_map(&self) -> &FxHashMap<ast::NodeId, RegionBoundPairs<'tcx>> {\n+        &self.region_bound_pairs_map\n     }\n \n     /// Returns ownership of the `free_region_map`.\n@@ -108,12 +144,12 @@ impl<'a, 'gcx: 'tcx, 'tcx: 'a> OutlivesEnvironment<'tcx> {\n     /// similar leaks around givens that seem equally suspicious, to\n     /// be honest. --nmatsakis\n     pub fn push_snapshot_pre_closure(&self) -> usize {\n-        self.region_bound_pairs.len()\n+        self.region_bound_pairs_accum.len()\n     }\n \n     /// See `push_snapshot_pre_closure`.\n     pub fn pop_snapshot_post_closure(&mut self, len: usize) {\n-        self.region_bound_pairs.truncate(len);\n+        self.region_bound_pairs_accum.truncate(len);\n     }\n \n     /// This method adds \"implied bounds\" into the outlives environment.\n@@ -149,6 +185,15 @@ impl<'a, 'gcx: 'tcx, 'tcx: 'a> OutlivesEnvironment<'tcx> {\n         }\n     }\n \n+    /// Save the current set of region-bound pairs under the given `body_id`.\n+    pub fn save_implied_bounds(&mut self, body_id: ast::NodeId) {\n+        let old = self.region_bound_pairs_map.insert(\n+            body_id,\n+            self.region_bound_pairs_accum.clone(),\n+        );\n+        assert!(old.is_none());\n+    }\n+\n     /// Processes outlives bounds that are known to hold, whether from implied or other sources.\n     ///\n     /// The `infcx` parameter is optional; if the implied bounds may\n@@ -167,16 +212,18 @@ impl<'a, 'gcx: 'tcx, 'tcx: 'a> OutlivesEnvironment<'tcx> {\n         for outlives_bound in outlives_bounds {\n             debug!(\"add_outlives_bounds: outlives_bound={:?}\", outlives_bound);\n             match outlives_bound {\n-                OutlivesBound::RegionSubRegion(r_a @ &ty::ReEarlyBound(_), &ty::ReVar(vid_b)) |\n-                OutlivesBound::RegionSubRegion(r_a @ &ty::ReFree(_), &ty::ReVar(vid_b)) => {\n-                    infcx.expect(\"no infcx provided but region vars found\").add_given(r_a, vid_b);\n+                OutlivesBound::RegionSubRegion(r_a @ &ty::ReEarlyBound(_), &ty::ReVar(vid_b))\n+                | OutlivesBound::RegionSubRegion(r_a @ &ty::ReFree(_), &ty::ReVar(vid_b)) => {\n+                    infcx\n+                        .expect(\"no infcx provided but region vars found\")\n+                        .add_given(r_a, vid_b);\n                 }\n                 OutlivesBound::RegionSubParam(r_a, param_b) => {\n-                    self.region_bound_pairs\n+                    self.region_bound_pairs_accum\n                         .push((r_a, GenericKind::Param(param_b)));\n                 }\n                 OutlivesBound::RegionSubProjection(r_a, projection_b) => {\n-                    self.region_bound_pairs\n+                    self.region_bound_pairs_accum\n                         .push((r_a, GenericKind::Projection(projection_b)));\n                 }\n                 OutlivesBound::RegionSubRegion(r_a, r_b) => {"}, {"sha": "282aef786f08ab2ad8b724b9f8130dd643edfff6", "filename": "src/librustc/infer/outlives/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/c7df1f530b8a88f471e60e933868e7ddf456974d/src%2Flibrustc%2Finfer%2Foutlives%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7df1f530b8a88f471e60e933868e7ddf456974d/src%2Flibrustc%2Finfer%2Foutlives%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Foutlives%2Fmod.rs?ref=c7df1f530b8a88f471e60e933868e7ddf456974d", "patch": "@@ -13,3 +13,4 @@\n pub mod env;\n pub mod free_region_map;\n pub mod obligations;\n+pub mod verify;"}, {"sha": "332859d4f81db28fd6b24471e4c40ba24126bba6", "filename": "src/librustc/infer/outlives/obligations.rs", "status": "modified", "additions": 105, "deletions": 286, "changes": 391, "blob_url": "https://github.com/rust-lang/rust/blob/c7df1f530b8a88f471e60e933868e7ddf456974d/src%2Flibrustc%2Finfer%2Foutlives%2Fobligations.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7df1f530b8a88f471e60e933868e7ddf456974d/src%2Flibrustc%2Finfer%2Foutlives%2Fobligations.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Foutlives%2Fobligations.rs?ref=c7df1f530b8a88f471e60e933868e7ddf456974d", "patch": "@@ -69,13 +69,14 @@\n //! might later infer `?U` to something like `&'b u32`, which would\n //! imply that `'b: 'a`.\n \n-use hir::def_id::DefId;\n+use infer::outlives::env::RegionBoundPairs;\n+use infer::outlives::verify::VerifyBoundCx;\n use infer::{self, GenericKind, InferCtxt, RegionObligation, SubregionOrigin, VerifyBound};\n+use rustc_data_structures::fx::FxHashMap;\n use syntax::ast;\n-use traits;\n+use traits::ObligationCause;\n use ty::outlives::Component;\n-use ty::subst::{Subst, Substs};\n-use ty::{self, Ty, TyCtxt, TypeFoldable};\n+use ty::{self, Region, Ty, TyCtxt, TypeFoldable};\n \n impl<'cx, 'gcx, 'tcx> InferCtxt<'cx, 'gcx, 'tcx> {\n     /// Registers that the given region obligation must be resolved\n@@ -98,6 +99,26 @@ impl<'cx, 'gcx, 'tcx> InferCtxt<'cx, 'gcx, 'tcx> {\n             .push((body_id, obligation));\n     }\n \n+    pub fn register_region_obligation_with_cause(\n+        &self,\n+        sup_type: Ty<'tcx>,\n+        sub_region: Region<'tcx>,\n+        cause: &ObligationCause<'tcx>,\n+    ) {\n+        let origin = SubregionOrigin::from_obligation_cause(cause, || {\n+            infer::RelateParamBound(cause.span, sup_type)\n+        });\n+\n+        self.register_region_obligation(\n+            cause.body_id,\n+            RegionObligation {\n+                sup_type,\n+                sub_region,\n+                origin,\n+            },\n+        );\n+    }\n+\n     /// Trait queries just want to pass back type obligations \"as is\"\n     pub fn take_registered_region_obligations(&self) -> Vec<(ast::NodeId, RegionObligation<'tcx>)> {\n         ::std::mem::replace(&mut *self.region_obligations.borrow_mut(), vec![])\n@@ -138,10 +159,9 @@ impl<'cx, 'gcx, 'tcx> InferCtxt<'cx, 'gcx, 'tcx> {\n     /// processed.\n     pub fn process_registered_region_obligations(\n         &self,\n-        region_bound_pairs: &[(ty::Region<'tcx>, GenericKind<'tcx>)],\n+        region_bound_pairs_map: &FxHashMap<ast::NodeId, RegionBoundPairs<'tcx>>,\n         implicit_region_bound: Option<ty::Region<'tcx>>,\n         param_env: ty::ParamEnv<'tcx>,\n-        body_id: ast::NodeId,\n     ) {\n         assert!(\n             !self.in_snapshot.get(),\n@@ -150,49 +170,47 @@ impl<'cx, 'gcx, 'tcx> InferCtxt<'cx, 'gcx, 'tcx> {\n \n         debug!(\"process_registered_region_obligations()\");\n \n-        // pull out the region obligations with the given `body_id` (leaving the rest)\n-        let mut my_region_obligations = Vec::with_capacity(self.region_obligations.borrow().len());\n-        {\n-            let mut r_o = self.region_obligations.borrow_mut();\n-            my_region_obligations.extend(\n-                r_o.drain_filter(|(ro_body_id, _)| *ro_body_id == body_id)\n-                   .map(|(_, obligation)| obligation)\n-            );\n-        }\n-\n-        let outlives = &mut TypeOutlives::new(\n-            self,\n-            self.tcx,\n-            region_bound_pairs,\n-            implicit_region_bound,\n-            param_env,\n-        );\n+        let my_region_obligations = self.take_registered_region_obligations();\n \n-        for RegionObligation {\n-            sup_type,\n-            sub_region,\n-            cause,\n-        } in my_region_obligations\n+        for (\n+            body_id,\n+            RegionObligation {\n+                sup_type,\n+                sub_region,\n+                origin,\n+            },\n+        ) in my_region_obligations\n         {\n             debug!(\n-                \"process_registered_region_obligations: sup_type={:?} sub_region={:?} cause={:?}\",\n-                sup_type, sub_region, cause\n+                \"process_registered_region_obligations: sup_type={:?} sub_region={:?} origin={:?}\",\n+                sup_type, sub_region, origin\n             );\n \n-            let origin = SubregionOrigin::from_obligation_cause(&cause, || {\n-                infer::RelateParamBound(cause.span, sup_type)\n-            });\n-\n             let sup_type = self.resolve_type_vars_if_possible(&sup_type);\n-            outlives.type_must_outlive(origin, sup_type, sub_region);\n+\n+            if let Some(region_bound_pairs) = region_bound_pairs_map.get(&body_id) {\n+                let outlives = &mut TypeOutlives::new(\n+                    self,\n+                    self.tcx,\n+                    &region_bound_pairs,\n+                    implicit_region_bound,\n+                    param_env,\n+                );\n+                outlives.type_must_outlive(origin, sup_type, sub_region);\n+            } else {\n+                self.tcx.sess.delay_span_bug(\n+                    origin.span(),\n+                    &format!(\"no region-bound-pairs for {:?}\", body_id),\n+                )\n+            }\n         }\n     }\n \n     /// Processes a single ad-hoc region obligation that was not\n     /// registered in advance.\n     pub fn type_must_outlive(\n         &self,\n-        region_bound_pairs: &[(ty::Region<'tcx>, GenericKind<'tcx>)],\n+        region_bound_pairs: &RegionBoundPairs<'tcx>,\n         implicit_region_bound: Option<ty::Region<'tcx>>,\n         param_env: ty::ParamEnv<'tcx>,\n         origin: infer::SubregionOrigin<'tcx>,\n@@ -225,9 +243,7 @@ where\n     // of these fields.\n     delegate: D,\n     tcx: TyCtxt<'cx, 'gcx, 'tcx>,\n-    region_bound_pairs: &'cx [(ty::Region<'tcx>, GenericKind<'tcx>)],\n-    implicit_region_bound: Option<ty::Region<'tcx>>,\n-    param_env: ty::ParamEnv<'tcx>,\n+    verify_bound: VerifyBoundCx<'cx, 'gcx, 'tcx>,\n }\n \n pub trait TypeOutlivesDelegate<'tcx> {\n@@ -254,16 +270,19 @@ where\n     pub fn new(\n         delegate: D,\n         tcx: TyCtxt<'cx, 'gcx, 'tcx>,\n-        region_bound_pairs: &'cx [(ty::Region<'tcx>, GenericKind<'tcx>)],\n+        region_bound_pairs: &'cx RegionBoundPairs<'tcx>,\n         implicit_region_bound: Option<ty::Region<'tcx>>,\n         param_env: ty::ParamEnv<'tcx>,\n     ) -> Self {\n         Self {\n             delegate,\n             tcx,\n-            region_bound_pairs,\n-            implicit_region_bound,\n-            param_env,\n+            verify_bound: VerifyBoundCx::new(\n+                tcx,\n+                region_bound_pairs,\n+                implicit_region_bound,\n+                param_env,\n+            ),\n         }\n     }\n \n@@ -302,7 +321,8 @@ where\n             let origin = origin.clone();\n             match component {\n                 Component::Region(region1) => {\n-                    self.delegate.push_sub_region_constraint(origin, region, region1);\n+                    self.delegate\n+                        .push_sub_region_constraint(origin, region, region1);\n                 }\n                 Component::Param(param_ty) => {\n                     self.param_ty_must_outlive(origin, region, param_ty);\n@@ -337,8 +357,8 @@ where\n             region, param_ty, origin\n         );\n \n-        let verify_bound = self.param_bound(param_ty);\n         let generic = GenericKind::Param(param_ty);\n+        let verify_bound = self.verify_bound.generic_bound(generic);\n         self.delegate\n             .push_verify(origin, generic, region, verify_bound);\n     }\n@@ -368,19 +388,22 @@ where\n         // rule might not apply (but another rule might). For now, we err\n         // on the side of adding too few edges into the graph.\n \n-        // Compute the bounds we can derive from the environment or trait\n-        // definition.  We know that the projection outlives all the\n-        // regions in this list.\n-        let env_bounds = self.projection_declared_bounds(projection_ty);\n-\n-        debug!(\"projection_must_outlive: env_bounds={:?}\", env_bounds);\n+        // Compute the bounds we can derive from the environment. This\n+        // is an \"approximate\" match -- in some cases, these bounds\n+        // may not apply.\n+        let approx_env_bounds = self.verify_bound\n+            .projection_approx_declared_bounds_from_env(projection_ty);\n+        debug!(\n+            \"projection_must_outlive: approx_env_bounds={:?}\",\n+            approx_env_bounds\n+        );\n \n-        // If we know that the projection outlives 'static, then we're\n-        // done here.\n-        if env_bounds.contains(&&ty::ReStatic) {\n-            debug!(\"projection_must_outlive: 'static as declared bound\");\n-            return;\n-        }\n+        // Compute the bounds we can derive from the trait definition.\n+        // These are guaranteed to apply, no matter the inference\n+        // results.\n+        let trait_bounds: Vec<_> = self.verify_bound\n+            .projection_declared_bounds_from_trait(projection_ty)\n+            .collect();\n \n         // If declared bounds list is empty, the only applicable rule is\n         // OutlivesProjectionComponent. If there are inference variables,\n@@ -397,261 +420,58 @@ where\n         // inference variables, we use a verify constraint instead of adding\n         // edges, which winds up enforcing the same condition.\n         let needs_infer = projection_ty.needs_infer();\n-        if env_bounds.is_empty() && needs_infer {\n+        if approx_env_bounds.is_empty() && trait_bounds.is_empty() && needs_infer {\n             debug!(\"projection_must_outlive: no declared bounds\");\n \n             for component_ty in projection_ty.substs.types() {\n                 self.type_must_outlive(origin.clone(), component_ty, region);\n             }\n \n             for r in projection_ty.substs.regions() {\n-                self.delegate.push_sub_region_constraint(origin.clone(), region, r);\n+                self.delegate\n+                    .push_sub_region_constraint(origin.clone(), region, r);\n             }\n \n             return;\n         }\n \n-        // If we find that there is a unique declared bound `'b`, and this bound\n-        // appears in the trait reference, then the best action is to require that `'b:'r`,\n-        // so do that. This is best no matter what rule we use:\n+        // If we found a unique bound `'b` from the trait, and we\n+        // found nothing else from the environment, then the best\n+        // action is to require that `'b: 'r`, so do that.\n+        //\n+        // This is best no matter what rule we use:\n         //\n-        // - OutlivesProjectionEnv or OutlivesProjectionTraitDef: these would translate to\n-        // the requirement that `'b:'r`\n-        // - OutlivesProjectionComponent: this would require `'b:'r` in addition to\n-        // other conditions\n-        if !env_bounds.is_empty() && env_bounds[1..].iter().all(|b| *b == env_bounds[0]) {\n-            let unique_bound = env_bounds[0];\n+        // - OutlivesProjectionEnv: these would translate to the requirement that `'b:'r`\n+        // - OutlivesProjectionTraitDef: these would translate to the requirement that `'b:'r`\n+        // - OutlivesProjectionComponent: this would require `'b:'r`\n+        //   in addition to other conditions\n+        if !trait_bounds.is_empty()\n+            && trait_bounds[1..]\n+                .iter()\n+                .chain(approx_env_bounds.iter().map(|b| &b.1))\n+                .all(|b| *b == trait_bounds[0])\n+        {\n+            let unique_bound = trait_bounds[0];\n             debug!(\n-                \"projection_must_outlive: unique declared bound = {:?}\",\n+                \"projection_must_outlive: unique trait bound = {:?}\",\n                 unique_bound\n             );\n-            if projection_ty\n-                .substs\n-                .regions()\n-                .any(|r| env_bounds.contains(&r))\n-            {\n-                debug!(\"projection_must_outlive: unique declared bound appears in trait ref\");\n-                self.delegate\n-                    .push_sub_region_constraint(origin.clone(), region, unique_bound);\n-                return;\n-            }\n+            debug!(\"projection_must_outlive: unique declared bound appears in trait ref\");\n+            self.delegate\n+                .push_sub_region_constraint(origin.clone(), region, unique_bound);\n+            return;\n         }\n \n         // Fallback to verifying after the fact that there exists a\n         // declared bound, or that all the components appearing in the\n         // projection outlive; in some cases, this may add insufficient\n         // edges into the inference graph, leading to inference failures\n         // even though a satisfactory solution exists.\n-        let verify_bound = self.projection_bound(env_bounds, projection_ty);\n         let generic = GenericKind::Projection(projection_ty);\n+        let verify_bound = self.verify_bound.generic_bound(generic);\n         self.delegate\n             .push_verify(origin, generic.clone(), region, verify_bound);\n     }\n-\n-    fn type_bound(&self, ty: Ty<'tcx>) -> VerifyBound<'tcx> {\n-        match ty.sty {\n-            ty::Param(p) => self.param_bound(p),\n-            ty::Projection(data) => {\n-                let declared_bounds = self.projection_declared_bounds(data);\n-                self.projection_bound(declared_bounds, data)\n-            }\n-            _ => self.recursive_type_bound(ty),\n-        }\n-    }\n-\n-    fn param_bound(&self, param_ty: ty::ParamTy) -> VerifyBound<'tcx> {\n-        debug!(\"param_bound(param_ty={:?})\", param_ty);\n-\n-        let mut param_bounds = self.declared_generic_bounds_from_env(GenericKind::Param(param_ty));\n-\n-        // Add in the default bound of fn body that applies to all in\n-        // scope type parameters:\n-        param_bounds.extend(self.implicit_region_bound);\n-\n-        VerifyBound::AnyRegion(param_bounds)\n-    }\n-\n-    fn projection_declared_bounds(\n-        &self,\n-        projection_ty: ty::ProjectionTy<'tcx>,\n-    ) -> Vec<ty::Region<'tcx>> {\n-        // First assemble bounds from where clauses and traits.\n-\n-        let mut declared_bounds =\n-            self.declared_generic_bounds_from_env(GenericKind::Projection(projection_ty));\n-\n-        declared_bounds\n-            .extend_from_slice(&self.declared_projection_bounds_from_trait(projection_ty));\n-\n-        declared_bounds\n-    }\n-\n-    fn projection_bound(\n-        &self,\n-        declared_bounds: Vec<ty::Region<'tcx>>,\n-        projection_ty: ty::ProjectionTy<'tcx>,\n-    ) -> VerifyBound<'tcx> {\n-        debug!(\n-            \"projection_bound(declared_bounds={:?}, projection_ty={:?})\",\n-            declared_bounds, projection_ty\n-        );\n-\n-        // see the extensive comment in projection_must_outlive\n-        let ty = self\n-            .tcx\n-            .mk_projection(projection_ty.item_def_id, projection_ty.substs);\n-        let recursive_bound = self.recursive_type_bound(ty);\n-\n-        VerifyBound::AnyRegion(declared_bounds).or(recursive_bound)\n-    }\n-\n-    fn recursive_type_bound(&self, ty: Ty<'tcx>) -> VerifyBound<'tcx> {\n-        let mut bounds = ty.walk_shallow().map(|subty| self.type_bound(subty)).collect::<Vec<_>>();\n-\n-        let mut regions = ty.regions();\n-        regions.retain(|r| !r.is_late_bound()); // ignore late-bound regions\n-        bounds.push(VerifyBound::AllRegions(regions));\n-\n-        // remove bounds that must hold, since they are not interesting\n-        bounds.retain(|b| !b.must_hold());\n-\n-        if bounds.len() == 1 {\n-            bounds.pop().unwrap()\n-        } else {\n-            VerifyBound::AllBounds(bounds)\n-        }\n-    }\n-\n-    fn declared_generic_bounds_from_env(\n-        &self,\n-        generic: GenericKind<'tcx>,\n-    ) -> Vec<ty::Region<'tcx>> {\n-        let tcx = self.tcx;\n-\n-        // To start, collect bounds from user environment. Note that\n-        // parameter environments are already elaborated, so we don't\n-        // have to worry about that. Comparing using `==` is a bit\n-        // dubious for projections, but it will work for simple cases\n-        // like `T` and `T::Item`. It may not work as well for things\n-        // like `<T as Foo<'a>>::Item`.\n-        let generic_ty = generic.to_ty(tcx);\n-        let c_b = self.param_env.caller_bounds;\n-        let mut param_bounds = self.collect_outlives_from_predicate_list(generic_ty, c_b);\n-\n-        // Next, collect regions we scraped from the well-formedness\n-        // constraints in the fn signature. To do that, we walk the list\n-        // of known relations from the fn ctxt.\n-        //\n-        // This is crucial because otherwise code like this fails:\n-        //\n-        //     fn foo<'a, A>(x: &'a A) { x.bar() }\n-        //\n-        // The problem is that the type of `x` is `&'a A`. To be\n-        // well-formed, then, A must be lower-generic by `'a`, but we\n-        // don't know that this holds from first principles.\n-        for &(r, p) in self.region_bound_pairs {\n-            debug!(\"generic={:?} p={:?}\", generic, p);\n-            if generic == p {\n-                param_bounds.push(r);\n-            }\n-        }\n-\n-        param_bounds\n-    }\n-\n-    /// Given a projection like `<T as Foo<'x>>::Bar`, returns any bounds\n-    /// declared in the trait definition. For example, if the trait were\n-    ///\n-    /// ```rust\n-    /// trait Foo<'a> {\n-    ///     type Bar: 'a;\n-    /// }\n-    /// ```\n-    ///\n-    /// then this function would return `'x`. This is subject to the\n-    /// limitations around higher-ranked bounds described in\n-    /// `region_bounds_declared_on_associated_item`.\n-    fn declared_projection_bounds_from_trait(\n-        &self,\n-        projection_ty: ty::ProjectionTy<'tcx>,\n-    ) -> Vec<ty::Region<'tcx>> {\n-        debug!(\"projection_bounds(projection_ty={:?})\", projection_ty);\n-        let mut bounds = self.region_bounds_declared_on_associated_item(projection_ty.item_def_id);\n-        for r in &mut bounds {\n-            *r = r.subst(self.tcx, projection_ty.substs);\n-        }\n-        bounds\n-    }\n-\n-    /// Given the def-id of an associated item, returns any region\n-    /// bounds attached to that associated item from the trait definition.\n-    ///\n-    /// For example:\n-    ///\n-    /// ```rust\n-    /// trait Foo<'a> {\n-    ///     type Bar: 'a;\n-    /// }\n-    /// ```\n-    ///\n-    /// If we were given the def-id of `Foo::Bar`, we would return\n-    /// `'a`. You could then apply the substitutions from the\n-    /// projection to convert this into your namespace. This also\n-    /// works if the user writes `where <Self as Foo<'a>>::Bar: 'a` on\n-    /// the trait. In fact, it works by searching for just such a\n-    /// where-clause.\n-    ///\n-    /// It will not, however, work for higher-ranked bounds like:\n-    ///\n-    /// ```rust\n-    /// trait Foo<'a, 'b>\n-    /// where for<'x> <Self as Foo<'x, 'b>>::Bar: 'x\n-    /// {\n-    ///     type Bar;\n-    /// }\n-    /// ```\n-    ///\n-    /// This is for simplicity, and because we are not really smart\n-    /// enough to cope with such bounds anywhere.\n-    fn region_bounds_declared_on_associated_item(\n-        &self,\n-        assoc_item_def_id: DefId,\n-    ) -> Vec<ty::Region<'tcx>> {\n-        let tcx = self.tcx;\n-        let assoc_item = tcx.associated_item(assoc_item_def_id);\n-        let trait_def_id = assoc_item.container.assert_trait();\n-        let trait_predicates = tcx.predicates_of(trait_def_id);\n-        let identity_substs = Substs::identity_for_item(tcx, assoc_item_def_id);\n-        let identity_proj = tcx.mk_projection(assoc_item_def_id, identity_substs);\n-        self.collect_outlives_from_predicate_list(\n-            identity_proj,\n-            traits::elaborate_predicates(tcx, trait_predicates.predicates),\n-        )\n-    }\n-\n-    /// Searches through a predicate list for a predicate `T: 'a`.\n-    ///\n-    /// Careful: does not elaborate predicates, and just uses `==`\n-    /// when comparing `ty` for equality, so `ty` must be something\n-    /// that does not involve inference variables and where you\n-    /// otherwise want a precise match.\n-    fn collect_outlives_from_predicate_list<I, P>(\n-        &self,\n-        ty: Ty<'tcx>,\n-        predicates: I,\n-    ) -> Vec<ty::Region<'tcx>>\n-    where\n-        I: IntoIterator<Item = P>,\n-        P: AsRef<ty::Predicate<'tcx>>,\n-    {\n-        predicates\n-            .into_iter()\n-            .filter_map(|p| p.as_ref().to_opt_type_outlives())\n-            .filter_map(|p| p.no_late_bound_regions())\n-            .filter(|p| p.0 == ty)\n-            .map(|p| p.1)\n-            .collect()\n-    }\n }\n \n impl<'cx, 'gcx, 'tcx> TypeOutlivesDelegate<'tcx> for &'cx InferCtxt<'cx, 'gcx, 'tcx> {\n@@ -674,4 +494,3 @@ impl<'cx, 'gcx, 'tcx> TypeOutlivesDelegate<'tcx> for &'cx InferCtxt<'cx, 'gcx, '\n         self.verify_generic_bound(origin, kind, a, bound)\n     }\n }\n-"}, {"sha": "5b23fc19a9d1ba874ef5c24a1e8bb0185ff9eed7", "filename": "src/librustc/infer/outlives/verify.rs", "status": "added", "additions": 326, "deletions": 0, "changes": 326, "blob_url": "https://github.com/rust-lang/rust/blob/c7df1f530b8a88f471e60e933868e7ddf456974d/src%2Flibrustc%2Finfer%2Foutlives%2Fverify.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7df1f530b8a88f471e60e933868e7ddf456974d/src%2Flibrustc%2Finfer%2Foutlives%2Fverify.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Foutlives%2Fverify.rs?ref=c7df1f530b8a88f471e60e933868e7ddf456974d", "patch": "@@ -0,0 +1,326 @@\n+// Copyright 2012-2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use hir::def_id::DefId;\n+use infer::outlives::env::RegionBoundPairs;\n+use infer::{GenericKind, VerifyBound};\n+use traits;\n+use ty::subst::{Subst, Substs};\n+use ty::{self, Ty, TyCtxt};\n+use util::captures::Captures;\n+\n+/// The `TypeOutlives` struct has the job of \"lowering\" a `T: 'a`\n+/// obligation into a series of `'a: 'b` constraints and \"verifys\", as\n+/// described on the module comment. The final constraints are emitted\n+/// via a \"delegate\" of type `D` -- this is usually the `infcx`, which\n+/// accrues them into the `region_obligations` code, but for NLL we\n+/// use something else.\n+pub struct VerifyBoundCx<'cx, 'gcx: 'tcx, 'tcx: 'cx> {\n+    tcx: TyCtxt<'cx, 'gcx, 'tcx>,\n+    region_bound_pairs: &'cx RegionBoundPairs<'tcx>,\n+    implicit_region_bound: Option<ty::Region<'tcx>>,\n+    param_env: ty::ParamEnv<'tcx>,\n+}\n+\n+impl<'cx, 'gcx, 'tcx> VerifyBoundCx<'cx, 'gcx, 'tcx> {\n+    pub fn new(\n+        tcx: TyCtxt<'cx, 'gcx, 'tcx>,\n+        region_bound_pairs: &'cx RegionBoundPairs<'tcx>,\n+        implicit_region_bound: Option<ty::Region<'tcx>>,\n+        param_env: ty::ParamEnv<'tcx>,\n+    ) -> Self {\n+        Self {\n+            tcx,\n+            region_bound_pairs,\n+            implicit_region_bound,\n+            param_env,\n+        }\n+    }\n+\n+    /// Returns a \"verify bound\" that encodes what we know about\n+    /// `generic` and the regions it outlives.\n+    pub fn generic_bound(&self, generic: GenericKind<'tcx>) -> VerifyBound<'tcx> {\n+        match generic {\n+            GenericKind::Param(param_ty) => self.param_bound(param_ty),\n+            GenericKind::Projection(projection_ty) => self.projection_bound(projection_ty),\n+        }\n+    }\n+\n+    fn type_bound(&self, ty: Ty<'tcx>) -> VerifyBound<'tcx> {\n+        match ty.sty {\n+            ty::Param(p) => self.param_bound(p),\n+            ty::Projection(data) => self.projection_bound(data),\n+            _ => self.recursive_type_bound(ty),\n+        }\n+    }\n+\n+    fn param_bound(&self, param_ty: ty::ParamTy) -> VerifyBound<'tcx> {\n+        debug!(\"param_bound(param_ty={:?})\", param_ty);\n+\n+        // Start with anything like `T: 'a` we can scrape from the\n+        // environment\n+        let param_bounds = self.declared_generic_bounds_from_env(GenericKind::Param(param_ty))\n+            .into_iter()\n+            .map(|outlives| outlives.1);\n+\n+        // Add in the default bound of fn body that applies to all in\n+        // scope type parameters:\n+        let param_bounds = param_bounds.chain(self.implicit_region_bound);\n+\n+        VerifyBound::AnyBound(param_bounds.map(|r| VerifyBound::OutlivedBy(r)).collect())\n+    }\n+\n+    /// Given a projection like `T::Item`, searches the environment\n+    /// for where-clauses like `T::Item: 'a`. Returns the set of\n+    /// regions `'a` that it finds.\n+    ///\n+    /// This is an \"approximate\" check -- it may not find all\n+    /// applicable bounds, and not all the bounds it returns can be\n+    /// relied upon. In particular, this check ignores region\n+    /// identity.  So, for example, if we have `<T as\n+    /// Trait<'0>>::Item` where `'0` is a region variable, and the\n+    /// user has `<T as Trait<'a>>::Item: 'b` in the environment, then\n+    /// the clause from the environment only applies if `'0 = 'a`,\n+    /// which we don't know yet. But we would still include `'b` in\n+    /// this list.\n+    pub fn projection_approx_declared_bounds_from_env(\n+        &self,\n+        projection_ty: ty::ProjectionTy<'tcx>,\n+    ) -> Vec<ty::OutlivesPredicate<Ty<'tcx>, ty::Region<'tcx>>> {\n+        let projection_ty = GenericKind::Projection(projection_ty).to_ty(self.tcx);\n+        let erased_projection_ty = self.tcx.erase_regions(&projection_ty);\n+        self.declared_generic_bounds_from_env_with_compare_fn(|ty| {\n+            if let ty::Projection(..) = ty.sty {\n+                let erased_ty = self.tcx.erase_regions(&ty);\n+                erased_ty == erased_projection_ty\n+            } else {\n+                false\n+            }\n+        })\n+    }\n+\n+    /// Searches the where clauses in scope for regions that\n+    /// `projection_ty` is known to outlive. Currently requires an\n+    /// exact match.\n+    pub fn projection_declared_bounds_from_trait(\n+        &self,\n+        projection_ty: ty::ProjectionTy<'tcx>,\n+    ) -> impl Iterator<Item = ty::Region<'tcx>> + 'cx + Captures<'gcx> {\n+        self.declared_projection_bounds_from_trait(projection_ty)\n+    }\n+\n+    pub fn projection_bound(&self, projection_ty: ty::ProjectionTy<'tcx>) -> VerifyBound<'tcx> {\n+        debug!(\"projection_bound(projection_ty={:?})\", projection_ty);\n+\n+        let projection_ty_as_ty =\n+            self.tcx.mk_projection(projection_ty.item_def_id, projection_ty.substs);\n+\n+        // Search the env for where clauses like `P: 'a`.\n+        let env_bounds = self.projection_approx_declared_bounds_from_env(projection_ty)\n+            .into_iter()\n+            .map(|ty::OutlivesPredicate(ty, r)| {\n+                let vb = VerifyBound::OutlivedBy(r);\n+                if ty == projection_ty_as_ty {\n+                    // Micro-optimize if this is an exact match (this\n+                    // occurs often when there are no region variables\n+                    // involved).\n+                    vb\n+                } else {\n+                    VerifyBound::IfEq(ty, Box::new(vb))\n+                }\n+            });\n+\n+        // Extend with bounds that we can find from the trait.\n+        let trait_bounds = self.projection_declared_bounds_from_trait(projection_ty)\n+            .into_iter()\n+            .map(|r| VerifyBound::OutlivedBy(r));\n+\n+        // see the extensive comment in projection_must_outlive\n+        let ty = self.tcx\n+            .mk_projection(projection_ty.item_def_id, projection_ty.substs);\n+        let recursive_bound = self.recursive_type_bound(ty);\n+\n+        VerifyBound::AnyBound(env_bounds.chain(trait_bounds).collect()).or(recursive_bound)\n+    }\n+\n+    fn recursive_type_bound(&self, ty: Ty<'tcx>) -> VerifyBound<'tcx> {\n+        let mut bounds = ty.walk_shallow()\n+            .map(|subty| self.type_bound(subty))\n+            .collect::<Vec<_>>();\n+\n+        let mut regions = ty.regions();\n+        regions.retain(|r| !r.is_late_bound()); // ignore late-bound regions\n+        bounds.push(VerifyBound::AllBounds(\n+            regions\n+                .into_iter()\n+                .map(|r| VerifyBound::OutlivedBy(r))\n+                .collect(),\n+        ));\n+\n+        // remove bounds that must hold, since they are not interesting\n+        bounds.retain(|b| !b.must_hold());\n+\n+        if bounds.len() == 1 {\n+            bounds.pop().unwrap()\n+        } else {\n+            VerifyBound::AllBounds(bounds)\n+        }\n+    }\n+\n+    /// Searches the environment for where-clauses like `G: 'a` where\n+    /// `G` is either some type parameter `T` or a projection like\n+    /// `T::Item`. Returns a vector of the `'a` bounds it can find.\n+    ///\n+    /// This is a conservative check -- it may not find all applicable\n+    /// bounds, but all the bounds it returns can be relied upon.\n+    fn declared_generic_bounds_from_env(\n+        &self,\n+        generic: GenericKind<'tcx>,\n+    ) -> Vec<ty::OutlivesPredicate<Ty<'tcx>, ty::Region<'tcx>>> {\n+        let generic_ty = generic.to_ty(self.tcx);\n+        self.declared_generic_bounds_from_env_with_compare_fn(|ty| ty == generic_ty)\n+    }\n+\n+    fn declared_generic_bounds_from_env_with_compare_fn(\n+        &self,\n+        compare_ty: impl Fn(Ty<'tcx>) -> bool,\n+    ) -> Vec<ty::OutlivesPredicate<Ty<'tcx>, ty::Region<'tcx>>> {\n+        let tcx = self.tcx;\n+\n+        // To start, collect bounds from user environment. Note that\n+        // parameter environments are already elaborated, so we don't\n+        // have to worry about that. Comparing using `==` is a bit\n+        // dubious for projections, but it will work for simple cases\n+        // like `T` and `T::Item`. It may not work as well for things\n+        // like `<T as Foo<'a>>::Item`.\n+        let c_b = self.param_env.caller_bounds;\n+        let param_bounds = self.collect_outlives_from_predicate_list(&compare_ty, c_b);\n+\n+        // Next, collect regions we scraped from the well-formedness\n+        // constraints in the fn signature. To do that, we walk the list\n+        // of known relations from the fn ctxt.\n+        //\n+        // This is crucial because otherwise code like this fails:\n+        //\n+        //     fn foo<'a, A>(x: &'a A) { x.bar() }\n+        //\n+        // The problem is that the type of `x` is `&'a A`. To be\n+        // well-formed, then, A must be lower-generic by `'a`, but we\n+        // don't know that this holds from first principles.\n+        let from_region_bound_pairs = self.region_bound_pairs.iter().filter_map(|&(r, p)| {\n+            debug!(\n+                \"declared_generic_bounds_from_env_with_compare_fn: region_bound_pair = {:?}\",\n+                (r, p)\n+            );\n+            let p_ty = p.to_ty(tcx);\n+            if compare_ty(p_ty) {\n+                Some(ty::OutlivesPredicate(p_ty, r))\n+            } else {\n+                None\n+            }\n+        });\n+\n+        param_bounds\n+            .chain(from_region_bound_pairs)\n+            .inspect(|bound| {\n+                debug!(\n+                    \"declared_generic_bounds_from_env_with_compare_fn: result predicate = {:?}\",\n+                    bound\n+                )\n+            })\n+            .collect()\n+    }\n+\n+    /// Given a projection like `<T as Foo<'x>>::Bar`, returns any bounds\n+    /// declared in the trait definition. For example, if the trait were\n+    ///\n+    /// ```rust\n+    /// trait Foo<'a> {\n+    ///     type Bar: 'a;\n+    /// }\n+    /// ```\n+    ///\n+    /// then this function would return `'x`. This is subject to the\n+    /// limitations around higher-ranked bounds described in\n+    /// `region_bounds_declared_on_associated_item`.\n+    fn declared_projection_bounds_from_trait(\n+        &self,\n+        projection_ty: ty::ProjectionTy<'tcx>,\n+    ) -> impl Iterator<Item = ty::Region<'tcx>> + 'cx + Captures<'gcx> {\n+        debug!(\"projection_bounds(projection_ty={:?})\", projection_ty);\n+        let tcx = self.tcx;\n+        self.region_bounds_declared_on_associated_item(projection_ty.item_def_id)\n+            .map(move |r| r.subst(tcx, projection_ty.substs))\n+    }\n+\n+    /// Given the def-id of an associated item, returns any region\n+    /// bounds attached to that associated item from the trait definition.\n+    ///\n+    /// For example:\n+    ///\n+    /// ```rust\n+    /// trait Foo<'a> {\n+    ///     type Bar: 'a;\n+    /// }\n+    /// ```\n+    ///\n+    /// If we were given the def-id of `Foo::Bar`, we would return\n+    /// `'a`. You could then apply the substitutions from the\n+    /// projection to convert this into your namespace. This also\n+    /// works if the user writes `where <Self as Foo<'a>>::Bar: 'a` on\n+    /// the trait. In fact, it works by searching for just such a\n+    /// where-clause.\n+    ///\n+    /// It will not, however, work for higher-ranked bounds like:\n+    ///\n+    /// ```rust\n+    /// trait Foo<'a, 'b>\n+    /// where for<'x> <Self as Foo<'x, 'b>>::Bar: 'x\n+    /// {\n+    ///     type Bar;\n+    /// }\n+    /// ```\n+    ///\n+    /// This is for simplicity, and because we are not really smart\n+    /// enough to cope with such bounds anywhere.\n+    fn region_bounds_declared_on_associated_item(\n+        &self,\n+        assoc_item_def_id: DefId,\n+    ) -> impl Iterator<Item = ty::Region<'tcx>> + 'cx + Captures<'gcx> {\n+        let tcx = self.tcx;\n+        let assoc_item = tcx.associated_item(assoc_item_def_id);\n+        let trait_def_id = assoc_item.container.assert_trait();\n+        let trait_predicates = tcx.predicates_of(trait_def_id);\n+        let identity_substs = Substs::identity_for_item(tcx, assoc_item_def_id);\n+        let identity_proj = tcx.mk_projection(assoc_item_def_id, identity_substs);\n+        self.collect_outlives_from_predicate_list(\n+            move |ty| ty == identity_proj,\n+            traits::elaborate_predicates(tcx, trait_predicates.predicates),\n+        ).map(|b| b.1)\n+    }\n+\n+    /// Searches through a predicate list for a predicate `T: 'a`.\n+    ///\n+    /// Careful: does not elaborate predicates, and just uses `==`\n+    /// when comparing `ty` for equality, so `ty` must be something\n+    /// that does not involve inference variables and where you\n+    /// otherwise want a precise match.\n+    fn collect_outlives_from_predicate_list(\n+        &self,\n+        compare_ty: impl Fn(Ty<'tcx>) -> bool,\n+        predicates: impl IntoIterator<Item = impl AsRef<ty::Predicate<'tcx>>>,\n+    ) -> impl Iterator<Item = ty::OutlivesPredicate<Ty<'tcx>, ty::Region<'tcx>>> {\n+        predicates\n+            .into_iter()\n+            .filter_map(|p| p.as_ref().to_opt_type_outlives())\n+            .filter_map(|p| p.no_late_bound_regions())\n+            .filter(move |p| compare_ty(p.0))\n+    }\n+}"}, {"sha": "bc9027a08258c944d91223de0111f96238ae8a66", "filename": "src/librustc/infer/region_constraints/mod.rs", "status": "modified", "additions": 90, "deletions": 35, "changes": 125, "blob_url": "https://github.com/rust-lang/rust/blob/c7df1f530b8a88f471e60e933868e7ddf456974d/src%2Flibrustc%2Finfer%2Fregion_constraints%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7df1f530b8a88f471e60e933868e7ddf456974d/src%2Flibrustc%2Finfer%2Fregion_constraints%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fregion_constraints%2Fmod.rs?ref=c7df1f530b8a88f471e60e933868e7ddf456974d", "patch": "@@ -155,29 +155,94 @@ pub enum GenericKind<'tcx> {\n     Projection(ty::ProjectionTy<'tcx>),\n }\n \n-/// When we introduce a verification step, we wish to test that a\n-/// particular region (let's call it `'min`) meets some bound.\n-/// The bound is described the by the following grammar:\n+EnumTypeFoldableImpl! {\n+    impl<'tcx> TypeFoldable<'tcx> for GenericKind<'tcx> {\n+        (GenericKind::Param)(a),\n+        (GenericKind::Projection)(a),\n+    }\n+}\n+\n+/// Describes the things that some `GenericKind` value G is known to\n+/// outlive. Each variant of `VerifyBound` can be thought of as a\n+/// function:\n+///\n+///     fn(min: Region) -> bool { .. }\n+///\n+/// where `true` means that the region `min` meets that `G: min`.\n+/// (False means nothing.)\n+///\n+/// So, for example, if we have the type `T` and we have in scope that\n+/// `T: 'a` and `T: 'b`, then the verify bound might be:\n+///\n+///     fn(min: Region) -> bool {\n+///        ('a: min) || ('b: min)\n+///     }\n+///\n+/// This is described with a `AnyRegion('a, 'b)` node.\n #[derive(Debug, Clone)]\n pub enum VerifyBound<'tcx> {\n-    /// B = exists {R} --> some 'r in {R} must outlive 'min\n+    /// Given a kind K and a bound B, expands to a function like the\n+    /// following, where `G` is the generic for which this verify\n+    /// bound was created:\n+    ///\n+    ///     fn(min) -> bool {\n+    ///       if G == K {\n+    ///         B(min)\n+    ///       } else {\n+    ///         false\n+    ///       }\n+    ///     }\n+    ///\n+    /// In other words, if the generic `G` that we are checking is\n+    /// equal to `K`, then check the associated verify bound\n+    /// (otherwise, false).\n     ///\n-    /// Put another way, the subject value is known to outlive all\n-    /// regions in {R}, so if any of those outlives 'min, then the\n-    /// bound is met.\n-    AnyRegion(Vec<Region<'tcx>>),\n+    /// This is used when we have something in the environment that\n+    /// may or may not be relevant, depending on the region inference\n+    /// results. For example, we may have `where <T as\n+    /// Trait<'a>>::Item: 'b` in our where clauses. If we are\n+    /// generating the verify-bound for `<T as Trait<'0>>::Item`, then\n+    /// this where-clause is only relevant if `'0` winds up inferred\n+    /// to `'a`.\n+    ///\n+    /// So we would compile to a verify-bound like\n+    ///\n+    ///     IfEq(<T as Trait<'a>>::Item, AnyRegion('a))\n+    ///\n+    /// meaning, if the subject G is equal to `<T as Trait<'a>>::Item`\n+    /// (after inference), and `'a: min`, then `G: min`.\n+    IfEq(Ty<'tcx>, Box<VerifyBound<'tcx>>),\n \n-    /// B = forall {R} --> all 'r in {R} must outlive 'min\n+    /// Given a region `R`, expands to the function:\n+    ///\n+    ///     fn(min) -> bool {\n+    ///       R: min\n+    ///     }\n     ///\n-    /// Put another way, the subject value is known to outlive some\n-    /// region in {R}, so if all of those outlives 'min, then the bound\n-    /// is met.\n-    AllRegions(Vec<Region<'tcx>>),\n+    /// This is used when we can establish that `G: R` -- therefore,\n+    /// if `R: min`, then by transitivity `G: min`.\n+    OutlivedBy(Region<'tcx>),\n \n-    /// B = exists {B} --> 'min must meet some bound b in {B}\n+    /// Given a set of bounds `B`, expands to the function:\n+    ///\n+    ///     fn(min) -> bool {\n+    ///       exists (b in B) { b(min) }\n+    ///     }\n+    ///\n+    /// In other words, if we meet some bound in `B`, that suffices.\n+    /// This is used when all the bounds in `B` are known to apply to\n+    /// G.\n     AnyBound(Vec<VerifyBound<'tcx>>),\n \n-    /// B = forall {B} --> 'min must meet all bounds b in {B}\n+    /// Given a set of bounds `B`, expands to the function:\n+    ///\n+    ///     fn(min) -> bool {\n+    ///       forall (b in B) { b(min) }\n+    ///     }\n+    ///\n+    /// In other words, if we meet *all* bounds in `B`, that suffices.\n+    /// This is used when *some* bound in `B` is known to suffice, but\n+    /// we don't know which.\n     AllBounds(Vec<VerifyBound<'tcx>>),\n }\n \n@@ -882,33 +947,23 @@ impl<'a, 'gcx, 'tcx> GenericKind<'tcx> {\n }\n \n impl<'a, 'gcx, 'tcx> VerifyBound<'tcx> {\n-    fn for_each_region(&self, f: &mut dyn FnMut(ty::Region<'tcx>)) {\n-        match self {\n-            &VerifyBound::AnyRegion(ref rs) | &VerifyBound::AllRegions(ref rs) => for &r in rs {\n-                f(r);\n-            },\n-\n-            &VerifyBound::AnyBound(ref bs) | &VerifyBound::AllBounds(ref bs) => for b in bs {\n-                b.for_each_region(f);\n-            },\n-        }\n-    }\n-\n     pub fn must_hold(&self) -> bool {\n         match self {\n-            &VerifyBound::AnyRegion(ref bs) => bs.contains(&&ty::ReStatic),\n-            &VerifyBound::AllRegions(ref bs) => bs.is_empty(),\n-            &VerifyBound::AnyBound(ref bs) => bs.iter().any(|b| b.must_hold()),\n-            &VerifyBound::AllBounds(ref bs) => bs.iter().all(|b| b.must_hold()),\n+            VerifyBound::IfEq(..) => false,\n+            VerifyBound::OutlivedBy(ty::ReStatic) => true,\n+            VerifyBound::OutlivedBy(_) => false,\n+            VerifyBound::AnyBound(bs) => bs.iter().any(|b| b.must_hold()),\n+            VerifyBound::AllBounds(bs) => bs.iter().all(|b| b.must_hold()),\n         }\n     }\n \n     pub fn cannot_hold(&self) -> bool {\n         match self {\n-            &VerifyBound::AnyRegion(ref bs) => bs.is_empty(),\n-            &VerifyBound::AllRegions(ref bs) => bs.contains(&&ty::ReEmpty),\n-            &VerifyBound::AnyBound(ref bs) => bs.iter().all(|b| b.cannot_hold()),\n-            &VerifyBound::AllBounds(ref bs) => bs.iter().any(|b| b.cannot_hold()),\n+            VerifyBound::IfEq(_, b) => b.cannot_hold(),\n+            VerifyBound::OutlivedBy(ty::ReEmpty) => true,\n+            VerifyBound::OutlivedBy(_) => false,\n+            VerifyBound::AnyBound(bs) => bs.iter().all(|b| b.cannot_hold()),\n+            VerifyBound::AllBounds(bs) => bs.iter().any(|b| b.cannot_hold()),\n         }\n     }\n "}, {"sha": "4f513cd5d484d99ec1fd6f222f86996754c2fea8", "filename": "src/librustc/infer/region_constraints/taint.rs", "status": "modified", "additions": 25, "deletions": 25, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/c7df1f530b8a88f471e60e933868e7ddf456974d/src%2Flibrustc%2Finfer%2Fregion_constraints%2Ftaint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7df1f530b8a88f471e60e933868e7ddf456974d/src%2Flibrustc%2Finfer%2Fregion_constraints%2Ftaint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fregion_constraints%2Ftaint.rs?ref=c7df1f530b8a88f471e60e933868e7ddf456974d", "patch": "@@ -13,34 +13,39 @@ use super::*;\n #[derive(Debug)]\n pub(super) struct TaintSet<'tcx> {\n     directions: TaintDirections,\n-    regions: FxHashSet<ty::Region<'tcx>>\n+    regions: FxHashSet<ty::Region<'tcx>>,\n }\n \n impl<'tcx> TaintSet<'tcx> {\n-    pub(super) fn new(directions: TaintDirections,\n-                      initial_region: ty::Region<'tcx>)\n-                      -> Self {\n+    pub(super) fn new(directions: TaintDirections, initial_region: ty::Region<'tcx>) -> Self {\n         let mut regions = FxHashSet();\n         regions.insert(initial_region);\n-        TaintSet { directions: directions, regions: regions }\n+        TaintSet {\n+            directions: directions,\n+            regions: regions,\n+        }\n     }\n \n-    pub(super) fn fixed_point(&mut self,\n-                              tcx: TyCtxt<'_, '_, 'tcx>,\n-                              undo_log: &[UndoLogEntry<'tcx>],\n-                              verifys: &[Verify<'tcx>]) {\n+    pub(super) fn fixed_point(\n+        &mut self,\n+        tcx: TyCtxt<'_, '_, 'tcx>,\n+        undo_log: &[UndoLogEntry<'tcx>],\n+        verifys: &[Verify<'tcx>],\n+    ) {\n         let mut prev_len = 0;\n         while prev_len < self.len() {\n-            debug!(\"tainted: prev_len = {:?} new_len = {:?}\",\n-                   prev_len, self.len());\n+            debug!(\n+                \"tainted: prev_len = {:?} new_len = {:?}\",\n+                prev_len,\n+                self.len()\n+            );\n \n             prev_len = self.len();\n \n             for undo_entry in undo_log {\n                 match undo_entry {\n                     &AddConstraint(Constraint::VarSubVar(a, b)) => {\n-                        self.add_edge(tcx.mk_region(ReVar(a)),\n-                                      tcx.mk_region(ReVar(b)));\n+                        self.add_edge(tcx.mk_region(ReVar(a)), tcx.mk_region(ReVar(b)));\n                     }\n                     &AddConstraint(Constraint::RegSubVar(a, b)) => {\n                         self.add_edge(a, tcx.mk_region(ReVar(b)));\n@@ -55,15 +60,13 @@ impl<'tcx> TaintSet<'tcx> {\n                         self.add_edge(a, tcx.mk_region(ReVar(b)));\n                     }\n                     &AddVerify(i) => {\n-                        verifys[i].bound.for_each_region(&mut |b| {\n-                            self.add_edge(verifys[i].region, b);\n-                        });\n+                        span_bug!(\n+                            verifys[i].origin.span(),\n+                            \"we never add verifications while doing higher-ranked things\",\n+                        )\n                     }\n-                    &Purged |\n-                    &AddCombination(..) |\n-                    &AddVar(..) |\n-                    &OpenSnapshot |\n-                    &CommitedSnapshot => {}\n+                    &Purged | &AddCombination(..) | &AddVar(..) | &OpenSnapshot\n+                    | &CommitedSnapshot => {}\n                 }\n             }\n         }\n@@ -77,9 +80,7 @@ impl<'tcx> TaintSet<'tcx> {\n         self.regions.len()\n     }\n \n-    fn add_edge(&mut self,\n-                source: ty::Region<'tcx>,\n-                target: ty::Region<'tcx>) {\n+    fn add_edge(&mut self, source: ty::Region<'tcx>, target: ty::Region<'tcx>) {\n         if self.directions.incoming {\n             if self.regions.contains(&target) {\n                 self.regions.insert(source);\n@@ -93,4 +94,3 @@ impl<'tcx> TaintSet<'tcx> {\n         }\n     }\n }\n-"}, {"sha": "8f106a08125386a56ee32998d2b3cbe0eeb554eb", "filename": "src/librustc/traits/auto_trait.rs", "status": "modified", "additions": 43, "deletions": 56, "changes": 99, "blob_url": "https://github.com/rust-lang/rust/blob/c7df1f530b8a88f471e60e933868e7ddf456974d/src%2Flibrustc%2Ftraits%2Fauto_trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7df1f530b8a88f471e60e933868e7ddf456974d/src%2Flibrustc%2Ftraits%2Fauto_trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fauto_trait.rs?ref=c7df1f530b8a88f471e60e933868e7ddf456974d", "patch": "@@ -16,10 +16,9 @@ use super::*;\n use std::collections::hash_map::Entry;\n use std::collections::VecDeque;\n \n-use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n-\n use infer::region_constraints::{Constraint, RegionConstraintData};\n-use infer::{InferCtxt, RegionObligation};\n+use infer::InferCtxt;\n+use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n \n use ty::fold::TypeFolder;\n use ty::{Region, RegionVid};\n@@ -227,20 +226,18 @@ impl<'a, 'tcx> AutoTraitFinder<'a, 'tcx> {\n                 .iter()\n                 .filter_map(|param| match param.kind {\n                     ty::GenericParamDefKind::Lifetime => Some(param.name.to_string()),\n-                    _ => None\n+                    _ => None,\n                 })\n                 .collect();\n \n-            let body_ids: FxHashSet<_> = infcx\n+            let body_id_map: FxHashMap<_, _> = infcx\n                 .region_obligations\n                 .borrow()\n                 .iter()\n-                .map(|&(id, _)| id)\n+                .map(|&(id, _)| (id, vec![]))\n                 .collect();\n \n-            for id in body_ids {\n-                infcx.process_registered_region_obligations(&[], None, full_env.clone(), id);\n-            }\n+            infcx.process_registered_region_obligations(&body_id_map, None, full_env.clone());\n \n             let region_data = infcx\n                 .borrow_region_constraints()\n@@ -359,8 +356,10 @@ impl<'a, 'tcx> AutoTraitFinder<'a, 'tcx> {\n                 &Err(SelectionError::Unimplemented) => {\n                     if self.is_of_param(pred.skip_binder().trait_ref.substs) {\n                         already_visited.remove(&pred);\n-                        self.add_user_pred(&mut user_computed_preds,\n-                                           ty::Predicate::Trait(pred.clone()));\n+                        self.add_user_pred(\n+                            &mut user_computed_preds,\n+                            ty::Predicate::Trait(pred.clone()),\n+                        );\n                         predicates.push_back(pred);\n                     } else {\n                         debug!(\n@@ -418,8 +417,11 @@ impl<'a, 'tcx> AutoTraitFinder<'a, 'tcx> {\n     // under which a type implements an auto trait. A trait predicate involving\n     // a HRTB means that the type needs to work with any choice of lifetime,\n     // not just one specific lifetime (e.g. 'static).\n-    fn add_user_pred<'c>(&self, user_computed_preds: &mut FxHashSet<ty::Predicate<'c>>,\n-                         new_pred: ty::Predicate<'c>) {\n+    fn add_user_pred<'c>(\n+        &self,\n+        user_computed_preds: &mut FxHashSet<ty::Predicate<'c>>,\n+        new_pred: ty::Predicate<'c>,\n+    ) {\n         let mut should_add_new = true;\n         user_computed_preds.retain(|&old_pred| {\n             match (&new_pred, old_pred) {\n@@ -431,20 +433,19 @@ impl<'a, 'tcx> AutoTraitFinder<'a, 'tcx> {\n                         if !new_substs.types().eq(old_substs.types()) {\n                             // We can't compare lifetimes if the types are different,\n                             // so skip checking old_pred\n-                            return true\n+                            return true;\n                         }\n \n-                        for (new_region, old_region) in new_substs\n-                            .regions()\n-                            .zip(old_substs.regions()) {\n-\n+                        for (new_region, old_region) in\n+                            new_substs.regions().zip(old_substs.regions())\n+                        {\n                             match (new_region, old_region) {\n                                 // If both predicates have an 'ReLateBound' (a HRTB) in the\n                                 // same spot, we do nothing\n                                 (\n                                     ty::RegionKind::ReLateBound(_, _),\n-                                    ty::RegionKind::ReLateBound(_, _)\n-                                ) => {},\n+                                    ty::RegionKind::ReLateBound(_, _),\n+                                ) => {}\n \n                                 (ty::RegionKind::ReLateBound(_, _), _) => {\n                                     // The new predicate has a HRTB in a spot where the old\n@@ -458,7 +459,7 @@ impl<'a, 'tcx> AutoTraitFinder<'a, 'tcx> {\n                                     // so we return 'false' to remove the old predicate from\n                                     // user_computed_preds\n                                     return false;\n-                                },\n+                                }\n                                 (_, ty::RegionKind::ReLateBound(_, _)) => {\n                                     // This is the opposite situation as the previous arm - the\n                                     // old predicate has a HRTB lifetime in a place where the\n@@ -471,10 +472,10 @@ impl<'a, 'tcx> AutoTraitFinder<'a, 'tcx> {\n                             }\n                         }\n                     }\n-                },\n+                }\n                 _ => {}\n             }\n-            return true\n+            return true;\n         });\n \n         if should_add_new {\n@@ -513,44 +514,32 @@ impl<'a, 'tcx> AutoTraitFinder<'a, 'tcx> {\n             match constraint {\n                 &Constraint::VarSubVar(r1, r2) => {\n                     {\n-                        let deps1 = vid_map\n-                            .entry(RegionTarget::RegionVid(r1))\n-                            .or_default();\n+                        let deps1 = vid_map.entry(RegionTarget::RegionVid(r1)).or_default();\n                         deps1.larger.insert(RegionTarget::RegionVid(r2));\n                     }\n \n-                    let deps2 = vid_map\n-                        .entry(RegionTarget::RegionVid(r2))\n-                        .or_default();\n+                    let deps2 = vid_map.entry(RegionTarget::RegionVid(r2)).or_default();\n                     deps2.smaller.insert(RegionTarget::RegionVid(r1));\n                 }\n                 &Constraint::RegSubVar(region, vid) => {\n                     {\n-                        let deps1 = vid_map\n-                            .entry(RegionTarget::Region(region))\n-                            .or_default();\n+                        let deps1 = vid_map.entry(RegionTarget::Region(region)).or_default();\n                         deps1.larger.insert(RegionTarget::RegionVid(vid));\n                     }\n \n-                    let deps2 = vid_map\n-                        .entry(RegionTarget::RegionVid(vid))\n-                        .or_default();\n+                    let deps2 = vid_map.entry(RegionTarget::RegionVid(vid)).or_default();\n                     deps2.smaller.insert(RegionTarget::Region(region));\n                 }\n                 &Constraint::VarSubReg(vid, region) => {\n                     finished_map.insert(vid, region);\n                 }\n                 &Constraint::RegSubReg(r1, r2) => {\n                     {\n-                        let deps1 = vid_map\n-                            .entry(RegionTarget::Region(r1))\n-                            .or_default();\n+                        let deps1 = vid_map.entry(RegionTarget::Region(r1)).or_default();\n                         deps1.larger.insert(RegionTarget::Region(r2));\n                     }\n \n-                    let deps2 = vid_map\n-                        .entry(RegionTarget::Region(r2))\n-                        .or_default();\n+                    let deps2 = vid_map.entry(RegionTarget::Region(r2)).or_default();\n                     deps2.smaller.insert(RegionTarget::Region(r1));\n                 }\n             }\n@@ -683,7 +672,11 @@ impl<'a, 'tcx> AutoTraitFinder<'a, 'tcx> {\n                     }\n                 }\n                 &ty::Predicate::RegionOutlives(ref binder) => {\n-                    if select.infcx().region_outlives_predicate(&dummy_cause, binder).is_err() {\n+                    if select\n+                        .infcx()\n+                        .region_outlives_predicate(&dummy_cause, binder)\n+                        .is_err()\n+                    {\n                         return false;\n                     }\n                 }\n@@ -693,23 +686,17 @@ impl<'a, 'tcx> AutoTraitFinder<'a, 'tcx> {\n                         binder.map_bound_ref(|pred| pred.0).no_late_bound_regions(),\n                     ) {\n                         (None, Some(t_a)) => {\n-                            select.infcx().register_region_obligation(\n-                                ast::DUMMY_NODE_ID,\n-                                RegionObligation {\n-                                    sup_type: t_a,\n-                                    sub_region: select.infcx().tcx.types.re_static,\n-                                    cause: dummy_cause.clone(),\n-                                },\n+                            select.infcx().register_region_obligation_with_cause(\n+                                t_a,\n+                                select.infcx().tcx.types.re_static,\n+                                &dummy_cause,\n                             );\n                         }\n                         (Some(ty::OutlivesPredicate(t_a, r_b)), _) => {\n-                            select.infcx().register_region_obligation(\n-                                ast::DUMMY_NODE_ID,\n-                                RegionObligation {\n-                                    sup_type: t_a,\n-                                    sub_region: r_b,\n-                                    cause: dummy_cause.clone(),\n-                                },\n+                            select.infcx().register_region_obligation_with_cause(\n+                                t_a,\n+                                r_b,\n+                                &dummy_cause,\n                             );\n                         }\n                         _ => {}"}, {"sha": "19ee2c1aabfa47c8c0e9bd10b4f21b0a9ea920bd", "filename": "src/librustc/traits/fulfill.rs", "status": "modified", "additions": 11, "deletions": 15, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/c7df1f530b8a88f471e60e933868e7ddf456974d/src%2Flibrustc%2Ftraits%2Ffulfill.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7df1f530b8a88f471e60e933868e7ddf456974d/src%2Flibrustc%2Ftraits%2Ffulfill.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Ffulfill.rs?ref=c7df1f530b8a88f471e60e933868e7ddf456974d", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use infer::{RegionObligation, InferCtxt};\n+use infer::InferCtxt;\n use mir::interpret::GlobalId;\n use ty::{self, Ty, TypeFoldable, ToPolyTraitRef, ToPredicate};\n use ty::error::ExpectedFound;\n@@ -372,13 +372,11 @@ impl<'a, 'b, 'gcx, 'tcx> ObligationProcessor for FulfillProcessor<'a, 'b, 'gcx,\n                             Some(t_a) => {\n                                 let r_static = self.selcx.tcx().types.re_static;\n                                 if self.register_region_obligations {\n-                                    self.selcx.infcx().register_region_obligation(\n-                                        obligation.cause.body_id,\n-                                        RegionObligation {\n-                                            sup_type: t_a,\n-                                            sub_region: r_static,\n-                                            cause: obligation.cause.clone(),\n-                                        });\n+                                    self.selcx.infcx().register_region_obligation_with_cause(\n+                                        t_a,\n+                                        r_static,\n+                                        &obligation.cause,\n+                                    );\n                                 }\n                                 ProcessResult::Changed(vec![])\n                             }\n@@ -387,13 +385,11 @@ impl<'a, 'b, 'gcx, 'tcx> ObligationProcessor for FulfillProcessor<'a, 'b, 'gcx,\n                     // If there aren't, register the obligation.\n                     Some(ty::OutlivesPredicate(t_a, r_b)) => {\n                         if self.register_region_obligations {\n-                            self.selcx.infcx().register_region_obligation(\n-                                obligation.cause.body_id,\n-                                RegionObligation {\n-                                    sup_type: t_a,\n-                                    sub_region: r_b,\n-                                    cause: obligation.cause.clone()\n-                                });\n+                            self.selcx.infcx().register_region_obligation_with_cause(\n+                                t_a,\n+                                r_b,\n+                                &obligation.cause,\n+                            );\n                         }\n                         ProcessResult::Changed(vec![])\n                     }"}, {"sha": "406d3a55b1f7cb60812d1a327bb714587e6bdcd4", "filename": "src/librustc/traits/mod.rs", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/c7df1f530b8a88f471e60e933868e7ddf456974d/src%2Flibrustc%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7df1f530b8a88f471e60e933868e7ddf456974d/src%2Flibrustc%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fmod.rs?ref=c7df1f530b8a88f471e60e933868e7ddf456974d", "patch": "@@ -20,6 +20,7 @@ pub use self::ObligationCauseCode::*;\n use chalk_engine;\n use hir;\n use hir::def_id::DefId;\n+use infer::SuppressRegionErrors;\n use infer::outlives::env::OutlivesEnvironment;\n use middle::region;\n use mir::interpret::ConstEvalErr;\n@@ -715,7 +716,12 @@ pub fn normalize_param_env_or_error<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         // cares about declarations like `'a: 'b`.\n         let outlives_env = OutlivesEnvironment::new(elaborated_env);\n \n-        infcx.resolve_regions_and_report_errors(region_context, &region_scope_tree, &outlives_env);\n+        infcx.resolve_regions_and_report_errors(\n+            region_context,\n+            &region_scope_tree,\n+            &outlives_env,\n+            SuppressRegionErrors::default(),\n+        );\n \n         let predicates = match infcx.fully_resolve(&predicates) {\n             Ok(predicates) => predicates,"}, {"sha": "a59bf9d530c4d0919001c3c81f23a33c9c0bbb40", "filename": "src/librustc_data_structures/indexed_vec.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/c7df1f530b8a88f471e60e933868e7ddf456974d/src%2Flibrustc_data_structures%2Findexed_vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7df1f530b8a88f471e60e933868e7ddf456974d/src%2Flibrustc_data_structures%2Findexed_vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Findexed_vec.rs?ref=c7df1f530b8a88f471e60e933868e7ddf456974d", "patch": "@@ -535,6 +535,13 @@ impl<I: Idx, T> IndexVec<I, T> {\n         self.raw.len()\n     }\n \n+    /// Gives the next index that will be assigned when `push` is\n+    /// called.\n+    #[inline]\n+    pub fn next_index(&self) -> I {\n+        I::new(self.len())\n+    }\n+\n     #[inline]\n     pub fn is_empty(&self) -> bool {\n         self.raw.is_empty()"}, {"sha": "f18f40bf7a1448851a6bc44b398673d86a8eb76b", "filename": "src/librustc_driver/test.rs", "status": "modified", "additions": 219, "deletions": 163, "changes": 382, "blob_url": "https://github.com/rust-lang/rust/blob/c7df1f530b8a88f471e60e933868e7ddf456974d/src%2Flibrustc_driver%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7df1f530b8a88f471e60e933868e7ddf456974d/src%2Flibrustc_driver%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Ftest.rs?ref=c7df1f530b8a88f471e60e933868e7ddf456974d", "patch": "@@ -14,29 +14,29 @@ use std::path::PathBuf;\n use std::sync::mpsc;\n \n use driver;\n-use rustc_lint;\n-use rustc_resolve::MakeGlobMap;\n-use rustc::middle::region;\n-use rustc::ty::subst::Subst;\n-use rustc::traits::ObligationCause;\n-use rustc::ty::{self, Ty, TyCtxt, TypeFoldable};\n-use rustc::ty::query::OnDiskCache;\n-use rustc::infer::{self, InferOk, InferResult};\n+use errors;\n+use errors::emitter::Emitter;\n+use errors::{DiagnosticBuilder, Level};\n+use rustc::hir::map as hir_map;\n use rustc::infer::outlives::env::OutlivesEnvironment;\n use rustc::infer::type_variable::TypeVariableOrigin;\n-use rustc_metadata::cstore::CStore;\n-use rustc::hir::map as hir_map;\n-use rustc::session::{self, config};\n+use rustc::infer::{self, InferOk, InferResult, SuppressRegionErrors};\n+use rustc::middle::region;\n use rustc::session::config::{OutputFilenames, OutputTypes};\n+use rustc::session::{self, config};\n+use rustc::traits::ObligationCause;\n+use rustc::ty::query::OnDiskCache;\n+use rustc::ty::subst::Subst;\n+use rustc::ty::{self, Ty, TyCtxt, TypeFoldable};\n use rustc_data_structures::sync::{self, Lrc};\n+use rustc_lint;\n+use rustc_metadata::cstore::CStore;\n+use rustc_resolve::MakeGlobMap;\n+use rustc_target::spec::abi::Abi;\n use syntax;\n use syntax::ast;\n-use rustc_target::spec::abi::Abi;\n-use syntax::source_map::{SourceMap, FilePathMapping, FileName};\n-use errors;\n-use errors::emitter::Emitter;\n-use errors::{Level, DiagnosticBuilder};\n use syntax::feature_gate::UnstableFeatures;\n+use syntax::source_map::{FileName, FilePathMapping, SourceMap};\n use syntax::symbol::Symbol;\n use syntax_pos::DUMMY_SP;\n \n@@ -90,13 +90,15 @@ impl Emitter for ExpectErrorEmitter {\n \n fn errors(msgs: &[&str]) -> (Box<dyn Emitter + sync::Send>, usize) {\n     let v = msgs.iter().map(|m| m.to_string()).collect();\n-    (box ExpectErrorEmitter { messages: v } as Box<dyn Emitter + sync::Send>, msgs.len())\n+    (\n+        box ExpectErrorEmitter { messages: v } as Box<dyn Emitter + sync::Send>,\n+        msgs.len(),\n+    )\n }\n \n-fn test_env<F>(source_string: &str,\n-               args: (Box<dyn Emitter + sync::Send>, usize),\n-               body: F)\n-    where F: FnOnce(Env)\n+fn test_env<F>(source_string: &str, args: (Box<dyn Emitter + sync::Send>, usize), body: F)\n+where\n+    F: FnOnce(Env),\n {\n     syntax::with_globals(|| {\n         let mut options = config::Options::default();\n@@ -113,34 +115,41 @@ fn test_env_with_pool<F>(\n     options: config::Options,\n     source_string: &str,\n     (emitter, expected_err_count): (Box<dyn Emitter + sync::Send>, usize),\n-    body: F\n-)\n-    where F: FnOnce(Env)\n+    body: F,\n+) where\n+    F: FnOnce(Env),\n {\n     let diagnostic_handler = errors::Handler::with_emitter(true, false, emitter);\n-    let sess = session::build_session_(options,\n-                                       None,\n-                                       diagnostic_handler,\n-                                       Lrc::new(SourceMap::new(FilePathMapping::empty())));\n+    let sess = session::build_session_(\n+        options,\n+        None,\n+        diagnostic_handler,\n+        Lrc::new(SourceMap::new(FilePathMapping::empty())),\n+    );\n     let cstore = CStore::new(::get_codegen_backend(&sess).metadata_loader());\n     rustc_lint::register_builtins(&mut sess.lint_store.borrow_mut(), Some(&sess));\n     let input = config::Input::Str {\n         name: FileName::Anon,\n         input: source_string.to_string(),\n     };\n-    let krate = driver::phase_1_parse_input(&driver::CompileController::basic(),\n-                                            &sess,\n-                                            &input).unwrap();\n-    let driver::ExpansionResult { defs, resolutions, mut hir_forest, .. } = {\n-        driver::phase_2_configure_and_expand(&sess,\n-                                             &cstore,\n-                                             krate,\n-                                             None,\n-                                             \"test\",\n-                                             None,\n-                                             MakeGlobMap::No,\n-                                             |_| Ok(()))\n-            .expect(\"phase 2 aborted\")\n+    let krate =\n+        driver::phase_1_parse_input(&driver::CompileController::basic(), &sess, &input).unwrap();\n+    let driver::ExpansionResult {\n+        defs,\n+        resolutions,\n+        mut hir_forest,\n+        ..\n+    } = {\n+        driver::phase_2_configure_and_expand(\n+            &sess,\n+            &cstore,\n+            krate,\n+            None,\n+            \"test\",\n+            None,\n+            MakeGlobMap::No,\n+            |_| Ok(()),\n+        ).expect(\"phase 2 aborted\")\n     };\n \n     let arenas = ty::AllArenas::new();\n@@ -155,32 +164,39 @@ fn test_env_with_pool<F>(\n         extra: String::new(),\n         outputs: OutputTypes::new(&[]),\n     };\n-    TyCtxt::create_and_enter(&sess,\n-                             &cstore,\n-                             ty::query::Providers::default(),\n-                             ty::query::Providers::default(),\n-                             &arenas,\n-                             resolutions,\n-                             hir_map,\n-                             OnDiskCache::new_empty(sess.source_map()),\n-                             \"test_crate\",\n-                             tx,\n-                             &outputs,\n-                             |tcx| {\n-        tcx.infer_ctxt().enter(|infcx| {\n-            let mut region_scope_tree = region::ScopeTree::default();\n-            let param_env = ty::ParamEnv::empty();\n-            body(Env {\n-                infcx: &infcx,\n-                region_scope_tree: &mut region_scope_tree,\n-                param_env: param_env,\n+    TyCtxt::create_and_enter(\n+        &sess,\n+        &cstore,\n+        ty::query::Providers::default(),\n+        ty::query::Providers::default(),\n+        &arenas,\n+        resolutions,\n+        hir_map,\n+        OnDiskCache::new_empty(sess.source_map()),\n+        \"test_crate\",\n+        tx,\n+        &outputs,\n+        |tcx| {\n+            tcx.infer_ctxt().enter(|infcx| {\n+                let mut region_scope_tree = region::ScopeTree::default();\n+                let param_env = ty::ParamEnv::empty();\n+                body(Env {\n+                    infcx: &infcx,\n+                    region_scope_tree: &mut region_scope_tree,\n+                    param_env: param_env,\n+                });\n+                let outlives_env = OutlivesEnvironment::new(param_env);\n+                let def_id = tcx.hir.local_def_id(ast::CRATE_NODE_ID);\n+                infcx.resolve_regions_and_report_errors(\n+                    def_id,\n+                    &region_scope_tree,\n+                    &outlives_env,\n+                    SuppressRegionErrors::default(),\n+                );\n+                assert_eq!(tcx.sess.err_count(), expected_err_count);\n             });\n-            let outlives_env = OutlivesEnvironment::new(param_env);\n-            let def_id = tcx.hir.local_def_id(ast::CRATE_NODE_ID);\n-            infcx.resolve_regions_and_report_errors(def_id, &region_scope_tree, &outlives_env);\n-            assert_eq!(tcx.sess.err_count(), expected_err_count);\n-        });\n-    });\n+        },\n+    );\n }\n \n fn d1() -> ty::DebruijnIndex {\n@@ -196,9 +212,15 @@ impl<'a, 'gcx, 'tcx> Env<'a, 'gcx, 'tcx> {\n         self.infcx.tcx\n     }\n \n-    pub fn create_region_hierarchy(&mut self, rh: &RH,\n-                                   parent: (region::Scope, region::ScopeDepth)) {\n-        let me = region::Scope { id: rh.id, data: region::ScopeData::Node };\n+    pub fn create_region_hierarchy(\n+        &mut self,\n+        rh: &RH,\n+        parent: (region::Scope, region::ScopeDepth),\n+    ) {\n+        let me = region::Scope {\n+            id: rh.id,\n+            data: region::ScopeData::Node,\n+        };\n         self.region_scope_tree.record_scope_parent(me, Some(parent));\n         for child_rh in rh.sub {\n             self.create_region_hierarchy(child_rh, (me, parent.1 + 1));\n@@ -211,20 +233,25 @@ impl<'a, 'gcx, 'tcx> Env<'a, 'gcx, 'tcx> {\n \n         let dscope = region::Scope {\n             id: hir::ItemLocalId(1),\n-            data: region::ScopeData::Destruction\n+            data: region::ScopeData::Destruction,\n         };\n         self.region_scope_tree.record_scope_parent(dscope, None);\n-        self.create_region_hierarchy(&RH {\n-            id: hir::ItemLocalId(1),\n-            sub: &[RH {\n-                id: hir::ItemLocalId(10),\n-                sub: &[],\n+        self.create_region_hierarchy(\n+            &RH {\n+                id: hir::ItemLocalId(1),\n+                sub: &[\n+                    RH {\n+                        id: hir::ItemLocalId(10),\n+                        sub: &[],\n+                    },\n+                    RH {\n+                        id: hir::ItemLocalId(11),\n+                        sub: &[],\n+                    },\n+                ],\n             },\n-            RH {\n-                id: hir::ItemLocalId(11),\n-                sub: &[],\n-            }],\n-        }, (dscope, 1));\n+            (dscope, 1),\n+        );\n     }\n \n     #[allow(dead_code)] // this seems like it could be useful, even if we don't use it now\n@@ -236,11 +263,12 @@ impl<'a, 'gcx, 'tcx> Env<'a, 'gcx, 'tcx> {\n             }\n         };\n \n-        fn search_mod(this: &Env,\n-                      m: &hir::Mod,\n-                      idx: usize,\n-                      names: &[String])\n-                      -> Option<ast::NodeId> {\n+        fn search_mod(\n+            this: &Env,\n+            m: &hir::Mod,\n+            idx: usize,\n+            names: &[String],\n+        ) -> Option<ast::NodeId> {\n             assert!(idx < names.len());\n             for item in &m.item_ids {\n                 let item = this.infcx.tcx.hir.expect_item(item.id);\n@@ -257,30 +285,33 @@ impl<'a, 'gcx, 'tcx> Env<'a, 'gcx, 'tcx> {\n             }\n \n             return match it.node {\n-                hir::ItemKind::Use(..) |\n-                hir::ItemKind::ExternCrate(..) |\n-                hir::ItemKind::Const(..) |\n-                hir::ItemKind::Static(..) |\n-                hir::ItemKind::Fn(..) |\n-                hir::ItemKind::ForeignMod(..) |\n-                hir::ItemKind::GlobalAsm(..) |\n-                hir::ItemKind::Existential(..) |\n-                hir::ItemKind::Ty(..) => None,\n-\n-                hir::ItemKind::Enum(..) |\n-                hir::ItemKind::Struct(..) |\n-                hir::ItemKind::Union(..) |\n-                hir::ItemKind::Trait(..) |\n-                hir::ItemKind::TraitAlias(..) |\n-                hir::ItemKind::Impl(..) => None,\n+                hir::ItemKind::Use(..)\n+                | hir::ItemKind::ExternCrate(..)\n+                | hir::ItemKind::Const(..)\n+                | hir::ItemKind::Static(..)\n+                | hir::ItemKind::Fn(..)\n+                | hir::ItemKind::ForeignMod(..)\n+                | hir::ItemKind::GlobalAsm(..)\n+                | hir::ItemKind::Existential(..)\n+                | hir::ItemKind::Ty(..) => None,\n+\n+                hir::ItemKind::Enum(..)\n+                | hir::ItemKind::Struct(..)\n+                | hir::ItemKind::Union(..)\n+                | hir::ItemKind::Trait(..)\n+                | hir::ItemKind::TraitAlias(..)\n+                | hir::ItemKind::Impl(..) => None,\n \n                 hir::ItemKind::Mod(ref m) => search_mod(this, m, idx, names),\n             };\n         }\n     }\n \n     pub fn make_subtype(&self, a: Ty<'tcx>, b: Ty<'tcx>) -> bool {\n-        match self.infcx.at(&ObligationCause::dummy(), self.param_env).sub(a, b) {\n+        match self.infcx\n+            .at(&ObligationCause::dummy(), self.param_env)\n+            .sub(a, b)\n+        {\n             Ok(_) => true,\n             Err(ref e) => panic!(\"Encountered error: {}\", e),\n         }\n@@ -302,13 +333,15 @@ impl<'a, 'gcx, 'tcx> Env<'a, 'gcx, 'tcx> {\n     }\n \n     pub fn t_fn(&self, input_tys: &[Ty<'tcx>], output_ty: Ty<'tcx>) -> Ty<'tcx> {\n-        self.infcx.tcx.mk_fn_ptr(ty::Binder::bind(self.infcx.tcx.mk_fn_sig(\n-            input_tys.iter().cloned(),\n-            output_ty,\n-            false,\n-            hir::Unsafety::Normal,\n-            Abi::Rust\n-        )))\n+        self.infcx\n+            .tcx\n+            .mk_fn_ptr(ty::Binder::bind(self.infcx.tcx.mk_fn_sig(\n+                input_tys.iter().cloned(),\n+                output_ty,\n+                false,\n+                hir::Unsafety::Normal,\n+                Abi::Rust,\n+            )))\n     }\n \n     pub fn t_nil(&self) -> Ty<'tcx> {\n@@ -321,23 +354,30 @@ impl<'a, 'gcx, 'tcx> Env<'a, 'gcx, 'tcx> {\n \n     pub fn t_param(&self, index: u32) -> Ty<'tcx> {\n         let name = format!(\"T{}\", index);\n-        self.infcx.tcx.mk_ty_param(index, Symbol::intern(&name).as_interned_str())\n+        self.infcx\n+            .tcx\n+            .mk_ty_param(index, Symbol::intern(&name).as_interned_str())\n     }\n \n     pub fn re_early_bound(&self, index: u32, name: &'static str) -> ty::Region<'tcx> {\n         let name = Symbol::intern(name).as_interned_str();\n-        self.infcx.tcx.mk_region(ty::ReEarlyBound(ty::EarlyBoundRegion {\n-            def_id: self.infcx.tcx.hir.local_def_id(ast::CRATE_NODE_ID),\n-            index,\n-            name,\n-        }))\n+        self.infcx\n+            .tcx\n+            .mk_region(ty::ReEarlyBound(ty::EarlyBoundRegion {\n+                def_id: self.infcx.tcx.hir.local_def_id(ast::CRATE_NODE_ID),\n+                index,\n+                name,\n+            }))\n     }\n \n-    pub fn re_late_bound_with_debruijn(&self,\n-                                       id: u32,\n-                                       debruijn: ty::DebruijnIndex)\n-                                       -> ty::Region<'tcx> {\n-        self.infcx.tcx.mk_region(ty::ReLateBound(debruijn, ty::BrAnon(id)))\n+    pub fn re_late_bound_with_debruijn(\n+        &self,\n+        id: u32,\n+        debruijn: ty::DebruijnIndex,\n+    ) -> ty::Region<'tcx> {\n+        self.infcx\n+            .tcx\n+            .mk_region(ty::ReLateBound(debruijn, ty::BrAnon(id)))\n     }\n \n     pub fn t_rptr(&self, r: ty::Region<'tcx>) -> Ty<'tcx> {\n@@ -349,20 +389,23 @@ impl<'a, 'gcx, 'tcx> Env<'a, 'gcx, 'tcx> {\n         self.infcx.tcx.mk_imm_ref(r, self.tcx().types.isize)\n     }\n \n-    pub fn t_rptr_late_bound_with_debruijn(&self,\n-                                           id: u32,\n-                                           debruijn: ty::DebruijnIndex)\n-                                           -> Ty<'tcx> {\n+    pub fn t_rptr_late_bound_with_debruijn(\n+        &self,\n+        id: u32,\n+        debruijn: ty::DebruijnIndex,\n+    ) -> Ty<'tcx> {\n         let r = self.re_late_bound_with_debruijn(id, debruijn);\n         self.infcx.tcx.mk_imm_ref(r, self.tcx().types.isize)\n     }\n \n     pub fn t_rptr_scope(&self, id: u32) -> Ty<'tcx> {\n         let r = ty::ReScope(region::Scope {\n             id: hir::ItemLocalId(id),\n-            data: region::ScopeData::Node\n+            data: region::ScopeData::Node,\n         });\n-        self.infcx.tcx.mk_imm_ref(self.infcx.tcx.mk_region(r), self.tcx().types.isize)\n+        self.infcx\n+            .tcx\n+            .mk_imm_ref(self.infcx.tcx.mk_region(r), self.tcx().types.isize)\n     }\n \n     pub fn re_free(&self, id: u32) -> ty::Region<'tcx> {\n@@ -378,14 +421,19 @@ impl<'a, 'gcx, 'tcx> Env<'a, 'gcx, 'tcx> {\n     }\n \n     pub fn sub(&self, t1: Ty<'tcx>, t2: Ty<'tcx>) -> InferResult<'tcx, ()> {\n-        self.infcx.at(&ObligationCause::dummy(), self.param_env).sub(t1, t2)\n+        self.infcx\n+            .at(&ObligationCause::dummy(), self.param_env)\n+            .sub(t1, t2)\n     }\n \n     /// Checks that `t1 <: t2` is true (this may register additional\n     /// region checks).\n     pub fn check_sub(&self, t1: Ty<'tcx>, t2: Ty<'tcx>) {\n         match self.sub(t1, t2) {\n-            Ok(InferOk { obligations, value: () }) => {\n+            Ok(InferOk {\n+                obligations,\n+                value: (),\n+            }) => {\n                 // None of these tests should require nested obligations:\n                 assert!(obligations.is_empty());\n             }\n@@ -445,8 +493,10 @@ fn sub_free_bound_false() {\n         env.create_simple_region_hierarchy();\n         let t_rptr_free1 = env.t_rptr_free(1);\n         let t_rptr_bound1 = env.t_rptr_late_bound(1);\n-        env.check_not_sub(env.t_fn(&[t_rptr_free1], env.tcx().types.isize),\n-                          env.t_fn(&[t_rptr_bound1], env.tcx().types.isize));\n+        env.check_not_sub(\n+            env.t_fn(&[t_rptr_free1], env.tcx().types.isize),\n+            env.t_fn(&[t_rptr_bound1], env.tcx().types.isize),\n+        );\n     })\n }\n \n@@ -462,8 +512,10 @@ fn sub_bound_free_true() {\n         env.create_simple_region_hierarchy();\n         let t_rptr_bound1 = env.t_rptr_late_bound(1);\n         let t_rptr_free1 = env.t_rptr_free(1);\n-        env.check_sub(env.t_fn(&[t_rptr_bound1], env.tcx().types.isize),\n-                      env.t_fn(&[t_rptr_free1], env.tcx().types.isize));\n+        env.check_sub(\n+            env.t_fn(&[t_rptr_bound1], env.tcx().types.isize),\n+            env.t_fn(&[t_rptr_free1], env.tcx().types.isize),\n+        );\n     })\n }\n \n@@ -476,18 +528,20 @@ fn sub_free_bound_false_infer() {\n     //! does NOT hold for any instantiation of `_#1`.\n \n     test_env(EMPTY_SOURCE_STR, errors(&[]), |env| {\n-        let t_infer1 = env.infcx.next_ty_var(TypeVariableOrigin::MiscVariable(DUMMY_SP));\n+        let t_infer1 = env.infcx\n+            .next_ty_var(TypeVariableOrigin::MiscVariable(DUMMY_SP));\n         let t_rptr_bound1 = env.t_rptr_late_bound(1);\n-        env.check_not_sub(env.t_fn(&[t_infer1], env.tcx().types.isize),\n-                          env.t_fn(&[t_rptr_bound1], env.tcx().types.isize));\n+        env.check_not_sub(\n+            env.t_fn(&[t_infer1], env.tcx().types.isize),\n+            env.t_fn(&[t_rptr_bound1], env.tcx().types.isize),\n+        );\n     })\n }\n \n /// Test substituting a bound region into a function, which introduces another level of binding.\n /// This requires adjusting the Debruijn index.\n #[test]\n fn subst_ty_renumber_bound() {\n-\n     test_env(EMPTY_SOURCE_STR, errors(&[]), |env| {\n         // Situation:\n         // Theta = [A -> &'a foo]\n@@ -509,11 +563,10 @@ fn subst_ty_renumber_bound() {\n             env.t_fn(&[t_ptr_bound2], env.t_nil())\n         };\n \n-        debug!(\"subst_bound: t_source={:?} substs={:?} t_substituted={:?} t_expected={:?}\",\n-               t_source,\n-               substs,\n-               t_substituted,\n-               t_expected);\n+        debug!(\n+            \"subst_bound: t_source={:?} substs={:?} t_substituted={:?} t_expected={:?}\",\n+            t_source, substs, t_substituted, t_expected\n+        );\n \n         assert_eq!(t_substituted, t_expected);\n     })\n@@ -546,11 +599,10 @@ fn subst_ty_renumber_some_bounds() {\n             env.t_pair(t_rptr_bound1, env.t_fn(&[t_rptr_bound2], env.t_nil()))\n         };\n \n-        debug!(\"subst_bound: t_source={:?} substs={:?} t_substituted={:?} t_expected={:?}\",\n-               t_source,\n-               substs,\n-               t_substituted,\n-               t_expected);\n+        debug!(\n+            \"subst_bound: t_source={:?} substs={:?} t_substituted={:?} t_expected={:?}\",\n+            t_source, substs, t_substituted, t_expected\n+        );\n \n         assert_eq!(t_substituted, t_expected);\n     })\n@@ -559,7 +611,6 @@ fn subst_ty_renumber_some_bounds() {\n /// Test that we correctly compute whether a type has escaping regions or not.\n #[test]\n fn escaping() {\n-\n     test_env(EMPTY_SOURCE_STR, errors(&[]), |mut env| {\n         // Situation:\n         // Theta = [A -> &'a foo]\n@@ -608,11 +659,10 @@ fn subst_region_renumber_region() {\n             env.t_fn(&[t_rptr_bound2], env.t_nil())\n         };\n \n-        debug!(\"subst_bound: t_source={:?} substs={:?} t_substituted={:?} t_expected={:?}\",\n-               t_source,\n-               substs,\n-               t_substituted,\n-               t_expected);\n+        debug!(\n+            \"subst_bound: t_source={:?} substs={:?} t_substituted={:?} t_expected={:?}\",\n+            t_source, substs, t_substituted, t_expected\n+        );\n \n         assert_eq!(t_substituted, t_expected);\n     })\n@@ -627,9 +677,13 @@ fn walk_ty() {\n         let tup1_ty = tcx.intern_tup(&[int_ty, usize_ty, int_ty, usize_ty]);\n         let tup2_ty = tcx.intern_tup(&[tup1_ty, tup1_ty, usize_ty]);\n         let walked: Vec<_> = tup2_ty.walk().collect();\n-        assert_eq!(walked,\n-                   [tup2_ty, tup1_ty, int_ty, usize_ty, int_ty, usize_ty, tup1_ty, int_ty,\n-                    usize_ty, int_ty, usize_ty, usize_ty]);\n+        assert_eq!(\n+            walked,\n+            [\n+                tup2_ty, tup1_ty, int_ty, usize_ty, int_ty, usize_ty, tup1_ty, int_ty, usize_ty,\n+                int_ty, usize_ty, usize_ty\n+            ]\n+        );\n     })\n }\n \n@@ -644,14 +698,16 @@ fn walk_ty_skip_subtree() {\n \n         // types we expect to see (in order), plus a boolean saying\n         // whether to skip the subtree.\n-        let mut expected = vec![(tup2_ty, false),\n-                                (tup1_ty, false),\n-                                (int_ty, false),\n-                                (usize_ty, false),\n-                                (int_ty, false),\n-                                (usize_ty, false),\n-                                (tup1_ty, true), // skip the isize/usize/isize/usize\n-                                (usize_ty, false)];\n+        let mut expected = vec![\n+            (tup2_ty, false),\n+            (tup1_ty, false),\n+            (int_ty, false),\n+            (usize_ty, false),\n+            (int_ty, false),\n+            (usize_ty, false),\n+            (tup1_ty, true), // skip the isize/usize/isize/usize\n+            (usize_ty, false),\n+        ];\n         expected.reverse();\n \n         let mut walker = tup2_ty.walk();"}, {"sha": "2dbb5cd9deb144437a38fb9d9cbd9e236489f217", "filename": "src/librustc_mir/borrow_check/nll/region_infer/mod.rs", "status": "modified", "additions": 131, "deletions": 60, "changes": 191, "blob_url": "https://github.com/rust-lang/rust/blob/c7df1f530b8a88f471e60e933868e7ddf456974d/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7df1f530b8a88f471e60e933868e7ddf456974d/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fmod.rs?ref=c7df1f530b8a88f471e60e933868e7ddf456974d", "patch": "@@ -10,15 +10,13 @@\n \n use super::universal_regions::UniversalRegions;\n use borrow_check::nll::constraints::graph::NormalConstraintGraph;\n-use borrow_check::nll::constraints::{\n-    ConstraintSccIndex, ConstraintSet, OutlivesConstraint,\n-};\n+use borrow_check::nll::constraints::{ConstraintSccIndex, ConstraintSet, OutlivesConstraint};\n use borrow_check::nll::region_infer::values::{RegionElement, ToElementIndex};\n use borrow_check::nll::type_check::free_region_relations::UniversalRegionRelations;\n use borrow_check::nll::type_check::Locations;\n use rustc::hir::def_id::DefId;\n use rustc::infer::canonical::QueryRegionConstraint;\n-use rustc::infer::region_constraints::{GenericKind, VarInfos};\n+use rustc::infer::region_constraints::{GenericKind, VarInfos, VerifyBound};\n use rustc::infer::{InferCtxt, NLLRegionVariableOrigin, RegionVariableOrigin};\n use rustc::mir::{\n     ClosureOutlivesRequirement, ClosureOutlivesSubject, ClosureRegionRequirements, Local, Location,\n@@ -29,7 +27,7 @@ use rustc::util::common;\n use rustc_data_structures::bit_set::BitSet;\n use rustc_data_structures::graph::scc::Sccs;\n use rustc_data_structures::indexed_vec::IndexVec;\n-use rustc_errors::{DiagnosticBuilder, Diagnostic};\n+use rustc_errors::{Diagnostic, DiagnosticBuilder};\n \n use std::rc::Rc;\n \n@@ -71,6 +69,15 @@ pub struct RegionInferenceContext<'tcx> {\n     /// visible from this index.\n     scc_universes: IndexVec<ConstraintSccIndex, ty::UniverseIndex>,\n \n+    /// Contains a \"representative\" from each SCC. This will be the\n+    /// minimal RegionVid belonging to that universe. It is used as a\n+    /// kind of hacky way to manage checking outlives relationships,\n+    /// since we can 'canonicalize' each region to the representative\n+    /// of its SCC and be sure that -- if they have the same repr --\n+    /// they *must* be equal (though not having the same repr does not\n+    /// mean they are unequal).\n+    scc_representatives: IndexVec<ConstraintSccIndex, ty::RegionVid>,\n+\n     /// The final inferred values of the region variables; we compute\n     /// one value per SCC. To get the value for any given *region*,\n     /// you first find which scc it is a part of.\n@@ -162,42 +169,7 @@ pub struct TypeTest<'tcx> {\n \n     /// A test which, if met by the region `'x`, proves that this type\n     /// constraint is satisfied.\n-    pub test: RegionTest,\n-}\n-\n-/// A \"test\" that can be applied to some \"subject region\" `'x`. These are used to\n-/// describe type constraints. Tests do not presently affect the\n-/// region values that get inferred for each variable; they only\n-/// examine the results *after* inference.  This means they can\n-/// conveniently include disjuction (\"a or b must be true\").\n-#[derive(Clone, Debug)]\n-pub enum RegionTest {\n-    /// The subject region `'x` must by outlived by *some* region in\n-    /// the given set of regions.\n-    ///\n-    /// This test comes from e.g. a where clause like `T: 'a + 'b`,\n-    /// which implies that we know that `T: 'a` and that `T:\n-    /// 'b`. Therefore, if we are trying to prove that `T: 'x`, we can\n-    /// do so by showing that `'a: 'x` *or* `'b: 'x`.\n-    IsOutlivedByAnyRegionIn(Vec<RegionVid>),\n-\n-    /// The subject region `'x` must by outlived by *all* regions in\n-    /// the given set of regions.\n-    ///\n-    /// This test comes from e.g. a projection type like `T = <u32 as\n-    /// Trait<'a, 'b>>::Foo`, which must outlive `'a` or `'b`, and\n-    /// maybe both. Therefore we can prove that `T: 'x` if we know\n-    /// that `'a: 'x` *and* `'b: 'x`.\n-    IsOutlivedByAllRegionsIn(Vec<RegionVid>),\n-\n-    /// Any of the given tests are true.\n-    ///\n-    /// This arises from projections, for which there are multiple\n-    /// ways to prove an outlives relationship.\n-    Any(Vec<RegionTest>),\n-\n-    /// All of the given tests are true.\n-    All(Vec<RegionTest>),\n+    pub verify_bound: VerifyBound<'tcx>,\n }\n \n impl<'tcx> RegionInferenceContext<'tcx> {\n@@ -245,13 +217,16 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n \n         let scc_universes = Self::compute_scc_universes(&constraint_sccs, &definitions);\n \n+        let scc_representatives = Self::compute_scc_representatives(&constraint_sccs, &definitions);\n+\n         let mut result = Self {\n             definitions,\n             liveness_constraints,\n             constraints,\n             constraint_graph,\n             constraint_sccs,\n             scc_universes,\n+            scc_representatives,\n             scc_values,\n             type_tests,\n             universal_regions,\n@@ -288,6 +263,27 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         scc_universes\n     }\n \n+    /// For each SCC, we compute a unique `RegionVid` (in fact, the\n+    /// minimal one that belongs to the SCC). See\n+    /// `scc_representatives` field of `RegionInferenceContext` for\n+    /// more details.\n+    fn compute_scc_representatives(\n+        constraints_scc: &Sccs<RegionVid, ConstraintSccIndex>,\n+        definitions: &IndexVec<RegionVid, RegionDefinition<'tcx>>,\n+    ) -> IndexVec<ConstraintSccIndex, ty::RegionVid> {\n+        let num_sccs = constraints_scc.num_sccs();\n+        let next_region_vid = definitions.next_index();\n+        let mut scc_representatives = IndexVec::from_elem_n(next_region_vid, num_sccs);\n+\n+        for region_vid in definitions.indices() {\n+            let scc = constraints_scc.scc(region_vid);\n+            let prev_min = scc_representatives[scc];\n+            scc_representatives[scc] = region_vid.min(prev_min);\n+        }\n+\n+        scc_representatives\n+    }\n+\n     /// Initializes the region variables for each universally\n     /// quantified region (lifetime parameter). The first N variables\n     /// always correspond to the regions appearing in the function\n@@ -582,7 +578,14 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         for type_test in &self.type_tests {\n             debug!(\"check_type_test: {:?}\", type_test);\n \n-            if self.eval_region_test(mir, type_test.lower_bound, &type_test.test) {\n+            let generic_ty = type_test.generic_kind.to_ty(tcx);\n+            if self.eval_verify_bound(\n+                tcx,\n+                mir,\n+                generic_ty,\n+                type_test.lower_bound,\n+                &type_test.verify_bound,\n+            ) {\n                 continue;\n             }\n \n@@ -689,7 +692,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n             generic_kind,\n             lower_bound,\n             locations,\n-            test: _,\n+            verify_bound: _,\n         } = type_test;\n \n         let generic_ty = generic_kind.to_ty(tcx);\n@@ -716,7 +719,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n             // where `ur` is a local bound -- we are sometimes in a\n             // position to prove things that our caller cannot.  See\n             // #53570 for an example.\n-            if self.eval_region_test(mir, ur, &type_test.test) {\n+            if self.eval_verify_bound(tcx, mir, generic_ty, ur, &type_test.verify_bound) {\n                 continue;\n             }\n \n@@ -888,31 +891,99 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n \n     /// Test if `test` is true when applied to `lower_bound` at\n     /// `point`, and returns true or false.\n-    fn eval_region_test(&self, mir: &Mir<'tcx>, lower_bound: RegionVid, test: &RegionTest) -> bool {\n+    fn eval_verify_bound(\n+        &self,\n+        tcx: TyCtxt<'_, '_, 'tcx>,\n+        mir: &Mir<'tcx>,\n+        generic_ty: Ty<'tcx>,\n+        lower_bound: RegionVid,\n+        verify_bound: &VerifyBound<'tcx>,\n+    ) -> bool {\n         debug!(\n-            \"eval_region_test(lower_bound={:?}, test={:?})\",\n-            lower_bound, test\n+            \"eval_verify_bound(lower_bound={:?}, verify_bound={:?})\",\n+            lower_bound, verify_bound\n         );\n \n-        match test {\n-            RegionTest::IsOutlivedByAllRegionsIn(regions) => regions\n-                .iter()\n-                .all(|&r| self.eval_outlives(mir, r, lower_bound)),\n+        match verify_bound {\n+            VerifyBound::IfEq(test_ty, verify_bound1) => {\n+                self.eval_if_eq(tcx, mir, generic_ty, lower_bound, test_ty, verify_bound1)\n+            }\n \n-            RegionTest::IsOutlivedByAnyRegionIn(regions) => regions\n-                .iter()\n-                .any(|&r| self.eval_outlives(mir, r, lower_bound)),\n+            VerifyBound::OutlivedBy(r) => {\n+                let r_vid = self.to_region_vid(r);\n+                self.eval_outlives(mir, r_vid, lower_bound)\n+            }\n \n-            RegionTest::Any(tests) => tests\n-                .iter()\n-                .any(|test| self.eval_region_test(mir, lower_bound, test)),\n+            VerifyBound::AnyBound(verify_bounds) => verify_bounds.iter().any(|verify_bound| {\n+                self.eval_verify_bound(tcx, mir, generic_ty, lower_bound, verify_bound)\n+            }),\n \n-            RegionTest::All(tests) => tests\n-                .iter()\n-                .all(|test| self.eval_region_test(mir, lower_bound, test)),\n+            VerifyBound::AllBounds(verify_bounds) => verify_bounds.iter().all(|verify_bound| {\n+                self.eval_verify_bound(tcx, mir, generic_ty, lower_bound, verify_bound)\n+            }),\n+        }\n+    }\n+\n+    fn eval_if_eq(\n+        &self,\n+        tcx: TyCtxt<'_, '_, 'tcx>,\n+        mir: &Mir<'tcx>,\n+        generic_ty: Ty<'tcx>,\n+        lower_bound: RegionVid,\n+        test_ty: Ty<'tcx>,\n+        verify_bound: &VerifyBound<'tcx>,\n+    ) -> bool {\n+        let generic_ty_normalized = self.normalize_to_scc_representatives(tcx, generic_ty);\n+        let test_ty_normalized = self.normalize_to_scc_representatives(tcx, test_ty);\n+        if generic_ty_normalized == test_ty_normalized {\n+            self.eval_verify_bound(tcx, mir, generic_ty, lower_bound, verify_bound)\n+        } else {\n+            false\n         }\n     }\n \n+    /// This is a conservative normalization procedure. It takes every\n+    /// free region in `value` and replaces it with the\n+    /// \"representative\" of its SCC (see `scc_representatives` field).\n+    /// We are guaranteed that if two values normalize to the same\n+    /// thing, then they are equal; this is a conservative check in\n+    /// that they could still be equal even if they normalize to\n+    /// different results. (For example, there might be two regions\n+    /// with the same value that are not in the same SCC).\n+    ///\n+    /// NB. This is not an ideal approach and I would like to revisit\n+    /// it. However, it works pretty well in practice. In particular,\n+    /// this is needed to deal with projection outlives bounds like\n+    ///\n+    ///     <T as Foo<'0>>::Item: '1\n+    ///\n+    /// In particular, this routine winds up being important when\n+    /// there are bounds like `where <T as Foo<'a>>::Item: 'b` in the\n+    /// environment.  In this case, if we can show that `'0 == 'a`,\n+    /// and that `'b: '1`, then we know that the clause is\n+    /// satisfied. In such cases, particularly due to limitations of\n+    /// the trait solver =), we usually wind up with a where-clause like\n+    /// `T: Foo<'a>` in scope, which thus forces `'0 == 'a` to be added as\n+    /// a constraint, and thus ensures that they are in the same SCC.\n+    ///\n+    /// So why can't we do a more correct routine? Well, we could\n+    /// *almost* use the `relate_tys` code, but the way it is\n+    /// currently setup it creates inference variables to deal with\n+    /// higher-ranked things and so forth, and right now the inference\n+    /// context is not permitted to make more inference variables. So\n+    /// we use this kind of hacky solution.\n+    fn normalize_to_scc_representatives<T>(&self, tcx: TyCtxt<'_, '_, 'tcx>, value: T) -> T\n+    where\n+        T: TypeFoldable<'tcx>,\n+    {\n+        tcx.fold_regions(&value, &mut false, |r, _db| {\n+            let vid = self.to_region_vid(r);\n+            let scc = self.constraint_sccs.scc(vid);\n+            let repr = self.scc_representatives[scc];\n+            tcx.mk_region(ty::ReVar(repr))\n+        })\n+    }\n+\n     // Evaluate whether `sup_region: sub_region @ point`.\n     fn eval_outlives(\n         &self,"}, {"sha": "0ad6183960da93bd522c410fd5a039b9b210f23c", "filename": "src/librustc_mir/borrow_check/nll/type_check/constraint_conversion.rs", "status": "modified", "additions": 6, "deletions": 33, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/c7df1f530b8a88f471e60e933868e7ddf456974d/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fconstraint_conversion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7df1f530b8a88f471e60e933868e7ddf456974d/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fconstraint_conversion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fconstraint_conversion.rs?ref=c7df1f530b8a88f471e60e933868e7ddf456974d", "patch": "@@ -11,10 +11,11 @@\n use borrow_check::location::LocationTable;\n use borrow_check::nll::constraints::{ConstraintCategory, ConstraintSet, OutlivesConstraint};\n use borrow_check::nll::facts::AllFacts;\n-use borrow_check::nll::region_infer::{RegionTest, TypeTest};\n+use borrow_check::nll::region_infer::TypeTest;\n use borrow_check::nll::type_check::Locations;\n use borrow_check::nll::universal_regions::UniversalRegions;\n use rustc::infer::canonical::QueryRegionConstraint;\n+use rustc::infer::outlives::env::RegionBoundPairs;\n use rustc::infer::outlives::obligations::{TypeOutlives, TypeOutlivesDelegate};\n use rustc::infer::region_constraints::{GenericKind, VerifyBound};\n use rustc::infer::{self, SubregionOrigin};\n@@ -26,7 +27,7 @@ crate struct ConstraintConversion<'a, 'gcx: 'tcx, 'tcx: 'a> {\n     tcx: TyCtxt<'a, 'gcx, 'tcx>,\n     universal_regions: &'a UniversalRegions<'tcx>,\n     location_table: &'a LocationTable,\n-    region_bound_pairs: &'a [(ty::Region<'tcx>, GenericKind<'tcx>)],\n+    region_bound_pairs: &'a RegionBoundPairs<'tcx>,\n     implicit_region_bound: Option<ty::Region<'tcx>>,\n     param_env: ty::ParamEnv<'tcx>,\n     locations: Locations,\n@@ -41,7 +42,7 @@ impl<'a, 'gcx, 'tcx> ConstraintConversion<'a, 'gcx, 'tcx> {\n         tcx: TyCtxt<'a, 'gcx, 'tcx>,\n         universal_regions: &'a UniversalRegions<'tcx>,\n         location_table: &'a LocationTable,\n-        region_bound_pairs: &'a [(ty::Region<'tcx>, GenericKind<'tcx>)],\n+        region_bound_pairs: &'a RegionBoundPairs<'tcx>,\n         implicit_region_bound: Option<ty::Region<'tcx>>,\n         param_env: ty::ParamEnv<'tcx>,\n         locations: Locations,\n@@ -139,43 +140,15 @@ impl<'a, 'gcx, 'tcx> ConstraintConversion<'a, 'gcx, 'tcx> {\n         &self,\n         generic_kind: GenericKind<'tcx>,\n         region: ty::Region<'tcx>,\n-        bound: VerifyBound<'tcx>,\n+        verify_bound: VerifyBound<'tcx>,\n     ) -> TypeTest<'tcx> {\n         let lower_bound = self.to_region_vid(region);\n \n-        let test = self.verify_bound_to_region_test(&bound);\n-\n         TypeTest {\n             generic_kind,\n             lower_bound,\n             locations: self.locations,\n-            test,\n-        }\n-    }\n-\n-    fn verify_bound_to_region_test(&self, verify_bound: &VerifyBound<'tcx>) -> RegionTest {\n-        match verify_bound {\n-            VerifyBound::AnyRegion(regions) => RegionTest::IsOutlivedByAnyRegionIn(\n-                regions.iter().map(|r| self.to_region_vid(r)).collect(),\n-            ),\n-\n-            VerifyBound::AllRegions(regions) => RegionTest::IsOutlivedByAllRegionsIn(\n-                regions.iter().map(|r| self.to_region_vid(r)).collect(),\n-            ),\n-\n-            VerifyBound::AnyBound(bounds) => RegionTest::Any(\n-                bounds\n-                    .iter()\n-                    .map(|b| self.verify_bound_to_region_test(b))\n-                    .collect(),\n-            ),\n-\n-            VerifyBound::AllBounds(bounds) => RegionTest::All(\n-                bounds\n-                    .iter()\n-                    .map(|b| self.verify_bound_to_region_test(b))\n-                    .collect(),\n-            ),\n+            verify_bound,\n         }\n     }\n "}, {"sha": "5ebaec1874aefceac651342ba9dd581f678f7aaa", "filename": "src/librustc_mir/borrow_check/nll/type_check/mod.rs", "status": "modified", "additions": 105, "deletions": 142, "changes": 247, "blob_url": "https://github.com/rust-lang/rust/blob/c7df1f530b8a88f471e60e933868e7ddf456974d/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7df1f530b8a88f471e60e933868e7ddf456974d/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fmod.rs?ref=c7df1f530b8a88f471e60e933868e7ddf456974d", "patch": "@@ -17,31 +17,31 @@ use borrow_check::nll::constraints::{ConstraintCategory, ConstraintSet, Outlives\n use borrow_check::nll::facts::AllFacts;\n use borrow_check::nll::region_infer::values::{LivenessValues, RegionValueElements};\n use borrow_check::nll::region_infer::{ClosureRegionRequirementsExt, TypeTest};\n+use borrow_check::nll::renumber;\n use borrow_check::nll::type_check::free_region_relations::{\n     CreateResult, UniversalRegionRelations,\n };\n use borrow_check::nll::universal_regions::UniversalRegions;\n use borrow_check::nll::ToRegionVid;\n-use borrow_check::nll::renumber;\n use dataflow::move_paths::MoveData;\n use dataflow::FlowAtLocation;\n use dataflow::MaybeInitializedPlaces;\n use rustc::hir;\n use rustc::hir::def_id::DefId;\n use rustc::infer::canonical::QueryRegionConstraint;\n-use rustc::infer::region_constraints::GenericKind;\n+use rustc::infer::outlives::env::RegionBoundPairs;\n use rustc::infer::{InferCtxt, InferOk, LateBoundRegionConversionTime};\n use rustc::mir::interpret::EvalErrorKind::BoundsCheck;\n use rustc::mir::tcx::PlaceTy;\n use rustc::mir::visit::{PlaceContext, Visitor};\n use rustc::mir::*;\n-use rustc::traits::{ObligationCause, PredicateObligations};\n use rustc::traits::query::type_op;\n use rustc::traits::query::type_op::custom::CustomTypeOp;\n use rustc::traits::query::{Fallible, NoSolution};\n+use rustc::traits::{ObligationCause, PredicateObligations};\n use rustc::ty::fold::TypeFoldable;\n-use rustc::ty::{self, CanonicalTy, RegionVid, ToPolyTraitRef, Ty, TyCtxt, TyKind};\n use rustc::ty::subst::Subst;\n+use rustc::ty::{self, CanonicalTy, RegionVid, ToPolyTraitRef, Ty, TyCtxt, TyKind};\n use std::fmt;\n use std::rc::Rc;\n use syntax_pos::{Span, DUMMY_SP};\n@@ -161,11 +161,7 @@ pub(crate) fn type_check<'gcx, 'tcx>(\n             Some(&mut borrowck_context),\n             Some(&universal_region_relations),\n             |cx| {\n-                cx.equate_inputs_and_outputs(\n-                    mir,\n-                    universal_regions,\n-                    &normalized_inputs_and_output,\n-                );\n+                cx.equate_inputs_and_outputs(mir, universal_regions, &normalized_inputs_and_output);\n                 liveness::generate(cx, mir, elements, flow_inits, move_data);\n             },\n         );\n@@ -182,7 +178,7 @@ fn type_check_internal<'a, 'gcx, 'tcx, R>(\n     mir_def_id: DefId,\n     param_env: ty::ParamEnv<'gcx>,\n     mir: &'a Mir<'tcx>,\n-    region_bound_pairs: &'a [(ty::Region<'tcx>, GenericKind<'tcx>)],\n+    region_bound_pairs: &'a RegionBoundPairs<'tcx>,\n     implicit_region_bound: Option<ty::Region<'tcx>>,\n     borrowck_context: Option<&'a mut BorrowCheckContext<'a, 'tcx>>,\n     universal_region_relations: Option<&'a UniversalRegionRelations<'tcx>>,\n@@ -377,14 +373,12 @@ impl<'a, 'b, 'gcx, 'tcx> TypeVerifier<'a, 'b, 'gcx, 'tcx> {\n \n         debug!(\"sanitize_constant: expected_ty={:?}\", constant.literal.ty);\n \n-        if let Err(terr) = self.cx\n-            .eq_types(\n-                constant.literal.ty,\n-                constant.ty,\n-                location.to_locations(),\n-                ConstraintCategory::Boring,\n-            )\n-        {\n+        if let Err(terr) = self.cx.eq_types(\n+            constant.literal.ty,\n+            constant.ty,\n+            location.to_locations(),\n+            ConstraintCategory::Boring,\n+        ) {\n             span_mirbug!(\n                 self,\n                 constant,\n@@ -429,12 +423,10 @@ impl<'a, 'b, 'gcx, 'tcx> TypeVerifier<'a, 'b, 'gcx, 'tcx> {\n                 let sty = self.sanitize_type(place, sty);\n                 let ty = self.tcx().type_of(def_id);\n                 let ty = self.cx.normalize(ty, location);\n-                if let Err(terr) = self.cx.eq_types(\n-                    ty,\n-                    sty,\n-                    location.to_locations(),\n-                    ConstraintCategory::Boring,\n-                ) {\n+                if let Err(terr) =\n+                    self.cx\n+                        .eq_types(ty, sty, location.to_locations(), ConstraintCategory::Boring)\n+                {\n                     span_mirbug!(\n                         self,\n                         place,\n@@ -693,7 +685,7 @@ struct TypeChecker<'a, 'gcx: 'tcx, 'tcx: 'a> {\n     last_span: Span,\n     mir: &'a Mir<'tcx>,\n     mir_def_id: DefId,\n-    region_bound_pairs: &'a [(ty::Region<'tcx>, GenericKind<'tcx>)],\n+    region_bound_pairs: &'a RegionBoundPairs<'tcx>,\n     implicit_region_bound: Option<ty::Region<'tcx>>,\n     reported_errors: FxHashSet<(Ty<'tcx>, Span)>,\n     borrowck_context: Option<&'a mut BorrowCheckContext<'a, 'tcx>>,\n@@ -802,7 +794,7 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n         mir: &'a Mir<'tcx>,\n         mir_def_id: DefId,\n         param_env: ty::ParamEnv<'gcx>,\n-        region_bound_pairs: &'a [(ty::Region<'tcx>, GenericKind<'tcx>)],\n+        region_bound_pairs: &'a RegionBoundPairs<'tcx>,\n         implicit_region_bound: Option<ty::Region<'tcx>>,\n         borrowck_context: Option<&'a mut BorrowCheckContext<'a, 'tcx>>,\n         universal_region_relations: Option<&'a UniversalRegionRelations<'tcx>>,\n@@ -955,66 +947,55 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n         let tcx = infcx.tcx;\n         let param_env = self.param_env;\n         let parent_def_id = infcx.tcx.closure_base_def_id(self.mir_def_id);\n-        let opaque_type_map =\n-            self.fully_perform_op(\n-                locations,\n-                category,\n-                CustomTypeOp::new(\n-                    |infcx| {\n-                        let mut obligations = ObligationAccumulator::default();\n-\n-                        let dummy_body_id = ObligationCause::dummy().body_id;\n-                        let (output_ty, opaque_type_map) =\n-                            obligations.add(infcx.instantiate_opaque_types(\n-                                parent_def_id,\n-                                dummy_body_id,\n-                                param_env,\n-                                &anon_ty,\n-                            ));\n+        let opaque_type_map = self.fully_perform_op(\n+            locations,\n+            category,\n+            CustomTypeOp::new(\n+                |infcx| {\n+                    let mut obligations = ObligationAccumulator::default();\n+\n+                    let dummy_body_id = ObligationCause::dummy().body_id;\n+                    let (output_ty, opaque_type_map) =\n+                        obligations.add(infcx.instantiate_opaque_types(\n+                            parent_def_id,\n+                            dummy_body_id,\n+                            param_env,\n+                            &anon_ty,\n+                        ));\n+                    debug!(\n+                        \"eq_opaque_type_and_type: \\\n+                         instantiated output_ty={:?} \\\n+                         opaque_type_map={:#?} \\\n+                         revealed_ty={:?}\",\n+                        output_ty, opaque_type_map, revealed_ty\n+                    );\n+                    obligations.add(infcx\n+                        .at(&ObligationCause::dummy(), param_env)\n+                        .eq(output_ty, revealed_ty)?);\n+\n+                    for (&opaque_def_id, opaque_decl) in &opaque_type_map {\n+                        let opaque_defn_ty = tcx.type_of(opaque_def_id);\n+                        let opaque_defn_ty = opaque_defn_ty.subst(tcx, opaque_decl.substs);\n+                        let opaque_defn_ty = renumber::renumber_regions(infcx, &opaque_defn_ty);\n                         debug!(\n-                            \"eq_opaque_type_and_type: \\\n-                             instantiated output_ty={:?} \\\n-                             opaque_type_map={:#?} \\\n-                             revealed_ty={:?}\",\n-                            output_ty,\n-                            opaque_type_map,\n-                            revealed_ty\n-                        );\n-                        obligations.add(\n-                            infcx\n-                                .at(&ObligationCause::dummy(), param_env)\n-                                .eq(output_ty, revealed_ty)?,\n+                            \"eq_opaque_type_and_type: concrete_ty={:?} opaque_defn_ty={:?}\",\n+                            opaque_decl.concrete_ty, opaque_defn_ty\n                         );\n+                        obligations.add(infcx\n+                            .at(&ObligationCause::dummy(), param_env)\n+                            .eq(opaque_decl.concrete_ty, opaque_defn_ty)?);\n+                    }\n \n-                        for (&opaque_def_id, opaque_decl) in &opaque_type_map {\n-                            let opaque_defn_ty = tcx.type_of(opaque_def_id);\n-                            let opaque_defn_ty = opaque_defn_ty.subst(tcx, opaque_decl.substs);\n-                            let opaque_defn_ty = renumber::renumber_regions(\n-                                infcx,\n-                                &opaque_defn_ty,\n-                            );\n-                            debug!(\n-                                \"eq_opaque_type_and_type: concrete_ty={:?} opaque_defn_ty={:?}\",\n-                                opaque_decl.concrete_ty,\n-                                opaque_defn_ty\n-                            );\n-                            obligations.add(\n-                                infcx\n-                                    .at(&ObligationCause::dummy(), param_env)\n-                                    .eq(opaque_decl.concrete_ty, opaque_defn_ty)?,\n-                            );\n-                        }\n-\n-                        debug!(\"eq_opaque_type_and_type: equated\");\n+                    debug!(\"eq_opaque_type_and_type: equated\");\n \n-                        Ok(InferOk {\n-                            value: Some(opaque_type_map),\n-                            obligations: obligations.into_vec(),\n-                        })\n-                    },\n-                    || \"input_output\".to_string(),\n-                ),\n-            )?;\n+                    Ok(InferOk {\n+                        value: Some(opaque_type_map),\n+                        obligations: obligations.into_vec(),\n+                    })\n+                },\n+                || \"input_output\".to_string(),\n+            ),\n+        )?;\n \n         let universal_region_relations = match self.universal_region_relations {\n             Some(rel) => rel,\n@@ -1035,7 +1016,7 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n                             infcx.constrain_opaque_type(\n                                 opaque_def_id,\n                                 &opaque_decl,\n-                                universal_region_relations\n+                                universal_region_relations,\n                             );\n                             Ok(InferOk {\n                                 value: (),\n@@ -1073,12 +1054,9 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n \n                 let place_ty = place.ty(mir, tcx).to_ty(tcx);\n                 let rv_ty = rv.ty(mir, tcx);\n-                if let Err(terr) = self.sub_types_or_anon(\n-                    rv_ty,\n-                    place_ty,\n-                    location.to_locations(),\n-                    category,\n-                ) {\n+                if let Err(terr) =\n+                    self.sub_types_or_anon(rv_ty, place_ty, location.to_locations(), category)\n+                {\n                     span_mirbug!(\n                         self,\n                         stmt,\n@@ -1117,7 +1095,7 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n                     self.prove_trait_ref(\n                         trait_ref,\n                         location.to_locations(),\n-                    ConstraintCategory::SizedBound,\n+                        ConstraintCategory::SizedBound,\n                     );\n                 }\n             }\n@@ -1148,15 +1126,13 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n             }\n             StatementKind::AscribeUserType(ref place, variance, c_ty) => {\n                 let place_ty = place.ty(mir, tcx).to_ty(tcx);\n-                if let Err(terr) =\n-                    self.relate_type_and_user_type(\n-                        place_ty,\n-                        variance,\n-                        c_ty,\n-                        Locations::All(stmt.source_info.span),\n-                        ConstraintCategory::TypeAnnotation,\n-                    )\n-                {\n+                if let Err(terr) = self.relate_type_and_user_type(\n+                    place_ty,\n+                    variance,\n+                    c_ty,\n+                    Locations::All(stmt.source_info.span),\n+                    ConstraintCategory::TypeAnnotation,\n+                ) {\n                     span_mirbug!(\n                         self,\n                         stmt,\n@@ -1208,12 +1184,9 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n                 let rv_ty = value.ty(mir, tcx);\n \n                 let locations = term_location.to_locations();\n-                if let Err(terr) = self.sub_types(\n-                    rv_ty,\n-                    place_ty,\n-                    locations,\n-                    ConstraintCategory::Assignment,\n-                ) {\n+                if let Err(terr) =\n+                    self.sub_types(rv_ty, place_ty, locations, ConstraintCategory::Assignment)\n+                {\n                     span_mirbug!(\n                         self,\n                         term,\n@@ -1327,8 +1300,7 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n                             ty,\n                             term_location.to_locations(),\n                             ConstraintCategory::Return,\n-                        )\n-                        {\n+                        ) {\n                             span_mirbug!(\n                                 self,\n                                 term,\n@@ -1366,12 +1338,9 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n \n                 let locations = term_location.to_locations();\n \n-                if let Err(terr) = self.sub_types_or_anon(\n-                    sig.output(),\n-                    dest_ty,\n-                    locations,\n-                    category,\n-                ) {\n+                if let Err(terr) =\n+                    self.sub_types_or_anon(sig.output(), dest_ty, locations, category)\n+                {\n                     span_mirbug!(\n                         self,\n                         term,\n@@ -1539,12 +1508,7 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n         }\n     }\n \n-    fn check_local(\n-        &mut self,\n-        mir: &Mir<'tcx>,\n-        local: Local,\n-        local_decl: &LocalDecl<'tcx>,\n-    ) {\n+    fn check_local(&mut self, mir: &Mir<'tcx>, local: Local, local_decl: &LocalDecl<'tcx>) {\n         match mir.local_kind(local) {\n             LocalKind::ReturnPointer | LocalKind::Arg => {\n                 // return values of normal functions are required to be\n@@ -1713,13 +1677,13 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n                             ConstraintCategory::Cast,\n                         ) {\n                             span_mirbug!(\n-                            self,\n-                            rvalue,\n-                            \"equating {:?} with {:?} yields {:?}\",\n-                            ty_fn_ptr_from,\n-                            ty,\n-                            terr\n-                        );\n+                                self,\n+                                rvalue,\n+                                \"equating {:?} with {:?} yields {:?}\",\n+                                ty_fn_ptr_from,\n+                                ty,\n+                                terr\n+                            );\n                         }\n                     }\n \n@@ -1739,13 +1703,13 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n                             ConstraintCategory::Cast,\n                         ) {\n                             span_mirbug!(\n-                            self,\n-                            rvalue,\n-                            \"equating {:?} with {:?} yields {:?}\",\n-                            ty_fn_ptr_from,\n-                            ty,\n-                            terr\n-                        );\n+                                self,\n+                                rvalue,\n+                                \"equating {:?} with {:?} yields {:?}\",\n+                                ty_fn_ptr_from,\n+                                ty,\n+                                terr\n+                            );\n                         }\n                     }\n \n@@ -1768,13 +1732,13 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n                             ConstraintCategory::Cast,\n                         ) {\n                             span_mirbug!(\n-                            self,\n-                            rvalue,\n-                            \"equating {:?} with {:?} yields {:?}\",\n-                            ty_fn_ptr_from,\n-                            ty,\n-                            terr\n-                        );\n+                                self,\n+                                rvalue,\n+                                \"equating {:?} with {:?} yields {:?}\",\n+                                ty_fn_ptr_from,\n+                                ty,\n+                                terr\n+                            );\n                         }\n                     }\n \n@@ -2232,7 +2196,7 @@ impl MirPass for TypeckMir {\n                 def_id,\n                 param_env,\n                 mir,\n-                &[],\n+                &vec![],\n                 None,\n                 None,\n                 None,\n@@ -2277,4 +2241,3 @@ impl<'tcx> ObligationAccumulator<'tcx> {\n         self.obligations\n     }\n }\n-"}, {"sha": "39e3403136360353f306502992623af90215b6d7", "filename": "src/librustc_mir/borrow_check/nll/type_check/relate_tys.rs", "status": "modified", "additions": 193, "deletions": 129, "changes": 322, "blob_url": "https://github.com/rust-lang/rust/blob/c7df1f530b8a88f471e60e933868e7ddf456974d/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Frelate_tys.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7df1f530b8a88f471e60e933868e7ddf456974d/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Frelate_tys.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Frelate_tys.rs?ref=c7df1f530b8a88f471e60e933868e7ddf456974d", "patch": "@@ -10,15 +10,13 @@\n \n use borrow_check::nll::constraints::{ConstraintCategory, OutlivesConstraint};\n use borrow_check::nll::type_check::{BorrowCheckContext, Locations};\n-use borrow_check::nll::universal_regions::UniversalRegions;\n-use borrow_check::nll::ToRegionVid;\n use rustc::infer::canonical::{Canonical, CanonicalVarInfos};\n use rustc::infer::{InferCtxt, NLLRegionVariableOrigin};\n use rustc::traits::query::Fallible;\n use rustc::ty::fold::{TypeFoldable, TypeVisitor};\n use rustc::ty::relate::{self, Relate, RelateResult, TypeRelation};\n use rustc::ty::subst::Kind;\n-use rustc::ty::{self, CanonicalTy, CanonicalVar, RegionVid, Ty, TyCtxt};\n+use rustc::ty::{self, CanonicalTy, CanonicalVar, Ty, TyCtxt};\n use rustc_data_structures::fx::FxHashMap;\n use rustc_data_structures::indexed_vec::IndexVec;\n \n@@ -33,11 +31,9 @@ pub(super) fn sub_types<'tcx>(\n ) -> Fallible<()> {\n     debug!(\"sub_types(a={:?}, b={:?}, locations={:?})\", a, b, locations);\n     TypeRelating::new(\n-        infcx,\n+        infcx.tcx,\n+        NllTypeRelatingDelegate::new(infcx, borrowck_context, locations, category),\n         ty::Variance::Covariant,\n-        locations,\n-        category,\n-        borrowck_context,\n         ty::List::empty(),\n     ).relate(&a, &b)?;\n     Ok(())\n@@ -54,11 +50,9 @@ pub(super) fn eq_types<'tcx>(\n ) -> Fallible<()> {\n     debug!(\"eq_types(a={:?}, b={:?}, locations={:?})\", a, b, locations);\n     TypeRelating::new(\n-        infcx,\n+        infcx.tcx,\n+        NllTypeRelatingDelegate::new(infcx, borrowck_context, locations, category),\n         ty::Variance::Invariant,\n-        locations,\n-        category,\n-        borrowck_context,\n         ty::List::empty(),\n     ).relate(&a, &b)?;\n     Ok(())\n@@ -91,18 +85,22 @@ pub(super) fn relate_type_and_user_type<'tcx>(\n     let v1 = ty::Contravariant.xform(v);\n \n     TypeRelating::new(\n-        infcx,\n+        infcx.tcx,\n+        NllTypeRelatingDelegate::new(infcx, borrowck_context, locations, category),\n         v1,\n-        locations,\n-        category,\n-        borrowck_context,\n         b_variables,\n     ).relate(&b_value, &a)?;\n     Ok(())\n }\n \n-struct TypeRelating<'cx, 'bccx: 'cx, 'gcx: 'tcx, 'tcx: 'bccx> {\n-    infcx: &'cx InferCtxt<'cx, 'gcx, 'tcx>,\n+struct TypeRelating<'me, 'gcx: 'tcx, 'tcx: 'me, D>\n+where\n+    D: TypeRelatingDelegate<'tcx>,\n+{\n+    tcx: TyCtxt<'me, 'gcx, 'tcx>,\n+\n+    /// Callback to use when we deduce an outlives relationship\n+    delegate: D,\n \n     /// How are we relating `a` and `b`?\n     ///\n@@ -122,19 +120,10 @@ struct TypeRelating<'cx, 'bccx: 'cx, 'gcx: 'tcx, 'tcx: 'bccx> {\n     ///\n     /// This field stores the instantiations for late-bound regions in\n     /// the `a` type.\n-    a_scopes: Vec<BoundRegionScope>,\n+    a_scopes: Vec<BoundRegionScope<'tcx>>,\n \n     /// Same as `a_scopes`, but for the `b` type.\n-    b_scopes: Vec<BoundRegionScope>,\n-\n-    /// Where (and why) is this relation taking place?\n-    locations: Locations,\n-\n-    category: ConstraintCategory,\n-\n-    /// This will be `Some` when we are running the type check as part\n-    /// of NLL, and `None` if we are running a \"sanity check\".\n-    borrowck_context: Option<&'cx mut BorrowCheckContext<'bccx, 'tcx>>,\n+    b_scopes: Vec<BoundRegionScope<'tcx>>,\n \n     /// As we execute, the type on the LHS *may* come from a canonical\n     /// source. In that case, we will sometimes find a constraint like\n@@ -150,37 +139,130 @@ struct TypeRelating<'cx, 'bccx: 'cx, 'gcx: 'tcx, 'tcx: 'bccx> {\n     canonical_var_values: IndexVec<CanonicalVar, Option<Kind<'tcx>>>,\n }\n \n+trait TypeRelatingDelegate<'tcx> {\n+    /// Push a constraint `sup: sub` -- this constraint must be\n+    /// satisfied for the two types to be related. `sub` and `sup` may\n+    /// be regions from the type or new variables created through the\n+    /// delegate.\n+    fn push_outlives(&mut self, sup: ty::Region<'tcx>, sub: ty::Region<'tcx>);\n+\n+    /// Creates a new region variable representing an instantiated\n+    /// higher-ranked region; this will be either existential or\n+    /// universal depending on the context.  So e.g. if you have\n+    /// `for<'a> fn(..) <: for<'b> fn(..)`, then we will first\n+    /// instantiate `'b` with a universally quantitifed region and\n+    /// then `'a` with an existentially quantified region (the order\n+    /// is important so that the existential region `'a` can see the\n+    /// universal one).\n+    fn next_region_var(\n+        &mut self,\n+        universally_quantified: UniversallyQuantified,\n+    ) -> ty::Region<'tcx>;\n+\n+    /// Creates a new existential region in the given universe. This\n+    /// is used when handling subtyping and type variables -- if we\n+    /// have that `?X <: Foo<'a>`, for example, we would instantiate\n+    /// `?X` with a type like `Foo<'?0>` where `'?0` is a fresh\n+    /// existential variable created by this function. We would then\n+    /// relate `Foo<'?0>` with `Foo<'a>` (and probably add an outlives\n+    /// relation stating that `'?0: 'a`).\n+    fn generalize_existential(&mut self, universe: ty::UniverseIndex) -> ty::Region<'tcx>;\n+}\n+\n+struct NllTypeRelatingDelegate<'me, 'bccx: 'me, 'gcx: 'tcx, 'tcx: 'bccx> {\n+    infcx: &'me InferCtxt<'me, 'gcx, 'tcx>,\n+    borrowck_context: Option<&'me mut BorrowCheckContext<'bccx, 'tcx>>,\n+\n+    /// Where (and why) is this relation taking place?\n+    locations: Locations,\n+\n+    /// What category do we assign the resulting `'a: 'b` relationships?\n+    category: ConstraintCategory,\n+}\n+\n+impl NllTypeRelatingDelegate<'me, 'bccx, 'gcx, 'tcx> {\n+    fn new(\n+        infcx: &'me InferCtxt<'me, 'gcx, 'tcx>,\n+        borrowck_context: Option<&'me mut BorrowCheckContext<'bccx, 'tcx>>,\n+        locations: Locations,\n+        category: ConstraintCategory,\n+    ) -> Self {\n+        Self {\n+            infcx,\n+            borrowck_context,\n+            locations,\n+            category,\n+        }\n+    }\n+}\n+\n+impl TypeRelatingDelegate<'tcx> for NllTypeRelatingDelegate<'_, '_, '_, 'tcx> {\n+    fn next_region_var(\n+        &mut self,\n+        universally_quantified: UniversallyQuantified,\n+    ) -> ty::Region<'tcx> {\n+        let origin = if universally_quantified.0 {\n+            NLLRegionVariableOrigin::BoundRegion(self.infcx.create_subuniverse())\n+        } else {\n+            NLLRegionVariableOrigin::Existential\n+        };\n+        self.infcx.next_nll_region_var(origin)\n+    }\n+\n+    fn generalize_existential(&mut self, universe: ty::UniverseIndex) -> ty::Region<'tcx> {\n+        self.infcx\n+            .next_nll_region_var_in_universe(NLLRegionVariableOrigin::Existential, universe)\n+    }\n+\n+    fn push_outlives(&mut self, sup: ty::Region<'tcx>, sub: ty::Region<'tcx>) {\n+        if let Some(borrowck_context) = &mut self.borrowck_context {\n+            let sub = borrowck_context.universal_regions.to_region_vid(sub);\n+            let sup = borrowck_context.universal_regions.to_region_vid(sup);\n+            borrowck_context\n+                .constraints\n+                .outlives_constraints\n+                .push(OutlivesConstraint {\n+                    sup,\n+                    sub,\n+                    locations: self.locations,\n+                    category: self.category,\n+                });\n+\n+            // FIXME all facts!\n+        }\n+    }\n+}\n+\n #[derive(Clone, Debug)]\n struct ScopesAndKind<'tcx> {\n-    scopes: Vec<BoundRegionScope>,\n+    scopes: Vec<BoundRegionScope<'tcx>>,\n     kind: Kind<'tcx>,\n }\n \n #[derive(Clone, Debug, Default)]\n-struct BoundRegionScope {\n-    map: FxHashMap<ty::BoundRegion, RegionVid>,\n+struct BoundRegionScope<'tcx> {\n+    map: FxHashMap<ty::BoundRegion, ty::Region<'tcx>>,\n }\n \n #[derive(Copy, Clone)]\n struct UniversallyQuantified(bool);\n \n-impl<'cx, 'bccx, 'gcx, 'tcx> TypeRelating<'cx, 'bccx, 'gcx, 'tcx> {\n+impl<'me, 'gcx, 'tcx, D> TypeRelating<'me, 'gcx, 'tcx, D>\n+where\n+    D: TypeRelatingDelegate<'tcx>,\n+{\n     fn new(\n-        infcx: &'cx InferCtxt<'cx, 'gcx, 'tcx>,\n+        tcx: TyCtxt<'me, 'gcx, 'tcx>,\n+        delegate: D,\n         ambient_variance: ty::Variance,\n-        locations: Locations,\n-        category: ConstraintCategory,\n-        borrowck_context: Option<&'cx mut BorrowCheckContext<'bccx, 'tcx>>,\n         canonical_var_infos: CanonicalVarInfos<'tcx>,\n     ) -> Self {\n         let canonical_var_values = IndexVec::from_elem_n(None, canonical_var_infos.len());\n         Self {\n-            infcx,\n+            tcx,\n+            delegate,\n             ambient_variance,\n-            borrowck_context,\n-            locations,\n             canonical_var_values,\n-            category,\n             a_scopes: vec![],\n             b_scopes: vec![],\n         }\n@@ -204,10 +286,10 @@ impl<'cx, 'bccx, 'gcx, 'tcx> TypeRelating<'cx, 'bccx, 'gcx, 'tcx> {\n         &mut self,\n         value: &ty::Binder<impl TypeFoldable<'tcx>>,\n         universally_quantified: UniversallyQuantified,\n-    ) -> BoundRegionScope {\n+    ) -> BoundRegionScope<'tcx> {\n         let mut scope = BoundRegionScope::default();\n         value.skip_binder().visit_with(&mut ScopeInstantiator {\n-            infcx: self.infcx,\n+            delegate: &mut self.delegate,\n             target_index: ty::INNERMOST,\n             universally_quantified,\n             bound_region_scope: &mut scope,\n@@ -227,8 +309,8 @@ impl<'cx, 'bccx, 'gcx, 'tcx> TypeRelating<'cx, 'bccx, 'gcx, 'tcx> {\n         debruijn: ty::DebruijnIndex,\n         br: &ty::BoundRegion,\n         first_free_index: ty::DebruijnIndex,\n-        scopes: &[BoundRegionScope],\n-    ) -> RegionVid {\n+        scopes: &[BoundRegionScope<'tcx>],\n+    ) -> ty::Region<'tcx> {\n         // The debruijn index is a \"reverse index\" into the\n         // scopes listing. So when we have INNERMOST (0), we\n         // want the *last* scope pushed, and so forth.\n@@ -245,40 +327,23 @@ impl<'cx, 'bccx, 'gcx, 'tcx> TypeRelating<'cx, 'bccx, 'gcx, 'tcx> {\n     /// with. Otherwise just return `r`.\n     fn replace_bound_region(\n         &self,\n-        universal_regions: &UniversalRegions<'tcx>,\n         r: ty::Region<'tcx>,\n         first_free_index: ty::DebruijnIndex,\n-        scopes: &[BoundRegionScope],\n-    ) -> RegionVid {\n-        match r {\n-            ty::ReLateBound(debruijn, br) => {\n-                Self::lookup_bound_region(*debruijn, br, first_free_index, scopes)\n-            }\n-\n-            ty::ReVar(v) => *v,\n-\n-            _ => universal_regions.to_region_vid(r),\n+        scopes: &[BoundRegionScope<'tcx>],\n+    ) -> ty::Region<'tcx> {\n+        if let ty::ReLateBound(debruijn, br) = r {\n+            Self::lookup_bound_region(*debruijn, br, first_free_index, scopes)\n+        } else {\n+            r\n         }\n     }\n \n     /// Push a new outlives requirement into our output set of\n     /// constraints.\n-    fn push_outlives(&mut self, sup: RegionVid, sub: RegionVid) {\n+    fn push_outlives(&mut self, sup: ty::Region<'tcx>, sub: ty::Region<'tcx>) {\n         debug!(\"push_outlives({:?}: {:?})\", sup, sub);\n \n-        if let Some(borrowck_context) = &mut self.borrowck_context {\n-            borrowck_context\n-                .constraints\n-                .outlives_constraints\n-                .push(OutlivesConstraint {\n-                    sup,\n-                    sub,\n-                    locations: self.locations,\n-                    category: self.category,\n-                });\n-\n-            // FIXME all facts!\n-        }\n+        self.delegate.push_outlives(sup, sub);\n     }\n \n     /// When we encounter a canonical variable `var` in the output,\n@@ -316,12 +381,10 @@ impl<'cx, 'bccx, 'gcx, 'tcx> TypeRelating<'cx, 'bccx, 'gcx, 'tcx> {\n         return result;\n     }\n \n-    fn generalize_value(\n-        &self,\n-        kind: Kind<'tcx>,\n-    ) -> Kind<'tcx> {\n+    fn generalize_value(&mut self, kind: Kind<'tcx>) -> Kind<'tcx> {\n         TypeGeneralizer {\n-            type_rel: self,\n+            tcx: self.tcx,\n+            delegate: &mut self.delegate,\n             first_free_index: ty::INNERMOST,\n             ambient_variance: self.ambient_variance,\n \n@@ -333,11 +396,12 @@ impl<'cx, 'bccx, 'gcx, 'tcx> TypeRelating<'cx, 'bccx, 'gcx, 'tcx> {\n     }\n }\n \n-impl<'cx, 'bccx, 'gcx, 'tcx> TypeRelation<'cx, 'gcx, 'tcx>\n-    for TypeRelating<'cx, 'bccx, 'gcx, 'tcx>\n+impl<D> TypeRelation<'me, 'gcx, 'tcx> for TypeRelating<'me, 'gcx, 'tcx, D>\n+where\n+    D: TypeRelatingDelegate<'tcx>,\n {\n-    fn tcx(&self) -> TyCtxt<'cx, 'gcx, 'tcx> {\n-        self.infcx.tcx\n+    fn tcx(&self) -> TyCtxt<'me, 'gcx, 'tcx> {\n+        self.tcx\n     }\n \n     fn tag(&self) -> &'static str {\n@@ -397,37 +461,30 @@ impl<'cx, 'bccx, 'gcx, 'tcx> TypeRelation<'cx, 'gcx, 'tcx>\n         a: ty::Region<'tcx>,\n         b: ty::Region<'tcx>,\n     ) -> RelateResult<'tcx, ty::Region<'tcx>> {\n-        if let Some(&mut BorrowCheckContext {\n-            universal_regions, ..\n-        }) = self.borrowck_context\n-        {\n-            if let ty::ReCanonical(var) = a {\n-                self.relate_var(*var, b.into())?;\n-                return Ok(a);\n-            }\n+        if let ty::ReCanonical(var) = a {\n+            self.relate_var(*var, b.into())?;\n+            return Ok(a);\n+        }\n \n-            debug!(\n-                \"regions(a={:?}, b={:?}, variance={:?})\",\n-                a, b, self.ambient_variance\n-            );\n+        debug!(\n+            \"regions(a={:?}, b={:?}, variance={:?})\",\n+            a, b, self.ambient_variance\n+        );\n \n-            let v_a =\n-                self.replace_bound_region(universal_regions, a, ty::INNERMOST, &self.a_scopes);\n-            let v_b =\n-                self.replace_bound_region(universal_regions, b, ty::INNERMOST, &self.b_scopes);\n+        let v_a = self.replace_bound_region(a, ty::INNERMOST, &self.a_scopes);\n+        let v_b = self.replace_bound_region(b, ty::INNERMOST, &self.b_scopes);\n \n-            debug!(\"regions: v_a = {:?}\", v_a);\n-            debug!(\"regions: v_b = {:?}\", v_b);\n+        debug!(\"regions: v_a = {:?}\", v_a);\n+        debug!(\"regions: v_b = {:?}\", v_b);\n \n-            if self.ambient_covariance() {\n-                // Covariance: a <= b. Hence, `b: a`.\n-                self.push_outlives(v_b, v_a);\n-            }\n+        if self.ambient_covariance() {\n+            // Covariance: a <= b. Hence, `b: a`.\n+            self.push_outlives(v_b, v_a);\n+        }\n \n-            if self.ambient_contravariance() {\n-                // Contravariant: b <= a. Hence, `a: b`.\n-                self.push_outlives(v_a, v_b);\n-            }\n+        if self.ambient_contravariance() {\n+            // Contravariant: b <= a. Hence, `a: b`.\n+            self.push_outlives(v_a, v_b);\n         }\n \n         Ok(a)\n@@ -527,10 +584,8 @@ impl<'cx, 'bccx, 'gcx, 'tcx> TypeRelation<'cx, 'gcx, 'tcx>\n \n             // Reset ambient variance to contravariance. See the\n             // covariant case above for an explanation.\n-            let variance = ::std::mem::replace(\n-                &mut self.ambient_variance,\n-                ty::Variance::Contravariant,\n-            );\n+            let variance =\n+                ::std::mem::replace(&mut self.ambient_variance, ty::Variance::Contravariant);\n \n             self.relate(a.skip_binder(), b.skip_binder())?;\n \n@@ -551,15 +606,21 @@ impl<'cx, 'bccx, 'gcx, 'tcx> TypeRelation<'cx, 'gcx, 'tcx>\n /// binder depth, and finds late-bound regions targeting the\n /// `for<..`>.  For each of those, it creates an entry in\n /// `bound_region_scope`.\n-struct ScopeInstantiator<'cx, 'gcx: 'tcx, 'tcx: 'cx> {\n-    infcx: &'cx InferCtxt<'cx, 'gcx, 'tcx>,\n+struct ScopeInstantiator<'me, 'tcx: 'me, D>\n+where\n+    D: TypeRelatingDelegate<'tcx> + 'me,\n+{\n+    delegate: &'me mut D,\n     // The debruijn index of the scope we are instantiating.\n     target_index: ty::DebruijnIndex,\n     universally_quantified: UniversallyQuantified,\n-    bound_region_scope: &'cx mut BoundRegionScope,\n+    bound_region_scope: &'me mut BoundRegionScope<'tcx>,\n }\n \n-impl<'cx, 'gcx, 'tcx> TypeVisitor<'tcx> for ScopeInstantiator<'cx, 'gcx, 'tcx> {\n+impl<'me, 'tcx, D> TypeVisitor<'tcx> for ScopeInstantiator<'me, 'tcx, D>\n+where\n+    D: TypeRelatingDelegate<'tcx>,\n+{\n     fn visit_binder<T: TypeFoldable<'tcx>>(&mut self, t: &ty::Binder<T>) -> bool {\n         self.target_index.shift_in(1);\n         t.super_visit_with(self);\n@@ -570,21 +631,18 @@ impl<'cx, 'gcx, 'tcx> TypeVisitor<'tcx> for ScopeInstantiator<'cx, 'gcx, 'tcx> {\n \n     fn visit_region(&mut self, r: ty::Region<'tcx>) -> bool {\n         let ScopeInstantiator {\n-            infcx,\n             universally_quantified,\n+            bound_region_scope,\n+            delegate,\n             ..\n-        } = *self;\n+        } = self;\n \n         match r {\n             ty::ReLateBound(debruijn, br) if *debruijn == self.target_index => {\n-                self.bound_region_scope.map.entry(*br).or_insert_with(|| {\n-                    let origin = if universally_quantified.0 {\n-                        NLLRegionVariableOrigin::BoundRegion(infcx.create_subuniverse())\n-                    } else {\n-                        NLLRegionVariableOrigin::Existential\n-                    };\n-                    infcx.next_nll_region_var(origin).to_region_vid()\n-                });\n+                bound_region_scope\n+                    .map\n+                    .entry(*br)\n+                    .or_insert_with(|| delegate.next_region_var(*universally_quantified));\n             }\n \n             _ => {}\n@@ -613,8 +671,13 @@ impl<'cx, 'gcx, 'tcx> TypeVisitor<'tcx> for ScopeInstantiator<'cx, 'gcx, 'tcx> {\n /// scopes.\n ///\n /// [blog post]: https://is.gd/0hKvIr\n-struct TypeGeneralizer<'me, 'bccx: 'me, 'gcx: 'tcx, 'tcx: 'bccx> {\n-    type_rel: &'me TypeRelating<'me, 'bccx, 'gcx, 'tcx>,\n+struct TypeGeneralizer<'me, 'gcx: 'tcx, 'tcx: 'me, D>\n+where\n+    D: TypeRelatingDelegate<'tcx> + 'me,\n+{\n+    tcx: TyCtxt<'me, 'gcx, 'tcx>,\n+\n+    delegate: &'me mut D,\n \n     /// After we generalize this type, we are going to relative it to\n     /// some other type. What will be the variance at this point?\n@@ -625,9 +688,12 @@ struct TypeGeneralizer<'me, 'bccx: 'me, 'gcx: 'tcx, 'tcx: 'bccx> {\n     universe: ty::UniverseIndex,\n }\n \n-impl TypeRelation<'me, 'gcx, 'tcx> for TypeGeneralizer<'me, 'bbcx, 'gcx, 'tcx> {\n+impl<D> TypeRelation<'me, 'gcx, 'tcx> for TypeGeneralizer<'me, 'gcx, 'tcx, D>\n+where\n+    D: TypeRelatingDelegate<'tcx>,\n+{\n     fn tcx(&self) -> TyCtxt<'me, 'gcx, 'tcx> {\n-        self.type_rel.infcx.tcx\n+        self.tcx\n     }\n \n     fn tag(&self) -> &'static str {\n@@ -710,9 +776,7 @@ impl TypeRelation<'me, 'gcx, 'tcx> for TypeGeneralizer<'me, 'bbcx, 'gcx, 'tcx> {\n         // though, we may however need to check well-formedness or\n         // risk a problem like #41677 again.\n \n-        let replacement_region_vid = self.type_rel\n-            .infcx\n-            .next_nll_region_var_in_universe(NLLRegionVariableOrigin::Existential, self.universe);\n+        let replacement_region_vid = self.delegate.generalize_existential(self.universe);\n \n         Ok(replacement_region_vid)\n     }"}, {"sha": "c1afc12736791e396d9f545f66a65f6ced52da48", "filename": "src/librustc_typeck/check/dropck.rs", "status": "modified", "additions": 69, "deletions": 44, "changes": 113, "blob_url": "https://github.com/rust-lang/rust/blob/c7df1f530b8a88f471e60e933868e7ddf456974d/src%2Flibrustc_typeck%2Fcheck%2Fdropck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7df1f530b8a88f471e60e933868e7ddf456974d/src%2Flibrustc_typeck%2Fcheck%2Fdropck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fdropck.rs?ref=c7df1f530b8a88f471e60e933868e7ddf456974d", "patch": "@@ -11,12 +11,12 @@\n use check::regionck::RegionCtxt;\n \n use hir::def_id::DefId;\n-use rustc::infer::{self, InferOk};\n use rustc::infer::outlives::env::OutlivesEnvironment;\n+use rustc::infer::{self, InferOk, SuppressRegionErrors};\n use rustc::middle::region;\n+use rustc::traits::{ObligationCause, TraitEngine, TraitEngineExt};\n use rustc::ty::subst::{Subst, Substs, UnpackedKind};\n use rustc::ty::{self, Ty, TyCtxt};\n-use rustc::traits::{ObligationCause, TraitEngine, TraitEngineExt};\n use util::common::ErrorReported;\n \n use syntax::ast;\n@@ -39,32 +39,41 @@ use syntax_pos::Span;\n ///    struct/enum definition for the nominal type itself (i.e.\n ///    cannot do `struct S<T>; impl<T:Clone> Drop for S<T> { ... }`).\n ///\n-pub fn check_drop_impl<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                                 drop_impl_did: DefId)\n-                                 -> Result<(), ErrorReported> {\n+pub fn check_drop_impl<'a, 'tcx>(\n+    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+    drop_impl_did: DefId,\n+) -> Result<(), ErrorReported> {\n     let dtor_self_type = tcx.type_of(drop_impl_did);\n     let dtor_predicates = tcx.predicates_of(drop_impl_did);\n     match dtor_self_type.sty {\n         ty::Adt(adt_def, self_to_impl_substs) => {\n-            ensure_drop_params_and_item_params_correspond(tcx,\n-                                                          drop_impl_did,\n-                                                          dtor_self_type,\n-                                                          adt_def.did)?;\n+            ensure_drop_params_and_item_params_correspond(\n+                tcx,\n+                drop_impl_did,\n+                dtor_self_type,\n+                adt_def.did,\n+            )?;\n \n-            ensure_drop_predicates_are_implied_by_item_defn(tcx,\n-                                                            drop_impl_did,\n-                                                            &dtor_predicates,\n-                                                            adt_def.did,\n-                                                            self_to_impl_substs)\n+            ensure_drop_predicates_are_implied_by_item_defn(\n+                tcx,\n+                drop_impl_did,\n+                &dtor_predicates,\n+                adt_def.did,\n+                self_to_impl_substs,\n+            )\n         }\n         _ => {\n             // Destructors only work on nominal types.  This was\n             // already checked by coherence, but compilation may\n             // not have been terminated.\n             let span = tcx.def_span(drop_impl_did);\n-            tcx.sess.delay_span_bug(span,\n-                            &format!(\"should have been rejected by coherence check: {}\",\n-                            dtor_self_type));\n+            tcx.sess.delay_span_bug(\n+                span,\n+                &format!(\n+                    \"should have been rejected by coherence check: {}\",\n+                    dtor_self_type\n+                ),\n+            );\n             Err(ErrorReported)\n         }\n     }\n@@ -74,9 +83,8 @@ fn ensure_drop_params_and_item_params_correspond<'a, 'tcx>(\n     tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     drop_impl_did: DefId,\n     drop_impl_ty: Ty<'tcx>,\n-    self_type_did: DefId)\n-    -> Result<(), ErrorReported>\n-{\n+    self_type_did: DefId,\n+) -> Result<(), ErrorReported> {\n     let drop_impl_node_id = tcx.hir.as_local_node_id(drop_impl_did).unwrap();\n \n     // check that the impl type can be made to match the trait type.\n@@ -89,22 +97,29 @@ fn ensure_drop_params_and_item_params_correspond<'a, 'tcx>(\n         let named_type = tcx.type_of(self_type_did);\n \n         let drop_impl_span = tcx.def_span(drop_impl_did);\n-        let fresh_impl_substs =\n-            infcx.fresh_substs_for_item(drop_impl_span, drop_impl_did);\n+        let fresh_impl_substs = infcx.fresh_substs_for_item(drop_impl_span, drop_impl_did);\n         let fresh_impl_self_ty = drop_impl_ty.subst(tcx, fresh_impl_substs);\n \n         let cause = &ObligationCause::misc(drop_impl_span, drop_impl_node_id);\n-        match infcx.at(cause, impl_param_env).eq(named_type, fresh_impl_self_ty) {\n+        match infcx\n+            .at(cause, impl_param_env)\n+            .eq(named_type, fresh_impl_self_ty)\n+        {\n             Ok(InferOk { obligations, .. }) => {\n                 fulfillment_cx.register_predicate_obligations(infcx, obligations);\n             }\n             Err(_) => {\n                 let item_span = tcx.def_span(self_type_did);\n-                struct_span_err!(tcx.sess, drop_impl_span, E0366,\n-                                 \"Implementations of Drop cannot be specialized\")\n-                    .span_note(item_span,\n-                               \"Use same sequence of generic type and region \\\n-                                parameters that is on the struct/enum definition\")\n+                struct_span_err!(\n+                    tcx.sess,\n+                    drop_impl_span,\n+                    E0366,\n+                    \"Implementations of Drop cannot be specialized\"\n+                ).span_note(\n+                    item_span,\n+                    \"Use same sequence of generic type and region \\\n+                     parameters that is on the struct/enum definition\",\n+                )\n                     .emit();\n                 return Err(ErrorReported);\n             }\n@@ -128,7 +143,12 @@ fn ensure_drop_params_and_item_params_correspond<'a, 'tcx>(\n         // conservative. -nmatsakis\n         let outlives_env = OutlivesEnvironment::new(ty::ParamEnv::empty());\n \n-        infcx.resolve_regions_and_report_errors(drop_impl_did, &region_scope_tree, &outlives_env);\n+        infcx.resolve_regions_and_report_errors(\n+            drop_impl_did,\n+            &region_scope_tree,\n+            &outlives_env,\n+            SuppressRegionErrors::default(),\n+        );\n         Ok(())\n     })\n }\n@@ -140,9 +160,8 @@ fn ensure_drop_predicates_are_implied_by_item_defn<'a, 'tcx>(\n     drop_impl_did: DefId,\n     dtor_predicates: &ty::GenericPredicates<'tcx>,\n     self_type_did: DefId,\n-    self_to_impl_substs: &Substs<'tcx>)\n-    -> Result<(), ErrorReported>\n-{\n+    self_to_impl_substs: &Substs<'tcx>,\n+) -> Result<(), ErrorReported> {\n     let mut result = Ok(());\n \n     // Here is an example, analogous to that from\n@@ -213,11 +232,17 @@ fn ensure_drop_predicates_are_implied_by_item_defn<'a, 'tcx>(\n \n         if !assumptions_in_impl_context.contains(&predicate) {\n             let item_span = tcx.hir.span(self_type_node_id);\n-            struct_span_err!(tcx.sess, drop_impl_span, E0367,\n-                             \"The requirement `{}` is added only by the Drop impl.\", predicate)\n-                .span_note(item_span,\n-                           \"The same requirement must be part of \\\n-                            the struct/enum definition\")\n+            struct_span_err!(\n+                tcx.sess,\n+                drop_impl_span,\n+                E0367,\n+                \"The requirement `{}` is added only by the Drop impl.\",\n+                predicate\n+            ).span_note(\n+                item_span,\n+                \"The same requirement must be part of \\\n+                 the struct/enum definition\",\n+            )\n                 .emit();\n             result = Err(ErrorReported);\n         }\n@@ -283,18 +308,18 @@ pub fn check_safety_of_destructor_if_necessary<'a, 'gcx, 'tcx>(\n     ty: Ty<'tcx>,\n     span: Span,\n     body_id: ast::NodeId,\n-    scope: region::Scope)\n-    -> Result<(), ErrorReported>\n-{\n-    debug!(\"check_safety_of_destructor_if_necessary typ: {:?} scope: {:?}\",\n-           ty, scope);\n-\n+    scope: region::Scope,\n+) -> Result<(), ErrorReported> {\n+    debug!(\n+        \"check_safety_of_destructor_if_necessary typ: {:?} scope: {:?}\",\n+        ty, scope\n+    );\n \n     let parent_scope = match rcx.region_scope_tree.opt_encl_scope(scope) {\n         Some(parent_scope) => parent_scope,\n         // If no enclosing scope, then it must be the root scope\n         // which cannot be outlived.\n-        None => return Ok(())\n+        None => return Ok(()),\n     };\n     let parent_scope = rcx.tcx.mk_region(ty::ReScope(parent_scope));\n     let origin = || infer::SubregionOrigin::SafeDestructor(span);"}, {"sha": "d7d006728536a4d2c5db91ff277b9f466f825af4", "filename": "src/librustc_typeck/check/regionck.rs", "status": "modified", "additions": 398, "deletions": 317, "changes": 715, "blob_url": "https://github.com/rust-lang/rust/blob/c7df1f530b8a88f471e60e933868e7ddf456974d/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7df1f530b8a88f471e60e933868e7ddf456974d/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs?ref=c7df1f530b8a88f471e60e933868e7ddf456974d", "patch": "@@ -88,27 +88,32 @@ use middle::mem_categorization as mc;\n use middle::mem_categorization::Categorization;\n use middle::region;\n use rustc::hir::def_id::DefId;\n-use rustc::ty::subst::Substs;\n-use rustc::ty::{self, Ty};\n-use rustc::infer;\n use rustc::infer::outlives::env::OutlivesEnvironment;\n+use rustc::infer::{self, RegionObligation, SuppressRegionErrors};\n use rustc::ty::adjustment;\n+use rustc::ty::subst::Substs;\n+use rustc::ty::{self, Ty};\n \n+use rustc::hir::intravisit::{self, NestedVisitorMap, Visitor};\n+use rustc::hir::{self, PatKind};\n+use rustc_data_structures::sync::Lrc;\n use std::mem;\n use std::ops::Deref;\n use std::rc::Rc;\n-use rustc_data_structures::sync::Lrc;\n use syntax::ast;\n use syntax_pos::Span;\n-use rustc::hir::intravisit::{self, Visitor, NestedVisitorMap};\n-use rustc::hir::{self, PatKind};\n \n // a variation on try that just returns unit\n macro_rules! ignore_err {\n-    ($e:expr) => (match $e { Ok(e) => e, Err(_) => {\n-        debug!(\"ignoring mem-categorization error!\");\n-        return ()\n-    }})\n+    ($e:expr) => {\n+        match $e {\n+            Ok(e) => e,\n+            Err(_) => {\n+                debug!(\"ignoring mem-categorization error!\");\n+                return ();\n+            }\n+        }\n+    };\n }\n \n ///////////////////////////////////////////////////////////////////////////\n@@ -118,38 +123,46 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n     pub fn regionck_expr(&self, body: &'gcx hir::Body) {\n         let subject = self.tcx.hir.body_owner_def_id(body.id());\n         let id = body.value.id;\n-        let mut rcx = RegionCtxt::new(self,\n-                                      RepeatingScope(id),\n-                                      id,\n-                                      Subject(subject),\n-                                      self.param_env);\n+        let mut rcx = RegionCtxt::new(\n+            self,\n+            RepeatingScope(id),\n+            id,\n+            Subject(subject),\n+            self.param_env,\n+        );\n+\n+        // There are no add'l implied bounds when checking a\n+        // standalone expr (e.g., the `E` in a type like `[u32; E]`).\n+        rcx.outlives_environment.save_implied_bounds(id);\n+\n         if self.err_count_since_creation() == 0 {\n             // regionck assumes typeck succeeded\n             rcx.visit_body(body);\n             rcx.visit_region_obligations(id);\n         }\n-        rcx.resolve_regions_and_report_errors_unless_nll();\n+        rcx.resolve_regions_and_report_errors(SuppressRegionErrors::when_nll_is_enabled(self.tcx));\n \n         assert!(self.tables.borrow().free_region_map.is_empty());\n         self.tables.borrow_mut().free_region_map = rcx.outlives_environment.into_free_region_map();\n     }\n \n     /// Region checking during the WF phase for items. `wf_tys` are the\n     /// types from which we should derive implied bounds, if any.\n-    pub fn regionck_item(&self,\n-                         item_id: ast::NodeId,\n-                         span: Span,\n-                         wf_tys: &[Ty<'tcx>]) {\n+    pub fn regionck_item(&self, item_id: ast::NodeId, span: Span, wf_tys: &[Ty<'tcx>]) {\n         debug!(\"regionck_item(item.id={:?}, wf_tys={:?})\", item_id, wf_tys);\n         let subject = self.tcx.hir.local_def_id(item_id);\n-        let mut rcx = RegionCtxt::new(self,\n-                                      RepeatingScope(item_id),\n-                                      item_id,\n-                                      Subject(subject),\n-                                      self.param_env);\n-        rcx.outlives_environment.add_implied_bounds(self, wf_tys, item_id, span);\n+        let mut rcx = RegionCtxt::new(\n+            self,\n+            RepeatingScope(item_id),\n+            item_id,\n+            Subject(subject),\n+            self.param_env,\n+        );\n+        rcx.outlives_environment\n+            .add_implied_bounds(self, wf_tys, item_id, span);\n+        rcx.outlives_environment.save_implied_bounds(item_id);\n         rcx.visit_region_obligations(item_id);\n-        rcx.resolve_regions_and_report_errors();\n+        rcx.resolve_regions_and_report_errors(SuppressRegionErrors::default());\n     }\n \n     /// Region check a function body. Not invoked on closures, but\n@@ -160,24 +173,24 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n     /// rest of type check and because sometimes we need type\n     /// inference to have completed before we can determine which\n     /// constraints to add.\n-    pub fn regionck_fn(&self,\n-                       fn_id: ast::NodeId,\n-                       body: &'gcx hir::Body) {\n+    pub fn regionck_fn(&self, fn_id: ast::NodeId, body: &'gcx hir::Body) {\n         debug!(\"regionck_fn(id={})\", fn_id);\n         let subject = self.tcx.hir.body_owner_def_id(body.id());\n         let node_id = body.value.id;\n-        let mut rcx = RegionCtxt::new(self,\n-                                      RepeatingScope(node_id),\n-                                      node_id,\n-                                      Subject(subject),\n-                                      self.param_env);\n+        let mut rcx = RegionCtxt::new(\n+            self,\n+            RepeatingScope(node_id),\n+            node_id,\n+            Subject(subject),\n+            self.param_env,\n+        );\n \n         if self.err_count_since_creation() == 0 {\n             // regionck assumes typeck succeeded\n             rcx.visit_fn_body(fn_id, body, self.tcx.hir.span(fn_id));\n         }\n \n-        rcx.resolve_regions_and_report_errors_unless_nll();\n+        rcx.resolve_regions_and_report_errors(SuppressRegionErrors::when_nll_is_enabled(self.tcx));\n \n         // In this mode, we also copy the free-region-map into the\n         // tables of the enclosing fcx. In the other regionck modes\n@@ -190,7 +203,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n ///////////////////////////////////////////////////////////////////////////\n // INTERNALS\n \n-pub struct RegionCtxt<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n+pub struct RegionCtxt<'a, 'gcx: 'a + 'tcx, 'tcx: 'a> {\n     pub fcx: &'a FnCtxt<'a, 'gcx, 'tcx>,\n \n     pub region_scope_tree: Lrc<region::ScopeTree>,\n@@ -208,7 +221,6 @@ pub struct RegionCtxt<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n \n     // id of AST node being analyzed (the subject of the analysis).\n     subject_def_id: DefId,\n-\n }\n \n impl<'a, 'gcx, 'tcx> Deref for RegionCtxt<'a, 'gcx, 'tcx> {\n@@ -222,12 +234,13 @@ pub struct RepeatingScope(ast::NodeId);\n pub struct Subject(DefId);\n \n impl<'a, 'gcx, 'tcx> RegionCtxt<'a, 'gcx, 'tcx> {\n-    pub fn new(fcx: &'a FnCtxt<'a, 'gcx, 'tcx>,\n-               RepeatingScope(initial_repeating_scope): RepeatingScope,\n-               initial_body_id: ast::NodeId,\n-               Subject(subject): Subject,\n-               param_env: ty::ParamEnv<'tcx>)\n-               -> RegionCtxt<'a, 'gcx, 'tcx> {\n+    pub fn new(\n+        fcx: &'a FnCtxt<'a, 'gcx, 'tcx>,\n+        RepeatingScope(initial_repeating_scope): RepeatingScope,\n+        initial_body_id: ast::NodeId,\n+        Subject(subject): Subject,\n+        param_env: ty::ParamEnv<'tcx>,\n+    ) -> RegionCtxt<'a, 'gcx, 'tcx> {\n         let region_scope_tree = fcx.tcx.region_scope_tree(subject);\n         let outlives_environment = OutlivesEnvironment::new(param_env);\n         RegionCtxt {\n@@ -296,11 +309,12 @@ impl<'a, 'gcx, 'tcx> RegionCtxt<'a, 'gcx, 'tcx> {\n     /// closures, however, we save and restore any \"scoped state\"\n     /// before we invoke this function. (See `visit_fn` in the\n     /// `intravisit::Visitor` impl below.)\n-    fn visit_fn_body(&mut self,\n-                     id: ast::NodeId, // the id of the fn itself\n-                     body: &'gcx hir::Body,\n-                     span: Span)\n-    {\n+    fn visit_fn_body(\n+        &mut self,\n+        id: ast::NodeId, // the id of the fn itself\n+        body: &'gcx hir::Body,\n+        span: Span,\n+    ) {\n         // When we enter a function, we can derive\n         debug!(\"visit_fn_body(id={})\", id);\n \n@@ -309,7 +323,7 @@ impl<'a, 'gcx, 'tcx> RegionCtxt<'a, 'gcx, 'tcx> {\n \n         let call_site = region::Scope {\n             id: body.value.hir_id.local_id,\n-            data: region::ScopeData::CallSite\n+            data: region::ScopeData::CallSite,\n         };\n         self.call_site_scope = Some(call_site);\n \n@@ -328,65 +342,70 @@ impl<'a, 'gcx, 'tcx> RegionCtxt<'a, 'gcx, 'tcx> {\n         // because it will have no effect.\n         //\n         // FIXME(#27579) return types should not be implied bounds\n-        let fn_sig_tys: Vec<_> =\n-            fn_sig.inputs().iter().cloned().chain(Some(fn_sig.output())).collect();\n+        let fn_sig_tys: Vec<_> = fn_sig\n+            .inputs()\n+            .iter()\n+            .cloned()\n+            .chain(Some(fn_sig.output()))\n+            .collect();\n \n         self.outlives_environment.add_implied_bounds(\n             self.fcx,\n             &fn_sig_tys[..],\n             body_id.node_id,\n-            span);\n+            span,\n+        );\n+        self.outlives_environment\n+            .save_implied_bounds(body_id.node_id);\n         self.link_fn_args(\n             region::Scope {\n                 id: body.value.hir_id.local_id,\n-                data: region::ScopeData::Node\n+                data: region::ScopeData::Node,\n             },\n-            &body.arguments);\n+            &body.arguments,\n+        );\n         self.visit_body(body);\n         self.visit_region_obligations(body_id.node_id);\n \n         let call_site_scope = self.call_site_scope.unwrap();\n-        debug!(\"visit_fn_body body.id {:?} call_site_scope: {:?}\",\n-               body.id(), call_site_scope);\n+        debug!(\n+            \"visit_fn_body body.id {:?} call_site_scope: {:?}\",\n+            body.id(),\n+            call_site_scope\n+        );\n         let call_site_region = self.tcx.mk_region(ty::ReScope(call_site_scope));\n \n         let body_hir_id = self.tcx.hir.node_to_hir_id(body_id.node_id);\n-        self.type_of_node_must_outlive(infer::CallReturn(span),\n-                                       body_hir_id,\n-                                       call_site_region);\n+        self.type_of_node_must_outlive(infer::CallReturn(span), body_hir_id, call_site_region);\n \n         self.constrain_opaque_types(\n             &self.fcx.opaque_types.borrow(),\n             self.outlives_environment.free_region_map(),\n         );\n     }\n \n-    fn visit_region_obligations(&mut self, node_id: ast::NodeId)\n-    {\n+    fn visit_region_obligations(&mut self, node_id: ast::NodeId) {\n         debug!(\"visit_region_obligations: node_id={}\", node_id);\n \n         // region checking can introduce new pending obligations\n         // which, when processed, might generate new region\n         // obligations. So make sure we process those.\n         self.select_all_obligations_or_error();\n+    }\n \n+    fn resolve_regions_and_report_errors(&self, suppress: SuppressRegionErrors) {\n         self.infcx.process_registered_region_obligations(\n-            self.outlives_environment.region_bound_pairs(),\n+            self.outlives_environment.region_bound_pairs_map(),\n             self.implicit_region_bound,\n             self.param_env,\n-            self.body_id);\n-    }\n-\n-    fn resolve_regions_and_report_errors(&self) {\n-        self.fcx.resolve_regions_and_report_errors(self.subject_def_id,\n-                                                   &self.region_scope_tree,\n-                                                   &self.outlives_environment);\n-    }\n+        );\n \n-    fn resolve_regions_and_report_errors_unless_nll(&self) {\n-        self.fcx.resolve_regions_and_report_errors_unless_nll(self.subject_def_id,\n-                                                              &self.region_scope_tree,\n-                                                              &self.outlives_environment);\n+        self.fcx.resolve_regions_and_report_errors(\n+            self.subject_def_id,\n+            &self.region_scope_tree,\n+            &self.outlives_environment,\n+            suppress,\n+        );\n     }\n \n     fn constrain_bindings_in_pat(&mut self, pat: &hir::Pat) {\n@@ -423,7 +442,8 @@ impl<'a, 'gcx, 'tcx> RegionCtxt<'a, 'gcx, 'tcx> {\n             let typ = self.resolve_node_type(hir_id);\n             let body_id = self.body_id;\n             let _ = dropck::check_safety_of_destructor_if_necessary(\n-                self, typ, span, body_id, var_scope);\n+                self, typ, span, body_id, var_scope,\n+            );\n         })\n     }\n }\n@@ -441,14 +461,21 @@ impl<'a, 'gcx, 'tcx> Visitor<'gcx> for RegionCtxt<'a, 'gcx, 'tcx> {\n         NestedVisitorMap::None\n     }\n \n-    fn visit_fn(&mut self,\n-                fk: intravisit::FnKind<'gcx>,\n-                _: &'gcx hir::FnDecl,\n-                body_id: hir::BodyId,\n-                span: Span,\n-                id: ast::NodeId) {\n-        assert!(match fk { intravisit::FnKind::Closure(..) => true, _ => false },\n-                \"visit_fn invoked for something other than a closure\");\n+    fn visit_fn(\n+        &mut self,\n+        fk: intravisit::FnKind<'gcx>,\n+        _: &'gcx hir::FnDecl,\n+        body_id: hir::BodyId,\n+        span: Span,\n+        id: ast::NodeId,\n+    ) {\n+        assert!(\n+            match fk {\n+                intravisit::FnKind::Closure(..) => true,\n+                _ => false,\n+            },\n+            \"visit_fn invoked for something other than a closure\"\n+        );\n \n         // Save state of current function before invoking\n         // `visit_fn_body`.  We will restore afterwards.\n@@ -460,7 +487,8 @@ impl<'a, 'gcx, 'tcx> Visitor<'gcx> for RegionCtxt<'a, 'gcx, 'tcx> {\n         self.visit_fn_body(id, body, span);\n \n         // Restore state from previous function.\n-        self.outlives_environment.pop_snapshot_post_closure(env_snapshot);\n+        self.outlives_environment\n+            .pop_snapshot_post_closure(env_snapshot);\n         self.call_site_scope = old_call_site_scope;\n         self.body_id = old_body_id;\n     }\n@@ -483,20 +511,24 @@ impl<'a, 'gcx, 'tcx> Visitor<'gcx> for RegionCtxt<'a, 'gcx, 'tcx> {\n     }\n \n     fn visit_expr(&mut self, expr: &'gcx hir::Expr) {\n-        debug!(\"regionck::visit_expr(e={:?}, repeating_scope={})\",\n-               expr, self.repeating_scope);\n+        debug!(\n+            \"regionck::visit_expr(e={:?}, repeating_scope={})\",\n+            expr, self.repeating_scope\n+        );\n \n         // No matter what, the type of each expression must outlive the\n         // scope of that expression. This also guarantees basic WF.\n         let expr_ty = self.resolve_node_type(expr.hir_id);\n         // the region corresponding to this expression\n-        let expr_region = self.tcx.mk_region(ty::ReScope(\n-            region::Scope {\n-                id: expr.hir_id.local_id,\n-                data: region::ScopeData::Node\n-            }));\n-        self.type_must_outlive(infer::ExprTypeIsNotInScope(expr_ty, expr.span),\n-                               expr_ty, expr_region);\n+        let expr_region = self.tcx.mk_region(ty::ReScope(region::Scope {\n+            id: expr.hir_id.local_id,\n+            data: region::ScopeData::Node,\n+        }));\n+        self.type_must_outlive(\n+            infer::ExprTypeIsNotInScope(expr_ty, expr.span),\n+            expr_ty,\n+            expr_region,\n+        );\n \n         let is_method_call = self.tables.borrow().is_method_call(expr);\n \n@@ -506,12 +538,11 @@ impl<'a, 'gcx, 'tcx> Visitor<'gcx> for RegionCtxt<'a, 'gcx, 'tcx> {\n         // provided as arguments outlive the call.\n         if is_method_call {\n             let origin = match expr.node {\n-                hir::ExprKind::MethodCall(..) =>\n-                    infer::ParameterOrigin::MethodCall,\n-                hir::ExprKind::Unary(op, _) if op == hir::UnDeref =>\n-                    infer::ParameterOrigin::OverloadedDeref,\n-                _ =>\n-                    infer::ParameterOrigin::OverloadedOperator\n+                hir::ExprKind::MethodCall(..) => infer::ParameterOrigin::MethodCall,\n+                hir::ExprKind::Unary(op, _) if op == hir::UnDeref => {\n+                    infer::ParameterOrigin::OverloadedDeref\n+                }\n+                _ => infer::ParameterOrigin::OverloadedOperator,\n             };\n \n             let substs = self.tables.borrow().node_substs(expr.hir_id);\n@@ -533,8 +564,10 @@ impl<'a, 'gcx, 'tcx> Visitor<'gcx> for RegionCtxt<'a, 'gcx, 'tcx> {\n             }\n         }\n \n-        debug!(\"regionck::visit_expr(e={:?}, repeating_scope={}) - visiting subexprs\",\n-               expr, self.repeating_scope);\n+        debug!(\n+            \"regionck::visit_expr(e={:?}, repeating_scope={}) - visiting subexprs\",\n+            expr, self.repeating_scope\n+        );\n         match expr.node {\n             hir::ExprKind::Path(_) => {\n                 let substs = self.tables.borrow().node_substs(expr.hir_id);\n@@ -571,7 +604,7 @@ impl<'a, 'gcx, 'tcx> Visitor<'gcx> for RegionCtxt<'a, 'gcx, 'tcx> {\n                 self.constrain_call(expr, Some(&lhs), Some(&**rhs).into_iter());\n \n                 intravisit::walk_expr(self, expr);\n-            },\n+            }\n \n             hir::ExprKind::Binary(_, ref lhs, ref rhs) if is_method_call => {\n                 // As `ExprKind::MethodCall`, but the call is via an overloaded op.\n@@ -586,8 +619,7 @@ impl<'a, 'gcx, 'tcx> Visitor<'gcx> for RegionCtxt<'a, 'gcx, 'tcx> {\n                 let lhs_ty = self.resolve_expr_type_adjusted(&lhs);\n                 let rhs_ty = self.resolve_expr_type_adjusted(&rhs);\n                 for &ty in &[lhs_ty, rhs_ty] {\n-                    self.type_must_outlive(infer::Operand(expr.span),\n-                                           ty, expr_region);\n+                    self.type_must_outlive(infer::Operand(expr.span), ty, expr_region);\n                 }\n                 intravisit::walk_expr(self, expr);\n             }\n@@ -674,12 +706,16 @@ impl<'a, 'gcx, 'tcx> Visitor<'gcx> for RegionCtxt<'a, 'gcx, 'tcx> {\n \n             hir::ExprKind::Ret(Some(ref ret_expr)) => {\n                 let call_site_scope = self.call_site_scope;\n-                debug!(\"visit_expr ExprKind::Ret ret_expr.id {} call_site_scope: {:?}\",\n-                       ret_expr.id, call_site_scope);\n+                debug!(\n+                    \"visit_expr ExprKind::Ret ret_expr.id {} call_site_scope: {:?}\",\n+                    ret_expr.id, call_site_scope\n+                );\n                 let call_site_region = self.tcx.mk_region(ty::ReScope(call_site_scope.unwrap()));\n-                self.type_of_node_must_outlive(infer::CallReturn(ret_expr.span),\n-                                               ret_expr.hir_id,\n-                                               call_site_region);\n+                self.type_of_node_must_outlive(\n+                    infer::CallReturn(ret_expr.span),\n+                    ret_expr.hir_id,\n+                    call_site_region,\n+                );\n                 intravisit::walk_expr(self, expr);\n             }\n \n@@ -691,54 +727,47 @@ impl<'a, 'gcx, 'tcx> Visitor<'gcx> for RegionCtxt<'a, 'gcx, 'tcx> {\n }\n \n impl<'a, 'gcx, 'tcx> RegionCtxt<'a, 'gcx, 'tcx> {\n-    fn constrain_cast(&mut self,\n-                      cast_expr: &hir::Expr,\n-                      source_expr: &hir::Expr)\n-    {\n-        debug!(\"constrain_cast(cast_expr={:?}, source_expr={:?})\",\n-               cast_expr,\n-               source_expr);\n+    fn constrain_cast(&mut self, cast_expr: &hir::Expr, source_expr: &hir::Expr) {\n+        debug!(\n+            \"constrain_cast(cast_expr={:?}, source_expr={:?})\",\n+            cast_expr, source_expr\n+        );\n \n         let source_ty = self.resolve_node_type(source_expr.hir_id);\n         let target_ty = self.resolve_node_type(cast_expr.hir_id);\n \n         self.walk_cast(cast_expr, source_ty, target_ty);\n     }\n \n-    fn walk_cast(&mut self,\n-                 cast_expr: &hir::Expr,\n-                 from_ty: Ty<'tcx>,\n-                 to_ty: Ty<'tcx>) {\n-        debug!(\"walk_cast(from_ty={:?}, to_ty={:?})\",\n-               from_ty,\n-               to_ty);\n+    fn walk_cast(&mut self, cast_expr: &hir::Expr, from_ty: Ty<'tcx>, to_ty: Ty<'tcx>) {\n+        debug!(\"walk_cast(from_ty={:?}, to_ty={:?})\", from_ty, to_ty);\n         match (&from_ty.sty, &to_ty.sty) {\n-            /*From:*/ (&ty::Ref(from_r, from_ty, _),\n-            /*To:  */  &ty::Ref(to_r, to_ty, _)) => {\n+            /*From:*/\n+            (&ty::Ref(from_r, from_ty, _), /*To:  */ &ty::Ref(to_r, to_ty, _)) => {\n                 // Target cannot outlive source, naturally.\n                 self.sub_regions(infer::Reborrow(cast_expr.span), to_r, from_r);\n                 self.walk_cast(cast_expr, from_ty, to_ty);\n             }\n \n-            /*From:*/ (_,\n-            /*To:  */  &ty::Dynamic(.., r)) => {\n+            /*From:*/\n+            (_, /*To:  */ &ty::Dynamic(.., r)) => {\n                 // When T is existentially quantified as a trait\n                 // `Foo+'to`, it must outlive the region bound `'to`.\n                 self.type_must_outlive(infer::RelateObjectBound(cast_expr.span), from_ty, r);\n             }\n \n-            /*From:*/ (&ty::Adt(from_def, _),\n-            /*To:  */  &ty::Adt(to_def, _)) if from_def.is_box() && to_def.is_box() => {\n+            /*From:*/\n+            (&ty::Adt(from_def, _), /*To:  */ &ty::Adt(to_def, _))\n+                if from_def.is_box() && to_def.is_box() =>\n+            {\n                 self.walk_cast(cast_expr, from_ty.boxed_ty(), to_ty.boxed_ty());\n             }\n \n-            _ => { }\n+            _ => {}\n         }\n     }\n \n-    fn check_expr_fn_block(&mut self,\n-                           expr: &'gcx hir::Expr,\n-                           body_id: hir::BodyId) {\n+    fn check_expr_fn_block(&mut self, expr: &'gcx hir::Expr, body_id: hir::BodyId) {\n         let repeating_scope = self.set_repeating_scope(body_id.node_id);\n         intravisit::walk_expr(self, expr);\n         self.set_repeating_scope(repeating_scope);\n@@ -747,7 +776,7 @@ impl<'a, 'gcx, 'tcx> RegionCtxt<'a, 'gcx, 'tcx> {\n     fn constrain_callee(&mut self, callee_expr: &hir::Expr) {\n         let callee_ty = self.resolve_node_type(callee_expr.hir_id);\n         match callee_ty.sty {\n-            ty::FnDef(..) | ty::FnPtr(_) => { }\n+            ty::FnDef(..) | ty::FnPtr(_) => {}\n             _ => {\n                 // this should not happen, but it does if the program is\n                 // erroneous\n@@ -760,26 +789,29 @@ impl<'a, 'gcx, 'tcx> RegionCtxt<'a, 'gcx, 'tcx> {\n         }\n     }\n \n-    fn constrain_call<'b, I: Iterator<Item=&'b hir::Expr>>(&mut self,\n-                                                           call_expr: &hir::Expr,\n-                                                           receiver: Option<&hir::Expr>,\n-                                                           arg_exprs: I) {\n+    fn constrain_call<'b, I: Iterator<Item = &'b hir::Expr>>(\n+        &mut self,\n+        call_expr: &hir::Expr,\n+        receiver: Option<&hir::Expr>,\n+        arg_exprs: I,\n+    ) {\n         //! Invoked on every call site (i.e., normal calls, method calls,\n         //! and overloaded operators). Constrains the regions which appear\n         //! in the type of the function. Also constrains the regions that\n         //! appear in the arguments appropriately.\n \n-        debug!(\"constrain_call(call_expr={:?}, receiver={:?})\",\n-                call_expr,\n-                receiver);\n+        debug!(\n+            \"constrain_call(call_expr={:?}, receiver={:?})\",\n+            call_expr, receiver\n+        );\n \n         // `callee_region` is the scope representing the time in which the\n         // call occurs.\n         //\n         // FIXME(#6268) to support nested method calls, should be callee_id\n         let callee_scope = region::Scope {\n             id: call_expr.hir_id.local_id,\n-            data: region::ScopeData::Node\n+            data: region::ScopeData::Node,\n         };\n         let callee_region = self.tcx.mk_region(ty::ReScope(callee_scope));\n \n@@ -790,27 +822,30 @@ impl<'a, 'gcx, 'tcx> RegionCtxt<'a, 'gcx, 'tcx> {\n \n             // ensure that any regions appearing in the argument type are\n             // valid for at least the lifetime of the function:\n-            self.type_of_node_must_outlive(infer::CallArg(arg_expr.span),\n-                                           arg_expr.hir_id,\n-                                           callee_region);\n+            self.type_of_node_must_outlive(\n+                infer::CallArg(arg_expr.span),\n+                arg_expr.hir_id,\n+                callee_region,\n+            );\n         }\n \n         // as loop above, but for receiver\n         if let Some(r) = receiver {\n             debug!(\"receiver: {:?}\", r);\n-            self.type_of_node_must_outlive(infer::CallRcvr(r.span),\n-                                           r.hir_id,\n-                                           callee_region);\n+            self.type_of_node_must_outlive(infer::CallRcvr(r.span), r.hir_id, callee_region);\n         }\n     }\n \n     /// Create a temporary `MemCategorizationContext` and pass it to the closure.\n     fn with_mc<F, R>(&self, f: F) -> R\n-        where F: for<'b> FnOnce(mc::MemCategorizationContext<'b, 'gcx, 'tcx>) -> R\n+    where\n+        F: for<'b> FnOnce(mc::MemCategorizationContext<'b, 'gcx, 'tcx>) -> R,\n     {\n-        f(mc::MemCategorizationContext::with_infer(&self.infcx,\n-                                                   &self.region_scope_tree,\n-                                                   &self.tables.borrow()))\n+        f(mc::MemCategorizationContext::with_infer(\n+            &self.infcx,\n+            &self.region_scope_tree,\n+            &self.tables.borrow(),\n+        ))\n     }\n \n     /// Invoked on any adjustments that occur. Checks that if this is a region pointer being\n@@ -832,37 +867,46 @@ impl<'a, 'gcx, 'tcx> RegionCtxt<'a, 'gcx, 'tcx> {\n         // expression.\n         self.check_safety_of_rvalue_destructor_if_necessary(&cmt, expr.span);\n \n-        let expr_region = self.tcx.mk_region(ty::ReScope(\n-            region::Scope {\n-                id: expr.hir_id.local_id,\n-                data: region::ScopeData::Node\n-            }));\n+        let expr_region = self.tcx.mk_region(ty::ReScope(region::Scope {\n+            id: expr.hir_id.local_id,\n+            data: region::ScopeData::Node,\n+        }));\n         for adjustment in adjustments {\n-            debug!(\"constrain_adjustments: adjustment={:?}, cmt={:?}\",\n-                   adjustment, cmt);\n+            debug!(\n+                \"constrain_adjustments: adjustment={:?}, cmt={:?}\",\n+                adjustment, cmt\n+            );\n \n             if let adjustment::Adjust::Deref(Some(deref)) = adjustment.kind {\n                 debug!(\"constrain_adjustments: overloaded deref: {:?}\", deref);\n \n                 // Treat overloaded autoderefs as if an AutoBorrow adjustment\n                 // was applied on the base type, as that is always the case.\n-                let input = self.tcx.mk_ref(deref.region, ty::TypeAndMut {\n-                    ty: cmt.ty,\n-                    mutbl: deref.mutbl,\n-                });\n-                let output = self.tcx.mk_ref(deref.region, ty::TypeAndMut {\n-                    ty: adjustment.target,\n-                    mutbl: deref.mutbl,\n-                });\n-\n-                self.link_region(expr.span, deref.region,\n-                                 ty::BorrowKind::from_mutbl(deref.mutbl), &cmt);\n+                let input = self.tcx.mk_ref(\n+                    deref.region,\n+                    ty::TypeAndMut {\n+                        ty: cmt.ty,\n+                        mutbl: deref.mutbl,\n+                    },\n+                );\n+                let output = self.tcx.mk_ref(\n+                    deref.region,\n+                    ty::TypeAndMut {\n+                        ty: adjustment.target,\n+                        mutbl: deref.mutbl,\n+                    },\n+                );\n+\n+                self.link_region(\n+                    expr.span,\n+                    deref.region,\n+                    ty::BorrowKind::from_mutbl(deref.mutbl),\n+                    &cmt,\n+                );\n \n                 // Specialized version of constrain_call.\n-                self.type_must_outlive(infer::CallRcvr(expr.span),\n-                                       input, expr_region);\n-                self.type_must_outlive(infer::CallReturn(expr.span),\n-                                       output, expr_region);\n+                self.type_must_outlive(infer::CallRcvr(expr.span), input, expr_region);\n+                self.type_must_outlive(infer::CallReturn(expr.span), output, expr_region);\n             }\n \n             if let adjustment::Adjust::Borrow(ref autoref) = adjustment.kind {\n@@ -872,73 +916,84 @@ impl<'a, 'gcx, 'tcx> RegionCtxt<'a, 'gcx, 'tcx> {\n                 // the current node.\n                 //\n                 // FIXME(#6268) remove to support nested method calls\n-                self.type_of_node_must_outlive(infer::AutoBorrow(expr.span),\n-                                               expr.hir_id,\n-                                               expr_region);\n+                self.type_of_node_must_outlive(\n+                    infer::AutoBorrow(expr.span),\n+                    expr.hir_id,\n+                    expr_region,\n+                );\n             }\n \n             cmt = self.with_mc(|mc| mc.cat_expr_adjusted(expr, cmt, &adjustment))?;\n \n             if let Categorization::Deref(_, mc::BorrowedPtr(_, r_ptr)) = cmt.cat {\n-                self.mk_subregion_due_to_dereference(expr.span,\n-                                                     expr_region, r_ptr);\n+                self.mk_subregion_due_to_dereference(expr.span, expr_region, r_ptr);\n             }\n         }\n \n         Ok(cmt)\n     }\n \n-    pub fn mk_subregion_due_to_dereference(&mut self,\n-                                           deref_span: Span,\n-                                           minimum_lifetime: ty::Region<'tcx>,\n-                                           maximum_lifetime: ty::Region<'tcx>) {\n-        self.sub_regions(infer::DerefPointer(deref_span),\n-                         minimum_lifetime, maximum_lifetime)\n+    pub fn mk_subregion_due_to_dereference(\n+        &mut self,\n+        deref_span: Span,\n+        minimum_lifetime: ty::Region<'tcx>,\n+        maximum_lifetime: ty::Region<'tcx>,\n+    ) {\n+        self.sub_regions(\n+            infer::DerefPointer(deref_span),\n+            minimum_lifetime,\n+            maximum_lifetime,\n+        )\n     }\n \n-    fn check_safety_of_rvalue_destructor_if_necessary(&mut self,\n-                                                     cmt: &mc::cmt_<'tcx>,\n-                                                     span: Span) {\n+    fn check_safety_of_rvalue_destructor_if_necessary(&mut self, cmt: &mc::cmt_<'tcx>, span: Span) {\n         match cmt.cat {\n-            Categorization::Rvalue(region) => {\n-                match *region {\n-                    ty::ReScope(rvalue_scope) => {\n-                        let typ = self.resolve_type(cmt.ty);\n-                        let body_id = self.body_id;\n-                        let _ = dropck::check_safety_of_destructor_if_necessary(\n-                            self, typ, span, body_id, rvalue_scope);\n-                    }\n-                    ty::ReStatic => {}\n-                    _ => {\n-                        span_bug!(span,\n-                                  \"unexpected rvalue region in rvalue \\\n-                                   destructor safety checking: `{:?}`\",\n-                                  region);\n-                    }\n+            Categorization::Rvalue(region) => match *region {\n+                ty::ReScope(rvalue_scope) => {\n+                    let typ = self.resolve_type(cmt.ty);\n+                    let body_id = self.body_id;\n+                    let _ = dropck::check_safety_of_destructor_if_necessary(\n+                        self,\n+                        typ,\n+                        span,\n+                        body_id,\n+                        rvalue_scope,\n+                    );\n                 }\n-            }\n+                ty::ReStatic => {}\n+                _ => {\n+                    span_bug!(\n+                        span,\n+                        \"unexpected rvalue region in rvalue \\\n+                         destructor safety checking: `{:?}`\",\n+                        region\n+                    );\n+                }\n+            },\n             _ => {}\n         }\n     }\n \n     /// Invoked on any index expression that occurs. Checks that if this is a slice\n     /// being indexed, the lifetime of the pointer includes the deref expr.\n-    fn constrain_index(&mut self,\n-                       index_expr: &hir::Expr,\n-                       indexed_ty: Ty<'tcx>)\n-    {\n-        debug!(\"constrain_index(index_expr=?, indexed_ty={}\",\n-               self.ty_to_string(indexed_ty));\n+    fn constrain_index(&mut self, index_expr: &hir::Expr, indexed_ty: Ty<'tcx>) {\n+        debug!(\n+            \"constrain_index(index_expr=?, indexed_ty={}\",\n+            self.ty_to_string(indexed_ty)\n+        );\n \n         let r_index_expr = ty::ReScope(region::Scope {\n             id: index_expr.hir_id.local_id,\n-            data: region::ScopeData::Node\n+            data: region::ScopeData::Node,\n         });\n         if let ty::Ref(r_ptr, r_ty, _) = indexed_ty.sty {\n             match r_ty.sty {\n                 ty::Slice(_) | ty::Str => {\n-                    self.sub_regions(infer::IndexSlice(index_expr.span),\n-                                     self.tcx.mk_region(r_index_expr), r_ptr);\n+                    self.sub_regions(\n+                        infer::IndexSlice(index_expr.span),\n+                        self.tcx.mk_region(r_index_expr),\n+                        r_ptr,\n+                    );\n                 }\n                 _ => {}\n             }\n@@ -947,27 +1002,29 @@ impl<'a, 'gcx, 'tcx> RegionCtxt<'a, 'gcx, 'tcx> {\n \n     /// Guarantees that any lifetimes which appear in the type of the node `id` (after applying\n     /// adjustments) are valid for at least `minimum_lifetime`\n-    fn type_of_node_must_outlive(&mut self,\n+    fn type_of_node_must_outlive(\n+        &mut self,\n         origin: infer::SubregionOrigin<'tcx>,\n         hir_id: hir::HirId,\n-        minimum_lifetime: ty::Region<'tcx>)\n-    {\n+        minimum_lifetime: ty::Region<'tcx>,\n+    ) {\n         // Try to resolve the type.  If we encounter an error, then typeck\n         // is going to fail anyway, so just stop here and let typeck\n         // report errors later on in the writeback phase.\n         let ty0 = self.resolve_node_type(hir_id);\n \n         let ty = self.tables\n-                     .borrow()\n-                     .adjustments()\n-                     .get(hir_id)\n-                     .and_then(|adj| adj.last())\n-                     .map_or(ty0, |adj| adj.target);\n+            .borrow()\n+            .adjustments()\n+            .get(hir_id)\n+            .and_then(|adj| adj.last())\n+            .map_or(ty0, |adj| adj.target);\n         let ty = self.resolve_type(ty);\n-        debug!(\"constrain_regions_in_type_of_node(\\\n-                ty={}, ty0={}, id={:?}, minimum_lifetime={:?})\",\n-                ty,  ty0,\n-                hir_id, minimum_lifetime);\n+        debug!(\n+            \"constrain_regions_in_type_of_node(\\\n+             ty={}, ty0={}, id={:?}, minimum_lifetime={:?})\",\n+            ty, ty0, hir_id, minimum_lifetime\n+        );\n         self.type_must_outlive(origin, ty, minimum_lifetime);\n     }\n \n@@ -979,23 +1036,25 @@ impl<'a, 'gcx, 'tcx> RegionCtxt<'a, 'gcx, 'tcx> {\n     /// - `origin`, the reason we need this constraint\n     /// - `ty`, the type `T`\n     /// - `region`, the region `'a`\n-    pub fn type_must_outlive(&self,\n-                             origin: infer::SubregionOrigin<'tcx>,\n-                             ty: Ty<'tcx>,\n-                             region: ty::Region<'tcx>)\n-    {\n-        self.infcx.type_must_outlive(self.outlives_environment.region_bound_pairs(),\n-                                     self.implicit_region_bound,\n-                                     self.param_env,\n-                                     origin,\n-                                     ty,\n-                                     region);\n+    pub fn type_must_outlive(\n+        &self,\n+        origin: infer::SubregionOrigin<'tcx>,\n+        ty: Ty<'tcx>,\n+        region: ty::Region<'tcx>,\n+    ) {\n+        self.infcx.register_region_obligation(\n+            self.body_id,\n+            RegionObligation {\n+                sub_region: region,\n+                sup_type: ty,\n+                origin,\n+            },\n+        );\n     }\n \n     /// Computes the guarantor for an expression `&base` and then ensures that the lifetime of the\n     /// resulting pointer is linked to the lifetime of its guarantor (if any).\n-    fn link_addr_of(&mut self, expr: &hir::Expr,\n-                    mutability: hir::Mutability, base: &hir::Expr) {\n+    fn link_addr_of(&mut self, expr: &hir::Expr, mutability: hir::Mutability, base: &hir::Expr) {\n         debug!(\"link_addr_of(expr={:?}, base={:?})\", expr, base);\n \n         let cmt = ignore_err!(self.with_mc(|mc| mc.cat_expr(base)));\n@@ -1011,7 +1070,9 @@ impl<'a, 'gcx, 'tcx> RegionCtxt<'a, 'gcx, 'tcx> {\n     fn link_local(&self, local: &hir::Local) {\n         debug!(\"regionck::for_local()\");\n         let init_expr = match local.init {\n-            None => { return; }\n+            None => {\n+                return;\n+            }\n             Some(ref expr) => &**expr,\n         };\n         let discr_cmt = Rc::new(ignore_err!(self.with_mc(|mc| mc.cat_expr(init_expr))));\n@@ -1043,32 +1104,36 @@ impl<'a, 'gcx, 'tcx> RegionCtxt<'a, 'gcx, 'tcx> {\n             let arg_cmt = self.with_mc(|mc| {\n                 Rc::new(mc.cat_rvalue(arg.hir_id, arg.pat.span, re_scope, arg_ty))\n             });\n-            debug!(\"arg_ty={:?} arg_cmt={:?} arg={:?}\",\n-                   arg_ty,\n-                   arg_cmt,\n-                   arg);\n+            debug!(\"arg_ty={:?} arg_cmt={:?} arg={:?}\", arg_ty, arg_cmt, arg);\n             self.link_pattern(arg_cmt, &arg.pat);\n         }\n     }\n \n     /// Link lifetimes of any ref bindings in `root_pat` to the pointers found\n     /// in the discriminant, if needed.\n     fn link_pattern(&self, discr_cmt: mc::cmt<'tcx>, root_pat: &hir::Pat) {\n-        debug!(\"link_pattern(discr_cmt={:?}, root_pat={:?})\",\n-               discr_cmt,\n-               root_pat);\n+        debug!(\n+            \"link_pattern(discr_cmt={:?}, root_pat={:?})\",\n+            discr_cmt, root_pat\n+        );\n         ignore_err!(self.with_mc(|mc| {\n             mc.cat_pattern(discr_cmt, root_pat, |sub_cmt, sub_pat| {\n                 match sub_pat.node {\n                     // `ref x` pattern\n                     PatKind::Binding(..) => {\n                         if let Some(&bm) = mc.tables.pat_binding_modes().get(sub_pat.hir_id) {\n                             if let ty::BindByReference(mutbl) = bm {\n-                                self.link_region_from_node_type(sub_pat.span, sub_pat.hir_id,\n-                                                                mutbl, &sub_cmt);\n+                                self.link_region_from_node_type(\n+                                    sub_pat.span,\n+                                    sub_pat.hir_id,\n+                                    mutbl,\n+                                    &sub_cmt,\n+                                );\n                             }\n                         } else {\n-                            self.tcx.sess.delay_span_bug(sub_pat.span, \"missing binding mode\");\n+                            self.tcx\n+                                .sess\n+                                .delay_span_bug(sub_pat.span, \"missing binding mode\");\n                         }\n                     }\n                     _ => {}\n@@ -1079,12 +1144,16 @@ impl<'a, 'gcx, 'tcx> RegionCtxt<'a, 'gcx, 'tcx> {\n \n     /// Link lifetime of borrowed pointer resulting from autoref to lifetimes in the value being\n     /// autoref'd.\n-    fn link_autoref(&self,\n-                    expr: &hir::Expr,\n-                    expr_cmt: &mc::cmt_<'tcx>,\n-                    autoref: &adjustment::AutoBorrow<'tcx>)\n-    {\n-        debug!(\"link_autoref(autoref={:?}, expr_cmt={:?})\", autoref, expr_cmt);\n+    fn link_autoref(\n+        &self,\n+        expr: &hir::Expr,\n+        expr_cmt: &mc::cmt_<'tcx>,\n+        autoref: &adjustment::AutoBorrow<'tcx>,\n+    ) {\n+        debug!(\n+            \"link_autoref(autoref={:?}, expr_cmt={:?})\",\n+            autoref, expr_cmt\n+        );\n \n         match *autoref {\n             adjustment::AutoBorrow::Ref(r, m) => {\n@@ -1094,7 +1163,7 @@ impl<'a, 'gcx, 'tcx> RegionCtxt<'a, 'gcx, 'tcx> {\n             adjustment::AutoBorrow::RawPtr(m) => {\n                 let r = self.tcx.mk_region(ty::ReScope(region::Scope {\n                     id: expr.hir_id.local_id,\n-                    data: region::ScopeData::Node\n+                    data: region::ScopeData::Node,\n                 }));\n                 self.link_region(expr.span, r, ty::BorrowKind::from_mutbl(m), expr_cmt);\n             }\n@@ -1103,17 +1172,21 @@ impl<'a, 'gcx, 'tcx> RegionCtxt<'a, 'gcx, 'tcx> {\n \n     /// Like `link_region()`, except that the region is extracted from the type of `id`,\n     /// which must be some reference (`&T`, `&str`, etc).\n-    fn link_region_from_node_type(&self,\n-                                  span: Span,\n-                                  id: hir::HirId,\n-                                  mutbl: hir::Mutability,\n-                                  cmt_borrowed: &mc::cmt_<'tcx>) {\n-        debug!(\"link_region_from_node_type(id={:?}, mutbl={:?}, cmt_borrowed={:?})\",\n-               id, mutbl, cmt_borrowed);\n+    fn link_region_from_node_type(\n+        &self,\n+        span: Span,\n+        id: hir::HirId,\n+        mutbl: hir::Mutability,\n+        cmt_borrowed: &mc::cmt_<'tcx>,\n+    ) {\n+        debug!(\n+            \"link_region_from_node_type(id={:?}, mutbl={:?}, cmt_borrowed={:?})\",\n+            id, mutbl, cmt_borrowed\n+        );\n \n         let rptr_ty = self.resolve_node_type(id);\n         if let ty::Ref(r, _, _) = rptr_ty.sty {\n-            debug!(\"rptr_ty={}\",  rptr_ty);\n+            debug!(\"rptr_ty={}\", rptr_ty);\n             self.link_region(span, r, ty::BorrowKind::from_mutbl(mutbl), cmt_borrowed);\n         }\n     }\n@@ -1122,28 +1195,35 @@ impl<'a, 'gcx, 'tcx> RegionCtxt<'a, 'gcx, 'tcx> {\n     /// kind `borrow_kind` and lifetime `borrow_region`.\n     /// In order to ensure borrowck is satisfied, this may create constraints\n     /// between regions, as explained in `link_reborrowed_region()`.\n-    fn link_region(&self,\n-                   span: Span,\n-                   borrow_region: ty::Region<'tcx>,\n-                   borrow_kind: ty::BorrowKind,\n-                   borrow_cmt: &mc::cmt_<'tcx>) {\n+    fn link_region(\n+        &self,\n+        span: Span,\n+        borrow_region: ty::Region<'tcx>,\n+        borrow_kind: ty::BorrowKind,\n+        borrow_cmt: &mc::cmt_<'tcx>,\n+    ) {\n         let origin = infer::DataBorrowed(borrow_cmt.ty, span);\n         self.type_must_outlive(origin, borrow_cmt.ty, borrow_region);\n \n         let mut borrow_kind = borrow_kind;\n         let mut borrow_cmt_cat = borrow_cmt.cat.clone();\n \n         loop {\n-            debug!(\"link_region(borrow_region={:?}, borrow_kind={:?}, borrow_cmt={:?})\",\n-                   borrow_region,\n-                   borrow_kind,\n-                   borrow_cmt);\n+            debug!(\n+                \"link_region(borrow_region={:?}, borrow_kind={:?}, borrow_cmt={:?})\",\n+                borrow_region, borrow_kind, borrow_cmt\n+            );\n             match borrow_cmt_cat {\n                 Categorization::Deref(ref_cmt, mc::BorrowedPtr(ref_kind, ref_region)) => {\n-                    match self.link_reborrowed_region(span,\n-                                                      borrow_region, borrow_kind,\n-                                                      ref_cmt, ref_region, ref_kind,\n-                                                      borrow_cmt.note) {\n+                    match self.link_reborrowed_region(\n+                        span,\n+                        borrow_region,\n+                        borrow_kind,\n+                        ref_cmt,\n+                        ref_region,\n+                        ref_kind,\n+                        borrow_cmt.note,\n+                    ) {\n                         Some((c, k)) => {\n                             borrow_cmt_cat = c.cat.clone();\n                             borrow_kind = k;\n@@ -1154,20 +1234,20 @@ impl<'a, 'gcx, 'tcx> RegionCtxt<'a, 'gcx, 'tcx> {\n                     }\n                 }\n \n-                Categorization::Downcast(cmt_base, _) |\n-                Categorization::Deref(cmt_base, mc::Unique) |\n-                Categorization::Interior(cmt_base, _) => {\n+                Categorization::Downcast(cmt_base, _)\n+                | Categorization::Deref(cmt_base, mc::Unique)\n+                | Categorization::Interior(cmt_base, _) => {\n                     // Borrowing interior or owned data requires the base\n                     // to be valid and borrowable in the same fashion.\n                     borrow_cmt_cat = cmt_base.cat.clone();\n                     borrow_kind = borrow_kind;\n                 }\n \n-                Categorization::Deref(_, mc::UnsafePtr(..)) |\n-                Categorization::StaticItem |\n-                Categorization::Upvar(..) |\n-                Categorization::Local(..) |\n-                Categorization::Rvalue(..) => {\n+                Categorization::Deref(_, mc::UnsafePtr(..))\n+                | Categorization::StaticItem\n+                | Categorization::Upvar(..)\n+                | Categorization::Local(..)\n+                | Categorization::Rvalue(..) => {\n                     // These are all \"base cases\" with independent lifetimes\n                     // that are not subject to inference\n                     return;\n@@ -1218,16 +1298,16 @@ impl<'a, 'gcx, 'tcx> RegionCtxt<'a, 'gcx, 'tcx> {\n     ///\n     /// The return value of this function indicates whether we need to\n     /// recurse and process `ref_cmt` (see case 2 above).\n-    fn link_reborrowed_region(&self,\n-                              span: Span,\n-                              borrow_region: ty::Region<'tcx>,\n-                              borrow_kind: ty::BorrowKind,\n-                              ref_cmt: mc::cmt<'tcx>,\n-                              ref_region: ty::Region<'tcx>,\n-                              mut ref_kind: ty::BorrowKind,\n-                              note: mc::Note)\n-                              -> Option<(mc::cmt<'tcx>, ty::BorrowKind)>\n-    {\n+    fn link_reborrowed_region(\n+        &self,\n+        span: Span,\n+        borrow_region: ty::Region<'tcx>,\n+        borrow_kind: ty::BorrowKind,\n+        ref_cmt: mc::cmt<'tcx>,\n+        ref_region: ty::Region<'tcx>,\n+        mut ref_kind: ty::BorrowKind,\n+        note: mc::Note,\n+    ) -> Option<(mc::cmt<'tcx>, ty::BorrowKind)> {\n         // Possible upvar ID we may need later to create an entry in the\n         // maybe link map.\n \n@@ -1243,7 +1323,7 @@ impl<'a, 'gcx, 'tcx> RegionCtxt<'a, 'gcx, 'tcx> {\n                         infer::ReborrowUpvar(span, *upvar_id)\n                     }\n                     _ => {\n-                        span_bug!( span, \"Illegal upvar id: {:?}\", upvar_id);\n+                        span_bug!(span, \"Illegal upvar id: {:?}\", upvar_id);\n                     }\n                 }\n             }\n@@ -1253,14 +1333,13 @@ impl<'a, 'gcx, 'tcx> RegionCtxt<'a, 'gcx, 'tcx> {\n                 // link\n                 infer::ReborrowUpvar(span, *upvar_id)\n             }\n-            _ => {\n-                infer::Reborrow(span)\n-            }\n+            _ => infer::Reborrow(span),\n         };\n \n-        debug!(\"link_reborrowed_region: {:?} <= {:?}\",\n-               borrow_region,\n-               ref_region);\n+        debug!(\n+            \"link_reborrowed_region: {:?} <= {:?}\",\n+            borrow_region, ref_region\n+        );\n         self.sub_regions(cause, borrow_region, ref_region);\n \n         // If we end up needing to recurse and establish a region link\n@@ -1272,10 +1351,8 @@ impl<'a, 'gcx, 'tcx> RegionCtxt<'a, 'gcx, 'tcx> {\n         // borrowck requires a unique path to the `&mut` reference but not\n         // necessarily a *mutable* path.\n         let new_borrow_kind = match borrow_kind {\n-            ty::ImmBorrow =>\n-                ty::ImmBorrow,\n-            ty::MutBorrow | ty::UniqueImmBorrow =>\n-                ty::UniqueImmBorrow\n+            ty::ImmBorrow => ty::ImmBorrow,\n+            ty::MutBorrow | ty::UniqueImmBorrow => ty::UniqueImmBorrow,\n         };\n \n         // Decide whether we need to recurse and link any regions within\n@@ -1329,16 +1406,20 @@ impl<'a, 'gcx, 'tcx> RegionCtxt<'a, 'gcx, 'tcx> {\n \n     /// Checks that the values provided for type/region arguments in a given\n     /// expression are well-formed and in-scope.\n-    fn substs_wf_in_scope(&mut self,\n-                          origin: infer::ParameterOrigin,\n-                          substs: &Substs<'tcx>,\n-                          expr_span: Span,\n-                          expr_region: ty::Region<'tcx>) {\n-        debug!(\"substs_wf_in_scope(substs={:?}, \\\n-                expr_region={:?}, \\\n-                origin={:?}, \\\n-                expr_span={:?})\",\n-               substs, expr_region, origin, expr_span);\n+    fn substs_wf_in_scope(\n+        &mut self,\n+        origin: infer::ParameterOrigin,\n+        substs: &Substs<'tcx>,\n+        expr_span: Span,\n+        expr_region: ty::Region<'tcx>,\n+    ) {\n+        debug!(\n+            \"substs_wf_in_scope(substs={:?}, \\\n+             expr_region={:?}, \\\n+             origin={:?}, \\\n+             expr_span={:?})\",\n+            substs, expr_region, origin, expr_span\n+        );\n \n         let origin = infer::ParameterInScope(origin, expr_span);\n "}, {"sha": "db08bf80953523d79a0504da27649097877c43d0", "filename": "src/librustc_typeck/coherence/builtin.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c7df1f530b8a88f471e60e933868e7ddf456974d/src%2Flibrustc_typeck%2Fcoherence%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7df1f530b8a88f471e60e933868e7ddf456974d/src%2Flibrustc_typeck%2Fcoherence%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Fbuiltin.rs?ref=c7df1f530b8a88f471e60e933868e7ddf456974d", "patch": "@@ -11,6 +11,7 @@\n //! Check properties that are required by built-in traits and set\n //! up data structures required by type-checking/codegen.\n \n+use rustc::infer::SuppressRegionErrors;\n use rustc::infer::outlives::env::OutlivesEnvironment;\n use rustc::middle::region;\n use rustc::middle::lang_items::UnsizeTraitLangItem;\n@@ -396,6 +397,7 @@ pub fn coerce_unsized_info<'a, 'gcx>(gcx: TyCtxt<'a, 'gcx, 'gcx>,\n             impl_did,\n             &region_scope_tree,\n             &outlives_env,\n+            SuppressRegionErrors::default(),\n         );\n \n         CoerceUnsizedInfo {"}, {"sha": "3406d534896600aac3fc7ddd15e8047e17577c9d", "filename": "src/test/ui/issues/issue-16922.nll.stderr", "status": "removed", "additions": 0, "deletions": 11, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/6846f22a13c7c896e86714736d597128fdfea94d/src%2Ftest%2Fui%2Fissues%2Fissue-16922.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/6846f22a13c7c896e86714736d597128fdfea94d/src%2Ftest%2Fui%2Fissues%2Fissue-16922.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-16922.nll.stderr?ref=6846f22a13c7c896e86714736d597128fdfea94d", "patch": "@@ -1,11 +0,0 @@\n-error[E0621]: explicit lifetime required in the type of `value`\n-  --> $DIR/issue-16922.rs:14:5\n-   |\n-LL | fn foo<T: Any>(value: &T) -> Box<Any> {\n-   |                       -- help: add explicit lifetime `'static` to the type of `value`: `&'static T`\n-LL |     Box::new(value) as Box<Any>\n-   |     ^^^^^^^^^^^^^^^ lifetime `'static` required\n-\n-error: aborting due to previous error\n-\n-For more information about this error, try `rustc --explain E0621`."}, {"sha": "3406d534896600aac3fc7ddd15e8047e17577c9d", "filename": "src/test/ui/issues/issue-16922.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c7df1f530b8a88f471e60e933868e7ddf456974d/src%2Ftest%2Fui%2Fissues%2Fissue-16922.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c7df1f530b8a88f471e60e933868e7ddf456974d/src%2Ftest%2Fui%2Fissues%2Fissue-16922.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-16922.stderr?ref=c7df1f530b8a88f471e60e933868e7ddf456974d", "patch": "@@ -4,7 +4,7 @@ error[E0621]: explicit lifetime required in the type of `value`\n LL | fn foo<T: Any>(value: &T) -> Box<Any> {\n    |                       -- help: add explicit lifetime `'static` to the type of `value`: `&'static T`\n LL |     Box::new(value) as Box<Any>\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^ lifetime `'static` required\n+   |     ^^^^^^^^^^^^^^^ lifetime `'static` required\n \n error: aborting due to previous error\n "}, {"sha": "593cdfdbf711a5a2bb1345216efd20816fa33512", "filename": "src/test/ui/nll/ty-outlives/issue-53789-1.rs", "status": "added", "additions": 91, "deletions": 0, "changes": 91, "blob_url": "https://github.com/rust-lang/rust/blob/c7df1f530b8a88f471e60e933868e7ddf456974d/src%2Ftest%2Fui%2Fnll%2Fty-outlives%2Fissue-53789-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7df1f530b8a88f471e60e933868e7ddf456974d/src%2Ftest%2Fui%2Fnll%2Fty-outlives%2Fissue-53789-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fty-outlives%2Fissue-53789-1.rs?ref=c7df1f530b8a88f471e60e933868e7ddf456974d", "patch": "@@ -0,0 +1,91 @@\n+// Regression test for #53789.\n+//\n+// compile-pass\n+\n+#![feature(nll)]\n+#![allow(unused_variables)]\n+\n+use std::collections::BTreeMap;\n+\n+trait ValueTree {\n+    type Value;\n+}\n+\n+trait Strategy {\n+    type Value: ValueTree;\n+}\n+\n+type StrategyFor<A> = StrategyType<'static, A>;\n+type StrategyType<'a, A> = <A as Arbitrary<'a>>::Strategy;\n+\n+impl<K: ValueTree, V: ValueTree> Strategy for (K, V) {\n+    type Value = TupleValueTree<(K, V)>;\n+}\n+\n+impl<K: ValueTree, V: ValueTree> ValueTree for TupleValueTree<(K, V)> {\n+    type Value = BTreeMapValueTree<K, V>;\n+}\n+\n+struct TupleValueTree<T> {\n+    tree: T,\n+}\n+\n+struct BTreeMapStrategy<K, V>(std::marker::PhantomData<(K, V)>)\n+where\n+    K: Strategy,\n+    V: Strategy;\n+\n+struct BTreeMapValueTree<K, V>(std::marker::PhantomData<(K, V)>)\n+where\n+    K: ValueTree,\n+    V: ValueTree;\n+\n+impl<K, V> Strategy for BTreeMapStrategy<K, V>\n+where\n+    K: Strategy,\n+    V: Strategy,\n+{\n+    type Value = BTreeMapValueTree<K::Value, V::Value>;\n+}\n+\n+impl<K, V> ValueTree for BTreeMapValueTree<K, V>\n+where\n+    K: ValueTree,\n+    V: ValueTree,\n+{\n+    type Value = BTreeMap<K::Value, V::Value>;\n+}\n+\n+trait Arbitrary<'a>: Sized {\n+    fn arbitrary_with(args: Self::Parameters) -> Self::Strategy;\n+    type Parameters;\n+    type Strategy: Strategy<Value = Self::ValueTree>;\n+    type ValueTree: ValueTree<Value = Self>;\n+}\n+\n+impl<'a, A, B> Arbitrary<'a> for BTreeMap<A, B>\n+where\n+    A: Arbitrary<'static>,\n+    B: Arbitrary<'static>,\n+    StrategyFor<A>: 'static,\n+    StrategyFor<B>: 'static,\n+{\n+    type ValueTree = <Self::Strategy as Strategy>::Value;\n+    type Parameters = (A::Parameters, B::Parameters);\n+    type Strategy = BTreeMapStrategy<A::Strategy, B::Strategy>;\n+    fn arbitrary_with(args: Self::Parameters) -> BTreeMapStrategy<A::Strategy, B::Strategy> {\n+        let (a, b) = args;\n+        btree_map(any_with::<A>(a), any_with::<B>(b))\n+    }\n+}\n+\n+fn btree_map<K: Strategy + 'static, V: Strategy>(key: K, value: V) -> BTreeMapStrategy<K, V> {\n+    unimplemented!()\n+}\n+\n+fn any_with<'a, A: Arbitrary<'a>>(args: A::Parameters) -> StrategyType<'a, A> {\n+    unimplemented!()\n+}\n+\n+fn main() { }\n+"}, {"sha": "62e2833aa1b1ab7e58aea24597e0d1b504d3e067", "filename": "src/test/ui/nll/ty-outlives/issue-53789-2.rs", "status": "added", "additions": 251, "deletions": 0, "changes": 251, "blob_url": "https://github.com/rust-lang/rust/blob/c7df1f530b8a88f471e60e933868e7ddf456974d/src%2Ftest%2Fui%2Fnll%2Fty-outlives%2Fissue-53789-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7df1f530b8a88f471e60e933868e7ddf456974d/src%2Ftest%2Fui%2Fnll%2Fty-outlives%2Fissue-53789-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fty-outlives%2Fissue-53789-2.rs?ref=c7df1f530b8a88f471e60e933868e7ddf456974d", "patch": "@@ -0,0 +1,251 @@\n+// Regression test for #53789.\n+//\n+// compile-pass\n+\n+#![feature(nll)]\n+#![allow(unused_variables)]\n+\n+use std::collections::BTreeMap;\n+use std::ops::Range;\n+use std::cmp::Ord;\n+\n+macro_rules! valuetree {\n+    () => {\n+        type ValueTree =\n+            <Self::Strategy as $crate::Strategy>::Value;\n+    };\n+}\n+\n+macro_rules! product_unpack {\n+    ($factor: pat) => {\n+        ($factor,)\n+    };\n+    ($($factor: pat),*) => {\n+        ( $( $factor ),* )\n+    };\n+    ($($factor: pat),*,) => {\n+        ( $( $factor ),* )\n+    };\n+}\n+\n+macro_rules! product_type {\n+    ($factor: ty) => {\n+        ($factor,)\n+    };\n+    ($($factor: ty),*) => {\n+        ( $( $factor, )* )\n+    };\n+    ($($factor: ty),*,) => {\n+        ( $( $factor, )* )\n+    };\n+}\n+\n+macro_rules! default {\n+    ($type: ty, $val: expr) => {\n+        impl Default for $type {\n+            fn default() -> Self { $val.into() }\n+        }\n+    };\n+}\n+\n+// Pervasive internal sugar\n+macro_rules! mapfn {\n+    ($(#[$meta:meta])* [$($vis:tt)*]\n+     fn $name:ident[$($gen:tt)*]($parm:ident: $input:ty) -> $output:ty {\n+         $($body:tt)*\n+     }) => {\n+        $(#[$meta])*\n+            #[derive(Clone, Copy)]\n+        $($vis)* struct $name;\n+        impl $($gen)* statics::MapFn<$input> for $name {\n+            type Output = $output;\n+        }\n+    }\n+}\n+\n+macro_rules! opaque_strategy_wrapper {\n+    ($(#[$smeta:meta])* pub struct $stratname:ident\n+     [$($sgen:tt)*][$($swhere:tt)*]\n+     ($innerstrat:ty) -> $stratvtty:ty;\n+\n+     $(#[$vmeta:meta])* pub struct $vtname:ident\n+     [$($vgen:tt)*][$($vwhere:tt)*]\n+     ($innervt:ty) -> $actualty:ty;\n+    ) => {\n+        $(#[$smeta])* struct $stratname $($sgen)* (std::marker::PhantomData<(K, V)>)\n+            $($swhere)*;\n+\n+        $(#[$vmeta])* struct $vtname $($vgen)* ($innervt) $($vwhere)*;\n+\n+        impl $($sgen)* Strategy for $stratname $($sgen)* $($swhere)* {\n+            type Value = $stratvtty;\n+        }\n+\n+        impl $($vgen)* ValueTree for $vtname $($vgen)* $($vwhere)* {\n+            type Value = $actualty;\n+        }\n+    }\n+}\n+\n+trait ValueTree {\n+    type Value;\n+}\n+\n+trait Strategy {\n+    type Value : ValueTree;\n+}\n+\n+#[derive(Clone)]\n+struct VecStrategy<T : Strategy> {\n+    element: T,\n+    size: Range<usize>,\n+}\n+\n+fn vec<T : Strategy>(element: T, size: Range<usize>)\n+                     -> VecStrategy<T> {\n+    VecStrategy {\n+        element: element,\n+        size: size,\n+    }\n+}\n+\n+type ValueFor<S> = <<S as Strategy>::Value as ValueTree>::Value;\n+\n+trait Arbitrary<'a>: Sized {\n+    fn arbitrary_with(args: Self::Parameters) -> Self::Strategy;\n+\n+    type Parameters: Default;\n+    type Strategy: Strategy<Value = Self::ValueTree>;\n+    type ValueTree: ValueTree<Value = Self>;\n+}\n+\n+type StrategyFor<A> = StrategyType<'static, A>;\n+type StrategyType<'a, A> = <A as Arbitrary<'a>>::Strategy;\n+\n+//#[derive(Clone, PartialEq, Eq, Hash, Debug, From, Into)]\n+struct SizeBounds(Range<usize>);\n+default!(SizeBounds, 0..100);\n+\n+\n+impl From<Range<usize>> for SizeBounds {\n+    fn from(high: Range<usize>) -> Self {\n+        unimplemented!()\n+    }\n+}\n+\n+impl From<SizeBounds> for Range<usize> {\n+    fn from(high: SizeBounds) -> Self {\n+        unimplemented!()\n+    }\n+}\n+\n+\n+fn any_with<'a, A: Arbitrary<'a>>(args: A::Parameters)\n+                                  -> StrategyType<'a, A> {\n+    unimplemented!()\n+}\n+\n+impl<K: ValueTree, V: ValueTree> Strategy for (K, V) where\n+    <K as ValueTree>::Value: Ord {\n+    type Value = TupleValueTree<(K, V)>;\n+}\n+\n+impl<K: ValueTree, V: ValueTree> ValueTree for TupleValueTree<(K, V)> where\n+    <K as ValueTree>::Value: Ord {\n+    type Value = BTreeMapValueTree<K, V>;\n+}\n+\n+#[derive(Clone)]\n+struct VecValueTree<T : ValueTree> {\n+    elements: Vec<T>,\n+}\n+\n+#[derive(Clone, Copy)]\n+struct TupleValueTree<T> {\n+    tree: T,\n+}\n+\n+opaque_strategy_wrapper! {\n+    #[derive(Clone)]\n+    pub struct BTreeMapStrategy[<K, V>]\n+        [where K : Strategy, V : Strategy, ValueFor<K> : Ord](\n+            statics::Filter<statics::Map<VecStrategy<(K,V)>,\n+            VecToBTreeMap>, MinSize>)\n+        -> BTreeMapValueTree<K::Value, V::Value>;\n+\n+    #[derive(Clone)]\n+    pub struct BTreeMapValueTree[<K, V>]\n+        [where K : ValueTree, V : ValueTree, K::Value : Ord](\n+            statics::Filter<statics::Map<VecValueTree<TupleValueTree<(K, V)>>,\n+            VecToBTreeMap>, MinSize>)\n+        -> BTreeMap<K::Value, V::Value>;\n+}\n+\n+type RangedParams2<A, B> = product_type![SizeBounds, A, B];\n+\n+impl<'a, A, B> Arbitrary<'a> for BTreeMap<A, B>\n+where\n+    A: Arbitrary<'static> + Ord,\n+    B: Arbitrary<'static>,\n+StrategyFor<A>: 'static,\n+StrategyFor<B>: 'static,\n+{\n+    valuetree!();\n+    type Parameters = RangedParams2<A::Parameters, B::Parameters>;\n+    type Strategy = BTreeMapStrategy<A::Strategy, B::Strategy>;\n+    fn arbitrary_with(args: Self::Parameters) -> Self::Strategy {\n+        let product_unpack![range, a, b] = args;\n+        btree_map(any_with::<A>(a), any_with::<B>(b), range.into())\n+    }\n+}\n+\n+#[derive(Clone, Copy)]\n+struct MinSize(usize);\n+\n+mapfn! {\n+    [] fn VecToBTreeMap[<K : Ord, V>]\n+        (vec: Vec<(K, V)>) -> BTreeMap<K, V>\n+    {\n+        vec.into_iter().collect()\n+    }\n+}\n+\n+fn btree_map<K : Strategy + 'static, V : Strategy + 'static>\n+    (key: K, value: V, size: Range<usize>)\n+     -> BTreeMapStrategy<K, V>\n+where ValueFor<K> : Ord {\n+    unimplemented!()\n+}\n+\n+mod statics {\n+    pub(super) trait MapFn<T> {\n+        type Output;\n+    }\n+\n+    #[derive(Clone)]\n+    pub struct Filter<S, F> {\n+        source: S,\n+        fun: F,\n+    }\n+\n+    impl<S, F> Filter<S, F> {\n+        pub fn new(source: S, whence: String, filter: F) -> Self {\n+            unimplemented!()\n+        }\n+    }\n+\n+    #[derive(Clone)]\n+    pub struct Map<S, F> {\n+        source: S,\n+        fun: F,\n+    }\n+\n+    impl<S, F> Map<S, F> {\n+        pub fn new(source: S, fun: F) -> Self {\n+            unimplemented!()\n+        }\n+    }\n+}\n+\n+fn main() { }\n+"}, {"sha": "2e105ece8b55cf27fa3738e1054bc9e05794814a", "filename": "src/test/ui/nll/ty-outlives/projection-body.rs", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/c7df1f530b8a88f471e60e933868e7ddf456974d/src%2Ftest%2Fui%2Fnll%2Fty-outlives%2Fprojection-body.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7df1f530b8a88f471e60e933868e7ddf456974d/src%2Ftest%2Fui%2Fnll%2Fty-outlives%2Fprojection-body.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fty-outlives%2Fprojection-body.rs?ref=c7df1f530b8a88f471e60e933868e7ddf456974d", "patch": "@@ -0,0 +1,27 @@\n+// Test that when we infer the lifetime to a subset of the fn body, it\n+// works out.\n+//\n+// compile-pass\n+\n+trait MyTrait<'a> {\n+    type Output;\n+}\n+\n+fn foo1<T>()\n+where\n+    for<'x> T: MyTrait<'x>,\n+{\n+    // Here the region `'c` in `<T as MyTrait<'c>>::Output` will be\n+    // inferred to a subset of the fn body.\n+    let x = bar::<T::Output>();\n+    drop(x);\n+}\n+\n+fn bar<'a, T>() -> &'a ()\n+where\n+    T: 'a,\n+{\n+    &()\n+}\n+\n+fn main() {}"}, {"sha": "6667457e13b15134be9c783a64ca066c436a3aa0", "filename": "src/test/ui/nll/ty-outlives/projection-one-region-closure.rs", "status": "modified", "additions": 2, "deletions": 11, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/c7df1f530b8a88f471e60e933868e7ddf456974d/src%2Ftest%2Fui%2Fnll%2Fty-outlives%2Fprojection-one-region-closure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7df1f530b8a88f471e60e933868e7ddf456974d/src%2Ftest%2Fui%2Fnll%2Fty-outlives%2Fprojection-one-region-closure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fty-outlives%2Fprojection-one-region-closure.rs?ref=c7df1f530b8a88f471e60e933868e7ddf456974d", "patch": "@@ -74,19 +74,10 @@ where\n     T: Anything<'b>,\n     T::AssocType: 'a,\n {\n-    // This error is unfortunate. This code ought to type-check: we\n-    // are projecting `<T as Anything<'b>>::AssocType`, and we know\n-    // that this outlives `'a` because of the where-clause. However,\n-    // the way the region checker works, we don't register this\n-    // outlives obligation, and hence we get an error: this is because\n-    // what we see is a projection like `<T as\n-    // Anything<'?0>>::AssocType`, and we don't yet know if `?0` will\n-    // equal `'b` or not, so we ignore the where-clause. Obviously we\n-    // can do better here with a more involved verification step.\n+    // We are projecting `<T as Anything<'b>>::AssocType`, and we know\n+    // that this outlives `'a` because of the where-clause.\n \n     with_signature(cell, t, |cell, t| require(cell, t));\n-    //~^ ERROR the parameter type `T` may not live long enough\n-    //~| ERROR\n }\n \n #[rustc_regions]"}, {"sha": "455fbba232007482e269fd28cc5ddd66a4fd9f6b", "filename": "src/test/ui/nll/ty-outlives/projection-one-region-closure.stderr", "status": "modified", "additions": 6, "deletions": 26, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/c7df1f530b8a88f471e60e933868e7ddf456974d/src%2Ftest%2Fui%2Fnll%2Fty-outlives%2Fprojection-one-region-closure.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c7df1f530b8a88f471e60e933868e7ddf456974d/src%2Ftest%2Fui%2Fnll%2Fty-outlives%2Fprojection-one-region-closure.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fty-outlives%2Fprojection-one-region-closure.stderr?ref=c7df1f530b8a88f471e60e933868e7ddf456974d", "patch": "@@ -106,7 +106,7 @@ LL |     with_signature(cell, t, |cell, t| require(cell, t));\n    |                             ^^^^^^^^^^^^^^^^^^^^^^^^^^ closure body requires that `'b` must outlive `'a`\n \n note: External requirements\n-  --> $DIR/projection-one-region-closure.rs:87:29\n+  --> $DIR/projection-one-region-closure.rs:80:29\n    |\n LL |     with_signature(cell, t, |cell, t| require(cell, t));\n    |                             ^^^^^^^^^^^^^^^^^^^^^^^^^^\n@@ -119,8 +119,7 @@ LL |     with_signature(cell, t, |cell, t| require(cell, t));\n                extern \"rust-call\" fn((std::cell::Cell<&'_#3r ()>, T))\n            ]\n    = note: number of external vids: 4\n-   = note: where T: '_#3r\n-   = note: where '_#2r: '_#3r\n+   = note: where <T as Anything<ReClosureBound('_#2r)>>::AssocType: '_#3r\n \n note: No external requirements\n   --> $DIR/projection-one-region-closure.rs:72:1\n@@ -130,7 +129,7 @@ LL | | where\n LL | |     T: Anything<'b>,\n LL | |     T::AssocType: 'a,\n ...  |\n-LL | |     //~| ERROR\n+LL | |     with_signature(cell, t, |cell, t| require(cell, t));\n LL | | }\n    | |_^\n    |\n@@ -140,27 +139,8 @@ LL | | }\n                T\n            ]\n \n-error[E0309]: the parameter type `T` may not live long enough\n-  --> $DIR/projection-one-region-closure.rs:87:29\n-   |\n-LL |     with_signature(cell, t, |cell, t| require(cell, t));\n-   |                             ^^^^^^^^^^^^^^^^^^^^^^^^^^\n-   |\n-   = help: consider adding an explicit lifetime bound `T: ReEarlyBound(0, 'a)`...\n-\n-error: unsatisfied lifetime constraints\n-  --> $DIR/projection-one-region-closure.rs:87:29\n-   |\n-LL | fn projection_outlives<'a, 'b, T>(cell: Cell<&'a ()>, t: T)\n-   |                        --  -- lifetime `'b` defined here\n-   |                        |\n-   |                        lifetime `'a` defined here\n-...\n-LL |     with_signature(cell, t, |cell, t| require(cell, t));\n-   |                             ^^^^^^^^^^^^^^^^^^^^^^^^^^ closure body requires that `'b` must outlive `'a`\n-\n note: External requirements\n-  --> $DIR/projection-one-region-closure.rs:99:29\n+  --> $DIR/projection-one-region-closure.rs:90:29\n    |\n LL |     with_signature(cell, t, |cell, t| require(cell, t));\n    |                             ^^^^^^^^^^^^^^^^^^^^^^^^^^\n@@ -177,7 +157,7 @@ LL |     with_signature(cell, t, |cell, t| require(cell, t));\n    = note: where '_#2r: '_#3r\n \n note: No external requirements\n-  --> $DIR/projection-one-region-closure.rs:93:1\n+  --> $DIR/projection-one-region-closure.rs:84:1\n    |\n LL | / fn elements_outlive<'a, 'b, T>(cell: Cell<&'a ()>, t: T)\n LL | | where\n@@ -194,6 +174,6 @@ LL | | }\n                T\n            ]\n \n-error: aborting due to 6 previous errors\n+error: aborting due to 4 previous errors\n \n For more information about this error, try `rustc --explain E0309`."}, {"sha": "a94d8239fbec0471eb5c02bc5a1f1d07ace05be2", "filename": "src/test/ui/nll/ty-outlives/projection-one-region-trait-bound-closure.rs", "status": "modified", "additions": 2, "deletions": 10, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/c7df1f530b8a88f471e60e933868e7ddf456974d/src%2Ftest%2Fui%2Fnll%2Fty-outlives%2Fprojection-one-region-trait-bound-closure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7df1f530b8a88f471e60e933868e7ddf456974d/src%2Ftest%2Fui%2Fnll%2Fty-outlives%2Fprojection-one-region-trait-bound-closure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fty-outlives%2Fprojection-one-region-trait-bound-closure.rs?ref=c7df1f530b8a88f471e60e933868e7ddf456974d", "patch": "@@ -64,18 +64,10 @@ where\n     T: Anything<'b>,\n     T::AssocType: 'a,\n {\n-    // This error is unfortunate. This code ought to type-check: we\n-    // are projecting `<T as Anything<'b>>::AssocType`, and we know\n-    // that this outlives `'a` because of the where-clause. However,\n-    // the way the region checker works, we don't register this\n-    // outlives obligation, and hence we get an error: this is because\n-    // what we see is a projection like `<T as\n-    // Anything<'?0>>::AssocType`, and we don't yet know if `?0` will\n-    // equal `'b` or not, so we ignore the where-clause. Obviously we\n-    // can do better here with a more involved verification step.\n+    // We are projecting `<T as Anything<'b>>::AssocType`, and we know\n+    // that this outlives `'a` because of the where-clause.\n \n     with_signature(cell, t, |cell, t| require(cell, t));\n-    //~^ ERROR\n }\n \n #[rustc_regions]"}, {"sha": "b98aca74058b97d1c915449551e3bafa764eb2dd", "filename": "src/test/ui/nll/ty-outlives/projection-one-region-trait-bound-closure.stderr", "status": "modified", "additions": 8, "deletions": 19, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/c7df1f530b8a88f471e60e933868e7ddf456974d/src%2Ftest%2Fui%2Fnll%2Fty-outlives%2Fprojection-one-region-trait-bound-closure.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c7df1f530b8a88f471e60e933868e7ddf456974d/src%2Ftest%2Fui%2Fnll%2Fty-outlives%2Fprojection-one-region-trait-bound-closure.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fty-outlives%2Fprojection-one-region-trait-bound-closure.stderr?ref=c7df1f530b8a88f471e60e933868e7ddf456974d", "patch": "@@ -88,7 +88,7 @@ LL |     with_signature(cell, t, |cell, t| require(cell, t));\n    |                             ^^^^^^^^^^^^^^^^^^^^^^^^^^ closure body requires that `'b` must outlive `'a`\n \n note: External requirements\n-  --> $DIR/projection-one-region-trait-bound-closure.rs:77:29\n+  --> $DIR/projection-one-region-trait-bound-closure.rs:70:29\n    |\n LL |     with_signature(cell, t, |cell, t| require(cell, t));\n    |                             ^^^^^^^^^^^^^^^^^^^^^^^^^^\n@@ -101,7 +101,7 @@ LL |     with_signature(cell, t, |cell, t| require(cell, t));\n                extern \"rust-call\" fn((std::cell::Cell<&'_#3r ()>, T))\n            ]\n    = note: number of external vids: 4\n-   = note: where '_#2r: '_#3r\n+   = note: where <T as Anything<ReClosureBound('_#2r)>>::AssocType: '_#3r\n \n note: No external requirements\n   --> $DIR/projection-one-region-trait-bound-closure.rs:62:1\n@@ -111,7 +111,7 @@ LL | | where\n LL | |     T: Anything<'b>,\n LL | |     T::AssocType: 'a,\n ...  |\n-LL | |     //~^ ERROR\n+LL | |     with_signature(cell, t, |cell, t| require(cell, t));\n LL | | }\n    | |_^\n    |\n@@ -121,19 +121,8 @@ LL | | }\n                T\n            ]\n \n-error: unsatisfied lifetime constraints\n-  --> $DIR/projection-one-region-trait-bound-closure.rs:77:29\n-   |\n-LL | fn projection_outlives<'a, 'b, T>(cell: Cell<&'a ()>, t: T)\n-   |                        --  -- lifetime `'b` defined here\n-   |                        |\n-   |                        lifetime `'a` defined here\n-...\n-LL |     with_signature(cell, t, |cell, t| require(cell, t));\n-   |                             ^^^^^^^^^^^^^^^^^^^^^^^^^^ closure body requires that `'b` must outlive `'a`\n-\n note: External requirements\n-  --> $DIR/projection-one-region-trait-bound-closure.rs:87:29\n+  --> $DIR/projection-one-region-trait-bound-closure.rs:79:29\n    |\n LL |     with_signature(cell, t, |cell, t| require(cell, t));\n    |                             ^^^^^^^^^^^^^^^^^^^^^^^^^^\n@@ -149,7 +138,7 @@ LL |     with_signature(cell, t, |cell, t| require(cell, t));\n    = note: where '_#2r: '_#3r\n \n note: No external requirements\n-  --> $DIR/projection-one-region-trait-bound-closure.rs:82:1\n+  --> $DIR/projection-one-region-trait-bound-closure.rs:74:1\n    |\n LL | / fn elements_outlive<'a, 'b, T>(cell: Cell<&'a ()>, t: T)\n LL | | where\n@@ -167,7 +156,7 @@ LL | | }\n            ]\n \n note: External requirements\n-  --> $DIR/projection-one-region-trait-bound-closure.rs:99:29\n+  --> $DIR/projection-one-region-trait-bound-closure.rs:91:29\n    |\n LL |     with_signature(cell, t, |cell, t| require(cell, t));\n    |                             ^^^^^^^^^^^^^^^^^^^^^^^^^^\n@@ -182,7 +171,7 @@ LL |     with_signature(cell, t, |cell, t| require(cell, t));\n    = note: where '_#1r: '_#2r\n \n note: No external requirements\n-  --> $DIR/projection-one-region-trait-bound-closure.rs:91:1\n+  --> $DIR/projection-one-region-trait-bound-closure.rs:83:1\n    |\n LL | / fn one_region<'a, T>(cell: Cell<&'a ()>, t: T)\n LL | | where\n@@ -198,5 +187,5 @@ LL | | }\n                T\n            ]\n \n-error: aborting due to 3 previous errors\n+error: aborting due to 2 previous errors\n "}, {"sha": "95c344e6dffb2f83bddae5bee03077188c176b34", "filename": "src/test/ui/nll/ty-outlives/projection-two-region-trait-bound-closure.rs", "status": "modified", "additions": 2, "deletions": 10, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/c7df1f530b8a88f471e60e933868e7ddf456974d/src%2Ftest%2Fui%2Fnll%2Fty-outlives%2Fprojection-two-region-trait-bound-closure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7df1f530b8a88f471e60e933868e7ddf456974d/src%2Ftest%2Fui%2Fnll%2Fty-outlives%2Fprojection-two-region-trait-bound-closure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fty-outlives%2Fprojection-two-region-trait-bound-closure.rs?ref=c7df1f530b8a88f471e60e933868e7ddf456974d", "patch": "@@ -65,18 +65,10 @@ where\n     T: Anything<'b, 'c>,\n     T::AssocType: 'a,\n {\n-    // This error is unfortunate. This code ought to type-check: we\n-    // are projecting `<T as Anything<'b>>::AssocType`, and we know\n-    // that this outlives `'a` because of the where-clause. However,\n-    // the way the region checker works, we don't register this\n-    // outlives obligation, and hence we get an error: this is because\n-    // what we see is a projection like `<T as\n-    // Anything<'?0>>::AssocType`, and we don't yet know if `?0` will\n-    // equal `'b` or not, so we ignore the where-clause. Obviously we\n-    // can do better here with a more involved verification step.\n+    // We are projecting `<T as Anything<'b>>::AssocType`, and we know\n+    // that this outlives `'a` because of the where-clause.\n \n     with_signature(cell, t, |cell, t| require(cell, t));\n-    //~^ ERROR associated type `<T as Anything<'_#6r, '_#7r>>::AssocType` may not live long enough\n }\n \n #[rustc_regions]"}, {"sha": "f872c87b0bb6986b79109d3b543a241c73af85a6", "filename": "src/test/ui/nll/ty-outlives/projection-two-region-trait-bound-closure.stderr", "status": "modified", "additions": 14, "deletions": 22, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/c7df1f530b8a88f471e60e933868e7ddf456974d/src%2Ftest%2Fui%2Fnll%2Fty-outlives%2Fprojection-two-region-trait-bound-closure.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c7df1f530b8a88f471e60e933868e7ddf456974d/src%2Ftest%2Fui%2Fnll%2Fty-outlives%2Fprojection-two-region-trait-bound-closure.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fty-outlives%2Fprojection-two-region-trait-bound-closure.stderr?ref=c7df1f530b8a88f471e60e933868e7ddf456974d", "patch": "@@ -86,7 +86,7 @@ LL |     with_signature(cell, t, |cell, t| require(cell, t));\n    = help: consider adding an explicit lifetime bound `<T as Anything<'_#6r, '_#7r>>::AssocType: ReEarlyBound(0, 'a)`...\n \n note: External requirements\n-  --> $DIR/projection-two-region-trait-bound-closure.rs:78:29\n+  --> $DIR/projection-two-region-trait-bound-closure.rs:71:29\n    |\n LL |     with_signature(cell, t, |cell, t| require(cell, t));\n    |                             ^^^^^^^^^^^^^^^^^^^^^^^^^^\n@@ -110,7 +110,7 @@ LL | | where\n LL | |     T: Anything<'b, 'c>,\n LL | |     T::AssocType: 'a,\n ...  |\n-LL | |     //~^ ERROR associated type `<T as Anything<'_#6r, '_#7r>>::AssocType` may not live long enough\n+LL | |     with_signature(cell, t, |cell, t| require(cell, t));\n LL | | }\n    | |_^\n    |\n@@ -121,16 +121,8 @@ LL | | }\n                T\n            ]\n \n-error[E0309]: the associated type `<T as Anything<'_#6r, '_#7r>>::AssocType` may not live long enough\n-  --> $DIR/projection-two-region-trait-bound-closure.rs:78:29\n-   |\n-LL |     with_signature(cell, t, |cell, t| require(cell, t));\n-   |                             ^^^^^^^^^^^^^^^^^^^^^^^^^^\n-   |\n-   = help: consider adding an explicit lifetime bound `<T as Anything<'_#6r, '_#7r>>::AssocType: ReEarlyBound(0, 'a)`...\n-\n note: External requirements\n-  --> $DIR/projection-two-region-trait-bound-closure.rs:88:29\n+  --> $DIR/projection-two-region-trait-bound-closure.rs:80:29\n    |\n LL |     with_signature(cell, t, |cell, t| require(cell, t));\n    |                             ^^^^^^^^^^^^^^^^^^^^^^^^^^\n@@ -147,7 +139,7 @@ LL |     with_signature(cell, t, |cell, t| require(cell, t));\n    = note: where <T as Anything<ReClosureBound('_#2r), ReClosureBound('_#3r)>>::AssocType: '_#4r\n \n note: No external requirements\n-  --> $DIR/projection-two-region-trait-bound-closure.rs:83:1\n+  --> $DIR/projection-two-region-trait-bound-closure.rs:75:1\n    |\n LL | / fn elements_outlive1<'a, 'b, 'c, T>(cell: Cell<&'a ()>, t: T)\n LL | | where\n@@ -166,7 +158,7 @@ LL | | }\n            ]\n \n note: External requirements\n-  --> $DIR/projection-two-region-trait-bound-closure.rs:97:29\n+  --> $DIR/projection-two-region-trait-bound-closure.rs:89:29\n    |\n LL |     with_signature(cell, t, |cell, t| require(cell, t));\n    |                             ^^^^^^^^^^^^^^^^^^^^^^^^^^\n@@ -183,7 +175,7 @@ LL |     with_signature(cell, t, |cell, t| require(cell, t));\n    = note: where <T as Anything<ReClosureBound('_#2r), ReClosureBound('_#3r)>>::AssocType: '_#4r\n \n note: No external requirements\n-  --> $DIR/projection-two-region-trait-bound-closure.rs:92:1\n+  --> $DIR/projection-two-region-trait-bound-closure.rs:84:1\n    |\n LL | / fn elements_outlive2<'a, 'b, 'c, T>(cell: Cell<&'a ()>, t: T)\n LL | | where\n@@ -202,7 +194,7 @@ LL | | }\n            ]\n \n note: External requirements\n-  --> $DIR/projection-two-region-trait-bound-closure.rs:105:29\n+  --> $DIR/projection-two-region-trait-bound-closure.rs:97:29\n    |\n LL |     with_signature(cell, t, |cell, t| require(cell, t));\n    |                             ^^^^^^^^^^^^^^^^^^^^^^^^^^\n@@ -218,7 +210,7 @@ LL |     with_signature(cell, t, |cell, t| require(cell, t));\n    = note: where <T as Anything<ReClosureBound('_#1r), ReClosureBound('_#1r)>>::AssocType: '_#2r\n \n note: No external requirements\n-  --> $DIR/projection-two-region-trait-bound-closure.rs:101:1\n+  --> $DIR/projection-two-region-trait-bound-closure.rs:93:1\n    |\n LL | / fn two_regions<'a, 'b, T>(cell: Cell<&'a ()>, t: T)\n LL | | where\n@@ -235,7 +227,7 @@ LL | | }\n            ]\n \n error: unsatisfied lifetime constraints\n-  --> $DIR/projection-two-region-trait-bound-closure.rs:105:29\n+  --> $DIR/projection-two-region-trait-bound-closure.rs:97:29\n    |\n LL | fn two_regions<'a, 'b, T>(cell: Cell<&'a ()>, t: T)\n    |                --  -- lifetime `'b` defined here\n@@ -246,7 +238,7 @@ LL |     with_signature(cell, t, |cell, t| require(cell, t));\n    |                             ^^^^^^^^^^^^^^^^^^^^^^^^^^ closure body requires that `'b` must outlive `'a`\n \n note: External requirements\n-  --> $DIR/projection-two-region-trait-bound-closure.rs:115:29\n+  --> $DIR/projection-two-region-trait-bound-closure.rs:107:29\n    |\n LL |     with_signature(cell, t, |cell, t| require(cell, t));\n    |                             ^^^^^^^^^^^^^^^^^^^^^^^^^^\n@@ -262,7 +254,7 @@ LL |     with_signature(cell, t, |cell, t| require(cell, t));\n    = note: where <T as Anything<ReClosureBound('_#2r), ReClosureBound('_#2r)>>::AssocType: '_#3r\n \n note: No external requirements\n-  --> $DIR/projection-two-region-trait-bound-closure.rs:110:1\n+  --> $DIR/projection-two-region-trait-bound-closure.rs:102:1\n    |\n LL | / fn two_regions_outlive<'a, 'b, T>(cell: Cell<&'a ()>, t: T)\n LL | | where\n@@ -280,7 +272,7 @@ LL | | }\n            ]\n \n note: External requirements\n-  --> $DIR/projection-two-region-trait-bound-closure.rs:127:29\n+  --> $DIR/projection-two-region-trait-bound-closure.rs:119:29\n    |\n LL |     with_signature(cell, t, |cell, t| require(cell, t));\n    |                             ^^^^^^^^^^^^^^^^^^^^^^^^^^\n@@ -295,7 +287,7 @@ LL |     with_signature(cell, t, |cell, t| require(cell, t));\n    = note: where <T as Anything<ReClosureBound('_#1r), ReClosureBound('_#1r)>>::AssocType: '_#2r\n \n note: No external requirements\n-  --> $DIR/projection-two-region-trait-bound-closure.rs:119:1\n+  --> $DIR/projection-two-region-trait-bound-closure.rs:111:1\n    |\n LL | / fn one_region<'a, T>(cell: Cell<&'a ()>, t: T)\n LL | | where\n@@ -311,6 +303,6 @@ LL | | }\n                T\n            ]\n \n-error: aborting due to 4 previous errors\n+error: aborting due to 3 previous errors\n \n For more information about this error, try `rustc --explain E0309`."}, {"sha": "9c2cbfd4a4530ead2f45a365afa8127891e8a9d6", "filename": "src/test/ui/nll/ty-outlives/projection-where-clause-env-wrong-bound.rs", "status": "added", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/c7df1f530b8a88f471e60e933868e7ddf456974d/src%2Ftest%2Fui%2Fnll%2Fty-outlives%2Fprojection-where-clause-env-wrong-bound.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7df1f530b8a88f471e60e933868e7ddf456974d/src%2Ftest%2Fui%2Fnll%2Fty-outlives%2Fprojection-where-clause-env-wrong-bound.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fty-outlives%2Fprojection-where-clause-env-wrong-bound.rs?ref=c7df1f530b8a88f471e60e933868e7ddf456974d", "patch": "@@ -0,0 +1,36 @@\n+#![feature(nll)]\n+\n+// Test that we are able to establish that `<T as\n+// MyTrait<'a>>::Output` outlives `'b` here. We need to prove however\n+// that `<T as MyTrait<'a>>::Output` outlives `'a`, so we also have to\n+// prove that `'b: 'a`.\n+\n+trait MyTrait<'a> {\n+    type Output;\n+}\n+\n+fn foo1<'a, 'b, T>() -> &'a ()\n+where\n+    T: MyTrait<'a>,\n+    <T as MyTrait<'a>>::Output: 'b,\n+{\n+    bar::<T::Output>() //~ ERROR may not live long enough\n+}\n+\n+fn foo2<'a, 'b, T>() -> &'a ()\n+where\n+    T: MyTrait<'a>,\n+    <T as MyTrait<'a>>::Output: 'b,\n+    'b: 'a,\n+{\n+    bar::<T::Output>() // OK\n+}\n+\n+fn bar<'a, T>() -> &'a ()\n+where\n+    T: 'a,\n+{\n+    &()\n+}\n+\n+fn main() {}"}, {"sha": "acb978b5d5a2c955229c0ebf7adb432f70416ab3", "filename": "src/test/ui/nll/ty-outlives/projection-where-clause-env-wrong-bound.stderr", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/c7df1f530b8a88f471e60e933868e7ddf456974d/src%2Ftest%2Fui%2Fnll%2Fty-outlives%2Fprojection-where-clause-env-wrong-bound.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c7df1f530b8a88f471e60e933868e7ddf456974d/src%2Ftest%2Fui%2Fnll%2Fty-outlives%2Fprojection-where-clause-env-wrong-bound.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fty-outlives%2Fprojection-where-clause-env-wrong-bound.stderr?ref=c7df1f530b8a88f471e60e933868e7ddf456974d", "patch": "@@ -0,0 +1,11 @@\n+error[E0309]: the associated type `<T as MyTrait<'_>>::Output` may not live long enough\n+  --> $DIR/projection-where-clause-env-wrong-bound.rs:17:5\n+   |\n+LL |     bar::<T::Output>() //~ ERROR may not live long enough\n+   |     ^^^^^^^^^^^^^^^^^^\n+   |\n+   = help: consider adding an explicit lifetime bound `<T as MyTrait<'_>>::Output: 'a`...\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0309`."}, {"sha": "1e953ecff692301d5a7a8634b5e07f119549933b", "filename": "src/test/ui/nll/ty-outlives/projection-where-clause-env-wrong-lifetime.nll.stderr", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/c7df1f530b8a88f471e60e933868e7ddf456974d/src%2Ftest%2Fui%2Fnll%2Fty-outlives%2Fprojection-where-clause-env-wrong-lifetime.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c7df1f530b8a88f471e60e933868e7ddf456974d/src%2Ftest%2Fui%2Fnll%2Fty-outlives%2Fprojection-where-clause-env-wrong-lifetime.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fty-outlives%2Fprojection-where-clause-env-wrong-lifetime.nll.stderr?ref=c7df1f530b8a88f471e60e933868e7ddf456974d", "patch": "@@ -0,0 +1,11 @@\n+error[E0309]: the associated type `<T as MyTrait<'_>>::Output` may not live long enough\n+  --> $DIR/projection-where-clause-env-wrong-lifetime.rs:14:5\n+   |\n+LL |     bar::<<T as MyTrait<'a>>::Output>()\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = help: consider adding an explicit lifetime bound `<T as MyTrait<'_>>::Output: 'a`...\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0309`."}, {"sha": "9e3590ca7154588a672a88c3a38ea69f1f6986f3", "filename": "src/test/ui/nll/ty-outlives/projection-where-clause-env-wrong-lifetime.rs", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/c7df1f530b8a88f471e60e933868e7ddf456974d/src%2Ftest%2Fui%2Fnll%2Fty-outlives%2Fprojection-where-clause-env-wrong-lifetime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7df1f530b8a88f471e60e933868e7ddf456974d/src%2Ftest%2Fui%2Fnll%2Fty-outlives%2Fprojection-where-clause-env-wrong-lifetime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fty-outlives%2Fprojection-where-clause-env-wrong-lifetime.rs?ref=c7df1f530b8a88f471e60e933868e7ddf456974d", "patch": "@@ -0,0 +1,25 @@\n+// Test that if we need to prove that `<T as MyTrait<'a>>::Output:\n+// 'a`, but we only know that `<T as MyTrait<'b>>::Output: 'a`, that\n+// doesn't suffice.\n+\n+trait MyTrait<'a> {\n+    type Output;\n+}\n+\n+fn foo1<'a, 'b, T>() -> &'a ()\n+where\n+    for<'x> T: MyTrait<'x>,\n+    <T as MyTrait<'b>>::Output: 'a,\n+{\n+    bar::<<T as MyTrait<'a>>::Output>()\n+    //~^ ERROR the associated type `<T as MyTrait<'a>>::Output` may not live long enough\n+}\n+\n+fn bar<'a, T>() -> &'a ()\n+where\n+    T: 'a,\n+{\n+    &()\n+}\n+\n+fn main() {}"}, {"sha": "d6ade2a603e82ad16128c2f620844d4a5c372147", "filename": "src/test/ui/nll/ty-outlives/projection-where-clause-env-wrong-lifetime.stderr", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/c7df1f530b8a88f471e60e933868e7ddf456974d/src%2Ftest%2Fui%2Fnll%2Fty-outlives%2Fprojection-where-clause-env-wrong-lifetime.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c7df1f530b8a88f471e60e933868e7ddf456974d/src%2Ftest%2Fui%2Fnll%2Fty-outlives%2Fprojection-where-clause-env-wrong-lifetime.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fty-outlives%2Fprojection-where-clause-env-wrong-lifetime.stderr?ref=c7df1f530b8a88f471e60e933868e7ddf456974d", "patch": "@@ -0,0 +1,16 @@\n+error[E0309]: the associated type `<T as MyTrait<'a>>::Output` may not live long enough\n+  --> $DIR/projection-where-clause-env-wrong-lifetime.rs:14:5\n+   |\n+LL |     bar::<<T as MyTrait<'a>>::Output>()\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = help: consider adding an explicit lifetime bound `<T as MyTrait<'a>>::Output: 'a`...\n+note: ...so that the type `<T as MyTrait<'a>>::Output` will meet its required lifetime bounds\n+  --> $DIR/projection-where-clause-env-wrong-lifetime.rs:14:5\n+   |\n+LL |     bar::<<T as MyTrait<'a>>::Output>()\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0309`."}, {"sha": "c6935badf54b289dd8f66764568f260b9a17b505", "filename": "src/test/ui/nll/ty-outlives/projection-where-clause-env.rs", "status": "added", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/c7df1f530b8a88f471e60e933868e7ddf456974d/src%2Ftest%2Fui%2Fnll%2Fty-outlives%2Fprojection-where-clause-env.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7df1f530b8a88f471e60e933868e7ddf456974d/src%2Ftest%2Fui%2Fnll%2Fty-outlives%2Fprojection-where-clause-env.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fty-outlives%2Fprojection-where-clause-env.rs?ref=c7df1f530b8a88f471e60e933868e7ddf456974d", "patch": "@@ -0,0 +1,30 @@\n+#![feature(nll)]\n+\n+// Test that when we have a `<T as MyTrait<'a>>::Output: 'a`\n+// relationship in the environment we take advantage of it.  In this\n+// case, that means we **don't** have to prove that `T: 'a`.\n+//\n+// Regression test for #53121.\n+//\n+// compile-pass\n+\n+trait MyTrait<'a> {\n+    type Output;\n+}\n+\n+fn foo<'a, T>() -> &'a ()\n+where\n+    T: MyTrait<'a>,\n+    <T as MyTrait<'a>>::Output: 'a,\n+{\n+    bar::<T::Output>()\n+}\n+\n+fn bar<'a, T>() -> &'a ()\n+where\n+    T: 'a,\n+{\n+    &()\n+}\n+\n+fn main() {}"}, {"sha": "f0f72f5d27f7675d22555be033b3926cd869121e", "filename": "src/test/ui/nll/ty-outlives/projection-where-clause-none.rs", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/c7df1f530b8a88f471e60e933868e7ddf456974d/src%2Ftest%2Fui%2Fnll%2Fty-outlives%2Fprojection-where-clause-none.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7df1f530b8a88f471e60e933868e7ddf456974d/src%2Ftest%2Fui%2Fnll%2Fty-outlives%2Fprojection-where-clause-none.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fty-outlives%2Fprojection-where-clause-none.rs?ref=c7df1f530b8a88f471e60e933868e7ddf456974d", "patch": "@@ -0,0 +1,26 @@\n+#![feature(nll)]\n+\n+// Test that we are NOT able to establish that `<T as\n+// MyTrait<'a>>::Output: 'a` outlives `'a` here -- we have only one\n+// recourse, which is to prove that `T: 'a` and `'a: 'a`, but we don't\n+// know that `T: 'a`.\n+\n+trait MyTrait<'a> {\n+    type Output;\n+}\n+\n+fn foo<'a, T>() -> &'a ()\n+where\n+    T: MyTrait<'a>,\n+{\n+    bar::<T::Output>() //~ ERROR the parameter type `T` may not live long enough\n+}\n+\n+fn bar<'a, T>() -> &'a ()\n+where\n+    T: 'a,\n+{\n+    &()\n+}\n+\n+fn main() {}"}, {"sha": "2d171a98789f8f626a37efde0eb8bc0b787ad263", "filename": "src/test/ui/nll/ty-outlives/projection-where-clause-none.stderr", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/c7df1f530b8a88f471e60e933868e7ddf456974d/src%2Ftest%2Fui%2Fnll%2Fty-outlives%2Fprojection-where-clause-none.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c7df1f530b8a88f471e60e933868e7ddf456974d/src%2Ftest%2Fui%2Fnll%2Fty-outlives%2Fprojection-where-clause-none.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fty-outlives%2Fprojection-where-clause-none.stderr?ref=c7df1f530b8a88f471e60e933868e7ddf456974d", "patch": "@@ -0,0 +1,11 @@\n+error[E0309]: the parameter type `T` may not live long enough\n+  --> $DIR/projection-where-clause-none.rs:16:5\n+   |\n+LL |     bar::<T::Output>() //~ ERROR the parameter type `T` may not live long enough\n+   |     ^^^^^^^^^^^^^^^^^^\n+   |\n+   = help: consider adding an explicit lifetime bound `T: 'a`...\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0309`."}, {"sha": "7c7d64a8cb4d3d379b812c5d107c05ac60fb1148", "filename": "src/test/ui/nll/ty-outlives/projection-where-clause-trait.rs", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/c7df1f530b8a88f471e60e933868e7ddf456974d/src%2Ftest%2Fui%2Fnll%2Fty-outlives%2Fprojection-where-clause-trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7df1f530b8a88f471e60e933868e7ddf456974d/src%2Ftest%2Fui%2Fnll%2Fty-outlives%2Fprojection-where-clause-trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fty-outlives%2Fprojection-where-clause-trait.rs?ref=c7df1f530b8a88f471e60e933868e7ddf456974d", "patch": "@@ -0,0 +1,27 @@\n+#![feature(nll)]\n+\n+// Test that we are able to establish that `<T as\n+// MyTrait<'a>>::Output: 'a` outlives `'a` (because the trait says\n+// so).\n+//\n+// compile-pass\n+\n+trait MyTrait<'a> {\n+    type Output: 'a;\n+}\n+\n+fn foo<'a, T>() -> &'a ()\n+where\n+    T: MyTrait<'a>,\n+{\n+    bar::<T::Output>()\n+}\n+\n+fn bar<'a, T>() -> &'a ()\n+where\n+    T: 'a,\n+{\n+    &()\n+}\n+\n+fn main() {}"}, {"sha": "b8c22583ff8d35314da5506430e407a63bfbef83", "filename": "src/test/ui/object-lifetime/object-lifetime-default-elision.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c7df1f530b8a88f471e60e933868e7ddf456974d/src%2Ftest%2Fui%2Fobject-lifetime%2Fobject-lifetime-default-elision.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c7df1f530b8a88f471e60e933868e7ddf456974d/src%2Ftest%2Fui%2Fobject-lifetime%2Fobject-lifetime-default-elision.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fobject-lifetime%2Fobject-lifetime-default-elision.stderr?ref=c7df1f530b8a88f471e60e933868e7ddf456974d", "patch": "@@ -9,7 +9,7 @@ note: first, the lifetime cannot outlive the lifetime 'a as defined on the funct\n    |\n LL | fn load3<'a,'b>(ss: &'a SomeTrait) -> &'b SomeTrait {\n    |          ^^\n-note: ...so that the type `(dyn SomeTrait + 'a)` is not borrowed for too long\n+note: ...so that reference does not outlive borrowed content\n   --> $DIR/object-lifetime-default-elision.rs:81:5\n    |\n LL |     ss"}, {"sha": "314f43585fedbbe158fc9c42be8ae28847bd6586", "filename": "src/test/ui/regions/region-object-lifetime-2.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c7df1f530b8a88f471e60e933868e7ddf456974d/src%2Ftest%2Fui%2Fregions%2Fregion-object-lifetime-2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c7df1f530b8a88f471e60e933868e7ddf456974d/src%2Ftest%2Fui%2Fregions%2Fregion-object-lifetime-2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fregions%2Fregion-object-lifetime-2.stderr?ref=c7df1f530b8a88f471e60e933868e7ddf456974d", "patch": "@@ -9,7 +9,7 @@ note: first, the lifetime cannot outlive the lifetime 'a as defined on the funct\n    |\n LL | fn borrowed_receiver_different_lifetimes<'a,'b>(x: &'a Foo) -> &'b () {\n    |                                          ^^\n-note: ...so that the type `(dyn Foo + 'a)` is not borrowed for too long\n+note: ...so that reference does not outlive borrowed content\n   --> $DIR/region-object-lifetime-2.rs:20:5\n    |\n LL |     x.borrowed() //~ ERROR cannot infer"}, {"sha": "a281b36946bfda687553b28fba46d7b73b0ee04a", "filename": "src/test/ui/regions/regions-trait-object-subtyping.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c7df1f530b8a88f471e60e933868e7ddf456974d/src%2Ftest%2Fui%2Fregions%2Fregions-trait-object-subtyping.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c7df1f530b8a88f471e60e933868e7ddf456974d/src%2Ftest%2Fui%2Fregions%2Fregions-trait-object-subtyping.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fregions%2Fregions-trait-object-subtyping.stderr?ref=c7df1f530b8a88f471e60e933868e7ddf456974d", "patch": "@@ -26,7 +26,7 @@ note: first, the lifetime cannot outlive the lifetime 'a as defined on the funct\n    |\n LL | fn foo3<'a,'b>(x: &'a mut Dummy) -> &'b mut Dummy {\n    |         ^^\n-note: ...so that the type `(dyn Dummy + 'a)` is not borrowed for too long\n+note: ...so that reference does not outlive borrowed content\n   --> $DIR/regions-trait-object-subtyping.rs:25:5\n    |\n LL |     x //~ ERROR lifetime bound not satisfied"}]}