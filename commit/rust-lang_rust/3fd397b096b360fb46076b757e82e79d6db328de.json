{"sha": "3fd397b096b360fb46076b757e82e79d6db328de", "node_id": "MDY6Q29tbWl0NzI0NzEyOjNmZDM5N2IwOTZiMzYwZmI0NjA3NmI3NTdlODJlNzlkNmRiMzI4ZGU=", "commit": {"author": {"name": "Eduard-Mihai Burtescu", "email": "edy.burt@gmail.com", "date": "2020-03-18T00:48:55Z"}, "committer": {"name": "Eduard-Mihai Burtescu", "email": "edy.burt@gmail.com", "date": "2020-03-21T12:47:33Z"}, "message": "rustc: make {Closure,Generator}Substs::split as cheap as possible.", "tree": {"sha": "76d6feee9863af7b40a9d5dc2f10bb9b5cd16aa9", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/76d6feee9863af7b40a9d5dc2f10bb9b5cd16aa9"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3fd397b096b360fb46076b757e82e79d6db328de", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3fd397b096b360fb46076b757e82e79d6db328de", "html_url": "https://github.com/rust-lang/rust/commit/3fd397b096b360fb46076b757e82e79d6db328de", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3fd397b096b360fb46076b757e82e79d6db328de/comments", "author": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "committer": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "10f08abd2e27785496ddfe92a9e6a4f9cd18443d", "url": "https://api.github.com/repos/rust-lang/rust/commits/10f08abd2e27785496ddfe92a9e6a4f9cd18443d", "html_url": "https://github.com/rust-lang/rust/commit/10f08abd2e27785496ddfe92a9e6a4f9cd18443d"}], "stats": {"total": 98, "additions": 31, "deletions": 67}, "files": [{"sha": "096f63fdf2e6871d145890a18bb2541757234dad", "filename": "src/librustc/ty/sty.rs", "status": "modified", "additions": 31, "deletions": 67, "changes": 98, "blob_url": "https://github.com/rust-lang/rust/blob/3fd397b096b360fb46076b757e82e79d6db328de/src%2Flibrustc%2Fty%2Fsty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3fd397b096b360fb46076b757e82e79d6db328de/src%2Flibrustc%2Fty%2Fsty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fsty.rs?ref=3fd397b096b360fb46076b757e82e79d6db328de", "patch": "@@ -11,7 +11,7 @@ use crate::mir::interpret::ConstValue;\n use crate::mir::interpret::Scalar;\n use crate::mir::Promoted;\n use crate::ty::layout::VariantIdx;\n-use crate::ty::subst::{GenericArgKind, InternalSubsts, Subst, SubstsRef};\n+use crate::ty::subst::{GenericArg, InternalSubsts, Subst, SubstsRef};\n use crate::ty::{\n     self, AdtDef, DefIdTree, Discr, Ty, TyCtxt, TypeFlags, TypeFoldable, WithConstness,\n };\n@@ -364,23 +364,21 @@ pub struct ClosureSubsts<'tcx> {\n /// Struct returned by `split()`. Note that these are subslices of the\n /// parent slice and not canonical substs themselves.\n struct SplitClosureSubsts<'tcx> {\n-    // FIXME(eddyb) maybe replace these with `GenericArg` to avoid having\n-    // `GenericArg::expect_ty` called on all of them when only one is used.\n-    closure_kind_ty: Ty<'tcx>,\n-    closure_sig_as_fn_ptr_ty: Ty<'tcx>,\n-    tupled_upvars_ty: Ty<'tcx>,\n+    closure_kind_ty: GenericArg<'tcx>,\n+    closure_sig_as_fn_ptr_ty: GenericArg<'tcx>,\n+    tupled_upvars_ty: GenericArg<'tcx>,\n }\n \n impl<'tcx> ClosureSubsts<'tcx> {\n     /// Divides the closure substs into their respective\n     /// components. Single source of truth with respect to the\n     /// ordering.\n     fn split(self) -> SplitClosureSubsts<'tcx> {\n-        let parent_len = self.substs.len() - 3;\n-        SplitClosureSubsts {\n-            closure_kind_ty: self.substs.type_at(parent_len),\n-            closure_sig_as_fn_ptr_ty: self.substs.type_at(parent_len + 1),\n-            tupled_upvars_ty: self.substs.type_at(parent_len + 2),\n+        match self.substs[..] {\n+            [.., closure_kind_ty, closure_sig_as_fn_ptr_ty, tupled_upvars_ty] => {\n+                SplitClosureSubsts { closure_kind_ty, closure_sig_as_fn_ptr_ty, tupled_upvars_ty }\n+            }\n+            _ => bug!(\"closure substs missing synthetics\"),\n         }\n     }\n \n@@ -390,29 +388,19 @@ impl<'tcx> ClosureSubsts<'tcx> {\n     /// Used primarily by `ty::print::pretty` to be able to handle closure\n     /// types that haven't had their synthetic types substituted in.\n     pub fn is_valid(self) -> bool {\n-        self.substs.len() >= 3 && matches!(self.split().tupled_upvars_ty.kind, Tuple(_))\n+        self.substs.len() >= 3 && matches!(self.split().tupled_upvars_ty.expect_ty().kind, Tuple(_))\n     }\n \n     #[inline]\n     pub fn upvar_tys(self) -> impl Iterator<Item = Ty<'tcx>> + 'tcx {\n-        let upvars = match self.split().tupled_upvars_ty.kind {\n-            Tuple(upvars) => upvars,\n-            _ => bug!(\"upvars should be tupled\"),\n-        };\n-        upvars.iter().map(|t| {\n-            if let GenericArgKind::Type(ty) = t.unpack() {\n-                ty\n-            } else {\n-                bug!(\"upvar should be type\")\n-            }\n-        })\n+        self.split().tupled_upvars_ty.expect_ty().tuple_fields()\n     }\n \n     /// Returns the closure kind for this closure; may return a type\n     /// variable during inference. To get the closure kind during\n     /// inference, use `infcx.closure_kind(substs)`.\n     pub fn kind_ty(self) -> Ty<'tcx> {\n-        self.split().closure_kind_ty\n+        self.split().closure_kind_ty.expect_ty()\n     }\n \n     /// Returns the `fn` pointer type representing the closure signature for this\n@@ -421,7 +409,7 @@ impl<'tcx> ClosureSubsts<'tcx> {\n     // type is known at the time of the creation of `ClosureSubsts`,\n     // see `rustc_typeck::check::closure`.\n     pub fn sig_as_fn_ptr_ty(self) -> Ty<'tcx> {\n-        self.split().closure_sig_as_fn_ptr_ty\n+        self.split().closure_sig_as_fn_ptr_ty.expect_ty()\n     }\n \n     /// Returns the closure kind for this closure; only usable outside\n@@ -430,7 +418,7 @@ impl<'tcx> ClosureSubsts<'tcx> {\n     ///\n     /// If you have an inference context, use `infcx.closure_kind()`.\n     pub fn kind(self) -> ty::ClosureKind {\n-        self.split().closure_kind_ty.to_opt_closure_kind().unwrap()\n+        self.kind_ty().to_opt_closure_kind().unwrap()\n     }\n \n     /// Extracts the signature from the closure.\n@@ -450,24 +438,20 @@ pub struct GeneratorSubsts<'tcx> {\n }\n \n struct SplitGeneratorSubsts<'tcx> {\n-    // FIXME(eddyb) maybe replace these with `GenericArg` to avoid having\n-    // `GenericArg::expect_ty` called on all of them when only one is used.\n-    resume_ty: Ty<'tcx>,\n-    yield_ty: Ty<'tcx>,\n-    return_ty: Ty<'tcx>,\n-    witness: Ty<'tcx>,\n-    tupled_upvars_ty: Ty<'tcx>,\n+    resume_ty: GenericArg<'tcx>,\n+    yield_ty: GenericArg<'tcx>,\n+    return_ty: GenericArg<'tcx>,\n+    witness: GenericArg<'tcx>,\n+    tupled_upvars_ty: GenericArg<'tcx>,\n }\n \n impl<'tcx> GeneratorSubsts<'tcx> {\n     fn split(self) -> SplitGeneratorSubsts<'tcx> {\n-        let parent_len = self.substs.len() - 5;\n-        SplitGeneratorSubsts {\n-            resume_ty: self.substs.type_at(parent_len),\n-            yield_ty: self.substs.type_at(parent_len + 1),\n-            return_ty: self.substs.type_at(parent_len + 2),\n-            witness: self.substs.type_at(parent_len + 3),\n-            tupled_upvars_ty: self.substs.type_at(parent_len + 4),\n+        match self.substs[..] {\n+            [.., resume_ty, yield_ty, return_ty, witness, tupled_upvars_ty] => {\n+                SplitGeneratorSubsts { resume_ty, yield_ty, return_ty, witness, tupled_upvars_ty }\n+            }\n+            _ => bug!(\"generator substs missing synthetics\"),\n         }\n     }\n \n@@ -477,7 +461,7 @@ impl<'tcx> GeneratorSubsts<'tcx> {\n     /// Used primarily by `ty::print::pretty` to be able to handle generator\n     /// types that haven't had their synthetic types substituted in.\n     pub fn is_valid(self) -> bool {\n-        self.substs.len() >= 5 && matches!(self.split().tupled_upvars_ty.kind, Tuple(_))\n+        self.substs.len() >= 5 && matches!(self.split().tupled_upvars_ty.expect_ty().kind, Tuple(_))\n     }\n \n     /// This describes the types that can be contained in a generator.\n@@ -486,37 +470,27 @@ impl<'tcx> GeneratorSubsts<'tcx> {\n     /// The state transformation MIR pass may only produce layouts which mention types\n     /// in this tuple. Upvars are not counted here.\n     pub fn witness(self) -> Ty<'tcx> {\n-        self.split().witness\n+        self.split().witness.expect_ty()\n     }\n \n     #[inline]\n     pub fn upvar_tys(self) -> impl Iterator<Item = Ty<'tcx>> + 'tcx {\n-        let upvars = match self.split().tupled_upvars_ty.kind {\n-            Tuple(upvars) => upvars,\n-            _ => bug!(\"upvars should be tupled\"),\n-        };\n-        upvars.iter().map(|t| {\n-            if let GenericArgKind::Type(ty) = t.unpack() {\n-                ty\n-            } else {\n-                bug!(\"upvar should be type\")\n-            }\n-        })\n+        self.split().tupled_upvars_ty.expect_ty().tuple_fields()\n     }\n \n     /// Returns the type representing the resume type of the generator.\n     pub fn resume_ty(self) -> Ty<'tcx> {\n-        self.split().resume_ty\n+        self.split().resume_ty.expect_ty()\n     }\n \n     /// Returns the type representing the yield type of the generator.\n     pub fn yield_ty(self) -> Ty<'tcx> {\n-        self.split().yield_ty\n+        self.split().yield_ty.expect_ty()\n     }\n \n     /// Returns the type representing the return type of the generator.\n     pub fn return_ty(self) -> Ty<'tcx> {\n-        self.split().return_ty\n+        self.split().return_ty.expect_ty()\n     }\n \n     /// Returns the \"generator signature\", which consists of its yield\n@@ -645,17 +619,7 @@ impl<'tcx> UpvarSubsts<'tcx> {\n             UpvarSubsts::Closure(substs) => substs.as_closure().split().tupled_upvars_ty,\n             UpvarSubsts::Generator(substs) => substs.as_generator().split().tupled_upvars_ty,\n         };\n-        let upvars = match tupled_upvars_ty.kind {\n-            Tuple(upvars) => upvars,\n-            _ => bug!(\"upvars should be tupled\"),\n-        };\n-        upvars.iter().map(|t| {\n-            if let GenericArgKind::Type(ty) = t.unpack() {\n-                ty\n-            } else {\n-                bug!(\"upvar should be type\")\n-            }\n-        })\n+        tupled_upvars_ty.expect_ty().tuple_fields()\n     }\n }\n "}]}