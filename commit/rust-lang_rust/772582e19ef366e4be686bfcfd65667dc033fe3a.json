{"sha": "772582e19ef366e4be686bfcfd65667dc033fe3a", "node_id": "MDY6Q29tbWl0NzI0NzEyOjc3MjU4MmUxOWVmMzY2ZTRiZTY4NmJmY2ZkNjU2NjdkYzAzM2ZlM2E=", "commit": {"author": {"name": "Dylan DPC", "email": "dylan.dpc@gmail.com", "date": "2021-03-29T22:32:21Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2021-03-29T22:32:21Z"}, "message": "Rollup merge of #83374 - reyk:fix/bsd-ancillary, r=joshtriplett\n\nunix: Fix feature(unix_socket_ancillary_data) on macos and other BSDs\n\nThis adds support for CMSG handling on macOS and fixes it on OpenBSD and possibly other BSDs.\n\nWhen traversing the CMSG list, the previous code had an exception for Android where the next element after the last pointer could point to the first pointer instead of NULL.  This is actually not specific to Android: the `libc::CMSG_NXTHDR` implementation for Linux and emscripten have a special case to return NULL when the length of the previous element is zero; most other implementations simply return the previous element plus a zero offset in this case.\n\nThis MR makes the check non-optional which fixes CMSG handling and a possible endless loop on such systems; tested with file descriptor passing on OpenBSD, Linux, and macOS.\n\nThis MR additionally adds `SocketAncillary::is_empty` because clippy is right that it should be added.\n\nThis belongs to the `feature(unix_socket_ancillary_data)` tracking issue:  https://github.com/rust-lang/rust/issues/76915\n\nr? `@joshtriplett`", "tree": {"sha": "0a485e095e1e3e5adc5285392055d2ae13fe6063", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0a485e095e1e3e5adc5285392055d2ae13fe6063"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/772582e19ef366e4be686bfcfd65667dc033fe3a", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJgYlV1CRBK7hj4Ov3rIwAAdHIIAEoV+vn16w3b4U7wkRB9FSOb\ntgiGXMlFUZ4L8Vq+xIrD8KUZU3rr90ZrfFFy47mbtnq4lT4dsMM+sNgU+Uvb6iAI\ns5mOB3iMYE4IHNPTIxD4zrD3BqDnBFXYt8RaEtqFWY5rVm6td8592vIB6racmLRp\ngkFjTCVTqEJS9J1agYNHOcahY//AiDKsrDLNsTfTrvTwsSivopEfHAFO5u8Qyf6R\n4w9Er65VUcuHl17fUN5umwvIb1VeNltUgJcIPBMQUmNoTBb/fFcK9gGyV7EBnE5b\n4ir/pFZDsfZ87v8Eqa3JttEB2E40M10GElGxxBNADYkwGrtSXWrDeCDsCN3XREY=\n=Dn6a\n-----END PGP SIGNATURE-----\n", "payload": "tree 0a485e095e1e3e5adc5285392055d2ae13fe6063\nparent 68964d1fc24888b04be492c3f3ba0dae7d6219da\nparent 3d6bd87b24a2fbccb6c1e81863874789eb046c17\nauthor Dylan DPC <dylan.dpc@gmail.com> 1617057141 +0200\ncommitter GitHub <noreply@github.com> 1617057141 +0200\n\nRollup merge of #83374 - reyk:fix/bsd-ancillary, r=joshtriplett\n\nunix: Fix feature(unix_socket_ancillary_data) on macos and other BSDs\n\nThis adds support for CMSG handling on macOS and fixes it on OpenBSD and possibly other BSDs.\n\nWhen traversing the CMSG list, the previous code had an exception for Android where the next element after the last pointer could point to the first pointer instead of NULL.  This is actually not specific to Android: the `libc::CMSG_NXTHDR` implementation for Linux and emscripten have a special case to return NULL when the length of the previous element is zero; most other implementations simply return the previous element plus a zero offset in this case.\n\nThis MR makes the check non-optional which fixes CMSG handling and a possible endless loop on such systems; tested with file descriptor passing on OpenBSD, Linux, and macOS.\n\nThis MR additionally adds `SocketAncillary::is_empty` because clippy is right that it should be added.\n\nThis belongs to the `feature(unix_socket_ancillary_data)` tracking issue:  https://github.com/rust-lang/rust/issues/76915\n\nr? `@joshtriplett`\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/772582e19ef366e4be686bfcfd65667dc033fe3a", "html_url": "https://github.com/rust-lang/rust/commit/772582e19ef366e4be686bfcfd65667dc033fe3a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/772582e19ef366e4be686bfcfd65667dc033fe3a/comments", "author": {"login": "Dylan-DPC", "id": 99973273, "node_id": "U_kgDOBfV4mQ", "avatar_url": "https://avatars.githubusercontent.com/u/99973273?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Dylan-DPC", "html_url": "https://github.com/Dylan-DPC", "followers_url": "https://api.github.com/users/Dylan-DPC/followers", "following_url": "https://api.github.com/users/Dylan-DPC/following{/other_user}", "gists_url": "https://api.github.com/users/Dylan-DPC/gists{/gist_id}", "starred_url": "https://api.github.com/users/Dylan-DPC/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Dylan-DPC/subscriptions", "organizations_url": "https://api.github.com/users/Dylan-DPC/orgs", "repos_url": "https://api.github.com/users/Dylan-DPC/repos", "events_url": "https://api.github.com/users/Dylan-DPC/events{/privacy}", "received_events_url": "https://api.github.com/users/Dylan-DPC/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "68964d1fc24888b04be492c3f3ba0dae7d6219da", "url": "https://api.github.com/repos/rust-lang/rust/commits/68964d1fc24888b04be492c3f3ba0dae7d6219da", "html_url": "https://github.com/rust-lang/rust/commit/68964d1fc24888b04be492c3f3ba0dae7d6219da"}, {"sha": "3d6bd87b24a2fbccb6c1e81863874789eb046c17", "url": "https://api.github.com/repos/rust-lang/rust/commits/3d6bd87b24a2fbccb6c1e81863874789eb046c17", "html_url": "https://github.com/rust-lang/rust/commit/3d6bd87b24a2fbccb6c1e81863874789eb046c17"}], "stats": {"total": 57, "additions": 34, "deletions": 23}, "files": [{"sha": "011ae643f87123bf9cf74539429c48abbd380d19", "filename": "library/std/src/sys/unix/ext/net/ancillary.rs", "status": "modified", "additions": 34, "deletions": 23, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/772582e19ef366e4be686bfcfd65667dc033fe3a/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fext%2Fnet%2Fancillary.rs", "raw_url": "https://github.com/rust-lang/rust/raw/772582e19ef366e4be686bfcfd65667dc033fe3a/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fext%2Fnet%2Fancillary.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fext%2Fnet%2Fancillary.rs?ref=772582e19ef366e4be686bfcfd65667dc033fe3a", "patch": "@@ -5,9 +5,7 @@ use crate::marker::PhantomData;\n use crate::mem::{size_of, zeroed};\n use crate::os::unix::io::RawFd;\n use crate::path::Path;\n-#[cfg(target_os = \"android\")]\n-use crate::ptr::eq;\n-use crate::ptr::read_unaligned;\n+use crate::ptr::{eq, read_unaligned};\n use crate::slice::from_raw_parts;\n use crate::sys::net::Socket;\n \n@@ -30,12 +28,10 @@ pub(super) fn recv_vectored_with_ancillary_from(\n ) -> io::Result<(usize, bool, io::Result<SocketAddr>)> {\n     unsafe {\n         let mut msg_name: libc::sockaddr_un = zeroed();\n-\n         let mut msg: libc::msghdr = zeroed();\n         msg.msg_name = &mut msg_name as *mut _ as *mut _;\n         msg.msg_namelen = size_of::<libc::sockaddr_un>() as libc::socklen_t;\n         msg.msg_iov = bufs.as_mut_ptr().cast();\n-        msg.msg_control = ancillary.buffer.as_mut_ptr().cast();\n         cfg_if::cfg_if! {\n             if #[cfg(any(target_os = \"android\", all(target_os = \"linux\", target_env = \"gnu\")))] {\n                 msg.msg_iovlen = bufs.len() as libc::size_t;\n@@ -45,13 +41,18 @@ pub(super) fn recv_vectored_with_ancillary_from(\n                           target_os = \"emscripten\",\n                           target_os = \"freebsd\",\n                           all(target_os = \"linux\", target_env = \"musl\",),\n+                          target_os = \"macos\",\n                           target_os = \"netbsd\",\n                           target_os = \"openbsd\",\n                       ))] {\n                 msg.msg_iovlen = bufs.len() as libc::c_int;\n                 msg.msg_controllen = ancillary.buffer.len() as libc::socklen_t;\n             }\n         }\n+        // macos requires that the control pointer is NULL when the len is 0.\n+        if msg.msg_controllen > 0 {\n+            msg.msg_control = ancillary.buffer.as_mut_ptr().cast();\n+        }\n \n         let count = socket.recv_msg(&mut msg)?;\n \n@@ -79,7 +80,6 @@ pub(super) fn send_vectored_with_ancillary_to(\n         msg.msg_name = &mut msg_name as *mut _ as *mut _;\n         msg.msg_namelen = msg_namelen;\n         msg.msg_iov = bufs.as_ptr() as *mut _;\n-        msg.msg_control = ancillary.buffer.as_mut_ptr().cast();\n         cfg_if::cfg_if! {\n             if #[cfg(any(target_os = \"android\", all(target_os = \"linux\", target_env = \"gnu\")))] {\n                 msg.msg_iovlen = bufs.len() as libc::size_t;\n@@ -89,13 +89,18 @@ pub(super) fn send_vectored_with_ancillary_to(\n                           target_os = \"emscripten\",\n                           target_os = \"freebsd\",\n                           all(target_os = \"linux\", target_env = \"musl\",),\n+                          target_os = \"macos\",\n                           target_os = \"netbsd\",\n                           target_os = \"openbsd\",\n                       ))] {\n                 msg.msg_iovlen = bufs.len() as libc::c_int;\n                 msg.msg_controllen = ancillary.length as libc::socklen_t;\n             }\n         }\n+        // macos requires that the control pointer is NULL when the len is 0.\n+        if msg.msg_controllen > 0 {\n+            msg.msg_control = ancillary.buffer.as_mut_ptr().cast();\n+        }\n \n         ancillary.truncated = false;\n \n@@ -147,6 +152,7 @@ fn add_to_ancillary_data<T>(\n                           target_os = \"emscripten\",\n                           target_os = \"freebsd\",\n                           all(target_os = \"linux\", target_env = \"musl\",),\n+                          target_os = \"macos\",\n                           target_os = \"netbsd\",\n                           target_os = \"openbsd\",\n                       ))] {\n@@ -159,14 +165,12 @@ fn add_to_ancillary_data<T>(\n         while !cmsg.is_null() {\n             previous_cmsg = cmsg;\n             cmsg = libc::CMSG_NXTHDR(&msg, cmsg);\n-            cfg_if::cfg_if! {\n-                // Android return the same pointer if it is the last cmsg.\n-                // Therefore, check it if the previous pointer is the same as the current one.\n-                if #[cfg(target_os = \"android\")] {\n-                    if cmsg == previous_cmsg {\n-                        break;\n-                    }\n-                }\n+\n+            // Most operating systems, but not Linux or emscripten, return the previous pointer\n+            // when its length is zero. Therefore, check if the previous pointer is the same as\n+            // the current one.\n+            if eq(cmsg, previous_cmsg) {\n+                break;\n             }\n         }\n \n@@ -184,6 +188,7 @@ fn add_to_ancillary_data<T>(\n                           target_os = \"emscripten\",\n                           target_os = \"freebsd\",\n                           all(target_os = \"linux\", target_env = \"musl\",),\n+                          target_os = \"macos\",\n                           target_os = \"netbsd\",\n                           target_os = \"openbsd\",\n                       ))] {\n@@ -371,6 +376,7 @@ impl<'a> AncillaryData<'a> {\n                               target_os = \"emscripten\",\n                               target_os = \"freebsd\",\n                               all(target_os = \"linux\", target_env = \"musl\",),\n+                              target_os = \"macos\",\n                               target_os = \"netbsd\",\n                               target_os = \"openbsd\",\n                           ))] {\n@@ -421,6 +427,7 @@ impl<'a> Iterator for Messages<'a> {\n                               target_os = \"emscripten\",\n                               target_os = \"freebsd\",\n                               all(target_os = \"linux\", target_env = \"musl\",),\n+                              target_os = \"macos\",\n                               target_os = \"netbsd\",\n                               target_os = \"openbsd\",\n                           ))] {\n@@ -435,15 +442,13 @@ impl<'a> Iterator for Messages<'a> {\n             };\n \n             let cmsg = cmsg.as_ref()?;\n-            cfg_if::cfg_if! {\n-                // Android return the same pointer if it is the last cmsg.\n-                // Therefore, check it if the previous pointer is the same as the current one.\n-                if #[cfg(target_os = \"android\")] {\n-                    if let Some(current) = self.current {\n-                        if eq(current, cmsg) {\n-                            return None;\n-                        }\n-                    }\n+\n+            // Most operating systems, but not Linux or emscripten, return the previous pointer\n+            // when its length is zero. Therefore, check if the previous pointer is the same as\n+            // the current one.\n+            if let Some(current) = self.current {\n+                if eq(current, cmsg) {\n+                    return None;\n                 }\n             }\n \n@@ -514,6 +519,12 @@ impl<'a> SocketAncillary<'a> {\n         self.buffer.len()\n     }\n \n+    /// Returns `true` if the ancillary data is empty.\n+    #[unstable(feature = \"unix_socket_ancillary_data\", issue = \"76915\")]\n+    pub fn is_empty(&self) -> bool {\n+        self.length == 0\n+    }\n+\n     /// Returns the number of used bytes.\n     #[unstable(feature = \"unix_socket_ancillary_data\", issue = \"76915\")]\n     pub fn len(&self) -> usize {"}]}