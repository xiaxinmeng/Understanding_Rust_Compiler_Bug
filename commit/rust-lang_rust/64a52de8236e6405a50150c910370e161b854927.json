{"sha": "64a52de8236e6405a50150c910370e161b854927", "node_id": "MDY6Q29tbWl0NzI0NzEyOjY0YTUyZGU4MjM2ZTY0MDVhNTAxNTBjOTEwMzcwZTE2MWI4NTQ5Mjc=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2014-03-22T07:53:58Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2014-03-25T00:17:46Z"}, "message": "sync: Update the arc module\n\nThis removes the now-outdated MutexArc and RWArc types. These are superseded by\nArc<Mutex<T>> and Arc<RWLock<T>>. The only remaining arc is the one true Arc.\nAdditionally, the arc now has weak pointers implemented for it to assist in\nbreaking cycles.\n\nThis commit brings the arc api up to parity with the sibling Rc api, making them\nnearly interchangeable for inter and intra task communication.", "tree": {"sha": "44064718010c8f6a594485256d96208b526dde84", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/44064718010c8f6a594485256d96208b526dde84"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/64a52de8236e6405a50150c910370e161b854927", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/64a52de8236e6405a50150c910370e161b854927", "html_url": "https://github.com/rust-lang/rust/commit/64a52de8236e6405a50150c910370e161b854927", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/64a52de8236e6405a50150c910370e161b854927/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4d5aafd3a6a25967a4b0d9326bbbbc1840dbaeeb", "url": "https://api.github.com/repos/rust-lang/rust/commits/4d5aafd3a6a25967a4b0d9326bbbbc1840dbaeeb", "html_url": "https://github.com/rust-lang/rust/commit/4d5aafd3a6a25967a4b0d9326bbbbc1840dbaeeb"}], "stats": {"total": 1168, "additions": 239, "deletions": 929}, "files": [{"sha": "28841b780a482cfb3aa014c209c31f55ac411566", "filename": "src/libsync/arc.rs", "status": "modified", "additions": 239, "deletions": 929, "changes": 1168, "blob_url": "https://github.com/rust-lang/rust/blob/64a52de8236e6405a50150c910370e161b854927/src%2Flibsync%2Farc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/64a52de8236e6405a50150c910370e161b854927/src%2Flibsync%2Farc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsync%2Farc.rs?ref=64a52de8236e6405a50150c910370e161b854927", "patch": "@@ -11,571 +11,247 @@\n /*!\n  * Concurrency-enabled mechanisms for sharing mutable and/or immutable state\n  * between tasks.\n- *\n- * # Example\n- *\n- * In this example, a large vector of floats is shared between several tasks.\n- * With simple pipes, without Arc, a copy would have to be made for each task.\n- *\n- * ```rust\n- * extern crate sync;\n- * extern crate rand;\n- *\n- * use std::slice;\n- * use sync::Arc;\n- *\n- * fn main() {\n- *     let numbers = slice::from_fn(100, |i| (i as f32) * rand::random());\n- *     let shared_numbers = Arc::new(numbers);\n- *\n- *     for _ in range(0, 10) {\n- *         let (tx, rx) = channel();\n- *         tx.send(shared_numbers.clone());\n- *\n- *         spawn(proc() {\n- *             let shared_numbers = rx.recv();\n- *             let local_numbers = shared_numbers.get();\n- *\n- *             // Work with the local numbers\n- *         });\n- *     }\n- * }\n- * ```\n  */\n \n-#[allow(missing_doc, dead_code)];\n-\n-\n-use sync;\n-use sync::{Mutex, RWLock};\n-\n use std::cast;\n-use std::kinds::{Share, marker};\n-use std::sync::arc::UnsafeArc;\n-use std::task;\n-\n-/// As sync::condvar, a mechanism for unlock-and-descheduling and\n-/// signaling, for use with the Arc types.\n-pub struct ArcCondvar<'a> {\n-    priv is_mutex: bool,\n-    priv failed: &'a bool,\n-    priv cond: &'a sync::Condvar<'a>\n+use std::ptr;\n+use std::rt::global_heap;\n+use std::sync::atomics;\n+\n+/// An atomically reference counted wrapper for shared state.\n+///\n+/// # Example\n+///\n+/// In this example, a large vector of floats is shared between several tasks.\n+/// With simple pipes, without `Arc`, a copy would have to be made for each\n+/// task.\n+///\n+/// ```rust\n+/// use sync::Arc;\n+///\n+/// fn main() {\n+///     let numbers = Vec::from_fn(100, |i| i as f32);\n+///     let shared_numbers = Arc::new(numbers);\n+///\n+///     for _ in range(0, 10) {\n+///         let child_numbers = shared_numbers.clone();\n+///\n+///         spawn(proc() {\n+///             let local_numbers = child_numbers.as_slice();\n+///\n+///             // Work with the local numbers\n+///         });\n+///     }\n+/// }\n+/// ```\n+#[unsafe_no_drop_flag]\n+pub struct Arc<T> {\n+    priv x: *mut ArcInner<T>,\n }\n \n-impl<'a> ArcCondvar<'a> {\n-    /// Atomically exit the associated Arc and block until a signal is sent.\n-    #[inline]\n-    pub fn wait(&self) { self.wait_on(0) }\n-\n-    /**\n-     * Atomically exit the associated Arc and block on a specified condvar\n-     * until a signal is sent on that same condvar (as sync::cond.wait_on).\n-     *\n-     * wait() is equivalent to wait_on(0).\n-     */\n-    #[inline]\n-    pub fn wait_on(&self, condvar_id: uint) {\n-        assert!(!*self.failed);\n-        self.cond.wait_on(condvar_id);\n-        // This is why we need to wrap sync::condvar.\n-        check_poison(self.is_mutex, *self.failed);\n-    }\n-\n-    /// Wake up a blocked task. Returns false if there was no blocked task.\n-    #[inline]\n-    pub fn signal(&self) -> bool { self.signal_on(0) }\n-\n-    /**\n-     * Wake up a blocked task on a specified condvar (as\n-     * sync::cond.signal_on). Returns false if there was no blocked task.\n-     */\n-    #[inline]\n-    pub fn signal_on(&self, condvar_id: uint) -> bool {\n-        assert!(!*self.failed);\n-        self.cond.signal_on(condvar_id)\n-    }\n-\n-    /// Wake up all blocked tasks. Returns the number of tasks woken.\n-    #[inline]\n-    pub fn broadcast(&self) -> uint { self.broadcast_on(0) }\n-\n-    /**\n-     * Wake up all blocked tasks on a specified condvar (as\n-     * sync::cond.broadcast_on). Returns the number of tasks woken.\n-     */\n-    #[inline]\n-    pub fn broadcast_on(&self, condvar_id: uint) -> uint {\n-        assert!(!*self.failed);\n-        self.cond.broadcast_on(condvar_id)\n-    }\n+/// A weak pointer to an `Arc`.\n+///\n+/// Weak pointers will not keep the data inside of the `Arc` alive, and can be\n+/// used to break cycles between `Arc` pointers.\n+#[unsafe_no_drop_flag]\n+pub struct Weak<T> {\n+    priv x: *mut ArcInner<T>,\n }\n \n-/****************************************************************************\n- * Immutable Arc\n- ****************************************************************************/\n-\n-/// An atomically reference counted wrapper for shared immutable state.\n-pub struct Arc<T> { priv x: UnsafeArc<T> }\n-\n+struct ArcInner<T> {\n+    strong: atomics::AtomicUint,\n+    weak: atomics::AtomicUint,\n+    data: T,\n+}\n \n-/**\n- * Access the underlying data in an atomically reference counted\n- * wrapper.\n- */\n impl<T: Share + Send> Arc<T> {\n     /// Create an atomically reference counted wrapper.\n     #[inline]\n     pub fn new(data: T) -> Arc<T> {\n-        Arc { x: UnsafeArc::new(data) }\n+        // Start the weak pointer count as 1 which is the weak pointer that's\n+        // held by all the strong pointers (kinda), see std/rc.rs for more info\n+        let x = ~ArcInner {\n+            strong: atomics::AtomicUint::new(1),\n+            weak: atomics::AtomicUint::new(1),\n+            data: data,\n+        };\n+        Arc { x: unsafe { cast::transmute(x) } }\n     }\n \n     #[inline]\n-    pub fn get<'a>(&'a self) -> &'a T {\n-        unsafe { &*self.x.get_immut() }\n+    fn inner<'a>(&'a self) -> &'a ArcInner<T> {\n+        // This unsafety is ok because while this arc is alive we're guaranteed\n+        // that the inner pointer is valid. Furthermore, we know that the\n+        // `ArcInner` structure itself is `Share` because the inner data is\n+        // `Share` as well, so we're ok loaning out an immutable pointer to\n+        // these contents.\n+        unsafe { &*self.x }\n+    }\n+\n+    /// Downgrades a strong pointer to a weak pointer\n+    ///\n+    /// Weak pointers will not keep the data alive. Once all strong references\n+    /// to the underlying data have been dropped, the data itself will be\n+    /// destroyed.\n+    pub fn downgrade(&self) -> Weak<T> {\n+        // See the clone() impl for why this is relaxed\n+        self.inner().weak.fetch_add(1, atomics::Relaxed);\n+        Weak { x: self.x }\n     }\n }\n \n impl<T: Share + Send> Clone for Arc<T> {\n-    /**\n-    * Duplicate an atomically reference counted wrapper.\n-    *\n-    * The resulting two `arc` objects will point to the same underlying data\n-    * object. However, one of the `arc` objects can be sent to another task,\n-    * allowing them to share the underlying data.\n-    */\n+    /// Duplicate an atomically reference counted wrapper.\n+    ///\n+    /// The resulting two `Arc` objects will point to the same underlying data\n+    /// object. However, one of the `Arc` objects can be sent to another task,\n+    /// allowing them to share the underlying data.\n     #[inline]\n     fn clone(&self) -> Arc<T> {\n-        Arc { x: self.x.clone() }\n+        // Using a relaxed ordering is alright here, as knowledge of the\n+        // original reference prevents other threads from erroneously deleting\n+        // the object.\n+        //\n+        // As explained in the [Boost documentation][1], Increasing the\n+        // reference counter can always be done with memory_order_relaxed: New\n+        // references to an object can only be formed from an existing\n+        // reference, and passing an existing reference from one thread to\n+        // another must already provide any required synchronization.\n+        //\n+        // [1]: (www.boost.org/doc/libs/1_55_0/doc/html/atomic/usage_examples.html)\n+        self.inner().strong.fetch_add(1, atomics::Relaxed);\n+        Arc { x: self.x }\n     }\n }\n \n-/****************************************************************************\n- * Mutex protected Arc (unsafe)\n- ****************************************************************************/\n-\n-#[doc(hidden)]\n-struct MutexArcInner<T> { lock: Mutex, failed: bool, data: T }\n-\n-/// An Arc with mutable data protected by a blocking mutex.\n-pub struct MutexArc<T> {\n-    priv x: UnsafeArc<MutexArcInner<T>>,\n-}\n-\n-impl<T:Send> Clone for MutexArc<T> {\n-    /// Duplicate a mutex-protected Arc. See arc::clone for more details.\n+// FIXME(#13042): this should have T: Send, and use self.inner()\n+impl<T> Deref<T> for Arc<T> {\n     #[inline]\n-    fn clone(&self) -> MutexArc<T> {\n-        // NB: Cloning the underlying mutex is not necessary. Its reference\n-        // count would be exactly the same as the shared state's.\n-        MutexArc { x: self.x.clone() }\n+    fn deref<'a>(&'a self) -> &'a T {\n+        let inner = unsafe { &*self.x };\n+        &inner.data\n     }\n }\n \n-impl<T:Send> MutexArc<T> {\n-    /// Create a mutex-protected Arc with the supplied data.\n-    pub fn new(user_data: T) -> MutexArc<T> {\n-        MutexArc::new_with_condvars(user_data, 1)\n-    }\n-\n-    /**\n-     * Create a mutex-protected Arc with the supplied data and a specified number\n-     * of condvars (as sync::Mutex::new_with_condvars).\n-     */\n-    pub fn new_with_condvars(user_data: T, num_condvars: uint) -> MutexArc<T> {\n-        let data = MutexArcInner {\n-            lock: Mutex::new_with_condvars(num_condvars),\n-            failed: false, data: user_data\n-        };\n-        MutexArc { x: UnsafeArc::new(data) }\n-    }\n-\n-    /**\n-     * Access the underlying mutable data with mutual exclusion from other\n-     * tasks. The argument closure will be run with the mutex locked; all\n-     * other tasks wishing to access the data will block until the closure\n-     * finishes running.\n-     *\n-     * If you wish to nest MutexArcs, one strategy for ensuring safety at\n-     * runtime is to add a \"nesting level counter\" inside the stored data, and\n-     * when traversing the arcs, assert that they monotonically decrease.\n-     *\n-     * # Failure\n-     *\n-     * Failing while inside the Arc will unlock the Arc while unwinding, so\n-     * that other tasks won't block forever. It will also poison the Arc:\n-     * any tasks that subsequently try to access it (including those already\n-     * blocked on the mutex) will also fail immediately.\n-     */\n-    #[inline]\n-    pub fn access<U>(&self, blk: |x: &mut T| -> U) -> U {\n-        let state = self.x.get();\n-        unsafe {\n-            // Borrowck would complain about this if the code were\n-            // not already unsafe. See borrow_rwlock, far below.\n-            (&(*state).lock).lock(|| {\n-                check_poison(true, (*state).failed);\n-                let _z = PoisonOnFail::new(&mut (*state).failed);\n-                blk(&mut (*state).data)\n-            })\n-        }\n-    }\n-\n-    /// As access(), but with a condvar, as sync::mutex.lock_cond().\n+impl<T: Send + Share + Clone> Arc<T> {\n+    /// Acquires a mutable pointer to the inner contents by guaranteeing that\n+    /// the reference count is one (no sharing is possible).\n+    ///\n+    /// This is also referred to as a copy-on-write operation because the inner\n+    /// data is cloned if the reference count is greater than one.\n     #[inline]\n-    pub fn access_cond<U>(&self, blk: |x: &mut T, c: &ArcCondvar| -> U) -> U {\n-        let state = self.x.get();\n-        unsafe {\n-            (&(*state).lock).lock_cond(|cond| {\n-                check_poison(true, (*state).failed);\n-                let _z = PoisonOnFail::new(&mut (*state).failed);\n-                blk(&mut (*state).data,\n-                    &ArcCondvar {is_mutex: true,\n-                            failed: &(*state).failed,\n-                            cond: cond })\n-            })\n-        }\n-    }\n-}\n-\n-// Common code for {mutex.access,rwlock.write}{,_cond}.\n-#[inline]\n-#[doc(hidden)]\n-fn check_poison(is_mutex: bool, failed: bool) {\n-    if failed {\n-        if is_mutex {\n-            fail!(\"Poisoned MutexArc - another task failed inside!\");\n-        } else {\n-            fail!(\"Poisoned rw_arc - another task failed inside!\");\n+    #[experimental]\n+    pub fn make_unique<'a>(&'a mut self) -> &'a mut T {\n+        if self.inner().strong.load(atomics::SeqCst) != 1 {\n+            *self = Arc::new(self.deref().clone())\n         }\n+        // This unsafety is ok because we're guaranteed that the pointer\n+        // returned is the *only* pointer that will ever be returned to T. Our\n+        // reference count is guaranteed to be 1 at this point, and we required\n+        // the Arc itself to be `mut`, so we're returning the only possible\n+        // reference to the inner data.\n+        unsafe { cast::transmute_mut(self.deref()) }\n     }\n }\n \n-#[doc(hidden)]\n-struct PoisonOnFail {\n-    flag: *mut bool,\n-    failed: bool,\n-}\n-\n-impl Drop for PoisonOnFail {\n+#[unsafe_destructor]\n+impl<T: Share + Send> Drop for Arc<T> {\n     fn drop(&mut self) {\n-        unsafe {\n-            /* assert!(!*self.failed);\n-               -- might be false in case of cond.wait() */\n-            if !self.failed && task::failing() {\n-                *self.flag = true;\n-            }\n+        // This structure has #[unsafe_no_drop_flag], so this drop glue may run\n+        // more than once (but it is guaranteed to be zeroed after the first if\n+        // it's run more than once)\n+        if self.x.is_null() { return }\n+\n+        // Because `fetch_sub` is already atomic, we do not need to synchronize\n+        // with other threads unless we are going to delete the object. This\n+        // same logic applies to the below `fetch_sub` to the `weak` count.\n+        if self.inner().strong.fetch_sub(1, atomics::Release) != 0 { return }\n+\n+        // This fence is needed to prevent reordering of use of the data and\n+        // deletion of the data. Because it is marked `Release`, the\n+        // decreasing of the reference count sychronizes with this `Acquire`\n+        // fence. This means that use of the data happens before decreasing\n+        // the refernce count, which happens before this fence, which\n+        // happens before the deletion of the data.\n+        //\n+        // As explained in the [Boost documentation][1],\n+        //\n+        // It is important to enforce any possible access to the object in\n+        // one thread (through an existing reference) to *happen before*\n+        // deleting the object in a different thread. This is achieved by a\n+        // \"release\" operation after dropping a reference (any access to the\n+        // object through this reference must obviously happened before),\n+        // and an \"acquire\" operation before deleting the object.\n+        //\n+        // [1]: (www.boost.org/doc/libs/1_55_0/doc/html/atomic/usage_examples.html)\n+        atomics::fence(atomics::Acquire);\n+\n+        // Destroy the data at this time, even though we may not free the box\n+        // allocation itself (there may still be weak pointers lying around).\n+        unsafe { drop(ptr::read(&self.inner().data)); }\n+\n+        if self.inner().weak.fetch_sub(1, atomics::Release) == 0 {\n+            atomics::fence(atomics::Acquire);\n+            unsafe { global_heap::exchange_free(self.x as *u8) }\n         }\n     }\n }\n \n-impl PoisonOnFail {\n-    fn new<'a>(flag: &'a mut bool) -> PoisonOnFail {\n-        PoisonOnFail {\n-            flag: flag,\n-            failed: task::failing()\n+impl<T: Share + Send> Weak<T> {\n+    /// Attempts to upgrade this weak reference to a strong reference.\n+    ///\n+    /// This method will fail to upgrade this reference if the strong reference\n+    /// count has already reached 0, but if there are still other active strong\n+    /// references this function will return a new strong reference to the data\n+    pub fn upgrade(&self) -> Option<Arc<T>> {\n+        // We use a CAS loop to increment the strong count instead of a\n+        // fetch_add because once the count hits 0 is must never be above 0.\n+        let inner = self.inner();\n+        loop {\n+            let n = inner.strong.load(atomics::SeqCst);\n+            if n == 0 { return None }\n+            let old = inner.strong.compare_and_swap(n, n + 1, atomics::SeqCst);\n+            if old == n { return Some(Arc { x: self.x }) }\n         }\n     }\n-}\n \n-/****************************************************************************\n- * R/W lock protected Arc\n- ****************************************************************************/\n-\n-#[doc(hidden)]\n-struct RWArcInner<T> { lock: RWLock, failed: bool, data: T }\n-/**\n- * A dual-mode Arc protected by a reader-writer lock. The data can be accessed\n- * mutably or immutably, and immutably-accessing tasks may run concurrently.\n- *\n- * Unlike mutex_arcs, rw_arcs are safe, because they cannot be nested.\n- */\n-pub struct RWArc<T> {\n-    priv x: UnsafeArc<RWArcInner<T>>,\n-    priv marker: marker::NoShare,\n-}\n-\n-impl<T: Share + Send> Clone for RWArc<T> {\n-    /// Duplicate a rwlock-protected Arc. See arc::clone for more details.\n     #[inline]\n-    fn clone(&self) -> RWArc<T> {\n-        RWArc {\n-            x: self.x.clone(),\n-            marker: marker::NoShare\n-        }\n+    fn inner<'a>(&'a self) -> &'a ArcInner<T> {\n+        // See comments above for why this is \"safe\"\n+        unsafe { &*self.x }\n     }\n-\n }\n \n-impl<T: Share + Send> RWArc<T> {\n-    /// Create a reader/writer Arc with the supplied data.\n-    pub fn new(user_data: T) -> RWArc<T> {\n-        RWArc::new_with_condvars(user_data, 1)\n-    }\n-\n-    /**\n-     * Create a reader/writer Arc with the supplied data and a specified number\n-     * of condvars (as sync::RWLock::new_with_condvars).\n-     */\n-    pub fn new_with_condvars(user_data: T, num_condvars: uint) -> RWArc<T> {\n-        let data = RWArcInner {\n-            lock: RWLock::new_with_condvars(num_condvars),\n-            failed: false, data: user_data\n-        };\n-        RWArc {\n-            x: UnsafeArc::new(data),\n-            marker: marker::NoShare\n-        }\n-    }\n-\n-    /**\n-     * Access the underlying data mutably. Locks the rwlock in write mode;\n-     * other readers and writers will block.\n-     *\n-     * # Failure\n-     *\n-     * Failing while inside the Arc will unlock the Arc while unwinding, so\n-     * that other tasks won't block forever. As MutexArc.access, it will also\n-     * poison the Arc, so subsequent readers and writers will both also fail.\n-     */\n+impl<T: Share + Send> Clone for Weak<T> {\n     #[inline]\n-    pub fn write<U>(&self, blk: |x: &mut T| -> U) -> U {\n-        unsafe {\n-            let state = self.x.get();\n-            (*borrow_rwlock(state)).write(|| {\n-                check_poison(false, (*state).failed);\n-                let _z = PoisonOnFail::new(&mut (*state).failed);\n-                blk(&mut (*state).data)\n-            })\n-        }\n-    }\n-\n-    /// As write(), but with a condvar, as sync::rwlock.write_cond().\n-    #[inline]\n-    pub fn write_cond<U>(&self,\n-                         blk: |x: &mut T, c: &ArcCondvar| -> U)\n-                         -> U {\n-        unsafe {\n-            let state = self.x.get();\n-            (*borrow_rwlock(state)).write_cond(|cond| {\n-                check_poison(false, (*state).failed);\n-                let _z = PoisonOnFail::new(&mut (*state).failed);\n-                blk(&mut (*state).data,\n-                    &ArcCondvar {is_mutex: false,\n-                              failed: &(*state).failed,\n-                              cond: cond})\n-            })\n-        }\n-    }\n-\n-    /**\n-     * Access the underlying data immutably. May run concurrently with other\n-     * reading tasks.\n-     *\n-     * # Failure\n-     *\n-     * Failing will unlock the Arc while unwinding. However, unlike all other\n-     * access modes, this will not poison the Arc.\n-     */\n-    pub fn read<U>(&self, blk: |x: &T| -> U) -> U {\n-        unsafe {\n-            let state = self.x.get();\n-            (*state).lock.read(|| {\n-                check_poison(false, (*state).failed);\n-                blk(&(*state).data)\n-            })\n-        }\n-    }\n-\n-    /**\n-     * As write(), but with the ability to atomically 'downgrade' the lock.\n-     * See sync::rwlock.write_downgrade(). The RWWriteMode token must be used\n-     * to obtain the &mut T, and can be transformed into a RWReadMode token by\n-     * calling downgrade(), after which a &T can be obtained instead.\n-     *\n-     * # Example\n-     *\n-     * ```rust\n-     * use sync::RWArc;\n-     *\n-     * let arc = RWArc::new(1);\n-     * arc.write_downgrade(|mut write_token| {\n-     *     write_token.write_cond(|state, condvar| {\n-     *         // ... exclusive access with mutable state ...\n-     *     });\n-     *     let read_token = arc.downgrade(write_token);\n-     *     read_token.read(|state| {\n-     *         // ... shared access with immutable state ...\n-     *     });\n-     * })\n-     * ```\n-     */\n-    pub fn write_downgrade<U>(&self, blk: |v: RWWriteMode<T>| -> U) -> U {\n-        unsafe {\n-            let state = self.x.get();\n-            (*borrow_rwlock(state)).write_downgrade(|write_mode| {\n-                check_poison(false, (*state).failed);\n-                blk(RWWriteMode {\n-                    data: &mut (*state).data,\n-                    token: write_mode,\n-                    poison: PoisonOnFail::new(&mut (*state).failed)\n-                })\n-            })\n-        }\n-    }\n-\n-    /// To be called inside of the write_downgrade block.\n-    pub fn downgrade<'a>(&self, token: RWWriteMode<'a, T>)\n-                         -> RWReadMode<'a, T> {\n-        unsafe {\n-            // The rwlock should assert that the token belongs to us for us.\n-            let state = self.x.get();\n-            let RWWriteMode {\n-                data: data,\n-                token: t,\n-                poison: _poison\n-            } = token;\n-            // Let readers in\n-            let new_token = (*state).lock.downgrade(t);\n-            // Whatever region the input reference had, it will be safe to use\n-            // the same region for the output reference. (The only 'unsafe' part\n-            // of this cast is removing the mutability.)\n-            let new_data = data;\n-            // Downgrade ensured the token belonged to us. Just a sanity check.\n-            assert!((&(*state).data as *T as uint) == (new_data as *mut T as uint));\n-            // Produce new token\n-            RWReadMode {\n-                data: new_data,\n-                token: new_token,\n-            }\n-        }\n-    }\n-}\n-\n-// Borrowck rightly complains about immutably aliasing the rwlock in order to\n-// lock it. This wraps the unsafety, with the justification that the 'lock'\n-// field is never overwritten; only 'failed' and 'data'.\n-#[doc(hidden)]\n-fn borrow_rwlock<T: Share + Send>(state: *mut RWArcInner<T>) -> *RWLock {\n-    unsafe { cast::transmute(&(*state).lock) }\n-}\n-\n-/// The \"write permission\" token used for RWArc.write_downgrade().\n-pub struct RWWriteMode<'a, T> {\n-    priv data: &'a mut T,\n-    priv token: sync::RWLockWriteMode<'a>,\n-    priv poison: PoisonOnFail,\n-}\n-\n-/// The \"read permission\" token used for RWArc.write_downgrade().\n-pub struct RWReadMode<'a, T> {\n-    priv data: &'a T,\n-    priv token: sync::RWLockReadMode<'a>,\n-}\n-\n-impl<'a, T: Share + Send> RWWriteMode<'a, T> {\n-    /// Access the pre-downgrade RWArc in write mode.\n-    pub fn write<U>(&mut self, blk: |x: &mut T| -> U) -> U {\n-        match *self {\n-            RWWriteMode {\n-                data: &ref mut data,\n-                token: ref token,\n-                poison: _\n-            } => {\n-                token.write(|| blk(data))\n-            }\n-        }\n-    }\n-\n-    /// Access the pre-downgrade RWArc in write mode with a condvar.\n-    pub fn write_cond<U>(&mut self,\n-                         blk: |x: &mut T, c: &ArcCondvar| -> U)\n-                         -> U {\n-        match *self {\n-            RWWriteMode {\n-                data: &ref mut data,\n-                token: ref token,\n-                poison: ref poison\n-            } => {\n-                token.write_cond(|cond| {\n-                    unsafe {\n-                        let cvar = ArcCondvar {\n-                            is_mutex: false,\n-                            failed: &*poison.flag,\n-                            cond: cond\n-                        };\n-                        blk(data, &cvar)\n-                    }\n-                })\n-            }\n-        }\n-    }\n-}\n-\n-impl<'a, T: Share + Send> RWReadMode<'a, T> {\n-    /// Access the post-downgrade rwlock in read mode.\n-    pub fn read<U>(&self, blk: |x: &T| -> U) -> U {\n-        match *self {\n-            RWReadMode {\n-                data: data,\n-                token: ref token\n-            } => {\n-                token.read(|| blk(data))\n-            }\n-        }\n+    fn clone(&self) -> Weak<T> {\n+        // See comments in Arc::clone() for why this is relaxed\n+        self.inner().weak.fetch_add(1, atomics::Relaxed);\n+        Weak { x: self.x }\n     }\n }\n \n-/****************************************************************************\n- * Copy-on-write Arc\n- ****************************************************************************/\n-\n-pub struct CowArc<T> { priv x: UnsafeArc<T> }\n-\n-/// A Copy-on-write Arc functions the same way as an `arc` except it allows\n-/// mutation of the contents if there is only a single reference to\n-/// the data. If there are multiple references the data is automatically\n-/// cloned and the task modifies the cloned data in place of the shared data.\n-impl<T: Clone + Send + Share> CowArc<T> {\n-    /// Create a copy-on-write atomically reference counted wrapper\n-    #[inline]\n-    pub fn new(data: T) -> CowArc<T> {\n-        CowArc { x: UnsafeArc::new(data) }\n-    }\n-\n-    #[inline]\n-    pub fn get<'a>(&'a self) -> &'a T {\n-        unsafe { &*self.x.get_immut() }\n-    }\n-\n-    /// get a mutable reference to the contents. If there are more then one\n-    /// reference to the contents of the `CowArc` will be cloned\n-    /// and this reference updated to point to the cloned data.\n-    #[inline]\n-    pub fn get_mut<'a>(&'a mut self) -> &'a mut T {\n-        if !self.x.is_owned() {\n-            *self = CowArc::new(self.get().clone())\n+#[unsafe_destructor]\n+impl<T: Share + Send> Drop for Weak<T> {\n+    fn drop(&mut self) {\n+        // see comments above for why this check is here\n+        if self.x.is_null() { return }\n+\n+        // If we find out that we were the last weak pointer, then its time to\n+        // deallocate the data entirely. See the discussion in Arc::drop() about\n+        // the memory orderings\n+        if self.inner().weak.fetch_sub(1, atomics::Release) == 0 {\n+            atomics::fence(atomics::Acquire);\n+            unsafe { global_heap::exchange_free(self.x as *u8) }\n         }\n-        unsafe { &mut *self.x.get() }\n-    }\n-}\n-\n-impl<T: Clone + Send + Share> Clone for CowArc<T> {\n-    /// Duplicate a Copy-on-write Arc. See arc::clone for more details.\n-    fn clone(&self) -> CowArc<T> {\n-        CowArc { x: self.x.clone() }\n     }\n }\n \n-\n-\n-/****************************************************************************\n- * Tests\n- ****************************************************************************/\n-\n #[cfg(test)]\n+#[allow(experimental)]\n mod tests {\n-\n-    use super::{Arc, RWArc, MutexArc, CowArc};\n+    use super::{Arc, Weak};\n+    use Mutex;\n \n     use std::task;\n \n@@ -588,455 +264,89 @@ mod tests {\n \n         task::spawn(proc() {\n             let arc_v: Arc<Vec<int>> = rx.recv();\n-\n-            let v = arc_v.get().clone();\n-            assert_eq!(*v.get(3), 4);\n+            assert_eq!(*arc_v.get(3), 4);\n         });\n \n         tx.send(arc_v.clone());\n \n-        assert_eq!(*arc_v.get().get(2), 3);\n-        assert_eq!(*arc_v.get().get(4), 5);\n+        assert_eq!(*arc_v.get(2), 3);\n+        assert_eq!(*arc_v.get(4), 5);\n \n         info!(\"{:?}\", arc_v);\n     }\n \n     #[test]\n-    fn test_mutex_arc_condvar() {\n-        let arc = ~MutexArc::new(false);\n-        let arc2 = ~arc.clone();\n-        let (tx, rx) = channel();\n-        task::spawn(proc() {\n-            // wait until parent gets in\n-            rx.recv();\n-            arc2.access_cond(|state, cond| {\n-                *state = true;\n-                cond.signal();\n-            })\n-        });\n-\n-        arc.access_cond(|state, cond| {\n-            tx.send(());\n-            assert!(!*state);\n-            while !*state {\n-                cond.wait();\n-            }\n-        })\n-    }\n-\n-    #[test] #[should_fail]\n-    fn test_arc_condvar_poison() {\n-        let arc = ~MutexArc::new(1);\n-        let arc2 = ~arc.clone();\n-        let (tx, rx) = channel();\n-\n-        spawn(proc() {\n-            let _ = rx.recv();\n-            arc2.access_cond(|one, cond| {\n-                cond.signal();\n-                // Parent should fail when it wakes up.\n-                assert_eq!(*one, 0);\n-            })\n-        });\n-\n-        arc.access_cond(|one, cond| {\n-            tx.send(());\n-            while *one == 1 {\n-                cond.wait();\n-            }\n-        })\n-    }\n-\n-    #[test] #[should_fail]\n-    fn test_mutex_arc_poison() {\n-        let arc = ~MutexArc::new(1);\n-        let arc2 = ~arc.clone();\n-        let _ = task::try(proc() {\n-            arc2.access(|one| {\n-                assert_eq!(*one, 2);\n-            })\n-        });\n-        arc.access(|one| {\n-            assert_eq!(*one, 1);\n-        })\n-    }\n-\n-    #[test]\n-    fn test_mutex_arc_nested() {\n-        // Tests nested mutexes and access\n-        // to underlaying data.\n-        let arc = ~MutexArc::new(1);\n-        let arc2 = ~MutexArc::new(*arc);\n-        task::spawn(proc() {\n-            (*arc2).access(|mutex| {\n-                (*mutex).access(|one| {\n-                    assert!(*one == 1);\n-                })\n-            })\n-        });\n-    }\n-\n-    #[test]\n-    fn test_mutex_arc_access_in_unwind() {\n-        let arc = MutexArc::new(1i);\n-        let arc2 = arc.clone();\n-        let _ = task::try::<()>(proc() {\n-            struct Unwinder {\n-                i: MutexArc<int>\n-            }\n-            impl Drop for Unwinder {\n-                fn drop(&mut self) {\n-                    self.i.access(|num| *num += 1);\n-                }\n-            }\n-            let _u = Unwinder { i: arc2 };\n-            fail!();\n-        });\n-        assert_eq!(2, arc.access(|n| *n));\n-    }\n-\n-    #[test] #[should_fail]\n-    fn test_rw_arc_poison_wr() {\n-        let arc = RWArc::new(1);\n-        let arc2 = arc.clone();\n-        let _ = task::try(proc() {\n-            arc2.write(|one| {\n-                assert_eq!(*one, 2);\n-            })\n-        });\n-        arc.read(|one| {\n-            assert_eq!(*one, 1);\n-        })\n-    }\n-\n-    #[test] #[should_fail]\n-    fn test_rw_arc_poison_ww() {\n-        let arc = RWArc::new(1);\n-        let arc2 = arc.clone();\n-        let _ = task::try(proc() {\n-            arc2.write(|one| {\n-                assert_eq!(*one, 2);\n-            })\n-        });\n-        arc.write(|one| {\n-            assert_eq!(*one, 1);\n-        })\n-    }\n-    #[test] #[should_fail]\n-    fn test_rw_arc_poison_dw() {\n-        let arc = RWArc::new(1);\n-        let arc2 = arc.clone();\n-        let _ = task::try(proc() {\n-            arc2.write_downgrade(|mut write_mode| {\n-                write_mode.write(|one| {\n-                    assert_eq!(*one, 2);\n-                })\n-            })\n-        });\n-        arc.write(|one| {\n-            assert_eq!(*one, 1);\n-        })\n-    }\n-    #[test]\n-    fn test_rw_arc_no_poison_rr() {\n-        let arc = RWArc::new(1);\n-        let arc2 = arc.clone();\n-        let _ = task::try(proc() {\n-            arc2.read(|one| {\n-                assert_eq!(*one, 2);\n-            })\n-        });\n-        arc.read(|one| {\n-            assert_eq!(*one, 1);\n-        })\n-    }\n-    #[test]\n-    fn test_rw_arc_no_poison_rw() {\n-        let arc = RWArc::new(1);\n-        let arc2 = arc.clone();\n-        let _ = task::try(proc() {\n-            arc2.read(|one| {\n-                assert_eq!(*one, 2);\n-            })\n-        });\n-        arc.write(|one| {\n-            assert_eq!(*one, 1);\n-        })\n-    }\n-    #[test]\n-    fn test_rw_arc_no_poison_dr() {\n-        let arc = RWArc::new(1);\n-        let arc2 = arc.clone();\n-        let _ = task::try(proc() {\n-            arc2.write_downgrade(|write_mode| {\n-                let read_mode = arc2.downgrade(write_mode);\n-                read_mode.read(|one| {\n-                    assert_eq!(*one, 2);\n-                })\n-            })\n-        });\n-        arc.write(|one| {\n-            assert_eq!(*one, 1);\n-        })\n-    }\n-    #[test]\n-    fn test_rw_arc() {\n-        let arc = RWArc::new(0);\n-        let arc2 = arc.clone();\n-        let (tx, rx) = channel();\n-\n-        task::spawn(proc() {\n-            arc2.write(|num| {\n-                for _ in range(0, 10) {\n-                    let tmp = *num;\n-                    *num = -1;\n-                    task::deschedule();\n-                    *num = tmp + 1;\n-                }\n-                tx.send(());\n-            })\n-        });\n+    fn test_cowarc_clone_make_unique() {\n+        let mut cow0 = Arc::new(75u);\n+        let mut cow1 = cow0.clone();\n+        let mut cow2 = cow1.clone();\n \n-        // Readers try to catch the writer in the act\n-        let mut children = Vec::new();\n-        for _ in range(0, 5) {\n-            let arc3 = arc.clone();\n-            let mut builder = task::task();\n-            children.push(builder.future_result());\n-            builder.spawn(proc() {\n-                arc3.read(|num| {\n-                    assert!(*num >= 0);\n-                })\n-            });\n-        }\n+        assert!(75 == *cow0.make_unique());\n+        assert!(75 == *cow1.make_unique());\n+        assert!(75 == *cow2.make_unique());\n \n-        // Wait for children to pass their asserts\n-        for r in children.mut_iter() {\n-            let _ = r.recv();\n-        }\n+        *cow0.make_unique() += 1;\n+        *cow1.make_unique() += 2;\n+        *cow2.make_unique() += 3;\n \n-        // Wait for writer to finish\n-        rx.recv();\n-        arc.read(|num| {\n-            assert_eq!(*num, 10);\n-        })\n-    }\n+        assert!(76 == *cow0);\n+        assert!(77 == *cow1);\n+        assert!(78 == *cow2);\n \n-    #[test]\n-    fn test_rw_arc_access_in_unwind() {\n-        let arc = RWArc::new(1i);\n-        let arc2 = arc.clone();\n-        let _ = task::try::<()>(proc() {\n-            struct Unwinder {\n-                i: RWArc<int>\n-            }\n-            impl Drop for Unwinder {\n-                fn drop(&mut self) {\n-                    self.i.write(|num| *num += 1);\n-                }\n-            }\n-            let _u = Unwinder { i: arc2 };\n-            fail!();\n-        });\n-        assert_eq!(2, arc.read(|n| *n));\n+        // none should point to the same backing memory\n+        assert!(*cow0 != *cow1);\n+        assert!(*cow0 != *cow2);\n+        assert!(*cow1 != *cow2);\n     }\n \n     #[test]\n-    fn test_rw_downgrade() {\n-        // (1) A downgrader gets in write mode and does cond.wait.\n-        // (2) A writer gets in write mode, sets state to 42, and does signal.\n-        // (3) Downgrader wakes, sets state to 31337.\n-        // (4) tells writer and all other readers to contend as it downgrades.\n-        // (5) Writer attempts to set state back to 42, while downgraded task\n-        //     and all reader tasks assert that it's 31337.\n-        let arc = RWArc::new(0);\n-\n-        // Reader tasks\n-        let mut reader_convos = Vec::new();\n-        for _ in range(0, 10) {\n-            let ((tx1, rx1), (tx2, rx2)) = (channel(), channel());\n-            reader_convos.push((tx1, rx2));\n-            let arcn = arc.clone();\n-            task::spawn(proc() {\n-                rx1.recv(); // wait for downgrader to give go-ahead\n-                arcn.read(|state| {\n-                    assert_eq!(*state, 31337);\n-                    tx2.send(());\n-                })\n-            });\n-        }\n-\n-        // Writer task\n-        let arc2 = arc.clone();\n-        let ((tx1, rx1), (tx2, rx2)) = (channel(), channel());\n-        task::spawn(proc() {\n-            rx1.recv();\n-            arc2.write_cond(|state, cond| {\n-                assert_eq!(*state, 0);\n-                *state = 42;\n-                cond.signal();\n-            });\n-            rx1.recv();\n-            arc2.write(|state| {\n-                // This shouldn't happen until after the downgrade read\n-                // section, and all other readers, finish.\n-                assert_eq!(*state, 31337);\n-                *state = 42;\n-            });\n-            tx2.send(());\n-        });\n-\n-        // Downgrader (us)\n-        arc.write_downgrade(|mut write_mode| {\n-            write_mode.write_cond(|state, cond| {\n-                tx1.send(()); // send to another writer who will wake us up\n-                while *state == 0 {\n-                    cond.wait();\n-                }\n-                assert_eq!(*state, 42);\n-                *state = 31337;\n-                // send to other readers\n-                for &(ref mut rc, _) in reader_convos.mut_iter() {\n-                    rc.send(())\n-                }\n-            });\n-            let read_mode = arc.downgrade(write_mode);\n-            read_mode.read(|state| {\n-                // complete handshake with other readers\n-                for &(_, ref mut rp) in reader_convos.mut_iter() {\n-                    rp.recv()\n-                }\n-                tx1.send(()); // tell writer to try again\n-                assert_eq!(*state, 31337);\n-            });\n-        });\n-\n-        rx2.recv(); // complete handshake with writer\n-    }\n-    #[cfg(test)]\n-    fn test_rw_write_cond_downgrade_read_race_helper() {\n-        // Tests that when a downgrader hands off the \"reader cloud\" lock\n-        // because of a contending reader, a writer can't race to get it\n-        // instead, which would result in readers_and_writers. This tests\n-        // the sync module rather than this one, but it's here because an\n-        // rwarc gives us extra shared state to help check for the race.\n-        // If you want to see this test fail, go to sync.rs and replace the\n-        // line in RWLock::write_cond() that looks like:\n-        //     \"blk(&ArcCondvar { order: opt_lock, ..*cond })\"\n-        // with just \"blk(cond)\".\n-        let x = RWArc::new(true);\n-        let (tx, rx) = channel();\n+    fn test_cowarc_clone_unique2() {\n+        let mut cow0 = Arc::new(75u);\n+        let cow1 = cow0.clone();\n+        let cow2 = cow1.clone();\n \n-        // writer task\n-        let xw = x.clone();\n-        task::spawn(proc() {\n-            xw.write_cond(|state, c| {\n-                tx.send(()); // tell downgrader it's ok to go\n-                c.wait();\n-                // The core of the test is here: the condvar reacquire path\n-                // must involve order_lock, so that it cannot race with a reader\n-                // trying to receive the \"reader cloud lock hand-off\".\n-                *state = false;\n-            })\n-        });\n+        assert!(75 == *cow0);\n+        assert!(75 == *cow1);\n+        assert!(75 == *cow2);\n \n-        rx.recv(); // wait for writer to get in\n+        *cow0.make_unique() += 1;\n \n-        x.write_downgrade(|mut write_mode| {\n-            write_mode.write_cond(|state, c| {\n-                assert!(*state);\n-                // make writer contend in the cond-reacquire path\n-                c.signal();\n-            });\n-            // make a reader task to trigger the \"reader cloud lock\" handoff\n-            let xr = x.clone();\n-            let (tx, rx) = channel();\n-            task::spawn(proc() {\n-                tx.send(());\n-                xr.read(|_state| { })\n-            });\n-            rx.recv(); // wait for reader task to exist\n+        assert!(76 == *cow0);\n+        assert!(75 == *cow1);\n+        assert!(75 == *cow2);\n \n-            let read_mode = x.downgrade(write_mode);\n-            read_mode.read(|state| {\n-                // if writer mistakenly got in, make sure it mutates state\n-                // before we assert on it\n-                for _ in range(0, 5) { task::deschedule(); }\n-                // make sure writer didn't get in.\n-                assert!(*state);\n-            })\n-        });\n-    }\n-    #[test]\n-    fn test_rw_write_cond_downgrade_read_race() {\n-        // Ideally the above test case would have deschedule statements in it that\n-        // helped to expose the race nearly 100% of the time... but adding\n-        // deschedules in the intuitively-right locations made it even less likely,\n-        // and I wasn't sure why :( . This is a mediocre \"next best\" option.\n-        for _ in range(0, 8) { test_rw_write_cond_downgrade_read_race_helper(); }\n+        // cow1 and cow2 should share the same contents\n+        // cow0 should have a unique reference\n+        assert!(*cow0 != *cow1);\n+        assert!(*cow0 != *cow2);\n+        assert!(*cow1 == *cow2);\n     }\n \n     #[test]\n-    fn test_cowarc_clone()\n-    {\n-        let cow0 = CowArc::new(75u);\n-        let cow1 = cow0.clone();\n-        let cow2 = cow1.clone();\n-\n-        assert!(75 == *cow0.get());\n-        assert!(75 == *cow1.get());\n-        assert!(75 == *cow2.get());\n-\n-        assert!(cow0.get() == cow1.get());\n-        assert!(cow0.get() == cow2.get());\n+    fn test_live() {\n+        let x = Arc::new(5);\n+        let y = x.downgrade();\n+        assert!(y.upgrade().is_some());\n     }\n \n     #[test]\n-    fn test_cowarc_clone_get_mut()\n-    {\n-        let mut cow0 = CowArc::new(75u);\n-        let mut cow1 = cow0.clone();\n-        let mut cow2 = cow1.clone();\n-\n-        assert!(75 == *cow0.get_mut());\n-        assert!(75 == *cow1.get_mut());\n-        assert!(75 == *cow2.get_mut());\n-\n-        *cow0.get_mut() += 1;\n-        *cow1.get_mut() += 2;\n-        *cow2.get_mut() += 3;\n-\n-        assert!(76 == *cow0.get());\n-        assert!(77 == *cow1.get());\n-        assert!(78 == *cow2.get());\n-\n-        // none should point to the same backing memory\n-        assert!(cow0.get() != cow1.get());\n-        assert!(cow0.get() != cow2.get());\n-        assert!(cow1.get() != cow2.get());\n+    fn test_dead() {\n+        let x = Arc::new(5);\n+        let y = x.downgrade();\n+        drop(x);\n+        assert!(y.upgrade().is_none());\n     }\n \n     #[test]\n-    fn test_cowarc_clone_get_mut2()\n-    {\n-        let mut cow0 = CowArc::new(75u);\n-        let cow1 = cow0.clone();\n-        let cow2 = cow1.clone();\n-\n-        assert!(75 == *cow0.get());\n-        assert!(75 == *cow1.get());\n-        assert!(75 == *cow2.get());\n-\n-        *cow0.get_mut() += 1;\n+    fn weak_self_cyclic() {\n+        struct Cycle {\n+            x: Mutex<Option<Weak<Cycle>>>\n+        }\n \n-        assert!(76 == *cow0.get());\n-        assert!(75 == *cow1.get());\n-        assert!(75 == *cow2.get());\n+        let a = Arc::new(Cycle { x: Mutex::new(None) });\n+        let b = a.clone().downgrade();\n+        *a.deref().x.lock().deref_mut() = Some(b);\n \n-        // cow1 and cow2 should share the same contents\n-        // cow0 should have a unique reference\n-        assert!(cow0.get() != cow1.get());\n-        assert!(cow0.get() != cow2.get());\n-        assert!(cow1.get() == cow2.get());\n+        // hopefully we don't double-free (or leak)...\n     }\n }"}]}