{"sha": "3c44e1f08553af4309d16ab098522e57a057fabc", "node_id": "MDY6Q29tbWl0NzI0NzEyOjNjNDRlMWYwODU1M2FmNDMwOWQxNmFiMDk4NTIyZTU3YTA1N2ZhYmM=", "commit": {"author": {"name": "Clar Fon", "email": "them@lightdark.xyz", "date": "2018-12-18T00:27:24Z"}, "committer": {"name": "Clar Fon", "email": "them@lightdark.xyz", "date": "2019-01-22T22:45:11Z"}, "message": "Move Zip and ZipImpl to own module", "tree": {"sha": "c9892392991f90cec197b35a36b280eac3f014e4", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c9892392991f90cec197b35a36b280eac3f014e4"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3c44e1f08553af4309d16ab098522e57a057fabc", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3c44e1f08553af4309d16ab098522e57a057fabc", "html_url": "https://github.com/rust-lang/rust/commit/3c44e1f08553af4309d16ab098522e57a057fabc", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3c44e1f08553af4309d16ab098522e57a057fabc/comments", "author": {"login": "clarfonthey", "id": 15850505, "node_id": "MDQ6VXNlcjE1ODUwNTA1", "avatar_url": "https://avatars.githubusercontent.com/u/15850505?v=4", "gravatar_id": "", "url": "https://api.github.com/users/clarfonthey", "html_url": "https://github.com/clarfonthey", "followers_url": "https://api.github.com/users/clarfonthey/followers", "following_url": "https://api.github.com/users/clarfonthey/following{/other_user}", "gists_url": "https://api.github.com/users/clarfonthey/gists{/gist_id}", "starred_url": "https://api.github.com/users/clarfonthey/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/clarfonthey/subscriptions", "organizations_url": "https://api.github.com/users/clarfonthey/orgs", "repos_url": "https://api.github.com/users/clarfonthey/repos", "events_url": "https://api.github.com/users/clarfonthey/events{/privacy}", "received_events_url": "https://api.github.com/users/clarfonthey/received_events", "type": "User", "site_admin": false}, "committer": {"login": "clarfonthey", "id": 15850505, "node_id": "MDQ6VXNlcjE1ODUwNTA1", "avatar_url": "https://avatars.githubusercontent.com/u/15850505?v=4", "gravatar_id": "", "url": "https://api.github.com/users/clarfonthey", "html_url": "https://github.com/clarfonthey", "followers_url": "https://api.github.com/users/clarfonthey/followers", "following_url": "https://api.github.com/users/clarfonthey/following{/other_user}", "gists_url": "https://api.github.com/users/clarfonthey/gists{/gist_id}", "starred_url": "https://api.github.com/users/clarfonthey/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/clarfonthey/subscriptions", "organizations_url": "https://api.github.com/users/clarfonthey/orgs", "repos_url": "https://api.github.com/users/clarfonthey/repos", "events_url": "https://api.github.com/users/clarfonthey/events{/privacy}", "received_events_url": "https://api.github.com/users/clarfonthey/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9228f3c6b2017993b0b829d60ecc51279e51ccb9", "url": "https://api.github.com/repos/rust-lang/rust/commits/9228f3c6b2017993b0b829d60ecc51279e51ccb9", "html_url": "https://github.com/rust-lang/rust/commit/9228f3c6b2017993b0b829d60ecc51279e51ccb9"}], "stats": {"total": 524, "additions": 266, "deletions": 258}, "files": [{"sha": "b0faded8871306968d5a105e2f0741c0fab4745b", "filename": "src/libcore/iter/adapters/mod.rs", "status": "modified", "additions": 5, "deletions": 258, "changes": 263, "blob_url": "https://github.com/rust-lang/rust/blob/3c44e1f08553af4309d16ab098522e57a057fabc/src%2Flibcore%2Fiter%2Fadapters%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3c44e1f08553af4309d16ab098522e57a057fabc/src%2Flibcore%2Fiter%2Fadapters%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter%2Fadapters%2Fmod.rs?ref=3c44e1f08553af4309d16ab098522e57a057fabc", "patch": "@@ -7,6 +7,11 @@ use intrinsics;\n use super::{Iterator, DoubleEndedIterator, ExactSizeIterator, FusedIterator, TrustedLen};\n use super::LoopState;\n \n+mod zip;\n+\n+pub use self::zip::Zip;\n+pub(super) use self::zip::ZipImpl;\n+\n /// A double-ended iterator with the direction inverted.\n ///\n /// This `struct` is created by the [`rev`] method on [`Iterator`]. See its\n@@ -703,264 +708,6 @@ unsafe impl<A, B> TrustedLen for Chain<A, B>\n     where A: TrustedLen, B: TrustedLen<Item=A::Item>,\n {}\n \n-/// An iterator that iterates two other iterators simultaneously.\n-///\n-/// This `struct` is created by the [`zip`] method on [`Iterator`]. See its\n-/// documentation for more.\n-///\n-/// [`zip`]: trait.Iterator.html#method.zip\n-/// [`Iterator`]: trait.Iterator.html\n-#[derive(Clone, Debug)]\n-#[must_use = \"iterators are lazy and do nothing unless consumed\"]\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub struct Zip<A, B> {\n-    a: A,\n-    b: B,\n-    // index and len are only used by the specialized version of zip\n-    index: usize,\n-    len: usize,\n-}\n-\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<A, B> Iterator for Zip<A, B> where A: Iterator, B: Iterator\n-{\n-    type Item = (A::Item, B::Item);\n-\n-    #[inline]\n-    fn next(&mut self) -> Option<Self::Item> {\n-        ZipImpl::next(self)\n-    }\n-\n-    #[inline]\n-    fn size_hint(&self) -> (usize, Option<usize>) {\n-        ZipImpl::size_hint(self)\n-    }\n-\n-    #[inline]\n-    fn nth(&mut self, n: usize) -> Option<Self::Item> {\n-        ZipImpl::nth(self, n)\n-    }\n-}\n-\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<A, B> DoubleEndedIterator for Zip<A, B> where\n-    A: DoubleEndedIterator + ExactSizeIterator,\n-    B: DoubleEndedIterator + ExactSizeIterator,\n-{\n-    #[inline]\n-    fn next_back(&mut self) -> Option<(A::Item, B::Item)> {\n-        ZipImpl::next_back(self)\n-    }\n-}\n-\n-// Zip specialization trait\n-#[doc(hidden)]\n-pub(super) trait ZipImpl<A, B> {\n-    type Item;\n-    fn new(a: A, b: B) -> Self;\n-    fn next(&mut self) -> Option<Self::Item>;\n-    fn size_hint(&self) -> (usize, Option<usize>);\n-    fn nth(&mut self, n: usize) -> Option<Self::Item>;\n-    fn super_nth(&mut self, mut n: usize) -> Option<Self::Item> {\n-        while let Some(x) = self.next() {\n-            if n == 0 { return Some(x) }\n-            n -= 1;\n-        }\n-        None\n-    }\n-    fn next_back(&mut self) -> Option<Self::Item>\n-        where A: DoubleEndedIterator + ExactSizeIterator,\n-              B: DoubleEndedIterator + ExactSizeIterator;\n-}\n-\n-// General Zip impl\n-#[doc(hidden)]\n-impl<A, B> ZipImpl<A, B> for Zip<A, B>\n-    where A: Iterator, B: Iterator\n-{\n-    type Item = (A::Item, B::Item);\n-    default fn new(a: A, b: B) -> Self {\n-        Zip {\n-            a,\n-            b,\n-            index: 0, // unused\n-            len: 0, // unused\n-        }\n-    }\n-\n-    #[inline]\n-    default fn next(&mut self) -> Option<(A::Item, B::Item)> {\n-        self.a.next().and_then(|x| {\n-            self.b.next().and_then(|y| {\n-                Some((x, y))\n-            })\n-        })\n-    }\n-\n-    #[inline]\n-    default fn nth(&mut self, n: usize) -> Option<Self::Item> {\n-        self.super_nth(n)\n-    }\n-\n-    #[inline]\n-    default fn next_back(&mut self) -> Option<(A::Item, B::Item)>\n-        where A: DoubleEndedIterator + ExactSizeIterator,\n-              B: DoubleEndedIterator + ExactSizeIterator\n-    {\n-        let a_sz = self.a.len();\n-        let b_sz = self.b.len();\n-        if a_sz != b_sz {\n-            // Adjust a, b to equal length\n-            if a_sz > b_sz {\n-                for _ in 0..a_sz - b_sz { self.a.next_back(); }\n-            } else {\n-                for _ in 0..b_sz - a_sz { self.b.next_back(); }\n-            }\n-        }\n-        match (self.a.next_back(), self.b.next_back()) {\n-            (Some(x), Some(y)) => Some((x, y)),\n-            (None, None) => None,\n-            _ => unreachable!(),\n-        }\n-    }\n-\n-    #[inline]\n-    default fn size_hint(&self) -> (usize, Option<usize>) {\n-        let (a_lower, a_upper) = self.a.size_hint();\n-        let (b_lower, b_upper) = self.b.size_hint();\n-\n-        let lower = cmp::min(a_lower, b_lower);\n-\n-        let upper = match (a_upper, b_upper) {\n-            (Some(x), Some(y)) => Some(cmp::min(x,y)),\n-            (Some(x), None) => Some(x),\n-            (None, Some(y)) => Some(y),\n-            (None, None) => None\n-        };\n-\n-        (lower, upper)\n-    }\n-}\n-\n-#[doc(hidden)]\n-impl<A, B> ZipImpl<A, B> for Zip<A, B>\n-    where A: TrustedRandomAccess, B: TrustedRandomAccess\n-{\n-    fn new(a: A, b: B) -> Self {\n-        let len = cmp::min(a.len(), b.len());\n-        Zip {\n-            a,\n-            b,\n-            index: 0,\n-            len,\n-        }\n-    }\n-\n-    #[inline]\n-    fn next(&mut self) -> Option<(A::Item, B::Item)> {\n-        if self.index < self.len {\n-            let i = self.index;\n-            self.index += 1;\n-            unsafe {\n-                Some((self.a.get_unchecked(i), self.b.get_unchecked(i)))\n-            }\n-        } else if A::may_have_side_effect() && self.index < self.a.len() {\n-            // match the base implementation's potential side effects\n-            unsafe {\n-                self.a.get_unchecked(self.index);\n-            }\n-            self.index += 1;\n-            None\n-        } else {\n-            None\n-        }\n-    }\n-\n-    #[inline]\n-    fn size_hint(&self) -> (usize, Option<usize>) {\n-        let len = self.len - self.index;\n-        (len, Some(len))\n-    }\n-\n-    #[inline]\n-    fn nth(&mut self, n: usize) -> Option<Self::Item> {\n-        let delta = cmp::min(n, self.len - self.index);\n-        let end = self.index + delta;\n-        while self.index < end {\n-            let i = self.index;\n-            self.index += 1;\n-            if A::may_have_side_effect() {\n-                unsafe { self.a.get_unchecked(i); }\n-            }\n-            if B::may_have_side_effect() {\n-                unsafe { self.b.get_unchecked(i); }\n-            }\n-        }\n-\n-        self.super_nth(n - delta)\n-    }\n-\n-    #[inline]\n-    fn next_back(&mut self) -> Option<(A::Item, B::Item)>\n-        where A: DoubleEndedIterator + ExactSizeIterator,\n-              B: DoubleEndedIterator + ExactSizeIterator\n-    {\n-        // Adjust a, b to equal length\n-        if A::may_have_side_effect() {\n-            let sz = self.a.len();\n-            if sz > self.len {\n-                for _ in 0..sz - cmp::max(self.len, self.index) {\n-                    self.a.next_back();\n-                }\n-            }\n-        }\n-        if B::may_have_side_effect() {\n-            let sz = self.b.len();\n-            if sz > self.len {\n-                for _ in 0..sz - self.len {\n-                    self.b.next_back();\n-                }\n-            }\n-        }\n-        if self.index < self.len {\n-            self.len -= 1;\n-            let i = self.len;\n-            unsafe {\n-                Some((self.a.get_unchecked(i), self.b.get_unchecked(i)))\n-            }\n-        } else {\n-            None\n-        }\n-    }\n-}\n-\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<A, B> ExactSizeIterator for Zip<A, B>\n-    where A: ExactSizeIterator, B: ExactSizeIterator {}\n-\n-#[doc(hidden)]\n-unsafe impl<A, B> TrustedRandomAccess for Zip<A, B>\n-    where A: TrustedRandomAccess,\n-          B: TrustedRandomAccess,\n-{\n-    unsafe fn get_unchecked(&mut self, i: usize) -> (A::Item, B::Item) {\n-        (self.a.get_unchecked(i), self.b.get_unchecked(i))\n-    }\n-\n-    fn may_have_side_effect() -> bool {\n-        A::may_have_side_effect() || B::may_have_side_effect()\n-    }\n-}\n-\n-#[stable(feature = \"fused\", since = \"1.26.0\")]\n-impl<A, B> FusedIterator for Zip<A, B>\n-    where A: FusedIterator, B: FusedIterator, {}\n-\n-#[unstable(feature = \"trusted_len\", issue = \"37572\")]\n-unsafe impl<A, B> TrustedLen for Zip<A, B>\n-    where A: TrustedLen, B: TrustedLen,\n-{}\n-\n /// An iterator that maps the values of `iter` with `f`.\n ///\n /// This `struct` is created by the [`map`] method on [`Iterator`]. See its"}, {"sha": "d2937f5d3e1470c65f9bcaa58d07bb0129914400", "filename": "src/libcore/iter/adapters/zip.rs", "status": "added", "additions": 261, "deletions": 0, "changes": 261, "blob_url": "https://github.com/rust-lang/rust/blob/3c44e1f08553af4309d16ab098522e57a057fabc/src%2Flibcore%2Fiter%2Fadapters%2Fzip.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3c44e1f08553af4309d16ab098522e57a057fabc/src%2Flibcore%2Fiter%2Fadapters%2Fzip.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter%2Fadapters%2Fzip.rs?ref=3c44e1f08553af4309d16ab098522e57a057fabc", "patch": "@@ -0,0 +1,261 @@\n+use cmp;\n+use iter_private::TrustedRandomAccess;\n+use super::super::{Iterator, DoubleEndedIterator, ExactSizeIterator, FusedIterator, TrustedLen};\n+\n+/// An iterator that iterates two other iterators simultaneously.\n+///\n+/// This `struct` is created by the [`zip`] method on [`Iterator`]. See its\n+/// documentation for more.\n+///\n+/// [`zip`]: trait.Iterator.html#method.zip\n+/// [`Iterator`]: trait.Iterator.html\n+#[derive(Clone, Debug)]\n+#[must_use = \"iterators are lazy and do nothing unless consumed\"]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+pub struct Zip<A, B> {\n+    a: A,\n+    b: B,\n+    // index and len are only used by the specialized version of zip\n+    index: usize,\n+    len: usize,\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<A, B> Iterator for Zip<A, B> where A: Iterator, B: Iterator\n+{\n+    type Item = (A::Item, B::Item);\n+\n+    #[inline]\n+    fn next(&mut self) -> Option<Self::Item> {\n+        ZipImpl::next(self)\n+    }\n+\n+    #[inline]\n+    fn size_hint(&self) -> (usize, Option<usize>) {\n+        ZipImpl::size_hint(self)\n+    }\n+\n+    #[inline]\n+    fn nth(&mut self, n: usize) -> Option<Self::Item> {\n+        ZipImpl::nth(self, n)\n+    }\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<A, B> DoubleEndedIterator for Zip<A, B> where\n+    A: DoubleEndedIterator + ExactSizeIterator,\n+    B: DoubleEndedIterator + ExactSizeIterator,\n+{\n+    #[inline]\n+    fn next_back(&mut self) -> Option<(A::Item, B::Item)> {\n+        ZipImpl::next_back(self)\n+    }\n+}\n+\n+// Zip specialization trait\n+#[doc(hidden)]\n+pub(in super::super) trait ZipImpl<A, B> {\n+    type Item;\n+    fn new(a: A, b: B) -> Self;\n+    fn next(&mut self) -> Option<Self::Item>;\n+    fn size_hint(&self) -> (usize, Option<usize>);\n+    fn nth(&mut self, n: usize) -> Option<Self::Item>;\n+    fn super_nth(&mut self, mut n: usize) -> Option<Self::Item> {\n+        while let Some(x) = self.next() {\n+            if n == 0 { return Some(x) }\n+            n -= 1;\n+        }\n+        None\n+    }\n+    fn next_back(&mut self) -> Option<Self::Item>\n+        where A: DoubleEndedIterator + ExactSizeIterator,\n+              B: DoubleEndedIterator + ExactSizeIterator;\n+}\n+\n+// General Zip impl\n+#[doc(hidden)]\n+impl<A, B> ZipImpl<A, B> for Zip<A, B>\n+    where A: Iterator, B: Iterator\n+{\n+    type Item = (A::Item, B::Item);\n+    default fn new(a: A, b: B) -> Self {\n+        Zip {\n+            a,\n+            b,\n+            index: 0, // unused\n+            len: 0, // unused\n+        }\n+    }\n+\n+    #[inline]\n+    default fn next(&mut self) -> Option<(A::Item, B::Item)> {\n+        self.a.next().and_then(|x| {\n+            self.b.next().and_then(|y| {\n+                Some((x, y))\n+            })\n+        })\n+    }\n+\n+    #[inline]\n+    default fn nth(&mut self, n: usize) -> Option<Self::Item> {\n+        self.super_nth(n)\n+    }\n+\n+    #[inline]\n+    default fn next_back(&mut self) -> Option<(A::Item, B::Item)>\n+        where A: DoubleEndedIterator + ExactSizeIterator,\n+              B: DoubleEndedIterator + ExactSizeIterator\n+    {\n+        let a_sz = self.a.len();\n+        let b_sz = self.b.len();\n+        if a_sz != b_sz {\n+            // Adjust a, b to equal length\n+            if a_sz > b_sz {\n+                for _ in 0..a_sz - b_sz { self.a.next_back(); }\n+            } else {\n+                for _ in 0..b_sz - a_sz { self.b.next_back(); }\n+            }\n+        }\n+        match (self.a.next_back(), self.b.next_back()) {\n+            (Some(x), Some(y)) => Some((x, y)),\n+            (None, None) => None,\n+            _ => unreachable!(),\n+        }\n+    }\n+\n+    #[inline]\n+    default fn size_hint(&self) -> (usize, Option<usize>) {\n+        let (a_lower, a_upper) = self.a.size_hint();\n+        let (b_lower, b_upper) = self.b.size_hint();\n+\n+        let lower = cmp::min(a_lower, b_lower);\n+\n+        let upper = match (a_upper, b_upper) {\n+            (Some(x), Some(y)) => Some(cmp::min(x,y)),\n+            (Some(x), None) => Some(x),\n+            (None, Some(y)) => Some(y),\n+            (None, None) => None\n+        };\n+\n+        (lower, upper)\n+    }\n+}\n+\n+#[doc(hidden)]\n+impl<A, B> ZipImpl<A, B> for Zip<A, B>\n+    where A: TrustedRandomAccess, B: TrustedRandomAccess\n+{\n+    fn new(a: A, b: B) -> Self {\n+        let len = cmp::min(a.len(), b.len());\n+        Zip {\n+            a,\n+            b,\n+            index: 0,\n+            len,\n+        }\n+    }\n+\n+    #[inline]\n+    fn next(&mut self) -> Option<(A::Item, B::Item)> {\n+        if self.index < self.len {\n+            let i = self.index;\n+            self.index += 1;\n+            unsafe {\n+                Some((self.a.get_unchecked(i), self.b.get_unchecked(i)))\n+            }\n+        } else if A::may_have_side_effect() && self.index < self.a.len() {\n+            // match the base implementation's potential side effects\n+            unsafe {\n+                self.a.get_unchecked(self.index);\n+            }\n+            self.index += 1;\n+            None\n+        } else {\n+            None\n+        }\n+    }\n+\n+    #[inline]\n+    fn size_hint(&self) -> (usize, Option<usize>) {\n+        let len = self.len - self.index;\n+        (len, Some(len))\n+    }\n+\n+    #[inline]\n+    fn nth(&mut self, n: usize) -> Option<Self::Item> {\n+        let delta = cmp::min(n, self.len - self.index);\n+        let end = self.index + delta;\n+        while self.index < end {\n+            let i = self.index;\n+            self.index += 1;\n+            if A::may_have_side_effect() {\n+                unsafe { self.a.get_unchecked(i); }\n+            }\n+            if B::may_have_side_effect() {\n+                unsafe { self.b.get_unchecked(i); }\n+            }\n+        }\n+\n+        self.super_nth(n - delta)\n+    }\n+\n+    #[inline]\n+    fn next_back(&mut self) -> Option<(A::Item, B::Item)>\n+        where A: DoubleEndedIterator + ExactSizeIterator,\n+              B: DoubleEndedIterator + ExactSizeIterator\n+    {\n+        // Adjust a, b to equal length\n+        if A::may_have_side_effect() {\n+            let sz = self.a.len();\n+            if sz > self.len {\n+                for _ in 0..sz - cmp::max(self.len, self.index) {\n+                    self.a.next_back();\n+                }\n+            }\n+        }\n+        if B::may_have_side_effect() {\n+            let sz = self.b.len();\n+            if sz > self.len {\n+                for _ in 0..sz - self.len {\n+                    self.b.next_back();\n+                }\n+            }\n+        }\n+        if self.index < self.len {\n+            self.len -= 1;\n+            let i = self.len;\n+            unsafe {\n+                Some((self.a.get_unchecked(i), self.b.get_unchecked(i)))\n+            }\n+        } else {\n+            None\n+        }\n+    }\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<A, B> ExactSizeIterator for Zip<A, B>\n+    where A: ExactSizeIterator, B: ExactSizeIterator {}\n+\n+#[doc(hidden)]\n+unsafe impl<A, B> TrustedRandomAccess for Zip<A, B>\n+    where A: TrustedRandomAccess,\n+          B: TrustedRandomAccess,\n+{\n+    unsafe fn get_unchecked(&mut self, i: usize) -> (A::Item, B::Item) {\n+        (self.a.get_unchecked(i), self.b.get_unchecked(i))\n+    }\n+\n+    fn may_have_side_effect() -> bool {\n+        A::may_have_side_effect() || B::may_have_side_effect()\n+    }\n+}\n+\n+#[stable(feature = \"fused\", since = \"1.26.0\")]\n+impl<A, B> FusedIterator for Zip<A, B>\n+    where A: FusedIterator, B: FusedIterator, {}\n+\n+#[unstable(feature = \"trusted_len\", issue = \"37572\")]\n+unsafe impl<A, B> TrustedLen for Zip<A, B>\n+    where A: TrustedLen, B: TrustedLen,\n+{}"}]}