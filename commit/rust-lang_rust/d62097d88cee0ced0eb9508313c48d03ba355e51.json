{"sha": "d62097d88cee0ced0eb9508313c48d03ba355e51", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQ2MjA5N2Q4OGNlZTBjZWQwZWI5NTA4MzEzYzQ4ZDAzYmEzNTVlNTE=", "commit": {"author": {"name": "Virgile Andreani", "email": "virgile.andreani@anbuco.fr", "date": "2014-01-29T09:27:58Z"}, "committer": {"name": "Virgile Andreani", "email": "virgile.andreani@anbuco.fr", "date": "2014-01-29T09:28:50Z"}, "message": "Document vector destructuring with wildcard '..'", "tree": {"sha": "95492c7dffe1d21ac77cbf01cc4dce20a0cb4555", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/95492c7dffe1d21ac77cbf01cc4dce20a0cb4555"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d62097d88cee0ced0eb9508313c48d03ba355e51", "comment_count": 5, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d62097d88cee0ced0eb9508313c48d03ba355e51", "html_url": "https://github.com/rust-lang/rust/commit/d62097d88cee0ced0eb9508313c48d03ba355e51", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d62097d88cee0ced0eb9508313c48d03ba355e51/comments", "author": {"login": "Armavica", "id": 5855503, "node_id": "MDQ6VXNlcjU4NTU1MDM=", "avatar_url": "https://avatars.githubusercontent.com/u/5855503?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Armavica", "html_url": "https://github.com/Armavica", "followers_url": "https://api.github.com/users/Armavica/followers", "following_url": "https://api.github.com/users/Armavica/following{/other_user}", "gists_url": "https://api.github.com/users/Armavica/gists{/gist_id}", "starred_url": "https://api.github.com/users/Armavica/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Armavica/subscriptions", "organizations_url": "https://api.github.com/users/Armavica/orgs", "repos_url": "https://api.github.com/users/Armavica/repos", "events_url": "https://api.github.com/users/Armavica/events{/privacy}", "received_events_url": "https://api.github.com/users/Armavica/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Armavica", "id": 5855503, "node_id": "MDQ6VXNlcjU4NTU1MDM=", "avatar_url": "https://avatars.githubusercontent.com/u/5855503?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Armavica", "html_url": "https://github.com/Armavica", "followers_url": "https://api.github.com/users/Armavica/followers", "following_url": "https://api.github.com/users/Armavica/following{/other_user}", "gists_url": "https://api.github.com/users/Armavica/gists{/gist_id}", "starred_url": "https://api.github.com/users/Armavica/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Armavica/subscriptions", "organizations_url": "https://api.github.com/users/Armavica/orgs", "repos_url": "https://api.github.com/users/Armavica/repos", "events_url": "https://api.github.com/users/Armavica/events{/privacy}", "received_events_url": "https://api.github.com/users/Armavica/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2b9392566c21ac25e25f1e9113598d914ba88490", "url": "https://api.github.com/repos/rust-lang/rust/commits/2b9392566c21ac25e25f1e9113598d914ba88490", "html_url": "https://github.com/rust-lang/rust/commit/2b9392566c21ac25e25f1e9113598d914ba88490"}], "stats": {"total": 51, "additions": 38, "deletions": 13}, "files": [{"sha": "9743868c9795358309e5d3c3a04f147f20c4e151", "filename": "doc/rust.md", "status": "modified", "additions": 38, "deletions": 13, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/d62097d88cee0ced0eb9508313c48d03ba355e51/doc%2Frust.md", "raw_url": "https://github.com/rust-lang/rust/raw/d62097d88cee0ced0eb9508313c48d03ba355e51/doc%2Frust.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Frust.md?ref=d62097d88cee0ced0eb9508313c48d03ba355e51", "patch": "@@ -2864,14 +2864,15 @@ match_pat : pat [ \"..\" pat ] ? [ \"if\" expr ] ;\n \n A `match` expression branches on a *pattern*. The exact form of matching that\n occurs depends on the pattern. Patterns consist of some combination of\n-literals, destructured enum constructors, structures, records and tuples, variable binding\n-specifications, wildcards (`..`), and placeholders (`_`). A `match` expression has a *head\n-expression*, which is the value to compare to the patterns. The type of the\n-patterns must equal the type of the head expression.\n+literals, destructured vectors or enum constructors, structures, records and\n+tuples, variable binding specifications, wildcards (`..`), and placeholders\n+(`_`). A `match` expression has a *head expression*, which is the value to\n+compare to the patterns. The type of the patterns must equal the type of the\n+head expression.\n \n-In a pattern whose head expression has an `enum` type, a placeholder (`_`) stands for a\n-*single* data field, whereas a wildcard `..` stands for *all* the fields of a particular\n-variant. For example:\n+In a pattern whose head expression has an `enum` type, a placeholder (`_`)\n+stands for a *single* data field, whereas a wildcard `..` stands for *all* the\n+fields of a particular variant. For example:\n \n ~~~~\n enum List<X> { Nil, Cons(X, ~List<X>) }\n@@ -2885,11 +2886,35 @@ match x {\n }\n ~~~~\n \n-The first pattern matches lists constructed by applying `Cons` to any head value, and a\n-tail value of `~Nil`. The second pattern matches _any_ list constructed with `Cons`,\n-ignoring the values of its arguments. The difference between `_` and `..` is that the pattern\n-`C(_)` is only type-correct if `C` has exactly one argument, while the pattern `C(..)` is\n-type-correct for any enum variant `C`, regardless of how many arguments `C` has.\n+The first pattern matches lists constructed by applying `Cons` to any head\n+value, and a tail value of `~Nil`. The second pattern matches _any_ list\n+constructed with `Cons`, ignoring the values of its arguments. The difference\n+between `_` and `..` is that the pattern `C(_)` is only type-correct if `C` has\n+exactly one argument, while the pattern `C(..)` is type-correct for any enum\n+variant `C`, regardless of how many arguments `C` has.\n+\n+Used inside a vector pattern, `..` stands for any number of elements. This\n+wildcard can be used at most once for a given vector, which implies that it\n+cannot be used to specifically match elements that are at an unknown distance\n+from both ends of a vector, like `[.., 42, ..]`. If followed by a variable name,\n+it will bind the corresponding slice to the variable. Example:\n+\n+~~~~\n+fn is_symmetric(list: &[uint]) -> bool {\n+    match list {\n+        [] | [_]                   => true,\n+        [x, ..inside, y] if x == y => is_symmetric(inside),\n+        _                          => false\n+    }\n+}\n+\n+fn main() {\n+    let sym     = &[0, 1, 4, 2, 4, 1, 0];\n+    let not_sym = &[0, 1, 7, 2, 4, 1, 0];\n+    assert!(is_symmetric(sym));\n+    assert!(!is_symmetric(not_sym));\n+}\n+~~~~\n \n A `match` behaves differently depending on whether or not the head expression\n is an [lvalue or an rvalue](#lvalues-rvalues-and-temporaries).\n@@ -2972,7 +2997,7 @@ let z = match x { &0 => \"zero\", _ => \"some\" };\n assert_eq!(y, z);\n ~~~~\n \n-A pattern that's just an identifier, like `Nil` in the previous answer,\n+A pattern that's just an identifier, like `Nil` in the previous example,\n could either refer to an enum variant that's in scope, or bind a new variable.\n The compiler resolves this ambiguity by forbidding variable bindings that occur\n in `match` patterns from shadowing names of variants that are in scope."}]}