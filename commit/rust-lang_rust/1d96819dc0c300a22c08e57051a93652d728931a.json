{"sha": "1d96819dc0c300a22c08e57051a93652d728931a", "node_id": "MDY6Q29tbWl0NzI0NzEyOjFkOTY4MTlkYzBjMzAwYTIyYzA4ZTU3MDUxYTkzNjUyZDcyODkzMWE=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2017-11-08T10:16:40Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2017-11-18T12:47:36Z"}, "message": "upvar.rs: rustfmt", "tree": {"sha": "794a623aab17b097a5975b1eb58b2faeacc787dc", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/794a623aab17b097a5975b1eb58b2faeacc787dc"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1d96819dc0c300a22c08e57051a93652d728931a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1d96819dc0c300a22c08e57051a93652d728931a", "html_url": "https://github.com/rust-lang/rust/commit/1d96819dc0c300a22c08e57051a93652d728931a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1d96819dc0c300a22c08e57051a93652d728931a/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "eab5b263e8a6189868caf7bd135e3ce127b57424", "url": "https://api.github.com/repos/rust-lang/rust/commits/eab5b263e8a6189868caf7bd135e3ce127b57424", "html_url": "https://github.com/rust-lang/rust/commit/eab5b263e8a6189868caf7bd135e3ce127b57424"}], "stats": {"total": 424, "additions": 236, "deletions": 188}, "files": [{"sha": "63cdac10321d44544e6b8a742cf8b254e872fc12", "filename": "src/librustc_typeck/check/upvar.rs", "status": "modified", "additions": 236, "deletions": 188, "changes": 424, "blob_url": "https://github.com/rust-lang/rust/blob/1d96819dc0c300a22c08e57051a93652d728931a/src%2Flibrustc_typeck%2Fcheck%2Fupvar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1d96819dc0c300a22c08e57051a93652d728931a/src%2Flibrustc_typeck%2Fcheck%2Fupvar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fupvar.rs?ref=1d96819dc0c300a22c08e57051a93652d728931a", "patch": "@@ -51,7 +51,7 @@ use syntax::ast;\n use syntax_pos::Span;\n use rustc::hir;\n use rustc::hir::def_id::LocalDefId;\n-use rustc::hir::intravisit::{self, Visitor, NestedVisitorMap};\n+use rustc::hir::intravisit::{self, NestedVisitorMap, Visitor};\n use rustc::util::nodemap::FxHashMap;\n \n use std::collections::hash_map::Entry;\n@@ -65,7 +65,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n     }\n }\n \n-struct InferBorrowKindVisitor<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n+struct InferBorrowKindVisitor<'a, 'gcx: 'a + 'tcx, 'tcx: 'a> {\n     fcx: &'a FnCtxt<'a, 'gcx, 'tcx>,\n }\n \n@@ -79,42 +79,45 @@ impl<'a, 'gcx, 'tcx> Visitor<'gcx> for InferBorrowKindVisitor<'a, 'gcx, 'tcx> {\n             hir::ExprClosure(cc, _, body_id, _, is_generator) => {\n                 let body = self.fcx.tcx.hir.body(body_id);\n                 self.visit_body(body);\n-                self.fcx.analyze_closure(expr.id,\n-                                         expr.hir_id,\n-                                         expr.span,\n-                                         body,\n-                                         cc,\n-                                         is_generator);\n+                self.fcx\n+                    .analyze_closure(expr.id, expr.hir_id, expr.span, body, cc, is_generator);\n             }\n \n-            _ => { }\n+            _ => {}\n         }\n \n         intravisit::walk_expr(self, expr);\n     }\n }\n \n impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n-    fn analyze_closure(&self,\n-                       closure_node_id: ast::NodeId,\n-                       closure_hir_id: hir::HirId,\n-                       span: Span,\n-                       body: &hir::Body,\n-                       capture_clause: hir::CaptureClause,\n-                       gen: bool) {\n+    fn analyze_closure(\n+        &self,\n+        closure_node_id: ast::NodeId,\n+        closure_hir_id: hir::HirId,\n+        span: Span,\n+        body: &hir::Body,\n+        capture_clause: hir::CaptureClause,\n+        gen: bool,\n+    ) {\n         /*!\n          * Analysis starting point.\n          */\n \n-        debug!(\"analyze_closure(id={:?}, body.id={:?})\", closure_node_id, body.id());\n+        debug!(\n+            \"analyze_closure(id={:?}, body.id={:?})\",\n+            closure_node_id,\n+            body.id()\n+        );\n \n         let infer_kind = if gen {\n             false\n         } else {\n             match self.tables\n-                      .borrow_mut()\n-                      .closure_kinds_mut()\n-                      .entry(closure_hir_id) {\n+                .borrow_mut()\n+                .closure_kinds_mut()\n+                .entry(closure_hir_id)\n+            {\n                 Entry::Occupied(_) => false,\n                 Entry::Vacant(entry) => {\n                     debug!(\"check_closure: adding closure {:?} as Fn\", closure_node_id);\n@@ -135,19 +138,22 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                 debug!(\"seed upvar_id {:?}\", upvar_id);\n \n                 let capture_kind = match capture_clause {\n-                    hir::CaptureByValue => {\n-                        ty::UpvarCapture::ByValue\n-                    }\n+                    hir::CaptureByValue => ty::UpvarCapture::ByValue,\n                     hir::CaptureByRef => {\n                         let origin = UpvarRegion(upvar_id, span);\n                         let freevar_region = self.next_region_var(origin);\n-                        let upvar_borrow = ty::UpvarBorrow { kind: ty::ImmBorrow,\n-                                                             region: freevar_region };\n+                        let upvar_borrow = ty::UpvarBorrow {\n+                            kind: ty::ImmBorrow,\n+                            region: freevar_region,\n+                        };\n                         ty::UpvarCapture::ByRef(upvar_borrow)\n                     }\n                 };\n \n-                self.tables.borrow_mut().upvar_capture_map.insert(upvar_id, capture_kind);\n+                self.tables\n+                    .borrow_mut()\n+                    .upvar_capture_map\n+                    .insert(upvar_id, capture_kind);\n             }\n         });\n \n@@ -159,25 +165,30 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                 adjust_closure_kinds: FxHashMap(),\n                 adjust_upvar_captures: ty::UpvarCaptureMap::default(),\n             };\n-            euv::ExprUseVisitor::with_infer(&mut delegate,\n-                                            &self.infcx,\n-                                            self.param_env,\n-                                            region_scope_tree,\n-                                            &self.tables.borrow())\n-                .consume_body(body);\n+            euv::ExprUseVisitor::with_infer(\n+                &mut delegate,\n+                &self.infcx,\n+                self.param_env,\n+                region_scope_tree,\n+                &self.tables.borrow(),\n+            ).consume_body(body);\n \n             // Write the adjusted values back into the main tables.\n             if infer_kind {\n-                if let Some(kind) = delegate.adjust_closure_kinds\n-                                            .remove(&closure_def_id.to_local()) {\n+                if let Some(kind) = delegate\n+                    .adjust_closure_kinds\n+                    .remove(&closure_def_id.to_local())\n+                {\n                     self.tables\n                         .borrow_mut()\n                         .closure_kinds_mut()\n                         .insert(closure_hir_id, kind);\n                 }\n             }\n-            self.tables.borrow_mut().upvar_capture_map.extend(\n-                delegate.adjust_upvar_captures);\n+            self.tables\n+                .borrow_mut()\n+                .upvar_capture_map\n+                .extend(delegate.adjust_upvar_captures);\n         }\n \n         // Now that we've analyzed the closure, we know how each\n@@ -194,31 +205,36 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n \n         // Extract the type variables UV0...UVn.\n         let (def_id, closure_substs) = match self.node_ty(closure_hir_id).sty {\n-            ty::TyClosure(def_id, substs) |\n-            ty::TyGenerator(def_id, substs, _) => (def_id, substs),\n+            ty::TyClosure(def_id, substs) | ty::TyGenerator(def_id, substs, _) => (def_id, substs),\n             ref t => {\n                 span_bug!(\n                     span,\n                     \"type of closure expr {:?} is not a closure {:?}\",\n-                    closure_node_id, t);\n+                    closure_node_id,\n+                    t\n+                );\n             }\n         };\n \n         // Equate the type variables with the actual types.\n         let final_upvar_tys = self.final_upvar_tys(closure_node_id);\n-        debug!(\"analyze_closure: id={:?} closure_substs={:?} final_upvar_tys={:?}\",\n-               closure_node_id, closure_substs, final_upvar_tys);\n-        for (upvar_ty, final_upvar_ty) in\n-            closure_substs.upvar_tys(def_id, self.tcx).zip(final_upvar_tys)\n+        debug!(\n+            \"analyze_closure: id={:?} closure_substs={:?} final_upvar_tys={:?}\",\n+            closure_node_id,\n+            closure_substs,\n+            final_upvar_tys\n+        );\n+        for (upvar_ty, final_upvar_ty) in closure_substs\n+            .upvar_tys(def_id, self.tcx)\n+            .zip(final_upvar_tys)\n         {\n             self.demand_eqtype(span, final_upvar_ty, upvar_ty);\n         }\n \n         // If we are also inferred the closure kind here,\n         // process any deferred resolutions.\n         if infer_kind {\n-            let deferred_call_resolutions =\n-                self.remove_deferred_call_resolutions(closure_def_id);\n+            let deferred_call_resolutions = self.remove_deferred_call_resolutions(closure_def_id);\n             for deferred_call_resolution in deferred_call_resolutions {\n                 deferred_call_resolution.resolve(self);\n             }\n@@ -236,51 +252,61 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         let closure_def_index = tcx.hir.local_def_id(closure_id);\n \n         tcx.with_freevars(closure_id, |freevars| {\n-            freevars.iter().map(|freevar| {\n-                let var_node_id = freevar.var_id();\n-                let var_hir_id = tcx.hir.node_to_hir_id(var_node_id);\n-                let freevar_ty = self.node_ty(var_hir_id);\n-                let upvar_id = ty::UpvarId {\n-                    var_id: var_hir_id,\n-                    closure_expr_id: LocalDefId::from_def_id(closure_def_index),\n-                };\n-                let capture = self.tables.borrow().upvar_capture(upvar_id);\n-\n-                debug!(\"var_id={:?} freevar_ty={:?} capture={:?}\",\n-                       var_node_id, freevar_ty, capture);\n-\n-                match capture {\n-                    ty::UpvarCapture::ByValue => freevar_ty,\n-                    ty::UpvarCapture::ByRef(borrow) =>\n-                        tcx.mk_ref(borrow.region,\n-                                    ty::TypeAndMut {\n-                                        ty: freevar_ty,\n-                                        mutbl: borrow.kind.to_mutbl_lossy(),\n-                                    }),\n-                }\n-            }).collect()\n+            freevars\n+                .iter()\n+                .map(|freevar| {\n+                    let var_node_id = freevar.var_id();\n+                    let var_hir_id = tcx.hir.node_to_hir_id(var_node_id);\n+                    let freevar_ty = self.node_ty(var_hir_id);\n+                    let upvar_id = ty::UpvarId {\n+                        var_id: var_hir_id,\n+                        closure_expr_id: LocalDefId::from_def_id(closure_def_index),\n+                    };\n+                    let capture = self.tables.borrow().upvar_capture(upvar_id);\n+\n+                    debug!(\n+                        \"var_id={:?} freevar_ty={:?} capture={:?}\",\n+                        var_node_id,\n+                        freevar_ty,\n+                        capture\n+                    );\n+\n+                    match capture {\n+                        ty::UpvarCapture::ByValue => freevar_ty,\n+                        ty::UpvarCapture::ByRef(borrow) => tcx.mk_ref(\n+                            borrow.region,\n+                            ty::TypeAndMut {\n+                                ty: freevar_ty,\n+                                mutbl: borrow.kind.to_mutbl_lossy(),\n+                            },\n+                        ),\n+                    }\n+                })\n+                .collect()\n         })\n     }\n }\n \n-struct InferBorrowKind<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n+struct InferBorrowKind<'a, 'gcx: 'a + 'tcx, 'tcx: 'a> {\n     fcx: &'a FnCtxt<'a, 'gcx, 'tcx>,\n     adjust_closure_kinds: FxHashMap<LocalDefId, (ty::ClosureKind, Option<(Span, ast::Name)>)>,\n     adjust_upvar_captures: ty::UpvarCaptureMap<'tcx>,\n }\n \n impl<'a, 'gcx, 'tcx> InferBorrowKind<'a, 'gcx, 'tcx> {\n-    fn adjust_upvar_borrow_kind_for_consume(&mut self,\n-                                            cmt: mc::cmt<'tcx>,\n-                                            mode: euv::ConsumeMode)\n-    {\n-        debug!(\"adjust_upvar_borrow_kind_for_consume(cmt={:?}, mode={:?})\",\n-               cmt, mode);\n+    fn adjust_upvar_borrow_kind_for_consume(&mut self, cmt: mc::cmt<'tcx>, mode: euv::ConsumeMode) {\n+        debug!(\n+            \"adjust_upvar_borrow_kind_for_consume(cmt={:?}, mode={:?})\",\n+            cmt,\n+            mode\n+        );\n \n         // we only care about moves\n         match mode {\n-            euv::Copy => { return; }\n-            euv::Move(_) => { }\n+            euv::Copy => {\n+                return;\n+            }\n+            euv::Move(_) => {}\n         }\n \n         let tcx = self.fcx.tcx;\n@@ -289,28 +315,39 @@ impl<'a, 'gcx, 'tcx> InferBorrowKind<'a, 'gcx, 'tcx> {\n         // for that to be legal, the upvar would have to be borrowed\n         // by value instead\n         let guarantor = cmt.guarantor();\n-        debug!(\"adjust_upvar_borrow_kind_for_consume: guarantor={:?}\",\n-               guarantor);\n-        debug!(\"adjust_upvar_borrow_kind_for_consume: guarantor.cat={:?}\",\n-               guarantor.cat);\n+        debug!(\n+            \"adjust_upvar_borrow_kind_for_consume: guarantor={:?}\",\n+            guarantor\n+        );\n+        debug!(\n+            \"adjust_upvar_borrow_kind_for_consume: guarantor.cat={:?}\",\n+            guarantor.cat\n+        );\n         match guarantor.cat {\n             Categorization::Deref(_, mc::BorrowedPtr(..)) |\n             Categorization::Deref(_, mc::Implicit(..)) => {\n-                debug!(\"adjust_upvar_borrow_kind_for_consume: found deref with note {:?}\",\n-                       cmt.note);\n+                debug!(\n+                    \"adjust_upvar_borrow_kind_for_consume: found deref with note {:?}\",\n+                    cmt.note\n+                );\n                 match guarantor.note {\n                     mc::NoteUpvarRef(upvar_id) => {\n-                        debug!(\"adjust_upvar_borrow_kind_for_consume: \\\n-                                setting upvar_id={:?} to by value\",\n-                               upvar_id);\n+                        debug!(\n+                            \"adjust_upvar_borrow_kind_for_consume: \\\n+                             setting upvar_id={:?} to by value\",\n+                            upvar_id\n+                        );\n \n                         // to move out of an upvar, this must be a FnOnce closure\n-                        self.adjust_closure_kind(upvar_id.closure_expr_id,\n-                                                 ty::ClosureKind::FnOnce,\n-                                                 guarantor.span,\n-                                                 var_name(tcx, upvar_id.var_id));\n-\n-                        self.adjust_upvar_captures.insert(upvar_id, ty::UpvarCapture::ByValue);\n+                        self.adjust_closure_kind(\n+                            upvar_id.closure_expr_id,\n+                            ty::ClosureKind::FnOnce,\n+                            guarantor.span,\n+                            var_name(tcx, upvar_id.var_id),\n+                        );\n+\n+                        self.adjust_upvar_captures\n+                            .insert(upvar_id, ty::UpvarCapture::ByValue);\n                     }\n                     mc::NoteClosureEnv(upvar_id) => {\n                         // we get just a closureenv ref if this is a\n@@ -319,25 +356,25 @@ impl<'a, 'gcx, 'tcx> InferBorrowKind<'a, 'gcx, 'tcx> {\n                         // must still adjust the kind of the closure\n                         // to be a FnOnce closure to permit moves out\n                         // of the environment.\n-                        self.adjust_closure_kind(upvar_id.closure_expr_id,\n-                                                 ty::ClosureKind::FnOnce,\n-                                                 guarantor.span,\n-                                                 var_name(tcx, upvar_id.var_id));\n-                    }\n-                    mc::NoteNone => {\n+                        self.adjust_closure_kind(\n+                            upvar_id.closure_expr_id,\n+                            ty::ClosureKind::FnOnce,\n+                            guarantor.span,\n+                            var_name(tcx, upvar_id.var_id),\n+                        );\n                     }\n+                    mc::NoteNone => {}\n                 }\n             }\n-            _ => { }\n+            _ => {}\n         }\n     }\n \n     /// Indicates that `cmt` is being directly mutated (e.g., assigned\n     /// to). If cmt contains any by-ref upvars, this implies that\n     /// those upvars must be borrowed using an `&mut` borrow.\n     fn adjust_upvar_borrow_kind_for_mut(&mut self, cmt: mc::cmt<'tcx>) {\n-        debug!(\"adjust_upvar_borrow_kind_for_mut(cmt={:?})\",\n-               cmt);\n+        debug!(\"adjust_upvar_borrow_kind_for_mut(cmt={:?})\", cmt);\n \n         match cmt.cat.clone() {\n             Categorization::Deref(base, mc::Unique) |\n@@ -370,8 +407,7 @@ impl<'a, 'gcx, 'tcx> InferBorrowKind<'a, 'gcx, 'tcx> {\n     }\n \n     fn adjust_upvar_borrow_kind_for_unique(&mut self, cmt: mc::cmt<'tcx>) {\n-        debug!(\"adjust_upvar_borrow_kind_for_unique(cmt={:?})\",\n-               cmt);\n+        debug!(\"adjust_upvar_borrow_kind_for_unique(cmt={:?})\", cmt);\n \n         match cmt.cat.clone() {\n             Categorization::Deref(base, mc::Unique) |\n@@ -395,16 +431,11 @@ impl<'a, 'gcx, 'tcx> InferBorrowKind<'a, 'gcx, 'tcx> {\n             Categorization::StaticItem |\n             Categorization::Rvalue(..) |\n             Categorization::Local(_) |\n-            Categorization::Upvar(..) => {\n-            }\n+            Categorization::Upvar(..) => {}\n         }\n     }\n \n-    fn try_adjust_upvar_deref(&mut self,\n-                              cmt: mc::cmt<'tcx>,\n-                              borrow_kind: ty::BorrowKind)\n-                              -> bool\n-    {\n+    fn try_adjust_upvar_deref(&mut self, cmt: mc::cmt<'tcx>, borrow_kind: ty::BorrowKind) -> bool {\n         assert!(match borrow_kind {\n             ty::MutBorrow => true,\n             ty::UniqueImmBorrow => true,\n@@ -424,27 +455,29 @@ impl<'a, 'gcx, 'tcx> InferBorrowKind<'a, 'gcx, 'tcx> {\n                 self.adjust_upvar_borrow_kind(upvar_id, borrow_kind);\n \n                 // also need to be in an FnMut closure since this is not an ImmBorrow\n-                self.adjust_closure_kind(upvar_id.closure_expr_id,\n-                                         ty::ClosureKind::FnMut,\n-                                         cmt.span,\n-                                         var_name(tcx, upvar_id.var_id));\n+                self.adjust_closure_kind(\n+                    upvar_id.closure_expr_id,\n+                    ty::ClosureKind::FnMut,\n+                    cmt.span,\n+                    var_name(tcx, upvar_id.var_id),\n+                );\n \n                 true\n             }\n             mc::NoteClosureEnv(upvar_id) => {\n                 // this kind of deref occurs in a `move` closure, or\n                 // for a by-value upvar; in either case, to mutate an\n                 // upvar, we need to be an FnMut closure\n-                self.adjust_closure_kind(upvar_id.closure_expr_id,\n-                                         ty::ClosureKind::FnMut,\n-                                         cmt.span,\n-                                         var_name(tcx, upvar_id.var_id));\n+                self.adjust_closure_kind(\n+                    upvar_id.closure_expr_id,\n+                    ty::ClosureKind::FnMut,\n+                    cmt.span,\n+                    var_name(tcx, upvar_id.var_id),\n+                );\n \n                 true\n             }\n-            mc::NoteNone => {\n-                false\n-            }\n+            mc::NoteNone => false,\n         }\n     }\n \n@@ -453,13 +486,17 @@ impl<'a, 'gcx, 'tcx> InferBorrowKind<'a, 'gcx, 'tcx> {\n     /// moving from left to right as needed (but never right to left).\n     /// Here the argument `mutbl` is the borrow_kind that is required by\n     /// some particular use.\n-    fn adjust_upvar_borrow_kind(&mut self,\n-                                upvar_id: ty::UpvarId,\n-                                kind: ty::BorrowKind) {\n-        let upvar_capture = self.adjust_upvar_captures.get(&upvar_id).cloned()\n+    fn adjust_upvar_borrow_kind(&mut self, upvar_id: ty::UpvarId, kind: ty::BorrowKind) {\n+        let upvar_capture = self.adjust_upvar_captures\n+            .get(&upvar_id)\n+            .cloned()\n             .unwrap_or_else(|| self.fcx.tables.borrow().upvar_capture(upvar_id));\n-        debug!(\"adjust_upvar_borrow_kind(upvar_id={:?}, upvar_capture={:?}, kind={:?})\",\n-               upvar_id, upvar_capture, kind);\n+        debug!(\n+            \"adjust_upvar_borrow_kind(upvar_id={:?}, upvar_capture={:?}, kind={:?})\",\n+            upvar_id,\n+            upvar_capture,\n+            kind\n+        );\n \n         match upvar_capture {\n             ty::UpvarCapture::ByValue => {\n@@ -472,37 +509,54 @@ impl<'a, 'gcx, 'tcx> InferBorrowKind<'a, 'gcx, 'tcx> {\n                     (ty::ImmBorrow, ty::MutBorrow) |\n                     (ty::UniqueImmBorrow, ty::MutBorrow) => {\n                         upvar_borrow.kind = kind;\n-                        self.adjust_upvar_captures.insert(upvar_id,\n-                            ty::UpvarCapture::ByRef(upvar_borrow));\n+                        self.adjust_upvar_captures\n+                            .insert(upvar_id, ty::UpvarCapture::ByRef(upvar_borrow));\n                     }\n                     // Take LHS:\n                     (ty::ImmBorrow, ty::ImmBorrow) |\n                     (ty::UniqueImmBorrow, ty::ImmBorrow) |\n                     (ty::UniqueImmBorrow, ty::UniqueImmBorrow) |\n-                    (ty::MutBorrow, _) => {\n-                    }\n+                    (ty::MutBorrow, _) => {}\n                 }\n             }\n         }\n     }\n \n-    fn adjust_closure_kind(&mut self,\n-                           closure_id: LocalDefId,\n-                           new_kind: ty::ClosureKind,\n-                           upvar_span: Span,\n-                           var_name: ast::Name) {\n-        debug!(\"adjust_closure_kind(closure_id={:?}, new_kind={:?}, upvar_span={:?}, var_name={})\",\n-               closure_id, new_kind, upvar_span, var_name);\n-\n-        let closure_kind = self.adjust_closure_kinds.get(&closure_id).cloned()\n+    fn adjust_closure_kind(\n+        &mut self,\n+        closure_id: LocalDefId,\n+        new_kind: ty::ClosureKind,\n+        upvar_span: Span,\n+        var_name: ast::Name,\n+    ) {\n+        debug!(\n+            \"adjust_closure_kind(closure_id={:?}, new_kind={:?}, upvar_span={:?}, var_name={})\",\n+            closure_id,\n+            new_kind,\n+            upvar_span,\n+            var_name\n+        );\n+\n+        let closure_kind = self.adjust_closure_kinds\n+            .get(&closure_id)\n+            .cloned()\n             .or_else(|| {\n                 let closure_id = self.fcx.tcx.hir.local_def_id_to_hir_id(closure_id);\n-                self.fcx.tables.borrow().closure_kinds().get(closure_id).cloned()\n+                self.fcx\n+                    .tables\n+                    .borrow()\n+                    .closure_kinds()\n+                    .get(closure_id)\n+                    .cloned()\n             });\n \n         if let Some((existing_kind, _)) = closure_kind {\n-            debug!(\"adjust_closure_kind: closure_id={:?}, existing_kind={:?}, new_kind={:?}\",\n-                   closure_id, existing_kind, new_kind);\n+            debug!(\n+                \"adjust_closure_kind: closure_id={:?}, existing_kind={:?}, new_kind={:?}\",\n+                closure_id,\n+                existing_kind,\n+                new_kind\n+            );\n \n             match (existing_kind, new_kind) {\n                 (ty::ClosureKind::Fn, ty::ClosureKind::Fn) |\n@@ -516,55 +570,52 @@ impl<'a, 'gcx, 'tcx> InferBorrowKind<'a, 'gcx, 'tcx> {\n                 (ty::ClosureKind::Fn, ty::ClosureKind::FnOnce) |\n                 (ty::ClosureKind::FnMut, ty::ClosureKind::FnOnce) => {\n                     // new kind is stronger than the old kind\n-                    self.adjust_closure_kinds.insert(\n-                        closure_id,\n-                        (new_kind, Some((upvar_span, var_name)))\n-                    );\n+                    self.adjust_closure_kinds\n+                        .insert(closure_id, (new_kind, Some((upvar_span, var_name))));\n                 }\n             }\n         }\n     }\n }\n \n impl<'a, 'gcx, 'tcx> euv::Delegate<'tcx> for InferBorrowKind<'a, 'gcx, 'tcx> {\n-    fn consume(&mut self,\n-               _consume_id: ast::NodeId,\n-               _consume_span: Span,\n-               cmt: mc::cmt<'tcx>,\n-               mode: euv::ConsumeMode)\n-    {\n+    fn consume(\n+        &mut self,\n+        _consume_id: ast::NodeId,\n+        _consume_span: Span,\n+        cmt: mc::cmt<'tcx>,\n+        mode: euv::ConsumeMode,\n+    ) {\n         debug!(\"consume(cmt={:?},mode={:?})\", cmt, mode);\n         self.adjust_upvar_borrow_kind_for_consume(cmt, mode);\n     }\n \n-    fn matched_pat(&mut self,\n-                   _matched_pat: &hir::Pat,\n-                   _cmt: mc::cmt<'tcx>,\n-                   _mode: euv::MatchMode)\n-    {}\n-\n-    fn consume_pat(&mut self,\n-                   _consume_pat: &hir::Pat,\n-                   cmt: mc::cmt<'tcx>,\n-                   mode: euv::ConsumeMode)\n-    {\n+    fn matched_pat(&mut self, _matched_pat: &hir::Pat, _cmt: mc::cmt<'tcx>, _mode: euv::MatchMode) {\n+    }\n+\n+    fn consume_pat(&mut self, _consume_pat: &hir::Pat, cmt: mc::cmt<'tcx>, mode: euv::ConsumeMode) {\n         debug!(\"consume_pat(cmt={:?},mode={:?})\", cmt, mode);\n         self.adjust_upvar_borrow_kind_for_consume(cmt, mode);\n     }\n \n-    fn borrow(&mut self,\n-              borrow_id: ast::NodeId,\n-              _borrow_span: Span,\n-              cmt: mc::cmt<'tcx>,\n-              _loan_region: ty::Region<'tcx>,\n-              bk: ty::BorrowKind,\n-              _loan_cause: euv::LoanCause)\n-    {\n-        debug!(\"borrow(borrow_id={}, cmt={:?}, bk={:?})\",\n-               borrow_id, cmt, bk);\n+    fn borrow(\n+        &mut self,\n+        borrow_id: ast::NodeId,\n+        _borrow_span: Span,\n+        cmt: mc::cmt<'tcx>,\n+        _loan_region: ty::Region<'tcx>,\n+        bk: ty::BorrowKind,\n+        _loan_cause: euv::LoanCause,\n+    ) {\n+        debug!(\n+            \"borrow(borrow_id={}, cmt={:?}, bk={:?})\",\n+            borrow_id,\n+            cmt,\n+            bk\n+        );\n \n         match bk {\n-            ty::ImmBorrow => { }\n+            ty::ImmBorrow => {}\n             ty::UniqueImmBorrow => {\n                 self.adjust_upvar_borrow_kind_for_unique(cmt);\n             }\n@@ -574,19 +625,16 @@ impl<'a, 'gcx, 'tcx> euv::Delegate<'tcx> for InferBorrowKind<'a, 'gcx, 'tcx> {\n         }\n     }\n \n-    fn decl_without_init(&mut self,\n-                         _id: ast::NodeId,\n-                         _span: Span)\n-    {}\n-\n-    fn mutate(&mut self,\n-              _assignment_id: ast::NodeId,\n-              _assignment_span: Span,\n-              assignee_cmt: mc::cmt<'tcx>,\n-              _mode: euv::MutateMode)\n-    {\n-        debug!(\"mutate(assignee_cmt={:?})\",\n-               assignee_cmt);\n+    fn decl_without_init(&mut self, _id: ast::NodeId, _span: Span) {}\n+\n+    fn mutate(\n+        &mut self,\n+        _assignment_id: ast::NodeId,\n+        _assignment_span: Span,\n+        assignee_cmt: mc::cmt<'tcx>,\n+        _mode: euv::MutateMode,\n+    ) {\n+        debug!(\"mutate(assignee_cmt={:?})\", assignee_cmt);\n \n         self.adjust_upvar_borrow_kind_for_mut(assignee_cmt);\n     }"}]}