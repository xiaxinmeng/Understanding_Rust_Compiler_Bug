{"sha": "e053dfad23515f7020171ae18013b230531a6042", "node_id": "MDY6Q29tbWl0NzI0NzEyOmUwNTNkZmFkMjM1MTVmNzAyMDE3MWFlMTgwMTNiMjMwNTMxYTYwNDI=", "commit": {"author": {"name": "Ariel Ben-Yehuda", "email": "ariel.byd@gmail.com", "date": "2014-10-14T20:40:21Z"}, "committer": {"name": "Ariel Ben-Yehuda", "email": "ariel.byd@gmail.com", "date": "2014-10-15T11:17:34Z"}, "message": "Add a compile-time error when oversized types are used\n\nLLVM generates wrong code (which may be an instance of compile-time UB) when\nfaced with types that take lots of memory - bigger than the address space.\nMake using such types a trans error. While trans errors are bad, overbig\ntypes are expected to be very rare.", "tree": {"sha": "bc376c46bf15fd3c5bc3d3ab79a2889f00d872bf", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/bc376c46bf15fd3c5bc3d3ab79a2889f00d872bf"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e053dfad23515f7020171ae18013b230531a6042", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e053dfad23515f7020171ae18013b230531a6042", "html_url": "https://github.com/rust-lang/rust/commit/e053dfad23515f7020171ae18013b230531a6042", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e053dfad23515f7020171ae18013b230531a6042/comments", "author": {"login": "arielb1", "id": 1830974, "node_id": "MDQ6VXNlcjE4MzA5NzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1830974?v=4", "gravatar_id": "", "url": "https://api.github.com/users/arielb1", "html_url": "https://github.com/arielb1", "followers_url": "https://api.github.com/users/arielb1/followers", "following_url": "https://api.github.com/users/arielb1/following{/other_user}", "gists_url": "https://api.github.com/users/arielb1/gists{/gist_id}", "starred_url": "https://api.github.com/users/arielb1/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/arielb1/subscriptions", "organizations_url": "https://api.github.com/users/arielb1/orgs", "repos_url": "https://api.github.com/users/arielb1/repos", "events_url": "https://api.github.com/users/arielb1/events{/privacy}", "received_events_url": "https://api.github.com/users/arielb1/received_events", "type": "User", "site_admin": false}, "committer": {"login": "arielb1", "id": 1830974, "node_id": "MDQ6VXNlcjE4MzA5NzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1830974?v=4", "gravatar_id": "", "url": "https://api.github.com/users/arielb1", "html_url": "https://github.com/arielb1", "followers_url": "https://api.github.com/users/arielb1/followers", "following_url": "https://api.github.com/users/arielb1/following{/other_user}", "gists_url": "https://api.github.com/users/arielb1/gists{/gist_id}", "starred_url": "https://api.github.com/users/arielb1/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/arielb1/subscriptions", "organizations_url": "https://api.github.com/users/arielb1/orgs", "repos_url": "https://api.github.com/users/arielb1/repos", "events_url": "https://api.github.com/users/arielb1/events{/privacy}", "received_events_url": "https://api.github.com/users/arielb1/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "01d693b1cdc8b2b6aee2b78f0ef89540427029be", "url": "https://api.github.com/repos/rust-lang/rust/commits/01d693b1cdc8b2b6aee2b78f0ef89540427029be", "html_url": "https://github.com/rust-lang/rust/commit/01d693b1cdc8b2b6aee2b78f0ef89540427029be"}], "stats": {"total": 207, "additions": 142, "deletions": 65}, "files": [{"sha": "66d4b3d804a942304d77aa5f684773e9d3423a14", "filename": "src/librustc/middle/trans/adt.rs", "status": "modified", "additions": 87, "deletions": 43, "changes": 130, "blob_url": "https://github.com/rust-lang/rust/blob/e053dfad23515f7020171ae18013b230531a6042/src%2Flibrustc%2Fmiddle%2Ftrans%2Fadt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e053dfad23515f7020171ae18013b230531a6042/src%2Flibrustc%2Fmiddle%2Ftrans%2Fadt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fadt.rs?ref=e053dfad23515f7020171ae18013b230531a6042", "patch": "@@ -163,7 +163,7 @@ pub fn represent_type(cx: &CrateContext, t: ty::t) -> Rc<Repr> {\n fn represent_type_uncached(cx: &CrateContext, t: ty::t) -> Repr {\n     match ty::get(t).sty {\n         ty::ty_tup(ref elems) => {\n-            return Univariant(mk_struct(cx, elems.as_slice(), false), false)\n+            return Univariant(mk_struct(cx, elems.as_slice(), false, t), false)\n         }\n         ty::ty_struct(def_id, ref substs) => {\n             let fields = ty::lookup_struct_fields(cx.tcx(), def_id);\n@@ -174,12 +174,12 @@ fn represent_type_uncached(cx: &CrateContext, t: ty::t) -> Repr {\n             let dtor = ty::ty_dtor(cx.tcx(), def_id).has_drop_flag();\n             if dtor { ftys.push(ty::mk_bool()); }\n \n-            return Univariant(mk_struct(cx, ftys.as_slice(), packed), dtor)\n+            return Univariant(mk_struct(cx, ftys.as_slice(), packed, t), dtor)\n         }\n         ty::ty_unboxed_closure(def_id, _) => {\n             let upvars = ty::unboxed_closure_upvars(cx.tcx(), def_id);\n             let upvar_types = upvars.iter().map(|u| u.ty).collect::<Vec<_>>();\n-            return Univariant(mk_struct(cx, upvar_types.as_slice(), false),\n+            return Univariant(mk_struct(cx, upvar_types.as_slice(), false, t),\n                               false)\n         }\n         ty::ty_enum(def_id, ref substs) => {\n@@ -194,7 +194,8 @@ fn represent_type_uncached(cx: &CrateContext, t: ty::t) -> Repr {\n                 // (Typechecking will reject discriminant-sizing attrs.)\n                 assert_eq!(hint, attr::ReprAny);\n                 let ftys = if dtor { vec!(ty::mk_bool()) } else { vec!() };\n-                return Univariant(mk_struct(cx, ftys.as_slice(), false), dtor);\n+                return Univariant(mk_struct(cx, ftys.as_slice(), false, t),\n+                                  dtor);\n             }\n \n             if !dtor && cases.iter().all(|c| c.tys.len() == 0) {\n@@ -225,15 +226,17 @@ fn represent_type_uncached(cx: &CrateContext, t: ty::t) -> Repr {\n                 assert_eq!(hint, attr::ReprAny);\n                 let mut ftys = cases.get(0).tys.clone();\n                 if dtor { ftys.push(ty::mk_bool()); }\n-                return Univariant(mk_struct(cx, ftys.as_slice(), false), dtor);\n+                return Univariant(mk_struct(cx, ftys.as_slice(), false, t),\n+                                  dtor);\n             }\n \n             if !dtor && cases.len() == 2 && hint == attr::ReprAny {\n                 // Nullable pointer optimization\n                 let mut discr = 0;\n                 while discr < 2 {\n-                    if cases.get(1 - discr).is_zerolen(cx) {\n-                        let st = mk_struct(cx, cases.get(discr).tys.as_slice(), false);\n+                    if cases.get(1 - discr).is_zerolen(cx, t) {\n+                        let st = mk_struct(cx, cases.get(discr).tys.as_slice(),\n+                                           false, t);\n                         match cases.get(discr).find_ptr() {\n                             Some(ThinPointer(_)) if st.fields.len() == 1 => {\n                                 return RawNullablePointer {\n@@ -263,11 +266,15 @@ fn represent_type_uncached(cx: &CrateContext, t: ty::t) -> Repr {\n                                      slo: 0, shi: (cases.len() - 1) as i64 };\n             let ity = range_to_inttype(cx, hint, &bounds);\n \n-            return General(ity, cases.iter().map(|c| {\n+            let fields : Vec<_> = cases.iter().map(|c| {\n                 let mut ftys = vec!(ty_of_inttype(ity)).append(c.tys.as_slice());\n                 if dtor { ftys.push(ty::mk_bool()); }\n-                mk_struct(cx, ftys.as_slice(), false)\n-            }).collect(), dtor);\n+                mk_struct(cx, ftys.as_slice(), false, t)\n+            }).collect();\n+\n+            ensure_enum_fits_in_address_space(cx, ity, fields.as_slice(), t);\n+\n+            General(ity, fields, dtor)\n         }\n         _ => cx.sess().bug(format!(\"adt::represent_type called on non-ADT type: {}\",\n                            ty_to_string(cx.tcx(), t)).as_slice())\n@@ -288,8 +295,8 @@ pub enum PointerField {\n }\n \n impl Case {\n-    fn is_zerolen(&self, cx: &CrateContext) -> bool {\n-        mk_struct(cx, self.tys.as_slice(), false).size == 0\n+    fn is_zerolen(&self, cx: &CrateContext, scapegoat: ty::t) -> bool {\n+        mk_struct(cx, self.tys.as_slice(), false, scapegoat).size == 0\n     }\n \n     fn find_ptr(&self) -> Option<PointerField> {\n@@ -344,29 +351,25 @@ fn get_cases(tcx: &ty::ctxt, def_id: ast::DefId, substs: &subst::Substs) -> Vec<\n     }).collect()\n }\n \n-fn mk_struct(cx: &CrateContext, tys: &[ty::t], packed: bool) -> Struct {\n-    if tys.iter().all(|&ty| ty::type_is_sized(cx.tcx(), ty)) {\n-        let lltys = tys.iter().map(|&ty| type_of::sizing_type_of(cx, ty)).collect::<Vec<_>>();\n-        let llty_rec = Type::struct_(cx, lltys.as_slice(), packed);\n-        Struct {\n-            size: machine::llsize_of_alloc(cx, llty_rec),\n-            align: machine::llalign_of_min(cx, llty_rec),\n-            sized: true,\n-            packed: packed,\n-            fields: Vec::from_slice(tys),\n-        }\n+fn mk_struct(cx: &CrateContext, tys: &[ty::t], packed: bool, scapegoat: ty::t) -> Struct {\n+    let sized = tys.iter().all(|&ty| ty::type_is_sized(cx.tcx(), ty));\n+    let lltys : Vec<Type> = if sized {\n+        tys.iter()\n+           .map(|&ty| type_of::sizing_type_of(cx, ty)).collect()\n     } else {\n-        // Ignore any dynamically sized fields.\n-        let lltys = tys.iter().filter(|&ty| ty::type_is_sized(cx.tcx(), *ty))\n-            .map(|&ty| type_of::sizing_type_of(cx, ty)).collect::<Vec<_>>();\n-        let llty_rec = Type::struct_(cx, lltys.as_slice(), packed);\n-        Struct {\n-            size: machine::llsize_of_alloc(cx, llty_rec),\n-            align: machine::llalign_of_min(cx, llty_rec),\n-            sized: false,\n-            packed: packed,\n-            fields: Vec::from_slice(tys),\n-        }\n+        tys.iter().filter(|&ty| ty::type_is_sized(cx.tcx(), *ty))\n+           .map(|&ty| type_of::sizing_type_of(cx, ty)).collect()\n+    };\n+\n+    ensure_struct_fits_in_address_space(cx, lltys.as_slice(), packed, scapegoat);\n+\n+    let llty_rec = Type::struct_(cx, lltys.as_slice(), packed);\n+    Struct {\n+        size: machine::llsize_of_alloc(cx, llty_rec),\n+        align: machine::llalign_of_min(cx, llty_rec),\n+        sized: sized,\n+        packed: packed,\n+        fields: Vec::from_slice(tys),\n     }\n }\n \n@@ -461,6 +464,48 @@ pub fn ty_of_inttype(ity: IntType) -> ty::t {\n     }\n }\n \n+// LLVM doesn't like types that don't fit in the address space\n+fn ensure_struct_fits_in_address_space(ccx: &CrateContext,\n+                                       fields: &[Type],\n+                                       packed: bool,\n+                                       scapegoat: ty::t) {\n+    let mut offset = 0;\n+    for &llty in fields.iter() {\n+        if !packed {\n+            let type_align = machine::llalign_of_min(ccx, llty);\n+            offset = roundup(offset, type_align);\n+        }\n+        offset += machine::llsize_of_alloc(ccx, llty);\n+\n+        // We can get away with checking for overflow once per iteration,\n+        // because field sizes are less than 1<<60.\n+        if offset >= ccx.max_obj_size() {\n+            ccx.report_overbig_object(scapegoat);\n+        }\n+    }\n+}\n+\n+fn union_size_and_align(sts: &[Struct]) -> (machine::llsize, machine::llalign) {\n+    let size = sts.iter().map(|st| st.size).max().unwrap();\n+    let most_aligned = sts.iter().max_by(|st| st.align).unwrap();\n+    (size, most_aligned.align)\n+}\n+\n+fn ensure_enum_fits_in_address_space(ccx: &CrateContext,\n+                                     discr: IntType,\n+                                     fields: &[Struct],\n+                                     scapegoat: ty::t) {\n+    let discr_size = machine::llsize_of_alloc(ccx, ll_inttype(ccx, discr));\n+    let (field_size, field_align) = union_size_and_align(fields);\n+\n+    // This can't overflow because field_size, discr_size, field_align < 1<<60\n+    let total_size = roundup(discr_size, field_align) + field_size;\n+\n+    if total_size >= ccx.max_obj_size() {\n+        ccx.report_overbig_object(scapegoat);\n+    }\n+}\n+\n \n /**\n  * LLVM-level types are a little complicated.\n@@ -523,13 +568,12 @@ fn generic_type_of(cx: &CrateContext,\n             // of the size.\n             //\n             // FIXME #10604: this breaks when vector types are present.\n-            let size = sts.iter().map(|st| st.size).max().unwrap();\n-            let most_aligned = sts.iter().max_by(|st| st.align).unwrap();\n-            let align = most_aligned.align;\n+            let (size, align) = union_size_and_align(sts.as_slice());\n+            let align_s = align as u64;\n             let discr_ty = ll_inttype(cx, ity);\n-            let discr_size = machine::llsize_of_alloc(cx, discr_ty) as u64;\n-            let align_units = (size + align - 1) / align - 1;\n-            let pad_ty = match align {\n+            let discr_size = machine::llsize_of_alloc(cx, discr_ty);\n+            let align_units = (size + align_s - 1) / align_s - 1;\n+            let pad_ty = match align_s {\n                 1 => Type::array(&Type::i8(cx), align_units),\n                 2 => Type::array(&Type::i16(cx), align_units),\n                 4 => Type::array(&Type::i32(cx), align_units),\n@@ -539,10 +583,10 @@ fn generic_type_of(cx: &CrateContext,\n                                                               align_units),\n                 _ => fail!(\"unsupported enum alignment: {:?}\", align)\n             };\n-            assert_eq!(machine::llalign_of_min(cx, pad_ty) as u64, align);\n-            assert_eq!(align % discr_size, 0);\n+            assert_eq!(machine::llalign_of_min(cx, pad_ty), align);\n+            assert_eq!(align_s % discr_size, 0);\n             let fields = vec!(discr_ty,\n-                           Type::array(&discr_ty, align / discr_size - 1),\n+                           Type::array(&discr_ty, align_s / discr_size - 1),\n                            pad_ty);\n             match name {\n                 None => Type::struct_(cx, fields.as_slice(), false),"}, {"sha": "0ef9cde56f91b6bde5de5f02210dd87ec2b59c2b", "filename": "src/librustc/middle/trans/context.rs", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/e053dfad23515f7020171ae18013b230531a6042/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e053dfad23515f7020171ae18013b230531a6042/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontext.rs?ref=e053dfad23515f7020171ae18013b230531a6042", "patch": "@@ -25,6 +25,7 @@ use middle::trans::debuginfo;\n use middle::trans::monomorphize::MonoId;\n use middle::trans::type_::{Type, TypeNames};\n use middle::ty;\n+use util::ppaux::Repr;\n use util::sha2::Sha256;\n use util::nodemap::{NodeMap, NodeSet, DefIdMap};\n \n@@ -717,6 +718,16 @@ impl<'b, 'tcx> CrateContext<'b, 'tcx> {\n     pub fn trait_cache(&self) -> &RefCell<HashMap<Rc<ty::TraitRef>, traits::Vtable<()>>> {\n         &self.local.trait_cache\n     }\n+\n+    pub fn max_obj_size(&self) -> u64 {\n+        1<<31 /* FIXME: select based on architecture */\n+    }\n+\n+    pub fn report_overbig_object(&self, obj: ty::t) -> ! {\n+        self.sess().fatal(\n+            format!(\"Objects of type `{}` are too big for the current ABI\",\n+                    obj.repr(self.tcx())).as_slice())\n+    }\n }\n \n fn declare_intrinsic(ccx: &CrateContext, key: & &'static str) -> Option<ValueRef> {"}, {"sha": "87b63478ea1ed087b6022d660104064de0ffa371", "filename": "src/librustc/middle/trans/type_of.rs", "status": "modified", "additions": 44, "deletions": 22, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/e053dfad23515f7020171ae18013b230531a6042/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_of.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e053dfad23515f7020171ae18013b230531a6042/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_of.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_of.rs?ref=e053dfad23515f7020171ae18013b230531a6042", "patch": "@@ -24,6 +24,20 @@ use middle::trans::type_::Type;\n use syntax::abi;\n use syntax::ast;\n \n+use std::num::CheckedMul;\n+\n+// LLVM doesn't like objects that are too big. Issue #17913\n+fn ensure_array_fits_in_address_space(ccx: &CrateContext,\n+                                       llet: Type,\n+                                       size: machine::llsize,\n+                                       scapegoat: ty::t) {\n+    let esz = machine::llsize_of_alloc(ccx, llet);\n+    match esz.checked_mul(&size) {\n+        Some(n) if n < ccx.max_obj_size() => {}\n+        _ => { ccx.report_overbig_object(scapegoat) }\n+    }\n+}\n+\n pub fn arg_is_indirect(ccx: &CrateContext, arg_ty: ty::t) -> bool {\n     !type_is_immediate(ccx, arg_ty)\n }\n@@ -186,7 +200,10 @@ pub fn sizing_type_of(cx: &CrateContext, t: ty::t) -> Type {\n         ty::ty_closure(..) => Type::struct_(cx, [Type::i8p(cx), Type::i8p(cx)], false),\n \n         ty::ty_vec(ty, Some(size)) => {\n-            Type::array(&sizing_type_of(cx, ty), size as u64)\n+            let llty = sizing_type_of(cx, ty);\n+            let size = size as u64;\n+            ensure_array_fits_in_address_space(cx, llty, size, t);\n+            Type::array(&llty, size)\n         }\n \n         ty::ty_tup(..) | ty::ty_enum(..) | ty::ty_unboxed_closure(..) => {\n@@ -196,9 +213,10 @@ pub fn sizing_type_of(cx: &CrateContext, t: ty::t) -> Type {\n \n         ty::ty_struct(..) => {\n             if ty::type_is_simd(cx.tcx(), t) {\n-                let et = ty::simd_type(cx.tcx(), t);\n-                let n = ty::simd_size(cx.tcx(), t);\n-                Type::vector(&type_of(cx, et), n as u64)\n+                let llet = type_of(cx, ty::simd_type(cx.tcx(), t));\n+                let n = ty::simd_size(cx.tcx(), t) as u64;\n+                ensure_array_fits_in_address_space(cx, llet, n, t);\n+                Type::vector(&llet, n)\n             } else {\n                 let repr = adt::represent_type(cx, t);\n                 adt::sizing_type_of(cx, &*repr, false)\n@@ -282,21 +300,21 @@ pub fn type_of(cx: &CrateContext, t: ty::t) -> Type {\n       ty::ty_uint(t) => Type::uint_from_ty(cx, t),\n       ty::ty_float(t) => Type::float_from_ty(cx, t),\n       ty::ty_enum(did, ref substs) => {\n-        // Only create the named struct, but don't fill it in. We\n-        // fill it in *after* placing it into the type cache. This\n-        // avoids creating more than one copy of the enum when one\n-        // of the enum's variants refers to the enum itself.\n-        let repr = adt::represent_type(cx, t);\n-        let tps = substs.types.get_slice(subst::TypeSpace);\n-        let name = llvm_type_name(cx, an_enum, did, tps);\n-        adt::incomplete_type_of(cx, &*repr, name.as_slice())\n+          // Only create the named struct, but don't fill it in. We\n+          // fill it in *after* placing it into the type cache. This\n+          // avoids creating more than one copy of the enum when one\n+          // of the enum's variants refers to the enum itself.\n+          let repr = adt::represent_type(cx, t);\n+          let tps = substs.types.get_slice(subst::TypeSpace);\n+          let name = llvm_type_name(cx, an_enum, did, tps);\n+          adt::incomplete_type_of(cx, &*repr, name.as_slice())\n       }\n       ty::ty_unboxed_closure(did, _) => {\n-        // Only create the named struct, but don't fill it in. We\n-        // fill it in *after* placing it into the type cache.\n-        let repr = adt::represent_type(cx, t);\n-        let name = llvm_type_name(cx, an_unboxed_closure, did, []);\n-        adt::incomplete_type_of(cx, &*repr, name.as_slice())\n+          // Only create the named struct, but don't fill it in. We\n+          // fill it in *after* placing it into the type cache.\n+          let repr = adt::represent_type(cx, t);\n+          let name = llvm_type_name(cx, an_unboxed_closure, did, []);\n+          adt::incomplete_type_of(cx, &*repr, name.as_slice())\n       }\n \n       ty::ty_uniq(ty) | ty::ty_rptr(_, ty::mt{ty, ..}) | ty::ty_ptr(ty::mt{ty, ..}) => {\n@@ -315,8 +333,11 @@ pub fn type_of(cx: &CrateContext, t: ty::t) -> Type {\n           }\n       }\n \n-      ty::ty_vec(ty, Some(n)) => {\n-          Type::array(&type_of(cx, ty), n as u64)\n+      ty::ty_vec(ty, Some(size)) => {\n+          let size = size as u64;\n+          let llty = type_of(cx, ty);\n+          ensure_array_fits_in_address_space(cx, llty, size, t);\n+          Type::array(&llty, size)\n       }\n       ty::ty_vec(ty, None) => {\n           type_of(cx, ty)\n@@ -341,9 +362,10 @@ pub fn type_of(cx: &CrateContext, t: ty::t) -> Type {\n       }\n       ty::ty_struct(did, ref substs) => {\n           if ty::type_is_simd(cx.tcx(), t) {\n-              let et = ty::simd_type(cx.tcx(), t);\n-              let n = ty::simd_size(cx.tcx(), t);\n-              Type::vector(&type_of(cx, et), n as u64)\n+              let llet = type_of(cx, ty::simd_type(cx.tcx(), t));\n+              let n = ty::simd_size(cx.tcx(), t) as u64;\n+              ensure_array_fits_in_address_space(cx, llet, n, t);\n+              Type::vector(&llet, n)\n           } else {\n               // Only create the named struct, but don't fill it in. We fill it\n               // in *after* placing it into the type cache. This prevents"}]}