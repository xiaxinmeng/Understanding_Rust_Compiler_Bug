{"sha": "e49e7f6a2e62670704ec52e10f7639c17afe4f8e", "node_id": "C_kwDOAAsO6NoAKGU0OWU3ZjZhMmU2MjY3MDcwNGVjNTJlMTBmNzYzOWMxN2FmZTRmOGU", "commit": {"author": {"name": "Camille GILLOT", "email": "gillot.camille@gmail.com", "date": "2023-02-12T20:15:12Z"}, "committer": {"name": "Camille GILLOT", "email": "gillot.camille@gmail.com", "date": "2023-02-14T20:27:36Z"}, "message": "Do not fetch HIR to compute symbols.", "tree": {"sha": "7eda5fd4fef6fab229f5bf1a11ab0e42c93f165b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7eda5fd4fef6fab229f5bf1a11ab0e42c93f165b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e49e7f6a2e62670704ec52e10f7639c17afe4f8e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e49e7f6a2e62670704ec52e10f7639c17afe4f8e", "html_url": "https://github.com/rust-lang/rust/commit/e49e7f6a2e62670704ec52e10f7639c17afe4f8e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e49e7f6a2e62670704ec52e10f7639c17afe4f8e/comments", "author": {"login": "cjgillot", "id": 1822483, "node_id": "MDQ6VXNlcjE4MjI0ODM=", "avatar_url": "https://avatars.githubusercontent.com/u/1822483?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cjgillot", "html_url": "https://github.com/cjgillot", "followers_url": "https://api.github.com/users/cjgillot/followers", "following_url": "https://api.github.com/users/cjgillot/following{/other_user}", "gists_url": "https://api.github.com/users/cjgillot/gists{/gist_id}", "starred_url": "https://api.github.com/users/cjgillot/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cjgillot/subscriptions", "organizations_url": "https://api.github.com/users/cjgillot/orgs", "repos_url": "https://api.github.com/users/cjgillot/repos", "events_url": "https://api.github.com/users/cjgillot/events{/privacy}", "received_events_url": "https://api.github.com/users/cjgillot/received_events", "type": "User", "site_admin": false}, "committer": {"login": "cjgillot", "id": 1822483, "node_id": "MDQ6VXNlcjE4MjI0ODM=", "avatar_url": "https://avatars.githubusercontent.com/u/1822483?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cjgillot", "html_url": "https://github.com/cjgillot", "followers_url": "https://api.github.com/users/cjgillot/followers", "following_url": "https://api.github.com/users/cjgillot/following{/other_user}", "gists_url": "https://api.github.com/users/cjgillot/gists{/gist_id}", "starred_url": "https://api.github.com/users/cjgillot/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cjgillot/subscriptions", "organizations_url": "https://api.github.com/users/cjgillot/orgs", "repos_url": "https://api.github.com/users/cjgillot/repos", "events_url": "https://api.github.com/users/cjgillot/events{/privacy}", "received_events_url": "https://api.github.com/users/cjgillot/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0d39f9d94d2eddd31e4743ae1e3ea269bb3e0984", "url": "https://api.github.com/repos/rust-lang/rust/commits/0d39f9d94d2eddd31e4743ae1e3ea269bb3e0984", "html_url": "https://github.com/rust-lang/rust/commit/0d39f9d94d2eddd31e4743ae1e3ea269bb3e0984"}], "stats": {"total": 67, "additions": 34, "deletions": 33}, "files": [{"sha": "11bd47a8f0c7929d865cd9867a5e8003b8e4c512", "filename": "compiler/rustc_codegen_ssa/src/back/symbol_export.rs", "status": "modified", "additions": 34, "deletions": 33, "changes": 67, "blob_url": "https://github.com/rust-lang/rust/blob/e49e7f6a2e62670704ec52e10f7639c17afe4f8e/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Fsymbol_export.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e49e7f6a2e62670704ec52e10f7639c17afe4f8e/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Fsymbol_export.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Fsymbol_export.rs?ref=e49e7f6a2e62670704ec52e10f7639c17afe4f8e", "patch": "@@ -2,17 +2,16 @@ use std::collections::hash_map::Entry::*;\n \n use rustc_ast::expand::allocator::ALLOCATOR_METHODS;\n use rustc_data_structures::fx::FxHashMap;\n-use rustc_hir as hir;\n+use rustc_hir::def::DefKind;\n use rustc_hir::def_id::{CrateNum, DefId, DefIdMap, LocalDefId, LOCAL_CRATE};\n-use rustc_hir::Node;\n use rustc_middle::middle::codegen_fn_attrs::CodegenFnAttrFlags;\n use rustc_middle::middle::exported_symbols::{\n     metadata_symbol_name, ExportedSymbol, SymbolExportInfo, SymbolExportKind, SymbolExportLevel,\n };\n use rustc_middle::ty::query::{ExternProviders, Providers};\n use rustc_middle::ty::subst::{GenericArgKind, SubstsRef};\n use rustc_middle::ty::Instance;\n-use rustc_middle::ty::{self, SymbolName, TyCtxt};\n+use rustc_middle::ty::{self, DefIdTree, SymbolName, TyCtxt};\n use rustc_session::config::{CrateType, OomStrategy};\n use rustc_target::spec::SanitizerSet;\n \n@@ -74,32 +73,34 @@ fn reachable_non_generics_provider(tcx: TyCtxt<'_>, cnum: CrateNum) -> DefIdMap<\n             //\n             // As a result, if this id is an FFI item (foreign item) then we only\n             // let it through if it's included statically.\n-            match tcx.hir().get_by_def_id(def_id) {\n-                Node::ForeignItem(..) => {\n-                    tcx.native_library(def_id).map_or(false, |library| library.kind.is_statically_included()).then_some(def_id)\n-                }\n+            if let Some(parent_id) = tcx.opt_local_parent(def_id)\n+                && let DefKind::ForeignMod = tcx.def_kind(parent_id)\n+            {\n+                let library = tcx.native_library(def_id)?;\n+                return library.kind.is_statically_included().then_some(def_id);\n+            }\n \n-                // Only consider nodes that actually have exported symbols.\n-                Node::Item(&hir::Item {\n-                    kind: hir::ItemKind::Static(..) | hir::ItemKind::Fn(..),\n-                    ..\n-                })\n-                | Node::ImplItem(&hir::ImplItem { kind: hir::ImplItemKind::Fn(..), .. }) => {\n-                    let generics = tcx.generics_of(def_id);\n-                    if !generics.requires_monomorphization(tcx)\n-                        // Functions marked with #[inline] are codegened with \"internal\"\n-                        // linkage and are not exported unless marked with an extern\n-                        // indicator\n-                        && (!Instance::mono(tcx, def_id.to_def_id()).def.generates_cgu_internal_copy(tcx)\n-                            || tcx.codegen_fn_attrs(def_id.to_def_id()).contains_extern_indicator())\n-                    {\n-                        Some(def_id)\n-                    } else {\n-                        None\n-                    }\n-                }\n+            // Only consider nodes that actually have exported symbols.\n+            match tcx.def_kind(def_id) {\n+                DefKind::Fn | DefKind::Static(_) => {}\n+                DefKind::AssocFn if tcx.impl_of_method(def_id.to_def_id()).is_some() => {}\n+                _ => return None,\n+            };\n \n-                _ => None,\n+            let generics = tcx.generics_of(def_id);\n+            if generics.requires_monomorphization(tcx) {\n+                return None;\n+            }\n+\n+            // Functions marked with #[inline] are codegened with \"internal\"\n+            // linkage and are not exported unless marked with an extern\n+            // indicator\n+            if !Instance::mono(tcx, def_id.to_def_id()).def.generates_cgu_internal_copy(tcx)\n+                || tcx.codegen_fn_attrs(def_id.to_def_id()).contains_extern_indicator()\n+            {\n+                Some(def_id)\n+            } else {\n+                None\n             }\n         })\n         .map(|def_id| {\n@@ -118,7 +119,7 @@ fn reachable_non_generics_provider(tcx: TyCtxt<'_>, cnum: CrateNum) -> DefIdMap<\n                 tcx.symbol_name(Instance::mono(tcx, def_id.to_def_id())),\n                 export_level\n             );\n-            (def_id.to_def_id(), SymbolExportInfo {\n+            let info = SymbolExportInfo {\n                 level: export_level,\n                 kind: if tcx.is_static(def_id.to_def_id()) {\n                     if codegen_attrs.flags.contains(CodegenFnAttrFlags::THREAD_LOCAL) {\n@@ -130,8 +131,10 @@ fn reachable_non_generics_provider(tcx: TyCtxt<'_>, cnum: CrateNum) -> DefIdMap<\n                     SymbolExportKind::Text\n                 },\n                 used: codegen_attrs.flags.contains(CodegenFnAttrFlags::USED)\n-                    || codegen_attrs.flags.contains(CodegenFnAttrFlags::USED_LINKER) || used,\n-            })\n+                    || codegen_attrs.flags.contains(CodegenFnAttrFlags::USED_LINKER)\n+                    || used,\n+            };\n+            (def_id.to_def_id(), info)\n         })\n         .collect();\n \n@@ -457,9 +460,7 @@ fn symbol_export_level(tcx: TyCtxt<'_>, sym_def_id: DefId) -> SymbolExportLevel\n         let target = &tcx.sess.target.llvm_target;\n         // WebAssembly cannot export data symbols, so reduce their export level\n         if target.contains(\"emscripten\") {\n-            if let Some(Node::Item(&hir::Item { kind: hir::ItemKind::Static(..), .. })) =\n-                tcx.hir().get_if_local(sym_def_id)\n-            {\n+            if let DefKind::Static(_) = tcx.def_kind(sym_def_id) {\n                 return SymbolExportLevel::Rust;\n             }\n         }"}]}