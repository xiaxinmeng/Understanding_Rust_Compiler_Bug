{"sha": "6efdf4d1309f8047bc439a4810888c715e2df480", "node_id": "C_kwDOAAsO6NoAKDZlZmRmNGQxMzA5ZjgwNDdiYzQzOWE0ODEwODg4YzcxNWUyZGY0ODA", "commit": {"author": {"name": "Ben Kimock", "email": "kimockb@gmail.com", "date": "2023-04-10T11:55:57Z"}, "committer": {"name": "Ben Kimock", "email": "kimockb@gmail.com", "date": "2023-04-10T11:55:57Z"}, "message": "Merge from rustc", "tree": {"sha": "016ef5aec1d8ddfb44c09609171b997f6add9de4", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/016ef5aec1d8ddfb44c09609171b997f6add9de4"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6efdf4d1309f8047bc439a4810888c715e2df480", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6efdf4d1309f8047bc439a4810888c715e2df480", "html_url": "https://github.com/rust-lang/rust/commit/6efdf4d1309f8047bc439a4810888c715e2df480", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6efdf4d1309f8047bc439a4810888c715e2df480/comments", "author": {"login": "saethlin", "id": 12105168, "node_id": "MDQ6VXNlcjEyMTA1MTY4", "avatar_url": "https://avatars.githubusercontent.com/u/12105168?v=4", "gravatar_id": "", "url": "https://api.github.com/users/saethlin", "html_url": "https://github.com/saethlin", "followers_url": "https://api.github.com/users/saethlin/followers", "following_url": "https://api.github.com/users/saethlin/following{/other_user}", "gists_url": "https://api.github.com/users/saethlin/gists{/gist_id}", "starred_url": "https://api.github.com/users/saethlin/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/saethlin/subscriptions", "organizations_url": "https://api.github.com/users/saethlin/orgs", "repos_url": "https://api.github.com/users/saethlin/repos", "events_url": "https://api.github.com/users/saethlin/events{/privacy}", "received_events_url": "https://api.github.com/users/saethlin/received_events", "type": "User", "site_admin": false}, "committer": {"login": "saethlin", "id": 12105168, "node_id": "MDQ6VXNlcjEyMTA1MTY4", "avatar_url": "https://avatars.githubusercontent.com/u/12105168?v=4", "gravatar_id": "", "url": "https://api.github.com/users/saethlin", "html_url": "https://github.com/saethlin", "followers_url": "https://api.github.com/users/saethlin/followers", "following_url": "https://api.github.com/users/saethlin/following{/other_user}", "gists_url": "https://api.github.com/users/saethlin/gists{/gist_id}", "starred_url": "https://api.github.com/users/saethlin/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/saethlin/subscriptions", "organizations_url": "https://api.github.com/users/saethlin/orgs", "repos_url": "https://api.github.com/users/saethlin/repos", "events_url": "https://api.github.com/users/saethlin/events{/privacy}", "received_events_url": "https://api.github.com/users/saethlin/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0bb6d66251dae171bac858874be87d714004cc16", "url": "https://api.github.com/repos/rust-lang/rust/commits/0bb6d66251dae171bac858874be87d714004cc16", "html_url": "https://github.com/rust-lang/rust/commit/0bb6d66251dae171bac858874be87d714004cc16"}, {"sha": "d4be8efc6296bace5b1e165f1b34d3c6da76aa8e", "url": "https://api.github.com/repos/rust-lang/rust/commits/d4be8efc6296bace5b1e165f1b34d3c6da76aa8e", "html_url": "https://github.com/rust-lang/rust/commit/d4be8efc6296bace5b1e165f1b34d3c6da76aa8e"}], "stats": {"total": 20105, "additions": 10687, "deletions": 9418}, "files": [{"sha": "03aab32bfc6e108bb2255b08a7e04c8fe2d0d17d", "filename": ".editorconfig", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/6efdf4d1309f8047bc439a4810888c715e2df480/.editorconfig", "raw_url": "https://github.com/rust-lang/rust/raw/6efdf4d1309f8047bc439a4810888c715e2df480/.editorconfig", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/.editorconfig?ref=6efdf4d1309f8047bc439a4810888c715e2df480", "patch": "@@ -11,6 +11,7 @@ trim_trailing_whitespace = true\n insert_final_newline = true\n indent_style = space\n indent_size = 4\n+max_line_length = 100\n \n [*.md]\n # double whitespace at end of line"}, {"sha": "4596ae17d023822abed442c0956d4affd5aae754", "filename": ".gitmodules", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6efdf4d1309f8047bc439a4810888c715e2df480/.gitmodules", "raw_url": "https://github.com/rust-lang/rust/raw/6efdf4d1309f8047bc439a4810888c715e2df480/.gitmodules", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/.gitmodules?ref=6efdf4d1309f8047bc439a4810888c715e2df480", "patch": "@@ -25,7 +25,7 @@\n [submodule \"src/llvm-project\"]\n \tpath = src/llvm-project\n \turl = https://github.com/rust-lang/llvm-project.git\n-\tbranch = rustc/16.0-2023-03-06\n+\tbranch = rustc/16.0-2023-04-05\n [submodule \"src/doc/embedded-book\"]\n \tpath = src/doc/embedded-book\n \turl = https://github.com/rust-embedded/book.git"}, {"sha": "6dd6fbe71b83d99093a78c5a12c4ad43ebeccc9e", "filename": "Cargo.lock", "status": "modified", "additions": 42, "deletions": 26, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/6efdf4d1309f8047bc439a4810888c715e2df480/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/6efdf4d1309f8047bc439a4810888c715e2df480/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=6efdf4d1309f8047bc439a4810888c715e2df480", "patch": "@@ -632,7 +632,7 @@ dependencies = [\n  \"proc-macro2\",\n  \"quote\",\n  \"syn 1.0.102\",\n- \"synstructure\",\n+ \"synstructure 0.12.6\",\n ]\n \n [[package]]\n@@ -1418,9 +1418,9 @@ dependencies = [\n \n [[package]]\n name = \"elsa\"\n-version = \"1.8.0\"\n+version = \"1.7.1\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"f74077c3c3aedb99a2683919698285596662518ea13e5eedcf8bdd43b0d0453b\"\n+checksum = \"848fe615fbb0a74d9ae68dcaa510106d32e37d9416207bbea4bd008bd89c47ed\"\n dependencies = [\n  \"stable_deref_trait\",\n ]\n@@ -1673,12 +1673,6 @@ version = \"2.8.1\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"64db3e262960f0662f43a6366788d5f10f7f244b8f7d7d987f560baf5ded5c50\"\n \n-[[package]]\n-name = \"fs_extra\"\n-version = \"1.1.0\"\n-source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"5f2a4a2034423744d2cc7ca2068453168dcdb82c438419e639a26bd87839c674\"\n-\n [[package]]\n name = \"futf\"\n version = \"0.1.5\"\n@@ -2861,12 +2855,11 @@ checksum = \"453ad9f582a441959e5f0d088b02ce04cfe8d51a8eaf077f12ac6d3e94164ca6\"\n \n [[package]]\n name = \"jemalloc-sys\"\n-version = \"0.5.0+5.3.0\"\n+version = \"0.5.3+5.3.0-patched\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"f655c3ecfa6b0d03634595b4b54551d4bd5ac208b9e0124873949a7ab168f70b\"\n+checksum = \"f9bd5d616ea7ed58b571b2e209a65759664d7fb021a0819d7a790afc67e47ca1\"\n dependencies = [\n  \"cc\",\n- \"fs_extra\",\n  \"libc\",\n ]\n \n@@ -3475,18 +3468,30 @@ dependencies = [\n \n [[package]]\n name = \"openssl\"\n-version = \"0.10.38\"\n+version = \"0.10.49\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"0c7ae222234c30df141154f159066c5093ff73b63204dcda7121eb082fc56a95\"\n+checksum = \"4d2f106ab837a24e03672c59b1239669a0596406ff657c3c0835b6b7f0f35a33\"\n dependencies = [\n  \"bitflags\",\n  \"cfg-if\",\n  \"foreign-types\",\n  \"libc\",\n  \"once_cell\",\n+ \"openssl-macros\",\n  \"openssl-sys\",\n ]\n \n+[[package]]\n+name = \"openssl-macros\"\n+version = \"0.1.1\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"a948666b637a0f465e8564c73e89d4dde00d72d4d473cc972f390fc3dcee7d9c\"\n+dependencies = [\n+ \"proc-macro2\",\n+ \"quote\",\n+ \"syn 2.0.8\",\n+]\n+\n [[package]]\n name = \"openssl-probe\"\n version = \"0.1.5\"\n@@ -3495,20 +3500,19 @@ checksum = \"ff011a302c396a5197692431fc1948019154afc178baf7d8e37367442a4601cf\"\n \n [[package]]\n name = \"openssl-src\"\n-version = \"111.22.0+1.1.1q\"\n+version = \"111.25.0+1.1.1t\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"8f31f0d509d1c1ae9cada2f9539ff8f37933831fd5098879e482aa687d659853\"\n+checksum = \"3173cd3626c43e3854b1b727422a276e568d9ec5fe8cec197822cf52cfb743d6\"\n dependencies = [\n  \"cc\",\n ]\n \n [[package]]\n name = \"openssl-sys\"\n-version = \"0.9.72\"\n+version = \"0.9.84\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"7e46109c383602735fa0a2e48dd2b7c892b048e1bf69e5c3b1d804b7d9c203cb\"\n+checksum = \"3a20eace9dc2d82904039cb76dcf50fb1a0bba071cfd1629720b5d6f1ddba0fa\"\n dependencies = [\n- \"autocfg\",\n  \"cc\",\n  \"libc\",\n  \"openssl-src\",\n@@ -4178,7 +4182,7 @@ name = \"rustbook\"\n version = \"0.1.0\"\n dependencies = [\n  \"clap 4.2.1\",\n- \"env_logger 0.7.1\",\n+ \"env_logger 0.10.0\",\n  \"mdbook\",\n ]\n \n@@ -4994,8 +4998,8 @@ dependencies = [\n  \"fluent-syntax\",\n  \"proc-macro2\",\n  \"quote\",\n- \"syn 1.0.102\",\n- \"synstructure\",\n+ \"syn 2.0.8\",\n+ \"synstructure 0.13.0\",\n  \"unic-langid\",\n ]\n \n@@ -6131,6 +6135,18 @@ dependencies = [\n  \"unicode-xid\",\n ]\n \n+[[package]]\n+name = \"synstructure\"\n+version = \"0.13.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"285ba80e733fac80aa4270fbcdf83772a79b80aa35c97075320abfee4a915b06\"\n+dependencies = [\n+ \"proc-macro2\",\n+ \"quote\",\n+ \"syn 2.0.8\",\n+ \"unicode-xid\",\n+]\n+\n [[package]]\n name = \"tar\"\n version = \"0.4.38\"\n@@ -6299,7 +6315,7 @@ name = \"tidy\"\n version = \"0.1.0\"\n dependencies = [\n  \"cargo-platform 0.1.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"cargo_metadata 0.14.0\",\n+ \"cargo_metadata 0.15.3\",\n  \"ignore\",\n  \"lazy_static\",\n  \"miropt-test-tools\",\n@@ -7154,7 +7170,7 @@ dependencies = [\n  \"proc-macro2\",\n  \"quote\",\n  \"syn 1.0.102\",\n- \"synstructure\",\n+ \"synstructure 0.12.6\",\n ]\n \n [[package]]\n@@ -7175,7 +7191,7 @@ dependencies = [\n  \"proc-macro2\",\n  \"quote\",\n  \"syn 1.0.102\",\n- \"synstructure\",\n+ \"synstructure 0.12.6\",\n ]\n \n [[package]]\n@@ -7204,5 +7220,5 @@ dependencies = [\n  \"proc-macro2\",\n  \"quote\",\n  \"syn 1.0.102\",\n- \"synstructure\",\n+ \"synstructure 0.12.6\",\n ]"}, {"sha": "c863acde7b03dde231794f4f988539c50f3aed39", "filename": "compiler/rustc_abi/src/layout.rs", "status": "modified", "additions": 35, "deletions": 40, "changes": 75, "blob_url": "https://github.com/rust-lang/rust/blob/6efdf4d1309f8047bc439a4810888c715e2df480/compiler%2Frustc_abi%2Fsrc%2Flayout.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6efdf4d1309f8047bc439a4810888c715e2df480/compiler%2Frustc_abi%2Fsrc%2Flayout.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_abi%2Fsrc%2Flayout.rs?ref=6efdf4d1309f8047bc439a4810888c715e2df480", "patch": "@@ -8,19 +8,6 @@ use rand_xoshiro::Xoshiro128StarStar;\n \n use tracing::debug;\n \n-// Invert a bijective mapping, i.e. `invert(map)[y] = x` if `map[x] = y`.\n-// This is used to go between `memory_index` (source field order to memory order)\n-// and `inverse_memory_index` (memory order to source field order).\n-// See also `FieldsShape::Arbitrary::memory_index` for more details.\n-// FIXME(eddyb) build a better abstraction for permutations, if possible.\n-fn invert_mapping(map: &[u32]) -> Vec<u32> {\n-    let mut inverse = vec![0; map.len()];\n-    for i in 0..map.len() {\n-        inverse[map[i] as usize] = i as u32;\n-    }\n-    inverse\n-}\n-\n pub trait LayoutCalculator {\n     type TargetDataLayoutRef: Borrow<TargetDataLayout>;\n \n@@ -45,8 +32,8 @@ pub trait LayoutCalculator {\n         LayoutS {\n             variants: Variants::Single { index: FIRST_VARIANT },\n             fields: FieldsShape::Arbitrary {\n-                offsets: vec![Size::ZERO, b_offset],\n-                memory_index: vec![0, 1],\n+                offsets: [Size::ZERO, b_offset].into(),\n+                memory_index: [0, 1].into(),\n             },\n             abi: Abi::ScalarPair(a, b),\n             largest_niche,\n@@ -58,18 +45,18 @@ pub trait LayoutCalculator {\n     fn univariant(\n         &self,\n         dl: &TargetDataLayout,\n-        fields: &[Layout<'_>],\n+        fields: &IndexSlice<FieldIdx, Layout<'_>>,\n         repr: &ReprOptions,\n         kind: StructKind,\n     ) -> Option<LayoutS> {\n         let pack = repr.pack;\n         let mut align = if pack.is_some() { dl.i8_align } else { dl.aggregate_align };\n-        let mut inverse_memory_index: Vec<u32> = (0..fields.len() as u32).collect();\n+        let mut inverse_memory_index: IndexVec<u32, FieldIdx> = fields.indices().collect();\n         let optimize = !repr.inhibit_struct_field_reordering_opt();\n         if optimize {\n             let end =\n                 if let StructKind::MaybeUnsized = kind { fields.len() - 1 } else { fields.len() };\n-            let optimizing = &mut inverse_memory_index[..end];\n+            let optimizing = &mut inverse_memory_index.raw[..end];\n             let effective_field_align = |layout: Layout<'_>| {\n                 if let Some(pack) = pack {\n                     // return the packed alignment in bytes\n@@ -105,7 +92,7 @@ pub trait LayoutCalculator {\n                             // Place ZSTs first to avoid \"interesting offsets\",\n                             // especially with only one or two non-ZST fields.\n                             // Then place largest alignments first, largest niches within an alignment group last\n-                            let f = fields[x as usize];\n+                            let f = fields[x];\n                             let niche_size = f.largest_niche().map_or(0, |n| n.available(dl));\n                             (!f.0.is_zst(), cmp::Reverse(effective_field_align(f)), niche_size)\n                         });\n@@ -117,7 +104,7 @@ pub trait LayoutCalculator {\n                         // And put the largest niche in an alignment group at the end\n                         // so it can be used as discriminant in jagged enums\n                         optimizing.sort_by_key(|&x| {\n-                            let f = fields[x as usize];\n+                            let f = fields[x];\n                             let niche_size = f.largest_niche().map_or(0, |n| n.available(dl));\n                             (effective_field_align(f), niche_size)\n                         });\n@@ -135,7 +122,7 @@ pub trait LayoutCalculator {\n         // At the bottom of this function, we invert `inverse_memory_index` to\n         // produce `memory_index` (see `invert_mapping`).\n         let mut sized = true;\n-        let mut offsets = vec![Size::ZERO; fields.len()];\n+        let mut offsets = IndexVec::from_elem(Size::ZERO, &fields);\n         let mut offset = Size::ZERO;\n         let mut largest_niche = None;\n         let mut largest_niche_available = 0;\n@@ -146,7 +133,7 @@ pub trait LayoutCalculator {\n             offset = prefix_size.align_to(prefix_align);\n         }\n         for &i in &inverse_memory_index {\n-            let field = &fields[i as usize];\n+            let field = &fields[i];\n             if !sized {\n                 self.delay_bug(&format!(\n                     \"univariant: field #{} comes after unsized field\",\n@@ -168,7 +155,7 @@ pub trait LayoutCalculator {\n             align = align.max(field_align);\n \n             debug!(\"univariant offset: {:?} field: {:#?}\", offset, field);\n-            offsets[i as usize] = offset;\n+            offsets[i] = offset;\n \n             if let Some(mut niche) = field.largest_niche() {\n                 let available = niche.available(dl);\n@@ -192,14 +179,18 @@ pub trait LayoutCalculator {\n         // If field 5 has offset 0, offsets[0] is 5, and memory_index[5] should be 0.\n         // Field 5 would be the first element, so memory_index is i:\n         // Note: if we didn't optimize, it's already right.\n-        let memory_index =\n-            if optimize { invert_mapping(&inverse_memory_index) } else { inverse_memory_index };\n+        let memory_index = if optimize {\n+            inverse_memory_index.invert_bijective_mapping()\n+        } else {\n+            debug_assert!(inverse_memory_index.iter().copied().eq(fields.indices()));\n+            inverse_memory_index.into_iter().map(FieldIdx::as_u32).collect()\n+        };\n         let size = min_size.align_to(align.abi);\n         let mut abi = Abi::Aggregate { sized };\n         // Unpack newtype ABIs and find scalar pairs.\n         if sized && size.bytes() > 0 {\n             // All other fields must be ZSTs.\n-            let mut non_zst_fields = fields.iter().enumerate().filter(|&(_, f)| !f.0.is_zst());\n+            let mut non_zst_fields = fields.iter_enumerated().filter(|&(_, f)| !f.0.is_zst());\n \n             match (non_zst_fields.next(), non_zst_fields.next(), non_zst_fields.next()) {\n                 // We have exactly one non-ZST field.\n@@ -238,13 +229,13 @@ pub trait LayoutCalculator {\n                             let pair = self.scalar_pair(a, b);\n                             let pair_offsets = match pair.fields {\n                                 FieldsShape::Arbitrary { ref offsets, ref memory_index } => {\n-                                    assert_eq!(memory_index, &[0, 1]);\n+                                    assert_eq!(memory_index.raw, [0, 1]);\n                                     offsets\n                                 }\n                                 _ => panic!(),\n                             };\n-                            if offsets[i] == pair_offsets[0]\n-                                && offsets[j] == pair_offsets[1]\n+                            if offsets[i] == pair_offsets[FieldIdx::from_usize(0)]\n+                                && offsets[j] == pair_offsets[FieldIdx::from_usize(1)]\n                                 && align == pair.align\n                                 && size == pair.size\n                             {\n@@ -289,7 +280,7 @@ pub trait LayoutCalculator {\n     fn layout_of_struct_or_enum(\n         &self,\n         repr: &ReprOptions,\n-        variants: &IndexSlice<VariantIdx, Vec<Layout<'_>>>,\n+        variants: &IndexSlice<VariantIdx, IndexVec<FieldIdx, Layout<'_>>>,\n         is_enum: bool,\n         is_unsafe_cell: bool,\n         scalar_valid_range: (Bound<u128>, Bound<u128>),\n@@ -312,7 +303,7 @@ pub trait LayoutCalculator {\n         // but *not* an encoding of the discriminant (e.g., a tag value).\n         // See issue #49298 for more details on the need to leave space\n         // for non-ZST uninhabited data (mostly partial initialization).\n-        let absent = |fields: &[Layout<'_>]| {\n+        let absent = |fields: &IndexSlice<FieldIdx, Layout<'_>>| {\n             let uninhabited = fields.iter().any(|f| f.abi().is_uninhabited());\n             let is_zst = fields.iter().all(|f| f.0.is_zst());\n             uninhabited && is_zst\n@@ -510,7 +501,7 @@ pub trait LayoutCalculator {\n                 // It'll fit, but we need to make some adjustments.\n                 match layout.fields {\n                     FieldsShape::Arbitrary { ref mut offsets, .. } => {\n-                        for (j, offset) in offsets.iter_mut().enumerate() {\n+                        for (j, offset) in offsets.iter_enumerated_mut() {\n                             if !variants[i][j].0.is_zst() {\n                                 *offset += this_offset;\n                             }\n@@ -577,8 +568,8 @@ pub trait LayoutCalculator {\n                     variants: IndexVec::new(),\n                 },\n                 fields: FieldsShape::Arbitrary {\n-                    offsets: vec![niche_offset],\n-                    memory_index: vec![0],\n+                    offsets: [niche_offset].into(),\n+                    memory_index: [0].into(),\n                 },\n                 abi,\n                 largest_niche,\n@@ -651,7 +642,8 @@ pub trait LayoutCalculator {\n                 st.variants = Variants::Single { index: i };\n                 // Find the first field we can't move later\n                 // to make room for a larger discriminant.\n-                for field in st.fields.index_by_increasing_offset().map(|j| &field_layouts[j]) {\n+                for field_idx in st.fields.index_by_increasing_offset() {\n+                    let field = &field_layouts[FieldIdx::from_usize(field_idx)];\n                     if !field.0.is_zst() || field.align().abi.bytes() != 1 {\n                         start_align = start_align.min(field.align().abi);\n                         break;\n@@ -802,13 +794,13 @@ pub trait LayoutCalculator {\n                 let pair = self.scalar_pair(tag, prim_scalar);\n                 let pair_offsets = match pair.fields {\n                     FieldsShape::Arbitrary { ref offsets, ref memory_index } => {\n-                        assert_eq!(memory_index, &[0, 1]);\n+                        assert_eq!(memory_index.raw, [0, 1]);\n                         offsets\n                     }\n                     _ => panic!(),\n                 };\n-                if pair_offsets[0] == Size::ZERO\n-                    && pair_offsets[1] == *offset\n+                if pair_offsets[FieldIdx::from_u32(0)] == Size::ZERO\n+                    && pair_offsets[FieldIdx::from_u32(1)] == *offset\n                     && align == pair.align\n                     && size == pair.size\n                 {\n@@ -844,7 +836,10 @@ pub trait LayoutCalculator {\n                 tag_field: 0,\n                 variants: IndexVec::new(),\n             },\n-            fields: FieldsShape::Arbitrary { offsets: vec![Size::ZERO], memory_index: vec![0] },\n+            fields: FieldsShape::Arbitrary {\n+                offsets: [Size::ZERO].into(),\n+                memory_index: [0].into(),\n+            },\n             largest_niche,\n             abi,\n             align,\n@@ -883,7 +878,7 @@ pub trait LayoutCalculator {\n     fn layout_of_union(\n         &self,\n         repr: &ReprOptions,\n-        variants: &IndexSlice<VariantIdx, Vec<Layout<'_>>>,\n+        variants: &IndexSlice<VariantIdx, IndexVec<FieldIdx, Layout<'_>>>,\n     ) -> Option<LayoutS> {\n         let dl = self.current_data_layout();\n         let dl = dl.borrow();"}, {"sha": "b0c0ee942ea8f5074cb2e6bfd8792395e8efe411", "filename": "compiler/rustc_abi/src/lib.rs", "status": "modified", "additions": 22, "deletions": 13, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/6efdf4d1309f8047bc439a4810888c715e2df480/compiler%2Frustc_abi%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6efdf4d1309f8047bc439a4810888c715e2df480/compiler%2Frustc_abi%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_abi%2Fsrc%2Flib.rs?ref=6efdf4d1309f8047bc439a4810888c715e2df480", "patch": "@@ -1108,7 +1108,7 @@ pub enum FieldsShape {\n         /// ordered to match the source definition order.\n         /// This vector does not go in increasing order.\n         // FIXME(eddyb) use small vector optimization for the common case.\n-        offsets: Vec<Size>,\n+        offsets: IndexVec<FieldIdx, Size>,\n \n         /// Maps source order field indices to memory order indices,\n         /// depending on how the fields were reordered (if at all).\n@@ -1122,7 +1122,7 @@ pub enum FieldsShape {\n         ///\n         // FIXME(eddyb) build a better abstraction for permutations, if possible.\n         // FIXME(camlorn) also consider small vector optimization here.\n-        memory_index: Vec<u32>,\n+        memory_index: IndexVec<FieldIdx, u32>,\n     },\n }\n \n@@ -1157,7 +1157,7 @@ impl FieldsShape {\n                 assert!(i < count);\n                 stride * i\n             }\n-            FieldsShape::Arbitrary { ref offsets, .. } => offsets[i],\n+            FieldsShape::Arbitrary { ref offsets, .. } => offsets[FieldIdx::from_usize(i)],\n         }\n     }\n \n@@ -1168,28 +1168,27 @@ impl FieldsShape {\n                 unreachable!(\"FieldsShape::memory_index: `Primitive`s have no fields\")\n             }\n             FieldsShape::Union(_) | FieldsShape::Array { .. } => i,\n-            FieldsShape::Arbitrary { ref memory_index, .. } => memory_index[i].try_into().unwrap(),\n+            FieldsShape::Arbitrary { ref memory_index, .. } => {\n+                memory_index[FieldIdx::from_usize(i)].try_into().unwrap()\n+            }\n         }\n     }\n \n     /// Gets source indices of the fields by increasing offsets.\n     #[inline]\n-    pub fn index_by_increasing_offset<'a>(&'a self) -> impl Iterator<Item = usize> + 'a {\n+    pub fn index_by_increasing_offset(&self) -> impl Iterator<Item = usize> + '_ {\n         let mut inverse_small = [0u8; 64];\n-        let mut inverse_big = vec![];\n+        let mut inverse_big = IndexVec::new();\n         let use_small = self.count() <= inverse_small.len();\n \n         // We have to write this logic twice in order to keep the array small.\n         if let FieldsShape::Arbitrary { ref memory_index, .. } = *self {\n             if use_small {\n-                for i in 0..self.count() {\n-                    inverse_small[memory_index[i] as usize] = i as u8;\n+                for (field_idx, &mem_idx) in memory_index.iter_enumerated() {\n+                    inverse_small[mem_idx as usize] = field_idx.as_u32() as u8;\n                 }\n             } else {\n-                inverse_big = vec![0; self.count()];\n-                for i in 0..self.count() {\n-                    inverse_big[memory_index[i] as usize] = i as u32;\n-                }\n+                inverse_big = memory_index.invert_bijective_mapping();\n             }\n         }\n \n@@ -1199,7 +1198,7 @@ impl FieldsShape {\n                 if use_small {\n                     inverse_small[i] as usize\n                 } else {\n-                    inverse_big[i] as usize\n+                    inverse_big[i as u32].as_usize()\n                 }\n             }\n         })\n@@ -1523,6 +1522,16 @@ impl<'a> Layout<'a> {\n     pub fn size(self) -> Size {\n         self.0.0.size\n     }\n+\n+    /// Whether the layout is from a type that implements [`std::marker::PointerLike`].\n+    ///\n+    /// Currently, that means that the type is pointer-sized, pointer-aligned,\n+    /// and has a scalar ABI.\n+    pub fn is_pointer_like(self, data_layout: &TargetDataLayout) -> bool {\n+        self.size() == data_layout.pointer_size\n+            && self.align().abi == data_layout.pointer_align.abi\n+            && matches!(self.abi(), Abi::Scalar(..))\n+    }\n }\n \n #[derive(Copy, Clone, PartialEq, Eq, Debug)]"}, {"sha": "345e058e1134a4a5c1ba516b326f01335addb152", "filename": "compiler/rustc_arena/src/lib.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/6efdf4d1309f8047bc439a4810888c715e2df480/compiler%2Frustc_arena%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6efdf4d1309f8047bc439a4810888c715e2df480/compiler%2Frustc_arena%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_arena%2Fsrc%2Flib.rs?ref=6efdf4d1309f8047bc439a4810888c715e2df480", "patch": "@@ -22,6 +22,7 @@\n #![feature(strict_provenance)]\n #![deny(rustc::untranslatable_diagnostic)]\n #![deny(rustc::diagnostic_outside_of_impl)]\n+#![allow(clippy::mut_from_ref)] // Arena allocators are one of the places where this pattern is fine.\n \n use smallvec::SmallVec;\n \n@@ -568,7 +569,9 @@ pub macro declare_arena([$($a:tt $name:ident: $ty:ty,)*]) {\n     }\n \n     pub trait ArenaAllocatable<'tcx, C = rustc_arena::IsNotCopy>: Sized {\n+        #[allow(clippy::mut_from_ref)]\n         fn allocate_on<'a>(self, arena: &'a Arena<'tcx>) -> &'a mut Self;\n+        #[allow(clippy::mut_from_ref)]\n         fn allocate_from_iter<'a>(\n             arena: &'a Arena<'tcx>,\n             iter: impl ::std::iter::IntoIterator<Item = Self>,\n@@ -578,10 +581,12 @@ pub macro declare_arena([$($a:tt $name:ident: $ty:ty,)*]) {\n     // Any type that impls `Copy` can be arena-allocated in the `DroplessArena`.\n     impl<'tcx, T: Copy> ArenaAllocatable<'tcx, rustc_arena::IsCopy> for T {\n         #[inline]\n+        #[allow(clippy::mut_from_ref)]\n         fn allocate_on<'a>(self, arena: &'a Arena<'tcx>) -> &'a mut Self {\n             arena.dropless.alloc(self)\n         }\n         #[inline]\n+        #[allow(clippy::mut_from_ref)]\n         fn allocate_from_iter<'a>(\n             arena: &'a Arena<'tcx>,\n             iter: impl ::std::iter::IntoIterator<Item = Self>,\n@@ -601,6 +606,7 @@ pub macro declare_arena([$($a:tt $name:ident: $ty:ty,)*]) {\n             }\n \n             #[inline]\n+            #[allow(clippy::mut_from_ref)]\n             fn allocate_from_iter<'a>(\n                 arena: &'a Arena<'tcx>,\n                 iter: impl ::std::iter::IntoIterator<Item = Self>,\n@@ -616,19 +622,22 @@ pub macro declare_arena([$($a:tt $name:ident: $ty:ty,)*]) {\n \n     impl<'tcx> Arena<'tcx> {\n         #[inline]\n+        #[allow(clippy::mut_from_ref)]\n         pub fn alloc<T: ArenaAllocatable<'tcx, C>, C>(&self, value: T) -> &mut T {\n             value.allocate_on(self)\n         }\n \n         // Any type that impls `Copy` can have slices be arena-allocated in the `DroplessArena`.\n         #[inline]\n+        #[allow(clippy::mut_from_ref)]\n         pub fn alloc_slice<T: ::std::marker::Copy>(&self, value: &[T]) -> &mut [T] {\n             if value.is_empty() {\n                 return &mut [];\n             }\n             self.dropless.alloc_slice(value)\n         }\n \n+        #[allow(clippy::mut_from_ref)]\n         pub fn alloc_from_iter<'a, T: ArenaAllocatable<'tcx, C>, C>(\n             &'a self,\n             iter: impl ::std::iter::IntoIterator<Item = T>,"}, {"sha": "fb9d71b52a8a612d2fa7ae4c1d91e9382d3bfd41", "filename": "compiler/rustc_ast/src/ast.rs", "status": "modified", "additions": 28, "deletions": 10, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/6efdf4d1309f8047bc439a4810888c715e2df480/compiler%2Frustc_ast%2Fsrc%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6efdf4d1309f8047bc439a4810888c715e2df480/compiler%2Frustc_ast%2Fsrc%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast%2Fsrc%2Fast.rs?ref=6efdf4d1309f8047bc439a4810888c715e2df480", "patch": "@@ -2890,6 +2890,20 @@ pub struct Fn {\n     pub body: Option<P<Block>>,\n }\n \n+#[derive(Clone, Encodable, Decodable, Debug)]\n+pub struct StaticItem {\n+    pub ty: P<Ty>,\n+    pub mutability: Mutability,\n+    pub expr: Option<P<Expr>>,\n+}\n+\n+#[derive(Clone, Encodable, Decodable, Debug)]\n+pub struct ConstItem {\n+    pub defaultness: Defaultness,\n+    pub ty: P<Ty>,\n+    pub expr: Option<P<Expr>>,\n+}\n+\n #[derive(Clone, Encodable, Decodable, Debug)]\n pub enum ItemKind {\n     /// An `extern crate` item, with the optional *original* crate name if the crate was renamed.\n@@ -2903,11 +2917,11 @@ pub enum ItemKind {\n     /// A static item (`static`).\n     ///\n     /// E.g., `static FOO: i32 = 42;` or `static FOO: &'static str = \"bar\";`.\n-    Static(P<Ty>, Mutability, Option<P<Expr>>),\n+    Static(Box<StaticItem>),\n     /// A constant item (`const`).\n     ///\n     /// E.g., `const FOO: i32 = 42;`.\n-    Const(Defaultness, P<Ty>, Option<P<Expr>>),\n+    Const(Box<ConstItem>),\n     /// A function declaration (`fn`).\n     ///\n     /// E.g., `fn foo(bar: usize) -> usize { .. }`.\n@@ -3023,7 +3037,7 @@ pub type AssocItem = Item<AssocItemKind>;\n pub enum AssocItemKind {\n     /// An associated constant, `const $ident: $ty $def?;` where `def ::= \"=\" $expr? ;`.\n     /// If `def` is parsed, then the constant is provided, and otherwise required.\n-    Const(Defaultness, P<Ty>, Option<P<Expr>>),\n+    Const(Box<ConstItem>),\n     /// An associated function.\n     Fn(Box<Fn>),\n     /// An associated type.\n@@ -3035,7 +3049,7 @@ pub enum AssocItemKind {\n impl AssocItemKind {\n     pub fn defaultness(&self) -> Defaultness {\n         match *self {\n-            Self::Const(defaultness, ..)\n+            Self::Const(box ConstItem { defaultness, .. })\n             | Self::Fn(box Fn { defaultness, .. })\n             | Self::Type(box TyAlias { defaultness, .. }) => defaultness,\n             Self::MacCall(..) => Defaultness::Final,\n@@ -3046,7 +3060,7 @@ impl AssocItemKind {\n impl From<AssocItemKind> for ItemKind {\n     fn from(assoc_item_kind: AssocItemKind) -> ItemKind {\n         match assoc_item_kind {\n-            AssocItemKind::Const(a, b, c) => ItemKind::Const(a, b, c),\n+            AssocItemKind::Const(item) => ItemKind::Const(item),\n             AssocItemKind::Fn(fn_kind) => ItemKind::Fn(fn_kind),\n             AssocItemKind::Type(ty_alias_kind) => ItemKind::TyAlias(ty_alias_kind),\n             AssocItemKind::MacCall(a) => ItemKind::MacCall(a),\n@@ -3059,7 +3073,7 @@ impl TryFrom<ItemKind> for AssocItemKind {\n \n     fn try_from(item_kind: ItemKind) -> Result<AssocItemKind, ItemKind> {\n         Ok(match item_kind {\n-            ItemKind::Const(a, b, c) => AssocItemKind::Const(a, b, c),\n+            ItemKind::Const(item) => AssocItemKind::Const(item),\n             ItemKind::Fn(fn_kind) => AssocItemKind::Fn(fn_kind),\n             ItemKind::TyAlias(ty_kind) => AssocItemKind::Type(ty_kind),\n             ItemKind::MacCall(a) => AssocItemKind::MacCall(a),\n@@ -3084,7 +3098,9 @@ pub enum ForeignItemKind {\n impl From<ForeignItemKind> for ItemKind {\n     fn from(foreign_item_kind: ForeignItemKind) -> ItemKind {\n         match foreign_item_kind {\n-            ForeignItemKind::Static(a, b, c) => ItemKind::Static(a, b, c),\n+            ForeignItemKind::Static(a, b, c) => {\n+                ItemKind::Static(StaticItem { ty: a, mutability: b, expr: c }.into())\n+            }\n             ForeignItemKind::Fn(fn_kind) => ItemKind::Fn(fn_kind),\n             ForeignItemKind::TyAlias(ty_alias_kind) => ItemKind::TyAlias(ty_alias_kind),\n             ForeignItemKind::MacCall(a) => ItemKind::MacCall(a),\n@@ -3097,7 +3113,9 @@ impl TryFrom<ItemKind> for ForeignItemKind {\n \n     fn try_from(item_kind: ItemKind) -> Result<ForeignItemKind, ItemKind> {\n         Ok(match item_kind {\n-            ItemKind::Static(a, b, c) => ForeignItemKind::Static(a, b, c),\n+            ItemKind::Static(box StaticItem { ty: a, mutability: b, expr: c }) => {\n+                ForeignItemKind::Static(a, b, c)\n+            }\n             ItemKind::Fn(fn_kind) => ForeignItemKind::Fn(fn_kind),\n             ItemKind::TyAlias(ty_alias_kind) => ForeignItemKind::TyAlias(ty_alias_kind),\n             ItemKind::MacCall(a) => ForeignItemKind::MacCall(a),\n@@ -3114,8 +3132,8 @@ mod size_asserts {\n     use super::*;\n     use rustc_data_structures::static_assert_size;\n     // tidy-alphabetical-start\n-    static_assert_size!(AssocItem, 104);\n-    static_assert_size!(AssocItemKind, 32);\n+    static_assert_size!(AssocItem, 88);\n+    static_assert_size!(AssocItemKind, 16);\n     static_assert_size!(Attribute, 32);\n     static_assert_size!(Block, 32);\n     static_assert_size!(Expr, 72);"}, {"sha": "2424073ae53adae2bfb9b7f034e25f8ec70432dd", "filename": "compiler/rustc_ast/src/mut_visit.rs", "status": "modified", "additions": 15, "deletions": 10, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/6efdf4d1309f8047bc439a4810888c715e2df480/compiler%2Frustc_ast%2Fsrc%2Fmut_visit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6efdf4d1309f8047bc439a4810888c715e2df480/compiler%2Frustc_ast%2Fsrc%2Fmut_visit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast%2Fsrc%2Fmut_visit.rs?ref=6efdf4d1309f8047bc439a4810888c715e2df480", "patch": "@@ -7,10 +7,10 @@\n //! a `MutVisitor` renaming item names in a module will miss all of those\n //! that are created by the expansion of a macro.\n \n-use crate::ast::*;\n use crate::ptr::P;\n use crate::token::{self, Token};\n use crate::tokenstream::*;\n+use crate::{ast::*, StaticItem};\n \n use rustc_data_structures::flat_map_in_place::FlatMapInPlace;\n use rustc_data_structures::sync::Lrc;\n@@ -1030,14 +1030,12 @@ pub fn noop_visit_item_kind<T: MutVisitor>(kind: &mut ItemKind, vis: &mut T) {\n     match kind {\n         ItemKind::ExternCrate(_orig_name) => {}\n         ItemKind::Use(use_tree) => vis.visit_use_tree(use_tree),\n-        ItemKind::Static(ty, _, expr) => {\n+        ItemKind::Static(box StaticItem { ty, mutability: _, expr }) => {\n             vis.visit_ty(ty);\n             visit_opt(expr, |expr| vis.visit_expr(expr));\n         }\n-        ItemKind::Const(defaultness, ty, expr) => {\n-            visit_defaultness(defaultness, vis);\n-            vis.visit_ty(ty);\n-            visit_opt(expr, |expr| vis.visit_expr(expr));\n+        ItemKind::Const(item) => {\n+            visit_const_item(item, vis);\n         }\n         ItemKind::Fn(box Fn { defaultness, generics, sig, body }) => {\n             visit_defaultness(defaultness, vis);\n@@ -1120,10 +1118,8 @@ pub fn noop_flat_map_assoc_item<T: MutVisitor>(\n     visitor.visit_vis(vis);\n     visit_attrs(attrs, visitor);\n     match kind {\n-        AssocItemKind::Const(defaultness, ty, expr) => {\n-            visit_defaultness(defaultness, visitor);\n-            visitor.visit_ty(ty);\n-            visit_opt(expr, |expr| visitor.visit_expr(expr));\n+        AssocItemKind::Const(item) => {\n+            visit_const_item(item, visitor);\n         }\n         AssocItemKind::Fn(box Fn { defaultness, generics, sig, body }) => {\n             visit_defaultness(defaultness, visitor);\n@@ -1153,6 +1149,15 @@ pub fn noop_flat_map_assoc_item<T: MutVisitor>(\n     smallvec![item]\n }\n \n+fn visit_const_item<T: MutVisitor>(\n+    ConstItem { defaultness, ty, expr }: &mut ConstItem,\n+    visitor: &mut T,\n+) {\n+    visit_defaultness(defaultness, visitor);\n+    visitor.visit_ty(ty);\n+    visit_opt(expr, |expr| visitor.visit_expr(expr));\n+}\n+\n pub fn noop_visit_fn_header<T: MutVisitor>(header: &mut FnHeader, vis: &mut T) {\n     let FnHeader { unsafety, asyncness, constness, ext: _ } = header;\n     visit_constness(constness, vis);"}, {"sha": "3b08467fde2bf6b8a7a598e7066589785245d305", "filename": "compiler/rustc_ast/src/visit.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/6efdf4d1309f8047bc439a4810888c715e2df480/compiler%2Frustc_ast%2Fsrc%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6efdf4d1309f8047bc439a4810888c715e2df480/compiler%2Frustc_ast%2Fsrc%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast%2Fsrc%2Fvisit.rs?ref=6efdf4d1309f8047bc439a4810888c715e2df480", "patch": "@@ -13,7 +13,7 @@\n //! instance, a walker looking for item names in a module will miss all of\n //! those that are created by the expansion of a macro.\n \n-use crate::ast::*;\n+use crate::{ast::*, StaticItem};\n \n use rustc_span::symbol::Ident;\n use rustc_span::Span;\n@@ -305,8 +305,9 @@ pub fn walk_item<'a, V: Visitor<'a>>(visitor: &mut V, item: &'a Item) {\n     match &item.kind {\n         ItemKind::ExternCrate(_) => {}\n         ItemKind::Use(use_tree) => visitor.visit_use_tree(use_tree, item.id, false),\n-        ItemKind::Static(typ, _, expr) | ItemKind::Const(_, typ, expr) => {\n-            visitor.visit_ty(typ);\n+        ItemKind::Static(box StaticItem { ty, mutability: _, expr })\n+        | ItemKind::Const(box ConstItem { ty, expr, .. }) => {\n+            visitor.visit_ty(ty);\n             walk_list!(visitor, visit_expr, expr);\n         }\n         ItemKind::Fn(box Fn { defaultness: _, generics, sig, body }) => {\n@@ -674,7 +675,7 @@ pub fn walk_assoc_item<'a, V: Visitor<'a>>(visitor: &mut V, item: &'a AssocItem,\n     visitor.visit_ident(ident);\n     walk_list!(visitor, visit_attribute, attrs);\n     match kind {\n-        AssocItemKind::Const(_, ty, expr) => {\n+        AssocItemKind::Const(box ConstItem { ty, expr, .. }) => {\n             visitor.visit_ty(ty);\n             walk_list!(visitor, visit_expr, expr);\n         }"}, {"sha": "f89e254a2f54dc248bc61e192cc7f4e175a9f10a", "filename": "compiler/rustc_ast_lowering/src/item.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/6efdf4d1309f8047bc439a4810888c715e2df480/compiler%2Frustc_ast_lowering%2Fsrc%2Fitem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6efdf4d1309f8047bc439a4810888c715e2df480/compiler%2Frustc_ast_lowering%2Fsrc%2Fitem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_lowering%2Fsrc%2Fitem.rs?ref=6efdf4d1309f8047bc439a4810888c715e2df480", "patch": "@@ -229,12 +229,12 @@ impl<'hir> LoweringContext<'_, 'hir> {\n \n                 self.lower_use_tree(use_tree, &prefix, id, vis_span, ident, attrs)\n             }\n-            ItemKind::Static(t, m, e) => {\n+            ItemKind::Static(box ast::StaticItem { ty: t, mutability: m, expr: e }) => {\n                 let (ty, body_id) = self.lower_const_item(t, span, e.as_deref());\n                 hir::ItemKind::Static(ty, *m, body_id)\n             }\n-            ItemKind::Const(_, t, e) => {\n-                let (ty, body_id) = self.lower_const_item(t, span, e.as_deref());\n+            ItemKind::Const(box ast::ConstItem { ty, expr, .. }) => {\n+                let (ty, body_id) = self.lower_const_item(ty, span, expr.as_deref());\n                 hir::ItemKind::Const(ty, body_id)\n             }\n             ItemKind::Fn(box Fn {\n@@ -708,10 +708,10 @@ impl<'hir> LoweringContext<'_, 'hir> {\n         let trait_item_def_id = hir_id.expect_owner();\n \n         let (generics, kind, has_default) = match &i.kind {\n-            AssocItemKind::Const(_, ty, default) => {\n+            AssocItemKind::Const(box ConstItem { ty, expr, .. }) => {\n                 let ty =\n                     self.lower_ty(ty, &ImplTraitContext::Disallowed(ImplTraitPosition::ConstTy));\n-                let body = default.as_ref().map(|x| self.lower_const_body(i.span, Some(x)));\n+                let body = expr.as_ref().map(|x| self.lower_const_body(i.span, Some(x)));\n                 (hir::Generics::empty(), hir::TraitItemKind::Const(ty, body), body.is_some())\n             }\n             AssocItemKind::Fn(box Fn { sig, generics, body: None, .. }) => {\n@@ -809,7 +809,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n         self.lower_attrs(hir_id, &i.attrs);\n \n         let (generics, kind) = match &i.kind {\n-            AssocItemKind::Const(_, ty, expr) => {\n+            AssocItemKind::Const(box ConstItem { ty, expr, .. }) => {\n                 let ty =\n                     self.lower_ty(ty, &ImplTraitContext::Disallowed(ImplTraitPosition::ConstTy));\n                 ("}, {"sha": "1389acabfcbd55e34c7a876009b8d821d70f75c5", "filename": "compiler/rustc_ast_passes/src/ast_validation.rs", "status": "modified", "additions": 10, "deletions": 12, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/6efdf4d1309f8047bc439a4810888c715e2df480/compiler%2Frustc_ast_passes%2Fsrc%2Fast_validation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6efdf4d1309f8047bc439a4810888c715e2df480/compiler%2Frustc_ast_passes%2Fsrc%2Fast_validation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_passes%2Fsrc%2Fast_validation.rs?ref=6efdf4d1309f8047bc439a4810888c715e2df480", "patch": "@@ -9,8 +9,8 @@\n use itertools::{Either, Itertools};\n use rustc_ast::ptr::P;\n use rustc_ast::visit::{self, AssocCtxt, BoundKind, FnCtxt, FnKind, Visitor};\n-use rustc_ast::walk_list;\n use rustc_ast::*;\n+use rustc_ast::{walk_list, StaticItem};\n use rustc_ast_pretty::pprust::{self, State};\n use rustc_data_structures::fx::FxIndexMap;\n use rustc_macros::Subdiagnostic;\n@@ -691,7 +691,7 @@ fn validate_generic_param_order(\n                 GenericParamKind::Lifetime => (),\n                 GenericParamKind::Const { ty: _, kw_span: _, default: Some(default) } => {\n                     ordered_params += \" = \";\n-                    ordered_params += &pprust::expr_to_string(&*default.value);\n+                    ordered_params += &pprust::expr_to_string(&default.value);\n                 }\n                 GenericParamKind::Const { ty: _, kw_span: _, default: None } => (),\n             }\n@@ -983,14 +983,14 @@ impl<'a> Visitor<'a> for AstValidator<'a> {\n                     self.err_handler().emit_err(errors::FieldlessUnion { span: item.span });\n                 }\n             }\n-            ItemKind::Const(def, .., None) => {\n-                self.check_defaultness(item.span, *def);\n+            ItemKind::Const(box ConstItem { defaultness, expr: None, .. }) => {\n+                self.check_defaultness(item.span, *defaultness);\n                 self.session.emit_err(errors::ConstWithoutBody {\n                     span: item.span,\n                     replace_span: self.ending_semi_or_hi(item.span),\n                 });\n             }\n-            ItemKind::Static(.., None) => {\n+            ItemKind::Static(box StaticItem { expr: None, .. }) => {\n                 self.session.emit_err(errors::StaticWithoutBody {\n                     span: item.span,\n                     replace_span: self.ending_semi_or_hi(item.span),\n@@ -1259,13 +1259,11 @@ impl<'a> Visitor<'a> for AstValidator<'a> {\n \n         if ctxt == AssocCtxt::Impl {\n             match &item.kind {\n-                AssocItemKind::Const(_, _, body) => {\n-                    if body.is_none() {\n-                        self.session.emit_err(errors::AssocConstWithoutBody {\n-                            span: item.span,\n-                            replace_span: self.ending_semi_or_hi(item.span),\n-                        });\n-                    }\n+                AssocItemKind::Const(box ConstItem { expr: None, .. }) => {\n+                    self.session.emit_err(errors::AssocConstWithoutBody {\n+                        span: item.span,\n+                        replace_span: self.ending_semi_or_hi(item.span),\n+                    });\n                 }\n                 AssocItemKind::Fn(box Fn { body, .. }) => {\n                     if body.is_none() {"}, {"sha": "007d64f681f76d156cab9e4c1afdca08a8626e6c", "filename": "compiler/rustc_ast_passes/src/feature_gate.rs", "status": "modified", "additions": 7, "deletions": 11, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/6efdf4d1309f8047bc439a4810888c715e2df480/compiler%2Frustc_ast_passes%2Fsrc%2Ffeature_gate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6efdf4d1309f8047bc439a4810888c715e2df480/compiler%2Frustc_ast_passes%2Fsrc%2Ffeature_gate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_passes%2Fsrc%2Ffeature_gate.rs?ref=6efdf4d1309f8047bc439a4810888c715e2df480", "patch": "@@ -404,11 +404,14 @@ impl<'a> Visitor<'a> for PostExpansionVisitor<'a> {\n                     );\n                 } else {\n                     // And if it isn't, cancel the early-pass warning.\n-                    self.sess\n+                    if let Some(err) = self\n+                        .sess\n                         .parse_sess\n                         .span_diagnostic\n                         .steal_diagnostic(e.span, StashKey::EarlySyntaxWarning)\n-                        .map(|err| err.cancel());\n+                    {\n+                        err.cancel()\n+                    }\n                 }\n             }\n             ast::ExprKind::TryBlock(_) => {\n@@ -485,17 +488,10 @@ impl<'a> Visitor<'a> for PostExpansionVisitor<'a> {\n             if let Some(args) = constraint.gen_args.as_ref()\n                 && matches!(\n                     args,\n-                    ast::GenericArgs::ReturnTypeNotation(..) | ast::GenericArgs::Parenthesized(..)\n+                    ast::GenericArgs::ReturnTypeNotation(..)\n                 )\n             {\n-                // RTN is gated elsewhere, and parenthesized args will turn into\n-                // another error.\n-                if matches!(args, ast::GenericArgs::Parenthesized(..)) {\n-                    self.sess.delay_span_bug(\n-                        constraint.span,\n-                        \"should have emitted a parenthesized generics error\",\n-                    );\n-                }\n+                // RTN is gated below with a `gate_all`.\n             } else {\n                 gate_feature_post!(\n                     &self,"}, {"sha": "1f6838a02784477720b5c4839b47ea9da5cdf5e0", "filename": "compiler/rustc_ast_pretty/src/pprust/state.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/6efdf4d1309f8047bc439a4810888c715e2df480/compiler%2Frustc_ast_pretty%2Fsrc%2Fpprust%2Fstate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6efdf4d1309f8047bc439a4810888c715e2df480/compiler%2Frustc_ast_pretty%2Fsrc%2Fpprust%2Fstate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_pretty%2Fsrc%2Fpprust%2Fstate.rs?ref=6efdf4d1309f8047bc439a4810888c715e2df480", "patch": "@@ -686,7 +686,7 @@ pub trait PrintState<'a>: std::ops::Deref<Target = pp::Printer> + std::ops::Dere\n     fn bclose_maybe_open(&mut self, span: rustc_span::Span, empty: bool, close_box: bool) {\n         let has_comment = self.maybe_print_comment(span.hi());\n         if !empty || has_comment {\n-            self.break_offset_if_not_bol(1, -(INDENT_UNIT as isize));\n+            self.break_offset_if_not_bol(1, -INDENT_UNIT);\n         }\n         self.word(\"}\");\n         if close_box {\n@@ -988,7 +988,9 @@ impl<'a> State<'a> {\n \n     pub fn print_assoc_constraint(&mut self, constraint: &ast::AssocConstraint) {\n         self.print_ident(constraint.ident);\n-        constraint.gen_args.as_ref().map(|args| self.print_generic_args(args, false));\n+        if let Some(args) = constraint.gen_args.as_ref() {\n+            self.print_generic_args(args, false)\n+        }\n         self.space();\n         match &constraint.kind {\n             ast::AssocConstraintKind::Equality { term } => {"}, {"sha": "c465f8c948a801ee468f3b6927d371fdd8218e26", "filename": "compiler/rustc_ast_pretty/src/pprust/state/item.rs", "status": "modified", "additions": 13, "deletions": 5, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/6efdf4d1309f8047bc439a4810888c715e2df480/compiler%2Frustc_ast_pretty%2Fsrc%2Fpprust%2Fstate%2Fitem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6efdf4d1309f8047bc439a4810888c715e2df480/compiler%2Frustc_ast_pretty%2Fsrc%2Fpprust%2Fstate%2Fitem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_pretty%2Fsrc%2Fpprust%2Fstate%2Fitem.rs?ref=6efdf4d1309f8047bc439a4810888c715e2df480", "patch": "@@ -2,6 +2,7 @@ use crate::pp::Breaks::Inconsistent;\n use crate::pprust::state::delimited::IterDelimited;\n use crate::pprust::state::{AnnNode, PrintState, State, INDENT_UNIT};\n \n+use ast::StaticItem;\n use rustc_ast as ast;\n use rustc_ast::GenericBound;\n use rustc_ast::ModKind;\n@@ -156,7 +157,7 @@ impl<'a> State<'a> {\n                 self.print_use_tree(tree);\n                 self.word(\";\");\n             }\n-            ast::ItemKind::Static(ty, mutbl, body) => {\n+            ast::ItemKind::Static(box StaticItem { ty, mutability: mutbl, expr: body }) => {\n                 let def = ast::Defaultness::Final;\n                 self.print_item_const(\n                     item.ident,\n@@ -167,8 +168,15 @@ impl<'a> State<'a> {\n                     def,\n                 );\n             }\n-            ast::ItemKind::Const(def, ty, body) => {\n-                self.print_item_const(item.ident, None, ty, body.as_deref(), &item.vis, *def);\n+            ast::ItemKind::Const(box ast::ConstItem { defaultness, ty, expr }) => {\n+                self.print_item_const(\n+                    item.ident,\n+                    None,\n+                    ty,\n+                    expr.as_deref(),\n+                    &item.vis,\n+                    *defaultness,\n+                );\n             }\n             ast::ItemKind::Fn(box ast::Fn { defaultness, sig, generics, body }) => {\n                 self.print_fn_full(\n@@ -507,8 +515,8 @@ impl<'a> State<'a> {\n             ast::AssocItemKind::Fn(box ast::Fn { defaultness, sig, generics, body }) => {\n                 self.print_fn_full(sig, ident, generics, vis, *defaultness, body.as_deref(), attrs);\n             }\n-            ast::AssocItemKind::Const(def, ty, body) => {\n-                self.print_item_const(ident, None, ty, body.as_deref(), vis, *def);\n+            ast::AssocItemKind::Const(box ast::ConstItem { defaultness, ty, expr }) => {\n+                self.print_item_const(ident, None, ty, expr.as_deref(), vis, *defaultness);\n             }\n             ast::AssocItemKind::Type(box ast::TyAlias {\n                 defaultness,"}, {"sha": "84f75caa6928aefa2aa372ddad8db66235a60a38", "filename": "compiler/rustc_borrowck/src/diagnostics/bound_region_errors.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6efdf4d1309f8047bc439a4810888c715e2df480/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fbound_region_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6efdf4d1309f8047bc439a4810888c715e2df480/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fbound_region_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fbound_region_errors.rs?ref=6efdf4d1309f8047bc439a4810888c715e2df480", "patch": "@@ -181,8 +181,8 @@ trait TypeOpInfo<'tcx> {\n         };\n \n         let placeholder_region = tcx.mk_re_placeholder(ty::Placeholder {\n-            name: placeholder.name,\n             universe: adjusted_universe.into(),\n+            bound: placeholder.bound,\n         });\n \n         let error_region =\n@@ -191,8 +191,8 @@ trait TypeOpInfo<'tcx> {\n                     error_placeholder.universe.as_u32().checked_sub(base_universe.as_u32());\n                 adjusted_universe.map(|adjusted| {\n                     tcx.mk_re_placeholder(ty::Placeholder {\n-                        name: error_placeholder.name,\n                         universe: adjusted.into(),\n+                        bound: error_placeholder.bound,\n                     })\n                 })\n             } else {"}, {"sha": "e2d04324f3b62a7c2bf7d03457b39b022dbe7297", "filename": "compiler/rustc_borrowck/src/diagnostics/find_use.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/6efdf4d1309f8047bc439a4810888c715e2df480/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Ffind_use.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6efdf4d1309f8047bc439a4810888c715e2df480/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Ffind_use.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Ffind_use.rs?ref=6efdf4d1309f8047bc439a4810888c715e2df480", "patch": "@@ -11,7 +11,7 @@ use crate::{\n };\n use rustc_data_structures::fx::FxIndexSet;\n use rustc_middle::mir::visit::{MirVisitable, PlaceContext, Visitor};\n-use rustc_middle::mir::{Body, Local, Location};\n+use rustc_middle::mir::{self, Body, Local, Location};\n use rustc_middle::ty::{RegionVid, TyCtxt};\n \n pub(crate) fn find<'tcx>(\n@@ -70,7 +70,10 @@ impl<'cx, 'tcx> UseFinder<'cx, 'tcx> {\n                             block_data\n                                 .terminator()\n                                 .successors()\n-                                .filter(|&bb| Some(&Some(bb)) != block_data.terminator().unwind())\n+                                .filter(|&bb| {\n+                                    Some(&mir::UnwindAction::Cleanup(bb))\n+                                        != block_data.terminator().unwind()\n+                                })\n                                 .map(|bb| Location { statement_index: 0, block: bb }),\n                         );\n                     }"}, {"sha": "110354a20d8393e94ca75f59fb82ea0762847a62", "filename": "compiler/rustc_borrowck/src/diagnostics/mod.rs", "status": "modified", "additions": 8, "deletions": 6, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/6efdf4d1309f8047bc439a4810888c715e2df480/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6efdf4d1309f8047bc439a4810888c715e2df480/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fmod.rs?ref=6efdf4d1309f8047bc439a4810888c715e2df480", "patch": "@@ -467,9 +467,10 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n         if let ty::Ref(region, ..) = ty.kind() {\n             match **region {\n                 ty::ReLateBound(_, ty::BoundRegion { kind: br, .. })\n-                | ty::RePlaceholder(ty::PlaceholderRegion { name: br, .. }) => {\n-                    printer.region_highlight_mode.highlighting_bound_region(br, counter)\n-                }\n+                | ty::RePlaceholder(ty::PlaceholderRegion {\n+                    bound: ty::BoundRegion { kind: br, .. },\n+                    ..\n+                }) => printer.region_highlight_mode.highlighting_bound_region(br, counter),\n                 _ => {}\n             }\n         }\n@@ -485,9 +486,10 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n         let region = if let ty::Ref(region, ..) = ty.kind() {\n             match **region {\n                 ty::ReLateBound(_, ty::BoundRegion { kind: br, .. })\n-                | ty::RePlaceholder(ty::PlaceholderRegion { name: br, .. }) => {\n-                    printer.region_highlight_mode.highlighting_bound_region(br, counter)\n-                }\n+                | ty::RePlaceholder(ty::PlaceholderRegion {\n+                    bound: ty::BoundRegion { kind: br, .. },\n+                    ..\n+                }) => printer.region_highlight_mode.highlighting_bound_region(br, counter),\n                 _ => {}\n             }\n             region"}, {"sha": "9fcebeb0acdc7ef670ce658c07afc56126dd1487", "filename": "compiler/rustc_borrowck/src/diagnostics/region_errors.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6efdf4d1309f8047bc439a4810888c715e2df480/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fregion_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6efdf4d1309f8047bc439a4810888c715e2df480/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fregion_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fregion_errors.rs?ref=6efdf4d1309f8047bc439a4810888c715e2df480", "patch": "@@ -207,7 +207,7 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n             .regioncx\n             .placeholders_contained_in(lower_bound)\n             .map(|placeholder| {\n-                if let Some(id) = placeholder.name.get_id()\n+                if let Some(id) = placeholder.bound.kind.get_id()\n                     && let Some(placeholder_id) = id.as_local()\n                     && let gat_hir_id = hir.local_def_id_to_hir_id(placeholder_id)\n                     && let Some(generics_impl) = hir.get_parent(gat_hir_id).generics()"}, {"sha": "498d254da65361bbfbf1b87c3a24089caab15304", "filename": "compiler/rustc_borrowck/src/invalidation.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/6efdf4d1309f8047bc439a4810888c715e2df480/compiler%2Frustc_borrowck%2Fsrc%2Finvalidation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6efdf4d1309f8047bc439a4810888c715e2df480/compiler%2Frustc_borrowck%2Fsrc%2Finvalidation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Finvalidation.rs?ref=6efdf4d1309f8047bc439a4810888c715e2df480", "patch": "@@ -125,7 +125,7 @@ impl<'cx, 'tcx> Visitor<'tcx> for InvalidationGenerator<'cx, 'tcx> {\n                 args,\n                 destination,\n                 target: _,\n-                cleanup: _,\n+                unwind: _,\n                 from_hir_call: _,\n                 fn_span: _,\n             } => {\n@@ -135,7 +135,7 @@ impl<'cx, 'tcx> Visitor<'tcx> for InvalidationGenerator<'cx, 'tcx> {\n                 }\n                 self.mutate_place(location, *destination, Deep);\n             }\n-            TerminatorKind::Assert { cond, expected: _, msg, target: _, cleanup: _ } => {\n+            TerminatorKind::Assert { cond, expected: _, msg, target: _, unwind: _ } => {\n                 self.consume_operand(location, cond);\n                 use rustc_middle::mir::AssertKind;\n                 if let AssertKind::BoundsCheck { len, index } = msg {\n@@ -173,7 +173,7 @@ impl<'cx, 'tcx> Visitor<'tcx> for InvalidationGenerator<'cx, 'tcx> {\n                 options: _,\n                 line_spans: _,\n                 destination: _,\n-                cleanup: _,\n+                unwind: _,\n             } => {\n                 for op in operands {\n                     match op {\n@@ -198,7 +198,7 @@ impl<'cx, 'tcx> Visitor<'tcx> for InvalidationGenerator<'cx, 'tcx> {\n                 }\n             }\n             TerminatorKind::Goto { target: _ }\n-            | TerminatorKind::Abort\n+            | TerminatorKind::Terminate\n             | TerminatorKind::Unreachable\n             | TerminatorKind::FalseEdge { real_target: _, imaginary_target: _ }\n             | TerminatorKind::FalseUnwind { real_target: _, unwind: _ } => {"}, {"sha": "3d876155fc9521ba82d0d57d2fa53f4008a6d31d", "filename": "compiler/rustc_borrowck/src/lib.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/6efdf4d1309f8047bc439a4810888c715e2df480/compiler%2Frustc_borrowck%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6efdf4d1309f8047bc439a4810888c715e2df480/compiler%2Frustc_borrowck%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Flib.rs?ref=6efdf4d1309f8047bc439a4810888c715e2df480", "patch": "@@ -740,7 +740,7 @@ impl<'cx, 'tcx> rustc_mir_dataflow::ResultsVisitor<'cx, 'tcx> for MirBorrowckCtx\n                 args,\n                 destination,\n                 target: _,\n-                cleanup: _,\n+                unwind: _,\n                 from_hir_call: _,\n                 fn_span: _,\n             } => {\n@@ -750,7 +750,7 @@ impl<'cx, 'tcx> rustc_mir_dataflow::ResultsVisitor<'cx, 'tcx> for MirBorrowckCtx\n                 }\n                 self.mutate_place(loc, (*destination, span), Deep, flow_state);\n             }\n-            TerminatorKind::Assert { cond, expected: _, msg, target: _, cleanup: _ } => {\n+            TerminatorKind::Assert { cond, expected: _, msg, target: _, unwind: _ } => {\n                 self.consume_operand(loc, (cond, span), flow_state);\n                 use rustc_middle::mir::AssertKind;\n                 if let AssertKind::BoundsCheck { len, index } = msg {\n@@ -770,7 +770,7 @@ impl<'cx, 'tcx> rustc_mir_dataflow::ResultsVisitor<'cx, 'tcx> for MirBorrowckCtx\n                 options: _,\n                 line_spans: _,\n                 destination: _,\n-                cleanup: _,\n+                unwind: _,\n             } => {\n                 for op in operands {\n                     match op {\n@@ -801,7 +801,7 @@ impl<'cx, 'tcx> rustc_mir_dataflow::ResultsVisitor<'cx, 'tcx> for MirBorrowckCtx\n             }\n \n             TerminatorKind::Goto { target: _ }\n-            | TerminatorKind::Abort\n+            | TerminatorKind::Terminate\n             | TerminatorKind::Unreachable\n             | TerminatorKind::Resume\n             | TerminatorKind::Return\n@@ -845,7 +845,7 @@ impl<'cx, 'tcx> rustc_mir_dataflow::ResultsVisitor<'cx, 'tcx> for MirBorrowckCtx\n                 }\n             }\n \n-            TerminatorKind::Abort\n+            TerminatorKind::Terminate\n             | TerminatorKind::Assert { .. }\n             | TerminatorKind::Call { .. }\n             | TerminatorKind::Drop { .. }"}, {"sha": "2c387edfef073cf0df2bb4a4f6a34e79445f9d37", "filename": "compiler/rustc_borrowck/src/type_check/liveness/local_use_map.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6efdf4d1309f8047bc439a4810888c715e2df480/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Fliveness%2Flocal_use_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6efdf4d1309f8047bc439a4810888c715e2df480/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Fliveness%2Flocal_use_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Fliveness%2Flocal_use_map.rs?ref=6efdf4d1309f8047bc439a4810888c715e2df480", "patch": "@@ -63,7 +63,7 @@ impl LocalUseMap {\n         elements: &RegionValueElements,\n         body: &Body<'_>,\n     ) -> Self {\n-        let nones = IndexVec::from_elem_n(None, body.local_decls.len());\n+        let nones = IndexVec::from_elem(None, &body.local_decls);\n         let mut local_use_map = LocalUseMap {\n             first_def_at: nones.clone(),\n             first_use_at: nones.clone(),\n@@ -76,7 +76,7 @@ impl LocalUseMap {\n         }\n \n         let mut locals_with_use_data: IndexVec<Local, bool> =\n-            IndexVec::from_elem_n(false, body.local_decls.len());\n+            IndexVec::from_elem(false, &body.local_decls);\n         live_locals.iter().for_each(|&local| locals_with_use_data[local] = true);\n \n         LocalUseMapBuild { local_use_map: &mut local_use_map, elements, locals_with_use_data }"}, {"sha": "624a4a00c319fddaded4e5db2aa4f707473703ea", "filename": "compiler/rustc_borrowck/src/type_check/mod.rs", "status": "modified", "additions": 33, "deletions": 32, "changes": 65, "blob_url": "https://github.com/rust-lang/rust/blob/6efdf4d1309f8047bc439a4810888c715e2df480/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6efdf4d1309f8047bc439a4810888c715e2df480/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Fmod.rs?ref=6efdf4d1309f8047bc439a4810888c715e2df480", "patch": "@@ -1300,7 +1300,7 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n         match &term.kind {\n             TerminatorKind::Goto { .. }\n             | TerminatorKind::Resume\n-            | TerminatorKind::Abort\n+            | TerminatorKind::Terminate\n             | TerminatorKind::Return\n             | TerminatorKind::GeneratorDrop\n             | TerminatorKind::Unreachable\n@@ -1342,9 +1342,7 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n \n                     let region_ctxt_fn = || {\n                         let reg_info = match br.kind {\n-                            ty::BoundRegionKind::BrAnon(_, Some(span)) => {\n-                                BoundRegionInfo::Span(span)\n-                            }\n+                            ty::BoundRegionKind::BrAnon(Some(span)) => BoundRegionInfo::Span(span),\n                             ty::BoundRegionKind::BrAnon(..) => {\n                                 BoundRegionInfo::Name(Symbol::intern(\"anon\"))\n                             }\n@@ -1584,7 +1582,7 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n                     span_mirbug!(self, block_data, \"resume on non-cleanup block!\")\n                 }\n             }\n-            TerminatorKind::Abort => {\n+            TerminatorKind::Terminate => {\n                 if !is_cleanup {\n                     span_mirbug!(self, block_data, \"abort on non-cleanup block!\")\n                 }\n@@ -1610,49 +1608,29 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n             }\n             TerminatorKind::Unreachable => {}\n             TerminatorKind::Drop { target, unwind, .. }\n-            | TerminatorKind::Assert { target, cleanup: unwind, .. } => {\n+            | TerminatorKind::Assert { target, unwind, .. } => {\n                 self.assert_iscleanup(body, block_data, target, is_cleanup);\n-                if let Some(unwind) = unwind {\n-                    if is_cleanup {\n-                        span_mirbug!(self, block_data, \"unwind on cleanup block\")\n-                    }\n-                    self.assert_iscleanup(body, block_data, unwind, true);\n-                }\n+                self.assert_iscleanup_unwind(body, block_data, unwind, is_cleanup);\n             }\n-            TerminatorKind::Call { ref target, cleanup, .. } => {\n+            TerminatorKind::Call { ref target, unwind, .. } => {\n                 if let &Some(target) = target {\n                     self.assert_iscleanup(body, block_data, target, is_cleanup);\n                 }\n-                if let Some(cleanup) = cleanup {\n-                    if is_cleanup {\n-                        span_mirbug!(self, block_data, \"cleanup on cleanup block\")\n-                    }\n-                    self.assert_iscleanup(body, block_data, cleanup, true);\n-                }\n+                self.assert_iscleanup_unwind(body, block_data, unwind, is_cleanup);\n             }\n             TerminatorKind::FalseEdge { real_target, imaginary_target } => {\n                 self.assert_iscleanup(body, block_data, real_target, is_cleanup);\n                 self.assert_iscleanup(body, block_data, imaginary_target, is_cleanup);\n             }\n             TerminatorKind::FalseUnwind { real_target, unwind } => {\n                 self.assert_iscleanup(body, block_data, real_target, is_cleanup);\n-                if let Some(unwind) = unwind {\n-                    if is_cleanup {\n-                        span_mirbug!(self, block_data, \"cleanup in cleanup block via false unwind\");\n-                    }\n-                    self.assert_iscleanup(body, block_data, unwind, true);\n-                }\n+                self.assert_iscleanup_unwind(body, block_data, unwind, is_cleanup);\n             }\n-            TerminatorKind::InlineAsm { destination, cleanup, .. } => {\n+            TerminatorKind::InlineAsm { destination, unwind, .. } => {\n                 if let Some(target) = destination {\n                     self.assert_iscleanup(body, block_data, target, is_cleanup);\n                 }\n-                if let Some(cleanup) = cleanup {\n-                    if is_cleanup {\n-                        span_mirbug!(self, block_data, \"cleanup on cleanup block\")\n-                    }\n-                    self.assert_iscleanup(body, block_data, cleanup, true);\n-                }\n+                self.assert_iscleanup_unwind(body, block_data, unwind, is_cleanup);\n             }\n         }\n     }\n@@ -1669,6 +1647,29 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n         }\n     }\n \n+    fn assert_iscleanup_unwind(\n+        &mut self,\n+        body: &Body<'tcx>,\n+        ctxt: &dyn fmt::Debug,\n+        unwind: UnwindAction,\n+        is_cleanup: bool,\n+    ) {\n+        match unwind {\n+            UnwindAction::Cleanup(unwind) => {\n+                if is_cleanup {\n+                    span_mirbug!(self, ctxt, \"unwind on cleanup block\")\n+                }\n+                self.assert_iscleanup(body, ctxt, unwind, true);\n+            }\n+            UnwindAction::Continue => {\n+                if is_cleanup {\n+                    span_mirbug!(self, ctxt, \"unwind on cleanup block\")\n+                }\n+            }\n+            UnwindAction::Unreachable | UnwindAction::Terminate => (),\n+        }\n+    }\n+\n     fn check_local(&mut self, body: &Body<'tcx>, local: Local, local_decl: &LocalDecl<'tcx>) {\n         match body.local_kind(local) {\n             LocalKind::ReturnPointer | LocalKind::Arg => {"}, {"sha": "83429f2ddef360e0cb6b1cf48238694e15f5e842", "filename": "compiler/rustc_borrowck/src/type_check/relate_tys.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6efdf4d1309f8047bc439a4810888c715e2df480/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Frelate_tys.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6efdf4d1309f8047bc439a4810888c715e2df480/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Frelate_tys.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Frelate_tys.rs?ref=6efdf4d1309f8047bc439a4810888c715e2df480", "patch": "@@ -123,8 +123,8 @@ impl<'tcx> TypeRelatingDelegate<'tcx> for NllTypeRelatingDelegate<'_, '_, 'tcx>\n             .constraints\n             .placeholder_region(self.type_checker.infcx, placeholder);\n \n-        let reg_info = match placeholder.name {\n-            ty::BoundRegionKind::BrAnon(_, Some(span)) => BoundRegionInfo::Span(span),\n+        let reg_info = match placeholder.bound.kind {\n+            ty::BoundRegionKind::BrAnon(Some(span)) => BoundRegionInfo::Span(span),\n             ty::BoundRegionKind::BrAnon(..) => BoundRegionInfo::Name(Symbol::intern(\"anon\")),\n             ty::BoundRegionKind::BrNamed(_, name) => BoundRegionInfo::Name(name),\n             ty::BoundRegionKind::BrEnv => BoundRegionInfo::Name(Symbol::intern(\"env\")),"}, {"sha": "866cc5adbf3b15b4b40a6029d15cdaf0e9414278", "filename": "compiler/rustc_builtin_macros/src/global_allocator.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6efdf4d1309f8047bc439a4810888c715e2df480/compiler%2Frustc_builtin_macros%2Fsrc%2Fglobal_allocator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6efdf4d1309f8047bc439a4810888c715e2df480/compiler%2Frustc_builtin_macros%2Fsrc%2Fglobal_allocator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fglobal_allocator.rs?ref=6efdf4d1309f8047bc439a4810888c715e2df480", "patch": "@@ -25,12 +25,12 @@ pub fn expand(\n     // FIXME - if we get deref patterns, use them to reduce duplication here\n     let (item, is_stmt, ty_span) =\n         if let Annotatable::Item(item) = &item\n-            && let ItemKind::Static(ty, ..) = &item.kind\n+            && let ItemKind::Static(box ast::StaticItem { ty, ..}) = &item.kind\n         {\n             (item, false, ecx.with_def_site_ctxt(ty.span))\n         } else if let Annotatable::Stmt(stmt) = &item\n             && let StmtKind::Item(item) = &stmt.kind\n-            && let ItemKind::Static(ty, ..) = &item.kind\n+            && let ItemKind::Static(box ast::StaticItem { ty, ..}) = &item.kind\n         {\n             (item, true, ecx.with_def_site_ctxt(ty.span))\n         } else {"}, {"sha": "7697b592e33a10b6fb8b4b4d7bd32d5f3687eaf0", "filename": "compiler/rustc_builtin_macros/src/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/6efdf4d1309f8047bc439a4810888c715e2df480/compiler%2Frustc_builtin_macros%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6efdf4d1309f8047bc439a4810888c715e2df480/compiler%2Frustc_builtin_macros%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Flib.rs?ref=6efdf4d1309f8047bc439a4810888c715e2df480", "patch": "@@ -7,7 +7,6 @@\n #![feature(box_patterns)]\n #![feature(decl_macro)]\n #![feature(if_let_guard)]\n-#![feature(is_some_and)]\n #![feature(is_sorted)]\n #![feature(let_chains)]\n #![feature(proc_macro_internals)]"}, {"sha": "a76ed4ee6cee35727467db0f5f5cbf6f563e5e0f", "filename": "compiler/rustc_builtin_macros/src/test.rs", "status": "modified", "additions": 26, "deletions": 22, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/6efdf4d1309f8047bc439a4810888c715e2df480/compiler%2Frustc_builtin_macros%2Fsrc%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6efdf4d1309f8047bc439a4810888c715e2df480/compiler%2Frustc_builtin_macros%2Fsrc%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Ftest.rs?ref=6efdf4d1309f8047bc439a4810888c715e2df480", "patch": "@@ -254,25 +254,27 @@ pub fn expand_test_or_bench(\n \n     let location_info = get_location_info(cx, &item);\n \n-    let mut test_const = cx.item(\n-        sp,\n-        Ident::new(item.ident.name, sp),\n-        thin_vec![\n-            // #[cfg(test)]\n-            cx.attr_nested_word(sym::cfg, sym::test, attr_sp),\n-            // #[rustc_test_marker = \"test_case_sort_key\"]\n-            cx.attr_name_value_str(sym::rustc_test_marker, test_path_symbol, attr_sp),\n-        ],\n-        // const $ident: test::TestDescAndFn =\n-        ast::ItemKind::Const(\n-            ast::Defaultness::Final,\n-            cx.ty(sp, ast::TyKind::Path(None, test_path(\"TestDescAndFn\"))),\n-            // test::TestDescAndFn {\n-            Some(\n-                cx.expr_struct(\n-                    sp,\n-                    test_path(\"TestDescAndFn\"),\n-                    thin_vec![\n+    let mut test_const =\n+        cx.item(\n+            sp,\n+            Ident::new(item.ident.name, sp),\n+            thin_vec![\n+                // #[cfg(test)]\n+                cx.attr_nested_word(sym::cfg, sym::test, attr_sp),\n+                // #[rustc_test_marker = \"test_case_sort_key\"]\n+                cx.attr_name_value_str(sym::rustc_test_marker, test_path_symbol, attr_sp),\n+            ],\n+            // const $ident: test::TestDescAndFn =\n+            ast::ItemKind::Const(\n+                ast::ConstItem {\n+                    defaultness: ast::Defaultness::Final,\n+                    ty: cx.ty(sp, ast::TyKind::Path(None, test_path(\"TestDescAndFn\"))),\n+                    // test::TestDescAndFn {\n+                    expr: Some(\n+                        cx.expr_struct(\n+                            sp,\n+                            test_path(\"TestDescAndFn\"),\n+                            thin_vec![\n                         // desc: test::TestDesc {\n                         field(\n                             \"desc\",\n@@ -359,10 +361,12 @@ pub fn expand_test_or_bench(\n                         // testfn: test::StaticTestFn(...) | test::StaticBenchFn(...)\n                         field(\"testfn\", test_fn), // }\n                     ],\n-                ), // }\n+                        ), // }\n+                    ),\n+                }\n+                .into(),\n             ),\n-        ),\n-    );\n+        );\n     test_const = test_const.map(|mut tc| {\n         tc.vis.kind = ast::VisibilityKind::Public;\n         tc"}, {"sha": "80f497333a632933a764385bfc771ec573c4f415", "filename": "compiler/rustc_builtin_macros/src/test_harness.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6efdf4d1309f8047bc439a4810888c715e2df480/compiler%2Frustc_builtin_macros%2Fsrc%2Ftest_harness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6efdf4d1309f8047bc439a4810888c715e2df480/compiler%2Frustc_builtin_macros%2Fsrc%2Ftest_harness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Ftest_harness.rs?ref=6efdf4d1309f8047bc439a4810888c715e2df480", "patch": "@@ -53,7 +53,7 @@ pub fn inject(krate: &mut ast::Crate, sess: &Session, resolver: &mut dyn Resolve\n     // even in non-test builds\n     let test_runner = get_test_runner(span_diagnostic, &krate);\n \n-    if sess.opts.test {\n+    if sess.is_test_crate() {\n         let panic_strategy = match (panic_strategy, sess.opts.unstable_opts.panic_abort_tests) {\n             (PanicStrategy::Abort, true) => PanicStrategy::Abort,\n             (PanicStrategy::Abort, false) => {"}, {"sha": "f5301f9f7f10b30077d16892c01b8a77d5a35d49", "filename": "compiler/rustc_codegen_cranelift/src/base.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/6efdf4d1309f8047bc439a4810888c715e2df480/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6efdf4d1309f8047bc439a4810888c715e2df480/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fbase.rs?ref=6efdf4d1309f8047bc439a4810888c715e2df480", "patch": "@@ -345,7 +345,7 @@ fn codegen_fn_body(fx: &mut FunctionCx<'_, '_, '_>, start_block: Block) {\n             TerminatorKind::Return => {\n                 crate::abi::codegen_return(fx);\n             }\n-            TerminatorKind::Assert { cond, expected, msg, target, cleanup: _ } => {\n+            TerminatorKind::Assert { cond, expected, msg, target, unwind: _ } => {\n                 if !fx.tcx.sess.overflow_checks() && msg.is_optional_overflow_check() {\n                     let target = fx.get_block(*target);\n                     fx.bcx.ins().jump(target, &[]);\n@@ -450,7 +450,7 @@ fn codegen_fn_body(fx: &mut FunctionCx<'_, '_, '_>, start_block: Block) {\n                 destination,\n                 target,\n                 fn_span,\n-                cleanup: _,\n+                unwind: _,\n                 from_hir_call: _,\n             } => {\n                 fx.tcx.prof.generic_activity(\"codegen call\").run(|| {\n@@ -470,7 +470,7 @@ fn codegen_fn_body(fx: &mut FunctionCx<'_, '_, '_>, start_block: Block) {\n                 options,\n                 destination,\n                 line_spans: _,\n-                cleanup: _,\n+                unwind: _,\n             } => {\n                 if options.contains(InlineAsmOptions::MAY_UNWIND) {\n                     fx.tcx.sess.span_fatal(\n@@ -488,7 +488,7 @@ fn codegen_fn_body(fx: &mut FunctionCx<'_, '_, '_>, start_block: Block) {\n                     *destination,\n                 );\n             }\n-            TerminatorKind::Abort => {\n+            TerminatorKind::Terminate => {\n                 codegen_panic_cannot_unwind(fx, source_info);\n             }\n             TerminatorKind::Resume => {"}, {"sha": "e87f4e258911a60f807d22319155e7cc95e2881f", "filename": "compiler/rustc_codegen_cranelift/src/constant.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6efdf4d1309f8047bc439a4810888c715e2df480/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fconstant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6efdf4d1309f8047bc439a4810888c715e2df480/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fconstant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fconstant.rs?ref=6efdf4d1309f8047bc439a4810888c715e2df480", "patch": "@@ -549,7 +549,7 @@ pub(crate) fn mir_operand_get_const_val<'tcx>(\n                     TerminatorKind::Goto { .. }\n                     | TerminatorKind::SwitchInt { .. }\n                     | TerminatorKind::Resume\n-                    | TerminatorKind::Abort\n+                    | TerminatorKind::Terminate\n                     | TerminatorKind::Return\n                     | TerminatorKind::Unreachable\n                     | TerminatorKind::Drop { .. }"}, {"sha": "e7668341eb6e728b0738e96ae110b200d638f8a4", "filename": "compiler/rustc_codegen_llvm/src/asm.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6efdf4d1309f8047bc439a4810888c715e2df480/compiler%2Frustc_codegen_llvm%2Fsrc%2Fasm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6efdf4d1309f8047bc439a4810888c715e2df480/compiler%2Frustc_codegen_llvm%2Fsrc%2Fasm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fasm.rs?ref=6efdf4d1309f8047bc439a4810888c715e2df480", "patch": "@@ -381,7 +381,7 @@ impl<'tcx> AsmMethods<'tcx> for CodegenCx<'_, 'tcx> {\n         }\n \n         unsafe {\n-            llvm::LLVMRustAppendModuleInlineAsm(\n+            llvm::LLVMAppendModuleInlineAsm(\n                 self.llmod,\n                 template_str.as_ptr().cast(),\n                 template_str.len(),"}, {"sha": "7136f750f39d9ee0a207de8ff16482b2c643c88f", "filename": "compiler/rustc_codegen_llvm/src/back/write.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6efdf4d1309f8047bc439a4810888c715e2df480/compiler%2Frustc_codegen_llvm%2Fsrc%2Fback%2Fwrite.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6efdf4d1309f8047bc439a4810888c715e2df480/compiler%2Frustc_codegen_llvm%2Fsrc%2Fback%2Fwrite.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fback%2Fwrite.rs?ref=6efdf4d1309f8047bc439a4810888c715e2df480", "patch": "@@ -904,9 +904,9 @@ unsafe fn embed_bitcode(\n         // We need custom section flags, so emit module-level inline assembly.\n         let section_flags = if cgcx.is_pe_coff { \"n\" } else { \"e\" };\n         let asm = create_section_with_flags_asm(\".llvmbc\", section_flags, bitcode);\n-        llvm::LLVMRustAppendModuleInlineAsm(llmod, asm.as_ptr().cast(), asm.len());\n+        llvm::LLVMAppendModuleInlineAsm(llmod, asm.as_ptr().cast(), asm.len());\n         let asm = create_section_with_flags_asm(\".llvmcmd\", section_flags, cmdline.as_bytes());\n-        llvm::LLVMRustAppendModuleInlineAsm(llmod, asm.as_ptr().cast(), asm.len());\n+        llvm::LLVMAppendModuleInlineAsm(llmod, asm.as_ptr().cast(), asm.len());\n     }\n }\n "}, {"sha": "6819a2af09da402482b99db9a7544b600c0a4b72", "filename": "compiler/rustc_codegen_llvm/src/builder.rs", "status": "modified", "additions": 18, "deletions": 11, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/6efdf4d1309f8047bc439a4810888c715e2df480/compiler%2Frustc_codegen_llvm%2Fsrc%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6efdf4d1309f8047bc439a4810888c715e2df480/compiler%2Frustc_codegen_llvm%2Fsrc%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fbuilder.rs?ref=6efdf4d1309f8047bc439a4810888c715e2df480", "patch": "@@ -2,7 +2,7 @@ use crate::abi::FnAbiLlvmExt;\n use crate::attributes;\n use crate::common::Funclet;\n use crate::context::CodegenCx;\n-use crate::llvm::{self, AtomicOrdering, AtomicRmwBinOp, BasicBlock};\n+use crate::llvm::{self, AtomicOrdering, AtomicRmwBinOp, BasicBlock, False, True};\n use crate::type_::Type;\n use crate::type_of::LayoutLlvmExt;\n use crate::value::Value;\n@@ -841,7 +841,15 @@ impl<'a, 'll, 'tcx> BuilderMethods<'a, 'tcx> for Builder<'a, 'll, 'tcx> {\n     }\n \n     fn intcast(&mut self, val: &'ll Value, dest_ty: &'ll Type, is_signed: bool) -> &'ll Value {\n-        unsafe { llvm::LLVMRustBuildIntCast(self.llbuilder, val, dest_ty, is_signed) }\n+        unsafe {\n+            llvm::LLVMBuildIntCast2(\n+                self.llbuilder,\n+                val,\n+                dest_ty,\n+                if is_signed { True } else { False },\n+                UNNAMED,\n+            )\n+        }\n     }\n \n     fn pointercast(&mut self, val: &'ll Value, dest_ty: &'ll Type) -> &'ll Value {\n@@ -1001,11 +1009,11 @@ impl<'a, 'll, 'tcx> BuilderMethods<'a, 'tcx> for Builder<'a, 'll, 'tcx> {\n     fn cleanup_pad(&mut self, parent: Option<&'ll Value>, args: &[&'ll Value]) -> Funclet<'ll> {\n         let name = cstr!(\"cleanuppad\");\n         let ret = unsafe {\n-            llvm::LLVMRustBuildCleanupPad(\n+            llvm::LLVMBuildCleanupPad(\n                 self.llbuilder,\n                 parent,\n-                args.len() as c_uint,\n                 args.as_ptr(),\n+                args.len() as c_uint,\n                 name.as_ptr(),\n             )\n         };\n@@ -1014,19 +1022,19 @@ impl<'a, 'll, 'tcx> BuilderMethods<'a, 'tcx> for Builder<'a, 'll, 'tcx> {\n \n     fn cleanup_ret(&mut self, funclet: &Funclet<'ll>, unwind: Option<&'ll BasicBlock>) {\n         unsafe {\n-            llvm::LLVMRustBuildCleanupRet(self.llbuilder, funclet.cleanuppad(), unwind)\n+            llvm::LLVMBuildCleanupRet(self.llbuilder, funclet.cleanuppad(), unwind)\n                 .expect(\"LLVM does not have support for cleanupret\");\n         }\n     }\n \n     fn catch_pad(&mut self, parent: &'ll Value, args: &[&'ll Value]) -> Funclet<'ll> {\n         let name = cstr!(\"catchpad\");\n         let ret = unsafe {\n-            llvm::LLVMRustBuildCatchPad(\n+            llvm::LLVMBuildCatchPad(\n                 self.llbuilder,\n                 parent,\n-                args.len() as c_uint,\n                 args.as_ptr(),\n+                args.len() as c_uint,\n                 name.as_ptr(),\n             )\n         };\n@@ -1041,7 +1049,7 @@ impl<'a, 'll, 'tcx> BuilderMethods<'a, 'tcx> for Builder<'a, 'll, 'tcx> {\n     ) -> &'ll Value {\n         let name = cstr!(\"catchswitch\");\n         let ret = unsafe {\n-            llvm::LLVMRustBuildCatchSwitch(\n+            llvm::LLVMBuildCatchSwitch(\n                 self.llbuilder,\n                 parent,\n                 unwind,\n@@ -1052,7 +1060,7 @@ impl<'a, 'll, 'tcx> BuilderMethods<'a, 'tcx> for Builder<'a, 'll, 'tcx> {\n         let ret = ret.expect(\"LLVM does not have support for catchswitch\");\n         for handler in handlers {\n             unsafe {\n-                llvm::LLVMRustAddHandler(ret, handler);\n+                llvm::LLVMAddHandler(ret, handler);\n             }\n         }\n         ret\n@@ -1376,8 +1384,7 @@ impl<'a, 'll, 'tcx> Builder<'a, 'll, 'tcx> {\n     }\n \n     pub fn catch_ret(&mut self, funclet: &Funclet<'ll>, unwind: &'ll BasicBlock) -> &'ll Value {\n-        let ret =\n-            unsafe { llvm::LLVMRustBuildCatchRet(self.llbuilder, funclet.cleanuppad(), unwind) };\n+        let ret = unsafe { llvm::LLVMBuildCatchRet(self.llbuilder, funclet.cleanuppad(), unwind) };\n         ret.expect(\"LLVM does not have support for catchret\")\n     }\n "}, {"sha": "940358acde9a2ad72cd982f43f1d62b17e930996", "filename": "compiler/rustc_codegen_llvm/src/consts.rs", "status": "modified", "additions": 7, "deletions": 10, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/6efdf4d1309f8047bc439a4810888c715e2df480/compiler%2Frustc_codegen_llvm%2Fsrc%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6efdf4d1309f8047bc439a4810888c715e2df480/compiler%2Frustc_codegen_llvm%2Fsrc%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fconsts.rs?ref=6efdf4d1309f8047bc439a4810888c715e2df480", "patch": "@@ -7,7 +7,6 @@ use crate::type_::Type;\n use crate::type_of::LayoutLlvmExt;\n use crate::value::Value;\n use cstr::cstr;\n-use libc::c_uint;\n use rustc_codegen_ssa::traits::*;\n use rustc_hir::def_id::DefId;\n use rustc_middle::middle::codegen_fn_attrs::{CodegenFnAttrFlags, CodegenFnAttrs};\n@@ -486,10 +485,10 @@ impl<'ll> StaticMethods for CodegenCx<'ll, '_> {\n             // go into custom sections of the wasm executable.\n             if self.tcx.sess.target.is_like_wasm {\n                 if let Some(section) = attrs.link_section {\n-                    let section = llvm::LLVMMDStringInContext(\n+                    let section = llvm::LLVMMDStringInContext2(\n                         self.llcx,\n                         section.as_str().as_ptr().cast(),\n-                        section.as_str().len() as c_uint,\n+                        section.as_str().len(),\n                     );\n                     assert!(alloc.provenance().ptrs().is_empty());\n \n@@ -498,17 +497,15 @@ impl<'ll> StaticMethods for CodegenCx<'ll, '_> {\n                     // as part of the interpreter execution).\n                     let bytes =\n                         alloc.inspect_with_uninit_and_ptr_outside_interpreter(0..alloc.len());\n-                    let alloc = llvm::LLVMMDStringInContext(\n-                        self.llcx,\n-                        bytes.as_ptr().cast(),\n-                        bytes.len() as c_uint,\n-                    );\n+                    let alloc =\n+                        llvm::LLVMMDStringInContext2(self.llcx, bytes.as_ptr().cast(), bytes.len());\n                     let data = [section, alloc];\n-                    let meta = llvm::LLVMMDNodeInContext(self.llcx, data.as_ptr(), 2);\n+                    let meta = llvm::LLVMMDNodeInContext2(self.llcx, data.as_ptr(), data.len());\n+                    let val = llvm::LLVMMetadataAsValue(self.llcx, meta);\n                     llvm::LLVMAddNamedMetadataOperand(\n                         self.llmod,\n                         \"wasm.custom_sections\\0\".as_ptr().cast(),\n-                        meta,\n+                        val,\n                     );\n                 }\n             } else {"}, {"sha": "21a0a60b012a6f27eb2d7317d8824b236cb41052", "filename": "compiler/rustc_codegen_llvm/src/debuginfo/metadata.rs", "status": "modified", "additions": 8, "deletions": 36, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/6efdf4d1309f8047bc439a4810888c715e2df480/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdebuginfo%2Fmetadata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6efdf4d1309f8047bc439a4810888c715e2df480/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdebuginfo%2Fmetadata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdebuginfo%2Fmetadata.rs?ref=6efdf4d1309f8047bc439a4810888c715e2df480", "patch": "@@ -830,24 +830,7 @@ pub fn build_compile_unit_di_node<'ll, 'tcx>(\n     }\n     .unwrap_or_default();\n     let split_name = split_name.to_str().unwrap();\n-\n-    // FIXME(#60020):\n-    //\n-    //    This should actually be\n-    //\n-    //        let kind = DebugEmissionKind::from_generic(tcx.sess.opts.debuginfo);\n-    //\n-    //    That is, we should set LLVM's emission kind to `LineTablesOnly` if\n-    //    we are compiling with \"limited\" debuginfo. However, some of the\n-    //    existing tools relied on slightly more debuginfo being generated than\n-    //    would be the case with `LineTablesOnly`, and we did not want to break\n-    //    these tools in a \"drive-by fix\", without a good idea or plan about\n-    //    what limited debuginfo should exactly look like. So for now we keep\n-    //    the emission kind as `FullDebug`.\n-    //\n-    //    See https://github.com/rust-lang/rust/issues/60020 for details.\n-    let kind = DebugEmissionKind::FullDebug;\n-    assert!(tcx.sess.opts.debuginfo != DebugInfo::None);\n+    let kind = DebugEmissionKind::from_generic(tcx.sess.opts.debuginfo);\n \n     unsafe {\n         let compile_unit_file = llvm::LLVMRustDIBuilderCreateFile(\n@@ -881,29 +864,24 @@ pub fn build_compile_unit_di_node<'ll, 'tcx>(\n         );\n \n         if tcx.sess.opts.unstable_opts.profile {\n-            let cu_desc_metadata =\n-                llvm::LLVMRustMetadataAsValue(debug_context.llcontext, unit_metadata);\n             let default_gcda_path = &output_filenames.with_extension(\"gcda\");\n             let gcda_path =\n                 tcx.sess.opts.unstable_opts.profile_emit.as_ref().unwrap_or(default_gcda_path);\n \n             let gcov_cu_info = [\n                 path_to_mdstring(debug_context.llcontext, &output_filenames.with_extension(\"gcno\")),\n                 path_to_mdstring(debug_context.llcontext, gcda_path),\n-                cu_desc_metadata,\n+                unit_metadata,\n             ];\n-            let gcov_metadata = llvm::LLVMMDNodeInContext(\n+            let gcov_metadata = llvm::LLVMMDNodeInContext2(\n                 debug_context.llcontext,\n                 gcov_cu_info.as_ptr(),\n-                gcov_cu_info.len() as c_uint,\n+                gcov_cu_info.len(),\n             );\n+            let val = llvm::LLVMMetadataAsValue(debug_context.llcontext, gcov_metadata);\n \n             let llvm_gcov_ident = cstr!(\"llvm.gcov\");\n-            llvm::LLVMAddNamedMetadataOperand(\n-                debug_context.llmod,\n-                llvm_gcov_ident.as_ptr(),\n-                gcov_metadata,\n-            );\n+            llvm::LLVMAddNamedMetadataOperand(debug_context.llmod, llvm_gcov_ident.as_ptr(), val);\n         }\n \n         // Insert `llvm.ident` metadata on the wasm targets since that will\n@@ -924,15 +902,9 @@ pub fn build_compile_unit_di_node<'ll, 'tcx>(\n         return unit_metadata;\n     };\n \n-    fn path_to_mdstring<'ll>(llcx: &'ll llvm::Context, path: &Path) -> &'ll Value {\n+    fn path_to_mdstring<'ll>(llcx: &'ll llvm::Context, path: &Path) -> &'ll llvm::Metadata {\n         let path_str = path_to_c_string(path);\n-        unsafe {\n-            llvm::LLVMMDStringInContext(\n-                llcx,\n-                path_str.as_ptr(),\n-                path_str.as_bytes().len() as c_uint,\n-            )\n-        }\n+        unsafe { llvm::LLVMMDStringInContext2(llcx, path_str.as_ptr(), path_str.as_bytes().len()) }\n     }\n }\n "}, {"sha": "d56c414cf651e535107f97f6ed5c4a0102cc1ade", "filename": "compiler/rustc_codegen_llvm/src/debuginfo/mod.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/6efdf4d1309f8047bc439a4810888c715e2df480/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdebuginfo%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6efdf4d1309f8047bc439a4810888c715e2df480/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdebuginfo%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdebuginfo%2Fmod.rs?ref=6efdf4d1309f8047bc439a4810888c715e2df480", "patch": "@@ -209,8 +209,7 @@ impl<'ll> DebugInfoBuilderMethods for Builder<'_, 'll, '_> {\n \n     fn set_dbg_loc(&mut self, dbg_loc: &'ll DILocation) {\n         unsafe {\n-            let dbg_loc_as_llval = llvm::LLVMRustMetadataAsValue(self.cx().llcx, dbg_loc);\n-            llvm::LLVMSetCurrentDebugLocation(self.llbuilder, dbg_loc_as_llval);\n+            llvm::LLVMSetCurrentDebugLocation2(self.llbuilder, dbg_loc);\n         }\n     }\n \n@@ -402,7 +401,7 @@ impl<'ll, 'tcx> DebugInfoMethods<'tcx> for CodegenCx<'ll, 'tcx> {\n             cx: &CodegenCx<'ll, 'tcx>,\n             fn_abi: &FnAbi<'tcx, Ty<'tcx>>,\n         ) -> &'ll DIArray {\n-            if cx.sess().opts.debuginfo == DebugInfo::Limited {\n+            if cx.sess().opts.debuginfo != DebugInfo::Full {\n                 return create_DIArray(DIB(cx), &[]);\n             }\n "}, {"sha": "09f3fe0216503ca67a5201002bc1fa1687b71c60", "filename": "compiler/rustc_codegen_llvm/src/llvm/ffi.rs", "status": "modified", "additions": 39, "deletions": 19, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/6efdf4d1309f8047bc439a4810888c715e2df480/compiler%2Frustc_codegen_llvm%2Fsrc%2Fllvm%2Fffi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6efdf4d1309f8047bc439a4810888c715e2df480/compiler%2Frustc_codegen_llvm%2Fsrc%2Fllvm%2Fffi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fllvm%2Fffi.rs?ref=6efdf4d1309f8047bc439a4810888c715e2df480", "patch": "@@ -946,15 +946,27 @@ pub mod debuginfo {\n         NoDebug,\n         FullDebug,\n         LineTablesOnly,\n+        DebugDirectivesOnly,\n     }\n \n     impl DebugEmissionKind {\n         pub fn from_generic(kind: rustc_session::config::DebugInfo) -> Self {\n+            // We should be setting LLVM's emission kind to `LineTablesOnly` if\n+            // we are compiling with \"limited\" debuginfo. However, some of the\n+            // existing tools relied on slightly more debuginfo being generated than\n+            // would be the case with `LineTablesOnly`, and we did not want to break\n+            // these tools in a \"drive-by fix\", without a good idea or plan about\n+            // what limited debuginfo should exactly look like. So for now we are\n+            // instead adding a new debuginfo option \"line-tables-only\" so as to\n+            // not break anything and to allow users to have 'limited' debug info.\n+            //\n+            // See https://github.com/rust-lang/rust/issues/60020 for details.\n             use rustc_session::config::DebugInfo;\n             match kind {\n                 DebugInfo::None => DebugEmissionKind::NoDebug,\n-                DebugInfo::Limited => DebugEmissionKind::LineTablesOnly,\n-                DebugInfo::Full => DebugEmissionKind::FullDebug,\n+                DebugInfo::LineDirectivesOnly => DebugEmissionKind::DebugDirectivesOnly,\n+                DebugInfo::LineTablesOnly => DebugEmissionKind::LineTablesOnly,\n+                DebugInfo::Limited | DebugInfo::Full => DebugEmissionKind::FullDebug,\n             }\n         }\n     }\n@@ -1006,7 +1018,7 @@ extern \"C\" {\n     pub fn LLVMSetDataLayout(M: &Module, Triple: *const c_char);\n \n     /// See Module::setModuleInlineAsm.\n-    pub fn LLVMRustAppendModuleInlineAsm(M: &Module, Asm: *const c_char, AsmLen: size_t);\n+    pub fn LLVMAppendModuleInlineAsm(M: &Module, Asm: *const c_char, Len: size_t);\n \n     /// See llvm::LLVMTypeKind::getTypeID.\n     pub fn LLVMRustGetTypeKind(Ty: &Type) -> TypeKind;\n@@ -1053,7 +1065,7 @@ extern \"C\" {\n \n     // Operations on other types\n     pub fn LLVMVoidTypeInContext(C: &Context) -> &Type;\n-    pub fn LLVMRustMetadataTypeInContext(C: &Context) -> &Type;\n+    pub fn LLVMMetadataTypeInContext(C: &Context) -> &Type;\n \n     // Operations on all values\n     pub fn LLVMTypeOf(Val: &Value) -> &Type;\n@@ -1072,7 +1084,12 @@ extern \"C\" {\n     pub fn LLVMGetPoison(Ty: &Type) -> &Value;\n \n     // Operations on metadata\n+    // FIXME: deprecated, replace with LLVMMDStringInContext2\n     pub fn LLVMMDStringInContext(C: &Context, Str: *const c_char, SLen: c_uint) -> &Value;\n+\n+    pub fn LLVMMDStringInContext2(C: &Context, Str: *const c_char, SLen: size_t) -> &Metadata;\n+\n+    // FIXME: deprecated, replace with LLVMMDNodeInContext2\n     pub fn LLVMMDNodeInContext<'a>(\n         C: &'a Context,\n         Vals: *const &'a Value,\n@@ -1111,6 +1128,8 @@ extern \"C\" {\n         Packed: Bool,\n     ) -> &'a Value;\n \n+    // FIXME: replace with LLVMConstArray2 when bumped minimal version to llvm-17\n+    // https://github.com/llvm/llvm-project/commit/35276f16e5a2cae0dfb49c0fbf874d4d2f177acc\n     pub fn LLVMConstArray<'a>(\n         ElementTy: &'a Type,\n         ConstantVals: *const &'a Value,\n@@ -1250,7 +1269,7 @@ extern \"C\" {\n     pub fn LLVMDisposeBuilder<'a>(Builder: &'a mut Builder<'a>);\n \n     // Metadata\n-    pub fn LLVMSetCurrentDebugLocation<'a>(Builder: &Builder<'a>, L: &'a Value);\n+    pub fn LLVMSetCurrentDebugLocation2<'a>(Builder: &Builder<'a>, Loc: &'a Metadata);\n \n     // Terminators\n     pub fn LLVMBuildRetVoid<'a>(B: &Builder<'a>) -> &'a Value;\n@@ -1290,38 +1309,38 @@ extern \"C\" {\n     pub fn LLVMBuildResume<'a>(B: &Builder<'a>, Exn: &'a Value) -> &'a Value;\n     pub fn LLVMBuildUnreachable<'a>(B: &Builder<'a>) -> &'a Value;\n \n-    pub fn LLVMRustBuildCleanupPad<'a>(\n+    pub fn LLVMBuildCleanupPad<'a>(\n         B: &Builder<'a>,\n         ParentPad: Option<&'a Value>,\n-        ArgCnt: c_uint,\n         Args: *const &'a Value,\n+        NumArgs: c_uint,\n         Name: *const c_char,\n     ) -> Option<&'a Value>;\n-    pub fn LLVMRustBuildCleanupRet<'a>(\n+    pub fn LLVMBuildCleanupRet<'a>(\n         B: &Builder<'a>,\n         CleanupPad: &'a Value,\n-        UnwindBB: Option<&'a BasicBlock>,\n+        BB: Option<&'a BasicBlock>,\n     ) -> Option<&'a Value>;\n-    pub fn LLVMRustBuildCatchPad<'a>(\n+    pub fn LLVMBuildCatchPad<'a>(\n         B: &Builder<'a>,\n         ParentPad: &'a Value,\n-        ArgCnt: c_uint,\n         Args: *const &'a Value,\n+        NumArgs: c_uint,\n         Name: *const c_char,\n     ) -> Option<&'a Value>;\n-    pub fn LLVMRustBuildCatchRet<'a>(\n+    pub fn LLVMBuildCatchRet<'a>(\n         B: &Builder<'a>,\n-        Pad: &'a Value,\n+        CatchPad: &'a Value,\n         BB: &'a BasicBlock,\n     ) -> Option<&'a Value>;\n-    pub fn LLVMRustBuildCatchSwitch<'a>(\n+    pub fn LLVMBuildCatchSwitch<'a>(\n         Builder: &Builder<'a>,\n         ParentPad: Option<&'a Value>,\n-        BB: Option<&'a BasicBlock>,\n+        UnwindBB: Option<&'a BasicBlock>,\n         NumHandlers: c_uint,\n         Name: *const c_char,\n     ) -> Option<&'a Value>;\n-    pub fn LLVMRustAddHandler<'a>(CatchSwitch: &'a Value, Handler: &'a BasicBlock);\n+    pub fn LLVMAddHandler<'a>(CatchSwitch: &'a Value, Dest: &'a BasicBlock);\n     pub fn LLVMSetPersonalityFn<'a>(Func: &'a Value, Pers: &'a Value);\n \n     // Add a case to the switch instruction\n@@ -1615,11 +1634,12 @@ extern \"C\" {\n         DestTy: &'a Type,\n         Name: *const c_char,\n     ) -> &'a Value;\n-    pub fn LLVMRustBuildIntCast<'a>(\n+    pub fn LLVMBuildIntCast2<'a>(\n         B: &Builder<'a>,\n         Val: &'a Value,\n         DestTy: &'a Type,\n-        IsSigned: bool,\n+        IsSigned: Bool,\n+        Name: *const c_char,\n     ) -> &'a Value;\n \n     // Comparisons\n@@ -1908,7 +1928,7 @@ extern \"C\" {\n     );\n     pub fn LLVMRustHasModuleFlag(M: &Module, name: *const c_char, len: size_t) -> bool;\n \n-    pub fn LLVMRustMetadataAsValue<'a>(C: &'a Context, MD: &'a Metadata) -> &'a Value;\n+    pub fn LLVMMetadataAsValue<'a>(C: &'a Context, MD: &'a Metadata) -> &'a Value;\n \n     pub fn LLVMRustDIBuilderCreate(M: &Module) -> &mut DIBuilder<'_>;\n "}, {"sha": "bef4647f20789c72abf07c7d9f1537b16d86c88e", "filename": "compiler/rustc_codegen_llvm/src/type_.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6efdf4d1309f8047bc439a4810888c715e2df480/compiler%2Frustc_codegen_llvm%2Fsrc%2Ftype_.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6efdf4d1309f8047bc439a4810888c715e2df480/compiler%2Frustc_codegen_llvm%2Fsrc%2Ftype_.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Ftype_.rs?ref=6efdf4d1309f8047bc439a4810888c715e2df480", "patch": "@@ -53,7 +53,7 @@ impl<'ll> CodegenCx<'ll, '_> {\n     }\n \n     pub(crate) fn type_metadata(&self) -> &'ll Type {\n-        unsafe { llvm::LLVMRustMetadataTypeInContext(self.llcx) }\n+        unsafe { llvm::LLVMMetadataTypeInContext(self.llcx) }\n     }\n \n     ///x Creates an integer type with the given number of bits, e.g., i24"}, {"sha": "7a5fa5a370cb9af889e177adaf1bf8c92df764ec", "filename": "compiler/rustc_codegen_ssa/src/back/link.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6efdf4d1309f8047bc439a4810888c715e2df480/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6efdf4d1309f8047bc439a4810888c715e2df480/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Flink.rs?ref=6efdf4d1309f8047bc439a4810888c715e2df480", "patch": "@@ -2301,7 +2301,7 @@ fn add_native_libs_from_crate(\n                         || (whole_archive == None\n                             && bundle\n                             && cnum == LOCAL_CRATE\n-                            && sess.opts.test);\n+                            && sess.is_test_crate());\n \n                     if bundle && cnum != LOCAL_CRATE {\n                         if let Some(filename) = lib.filename {"}, {"sha": "65dfc325a118f8b23837fd6f64c1ad99c4eef716", "filename": "compiler/rustc_codegen_ssa/src/back/linker.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/6efdf4d1309f8047bc439a4810888c715e2df480/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Flinker.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6efdf4d1309f8047bc439a4810888c715e2df480/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Flinker.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Flinker.rs?ref=6efdf4d1309f8047bc439a4810888c715e2df480", "patch": "@@ -1121,9 +1121,12 @@ impl<'a> Linker for EmLinker<'a> {\n \n     fn debuginfo(&mut self, _strip: Strip, _: &[PathBuf]) {\n         // Preserve names or generate source maps depending on debug info\n+        // For more information see https://emscripten.org/docs/tools_reference/emcc.html#emcc-g\n         self.cmd.arg(match self.sess.opts.debuginfo {\n             DebugInfo::None => \"-g0\",\n-            DebugInfo::Limited => \"--profiling-funcs\",\n+            DebugInfo::Limited | DebugInfo::LineTablesOnly | DebugInfo::LineDirectivesOnly => {\n+                \"--profiling-funcs\"\n+            }\n             DebugInfo::Full => \"-g\",\n         });\n     }"}, {"sha": "3e3fcc08bd64470448001fbc19df6409ba19a3a8", "filename": "compiler/rustc_codegen_ssa/src/back/metadata.rs", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/6efdf4d1309f8047bc439a4810888c715e2df480/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Fmetadata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6efdf4d1309f8047bc439a4810888c715e2df480/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Fmetadata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Fmetadata.rs?ref=6efdf4d1309f8047bc439a4810888c715e2df480", "patch": "@@ -13,8 +13,7 @@ use object::{\n use snap::write::FrameEncoder;\n \n use rustc_data_structures::memmap::Mmap;\n-use rustc_data_structures::owning_ref::OwningRef;\n-use rustc_data_structures::rustc_erase_owner;\n+use rustc_data_structures::owned_slice::try_slice_owned;\n use rustc_data_structures::sync::MetadataRef;\n use rustc_metadata::fs::METADATA_FILENAME;\n use rustc_metadata::EncodedMetadata;\n@@ -42,10 +41,10 @@ fn load_metadata_with(\n ) -> Result<MetadataRef, String> {\n     let file =\n         File::open(path).map_err(|e| format!(\"failed to open file '{}': {}\", path.display(), e))?;\n-    let data = unsafe { Mmap::map(file) }\n-        .map_err(|e| format!(\"failed to mmap file '{}': {}\", path.display(), e))?;\n-    let metadata = OwningRef::new(data).try_map(f)?;\n-    return Ok(rustc_erase_owner!(metadata.map_owner_box()));\n+\n+    unsafe { Mmap::map(file) }\n+        .map_err(|e| format!(\"failed to mmap file '{}': {}\", path.display(), e))\n+        .and_then(|mmap| try_slice_owned(mmap, |mmap| f(mmap)))\n }\n \n impl MetadataLoader for DefaultMetadataLoader {"}, {"sha": "115a41050d2a3f5804896a3c1e39e9c0c3e929e2", "filename": "compiler/rustc_codegen_ssa/src/mir/analyze.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/6efdf4d1309f8047bc439a4810888c715e2df480/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fanalyze.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6efdf4d1309f8047bc439a4810888c715e2df480/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fanalyze.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fanalyze.rs?ref=6efdf4d1309f8047bc439a4810888c715e2df480", "patch": "@@ -284,19 +284,19 @@ pub fn cleanup_kinds(mir: &mir::Body<'_>) -> IndexVec<mir::BasicBlock, CleanupKi\n             match data.terminator().kind {\n                 TerminatorKind::Goto { .. }\n                 | TerminatorKind::Resume\n-                | TerminatorKind::Abort\n+                | TerminatorKind::Terminate\n                 | TerminatorKind::Return\n                 | TerminatorKind::GeneratorDrop\n                 | TerminatorKind::Unreachable\n                 | TerminatorKind::SwitchInt { .. }\n                 | TerminatorKind::Yield { .. }\n                 | TerminatorKind::FalseEdge { .. }\n                 | TerminatorKind::FalseUnwind { .. } => { /* nothing to do */ }\n-                TerminatorKind::Call { cleanup: unwind, .. }\n-                | TerminatorKind::InlineAsm { cleanup: unwind, .. }\n-                | TerminatorKind::Assert { cleanup: unwind, .. }\n+                TerminatorKind::Call { unwind, .. }\n+                | TerminatorKind::InlineAsm { unwind, .. }\n+                | TerminatorKind::Assert { unwind, .. }\n                 | TerminatorKind::Drop { unwind, .. } => {\n-                    if let Some(unwind) = unwind {\n+                    if let mir::UnwindAction::Cleanup(unwind) = unwind {\n                         debug!(\n                             \"cleanup_kinds: {:?}/{:?} registering {:?} as funclet\",\n                             bb, data, unwind"}, {"sha": "dd86977817fbc1992c57de107f86a5c1164734b6", "filename": "compiler/rustc_codegen_ssa/src/mir/block.rs", "status": "modified", "additions": 118, "deletions": 109, "changes": 227, "blob_url": "https://github.com/rust-lang/rust/blob/6efdf4d1309f8047bc439a4810888c715e2df480/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6efdf4d1309f8047bc439a4810888c715e2df480/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fblock.rs?ref=6efdf4d1309f8047bc439a4810888c715e2df480", "patch": "@@ -147,7 +147,7 @@ impl<'a, 'tcx> TerminatorCodegenHelper<'tcx> {\n     }\n \n     /// Call `fn_ptr` of `fn_abi` with the arguments `llargs`, the optional\n-    /// return destination `destination` and the cleanup function `cleanup`.\n+    /// return destination `destination` and the unwind action `unwind`.\n     fn do_call<Bx: BuilderMethods<'a, 'tcx>>(\n         &self,\n         fx: &mut FunctionCx<'a, 'tcx, Bx>,\n@@ -156,31 +156,31 @@ impl<'a, 'tcx> TerminatorCodegenHelper<'tcx> {\n         fn_ptr: Bx::Value,\n         llargs: &[Bx::Value],\n         destination: Option<(ReturnDest<'tcx, Bx::Value>, mir::BasicBlock)>,\n-        cleanup: Option<mir::BasicBlock>,\n+        mut unwind: mir::UnwindAction,\n         copied_constant_arguments: &[PlaceRef<'tcx, <Bx as BackendTypes>::Value>],\n         mergeable_succ: bool,\n     ) -> MergingSucc {\n         // If there is a cleanup block and the function we're calling can unwind, then\n         // do an invoke, otherwise do a call.\n         let fn_ty = bx.fn_decl_backend_type(&fn_abi);\n \n-        let unwind_block = if let Some(cleanup) = cleanup.filter(|_| fn_abi.can_unwind) {\n-            Some(self.llbb_with_cleanup(fx, cleanup))\n-        } else if fx.mir[self.bb].is_cleanup\n-            && fn_abi.can_unwind\n-            && !base::wants_msvc_seh(fx.cx.tcx().sess)\n-        {\n-            // Exception must not propagate out of the execution of a cleanup (doing so\n-            // can cause undefined behaviour). We insert a double unwind guard for\n-            // functions that can potentially unwind to protect against this.\n-            //\n-            // This is not necessary for SEH which does not use successive unwinding\n-            // like Itanium EH. EH frames in SEH are different from normal function\n-            // frames and SEH will abort automatically if an exception tries to\n-            // propagate out from cleanup.\n-            Some(fx.double_unwind_guard())\n-        } else {\n-            None\n+        if !fn_abi.can_unwind {\n+            unwind = mir::UnwindAction::Unreachable;\n+        }\n+\n+        let unwind_block = match unwind {\n+            mir::UnwindAction::Cleanup(cleanup) => Some(self.llbb_with_cleanup(fx, cleanup)),\n+            mir::UnwindAction::Continue => None,\n+            mir::UnwindAction::Unreachable => None,\n+            mir::UnwindAction::Terminate => {\n+                if fx.mir[self.bb].is_cleanup && base::wants_msvc_seh(fx.cx.tcx().sess) {\n+                    // SEH will abort automatically if an exception tries to\n+                    // propagate out from cleanup.\n+                    None\n+                } else {\n+                    Some(fx.terminate_block())\n+                }\n+            }\n         };\n \n         if let Some(unwind_block) = unwind_block {\n@@ -234,7 +234,7 @@ impl<'a, 'tcx> TerminatorCodegenHelper<'tcx> {\n         }\n     }\n \n-    /// Generates inline assembly with optional `destination` and `cleanup`.\n+    /// Generates inline assembly with optional `destination` and `unwind`.\n     fn do_inlineasm<Bx: BuilderMethods<'a, 'tcx>>(\n         &self,\n         fx: &mut FunctionCx<'a, 'tcx, Bx>,\n@@ -244,11 +244,18 @@ impl<'a, 'tcx> TerminatorCodegenHelper<'tcx> {\n         options: InlineAsmOptions,\n         line_spans: &[Span],\n         destination: Option<mir::BasicBlock>,\n-        cleanup: Option<mir::BasicBlock>,\n+        unwind: mir::UnwindAction,\n         instance: Instance<'_>,\n         mergeable_succ: bool,\n     ) -> MergingSucc {\n-        if let Some(cleanup) = cleanup {\n+        let unwind_target = match unwind {\n+            mir::UnwindAction::Cleanup(cleanup) => Some(self.llbb_with_cleanup(fx, cleanup)),\n+            mir::UnwindAction::Terminate => Some(fx.terminate_block()),\n+            mir::UnwindAction::Continue => None,\n+            mir::UnwindAction::Unreachable => None,\n+        };\n+\n+        if let Some(cleanup) = unwind_target {\n             let ret_llbb = if let Some(target) = destination {\n                 fx.llbb(target)\n             } else {\n@@ -261,7 +268,7 @@ impl<'a, 'tcx> TerminatorCodegenHelper<'tcx> {\n                 options,\n                 line_spans,\n                 instance,\n-                Some((ret_llbb, self.llbb_with_cleanup(fx, cleanup), self.funclet(fx))),\n+                Some((ret_llbb, cleanup, self.funclet(fx))),\n             );\n             MergingSucc::False\n         } else {\n@@ -431,7 +438,7 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n         bx: &mut Bx,\n         location: mir::Place<'tcx>,\n         target: mir::BasicBlock,\n-        unwind: Option<mir::BasicBlock>,\n+        unwind: mir::UnwindAction,\n         mergeable_succ: bool,\n     ) -> MergingSucc {\n         let ty = location.ty(self.mir, bx.tcx()).ty;\n@@ -552,7 +559,7 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n         expected: bool,\n         msg: &mir::AssertMessage<'tcx>,\n         target: mir::BasicBlock,\n-        cleanup: Option<mir::BasicBlock>,\n+        unwind: mir::UnwindAction,\n         mergeable_succ: bool,\n     ) -> MergingSucc {\n         let span = terminator.source_info.span;\n@@ -618,12 +625,12 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n         let (fn_abi, llfn) = common::build_langcall(bx, Some(span), lang_item);\n \n         // Codegen the actual panic invoke/call.\n-        let merging_succ = helper.do_call(self, bx, fn_abi, llfn, &args, None, cleanup, &[], false);\n+        let merging_succ = helper.do_call(self, bx, fn_abi, llfn, &args, None, unwind, &[], false);\n         assert_eq!(merging_succ, MergingSucc::False);\n         MergingSucc::False\n     }\n \n-    fn codegen_abort_terminator(\n+    fn codegen_terminate_terminator(\n         &mut self,\n         helper: TerminatorCodegenHelper<'tcx>,\n         bx: &mut Bx,\n@@ -636,7 +643,17 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n         let (fn_abi, llfn) = common::build_langcall(bx, Some(span), LangItem::PanicCannotUnwind);\n \n         // Codegen the actual panic invoke/call.\n-        let merging_succ = helper.do_call(self, bx, fn_abi, llfn, &[], None, None, &[], false);\n+        let merging_succ = helper.do_call(\n+            self,\n+            bx,\n+            fn_abi,\n+            llfn,\n+            &[],\n+            None,\n+            mir::UnwindAction::Unreachable,\n+            &[],\n+            false,\n+        );\n         assert_eq!(merging_succ, MergingSucc::False);\n     }\n \n@@ -649,7 +666,7 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n         instance: Option<Instance<'tcx>>,\n         source_info: mir::SourceInfo,\n         target: Option<mir::BasicBlock>,\n-        cleanup: Option<mir::BasicBlock>,\n+        unwind: mir::UnwindAction,\n         mergeable_succ: bool,\n     ) -> Option<MergingSucc> {\n         // Emit a panic or a no-op for `assert_*` intrinsics.\n@@ -696,7 +713,7 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n                     llfn,\n                     &[msg.0, msg.1],\n                     target.as_ref().map(|bb| (ReturnDest::Nothing, *bb)),\n-                    cleanup,\n+                    unwind,\n                     &[],\n                     mergeable_succ,\n                 )\n@@ -719,7 +736,7 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n         args: &[mir::Operand<'tcx>],\n         destination: mir::Place<'tcx>,\n         target: Option<mir::BasicBlock>,\n-        cleanup: Option<mir::BasicBlock>,\n+        unwind: mir::UnwindAction,\n         fn_span: Span,\n         mergeable_succ: bool,\n     ) -> MergingSucc {\n@@ -783,7 +800,7 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n             instance,\n             source_info,\n             target,\n-            cleanup,\n+            unwind,\n             mergeable_succ,\n         ) {\n             return merging_succ;\n@@ -1064,7 +1081,7 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n                 fn_ptr,\n                 &llargs,\n                 target.as_ref().map(|&target| (ret_dest, target)),\n-                cleanup,\n+                unwind,\n                 &copied_constant_arguments,\n                 false,\n             );\n@@ -1084,7 +1101,7 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n             fn_ptr,\n             &llargs,\n             target.as_ref().map(|&target| (ret_dest, target)),\n-            cleanup,\n+            unwind,\n             &copied_constant_arguments,\n             mergeable_succ,\n         )\n@@ -1100,7 +1117,7 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n         options: ast::InlineAsmOptions,\n         line_spans: &[Span],\n         destination: Option<mir::BasicBlock>,\n-        cleanup: Option<mir::BasicBlock>,\n+        unwind: mir::UnwindAction,\n         instance: Instance<'_>,\n         mergeable_succ: bool,\n     ) -> MergingSucc {\n@@ -1164,7 +1181,7 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n             options,\n             line_spans,\n             destination,\n-            cleanup,\n+            unwind,\n             instance,\n             mergeable_succ,\n         )\n@@ -1246,8 +1263,8 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n                 MergingSucc::False\n             }\n \n-            mir::TerminatorKind::Abort => {\n-                self.codegen_abort_terminator(helper, bx, terminator);\n+            mir::TerminatorKind::Terminate => {\n+                self.codegen_terminate_terminator(helper, bx, terminator);\n                 MergingSucc::False\n             }\n \n@@ -1274,7 +1291,7 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n                 self.codegen_drop_terminator(helper, bx, place, target, unwind, mergeable_succ())\n             }\n \n-            mir::TerminatorKind::Assert { ref cond, expected, ref msg, target, cleanup } => self\n+            mir::TerminatorKind::Assert { ref cond, expected, ref msg, target, unwind } => self\n                 .codegen_assert_terminator(\n                     helper,\n                     bx,\n@@ -1283,7 +1300,7 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n                     expected,\n                     msg,\n                     target,\n-                    cleanup,\n+                    unwind,\n                     mergeable_succ(),\n                 ),\n \n@@ -1292,7 +1309,7 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n                 ref args,\n                 destination,\n                 target,\n-                cleanup,\n+                unwind,\n                 from_hir_call: _,\n                 fn_span,\n             } => self.codegen_call_terminator(\n@@ -1303,7 +1320,7 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n                 args,\n                 destination,\n                 target,\n-                cleanup,\n+                unwind,\n                 fn_span,\n                 mergeable_succ(),\n             ),\n@@ -1320,7 +1337,7 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n                 options,\n                 line_spans,\n                 destination,\n-                cleanup,\n+                unwind,\n             } => self.codegen_asm_terminator(\n                 helper,\n                 bx,\n@@ -1330,7 +1347,7 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n                 options,\n                 line_spans,\n                 destination,\n-                cleanup,\n+                unwind,\n                 self.instance,\n                 mergeable_succ(),\n             ),\n@@ -1536,62 +1553,12 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n     fn landing_pad_for_uncached(&mut self, bb: mir::BasicBlock) -> Bx::BasicBlock {\n         let llbb = self.llbb(bb);\n         if base::wants_msvc_seh(self.cx.sess()) {\n-            let funclet;\n-            let ret_llbb;\n-            match self.mir[bb].terminator.as_ref().map(|t| &t.kind) {\n-                // This is a basic block that we're aborting the program for,\n-                // notably in an `extern` function. These basic blocks are inserted\n-                // so that we assert that `extern` functions do indeed not panic,\n-                // and if they do we abort the process.\n-                //\n-                // On MSVC these are tricky though (where we're doing funclets). If\n-                // we were to do a cleanuppad (like below) the normal functions like\n-                // `longjmp` would trigger the abort logic, terminating the\n-                // program. Instead we insert the equivalent of `catch(...)` for C++\n-                // which magically doesn't trigger when `longjmp` files over this\n-                // frame.\n-                //\n-                // Lots more discussion can be found on #48251 but this codegen is\n-                // modeled after clang's for:\n-                //\n-                //      try {\n-                //          foo();\n-                //      } catch (...) {\n-                //          bar();\n-                //      }\n-                Some(&mir::TerminatorKind::Abort) => {\n-                    let cs_llbb =\n-                        Bx::append_block(self.cx, self.llfn, &format!(\"cs_funclet{:?}\", bb));\n-                    let cp_llbb =\n-                        Bx::append_block(self.cx, self.llfn, &format!(\"cp_funclet{:?}\", bb));\n-                    ret_llbb = cs_llbb;\n-\n-                    let mut cs_bx = Bx::build(self.cx, cs_llbb);\n-                    let cs = cs_bx.catch_switch(None, None, &[cp_llbb]);\n-\n-                    // The \"null\" here is actually a RTTI type descriptor for the\n-                    // C++ personality function, but `catch (...)` has no type so\n-                    // it's null. The 64 here is actually a bitfield which\n-                    // represents that this is a catch-all block.\n-                    let mut cp_bx = Bx::build(self.cx, cp_llbb);\n-                    let null = cp_bx.const_null(\n-                        cp_bx.type_i8p_ext(cp_bx.cx().data_layout().instruction_address_space),\n-                    );\n-                    let sixty_four = cp_bx.const_i32(64);\n-                    funclet = cp_bx.catch_pad(cs, &[null, sixty_four, null]);\n-                    cp_bx.br(llbb);\n-                }\n-                _ => {\n-                    let cleanup_llbb =\n-                        Bx::append_block(self.cx, self.llfn, &format!(\"funclet_{:?}\", bb));\n-                    ret_llbb = cleanup_llbb;\n-                    let mut cleanup_bx = Bx::build(self.cx, cleanup_llbb);\n-                    funclet = cleanup_bx.cleanup_pad(None, &[]);\n-                    cleanup_bx.br(llbb);\n-                }\n-            }\n+            let cleanup_bb = Bx::append_block(self.cx, self.llfn, &format!(\"funclet_{:?}\", bb));\n+            let mut cleanup_bx = Bx::build(self.cx, cleanup_bb);\n+            let funclet = cleanup_bx.cleanup_pad(None, &[]);\n+            cleanup_bx.br(llbb);\n             self.funclets[bb] = Some(funclet);\n-            ret_llbb\n+            cleanup_bb\n         } else {\n             let cleanup_llbb = Bx::append_block(self.cx, self.llfn, \"cleanup\");\n             let mut cleanup_bx = Bx::build(self.cx, cleanup_llbb);\n@@ -1618,26 +1585,68 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n         })\n     }\n \n-    fn double_unwind_guard(&mut self) -> Bx::BasicBlock {\n-        self.double_unwind_guard.unwrap_or_else(|| {\n-            assert!(!base::wants_msvc_seh(self.cx.sess()));\n+    fn terminate_block(&mut self) -> Bx::BasicBlock {\n+        self.terminate_block.unwrap_or_else(|| {\n+            let funclet;\n+            let llbb;\n+            let mut bx;\n+            if base::wants_msvc_seh(self.cx.sess()) {\n+                // This is a basic block that we're aborting the program for,\n+                // notably in an `extern` function. These basic blocks are inserted\n+                // so that we assert that `extern` functions do indeed not panic,\n+                // and if they do we abort the process.\n+                //\n+                // On MSVC these are tricky though (where we're doing funclets). If\n+                // we were to do a cleanuppad (like below) the normal functions like\n+                // `longjmp` would trigger the abort logic, terminating the\n+                // program. Instead we insert the equivalent of `catch(...)` for C++\n+                // which magically doesn't trigger when `longjmp` files over this\n+                // frame.\n+                //\n+                // Lots more discussion can be found on #48251 but this codegen is\n+                // modeled after clang's for:\n+                //\n+                //      try {\n+                //          foo();\n+                //      } catch (...) {\n+                //          bar();\n+                //      }\n+                llbb = Bx::append_block(self.cx, self.llfn, \"cs_terminate\");\n+                let cp_llbb = Bx::append_block(self.cx, self.llfn, \"cp_terminate\");\n+\n+                let mut cs_bx = Bx::build(self.cx, llbb);\n+                let cs = cs_bx.catch_switch(None, None, &[cp_llbb]);\n+\n+                // The \"null\" here is actually a RTTI type descriptor for the\n+                // C++ personality function, but `catch (...)` has no type so\n+                // it's null. The 64 here is actually a bitfield which\n+                // represents that this is a catch-all block.\n+                bx = Bx::build(self.cx, cp_llbb);\n+                let null =\n+                    bx.const_null(bx.type_i8p_ext(bx.cx().data_layout().instruction_address_space));\n+                let sixty_four = bx.const_i32(64);\n+                funclet = Some(bx.catch_pad(cs, &[null, sixty_four, null]));\n+            } else {\n+                llbb = Bx::append_block(self.cx, self.llfn, \"terminate\");\n+                bx = Bx::build(self.cx, llbb);\n+\n+                let llpersonality = self.cx.eh_personality();\n+                bx.cleanup_landing_pad(llpersonality);\n \n-            let llbb = Bx::append_block(self.cx, self.llfn, \"abort\");\n-            let mut bx = Bx::build(self.cx, llbb);\n-            self.set_debug_loc(&mut bx, mir::SourceInfo::outermost(self.mir.span));\n+                funclet = None;\n+            }\n \n-            let llpersonality = self.cx.eh_personality();\n-            bx.cleanup_landing_pad(llpersonality);\n+            self.set_debug_loc(&mut bx, mir::SourceInfo::outermost(self.mir.span));\n \n             let (fn_abi, fn_ptr) = common::build_langcall(&bx, None, LangItem::PanicCannotUnwind);\n             let fn_ty = bx.fn_decl_backend_type(&fn_abi);\n \n-            let llret = bx.call(fn_ty, Some(&fn_abi), fn_ptr, &[], None);\n+            let llret = bx.call(fn_ty, Some(&fn_abi), fn_ptr, &[], funclet.as_ref());\n             bx.do_not_inline(llret);\n \n             bx.unreachable();\n \n-            self.double_unwind_guard = Some(llbb);\n+            self.terminate_block = Some(llbb);\n             llbb\n         })\n     }"}, {"sha": "280f0207116f3208c9ddf8ac32288de46fdc8730", "filename": "compiler/rustc_codegen_ssa/src/mir/debuginfo.rs", "status": "modified", "additions": 9, "deletions": 5, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/6efdf4d1309f8047bc439a4810888c715e2df480/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fdebuginfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6efdf4d1309f8047bc439a4810888c715e2df480/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fdebuginfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fdebuginfo.rs?ref=6efdf4d1309f8047bc439a4810888c715e2df480", "patch": "@@ -165,11 +165,15 @@ fn calculate_debuginfo_offset<\n             mir::ProjectionElem::Downcast(_, variant) => {\n                 place = place.downcast(bx, variant);\n             }\n-            _ => span_bug!(\n-                var.source_info.span,\n-                \"unsupported var debuginfo place `{:?}`\",\n-                mir::Place { local, projection: var.projection },\n-            ),\n+            _ => {\n+                // Sanity check for `can_use_in_debuginfo`.\n+                debug_assert!(!elem.can_use_in_debuginfo());\n+                span_bug!(\n+                    var.source_info.span,\n+                    \"unsupported var debuginfo place `{:?}`\",\n+                    mir::Place { local, projection: var.projection },\n+                )\n+            }\n         }\n     }\n "}, {"sha": "3dadb33c96917b3e65f89d0bc531151bce0c0486", "filename": "compiler/rustc_codegen_ssa/src/mir/mod.rs", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/6efdf4d1309f8047bc439a4810888c715e2df480/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6efdf4d1309f8047bc439a4810888c715e2df480/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fmod.rs?ref=6efdf4d1309f8047bc439a4810888c715e2df480", "patch": "@@ -73,8 +73,8 @@ pub struct FunctionCx<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> {\n     /// Cached unreachable block\n     unreachable_block: Option<Bx::BasicBlock>,\n \n-    /// Cached double unwind guarding block\n-    double_unwind_guard: Option<Bx::BasicBlock>,\n+    /// Cached terminate upon unwinding block\n+    terminate_block: Option<Bx::BasicBlock>,\n \n     /// The location where each MIR arg/var/tmp/ret is stored. This is\n     /// usually an `PlaceRef` representing an alloca, but not always:\n@@ -166,7 +166,9 @@ pub fn codegen_mir<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>>(\n     let start_llbb = Bx::append_block(cx, llfn, \"start\");\n     let mut start_bx = Bx::build(cx, start_llbb);\n \n-    if mir.basic_blocks.iter().any(|bb| bb.is_cleanup) {\n+    if mir.basic_blocks.iter().any(|bb| {\n+        bb.is_cleanup || matches!(bb.terminator().unwind(), Some(mir::UnwindAction::Terminate))\n+    }) {\n         start_bx.set_personality_fn(cx.eh_personality());\n     }\n \n@@ -189,7 +191,7 @@ pub fn codegen_mir<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>>(\n         personality_slot: None,\n         cached_llbbs,\n         unreachable_block: None,\n-        double_unwind_guard: None,\n+        terminate_block: None,\n         cleanup_kinds,\n         landing_pads: IndexVec::from_elem(None, &mir.basic_blocks),\n         funclets: IndexVec::from_fn_n(|_| None, mir.basic_blocks.len()),"}, {"sha": "b37797fef4ce3d10a6406247e9be3be250174805", "filename": "compiler/rustc_codegen_ssa/src/mir/operand.rs", "status": "modified", "additions": 42, "deletions": 1, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/6efdf4d1309f8047bc439a4810888c715e2df480/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Foperand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6efdf4d1309f8047bc439a4810888c715e2df480/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Foperand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Foperand.rs?ref=6efdf4d1309f8047bc439a4810888c715e2df480", "patch": "@@ -23,10 +23,26 @@ pub enum OperandValue<V> {\n     /// to be valid for the operand's lifetime.\n     /// The second value, if any, is the extra data (vtable or length)\n     /// which indicates that it refers to an unsized rvalue.\n+    ///\n+    /// An `OperandValue` has this variant for types which are neither\n+    /// `Immediate` nor `Pair`s. The backend value in this variant must be a\n+    /// pointer to the *non*-immediate backend type. That pointee type is the\n+    /// one returned by [`LayoutTypeMethods::backend_type`].\n     Ref(V, Option<V>, Align),\n-    /// A single LLVM value.\n+    /// A single LLVM immediate value.\n+    ///\n+    /// An `OperandValue` *must* be this variant for any type for which\n+    /// [`LayoutTypeMethods::is_backend_immediate`] returns `true`.\n+    /// The backend value in this variant must be the *immediate* backend type,\n+    /// as returned by [`LayoutTypeMethods::immediate_backend_type`].\n     Immediate(V),\n     /// A pair of immediate LLVM values. Used by fat pointers too.\n+    ///\n+    /// An `OperandValue` *must* be this variant for any type for which\n+    /// [`LayoutTypeMethods::is_backend_scalar_pair`] returns `true`.\n+    /// The backend values in this variant must be the *immediate* backend types,\n+    /// as returned by [`LayoutTypeMethods::scalar_pair_element_backend_type`]\n+    /// with `immediate: true`.\n     Pair(V, V),\n }\n \n@@ -243,6 +259,31 @@ impl<'a, 'tcx, V: CodegenObject> OperandRef<'tcx, V> {\n }\n \n impl<'a, 'tcx, V: CodegenObject> OperandValue<V> {\n+    /// Returns an `OperandValue` that's generally UB to use in any way.\n+    ///\n+    /// Depending on the `layout`, returns an `Immediate` or `Pair` containing\n+    /// poison value(s), or a `Ref` containing a poison pointer.\n+    ///\n+    /// Supports sized types only.\n+    pub fn poison<Bx: BuilderMethods<'a, 'tcx, Value = V>>(\n+        bx: &mut Bx,\n+        layout: TyAndLayout<'tcx>,\n+    ) -> OperandValue<V> {\n+        assert!(layout.is_sized());\n+        if bx.cx().is_backend_immediate(layout) {\n+            let ibty = bx.cx().immediate_backend_type(layout);\n+            OperandValue::Immediate(bx.const_poison(ibty))\n+        } else if bx.cx().is_backend_scalar_pair(layout) {\n+            let ibty0 = bx.cx().scalar_pair_element_backend_type(layout, 0, true);\n+            let ibty1 = bx.cx().scalar_pair_element_backend_type(layout, 1, true);\n+            OperandValue::Pair(bx.const_poison(ibty0), bx.const_poison(ibty1))\n+        } else {\n+            let bty = bx.cx().backend_type(layout);\n+            let ptr_bty = bx.cx().type_ptr_to(bty);\n+            OperandValue::Ref(bx.const_poison(ptr_bty), None, layout.align.abi)\n+        }\n+    }\n+\n     pub fn store<Bx: BuilderMethods<'a, 'tcx, Value = V>>(\n         self,\n         bx: &mut Bx,"}, {"sha": "d88226f5db05335ee404e996c8fc5c6969b81333", "filename": "compiler/rustc_codegen_ssa/src/mir/rvalue.rs", "status": "modified", "additions": 203, "deletions": 28, "changes": 231, "blob_url": "https://github.com/rust-lang/rust/blob/6efdf4d1309f8047bc439a4810888c715e2df480/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Frvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6efdf4d1309f8047bc439a4810888c715e2df480/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Frvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Frvalue.rs?ref=6efdf4d1309f8047bc439a4810888c715e2df480", "patch": "@@ -10,7 +10,7 @@ use crate::MemFlags;\n use rustc_middle::mir;\n use rustc_middle::mir::Operand;\n use rustc_middle::ty::cast::{CastTy, IntTy};\n-use rustc_middle::ty::layout::{HasTyCtxt, LayoutOf};\n+use rustc_middle::ty::layout::{HasTyCtxt, LayoutOf, TyAndLayout};\n use rustc_middle::ty::{self, adjustment::PointerCast, Instance, Ty, TyCtxt};\n use rustc_span::source_map::{Span, DUMMY_SP};\n use rustc_target::abi::{self, FIRST_VARIANT};\n@@ -158,33 +158,20 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n         debug_assert!(src.layout.is_sized());\n         debug_assert!(dst.layout.is_sized());\n \n-        if src.layout.size != dst.layout.size\n-            || src.layout.abi == abi::Abi::Uninhabited\n-            || dst.layout.abi == abi::Abi::Uninhabited\n-        {\n-            // In all of these cases it's UB to run this transmute, but that's\n-            // known statically so might as well trap for it, rather than just\n-            // making it unreachable.\n-            bx.abort();\n-            return;\n-        }\n-\n-        let size_in_bytes = src.layout.size.bytes();\n-        if size_in_bytes == 0 {\n-            // Nothing to write\n+        if let Some(val) = self.codegen_transmute_operand(bx, src, dst.layout) {\n+            val.store(bx, dst);\n             return;\n         }\n \n         match src.val {\n-            OperandValue::Ref(src_llval, meta, src_align) => {\n-                debug_assert_eq!(meta, None);\n-                // For a place-to-place transmute, call `memcpy` directly so that\n-                // both arguments get the best-available alignment information.\n-                let bytes = bx.cx().const_usize(size_in_bytes);\n-                let flags = MemFlags::empty();\n-                bx.memcpy(dst.llval, dst.align, src_llval, src_align, bytes, flags);\n+            OperandValue::Ref(..) => {\n+                span_bug!(\n+                    self.mir.span,\n+                    \"Operand path should have handled transmute \\\n+                    from `Ref` {src:?} to place {dst:?}\"\n+                );\n             }\n-            OperandValue::Immediate(_) | OperandValue::Pair(_, _) => {\n+            OperandValue::Immediate(..) | OperandValue::Pair(..) => {\n                 // When we have immediate(s), the alignment of the source is irrelevant,\n                 // so we can store them using the destination's alignment.\n                 let llty = bx.backend_type(src.layout);\n@@ -194,6 +181,123 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n         }\n     }\n \n+    /// Attempts to transmute an `OperandValue` to another `OperandValue`.\n+    ///\n+    /// Returns `None` for cases that can't work in that framework, such as for\n+    /// `Immediate`->`Ref` that needs an `alloc` to get the location.\n+    fn codegen_transmute_operand(\n+        &mut self,\n+        bx: &mut Bx,\n+        operand: OperandRef<'tcx, Bx::Value>,\n+        cast: TyAndLayout<'tcx>,\n+    ) -> Option<OperandValue<Bx::Value>> {\n+        // Check for transmutes that are always UB.\n+        if operand.layout.size != cast.size\n+            || operand.layout.abi.is_uninhabited()\n+            || cast.abi.is_uninhabited()\n+        {\n+            if !operand.layout.abi.is_uninhabited() {\n+                // Since this is known statically and the input could have existed\n+                // without already having hit UB, might as well trap for it.\n+                bx.abort();\n+            }\n+\n+            // Because this transmute is UB, return something easy to generate,\n+            // since it's fine that later uses of the value are probably UB.\n+            return Some(OperandValue::poison(bx, cast));\n+        }\n+\n+        let operand_kind = self.value_kind(operand.layout);\n+        let cast_kind = self.value_kind(cast);\n+\n+        match operand.val {\n+            OperandValue::Ref(ptr, meta, align) => {\n+                debug_assert_eq!(meta, None);\n+                debug_assert!(matches!(operand_kind, OperandValueKind::Ref));\n+                let cast_bty = bx.backend_type(cast);\n+                let cast_ptr = bx.pointercast(ptr, bx.type_ptr_to(cast_bty));\n+                let fake_place = PlaceRef::new_sized_aligned(cast_ptr, cast, align);\n+                Some(bx.load_operand(fake_place).val)\n+            }\n+            OperandValue::Immediate(imm) => {\n+                let OperandValueKind::Immediate(in_scalar) = operand_kind else {\n+                    bug!(\"Found {operand_kind:?} for operand {operand:?}\");\n+                };\n+                if let OperandValueKind::Immediate(out_scalar) = cast_kind {\n+                    match (in_scalar, out_scalar) {\n+                        (ScalarOrZst::Zst, ScalarOrZst::Zst) => {\n+                            Some(OperandRef::new_zst(bx, cast).val)\n+                        }\n+                        (ScalarOrZst::Scalar(in_scalar), ScalarOrZst::Scalar(out_scalar))\n+                            if in_scalar.size(self.cx) == out_scalar.size(self.cx) =>\n+                        {\n+                            let cast_bty = bx.backend_type(cast);\n+                            Some(OperandValue::Immediate(\n+                                self.transmute_immediate(bx, imm, in_scalar, out_scalar, cast_bty),\n+                            ))\n+                        }\n+                        _ => None,\n+                    }\n+                } else {\n+                    None\n+                }\n+            }\n+            OperandValue::Pair(imm_a, imm_b) => {\n+                let OperandValueKind::Pair(in_a, in_b) = operand_kind else {\n+                    bug!(\"Found {operand_kind:?} for operand {operand:?}\");\n+                };\n+                if let OperandValueKind::Pair(out_a, out_b) = cast_kind\n+                    && in_a.size(self.cx) == out_a.size(self.cx)\n+                    && in_b.size(self.cx) == out_b.size(self.cx)\n+                {\n+                    let out_a_ibty = bx.scalar_pair_element_backend_type(cast, 0, false);\n+                    let out_b_ibty = bx.scalar_pair_element_backend_type(cast, 1, false);\n+                    Some(OperandValue::Pair(\n+                        self.transmute_immediate(bx, imm_a, in_a, out_a, out_a_ibty),\n+                        self.transmute_immediate(bx, imm_b, in_b, out_b, out_b_ibty),\n+                    ))\n+                } else {\n+                    None\n+                }\n+            }\n+        }\n+    }\n+\n+    /// Transmutes one of the immediates from an [`OperandValue::Immediate`]\n+    /// or an [`OperandValue::Pair`] to an immediate of the target type.\n+    ///\n+    /// `to_backend_ty` must be the *non*-immediate backend type (so it will be\n+    /// `i8`, not `i1`, for `bool`-like types.)\n+    fn transmute_immediate(\n+        &self,\n+        bx: &mut Bx,\n+        mut imm: Bx::Value,\n+        from_scalar: abi::Scalar,\n+        to_scalar: abi::Scalar,\n+        to_backend_ty: Bx::Type,\n+    ) -> Bx::Value {\n+        debug_assert_eq!(from_scalar.size(self.cx), to_scalar.size(self.cx));\n+\n+        use abi::Primitive::*;\n+        imm = bx.from_immediate(imm);\n+        imm = match (from_scalar.primitive(), to_scalar.primitive()) {\n+            (Int(..) | F32 | F64, Int(..) | F32 | F64) => bx.bitcast(imm, to_backend_ty),\n+            (Pointer(..), Pointer(..)) => bx.pointercast(imm, to_backend_ty),\n+            (Int(..), Pointer(..)) => bx.inttoptr(imm, to_backend_ty),\n+            (Pointer(..), Int(..)) => bx.ptrtoint(imm, to_backend_ty),\n+            (F32 | F64, Pointer(..)) => {\n+                let int_imm = bx.bitcast(imm, bx.cx().type_isize());\n+                bx.inttoptr(int_imm, to_backend_ty)\n+            }\n+            (Pointer(..), F32 | F64) => {\n+                let int_imm = bx.ptrtoint(imm, bx.cx().type_isize());\n+                bx.bitcast(int_imm, to_backend_ty)\n+            }\n+        };\n+        imm = bx.to_immediate_scalar(imm, to_scalar);\n+        imm\n+    }\n+\n     pub fn codegen_rvalue_unsized(\n         &mut self,\n         bx: &mut Bx,\n@@ -396,7 +500,9 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n                         OperandValue::Immediate(newval)\n                     }\n                     mir::CastKind::Transmute => {\n-                        bug!(\"Transmute operand {:?} in `codegen_rvalue_operand`\", operand);\n+                        self.codegen_transmute_operand(bx, operand, cast).unwrap_or_else(|| {\n+                            bug!(\"Unsupported transmute-as-operand of {operand:?} to {cast:?}\");\n+                        })\n                     }\n                 };\n                 OperandRef { val, layout: cast }\n@@ -739,10 +845,31 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n     pub fn rvalue_creates_operand(&self, rvalue: &mir::Rvalue<'tcx>, span: Span) -> bool {\n         match *rvalue {\n-            mir::Rvalue::Cast(mir::CastKind::Transmute, ..) =>\n-                // FIXME: Now that transmute is an Rvalue, it would be nice if\n-                // it could create `Immediate`s for scalars, where possible.\n-                false,\n+            mir::Rvalue::Cast(mir::CastKind::Transmute, ref operand, cast_ty) => {\n+                let operand_ty = operand.ty(self.mir, self.cx.tcx());\n+                let cast_layout = self.cx.layout_of(self.monomorphize(cast_ty));\n+                let operand_layout = self.cx.layout_of(self.monomorphize(operand_ty));\n+\n+                match (self.value_kind(operand_layout), self.value_kind(cast_layout)) {\n+                    // Can always load from a pointer as needed\n+                    (OperandValueKind::Ref, _) => true,\n+\n+                    // Need to generate an `alloc` to get a pointer from an immediate\n+                    (OperandValueKind::Immediate(..) | OperandValueKind::Pair(..), OperandValueKind::Ref) => false,\n+\n+                    // When we have scalar immediates, we can only convert things\n+                    // where the sizes match, to avoid endianness questions.\n+                    (OperandValueKind::Immediate(a), OperandValueKind::Immediate(b)) =>\n+                        a.size(self.cx) == b.size(self.cx),\n+                    (OperandValueKind::Pair(a0, a1), OperandValueKind::Pair(b0, b1)) =>\n+                        a0.size(self.cx) == b0.size(self.cx) && a1.size(self.cx) == b1.size(self.cx),\n+\n+                    // Send mixings between scalars and pairs through the memory route\n+                    // FIXME: Maybe this could use insertvalue/extractvalue instead?\n+                    (OperandValueKind::Immediate(..), OperandValueKind::Pair(..)) |\n+                    (OperandValueKind::Pair(..), OperandValueKind::Immediate(..)) => false,\n+                }\n+            }\n             mir::Rvalue::Ref(..) |\n             mir::Rvalue::CopyForDeref(..) |\n             mir::Rvalue::AddressOf(..) |\n@@ -767,4 +894,52 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n \n         // (*) this is only true if the type is suitable\n     }\n+\n+    /// Gets which variant of [`OperandValue`] is expected for a particular type.\n+    fn value_kind(&self, layout: TyAndLayout<'tcx>) -> OperandValueKind {\n+        if self.cx.is_backend_immediate(layout) {\n+            debug_assert!(!self.cx.is_backend_scalar_pair(layout));\n+            OperandValueKind::Immediate(match layout.abi {\n+                abi::Abi::Scalar(s) => ScalarOrZst::Scalar(s),\n+                abi::Abi::Vector { element, .. } => ScalarOrZst::Scalar(element),\n+                _ if layout.is_zst() => ScalarOrZst::Zst,\n+                x => span_bug!(self.mir.span, \"Couldn't translate {x:?} as backend immediate\"),\n+            })\n+        } else if self.cx.is_backend_scalar_pair(layout) {\n+            let abi::Abi::ScalarPair(s1, s2) = layout.abi else {\n+                span_bug!(\n+                    self.mir.span,\n+                    \"Couldn't translate {:?} as backend scalar pair\",\n+                    layout.abi,\n+                );\n+            };\n+            OperandValueKind::Pair(s1, s2)\n+        } else {\n+            OperandValueKind::Ref\n+        }\n+    }\n+}\n+\n+/// The variants of this match [`OperandValue`], giving details about the\n+/// backend values that will be held in that other type.\n+#[derive(Debug, Copy, Clone)]\n+enum OperandValueKind {\n+    Ref,\n+    Immediate(ScalarOrZst),\n+    Pair(abi::Scalar, abi::Scalar),\n+}\n+\n+#[derive(Debug, Copy, Clone)]\n+enum ScalarOrZst {\n+    Zst,\n+    Scalar(abi::Scalar),\n+}\n+\n+impl ScalarOrZst {\n+    pub fn size(self, cx: &impl abi::HasDataLayout) -> abi::Size {\n+        match self {\n+            ScalarOrZst::Zst => abi::Size::ZERO,\n+            ScalarOrZst::Scalar(s) => s.size(cx),\n+        }\n+    }\n }"}, {"sha": "32905b079d365a72a4a97a7018949084fb6ec124", "filename": "compiler/rustc_codegen_ssa/src/traits/type_.rs", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/6efdf4d1309f8047bc439a4810888c715e2df480/compiler%2Frustc_codegen_ssa%2Fsrc%2Ftraits%2Ftype_.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6efdf4d1309f8047bc439a4810888c715e2df480/compiler%2Frustc_codegen_ssa%2Fsrc%2Ftraits%2Ftype_.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Ftraits%2Ftype_.rs?ref=6efdf4d1309f8047bc439a4810888c715e2df480", "patch": "@@ -100,11 +100,22 @@ pub trait DerivedTypeMethods<'tcx>: BaseTypeMethods<'tcx> + MiscMethods<'tcx> {\n impl<'tcx, T> DerivedTypeMethods<'tcx> for T where Self: BaseTypeMethods<'tcx> + MiscMethods<'tcx> {}\n \n pub trait LayoutTypeMethods<'tcx>: Backend<'tcx> {\n+    /// The backend type used for a rust type when it's in memory,\n+    /// such as when it's stack-allocated or when it's being loaded or stored.\n     fn backend_type(&self, layout: TyAndLayout<'tcx>) -> Self::Type;\n     fn cast_backend_type(&self, ty: &CastTarget) -> Self::Type;\n     fn fn_decl_backend_type(&self, fn_abi: &FnAbi<'tcx, Ty<'tcx>>) -> Self::Type;\n     fn fn_ptr_backend_type(&self, fn_abi: &FnAbi<'tcx, Ty<'tcx>>) -> Self::Type;\n     fn reg_backend_type(&self, ty: &Reg) -> Self::Type;\n+    /// The backend type used for a rust type when it's in an SSA register.\n+    ///\n+    /// For nearly all types this is the same as the [`Self::backend_type`], however\n+    /// `bool` (and other `0`-or-`1` values) are kept as [`BaseTypeMethods::type_i1`]\n+    /// in registers but as [`BaseTypeMethods::type_i8`] in memory.\n+    ///\n+    /// Converting values between the two different backend types is done using\n+    /// [`from_immediate`](super::BuilderMethods::from_immediate) and\n+    /// [`to_immediate_scalar`](super::BuilderMethods::to_immediate_scalar).\n     fn immediate_backend_type(&self, layout: TyAndLayout<'tcx>) -> Self::Type;\n     fn is_backend_immediate(&self, layout: TyAndLayout<'tcx>) -> bool;\n     fn is_backend_scalar_pair(&self, layout: TyAndLayout<'tcx>) -> bool;"}, {"sha": "a5dfd1072f0aaf0e0b489d7741d637adceae7633", "filename": "compiler/rustc_const_eval/src/const_eval/machine.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/6efdf4d1309f8047bc439a4810888c715e2df480/compiler%2Frustc_const_eval%2Fsrc%2Fconst_eval%2Fmachine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6efdf4d1309f8047bc439a4810888c715e2df480/compiler%2Frustc_const_eval%2Fsrc%2Fconst_eval%2Fmachine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Fconst_eval%2Fmachine.rs?ref=6efdf4d1309f8047bc439a4810888c715e2df480", "patch": "@@ -23,7 +23,7 @@ use rustc_target::spec::abi::Abi as CallAbi;\n \n use crate::interpret::{\n     self, compile_time_machine, AllocId, ConstAllocation, FnVal, Frame, ImmTy, InterpCx,\n-    InterpResult, OpTy, PlaceTy, Pointer, Scalar, StackPopUnwind,\n+    InterpResult, OpTy, PlaceTy, Pointer, Scalar,\n };\n \n use super::error::*;\n@@ -271,7 +271,7 @@ impl<'mir, 'tcx: 'mir> CompileTimeEvalContext<'mir, 'tcx> {\n                         /* with_caller_location = */ false,\n                         dest,\n                         ret,\n-                        StackPopUnwind::NotAllowed,\n+                        mir::UnwindAction::Unreachable,\n                     )?;\n                     Ok(ControlFlow::Break(()))\n                 } else {\n@@ -401,7 +401,7 @@ impl<'mir, 'tcx> interpret::Machine<'mir, 'tcx> for CompileTimeInterpreter<'mir,\n         args: &[OpTy<'tcx>],\n         dest: &PlaceTy<'tcx>,\n         ret: Option<mir::BasicBlock>,\n-        _unwind: StackPopUnwind, // unwinding is not supported in consts\n+        _unwind: mir::UnwindAction, // unwinding is not supported in consts\n     ) -> InterpResult<'tcx, Option<(&'mir mir::Body<'tcx>, ty::Instance<'tcx>)>> {\n         debug!(\"find_mir_or_eval_fn: {:?}\", instance);\n \n@@ -450,7 +450,7 @@ impl<'mir, 'tcx> interpret::Machine<'mir, 'tcx> for CompileTimeInterpreter<'mir,\n         args: &[OpTy<'tcx>],\n         dest: &PlaceTy<'tcx, Self::Provenance>,\n         target: Option<mir::BasicBlock>,\n-        _unwind: StackPopUnwind,\n+        _unwind: mir::UnwindAction,\n     ) -> InterpResult<'tcx> {\n         // Shared intrinsics.\n         if ecx.emulate_intrinsic(instance, args, dest, target)? {\n@@ -526,7 +526,7 @@ impl<'mir, 'tcx> interpret::Machine<'mir, 'tcx> for CompileTimeInterpreter<'mir,\n     fn assert_panic(\n         ecx: &mut InterpCx<'mir, 'tcx, Self>,\n         msg: &AssertMessage<'tcx>,\n-        _unwind: Option<mir::BasicBlock>,\n+        _unwind: mir::UnwindAction,\n     ) -> InterpResult<'tcx> {\n         use rustc_middle::mir::AssertKind::*;\n         // Convert `AssertKind<Operand>` to `AssertKind<Scalar>`."}, {"sha": "3e58a58aef7d08bee8c6cbb55650f6f8afca32a1", "filename": "compiler/rustc_const_eval/src/interpret/eval_context.rs", "status": "modified", "additions": 11, "deletions": 18, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/6efdf4d1309f8047bc439a4810888c715e2df480/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Feval_context.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6efdf4d1309f8047bc439a4810888c715e2df480/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Feval_context.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Feval_context.rs?ref=6efdf4d1309f8047bc439a4810888c715e2df480", "patch": "@@ -139,25 +139,14 @@ pub struct FrameInfo<'tcx> {\n     pub lint_root: Option<hir::HirId>,\n }\n \n-/// Unwind information.\n-#[derive(Clone, Copy, Eq, PartialEq, Debug)]\n-pub enum StackPopUnwind {\n-    /// The cleanup block.\n-    Cleanup(mir::BasicBlock),\n-    /// No cleanup needs to be done.\n-    Skip,\n-    /// Unwinding is not allowed (UB).\n-    NotAllowed,\n-}\n-\n #[derive(Clone, Copy, Eq, PartialEq, Debug)] // Miri debug-prints these\n pub enum StackPopCleanup {\n     /// Jump to the next block in the caller, or cause UB if None (that's a function\n     /// that may never return). Also store layout of return place so\n     /// we can validate it at that layout.\n     /// `ret` stores the block we jump to on a normal return, while `unwind`\n     /// stores the block used for cleanup during unwinding.\n-    Goto { ret: Option<mir::BasicBlock>, unwind: StackPopUnwind },\n+    Goto { ret: Option<mir::BasicBlock>, unwind: mir::UnwindAction },\n     /// The root frame of the stack: nowhere else to jump to.\n     /// `cleanup` says whether locals are deallocated. Static computation\n     /// wants them leaked to intern what they need (and just throw away\n@@ -735,18 +724,22 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n     /// *Unwind* to the given `target` basic block.\n     /// Do *not* use for returning! Use `return_to_block` instead.\n     ///\n-    /// If `target` is `StackPopUnwind::Skip`, that indicates the function does not need cleanup\n+    /// If `target` is `UnwindAction::Continue`, that indicates the function does not need cleanup\n     /// during unwinding, and we will just keep propagating that upwards.\n     ///\n-    /// If `target` is `StackPopUnwind::NotAllowed`, that indicates the function does not allow\n+    /// If `target` is `UnwindAction::Unreachable`, that indicates the function does not allow\n     /// unwinding, and doing so is UB.\n-    pub fn unwind_to_block(&mut self, target: StackPopUnwind) -> InterpResult<'tcx> {\n+    pub fn unwind_to_block(&mut self, target: mir::UnwindAction) -> InterpResult<'tcx> {\n         self.frame_mut().loc = match target {\n-            StackPopUnwind::Cleanup(block) => Left(mir::Location { block, statement_index: 0 }),\n-            StackPopUnwind::Skip => Right(self.frame_mut().body.span),\n-            StackPopUnwind::NotAllowed => {\n+            mir::UnwindAction::Cleanup(block) => Left(mir::Location { block, statement_index: 0 }),\n+            mir::UnwindAction::Continue => Right(self.frame_mut().body.span),\n+            mir::UnwindAction::Unreachable => {\n                 throw_ub_format!(\"unwinding past a stack frame that does not allow unwinding\")\n             }\n+            mir::UnwindAction::Terminate => {\n+                self.frame_mut().loc = Right(self.frame_mut().body.span);\n+                M::abort(self, \"panic in a function that cannot unwind\".to_owned())?;\n+            }\n         };\n         Ok(())\n     }"}, {"sha": "0291cca7378a4543b3da851a6bbe2550a2f4a6be", "filename": "compiler/rustc_const_eval/src/interpret/machine.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/6efdf4d1309f8047bc439a4810888c715e2df480/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fmachine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6efdf4d1309f8047bc439a4810888c715e2df480/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fmachine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fmachine.rs?ref=6efdf4d1309f8047bc439a4810888c715e2df480", "patch": "@@ -18,7 +18,7 @@ use crate::const_eval::CheckAlignment;\n \n use super::{\n     AllocBytes, AllocId, AllocRange, Allocation, ConstAllocation, Frame, ImmTy, InterpCx,\n-    InterpResult, MemoryKind, OpTy, Operand, PlaceTy, Pointer, Provenance, Scalar, StackPopUnwind,\n+    InterpResult, MemoryKind, OpTy, Operand, PlaceTy, Pointer, Provenance, Scalar,\n };\n \n /// Data returned by Machine::stack_pop,\n@@ -185,7 +185,7 @@ pub trait Machine<'mir, 'tcx>: Sized {\n         args: &[OpTy<'tcx, Self::Provenance>],\n         destination: &PlaceTy<'tcx, Self::Provenance>,\n         target: Option<mir::BasicBlock>,\n-        unwind: StackPopUnwind,\n+        unwind: mir::UnwindAction,\n     ) -> InterpResult<'tcx, Option<(&'mir mir::Body<'tcx>, ty::Instance<'tcx>)>>;\n \n     /// Execute `fn_val`. It is the hook's responsibility to advance the instruction\n@@ -197,7 +197,7 @@ pub trait Machine<'mir, 'tcx>: Sized {\n         args: &[OpTy<'tcx, Self::Provenance>],\n         destination: &PlaceTy<'tcx, Self::Provenance>,\n         target: Option<mir::BasicBlock>,\n-        unwind: StackPopUnwind,\n+        unwind: mir::UnwindAction,\n     ) -> InterpResult<'tcx>;\n \n     /// Directly process an intrinsic without pushing a stack frame. It is the hook's\n@@ -208,17 +208,17 @@ pub trait Machine<'mir, 'tcx>: Sized {\n         args: &[OpTy<'tcx, Self::Provenance>],\n         destination: &PlaceTy<'tcx, Self::Provenance>,\n         target: Option<mir::BasicBlock>,\n-        unwind: StackPopUnwind,\n+        unwind: mir::UnwindAction,\n     ) -> InterpResult<'tcx>;\n \n     /// Called to evaluate `Assert` MIR terminators that trigger a panic.\n     fn assert_panic(\n         ecx: &mut InterpCx<'mir, 'tcx, Self>,\n         msg: &mir::AssertMessage<'tcx>,\n-        unwind: Option<mir::BasicBlock>,\n+        unwind: mir::UnwindAction,\n     ) -> InterpResult<'tcx>;\n \n-    /// Called to evaluate `Abort` MIR terminator.\n+    /// Called to abort evaluation.\n     fn abort(_ecx: &mut InterpCx<'mir, 'tcx, Self>, _msg: String) -> InterpResult<'tcx, !> {\n         throw_unsup_format!(\"aborting execution is not supported\")\n     }\n@@ -487,7 +487,7 @@ pub macro compile_time_machine(<$mir: lifetime, $tcx: lifetime>) {\n         _args: &[OpTy<$tcx>],\n         _destination: &PlaceTy<$tcx, Self::Provenance>,\n         _target: Option<mir::BasicBlock>,\n-        _unwind: StackPopUnwind,\n+        _unwind: mir::UnwindAction,\n     ) -> InterpResult<$tcx> {\n         match fn_val {}\n     }"}, {"sha": "898d62361ab2aae810f18693c90ae85fb7bebd84", "filename": "compiler/rustc_const_eval/src/interpret/mod.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6efdf4d1309f8047bc439a4810888c715e2df480/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6efdf4d1309f8047bc439a4810888c715e2df480/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fmod.rs?ref=6efdf4d1309f8047bc439a4810888c715e2df480", "patch": "@@ -20,9 +20,7 @@ mod visitor;\n \n pub use rustc_middle::mir::interpret::*; // have all the `interpret` symbols in one place: here\n \n-pub use self::eval_context::{\n-    Frame, FrameInfo, InterpCx, LocalState, LocalValue, StackPopCleanup, StackPopUnwind,\n-};\n+pub use self::eval_context::{Frame, FrameInfo, InterpCx, LocalState, LocalValue, StackPopCleanup};\n pub use self::intern::{intern_const_alloc_recursive, InternKind};\n pub use self::machine::{compile_time_machine, AllocMap, Machine, MayLeak, StackPopJump};\n pub use self::memory::{AllocKind, AllocRef, AllocRefMut, FnVal, Memory, MemoryKind};"}, {"sha": "5310ef0bb3ed0e076b82331dc33a2be2f5d484c3", "filename": "compiler/rustc_const_eval/src/interpret/operand.rs", "status": "modified", "additions": 1, "deletions": 8, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/6efdf4d1309f8047bc439a4810888c715e2df480/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Foperand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6efdf4d1309f8047bc439a4810888c715e2df480/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Foperand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Foperand.rs?ref=6efdf4d1309f8047bc439a4810888c715e2df480", "patch": "@@ -612,14 +612,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         span: Option<Span>,\n         layout: Option<TyAndLayout<'tcx>>,\n     ) -> InterpResult<'tcx, OpTy<'tcx, M::Provenance>> {\n-        // FIXME(const_prop): normalization needed b/c const prop lint in\n-        // `mir_drops_elaborated_and_const_checked`, which happens before\n-        // optimized MIR. Only after optimizing the MIR can we guarantee\n-        // that the `RevealAll` pass has happened and that the body's consts\n-        // are normalized, so any call to resolve before that needs to be\n-        // manually normalized.\n-        let val = self.tcx.normalize_erasing_regions(self.param_env, *val);\n-        match val {\n+        match *val {\n             mir::ConstantKind::Ty(ct) => {\n                 let ty = ct.ty();\n                 let valtree = self.eval_ty_constant(ct, span)?;"}, {"sha": "a07702f7d9bb3957a8ad47a20d0bb015cb25c04d", "filename": "compiler/rustc_const_eval/src/interpret/terminator.rs", "status": "modified", "additions": 14, "deletions": 20, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/6efdf4d1309f8047bc439a4810888c715e2df480/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fterminator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6efdf4d1309f8047bc439a4810888c715e2df480/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fterminator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fterminator.rs?ref=6efdf4d1309f8047bc439a4810888c715e2df480", "patch": "@@ -13,7 +13,7 @@ use rustc_target::spec::abi::Abi;\n \n use super::{\n     FnVal, ImmTy, Immediate, InterpCx, InterpResult, MPlaceTy, Machine, MemoryKind, OpTy, Operand,\n-    PlaceTy, Scalar, StackPopCleanup, StackPopUnwind,\n+    PlaceTy, Scalar, StackPopCleanup,\n };\n \n impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n@@ -60,7 +60,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                 ref args,\n                 destination,\n                 target,\n-                ref cleanup,\n+                unwind,\n                 from_hir_call: _,\n                 fn_span: _,\n             } => {\n@@ -106,11 +106,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                     with_caller_location,\n                     &destination,\n                     target,\n-                    match (cleanup, fn_abi.can_unwind) {\n-                        (Some(cleanup), true) => StackPopUnwind::Cleanup(*cleanup),\n-                        (None, true) => StackPopUnwind::Skip,\n-                        (_, false) => StackPopUnwind::NotAllowed,\n-                    },\n+                    if fn_abi.can_unwind { unwind } else { mir::UnwindAction::Unreachable },\n                 )?;\n                 // Sanity-check that `eval_fn_call` either pushed a new frame or\n                 // did a jump to another block.\n@@ -137,19 +133,20 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                 self.drop_in_place(&place, instance, target, unwind)?;\n             }\n \n-            Assert { ref cond, expected, ref msg, target, cleanup } => {\n+            Assert { ref cond, expected, ref msg, target, unwind } => {\n                 let ignored =\n                     M::ignore_optional_overflow_checks(self) && msg.is_optional_overflow_check();\n                 let cond_val = self.read_scalar(&self.eval_operand(cond, None)?)?.to_bool()?;\n                 if ignored || expected == cond_val {\n                     self.go_to_block(target);\n                 } else {\n-                    M::assert_panic(self, msg, cleanup)?;\n+                    M::assert_panic(self, msg, unwind)?;\n                 }\n             }\n \n-            Abort => {\n-                M::abort(self, \"the program aborted execution\".to_owned())?;\n+            Terminate => {\n+                // FIXME: maybe should call `panic_no_unwind` lang item instead.\n+                M::abort(self, \"panic in a function that cannot unwind\".to_owned())?;\n             }\n \n             // When we encounter Resume, we've finished unwinding\n@@ -351,7 +348,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         with_caller_location: bool,\n         destination: &PlaceTy<'tcx, M::Provenance>,\n         target: Option<mir::BasicBlock>,\n-        mut unwind: StackPopUnwind,\n+        mut unwind: mir::UnwindAction,\n     ) -> InterpResult<'tcx> {\n         trace!(\"eval_fn_call: {:#?}\", fn_val);\n \n@@ -410,9 +407,9 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                     }\n                 }\n \n-                if !matches!(unwind, StackPopUnwind::NotAllowed) && !callee_fn_abi.can_unwind {\n-                    // The callee cannot unwind.\n-                    unwind = StackPopUnwind::NotAllowed;\n+                if !callee_fn_abi.can_unwind {\n+                    // The callee cannot unwind, so force the `Unreachable` unwind handling.\n+                    unwind = mir::UnwindAction::Unreachable;\n                 }\n \n                 self.push_stack_frame(\n@@ -676,7 +673,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         place: &PlaceTy<'tcx, M::Provenance>,\n         instance: ty::Instance<'tcx>,\n         target: mir::BasicBlock,\n-        unwind: Option<mir::BasicBlock>,\n+        unwind: mir::UnwindAction,\n     ) -> InterpResult<'tcx> {\n         trace!(\"drop_in_place: {:?},\\n  {:?}, {:?}\", *place, place.layout.ty, instance);\n         // We take the address of the object. This may well be unaligned, which is fine\n@@ -717,10 +714,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n             false,\n             &ret.into(),\n             Some(target),\n-            match unwind {\n-                Some(cleanup) => StackPopUnwind::Cleanup(cleanup),\n-                None => StackPopUnwind::Skip,\n-            },\n+            unwind,\n         )\n     }\n }"}, {"sha": "5ab389d04c7eea344b84dc4b0f520c1291a3e476", "filename": "compiler/rustc_const_eval/src/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/6efdf4d1309f8047bc439a4810888c715e2df480/compiler%2Frustc_const_eval%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6efdf4d1309f8047bc439a4810888c715e2df480/compiler%2Frustc_const_eval%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Flib.rs?ref=6efdf4d1309f8047bc439a4810888c715e2df480", "patch": "@@ -20,7 +20,6 @@ Rust MIR: a lowered representation of Rust.\n #![feature(try_blocks)]\n #![feature(yeet_expr)]\n #![feature(if_let_guard)]\n-#![feature(is_some_and)]\n #![recursion_limit = \"256\"]\n \n #[macro_use]"}, {"sha": "9dad947905397e87f561ad07bdb3c45ba2817f63", "filename": "compiler/rustc_const_eval/src/transform/check_consts/check.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/6efdf4d1309f8047bc439a4810888c715e2df480/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fcheck_consts%2Fcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6efdf4d1309f8047bc439a4810888c715e2df480/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fcheck_consts%2Fcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fcheck_consts%2Fcheck.rs?ref=6efdf4d1309f8047bc439a4810888c715e2df480", "patch": "@@ -553,7 +553,7 @@ impl<'tcx> Visitor<'tcx> for Checker<'_, 'tcx> {\n             }\n \n             Rvalue::Cast(CastKind::DynStar, _, _) => {\n-                unimplemented!()\n+                // `dyn*` coercion is implemented for CTFE.\n             }\n \n             Rvalue::Cast(_, _, _) => {}\n@@ -1031,9 +1031,9 @@ impl<'tcx> Visitor<'tcx> for Checker<'_, 'tcx> {\n                 self.check_op(ops::Generator(hir::GeneratorKind::Gen))\n             }\n \n-            TerminatorKind::Abort => {\n+            TerminatorKind::Terminate => {\n                 // Cleanup blocks are skipped for const checking (see `visit_basic_block_data`).\n-                span_bug!(self.span, \"`Abort` terminator outside of cleanup block\")\n+                span_bug!(self.span, \"`Terminate` terminator outside of cleanup block\")\n             }\n \n             TerminatorKind::Assert { .. }"}, {"sha": "1f1640fd80ae61b1b12ef47302e75482e34c3734", "filename": "compiler/rustc_const_eval/src/transform/check_consts/post_drop_elaboration.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6efdf4d1309f8047bc439a4810888c715e2df480/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fcheck_consts%2Fpost_drop_elaboration.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6efdf4d1309f8047bc439a4810888c715e2df480/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fcheck_consts%2Fpost_drop_elaboration.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fcheck_consts%2Fpost_drop_elaboration.rs?ref=6efdf4d1309f8047bc439a4810888c715e2df480", "patch": "@@ -104,7 +104,7 @@ impl<'tcx> Visitor<'tcx> for CheckLiveDrops<'_, 'tcx> {\n                 }\n             }\n \n-            mir::TerminatorKind::Abort\n+            mir::TerminatorKind::Terminate\n             | mir::TerminatorKind::Call { .. }\n             | mir::TerminatorKind::Assert { .. }\n             | mir::TerminatorKind::FalseEdge { .. }"}, {"sha": "7919aed097a452dc19479bbc734b6704cafee068", "filename": "compiler/rustc_const_eval/src/transform/promote_consts.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6efdf4d1309f8047bc439a4810888c715e2df480/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fpromote_consts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6efdf4d1309f8047bc439a4810888c715e2df480/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fpromote_consts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fpromote_consts.rs?ref=6efdf4d1309f8047bc439a4810888c715e2df480", "patch": "@@ -807,7 +807,7 @@ impl<'a, 'tcx> Promoter<'a, 'tcx> {\n                         kind: TerminatorKind::Call {\n                             func,\n                             args,\n-                            cleanup: None,\n+                            unwind: UnwindAction::Continue,\n                             destination: Place::from(new_temp),\n                             target: Some(new_target),\n                             from_hir_call,"}, {"sha": "0f56fda18f56151c1a0afefdec9f1bbb0090c725", "filename": "compiler/rustc_const_eval/src/transform/validate.rs", "status": "modified", "additions": 70, "deletions": 24, "changes": 94, "blob_url": "https://github.com/rust-lang/rust/blob/6efdf4d1309f8047bc439a4810888c715e2df480/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fvalidate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6efdf4d1309f8047bc439a4810888c715e2df480/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fvalidate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fvalidate.rs?ref=6efdf4d1309f8047bc439a4810888c715e2df480", "patch": "@@ -5,13 +5,12 @@ use rustc_index::bit_set::BitSet;\n use rustc_index::vec::IndexVec;\n use rustc_infer::traits::Reveal;\n use rustc_middle::mir::interpret::Scalar;\n-use rustc_middle::mir::visit::NonUseContext::VarDebugInfo;\n-use rustc_middle::mir::visit::{PlaceContext, Visitor};\n+use rustc_middle::mir::visit::{NonUseContext, PlaceContext, Visitor};\n use rustc_middle::mir::{\n     traversal, BasicBlock, BinOp, Body, BorrowKind, CastKind, CopyNonOverlapping, Local, Location,\n     MirPass, MirPhase, NonDivergingIntrinsic, Operand, Place, PlaceElem, PlaceRef, ProjectionElem,\n     RetagKind, RuntimePhase, Rvalue, SourceScope, Statement, StatementKind, Terminator,\n-    TerminatorKind, UnOp, START_BLOCK,\n+    TerminatorKind, UnOp, UnwindAction, VarDebugInfo, VarDebugInfoContents, START_BLOCK,\n };\n use rustc_middle::ty::{self, InstanceDef, ParamEnv, Ty, TyCtxt, TypeVisitableExt};\n use rustc_mir_dataflow::impls::MaybeStorageLive;\n@@ -233,6 +232,24 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n         }\n     }\n \n+    fn check_unwind_edge(&mut self, location: Location, unwind: UnwindAction) {\n+        let is_cleanup = self.body.basic_blocks[location.block].is_cleanup;\n+        match unwind {\n+            UnwindAction::Cleanup(unwind) => {\n+                if is_cleanup {\n+                    self.fail(location, \"unwind on cleanup block\");\n+                }\n+                self.check_edge(location, unwind, EdgeKind::Unwind);\n+            }\n+            UnwindAction::Continue => {\n+                if is_cleanup {\n+                    self.fail(location, \"unwind on cleanup block\");\n+                }\n+            }\n+            UnwindAction::Unreachable | UnwindAction::Terminate => (),\n+        }\n+    }\n+\n     /// Check if src can be assigned into dest.\n     /// This is not precise, it will accept some incorrect assignments.\n     fn mir_assign_valid_types(&self, src: Ty<'tcx>, dest: Ty<'tcx>) -> bool {\n@@ -419,13 +436,49 @@ impl<'a, 'tcx> Visitor<'tcx> for TypeChecker<'a, 'tcx> {\n         self.super_projection_elem(local, proj_base, elem, context, location);\n     }\n \n+    fn visit_var_debug_info(&mut self, debuginfo: &VarDebugInfo<'tcx>) {\n+        let check_place = |place: Place<'_>| {\n+            if place.projection.iter().any(|p| !p.can_use_in_debuginfo()) {\n+                self.fail(\n+                    START_BLOCK.start_location(),\n+                    format!(\"illegal place {:?} in debuginfo for {:?}\", place, debuginfo.name),\n+                );\n+            }\n+        };\n+        match debuginfo.value {\n+            VarDebugInfoContents::Const(_) => {}\n+            VarDebugInfoContents::Place(place) => check_place(place),\n+            VarDebugInfoContents::Composite { ty, ref fragments } => {\n+                for f in fragments {\n+                    check_place(f.contents);\n+                    if ty.is_union() || ty.is_enum() {\n+                        self.fail(\n+                            START_BLOCK.start_location(),\n+                            format!(\"invalid type {:?} for composite debuginfo\", ty),\n+                        );\n+                    }\n+                    if f.projection.iter().any(|p| !matches!(p, PlaceElem::Field(..))) {\n+                        self.fail(\n+                            START_BLOCK.start_location(),\n+                            format!(\n+                                \"illegal projection {:?} in debuginfo for {:?}\",\n+                                f.projection, debuginfo.name\n+                            ),\n+                        );\n+                    }\n+                }\n+            }\n+        }\n+        self.super_var_debug_info(debuginfo);\n+    }\n+\n     fn visit_place(&mut self, place: &Place<'tcx>, cntxt: PlaceContext, location: Location) {\n         // Set off any `bug!`s in the type computation code\n         let _ = place.ty(&self.body.local_decls, self.tcx);\n \n         if self.mir_phase >= MirPhase::Runtime(RuntimePhase::Initial)\n             && place.projection.len() > 1\n-            && cntxt != PlaceContext::NonUse(VarDebugInfo)\n+            && cntxt != PlaceContext::NonUse(NonUseContext::VarDebugInfo)\n             && place.projection[1..].contains(&ProjectionElem::Deref)\n         {\n             self.fail(location, format!(\"{:?}, has deref at the wrong place\", place));\n@@ -867,11 +920,9 @@ impl<'a, 'tcx> Visitor<'tcx> for TypeChecker<'a, 'tcx> {\n             }\n             TerminatorKind::Drop { target, unwind, .. } => {\n                 self.check_edge(location, *target, EdgeKind::Normal);\n-                if let Some(unwind) = unwind {\n-                    self.check_edge(location, *unwind, EdgeKind::Unwind);\n-                }\n+                self.check_unwind_edge(location, *unwind);\n             }\n-            TerminatorKind::Call { func, args, destination, target, cleanup, .. } => {\n+            TerminatorKind::Call { func, args, destination, target, unwind, .. } => {\n                 let func_ty = func.ty(&self.body.local_decls, self.tcx);\n                 match func_ty.kind() {\n                     ty::FnPtr(..) | ty::FnDef(..) => {}\n@@ -883,9 +934,7 @@ impl<'a, 'tcx> Visitor<'tcx> for TypeChecker<'a, 'tcx> {\n                 if let Some(target) = target {\n                     self.check_edge(location, *target, EdgeKind::Normal);\n                 }\n-                if let Some(cleanup) = cleanup {\n-                    self.check_edge(location, *cleanup, EdgeKind::Unwind);\n-                }\n+                self.check_unwind_edge(location, *unwind);\n \n                 // The call destination place and Operand::Move place used as an argument might be\n                 // passed by a reference to the callee. Consequently they must be non-overlapping.\n@@ -911,7 +960,7 @@ impl<'a, 'tcx> Visitor<'tcx> for TypeChecker<'a, 'tcx> {\n                     );\n                 }\n             }\n-            TerminatorKind::Assert { cond, target, cleanup, .. } => {\n+            TerminatorKind::Assert { cond, target, unwind, .. } => {\n                 let cond_ty = cond.ty(&self.body.local_decls, self.tcx);\n                 if cond_ty != self.tcx.types.bool {\n                     self.fail(\n@@ -923,9 +972,7 @@ impl<'a, 'tcx> Visitor<'tcx> for TypeChecker<'a, 'tcx> {\n                     );\n                 }\n                 self.check_edge(location, *target, EdgeKind::Normal);\n-                if let Some(cleanup) = cleanup {\n-                    self.check_edge(location, *cleanup, EdgeKind::Unwind);\n-                }\n+                self.check_unwind_edge(location, *unwind);\n             }\n             TerminatorKind::Yield { resume, drop, .. } => {\n                 if self.body.generator.is_none() {\n@@ -957,17 +1004,13 @@ impl<'a, 'tcx> Visitor<'tcx> for TypeChecker<'a, 'tcx> {\n                     );\n                 }\n                 self.check_edge(location, *real_target, EdgeKind::Normal);\n-                if let Some(unwind) = unwind {\n-                    self.check_edge(location, *unwind, EdgeKind::Unwind);\n-                }\n+                self.check_unwind_edge(location, *unwind);\n             }\n-            TerminatorKind::InlineAsm { destination, cleanup, .. } => {\n+            TerminatorKind::InlineAsm { destination, unwind, .. } => {\n                 if let Some(destination) = destination {\n                     self.check_edge(location, *destination, EdgeKind::Normal);\n                 }\n-                if let Some(cleanup) = cleanup {\n-                    self.check_edge(location, *cleanup, EdgeKind::Unwind);\n-                }\n+                self.check_unwind_edge(location, *unwind);\n             }\n             TerminatorKind::GeneratorDrop => {\n                 if self.body.generator.is_none() {\n@@ -980,10 +1023,13 @@ impl<'a, 'tcx> Visitor<'tcx> for TypeChecker<'a, 'tcx> {\n                     );\n                 }\n             }\n-            TerminatorKind::Resume | TerminatorKind::Abort => {\n+            TerminatorKind::Resume | TerminatorKind::Terminate => {\n                 let bb = location.block;\n                 if !self.body.basic_blocks[bb].is_cleanup {\n-                    self.fail(location, \"Cannot `Resume` or `Abort` from non-cleanup basic block\")\n+                    self.fail(\n+                        location,\n+                        \"Cannot `Resume` or `Terminate` from non-cleanup basic block\",\n+                    )\n                 }\n             }\n             TerminatorKind::Return => {"}, {"sha": "24b6b5cfb1f73ec0e5b8745d32fdf344251d0b49", "filename": "compiler/rustc_data_structures/Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6efdf4d1309f8047bc439a4810888c715e2df480/compiler%2Frustc_data_structures%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/6efdf4d1309f8047bc439a4810888c715e2df480/compiler%2Frustc_data_structures%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_data_structures%2FCargo.toml?ref=6efdf4d1309f8047bc439a4810888c715e2df480", "patch": "@@ -32,7 +32,7 @@ stacker = \"0.1.15\"\n tempfile = \"3.2\"\n thin-vec = \"0.2.12\"\n tracing = \"0.1\"\n-elsa = \"1.8\"\n+elsa = \"=1.7.1\"\n \n [dependencies.parking_lot]\n version = \"0.11\""}, {"sha": "9ff401c3c7aad19d78a73c057b4001bce31d123e", "filename": "compiler/rustc_data_structures/src/graph/implementation/mod.rs", "status": "modified", "additions": 2, "deletions": 8, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/6efdf4d1309f8047bc439a4810888c715e2df480/compiler%2Frustc_data_structures%2Fsrc%2Fgraph%2Fimplementation%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6efdf4d1309f8047bc439a4810888c715e2df480/compiler%2Frustc_data_structures%2Fsrc%2Fgraph%2Fimplementation%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_data_structures%2Fsrc%2Fgraph%2Fimplementation%2Fmod.rs?ref=6efdf4d1309f8047bc439a4810888c715e2df480", "patch": "@@ -206,17 +206,11 @@ impl<N: Debug, E: Debug> Graph<N, E> {\n         AdjacentEdges { graph: self, direction, next: first_edge }\n     }\n \n-    pub fn successor_nodes<'a>(\n-        &'a self,\n-        source: NodeIndex,\n-    ) -> impl Iterator<Item = NodeIndex> + 'a {\n+    pub fn successor_nodes(&self, source: NodeIndex) -> impl Iterator<Item = NodeIndex> + '_ {\n         self.outgoing_edges(source).targets()\n     }\n \n-    pub fn predecessor_nodes<'a>(\n-        &'a self,\n-        target: NodeIndex,\n-    ) -> impl Iterator<Item = NodeIndex> + 'a {\n+    pub fn predecessor_nodes(&self, target: NodeIndex) -> impl Iterator<Item = NodeIndex> + '_ {\n         self.incoming_edges(target).sources()\n     }\n "}, {"sha": "e373bd18402a8b7d960076ef17b598c8749a6fb8", "filename": "compiler/rustc_data_structures/src/lib.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/6efdf4d1309f8047bc439a4810888c715e2df480/compiler%2Frustc_data_structures%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6efdf4d1309f8047bc439a4810888c715e2df480/compiler%2Frustc_data_structures%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_data_structures%2Fsrc%2Flib.rs?ref=6efdf4d1309f8047bc439a4810888c715e2df480", "patch": "@@ -1,5 +1,5 @@\n //! Various data structures used by the Rust compiler. The intention\n-//! is that code in here should be not be *specific* to rustc, so that\n+//! is that code in here should not be *specific* to rustc, so that\n //! it can be easily unit tested and so forth.\n //!\n //! # Note\n@@ -27,6 +27,8 @@\n #![feature(thread_id_value)]\n #![feature(vec_into_raw_parts)]\n #![feature(get_mut_unchecked)]\n+#![feature(lint_reasons)]\n+#![feature(unwrap_infallible)]\n #![allow(rustc::default_hash_types)]\n #![allow(rustc::potential_query_instability)]\n #![deny(rustc::untranslatable_diagnostic)]\n@@ -59,7 +61,6 @@ pub mod intern;\n pub mod jobserver;\n pub mod macros;\n pub mod obligation_forest;\n-pub mod owning_ref;\n pub mod sip128;\n pub mod small_c_str;\n pub mod small_str;\n@@ -82,6 +83,7 @@ pub mod vec_linked_list;\n pub mod work_queue;\n pub use atomic_ref::AtomicRef;\n pub mod frozen;\n+pub mod owned_slice;\n pub mod sso;\n pub mod steal;\n pub mod tagged_ptr;"}, {"sha": "ef37a606f313e59221624f90bd2a8e272b3dea11", "filename": "compiler/rustc_data_structures/src/memmap.rs", "status": "modified", "additions": 2, "deletions": 10, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/6efdf4d1309f8047bc439a4810888c715e2df480/compiler%2Frustc_data_structures%2Fsrc%2Fmemmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6efdf4d1309f8047bc439a4810888c715e2df480/compiler%2Frustc_data_structures%2Fsrc%2Fmemmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_data_structures%2Fsrc%2Fmemmap.rs?ref=6efdf4d1309f8047bc439a4810888c715e2df480", "patch": "@@ -2,9 +2,7 @@ use std::fs::File;\n use std::io;\n use std::ops::{Deref, DerefMut};\n \n-use crate::owning_ref::StableAddress;\n-\n-/// A trivial wrapper for [`memmap2::Mmap`] that implements [`StableAddress`].\n+/// A trivial wrapper for [`memmap2::Mmap`] (or `Vec<u8>` on WASM).\n #[cfg(not(target_arch = \"wasm32\"))]\n pub struct Mmap(memmap2::Mmap);\n \n@@ -42,16 +40,10 @@ impl Deref for Mmap {\n \n impl AsRef<[u8]> for Mmap {\n     fn as_ref(&self) -> &[u8] {\n-        &*self.0\n+        &self.0\n     }\n }\n \n-// SAFETY: On architectures other than WASM, mmap is used as backing storage. The address of this\n-// memory map is stable. On WASM, `Vec<u8>` is used as backing storage. The `Mmap` type doesn't\n-// export any function that can cause the `Vec` to be re-allocated. As such the address of the\n-// bytes inside this `Vec` is stable.\n-unsafe impl StableAddress for Mmap {}\n-\n #[cfg(not(target_arch = \"wasm32\"))]\n pub struct MmapMut(memmap2::MmapMut);\n "}, {"sha": "048401f66c27e327c62f464cdf8cf7cd18ff027f", "filename": "compiler/rustc_data_structures/src/owned_slice.rs", "status": "added", "additions": 118, "deletions": 0, "changes": 118, "blob_url": "https://github.com/rust-lang/rust/blob/6efdf4d1309f8047bc439a4810888c715e2df480/compiler%2Frustc_data_structures%2Fsrc%2Fowned_slice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6efdf4d1309f8047bc439a4810888c715e2df480/compiler%2Frustc_data_structures%2Fsrc%2Fowned_slice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_data_structures%2Fsrc%2Fowned_slice.rs?ref=6efdf4d1309f8047bc439a4810888c715e2df480", "patch": "@@ -0,0 +1,118 @@\n+use std::{borrow::Borrow, ops::Deref};\n+\n+// Use our fake Send/Sync traits when on not parallel compiler,\n+// so that `OwnedSlice` only implements/requires Send/Sync\n+// for parallel compiler builds.\n+use crate::sync::{Send, Sync};\n+\n+/// An owned slice.\n+///\n+/// This is similar to `Box<[u8]>` but allows slicing and using anything as the\n+/// backing buffer.\n+///\n+/// See [`slice_owned`] for `OwnedSlice` construction and examples.\n+///\n+/// ---------------------------------------------------------------------------\n+///\n+/// This is essentially a replacement for `owning_ref` which is a lot simpler\n+/// and even sound! \ud83c\udf38\n+pub struct OwnedSlice {\n+    /// This is conceptually a `&'self.owner [u8]`.\n+    bytes: *const [u8],\n+\n+    // +---------------------------------------+\n+    // | We expect `dead_code` lint here,      |\n+    // | because we don't want to accidentally |\n+    // | touch the owner \u2014 otherwise the owner |\n+    // | could invalidate out `bytes` pointer  |\n+    // |                                       |\n+    // | so be quiet                           |\n+    // +----+  +-------------------------------+\n+    //       \\/\n+    //      \u2282(\u00b4\uff65\u25e1\uff65\u2282 )\u2218\u02da\u02f3\u00b0 (I am the phantom remnant of #97770)\n+    #[expect(dead_code)]\n+    owner: Box<dyn Send + Sync>,\n+}\n+\n+/// Makes an [`OwnedSlice`] out of an `owner` and a `slicer` function.\n+///\n+/// ## Examples\n+///\n+/// ```rust\n+/// # use rustc_data_structures::owned_slice::{OwnedSlice, slice_owned};\n+/// let vec = vec![1, 2, 3, 4];\n+///\n+/// // Identical to slicing via `&v[1..3]` but produces an owned slice\n+/// let slice: OwnedSlice = slice_owned(vec, |v| &v[1..3]);\n+/// assert_eq!(&*slice, [2, 3]);\n+/// ```\n+///\n+/// ```rust\n+/// # use rustc_data_structures::owned_slice::{OwnedSlice, slice_owned};\n+/// # use std::ops::Deref;\n+/// let vec = vec![1, 2, 3, 4];\n+///\n+/// // Identical to slicing via `&v[..]` but produces an owned slice\n+/// let slice: OwnedSlice = slice_owned(vec, Deref::deref);\n+/// assert_eq!(&*slice, [1, 2, 3, 4]);\n+/// ```\n+pub fn slice_owned<O, F>(owner: O, slicer: F) -> OwnedSlice\n+where\n+    O: Send + Sync + 'static,\n+    F: FnOnce(&O) -> &[u8],\n+{\n+    try_slice_owned(owner, |x| Ok::<_, !>(slicer(x))).into_ok()\n+}\n+\n+/// Makes an [`OwnedSlice`] out of an `owner` and a `slicer` function that can fail.\n+///\n+/// See [`slice_owned`] for the infallible version.\n+pub fn try_slice_owned<O, F, E>(owner: O, slicer: F) -> Result<OwnedSlice, E>\n+where\n+    O: Send + Sync + 'static,\n+    F: FnOnce(&O) -> Result<&[u8], E>,\n+{\n+    // We box the owner of the bytes, so it doesn't move.\n+    //\n+    // Since the owner does not move and we don't access it in any way\n+    // before drop, there is nothing that can invalidate the bytes pointer.\n+    //\n+    // Thus, \"extending\" the lifetime of the reference returned from `F` is fine.\n+    // We pretend that we pass it a reference that lives as long as the returned slice.\n+    //\n+    // N.B. the HRTB on the `slicer` is important \u2014 without it the caller could provide\n+    // a short lived slice, unrelated to the owner.\n+\n+    let owner = Box::new(owner);\n+    let bytes = slicer(&*owner)?;\n+\n+    Ok(OwnedSlice { bytes, owner })\n+}\n+\n+impl Deref for OwnedSlice {\n+    type Target = [u8];\n+\n+    #[inline]\n+    fn deref(&self) -> &[u8] {\n+        // Safety:\n+        // `self.bytes` is valid per the construction in `slice_owned`\n+        // (which is the only constructor)\n+        unsafe { &*self.bytes }\n+    }\n+}\n+\n+impl Borrow<[u8]> for OwnedSlice {\n+    #[inline]\n+    fn borrow(&self) -> &[u8] {\n+        self\n+    }\n+}\n+\n+// Safety: `OwnedSlice` is conceptually `(&'self.1 [u8], Box<dyn Send + Sync>)`, which is `Send`\n+unsafe impl Send for OwnedSlice {}\n+\n+// Safety: `OwnedSlice` is conceptually `(&'self.1 [u8], Box<dyn Send + Sync>)`, which is `Sync`\n+unsafe impl Sync for OwnedSlice {}\n+\n+#[cfg(test)]\n+mod tests;"}, {"sha": "e715fb55362dd7b66789296e831d275668952bfa", "filename": "compiler/rustc_data_structures/src/owned_slice/tests.rs", "status": "added", "additions": 74, "deletions": 0, "changes": 74, "blob_url": "https://github.com/rust-lang/rust/blob/6efdf4d1309f8047bc439a4810888c715e2df480/compiler%2Frustc_data_structures%2Fsrc%2Fowned_slice%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6efdf4d1309f8047bc439a4810888c715e2df480/compiler%2Frustc_data_structures%2Fsrc%2Fowned_slice%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_data_structures%2Fsrc%2Fowned_slice%2Ftests.rs?ref=6efdf4d1309f8047bc439a4810888c715e2df480", "patch": "@@ -0,0 +1,74 @@\n+use std::{\n+    ops::Deref,\n+    sync::{\n+        atomic::{self, AtomicBool},\n+        Arc,\n+    },\n+};\n+\n+use crate::{\n+    owned_slice::{slice_owned, try_slice_owned, OwnedSlice},\n+    OnDrop,\n+};\n+\n+#[test]\n+fn smoke() {\n+    let slice = slice_owned(vec![1, 2, 3, 4, 5, 6], Vec::as_slice);\n+\n+    assert_eq!(&*slice, [1, 2, 3, 4, 5, 6]);\n+}\n+\n+#[test]\n+fn static_storage() {\n+    let slice = slice_owned(Box::new(String::from(\"what\")), |_| b\"bytes boo\");\n+\n+    assert_eq!(&*slice, b\"bytes boo\");\n+}\n+\n+#[test]\n+fn slice_the_slice() {\n+    let slice = slice_owned(vec![1, 2, 3, 4, 5, 6], Vec::as_slice);\n+    let slice = slice_owned(slice, |s| &s[1..][..4]);\n+    let slice = slice_owned(slice, |s| s);\n+    let slice = slice_owned(slice, |s| &s[1..]);\n+\n+    assert_eq!(&*slice, &[1, 2, 3, 4, 5, 6][1..][..4][1..]);\n+}\n+\n+#[test]\n+fn try_and_fail() {\n+    let res = try_slice_owned(vec![0], |v| v.get(12..).ok_or(()));\n+\n+    assert!(res.is_err());\n+}\n+\n+#[test]\n+fn boxed() {\n+    // It's important that we don't cause UB because of `Box`'es uniqueness\n+\n+    let boxed: Box<[u8]> = vec![1, 1, 2, 3, 5, 8, 13, 21].into_boxed_slice();\n+    let slice = slice_owned(boxed, Deref::deref);\n+\n+    assert_eq!(&*slice, [1, 1, 2, 3, 5, 8, 13, 21]);\n+}\n+\n+#[test]\n+fn drop_drops() {\n+    let flag = Arc::new(AtomicBool::new(false));\n+    let flag_prime = Arc::clone(&flag);\n+    let d = OnDrop(move || flag_prime.store(true, atomic::Ordering::Relaxed));\n+\n+    let slice = slice_owned(d, |_| &[]);\n+\n+    assert_eq!(flag.load(atomic::Ordering::Relaxed), false);\n+\n+    drop(slice);\n+\n+    assert_eq!(flag.load(atomic::Ordering::Relaxed), true);\n+}\n+\n+#[test]\n+fn send_sync() {\n+    crate::sync::assert_send::<OwnedSlice>();\n+    crate::sync::assert_sync::<OwnedSlice>();\n+}"}, {"sha": "dff72d1e43251989d52b6bec53c8588f7f4df47b", "filename": "compiler/rustc_data_structures/src/owning_ref/LICENSE", "status": "removed", "additions": 0, "deletions": 21, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/0bb6d66251dae171bac858874be87d714004cc16/compiler%2Frustc_data_structures%2Fsrc%2Fowning_ref%2FLICENSE", "raw_url": "https://github.com/rust-lang/rust/raw/0bb6d66251dae171bac858874be87d714004cc16/compiler%2Frustc_data_structures%2Fsrc%2Fowning_ref%2FLICENSE", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_data_structures%2Fsrc%2Fowning_ref%2FLICENSE?ref=0bb6d66251dae171bac858874be87d714004cc16", "patch": "@@ -1,21 +0,0 @@\n-The MIT License (MIT)\n-\n-Copyright (c) 2015 Marvin L\u00f6bel\n-\n-Permission is hereby granted, free of charge, to any person obtaining a copy\n-of this software and associated documentation files (the \"Software\"), to deal\n-in the Software without restriction, including without limitation the rights\n-to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n-copies of the Software, and to permit persons to whom the Software is\n-furnished to do so, subject to the following conditions:\n-\n-The above copyright notice and this permission notice shall be included in all\n-copies or substantial portions of the Software.\n-\n-THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n-IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n-FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n-AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n-LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n-OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n-SOFTWARE."}, {"sha": "d1d92b905b82e0b9da4db953f10c263d8bce4838", "filename": "compiler/rustc_data_structures/src/owning_ref/mod.rs", "status": "removed", "additions": 0, "deletions": 1211, "changes": 1211, "blob_url": "https://github.com/rust-lang/rust/blob/0bb6d66251dae171bac858874be87d714004cc16/compiler%2Frustc_data_structures%2Fsrc%2Fowning_ref%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0bb6d66251dae171bac858874be87d714004cc16/compiler%2Frustc_data_structures%2Fsrc%2Fowning_ref%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_data_structures%2Fsrc%2Fowning_ref%2Fmod.rs?ref=0bb6d66251dae171bac858874be87d714004cc16", "patch": "@@ -1,1211 +0,0 @@\n-#![warn(missing_docs)]\n-\n-/*!\n-# An owning reference.\n-\n-This crate provides the _owning reference_ types `OwningRef` and `OwningRefMut`\n-that enables it to bundle a reference together with the owner of the data it points to.\n-This allows moving and dropping of an `OwningRef` without needing to recreate the reference.\n-\n-This can sometimes be useful because Rust borrowing rules normally prevent\n-moving a type that has been moved from. For example, this kind of code gets rejected:\n-\n-```compile_fail,E0515\n-fn return_owned_and_referenced<'a>() -> (Vec<u8>, &'a [u8]) {\n-    let v = vec![1, 2, 3, 4];\n-    let s = &v[1..3];\n-    (v, s)\n-}\n-```\n-\n-Even though, from a memory-layout point of view, this can be entirely safe\n-if the new location of the vector still lives longer than the lifetime `'a`\n-of the reference because the backing allocation of the vector does not change.\n-\n-This library enables this safe usage by keeping the owner and the reference\n-bundled together in a wrapper type that ensure that lifetime constraint:\n-\n-```\n-# use rustc_data_structures::owning_ref::OwningRef;\n-# fn main() {\n-fn return_owned_and_referenced() -> OwningRef<Vec<u8>, [u8]> {\n-    let v = vec![1, 2, 3, 4];\n-    let or = OwningRef::new(v);\n-    let or = or.map(|v| &v[1..3]);\n-    or\n-}\n-# }\n-```\n-\n-It works by requiring owner types to dereference to stable memory locations\n-and preventing mutable access to root containers, which in practice requires heap allocation\n-as provided by `Box<T>`, `Rc<T>`, etc.\n-\n-Also provided are typedefs for common owner type combinations,\n-which allow for less verbose type signatures.\n-For example, `BoxRef<T>` instead of `OwningRef<Box<T>, T>`.\n-\n-The crate also provides the more advanced `OwningHandle` type,\n-which allows more freedom in bundling a dependent handle object\n-along with the data it depends on, at the cost of some unsafe needed in the API.\n-See the documentation around `OwningHandle` for more details.\n-\n-# Examples\n-\n-## Basics\n-\n-```\n-use rustc_data_structures::owning_ref::BoxRef;\n-\n-fn main() {\n-    // Create an array owned by a Box.\n-    let arr = Box::new([1, 2, 3, 4]) as Box<[i32]>;\n-\n-    // Transfer into a BoxRef.\n-    let arr: BoxRef<[i32]> = BoxRef::new(arr);\n-    assert_eq!(&*arr, &[1, 2, 3, 4]);\n-\n-    // We can slice the array without losing ownership or changing type.\n-    let arr: BoxRef<[i32]> = arr.map(|arr| &arr[1..3]);\n-    assert_eq!(&*arr, &[2, 3]);\n-\n-    // Also works for Arc, Rc, String and Vec!\n-}\n-```\n-\n-## Caching a reference to a struct field\n-\n-```\n-use rustc_data_structures::owning_ref::BoxRef;\n-\n-fn main() {\n-    struct Foo {\n-        tag: u32,\n-        x: u16,\n-        y: u16,\n-        z: u16,\n-    }\n-    let foo = Foo { tag: 1, x: 100, y: 200, z: 300 };\n-\n-    let or = BoxRef::new(Box::new(foo)).map(|foo| {\n-        match foo.tag {\n-            0 => &foo.x,\n-            1 => &foo.y,\n-            2 => &foo.z,\n-            _ => panic!(),\n-        }\n-    });\n-\n-    assert_eq!(*or, 200);\n-}\n-```\n-\n-## Caching a reference to an entry in a vector\n-\n-```\n-use rustc_data_structures::owning_ref::VecRef;\n-\n-fn main() {\n-    let v = VecRef::new(vec![1, 2, 3, 4, 5]).map(|v| &v[3]);\n-    assert_eq!(*v, 4);\n-}\n-```\n-\n-## Caching a subslice of a String\n-\n-```\n-use rustc_data_structures::owning_ref::StringRef;\n-\n-fn main() {\n-    let s = StringRef::new(\"hello world\".to_owned())\n-        .map(|s| s.split(' ').nth(1).unwrap());\n-\n-    assert_eq!(&*s, \"world\");\n-}\n-```\n-\n-## Reference counted slices that share ownership of the backing storage\n-\n-```\n-use rustc_data_structures::owning_ref::RcRef;\n-use std::rc::Rc;\n-\n-fn main() {\n-    let rc: RcRef<[i32]> = RcRef::new(Rc::new([1, 2, 3, 4]) as Rc<[i32]>);\n-    assert_eq!(&*rc, &[1, 2, 3, 4]);\n-\n-    let rc_a: RcRef<[i32]> = rc.clone().map(|s| &s[0..2]);\n-    let rc_b = rc.clone().map(|s| &s[1..3]);\n-    let rc_c = rc.clone().map(|s| &s[2..4]);\n-    assert_eq!(&*rc_a, &[1, 2]);\n-    assert_eq!(&*rc_b, &[2, 3]);\n-    assert_eq!(&*rc_c, &[3, 4]);\n-\n-    let rc_c_a = rc_c.clone().map(|s| &s[1]);\n-    assert_eq!(&*rc_c_a, &4);\n-}\n-```\n-\n-## Atomic reference counted slices that share ownership of the backing storage\n-\n-```\n-use rustc_data_structures::owning_ref::ArcRef;\n-use std::sync::Arc;\n-\n-fn main() {\n-    use std::thread;\n-\n-    fn par_sum(rc: ArcRef<[i32]>) -> i32 {\n-        if rc.len() == 0 {\n-            return 0;\n-        } else if rc.len() == 1 {\n-            return rc[0];\n-        }\n-        let mid = rc.len() / 2;\n-        let left = rc.clone().map(|s| &s[..mid]);\n-        let right = rc.map(|s| &s[mid..]);\n-\n-        let left = thread::spawn(move || par_sum(left));\n-        let right = thread::spawn(move || par_sum(right));\n-\n-        left.join().unwrap() + right.join().unwrap()\n-    }\n-\n-    let rc: Arc<[i32]> = Arc::new([1, 2, 3, 4]);\n-    let rc: ArcRef<[i32]> = rc.into();\n-\n-    assert_eq!(par_sum(rc), 10);\n-}\n-```\n-\n-## References into RAII locks\n-\n-```\n-use rustc_data_structures::owning_ref::RefRef;\n-use std::cell::{RefCell, Ref};\n-\n-fn main() {\n-    let refcell = RefCell::new((1, 2, 3, 4));\n-    // Also works with Mutex and RwLock\n-\n-    let refref = {\n-        let refref = RefRef::new(refcell.borrow()).map(|x| &x.3);\n-        assert_eq!(*refref, 4);\n-\n-        // We move the RAII lock and the reference to one of\n-        // the subfields in the data it guards here:\n-        refref\n-    };\n-\n-    assert_eq!(*refref, 4);\n-\n-    drop(refref);\n-\n-    assert_eq!(*refcell.borrow(), (1, 2, 3, 4));\n-}\n-```\n-\n-## Mutable reference\n-\n-When the owned container implements `DerefMut`, it is also possible to make\n-a _mutable owning reference_. (e.g., with `Box`, `RefMut`, `MutexGuard`)\n-\n-```\n-use rustc_data_structures::owning_ref::RefMutRefMut;\n-use std::cell::{RefCell, RefMut};\n-\n-fn main() {\n-    let refcell = RefCell::new((1, 2, 3, 4));\n-\n-    let mut refmut_refmut = {\n-        let mut refmut_refmut = RefMutRefMut::new(refcell.borrow_mut()).map_mut(|x| &mut x.3);\n-        assert_eq!(*refmut_refmut, 4);\n-        *refmut_refmut *= 2;\n-\n-        refmut_refmut\n-    };\n-\n-    assert_eq!(*refmut_refmut, 8);\n-    *refmut_refmut *= 2;\n-\n-    drop(refmut_refmut);\n-\n-    assert_eq!(*refcell.borrow(), (1, 2, 3, 16));\n-}\n-```\n-*/\n-\n-pub use stable_deref_trait::{\n-    CloneStableDeref as CloneStableAddress, StableDeref as StableAddress,\n-};\n-use std::mem;\n-\n-/// An owning reference.\n-///\n-/// This wraps an owner `O` and a reference `&T` pointing\n-/// at something reachable from `O::Target` while keeping\n-/// the ability to move `self` around.\n-///\n-/// The owner is usually a pointer that points at some base type.\n-///\n-/// For more details and examples, see the module and method docs.\n-pub struct OwningRef<O, T: ?Sized> {\n-    owner: O,\n-    reference: *const T,\n-}\n-\n-/// An mutable owning reference.\n-///\n-/// This wraps an owner `O` and a reference `&mut T` pointing\n-/// at something reachable from `O::Target` while keeping\n-/// the ability to move `self` around.\n-///\n-/// The owner is usually a pointer that points at some base type.\n-///\n-/// For more details and examples, see the module and method docs.\n-pub struct OwningRefMut<O, T: ?Sized> {\n-    owner: O,\n-    reference: *mut T,\n-}\n-\n-/// Helper trait for an erased concrete type an owner dereferences to.\n-/// This is used in form of a trait object for keeping\n-/// something around to (virtually) call the destructor.\n-pub trait Erased {}\n-impl<T> Erased for T {}\n-\n-/// Helper trait for erasing the concrete type of what an owner dereferences to,\n-/// for example `Box<T> -> Box<Erased>`. This would be unneeded with\n-/// higher kinded types support in the language.\n-#[allow(unused_lifetimes)]\n-pub unsafe trait IntoErased<'a> {\n-    /// Owner with the dereference type substituted to `Erased`.\n-    type Erased;\n-    /// Performs the type erasure.\n-    fn into_erased(self) -> Self::Erased;\n-}\n-\n-/// Helper trait for erasing the concrete type of what an owner dereferences to,\n-/// for example `Box<T> -> Box<Erased + Send>`. This would be unneeded with\n-/// higher kinded types support in the language.\n-#[allow(unused_lifetimes)]\n-pub unsafe trait IntoErasedSend<'a> {\n-    /// Owner with the dereference type substituted to `Erased + Send`.\n-    type Erased: Send;\n-    /// Performs the type erasure.\n-    fn into_erased_send(self) -> Self::Erased;\n-}\n-\n-/// Helper trait for erasing the concrete type of what an owner dereferences to,\n-/// for example `Box<T> -> Box<Erased + Send + Sync>`. This would be unneeded with\n-/// higher kinded types support in the language.\n-#[allow(unused_lifetimes)]\n-pub unsafe trait IntoErasedSendSync<'a> {\n-    /// Owner with the dereference type substituted to `Erased + Send + Sync`.\n-    type Erased: Send + Sync;\n-    /// Performs the type erasure.\n-    fn into_erased_send_sync(self) -> Self::Erased;\n-}\n-\n-/////////////////////////////////////////////////////////////////////////////\n-// OwningRef\n-/////////////////////////////////////////////////////////////////////////////\n-\n-impl<O, T: ?Sized> OwningRef<O, T> {\n-    /// Creates a new owning reference from an owner\n-    /// initialized to the direct dereference of it.\n-    ///\n-    /// # Example\n-    /// ```\n-    /// use rustc_data_structures::owning_ref::OwningRef;\n-    ///\n-    /// fn main() {\n-    ///     let owning_ref = OwningRef::new(Box::new(42));\n-    ///     assert_eq!(*owning_ref, 42);\n-    /// }\n-    /// ```\n-    pub fn new(o: O) -> Self\n-    where\n-        O: StableAddress,\n-        O: Deref<Target = T>,\n-    {\n-        OwningRef { reference: &*o, owner: o }\n-    }\n-\n-    /// Like `new`, but doesn\u2019t require `O` to implement the `StableAddress` trait.\n-    /// Instead, the caller is responsible to make the same promises as implementing the trait.\n-    ///\n-    /// This is useful for cases where coherence rules prevents implementing the trait\n-    /// without adding a dependency to this crate in a third-party library.\n-    pub unsafe fn new_assert_stable_address(o: O) -> Self\n-    where\n-        O: Deref<Target = T>,\n-    {\n-        OwningRef { reference: &*o, owner: o }\n-    }\n-\n-    /// Converts `self` into a new owning reference that points at something reachable\n-    /// from the previous one.\n-    ///\n-    /// This can be a reference to a field of `U`, something reachable from a field of\n-    /// `U`, or even something unrelated with a `'static` lifetime.\n-    ///\n-    /// # Example\n-    /// ```\n-    /// use rustc_data_structures::owning_ref::OwningRef;\n-    ///\n-    /// fn main() {\n-    ///     let owning_ref = OwningRef::new(Box::new([1, 2, 3, 4]));\n-    ///\n-    ///     // create an owning reference that points at the\n-    ///     // third element of the array.\n-    ///     let owning_ref = owning_ref.map(|array| &array[2]);\n-    ///     assert_eq!(*owning_ref, 3);\n-    /// }\n-    /// ```\n-    pub fn map<F, U: ?Sized>(self, f: F) -> OwningRef<O, U>\n-    where\n-        O: StableAddress,\n-        F: FnOnce(&T) -> &U,\n-    {\n-        OwningRef { reference: f(&self), owner: self.owner }\n-    }\n-\n-    /// Tries to convert `self` into a new owning reference that points\n-    /// at something reachable from the previous one.\n-    ///\n-    /// This can be a reference to a field of `U`, something reachable from a field of\n-    /// `U`, or even something unrelated with a `'static` lifetime.\n-    ///\n-    /// # Example\n-    /// ```\n-    /// use rustc_data_structures::owning_ref::OwningRef;\n-    ///\n-    /// fn main() {\n-    ///     let owning_ref = OwningRef::new(Box::new([1, 2, 3, 4]));\n-    ///\n-    ///     // create an owning reference that points at the\n-    ///     // third element of the array.\n-    ///     let owning_ref = owning_ref.try_map(|array| {\n-    ///         if array[2] == 3 { Ok(&array[2]) } else { Err(()) }\n-    ///     });\n-    ///     assert_eq!(*owning_ref.unwrap(), 3);\n-    /// }\n-    /// ```\n-    pub fn try_map<F, U: ?Sized, E>(self, f: F) -> Result<OwningRef<O, U>, E>\n-    where\n-        O: StableAddress,\n-        F: FnOnce(&T) -> Result<&U, E>,\n-    {\n-        Ok(OwningRef { reference: f(&self)?, owner: self.owner })\n-    }\n-\n-    /// Converts `self` into a new owning reference with a different owner type.\n-    ///\n-    /// The new owner type needs to still contain the original owner in some way\n-    /// so that the reference into it remains valid. This function is marked unsafe\n-    /// because the user needs to manually uphold this guarantee.\n-    pub unsafe fn map_owner<F, P>(self, f: F) -> OwningRef<P, T>\n-    where\n-        O: StableAddress,\n-        P: StableAddress,\n-        F: FnOnce(O) -> P,\n-    {\n-        OwningRef { reference: self.reference, owner: f(self.owner) }\n-    }\n-\n-    /// Converts `self` into a new owning reference where the owner is wrapped\n-    /// in an additional `Box<O>`.\n-    ///\n-    /// This can be used to safely erase the owner of any `OwningRef<O, T>`\n-    /// to an `OwningRef<Box<Erased>, T>`.\n-    pub fn map_owner_box(self) -> OwningRef<Box<O>, T> {\n-        OwningRef { reference: self.reference, owner: Box::new(self.owner) }\n-    }\n-\n-    /// Erases the concrete base type of the owner with a trait object.\n-    ///\n-    /// This allows mixing of owned references with different owner base types.\n-    ///\n-    /// # Example\n-    /// ```\n-    /// use rustc_data_structures::owning_ref::{OwningRef, Erased};\n-    ///\n-    /// fn main() {\n-    ///     // N.B., using the concrete types here for explicitness.\n-    ///     // For less verbose code type aliases like `BoxRef` are provided.\n-    ///\n-    ///     let owning_ref_a: OwningRef<Box<[i32; 4]>, [i32; 4]>\n-    ///         = OwningRef::new(Box::new([1, 2, 3, 4]));\n-    ///\n-    ///     let owning_ref_b: OwningRef<Box<Vec<(i32, bool)>>, Vec<(i32, bool)>>\n-    ///         = OwningRef::new(Box::new(vec![(0, false), (1, true)]));\n-    ///\n-    ///     let owning_ref_a: OwningRef<Box<[i32; 4]>, i32>\n-    ///         = owning_ref_a.map(|a| &a[0]);\n-    ///\n-    ///     let owning_ref_b: OwningRef<Box<Vec<(i32, bool)>>, i32>\n-    ///         = owning_ref_b.map(|a| &a[1].0);\n-    ///\n-    ///     let owning_refs: [OwningRef<Box<dyn Erased>, i32>; 2]\n-    ///         = [owning_ref_a.erase_owner(), owning_ref_b.erase_owner()];\n-    ///\n-    ///     assert_eq!(*owning_refs[0], 1);\n-    ///     assert_eq!(*owning_refs[1], 1);\n-    /// }\n-    /// ```\n-    pub fn erase_owner<'a>(self) -> OwningRef<O::Erased, T>\n-    where\n-        O: IntoErased<'a>,\n-    {\n-        OwningRef { reference: self.reference, owner: self.owner.into_erased() }\n-    }\n-\n-    /// Erases the concrete base type of the owner with a trait object which implements `Send`.\n-    ///\n-    /// This allows mixing of owned references with different owner base types.\n-    pub fn erase_send_owner<'a>(self) -> OwningRef<O::Erased, T>\n-    where\n-        O: IntoErasedSend<'a>,\n-    {\n-        OwningRef { reference: self.reference, owner: self.owner.into_erased_send() }\n-    }\n-\n-    /// Erases the concrete base type of the owner with a trait object\n-    /// which implements `Send` and `Sync`.\n-    ///\n-    /// This allows mixing of owned references with different owner base types.\n-    pub fn erase_send_sync_owner<'a>(self) -> OwningRef<O::Erased, T>\n-    where\n-        O: IntoErasedSendSync<'a>,\n-    {\n-        OwningRef { reference: self.reference, owner: self.owner.into_erased_send_sync() }\n-    }\n-\n-    // UNIMPLEMENTED: wrap_owner\n-\n-    // FIXME: Naming convention?\n-    /// A getter for the underlying owner.\n-    pub fn owner(&self) -> &O {\n-        &self.owner\n-    }\n-\n-    // FIXME: Naming convention?\n-    /// Discards the reference and retrieves the owner.\n-    pub fn into_inner(self) -> O {\n-        self.owner\n-    }\n-}\n-\n-impl<O, T: ?Sized> OwningRefMut<O, T> {\n-    /// Creates a new owning reference from an owner\n-    /// initialized to the direct dereference of it.\n-    ///\n-    /// # Example\n-    /// ```\n-    /// use rustc_data_structures::owning_ref::OwningRefMut;\n-    ///\n-    /// fn main() {\n-    ///     let owning_ref_mut = OwningRefMut::new(Box::new(42));\n-    ///     assert_eq!(*owning_ref_mut, 42);\n-    /// }\n-    /// ```\n-    pub fn new(mut o: O) -> Self\n-    where\n-        O: StableAddress,\n-        O: DerefMut<Target = T>,\n-    {\n-        OwningRefMut { reference: &mut *o, owner: o }\n-    }\n-\n-    /// Like `new`, but doesn\u2019t require `O` to implement the `StableAddress` trait.\n-    /// Instead, the caller is responsible to make the same promises as implementing the trait.\n-    ///\n-    /// This is useful for cases where coherence rules prevents implementing the trait\n-    /// without adding a dependency to this crate in a third-party library.\n-    pub unsafe fn new_assert_stable_address(mut o: O) -> Self\n-    where\n-        O: DerefMut<Target = T>,\n-    {\n-        OwningRefMut { reference: &mut *o, owner: o }\n-    }\n-\n-    /// Converts `self` into a new _shared_ owning reference that points at\n-    /// something reachable from the previous one.\n-    ///\n-    /// This can be a reference to a field of `U`, something reachable from a field of\n-    /// `U`, or even something unrelated with a `'static` lifetime.\n-    ///\n-    /// # Example\n-    /// ```\n-    /// use rustc_data_structures::owning_ref::OwningRefMut;\n-    ///\n-    /// fn main() {\n-    ///     let owning_ref_mut = OwningRefMut::new(Box::new([1, 2, 3, 4]));\n-    ///\n-    ///     // create an owning reference that points at the\n-    ///     // third element of the array.\n-    ///     let owning_ref = owning_ref_mut.map(|array| &array[2]);\n-    ///     assert_eq!(*owning_ref, 3);\n-    /// }\n-    /// ```\n-    pub fn map<F, U: ?Sized>(mut self, f: F) -> OwningRef<O, U>\n-    where\n-        O: StableAddress,\n-        F: FnOnce(&mut T) -> &U,\n-    {\n-        OwningRef { reference: f(&mut self), owner: self.owner }\n-    }\n-\n-    /// Converts `self` into a new _mutable_ owning reference that points at\n-    /// something reachable from the previous one.\n-    ///\n-    /// This can be a reference to a field of `U`, something reachable from a field of\n-    /// `U`, or even something unrelated with a `'static` lifetime.\n-    ///\n-    /// # Example\n-    /// ```\n-    /// use rustc_data_structures::owning_ref::OwningRefMut;\n-    ///\n-    /// fn main() {\n-    ///     let owning_ref_mut = OwningRefMut::new(Box::new([1, 2, 3, 4]));\n-    ///\n-    ///     // create an owning reference that points at the\n-    ///     // third element of the array.\n-    ///     let owning_ref_mut = owning_ref_mut.map_mut(|array| &mut array[2]);\n-    ///     assert_eq!(*owning_ref_mut, 3);\n-    /// }\n-    /// ```\n-    pub fn map_mut<F, U: ?Sized>(mut self, f: F) -> OwningRefMut<O, U>\n-    where\n-        O: StableAddress,\n-        F: FnOnce(&mut T) -> &mut U,\n-    {\n-        OwningRefMut { reference: f(&mut self), owner: self.owner }\n-    }\n-\n-    /// Tries to convert `self` into a new _shared_ owning reference that points\n-    /// at something reachable from the previous one.\n-    ///\n-    /// This can be a reference to a field of `U`, something reachable from a field of\n-    /// `U`, or even something unrelated with a `'static` lifetime.\n-    ///\n-    /// # Example\n-    /// ```\n-    /// use rustc_data_structures::owning_ref::OwningRefMut;\n-    ///\n-    /// fn main() {\n-    ///     let owning_ref_mut = OwningRefMut::new(Box::new([1, 2, 3, 4]));\n-    ///\n-    ///     // create an owning reference that points at the\n-    ///     // third element of the array.\n-    ///     let owning_ref = owning_ref_mut.try_map(|array| {\n-    ///         if array[2] == 3 { Ok(&array[2]) } else { Err(()) }\n-    ///     });\n-    ///     assert_eq!(*owning_ref.unwrap(), 3);\n-    /// }\n-    /// ```\n-    pub fn try_map<F, U: ?Sized, E>(mut self, f: F) -> Result<OwningRef<O, U>, E>\n-    where\n-        O: StableAddress,\n-        F: FnOnce(&mut T) -> Result<&U, E>,\n-    {\n-        Ok(OwningRef { reference: f(&mut self)?, owner: self.owner })\n-    }\n-\n-    /// Tries to convert `self` into a new _mutable_ owning reference that points\n-    /// at something reachable from the previous one.\n-    ///\n-    /// This can be a reference to a field of `U`, something reachable from a field of\n-    /// `U`, or even something unrelated with a `'static` lifetime.\n-    ///\n-    /// # Example\n-    /// ```\n-    /// use rustc_data_structures::owning_ref::OwningRefMut;\n-    ///\n-    /// fn main() {\n-    ///     let owning_ref_mut = OwningRefMut::new(Box::new([1, 2, 3, 4]));\n-    ///\n-    ///     // create an owning reference that points at the\n-    ///     // third element of the array.\n-    ///     let owning_ref_mut = owning_ref_mut.try_map_mut(|array| {\n-    ///         if array[2] == 3 { Ok(&mut array[2]) } else { Err(()) }\n-    ///     });\n-    ///     assert_eq!(*owning_ref_mut.unwrap(), 3);\n-    /// }\n-    /// ```\n-    pub fn try_map_mut<F, U: ?Sized, E>(mut self, f: F) -> Result<OwningRefMut<O, U>, E>\n-    where\n-        O: StableAddress,\n-        F: FnOnce(&mut T) -> Result<&mut U, E>,\n-    {\n-        Ok(OwningRefMut { reference: f(&mut self)?, owner: self.owner })\n-    }\n-\n-    /// Converts `self` into a new owning reference with a different owner type.\n-    ///\n-    /// The new owner type needs to still contain the original owner in some way\n-    /// so that the reference into it remains valid. This function is marked unsafe\n-    /// because the user needs to manually uphold this guarantee.\n-    pub unsafe fn map_owner<F, P>(self, f: F) -> OwningRefMut<P, T>\n-    where\n-        O: StableAddress,\n-        P: StableAddress,\n-        F: FnOnce(O) -> P,\n-    {\n-        OwningRefMut { reference: self.reference, owner: f(self.owner) }\n-    }\n-\n-    /// Converts `self` into a new owning reference where the owner is wrapped\n-    /// in an additional `Box<O>`.\n-    ///\n-    /// This can be used to safely erase the owner of any `OwningRefMut<O, T>`\n-    /// to an `OwningRefMut<Box<Erased>, T>`.\n-    pub fn map_owner_box(self) -> OwningRefMut<Box<O>, T> {\n-        OwningRefMut { reference: self.reference, owner: Box::new(self.owner) }\n-    }\n-\n-    /// Erases the concrete base type of the owner with a trait object.\n-    ///\n-    /// This allows mixing of owned references with different owner base types.\n-    ///\n-    /// # Example\n-    /// ```\n-    /// use rustc_data_structures::owning_ref::{OwningRefMut, Erased};\n-    ///\n-    /// fn main() {\n-    ///     // N.B., using the concrete types here for explicitness.\n-    ///     // For less verbose code type aliases like `BoxRef` are provided.\n-    ///\n-    ///     let owning_ref_mut_a: OwningRefMut<Box<[i32; 4]>, [i32; 4]>\n-    ///         = OwningRefMut::new(Box::new([1, 2, 3, 4]));\n-    ///\n-    ///     let owning_ref_mut_b: OwningRefMut<Box<Vec<(i32, bool)>>, Vec<(i32, bool)>>\n-    ///         = OwningRefMut::new(Box::new(vec![(0, false), (1, true)]));\n-    ///\n-    ///     let owning_ref_mut_a: OwningRefMut<Box<[i32; 4]>, i32>\n-    ///         = owning_ref_mut_a.map_mut(|a| &mut a[0]);\n-    ///\n-    ///     let owning_ref_mut_b: OwningRefMut<Box<Vec<(i32, bool)>>, i32>\n-    ///         = owning_ref_mut_b.map_mut(|a| &mut a[1].0);\n-    ///\n-    ///     let owning_refs_mut: [OwningRefMut<Box<dyn Erased>, i32>; 2]\n-    ///         = [owning_ref_mut_a.erase_owner(), owning_ref_mut_b.erase_owner()];\n-    ///\n-    ///     assert_eq!(*owning_refs_mut[0], 1);\n-    ///     assert_eq!(*owning_refs_mut[1], 1);\n-    /// }\n-    /// ```\n-    pub fn erase_owner<'a>(self) -> OwningRefMut<O::Erased, T>\n-    where\n-        O: IntoErased<'a>,\n-    {\n-        OwningRefMut { reference: self.reference, owner: self.owner.into_erased() }\n-    }\n-\n-    // UNIMPLEMENTED: wrap_owner\n-\n-    // FIXME: Naming convention?\n-    /// A getter for the underlying owner.\n-    pub fn owner(&self) -> &O {\n-        &self.owner\n-    }\n-\n-    // FIXME: Naming convention?\n-    /// Discards the reference and retrieves the owner.\n-    pub fn into_inner(self) -> O {\n-        self.owner\n-    }\n-}\n-\n-/////////////////////////////////////////////////////////////////////////////\n-// OwningHandle\n-/////////////////////////////////////////////////////////////////////////////\n-\n-use std::ops::{Deref, DerefMut};\n-\n-/// `OwningHandle` is a complement to `OwningRef`. Where `OwningRef` allows\n-/// consumers to pass around an owned object and a dependent reference,\n-/// `OwningHandle` contains an owned object and a dependent _object_.\n-///\n-/// `OwningHandle` can encapsulate a `RefMut` along with its associated\n-/// `RefCell`, or an `RwLockReadGuard` along with its associated `RwLock`.\n-/// However, the API is completely generic and there are no restrictions on\n-/// what types of owning and dependent objects may be used.\n-///\n-/// `OwningHandle` is created by passing an owner object (which dereferences\n-/// to a stable address) along with a callback which receives a pointer to\n-/// that stable location. The callback may then dereference the pointer and\n-/// mint a dependent object, with the guarantee that the returned object will\n-/// not outlive the referent of the pointer.\n-///\n-/// Since the callback needs to dereference a raw pointer, it requires `unsafe`\n-/// code. To avoid forcing this unsafety on most callers, the `ToHandle` trait is\n-/// implemented for common data structures. Types that implement `ToHandle` can\n-/// be wrapped into an `OwningHandle` without passing a callback.\n-pub struct OwningHandle<O, H>\n-where\n-    O: StableAddress,\n-    H: Deref,\n-{\n-    handle: H,\n-    _owner: O,\n-}\n-\n-impl<O, H> Deref for OwningHandle<O, H>\n-where\n-    O: StableAddress,\n-    H: Deref,\n-{\n-    type Target = H::Target;\n-    fn deref(&self) -> &H::Target {\n-        self.handle.deref()\n-    }\n-}\n-\n-unsafe impl<O, H> StableAddress for OwningHandle<O, H>\n-where\n-    O: StableAddress,\n-    H: StableAddress,\n-{\n-}\n-\n-impl<O, H> DerefMut for OwningHandle<O, H>\n-where\n-    O: StableAddress,\n-    H: DerefMut,\n-{\n-    fn deref_mut(&mut self) -> &mut H::Target {\n-        self.handle.deref_mut()\n-    }\n-}\n-\n-/// Trait to implement the conversion of owner to handle for common types.\n-pub trait ToHandle {\n-    /// The type of handle to be encapsulated by the OwningHandle.\n-    type Handle: Deref;\n-\n-    /// Given an appropriately-long-lived pointer to ourselves, create a\n-    /// handle to be encapsulated by the `OwningHandle`.\n-    unsafe fn to_handle(x: *const Self) -> Self::Handle;\n-}\n-\n-/// Trait to implement the conversion of owner to mutable handle for common types.\n-pub trait ToHandleMut {\n-    /// The type of handle to be encapsulated by the OwningHandle.\n-    type HandleMut: DerefMut;\n-\n-    /// Given an appropriately-long-lived pointer to ourselves, create a\n-    /// mutable handle to be encapsulated by the `OwningHandle`.\n-    unsafe fn to_handle_mut(x: *const Self) -> Self::HandleMut;\n-}\n-\n-impl<O, H> OwningHandle<O, H>\n-where\n-    O: StableAddress<Target: ToHandle<Handle = H>>,\n-    H: Deref,\n-{\n-    /// Creates a new `OwningHandle` for a type that implements `ToHandle`. For types\n-    /// that don't implement `ToHandle`, callers may invoke `new_with_fn`, which accepts\n-    /// a callback to perform the conversion.\n-    pub fn new(o: O) -> Self {\n-        OwningHandle::new_with_fn(o, |x| unsafe { O::Target::to_handle(x) })\n-    }\n-}\n-\n-impl<O, H> OwningHandle<O, H>\n-where\n-    O: StableAddress<Target: ToHandleMut<HandleMut = H>>,\n-    H: DerefMut,\n-{\n-    /// Creates a new mutable `OwningHandle` for a type that implements `ToHandleMut`.\n-    pub fn new_mut(o: O) -> Self {\n-        OwningHandle::new_with_fn(o, |x| unsafe { O::Target::to_handle_mut(x) })\n-    }\n-}\n-\n-impl<O, H> OwningHandle<O, H>\n-where\n-    O: StableAddress,\n-    H: Deref,\n-{\n-    /// Creates a new OwningHandle. The provided callback will be invoked with\n-    /// a pointer to the object owned by `o`, and the returned value is stored\n-    /// as the object to which this `OwningHandle` will forward `Deref` and\n-    /// `DerefMut`.\n-    pub fn new_with_fn<F>(o: O, f: F) -> Self\n-    where\n-        F: FnOnce(*const O::Target) -> H,\n-    {\n-        let h: H;\n-        {\n-            h = f(o.deref() as *const O::Target);\n-        }\n-\n-        OwningHandle { handle: h, _owner: o }\n-    }\n-\n-    /// Creates a new OwningHandle. The provided callback will be invoked with\n-    /// a pointer to the object owned by `o`, and the returned value is stored\n-    /// as the object to which this `OwningHandle` will forward `Deref` and\n-    /// `DerefMut`.\n-    pub fn try_new<F, E>(o: O, f: F) -> Result<Self, E>\n-    where\n-        F: FnOnce(*const O::Target) -> Result<H, E>,\n-    {\n-        let h: H;\n-        {\n-            h = f(o.deref() as *const O::Target)?;\n-        }\n-\n-        Ok(OwningHandle { handle: h, _owner: o })\n-    }\n-}\n-\n-/////////////////////////////////////////////////////////////////////////////\n-// std traits\n-/////////////////////////////////////////////////////////////////////////////\n-\n-use std::borrow::Borrow;\n-use std::cmp::Ordering;\n-use std::fmt::{self, Debug};\n-use std::hash::{Hash, Hasher};\n-\n-impl<O, T: ?Sized> Deref for OwningRef<O, T> {\n-    type Target = T;\n-\n-    fn deref(&self) -> &T {\n-        unsafe { &*self.reference }\n-    }\n-}\n-\n-impl<O, T: ?Sized> Deref for OwningRefMut<O, T> {\n-    type Target = T;\n-\n-    fn deref(&self) -> &T {\n-        unsafe { &*self.reference }\n-    }\n-}\n-\n-impl<O, T: ?Sized> DerefMut for OwningRefMut<O, T> {\n-    fn deref_mut(&mut self) -> &mut T {\n-        unsafe { &mut *self.reference }\n-    }\n-}\n-\n-unsafe impl<O, T: ?Sized> StableAddress for OwningRef<O, T> {}\n-\n-impl<O, T: ?Sized> AsRef<T> for OwningRef<O, T> {\n-    fn as_ref(&self) -> &T {\n-        self\n-    }\n-}\n-\n-impl<O, T: ?Sized> AsRef<T> for OwningRefMut<O, T> {\n-    fn as_ref(&self) -> &T {\n-        self\n-    }\n-}\n-\n-impl<O, T: ?Sized> AsMut<T> for OwningRefMut<O, T> {\n-    fn as_mut(&mut self) -> &mut T {\n-        self\n-    }\n-}\n-\n-impl<O, T: ?Sized> Borrow<T> for OwningRef<O, T> {\n-    fn borrow(&self) -> &T {\n-        self\n-    }\n-}\n-\n-impl<O, T: ?Sized> From<O> for OwningRef<O, T>\n-where\n-    O: StableAddress,\n-    O: Deref<Target = T>,\n-{\n-    fn from(owner: O) -> Self {\n-        OwningRef::new(owner)\n-    }\n-}\n-\n-impl<O, T: ?Sized> From<O> for OwningRefMut<O, T>\n-where\n-    O: StableAddress,\n-    O: DerefMut<Target = T>,\n-{\n-    fn from(owner: O) -> Self {\n-        OwningRefMut::new(owner)\n-    }\n-}\n-\n-impl<O, T: ?Sized> From<OwningRefMut<O, T>> for OwningRef<O, T>\n-where\n-    O: StableAddress,\n-    O: DerefMut<Target = T>,\n-{\n-    fn from(other: OwningRefMut<O, T>) -> Self {\n-        OwningRef { owner: other.owner, reference: other.reference }\n-    }\n-}\n-\n-// ^ FIXME: Is an Into impl for calling into_inner() possible as well?\n-\n-impl<O, T: ?Sized> Debug for OwningRef<O, T>\n-where\n-    O: Debug,\n-    T: Debug,\n-{\n-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        write!(f, \"OwningRef {{ owner: {:?}, reference: {:?} }}\", self.owner(), &**self)\n-    }\n-}\n-\n-impl<O, T: ?Sized> Debug for OwningRefMut<O, T>\n-where\n-    O: Debug,\n-    T: Debug,\n-{\n-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        write!(f, \"OwningRefMut {{ owner: {:?}, reference: {:?} }}\", self.owner(), &**self)\n-    }\n-}\n-\n-impl<O, T: ?Sized> Clone for OwningRef<O, T>\n-where\n-    O: CloneStableAddress,\n-{\n-    fn clone(&self) -> Self {\n-        OwningRef { owner: self.owner.clone(), reference: self.reference }\n-    }\n-}\n-\n-unsafe impl<O, T: ?Sized> CloneStableAddress for OwningRef<O, T> where O: CloneStableAddress {}\n-\n-unsafe impl<O, T: ?Sized> Send for OwningRef<O, T>\n-where\n-    O: Send,\n-    for<'a> &'a T: Send,\n-{\n-}\n-unsafe impl<O, T: ?Sized> Sync for OwningRef<O, T>\n-where\n-    O: Sync,\n-    for<'a> &'a T: Sync,\n-{\n-}\n-\n-unsafe impl<O, T: ?Sized> Send for OwningRefMut<O, T>\n-where\n-    O: Send,\n-    for<'a> &'a mut T: Send,\n-{\n-}\n-unsafe impl<O, T: ?Sized> Sync for OwningRefMut<O, T>\n-where\n-    O: Sync,\n-    for<'a> &'a mut T: Sync,\n-{\n-}\n-\n-impl Debug for dyn Erased {\n-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        write!(f, \"<Erased>\",)\n-    }\n-}\n-\n-impl<O, T: ?Sized> PartialEq for OwningRef<O, T>\n-where\n-    T: PartialEq,\n-{\n-    fn eq(&self, other: &Self) -> bool {\n-        self.deref().eq(other.deref())\n-    }\n-}\n-\n-impl<O, T: ?Sized> Eq for OwningRef<O, T> where T: Eq {}\n-\n-impl<O, T: ?Sized> PartialOrd for OwningRef<O, T>\n-where\n-    T: PartialOrd,\n-{\n-    fn partial_cmp(&self, other: &Self) -> Option<Ordering> {\n-        self.deref().partial_cmp(other.deref())\n-    }\n-}\n-\n-impl<O, T: ?Sized> Ord for OwningRef<O, T>\n-where\n-    T: Ord,\n-{\n-    fn cmp(&self, other: &Self) -> Ordering {\n-        self.deref().cmp(other.deref())\n-    }\n-}\n-\n-impl<O, T: ?Sized> Hash for OwningRef<O, T>\n-where\n-    T: Hash,\n-{\n-    fn hash<H: Hasher>(&self, state: &mut H) {\n-        self.deref().hash(state);\n-    }\n-}\n-\n-impl<O, T: ?Sized> PartialEq for OwningRefMut<O, T>\n-where\n-    T: PartialEq,\n-{\n-    fn eq(&self, other: &Self) -> bool {\n-        self.deref().eq(other.deref())\n-    }\n-}\n-\n-impl<O, T: ?Sized> Eq for OwningRefMut<O, T> where T: Eq {}\n-\n-impl<O, T: ?Sized> PartialOrd for OwningRefMut<O, T>\n-where\n-    T: PartialOrd,\n-{\n-    fn partial_cmp(&self, other: &Self) -> Option<Ordering> {\n-        self.deref().partial_cmp(other.deref())\n-    }\n-}\n-\n-impl<O, T: ?Sized> Ord for OwningRefMut<O, T>\n-where\n-    T: Ord,\n-{\n-    fn cmp(&self, other: &Self) -> Ordering {\n-        self.deref().cmp(other.deref())\n-    }\n-}\n-\n-impl<O, T: ?Sized> Hash for OwningRefMut<O, T>\n-where\n-    T: Hash,\n-{\n-    fn hash<H: Hasher>(&self, state: &mut H) {\n-        self.deref().hash(state);\n-    }\n-}\n-\n-/////////////////////////////////////////////////////////////////////////////\n-// std types integration and convenience type defs\n-/////////////////////////////////////////////////////////////////////////////\n-\n-use std::cell::{Ref, RefCell, RefMut};\n-use std::rc::Rc;\n-use std::sync::Arc;\n-use std::sync::{MutexGuard, RwLockReadGuard, RwLockWriteGuard};\n-\n-impl<T: 'static> ToHandle for RefCell<T> {\n-    type Handle = Ref<'static, T>;\n-    unsafe fn to_handle(x: *const Self) -> Self::Handle {\n-        (*x).borrow()\n-    }\n-}\n-\n-impl<T: 'static> ToHandleMut for RefCell<T> {\n-    type HandleMut = RefMut<'static, T>;\n-    unsafe fn to_handle_mut(x: *const Self) -> Self::HandleMut {\n-        (*x).borrow_mut()\n-    }\n-}\n-\n-// N.B., implementing ToHandle{,Mut} for Mutex and RwLock requires a decision\n-// about which handle creation to use (i.e., read() vs try_read()) as well as\n-// what to do with error results.\n-\n-/// Typedef of an owning reference that uses a `Box` as the owner.\n-pub type BoxRef<T, U = T> = OwningRef<Box<T>, U>;\n-/// Typedef of an owning reference that uses a `Vec` as the owner.\n-pub type VecRef<T, U = T> = OwningRef<Vec<T>, U>;\n-/// Typedef of an owning reference that uses a `String` as the owner.\n-pub type StringRef = OwningRef<String, str>;\n-\n-/// Typedef of an owning reference that uses an `Rc` as the owner.\n-pub type RcRef<T, U = T> = OwningRef<Rc<T>, U>;\n-/// Typedef of an owning reference that uses an `Arc` as the owner.\n-pub type ArcRef<T, U = T> = OwningRef<Arc<T>, U>;\n-\n-/// Typedef of an owning reference that uses a `Ref` as the owner.\n-pub type RefRef<'a, T, U = T> = OwningRef<Ref<'a, T>, U>;\n-/// Typedef of an owning reference that uses a `RefMut` as the owner.\n-pub type RefMutRef<'a, T, U = T> = OwningRef<RefMut<'a, T>, U>;\n-/// Typedef of an owning reference that uses a `MutexGuard` as the owner.\n-pub type MutexGuardRef<'a, T, U = T> = OwningRef<MutexGuard<'a, T>, U>;\n-/// Typedef of an owning reference that uses an `RwLockReadGuard` as the owner.\n-pub type RwLockReadGuardRef<'a, T, U = T> = OwningRef<RwLockReadGuard<'a, T>, U>;\n-/// Typedef of an owning reference that uses an `RwLockWriteGuard` as the owner.\n-pub type RwLockWriteGuardRef<'a, T, U = T> = OwningRef<RwLockWriteGuard<'a, T>, U>;\n-\n-/// Typedef of a mutable owning reference that uses a `Box` as the owner.\n-pub type BoxRefMut<T, U = T> = OwningRefMut<Box<T>, U>;\n-/// Typedef of a mutable owning reference that uses a `Vec` as the owner.\n-pub type VecRefMut<T, U = T> = OwningRefMut<Vec<T>, U>;\n-/// Typedef of a mutable owning reference that uses a `String` as the owner.\n-pub type StringRefMut = OwningRefMut<String, str>;\n-\n-/// Typedef of a mutable owning reference that uses a `RefMut` as the owner.\n-pub type RefMutRefMut<'a, T, U = T> = OwningRefMut<RefMut<'a, T>, U>;\n-/// Typedef of a mutable owning reference that uses a `MutexGuard` as the owner.\n-pub type MutexGuardRefMut<'a, T, U = T> = OwningRefMut<MutexGuard<'a, T>, U>;\n-/// Typedef of a mutable owning reference that uses an `RwLockWriteGuard` as the owner.\n-pub type RwLockWriteGuardRefMut<'a, T, U = T> = OwningRef<RwLockWriteGuard<'a, T>, U>;\n-\n-unsafe impl<'a, T: 'a> IntoErased<'a> for Box<T> {\n-    type Erased = Box<dyn Erased + 'a>;\n-    fn into_erased(self) -> Self::Erased {\n-        self\n-    }\n-}\n-unsafe impl<'a, T: 'a> IntoErased<'a> for Rc<T> {\n-    type Erased = Rc<dyn Erased + 'a>;\n-    fn into_erased(self) -> Self::Erased {\n-        self\n-    }\n-}\n-unsafe impl<'a, T: 'a> IntoErased<'a> for Arc<T> {\n-    type Erased = Arc<dyn Erased + 'a>;\n-    fn into_erased(self) -> Self::Erased {\n-        self\n-    }\n-}\n-\n-unsafe impl<'a, T: Send + 'a> IntoErasedSend<'a> for Box<T> {\n-    type Erased = Box<dyn Erased + Send + 'a>;\n-    fn into_erased_send(self) -> Self::Erased {\n-        self\n-    }\n-}\n-\n-unsafe impl<'a, T: Send + 'a> IntoErasedSendSync<'a> for Box<T> {\n-    type Erased = Box<dyn Erased + Sync + Send + 'a>;\n-    fn into_erased_send_sync(self) -> Self::Erased {\n-        let result: Box<dyn Erased + Send + 'a> = self;\n-        // This is safe since Erased can always implement Sync\n-        // Only the destructor is available and it takes &mut self\n-        unsafe { mem::transmute(result) }\n-    }\n-}\n-\n-unsafe impl<'a, T: Send + Sync + 'a> IntoErasedSendSync<'a> for Arc<T> {\n-    type Erased = Arc<dyn Erased + Send + Sync + 'a>;\n-    fn into_erased_send_sync(self) -> Self::Erased {\n-        self\n-    }\n-}\n-\n-/// Typedef of an owning reference that uses an erased `Box` as the owner.\n-pub type ErasedBoxRef<U> = OwningRef<Box<dyn Erased>, U>;\n-/// Typedef of an owning reference that uses an erased `Rc` as the owner.\n-pub type ErasedRcRef<U> = OwningRef<Rc<dyn Erased>, U>;\n-/// Typedef of an owning reference that uses an erased `Arc` as the owner.\n-pub type ErasedArcRef<U> = OwningRef<Arc<dyn Erased>, U>;\n-\n-/// Typedef of a mutable owning reference that uses an erased `Box` as the owner.\n-pub type ErasedBoxRefMut<U> = OwningRefMut<Box<dyn Erased>, U>;\n-\n-#[cfg(test)]\n-mod tests;"}, {"sha": "a9b187c4ce0a79f979ae4c562ebe56ab598c40bb", "filename": "compiler/rustc_data_structures/src/owning_ref/tests.rs", "status": "removed", "additions": 0, "deletions": 711, "changes": 711, "blob_url": "https://github.com/rust-lang/rust/blob/0bb6d66251dae171bac858874be87d714004cc16/compiler%2Frustc_data_structures%2Fsrc%2Fowning_ref%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0bb6d66251dae171bac858874be87d714004cc16/compiler%2Frustc_data_structures%2Fsrc%2Fowning_ref%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_data_structures%2Fsrc%2Fowning_ref%2Ftests.rs?ref=0bb6d66251dae171bac858874be87d714004cc16", "patch": "@@ -1,711 +0,0 @@\n-// FIXME: owning_ref is not sound under stacked borrows. Preferably, get rid of it.\n-#[cfg(not(miri))]\n-mod owning_ref {\n-    use super::super::OwningRef;\n-    use super::super::{BoxRef, Erased, ErasedBoxRef, RcRef};\n-    use std::cmp::Ordering;\n-    use std::collections::hash_map::DefaultHasher;\n-    use std::collections::HashMap;\n-    use std::hash::{Hash, Hasher};\n-    use std::rc::Rc;\n-\n-    #[derive(Debug, PartialEq)]\n-    struct Example(u32, String, [u8; 3]);\n-    fn example() -> Example {\n-        Example(42, \"hello world\".to_string(), [1, 2, 3])\n-    }\n-\n-    #[test]\n-    fn new_deref() {\n-        let or: OwningRef<Box<()>, ()> = OwningRef::new(Box::new(()));\n-        assert_eq!(&*or, &());\n-    }\n-\n-    #[test]\n-    fn into() {\n-        let or: OwningRef<Box<()>, ()> = Box::new(()).into();\n-        assert_eq!(&*or, &());\n-    }\n-\n-    #[test]\n-    fn map_offset_ref() {\n-        let or: BoxRef<Example> = Box::new(example()).into();\n-        let or: BoxRef<_, u32> = or.map(|x| &x.0);\n-        assert_eq!(&*or, &42);\n-\n-        let or: BoxRef<Example> = Box::new(example()).into();\n-        let or: BoxRef<_, u8> = or.map(|x| &x.2[1]);\n-        assert_eq!(&*or, &2);\n-    }\n-\n-    #[test]\n-    fn map_heap_ref() {\n-        let or: BoxRef<Example> = Box::new(example()).into();\n-        let or: BoxRef<_, str> = or.map(|x| &x.1[..5]);\n-        assert_eq!(&*or, \"hello\");\n-    }\n-\n-    #[test]\n-    fn map_static_ref() {\n-        let or: BoxRef<()> = Box::new(()).into();\n-        let or: BoxRef<_, str> = or.map(|_| \"hello\");\n-        assert_eq!(&*or, \"hello\");\n-    }\n-\n-    #[test]\n-    fn map_chained() {\n-        let or: BoxRef<String> = Box::new(example().1).into();\n-        let or: BoxRef<_, str> = or.map(|x| &x[1..5]);\n-        let or: BoxRef<_, str> = or.map(|x| &x[..2]);\n-        assert_eq!(&*or, \"el\");\n-    }\n-\n-    #[test]\n-    fn map_chained_inference() {\n-        let or = BoxRef::new(Box::new(example().1)).map(|x| &x[..5]).map(|x| &x[1..3]);\n-        assert_eq!(&*or, \"el\");\n-    }\n-\n-    #[test]\n-    fn owner() {\n-        let or: BoxRef<String> = Box::new(example().1).into();\n-        let or = or.map(|x| &x[..5]);\n-        assert_eq!(&*or, \"hello\");\n-        assert_eq!(&**or.owner(), \"hello world\");\n-    }\n-\n-    #[test]\n-    fn into_inner() {\n-        let or: BoxRef<String> = Box::new(example().1).into();\n-        let or = or.map(|x| &x[..5]);\n-        assert_eq!(&*or, \"hello\");\n-        let s = *or.into_inner();\n-        assert_eq!(&s, \"hello world\");\n-    }\n-\n-    #[test]\n-    fn fmt_debug() {\n-        let or: BoxRef<String> = Box::new(example().1).into();\n-        let or = or.map(|x| &x[..5]);\n-        let s = format!(\"{:?}\", or);\n-        assert_eq!(&s, \"OwningRef { owner: \\\"hello world\\\", reference: \\\"hello\\\" }\");\n-    }\n-\n-    #[test]\n-    fn erased_owner() {\n-        let o1: BoxRef<Example, str> = BoxRef::new(Box::new(example())).map(|x| &x.1[..]);\n-\n-        let o2: BoxRef<String, str> = BoxRef::new(Box::new(example().1)).map(|x| &x[..]);\n-\n-        let os: Vec<ErasedBoxRef<str>> = vec![o1.erase_owner(), o2.erase_owner()];\n-        assert!(os.iter().all(|e| &e[..] == \"hello world\"));\n-    }\n-\n-    #[test]\n-    fn raii_locks() {\n-        use super::super::{MutexGuardRef, RwLockReadGuardRef, RwLockWriteGuardRef};\n-        use super::super::{RefMutRef, RefRef};\n-        use std::cell::RefCell;\n-        use std::sync::{Mutex, RwLock};\n-\n-        {\n-            let a = RefCell::new(1);\n-            let a = {\n-                let a = RefRef::new(a.borrow());\n-                assert_eq!(*a, 1);\n-                a\n-            };\n-            assert_eq!(*a, 1);\n-            drop(a);\n-        }\n-        {\n-            let a = RefCell::new(1);\n-            let a = {\n-                let a = RefMutRef::new(a.borrow_mut());\n-                assert_eq!(*a, 1);\n-                a\n-            };\n-            assert_eq!(*a, 1);\n-            drop(a);\n-        }\n-        {\n-            let a = Mutex::new(1);\n-            let a = {\n-                let a = MutexGuardRef::new(a.lock().unwrap());\n-                assert_eq!(*a, 1);\n-                a\n-            };\n-            assert_eq!(*a, 1);\n-            drop(a);\n-        }\n-        {\n-            let a = RwLock::new(1);\n-            let a = {\n-                let a = RwLockReadGuardRef::new(a.read().unwrap());\n-                assert_eq!(*a, 1);\n-                a\n-            };\n-            assert_eq!(*a, 1);\n-            drop(a);\n-        }\n-        {\n-            let a = RwLock::new(1);\n-            let a = {\n-                let a = RwLockWriteGuardRef::new(a.write().unwrap());\n-                assert_eq!(*a, 1);\n-                a\n-            };\n-            assert_eq!(*a, 1);\n-            drop(a);\n-        }\n-    }\n-\n-    #[test]\n-    fn eq() {\n-        let or1: BoxRef<[u8]> = BoxRef::new(vec![1, 2, 3].into_boxed_slice());\n-        let or2: BoxRef<[u8]> = BoxRef::new(vec![1, 2, 3].into_boxed_slice());\n-        assert_eq!(or1.eq(&or2), true);\n-    }\n-\n-    #[test]\n-    fn cmp() {\n-        let or1: BoxRef<[u8]> = BoxRef::new(vec![1, 2, 3].into_boxed_slice());\n-        let or2: BoxRef<[u8]> = BoxRef::new(vec![4, 5, 6].into_boxed_slice());\n-        assert_eq!(or1.cmp(&or2), Ordering::Less);\n-    }\n-\n-    #[test]\n-    fn partial_cmp() {\n-        let or1: BoxRef<[u8]> = BoxRef::new(vec![4, 5, 6].into_boxed_slice());\n-        let or2: BoxRef<[u8]> = BoxRef::new(vec![1, 2, 3].into_boxed_slice());\n-        assert_eq!(or1.partial_cmp(&or2), Some(Ordering::Greater));\n-    }\n-\n-    #[test]\n-    fn hash() {\n-        let mut h1 = DefaultHasher::new();\n-        let mut h2 = DefaultHasher::new();\n-\n-        let or1: BoxRef<[u8]> = BoxRef::new(vec![1, 2, 3].into_boxed_slice());\n-        let or2: BoxRef<[u8]> = BoxRef::new(vec![1, 2, 3].into_boxed_slice());\n-\n-        or1.hash(&mut h1);\n-        or2.hash(&mut h2);\n-\n-        assert_eq!(h1.finish(), h2.finish());\n-    }\n-\n-    #[test]\n-    fn borrow() {\n-        let mut hash = HashMap::new();\n-        let key = RcRef::<String>::new(Rc::new(\"foo-bar\".to_string())).map(|s| &s[..]);\n-\n-        hash.insert(key.clone().map(|s| &s[..3]), 42);\n-        hash.insert(key.clone().map(|s| &s[4..]), 23);\n-\n-        assert_eq!(hash.get(\"foo\"), Some(&42));\n-        assert_eq!(hash.get(\"bar\"), Some(&23));\n-    }\n-\n-    #[test]\n-    fn total_erase() {\n-        let a: OwningRef<Vec<u8>, [u8]> = OwningRef::new(vec![]).map(|x| &x[..]);\n-        let b: OwningRef<Box<[u8]>, [u8]> =\n-            OwningRef::new(vec![].into_boxed_slice()).map(|x| &x[..]);\n-\n-        let c: OwningRef<Rc<Vec<u8>>, [u8]> = unsafe { a.map_owner(Rc::new) };\n-        let d: OwningRef<Rc<Box<[u8]>>, [u8]> = unsafe { b.map_owner(Rc::new) };\n-\n-        let e: OwningRef<Rc<dyn Erased>, [u8]> = c.erase_owner();\n-        let f: OwningRef<Rc<dyn Erased>, [u8]> = d.erase_owner();\n-\n-        let _g = e.clone();\n-        let _h = f.clone();\n-    }\n-\n-    #[test]\n-    fn total_erase_box() {\n-        let a: OwningRef<Vec<u8>, [u8]> = OwningRef::new(vec![]).map(|x| &x[..]);\n-        let b: OwningRef<Box<[u8]>, [u8]> =\n-            OwningRef::new(vec![].into_boxed_slice()).map(|x| &x[..]);\n-\n-        let c: OwningRef<Box<Vec<u8>>, [u8]> = a.map_owner_box();\n-        let d: OwningRef<Box<Box<[u8]>>, [u8]> = b.map_owner_box();\n-\n-        let _e: OwningRef<Box<dyn Erased>, [u8]> = c.erase_owner();\n-        let _f: OwningRef<Box<dyn Erased>, [u8]> = d.erase_owner();\n-    }\n-\n-    #[test]\n-    fn try_map1() {\n-        use std::any::Any;\n-\n-        let x = Box::new(123_i32);\n-        let y: Box<dyn Any> = x;\n-\n-        assert!(OwningRef::new(y).try_map(|x| x.downcast_ref::<i32>().ok_or(())).is_ok());\n-    }\n-\n-    #[test]\n-    fn try_map2() {\n-        use std::any::Any;\n-\n-        let x = Box::new(123_i32);\n-        let y: Box<dyn Any> = x;\n-\n-        assert!(!OwningRef::new(y).try_map(|x| x.downcast_ref::<i32>().ok_or(())).is_err());\n-    }\n-}\n-\n-mod owning_handle {\n-    use super::super::OwningHandle;\n-    use super::super::RcRef;\n-    use std::cell::RefCell;\n-    use std::rc::Rc;\n-    use std::sync::Arc;\n-    use std::sync::RwLock;\n-\n-    #[test]\n-    fn owning_handle() {\n-        use std::cell::RefCell;\n-        let cell = Rc::new(RefCell::new(2));\n-        let cell_ref = RcRef::new(cell);\n-        let mut handle =\n-            OwningHandle::new_with_fn(cell_ref, |x| unsafe { x.as_ref() }.unwrap().borrow_mut());\n-        assert_eq!(*handle, 2);\n-        *handle = 3;\n-        assert_eq!(*handle, 3);\n-    }\n-\n-    #[test]\n-    fn try_owning_handle_ok() {\n-        use std::cell::RefCell;\n-        let cell = Rc::new(RefCell::new(2));\n-        let cell_ref = RcRef::new(cell);\n-        let mut handle = OwningHandle::try_new::<_, ()>(cell_ref, |x| {\n-            Ok(unsafe { x.as_ref() }.unwrap().borrow_mut())\n-        })\n-        .unwrap();\n-        assert_eq!(*handle, 2);\n-        *handle = 3;\n-        assert_eq!(*handle, 3);\n-    }\n-\n-    #[test]\n-    fn try_owning_handle_err() {\n-        use std::cell::RefCell;\n-        let cell = Rc::new(RefCell::new(2));\n-        let cell_ref = RcRef::new(cell);\n-        let handle = OwningHandle::try_new::<_, ()>(cell_ref, |x| {\n-            if false {\n-                return Ok(unsafe { x.as_ref() }.unwrap().borrow_mut());\n-            }\n-            Err(())\n-        });\n-        assert!(handle.is_err());\n-    }\n-\n-    #[test]\n-    fn nested() {\n-        use std::cell::RefCell;\n-        use std::sync::{Arc, RwLock};\n-\n-        let result = {\n-            let complex = Rc::new(RefCell::new(Arc::new(RwLock::new(\"someString\"))));\n-            let curr = RcRef::new(complex);\n-            let curr =\n-                OwningHandle::new_with_fn(curr, |x| unsafe { x.as_ref() }.unwrap().borrow_mut());\n-            let mut curr = OwningHandle::new_with_fn(curr, |x| {\n-                unsafe { x.as_ref() }.unwrap().try_write().unwrap()\n-            });\n-            assert_eq!(*curr, \"someString\");\n-            *curr = \"someOtherString\";\n-            curr\n-        };\n-        assert_eq!(*result, \"someOtherString\");\n-    }\n-\n-    #[test]\n-    fn owning_handle_safe() {\n-        use std::cell::RefCell;\n-        let cell = Rc::new(RefCell::new(2));\n-        let cell_ref = RcRef::new(cell);\n-        let handle = OwningHandle::new(cell_ref);\n-        assert_eq!(*handle, 2);\n-    }\n-\n-    #[test]\n-    fn owning_handle_mut_safe() {\n-        use std::cell::RefCell;\n-        let cell = Rc::new(RefCell::new(2));\n-        let cell_ref = RcRef::new(cell);\n-        let mut handle = OwningHandle::new_mut(cell_ref);\n-        assert_eq!(*handle, 2);\n-        *handle = 3;\n-        assert_eq!(*handle, 3);\n-    }\n-\n-    #[test]\n-    fn owning_handle_safe_2() {\n-        let result = {\n-            let complex = Rc::new(RefCell::new(Arc::new(RwLock::new(\"someString\"))));\n-            let curr = RcRef::new(complex);\n-            let curr =\n-                OwningHandle::new_with_fn(curr, |x| unsafe { x.as_ref() }.unwrap().borrow_mut());\n-            let mut curr = OwningHandle::new_with_fn(curr, |x| {\n-                unsafe { x.as_ref() }.unwrap().try_write().unwrap()\n-            });\n-            assert_eq!(*curr, \"someString\");\n-            *curr = \"someOtherString\";\n-            curr\n-        };\n-        assert_eq!(*result, \"someOtherString\");\n-    }\n-}\n-\n-// FIXME: owning_ref is not sound under stacked borrows. Preferably, get rid of it.\n-#[cfg(not(miri))]\n-mod owning_ref_mut {\n-    use super::super::BoxRef;\n-    use super::super::{BoxRefMut, Erased, ErasedBoxRefMut, OwningRefMut};\n-    use std::cmp::Ordering;\n-    use std::collections::hash_map::DefaultHasher;\n-    use std::collections::HashMap;\n-    use std::hash::{Hash, Hasher};\n-\n-    #[derive(Debug, PartialEq)]\n-    struct Example(u32, String, [u8; 3]);\n-    fn example() -> Example {\n-        Example(42, \"hello world\".to_string(), [1, 2, 3])\n-    }\n-\n-    #[test]\n-    fn new_deref() {\n-        let or: OwningRefMut<Box<()>, ()> = OwningRefMut::new(Box::new(()));\n-        assert_eq!(&*or, &());\n-    }\n-\n-    #[test]\n-    fn new_deref_mut() {\n-        let mut or: OwningRefMut<Box<()>, ()> = OwningRefMut::new(Box::new(()));\n-        assert_eq!(&mut *or, &mut ());\n-    }\n-\n-    #[test]\n-    fn mutate() {\n-        let mut or: OwningRefMut<Box<usize>, usize> = OwningRefMut::new(Box::new(0));\n-        assert_eq!(&*or, &0);\n-        *or = 1;\n-        assert_eq!(&*or, &1);\n-    }\n-\n-    #[test]\n-    fn into() {\n-        let or: OwningRefMut<Box<()>, ()> = Box::new(()).into();\n-        assert_eq!(&*or, &());\n-    }\n-\n-    #[test]\n-    fn map_offset_ref() {\n-        let or: BoxRefMut<Example> = Box::new(example()).into();\n-        let or: BoxRef<_, u32> = or.map(|x| &mut x.0);\n-        assert_eq!(&*or, &42);\n-\n-        let or: BoxRefMut<Example> = Box::new(example()).into();\n-        let or: BoxRef<_, u8> = or.map(|x| &mut x.2[1]);\n-        assert_eq!(&*or, &2);\n-    }\n-\n-    #[test]\n-    fn map_heap_ref() {\n-        let or: BoxRefMut<Example> = Box::new(example()).into();\n-        let or: BoxRef<_, str> = or.map(|x| &mut x.1[..5]);\n-        assert_eq!(&*or, \"hello\");\n-    }\n-\n-    #[test]\n-    fn map_static_ref() {\n-        let or: BoxRefMut<()> = Box::new(()).into();\n-        let or: BoxRef<_, str> = or.map(|_| \"hello\");\n-        assert_eq!(&*or, \"hello\");\n-    }\n-\n-    #[test]\n-    fn map_mut_offset_ref() {\n-        let or: BoxRefMut<Example> = Box::new(example()).into();\n-        let or: BoxRefMut<_, u32> = or.map_mut(|x| &mut x.0);\n-        assert_eq!(&*or, &42);\n-\n-        let or: BoxRefMut<Example> = Box::new(example()).into();\n-        let or: BoxRefMut<_, u8> = or.map_mut(|x| &mut x.2[1]);\n-        assert_eq!(&*or, &2);\n-    }\n-\n-    #[test]\n-    fn map_mut_heap_ref() {\n-        let or: BoxRefMut<Example> = Box::new(example()).into();\n-        let or: BoxRefMut<_, str> = or.map_mut(|x| &mut x.1[..5]);\n-        assert_eq!(&*or, \"hello\");\n-    }\n-\n-    #[test]\n-    fn map_mut_static_ref() {\n-        static mut MUT_S: [u8; 5] = *b\"hello\";\n-\n-        let mut_s: &'static mut [u8] = unsafe { &mut MUT_S };\n-\n-        let or: BoxRefMut<()> = Box::new(()).into();\n-        let or: BoxRefMut<_, [u8]> = or.map_mut(move |_| mut_s);\n-        assert_eq!(&*or, b\"hello\");\n-    }\n-\n-    #[test]\n-    fn map_mut_chained() {\n-        let or: BoxRefMut<String> = Box::new(example().1).into();\n-        let or: BoxRefMut<_, str> = or.map_mut(|x| &mut x[1..5]);\n-        let or: BoxRefMut<_, str> = or.map_mut(|x| &mut x[..2]);\n-        assert_eq!(&*or, \"el\");\n-    }\n-\n-    #[test]\n-    fn map_chained_inference() {\n-        let or = BoxRefMut::new(Box::new(example().1))\n-            .map_mut(|x| &mut x[..5])\n-            .map_mut(|x| &mut x[1..3]);\n-        assert_eq!(&*or, \"el\");\n-    }\n-\n-    #[test]\n-    fn try_map_mut() {\n-        let or: BoxRefMut<String> = Box::new(example().1).into();\n-        let or: Result<BoxRefMut<_, str>, ()> = or.try_map_mut(|x| Ok(&mut x[1..5]));\n-        assert_eq!(&*or.unwrap(), \"ello\");\n-\n-        let or: BoxRefMut<String> = Box::new(example().1).into();\n-        let or: Result<BoxRefMut<_, str>, ()> = or.try_map_mut(|_| Err(()));\n-        assert!(or.is_err());\n-    }\n-\n-    #[test]\n-    fn owner() {\n-        let or: BoxRefMut<String> = Box::new(example().1).into();\n-        let or = or.map_mut(|x| &mut x[..5]);\n-        assert_eq!(&*or, \"hello\");\n-        assert_eq!(&**or.owner(), \"hello world\");\n-    }\n-\n-    #[test]\n-    fn into_inner() {\n-        let or: BoxRefMut<String> = Box::new(example().1).into();\n-        let or = or.map_mut(|x| &mut x[..5]);\n-        assert_eq!(&*or, \"hello\");\n-        let s = *or.into_inner();\n-        assert_eq!(&s, \"hello world\");\n-    }\n-\n-    #[test]\n-    fn fmt_debug() {\n-        let or: BoxRefMut<String> = Box::new(example().1).into();\n-        let or = or.map_mut(|x| &mut x[..5]);\n-        let s = format!(\"{:?}\", or);\n-        assert_eq!(&s, \"OwningRefMut { owner: \\\"hello world\\\", reference: \\\"hello\\\" }\");\n-    }\n-\n-    #[test]\n-    fn erased_owner() {\n-        let o1: BoxRefMut<Example, str> =\n-            BoxRefMut::new(Box::new(example())).map_mut(|x| &mut x.1[..]);\n-\n-        let o2: BoxRefMut<String, str> =\n-            BoxRefMut::new(Box::new(example().1)).map_mut(|x| &mut x[..]);\n-\n-        let os: Vec<ErasedBoxRefMut<str>> = vec![o1.erase_owner(), o2.erase_owner()];\n-        assert!(os.iter().all(|e| &e[..] == \"hello world\"));\n-    }\n-\n-    #[test]\n-    fn raii_locks() {\n-        use super::super::RefMutRefMut;\n-        use super::super::{MutexGuardRefMut, RwLockWriteGuardRefMut};\n-        use std::cell::RefCell;\n-        use std::sync::{Mutex, RwLock};\n-\n-        {\n-            let a = RefCell::new(1);\n-            let a = {\n-                let a = RefMutRefMut::new(a.borrow_mut());\n-                assert_eq!(*a, 1);\n-                a\n-            };\n-            assert_eq!(*a, 1);\n-            drop(a);\n-        }\n-        {\n-            let a = Mutex::new(1);\n-            let a = {\n-                let a = MutexGuardRefMut::new(a.lock().unwrap());\n-                assert_eq!(*a, 1);\n-                a\n-            };\n-            assert_eq!(*a, 1);\n-            drop(a);\n-        }\n-        {\n-            let a = RwLock::new(1);\n-            let a = {\n-                let a = RwLockWriteGuardRefMut::new(a.write().unwrap());\n-                assert_eq!(*a, 1);\n-                a\n-            };\n-            assert_eq!(*a, 1);\n-            drop(a);\n-        }\n-    }\n-\n-    #[test]\n-    fn eq() {\n-        let or1: BoxRefMut<[u8]> = BoxRefMut::new(vec![1, 2, 3].into_boxed_slice());\n-        let or2: BoxRefMut<[u8]> = BoxRefMut::new(vec![1, 2, 3].into_boxed_slice());\n-        assert_eq!(or1.eq(&or2), true);\n-    }\n-\n-    #[test]\n-    fn cmp() {\n-        let or1: BoxRefMut<[u8]> = BoxRefMut::new(vec![1, 2, 3].into_boxed_slice());\n-        let or2: BoxRefMut<[u8]> = BoxRefMut::new(vec![4, 5, 6].into_boxed_slice());\n-        assert_eq!(or1.cmp(&or2), Ordering::Less);\n-    }\n-\n-    #[test]\n-    fn partial_cmp() {\n-        let or1: BoxRefMut<[u8]> = BoxRefMut::new(vec![4, 5, 6].into_boxed_slice());\n-        let or2: BoxRefMut<[u8]> = BoxRefMut::new(vec![1, 2, 3].into_boxed_slice());\n-        assert_eq!(or1.partial_cmp(&or2), Some(Ordering::Greater));\n-    }\n-\n-    #[test]\n-    fn hash() {\n-        let mut h1 = DefaultHasher::new();\n-        let mut h2 = DefaultHasher::new();\n-\n-        let or1: BoxRefMut<[u8]> = BoxRefMut::new(vec![1, 2, 3].into_boxed_slice());\n-        let or2: BoxRefMut<[u8]> = BoxRefMut::new(vec![1, 2, 3].into_boxed_slice());\n-\n-        or1.hash(&mut h1);\n-        or2.hash(&mut h2);\n-\n-        assert_eq!(h1.finish(), h2.finish());\n-    }\n-\n-    #[test]\n-    fn borrow() {\n-        let mut hash = HashMap::new();\n-        let key1 = BoxRefMut::<String>::new(Box::new(\"foo\".to_string())).map(|s| &s[..]);\n-        let key2 = BoxRefMut::<String>::new(Box::new(\"bar\".to_string())).map(|s| &s[..]);\n-\n-        hash.insert(key1, 42);\n-        hash.insert(key2, 23);\n-\n-        assert_eq!(hash.get(\"foo\"), Some(&42));\n-        assert_eq!(hash.get(\"bar\"), Some(&23));\n-    }\n-\n-    #[test]\n-    fn total_erase() {\n-        let a: OwningRefMut<Vec<u8>, [u8]> = OwningRefMut::new(vec![]).map_mut(|x| &mut x[..]);\n-        let b: OwningRefMut<Box<[u8]>, [u8]> =\n-            OwningRefMut::new(vec![].into_boxed_slice()).map_mut(|x| &mut x[..]);\n-\n-        let c: OwningRefMut<Box<Vec<u8>>, [u8]> = unsafe { a.map_owner(Box::new) };\n-        let d: OwningRefMut<Box<Box<[u8]>>, [u8]> = unsafe { b.map_owner(Box::new) };\n-\n-        let _e: OwningRefMut<Box<dyn Erased>, [u8]> = c.erase_owner();\n-        let _f: OwningRefMut<Box<dyn Erased>, [u8]> = d.erase_owner();\n-    }\n-\n-    #[test]\n-    fn total_erase_box() {\n-        let a: OwningRefMut<Vec<u8>, [u8]> = OwningRefMut::new(vec![]).map_mut(|x| &mut x[..]);\n-        let b: OwningRefMut<Box<[u8]>, [u8]> =\n-            OwningRefMut::new(vec![].into_boxed_slice()).map_mut(|x| &mut x[..]);\n-\n-        let c: OwningRefMut<Box<Vec<u8>>, [u8]> = a.map_owner_box();\n-        let d: OwningRefMut<Box<Box<[u8]>>, [u8]> = b.map_owner_box();\n-\n-        let _e: OwningRefMut<Box<dyn Erased>, [u8]> = c.erase_owner();\n-        let _f: OwningRefMut<Box<dyn Erased>, [u8]> = d.erase_owner();\n-    }\n-\n-    #[test]\n-    fn try_map1() {\n-        use std::any::Any;\n-\n-        let x = Box::new(123_i32);\n-        let y: Box<dyn Any> = x;\n-\n-        assert!(OwningRefMut::new(y).try_map_mut(|x| x.downcast_mut::<i32>().ok_or(())).is_ok());\n-    }\n-\n-    #[test]\n-    fn try_map2() {\n-        use std::any::Any;\n-\n-        let x = Box::new(123_i32);\n-        let y: Box<dyn Any> = x;\n-\n-        assert!(!OwningRefMut::new(y).try_map_mut(|x| x.downcast_mut::<i32>().ok_or(())).is_err());\n-    }\n-\n-    #[test]\n-    fn try_map3() {\n-        use std::any::Any;\n-\n-        let x = Box::new(123_i32);\n-        let y: Box<dyn Any> = x;\n-\n-        assert!(OwningRefMut::new(y).try_map(|x| x.downcast_ref::<i32>().ok_or(())).is_ok());\n-    }\n-\n-    #[test]\n-    fn try_map4() {\n-        use std::any::Any;\n-\n-        let x = Box::new(123_i32);\n-        let y: Box<dyn Any> = x;\n-\n-        assert!(!OwningRefMut::new(y).try_map(|x| x.downcast_ref::<i32>().ok_or(())).is_err());\n-    }\n-\n-    #[test]\n-    fn into_owning_ref() {\n-        use super::super::BoxRef;\n-\n-        let or: BoxRefMut<()> = Box::new(()).into();\n-        let or: BoxRef<()> = or.into();\n-        assert_eq!(&*or, &());\n-    }\n-\n-    struct Foo {\n-        u: u32,\n-    }\n-    struct Bar {\n-        f: Foo,\n-    }\n-\n-    #[test]\n-    fn ref_mut() {\n-        use std::cell::RefCell;\n-\n-        let a = RefCell::new(Bar { f: Foo { u: 42 } });\n-        let mut b = OwningRefMut::new(a.borrow_mut());\n-        assert_eq!(b.f.u, 42);\n-        b.f.u = 43;\n-        let mut c = b.map_mut(|x| &mut x.f);\n-        assert_eq!(c.u, 43);\n-        c.u = 44;\n-        let mut d = c.map_mut(|x| &mut x.u);\n-        assert_eq!(*d, 44);\n-        *d = 45;\n-        assert_eq!(*d, 45);\n-    }\n-}"}, {"sha": "1ed584eafad307f7d2f121d30b9dccf23dd4c952", "filename": "compiler/rustc_data_structures/src/profiling.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6efdf4d1309f8047bc439a4810888c715e2df480/compiler%2Frustc_data_structures%2Fsrc%2Fprofiling.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6efdf4d1309f8047bc439a4810888c715e2df480/compiler%2Frustc_data_structures%2Fsrc%2Fprofiling.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_data_structures%2Fsrc%2Fprofiling.rs?ref=6efdf4d1309f8047bc439a4810888c715e2df480", "patch": "@@ -778,7 +778,7 @@ pub fn print_time_passes_entry(\n                 \"rss_start\": start_rss,\n                 \"rss_end\": end_rss,\n             });\n-            eprintln!(\"time: {}\", json.to_string());\n+            eprintln!(\"time: {json}\");\n             return;\n         }\n         TimePassesFormat::Text => (),"}, {"sha": "bd7a86f67800f8d81b306ed3d100fcb8b7ba9fd8", "filename": "compiler/rustc_data_structures/src/sharded.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/6efdf4d1309f8047bc439a4810888c715e2df480/compiler%2Frustc_data_structures%2Fsrc%2Fsharded.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6efdf4d1309f8047bc439a4810888c715e2df480/compiler%2Frustc_data_structures%2Fsrc%2Fsharded.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_data_structures%2Fsrc%2Fsharded.rs?ref=6efdf4d1309f8047bc439a4810888c715e2df480", "patch": "@@ -140,6 +140,7 @@ pub fn make_hash<K: Hash + ?Sized>(val: &K) -> u64 {\n /// `hash` can be computed with any hasher, so long as that hasher is used\n /// consistently for each `Sharded` instance.\n #[inline]\n+#[allow(clippy::modulo_one)]\n pub fn get_shard_index_by_hash(hash: u64) -> usize {\n     let hash_len = mem::size_of::<usize>();\n     // Ignore the top 7 bits as hashbrown uses these and get the next SHARD_BITS highest bits."}, {"sha": "d849fe0373f28740c986e34571d631e471a31683", "filename": "compiler/rustc_data_structures/src/sip128.rs", "status": "modified", "additions": 9, "deletions": 11, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/6efdf4d1309f8047bc439a4810888c715e2df480/compiler%2Frustc_data_structures%2Fsrc%2Fsip128.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6efdf4d1309f8047bc439a4810888c715e2df480/compiler%2Frustc_data_structures%2Fsrc%2Fsip128.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_data_structures%2Fsrc%2Fsip128.rs?ref=6efdf4d1309f8047bc439a4810888c715e2df480", "patch": "@@ -247,7 +247,7 @@ impl SipHasher128 {\n         for i in 0..BUFFER_CAPACITY {\n             let elem = self.buf.get_unchecked(i).assume_init().to_le();\n             self.state.v3 ^= elem;\n-            Sip24Rounds::c_rounds(&mut self.state);\n+            Sip13Rounds::c_rounds(&mut self.state);\n             self.state.v0 ^= elem;\n         }\n \n@@ -327,7 +327,7 @@ impl SipHasher128 {\n         for i in 0..last {\n             let elem = self.buf.get_unchecked(i).assume_init().to_le();\n             self.state.v3 ^= elem;\n-            Sip24Rounds::c_rounds(&mut self.state);\n+            Sip13Rounds::c_rounds(&mut self.state);\n             self.state.v0 ^= elem;\n         }\n \n@@ -340,7 +340,7 @@ impl SipHasher128 {\n         for _ in 0..elems_left {\n             let elem = (msg.as_ptr().add(processed) as *const u64).read_unaligned().to_le();\n             self.state.v3 ^= elem;\n-            Sip24Rounds::c_rounds(&mut self.state);\n+            Sip13Rounds::c_rounds(&mut self.state);\n             self.state.v0 ^= elem;\n             processed += ELEM_SIZE;\n         }\n@@ -368,7 +368,7 @@ impl SipHasher128 {\n         for i in 0..last {\n             let elem = unsafe { self.buf.get_unchecked(i).assume_init().to_le() };\n             state.v3 ^= elem;\n-            Sip24Rounds::c_rounds(&mut state);\n+            Sip13Rounds::c_rounds(&mut state);\n             state.v0 ^= elem;\n         }\n \n@@ -392,15 +392,15 @@ impl SipHasher128 {\n         let b: u64 = ((length as u64 & 0xff) << 56) | elem;\n \n         state.v3 ^= b;\n-        Sip24Rounds::c_rounds(&mut state);\n+        Sip13Rounds::c_rounds(&mut state);\n         state.v0 ^= b;\n \n         state.v2 ^= 0xee;\n-        Sip24Rounds::d_rounds(&mut state);\n+        Sip13Rounds::d_rounds(&mut state);\n         let _0 = state.v0 ^ state.v1 ^ state.v2 ^ state.v3;\n \n         state.v1 ^= 0xdd;\n-        Sip24Rounds::d_rounds(&mut state);\n+        Sip13Rounds::d_rounds(&mut state);\n         let _1 = state.v0 ^ state.v1 ^ state.v2 ^ state.v3;\n \n         (_0, _1)\n@@ -477,20 +477,18 @@ impl Hasher for SipHasher128 {\n }\n \n #[derive(Debug, Clone, Default)]\n-struct Sip24Rounds;\n+struct Sip13Rounds;\n \n-impl Sip24Rounds {\n+impl Sip13Rounds {\n     #[inline]\n     fn c_rounds(state: &mut State) {\n         compress!(state);\n-        compress!(state);\n     }\n \n     #[inline]\n     fn d_rounds(state: &mut State) {\n         compress!(state);\n         compress!(state);\n         compress!(state);\n-        compress!(state);\n     }\n }"}, {"sha": "cc6d3b0f471525430823bc7f5b776677d4ab58a7", "filename": "compiler/rustc_data_structures/src/sip128/tests.rs", "status": "modified", "additions": 66, "deletions": 259, "changes": 325, "blob_url": "https://github.com/rust-lang/rust/blob/6efdf4d1309f8047bc439a4810888c715e2df480/compiler%2Frustc_data_structures%2Fsrc%2Fsip128%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6efdf4d1309f8047bc439a4810888c715e2df480/compiler%2Frustc_data_structures%2Fsrc%2Fsip128%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_data_structures%2Fsrc%2Fsip128%2Ftests.rs?ref=6efdf4d1309f8047bc439a4810888c715e2df480", "patch": "@@ -22,269 +22,76 @@ fn hash_with<T: Hash>(mut st: SipHasher128, x: &T) -> (u64, u64) {\n fn hash<T: Hash>(x: &T) -> (u64, u64) {\n     hash_with(SipHasher128::new_with_keys(0, 0), x)\n }\n-\n+#[rustfmt::skip]\n const TEST_VECTOR: [[u8; 16]; 64] = [\n-    [\n-        0xa3, 0x81, 0x7f, 0x04, 0xba, 0x25, 0xa8, 0xe6, 0x6d, 0xf6, 0x72, 0x14, 0xc7, 0x55, 0x02,\n-        0x93,\n-    ],\n-    [\n-        0xda, 0x87, 0xc1, 0xd8, 0x6b, 0x99, 0xaf, 0x44, 0x34, 0x76, 0x59, 0x11, 0x9b, 0x22, 0xfc,\n-        0x45,\n-    ],\n-    [\n-        0x81, 0x77, 0x22, 0x8d, 0xa4, 0xa4, 0x5d, 0xc7, 0xfc, 0xa3, 0x8b, 0xde, 0xf6, 0x0a, 0xff,\n-        0xe4,\n-    ],\n-    [\n-        0x9c, 0x70, 0xb6, 0x0c, 0x52, 0x67, 0xa9, 0x4e, 0x5f, 0x33, 0xb6, 0xb0, 0x29, 0x85, 0xed,\n-        0x51,\n-    ],\n-    [\n-        0xf8, 0x81, 0x64, 0xc1, 0x2d, 0x9c, 0x8f, 0xaf, 0x7d, 0x0f, 0x6e, 0x7c, 0x7b, 0xcd, 0x55,\n-        0x79,\n-    ],\n-    [\n-        0x13, 0x68, 0x87, 0x59, 0x80, 0x77, 0x6f, 0x88, 0x54, 0x52, 0x7a, 0x07, 0x69, 0x0e, 0x96,\n-        0x27,\n-    ],\n-    [\n-        0x14, 0xee, 0xca, 0x33, 0x8b, 0x20, 0x86, 0x13, 0x48, 0x5e, 0xa0, 0x30, 0x8f, 0xd7, 0xa1,\n-        0x5e,\n-    ],\n-    [\n-        0xa1, 0xf1, 0xeb, 0xbe, 0xd8, 0xdb, 0xc1, 0x53, 0xc0, 0xb8, 0x4a, 0xa6, 0x1f, 0xf0, 0x82,\n-        0x39,\n-    ],\n-    [\n-        0x3b, 0x62, 0xa9, 0xba, 0x62, 0x58, 0xf5, 0x61, 0x0f, 0x83, 0xe2, 0x64, 0xf3, 0x14, 0x97,\n-        0xb4,\n-    ],\n-    [\n-        0x26, 0x44, 0x99, 0x06, 0x0a, 0xd9, 0xba, 0xab, 0xc4, 0x7f, 0x8b, 0x02, 0xbb, 0x6d, 0x71,\n-        0xed,\n-    ],\n-    [\n-        0x00, 0x11, 0x0d, 0xc3, 0x78, 0x14, 0x69, 0x56, 0xc9, 0x54, 0x47, 0xd3, 0xf3, 0xd0, 0xfb,\n-        0xba,\n-    ],\n-    [\n-        0x01, 0x51, 0xc5, 0x68, 0x38, 0x6b, 0x66, 0x77, 0xa2, 0xb4, 0xdc, 0x6f, 0x81, 0xe5, 0xdc,\n-        0x18,\n-    ],\n-    [\n-        0xd6, 0x26, 0xb2, 0x66, 0x90, 0x5e, 0xf3, 0x58, 0x82, 0x63, 0x4d, 0xf6, 0x85, 0x32, 0xc1,\n-        0x25,\n-    ],\n-    [\n-        0x98, 0x69, 0xe2, 0x47, 0xe9, 0xc0, 0x8b, 0x10, 0xd0, 0x29, 0x93, 0x4f, 0xc4, 0xb9, 0x52,\n-        0xf7,\n-    ],\n-    [\n-        0x31, 0xfc, 0xef, 0xac, 0x66, 0xd7, 0xde, 0x9c, 0x7e, 0xc7, 0x48, 0x5f, 0xe4, 0x49, 0x49,\n-        0x02,\n-    ],\n-    [\n-        0x54, 0x93, 0xe9, 0x99, 0x33, 0xb0, 0xa8, 0x11, 0x7e, 0x08, 0xec, 0x0f, 0x97, 0xcf, 0xc3,\n-        0xd9,\n-    ],\n-    [\n-        0x6e, 0xe2, 0xa4, 0xca, 0x67, 0xb0, 0x54, 0xbb, 0xfd, 0x33, 0x15, 0xbf, 0x85, 0x23, 0x05,\n-        0x77,\n-    ],\n-    [\n-        0x47, 0x3d, 0x06, 0xe8, 0x73, 0x8d, 0xb8, 0x98, 0x54, 0xc0, 0x66, 0xc4, 0x7a, 0xe4, 0x77,\n-        0x40,\n-    ],\n-    [\n-        0xa4, 0x26, 0xe5, 0xe4, 0x23, 0xbf, 0x48, 0x85, 0x29, 0x4d, 0xa4, 0x81, 0xfe, 0xae, 0xf7,\n-        0x23,\n-    ],\n-    [\n-        0x78, 0x01, 0x77, 0x31, 0xcf, 0x65, 0xfa, 0xb0, 0x74, 0xd5, 0x20, 0x89, 0x52, 0x51, 0x2e,\n-        0xb1,\n-    ],\n-    [\n-        0x9e, 0x25, 0xfc, 0x83, 0x3f, 0x22, 0x90, 0x73, 0x3e, 0x93, 0x44, 0xa5, 0xe8, 0x38, 0x39,\n-        0xeb,\n-    ],\n-    [\n-        0x56, 0x8e, 0x49, 0x5a, 0xbe, 0x52, 0x5a, 0x21, 0x8a, 0x22, 0x14, 0xcd, 0x3e, 0x07, 0x1d,\n-        0x12,\n-    ],\n-    [\n-        0x4a, 0x29, 0xb5, 0x45, 0x52, 0xd1, 0x6b, 0x9a, 0x46, 0x9c, 0x10, 0x52, 0x8e, 0xff, 0x0a,\n-        0xae,\n-    ],\n-    [\n-        0xc9, 0xd1, 0x84, 0xdd, 0xd5, 0xa9, 0xf5, 0xe0, 0xcf, 0x8c, 0xe2, 0x9a, 0x9a, 0xbf, 0x69,\n-        0x1c,\n-    ],\n-    [\n-        0x2d, 0xb4, 0x79, 0xae, 0x78, 0xbd, 0x50, 0xd8, 0x88, 0x2a, 0x8a, 0x17, 0x8a, 0x61, 0x32,\n-        0xad,\n-    ],\n-    [\n-        0x8e, 0xce, 0x5f, 0x04, 0x2d, 0x5e, 0x44, 0x7b, 0x50, 0x51, 0xb9, 0xea, 0xcb, 0x8d, 0x8f,\n-        0x6f,\n-    ],\n-    [\n-        0x9c, 0x0b, 0x53, 0xb4, 0xb3, 0xc3, 0x07, 0xe8, 0x7e, 0xae, 0xe0, 0x86, 0x78, 0x14, 0x1f,\n-        0x66,\n-    ],\n-    [\n-        0xab, 0xf2, 0x48, 0xaf, 0x69, 0xa6, 0xea, 0xe4, 0xbf, 0xd3, 0xeb, 0x2f, 0x12, 0x9e, 0xeb,\n-        0x94,\n-    ],\n-    [\n-        0x06, 0x64, 0xda, 0x16, 0x68, 0x57, 0x4b, 0x88, 0xb9, 0x35, 0xf3, 0x02, 0x73, 0x58, 0xae,\n-        0xf4,\n-    ],\n-    [\n-        0xaa, 0x4b, 0x9d, 0xc4, 0xbf, 0x33, 0x7d, 0xe9, 0x0c, 0xd4, 0xfd, 0x3c, 0x46, 0x7c, 0x6a,\n-        0xb7,\n-    ],\n-    [\n-        0xea, 0x5c, 0x7f, 0x47, 0x1f, 0xaf, 0x6b, 0xde, 0x2b, 0x1a, 0xd7, 0xd4, 0x68, 0x6d, 0x22,\n-        0x87,\n-    ],\n-    [\n-        0x29, 0x39, 0xb0, 0x18, 0x32, 0x23, 0xfa, 0xfc, 0x17, 0x23, 0xde, 0x4f, 0x52, 0xc4, 0x3d,\n-        0x35,\n-    ],\n-    [\n-        0x7c, 0x39, 0x56, 0xca, 0x5e, 0xea, 0xfc, 0x3e, 0x36, 0x3e, 0x9d, 0x55, 0x65, 0x46, 0xeb,\n-        0x68,\n-    ],\n-    [\n-        0x77, 0xc6, 0x07, 0x71, 0x46, 0xf0, 0x1c, 0x32, 0xb6, 0xb6, 0x9d, 0x5f, 0x4e, 0xa9, 0xff,\n-        0xcf,\n-    ],\n-    [\n-        0x37, 0xa6, 0x98, 0x6c, 0xb8, 0x84, 0x7e, 0xdf, 0x09, 0x25, 0xf0, 0xf1, 0x30, 0x9b, 0x54,\n-        0xde,\n-    ],\n-    [\n-        0xa7, 0x05, 0xf0, 0xe6, 0x9d, 0xa9, 0xa8, 0xf9, 0x07, 0x24, 0x1a, 0x2e, 0x92, 0x3c, 0x8c,\n-        0xc8,\n-    ],\n-    [\n-        0x3d, 0xc4, 0x7d, 0x1f, 0x29, 0xc4, 0x48, 0x46, 0x1e, 0x9e, 0x76, 0xed, 0x90, 0x4f, 0x67,\n-        0x11,\n-    ],\n-    [\n-        0x0d, 0x62, 0xbf, 0x01, 0xe6, 0xfc, 0x0e, 0x1a, 0x0d, 0x3c, 0x47, 0x51, 0xc5, 0xd3, 0x69,\n-        0x2b,\n-    ],\n-    [\n-        0x8c, 0x03, 0x46, 0x8b, 0xca, 0x7c, 0x66, 0x9e, 0xe4, 0xfd, 0x5e, 0x08, 0x4b, 0xbe, 0xe7,\n-        0xb5,\n-    ],\n-    [\n-        0x52, 0x8a, 0x5b, 0xb9, 0x3b, 0xaf, 0x2c, 0x9c, 0x44, 0x73, 0xcc, 0xe5, 0xd0, 0xd2, 0x2b,\n-        0xd9,\n-    ],\n-    [\n-        0xdf, 0x6a, 0x30, 0x1e, 0x95, 0xc9, 0x5d, 0xad, 0x97, 0xae, 0x0c, 0xc8, 0xc6, 0x91, 0x3b,\n-        0xd8,\n-    ],\n-    [\n-        0x80, 0x11, 0x89, 0x90, 0x2c, 0x85, 0x7f, 0x39, 0xe7, 0x35, 0x91, 0x28, 0x5e, 0x70, 0xb6,\n-        0xdb,\n-    ],\n-    [\n-        0xe6, 0x17, 0x34, 0x6a, 0xc9, 0xc2, 0x31, 0xbb, 0x36, 0x50, 0xae, 0x34, 0xcc, 0xca, 0x0c,\n-        0x5b,\n-    ],\n-    [\n-        0x27, 0xd9, 0x34, 0x37, 0xef, 0xb7, 0x21, 0xaa, 0x40, 0x18, 0x21, 0xdc, 0xec, 0x5a, 0xdf,\n-        0x89,\n-    ],\n-    [\n-        0x89, 0x23, 0x7d, 0x9d, 0xed, 0x9c, 0x5e, 0x78, 0xd8, 0xb1, 0xc9, 0xb1, 0x66, 0xcc, 0x73,\n-        0x42,\n-    ],\n-    [\n-        0x4a, 0x6d, 0x80, 0x91, 0xbf, 0x5e, 0x7d, 0x65, 0x11, 0x89, 0xfa, 0x94, 0xa2, 0x50, 0xb1,\n-        0x4c,\n-    ],\n-    [\n-        0x0e, 0x33, 0xf9, 0x60, 0x55, 0xe7, 0xae, 0x89, 0x3f, 0xfc, 0x0e, 0x3d, 0xcf, 0x49, 0x29,\n-        0x02,\n-    ],\n-    [\n-        0xe6, 0x1c, 0x43, 0x2b, 0x72, 0x0b, 0x19, 0xd1, 0x8e, 0xc8, 0xd8, 0x4b, 0xdc, 0x63, 0x15,\n-        0x1b,\n-    ],\n-    [\n-        0xf7, 0xe5, 0xae, 0xf5, 0x49, 0xf7, 0x82, 0xcf, 0x37, 0x90, 0x55, 0xa6, 0x08, 0x26, 0x9b,\n-        0x16,\n-    ],\n-    [\n-        0x43, 0x8d, 0x03, 0x0f, 0xd0, 0xb7, 0xa5, 0x4f, 0xa8, 0x37, 0xf2, 0xad, 0x20, 0x1a, 0x64,\n-        0x03,\n-    ],\n-    [\n-        0xa5, 0x90, 0xd3, 0xee, 0x4f, 0xbf, 0x04, 0xe3, 0x24, 0x7e, 0x0d, 0x27, 0xf2, 0x86, 0x42,\n-        0x3f,\n-    ],\n-    [\n-        0x5f, 0xe2, 0xc1, 0xa1, 0x72, 0xfe, 0x93, 0xc4, 0xb1, 0x5c, 0xd3, 0x7c, 0xae, 0xf9, 0xf5,\n-        0x38,\n-    ],\n-    [\n-        0x2c, 0x97, 0x32, 0x5c, 0xbd, 0x06, 0xb3, 0x6e, 0xb2, 0x13, 0x3d, 0xd0, 0x8b, 0x3a, 0x01,\n-        0x7c,\n-    ],\n-    [\n-        0x92, 0xc8, 0x14, 0x22, 0x7a, 0x6b, 0xca, 0x94, 0x9f, 0xf0, 0x65, 0x9f, 0x00, 0x2a, 0xd3,\n-        0x9e,\n-    ],\n-    [\n-        0xdc, 0xe8, 0x50, 0x11, 0x0b, 0xd8, 0x32, 0x8c, 0xfb, 0xd5, 0x08, 0x41, 0xd6, 0x91, 0x1d,\n-        0x87,\n-    ],\n-    [\n-        0x67, 0xf1, 0x49, 0x84, 0xc7, 0xda, 0x79, 0x12, 0x48, 0xe3, 0x2b, 0xb5, 0x92, 0x25, 0x83,\n-        0xda,\n-    ],\n-    [\n-        0x19, 0x38, 0xf2, 0xcf, 0x72, 0xd5, 0x4e, 0xe9, 0x7e, 0x94, 0x16, 0x6f, 0xa9, 0x1d, 0x2a,\n-        0x36,\n-    ],\n-    [\n-        0x74, 0x48, 0x1e, 0x96, 0x46, 0xed, 0x49, 0xfe, 0x0f, 0x62, 0x24, 0x30, 0x16, 0x04, 0x69,\n-        0x8e,\n-    ],\n-    [\n-        0x57, 0xfc, 0xa5, 0xde, 0x98, 0xa9, 0xd6, 0xd8, 0x00, 0x64, 0x38, 0xd0, 0x58, 0x3d, 0x8a,\n-        0x1d,\n-    ],\n-    [\n-        0x9f, 0xec, 0xde, 0x1c, 0xef, 0xdc, 0x1c, 0xbe, 0xd4, 0x76, 0x36, 0x74, 0xd9, 0x57, 0x53,\n-        0x59,\n-    ],\n-    [\n-        0xe3, 0x04, 0x0c, 0x00, 0xeb, 0x28, 0xf1, 0x53, 0x66, 0xca, 0x73, 0xcb, 0xd8, 0x72, 0xe7,\n-        0x40,\n-    ],\n-    [\n-        0x76, 0x97, 0x00, 0x9a, 0x6a, 0x83, 0x1d, 0xfe, 0xcc, 0xa9, 0x1c, 0x59, 0x93, 0x67, 0x0f,\n-        0x7a,\n-    ],\n-    [\n-        0x58, 0x53, 0x54, 0x23, 0x21, 0xf5, 0x67, 0xa0, 0x05, 0xd5, 0x47, 0xa4, 0xf0, 0x47, 0x59,\n-        0xbd,\n-    ],\n-    [\n-        0x51, 0x50, 0xd1, 0x77, 0x2f, 0x50, 0x83, 0x4a, 0x50, 0x3e, 0x06, 0x9a, 0x97, 0x3f, 0xbd,\n-        0x7c,\n-    ],\n+    [0xe7, 0x7e, 0xbc, 0xb2, 0x27, 0x88, 0xa5, 0xbe, 0xfd, 0x62, 0xdb, 0x6a, 0xdd, 0x30, 0x30, 0x01],\n+    [0xfc, 0x6f, 0x37, 0x04, 0x60, 0xd3, 0xed, 0xa8, 0x5e, 0x05, 0x73, 0xcc, 0x2b, 0x2f, 0xf0, 0x63],\n+    [0x75, 0x78, 0x7f, 0x09, 0x05, 0x69, 0x83, 0x9b, 0x85, 0x5b, 0xc9, 0x54, 0x8c, 0x6a, 0xea, 0x95],\n+    [0x6b, 0xc5, 0xcc, 0xfa, 0x1e, 0xdc, 0xf7, 0x9f, 0x48, 0x23, 0x18, 0x77, 0x12, 0xeb, 0xd7, 0x43],\n+    [0x0c, 0x78, 0x4e, 0x71, 0xac, 0x2b, 0x28, 0x5a, 0x9f, 0x8e, 0x92, 0xe7, 0x8f, 0xbf, 0x2c, 0x25],\n+    [0xf3, 0x28, 0xdb, 0x89, 0x34, 0x5b, 0x62, 0x0c, 0x79, 0x52, 0x29, 0xa4, 0x26, 0x95, 0x84, 0x3e],\n+    [0xdc, 0xd0, 0x3d, 0x29, 0xf7, 0x43, 0xe7, 0x10, 0x09, 0x51, 0xb0, 0xe8, 0x39, 0x85, 0xa6, 0xf8],\n+    [0x10, 0x84, 0xb9, 0x23, 0xf2, 0xaa, 0xe0, 0xc3, 0xa6, 0x2f, 0x2e, 0xc8, 0x08, 0x48, 0xab, 0x77],\n+    [0xaa, 0x12, 0xfe, 0xe1, 0xd5, 0xe3, 0xda, 0xb4, 0x72, 0x4f, 0x16, 0xab, 0x35, 0xf9, 0xc7, 0x99],\n+    [0x81, 0xdd, 0xb8, 0x04, 0x2c, 0xf3, 0x39, 0x94, 0xf4, 0x72, 0x0e, 0x00, 0x94, 0x13, 0x7c, 0x42],\n+    [0x4f, 0xaa, 0x54, 0x1d, 0x5d, 0x49, 0x8e, 0x89, 0xba, 0x0e, 0xa4, 0xc3, 0x87, 0xb2, 0x2f, 0xb4],\n+    [0x72, 0x3b, 0x9a, 0xf3, 0x55, 0x44, 0x91, 0xdb, 0xb1, 0xd6, 0x63, 0x3d, 0xfc, 0x6e, 0x0c, 0x4e],\n+    [0xe5, 0x3f, 0x92, 0x85, 0x9e, 0x48, 0x19, 0xa8, 0xdc, 0x06, 0x95, 0x73, 0x9f, 0xea, 0x8c, 0x65],\n+    [0xb2, 0xf8, 0x58, 0xc7, 0xc9, 0xea, 0x80, 0x1d, 0x53, 0xd6, 0x03, 0x59, 0x6d, 0x65, 0x78, 0x44],\n+    [0x87, 0xe7, 0x62, 0x68, 0xdb, 0xc9, 0x22, 0x72, 0x26, 0xb0, 0xca, 0x66, 0x5f, 0x64, 0xe3, 0x78],\n+    [0xc1, 0x7e, 0x55, 0x05, 0xb2, 0xbd, 0x52, 0x6c, 0x29, 0x21, 0xcd, 0xec, 0x1e, 0x7e, 0x01, 0x09],\n+    [0xd0, 0xa8, 0xd9, 0x57, 0x15, 0x51, 0x8e, 0xeb, 0xb5, 0x13, 0xb0, 0xf8, 0x3d, 0x9e, 0x17, 0x93],\n+    [0x23, 0x41, 0x26, 0xf9, 0x3f, 0xbb, 0x66, 0x8d, 0x97, 0x51, 0x12, 0xe8, 0xfe, 0xbd, 0xf7, 0xec],\n+    [0xef, 0x42, 0xf0, 0x3d, 0xb7, 0x8f, 0x70, 0x4d, 0x02, 0x3c, 0x44, 0x9f, 0x16, 0xb7, 0x09, 0x2b],\n+    [0xab, 0xf7, 0x62, 0x38, 0xc2, 0x0a, 0xf1, 0x61, 0xb2, 0x31, 0x4b, 0x4d, 0x55, 0x26, 0xbc, 0xe9],\n+    [0x3c, 0x2c, 0x2f, 0x11, 0xbb, 0x90, 0xcf, 0x0b, 0xe3, 0x35, 0xca, 0x9b, 0x2e, 0x91, 0xe9, 0xb7],\n+    [0x2a, 0x7a, 0x68, 0x0f, 0x22, 0xa0, 0x2a, 0x92, 0xf4, 0x51, 0x49, 0xd2, 0x0f, 0xec, 0xe0, 0xef],\n+    [0xc9, 0xa8, 0xd1, 0x30, 0x23, 0x1d, 0xd4, 0x3e, 0x42, 0xe6, 0x45, 0x69, 0x57, 0xf8, 0x37, 0x79],\n+    [0x1d, 0x12, 0x7b, 0x84, 0x40, 0x5c, 0xea, 0xb9, 0x9f, 0xd8, 0x77, 0x5a, 0x9b, 0xe6, 0xc5, 0x59],\n+    [0x9e, 0x4b, 0xf8, 0x37, 0xbc, 0xfd, 0x92, 0xca, 0xce, 0x09, 0xd2, 0x06, 0x1a, 0x84, 0xd0, 0x4a],\n+    [0x39, 0x03, 0x1a, 0x96, 0x5d, 0x73, 0xb4, 0xaf, 0x5a, 0x27, 0x4d, 0x18, 0xf9, 0x73, 0xb1, 0xd2],\n+    [0x7f, 0x4d, 0x0a, 0x12, 0x09, 0xd6, 0x7e, 0x4e, 0xd0, 0x6f, 0x75, 0x38, 0xe1, 0xcf, 0xad, 0x64],\n+    [0xe6, 0x1e, 0xe2, 0x40, 0xfb, 0xdc, 0xce, 0x38, 0x96, 0x9f, 0x4c, 0xd2, 0x49, 0x27, 0xdd, 0x93],\n+    [0x4c, 0x3b, 0xa2, 0xb3, 0x7b, 0x0f, 0xdd, 0x8c, 0xfa, 0x5e, 0x95, 0xc1, 0x89, 0xb2, 0x94, 0x14],\n+    [0xe0, 0x6f, 0xd4, 0xca, 0x06, 0x6f, 0xec, 0xdd, 0x54, 0x06, 0x8a, 0x5a, 0xd8, 0x89, 0x6f, 0x86],\n+    [0x5c, 0xa8, 0x4c, 0x34, 0x13, 0x9c, 0x65, 0x80, 0xa8, 0x8a, 0xf2, 0x49, 0x90, 0x72, 0x07, 0x06],\n+    [0x42, 0xea, 0x96, 0x1c, 0x5b, 0x3c, 0x85, 0x8b, 0x17, 0xc3, 0xe5, 0x50, 0xdf, 0xa7, 0x90, 0x10],\n+    [0x40, 0x6c, 0x44, 0xde, 0xe6, 0x78, 0x57, 0xb2, 0x94, 0x31, 0x60, 0xf3, 0x0c, 0x74, 0x17, 0xd3],\n+    [0xc5, 0xf5, 0x7b, 0xae, 0x13, 0x20, 0xfc, 0xf4, 0xb4, 0xe8, 0x68, 0xe7, 0x1d, 0x56, 0xc6, 0x6b],\n+    [0x04, 0xbf, 0x73, 0x7a, 0x5b, 0x67, 0x6b, 0xe7, 0xc3, 0xde, 0x05, 0x01, 0x7d, 0xf4, 0xbf, 0xf9],\n+    [0x51, 0x63, 0xc9, 0xc0, 0x3f, 0x19, 0x07, 0xea, 0x10, 0x44, 0xed, 0x5c, 0x30, 0x72, 0x7b, 0x4f],\n+    [0x37, 0xa1, 0x10, 0xf0, 0x02, 0x71, 0x8e, 0xda, 0xd2, 0x4b, 0x3f, 0x9e, 0xe4, 0x53, 0xf1, 0x40],\n+    [0xb9, 0x87, 0x7e, 0x38, 0x1a, 0xed, 0xd3, 0xda, 0x08, 0xc3, 0x3e, 0x75, 0xff, 0x23, 0xac, 0x10],\n+    [0x7c, 0x50, 0x04, 0x00, 0x5e, 0xc5, 0xda, 0x4c, 0x5a, 0xc9, 0x44, 0x0e, 0x5c, 0x72, 0x31, 0x93],\n+    [0x81, 0xb8, 0x24, 0x37, 0x83, 0xdb, 0xc6, 0x46, 0xca, 0x9d, 0x0c, 0xd8, 0x2a, 0xbd, 0xb4, 0x6c],\n+    [0x50, 0x57, 0x20, 0x54, 0x3e, 0xb9, 0xb4, 0x13, 0xd5, 0x0b, 0x3c, 0xfa, 0xd9, 0xee, 0xf9, 0x38],\n+    [0x94, 0x5f, 0x59, 0x4d, 0xe7, 0x24, 0x11, 0xe4, 0xd3, 0x35, 0xbe, 0x87, 0x44, 0x56, 0xd8, 0xf3],\n+    [0x37, 0x92, 0x3b, 0x3e, 0x37, 0x17, 0x77, 0xb2, 0x11, 0x70, 0xbf, 0x9d, 0x7e, 0x62, 0xf6, 0x02],\n+    [0x3a, 0xd4, 0xe7, 0xc8, 0x57, 0x64, 0x96, 0x46, 0x11, 0xeb, 0x0a, 0x6c, 0x4d, 0x62, 0xde, 0x56],\n+    [0xcd, 0x91, 0x39, 0x6c, 0x44, 0xaf, 0x4f, 0x51, 0x85, 0x57, 0x8d, 0x9d, 0xd9, 0x80, 0x3f, 0x0a],\n+    [0xfe, 0x28, 0x15, 0x8e, 0x72, 0x7b, 0x86, 0x8f, 0x39, 0x03, 0xc9, 0xac, 0xda, 0x64, 0xa2, 0x58],\n+    [0x40, 0xcc, 0x10, 0xb8, 0x28, 0x8c, 0xe5, 0xf0, 0xbc, 0x3a, 0xc0, 0xb6, 0x8a, 0x0e, 0xeb, 0xc8],\n+    [0x6f, 0x14, 0x90, 0xf5, 0x40, 0x69, 0x9a, 0x3c, 0xd4, 0x97, 0x44, 0x20, 0xec, 0xc9, 0x27, 0x37],\n+    [0xd5, 0x05, 0xf1, 0xb7, 0x5e, 0x1a, 0x84, 0xa6, 0x03, 0xc4, 0x35, 0x83, 0xb2, 0xed, 0x03, 0x08],\n+    [0x49, 0x15, 0x73, 0xcf, 0xd7, 0x2b, 0xb4, 0x68, 0x2b, 0x7c, 0xa5, 0x88, 0x0e, 0x1c, 0x8d, 0x6f],\n+    [0x3e, 0xd6, 0x9c, 0xfe, 0x45, 0xab, 0x40, 0x3f, 0x2f, 0xd2, 0xad, 0x95, 0x9b, 0xa2, 0x76, 0x66],\n+    [0x8b, 0xe8, 0x39, 0xef, 0x1b, 0x20, 0xb5, 0x7c, 0x83, 0xba, 0x7e, 0xb6, 0xa8, 0xc2, 0x2b, 0x6a],\n+    [0x14, 0x09, 0x18, 0x6a, 0xb4, 0x22, 0x31, 0xfe, 0xde, 0xe1, 0x81, 0x62, 0xcf, 0x1c, 0xb4, 0xca],\n+    [0x2b, 0xf3, 0xcc, 0xc2, 0x4a, 0xb6, 0x72, 0xcf, 0x15, 0x1f, 0xb8, 0xd2, 0xf3, 0xf3, 0x06, 0x9b],\n+    [0xb9, 0xb9, 0x3a, 0x28, 0x82, 0xd6, 0x02, 0x5c, 0xdb, 0x8c, 0x56, 0xfa, 0x13, 0xf7, 0x53, 0x7b],\n+    [0xd9, 0x7c, 0xca, 0x36, 0x94, 0xfb, 0x20, 0x6d, 0xb8, 0xbd, 0x1f, 0x36, 0x50, 0xc3, 0x33, 0x22],\n+    [0x94, 0xec, 0x2e, 0x19, 0xa4, 0x0b, 0xe4, 0x1a, 0xf3, 0x94, 0x0d, 0x6b, 0x30, 0xc4, 0x93, 0x84],\n+    [0x4b, 0x41, 0x60, 0x3f, 0x20, 0x9a, 0x04, 0x5b, 0xe1, 0x40, 0xa3, 0x41, 0xa3, 0xdf, 0xfe, 0x10],\n+    [0x23, 0xfb, 0xcb, 0x30, 0x9f, 0x1c, 0xf0, 0x94, 0x89, 0x07, 0x55, 0xab, 0x1b, 0x42, 0x65, 0x69],\n+    [0xe7, 0xd9, 0xb6, 0x56, 0x90, 0x91, 0x8a, 0x2b, 0x23, 0x2f, 0x2f, 0x5c, 0x12, 0xc8, 0x30, 0x0e],\n+    [0xad, 0xe8, 0x3c, 0xf7, 0xe7, 0xf3, 0x84, 0x7b, 0x36, 0xfa, 0x4b, 0x54, 0xb0, 0x0d, 0xce, 0x61],\n+    [0x06, 0x10, 0xc5, 0xf2, 0xee, 0x57, 0x1c, 0x8a, 0xc8, 0x0c, 0xbf, 0xe5, 0x38, 0xbd, 0xf1, 0xc7],\n+    [0x27, 0x1d, 0x5d, 0x00, 0xfb, 0xdb, 0x5d, 0x15, 0x5d, 0x9d, 0xce, 0xa9, 0x7c, 0xb4, 0x02, 0x18],\n+    [0x4c, 0x58, 0x00, 0xe3, 0x4e, 0xfe, 0x42, 0x6f, 0x07, 0x9f, 0x6b, 0x0a, 0xa7, 0x52, 0x60, 0xad],\n ];\n \n-// Test vector from reference implementation\n #[test]\n-fn test_siphash_2_4_test_vector() {\n+fn test_siphash_1_3_test_vector() {\n     let k0 = 0x_07_06_05_04_03_02_01_00;\n     let k1 = 0x_0f_0e_0d_0c_0b_0a_09_08;\n "}, {"sha": "3ed1de1bc3ca1ebbd712c3f847e95d5c6aca5a95", "filename": "compiler/rustc_data_structures/src/stable_hasher.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6efdf4d1309f8047bc439a4810888c715e2df480/compiler%2Frustc_data_structures%2Fsrc%2Fstable_hasher.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6efdf4d1309f8047bc439a4810888c715e2df480/compiler%2Frustc_data_structures%2Fsrc%2Fstable_hasher.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_data_structures%2Fsrc%2Fstable_hasher.rs?ref=6efdf4d1309f8047bc439a4810888c715e2df480", "patch": "@@ -312,14 +312,14 @@ impl<CTX> HashStable<CTX> for ::std::num::NonZeroUsize {\n \n impl<CTX> HashStable<CTX> for f32 {\n     fn hash_stable(&self, ctx: &mut CTX, hasher: &mut StableHasher) {\n-        let val: u32 = unsafe { ::std::mem::transmute(*self) };\n+        let val: u32 = self.to_bits();\n         val.hash_stable(ctx, hasher);\n     }\n }\n \n impl<CTX> HashStable<CTX> for f64 {\n     fn hash_stable(&self, ctx: &mut CTX, hasher: &mut StableHasher) {\n-        let val: u64 = unsafe { ::std::mem::transmute(*self) };\n+        let val: u64 = self.to_bits();\n         val.hash_stable(ctx, hasher);\n     }\n }"}, {"sha": "a98b1bc36261ce1d12646c7efae7f2c8af3990d6", "filename": "compiler/rustc_data_structures/src/stable_hasher/tests.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/6efdf4d1309f8047bc439a4810888c715e2df480/compiler%2Frustc_data_structures%2Fsrc%2Fstable_hasher%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6efdf4d1309f8047bc439a4810888c715e2df480/compiler%2Frustc_data_structures%2Fsrc%2Fstable_hasher%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_data_structures%2Fsrc%2Fstable_hasher%2Ftests.rs?ref=6efdf4d1309f8047bc439a4810888c715e2df480", "patch": "@@ -39,7 +39,7 @@ fn test_hash_integers() {\n     test_isize.hash(&mut h);\n \n     // This depends on the hashing algorithm. See note at top of file.\n-    let expected = (1784307454142909076, 11471672289340283879);\n+    let expected = (13997337031081104755, 6178945012502239489);\n \n     assert_eq!(h.finalize(), expected);\n }\n@@ -53,7 +53,7 @@ fn test_hash_usize() {\n     test_usize.hash(&mut h);\n \n     // This depends on the hashing algorithm. See note at top of file.\n-    let expected = (5798740672699530587, 11186240177685111648);\n+    let expected = (12037165114281468837, 3094087741167521712);\n \n     assert_eq!(h.finalize(), expected);\n }\n@@ -67,7 +67,7 @@ fn test_hash_isize() {\n     test_isize.hash(&mut h);\n \n     // This depends on the hashing algorithm. See note at top of file.\n-    let expected = (2789913510339652884, 674280939192711005);\n+    let expected = (3979067582695659080, 2322428596355037273);\n \n     assert_eq!(h.finalize(), expected);\n }"}, {"sha": "7ff1339c5ab34c554f9ee754f42e403fad0ed79a", "filename": "compiler/rustc_data_structures/src/stack.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6efdf4d1309f8047bc439a4810888c715e2df480/compiler%2Frustc_data_structures%2Fsrc%2Fstack.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6efdf4d1309f8047bc439a4810888c715e2df480/compiler%2Frustc_data_structures%2Fsrc%2Fstack.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_data_structures%2Fsrc%2Fstack.rs?ref=6efdf4d1309f8047bc439a4810888c715e2df480", "patch": "@@ -5,7 +5,7 @@ const RED_ZONE: usize = 100 * 1024; // 100k\n \n // Only the first stack that is pushed, grows exponentially (2^n * STACK_PER_RECURSION) from then\n // on. This flag has performance relevant characteristics. Don't set it too high.\n-const STACK_PER_RECURSION: usize = 1 * 1024 * 1024; // 1MB\n+const STACK_PER_RECURSION: usize = 1024 * 1024; // 1MB\n \n /// Grows the stack on demand to prevent stack overflow. Call this in strategic locations\n /// to \"break up\" recursive calls. E.g. almost any call to `visit_expr` or equivalent can benefit"}, {"sha": "ef1da85198fd4049c41eb3cf83e184a391a6e56f", "filename": "compiler/rustc_data_structures/src/sync.rs", "status": "modified", "additions": 16, "deletions": 35, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/6efdf4d1309f8047bc439a4810888c715e2df480/compiler%2Frustc_data_structures%2Fsrc%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6efdf4d1309f8047bc439a4810888c715e2df480/compiler%2Frustc_data_structures%2Fsrc%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_data_structures%2Fsrc%2Fsync.rs?ref=6efdf4d1309f8047bc439a4810888c715e2df480", "patch": "@@ -7,9 +7,6 @@\n //! while the serial versions degenerate straightforwardly to serial execution.\n //! The operations include `join`, `parallel`, `par_iter`, and `par_for_each`.\n //!\n-//! `rustc_erase_owner!` erases an `OwningRef` owner into `Erased` for the\n-//! serial version and `Erased + Send + Sync` for the parallel version.\n-//!\n //! Types\n //! -----\n //! The parallel versions of types provide various kinds of synchronization,\n@@ -42,7 +39,7 @@\n //!\n //! [^2] `MTLockRef` is a typedef.\n \n-use crate::owning_ref::{Erased, OwningRef};\n+use crate::owned_slice::OwnedSlice;\n use std::collections::HashMap;\n use std::hash::{BuildHasher, Hash};\n use std::ops::{Deref, DerefMut};\n@@ -51,24 +48,17 @@ use std::panic::{catch_unwind, resume_unwind, AssertUnwindSafe};\n pub use std::sync::atomic::Ordering;\n pub use std::sync::atomic::Ordering::SeqCst;\n \n-pub use vec::AppendOnlyVec;\n+pub use vec::{AppendOnlyIndexVec, AppendOnlyVec};\n \n mod vec;\n \n cfg_if! {\n     if #[cfg(not(parallel_compiler))] {\n-        pub auto trait Send {}\n-        pub auto trait Sync {}\n-\n-        impl<T> Send for T {}\n-        impl<T> Sync for T {}\n+        pub unsafe auto trait Send {}\n+        pub unsafe auto trait Sync {}\n \n-        #[macro_export]\n-        macro_rules! rustc_erase_owner {\n-            ($v:expr) => {\n-                $v.erase_owner()\n-            }\n-        }\n+        unsafe impl<T> Send for T {}\n+        unsafe impl<T> Sync for T {}\n \n         use std::ops::Add;\n \n@@ -107,6 +97,14 @@ cfg_if! {\n             }\n         }\n \n+        impl Atomic<bool> {\n+            pub fn fetch_or(&self, val: bool, _: Ordering) -> bool {\n+                let result = self.0.get() | val;\n+                self.0.set(val);\n+                result\n+            }\n+        }\n+\n         impl<T: Copy + PartialEq> Atomic<T> {\n             #[inline]\n             pub fn compare_exchange(&self,\n@@ -189,7 +187,7 @@ cfg_if! {\n             }\n         }\n \n-        pub type MetadataRef = OwningRef<Box<dyn Erased>, [u8]>;\n+        pub type MetadataRef = OwnedSlice;\n \n         pub use std::rc::Rc as Lrc;\n         pub use std::rc::Weak as Weak;\n@@ -372,20 +370,11 @@ cfg_if! {\n             });\n         }\n \n-        pub type MetadataRef = OwningRef<Box<dyn Erased + Send + Sync>, [u8]>;\n+        pub type MetadataRef = OwnedSlice;\n \n         /// This makes locks panic if they are already held.\n         /// It is only useful when you are running in a single thread\n         const ERROR_CHECKING: bool = false;\n-\n-        #[macro_export]\n-        macro_rules! rustc_erase_owner {\n-            ($v:expr) => {{\n-                let v = $v;\n-                ::rustc_data_structures::sync::assert_send_val(&v);\n-                v.erase_send_sync_owner()\n-            }}\n-        }\n     }\n }\n \n@@ -481,14 +470,6 @@ impl<T: Default> Default for Lock<T> {\n     }\n }\n \n-// FIXME: Probably a bad idea\n-impl<T: Clone> Clone for Lock<T> {\n-    #[inline]\n-    fn clone(&self) -> Self {\n-        Lock::new(self.borrow().clone())\n-    }\n-}\n-\n #[derive(Debug, Default)]\n pub struct RwLock<T>(InnerRwLock<T>);\n "}, {"sha": "1783b4b357257aa5789e2b3601e069d772d79e98", "filename": "compiler/rustc_data_structures/src/sync/vec.rs", "status": "modified", "additions": 66, "deletions": 2, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/6efdf4d1309f8047bc439a4810888c715e2df480/compiler%2Frustc_data_structures%2Fsrc%2Fsync%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6efdf4d1309f8047bc439a4810888c715e2df480/compiler%2Frustc_data_structures%2Fsrc%2Fsync%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_data_structures%2Fsrc%2Fsync%2Fvec.rs?ref=6efdf4d1309f8047bc439a4810888c715e2df480", "patch": "@@ -2,15 +2,16 @@ use std::marker::PhantomData;\n \n use rustc_index::vec::Idx;\n \n-pub struct AppendOnlyVec<I: Idx, T: Copy> {\n+#[derive(Default)]\n+pub struct AppendOnlyIndexVec<I: Idx, T: Copy> {\n     #[cfg(not(parallel_compiler))]\n     vec: elsa::vec::FrozenVec<T>,\n     #[cfg(parallel_compiler)]\n     vec: elsa::sync::LockFreeFrozenVec<T>,\n     _marker: PhantomData<fn(&I)>,\n }\n \n-impl<I: Idx, T: Copy> AppendOnlyVec<I, T> {\n+impl<I: Idx, T: Copy> AppendOnlyIndexVec<I, T> {\n     pub fn new() -> Self {\n         Self {\n             #[cfg(not(parallel_compiler))]\n@@ -39,3 +40,66 @@ impl<I: Idx, T: Copy> AppendOnlyVec<I, T> {\n         return self.vec.get(i);\n     }\n }\n+\n+#[derive(Default)]\n+pub struct AppendOnlyVec<T: Copy> {\n+    #[cfg(not(parallel_compiler))]\n+    vec: elsa::vec::FrozenVec<T>,\n+    #[cfg(parallel_compiler)]\n+    vec: elsa::sync::LockFreeFrozenVec<T>,\n+}\n+\n+impl<T: Copy> AppendOnlyVec<T> {\n+    pub fn new() -> Self {\n+        Self {\n+            #[cfg(not(parallel_compiler))]\n+            vec: elsa::vec::FrozenVec::new(),\n+            #[cfg(parallel_compiler)]\n+            vec: elsa::sync::LockFreeFrozenVec::new(),\n+        }\n+    }\n+\n+    pub fn push(&self, val: T) -> usize {\n+        #[cfg(not(parallel_compiler))]\n+        let i = self.vec.len();\n+        #[cfg(not(parallel_compiler))]\n+        self.vec.push(val);\n+        #[cfg(parallel_compiler)]\n+        let i = self.vec.push(val);\n+        i\n+    }\n+\n+    pub fn get(&self, i: usize) -> Option<T> {\n+        #[cfg(not(parallel_compiler))]\n+        return self.vec.get_copy(i);\n+        #[cfg(parallel_compiler)]\n+        return self.vec.get(i);\n+    }\n+\n+    pub fn iter_enumerated(&self) -> impl Iterator<Item = (usize, T)> + '_ {\n+        (0..)\n+            .map(|i| (i, self.get(i)))\n+            .take_while(|(_, o)| o.is_some())\n+            .filter_map(|(i, o)| Some((i, o?)))\n+    }\n+\n+    pub fn iter(&self) -> impl Iterator<Item = T> + '_ {\n+        (0..).map(|i| self.get(i)).take_while(|o| o.is_some()).flatten()\n+    }\n+}\n+\n+impl<T: Copy + PartialEq> AppendOnlyVec<T> {\n+    pub fn contains(&self, val: T) -> bool {\n+        self.iter_enumerated().any(|(_, v)| v == val)\n+    }\n+}\n+\n+impl<A: Copy> FromIterator<A> for AppendOnlyVec<A> {\n+    fn from_iter<T: IntoIterator<Item = A>>(iter: T) -> Self {\n+        let this = Self::new();\n+        for val in iter {\n+            this.push(val);\n+        }\n+        this\n+    }\n+}"}, {"sha": "6c8d541463158398178f6a9cc927c537c8cd2431", "filename": "compiler/rustc_data_structures/src/unord.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6efdf4d1309f8047bc439a4810888c715e2df480/compiler%2Frustc_data_structures%2Fsrc%2Funord.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6efdf4d1309f8047bc439a4810888c715e2df480/compiler%2Frustc_data_structures%2Fsrc%2Funord.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_data_structures%2Fsrc%2Funord.rs?ref=6efdf4d1309f8047bc439a4810888c715e2df480", "patch": "@@ -224,7 +224,7 @@ impl<V: Eq + Hash> UnordSet<V> {\n     }\n \n     #[inline]\n-    pub fn items<'a>(&'a self) -> UnordItems<&'a V, impl Iterator<Item = &'a V>> {\n+    pub fn items(&self) -> UnordItems<&V, impl Iterator<Item = &V>> {\n         UnordItems(self.inner.iter())\n     }\n \n@@ -415,7 +415,7 @@ impl<K: Eq + Hash, V> UnordMap<K, V> {\n     }\n \n     #[inline]\n-    pub fn items<'a>(&'a self) -> UnordItems<(&'a K, &'a V), impl Iterator<Item = (&'a K, &'a V)>> {\n+    pub fn items(&self) -> UnordItems<(&K, &V), impl Iterator<Item = (&K, &V)>> {\n         UnordItems(self.inner.iter())\n     }\n "}, {"sha": "730d41ab962f899838e9a974c364fa0aee832196", "filename": "compiler/rustc_driver_impl/src/lib.rs", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/6efdf4d1309f8047bc439a4810888c715e2df480/compiler%2Frustc_driver_impl%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6efdf4d1309f8047bc439a4810888c715e2df480/compiler%2Frustc_driver_impl%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_driver_impl%2Fsrc%2Flib.rs?ref=6efdf4d1309f8047bc439a4810888c715e2df480", "patch": "@@ -44,8 +44,10 @@ use rustc_session::{early_error, early_error_no_abort, early_warn};\n use rustc_span::source_map::{FileLoader, FileName};\n use rustc_span::symbol::sym;\n use rustc_target::json::ToJson;\n+use rustc_target::spec::{Target, TargetTriple};\n \n use std::cmp::max;\n+use std::collections::BTreeMap;\n use std::env;\n use std::ffi::OsString;\n use std::fs;\n@@ -648,6 +650,15 @@ fn print_crate_info(\n             TargetSpec => {\n                 println!(\"{}\", serde_json::to_string_pretty(&sess.target.to_json()).unwrap());\n             }\n+            AllTargetSpecs => {\n+                let mut targets = BTreeMap::new();\n+                for name in rustc_target::spec::TARGETS {\n+                    let triple = TargetTriple::from_triple(name);\n+                    let target = Target::expect_builtin(&triple);\n+                    targets.insert(name, target.to_json());\n+                }\n+                println!(\"{}\", serde_json::to_string_pretty(&targets).unwrap());\n+            }\n             FileNames | CrateName => {\n                 let Some(attrs) = attrs.as_ref() else {\n                     // no crate attributes, print out an error and exit"}, {"sha": "e09ef34b93dbc405ae0a0105bb42c0ff23e318ff", "filename": "compiler/rustc_errors/src/diagnostic.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6efdf4d1309f8047bc439a4810888c715e2df480/compiler%2Frustc_errors%2Fsrc%2Fdiagnostic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6efdf4d1309f8047bc439a4810888c715e2df480/compiler%2Frustc_errors%2Fsrc%2Fdiagnostic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_errors%2Fsrc%2Fdiagnostic.rs?ref=6efdf4d1309f8047bc439a4810888c715e2df480", "patch": "@@ -956,7 +956,7 @@ impl Diagnostic {\n     // Exact iteration order of diagnostic arguments shouldn't make a difference to output because\n     // they're only used in interpolation.\n     #[allow(rustc::potential_query_instability)]\n-    pub fn args<'a>(&'a self) -> impl Iterator<Item = DiagnosticArg<'a, 'static>> {\n+    pub fn args(&self) -> impl Iterator<Item = DiagnosticArg<'_, 'static>> {\n         self.args.iter()\n     }\n "}, {"sha": "81e8bcbf7cd54995dad10c325589cc7dd5a15109", "filename": "compiler/rustc_errors/src/emitter.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/6efdf4d1309f8047bc439a4810888c715e2df480/compiler%2Frustc_errors%2Fsrc%2Femitter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6efdf4d1309f8047bc439a4810888c715e2df480/compiler%2Frustc_errors%2Fsrc%2Femitter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_errors%2Fsrc%2Femitter.rs?ref=6efdf4d1309f8047bc439a4810888c715e2df480", "patch": "@@ -1407,7 +1407,7 @@ impl EmitterWriter {\n                 // Account for newlines to align output to its label.\n                 for (line, text) in normalize_whitespace(&text).lines().enumerate() {\n                     buffer.append(\n-                        0 + line,\n+                        line,\n                         &format!(\n                             \"{}{}\",\n                             if line == 0 { String::new() } else { \" \".repeat(label_width) },\n@@ -1918,7 +1918,7 @@ impl EmitterWriter {\n                         let last_line = unhighlighted_lines.pop();\n                         let first_line = unhighlighted_lines.drain(..).next();\n \n-                        first_line.map(|(p, l)| {\n+                        if let Some((p, l)) = first_line {\n                             self.draw_code_line(\n                                 &mut buffer,\n                                 &mut row_num,\n@@ -1930,12 +1930,12 @@ impl EmitterWriter {\n                                 &file_lines,\n                                 is_multiline,\n                             )\n-                        });\n+                        }\n \n                         buffer.puts(row_num, max_line_num_len - 1, \"...\", Style::LineNumber);\n                         row_num += 1;\n \n-                        last_line.map(|(p, l)| {\n+                        if let Some((p, l)) = last_line {\n                             self.draw_code_line(\n                                 &mut buffer,\n                                 &mut row_num,\n@@ -1947,7 +1947,7 @@ impl EmitterWriter {\n                                 &file_lines,\n                                 is_multiline,\n                             )\n-                        });\n+                        }\n                     }\n                 }\n "}, {"sha": "264f30fb10a124305e8fad61f49e357c757c6d86", "filename": "compiler/rustc_expand/src/build.rs", "status": "modified", "additions": 14, "deletions": 4, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/6efdf4d1309f8047bc439a4810888c715e2df480/compiler%2Frustc_expand%2Fsrc%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6efdf4d1309f8047bc439a4810888c715e2df480/compiler%2Frustc_expand%2Fsrc%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Fbuild.rs?ref=6efdf4d1309f8047bc439a4810888c715e2df480", "patch": "@@ -620,10 +620,15 @@ impl<'a> ExtCtxt<'a> {\n         span: Span,\n         name: Ident,\n         ty: P<ast::Ty>,\n-        mutbl: ast::Mutability,\n+        mutability: ast::Mutability,\n         expr: P<ast::Expr>,\n     ) -> P<ast::Item> {\n-        self.item(span, name, AttrVec::new(), ast::ItemKind::Static(ty, mutbl, Some(expr)))\n+        self.item(\n+            span,\n+            name,\n+            AttrVec::new(),\n+            ast::ItemKind::Static(ast::StaticItem { ty, mutability, expr: Some(expr) }.into()),\n+        )\n     }\n \n     pub fn item_const(\n@@ -633,8 +638,13 @@ impl<'a> ExtCtxt<'a> {\n         ty: P<ast::Ty>,\n         expr: P<ast::Expr>,\n     ) -> P<ast::Item> {\n-        let def = ast::Defaultness::Final;\n-        self.item(span, name, AttrVec::new(), ast::ItemKind::Const(def, ty, Some(expr)))\n+        let defaultness = ast::Defaultness::Final;\n+        self.item(\n+            span,\n+            name,\n+            AttrVec::new(),\n+            ast::ItemKind::Const(ast::ConstItem { defaultness, ty, expr: Some(expr) }.into()),\n+        )\n     }\n \n     // Builds `#[name]`."}, {"sha": "4ff8e409d88e3f2cb4d90dc3226557256ec23fac", "filename": "compiler/rustc_expand/src/config.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6efdf4d1309f8047bc439a4810888c715e2df480/compiler%2Frustc_expand%2Fsrc%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6efdf4d1309f8047bc439a4810888c715e2df480/compiler%2Frustc_expand%2Fsrc%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Fconfig.rs?ref=6efdf4d1309f8047bc439a4810888c715e2df480", "patch": "@@ -466,7 +466,7 @@ impl<'a> StripUnconfigured<'a> {\n         //\n         // N.B., this is intentionally not part of the visit_expr() function\n         //     in order for filter_map_expr() to be able to avoid this check\n-        if let Some(attr) = expr.attrs().iter().find(|a| is_cfg(*a)) {\n+        if let Some(attr) = expr.attrs().iter().find(|a| is_cfg(a)) {\n             self.sess.emit_err(RemoveExprNotSupported { span: attr.span });\n         }\n "}, {"sha": "fb3a00d86d4f73a45f12b3cc796aa6bb4e388d64", "filename": "compiler/rustc_expand/src/mbe/metavar_expr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6efdf4d1309f8047bc439a4810888c715e2df480/compiler%2Frustc_expand%2Fsrc%2Fmbe%2Fmetavar_expr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6efdf4d1309f8047bc439a4810888c715e2df480/compiler%2Frustc_expand%2Fsrc%2Fmbe%2Fmetavar_expr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Fmbe%2Fmetavar_expr.rs?ref=6efdf4d1309f8047bc439a4810888c715e2df480", "patch": "@@ -41,7 +41,7 @@ impl MetaVarExpr {\n         };\n         check_trailing_token(&mut tts, sess)?;\n         let mut iter = args.trees();\n-        let rslt = match &*ident.as_str() {\n+        let rslt = match ident.as_str() {\n             \"count\" => parse_count(&mut iter, sess, ident.span)?,\n             \"ignore\" => MetaVarExpr::Ignore(parse_ident(&mut iter, sess, ident.span)?),\n             \"index\" => MetaVarExpr::Index(parse_depth(&mut iter, sess, ident.span)?),"}, {"sha": "426c6727adca56ed318735abb604054e2045306e", "filename": "compiler/rustc_feature/src/active.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6efdf4d1309f8047bc439a4810888c715e2df480/compiler%2Frustc_feature%2Fsrc%2Factive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6efdf4d1309f8047bc439a4810888c715e2df480/compiler%2Frustc_feature%2Fsrc%2Factive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_feature%2Fsrc%2Factive.rs?ref=6efdf4d1309f8047bc439a4810888c715e2df480", "patch": "@@ -518,6 +518,8 @@ declare_features! (\n     /// Allows dyn upcasting trait objects via supertraits.\n     /// Dyn upcasting is casting, e.g., `dyn Foo -> dyn Bar` where `Foo: Bar`.\n     (active, trait_upcasting, \"1.56.0\", Some(65991), None),\n+    /// Allows for transmuting between arrays with sizes that contain generic consts.\n+    (active, transmute_generic_consts, \"CURRENT_RUSTC_VERSION\", Some(109929), None),\n     /// Allows #[repr(transparent)] on unions (RFC 2645).\n     (active, transparent_unions, \"1.37.0\", Some(60405), None),\n     /// Allows inconsistent bounds in where clauses."}, {"sha": "8f91a96f964aba3bb73297faaa5f23484c188c72", "filename": "compiler/rustc_hir/src/lang_items.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6efdf4d1309f8047bc439a4810888c715e2df480/compiler%2Frustc_hir%2Fsrc%2Flang_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6efdf4d1309f8047bc439a4810888c715e2df480/compiler%2Frustc_hir%2Fsrc%2Flang_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir%2Fsrc%2Flang_items.rs?ref=6efdf4d1309f8047bc439a4810888c715e2df480", "patch": "@@ -49,7 +49,7 @@ impl LanguageItems {\n         self.get(it).ok_or_else(|| LangItemError(it))\n     }\n \n-    pub fn iter<'a>(&'a self) -> impl Iterator<Item = (LangItem, DefId)> + 'a {\n+    pub fn iter(&self) -> impl Iterator<Item = (LangItem, DefId)> + '_ {\n         self.items\n             .iter()\n             .enumerate()"}, {"sha": "838c123f83c8c27b2725af903b8b6e1b9685b026", "filename": "compiler/rustc_hir/src/pat_util.rs", "status": "modified", "additions": 0, "deletions": 11, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/6efdf4d1309f8047bc439a4810888c715e2df480/compiler%2Frustc_hir%2Fsrc%2Fpat_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6efdf4d1309f8047bc439a4810888c715e2df480/compiler%2Frustc_hir%2Fsrc%2Fpat_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir%2Fsrc%2Fpat_util.rs?ref=6efdf4d1309f8047bc439a4810888c715e2df480", "patch": "@@ -2,7 +2,6 @@ use crate::def::{CtorOf, DefKind, Res};\n use crate::def_id::DefId;\n use crate::hir::{self, BindingAnnotation, ByRef, HirId, PatKind};\n use rustc_data_structures::fx::FxHashSet;\n-use rustc_span::hygiene::DesugaringKind;\n use rustc_span::symbol::Ident;\n use rustc_span::Span;\n \n@@ -136,14 +135,4 @@ impl hir::Pat<'_> {\n         });\n         result\n     }\n-\n-    /// If the pattern is `Some(<pat>)` from a desugared for loop, returns the inner pattern\n-    pub fn for_loop_some(&self) -> Option<&Self> {\n-        if self.span.desugaring_kind() == Some(DesugaringKind::ForLoop) {\n-            if let hir::PatKind::Struct(_, [pat_field], _) = self.kind {\n-                return Some(pat_field.pat);\n-            }\n-        }\n-        None\n-    }\n }"}, {"sha": "1d7965ff5f66e544361e4ebb1a6e027a936a0fc7", "filename": "compiler/rustc_hir_analysis/messages.ftl", "status": "modified", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/6efdf4d1309f8047bc439a4810888c715e2df480/compiler%2Frustc_hir_analysis%2Fmessages.ftl", "raw_url": "https://github.com/rust-lang/rust/raw/6efdf4d1309f8047bc439a4810888c715e2df480/compiler%2Frustc_hir_analysis%2Fmessages.ftl", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fmessages.ftl?ref=6efdf4d1309f8047bc439a4810888c715e2df480", "patch": "@@ -189,3 +189,39 @@ hir_analysis_return_type_notation_equality_bound =\n \n hir_analysis_return_type_notation_missing_method =\n     cannot find associated function `{$assoc_name}` in trait `{$trait_name}`\n+\n+hir_analysis_placeholder_not_allowed_item_signatures = the placeholder `_` is not allowed within types on item signatures for {$kind}\n+    .label = not allowed in type signatures\n+\n+hir_analysis_associated_type_trait_uninferred_generic_params = cannot use the associated type of a trait with uninferred generic parameters\n+    .suggestion = use a fully qualified path with inferred lifetimes\n+\n+hir_analysis_associated_type_trait_uninferred_generic_params_multipart_suggestion = use a fully qualified path with explicit lifetimes\n+\n+hir_analysis_enum_discriminant_overflowed = enum discriminant overflowed\n+    .label = overflowed on value after {$discr}\n+    .note = explicitly set `{$item_name} = {$wrapped_discr}` if that is desired outcome\n+\n+hir_analysis_paren_sugar_attribute = the `#[rustc_paren_sugar]` attribute is a temporary means of controlling which traits can use parenthetical notation\n+    .help = add `#![feature(unboxed_closures)]` to the crate attributes to use it\n+\n+hir_analysis_must_implement_one_of_attribute = the `#[rustc_must_implement_one_of]` attribute must be used with at least 2 args\n+\n+hir_analysis_must_be_name_of_associated_function = must be a name of an associated function\n+\n+hir_analysis_function_not_have_default_implementation = function doesn't have a default implementation\n+    .note = required by this annotation\n+\n+hir_analysis_must_implement_not_function = not a function\n+\n+hir_analysis_must_implement_not_function_span_note = required by this annotation\n+\n+hir_analysis_must_implement_not_function_note = all `#[rustc_must_implement_one_of]` arguments must be associated function names\n+\n+hir_analysis_function_not_found_in_trait = function not found in this trait\n+\n+hir_analysis_functions_names_duplicated = functions names are duplicated\n+    .note = all `#[rustc_must_implement_one_of]` arguments must be unique\n+\n+hir_analysis_simd_ffi_highly_experimental = use of SIMD type{$snip} in FFI is highly experimental and may result in invalid code\n+    .help = add `#![feature(simd_ffi)]` to the crate attributes to enable"}, {"sha": "acca3fa26418712eac7f02829cf2ba7fb3f0b2d8", "filename": "compiler/rustc_hir_analysis/src/astconv/mod.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/6efdf4d1309f8047bc439a4810888c715e2df480/compiler%2Frustc_hir_analysis%2Fsrc%2Fastconv%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6efdf4d1309f8047bc439a4810888c715e2df480/compiler%2Frustc_hir_analysis%2Fsrc%2Fastconv%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fastconv%2Fmod.rs?ref=6efdf4d1309f8047bc439a4810888c715e2df480", "patch": "@@ -33,9 +33,9 @@ use rustc_middle::infer::unify_key::{ConstVariableOrigin, ConstVariableOriginKin\n use rustc_middle::middle::stability::AllowUnstable;\n use rustc_middle::ty::fold::FnMutDelegate;\n use rustc_middle::ty::subst::{self, GenericArgKind, InternalSubsts, SubstsRef};\n-use rustc_middle::ty::DynKind;\n use rustc_middle::ty::GenericParamDefKind;\n use rustc_middle::ty::{self, Const, IsSuggestable, Ty, TyCtxt, TypeVisitableExt};\n+use rustc_middle::ty::{DynKind, ToPredicate};\n use rustc_session::lint::builtin::{AMBIGUOUS_ASSOCIATED_ITEMS, BARE_TRAIT_OBJECTS};\n use rustc_span::edit_distance::find_best_match_for_name;\n use rustc_span::edition::Edition;\n@@ -1526,8 +1526,8 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n \n         for (base_trait_ref, span, constness) in regular_traits_refs_spans {\n             assert_eq!(constness, ty::BoundConstness::NotConst);\n-\n-            for pred in traits::elaborate_trait_ref(tcx, base_trait_ref) {\n+            let base_pred: ty::Predicate<'tcx> = base_trait_ref.to_predicate(tcx);\n+            for pred in traits::elaborate(tcx, [base_pred]) {\n                 debug!(\"conv_object_ty_poly_trait_ref: observing object predicate `{:?}`\", pred);\n \n                 let bound_predicate = pred.kind();\n@@ -2336,10 +2336,10 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n                 FnMutDelegate {\n                     regions: &mut |_| tcx.lifetimes.re_erased,\n                     types: &mut |bv| {\n-                        tcx.mk_placeholder(ty::PlaceholderType { universe, name: bv.kind })\n+                        tcx.mk_placeholder(ty::PlaceholderType { universe, bound: bv })\n                     },\n                     consts: &mut |bv, ty| {\n-                        tcx.mk_const(ty::PlaceholderConst { universe, name: bv }, ty)\n+                        tcx.mk_const(ty::PlaceholderConst { universe, bound: bv }, ty)\n                     },\n                 },\n             );\n@@ -2525,11 +2525,11 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n                                             regions: &mut |_| tcx.lifetimes.re_erased,\n                                             types: &mut |bv| tcx.mk_placeholder(ty::PlaceholderType {\n                                                 universe,\n-                                                name: bv.kind,\n+                                                bound: bv,\n                                             }),\n                                             consts: &mut |bv, ty| tcx.mk_const(ty::PlaceholderConst {\n                                                 universe,\n-                                                name: bv\n+                                                bound: bv,\n                                             }, ty),\n                                         })\n                                     )"}, {"sha": "f6c2004c4a672073000482401c0745c3a613ad64", "filename": "compiler/rustc_hir_analysis/src/check/compare_impl_item.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6efdf4d1309f8047bc439a4810888c715e2df480/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fcompare_impl_item.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6efdf4d1309f8047bc439a4810888c715e2df480/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fcompare_impl_item.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fcompare_impl_item.rs?ref=6efdf4d1309f8047bc439a4810888c715e2df480", "patch": "@@ -2034,7 +2034,7 @@ pub(super) fn check_type_bounds<'tcx>(\n         ObligationCause::new(impl_ty_span, impl_ty_def_id, code)\n     };\n \n-    let obligations = tcx\n+    let obligations: Vec<_> = tcx\n         .bound_explicit_item_bounds(trait_ty.def_id)\n         .subst_iter_copied(tcx, rebased_substs)\n         .map(|(concrete_ty_bound, span)| {\n@@ -2044,7 +2044,7 @@ pub(super) fn check_type_bounds<'tcx>(\n         .collect();\n     debug!(\"check_type_bounds: item_bounds={:?}\", obligations);\n \n-    for mut obligation in util::elaborate_obligations(tcx, obligations) {\n+    for mut obligation in util::elaborate(tcx, obligations) {\n         let normalized_predicate =\n             ocx.normalize(&normalize_cause, normalize_param_env, obligation.predicate);\n         debug!(\"compare_projection_bounds: normalized predicate = {:?}\", normalized_predicate);"}, {"sha": "111bf5e545552ce22bd9b4b1f8d410d2ad86f35c", "filename": "compiler/rustc_hir_analysis/src/check/dropck.rs", "status": "modified", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/6efdf4d1309f8047bc439a4810888c715e2df480/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fdropck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6efdf4d1309f8047bc439a4810888c715e2df480/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fdropck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fdropck.rs?ref=6efdf4d1309f8047bc439a4810888c715e2df480", "patch": "@@ -253,10 +253,6 @@ impl<'tcx> TypeRelation<'tcx> for SimpleEqRelation<'tcx> {\n         self.tcx\n     }\n \n-    fn intercrate(&self) -> bool {\n-        false\n-    }\n-\n     fn param_env(&self) -> ty::ParamEnv<'tcx> {\n         self.param_env\n     }\n@@ -269,10 +265,6 @@ impl<'tcx> TypeRelation<'tcx> for SimpleEqRelation<'tcx> {\n         true\n     }\n \n-    fn mark_ambiguous(&mut self) {\n-        bug!()\n-    }\n-\n     fn relate_with_variance<T: Relate<'tcx>>(\n         &mut self,\n         _: ty::Variance,"}, {"sha": "854974d1605a5818f54b8674f5eaacc17f9a555a", "filename": "compiler/rustc_hir_analysis/src/check/intrinsic.rs", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/6efdf4d1309f8047bc439a4810888c715e2df480/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6efdf4d1309f8047bc439a4810888c715e2df480/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fintrinsic.rs?ref=6efdf4d1309f8047bc439a4810888c715e2df480", "patch": "@@ -139,14 +139,14 @@ pub fn check_intrinsic_type(tcx: TyCtxt<'_>, it: &hir::ForeignItem<'_>) {\n     let name_str = intrinsic_name.as_str();\n \n     let bound_vars = tcx.mk_bound_variable_kinds(&[\n-        ty::BoundVariableKind::Region(ty::BrAnon(0, None)),\n+        ty::BoundVariableKind::Region(ty::BrAnon(None)),\n         ty::BoundVariableKind::Region(ty::BrEnv),\n     ]);\n     let mk_va_list_ty = |mutbl| {\n         tcx.lang_items().va_list().map(|did| {\n             let region = tcx.mk_re_late_bound(\n                 ty::INNERMOST,\n-                ty::BoundRegion { var: ty::BoundVar::from_u32(0), kind: ty::BrAnon(0, None) },\n+                ty::BoundRegion { var: ty::BoundVar::from_u32(0), kind: ty::BrAnon(None) },\n             );\n             let env_region = tcx.mk_re_late_bound(\n                 ty::INNERMOST,\n@@ -387,8 +387,7 @@ pub fn check_intrinsic_type(tcx: TyCtxt<'_>, it: &hir::ForeignItem<'_>) {\n                 );\n                 let discriminant_def_id = assoc_items[0];\n \n-                let br =\n-                    ty::BoundRegion { var: ty::BoundVar::from_u32(0), kind: ty::BrAnon(0, None) };\n+                let br = ty::BoundRegion { var: ty::BoundVar::from_u32(0), kind: ty::BrAnon(None) };\n                 (\n                     1,\n                     vec![tcx.mk_imm_ref(tcx.mk_re_late_bound(ty::INNERMOST, br), param(0))],\n@@ -440,8 +439,7 @@ pub fn check_intrinsic_type(tcx: TyCtxt<'_>, it: &hir::ForeignItem<'_>) {\n             sym::nontemporal_store => (1, vec![tcx.mk_mut_ptr(param(0)), param(0)], tcx.mk_unit()),\n \n             sym::raw_eq => {\n-                let br =\n-                    ty::BoundRegion { var: ty::BoundVar::from_u32(0), kind: ty::BrAnon(0, None) };\n+                let br = ty::BoundRegion { var: ty::BoundVar::from_u32(0), kind: ty::BrAnon(None) };\n                 let param_ty = tcx.mk_imm_ref(tcx.mk_re_late_bound(ty::INNERMOST, br), param(0));\n                 (1, vec![param_ty; 2], tcx.types.bool)\n             }"}, {"sha": "c03621fcfb224d0447c3c37c1c71c2b402f5ba8e", "filename": "compiler/rustc_hir_analysis/src/check/wfcheck.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6efdf4d1309f8047bc439a4810888c715e2df480/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fwfcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6efdf4d1309f8047bc439a4810888c715e2df480/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fwfcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fwfcheck.rs?ref=6efdf4d1309f8047bc439a4810888c715e2df480", "patch": "@@ -1908,7 +1908,7 @@ impl<'tcx> WfCheckingCtxt<'_, 'tcx> {\n \n         let predicates_with_span = tcx.predicates_of(self.body_def_id).predicates.iter().copied();\n         // Check elaborated bounds.\n-        let implied_obligations = traits::elaborate_predicates_with_span(tcx, predicates_with_span);\n+        let implied_obligations = traits::elaborate(tcx, predicates_with_span);\n \n         for (pred, obligation_span) in implied_obligations {\n             // We lower empty bounds like `Vec<dyn Copy>:` as"}, {"sha": "ad76e2bed2023ddf1a59192d841223c9a55d8b33", "filename": "compiler/rustc_hir_analysis/src/coherence/inherent_impls_overlap.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6efdf4d1309f8047bc439a4810888c715e2df480/compiler%2Frustc_hir_analysis%2Fsrc%2Fcoherence%2Finherent_impls_overlap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6efdf4d1309f8047bc439a4810888c715e2df480/compiler%2Frustc_hir_analysis%2Fsrc%2Fcoherence%2Finherent_impls_overlap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcoherence%2Finherent_impls_overlap.rs?ref=6efdf4d1309f8047bc439a4810888c715e2df480", "patch": "@@ -302,7 +302,7 @@ impl<'tcx> InherentOverlapChecker<'tcx> {\n                         .iter()\n                         .flatten()\n                         .map(|r| r.impl_blocks.len() as isize - avg as isize)\n-                        .map(|v| v.abs() as usize)\n+                        .map(|v| v.unsigned_abs())\n                         .sum::<usize>();\n                     s / connected_regions.len()\n                 },"}, {"sha": "50862e3426238420bbe1d563c02ee13a8e924955", "filename": "compiler/rustc_hir_analysis/src/collect.rs", "status": "modified", "additions": 55, "deletions": 110, "changes": 165, "blob_url": "https://github.com/rust-lang/rust/blob/6efdf4d1309f8047bc439a4810888c715e2df480/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6efdf4d1309f8047bc439a4810888c715e2df480/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect.rs?ref=6efdf4d1309f8047bc439a4810888c715e2df480", "patch": "@@ -20,7 +20,7 @@ use crate::errors;\n use hir::def::DefKind;\n use rustc_data_structures::captures::Captures;\n use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n-use rustc_errors::{struct_span_err, Applicability, DiagnosticBuilder, ErrorGuaranteed, StashKey};\n+use rustc_errors::{Applicability, DiagnosticBuilder, ErrorGuaranteed, StashKey};\n use rustc_hir as hir;\n use rustc_hir::def_id::{DefId, LocalDefId};\n use rustc_hir::intravisit::{self, Visitor};\n@@ -333,17 +333,7 @@ fn bad_placeholder<'tcx>(\n     let kind = if kind.ends_with('s') { format!(\"{}es\", kind) } else { format!(\"{}s\", kind) };\n \n     spans.sort();\n-    let mut err = struct_span_err!(\n-        tcx.sess,\n-        spans.clone(),\n-        E0121,\n-        \"the placeholder `_` is not allowed within types on item signatures for {}\",\n-        kind\n-    );\n-    for span in spans {\n-        err.span_label(span, \"not allowed in type signatures\");\n-    }\n-    err\n+    tcx.sess.create_err(errors::PlaceholderNotAllowedItemSignatures { spans, kind })\n }\n \n impl<'tcx> ItemCtxt<'tcx> {\n@@ -419,13 +409,8 @@ impl<'tcx> AstConv<'tcx> for ItemCtxt<'tcx> {\n             self.tcx().mk_projection(item_def_id, item_substs)\n         } else {\n             // There are no late-bound regions; we can just ignore the binder.\n-            let mut err = struct_span_err!(\n-                self.tcx().sess,\n-                span,\n-                E0212,\n-                \"cannot use the associated type of a trait \\\n-                 with uninferred generic parameters\"\n-            );\n+            let (mut mpart_sugg, mut inferred_sugg) = (None, None);\n+            let mut bound = String::new();\n \n             match self.node() {\n                 hir::Node::Field(_) | hir::Node::Ctor(_) | hir::Node::Variant(_) => {\n@@ -444,31 +429,25 @@ impl<'tcx> AstConv<'tcx> for ItemCtxt<'tcx> {\n                                     (bound.span.shrink_to_lo(), format!(\"{}, \", lt_name))\n                                 }\n                             };\n-                            let suggestions = vec![\n-                                (lt_sp, sugg),\n-                                (\n-                                    span.with_hi(item_segment.ident.span.lo()),\n-                                    format!(\n-                                        \"{}::\",\n-                                        // Replace the existing lifetimes with a new named lifetime.\n-                                        self.tcx.replace_late_bound_regions_uncached(\n-                                            poly_trait_ref,\n-                                            |_| {\n-                                                self.tcx.mk_re_early_bound(ty::EarlyBoundRegion {\n-                                                    def_id: item_def_id,\n-                                                    index: 0,\n-                                                    name: Symbol::intern(&lt_name),\n-                                                })\n-                                            }\n-                                        ),\n+                            mpart_sugg = Some(errors::AssociatedTypeTraitUninferredGenericParamsMultipartSuggestion {\n+                                fspan: lt_sp,\n+                                first: sugg,\n+                                sspan: span.with_hi(item_segment.ident.span.lo()),\n+                                second: format!(\n+                                    \"{}::\",\n+                                    // Replace the existing lifetimes with a new named lifetime.\n+                                    self.tcx.replace_late_bound_regions_uncached(\n+                                        poly_trait_ref,\n+                                        |_| {\n+                                            self.tcx.mk_re_early_bound(ty::EarlyBoundRegion {\n+                                                def_id: item_def_id,\n+                                                index: 0,\n+                                                name: Symbol::intern(&lt_name),\n+                                            })\n+                                        }\n                                     ),\n                                 ),\n-                            ];\n-                            err.multipart_suggestion(\n-                                \"use a fully qualified path with explicit lifetimes\",\n-                                suggestions,\n-                                Applicability::MaybeIncorrect,\n-                            );\n+                            });\n                         }\n                         _ => {}\n                     }\n@@ -482,20 +461,23 @@ impl<'tcx> AstConv<'tcx> for ItemCtxt<'tcx> {\n                 | hir::Node::ForeignItem(_)\n                 | hir::Node::TraitItem(_)\n                 | hir::Node::ImplItem(_) => {\n-                    err.span_suggestion_verbose(\n-                        span.with_hi(item_segment.ident.span.lo()),\n-                        \"use a fully qualified path with inferred lifetimes\",\n-                        format!(\n-                            \"{}::\",\n-                            // Erase named lt, we want `<A as B<'_>::C`, not `<A as B<'a>::C`.\n-                            self.tcx.anonymize_bound_vars(poly_trait_ref).skip_binder(),\n-                        ),\n-                        Applicability::MaybeIncorrect,\n+                    inferred_sugg = Some(span.with_hi(item_segment.ident.span.lo()));\n+                    bound = format!(\n+                        \"{}::\",\n+                        // Erase named lt, we want `<A as B<'_>::C`, not `<A as B<'a>::C`.\n+                        self.tcx.anonymize_bound_vars(poly_trait_ref).skip_binder(),\n                     );\n                 }\n                 _ => {}\n             }\n-            self.tcx().ty_error(err.emit())\n+            self.tcx().ty_error(self.tcx().sess.emit_err(\n+                errors::AssociatedTypeTraitUninferredGenericParams {\n+                    span,\n+                    inferred_sugg,\n+                    bound,\n+                    mpart_sugg,\n+                },\n+            ))\n         }\n     }\n \n@@ -763,14 +745,12 @@ fn convert_enum_variant_types(tcx: TyCtxt<'_>, def_id: DefId) {\n                 Some(discr)\n             } else {\n                 let span = tcx.def_span(variant.def_id);\n-                struct_span_err!(tcx.sess, span, E0370, \"enum discriminant overflowed\")\n-                    .span_label(span, format!(\"overflowed on value after {}\", prev_discr.unwrap()))\n-                    .note(&format!(\n-                        \"explicitly set `{} = {}` if that is desired outcome\",\n-                        tcx.item_name(variant.def_id),\n-                        wrapped_discr\n-                    ))\n-                    .emit();\n+                tcx.sess.emit_err(errors::EnumDiscriminantOverflowed {\n+                    span,\n+                    discr: prev_discr.unwrap().to_string(),\n+                    item_name: tcx.item_name(variant.def_id),\n+                    wrapped_discr: wrapped_discr.to_string(),\n+                });\n                 None\n             }\n             .unwrap_or(wrapped_discr),\n@@ -915,14 +895,7 @@ fn trait_def(tcx: TyCtxt<'_>, def_id: LocalDefId) -> ty::TraitDef {\n \n     let paren_sugar = tcx.has_attr(def_id, sym::rustc_paren_sugar);\n     if paren_sugar && !tcx.features().unboxed_closures {\n-        tcx.sess\n-            .struct_span_err(\n-                item.span,\n-                \"the `#[rustc_paren_sugar]` attribute is a temporary means of controlling \\\n-                 which traits can use parenthetical notation\",\n-            )\n-            .help(\"add `#![feature(unboxed_closures)]` to the crate attributes to use it\")\n-            .emit();\n+        tcx.sess.emit_err(errors::ParenSugarAttribute { span: item.span });\n     }\n \n     let is_marker = tcx.has_attr(def_id, sym::marker);\n@@ -942,13 +915,7 @@ fn trait_def(tcx: TyCtxt<'_>, def_id: LocalDefId) -> ty::TraitDef {\n         // and that they are all identifiers\n         .and_then(|attr| match attr.meta_item_list() {\n             Some(items) if items.len() < 2 => {\n-                tcx.sess\n-                    .struct_span_err(\n-                        attr.span,\n-                        \"the `#[rustc_must_implement_one_of]` attribute must be \\\n-                         used with at least 2 args\",\n-                    )\n-                    .emit();\n+                tcx.sess.emit_err(errors::MustImplementOneOfAttribute { span: attr.span });\n \n                 None\n             }\n@@ -957,9 +924,7 @@ fn trait_def(tcx: TyCtxt<'_>, def_id: LocalDefId) -> ty::TraitDef {\n                 .map(|item| item.ident().ok_or(item.span()))\n                 .collect::<Result<Box<[_]>, _>>()\n                 .map_err(|span| {\n-                    tcx.sess\n-                        .struct_span_err(span, \"must be a name of an associated function\")\n-                        .emit();\n+                    tcx.sess.emit_err(errors::MustBeNameOfAssociatedFunction { span });\n                 })\n                 .ok()\n                 .zip(Some(attr.span)),\n@@ -975,33 +940,25 @@ fn trait_def(tcx: TyCtxt<'_>, def_id: LocalDefId) -> ty::TraitDef {\n                 match item {\n                     Some(item) if matches!(item.kind, hir::AssocItemKind::Fn { .. }) => {\n                         if !tcx.impl_defaultness(item.id.owner_id).has_value() {\n-                            tcx.sess\n-                                .struct_span_err(\n-                                    item.span,\n-                                    \"function doesn't have a default implementation\",\n-                                )\n-                                .span_note(attr_span, \"required by this annotation\")\n-                                .emit();\n+                            tcx.sess.emit_err(errors::FunctionNotHaveDefaultImplementation {\n+                                span: item.span,\n+                                note_span: attr_span,\n+                            });\n \n                             return Some(());\n                         }\n \n                         return None;\n                     }\n                     Some(item) => {\n-                        tcx.sess\n-                            .struct_span_err(item.span, \"not a function\")\n-                            .span_note(attr_span, \"required by this annotation\")\n-                            .note(\n-                                \"all `#[rustc_must_implement_one_of]` arguments must be associated \\\n-                                 function names\",\n-                            )\n-                            .emit();\n+                        tcx.sess.emit_err(errors::MustImplementNotFunction {\n+                            span: item.span,\n+                            span_note: errors::MustImplementNotFunctionSpanNote { span: attr_span },\n+                            note: errors::MustImplementNotFunctionNote {},\n+                        });\n                     }\n                     None => {\n-                        tcx.sess\n-                            .struct_span_err(ident.span, \"function not found in this trait\")\n-                            .emit();\n+                        tcx.sess.emit_err(errors::FunctionNotFoundInTrait { span: ident.span });\n                     }\n                 }\n \n@@ -1018,9 +975,7 @@ fn trait_def(tcx: TyCtxt<'_>, def_id: LocalDefId) -> ty::TraitDef {\n             for ident in &*list {\n                 if let Some(dup) = set.insert(ident.name, ident.span) {\n                     tcx.sess\n-                        .struct_span_err(vec![dup, ident.span], \"functions names are duplicated\")\n-                        .note(\"all `#[rustc_must_implement_one_of]` arguments must be unique\")\n-                        .emit();\n+                        .emit_err(errors::FunctionNamesDuplicated { spans: vec![dup, ident.span] });\n \n                     no_dups = false;\n                 }\n@@ -1485,17 +1440,7 @@ fn compute_sig_of_foreign_fn_decl<'tcx>(\n                     .source_map()\n                     .span_to_snippet(ast_ty.span)\n                     .map_or_else(|_| String::new(), |s| format!(\" `{}`\", s));\n-                tcx.sess\n-                    .struct_span_err(\n-                        ast_ty.span,\n-                        &format!(\n-                            \"use of SIMD type{} in FFI is highly experimental and \\\n-                             may result in invalid code\",\n-                            snip\n-                        ),\n-                    )\n-                    .help(\"add `#![feature(simd_ffi)]` to the crate attributes to enable\")\n-                    .emit();\n+                tcx.sess.emit_err(errors::SIMDFFIHighlyExperimental { span: ast_ty.span, snip });\n             }\n         };\n         for (input, ty) in iter::zip(decl.inputs, fty.inputs().skip_binder()) {"}, {"sha": "2e56d24638cdb101920d748bc2a849fe66492b5c", "filename": "compiler/rustc_hir_analysis/src/collect/item_bounds.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6efdf4d1309f8047bc439a4810888c715e2df480/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect%2Fitem_bounds.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6efdf4d1309f8047bc439a4810888c715e2df480/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect%2Fitem_bounds.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect%2Fitem_bounds.rs?ref=6efdf4d1309f8047bc439a4810888c715e2df480", "patch": "@@ -130,7 +130,7 @@ pub(super) fn item_bounds(\n     tcx: TyCtxt<'_>,\n     def_id: DefId,\n ) -> ty::EarlyBinder<&'_ ty::List<ty::Predicate<'_>>> {\n-    let bounds = tcx.mk_predicates_from_iter(util::elaborate_predicates(\n+    let bounds = tcx.mk_predicates_from_iter(util::elaborate(\n         tcx,\n         tcx.explicit_item_bounds(def_id).iter().map(|&(bound, _span)| bound),\n     ));"}, {"sha": "2a3a683489ddd21b5a5dcff9c175c9d741a7b7c2", "filename": "compiler/rustc_hir_analysis/src/errors.rs", "status": "modified", "additions": 124, "deletions": 0, "changes": 124, "blob_url": "https://github.com/rust-lang/rust/blob/6efdf4d1309f8047bc439a4810888c715e2df480/compiler%2Frustc_hir_analysis%2Fsrc%2Ferrors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6efdf4d1309f8047bc439a4810888c715e2df480/compiler%2Frustc_hir_analysis%2Fsrc%2Ferrors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Ferrors.rs?ref=6efdf4d1309f8047bc439a4810888c715e2df480", "patch": "@@ -507,3 +507,127 @@ pub(crate) struct ReturnTypeNotationMissingMethod {\n     pub trait_name: Symbol,\n     pub assoc_name: Symbol,\n }\n+\n+#[derive(Diagnostic)]\n+#[diag(hir_analysis_placeholder_not_allowed_item_signatures, code = \"E0121\")]\n+pub(crate) struct PlaceholderNotAllowedItemSignatures {\n+    #[primary_span]\n+    #[label]\n+    pub spans: Vec<Span>,\n+    pub kind: String,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(hir_analysis_associated_type_trait_uninferred_generic_params, code = \"E0212\")]\n+pub(crate) struct AssociatedTypeTraitUninferredGenericParams {\n+    #[primary_span]\n+    pub span: Span,\n+    #[suggestion(style = \"verbose\", applicability = \"maybe-incorrect\", code = \"{bound}\")]\n+    pub inferred_sugg: Option<Span>,\n+    pub bound: String,\n+    #[subdiagnostic]\n+    pub mpart_sugg: Option<AssociatedTypeTraitUninferredGenericParamsMultipartSuggestion>,\n+}\n+\n+#[derive(Subdiagnostic)]\n+#[multipart_suggestion(\n+    hir_analysis_associated_type_trait_uninferred_generic_params_multipart_suggestion,\n+    applicability = \"maybe-incorrect\"\n+)]\n+pub(crate) struct AssociatedTypeTraitUninferredGenericParamsMultipartSuggestion {\n+    #[suggestion_part(code = \"{first}\")]\n+    pub fspan: Span,\n+    pub first: String,\n+    #[suggestion_part(code = \"{second}\")]\n+    pub sspan: Span,\n+    pub second: String,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(hir_analysis_enum_discriminant_overflowed, code = \"E0370\")]\n+#[note]\n+pub(crate) struct EnumDiscriminantOverflowed {\n+    #[primary_span]\n+    #[label]\n+    pub span: Span,\n+    pub discr: String,\n+    pub item_name: Symbol,\n+    pub wrapped_discr: String,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(hir_analysis_paren_sugar_attribute)]\n+#[help]\n+pub(crate) struct ParenSugarAttribute {\n+    #[primary_span]\n+    pub span: Span,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(hir_analysis_must_implement_one_of_attribute)]\n+pub(crate) struct MustImplementOneOfAttribute {\n+    #[primary_span]\n+    pub span: Span,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(hir_analysis_must_be_name_of_associated_function)]\n+pub(crate) struct MustBeNameOfAssociatedFunction {\n+    #[primary_span]\n+    pub span: Span,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(hir_analysis_function_not_have_default_implementation)]\n+pub(crate) struct FunctionNotHaveDefaultImplementation {\n+    #[primary_span]\n+    pub span: Span,\n+    #[note]\n+    pub note_span: Span,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(hir_analysis_must_implement_not_function)]\n+pub(crate) struct MustImplementNotFunction {\n+    #[primary_span]\n+    pub span: Span,\n+    #[subdiagnostic]\n+    pub span_note: MustImplementNotFunctionSpanNote,\n+    #[subdiagnostic]\n+    pub note: MustImplementNotFunctionNote,\n+}\n+\n+#[derive(Subdiagnostic)]\n+#[note(hir_analysis_must_implement_not_function_span_note)]\n+pub(crate) struct MustImplementNotFunctionSpanNote {\n+    #[primary_span]\n+    pub span: Span,\n+}\n+\n+#[derive(Subdiagnostic)]\n+#[note(hir_analysis_must_implement_not_function_note)]\n+pub(crate) struct MustImplementNotFunctionNote {}\n+\n+#[derive(Diagnostic)]\n+#[diag(hir_analysis_function_not_found_in_trait)]\n+pub(crate) struct FunctionNotFoundInTrait {\n+    #[primary_span]\n+    pub span: Span,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(hir_analysis_functions_names_duplicated)]\n+#[note]\n+pub(crate) struct FunctionNamesDuplicated {\n+    #[primary_span]\n+    pub spans: Vec<Span>,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(hir_analysis_simd_ffi_highly_experimental)]\n+#[help]\n+pub(crate) struct SIMDFFIHighlyExperimental {\n+    #[primary_span]\n+    pub span: Span,\n+    pub snip: String,\n+}"}, {"sha": "35785e81ff497516004281970f1c4b127d6611c0", "filename": "compiler/rustc_hir_analysis/src/impl_wf_check/min_specialization.rs", "status": "modified", "additions": 5, "deletions": 7, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/6efdf4d1309f8047bc439a4810888c715e2df480/compiler%2Frustc_hir_analysis%2Fsrc%2Fimpl_wf_check%2Fmin_specialization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6efdf4d1309f8047bc439a4810888c715e2df480/compiler%2Frustc_hir_analysis%2Fsrc%2Fimpl_wf_check%2Fmin_specialization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fimpl_wf_check%2Fmin_specialization.rs?ref=6efdf4d1309f8047bc439a4810888c715e2df480", "patch": "@@ -318,15 +318,14 @@ fn check_predicates<'tcx>(\n     span: Span,\n ) {\n     let instantiated = tcx.predicates_of(impl1_def_id).instantiate(tcx, impl1_substs);\n-    let impl1_predicates: Vec<_> =\n-        traits::elaborate_predicates_with_span(tcx, instantiated.into_iter()).collect();\n+    let impl1_predicates: Vec<_> = traits::elaborate(tcx, instantiated.into_iter()).collect();\n \n     let mut impl2_predicates = if impl2_node.is_from_trait() {\n         // Always applicable traits have to be always applicable without any\n         // assumptions.\n         Vec::new()\n     } else {\n-        traits::elaborate_predicates(\n+        traits::elaborate(\n             tcx,\n             tcx.predicates_of(impl2_node.def_id())\n                 .instantiate(tcx, impl2_substs)\n@@ -371,11 +370,10 @@ fn check_predicates<'tcx>(\n                 .unwrap();\n \n         assert!(!obligations.needs_infer());\n-        impl2_predicates.extend(\n-            traits::elaborate_obligations(tcx, obligations).map(|obligation| obligation.predicate),\n-        )\n+        impl2_predicates\n+            .extend(traits::elaborate(tcx, obligations).map(|obligation| obligation.predicate))\n     }\n-    impl2_predicates.extend(traits::elaborate_predicates(tcx, always_applicable_traits));\n+    impl2_predicates.extend(traits::elaborate(tcx, always_applicable_traits));\n \n     for (predicate, span) in impl1_predicates {\n         if !impl2_predicates.iter().any(|pred2| trait_predicates_eq(tcx, predicate, *pred2, span)) {"}, {"sha": "27e56180349efe7ae852cd549359d9cafb2f8d1b", "filename": "compiler/rustc_hir_analysis/src/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/6efdf4d1309f8047bc439a4810888c715e2df480/compiler%2Frustc_hir_analysis%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6efdf4d1309f8047bc439a4810888c715e2df480/compiler%2Frustc_hir_analysis%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Flib.rs?ref=6efdf4d1309f8047bc439a4810888c715e2df480", "patch": "@@ -70,7 +70,6 @@ This API is completely unstable and subject to change.\n #![feature(lazy_cell)]\n #![feature(slice_partition_dedup)]\n #![feature(try_blocks)]\n-#![feature(is_some_and)]\n #![feature(type_alias_impl_trait)]\n #![recursion_limit = \"256\"]\n "}, {"sha": "74f5b359021d291fd86b35dd808fa86f0c257b36", "filename": "compiler/rustc_hir_pretty/src/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6efdf4d1309f8047bc439a4810888c715e2df480/compiler%2Frustc_hir_pretty%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6efdf4d1309f8047bc439a4810888c715e2df480/compiler%2Frustc_hir_pretty%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_pretty%2Fsrc%2Flib.rs?ref=6efdf4d1309f8047bc439a4810888c715e2df480", "patch": "@@ -242,7 +242,7 @@ pub fn enum_def_to_string(\n impl<'a> State<'a> {\n     pub fn bclose_maybe_open(&mut self, span: rustc_span::Span, close_box: bool) {\n         self.maybe_print_comment(span.hi());\n-        self.break_offset_if_not_bol(1, -(INDENT_UNIT as isize));\n+        self.break_offset_if_not_bol(1, -INDENT_UNIT);\n         self.word(\"}\");\n         if close_box {\n             self.end(); // close the outer-box"}, {"sha": "6c2ce62722a548054339b5709df3550305168074", "filename": "compiler/rustc_hir_typeck/src/_match.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/6efdf4d1309f8047bc439a4810888c715e2df480/compiler%2Frustc_hir_typeck%2Fsrc%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6efdf4d1309f8047bc439a4810888c715e2df480/compiler%2Frustc_hir_typeck%2Fsrc%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2F_match.rs?ref=6efdf4d1309f8047bc439a4810888c715e2df480", "patch": "@@ -538,8 +538,8 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                                 // FIXME(rpitit): This will need to be fixed when we move to associated types\n                                 assert!(matches!(\n                                     *trait_pred.trait_ref.self_ty().kind(),\n-                                    ty::Alias(_, ty::AliasTy { def_id, substs, .. })\n-                                    if def_id == rpit_def_id && substs == substs\n+                                    ty::Alias(_, ty::AliasTy { def_id, substs: alias_substs, .. })\n+                                    if def_id == rpit_def_id && substs == alias_substs\n                                 ));\n                                 ty::PredicateKind::Clause(ty::Clause::Trait(\n                                     trait_pred.with_self_ty(self.tcx, ty),\n@@ -548,8 +548,8 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                             ty::PredicateKind::Clause(ty::Clause::Projection(mut proj_pred)) => {\n                                 assert!(matches!(\n                                     *proj_pred.projection_ty.self_ty().kind(),\n-                                    ty::Alias(_, ty::AliasTy { def_id, substs, .. })\n-                                    if def_id == rpit_def_id && substs == substs\n+                                    ty::Alias(_, ty::AliasTy { def_id, substs: alias_substs, .. })\n+                                    if def_id == rpit_def_id && substs == alias_substs\n                                 ));\n                                 proj_pred = proj_pred.with_self_ty(self.tcx, ty);\n                                 ty::PredicateKind::Clause(ty::Clause::Projection(proj_pred))"}, {"sha": "15eec42d78641c7810f53da5c6b97fe2af3120e1", "filename": "compiler/rustc_hir_typeck/src/closure.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6efdf4d1309f8047bc439a4810888c715e2df480/compiler%2Frustc_hir_typeck%2Fsrc%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6efdf4d1309f8047bc439a4810888c715e2df480/compiler%2Frustc_hir_typeck%2Fsrc%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fclosure.rs?ref=6efdf4d1309f8047bc439a4810888c715e2df480", "patch": "@@ -204,7 +204,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         let mut expected_sig = None;\n         let mut expected_kind = None;\n \n-        for (pred, span) in traits::elaborate_predicates_with_span(\n+        for (pred, span) in traits::elaborate(\n             self.tcx,\n             // Reverse the obligations here, since `elaborate_*` uses a stack,\n             // and we want to keep inference generally in the same order of"}, {"sha": "68e096e3bd023958e6fb2b7c14f4c370cd05aa7b", "filename": "compiler/rustc_hir_typeck/src/expr.rs", "status": "modified", "additions": 16, "deletions": 13, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/6efdf4d1309f8047bc439a4810888c715e2df480/compiler%2Frustc_hir_typeck%2Fsrc%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6efdf4d1309f8047bc439a4810888c715e2df480/compiler%2Frustc_hir_typeck%2Fsrc%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fexpr.rs?ref=6efdf4d1309f8047bc439a4810888c715e2df480", "patch": "@@ -2810,23 +2810,26 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                         \"cannot index into a value of type `{base_t}`\",\n                     );\n                     // Try to give some advice about indexing tuples.\n-                    if let ty::Tuple(..) = base_t.kind() {\n+                    if let ty::Tuple(types) = base_t.kind() {\n                         let mut needs_note = true;\n                         // If the index is an integer, we can show the actual\n                         // fixed expression:\n-                        if let ExprKind::Lit(ref lit) = idx.kind {\n-                            if let ast::LitKind::Int(i, ast::LitIntType::Unsuffixed) = lit.node {\n-                                let snip = self.tcx.sess.source_map().span_to_snippet(base.span);\n-                                if let Ok(snip) = snip {\n-                                    err.span_suggestion(\n-                                        expr.span,\n-                                        \"to access tuple elements, use\",\n-                                        format!(\"{snip}.{i}\"),\n-                                        Applicability::MachineApplicable,\n-                                    );\n-                                    needs_note = false;\n-                                }\n+                        if let ExprKind::Lit(ref lit) = idx.kind\n+                            && let ast::LitKind::Int(i, ast::LitIntType::Unsuffixed) = lit.node\n+                            && i < types.len().try_into().expect(\"expected tuple index to be < usize length\")\n+                        {\n+                            let snip = self.tcx.sess.source_map().span_to_snippet(base.span);\n+                            if let Ok(snip) = snip {\n+                                err.span_suggestion(\n+                                    expr.span,\n+                                    \"to access tuple elements, use\",\n+                                    format!(\"{snip}.{i}\"),\n+                                    Applicability::MachineApplicable,\n+                                );\n+                                needs_note = false;\n                             }\n+                        } else if let ExprKind::Path(..) = idx.peel_borrows().kind {\n+                            err.span_label(idx.span, \"cannot access tuple elements at a variable index\");\n                         }\n                         if needs_note {\n                             err.help("}, {"sha": "3e0c2bf2a55382635d472e56c8e207e118fc21dc", "filename": "compiler/rustc_hir_typeck/src/fn_ctxt/adjust_fulfillment_errors.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/6efdf4d1309f8047bc439a4810888c715e2df480/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2Fadjust_fulfillment_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6efdf4d1309f8047bc439a4810888c715e2df480/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2Fadjust_fulfillment_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2Fadjust_fulfillment_errors.rs?ref=6efdf4d1309f8047bc439a4810888c715e2df480", "patch": "@@ -242,8 +242,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         let Some(arg) = segment\n             .args()\n             .args\n-            .iter()\n-            .nth(index) else { return false; };\n+            .get(index) else { return false; };\n         error.obligation.cause.span = arg\n             .span()\n             .find_ancestor_in_same_ctxt(error.obligation.cause.span)"}, {"sha": "b02eae19fce103f5ca0059e1865a3178c993972d", "filename": "compiler/rustc_hir_typeck/src/fn_ctxt/checks.rs", "status": "modified", "additions": 34, "deletions": 5, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/6efdf4d1309f8047bc439a4810888c715e2df480/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2Fchecks.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6efdf4d1309f8047bc439a4810888c715e2df480/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2Fchecks.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2Fchecks.rs?ref=6efdf4d1309f8047bc439a4810888c715e2df480", "patch": "@@ -31,7 +31,7 @@ use rustc_middle::ty::visit::TypeVisitableExt;\n use rustc_middle::ty::{self, IsSuggestable, Ty};\n use rustc_session::Session;\n use rustc_span::symbol::{kw, Ident};\n-use rustc_span::{self, sym, Span};\n+use rustc_span::{self, sym, BytePos, Span};\n use rustc_trait_selection::traits::{self, ObligationCauseCode, SelectionContext};\n \n use std::iter;\n@@ -894,8 +894,13 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         };\n \n         let mut errors = errors.into_iter().peekable();\n+        let mut only_extras_so_far = errors\n+            .peek()\n+            .map_or(false, |first| matches!(first, Error::Extra(arg_idx) if arg_idx.index() == 0));\n         let mut suggestions = vec![];\n         while let Some(error) = errors.next() {\n+            only_extras_so_far &= matches!(error, Error::Extra(_));\n+\n             match error {\n                 Error::Invalid(provided_idx, expected_idx, compatibility) => {\n                     let (formal_ty, expected_ty) = formal_and_expected_inputs[expected_idx];\n@@ -941,10 +946,34 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                         if arg_idx.index() > 0\n                         && let Some((_, prev)) = provided_arg_tys\n                             .get(ProvidedIdx::from_usize(arg_idx.index() - 1)\n-                    ) {\n-                        // Include previous comma\n-                        span = prev.shrink_to_hi().to(span);\n-                    }\n+                        ) {\n+                            // Include previous comma\n+                            span = prev.shrink_to_hi().to(span);\n+                        }\n+\n+                        // Is last argument for deletion in a row starting from the 0-th argument?\n+                        // Then delete the next comma, so we are not left with `f(, ...)`\n+                        //\n+                        //     fn f() {}\n+                        //   - f(0, 1,)\n+                        //   + f()\n+                        if only_extras_so_far\n+                            && errors\n+                                .peek()\n+                                .map_or(true, |next_error| !matches!(next_error, Error::Extra(_)))\n+                        {\n+                            let next = provided_arg_tys\n+                                .get(arg_idx + 1)\n+                                .map(|&(_, sp)| sp)\n+                                .unwrap_or_else(|| {\n+                                    // Subtract one to move before `)`\n+                                    call_expr.span.with_lo(call_expr.span.hi() - BytePos(1))\n+                                });\n+\n+                            // Include next comma\n+                            span = span.until(next);\n+                        }\n+\n                         suggestions.push((span, String::new()));\n \n                         suggestion_text = match suggestion_text {"}, {"sha": "3e9a9ce1b31147c02a36631834cc7dc7635b243a", "filename": "compiler/rustc_hir_typeck/src/generator_interior/drop_ranges/cfg_build.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/6efdf4d1309f8047bc439a4810888c715e2df480/compiler%2Frustc_hir_typeck%2Fsrc%2Fgenerator_interior%2Fdrop_ranges%2Fcfg_build.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6efdf4d1309f8047bc439a4810888c715e2df480/compiler%2Frustc_hir_typeck%2Fsrc%2Fgenerator_interior%2Fdrop_ranges%2Fcfg_build.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fgenerator_interior%2Fdrop_ranges%2Fcfg_build.rs?ref=6efdf4d1309f8047bc439a4810888c715e2df480", "patch": "@@ -526,8 +526,9 @@ impl DropRangesBuilder {\n         let mut next = <_>::from(0u32);\n         for value in tracked_values {\n             for_each_consumable(hir, value, |value| {\n-                if !tracked_value_map.contains_key(&value) {\n-                    tracked_value_map.insert(value, next);\n+                if let std::collections::hash_map::Entry::Vacant(e) = tracked_value_map.entry(value)\n+                {\n+                    e.insert(next);\n                     next = next + 1;\n                 }\n             });"}, {"sha": "5faa6ab13dd7de1a9e8149ade04145d7e02cc086", "filename": "compiler/rustc_hir_typeck/src/generator_interior/mod.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/6efdf4d1309f8047bc439a4810888c715e2df480/compiler%2Frustc_hir_typeck%2Fsrc%2Fgenerator_interior%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6efdf4d1309f8047bc439a4810888c715e2df480/compiler%2Frustc_hir_typeck%2Fsrc%2Fgenerator_interior%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fgenerator_interior%2Fmod.rs?ref=6efdf4d1309f8047bc439a4810888c715e2df480", "patch": "@@ -240,7 +240,7 @@ pub fn resolve_interior<'a, 'tcx>(\n \n             let mut counter = 0;\n             let mut mk_bound_region = |span| {\n-                let kind = ty::BrAnon(counter, span);\n+                let kind = ty::BrAnon(span);\n                 let var = ty::BoundVar::from_u32(counter);\n                 counter += 1;\n                 ty::BoundRegion { var, kind }\n@@ -263,7 +263,7 @@ pub fn resolve_interior<'a, 'tcx>(\n                     }\n                     ty::ReLateBound(_, ty::BoundRegion { kind, .. })\n                     | ty::ReFree(ty::FreeRegion { bound_region: kind, .. }) => match kind {\n-                        ty::BoundRegionKind::BrAnon(_, span) => mk_bound_region(span),\n+                        ty::BoundRegionKind::BrAnon(span) => mk_bound_region(span),\n                         ty::BoundRegionKind::BrNamed(def_id, _) => {\n                             mk_bound_region(Some(fcx.tcx.def_span(def_id)))\n                         }\n@@ -294,7 +294,7 @@ pub fn resolve_interior<'a, 'tcx>(\n             FnMutDelegate {\n                 regions: &mut |br| {\n                     let kind = match br.kind {\n-                        ty::BrAnon(_, span) => ty::BrAnon(counter, span),\n+                        ty::BrAnon(span) => ty::BrAnon(span),\n                         _ => br.kind,\n                     };\n                     let var = ty::BoundVar::from_usize(bound_vars.len());\n@@ -313,8 +313,7 @@ pub fn resolve_interior<'a, 'tcx>(\n     // Extract type components to build the witness type.\n     let type_list = fcx.tcx.mk_type_list_from_iter(type_causes.iter().map(|cause| cause.ty));\n     let bound_vars = fcx.tcx.mk_bound_variable_kinds(&bound_vars);\n-    let witness =\n-        fcx.tcx.mk_generator_witness(ty::Binder::bind_with_vars(type_list, bound_vars.clone()));\n+    let witness = fcx.tcx.mk_generator_witness(ty::Binder::bind_with_vars(type_list, bound_vars));\n \n     drop(typeck_results);\n     // Store the generator types and spans into the typeck results for this generator."}, {"sha": "106f5bcd7558700d22667213cf8f78613b9197d2", "filename": "compiler/rustc_hir_typeck/src/intrinsicck.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/6efdf4d1309f8047bc439a4810888c715e2df480/compiler%2Frustc_hir_typeck%2Fsrc%2Fintrinsicck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6efdf4d1309f8047bc439a4810888c715e2df480/compiler%2Frustc_hir_typeck%2Fsrc%2Fintrinsicck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fintrinsicck.rs?ref=6efdf4d1309f8047bc439a4810888c715e2df480", "patch": "@@ -84,6 +84,13 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         let skeleton_string = |ty: Ty<'tcx>, sk| match sk {\n             Ok(SizeSkeleton::Known(size)) => format!(\"{} bits\", size.bits()),\n             Ok(SizeSkeleton::Pointer { tail, .. }) => format!(\"pointer to `{tail}`\"),\n+            Ok(SizeSkeleton::Generic(size)) => {\n+                if let Some(size) = size.try_eval_target_usize(tcx, self.param_env) {\n+                    format!(\"{size} bytes\")\n+                } else {\n+                    format!(\"generic size {size}\")\n+                }\n+            }\n             Err(LayoutError::Unknown(bad)) => {\n                 if bad == ty {\n                     \"this type does not have a fixed size\".to_owned()"}, {"sha": "9155a3d8daa19ac796521454b34d47853d854173", "filename": "compiler/rustc_hir_typeck/src/method/confirm.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6efdf4d1309f8047bc439a4810888c715e2df480/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fconfirm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6efdf4d1309f8047bc439a4810888c715e2df480/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fconfirm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fconfirm.rs?ref=6efdf4d1309f8047bc439a4810888c715e2df480", "patch": "@@ -574,7 +574,7 @@ impl<'a, 'tcx> ConfirmContext<'a, 'tcx> {\n     ) -> Option<Span> {\n         let sized_def_id = self.tcx.lang_items().sized_trait()?;\n \n-        traits::elaborate_predicates(self.tcx, predicates.predicates.iter().copied())\n+        traits::elaborate(self.tcx, predicates.predicates.iter().copied())\n             // We don't care about regions here.\n             .filter_map(|pred| match pred.kind().skip_binder() {\n                 ty::PredicateKind::Clause(ty::Clause::Trait(trait_pred))"}, {"sha": "08cd6085d7f30d6f4e6f818860361b7936fbf90d", "filename": "compiler/rustc_hir_typeck/src/method/probe.rs", "status": "modified", "additions": 21, "deletions": 14, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/6efdf4d1309f8047bc439a4810888c715e2df480/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fprobe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6efdf4d1309f8047bc439a4810888c715e2df480/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fprobe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fprobe.rs?ref=6efdf4d1309f8047bc439a4810888c715e2df480", "patch": "@@ -793,6 +793,14 @@ impl<'a, 'tcx> ProbeContext<'a, 'tcx> {\n         // a `&self` method will wind up with an argument type like `&dyn Trait`.\n         let trait_ref = principal.with_self_ty(self.tcx, self_ty);\n         self.elaborate_bounds(iter::once(trait_ref), |this, new_trait_ref, item| {\n+            if new_trait_ref.has_non_region_late_bound() {\n+                this.tcx.sess.delay_span_bug(\n+                    this.span,\n+                    \"tried to select method from HRTB with non-lifetime bound vars\",\n+                );\n+                return;\n+            }\n+\n             let new_trait_ref = this.erase_late_bound_regions(new_trait_ref);\n \n             let (xform_self_ty, xform_ret_ty) =\n@@ -843,18 +851,15 @@ impl<'a, 'tcx> ProbeContext<'a, 'tcx> {\n         });\n \n         self.elaborate_bounds(bounds, |this, poly_trait_ref, item| {\n-            let trait_ref = this.erase_late_bound_regions(poly_trait_ref);\n+            let trait_ref = this.instantiate_binder_with_fresh_vars(\n+                this.span,\n+                infer::LateBoundRegionConversionTime::FnCall,\n+                poly_trait_ref,\n+            );\n \n             let (xform_self_ty, xform_ret_ty) =\n                 this.xform_self_ty(item, trait_ref.self_ty(), trait_ref.substs);\n \n-            // Because this trait derives from a where-clause, it\n-            // should not contain any inference variables or other\n-            // artifacts. This means it is safe to put into the\n-            // `WhereClauseCandidate` and (eventually) into the\n-            // `WhereClausePick`.\n-            assert!(!trait_ref.substs.needs_infer());\n-\n             this.push_candidate(\n                 Candidate {\n                     xform_self_ty,\n@@ -964,7 +969,11 @@ impl<'a, 'tcx> ProbeContext<'a, 'tcx> {\n                             bound_trait_ref.def_id(),\n                         ));\n                     } else {\n-                        let new_trait_ref = self.erase_late_bound_regions(bound_trait_ref);\n+                        let new_trait_ref = self.instantiate_binder_with_fresh_vars(\n+                            self.span,\n+                            infer::LateBoundRegionConversionTime::FnCall,\n+                            bound_trait_ref,\n+                        );\n \n                         let (xform_self_ty, xform_ret_ty) =\n                             self.xform_self_ty(item, new_trait_ref.self_ty(), new_trait_ref.substs);\n@@ -1555,8 +1564,7 @@ impl<'a, 'tcx> ProbeContext<'a, 'tcx> {\n                         if !self.predicate_may_hold(&o) {\n                             result = ProbeResult::NoMatch;\n                             let parent_o = o.clone();\n-                            let implied_obligations =\n-                                traits::elaborate_obligations(self.tcx, vec![o]);\n+                            let implied_obligations = traits::elaborate(self.tcx, vec![o]);\n                             for o in implied_obligations {\n                                 let parent = if o == parent_o {\n                                     None\n@@ -1756,16 +1764,15 @@ impl<'a, 'tcx> ProbeContext<'a, 'tcx> {\n     fn probe_for_similar_candidate(&mut self) -> Result<Option<ty::AssocItem>, MethodError<'tcx>> {\n         debug!(\"probing for method names similar to {:?}\", self.method_name);\n \n-        let steps = self.steps.clone();\n         self.probe(|_| {\n             let mut pcx = ProbeContext::new(\n                 self.fcx,\n                 self.span,\n                 self.mode,\n                 self.method_name,\n                 self.return_type,\n-                &self.orig_steps_var_values,\n-                steps,\n+                self.orig_steps_var_values,\n+                self.steps,\n                 self.scope_expr_id,\n             );\n             pcx.allow_similar_names = true;"}, {"sha": "af0bd26dec5f91983a811c2735b41e07d7be92f5", "filename": "compiler/rustc_hir_typeck/src/pat.rs", "status": "modified", "additions": 21, "deletions": 2, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/6efdf4d1309f8047bc439a4810888c715e2df480/compiler%2Frustc_hir_typeck%2Fsrc%2Fpat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6efdf4d1309f8047bc439a4810888c715e2df480/compiler%2Frustc_hir_typeck%2Fsrc%2Fpat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fpat.rs?ref=6efdf4d1309f8047bc439a4810888c715e2df480", "patch": "@@ -37,6 +37,10 @@ pointers. If you encounter this error you should try to avoid dereferencing the\n You can read more about trait objects in the Trait Objects section of the Reference: \\\n https://doc.rust-lang.org/reference/types.html#trait-objects\";\n \n+fn is_number(text: &str) -> bool {\n+    text.chars().all(|c: char| c.is_digit(10))\n+}\n+\n /// Information about the expected type at the top level of type checking a pattern.\n ///\n /// **NOTE:** This is only for use by diagnostics. Do NOT use for type checking logic!\n@@ -1673,7 +1677,15 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         fields: &'tcx [hir::PatField<'tcx>],\n         variant: &ty::VariantDef,\n     ) -> Option<DiagnosticBuilder<'tcx, ErrorGuaranteed>> {\n-        if let (Some(CtorKind::Fn), PatKind::Struct(qpath, ..)) = (variant.ctor_kind(), &pat.kind) {\n+        if let (Some(CtorKind::Fn), PatKind::Struct(qpath, pattern_fields, ..)) =\n+            (variant.ctor_kind(), &pat.kind)\n+        {\n+            let is_tuple_struct_match = !pattern_fields.is_empty()\n+                && pattern_fields.iter().map(|field| field.ident.name.as_str()).all(is_number);\n+            if is_tuple_struct_match {\n+                return None;\n+            }\n+\n             let path = rustc_hir_pretty::to_string(rustc_hir_pretty::NO_ANN, |s| {\n                 s.print_qpath(qpath, false)\n             });\n@@ -1895,7 +1907,14 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 prefix,\n                 unmentioned_fields\n                     .iter()\n-                    .map(|(_, name)| name.to_string())\n+                    .map(|(_, name)| {\n+                        let field_name = name.to_string();\n+                        if is_number(&field_name) {\n+                            format!(\"{}: _\", field_name)\n+                        } else {\n+                            field_name\n+                        }\n+                    })\n                     .collect::<Vec<_>>()\n                     .join(\", \"),\n                 if have_inaccessible_fields { \", ..\" } else { \"\" },"}, {"sha": "271ab830694bb522381a569a848253dc7018b53e", "filename": "compiler/rustc_index/src/bit_set.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6efdf4d1309f8047bc439a4810888c715e2df480/compiler%2Frustc_index%2Fsrc%2Fbit_set.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6efdf4d1309f8047bc439a4810888c715e2df480/compiler%2Frustc_index%2Fsrc%2Fbit_set.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_index%2Fsrc%2Fbit_set.rs?ref=6efdf4d1309f8047bc439a4810888c715e2df480", "patch": "@@ -1850,7 +1850,7 @@ impl<R: Idx, C: Idx> SparseBitMatrix<R, C> {\n \n     /// Iterates through all the columns set to true in a given row of\n     /// the matrix.\n-    pub fn iter<'a>(&'a self, row: R) -> impl Iterator<Item = C> + 'a {\n+    pub fn iter(&self, row: R) -> impl Iterator<Item = C> + '_ {\n         self.row(row).into_iter().flat_map(|r| r.iter())\n     }\n "}, {"sha": "ae2f52c513e9f4398526ad0ebd9a1a97702282c4", "filename": "compiler/rustc_index/src/vec.rs", "status": "modified", "additions": 58, "deletions": 7, "changes": 65, "blob_url": "https://github.com/rust-lang/rust/blob/6efdf4d1309f8047bc439a4810888c715e2df480/compiler%2Frustc_index%2Fsrc%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6efdf4d1309f8047bc439a4810888c715e2df480/compiler%2Frustc_index%2Fsrc%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_index%2Fsrc%2Fvec.rs?ref=6efdf4d1309f8047bc439a4810888c715e2df480", "patch": "@@ -24,6 +24,7 @@ pub trait Idx: Copy + 'static + Eq + PartialEq + Debug + Hash {\n     }\n \n     #[inline]\n+    #[must_use = \"Use `increment_by` if you wanted to update the index in-place\"]\n     fn plus(self, amount: usize) -> Self {\n         Self::new(self.index() + amount)\n     }\n@@ -129,6 +130,17 @@ impl<I: Idx, T> IndexVec<I, T> {\n         IndexVec { raw: Vec::with_capacity(capacity), _marker: PhantomData }\n     }\n \n+    /// Creates a new vector with a copy of `elem` for each index in `universe`.\n+    ///\n+    /// Thus `IndexVec::from_elem(elem, &universe)` is equivalent to\n+    /// `IndexVec::<I, _>::from_elem_n(elem, universe.len())`. That can help\n+    /// type inference as it ensures that the resulting vector uses the same\n+    /// index type as `universe`, rather than something potentially surprising.\n+    ///\n+    /// For example, if you want to store data for each local in a MIR body,\n+    /// using `let mut uses = IndexVec::from_elem(vec![], &body.local_decls);`\n+    /// ensures that `uses` is an `IndexVec<Local, _>`, and thus can give\n+    /// better error messages later if one accidentally mismatches indices.\n     #[inline]\n     pub fn from_elem<S>(elem: T, universe: &IndexSlice<I, S>) -> Self\n     where\n@@ -189,18 +201,15 @@ impl<I: Idx, T> IndexVec<I, T> {\n     }\n \n     #[inline]\n-    pub fn drain<'a, R: RangeBounds<usize>>(\n-        &'a mut self,\n-        range: R,\n-    ) -> impl Iterator<Item = T> + 'a {\n+    pub fn drain<R: RangeBounds<usize>>(&mut self, range: R) -> impl Iterator<Item = T> + '_ {\n         self.raw.drain(range)\n     }\n \n     #[inline]\n-    pub fn drain_enumerated<'a, R: RangeBounds<usize>>(\n-        &'a mut self,\n+    pub fn drain_enumerated<R: RangeBounds<usize>>(\n+        &mut self,\n         range: R,\n-    ) -> impl Iterator<Item = (I, T)> + 'a {\n+    ) -> impl Iterator<Item = (I, T)> + '_ {\n         let begin = match range.start_bound() {\n             std::ops::Bound::Included(i) => *i,\n             std::ops::Bound::Excluded(i) => i.checked_add(1).unwrap(),\n@@ -283,6 +292,11 @@ impl<I: Idx, T: Clone> ToOwned for IndexSlice<I, T> {\n }\n \n impl<I: Idx, T> IndexSlice<I, T> {\n+    #[inline]\n+    pub fn empty() -> &'static Self {\n+        Default::default()\n+    }\n+\n     #[inline]\n     pub fn from_raw(raw: &[T]) -> &Self {\n         let ptr: *const [T] = raw;\n@@ -398,6 +412,36 @@ impl<I: Idx, T> IndexSlice<I, T> {\n     }\n }\n \n+impl<I: Idx, J: Idx> IndexSlice<I, J> {\n+    /// Invert a bijective mapping, i.e. `invert(map)[y] = x` if `map[x] = y`,\n+    /// assuming the values in `self` are a permutation of `0..self.len()`.\n+    ///\n+    /// This is used to go between `memory_index` (source field order to memory order)\n+    /// and `inverse_memory_index` (memory order to source field order).\n+    /// See also `FieldsShape::Arbitrary::memory_index` for more details.\n+    // FIXME(eddyb) build a better abstraction for permutations, if possible.\n+    pub fn invert_bijective_mapping(&self) -> IndexVec<J, I> {\n+        debug_assert_eq!(\n+            self.iter().map(|x| x.index() as u128).sum::<u128>(),\n+            (0..self.len() as u128).sum::<u128>(),\n+            \"The values aren't 0..N in input {self:?}\",\n+        );\n+\n+        let mut inverse = IndexVec::from_elem_n(Idx::new(0), self.len());\n+        for (i1, &i2) in self.iter_enumerated() {\n+            inverse[i2] = i1;\n+        }\n+\n+        debug_assert_eq!(\n+            inverse.iter().map(|x| x.index() as u128).sum::<u128>(),\n+            (0..inverse.len() as u128).sum::<u128>(),\n+            \"The values aren't 0..N in result {self:?}\",\n+        );\n+\n+        inverse\n+    }\n+}\n+\n /// `IndexVec` is often used as a map, so it provides some map-like APIs.\n impl<I: Idx, T> IndexVec<I, Option<T>> {\n     #[inline]\n@@ -502,6 +546,13 @@ impl<I: Idx, T> FromIterator<T> for IndexVec<I, T> {\n     }\n }\n \n+impl<I: Idx, T, const N: usize> From<[T; N]> for IndexVec<I, T> {\n+    #[inline]\n+    fn from(array: [T; N]) -> Self {\n+        IndexVec::from_raw(array.into())\n+    }\n+}\n+\n impl<I: Idx, T> IntoIterator for IndexVec<I, T> {\n     type Item = T;\n     type IntoIter = vec::IntoIter<T>;"}, {"sha": "1e43644be89abf8e1845f7cb390ead966378d428", "filename": "compiler/rustc_infer/messages.ftl", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6efdf4d1309f8047bc439a4810888c715e2df480/compiler%2Frustc_infer%2Fmessages.ftl", "raw_url": "https://github.com/rust-lang/rust/raw/6efdf4d1309f8047bc439a4810888c715e2df480/compiler%2Frustc_infer%2Fmessages.ftl", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fmessages.ftl?ref=6efdf4d1309f8047bc439a4810888c715e2df480", "patch": "@@ -30,8 +30,8 @@ infer_source_kind_subdiag_let = {$kind ->\n }{$x_kind ->\n     [has_name] , where the {$prefix_kind ->\n         *[type] type for {$prefix}\n-        [const_with_param] the value of const parameter\n-        [const] the value of the constant\n+        [const_with_param] value of const parameter\n+        [const] value of the constant\n     } `{$arg_name}` is specified\n     [underscore] , where the placeholders `_` are specified\n     *[empty] {\"\"}"}, {"sha": "30f6af74b83ef5b4f6e575588d698ac11c8ea62a", "filename": "compiler/rustc_infer/src/errors/note_and_explain.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/6efdf4d1309f8047bc439a4810888c715e2df480/compiler%2Frustc_infer%2Fsrc%2Ferrors%2Fnote_and_explain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6efdf4d1309f8047bc439a4810888c715e2df480/compiler%2Frustc_infer%2Fsrc%2Ferrors%2Fnote_and_explain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Ferrors%2Fnote_and_explain.rs?ref=6efdf4d1309f8047bc439a4810888c715e2df480", "patch": "@@ -90,9 +90,8 @@ impl<'a> DescriptionCtx<'a> {\n                             };\n                             me.span = Some(sp);\n                         }\n-                        ty::BrAnon(idx, span) => {\n-                            me.kind = \"anon_num_here\";\n-                            me.num_arg = idx+1;\n+                        ty::BrAnon(span) => {\n+                            me.kind = \"defined_here\";\n                             me.span = match span {\n                                 Some(_) => span,\n                                 None => Some(tcx.def_span(scope)),"}, {"sha": "e808911a38b12f40a54064ec88bb49decbf4c230", "filename": "compiler/rustc_infer/src/infer/canonical/canonicalizer.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6efdf4d1309f8047bc439a4810888c715e2df480/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcanonical%2Fcanonicalizer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6efdf4d1309f8047bc439a4810888c715e2df480/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcanonical%2Fcanonicalizer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcanonical%2Fcanonicalizer.rs?ref=6efdf4d1309f8047bc439a4810888c715e2df480", "patch": "@@ -772,7 +772,7 @@ impl<'cx, 'tcx> Canonicalizer<'cx, 'tcx> {\n         r: ty::Region<'tcx>,\n     ) -> ty::Region<'tcx> {\n         let var = self.canonical_var(info, r.into());\n-        let br = ty::BoundRegion { var, kind: ty::BrAnon(var.as_u32(), None) };\n+        let br = ty::BoundRegion { var, kind: ty::BrAnon(None) };\n         self.interner().mk_re_late_bound(self.binder_index, br)\n     }\n "}, {"sha": "fbb2257bf67c4929473668d5e387da863f60f1d9", "filename": "compiler/rustc_infer/src/infer/canonical/mod.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/6efdf4d1309f8047bc439a4810888c715e2df480/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcanonical%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6efdf4d1309f8047bc439a4810888c715e2df480/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcanonical%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcanonical%2Fmod.rs?ref=6efdf4d1309f8047bc439a4810888c715e2df480", "patch": "@@ -125,9 +125,9 @@ impl<'tcx> InferCtxt<'tcx> {\n                 ty.into()\n             }\n \n-            CanonicalVarKind::PlaceholderTy(ty::PlaceholderType { universe, name }) => {\n+            CanonicalVarKind::PlaceholderTy(ty::PlaceholderType { universe, bound }) => {\n                 let universe_mapped = universe_map(universe);\n-                let placeholder_mapped = ty::PlaceholderType { universe: universe_mapped, name };\n+                let placeholder_mapped = ty::PlaceholderType { universe: universe_mapped, bound };\n                 self.tcx.mk_placeholder(placeholder_mapped).into()\n             }\n \n@@ -138,9 +138,9 @@ impl<'tcx> InferCtxt<'tcx> {\n                 )\n                 .into(),\n \n-            CanonicalVarKind::PlaceholderRegion(ty::PlaceholderRegion { universe, name }) => {\n+            CanonicalVarKind::PlaceholderRegion(ty::PlaceholderRegion { universe, bound }) => {\n                 let universe_mapped = universe_map(universe);\n-                let placeholder_mapped = ty::PlaceholderRegion { universe: universe_mapped, name };\n+                let placeholder_mapped = ty::PlaceholderRegion { universe: universe_mapped, bound };\n                 self.tcx.mk_re_placeholder(placeholder_mapped).into()\n             }\n \n@@ -152,9 +152,9 @@ impl<'tcx> InferCtxt<'tcx> {\n                 )\n                 .into(),\n \n-            CanonicalVarKind::PlaceholderConst(ty::PlaceholderConst { universe, name }, ty) => {\n+            CanonicalVarKind::PlaceholderConst(ty::PlaceholderConst { universe, bound }, ty) => {\n                 let universe_mapped = universe_map(universe);\n-                let placeholder_mapped = ty::PlaceholderConst { universe: universe_mapped, name };\n+                let placeholder_mapped = ty::PlaceholderConst { universe: universe_mapped, bound };\n                 self.tcx.mk_const(placeholder_mapped, ty).into()\n             }\n         }"}, {"sha": "fe45b5ebe61b1106b0df57fbe4faff6753e1732d", "filename": "compiler/rustc_infer/src/infer/combine.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/6efdf4d1309f8047bc439a4810888c715e2df480/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcombine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6efdf4d1309f8047bc439a4810888c715e2df480/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcombine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcombine.rs?ref=6efdf4d1309f8047bc439a4810888c715e2df480", "patch": "@@ -137,6 +137,18 @@ impl<'tcx> InferCtxt<'tcx> {\n                 Err(TypeError::Sorts(ty::relate::expected_found(relation, a, b)))\n             }\n \n+            // During coherence, opaque types should be treated as *possibly*\n+            // equal to each other, even if their generic params differ, as\n+            // they could resolve to the same hidden type, even for different\n+            // generic params.\n+            (\n+                &ty::Alias(ty::Opaque, ty::AliasTy { def_id: a_def_id, .. }),\n+                &ty::Alias(ty::Opaque, ty::AliasTy { def_id: b_def_id, .. }),\n+            ) if self.intercrate && a_def_id == b_def_id => {\n+                relation.register_predicates([ty::Binder::dummy(ty::PredicateKind::Ambiguous)]);\n+                Ok(a)\n+            }\n+\n             _ => ty::relate::super_relate_tys(relation, a, b),\n         }\n     }\n@@ -505,10 +517,6 @@ impl<'infcx, 'tcx> CombineFields<'infcx, 'tcx> {\n             Obligation::new(self.infcx.tcx, self.trace.cause.clone(), self.param_env, to_pred)\n         }))\n     }\n-\n-    pub fn mark_ambiguous(&mut self) {\n-        self.register_predicates([ty::Binder::dummy(ty::PredicateKind::Ambiguous)]);\n-    }\n }\n \n struct Generalizer<'cx, 'tcx> {\n@@ -581,10 +589,6 @@ impl<'tcx> TypeRelation<'tcx> for Generalizer<'_, 'tcx> {\n         self.infcx.tcx\n     }\n \n-    fn intercrate(&self) -> bool {\n-        self.infcx.intercrate\n-    }\n-\n     fn param_env(&self) -> ty::ParamEnv<'tcx> {\n         self.param_env\n     }\n@@ -597,10 +601,6 @@ impl<'tcx> TypeRelation<'tcx> for Generalizer<'_, 'tcx> {\n         true\n     }\n \n-    fn mark_ambiguous(&mut self) {\n-        span_bug!(self.cause.span, \"opaque types are handled in `tys`\");\n-    }\n-\n     fn binders<T>(\n         &mut self,\n         a: ty::Binder<'tcx, T>,"}, {"sha": "fe4a2dd3800733b3da3c33320bb36f46bba30879", "filename": "compiler/rustc_infer/src/infer/equate.rs", "status": "modified", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/6efdf4d1309f8047bc439a4810888c715e2df480/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fequate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6efdf4d1309f8047bc439a4810888c715e2df480/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fequate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fequate.rs?ref=6efdf4d1309f8047bc439a4810888c715e2df480", "patch": "@@ -35,10 +35,6 @@ impl<'tcx> TypeRelation<'tcx> for Equate<'_, '_, 'tcx> {\n         self.fields.tcx()\n     }\n \n-    fn intercrate(&self) -> bool {\n-        self.fields.infcx.intercrate\n-    }\n-\n     fn param_env(&self) -> ty::ParamEnv<'tcx> {\n         self.fields.param_env\n     }\n@@ -47,10 +43,6 @@ impl<'tcx> TypeRelation<'tcx> for Equate<'_, '_, 'tcx> {\n         self.a_is_expected\n     }\n \n-    fn mark_ambiguous(&mut self) {\n-        self.fields.mark_ambiguous();\n-    }\n-\n     fn relate_item_substs(\n         &mut self,\n         _item_def_id: DefId,"}, {"sha": "86fca9797d029c73279811e648988f97bb7ca0bd", "filename": "compiler/rustc_infer/src/infer/error_reporting/mod.rs", "status": "modified", "additions": 5, "deletions": 14, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/6efdf4d1309f8047bc439a4810888c715e2df480/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6efdf4d1309f8047bc439a4810888c715e2df480/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fmod.rs?ref=6efdf4d1309f8047bc439a4810888c715e2df480", "patch": "@@ -170,15 +170,15 @@ fn msg_span_from_named_region<'tcx>(\n         }\n         ty::ReStatic => (\"the static lifetime\".to_owned(), alt_span),\n         ty::RePlaceholder(ty::PlaceholderRegion {\n-            name: ty::BoundRegionKind::BrNamed(def_id, name),\n+            bound: ty::BoundRegion { kind: ty::BoundRegionKind::BrNamed(def_id, name), .. },\n             ..\n         }) => (format!(\"the lifetime `{name}` as defined here\"), Some(tcx.def_span(def_id))),\n         ty::RePlaceholder(ty::PlaceholderRegion {\n-            name: ty::BoundRegionKind::BrAnon(_, Some(span)),\n+            bound: ty::BoundRegion { kind: ty::BoundRegionKind::BrAnon(Some(span)), .. },\n             ..\n         }) => (format!(\"the anonymous lifetime defined here\"), Some(span)),\n         ty::RePlaceholder(ty::PlaceholderRegion {\n-            name: ty::BoundRegionKind::BrAnon(_, None),\n+            bound: ty::BoundRegion { kind: ty::BoundRegionKind::BrAnon(None), .. },\n             ..\n         }) => (format!(\"an anonymous lifetime\"), None),\n         _ => bug!(\"{:?}\", region),\n@@ -226,8 +226,8 @@ fn msg_span_from_early_bound_and_free_regions<'tcx>(\n                         };\n                         (text, sp)\n                     }\n-                    ty::BrAnon(idx, span) => (\n-                        format!(\"the anonymous lifetime #{} defined here\", idx + 1),\n+                    ty::BrAnon(span) => (\n+                        \"the anonymous lifetime as defined here\".to_string(),\n                         match span {\n                             Some(span) => span,\n                             None => tcx.def_span(scope)\n@@ -2697,11 +2697,6 @@ impl<'tcx> TypeRelation<'tcx> for SameTypeModuloInfer<'_, 'tcx> {\n         self.0.tcx\n     }\n \n-    fn intercrate(&self) -> bool {\n-        assert!(!self.0.intercrate);\n-        false\n-    }\n-\n     fn param_env(&self) -> ty::ParamEnv<'tcx> {\n         // Unused, only for consts which we treat as always equal\n         ty::ParamEnv::empty()\n@@ -2715,10 +2710,6 @@ impl<'tcx> TypeRelation<'tcx> for SameTypeModuloInfer<'_, 'tcx> {\n         true\n     }\n \n-    fn mark_ambiguous(&mut self) {\n-        bug!()\n-    }\n-\n     fn relate_with_variance<T: relate::Relate<'tcx>>(\n         &mut self,\n         _variance: ty::Variance,"}, {"sha": "d7b900ca02d3e0bca860b237f0bd7842d8441258", "filename": "compiler/rustc_infer/src/infer/error_reporting/need_type_info.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/6efdf4d1309f8047bc439a4810888c715e2df480/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fneed_type_info.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6efdf4d1309f8047bc439a4810888c715e2df480/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fneed_type_info.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fneed_type_info.rs?ref=6efdf4d1309f8047bc439a4810888c715e2df480", "patch": "@@ -1191,11 +1191,14 @@ impl<'a, 'tcx> Visitor<'tcx> for FindInferSourceVisitor<'a, 'tcx> {\n                 have_turbofish,\n             } = args;\n             let generics = tcx.generics_of(generics_def_id);\n-            if let Some(argument_index) = generics\n+            if let Some(mut argument_index) = generics\n                 .own_substs(substs)\n                 .iter()\n                 .position(|&arg| self.generic_arg_contains_target(arg))\n             {\n+                if generics.parent.is_none() && generics.has_self {\n+                    argument_index += 1;\n+                }\n                 let substs = self.infcx.resolve_vars_if_possible(substs);\n                 let generic_args = &generics.own_substs_no_defaults(tcx, substs)\n                     [generics.own_counts().lifetimes..];"}, {"sha": "8a78a1956c9972673863f66d2c980609fa8733c5", "filename": "compiler/rustc_infer/src/infer/error_reporting/nice_region_error/placeholder_relation.rs", "status": "modified", "additions": 16, "deletions": 4, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/6efdf4d1309f8047bc439a4810888c715e2df480/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fplaceholder_relation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6efdf4d1309f8047bc439a4810888c715e2df480/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fplaceholder_relation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fplaceholder_relation.rs?ref=6efdf4d1309f8047bc439a4810888c715e2df480", "patch": "@@ -16,22 +16,34 @@ impl<'tcx> NiceRegionError<'_, 'tcx> {\n         match &self.error {\n             Some(RegionResolutionError::ConcreteFailure(\n                 SubregionOrigin::RelateRegionParamBound(span),\n-                Region(Interned(RePlaceholder(ty::Placeholder { name: sub_name, .. }), _)),\n-                Region(Interned(RePlaceholder(ty::Placeholder { name: sup_name, .. }), _)),\n+                Region(Interned(\n+                    RePlaceholder(ty::Placeholder {\n+                        bound: ty::BoundRegion { kind: sub_name, .. },\n+                        ..\n+                    }),\n+                    _,\n+                )),\n+                Region(Interned(\n+                    RePlaceholder(ty::Placeholder {\n+                        bound: ty::BoundRegion { kind: sup_name, .. },\n+                        ..\n+                    }),\n+                    _,\n+                )),\n             )) => {\n                 let span = *span;\n                 let (sub_span, sub_symbol) = match sub_name {\n                     ty::BrNamed(def_id, symbol) => {\n                         (Some(self.tcx().def_span(def_id)), Some(symbol))\n                     }\n-                    ty::BrAnon(_, span) => (*span, None),\n+                    ty::BrAnon(span) => (*span, None),\n                     ty::BrEnv => (None, None),\n                 };\n                 let (sup_span, sup_symbol) = match sup_name {\n                     ty::BrNamed(def_id, symbol) => {\n                         (Some(self.tcx().def_span(def_id)), Some(symbol))\n                     }\n-                    ty::BrAnon(_, span) => (*span, None),\n+                    ty::BrAnon(span) => (*span, None),\n                     ty::BrEnv => (None, None),\n                 };\n                 let diag = match (sub_span, sup_span, sub_symbol, sup_symbol) {"}, {"sha": "2f659d9a665273e58344fc90d7a23f017e672808", "filename": "compiler/rustc_infer/src/infer/glb.rs", "status": "modified", "additions": 0, "deletions": 9, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/6efdf4d1309f8047bc439a4810888c715e2df480/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fglb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6efdf4d1309f8047bc439a4810888c715e2df480/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fglb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fglb.rs?ref=6efdf4d1309f8047bc439a4810888c715e2df480", "patch": "@@ -29,11 +29,6 @@ impl<'tcx> TypeRelation<'tcx> for Glb<'_, '_, 'tcx> {\n         \"Glb\"\n     }\n \n-    fn intercrate(&self) -> bool {\n-        assert!(!self.fields.infcx.intercrate);\n-        false\n-    }\n-\n     fn tcx(&self) -> TyCtxt<'tcx> {\n         self.fields.tcx()\n     }\n@@ -46,10 +41,6 @@ impl<'tcx> TypeRelation<'tcx> for Glb<'_, '_, 'tcx> {\n         self.a_is_expected\n     }\n \n-    fn mark_ambiguous(&mut self) {\n-        bug!(\"mark_ambiguous used outside of coherence\");\n-    }\n-\n     fn relate_with_variance<T: Relate<'tcx>>(\n         &mut self,\n         variance: ty::Variance,"}, {"sha": "a63cfbc919c65caffeb6dae90ffad44136234444", "filename": "compiler/rustc_infer/src/infer/higher_ranked/mod.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/6efdf4d1309f8047bc439a4810888c715e2df480/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fhigher_ranked%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6efdf4d1309f8047bc439a4810888c715e2df480/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fhigher_ranked%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fhigher_ranked%2Fmod.rs?ref=6efdf4d1309f8047bc439a4810888c715e2df480", "patch": "@@ -82,20 +82,20 @@ impl<'tcx> InferCtxt<'tcx> {\n \n         let delegate = FnMutDelegate {\n             regions: &mut |br: ty::BoundRegion| {\n-                self.tcx.mk_re_placeholder(ty::PlaceholderRegion {\n-                    universe: next_universe,\n-                    name: br.kind,\n-                })\n+                self.tcx\n+                    .mk_re_placeholder(ty::PlaceholderRegion { universe: next_universe, bound: br })\n             },\n             types: &mut |bound_ty: ty::BoundTy| {\n                 self.tcx.mk_placeholder(ty::PlaceholderType {\n                     universe: next_universe,\n-                    name: bound_ty.kind,\n+                    bound: bound_ty,\n                 })\n             },\n             consts: &mut |bound_var: ty::BoundVar, ty| {\n-                self.tcx\n-                    .mk_const(ty::PlaceholderConst { universe: next_universe, name: bound_var }, ty)\n+                self.tcx.mk_const(\n+                    ty::PlaceholderConst { universe: next_universe, bound: bound_var },\n+                    ty,\n+                )\n             },\n         };\n "}, {"sha": "f298b95ca35b180d9843f49aa9152a01d4a7c2db", "filename": "compiler/rustc_infer/src/infer/lexical_region_resolve/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6efdf4d1309f8047bc439a4810888c715e2df480/compiler%2Frustc_infer%2Fsrc%2Finfer%2Flexical_region_resolve%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6efdf4d1309f8047bc439a4810888c715e2df480/compiler%2Frustc_infer%2Fsrc%2Finfer%2Flexical_region_resolve%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Flexical_region_resolve%2Fmod.rs?ref=6efdf4d1309f8047bc439a4810888c715e2df480", "patch": "@@ -203,7 +203,7 @@ impl<'cx, 'tcx> LexicalResolver<'cx, 'tcx> {\n \n         // Tracks the `VarSubVar` constraints generated for each region vid. We\n         // later use this to expand across vids.\n-        let mut constraints = IndexVec::from_elem_n(Vec::new(), var_values.values.len());\n+        let mut constraints = IndexVec::from_elem(Vec::new(), &var_values.values);\n         // Tracks the changed region vids.\n         let mut changes = Vec::new();\n         for constraint in self.data.constraints.keys() {"}, {"sha": "e41ec7e6c0105b76299109ceccdb53d9963df7a3", "filename": "compiler/rustc_infer/src/infer/lub.rs", "status": "modified", "additions": 0, "deletions": 9, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/6efdf4d1309f8047bc439a4810888c715e2df480/compiler%2Frustc_infer%2Fsrc%2Finfer%2Flub.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6efdf4d1309f8047bc439a4810888c715e2df480/compiler%2Frustc_infer%2Fsrc%2Finfer%2Flub.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Flub.rs?ref=6efdf4d1309f8047bc439a4810888c715e2df480", "patch": "@@ -29,11 +29,6 @@ impl<'tcx> TypeRelation<'tcx> for Lub<'_, '_, 'tcx> {\n         \"Lub\"\n     }\n \n-    fn intercrate(&self) -> bool {\n-        assert!(!self.fields.infcx.intercrate);\n-        false\n-    }\n-\n     fn tcx(&self) -> TyCtxt<'tcx> {\n         self.fields.tcx()\n     }\n@@ -46,10 +41,6 @@ impl<'tcx> TypeRelation<'tcx> for Lub<'_, '_, 'tcx> {\n         self.a_is_expected\n     }\n \n-    fn mark_ambiguous(&mut self) {\n-        bug!(\"mark_ambiguous used outside of coherence\");\n-    }\n-\n     fn relate_with_variance<T: Relate<'tcx>>(\n         &mut self,\n         variance: ty::Variance,"}, {"sha": "b4f2ad0bb34330b2c6c1b91ea69903145feb7308", "filename": "compiler/rustc_infer/src/infer/mod.rs", "status": "modified", "additions": 10, "deletions": 6, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/6efdf4d1309f8047bc439a4810888c715e2df480/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6efdf4d1309f8047bc439a4810888c715e2df480/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fmod.rs?ref=6efdf4d1309f8047bc439a4810888c715e2df480", "patch": "@@ -2130,13 +2130,17 @@ fn replace_param_and_infer_substs_with_placeholder<'tcx>(\n \n         fn fold_ty(&mut self, t: Ty<'tcx>) -> Ty<'tcx> {\n             if let ty::Infer(_) = t.kind() {\n+                let idx = {\n+                    let idx = self.idx;\n+                    self.idx += 1;\n+                    idx\n+                };\n                 self.tcx.mk_placeholder(ty::PlaceholderType {\n                     universe: ty::UniverseIndex::ROOT,\n-                    name: ty::BoundTyKind::Anon({\n-                        let idx = self.idx;\n-                        self.idx += 1;\n-                        idx\n-                    }),\n+                    bound: ty::BoundTy {\n+                        var: ty::BoundVar::from_u32(idx),\n+                        kind: ty::BoundTyKind::Anon,\n+                    },\n                 })\n             } else {\n                 t.super_fold_with(self)\n@@ -2153,7 +2157,7 @@ fn replace_param_and_infer_substs_with_placeholder<'tcx>(\n                 self.tcx.mk_const(\n                     ty::PlaceholderConst {\n                         universe: ty::UniverseIndex::ROOT,\n-                        name: ty::BoundVar::from_u32({\n+                        bound: ty::BoundVar::from_u32({\n                             let idx = self.idx;\n                             self.idx += 1;\n                             idx"}, {"sha": "9f7b26b87f459470fe756cf8d0223577a99ba83b", "filename": "compiler/rustc_infer/src/infer/nll_relate/mod.rs", "status": "modified", "additions": 1, "deletions": 25, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/6efdf4d1309f8047bc439a4810888c715e2df480/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fnll_relate%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6efdf4d1309f8047bc439a4810888c715e2df480/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fnll_relate%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fnll_relate%2Fmod.rs?ref=6efdf4d1309f8047bc439a4810888c715e2df480", "patch": "@@ -296,7 +296,7 @@ where\n                     universe\n                 });\n \n-                let placeholder = ty::PlaceholderRegion { universe, name: br.kind };\n+                let placeholder = ty::PlaceholderRegion { universe, bound: br };\n                 debug!(?placeholder);\n                 let placeholder_reg = nll_delegate.next_placeholder_region(placeholder);\n                 debug!(?placeholder_reg);\n@@ -443,10 +443,6 @@ where\n         self.infcx.tcx\n     }\n \n-    fn intercrate(&self) -> bool {\n-        self.infcx.intercrate\n-    }\n-\n     fn param_env(&self) -> ty::ParamEnv<'tcx> {\n         self.delegate.param_env()\n     }\n@@ -459,17 +455,6 @@ where\n         true\n     }\n \n-    fn mark_ambiguous(&mut self) {\n-        let cause = ObligationCause::dummy_with_span(self.delegate.span());\n-        let param_env = self.delegate.param_env();\n-        self.delegate.register_obligations(vec![Obligation::new(\n-            self.tcx(),\n-            cause,\n-            param_env,\n-            ty::Binder::dummy(ty::PredicateKind::Ambiguous),\n-        )]);\n-    }\n-\n     #[instrument(skip(self, info), level = \"trace\", ret)]\n     fn relate_with_variance<T: Relate<'tcx>>(\n         &mut self,\n@@ -834,11 +819,6 @@ where\n         self.infcx.tcx\n     }\n \n-    fn intercrate(&self) -> bool {\n-        assert!(!self.infcx.intercrate);\n-        false\n-    }\n-\n     fn param_env(&self) -> ty::ParamEnv<'tcx> {\n         self.delegate.param_env()\n     }\n@@ -851,10 +831,6 @@ where\n         true\n     }\n \n-    fn mark_ambiguous(&mut self) {\n-        bug!()\n-    }\n-\n     fn relate_with_variance<T: Relate<'tcx>>(\n         &mut self,\n         variance: ty::Variance,"}, {"sha": "01f900f050ee9f801113de4c99ec6f86ac5924ac", "filename": "compiler/rustc_infer/src/infer/outlives/test_type_match.rs", "status": "modified", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/6efdf4d1309f8047bc439a4810888c715e2df480/compiler%2Frustc_infer%2Fsrc%2Finfer%2Foutlives%2Ftest_type_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6efdf4d1309f8047bc439a4810888c715e2df480/compiler%2Frustc_infer%2Fsrc%2Finfer%2Foutlives%2Ftest_type_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Foutlives%2Ftest_type_match.rs?ref=6efdf4d1309f8047bc439a4810888c715e2df480", "patch": "@@ -137,10 +137,6 @@ impl<'tcx> TypeRelation<'tcx> for Match<'tcx> {\n         \"Match\"\n     }\n \n-    fn intercrate(&self) -> bool {\n-        false\n-    }\n-\n     fn tcx(&self) -> TyCtxt<'tcx> {\n         self.tcx\n     }\n@@ -151,10 +147,6 @@ impl<'tcx> TypeRelation<'tcx> for Match<'tcx> {\n         true\n     } // irrelevant\n \n-    fn mark_ambiguous(&mut self) {\n-        bug!()\n-    }\n-\n     #[instrument(level = \"trace\", skip(self))]\n     fn relate_with_variance<T: Relate<'tcx>>(\n         &mut self,"}, {"sha": "b8ba98fc0a9f53901f2b75d110c58c394da5c09c", "filename": "compiler/rustc_infer/src/infer/region_constraints/leak_check.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6efdf4d1309f8047bc439a4810888c715e2df480/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fregion_constraints%2Fleak_check.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6efdf4d1309f8047bc439a4810888c715e2df480/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fregion_constraints%2Fleak_check.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fregion_constraints%2Fleak_check.rs?ref=6efdf4d1309f8047bc439a4810888c715e2df480", "patch": "@@ -290,9 +290,9 @@ impl<'me, 'tcx> LeakCheck<'me, 'tcx> {\n     ) -> TypeError<'tcx> {\n         debug!(\"error: placeholder={:?}, other_region={:?}\", placeholder, other_region);\n         if self.overly_polymorphic {\n-            TypeError::RegionsOverlyPolymorphic(placeholder.name, other_region)\n+            TypeError::RegionsOverlyPolymorphic(placeholder.bound.kind, other_region)\n         } else {\n-            TypeError::RegionsInsufficientlyPolymorphic(placeholder.name, other_region)\n+            TypeError::RegionsInsufficientlyPolymorphic(placeholder.bound.kind, other_region)\n         }\n     }\n }"}, {"sha": "0dd73a6e999eefa64b093a279ad15cc02d880107", "filename": "compiler/rustc_infer/src/infer/sub.rs", "status": "modified", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/6efdf4d1309f8047bc439a4810888c715e2df480/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fsub.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6efdf4d1309f8047bc439a4810888c715e2df480/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fsub.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fsub.rs?ref=6efdf4d1309f8047bc439a4810888c715e2df480", "patch": "@@ -35,10 +35,6 @@ impl<'tcx> TypeRelation<'tcx> for Sub<'_, '_, 'tcx> {\n         \"Sub\"\n     }\n \n-    fn intercrate(&self) -> bool {\n-        self.fields.infcx.intercrate\n-    }\n-\n     fn tcx(&self) -> TyCtxt<'tcx> {\n         self.fields.infcx.tcx\n     }\n@@ -51,10 +47,6 @@ impl<'tcx> TypeRelation<'tcx> for Sub<'_, '_, 'tcx> {\n         self.a_is_expected\n     }\n \n-    fn mark_ambiguous(&mut self) {\n-        self.fields.mark_ambiguous()\n-    }\n-\n     fn with_cause<F, R>(&mut self, cause: Cause, f: F) -> R\n     where\n         F: FnOnce(&mut Self) -> R,"}, {"sha": "c7f7ed149407acaa297f9027f91b9e41c01b99fe", "filename": "compiler/rustc_infer/src/traits/util.rs", "status": "modified", "additions": 112, "deletions": 97, "changes": 209, "blob_url": "https://github.com/rust-lang/rust/blob/6efdf4d1309f8047bc439a4810888c715e2df480/compiler%2Frustc_infer%2Fsrc%2Ftraits%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6efdf4d1309f8047bc439a4810888c715e2df480/compiler%2Frustc_infer%2Fsrc%2Ftraits%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Ftraits%2Futil.rs?ref=6efdf4d1309f8047bc439a4810888c715e2df480", "patch": "@@ -1,7 +1,7 @@\n use smallvec::smallvec;\n \n use crate::infer::outlives::components::{push_outlives_components, Component};\n-use crate::traits::{self, Obligation, ObligationCause, PredicateObligation};\n+use crate::traits::{self, Obligation, PredicateObligation};\n use rustc_data_structures::fx::{FxHashSet, FxIndexSet};\n use rustc_middle::ty::{self, ToPredicate, TyCtxt};\n use rustc_span::symbol::Ident;\n@@ -66,99 +66,129 @@ impl<'tcx> Extend<ty::Predicate<'tcx>> for PredicateSet<'tcx> {\n /// if we know that `T: Ord`, the elaborator would deduce that `T: PartialOrd`\n /// holds as well. Similarly, if we have `trait Foo: 'static`, and we know that\n /// `T: Foo`, then we know that `T: 'static`.\n-pub struct Elaborator<'tcx> {\n-    stack: Vec<PredicateObligation<'tcx>>,\n+pub struct Elaborator<'tcx, O> {\n+    stack: Vec<O>,\n     visited: PredicateSet<'tcx>,\n }\n \n-pub fn elaborate_trait_ref<'tcx>(\n-    tcx: TyCtxt<'tcx>,\n-    trait_ref: ty::PolyTraitRef<'tcx>,\n-) -> impl Iterator<Item = ty::Predicate<'tcx>> {\n-    elaborate_predicates(tcx, std::iter::once(trait_ref.without_const().to_predicate(tcx)))\n+/// Describes how to elaborate an obligation into a sub-obligation.\n+///\n+/// For [`Obligation`], a sub-obligation is combined with the current obligation's\n+/// param-env and cause code. For [`ty::Predicate`], none of this is needed, since\n+/// there is no param-env or cause code to copy over.\n+pub trait Elaboratable<'tcx> {\n+    fn predicate(&self) -> ty::Predicate<'tcx>;\n+\n+    // Makes a new `Self` but with a different predicate.\n+    fn child(&self, predicate: ty::Predicate<'tcx>) -> Self;\n+\n+    // Makes a new `Self` but with a different predicate and a different cause\n+    // code (if `Self` has one).\n+    fn child_with_derived_cause(\n+        &self,\n+        predicate: ty::Predicate<'tcx>,\n+        span: Span,\n+        parent_trait_pred: ty::PolyTraitPredicate<'tcx>,\n+        index: usize,\n+    ) -> Self;\n }\n \n-pub fn elaborate_trait_refs<'tcx>(\n-    tcx: TyCtxt<'tcx>,\n-    trait_refs: impl Iterator<Item = ty::PolyTraitRef<'tcx>>,\n-) -> impl Iterator<Item = ty::Predicate<'tcx>> {\n-    let predicates = trait_refs.map(move |trait_ref| trait_ref.without_const().to_predicate(tcx));\n-    elaborate_predicates(tcx, predicates)\n+impl<'tcx> Elaboratable<'tcx> for PredicateObligation<'tcx> {\n+    fn predicate(&self) -> ty::Predicate<'tcx> {\n+        self.predicate\n+    }\n+\n+    fn child(&self, predicate: ty::Predicate<'tcx>) -> Self {\n+        Obligation {\n+            cause: self.cause.clone(),\n+            param_env: self.param_env,\n+            recursion_depth: 0,\n+            predicate,\n+        }\n+    }\n+\n+    fn child_with_derived_cause(\n+        &self,\n+        predicate: ty::Predicate<'tcx>,\n+        span: Span,\n+        parent_trait_pred: ty::PolyTraitPredicate<'tcx>,\n+        index: usize,\n+    ) -> Self {\n+        let cause = self.cause.clone().derived_cause(parent_trait_pred, |derived| {\n+            traits::ImplDerivedObligation(Box::new(traits::ImplDerivedObligationCause {\n+                derived,\n+                impl_or_alias_def_id: parent_trait_pred.def_id(),\n+                impl_def_predicate_index: Some(index),\n+                span,\n+            }))\n+        });\n+        Obligation { cause, param_env: self.param_env, recursion_depth: 0, predicate }\n+    }\n }\n \n-pub fn elaborate_predicates<'tcx>(\n-    tcx: TyCtxt<'tcx>,\n-    predicates: impl Iterator<Item = ty::Predicate<'tcx>>,\n-) -> impl Iterator<Item = ty::Predicate<'tcx>> {\n-    elaborate_obligations(\n-        tcx,\n-        predicates\n-            .map(|predicate| {\n-                Obligation::new(\n-                    tcx,\n-                    // We'll dump the cause/param-env later\n-                    ObligationCause::dummy(),\n-                    ty::ParamEnv::empty(),\n-                    predicate,\n-                )\n-            })\n-            .collect(),\n-    )\n-    .map(|obl| obl.predicate)\n+impl<'tcx> Elaboratable<'tcx> for ty::Predicate<'tcx> {\n+    fn predicate(&self) -> ty::Predicate<'tcx> {\n+        *self\n+    }\n+\n+    fn child(&self, predicate: ty::Predicate<'tcx>) -> Self {\n+        predicate\n+    }\n+\n+    fn child_with_derived_cause(\n+        &self,\n+        predicate: ty::Predicate<'tcx>,\n+        _span: Span,\n+        _parent_trait_pred: ty::PolyTraitPredicate<'tcx>,\n+        _index: usize,\n+    ) -> Self {\n+        predicate\n+    }\n }\n \n-pub fn elaborate_predicates_with_span<'tcx>(\n-    tcx: TyCtxt<'tcx>,\n-    predicates: impl Iterator<Item = (ty::Predicate<'tcx>, Span)>,\n-) -> impl Iterator<Item = (ty::Predicate<'tcx>, Span)> {\n-    elaborate_obligations(\n-        tcx,\n-        predicates\n-            .map(|(predicate, span)| {\n-                Obligation::new(\n-                    tcx,\n-                    // We'll dump the cause/param-env later\n-                    ObligationCause::dummy_with_span(span),\n-                    ty::ParamEnv::empty(),\n-                    predicate,\n-                )\n-            })\n-            .collect(),\n-    )\n-    .map(|obl| (obl.predicate, obl.cause.span))\n+impl<'tcx> Elaboratable<'tcx> for (ty::Predicate<'tcx>, Span) {\n+    fn predicate(&self) -> ty::Predicate<'tcx> {\n+        self.0\n+    }\n+\n+    fn child(&self, predicate: ty::Predicate<'tcx>) -> Self {\n+        (predicate, self.1)\n+    }\n+\n+    fn child_with_derived_cause(\n+        &self,\n+        predicate: ty::Predicate<'tcx>,\n+        _span: Span,\n+        _parent_trait_pred: ty::PolyTraitPredicate<'tcx>,\n+        _index: usize,\n+    ) -> Self {\n+        (predicate, self.1)\n+    }\n }\n \n-pub fn elaborate_obligations<'tcx>(\n+pub fn elaborate<'tcx, O: Elaboratable<'tcx>>(\n     tcx: TyCtxt<'tcx>,\n-    obligations: Vec<PredicateObligation<'tcx>>,\n-) -> Elaborator<'tcx> {\n+    obligations: impl IntoIterator<Item = O>,\n+) -> Elaborator<'tcx, O> {\n     let mut elaborator = Elaborator { stack: Vec::new(), visited: PredicateSet::new(tcx) };\n     elaborator.extend_deduped(obligations);\n     elaborator\n }\n \n-fn predicate_obligation<'tcx>(\n-    predicate: ty::Predicate<'tcx>,\n-    param_env: ty::ParamEnv<'tcx>,\n-    cause: ObligationCause<'tcx>,\n-) -> PredicateObligation<'tcx> {\n-    Obligation { cause, param_env, recursion_depth: 0, predicate }\n-}\n-\n-impl<'tcx> Elaborator<'tcx> {\n-    fn extend_deduped(&mut self, obligations: impl IntoIterator<Item = PredicateObligation<'tcx>>) {\n+impl<'tcx, O: Elaboratable<'tcx>> Elaborator<'tcx, O> {\n+    fn extend_deduped(&mut self, obligations: impl IntoIterator<Item = O>) {\n         // Only keep those bounds that we haven't already seen.\n         // This is necessary to prevent infinite recursion in some\n         // cases. One common case is when people define\n         // `trait Sized: Sized { }` rather than `trait Sized { }`.\n         // let visited = &mut self.visited;\n-        self.stack.extend(obligations.into_iter().filter(|o| self.visited.insert(o.predicate)));\n+        self.stack.extend(obligations.into_iter().filter(|o| self.visited.insert(o.predicate())));\n     }\n \n-    fn elaborate(&mut self, obligation: &PredicateObligation<'tcx>) {\n+    fn elaborate(&mut self, elaboratable: &O) {\n         let tcx = self.visited.tcx;\n \n-        let bound_predicate = obligation.predicate.kind();\n+        let bound_predicate = elaboratable.predicate().kind();\n         match bound_predicate.skip_binder() {\n             ty::PredicateKind::Clause(ty::Clause::Trait(data)) => {\n                 // Get predicates declared on the trait.\n@@ -170,24 +200,11 @@ impl<'tcx> Elaborator<'tcx> {\n                         if data.constness == ty::BoundConstness::NotConst {\n                             pred = pred.without_const(tcx);\n                         }\n-\n-                        let cause = obligation.cause.clone().derived_cause(\n-                            bound_predicate.rebind(data),\n-                            |derived| {\n-                                traits::ImplDerivedObligation(Box::new(\n-                                    traits::ImplDerivedObligationCause {\n-                                        derived,\n-                                        impl_or_alias_def_id: data.def_id(),\n-                                        impl_def_predicate_index: Some(index),\n-                                        span,\n-                                    },\n-                                ))\n-                            },\n-                        );\n-                        predicate_obligation(\n+                        elaboratable.child_with_derived_cause(\n                             pred.subst_supertrait(tcx, &bound_predicate.rebind(data.trait_ref)),\n-                            obligation.param_env,\n-                            cause,\n+                            span,\n+                            bound_predicate.rebind(data),\n+                            index,\n                         )\n                     });\n                 debug!(?data, ?obligations, \"super_predicates\");\n@@ -290,13 +307,7 @@ impl<'tcx> Elaborator<'tcx> {\n                         .map(|predicate_kind| {\n                             bound_predicate.rebind(predicate_kind).to_predicate(tcx)\n                         })\n-                        .map(|predicate| {\n-                            predicate_obligation(\n-                                predicate,\n-                                obligation.param_env,\n-                                obligation.cause.clone(),\n-                            )\n-                        }),\n+                        .map(|predicate| elaboratable.child(predicate)),\n                 );\n             }\n             ty::PredicateKind::TypeWellFormedFromEnv(..) => {\n@@ -313,8 +324,8 @@ impl<'tcx> Elaborator<'tcx> {\n     }\n }\n \n-impl<'tcx> Iterator for Elaborator<'tcx> {\n-    type Item = PredicateObligation<'tcx>;\n+impl<'tcx, O: Elaboratable<'tcx>> Iterator for Elaborator<'tcx, O> {\n+    type Item = O;\n \n     fn size_hint(&self) -> (usize, Option<usize>) {\n         (self.stack.len(), None)\n@@ -339,17 +350,21 @@ pub fn supertraits<'tcx>(\n     tcx: TyCtxt<'tcx>,\n     trait_ref: ty::PolyTraitRef<'tcx>,\n ) -> impl Iterator<Item = ty::PolyTraitRef<'tcx>> {\n-    FilterToTraits::new(elaborate_trait_ref(tcx, trait_ref))\n+    let pred: ty::Predicate<'tcx> = trait_ref.to_predicate(tcx);\n+    FilterToTraits::new(elaborate(tcx, [pred]))\n }\n \n pub fn transitive_bounds<'tcx>(\n     tcx: TyCtxt<'tcx>,\n     trait_refs: impl Iterator<Item = ty::PolyTraitRef<'tcx>>,\n ) -> impl Iterator<Item = ty::PolyTraitRef<'tcx>> {\n-    FilterToTraits::new(elaborate_trait_refs(tcx, trait_refs))\n+    FilterToTraits::new(elaborate(\n+        tcx,\n+        trait_refs.map(|trait_ref| -> ty::Predicate<'tcx> { trait_ref.to_predicate(tcx) }),\n+    ))\n }\n \n-/// A specialized variant of `elaborate_trait_refs` that only elaborates trait references that may\n+/// A specialized variant of `elaborate` that only elaborates trait references that may\n /// define the given associated type `assoc_name`. It uses the\n /// `super_predicates_that_define_assoc_type` query to avoid enumerating super-predicates that\n /// aren't related to `assoc_item`. This is used when resolving types like `Self::Item` or"}, {"sha": "0e4e20c7cd1d4de48821d8d2369de0c3dc87dcb1", "filename": "compiler/rustc_interface/src/passes.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/6efdf4d1309f8047bc439a4810888c715e2df480/compiler%2Frustc_interface%2Fsrc%2Fpasses.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6efdf4d1309f8047bc439a4810888c715e2df480/compiler%2Frustc_interface%2Fsrc%2Fpasses.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_interface%2Fsrc%2Fpasses.rs?ref=6efdf4d1309f8047bc439a4810888c715e2df480", "patch": "@@ -230,7 +230,7 @@ fn configure_and_expand(\n             features: Some(features),\n             recursion_limit,\n             trace_mac: sess.opts.unstable_opts.trace_macros,\n-            should_test: sess.opts.test,\n+            should_test: sess.is_test_crate(),\n             span_debug: sess.opts.unstable_opts.span_debug,\n             proc_macro_backtrace: sess.opts.unstable_opts.proc_macro_backtrace,\n             ..rustc_expand::expand::ExpansionConfig::default(crate_name.to_string())\n@@ -292,7 +292,7 @@ fn configure_and_expand(\n     }\n \n     sess.time(\"maybe_create_a_macro_crate\", || {\n-        let is_test_crate = sess.opts.test;\n+        let is_test_crate = sess.is_test_crate();\n         rustc_builtin_macros::proc_macro_harness::inject(\n             &mut krate,\n             sess,\n@@ -765,7 +765,7 @@ fn analysis(tcx: TyCtxt<'_>, (): ()) -> Result<()> {\n         parallel!(\n             {\n                 sess.time(\"match_checking\", || {\n-                    tcx.hir().par_body_owners(|def_id| tcx.ensure().check_match(def_id.to_def_id()))\n+                    tcx.hir().par_body_owners(|def_id| tcx.ensure().check_match(def_id))\n                 });\n             },\n             {"}, {"sha": "818f450a58c16c2e10218462cb906f7ce0c937c2", "filename": "compiler/rustc_interface/src/queries.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6efdf4d1309f8047bc439a4810888c715e2df480/compiler%2Frustc_interface%2Fsrc%2Fqueries.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6efdf4d1309f8047bc439a4810888c715e2df480/compiler%2Frustc_interface%2Fsrc%2Fqueries.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_interface%2Fsrc%2Fqueries.rs?ref=6efdf4d1309f8047bc439a4810888c715e2df480", "patch": "@@ -7,7 +7,7 @@ use rustc_codegen_ssa::traits::CodegenBackend;\n use rustc_codegen_ssa::CodegenResults;\n use rustc_data_structures::steal::Steal;\n use rustc_data_structures::svh::Svh;\n-use rustc_data_structures::sync::{AppendOnlyVec, Lrc, OnceCell, RwLock, WorkerLocal};\n+use rustc_data_structures::sync::{AppendOnlyIndexVec, Lrc, OnceCell, RwLock, WorkerLocal};\n use rustc_hir::def_id::{CRATE_DEF_ID, LOCAL_CRATE};\n use rustc_hir::definitions::Definitions;\n use rustc_incremental::DepGraphFuture;\n@@ -215,7 +215,7 @@ impl<'tcx> Queries<'tcx> {\n \n             let cstore = RwLock::new(Box::new(CStore::new(sess)) as _);\n             let definitions = RwLock::new(Definitions::new(sess.local_stable_crate_id()));\n-            let source_span = AppendOnlyVec::new();\n+            let source_span = AppendOnlyIndexVec::new();\n             let _id = source_span.push(krate.spans.inner_span);\n             debug_assert_eq!(_id, CRATE_DEF_ID);\n             let untracked = Untracked { cstore, source_span, definitions };"}, {"sha": "10dfd32d418a21c443258dccf50dcffc78d7ac5b", "filename": "compiler/rustc_interface/src/tests.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/6efdf4d1309f8047bc439a4810888c715e2df480/compiler%2Frustc_interface%2Fsrc%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6efdf4d1309f8047bc439a4810888c715e2df480/compiler%2Frustc_interface%2Fsrc%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_interface%2Fsrc%2Ftests.rs?ref=6efdf4d1309f8047bc439a4810888c715e2df480", "patch": "@@ -5,6 +5,7 @@ use rustc_data_structures::fx::FxHashSet;\n use rustc_data_structures::profiling::TimePassesFormat;\n use rustc_errors::{emitter::HumanReadableErrorType, registry, ColorConfig};\n use rustc_session::config::rustc_optgroups;\n+use rustc_session::config::DebugInfo;\n use rustc_session::config::Input;\n use rustc_session::config::InstrumentXRay;\n use rustc_session::config::TraitSolver;\n@@ -574,7 +575,7 @@ fn test_codegen_options_tracking_hash() {\n     tracked!(code_model, Some(CodeModel::Large));\n     tracked!(control_flow_guard, CFGuard::Checks);\n     tracked!(debug_assertions, Some(true));\n-    tracked!(debuginfo, 0xdeadbeef);\n+    tracked!(debuginfo, DebugInfo::Limited);\n     tracked!(embed_bitcode, false);\n     tracked!(force_frame_pointers, Some(false));\n     tracked!(force_unwind_tables, Some(true));"}, {"sha": "6b387df785e7df66b80784e83e8c38ef86db327d", "filename": "compiler/rustc_lint/src/builtin.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6efdf4d1309f8047bc439a4810888c715e2df480/compiler%2Frustc_lint%2Fsrc%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6efdf4d1309f8047bc439a4810888c715e2df480/compiler%2Frustc_lint%2Fsrc%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Fbuiltin.rs?ref=6efdf4d1309f8047bc439a4810888c715e2df480", "patch": "@@ -1947,7 +1947,7 @@ impl KeywordIdents {\n         };\n \n         // Don't lint `r#foo`.\n-        if cx.sess().parse_sess.raw_identifier_spans.borrow().contains(&ident.span) {\n+        if cx.sess().parse_sess.raw_identifier_spans.contains(ident.span) {\n             return;\n         }\n "}, {"sha": "a2a7c93a7ca957428f50531e84b55364c8779548", "filename": "compiler/rustc_lint/src/levels.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/6efdf4d1309f8047bc439a4810888c715e2df480/compiler%2Frustc_lint%2Fsrc%2Flevels.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6efdf4d1309f8047bc439a4810888c715e2df480/compiler%2Frustc_lint%2Fsrc%2Flevels.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Flevels.rs?ref=6efdf4d1309f8047bc439a4810888c715e2df480", "patch": "@@ -266,12 +266,12 @@ impl LintLevelsProvider for QueryMapExpectationsWrapper<'_> {\n         let LintExpectationId::Stable { attr_id: Some(attr_id), hir_id, attr_index, .. } = id else { bug!(\"unstable expectation id should already be mapped\") };\n         let key = LintExpectationId::Unstable { attr_id, lint_index: None };\n \n-        if !self.unstable_to_stable_ids.contains_key(&key) {\n-            self.unstable_to_stable_ids.insert(\n-                key,\n-                LintExpectationId::Stable { hir_id, attr_index, lint_index: None, attr_id: None },\n-            );\n-        }\n+        self.unstable_to_stable_ids.entry(key).or_insert(LintExpectationId::Stable {\n+            hir_id,\n+            attr_index,\n+            lint_index: None,\n+            attr_id: None,\n+        });\n \n         self.expectations.push((id.normalize(), expectation));\n     }"}, {"sha": "4c25d94a1f3726f8150418701a19898bc0c1df4b", "filename": "compiler/rustc_lint/src/methods.rs", "status": "modified", "additions": 8, "deletions": 41, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/6efdf4d1309f8047bc439a4810888c715e2df480/compiler%2Frustc_lint%2Fsrc%2Fmethods.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6efdf4d1309f8047bc439a4810888c715e2df480/compiler%2Frustc_lint%2Fsrc%2Fmethods.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Fmethods.rs?ref=6efdf4d1309f8047bc439a4810888c715e2df480", "patch": "@@ -2,9 +2,9 @@ use crate::lints::CStringPtr;\n use crate::LateContext;\n use crate::LateLintPass;\n use crate::LintContext;\n-use rustc_hir::{Expr, ExprKind, PathSegment};\n+use rustc_hir::{Expr, ExprKind};\n use rustc_middle::ty;\n-use rustc_span::{symbol::sym, ExpnKind, Span};\n+use rustc_span::{symbol::sym, Span};\n \n declare_lint! {\n     /// The `temporary_cstring_as_ptr` lint detects getting the inner pointer of\n@@ -34,47 +34,14 @@ declare_lint! {\n \n declare_lint_pass!(TemporaryCStringAsPtr => [TEMPORARY_CSTRING_AS_PTR]);\n \n-fn in_macro(span: Span) -> bool {\n-    if span.from_expansion() {\n-        !matches!(span.ctxt().outer_expn_data().kind, ExpnKind::Desugaring(..))\n-    } else {\n-        false\n-    }\n-}\n-\n-fn first_method_call<'tcx>(\n-    expr: &'tcx Expr<'tcx>,\n-) -> Option<(&'tcx PathSegment<'tcx>, &'tcx Expr<'tcx>)> {\n-    if let ExprKind::MethodCall(path, receiver, args, ..) = &expr.kind {\n-        if args.iter().any(|e| e.span.from_expansion()) || receiver.span.from_expansion() {\n-            None\n-        } else {\n-            Some((path, *receiver))\n-        }\n-    } else {\n-        None\n-    }\n-}\n-\n impl<'tcx> LateLintPass<'tcx> for TemporaryCStringAsPtr {\n     fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) {\n-        if in_macro(expr.span) {\n-            return;\n-        }\n-\n-        match first_method_call(expr) {\n-            Some((path, unwrap_arg)) if path.ident.name == sym::as_ptr => {\n-                let as_ptr_span = path.ident.span;\n-                match first_method_call(unwrap_arg) {\n-                    Some((path, receiver))\n-                        if path.ident.name == sym::unwrap || path.ident.name == sym::expect =>\n-                    {\n-                        lint_cstring_as_ptr(cx, as_ptr_span, receiver, unwrap_arg);\n-                    }\n-                    _ => return,\n-                }\n-            }\n-            _ => return,\n+        if let ExprKind::MethodCall(as_ptr_path, as_ptr_receiver, ..) = expr.kind\n+            && as_ptr_path.ident.name == sym::as_ptr\n+            && let ExprKind::MethodCall(unwrap_path, unwrap_receiver, ..) = as_ptr_receiver.kind\n+            && (unwrap_path.ident.name == sym::unwrap || unwrap_path.ident.name == sym::expect)\n+        {\n+            lint_cstring_as_ptr(cx, as_ptr_path.ident.span, unwrap_receiver, as_ptr_receiver);\n         }\n     }\n }"}, {"sha": "35c461f5acee81f78e8fb1f2026aa7620e315874", "filename": "compiler/rustc_lint/src/unused.rs", "status": "modified", "additions": 19, "deletions": 20, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/6efdf4d1309f8047bc439a4810888c715e2df480/compiler%2Frustc_lint%2Fsrc%2Funused.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6efdf4d1309f8047bc439a4810888c715e2df480/compiler%2Frustc_lint%2Fsrc%2Funused.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Funused.rs?ref=6efdf4d1309f8047bc439a4810888c715e2df480", "patch": "@@ -12,7 +12,7 @@ use rustc_errors::{pluralize, MultiSpan};\n use rustc_hir as hir;\n use rustc_hir::def::{DefKind, Res};\n use rustc_hir::def_id::DefId;\n-use rustc_infer::traits::util::elaborate_predicates_with_span;\n+use rustc_infer::traits::util::elaborate;\n use rustc_middle::ty::adjustment;\n use rustc_middle::ty::{self, Ty};\n use rustc_span::symbol::Symbol;\n@@ -254,24 +254,21 @@ impl<'tcx> LateLintPass<'tcx> for UnusedResults {\n                 }\n                 ty::Adt(def, _) => is_def_must_use(cx, def.did(), span),\n                 ty::Alias(ty::Opaque, ty::AliasTy { def_id: def, .. }) => {\n-                    elaborate_predicates_with_span(\n-                        cx.tcx,\n-                        cx.tcx.explicit_item_bounds(def).iter().cloned(),\n-                    )\n-                    .find_map(|(pred, _span)| {\n-                        // We only look at the `DefId`, so it is safe to skip the binder here.\n-                        if let ty::PredicateKind::Clause(ty::Clause::Trait(\n-                            ref poly_trait_predicate,\n-                        )) = pred.kind().skip_binder()\n-                        {\n-                            let def_id = poly_trait_predicate.trait_ref.def_id;\n-\n-                            is_def_must_use(cx, def_id, span)\n-                        } else {\n-                            None\n-                        }\n-                    })\n-                    .map(|inner| MustUsePath::Opaque(Box::new(inner)))\n+                    elaborate(cx.tcx, cx.tcx.explicit_item_bounds(def).iter().cloned())\n+                        .find_map(|(pred, _span)| {\n+                            // We only look at the `DefId`, so it is safe to skip the binder here.\n+                            if let ty::PredicateKind::Clause(ty::Clause::Trait(\n+                                ref poly_trait_predicate,\n+                            )) = pred.kind().skip_binder()\n+                            {\n+                                let def_id = poly_trait_predicate.trait_ref.def_id;\n+\n+                                is_def_must_use(cx, def_id, span)\n+                            } else {\n+                                None\n+                            }\n+                        })\n+                        .map(|inner| MustUsePath::Opaque(Box::new(inner)))\n                 }\n                 ty::Dynamic(binders, _, _) => binders.iter().find_map(|predicate| {\n                     if let ty::ExistentialPredicate::Trait(ref trait_ref) = predicate.skip_binder()\n@@ -805,7 +802,9 @@ trait UnusedDelimLint {\n     fn check_item(&mut self, cx: &EarlyContext<'_>, item: &ast::Item) {\n         use ast::ItemKind::*;\n \n-        if let Const(.., Some(expr)) | Static(.., Some(expr)) = &item.kind {\n+        if let Const(box ast::ConstItem { expr: Some(expr), .. })\n+        | Static(box ast::StaticItem { expr: Some(expr), .. }) = &item.kind\n+        {\n             self.check_unused_delims_expr(\n                 cx,\n                 expr,"}, {"sha": "cadb6b1e23fe9d2597a7436ec5729da7101d2fdb", "filename": "compiler/rustc_llvm/llvm-wrapper/RustWrapper.cpp", "status": "modified", "additions": 6, "deletions": 74, "changes": 80, "blob_url": "https://github.com/rust-lang/rust/blob/6efdf4d1309f8047bc439a4810888c715e2df480/compiler%2Frustc_llvm%2Fllvm-wrapper%2FRustWrapper.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/6efdf4d1309f8047bc439a4810888c715e2df480/compiler%2Frustc_llvm%2Fllvm-wrapper%2FRustWrapper.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_llvm%2Fllvm-wrapper%2FRustWrapper.cpp?ref=6efdf4d1309f8047bc439a4810888c715e2df480", "patch": "@@ -152,10 +152,6 @@ LLVMRustInsertPrivateGlobal(LLVMModuleRef M, LLVMTypeRef Ty) {\n                                  nullptr));\n }\n \n-extern \"C\" LLVMTypeRef LLVMRustMetadataTypeInContext(LLVMContextRef C) {\n-  return wrap(Type::getMetadataTy(*unwrap(C)));\n-}\n-\n static Attribute::AttrKind fromRust(LLVMRustAttribute Kind) {\n   switch (Kind) {\n   case AlwaysInline:\n@@ -480,11 +476,6 @@ extern \"C\" bool LLVMRustInlineAsmVerify(LLVMTypeRef Ty, char *Constraints,\n #endif\n }\n \n-extern \"C\" void LLVMRustAppendModuleInlineAsm(LLVMModuleRef M, const char *Asm,\n-                                              size_t AsmLen) {\n-  unwrap(M)->appendModuleInlineAsm(StringRef(Asm, AsmLen));\n-}\n-\n typedef DIBuilder *LLVMRustDIBuilderRef;\n \n template <typename DIT> DIT *unwrapDIPtr(LLVMMetadataRef Ref) {\n@@ -682,6 +673,7 @@ enum class LLVMRustDebugEmissionKind {\n   NoDebug,\n   FullDebug,\n   LineTablesOnly,\n+  DebugDirectivesOnly,\n };\n \n static DICompileUnit::DebugEmissionKind fromRust(LLVMRustDebugEmissionKind Kind) {\n@@ -692,6 +684,8 @@ static DICompileUnit::DebugEmissionKind fromRust(LLVMRustDebugEmissionKind Kind)\n     return DICompileUnit::DebugEmissionKind::FullDebug;\n   case LLVMRustDebugEmissionKind::LineTablesOnly:\n     return DICompileUnit::DebugEmissionKind::LineTablesOnly;\n+  case LLVMRustDebugEmissionKind::DebugDirectivesOnly:\n+    return DICompileUnit::DebugEmissionKind::DebugDirectivesOnly;\n   default:\n     report_fatal_error(\"bad DebugEmissionKind.\");\n   }\n@@ -750,10 +744,6 @@ extern \"C\" bool LLVMRustHasModuleFlag(LLVMModuleRef M, const char *Name,\n   return unwrap(M)->getModuleFlag(StringRef(Name, Len)) != nullptr;\n }\n \n-extern \"C\" LLVMValueRef LLVMRustMetadataAsValue(LLVMContextRef C, LLVMMetadataRef MD) {\n-  return wrap(MetadataAsValue::get(*unwrap(C), unwrap(MD)));\n-}\n-\n extern \"C\" void LLVMRustGlobalAddMetadata(\n     LLVMValueRef Global, unsigned Kind, LLVMMetadataRef MD) {\n   unwrap<GlobalObject>(Global)->addMetadata(Kind, *unwrap<MDNode>(MD));\n@@ -1150,6 +1140,8 @@ extern \"C\" void LLVMRustWriteValueToString(LLVMValueRef V,\n }\n \n // LLVMArrayType function does not support 64-bit ElementCount\n+// FIXME: replace with LLVMArrayType2 when bumped minimal version to llvm-17\n+// https://github.com/llvm/llvm-project/commit/35276f16e5a2cae0dfb49c0fbf874d4d2f177acc\n extern \"C\" LLVMTypeRef LLVMRustArrayType(LLVMTypeRef ElementTy,\n                                          uint64_t ElementCount) {\n   return wrap(ArrayType::get(unwrap(ElementTy), ElementCount));\n@@ -1405,61 +1397,6 @@ extern \"C\" bool LLVMRustUnpackSMDiagnostic(LLVMSMDiagnosticRef DRef,\n   return true;\n }\n \n-extern \"C\" LLVMValueRef LLVMRustBuildCleanupPad(LLVMBuilderRef B,\n-                                                LLVMValueRef ParentPad,\n-                                                unsigned ArgCount,\n-                                                LLVMValueRef *LLArgs,\n-                                                const char *Name) {\n-  Value **Args = unwrap(LLArgs);\n-  if (ParentPad == nullptr) {\n-    Type *Ty = Type::getTokenTy(unwrap(B)->getContext());\n-    ParentPad = wrap(Constant::getNullValue(Ty));\n-  }\n-  return wrap(unwrap(B)->CreateCleanupPad(\n-      unwrap(ParentPad), ArrayRef<Value *>(Args, ArgCount), Name));\n-}\n-\n-extern \"C\" LLVMValueRef LLVMRustBuildCleanupRet(LLVMBuilderRef B,\n-                                                LLVMValueRef CleanupPad,\n-                                                LLVMBasicBlockRef UnwindBB) {\n-  CleanupPadInst *Inst = cast<CleanupPadInst>(unwrap(CleanupPad));\n-  return wrap(unwrap(B)->CreateCleanupRet(Inst, unwrap(UnwindBB)));\n-}\n-\n-extern \"C\" LLVMValueRef\n-LLVMRustBuildCatchPad(LLVMBuilderRef B, LLVMValueRef ParentPad,\n-                      unsigned ArgCount, LLVMValueRef *LLArgs, const char *Name) {\n-  Value **Args = unwrap(LLArgs);\n-  return wrap(unwrap(B)->CreateCatchPad(\n-      unwrap(ParentPad), ArrayRef<Value *>(Args, ArgCount), Name));\n-}\n-\n-extern \"C\" LLVMValueRef LLVMRustBuildCatchRet(LLVMBuilderRef B,\n-                                              LLVMValueRef Pad,\n-                                              LLVMBasicBlockRef BB) {\n-  return wrap(unwrap(B)->CreateCatchRet(cast<CatchPadInst>(unwrap(Pad)),\n-                                              unwrap(BB)));\n-}\n-\n-extern \"C\" LLVMValueRef LLVMRustBuildCatchSwitch(LLVMBuilderRef B,\n-                                                 LLVMValueRef ParentPad,\n-                                                 LLVMBasicBlockRef BB,\n-                                                 unsigned NumHandlers,\n-                                                 const char *Name) {\n-  if (ParentPad == nullptr) {\n-    Type *Ty = Type::getTokenTy(unwrap(B)->getContext());\n-    ParentPad = wrap(Constant::getNullValue(Ty));\n-  }\n-  return wrap(unwrap(B)->CreateCatchSwitch(unwrap(ParentPad), unwrap(BB),\n-                                                 NumHandlers, Name));\n-}\n-\n-extern \"C\" void LLVMRustAddHandler(LLVMValueRef CatchSwitchRef,\n-                                   LLVMBasicBlockRef Handler) {\n-  Value *CatchSwitch = unwrap(CatchSwitchRef);\n-  cast<CatchSwitchInst>(CatchSwitch)->addHandler(unwrap(Handler));\n-}\n-\n extern \"C\" OperandBundleDef *LLVMRustBuildOperandBundleDef(const char *Name,\n                                                            LLVMValueRef *Inputs,\n                                                            unsigned NumInputs) {\n@@ -1624,6 +1561,7 @@ extern \"C\" void LLVMRustSetLinkage(LLVMValueRef V,\n   LLVMSetLinkage(V, fromRust(RustLinkage));\n }\n \n+// FIXME: replace with LLVMConstInBoundsGEP2 when bumped minimal version to llvm-14\n extern \"C\" LLVMValueRef LLVMRustConstInBoundsGEP2(LLVMTypeRef Ty,\n                                                   LLVMValueRef ConstantVal,\n                                                   LLVMValueRef *ConstantIndices,\n@@ -1701,12 +1639,6 @@ extern \"C\" LLVMRustVisibility LLVMRustGetVisibility(LLVMValueRef V) {\n   return toRust(LLVMGetVisibility(V));\n }\n \n-// Oh hey, a binding that makes sense for once? (because LLVM\u2019s own do not)\n-extern \"C\" LLVMValueRef LLVMRustBuildIntCast(LLVMBuilderRef B, LLVMValueRef Val,\n-                                             LLVMTypeRef DestTy, bool isSigned) {\n-  return wrap(unwrap(B)->CreateIntCast(unwrap(Val), unwrap(DestTy), isSigned, \"\"));\n-}\n-\n extern \"C\" void LLVMRustSetVisibility(LLVMValueRef V,\n                                       LLVMRustVisibility RustVisibility) {\n   LLVMSetVisibility(V, fromRust(RustVisibility));"}, {"sha": "ec3cf34d7109f5ab67e1af763374db5bfde2f83d", "filename": "compiler/rustc_llvm/src/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6efdf4d1309f8047bc439a4810888c715e2df480/compiler%2Frustc_llvm%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6efdf4d1309f8047bc439a4810888c715e2df480/compiler%2Frustc_llvm%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_llvm%2Fsrc%2Flib.rs?ref=6efdf4d1309f8047bc439a4810888c715e2df480", "patch": "@@ -30,7 +30,7 @@ pub unsafe extern \"C\" fn LLVMRustStringWriteImpl(\n     ptr: *const c_char,\n     size: size_t,\n ) {\n-    let slice = slice::from_raw_parts(ptr as *const u8, size as usize);\n+    let slice = slice::from_raw_parts(ptr as *const u8, size);\n \n     sr.bytes.borrow_mut().extend_from_slice(slice);\n }"}, {"sha": "21f6a404a01534da91f3c31761b6156e197f37c6", "filename": "compiler/rustc_log/src/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6efdf4d1309f8047bc439a4810888c715e2df480/compiler%2Frustc_log%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6efdf4d1309f8047bc439a4810888c715e2df480/compiler%2Frustc_log%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_log%2Fsrc%2Flib.rs?ref=6efdf4d1309f8047bc439a4810888c715e2df480", "patch": "@@ -83,7 +83,7 @@ pub fn init_env_logger(env: &str) -> Result<(), Error> {\n         .with_verbose_exit(verbose_entry_exit)\n         .with_verbose_entry(verbose_entry_exit)\n         .with_indent_amount(2);\n-    #[cfg(parallel_compiler)]\n+    #[cfg(all(parallel_compiler, debug_assertions))]\n     let layer = layer.with_thread_ids(true).with_thread_names(true);\n \n     let subscriber = tracing_subscriber::Registry::default().with(filter).with(layer);"}, {"sha": "745983e7e869aed7e1f42167b26bcc41baa7e3b3", "filename": "compiler/rustc_macros/Cargo.toml", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6efdf4d1309f8047bc439a4810888c715e2df480/compiler%2Frustc_macros%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/6efdf4d1309f8047bc439a4810888c715e2df480/compiler%2Frustc_macros%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_macros%2FCargo.toml?ref=6efdf4d1309f8047bc439a4810888c715e2df480", "patch": "@@ -10,8 +10,8 @@ proc-macro = true\n annotate-snippets = \"0.9\"\n fluent-bundle = \"0.15.2\"\n fluent-syntax = \"0.11\"\n-synstructure = \"0.12.1\"\n-syn = { version = \"1\", features = [\"full\"] }\n+synstructure = \"0.13.0\"\n+syn = { version = \"2\", features = [\"full\"] }\n proc-macro2 = \"1\"\n quote = \"1\"\n unic-langid = { version = \"0.9.0\", features = [\"macros\"] }"}, {"sha": "4540ded0f41a33dd29a6fcadc7c8e840f9341d96", "filename": "compiler/rustc_macros/src/diagnostics/diagnostic_builder.rs", "status": "modified", "additions": 69, "deletions": 92, "changes": 161, "blob_url": "https://github.com/rust-lang/rust/blob/6efdf4d1309f8047bc439a4810888c715e2df480/compiler%2Frustc_macros%2Fsrc%2Fdiagnostics%2Fdiagnostic_builder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6efdf4d1309f8047bc439a4810888c715e2df480/compiler%2Frustc_macros%2Fsrc%2Fdiagnostics%2Fdiagnostic_builder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_macros%2Fsrc%2Fdiagnostics%2Fdiagnostic_builder.rs?ref=6efdf4d1309f8047bc439a4810888c715e2df480", "patch": "@@ -1,8 +1,7 @@\n #![deny(unused_must_use)]\n \n use crate::diagnostics::error::{\n-    invalid_nested_attr, span_err, throw_invalid_attr, throw_invalid_nested_attr, throw_span_err,\n-    DiagnosticDeriveError,\n+    span_err, throw_invalid_attr, throw_span_err, DiagnosticDeriveError,\n };\n use crate::diagnostics::utils::{\n     build_field_mapping, is_doc_comment, report_error_if_not_applied_to_span, report_type_error,\n@@ -11,9 +10,8 @@ use crate::diagnostics::utils::{\n };\n use proc_macro2::{Ident, Span, TokenStream};\n use quote::{format_ident, quote};\n-use syn::{\n-    parse_quote, spanned::Spanned, Attribute, Meta, MetaList, MetaNameValue, NestedMeta, Path, Type,\n-};\n+use syn::Token;\n+use syn::{parse_quote, spanned::Spanned, Attribute, Meta, Path, Type};\n use synstructure::{BindingInfo, Structure, VariantInfo};\n \n /// What kind of diagnostic is being derived - a fatal/error/warning or a lint?\n@@ -77,7 +75,7 @@ impl DiagnosticDeriveBuilder {\n         match ast.data {\n             syn::Data::Struct(..) | syn::Data::Enum(..) => (),\n             syn::Data::Union(..) => {\n-                span_err(span, \"diagnostic derives can only be used on structs and enums\");\n+                span_err(span, \"diagnostic derives can only be used on structs and enums\").emit();\n             }\n         }\n \n@@ -121,7 +119,7 @@ impl DiagnosticDeriveBuilder {\n impl<'a> DiagnosticDeriveVariantBuilder<'a> {\n     /// Generates calls to `code` and similar functions based on the attributes on the type or\n     /// variant.\n-    pub fn preamble<'s>(&mut self, variant: &VariantInfo<'s>) -> TokenStream {\n+    pub fn preamble(&mut self, variant: &VariantInfo<'_>) -> TokenStream {\n         let ast = variant.ast();\n         let attrs = &ast.attrs;\n         let preamble = attrs.iter().map(|attr| {\n@@ -135,7 +133,7 @@ impl<'a> DiagnosticDeriveVariantBuilder<'a> {\n \n     /// Generates calls to `span_label` and similar functions based on the attributes on fields or\n     /// calls to `set_arg` when no attributes are present.\n-    pub fn body<'s>(&mut self, variant: &VariantInfo<'s>) -> TokenStream {\n+    pub fn body(&mut self, variant: &VariantInfo<'_>) -> TokenStream {\n         let mut body = quote! {};\n         // Generate `set_arg` calls first..\n         for binding in variant.bindings().iter().filter(|bi| should_generate_set_arg(bi.ast())) {\n@@ -160,8 +158,7 @@ impl<'a> DiagnosticDeriveVariantBuilder<'a> {\n         };\n \n         if let SubdiagnosticKind::MultipartSuggestion { .. } = subdiag {\n-            let meta = attr.parse_meta()?;\n-            throw_invalid_attr!(attr, &meta, |diag| diag\n+            throw_invalid_attr!(attr, |diag| diag\n                 .help(\"consider creating a `Subdiagnostic` instead\"));\n         }\n \n@@ -191,71 +188,44 @@ impl<'a> DiagnosticDeriveVariantBuilder<'a> {\n             return Ok(quote! {});\n         }\n \n-        let name = attr.path.segments.last().unwrap().ident.to_string();\n+        let name = attr.path().segments.last().unwrap().ident.to_string();\n         let name = name.as_str();\n-        let meta = attr.parse_meta()?;\n \n-        if name == \"diag\" {\n-            let Meta::List(MetaList { ref nested, .. }) = meta else {\n-                throw_invalid_attr!(\n-                    attr,\n-                    &meta\n-                );\n-            };\n+        let mut first = true;\n \n-            let mut nested_iter = nested.into_iter().peekable();\n+        if name == \"diag\" {\n+            let mut tokens = TokenStream::new();\n+            attr.parse_nested_meta(|nested| {\n+                let path = &nested.path;\n \n-            match nested_iter.peek() {\n-                Some(NestedMeta::Meta(Meta::Path(slug))) => {\n-                    self.slug.set_once(slug.clone(), slug.span().unwrap());\n-                    nested_iter.next();\n+                if first && (nested.input.is_empty() || nested.input.peek(Token![,])) {\n+                    self.slug.set_once(path.clone(), path.span().unwrap());\n+                    first = false;\n+                    return Ok(())\n                 }\n-                Some(NestedMeta::Meta(Meta::NameValue { .. })) => {}\n-                Some(nested_attr) => throw_invalid_nested_attr!(attr, nested_attr, |diag| diag\n-                    .help(\"a diagnostic slug is required as the first argument\")),\n-                None => throw_invalid_attr!(attr, &meta, |diag| diag\n-                    .help(\"a diagnostic slug is required as the first argument\")),\n-            };\n \n-            // Remaining attributes are optional, only `code = \"..\"` at the moment.\n-            let mut tokens = TokenStream::new();\n-            for nested_attr in nested_iter {\n-                let (value, path) = match nested_attr {\n-                    NestedMeta::Meta(Meta::NameValue(MetaNameValue {\n-                        lit: syn::Lit::Str(value),\n-                        path,\n-                        ..\n-                    })) => (value, path),\n-                    NestedMeta::Meta(Meta::Path(_)) => {\n-                        invalid_nested_attr(attr, nested_attr)\n-                            .help(\"diagnostic slug must be the first argument\")\n-                            .emit();\n-                        continue;\n-                    }\n-                    _ => {\n-                        invalid_nested_attr(attr, nested_attr).emit();\n-                        continue;\n-                    }\n+                first = false;\n+\n+                let Ok(nested) = nested.value() else {\n+                    span_err(nested.input.span().unwrap(), \"diagnostic slug must be the first argument\").emit();\n+                    return Ok(())\n                 };\n \n-                let nested_name = path.segments.last().unwrap().ident.to_string();\n-                // Struct attributes are only allowed to be applied once, and the diagnostic\n-                // changes will be set in the initialisation code.\n-                let span = value.span().unwrap();\n-                match nested_name.as_str() {\n-                    \"code\" => {\n-                        self.code.set_once((), span);\n-\n-                        let code = value.value();\n-                        tokens.extend(quote! {\n-                            #diag.code(rustc_errors::DiagnosticId::Error(#code.to_string()));\n-                        });\n-                    }\n-                    _ => invalid_nested_attr(attr, nested_attr)\n-                        .help(\"only `code` is a valid nested attributes following the slug\")\n-                        .emit(),\n+                if path.is_ident(\"code\") {\n+                    self.code.set_once((), path.span().unwrap());\n+\n+                    let code = nested.parse::<syn::LitStr>()?;\n+                    tokens.extend(quote! {\n+                        #diag.code(rustc_errors::DiagnosticId::Error(#code.to_string()));\n+                    });\n+                } else {\n+                    span_err(path.span().unwrap(), \"unknown argument\").note(\"only the `code` parameter is valid after the slug\").emit();\n+\n+                    // consume the buffer so we don't have syntax errors from syn\n+                    let _ = nested.parse::<TokenStream>();\n                 }\n-            }\n+                Ok(())\n+            })?;\n             return Ok(tokens);\n         }\n \n@@ -270,7 +240,7 @@ impl<'a> DiagnosticDeriveVariantBuilder<'a> {\n                 Ok(self.add_subdiagnostic(&fn_ident, slug))\n             }\n             SubdiagnosticKind::Label | SubdiagnosticKind::Suggestion { .. } => {\n-                throw_invalid_attr!(attr, &meta, |diag| diag\n+                throw_invalid_attr!(attr, |diag| diag\n                     .help(\"`#[label]` and `#[suggestion]` can only be applied to fields\"));\n             }\n             SubdiagnosticKind::MultipartSuggestion { .. } => unreachable!(),\n@@ -309,7 +279,7 @@ impl<'a> DiagnosticDeriveVariantBuilder<'a> {\n                     return quote! {};\n                 }\n \n-                let name = attr.path.segments.last().unwrap().ident.to_string();\n+                let name = attr.path().segments.last().unwrap().ident.to_string();\n                 let needs_clone =\n                     name == \"primary_span\" && matches!(inner_ty, FieldInnerTy::Vec(_));\n                 let (binding, needs_destructure) = if needs_clone {\n@@ -343,11 +313,10 @@ impl<'a> DiagnosticDeriveVariantBuilder<'a> {\n         binding: TokenStream,\n     ) -> Result<TokenStream, DiagnosticDeriveError> {\n         let diag = &self.parent.diag;\n-        let meta = attr.parse_meta()?;\n \n-        let ident = &attr.path.segments.last().unwrap().ident;\n+        let ident = &attr.path().segments.last().unwrap().ident;\n         let name = ident.to_string();\n-        match (&meta, name.as_str()) {\n+        match (&attr.meta, name.as_str()) {\n             // Don't need to do anything - by virtue of the attribute existing, the\n             // `set_arg` call will not be generated.\n             (Meta::Path(_), \"skip_arg\") => return Ok(quote! {}),\n@@ -361,7 +330,7 @@ impl<'a> DiagnosticDeriveVariantBuilder<'a> {\n                         });\n                     }\n                     DiagnosticDeriveKind::LintDiagnostic => {\n-                        throw_invalid_attr!(attr, &meta, |diag| {\n+                        throw_invalid_attr!(attr, |diag| {\n                             diag.help(\"the `primary_span` field attribute is not valid for lint diagnostics\")\n                         })\n                     }\n@@ -378,26 +347,34 @@ impl<'a> DiagnosticDeriveVariantBuilder<'a> {\n                     return Ok(quote! { #diag.subdiagnostic(#binding); });\n                 }\n             }\n-            (Meta::List(MetaList { ref nested, .. }), \"subdiagnostic\") => {\n-                if nested.len() == 1\n-                    && let Some(NestedMeta::Meta(Meta::Path(path))) = nested.first()\n-                    && path.is_ident(\"eager\") {\n-                        let handler = match &self.parent.kind {\n-                            DiagnosticDeriveKind::Diagnostic { handler } => handler,\n-                            DiagnosticDeriveKind::LintDiagnostic => {\n-                                throw_invalid_attr!(attr, &meta, |diag| {\n-                                    diag.help(\"eager subdiagnostics are not supported on lints\")\n-                                })\n-                            }\n-                        };\n-                        return Ok(quote! { #diag.eager_subdiagnostic(#handler, #binding); });\n-                } else {\n-                    throw_invalid_attr!(attr, &meta, |diag| {\n-                        diag.help(\n-                            \"`eager` is the only supported nested attribute for `subdiagnostic`\",\n-                        )\n-                    })\n+            (Meta::List(meta_list), \"subdiagnostic\") => {\n+                let err = || {\n+                    span_err(\n+                        meta_list.span().unwrap(),\n+                        \"`eager` is the only supported nested attribute for `subdiagnostic`\",\n+                    )\n+                    .emit();\n+                };\n+\n+                let Ok(p): Result<Path, _> = meta_list.parse_args() else {\n+                    err();\n+                    return Ok(quote! {});\n+                };\n+\n+                if !p.is_ident(\"eager\") {\n+                    err();\n+                    return Ok(quote! {});\n                 }\n+\n+                let handler = match &self.parent.kind {\n+                    DiagnosticDeriveKind::Diagnostic { handler } => handler,\n+                    DiagnosticDeriveKind::LintDiagnostic => {\n+                        throw_invalid_attr!(attr, |diag| {\n+                            diag.help(\"eager subdiagnostics are not supported on lints\")\n+                        })\n+                    }\n+                };\n+                return Ok(quote! { #diag.eager_subdiagnostic(#handler, #binding); });\n             }\n             _ => (),\n         }\n@@ -432,7 +409,7 @@ impl<'a> DiagnosticDeriveVariantBuilder<'a> {\n                 code_init,\n             } => {\n                 if let FieldInnerTy::Vec(_) = info.ty {\n-                    throw_invalid_attr!(attr, &meta, |diag| {\n+                    throw_invalid_attr!(attr, |diag| {\n                         diag\n                         .note(\"`#[suggestion(...)]` applied to `Vec` field is ambiguous\")\n                         .help(\"to show a suggestion consisting of multiple parts, use a `Subdiagnostic` annotated with `#[multipart_suggestion(...)]`\")"}, {"sha": "b37dc826d28865d5cc44e237f7499571e50ac453", "filename": "compiler/rustc_macros/src/diagnostics/error.rs", "status": "modified", "additions": 8, "deletions": 47, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/6efdf4d1309f8047bc439a4810888c715e2df480/compiler%2Frustc_macros%2Fsrc%2Fdiagnostics%2Ferror.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6efdf4d1309f8047bc439a4810888c715e2df480/compiler%2Frustc_macros%2Fsrc%2Fdiagnostics%2Ferror.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_macros%2Fsrc%2Fdiagnostics%2Ferror.rs?ref=6efdf4d1309f8047bc439a4810888c715e2df480", "patch": "@@ -1,7 +1,7 @@\n use proc_macro::{Diagnostic, Level, MultiSpan};\n use proc_macro2::TokenStream;\n use quote::quote;\n-use syn::{spanned::Spanned, Attribute, Error as SynError, Meta, NestedMeta};\n+use syn::{spanned::Spanned, Attribute, Error as SynError, Meta};\n \n #[derive(Debug)]\n pub(crate) enum DiagnosticDeriveError {\n@@ -53,6 +53,7 @@ fn path_to_string(path: &syn::Path) -> String {\n }\n \n /// Returns an error diagnostic on span `span` with msg `msg`.\n+#[must_use]\n pub(crate) fn span_err(span: impl MultiSpan, msg: &str) -> Diagnostic {\n     Diagnostic::spanned(span, Level::Error, msg)\n }\n@@ -72,10 +73,10 @@ macro_rules! throw_span_err {\n pub(crate) use throw_span_err;\n \n /// Returns an error diagnostic for an invalid attribute.\n-pub(crate) fn invalid_attr(attr: &Attribute, meta: &Meta) -> Diagnostic {\n+pub(crate) fn invalid_attr(attr: &Attribute) -> Diagnostic {\n     let span = attr.span().unwrap();\n-    let path = path_to_string(&attr.path);\n-    match meta {\n+    let path = path_to_string(attr.path());\n+    match attr.meta {\n         Meta::Path(_) => span_err(span, &format!(\"`#[{path}]` is not a valid attribute\")),\n         Meta::NameValue(_) => {\n             span_err(span, &format!(\"`#[{path} = ...]` is not a valid attribute\"))\n@@ -89,51 +90,11 @@ pub(crate) fn invalid_attr(attr: &Attribute, meta: &Meta) -> Diagnostic {\n ///\n /// For methods that return a `Result<_, DiagnosticDeriveError>`:\n macro_rules! throw_invalid_attr {\n-    ($attr:expr, $meta:expr) => {{ throw_invalid_attr!($attr, $meta, |diag| diag) }};\n-    ($attr:expr, $meta:expr, $f:expr) => {{\n-        let diag = crate::diagnostics::error::invalid_attr($attr, $meta);\n+    ($attr:expr) => {{ throw_invalid_attr!($attr, |diag| diag) }};\n+    ($attr:expr, $f:expr) => {{\n+        let diag = crate::diagnostics::error::invalid_attr($attr);\n         return Err(crate::diagnostics::error::_throw_err(diag, $f));\n     }};\n }\n \n pub(crate) use throw_invalid_attr;\n-\n-/// Returns an error diagnostic for an invalid nested attribute.\n-pub(crate) fn invalid_nested_attr(attr: &Attribute, nested: &NestedMeta) -> Diagnostic {\n-    let name = attr.path.segments.last().unwrap().ident.to_string();\n-    let name = name.as_str();\n-\n-    let span = nested.span().unwrap();\n-    let meta = match nested {\n-        syn::NestedMeta::Meta(meta) => meta,\n-        syn::NestedMeta::Lit(_) => {\n-            return span_err(span, &format!(\"`#[{name}(\\\"...\\\")]` is not a valid attribute\"));\n-        }\n-    };\n-\n-    let span = meta.span().unwrap();\n-    let path = path_to_string(meta.path());\n-    match meta {\n-        Meta::NameValue(..) => {\n-            span_err(span, &format!(\"`#[{name}({path} = ...)]` is not a valid attribute\"))\n-        }\n-        Meta::Path(..) => span_err(span, &format!(\"`#[{name}({path})]` is not a valid attribute\")),\n-        Meta::List(..) => {\n-            span_err(span, &format!(\"`#[{name}({path}(...))]` is not a valid attribute\"))\n-        }\n-    }\n-}\n-\n-/// Emit an error diagnostic for an invalid nested attribute (optionally performing additional\n-/// decoration using the `FnOnce` passed in `diag`) and return `Err(ErrorHandled)`.\n-///\n-/// For methods that return a `Result<_, DiagnosticDeriveError>`:\n-macro_rules! throw_invalid_nested_attr {\n-    ($attr:expr, $nested_attr:expr) => {{ throw_invalid_nested_attr!($attr, $nested_attr, |diag| diag) }};\n-    ($attr:expr, $nested_attr:expr, $f:expr) => {{\n-        let diag = crate::diagnostics::error::invalid_nested_attr($attr, $nested_attr);\n-        return Err(crate::diagnostics::error::_throw_err(diag, $f));\n-    }};\n-}\n-\n-pub(crate) use throw_invalid_nested_attr;"}, {"sha": "607d51f5608d38ed56e4fc63d3accfac5946d581", "filename": "compiler/rustc_macros/src/diagnostics/fluent.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6efdf4d1309f8047bc439a4810888c715e2df480/compiler%2Frustc_macros%2Fsrc%2Fdiagnostics%2Ffluent.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6efdf4d1309f8047bc439a4810888c715e2df480/compiler%2Frustc_macros%2Fsrc%2Fdiagnostics%2Ffluent.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_macros%2Fsrc%2Fdiagnostics%2Ffluent.rs?ref=6efdf4d1309f8047bc439a4810888c715e2df480", "patch": "@@ -100,7 +100,7 @@ pub(crate) fn fluent_messages(input: proc_macro::TokenStream) -> proc_macro::Tok\n             Diagnostic::spanned(\n                 resource_span,\n                 Level::Error,\n-                format!(\"could not open Fluent resource: {}\", e.to_string()),\n+                format!(\"could not open Fluent resource: {e}\"),\n             )\n             .emit();\n             return failed(&crate_name);"}, {"sha": "62d49c1c64e27f3787dfca6ea5a03d47557af7d8", "filename": "compiler/rustc_macros/src/diagnostics/subdiagnostic.rs", "status": "modified", "additions": 38, "deletions": 41, "changes": 79, "blob_url": "https://github.com/rust-lang/rust/blob/6efdf4d1309f8047bc439a4810888c715e2df480/compiler%2Frustc_macros%2Fsrc%2Fdiagnostics%2Fsubdiagnostic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6efdf4d1309f8047bc439a4810888c715e2df480/compiler%2Frustc_macros%2Fsrc%2Fdiagnostics%2Fsubdiagnostic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_macros%2Fsrc%2Fdiagnostics%2Fsubdiagnostic.rs?ref=6efdf4d1309f8047bc439a4810888c715e2df480", "patch": "@@ -1,8 +1,7 @@\n #![deny(unused_must_use)]\n \n use crate::diagnostics::error::{\n-    invalid_attr, span_err, throw_invalid_attr, throw_invalid_nested_attr, throw_span_err,\n-    DiagnosticDeriveError,\n+    invalid_attr, span_err, throw_invalid_attr, throw_span_err, DiagnosticDeriveError,\n };\n use crate::diagnostics::utils::{\n     build_field_mapping, is_doc_comment, new_code_ident,\n@@ -11,7 +10,7 @@ use crate::diagnostics::utils::{\n };\n use proc_macro2::TokenStream;\n use quote::{format_ident, quote};\n-use syn::{spanned::Spanned, Attribute, Meta, MetaList, NestedMeta, Path};\n+use syn::{spanned::Spanned, Attribute, Meta, MetaList, Path};\n use synstructure::{BindingInfo, Structure, VariantInfo};\n \n use super::utils::{build_suggestion_code, AllowMultipleAlternatives};\n@@ -39,7 +38,8 @@ impl SubdiagnosticDeriveBuilder {\n                     span_err(\n                         span,\n                         \"`#[derive(Subdiagnostic)]` can only be used on structs and enums\",\n-                    );\n+                    )\n+                    .emit();\n                 }\n             }\n \n@@ -192,7 +192,7 @@ impl<'parent, 'a> SubdiagnosticDeriveVariantBuilder<'parent, 'a> {\n             };\n \n             let Some(slug) = slug else {\n-                let name = attr.path.segments.last().unwrap().ident.to_string();\n+                let name = attr.path().segments.last().unwrap().ident.to_string();\n                 let name = name.as_str();\n \n                 throw_span_err!(\n@@ -265,17 +265,18 @@ impl<'parent, 'a> SubdiagnosticDeriveVariantBuilder<'parent, 'a> {\n         info: FieldInfo<'_>,\n         clone_suggestion_code: bool,\n     ) -> Result<TokenStream, DiagnosticDeriveError> {\n-        let meta = attr.parse_meta()?;\n-        match meta {\n-            Meta::Path(path) => self.generate_field_code_inner_path(kind_stats, attr, info, path),\n-            Meta::List(list @ MetaList { .. }) => self.generate_field_code_inner_list(\n+        match &attr.meta {\n+            Meta::Path(path) => {\n+                self.generate_field_code_inner_path(kind_stats, attr, info, path.clone())\n+            }\n+            Meta::List(list) => self.generate_field_code_inner_list(\n                 kind_stats,\n                 attr,\n                 info,\n                 list,\n                 clone_suggestion_code,\n             ),\n-            _ => throw_invalid_attr!(attr, &meta),\n+            _ => throw_invalid_attr!(attr),\n         }\n     }\n \n@@ -296,7 +297,7 @@ impl<'parent, 'a> SubdiagnosticDeriveVariantBuilder<'parent, 'a> {\n             \"skip_arg\" => Ok(quote! {}),\n             \"primary_span\" => {\n                 if kind_stats.has_multipart_suggestion {\n-                    invalid_attr(attr, &Meta::Path(path))\n+                    invalid_attr(attr)\n                         .help(\n                             \"multipart suggestions use one or more `#[suggestion_part]`s rather \\\n                             than one `#[primary_span]`\",\n@@ -309,7 +310,7 @@ impl<'parent, 'a> SubdiagnosticDeriveVariantBuilder<'parent, 'a> {\n                     // FIXME(#100717): support `Option<Span>` on `primary_span` like in the\n                     // diagnostic derive\n                     if !matches!(info.ty, FieldInnerTy::Plain(_)) {\n-                        throw_invalid_attr!(attr, &Meta::Path(path), |diag| {\n+                        throw_invalid_attr!(attr, |diag| {\n                             let diag = diag.note(\"there must be exactly one primary span\");\n \n                             if kind_stats.has_normal_suggestion {\n@@ -335,7 +336,7 @@ impl<'parent, 'a> SubdiagnosticDeriveVariantBuilder<'parent, 'a> {\n                     span_err(span, \"`#[suggestion_part(...)]` attribute without `code = \\\"...\\\"`\")\n                         .emit();\n                 } else {\n-                    invalid_attr(attr, &Meta::Path(path))\n+                    invalid_attr(attr)\n                         .help(\n                             \"`#[suggestion_part(...)]` is only valid in multipart suggestions, \\\n                              use `#[primary_span]` instead\",\n@@ -375,7 +376,7 @@ impl<'parent, 'a> SubdiagnosticDeriveVariantBuilder<'parent, 'a> {\n                     span_attrs.push(\"primary_span\")\n                 }\n \n-                invalid_attr(attr, &Meta::Path(path))\n+                invalid_attr(attr)\n                     .help(format!(\n                         \"only `{}`, `applicability` and `skip_arg` are valid field attributes\",\n                         span_attrs.join(\", \")\n@@ -394,7 +395,7 @@ impl<'parent, 'a> SubdiagnosticDeriveVariantBuilder<'parent, 'a> {\n         kind_stats: KindsStatistics,\n         attr: &Attribute,\n         info: FieldInfo<'_>,\n-        list: MetaList,\n+        list: &MetaList,\n         clone_suggestion_code: bool,\n     ) -> Result<TokenStream, DiagnosticDeriveError> {\n         let span = attr.span().unwrap();\n@@ -405,7 +406,7 @@ impl<'parent, 'a> SubdiagnosticDeriveVariantBuilder<'parent, 'a> {\n         match name {\n             \"suggestion_part\" => {\n                 if !kind_stats.has_multipart_suggestion {\n-                    throw_invalid_attr!(attr, &Meta::List(list), |diag| {\n+                    throw_invalid_attr!(attr, |diag| {\n                         diag.help(\n                             \"`#[suggestion_part(...)]` is only valid in multipart suggestions\",\n                         )\n@@ -417,31 +418,27 @@ impl<'parent, 'a> SubdiagnosticDeriveVariantBuilder<'parent, 'a> {\n                 report_error_if_not_applied_to_span(attr, &info)?;\n \n                 let mut code = None;\n-                for nested_attr in list.nested.iter() {\n-                    let NestedMeta::Meta(ref meta) = nested_attr else {\n-                        throw_invalid_nested_attr!(attr, nested_attr);\n-                    };\n-\n-                    let span = meta.span().unwrap();\n-                    let nested_name = meta.path().segments.last().unwrap().ident.to_string();\n-                    let nested_name = nested_name.as_str();\n-\n-                    match nested_name {\n-                        \"code\" => {\n-                            let code_field = new_code_ident();\n-                            let formatting_init = build_suggestion_code(\n-                                &code_field,\n-                                meta,\n-                                self,\n-                                AllowMultipleAlternatives::No,\n-                            );\n-                            code.set_once((code_field, formatting_init), span);\n-                        }\n-                        _ => throw_invalid_nested_attr!(attr, nested_attr, |diag| {\n-                            diag.help(\"`code` is the only valid nested attribute\")\n-                        }),\n+\n+                list.parse_nested_meta(|nested| {\n+                    if nested.path.is_ident(\"code\") {\n+                        let code_field = new_code_ident();\n+                        let span = nested.path.span().unwrap();\n+                        let formatting_init = build_suggestion_code(\n+                            &code_field,\n+                            nested,\n+                            self,\n+                            AllowMultipleAlternatives::No,\n+                        );\n+                        code.set_once((code_field, formatting_init), span);\n+                    } else {\n+                        span_err(\n+                            nested.path.span().unwrap(),\n+                            \"`code` is the only valid nested attribute\",\n+                        )\n+                        .emit();\n                     }\n-                }\n+                    Ok(())\n+                })?;\n \n                 let Some((code_field, formatting_init)) = code.value() else {\n                     span_err(span, \"`#[suggestion_part(...)]` attribute without `code = \\\"...\\\"`\")\n@@ -458,7 +455,7 @@ impl<'parent, 'a> SubdiagnosticDeriveVariantBuilder<'parent, 'a> {\n                 };\n                 Ok(quote! { suggestions.push((#binding, #code_field)); })\n             }\n-            _ => throw_invalid_attr!(attr, &Meta::List(list), |diag| {\n+            _ => throw_invalid_attr!(attr, |diag| {\n                 let mut span_attrs = vec![];\n                 if kind_stats.has_multipart_suggestion {\n                     span_attrs.push(\"suggestion_part\");"}, {"sha": "b9b09c66230b8de6bde1ee419cb04633cfd40ac3", "filename": "compiler/rustc_macros/src/diagnostics/utils.rs", "status": "modified", "additions": 116, "deletions": 106, "changes": 222, "blob_url": "https://github.com/rust-lang/rust/blob/6efdf4d1309f8047bc439a4810888c715e2df480/compiler%2Frustc_macros%2Fsrc%2Fdiagnostics%2Futils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6efdf4d1309f8047bc439a4810888c715e2df480/compiler%2Frustc_macros%2Fsrc%2Fdiagnostics%2Futils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_macros%2Fsrc%2Fdiagnostics%2Futils.rs?ref=6efdf4d1309f8047bc439a4810888c715e2df480", "patch": "@@ -1,5 +1,5 @@\n use crate::diagnostics::error::{\n-    span_err, throw_invalid_attr, throw_invalid_nested_attr, throw_span_err, DiagnosticDeriveError,\n+    span_err, throw_invalid_attr, throw_span_err, DiagnosticDeriveError,\n };\n use proc_macro::Span;\n use proc_macro2::{Ident, TokenStream};\n@@ -8,11 +8,13 @@ use std::cell::RefCell;\n use std::collections::{BTreeSet, HashMap};\n use std::fmt;\n use std::str::FromStr;\n+use syn::meta::ParseNestedMeta;\n+use syn::punctuated::Punctuated;\n+use syn::{parenthesized, LitStr, Path, Token};\n use syn::{spanned::Spanned, Attribute, Field, Meta, Type, TypeTuple};\n-use syn::{MetaList, MetaNameValue, NestedMeta, Path};\n use synstructure::{BindingInfo, VariantInfo};\n \n-use super::error::{invalid_attr, invalid_nested_attr};\n+use super::error::invalid_attr;\n \n thread_local! {\n     pub static CODE_IDENT_COUNT: RefCell<u32> = RefCell::new(0);\n@@ -60,8 +62,8 @@ pub(crate) fn report_type_error(\n     attr: &Attribute,\n     ty_name: &str,\n ) -> Result<!, DiagnosticDeriveError> {\n-    let name = attr.path.segments.last().unwrap().ident.to_string();\n-    let meta = attr.parse_meta()?;\n+    let name = attr.path().segments.last().unwrap().ident.to_string();\n+    let meta = &attr.meta;\n \n     throw_span_err!(\n         attr.span().unwrap(),\n@@ -418,59 +420,62 @@ pub(super) enum AllowMultipleAlternatives {\n     Yes,\n }\n \n+fn parse_suggestion_values(\n+    nested: ParseNestedMeta<'_>,\n+    allow_multiple: AllowMultipleAlternatives,\n+) -> syn::Result<Vec<LitStr>> {\n+    let values = if let Ok(val) = nested.value() {\n+        vec![val.parse()?]\n+    } else {\n+        let content;\n+        parenthesized!(content in nested.input);\n+\n+        if let AllowMultipleAlternatives::No = allow_multiple {\n+            span_err(\n+                nested.input.span().unwrap(),\n+                \"expected exactly one string literal for `code = ...`\",\n+            )\n+            .emit();\n+            vec![]\n+        } else {\n+            let literals = Punctuated::<LitStr, Token![,]>::parse_terminated(&content);\n+\n+            match literals {\n+                Ok(p) if p.is_empty() => {\n+                    span_err(\n+                        content.span().unwrap(),\n+                        \"expected at least one string literal for `code(...)`\",\n+                    )\n+                    .emit();\n+                    vec![]\n+                }\n+                Ok(p) => p.into_iter().collect(),\n+                Err(_) => {\n+                    span_err(\n+                        content.span().unwrap(),\n+                        \"`code(...)` must contain only string literals\",\n+                    )\n+                    .emit();\n+                    vec![]\n+                }\n+            }\n+        }\n+    };\n+\n+    Ok(values)\n+}\n+\n /// Constructs the `format!()` invocation(s) necessary for a `#[suggestion*(code = \"foo\")]` or\n /// `#[suggestion*(code(\"foo\", \"bar\"))]` attribute field\n pub(super) fn build_suggestion_code(\n     code_field: &Ident,\n-    meta: &Meta,\n+    nested: ParseNestedMeta<'_>,\n     fields: &impl HasFieldMap,\n     allow_multiple: AllowMultipleAlternatives,\n ) -> TokenStream {\n-    let values = match meta {\n-        // `code = \"foo\"`\n-        Meta::NameValue(MetaNameValue { lit: syn::Lit::Str(s), .. }) => vec![s],\n-        // `code(\"foo\", \"bar\")`\n-        Meta::List(MetaList { nested, .. }) => {\n-            if let AllowMultipleAlternatives::No = allow_multiple {\n-                span_err(\n-                    meta.span().unwrap(),\n-                    \"expected exactly one string literal for `code = ...`\",\n-                )\n-                .emit();\n-                vec![]\n-            } else if nested.is_empty() {\n-                span_err(\n-                    meta.span().unwrap(),\n-                    \"expected at least one string literal for `code(...)`\",\n-                )\n-                .emit();\n-                vec![]\n-            } else {\n-                nested\n-                    .into_iter()\n-                    .filter_map(|item| {\n-                        if let NestedMeta::Lit(syn::Lit::Str(s)) = item {\n-                            Some(s)\n-                        } else {\n-                            span_err(\n-                                item.span().unwrap(),\n-                                \"`code(...)` must contain only string literals\",\n-                            )\n-                            .emit();\n-                            None\n-                        }\n-                    })\n-                    .collect()\n-            }\n-        }\n-        _ => {\n-            span_err(\n-                meta.span().unwrap(),\n-                r#\"`code = \"...\"`/`code(...)` must contain only string literals\"#,\n-            )\n-            .emit();\n-            vec![]\n-        }\n+    let values = match parse_suggestion_values(nested, allow_multiple) {\n+        Ok(x) => x,\n+        Err(e) => return e.into_compile_error(),\n     };\n \n     if let AllowMultipleAlternatives::Yes = allow_multiple {\n@@ -601,11 +606,9 @@ impl SubdiagnosticKind {\n \n         let span = attr.span().unwrap();\n \n-        let name = attr.path.segments.last().unwrap().ident.to_string();\n+        let name = attr.path().segments.last().unwrap().ident.to_string();\n         let name = name.as_str();\n \n-        let meta = attr.parse_meta()?;\n-\n         let mut kind = match name {\n             \"label\" => SubdiagnosticKind::Label,\n             \"note\" => SubdiagnosticKind::Note,\n@@ -618,7 +621,7 @@ impl SubdiagnosticKind {\n                     name.strip_prefix(\"suggestion\").and_then(SuggestionKind::from_suffix)\n                 {\n                     if suggestion_kind != SuggestionKind::Normal {\n-                        invalid_attr(attr, &meta)\n+                        invalid_attr(attr)\n                             .help(format!(\n                                 r#\"Use `#[suggestion(..., style = \"{suggestion_kind}\")]` instead\"#\n                             ))\n@@ -635,7 +638,7 @@ impl SubdiagnosticKind {\n                     name.strip_prefix(\"multipart_suggestion\").and_then(SuggestionKind::from_suffix)\n                 {\n                     if suggestion_kind != SuggestionKind::Normal {\n-                        invalid_attr(attr, &meta)\n+                        invalid_attr(attr)\n                             .help(format!(\n                                 r#\"Use `#[multipart_suggestion(..., style = \"{suggestion_kind}\")]` instead\"#\n                             ))\n@@ -647,16 +650,16 @@ impl SubdiagnosticKind {\n                         applicability: None,\n                     }\n                 } else {\n-                    throw_invalid_attr!(attr, &meta);\n+                    throw_invalid_attr!(attr);\n                 }\n             }\n         };\n \n-        let nested = match meta {\n-            Meta::List(MetaList { ref nested, .. }) => {\n+        let list = match &attr.meta {\n+            Meta::List(list) => {\n                 // An attribute with properties, such as `#[suggestion(code = \"...\")]` or\n                 // `#[error(some::slug)]`\n-                nested\n+                list\n             }\n             Meta::Path(_) => {\n                 // An attribute without a slug or other properties, such as `#[note]` - return\n@@ -678,69 +681,68 @@ impl SubdiagnosticKind {\n                 }\n             }\n             _ => {\n-                throw_invalid_attr!(attr, &meta)\n+                throw_invalid_attr!(attr)\n             }\n         };\n \n         let mut code = None;\n         let mut suggestion_kind = None;\n \n-        let mut nested_iter = nested.into_iter().peekable();\n+        let mut first = true;\n+        let mut slug = None;\n \n-        // Peek at the first nested attribute: if it's a slug path, consume it.\n-        let slug = if let Some(NestedMeta::Meta(Meta::Path(path))) = nested_iter.peek() {\n-            let path = path.clone();\n-            // Advance the iterator.\n-            nested_iter.next();\n-            Some(path)\n-        } else {\n-            None\n-        };\n-\n-        for nested_attr in nested_iter {\n-            let meta = match nested_attr {\n-                NestedMeta::Meta(ref meta) => meta,\n-                NestedMeta::Lit(_) => {\n-                    invalid_nested_attr(attr, nested_attr).emit();\n-                    continue;\n+        list.parse_nested_meta(|nested| {\n+            if nested.input.is_empty() || nested.input.peek(Token![,]) {\n+                if first {\n+                    slug = Some(nested.path);\n+                } else {\n+                    span_err(nested.input.span().unwrap(), \"a diagnostic slug must be the first argument to the attribute\").emit();\n                 }\n-            };\n \n-            let span = meta.span().unwrap();\n-            let nested_name = meta.path().segments.last().unwrap().ident.to_string();\n+                first = false;\n+                return Ok(());\n+            }\n+\n+            first = false;\n+\n+            let nested_name = nested.path.segments.last().unwrap().ident.to_string();\n             let nested_name = nested_name.as_str();\n \n-            let string_value = match meta {\n-                Meta::NameValue(MetaNameValue { lit: syn::Lit::Str(value), .. }) => Some(value),\n+            let path_span = nested.path.span().unwrap();\n+            let val_span = nested.input.span().unwrap();\n \n-                Meta::Path(_) => throw_invalid_nested_attr!(attr, nested_attr, |diag| {\n-                    diag.help(\"a diagnostic slug must be the first argument to the attribute\")\n-                }),\n-                _ => None,\n-            };\n+            macro_rules! get_string {\n+                () => {{\n+                    let Ok(value) = nested.value().and_then(|x| x.parse::<LitStr>()) else {\n+                        span_err(val_span, \"expected `= \\\"xxx\\\"`\").emit();\n+                        return Ok(());\n+                    };\n+                    value\n+                }};\n+            }\n+\n+            let mut has_errors = false;\n+            let input = nested.input;\n \n             match (nested_name, &mut kind) {\n                 (\"code\", SubdiagnosticKind::Suggestion { code_field, .. }) => {\n                     let code_init = build_suggestion_code(\n                         code_field,\n-                        meta,\n+                        nested,\n                         fields,\n                         AllowMultipleAlternatives::Yes,\n                     );\n-                    code.set_once(code_init, span);\n+                    code.set_once(code_init, path_span);\n                 }\n                 (\n                     \"applicability\",\n                     SubdiagnosticKind::Suggestion { ref mut applicability, .. }\n                     | SubdiagnosticKind::MultipartSuggestion { ref mut applicability, .. },\n                 ) => {\n-                    let Some(value) = string_value else {\n-                        invalid_nested_attr(attr, nested_attr).emit();\n-                        continue;\n-                    };\n-\n+                    let value = get_string!();\n                     let value = Applicability::from_str(&value.value()).unwrap_or_else(|()| {\n-                        span_err(span, \"invalid applicability\").emit();\n+                        span_err(value.span().unwrap(), \"invalid applicability\").emit();\n+                        has_errors = true;\n                         Applicability::Unspecified\n                     });\n                     applicability.set_once(value, span);\n@@ -750,15 +752,13 @@ impl SubdiagnosticKind {\n                     SubdiagnosticKind::Suggestion { .. }\n                     | SubdiagnosticKind::MultipartSuggestion { .. },\n                 ) => {\n-                    let Some(value) = string_value else {\n-                        invalid_nested_attr(attr, nested_attr).emit();\n-                        continue;\n-                    };\n+                    let value = get_string!();\n \n                     let value = value.value().parse().unwrap_or_else(|()| {\n                         span_err(value.span().unwrap(), \"invalid suggestion style\")\n                             .help(\"valid styles are `normal`, `short`, `hidden`, `verbose` and `tool-only`\")\n                             .emit();\n+                        has_errors = true;\n                         SuggestionKind::Normal\n                     });\n \n@@ -767,22 +767,32 @@ impl SubdiagnosticKind {\n \n                 // Invalid nested attribute\n                 (_, SubdiagnosticKind::Suggestion { .. }) => {\n-                    invalid_nested_attr(attr, nested_attr)\n+                    span_err(path_span, \"invalid nested attribute\")\n                         .help(\n                             \"only `style`, `code` and `applicability` are valid nested attributes\",\n                         )\n                         .emit();\n+                    has_errors = true;\n                 }\n                 (_, SubdiagnosticKind::MultipartSuggestion { .. }) => {\n-                    invalid_nested_attr(attr, nested_attr)\n+                    span_err(path_span, \"invalid nested attribute\")\n                         .help(\"only `style` and `applicability` are valid nested attributes\")\n-                        .emit()\n+                        .emit();\n+                    has_errors = true;\n                 }\n                 _ => {\n-                    invalid_nested_attr(attr, nested_attr).emit();\n+                    span_err(path_span, \"invalid nested attribute\").emit();\n+                    has_errors = true;\n                 }\n             }\n-        }\n+\n+            if has_errors {\n+                // Consume the rest of the input to avoid spamming errors\n+                let _ = input.parse::<TokenStream>();\n+            }\n+\n+            Ok(())\n+        })?;\n \n         match kind {\n             SubdiagnosticKind::Suggestion {\n@@ -845,5 +855,5 @@ pub(super) fn should_generate_set_arg(field: &Field) -> bool {\n }\n \n pub(super) fn is_doc_comment(attr: &Attribute) -> bool {\n-    attr.path.segments.last().unwrap().ident == \"doc\"\n+    attr.path().segments.last().unwrap().ident == \"doc\"\n }"}, {"sha": "75a2f7009c2589d7e684a4b1f74ca6c2cdcd5b2e", "filename": "compiler/rustc_macros/src/hash_stable.rs", "status": "modified", "additions": 21, "deletions": 24, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/6efdf4d1309f8047bc439a4810888c715e2df480/compiler%2Frustc_macros%2Fsrc%2Fhash_stable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6efdf4d1309f8047bc439a4810888c715e2df480/compiler%2Frustc_macros%2Fsrc%2Fhash_stable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_macros%2Fsrc%2Fhash_stable.rs?ref=6efdf4d1309f8047bc439a4810888c715e2df480", "patch": "@@ -1,6 +1,6 @@\n use proc_macro2::{self, Ident};\n use quote::quote;\n-use syn::{self, parse_quote, Meta, NestedMeta};\n+use syn::{self, parse_quote};\n \n struct Attributes {\n     ignore: bool,\n@@ -10,32 +10,29 @@ struct Attributes {\n fn parse_attributes(field: &syn::Field) -> Attributes {\n     let mut attrs = Attributes { ignore: false, project: None };\n     for attr in &field.attrs {\n-        if let Ok(meta) = attr.parse_meta() {\n-            if !meta.path().is_ident(\"stable_hasher\") {\n-                continue;\n+        let meta = &attr.meta;\n+        if !meta.path().is_ident(\"stable_hasher\") {\n+            continue;\n+        }\n+        let mut any_attr = false;\n+        let _ = attr.parse_nested_meta(|nested| {\n+            if nested.path.is_ident(\"ignore\") {\n+                attrs.ignore = true;\n+                any_attr = true;\n             }\n-            let mut any_attr = false;\n-            if let Meta::List(list) = meta {\n-                for nested in list.nested.iter() {\n-                    if let NestedMeta::Meta(meta) = nested {\n-                        if meta.path().is_ident(\"ignore\") {\n-                            attrs.ignore = true;\n-                            any_attr = true;\n-                        }\n-                        if meta.path().is_ident(\"project\") {\n-                            if let Meta::List(list) = meta {\n-                                if let Some(NestedMeta::Meta(meta)) = list.nested.iter().next() {\n-                                    attrs.project = meta.path().get_ident().cloned();\n-                                    any_attr = true;\n-                                }\n-                            }\n-                        }\n+            if nested.path.is_ident(\"project\") {\n+                let _ = nested.parse_nested_meta(|meta| {\n+                    if attrs.project.is_none() {\n+                        attrs.project = meta.path.get_ident().cloned();\n                     }\n-                }\n-            }\n-            if !any_attr {\n-                panic!(\"error parsing stable_hasher\");\n+                    any_attr = true;\n+                    Ok(())\n+                });\n             }\n+            Ok(())\n+        });\n+        if !any_attr {\n+            panic!(\"error parsing stable_hasher\");\n         }\n     }\n     attrs"}, {"sha": "78a6f74887d4b1a3e258f3411f9c0ef7ee91fefd", "filename": "compiler/rustc_macros/src/newtype.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/6efdf4d1309f8047bc439a4810888c715e2df480/compiler%2Frustc_macros%2Fsrc%2Fnewtype.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6efdf4d1309f8047bc439a4810888c715e2df480/compiler%2Frustc_macros%2Fsrc%2Fnewtype.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_macros%2Fsrc%2Fnewtype.rs?ref=6efdf4d1309f8047bc439a4810888c715e2df480", "patch": "@@ -25,7 +25,7 @@ impl Parse for Newtype {\n         let mut encodable = true;\n         let mut ord = true;\n \n-        attrs.retain(|attr| match attr.path.get_ident() {\n+        attrs.retain(|attr| match attr.path().get_ident() {\n             Some(ident) => match &*ident.to_string() {\n                 \"custom_encodable\" => {\n                     encodable = false;\n@@ -36,22 +36,22 @@ impl Parse for Newtype {\n                     false\n                 }\n                 \"max\" => {\n-                    let Ok(Meta::NameValue(literal) )= attr.parse_meta() else {\n+                    let Meta::NameValue(MetaNameValue { value: Expr::Lit(lit), .. }) = &attr.meta else {\n                         panic!(\"#[max = NUMBER] attribute requires max value\");\n                     };\n \n-                    if let Some(old) = max.replace(literal.lit) {\n+                    if let Some(old) = max.replace(lit.lit.clone()) {\n                         panic!(\"Specified multiple max: {old:?}\");\n                     }\n \n                     false\n                 }\n                 \"debug_format\" => {\n-                    let Ok(Meta::NameValue(literal) )= attr.parse_meta() else {\n+                    let Meta::NameValue(MetaNameValue { value: Expr::Lit(lit), .. }) = &attr.meta else {\n                         panic!(\"#[debug_format = FMT] attribute requires a format\");\n                     };\n \n-                    if let Some(old) = debug_format.replace(literal.lit) {\n+                    if let Some(old) = debug_format.replace(lit.lit.clone()) {\n                         panic!(\"Specified multiple debug format options: {old:?}\");\n                     }\n "}, {"sha": "f85ba38003c13a39599c31959e049d8ef3a7b32b", "filename": "compiler/rustc_macros/src/query.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/6efdf4d1309f8047bc439a4810888c715e2df480/compiler%2Frustc_macros%2Fsrc%2Fquery.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6efdf4d1309f8047bc439a4810888c715e2df480/compiler%2Frustc_macros%2Fsrc%2Fquery.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_macros%2Fsrc%2Fquery.rs?ref=6efdf4d1309f8047bc439a4810888c715e2df480", "patch": "@@ -15,7 +15,7 @@ mod kw {\n /// Ensures only doc comment attributes are used\n fn check_attributes(attrs: Vec<Attribute>) -> Result<Vec<Attribute>> {\n     let inner = |attr: Attribute| {\n-        if !attr.path.is_ident(\"doc\") {\n+        if !attr.path().is_ident(\"doc\") {\n             Err(Error::new(attr.span(), \"attributes not supported on queries\"))\n         } else if attr.style != AttrStyle::Outer {\n             Err(Error::new(\n@@ -48,7 +48,7 @@ impl Parse for Query {\n         let name: Ident = input.parse()?;\n         let arg_content;\n         parenthesized!(arg_content in input);\n-        let key = arg_content.parse()?;\n+        let key = Pat::parse_single(&arg_content)?;\n         arg_content.parse::<Token![:]>()?;\n         let arg = arg_content.parse()?;\n         let result = input.parse()?;\n@@ -158,15 +158,15 @@ fn parse_query_modifiers(input: ParseStream<'_>) -> Result<QueryModifiers> {\n             } else {\n                 None\n             };\n-            let list = attr_content.parse_terminated(Expr::parse)?;\n+            let list = attr_content.parse_terminated(Expr::parse, Token![,])?;\n             try_insert!(desc = (tcx, list));\n         } else if modifier == \"cache_on_disk_if\" {\n             // Parse a cache modifier like:\n             // `cache(tcx) { |tcx| key.is_local() }`\n             let args = if input.peek(token::Paren) {\n                 let args;\n                 parenthesized!(args in input);\n-                let tcx = args.parse()?;\n+                let tcx = Pat::parse_single(&args)?;\n                 Some(tcx)\n             } else {\n                 None"}, {"sha": "5ee4d8793135ca8865982460f621012f015edd27", "filename": "compiler/rustc_macros/src/type_foldable.rs", "status": "modified", "additions": 13, "deletions": 14, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/6efdf4d1309f8047bc439a4810888c715e2df480/compiler%2Frustc_macros%2Fsrc%2Ftype_foldable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6efdf4d1309f8047bc439a4810888c715e2df480/compiler%2Frustc_macros%2Fsrc%2Ftype_foldable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_macros%2Fsrc%2Ftype_foldable.rs?ref=6efdf4d1309f8047bc439a4810888c715e2df480", "patch": "@@ -1,5 +1,5 @@\n use quote::{quote, ToTokens};\n-use syn::{parse_quote, Attribute, Meta, NestedMeta};\n+use syn::parse_quote;\n \n pub fn type_foldable_derive(mut s: synstructure::Structure<'_>) -> proc_macro2::TokenStream {\n     if let syn::Data::Union(_) = s.ast().data {\n@@ -17,21 +17,20 @@ pub fn type_foldable_derive(mut s: synstructure::Structure<'_>) -> proc_macro2::\n         vi.construct(|_, index| {\n             let bind = &bindings[index];\n \n+            let mut fixed = false;\n+\n             // retain value of fields with #[type_foldable(identity)]\n-            let fixed = bind\n-                .ast()\n-                .attrs\n-                .iter()\n-                .map(Attribute::parse_meta)\n-                .filter_map(Result::ok)\n-                .flat_map(|attr| match attr {\n-                    Meta::List(list) if list.path.is_ident(\"type_foldable\") => list.nested,\n-                    _ => Default::default(),\n-                })\n-                .any(|nested| match nested {\n-                    NestedMeta::Meta(Meta::Path(path)) => path.is_ident(\"identity\"),\n-                    _ => false,\n+            bind.ast().attrs.iter().for_each(|x| {\n+                if !x.path().is_ident(\"type_foldable\") {\n+                    return;\n+                }\n+                let _ = x.parse_nested_meta(|nested| {\n+                    if nested.path.is_ident(\"identity\") {\n+                        fixed = true;\n+                    }\n+                    Ok(())\n                 });\n+            });\n \n             if fixed {\n                 bind.to_token_stream()"}, {"sha": "dcd505a105e579c8387f696b82b70b94e8d0655f", "filename": "compiler/rustc_macros/src/type_visitable.rs", "status": "modified", "additions": 16, "deletions": 14, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/6efdf4d1309f8047bc439a4810888c715e2df480/compiler%2Frustc_macros%2Fsrc%2Ftype_visitable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6efdf4d1309f8047bc439a4810888c715e2df480/compiler%2Frustc_macros%2Fsrc%2Ftype_visitable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_macros%2Fsrc%2Ftype_visitable.rs?ref=6efdf4d1309f8047bc439a4810888c715e2df480", "patch": "@@ -1,5 +1,5 @@\n use quote::quote;\n-use syn::{parse_quote, Attribute, Meta, NestedMeta};\n+use syn::parse_quote;\n \n pub fn type_visitable_derive(mut s: synstructure::Structure<'_>) -> proc_macro2::TokenStream {\n     if let syn::Data::Union(_) = s.ast().data {\n@@ -8,19 +8,21 @@ pub fn type_visitable_derive(mut s: synstructure::Structure<'_>) -> proc_macro2:\n \n     // ignore fields with #[type_visitable(ignore)]\n     s.filter(|bi| {\n-        !bi.ast()\n-            .attrs\n-            .iter()\n-            .map(Attribute::parse_meta)\n-            .filter_map(Result::ok)\n-            .flat_map(|attr| match attr {\n-                Meta::List(list) if list.path.is_ident(\"type_visitable\") => list.nested,\n-                _ => Default::default(),\n-            })\n-            .any(|nested| match nested {\n-                NestedMeta::Meta(Meta::Path(path)) => path.is_ident(\"ignore\"),\n-                _ => false,\n-            })\n+        let mut ignored = false;\n+\n+        bi.ast().attrs.iter().for_each(|attr| {\n+            if !attr.path().is_ident(\"type_visitable\") {\n+                return;\n+            }\n+            let _ = attr.parse_nested_meta(|nested| {\n+                if nested.path.is_ident(\"ignore\") {\n+                    ignored = true;\n+                }\n+                Ok(())\n+            });\n+        });\n+\n+        !ignored\n     });\n \n     if !s.ast().generics.lifetimes().any(|lt| lt.lifetime.ident == \"tcx\") {"}, {"sha": "23aceca06223a01142ed448da5a0cda2d025a59d", "filename": "compiler/rustc_metadata/src/creader.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6efdf4d1309f8047bc439a4810888c715e2df480/compiler%2Frustc_metadata%2Fsrc%2Fcreader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6efdf4d1309f8047bc439a4810888c715e2df480/compiler%2Frustc_metadata%2Fsrc%2Fcreader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Fcreader.rs?ref=6efdf4d1309f8047bc439a4810888c715e2df480", "patch": "@@ -185,7 +185,7 @@ impl CStore {\n     fn push_dependencies_in_postorder(&self, deps: &mut Vec<CrateNum>, cnum: CrateNum) {\n         if !deps.contains(&cnum) {\n             let data = self.get_crate_data(cnum);\n-            for &dep in data.dependencies().iter() {\n+            for dep in data.dependencies() {\n                 if dep != cnum {\n                     self.push_dependencies_in_postorder(deps, dep);\n                 }\n@@ -605,7 +605,7 @@ impl<'a, 'tcx> CrateLoader<'a, 'tcx> {\n         if cmeta.update_extern_crate(extern_crate) {\n             // Propagate the extern crate info to dependencies if it was updated.\n             let extern_crate = ExternCrate { dependency_of: cnum, ..extern_crate };\n-            for &dep_cnum in cmeta.dependencies().iter() {\n+            for dep_cnum in cmeta.dependencies() {\n                 self.update_extern_crate(dep_cnum, extern_crate);\n             }\n         }"}, {"sha": "81e62eccb8a59feb37d6a0197a402352992ba579", "filename": "compiler/rustc_metadata/src/lib.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6efdf4d1309f8047bc439a4810888c715e2df480/compiler%2Frustc_metadata%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6efdf4d1309f8047bc439a4810888c715e2df480/compiler%2Frustc_metadata%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Flib.rs?ref=6efdf4d1309f8047bc439a4810888c715e2df480", "patch": "@@ -22,8 +22,6 @@ extern crate proc_macro;\n extern crate rustc_macros;\n #[macro_use]\n extern crate rustc_middle;\n-#[macro_use]\n-extern crate rustc_data_structures;\n \n #[macro_use]\n extern crate tracing;"}, {"sha": "c6af8d6328983a564f05ea6d666308f1433dd000", "filename": "compiler/rustc_metadata/src/locator.rs", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/6efdf4d1309f8047bc439a4810888c715e2df480/compiler%2Frustc_metadata%2Fsrc%2Flocator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6efdf4d1309f8047bc439a4810888c715e2df480/compiler%2Frustc_metadata%2Fsrc%2Flocator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Flocator.rs?ref=6efdf4d1309f8047bc439a4810888c715e2df480", "patch": "@@ -218,7 +218,7 @@ use crate::rmeta::{rustc_version, MetadataBlob, METADATA_HEADER};\n \n use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n use rustc_data_structures::memmap::Mmap;\n-use rustc_data_structures::owning_ref::OwningRef;\n+use rustc_data_structures::owned_slice::slice_owned;\n use rustc_data_structures::svh::Svh;\n use rustc_data_structures::sync::MetadataRef;\n use rustc_errors::{DiagnosticArgValue, FatalError, IntoDiagnosticArg};\n@@ -236,6 +236,7 @@ use rustc_target::spec::{Target, TargetTriple};\n use snap::read::FrameDecoder;\n use std::borrow::Cow;\n use std::io::{Read, Result as IoResult, Write};\n+use std::ops::Deref;\n use std::path::{Path, PathBuf};\n use std::{cmp, fmt};\n \n@@ -761,14 +762,14 @@ impl<'a> CrateLocator<'a> {\n     }\n \n     pub(crate) fn into_error(self, root: Option<CratePaths>) -> CrateError {\n-        CrateError::LocatorCombined(CombinedLocatorError {\n+        CrateError::LocatorCombined(Box::new(CombinedLocatorError {\n             crate_name: self.crate_name,\n             root,\n             triple: self.triple,\n             dll_prefix: self.target.dll_prefix.to_string(),\n             dll_suffix: self.target.dll_suffix.to_string(),\n             crate_rejections: self.crate_rejections,\n-        })\n+        }))\n     }\n }\n \n@@ -814,15 +815,14 @@ fn get_metadata_section<'p>(\n             // Assume the decompressed data will be at least the size of the compressed data, so we\n             // don't have to grow the buffer as much.\n             let mut inflated = Vec::with_capacity(compressed_bytes.len());\n-            match FrameDecoder::new(compressed_bytes).read_to_end(&mut inflated) {\n-                Ok(_) => rustc_erase_owner!(OwningRef::new(inflated).map_owner_box()),\n-                Err(_) => {\n-                    return Err(MetadataError::LoadFailure(format!(\n-                        \"failed to decompress metadata: {}\",\n-                        filename.display()\n-                    )));\n-                }\n-            }\n+            FrameDecoder::new(compressed_bytes).read_to_end(&mut inflated).map_err(|_| {\n+                MetadataError::LoadFailure(format!(\n+                    \"failed to decompress metadata: {}\",\n+                    filename.display()\n+                ))\n+            })?;\n+\n+            slice_owned(inflated, Deref::deref)\n         }\n         CrateFlavor::Rmeta => {\n             // mmap the file, because only a small fraction of it is read.\n@@ -840,7 +840,7 @@ fn get_metadata_section<'p>(\n                 ))\n             })?;\n \n-            rustc_erase_owner!(OwningRef::new(mmap).map_owner_box())\n+            slice_owned(mmap, Deref::deref)\n         }\n     };\n     let blob = MetadataBlob::new(raw_bytes);\n@@ -958,7 +958,7 @@ pub(crate) enum CrateError {\n     StableCrateIdCollision(Symbol, Symbol),\n     DlOpen(String),\n     DlSym(String),\n-    LocatorCombined(CombinedLocatorError),\n+    LocatorCombined(Box<CombinedLocatorError>),\n     NonDylibPlugin(Symbol),\n }\n "}, {"sha": "f9d32ffceef61fa6828f30d4b15f9b7f25020a78", "filename": "compiler/rustc_metadata/src/rmeta/decoder.rs", "status": "modified", "additions": 7, "deletions": 13, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/6efdf4d1309f8047bc439a4810888c715e2df480/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6efdf4d1309f8047bc439a4810888c715e2df480/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder.rs?ref=6efdf4d1309f8047bc439a4810888c715e2df480", "patch": "@@ -7,7 +7,7 @@ use rustc_ast as ast;\n use rustc_data_structures::captures::Captures;\n use rustc_data_structures::fx::FxHashMap;\n use rustc_data_structures::svh::Svh;\n-use rustc_data_structures::sync::{Lock, LockGuard, Lrc, OnceCell};\n+use rustc_data_structures::sync::{AppendOnlyVec, Lock, Lrc, OnceCell};\n use rustc_data_structures::unhash::UnhashMap;\n use rustc_expand::base::{SyntaxExtension, SyntaxExtensionKind};\n use rustc_expand::proc_macro::{AttrProcMacro, BangProcMacro, DeriveProcMacro};\n@@ -51,12 +51,6 @@ mod cstore_impl;\n #[derive(Clone)]\n pub(crate) struct MetadataBlob(Lrc<MetadataRef>);\n \n-// This is needed so we can create an OwningRef into the blob.\n-// The data behind a `MetadataBlob` has a stable address because it is\n-// contained within an Rc/Arc.\n-unsafe impl rustc_data_structures::owning_ref::StableAddress for MetadataBlob {}\n-\n-// This is needed so we can create an OwningRef into the blob.\n impl std::ops::Deref for MetadataBlob {\n     type Target = [u8];\n \n@@ -109,7 +103,7 @@ pub(crate) struct CrateMetadata {\n     /// IDs as they are seen from the current compilation session.\n     cnum_map: CrateNumMap,\n     /// Same ID set as `cnum_map` plus maybe some injected crates like panic runtime.\n-    dependencies: Lock<Vec<CrateNum>>,\n+    dependencies: AppendOnlyVec<CrateNum>,\n     /// How to link (or not link) this crate to the currently compiled crate.\n     dep_kind: Lock<CrateDepKind>,\n     /// Filesystem location of this crate.\n@@ -997,7 +991,7 @@ impl<'a, 'tcx> CrateMetadataRef<'a> {\n             _ => false,\n         };\n \n-        ModChild { ident, res, vis, span, macro_rules }\n+        ModChild { ident, res, vis, span, macro_rules, reexport_chain: Default::default() }\n     }\n \n     /// Iterates over all named children of the given module,\n@@ -1594,7 +1588,7 @@ impl CrateMetadata {\n             .collect();\n         let alloc_decoding_state =\n             AllocDecodingState::new(root.interpret_alloc_index.decode(&blob).collect());\n-        let dependencies = Lock::new(cnum_map.iter().cloned().collect());\n+        let dependencies = cnum_map.iter().copied().collect();\n \n         // Pre-decode the DefPathHash->DefIndex table. This is a cheap operation\n         // that does not copy any data. It just does some data verification.\n@@ -1634,12 +1628,12 @@ impl CrateMetadata {\n         cdata\n     }\n \n-    pub(crate) fn dependencies(&self) -> LockGuard<'_, Vec<CrateNum>> {\n-        self.dependencies.borrow()\n+    pub(crate) fn dependencies(&self) -> impl Iterator<Item = CrateNum> + '_ {\n+        self.dependencies.iter()\n     }\n \n     pub(crate) fn add_dependency(&self, cnum: CrateNum) {\n-        self.dependencies.borrow_mut().push(cnum);\n+        self.dependencies.push(cnum);\n     }\n \n     pub(crate) fn update_extern_crate(&self, new_extern_crate: ExternCrate) -> bool {"}, {"sha": "02cab561b8f612dac707b678f9db2f97a2254a7b", "filename": "compiler/rustc_metadata/src/rmeta/def_path_hash_map.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/6efdf4d1309f8047bc439a4810888c715e2df480/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdef_path_hash_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6efdf4d1309f8047bc439a4810888c715e2df480/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdef_path_hash_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdef_path_hash_map.rs?ref=6efdf4d1309f8047bc439a4810888c715e2df480", "patch": "@@ -1,14 +1,14 @@\n use crate::rmeta::DecodeContext;\n use crate::rmeta::EncodeContext;\n-use crate::rmeta::MetadataBlob;\n-use rustc_data_structures::owning_ref::OwningRef;\n+use rustc_data_structures::owned_slice::slice_owned;\n+use rustc_data_structures::owned_slice::OwnedSlice;\n use rustc_hir::def_path_hash_map::{Config as HashMapConfig, DefPathHashMap};\n use rustc_middle::parameterized_over_tcx;\n use rustc_serialize::{Decodable, Decoder, Encodable, Encoder};\n use rustc_span::def_id::{DefIndex, DefPathHash};\n \n pub(crate) enum DefPathHashMapRef<'tcx> {\n-    OwnedFromMetadata(odht::HashTable<HashMapConfig, OwningRef<MetadataBlob, [u8]>>),\n+    OwnedFromMetadata(odht::HashTable<HashMapConfig, OwnedSlice>),\n     BorrowedFromTcx(&'tcx DefPathHashMap),\n }\n \n@@ -50,11 +50,11 @@ impl<'a, 'tcx> Decodable<DecodeContext<'a, 'tcx>> for DefPathHashMapRef<'static>\n \n         let len = d.read_usize();\n         let pos = d.position();\n-        let o = OwningRef::new(d.blob().clone()).map(|x| &x[pos..pos + len]);\n+        let o = slice_owned(d.blob().clone(), |blob| &blob[pos..pos + len]);\n \n-        // Although we already have the data we need via the OwningRef, we still need\n-        // to advance the DecodeContext's position so it's in a valid state after\n-        // the method. We use read_raw_bytes() for that.\n+        // Although we already have the data we need via the `OwnedSlice`, we still need\n+        // to advance the `DecodeContext`'s position so it's in a valid state after\n+        // the method. We use `read_raw_bytes()` for that.\n         let _ = d.read_raw_bytes(len);\n \n         let inner = odht::HashTable::from_raw_bytes(o).unwrap_or_else(|e| {"}, {"sha": "4291b9aa14266a68a3299434198dcbd04db75d62", "filename": "compiler/rustc_metadata/src/rmeta/encoder.rs", "status": "modified", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/6efdf4d1309f8047bc439a4810888c715e2df480/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6efdf4d1309f8047bc439a4810888c715e2df480/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fencoder.rs?ref=6efdf4d1309f8047bc439a4810888c715e2df480", "patch": "@@ -112,8 +112,6 @@ impl<'a, 'tcx> Encoder for EncodeContext<'a, 'tcx> {\n         emit_i8(i8);\n \n         emit_bool(bool);\n-        emit_f64(f64);\n-        emit_f32(f32);\n         emit_char(char);\n         emit_str(&str);\n         emit_raw_bytes(&[u8]);\n@@ -1329,8 +1327,8 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n                 }\n             }));\n \n-            if let Some(reexports) = tcx.module_reexports(local_def_id) {\n-                assert!(!reexports.is_empty());\n+            let reexports = tcx.module_reexports(local_def_id);\n+            if !reexports.is_empty() {\n                 record_array!(self.tables.module_reexports[def_id] <- reexports);\n             }\n         }\n@@ -1712,8 +1710,7 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n             let stability = tcx.lookup_stability(CRATE_DEF_ID);\n             let macros =\n                 self.lazy_array(tcx.resolutions(()).proc_macros.iter().map(|p| p.local_def_index));\n-            let spans = self.tcx.sess.parse_sess.proc_macro_quoted_spans();\n-            for (i, span) in spans.into_iter().enumerate() {\n+            for (i, span) in self.tcx.sess.parse_sess.proc_macro_quoted_spans() {\n                 let span = self.lazy(span);\n                 self.tables.proc_macro_quoted_spans.set_some(i, span);\n             }"}, {"sha": "dd1e254f405b65983b0e8be00f3fa889bfa8b1a5", "filename": "compiler/rustc_middle/src/arena.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/6efdf4d1309f8047bc439a4810888c715e2df480/compiler%2Frustc_middle%2Fsrc%2Farena.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6efdf4d1309f8047bc439a4810888c715e2df480/compiler%2Frustc_middle%2Fsrc%2Farena.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Farena.rs?ref=6efdf4d1309f8047bc439a4810888c715e2df480", "patch": "@@ -119,6 +119,7 @@ macro_rules! arena_types {\n             [] external_constraints: rustc_middle::traits::solve::ExternalConstraintsData<'tcx>,\n             [decode] doc_link_resolutions: rustc_hir::def::DocLinkResMap,\n             [] closure_kind_origin: (rustc_span::Span, rustc_middle::hir::place::Place<'tcx>),\n+            [] mod_child: rustc_middle::metadata::ModChild,\n         ]);\n     )\n }"}, {"sha": "0ddbe7d1c2922a76c563e21312f382c3b32e9192", "filename": "compiler/rustc_middle/src/dep_graph/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6efdf4d1309f8047bc439a4810888c715e2df480/compiler%2Frustc_middle%2Fsrc%2Fdep_graph%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6efdf4d1309f8047bc439a4810888c715e2df480/compiler%2Frustc_middle%2Fsrc%2Fdep_graph%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fdep_graph%2Fmod.rs?ref=6efdf4d1309f8047bc439a4810888c715e2df480", "patch": "@@ -94,7 +94,7 @@ impl<'tcx> DepContext for TyCtxt<'tcx> {\n     }\n \n     #[inline]\n-    fn dep_kind_info(&self, dep_kind: DepKind) -> &DepKindStruct<'tcx> {\n-        &self.query_kinds[dep_kind as usize]\n+    fn dep_kind_info(&self, dk: DepKind) -> &DepKindStruct<'tcx> {\n+        &self.query_kinds[dk as usize]\n     }\n }"}, {"sha": "9d97a75a2fa6f96e728b3c64a3ff7ff345a5d6fb", "filename": "compiler/rustc_middle/src/hir/map/mod.rs", "status": "modified", "additions": 8, "deletions": 9, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/6efdf4d1309f8047bc439a4810888c715e2df480/compiler%2Frustc_middle%2Fsrc%2Fhir%2Fmap%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6efdf4d1309f8047bc439a4810888c715e2df480/compiler%2Frustc_middle%2Fsrc%2Fhir%2Fmap%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fhir%2Fmap%2Fmod.rs?ref=6efdf4d1309f8047bc439a4810888c715e2df480", "patch": "@@ -74,18 +74,17 @@ impl<'hir> Iterator for ParentHirIterator<'hir> {\n         if self.current_id == CRATE_HIR_ID {\n             return None;\n         }\n-        loop {\n-            // There are nodes that do not have entries, so we need to skip them.\n-            let parent_id = self.map.parent_id(self.current_id);\n \n-            if parent_id == self.current_id {\n-                self.current_id = CRATE_HIR_ID;\n-                return None;\n-            }\n+        // There are nodes that do not have entries, so we need to skip them.\n+        let parent_id = self.map.parent_id(self.current_id);\n \n-            self.current_id = parent_id;\n-            return Some(parent_id);\n+        if parent_id == self.current_id {\n+            self.current_id = CRATE_HIR_ID;\n+            return None;\n         }\n+\n+        self.current_id = parent_id;\n+        return Some(parent_id);\n     }\n }\n "}, {"sha": "b5b712c367d08d36147ab99664e182d5516c116a", "filename": "compiler/rustc_middle/src/infer/canonical.rs", "status": "modified", "additions": 18, "deletions": 6, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/6efdf4d1309f8047bc439a4810888c715e2df480/compiler%2Frustc_middle%2Fsrc%2Finfer%2Fcanonical.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6efdf4d1309f8047bc439a4810888c715e2df480/compiler%2Frustc_middle%2Fsrc%2Finfer%2Fcanonical.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Finfer%2Fcanonical.rs?ref=6efdf4d1309f8047bc439a4810888c715e2df480", "patch": "@@ -35,9 +35,9 @@ use std::ops::Index;\n #[derive(Copy, Clone, Debug, PartialEq, Eq, Hash, TyDecodable, TyEncodable)]\n #[derive(HashStable, TypeFoldable, TypeVisitable, Lift)]\n pub struct Canonical<'tcx, V> {\n+    pub value: V,\n     pub max_universe: ty::UniverseIndex,\n     pub variables: CanonicalVarInfos<'tcx>,\n-    pub value: V,\n }\n \n pub type CanonicalVarInfos<'tcx> = &'tcx List<CanonicalVarInfo<'tcx>>;\n@@ -80,6 +80,18 @@ impl CanonicalVarValues<'_> {\n             }\n         })\n     }\n+\n+    pub fn is_identity_modulo_regions(&self) -> bool {\n+        self.var_values.iter().enumerate().all(|(bv, arg)| match arg.unpack() {\n+            ty::GenericArgKind::Lifetime(_) => true,\n+            ty::GenericArgKind::Type(ty) => {\n+                matches!(*ty.kind(), ty::Bound(ty::INNERMOST, bt) if bt.var.as_usize() == bv)\n+            }\n+            ty::GenericArgKind::Const(ct) => {\n+                matches!(ct.kind(), ty::ConstKind::Bound(ty::INNERMOST, bc) if bc.as_usize() == bv)\n+            }\n+        })\n+    }\n }\n \n /// When we canonicalize a value to form a query, we wind up replacing\n@@ -149,15 +161,15 @@ impl<'tcx> CanonicalVarInfo<'tcx> {\n         }\n     }\n \n-    pub fn expect_anon_placeholder(self) -> u32 {\n+    pub fn expect_placeholder_index(self) -> usize {\n         match self.kind {\n             CanonicalVarKind::Ty(_)\n             | CanonicalVarKind::Region(_)\n             | CanonicalVarKind::Const(_, _) => bug!(\"expected placeholder: {self:?}\"),\n \n-            CanonicalVarKind::PlaceholderRegion(placeholder) => placeholder.name.expect_anon(),\n-            CanonicalVarKind::PlaceholderTy(placeholder) => placeholder.name.expect_anon(),\n-            CanonicalVarKind::PlaceholderConst(placeholder, _) => placeholder.name.as_u32(),\n+            CanonicalVarKind::PlaceholderRegion(placeholder) => placeholder.bound.var.as_usize(),\n+            CanonicalVarKind::PlaceholderTy(placeholder) => placeholder.bound.var.as_usize(),\n+            CanonicalVarKind::PlaceholderConst(placeholder, _) => placeholder.bound.as_usize(),\n         }\n     }\n }\n@@ -411,7 +423,7 @@ impl<'tcx> CanonicalVarValues<'tcx> {\n                         CanonicalVarKind::Region(_) | CanonicalVarKind::PlaceholderRegion(_) => {\n                             let br = ty::BoundRegion {\n                                 var: ty::BoundVar::from_usize(i),\n-                                kind: ty::BrAnon(i as u32, None),\n+                                kind: ty::BrAnon(None),\n                             };\n                             tcx.mk_re_late_bound(ty::INNERMOST, br).into()\n                         }"}, {"sha": "b4edb02f6c48dea096f6aecee9d9103e9e61bf9d", "filename": "compiler/rustc_middle/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/6efdf4d1309f8047bc439a4810888c715e2df480/compiler%2Frustc_middle%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6efdf4d1309f8047bc439a4810888c715e2df480/compiler%2Frustc_middle%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Flib.rs?ref=6efdf4d1309f8047bc439a4810888c715e2df480", "patch": "@@ -33,6 +33,7 @@\n #![feature(generators)]\n #![feature(get_mut_unchecked)]\n #![feature(if_let_guard)]\n+#![feature(inline_const)]\n #![feature(iter_from_generator)]\n #![feature(local_key_cell_methods)]\n #![feature(negative_impls)]"}, {"sha": "fabc6bce7317bd24fa259ea384cee7441abe8c57", "filename": "compiler/rustc_middle/src/metadata.rs", "status": "modified", "additions": 25, "deletions": 1, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/6efdf4d1309f8047bc439a4810888c715e2df480/compiler%2Frustc_middle%2Fsrc%2Fmetadata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6efdf4d1309f8047bc439a4810888c715e2df480/compiler%2Frustc_middle%2Fsrc%2Fmetadata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmetadata.rs?ref=6efdf4d1309f8047bc439a4810888c715e2df480", "patch": "@@ -5,13 +5,34 @@ use rustc_macros::HashStable;\n use rustc_span::def_id::DefId;\n use rustc_span::symbol::Ident;\n use rustc_span::Span;\n+use smallvec::SmallVec;\n+\n+/// A simplified version of `ImportKind` from resolve.\n+/// `DefId`s here correspond to `use` and `extern crate` items themselves, not their targets.\n+#[derive(Clone, Copy, Debug, TyEncodable, TyDecodable, HashStable)]\n+pub enum Reexport {\n+    Single(DefId),\n+    Glob(DefId),\n+    ExternCrate(DefId),\n+    MacroUse,\n+    MacroExport,\n+}\n+\n+impl Reexport {\n+    pub fn id(self) -> Option<DefId> {\n+        match self {\n+            Reexport::Single(id) | Reexport::Glob(id) | Reexport::ExternCrate(id) => Some(id),\n+            Reexport::MacroUse | Reexport::MacroExport => None,\n+        }\n+    }\n+}\n \n /// This structure is supposed to keep enough data to re-create `NameBinding`s for other crates\n /// during name resolution. Right now the bindings are not recreated entirely precisely so we may\n /// need to add more data in the future to correctly support macros 2.0, for example.\n /// Module child can be either a proper item or a reexport (including private imports).\n /// In case of reexport all the fields describe the reexport item itself, not what it refers to.\n-#[derive(Copy, Clone, Debug, TyEncodable, TyDecodable, HashStable)]\n+#[derive(Debug, TyEncodable, TyDecodable, HashStable)]\n pub struct ModChild {\n     /// Name of the item.\n     pub ident: Ident,\n@@ -24,4 +45,7 @@ pub struct ModChild {\n     pub span: Span,\n     /// A proper `macro_rules` item (not a reexport).\n     pub macro_rules: bool,\n+    /// Reexport chain linking this module child to its original reexported item.\n+    /// Empty if the module child is a proper item.\n+    pub reexport_chain: SmallVec<[Reexport; 2]>,\n }"}, {"sha": "1a8e48264471c51d17a9851ec52183556e51e048", "filename": "compiler/rustc_middle/src/mir/interpret/allocation.rs", "status": "modified", "additions": 17, "deletions": 9, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/6efdf4d1309f8047bc439a4810888c715e2df480/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Fallocation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6efdf4d1309f8047bc439a4810888c715e2df480/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Fallocation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Fallocation.rs?ref=6efdf4d1309f8047bc439a4810888c715e2df480", "patch": "@@ -109,26 +109,34 @@ const MAX_HASHED_BUFFER_LEN: usize = 2 * MAX_BYTES_TO_HASH;\n // large.\n impl hash::Hash for Allocation {\n     fn hash<H: hash::Hasher>(&self, state: &mut H) {\n+        let Self {\n+            bytes,\n+            provenance,\n+            init_mask,\n+            align,\n+            mutability,\n+            extra: (), // don't bother hashing ()\n+        } = self;\n+\n         // Partially hash the `bytes` buffer when it is large. To limit collisions with common\n         // prefixes and suffixes, we hash the length and some slices of the buffer.\n-        let byte_count = self.bytes.len();\n+        let byte_count = bytes.len();\n         if byte_count > MAX_HASHED_BUFFER_LEN {\n             // Hash the buffer's length.\n             byte_count.hash(state);\n \n             // And its head and tail.\n-            self.bytes[..MAX_BYTES_TO_HASH].hash(state);\n-            self.bytes[byte_count - MAX_BYTES_TO_HASH..].hash(state);\n+            bytes[..MAX_BYTES_TO_HASH].hash(state);\n+            bytes[byte_count - MAX_BYTES_TO_HASH..].hash(state);\n         } else {\n-            self.bytes.hash(state);\n+            bytes.hash(state);\n         }\n \n         // Hash the other fields as usual.\n-        self.provenance.hash(state);\n-        self.init_mask.hash(state);\n-        self.align.hash(state);\n-        self.mutability.hash(state);\n-        self.extra.hash(state);\n+        provenance.hash(state);\n+        init_mask.hash(state);\n+        align.hash(state);\n+        mutability.hash(state);\n     }\n }\n "}, {"sha": "1f8b650e34cfc9f082e4c807129dd75fdf3ed84e", "filename": "compiler/rustc_middle/src/mir/interpret/mod.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/6efdf4d1309f8047bc439a4810888c715e2df480/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6efdf4d1309f8047bc439a4810888c715e2df480/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Fmod.rs?ref=6efdf4d1309f8047bc439a4810888c715e2df480", "patch": "@@ -263,7 +263,8 @@ impl AllocDecodingState {\n     }\n \n     pub fn new(data_offsets: Vec<u32>) -> Self {\n-        let decoding_state = vec![Lock::new(State::Empty); data_offsets.len()];\n+        let decoding_state =\n+            std::iter::repeat_with(|| Lock::new(State::Empty)).take(data_offsets.len()).collect();\n \n         Self { decoding_state, data_offsets }\n     }"}, {"sha": "56755e588cb45604568c04e1781da272e12b60d3", "filename": "compiler/rustc_middle/src/mir/mod.rs", "status": "modified", "additions": 25, "deletions": 8, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/6efdf4d1309f8047bc439a4810888c715e2df480/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6efdf4d1309f8047bc439a4810888c715e2df480/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fmod.rs?ref=6efdf4d1309f8047bc439a4810888c715e2df480", "patch": "@@ -915,7 +915,7 @@ pub enum LocalInfo<'tcx> {\n \n impl<'tcx> LocalDecl<'tcx> {\n     pub fn local_info(&self) -> &LocalInfo<'tcx> {\n-        &**self.local_info.as_ref().assert_crate_local()\n+        &self.local_info.as_ref().assert_crate_local()\n     }\n \n     /// Returns `true` only if local is a binding that can itself be\n@@ -1036,8 +1036,7 @@ impl<'tcx> LocalDecl<'tcx> {\n \n #[derive(Clone, TyEncodable, TyDecodable, HashStable, TypeFoldable, TypeVisitable)]\n pub enum VarDebugInfoContents<'tcx> {\n-    /// NOTE(eddyb) There's an unenforced invariant that this `Place` is\n-    /// based on a `Local`, not a `Static`, and contains no indexing.\n+    /// This `Place` only contains projection which satisfy `can_use_in_debuginfo`.\n     Place(Place<'tcx>),\n     Const(Constant<'tcx>),\n     /// The user variable's data is split across several fragments,\n@@ -1047,6 +1046,7 @@ pub enum VarDebugInfoContents<'tcx> {\n     /// the underlying debuginfo feature this relies on.\n     Composite {\n         /// Type of the original user variable.\n+        /// This cannot contain a union or an enum.\n         ty: Ty<'tcx>,\n         /// All the parts of the original user variable, which ended\n         /// up in disjoint places, due to optimizations.\n@@ -1075,17 +1075,16 @@ pub struct VarDebugInfoFragment<'tcx> {\n     /// Where in the composite user variable this fragment is,\n     /// represented as a \"projection\" into the composite variable.\n     /// At lower levels, this corresponds to a byte/bit range.\n-    // NOTE(eddyb) there's an unenforced invariant that this contains\n-    // only `Field`s, and not into `enum` variants or `union`s.\n-    // FIXME(eddyb) support this for `enum`s by either using DWARF's\n+    ///\n+    /// This can only contain `PlaceElem::Field`.\n+    // FIXME support this for `enum`s by either using DWARF's\n     // more advanced control-flow features (unsupported by LLVM?)\n     // to match on the discriminant, or by using custom type debuginfo\n     // with non-overlapping variants for the composite variable.\n     pub projection: Vec<PlaceElem<'tcx>>,\n \n     /// Where the data for this fragment can be found.\n-    // NOTE(eddyb) There's an unenforced invariant that this `Place` is\n-    // contains no indexing (with a non-constant index).\n+    /// This `Place` only contains projection which satisfy `can_use_in_debuginfo`.\n     pub contents: Place<'tcx>,\n }\n \n@@ -1538,6 +1537,17 @@ impl<V, T> ProjectionElem<V, T> {\n     pub fn is_field_to(&self, f: FieldIdx) -> bool {\n         matches!(*self, Self::Field(x, _) if x == f)\n     }\n+\n+    /// Returns `true` if this is accepted inside `VarDebugInfoContents::Place`.\n+    pub fn can_use_in_debuginfo(&self) -> bool {\n+        match self {\n+            Self::Deref | Self::Downcast(_, _) | Self::Field(_, _) => true,\n+            Self::ConstantIndex { .. }\n+            | Self::Index(_)\n+            | Self::OpaqueCast(_)\n+            | Self::Subslice { .. } => false,\n+        }\n+    }\n }\n \n /// Alias for projections as they appear in `UserTypeProjection`, where we\n@@ -1991,6 +2001,13 @@ impl<'tcx> Rvalue<'tcx> {\n }\n \n impl BorrowKind {\n+    pub fn mutability(&self) -> Mutability {\n+        match *self {\n+            BorrowKind::Shared | BorrowKind::Shallow | BorrowKind::Unique => Mutability::Not,\n+            BorrowKind::Mut { .. } => Mutability::Mut,\n+        }\n+    }\n+\n     pub fn allows_two_phase_borrow(&self) -> bool {\n         match *self {\n             BorrowKind::Shared | BorrowKind::Shallow | BorrowKind::Unique => false,"}, {"sha": "f62853c3e740304e661f13aad808280de4d45c30", "filename": "compiler/rustc_middle/src/mir/patch.rs", "status": "modified", "additions": 59, "deletions": 5, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/6efdf4d1309f8047bc439a4810888c715e2df480/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fpatch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6efdf4d1309f8047bc439a4810888c715e2df480/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fpatch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fpatch.rs?ref=6efdf4d1309f8047bc439a4810888c715e2df480", "patch": "@@ -12,6 +12,9 @@ pub struct MirPatch<'tcx> {\n     new_statements: Vec<(Location, StatementKind<'tcx>)>,\n     new_locals: Vec<LocalDecl<'tcx>>,\n     resume_block: Option<BasicBlock>,\n+    // Only for unreachable in cleanup path.\n+    unreachable_cleanup_block: Option<BasicBlock>,\n+    terminate_block: Option<BasicBlock>,\n     body_span: Span,\n     next_local: usize,\n }\n@@ -25,14 +28,31 @@ impl<'tcx> MirPatch<'tcx> {\n             new_locals: vec![],\n             next_local: body.local_decls.len(),\n             resume_block: None,\n+            unreachable_cleanup_block: None,\n+            terminate_block: None,\n             body_span: body.span,\n         };\n \n-        // Check if we already have a resume block\n         for (bb, block) in body.basic_blocks.iter_enumerated() {\n+            // Check if we already have a resume block\n             if let TerminatorKind::Resume = block.terminator().kind && block.statements.is_empty() {\n                 result.resume_block = Some(bb);\n-                break;\n+                continue;\n+            }\n+\n+            // Check if we already have an unreachable block\n+            if let TerminatorKind::Unreachable = block.terminator().kind\n+                && block.statements.is_empty()\n+                && block.is_cleanup\n+            {\n+                result.unreachable_cleanup_block = Some(bb);\n+                continue;\n+            }\n+\n+            // Check if we already have a terminate block\n+            if let TerminatorKind::Terminate = block.terminator().kind && block.statements.is_empty() {\n+                result.terminate_block = Some(bb);\n+                continue;\n             }\n         }\n \n@@ -56,6 +76,40 @@ impl<'tcx> MirPatch<'tcx> {\n         bb\n     }\n \n+    pub fn unreachable_cleanup_block(&mut self) -> BasicBlock {\n+        if let Some(bb) = self.unreachable_cleanup_block {\n+            return bb;\n+        }\n+\n+        let bb = self.new_block(BasicBlockData {\n+            statements: vec![],\n+            terminator: Some(Terminator {\n+                source_info: SourceInfo::outermost(self.body_span),\n+                kind: TerminatorKind::Unreachable,\n+            }),\n+            is_cleanup: true,\n+        });\n+        self.unreachable_cleanup_block = Some(bb);\n+        bb\n+    }\n+\n+    pub fn terminate_block(&mut self) -> BasicBlock {\n+        if let Some(bb) = self.terminate_block {\n+            return bb;\n+        }\n+\n+        let bb = self.new_block(BasicBlockData {\n+            statements: vec![],\n+            terminator: Some(Terminator {\n+                source_info: SourceInfo::outermost(self.body_span),\n+                kind: TerminatorKind::Terminate,\n+            }),\n+            is_cleanup: true,\n+        });\n+        self.terminate_block = Some(bb);\n+        bb\n+    }\n+\n     pub fn is_patched(&self, bb: BasicBlock) -> bool {\n         self.patch_map[bb].is_some()\n     }\n@@ -79,21 +133,21 @@ impl<'tcx> MirPatch<'tcx> {\n         let mut new_decl = LocalDecl::new(ty, span).internal();\n         **new_decl.local_info.as_mut().assert_crate_local() = local_info;\n         self.new_locals.push(new_decl);\n-        Local::new(index as usize)\n+        Local::new(index)\n     }\n \n     pub fn new_temp(&mut self, ty: Ty<'tcx>, span: Span) -> Local {\n         let index = self.next_local;\n         self.next_local += 1;\n         self.new_locals.push(LocalDecl::new(ty, span));\n-        Local::new(index as usize)\n+        Local::new(index)\n     }\n \n     pub fn new_internal(&mut self, ty: Ty<'tcx>, span: Span) -> Local {\n         let index = self.next_local;\n         self.next_local += 1;\n         self.new_locals.push(LocalDecl::new(ty, span).internal());\n-        Local::new(index as usize)\n+        Local::new(index)\n     }\n \n     pub fn new_block(&mut self, data: BasicBlockData<'tcx>) -> BasicBlock {"}, {"sha": "cfdf1dcf5c02967f058b38f2494a3ca6f3e7fcab", "filename": "compiler/rustc_middle/src/mir/query.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/6efdf4d1309f8047bc439a4810888c715e2df480/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fquery.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6efdf4d1309f8047bc439a4810888c715e2df480/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fquery.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fquery.rs?ref=6efdf4d1309f8047bc439a4810888c715e2df480", "patch": "@@ -411,10 +411,8 @@ impl<'tcx> ClosureOutlivesSubjectTy<'tcx> {\n     pub fn bind(tcx: TyCtxt<'tcx>, ty: Ty<'tcx>) -> Self {\n         let inner = tcx.fold_regions(ty, |r, depth| match r.kind() {\n             ty::ReVar(vid) => {\n-                let br = ty::BoundRegion {\n-                    var: ty::BoundVar::new(vid.index()),\n-                    kind: ty::BrAnon(vid.as_u32(), None),\n-                };\n+                let br =\n+                    ty::BoundRegion { var: ty::BoundVar::new(vid.index()), kind: ty::BrAnon(None) };\n                 tcx.mk_re_late_bound(depth, br)\n             }\n             _ => bug!(\"unexpected region in ClosureOutlivesSubjectTy: {r:?}\"),"}, {"sha": "2165403da2671a2fb3dd15fd218bb0b0b2327417", "filename": "compiler/rustc_middle/src/mir/spanview.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6efdf4d1309f8047bc439a4810888c715e2df480/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fspanview.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6efdf4d1309f8047bc439a4810888c715e2df480/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fspanview.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fspanview.rs?ref=6efdf4d1309f8047bc439a4810888c715e2df480", "patch": "@@ -262,7 +262,7 @@ pub fn terminator_kind_name(term: &Terminator<'_>) -> &'static str {\n         Goto { .. } => \"Goto\",\n         SwitchInt { .. } => \"SwitchInt\",\n         Resume => \"Resume\",\n-        Abort => \"Abort\",\n+        Terminate => \"Terminate\",\n         Return => \"Return\",\n         Unreachable => \"Unreachable\",\n         Drop { .. } => \"Drop\","}, {"sha": "135889d0da810831a32e1529800727e7c92b2b96", "filename": "compiler/rustc_middle/src/mir/syntax.rs", "status": "modified", "additions": 37, "deletions": 19, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/6efdf4d1309f8047bc439a4810888c715e2df480/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fsyntax.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6efdf4d1309f8047bc439a4810888c715e2df480/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fsyntax.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fsyntax.rs?ref=6efdf4d1309f8047bc439a4810888c715e2df480", "patch": "@@ -515,15 +515,15 @@ pub struct CopyNonOverlapping<'tcx> {\n ///\n /// A note on unwinding: Panics may occur during the execution of some terminators. Depending on the\n /// `-C panic` flag, this may either cause the program to abort or the call stack to unwind. Such\n-/// terminators have a `cleanup: Option<BasicBlock>` field on them. If stack unwinding occurs, then\n-/// once the current function is reached, execution continues at the given basic block, if any. If\n-/// `cleanup` is `None` then no cleanup is performed, and the stack continues unwinding. This is\n-/// equivalent to the execution of a `Resume` terminator.\n+/// terminators have a `unwind: UnwindAction` field on them. If stack unwinding occurs, then\n+/// once the current function is reached, an action will be taken based on the `unwind` field.\n+/// If the action is `Cleanup`, then the execution continues at the given basic block. If the\n+/// action is `Continue` then no cleanup is performed, and the stack continues unwinding.\n ///\n-/// The basic block pointed to by a `cleanup` field must have its `cleanup` flag set. `cleanup`\n-/// basic blocks have a couple restrictions:\n-///  1. All `cleanup` fields in them must be `None`.\n-///  2. `Return` terminators are not allowed in them. `Abort` and `Unwind` terminators are.\n+/// The basic block pointed to by a `Cleanup` unwind action must have its `cleanup` flag set.\n+/// `cleanup` basic blocks have a couple restrictions:\n+///  1. All `unwind` fields in them must be `UnwindAction::Terminate` or `UnwindAction::Unreachable`.\n+///  2. `Return` terminators are not allowed in them. `Terminate` and `Resume` terminators are.\n ///  3. All other basic blocks (in the current body) that are reachable from `cleanup` basic blocks\n ///     must also be `cleanup`. This is a part of the type system and checked statically, so it is\n ///     still an error to have such an edge in the CFG even if it's known that it won't be taken at\n@@ -565,11 +565,11 @@ pub enum TerminatorKind<'tcx> {\n     /// deaggregation runs.\n     Resume,\n \n-    /// Indicates that the landing pad is finished and that the process should abort.\n+    /// Indicates that the landing pad is finished and that the process should terminate.\n     ///\n     /// Used to prevent unwinding for foreign items or with `-C unwind=abort`. Only permitted in\n     /// cleanup blocks.\n-    Abort,\n+    Terminate,\n \n     /// Returns from the function.\n     ///\n@@ -604,7 +604,7 @@ pub enum TerminatorKind<'tcx> {\n     /// > The drop glue is executed if, among all statements executed within this `Body`, an assignment to\n     /// > the place or one of its \"parents\" occurred more recently than a move out of it. This does not\n     /// > consider indirect assignments.\n-    Drop { place: Place<'tcx>, target: BasicBlock, unwind: Option<BasicBlock> },\n+    Drop { place: Place<'tcx>, target: BasicBlock, unwind: UnwindAction },\n \n     /// Roughly speaking, evaluates the `func` operand and the arguments, and starts execution of\n     /// the referred to function. The operand types must match the argument types of the function.\n@@ -628,8 +628,8 @@ pub enum TerminatorKind<'tcx> {\n         destination: Place<'tcx>,\n         /// Where to go after this call returns. If none, the call necessarily diverges.\n         target: Option<BasicBlock>,\n-        /// Cleanups to be done if the call unwinds.\n-        cleanup: Option<BasicBlock>,\n+        /// Action to be taken if the call unwinds.\n+        unwind: UnwindAction,\n         /// `true` if this is from a call in HIR rather than from an overloaded\n         /// operator. True for overloaded function call.\n         from_hir_call: bool,\n@@ -654,7 +654,7 @@ pub enum TerminatorKind<'tcx> {\n         expected: bool,\n         msg: AssertMessage<'tcx>,\n         target: BasicBlock,\n-        cleanup: Option<BasicBlock>,\n+        unwind: UnwindAction,\n     },\n \n     /// Marks a suspend point.\n@@ -720,9 +720,8 @@ pub enum TerminatorKind<'tcx> {\n         /// in practice, but in order to avoid fragility we want to always\n         /// consider it in borrowck. We don't want to accept programs which\n         /// pass borrowck only when `panic=abort` or some assertions are disabled\n-        /// due to release vs. debug mode builds. This needs to be an `Option` because\n-        /// of the `remove_noop_landing_pads` and `abort_unwinding_calls` passes.\n-        unwind: Option<BasicBlock>,\n+        /// due to release vs. debug mode builds.\n+        unwind: UnwindAction,\n     },\n \n     /// Block ends with an inline assembly block. This is a terminator since\n@@ -745,12 +744,31 @@ pub enum TerminatorKind<'tcx> {\n         /// diverging (InlineAsmOptions::NORETURN).\n         destination: Option<BasicBlock>,\n \n-        /// Cleanup to be done if the inline assembly unwinds. This is present\n+        /// Action to be taken if the inline assembly unwinds. This is present\n         /// if and only if InlineAsmOptions::MAY_UNWIND is set.\n-        cleanup: Option<BasicBlock>,\n+        unwind: UnwindAction,\n     },\n }\n \n+/// Action to be taken when a stack unwind happens.\n+#[derive(Copy, Clone, Debug, PartialEq, Eq, TyEncodable, TyDecodable, Hash, HashStable)]\n+#[derive(TypeFoldable, TypeVisitable)]\n+pub enum UnwindAction {\n+    /// No action is to be taken. Continue unwinding.\n+    ///\n+    /// This is similar to `Cleanup(bb)` where `bb` does nothing but `Resume`, but they are not\n+    /// equivalent, as presence of `Cleanup(_)` will make a frame non-POF.\n+    Continue,\n+    /// Triggers undefined behavior if unwind happens.\n+    Unreachable,\n+    /// Terminates the execution if unwind happens.\n+    ///\n+    /// Depending on the platform and situation this may cause a non-unwindable panic or abort.\n+    Terminate,\n+    /// Cleanups to be done.\n+    Cleanup(BasicBlock),\n+}\n+\n /// Information about an assertion failure.\n #[derive(Clone, TyEncodable, TyDecodable, Hash, HashStable, PartialEq, TypeFoldable, TypeVisitable)]\n pub enum AssertKind<O> {"}, {"sha": "4f00abf7fabc148e97b54c1c87a0ac04fe70e962", "filename": "compiler/rustc_middle/src/mir/tcx.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6efdf4d1309f8047bc439a4810888c715e2df480/compiler%2Frustc_middle%2Fsrc%2Fmir%2Ftcx.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6efdf4d1309f8047bc439a4810888c715e2df480/compiler%2Frustc_middle%2Fsrc%2Fmir%2Ftcx.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Ftcx.rs?ref=6efdf4d1309f8047bc439a4810888c715e2df480", "patch": "@@ -98,7 +98,7 @@ impl<'tcx> PlaceTy<'tcx> {\n                     ty::Array(inner, _) if !from_end => tcx.mk_array(*inner, (to - from) as u64),\n                     ty::Array(inner, size) if from_end => {\n                         let size = size.eval_target_usize(tcx, param_env);\n-                        let len = size - (from as u64) - (to as u64);\n+                        let len = size - from - to;\n                         tcx.mk_array(*inner, len)\n                     }\n                     _ => bug!(\"cannot subslice non-array type: `{:?}`\", self),"}, {"sha": "2c6126cdd29cdeded6a14af1ee513b608290b187", "filename": "compiler/rustc_middle/src/mir/terminator.rs", "status": "modified", "additions": 96, "deletions": 81, "changes": 177, "blob_url": "https://github.com/rust-lang/rust/blob/6efdf4d1309f8047bc439a4810888c715e2df480/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fterminator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6efdf4d1309f8047bc439a4810888c715e2df480/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fterminator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fterminator.rs?ref=6efdf4d1309f8047bc439a4810888c715e2df480", "patch": "@@ -1,6 +1,6 @@\n use smallvec::SmallVec;\n \n-use super::{BasicBlock, InlineAsmOperand, Operand, SourceInfo, TerminatorKind};\n+use super::{BasicBlock, InlineAsmOperand, Operand, SourceInfo, TerminatorKind, UnwindAction};\n use rustc_ast::InlineAsmTemplatePiece;\n pub use rustc_ast::Mutability;\n use rustc_macros::HashStable;\n@@ -118,11 +118,11 @@ impl<'tcx> Terminator<'tcx> {\n         self.kind.successors_mut()\n     }\n \n-    pub fn unwind(&self) -> Option<&Option<BasicBlock>> {\n+    pub fn unwind(&self) -> Option<&UnwindAction> {\n         self.kind.unwind()\n     }\n \n-    pub fn unwind_mut(&mut self) -> Option<&mut Option<BasicBlock>> {\n+    pub fn unwind_mut(&mut self) -> Option<&mut UnwindAction> {\n         self.kind.unwind_mut()\n     }\n }\n@@ -135,33 +135,33 @@ impl<'tcx> TerminatorKind<'tcx> {\n     pub fn successors(&self) -> Successors<'_> {\n         use self::TerminatorKind::*;\n         match *self {\n-            Resume\n-            | Abort\n-            | GeneratorDrop\n-            | Return\n-            | Unreachable\n-            | Call { target: None, cleanup: None, .. }\n-            | InlineAsm { destination: None, cleanup: None, .. } => {\n-                None.into_iter().chain((&[]).into_iter().copied())\n+            Call { target: Some(t), unwind: UnwindAction::Cleanup(ref u), .. }\n+            | Yield { resume: t, drop: Some(ref u), .. }\n+            | Drop { target: t, unwind: UnwindAction::Cleanup(ref u), .. }\n+            | Assert { target: t, unwind: UnwindAction::Cleanup(ref u), .. }\n+            | FalseUnwind { real_target: t, unwind: UnwindAction::Cleanup(ref u) }\n+            | InlineAsm { destination: Some(t), unwind: UnwindAction::Cleanup(ref u), .. } => {\n+                Some(t).into_iter().chain(slice::from_ref(u).into_iter().copied())\n             }\n             Goto { target: t }\n-            | Call { target: None, cleanup: Some(t), .. }\n-            | Call { target: Some(t), cleanup: None, .. }\n+            | Call { target: None, unwind: UnwindAction::Cleanup(t), .. }\n+            | Call { target: Some(t), unwind: _, .. }\n             | Yield { resume: t, drop: None, .. }\n-            | Drop { target: t, unwind: None, .. }\n-            | Assert { target: t, cleanup: None, .. }\n-            | FalseUnwind { real_target: t, unwind: None }\n-            | InlineAsm { destination: Some(t), cleanup: None, .. }\n-            | InlineAsm { destination: None, cleanup: Some(t), .. } => {\n+            | Drop { target: t, unwind: _, .. }\n+            | Assert { target: t, unwind: _, .. }\n+            | FalseUnwind { real_target: t, unwind: _ }\n+            | InlineAsm { destination: None, unwind: UnwindAction::Cleanup(t), .. }\n+            | InlineAsm { destination: Some(t), unwind: _, .. } => {\n                 Some(t).into_iter().chain((&[]).into_iter().copied())\n             }\n-            Call { target: Some(t), cleanup: Some(ref u), .. }\n-            | Yield { resume: t, drop: Some(ref u), .. }\n-            | Drop { target: t, unwind: Some(ref u), .. }\n-            | Assert { target: t, cleanup: Some(ref u), .. }\n-            | FalseUnwind { real_target: t, unwind: Some(ref u) }\n-            | InlineAsm { destination: Some(t), cleanup: Some(ref u), .. } => {\n-                Some(t).into_iter().chain(slice::from_ref(u).into_iter().copied())\n+            Resume\n+            | Terminate\n+            | GeneratorDrop\n+            | Return\n+            | Unreachable\n+            | Call { target: None, unwind: _, .. }\n+            | InlineAsm { destination: None, unwind: _, .. } => {\n+                None.into_iter().chain((&[]).into_iter().copied())\n             }\n             SwitchInt { ref targets, .. } => {\n                 None.into_iter().chain(targets.targets.iter().copied())\n@@ -175,74 +175,76 @@ impl<'tcx> TerminatorKind<'tcx> {\n     pub fn successors_mut(&mut self) -> SuccessorsMut<'_> {\n         use self::TerminatorKind::*;\n         match *self {\n-            Resume\n-            | Abort\n-            | GeneratorDrop\n-            | Return\n-            | Unreachable\n-            | Call { target: None, cleanup: None, .. }\n-            | InlineAsm { destination: None, cleanup: None, .. } => None.into_iter().chain(&mut []),\n+            Call { target: Some(ref mut t), unwind: UnwindAction::Cleanup(ref mut u), .. }\n+            | Yield { resume: ref mut t, drop: Some(ref mut u), .. }\n+            | Drop { target: ref mut t, unwind: UnwindAction::Cleanup(ref mut u), .. }\n+            | Assert { target: ref mut t, unwind: UnwindAction::Cleanup(ref mut u), .. }\n+            | FalseUnwind { real_target: ref mut t, unwind: UnwindAction::Cleanup(ref mut u) }\n+            | InlineAsm {\n+                destination: Some(ref mut t),\n+                unwind: UnwindAction::Cleanup(ref mut u),\n+                ..\n+            } => Some(t).into_iter().chain(slice::from_mut(u)),\n             Goto { target: ref mut t }\n-            | Call { target: None, cleanup: Some(ref mut t), .. }\n-            | Call { target: Some(ref mut t), cleanup: None, .. }\n+            | Call { target: None, unwind: UnwindAction::Cleanup(ref mut t), .. }\n+            | Call { target: Some(ref mut t), unwind: _, .. }\n             | Yield { resume: ref mut t, drop: None, .. }\n-            | Drop { target: ref mut t, unwind: None, .. }\n-            | Assert { target: ref mut t, cleanup: None, .. }\n-            | FalseUnwind { real_target: ref mut t, unwind: None }\n-            | InlineAsm { destination: Some(ref mut t), cleanup: None, .. }\n-            | InlineAsm { destination: None, cleanup: Some(ref mut t), .. } => {\n+            | Drop { target: ref mut t, unwind: _, .. }\n+            | Assert { target: ref mut t, unwind: _, .. }\n+            | FalseUnwind { real_target: ref mut t, unwind: _ }\n+            | InlineAsm { destination: None, unwind: UnwindAction::Cleanup(ref mut t), .. }\n+            | InlineAsm { destination: Some(ref mut t), unwind: _, .. } => {\n                 Some(t).into_iter().chain(&mut [])\n             }\n-            Call { target: Some(ref mut t), cleanup: Some(ref mut u), .. }\n-            | Yield { resume: ref mut t, drop: Some(ref mut u), .. }\n-            | Drop { target: ref mut t, unwind: Some(ref mut u), .. }\n-            | Assert { target: ref mut t, cleanup: Some(ref mut u), .. }\n-            | FalseUnwind { real_target: ref mut t, unwind: Some(ref mut u) }\n-            | InlineAsm { destination: Some(ref mut t), cleanup: Some(ref mut u), .. } => {\n-                Some(t).into_iter().chain(slice::from_mut(u))\n-            }\n+            Resume\n+            | Terminate\n+            | GeneratorDrop\n+            | Return\n+            | Unreachable\n+            | Call { target: None, unwind: _, .. }\n+            | InlineAsm { destination: None, unwind: _, .. } => None.into_iter().chain(&mut []),\n             SwitchInt { ref mut targets, .. } => None.into_iter().chain(&mut targets.targets),\n             FalseEdge { ref mut real_target, ref mut imaginary_target } => {\n                 Some(real_target).into_iter().chain(slice::from_mut(imaginary_target))\n             }\n         }\n     }\n \n-    pub fn unwind(&self) -> Option<&Option<BasicBlock>> {\n+    pub fn unwind(&self) -> Option<&UnwindAction> {\n         match *self {\n             TerminatorKind::Goto { .. }\n             | TerminatorKind::Resume\n-            | TerminatorKind::Abort\n+            | TerminatorKind::Terminate\n             | TerminatorKind::Return\n             | TerminatorKind::Unreachable\n             | TerminatorKind::GeneratorDrop\n             | TerminatorKind::Yield { .. }\n             | TerminatorKind::SwitchInt { .. }\n             | TerminatorKind::FalseEdge { .. } => None,\n-            TerminatorKind::Call { cleanup: ref unwind, .. }\n-            | TerminatorKind::Assert { cleanup: ref unwind, .. }\n+            TerminatorKind::Call { ref unwind, .. }\n+            | TerminatorKind::Assert { ref unwind, .. }\n             | TerminatorKind::Drop { ref unwind, .. }\n             | TerminatorKind::FalseUnwind { ref unwind, .. }\n-            | TerminatorKind::InlineAsm { cleanup: ref unwind, .. } => Some(unwind),\n+            | TerminatorKind::InlineAsm { ref unwind, .. } => Some(unwind),\n         }\n     }\n \n-    pub fn unwind_mut(&mut self) -> Option<&mut Option<BasicBlock>> {\n+    pub fn unwind_mut(&mut self) -> Option<&mut UnwindAction> {\n         match *self {\n             TerminatorKind::Goto { .. }\n             | TerminatorKind::Resume\n-            | TerminatorKind::Abort\n+            | TerminatorKind::Terminate\n             | TerminatorKind::Return\n             | TerminatorKind::Unreachable\n             | TerminatorKind::GeneratorDrop\n             | TerminatorKind::Yield { .. }\n             | TerminatorKind::SwitchInt { .. }\n             | TerminatorKind::FalseEdge { .. } => None,\n-            TerminatorKind::Call { cleanup: ref mut unwind, .. }\n-            | TerminatorKind::Assert { cleanup: ref mut unwind, .. }\n+            TerminatorKind::Call { ref mut unwind, .. }\n+            | TerminatorKind::Assert { ref mut unwind, .. }\n             | TerminatorKind::Drop { ref mut unwind, .. }\n             | TerminatorKind::FalseUnwind { ref mut unwind, .. }\n-            | TerminatorKind::InlineAsm { cleanup: ref mut unwind, .. } => Some(unwind),\n+            | TerminatorKind::InlineAsm { ref mut unwind, .. } => Some(unwind),\n         }\n     }\n \n@@ -268,11 +270,17 @@ impl<'tcx> Debug for TerminatorKind<'tcx> {\n         let labels = self.fmt_successor_labels();\n         assert_eq!(successor_count, labels.len());\n \n-        match successor_count {\n-            0 => Ok(()),\n-\n-            1 => write!(fmt, \" -> {:?}\", self.successors().next().unwrap()),\n-\n+        let unwind = match self.unwind() {\n+            // Not needed or included in successors\n+            None | Some(UnwindAction::Continue) | Some(UnwindAction::Cleanup(_)) => None,\n+            Some(UnwindAction::Unreachable) => Some(\"unwind unreachable\"),\n+            Some(UnwindAction::Terminate) => Some(\"unwind terminate\"),\n+        };\n+\n+        match (successor_count, unwind) {\n+            (0, None) => Ok(()),\n+            (0, Some(unwind)) => write!(fmt, \" -> {}\", unwind),\n+            (1, None) => write!(fmt, \" -> {:?}\", self.successors().next().unwrap()),\n             _ => {\n                 write!(fmt, \" -> [\")?;\n                 for (i, target) in self.successors().enumerate() {\n@@ -281,6 +289,9 @@ impl<'tcx> Debug for TerminatorKind<'tcx> {\n                     }\n                     write!(fmt, \"{}: {:?}\", labels[i], target)?;\n                 }\n+                if let Some(unwind) = unwind {\n+                    write!(fmt, \", {unwind}\")?;\n+                }\n                 write!(fmt, \"]\")\n             }\n         }\n@@ -299,7 +310,7 @@ impl<'tcx> TerminatorKind<'tcx> {\n             Return => write!(fmt, \"return\"),\n             GeneratorDrop => write!(fmt, \"generator_drop\"),\n             Resume => write!(fmt, \"resume\"),\n-            Abort => write!(fmt, \"abort\"),\n+            Terminate => write!(fmt, \"abort\"),\n             Yield { value, resume_arg, .. } => write!(fmt, \"{:?} = yield({:?})\", resume_arg, value),\n             Unreachable => write!(fmt, \"unreachable\"),\n             Drop { place, .. } => write!(fmt, \"drop({:?})\", place),\n@@ -378,39 +389,43 @@ impl<'tcx> TerminatorKind<'tcx> {\n     pub fn fmt_successor_labels(&self) -> Vec<Cow<'static, str>> {\n         use self::TerminatorKind::*;\n         match *self {\n-            Return | Resume | Abort | Unreachable | GeneratorDrop => vec![],\n+            Return | Resume | Terminate | Unreachable | GeneratorDrop => vec![],\n             Goto { .. } => vec![\"\".into()],\n             SwitchInt { ref targets, .. } => targets\n                 .values\n                 .iter()\n                 .map(|&u| Cow::Owned(u.to_string()))\n                 .chain(iter::once(\"otherwise\".into()))\n                 .collect(),\n-            Call { target: Some(_), cleanup: Some(_), .. } => {\n+            Call { target: Some(_), unwind: UnwindAction::Cleanup(_), .. } => {\n                 vec![\"return\".into(), \"unwind\".into()]\n             }\n-            Call { target: Some(_), cleanup: None, .. } => vec![\"return\".into()],\n-            Call { target: None, cleanup: Some(_), .. } => vec![\"unwind\".into()],\n-            Call { target: None, cleanup: None, .. } => vec![],\n+            Call { target: Some(_), unwind: _, .. } => vec![\"return\".into()],\n+            Call { target: None, unwind: UnwindAction::Cleanup(_), .. } => vec![\"unwind\".into()],\n+            Call { target: None, unwind: _, .. } => vec![],\n             Yield { drop: Some(_), .. } => vec![\"resume\".into(), \"drop\".into()],\n             Yield { drop: None, .. } => vec![\"resume\".into()],\n-            Drop { unwind: None, .. } => {\n-                vec![\"return\".into()]\n-            }\n-            Drop { unwind: Some(_), .. } => {\n-                vec![\"return\".into(), \"unwind\".into()]\n+            Drop { unwind: UnwindAction::Cleanup(_), .. } => vec![\"return\".into(), \"unwind\".into()],\n+            Drop { unwind: _, .. } => vec![\"return\".into()],\n+            Assert { unwind: UnwindAction::Cleanup(_), .. } => {\n+                vec![\"success\".into(), \"unwind\".into()]\n             }\n-            Assert { cleanup: None, .. } => vec![\"\".into()],\n-            Assert { .. } => vec![\"success\".into(), \"unwind\".into()],\n+            Assert { unwind: _, .. } => vec![\"success\".into()],\n             FalseEdge { .. } => vec![\"real\".into(), \"imaginary\".into()],\n-            FalseUnwind { unwind: Some(_), .. } => vec![\"real\".into(), \"cleanup\".into()],\n-            FalseUnwind { unwind: None, .. } => vec![\"real\".into()],\n-            InlineAsm { destination: Some(_), cleanup: Some(_), .. } => {\n+            FalseUnwind { unwind: UnwindAction::Cleanup(_), .. } => {\n+                vec![\"real\".into(), \"unwind\".into()]\n+            }\n+            FalseUnwind { unwind: _, .. } => vec![\"real\".into()],\n+            InlineAsm { destination: Some(_), unwind: UnwindAction::Cleanup(_), .. } => {\n                 vec![\"return\".into(), \"unwind\".into()]\n             }\n-            InlineAsm { destination: Some(_), cleanup: None, .. } => vec![\"return\".into()],\n-            InlineAsm { destination: None, cleanup: Some(_), .. } => vec![\"unwind\".into()],\n-            InlineAsm { destination: None, cleanup: None, .. } => vec![],\n+            InlineAsm { destination: Some(_), unwind: _, .. } => {\n+                vec![\"return\".into()]\n+            }\n+            InlineAsm { destination: None, unwind: UnwindAction::Cleanup(_), .. } => {\n+                vec![\"unwind\".into()]\n+            }\n+            InlineAsm { destination: None, unwind: _, .. } => vec![],\n         }\n     }\n }"}, {"sha": "7d247eeb656c2cfe953f77c21c450a062ece2a32", "filename": "compiler/rustc_middle/src/mir/traversal.rs", "status": "modified", "additions": 1, "deletions": 11, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/6efdf4d1309f8047bc439a4810888c715e2df480/compiler%2Frustc_middle%2Fsrc%2Fmir%2Ftraversal.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6efdf4d1309f8047bc439a4810888c715e2df480/compiler%2Frustc_middle%2Fsrc%2Fmir%2Ftraversal.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Ftraversal.rs?ref=6efdf4d1309f8047bc439a4810888c715e2df480", "patch": "@@ -178,17 +178,7 @@ impl<'a, 'tcx> Postorder<'a, 'tcx> {\n         // When we yield `B` and call `traverse_successor`, we push `C` to the stack, but\n         // since we've already visited `E`, that child isn't added to the stack. The last\n         // two iterations yield `C` and finally `A` for a final traversal of [E, D, B, C, A]\n-        loop {\n-            let bb = if let Some(&mut (_, ref mut iter)) = self.visit_stack.last_mut() {\n-                if let Some(bb) = iter.next() {\n-                    bb\n-                } else {\n-                    break;\n-                }\n-            } else {\n-                break;\n-            };\n-\n+        while let Some(&mut (_, ref mut iter)) = self.visit_stack.last_mut() && let Some(bb) = iter.next() {\n             if self.visited.insert(bb) {\n                 if let Some(term) = &self.basic_blocks[bb].terminator {\n                     self.visit_stack.push((bb, term.successors()));"}, {"sha": "6c4ea065abeb3a522d53f2c6ced9701cf432127e", "filename": "compiler/rustc_middle/src/mir/visit.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/6efdf4d1309f8047bc439a4810888c715e2df480/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6efdf4d1309f8047bc439a4810888c715e2df480/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fvisit.rs?ref=6efdf4d1309f8047bc439a4810888c715e2df480", "patch": "@@ -462,7 +462,7 @@ macro_rules! make_mir_visitor {\n                 match kind {\n                     TerminatorKind::Goto { .. } |\n                     TerminatorKind::Resume |\n-                    TerminatorKind::Abort |\n+                    TerminatorKind::Terminate |\n                     TerminatorKind::GeneratorDrop |\n                     TerminatorKind::Unreachable |\n                     TerminatorKind::FalseEdge { .. } |\n@@ -509,7 +509,7 @@ macro_rules! make_mir_visitor {\n                         args,\n                         destination,\n                         target: _,\n-                        cleanup: _,\n+                        unwind: _,\n                         from_hir_call: _,\n                         fn_span: _\n                     } => {\n@@ -529,7 +529,7 @@ macro_rules! make_mir_visitor {\n                         expected: _,\n                         msg,\n                         target: _,\n-                        cleanup: _,\n+                        unwind: _,\n                     } => {\n                         self.visit_operand(cond, location);\n                         self.visit_assert_message(msg, location);\n@@ -555,7 +555,7 @@ macro_rules! make_mir_visitor {\n                         options: _,\n                         line_spans: _,\n                         destination: _,\n-                        cleanup: _,\n+                        unwind: _,\n                     } => {\n                         for op in operands {\n                             match op {"}, {"sha": "24d98665a7b445809434f6a3bd442e707721b85b", "filename": "compiler/rustc_middle/src/query/erase.rs", "status": "added", "additions": 336, "deletions": 0, "changes": 336, "blob_url": "https://github.com/rust-lang/rust/blob/6efdf4d1309f8047bc439a4810888c715e2df480/compiler%2Frustc_middle%2Fsrc%2Fquery%2Ferase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6efdf4d1309f8047bc439a4810888c715e2df480/compiler%2Frustc_middle%2Fsrc%2Fquery%2Ferase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fquery%2Ferase.rs?ref=6efdf4d1309f8047bc439a4810888c715e2df480", "patch": "@@ -0,0 +1,336 @@\n+use crate::mir;\n+use crate::traits;\n+use crate::ty::{self, Ty};\n+use std::mem::{size_of, transmute_copy, MaybeUninit};\n+\n+#[derive(Copy, Clone)]\n+pub struct Erased<T: Copy> {\n+    // We use `MaybeUninit` here so we can store any value\n+    // in `data` since we aren't actually storing a `T`.\n+    data: MaybeUninit<T>,\n+}\n+\n+pub trait EraseType: Copy {\n+    type Result: Copy;\n+}\n+\n+// Allow `type_alias_bounds` since compilation will fail without `EraseType`.\n+#[allow(type_alias_bounds)]\n+pub type Erase<T: EraseType> = Erased<impl Copy>;\n+\n+#[inline(always)]\n+pub fn erase<T: EraseType>(src: T) -> Erase<T> {\n+    // Ensure the sizes match\n+    const {\n+        if std::mem::size_of::<T>() != std::mem::size_of::<T::Result>() {\n+            panic!(\"size of T must match erased type T::Result\")\n+        }\n+    };\n+\n+    Erased::<<T as EraseType>::Result> {\n+        // SAFETY: Is it safe to transmute to MaybeUninit for types with the same sizes.\n+        data: unsafe { transmute_copy(&src) },\n+    }\n+}\n+\n+/// Restores an erased value.\n+#[inline(always)]\n+pub fn restore<T: EraseType>(value: Erase<T>) -> T {\n+    let value: Erased<<T as EraseType>::Result> = value;\n+    // SAFETY: Due to the use of impl Trait in `Erase` the only way to safetly create an instance\n+    // of `Erase` is to call `erase`, so we know that `value.data` is a valid instance of `T` of\n+    // the right size.\n+    unsafe { transmute_copy(&value.data) }\n+}\n+\n+impl<T> EraseType for &'_ T {\n+    type Result = [u8; size_of::<*const ()>()];\n+}\n+\n+impl<T> EraseType for &'_ [T] {\n+    type Result = [u8; size_of::<*const [()]>()];\n+}\n+\n+impl<T> EraseType for &'_ ty::List<T> {\n+    type Result = [u8; size_of::<*const ()>()];\n+}\n+\n+impl<T> EraseType for Result<&'_ T, traits::query::NoSolution> {\n+    type Result = [u8; size_of::<Result<&'static (), traits::query::NoSolution>>()];\n+}\n+\n+impl<T> EraseType for Result<&'_ T, rustc_errors::ErrorGuaranteed> {\n+    type Result = [u8; size_of::<Result<&'static (), rustc_errors::ErrorGuaranteed>>()];\n+}\n+\n+impl<T> EraseType for Result<&'_ T, traits::CodegenObligationError> {\n+    type Result = [u8; size_of::<Result<&'static (), traits::CodegenObligationError>>()];\n+}\n+\n+impl<T> EraseType for Result<&'_ T, ty::layout::FnAbiError<'_>> {\n+    type Result = [u8; size_of::<Result<&'static (), ty::layout::FnAbiError<'static>>>()];\n+}\n+\n+impl<T> EraseType for Result<(&'_ T, rustc_middle::thir::ExprId), rustc_errors::ErrorGuaranteed> {\n+    type Result = [u8; size_of::<\n+        Result<(&'static (), rustc_middle::thir::ExprId), rustc_errors::ErrorGuaranteed>,\n+    >()];\n+}\n+\n+impl EraseType for Result<Option<ty::Instance<'_>>, rustc_errors::ErrorGuaranteed> {\n+    type Result =\n+        [u8; size_of::<Result<Option<ty::Instance<'static>>, rustc_errors::ErrorGuaranteed>>()];\n+}\n+\n+impl EraseType for Result<Option<ty::Const<'_>>, rustc_errors::ErrorGuaranteed> {\n+    type Result =\n+        [u8; size_of::<Result<Option<ty::Const<'static>>, rustc_errors::ErrorGuaranteed>>()];\n+}\n+\n+impl EraseType for Result<ty::GenericArg<'_>, traits::query::NoSolution> {\n+    type Result = [u8; size_of::<Result<ty::GenericArg<'static>, traits::query::NoSolution>>()];\n+}\n+\n+impl EraseType for Result<bool, ty::layout::LayoutError<'_>> {\n+    type Result = [u8; size_of::<Result<bool, ty::layout::LayoutError<'static>>>()];\n+}\n+\n+impl EraseType for Result<rustc_target::abi::TyAndLayout<'_, Ty<'_>>, ty::layout::LayoutError<'_>> {\n+    type Result = [u8; size_of::<\n+        Result<\n+            rustc_target::abi::TyAndLayout<'static, Ty<'static>>,\n+            ty::layout::LayoutError<'static>,\n+        >,\n+    >()];\n+}\n+\n+impl EraseType for Result<ty::Const<'_>, mir::interpret::LitToConstError> {\n+    type Result = [u8; size_of::<Result<ty::Const<'static>, mir::interpret::LitToConstError>>()];\n+}\n+\n+impl EraseType for Result<mir::ConstantKind<'_>, mir::interpret::LitToConstError> {\n+    type Result =\n+        [u8; size_of::<Result<mir::ConstantKind<'static>, mir::interpret::LitToConstError>>()];\n+}\n+\n+impl EraseType for Result<mir::interpret::ConstAlloc<'_>, mir::interpret::ErrorHandled> {\n+    type Result = [u8; size_of::<\n+        Result<mir::interpret::ConstAlloc<'static>, mir::interpret::ErrorHandled>,\n+    >()];\n+}\n+\n+impl EraseType for Result<mir::interpret::ConstValue<'_>, mir::interpret::ErrorHandled> {\n+    type Result = [u8; size_of::<\n+        Result<mir::interpret::ConstValue<'static>, mir::interpret::ErrorHandled>,\n+    >()];\n+}\n+\n+impl EraseType for Result<Option<ty::ValTree<'_>>, mir::interpret::ErrorHandled> {\n+    type Result =\n+        [u8; size_of::<Result<Option<ty::ValTree<'static>>, mir::interpret::ErrorHandled>>()];\n+}\n+\n+impl EraseType for Result<&'_ ty::List<Ty<'_>>, ty::util::AlwaysRequiresDrop> {\n+    type Result =\n+        [u8; size_of::<Result<&'static ty::List<Ty<'static>>, ty::util::AlwaysRequiresDrop>>()];\n+}\n+\n+impl<T> EraseType for Option<&'_ T> {\n+    type Result = [u8; size_of::<Option<&'static ()>>()];\n+}\n+\n+impl<T> EraseType for Option<&'_ [T]> {\n+    type Result = [u8; size_of::<Option<&'static [()]>>()];\n+}\n+\n+impl EraseType for Option<rustc_middle::hir::Owner<'_>> {\n+    type Result = [u8; size_of::<Option<rustc_middle::hir::Owner<'static>>>()];\n+}\n+\n+impl EraseType for Option<mir::DestructuredConstant<'_>> {\n+    type Result = [u8; size_of::<Option<mir::DestructuredConstant<'static>>>()];\n+}\n+\n+impl EraseType for Option<ty::EarlyBinder<ty::TraitRef<'_>>> {\n+    type Result = [u8; size_of::<Option<ty::EarlyBinder<ty::TraitRef<'static>>>>()];\n+}\n+\n+impl EraseType for Option<ty::EarlyBinder<Ty<'_>>> {\n+    type Result = [u8; size_of::<Option<ty::EarlyBinder<Ty<'static>>>>()];\n+}\n+\n+impl<T> EraseType for rustc_hir::MaybeOwner<&'_ T> {\n+    type Result = [u8; size_of::<rustc_hir::MaybeOwner<&'static ()>>()];\n+}\n+\n+impl<T: EraseType> EraseType for ty::EarlyBinder<T> {\n+    type Result = T::Result;\n+}\n+\n+impl EraseType for ty::Binder<'_, ty::FnSig<'_>> {\n+    type Result = [u8; size_of::<ty::Binder<'static, ty::FnSig<'static>>>()];\n+}\n+\n+impl<T0, T1> EraseType for (&'_ T0, &'_ T1) {\n+    type Result = [u8; size_of::<(&'static (), &'static ())>()];\n+}\n+\n+impl<T0, T1> EraseType for (&'_ T0, &'_ [T1]) {\n+    type Result = [u8; size_of::<(&'static (), &'static [()])>()];\n+}\n+\n+macro_rules! trivial {\n+    ($($ty:ty),+ $(,)?) => {\n+        $(\n+            impl EraseType for $ty {\n+                type Result = [u8; size_of::<$ty>()];\n+            }\n+        )*\n+    }\n+}\n+\n+trivial! {\n+    (),\n+    bool,\n+    Option<(rustc_span::def_id::DefId, rustc_session::config::EntryFnType)>,\n+    Option<rustc_ast::expand::allocator::AllocatorKind>,\n+    Option<rustc_attr::ConstStability>,\n+    Option<rustc_attr::DefaultBodyStability>,\n+    Option<rustc_attr::Stability>,\n+    Option<rustc_data_structures::svh::Svh>,\n+    Option<rustc_hir::def::DefKind>,\n+    Option<rustc_hir::GeneratorKind>,\n+    Option<rustc_hir::HirId>,\n+    Option<rustc_middle::middle::stability::DeprecationEntry>,\n+    Option<rustc_middle::ty::Destructor>,\n+    Option<rustc_middle::ty::ImplTraitInTraitData>,\n+    Option<rustc_span::def_id::CrateNum>,\n+    Option<rustc_span::def_id::DefId>,\n+    Option<rustc_span::def_id::LocalDefId>,\n+    Option<rustc_span::Span>,\n+    Option<rustc_target::spec::PanicStrategy>,\n+    Option<usize>,\n+    Result<(), rustc_errors::ErrorGuaranteed>,\n+    Result<(), rustc_middle::traits::query::NoSolution>,\n+    Result<rustc_middle::traits::EvaluationResult, rustc_middle::traits::OverflowError>,\n+    rustc_ast::expand::allocator::AllocatorKind,\n+    rustc_attr::ConstStability,\n+    rustc_attr::DefaultBodyStability,\n+    rustc_attr::Deprecation,\n+    rustc_attr::Stability,\n+    rustc_data_structures::svh::Svh,\n+    rustc_errors::ErrorGuaranteed,\n+    rustc_hir::Constness,\n+    rustc_hir::def_id::DefId,\n+    rustc_hir::def_id::DefIndex,\n+    rustc_hir::def_id::LocalDefId,\n+    rustc_hir::def::DefKind,\n+    rustc_hir::Defaultness,\n+    rustc_hir::definitions::DefKey,\n+    rustc_hir::GeneratorKind,\n+    rustc_hir::HirId,\n+    rustc_hir::IsAsync,\n+    rustc_hir::ItemLocalId,\n+    rustc_hir::LangItem,\n+    rustc_hir::OwnerId,\n+    rustc_hir::Upvar,\n+    rustc_index::bit_set::FiniteBitSet<u32>,\n+    rustc_middle::middle::dependency_format::Linkage,\n+    rustc_middle::middle::exported_symbols::SymbolExportInfo,\n+    rustc_middle::middle::resolve_bound_vars::ObjectLifetimeDefault,\n+    rustc_middle::middle::resolve_bound_vars::ResolvedArg,\n+    rustc_middle::middle::stability::DeprecationEntry,\n+    rustc_middle::mir::ConstQualifs,\n+    rustc_middle::mir::interpret::AllocId,\n+    rustc_middle::mir::interpret::ErrorHandled,\n+    rustc_middle::mir::interpret::LitToConstError,\n+    rustc_middle::thir::ExprId,\n+    rustc_middle::traits::CodegenObligationError,\n+    rustc_middle::traits::EvaluationResult,\n+    rustc_middle::traits::OverflowError,\n+    rustc_middle::traits::query::NoSolution,\n+    rustc_middle::traits::WellFormedLoc,\n+    rustc_middle::ty::adjustment::CoerceUnsizedInfo,\n+    rustc_middle::ty::AssocItem,\n+    rustc_middle::ty::AssocItemContainer,\n+    rustc_middle::ty::BoundVariableKind,\n+    rustc_middle::ty::DeducedParamAttrs,\n+    rustc_middle::ty::Destructor,\n+    rustc_middle::ty::fast_reject::SimplifiedType,\n+    rustc_middle::ty::ImplPolarity,\n+    rustc_middle::ty::Representability,\n+    rustc_middle::ty::ReprOptions,\n+    rustc_middle::ty::UnusedGenericParams,\n+    rustc_middle::ty::util::AlwaysRequiresDrop,\n+    rustc_middle::ty::Visibility<rustc_span::def_id::DefId>,\n+    rustc_session::config::CrateType,\n+    rustc_session::config::EntryFnType,\n+    rustc_session::config::OptLevel,\n+    rustc_session::config::SymbolManglingVersion,\n+    rustc_session::cstore::CrateDepKind,\n+    rustc_session::cstore::ExternCrate,\n+    rustc_session::cstore::LinkagePreference,\n+    rustc_session::Limits,\n+    rustc_session::lint::LintExpectationId,\n+    rustc_span::def_id::CrateNum,\n+    rustc_span::def_id::DefPathHash,\n+    rustc_span::ExpnHash,\n+    rustc_span::ExpnId,\n+    rustc_span::Span,\n+    rustc_span::Symbol,\n+    rustc_span::symbol::Ident,\n+    rustc_target::spec::PanicStrategy,\n+    rustc_type_ir::Variance,\n+    u32,\n+    usize,\n+}\n+\n+macro_rules! tcx_lifetime {\n+    ($($($fake_path:ident)::+),+ $(,)?) => {\n+        $(\n+            impl<'tcx> EraseType for $($fake_path)::+<'tcx> {\n+                type Result = [u8; size_of::<$($fake_path)::+<'static>>()];\n+            }\n+        )*\n+    }\n+}\n+\n+tcx_lifetime! {\n+    rustc_middle::hir::Owner,\n+    rustc_middle::middle::exported_symbols::ExportedSymbol,\n+    rustc_middle::mir::ConstantKind,\n+    rustc_middle::mir::DestructuredConstant,\n+    rustc_middle::mir::interpret::ConstAlloc,\n+    rustc_middle::mir::interpret::ConstValue,\n+    rustc_middle::mir::interpret::GlobalId,\n+    rustc_middle::mir::interpret::LitToConstInput,\n+    rustc_middle::traits::ChalkEnvironmentAndGoal,\n+    rustc_middle::traits::query::MethodAutoderefStepsResult,\n+    rustc_middle::traits::query::type_op::AscribeUserType,\n+    rustc_middle::traits::query::type_op::Eq,\n+    rustc_middle::traits::query::type_op::ProvePredicate,\n+    rustc_middle::traits::query::type_op::Subtype,\n+    rustc_middle::ty::AdtDef,\n+    rustc_middle::ty::AliasTy,\n+    rustc_middle::ty::Clause,\n+    rustc_middle::ty::ClosureTypeInfo,\n+    rustc_middle::ty::Const,\n+    rustc_middle::ty::DestructuredConst,\n+    rustc_middle::ty::ExistentialTraitRef,\n+    rustc_middle::ty::FnSig,\n+    rustc_middle::ty::GenericArg,\n+    rustc_middle::ty::GenericPredicates,\n+    rustc_middle::ty::inhabitedness::InhabitedPredicate,\n+    rustc_middle::ty::Instance,\n+    rustc_middle::ty::InstanceDef,\n+    rustc_middle::ty::layout::FnAbiError,\n+    rustc_middle::ty::layout::LayoutError,\n+    rustc_middle::ty::ParamEnv,\n+    rustc_middle::ty::Predicate,\n+    rustc_middle::ty::SymbolName,\n+    rustc_middle::ty::TraitRef,\n+    rustc_middle::ty::Ty,\n+    rustc_middle::ty::UnevaluatedConst,\n+    rustc_middle::ty::ValTree,\n+    rustc_middle::ty::VtblEntry,\n+}"}, {"sha": "a0fce4b47ca30b16cfe1de1fcd9fc4538fd08822", "filename": "compiler/rustc_middle/src/query/mod.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/6efdf4d1309f8047bc439a4810888c715e2df480/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6efdf4d1309f8047bc439a4810888c715e2df480/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs?ref=6efdf4d1309f8047bc439a4810888c715e2df480", "patch": "@@ -7,6 +7,7 @@\n use crate::ty::{self, print::describe_as_module, TyCtxt};\n use rustc_span::def_id::LOCAL_CRATE;\n \n+pub mod erase;\n mod keys;\n pub use keys::{AsLocalKey, Key, LocalCrate};\n \n@@ -1114,9 +1115,9 @@ rustc_queries! {\n         desc { \"converting literal to mir constant\" }\n     }\n \n-    query check_match(key: DefId) {\n-        desc { |tcx| \"match-checking `{}`\", tcx.def_path_str(key) }\n-        cache_on_disk_if { key.is_local() }\n+    query check_match(key: LocalDefId) {\n+        desc { |tcx| \"match-checking `{}`\", tcx.def_path_str(key.to_def_id()) }\n+        cache_on_disk_if { true }\n     }\n \n     /// Performs part of the privacy check and computes effective visibilities.\n@@ -1509,7 +1510,7 @@ rustc_queries! {\n         desc { \"getting traits in scope at a block\" }\n     }\n \n-    query module_reexports(def_id: LocalDefId) -> Option<&'tcx [ModChild]> {\n+    query module_reexports(def_id: LocalDefId) -> &'tcx [ModChild] {\n         desc { |tcx| \"looking up reexports of module `{}`\", tcx.def_path_str(def_id.to_def_id()) }\n     }\n "}, {"sha": "7d79a13d3fde3d5737f9a85576b9e292220ab023", "filename": "compiler/rustc_middle/src/thir.rs", "status": "modified", "additions": 54, "deletions": 2, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/6efdf4d1309f8047bc439a4810888c715e2df480/compiler%2Frustc_middle%2Fsrc%2Fthir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6efdf4d1309f8047bc439a4810888c715e2df480/compiler%2Frustc_middle%2Fsrc%2Fthir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fthir.rs?ref=6efdf4d1309f8047bc439a4810888c715e2df480", "patch": "@@ -227,6 +227,9 @@ pub enum StmtKind<'tcx> {\n \n         /// The lint level for this `let` statement.\n         lint_level: LintLevel,\n+\n+        /// Span of the `let <PAT> = <INIT>` part.\n+        span: Span,\n     },\n }\n \n@@ -594,6 +597,55 @@ impl<'tcx> Pat<'tcx> {\n             _ => None,\n         }\n     }\n+\n+    /// Call `f` on every \"binding\" in a pattern, e.g., on `a` in\n+    /// `match foo() { Some(a) => (), None => () }`\n+    pub fn each_binding(&self, mut f: impl FnMut(Symbol, BindingMode, Ty<'tcx>, Span)) {\n+        self.walk_always(|p| {\n+            if let PatKind::Binding { name, mode, ty, .. } = p.kind {\n+                f(name, mode, ty, p.span);\n+            }\n+        });\n+    }\n+\n+    /// Walk the pattern in left-to-right order.\n+    ///\n+    /// If `it(pat)` returns `false`, the children are not visited.\n+    pub fn walk(&self, mut it: impl FnMut(&Pat<'tcx>) -> bool) {\n+        self.walk_(&mut it)\n+    }\n+\n+    fn walk_(&self, it: &mut impl FnMut(&Pat<'tcx>) -> bool) {\n+        if !it(self) {\n+            return;\n+        }\n+\n+        use PatKind::*;\n+        match &self.kind {\n+            Wild | Range(..) | Binding { subpattern: None, .. } | Constant { .. } => {}\n+            AscribeUserType { subpattern, .. }\n+            | Binding { subpattern: Some(subpattern), .. }\n+            | Deref { subpattern } => subpattern.walk_(it),\n+            Leaf { subpatterns } | Variant { subpatterns, .. } => {\n+                subpatterns.iter().for_each(|field| field.pattern.walk_(it))\n+            }\n+            Or { pats } => pats.iter().for_each(|p| p.walk_(it)),\n+            Array { box ref prefix, ref slice, box ref suffix }\n+            | Slice { box ref prefix, ref slice, box ref suffix } => {\n+                prefix.iter().chain(slice.iter()).chain(suffix.iter()).for_each(|p| p.walk_(it))\n+            }\n+        }\n+    }\n+\n+    /// Walk the pattern in left-to-right order.\n+    ///\n+    /// If you always want to recurse, prefer this method over `walk`.\n+    pub fn walk_always(&self, mut it: impl FnMut(&Pat<'tcx>)) {\n+        self.walk(|p| {\n+            it(p);\n+            true\n+        })\n+    }\n }\n \n impl<'tcx> IntoDiagnosticArg for Pat<'tcx> {\n@@ -879,7 +931,7 @@ mod size_asserts {\n     static_assert_size!(ExprKind<'_>, 40);\n     static_assert_size!(Pat<'_>, 72);\n     static_assert_size!(PatKind<'_>, 56);\n-    static_assert_size!(Stmt<'_>, 48);\n-    static_assert_size!(StmtKind<'_>, 40);\n+    static_assert_size!(Stmt<'_>, 56);\n+    static_assert_size!(StmtKind<'_>, 48);\n     // tidy-alphabetical-end\n }"}, {"sha": "5614528c4cb2524babf43a18b5d95d69bcb72432", "filename": "compiler/rustc_middle/src/thir/visit.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/6efdf4d1309f8047bc439a4810888c715e2df480/compiler%2Frustc_middle%2Fsrc%2Fthir%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6efdf4d1309f8047bc439a4810888c715e2df480/compiler%2Frustc_middle%2Fsrc%2Fthir%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fthir%2Fvisit.rs?ref=6efdf4d1309f8047bc439a4810888c715e2df480", "patch": "@@ -175,6 +175,7 @@ pub fn walk_stmt<'a, 'tcx: 'a, V: Visitor<'a, 'tcx>>(visitor: &mut V, stmt: &Stm\n             ref pattern,\n             lint_level: _,\n             else_block,\n+            span: _,\n         } => {\n             if let Some(init) = initializer {\n                 visitor.visit_expr(&visitor.thir()[*init]);"}, {"sha": "6a8ae525069c0f8eaa65c8f6bb5ea8c76347f938", "filename": "compiler/rustc_middle/src/traits/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6efdf4d1309f8047bc439a4810888c715e2df480/compiler%2Frustc_middle%2Fsrc%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6efdf4d1309f8047bc439a4810888c715e2df480/compiler%2Frustc_middle%2Fsrc%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Ftraits%2Fmod.rs?ref=6efdf4d1309f8047bc439a4810888c715e2df480", "patch": "@@ -923,7 +923,7 @@ impl ObjectSafetyViolation {\n                 }\n             }\n             ObjectSafetyViolation::SupertraitNonLifetimeBinder(_) => {\n-                format!(\"where clause cannot reference non-lifetime `for<...>` variables\").into()\n+                \"where clause cannot reference non-lifetime `for<...>` variables\".into()\n             }\n             ObjectSafetyViolation::Method(name, MethodViolationCode::StaticMethod(_), _) => {\n                 format!(\"associated function `{}` has no `self` parameter\", name).into()"}, {"sha": "fef2be133e81f2c5914d5b44bdaed9248100333b", "filename": "compiler/rustc_middle/src/traits/solve.rs", "status": "modified", "additions": 16, "deletions": 6, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/6efdf4d1309f8047bc439a4810888c715e2df480/compiler%2Frustc_middle%2Fsrc%2Ftraits%2Fsolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6efdf4d1309f8047bc439a4810888c715e2df480/compiler%2Frustc_middle%2Fsrc%2Ftraits%2Fsolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Ftraits%2Fsolve.rs?ref=6efdf4d1309f8047bc439a4810888c715e2df480", "patch": "@@ -20,8 +20,8 @@ pub type EvaluationCache<'tcx> = Cache<CanonicalGoal<'tcx>, QueryResult<'tcx>>;\n /// we're currently typechecking while the `predicate` is some trait bound.\n #[derive(Debug, PartialEq, Eq, Clone, Copy, Hash, TypeFoldable, TypeVisitable)]\n pub struct Goal<'tcx, P> {\n-    pub param_env: ty::ParamEnv<'tcx>,\n     pub predicate: P,\n+    pub param_env: ty::ParamEnv<'tcx>,\n }\n \n impl<'tcx, P> Goal<'tcx, P> {\n@@ -41,10 +41,10 @@ impl<'tcx, P> Goal<'tcx, P> {\n \n #[derive(Debug, PartialEq, Eq, Clone, Copy, Hash, TypeFoldable, TypeVisitable)]\n pub struct Response<'tcx> {\n+    pub certainty: Certainty,\n     pub var_values: CanonicalVarValues<'tcx>,\n     /// Additional constraints returned by this query.\n     pub external_constraints: ExternalConstraints<'tcx>,\n-    pub certainty: Certainty,\n }\n \n #[derive(Debug, PartialEq, Eq, Clone, Copy, Hash, TypeFoldable, TypeVisitable)]\n@@ -56,9 +56,19 @@ pub enum Certainty {\n impl Certainty {\n     pub const AMBIGUOUS: Certainty = Certainty::Maybe(MaybeCause::Ambiguity);\n \n-    /// When proving multiple goals using **AND**, e.g. nested obligations for an impl,\n-    /// use this function to unify the certainty of these goals\n-    pub fn unify_and(self, other: Certainty) -> Certainty {\n+    /// Use this function to merge the certainty of multiple nested subgoals.\n+    ///\n+    /// Given an impl like `impl<T: Foo + Bar> Baz for T {}`, we have 2 nested\n+    /// subgoals whenever we use the impl as a candidate: `T: Foo` and `T: Bar`.\n+    /// If evaluating `T: Foo` results in ambiguity and `T: Bar` results in\n+    /// success, we merge these two responses. This results in ambiguity.\n+    ///\n+    /// If we unify ambiguity with overflow, we return overflow. This doesn't matter\n+    /// inside of the solver as we distinguish ambiguity from overflow. It does\n+    /// however matter for diagnostics. If `T: Foo` resulted in overflow and `T: Bar`\n+    /// in ambiguity without changing the inference state, we still want to tell the\n+    /// user that `T: Baz` results in overflow.\n+    pub fn unify_with(self, other: Certainty) -> Certainty {\n         match (self, other) {\n             (Certainty::Yes, Certainty::Yes) => Certainty::Yes,\n             (Certainty::Yes, Certainty::Maybe(_)) => other,\n@@ -105,7 +115,7 @@ impl<'tcx> std::ops::Deref for ExternalConstraints<'tcx> {\n     type Target = ExternalConstraintsData<'tcx>;\n \n     fn deref(&self) -> &Self::Target {\n-        &*self.0\n+        &self.0\n     }\n }\n "}, {"sha": "468c2c818b247cad88d1798ddd108feac3223601", "filename": "compiler/rustc_middle/src/ty/_match.rs", "status": "modified", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/6efdf4d1309f8047bc439a4810888c715e2df480/compiler%2Frustc_middle%2Fsrc%2Fty%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6efdf4d1309f8047bc439a4810888c715e2df480/compiler%2Frustc_middle%2Fsrc%2Fty%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2F_match.rs?ref=6efdf4d1309f8047bc439a4810888c715e2df480", "patch": "@@ -37,21 +37,13 @@ impl<'tcx> TypeRelation<'tcx> for Match<'tcx> {\n         self.tcx\n     }\n \n-    fn intercrate(&self) -> bool {\n-        false\n-    }\n-\n     fn param_env(&self) -> ty::ParamEnv<'tcx> {\n         self.param_env\n     }\n     fn a_is_expected(&self) -> bool {\n         true\n     } // irrelevant\n \n-    fn mark_ambiguous(&mut self) {\n-        bug!()\n-    }\n-\n     fn relate_with_variance<T: Relate<'tcx>>(\n         &mut self,\n         _: ty::Variance,"}, {"sha": "8ef4a46a733aa60d631ca00df67ac8c1f5ba5d0c", "filename": "compiler/rustc_middle/src/ty/codec.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6efdf4d1309f8047bc439a4810888c715e2df480/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcodec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6efdf4d1309f8047bc439a4810888c715e2df480/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcodec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcodec.rs?ref=6efdf4d1309f8047bc439a4810888c715e2df480", "patch": "@@ -511,8 +511,6 @@ macro_rules! implement_ty_decoder {\n                     read_isize -> isize;\n \n                     read_bool -> bool;\n-                    read_f64 -> f64;\n-                    read_f32 -> f32;\n                     read_char -> char;\n                     read_str -> &str;\n                 }"}, {"sha": "c0e557d480d3d0a52e399fa0c45dc4b8fcd81f65", "filename": "compiler/rustc_middle/src/ty/consts/int.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6efdf4d1309f8047bc439a4810888c715e2df480/compiler%2Frustc_middle%2Fsrc%2Fty%2Fconsts%2Fint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6efdf4d1309f8047bc439a4810888c715e2df480/compiler%2Frustc_middle%2Fsrc%2Fty%2Fconsts%2Fint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fconsts%2Fint.rs?ref=6efdf4d1309f8047bc439a4810888c715e2df480", "patch": "@@ -337,7 +337,7 @@ impl ScalarInt {\n     /// Fails if the size of the `ScalarInt` is not equal to `Size { raw: 16 }`\n     /// and returns the `ScalarInt`s size in that case.\n     pub fn try_to_i128(self) -> Result<i128, Size> {\n-        self.try_to_int(Size::from_bits(128)).map(|v| i128::try_from(v).unwrap())\n+        self.try_to_int(Size::from_bits(128))\n     }\n }\n "}, {"sha": "c312aaf6819aa955530b1485da845724a72955e2", "filename": "compiler/rustc_middle/src/ty/context.rs", "status": "modified", "additions": 7, "deletions": 11, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/6efdf4d1309f8047bc439a4810888c715e2df480/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6efdf4d1309f8047bc439a4810888c715e2df480/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs?ref=6efdf4d1309f8047bc439a4810888c715e2df480", "patch": "@@ -311,7 +311,7 @@ pub struct CommonLifetimes<'tcx> {\n     pub re_vars: Vec<Region<'tcx>>,\n \n     /// Pre-interned values of the form:\n-    /// `ReLateBound(DebruijnIndex(i), BoundRegion { var: v, kind: BrAnon(v, None) })`\n+    /// `ReLateBound(DebruijnIndex(i), BoundRegion { var: v, kind: BrAnon(None) })`\n     /// for small values of `i` and `v`.\n     pub re_late_bounds: Vec<Vec<Region<'tcx>>>,\n }\n@@ -386,10 +386,7 @@ impl<'tcx> CommonLifetimes<'tcx> {\n                     .map(|v| {\n                         mk(ty::ReLateBound(\n                             ty::DebruijnIndex::from(i),\n-                            ty::BoundRegion {\n-                                var: ty::BoundVar::from(v),\n-                                kind: ty::BrAnon(v, None),\n-                            },\n+                            ty::BoundRegion { var: ty::BoundVar::from(v), kind: ty::BrAnon(None) },\n                         ))\n                     })\n                     .collect()\n@@ -927,7 +924,7 @@ impl<'tcx> TyCtxt<'tcx> {\n             crate_name,\n             // Don't print the whole stable crate id. That's just\n             // annoying in debug output.\n-            stable_crate_id.to_u64() >> 8 * 6,\n+            stable_crate_id.to_u64() >> (8 * 6),\n             self.def_path(def_id).to_string_no_crate_verbose()\n         )\n     }\n@@ -2075,10 +2072,9 @@ impl<'tcx> TyCtxt<'tcx> {\n         bound_region: ty::BoundRegion,\n     ) -> Region<'tcx> {\n         // Use a pre-interned one when possible.\n-        if let ty::BoundRegion { var, kind: ty::BrAnon(v, None) } = bound_region\n-            && var.as_u32() == v\n+        if let ty::BoundRegion { var, kind: ty::BrAnon(None) } = bound_region\n             && let Some(inner) = self.lifetimes.re_late_bounds.get(debruijn.as_usize())\n-            && let Some(re) = inner.get(v as usize).copied()\n+            && let Some(re) = inner.get(var.as_usize()).copied()\n         {\n             re\n         } else {\n@@ -2383,7 +2379,7 @@ impl<'tcx> TyCtxt<'tcx> {\n     pub fn in_scope_traits(self, id: HirId) -> Option<&'tcx [TraitCandidate]> {\n         let map = self.in_scope_traits_map(id.owner)?;\n         let candidates = map.get(&id.local_id)?;\n-        Some(&*candidates)\n+        Some(candidates)\n     }\n \n     pub fn named_bound_var(self, id: HirId) -> Option<resolve_bound_vars::ResolvedArg> {\n@@ -2506,7 +2502,7 @@ pub struct DeducedParamAttrs {\n \n pub fn provide(providers: &mut ty::query::Providers) {\n     providers.module_reexports =\n-        |tcx, id| tcx.resolutions(()).reexport_map.get(&id).map(|v| &v[..]);\n+        |tcx, id| tcx.resolutions(()).reexport_map.get(&id).map_or(&[], |v| &v[..]);\n     providers.maybe_unused_trait_imports =\n         |tcx, ()| &tcx.resolutions(()).maybe_unused_trait_imports;\n     providers.names_imported_by_glob_use = |tcx, id| {"}, {"sha": "203e16bea27fe9ccbe6603f5717dee40f9401352", "filename": "compiler/rustc_middle/src/ty/fold.rs", "status": "modified", "additions": 2, "deletions": 6, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/6efdf4d1309f8047bc439a4810888c715e2df480/compiler%2Frustc_middle%2Fsrc%2Fty%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6efdf4d1309f8047bc439a4810888c715e2df480/compiler%2Frustc_middle%2Fsrc%2Fty%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Ffold.rs?ref=6efdf4d1309f8047bc439a4810888c715e2df480", "patch": "@@ -379,9 +379,7 @@ impl<'tcx> TyCtxt<'tcx> {\n                 let index = entry.index();\n                 let var = ty::BoundVar::from_usize(index);\n                 let kind = entry\n-                    .or_insert_with(|| {\n-                        ty::BoundVariableKind::Region(ty::BrAnon(index as u32, None))\n-                    })\n+                    .or_insert_with(|| ty::BoundVariableKind::Region(ty::BrAnon(None)))\n                     .expect_region();\n                 let br = ty::BoundRegion { var, kind };\n                 self.tcx.mk_re_late_bound(ty::INNERMOST, br)\n@@ -391,9 +389,7 @@ impl<'tcx> TyCtxt<'tcx> {\n                 let index = entry.index();\n                 let var = ty::BoundVar::from_usize(index);\n                 let kind = entry\n-                    .or_insert_with(|| {\n-                        ty::BoundVariableKind::Ty(ty::BoundTyKind::Anon(index as u32))\n-                    })\n+                    .or_insert_with(|| ty::BoundVariableKind::Ty(ty::BoundTyKind::Anon))\n                     .expect_ty();\n                 self.tcx.mk_bound(ty::INNERMOST, BoundTy { var, kind })\n             }"}, {"sha": "2328a1324fc3c462446f15ecf9d4b90f092d58d8", "filename": "compiler/rustc_middle/src/ty/layout.rs", "status": "modified", "additions": 97, "deletions": 1, "changes": 98, "blob_url": "https://github.com/rust-lang/rust/blob/6efdf4d1309f8047bc439a4810888c715e2df480/compiler%2Frustc_middle%2Fsrc%2Fty%2Flayout.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6efdf4d1309f8047bc439a4810888c715e2df480/compiler%2Frustc_middle%2Fsrc%2Fty%2Flayout.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Flayout.rs?ref=6efdf4d1309f8047bc439a4810888c715e2df480", "patch": "@@ -5,6 +5,7 @@ use crate::ty::{self, ReprOptions, Ty, TyCtxt, TypeVisitableExt};\n use rustc_errors::{DiagnosticBuilder, Handler, IntoDiagnostic};\n use rustc_hir as hir;\n use rustc_hir::def_id::DefId;\n+use rustc_index::vec::IndexVec;\n use rustc_session::config::OptLevel;\n use rustc_span::symbol::{sym, Symbol};\n use rustc_span::{Span, DUMMY_SP};\n@@ -280,6 +281,12 @@ pub enum SizeSkeleton<'tcx> {\n     /// Any statically computable Layout.\n     Known(Size),\n \n+    /// This is a generic const expression (i.e. N * 2), which may contain some parameters.\n+    /// It must be of type usize, and represents the size of a type in bytes.\n+    /// It is not required to be evaluatable to a concrete value, but can be used to check\n+    /// that another SizeSkeleton is of equal size.\n+    Generic(ty::Const<'tcx>),\n+\n     /// A potentially-fat pointer.\n     Pointer {\n         /// If true, this pointer is never null.\n@@ -325,6 +332,37 @@ impl<'tcx> SizeSkeleton<'tcx> {\n                     ),\n                 }\n             }\n+            ty::Array(inner, len)\n+                if len.ty() == tcx.types.usize && tcx.features().transmute_generic_consts =>\n+            {\n+                match SizeSkeleton::compute(inner, tcx, param_env)? {\n+                    // This may succeed because the multiplication of two types may overflow\n+                    // but a single size of a nested array will not.\n+                    SizeSkeleton::Known(s) => {\n+                        if let Some(c) = len.try_eval_target_usize(tcx, param_env) {\n+                            let size = s\n+                                .bytes()\n+                                .checked_mul(c)\n+                                .ok_or_else(|| LayoutError::SizeOverflow(ty))?;\n+                            return Ok(SizeSkeleton::Known(Size::from_bytes(size)));\n+                        }\n+                        let len = tcx.expand_abstract_consts(len);\n+                        let prev = ty::Const::from_target_usize(tcx, s.bytes());\n+                        let Some(gen_size) = mul_sorted_consts(tcx, param_env, len, prev) else {\n+                            return Err(LayoutError::SizeOverflow(ty));\n+                        };\n+                        Ok(SizeSkeleton::Generic(gen_size))\n+                    }\n+                    SizeSkeleton::Pointer { .. } => Err(err),\n+                    SizeSkeleton::Generic(g) => {\n+                        let len = tcx.expand_abstract_consts(len);\n+                        let Some(gen_size) = mul_sorted_consts(tcx, param_env, len, g) else {\n+                            return Err(LayoutError::SizeOverflow(ty));\n+                        };\n+                        Ok(SizeSkeleton::Generic(gen_size))\n+                    }\n+                }\n+            }\n \n             ty::Adt(def, substs) => {\n                 // Only newtypes and enums w/ nullable pointer optimization.\n@@ -354,6 +392,9 @@ impl<'tcx> SizeSkeleton<'tcx> {\n                                 }\n                                 ptr = Some(field);\n                             }\n+                            SizeSkeleton::Generic(_) => {\n+                                return Err(err);\n+                            }\n                         }\n                     }\n                     Ok(ptr)\n@@ -409,11 +450,66 @@ impl<'tcx> SizeSkeleton<'tcx> {\n             (SizeSkeleton::Pointer { tail: a, .. }, SizeSkeleton::Pointer { tail: b, .. }) => {\n                 a == b\n             }\n+            // constants are always pre-normalized into a canonical form so this\n+            // only needs to check if their pointers are identical.\n+            (SizeSkeleton::Generic(a), SizeSkeleton::Generic(b)) => a == b,\n             _ => false,\n         }\n     }\n }\n \n+/// When creating the layout for types with abstract conts in their size (i.e. [usize; 4 * N]),\n+/// to ensure that they have a canonical order and can be compared directly we combine all\n+/// constants, and sort the other terms. This allows comparison of expressions of sizes,\n+/// allowing for things like transmutating between types that depend on generic consts.\n+/// This returns `None` if multiplication of constants overflows.\n+fn mul_sorted_consts<'tcx>(\n+    tcx: TyCtxt<'tcx>,\n+    param_env: ty::ParamEnv<'tcx>,\n+    a: ty::Const<'tcx>,\n+    b: ty::Const<'tcx>,\n+) -> Option<ty::Const<'tcx>> {\n+    use crate::mir::BinOp::Mul;\n+    use ty::ConstKind::Expr;\n+    use ty::Expr::Binop;\n+\n+    let mut work = vec![a, b];\n+    let mut done = vec![];\n+    while let Some(n) = work.pop() {\n+        if let Expr(Binop(Mul, l, r)) = n.kind() {\n+            work.push(l);\n+            work.push(r)\n+        } else {\n+            done.push(n);\n+        }\n+    }\n+    let mut k = 1;\n+    let mut overflow = false;\n+    done.retain(|c| {\n+        let Some(c) = c.try_eval_target_usize(tcx, param_env) else {\n+            return true;\n+        };\n+        let Some(next) = c.checked_mul(k) else {\n+            overflow = true;\n+            return false;\n+        };\n+        k = next;\n+        false\n+    });\n+    if overflow {\n+        return None;\n+    }\n+    if k != 1 {\n+        done.push(ty::Const::from_target_usize(tcx, k));\n+    } else if k == 0 {\n+        return Some(ty::Const::from_target_usize(tcx, 0));\n+    }\n+    done.sort_unstable();\n+\n+    // create a single tree from the buffer\n+    done.into_iter().reduce(|acc, n| tcx.mk_const(Expr(Binop(Mul, n, acc)), n.ty()))\n+}\n+\n pub trait HasTyCtxt<'tcx>: HasDataLayout {\n     fn tcx(&self) -> TyCtxt<'tcx>;\n }\n@@ -635,7 +731,7 @@ where\n                     variants: Variants::Single { index: variant_index },\n                     fields: match NonZeroUsize::new(fields) {\n                         Some(fields) => FieldsShape::Union(fields),\n-                        None => FieldsShape::Arbitrary { offsets: vec![], memory_index: vec![] },\n+                        None => FieldsShape::Arbitrary { offsets: IndexVec::new(), memory_index: IndexVec::new() },\n                     },\n                     abi: Abi::Uninhabited,\n                     largest_niche: None,"}, {"sha": "c856bb25e1474c5d96713baa0655092a8ec12ae0", "filename": "compiler/rustc_middle/src/ty/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/6efdf4d1309f8047bc439a4810888c715e2df480/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6efdf4d1309f8047bc439a4810888c715e2df480/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs?ref=6efdf4d1309f8047bc439a4810888c715e2df480", "patch": "@@ -1454,12 +1454,12 @@ impl<'tcx> OpaqueHiddenType<'tcx> {\n #[derive(HashStable, TyEncodable, TyDecodable)]\n pub struct Placeholder<T> {\n     pub universe: UniverseIndex,\n-    pub name: T,\n+    pub bound: T,\n }\n \n-pub type PlaceholderRegion = Placeholder<BoundRegionKind>;\n+pub type PlaceholderRegion = Placeholder<BoundRegion>;\n \n-pub type PlaceholderType = Placeholder<BoundTyKind>;\n+pub type PlaceholderType = Placeholder<BoundTy>;\n \n #[derive(Copy, Clone, Debug, PartialEq, Eq, Hash, HashStable)]\n #[derive(TyEncodable, TyDecodable, PartialOrd, Ord)]"}, {"sha": "7c59879a187feb960570509010630f3387ea61da", "filename": "compiler/rustc_middle/src/ty/normalize_erasing_regions.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/6efdf4d1309f8047bc439a4810888c715e2df480/compiler%2Frustc_middle%2Fsrc%2Fty%2Fnormalize_erasing_regions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6efdf4d1309f8047bc439a4810888c715e2df480/compiler%2Frustc_middle%2Fsrc%2Fty%2Fnormalize_erasing_regions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fnormalize_erasing_regions.rs?ref=6efdf4d1309f8047bc439a4810888c715e2df480", "patch": "@@ -193,9 +193,9 @@ impl<'tcx> NormalizeAfterErasingRegionsFolder<'tcx> {\n         let arg = self.param_env.and(arg);\n \n         self.tcx.try_normalize_generic_arg_after_erasing_regions(arg).unwrap_or_else(|_| bug!(\n-                \"Failed to normalize {:?}, maybe try to call `try_normalize_erasing_regions` instead\",\n-                arg.value\n-            ))\n+            \"Failed to normalize {:?}, maybe try to call `try_normalize_erasing_regions` instead\",\n+            arg.value\n+        ))\n     }\n }\n "}, {"sha": "bc0ccc1ebc3a9e32c954a7430586be8ed38c6f81", "filename": "compiler/rustc_middle/src/ty/print/pretty.rs", "status": "modified", "additions": 13, "deletions": 8, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/6efdf4d1309f8047bc439a4810888c715e2df480/compiler%2Frustc_middle%2Fsrc%2Fty%2Fprint%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6efdf4d1309f8047bc439a4810888c715e2df480/compiler%2Frustc_middle%2Fsrc%2Fty%2Fprint%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fprint%2Fpretty.rs?ref=6efdf4d1309f8047bc439a4810888c715e2df480", "patch": "@@ -701,9 +701,7 @@ pub trait PrettyPrinter<'tcx>:\n             ty::Error(_) => p!(\"[type error]\"),\n             ty::Param(ref param_ty) => p!(print(param_ty)),\n             ty::Bound(debruijn, bound_ty) => match bound_ty.kind {\n-                ty::BoundTyKind::Anon(bv) => {\n-                    self.pretty_print_bound_var(debruijn, ty::BoundVar::from_u32(bv))?\n-                }\n+                ty::BoundTyKind::Anon => self.pretty_print_bound_var(debruijn, bound_ty.var)?,\n                 ty::BoundTyKind::Param(_, s) => match self.should_print_verbose() {\n                     true if debruijn == ty::INNERMOST => p!(write(\"^{}\", s)),\n                     true => p!(write(\"^{}_{}\", debruijn.index(), s)),\n@@ -739,8 +737,8 @@ pub trait PrettyPrinter<'tcx>:\n                     p!(print(data))\n                 }\n             }\n-            ty::Placeholder(placeholder) => match placeholder.name {\n-                ty::BoundTyKind::Anon(_) => p!(write(\"Placeholder({:?})\", placeholder)),\n+            ty::Placeholder(placeholder) => match placeholder.bound.kind {\n+                ty::BoundTyKind::Anon => p!(write(\"Placeholder({:?})\", placeholder)),\n                 ty::BoundTyKind::Param(_, name) => p!(write(\"{}\", name)),\n             },\n             ty::Alias(ty::Opaque, ty::AliasTy { def_id, substs, .. }) => {\n@@ -2104,7 +2102,9 @@ impl<'tcx> PrettyPrinter<'tcx> for FmtPrinter<'_, 'tcx> {\n \n             ty::ReLateBound(_, ty::BoundRegion { kind: br, .. })\n             | ty::ReFree(ty::FreeRegion { bound_region: br, .. })\n-            | ty::RePlaceholder(ty::Placeholder { name: br, .. }) => {\n+            | ty::RePlaceholder(ty::Placeholder {\n+                bound: ty::BoundRegion { kind: br, .. }, ..\n+            }) => {\n                 if br.is_named() {\n                     return true;\n                 }\n@@ -2181,7 +2181,9 @@ impl<'tcx> FmtPrinter<'_, 'tcx> {\n             }\n             ty::ReLateBound(_, ty::BoundRegion { kind: br, .. })\n             | ty::ReFree(ty::FreeRegion { bound_region: br, .. })\n-            | ty::RePlaceholder(ty::Placeholder { name: br, .. }) => {\n+            | ty::RePlaceholder(ty::Placeholder {\n+                bound: ty::BoundRegion { kind: br, .. }, ..\n+            }) => {\n                 if let ty::BrNamed(_, name) = br && br.is_named() {\n                     p!(write(\"{}\", name));\n                     return Ok(self);\n@@ -2259,7 +2261,10 @@ impl<'a, 'tcx> ty::TypeFolder<TyCtxt<'tcx>> for RegionFolder<'a, 'tcx> {\n             ty::ReLateBound(db, br) if db >= self.current_index => {\n                 *self.region_map.entry(br).or_insert_with(|| name(Some(db), self.current_index, br))\n             }\n-            ty::RePlaceholder(ty::PlaceholderRegion { name: kind, .. }) => {\n+            ty::RePlaceholder(ty::PlaceholderRegion {\n+                bound: ty::BoundRegion { kind, .. },\n+                ..\n+            }) => {\n                 // If this is an anonymous placeholder, don't rename. Otherwise, in some\n                 // async fns, we get a `for<'r> Send` bound\n                 match kind {"}, {"sha": "fa9fea723448660c44ba518a215744a29f87af20", "filename": "compiler/rustc_middle/src/ty/query.rs", "status": "modified", "additions": 23, "deletions": 12, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/6efdf4d1309f8047bc439a4810888c715e2df480/compiler%2Frustc_middle%2Fsrc%2Fty%2Fquery.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6efdf4d1309f8047bc439a4810888c715e2df480/compiler%2Frustc_middle%2Fsrc%2Fty%2Fquery.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fquery.rs?ref=6efdf4d1309f8047bc439a4810888c715e2df480", "patch": "@@ -17,6 +17,7 @@ use crate::mir::interpret::{\n };\n use crate::mir::interpret::{LitToConstError, LitToConstInput};\n use crate::mir::mono::CodegenUnit;\n+use crate::query::erase::{erase, restore, Erase};\n use crate::query::{AsLocalKey, Key};\n use crate::thir;\n use crate::traits::query::{\n@@ -57,6 +58,8 @@ use rustc_hir::hir_id::OwnerId;\n use rustc_hir::lang_items::{LangItem, LanguageItems};\n use rustc_hir::{Crate, ItemLocalId, TraitCandidate};\n use rustc_index::vec::IndexVec;\n+pub(crate) use rustc_query_system::query::QueryJobId;\n+use rustc_query_system::query::*;\n use rustc_session::config::{EntryFnType, OptLevel, OutputFilenames, SymbolManglingVersion};\n use rustc_session::cstore::{CrateDepKind, CrateSource};\n use rustc_session::cstore::{ExternCrate, ForeignModule, LinkagePreference, NativeLib};\n@@ -66,18 +69,19 @@ use rustc_span::symbol::Symbol;\n use rustc_span::{Span, DUMMY_SP};\n use rustc_target::abi;\n use rustc_target::spec::PanicStrategy;\n+\n+use std::marker::PhantomData;\n use std::mem;\n use std::ops::Deref;\n use std::path::PathBuf;\n use std::sync::Arc;\n \n-pub(crate) use rustc_query_system::query::QueryJobId;\n-use rustc_query_system::query::*;\n-\n #[derive(Default)]\n pub struct QuerySystem<'tcx> {\n     pub arenas: QueryArenas<'tcx>,\n     pub caches: QueryCaches<'tcx>,\n+    // Since we erase query value types we tell the typesystem about them with `PhantomData`.\n+    _phantom_values: QueryPhantomValues<'tcx>,\n }\n \n #[derive(Copy, Clone)]\n@@ -263,8 +267,8 @@ macro_rules! define_callbacks {\n                 pub fn $name<'tcx>(\n                     _tcx: TyCtxt<'tcx>,\n                     value: query_provided::$name<'tcx>,\n-                ) -> query_values::$name<'tcx> {\n-                    query_if_arena!([$($modifiers)*]\n+                ) -> Erase<query_values::$name<'tcx>> {\n+                    erase(query_if_arena!([$($modifiers)*]\n                         {\n                             if mem::needs_drop::<query_provided::$name<'tcx>>() {\n                                 &*_tcx.query_system.arenas.$name.alloc(value)\n@@ -273,7 +277,7 @@ macro_rules! define_callbacks {\n                             }\n                         }\n                         (value)\n-                    )\n+                    ))\n                 }\n             )*\n         }\n@@ -282,7 +286,7 @@ macro_rules! define_callbacks {\n             use super::*;\n \n             $(\n-                pub type $name<'tcx> = <<$($K)* as Key>::CacheSelector as CacheSelector<'tcx, $V>>::Cache;\n+                pub type $name<'tcx> = <<$($K)* as Key>::CacheSelector as CacheSelector<'tcx, Erase<$V>>>::Cache;\n             )*\n         }\n \n@@ -334,6 +338,11 @@ macro_rules! define_callbacks {\n             }\n         }\n \n+        #[derive(Default)]\n+        pub struct QueryPhantomValues<'tcx> {\n+            $($(#[$attr])* pub $name: PhantomData<query_values::$name<'tcx>>,)*\n+        }\n+\n         #[derive(Default)]\n         pub struct QueryCaches<'tcx> {\n             $($(#[$attr])* pub $name: query_storage::$name<'tcx>,)*\n@@ -395,10 +404,10 @@ macro_rules! define_callbacks {\n                 let key = key.into_query_param();\n                 opt_remap_env_constness!([$($modifiers)*][key]);\n \n-                match try_get_cached(self.tcx, &self.tcx.query_system.caches.$name, &key) {\n+                restore::<$V>(match try_get_cached(self.tcx, &self.tcx.query_system.caches.$name, &key) {\n                     Some(value) => value,\n                     None => self.tcx.queries.$name(self.tcx, self.span, key, QueryMode::Get).unwrap(),\n-                }\n+                })\n             })*\n         }\n \n@@ -459,7 +468,7 @@ macro_rules! define_callbacks {\n                 span: Span,\n                 key: query_keys::$name<'tcx>,\n                 mode: QueryMode,\n-            ) -> Option<$V>;)*\n+            ) -> Option<Erase<$V>>;)*\n         }\n     };\n }\n@@ -486,11 +495,13 @@ macro_rules! define_feedable {\n                 opt_remap_env_constness!([$($modifiers)*][key]);\n \n                 let tcx = self.tcx;\n-                let value = query_provided_to_value::$name(tcx, value);\n+                let erased = query_provided_to_value::$name(tcx, value);\n+                let value = restore::<$V>(erased);\n                 let cache = &tcx.query_system.caches.$name;\n \n                 match try_get_cached(tcx, cache, &key) {\n                     Some(old) => {\n+                        let old = restore::<$V>(old);\n                         bug!(\n                             \"Trying to feed an already recorded value for query {} key={key:?}:\\nold value: {old:?}\\nnew value: {value:?}\",\n                             stringify!($name),\n@@ -505,7 +516,7 @@ macro_rules! define_feedable {\n                             &value,\n                             hash_result!([$($modifiers)*]),\n                         );\n-                        cache.complete(key, value, dep_node_index);\n+                        cache.complete(key, erased, dep_node_index);\n                         value\n                     }\n                 }"}, {"sha": "46c931d61dc993a04dbcb89da658ac8c22421126", "filename": "compiler/rustc_middle/src/ty/relate.rs", "status": "modified", "additions": 10, "deletions": 22, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/6efdf4d1309f8047bc439a4810888c715e2df480/compiler%2Frustc_middle%2Fsrc%2Fty%2Frelate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6efdf4d1309f8047bc439a4810888c715e2df480/compiler%2Frustc_middle%2Fsrc%2Fty%2Frelate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Frelate.rs?ref=6efdf4d1309f8047bc439a4810888c715e2df480", "patch": "@@ -22,8 +22,6 @@ pub enum Cause {\n pub trait TypeRelation<'tcx>: Sized {\n     fn tcx(&self) -> TyCtxt<'tcx>;\n \n-    fn intercrate(&self) -> bool;\n-\n     fn param_env(&self) -> ty::ParamEnv<'tcx>;\n \n     /// Returns a static string we can use for printouts.\n@@ -33,9 +31,6 @@ pub trait TypeRelation<'tcx>: Sized {\n     /// relation. Just affects error messages.\n     fn a_is_expected(&self) -> bool;\n \n-    /// Used during coherence. If called, must emit an always-ambiguous obligation.\n-    fn mark_ambiguous(&mut self);\n-\n     fn with_cause<F, R>(&mut self, _cause: Cause, f: F) -> R\n     where\n         F: FnOnce(&mut Self) -> R,\n@@ -559,23 +554,16 @@ pub fn super_relate_tys<'tcx, R: TypeRelation<'tcx>>(\n             &ty::Alias(ty::Opaque, ty::AliasTy { def_id: a_def_id, substs: a_substs, .. }),\n             &ty::Alias(ty::Opaque, ty::AliasTy { def_id: b_def_id, substs: b_substs, .. }),\n         ) if a_def_id == b_def_id => {\n-            if relation.intercrate() {\n-                // During coherence, opaque types should be treated as equal to each other, even if their generic params\n-                // differ, as they could resolve to the same hidden type, even for different generic params.\n-                relation.mark_ambiguous();\n-                Ok(a)\n-            } else {\n-                let opt_variances = tcx.variances_of(a_def_id);\n-                let substs = relate_substs_with_variances(\n-                    relation,\n-                    a_def_id,\n-                    opt_variances,\n-                    a_substs,\n-                    b_substs,\n-                    false, // do not fetch `type_of(a_def_id)`, as it will cause a cycle\n-                )?;\n-                Ok(tcx.mk_opaque(a_def_id, substs))\n-            }\n+            let opt_variances = tcx.variances_of(a_def_id);\n+            let substs = relate_substs_with_variances(\n+                relation,\n+                a_def_id,\n+                opt_variances,\n+                a_substs,\n+                b_substs,\n+                false, // do not fetch `type_of(a_def_id)`, as it will cause a cycle\n+            )?;\n+            Ok(tcx.mk_opaque(a_def_id, substs))\n         }\n \n         _ => Err(TypeError::Sorts(expected_found(relation, a, b))),"}, {"sha": "5c604bb6db274297ee6fb3ebe37fabed88616662", "filename": "compiler/rustc_middle/src/ty/structural_impls.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/6efdf4d1309f8047bc439a4810888c715e2df480/compiler%2Frustc_middle%2Fsrc%2Fty%2Fstructural_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6efdf4d1309f8047bc439a4810888c715e2df480/compiler%2Frustc_middle%2Fsrc%2Fty%2Fstructural_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fstructural_impls.rs?ref=6efdf4d1309f8047bc439a4810888c715e2df480", "patch": "@@ -68,7 +68,7 @@ impl<'tcx> fmt::Debug for ty::adjustment::Adjustment<'tcx> {\n impl fmt::Debug for ty::BoundRegionKind {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         match *self {\n-            ty::BrAnon(n, span) => write!(f, \"BrAnon({n:?}, {span:?})\"),\n+            ty::BrAnon(span) => write!(f, \"BrAnon({span:?})\"),\n             ty::BrNamed(did, name) => {\n                 if did.is_crate_root() {\n                     write!(f, \"BrNamed({})\", name)\n@@ -254,8 +254,8 @@ TrivialTypeTraversalAndLiftImpls! {\n     crate::ty::AssocKind,\n     crate::ty::AliasKind,\n     crate::ty::AliasRelationDirection,\n-    crate::ty::Placeholder<crate::ty::BoundRegionKind>,\n-    crate::ty::Placeholder<crate::ty::BoundTyKind>,\n+    crate::ty::Placeholder<crate::ty::BoundRegion>,\n+    crate::ty::Placeholder<crate::ty::BoundTy>,\n     crate::ty::ClosureKind,\n     crate::ty::FreeRegion,\n     crate::ty::InferTy,"}, {"sha": "5bbd396d6f3b052bf80233be4bc09ef2bdb2e19a", "filename": "compiler/rustc_middle/src/ty/sty.rs", "status": "modified", "additions": 17, "deletions": 28, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/6efdf4d1309f8047bc439a4810888c715e2df480/compiler%2Frustc_middle%2Fsrc%2Fty%2Fsty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6efdf4d1309f8047bc439a4810888c715e2df480/compiler%2Frustc_middle%2Fsrc%2Fty%2Fsty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fsty.rs?ref=6efdf4d1309f8047bc439a4810888c715e2df480", "patch": "@@ -60,7 +60,7 @@ pub struct FreeRegion {\n #[derive(HashStable)]\n pub enum BoundRegionKind {\n     /// An anonymous region parameter for a given fn (&T)\n-    BrAnon(u32, Option<Span>),\n+    BrAnon(Option<Span>),\n \n     /// Named region parameters for functions (a in &'a T)\n     ///\n@@ -107,15 +107,6 @@ impl BoundRegionKind {\n             _ => None,\n         }\n     }\n-\n-    pub fn expect_anon(&self) -> u32 {\n-        match *self {\n-            BoundRegionKind::BrNamed(_, _) | BoundRegionKind::BrEnv => {\n-                bug!(\"expected anon region: {self:?}\")\n-            }\n-            BoundRegionKind::BrAnon(idx, _) => idx,\n-        }\n-    }\n }\n \n pub trait Article {\n@@ -136,10 +127,6 @@ impl<'tcx> Article for TyKind<'tcx> {\n     }\n }\n \n-// `TyKind` is used a lot. Make sure it doesn't unintentionally get bigger.\n-#[cfg(all(target_arch = \"x86_64\", target_pointer_width = \"64\"))]\n-static_assert_size!(TyKind<'_>, 32);\n-\n /// A closure can be modeled as a struct that looks like:\n /// ```ignore (illustrative)\n /// struct Closure<'l0...'li, T0...Tj, CK, CS, U>(...U);\n@@ -1533,22 +1520,13 @@ pub struct BoundTy {\n #[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Debug, TyEncodable, TyDecodable)]\n #[derive(HashStable)]\n pub enum BoundTyKind {\n-    Anon(u32),\n+    Anon,\n     Param(DefId, Symbol),\n }\n \n-impl BoundTyKind {\n-    pub fn expect_anon(self) -> u32 {\n-        match self {\n-            BoundTyKind::Anon(i) => i,\n-            _ => bug!(),\n-        }\n-    }\n-}\n-\n impl From<BoundVar> for BoundTy {\n     fn from(var: BoundVar) -> Self {\n-        BoundTy { var, kind: BoundTyKind::Anon(var.as_u32()) }\n+        BoundTy { var, kind: BoundTyKind::Anon }\n     }\n }\n \n@@ -1632,7 +1610,7 @@ impl<'tcx> Region<'tcx> {\n                 ty::ReLateBound(_, br) => br.kind.get_name(),\n                 ty::ReFree(fr) => fr.bound_region.get_name(),\n                 ty::ReStatic => Some(kw::StaticLifetime),\n-                ty::RePlaceholder(placeholder) => placeholder.name.get_name(),\n+                ty::RePlaceholder(placeholder) => placeholder.bound.kind.get_name(),\n                 _ => None,\n             };\n \n@@ -1650,7 +1628,7 @@ impl<'tcx> Region<'tcx> {\n             ty::ReFree(fr) => fr.bound_region.is_named(),\n             ty::ReStatic => true,\n             ty::ReVar(..) => false,\n-            ty::RePlaceholder(placeholder) => placeholder.name.is_named(),\n+            ty::RePlaceholder(placeholder) => placeholder.bound.kind.is_named(),\n             ty::ReErased => false,\n             ty::ReError(_) => false,\n         }\n@@ -1913,7 +1891,7 @@ impl<'tcx> Ty<'tcx> {\n                         // The way we evaluate the `N` in `[T; N]` here only works since we use\n                         // `simd_size_and_type` post-monomorphization. It will probably start to ICE\n                         // if we use it in generic code. See the `simd-array-trait` ui test.\n-                        (f0_len.eval_target_usize(tcx, ParamEnv::empty()) as u64, *f0_elem_ty)\n+                        (f0_len.eval_target_usize(tcx, ParamEnv::empty()), *f0_elem_ty)\n                     }\n                     // Otherwise, the fields of this Adt are the SIMD components (and we assume they\n                     // all have the same type).\n@@ -2514,3 +2492,14 @@ impl<'tcx> VarianceDiagInfo<'tcx> {\n         }\n     }\n }\n+\n+// Some types are used a lot. Make sure they don't unintentionally get bigger.\n+#[cfg(all(target_arch = \"x86_64\", target_pointer_width = \"64\"))]\n+mod size_asserts {\n+    use super::*;\n+    use rustc_data_structures::static_assert_size;\n+    // tidy-alphabetical-start\n+    static_assert_size!(RegionKind<'_>, 28);\n+    static_assert_size!(TyKind<'_>, 32);\n+    // tidy-alphabetical-end\n+}"}, {"sha": "f346cd48347022b49b9f5ecc0986fef9bace6f65", "filename": "compiler/rustc_mir_build/messages.ftl", "status": "modified", "additions": 2, "deletions": 14, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/6efdf4d1309f8047bc439a4810888c715e2df480/compiler%2Frustc_mir_build%2Fmessages.ftl", "raw_url": "https://github.com/rust-lang/rust/raw/6efdf4d1309f8047bc439a4810888c715e2df480/compiler%2Frustc_mir_build%2Fmessages.ftl", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fmessages.ftl?ref=6efdf4d1309f8047bc439a4810888c715e2df480", "patch": "@@ -239,19 +239,9 @@ mir_build_trailing_irrefutable_let_patterns = trailing irrefutable {$count ->\n     } into the body\n \n mir_build_bindings_with_variant_name =\n-    pattern binding `{$ident}` is named the same as one of the variants of the type `{$ty_path}`\n+    pattern binding `{$name}` is named the same as one of the variants of the type `{$ty_path}`\n     .suggestion = to match on the variant, qualify the path\n \n-mir_build_irrefutable_let_patterns_generic_let = irrefutable `let` {$count ->\n-        [one] pattern\n-        *[other] patterns\n-    }\n-    .note = {$count ->\n-        [one] this pattern\n-        *[other] these patterns\n-    } will always match, so the `let` is useless\n-    .help = consider removing `let`\n-\n mir_build_irrefutable_let_patterns_if_let = irrefutable `if let` {$count ->\n         [one] pattern\n         *[other] patterns\n@@ -357,15 +347,13 @@ mir_build_inform_irrefutable = `let` bindings require an \"irrefutable pattern\",\n \n mir_build_more_information = for more information, visit https://doc.rust-lang.org/book/ch18-02-refutability.html\n \n-mir_build_res_defined_here = {$res} defined here\n-\n mir_build_adt_defined_here = `{$ty}` defined here\n \n mir_build_variant_defined_here = not covered\n \n mir_build_interpreted_as_const = introduce a variable instead\n \n-mir_build_confused = missing patterns are not covered because `{$variable}` is interpreted as {$article} {$res} pattern, not a new variable\n+mir_build_confused = missing patterns are not covered because `{$variable}` is interpreted as a constant pattern, not a new variable\n \n mir_build_suggest_if_let = you might want to use `if let` to ignore the {$count ->\n         [one] variant that isn't"}, {"sha": "609ab19289c9a494c691ad3105c472aa768ea83a", "filename": "compiler/rustc_mir_build/src/build/block.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6efdf4d1309f8047bc439a4810888c715e2df480/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6efdf4d1309f8047bc439a4810888c715e2df480/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fblock.rs?ref=6efdf4d1309f8047bc439a4810888c715e2df480", "patch": "@@ -115,6 +115,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                     initializer: Some(initializer),\n                     lint_level,\n                     else_block: Some(else_block),\n+                    span: _,\n                 } => {\n                     // When lowering the statement `let <pat> = <expr> else { <else> };`,\n                     // the `<else>` block is nested in the parent scope enclosing this statement.\n@@ -278,6 +279,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                     initializer,\n                     lint_level,\n                     else_block: None,\n+                    span: _,\n                 } => {\n                     let ignores_expr_result = matches!(pattern.kind, PatKind::Wild);\n                     this.block_context.push(BlockFrame::Statement { ignores_expr_result });"}, {"sha": "54028dfe87b73328d25740d306305af41563b687", "filename": "compiler/rustc_mir_build/src/build/custom/parse/instruction.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6efdf4d1309f8047bc439a4810888c715e2df480/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fcustom%2Fparse%2Finstruction.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6efdf4d1309f8047bc439a4810888c715e2df480/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fcustom%2Fparse%2Finstruction.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fcustom%2Fparse%2Finstruction.rs?ref=6efdf4d1309f8047bc439a4810888c715e2df480", "patch": "@@ -56,7 +56,7 @@ impl<'tcx, 'body> ParseCtxt<'tcx, 'body> {\n                 Ok(TerminatorKind::Drop {\n                     place: self.parse_place(args[0])?,\n                     target: self.parse_block(args[1])?,\n-                    unwind: None,\n+                    unwind: UnwindAction::Continue,\n                 })\n             },\n             @call(\"mir_call\", args) => {\n@@ -126,7 +126,7 @@ impl<'tcx, 'body> ParseCtxt<'tcx, 'body> {\n                     args,\n                     destination,\n                     target: Some(target),\n-                    cleanup: None,\n+                    unwind: UnwindAction::Continue,\n                     from_hir_call: *from_hir_call,\n                     fn_span: *fn_span,\n                 })"}, {"sha": "8631749a524be379c24650f9740f763b3d399c25", "filename": "compiler/rustc_mir_build/src/build/expr/as_rvalue.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/6efdf4d1309f8047bc439a4810888c715e2df480/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fas_rvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6efdf4d1309f8047bc439a4810888c715e2df480/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fas_rvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fas_rvalue.rs?ref=6efdf4d1309f8047bc439a4810888c715e2df480", "patch": "@@ -171,7 +171,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                         args: vec![Operand::Move(size), Operand::Move(align)],\n                         destination: storage,\n                         target: Some(success),\n-                        cleanup: None,\n+                        unwind: UnwindAction::Continue,\n                         from_hir_call: false,\n                         fn_span: expr_span,\n                     },\n@@ -702,7 +702,11 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                 this.cfg.terminate(\n                     block,\n                     outer_source_info,\n-                    TerminatorKind::Drop { place: to_drop, target: success, unwind: None },\n+                    TerminatorKind::Drop {\n+                        place: to_drop,\n+                        target: success,\n+                        unwind: UnwindAction::Continue,\n+                    },\n                 );\n                 this.diverge_from(block);\n                 block = success;"}, {"sha": "05a723a6b6750b73095602589cd168aa1406e92c", "filename": "compiler/rustc_mir_build/src/build/expr/into.rs", "status": "modified", "additions": 10, "deletions": 3, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/6efdf4d1309f8047bc439a4810888c715e2df480/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Finto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6efdf4d1309f8047bc439a4810888c715e2df480/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Finto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Finto.rs?ref=6efdf4d1309f8047bc439a4810888c715e2df480", "patch": "@@ -228,7 +228,10 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                     this.cfg.terminate(\n                         loop_block,\n                         source_info,\n-                        TerminatorKind::FalseUnwind { real_target: body_block, unwind: None },\n+                        TerminatorKind::FalseUnwind {\n+                            real_target: body_block,\n+                            unwind: UnwindAction::Continue,\n+                        },\n                     );\n                     this.diverge_from(loop_block);\n \n@@ -264,7 +267,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                     TerminatorKind::Call {\n                         func: fun,\n                         args,\n-                        cleanup: None,\n+                        unwind: UnwindAction::Continue,\n                         destination,\n                         // The presence or absence of a return edge affects control-flow sensitive\n                         // MIR checks and ultimately whether code is accepted or not. We can only\n@@ -466,7 +469,11 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                         } else {\n                             Some(destination_block)\n                         },\n-                        cleanup: None,\n+                        unwind: if options.contains(InlineAsmOptions::MAY_UNWIND) {\n+                            UnwindAction::Continue\n+                        } else {\n+                            UnwindAction::Unreachable\n+                        },\n                     },\n                 );\n                 if options.contains(InlineAsmOptions::MAY_UNWIND) {"}, {"sha": "8a03ea7e2cc7fdc78cf1b9727bbe847233eabf9e", "filename": "compiler/rustc_mir_build/src/build/matches/test.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6efdf4d1309f8047bc439a4810888c715e2df480/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmatches%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6efdf4d1309f8047bc439a4810888c715e2df480/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmatches%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmatches%2Ftest.rs?ref=6efdf4d1309f8047bc439a4810888c715e2df480", "patch": "@@ -263,7 +263,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                             args: vec![Operand::Move(ref_string)],\n                             destination: ref_str,\n                             target: Some(eq_block),\n-                            cleanup: None,\n+                            unwind: UnwindAction::Continue,\n                             from_hir_call: false,\n                             fn_span: source_info.span\n                         }\n@@ -466,7 +466,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                 args: vec![val, expect],\n                 destination: eq_result,\n                 target: Some(eq_block),\n-                cleanup: None,\n+                unwind: UnwindAction::Continue,\n                 from_hir_call: false,\n                 fn_span: source_info.span,\n             },"}, {"sha": "415f5b1b1e15dc1f9aabaa49778472e31de48056", "filename": "compiler/rustc_mir_build/src/build/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/6efdf4d1309f8047bc439a4810888c715e2df480/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6efdf4d1309f8047bc439a4810888c715e2df480/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmod.rs?ref=6efdf4d1309f8047bc439a4810888c715e2df480", "patch": "@@ -58,6 +58,7 @@ fn mir_build(tcx: TyCtxt<'_>, def: ty::WithOptConstParam<LocalDefId>) -> Body<'_\n         ty::WithOptConstParam { did, const_param_did: None } => {\n             tcx.ensure_with_value().thir_check_unsafety(did);\n             tcx.ensure_with_value().thir_abstract_const(did);\n+            tcx.ensure_with_value().check_match(did);\n         }\n     }\n "}, {"sha": "f32d2db4e71201758fe4a1f1b5fb40617ceec2e7", "filename": "compiler/rustc_mir_build/src/build/scope.rs", "status": "modified", "additions": 25, "deletions": 11, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/6efdf4d1309f8047bc439a4810888c715e2df480/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fscope.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6efdf4d1309f8047bc439a4810888c715e2df480/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fscope.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fscope.rs?ref=6efdf4d1309f8047bc439a4810888c715e2df480", "patch": "@@ -369,7 +369,7 @@ impl DropTree {\n                     let terminator = TerminatorKind::Drop {\n                         target: blocks[drop_data.1].unwrap(),\n                         // The caller will handle this if needed.\n-                        unwind: None,\n+                        unwind: UnwindAction::Terminate,\n                         place: drop_data.0.local.into(),\n                     };\n                     cfg.terminate(block, drop_data.0.source_info, terminator);\n@@ -1141,7 +1141,11 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         self.cfg.terminate(\n             block,\n             source_info,\n-            TerminatorKind::Drop { place, target: assign, unwind: Some(assign_unwind) },\n+            TerminatorKind::Drop {\n+                place,\n+                target: assign,\n+                unwind: UnwindAction::Cleanup(assign_unwind),\n+            },\n         );\n         self.diverge_from(block);\n \n@@ -1165,7 +1169,13 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         self.cfg.terminate(\n             block,\n             source_info,\n-            TerminatorKind::Assert { cond, expected, msg, target: success_block, cleanup: None },\n+            TerminatorKind::Assert {\n+                cond,\n+                expected,\n+                msg,\n+                target: success_block,\n+                unwind: UnwindAction::Continue,\n+            },\n         );\n         self.diverge_from(block);\n \n@@ -1244,7 +1254,11 @@ fn build_scope_drops<'tcx>(\n                 cfg.terminate(\n                     block,\n                     source_info,\n-                    TerminatorKind::Drop { place: local.into(), target: next, unwind: None },\n+                    TerminatorKind::Drop {\n+                        place: local.into(),\n+                        target: next,\n+                        unwind: UnwindAction::Continue,\n+                    },\n                 );\n                 block = next;\n             }\n@@ -1424,23 +1438,23 @@ impl<'tcx> DropTreeBuilder<'tcx> for Unwind {\n         let term = &mut cfg.block_data_mut(from).terminator_mut();\n         match &mut term.kind {\n             TerminatorKind::Drop { unwind, .. } => {\n-                if let Some(unwind) = *unwind {\n+                if let UnwindAction::Cleanup(unwind) = *unwind {\n                     let source_info = term.source_info;\n                     cfg.terminate(unwind, source_info, TerminatorKind::Goto { target: to });\n                 } else {\n-                    *unwind = Some(to);\n+                    *unwind = UnwindAction::Cleanup(to);\n                 }\n             }\n             TerminatorKind::FalseUnwind { unwind, .. }\n-            | TerminatorKind::Call { cleanup: unwind, .. }\n-            | TerminatorKind::Assert { cleanup: unwind, .. }\n-            | TerminatorKind::InlineAsm { cleanup: unwind, .. } => {\n-                *unwind = Some(to);\n+            | TerminatorKind::Call { unwind, .. }\n+            | TerminatorKind::Assert { unwind, .. }\n+            | TerminatorKind::InlineAsm { unwind, .. } => {\n+                *unwind = UnwindAction::Cleanup(to);\n             }\n             TerminatorKind::Goto { .. }\n             | TerminatorKind::SwitchInt { .. }\n             | TerminatorKind::Resume\n-            | TerminatorKind::Abort\n+            | TerminatorKind::Terminate\n             | TerminatorKind::Return\n             | TerminatorKind::Unreachable\n             | TerminatorKind::Yield { .. }"}, {"sha": "431c3255ab2ac607f0715e934640495ebe162bab", "filename": "compiler/rustc_mir_build/src/errors.rs", "status": "modified", "additions": 8, "deletions": 29, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/6efdf4d1309f8047bc439a4810888c715e2df480/compiler%2Frustc_mir_build%2Fsrc%2Ferrors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6efdf4d1309f8047bc439a4810888c715e2df480/compiler%2Frustc_mir_build%2Fsrc%2Ferrors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Ferrors.rs?ref=6efdf4d1309f8047bc439a4810888c715e2df480", "patch": "@@ -6,11 +6,11 @@ use rustc_errors::{\n     error_code, AddToDiagnostic, Applicability, Diagnostic, DiagnosticBuilder, ErrorGuaranteed,\n     Handler, IntoDiagnostic, MultiSpan, SubdiagnosticMessage,\n };\n-use rustc_hir::def::Res;\n use rustc_macros::{Diagnostic, LintDiagnostic, Subdiagnostic};\n use rustc_middle::thir::Pat;\n use rustc_middle::ty::{self, Ty};\n-use rustc_span::{symbol::Ident, Span};\n+use rustc_span::symbol::Symbol;\n+use rustc_span::Span;\n \n #[derive(LintDiagnostic)]\n #[diag(mir_build_unconditional_recursion)]\n@@ -534,18 +534,10 @@ pub struct TrailingIrrefutableLetPatterns {\n #[derive(LintDiagnostic)]\n #[diag(mir_build_bindings_with_variant_name, code = \"E0170\")]\n pub struct BindingsWithVariantName {\n-    #[suggestion(code = \"{ty_path}::{ident}\", applicability = \"machine-applicable\")]\n+    #[suggestion(code = \"{ty_path}::{name}\", applicability = \"machine-applicable\")]\n     pub suggestion: Option<Span>,\n     pub ty_path: String,\n-    pub ident: Ident,\n-}\n-\n-#[derive(LintDiagnostic)]\n-#[diag(mir_build_irrefutable_let_patterns_generic_let)]\n-#[note]\n-#[help]\n-pub struct IrrefutableLetPatternsGenericLet {\n-    pub count: usize,\n+    pub name: Symbol,\n }\n \n #[derive(LintDiagnostic)]\n@@ -584,13 +576,12 @@ pub struct IrrefutableLetPatternsWhileLet {\n #[diag(mir_build_borrow_of_moved_value)]\n pub struct BorrowOfMovedValue<'tcx> {\n     #[primary_span]\n-    pub span: Span,\n     #[label]\n     #[label(mir_build_occurs_because_label)]\n     pub binding_span: Span,\n     #[label(mir_build_value_borrowed_label)]\n     pub conflicts_ref: Vec<Span>,\n-    pub name: Ident,\n+    pub name: Symbol,\n     pub ty: Ty<'tcx>,\n     #[suggestion(code = \"ref \", applicability = \"machine-applicable\")]\n     pub suggest_borrowing: Option<Span>,\n@@ -638,19 +629,19 @@ pub enum Conflict {\n     Mut {\n         #[primary_span]\n         span: Span,\n-        name: Ident,\n+        name: Symbol,\n     },\n     #[label(mir_build_borrow)]\n     Ref {\n         #[primary_span]\n         span: Span,\n-        name: Ident,\n+        name: Symbol,\n     },\n     #[label(mir_build_moved)]\n     Moved {\n         #[primary_span]\n         span: Span,\n-        name: Ident,\n+        name: Symbol,\n     },\n }\n \n@@ -802,8 +793,6 @@ pub(crate) struct PatternNotCovered<'s, 'tcx> {\n     pub let_suggestion: Option<SuggestLet>,\n     #[subdiagnostic]\n     pub misc_suggestion: Option<MiscPatternSuggestion>,\n-    #[subdiagnostic]\n-    pub res_defined_here: Option<ResDefinedHere>,\n }\n \n #[derive(Subdiagnostic)]\n@@ -837,14 +826,6 @@ impl<'tcx> AddToDiagnostic for AdtDefinedHere<'tcx> {\n     }\n }\n \n-#[derive(Subdiagnostic)]\n-#[label(mir_build_res_defined_here)]\n-pub struct ResDefinedHere {\n-    #[primary_span]\n-    pub def_span: Span,\n-    pub res: Res,\n-}\n-\n #[derive(Subdiagnostic)]\n #[suggestion(\n     mir_build_interpreted_as_const,\n@@ -855,9 +836,7 @@ pub struct ResDefinedHere {\n pub struct InterpretedAsConst {\n     #[primary_span]\n     pub span: Span,\n-    pub article: &'static str,\n     pub variable: String,\n-    pub res: Res,\n }\n \n #[derive(Subdiagnostic)]"}, {"sha": "8e41957af0ebabc4c964b4ea1938247c15e11ed0", "filename": "compiler/rustc_mir_build/src/lints.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/6efdf4d1309f8047bc439a4810888c715e2df480/compiler%2Frustc_mir_build%2Fsrc%2Flints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6efdf4d1309f8047bc439a4810888c715e2df480/compiler%2Frustc_mir_build%2Fsrc%2Flints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Flints.rs?ref=6efdf4d1309f8047bc439a4810888c715e2df480", "patch": "@@ -3,7 +3,7 @@ use rustc_data_structures::graph::iterate::{\n     NodeStatus, TriColorDepthFirstSearch, TriColorVisitor,\n };\n use rustc_hir::def::DefKind;\n-use rustc_middle::mir::{BasicBlock, BasicBlocks, Body, Operand, TerminatorKind};\n+use rustc_middle::mir::{self, BasicBlock, BasicBlocks, Body, Operand, TerminatorKind};\n use rustc_middle::ty::subst::{GenericArg, InternalSubsts};\n use rustc_middle::ty::{self, Instance, TyCtxt};\n use rustc_session::lint::builtin::UNCONDITIONAL_RECURSION;\n@@ -108,7 +108,7 @@ impl<'mir, 'tcx> TriColorVisitor<BasicBlocks<'tcx>> for Search<'mir, 'tcx> {\n \n         match self.body[bb].terminator().kind {\n             // These terminators return control flow to the caller.\n-            TerminatorKind::Abort\n+            TerminatorKind::Terminate\n             | TerminatorKind::GeneratorDrop\n             | TerminatorKind::Resume\n             | TerminatorKind::Return\n@@ -149,7 +149,9 @@ impl<'mir, 'tcx> TriColorVisitor<BasicBlocks<'tcx>> for Search<'mir, 'tcx> {\n \n     fn ignore_edge(&mut self, bb: BasicBlock, target: BasicBlock) -> bool {\n         let terminator = self.body[bb].terminator();\n-        if terminator.unwind() == Some(&Some(target)) && terminator.successors().count() > 1 {\n+        if terminator.unwind() == Some(&mir::UnwindAction::Cleanup(target))\n+            && terminator.successors().count() > 1\n+        {\n             return true;\n         }\n         // Don't traverse successors of recursive calls or false CFG edges."}, {"sha": "8aacec53f94597d818cd98a55940d8fb0db117c6", "filename": "compiler/rustc_mir_build/src/thir/cx/block.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/6efdf4d1309f8047bc439a4810888c715e2df480/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fcx%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6efdf4d1309f8047bc439a4810888c715e2df480/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fcx%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fcx%2Fblock.rs?ref=6efdf4d1309f8047bc439a4810888c715e2df480", "patch": "@@ -105,6 +105,10 @@ impl<'tcx> Cx<'tcx> {\n                             }\n                         }\n \n+                        let span = match local.init {\n+                            Some(init) => local.span.with_hi(init.span.hi()),\n+                            None => local.span,\n+                        };\n                         let stmt = Stmt {\n                             kind: StmtKind::Let {\n                                 remainder_scope,\n@@ -116,6 +120,7 @@ impl<'tcx> Cx<'tcx> {\n                                 initializer: local.init.map(|init| self.mirror_expr(init)),\n                                 else_block,\n                                 lint_level: LintLevel::Explicit(local.hir_id),\n+                                span,\n                             },\n                             opt_destruction_scope: opt_dxn_ext,\n                         };"}, {"sha": "0882b473f10877a62c730201dd6e466e2b1ee66b", "filename": "compiler/rustc_mir_build/src/thir/pattern/check_match.rs", "status": "modified", "additions": 334, "deletions": 380, "changes": 714, "blob_url": "https://github.com/rust-lang/rust/blob/6efdf4d1309f8047bc439a4810888c715e2df480/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fcheck_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6efdf4d1309f8047bc439a4810888c715e2df480/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fcheck_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fcheck_match.rs?ref=6efdf4d1309f8047bc439a4810888c715e2df480", "patch": "@@ -2,45 +2,48 @@ use super::deconstruct_pat::{Constructor, DeconstructedPat};\n use super::usefulness::{\n     compute_match_usefulness, MatchArm, MatchCheckCtxt, Reachability, UsefulnessReport,\n };\n-use super::{PatCtxt, PatternError};\n \n use crate::errors::*;\n \n-use hir::{ExprKind, PatKind};\n use rustc_arena::TypedArena;\n-use rustc_ast::{LitKind, Mutability};\n+use rustc_ast::Mutability;\n+use rustc_data_structures::stack::ensure_sufficient_stack;\n use rustc_errors::{\n     struct_span_err, Applicability, Diagnostic, DiagnosticBuilder, ErrorGuaranteed, MultiSpan,\n };\n use rustc_hir as hir;\n use rustc_hir::def::*;\n-use rustc_hir::def_id::DefId;\n-use rustc_hir::intravisit::{self, Visitor};\n-use rustc_hir::{HirId, Pat};\n+use rustc_hir::def_id::LocalDefId;\n+use rustc_hir::HirId;\n+use rustc_middle::thir::visit::{self, Visitor};\n+use rustc_middle::thir::*;\n use rustc_middle::ty::print::with_no_trimmed_paths;\n use rustc_middle::ty::{self, AdtDef, Ty, TyCtxt};\n-\n use rustc_session::lint::builtin::{\n     BINDINGS_WITH_VARIANT_NAME, IRREFUTABLE_LET_PATTERNS, UNREACHABLE_PATTERNS,\n };\n use rustc_session::Session;\n-use rustc_span::source_map::Spanned;\n-use rustc_span::{BytePos, Span};\n-\n-pub(crate) fn check_match(tcx: TyCtxt<'_>, def_id: DefId) {\n-    let body_id = match def_id.as_local() {\n-        None => return,\n-        Some(def_id) => tcx.hir().body_owned_by(def_id),\n-    };\n+use rustc_span::hygiene::DesugaringKind;\n+use rustc_span::Span;\n \n+pub(crate) fn check_match(tcx: TyCtxt<'_>, def_id: LocalDefId) {\n+    let Ok((thir, expr)) = tcx.thir_body(ty::WithOptConstParam::unknown(def_id)) else { return };\n+    let thir = thir.borrow();\n     let pattern_arena = TypedArena::default();\n     let mut visitor = MatchVisitor {\n         tcx,\n-        typeck_results: tcx.typeck_body(body_id),\n+        thir: &*thir,\n         param_env: tcx.param_env(def_id),\n+        lint_level: tcx.hir().local_def_id_to_hir_id(def_id),\n+        let_source: LetSource::None,\n         pattern_arena: &pattern_arena,\n     };\n-    visitor.visit_body(tcx.hir().body(body_id));\n+    visitor.visit_expr(&thir[expr]);\n+    for param in thir.params.iter() {\n+        if let Some(box ref pattern) = param.pat {\n+            visitor.check_irrefutable(pattern, \"function argument\", None);\n+        }\n+    }\n }\n \n fn create_e0004(\n@@ -58,151 +61,196 @@ enum RefutableFlag {\n }\n use RefutableFlag::*;\n \n+#[derive(Clone, Copy, Debug, PartialEq, Eq)]\n+enum LetSource {\n+    None,\n+    IfLet,\n+    IfLetGuard,\n+    LetElse,\n+    WhileLet,\n+}\n+\n struct MatchVisitor<'a, 'p, 'tcx> {\n     tcx: TyCtxt<'tcx>,\n-    typeck_results: &'a ty::TypeckResults<'tcx>,\n     param_env: ty::ParamEnv<'tcx>,\n+    thir: &'a Thir<'tcx>,\n+    lint_level: HirId,\n+    let_source: LetSource,\n     pattern_arena: &'p TypedArena<DeconstructedPat<'p, 'tcx>>,\n }\n \n-impl<'tcx> Visitor<'tcx> for MatchVisitor<'_, '_, 'tcx> {\n-    fn visit_expr(&mut self, ex: &'tcx hir::Expr<'tcx>) {\n-        intravisit::walk_expr(self, ex);\n-        match &ex.kind {\n-            hir::ExprKind::Match(scrut, arms, source) => {\n-                self.check_match(scrut, arms, *source, ex.span)\n+impl<'a, 'tcx> Visitor<'a, 'tcx> for MatchVisitor<'a, '_, 'tcx> {\n+    fn thir(&self) -> &'a Thir<'tcx> {\n+        self.thir\n+    }\n+\n+    #[instrument(level = \"trace\", skip(self))]\n+    fn visit_arm(&mut self, arm: &Arm<'tcx>) {\n+        match arm.guard {\n+            Some(Guard::If(expr)) => {\n+                self.with_let_source(LetSource::IfLetGuard, |this| {\n+                    this.visit_expr(&this.thir[expr])\n+                });\n             }\n-            hir::ExprKind::Let(hir::Let { pat, init, span, .. }) => {\n-                self.check_let(pat, init, *span)\n+            Some(Guard::IfLet(ref pat, expr)) => {\n+                self.with_let_source(LetSource::IfLetGuard, |this| {\n+                    this.check_let(pat, expr, LetSource::IfLetGuard, pat.span);\n+                    this.visit_pat(pat);\n+                    this.visit_expr(&this.thir[expr]);\n+                });\n             }\n-            _ => {}\n+            None => {}\n         }\n+        self.visit_pat(&arm.pattern);\n+        self.visit_expr(&self.thir[arm.body]);\n     }\n \n-    fn visit_local(&mut self, loc: &'tcx hir::Local<'tcx>) {\n-        intravisit::walk_local(self, loc);\n-        let els = loc.els;\n-        if let Some(init) = loc.init && els.is_some() {\n-            // Build a span without the else { ... } as we don't want to underline\n-            // the entire else block in the IDE setting.\n-            let span = loc.span.with_hi(init.span.hi());\n-            self.check_let(&loc.pat, init, span);\n-        }\n-\n-        let (msg, sp) = match loc.source {\n-            hir::LocalSource::Normal => (\"local binding\", Some(loc.span)),\n-            hir::LocalSource::AsyncFn => (\"async fn binding\", None),\n-            hir::LocalSource::AwaitDesugar => (\"`await` future binding\", None),\n-            hir::LocalSource::AssignDesugar(_) => (\"destructuring assignment binding\", None),\n+    #[instrument(level = \"trace\", skip(self))]\n+    fn visit_expr(&mut self, ex: &Expr<'tcx>) {\n+        match ex.kind {\n+            ExprKind::Scope { value, lint_level, .. } => {\n+                let old_lint_level = self.lint_level;\n+                if let LintLevel::Explicit(hir_id) = lint_level {\n+                    self.lint_level = hir_id;\n+                }\n+                self.visit_expr(&self.thir[value]);\n+                self.lint_level = old_lint_level;\n+                return;\n+            }\n+            ExprKind::If { cond, then, else_opt, if_then_scope: _ } => {\n+                // Give a specific `let_source` for the condition.\n+                let let_source = match ex.span.desugaring_kind() {\n+                    Some(DesugaringKind::WhileLoop) => LetSource::WhileLet,\n+                    _ => LetSource::IfLet,\n+                };\n+                self.with_let_source(let_source, |this| this.visit_expr(&self.thir[cond]));\n+                self.with_let_source(LetSource::None, |this| {\n+                    this.visit_expr(&this.thir[then]);\n+                    if let Some(else_) = else_opt {\n+                        this.visit_expr(&this.thir[else_]);\n+                    }\n+                });\n+                return;\n+            }\n+            ExprKind::Match { scrutinee, box ref arms } => {\n+                let source = match ex.span.desugaring_kind() {\n+                    Some(DesugaringKind::ForLoop) => hir::MatchSource::ForLoopDesugar,\n+                    Some(DesugaringKind::QuestionMark) => hir::MatchSource::TryDesugar,\n+                    Some(DesugaringKind::Await) => hir::MatchSource::AwaitDesugar,\n+                    _ => hir::MatchSource::Normal,\n+                };\n+                self.check_match(scrutinee, arms, source, ex.span);\n+            }\n+            ExprKind::Let { box ref pat, expr } => {\n+                self.check_let(pat, expr, self.let_source, ex.span);\n+            }\n+            ExprKind::LogicalOp { op: LogicalOp::And, lhs, rhs } => {\n+                self.check_let_chain(self.let_source, ex.span, lhs, rhs);\n+            }\n+            _ => {}\n         };\n-        if els.is_none() {\n-            self.check_irrefutable(&loc.pat, msg, sp);\n-        }\n+        self.with_let_source(LetSource::None, |this| visit::walk_expr(this, ex));\n     }\n \n-    fn visit_param(&mut self, param: &'tcx hir::Param<'tcx>) {\n-        intravisit::walk_param(self, param);\n-        self.check_irrefutable(&param.pat, \"function argument\", None);\n-    }\n-}\n-\n-impl PatCtxt<'_, '_> {\n-    fn report_inlining_errors(&self) {\n-        for error in &self.errors {\n-            match *error {\n-                PatternError::StaticInPattern(span) => {\n-                    self.tcx.sess.emit_err(StaticInPattern { span });\n+    fn visit_stmt(&mut self, stmt: &Stmt<'tcx>) {\n+        let old_lint_level = self.lint_level;\n+        match stmt.kind {\n+            StmtKind::Let {\n+                box ref pattern, initializer, else_block, lint_level, span, ..\n+            } => {\n+                if let LintLevel::Explicit(lint_level) = lint_level {\n+                    self.lint_level = lint_level;\n                 }\n-                PatternError::AssocConstInPattern(span) => {\n-                    self.tcx.sess.emit_err(AssocConstInPattern { span });\n-                }\n-                PatternError::ConstParamInPattern(span) => {\n-                    self.tcx.sess.emit_err(ConstParamInPattern { span });\n+\n+                if let Some(initializer) = initializer && else_block.is_some() {\n+                    self.check_let(pattern, initializer, LetSource::LetElse, span);\n                 }\n-                PatternError::NonConstPath(span) => {\n-                    self.tcx.sess.emit_err(NonConstPath { span });\n+\n+                if else_block.is_none() {\n+                    self.check_irrefutable(pattern, \"local binding\", Some(span));\n                 }\n             }\n+            _ => {}\n         }\n+        visit::walk_stmt(self, stmt);\n+        self.lint_level = old_lint_level;\n     }\n }\n \n impl<'p, 'tcx> MatchVisitor<'_, 'p, 'tcx> {\n-    fn check_patterns(&self, pat: &Pat<'_>, rf: RefutableFlag) {\n+    #[instrument(level = \"trace\", skip(self, f))]\n+    fn with_let_source(&mut self, let_source: LetSource, f: impl FnOnce(&mut Self)) {\n+        let old_let_source = self.let_source;\n+        self.let_source = let_source;\n+        ensure_sufficient_stack(|| f(self));\n+        self.let_source = old_let_source;\n+    }\n+\n+    fn check_patterns(&self, pat: &Pat<'tcx>, rf: RefutableFlag) {\n         pat.walk_always(|pat| check_borrow_conflicts_in_at_patterns(self, pat));\n         check_for_bindings_named_same_as_variants(self, pat, rf);\n     }\n \n     fn lower_pattern(\n         &self,\n         cx: &mut MatchCheckCtxt<'p, 'tcx>,\n-        pat: &'tcx hir::Pat<'tcx>,\n-        have_errors: &mut bool,\n+        pattern: &Pat<'tcx>,\n     ) -> &'p DeconstructedPat<'p, 'tcx> {\n-        let mut patcx = PatCtxt::new(self.tcx, self.param_env, self.typeck_results);\n-        patcx.include_lint_checks();\n-        let pattern = patcx.lower_pattern(pat);\n-        let pattern: &_ = cx.pattern_arena.alloc(DeconstructedPat::from_pat(cx, &pattern));\n-        if !patcx.errors.is_empty() {\n-            *have_errors = true;\n-            patcx.report_inlining_errors();\n-        }\n-        pattern\n+        cx.pattern_arena.alloc(DeconstructedPat::from_pat(cx, &pattern))\n     }\n \n-    fn new_cx(&self, hir_id: HirId) -> MatchCheckCtxt<'p, 'tcx> {\n+    fn new_cx(&self, hir_id: HirId, refutable: bool) -> MatchCheckCtxt<'p, 'tcx> {\n         MatchCheckCtxt {\n             tcx: self.tcx,\n             param_env: self.param_env,\n             module: self.tcx.parent_module(hir_id).to_def_id(),\n             pattern_arena: &self.pattern_arena,\n+            refutable,\n         }\n     }\n \n-    fn check_let(&mut self, pat: &'tcx hir::Pat<'tcx>, scrutinee: &hir::Expr<'_>, span: Span) {\n+    #[instrument(level = \"trace\", skip(self))]\n+    fn check_let(&mut self, pat: &Pat<'tcx>, scrutinee: ExprId, source: LetSource, span: Span) {\n+        if let LetSource::None = source {\n+            return;\n+        }\n         self.check_patterns(pat, Refutable);\n-        let mut cx = self.new_cx(scrutinee.hir_id);\n-        let tpat = self.lower_pattern(&mut cx, pat, &mut false);\n-        self.check_let_reachability(&mut cx, pat.hir_id, tpat, span);\n+        let mut cx = self.new_cx(self.lint_level, true);\n+        let tpat = self.lower_pattern(&mut cx, pat);\n+        self.check_let_reachability(&mut cx, self.lint_level, source, tpat, span);\n     }\n \n     fn check_match(\n         &mut self,\n-        scrut: &hir::Expr<'_>,\n-        hir_arms: &'tcx [hir::Arm<'tcx>],\n+        scrut: ExprId,\n+        arms: &[ArmId],\n         source: hir::MatchSource,\n         expr_span: Span,\n     ) {\n-        let mut cx = self.new_cx(scrut.hir_id);\n+        let mut cx = self.new_cx(self.lint_level, true);\n \n-        for arm in hir_arms {\n+        for &arm in arms {\n             // Check the arm for some things unrelated to exhaustiveness.\n-            self.check_patterns(&arm.pat, Refutable);\n-            if let Some(hir::Guard::IfLet(ref let_expr)) = arm.guard {\n-                self.check_patterns(let_expr.pat, Refutable);\n-                let tpat = self.lower_pattern(&mut cx, let_expr.pat, &mut false);\n-                self.check_let_reachability(&mut cx, let_expr.pat.hir_id, tpat, tpat.span());\n-            }\n+            let arm = &self.thir.arms[arm];\n+            self.check_patterns(&arm.pattern, Refutable);\n         }\n \n-        let mut have_errors = false;\n-\n-        let arms: Vec<_> = hir_arms\n+        let tarms: Vec<_> = arms\n             .iter()\n-            .map(|hir::Arm { pat, guard, .. }| MatchArm {\n-                pat: self.lower_pattern(&mut cx, pat, &mut have_errors),\n-                hir_id: pat.hir_id,\n-                has_guard: guard.is_some(),\n+            .map(|&arm| {\n+                let arm = &self.thir.arms[arm];\n+                let hir_id = match arm.lint_level {\n+                    LintLevel::Explicit(hir_id) => hir_id,\n+                    LintLevel::Inherited => self.lint_level,\n+                };\n+                let pat = self.lower_pattern(&mut cx, &arm.pattern);\n+                MatchArm { pat, hir_id, has_guard: arm.guard.is_some() }\n             })\n             .collect();\n \n-        // Bail out early if lowering failed.\n-        if have_errors {\n-            return;\n-        }\n-\n-        let scrut_ty = self.typeck_results.expr_ty_adjusted(scrut);\n-        let report = compute_match_usefulness(&cx, &arms, scrut.hir_id, scrut_ty);\n+        let scrut = &self.thir[scrut];\n+        let scrut_ty = scrut.ty;\n+        let report = compute_match_usefulness(&cx, &tarms, self.lint_level, scrut_ty);\n \n         match source {\n             // Don't report arm reachability of desugared `match $iter.into_iter() { iter => .. }`\n@@ -219,12 +267,18 @@ impl<'p, 'tcx> MatchVisitor<'_, 'p, 'tcx> {\n         // Check if the match is exhaustive.\n         let witnesses = report.non_exhaustiveness_witnesses;\n         if !witnesses.is_empty() {\n-            if source == hir::MatchSource::ForLoopDesugar && hir_arms.len() == 2 {\n+            if source == hir::MatchSource::ForLoopDesugar && arms.len() == 2 {\n                 // the for loop pattern is not irrefutable\n-                let pat = hir_arms[1].pat.for_loop_some().unwrap();\n-                self.check_irrefutable(pat, \"`for` loop binding\", None);\n+                let pat = &self.thir[arms[1]].pattern;\n+                // `pat` should be `Some(<pat_field>)` from a desugared for loop.\n+                debug_assert_eq!(pat.span.desugaring_kind(), Some(DesugaringKind::ForLoop));\n+                let PatKind::Variant { ref subpatterns, .. } = pat.kind else { bug!() };\n+                let [pat_field] = &subpatterns[..] else { bug!() };\n+                self.check_irrefutable(&pat_field.pattern, \"`for` loop binding\", None);\n             } else {\n-                non_exhaustive_match(&cx, scrut_ty, scrut.span, witnesses, hir_arms, expr_span);\n+                non_exhaustive_match(\n+                    &cx, self.thir, scrut_ty, scrut.span, witnesses, arms, expr_span,\n+                );\n             }\n         }\n     }\n@@ -233,114 +287,96 @@ impl<'p, 'tcx> MatchVisitor<'_, 'p, 'tcx> {\n         &mut self,\n         cx: &mut MatchCheckCtxt<'p, 'tcx>,\n         pat_id: HirId,\n+        source: LetSource,\n         pat: &'p DeconstructedPat<'p, 'tcx>,\n         span: Span,\n     ) {\n-        if self.check_let_chain(cx, pat_id) {\n-            return;\n-        }\n-\n         if is_let_irrefutable(cx, pat_id, pat) {\n-            irrefutable_let_pattern(cx.tcx, pat_id, span);\n+            irrefutable_let_patterns(cx.tcx, pat_id, source, 1, span);\n         }\n     }\n \n-    fn check_let_chain(&mut self, cx: &mut MatchCheckCtxt<'p, 'tcx>, pat_id: HirId) -> bool {\n-        let hir = self.tcx.hir();\n-        let parent = hir.parent_id(pat_id);\n+    #[instrument(level = \"trace\", skip(self))]\n+    fn check_let_chain(\n+        &mut self,\n+        let_source: LetSource,\n+        top_expr_span: Span,\n+        mut lhs: ExprId,\n+        rhs: ExprId,\n+    ) {\n+        if let LetSource::None = let_source {\n+            return;\n+        }\n \n-        // First, figure out if the given pattern is part of a let chain,\n-        // and if so, obtain the top node of the chain.\n-        let mut top = parent;\n-        let mut part_of_chain = false;\n-        loop {\n-            let new_top = hir.parent_id(top);\n-            if let hir::Node::Expr(\n-                hir::Expr {\n-                    kind: hir::ExprKind::Binary(Spanned { node: hir::BinOpKind::And, .. }, lhs, rhs),\n-                    ..\n-                },\n-                ..,\n-            ) = hir.get(new_top)\n-            {\n-                // If this isn't the first iteration, we need to check\n-                // if there is a let expr before us in the chain, so\n-                // that we avoid doubly checking the let chain.\n-\n-                // The way a chain of &&s is encoded is ((let ... && let ...) && let ...) && let ...\n-                // as && is left-to-right associative. Thus, we need to check rhs.\n-                if part_of_chain && matches!(rhs.kind, hir::ExprKind::Let(..)) {\n-                    return true;\n+        // Lint level enclosing the next `lhs`.\n+        let mut cur_lint_level = self.lint_level;\n+\n+        // Obtain the refutabilities of all exprs in the chain,\n+        // and record chain members that aren't let exprs.\n+        let mut chain_refutabilities = Vec::new();\n+\n+        let add = |expr: ExprId, mut local_lint_level| {\n+            // `local_lint_level` is the lint level enclosing the pattern inside `expr`.\n+            let mut expr = &self.thir[expr];\n+            debug!(?expr, ?local_lint_level, \"add\");\n+            // Fast-forward through scopes.\n+            while let ExprKind::Scope { value, lint_level, .. } = expr.kind {\n+                if let LintLevel::Explicit(hir_id) = lint_level {\n+                    local_lint_level = hir_id\n                 }\n-                // If there is a let at the lhs, and we provide the rhs, we don't do any checking either.\n-                if !part_of_chain && matches!(lhs.kind, hir::ExprKind::Let(..)) && rhs.hir_id == top\n-                {\n-                    return true;\n+                expr = &self.thir[value];\n+            }\n+            debug!(?expr, ?local_lint_level, \"after scopes\");\n+            match expr.kind {\n+                ExprKind::Let { box ref pat, expr: _ } => {\n+                    let mut ncx = self.new_cx(local_lint_level, true);\n+                    let tpat = self.lower_pattern(&mut ncx, pat);\n+                    let refutable = !is_let_irrefutable(&mut ncx, local_lint_level, tpat);\n+                    Some((expr.span, refutable))\n                 }\n-            } else {\n-                // We've reached the top.\n-                break;\n+                ExprKind::LogicalOp { op: LogicalOp::And, .. } => {\n+                    bug!()\n+                }\n+                _ => None,\n             }\n+        };\n \n-            // Since this function is called within a let context, it is reasonable to assume that any parent\n-            // `&&` infers a let chain\n-            part_of_chain = true;\n-            top = new_top;\n-        }\n-        if !part_of_chain {\n-            return false;\n-        }\n+        // Let chains recurse on the left, so we start by adding the rightmost.\n+        chain_refutabilities.push(add(rhs, cur_lint_level));\n \n-        // Second, obtain the refutabilities of all exprs in the chain,\n-        // and record chain members that aren't let exprs.\n-        let mut chain_refutabilities = Vec::new();\n-        let hir::Node::Expr(top_expr) = hir.get(top) else {\n-            // We ensure right above that it's an Expr\n-            unreachable!()\n-        };\n-        let mut cur_expr = top_expr;\n         loop {\n-            let mut add = |expr: &hir::Expr<'tcx>| {\n-                let refutability = match expr.kind {\n-                    hir::ExprKind::Let(hir::Let { pat, init, span, .. }) => {\n-                        let mut ncx = self.new_cx(init.hir_id);\n-                        let tpat = self.lower_pattern(&mut ncx, pat, &mut false);\n-\n-                        let refutable = !is_let_irrefutable(&mut ncx, pat.hir_id, tpat);\n-                        Some((*span, refutable))\n-                    }\n-                    _ => None,\n-                };\n-                chain_refutabilities.push(refutability);\n-            };\n-            if let hir::Expr {\n-                kind: hir::ExprKind::Binary(Spanned { node: hir::BinOpKind::And, .. }, lhs, rhs),\n-                ..\n-            } = cur_expr\n+            while let ExprKind::Scope { value, lint_level, .. } = self.thir[lhs].kind {\n+                if let LintLevel::Explicit(hir_id) = lint_level {\n+                    cur_lint_level = hir_id\n+                }\n+                lhs = value;\n+            }\n+            if let ExprKind::LogicalOp { op: LogicalOp::And, lhs: new_lhs, rhs: expr } =\n+                self.thir[lhs].kind\n             {\n-                add(rhs);\n-                cur_expr = lhs;\n+                chain_refutabilities.push(add(expr, cur_lint_level));\n+                lhs = new_lhs;\n             } else {\n-                add(cur_expr);\n+                chain_refutabilities.push(add(lhs, cur_lint_level));\n                 break;\n             }\n         }\n+        debug!(?chain_refutabilities);\n         chain_refutabilities.reverse();\n \n         // Third, emit the actual warnings.\n-\n         if chain_refutabilities.iter().all(|r| matches!(*r, Some((_, false)))) {\n             // The entire chain is made up of irrefutable `let` statements\n-            let let_source = let_source_parent(self.tcx, top, None);\n             irrefutable_let_patterns(\n-                cx.tcx,\n-                top,\n+                self.tcx,\n+                self.lint_level,\n                 let_source,\n                 chain_refutabilities.len(),\n-                top_expr.span,\n+                top_expr_span,\n             );\n-            return true;\n+            return;\n         }\n+\n         if let Some(until) = chain_refutabilities.iter().position(|r| !matches!(*r, Some((_, false)))) && until > 0 {\n             // The chain has a non-zero prefix of irrefutable `let` statements.\n \n@@ -350,36 +386,36 @@ impl<'p, 'tcx> MatchVisitor<'_, 'p, 'tcx> {\n             // so can't always be moved out.\n             // FIXME: Add checking whether the bindings are actually used in the prefix,\n             // and lint if they are not.\n-            let let_source = let_source_parent(self.tcx, top, None);\n             if !matches!(let_source, LetSource::WhileLet | LetSource::IfLetGuard) {\n                 // Emit the lint\n                 let prefix = &chain_refutabilities[..until];\n                 let span_start = prefix[0].unwrap().0;\n                 let span_end = prefix.last().unwrap().unwrap().0;\n                 let span = span_start.to(span_end);\n                 let count = prefix.len();\n-                cx.tcx.emit_spanned_lint(IRREFUTABLE_LET_PATTERNS, top, span, LeadingIrrefutableLetPatterns { count });\n+                self.tcx.emit_spanned_lint(IRREFUTABLE_LET_PATTERNS, self.lint_level, span, LeadingIrrefutableLetPatterns { count });\n             }\n         }\n+\n         if let Some(from) = chain_refutabilities.iter().rposition(|r| !matches!(*r, Some((_, false)))) && from != (chain_refutabilities.len() - 1) {\n             // The chain has a non-empty suffix of irrefutable `let` statements\n             let suffix = &chain_refutabilities[from + 1..];\n             let span_start = suffix[0].unwrap().0;\n             let span_end = suffix.last().unwrap().unwrap().0;\n             let span = span_start.to(span_end);\n             let count = suffix.len();\n-            cx.tcx.emit_spanned_lint(IRREFUTABLE_LET_PATTERNS, top, span, TrailingIrrefutableLetPatterns { count });\n+            self.tcx.emit_spanned_lint(IRREFUTABLE_LET_PATTERNS, self.lint_level, span, TrailingIrrefutableLetPatterns { count });\n         }\n-        true\n     }\n \n-    fn check_irrefutable(&self, pat: &'tcx Pat<'tcx>, origin: &str, sp: Option<Span>) {\n-        let mut cx = self.new_cx(pat.hir_id);\n+    #[instrument(level = \"trace\", skip(self))]\n+    fn check_irrefutable(&self, pat: &Pat<'tcx>, origin: &str, sp: Option<Span>) {\n+        let mut cx = self.new_cx(self.lint_level, false);\n \n-        let pattern = self.lower_pattern(&mut cx, pat, &mut false);\n+        let pattern = self.lower_pattern(&mut cx, pat);\n         let pattern_ty = pattern.ty();\n-        let arm = MatchArm { pat: pattern, hir_id: pat.hir_id, has_guard: false };\n-        let report = compute_match_usefulness(&cx, &[arm], pat.hir_id, pattern_ty);\n+        let arm = MatchArm { pat: pattern, hir_id: self.lint_level, has_guard: false };\n+        let report = compute_match_usefulness(&cx, &[arm], self.lint_level, pattern_ty);\n \n         // Note: we ignore whether the pattern is unreachable (i.e. whether the type is empty). We\n         // only care about exhaustiveness here.\n@@ -390,58 +426,45 @@ impl<'p, 'tcx> MatchVisitor<'_, 'p, 'tcx> {\n             return;\n         }\n \n-        let (inform, interpreted_as_const, res_defined_here,let_suggestion, misc_suggestion) =\n-            if let hir::PatKind::Path(hir::QPath::Resolved(\n-                None,\n-                hir::Path {\n-                    segments: &[hir::PathSegment { args: None, res, ident, .. }],\n-                    ..\n-                },\n-            )) = &pat.kind\n-            {\n-                (\n-                    None,\n-                    Some(InterpretedAsConst {\n-                        span: pat.span,\n-                        article: res.article(),\n-                        variable: ident.to_string().to_lowercase(),\n-                        res,\n-                    }),\n-                    try {\n-                        ResDefinedHere {\n-                            def_span: cx.tcx.hir().res_span(res)?,\n-                            res,\n-                        }\n-                    },\n-                    None,\n-                    None,\n-                )\n-            } else if let Some(span) = sp && self.tcx.sess.source_map().is_span_accessible(span) {\n-                let mut bindings = vec![];\n-                pat.walk_always(&mut |pat: &hir::Pat<'_>| {\n-                    if let hir::PatKind::Binding(_, _, ident, _) = pat.kind {\n-                        bindings.push(ident);\n-                    }\n+        let inform = sp.is_some().then_some(Inform);\n+        let mut let_suggestion = None;\n+        let mut misc_suggestion = None;\n+        let mut interpreted_as_const = None;\n+        if let PatKind::Constant { .. } = pat.kind\n+            && let Ok(snippet) = self.tcx.sess.source_map().span_to_snippet(pat.span)\n+        {\n+            // If the pattern to match is an integer literal:\n+            if snippet.chars().all(|c| c.is_digit(10)) {\n+                // Then give a suggestion, the user might've meant to create a binding instead.\n+                misc_suggestion = Some(MiscPatternSuggestion::AttemptedIntegerLiteral {\n+                    start_span: pat.span.shrink_to_lo()\n                 });\n-                let semi_span = span.shrink_to_hi().with_lo(span.hi() - BytePos(1));\n-                let start_span = span.shrink_to_lo();\n-                let end_span = semi_span.shrink_to_lo();\n-                let count = witnesses.len();\n-\n-                // If the pattern to match is an integer literal:\n-                let int_suggestion = if\n-                    let PatKind::Lit(expr) = &pat.kind\n-                    && bindings.is_empty()\n-                    && let ExprKind::Lit(Spanned { node: LitKind::Int(_, _), span }) = expr.kind {\n-                    // Then give a suggestion, the user might've meant to create a binding instead.\n-                    Some(MiscPatternSuggestion::AttemptedIntegerLiteral { start_span: span.shrink_to_lo() })\n-                } else { None };\n-\n-                let let_suggestion = if bindings.is_empty() {SuggestLet::If{start_span, semi_span, count}} else{ SuggestLet::Else{end_span, count }};\n-                (sp.map(|_|Inform), None, None, Some(let_suggestion), int_suggestion)\n-            } else{\n-                (sp.map(|_|Inform), None, None,  None, None)\n-            };\n+            } else if snippet.chars().all(|c| c.is_alphanumeric() || c == '_') {\n+                interpreted_as_const = Some(InterpretedAsConst {\n+                    span: pat.span,\n+                    variable: snippet,\n+                });\n+            }\n+        }\n+\n+        if let Some(span) = sp\n+            && self.tcx.sess.source_map().is_span_accessible(span)\n+            && interpreted_as_const.is_none()\n+        {\n+            let mut bindings = vec![];\n+            pat.each_binding(|name, _, _, _| bindings.push(name));\n+\n+            let semi_span = span.shrink_to_hi();\n+            let start_span = span.shrink_to_lo();\n+            let end_span = semi_span.shrink_to_lo();\n+            let count = witnesses.len();\n+\n+            let_suggestion = Some(if bindings.is_empty() {\n+                SuggestLet::If { start_span, semi_span, count }\n+            } else {\n+                SuggestLet::Else { end_span, count }\n+            });\n+        };\n \n         let adt_defined_here = try {\n             let ty = pattern_ty.peel_refs();\n@@ -465,7 +488,6 @@ impl<'p, 'tcx> MatchVisitor<'_, 'p, 'tcx> {\n             pattern_ty,\n             let_suggestion,\n             misc_suggestion,\n-            res_defined_here,\n             adt_defined_here,\n         });\n     }\n@@ -477,14 +499,18 @@ fn check_for_bindings_named_same_as_variants(\n     rf: RefutableFlag,\n ) {\n     pat.walk_always(|p| {\n-        if let hir::PatKind::Binding(_, _, ident, None) = p.kind\n-            && let Some(ty::BindByValue(hir::Mutability::Not)) =\n-                cx.typeck_results.extract_binding_mode(cx.tcx.sess, p.hir_id, p.span)\n-            && let pat_ty = cx.typeck_results.pat_ty(p).peel_refs()\n-            && let ty::Adt(edef, _) = pat_ty.kind()\n+        if let PatKind::Binding {\n+                name,\n+                mode: BindingMode::ByValue,\n+                mutability: Mutability::Not,\n+                subpattern: None,\n+                ty,\n+                ..\n+            } = p.kind\n+            && let ty::Adt(edef, _) = ty.peel_refs().kind()\n             && edef.is_enum()\n             && edef.variants().iter().any(|variant| {\n-                variant.ident(cx.tcx) == ident && variant.ctor_kind() == Some(CtorKind::Const)\n+                variant.name == name && variant.ctor_kind() == Some(CtorKind::Const)\n             })\n         {\n             let variant_count = edef.variants().len();\n@@ -493,7 +519,7 @@ fn check_for_bindings_named_same_as_variants(\n             });\n             cx.tcx.emit_spanned_lint(\n                 BINDINGS_WITH_VARIANT_NAME,\n-                p.hir_id,\n+                cx.lint_level,\n                 p.span,\n                 BindingsWithVariantName {\n                     // If this is an irrefutable pattern, and there's > 1 variant,\n@@ -503,7 +529,7 @@ fn check_for_bindings_named_same_as_variants(\n                         Some(p.span)\n                     } else { None },\n                     ty_path,\n-                    ident,\n+                    name,\n                 },\n             )\n         }\n@@ -529,11 +555,6 @@ fn unreachable_pattern(tcx: TyCtxt<'_>, span: Span, id: HirId, catchall: Option<\n     );\n }\n \n-fn irrefutable_let_pattern(tcx: TyCtxt<'_>, id: HirId, span: Span) {\n-    let source = let_source(tcx, id);\n-    irrefutable_let_patterns(tcx, id, source, 1, span);\n-}\n-\n fn irrefutable_let_patterns(\n     tcx: TyCtxt<'_>,\n     id: HirId,\n@@ -548,7 +569,7 @@ fn irrefutable_let_patterns(\n     }\n \n     match source {\n-        LetSource::GenericLet => emit_diag!(IrrefutableLetPatternsGenericLet),\n+        LetSource::None => bug!(),\n         LetSource::IfLet => emit_diag!(IrrefutableLetPatternsIfLet),\n         LetSource::IfLetGuard => emit_diag!(IrrefutableLetPatternsIfLetGuard),\n         LetSource::LetElse => emit_diag!(IrrefutableLetPatternsLetElse),\n@@ -604,10 +625,11 @@ fn report_arm_reachability<'p, 'tcx>(\n /// Report that a match is not exhaustive.\n fn non_exhaustive_match<'p, 'tcx>(\n     cx: &MatchCheckCtxt<'p, 'tcx>,\n+    thir: &Thir<'tcx>,\n     scrut_ty: Ty<'tcx>,\n     sp: Span,\n     witnesses: Vec<DeconstructedPat<'p, 'tcx>>,\n-    arms: &[hir::Arm<'tcx>],\n+    arms: &[ArmId],\n     expr_span: Span,\n ) {\n     let is_empty_match = arms.is_empty();\n@@ -705,6 +727,7 @@ fn non_exhaustive_match<'p, 'tcx>(\n             ));\n         }\n         [only] => {\n+            let only = &thir[*only];\n             let (pre_indentation, is_multiline) = if let Some(snippet) = sm.indentation_before(only.span)\n                 && let Ok(with_trailing) = sm.span_extend_while(only.span, |c| c.is_whitespace() || c == ',')\n                 && sm.is_multiline(with_trailing)\n@@ -713,8 +736,9 @@ fn non_exhaustive_match<'p, 'tcx>(\n             } else {\n                 (\" \".to_string(), false)\n             };\n-            let comma = if matches!(only.body.kind, hir::ExprKind::Block(..))\n-                && only.span.eq_ctxt(only.body.span)\n+            let only_body = &thir[only.body];\n+            let comma = if matches!(only_body.kind, ExprKind::Block { .. })\n+                && only.span.eq_ctxt(only_body.span)\n                 && is_multiline\n             {\n                 \"\"\n@@ -726,24 +750,29 @@ fn non_exhaustive_match<'p, 'tcx>(\n                 format!(\"{}{}{} => todo!()\", comma, pre_indentation, pattern),\n             ));\n         }\n-        [.., prev, last] if prev.span.eq_ctxt(last.span) => {\n-            let comma = if matches!(last.body.kind, hir::ExprKind::Block(..))\n-                && last.span.eq_ctxt(last.body.span)\n-            {\n-                \"\"\n-            } else {\n-                \",\"\n-            };\n-            let spacing = if sm.is_multiline(prev.span.between(last.span)) {\n-                sm.indentation_before(last.span).map(|indent| format!(\"\\n{indent}\"))\n-            } else {\n-                Some(\" \".to_string())\n-            };\n-            if let Some(spacing) = spacing {\n-                suggestion = Some((\n-                    last.span.shrink_to_hi(),\n-                    format!(\"{}{}{} => todo!()\", comma, spacing, pattern),\n-                ));\n+        [.., prev, last] => {\n+            let prev = &thir[*prev];\n+            let last = &thir[*last];\n+            if prev.span.eq_ctxt(last.span) {\n+                let last_body = &thir[last.body];\n+                let comma = if matches!(last_body.kind, ExprKind::Block { .. })\n+                    && last.span.eq_ctxt(last_body.span)\n+                {\n+                    \"\"\n+                } else {\n+                    \",\"\n+                };\n+                let spacing = if sm.is_multiline(prev.span.between(last.span)) {\n+                    sm.indentation_before(last.span).map(|indent| format!(\"\\n{indent}\"))\n+                } else {\n+                    Some(\" \".to_string())\n+                };\n+                if let Some(spacing) = spacing {\n+                    suggestion = Some((\n+                        last.span.shrink_to_hi(),\n+                        format!(\"{}{}{} => todo!()\", comma, spacing, pattern),\n+                    ));\n+                }\n             }\n         }\n         _ => {}\n@@ -863,10 +892,6 @@ fn maybe_point_at_variant<'a, 'p: 'a, 'tcx: 'a>(\n }\n \n /// Check if a by-value binding is by-value. That is, check if the binding's type is not `Copy`.\n-fn is_binding_by_move(cx: &MatchVisitor<'_, '_, '_>, hir_id: HirId) -> bool {\n-    !cx.typeck_results.node_type(hir_id).is_copy_modulo_regions(cx.tcx, cx.param_env)\n-}\n-\n /// Check that there are no borrow or move conflicts in `binding @ subpat` patterns.\n ///\n /// For example, this would reject:\n@@ -877,55 +902,46 @@ fn is_binding_by_move(cx: &MatchVisitor<'_, '_, '_>, hir_id: HirId) -> bool {\n /// - `x @ Some(ref mut? y)`.\n ///\n /// This analysis is *not* subsumed by NLL.\n-fn check_borrow_conflicts_in_at_patterns(cx: &MatchVisitor<'_, '_, '_>, pat: &Pat<'_>) {\n+fn check_borrow_conflicts_in_at_patterns<'tcx>(cx: &MatchVisitor<'_, '_, 'tcx>, pat: &Pat<'tcx>) {\n     // Extract `sub` in `binding @ sub`.\n-    let (name, sub) = match &pat.kind {\n-        hir::PatKind::Binding(.., name, Some(sub)) => (*name, sub),\n-        _ => return,\n-    };\n-    let binding_span = pat.span.with_hi(name.span.hi());\n+    let PatKind::Binding { name, mode, ty, subpattern: Some(box ref sub), .. } = pat.kind else { return };\n+\n+    let is_binding_by_move = |ty: Ty<'tcx>| !ty.is_copy_modulo_regions(cx.tcx, cx.param_env);\n \n-    let typeck_results = cx.typeck_results;\n     let sess = cx.tcx.sess;\n \n     // Get the binding move, extract the mutability if by-ref.\n-    let mut_outer = match typeck_results.extract_binding_mode(sess, pat.hir_id, pat.span) {\n-        Some(ty::BindByValue(_)) if is_binding_by_move(cx, pat.hir_id) => {\n+    let mut_outer = match mode {\n+        BindingMode::ByValue if is_binding_by_move(ty) => {\n             // We have `x @ pat` where `x` is by-move. Reject all borrows in `pat`.\n             let mut conflicts_ref = Vec::new();\n-            sub.each_binding(|_, hir_id, span, _| {\n-                match typeck_results.extract_binding_mode(sess, hir_id, span) {\n-                    Some(ty::BindByValue(_)) | None => {}\n-                    Some(ty::BindByReference(_)) => conflicts_ref.push(span),\n-                }\n+            sub.each_binding(|_, mode, _, span| match mode {\n+                BindingMode::ByValue => {}\n+                BindingMode::ByRef(_) => conflicts_ref.push(span),\n             });\n             if !conflicts_ref.is_empty() {\n                 sess.emit_err(BorrowOfMovedValue {\n-                    span: pat.span,\n-                    binding_span,\n+                    binding_span: pat.span,\n                     conflicts_ref,\n                     name,\n-                    ty: typeck_results.node_type(pat.hir_id),\n-                    suggest_borrowing: pat\n-                        .span\n-                        .contains(binding_span)\n-                        .then(|| binding_span.shrink_to_lo()),\n+                    ty,\n+                    suggest_borrowing: Some(pat.span.shrink_to_lo()),\n                 });\n             }\n             return;\n         }\n-        Some(ty::BindByValue(_)) | None => return,\n-        Some(ty::BindByReference(m)) => m,\n+        BindingMode::ByValue => return,\n+        BindingMode::ByRef(m) => m.mutability(),\n     };\n \n     // We now have `ref $mut_outer binding @ sub` (semantically).\n     // Recurse into each binding in `sub` and find mutability or move conflicts.\n     let mut conflicts_move = Vec::new();\n     let mut conflicts_mut_mut = Vec::new();\n     let mut conflicts_mut_ref = Vec::new();\n-    sub.each_binding(|_, hir_id, span, name| {\n-        match typeck_results.extract_binding_mode(sess, hir_id, span) {\n-            Some(ty::BindByReference(mut_inner)) => match (mut_outer, mut_inner) {\n+    sub.each_binding(|name, mode, ty, span| {\n+        match mode {\n+            BindingMode::ByRef(mut_inner) => match (mut_outer, mut_inner.mutability()) {\n                 // Both sides are `ref`.\n                 (Mutability::Not, Mutability::Not) => {}\n                 // 2x `ref mut`.\n@@ -939,10 +955,10 @@ fn check_borrow_conflicts_in_at_patterns(cx: &MatchVisitor<'_, '_, '_>, pat: &Pa\n                     conflicts_mut_ref.push(Conflict::Ref { span, name })\n                 }\n             },\n-            Some(ty::BindByValue(_)) if is_binding_by_move(cx, hir_id) => {\n+            BindingMode::ByValue if is_binding_by_move(ty) => {\n                 conflicts_move.push(Conflict::Moved { span, name }) // `ref mut?` + by-move conflict.\n             }\n-            Some(ty::BindByValue(_)) | None => {} // `ref mut?` + by-copy is fine.\n+            BindingMode::ByValue => {} // `ref mut?` + by-copy is fine.\n         }\n     });\n \n@@ -951,8 +967,8 @@ fn check_borrow_conflicts_in_at_patterns(cx: &MatchVisitor<'_, '_, '_>, pat: &Pa\n     let report_move_conflict = !conflicts_move.is_empty();\n \n     let mut occurences = match mut_outer {\n-        Mutability::Mut => vec![Conflict::Mut { span: binding_span, name }],\n-        Mutability::Not => vec![Conflict::Ref { span: binding_span, name }],\n+        Mutability::Mut => vec![Conflict::Mut { span: pat.span, name }],\n+        Mutability::Not => vec![Conflict::Ref { span: pat.span, name }],\n     };\n     occurences.extend(conflicts_mut_mut);\n     occurences.extend(conflicts_mut_ref);\n@@ -977,65 +993,3 @@ fn check_borrow_conflicts_in_at_patterns(cx: &MatchVisitor<'_, '_, '_>, pat: &Pa\n         sess.emit_err(MovedWhileBorrowed { span: pat.span, occurences });\n     }\n }\n-\n-#[derive(Clone, Copy, Debug)]\n-pub enum LetSource {\n-    GenericLet,\n-    IfLet,\n-    IfLetGuard,\n-    LetElse,\n-    WhileLet,\n-}\n-\n-fn let_source(tcx: TyCtxt<'_>, pat_id: HirId) -> LetSource {\n-    let hir = tcx.hir();\n-\n-    let parent = hir.parent_id(pat_id);\n-    let_source_parent(tcx, parent, Some(pat_id))\n-}\n-\n-fn let_source_parent(tcx: TyCtxt<'_>, parent: HirId, pat_id: Option<HirId>) -> LetSource {\n-    let hir = tcx.hir();\n-\n-    let parent_node = hir.get(parent);\n-\n-    match parent_node {\n-        hir::Node::Arm(hir::Arm {\n-            guard: Some(hir::Guard::IfLet(&hir::Let { pat: hir::Pat { hir_id, .. }, .. })),\n-            ..\n-        }) if Some(*hir_id) == pat_id => {\n-            return LetSource::IfLetGuard;\n-        }\n-        _ => {}\n-    }\n-\n-    let parent_parent = hir.parent_id(parent);\n-    let parent_parent_node = hir.get(parent_parent);\n-    match parent_parent_node {\n-        hir::Node::Stmt(hir::Stmt { kind: hir::StmtKind::Local(_), .. }) => {\n-            return LetSource::LetElse;\n-        }\n-        hir::Node::Arm(hir::Arm { guard: Some(hir::Guard::If(_)), .. }) => {\n-            return LetSource::IfLetGuard;\n-        }\n-        _ => {}\n-    }\n-\n-    let parent_parent_parent = hir.parent_id(parent_parent);\n-    let parent_parent_parent_parent = hir.parent_id(parent_parent_parent);\n-    let parent_parent_parent_parent_node = hir.get(parent_parent_parent_parent);\n-\n-    if let hir::Node::Expr(hir::Expr {\n-        kind: hir::ExprKind::Loop(_, _, hir::LoopSource::While, _),\n-        ..\n-    }) = parent_parent_parent_parent_node\n-    {\n-        return LetSource::WhileLet;\n-    }\n-\n-    if let hir::Node::Expr(hir::Expr { kind: hir::ExprKind::If(..), .. }) = parent_parent_node {\n-        return LetSource::IfLet;\n-    }\n-\n-    LetSource::GenericLet\n-}"}, {"sha": "32d0404bd07392077dd3f1182a6b543b82bcbda2", "filename": "compiler/rustc_mir_build/src/thir/pattern/const_to_pat.rs", "status": "modified", "additions": 12, "deletions": 21, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/6efdf4d1309f8047bc439a4810888c715e2df480/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fconst_to_pat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6efdf4d1309f8047bc439a4810888c715e2df480/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fconst_to_pat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fconst_to_pat.rs?ref=6efdf4d1309f8047bc439a4810888c715e2df480", "patch": "@@ -59,8 +59,6 @@ struct ConstToPat<'tcx> {\n     // inference context used for checking `T: Structural` bounds.\n     infcx: InferCtxt<'tcx>,\n \n-    include_lint_checks: bool,\n-\n     treat_byte_string_as_slice: bool,\n }\n \n@@ -93,7 +91,6 @@ impl<'tcx> ConstToPat<'tcx> {\n             span,\n             infcx,\n             param_env: pat_ctxt.param_env,\n-            include_lint_checks: pat_ctxt.include_lint_checks,\n             saw_const_match_error: Cell::new(false),\n             saw_const_match_lint: Cell::new(false),\n             behind_reference: Cell::new(false),\n@@ -134,7 +131,7 @@ impl<'tcx> ConstToPat<'tcx> {\n                 })\n             });\n \n-        if self.include_lint_checks && !self.saw_const_match_error.get() {\n+        if !self.saw_const_match_error.get() {\n             // If we were able to successfully convert the const to some pat,\n             // double-check that all types in the const implement `Structural`.\n \n@@ -239,21 +236,19 @@ impl<'tcx> ConstToPat<'tcx> {\n \n         let kind = match cv.ty().kind() {\n             ty::Float(_) => {\n-                if self.include_lint_checks {\n                     tcx.emit_spanned_lint(\n                         lint::builtin::ILLEGAL_FLOATING_POINT_LITERAL_PATTERN,\n                         id,\n                         span,\n                         FloatPattern,\n                     );\n-                }\n                 PatKind::Constant { value: cv }\n             }\n             ty::Adt(adt_def, _) if adt_def.is_union() => {\n                 // Matching on union fields is unsafe, we can't hide it in constants\n                 self.saw_const_match_error.set(true);\n                 let err = UnionPattern { span };\n-                tcx.sess.create_err(err).emit_unless(!self.include_lint_checks);\n+                tcx.sess.emit_err(err);\n                 PatKind::Wild\n             }\n             ty::Adt(..)\n@@ -267,7 +262,7 @@ impl<'tcx> ConstToPat<'tcx> {\n             {\n                 self.saw_const_match_error.set(true);\n                 let err = TypeNotStructural { span, non_sm_ty };\n-                tcx.sess.create_err(err).emit_unless(!self.include_lint_checks);\n+                tcx.sess.emit_err(err);\n                 PatKind::Wild\n             }\n             // If the type is not structurally comparable, just emit the constant directly,\n@@ -280,8 +275,7 @@ impl<'tcx> ConstToPat<'tcx> {\n             // Backwards compatibility hack because we can't cause hard errors on these\n             // types, so we compare them via `PartialEq::eq` at runtime.\n             ty::Adt(..) if !self.type_marked_structural(cv.ty()) && self.behind_reference.get() => {\n-                if self.include_lint_checks\n-                    && !self.saw_const_match_error.get()\n+                if !self.saw_const_match_error.get()\n                     && !self.saw_const_match_lint.get()\n                 {\n                     self.saw_const_match_lint.set(true);\n@@ -305,7 +299,7 @@ impl<'tcx> ConstToPat<'tcx> {\n                 );\n                 self.saw_const_match_error.set(true);\n                 let err = TypeNotStructural { span, non_sm_ty: cv.ty() };\n-                tcx.sess.create_err(err).emit_unless(!self.include_lint_checks);\n+                tcx.sess.emit_err(err);\n                 PatKind::Wild\n             }\n             ty::Adt(adt_def, substs) if adt_def.is_enum() => {\n@@ -339,7 +333,7 @@ impl<'tcx> ConstToPat<'tcx> {\n                 ty::Dynamic(..) => {\n                     self.saw_const_match_error.set(true);\n                     let err = InvalidPattern { span, non_sm_ty: cv.ty() };\n-                    tcx.sess.create_err(err).emit_unless(!self.include_lint_checks);\n+                    tcx.sess.emit_err(err);\n                     PatKind::Wild\n                 }\n                 // `&str` is represented as `ConstValue::Slice`, let's keep using this\n@@ -406,8 +400,7 @@ impl<'tcx> ConstToPat<'tcx> {\n                 // to figure out how to get a reference again.\n                 ty::Adt(_, _) if !self.type_marked_structural(*pointee_ty) => {\n                     if self.behind_reference.get() {\n-                        if self.include_lint_checks\n-                            && !self.saw_const_match_error.get()\n+                        if !self.saw_const_match_error.get()\n                             && !self.saw_const_match_lint.get()\n                         {\n                            self.saw_const_match_lint.set(true);\n@@ -423,7 +416,7 @@ impl<'tcx> ConstToPat<'tcx> {\n                         if !self.saw_const_match_error.get() {\n                             self.saw_const_match_error.set(true);\n                             let err = TypeNotStructural { span, non_sm_ty: *pointee_ty };\n-                            tcx.sess.create_err(err).emit_unless(!self.include_lint_checks);\n+                            tcx.sess.emit_err(err);\n                         }\n                         PatKind::Wild\n                     }\n@@ -437,7 +430,7 @@ impl<'tcx> ConstToPat<'tcx> {\n                         // (except slices, which are handled in a separate arm above).\n \n                         let err = UnsizedPattern { span, non_sm_ty: *pointee_ty };\n-                        tcx.sess.create_err(err).emit_unless(!self.include_lint_checks);\n+                        tcx.sess.emit_err(err);\n \n                         PatKind::Wild\n                     } else {\n@@ -465,8 +458,7 @@ impl<'tcx> ConstToPat<'tcx> {\n             // compilation choices change the runtime behaviour of the match.\n             // See https://github.com/rust-lang/rust/issues/70861 for examples.\n             ty::FnPtr(..) | ty::RawPtr(..) => {\n-                if self.include_lint_checks\n-                    && !self.saw_const_match_error.get()\n+                if !self.saw_const_match_error.get()\n                     && !self.saw_const_match_lint.get()\n                 {\n                     self.saw_const_match_lint.set(true);\n@@ -482,13 +474,12 @@ impl<'tcx> ConstToPat<'tcx> {\n             _ => {\n                 self.saw_const_match_error.set(true);\n                 let err = InvalidPattern { span, non_sm_ty: cv.ty() };\n-                    tcx.sess.create_err(err).emit_unless(!self.include_lint_checks);\n+                    tcx.sess.emit_err(err);\n                 PatKind::Wild\n             }\n         };\n \n-        if self.include_lint_checks\n-            && !self.saw_const_match_error.get()\n+        if !self.saw_const_match_error.get()\n             && !self.saw_const_match_lint.get()\n             && mir_structural_match_violation\n             // FIXME(#73448): Find a way to bring const qualification into parity with"}, {"sha": "7c29196447c712444bf5cff47392454bf7ae73aa", "filename": "compiler/rustc_mir_build/src/thir/pattern/deconstruct_pat.rs", "status": "modified", "additions": 21, "deletions": 18, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/6efdf4d1309f8047bc439a4810888c715e2df480/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fdeconstruct_pat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6efdf4d1309f8047bc439a4810888c715e2df480/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fdeconstruct_pat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fdeconstruct_pat.rs?ref=6efdf4d1309f8047bc439a4810888c715e2df480", "patch": "@@ -258,7 +258,7 @@ impl IntRange {\n         pcx: &PatCtxt<'_, 'p, 'tcx>,\n         pats: impl Iterator<Item = &'a DeconstructedPat<'p, 'tcx>>,\n         column_count: usize,\n-        hir_id: HirId,\n+        lint_root: HirId,\n     ) {\n         if self.is_singleton() {\n             return;\n@@ -290,7 +290,7 @@ impl IntRange {\n         if !overlap.is_empty() {\n             pcx.cx.tcx.emit_spanned_lint(\n                 lint::builtin::OVERLAPPING_RANGE_ENDPOINTS,\n-                hir_id,\n+                lint_root,\n                 pcx.span,\n                 OverlappingRangeEndpoints { overlap, range: pcx.span },\n             );\n@@ -1154,8 +1154,9 @@ impl<'p, 'tcx> Fields<'p, 'tcx> {\n     fn wildcards_from_tys(\n         cx: &MatchCheckCtxt<'p, 'tcx>,\n         tys: impl IntoIterator<Item = Ty<'tcx>>,\n+        span: Span,\n     ) -> Self {\n-        Fields::from_iter(cx, tys.into_iter().map(DeconstructedPat::wildcard))\n+        Fields::from_iter(cx, tys.into_iter().map(|ty| DeconstructedPat::wildcard(ty, span)))\n     }\n \n     // In the cases of either a `#[non_exhaustive]` field list or a non-public field, we hide\n@@ -1191,26 +1192,26 @@ impl<'p, 'tcx> Fields<'p, 'tcx> {\n     pub(super) fn wildcards(pcx: &PatCtxt<'_, 'p, 'tcx>, constructor: &Constructor<'tcx>) -> Self {\n         let ret = match constructor {\n             Single | Variant(_) => match pcx.ty.kind() {\n-                ty::Tuple(fs) => Fields::wildcards_from_tys(pcx.cx, fs.iter()),\n-                ty::Ref(_, rty, _) => Fields::wildcards_from_tys(pcx.cx, once(*rty)),\n+                ty::Tuple(fs) => Fields::wildcards_from_tys(pcx.cx, fs.iter(), pcx.span),\n+                ty::Ref(_, rty, _) => Fields::wildcards_from_tys(pcx.cx, once(*rty), pcx.span),\n                 ty::Adt(adt, substs) => {\n                     if adt.is_box() {\n                         // The only legal patterns of type `Box` (outside `std`) are `_` and box\n                         // patterns. If we're here we can assume this is a box pattern.\n-                        Fields::wildcards_from_tys(pcx.cx, once(substs.type_at(0)))\n+                        Fields::wildcards_from_tys(pcx.cx, once(substs.type_at(0)), pcx.span)\n                     } else {\n                         let variant = &adt.variant(constructor.variant_index_for_adt(*adt));\n                         let tys = Fields::list_variant_nonhidden_fields(pcx.cx, pcx.ty, variant)\n                             .map(|(_, ty)| ty);\n-                        Fields::wildcards_from_tys(pcx.cx, tys)\n+                        Fields::wildcards_from_tys(pcx.cx, tys, pcx.span)\n                     }\n                 }\n                 _ => bug!(\"Unexpected type for `Single` constructor: {:?}\", pcx),\n             },\n             Slice(slice) => match *pcx.ty.kind() {\n                 ty::Slice(ty) | ty::Array(ty, _) => {\n                     let arity = slice.arity();\n-                    Fields::wildcards_from_tys(pcx.cx, (0..arity).map(|_| ty))\n+                    Fields::wildcards_from_tys(pcx.cx, (0..arity).map(|_| ty), pcx.span)\n                 }\n                 _ => bug!(\"bad slice pattern {:?} {:?}\", constructor, pcx),\n             },\n@@ -1251,8 +1252,8 @@ pub(crate) struct DeconstructedPat<'p, 'tcx> {\n }\n \n impl<'p, 'tcx> DeconstructedPat<'p, 'tcx> {\n-    pub(super) fn wildcard(ty: Ty<'tcx>) -> Self {\n-        Self::new(Wildcard, Fields::empty(), ty, DUMMY_SP)\n+    pub(super) fn wildcard(ty: Ty<'tcx>, span: Span) -> Self {\n+        Self::new(Wildcard, Fields::empty(), ty, span)\n     }\n \n     pub(super) fn new(\n@@ -1269,7 +1270,7 @@ impl<'p, 'tcx> DeconstructedPat<'p, 'tcx> {\n     /// `Some(_)`.\n     pub(super) fn wild_from_ctor(pcx: &PatCtxt<'_, 'p, 'tcx>, ctor: Constructor<'tcx>) -> Self {\n         let fields = Fields::wildcards(pcx, &ctor);\n-        DeconstructedPat::new(ctor, fields, pcx.ty, DUMMY_SP)\n+        DeconstructedPat::new(ctor, fields, pcx.ty, pcx.span)\n     }\n \n     /// Clone this value. This method emphasizes that cloning loses reachability information and\n@@ -1298,7 +1299,7 @@ impl<'p, 'tcx> DeconstructedPat<'p, 'tcx> {\n                     ty::Tuple(fs) => {\n                         ctor = Single;\n                         let mut wilds: SmallVec<[_; 2]> =\n-                            fs.iter().map(DeconstructedPat::wildcard).collect();\n+                            fs.iter().map(|ty| DeconstructedPat::wildcard(ty, pat.span)).collect();\n                         for pat in subpatterns {\n                             wilds[pat.field.index()] = mkpat(&pat.pattern);\n                         }\n@@ -1317,11 +1318,11 @@ impl<'p, 'tcx> DeconstructedPat<'p, 'tcx> {\n                         // normally or through box-patterns. We'll have to figure out a proper\n                         // solution when we introduce generalized deref patterns. Also need to\n                         // prevent mixing of those two options.\n-                        let pat = subpatterns.into_iter().find(|pat| pat.field.index() == 0);\n-                        let pat = if let Some(pat) = pat {\n+                        let pattern = subpatterns.into_iter().find(|pat| pat.field.index() == 0);\n+                        let pat = if let Some(pat) = pattern {\n                             mkpat(&pat.pattern)\n                         } else {\n-                            DeconstructedPat::wildcard(substs.type_at(0))\n+                            DeconstructedPat::wildcard(substs.type_at(0), pat.span)\n                         };\n                         ctor = Single;\n                         fields = Fields::singleton(cx, pat);\n@@ -1343,7 +1344,7 @@ impl<'p, 'tcx> DeconstructedPat<'p, 'tcx> {\n                                 ty\n                             });\n                         let mut wilds: SmallVec<[_; 2]> =\n-                            tys.map(DeconstructedPat::wildcard).collect();\n+                            tys.map(|ty| DeconstructedPat::wildcard(ty, pat.span)).collect();\n                         for pat in subpatterns {\n                             if let Some(i) = field_id_to_id[pat.field.index()] {\n                                 wilds[i] = mkpat(&pat.pattern);\n@@ -1566,8 +1567,10 @@ impl<'p, 'tcx> DeconstructedPat<'p, 'tcx> {\n                         };\n                         let prefix = &self.fields.fields[..prefix];\n                         let suffix = &self.fields.fields[self_slice.arity() - suffix..];\n-                        let wildcard: &_ =\n-                            pcx.cx.pattern_arena.alloc(DeconstructedPat::wildcard(inner_ty));\n+                        let wildcard: &_ = pcx\n+                            .cx\n+                            .pattern_arena\n+                            .alloc(DeconstructedPat::wildcard(inner_ty, pcx.span));\n                         let extra_wildcards = other_slice.arity() - self_slice.arity();\n                         let extra_wildcards = (0..extra_wildcards).map(|_| wildcard);\n                         prefix.iter().chain(extra_wildcards).chain(suffix).collect()"}, {"sha": "70d015a39e4e2c716996c31d1f9fcfea9f565cb2", "filename": "compiler/rustc_mir_build/src/thir/pattern/mod.rs", "status": "modified", "additions": 11, "deletions": 35, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/6efdf4d1309f8047bc439a4810888c715e2df480/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6efdf4d1309f8047bc439a4810888c715e2df480/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fmod.rs?ref=6efdf4d1309f8047bc439a4810888c715e2df480", "patch": "@@ -31,20 +31,10 @@ use rustc_target::abi::FieldIdx;\n \n use std::cmp::Ordering;\n \n-#[derive(Clone, Debug)]\n-enum PatternError {\n-    AssocConstInPattern(Span),\n-    ConstParamInPattern(Span),\n-    StaticInPattern(Span),\n-    NonConstPath(Span),\n-}\n-\n struct PatCtxt<'a, 'tcx> {\n     tcx: TyCtxt<'tcx>,\n     param_env: ty::ParamEnv<'tcx>,\n     typeck_results: &'a ty::TypeckResults<'tcx>,\n-    errors: Vec<PatternError>,\n-    include_lint_checks: bool,\n }\n \n pub(super) fn pat_from_hir<'a, 'tcx>(\n@@ -53,30 +43,13 @@ pub(super) fn pat_from_hir<'a, 'tcx>(\n     typeck_results: &'a ty::TypeckResults<'tcx>,\n     pat: &'tcx hir::Pat<'tcx>,\n ) -> Box<Pat<'tcx>> {\n-    let mut pcx = PatCtxt::new(tcx, param_env, typeck_results);\n+    let mut pcx = PatCtxt { tcx, param_env, typeck_results };\n     let result = pcx.lower_pattern(pat);\n-    if !pcx.errors.is_empty() {\n-        let msg = format!(\"encountered errors lowering pattern: {:?}\", pcx.errors);\n-        tcx.sess.delay_span_bug(pat.span, &msg);\n-    }\n     debug!(\"pat_from_hir({:?}) = {:?}\", pat, result);\n     result\n }\n \n impl<'a, 'tcx> PatCtxt<'a, 'tcx> {\n-    fn new(\n-        tcx: TyCtxt<'tcx>,\n-        param_env: ty::ParamEnv<'tcx>,\n-        typeck_results: &'a ty::TypeckResults<'tcx>,\n-    ) -> Self {\n-        PatCtxt { tcx, param_env, typeck_results, errors: vec![], include_lint_checks: false }\n-    }\n-\n-    fn include_lint_checks(&mut self) -> &mut Self {\n-        self.include_lint_checks = true;\n-        self\n-    }\n-\n     fn lower_pattern(&mut self, pat: &'tcx hir::Pat<'tcx>) -> Box<Pat<'tcx>> {\n         // When implicit dereferences have been inserted in this pattern, the unadjusted lowered\n         // pattern has the type that results *after* dereferencing. For example, in this code:\n@@ -473,12 +446,15 @@ impl<'a, 'tcx> PatCtxt<'a, 'tcx> {\n             | Res::SelfTyAlias { .. }\n             | Res::SelfCtor(..) => PatKind::Leaf { subpatterns },\n             _ => {\n-                let pattern_error = match res {\n-                    Res::Def(DefKind::ConstParam, _) => PatternError::ConstParamInPattern(span),\n-                    Res::Def(DefKind::Static(_), _) => PatternError::StaticInPattern(span),\n-                    _ => PatternError::NonConstPath(span),\n+                match res {\n+                    Res::Def(DefKind::ConstParam, _) => {\n+                        self.tcx.sess.emit_err(ConstParamInPattern { span })\n+                    }\n+                    Res::Def(DefKind::Static(_), _) => {\n+                        self.tcx.sess.emit_err(StaticInPattern { span })\n+                    }\n+                    _ => self.tcx.sess.emit_err(NonConstPath { span }),\n                 };\n-                self.errors.push(pattern_error);\n                 PatKind::Wild\n             }\n         };\n@@ -531,7 +507,7 @@ impl<'a, 'tcx> PatCtxt<'a, 'tcx> {\n                 // It should be assoc consts if there's no error but we cannot resolve it.\n                 debug_assert!(is_associated_const);\n \n-                self.errors.push(PatternError::AssocConstInPattern(span));\n+                self.tcx.sess.emit_err(AssocConstInPattern { span });\n \n                 return pat_from_kind(PatKind::Wild);\n             }\n@@ -609,7 +585,7 @@ impl<'a, 'tcx> PatCtxt<'a, 'tcx> {\n         match value {\n             mir::ConstantKind::Ty(c) => match c.kind() {\n                 ConstKind::Param(_) => {\n-                    self.errors.push(PatternError::ConstParamInPattern(span));\n+                    self.tcx.sess.emit_err(ConstParamInPattern { span });\n                     return PatKind::Wild;\n                 }\n                 ConstKind::Error(_) => {"}, {"sha": "d8f66a1755b2b2c9365520b6aad3f00a01c25c92", "filename": "compiler/rustc_mir_build/src/thir/pattern/usefulness.rs", "status": "modified", "additions": 24, "deletions": 15, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/6efdf4d1309f8047bc439a4810888c715e2df480/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fusefulness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6efdf4d1309f8047bc439a4810888c715e2df480/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fusefulness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fusefulness.rs?ref=6efdf4d1309f8047bc439a4810888c715e2df480", "patch": "@@ -300,7 +300,6 @@ use rustc_arena::TypedArena;\n use rustc_data_structures::stack::ensure_sufficient_stack;\n use rustc_hir::def_id::DefId;\n use rustc_hir::HirId;\n-use rustc_hir::Node;\n use rustc_middle::ty::{self, Ty, TyCtxt};\n use rustc_session::lint::builtin::NON_EXHAUSTIVE_OMITTED_PATTERNS;\n use rustc_span::{Span, DUMMY_SP};\n@@ -319,6 +318,8 @@ pub(crate) struct MatchCheckCtxt<'p, 'tcx> {\n     pub(crate) module: DefId,\n     pub(crate) param_env: ty::ParamEnv<'tcx>,\n     pub(crate) pattern_arena: &'p TypedArena<DeconstructedPat<'p, 'tcx>>,\n+    /// Only produce `NON_EXHAUSTIVE_OMITTED_PATTERNS` lint on refutable patterns.\n+    pub(crate) refutable: bool,\n }\n \n impl<'a, 'tcx> MatchCheckCtxt<'a, 'tcx> {\n@@ -604,7 +605,7 @@ impl<'p, 'tcx> Usefulness<'p, 'tcx> {\n                     let new_patterns = if pcx.is_non_exhaustive {\n                         // Here we don't want the user to try to list all variants, we want them to add\n                         // a wildcard, so we only suggest that.\n-                        vec![DeconstructedPat::wildcard(pcx.ty)]\n+                        vec![DeconstructedPat::wildcard(pcx.ty, pcx.span)]\n                     } else {\n                         let mut split_wildcard = SplitWildcard::new(pcx);\n                         split_wildcard.split(pcx, matrix.heads().map(DeconstructedPat::ctor));\n@@ -631,7 +632,7 @@ impl<'p, 'tcx> Usefulness<'p, 'tcx> {\n                             .collect();\n \n                         if hide_variant_show_wild {\n-                            new.push(DeconstructedPat::wildcard(pcx.ty));\n+                            new.push(DeconstructedPat::wildcard(pcx.ty, pcx.span));\n                         }\n \n                         new\n@@ -734,7 +735,7 @@ impl<'p, 'tcx> Witness<'p, 'tcx> {\n             let arity = ctor.arity(pcx);\n             let pats = self.0.drain((len - arity)..).rev();\n             let fields = Fields::from_iter(pcx.cx, pats);\n-            DeconstructedPat::new(ctor.clone(), fields, pcx.ty, DUMMY_SP)\n+            DeconstructedPat::new(ctor.clone(), fields, pcx.ty, pcx.span)\n         };\n \n         self.0.push(pat);\n@@ -765,13 +766,13 @@ impl<'p, 'tcx> Witness<'p, 'tcx> {\n /// `is_under_guard` is used to inform if the pattern has a guard. If it\n /// has one it must not be inserted into the matrix. This shouldn't be\n /// relied on for soundness.\n-#[instrument(level = \"debug\", skip(cx, matrix, hir_id), ret)]\n+#[instrument(level = \"debug\", skip(cx, matrix, lint_root), ret)]\n fn is_useful<'p, 'tcx>(\n     cx: &MatchCheckCtxt<'p, 'tcx>,\n     matrix: &Matrix<'p, 'tcx>,\n     v: &PatStack<'p, 'tcx>,\n     witness_preference: ArmType,\n-    hir_id: HirId,\n+    lint_root: HirId,\n     is_under_guard: bool,\n     is_top_level: bool,\n ) -> Usefulness<'p, 'tcx> {\n@@ -804,7 +805,7 @@ fn is_useful<'p, 'tcx>(\n         for v in v.expand_or_pat() {\n             debug!(?v);\n             let usefulness = ensure_sufficient_stack(|| {\n-                is_useful(cx, &matrix, &v, witness_preference, hir_id, is_under_guard, false)\n+                is_useful(cx, &matrix, &v, witness_preference, lint_root, is_under_guard, false)\n             });\n             debug!(?usefulness);\n             ret.extend(usefulness);\n@@ -837,7 +838,7 @@ fn is_useful<'p, 'tcx>(\n                 pcx,\n                 matrix.heads(),\n                 matrix.column_count().unwrap_or(0),\n-                hir_id,\n+                lint_root,\n             )\n         }\n         // We split the head constructor of `v`.\n@@ -852,14 +853,24 @@ fn is_useful<'p, 'tcx>(\n             let spec_matrix = start_matrix.specialize_constructor(pcx, &ctor);\n             let v = v.pop_head_constructor(pcx, &ctor);\n             let usefulness = ensure_sufficient_stack(|| {\n-                is_useful(cx, &spec_matrix, &v, witness_preference, hir_id, is_under_guard, false)\n+                is_useful(\n+                    cx,\n+                    &spec_matrix,\n+                    &v,\n+                    witness_preference,\n+                    lint_root,\n+                    is_under_guard,\n+                    false,\n+                )\n             });\n             let usefulness = usefulness.apply_constructor(pcx, start_matrix, &ctor);\n \n             // When all the conditions are met we have a match with a `non_exhaustive` enum\n             // that has the potential to trigger the `non_exhaustive_omitted_patterns` lint.\n             // To understand the workings checkout `Constructor::split` and `SplitWildcard::new/into_ctors`\n             if is_non_exhaustive_and_wild\n+                // Only emit a lint on refutable patterns.\n+                && cx.refutable\n                 // We check that the match has a wildcard pattern and that wildcard is useful,\n                 // meaning there are variants that are covered by the wildcard. Without the check\n                 // for `witness_preference` the lint would trigger on `if let NonExhaustiveEnum::A = foo {}`\n@@ -868,8 +879,6 @@ fn is_useful<'p, 'tcx>(\n                     &ctor,\n                     Constructor::Missing { nonexhaustive_enum_missing_real_variants: true }\n                 )\n-                // We don't want to lint patterns which are function arguments or locals\n-                && !matches!(cx.tcx.hir().find_parent(hir_id), Some(Node::Param(_)|Node::Local(_)))\n             {\n                 let patterns = {\n                     let mut split_wildcard = SplitWildcard::new(pcx);\n@@ -896,7 +905,7 @@ fn is_useful<'p, 'tcx>(\n                 // NB: The partner lint for structs lives in `compiler/rustc_hir_analysis/src/check/pat.rs`.\n                 cx.tcx.emit_spanned_lint(\n                     NON_EXHAUSTIVE_OMITTED_PATTERNS,\n-                    hir_id,\n+                    lint_root,\n                     pcx.span,\n                     NonExhaustiveOmittedPattern {\n                         scrut_ty: pcx.ty,\n@@ -954,7 +963,7 @@ pub(crate) struct UsefulnessReport<'p, 'tcx> {\n pub(crate) fn compute_match_usefulness<'p, 'tcx>(\n     cx: &MatchCheckCtxt<'p, 'tcx>,\n     arms: &[MatchArm<'p, 'tcx>],\n-    scrut_hir_id: HirId,\n+    lint_root: HirId,\n     scrut_ty: Ty<'tcx>,\n ) -> UsefulnessReport<'p, 'tcx> {\n     let mut matrix = Matrix::empty();\n@@ -977,9 +986,9 @@ pub(crate) fn compute_match_usefulness<'p, 'tcx>(\n         })\n         .collect();\n \n-    let wild_pattern = cx.pattern_arena.alloc(DeconstructedPat::wildcard(scrut_ty));\n+    let wild_pattern = cx.pattern_arena.alloc(DeconstructedPat::wildcard(scrut_ty, DUMMY_SP));\n     let v = PatStack::from_pattern(wild_pattern);\n-    let usefulness = is_useful(cx, &matrix, &v, FakeExtraWildcard, scrut_hir_id, false, true);\n+    let usefulness = is_useful(cx, &matrix, &v, FakeExtraWildcard, lint_root, false, true);\n     let non_exhaustiveness_witnesses = match usefulness {\n         WithWitnesses(pats) => pats.into_iter().map(|w| w.single_pattern()).collect(),\n         NoWitnesses { .. } => bug!(),"}, {"sha": "ed61d6ee78b1d387c9fb5d067af001ea56e2958e", "filename": "compiler/rustc_mir_build/src/thir/print.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6efdf4d1309f8047bc439a4810888c715e2df480/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fprint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6efdf4d1309f8047bc439a4810888c715e2df480/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fprint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fprint.rs?ref=6efdf4d1309f8047bc439a4810888c715e2df480", "patch": "@@ -151,6 +151,7 @@ impl<'a, 'tcx> ThirPrinter<'a, 'tcx> {\n                 initializer,\n                 else_block,\n                 lint_level,\n+                span,\n             } => {\n                 print_indented!(self, \"kind: Let {\", depth_lvl + 1);\n                 print_indented!(\n@@ -181,6 +182,7 @@ impl<'a, 'tcx> ThirPrinter<'a, 'tcx> {\n                 }\n \n                 print_indented!(self, format!(\"lint_level: {:?}\", lint_level), depth_lvl + 2);\n+                print_indented!(self, format!(\"span: {:?}\", span), depth_lvl + 2);\n                 print_indented!(self, \"}\", depth_lvl + 1);\n             }\n         }"}, {"sha": "bd8ec82dffd17eb67514024a9c79b383949e1f22", "filename": "compiler/rustc_mir_dataflow/src/elaborate_drops.rs", "status": "modified", "additions": 12, "deletions": 8, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/6efdf4d1309f8047bc439a4810888c715e2df480/compiler%2Frustc_mir_dataflow%2Fsrc%2Felaborate_drops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6efdf4d1309f8047bc439a4810888c715e2df480/compiler%2Frustc_mir_dataflow%2Fsrc%2Felaborate_drops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_dataflow%2Fsrc%2Felaborate_drops.rs?ref=6efdf4d1309f8047bc439a4810888c715e2df480", "patch": "@@ -77,10 +77,10 @@ impl Unwind {\n         }\n     }\n \n-    fn into_option(self) -> Option<BasicBlock> {\n+    fn into_action(self) -> UnwindAction {\n         match self {\n-            Unwind::To(bb) => Some(bb),\n-            Unwind::InCleanup => None,\n+            Unwind::To(bb) => UnwindAction::Cleanup(bb),\n+            Unwind::InCleanup => UnwindAction::Terminate,\n         }\n     }\n \n@@ -236,7 +236,7 @@ where\n                     TerminatorKind::Drop {\n                         place: self.place,\n                         target: self.succ,\n-                        unwind: self.unwind.into_option(),\n+                        unwind: self.unwind.into_action(),\n                     },\n                 );\n             }\n@@ -640,7 +640,7 @@ where\n                     args: vec![Operand::Move(Place::from(ref_place))],\n                     destination: unit_temp,\n                     target: Some(succ),\n-                    cleanup: unwind.into_option(),\n+                    unwind: unwind.into_action(),\n                     from_hir_call: true,\n                     fn_span: self.source_info.span,\n                 },\n@@ -717,7 +717,7 @@ where\n             TerminatorKind::Drop {\n                 place: tcx.mk_place_deref(ptr),\n                 target: loop_block,\n-                unwind: unwind.into_option(),\n+                unwind: unwind.into_action(),\n             },\n         );\n \n@@ -946,7 +946,11 @@ where\n             args,\n             destination: unit_temp,\n             target: Some(target),\n-            cleanup: None,\n+            unwind: if unwind.is_cleanup() {\n+                UnwindAction::Terminate\n+            } else {\n+                UnwindAction::Continue\n+            },\n             from_hir_call: false,\n             fn_span: self.source_info.span,\n         }; // FIXME(#43234)\n@@ -959,7 +963,7 @@ where\n \n     fn drop_block(&mut self, target: BasicBlock, unwind: Unwind) -> BasicBlock {\n         let block =\n-            TerminatorKind::Drop { place: self.place, target, unwind: unwind.into_option() };\n+            TerminatorKind::Drop { place: self.place, target, unwind: unwind.into_action() };\n         self.new_block(unwind, block)\n     }\n "}, {"sha": "c8fe1af6674c8b33e19443865dc56718077577f3", "filename": "compiler/rustc_mir_dataflow/src/framework/direction.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/6efdf4d1309f8047bc439a4810888c715e2df480/compiler%2Frustc_mir_dataflow%2Fsrc%2Fframework%2Fdirection.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6efdf4d1309f8047bc439a4810888c715e2df480/compiler%2Frustc_mir_dataflow%2Fsrc%2Fframework%2Fdirection.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_dataflow%2Fsrc%2Fframework%2Fdirection.rs?ref=6efdf4d1309f8047bc439a4810888c715e2df480", "patch": "@@ -1,4 +1,4 @@\n-use rustc_middle::mir::{self, BasicBlock, Location, SwitchTargets};\n+use rustc_middle::mir::{self, BasicBlock, Location, SwitchTargets, UnwindAction};\n use rustc_middle::ty::TyCtxt;\n use std::ops::RangeInclusive;\n \n@@ -474,14 +474,14 @@ impl Direction for Forward {\n     {\n         use mir::TerminatorKind::*;\n         match bb_data.terminator().kind {\n-            Return | Resume | Abort | GeneratorDrop | Unreachable => {}\n+            Return | Resume | Terminate | GeneratorDrop | Unreachable => {}\n \n             Goto { target } => propagate(target, exit_state),\n \n-            Assert { target, cleanup: unwind, expected: _, msg: _, cond: _ }\n+            Assert { target, unwind, expected: _, msg: _, cond: _ }\n             | Drop { target, unwind, place: _ }\n             | FalseUnwind { real_target: target, unwind } => {\n-                if let Some(unwind) = unwind {\n+                if let UnwindAction::Cleanup(unwind) = unwind {\n                     propagate(unwind, exit_state);\n                 }\n \n@@ -503,15 +503,15 @@ impl Direction for Forward {\n             }\n \n             Call {\n-                cleanup,\n+                unwind,\n                 destination,\n                 target,\n                 func: _,\n                 args: _,\n                 from_hir_call: _,\n                 fn_span: _,\n             } => {\n-                if let Some(unwind) = cleanup {\n+                if let UnwindAction::Cleanup(unwind) = unwind {\n                     propagate(unwind, exit_state);\n                 }\n \n@@ -533,9 +533,9 @@ impl Direction for Forward {\n                 options: _,\n                 line_spans: _,\n                 destination,\n-                cleanup,\n+                unwind,\n             } => {\n-                if let Some(unwind) = cleanup {\n+                if let UnwindAction::Cleanup(unwind) = unwind {\n                     propagate(unwind, exit_state);\n                 }\n "}, {"sha": "2abdee064a687b41c4c4cfef40894f8b4690934f", "filename": "compiler/rustc_mir_dataflow/src/framework/engine.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/6efdf4d1309f8047bc439a4810888c715e2df480/compiler%2Frustc_mir_dataflow%2Fsrc%2Fframework%2Fengine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6efdf4d1309f8047bc439a4810888c715e2df480/compiler%2Frustc_mir_dataflow%2Fsrc%2Fframework%2Fengine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_dataflow%2Fsrc%2Fframework%2Fengine.rs?ref=6efdf4d1309f8047bc439a4810888c715e2df480", "patch": "@@ -15,6 +15,7 @@ use rustc_hir::def_id::DefId;\n use rustc_index::vec::{Idx, IndexVec};\n use rustc_middle::mir::{self, traversal, BasicBlock};\n use rustc_middle::mir::{create_dump_file, dump_enabled};\n+use rustc_middle::ty::print::with_no_trimmed_paths;\n use rustc_middle::ty::TyCtxt;\n use rustc_span::symbol::{sym, Symbol};\n \n@@ -285,7 +286,7 @@ where\n     if tcx.sess.opts.unstable_opts.graphviz_dark_mode {\n         render_opts.push(dot::RenderOption::DarkTheme);\n     }\n-    dot::render_opts(&graphviz, &mut buf, &render_opts)?;\n+    with_no_trimmed_paths!(dot::render_opts(&graphviz, &mut buf, &render_opts)?);\n \n     file.write_all(&buf)?;\n "}, {"sha": "c188105eae89f44e716e532773fc20a19b13b59d", "filename": "compiler/rustc_mir_dataflow/src/framework/graphviz.rs", "status": "modified", "additions": 10, "deletions": 2, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/6efdf4d1309f8047bc439a4810888c715e2df480/compiler%2Frustc_mir_dataflow%2Fsrc%2Fframework%2Fgraphviz.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6efdf4d1309f8047bc439a4810888c715e2df480/compiler%2Frustc_mir_dataflow%2Fsrc%2Fframework%2Fgraphviz.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_dataflow%2Fsrc%2Fframework%2Fgraphviz.rs?ref=6efdf4d1309f8047bc439a4810888c715e2df480", "patch": "@@ -6,6 +6,7 @@ use std::{io, ops, str};\n \n use regex::Regex;\n use rustc_graphviz as dot;\n+use rustc_index::bit_set::BitSet;\n use rustc_middle::mir::graphviz_safe_def_name;\n use rustc_middle::mir::{self, BasicBlock, Body, Location};\n \n@@ -34,14 +35,16 @@ where\n     body: &'a Body<'tcx>,\n     results: &'a Results<'tcx, A>,\n     style: OutputStyle,\n+    reachable: BitSet<BasicBlock>,\n }\n \n impl<'a, 'tcx, A> Formatter<'a, 'tcx, A>\n where\n     A: Analysis<'tcx>,\n {\n     pub fn new(body: &'a Body<'tcx>, results: &'a Results<'tcx, A>, style: OutputStyle) -> Self {\n-        Formatter { body, results, style }\n+        let reachable = mir::traversal::reachable_as_bitset(body);\n+        Formatter { body, results, style, reachable }\n     }\n }\n \n@@ -108,7 +111,12 @@ where\n     type Edge = CfgEdge;\n \n     fn nodes(&self) -> dot::Nodes<'_, Self::Node> {\n-        self.body.basic_blocks.indices().collect::<Vec<_>>().into()\n+        self.body\n+            .basic_blocks\n+            .indices()\n+            .filter(|&idx| self.reachable.contains(idx))\n+            .collect::<Vec<_>>()\n+            .into()\n     }\n \n     fn edges(&self) -> dot::Edges<'_, Self::Edge> {"}, {"sha": "60679b17d6c496dd9b8dfb95fe3270f7b2f429e5", "filename": "compiler/rustc_mir_dataflow/src/framework/tests.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6efdf4d1309f8047bc439a4810888c715e2df480/compiler%2Frustc_mir_dataflow%2Fsrc%2Fframework%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6efdf4d1309f8047bc439a4810888c715e2df480/compiler%2Frustc_mir_dataflow%2Fsrc%2Fframework%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_dataflow%2Fsrc%2Fframework%2Ftests.rs?ref=6efdf4d1309f8047bc439a4810888c715e2df480", "patch": "@@ -39,7 +39,7 @@ fn mock_body<'tcx>() -> mir::Body<'tcx> {\n             args: vec![],\n             destination: dummy_place.clone(),\n             target: Some(mir::START_BLOCK),\n-            cleanup: None,\n+            unwind: mir::UnwindAction::Continue,\n             from_hir_call: false,\n             fn_span: DUMMY_SP,\n         },\n@@ -53,7 +53,7 @@ fn mock_body<'tcx>() -> mir::Body<'tcx> {\n             args: vec![],\n             destination: dummy_place.clone(),\n             target: Some(mir::START_BLOCK),\n-            cleanup: None,\n+            unwind: mir::UnwindAction::Continue,\n             from_hir_call: false,\n             fn_span: DUMMY_SP,\n         },"}, {"sha": "92d30f254a6af2a62c06b367934f7377c173163c", "filename": "compiler/rustc_mir_dataflow/src/impls/borrowed_locals.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6efdf4d1309f8047bc439a4810888c715e2df480/compiler%2Frustc_mir_dataflow%2Fsrc%2Fimpls%2Fborrowed_locals.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6efdf4d1309f8047bc439a4810888c715e2df480/compiler%2Frustc_mir_dataflow%2Fsrc%2Fimpls%2Fborrowed_locals.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_dataflow%2Fsrc%2Fimpls%2Fborrowed_locals.rs?ref=6efdf4d1309f8047bc439a4810888c715e2df480", "patch": "@@ -125,7 +125,7 @@ where\n                 }\n             }\n \n-            TerminatorKind::Abort\n+            TerminatorKind::Terminate\n             | TerminatorKind::Assert { .. }\n             | TerminatorKind::Call { .. }\n             | TerminatorKind::FalseEdge { .. }"}, {"sha": "4a5d9d520108ec58520d760847538f1d26e7ec6e", "filename": "compiler/rustc_mir_dataflow/src/impls/storage_liveness.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6efdf4d1309f8047bc439a4810888c715e2df480/compiler%2Frustc_mir_dataflow%2Fsrc%2Fimpls%2Fstorage_liveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6efdf4d1309f8047bc439a4810888c715e2df480/compiler%2Frustc_mir_dataflow%2Fsrc%2Fimpls%2Fstorage_liveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_dataflow%2Fsrc%2Fimpls%2Fstorage_liveness.rs?ref=6efdf4d1309f8047bc439a4810888c715e2df480", "patch": "@@ -200,7 +200,7 @@ impl<'mir, 'tcx> crate::GenKillAnalysis<'tcx> for MaybeRequiresStorage<'mir, 'tc\n \n             // Nothing to do for these. Match exhaustively so this fails to compile when new\n             // variants are added.\n-            TerminatorKind::Abort\n+            TerminatorKind::Terminate\n             | TerminatorKind::Assert { .. }\n             | TerminatorKind::Drop { .. }\n             | TerminatorKind::FalseEdge { .. }\n@@ -237,7 +237,7 @@ impl<'mir, 'tcx> crate::GenKillAnalysis<'tcx> for MaybeRequiresStorage<'mir, 'tc\n             // Nothing to do for these. Match exhaustively so this fails to compile when new\n             // variants are added.\n             TerminatorKind::Yield { .. }\n-            | TerminatorKind::Abort\n+            | TerminatorKind::Terminate\n             | TerminatorKind::Assert { .. }\n             | TerminatorKind::Drop { .. }\n             | TerminatorKind::FalseEdge { .. }"}, {"sha": "64ed7a29f6f3d0aa8fe505fc6324c917b8847d0b", "filename": "compiler/rustc_mir_dataflow/src/move_paths/builder.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/6efdf4d1309f8047bc439a4810888c715e2df480/compiler%2Frustc_mir_dataflow%2Fsrc%2Fmove_paths%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6efdf4d1309f8047bc439a4810888c715e2df480/compiler%2Frustc_mir_dataflow%2Fsrc%2Fmove_paths%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_dataflow%2Fsrc%2Fmove_paths%2Fbuilder.rs?ref=6efdf4d1309f8047bc439a4810888c715e2df480", "patch": "@@ -375,7 +375,7 @@ impl<'b, 'a, 'tcx> Gatherer<'b, 'a, 'tcx> {\n             // need recording.\n             | TerminatorKind::Return\n             | TerminatorKind::Resume\n-            | TerminatorKind::Abort\n+            | TerminatorKind::Terminate\n             | TerminatorKind::GeneratorDrop\n             | TerminatorKind::Unreachable\n             | TerminatorKind::Drop { .. } => {}\n@@ -398,7 +398,7 @@ impl<'b, 'a, 'tcx> Gatherer<'b, 'a, 'tcx> {\n                 ref args,\n                 destination,\n                 target,\n-                cleanup: _,\n+                unwind: _,\n                 from_hir_call: _,\n                 fn_span: _,\n             } => {\n@@ -417,7 +417,7 @@ impl<'b, 'a, 'tcx> Gatherer<'b, 'a, 'tcx> {\n                 options: _,\n                 line_spans: _,\n                 destination: _,\n-                cleanup: _,\n+                unwind: _,\n             } => {\n                 for op in operands {\n                     match *op {"}, {"sha": "98bebc9b13bc505df2753921013d8284610cdab4", "filename": "compiler/rustc_mir_dataflow/src/value_analysis.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6efdf4d1309f8047bc439a4810888c715e2df480/compiler%2Frustc_mir_dataflow%2Fsrc%2Fvalue_analysis.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6efdf4d1309f8047bc439a4810888c715e2df480/compiler%2Frustc_mir_dataflow%2Fsrc%2Fvalue_analysis.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_dataflow%2Fsrc%2Fvalue_analysis.rs?ref=6efdf4d1309f8047bc439a4810888c715e2df480", "patch": "@@ -238,7 +238,7 @@ pub trait ValueAnalysis<'tcx> {\n             TerminatorKind::Goto { .. }\n             | TerminatorKind::SwitchInt { .. }\n             | TerminatorKind::Resume\n-            | TerminatorKind::Abort\n+            | TerminatorKind::Terminate\n             | TerminatorKind::Return\n             | TerminatorKind::Unreachable\n             | TerminatorKind::Assert { .. }"}, {"sha": "5aed89139e2fa0a60916ea4425b6af34d11faf47", "filename": "compiler/rustc_mir_transform/src/abort_unwinding_calls.rs", "status": "modified", "additions": 4, "deletions": 26, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/6efdf4d1309f8047bc439a4810888c715e2df480/compiler%2Frustc_mir_transform%2Fsrc%2Fabort_unwinding_calls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6efdf4d1309f8047bc439a4810888c715e2df480/compiler%2Frustc_mir_transform%2Fsrc%2Fabort_unwinding_calls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Fabort_unwinding_calls.rs?ref=6efdf4d1309f8047bc439a4810888c715e2df480", "patch": "@@ -34,11 +34,6 @@ impl<'tcx> MirPass<'tcx> for AbortUnwindingCalls {\n             return;\n         }\n \n-        // This pass only runs on functions which themselves cannot unwind,\n-        // forcibly changing the body of the function to structurally provide\n-        // this guarantee by aborting on an unwind. If this function can unwind,\n-        // then there's nothing to do because it already should work correctly.\n-        //\n         // Here we test for this function itself whether its ABI allows\n         // unwinding or not.\n         let body_ty = tcx.type_of(def_id).skip_binder();\n@@ -107,31 +102,14 @@ impl<'tcx> MirPass<'tcx> for AbortUnwindingCalls {\n             }\n         }\n \n-        // For call instructions which need to be terminated, we insert a\n-        // singular basic block which simply terminates, and then configure the\n-        // `cleanup` attribute for all calls we found to this basic block we\n-        // insert which means that any unwinding that happens in the functions\n-        // will force an abort of the process.\n-        if !calls_to_terminate.is_empty() {\n-            let bb = BasicBlockData {\n-                statements: Vec::new(),\n-                is_cleanup: true,\n-                terminator: Some(Terminator {\n-                    source_info: SourceInfo::outermost(body.span),\n-                    kind: TerminatorKind::Abort,\n-                }),\n-            };\n-            let abort_bb = body.basic_blocks_mut().push(bb);\n-\n-            for bb in calls_to_terminate {\n-                let cleanup = body.basic_blocks_mut()[bb].terminator_mut().unwind_mut().unwrap();\n-                *cleanup = Some(abort_bb);\n-            }\n+        for id in calls_to_terminate {\n+            let cleanup = body.basic_blocks_mut()[id].terminator_mut().unwind_mut().unwrap();\n+            *cleanup = UnwindAction::Terminate;\n         }\n \n         for id in cleanups_to_remove {\n             let cleanup = body.basic_blocks_mut()[id].terminator_mut().unwind_mut().unwrap();\n-            *cleanup = None;\n+            *cleanup = UnwindAction::Unreachable;\n         }\n \n         // We may have invalidated some `cleanup` blocks so clean those up now."}, {"sha": "e1e354efa1c4fcfaa0d605123d9665374f1376d8", "filename": "compiler/rustc_mir_transform/src/add_call_guards.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/6efdf4d1309f8047bc439a4810888c715e2df480/compiler%2Frustc_mir_transform%2Fsrc%2Fadd_call_guards.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6efdf4d1309f8047bc439a4810888c715e2df480/compiler%2Frustc_mir_transform%2Fsrc%2Fadd_call_guards.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Fadd_call_guards.rs?ref=6efdf4d1309f8047bc439a4810888c715e2df480", "patch": "@@ -50,10 +50,11 @@ impl AddCallGuards {\n         for block in body.basic_blocks_mut() {\n             match block.terminator {\n                 Some(Terminator {\n-                    kind: TerminatorKind::Call { target: Some(ref mut destination), cleanup, .. },\n+                    kind: TerminatorKind::Call { target: Some(ref mut destination), unwind, .. },\n                     source_info,\n                 }) if pred_count[*destination] > 1\n-                    && (cleanup.is_some() || self == &AllCallEdges) =>\n+                    && (matches!(unwind, UnwindAction::Cleanup(_) | UnwindAction::Terminate)\n+                        || self == &AllCallEdges) =>\n                 {\n                     // It's a critical edge, break it\n                     let call_guard = BasicBlockData {"}, {"sha": "8086a4557b70f555aaa27224cd223030ccc930a5", "filename": "compiler/rustc_mir_transform/src/check_alignment.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6efdf4d1309f8047bc439a4810888c715e2df480/compiler%2Frustc_mir_transform%2Fsrc%2Fcheck_alignment.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6efdf4d1309f8047bc439a4810888c715e2df480/compiler%2Frustc_mir_transform%2Fsrc%2Fcheck_alignment.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Fcheck_alignment.rs?ref=6efdf4d1309f8047bc439a4810888c715e2df480", "patch": "@@ -221,7 +221,7 @@ fn insert_alignment_check<'tcx>(\n                 required: Operand::Copy(alignment),\n                 found: Operand::Copy(addr),\n             },\n-            cleanup: None,\n+            unwind: UnwindAction::Terminate,\n         },\n     });\n }"}, {"sha": "d908f6b3a9b544a95239e8efe3ee1d43ed57eba0", "filename": "compiler/rustc_mir_transform/src/check_unsafety.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6efdf4d1309f8047bc439a4810888c715e2df480/compiler%2Frustc_mir_transform%2Fsrc%2Fcheck_unsafety.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6efdf4d1309f8047bc439a4810888c715e2df480/compiler%2Frustc_mir_transform%2Fsrc%2Fcheck_unsafety.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Fcheck_unsafety.rs?ref=6efdf4d1309f8047bc439a4810888c715e2df480", "patch": "@@ -57,7 +57,7 @@ impl<'tcx> Visitor<'tcx> for UnsafetyChecker<'_, 'tcx> {\n             | TerminatorKind::Assert { .. }\n             | TerminatorKind::GeneratorDrop\n             | TerminatorKind::Resume\n-            | TerminatorKind::Abort\n+            | TerminatorKind::Terminate\n             | TerminatorKind::Return\n             | TerminatorKind::Unreachable\n             | TerminatorKind::FalseEdge { .. }"}, {"sha": "79a9ac7d20c182d85b1b9727234712a9200ee300", "filename": "compiler/rustc_mir_transform/src/const_prop.rs", "status": "modified", "additions": 6, "deletions": 9, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/6efdf4d1309f8047bc439a4810888c715e2df480/compiler%2Frustc_mir_transform%2Fsrc%2Fconst_prop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6efdf4d1309f8047bc439a4810888c715e2df480/compiler%2Frustc_mir_transform%2Fsrc%2Fconst_prop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Fconst_prop.rs?ref=6efdf4d1309f8047bc439a4810888c715e2df480", "patch": "@@ -24,7 +24,7 @@ use crate::MirPass;\n use rustc_const_eval::interpret::{\n     self, compile_time_machine, AllocId, ConstAllocation, ConstValue, CtfeValidationMode, Frame,\n     ImmTy, Immediate, InterpCx, InterpResult, LocalValue, MemoryKind, OpTy, PlaceTy, Pointer,\n-    Scalar, StackPopCleanup, StackPopUnwind,\n+    Scalar, StackPopCleanup,\n };\n \n /// The maximum number of bytes that we'll allocate space for a local or the return value.\n@@ -115,10 +115,7 @@ impl<'tcx> MirPass<'tcx> for ConstProp {\n             .predicates\n             .iter()\n             .filter_map(|(p, _)| if p.is_global() { Some(*p) } else { None });\n-        if traits::impossible_predicates(\n-            tcx,\n-            traits::elaborate_predicates(tcx, predicates).collect(),\n-        ) {\n+        if traits::impossible_predicates(tcx, traits::elaborate(tcx, predicates).collect()) {\n             trace!(\"ConstProp skipped for {:?}: found unsatisfiable predicates\", def_id);\n             return;\n         }\n@@ -209,7 +206,7 @@ impl<'mir, 'tcx> interpret::Machine<'mir, 'tcx> for ConstPropMachine<'mir, 'tcx>\n         _args: &[OpTy<'tcx>],\n         _destination: &PlaceTy<'tcx>,\n         _target: Option<BasicBlock>,\n-        _unwind: StackPopUnwind,\n+        _unwind: UnwindAction,\n     ) -> InterpResult<'tcx, Option<(&'mir Body<'tcx>, ty::Instance<'tcx>)>> {\n         Ok(None)\n     }\n@@ -220,15 +217,15 @@ impl<'mir, 'tcx> interpret::Machine<'mir, 'tcx> for ConstPropMachine<'mir, 'tcx>\n         _args: &[OpTy<'tcx>],\n         _destination: &PlaceTy<'tcx>,\n         _target: Option<BasicBlock>,\n-        _unwind: StackPopUnwind,\n+        _unwind: UnwindAction,\n     ) -> InterpResult<'tcx> {\n         throw_machine_stop_str!(\"calling intrinsics isn't supported in ConstProp\")\n     }\n \n     fn assert_panic(\n         _ecx: &mut InterpCx<'mir, 'tcx, Self>,\n         _msg: &rustc_middle::mir::AssertMessage<'tcx>,\n-        _unwind: Option<rustc_middle::mir::BasicBlock>,\n+        _unwind: rustc_middle::mir::UnwindAction,\n     ) -> InterpResult<'tcx> {\n         bug!(\"panics terminators are not evaluated in ConstProp\")\n     }\n@@ -959,7 +956,7 @@ impl<'tcx> MutVisitor<'tcx> for ConstPropagator<'_, 'tcx> {\n             // None of these have Operands to const-propagate.\n             TerminatorKind::Goto { .. }\n             | TerminatorKind::Resume\n-            | TerminatorKind::Abort\n+            | TerminatorKind::Terminate\n             | TerminatorKind::Return\n             | TerminatorKind::Unreachable\n             | TerminatorKind::Drop { .. }"}, {"sha": "699fe44892b2c3814c078eb8bff0738f7e7de153", "filename": "compiler/rustc_mir_transform/src/const_prop_lint.rs", "status": "modified", "additions": 149, "deletions": 137, "changes": 286, "blob_url": "https://github.com/rust-lang/rust/blob/6efdf4d1309f8047bc439a4810888c715e2df480/compiler%2Frustc_mir_transform%2Fsrc%2Fconst_prop_lint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6efdf4d1309f8047bc439a4810888c715e2df480/compiler%2Frustc_mir_transform%2Fsrc%2Fconst_prop_lint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Fconst_prop_lint.rs?ref=6efdf4d1309f8047bc439a4810888c715e2df480", "patch": "@@ -1,15 +1,15 @@\n //! Propagates constants for early reporting of statically known\n //! assertion failures\n \n-use either::{Left, Right};\n+use either::Left;\n \n use rustc_const_eval::interpret::Immediate;\n use rustc_const_eval::interpret::{\n     self, InterpCx, InterpResult, LocalValue, MemoryKind, OpTy, Scalar, StackPopCleanup,\n };\n use rustc_hir::def::DefKind;\n use rustc_hir::HirId;\n-use rustc_index::vec::IndexSlice;\n+use rustc_index::bit_set::BitSet;\n use rustc_middle::mir::visit::Visitor;\n use rustc_middle::mir::*;\n use rustc_middle::ty::layout::{LayoutError, LayoutOf, LayoutOfHelpers, TyAndLayout};\n@@ -91,10 +91,7 @@ impl<'tcx> MirLint<'tcx> for ConstProp {\n             .predicates\n             .iter()\n             .filter_map(|(p, _)| if p.is_global() { Some(*p) } else { None });\n-        if traits::impossible_predicates(\n-            tcx,\n-            traits::elaborate_predicates(tcx, predicates).collect(),\n-        ) {\n+        if traits::impossible_predicates(tcx, traits::elaborate(tcx, predicates).collect()) {\n             trace!(\"ConstProp skipped for {:?}: found unsatisfiable predicates\", def_id);\n             return;\n         }\n@@ -130,11 +127,8 @@ struct ConstPropagator<'mir, 'tcx> {\n     ecx: InterpCx<'mir, 'tcx, ConstPropMachine<'mir, 'tcx>>,\n     tcx: TyCtxt<'tcx>,\n     param_env: ParamEnv<'tcx>,\n-    source_scopes: &'mir IndexSlice<SourceScope, SourceScopeData<'tcx>>,\n-    local_decls: &'mir IndexSlice<Local, LocalDecl<'tcx>>,\n-    // Because we have `MutVisitor` we can't obtain the `SourceInfo` from a `Location`. So we store\n-    // the last known `SourceInfo` here and just keep revisiting it.\n-    source_info: Option<SourceInfo>,\n+    worklist: Vec<BasicBlock>,\n+    visited_blocks: BitSet<BasicBlock>,\n }\n \n impl<'tcx> LayoutOfHelpers<'tcx> for ConstPropagator<'_, 'tcx> {\n@@ -213,12 +207,19 @@ impl<'mir, 'tcx> ConstPropagator<'mir, 'tcx> {\n             ecx,\n             tcx,\n             param_env,\n-            source_scopes: &dummy_body.source_scopes,\n-            local_decls: &dummy_body.local_decls,\n-            source_info: None,\n+            worklist: vec![START_BLOCK],\n+            visited_blocks: BitSet::new_empty(body.basic_blocks.len()),\n         }\n     }\n \n+    fn body(&self) -> &'mir Body<'tcx> {\n+        self.ecx.frame().body\n+    }\n+\n+    fn local_decls(&self) -> &'mir LocalDecls<'tcx> {\n+        &self.body().local_decls\n+    }\n+\n     fn get_const(&self, place: Place<'tcx>) -> Option<OpTy<'tcx>> {\n         let op = match self.ecx.eval_place_to_op(place, None) {\n             Ok(op) => {\n@@ -251,15 +252,15 @@ impl<'mir, 'tcx> ConstPropagator<'mir, 'tcx> {\n     }\n \n     fn lint_root(&self, source_info: SourceInfo) -> Option<HirId> {\n-        source_info.scope.lint_root(self.source_scopes)\n+        source_info.scope.lint_root(&self.body().source_scopes)\n     }\n \n-    fn use_ecx<F, T>(&mut self, source_info: SourceInfo, f: F) -> Option<T>\n+    fn use_ecx<F, T>(&mut self, location: Location, f: F) -> Option<T>\n     where\n         F: FnOnce(&mut Self) -> InterpResult<'tcx, T>,\n     {\n         // Overwrite the PC -- whatever the interpreter does to it does not make any sense anyway.\n-        self.ecx.frame_mut().loc = Right(source_info.span);\n+        self.ecx.frame_mut().loc = Left(location);\n         match f(self) {\n             Ok(val) => Some(val),\n             Err(error) => {\n@@ -278,51 +279,55 @@ impl<'mir, 'tcx> ConstPropagator<'mir, 'tcx> {\n     }\n \n     /// Returns the value, if any, of evaluating `c`.\n-    fn eval_constant(&mut self, c: &Constant<'tcx>, source_info: SourceInfo) -> Option<OpTy<'tcx>> {\n+    fn eval_constant(&mut self, c: &Constant<'tcx>, location: Location) -> Option<OpTy<'tcx>> {\n         // FIXME we need to revisit this for #67176\n         if c.needs_subst() {\n             return None;\n         }\n \n-        self.use_ecx(source_info, |this| this.ecx.eval_mir_constant(&c.literal, Some(c.span), None))\n+        // Normalization needed b/c const prop lint runs in\n+        // `mir_drops_elaborated_and_const_checked`, which happens before\n+        // optimized MIR. Only after optimizing the MIR can we guarantee\n+        // that the `RevealAll` pass has happened and that the body's consts\n+        // are normalized, so any call to resolve before that needs to be\n+        // manually normalized.\n+        let val = self.tcx.try_normalize_erasing_regions(self.param_env, c.literal).ok()?;\n+\n+        self.use_ecx(location, |this| this.ecx.eval_mir_constant(&val, Some(c.span), None))\n     }\n \n     /// Returns the value, if any, of evaluating `place`.\n-    fn eval_place(&mut self, place: Place<'tcx>, source_info: SourceInfo) -> Option<OpTy<'tcx>> {\n+    fn eval_place(&mut self, place: Place<'tcx>, location: Location) -> Option<OpTy<'tcx>> {\n         trace!(\"eval_place(place={:?})\", place);\n-        self.use_ecx(source_info, |this| this.ecx.eval_place_to_op(place, None))\n+        self.use_ecx(location, |this| this.ecx.eval_place_to_op(place, None))\n     }\n \n     /// Returns the value, if any, of evaluating `op`. Calls upon `eval_constant`\n     /// or `eval_place`, depending on the variant of `Operand` used.\n-    fn eval_operand(&mut self, op: &Operand<'tcx>, source_info: SourceInfo) -> Option<OpTy<'tcx>> {\n+    fn eval_operand(&mut self, op: &Operand<'tcx>, location: Location) -> Option<OpTy<'tcx>> {\n         match *op {\n-            Operand::Constant(ref c) => self.eval_constant(c, source_info),\n-            Operand::Move(place) | Operand::Copy(place) => self.eval_place(place, source_info),\n+            Operand::Constant(ref c) => self.eval_constant(c, location),\n+            Operand::Move(place) | Operand::Copy(place) => self.eval_place(place, location),\n         }\n     }\n \n     fn report_assert_as_lint(\n         &self,\n         lint: &'static lint::Lint,\n-        source_info: SourceInfo,\n+        location: Location,\n         message: &'static str,\n         panic: AssertKind<impl std::fmt::Debug>,\n     ) {\n-        if let Some(lint_root) = self.lint_root(source_info) {\n+        let source_info = self.body().source_info(location);\n+        if let Some(lint_root) = self.lint_root(*source_info) {\n             self.tcx.struct_span_lint_hir(lint, lint_root, source_info.span, message, |lint| {\n                 lint.span_label(source_info.span, format!(\"{:?}\", panic))\n             });\n         }\n     }\n \n-    fn check_unary_op(\n-        &mut self,\n-        op: UnOp,\n-        arg: &Operand<'tcx>,\n-        source_info: SourceInfo,\n-    ) -> Option<()> {\n-        if let (val, true) = self.use_ecx(source_info, |this| {\n+    fn check_unary_op(&mut self, op: UnOp, arg: &Operand<'tcx>, location: Location) -> Option<()> {\n+        if let (val, true) = self.use_ecx(location, |this| {\n             let val = this.ecx.read_immediate(&this.ecx.eval_operand(arg, None)?)?;\n             let (_res, overflow, _ty) = this.ecx.overflowing_unary_op(op, &val)?;\n             Ok((val, overflow))\n@@ -332,7 +337,7 @@ impl<'mir, 'tcx> ConstPropagator<'mir, 'tcx> {\n             assert_eq!(op, UnOp::Neg, \"Neg is the only UnOp that can overflow\");\n             self.report_assert_as_lint(\n                 lint::builtin::ARITHMETIC_OVERFLOW,\n-                source_info,\n+                location,\n                 \"this arithmetic operation will overflow\",\n                 AssertKind::OverflowNeg(val.to_const_int()),\n             );\n@@ -347,28 +352,27 @@ impl<'mir, 'tcx> ConstPropagator<'mir, 'tcx> {\n         op: BinOp,\n         left: &Operand<'tcx>,\n         right: &Operand<'tcx>,\n-        source_info: SourceInfo,\n+        location: Location,\n     ) -> Option<()> {\n-        let r = self.use_ecx(source_info, |this| {\n+        let r = self.use_ecx(location, |this| {\n             this.ecx.read_immediate(&this.ecx.eval_operand(right, None)?)\n         });\n-        let l = self.use_ecx(source_info, |this| {\n-            this.ecx.read_immediate(&this.ecx.eval_operand(left, None)?)\n-        });\n+        let l = self\n+            .use_ecx(location, |this| this.ecx.read_immediate(&this.ecx.eval_operand(left, None)?));\n         // Check for exceeding shifts *even if* we cannot evaluate the LHS.\n         if matches!(op, BinOp::Shr | BinOp::Shl) {\n             let r = r.clone()?;\n             // We need the type of the LHS. We cannot use `place_layout` as that is the type\n             // of the result, which for checked binops is not the same!\n-            let left_ty = left.ty(self.local_decls, self.tcx);\n+            let left_ty = left.ty(self.local_decls(), self.tcx);\n             let left_size = self.ecx.layout_of(left_ty).ok()?.size;\n             let right_size = r.layout.size;\n             let r_bits = r.to_scalar().to_bits(right_size).ok();\n             if r_bits.map_or(false, |b| b >= left_size.bits() as u128) {\n-                debug!(\"check_binary_op: reporting assert for {:?}\", source_info);\n+                debug!(\"check_binary_op: reporting assert for {:?}\", location);\n                 self.report_assert_as_lint(\n                     lint::builtin::ARITHMETIC_OVERFLOW,\n-                    source_info,\n+                    location,\n                     \"this arithmetic operation will overflow\",\n                     AssertKind::Overflow(\n                         op,\n@@ -390,13 +394,13 @@ impl<'mir, 'tcx> ConstPropagator<'mir, 'tcx> {\n \n         if let (Some(l), Some(r)) = (l, r) {\n             // The remaining operators are handled through `overflowing_binary_op`.\n-            if self.use_ecx(source_info, |this| {\n+            if self.use_ecx(location, |this| {\n                 let (_res, overflow, _ty) = this.ecx.overflowing_binary_op(op, &l, &r)?;\n                 Ok(overflow)\n             })? {\n                 self.report_assert_as_lint(\n                     lint::builtin::ARITHMETIC_OVERFLOW,\n-                    source_info,\n+                    location,\n                     \"this arithmetic operation will overflow\",\n                     AssertKind::Overflow(op, l.to_const_int(), r.to_const_int()),\n                 );\n@@ -406,7 +410,7 @@ impl<'mir, 'tcx> ConstPropagator<'mir, 'tcx> {\n         Some(())\n     }\n \n-    fn check_rvalue(&mut self, rvalue: &Rvalue<'tcx>, source_info: SourceInfo) -> Option<()> {\n+    fn check_rvalue(&mut self, rvalue: &Rvalue<'tcx>, location: Location) -> Option<()> {\n         // Perform any special handling for specific Rvalue types.\n         // Generally, checks here fall into one of two categories:\n         //   1. Additional checking to provide useful lints to the user\n@@ -421,11 +425,11 @@ impl<'mir, 'tcx> ConstPropagator<'mir, 'tcx> {\n             // lint.\n             Rvalue::UnaryOp(op, arg) => {\n                 trace!(\"checking UnaryOp(op = {:?}, arg = {:?})\", op, arg);\n-                self.check_unary_op(*op, arg, source_info)?;\n+                self.check_unary_op(*op, arg, location)?;\n             }\n             Rvalue::BinaryOp(op, box (left, right)) => {\n                 trace!(\"checking BinaryOp(op = {:?}, left = {:?}, right = {:?})\", op, left, right);\n-                self.check_binary_op(*op, left, right, source_info)?;\n+                self.check_binary_op(*op, left, right, location)?;\n             }\n             Rvalue::CheckedBinaryOp(op, box (left, right)) => {\n                 trace!(\n@@ -434,7 +438,7 @@ impl<'mir, 'tcx> ConstPropagator<'mir, 'tcx> {\n                     left,\n                     right\n                 );\n-                self.check_binary_op(*op, left, right, source_info)?;\n+                self.check_binary_op(*op, left, right, location)?;\n             }\n \n             // Do not try creating references (#67862)\n@@ -473,10 +477,7 @@ impl<'mir, 'tcx> ConstPropagator<'mir, 'tcx> {\n         if rvalue.needs_subst() {\n             return None;\n         }\n-        if !rvalue\n-            .ty(&self.ecx.frame().body.local_decls, *self.ecx.tcx)\n-            .is_sized(*self.ecx.tcx, self.param_env)\n-        {\n+        if !rvalue.ty(self.local_decls(), self.tcx).is_sized(self.tcx, self.param_env) {\n             // the interpreter doesn't support unsized locals (only unsized arguments),\n             // but rustc does (in a kinda broken way), so we have to skip them here\n             return None;\n@@ -485,12 +486,80 @@ impl<'mir, 'tcx> ConstPropagator<'mir, 'tcx> {\n         Some(())\n     }\n \n+    fn check_assertion(\n+        &mut self,\n+        expected: bool,\n+        msg: &AssertKind<Operand<'tcx>>,\n+        cond: &Operand<'tcx>,\n+        location: Location,\n+    ) -> Option<!> {\n+        let ref value = self.eval_operand(&cond, location)?;\n+        trace!(\"assertion on {:?} should be {:?}\", value, expected);\n+\n+        let expected = Scalar::from_bool(expected);\n+        let value_const = self.use_ecx(location, |this| this.ecx.read_scalar(&value))?;\n+\n+        if expected != value_const {\n+            // Poison all places this operand references so that further code\n+            // doesn't use the invalid value\n+            if let Some(place) = cond.place() {\n+                Self::remove_const(&mut self.ecx, place.local);\n+            }\n+\n+            enum DbgVal<T> {\n+                Val(T),\n+                Underscore,\n+            }\n+            impl<T: std::fmt::Debug> std::fmt::Debug for DbgVal<T> {\n+                fn fmt(&self, fmt: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n+                    match self {\n+                        Self::Val(val) => val.fmt(fmt),\n+                        Self::Underscore => fmt.write_str(\"_\"),\n+                    }\n+                }\n+            }\n+            let mut eval_to_int = |op| {\n+                // This can be `None` if the lhs wasn't const propagated and we just\n+                // triggered the assert on the value of the rhs.\n+                self.eval_operand(op, location)\n+                    .and_then(|op| self.ecx.read_immediate(&op).ok())\n+                    .map_or(DbgVal::Underscore, |op| DbgVal::Val(op.to_const_int()))\n+            };\n+            let msg = match msg {\n+                AssertKind::DivisionByZero(op) => AssertKind::DivisionByZero(eval_to_int(op)),\n+                AssertKind::RemainderByZero(op) => AssertKind::RemainderByZero(eval_to_int(op)),\n+                AssertKind::Overflow(bin_op @ (BinOp::Div | BinOp::Rem), op1, op2) => {\n+                    // Division overflow is *UB* in the MIR, and different than the\n+                    // other overflow checks.\n+                    AssertKind::Overflow(*bin_op, eval_to_int(op1), eval_to_int(op2))\n+                }\n+                AssertKind::BoundsCheck { ref len, ref index } => {\n+                    let len = eval_to_int(len);\n+                    let index = eval_to_int(index);\n+                    AssertKind::BoundsCheck { len, index }\n+                }\n+                // Remaining overflow errors are already covered by checks on the binary operators.\n+                AssertKind::Overflow(..) | AssertKind::OverflowNeg(_) => return None,\n+                // Need proper const propagator for these.\n+                _ => return None,\n+            };\n+            self.report_assert_as_lint(\n+                lint::builtin::UNCONDITIONAL_PANIC,\n+                location,\n+                \"this operation will panic at runtime\",\n+                msg,\n+            );\n+        }\n+\n+        None\n+    }\n+\n     fn ensure_not_propagated(&self, local: Local) {\n         if cfg!(debug_assertions) {\n             assert!(\n                 self.get_const(local.into()).is_none()\n                     || self\n-                        .layout_of(self.local_decls[local].ty)\n+                        .layout_of(self.local_decls()[local].ty)\n                         .map_or(true, |layout| layout.is_zst()),\n                 \"failed to remove values for `{local:?}`, value={:?}\",\n                 self.get_const(local.into()),\n@@ -501,7 +570,12 @@ impl<'mir, 'tcx> ConstPropagator<'mir, 'tcx> {\n \n impl<'tcx> Visitor<'tcx> for ConstPropagator<'_, 'tcx> {\n     fn visit_body(&mut self, body: &Body<'tcx>) {\n-        for (bb, data) in body.basic_blocks.iter_enumerated() {\n+        while let Some(bb) = self.worklist.pop() {\n+            if !self.visited_blocks.insert(bb) {\n+                continue;\n+            }\n+\n+            let data = &body.basic_blocks[bb];\n             self.visit_basic_block_data(bb, data);\n         }\n     }\n@@ -513,22 +587,21 @@ impl<'tcx> Visitor<'tcx> for ConstPropagator<'_, 'tcx> {\n     fn visit_constant(&mut self, constant: &Constant<'tcx>, location: Location) {\n         trace!(\"visit_constant: {:?}\", constant);\n         self.super_constant(constant, location);\n-        self.eval_constant(constant, self.source_info.unwrap());\n+        self.eval_constant(constant, location);\n     }\n \n     fn visit_assign(&mut self, place: &Place<'tcx>, rvalue: &Rvalue<'tcx>, location: Location) {\n         self.super_assign(place, rvalue, location);\n \n-        let source_info = self.source_info.unwrap();\n-        let Some(()) = self.check_rvalue(rvalue, source_info) else { return };\n+        let Some(()) = self.check_rvalue(rvalue, location) else { return };\n \n         match self.ecx.machine.can_const_prop[place.local] {\n             // Do nothing if the place is indirect.\n             _ if place.is_indirect() => {}\n             ConstPropMode::NoPropagation => self.ensure_not_propagated(place.local),\n             ConstPropMode::OnlyInsideOwnBlock | ConstPropMode::FullConstProp => {\n                 if self\n-                    .use_ecx(source_info, |this| this.ecx.eval_rvalue_into_place(rvalue, *place))\n+                    .use_ecx(location, |this| this.ecx.eval_rvalue_into_place(rvalue, *place))\n                     .is_none()\n                 {\n                     // Const prop failed, so erase the destination, ensuring that whatever happens\n@@ -554,8 +627,6 @@ impl<'tcx> Visitor<'tcx> for ConstPropagator<'_, 'tcx> {\n \n     fn visit_statement(&mut self, statement: &Statement<'tcx>, location: Location) {\n         trace!(\"visit_statement: {:?}\", statement);\n-        let source_info = statement.source_info;\n-        self.source_info = Some(source_info);\n \n         // We want to evaluate operands before any change to the assigned-to value,\n         // so we recurse first.\n@@ -568,8 +639,7 @@ impl<'tcx> Visitor<'tcx> for ConstPropagator<'_, 'tcx> {\n                     _ if place.is_indirect() => {}\n                     ConstPropMode::NoPropagation => self.ensure_not_propagated(place.local),\n                     ConstPropMode::FullConstProp | ConstPropMode::OnlyInsideOwnBlock => {\n-                        if self.use_ecx(source_info, |this| this.ecx.statement(statement)).is_some()\n-                        {\n+                        if self.use_ecx(location, |this| this.ecx.statement(statement)).is_some() {\n                             trace!(\"propped discriminant into {:?}\", place);\n                         } else {\n                             Self::remove_const(&mut self.ecx, place.local);\n@@ -591,99 +661,41 @@ impl<'tcx> Visitor<'tcx> for ConstPropagator<'_, 'tcx> {\n     }\n \n     fn visit_terminator(&mut self, terminator: &Terminator<'tcx>, location: Location) {\n-        let source_info = terminator.source_info;\n-        self.source_info = Some(source_info);\n         self.super_terminator(terminator, location);\n         match &terminator.kind {\n             TerminatorKind::Assert { expected, ref msg, ref cond, .. } => {\n-                if let Some(ref value) = self.eval_operand(&cond, source_info) {\n-                    trace!(\"assertion on {:?} should be {:?}\", value, expected);\n-                    let expected = Scalar::from_bool(*expected);\n-                    let Ok(value_const) = self.ecx.read_scalar(&value) else {\n-                        // FIXME should be used use_ecx rather than a local match... but we have\n-                        // quite a few of these read_scalar/read_immediate that need fixing.\n-                        return\n-                    };\n-                    if expected != value_const {\n-                        enum DbgVal<T> {\n-                            Val(T),\n-                            Underscore,\n-                        }\n-                        impl<T: std::fmt::Debug> std::fmt::Debug for DbgVal<T> {\n-                            fn fmt(&self, fmt: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n-                                match self {\n-                                    Self::Val(val) => val.fmt(fmt),\n-                                    Self::Underscore => fmt.write_str(\"_\"),\n-                                }\n-                            }\n-                        }\n-                        let mut eval_to_int = |op| {\n-                            // This can be `None` if the lhs wasn't const propagated and we just\n-                            // triggered the assert on the value of the rhs.\n-                            self.eval_operand(op, source_info)\n-                                .and_then(|op| self.ecx.read_immediate(&op).ok())\n-                                .map_or(DbgVal::Underscore, |op| DbgVal::Val(op.to_const_int()))\n-                        };\n-                        let msg = match msg {\n-                            AssertKind::DivisionByZero(op) => {\n-                                Some(AssertKind::DivisionByZero(eval_to_int(op)))\n-                            }\n-                            AssertKind::RemainderByZero(op) => {\n-                                Some(AssertKind::RemainderByZero(eval_to_int(op)))\n-                            }\n-                            AssertKind::Overflow(bin_op @ (BinOp::Div | BinOp::Rem), op1, op2) => {\n-                                // Division overflow is *UB* in the MIR, and different than the\n-                                // other overflow checks.\n-                                Some(AssertKind::Overflow(\n-                                    *bin_op,\n-                                    eval_to_int(op1),\n-                                    eval_to_int(op2),\n-                                ))\n-                            }\n-                            AssertKind::BoundsCheck { ref len, ref index } => {\n-                                let len = eval_to_int(len);\n-                                let index = eval_to_int(index);\n-                                Some(AssertKind::BoundsCheck { len, index })\n-                            }\n-                            // Remaining overflow errors are already covered by checks on the binary operators.\n-                            AssertKind::Overflow(..) | AssertKind::OverflowNeg(_) => None,\n-                            // Need proper const propagator for these.\n-                            _ => None,\n-                        };\n-                        // Poison all places this operand references so that further code\n-                        // doesn't use the invalid value\n-                        match cond {\n-                            Operand::Move(ref place) | Operand::Copy(ref place) => {\n-                                Self::remove_const(&mut self.ecx, place.local);\n-                            }\n-                            Operand::Constant(_) => {}\n-                        }\n-                        if let Some(msg) = msg {\n-                            self.report_assert_as_lint(\n-                                lint::builtin::UNCONDITIONAL_PANIC,\n-                                source_info,\n-                                \"this operation will panic at runtime\",\n-                                msg,\n-                            );\n-                        }\n-                    }\n+                self.check_assertion(*expected, msg, cond, location);\n+            }\n+            TerminatorKind::SwitchInt { ref discr, ref targets } => {\n+                if let Some(ref value) = self.eval_operand(&discr, location)\n+                  && let Some(value_const) = self.use_ecx(location, |this| this.ecx.read_scalar(&value))\n+                  && let Ok(constant) = value_const.try_to_int()\n+                  && let Ok(constant) = constant.to_bits(constant.size())\n+                {\n+                    // We managed to evaluate the discriminant, so we know we only need to visit\n+                    // one target.\n+                    let target = targets.target_for_value(constant);\n+                    self.worklist.push(target);\n+                    return;\n                 }\n+                // We failed to evaluate the discriminant, fallback to visiting all successors.\n             }\n             // None of these have Operands to const-propagate.\n             TerminatorKind::Goto { .. }\n             | TerminatorKind::Resume\n-            | TerminatorKind::Abort\n+            | TerminatorKind::Terminate\n             | TerminatorKind::Return\n             | TerminatorKind::Unreachable\n             | TerminatorKind::Drop { .. }\n             | TerminatorKind::Yield { .. }\n             | TerminatorKind::GeneratorDrop\n             | TerminatorKind::FalseEdge { .. }\n             | TerminatorKind::FalseUnwind { .. }\n-            | TerminatorKind::SwitchInt { .. }\n             | TerminatorKind::Call { .. }\n             | TerminatorKind::InlineAsm { .. } => {}\n         }\n+\n+        self.worklist.extend(terminator.successors());\n     }\n \n     fn visit_basic_block_data(&mut self, block: BasicBlock, data: &BasicBlockData<'tcx>) {"}, {"sha": "725883b83fa92d91b4f8fb83d4700b2cd754c0a1", "filename": "compiler/rustc_mir_transform/src/coverage/debug.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6efdf4d1309f8047bc439a4810888c715e2df480/compiler%2Frustc_mir_transform%2Fsrc%2Fcoverage%2Fdebug.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6efdf4d1309f8047bc439a4810888c715e2df480/compiler%2Frustc_mir_transform%2Fsrc%2Fcoverage%2Fdebug.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Fcoverage%2Fdebug.rs?ref=6efdf4d1309f8047bc439a4810888c715e2df480", "patch": "@@ -818,7 +818,7 @@ pub(super) fn term_type(kind: &TerminatorKind<'_>) -> &'static str {\n         TerminatorKind::Goto { .. } => \"Goto\",\n         TerminatorKind::SwitchInt { .. } => \"SwitchInt\",\n         TerminatorKind::Resume => \"Resume\",\n-        TerminatorKind::Abort => \"Abort\",\n+        TerminatorKind::Terminate => \"Terminate\",\n         TerminatorKind::Return => \"Return\",\n         TerminatorKind::Unreachable => \"Unreachable\",\n         TerminatorKind::Drop { .. } => \"Drop\","}, {"sha": "7391a77b0a66b614fc405caebe2f5ccf861912d0", "filename": "compiler/rustc_mir_transform/src/coverage/graph.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/6efdf4d1309f8047bc439a4810888c715e2df480/compiler%2Frustc_mir_transform%2Fsrc%2Fcoverage%2Fgraph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6efdf4d1309f8047bc439a4810888c715e2df480/compiler%2Frustc_mir_transform%2Fsrc%2Fcoverage%2Fgraph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Fcoverage%2Fgraph.rs?ref=6efdf4d1309f8047bc439a4810888c715e2df480", "patch": "@@ -37,8 +37,7 @@ impl CoverageGraph {\n         // `SwitchInt` to have multiple targets to the same destination `BasicBlock`, so\n         // de-duplication is required. This is done without reordering the successors.\n \n-        let bcbs_len = bcbs.len();\n-        let mut seen = IndexVec::from_elem_n(false, bcbs_len);\n+        let mut seen = IndexVec::from_elem(false, &bcbs);\n         let successors = IndexVec::from_fn_n(\n             |bcb| {\n                 for b in seen.iter_mut() {\n@@ -60,7 +59,7 @@ impl CoverageGraph {\n             bcbs.len(),\n         );\n \n-        let mut predecessors = IndexVec::from_elem_n(Vec::new(), bcbs.len());\n+        let mut predecessors = IndexVec::from_elem(Vec::new(), &bcbs);\n         for (bcb, bcb_successors) in successors.iter_enumerated() {\n             for &successor in bcb_successors {\n                 predecessors[successor].push(bcb);\n@@ -123,7 +122,7 @@ impl CoverageGraph {\n \n             match term.kind {\n                 TerminatorKind::Return { .. }\n-                | TerminatorKind::Abort\n+                | TerminatorKind::Terminate\n                 | TerminatorKind::Yield { .. }\n                 | TerminatorKind::SwitchInt { .. } => {\n                     // The `bb` has more than one _outgoing_ edge, or exits the function. Save the\n@@ -137,7 +136,7 @@ impl CoverageGraph {\n                     debug!(\"  because term.kind = {:?}\", term.kind);\n                     // Note that this condition is based on `TerminatorKind`, even though it\n                     // theoretically boils down to `successors().len() != 1`; that is, either zero\n-                    // (e.g., `Return`, `Abort`) or multiple successors (e.g., `SwitchInt`), but\n+                    // (e.g., `Return`, `Terminate`) or multiple successors (e.g., `SwitchInt`), but\n                     // since the BCB CFG ignores things like unwind branches (which exist in the\n                     // `Terminator`s `successors()` list) checking the number of successors won't\n                     // work."}, {"sha": "287ae2170875f347370931f387dc442a6d3fd59a", "filename": "compiler/rustc_mir_transform/src/coverage/spans.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6efdf4d1309f8047bc439a4810888c715e2df480/compiler%2Frustc_mir_transform%2Fsrc%2Fcoverage%2Fspans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6efdf4d1309f8047bc439a4810888c715e2df480/compiler%2Frustc_mir_transform%2Fsrc%2Fcoverage%2Fspans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Fcoverage%2Fspans.rs?ref=6efdf4d1309f8047bc439a4810888c715e2df480", "patch": "@@ -869,7 +869,7 @@ pub(super) fn filtered_terminator_span(terminator: &Terminator<'_>) -> Option<Sp\n \n         // Retain spans from all other terminators\n         TerminatorKind::Resume\n-        | TerminatorKind::Abort\n+        | TerminatorKind::Terminate\n         | TerminatorKind::Return\n         | TerminatorKind::Yield { .. }\n         | TerminatorKind::GeneratorDrop"}, {"sha": "0f6c06e370ba4e6e9b50f15af3487f6439630506", "filename": "compiler/rustc_mir_transform/src/coverage/tests.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6efdf4d1309f8047bc439a4810888c715e2df480/compiler%2Frustc_mir_transform%2Fsrc%2Fcoverage%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6efdf4d1309f8047bc439a4810888c715e2df480/compiler%2Frustc_mir_transform%2Fsrc%2Fcoverage%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Fcoverage%2Ftests.rs?ref=6efdf4d1309f8047bc439a4810888c715e2df480", "patch": "@@ -140,7 +140,7 @@ impl<'tcx> MockBlocks<'tcx> {\n                 args: vec![],\n                 destination: self.dummy_place.clone(),\n                 target: Some(TEMP_BLOCK),\n-                cleanup: None,\n+                unwind: UnwindAction::Continue,\n                 from_hir_call: false,\n                 fn_span: DUMMY_SP,\n             },"}, {"sha": "d4db7e2de4039bba697128bef9fa3394e0376af2", "filename": "compiler/rustc_mir_transform/src/dataflow_const_prop.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/6efdf4d1309f8047bc439a4810888c715e2df480/compiler%2Frustc_mir_transform%2Fsrc%2Fdataflow_const_prop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6efdf4d1309f8047bc439a4810888c715e2df480/compiler%2Frustc_mir_transform%2Fsrc%2Fdataflow_const_prop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Fdataflow_const_prop.rs?ref=6efdf4d1309f8047bc439a4810888c715e2df480", "patch": "@@ -567,7 +567,7 @@ impl<'mir, 'tcx> rustc_const_eval::interpret::Machine<'mir, 'tcx> for DummyMachi\n         _args: &[rustc_const_eval::interpret::OpTy<'tcx, Self::Provenance>],\n         _destination: &rustc_const_eval::interpret::PlaceTy<'tcx, Self::Provenance>,\n         _target: Option<BasicBlock>,\n-        _unwind: rustc_const_eval::interpret::StackPopUnwind,\n+        _unwind: UnwindAction,\n     ) -> interpret::InterpResult<'tcx, Option<(&'mir Body<'tcx>, ty::Instance<'tcx>)>> {\n         unimplemented!()\n     }\n@@ -578,15 +578,15 @@ impl<'mir, 'tcx> rustc_const_eval::interpret::Machine<'mir, 'tcx> for DummyMachi\n         _args: &[rustc_const_eval::interpret::OpTy<'tcx, Self::Provenance>],\n         _destination: &rustc_const_eval::interpret::PlaceTy<'tcx, Self::Provenance>,\n         _target: Option<BasicBlock>,\n-        _unwind: rustc_const_eval::interpret::StackPopUnwind,\n+        _unwind: UnwindAction,\n     ) -> interpret::InterpResult<'tcx> {\n         unimplemented!()\n     }\n \n     fn assert_panic(\n         _ecx: &mut InterpCx<'mir, 'tcx, Self>,\n         _msg: &rustc_middle::mir::AssertMessage<'tcx>,\n-        _unwind: Option<BasicBlock>,\n+        _unwind: UnwindAction,\n     ) -> interpret::InterpResult<'tcx> {\n         unimplemented!()\n     }"}, {"sha": "811935aa9908282627deb2d264a3e16e31680f07", "filename": "compiler/rustc_mir_transform/src/dest_prop.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6efdf4d1309f8047bc439a4810888c715e2df480/compiler%2Frustc_mir_transform%2Fsrc%2Fdest_prop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6efdf4d1309f8047bc439a4810888c715e2df480/compiler%2Frustc_mir_transform%2Fsrc%2Fdest_prop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Fdest_prop.rs?ref=6efdf4d1309f8047bc439a4810888c715e2df480", "patch": "@@ -645,8 +645,8 @@ impl WriteInfo {\n                 }\n             }\n             TerminatorKind::Goto { .. }\n-            | TerminatorKind::Resume { .. }\n-            | TerminatorKind::Abort { .. }\n+            | TerminatorKind::Resume\n+            | TerminatorKind::Terminate\n             | TerminatorKind::Return\n             | TerminatorKind::Unreachable { .. } => (),\n             TerminatorKind::Drop { .. } => {"}, {"sha": "a702113bd9998cce8bbcbf2a2ea9e69d58921ad9", "filename": "compiler/rustc_mir_transform/src/elaborate_drops.rs", "status": "modified", "additions": 35, "deletions": 17, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/6efdf4d1309f8047bc439a4810888c715e2df480/compiler%2Frustc_mir_transform%2Fsrc%2Felaborate_drops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6efdf4d1309f8047bc439a4810888c715e2df480/compiler%2Frustc_mir_transform%2Fsrc%2Felaborate_drops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Felaborate_drops.rs?ref=6efdf4d1309f8047bc439a4810888c715e2df480", "patch": "@@ -120,7 +120,7 @@ fn remove_dead_unwinds<'tcx>(\n         .into_results_cursor(body);\n     for (bb, bb_data) in body.basic_blocks.iter_enumerated() {\n         let place = match bb_data.terminator().kind {\n-            TerminatorKind::Drop { ref place, unwind: Some(_), .. } => {\n+            TerminatorKind::Drop { ref place, unwind: UnwindAction::Cleanup(_), .. } => {\n                 und.derefer(place.as_ref(), body).unwrap_or(*place)\n             }\n             _ => continue,\n@@ -160,7 +160,7 @@ fn remove_dead_unwinds<'tcx>(\n     let basic_blocks = body.basic_blocks.as_mut();\n     for &bb in dead_unwinds.iter() {\n         if let Some(unwind) = basic_blocks[bb].terminator_mut().unwind_mut() {\n-            *unwind = None;\n+            *unwind = UnwindAction::Unreachable;\n         }\n     }\n }\n@@ -399,7 +399,6 @@ impl<'b, 'tcx> ElaborateDropsCtxt<'b, 'tcx> {\n             let loc = Location { block: bb, statement_index: data.statements.len() };\n             let terminator = data.terminator();\n \n-            let resume_block = self.patch.resume_block();\n             match terminator.kind {\n                 TerminatorKind::Drop { mut place, target, unwind } => {\n                     if let Some(new_place) = self.un_derefer.derefer(place.as_ref(), self.body) {\n@@ -408,19 +407,31 @@ impl<'b, 'tcx> ElaborateDropsCtxt<'b, 'tcx> {\n \n                     self.init_data.seek_before(loc);\n                     match self.move_data().rev_lookup.find(place.as_ref()) {\n-                        LookupResult::Exact(path) => elaborate_drop(\n-                            &mut Elaborator { ctxt: self },\n-                            terminator.source_info,\n-                            place,\n-                            path,\n-                            target,\n-                            if data.is_cleanup {\n+                        LookupResult::Exact(path) => {\n+                            let unwind = if data.is_cleanup {\n                                 Unwind::InCleanup\n                             } else {\n-                                Unwind::To(Option::unwrap_or(unwind, resume_block))\n-                            },\n-                            bb,\n-                        ),\n+                                match unwind {\n+                                    UnwindAction::Cleanup(cleanup) => Unwind::To(cleanup),\n+                                    UnwindAction::Continue => Unwind::To(self.patch.resume_block()),\n+                                    UnwindAction::Unreachable => {\n+                                        Unwind::To(self.patch.unreachable_cleanup_block())\n+                                    }\n+                                    UnwindAction::Terminate => {\n+                                        Unwind::To(self.patch.terminate_block())\n+                                    }\n+                                }\n+                            };\n+                            elaborate_drop(\n+                                &mut Elaborator { ctxt: self },\n+                                terminator.source_info,\n+                                place,\n+                                path,\n+                                target,\n+                                unwind,\n+                                bb,\n+                            )\n+                        }\n                         LookupResult::Parent(..) => {\n                             if !matches!(\n                                 terminator.source_info.span.desugaring_kind(),\n@@ -474,7 +485,10 @@ impl<'b, 'tcx> ElaborateDropsCtxt<'b, 'tcx> {\n                 continue;\n             }\n             if let TerminatorKind::Call {\n-                destination, target: Some(tgt), cleanup: Some(_), ..\n+                destination,\n+                target: Some(tgt),\n+                unwind: UnwindAction::Cleanup(_),\n+                ..\n             } = data.terminator().kind\n             {\n                 assert!(!self.patch.is_patched(bb));\n@@ -543,8 +557,12 @@ impl<'b, 'tcx> ElaborateDropsCtxt<'b, 'tcx> {\n             // There may be a critical edge after this call,\n             // so mark the return as initialized *before* the\n             // call.\n-            if let TerminatorKind::Call { destination, target: Some(_), cleanup: None, .. } =\n-                data.terminator().kind\n+            if let TerminatorKind::Call {\n+                destination,\n+                target: Some(_),\n+                unwind: UnwindAction::Continue | UnwindAction::Unreachable | UnwindAction::Terminate,\n+                ..\n+            } = data.terminator().kind\n             {\n                 assert!(!self.patch.is_patched(bb));\n "}, {"sha": "8601c1b2d71a11366b73fa12298673c513635a4e", "filename": "compiler/rustc_mir_transform/src/function_item_references.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6efdf4d1309f8047bc439a4810888c715e2df480/compiler%2Frustc_mir_transform%2Fsrc%2Ffunction_item_references.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6efdf4d1309f8047bc439a4810888c715e2df480/compiler%2Frustc_mir_transform%2Fsrc%2Ffunction_item_references.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Ffunction_item_references.rs?ref=6efdf4d1309f8047bc439a4810888c715e2df480", "patch": "@@ -34,7 +34,7 @@ impl<'tcx> Visitor<'tcx> for FunctionItemRefChecker<'_, 'tcx> {\n             args,\n             destination: _,\n             target: _,\n-            cleanup: _,\n+            unwind: _,\n             from_hir_call: _,\n             fn_span: _,\n         } = &terminator.kind"}, {"sha": "159780319ba5b505e80ab9b748ad80dee59759a8", "filename": "compiler/rustc_mir_transform/src/generator.rs", "status": "modified", "additions": 18, "deletions": 10, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/6efdf4d1309f8047bc439a4810888c715e2df480/compiler%2Frustc_mir_transform%2Fsrc%2Fgenerator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6efdf4d1309f8047bc439a4810888c715e2df480/compiler%2Frustc_mir_transform%2Fsrc%2Fgenerator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Fgenerator.rs?ref=6efdf4d1309f8047bc439a4810888c715e2df480", "patch": "@@ -287,7 +287,7 @@ impl<'tcx> TransformVisitor<'tcx> {\n         statements.push(Statement {\n             kind: StatementKind::Assign(Box::new((\n                 Place::return_place(),\n-                Rvalue::Aggregate(Box::new(kind), IndexVec::from_iter([val])),\n+                Rvalue::Aggregate(Box::new(kind), [val].into()),\n             ))),\n             source_info,\n         });\n@@ -1060,7 +1060,12 @@ fn elaborate_generator_drops<'tcx>(tcx: TyCtxt<'tcx>, body: &mut Body<'tcx>) {\n         let unwind = if block_data.is_cleanup {\n             Unwind::InCleanup\n         } else {\n-            Unwind::To(unwind.unwrap_or_else(|| elaborator.patch.resume_block()))\n+            Unwind::To(match *unwind {\n+                UnwindAction::Cleanup(tgt) => tgt,\n+                UnwindAction::Continue => elaborator.patch.resume_block(),\n+                UnwindAction::Unreachable => elaborator.patch.unreachable_cleanup_block(),\n+                UnwindAction::Terminate => elaborator.patch.terminate_block(),\n+            })\n         };\n         elaborate_drop(\n             &mut elaborator,\n@@ -1147,7 +1152,7 @@ fn insert_panic_block<'tcx>(\n         expected: true,\n         msg: message,\n         target: assert_block,\n-        cleanup: None,\n+        unwind: UnwindAction::Continue,\n     };\n \n     let source_info = SourceInfo::outermost(body.span);\n@@ -1189,7 +1194,7 @@ fn can_unwind<'tcx>(tcx: TyCtxt<'tcx>, body: &Body<'tcx>) -> bool {\n             // These never unwind.\n             TerminatorKind::Goto { .. }\n             | TerminatorKind::SwitchInt { .. }\n-            | TerminatorKind::Abort\n+            | TerminatorKind::Terminate\n             | TerminatorKind::Return\n             | TerminatorKind::Unreachable\n             | TerminatorKind::GeneratorDrop\n@@ -1248,8 +1253,8 @@ fn create_generator_resume_function<'tcx>(\n             } else if !block.is_cleanup {\n                 // Any terminators that *can* unwind but don't have an unwind target set are also\n                 // pointed at our poisoning block (unless they're part of the cleanup path).\n-                if let Some(unwind @ None) = block.terminator_mut().unwind_mut() {\n-                    *unwind = Some(poison_block);\n+                if let Some(unwind @ UnwindAction::Continue) = block.terminator_mut().unwind_mut() {\n+                    *unwind = UnwindAction::Cleanup(poison_block);\n                 }\n             }\n         }\n@@ -1294,8 +1299,11 @@ fn create_generator_resume_function<'tcx>(\n fn insert_clean_drop(body: &mut Body<'_>) -> BasicBlock {\n     let return_block = insert_term_block(body, TerminatorKind::Return);\n \n-    let term =\n-        TerminatorKind::Drop { place: Place::from(SELF_ARG), target: return_block, unwind: None };\n+    let term = TerminatorKind::Drop {\n+        place: Place::from(SELF_ARG),\n+        target: return_block,\n+        unwind: UnwindAction::Continue,\n+    };\n     let source_info = SourceInfo::outermost(body.span);\n \n     // Create a block to destroy an unresumed generators. This can only destroy upvars.\n@@ -1670,7 +1678,7 @@ impl<'tcx> Visitor<'tcx> for EnsureGeneratorFieldAssignmentsNeverAlias<'_> {\n                 args,\n                 destination,\n                 target: Some(_),\n-                cleanup: _,\n+                unwind: _,\n                 from_hir_call: _,\n                 fn_span: _,\n             } => {\n@@ -1693,7 +1701,7 @@ impl<'tcx> Visitor<'tcx> for EnsureGeneratorFieldAssignmentsNeverAlias<'_> {\n             | TerminatorKind::Goto { .. }\n             | TerminatorKind::SwitchInt { .. }\n             | TerminatorKind::Resume\n-            | TerminatorKind::Abort\n+            | TerminatorKind::Terminate\n             | TerminatorKind::Return\n             | TerminatorKind::Unreachable\n             | TerminatorKind::Drop { .. }"}, {"sha": "f0cb317f449f352666d3930ffd14f26fec19d851", "filename": "compiler/rustc_mir_transform/src/inline.rs", "status": "modified", "additions": 33, "deletions": 27, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/6efdf4d1309f8047bc439a4810888c715e2df480/compiler%2Frustc_mir_transform%2Fsrc%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6efdf4d1309f8047bc439a4810888c715e2df480/compiler%2Frustc_mir_transform%2Fsrc%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Finline.rs?ref=6efdf4d1309f8047bc439a4810888c715e2df480", "patch": "@@ -453,7 +453,7 @@ impl<'tcx> Inliner<'tcx> {\n \n                 // If the place doesn't actually need dropping, treat it like a regular goto.\n                 let ty = callsite.callee.subst_mir(self.tcx, &place.ty(callee_body, tcx).ty);\n-                if ty.needs_drop(tcx, self.param_env) && let Some(unwind) = unwind {\n+                if ty.needs_drop(tcx, self.param_env) && let UnwindAction::Cleanup(unwind) = unwind {\n                         work_list.push(unwind);\n                     }\n             } else if callee_attrs.instruction_set != self.codegen_fn_attrs.instruction_set\n@@ -500,7 +500,7 @@ impl<'tcx> Inliner<'tcx> {\n     ) {\n         let terminator = caller_body[callsite.block].terminator.take().unwrap();\n         match terminator.kind {\n-            TerminatorKind::Call { args, destination, cleanup, .. } => {\n+            TerminatorKind::Call { args, destination, unwind, .. } => {\n                 // If the call is something like `a[*i] = f(i)`, where\n                 // `i : &mut usize`, then just duplicating the `a[*i]`\n                 // Place could result in two different locations if `f`\n@@ -571,7 +571,7 @@ impl<'tcx> Inliner<'tcx> {\n                     destination: destination_local,\n                     callsite_scope: caller_body.source_scopes[callsite.source_info.scope].clone(),\n                     callsite,\n-                    cleanup_block: cleanup,\n+                    cleanup_block: unwind,\n                     in_cleanup_block: false,\n                     tcx: self.tcx,\n                     expn_data,\n@@ -813,35 +813,35 @@ impl<'tcx> Visitor<'tcx> for CostChecker<'_, 'tcx> {\n                 let ty = self.instance.subst_mir(tcx, &place.ty(self.callee_body, tcx).ty);\n                 if ty.needs_drop(tcx, self.param_env) {\n                     self.cost += CALL_PENALTY;\n-                    if unwind.is_some() {\n+                    if let UnwindAction::Cleanup(_) = unwind {\n                         self.cost += LANDINGPAD_PENALTY;\n                     }\n                 } else {\n                     self.cost += INSTR_COST;\n                 }\n             }\n-            TerminatorKind::Call { func: Operand::Constant(ref f), cleanup, .. } => {\n+            TerminatorKind::Call { func: Operand::Constant(ref f), unwind, .. } => {\n                 let fn_ty = self.instance.subst_mir(tcx, &f.literal.ty());\n                 self.cost += if let ty::FnDef(def_id, _) = *fn_ty.kind() && tcx.is_intrinsic(def_id) {\n                     // Don't give intrinsics the extra penalty for calls\n                     INSTR_COST\n                 } else {\n                     CALL_PENALTY\n                 };\n-                if cleanup.is_some() {\n+                if let UnwindAction::Cleanup(_) = unwind {\n                     self.cost += LANDINGPAD_PENALTY;\n                 }\n             }\n-            TerminatorKind::Assert { cleanup, .. } => {\n+            TerminatorKind::Assert { unwind, .. } => {\n                 self.cost += CALL_PENALTY;\n-                if cleanup.is_some() {\n+                if let UnwindAction::Cleanup(_) = unwind {\n                     self.cost += LANDINGPAD_PENALTY;\n                 }\n             }\n             TerminatorKind::Resume => self.cost += RESUME_PENALTY,\n-            TerminatorKind::InlineAsm { cleanup, .. } => {\n+            TerminatorKind::InlineAsm { unwind, .. } => {\n                 self.cost += INSTR_COST;\n-                if cleanup.is_some() {\n+                if let UnwindAction::Cleanup(_) = unwind {\n                     self.cost += LANDINGPAD_PENALTY;\n                 }\n             }\n@@ -979,7 +979,7 @@ struct Integrator<'a, 'tcx> {\n     destination: Local,\n     callsite_scope: SourceScopeData<'tcx>,\n     callsite: &'a CallSite<'tcx>,\n-    cleanup_block: Option<BasicBlock>,\n+    cleanup_block: UnwindAction,\n     in_cleanup_block: bool,\n     tcx: TyCtxt<'tcx>,\n     expn_data: LocalExpnId,\n@@ -1014,18 +1014,21 @@ impl Integrator<'_, '_> {\n         new\n     }\n \n-    fn map_unwind(&self, unwind: Option<BasicBlock>) -> Option<BasicBlock> {\n+    fn map_unwind(&self, unwind: UnwindAction) -> UnwindAction {\n         if self.in_cleanup_block {\n-            if unwind.is_some() {\n-                bug!(\"cleanup on cleanup block\");\n+            match unwind {\n+                UnwindAction::Cleanup(_) | UnwindAction::Continue => {\n+                    bug!(\"cleanup on cleanup block\");\n+                }\n+                UnwindAction::Unreachable | UnwindAction::Terminate => return unwind,\n             }\n-            return unwind;\n         }\n \n         match unwind {\n-            Some(target) => Some(self.map_block(target)),\n+            UnwindAction::Unreachable | UnwindAction::Terminate => unwind,\n+            UnwindAction::Cleanup(target) => UnwindAction::Cleanup(self.map_block(target)),\n             // Add an unwind edge to the original call's cleanup block\n-            None => self.cleanup_block,\n+            UnwindAction::Continue => self.cleanup_block,\n         }\n     }\n }\n@@ -1116,15 +1119,15 @@ impl<'tcx> MutVisitor<'tcx> for Integrator<'_, 'tcx> {\n                 *target = self.map_block(*target);\n                 *unwind = self.map_unwind(*unwind);\n             }\n-            TerminatorKind::Call { ref mut target, ref mut cleanup, .. } => {\n+            TerminatorKind::Call { ref mut target, ref mut unwind, .. } => {\n                 if let Some(ref mut tgt) = *target {\n                     *tgt = self.map_block(*tgt);\n                 }\n-                *cleanup = self.map_unwind(*cleanup);\n+                *unwind = self.map_unwind(*unwind);\n             }\n-            TerminatorKind::Assert { ref mut target, ref mut cleanup, .. } => {\n+            TerminatorKind::Assert { ref mut target, ref mut unwind, .. } => {\n                 *target = self.map_block(*target);\n-                *cleanup = self.map_unwind(*cleanup);\n+                *unwind = self.map_unwind(*unwind);\n             }\n             TerminatorKind::Return => {\n                 terminator.kind = if let Some(tgt) = self.callsite.target {\n@@ -1134,11 +1137,14 @@ impl<'tcx> MutVisitor<'tcx> for Integrator<'_, 'tcx> {\n                 }\n             }\n             TerminatorKind::Resume => {\n-                if let Some(tgt) = self.cleanup_block {\n-                    terminator.kind = TerminatorKind::Goto { target: tgt }\n-                }\n+                terminator.kind = match self.cleanup_block {\n+                    UnwindAction::Cleanup(tgt) => TerminatorKind::Goto { target: tgt },\n+                    UnwindAction::Continue => TerminatorKind::Resume,\n+                    UnwindAction::Unreachable => TerminatorKind::Unreachable,\n+                    UnwindAction::Terminate => TerminatorKind::Terminate,\n+                };\n             }\n-            TerminatorKind::Abort => {}\n+            TerminatorKind::Terminate => {}\n             TerminatorKind::Unreachable => {}\n             TerminatorKind::FalseEdge { ref mut real_target, ref mut imaginary_target } => {\n                 *real_target = self.map_block(*real_target);\n@@ -1149,11 +1155,11 @@ impl<'tcx> MutVisitor<'tcx> for Integrator<'_, 'tcx> {\n             {\n                 bug!(\"False unwinds should have been removed before inlining\")\n             }\n-            TerminatorKind::InlineAsm { ref mut destination, ref mut cleanup, .. } => {\n+            TerminatorKind::InlineAsm { ref mut destination, ref mut unwind, .. } => {\n                 if let Some(ref mut tgt) = *destination {\n                     *tgt = self.map_block(*tgt);\n                 }\n-                *cleanup = self.map_unwind(*cleanup);\n+                *unwind = self.map_unwind(*unwind);\n             }\n         }\n     }"}, {"sha": "2e418c1dafc48618975d792dc62c1e4fba316eeb", "filename": "compiler/rustc_mir_transform/src/lib.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6efdf4d1309f8047bc439a4810888c715e2df480/compiler%2Frustc_mir_transform%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6efdf4d1309f8047bc439a4810888c715e2df480/compiler%2Frustc_mir_transform%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Flib.rs?ref=6efdf4d1309f8047bc439a4810888c715e2df480", "patch": "@@ -159,7 +159,7 @@ fn remap_mir_for_const_eval_select<'tcx>(\n                 ref mut args,\n                 destination,\n                 target,\n-                cleanup,\n+                unwind,\n                 fn_span,\n                 ..\n             } if let ty::FnDef(def_id, _) = *literal.ty().kind()\n@@ -196,7 +196,7 @@ fn remap_mir_for_const_eval_select<'tcx>(\n                     };\n                     method(place)\n                 }).collect();\n-                terminator.kind = TerminatorKind::Call { func, args: arguments, destination, target, cleanup, from_hir_call: false, fn_span };\n+                terminator.kind = TerminatorKind::Call { func, args: arguments, destination, target, unwind, from_hir_call: false, fn_span };\n             }\n             _ => {}\n         }"}, {"sha": "7dc5878e04701a056509b68c3d30f3eced5a753b", "filename": "compiler/rustc_mir_transform/src/lower_slice_len.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/6efdf4d1309f8047bc439a4810888c715e2df480/compiler%2Frustc_mir_transform%2Fsrc%2Flower_slice_len.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6efdf4d1309f8047bc439a4810888c715e2df480/compiler%2Frustc_mir_transform%2Fsrc%2Flower_slice_len.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Flower_slice_len.rs?ref=6efdf4d1309f8047bc439a4810888c715e2df480", "patch": "@@ -54,7 +54,6 @@ fn lower_slice_len_call<'tcx>(\n             args,\n             destination,\n             target: Some(bb),\n-            cleanup: None,\n             from_hir_call: true,\n             ..\n         } => {"}, {"sha": "4941c9edce3058d642b7e3b488558762b4142c8b", "filename": "compiler/rustc_mir_transform/src/remove_noop_landing_pads.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/6efdf4d1309f8047bc439a4810888c715e2df480/compiler%2Frustc_mir_transform%2Fsrc%2Fremove_noop_landing_pads.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6efdf4d1309f8047bc439a4810888c715e2df480/compiler%2Frustc_mir_transform%2Fsrc%2Fremove_noop_landing_pads.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Fremove_noop_landing_pads.rs?ref=6efdf4d1309f8047bc439a4810888c715e2df480", "patch": "@@ -72,7 +72,7 @@ impl RemoveNoopLandingPads {\n             TerminatorKind::GeneratorDrop\n             | TerminatorKind::Yield { .. }\n             | TerminatorKind::Return\n-            | TerminatorKind::Abort\n+            | TerminatorKind::Terminate\n             | TerminatorKind::Unreachable\n             | TerminatorKind::Call { .. }\n             | TerminatorKind::Assert { .. }\n@@ -103,11 +103,11 @@ impl RemoveNoopLandingPads {\n         for bb in postorder {\n             debug!(\"  processing {:?}\", bb);\n             if let Some(unwind) = body[bb].terminator_mut().unwind_mut() {\n-                if let Some(unwind_bb) = *unwind {\n+                if let UnwindAction::Cleanup(unwind_bb) = *unwind {\n                     if nop_landing_pads.contains(unwind_bb) {\n                         debug!(\"    removing noop landing pad\");\n                         landing_pads_removed += 1;\n-                        *unwind = None;\n+                        *unwind = UnwindAction::Continue;\n                     }\n                 }\n             }"}, {"sha": "ef367faf6a70791cae313bd44f2aad5a7b6fea8c", "filename": "compiler/rustc_mir_transform/src/separate_const_switch.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6efdf4d1309f8047bc439a4810888c715e2df480/compiler%2Frustc_mir_transform%2Fsrc%2Fseparate_const_switch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6efdf4d1309f8047bc439a4810888c715e2df480/compiler%2Frustc_mir_transform%2Fsrc%2Fseparate_const_switch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Fseparate_const_switch.rs?ref=6efdf4d1309f8047bc439a4810888c715e2df480", "patch": "@@ -112,7 +112,7 @@ pub fn separate_const_switch(body: &mut Body<'_>) -> usize {\n                         | TerminatorKind::Assert { .. }\n                         | TerminatorKind::FalseUnwind { .. }\n                         | TerminatorKind::Yield { .. }\n-                        | TerminatorKind::Abort\n+                        | TerminatorKind::Terminate\n                         | TerminatorKind::Return\n                         | TerminatorKind::Unreachable\n                         | TerminatorKind::InlineAsm { .. }\n@@ -164,7 +164,7 @@ pub fn separate_const_switch(body: &mut Body<'_>) -> usize {\n             }\n \n             TerminatorKind::Resume\n-            | TerminatorKind::Abort\n+            | TerminatorKind::Terminate\n             | TerminatorKind::Return\n             | TerminatorKind::Unreachable\n             | TerminatorKind::GeneratorDrop"}, {"sha": "2787fe2ce42cd6b18266824b0f8e58b88183121e", "filename": "compiler/rustc_mir_transform/src/shim.rs", "status": "modified", "additions": 19, "deletions": 7, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/6efdf4d1309f8047bc439a4810888c715e2df480/compiler%2Frustc_mir_transform%2Fsrc%2Fshim.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6efdf4d1309f8047bc439a4810888c715e2df480/compiler%2Frustc_mir_transform%2Fsrc%2Fshim.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Fshim.rs?ref=6efdf4d1309f8047bc439a4810888c715e2df480", "patch": "@@ -499,7 +499,7 @@ impl<'tcx> CloneShimBuilder<'tcx> {\n                 args: vec![Operand::Move(ref_loc)],\n                 destination: dest,\n                 target: Some(next),\n-                cleanup: Some(cleanup),\n+                unwind: UnwindAction::Cleanup(cleanup),\n                 from_hir_call: true,\n                 fn_span: self.span,\n             },\n@@ -540,7 +540,11 @@ impl<'tcx> CloneShimBuilder<'tcx> {\n             self.make_clone_call(dest_field, src_field, ity, next_block, unwind);\n             self.block(\n                 vec![],\n-                TerminatorKind::Drop { place: dest_field, target: unwind, unwind: None },\n+                TerminatorKind::Drop {\n+                    place: dest_field,\n+                    target: unwind,\n+                    unwind: UnwindAction::Terminate,\n+                },\n                 true,\n             );\n             unwind = next_unwind;\n@@ -776,10 +780,10 @@ fn build_call_shim<'tcx>(\n             args,\n             destination: Place::return_place(),\n             target: Some(BasicBlock::new(1)),\n-            cleanup: if let Some(Adjustment::RefMut) = rcvr_adjustment {\n-                Some(BasicBlock::new(3))\n+            unwind: if let Some(Adjustment::RefMut) = rcvr_adjustment {\n+                UnwindAction::Cleanup(BasicBlock::new(3))\n             } else {\n-                None\n+                UnwindAction::Continue\n             },\n             from_hir_call: true,\n             fn_span: span,\n@@ -792,7 +796,11 @@ fn build_call_shim<'tcx>(\n         block(\n             &mut blocks,\n             vec![],\n-            TerminatorKind::Drop { place: rcvr_place(), target: BasicBlock::new(2), unwind: None },\n+            TerminatorKind::Drop {\n+                place: rcvr_place(),\n+                target: BasicBlock::new(2),\n+                unwind: UnwindAction::Continue,\n+            },\n             false,\n         );\n     }\n@@ -803,7 +811,11 @@ fn build_call_shim<'tcx>(\n         block(\n             &mut blocks,\n             vec![],\n-            TerminatorKind::Drop { place: rcvr_place(), target: BasicBlock::new(4), unwind: None },\n+            TerminatorKind::Drop {\n+                place: rcvr_place(),\n+                target: BasicBlock::new(4),\n+                unwind: UnwindAction::Terminate,\n+            },\n             true,\n         );\n "}, {"sha": "7bcff7e07fb34ff703d2d870a5e80a7c69735fc4", "filename": "compiler/rustc_monomorphize/src/collector.rs", "status": "modified", "additions": 11, "deletions": 1, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/6efdf4d1309f8047bc439a4810888c715e2df480/compiler%2Frustc_monomorphize%2Fsrc%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6efdf4d1309f8047bc439a4810888c715e2df480/compiler%2Frustc_monomorphize%2Fsrc%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_monomorphize%2Fsrc%2Fcollector.rs?ref=6efdf4d1309f8047bc439a4810888c715e2df480", "patch": "@@ -852,7 +852,7 @@ impl<'a, 'tcx> MirVisitor<'tcx> for MirNeighborCollector<'a, 'tcx> {\n                     self.output.push(create_fn_mono_item(tcx, instance, source));\n                 }\n             }\n-            mir::TerminatorKind::Abort { .. } => {\n+            mir::TerminatorKind::Terminate { .. } => {\n                 let instance = Instance::mono(\n                     tcx,\n                     tcx.require_lang_item(LangItem::PanicCannotUnwind, Some(source)),\n@@ -872,6 +872,16 @@ impl<'a, 'tcx> MirVisitor<'tcx> for MirNeighborCollector<'a, 'tcx> {\n             | mir::TerminatorKind::FalseUnwind { .. } => bug!(),\n         }\n \n+        if let Some(mir::UnwindAction::Terminate) = terminator.unwind() {\n+            let instance = Instance::mono(\n+                tcx,\n+                tcx.require_lang_item(LangItem::PanicCannotUnwind, Some(source)),\n+            );\n+            if should_codegen_locally(tcx, &instance) {\n+                self.output.push(create_fn_mono_item(tcx, instance, source));\n+            }\n+        }\n+\n         self.super_terminator(terminator, location);\n     }\n "}, {"sha": "e41d0f7047b3bd8a9bf3e21afdcb4fa5aa8cc713", "filename": "compiler/rustc_parse/src/lexer/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/6efdf4d1309f8047bc439a4810888c715e2df480/compiler%2Frustc_parse%2Fsrc%2Flexer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6efdf4d1309f8047bc439a4810888c715e2df480/compiler%2Frustc_parse%2Fsrc%2Flexer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Flexer%2Fmod.rs?ref=6efdf4d1309f8047bc439a4810888c715e2df480", "patch": "@@ -175,7 +175,7 @@ impl<'a> StringReader<'a> {\n                     if !sym.can_be_raw() {\n                         self.sess.emit_err(errors::CannotBeRawIdent { span, ident: sym });\n                     }\n-                    self.sess.raw_identifier_spans.borrow_mut().push(span);\n+                    self.sess.raw_identifier_spans.push(span);\n                     token::Ident(sym, true)\n                 }\n                 rustc_lexer::TokenKind::UnknownPrefix => {\n@@ -558,8 +558,8 @@ impl<'a> StringReader<'a> {\n         }\n \n         if let Some(possible_offset) = possible_offset {\n-            let lo = start + BytePos(possible_offset as u32);\n-            let hi = lo + BytePos(found_terminators as u32);\n+            let lo = start + BytePos(possible_offset);\n+            let hi = lo + BytePos(found_terminators);\n             let span = self.mk_sp(lo, hi);\n             err.span_suggestion(\n                 span,"}, {"sha": "1f027c08fc3b5fe8e3fd7a52e124ea93d907eaca", "filename": "compiler/rustc_parse/src/lexer/unicode_chars.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6efdf4d1309f8047bc439a4810888c715e2df480/compiler%2Frustc_parse%2Fsrc%2Flexer%2Funicode_chars.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6efdf4d1309f8047bc439a4810888c715e2df480/compiler%2Frustc_parse%2Fsrc%2Flexer%2Funicode_chars.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Flexer%2Funicode_chars.rs?ref=6efdf4d1309f8047bc439a4810888c715e2df480", "patch": "@@ -336,8 +336,8 @@ const ASCII_ARRAY: &[(&str, &str, Option<token::TokenKind>)] = &[\n     (\"\\\"\", \"Quotation Mark\", None),\n ];\n \n-pub(super) fn check_for_substitution<'a>(\n-    reader: &StringReader<'a>,\n+pub(super) fn check_for_substitution(\n+    reader: &StringReader<'_>,\n     pos: BytePos,\n     ch: char,\n     count: usize,"}, {"sha": "e03ce5d712056cbedee23fadc5850eb59a21639e", "filename": "compiler/rustc_parse/src/parser/diagnostics.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6efdf4d1309f8047bc439a4810888c715e2df480/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6efdf4d1309f8047bc439a4810888c715e2df480/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fdiagnostics.rs?ref=6efdf4d1309f8047bc439a4810888c715e2df480", "patch": "@@ -423,11 +423,11 @@ impl<'a> Parser<'a> {\n         if let token::Literal(Lit {\n             kind: token::LitKind::Integer | token::LitKind::Float,\n             symbol,\n-            suffix,\n+            suffix: Some(suffix), // no suffix makes it a valid literal\n         }) = self.token.kind\n             && rustc_ast::MetaItemLit::from_token(&self.token).is_none()\n         {\n-            Some((symbol.as_str().len(), suffix.unwrap()))\n+            Some((symbol.as_str().len(), suffix))\n         } else {\n             None\n         }"}, {"sha": "f8ef1307c988e187d13ea1035fbf2b3594b94f15", "filename": "compiler/rustc_parse/src/parser/generics.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6efdf4d1309f8047bc439a4810888c715e2df480/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fgenerics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6efdf4d1309f8047bc439a4810888c715e2df480/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fgenerics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fgenerics.rs?ref=6efdf4d1309f8047bc439a4810888c715e2df480", "patch": "@@ -53,7 +53,7 @@ impl<'a> Parser<'a> {\n                 let snapshot = self.create_snapshot_for_diagnostic();\n                 match self.parse_ty() {\n                     Ok(p) => {\n-                        if let TyKind::ImplTrait(_, bounds) = &(*p).kind {\n+                        if let TyKind::ImplTrait(_, bounds) = &p.kind {\n                             let span = impl_span.to(self.token.span.shrink_to_lo());\n                             let mut err = self.struct_span_err(\n                                 span,"}, {"sha": "6422b8ac1ba458d58a4036865429451378923ed2", "filename": "compiler/rustc_parse/src/parser/item.rs", "status": "modified", "additions": 11, "deletions": 6, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/6efdf4d1309f8047bc439a4810888c715e2df480/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fitem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6efdf4d1309f8047bc439a4810888c715e2df480/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fitem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fitem.rs?ref=6efdf4d1309f8047bc439a4810888c715e2df480", "patch": "@@ -3,6 +3,7 @@ use crate::errors;\n use super::diagnostics::{dummy_arg, ConsumeClosingDelim};\n use super::ty::{AllowPlus, RecoverQPath, RecoverReturnSign};\n use super::{AttrWrapper, FollowedByType, ForceCollect, Parser, PathStyle, TrailingToken};\n+use ast::StaticItem;\n use rustc_ast::ast::*;\n use rustc_ast::ptr::P;\n use rustc_ast::token::{self, Delimiter, TokenKind};\n@@ -227,7 +228,7 @@ impl<'a> Parser<'a> {\n             self.bump(); // `static`\n             let m = self.parse_mutability();\n             let (ident, ty, expr) = self.parse_item_global(Some(m))?;\n-            (ident, ItemKind::Static(ty, m, expr))\n+            (ident, ItemKind::Static(Box::new(StaticItem { ty, mutability: m, expr })))\n         } else if let Const::Yes(const_span) = self.parse_constness(Case::Sensitive) {\n             // CONST ITEM\n             if self.token.is_keyword(kw::Impl) {\n@@ -236,7 +237,7 @@ impl<'a> Parser<'a> {\n             } else {\n                 self.recover_const_mut(const_span);\n                 let (ident, ty, expr) = self.parse_item_global(None)?;\n-                (ident, ItemKind::Const(def_(), ty, expr))\n+                (ident, ItemKind::Const(Box::new(ConstItem { defaultness: def_(), ty, expr })))\n             }\n         } else if self.check_keyword(kw::Trait) || self.check_auto_or_unsafe_trait_item() {\n             // TRAIT ITEM\n@@ -862,9 +863,13 @@ impl<'a> Parser<'a> {\n                 let kind = match AssocItemKind::try_from(kind) {\n                     Ok(kind) => kind,\n                     Err(kind) => match kind {\n-                        ItemKind::Static(a, _, b) => {\n+                        ItemKind::Static(box StaticItem { ty, mutability: _, expr }) => {\n                             self.sess.emit_err(errors::AssociatedStaticItemNotAllowed { span });\n-                            AssocItemKind::Const(Defaultness::Final, a, b)\n+                            AssocItemKind::Const(Box::new(ConstItem {\n+                                defaultness: Defaultness::Final,\n+                                ty,\n+                                expr,\n+                            }))\n                         }\n                         _ => return self.error_bad_item_kind(span, &kind, \"`trait`s or `impl`s\"),\n                     },\n@@ -1114,12 +1119,12 @@ impl<'a> Parser<'a> {\n                 let kind = match ForeignItemKind::try_from(kind) {\n                     Ok(kind) => kind,\n                     Err(kind) => match kind {\n-                        ItemKind::Const(_, a, b) => {\n+                        ItemKind::Const(box ConstItem { ty, expr, .. }) => {\n                             self.sess.emit_err(errors::ExternItemCannotBeConst {\n                                 ident_span: ident.span,\n                                 const_span: span.with_hi(ident.span.lo()),\n                             });\n-                            ForeignItemKind::Static(a, Mutability::Not, b)\n+                            ForeignItemKind::Static(ty, Mutability::Not, expr)\n                         }\n                         _ => return self.error_bad_item_kind(span, &kind, \"`extern` blocks\"),\n                     },"}, {"sha": "aa57b804779b0846195a9549ddceb1899e2c952c", "filename": "compiler/rustc_parse/src/parser/mod.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/6efdf4d1309f8047bc439a4810888c715e2df480/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6efdf4d1309f8047bc439a4810888c715e2df480/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fmod.rs?ref=6efdf4d1309f8047bc439a4810888c715e2df480", "patch": "@@ -29,6 +29,7 @@ use rustc_ast::{Async, AttrArgs, AttrArgsEq, Expr, ExprKind, MacDelimiter, Mutab\n use rustc_ast::{HasAttrs, HasTokens, Unsafe, Visibility, VisibilityKind};\n use rustc_ast_pretty::pprust;\n use rustc_data_structures::fx::FxHashMap;\n+use rustc_data_structures::sync::Ordering;\n use rustc_errors::PResult;\n use rustc_errors::{\n     Applicability, DiagnosticBuilder, ErrorGuaranteed, FatalError, IntoDiagnostic, MultiSpan,\n@@ -1540,8 +1541,10 @@ pub(crate) fn make_unclosed_delims_error(\n }\n \n pub fn emit_unclosed_delims(unclosed_delims: &mut Vec<UnmatchedDelim>, sess: &ParseSess) {\n-    *sess.reached_eof.borrow_mut() |=\n-        unclosed_delims.iter().any(|unmatched_delim| unmatched_delim.found_delim.is_none());\n+    let _ = sess.reached_eof.fetch_or(\n+        unclosed_delims.iter().any(|unmatched_delim| unmatched_delim.found_delim.is_none()),\n+        Ordering::Relaxed,\n+    );\n     for unmatched in unclosed_delims.drain(..) {\n         if let Some(mut e) = make_unclosed_delims_error(unmatched, sess) {\n             e.emit();"}, {"sha": "e3e4b73efa324071e371a3b8f9d147106c862c6d", "filename": "compiler/rustc_passes/src/entry.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6efdf4d1309f8047bc439a4810888c715e2df480/compiler%2Frustc_passes%2Fsrc%2Fentry.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6efdf4d1309f8047bc439a4810888c715e2df480/compiler%2Frustc_passes%2Fsrc%2Fentry.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_passes%2Fsrc%2Fentry.rs?ref=6efdf4d1309f8047bc439a4810888c715e2df480", "patch": "@@ -187,7 +187,7 @@ fn sigpipe(tcx: TyCtxt<'_>, def_id: DefId) -> u8 {\n \n fn no_main_err(tcx: TyCtxt<'_>, visitor: &EntryContext<'_>) {\n     let sp = tcx.def_span(CRATE_DEF_ID);\n-    if *tcx.sess.parse_sess.reached_eof.borrow() {\n+    if tcx.sess.parse_sess.reached_eof.load(rustc_data_structures::sync::Ordering::Relaxed) {\n         // There's an unclosed brace that made the parser reach `Eof`, we shouldn't complain about\n         // the missing `fn main()` then as it might have been hidden inside an unclosed block.\n         tcx.sess.delay_span_bug(sp, \"`main` not found, but expected unclosed brace error\");"}, {"sha": "4a35c6794663e09e8d1b927fdfb39df29bcd4e6b", "filename": "compiler/rustc_passes/src/stability.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6efdf4d1309f8047bc439a4810888c715e2df480/compiler%2Frustc_passes%2Fsrc%2Fstability.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6efdf4d1309f8047bc439a4810888c715e2df480/compiler%2Frustc_passes%2Fsrc%2Fstability.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_passes%2Fsrc%2Fstability.rs?ref=6efdf4d1309f8047bc439a4810888c715e2df480", "patch": "@@ -530,7 +530,7 @@ struct MissingStabilityAnnotations<'tcx> {\n impl<'tcx> MissingStabilityAnnotations<'tcx> {\n     fn check_missing_stability(&self, def_id: LocalDefId, span: Span) {\n         let stab = self.tcx.stability().local_stability(def_id);\n-        if !self.tcx.sess.opts.test\n+        if !self.tcx.sess.is_test_crate()\n             && stab.is_none()\n             && self.effective_visibilities.is_reachable(def_id)\n         {"}, {"sha": "089e043d61c3c0bce58a25cb47088bdcdf6237ec", "filename": "compiler/rustc_privacy/src/lib.rs", "status": "modified", "additions": 6, "deletions": 10, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/6efdf4d1309f8047bc439a4810888c715e2df480/compiler%2Frustc_privacy%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6efdf4d1309f8047bc439a4810888c715e2df480/compiler%2Frustc_privacy%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_privacy%2Fsrc%2Flib.rs?ref=6efdf4d1309f8047bc439a4810888c715e2df480", "patch": "@@ -515,16 +515,12 @@ impl<'tcx> EmbargoVisitor<'tcx> {\n             let vis = self.tcx.local_visibility(item_id.owner_id.def_id);\n             self.update_macro_reachable_def(item_id.owner_id.def_id, def_kind, vis, defining_mod);\n         }\n-        if let Some(exports) = self.tcx.module_reexports(module_def_id) {\n-            for export in exports {\n-                if export.vis.is_accessible_from(defining_mod, self.tcx) {\n-                    if let Res::Def(def_kind, def_id) = export.res {\n-                        if let Some(def_id) = def_id.as_local() {\n-                            let vis = self.tcx.local_visibility(def_id);\n-                            self.update_macro_reachable_def(def_id, def_kind, vis, defining_mod);\n-                        }\n-                    }\n-                }\n+        for export in self.tcx.module_reexports(module_def_id) {\n+            if export.vis.is_accessible_from(defining_mod, self.tcx)\n+                && let Res::Def(def_kind, def_id) = export.res\n+                && let Some(def_id) = def_id.as_local() {\n+                let vis = self.tcx.local_visibility(def_id);\n+                self.update_macro_reachable_def(def_id, def_kind, vis, defining_mod);\n             }\n         }\n     }"}, {"sha": "7001a1eed57e711fdb3ceb7032d661391dbd1fda", "filename": "compiler/rustc_query_impl/src/lib.rs", "status": "modified", "additions": 11, "deletions": 2, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/6efdf4d1309f8047bc439a4810888c715e2df480/compiler%2Frustc_query_impl%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6efdf4d1309f8047bc439a4810888c715e2df480/compiler%2Frustc_query_impl%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_query_impl%2Fsrc%2Flib.rs?ref=6efdf4d1309f8047bc439a4810888c715e2df480", "patch": "@@ -18,19 +18,21 @@ extern crate rustc_middle;\n \n use rustc_data_structures::sync::AtomicU64;\n use rustc_middle::arena::Arena;\n-use rustc_middle::dep_graph::{self, DepKindStruct};\n+use rustc_middle::dep_graph::{self, DepKind, DepKindStruct};\n+use rustc_middle::query::erase::{erase, restore, Erase};\n use rustc_middle::query::AsLocalKey;\n use rustc_middle::ty::query::{\n     query_keys, query_provided, query_provided_to_value, query_storage, query_values,\n };\n use rustc_middle::ty::query::{ExternProviders, Providers, QueryEngine};\n use rustc_middle::ty::TyCtxt;\n+use rustc_query_system::dep_graph::SerializedDepNodeIndex;\n+use rustc_query_system::Value;\n use rustc_span::Span;\n \n #[macro_use]\n mod plumbing;\n pub use plumbing::QueryCtxt;\n-use rustc_query_system::dep_graph::SerializedDepNodeIndex;\n use rustc_query_system::query::*;\n #[cfg(parallel_compiler)]\n pub use rustc_query_system::query::{deadlock, QueryContext};\n@@ -43,6 +45,13 @@ pub use on_disk_cache::OnDiskCache;\n mod profiling_support;\n pub use self::profiling_support::alloc_self_profile_query_strings;\n \n+/// This is implemented per query and restoring query values from their erased state.\n+trait QueryConfigRestored<'tcx>: QueryConfig<QueryCtxt<'tcx>> + Default {\n+    type RestoredValue;\n+\n+    fn restore(value: <Self as QueryConfig<QueryCtxt<'tcx>>>::Value) -> Self::RestoredValue;\n+}\n+\n rustc_query_append! { define_queries! }\n \n impl<'tcx> Queries<'tcx> {"}, {"sha": "30477c7bd4422008113ef3e264de31e84dcb752e", "filename": "compiler/rustc_query_impl/src/on_disk_cache.rs", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/6efdf4d1309f8047bc439a4810888c715e2df480/compiler%2Frustc_query_impl%2Fsrc%2Fon_disk_cache.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6efdf4d1309f8047bc439a4810888c715e2df480/compiler%2Frustc_query_impl%2Fsrc%2Fon_disk_cache.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_query_impl%2Fsrc%2Fon_disk_cache.rs?ref=6efdf4d1309f8047bc439a4810888c715e2df480", "patch": "@@ -1046,8 +1046,6 @@ impl<'a, 'tcx> Encoder for CacheEncoder<'a, 'tcx> {\n         emit_i8(i8);\n \n         emit_bool(bool);\n-        emit_f64(f64);\n-        emit_f32(f32);\n         emit_char(char);\n         emit_str(&str);\n         emit_raw_bytes(&[u8]);\n@@ -1064,14 +1062,14 @@ impl<'a, 'tcx> Encodable<CacheEncoder<'a, 'tcx>> for [u8] {\n     }\n }\n \n-pub fn encode_query_results<'a, 'tcx, Q>(\n+pub(crate) fn encode_query_results<'a, 'tcx, Q>(\n     query: Q,\n     qcx: QueryCtxt<'tcx>,\n     encoder: &mut CacheEncoder<'a, 'tcx>,\n     query_result_index: &mut EncodedDepNodeIndex,\n ) where\n-    Q: super::QueryConfig<QueryCtxt<'tcx>>,\n-    Q::Value: Encodable<CacheEncoder<'a, 'tcx>>,\n+    Q: super::QueryConfigRestored<'tcx>,\n+    Q::RestoredValue: Encodable<CacheEncoder<'a, 'tcx>>,\n {\n     let _timer = qcx\n         .tcx\n@@ -1089,7 +1087,7 @@ pub fn encode_query_results<'a, 'tcx, Q>(\n \n             // Encode the type check tables with the `SerializedDepNodeIndex`\n             // as tag.\n-            encoder.encode_tagged(dep_node, value);\n+            encoder.encode_tagged(dep_node, &Q::restore(*value));\n         }\n     });\n }"}, {"sha": "afbead7d1ae97cb486f3611fbdf4df7b47e43080", "filename": "compiler/rustc_query_impl/src/plumbing.rs", "status": "modified", "additions": 36, "deletions": 12, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/6efdf4d1309f8047bc439a4810888c715e2df480/compiler%2Frustc_query_impl%2Fsrc%2Fplumbing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6efdf4d1309f8047bc439a4810888c715e2df480/compiler%2Frustc_query_impl%2Fsrc%2Fplumbing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_query_impl%2Fsrc%2Fplumbing.rs?ref=6efdf4d1309f8047bc439a4810888c715e2df480", "patch": "@@ -263,14 +263,14 @@ macro_rules! feedable {\n }\n \n macro_rules! hash_result {\n-    ([]) => {{\n-        Some(dep_graph::hash_result)\n+    ([][$V:ty]) => {{\n+        Some(|hcx, result| dep_graph::hash_result(hcx, &restore::<$V>(*result)))\n     }};\n-    ([(no_hash) $($rest:tt)*]) => {{\n+    ([(no_hash) $($rest:tt)*][$V:ty]) => {{\n         None\n     }};\n-    ([$other:tt $($modifiers:tt)*]) => {\n-        hash_result!([$($modifiers)*])\n+    ([$other:tt $($modifiers:tt)*][$($args:tt)*]) => {\n+        hash_result!([$($modifiers)*][$($args)*])\n     };\n }\n \n@@ -479,13 +479,18 @@ macro_rules! define_queries {\n \n         $(impl<'tcx> QueryConfig<QueryCtxt<'tcx>> for queries::$name<'tcx> {\n             type Key = query_keys::$name<'tcx>;\n-            type Value = query_values::$name<'tcx>;\n+            type Value = Erase<query_values::$name<'tcx>>;\n \n             #[inline(always)]\n             fn name(self) -> &'static str {\n                 stringify!($name)\n             }\n \n+            #[inline]\n+            fn format_value(self) -> fn(&Self::Value) -> String {\n+                |value| format!(\"{:?}\", restore::<query_values::$name<'tcx>>(*value))\n+            }\n+\n             #[inline]\n             fn cache_on_disk(self, tcx: TyCtxt<'tcx>, key: &Self::Key) -> bool {\n                 ::rustc_middle::query::cached::$name(tcx, key)\n@@ -508,7 +513,7 @@ macro_rules! define_queries {\n             }\n \n             fn execute_query(self, tcx: TyCtxt<'tcx>, key: Self::Key) -> Self::Value {\n-                tcx.$name(key)\n+                erase(tcx.$name(key))\n             }\n \n             #[inline]\n@@ -558,6 +563,16 @@ macro_rules! define_queries {\n                 })\n             }\n \n+            #[inline]\n+            fn value_from_cycle_error(\n+                self,\n+                tcx: TyCtxt<'tcx>,\n+                cycle: &[QueryInfo<DepKind>],\n+            ) -> Self::Value {\n+                let result: query_values::$name<'tcx> = Value::from_cycle_error(tcx, cycle);\n+                erase(result)\n+            }\n+\n             #[inline(always)]\n             fn anon(self) -> bool {\n                 is_anon!([$($modifiers)*])\n@@ -590,7 +605,16 @@ macro_rules! define_queries {\n \n             #[inline(always)]\n             fn hash_result(self) -> rustc_query_system::query::HashResult<Self::Value> {\n-                hash_result!([$($modifiers)*])\n+                hash_result!([$($modifiers)*][query_values::$name<'tcx>])\n+            }\n+        })*\n+\n+        $(impl<'tcx> QueryConfigRestored<'tcx> for queries::$name<'tcx> {\n+            type RestoredValue = query_values::$name<'tcx>;\n+\n+            #[inline(always)]\n+            fn restore(value: <Self as QueryConfig<QueryCtxt<'tcx>>>::Value) -> Self::RestoredValue {\n+                restore::<query_values::$name<'tcx>>(value)\n             }\n         })*\n \n@@ -708,7 +732,7 @@ macro_rules! define_queries {\n                     )\n                 },\n                 encode_query_results: expand_if_cached!([$($modifiers)*], |qcx, encoder, query_result_index|\n-                    $crate::on_disk_cache::encode_query_results(\n+                    $crate::on_disk_cache::encode_query_results::<super::queries::$name<'tcx>>(\n                         super::queries::$name::default(),\n                         qcx,\n                         encoder,\n@@ -793,14 +817,14 @@ macro_rules! define_queries_struct {\n \n             $($(#[$attr])*\n             #[inline(always)]\n-            #[tracing::instrument(level = \"trace\", skip(self, tcx), ret)]\n+            #[tracing::instrument(level = \"trace\", skip(self, tcx))]\n             fn $name(\n                 &'tcx self,\n                 tcx: TyCtxt<'tcx>,\n                 span: Span,\n-                key: <queries::$name<'tcx> as QueryConfig<QueryCtxt<'tcx>>>::Key,\n+                key: query_keys::$name<'tcx>,\n                 mode: QueryMode,\n-            ) -> Option<query_values::$name<'tcx>> {\n+            ) -> Option<Erase<query_values::$name<'tcx>>> {\n                 let qcx = QueryCtxt { tcx, queries: self };\n                 get_query(\n                     queries::$name::default(),"}, {"sha": "6e862db0b2547e98e3b91f7bf106dd5264dee2a8", "filename": "compiler/rustc_query_system/src/cache.rs", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/6efdf4d1309f8047bc439a4810888c715e2df480/compiler%2Frustc_query_system%2Fsrc%2Fcache.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6efdf4d1309f8047bc439a4810888c715e2df480/compiler%2Frustc_query_system%2Fsrc%2Fcache.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_query_system%2Fsrc%2Fcache.rs?ref=6efdf4d1309f8047bc439a4810888c715e2df480", "patch": "@@ -7,11 +7,16 @@ use rustc_data_structures::sync::Lock;\n \n use std::hash::Hash;\n \n-#[derive(Clone)]\n pub struct Cache<Key, Value> {\n     hashmap: Lock<FxHashMap<Key, WithDepNode<Value>>>,\n }\n \n+impl<Key: Clone, Value: Clone> Clone for Cache<Key, Value> {\n+    fn clone(&self) -> Self {\n+        Self { hashmap: Lock::new(self.hashmap.borrow().clone()) }\n+    }\n+}\n+\n impl<Key, Value> Default for Cache<Key, Value> {\n     fn default() -> Self {\n         Self { hashmap: Default::default() }"}, {"sha": "534d13b1ae0f4a643c11022f56614c30649f259f", "filename": "compiler/rustc_query_system/src/dep_graph/graph.rs", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/6efdf4d1309f8047bc439a4810888c715e2df480/compiler%2Frustc_query_system%2Fsrc%2Fdep_graph%2Fgraph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6efdf4d1309f8047bc439a4810888c715e2df480/compiler%2Frustc_query_system%2Fsrc%2Fdep_graph%2Fgraph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_query_system%2Fsrc%2Fdep_graph%2Fgraph.rs?ref=6efdf4d1309f8047bc439a4810888c715e2df480", "patch": "@@ -538,7 +538,14 @@ impl<K: DepKind> DepGraph<K> {\n             if let Some(prev_index) = data.previous.node_to_index_opt(&node) {\n                 let dep_node_index = data.current.prev_index_to_index.lock()[prev_index];\n                 if let Some(dep_node_index) = dep_node_index {\n-                    crate::query::incremental_verify_ich(cx, data, result, prev_index, hash_result);\n+                    crate::query::incremental_verify_ich(\n+                        cx,\n+                        data,\n+                        result,\n+                        prev_index,\n+                        hash_result,\n+                        |value| format!(\"{:?}\", value),\n+                    );\n \n                     #[cfg(debug_assertions)]\n                     if hash_result.is_some() {"}, {"sha": "29f6a07e81bebac0b9852753af5ea24197fb1ffa", "filename": "compiler/rustc_query_system/src/query/caches.rs", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/6efdf4d1309f8047bc439a4810888c715e2df480/compiler%2Frustc_query_system%2Fsrc%2Fquery%2Fcaches.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6efdf4d1309f8047bc439a4810888c715e2df480/compiler%2Frustc_query_system%2Fsrc%2Fquery%2Fcaches.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_query_system%2Fsrc%2Fquery%2Fcaches.rs?ref=6efdf4d1309f8047bc439a4810888c715e2df480", "patch": "@@ -18,7 +18,7 @@ pub trait CacheSelector<'tcx, V> {\n \n pub trait QueryCache: Sized {\n     type Key: Hash + Eq + Copy + Debug;\n-    type Value: Copy + Debug;\n+    type Value: Copy;\n \n     /// Checks if the query is already computed and in the cache.\n     fn lookup(&self, key: &Self::Key) -> Option<(Self::Value, DepNodeIndex)>;\n@@ -52,7 +52,7 @@ impl<K, V> Default for DefaultCache<K, V> {\n impl<K, V> QueryCache for DefaultCache<K, V>\n where\n     K: Eq + Hash + Copy + Debug,\n-    V: Copy + Debug,\n+    V: Copy,\n {\n     type Key = K;\n     type Value = V;\n@@ -120,7 +120,7 @@ impl<V> Default for SingleCache<V> {\n \n impl<V> QueryCache for SingleCache<V>\n where\n-    V: Copy + Debug,\n+    V: Copy,\n {\n     type Key = ();\n     type Value = V;\n@@ -136,7 +136,9 @@ where\n     }\n \n     fn iter(&self, f: &mut dyn FnMut(&Self::Key, &Self::Value, DepNodeIndex)) {\n-        self.cache.lock().as_ref().map(|value| f(&(), &value.0, value.1));\n+        if let Some(value) = self.cache.lock().as_ref() {\n+            f(&(), &value.0, value.1)\n+        }\n     }\n }\n \n@@ -164,7 +166,7 @@ impl<K: Idx, V> Default for VecCache<K, V> {\n impl<K, V> QueryCache for VecCache<K, V>\n where\n     K: Eq + Idx + Copy + Debug,\n-    V: Copy + Debug,\n+    V: Copy,\n {\n     type Key = K;\n     type Value = V;"}, {"sha": "c8d779385108f04dad64cf91e2fe5713f590fc5d", "filename": "compiler/rustc_query_system/src/query/config.rs", "status": "modified", "additions": 11, "deletions": 2, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/6efdf4d1309f8047bc439a4810888c715e2df480/compiler%2Frustc_query_system%2Fsrc%2Fquery%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6efdf4d1309f8047bc439a4810888c715e2df480/compiler%2Frustc_query_system%2Fsrc%2Fquery%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_query_system%2Fsrc%2Fquery%2Fconfig.rs?ref=6efdf4d1309f8047bc439a4810888c715e2df480", "patch": "@@ -4,7 +4,7 @@ use crate::dep_graph::{DepNode, DepNodeParams, SerializedDepNodeIndex};\n use crate::error::HandleCycleError;\n use crate::ich::StableHashingContext;\n use crate::query::caches::QueryCache;\n-use crate::query::{QueryContext, QueryState};\n+use crate::query::{QueryContext, QueryInfo, QueryState};\n \n use rustc_data_structures::fingerprint::Fingerprint;\n use std::fmt::Debug;\n@@ -20,10 +20,12 @@ pub trait QueryConfig<Qcx: QueryContext>: Copy {\n     // `Key` and `Value` are `Copy` instead of `Clone` to ensure copying them stays cheap,\n     // but it isn't necessary.\n     type Key: DepNodeParams<Qcx::DepContext> + Eq + Hash + Copy + Debug;\n-    type Value: Debug + Copy;\n+    type Value: Copy;\n \n     type Cache: QueryCache<Key = Self::Key, Value = Self::Value>;\n \n+    fn format_value(self) -> fn(&Self::Value) -> String;\n+\n     // Don't use this method to access query results, instead use the methods on TyCtxt\n     fn query_state<'a>(self, tcx: Qcx) -> &'a QueryState<Self::Key, Qcx::DepKind>\n     where\n@@ -45,6 +47,13 @@ pub trait QueryConfig<Qcx: QueryContext>: Copy {\n \n     fn loadable_from_disk(self, qcx: Qcx, key: &Self::Key, idx: SerializedDepNodeIndex) -> bool;\n \n+    /// Synthesize an error value to let compilation continue after a cycle.\n+    fn value_from_cycle_error(\n+        self,\n+        tcx: Qcx::DepContext,\n+        cycle: &[QueryInfo<Qcx::DepKind>],\n+    ) -> Self::Value;\n+\n     fn anon(self) -> bool;\n     fn eval_always(self) -> bool;\n     fn depth_limit(self) -> bool;"}, {"sha": "20310483d7e86b2fb2262b2d9b39cabda9aa1471", "filename": "compiler/rustc_query_system/src/query/plumbing.rs", "status": "modified", "additions": 29, "deletions": 24, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/6efdf4d1309f8047bc439a4810888c715e2df480/compiler%2Frustc_query_system%2Fsrc%2Fquery%2Fplumbing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6efdf4d1309f8047bc439a4810888c715e2df480/compiler%2Frustc_query_system%2Fsrc%2Fquery%2Fplumbing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_query_system%2Fsrc%2Fquery%2Fplumbing.rs?ref=6efdf4d1309f8047bc439a4810888c715e2df480", "patch": "@@ -11,7 +11,6 @@ use crate::query::job::QueryLatch;\n use crate::query::job::{report_cycle, QueryInfo, QueryJob, QueryJobId, QueryJobInfo};\n use crate::query::SerializedDepNodeIndex;\n use crate::query::{QueryContext, QueryMap, QuerySideEffects, QueryStackFrame};\n-use crate::values::Value;\n use crate::HandleCycleError;\n use rustc_data_structures::fingerprint::Fingerprint;\n use rustc_data_structures::fx::FxHashMap;\n@@ -120,43 +119,45 @@ where\n \n #[cold]\n #[inline(never)]\n-fn mk_cycle<Qcx, R, D: DepKind>(\n+fn mk_cycle<Q, Qcx>(\n+    query: Q,\n     qcx: Qcx,\n-    cycle_error: CycleError<D>,\n+    cycle_error: CycleError<Qcx::DepKind>,\n     handler: HandleCycleError,\n-) -> R\n+) -> Q::Value\n where\n-    Qcx: QueryContext + HasDepContext<DepKind = D>,\n-    R: std::fmt::Debug + Value<Qcx::DepContext, Qcx::DepKind>,\n+    Q: QueryConfig<Qcx>,\n+    Qcx: QueryContext,\n {\n     let error = report_cycle(qcx.dep_context().sess(), &cycle_error);\n-    handle_cycle_error(*qcx.dep_context(), &cycle_error, error, handler)\n+    handle_cycle_error(query, qcx, &cycle_error, error, handler)\n }\n \n-fn handle_cycle_error<Tcx, V>(\n-    tcx: Tcx,\n-    cycle_error: &CycleError<Tcx::DepKind>,\n+fn handle_cycle_error<Q, Qcx>(\n+    query: Q,\n+    qcx: Qcx,\n+    cycle_error: &CycleError<Qcx::DepKind>,\n     mut error: DiagnosticBuilder<'_, ErrorGuaranteed>,\n     handler: HandleCycleError,\n-) -> V\n+) -> Q::Value\n where\n-    Tcx: DepContext,\n-    V: Value<Tcx, Tcx::DepKind>,\n+    Q: QueryConfig<Qcx>,\n+    Qcx: QueryContext,\n {\n     use HandleCycleError::*;\n     match handler {\n         Error => {\n             error.emit();\n-            Value::from_cycle_error(tcx, &cycle_error.cycle)\n+            query.value_from_cycle_error(*qcx.dep_context(), &cycle_error.cycle)\n         }\n         Fatal => {\n             error.emit();\n-            tcx.sess().abort_if_errors();\n+            qcx.dep_context().sess().abort_if_errors();\n             unreachable!()\n         }\n         DelayBug => {\n             error.delay_as_bug();\n-            Value::from_cycle_error(tcx, &cycle_error.cycle)\n+            query.value_from_cycle_error(*qcx.dep_context(), &cycle_error.cycle)\n         }\n     }\n }\n@@ -269,7 +270,7 @@ where\n         &qcx.current_query_job(),\n         span,\n     );\n-    (mk_cycle(qcx, error, query.handle_cycle_error()), None)\n+    (mk_cycle(query, qcx, error, query.handle_cycle_error()), None)\n }\n \n #[inline(always)]\n@@ -306,7 +307,7 @@ where\n \n             (v, Some(index))\n         }\n-        Err(cycle) => (mk_cycle(qcx, cycle, query.handle_cycle_error()), None),\n+        Err(cycle) => (mk_cycle(query, qcx, cycle, query.handle_cycle_error()), None),\n     }\n }\n \n@@ -410,7 +411,8 @@ where\n         // get evaluated first, and re-feed the query.\n         if let Some((cached_result, _)) = cache.lookup(&key) {\n             panic!(\n-                \"fed query later has its value computed. The already cached value: {cached_result:?}\"\n+                \"fed query later has its value computed. The already cached value: {}\",\n+                (query.format_value())(&cached_result)\n             );\n         }\n     }\n@@ -581,6 +583,7 @@ where\n                     &result,\n                     prev_dep_node_index,\n                     query.hash_result(),\n+                    query.format_value(),\n                 );\n             }\n \n@@ -626,19 +629,21 @@ where\n         &result,\n         prev_dep_node_index,\n         query.hash_result(),\n+        query.format_value(),\n     );\n \n     Some((result, dep_node_index))\n }\n \n #[inline]\n-#[instrument(skip(tcx, dep_graph_data, result, hash_result), level = \"debug\")]\n-pub(crate) fn incremental_verify_ich<Tcx, V: Debug>(\n+#[instrument(skip(tcx, dep_graph_data, result, hash_result, format_value), level = \"debug\")]\n+pub(crate) fn incremental_verify_ich<Tcx, V>(\n     tcx: Tcx,\n     dep_graph_data: &DepGraphData<Tcx::DepKind>,\n     result: &V,\n     prev_index: SerializedDepNodeIndex,\n     hash_result: Option<fn(&mut StableHashingContext<'_>, &V) -> Fingerprint>,\n+    format_value: fn(&V) -> String,\n ) where\n     Tcx: DepContext,\n {\n@@ -653,7 +658,7 @@ pub(crate) fn incremental_verify_ich<Tcx, V: Debug>(\n     let old_hash = dep_graph_data.prev_fingerprint_of(prev_index);\n \n     if new_hash != old_hash {\n-        incremental_verify_ich_failed(tcx, prev_index, result);\n+        incremental_verify_ich_failed(tcx, prev_index, &|| format_value(&result));\n     }\n }\n \n@@ -677,7 +682,7 @@ where\n fn incremental_verify_ich_failed<Tcx>(\n     tcx: Tcx,\n     prev_index: SerializedDepNodeIndex,\n-    result: &dyn Debug,\n+    result: &dyn Fn() -> String,\n ) where\n     Tcx: DepContext,\n {\n@@ -707,7 +712,7 @@ fn incremental_verify_ich_failed<Tcx>(\n             run_cmd,\n             dep_node: format!(\"{dep_node:?}\"),\n         });\n-        panic!(\"Found unstable fingerprints for {dep_node:?}: {result:?}\");\n+        panic!(\"Found unstable fingerprints for {dep_node:?}: {}\", result());\n     }\n \n     INSIDE_VERIFY_PANIC.with(|in_panic| in_panic.set(old_in_panic));"}, {"sha": "2199ceee532614cedfcddb1da8fb7e596f2fdeec", "filename": "compiler/rustc_resolve/messages.ftl", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6efdf4d1309f8047bc439a4810888c715e2df480/compiler%2Frustc_resolve%2Fmessages.ftl", "raw_url": "https://github.com/rust-lang/rust/raw/6efdf4d1309f8047bc439a4810888c715e2df480/compiler%2Frustc_resolve%2Fmessages.ftl", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fmessages.ftl?ref=6efdf4d1309f8047bc439a4810888c715e2df480", "patch": "@@ -207,5 +207,9 @@ resolve_expected_found =\n resolve_indeterminate =\n     cannot determine resolution for the visibility\n \n+resolve_tool_module_imported =\n+    cannot use a tool module through an import\n+    .note = the tool module imported here\n+\n resolve_module_only =\n     visibility must resolve to a module"}, {"sha": "1f2a90829ec729325796c5552b5051e6ecc054fc", "filename": "compiler/rustc_resolve/src/build_reduced_graph.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/6efdf4d1309f8047bc439a4810888c715e2df480/compiler%2Frustc_resolve%2Fsrc%2Fbuild_reduced_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6efdf4d1309f8047bc439a4810888c715e2df480/compiler%2Frustc_resolve%2Fsrc%2Fbuild_reduced_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Fbuild_reduced_graph.rs?ref=6efdf4d1309f8047bc439a4810888c715e2df480", "patch": "@@ -688,8 +688,8 @@ impl<'a, 'b, 'tcx> BuildReducedGraphVisitor<'a, 'b, 'tcx> {\n             }\n \n             // These items live in the value namespace.\n-            ItemKind::Static(_, mt, _) => {\n-                let res = Res::Def(DefKind::Static(mt), def_id);\n+            ItemKind::Static(box ast::StaticItem { mutability, .. }) => {\n+                let res = Res::Def(DefKind::Static(mutability), def_id);\n                 self.r.define(parent, ident, ValueNS, (res, vis, sp, expansion));\n             }\n             ItemKind::Const(..) => {\n@@ -931,7 +931,7 @@ impl<'a, 'b, 'tcx> BuildReducedGraphVisitor<'a, 'b, 'tcx> {\n     /// Builds the reduced graph for a single item in an external crate.\n     fn build_reduced_graph_for_external_crate_res(&mut self, child: ModChild) {\n         let parent = self.parent_scope.module;\n-        let ModChild { ident, res, vis, span, macro_rules } = child;\n+        let ModChild { ident, res, vis, span, macro_rules, .. } = child;\n         let res = res.expect_non_local();\n         let expansion = self.parent_scope.expansion;\n         // Record primary definitions."}, {"sha": "ae3fd0ede6cffba21b839fc13b7db32adc6812b6", "filename": "compiler/rustc_resolve/src/check_unused.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6efdf4d1309f8047bc439a4810888c715e2df480/compiler%2Frustc_resolve%2Fsrc%2Fcheck_unused.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6efdf4d1309f8047bc439a4810888c715e2df480/compiler%2Frustc_resolve%2Fsrc%2Fcheck_unused.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Fcheck_unused.rs?ref=6efdf4d1309f8047bc439a4810888c715e2df480", "patch": "@@ -393,7 +393,7 @@ impl Resolver<'_, '_> {\n             // If we are in the `--test` mode, suppress a help that adds the `#[cfg(test)]`\n             // attribute; however, if not, suggest adding the attribute. There is no way to\n             // retrieve attributes here because we do not have a `TyCtxt` yet.\n-            let test_module_span = if tcx.sess.opts.test {\n+            let test_module_span = if tcx.sess.is_test_crate() {\n                 None\n             } else {\n                 let parent_module = visitor.r.get_nearest_non_block_module("}, {"sha": "0c9d306081eb8c95673ac940737635d636e77a91", "filename": "compiler/rustc_resolve/src/diagnostics.rs", "status": "modified", "additions": 19, "deletions": 1, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/6efdf4d1309f8047bc439a4810888c715e2df480/compiler%2Frustc_resolve%2Fsrc%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6efdf4d1309f8047bc439a4810888c715e2df480/compiler%2Frustc_resolve%2Fsrc%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Fdiagnostics.rs?ref=6efdf4d1309f8047bc439a4810888c715e2df480", "patch": "@@ -1607,7 +1607,17 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n         let mut err =\n             struct_span_err!(self.tcx.sess, ident.span, E0603, \"{} `{}` is private\", descr, ident);\n         err.span_label(ident.span, &format!(\"private {}\", descr));\n-        if let Some(span) = ctor_fields_span {\n+\n+        let mut non_exhaustive = None;\n+        // If an ADT is foreign and marked as `non_exhaustive`, then that's\n+        // probably why we have the privacy error.\n+        // Otherwise, point out if the struct has any private fields.\n+        if let Some(def_id) = res.opt_def_id()\n+            && !def_id.is_local()\n+            && let Some(attr) = self.tcx.get_attr(def_id, sym::non_exhaustive)\n+        {\n+            non_exhaustive = Some(attr.span);\n+        } else if let Some(span) = ctor_fields_span {\n             err.span_label(span, \"a constructor is private if any of the fields is private\");\n             if let Res::Def(_, d) = res && let Some(fields) = self.field_visibility_spans.get(&d) {\n                 err.multipart_suggestion_verbose(\n@@ -1656,6 +1666,14 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n             if !first && binding.vis.is_public() {\n                 note_span.push_span_label(def_span, \"consider importing it directly\");\n             }\n+            // Final step in the import chain, point out if the ADT is `non_exhaustive`\n+            // which is probably why this privacy violation occurred.\n+            if next_binding.is_none() && let Some(span) = non_exhaustive {\n+                note_span.push_span_label(\n+                    span,\n+                    format!(\"cannot be constructed because it is `#[non_exhaustive]`\"),\n+                );\n+            }\n             err.span_note(note_span, &msg);\n         }\n "}, {"sha": "bed579f6b9258607aa766900b326ac8f4a903ce4", "filename": "compiler/rustc_resolve/src/effective_visibilities.rs", "status": "modified", "additions": 28, "deletions": 8, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/6efdf4d1309f8047bc439a4810888c715e2df480/compiler%2Frustc_resolve%2Fsrc%2Feffective_visibilities.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6efdf4d1309f8047bc439a4810888c715e2df480/compiler%2Frustc_resolve%2Fsrc%2Feffective_visibilities.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Feffective_visibilities.rs?ref=6efdf4d1309f8047bc439a4810888c715e2df480", "patch": "@@ -155,10 +155,6 @@ impl<'r, 'a, 'tcx> EffectiveVisibilitiesVisitor<'r, 'a, 'tcx> {\n         }\n     }\n \n-    fn cheap_private_vis(&self, parent_id: ParentId<'_>) -> Option<Visibility> {\n-        matches!(parent_id, ParentId::Def(_)).then_some(self.current_private_vis)\n-    }\n-\n     fn effective_vis_or_private(&mut self, parent_id: ParentId<'a>) -> EffectiveVisibility {\n         // Private nodes are only added to the table for caching, they could be added or removed at\n         // any moment without consequences, so we don't set `changed` to true when adding them.\n@@ -172,29 +168,53 @@ impl<'r, 'a, 'tcx> EffectiveVisibilitiesVisitor<'r, 'a, 'tcx> {\n         }\n     }\n \n+    /// All effective visibilities for a node are larger or equal than private visibility\n+    /// for that node (see `check_invariants` in middle/privacy.rs).\n+    /// So if either parent or nominal visibility is the same as private visibility, then\n+    /// `min(parent_vis, nominal_vis) <= private_vis`, and the update logic is guaranteed\n+    /// to not update anything and we can skip it.\n+    ///\n+    /// We are checking this condition only if the correct value of private visibility is\n+    /// cheaply available, otherwise it does't make sense performance-wise.\n+    ///\n+    /// `None` is returned if the update can be skipped,\n+    /// and cheap private visibility is returned otherwise.\n+    fn may_update(\n+        &self,\n+        nominal_vis: Visibility,\n+        parent_id: ParentId<'_>,\n+    ) -> Option<Option<Visibility>> {\n+        match parent_id {\n+            ParentId::Def(def_id) => (nominal_vis != self.current_private_vis\n+                && self.r.visibilities[&def_id] != self.current_private_vis)\n+                .then_some(Some(self.current_private_vis)),\n+            ParentId::Import(_) => Some(None),\n+        }\n+    }\n+\n     fn update_import(&mut self, binding: ImportId<'a>, parent_id: ParentId<'a>) {\n         let nominal_vis = binding.vis.expect_local();\n-        let private_vis = self.cheap_private_vis(parent_id);\n+        let Some(cheap_private_vis) = self.may_update(nominal_vis, parent_id) else { return };\n         let inherited_eff_vis = self.effective_vis_or_private(parent_id);\n         let tcx = self.r.tcx;\n         self.changed |= self.import_effective_visibilities.update(\n             binding,\n             nominal_vis,\n-            || private_vis.unwrap_or_else(|| self.r.private_vis_import(binding)),\n+            || cheap_private_vis.unwrap_or_else(|| self.r.private_vis_import(binding)),\n             inherited_eff_vis,\n             parent_id.level(),\n             tcx,\n         );\n     }\n \n     fn update_def(&mut self, def_id: LocalDefId, nominal_vis: Visibility, parent_id: ParentId<'a>) {\n-        let private_vis = self.cheap_private_vis(parent_id);\n+        let Some(cheap_private_vis) = self.may_update(nominal_vis, parent_id) else { return };\n         let inherited_eff_vis = self.effective_vis_or_private(parent_id);\n         let tcx = self.r.tcx;\n         self.changed |= self.def_effective_visibilities.update(\n             def_id,\n             nominal_vis,\n-            || private_vis.unwrap_or_else(|| self.r.private_vis_def(def_id)),\n+            || cheap_private_vis.unwrap_or_else(|| self.r.private_vis_def(def_id)),\n             inherited_eff_vis,\n             parent_id.level(),\n             tcx,"}, {"sha": "07aaaa1eb7f600c0d48e1b0a8346e1397b8f8713", "filename": "compiler/rustc_resolve/src/errors.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/6efdf4d1309f8047bc439a4810888c715e2df480/compiler%2Frustc_resolve%2Fsrc%2Ferrors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6efdf4d1309f8047bc439a4810888c715e2df480/compiler%2Frustc_resolve%2Fsrc%2Ferrors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Ferrors.rs?ref=6efdf4d1309f8047bc439a4810888c715e2df480", "patch": "@@ -469,6 +469,15 @@ pub(crate) struct ExpectedFound {\n #[diag(resolve_indeterminate, code = \"E0578\")]\n pub(crate) struct Indeterminate(#[primary_span] pub(crate) Span);\n \n+#[derive(Diagnostic)]\n+#[diag(resolve_tool_module_imported)]\n+pub(crate) struct ToolModuleImported {\n+    #[primary_span]\n+    pub(crate) span: Span,\n+    #[note]\n+    pub(crate) import: Span,\n+}\n+\n #[derive(Diagnostic)]\n #[diag(resolve_module_only)]\n pub(crate) struct ModuleOnly(#[primary_span] pub(crate) Span);"}, {"sha": "5a56d7b99a978da3c62b9329efd0fb593b5c40d4", "filename": "compiler/rustc_resolve/src/ident.rs", "status": "modified", "additions": 28, "deletions": 25, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/6efdf4d1309f8047bc439a4810888c715e2df480/compiler%2Frustc_resolve%2Fsrc%2Fident.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6efdf4d1309f8047bc439a4810888c715e2df480/compiler%2Frustc_resolve%2Fsrc%2Fident.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Fident.rs?ref=6efdf4d1309f8047bc439a4810888c715e2df480", "patch": "@@ -17,7 +17,7 @@ use crate::late::{\n     ConstantHasGenerics, ConstantItemKind, HasGenericParams, PathSource, Rib, RibKind,\n };\n use crate::macros::{sub_namespace_match, MacroRulesScope};\n-use crate::{AmbiguityError, AmbiguityErrorMisc, AmbiguityKind, Determinacy, Finalize};\n+use crate::{errors, AmbiguityError, AmbiguityErrorMisc, AmbiguityKind, Determinacy, Finalize};\n use crate::{Import, ImportKind, LexicalScopeBinding, Module, ModuleKind, ModuleOrUniformRoot};\n use crate::{NameBinding, NameBindingKind, ParentScope, PathResult, PrivacyError, Res};\n use crate::{ResolutionError, Resolver, Scope, ScopeSet, Segment, ToNameBinding, Weak};\n@@ -869,17 +869,19 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n         let resolution =\n             self.resolution(module, key).try_borrow_mut().map_err(|_| (Determined, Weak::No))?; // This happens when there is a cycle of imports.\n \n-        if let Some(Finalize { path_span, report_private, .. }) = finalize {\n-            // If the primary binding is unusable, search further and return the shadowed glob\n-            // binding if it exists. What we really want here is having two separate scopes in\n-            // a module - one for non-globs and one for globs, but until that's done use this\n-            // hack to avoid inconsistent resolution ICEs during import validation.\n-            let binding = [resolution.binding, resolution.shadowed_glob].into_iter().find_map(\n-                |binding| match (binding, ignore_binding) {\n+        // If the primary binding is unusable, search further and return the shadowed glob\n+        // binding if it exists. What we really want here is having two separate scopes in\n+        // a module - one for non-globs and one for globs, but until that's done use this\n+        // hack to avoid inconsistent resolution ICEs during import validation.\n+        let binding =\n+            [resolution.binding, resolution.shadowed_glob].into_iter().find_map(|binding| {\n+                match (binding, ignore_binding) {\n                     (Some(binding), Some(ignored)) if ptr::eq(binding, ignored) => None,\n                     _ => binding,\n-                },\n-            );\n+                }\n+            });\n+\n+        if let Some(Finalize { path_span, report_private, .. }) = finalize {\n             let Some(binding) = binding else {\n                 return Err((Determined, Weak::No));\n             };\n@@ -927,15 +929,12 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n         }\n \n         let check_usable = |this: &mut Self, binding: &'a NameBinding<'a>| {\n-            if let Some(ignored) = ignore_binding && ptr::eq(binding, ignored) {\n-                return Err((Determined, Weak::No));\n-            }\n             let usable = this.is_accessible_from(binding.vis, parent_scope.module);\n             if usable { Ok(binding) } else { Err((Determined, Weak::No)) }\n         };\n \n         // Items and single imports are not shadowable, if we have one, then it's determined.\n-        if let Some(binding) = resolution.binding {\n+        if let Some(binding) = binding {\n             if !binding.is_glob_import() {\n                 return check_usable(self, binding);\n             }\n@@ -952,6 +951,14 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n             if !self.is_accessible_from(import_vis, parent_scope.module) {\n                 continue;\n             }\n+            if let Some(ignored) = ignore_binding &&\n+                let NameBindingKind::Import { import, .. } = ignored.kind &&\n+                ptr::eq(import, &**single_import) {\n+                // Ignore not just the binding itself, but if it has a shadowed_glob,\n+                // ignore that, too, because this loop is supposed to only process\n+                // named imports.\n+                continue;\n+            }\n             let Some(module) = single_import.imported_module.get() else {\n                 return Err((Undetermined, Weak::No));\n             };\n@@ -989,7 +996,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n         // and prohibit access to macro-expanded `macro_export` macros instead (unless restricted\n         // shadowing is enabled, see `macro_expanded_macro_export_errors`).\n         let unexpanded_macros = !module.unexpanded_invocations.borrow().is_empty();\n-        if let Some(binding) = resolution.binding {\n+        if let Some(binding) = binding {\n             if !unexpanded_macros || ns == MacroNS || restricted_shadowing {\n                 return check_usable(self, binding);\n             } else {\n@@ -1357,7 +1364,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                 }\n             };\n \n-            let is_last = i == path.len() - 1;\n+            let is_last = i + 1 == path.len();\n             let ns = if is_last { opt_ns.unwrap_or(TypeNS) } else { TypeNS };\n             let name = ident.name;\n \n@@ -1494,16 +1501,12 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                     if let Some(next_module) = binding.module() {\n                         module = Some(ModuleOrUniformRoot::Module(next_module));\n                         record_segment_res(self, res);\n-                    } else if res == Res::ToolMod && i + 1 != path.len() {\n+                    } else if res == Res::ToolMod && !is_last && opt_ns.is_some() {\n                         if binding.is_import() {\n-                            self.tcx\n-                                .sess\n-                                .struct_span_err(\n-                                    ident.span,\n-                                    \"cannot use a tool module through an import\",\n-                                )\n-                                .span_note(binding.span, \"the tool module imported here\")\n-                                .emit();\n+                            self.tcx.sess.emit_err(errors::ToolModuleImported {\n+                                span: ident.span,\n+                                import: binding.span,\n+                            });\n                         }\n                         let res = Res::NonMacroAttr(NonMacroAttrKind::Tool);\n                         return PathResult::NonModule(PartialRes::new(res));"}, {"sha": "77bfcb659de106967088562a9cb9a1436f39fa0e", "filename": "compiler/rustc_resolve/src/imports.rs", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/6efdf4d1309f8047bc439a4810888c715e2df480/compiler%2Frustc_resolve%2Fsrc%2Fimports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6efdf4d1309f8047bc439a4810888c715e2df480/compiler%2Frustc_resolve%2Fsrc%2Fimports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Fimports.rs?ref=6efdf4d1309f8047bc439a4810888c715e2df480", "patch": "@@ -17,6 +17,7 @@ use rustc_data_structures::intern::Interned;\n use rustc_errors::{pluralize, struct_span_err, Applicability, MultiSpan};\n use rustc_hir::def::{self, DefKind, PartialRes};\n use rustc_middle::metadata::ModChild;\n+use rustc_middle::metadata::Reexport;\n use rustc_middle::span_bug;\n use rustc_middle::ty;\n use rustc_session::lint::builtin::{\n@@ -27,6 +28,7 @@ use rustc_span::edit_distance::find_best_match_for_name;\n use rustc_span::hygiene::LocalExpnId;\n use rustc_span::symbol::{kw, Ident, Symbol};\n use rustc_span::Span;\n+use smallvec::SmallVec;\n \n use std::cell::Cell;\n use std::{mem, ptr};\n@@ -190,6 +192,17 @@ impl<'a> Import<'a> {\n             ImportKind::MacroUse | ImportKind::MacroExport => None,\n         }\n     }\n+\n+    fn simplify(&self, r: &Resolver<'_, '_>) -> Reexport {\n+        let to_def_id = |id| r.local_def_id(id).to_def_id();\n+        match self.kind {\n+            ImportKind::Single { id, .. } => Reexport::Single(to_def_id(id)),\n+            ImportKind::Glob { id, .. } => Reexport::Glob(to_def_id(id)),\n+            ImportKind::ExternCrate { id, .. } => Reexport::ExternCrate(to_def_id(id)),\n+            ImportKind::MacroUse => Reexport::MacroUse,\n+            ImportKind::MacroExport => Reexport::MacroExport,\n+        }\n+    }\n }\n \n /// Records information about the resolution of a name in a namespace of a module.\n@@ -1252,12 +1265,20 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n \n             module.for_each_child(self, |this, ident, _, binding| {\n                 if let Some(res) = this.is_reexport(binding) {\n+                    let mut reexport_chain = SmallVec::new();\n+                    let mut next_binding = binding;\n+                    while let NameBindingKind::Import { binding, import, .. } = next_binding.kind {\n+                        reexport_chain.push(import.simplify(this));\n+                        next_binding = binding;\n+                    }\n+\n                     reexports.push(ModChild {\n                         ident,\n                         res,\n                         vis: binding.vis,\n                         span: binding.span,\n                         macro_rules: false,\n+                        reexport_chain,\n                     });\n                 }\n             });"}, {"sha": "31ac3f1c151eee95507534a07e8de3227ec82255", "filename": "compiler/rustc_resolve/src/late.rs", "status": "modified", "additions": 39, "deletions": 10, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/6efdf4d1309f8047bc439a4810888c715e2df480/compiler%2Frustc_resolve%2Fsrc%2Flate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6efdf4d1309f8047bc439a4810888c715e2df480/compiler%2Frustc_resolve%2Fsrc%2Flate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Flate.rs?ref=6efdf4d1309f8047bc439a4810888c715e2df480", "patch": "@@ -122,6 +122,12 @@ pub(crate) enum ConstantItemKind {\n     Static,\n }\n \n+#[derive(Debug, Copy, Clone, PartialEq, Eq)]\n+enum RecordPartialRes {\n+    Yes,\n+    No,\n+}\n+\n /// The rib kind restricts certain accesses,\n /// e.g. to a `Res::Local` of an outer item.\n #[derive(Copy, Clone, Debug)]\n@@ -1218,7 +1224,7 @@ impl<'a: 'ast, 'b, 'ast, 'tcx> LateResolutionVisitor<'a, 'b, 'ast, 'tcx> {\n             lifetime_ribs: Vec::new(),\n             lifetime_elision_candidates: None,\n             current_trait_ref: None,\n-            diagnostic_metadata: Box::new(DiagnosticMetadata::default()),\n+            diagnostic_metadata: Default::default(),\n             // errors at module scope should always be reported\n             in_func_body: false,\n             lifetime_uses: Default::default(),\n@@ -2346,7 +2352,8 @@ impl<'a: 'ast, 'b, 'ast, 'tcx> LateResolutionVisitor<'a, 'b, 'ast, 'tcx> {\n                 });\n             }\n \n-            ItemKind::Static(ref ty, _, ref expr) | ItemKind::Const(_, ref ty, ref expr) => {\n+            ItemKind::Static(box ast::StaticItem { ref ty, ref expr, .. })\n+            | ItemKind::Const(box ast::ConstItem { ref ty, ref expr, .. }) => {\n                 self.with_static_rib(|this| {\n                     this.with_lifetime_rib(LifetimeRibKind::Elided(LifetimeRes::Static), |this| {\n                         this.visit_ty(ty);\n@@ -2624,11 +2631,11 @@ impl<'a: 'ast, 'b, 'ast, 'tcx> LateResolutionVisitor<'a, 'b, 'ast, 'tcx> {\n         for item in trait_items {\n             self.resolve_doc_links(&item.attrs, MaybeExported::Ok(item.id));\n             match &item.kind {\n-                AssocItemKind::Const(_, ty, default) => {\n+                AssocItemKind::Const(box ast::ConstItem { ty, expr, .. }) => {\n                     self.visit_ty(ty);\n                     // Only impose the restrictions of `ConstRibKind` for an\n                     // actual constant expression in a provided default.\n-                    if let Some(expr) = default {\n+                    if let Some(expr) = expr {\n                         // We allow arbitrary const expressions inside of associated consts,\n                         // even if they are potentially not const evaluatable.\n                         //\n@@ -2681,6 +2688,7 @@ impl<'a: 'ast, 'b, 'ast, 'tcx> LateResolutionVisitor<'a, 'b, 'ast, 'tcx> {\n                 &path,\n                 PathSource::Trait(AliasPossibility::No),\n                 Finalize::new(trait_ref.ref_id, trait_ref.path.span),\n+                RecordPartialRes::Yes,\n             );\n             self.diagnostic_metadata.currently_processing_impl_trait = None;\n             if let Some(def_id) = res.expect_full_res().opt_def_id() {\n@@ -2799,7 +2807,7 @@ impl<'a: 'ast, 'b, 'ast, 'tcx> LateResolutionVisitor<'a, 'b, 'ast, 'tcx> {\n         use crate::ResolutionError::*;\n         self.resolve_doc_links(&item.attrs, MaybeExported::ImplItem(trait_id.ok_or(&item.vis)));\n         match &item.kind {\n-            AssocItemKind::Const(_, ty, default) => {\n+            AssocItemKind::Const(box ast::ConstItem { ty, expr, .. }) => {\n                 debug!(\"resolve_implementation AssocItemKind::Const\");\n                 // If this is a trait impl, ensure the const\n                 // exists in trait\n@@ -2814,7 +2822,7 @@ impl<'a: 'ast, 'b, 'ast, 'tcx> LateResolutionVisitor<'a, 'b, 'ast, 'tcx> {\n                 );\n \n                 self.visit_ty(ty);\n-                if let Some(expr) = default {\n+                if let Some(expr) = expr {\n                     // We allow arbitrary const expressions inside of associated consts,\n                     // even if they are potentially not const evaluatable.\n                     //\n@@ -3419,6 +3427,7 @@ impl<'a: 'ast, 'b, 'ast, 'tcx> LateResolutionVisitor<'a, 'b, 'ast, 'tcx> {\n             &Segment::from_path(path),\n             source,\n             Finalize::new(id, path.span),\n+            RecordPartialRes::Yes,\n         );\n     }\n \n@@ -3429,6 +3438,7 @@ impl<'a: 'ast, 'b, 'ast, 'tcx> LateResolutionVisitor<'a, 'b, 'ast, 'tcx> {\n         path: &[Segment],\n         source: PathSource<'ast>,\n         finalize: Finalize,\n+        record_partial_res: RecordPartialRes,\n     ) -> PartialRes {\n         let ns = source.namespace();\n \n@@ -3457,8 +3467,8 @@ impl<'a: 'ast, 'b, 'ast, 'tcx> LateResolutionVisitor<'a, 'b, 'ast, 'tcx> {\n                         sugg.to_string(),\n                         Applicability::MaybeIncorrect,\n                     ))\n-                } else if res.is_none() && matches!(source, PathSource::Type) {\n-                    this.report_missing_type_error(path)\n+                } else if res.is_none() && let PathSource::Type | PathSource::Expr(_) = source {\n+                    this.suggest_adding_generic_parameter(path, source)\n                 } else {\n                     None\n                 };\n@@ -3635,7 +3645,7 @@ impl<'a: 'ast, 'b, 'ast, 'tcx> LateResolutionVisitor<'a, 'b, 'ast, 'tcx> {\n             _ => report_errors(self, None),\n         };\n \n-        if !matches!(source, PathSource::TraitItem(..)) {\n+        if record_partial_res == RecordPartialRes::Yes {\n             // Avoid recording definition of `A::B` in `<T as A>::B::C`.\n             self.r.record_partial_res(node_id, partial_res);\n             self.resolve_elided_lifetimes_in_path(node_id, partial_res, path, source, path_span);\n@@ -3739,7 +3749,25 @@ impl<'a: 'ast, 'b, 'ast, 'tcx> LateResolutionVisitor<'a, 'b, 'ast, 'tcx> {\n                 )));\n             }\n \n-            // Make sure `A::B` in `<T as A::B>::C` is a trait item.\n+            let num_privacy_errors = self.r.privacy_errors.len();\n+            // Make sure that `A` in `<T as A>::B::C` is a trait.\n+            let trait_res = self.smart_resolve_path_fragment(\n+                &None,\n+                &path[..qself.position],\n+                PathSource::Trait(AliasPossibility::No),\n+                Finalize::new(finalize.node_id, qself.path_span),\n+                RecordPartialRes::No,\n+            );\n+\n+            if trait_res.expect_full_res() == Res::Err {\n+                return Ok(Some(trait_res));\n+            }\n+\n+            // Truncate additional privacy errors reported above,\n+            // because they'll be recomputed below.\n+            self.r.privacy_errors.truncate(num_privacy_errors);\n+\n+            // Make sure `A::B` in `<T as A>::B::C` is a trait item.\n             //\n             // Currently, `path` names the full item (`A::B::C`, in\n             // our example). so we extract the prefix of that that is\n@@ -3752,6 +3780,7 @@ impl<'a: 'ast, 'b, 'ast, 'tcx> LateResolutionVisitor<'a, 'b, 'ast, 'tcx> {\n                 &path[..=qself.position],\n                 PathSource::TraitItem(ns),\n                 Finalize::with_root_span(finalize.node_id, finalize.path_span, qself.path_span),\n+                RecordPartialRes::No,\n             );\n \n             // The remaining segments (the `C` in our example) will"}, {"sha": "37fbfad2de631fb8ae301111a419ffc16573a774", "filename": "compiler/rustc_resolve/src/late/diagnostics.rs", "status": "modified", "additions": 10, "deletions": 5, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/6efdf4d1309f8047bc439a4810888c715e2df480/compiler%2Frustc_resolve%2Fsrc%2Flate%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6efdf4d1309f8047bc439a4810888c715e2df480/compiler%2Frustc_resolve%2Fsrc%2Flate%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Flate%2Fdiagnostics.rs?ref=6efdf4d1309f8047bc439a4810888c715e2df480", "patch": "@@ -2110,9 +2110,10 @@ impl<'a: 'ast, 'ast, 'tcx> LateResolutionVisitor<'a, '_, 'ast, 'tcx> {\n         }\n     }\n \n-    pub(crate) fn report_missing_type_error(\n+    pub(crate) fn suggest_adding_generic_parameter(\n         &self,\n         path: &[Segment],\n+        source: PathSource<'_>,\n     ) -> Option<(Span, &'static str, String, Applicability)> {\n         let (ident, span) = match path {\n             [segment]\n@@ -2148,7 +2149,6 @@ impl<'a: 'ast, 'ast, 'tcx> LateResolutionVisitor<'a, '_, 'ast, 'tcx> {\n             // Without the 2nd `true`, we'd suggest `impl <T>` for `impl T` when a type `T` isn't found\n             | (Some(Item { kind: kind @ ItemKind::Impl(..), .. }), true, true)\n             | (Some(Item { kind, .. }), false, _) => {\n-                // Likely missing type parameter.\n                 if let Some(generics) = kind.generics() {\n                     if span.overlaps(generics.span) {\n                         // Avoid the following:\n@@ -2161,7 +2161,12 @@ impl<'a: 'ast, 'ast, 'tcx> LateResolutionVisitor<'a, '_, 'ast, 'tcx> {\n                         //   |           not found in this scope\n                         return None;\n                     }\n-                    let msg = \"you might be missing a type parameter\";\n+\n+                    let (msg, sugg) = match source {\n+                        PathSource::Type => (\"you might be missing a type parameter\", ident),\n+                        PathSource::Expr(_) => (\"you might be missing a const parameter\", format!(\"const {ident}: /* Type */\")),\n+                        _ => return None,\n+                    };\n                     let (span, sugg) = if let [.., param] = &generics.params[..] {\n                         let span = if let [.., bound] = &param.bounds[..] {\n                             bound.span()\n@@ -2172,9 +2177,9 @@ impl<'a: 'ast, 'ast, 'tcx> LateResolutionVisitor<'a, '_, 'ast, 'tcx> {\n                         } else {\n                             param.ident.span\n                         };\n-                        (span, format!(\", {}\", ident))\n+                        (span, format!(\", {sugg}\"))\n                     } else {\n-                        (generics.span, format!(\"<{}>\", ident))\n+                        (generics.span, format!(\"<{sugg}>\"))\n                     };\n                     // Do not suggest if this is coming from macro expansion.\n                     if span.can_be_used_for_suggestions() {"}, {"sha": "53e5c89673652621f6e2cd923e6ab2b46154677d", "filename": "compiler/rustc_serialize/src/opaque.rs", "status": "modified", "additions": 0, "deletions": 36, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/6efdf4d1309f8047bc439a4810888c715e2df480/compiler%2Frustc_serialize%2Fsrc%2Fopaque.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6efdf4d1309f8047bc439a4810888c715e2df480/compiler%2Frustc_serialize%2Fsrc%2Fopaque.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_serialize%2Fsrc%2Fopaque.rs?ref=6efdf4d1309f8047bc439a4810888c715e2df480", "patch": "@@ -122,18 +122,6 @@ impl Encoder for MemEncoder {\n         self.emit_u8(if v { 1 } else { 0 });\n     }\n \n-    #[inline]\n-    fn emit_f64(&mut self, v: f64) {\n-        let as_u64: u64 = v.to_bits();\n-        self.emit_u64(as_u64);\n-    }\n-\n-    #[inline]\n-    fn emit_f32(&mut self, v: f32) {\n-        let as_u32: u32 = v.to_bits();\n-        self.emit_u32(as_u32);\n-    }\n-\n     #[inline]\n     fn emit_char(&mut self, v: char) {\n         self.emit_u32(v as u32);\n@@ -500,18 +488,6 @@ impl Encoder for FileEncoder {\n         self.emit_u8(if v { 1 } else { 0 });\n     }\n \n-    #[inline]\n-    fn emit_f64(&mut self, v: f64) {\n-        let as_u64: u64 = v.to_bits();\n-        self.emit_u64(as_u64);\n-    }\n-\n-    #[inline]\n-    fn emit_f32(&mut self, v: f32) {\n-        let as_u32: u32 = v.to_bits();\n-        self.emit_u32(as_u32);\n-    }\n-\n     #[inline]\n     fn emit_char(&mut self, v: char) {\n         self.emit_u32(v as u32);\n@@ -642,18 +618,6 @@ impl<'a> Decoder for MemDecoder<'a> {\n         value != 0\n     }\n \n-    #[inline]\n-    fn read_f64(&mut self) -> f64 {\n-        let bits = self.read_u64();\n-        f64::from_bits(bits)\n-    }\n-\n-    #[inline]\n-    fn read_f32(&mut self) -> f32 {\n-        let bits = self.read_u32();\n-        f32::from_bits(bits)\n-    }\n-\n     #[inline]\n     fn read_char(&mut self) -> char {\n         let bits = self.read_u32();"}, {"sha": "527abc23727153e96d7d01788a499c1586d3e659", "filename": "compiler/rustc_serialize/src/serialize.rs", "status": "modified", "additions": 10, "deletions": 6, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/6efdf4d1309f8047bc439a4810888c715e2df480/compiler%2Frustc_serialize%2Fsrc%2Fserialize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6efdf4d1309f8047bc439a4810888c715e2df480/compiler%2Frustc_serialize%2Fsrc%2Fserialize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_serialize%2Fsrc%2Fserialize.rs?ref=6efdf4d1309f8047bc439a4810888c715e2df480", "patch": "@@ -22,6 +22,11 @@ use std::sync::Arc;\n /// be processed or ignored, whichever is appropriate. Then they should provide\n /// a `finish` method that finishes up encoding. If the encoder is fallible,\n /// `finish` should return a `Result` that indicates success or failure.\n+///\n+/// This current does not support `f32` nor `f64`, as they're not needed in any\n+/// serialized data structures. That could be changed, but consider whether it\n+/// really makes sense to store floating-point values at all.\n+/// (If you need it, revert <https://github.com/rust-lang/rust/pull/109984>.)\n pub trait Encoder {\n     // Primitive types:\n     fn emit_usize(&mut self, v: usize);\n@@ -37,8 +42,6 @@ pub trait Encoder {\n     fn emit_i16(&mut self, v: i16);\n     fn emit_i8(&mut self, v: i8);\n     fn emit_bool(&mut self, v: bool);\n-    fn emit_f64(&mut self, v: f64);\n-    fn emit_f32(&mut self, v: f32);\n     fn emit_char(&mut self, v: char);\n     fn emit_str(&mut self, v: &str);\n     fn emit_raw_bytes(&mut self, s: &[u8]);\n@@ -58,6 +61,11 @@ pub trait Encoder {\n // top-level invocation would also just panic on failure. Switching to\n // infallibility made things faster and lots of code a little simpler and more\n // concise.\n+///\n+/// This current does not support `f32` nor `f64`, as they're not needed in any\n+/// serialized data structures. That could be changed, but consider whether it\n+/// really makes sense to store floating-point values at all.\n+/// (If you need it, revert <https://github.com/rust-lang/rust/pull/109984>.)\n pub trait Decoder {\n     // Primitive types:\n     fn read_usize(&mut self) -> usize;\n@@ -73,8 +81,6 @@ pub trait Decoder {\n     fn read_i16(&mut self) -> i16;\n     fn read_i8(&mut self) -> i8;\n     fn read_bool(&mut self) -> bool;\n-    fn read_f64(&mut self) -> f64;\n-    fn read_f32(&mut self) -> f32;\n     fn read_char(&mut self) -> char;\n     fn read_str(&mut self) -> &str;\n     fn read_raw_bytes(&mut self, len: usize) -> &[u8];\n@@ -143,8 +149,6 @@ direct_serialize_impls! {\n     i64 emit_i64 read_i64,\n     i128 emit_i128 read_i128,\n \n-    f32 emit_f32 read_f32,\n-    f64 emit_f64 read_f64,\n     bool emit_bool read_bool,\n     char emit_char read_char\n }"}, {"sha": "5e7dd18aa84086100b39ef4d8bec4533a63724bd", "filename": "compiler/rustc_serialize/tests/opaque.rs", "status": "modified", "additions": 4, "deletions": 28, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/6efdf4d1309f8047bc439a4810888c715e2df480/compiler%2Frustc_serialize%2Ftests%2Fopaque.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6efdf4d1309f8047bc439a4810888c715e2df480/compiler%2Frustc_serialize%2Ftests%2Fopaque.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_serialize%2Ftests%2Fopaque.rs?ref=6efdf4d1309f8047bc439a4810888c715e2df480", "patch": "@@ -22,8 +22,6 @@ struct Struct {\n \n     l: char,\n     m: String,\n-    n: f32,\n-    o: f64,\n     p: bool,\n     q: Option<u32>,\n }\n@@ -119,24 +117,6 @@ fn test_bool() {\n     check_round_trip(vec![false, true, true, false, false]);\n }\n \n-#[test]\n-fn test_f32() {\n-    let mut vec = vec![];\n-    for i in -100..100 {\n-        vec.push((i as f32) / 3.0);\n-    }\n-    check_round_trip(vec);\n-}\n-\n-#[test]\n-fn test_f64() {\n-    let mut vec = vec![];\n-    for i in -100..100 {\n-        vec.push((i as f64) / 3.0);\n-    }\n-    check_round_trip(vec);\n-}\n-\n #[test]\n fn test_char() {\n     let vec = vec!['a', 'b', 'c', 'd', 'A', 'X', ' ', '#', '\u00d6', '\u00c4', '\u00b5', '\u20ac'];\n@@ -200,8 +180,6 @@ fn test_struct() {\n \n         l: 'x',\n         m: \"abc\".to_string(),\n-        n: 20.5,\n-        o: 21.5,\n         p: false,\n         q: None,\n     }]);\n@@ -222,8 +200,6 @@ fn test_struct() {\n \n         l: 'y',\n         m: \"def\".to_string(),\n-        n: -20.5,\n-        o: -21.5,\n         p: true,\n         q: Some(1234567),\n     }]);\n@@ -232,15 +208,15 @@ fn test_struct() {\n #[derive(PartialEq, Clone, Debug, Encodable, Decodable)]\n enum Enum {\n     Variant1,\n-    Variant2(usize, f32),\n+    Variant2(usize, u32),\n     Variant3 { a: i32, b: char, c: bool },\n }\n \n #[test]\n fn test_enum() {\n     check_round_trip(vec![\n         Enum::Variant1,\n-        Enum::Variant2(1, 2.5),\n+        Enum::Variant2(1, 25),\n         Enum::Variant3 { a: 3, b: 'b', c: false },\n         Enum::Variant3 { a: -4, b: 'f', c: true },\n     ]);\n@@ -269,8 +245,8 @@ fn test_hash_map() {\n \n #[test]\n fn test_tuples() {\n-    check_round_trip(vec![('x', (), false, 0.5f32)]);\n-    check_round_trip(vec![(9i8, 10u16, 1.5f64)]);\n+    check_round_trip(vec![('x', (), false, 5u32)]);\n+    check_round_trip(vec![(9i8, 10u16, 15i64)]);\n     check_round_trip(vec![(-12i16, 11u8, 12usize)]);\n     check_round_trip(vec![(1234567isize, 100000000000000u64, 99999999999999i64)]);\n     check_round_trip(vec![(String::new(), \"some string\".to_string())]);"}, {"sha": "acfb36c97d0c6fd3a3ec0623eea54954a2ae445c", "filename": "compiler/rustc_session/src/config.rs", "status": "modified", "additions": 23, "deletions": 29, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/6efdf4d1309f8047bc439a4810888c715e2df480/compiler%2Frustc_session%2Fsrc%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6efdf4d1309f8047bc439a4810888c715e2df480/compiler%2Frustc_session%2Fsrc%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_session%2Fsrc%2Fconfig.rs?ref=6efdf4d1309f8047bc439a4810888c715e2df480", "patch": "@@ -260,6 +260,8 @@ pub enum SymbolManglingVersion {\n #[derive(Clone, Copy, Debug, PartialEq, Hash)]\n pub enum DebugInfo {\n     None,\n+    LineDirectivesOnly,\n+    LineTablesOnly,\n     Limited,\n     Full,\n }\n@@ -580,6 +582,7 @@ pub enum PrintRequest {\n     CodeModels,\n     TlsModels,\n     TargetSpec,\n+    AllTargetSpecs,\n     NativeStaticLibs,\n     StackProtectorStrategies,\n     LinkArgs,\n@@ -1255,7 +1258,7 @@ pub fn build_configuration(sess: &Session, mut user_cfg: CrateConfig) -> CrateCo\n     // some default and generated configuration items.\n     let default_cfg = default_configuration(sess);\n     // If the user wants a test runner, then add the test cfg.\n-    if sess.opts.test {\n+    if sess.is_test_crate() {\n         user_cfg.insert((sym::test, None));\n     }\n     user_cfg.extend(default_cfg.iter().cloned());\n@@ -1423,7 +1426,7 @@ pub fn rustc_short_optgroups() -> Vec<RustcOptGroup> {\n         opt::opt_s(\n             \"\",\n             \"edition\",\n-            &*EDITION_STRING,\n+            &EDITION_STRING,\n             EDITION_NAME_LIST,\n         ),\n         opt::multi_s(\n@@ -1439,8 +1442,8 @@ pub fn rustc_short_optgroups() -> Vec<RustcOptGroup> {\n             \"Compiler information to print on stdout\",\n             \"[crate-name|file-names|sysroot|target-libdir|cfg|calling-conventions|\\\n              target-list|target-cpus|target-features|relocation-models|code-models|\\\n-             tls-models|target-spec-json|native-static-libs|stack-protector-strategies|\\\n-             link-args]\",\n+             tls-models|target-spec-json|all-target-specs-json|native-static-libs|\\\n+             stack-protector-strategies|link-args]\",\n         ),\n         opt::flagmulti_s(\"g\", \"\", \"Equivalent to -C debuginfo=2\"),\n         opt::flagmulti_s(\"O\", \"\", \"Equivalent to -C opt-level=2\"),\n@@ -1887,6 +1890,7 @@ fn collect_print_requests(\n         (\"native-static-libs\", PrintRequest::NativeStaticLibs),\n         (\"stack-protector-strategies\", PrintRequest::StackProtectorStrategies),\n         (\"target-spec-json\", PrintRequest::TargetSpec),\n+        (\"all-target-specs-json\", PrintRequest::AllTargetSpecs),\n         (\"link-args\", PrintRequest::LinkArgs),\n         (\"split-debuginfo\", PrintRequest::SplitDebuginfo),\n     ];\n@@ -1900,7 +1904,18 @@ fn collect_print_requests(\n                     early_error(\n                         error_format,\n                         \"the `-Z unstable-options` flag must also be passed to \\\n-                     enable the target-spec-json print option\",\n+                         enable the target-spec-json print option\",\n+                    );\n+                }\n+            }\n+            Some((_, PrintRequest::AllTargetSpecs)) => {\n+                if unstable_opts.unstable_options {\n+                    PrintRequest::AllTargetSpecs\n+                } else {\n+                    early_error(\n+                        error_format,\n+                        \"the `-Z unstable-options` flag must also be passed to \\\n+                         enable the all-target-specs-json print option\",\n                     );\n                 }\n             }\n@@ -1979,11 +1994,7 @@ fn parse_opt_level(\n     }\n }\n \n-fn select_debuginfo(\n-    matches: &getopts::Matches,\n-    cg: &CodegenOptions,\n-    error_format: ErrorOutputType,\n-) -> DebugInfo {\n+fn select_debuginfo(matches: &getopts::Matches, cg: &CodegenOptions) -> DebugInfo {\n     let max_g = matches.opt_positions(\"g\").into_iter().max();\n     let max_c = matches\n         .opt_strs_pos(\"C\")\n@@ -1993,24 +2004,7 @@ fn select_debuginfo(\n             if let Some(\"debuginfo\") = s.split('=').next() { Some(i) } else { None }\n         })\n         .max();\n-    if max_g > max_c {\n-        DebugInfo::Full\n-    } else {\n-        match cg.debuginfo {\n-            0 => DebugInfo::None,\n-            1 => DebugInfo::Limited,\n-            2 => DebugInfo::Full,\n-            arg => {\n-                early_error(\n-                    error_format,\n-                    &format!(\n-                        \"debug info level needs to be between \\\n-                         0-2 (instead was `{arg}`)\"\n-                    ),\n-                );\n-            }\n-        }\n-    }\n+    if max_g > max_c { DebugInfo::Full } else { cg.debuginfo }\n }\n \n pub(crate) fn parse_assert_incr_state(\n@@ -2498,7 +2492,7 @@ pub fn build_session_options(matches: &getopts::Matches) -> Options {\n     // to use them interchangeably. See the note above (regarding `-O` and `-C opt-level`)\n     // for more details.\n     let debug_assertions = cg.debug_assertions.unwrap_or(opt_level == OptLevel::No);\n-    let debuginfo = select_debuginfo(matches, &cg, error_format);\n+    let debuginfo = select_debuginfo(matches, &cg);\n \n     let mut search_paths = vec![];\n     for s in &matches.opt_strs(\"L\") {"}, {"sha": "dd1721801f37fa1c99d1e478e574103fbd70e86a", "filename": "compiler/rustc_session/src/cstore.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6efdf4d1309f8047bc439a4810888c715e2df480/compiler%2Frustc_session%2Fsrc%2Fcstore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6efdf4d1309f8047bc439a4810888c715e2df480/compiler%2Frustc_session%2Fsrc%2Fcstore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_session%2Fsrc%2Fcstore.rs?ref=6efdf4d1309f8047bc439a4810888c715e2df480", "patch": "@@ -6,7 +6,7 @@ use crate::search_paths::PathKind;\n use crate::utils::NativeLibKind;\n use crate::Session;\n use rustc_ast as ast;\n-use rustc_data_structures::sync::{self, AppendOnlyVec, MetadataRef, RwLock};\n+use rustc_data_structures::sync::{self, AppendOnlyIndexVec, MetadataRef, RwLock};\n use rustc_hir::def_id::{CrateNum, DefId, LocalDefId, StableCrateId, LOCAL_CRATE};\n use rustc_hir::definitions::{DefKey, DefPath, DefPathHash, Definitions};\n use rustc_span::hygiene::{ExpnHash, ExpnId};\n@@ -257,6 +257,6 @@ pub type CrateStoreDyn = dyn CrateStore + sync::Sync + sync::Send;\n pub struct Untracked {\n     pub cstore: RwLock<Box<CrateStoreDyn>>,\n     /// Reference span for definitions.\n-    pub source_span: AppendOnlyVec<LocalDefId, Span>,\n+    pub source_span: AppendOnlyIndexVec<LocalDefId, Span>,\n     pub definitions: RwLock<Definitions>,\n }"}, {"sha": "631dd0a2146e8b2aeb7bc2de6f4d136e426eaa6c", "filename": "compiler/rustc_session/src/options.rs", "status": "modified", "additions": 16, "deletions": 3, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/6efdf4d1309f8047bc439a4810888c715e2df480/compiler%2Frustc_session%2Fsrc%2Foptions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6efdf4d1309f8047bc439a4810888c715e2df480/compiler%2Frustc_session%2Fsrc%2Foptions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_session%2Fsrc%2Foptions.rs?ref=6efdf4d1309f8047bc439a4810888c715e2df480", "patch": "@@ -377,6 +377,7 @@ mod desc {\n     pub const parse_cfguard: &str =\n         \"either a boolean (`yes`, `no`, `on`, `off`, etc), `checks`, or `nochecks`\";\n     pub const parse_cfprotection: &str = \"`none`|`no`|`n` (default), `branch`, `return`, or `full`|`yes`|`y` (equivalent to `branch` and `return`)\";\n+    pub const parse_debuginfo: &str = \"either an integer (0, 1, 2), `none`, `line-directives-only`, `line-tables-only`, `limited`, or `full`\";\n     pub const parse_strip: &str = \"either `none`, `debuginfo`, or `symbols`\";\n     pub const parse_linker_flavor: &str = ::rustc_target::spec::LinkerFlavorCli::one_of();\n     pub const parse_optimization_fuel: &str = \"crate=integer\";\n@@ -767,6 +768,18 @@ mod parse {\n         true\n     }\n \n+    pub(crate) fn parse_debuginfo(slot: &mut DebugInfo, v: Option<&str>) -> bool {\n+        match v {\n+            Some(\"0\") | Some(\"none\") => *slot = DebugInfo::None,\n+            Some(\"line-directives-only\") => *slot = DebugInfo::LineDirectivesOnly,\n+            Some(\"line-tables-only\") => *slot = DebugInfo::LineTablesOnly,\n+            Some(\"1\") | Some(\"limited\") => *slot = DebugInfo::Limited,\n+            Some(\"2\") | Some(\"full\") => *slot = DebugInfo::Full,\n+            _ => return false,\n+        }\n+        true\n+    }\n+\n     pub(crate) fn parse_linker_flavor(slot: &mut Option<LinkerFlavorCli>, v: Option<&str>) -> bool {\n         match v.and_then(LinkerFlavorCli::from_str) {\n             Some(lf) => *slot = Some(lf),\n@@ -1217,9 +1230,9 @@ options! {\n         \"use Windows Control Flow Guard (default: no)\"),\n     debug_assertions: Option<bool> = (None, parse_opt_bool, [TRACKED],\n         \"explicitly enable the `cfg(debug_assertions)` directive\"),\n-    debuginfo: usize = (0, parse_number, [TRACKED],\n-        \"debug info emission level (0 = no debug info, 1 = line tables only, \\\n-        2 = full debug info with variable and type information; default: 0)\"),\n+    debuginfo: DebugInfo = (DebugInfo::None, parse_debuginfo, [TRACKED],\n+        \"debug info emission level (0-2, none, line-directives-only, \\\n+        line-tables-only, limited, or full; default: 0)\"),\n     default_linker_libraries: bool = (false, parse_bool, [UNTRACKED],\n         \"allow the linker to link its default libraries (default: no)\"),\n     embed_bitcode: bool = (true, parse_bool, [TRACKED],"}, {"sha": "15e27952cf50f34a873b5fccd6e7c3bd29c08f74", "filename": "compiler/rustc_session/src/parse.rs", "status": "modified", "additions": 21, "deletions": 20, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/6efdf4d1309f8047bc439a4810888c715e2df480/compiler%2Frustc_session%2Fsrc%2Fparse.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6efdf4d1309f8047bc439a4810888c715e2df480/compiler%2Frustc_session%2Fsrc%2Fparse.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_session%2Fsrc%2Fparse.rs?ref=6efdf4d1309f8047bc439a4810888c715e2df480", "patch": "@@ -8,7 +8,7 @@ use crate::lint::{\n };\n use rustc_ast::node_id::NodeId;\n use rustc_data_structures::fx::{FxHashMap, FxHashSet, FxIndexSet};\n-use rustc_data_structures::sync::{Lock, Lrc};\n+use rustc_data_structures::sync::{AppendOnlyVec, AtomicBool, Lock, Lrc};\n use rustc_errors::{emitter::SilentEmitter, ColorConfig, Handler};\n use rustc_errors::{\n     fallback_fluent_bundle, Diagnostic, DiagnosticBuilder, DiagnosticId, DiagnosticMessage,\n@@ -84,12 +84,12 @@ impl SymbolGallery {\n \n /// Construct a diagnostic for a language feature error due to the given `span`.\n /// The `feature`'s `Symbol` is the one you used in `active.rs` and `rustc_span::symbols`.\n-pub fn feature_err<'a>(\n-    sess: &'a ParseSess,\n+pub fn feature_err(\n+    sess: &ParseSess,\n     feature: Symbol,\n     span: impl Into<MultiSpan>,\n     explain: impl Into<DiagnosticMessage>,\n-) -> DiagnosticBuilder<'a, ErrorGuaranteed> {\n+) -> DiagnosticBuilder<'_, ErrorGuaranteed> {\n     feature_err_issue(sess, feature, span, GateIssue::Language, explain)\n }\n \n@@ -98,20 +98,21 @@ pub fn feature_err<'a>(\n /// This variant allows you to control whether it is a library or language feature.\n /// Almost always, you want to use this for a language feature. If so, prefer `feature_err`.\n #[track_caller]\n-pub fn feature_err_issue<'a>(\n-    sess: &'a ParseSess,\n+pub fn feature_err_issue(\n+    sess: &ParseSess,\n     feature: Symbol,\n     span: impl Into<MultiSpan>,\n     issue: GateIssue,\n     explain: impl Into<DiagnosticMessage>,\n-) -> DiagnosticBuilder<'a, ErrorGuaranteed> {\n+) -> DiagnosticBuilder<'_, ErrorGuaranteed> {\n     let span = span.into();\n \n     // Cancel an earlier warning for this same error, if it exists.\n     if let Some(span) = span.primary_span() {\n-        sess.span_diagnostic\n-            .steal_diagnostic(span, StashKey::EarlySyntaxWarning)\n-            .map(|err| err.cancel());\n+        if let Some(err) = sess.span_diagnostic.steal_diagnostic(span, StashKey::EarlySyntaxWarning)\n+        {\n+            err.cancel()\n+        }\n     }\n \n     let mut err = sess.create_err(FeatureGateError { span, explain: explain.into() });\n@@ -194,7 +195,7 @@ pub struct ParseSess {\n     pub edition: Edition,\n     /// Places where raw identifiers were used. This is used to avoid complaining about idents\n     /// clashing with keywords in new editions.\n-    pub raw_identifier_spans: Lock<Vec<Span>>,\n+    pub raw_identifier_spans: AppendOnlyVec<Span>,\n     /// Places where identifiers that contain invalid Unicode codepoints but that look like they\n     /// should be. Useful to avoid bad tokenization when encountering emoji. We group them to\n     /// provide a single error per unique incorrect identifier.\n@@ -208,7 +209,7 @@ pub struct ParseSess {\n     pub gated_spans: GatedSpans,\n     pub symbol_gallery: SymbolGallery,\n     /// The parser has reached `Eof` due to an unclosed brace. Used to silence unnecessary errors.\n-    pub reached_eof: Lock<bool>,\n+    pub reached_eof: AtomicBool,\n     /// Environment variables accessed during the build and their values when they exist.\n     pub env_depinfo: Lock<FxHashSet<(Symbol, Option<Symbol>)>>,\n     /// File paths accessed during the build.\n@@ -219,7 +220,7 @@ pub struct ParseSess {\n     pub assume_incomplete_release: bool,\n     /// Spans passed to `proc_macro::quote_span`. Each span has a numerical\n     /// identifier represented by its position in the vector.\n-    pub proc_macro_quoted_spans: Lock<Vec<Span>>,\n+    pub proc_macro_quoted_spans: AppendOnlyVec<Span>,\n     /// Used to generate new `AttrId`s. Every `AttrId` is unique.\n     pub attr_id_generator: AttrIdGenerator,\n }\n@@ -247,14 +248,14 @@ impl ParseSess {\n             config: FxIndexSet::default(),\n             check_config: CrateCheckConfig::default(),\n             edition: ExpnId::root().expn_data().edition,\n-            raw_identifier_spans: Lock::new(Vec::new()),\n+            raw_identifier_spans: Default::default(),\n             bad_unicode_identifiers: Lock::new(Default::default()),\n             source_map,\n             buffered_lints: Lock::new(vec![]),\n             ambiguous_block_expr_parse: Lock::new(FxHashMap::default()),\n             gated_spans: GatedSpans::default(),\n             symbol_gallery: SymbolGallery::default(),\n-            reached_eof: Lock::new(false),\n+            reached_eof: AtomicBool::new(false),\n             env_depinfo: Default::default(),\n             file_depinfo: Default::default(),\n             type_ascription_path_suggestions: Default::default(),\n@@ -324,13 +325,13 @@ impl ParseSess {\n     }\n \n     pub fn save_proc_macro_span(&self, span: Span) -> usize {\n-        let mut spans = self.proc_macro_quoted_spans.lock();\n-        spans.push(span);\n-        return spans.len() - 1;\n+        self.proc_macro_quoted_spans.push(span)\n     }\n \n-    pub fn proc_macro_quoted_spans(&self) -> Vec<Span> {\n-        self.proc_macro_quoted_spans.lock().clone()\n+    pub fn proc_macro_quoted_spans(&self) -> impl Iterator<Item = (usize, Span)> + '_ {\n+        // This is equivalent to `.iter().copied().enumerate()`, but that isn't possible for\n+        // AppendOnlyVec, so we resort to this scheme.\n+        self.proc_macro_quoted_spans.iter_enumerated()\n     }\n \n     #[track_caller]"}, {"sha": "340bb158e1791e593e97b7185cb6de22fbc913e2", "filename": "compiler/rustc_session/src/session.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/6efdf4d1309f8047bc439a4810888c715e2df480/compiler%2Frustc_session%2Fsrc%2Fsession.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6efdf4d1309f8047bc439a4810888c715e2df480/compiler%2Frustc_session%2Fsrc%2Fsession.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_session%2Fsrc%2Fsession.rs?ref=6efdf4d1309f8047bc439a4810888c715e2df480", "patch": "@@ -294,6 +294,11 @@ impl Session {\n         self.crate_types.get().unwrap().as_slice()\n     }\n \n+    /// Returns true if the crate is a testing one.\n+    pub fn is_test_crate(&self) -> bool {\n+        self.opts.test\n+    }\n+\n     pub fn needs_crate_hash(&self) -> bool {\n         // Why is the crate hash needed for these configurations?\n         // - debug_assertions: for the \"fingerprint the result\" check in"}, {"sha": "0befff894ef31e6f28a4c9cd6df15a90116708cf", "filename": "compiler/rustc_smir/src/rustc_smir/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6efdf4d1309f8047bc439a4810888c715e2df480/compiler%2Frustc_smir%2Fsrc%2Frustc_smir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6efdf4d1309f8047bc439a4810888c715e2df480/compiler%2Frustc_smir%2Fsrc%2Frustc_smir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_smir%2Fsrc%2Frustc_smir%2Fmod.rs?ref=6efdf4d1309f8047bc439a4810888c715e2df480", "patch": "@@ -143,7 +143,7 @@ fn rustc_terminator_to_terminator(\n             otherwise: targets.otherwise().as_usize(),\n         },\n         Resume => Terminator::Resume,\n-        Abort => Terminator::Abort,\n+        Terminate => Terminator::Abort,\n         Return => Terminator::Return,\n         Unreachable => Terminator::Unreachable,\n         Drop { .. } => todo!(),"}, {"sha": "9fe9e3a7a5fd22cd2feafc6800e48e47304f4168", "filename": "compiler/rustc_span/src/edit_distance.rs", "status": "modified", "additions": 29, "deletions": 3, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/6efdf4d1309f8047bc439a4810888c715e2df480/compiler%2Frustc_span%2Fsrc%2Fedit_distance.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6efdf4d1309f8047bc439a4810888c715e2df480/compiler%2Frustc_span%2Fsrc%2Fedit_distance.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_span%2Fsrc%2Fedit_distance.rs?ref=6efdf4d1309f8047bc439a4810888c715e2df480", "patch": "@@ -174,10 +174,10 @@ pub fn find_best_match_for_name(\n fn find_best_match_for_name_impl(\n     use_substring_score: bool,\n     candidates: &[Symbol],\n-    lookup: Symbol,\n+    lookup_symbol: Symbol,\n     dist: Option<usize>,\n ) -> Option<Symbol> {\n-    let lookup = lookup.as_str();\n+    let lookup = lookup_symbol.as_str();\n     let lookup_uppercase = lookup.to_uppercase();\n \n     // Priority of matches:\n@@ -190,6 +190,8 @@ fn find_best_match_for_name_impl(\n \n     let mut dist = dist.unwrap_or_else(|| cmp::max(lookup.len(), 3) / 3);\n     let mut best = None;\n+    // store the candidates with the same distance, only for `use_substring_score` current.\n+    let mut next_candidates = vec![];\n     for c in candidates {\n         match if use_substring_score {\n             edit_distance_with_substrings(lookup, c.as_str(), dist)\n@@ -198,12 +200,36 @@ fn find_best_match_for_name_impl(\n         } {\n             Some(0) => return Some(*c),\n             Some(d) => {\n-                dist = d - 1;\n+                if use_substring_score {\n+                    if d < dist {\n+                        dist = d;\n+                        next_candidates.clear();\n+                    } else {\n+                        // `d == dist` here, we need to store the candidates with the same distance\n+                        // so we won't decrease the distance in the next loop.\n+                    }\n+                    next_candidates.push(*c);\n+                } else {\n+                    dist = d - 1;\n+                }\n                 best = Some(*c);\n             }\n             None => {}\n         }\n     }\n+\n+    // We have a tie among several candidates, try to select the best among them ignoring substrings.\n+    // For example, the candidates list `force_capture`, `capture`, and user inputed `forced_capture`,\n+    // we select `force_capture` with a extra round of edit distance calculation.\n+    if next_candidates.len() > 1 {\n+        debug_assert!(use_substring_score);\n+        best = find_best_match_for_name_impl(\n+            false,\n+            &next_candidates,\n+            lookup_symbol,\n+            Some(lookup.len()),\n+        );\n+    }\n     if best.is_some() {\n         return best;\n     }"}, {"sha": "aa8859ed1a358e4871209ca000ad8adf4664a051", "filename": "compiler/rustc_span/src/lib.rs", "status": "modified", "additions": 21, "deletions": 3, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/6efdf4d1309f8047bc439a4810888c715e2df480/compiler%2Frustc_span%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6efdf4d1309f8047bc439a4810888c715e2df480/compiler%2Frustc_span%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_span%2Fsrc%2Flib.rs?ref=6efdf4d1309f8047bc439a4810888c715e2df480", "patch": "@@ -1318,7 +1318,6 @@ pub struct SourceFileDiffs {\n }\n \n /// A single source in the [`SourceMap`].\n-#[derive(Clone)]\n pub struct SourceFile {\n     /// The name of the file that the source came from. Source that doesn't\n     /// originate from files has names between angle brackets by convention\n@@ -1349,6 +1348,25 @@ pub struct SourceFile {\n     pub cnum: CrateNum,\n }\n \n+impl Clone for SourceFile {\n+    fn clone(&self) -> Self {\n+        Self {\n+            name: self.name.clone(),\n+            src: self.src.clone(),\n+            src_hash: self.src_hash,\n+            external_src: Lock::new(self.external_src.borrow().clone()),\n+            start_pos: self.start_pos,\n+            end_pos: self.end_pos,\n+            lines: Lock::new(self.lines.borrow().clone()),\n+            multibyte_chars: self.multibyte_chars.clone(),\n+            non_narrow_chars: self.non_narrow_chars.clone(),\n+            normalized_pos: self.normalized_pos.clone(),\n+            name_hash: self.name_hash,\n+            cnum: self.cnum,\n+        }\n+    }\n+}\n+\n impl<S: Encoder> Encodable<S> for SourceFile {\n     fn encode(&self, s: &mut S) {\n         self.name.encode(s);\n@@ -2033,13 +2051,13 @@ pub type FileLinesResult = Result<FileLines, SpanLinesError>;\n \n #[derive(Clone, PartialEq, Eq, Debug)]\n pub enum SpanLinesError {\n-    DistinctSources(DistinctSources),\n+    DistinctSources(Box<DistinctSources>),\n }\n \n #[derive(Clone, PartialEq, Eq, Debug)]\n pub enum SpanSnippetError {\n     IllFormedSpan(Span),\n-    DistinctSources(DistinctSources),\n+    DistinctSources(Box<DistinctSources>),\n     MalformedForSourcemap(MalformedSourceMapPositions),\n     SourceNotAvailable { filename: FileName },\n }"}, {"sha": "88e3674f8994344460913c8486168b1cfba2f3b2", "filename": "compiler/rustc_span/src/source_map.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/6efdf4d1309f8047bc439a4810888c715e2df480/compiler%2Frustc_span%2Fsrc%2Fsource_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6efdf4d1309f8047bc439a4810888c715e2df480/compiler%2Frustc_span%2Fsrc%2Fsource_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_span%2Fsrc%2Fsource_map.rs?ref=6efdf4d1309f8047bc439a4810888c715e2df480", "patch": "@@ -542,10 +542,10 @@ impl SourceMap {\n         let hi = self.lookup_char_pos(sp.hi());\n         trace!(?hi);\n         if lo.file.start_pos != hi.file.start_pos {\n-            return Err(SpanLinesError::DistinctSources(DistinctSources {\n+            return Err(SpanLinesError::DistinctSources(Box::new(DistinctSources {\n                 begin: (lo.file.name.clone(), lo.file.start_pos),\n                 end: (hi.file.name.clone(), hi.file.start_pos),\n-            }));\n+            })));\n         }\n         Ok((lo, hi))\n     }\n@@ -603,10 +603,10 @@ impl SourceMap {\n         let local_end = self.lookup_byte_offset(sp.hi());\n \n         if local_begin.sf.start_pos != local_end.sf.start_pos {\n-            Err(SpanSnippetError::DistinctSources(DistinctSources {\n+            Err(SpanSnippetError::DistinctSources(Box::new(DistinctSources {\n                 begin: (local_begin.sf.name.clone(), local_begin.sf.start_pos),\n                 end: (local_end.sf.name.clone(), local_end.sf.start_pos),\n-            }))\n+            })))\n         } else {\n             self.ensure_source_file_source_present(local_begin.sf.clone());\n "}, {"sha": "7affad9aa0171fd85d4557205c9420b867d34275", "filename": "compiler/rustc_span/src/symbol.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/6efdf4d1309f8047bc439a4810888c715e2df480/compiler%2Frustc_span%2Fsrc%2Fsymbol.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6efdf4d1309f8047bc439a4810888c715e2df480/compiler%2Frustc_span%2Fsrc%2Fsymbol.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_span%2Fsrc%2Fsymbol.rs?ref=6efdf4d1309f8047bc439a4810888c715e2df480", "patch": "@@ -1496,6 +1496,7 @@ symbols! {\n         trait_alias,\n         trait_upcasting,\n         transmute,\n+        transmute_generic_consts,\n         transmute_opts,\n         transmute_trait,\n         transparent,"}, {"sha": "ee883285531df52f232ced3d6098a3406e53fa38", "filename": "compiler/rustc_symbol_mangling/src/v0.rs", "status": "modified", "additions": 12, "deletions": 21, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/6efdf4d1309f8047bc439a4810888c715e2df480/compiler%2Frustc_symbol_mangling%2Fsrc%2Fv0.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6efdf4d1309f8047bc439a4810888c715e2df480/compiler%2Frustc_symbol_mangling%2Fsrc%2Fv0.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_symbol_mangling%2Fsrc%2Fv0.rs?ref=6efdf4d1309f8047bc439a4810888c715e2df480", "patch": "@@ -1,5 +1,5 @@\n use rustc_data_structures::base_n;\n-use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n+use rustc_data_structures::fx::FxHashMap;\n use rustc_data_structures::intern::Interned;\n use rustc_hir as hir;\n use rustc_hir::def::CtorKind;\n@@ -81,9 +81,9 @@ pub(super) fn mangle_typeid_for_trait_ref<'tcx>(\n struct BinderLevel {\n     /// The range of distances from the root of what's\n     /// being printed, to the lifetimes in a binder.\n-    /// Specifically, a `BrAnon(i)` lifetime has depth\n-    /// `lifetime_depths.start + i`, going away from the\n-    /// the root and towards its use site, as `i` increases.\n+    /// Specifically, a `BrAnon` lifetime has depth\n+    /// `lifetime_depths.start + index`, going away from the\n+    /// the root and towards its use site, as the var index increases.\n     /// This is used to flatten rustc's pairing of `BrAnon`\n     /// (intra-binder disambiguation) with a `DebruijnIndex`\n     /// (binder addressing), to \"true\" de Bruijn indices,\n@@ -208,24 +208,15 @@ impl<'tcx> SymbolMangler<'tcx> {\n     where\n         T: TypeVisitable<TyCtxt<'tcx>>,\n     {\n-        // FIXME(non-lifetime-binders): What to do here?\n-        let regions = if value.has_late_bound_regions() {\n-            self.tcx.collect_referenced_late_bound_regions(value)\n-        } else {\n-            FxHashSet::default()\n-        };\n-\n         let mut lifetime_depths =\n             self.binders.last().map(|b| b.lifetime_depths.end).map_or(0..0, |i| i..i);\n \n-        let lifetimes = regions\n-            .into_iter()\n-            .map(|br| match br {\n-                ty::BrAnon(i, _) => i,\n-                _ => bug!(\"symbol_names: non-anonymized region `{:?}` in `{:?}`\", br, value),\n-            })\n-            .max()\n-            .map_or(0, |max| max + 1);\n+        // FIXME(non-lifetime-binders): What to do here?\n+        let lifetimes = value\n+            .bound_vars()\n+            .iter()\n+            .filter(|var| matches!(var, ty::BoundVariableKind::Region(..)))\n+            .count() as u32;\n \n         self.push_opt_integer_62(\"G\", lifetimes as u64);\n         lifetime_depths.end += lifetimes;\n@@ -338,9 +329,9 @@ impl<'tcx> Printer<'tcx> for &mut SymbolMangler<'tcx> {\n \n             // Late-bound lifetimes use indices starting at 1,\n             // see `BinderLevel` for more details.\n-            ty::ReLateBound(debruijn, ty::BoundRegion { kind: ty::BrAnon(i, _), .. }) => {\n+            ty::ReLateBound(debruijn, ty::BoundRegion { var, kind: ty::BrAnon(_) }) => {\n                 let binder = &self.binders[self.binders.len() - 1 - debruijn.index()];\n-                let depth = binder.lifetime_depths.start + i;\n+                let depth = binder.lifetime_depths.start + var.as_u32();\n \n                 1 + (self.binders.last().unwrap().lifetime_depths.end - 1 - depth)\n             }"}, {"sha": "bf1b089f657b49d8ab79e3d462d65540ec0fce44", "filename": "compiler/rustc_target/src/spec/aarch64_unknown_linux_ohos.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/6efdf4d1309f8047bc439a4810888c715e2df480/compiler%2Frustc_target%2Fsrc%2Fspec%2Faarch64_unknown_linux_ohos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6efdf4d1309f8047bc439a4810888c715e2df480/compiler%2Frustc_target%2Fsrc%2Fspec%2Faarch64_unknown_linux_ohos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_target%2Fsrc%2Fspec%2Faarch64_unknown_linux_ohos.rs?ref=6efdf4d1309f8047bc439a4810888c715e2df480", "patch": "@@ -18,6 +18,7 @@ pub fn target() -> Target {\n             features: \"+reserve-x18\".into(),\n             mcount: \"\\u{1}_mcount\".into(),\n             force_emulated_tls: true,\n+            has_thread_local: false,\n             supported_sanitizers: SanitizerSet::ADDRESS\n                 | SanitizerSet::CFI\n                 | SanitizerSet::LEAK"}, {"sha": "630642dcd33a2188ffe7861a632676c4854a698f", "filename": "compiler/rustc_target/src/spec/aarch64_unknown_nto_qnx_710.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/6efdf4d1309f8047bc439a4810888c715e2df480/compiler%2Frustc_target%2Fsrc%2Fspec%2Faarch64_unknown_nto_qnx_710.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6efdf4d1309f8047bc439a4810888c715e2df480/compiler%2Frustc_target%2Fsrc%2Fspec%2Faarch64_unknown_nto_qnx_710.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_target%2Fsrc%2Fspec%2Faarch64_unknown_nto_qnx_710.rs?ref=6efdf4d1309f8047bc439a4810888c715e2df480", "patch": "@@ -23,6 +23,7 @@ pub fn target() -> Target {\n                 LinkerFlavor::Gnu(Cc::Yes, Lld::No),\n                 &[\"-Vgcc_ntoaarch64le_cxx\"],\n             ),\n+            env: \"nto71\".into(),\n             ..nto_qnx_base::opts()\n         },\n     }"}, {"sha": "5582d909f6b10a5326a66e1adddfe98bb8a91fd2", "filename": "compiler/rustc_target/src/spec/abi.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6efdf4d1309f8047bc439a4810888c715e2df480/compiler%2Frustc_target%2Fsrc%2Fspec%2Fabi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6efdf4d1309f8047bc439a4810888c715e2df480/compiler%2Frustc_target%2Fsrc%2Fspec%2Fabi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_target%2Fsrc%2Fspec%2Fabi.rs?ref=6efdf4d1309f8047bc439a4810888c715e2df480", "patch": "@@ -324,8 +324,6 @@ impl Abi {\n \n impl fmt::Display for Abi {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        match self {\n-            abi => write!(f, \"\\\"{}\\\"\", abi.name()),\n-        }\n+        write!(f, \"\\\"{}\\\"\", self.name())\n     }\n }"}, {"sha": "16da2453367735fdb91fd3fd8e85d55643422fdb", "filename": "compiler/rustc_target/src/spec/armv7_unknown_linux_ohos.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/6efdf4d1309f8047bc439a4810888c715e2df480/compiler%2Frustc_target%2Fsrc%2Fspec%2Farmv7_unknown_linux_ohos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6efdf4d1309f8047bc439a4810888c715e2df480/compiler%2Frustc_target%2Fsrc%2Fspec%2Farmv7_unknown_linux_ohos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_target%2Fsrc%2Fspec%2Farmv7_unknown_linux_ohos.rs?ref=6efdf4d1309f8047bc439a4810888c715e2df480", "patch": "@@ -21,6 +21,7 @@ pub fn target() -> Target {\n             crt_static_default: false,\n             mcount: \"\\u{1}mcount\".into(),\n             force_emulated_tls: true,\n+            has_thread_local: false,\n             ..super::linux_musl_base::opts()\n         },\n     }"}, {"sha": "68afa7fe401275ad784725392472fd6aa514eb04", "filename": "compiler/rustc_target/src/spec/i586_pc_nto_qnx700.rs", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/6efdf4d1309f8047bc439a4810888c715e2df480/compiler%2Frustc_target%2Fsrc%2Fspec%2Fi586_pc_nto_qnx700.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6efdf4d1309f8047bc439a4810888c715e2df480/compiler%2Frustc_target%2Fsrc%2Fspec%2Fi586_pc_nto_qnx700.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_target%2Fsrc%2Fspec%2Fi586_pc_nto_qnx700.rs?ref=6efdf4d1309f8047bc439a4810888c715e2df480", "patch": "@@ -0,0 +1,24 @@\n+use super::nto_qnx_base;\n+use crate::spec::{Cc, LinkerFlavor, Lld, StackProbeType, Target, TargetOptions};\n+\n+pub fn target() -> Target {\n+    Target {\n+        llvm_target: \"i586-pc-unknown\".into(),\n+        pointer_width: 32,\n+        data_layout: \"e-m:e-p:32:32-p270:32:32-p271:32:32-p272:64:64-\\\n+            f64:32:64-f80:32-n8:16:32-S128\"\n+            .into(),\n+        arch: \"x86\".into(),\n+        options: TargetOptions {\n+            cpu: \"pentium4\".into(),\n+            max_atomic_width: Some(64),\n+            pre_link_args: TargetOptions::link_args(\n+                LinkerFlavor::Gnu(Cc::Yes, Lld::No),\n+                &[\"-Vgcc_ntox86_cxx\"],\n+            ),\n+            env: \"nto70\".into(),\n+            stack_probes: StackProbeType::X86,\n+            ..nto_qnx_base::opts()\n+        },\n+    }\n+}"}, {"sha": "62c58c204e09adb73f50215efd78633baa10ef07", "filename": "compiler/rustc_target/src/spec/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/6efdf4d1309f8047bc439a4810888c715e2df480/compiler%2Frustc_target%2Fsrc%2Fspec%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6efdf4d1309f8047bc439a4810888c715e2df480/compiler%2Frustc_target%2Fsrc%2Fspec%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_target%2Fsrc%2Fspec%2Fmod.rs?ref=6efdf4d1309f8047bc439a4810888c715e2df480", "patch": "@@ -1261,6 +1261,7 @@ supported_targets! {\n \n     (\"aarch64-unknown-nto-qnx710\", aarch64_unknown_nto_qnx_710),\n     (\"x86_64-pc-nto-qnx710\", x86_64_pc_nto_qnx710),\n+    (\"i586-pc-nto-qnx700\", i586_pc_nto_qnx700),\n \n     (\"aarch64-unknown-linux-ohos\", aarch64_unknown_linux_ohos),\n     (\"armv7-unknown-linux-ohos\", armv7_unknown_linux_ohos),"}, {"sha": "f1405e9b44667625012f4c8736057be7dd1bf7a6", "filename": "compiler/rustc_target/src/spec/nto_qnx_base.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/6efdf4d1309f8047bc439a4810888c715e2df480/compiler%2Frustc_target%2Fsrc%2Fspec%2Fnto_qnx_base.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6efdf4d1309f8047bc439a4810888c715e2df480/compiler%2Frustc_target%2Fsrc%2Fspec%2Fnto_qnx_base.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_target%2Fsrc%2Fspec%2Fnto_qnx_base.rs?ref=6efdf4d1309f8047bc439a4810888c715e2df480", "patch": "@@ -4,7 +4,6 @@ pub fn opts() -> TargetOptions {\n     TargetOptions {\n         crt_static_respected: true,\n         dynamic_linking: true,\n-        env: \"nto71\".into(),\n         executables: true,\n         families: cvs![\"unix\"],\n         has_rpath: true,"}, {"sha": "6fb2dfd807a0f21f4f3c2d7e37eac538eb2cf62c", "filename": "compiler/rustc_target/src/spec/x86_64_pc_nto_qnx710.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/6efdf4d1309f8047bc439a4810888c715e2df480/compiler%2Frustc_target%2Fsrc%2Fspec%2Fx86_64_pc_nto_qnx710.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6efdf4d1309f8047bc439a4810888c715e2df480/compiler%2Frustc_target%2Fsrc%2Fspec%2Fx86_64_pc_nto_qnx710.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_target%2Fsrc%2Fspec%2Fx86_64_pc_nto_qnx710.rs?ref=6efdf4d1309f8047bc439a4810888c715e2df480", "patch": "@@ -15,6 +15,7 @@ pub fn target() -> Target {\n                 LinkerFlavor::Gnu(Cc::Yes, Lld::No),\n                 &[\"-Vgcc_ntox86_64_cxx\"],\n             ),\n+            env: \"nto71\".into(),\n             ..nto_qnx_base::opts()\n         },\n     }"}, {"sha": "12ee80b6722b1f571958baa3f770a33e7cb5b895", "filename": "compiler/rustc_trait_selection/src/solve/assembly/mod.rs", "status": "renamed", "additions": 37, "deletions": 50, "changes": 87, "blob_url": "https://github.com/rust-lang/rust/blob/6efdf4d1309f8047bc439a4810888c715e2df480/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fassembly%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6efdf4d1309f8047bc439a4810888c715e2df480/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fassembly%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fassembly%2Fmod.rs?ref=6efdf4d1309f8047bc439a4810888c715e2df480", "patch": "@@ -1,21 +1,21 @@\n //! Code shared by trait and projection goals for candidate assembly.\n \n use super::search_graph::OverflowHandler;\n-#[cfg(doc)]\n-use super::trait_goals::structural_traits::*;\n use super::{EvalCtxt, SolverMode};\n+use crate::solve::CanonicalResponseExt;\n use crate::traits::coherence;\n-use itertools::Itertools;\n use rustc_data_structures::fx::FxIndexSet;\n use rustc_hir::def_id::DefId;\n use rustc_infer::traits::query::NoSolution;\n-use rustc_infer::traits::util::elaborate_predicates;\n+use rustc_infer::traits::util::elaborate;\n use rustc_middle::traits::solve::{CanonicalResponse, Certainty, Goal, MaybeCause, QueryResult};\n use rustc_middle::ty::fast_reject::TreatProjections;\n use rustc_middle::ty::TypeFoldable;\n use rustc_middle::ty::{self, Ty, TyCtxt};\n use std::fmt::Debug;\n \n+pub(super) mod structural_traits;\n+\n /// A candidate is a possible way to prove a goal.\n ///\n /// It consists of both the `source`, which describes how that goal would be proven,\n@@ -270,6 +270,7 @@ impl<'tcx> EvalCtxt<'_, 'tcx> {\n     /// To deal with this, we first try to normalize the self type and add the candidates for the normalized\n     /// self type to the list of candidates in case that succeeds. We also have to consider candidates with the\n     /// projection as a self type as well\n+    #[instrument(level = \"debug\", skip_all)]\n     fn assemble_candidates_after_normalizing_self_ty<G: GoalKind<'tcx>>(\n         &mut self,\n         goal: Goal<'tcx, G>,\n@@ -315,6 +316,7 @@ impl<'tcx> EvalCtxt<'_, 'tcx> {\n         }\n     }\n \n+    #[instrument(level = \"debug\", skip_all)]\n     fn assemble_impl_candidates<G: GoalKind<'tcx>>(\n         &mut self,\n         goal: Goal<'tcx, G>,\n@@ -333,6 +335,7 @@ impl<'tcx> EvalCtxt<'_, 'tcx> {\n         );\n     }\n \n+    #[instrument(level = \"debug\", skip_all)]\n     fn assemble_builtin_impl_candidates<G: GoalKind<'tcx>>(\n         &mut self,\n         goal: Goal<'tcx, G>,\n@@ -390,6 +393,7 @@ impl<'tcx> EvalCtxt<'_, 'tcx> {\n         }\n     }\n \n+    #[instrument(level = \"debug\", skip_all)]\n     fn assemble_param_env_candidates<G: GoalKind<'tcx>>(\n         &mut self,\n         goal: Goal<'tcx, G>,\n@@ -405,6 +409,7 @@ impl<'tcx> EvalCtxt<'_, 'tcx> {\n         }\n     }\n \n+    #[instrument(level = \"debug\", skip_all)]\n     fn assemble_alias_bound_candidates<G: GoalKind<'tcx>>(\n         &mut self,\n         goal: Goal<'tcx, G>,\n@@ -452,6 +457,7 @@ impl<'tcx> EvalCtxt<'_, 'tcx> {\n         }\n     }\n \n+    #[instrument(level = \"debug\", skip_all)]\n     fn assemble_object_bound_candidates<G: GoalKind<'tcx>>(\n         &mut self,\n         goal: Goal<'tcx, G>,\n@@ -492,7 +498,7 @@ impl<'tcx> EvalCtxt<'_, 'tcx> {\n         let tcx = self.tcx();\n         let own_bounds: FxIndexSet<_> =\n             bounds.iter().map(|bound| bound.with_self_ty(tcx, self_ty)).collect();\n-        for assumption in elaborate_predicates(tcx, own_bounds.iter().copied()) {\n+        for assumption in elaborate(tcx, own_bounds.iter().copied()) {\n             // FIXME: Predicates are fully elaborated in the object type's existential bounds\n             // list. We want to only consider these pre-elaborated projections, and not other\n             // projection predicates that we reach by elaborating the principal trait ref,\n@@ -514,6 +520,7 @@ impl<'tcx> EvalCtxt<'_, 'tcx> {\n         }\n     }\n \n+    #[instrument(level = \"debug\", skip_all)]\n     fn assemble_coherence_unknowable_candidates<G: GoalKind<'tcx>>(\n         &mut self,\n         goal: Goal<'tcx, G>,\n@@ -540,61 +547,41 @@ impl<'tcx> EvalCtxt<'_, 'tcx> {\n         }\n     }\n \n+    /// If there are multiple ways to prove a trait or projection goal, we have\n+    /// to somehow try to merge the candidates into one. If that fails, we return\n+    /// ambiguity.\n     #[instrument(level = \"debug\", skip(self), ret)]\n     pub(super) fn merge_candidates(\n         &mut self,\n         mut candidates: Vec<Candidate<'tcx>>,\n     ) -> QueryResult<'tcx> {\n-        match candidates.len() {\n-            0 => return Err(NoSolution),\n-            1 => return Ok(candidates.pop().unwrap().result),\n-            _ => {}\n+        // First try merging all candidates. This is complete and fully sound.\n+        let responses = candidates.iter().map(|c| c.result).collect::<Vec<_>>();\n+        if let Some(result) = self.try_merge_responses(&responses) {\n+            return Ok(result);\n         }\n \n-        if candidates.len() > 1 {\n-            let mut i = 0;\n-            'outer: while i < candidates.len() {\n-                for j in (0..candidates.len()).filter(|&j| i != j) {\n-                    if self.candidate_should_be_dropped_in_favor_of(&candidates[i], &candidates[j])\n-                    {\n-                        debug!(candidate = ?candidates[i], \"Dropping candidate #{}/{}\", i, candidates.len());\n-                        candidates.swap_remove(i);\n-                        continue 'outer;\n+        // We then check whether we should prioritize `ParamEnv` candidates.\n+        //\n+        // Doing so is incomplete and would therefore be unsound during coherence.\n+        match self.solver_mode() {\n+            SolverMode::Coherence => (),\n+            // Prioritize `ParamEnv` candidates only if they do not guide inference.\n+            //\n+            // This is still incomplete as we may add incorrect region bounds.\n+            SolverMode::Normal => {\n+                let param_env_responses = candidates\n+                    .iter()\n+                    .filter(|c| matches!(c.source, CandidateSource::ParamEnv(_)))\n+                    .map(|c| c.result)\n+                    .collect::<Vec<_>>();\n+                if let Some(result) = self.try_merge_responses(&param_env_responses) {\n+                    if result.has_only_region_constraints() {\n+                        return Ok(result);\n                     }\n                 }\n-\n-                debug!(candidate = ?candidates[i], \"Retaining candidate #{}/{}\", i, candidates.len());\n-                i += 1;\n             }\n-\n-            // If there are *STILL* multiple candidates that have *different* response\n-            // results, give up and report ambiguity.\n-            if candidates.len() > 1 && !candidates.iter().map(|cand| cand.result).all_equal() {\n-                let certainty = if candidates.iter().all(|x| {\n-                    matches!(x.result.value.certainty, Certainty::Maybe(MaybeCause::Overflow))\n-                }) {\n-                    Certainty::Maybe(MaybeCause::Overflow)\n-                } else {\n-                    Certainty::AMBIGUOUS\n-                };\n-                return self.evaluate_added_goals_and_make_canonical_response(certainty);\n-            }\n-        }\n-\n-        Ok(candidates.pop().unwrap().result)\n-    }\n-\n-    fn candidate_should_be_dropped_in_favor_of(\n-        &self,\n-        candidate: &Candidate<'tcx>,\n-        other: &Candidate<'tcx>,\n-    ) -> bool {\n-        // FIXME: implement this\n-        match (candidate.source, other.source) {\n-            (CandidateSource::Impl(_), _)\n-            | (CandidateSource::ParamEnv(_), _)\n-            | (CandidateSource::AliasBound, _)\n-            | (CandidateSource::BuiltinImpl, _) => false,\n         }\n+        self.flounder(&responses)\n     }\n }", "previous_filename": "compiler/rustc_trait_selection/src/solve/assembly.rs"}, {"sha": "cbec39d82856e2862d6226c8be03e48dd5c970ea", "filename": "compiler/rustc_trait_selection/src/solve/assembly/structural_traits.rs", "status": "renamed", "additions": 55, "deletions": 8, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/6efdf4d1309f8047bc439a4810888c715e2df480/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fassembly%2Fstructural_traits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6efdf4d1309f8047bc439a4810888c715e2df480/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fassembly%2Fstructural_traits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fassembly%2Fstructural_traits.rs?ref=6efdf4d1309f8047bc439a4810888c715e2df480", "patch": "@@ -1,15 +1,17 @@\n use rustc_data_structures::fx::FxHashMap;\n use rustc_hir::{def_id::DefId, Movability, Mutability};\n use rustc_infer::traits::query::NoSolution;\n-use rustc_middle::ty::{self, Ty, TyCtxt, TypeFoldable, TypeFolder, TypeSuperFoldable};\n+use rustc_middle::ty::{\n+    self, Ty, TyCtxt, TypeFoldable, TypeFolder, TypeSuperFoldable, TypeVisitableExt,\n+};\n \n use crate::solve::EvalCtxt;\n \n // Calculates the constituent types of a type for `auto trait` purposes.\n //\n // For types with an \"existential\" binder, i.e. generator witnesses, we also\n // instantiate the binder with placeholders eagerly.\n-pub(super) fn instantiate_constituent_tys_for_auto_trait<'tcx>(\n+pub(in crate::solve) fn instantiate_constituent_tys_for_auto_trait<'tcx>(\n     ecx: &EvalCtxt<'_, 'tcx>,\n     ty: Ty<'tcx>,\n ) -> Result<Vec<Ty<'tcx>>, NoSolution> {\n@@ -60,7 +62,16 @@ pub(super) fn instantiate_constituent_tys_for_auto_trait<'tcx>(\n \n         ty::GeneratorWitness(types) => Ok(ecx.instantiate_binder_with_placeholders(types).to_vec()),\n \n-        ty::GeneratorWitnessMIR(..) => todo!(),\n+        ty::GeneratorWitnessMIR(def_id, substs) => Ok(ecx\n+            .tcx()\n+            .generator_hidden_types(def_id)\n+            .map(|bty| {\n+                ecx.instantiate_binder_with_placeholders(replace_erased_lifetimes_with_bound_vars(\n+                    tcx,\n+                    bty.subst(tcx, substs),\n+                ))\n+            })\n+            .collect()),\n \n         // For `PhantomData<T>`, we pass `T`.\n         ty::Adt(def, substs) if def.is_phantom_data() => Ok(vec![substs.type_at(0)]),\n@@ -76,7 +87,28 @@ pub(super) fn instantiate_constituent_tys_for_auto_trait<'tcx>(\n     }\n }\n \n-pub(super) fn instantiate_constituent_tys_for_sized_trait<'tcx>(\n+pub(in crate::solve) fn replace_erased_lifetimes_with_bound_vars<'tcx>(\n+    tcx: TyCtxt<'tcx>,\n+    ty: Ty<'tcx>,\n+) -> ty::Binder<'tcx, Ty<'tcx>> {\n+    debug_assert!(!ty.has_late_bound_regions());\n+    let mut counter = 0;\n+    let ty = tcx.fold_regions(ty, |mut r, current_depth| {\n+        if let ty::ReErased = r.kind() {\n+            let br =\n+                ty::BoundRegion { var: ty::BoundVar::from_u32(counter), kind: ty::BrAnon(None) };\n+            counter += 1;\n+            r = tcx.mk_re_late_bound(current_depth, br);\n+        }\n+        r\n+    });\n+    let bound_vars = tcx.mk_bound_variable_kinds_from_iter(\n+        (0..counter).map(|_| ty::BoundVariableKind::Region(ty::BrAnon(None))),\n+    );\n+    ty::Binder::bind_with_vars(ty, bound_vars)\n+}\n+\n+pub(in crate::solve) fn instantiate_constituent_tys_for_sized_trait<'tcx>(\n     ecx: &EvalCtxt<'_, 'tcx>,\n     ty: Ty<'tcx>,\n ) -> Result<Vec<Ty<'tcx>>, NoSolution> {\n@@ -126,7 +158,7 @@ pub(super) fn instantiate_constituent_tys_for_sized_trait<'tcx>(\n     }\n }\n \n-pub(super) fn instantiate_constituent_tys_for_copy_clone_trait<'tcx>(\n+pub(in crate::solve) fn instantiate_constituent_tys_for_copy_clone_trait<'tcx>(\n     ecx: &EvalCtxt<'_, 'tcx>,\n     ty: Ty<'tcx>,\n ) -> Result<Vec<Ty<'tcx>>, NoSolution> {\n@@ -178,12 +210,21 @@ pub(super) fn instantiate_constituent_tys_for_copy_clone_trait<'tcx>(\n \n         ty::GeneratorWitness(types) => Ok(ecx.instantiate_binder_with_placeholders(types).to_vec()),\n \n-        ty::GeneratorWitnessMIR(..) => todo!(),\n+        ty::GeneratorWitnessMIR(def_id, substs) => Ok(ecx\n+            .tcx()\n+            .generator_hidden_types(def_id)\n+            .map(|bty| {\n+                ecx.instantiate_binder_with_placeholders(replace_erased_lifetimes_with_bound_vars(\n+                    ecx.tcx(),\n+                    bty.subst(ecx.tcx(), substs),\n+                ))\n+            })\n+            .collect()),\n     }\n }\n \n // Returns a binder of the tupled inputs types and output type from a builtin callable type.\n-pub(crate) fn extract_tupled_inputs_and_output_from_callable<'tcx>(\n+pub(in crate::solve) fn extract_tupled_inputs_and_output_from_callable<'tcx>(\n     tcx: TyCtxt<'tcx>,\n     self_ty: Ty<'tcx>,\n     goal_kind: ty::ClosureKind,\n@@ -296,7 +337,13 @@ pub(crate) fn extract_tupled_inputs_and_output_from_callable<'tcx>(\n /// additional step of eagerly folding the associated types in the where\n /// clauses of the impl. In this example, that means replacing\n /// `<Self as Foo>::Bar` with `Ty` in the first impl.\n-pub(crate) fn predicates_for_object_candidate<'tcx>(\n+///\n+// FIXME: This is only necessary as `<Self as Trait>::Assoc: ItemBound`\n+// bounds in impls are trivially proven using the item bound candidates.\n+// This is unsound in general and once that is fixed, we don't need to\n+// normalize eagerly here. See https://github.com/lcnr/solver-woes/issues/9\n+// for more details.\n+pub(in crate::solve) fn predicates_for_object_candidate<'tcx>(\n     ecx: &EvalCtxt<'_, 'tcx>,\n     param_env: ty::ParamEnv<'tcx>,\n     trait_ref: ty::TraitRef<'tcx>,", "previous_filename": "compiler/rustc_trait_selection/src/solve/trait_goals/structural_traits.rs"}, {"sha": "55025e2e72b9c9589cdebafcdeb4fd04f3863918", "filename": "compiler/rustc_trait_selection/src/solve/canonicalize.rs", "status": "modified", "additions": 12, "deletions": 6, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/6efdf4d1309f8047bc439a4810888c715e2df480/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fcanonicalize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6efdf4d1309f8047bc439a4810888c715e2df480/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fcanonicalize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fcanonicalize.rs?ref=6efdf4d1309f8047bc439a4810888c715e2df480", "patch": "@@ -257,7 +257,7 @@ impl<'tcx> TypeFolder<TyCtxt<'tcx>> for Canonicalizer<'_, 'tcx> {\n             self.primitive_var_infos.push(CanonicalVarInfo { kind });\n             var\n         });\n-        let br = ty::BoundRegion { var, kind: BrAnon(var.as_u32(), None) };\n+        let br = ty::BoundRegion { var, kind: BrAnon(None) };\n         self.interner().mk_re_late_bound(self.binder_index, br)\n     }\n \n@@ -300,14 +300,20 @@ impl<'tcx> TypeFolder<TyCtxt<'tcx>> for Canonicalizer<'_, 'tcx> {\n             ty::Placeholder(placeholder) => match self.canonicalize_mode {\n                 CanonicalizeMode::Input => CanonicalVarKind::PlaceholderTy(ty::Placeholder {\n                     universe: placeholder.universe,\n-                    name: BoundTyKind::Anon(self.variables.len() as u32),\n+                    bound: ty::BoundTy {\n+                        var: ty::BoundVar::from_usize(self.variables.len()),\n+                        kind: ty::BoundTyKind::Anon,\n+                    },\n                 }),\n                 CanonicalizeMode::Response { .. } => CanonicalVarKind::PlaceholderTy(placeholder),\n             },\n             ty::Param(_) => match self.canonicalize_mode {\n                 CanonicalizeMode::Input => CanonicalVarKind::PlaceholderTy(ty::Placeholder {\n                     universe: ty::UniverseIndex::ROOT,\n-                    name: ty::BoundTyKind::Anon(self.variables.len() as u32),\n+                    bound: ty::BoundTy {\n+                        var: ty::BoundVar::from_usize(self.variables.len()),\n+                        kind: ty::BoundTyKind::Anon,\n+                    },\n                 }),\n                 CanonicalizeMode::Response { .. } => bug!(\"param ty in response: {t:?}\"),\n             },\n@@ -345,7 +351,7 @@ impl<'tcx> TypeFolder<TyCtxt<'tcx>> for Canonicalizer<'_, 'tcx> {\n                 var\n             }),\n         );\n-        let bt = ty::BoundTy { var, kind: BoundTyKind::Anon(var.index() as u32) };\n+        let bt = ty::BoundTy { var, kind: BoundTyKind::Anon };\n         self.interner().mk_bound(self.binder_index, bt)\n     }\n \n@@ -373,7 +379,7 @@ impl<'tcx> TypeFolder<TyCtxt<'tcx>> for Canonicalizer<'_, 'tcx> {\n                 CanonicalizeMode::Input => CanonicalVarKind::PlaceholderConst(\n                     ty::Placeholder {\n                         universe: placeholder.universe,\n-                        name: ty::BoundVar::from(self.variables.len()),\n+                        bound: ty::BoundVar::from(self.variables.len()),\n                     },\n                     c.ty(),\n                 ),\n@@ -385,7 +391,7 @@ impl<'tcx> TypeFolder<TyCtxt<'tcx>> for Canonicalizer<'_, 'tcx> {\n                 CanonicalizeMode::Input => CanonicalVarKind::PlaceholderConst(\n                     ty::Placeholder {\n                         universe: ty::UniverseIndex::ROOT,\n-                        name: ty::BoundVar::from(self.variables.len()),\n+                        bound: ty::BoundVar::from(self.variables.len()),\n                     },\n                     c.ty(),\n                 ),"}, {"sha": "28aca76cceb6696633ba7a725a1d4be9655c4c15", "filename": "compiler/rustc_trait_selection/src/solve/eval_ctxt.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/6efdf4d1309f8047bc439a4810888c715e2df480/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Feval_ctxt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6efdf4d1309f8047bc439a4810888c715e2df480/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Feval_ctxt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Feval_ctxt.rs?ref=6efdf4d1309f8047bc439a4810888c715e2df480", "patch": "@@ -106,7 +106,7 @@ pub trait InferCtxtEvalExt<'tcx> {\n }\n \n impl<'tcx> InferCtxtEvalExt<'tcx> for InferCtxt<'tcx> {\n-    #[instrument(level = \"debug\", skip(self))]\n+    #[instrument(level = \"debug\", skip(self), ret)]\n     fn evaluate_root_goal(\n         &self,\n         goal: Goal<'tcx, ty::Predicate<'tcx>>,\n@@ -357,7 +357,7 @@ impl<'a, 'tcx> EvalCtxt<'a, 'tcx> {\n                             // deal with `has_changed` in the next iteration.\n                             new_goals.normalizes_to_hack_goal =\n                                 Some(this.resolve_vars_if_possible(goal));\n-                            has_changed = has_changed.map_err(|c| c.unify_and(certainty));\n+                            has_changed = has_changed.map_err(|c| c.unify_with(certainty));\n                         }\n                     }\n                 }\n@@ -378,7 +378,7 @@ impl<'a, 'tcx> EvalCtxt<'a, 'tcx> {\n                         Certainty::Yes => {}\n                         Certainty::Maybe(_) => {\n                             new_goals.goals.push(goal);\n-                            has_changed = has_changed.map_err(|c| c.unify_and(certainty));\n+                            has_changed = has_changed.map_err(|c| c.unify_with(certainty));\n                         }\n                     }\n                 }\n@@ -552,7 +552,7 @@ impl<'tcx> EvalCtxt<'_, 'tcx> {\n     ///\n     /// If possible, try using `eq` instead which automatically handles nested\n     /// goals correctly.\n-    #[instrument(level = \"debug\", skip(self, param_env), ret)]\n+    #[instrument(level = \"trace\", skip(self, param_env), ret)]\n     pub(super) fn eq_and_get_goals<T: ToTrace<'tcx>>(\n         &self,\n         param_env: ty::ParamEnv<'tcx>,"}, {"sha": "861fa0a305ac0184c9beeeab91fa53d58f1e4a85", "filename": "compiler/rustc_trait_selection/src/solve/eval_ctxt/canonical.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6efdf4d1309f8047bc439a4810888c715e2df480/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Feval_ctxt%2Fcanonical.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6efdf4d1309f8047bc439a4810888c715e2df480/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Feval_ctxt%2Fcanonical.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Feval_ctxt%2Fcanonical.rs?ref=6efdf4d1309f8047bc439a4810888c715e2df480", "patch": "@@ -50,7 +50,7 @@ impl<'tcx> EvalCtxt<'_, 'tcx> {\n         certainty: Certainty,\n     ) -> QueryResult<'tcx> {\n         let goals_certainty = self.try_evaluate_added_goals()?;\n-        let certainty = certainty.unify_and(goals_certainty);\n+        let certainty = certainty.unify_with(goals_certainty);\n \n         let external_constraints = self.compute_external_query_constraints()?;\n \n@@ -188,7 +188,7 @@ impl<'tcx> EvalCtxt<'_, 'tcx> {\n                 } else {\n                     // For placeholders which were already part of the input, we simply map this\n                     // universal bound variable back the placeholder of the input.\n-                    original_values[info.expect_anon_placeholder() as usize]\n+                    original_values[info.expect_placeholder_index()]\n                 }\n             },\n         ));"}, {"sha": "19bcbd461447d75c915abbae9b7f8ada593cee9a", "filename": "compiler/rustc_trait_selection/src/solve/mod.rs", "status": "modified", "additions": 78, "deletions": 37, "changes": 115, "blob_url": "https://github.com/rust-lang/rust/blob/6efdf4d1309f8047bc439a4810888c715e2df480/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6efdf4d1309f8047bc439a4810888c715e2df480/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fmod.rs?ref=6efdf4d1309f8047bc439a4810888c715e2df480", "patch": "@@ -46,6 +46,8 @@ enum SolverMode {\n \n trait CanonicalResponseExt {\n     fn has_no_inference_or_external_constraints(&self) -> bool;\n+\n+    fn has_only_region_constraints(&self) -> bool;\n }\n \n impl<'tcx> CanonicalResponseExt for Canonical<'tcx, Response<'tcx>> {\n@@ -54,6 +56,11 @@ impl<'tcx> CanonicalResponseExt for Canonical<'tcx, Response<'tcx>> {\n             && self.value.var_values.is_identity()\n             && self.value.external_constraints.opaque_types.is_empty()\n     }\n+\n+    fn has_only_region_constraints(&self) -> bool {\n+        self.value.var_values.is_identity_modulo_regions()\n+            && self.value.external_constraints.opaque_types.is_empty()\n+    }\n }\n \n impl<'a, 'tcx> EvalCtxt<'a, 'tcx> {\n@@ -153,13 +160,22 @@ impl<'a, 'tcx> EvalCtxt<'a, 'tcx> {\n     ) -> QueryResult<'tcx> {\n         let tcx = self.tcx();\n         // We may need to invert the alias relation direction if dealing an alias on the RHS.\n+        #[derive(Debug)]\n         enum Invert {\n             No,\n             Yes,\n         }\n         let evaluate_normalizes_to =\n             |ecx: &mut EvalCtxt<'_, 'tcx>, alias, other, direction, invert| {\n-                debug!(\"evaluate_normalizes_to(alias={:?}, other={:?})\", alias, other);\n+                let span = tracing::span!(\n+                    tracing::Level::DEBUG,\n+                    \"compute_alias_relate_goal(evaluate_normalizes_to)\",\n+                    ?alias,\n+                    ?other,\n+                    ?direction,\n+                    ?invert\n+                );\n+                let _enter = span.enter();\n                 let result = ecx.probe(|ecx| {\n                     let other = match direction {\n                         // This is purely an optimization.\n@@ -184,7 +200,7 @@ impl<'a, 'tcx> EvalCtxt<'a, 'tcx> {\n                     ));\n                     ecx.evaluate_added_goals_and_make_canonical_response(Certainty::Yes)\n                 });\n-                debug!(\"evaluate_normalizes_to({alias}, {other}, {direction:?}) -> {result:?}\");\n+                debug!(?result);\n                 result\n             };\n \n@@ -210,18 +226,28 @@ impl<'a, 'tcx> EvalCtxt<'a, 'tcx> {\n             }\n \n             (Some(alias_lhs), Some(alias_rhs)) => {\n-                debug!(\"compute_alias_relate_goal: both sides are aliases\");\n-\n-                let candidates = vec![\n-                    // LHS normalizes-to RHS\n-                    evaluate_normalizes_to(self, alias_lhs, rhs, direction, Invert::No),\n-                    // RHS normalizes-to RHS\n-                    evaluate_normalizes_to(self, alias_rhs, lhs, direction, Invert::Yes),\n-                    // Relate via substs\n+                debug!(\"both sides are aliases\");\n+\n+                let mut candidates = Vec::new();\n+                // LHS normalizes-to RHS\n+                candidates.extend(\n+                    evaluate_normalizes_to(self, alias_lhs, rhs, direction, Invert::No).ok(),\n+                );\n+                // RHS normalizes-to RHS\n+                candidates.extend(\n+                    evaluate_normalizes_to(self, alias_rhs, lhs, direction, Invert::Yes).ok(),\n+                );\n+                // Relate via substs\n+                candidates.extend(\n                     self.probe(|ecx| {\n-                        debug!(\n-                            \"compute_alias_relate_goal: alias defids are equal, equating substs\"\n+                        let span = tracing::span!(\n+                            tracing::Level::DEBUG,\n+                            \"compute_alias_relate_goal(relate_via_substs)\",\n+                            ?alias_lhs,\n+                            ?alias_rhs,\n+                            ?direction\n                         );\n+                        let _enter = span.enter();\n \n                         match direction {\n                             ty::AliasRelationDirection::Equate => {\n@@ -233,11 +259,16 @@ impl<'a, 'tcx> EvalCtxt<'a, 'tcx> {\n                         }\n \n                         ecx.evaluate_added_goals_and_make_canonical_response(Certainty::Yes)\n-                    }),\n-                ];\n+                    })\n+                    .ok(),\n+                );\n                 debug!(?candidates);\n \n-                self.try_merge_responses(candidates.into_iter())\n+                if let Some(merged) = self.try_merge_responses(&candidates) {\n+                    Ok(merged)\n+                } else {\n+                    self.flounder(&candidates)\n+                }\n             }\n         }\n     }\n@@ -275,41 +306,51 @@ impl<'tcx> EvalCtxt<'_, 'tcx> {\n         debug!(\"added_goals={:?}\", &self.nested_goals.goals[current_len..]);\n     }\n \n+    /// Try to merge multiple possible ways to prove a goal, if that is not possible returns `None`.\n+    ///\n+    /// In this case we tend to flounder and return ambiguity by calling `[EvalCtxt::flounder]`.\n+    #[instrument(level = \"debug\", skip(self), ret)]\n     fn try_merge_responses(\n         &mut self,\n-        responses: impl Iterator<Item = QueryResult<'tcx>>,\n-    ) -> QueryResult<'tcx> {\n-        let candidates = responses.into_iter().flatten().collect::<Box<[_]>>();\n-\n-        if candidates.is_empty() {\n-            return Err(NoSolution);\n+        responses: &[CanonicalResponse<'tcx>],\n+    ) -> Option<CanonicalResponse<'tcx>> {\n+        if responses.is_empty() {\n+            return None;\n         }\n \n         // FIXME(-Ztrait-solver=next): We should instead try to find a `Certainty::Yes` response with\n         // a subset of the constraints that all the other responses have.\n-        let one = candidates[0];\n-        if candidates[1..].iter().all(|resp| resp == &one) {\n-            return Ok(one);\n+        let one = responses[0];\n+        if responses[1..].iter().all(|&resp| resp == one) {\n+            return Some(one);\n         }\n \n-        if let Some(response) = candidates.iter().find(|response| {\n-            response.value.certainty == Certainty::Yes\n-                && response.has_no_inference_or_external_constraints()\n-        }) {\n-            return Ok(*response);\n-        }\n+        responses\n+            .iter()\n+            .find(|response| {\n+                response.value.certainty == Certainty::Yes\n+                    && response.has_no_inference_or_external_constraints()\n+            })\n+            .copied()\n+    }\n \n-        let certainty = candidates.iter().fold(Certainty::AMBIGUOUS, |certainty, response| {\n-            certainty.unify_and(response.value.certainty)\n+    /// If we fail to merge responses we flounder and return overflow or ambiguity.\n+    #[instrument(level = \"debug\", skip(self), ret)]\n+    fn flounder(&mut self, responses: &[CanonicalResponse<'tcx>]) -> QueryResult<'tcx> {\n+        if responses.is_empty() {\n+            return Err(NoSolution);\n+        }\n+        let certainty = responses.iter().fold(Certainty::AMBIGUOUS, |certainty, response| {\n+            certainty.unify_with(response.value.certainty)\n         });\n-        // FIXME(-Ztrait-solver=next): We should take the intersection of the constraints on all the\n-        // responses and use that for the constraints of this ambiguous response.\n+\n         let response = self.evaluate_added_goals_and_make_canonical_response(certainty);\n-        if let Ok(response) = &response {\n+        if let Ok(response) = response {\n             assert!(response.has_no_inference_or_external_constraints());\n+            Ok(response)\n+        } else {\n+            bug!(\"failed to make floundered response: {responses:?}\");\n         }\n-\n-        response\n     }\n }\n "}, {"sha": "2a47da81ec760aedea5abcdbd1f9543e7ccf7e89", "filename": "compiler/rustc_trait_selection/src/solve/project_goals.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/6efdf4d1309f8047bc439a4810888c715e2df480/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fproject_goals.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6efdf4d1309f8047bc439a4810888c715e2df480/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fproject_goals.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fproject_goals.rs?ref=6efdf4d1309f8047bc439a4810888c715e2df480", "patch": "@@ -1,7 +1,6 @@\n use crate::traits::specialization_graph;\n \n-use super::assembly;\n-use super::trait_goals::structural_traits;\n+use super::assembly::{self, structural_traits};\n use super::EvalCtxt;\n use rustc_errors::ErrorGuaranteed;\n use rustc_hir::def::DefKind;"}, {"sha": "42c28686f5c14ec3d692eb8cc2f9fc0cdd38e199", "filename": "compiler/rustc_trait_selection/src/solve/search_graph/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/6efdf4d1309f8047bc439a4810888c715e2df480/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fsearch_graph%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6efdf4d1309f8047bc439a4810888c715e2df480/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fsearch_graph%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fsearch_graph%2Fmod.rs?ref=6efdf4d1309f8047bc439a4810888c715e2df480", "patch": "@@ -209,6 +209,7 @@ impl<'tcx> SearchGraph<'tcx> {\n     ) -> QueryResult<'tcx> {\n         if self.should_use_global_cache() {\n             if let Some(result) = tcx.new_solver_evaluation_cache.get(&canonical_goal, tcx) {\n+                debug!(?canonical_goal, ?result, \"cache hit\");\n                 return result;\n             }\n         }"}, {"sha": "81f89fd950c8d29e29f2f338ef84ec9ba8ce39d9", "filename": "compiler/rustc_trait_selection/src/solve/trait_goals.rs", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/6efdf4d1309f8047bc439a4810888c715e2df480/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Ftrait_goals.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6efdf4d1309f8047bc439a4810888c715e2df480/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Ftrait_goals.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Ftrait_goals.rs?ref=6efdf4d1309f8047bc439a4810888c715e2df480", "patch": "@@ -1,6 +1,7 @@\n //! Dealing with trait goals, i.e. `T: Trait<'a, U>`.\n \n-use super::{assembly, EvalCtxt, SolverMode};\n+use super::assembly::{self, structural_traits};\n+use super::{EvalCtxt, SolverMode};\n use rustc_hir::def_id::DefId;\n use rustc_hir::LangItem;\n use rustc_infer::traits::query::NoSolution;\n@@ -11,8 +12,6 @@ use rustc_middle::ty::{self, ToPredicate, Ty, TyCtxt};\n use rustc_middle::ty::{TraitPredicate, TypeVisitableExt};\n use rustc_span::DUMMY_SP;\n \n-pub mod structural_traits;\n-\n impl<'tcx> assembly::GoalKind<'tcx> for TraitPredicate<'tcx> {\n     fn self_ty(self) -> Ty<'tcx> {\n         self.self_ty()\n@@ -221,8 +220,7 @@ impl<'tcx> assembly::GoalKind<'tcx> for TraitPredicate<'tcx> {\n         let self_ty = tcx.erase_regions(goal.predicate.self_ty());\n \n         if let Ok(layout) = tcx.layout_of(goal.param_env.and(self_ty))\n-            && layout.layout.size() == tcx.data_layout.pointer_size\n-            && layout.layout.align().abi == tcx.data_layout.pointer_align.abi\n+            && layout.layout.is_pointer_like(&tcx.data_layout)\n         {\n             // FIXME: We could make this faster by making a no-constraints response\n             ecx.evaluate_added_goals_and_make_canonical_response(Certainty::Yes)"}]}