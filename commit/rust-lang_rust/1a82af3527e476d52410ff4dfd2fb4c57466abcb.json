{"sha": "1a82af3527e476d52410ff4dfd2fb4c57466abcb", "node_id": "MDY6Q29tbWl0NzI0NzEyOjFhODJhZjM1MjdlNDc2ZDUyNDEwZmY0ZGZkMmZiNGM1NzQ2NmFiY2I=", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2021-03-16T08:05:24Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2021-03-16T08:05:24Z"}, "message": "Merge #7900 #8000\n\n7900: show function params in completion detail r=matklad a=JoshMcguigan\n\nThis resolves #7842 by updating the detail for function completions from `-> T` to `fn(T, U) -> V`. I added an expicit unit test for this, `ide_completion::render::fn_detail_includes_args_and_return_type`, which passes.\r\n\r\nLots of other unit tests fail (~60 of them) due to this change, although I believe the failures are purely cosmetic (they were testing the exact format of this output). I'm happy to go update those tests, but before I do that I'd like to make sure this is in fact the format we want for the detail?\r\n\r\nedit - I realized `UPDATE_EXPECT=1 cargo test` automatically updates `expect!` tests. Big :+1: to whoever worked on that! So I'll go ahead and update all these tests soon. But I still would like to confirm `fn(T, U) -> V` is the desired content in the `detail` field. \n\n8000: Use hir formatter for hover text r=matklad a=oxalica\n\nFix #2765 , (should) fix #4665\n\nCo-authored-by: Josh Mcguigan <joshmcg88@gmail.com>\nCo-authored-by: oxalica <oxalicc@pm.me>", "tree": {"sha": "0c86e28a43908e099bb522727f93c28b301e6f3c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0c86e28a43908e099bb522727f93c28b301e6f3c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1a82af3527e476d52410ff4dfd2fb4c57466abcb", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJgUGbECRBK7hj4Ov3rIwAAdHIIAKiK0QQktYPm1fRaCINQl9gD\nwlFjw5viGHFtUfmjdl+ixU6Uw92CM8FKOl3xMCefcP19I48WyOg3qK3z0EEr+bhw\neQgqpFqSrwaWhQAr9xSSDheR6JAkfSIhF3cigTTmWIoyF7lRDuPaGFAPnDjqp6dU\nEmBW/lMLA6dqy9DTrg00FsUyYMVO3U8FPvEMs/Vz7AaGt5GgL6KKHDkWmBZnx2fs\nO6crizaazrVVpNewQTNmHNM/JbWNM3BpWmKYKDzKPsChirMFOz8JDs3R6XvR3CFr\nhbA5pEv+tkiMrv4sKorPTGwA2A8AEl7pmZVaUm5bLi3xUUK3ZZdW7DA593D2eIo=\n=NTW5\n-----END PGP SIGNATURE-----\n", "payload": "tree 0c86e28a43908e099bb522727f93c28b301e6f3c\nparent 62ec04bbd53ba50e21a7b8f23d46958d322640eb\nparent d5f0f58e6330efd8200f93a6904caafc600a904e\nparent 455b418263df80da5cd80e2af1df27b7e165c0c3\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1615881924 +0000\ncommitter GitHub <noreply@github.com> 1615881924 +0000\n\nMerge #7900 #8000\n\n7900: show function params in completion detail r=matklad a=JoshMcguigan\n\nThis resolves #7842 by updating the detail for function completions from `-> T` to `fn(T, U) -> V`. I added an expicit unit test for this, `ide_completion::render::fn_detail_includes_args_and_return_type`, which passes.\r\n\r\nLots of other unit tests fail (~60 of them) due to this change, although I believe the failures are purely cosmetic (they were testing the exact format of this output). I'm happy to go update those tests, but before I do that I'd like to make sure this is in fact the format we want for the detail?\r\n\r\nedit - I realized `UPDATE_EXPECT=1 cargo test` automatically updates `expect!` tests. Big :+1: to whoever worked on that! So I'll go ahead and update all these tests soon. But I still would like to confirm `fn(T, U) -> V` is the desired content in the `detail` field. \n\n8000: Use hir formatter for hover text r=matklad a=oxalica\n\nFix #2765 , (should) fix #4665\n\nCo-authored-by: Josh Mcguigan <joshmcg88@gmail.com>\nCo-authored-by: oxalica <oxalicc@pm.me>\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1a82af3527e476d52410ff4dfd2fb4c57466abcb", "html_url": "https://github.com/rust-lang/rust/commit/1a82af3527e476d52410ff4dfd2fb4c57466abcb", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1a82af3527e476d52410ff4dfd2fb4c57466abcb/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "62ec04bbd53ba50e21a7b8f23d46958d322640eb", "url": "https://api.github.com/repos/rust-lang/rust/commits/62ec04bbd53ba50e21a7b8f23d46958d322640eb", "html_url": "https://github.com/rust-lang/rust/commit/62ec04bbd53ba50e21a7b8f23d46958d322640eb"}, {"sha": "d5f0f58e6330efd8200f93a6904caafc600a904e", "url": "https://api.github.com/repos/rust-lang/rust/commits/d5f0f58e6330efd8200f93a6904caafc600a904e", "html_url": "https://github.com/rust-lang/rust/commit/d5f0f58e6330efd8200f93a6904caafc600a904e"}, {"sha": "455b418263df80da5cd80e2af1df27b7e165c0c3", "url": "https://api.github.com/repos/rust-lang/rust/commits/455b418263df80da5cd80e2af1df27b7e165c0c3", "html_url": "https://github.com/rust-lang/rust/commit/455b418263df80da5cd80e2af1df27b7e165c0c3"}], "stats": {"total": 1270, "additions": 1058, "deletions": 212}, "files": [{"sha": "44cdcc296384df00668dec23be2ab167c93b75be", "filename": "crates/hir/src/display.rs", "status": "added", "additions": 441, "deletions": 0, "changes": 441, "blob_url": "https://github.com/rust-lang/rust/blob/1a82af3527e476d52410ff4dfd2fb4c57466abcb/crates%2Fhir%2Fsrc%2Fdisplay.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1a82af3527e476d52410ff4dfd2fb4c57466abcb/crates%2Fhir%2Fsrc%2Fdisplay.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir%2Fsrc%2Fdisplay.rs?ref=1a82af3527e476d52410ff4dfd2fb4c57466abcb", "patch": "@@ -0,0 +1,441 @@\n+//! HirDisplay implementations for various hir types.\n+use hir_def::{\n+    adt::VariantData,\n+    generics::{TypeParamProvenance, WherePredicate, WherePredicateTypeTarget},\n+    type_ref::{TypeBound, TypeRef},\n+    AdtId, GenericDefId,\n+};\n+use hir_ty::display::{\n+    write_bounds_like_dyn_trait_with_prefix, write_visibility, HirDisplay, HirDisplayError,\n+    HirFormatter,\n+};\n+use syntax::ast::{self, NameOwner};\n+\n+use crate::{\n+    Const, ConstParam, Enum, Field, Function, HasVisibility, Module, Static, Struct, Substs, Trait,\n+    Type, TypeAlias, TypeParam, Union, Variant,\n+};\n+\n+impl HirDisplay for Function {\n+    fn hir_fmt(&self, f: &mut HirFormatter) -> Result<(), HirDisplayError> {\n+        let data = f.db.function_data(self.id);\n+        write_visibility(self.module(f.db).id, self.visibility(f.db), f)?;\n+        let qual = &data.qualifier;\n+        if qual.is_default {\n+            write!(f, \"default \")?;\n+        }\n+        if qual.is_const {\n+            write!(f, \"const \")?;\n+        }\n+        if qual.is_async {\n+            write!(f, \"async \")?;\n+        }\n+        if qual.is_unsafe {\n+            write!(f, \"unsafe \")?;\n+        }\n+        if let Some(abi) = &qual.abi {\n+            // FIXME: String escape?\n+            write!(f, \"extern \\\"{}\\\" \", abi)?;\n+        }\n+        write!(f, \"fn {}\", data.name)?;\n+\n+        write_generic_params(GenericDefId::FunctionId(self.id), f)?;\n+\n+        write!(f, \"(\")?;\n+\n+        let write_self_param = |ty: &TypeRef, f: &mut HirFormatter| match ty {\n+            TypeRef::Path(p) if p.is_self_type() => write!(f, \"self\"),\n+            TypeRef::Reference(inner, lifetime, mut_) if matches!(&**inner,TypeRef::Path(p) if p.is_self_type()) =>\n+            {\n+                write!(f, \"&\")?;\n+                if let Some(lifetime) = lifetime {\n+                    write!(f, \"{} \", lifetime.name)?;\n+                }\n+                if let hir_def::type_ref::Mutability::Mut = mut_ {\n+                    write!(f, \"mut \")?;\n+                }\n+                write!(f, \"self\")\n+            }\n+            _ => {\n+                write!(f, \"self: \")?;\n+                ty.hir_fmt(f)\n+            }\n+        };\n+\n+        let mut first = true;\n+        for (param, type_ref) in self.assoc_fn_params(f.db).into_iter().zip(&data.params) {\n+            if !first {\n+                write!(f, \", \")?;\n+            } else {\n+                first = false;\n+                if data.has_self_param {\n+                    write_self_param(type_ref, f)?;\n+                    continue;\n+                }\n+            }\n+            match param.pattern_source(f.db) {\n+                Some(ast::Pat::IdentPat(p)) if p.name().is_some() => {\n+                    write!(f, \"{}: \", p.name().unwrap())?\n+                }\n+                _ => write!(f, \"_: \")?,\n+            }\n+            // FIXME: Use resolved `param.ty` or raw `type_ref`?\n+            // The former will ignore lifetime arguments currently.\n+            type_ref.hir_fmt(f)?;\n+        }\n+        write!(f, \")\")?;\n+\n+        // `FunctionData::ret_type` will be `::core::future::Future<Output = ...>` for async fns.\n+        // Use ugly pattern match to strip the Future trait.\n+        // Better way?\n+        let ret_type = if !qual.is_async {\n+            &data.ret_type\n+        } else {\n+            match &data.ret_type {\n+                TypeRef::ImplTrait(bounds) => match &bounds[0] {\n+                    TypeBound::Path(path) => {\n+                        path.segments().iter().last().unwrap().args_and_bindings.unwrap().bindings\n+                            [0]\n+                        .type_ref\n+                        .as_ref()\n+                        .unwrap()\n+                    }\n+                    _ => panic!(\"Async fn ret_type should be impl Future\"),\n+                },\n+                _ => panic!(\"Async fn ret_type should be impl Future\"),\n+            }\n+        };\n+\n+        match ret_type {\n+            TypeRef::Tuple(tup) if tup.is_empty() => {}\n+            ty => {\n+                write!(f, \" -> \")?;\n+                ty.hir_fmt(f)?;\n+            }\n+        }\n+\n+        write_where_clause(GenericDefId::FunctionId(self.id), f)?;\n+\n+        Ok(())\n+    }\n+}\n+\n+impl HirDisplay for Struct {\n+    fn hir_fmt(&self, f: &mut HirFormatter) -> Result<(), HirDisplayError> {\n+        write_visibility(self.module(f.db).id, self.visibility(f.db), f)?;\n+        write!(f, \"struct \")?;\n+        write!(f, \"{}\", self.name(f.db))?;\n+        let def_id = GenericDefId::AdtId(AdtId::StructId(self.id));\n+        write_generic_params(def_id, f)?;\n+        write_where_clause(def_id, f)?;\n+        Ok(())\n+    }\n+}\n+\n+impl HirDisplay for Enum {\n+    fn hir_fmt(&self, f: &mut HirFormatter) -> Result<(), HirDisplayError> {\n+        write_visibility(self.module(f.db).id, self.visibility(f.db), f)?;\n+        write!(f, \"enum \")?;\n+        write!(f, \"{}\", self.name(f.db))?;\n+        let def_id = GenericDefId::AdtId(AdtId::EnumId(self.id));\n+        write_generic_params(def_id, f)?;\n+        write_where_clause(def_id, f)?;\n+        Ok(())\n+    }\n+}\n+\n+impl HirDisplay for Union {\n+    fn hir_fmt(&self, f: &mut HirFormatter) -> Result<(), HirDisplayError> {\n+        write_visibility(self.module(f.db).id, self.visibility(f.db), f)?;\n+        write!(f, \"union \")?;\n+        write!(f, \"{}\", self.name(f.db))?;\n+        let def_id = GenericDefId::AdtId(AdtId::UnionId(self.id));\n+        write_generic_params(def_id, f)?;\n+        write_where_clause(def_id, f)?;\n+        Ok(())\n+    }\n+}\n+\n+impl HirDisplay for Field {\n+    fn hir_fmt(&self, f: &mut HirFormatter) -> Result<(), HirDisplayError> {\n+        write_visibility(self.parent.module(f.db).id, self.visibility(f.db), f)?;\n+        write!(f, \"{}: \", self.name(f.db))?;\n+        self.signature_ty(f.db).hir_fmt(f)\n+    }\n+}\n+\n+impl HirDisplay for Variant {\n+    fn hir_fmt(&self, f: &mut HirFormatter) -> Result<(), HirDisplayError> {\n+        write!(f, \"{}\", self.name(f.db))?;\n+        let data = self.variant_data(f.db);\n+        match &*data {\n+            VariantData::Unit => {}\n+            VariantData::Tuple(fields) => {\n+                write!(f, \"(\")?;\n+                let mut first = true;\n+                for (_, field) in fields.iter() {\n+                    if first {\n+                        first = false;\n+                    } else {\n+                        write!(f, \", \")?;\n+                    }\n+                    // Enum variant fields must be pub.\n+                    field.type_ref.hir_fmt(f)?;\n+                }\n+                write!(f, \")\")?;\n+            }\n+            VariantData::Record(fields) => {\n+                write!(f, \" {{\")?;\n+                let mut first = true;\n+                for (_, field) in fields.iter() {\n+                    if first {\n+                        first = false;\n+                        write!(f, \" \")?;\n+                    } else {\n+                        write!(f, \", \")?;\n+                    }\n+                    // Enum variant fields must be pub.\n+                    write!(f, \"{}: \", field.name)?;\n+                    field.type_ref.hir_fmt(f)?;\n+                }\n+                write!(f, \" }}\")?;\n+            }\n+        }\n+        Ok(())\n+    }\n+}\n+\n+impl HirDisplay for Type {\n+    fn hir_fmt(&self, f: &mut HirFormatter) -> Result<(), HirDisplayError> {\n+        self.ty.value.hir_fmt(f)\n+    }\n+}\n+\n+impl HirDisplay for TypeParam {\n+    fn hir_fmt(&self, f: &mut HirFormatter) -> Result<(), HirDisplayError> {\n+        write!(f, \"{}\", self.name(f.db))?;\n+        let bounds = f.db.generic_predicates_for_param(self.id);\n+        let substs = Substs::type_params(f.db, self.id.parent);\n+        let predicates = bounds.iter().cloned().map(|b| b.subst(&substs)).collect::<Vec<_>>();\n+        if !(predicates.is_empty() || f.omit_verbose_types()) {\n+            write_bounds_like_dyn_trait_with_prefix(\":\", &predicates, f)?;\n+        }\n+        Ok(())\n+    }\n+}\n+\n+impl HirDisplay for ConstParam {\n+    fn hir_fmt(&self, f: &mut HirFormatter) -> Result<(), HirDisplayError> {\n+        write!(f, \"const {}: \", self.name(f.db))?;\n+        self.ty(f.db).hir_fmt(f)\n+    }\n+}\n+\n+fn write_generic_params(def: GenericDefId, f: &mut HirFormatter) -> Result<(), HirDisplayError> {\n+    let params = f.db.generic_params(def);\n+    if params.lifetimes.is_empty()\n+        && params.consts.is_empty()\n+        && params\n+            .types\n+            .iter()\n+            .all(|(_, param)| !matches!(param.provenance, TypeParamProvenance::TypeParamList))\n+    {\n+        return Ok(());\n+    }\n+    write!(f, \"<\")?;\n+\n+    let mut first = true;\n+    let mut delim = |f: &mut HirFormatter| {\n+        if first {\n+            first = false;\n+            Ok(())\n+        } else {\n+            write!(f, \", \")\n+        }\n+    };\n+    for (_, lifetime) in params.lifetimes.iter() {\n+        delim(f)?;\n+        write!(f, \"{}\", lifetime.name)?;\n+    }\n+    for (_, ty) in params.types.iter() {\n+        if ty.provenance != TypeParamProvenance::TypeParamList {\n+            continue;\n+        }\n+        if let Some(name) = &ty.name {\n+            delim(f)?;\n+            write!(f, \"{}\", name)?;\n+            if let Some(default) = &ty.default {\n+                write!(f, \" = \")?;\n+                default.hir_fmt(f)?;\n+            }\n+        }\n+    }\n+    for (_, konst) in params.consts.iter() {\n+        delim(f)?;\n+        write!(f, \"const {}: \", konst.name)?;\n+        konst.ty.hir_fmt(f)?;\n+    }\n+\n+    write!(f, \">\")?;\n+    Ok(())\n+}\n+\n+fn write_where_clause(def: GenericDefId, f: &mut HirFormatter) -> Result<(), HirDisplayError> {\n+    let params = f.db.generic_params(def);\n+    if params.where_predicates.is_empty() {\n+        return Ok(());\n+    }\n+\n+    let write_target = |target: &WherePredicateTypeTarget, f: &mut HirFormatter| match target {\n+        WherePredicateTypeTarget::TypeRef(ty) => ty.hir_fmt(f),\n+        WherePredicateTypeTarget::TypeParam(id) => match &params.types[*id].name {\n+            Some(name) => write!(f, \"{}\", name),\n+            None => write!(f, \"{{unnamed}}\"),\n+        },\n+    };\n+\n+    write!(f, \"\\nwhere\")?;\n+\n+    for (pred_idx, pred) in params.where_predicates.iter().enumerate() {\n+        let prev_pred =\n+            if pred_idx == 0 { None } else { Some(&params.where_predicates[pred_idx - 1]) };\n+\n+        let new_predicate = |f: &mut HirFormatter| {\n+            write!(f, \"{}\", if pred_idx == 0 { \"\\n    \" } else { \",\\n    \" })\n+        };\n+\n+        match pred {\n+            WherePredicate::TypeBound { target, bound } => {\n+                if matches!(prev_pred, Some(WherePredicate::TypeBound { target: target_, .. }) if target_ == target)\n+                {\n+                    write!(f, \" + \")?;\n+                } else {\n+                    new_predicate(f)?;\n+                    write_target(target, f)?;\n+                    write!(f, \": \")?;\n+                }\n+                bound.hir_fmt(f)?;\n+            }\n+            WherePredicate::Lifetime { target, bound } => {\n+                if matches!(prev_pred, Some(WherePredicate::Lifetime { target: target_, .. }) if target_ == target)\n+                {\n+                    write!(f, \" + {}\", bound.name)?;\n+                } else {\n+                    new_predicate(f)?;\n+                    write!(f, \"{}: {}\", target.name, bound.name)?;\n+                }\n+            }\n+            WherePredicate::ForLifetime { lifetimes, target, bound } => {\n+                if matches!(\n+                    prev_pred,\n+                    Some(WherePredicate::ForLifetime { lifetimes: lifetimes_, target: target_, .. })\n+                    if lifetimes_ == lifetimes && target_ == target,\n+                ) {\n+                    write!(f, \" + \")?;\n+                } else {\n+                    new_predicate(f)?;\n+                    write!(f, \"for<\")?;\n+                    for (idx, lifetime) in lifetimes.iter().enumerate() {\n+                        if idx != 0 {\n+                            write!(f, \", \")?;\n+                        }\n+                        write!(f, \"{}\", lifetime)?;\n+                    }\n+                    write!(f, \"> \")?;\n+                    write_target(target, f)?;\n+                    write!(f, \": \")?;\n+                }\n+                bound.hir_fmt(f)?;\n+            }\n+        }\n+    }\n+\n+    // End of final predicate. There must be at least one predicate here.\n+    write!(f, \",\")?;\n+\n+    Ok(())\n+}\n+\n+impl HirDisplay for Const {\n+    fn hir_fmt(&self, f: &mut HirFormatter) -> Result<(), HirDisplayError> {\n+        write_visibility(self.module(f.db).id, self.visibility(f.db), f)?;\n+        let data = f.db.const_data(self.id);\n+        write!(f, \"const \")?;\n+        match &data.name {\n+            Some(name) => write!(f, \"{}: \", name)?,\n+            None => write!(f, \"_: \")?,\n+        }\n+        data.type_ref.hir_fmt(f)?;\n+        Ok(())\n+    }\n+}\n+\n+impl HirDisplay for Static {\n+    fn hir_fmt(&self, f: &mut HirFormatter) -> Result<(), HirDisplayError> {\n+        write_visibility(self.module(f.db).id, self.visibility(f.db), f)?;\n+        let data = f.db.static_data(self.id);\n+        write!(f, \"static \")?;\n+        if data.mutable {\n+            write!(f, \"mut \")?;\n+        }\n+        match &data.name {\n+            Some(name) => write!(f, \"{}: \", name)?,\n+            None => write!(f, \"_: \")?,\n+        }\n+        data.type_ref.hir_fmt(f)?;\n+        Ok(())\n+    }\n+}\n+\n+impl HirDisplay for Trait {\n+    fn hir_fmt(&self, f: &mut HirFormatter) -> Result<(), HirDisplayError> {\n+        write_visibility(self.module(f.db).id, self.visibility(f.db), f)?;\n+        let data = f.db.trait_data(self.id);\n+        if data.is_unsafe {\n+            write!(f, \"unsafe \")?;\n+        }\n+        if data.is_auto {\n+            write!(f, \"auto \")?;\n+        }\n+        write!(f, \"trait {}\", data.name)?;\n+        let def_id = GenericDefId::TraitId(self.id);\n+        write_generic_params(def_id, f)?;\n+        if !data.bounds.is_empty() {\n+            write!(f, \": \")?;\n+            f.write_joined(&*data.bounds, \" + \")?;\n+        }\n+        write_where_clause(def_id, f)?;\n+        Ok(())\n+    }\n+}\n+\n+impl HirDisplay for TypeAlias {\n+    fn hir_fmt(&self, f: &mut HirFormatter) -> Result<(), HirDisplayError> {\n+        write_visibility(self.module(f.db).id, self.visibility(f.db), f)?;\n+        let data = f.db.type_alias_data(self.id);\n+        write!(f, \"type {}\", data.name)?;\n+        if !data.bounds.is_empty() {\n+            write!(f, \": \")?;\n+            f.write_joined(&data.bounds, \" + \")?;\n+        }\n+        if let Some(ty) = &data.type_ref {\n+            write!(f, \" = \")?;\n+            ty.hir_fmt(f)?;\n+        }\n+        Ok(())\n+    }\n+}\n+\n+impl HirDisplay for Module {\n+    fn hir_fmt(&self, f: &mut HirFormatter) -> Result<(), HirDisplayError> {\n+        // FIXME: Module doesn't have visibility saved in data.\n+        match self.name(f.db) {\n+            Some(name) => write!(f, \"mod {}\", name),\n+            None if self.crate_root(f.db) == *self => match self.krate().display_name(f.db) {\n+                Some(name) => write!(f, \"extern crate {}\", name),\n+                None => write!(f, \"extern crate {{unknown}}\"),\n+            },\n+            None => write!(f, \"mod {{unnamed}}\"),\n+        }\n+    }\n+}"}, {"sha": "f0bc2c7b952a250eb4af7600089ef2776f9e8b01", "filename": "crates/hir/src/lib.rs", "status": "modified", "additions": 61, "deletions": 24, "changes": 85, "blob_url": "https://github.com/rust-lang/rust/blob/1a82af3527e476d52410ff4dfd2fb4c57466abcb/crates%2Fhir%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1a82af3527e476d52410ff4dfd2fb4c57466abcb/crates%2Fhir%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir%2Fsrc%2Flib.rs?ref=1a82af3527e476d52410ff4dfd2fb4c57466abcb", "patch": "@@ -29,6 +29,8 @@ mod has_source;\n pub mod diagnostics;\n pub mod db;\n \n+mod display;\n+\n use std::{iter, sync::Arc};\n \n use arrayvec::ArrayVec;\n@@ -50,7 +52,6 @@ use hir_def::{\n use hir_expand::{diagnostics::DiagnosticSink, name::name, MacroDefKind};\n use hir_ty::{\n     autoderef,\n-    display::{write_bounds_like_dyn_trait_with_prefix, HirDisplayError, HirFormatter},\n     method_resolution::{self, TyFingerprint},\n     primitive::UintTy,\n     to_assoc_type_id,\n@@ -572,6 +573,12 @@ impl Struct {\n     }\n }\n \n+impl HasVisibility for Struct {\n+    fn visibility(&self, db: &dyn HirDatabase) -> Visibility {\n+        db.struct_data(self.id).visibility.resolve(db.upcast(), &self.id.resolver(db.upcast()))\n+    }\n+}\n+\n #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n pub struct Union {\n     pub(crate) id: UnionId,\n@@ -604,6 +611,12 @@ impl Union {\n     }\n }\n \n+impl HasVisibility for Union {\n+    fn visibility(&self, db: &dyn HirDatabase) -> Visibility {\n+        db.union_data(self.id).visibility.resolve(db.upcast(), &self.id.resolver(db.upcast()))\n+    }\n+}\n+\n #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n pub struct Enum {\n     pub(crate) id: EnumId,\n@@ -631,6 +644,12 @@ impl Enum {\n     }\n }\n \n+impl HasVisibility for Enum {\n+    fn visibility(&self, db: &dyn HirDatabase) -> Visibility {\n+        db.enum_data(self.id).visibility.resolve(db.upcast(), &self.id.resolver(db.upcast()))\n+    }\n+}\n+\n #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n pub struct Variant {\n     pub(crate) parent: Enum,\n@@ -822,15 +841,16 @@ impl Function {\n         db.function_data(self.id)\n             .params\n             .iter()\n-            .map(|type_ref| {\n+            .enumerate()\n+            .map(|(idx, type_ref)| {\n                 let ty = Type {\n                     krate,\n                     ty: InEnvironment {\n                         value: ctx.lower_ty(type_ref),\n                         environment: environment.clone(),\n                     },\n                 };\n-                Param { ty }\n+                Param { func: self, ty, idx }\n             })\n             .collect()\n     }\n@@ -844,7 +864,7 @@ impl Function {\n     }\n \n     pub fn is_unsafe(self, db: &dyn HirDatabase) -> bool {\n-        db.function_data(self.id).is_unsafe\n+        db.function_data(self.id).qualifier.is_unsafe\n     }\n \n     pub fn diagnostics(self, db: &dyn HirDatabase, sink: &mut DiagnosticSink) {\n@@ -893,13 +913,25 @@ impl From<hir_ty::Mutability> for Access {\n \n #[derive(Debug)]\n pub struct Param {\n+    func: Function,\n+    /// The index in parameter list, including self parameter.\n+    idx: usize,\n     ty: Type,\n }\n \n impl Param {\n     pub fn ty(&self) -> &Type {\n         &self.ty\n     }\n+\n+    pub fn pattern_source(&self, db: &dyn HirDatabase) -> Option<ast::Pat> {\n+        let params = self.func.source(db)?.value.param_list()?;\n+        if params.self_param().is_some() {\n+            params.params().nth(self.idx.checked_sub(1)?)?.pat()\n+        } else {\n+            params.params().nth(self.idx)?.pat()\n+        }\n+    }\n }\n \n #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n@@ -922,6 +954,14 @@ impl SelfParam {\n             })\n             .unwrap_or(Access::Owned)\n     }\n+\n+    pub fn display(self, db: &dyn HirDatabase) -> &'static str {\n+        match self.access(db) {\n+            Access::Shared => \"&self\",\n+            Access::Exclusive => \"&mut self\",\n+            Access::Owned => \"self\",\n+        }\n+    }\n }\n \n impl HasVisibility for Function {\n@@ -949,6 +989,10 @@ impl Const {\n     pub fn name(self, db: &dyn HirDatabase) -> Option<Name> {\n         db.const_data(self.id).name.clone()\n     }\n+\n+    pub fn type_ref(self, db: &dyn HirDatabase) -> TypeRef {\n+        db.const_data(self.id).type_ref.clone()\n+    }\n }\n \n impl HasVisibility for Const {\n@@ -982,6 +1026,12 @@ impl Static {\n     }\n }\n \n+impl HasVisibility for Static {\n+    fn visibility(&self, db: &dyn HirDatabase) -> Visibility {\n+        db.static_data(self.id).visibility.resolve(db.upcast(), &self.id.resolver(db.upcast()))\n+    }\n+}\n+\n #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n pub struct Trait {\n     pub(crate) id: TraitId,\n@@ -1001,7 +1051,13 @@ impl Trait {\n     }\n \n     pub fn is_auto(self, db: &dyn HirDatabase) -> bool {\n-        db.trait_data(self.id).auto\n+        db.trait_data(self.id).is_auto\n+    }\n+}\n+\n+impl HasVisibility for Trait {\n+    fn visibility(&self, db: &dyn HirDatabase) -> Visibility {\n+        db.trait_data(self.id).visibility.resolve(db.upcast(), &self.id.resolver(db.upcast()))\n     }\n }\n \n@@ -1413,19 +1469,6 @@ impl TypeParam {\n     }\n }\n \n-impl HirDisplay for TypeParam {\n-    fn hir_fmt(&self, f: &mut HirFormatter) -> Result<(), HirDisplayError> {\n-        write!(f, \"{}\", self.name(f.db))?;\n-        let bounds = f.db.generic_predicates_for_param(self.id);\n-        let substs = Substs::type_params(f.db, self.id.parent);\n-        let predicates = bounds.iter().cloned().map(|b| b.subst(&substs)).collect::<Vec<_>>();\n-        if !(predicates.is_empty() || f.omit_verbose_types()) {\n-            write_bounds_like_dyn_trait_with_prefix(\":\", &predicates, f)?;\n-        }\n-        Ok(())\n-    }\n-}\n-\n #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]\n pub struct LifetimeParam {\n     pub(crate) id: LifetimeParamId,\n@@ -2059,12 +2102,6 @@ impl Type {\n     }\n }\n \n-impl HirDisplay for Type {\n-    fn hir_fmt(&self, f: &mut HirFormatter) -> Result<(), HirDisplayError> {\n-        self.ty.value.hir_fmt(f)\n-    }\n-}\n-\n // FIXME: closures\n #[derive(Debug)]\n pub struct Callable {"}, {"sha": "1b9bb8235f214a3adc54c06812298ce6b86b146f", "filename": "crates/hir_def/src/adt.rs", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/1a82af3527e476d52410ff4dfd2fb4c57466abcb/crates%2Fhir_def%2Fsrc%2Fadt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1a82af3527e476d52410ff4dfd2fb4c57466abcb/crates%2Fhir_def%2Fsrc%2Fadt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_def%2Fsrc%2Fadt.rs?ref=1a82af3527e476d52410ff4dfd2fb4c57466abcb", "patch": "@@ -31,12 +31,14 @@ pub struct StructData {\n     pub name: Name,\n     pub variant_data: Arc<VariantData>,\n     pub repr: Option<ReprKind>,\n+    pub visibility: RawVisibility,\n }\n \n #[derive(Debug, Clone, PartialEq, Eq)]\n pub struct EnumData {\n     pub name: Name,\n     pub variants: Arena<EnumVariantData>,\n+    pub visibility: RawVisibility,\n }\n \n #[derive(Debug, Clone, PartialEq, Eq)]\n@@ -102,6 +104,7 @@ impl StructData {\n             name: strukt.name.clone(),\n             variant_data: Arc::new(variant_data),\n             repr,\n+            visibility: item_tree[strukt.visibility].clone(),\n         })\n     }\n     pub(crate) fn union_data_query(db: &dyn DefDatabase, id: UnionId) -> Arc<StructData> {\n@@ -118,6 +121,7 @@ impl StructData {\n             name: union.name.clone(),\n             variant_data: Arc::new(variant_data),\n             repr,\n+            visibility: item_tree[union.visibility].clone(),\n         })\n     }\n }\n@@ -150,7 +154,11 @@ impl EnumData {\n             }\n         }\n \n-        Arc::new(EnumData { name: enum_.name.clone(), variants })\n+        Arc::new(EnumData {\n+            name: enum_.name.clone(),\n+            variants,\n+            visibility: item_tree[enum_.visibility].clone(),\n+        })\n     }\n \n     pub fn variant(&self, name: &Name) -> Option<LocalEnumVariantId> {"}, {"sha": "74a2194e5e7bf339b7ea216464262b185238c22f", "filename": "crates/hir_def/src/data.rs", "status": "modified", "additions": 14, "deletions": 8, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/1a82af3527e476d52410ff4dfd2fb4c57466abcb/crates%2Fhir_def%2Fsrc%2Fdata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1a82af3527e476d52410ff4dfd2fb4c57466abcb/crates%2Fhir_def%2Fsrc%2Fdata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_def%2Fsrc%2Fdata.rs?ref=1a82af3527e476d52410ff4dfd2fb4c57466abcb", "patch": "@@ -9,7 +9,7 @@ use crate::{\n     attr::Attrs,\n     body::Expander,\n     db::DefDatabase,\n-    item_tree::{AssocItem, ItemTreeId, ModItem},\n+    item_tree::{AssocItem, FunctionQualifier, ItemTreeId, ModItem},\n     type_ref::{TypeBound, TypeRef},\n     visibility::RawVisibility,\n     AssocContainerId, AssocItemId, ConstId, ConstLoc, FunctionId, FunctionLoc, HasModule, ImplId,\n@@ -26,9 +26,9 @@ pub struct FunctionData {\n     /// can be called as a method.\n     pub has_self_param: bool,\n     pub has_body: bool,\n-    pub is_unsafe: bool,\n+    pub qualifier: FunctionQualifier,\n+    pub is_in_extern_block: bool,\n     pub is_varargs: bool,\n-    pub is_extern: bool,\n     pub visibility: RawVisibility,\n }\n \n@@ -46,9 +46,9 @@ impl FunctionData {\n             attrs: item_tree.attrs(db, krate, ModItem::from(loc.id.value).into()),\n             has_self_param: func.has_self_param,\n             has_body: func.has_body,\n-            is_unsafe: func.is_unsafe,\n+            qualifier: func.qualifier.clone(),\n+            is_in_extern_block: func.is_in_extern_block,\n             is_varargs: func.is_varargs,\n-            is_extern: func.is_extern,\n             visibility: item_tree[func.visibility].clone(),\n         })\n     }\n@@ -87,7 +87,10 @@ impl TypeAliasData {\n pub struct TraitData {\n     pub name: Name,\n     pub items: Vec<(Name, AssocItemId)>,\n-    pub auto: bool,\n+    pub is_auto: bool,\n+    pub is_unsafe: bool,\n+    pub visibility: RawVisibility,\n+    pub bounds: Box<[TypeBound]>,\n }\n \n impl TraitData {\n@@ -96,10 +99,13 @@ impl TraitData {\n         let item_tree = db.item_tree(tr_loc.id.file_id);\n         let tr_def = &item_tree[tr_loc.id.value];\n         let name = tr_def.name.clone();\n-        let auto = tr_def.auto;\n+        let is_auto = tr_def.is_auto;\n+        let is_unsafe = tr_def.is_unsafe;\n         let module_id = tr_loc.container;\n         let container = AssocContainerId::TraitId(tr);\n         let mut expander = Expander::new(db, tr_loc.id.file_id, module_id);\n+        let visibility = item_tree[tr_def.visibility].clone();\n+        let bounds = tr_def.bounds.clone();\n \n         let items = collect_items(\n             db,\n@@ -111,7 +117,7 @@ impl TraitData {\n             100,\n         );\n \n-        Arc::new(TraitData { name, items, auto })\n+        Arc::new(TraitData { name, items, is_auto, is_unsafe, visibility, bounds })\n     }\n \n     pub fn associated_types(&self) -> impl Iterator<Item = TypeAliasId> + '_ {"}, {"sha": "7bb22c4c49fd55490d562d722621d87dc5c0b4c6", "filename": "crates/hir_def/src/item_tree.rs", "status": "modified", "additions": 15, "deletions": 4, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/1a82af3527e476d52410ff4dfd2fb4c57466abcb/crates%2Fhir_def%2Fsrc%2Fitem_tree.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1a82af3527e476d52410ff4dfd2fb4c57466abcb/crates%2Fhir_def%2Fsrc%2Fitem_tree.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_def%2Fsrc%2Fitem_tree.rs?ref=1a82af3527e476d52410ff4dfd2fb4c57466abcb", "patch": "@@ -24,7 +24,7 @@ use la_arena::{Arena, Idx, RawIdx};\n use profile::Count;\n use rustc_hash::FxHashMap;\n use smallvec::SmallVec;\n-use syntax::{ast, match_ast, SyntaxKind};\n+use syntax::{ast, match_ast, SmolStr, SyntaxKind};\n \n use crate::{\n     attr::{Attrs, RawAttrs},\n@@ -556,16 +556,25 @@ pub struct Function {\n     pub generic_params: GenericParamsId,\n     pub has_self_param: bool,\n     pub has_body: bool,\n-    pub is_unsafe: bool,\n+    pub qualifier: FunctionQualifier,\n     /// Whether the function is located in an `extern` block (*not* whether it is an\n     /// `extern \"abi\" fn`).\n-    pub is_extern: bool,\n+    pub is_in_extern_block: bool,\n     pub params: Box<[Idx<TypeRef>]>,\n     pub is_varargs: bool,\n     pub ret_type: Idx<TypeRef>,\n     pub ast_id: FileAstId<ast::Fn>,\n }\n \n+#[derive(Debug, Clone, PartialEq, Eq)]\n+pub struct FunctionQualifier {\n+    pub is_default: bool,\n+    pub is_const: bool,\n+    pub is_async: bool,\n+    pub is_unsafe: bool,\n+    pub abi: Option<SmolStr>,\n+}\n+\n #[derive(Debug, Clone, Eq, PartialEq)]\n pub struct Struct {\n     pub name: Name,\n@@ -629,7 +638,9 @@ pub struct Trait {\n     pub name: Name,\n     pub visibility: RawVisibilityId,\n     pub generic_params: GenericParamsId,\n-    pub auto: bool,\n+    pub is_auto: bool,\n+    pub is_unsafe: bool,\n+    pub bounds: Box<[TypeBound]>,\n     pub items: Box<[AssocItem]>,\n     pub ast_id: FileAstId<ast::Trait>,\n }"}, {"sha": "7e91b991d2cf60d36340b996c281d37453c67b0a", "filename": "crates/hir_def/src/item_tree/lower.rs", "status": "modified", "additions": 29, "deletions": 6, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/1a82af3527e476d52410ff4dfd2fb4c57466abcb/crates%2Fhir_def%2Fsrc%2Fitem_tree%2Flower.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1a82af3527e476d52410ff4dfd2fb4c57466abcb/crates%2Fhir_def%2Fsrc%2Fitem_tree%2Flower.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_def%2Fsrc%2Fitem_tree%2Flower.rs?ref=1a82af3527e476d52410ff4dfd2fb4c57466abcb", "patch": "@@ -391,14 +391,33 @@ impl Ctx {\n         let has_body = func.body().is_some();\n \n         let ast_id = self.source_ast_id_map.ast_id(func);\n+        let qualifier = FunctionQualifier {\n+            is_default: func.default_token().is_some(),\n+            is_const: func.const_token().is_some(),\n+            is_async: func.async_token().is_some(),\n+            is_unsafe: func.unsafe_token().is_some(),\n+            abi: func.abi().map(|abi| {\n+                // FIXME: Abi::abi() -> Option<SyntaxToken>?\n+                match abi.syntax().last_token() {\n+                    Some(tok) if tok.kind() == SyntaxKind::STRING => {\n+                        // FIXME: Better way to unescape?\n+                        tok.text().trim_matches('\"').into()\n+                    }\n+                    _ => {\n+                        // `extern` default to be `extern \"C\"`.\n+                        \"C\".into()\n+                    }\n+                }\n+            }),\n+        };\n         let mut res = Function {\n             name,\n             visibility,\n             generic_params: GenericParamsId::EMPTY,\n             has_self_param,\n             has_body,\n-            is_unsafe: func.unsafe_token().is_some(),\n-            is_extern: false,\n+            qualifier,\n+            is_in_extern_block: false,\n             params,\n             is_varargs,\n             ret_type,\n@@ -481,7 +500,9 @@ impl Ctx {\n         let visibility = self.lower_visibility(trait_def);\n         let generic_params =\n             self.lower_generic_params_and_inner_items(GenericsOwner::Trait(trait_def), trait_def);\n-        let auto = trait_def.auto_token().is_some();\n+        let is_auto = trait_def.auto_token().is_some();\n+        let is_unsafe = trait_def.unsafe_token().is_some();\n+        let bounds = self.lower_type_bounds(trait_def);\n         let items = trait_def.assoc_item_list().map(|list| {\n             self.with_inherited_visibility(visibility, |this| {\n                 list.assoc_items()\n@@ -501,7 +522,9 @@ impl Ctx {\n             name,\n             visibility,\n             generic_params,\n-            auto,\n+            is_auto,\n+            is_unsafe,\n+            bounds: bounds.into(),\n             items: items.unwrap_or_default(),\n             ast_id,\n         };\n@@ -608,8 +631,8 @@ impl Ctx {\n                         ast::ExternItem::Fn(ast) => {\n                             let func_id = self.lower_function(&ast)?;\n                             let func = &mut self.data().functions[func_id.index];\n-                            func.is_unsafe = is_intrinsic_fn_unsafe(&func.name);\n-                            func.is_extern = true;\n+                            func.qualifier.is_unsafe = is_intrinsic_fn_unsafe(&func.name);\n+                            func.is_in_extern_block = true;\n                             func_id.into()\n                         }\n                         ast::ExternItem::Static(ast) => {"}, {"sha": "8c923bb7b28d651d0349532e577902155a0188b5", "filename": "crates/hir_def/src/path.rs", "status": "modified", "additions": 10, "deletions": 1, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/1a82af3527e476d52410ff4dfd2fb4c57466abcb/crates%2Fhir_def%2Fsrc%2Fpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1a82af3527e476d52410ff4dfd2fb4c57466abcb/crates%2Fhir_def%2Fsrc%2Fpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_def%2Fsrc%2Fpath.rs?ref=1a82af3527e476d52410ff4dfd2fb4c57466abcb", "patch": "@@ -9,7 +9,10 @@ use std::{\n \n use crate::{body::LowerCtx, type_ref::LifetimeRef};\n use base_db::CrateId;\n-use hir_expand::{hygiene::Hygiene, name::Name};\n+use hir_expand::{\n+    hygiene::Hygiene,\n+    name::{name, Name},\n+};\n use syntax::ast;\n \n use crate::{\n@@ -209,6 +212,12 @@ impl Path {\n         };\n         Some(res)\n     }\n+\n+    pub fn is_self_type(&self) -> bool {\n+        self.type_anchor.is_none()\n+            && self.generic_args == &[None]\n+            && self.mod_path.as_ident() == Some(&name!(Self))\n+    }\n }\n \n #[derive(Debug, Clone, PartialEq, Eq, Hash)]"}, {"sha": "982ad5b9e0041982dd26748b4f76a2304b9267c4", "filename": "crates/hir_ty/src/diagnostics/decl_check.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1a82af3527e476d52410ff4dfd2fb4c57466abcb/crates%2Fhir_ty%2Fsrc%2Fdiagnostics%2Fdecl_check.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1a82af3527e476d52410ff4dfd2fb4c57466abcb/crates%2Fhir_ty%2Fsrc%2Fdiagnostics%2Fdecl_check.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Fdiagnostics%2Fdecl_check.rs?ref=1a82af3527e476d52410ff4dfd2fb4c57466abcb", "patch": "@@ -91,7 +91,7 @@ impl<'a, 'b> DeclValidator<'a, 'b> {\n \n     fn validate_func(&mut self, func: FunctionId) {\n         let data = self.db.function_data(func);\n-        if data.is_extern {\n+        if data.is_in_extern_block {\n             cov_mark::hit!(extern_func_incorrect_case_ignored);\n             return;\n         }"}, {"sha": "44a7e550647debda53baf7599ade10f8446772f3", "filename": "crates/hir_ty/src/diagnostics/unsafe_check.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/1a82af3527e476d52410ff4dfd2fb4c57466abcb/crates%2Fhir_ty%2Fsrc%2Fdiagnostics%2Funsafe_check.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1a82af3527e476d52410ff4dfd2fb4c57466abcb/crates%2Fhir_ty%2Fsrc%2Fdiagnostics%2Funsafe_check.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Fdiagnostics%2Funsafe_check.rs?ref=1a82af3527e476d52410ff4dfd2fb4c57466abcb", "patch": "@@ -32,7 +32,7 @@ impl<'a, 'b> UnsafeValidator<'a, 'b> {\n         let def = self.owner.into();\n         let unsafe_expressions = unsafe_expressions(db, self.infer.as_ref(), def);\n         let is_unsafe = match self.owner {\n-            DefWithBodyId::FunctionId(it) => db.function_data(it).is_unsafe,\n+            DefWithBodyId::FunctionId(it) => db.function_data(it).qualifier.is_unsafe,\n             DefWithBodyId::StaticId(_) | DefWithBodyId::ConstId(_) => false,\n         };\n         if is_unsafe\n@@ -86,7 +86,7 @@ fn walk_unsafe(\n     match expr {\n         &Expr::Call { callee, .. } => {\n             if let Some(func) = infer[callee].as_fn_def(db) {\n-                if db.function_data(func).is_unsafe {\n+                if db.function_data(func).qualifier.is_unsafe {\n                     unsafe_exprs.push(UnsafeExpr { expr: current, inside_unsafe_block });\n                 }\n             }\n@@ -103,7 +103,7 @@ fn walk_unsafe(\n         Expr::MethodCall { .. } => {\n             if infer\n                 .method_resolution(current)\n-                .map(|func| db.function_data(func).is_unsafe)\n+                .map(|func| db.function_data(func).qualifier.is_unsafe)\n                 .unwrap_or(false)\n             {\n                 unsafe_exprs.push(UnsafeExpr { expr: current, inside_unsafe_block });"}, {"sha": "c572bb1141e9118be9280880f58b132a67ae1c75", "filename": "crates/hir_ty/src/display.rs", "status": "modified", "additions": 195, "deletions": 8, "changes": 203, "blob_url": "https://github.com/rust-lang/rust/blob/1a82af3527e476d52410ff4dfd2fb4c57466abcb/crates%2Fhir_ty%2Fsrc%2Fdisplay.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1a82af3527e476d52410ff4dfd2fb4c57466abcb/crates%2Fhir_ty%2Fsrc%2Fdisplay.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Fdisplay.rs?ref=1a82af3527e476d52410ff4dfd2fb4c57466abcb", "patch": "@@ -5,7 +5,13 @@ use std::{borrow::Cow, fmt};\n use arrayvec::ArrayVec;\n use chalk_ir::Mutability;\n use hir_def::{\n-    db::DefDatabase, find_path, generics::TypeParamProvenance, item_scope::ItemInNs,\n+    db::DefDatabase,\n+    find_path,\n+    generics::TypeParamProvenance,\n+    item_scope::ItemInNs,\n+    path::{GenericArg, Path, PathKind},\n+    type_ref::{TypeBound, TypeRef},\n+    visibility::Visibility,\n     AssocContainerId, Lookup, ModuleId, TraitId,\n };\n use hir_expand::name::Name;\n@@ -232,7 +238,7 @@ where\n \n const TYPE_HINT_TRUNCATION: &str = \"\u2026\";\n \n-impl HirDisplay for &Ty {\n+impl<T: HirDisplay> HirDisplay for &'_ T {\n     fn hir_fmt(&self, f: &mut HirFormatter) -> Result<(), HirDisplayError> {\n         HirDisplay::hir_fmt(*self, f)\n     }\n@@ -761,12 +767,6 @@ impl HirDisplay for TraitRef {\n     }\n }\n \n-impl HirDisplay for &GenericPredicate {\n-    fn hir_fmt(&self, f: &mut HirFormatter) -> Result<(), HirDisplayError> {\n-        HirDisplay::hir_fmt(*self, f)\n-    }\n-}\n-\n impl HirDisplay for GenericPredicate {\n     fn hir_fmt(&self, f: &mut HirFormatter) -> Result<(), HirDisplayError> {\n         if f.should_truncate() {\n@@ -825,3 +825,190 @@ impl HirDisplay for Obligation {\n         }\n     }\n }\n+\n+pub fn write_visibility(\n+    module_id: ModuleId,\n+    vis: Visibility,\n+    f: &mut HirFormatter,\n+) -> Result<(), HirDisplayError> {\n+    match vis {\n+        Visibility::Public => write!(f, \"pub \"),\n+        Visibility::Module(vis_id) => {\n+            let def_map = module_id.def_map(f.db.upcast());\n+            let root_module_id = def_map.module_id(def_map.root());\n+            if vis_id == module_id {\n+                // pub(self) or omitted\n+                Ok(())\n+            } else if root_module_id == vis_id {\n+                write!(f, \"pub(crate) \")\n+            } else if module_id.containing_module(f.db.upcast()) == Some(vis_id) {\n+                write!(f, \"pub(super) \")\n+            } else {\n+                write!(f, \"pub(in ...) \")\n+            }\n+        }\n+    }\n+}\n+\n+impl HirDisplay for TypeRef {\n+    fn hir_fmt(&self, f: &mut HirFormatter) -> Result<(), HirDisplayError> {\n+        match self {\n+            TypeRef::Never => write!(f, \"!\")?,\n+            TypeRef::Placeholder => write!(f, \"_\")?,\n+            TypeRef::Tuple(elems) => {\n+                write!(f, \"(\")?;\n+                f.write_joined(elems, \", \")?;\n+                if elems.len() == 1 {\n+                    write!(f, \",\")?;\n+                }\n+                write!(f, \")\")?;\n+            }\n+            TypeRef::Path(path) => path.hir_fmt(f)?,\n+            TypeRef::RawPtr(inner, mutability) => {\n+                let mutability = match mutability {\n+                    hir_def::type_ref::Mutability::Shared => \"*const \",\n+                    hir_def::type_ref::Mutability::Mut => \"*mut \",\n+                };\n+                write!(f, \"{}\", mutability)?;\n+                inner.hir_fmt(f)?;\n+            }\n+            TypeRef::Reference(inner, lifetime, mutability) => {\n+                let mutability = match mutability {\n+                    hir_def::type_ref::Mutability::Shared => \"\",\n+                    hir_def::type_ref::Mutability::Mut => \"mut \",\n+                };\n+                write!(f, \"&\")?;\n+                if let Some(lifetime) = lifetime {\n+                    write!(f, \"{} \", lifetime.name)?;\n+                }\n+                write!(f, \"{}\", mutability)?;\n+                inner.hir_fmt(f)?;\n+            }\n+            TypeRef::Array(inner) => {\n+                write!(f, \"[\")?;\n+                inner.hir_fmt(f)?;\n+                // FIXME: Array length?\n+                write!(f, \"; _]\")?;\n+            }\n+            TypeRef::Slice(inner) => {\n+                write!(f, \"[\")?;\n+                inner.hir_fmt(f)?;\n+                write!(f, \"]\")?;\n+            }\n+            TypeRef::Fn(tys, is_varargs) => {\n+                // FIXME: Function pointer qualifiers.\n+                write!(f, \"fn(\")?;\n+                f.write_joined(&tys[..tys.len() - 1], \", \")?;\n+                if *is_varargs {\n+                    write!(f, \"{}...\", if tys.len() == 1 { \"\" } else { \", \" })?;\n+                }\n+                write!(f, \")\")?;\n+                let ret_ty = tys.last().unwrap();\n+                match ret_ty {\n+                    TypeRef::Tuple(tup) if tup.is_empty() => {}\n+                    _ => {\n+                        write!(f, \" -> \")?;\n+                        ret_ty.hir_fmt(f)?;\n+                    }\n+                }\n+            }\n+            TypeRef::ImplTrait(bounds) => {\n+                write!(f, \"impl \")?;\n+                f.write_joined(bounds, \" + \")?;\n+            }\n+            TypeRef::DynTrait(bounds) => {\n+                write!(f, \"dyn \")?;\n+                f.write_joined(bounds, \" + \")?;\n+            }\n+            TypeRef::Error => write!(f, \"{{error}}\")?,\n+        }\n+        Ok(())\n+    }\n+}\n+\n+impl HirDisplay for TypeBound {\n+    fn hir_fmt(&self, f: &mut HirFormatter) -> Result<(), HirDisplayError> {\n+        match self {\n+            TypeBound::Path(path) => path.hir_fmt(f),\n+            TypeBound::Lifetime(lifetime) => write!(f, \"{}\", lifetime.name),\n+            TypeBound::Error => write!(f, \"{{error}}\"),\n+        }\n+    }\n+}\n+\n+impl HirDisplay for Path {\n+    fn hir_fmt(&self, f: &mut HirFormatter) -> Result<(), HirDisplayError> {\n+        match (self.type_anchor(), self.kind()) {\n+            (Some(anchor), _) => {\n+                write!(f, \"<\")?;\n+                anchor.hir_fmt(f)?;\n+                write!(f, \">\")?;\n+            }\n+            (_, PathKind::Plain) => {}\n+            (_, PathKind::Abs) => write!(f, \"::\")?,\n+            (_, PathKind::Crate) => write!(f, \"crate\")?,\n+            (_, PathKind::Super(0)) => write!(f, \"self\")?,\n+            (_, PathKind::Super(n)) => {\n+                write!(f, \"super\")?;\n+                for _ in 0..*n {\n+                    write!(f, \"::super\")?;\n+                }\n+            }\n+            (_, PathKind::DollarCrate(_)) => write!(f, \"{{extern_crate}}\")?,\n+        }\n+\n+        for (seg_idx, segment) in self.segments().iter().enumerate() {\n+            if seg_idx != 0 {\n+                write!(f, \"::\")?;\n+            }\n+            write!(f, \"{}\", segment.name)?;\n+            if let Some(generic_args) = segment.args_and_bindings {\n+                // We should be in type context, so format as `Foo<Bar>` instead of `Foo::<Bar>`.\n+                // Do we actually format expressions?\n+                write!(f, \"<\")?;\n+                let mut first = true;\n+                for arg in &generic_args.args {\n+                    if first {\n+                        first = false;\n+                        if generic_args.has_self_type {\n+                            // FIXME: Convert to `<Ty as Trait>` form.\n+                            write!(f, \"Self = \")?;\n+                        }\n+                    } else {\n+                        write!(f, \", \")?;\n+                    }\n+                    arg.hir_fmt(f)?;\n+                }\n+                for binding in &generic_args.bindings {\n+                    if first {\n+                        first = false;\n+                    } else {\n+                        write!(f, \", \")?;\n+                    }\n+                    write!(f, \"{}\", binding.name)?;\n+                    match &binding.type_ref {\n+                        Some(ty) => {\n+                            write!(f, \" = \")?;\n+                            ty.hir_fmt(f)?\n+                        }\n+                        None => {\n+                            write!(f, \": \")?;\n+                            f.write_joined(&binding.bounds, \" + \")?;\n+                        }\n+                    }\n+                }\n+                write!(f, \">\")?;\n+            }\n+        }\n+        Ok(())\n+    }\n+}\n+\n+impl HirDisplay for GenericArg {\n+    fn hir_fmt(&self, f: &mut HirFormatter) -> Result<(), HirDisplayError> {\n+        match self {\n+            GenericArg::Type(ty) => ty.hir_fmt(f),\n+            GenericArg::Lifetime(lifetime) => write!(f, \"{}\", lifetime.name),\n+        }\n+    }\n+}"}, {"sha": "4bd8ba3031563afb00e874e9f73400c8696d2d4a", "filename": "crates/hir_ty/src/traits/chalk.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1a82af3527e476d52410ff4dfd2fb4c57466abcb/crates%2Fhir_ty%2Fsrc%2Ftraits%2Fchalk.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1a82af3527e476d52410ff4dfd2fb4c57466abcb/crates%2Fhir_ty%2Fsrc%2Ftraits%2Fchalk.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Ftraits%2Fchalk.rs?ref=1a82af3527e476d52410ff4dfd2fb4c57466abcb", "patch": "@@ -429,7 +429,7 @@ pub(crate) fn trait_datum_query(\n     let generic_params = generics(db.upcast(), trait_.into());\n     let bound_vars = Substs::bound_vars(&generic_params, DebruijnIndex::INNERMOST);\n     let flags = rust_ir::TraitFlags {\n-        auto: trait_data.auto,\n+        auto: trait_data.is_auto,\n         upstream: trait_.lookup(db.upcast()).container.krate() != krate,\n         non_enumerable: true,\n         coinductive: false, // only relevant for Chalk testing"}, {"sha": "1f7b665c07896ba8be14e1347d15acbd6e771650", "filename": "crates/ide/src/display.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/1a82af3527e476d52410ff4dfd2fb4c57466abcb/crates%2Fide%2Fsrc%2Fdisplay.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1a82af3527e476d52410ff4dfd2fb4c57466abcb/crates%2Fide%2Fsrc%2Fdisplay.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fdisplay.rs?ref=1a82af3527e476d52410ff4dfd2fb4c57466abcb", "patch": "@@ -5,6 +5,5 @@ pub(crate) mod navigation_target;\n mod short_label;\n \n pub(crate) use navigation_target::{ToNav, TryToNav};\n-pub(crate) use short_label::ShortLabel;\n \n pub(crate) use syntax::display::{function_declaration, macro_label};"}, {"sha": "69c3751a1b7b0c3fcc130c6716118fd1ab9f4c9c", "filename": "crates/ide/src/display/navigation_target.rs", "status": "modified", "additions": 8, "deletions": 6, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/1a82af3527e476d52410ff4dfd2fb4c57466abcb/crates%2Fide%2Fsrc%2Fdisplay%2Fnavigation_target.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1a82af3527e476d52410ff4dfd2fb4c57466abcb/crates%2Fide%2Fsrc%2Fdisplay%2Fnavigation_target.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fdisplay%2Fnavigation_target.rs?ref=1a82af3527e476d52410ff4dfd2fb4c57466abcb", "patch": "@@ -3,7 +3,9 @@\n use std::fmt;\n \n use either::Either;\n-use hir::{AssocItem, Documentation, FieldSource, HasAttrs, HasSource, InFile, ModuleSource};\n+use hir::{\n+    AssocItem, Documentation, FieldSource, HasAttrs, HasSource, HirDisplay, InFile, ModuleSource,\n+};\n use ide_db::{\n     base_db::{FileId, FileRange, SourceDatabase},\n     symbol_index::FileSymbolKind,\n@@ -98,7 +100,7 @@ impl NavigationTarget {\n                 SymbolKind::Module,\n             );\n             res.docs = module.attrs(db).docs();\n-            res.description = src.value.short_label();\n+            res.description = Some(module.display(db).to_string());\n             return res;\n         }\n         module.to_nav(db)\n@@ -251,8 +253,8 @@ impl ToNavFromAst for hir::Trait {\n \n impl<D> TryToNav for D\n where\n-    D: HasSource + ToNavFromAst + Copy + HasAttrs,\n-    D::Ast: ast::NameOwner + ShortLabel,\n+    D: HasSource + ToNavFromAst + Copy + HasAttrs + HirDisplay,\n+    D::Ast: ast::NameOwner,\n {\n     fn try_to_nav(&self, db: &RootDatabase) -> Option<NavigationTarget> {\n         let src = self.source(db)?;\n@@ -262,7 +264,7 @@ where\n             D::KIND,\n         );\n         res.docs = self.docs(db);\n-        res.description = src.value.short_label();\n+        res.description = Some(self.display(db).to_string());\n         Some(res)\n     }\n }\n@@ -317,7 +319,7 @@ impl TryToNav for hir::Field {\n                 let mut res =\n                     NavigationTarget::from_named(db, src.with_value(it), SymbolKind::Field);\n                 res.docs = self.docs(db);\n-                res.description = it.short_label();\n+                res.description = Some(self.display(db).to_string());\n                 res\n             }\n             FieldSource::Pos(it) => {"}, {"sha": "a35805c5e7e7f817e212233ccccc2798aad5e2cf", "filename": "crates/ide/src/hover.rs", "status": "modified", "additions": 116, "deletions": 66, "changes": 182, "blob_url": "https://github.com/rust-lang/rust/blob/1a82af3527e476d52410ff4dfd2fb4c57466abcb/crates%2Fide%2Fsrc%2Fhover.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1a82af3527e476d52410ff4dfd2fb4c57466abcb/crates%2Fide%2Fsrc%2Fhover.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fhover.rs?ref=1a82af3527e476d52410ff4dfd2fb4c57466abcb", "patch": "@@ -1,7 +1,7 @@\n use either::Either;\n use hir::{\n-    Adt, AsAssocItem, AssocItemContainer, FieldSource, GenericParam, HasAttrs, HasSource,\n-    HirDisplay, Module, ModuleDef, ModuleSource, Semantics,\n+    Adt, AsAssocItem, AssocItemContainer, GenericParam, HasAttrs, HasSource, HirDisplay, Module,\n+    ModuleDef, Semantics,\n };\n use ide_db::{\n     base_db::SourceDatabase,\n@@ -14,7 +14,7 @@ use stdx::format_to;\n use syntax::{ast, match_ast, AstNode, SyntaxKind::*, SyntaxToken, TokenAtOffset, T};\n \n use crate::{\n-    display::{macro_label, ShortLabel, TryToNav},\n+    display::{macro_label, TryToNav},\n     doc_links::{remove_links, rewrite_links},\n     markdown_remove::remove_markdown,\n     markup::Markup,\n@@ -335,61 +335,44 @@ fn hover_for_definition(\n             let label = macro_label(&it.source(db)?.value);\n             from_def_source_labeled(db, it, Some(label), mod_path)\n         }\n-        Definition::Field(def) => {\n-            let src = def.source(db)?.value;\n-            if let FieldSource::Named(it) = src {\n-                from_def_source_labeled(db, def, it.short_label(), mod_path)\n-            } else {\n-                None\n-            }\n-        }\n+        Definition::Field(def) => from_hir_fmt(db, def, mod_path),\n         Definition::ModuleDef(it) => match it {\n-            ModuleDef::Module(it) => from_def_source_labeled(\n-                db,\n-                it,\n-                match it.definition_source(db).value {\n-                    ModuleSource::Module(it) => it.short_label(),\n-                    ModuleSource::SourceFile(it) => it.short_label(),\n-                    ModuleSource::BlockExpr(it) => it.short_label(),\n-                },\n-                mod_path,\n-            ),\n-            ModuleDef::Function(it) => from_def_source(db, it, mod_path),\n-            ModuleDef::Adt(Adt::Struct(it)) => from_def_source(db, it, mod_path),\n-            ModuleDef::Adt(Adt::Union(it)) => from_def_source(db, it, mod_path),\n-            ModuleDef::Adt(Adt::Enum(it)) => from_def_source(db, it, mod_path),\n-            ModuleDef::Variant(it) => from_def_source(db, it, mod_path),\n-            ModuleDef::Const(it) => from_def_source(db, it, mod_path),\n-            ModuleDef::Static(it) => from_def_source(db, it, mod_path),\n-            ModuleDef::Trait(it) => from_def_source(db, it, mod_path),\n-            ModuleDef::TypeAlias(it) => from_def_source(db, it, mod_path),\n+            ModuleDef::Module(it) => from_hir_fmt(db, it, mod_path),\n+            ModuleDef::Function(it) => from_hir_fmt(db, it, mod_path),\n+            ModuleDef::Adt(Adt::Struct(it)) => from_hir_fmt(db, it, mod_path),\n+            ModuleDef::Adt(Adt::Union(it)) => from_hir_fmt(db, it, mod_path),\n+            ModuleDef::Adt(Adt::Enum(it)) => from_hir_fmt(db, it, mod_path),\n+            ModuleDef::Variant(it) => from_hir_fmt(db, it, mod_path),\n+            ModuleDef::Const(it) => from_hir_fmt(db, it, mod_path),\n+            ModuleDef::Static(it) => from_hir_fmt(db, it, mod_path),\n+            ModuleDef::Trait(it) => from_hir_fmt(db, it, mod_path),\n+            ModuleDef::TypeAlias(it) => from_hir_fmt(db, it, mod_path),\n             ModuleDef::BuiltinType(it) => famous_defs\n                 .and_then(|fd| hover_for_builtin(fd, it))\n                 .or_else(|| Some(Markup::fenced_block(&it.name()))),\n         },\n         Definition::Local(it) => hover_for_local(it, db),\n         Definition::SelfType(impl_def) => {\n             impl_def.target_ty(db).as_adt().and_then(|adt| match adt {\n-                Adt::Struct(it) => from_def_source(db, it, mod_path),\n-                Adt::Union(it) => from_def_source(db, it, mod_path),\n-                Adt::Enum(it) => from_def_source(db, it, mod_path),\n+                Adt::Struct(it) => from_hir_fmt(db, it, mod_path),\n+                Adt::Union(it) => from_hir_fmt(db, it, mod_path),\n+                Adt::Enum(it) => from_hir_fmt(db, it, mod_path),\n             })\n         }\n         Definition::Label(it) => Some(Markup::fenced_block(&it.name(db))),\n         Definition::GenericParam(it) => match it {\n             GenericParam::TypeParam(it) => Some(Markup::fenced_block(&it.display(db))),\n             GenericParam::LifetimeParam(it) => Some(Markup::fenced_block(&it.name(db))),\n-            GenericParam::ConstParam(it) => from_def_source(db, it, None),\n+            GenericParam::ConstParam(it) => Some(Markup::fenced_block(&it.display(db))),\n         },\n     };\n \n-    fn from_def_source<A, D>(db: &RootDatabase, def: D, mod_path: Option<String>) -> Option<Markup>\n+    fn from_hir_fmt<D>(db: &RootDatabase, def: D, mod_path: Option<String>) -> Option<Markup>\n     where\n-        D: HasSource<Ast = A> + HasAttrs + Copy,\n-        A: ShortLabel,\n+        D: HasAttrs + HirDisplay,\n     {\n-        let short_label = def.source(db)?.value.short_label();\n-        from_def_source_labeled(db, def, short_label, mod_path)\n+        let label = def.display(db).to_string();\n+        from_def_source_labeled(db, def, Some(label), mod_path)\n     }\n \n     fn from_def_source_labeled<D>(\n@@ -670,7 +653,9 @@ fn main() { let foo_test = fo$0o(); }\n                 ```\n \n                 ```rust\n-                pub fn foo<'a, T: AsRef<str>>(b: &'a T) -> &'a str\n+                pub fn foo<'a, T>(b: &'a T) -> &'a str\n+                where\n+                    T: AsRef<str>,\n                 ```\n             \"#]],\n         );\n@@ -878,7 +863,7 @@ fn main() { So$0me(12); }\n                 ```\n \n                 ```rust\n-                Some\n+                Some(T)\n                 ```\n             \"#]],\n         );\n@@ -944,7 +929,7 @@ fn main() {\n                 ```\n \n                 ```rust\n-                Some\n+                Some(T)\n                 ```\n \n                 ---\n@@ -1441,13 +1426,14 @@ fn bar() { fo$0o(); }\n                 ```\n             \"#]],\n         );\n+        // Top level `pub(crate)` will be displayed as no visibility.\n         check(\n-            r#\"pub(crate) async unsafe extern \"C\" fn foo$0() {}\"#,\n+            r#\"mod m { pub(crate) async unsafe extern \"C\" fn foo$0() {} }\"#,\n             expect![[r#\"\n                 *foo*\n \n                 ```rust\n-                test\n+                test::m\n                 ```\n \n                 ```rust\n@@ -1489,11 +1475,18 @@ extern crate st$0d;\n //! abc123\n             \"#,\n             expect![[r#\"\n-            *std*\n-            Standard library for this test\n+                *std*\n+\n+                ```rust\n+                extern crate std\n+                ```\n \n-            Printed?\n-            abc123\n+                ---\n+\n+                Standard library for this test\n+\n+                Printed?\n+                abc123\n             \"#]],\n         );\n         check(\n@@ -1507,11 +1500,18 @@ extern crate std as ab$0c;\n //! abc123\n             \"#,\n             expect![[r#\"\n-            *abc*\n-            Standard library for this test\n+                *abc*\n+\n+                ```rust\n+                extern crate std\n+                ```\n+\n+                ---\n \n-            Printed?\n-            abc123\n+                Standard library for this test\n+\n+                Printed?\n+                abc123\n             \"#]],\n         );\n     }\n@@ -2021,7 +2021,7 @@ enum E {\n                 ```\n \n                 ```rust\n-                V\n+                V { field: i32 }\n                 ```\n \n                 ---\n@@ -2417,7 +2417,7 @@ fn main() { let s$0t = S{ f1:Arg(0) }; }\n                                     focus_range: 24..25,\n                                     name: \"S\",\n                                     kind: Struct,\n-                                    description: \"struct S\",\n+                                    description: \"struct S<T>\",\n                                 },\n                             },\n                             HoverGotoTypeData {\n@@ -2463,7 +2463,7 @@ fn main() { let s$0t = S{ f1: S{ f1: Arg(0) } }; }\n                                     focus_range: 24..25,\n                                     name: \"S\",\n                                     kind: Struct,\n-                                    description: \"struct S\",\n+                                    description: \"struct S<T>\",\n                                 },\n                             },\n                             HoverGotoTypeData {\n@@ -2605,7 +2605,7 @@ fn main() { let s$0t = foo(); }\n                                     focus_range: 6..9,\n                                     name: \"Foo\",\n                                     kind: Trait,\n-                                    description: \"trait Foo\",\n+                                    description: \"trait Foo<T>\",\n                                 },\n                             },\n                             HoverGotoTypeData {\n@@ -2702,7 +2702,7 @@ fn main() { let s$0t = foo(); }\n                                     focus_range: 6..9,\n                                     name: \"Foo\",\n                                     kind: Trait,\n-                                    description: \"trait Foo\",\n+                                    description: \"trait Foo<T>\",\n                                 },\n                             },\n                             HoverGotoTypeData {\n@@ -2715,7 +2715,7 @@ fn main() { let s$0t = foo(); }\n                                     focus_range: 22..25,\n                                     name: \"Bar\",\n                                     kind: Trait,\n-                                    description: \"trait Bar\",\n+                                    description: \"trait Bar<T>\",\n                                 },\n                             },\n                             HoverGotoTypeData {\n@@ -2819,7 +2819,7 @@ fn foo(ar$0g: &impl Foo + Bar<S>) {}\n                                     focus_range: 19..22,\n                                     name: \"Bar\",\n                                     kind: Trait,\n-                                    description: \"trait Bar\",\n+                                    description: \"trait Bar<T>\",\n                                 },\n                             },\n                             HoverGotoTypeData {\n@@ -2916,7 +2916,7 @@ fn foo(ar$0g: &impl Foo<S>) {}\n                                     focus_range: 6..9,\n                                     name: \"Foo\",\n                                     kind: Trait,\n-                                    description: \"trait Foo\",\n+                                    description: \"trait Foo<T>\",\n                                 },\n                             },\n                             HoverGotoTypeData {\n@@ -2966,7 +2966,7 @@ fn main() { let s$0t = foo(); }\n                                     focus_range: 49..50,\n                                     name: \"B\",\n                                     kind: Struct,\n-                                    description: \"struct B\",\n+                                    description: \"struct B<T>\",\n                                 },\n                             },\n                             HoverGotoTypeData {\n@@ -3042,7 +3042,7 @@ fn foo(ar$0g: &dyn Foo<S>) {}\n                                     focus_range: 6..9,\n                                     name: \"Foo\",\n                                     kind: Trait,\n-                                    description: \"trait Foo\",\n+                                    description: \"trait Foo<T>\",\n                                 },\n                             },\n                             HoverGotoTypeData {\n@@ -3090,7 +3090,7 @@ fn foo(a$0rg: &impl ImplTrait<B<dyn DynTrait<B<S>>>>) {}\n                                     focus_range: 6..15,\n                                     name: \"ImplTrait\",\n                                     kind: Trait,\n-                                    description: \"trait ImplTrait\",\n+                                    description: \"trait ImplTrait<T>\",\n                                 },\n                             },\n                             HoverGotoTypeData {\n@@ -3103,7 +3103,7 @@ fn foo(a$0rg: &impl ImplTrait<B<dyn DynTrait<B<S>>>>) {}\n                                     focus_range: 50..51,\n                                     name: \"B\",\n                                     kind: Struct,\n-                                    description: \"struct B\",\n+                                    description: \"struct B<T>\",\n                                 },\n                             },\n                             HoverGotoTypeData {\n@@ -3116,7 +3116,7 @@ fn foo(a$0rg: &impl ImplTrait<B<dyn DynTrait<B<S>>>>) {}\n                                     focus_range: 28..36,\n                                     name: \"DynTrait\",\n                                     kind: Trait,\n-                                    description: \"trait DynTrait\",\n+                                    description: \"trait DynTrait<T>\",\n                                 },\n                             },\n                             HoverGotoTypeData {\n@@ -3582,6 +3582,17 @@ mod foo$0;\n \"#,\n             expect![[r#\"\n                 *foo*\n+\n+                ```rust\n+                test\n+                ```\n+\n+                ```rust\n+                mod foo\n+                ```\n+\n+                ---\n+\n                 For the horde!\n             \"#]],\n         );\n@@ -3606,7 +3617,7 @@ use foo::bar::{self$0};\n                 ```\n \n                 ```rust\n-                pub mod bar\n+                mod bar\n                 ```\n \n                 ---\n@@ -3657,4 +3668,43 @@ cosnt _: &str$0 = \"\"; }\"#;\n             \"#]],\n         );\n     }\n+\n+    #[test]\n+    fn hover_macro_expanded_function() {\n+        check(\n+            r#\"\n+struct S<'a, T>(&'a T);\n+trait Clone {}\n+macro_rules! foo {\n+    () => {\n+        fn bar<'t, T: Clone + 't>(s: &mut S<'t, T>, t: u32) -> *mut u32 where\n+            't: 't + 't,\n+            for<'a> T: Clone + 'a\n+        { 0 as _ }\n+    };\n+}\n+\n+foo!();\n+\n+fn main() {\n+    bar$0;\n+}\n+\"#,\n+            expect![[r#\"\n+                *bar*\n+\n+                ```rust\n+                test\n+                ```\n+\n+                ```rust\n+                fn bar<'t, T>(s: &mut S<'t, T>, t: u32) -> *mut u32\n+                where\n+                    T: Clone + 't,\n+                    't: 't + 't,\n+                    for<'a> T: Clone + 'a,\n+                ```\n+            \"#]],\n+        )\n+    }\n }"}, {"sha": "cec2d0c3a37e794fe441c20ef3a3b30ba51100b2", "filename": "crates/ide_completion/src/completions/dot.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/1a82af3527e476d52410ff4dfd2fb4c57466abcb/crates%2Fide_completion%2Fsrc%2Fcompletions%2Fdot.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1a82af3527e476d52410ff4dfd2fb4c57466abcb/crates%2Fide_completion%2Fsrc%2Fcompletions%2Fdot.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_completion%2Fsrc%2Fcompletions%2Fdot.rs?ref=1a82af3527e476d52410ff4dfd2fb4c57466abcb", "patch": "@@ -81,7 +81,7 @@ fn foo(s: S) { s.$0 }\n \"#,\n             expect![[r#\"\n                 fd foo   u32\n-                me bar() -> ()\n+                me bar() fn(&self)\n             \"#]],\n         );\n     }\n@@ -97,7 +97,7 @@ impl S {\n \"#,\n             expect![[r#\"\n                 fd the_field (u32,)\n-                me foo()     -> ()\n+                me foo()     fn(self)\n             \"#]],\n         )\n     }\n@@ -113,7 +113,7 @@ impl A {\n \"#,\n             expect![[r#\"\n                 fd the_field (u32, i32)\n-                me foo()     -> ()\n+                me foo()     fn(&self)\n             \"#]],\n         )\n     }\n@@ -163,7 +163,7 @@ mod m {\n fn foo(a: A) { a.$0 }\n \"#,\n             expect![[r#\"\n-                me the_method() -> ()\n+                me the_method() fn(&self)\n             \"#]],\n         );\n     }\n@@ -196,7 +196,7 @@ impl A<i32> {\n fn foo(a: A<u32>) { a.$0 }\n \"#,\n             expect![[r#\"\n-                me the_method() -> ()\n+                me the_method() fn(&self)\n             \"#]],\n         )\n     }\n@@ -211,7 +211,7 @@ impl Trait for A {}\n fn foo(a: A) { a.$0 }\n \"#,\n             expect![[r#\"\n-                me the_method() -> ()\n+                me the_method() fn(&self)\n             \"#]],\n         );\n     }\n@@ -226,7 +226,7 @@ impl<T> Trait for T {}\n fn foo(a: &A) { a.$0 }\n \",\n             expect![[r#\"\n-                me the_method() -> ()\n+                me the_method() fn(&self)\n             \"#]],\n         );\n     }\n@@ -244,7 +244,7 @@ impl Trait for A {}\n fn foo(a: A) { a.$0 }\n \",\n             expect![[r#\"\n-                me the_method() -> ()\n+                me the_method() fn(&self)\n             \"#]],\n         );\n     }\n@@ -298,7 +298,7 @@ impl T {\n }\n \"#,\n             expect![[r#\"\n-                me blah() -> ()\n+                me blah() fn(&self)\n             \"#]],\n         );\n     }\n@@ -407,7 +407,7 @@ fn foo() {\n }\n \"#,\n             expect![[r#\"\n-                me the_method() -> ()\n+                me the_method() fn(&self)\n             \"#]],\n         );\n     }\n@@ -422,7 +422,7 @@ macro_rules! make_s { () => { S }; }\n fn main() { make_s!().f$0; }\n \"#,\n             expect![[r#\"\n-                me foo() -> ()\n+                me foo() fn(&self)\n             \"#]],\n         )\n     }\n@@ -450,7 +450,7 @@ mod foo {\n }\n         \"#,\n             expect![[r#\"\n-                me private() -> ()\n+                me private() fn(&self)\n             \"#]],\n         );\n     }"}, {"sha": "08df2df3f680b0907cf89a3cbec39a5da5dc94e6", "filename": "crates/ide_completion/src/completions/flyimport.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/1a82af3527e476d52410ff4dfd2fb4c57466abcb/crates%2Fide_completion%2Fsrc%2Fcompletions%2Fflyimport.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1a82af3527e476d52410ff4dfd2fb4c57466abcb/crates%2Fide_completion%2Fsrc%2Fcompletions%2Fflyimport.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_completion%2Fsrc%2Fcompletions%2Fflyimport.rs?ref=1a82af3527e476d52410ff4dfd2fb4c57466abcb", "patch": "@@ -402,7 +402,7 @@ fn main() {\n         check(\n             fixture,\n             expect![[r#\"\n-                fn weird_function() (dep::test_mod::TestTrait) -> ()\n+                fn weird_function() (dep::test_mod::TestTrait) fn()\n             \"#]],\n         );\n \n@@ -495,7 +495,7 @@ fn main() {\n         check(\n             fixture,\n             expect![[r#\"\n-                me random_method() (dep::test_mod::TestTrait) -> ()\n+                me random_method() (dep::test_mod::TestTrait) fn(&self)\n             \"#]],\n         );\n \n@@ -665,7 +665,7 @@ fn main() {\n }\n         \"#,\n             expect![[r#\"\n-                me random_method() (dep::test_mod::TestTrait) -> () DEPRECATED\n+                me random_method() (dep::test_mod::TestTrait) fn(&self) DEPRECATED\n             \"#]],\n         );\n \n@@ -696,7 +696,7 @@ fn main() {\n \"#,\n             expect![[r#\"\n                 ct SPECIAL_CONST (dep::test_mod::TestTrait) DEPRECATED\n-                fn weird_function() (dep::test_mod::TestTrait) -> () DEPRECATED\n+                fn weird_function() (dep::test_mod::TestTrait) fn() DEPRECATED\n             \"#]],\n         );\n     }"}, {"sha": "105ff60131dd9dd58b12757f4777ee4a66b8677c", "filename": "crates/ide_completion/src/completions/qualified_path.rs", "status": "modified", "additions": 28, "deletions": 28, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/1a82af3527e476d52410ff4dfd2fb4c57466abcb/crates%2Fide_completion%2Fsrc%2Fcompletions%2Fqualified_path.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1a82af3527e476d52410ff4dfd2fb4c57466abcb/crates%2Fide_completion%2Fsrc%2Fcompletions%2Fqualified_path.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_completion%2Fsrc%2Fcompletions%2Fqualified_path.rs?ref=1a82af3527e476d52410ff4dfd2fb4c57466abcb", "patch": "@@ -359,8 +359,8 @@ impl S {\n fn foo() { let _ = S::$0 }\n \"#,\n             expect![[r#\"\n-                fn a()  -> ()\n-                me b(\u2026) -> ()\n+                fn a()  fn()\n+                me b(\u2026) fn(&self)\n                 ct C    const C: i32 = 42;\n                 ta T    type T = i32;\n             \"#]],\n@@ -387,7 +387,7 @@ mod m {\n fn foo() { let _ = S::$0 }\n \"#,\n             expect![[r#\"\n-                fn public_method() -> ()\n+                fn public_method() fn()\n                 ct PUBLIC_CONST    pub(crate) const PUBLIC_CONST: u32 = 1;\n                 ta PublicType      pub(crate) type PublicType = u32;\n             \"#]],\n@@ -404,7 +404,7 @@ impl E { fn m() { } }\n fn foo() { let _ = E::$0 }\n         \"#,\n             expect![[r#\"\n-                fn m() -> ()\n+                fn m() fn()\n             \"#]],\n         );\n     }\n@@ -419,7 +419,7 @@ impl U { fn m() { } }\n fn foo() { let _ = U::$0 }\n \"#,\n             expect![[r#\"\n-                fn m() -> ()\n+                fn m() fn()\n             \"#]],\n         );\n     }\n@@ -449,7 +449,7 @@ trait Trait { fn m(); }\n fn foo() { let _ = Trait::$0 }\n \"#,\n             expect![[r#\"\n-                fn m() -> ()\n+                fn m() fn()\n             \"#]],\n         );\n     }\n@@ -466,7 +466,7 @@ impl Trait for S {}\n fn foo() { let _ = S::$0 }\n \"#,\n             expect![[r#\"\n-                fn m() -> ()\n+                fn m() fn()\n             \"#]],\n         );\n     }\n@@ -483,7 +483,7 @@ impl Trait for S {}\n fn foo() { let _ = <S as Trait>::$0 }\n \"#,\n             expect![[r#\"\n-                fn m() -> ()\n+                fn m() fn()\n             \"#]],\n         );\n     }\n@@ -512,11 +512,11 @@ fn foo<T: Sub>() { T::$0 }\n                 ta SubTy        type SubTy;\n                 ta Ty           type Ty;\n                 ct C2           const C2: ();\n-                fn subfunc()    -> ()\n-                me submethod(\u2026) -> ()\n+                fn subfunc()    fn()\n+                me submethod(\u2026) fn(&self)\n                 ct CONST        const CONST: u8;\n-                fn func()       -> ()\n-                me method(\u2026)    -> ()\n+                fn func()       fn()\n+                me method(\u2026)    fn(&self)\n             \"#]],\n         );\n     }\n@@ -552,11 +552,11 @@ impl<T> Sub for Wrap<T> {\n                 ta SubTy        type SubTy;\n                 ta Ty           type Ty;\n                 ct CONST        const CONST: u8 = 0;\n-                fn func()       -> ()\n-                me method(\u2026)    -> ()\n+                fn func()       fn()\n+                me method(\u2026)    fn(&self)\n                 ct C2           const C2: () = ();\n-                fn subfunc()    -> ()\n-                me submethod(\u2026) -> ()\n+                fn subfunc()    fn()\n+                me submethod(\u2026) fn(&self)\n             \"#]],\n         );\n     }\n@@ -573,8 +573,8 @@ impl T { fn bar() {} }\n fn main() { T::$0; }\n \"#,\n             expect![[r#\"\n-                fn foo() -> ()\n-                fn bar() -> ()\n+                fn foo() fn()\n+                fn bar() fn()\n             \"#]],\n         );\n     }\n@@ -589,7 +589,7 @@ macro_rules! foo { () => {} }\n fn main() { let _ = crate::$0 }\n         \"#,\n             expect![[r##\"\n-                fn main()  -> ()\n+                fn main()  fn()\n                 ma foo!(\u2026) #[macro_export] macro_rules! foo\n             \"##]],\n         );\n@@ -633,7 +633,7 @@ mod p {\n \"#,\n             expect![[r#\"\n                 ct RIGHT_CONST\n-                fn right_fn()  -> ()\n+                fn right_fn()  fn()\n                 st RightType\n             \"#]],\n         );\n@@ -680,8 +680,8 @@ fn main() { m!(self::f$0); }\n fn foo() {}\n \"#,\n             expect![[r#\"\n-                fn main() -> ()\n-                fn foo()  -> ()\n+                fn main() fn()\n+                fn foo()  fn()\n             \"#]],\n         );\n     }\n@@ -699,7 +699,7 @@ mod m {\n \"#,\n             expect![[r#\"\n                 md z\n-                fn z() -> ()\n+                fn z() fn()\n             \"#]],\n         );\n     }\n@@ -719,7 +719,7 @@ fn foo() {\n }\n \"#,\n             expect![[r#\"\n-                fn new() -> HashMap<K, V, RandomState>\n+                fn new() fn() -> HashMap<K, V, RandomState>\n             \"#]],\n         );\n     }\n@@ -752,8 +752,8 @@ fn main() {\n }\n \"#,\n             expect![[r#\"\n-                fn main() -> ()\n-                fn foo(\u2026) -> ()\n+                fn main() fn()\n+                fn foo(\u2026) fn(i32, i32)\n             \"#]],\n         );\n     }\n@@ -776,7 +776,7 @@ impl Foo {\n             expect![[r#\"\n                 ev Bar    ()\n                 ev Baz    ()\n-                me foo(\u2026) -> ()\n+                me foo(\u2026) fn(self)\n             \"#]],\n         );\n     }\n@@ -800,7 +800,7 @@ impl u8 {\n \"#,\n             expect![[r#\"\n                 ct MAX     pub const MAX: Self = 255;\n-                me func(\u2026) -> ()\n+                me func(\u2026) fn(self)\n             \"#]],\n         );\n     }"}, {"sha": "1b8b063e7d62b996eb4bf7a3a937429209438b9a", "filename": "crates/ide_completion/src/completions/unqualified_path.rs", "status": "modified", "additions": 25, "deletions": 25, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/1a82af3527e476d52410ff4dfd2fb4c57466abcb/crates%2Fide_completion%2Fsrc%2Fcompletions%2Funqualified_path.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1a82af3527e476d52410ff4dfd2fb4c57466abcb/crates%2Fide_completion%2Fsrc%2Fcompletions%2Funqualified_path.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_completion%2Fsrc%2Fcompletions%2Funqualified_path.rs?ref=1a82af3527e476d52410ff4dfd2fb4c57466abcb", "patch": "@@ -135,7 +135,7 @@ fn quux(x: i32) {\n             expect![[r#\"\n                 lc y       i32\n                 lc x       i32\n-                fn quux(\u2026) -> ()\n+                fn quux(\u2026) fn(i32)\n             \"#]],\n         );\n     }\n@@ -157,7 +157,7 @@ fn quux() {\n             expect![[r#\"\n                 lc b      i32\n                 lc a\n-                fn quux() -> ()\n+                fn quux() fn()\n             \"#]],\n         );\n     }\n@@ -172,7 +172,7 @@ fn quux() {\n \"#,\n             expect![[r#\"\n                 lc x\n-                fn quux() -> ()\n+                fn quux() fn()\n             \"#]],\n         );\n     }\n@@ -203,14 +203,14 @@ fn main() {\n             r#\"fn quux<T>() { $0 }\"#,\n             expect![[r#\"\n                 tp T\n-                fn quux() -> ()\n+                fn quux() fn()\n             \"#]],\n         );\n         check(\n             r#\"fn quux<const C: usize>() { $0 }\"#,\n             expect![[r#\"\n                 cp C\n-                fn quux() -> ()\n+                fn quux() fn()\n             \"#]],\n         );\n     }\n@@ -221,7 +221,7 @@ fn main() {\n         check(\n             r#\"fn quux<'a>() { $0 }\"#,\n             expect![[r#\"\n-                fn quux() -> ()\n+                fn quux() fn()\n             \"#]],\n         );\n     }\n@@ -259,7 +259,7 @@ fn quux() { $0 }\n \"#,\n             expect![[r#\"\n                 st S\n-                fn quux() -> ()\n+                fn quux() fn()\n                 en E\n             \"#]],\n         );\n@@ -312,7 +312,7 @@ mod m {\n }\n \"#,\n             expect![[r#\"\n-                fn quux() -> ()\n+                fn quux() fn()\n                 st Bar\n             \"#]],\n         );\n@@ -327,7 +327,7 @@ fn x() -> $0\n \"#,\n             expect![[r#\"\n                 st Foo\n-                fn x() -> ()\n+                fn x() fn()\n             \"#]],\n         );\n     }\n@@ -348,7 +348,7 @@ fn foo() {\n             expect![[r#\"\n                 lc bar   i32\n                 lc bar   i32\n-                fn foo() -> ()\n+                fn foo() fn()\n             \"#]],\n         );\n     }\n@@ -378,7 +378,7 @@ use prelude::*;\n mod prelude { struct Option; }\n \"#,\n             expect![[r#\"\n-                fn foo()  -> ()\n+                fn foo()  fn()\n                 md std\n                 st Option\n             \"#]],\n@@ -408,7 +408,7 @@ mod macros {\n }\n \"#,\n             expect![[r##\"\n-                fn f()        -> ()\n+                fn f()        fn()\n                 ma concat!(\u2026) #[macro_export] macro_rules! concat\n                 md std\n             \"##]],\n@@ -435,7 +435,7 @@ use prelude::*;\n mod prelude { struct String; }\n \"#,\n             expect![[r#\"\n-                fn foo()  -> ()\n+                fn foo()  fn()\n                 md std\n                 md core\n                 st String\n@@ -466,7 +466,7 @@ fn main() { let v = $0 }\n             expect![[r##\"\n                 md m1\n                 ma baz!(\u2026) #[macro_export] macro_rules! baz\n-                fn main()  -> ()\n+                fn main()  fn()\n                 md m2\n                 ma bar!(\u2026) macro_rules! bar\n                 ma foo!(\u2026) macro_rules! foo\n@@ -482,7 +482,7 @@ macro_rules! foo { () => {} }\n fn foo() { $0 }\n \"#,\n             expect![[r#\"\n-                fn foo()   -> ()\n+                fn foo()   fn()\n                 ma foo!(\u2026) macro_rules! foo\n             \"#]],\n         );\n@@ -496,7 +496,7 @@ macro_rules! foo { () => {} }\n fn main() { let x: $0 }\n \"#,\n             expect![[r#\"\n-                fn main()  -> ()\n+                fn main()  fn()\n                 ma foo!(\u2026) macro_rules! foo\n             \"#]],\n         );\n@@ -510,7 +510,7 @@ macro_rules! foo { () => {} }\n fn main() { $0 }\n \"#,\n             expect![[r#\"\n-                fn main()  -> ()\n+                fn main()  fn()\n                 ma foo!(\u2026) macro_rules! foo\n             \"#]],\n         );\n@@ -526,8 +526,8 @@ fn main() {\n }\n \"#,\n             expect![[r#\"\n-                fn frobnicate() -> ()\n-                fn main()       -> ()\n+                fn frobnicate() fn()\n+                fn main()       fn()\n             \"#]],\n         );\n     }\n@@ -545,7 +545,7 @@ fn quux(x: i32) {\n             expect![[r#\"\n                 lc y       i32\n                 lc x       i32\n-                fn quux(\u2026) -> ()\n+                fn quux(\u2026) fn(i32)\n                 ma m!(\u2026)   macro_rules! m\n             \"#]],\n         );\n@@ -564,7 +564,7 @@ fn quux(x: i32) {\n             expect![[r#\"\n                 lc y       i32\n                 lc x       i32\n-                fn quux(\u2026) -> ()\n+                fn quux(\u2026) fn(i32)\n                 ma m!(\u2026)   macro_rules! m\n             \"#]],\n         );\n@@ -583,7 +583,7 @@ fn quux(x: i32) {\n             expect![[r#\"\n                 lc y       i32\n                 lc x       i32\n-                fn quux(\u2026) -> ()\n+                fn quux(\u2026) fn(i32)\n                 ma m!(\u2026)   macro_rules! m\n             \"#]],\n         );\n@@ -598,7 +598,7 @@ use spam::Quux;\n fn main() { $0 }\n \"#,\n             expect![[r#\"\n-                fn main() -> ()\n+                fn main() fn()\n                 ?? Quux\n             \"#]],\n         );\n@@ -616,7 +616,7 @@ fn main() { let foo: Foo = Q$0 }\n                 ev Foo::Baz  ()\n                 ev Foo::Quux ()\n                 en Foo\n-                fn main()    -> ()\n+                fn main()    fn()\n             \"#]],\n         )\n     }\n@@ -631,7 +631,7 @@ fn f() -> m::E { V$0 }\n             expect![[r#\"\n                 ev m::E::V ()\n                 md m\n-                fn f()     -> E\n+                fn f()     fn() -> E\n             \"#]],\n         )\n     }"}, {"sha": "5b7ad38d5f98ea1cab60926b9c7973f1dc5ee4dd", "filename": "crates/ide_completion/src/lib.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/1a82af3527e476d52410ff4dfd2fb4c57466abcb/crates%2Fide_completion%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1a82af3527e476d52410ff4dfd2fb4c57466abcb/crates%2Fide_completion%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_completion%2Fsrc%2Flib.rs?ref=1a82af3527e476d52410ff4dfd2fb4c57466abcb", "patch": "@@ -230,7 +230,7 @@ fn foo() {\n     bar.fo$0;\n }\n \"#,\n-            DetailAndDocumentation { detail: \"-> ()\", documentation: \"Do the foo\" },\n+            DetailAndDocumentation { detail: \"fn(&self)\", documentation: \"Do the foo\" },\n         );\n     }\n \n@@ -255,7 +255,7 @@ fn foo() {\n     bar.fo$0;\n }\n \"#,\n-            DetailAndDocumentation { detail: \"-> ()\", documentation: \" Do the foo\" },\n+            DetailAndDocumentation { detail: \"fn(&self)\", documentation: \" Do the foo\" },\n         );\n     }\n \n@@ -273,7 +273,7 @@ fn bar() {\n     for c in fo$0\n }\n \"#,\n-            DetailAndDocumentation { detail: \"-> &str\", documentation: \"Do the foo\" },\n+            DetailAndDocumentation { detail: \"fn() -> &str\", documentation: \"Do the foo\" },\n         );\n     }\n }"}, {"sha": "36655667c202ba8dfeb8563b84694d06757fc643", "filename": "crates/ide_completion/src/render.rs", "status": "modified", "additions": 46, "deletions": 8, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/1a82af3527e476d52410ff4dfd2fb4c57466abcb/crates%2Fide_completion%2Fsrc%2Frender.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1a82af3527e476d52410ff4dfd2fb4c57466abcb/crates%2Fide_completion%2Fsrc%2Frender.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_completion%2Fsrc%2Frender.rs?ref=1a82af3527e476d52410ff4dfd2fb4c57466abcb", "patch": "@@ -451,6 +451,44 @@ fn main() { Foo::Fo$0 }\n         );\n     }\n \n+    #[test]\n+    fn fn_detail_includes_args_and_return_type() {\n+        check(\n+            r#\"\n+fn foo<T>(a: u32, b: u32, t: T) -> (u32, T) { (a, t) }\n+\n+fn main() { fo$0 }\n+\"#,\n+            expect![[r#\"\n+                [\n+                    CompletionItem {\n+                        label: \"foo(\u2026)\",\n+                        source_range: 68..70,\n+                        delete: 68..70,\n+                        insert: \"foo(${1:a}, ${2:b}, ${3:t})$0\",\n+                        kind: SymbolKind(\n+                            Function,\n+                        ),\n+                        lookup: \"foo\",\n+                        detail: \"fn(u32, u32, T) -> (u32, T)\",\n+                        trigger_call_info: true,\n+                    },\n+                    CompletionItem {\n+                        label: \"main()\",\n+                        source_range: 68..70,\n+                        delete: 68..70,\n+                        insert: \"main()$0\",\n+                        kind: SymbolKind(\n+                            Function,\n+                        ),\n+                        lookup: \"main\",\n+                        detail: \"fn()\",\n+                    },\n+                ]\n+            \"#]],\n+        );\n+    }\n+\n     #[test]\n     fn enum_detail_just_parentheses_for_unit() {\n         check(\n@@ -538,7 +576,7 @@ fn main() { let _: m::Spam = S$0 }\n                             Function,\n                         ),\n                         lookup: \"main\",\n-                        detail: \"-> ()\",\n+                        detail: \"fn()\",\n                     },\n                 ]\n             \"#]],\n@@ -567,7 +605,7 @@ fn main() { som$0 }\n                             Function,\n                         ),\n                         lookup: \"main\",\n-                        detail: \"-> ()\",\n+                        detail: \"fn()\",\n                     },\n                     CompletionItem {\n                         label: \"something_deprecated()\",\n@@ -578,7 +616,7 @@ fn main() { som$0 }\n                             Function,\n                         ),\n                         lookup: \"something_deprecated\",\n-                        detail: \"-> ()\",\n+                        detail: \"fn()\",\n                         deprecated: true,\n                     },\n                     CompletionItem {\n@@ -590,7 +628,7 @@ fn main() { som$0 }\n                             Function,\n                         ),\n                         lookup: \"something_else_deprecated\",\n-                        detail: \"-> ()\",\n+                        detail: \"fn()\",\n                         deprecated: true,\n                     },\n                 ]\n@@ -641,7 +679,7 @@ impl S {\n                         insert: \"bar()$0\",\n                         kind: Method,\n                         lookup: \"bar\",\n-                        detail: \"-> ()\",\n+                        detail: \"fn(self)\",\n                         documentation: Documentation(\n                             \"Method docs\",\n                         ),\n@@ -741,7 +779,7 @@ fn foo(s: S) { s.$0 }\n                         insert: \"the_method()$0\",\n                         kind: Method,\n                         lookup: \"the_method\",\n-                        detail: \"-> ()\",\n+                        detail: \"fn(&self)\",\n                     },\n                 ]\n             \"#]],\n@@ -1049,7 +1087,7 @@ fn main() {\n                             Function,\n                         ),\n                         lookup: \"foo\",\n-                        detail: \"-> ()\",\n+                        detail: \"fn(&mut S)\",\n                         trigger_call_info: true,\n                     },\n                     CompletionItem {\n@@ -1061,7 +1099,7 @@ fn main() {\n                             Function,\n                         ),\n                         lookup: \"main\",\n-                        detail: \"-> ()\",\n+                        detail: \"fn()\",\n                     },\n                     CompletionItem {\n                         label: \"s\","}, {"sha": "010303182903c69107a8568e06524507a5c4ebf0", "filename": "crates/ide_completion/src/render/function.rs", "status": "modified", "additions": 37, "deletions": 2, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/1a82af3527e476d52410ff4dfd2fb4c57466abcb/crates%2Fide_completion%2Fsrc%2Frender%2Ffunction.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1a82af3527e476d52410ff4dfd2fb4c57466abcb/crates%2Fide_completion%2Fsrc%2Frender%2Ffunction.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_completion%2Fsrc%2Frender%2Ffunction.rs?ref=1a82af3527e476d52410ff4dfd2fb4c57466abcb", "patch": "@@ -2,6 +2,7 @@\n \n use hir::{HasSource, HirDisplay, Type};\n use ide_db::SymbolKind;\n+use itertools::Itertools;\n use syntax::ast::Fn;\n \n use crate::{\n@@ -73,8 +74,42 @@ impl<'a> FunctionRender<'a> {\n     }\n \n     fn detail(&self) -> String {\n-        let ty = self.func.ret_type(self.ctx.db());\n-        format!(\"-> {}\", ty.display(self.ctx.db()))\n+        let ret_ty = self.func.ret_type(self.ctx.db());\n+        let ret = if ret_ty.is_unit() {\n+            // Omit the return type if it is the unit type\n+            String::new()\n+        } else {\n+            format!(\" {}\", self.ty_display())\n+        };\n+\n+        format!(\"fn({}){}\", self.params_display(), ret)\n+    }\n+\n+    fn params_display(&self) -> String {\n+        if let Some(self_param) = self.func.self_param(self.ctx.db()) {\n+            let params = self\n+                .func\n+                .assoc_fn_params(self.ctx.db())\n+                .into_iter()\n+                .skip(1) // skip the self param because we are manually handling that\n+                .map(|p| p.ty().display(self.ctx.db()).to_string());\n+\n+            std::iter::once(self_param.display(self.ctx.db()).to_owned()).chain(params).join(\", \")\n+        } else {\n+            let params = self\n+                .func\n+                .assoc_fn_params(self.ctx.db())\n+                .into_iter()\n+                .map(|p| p.ty().display(self.ctx.db()).to_string())\n+                .join(\", \");\n+            params\n+        }\n+    }\n+\n+    fn ty_display(&self) -> String {\n+        let ret_ty = self.func.ret_type(self.ctx.db());\n+\n+        format!(\"-> {}\", ret_ty.display(self.ctx.db()))\n     }\n \n     fn add_arg(&self, arg: &str, ty: &Type) -> String {"}]}