{"sha": "b9112525ba27d46e056dcab303c27bb43073c4fc", "node_id": "MDY6Q29tbWl0NzI0NzEyOmI5MTEyNTI1YmEyN2Q0NmUwNTZkY2FiMzAzYzI3YmI0MzA3M2M0ZmM=", "commit": {"author": {"name": "Marijn Haverbeke", "email": "marijnh@gmail.com", "date": "2011-08-24T12:54:55Z"}, "committer": {"name": "Marijn Haverbeke", "email": "marijnh@gmail.com", "date": "2011-08-24T14:48:10Z"}, "message": "Move to a more lightweight builder system\n\nYou now do\n\n    bld::Ret(bcx, someval)\n\nwhere you used to say\n\n    bcx.build.Ret(someval)\n\nTwo fewer boxes are allocated for each block context, and build calls\nno longer go through a vtable.", "tree": {"sha": "e163524132fbff30d0dbc477894c1aa3e9ed1e3a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e163524132fbff30d0dbc477894c1aa3e9ed1e3a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b9112525ba27d46e056dcab303c27bb43073c4fc", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b9112525ba27d46e056dcab303c27bb43073c4fc", "html_url": "https://github.com/rust-lang/rust/commit/b9112525ba27d46e056dcab303c27bb43073c4fc", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b9112525ba27d46e056dcab303c27bb43073c4fc/comments", "author": {"login": "marijnh", "id": 144427, "node_id": "MDQ6VXNlcjE0NDQyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/144427?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marijnh", "html_url": "https://github.com/marijnh", "followers_url": "https://api.github.com/users/marijnh/followers", "following_url": "https://api.github.com/users/marijnh/following{/other_user}", "gists_url": "https://api.github.com/users/marijnh/gists{/gist_id}", "starred_url": "https://api.github.com/users/marijnh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marijnh/subscriptions", "organizations_url": "https://api.github.com/users/marijnh/orgs", "repos_url": "https://api.github.com/users/marijnh/repos", "events_url": "https://api.github.com/users/marijnh/events{/privacy}", "received_events_url": "https://api.github.com/users/marijnh/received_events", "type": "User", "site_admin": false}, "committer": {"login": "marijnh", "id": 144427, "node_id": "MDQ6VXNlcjE0NDQyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/144427?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marijnh", "html_url": "https://github.com/marijnh", "followers_url": "https://api.github.com/users/marijnh/followers", "following_url": "https://api.github.com/users/marijnh/following{/other_user}", "gists_url": "https://api.github.com/users/marijnh/gists{/gist_id}", "starred_url": "https://api.github.com/users/marijnh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marijnh/subscriptions", "organizations_url": "https://api.github.com/users/marijnh/orgs", "repos_url": "https://api.github.com/users/marijnh/repos", "events_url": "https://api.github.com/users/marijnh/events{/privacy}", "received_events_url": "https://api.github.com/users/marijnh/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9f44df65efe59745c08c8af1adaad37525189f8c", "url": "https://api.github.com/repos/rust-lang/rust/commits/9f44df65efe59745c08c8af1adaad37525189f8c", "html_url": "https://github.com/rust-lang/rust/commit/9f44df65efe59745c08c8af1adaad37525189f8c"}], "stats": {"total": 2341, "additions": 1147, "deletions": 1194}, "files": [{"sha": "9faabc6f3c7b105db51d2386657825cfad6bf6df", "filename": "src/comp/lib/llvm.rs", "status": "modified", "additions": 0, "deletions": 519, "changes": 519, "blob_url": "https://github.com/rust-lang/rust/blob/b9112525ba27d46e056dcab303c27bb43073c4fc/src%2Fcomp%2Flib%2Fllvm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b9112525ba27d46e056dcab303c27bb43073c4fc/src%2Fcomp%2Flib%2Fllvm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Flib%2Fllvm.rs?ref=b9112525ba27d46e056dcab303c27bb43073c4fc", "patch": "@@ -897,525 +897,6 @@ native \"cdecl\" mod llvm = \"rustllvm\" {\n     fn LLVMLinkModules(Dest: ModuleRef, Src: ModuleRef) -> Bool;\n }\n \n-/* Slightly more terse object-interface to LLVM's 'builder' functions. For the\n- * most part, build.Foo() wraps LLVMBuildFoo(), threading the correct\n- * BuilderRef B into place.  A BuilderRef is a cursor-like LLVM value that\n- * inserts instructions for a particular BasicBlockRef at a particular\n- * position; for our purposes, it always inserts at the end of the basic block\n- * it's attached to.\n- */\n-\n-resource BuilderRef_res(B: BuilderRef) { llvm::LLVMDisposeBuilder(B); }\n-\n-obj builder(B: BuilderRef,\n-            terminated: @mutable bool,\n-\n-            // Stored twice so that we don't have to constantly deref\n-            res: @BuilderRef_res) {\n-    /* Terminators */\n-    fn RetVoid() -> ValueRef {\n-        assert (!*terminated);;\n-        *terminated = true;\n-        ret llvm::LLVMBuildRetVoid(B);\n-    }\n-\n-    fn Ret(V: ValueRef) -> ValueRef {\n-        assert (!*terminated);;\n-        *terminated = true;\n-        ret llvm::LLVMBuildRet(B, V);\n-    }\n-\n-    fn AggregateRet(RetVals: &[ValueRef]) -> ValueRef {\n-        assert (!*terminated);;\n-        *terminated = true;\n-        ret llvm::LLVMBuildAggregateRet(B, vec::to_ptr(RetVals),\n-                                        vec::len(RetVals));\n-    }\n-\n-    fn Br(Dest: BasicBlockRef) -> ValueRef {\n-        assert (!*terminated);;\n-        *terminated = true;\n-        ret llvm::LLVMBuildBr(B, Dest);\n-    }\n-\n-    fn CondBr(If: ValueRef, Then: BasicBlockRef, Else: BasicBlockRef) ->\n-       ValueRef {\n-        assert (!*terminated);;\n-        *terminated = true;\n-        ret llvm::LLVMBuildCondBr(B, If, Then, Else);\n-    }\n-\n-    fn Switch(V: ValueRef, Else: BasicBlockRef, NumCases: uint) -> ValueRef {\n-        assert (!*terminated);;\n-        *terminated = true;\n-        ret llvm::LLVMBuildSwitch(B, V, Else, NumCases);\n-    }\n-\n-    fn IndirectBr(Addr: ValueRef, NumDests: uint) -> ValueRef {\n-        assert (!*terminated);;\n-        *terminated = true;\n-        ret llvm::LLVMBuildIndirectBr(B, Addr, NumDests);\n-    }\n-\n-    fn Invoke(Fn: ValueRef, Args: &[ValueRef], Then: BasicBlockRef,\n-              Catch: BasicBlockRef) -> ValueRef {\n-        assert (!*terminated);;\n-        *terminated = true;\n-        ret llvm::LLVMBuildInvoke(B, Fn, vec::to_ptr(Args), vec::len(Args),\n-                                  Then, Catch, str::buf(\"\"));\n-    }\n-\n-    fn Unreachable() -> ValueRef {\n-        assert (!*terminated);;\n-        *terminated = true;\n-        ret llvm::LLVMBuildUnreachable(B);\n-    }\n-\n-    /* Arithmetic */\n-    fn Add(LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n-        assert (!*terminated);\n-        ret llvm::LLVMBuildAdd(B, LHS, RHS, str::buf(\"\"));\n-    }\n-\n-    fn NSWAdd(LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n-        assert (!*terminated);\n-        ret llvm::LLVMBuildNSWAdd(B, LHS, RHS, str::buf(\"\"));\n-    }\n-\n-    fn NUWAdd(LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n-        assert (!*terminated);\n-        ret llvm::LLVMBuildNUWAdd(B, LHS, RHS, str::buf(\"\"));\n-    }\n-\n-    fn FAdd(LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n-        assert (!*terminated);\n-        ret llvm::LLVMBuildFAdd(B, LHS, RHS, str::buf(\"\"));\n-    }\n-\n-    fn Sub(LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n-        assert (!*terminated);\n-        ret llvm::LLVMBuildSub(B, LHS, RHS, str::buf(\"\"));\n-    }\n-\n-    fn NSWSub(LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n-        assert (!*terminated);\n-        ret llvm::LLVMBuildNSWSub(B, LHS, RHS, str::buf(\"\"));\n-    }\n-\n-    fn NUWSub(LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n-        assert (!*terminated);\n-        ret llvm::LLVMBuildNUWSub(B, LHS, RHS, str::buf(\"\"));\n-    }\n-\n-    fn FSub(LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n-        assert (!*terminated);\n-        ret llvm::LLVMBuildFSub(B, LHS, RHS, str::buf(\"\"));\n-    }\n-\n-    fn Mul(LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n-        assert (!*terminated);\n-        ret llvm::LLVMBuildMul(B, LHS, RHS, str::buf(\"\"));\n-    }\n-\n-    fn NSWMul(LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n-        assert (!*terminated);\n-        ret llvm::LLVMBuildNSWMul(B, LHS, RHS, str::buf(\"\"));\n-    }\n-\n-    fn NUWMul(LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n-        assert (!*terminated);\n-        ret llvm::LLVMBuildNUWMul(B, LHS, RHS, str::buf(\"\"));\n-    }\n-\n-    fn FMul(LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n-        assert (!*terminated);\n-        ret llvm::LLVMBuildFMul(B, LHS, RHS, str::buf(\"\"));\n-    }\n-\n-    fn UDiv(LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n-        assert (!*terminated);\n-        ret llvm::LLVMBuildUDiv(B, LHS, RHS, str::buf(\"\"));\n-    }\n-\n-    fn SDiv(LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n-        assert (!*terminated);\n-        ret llvm::LLVMBuildSDiv(B, LHS, RHS, str::buf(\"\"));\n-    }\n-\n-    fn ExactSDiv(LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n-        assert (!*terminated);\n-        ret llvm::LLVMBuildExactSDiv(B, LHS, RHS, str::buf(\"\"));\n-    }\n-\n-    fn FDiv(LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n-        assert (!*terminated);\n-        ret llvm::LLVMBuildFDiv(B, LHS, RHS, str::buf(\"\"));\n-    }\n-\n-    fn URem(LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n-        assert (!*terminated);\n-        ret llvm::LLVMBuildURem(B, LHS, RHS, str::buf(\"\"));\n-    }\n-\n-    fn SRem(LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n-        assert (!*terminated);\n-        ret llvm::LLVMBuildSRem(B, LHS, RHS, str::buf(\"\"));\n-    }\n-\n-    fn FRem(LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n-        assert (!*terminated);\n-        ret llvm::LLVMBuildFRem(B, LHS, RHS, str::buf(\"\"));\n-    }\n-\n-    fn Shl(LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n-        assert (!*terminated);\n-        ret llvm::LLVMBuildShl(B, LHS, RHS, str::buf(\"\"));\n-    }\n-\n-    fn LShr(LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n-        assert (!*terminated);\n-        ret llvm::LLVMBuildLShr(B, LHS, RHS, str::buf(\"\"));\n-    }\n-\n-    fn AShr(LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n-        assert (!*terminated);\n-        ret llvm::LLVMBuildAShr(B, LHS, RHS, str::buf(\"\"));\n-    }\n-\n-    fn And(LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n-        assert (!*terminated);\n-        ret llvm::LLVMBuildAnd(B, LHS, RHS, str::buf(\"\"));\n-    }\n-\n-    fn Or(LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n-        assert (!*terminated);\n-        ret llvm::LLVMBuildOr(B, LHS, RHS, str::buf(\"\"));\n-    }\n-\n-    fn Xor(LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n-        assert (!*terminated);\n-        ret llvm::LLVMBuildXor(B, LHS, RHS, str::buf(\"\"));\n-    }\n-\n-    fn BinOp(Op: Opcode, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n-        assert (!*terminated);\n-        ret llvm::LLVMBuildBinOp(B, Op, LHS, RHS, str::buf(\"\"));\n-    }\n-\n-    fn Neg(V: ValueRef) -> ValueRef {\n-        assert (!*terminated);\n-        ret llvm::LLVMBuildNeg(B, V, str::buf(\"\"));\n-    }\n-\n-    fn NSWNeg(V: ValueRef) -> ValueRef {\n-        assert (!*terminated);\n-        ret llvm::LLVMBuildNSWNeg(B, V, str::buf(\"\"));\n-    }\n-\n-    fn NUWNeg(V: ValueRef) -> ValueRef {\n-        assert (!*terminated);\n-        ret llvm::LLVMBuildNUWNeg(B, V, str::buf(\"\"));\n-    }\n-    fn FNeg(V: ValueRef) -> ValueRef {\n-        assert (!*terminated);\n-        ret llvm::LLVMBuildFNeg(B, V, str::buf(\"\"));\n-    }\n-    fn Not(V: ValueRef) -> ValueRef {\n-        assert (!*terminated);\n-        ret llvm::LLVMBuildNot(B, V, str::buf(\"\"));\n-    }\n-\n-    /* Memory */\n-    fn Malloc(Ty: TypeRef) -> ValueRef {\n-        assert (!*terminated);\n-        ret llvm::LLVMBuildMalloc(B, Ty, str::buf(\"\"));\n-    }\n-\n-    fn ArrayMalloc(Ty: TypeRef, Val: ValueRef) -> ValueRef {\n-        assert (!*terminated);\n-        ret llvm::LLVMBuildArrayMalloc(B, Ty, Val, str::buf(\"\"));\n-    }\n-\n-    fn Alloca(Ty: TypeRef) -> ValueRef {\n-        assert (!*terminated);\n-        ret llvm::LLVMBuildAlloca(B, Ty, str::buf(\"\"));\n-    }\n-\n-    fn ArrayAlloca(Ty: TypeRef, Val: ValueRef) -> ValueRef {\n-        assert (!*terminated);\n-        ret llvm::LLVMBuildArrayAlloca(B, Ty, Val, str::buf(\"\"));\n-    }\n-\n-    fn Free(PointerVal: ValueRef) -> ValueRef {\n-        assert (!*terminated);\n-        ret llvm::LLVMBuildFree(B, PointerVal);\n-    }\n-\n-    fn Load(PointerVal: ValueRef) -> ValueRef {\n-        assert (!*terminated);\n-        ret llvm::LLVMBuildLoad(B, PointerVal, str::buf(\"\"));\n-    }\n-\n-    fn Store(Val: ValueRef, Ptr: ValueRef) -> ValueRef {\n-        assert (!*terminated);\n-        ret llvm::LLVMBuildStore(B, Val, Ptr);\n-    }\n-\n-    fn GEP(Pointer: ValueRef, Indices: &[ValueRef]) -> ValueRef {\n-        assert (!*terminated);\n-        ret llvm::LLVMBuildGEP(B, Pointer, vec::to_ptr(Indices),\n-                               vec::len(Indices), str::buf(\"\"));\n-    }\n-\n-    fn InBoundsGEP(Pointer: ValueRef, Indices: &[ValueRef]) -> ValueRef {\n-        assert (!*terminated);\n-        ret llvm::LLVMBuildInBoundsGEP(B, Pointer, vec::to_ptr(Indices),\n-                                       vec::len(Indices), str::buf(\"\"));\n-    }\n-\n-    fn StructGEP(Pointer: ValueRef, Idx: uint) -> ValueRef {\n-        assert (!*terminated);\n-        ret llvm::LLVMBuildStructGEP(B, Pointer, Idx, str::buf(\"\"));\n-    }\n-\n-    fn GlobalString(_Str: sbuf) -> ValueRef {\n-        assert (!*terminated);\n-        ret llvm::LLVMBuildGlobalString(B, _Str, str::buf(\"\"));\n-    }\n-\n-    fn GlobalStringPtr(_Str: sbuf) -> ValueRef {\n-        assert (!*terminated);\n-        ret llvm::LLVMBuildGlobalStringPtr(B, _Str, str::buf(\"\"));\n-    }\n-\n-    /* Casts */\n-    fn Trunc(Val: ValueRef, DestTy: TypeRef) -> ValueRef {\n-        assert (!*terminated);\n-        ret llvm::LLVMBuildTrunc(B, Val, DestTy, str::buf(\"\"));\n-    }\n-\n-    fn ZExt(Val: ValueRef, DestTy: TypeRef) -> ValueRef {\n-        assert (!*terminated);\n-        ret llvm::LLVMBuildZExt(B, Val, DestTy, str::buf(\"\"));\n-    }\n-\n-    fn SExt(Val: ValueRef, DestTy: TypeRef) -> ValueRef {\n-        assert (!*terminated);\n-        ret llvm::LLVMBuildSExt(B, Val, DestTy, str::buf(\"\"));\n-    }\n-\n-    fn FPToUI(Val: ValueRef, DestTy: TypeRef) -> ValueRef {\n-        assert (!*terminated);\n-        ret llvm::LLVMBuildFPToUI(B, Val, DestTy, str::buf(\"\"));\n-    }\n-\n-    fn FPToSI(Val: ValueRef, DestTy: TypeRef) -> ValueRef {\n-        assert (!*terminated);\n-        ret llvm::LLVMBuildFPToSI(B, Val, DestTy, str::buf(\"\"));\n-    }\n-\n-    fn UIToFP(Val: ValueRef, DestTy: TypeRef) -> ValueRef {\n-        assert (!*terminated);\n-        ret llvm::LLVMBuildUIToFP(B, Val, DestTy, str::buf(\"\"));\n-    }\n-\n-    fn SIToFP(Val: ValueRef, DestTy: TypeRef) -> ValueRef {\n-        assert (!*terminated);\n-        ret llvm::LLVMBuildSIToFP(B, Val, DestTy, str::buf(\"\"));\n-    }\n-\n-    fn FPTrunc(Val: ValueRef, DestTy: TypeRef) -> ValueRef {\n-        assert (!*terminated);\n-        ret llvm::LLVMBuildFPTrunc(B, Val, DestTy, str::buf(\"\"));\n-    }\n-\n-    fn FPExt(Val: ValueRef, DestTy: TypeRef) -> ValueRef {\n-        assert (!*terminated);\n-        ret llvm::LLVMBuildFPExt(B, Val, DestTy, str::buf(\"\"));\n-    }\n-\n-    fn PtrToInt(Val: ValueRef, DestTy: TypeRef) -> ValueRef {\n-        assert (!*terminated);\n-        ret llvm::LLVMBuildPtrToInt(B, Val, DestTy, str::buf(\"\"));\n-    }\n-\n-    fn IntToPtr(Val: ValueRef, DestTy: TypeRef) -> ValueRef {\n-        assert (!*terminated);\n-        ret llvm::LLVMBuildIntToPtr(B, Val, DestTy, str::buf(\"\"));\n-    }\n-\n-    fn BitCast(Val: ValueRef, DestTy: TypeRef) -> ValueRef {\n-        assert (!*terminated);\n-        ret llvm::LLVMBuildBitCast(B, Val, DestTy, str::buf(\"\"));\n-    }\n-\n-    fn ZExtOrBitCast(Val: ValueRef, DestTy: TypeRef) -> ValueRef {\n-        assert (!*terminated);\n-        ret llvm::LLVMBuildZExtOrBitCast(B, Val, DestTy, str::buf(\"\"));\n-    }\n-\n-    fn SExtOrBitCast(Val: ValueRef, DestTy: TypeRef) -> ValueRef {\n-        assert (!*terminated);\n-        ret llvm::LLVMBuildSExtOrBitCast(B, Val, DestTy, str::buf(\"\"));\n-    }\n-\n-    fn TruncOrBitCast(Val: ValueRef, DestTy: TypeRef) -> ValueRef {\n-        assert (!*terminated);\n-        ret llvm::LLVMBuildTruncOrBitCast(B, Val, DestTy, str::buf(\"\"));\n-    }\n-\n-    fn Cast(Op: Opcode, Val: ValueRef, DestTy: TypeRef, _Name: sbuf) ->\n-       ValueRef {\n-        assert (!*terminated);\n-        ret llvm::LLVMBuildCast(B, Op, Val, DestTy, str::buf(\"\"));\n-    }\n-\n-    fn PointerCast(Val: ValueRef, DestTy: TypeRef) -> ValueRef {\n-        assert (!*terminated);\n-        ret llvm::LLVMBuildPointerCast(B, Val, DestTy, str::buf(\"\"));\n-    }\n-\n-    fn IntCast(Val: ValueRef, DestTy: TypeRef) -> ValueRef {\n-        assert (!*terminated);\n-        ret llvm::LLVMBuildIntCast(B, Val, DestTy, str::buf(\"\"));\n-    }\n-\n-    fn FPCast(Val: ValueRef, DestTy: TypeRef) -> ValueRef {\n-        assert (!*terminated);\n-        ret llvm::LLVMBuildFPCast(B, Val, DestTy, str::buf(\"\"));\n-    }\n-\n-\n-    /* Comparisons */\n-    fn ICmp(Op: uint, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n-        assert (!*terminated);\n-        ret llvm::LLVMBuildICmp(B, Op, LHS, RHS, str::buf(\"\"));\n-    }\n-\n-    fn FCmp(Op: uint, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n-        assert (!*terminated);\n-        ret llvm::LLVMBuildFCmp(B, Op, LHS, RHS, str::buf(\"\"));\n-    }\n-\n-\n-    /* Miscellaneous instructions */\n-    fn Phi(Ty: TypeRef, vals: &[ValueRef], bbs: &[BasicBlockRef]) ->\n-       ValueRef {\n-        assert (!*terminated);\n-        let phi = llvm::LLVMBuildPhi(B, Ty, str::buf(\"\"));\n-        assert (vec::len::<ValueRef>(vals) == vec::len::<BasicBlockRef>(bbs));\n-        llvm::LLVMAddIncoming(phi, vec::to_ptr(vals), vec::to_ptr(bbs),\n-                              vec::len(vals));\n-        ret phi;\n-    }\n-\n-    fn AddIncomingToPhi(phi: ValueRef, vals: &[ValueRef],\n-                        bbs: &[BasicBlockRef]) {\n-        assert (vec::len::<ValueRef>(vals) == vec::len::<BasicBlockRef>(bbs));\n-        llvm::LLVMAddIncoming(phi, vec::to_ptr(vals), vec::to_ptr(bbs),\n-                              vec::len(vals));\n-    }\n-\n-    fn Call(Fn: ValueRef, Args: &[ValueRef]) -> ValueRef {\n-        assert (!*terminated);\n-        ret llvm::LLVMBuildCall(B, Fn, vec::to_ptr(Args), vec::len(Args),\n-                                str::buf(\"\"));\n-    }\n-\n-    fn FastCall(Fn: ValueRef, Args: &[ValueRef]) -> ValueRef {\n-        assert (!*terminated);\n-        let v =\n-            llvm::LLVMBuildCall(B, Fn, vec::to_ptr(Args), vec::len(Args),\n-                                str::buf(\"\"));\n-        llvm::LLVMSetInstructionCallConv(v, LLVMFastCallConv);\n-        ret v;\n-    }\n-\n-    fn CallWithConv(Fn: ValueRef, Args: &[ValueRef], Conv: uint) -> ValueRef {\n-        assert (!*terminated);\n-        let v =\n-            llvm::LLVMBuildCall(B, Fn, vec::to_ptr(Args), vec::len(Args),\n-                                str::buf(\"\"));\n-        llvm::LLVMSetInstructionCallConv(v, Conv);\n-        ret v;\n-    }\n-\n-    fn Select(If: ValueRef, Then: ValueRef, Else: ValueRef) -> ValueRef {\n-        assert (!*terminated);\n-        ret llvm::LLVMBuildSelect(B, If, Then, Else, str::buf(\"\"));\n-    }\n-\n-    fn VAArg(list: ValueRef, Ty: TypeRef) -> ValueRef {\n-        assert (!*terminated);\n-        ret llvm::LLVMBuildVAArg(B, list, Ty, str::buf(\"\"));\n-    }\n-\n-    fn ExtractElement(VecVal: ValueRef, Index: ValueRef) -> ValueRef {\n-        assert (!*terminated);\n-        ret llvm::LLVMBuildExtractElement(B, VecVal, Index, str::buf(\"\"));\n-    }\n-\n-    fn InsertElement(VecVal: ValueRef, EltVal: ValueRef, Index: ValueRef) ->\n-       ValueRef {\n-        assert (!*terminated);\n-        ret llvm::LLVMBuildInsertElement(B, VecVal, EltVal, Index,\n-                                         str::buf(\"\"));\n-    }\n-\n-    fn ShuffleVector(V1: ValueRef, V2: ValueRef, Mask: ValueRef) -> ValueRef {\n-        assert (!*terminated);\n-        ret llvm::LLVMBuildShuffleVector(B, V1, V2, Mask, str::buf(\"\"));\n-    }\n-\n-    fn ExtractValue(AggVal: ValueRef, Index: uint) -> ValueRef {\n-        assert (!*terminated);\n-        ret llvm::LLVMBuildExtractValue(B, AggVal, Index, str::buf(\"\"));\n-    }\n-\n-    fn InsertValue(AggVal: ValueRef, EltVal: ValueRef, Index: uint) ->\n-       ValueRef {\n-        assert (!*terminated);\n-        ret llvm::LLVMBuildInsertValue(B, AggVal, EltVal, Index,\n-                                       str::buf(\"\"));\n-    }\n-\n-    fn IsNull(Val: ValueRef) -> ValueRef {\n-        assert (!*terminated);\n-        ret llvm::LLVMBuildIsNull(B, Val, str::buf(\"\"));\n-    }\n-\n-    fn IsNotNull(Val: ValueRef) -> ValueRef {\n-        assert (!*terminated);\n-        ret llvm::LLVMBuildIsNotNull(B, Val, str::buf(\"\"));\n-    }\n-\n-    fn PtrDiff(LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n-        assert (!*terminated);\n-        ret llvm::LLVMBuildPtrDiff(B, LHS, RHS, str::buf(\"\"));\n-    }\n-\n-    fn Trap() -> ValueRef {\n-        assert (!*terminated);\n-        let BB: BasicBlockRef = llvm::LLVMGetInsertBlock(B);\n-        let FN: ValueRef = llvm::LLVMGetBasicBlockParent(BB);\n-        let M: ModuleRef = llvm::LLVMGetGlobalParent(FN);\n-        let T: ValueRef =\n-            llvm::LLVMGetNamedFunction(M, str::buf(\"llvm.trap\"));\n-        assert (T as int != 0);\n-        let Args: [ValueRef] = [];\n-        ret llvm::LLVMBuildCall(B, T, vec::to_ptr(Args), vec::len(Args),\n-                                str::buf(\"\"));\n-    }\n-\n-    fn is_terminated() -> bool { ret *terminated; }\n-}\n-\n-fn new_builder(llbb: BasicBlockRef) -> builder {\n-    let llbuild: BuilderRef = llvm::LLVMCreateBuilder();\n-    llvm::LLVMPositionBuilderAtEnd(llbuild, llbb);\n-    ret builder(llbuild, @mutable false, @BuilderRef_res(llbuild));\n-}\n-\n /* Memory-managed object interface to type handles. */\n \n obj type_names(type_names: std::map::hashmap<TypeRef, str>,"}, {"sha": "1fdb17c18876e5891b41ab6fab53f1fd7f21979e", "filename": "src/comp/middle/gc.rs", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/b9112525ba27d46e056dcab303c27bb43073c4fc/src%2Fcomp%2Fmiddle%2Fgc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b9112525ba27d46e056dcab303c27bb43073c4fc/src%2Fcomp%2Fmiddle%2Fgc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fgc.rs?ref=b9112525ba27d46e056dcab303c27bb43073c4fc", "patch": "@@ -15,6 +15,7 @@ import std::unsafe;\n import std::vec;\n \n import lll = lib::llvm::llvm;\n+import bld = trans_build;\n \n type ctxt = @{mutable next_tydesc_num: uint};\n \n@@ -47,13 +48,13 @@ fn add_gc_root(cx: &@block_ctxt, llval: ValueRef, ty: ty::t) -> @block_ctxt {\n     let lltydesc = td_r.result.val;\n \n     let gcroot = bcx_ccx(bcx).intrinsics.get(\"llvm.gcroot\");\n-    let llvalptr = bcx.build.PointerCast(llval, T_ptr(T_ptr(T_i8())));\n+    let llvalptr = bld::PointerCast(bcx, llval, T_ptr(T_ptr(T_i8())));\n \n     alt td_r.kind {\n       tk_derived. {\n         // It's a derived type descriptor. First, spill it.\n         let lltydescptr = trans::alloca(bcx, val_ty(lltydesc));\n-        bcx.build.Store(lltydesc, lltydescptr);\n+        bld::Store(bcx, lltydesc, lltydescptr);\n \n         let number = gc_cx.next_tydesc_num;\n         gc_cx.next_tydesc_num += 1u;\n@@ -69,10 +70,10 @@ fn add_gc_root(cx: &@block_ctxt, llval: ValueRef, ty: ty::t) -> @block_ctxt {\n         llsrcindex = lll::LLVMConstPointerCast(llsrcindex, T_ptr(T_i8()));\n \n         lltydescptr =\n-            bcx.build.PointerCast(lltydescptr, T_ptr(T_ptr(T_i8())));\n+            bld::PointerCast(bcx, lltydescptr, T_ptr(T_ptr(T_i8())));\n \n-        bcx.build.Call(gcroot, [lltydescptr, lldestindex]);\n-        bcx.build.Call(gcroot, [llvalptr, llsrcindex]);\n+        bld::Call(bcx, gcroot, [lltydescptr, lldestindex]);\n+        bld::Call(bcx, gcroot, [llvalptr, llsrcindex]);\n       }\n       tk_param. {\n         bcx_tcx(cx).sess.bug(\"we should never be trying to root values \" +\n@@ -87,7 +88,7 @@ fn add_gc_root(cx: &@block_ctxt, llval: ValueRef, ty: ty::t) -> @block_ctxt {\n         let llstaticgcmetaptr =\n             lll::LLVMConstPointerCast(llstaticgcmeta, T_ptr(T_i8()));\n \n-        bcx.build.Call(gcroot, [llvalptr, llstaticgcmetaptr]);\n+        bld::Call(bcx, gcroot, [llvalptr, llstaticgcmetaptr]);\n       }\n     }\n "}, {"sha": "726223ff9d779a5c5c92ee737aa52d93c09f8e4d", "filename": "src/comp/middle/trans.rs", "status": "modified", "additions": 444, "deletions": 438, "changes": 882, "blob_url": "https://github.com/rust-lang/rust/blob/b9112525ba27d46e056dcab303c27bb43073c4fc/src%2Fcomp%2Fmiddle%2Ftrans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b9112525ba27d46e056dcab303c27bb43073c4fc/src%2Fcomp%2Fmiddle%2Ftrans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans.rs?ref=b9112525ba27d46e056dcab303c27bb43073c4fc"}, {"sha": "c391c6b4baaca3d2b4e3c9a472f8808dd8d5e0f4", "filename": "src/comp/middle/trans_alt.rs", "status": "modified", "additions": 22, "deletions": 22, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/b9112525ba27d46e056dcab303c27bb43073c4fc/src%2Fcomp%2Fmiddle%2Ftrans_alt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b9112525ba27d46e056dcab303c27bb43073c4fc/src%2Fcomp%2Fmiddle%2Ftrans_alt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans_alt.rs?ref=b9112525ba27d46e056dcab303c27bb43073c4fc", "patch": "@@ -9,6 +9,7 @@ import lib::llvm::llvm;\n import lib::llvm::llvm::ValueRef;\n import lib::llvm::llvm::TypeRef;\n import lib::llvm::llvm::BasicBlockRef;\n+import bld = trans_build;\n import trans::new_sub_block_ctxt;\n import trans::new_scope_block_ctxt;\n import trans::load_if_immediate;\n@@ -210,9 +211,9 @@ fn extract_variant_args(bcx: @block_ctxt, pat_id: ast::node_id,\n         vec::len(ty::tag_variant_with_id(ccx.tcx, vdefs.tg, vdefs.var).args);\n     if size > 0u && vec::len(variants) != 1u {\n         let tagptr =\n-            bcx.build.PointerCast(val,\n+            bld::PointerCast(bcx, val,\n                                   trans_common::T_opaque_tag_ptr(ccx.tn));\n-        blobptr = bcx.build.GEP(tagptr, [C_int(0), C_int(1)]);\n+        blobptr = bld::GEP(bcx, tagptr, [C_int(0), C_int(1)]);\n     }\n     let i = 0u;\n     while i < size {\n@@ -289,15 +290,15 @@ fn pick_col(m: &match) -> uint {\n \n fn compile_submatch(bcx: @block_ctxt, m: &match, vals: [ValueRef],\n                     f: &mk_fail, exits: &mutable [exit_node]) {\n-    if vec::len(m) == 0u { bcx.build.Br(f()); ret; }\n+    if vec::len(m) == 0u { bld::Br(bcx, f()); ret; }\n     if vec::len(m[0].pats) == 0u {\n         let data = m[0].data;\n         alt data.guard {\n           some(e) {\n             let guard_cx = new_scope_block_ctxt(bcx, \"guard\");\n             let next_cx = new_sub_block_ctxt(bcx, \"next\");\n             let else_cx = new_sub_block_ctxt(bcx, \"else\");\n-            bcx.build.Br(guard_cx.llbb);\n+            bld::Br(bcx, guard_cx.llbb);\n             // Temporarily set bindings. They'll be rewritten to PHI nodes for\n             // the actual arm block.\n             for each @{key, val} in data.id_map.items() {\n@@ -307,15 +308,15 @@ fn compile_submatch(bcx: @block_ctxt, m: &match, vals: [ValueRef],\n             let {bcx: guard_bcx, val: guard_val} =\n                 trans::trans_expr(guard_cx, e);\n             guard_bcx = trans::trans_block_cleanups(guard_bcx, guard_cx);\n-            guard_bcx.build.CondBr(guard_val, next_cx.llbb, else_cx.llbb);\n+            bld::CondBr(guard_bcx, guard_val, next_cx.llbb, else_cx.llbb);\n             compile_submatch(else_cx, vec::slice(m, 1u, vec::len(m)),\n                              vals, f, exits);\n             bcx = next_cx;\n           }\n           _ {}\n         }\n         exits += [{bound: m[0].bound, from: bcx.llbb, to: data.body}];\n-        bcx.build.Br(data.body);\n+        bld::Br(bcx, data.body);\n         ret;\n     }\n \n@@ -372,9 +373,9 @@ fn compile_submatch(bcx: @block_ctxt, m: &match, vals: [ValueRef],\n \n     // Unbox in case of a box field\n     if any_box_pat(m, col) {\n-        let box = bcx.build.Load(val);\n+        let box = bld::Load(bcx, val);\n         let unboxed =\n-            bcx.build.InBoundsGEP(box,\n+            bld::InBoundsGEP(bcx, box,\n                                   [C_int(0),\n                                    C_int(back::abi::box_rc_field_body)]);\n         compile_submatch(bcx, enter_box(m, col, val), [unboxed] + vals_left,\n@@ -394,16 +395,15 @@ fn compile_submatch(bcx: @block_ctxt, m: &match, vals: [ValueRef],\n                 kind = single;\n             } else {\n                 let tagptr =\n-                    bcx.build.PointerCast(\n-                        val,\n+                    bld::PointerCast(bcx, val,\n                         trans_common::T_opaque_tag_ptr(ccx.tn));\n-                let discrimptr = bcx.build.GEP(tagptr, [C_int(0), C_int(0)]);\n-                test_val = bcx.build.Load(discrimptr);\n+                let discrimptr = bld::GEP(bcx, tagptr, [C_int(0), C_int(0)]);\n+                test_val = bld::Load(bcx, discrimptr);\n                 kind = switch;\n             }\n           }\n           lit(l) {\n-            test_val = bcx.build.Load(val);\n+            test_val = bld::Load(bcx, val);\n             kind = alt l.node { ast::lit_str(_, _) { compare } _ { switch } };\n           }\n         }\n@@ -415,14 +415,14 @@ fn compile_submatch(bcx: @block_ctxt, m: &match, vals: [ValueRef],\n         };\n     let sw =\n         if kind == switch {\n-            bcx.build.Switch(test_val, else_cx.llbb, vec::len(opts))\n+            bld::Switch(bcx, test_val, else_cx.llbb, vec::len(opts))\n         } else { C_int(0) }; // Placeholder for when not using a switch\n \n      // Compile subtrees for each option\n     for opt: opt in opts {\n         let opt_cx = new_sub_block_ctxt(bcx, \"match_case\");\n         alt kind {\n-          single. { bcx.build.Br(opt_cx.llbb); }\n+          single. { bld::Br(bcx, opt_cx.llbb); }\n           switch. {\n             let r = trans_opt(bcx, opt);\n             bcx = r.bcx;\n@@ -435,7 +435,7 @@ fn compile_submatch(bcx: @block_ctxt, m: &match, vals: [ValueRef],\n             let eq =\n                 trans::trans_compare(bcx, ast::eq, test_val, t, r.val, t);\n             bcx = new_sub_block_ctxt(bcx, \"next\");\n-            eq.bcx.build.CondBr(eq.val, opt_cx.llbb, bcx.llbb);\n+            bld::CondBr(eq.bcx, eq.val, opt_cx.llbb, bcx.llbb);\n           }\n           _ { }\n         }\n@@ -455,7 +455,7 @@ fn compile_submatch(bcx: @block_ctxt, m: &match, vals: [ValueRef],\n     }\n \n     // Compile the fall-through case\n-    if kind == compare { bcx.build.Br(else_cx.llbb); }\n+    if kind == compare { bld::Br(bcx, else_cx.llbb); }\n     if kind != single {\n         compile_submatch(else_cx, enter_default(m, col, val), vals_left, f,\n                          exits);\n@@ -479,7 +479,7 @@ fn make_phi_bindings(bcx: &@block_ctxt, map: &[exit_node],\n             }\n         }\n         if vec::len(vals) > 0u {\n-            let phi = bcx.build.Phi(val_ty(vals[0]), vals, llbbs);\n+            let phi = bld::Phi(bcx, val_ty(vals[0]), vals, llbbs);\n             bcx.fcx.lllocals.insert(item.val, phi);\n         } else { success = false; }\n     }\n@@ -495,8 +495,8 @@ fn trans_alt(cx: &@block_ctxt, expr: &@ast::expr, arms: &[ast::arm],\n \n         // No need to generate code for alt,\n         // since the disc diverges.\n-        if !cx.build.is_terminated() {\n-            ret rslt(cx, cx.build.Unreachable());\n+        if !is_terminated(cx) {\n+            ret rslt(cx, bld::Unreachable(cx));\n         } else { ret er; }\n     }\n \n@@ -594,9 +594,9 @@ fn bind_irrefutable_pat(bcx: @block_ctxt, pat: &@ast::pat, val: ValueRef,\n         }\n       }\n       ast::pat_box(inner) {\n-        let box = bcx.build.Load(val);\n+        let box = bld::Load(bcx, val);\n         let unboxed =\n-            bcx.build.InBoundsGEP(box,\n+            bld::InBoundsGEP(bcx, box,\n                                   [C_int(0),\n                                    C_int(back::abi::box_rc_field_body)]);\n         bcx = bind_irrefutable_pat(bcx, inner, unboxed, table, true);"}, {"sha": "8e732394e78922de77dcabba5bdb0f2e3dad0f6d", "filename": "src/comp/middle/trans_build.rs", "status": "added", "additions": 459, "deletions": 0, "changes": 459, "blob_url": "https://github.com/rust-lang/rust/blob/b9112525ba27d46e056dcab303c27bb43073c4fc/src%2Fcomp%2Fmiddle%2Ftrans_build.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b9112525ba27d46e056dcab303c27bb43073c4fc/src%2Fcomp%2Fmiddle%2Ftrans_build.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans_build.rs?ref=b9112525ba27d46e056dcab303c27bb43073c4fc", "patch": "@@ -0,0 +1,459 @@\n+import std::{vec, str};\n+import str::rustrt::sbuf;\n+import lib::llvm::llvm;\n+import llvm::{ValueRef, TypeRef, BasicBlockRef, BuilderRef,\n+              Opcode, ModuleRef};\n+import trans_common::block_ctxt;\n+\n+resource BuilderRef_res(B: llvm::BuilderRef) {\n+    llvm::LLVMDisposeBuilder(B);\n+}\n+\n+fn mk_builder(llbb: BasicBlockRef) -> BuilderRef {\n+    let B = llvm::LLVMCreateBuilder();\n+    llvm::LLVMPositionBuilderAtEnd(B, llbb);\n+    ret B;\n+}\n+\n+fn RetVoid(cx: &@block_ctxt) -> ValueRef {\n+    assert (!cx.terminated);;\n+    cx.terminated = true;\n+    ret llvm::LLVMBuildRetVoid(*cx.build);\n+}\n+\n+fn Ret(cx: &@block_ctxt, V: ValueRef) -> ValueRef {\n+    assert (!cx.terminated);;\n+    cx.terminated = true;\n+    ret llvm::LLVMBuildRet(*cx.build, V);\n+}\n+\n+fn AggregateRet(cx: &@block_ctxt, RetVals: &[ValueRef]) -> ValueRef {\n+    assert (!cx.terminated);;\n+    cx.terminated = true;\n+    ret llvm::LLVMBuildAggregateRet(*cx.build, vec::to_ptr(RetVals),\n+                                    vec::len(RetVals));\n+}\n+\n+fn Br(cx: &@block_ctxt, Dest: BasicBlockRef) -> ValueRef {\n+    assert (!cx.terminated);;\n+    cx.terminated = true;\n+    ret llvm::LLVMBuildBr(*cx.build, Dest);\n+}\n+\n+fn CondBr(cx: &@block_ctxt, If: ValueRef, Then: BasicBlockRef,\n+          Else: BasicBlockRef) -> ValueRef {\n+    assert (!cx.terminated);;\n+    cx.terminated = true;\n+    ret llvm::LLVMBuildCondBr(*cx.build, If, Then, Else);\n+}\n+\n+fn Switch(cx: &@block_ctxt, V: ValueRef, Else: BasicBlockRef,\n+          NumCases: uint) -> ValueRef {\n+    assert (!cx.terminated);;\n+    cx.terminated = true;\n+    ret llvm::LLVMBuildSwitch(*cx.build, V, Else, NumCases);\n+}\n+\n+fn IndirectBr(cx: &@block_ctxt, Addr: ValueRef,\n+              NumDests: uint) -> ValueRef {\n+    assert (!cx.terminated);;\n+    cx.terminated = true;\n+    ret llvm::LLVMBuildIndirectBr(*cx.build, Addr, NumDests);\n+}\n+\n+fn Invoke(cx: &@block_ctxt, Fn: ValueRef, Args: &[ValueRef],\n+          Then: BasicBlockRef, Catch: BasicBlockRef) -> ValueRef {\n+    assert (!cx.terminated);;\n+    cx.terminated = true;\n+    ret llvm::LLVMBuildInvoke(*cx.build, Fn, vec::to_ptr(Args),\n+                              vec::len(Args), Then, Catch, str::buf(\"\"));\n+}\n+\n+fn Unreachable(cx: &@block_ctxt) -> ValueRef {\n+    assert (!cx.terminated);;\n+    cx.terminated = true;\n+    ret llvm::LLVMBuildUnreachable(*cx.build);\n+}\n+\n+/* Arithmetic */\n+fn Add(cx: &@block_ctxt, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n+    ret llvm::LLVMBuildAdd(*cx.build, LHS, RHS, str::buf(\"\"));\n+}\n+\n+fn NSWAdd(cx: &@block_ctxt, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n+    ret llvm::LLVMBuildNSWAdd(*cx.build, LHS, RHS, str::buf(\"\"));\n+}\n+\n+fn NUWAdd(cx: &@block_ctxt, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n+    ret llvm::LLVMBuildNUWAdd(*cx.build, LHS, RHS, str::buf(\"\"));\n+}\n+\n+fn FAdd(cx: &@block_ctxt, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n+    ret llvm::LLVMBuildFAdd(*cx.build, LHS, RHS, str::buf(\"\"));\n+}\n+\n+fn Sub(cx: &@block_ctxt, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n+    ret llvm::LLVMBuildSub(*cx.build, LHS, RHS, str::buf(\"\"));\n+}\n+\n+fn NSWSub(cx: &@block_ctxt, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n+    ret llvm::LLVMBuildNSWSub(*cx.build, LHS, RHS, str::buf(\"\"));\n+}\n+\n+fn NUWSub(cx: &@block_ctxt, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n+    ret llvm::LLVMBuildNUWSub(*cx.build, LHS, RHS, str::buf(\"\"));\n+}\n+\n+fn FSub(cx: &@block_ctxt, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n+    ret llvm::LLVMBuildFSub(*cx.build, LHS, RHS, str::buf(\"\"));\n+}\n+\n+fn Mul(cx: &@block_ctxt, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n+    ret llvm::LLVMBuildMul(*cx.build, LHS, RHS, str::buf(\"\"));\n+}\n+\n+fn NSWMul(cx: &@block_ctxt, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n+    ret llvm::LLVMBuildNSWMul(*cx.build, LHS, RHS, str::buf(\"\"));\n+}\n+\n+fn NUWMul(cx: &@block_ctxt, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n+    ret llvm::LLVMBuildNUWMul(*cx.build, LHS, RHS, str::buf(\"\"));\n+}\n+\n+fn FMul(cx: &@block_ctxt, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n+    ret llvm::LLVMBuildFMul(*cx.build, LHS, RHS, str::buf(\"\"));\n+}\n+\n+fn UDiv(cx: &@block_ctxt, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n+    ret llvm::LLVMBuildUDiv(*cx.build, LHS, RHS, str::buf(\"\"));\n+}\n+\n+fn SDiv(cx: &@block_ctxt, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n+    ret llvm::LLVMBuildSDiv(*cx.build, LHS, RHS, str::buf(\"\"));\n+}\n+\n+fn ExactSDiv(cx: &@block_ctxt, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n+    ret llvm::LLVMBuildExactSDiv(*cx.build, LHS, RHS, str::buf(\"\"));\n+}\n+\n+fn FDiv(cx: &@block_ctxt, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n+    ret llvm::LLVMBuildFDiv(*cx.build, LHS, RHS, str::buf(\"\"));\n+}\n+\n+fn URem(cx: &@block_ctxt, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n+    ret llvm::LLVMBuildURem(*cx.build, LHS, RHS, str::buf(\"\"));\n+}\n+\n+fn SRem(cx: &@block_ctxt, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n+    ret llvm::LLVMBuildSRem(*cx.build, LHS, RHS, str::buf(\"\"));\n+}\n+\n+fn FRem(cx: &@block_ctxt, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n+    ret llvm::LLVMBuildFRem(*cx.build, LHS, RHS, str::buf(\"\"));\n+}\n+\n+fn Shl(cx: &@block_ctxt, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n+    ret llvm::LLVMBuildShl(*cx.build, LHS, RHS, str::buf(\"\"));\n+}\n+\n+fn LShr(cx: &@block_ctxt, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n+    ret llvm::LLVMBuildLShr(*cx.build, LHS, RHS, str::buf(\"\"));\n+}\n+\n+fn AShr(cx: &@block_ctxt, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n+    ret llvm::LLVMBuildAShr(*cx.build, LHS, RHS, str::buf(\"\"));\n+}\n+\n+fn And(cx: &@block_ctxt, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n+    ret llvm::LLVMBuildAnd(*cx.build, LHS, RHS, str::buf(\"\"));\n+}\n+\n+fn Or(cx: &@block_ctxt, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n+    ret llvm::LLVMBuildOr(*cx.build, LHS, RHS, str::buf(\"\"));\n+}\n+\n+fn Xor(cx: &@block_ctxt, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n+    ret llvm::LLVMBuildXor(*cx.build, LHS, RHS, str::buf(\"\"));\n+}\n+\n+fn BinOp(cx: &@block_ctxt, Op: Opcode, LHS: ValueRef,\n+         RHS: ValueRef) -> ValueRef {\n+    ret llvm::LLVMBuildBinOp(*cx.build, Op, LHS, RHS, str::buf(\"\"));\n+}\n+\n+fn Neg(cx: &@block_ctxt, V: ValueRef) -> ValueRef {\n+    ret llvm::LLVMBuildNeg(*cx.build, V, str::buf(\"\"));\n+}\n+\n+fn NSWNeg(cx: &@block_ctxt, V: ValueRef) -> ValueRef {\n+    ret llvm::LLVMBuildNSWNeg(*cx.build, V, str::buf(\"\"));\n+}\n+\n+fn NUWNeg(cx: &@block_ctxt, V: ValueRef) -> ValueRef {\n+    ret llvm::LLVMBuildNUWNeg(*cx.build, V, str::buf(\"\"));\n+}\n+fn FNeg(cx: &@block_ctxt, V: ValueRef) -> ValueRef {\n+    ret llvm::LLVMBuildFNeg(*cx.build, V, str::buf(\"\"));\n+}\n+fn Not(cx: &@block_ctxt, V: ValueRef) -> ValueRef {\n+    ret llvm::LLVMBuildNot(*cx.build, V, str::buf(\"\"));\n+}\n+\n+/* Memory */\n+fn Malloc(cx: &@block_ctxt, Ty: TypeRef) -> ValueRef {\n+    ret llvm::LLVMBuildMalloc(*cx.build, Ty, str::buf(\"\"));\n+}\n+\n+fn ArrayMalloc(cx: &@block_ctxt, Ty: TypeRef, Val: ValueRef) -> ValueRef {\n+    ret llvm::LLVMBuildArrayMalloc(*cx.build, Ty, Val, str::buf(\"\"));\n+}\n+\n+fn Alloca(cx: &@block_ctxt, Ty: TypeRef) -> ValueRef {\n+    ret llvm::LLVMBuildAlloca(*cx.build, Ty, str::buf(\"\"));\n+}\n+\n+fn ArrayAlloca(cx: &@block_ctxt, Ty: TypeRef, Val: ValueRef) -> ValueRef {\n+    ret llvm::LLVMBuildArrayAlloca(*cx.build, Ty, Val, str::buf(\"\"));\n+}\n+\n+fn Free(cx: &@block_ctxt, PointerVal: ValueRef) -> ValueRef {\n+    ret llvm::LLVMBuildFree(*cx.build, PointerVal);\n+}\n+\n+fn Load(cx: &@block_ctxt, PointerVal: ValueRef) -> ValueRef {\n+    ret llvm::LLVMBuildLoad(*cx.build, PointerVal, str::buf(\"\"));\n+}\n+\n+fn Store(cx: &@block_ctxt, Val: ValueRef, Ptr: ValueRef) -> ValueRef {\n+    ret llvm::LLVMBuildStore(*cx.build, Val, Ptr);\n+}\n+\n+fn GEP(cx: &@block_ctxt, Pointer: ValueRef,\n+       Indices: &[ValueRef]) -> ValueRef {\n+    ret llvm::LLVMBuildGEP(*cx.build, Pointer, vec::to_ptr(Indices),\n+                           vec::len(Indices), str::buf(\"\"));\n+}\n+\n+fn InBoundsGEP(cx: &@block_ctxt, Pointer: ValueRef,\n+               Indices: &[ValueRef]) -> ValueRef {\n+    ret llvm::LLVMBuildInBoundsGEP(*cx.build, Pointer, vec::to_ptr(Indices),\n+                                   vec::len(Indices), str::buf(\"\"));\n+}\n+\n+fn StructGEP(cx: &@block_ctxt, Pointer: ValueRef, Idx: uint) -> ValueRef {\n+    ret llvm::LLVMBuildStructGEP(*cx.build, Pointer, Idx, str::buf(\"\"));\n+}\n+\n+fn GlobalString(cx: &@block_ctxt, _Str: sbuf) -> ValueRef {\n+    ret llvm::LLVMBuildGlobalString(*cx.build, _Str, str::buf(\"\"));\n+}\n+\n+fn GlobalStringPtr(cx: &@block_ctxt, _Str: sbuf) -> ValueRef {\n+    ret llvm::LLVMBuildGlobalStringPtr(*cx.build, _Str, str::buf(\"\"));\n+}\n+\n+/* Casts */\n+fn Trunc(cx: &@block_ctxt, Val: ValueRef, DestTy: TypeRef) -> ValueRef {\n+    ret llvm::LLVMBuildTrunc(*cx.build, Val, DestTy, str::buf(\"\"));\n+}\n+\n+fn ZExt(cx: &@block_ctxt, Val: ValueRef, DestTy: TypeRef) -> ValueRef {\n+    ret llvm::LLVMBuildZExt(*cx.build, Val, DestTy, str::buf(\"\"));\n+}\n+\n+fn SExt(cx: &@block_ctxt, Val: ValueRef, DestTy: TypeRef) -> ValueRef {\n+    ret llvm::LLVMBuildSExt(*cx.build, Val, DestTy, str::buf(\"\"));\n+}\n+\n+fn FPToUI(cx: &@block_ctxt, Val: ValueRef, DestTy: TypeRef) -> ValueRef {\n+    ret llvm::LLVMBuildFPToUI(*cx.build, Val, DestTy, str::buf(\"\"));\n+}\n+\n+fn FPToSI(cx: &@block_ctxt, Val: ValueRef, DestTy: TypeRef) -> ValueRef {\n+    ret llvm::LLVMBuildFPToSI(*cx.build, Val, DestTy, str::buf(\"\"));\n+}\n+\n+fn UIToFP(cx: &@block_ctxt, Val: ValueRef, DestTy: TypeRef) -> ValueRef {\n+    ret llvm::LLVMBuildUIToFP(*cx.build, Val, DestTy, str::buf(\"\"));\n+}\n+\n+fn SIToFP(cx: &@block_ctxt, Val: ValueRef, DestTy: TypeRef) -> ValueRef {\n+    ret llvm::LLVMBuildSIToFP(*cx.build, Val, DestTy, str::buf(\"\"));\n+}\n+\n+fn FPTrunc(cx: &@block_ctxt, Val: ValueRef, DestTy: TypeRef) -> ValueRef {\n+    ret llvm::LLVMBuildFPTrunc(*cx.build, Val, DestTy, str::buf(\"\"));\n+}\n+\n+fn FPExt(cx: &@block_ctxt, Val: ValueRef, DestTy: TypeRef) -> ValueRef {\n+    ret llvm::LLVMBuildFPExt(*cx.build, Val, DestTy, str::buf(\"\"));\n+}\n+\n+fn PtrToInt(cx: &@block_ctxt, Val: ValueRef,\n+            DestTy: TypeRef) -> ValueRef {\n+    ret llvm::LLVMBuildPtrToInt(*cx.build, Val, DestTy, str::buf(\"\"));\n+}\n+\n+fn IntToPtr(cx: &@block_ctxt, Val: ValueRef,\n+            DestTy: TypeRef) -> ValueRef {\n+    ret llvm::LLVMBuildIntToPtr(*cx.build, Val, DestTy, str::buf(\"\"));\n+}\n+\n+fn BitCast(cx: &@block_ctxt, Val: ValueRef, DestTy: TypeRef) -> ValueRef {\n+    ret llvm::LLVMBuildBitCast(*cx.build, Val, DestTy, str::buf(\"\"));\n+}\n+\n+fn ZExtOrBitCast(cx: &@block_ctxt, Val: ValueRef,\n+                 DestTy: TypeRef) -> ValueRef {\n+    ret llvm::LLVMBuildZExtOrBitCast(*cx.build, Val, DestTy, str::buf(\"\"));\n+}\n+\n+fn SExtOrBitCast(cx: &@block_ctxt, Val: ValueRef,\n+                 DestTy: TypeRef) -> ValueRef {\n+    ret llvm::LLVMBuildSExtOrBitCast(*cx.build, Val, DestTy, str::buf(\"\"));\n+}\n+\n+fn TruncOrBitCast(cx: &@block_ctxt, Val: ValueRef,\n+                  DestTy: TypeRef) -> ValueRef {\n+    ret llvm::LLVMBuildTruncOrBitCast(*cx.build, Val, DestTy, str::buf(\"\"));\n+}\n+\n+fn Cast(cx: &@block_ctxt, Op: Opcode, Val: ValueRef,\n+        DestTy: TypeRef, _Name: sbuf) ->\n+    ValueRef {\n+    ret llvm::LLVMBuildCast(*cx.build, Op, Val, DestTy, str::buf(\"\"));\n+}\n+\n+fn PointerCast(cx: &@block_ctxt, Val: ValueRef, DestTy: TypeRef) -> ValueRef {\n+    ret llvm::LLVMBuildPointerCast(*cx.build, Val, DestTy, str::buf(\"\"));\n+}\n+\n+fn IntCast(cx: &@block_ctxt, Val: ValueRef, DestTy: TypeRef) -> ValueRef {\n+    ret llvm::LLVMBuildIntCast(*cx.build, Val, DestTy, str::buf(\"\"));\n+}\n+\n+fn FPCast(cx: &@block_ctxt, Val: ValueRef, DestTy: TypeRef) -> ValueRef {\n+    ret llvm::LLVMBuildFPCast(*cx.build, Val, DestTy, str::buf(\"\"));\n+}\n+\n+\n+/* Comparisons */\n+fn ICmp(cx: &@block_ctxt, Op: uint, LHS: ValueRef,\n+        RHS: ValueRef) -> ValueRef {\n+    ret llvm::LLVMBuildICmp(*cx.build, Op, LHS, RHS, str::buf(\"\"));\n+}\n+\n+fn FCmp(cx: &@block_ctxt, Op: uint, LHS: ValueRef,\n+        RHS: ValueRef) -> ValueRef {\n+    ret llvm::LLVMBuildFCmp(*cx.build, Op, LHS, RHS, str::buf(\"\"));\n+}\n+\n+\n+/* Miscellaneous instructions */\n+fn Phi(cx: &@block_ctxt, Ty: TypeRef, vals: &[ValueRef],\n+       bbs: &[BasicBlockRef]) -> ValueRef {\n+    let phi = llvm::LLVMBuildPhi(*cx.build, Ty, str::buf(\"\"));\n+    assert (vec::len::<ValueRef>(vals) == vec::len::<BasicBlockRef>(bbs));\n+    llvm::LLVMAddIncoming(phi, vec::to_ptr(vals), vec::to_ptr(bbs),\n+                          vec::len(vals));\n+    ret phi;\n+}\n+\n+fn AddIncomingToPhi(phi: ValueRef, vals: &[ValueRef], bbs: &[BasicBlockRef]) {\n+    assert (vec::len::<ValueRef>(vals) == vec::len::<BasicBlockRef>(bbs));\n+    llvm::LLVMAddIncoming(phi, vec::to_ptr(vals), vec::to_ptr(bbs),\n+                          vec::len(vals));\n+}\n+\n+fn Call(cx: &@block_ctxt, Fn: ValueRef, Args: &[ValueRef]) -> ValueRef {\n+    ret llvm::LLVMBuildCall(*cx.build, Fn, vec::to_ptr(Args), vec::len(Args),\n+                            str::buf(\"\"));\n+}\n+\n+fn FastCall(cx: &@block_ctxt, Fn: ValueRef, Args: &[ValueRef]) -> ValueRef {\n+    let v =\n+        llvm::LLVMBuildCall(*cx.build, Fn, vec::to_ptr(Args), vec::len(Args),\n+                            str::buf(\"\"));\n+    llvm::LLVMSetInstructionCallConv(v, lib::llvm::LLVMFastCallConv);\n+    ret v;\n+}\n+\n+fn CallWithConv(cx: &@block_ctxt, Fn: ValueRef, Args: &[ValueRef],\n+                Conv: uint) -> ValueRef {\n+    let v =\n+        llvm::LLVMBuildCall(*cx.build, Fn, vec::to_ptr(Args), vec::len(Args),\n+                            str::buf(\"\"));\n+    llvm::LLVMSetInstructionCallConv(v, Conv);\n+    ret v;\n+}\n+\n+fn Select(cx: &@block_ctxt, If: ValueRef, Then: ValueRef,\n+          Else: ValueRef) -> ValueRef {\n+    ret llvm::LLVMBuildSelect(*cx.build, If, Then, Else, str::buf(\"\"));\n+}\n+\n+fn VAArg(cx: &@block_ctxt, list: ValueRef, Ty: TypeRef) -> ValueRef {\n+    ret llvm::LLVMBuildVAArg(*cx.build, list, Ty, str::buf(\"\"));\n+}\n+\n+fn ExtractElement(cx: &@block_ctxt, VecVal: ValueRef,\n+                  Index: ValueRef) -> ValueRef {\n+    ret llvm::LLVMBuildExtractElement(*cx.build, VecVal, Index, str::buf(\"\"));\n+}\n+\n+fn InsertElement(cx: &@block_ctxt, VecVal: ValueRef, EltVal: ValueRef,\n+                 Index: ValueRef) ->\n+    ValueRef {\n+    ret llvm::LLVMBuildInsertElement(*cx.build, VecVal, EltVal, Index,\n+                                     str::buf(\"\"));\n+}\n+\n+fn ShuffleVector(cx: &@block_ctxt, V1: ValueRef, V2: ValueRef,\n+                 Mask: ValueRef) -> ValueRef {\n+    ret llvm::LLVMBuildShuffleVector(*cx.build, V1, V2, Mask, str::buf(\"\"));\n+}\n+\n+fn ExtractValue(cx: &@block_ctxt, AggVal: ValueRef, Index: uint) -> ValueRef {\n+    ret llvm::LLVMBuildExtractValue(*cx.build, AggVal, Index, str::buf(\"\"));\n+}\n+\n+fn InsertValue(cx: &@block_ctxt, AggVal: ValueRef,\n+               EltVal: ValueRef, Index: uint) -> ValueRef {\n+    ret llvm::LLVMBuildInsertValue(*cx.build, AggVal, EltVal, Index,\n+                                   str::buf(\"\"));\n+}\n+\n+fn IsNull(cx: &@block_ctxt, Val: ValueRef) -> ValueRef {\n+    ret llvm::LLVMBuildIsNull(*cx.build, Val, str::buf(\"\"));\n+}\n+\n+fn IsNotNull(cx: &@block_ctxt, Val: ValueRef) -> ValueRef {\n+    ret llvm::LLVMBuildIsNotNull(*cx.build, Val, str::buf(\"\"));\n+}\n+\n+fn PtrDiff(cx: &@block_ctxt, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n+    ret llvm::LLVMBuildPtrDiff(*cx.build, LHS, RHS, str::buf(\"\"));\n+}\n+\n+fn Trap(cx: &@block_ctxt) -> ValueRef {\n+    let BB: BasicBlockRef = llvm::LLVMGetInsertBlock(*cx.build);\n+    let FN: ValueRef = llvm::LLVMGetBasicBlockParent(BB);\n+    let M: ModuleRef = llvm::LLVMGetGlobalParent(FN);\n+    let T: ValueRef =\n+        llvm::LLVMGetNamedFunction(M, str::buf(\"llvm.trap\"));\n+    assert (T as int != 0);\n+    let Args: [ValueRef] = [];\n+    ret llvm::LLVMBuildCall(*cx.build, T, vec::to_ptr(Args), vec::len(Args),\n+                            str::buf(\"\"));\n+}\n+\n+//\n+// Local Variables:\n+// mode: rust\n+// fill-column: 78;\n+// indent-tabs-mode: nil\n+// c-basic-offset: 4\n+// buffer-file-coding-system: utf-8-unix\n+// compile-command: \"make -k -C $RBUILD 2>&1 | sed -e 's/\\\\/x\\\\//x:\\\\//g'\";\n+// End:\n+//"}, {"sha": "ef68f0ce5b17d83cfde35d743a4d8948fe17f39e", "filename": "src/comp/middle/trans_common.rs", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/b9112525ba27d46e056dcab303c27bb43073c4fc/src%2Fcomp%2Fmiddle%2Ftrans_common.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b9112525ba27d46e056dcab303c27bb43073c4fc/src%2Fcomp%2Fmiddle%2Ftrans_common.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans_common.rs?ref=b9112525ba27d46e056dcab303c27bb43073c4fc", "patch": "@@ -30,7 +30,6 @@ import std::map::new_int_hash;\n import std::map::new_str_hash;\n import syntax::codemap::span;\n import lib::llvm::llvm;\n-import lib::llvm::builder;\n import lib::llvm::target_data;\n import lib::llvm::type_names;\n import lib::llvm::mk_target_data;\n@@ -56,6 +55,7 @@ import util::ppaux::ty_to_str;\n import util::ppaux::ty_to_short_str;\n import syntax::print::pprust::expr_to_str;\n import syntax::print::pprust::path_to_str;\n+import bld = trans_build;\n \n // FIXME: These should probably be pulled in here too.\n import trans::type_of_fn_full;\n@@ -400,13 +400,18 @@ type block_ctxt =\n     // The function context for the function to which this block is\n     // attached.\n     {llbb: BasicBlockRef,\n-     build: builder,\n+     mutable terminated: bool,\n+     build: bld::BuilderRef_res,\n      parent: block_parent,\n      kind: block_kind,\n      mutable cleanups: [cleanup],\n      sp: span,\n      fcx: @fn_ctxt};\n \n+fn is_terminated(cx: &@block_ctxt) -> bool {\n+    ret cx.terminated;\n+}\n+\n // FIXME: we should be able to use option::t<@block_parent> here but\n // the infinite-tag check in rustboot gets upset.\n tag block_parent { parent_none; parent_some(@block_ctxt); }"}, {"sha": "b0c18dbc522722e27cb06df81d2fe4206b5aa9e5", "filename": "src/comp/middle/trans_ivec.rs", "status": "modified", "additions": 154, "deletions": 154, "changes": 308, "blob_url": "https://github.com/rust-lang/rust/blob/b9112525ba27d46e056dcab303c27bb43073c4fc/src%2Fcomp%2Fmiddle%2Ftrans_ivec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b9112525ba27d46e056dcab303c27bb43073c4fc/src%2Fcomp%2Fmiddle%2Ftrans_ivec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans_ivec.rs?ref=b9112525ba27d46e056dcab303c27bb43073c4fc", "patch": "@@ -9,6 +9,7 @@ import trans::{call_memmove, trans_shared_malloc, llsize_of,\n                lazily_emit_tydesc_glue, get_tydesc, load_inbounds,\n                move_val_if_temp, trans_lval, node_id_type,\n                new_sub_block_ctxt};\n+import bld = trans_build;\n import trans_common::*;\n \n fn alloc_with_heap(bcx: @block_ctxt, typ: &ty::t, vecsz: uint) ->\n@@ -33,23 +34,23 @@ fn alloc_with_heap(bcx: @block_ctxt, typ: &ty::t, vecsz: uint) ->\n \n     add_clean_temp(bcx, llvecptr, typ);\n \n-    let lllen = bcx.build.Mul(C_uint(vecsz), unit_sz);\n+    let lllen = bld::Mul(bcx, C_uint(vecsz), unit_sz);\n     // Allocate the vector pieces and store length and allocated length.\n \n     let llfirsteltptr;\n     if vecsz > 0u && vecsz <= abi::ivec_default_length {\n         // Interior case.\n \n-        bcx.build.Store(lllen,\n-                        bcx.build.InBoundsGEP(llvecptr,\n+        bld::Store(bcx, lllen,\n+                        bld::InBoundsGEP(bcx, llvecptr,\n                                               [C_int(0),\n                                                C_uint(abi::ivec_elt_len)]));\n-        bcx.build.Store(llalen,\n-                        bcx.build.InBoundsGEP(llvecptr,\n+        bld::Store(bcx, llalen,\n+                        bld::InBoundsGEP(bcx, llvecptr,\n                                               [C_int(0),\n                                                C_uint(abi::ivec_elt_alen)]));\n         llfirsteltptr =\n-            bcx.build.InBoundsGEP(llvecptr,\n+            bld::InBoundsGEP(bcx, llvecptr,\n                                   [C_int(0), C_uint(abi::ivec_elt_elems),\n                                    C_int(0)]);\n     } else {\n@@ -59,29 +60,29 @@ fn alloc_with_heap(bcx: @block_ctxt, typ: &ty::t, vecsz: uint) ->\n         let stub_a = [C_int(0), C_uint(abi::ivec_heap_stub_elt_alen)];\n         let stub_p = [C_int(0), C_uint(abi::ivec_heap_stub_elt_ptr)];\n         let llstubty = T_ivec_heap(llunitty);\n-        let llstubptr = bcx.build.PointerCast(llvecptr, T_ptr(llstubty));\n-        bcx.build.Store(C_int(0), bcx.build.InBoundsGEP(llstubptr, stub_z));\n+        let llstubptr = bld::PointerCast(bcx, llvecptr, T_ptr(llstubty));\n+        bld::Store(bcx, C_int(0), bld::InBoundsGEP(bcx, llstubptr, stub_z));\n         let llheapty = T_ivec_heap_part(llunitty);\n         if vecsz == 0u {\n             // Null heap pointer indicates a zero-length vector.\n \n-            bcx.build.Store(llalen, bcx.build.InBoundsGEP(llstubptr, stub_a));\n-            bcx.build.Store(C_null(T_ptr(llheapty)),\n-                            bcx.build.InBoundsGEP(llstubptr, stub_p));\n+            bld::Store(bcx, llalen, bld::InBoundsGEP(bcx, llstubptr, stub_a));\n+            bld::Store(bcx, C_null(T_ptr(llheapty)),\n+                            bld::InBoundsGEP(bcx, llstubptr, stub_p));\n             llfirsteltptr = C_null(T_ptr(llunitty));\n         } else {\n-            bcx.build.Store(lllen, bcx.build.InBoundsGEP(llstubptr, stub_a));\n+            bld::Store(bcx, lllen, bld::InBoundsGEP(bcx, llstubptr, stub_a));\n \n-            let llheapsz = bcx.build.Add(llsize_of(llheapty), lllen);\n+            let llheapsz = bld::Add(bcx, llsize_of(llheapty), lllen);\n             let rslt = trans_shared_malloc(bcx, T_ptr(llheapty), llheapsz);\n             bcx = rslt.bcx;\n             let llheapptr = rslt.val;\n-            bcx.build.Store(llheapptr,\n-                            bcx.build.InBoundsGEP(llstubptr, stub_p));\n+            bld::Store(bcx, llheapptr,\n+                            bld::InBoundsGEP(bcx, llstubptr, stub_p));\n             let heap_l = [C_int(0), C_uint(abi::ivec_heap_elt_len)];\n-            bcx.build.Store(lllen, bcx.build.InBoundsGEP(llheapptr, heap_l));\n+            bld::Store(bcx, lllen, bld::InBoundsGEP(bcx, llheapptr, heap_l));\n             llfirsteltptr =\n-                bcx.build.InBoundsGEP(llheapptr,\n+                bld::InBoundsGEP(bcx, llheapptr,\n                                       [C_int(0),\n                                        C_uint(abi::ivec_heap_elt_elems),\n                                        C_int(0)]);\n@@ -115,10 +116,10 @@ fn trans_ivec(bcx: @block_ctxt, args: &[@ast::expr],\n         let lleltptr;\n         if ty::type_has_dynamic_size(bcx_tcx(bcx), unit_ty) {\n             lleltptr =\n-                bcx.build.InBoundsGEP(llfirsteltptr,\n-                                      [bcx.build.Mul(C_uint(i), llunitsz)]);\n+                bld::InBoundsGEP(bcx, llfirsteltptr,\n+                                      [bld::Mul(bcx, C_uint(i), llunitsz)]);\n         } else {\n-            lleltptr = bcx.build.InBoundsGEP(llfirsteltptr, [C_uint(i)]);\n+            lleltptr = bld::InBoundsGEP(bcx, llfirsteltptr, [C_uint(i)]);\n         }\n         bcx = move_val_if_temp(bcx, INIT, lleltptr, lv, unit_ty);\n         i += 1u;\n@@ -135,23 +136,23 @@ fn get_len_and_data(bcx: &@block_ctxt, orig_v: ValueRef, unit_ty: ty::t)\n     // opaque vector type.\n     let v;\n     if ty::type_has_dynamic_size(bcx_tcx(bcx), unit_ty) {\n-        v = bcx.build.PointerCast(orig_v, T_ptr(T_opaque_ivec()));\n+        v = bld::PointerCast(bcx, orig_v, T_ptr(T_opaque_ivec()));\n     } else { v = orig_v; }\n \n     let llunitty = type_of_or_i8(bcx, unit_ty);\n     let stack_len =\n         load_inbounds(bcx, v, [C_int(0), C_uint(abi::ivec_elt_len)]);\n     let stack_elem =\n-        bcx.build.InBoundsGEP(v,\n+        bld::InBoundsGEP(bcx, v,\n                               [C_int(0), C_uint(abi::ivec_elt_elems),\n                                C_int(0)]);\n     let on_heap =\n-        bcx.build.ICmp(lib::llvm::LLVMIntEQ, stack_len, C_int(0));\n+        bld::ICmp(bcx, lib::llvm::LLVMIntEQ, stack_len, C_int(0));\n     let on_heap_cx = new_sub_block_ctxt(bcx, \"on_heap\");\n     let next_cx = new_sub_block_ctxt(bcx, \"next\");\n-    bcx.build.CondBr(on_heap, on_heap_cx.llbb, next_cx.llbb);\n+    bld::CondBr(bcx, on_heap, on_heap_cx.llbb, next_cx.llbb);\n     let heap_stub =\n-        on_heap_cx.build.PointerCast(v, T_ptr(T_ivec_heap(llunitty)));\n+        bld::PointerCast(on_heap_cx, v, T_ptr(T_ivec_heap(llunitty)));\n     let heap_ptr =\n         load_inbounds(on_heap_cx, heap_stub,\n                       [C_int(0), C_uint(abi::ivec_heap_stub_elt_ptr)]);\n@@ -162,18 +163,18 @@ fn get_len_and_data(bcx: &@block_ctxt, orig_v: ValueRef, unit_ty: ty::t)\n     let llstubty = T_ivec_heap(llunitty);\n     let llheapptrty = struct_elt(llstubty, abi::ivec_heap_stub_elt_ptr);\n     let heap_ptr_is_null =\n-        on_heap_cx.build.ICmp(lib::llvm::LLVMIntEQ, heap_ptr,\n+        bld::ICmp(on_heap_cx, lib::llvm::LLVMIntEQ, heap_ptr,\n                               C_null(T_ptr(llheapptrty)));\n     let zero_len_cx = new_sub_block_ctxt(bcx, \"zero_len\");\n     let nonzero_len_cx = new_sub_block_ctxt(bcx, \"nonzero_len\");\n-    on_heap_cx.build.CondBr(heap_ptr_is_null, zero_len_cx.llbb,\n+    bld::CondBr(on_heap_cx, heap_ptr_is_null, zero_len_cx.llbb,\n                             nonzero_len_cx.llbb);\n     // Technically this context is unnecessary, but it makes this function\n     // clearer.\n \n     let zero_len = C_int(0);\n     let zero_elem = C_null(T_ptr(llunitty));\n-    zero_len_cx.build.Br(next_cx.llbb);\n+    bld::Br(zero_len_cx, next_cx.llbb);\n     // If we're here, then we actually have a heapified vector.\n \n     let heap_len =\n@@ -183,19 +184,19 @@ fn get_len_and_data(bcx: &@block_ctxt, orig_v: ValueRef, unit_ty: ty::t)\n         {\n         let v =\n             [C_int(0), C_uint(abi::ivec_heap_elt_elems), C_int(0)];\n-        nonzero_len_cx.build.InBoundsGEP(heap_ptr, v)\n+        bld::InBoundsGEP(nonzero_len_cx, heap_ptr, v)\n     };\n \n-    nonzero_len_cx.build.Br(next_cx.llbb);\n+    bld::Br(nonzero_len_cx, next_cx.llbb);\n     // Now we can figure out the length of `v` and get a pointer to its\n     // first element.\n \n     let len =\n-        next_cx.build.Phi(T_int(), [stack_len, zero_len, heap_len],\n+        bld::Phi(next_cx, T_int(), [stack_len, zero_len, heap_len],\n                           [bcx.llbb, zero_len_cx.llbb,\n                            nonzero_len_cx.llbb]);\n     let elem =\n-        next_cx.build.Phi(T_ptr(llunitty),\n+        bld::Phi(next_cx, T_ptr(llunitty),\n                           [stack_elem, zero_elem, heap_elem],\n                           [bcx.llbb, zero_len_cx.llbb,\n                            nonzero_len_cx.llbb]);\n@@ -207,8 +208,8 @@ fn get_len_and_data(bcx: &@block_ctxt, orig_v: ValueRef, unit_ty: ty::t)\n fn reserve_space(cx: &@block_ctxt, llunitty: TypeRef, v: ValueRef,\n                  len_needed: ValueRef) -> result {\n     let stack_len_ptr =\n-        cx.build.InBoundsGEP(v, [C_int(0), C_uint(abi::ivec_elt_len)]);\n-    let stack_len = cx.build.Load(stack_len_ptr);\n+        bld::InBoundsGEP(cx, v, [C_int(0), C_uint(abi::ivec_elt_len)]);\n+    let stack_len = bld::Load(cx, stack_len_ptr);\n     let alen =\n         load_inbounds(cx, v, [C_int(0), C_uint(abi::ivec_elt_alen)]);\n     // There are four cases we have to consider:\n@@ -218,40 +219,40 @@ fn reserve_space(cx: &@block_ctxt, llunitty: TypeRef, v: ValueRef,\n     // (4) On stack, need to spill to heap.\n \n     let maybe_on_heap =\n-        cx.build.ICmp(lib::llvm::LLVMIntEQ, stack_len, C_int(0));\n+        bld::ICmp(cx, lib::llvm::LLVMIntEQ, stack_len, C_int(0));\n     let maybe_on_heap_cx = new_sub_block_ctxt(cx, \"maybe_on_heap\");\n     let on_stack_cx = new_sub_block_ctxt(cx, \"on_stack\");\n-    cx.build.CondBr(maybe_on_heap, maybe_on_heap_cx.llbb,\n+    bld::CondBr(cx, maybe_on_heap, maybe_on_heap_cx.llbb,\n                     on_stack_cx.llbb);\n     let next_cx = new_sub_block_ctxt(cx, \"next\");\n     // We're possibly on the heap, unless the vector is zero-length.\n \n     let stub_p = [C_int(0), C_uint(abi::ivec_heap_stub_elt_ptr)];\n     let stub_ptr =\n-        maybe_on_heap_cx.build.PointerCast(v,\n+        bld::PointerCast(maybe_on_heap_cx, v,\n                                            T_ptr(T_ivec_heap(llunitty)));\n     let heap_ptr = load_inbounds(maybe_on_heap_cx, stub_ptr, stub_p);\n     let on_heap =\n-        maybe_on_heap_cx.build.ICmp(lib::llvm::LLVMIntNE, heap_ptr,\n+        bld::ICmp(maybe_on_heap_cx, lib::llvm::LLVMIntNE, heap_ptr,\n                                     C_null(val_ty(heap_ptr)));\n     let on_heap_cx = new_sub_block_ctxt(cx, \"on_heap\");\n-    maybe_on_heap_cx.build.CondBr(on_heap, on_heap_cx.llbb,\n+    bld::CondBr(maybe_on_heap_cx, on_heap, on_heap_cx.llbb,\n                                   on_stack_cx.llbb);\n     // We're definitely on the heap. Check whether we need to resize.\n \n     let heap_len_ptr =\n-        on_heap_cx.build.InBoundsGEP(heap_ptr,\n+        bld::InBoundsGEP(on_heap_cx, heap_ptr,\n                                      [C_int(0),\n                                       C_uint(abi::ivec_heap_elt_len)]);\n-    let heap_len = on_heap_cx.build.Load(heap_len_ptr);\n-    let new_heap_len = on_heap_cx.build.Add(heap_len, len_needed);\n+    let heap_len = bld::Load(on_heap_cx, heap_len_ptr);\n+    let new_heap_len = bld::Add(on_heap_cx, heap_len, len_needed);\n     let heap_len_unscaled =\n-        on_heap_cx.build.UDiv(heap_len, llsize_of(llunitty));\n+        bld::UDiv(on_heap_cx, heap_len, llsize_of(llunitty));\n     let heap_no_resize_needed =\n-        on_heap_cx.build.ICmp(lib::llvm::LLVMIntULE, new_heap_len, alen);\n+        bld::ICmp(on_heap_cx, lib::llvm::LLVMIntULE, new_heap_len, alen);\n     let heap_no_resize_cx = new_sub_block_ctxt(cx, \"heap_no_resize\");\n     let heap_resize_cx = new_sub_block_ctxt(cx, \"heap_resize\");\n-    on_heap_cx.build.CondBr(heap_no_resize_needed, heap_no_resize_cx.llbb,\n+    bld::CondBr(on_heap_cx, heap_no_resize_needed, heap_no_resize_cx.llbb,\n                             heap_resize_cx.llbb);\n     // Case (1): We're on the heap and don't need to resize.\n \n@@ -260,18 +261,18 @@ fn reserve_space(cx: &@block_ctxt, llunitty: TypeRef, v: ValueRef,\n         let v =\n             [C_int(0), C_uint(abi::ivec_heap_elt_elems),\n              heap_len_unscaled];\n-        heap_no_resize_cx.build.InBoundsGEP(heap_ptr, v)\n+        bld::InBoundsGEP(heap_no_resize_cx, heap_ptr, v)\n     };\n-    heap_no_resize_cx.build.Store(new_heap_len, heap_len_ptr);\n-    heap_no_resize_cx.build.Br(next_cx.llbb);\n+    bld::Store(heap_no_resize_cx, new_heap_len, heap_len_ptr);\n+    bld::Br(heap_no_resize_cx, next_cx.llbb);\n     // Case (2): We're on the heap and need to resize. This path is rare,\n     // so we delegate to cold glue.\n \n     {\n         let p =\n-            heap_resize_cx.build.PointerCast(v, T_ptr(T_opaque_ivec()));\n+            bld::PointerCast(heap_resize_cx, v, T_ptr(T_opaque_ivec()));\n         let upcall = bcx_ccx(cx).upcalls.ivec_resize_shared;\n-        heap_resize_cx.build.Call(upcall,\n+        bld::Call(heap_resize_cx, upcall,\n                                   [cx.fcx.lltaskptr, p, new_heap_len]);\n     }\n     let heap_ptr_resize = load_inbounds(heap_resize_cx, stub_ptr, stub_p);\n@@ -281,42 +282,42 @@ fn reserve_space(cx: &@block_ctxt, llunitty: TypeRef, v: ValueRef,\n         let v =\n             [C_int(0), C_uint(abi::ivec_heap_elt_elems),\n              heap_len_unscaled];\n-        heap_resize_cx.build.InBoundsGEP(heap_ptr_resize, v)\n+        bld::InBoundsGEP(heap_resize_cx, heap_ptr_resize, v)\n     };\n-    heap_resize_cx.build.Br(next_cx.llbb);\n+    bld::Br(heap_resize_cx, next_cx.llbb);\n     // We're on the stack. Check whether we need to spill to the heap.\n \n-    let new_stack_len = on_stack_cx.build.Add(stack_len, len_needed);\n+    let new_stack_len = bld::Add(on_stack_cx, stack_len, len_needed);\n     let stack_no_spill_needed =\n-        on_stack_cx.build.ICmp(lib::llvm::LLVMIntULE, new_stack_len,\n+        bld::ICmp(on_stack_cx, lib::llvm::LLVMIntULE, new_stack_len,\n                                alen);\n     let stack_len_unscaled =\n-        on_stack_cx.build.UDiv(stack_len, llsize_of(llunitty));\n+        bld::UDiv(on_stack_cx, stack_len, llsize_of(llunitty));\n     let stack_no_spill_cx = new_sub_block_ctxt(cx, \"stack_no_spill\");\n     let stack_spill_cx = new_sub_block_ctxt(cx, \"stack_spill\");\n-    on_stack_cx.build.CondBr(stack_no_spill_needed,\n+    bld::CondBr(on_stack_cx, stack_no_spill_needed,\n                              stack_no_spill_cx.llbb, stack_spill_cx.llbb);\n     // Case (3): We're on the stack and don't need to spill.\n \n     let stack_data_no_spill =\n-        stack_no_spill_cx.build.InBoundsGEP(v,\n+        bld::InBoundsGEP(stack_no_spill_cx, v,\n                                             [C_int(0),\n                                              C_uint(abi::ivec_elt_elems),\n                                              stack_len_unscaled]);\n-    stack_no_spill_cx.build.Store(new_stack_len, stack_len_ptr);\n-    stack_no_spill_cx.build.Br(next_cx.llbb);\n+    bld::Store(stack_no_spill_cx, new_stack_len, stack_len_ptr);\n+    bld::Br(stack_no_spill_cx, next_cx.llbb);\n     // Case (4): We're on the stack and need to spill. Like case (2), this\n     // path is rare, so we delegate to cold glue.\n \n     {\n         let p =\n-            stack_spill_cx.build.PointerCast(v, T_ptr(T_opaque_ivec()));\n+            bld::PointerCast(stack_spill_cx, v, T_ptr(T_opaque_ivec()));\n         let upcall = bcx_ccx(cx).upcalls.ivec_spill_shared;\n-        stack_spill_cx.build.Call(upcall,\n+        bld::Call(stack_spill_cx, upcall,\n                                   [cx.fcx.lltaskptr, p, new_stack_len]);\n     }\n     let spill_stub =\n-        stack_spill_cx.build.PointerCast(v, T_ptr(T_ivec_heap(llunitty)));\n+        bld::PointerCast(stack_spill_cx, v, T_ptr(T_ivec_heap(llunitty)));\n \n     let heap_ptr_spill =\n         load_inbounds(stack_spill_cx, spill_stub, stub_p);\n@@ -326,13 +327,13 @@ fn reserve_space(cx: &@block_ctxt, llunitty: TypeRef, v: ValueRef,\n         let v =\n             [C_int(0), C_uint(abi::ivec_heap_elt_elems),\n              stack_len_unscaled];\n-        stack_spill_cx.build.InBoundsGEP(heap_ptr_spill, v)\n+        bld::InBoundsGEP(stack_spill_cx, heap_ptr_spill, v)\n     };\n-    stack_spill_cx.build.Br(next_cx.llbb);\n+    bld::Br(stack_spill_cx, next_cx.llbb);\n     // Phi together the different data pointers to get the result.\n \n     let data_ptr =\n-        next_cx.build.Phi(T_ptr(llunitty),\n+        bld::Phi(next_cx, T_ptr(llunitty),\n                           [heap_data_no_resize, heap_data_resize,\n                            stack_data_no_spill, heap_data_spill],\n                           [heap_no_resize_cx.llbb, heap_resize_cx.llbb,\n@@ -343,8 +344,8 @@ fn trans_append(cx: &@block_ctxt, t: ty::t, lhs: ValueRef,\n                 rhs: ValueRef) -> result {\n     // Cast to opaque interior vector types if necessary.\n     if ty::type_has_dynamic_size(bcx_tcx(cx), t) {\n-        lhs = cx.build.PointerCast(lhs, T_ptr(T_opaque_ivec()));\n-        rhs = cx.build.PointerCast(rhs, T_ptr(T_opaque_ivec()));\n+        lhs = bld::PointerCast(cx, lhs, T_ptr(T_opaque_ivec()));\n+        rhs = bld::PointerCast(cx, rhs, T_ptr(T_opaque_ivec()));\n     }\n \n     let unit_ty = ty::sequence_element_type(bcx_tcx(cx), t);\n@@ -380,7 +381,7 @@ fn trans_append(cx: &@block_ctxt, t: ty::t, lhs: ValueRef,\n \n     let extra_len = if have_istrs {\n         // Only need one of the nulls\n-        bcx.build.Sub(rhs_len, C_uint(1u))\n+        bld::Sub(bcx, rhs_len, C_uint(1u))\n     } else { rhs_len };\n \n     rs = reserve_space(bcx, llunitty, lhs, extra_len);\n@@ -391,7 +392,7 @@ fn trans_append(cx: &@block_ctxt, t: ty::t, lhs: ValueRef,\n         let lhs_data_without_null_ptr = alloca(bcx, T_ptr(llunitty));\n         incr_ptr(bcx, lhs_data, C_int(-1),\n                  lhs_data_without_null_ptr);\n-        bcx.build.Load(lhs_data_without_null_ptr)\n+        bld::Load(bcx, lhs_data_without_null_ptr)\n     } else {\n         rs.val\n     };\n@@ -403,27 +404,27 @@ fn trans_append(cx: &@block_ctxt, t: ty::t, lhs: ValueRef,\n \n     // Work out the end pointer.\n \n-    let lhs_unscaled_idx = bcx.build.UDiv(rhs_len, llsize_of(llunitty));\n-    let lhs_end = bcx.build.InBoundsGEP(lhs_data, [lhs_unscaled_idx]);\n+    let lhs_unscaled_idx = bld::UDiv(bcx, rhs_len, llsize_of(llunitty));\n+    let lhs_end = bld::InBoundsGEP(bcx, lhs_data, [lhs_unscaled_idx]);\n     // Now emit the copy loop.\n \n     let dest_ptr = alloca(bcx, T_ptr(llunitty));\n-    bcx.build.Store(lhs_data, dest_ptr);\n+    bld::Store(bcx, lhs_data, dest_ptr);\n     let src_ptr = alloca(bcx, T_ptr(llunitty));\n-    bcx.build.Store(rhs_data, src_ptr);\n+    bld::Store(bcx, rhs_data, src_ptr);\n     let copy_loop_header_cx = new_sub_block_ctxt(bcx, \"copy_loop_header\");\n-    bcx.build.Br(copy_loop_header_cx.llbb);\n-    let copy_dest_ptr = copy_loop_header_cx.build.Load(dest_ptr);\n+    bld::Br(bcx, copy_loop_header_cx.llbb);\n+    let copy_dest_ptr = bld::Load(copy_loop_header_cx, dest_ptr);\n     let not_yet_at_end =\n-        copy_loop_header_cx.build.ICmp(lib::llvm::LLVMIntNE,\n+        bld::ICmp(copy_loop_header_cx, lib::llvm::LLVMIntNE,\n                                        copy_dest_ptr, lhs_end);\n     let copy_loop_body_cx = new_sub_block_ctxt(bcx, \"copy_loop_body\");\n     let next_cx = new_sub_block_ctxt(bcx, \"next\");\n-    copy_loop_header_cx.build.CondBr(not_yet_at_end,\n+    bld::CondBr(copy_loop_header_cx, not_yet_at_end,\n                                      copy_loop_body_cx.llbb,\n                                      next_cx.llbb);\n \n-    let copy_src_ptr = copy_loop_body_cx.build.Load(src_ptr);\n+    let copy_src_ptr = bld::Load(copy_loop_body_cx, src_ptr);\n     let copy_src =\n         load_if_immediate(copy_loop_body_cx, copy_src_ptr, unit_ty);\n \n@@ -439,7 +440,7 @@ fn trans_append(cx: &@block_ctxt, t: ty::t, lhs: ValueRef,\n         incr_ptr(post_copy_cx, copy_src_ptr, C_int(1), src_ptr);\n     }\n \n-    post_copy_cx.build.Br(copy_loop_header_cx.llbb);\n+    bld::Br(post_copy_cx, copy_loop_header_cx.llbb);\n     ret rslt(next_cx, C_nil());\n }\n \n@@ -449,14 +450,14 @@ fn trans_append_literal(bcx: &@block_ctxt, v: ValueRef, vec_ty: ty::t,\n     let ti = none;\n     let {bcx, val: td} = get_tydesc(bcx, elt_ty, false, ti).result;\n     trans::lazily_emit_all_tydesc_glue(bcx, ti);\n-    let opaque_v = bcx.build.PointerCast(v, T_ptr(T_opaque_ivec()));\n+    let opaque_v = bld::PointerCast(bcx, v, T_ptr(T_opaque_ivec()));\n     for val in vals {\n         let {bcx: e_bcx, val: elt} = trans::trans_expr(bcx, val);\n         bcx = e_bcx;\n         let spilled = trans::spill_if_immediate(bcx, elt, elt_ty);\n-        bcx.build.Call(bcx_ccx(bcx).upcalls.ivec_push,\n+        bld::Call(bcx, bcx_ccx(bcx).upcalls.ivec_push,\n                        [bcx.fcx.lltaskptr, opaque_v, td,\n-                        bcx.build.PointerCast(spilled, T_ptr(T_i8()))]);\n+                        bld::PointerCast(bcx, spilled, T_ptr(T_i8()))]);\n     }\n     ret bcx;\n }\n@@ -483,18 +484,18 @@ fn alloc(cx: &@block_ctxt, unit_ty: ty::t) -> alloc_result {\n     if dynamic { cx.fcx.llderivedtydescs = bcx.llbb; }\n \n     let llalen =\n-        bcx.build.Mul(llunitsz, C_uint(abi::ivec_default_length));\n+        bld::Mul(bcx, llunitsz, C_uint(abi::ivec_default_length));\n \n     let llptr;\n     let llunitty = type_of_or_i8(bcx, unit_ty);\n     let bcx_result;\n     if dynamic {\n-        let llarraysz = bcx.build.Add(llsize_of(T_opaque_ivec()), llalen);\n+        let llarraysz = bld::Add(bcx, llsize_of(T_opaque_ivec()), llalen);\n         let llvecptr = array_alloca(bcx, T_i8(), llarraysz);\n \n         bcx_result = cx;\n         llptr =\n-            bcx_result.build.PointerCast(llvecptr,\n+            bld::PointerCast(bcx_result, llvecptr,\n                                          T_ptr(T_opaque_ivec()));\n     } else { llptr = alloca(bcx, T_ivec(llunitty)); bcx_result = bcx; }\n \n@@ -527,7 +528,7 @@ fn trans_add(cx: &@block_ctxt, vec_ty: ty::t, lhs: ValueRef,\n     lhs_len = alt ty::struct(bcx_tcx(bcx), vec_ty) {\n       ty::ty_istr. {\n         // Forget about the trailing null on the left side\n-        bcx.build.Sub(lhs_len, C_uint(1u))\n+        bld::Sub(bcx, lhs_len, C_uint(1u))\n       }\n       ty::ty_vec(_) { lhs_len }\n       _ { bcx_tcx(bcx).sess.bug(\"non-istr/ivec in trans_add\") }\n@@ -537,17 +538,17 @@ fn trans_add(cx: &@block_ctxt, vec_ty: ty::t, lhs: ValueRef,\n     let rhs_len = rhs_len_and_data.len;\n     let rhs_data = rhs_len_and_data.data;\n     bcx = rhs_len_and_data.bcx;\n-    let lllen = bcx.build.Add(lhs_len, rhs_len);\n+    let lllen = bld::Add(bcx, lhs_len, rhs_len);\n     // We have three cases to handle here:\n     // (1) Length is zero ([] + []).\n     // (2) Copy onto stack.\n     // (3) Allocate on heap and copy there.\n \n     let len_is_zero =\n-        bcx.build.ICmp(lib::llvm::LLVMIntEQ, lllen, C_int(0));\n+        bld::ICmp(bcx, lib::llvm::LLVMIntEQ, lllen, C_int(0));\n     let zero_len_cx = new_sub_block_ctxt(bcx, \"zero_len\");\n     let nonzero_len_cx = new_sub_block_ctxt(bcx, \"nonzero_len\");\n-    bcx.build.CondBr(len_is_zero, zero_len_cx.llbb, nonzero_len_cx.llbb);\n+    bld::CondBr(bcx, len_is_zero, zero_len_cx.llbb, nonzero_len_cx.llbb);\n     // Case (1): Length is zero.\n \n     let stub_z = [C_int(0), C_uint(abi::ivec_heap_stub_elt_zero)];\n@@ -558,103 +559,103 @@ fn trans_add(cx: &@block_ctxt, vec_ty: ty::t, lhs: ValueRef,\n     let vec_a = [C_int(0), C_uint(abi::ivec_elt_alen)];\n \n     let stub_ptr_zero =\n-        zero_len_cx.build.PointerCast(llvecptr,\n+        bld::PointerCast(zero_len_cx, llvecptr,\n                                       T_ptr(T_ivec_heap(llunitty)));\n-    zero_len_cx.build.Store(C_int(0),\n-                            zero_len_cx.build.InBoundsGEP(stub_ptr_zero,\n+    bld::Store(zero_len_cx, C_int(0),\n+                            bld::InBoundsGEP(zero_len_cx, stub_ptr_zero,\n                                                           stub_z));\n-    zero_len_cx.build.Store(llalen,\n-                            zero_len_cx.build.InBoundsGEP(stub_ptr_zero,\n+    bld::Store(zero_len_cx, llalen,\n+                            bld::InBoundsGEP(zero_len_cx, stub_ptr_zero,\n                                                           stub_a));\n-    zero_len_cx.build.Store(C_null(T_ptr(llheappartty)),\n-                            zero_len_cx.build.InBoundsGEP(stub_ptr_zero,\n+    bld::Store(zero_len_cx, C_null(T_ptr(llheappartty)),\n+                            bld::InBoundsGEP(zero_len_cx, stub_ptr_zero,\n                                                           stub_p));\n     let next_cx = new_sub_block_ctxt(bcx, \"next\");\n-    zero_len_cx.build.Br(next_cx.llbb);\n+    bld::Br(zero_len_cx, next_cx.llbb);\n     // Determine whether we need to spill to the heap.\n \n     let on_stack =\n-        nonzero_len_cx.build.ICmp(lib::llvm::LLVMIntULE, lllen, llalen);\n+        bld::ICmp(nonzero_len_cx, lib::llvm::LLVMIntULE, lllen, llalen);\n     let stack_cx = new_sub_block_ctxt(bcx, \"stack\");\n     let heap_cx = new_sub_block_ctxt(bcx, \"heap\");\n-    nonzero_len_cx.build.CondBr(on_stack, stack_cx.llbb, heap_cx.llbb);\n+    bld::CondBr(nonzero_len_cx, on_stack, stack_cx.llbb, heap_cx.llbb);\n     // Case (2): Copy onto stack.\n \n-    stack_cx.build.Store(lllen,\n-                         stack_cx.build.InBoundsGEP(llvecptr, vec_l));\n-    stack_cx.build.Store(llalen,\n-                         stack_cx.build.InBoundsGEP(llvecptr, vec_a));\n+    bld::Store(stack_cx, lllen,\n+                         bld::InBoundsGEP(stack_cx, llvecptr, vec_l));\n+    bld::Store(stack_cx, llalen,\n+                         bld::InBoundsGEP(stack_cx, llvecptr, vec_a));\n     let dest_ptr_stack =\n-        stack_cx.build.InBoundsGEP(llvecptr,\n+        bld::InBoundsGEP(stack_cx, llvecptr,\n                                    [C_int(0), C_uint(abi::ivec_elt_elems),\n                                     C_int(0)]);\n     let copy_cx = new_sub_block_ctxt(bcx, \"copy\");\n-    stack_cx.build.Br(copy_cx.llbb);\n+    bld::Br(stack_cx, copy_cx.llbb);\n     // Case (3): Allocate on heap and copy there.\n \n     let stub_ptr_heap =\n-        heap_cx.build.PointerCast(llvecptr, T_ptr(T_ivec_heap(llunitty)));\n-    heap_cx.build.Store(C_int(0),\n-                        heap_cx.build.InBoundsGEP(stub_ptr_heap, stub_z));\n-    heap_cx.build.Store(lllen,\n-                        heap_cx.build.InBoundsGEP(stub_ptr_heap, stub_a));\n-    let heap_sz = heap_cx.build.Add(llsize_of(llheappartty), lllen);\n+        bld::PointerCast(heap_cx, llvecptr, T_ptr(T_ivec_heap(llunitty)));\n+    bld::Store(heap_cx, C_int(0),\n+                        bld::InBoundsGEP(heap_cx, stub_ptr_heap, stub_z));\n+    bld::Store(heap_cx, lllen,\n+                        bld::InBoundsGEP(heap_cx, stub_ptr_heap, stub_a));\n+    let heap_sz = bld::Add(heap_cx, llsize_of(llheappartty), lllen);\n     let rs = trans_shared_malloc(heap_cx, T_ptr(llheappartty), heap_sz);\n     let heap_part = rs.val;\n     heap_cx = rs.bcx;\n-    heap_cx.build.Store(heap_part,\n-                        heap_cx.build.InBoundsGEP(stub_ptr_heap, stub_p));\n+    bld::Store(heap_cx, heap_part,\n+                        bld::InBoundsGEP(heap_cx, stub_ptr_heap, stub_p));\n     {\n         let v = [C_int(0), C_uint(abi::ivec_heap_elt_len)];\n-        heap_cx.build.Store(lllen,\n-                            heap_cx.build.InBoundsGEP(heap_part, v));\n+        bld::Store(heap_cx, lllen,\n+                            bld::InBoundsGEP(heap_cx, heap_part, v));\n     }\n     let dest_ptr_heap =\n-        heap_cx.build.InBoundsGEP(heap_part,\n+        bld::InBoundsGEP(heap_cx, heap_part,\n                                   [C_int(0),\n                                    C_uint(abi::ivec_heap_elt_elems),\n                                    C_int(0)]);\n-    heap_cx.build.Br(copy_cx.llbb);\n+    bld::Br(heap_cx, copy_cx.llbb);\n     // Emit the copy loop.\n \n     let first_dest_ptr =\n-        copy_cx.build.Phi(T_ptr(llunitty),\n+        bld::Phi(copy_cx, T_ptr(llunitty),\n                           [dest_ptr_stack, dest_ptr_heap],\n                           [stack_cx.llbb, heap_cx.llbb]);\n \n     let lhs_end_ptr;\n     let rhs_end_ptr;\n     if ty::type_has_dynamic_size(bcx_tcx(cx), unit_ty) {\n-        lhs_end_ptr = copy_cx.build.InBoundsGEP(lhs_data, [lhs_len]);\n-        rhs_end_ptr = copy_cx.build.InBoundsGEP(rhs_data, [rhs_len]);\n+        lhs_end_ptr = bld::InBoundsGEP(copy_cx, lhs_data, [lhs_len]);\n+        rhs_end_ptr = bld::InBoundsGEP(copy_cx, rhs_data, [rhs_len]);\n     } else {\n-        let lhs_len_unscaled = copy_cx.build.UDiv(lhs_len, unit_sz);\n+        let lhs_len_unscaled = bld::UDiv(copy_cx, lhs_len, unit_sz);\n         lhs_end_ptr =\n-            copy_cx.build.InBoundsGEP(lhs_data, [lhs_len_unscaled]);\n-        let rhs_len_unscaled = copy_cx.build.UDiv(rhs_len, unit_sz);\n+            bld::InBoundsGEP(copy_cx, lhs_data, [lhs_len_unscaled]);\n+        let rhs_len_unscaled = bld::UDiv(copy_cx, rhs_len, unit_sz);\n         rhs_end_ptr =\n-            copy_cx.build.InBoundsGEP(rhs_data, [rhs_len_unscaled]);\n+            bld::InBoundsGEP(copy_cx, rhs_data, [rhs_len_unscaled]);\n     }\n \n     let dest_ptr_ptr = alloca(copy_cx, T_ptr(llunitty));\n-    copy_cx.build.Store(first_dest_ptr, dest_ptr_ptr);\n+    bld::Store(copy_cx, first_dest_ptr, dest_ptr_ptr);\n     let lhs_ptr_ptr = alloca(copy_cx, T_ptr(llunitty));\n-    copy_cx.build.Store(lhs_data, lhs_ptr_ptr);\n+    bld::Store(copy_cx, lhs_data, lhs_ptr_ptr);\n     let rhs_ptr_ptr = alloca(copy_cx, T_ptr(llunitty));\n-    copy_cx.build.Store(rhs_data, rhs_ptr_ptr);\n+    bld::Store(copy_cx, rhs_data, rhs_ptr_ptr);\n     let lhs_copy_cx = new_sub_block_ctxt(bcx, \"lhs_copy\");\n-    copy_cx.build.Br(lhs_copy_cx.llbb);\n+    bld::Br(copy_cx, lhs_copy_cx.llbb);\n     // Copy in elements from the LHS.\n \n-    let lhs_ptr = lhs_copy_cx.build.Load(lhs_ptr_ptr);\n+    let lhs_ptr = bld::Load(lhs_copy_cx, lhs_ptr_ptr);\n     let not_at_end_lhs =\n-        lhs_copy_cx.build.ICmp(lib::llvm::LLVMIntNE, lhs_ptr,\n+        bld::ICmp(lhs_copy_cx, lib::llvm::LLVMIntNE, lhs_ptr,\n                                lhs_end_ptr);\n     let lhs_do_copy_cx = new_sub_block_ctxt(bcx, \"lhs_do_copy\");\n     let rhs_copy_cx = new_sub_block_ctxt(bcx, \"rhs_copy\");\n-    lhs_copy_cx.build.CondBr(not_at_end_lhs, lhs_do_copy_cx.llbb,\n+    bld::CondBr(lhs_copy_cx, not_at_end_lhs, lhs_do_copy_cx.llbb,\n                              rhs_copy_cx.llbb);\n-    let dest_ptr_lhs_copy = lhs_do_copy_cx.build.Load(dest_ptr_ptr);\n+    let dest_ptr_lhs_copy = bld::Load(lhs_do_copy_cx, dest_ptr_ptr);\n     let lhs_val = load_if_immediate(lhs_do_copy_cx, lhs_ptr, unit_ty);\n     lhs_do_copy_cx = copy_val(lhs_do_copy_cx, INIT, dest_ptr_lhs_copy,\n                               lhs_val, unit_ty);\n@@ -671,17 +672,17 @@ fn trans_add(cx: &@block_ctxt, vec_ty: ty::t, lhs: ValueRef,\n         incr_ptr(lhs_do_copy_cx, lhs_ptr, C_int(1), lhs_ptr_ptr);\n     }\n \n-    lhs_do_copy_cx.build.Br(lhs_copy_cx.llbb);\n+    bld::Br(lhs_do_copy_cx, lhs_copy_cx.llbb);\n     // Copy in elements from the RHS.\n \n-    let rhs_ptr = rhs_copy_cx.build.Load(rhs_ptr_ptr);\n+    let rhs_ptr = bld::Load(rhs_copy_cx, rhs_ptr_ptr);\n     let not_at_end_rhs =\n-        rhs_copy_cx.build.ICmp(lib::llvm::LLVMIntNE, rhs_ptr,\n+        bld::ICmp(rhs_copy_cx, lib::llvm::LLVMIntNE, rhs_ptr,\n                                rhs_end_ptr);\n     let rhs_do_copy_cx = new_sub_block_ctxt(bcx, \"rhs_do_copy\");\n-    rhs_copy_cx.build.CondBr(not_at_end_rhs, rhs_do_copy_cx.llbb,\n+    bld::CondBr(rhs_copy_cx, not_at_end_rhs, rhs_do_copy_cx.llbb,\n                              next_cx.llbb);\n-    let dest_ptr_rhs_copy = rhs_do_copy_cx.build.Load(dest_ptr_ptr);\n+    let dest_ptr_rhs_copy = bld::Load(rhs_do_copy_cx, dest_ptr_ptr);\n     let rhs_val = load_if_immediate(rhs_do_copy_cx, rhs_ptr, unit_ty);\n     rhs_do_copy_cx = copy_val(rhs_do_copy_cx, INIT, dest_ptr_rhs_copy,\n                               rhs_val, unit_ty);\n@@ -698,7 +699,7 @@ fn trans_add(cx: &@block_ctxt, vec_ty: ty::t, lhs: ValueRef,\n         incr_ptr(rhs_do_copy_cx, rhs_ptr, C_int(1), rhs_ptr_ptr);\n     }\n \n-    rhs_do_copy_cx.build.Br(rhs_copy_cx.llbb);\n+    bld::Br(rhs_do_copy_cx, rhs_copy_cx.llbb);\n     // Finally done!\n \n     ret rslt(next_cx, llvecptr);\n@@ -712,49 +713,48 @@ fn duplicate_heap_part(cx: &@block_ctxt, orig_vptr: ValueRef,\n     // type.\n     let vptr;\n     if ty::type_has_dynamic_size(bcx_tcx(cx), unit_ty) {\n-        vptr = cx.build.PointerCast(orig_vptr, T_ptr(T_opaque_ivec()));\n+        vptr = bld::PointerCast(cx, orig_vptr, T_ptr(T_opaque_ivec()));\n     } else { vptr = orig_vptr; }\n \n     let llunitty = type_of_or_i8(cx, unit_ty);\n     let llheappartty = T_ivec_heap_part(llunitty);\n \n     // Check to see if the vector is heapified.\n     let stack_len_ptr =\n-        cx.build.InBoundsGEP(vptr, [C_int(0), C_uint(abi::ivec_elt_len)]);\n-    let stack_len = cx.build.Load(stack_len_ptr);\n+        bld::InBoundsGEP(cx, vptr, [C_int(0), C_uint(abi::ivec_elt_len)]);\n+    let stack_len = bld::Load(cx, stack_len_ptr);\n     let stack_len_is_zero =\n-        cx.build.ICmp(lib::llvm::LLVMIntEQ, stack_len, C_int(0));\n+        bld::ICmp(cx, lib::llvm::LLVMIntEQ, stack_len, C_int(0));\n     let maybe_on_heap_cx = new_sub_block_ctxt(cx, \"maybe_on_heap\");\n     let next_cx = new_sub_block_ctxt(cx, \"next\");\n-    cx.build.CondBr(stack_len_is_zero, maybe_on_heap_cx.llbb,\n+    bld::CondBr(cx, stack_len_is_zero, maybe_on_heap_cx.llbb,\n                     next_cx.llbb);\n \n     let stub_ptr =\n-        maybe_on_heap_cx.build.PointerCast(vptr,\n+        bld::PointerCast(maybe_on_heap_cx, vptr,\n                                            T_ptr(T_ivec_heap(llunitty)));\n     let heap_ptr_ptr =\n-        maybe_on_heap_cx.build.InBoundsGEP(\n+        bld::InBoundsGEP(maybe_on_heap_cx,\n             stub_ptr,\n             [C_int(0),\n              C_uint(abi::ivec_heap_stub_elt_ptr)]);\n-    let heap_ptr = maybe_on_heap_cx.build.Load(heap_ptr_ptr);\n+    let heap_ptr = bld::Load(maybe_on_heap_cx, heap_ptr_ptr);\n     let heap_ptr_is_nonnull =\n-        maybe_on_heap_cx.build.ICmp(lib::llvm::LLVMIntNE, heap_ptr,\n+        bld::ICmp(maybe_on_heap_cx, lib::llvm::LLVMIntNE, heap_ptr,\n                                     C_null(T_ptr(llheappartty)));\n     let on_heap_cx = new_sub_block_ctxt(cx, \"on_heap\");\n-    maybe_on_heap_cx.build.CondBr(heap_ptr_is_nonnull, on_heap_cx.llbb,\n+    bld::CondBr(maybe_on_heap_cx, heap_ptr_is_nonnull, on_heap_cx.llbb,\n                                   next_cx.llbb);\n \n     // Ok, the vector is on the heap. Copy the heap part.\n     let alen_ptr =\n-        on_heap_cx.build.InBoundsGEP(\n-            stub_ptr,\n+        bld::InBoundsGEP(on_heap_cx, stub_ptr,\n             [C_int(0),\n              C_uint(abi::ivec_heap_stub_elt_alen)]);\n-    let alen = on_heap_cx.build.Load(alen_ptr);\n+    let alen = bld::Load(on_heap_cx, alen_ptr);\n \n     let heap_part_sz =\n-        on_heap_cx.build.Add(alen, llsize_of(T_opaque_ivec_heap_part()));\n+        bld::Add(on_heap_cx, alen, llsize_of(T_opaque_ivec_heap_part()));\n     let rs =\n         trans_shared_malloc(on_heap_cx, T_ptr(llheappartty),\n                             heap_part_sz);\n@@ -764,8 +764,8 @@ fn duplicate_heap_part(cx: &@block_ctxt, orig_vptr: ValueRef,\n     rs = call_memmove(on_heap_cx, new_heap_ptr, heap_ptr, heap_part_sz);\n     on_heap_cx = rs.bcx;\n \n-    on_heap_cx.build.Store(new_heap_ptr, heap_ptr_ptr);\n-    on_heap_cx.build.Br(next_cx.llbb);\n+    bld::Store(on_heap_cx, new_heap_ptr, heap_ptr_ptr);\n+    bld::Br(on_heap_cx, next_cx.llbb);\n \n     ret rslt(next_cx, C_nil());\n }"}, {"sha": "5b29b111b6df402db612087378d1cb9d341c0971", "filename": "src/comp/middle/trans_objects.rs", "status": "modified", "additions": 53, "deletions": 53, "changes": 106, "blob_url": "https://github.com/rust-lang/rust/blob/b9112525ba27d46e056dcab303c27bb43073c4fc/src%2Fcomp%2Fmiddle%2Ftrans_objects.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b9112525ba27d46e056dcab303c27bb43073c4fc/src%2Fcomp%2Fmiddle%2Ftrans_objects.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans_objects.rs?ref=b9112525ba27d46e056dcab303c27bb43073c4fc", "patch": "@@ -20,6 +20,7 @@ import syntax::codemap::span;\n \n import trans_common::*;\n import trans::*;\n+import bld = trans_build;\n \n export trans_anon_obj;\n export trans_obj;\n@@ -78,17 +79,17 @@ fn trans_obj(cx: @local_ctxt, sp: &span, ob: &ast::_obj,\n     // abi::obj_field_vtbl and abi::obj_field_box simply specify words 0 and 1\n     // of 'pair'.\n     let pair_vtbl =\n-        bcx.build.GEP(pair, [C_int(0), C_int(abi::obj_field_vtbl)]);\n-    let pair_box = bcx.build.GEP(pair, [C_int(0), C_int(abi::obj_field_box)]);\n+        bld::GEP(bcx, pair, [C_int(0), C_int(abi::obj_field_vtbl)]);\n+    let pair_box = bld::GEP(bcx, pair, [C_int(0), C_int(abi::obj_field_box)]);\n \n     // Make a vtable for this object: a static array of pointers to functions.\n     // It will be located in the read-only memory of the executable we're\n     // creating and will contain ValueRefs for all of this object's methods.\n     // create_vtbl returns a pointer to the vtable, which we store.\n     let vtbl = create_vtbl(cx, sp, self_ty, ob, ty_params, none, []);\n-    vtbl = bcx.build.PointerCast(vtbl, T_ptr(T_empty_struct()));\n+    vtbl = bld::PointerCast(bcx, vtbl, T_ptr(T_empty_struct()));\n \n-    bcx.build.Store(vtbl, pair_vtbl);\n+    bld::Store(bcx, vtbl, pair_vtbl);\n \n     // Next we have to take care of the other half of the pair we're\n     // returning: a boxed (reference-counted) tuple containing a tydesc,\n@@ -101,7 +102,7 @@ fn trans_obj(cx: @local_ctxt, sp: &span, ob: &ast::_obj,\n         // there's not much to do.\n \n         // Store null into pair, if no args or typarams.\n-        bcx.build.Store(C_null(llbox_ty), pair_box);\n+        bld::Store(bcx, C_null(llbox_ty), pair_box);\n     } else {\n         let obj_fields: [ty::t] = [];\n         for a: ty::arg in arg_tys { obj_fields += [a.ty]; }\n@@ -136,7 +137,7 @@ fn trans_obj(cx: @local_ctxt, sp: &span, ob: &ast::_obj,\n         lazily_emit_tydesc_glue(bcx, abi::tydesc_field_drop_glue, ti);\n         lazily_emit_tydesc_glue(bcx, abi::tydesc_field_free_glue, ti);\n         bcx = body_td.bcx;\n-        bcx.build.Store(body_td.val, body_tydesc.val);\n+        bld::Store(bcx, body_td.val, body_tydesc.val);\n \n         // Copy the object's type parameters and fields into the space we\n         // allocated for the object body.  (This is something like saving the\n@@ -186,8 +187,8 @@ fn trans_obj(cx: @local_ctxt, sp: &span, ob: &ast::_obj,\n         }\n \n         // Store box ptr in outer pair.\n-        let p = bcx.build.PointerCast(box.box, llbox_ty);\n-        bcx.build.Store(p, pair_box);\n+        let p = bld::PointerCast(bcx, box.box, llbox_ty);\n+        bld::Store(bcx, p, pair_box);\n     }\n     build_return(bcx);\n \n@@ -280,11 +281,11 @@ fn trans_anon_obj(bcx: @block_ctxt, sp: &span, anon_obj: &ast::anon_obj,\n \n     // Grab onto the first and second elements of the pair.\n     let pair_vtbl =\n-        bcx.build.GEP(pair, [C_int(0), C_int(abi::obj_field_vtbl)]);\n-    let pair_box = bcx.build.GEP(pair, [C_int(0), C_int(abi::obj_field_box)]);\n+        bld::GEP(bcx, pair, [C_int(0), C_int(abi::obj_field_vtbl)]);\n+    let pair_box = bld::GEP(bcx, pair, [C_int(0), C_int(abi::obj_field_box)]);\n \n-    vtbl = bcx.build.PointerCast(vtbl, T_ptr(T_empty_struct()));\n-    bcx.build.Store(vtbl, pair_vtbl);\n+    vtbl = bld::PointerCast(bcx, vtbl, T_ptr(T_empty_struct()));\n+    bld::Store(bcx, vtbl, pair_vtbl);\n \n     // Next we have to take care of the other half of the pair we're\n     // returning: a boxed (reference-counted) tuple containing a tydesc,\n@@ -296,7 +297,7 @@ fn trans_anon_obj(bcx: @block_ctxt, sp: &span, anon_obj: &ast::anon_obj,\n \n         // If the object we're translating has no fields and no inner_obj,\n         // there's not much to do.\n-        bcx.build.Store(C_null(llbox_ty), pair_box);\n+        bld::Store(bcx, C_null(llbox_ty), pair_box);\n \n     } else {\n \n@@ -326,7 +327,7 @@ fn trans_anon_obj(bcx: @block_ctxt, sp: &span, anon_obj: &ast::anon_obj,\n         lazily_emit_tydesc_glue(bcx, abi::tydesc_field_drop_glue, ti);\n         lazily_emit_tydesc_glue(bcx, abi::tydesc_field_free_glue, ti);\n         bcx = body_td.bcx;\n-        bcx.build.Store(body_td.val, body_tydesc.val);\n+        bld::Store(bcx, body_td.val, body_tydesc.val);\n \n         // Copy the object's fields into the space we allocated for the object\n         // body.  (This is something like saving the lexical environment of a\n@@ -370,8 +371,8 @@ fn trans_anon_obj(bcx: @block_ctxt, sp: &span, anon_obj: &ast::anon_obj,\n         }\n \n         // Store box ptr in outer pair.\n-        let p = bcx.build.PointerCast(box.box, llbox_ty);\n-        bcx.build.Store(p, pair_box);\n+        let p = bld::PointerCast(bcx, box.box, llbox_ty);\n+        bld::Store(bcx, p, pair_box);\n     }\n \n     // return the object we built.\n@@ -618,24 +619,23 @@ fn process_bkwding_mthd(cx: @local_ctxt, sp: &span, m: @ty::method,\n \n     // Cast to self-stack's type.\n     let llenv =\n-        bcx.build.PointerCast(\n-            fcx.llenv,\n+        bld::PointerCast(bcx, fcx.llenv,\n             T_ptr(T_struct([cx.ccx.rust_object_type,\n                             T_ptr(cx.ccx.rust_object_type)])));\n-    let llself_obj_ptr = bcx.build.GEP(llenv, [C_int(0), C_int(1)]);\n-    llself_obj_ptr = bcx.build.Load(llself_obj_ptr);\n+    let llself_obj_ptr = bld::GEP(bcx, llenv, [C_int(0), C_int(1)]);\n+    llself_obj_ptr = bld::Load(bcx, llself_obj_ptr);\n \n     // Cast it back to pointer-to-object-type, so LLVM won't complain.\n     llself_obj_ptr =\n-        bcx.build.PointerCast(llself_obj_ptr, T_ptr(cx.ccx.rust_object_type));\n+        bld::PointerCast(bcx, llself_obj_ptr, T_ptr(cx.ccx.rust_object_type));\n \n     // The 'llretptr' that will arrive in the backwarding function we're\n     // creating also needs to be the correct type.  Cast it to the method's\n     // return type, if necessary.\n     let llretptr = fcx.llretptr;\n     if ty::type_contains_params(cx.ccx.tcx, m.output) {\n         let llretty = type_of_inner(cx.ccx, sp, m.output);\n-        llretptr = bcx.build.PointerCast(llretptr, T_ptr(llretty));\n+        llretptr = bld::PointerCast(bcx, llretptr, T_ptr(llretty));\n     }\n \n     // Get the index of the method we want.\n@@ -655,12 +655,12 @@ fn process_bkwding_mthd(cx: @local_ctxt, sp: &span, m: @ty::method,\n     let vtbl_type = T_ptr(T_array(T_ptr(T_nil()), ix + 1u));\n \n     let llouter_obj_vtbl =\n-        bcx.build.GEP(llself_obj_ptr, [C_int(0), C_int(abi::obj_field_vtbl)]);\n-    llouter_obj_vtbl = bcx.build.Load(llouter_obj_vtbl);\n-    llouter_obj_vtbl = bcx.build.PointerCast(llouter_obj_vtbl, vtbl_type);\n+        bld::GEP(bcx, llself_obj_ptr, [C_int(0), C_int(abi::obj_field_vtbl)]);\n+    llouter_obj_vtbl = bld::Load(bcx, llouter_obj_vtbl);\n+    llouter_obj_vtbl = bld::PointerCast(bcx, llouter_obj_vtbl, vtbl_type);\n \n     let llouter_mthd =\n-        bcx.build.GEP(llouter_obj_vtbl, [C_int(0), C_int(ix as int)]);\n+        bld::GEP(bcx, llouter_obj_vtbl, [C_int(0), C_int(ix as int)]);\n \n     // Set up the outer method to be called.\n     let outer_mthd_ty = ty::method_ty_to_fn_ty(cx.ccx.tcx, *m);\n@@ -670,8 +670,8 @@ fn process_bkwding_mthd(cx: @local_ctxt, sp: &span, m: @ty::method,\n                         m.inputs, m.output,\n                         std::vec::len::<ast::ty_param>(ty_params));\n     llouter_mthd =\n-        bcx.build.PointerCast(llouter_mthd, T_ptr(T_ptr(llouter_mthd_ty)));\n-    llouter_mthd = bcx.build.Load(llouter_mthd);\n+        bld::PointerCast(bcx, llouter_mthd, T_ptr(T_ptr(llouter_mthd_ty)));\n+    llouter_mthd = bld::Load(bcx, llouter_mthd);\n \n     // Set up the three implicit arguments to the outer method we'll need to\n     // call.\n@@ -692,7 +692,7 @@ fn process_bkwding_mthd(cx: @local_ctxt, sp: &span, m: @ty::method,\n     }\n \n     // And, finally, call the outer method.\n-    bcx.build.FastCall(llouter_mthd, llouter_mthd_args);\n+    bld::FastCall(bcx, llouter_mthd, llouter_mthd_args);\n \n     build_return(bcx);\n     finish_fn(fcx, lltop);\n@@ -751,7 +751,7 @@ fn process_fwding_mthd(cx: @local_ctxt, sp: &span, m: @ty::method,\n     let llretptr = fcx.llretptr;\n     if ty::type_contains_params(cx.ccx.tcx, m.output) {\n         let llretty = type_of_inner(cx.ccx, sp, m.output);\n-        llretptr = bcx.build.PointerCast(llretptr, T_ptr(llretty));\n+        llretptr = bld::PointerCast(bcx, llretptr, T_ptr(llretty));\n     }\n \n     // Now, we have to get the the inner_obj's vtbl out of the self_obj.  This\n@@ -760,16 +760,16 @@ fn process_fwding_mthd(cx: @local_ctxt, sp: &span, m: @ty::method,\n     // First, grab the box out of the self_obj.  It contains a refcount and a\n     // body.\n     let llself_obj_box =\n-        bcx.build.GEP(llself_obj_ptr, [C_int(0), C_int(abi::obj_field_box)]);\n-    llself_obj_box = bcx.build.Load(llself_obj_box);\n+        bld::GEP(bcx, llself_obj_ptr, [C_int(0), C_int(abi::obj_field_box)]);\n+    llself_obj_box = bld::Load(bcx, llself_obj_box);\n \n     let ccx = bcx_ccx(bcx);\n     let llbox_ty = T_opaque_obj_ptr(*ccx);\n-    llself_obj_box = bcx.build.PointerCast(llself_obj_box, llbox_ty);\n+    llself_obj_box = bld::PointerCast(bcx, llself_obj_box, llbox_ty);\n \n     // Now, reach into the box and grab the body.\n     let llself_obj_body =\n-        bcx.build.GEP(llself_obj_box,\n+        bld::GEP(bcx, llself_obj_box,\n                       [C_int(0), C_int(abi::box_rc_field_body)]);\n \n     // Now, we need to figure out exactly what type the body is supposed to be\n@@ -779,7 +779,7 @@ fn process_fwding_mthd(cx: @local_ctxt, sp: &span, m: @ty::method,\n                                 some(inner_obj_ty));\n     // And cast to that type.\n     llself_obj_body =\n-        bcx.build.PointerCast(llself_obj_body,\n+        bld::PointerCast(bcx, llself_obj_body,\n                               T_ptr(type_of(cx.ccx, sp, body_ty)));\n \n     // Now, reach into the body and grab the inner_obj.\n@@ -793,13 +793,13 @@ fn process_fwding_mthd(cx: @local_ctxt, sp: &span, m: @ty::method,\n     // method's entry out of the vtable so that the forwarding function can\n     // call it.\n     let llinner_obj_vtbl =\n-        bcx.build.GEP(llinner_obj.val,\n+        bld::GEP(bcx, llinner_obj.val,\n                       [C_int(0), C_int(abi::obj_field_vtbl)]);\n-    llinner_obj_vtbl = bcx.build.Load(llinner_obj_vtbl);\n+    llinner_obj_vtbl = bld::Load(bcx, llinner_obj_vtbl);\n \n     let llinner_obj_body =\n-        bcx.build.GEP(llinner_obj.val, [C_int(0), C_int(abi::obj_field_box)]);\n-    llinner_obj_body = bcx.build.Load(llinner_obj_body);\n+        bld::GEP(bcx, llinner_obj.val, [C_int(0), C_int(abi::obj_field_box)]);\n+    llinner_obj_body = bld::Load(bcx, llinner_obj_body);\n \n     // Get the index of the method we want.\n     let ix: uint = 0u;\n@@ -816,10 +816,10 @@ fn process_fwding_mthd(cx: @local_ctxt, sp: &span, m: @ty::method,\n \n     // Pick out the original method from the vtable.\n     let vtbl_type = T_ptr(T_array(T_ptr(T_nil()), ix + 1u));\n-    llinner_obj_vtbl = bcx.build.PointerCast(llinner_obj_vtbl, vtbl_type);\n+    llinner_obj_vtbl = bld::PointerCast(bcx, llinner_obj_vtbl, vtbl_type);\n \n     let llorig_mthd =\n-        bcx.build.GEP(llinner_obj_vtbl, [C_int(0), C_int(ix as int)]);\n+        bld::GEP(bcx, llinner_obj_vtbl, [C_int(0), C_int(ix as int)]);\n \n     // Set up the original method to be called.\n     let orig_mthd_ty = ty::method_ty_to_fn_ty(cx.ccx.tcx, *m);\n@@ -829,8 +829,8 @@ fn process_fwding_mthd(cx: @local_ctxt, sp: &span, m: @ty::method,\n                         m.inputs, m.output,\n                         std::vec::len::<ast::ty_param>(ty_params));\n     llorig_mthd =\n-        bcx.build.PointerCast(llorig_mthd, T_ptr(T_ptr(llorig_mthd_ty)));\n-    llorig_mthd = bcx.build.Load(llorig_mthd);\n+        bld::PointerCast(bcx, llorig_mthd, T_ptr(T_ptr(llorig_mthd_ty)));\n+    llorig_mthd = bld::Load(bcx, llorig_mthd);\n \n     // Set up the self-stack.\n     let self_stack =\n@@ -843,7 +843,7 @@ fn process_fwding_mthd(cx: @local_ctxt, sp: &span, m: @ty::method,\n \n     // Cast self_stack back to pointer-to-object-type to make LLVM happy.\n     self_stack =\n-        bcx.build.PointerCast(self_stack, T_ptr(cx.ccx.rust_object_type));\n+        bld::PointerCast(bcx, self_stack, T_ptr(cx.ccx.rust_object_type));\n \n     // Set up the three implicit arguments to the original method we'll need\n     // to call.\n@@ -863,7 +863,7 @@ fn process_fwding_mthd(cx: @local_ctxt, sp: &span, m: @ty::method,\n     }\n \n     // And, finally, call the original (inner) method.\n-    bcx.build.FastCall(llorig_mthd, llorig_mthd_args);\n+    bld::FastCall(bcx, llorig_mthd, llorig_mthd_args);\n \n     build_return(bcx);\n     finish_fn(fcx, lltop);\n@@ -939,19 +939,19 @@ fn populate_self_stack(bcx: @block_ctxt, self_stack: ValueRef,\n                        inner_obj_body: ValueRef) -> ValueRef {\n \n     // Drop the outer obj into the second slot.\n-    let self_pair_ptr = bcx.build.GEP(self_stack, [C_int(0), C_int(1)]);\n-    bcx.build.Store(outer_obj, self_pair_ptr);\n+    let self_pair_ptr = bld::GEP(bcx, self_stack, [C_int(0), C_int(1)]);\n+    bld::Store(bcx, outer_obj, self_pair_ptr);\n \n     // Drop in the backwarding vtbl.\n-    let wrapper_pair = bcx.build.GEP(self_stack, [C_int(0), C_int(0)]);\n-    let wrapper_vtbl_ptr = bcx.build.GEP(wrapper_pair, [C_int(0), C_int(0)]);\n+    let wrapper_pair = bld::GEP(bcx, self_stack, [C_int(0), C_int(0)]);\n+    let wrapper_vtbl_ptr = bld::GEP(bcx, wrapper_pair, [C_int(0), C_int(0)]);\n     let backwarding_vtbl_cast =\n-        bcx.build.PointerCast(backwarding_vtbl, T_ptr(T_empty_struct()));\n-    bcx.build.Store(backwarding_vtbl_cast, wrapper_vtbl_ptr);\n+        bld::PointerCast(bcx, backwarding_vtbl, T_ptr(T_empty_struct()));\n+    bld::Store(bcx, backwarding_vtbl_cast, wrapper_vtbl_ptr);\n \n     // Drop in the inner obj body.\n-    let wrapper_body_ptr = bcx.build.GEP(wrapper_pair, [C_int(0), C_int(1)]);\n-    bcx.build.Store(inner_obj_body, wrapper_body_ptr);\n+    let wrapper_body_ptr = bld::GEP(bcx, wrapper_pair, [C_int(0), C_int(1)]);\n+    bld::Store(bcx, inner_obj_body, wrapper_body_ptr);\n \n     ret self_stack;\n }"}, {"sha": "c9f0d2f067b9cb817ca6aaf37b14b9ced7986539", "filename": "src/comp/rustc.rc", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/b9112525ba27d46e056dcab303c27bb43073c4fc/src%2Fcomp%2Frustc.rc", "raw_url": "https://github.com/rust-lang/rust/raw/b9112525ba27d46e056dcab303c27bb43073c4fc/src%2Fcomp%2Frustc.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Frustc.rc?ref=b9112525ba27d46e056dcab303c27bb43073c4fc", "patch": "@@ -15,6 +15,7 @@ use std (name = \"std\",\n \n mod middle {\n     mod trans_common;\n+    mod trans_build;\n     mod trans;\n     mod trans_alt;\n     mod trans_objects;"}]}