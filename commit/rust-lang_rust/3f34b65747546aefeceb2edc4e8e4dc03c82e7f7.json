{"sha": "3f34b65747546aefeceb2edc4e8e4dc03c82e7f7", "node_id": "MDY6Q29tbWl0NzI0NzEyOjNmMzRiNjU3NDc1NDZhZWZlY2ViMmVkYzRlOGU0ZGMwM2M4MmU3Zjc=", "commit": {"author": {"name": "Oliver 'ker' Schneider", "email": "git-spam-no-reply9815368754983@oli-obk.de", "date": "2016-02-12T17:35:44Z"}, "committer": {"name": "Oliver 'ker' Schneider", "email": "git-spam-no-reply9815368754983@oli-obk.de", "date": "2016-02-12T17:35:44Z"}, "message": "fix nightly breakage", "tree": {"sha": "8c64dcbd1fb2787538f3a71622e3b132e1fbaf34", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8c64dcbd1fb2787538f3a71622e3b132e1fbaf34"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3f34b65747546aefeceb2edc4e8e4dc03c82e7f7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3f34b65747546aefeceb2edc4e8e4dc03c82e7f7", "html_url": "https://github.com/rust-lang/rust/commit/3f34b65747546aefeceb2edc4e8e4dc03c82e7f7", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3f34b65747546aefeceb2edc4e8e4dc03c82e7f7/comments", "author": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "committer": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d305bca25bf4c560faaa030c069364d46739e255", "url": "https://api.github.com/repos/rust-lang/rust/commits/d305bca25bf4c560faaa030c069364d46739e255", "html_url": "https://github.com/rust-lang/rust/commit/d305bca25bf4c560faaa030c069364d46739e255"}], "stats": {"total": 462, "additions": 202, "deletions": 260}, "files": [{"sha": "9a0b0b37bae14803b7c9bceff554593a50bb3522", "filename": "Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3f34b65747546aefeceb2edc4e8e4dc03c82e7f7/Cargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/3f34b65747546aefeceb2edc4e8e4dc03c82e7f7/Cargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.toml?ref=3f34b65747546aefeceb2edc4e8e4dc03c82e7f7", "patch": "@@ -24,7 +24,7 @@ regex-syntax = \"0.2.2\"\n [dev-dependencies]\n compiletest_rs = \"0.0.11\"\n regex = \"0.1.47\"\n-regex_macros = \"0.1.27\"\n+regex_macros = \"0.1.28\"\n lazy_static = \"0.1.15\"\n rustc-serialize = \"0.3\"\n "}, {"sha": "b1a335844426ed51e46369bb4b7ea02249c2308f", "filename": "src/approx_const.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/3f34b65747546aefeceb2edc4e8e4dc03c82e7f7/src%2Fapprox_const.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f34b65747546aefeceb2edc4e8e4dc03c82e7f7/src%2Fapprox_const.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fapprox_const.rs?ref=3f34b65747546aefeceb2edc4e8e4dc03c82e7f7", "patch": "@@ -2,7 +2,7 @@ use rustc::lint::*;\n use rustc_front::hir::*;\n use std::f64::consts as f64;\n use utils::span_lint;\n-use syntax::ast::{Lit, Lit_, FloatTy};\n+use syntax::ast::{Lit, LitKind, FloatTy};\n \n /// **What it does:** This lint checks for floating point literals that approximate constants which are defined in [`std::f32::consts`](https://doc.rust-lang.org/stable/std/f32/consts/#constants) or [`std::f64::consts`](https://doc.rust-lang.org/stable/std/f64/consts/#constants), respectively, suggesting to use the predefined constant.\n ///\n@@ -55,9 +55,9 @@ impl LateLintPass for ApproxConstant {\n \n fn check_lit(cx: &LateContext, lit: &Lit, e: &Expr) {\n     match lit.node {\n-        Lit_::LitFloat(ref s, FloatTy::TyF32) => check_known_consts(cx, e, s, \"f32\"),\n-        Lit_::LitFloat(ref s, FloatTy::TyF64) => check_known_consts(cx, e, s, \"f64\"),\n-        Lit_::LitFloatUnsuffixed(ref s) => check_known_consts(cx, e, s, \"f{32, 64}\"),\n+        LitKind::Float(ref s, FloatTy::F32) => check_known_consts(cx, e, s, \"f32\"),\n+        LitKind::Float(ref s, FloatTy::F64) => check_known_consts(cx, e, s, \"f64\"),\n+        LitKind::FloatUnsuffixed(ref s) => check_known_consts(cx, e, s, \"f{32, 64}\"),\n         _ => (),\n     }\n }"}, {"sha": "fda46724862e03c4513bb1a8726abf2f10033f59", "filename": "src/attrs.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/3f34b65747546aefeceb2edc4e8e4dc03c82e7f7/src%2Fattrs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f34b65747546aefeceb2edc4e8e4dc03c82e7f7/src%2Fattrs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fattrs.rs?ref=3f34b65747546aefeceb2edc4e8e4dc03c82e7f7", "patch": "@@ -6,7 +6,7 @@ use reexport::*;\n use semver::Version;\n use syntax::codemap::Span;\n use syntax::attr::*;\n-use syntax::ast::{Attribute, Lit, Lit_, MetaList, MetaWord, MetaNameValue};\n+use syntax::ast::{Attribute, Lit, LitKind, MetaItemKind};\n use utils::{in_macro, match_path, span_lint, BEGIN_UNWIND};\n \n /// **What it does:** This lint checks for items annotated with `#[inline(always)]`, unless the annotated function is empty or simply panics.\n@@ -54,12 +54,12 @@ impl LintPass for AttrPass {\n \n impl LateLintPass for AttrPass {\n     fn check_attribute(&mut self, cx: &LateContext, attr: &Attribute) {\n-        if let MetaList(ref name, ref items) = attr.node.value.node {\n+        if let MetaItemKind::List(ref name, ref items) = attr.node.value.node {\n             if items.is_empty() || name != &\"deprecated\" {\n                 return;\n             }\n             for ref item in items {\n-                if let MetaNameValue(ref name, ref lit) = item.node {\n+                if let MetaItemKind::NameValue(ref name, ref lit) = item.node {\n                     if name == &\"since\" {\n                         check_semver(cx, item.span, lit);\n                     }\n@@ -144,11 +144,11 @@ fn check_attrs(cx: &LateContext, span: Span, name: &Name, attrs: &[Attribute]) {\n     }\n \n     for attr in attrs {\n-        if let MetaList(ref inline, ref values) = attr.node.value.node {\n+        if let MetaItemKind::List(ref inline, ref values) = attr.node.value.node {\n             if values.len() != 1 || inline != &\"inline\" {\n                 continue;\n             }\n-            if let MetaWord(ref always) = values[0].node {\n+            if let MetaItemKind::Word(ref always) = values[0].node {\n                 if always != &\"always\" {\n                     continue;\n                 }\n@@ -163,7 +163,7 @@ fn check_attrs(cx: &LateContext, span: Span, name: &Name, attrs: &[Attribute]) {\n }\n \n fn check_semver(cx: &LateContext, span: Span, lit: &Lit) {\n-    if let Lit_::LitStr(ref is, _) = lit.node {\n+    if let LitKind::Str(ref is, _) = lit.node {\n         if Version::parse(&*is).is_ok() {\n             return;\n         }"}, {"sha": "e1366924e1dec9b92032a771532c2f17e7e4afe3", "filename": "src/bit_mask.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3f34b65747546aefeceb2edc4e8e4dc03c82e7f7/src%2Fbit_mask.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f34b65747546aefeceb2edc4e8e4dc03c82e7f7/src%2Fbit_mask.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbit_mask.rs?ref=3f34b65747546aefeceb2edc4e8e4dc03c82e7f7", "patch": "@@ -4,7 +4,7 @@ use rustc::middle::def::{Def, PathResolution};\n use rustc_front::hir::*;\n use rustc_front::util::is_comparison_binop;\n use syntax::codemap::Span;\n-use syntax::ast::Lit_;\n+use syntax::ast::LitKind;\n \n use utils::span_lint;\n \n@@ -254,7 +254,7 @@ fn check_ineffective_gt(cx: &LateContext, span: Span, m: u64, c: u64, op: &str)\n fn fetch_int_literal(cx: &LateContext, lit: &Expr) -> Option<u64> {\n     match lit.node {\n         ExprLit(ref lit_ptr) => {\n-            if let Lit_::LitInt(value, _) = lit_ptr.node {\n+            if let LitKind::Int(value, _) = lit_ptr.node {\n                 Some(value) //TODO: Handle sign\n             } else {\n                 None"}, {"sha": "5ff0591e02d8030dc507a321af36c200277203f1", "filename": "src/consts.rs", "status": "modified", "additions": 88, "deletions": 145, "changes": 233, "blob_url": "https://github.com/rust-lang/rust/blob/3f34b65747546aefeceb2edc4e8e4dc03c82e7f7/src%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f34b65747546aefeceb2edc4e8e4dc03c82e7f7/src%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fconsts.rs?ref=3f34b65747546aefeceb2edc4e8e4dc03c82e7f7", "patch": "@@ -11,10 +11,9 @@ use std::cmp::Ordering::{self, Greater, Less, Equal};\n use std::rc::Rc;\n use std::ops::Deref;\n \n-use syntax::ast::Lit_;\n+use syntax::ast::LitKind;\n use syntax::ast::LitIntType;\n use syntax::ast::{UintTy, FloatTy, StrStyle};\n-use syntax::ast::Sign::{self, Plus, Minus};\n \n \n #[derive(PartialEq, Eq, Debug, Copy, Clone)]\n@@ -27,12 +26,18 @@ pub enum FloatWidth {\n impl From<FloatTy> for FloatWidth {\n     fn from(ty: FloatTy) -> FloatWidth {\n         match ty {\n-            FloatTy::TyF32 => FloatWidth::Fw32,\n-            FloatTy::TyF64 => FloatWidth::Fw64,\n+            FloatTy::F32 => FloatWidth::Fw32,\n+            FloatTy::F64 => FloatWidth::Fw64,\n         }\n     }\n }\n \n+#[derive(Copy, Eq, Debug, Clone, PartialEq)]\n+pub enum Sign {\n+    Plus,\n+    Minus,\n+}\n+\n /// a Lit_-like enum to fold constant `Expr`s into\n #[derive(Eq, Debug, Clone)]\n pub enum Constant {\n@@ -44,8 +49,8 @@ pub enum Constant {\n     Byte(u8),\n     /// a single char 'a'\n     Char(char),\n-    /// an integer\n-    Int(u64, LitIntType),\n+    /// an integer, third argument is whether the value is negated\n+    Int(u64, LitIntType, Sign),\n     /// a float with given type\n     Float(String, FloatWidth),\n     /// true or false\n@@ -65,7 +70,7 @@ impl Constant {\n     ///\n     /// if the constant could not be converted to u64 losslessly\n     fn as_u64(&self) -> u64 {\n-        if let Constant::Int(val, _) = *self {\n+        if let Constant::Int(val, _, _) = *self {\n             val // TODO we may want to check the sign if any\n         } else {\n             panic!(\"Could not convert a {:?} to u64\", self);\n@@ -78,13 +83,8 @@ impl Constant {\n         match *self {\n             Constant::Byte(b) => Some(b as f64),\n             Constant::Float(ref s, _) => s.parse().ok(),\n-            Constant::Int(i, ty) => {\n-                Some(if is_negative(ty) {\n-                    -(i as f64)\n-                } else {\n-                    i as f64\n-                })\n-            }\n+            Constant::Int(i, _, Sign::Minus) => Some(-(i as f64)),\n+            Constant::Int(i, _, Sign::Plus) => Some(i as f64),\n             _ => None,\n         }\n     }\n@@ -97,8 +97,9 @@ impl PartialEq for Constant {\n             (&Constant::Binary(ref l), &Constant::Binary(ref r)) => l == r,\n             (&Constant::Byte(l), &Constant::Byte(r)) => l == r,\n             (&Constant::Char(l), &Constant::Char(r)) => l == r,\n-            (&Constant::Int(lv, lty), &Constant::Int(rv, rty)) => {\n-                lv == rv && (is_negative(lty) & (lv != 0)) == (is_negative(rty) & (rv != 0))\n+            (&Constant::Int(0, _, _), &Constant::Int(0, _, _)) => true,\n+            (&Constant::Int(lv, _, lneg), &Constant::Int(rv, _, rneg)) => {\n+                lv == rv && lneg == rneg\n             }\n             (&Constant::Float(ref ls, lw), &Constant::Float(ref rs, rw)) => {\n                 use self::FloatWidth::*;\n@@ -135,14 +136,11 @@ impl PartialOrd for Constant {\n             }\n             (&Constant::Byte(ref l), &Constant::Byte(ref r)) => Some(l.cmp(r)),\n             (&Constant::Char(ref l), &Constant::Char(ref r)) => Some(l.cmp(r)),\n-            (&Constant::Int(ref lv, lty), &Constant::Int(ref rv, rty)) => {\n-                Some(match (is_negative(lty) && *lv != 0, is_negative(rty) && *rv != 0) {\n-                    (true, true) => rv.cmp(lv),\n-                    (false, false) => lv.cmp(rv),\n-                    (true, false) => Less,\n-                    (false, true) => Greater,\n-                })\n-            }\n+            (&Constant::Int(0, _, _), &Constant::Int(0, _, _)) => Some(Equal),\n+            (&Constant::Int(ref lv, _, Sign::Plus), &Constant::Int(ref rv, _, Sign::Plus)) => Some(lv.cmp(rv)),\n+            (&Constant::Int(ref lv, _, Sign::Minus), &Constant::Int(ref rv, _, Sign::Minus)) => Some(rv.cmp(lv)),\n+            (&Constant::Int(_, _, Sign::Minus), &Constant::Int(_, _, Sign::Plus)) => Some(Less),\n+            (&Constant::Int(_, _, Sign::Plus), &Constant::Int(_, _, Sign::Minus)) => Some(Greater),\n             (&Constant::Float(ref ls, lw), &Constant::Float(ref rs, rw)) => {\n                 use self::FloatWidth::*;\n                 if match (lw, rw) {\n@@ -171,16 +169,16 @@ impl PartialOrd for Constant {\n     }\n }\n \n-fn lit_to_constant(lit: &Lit_) -> Constant {\n+fn lit_to_constant(lit: &LitKind) -> Constant {\n     match *lit {\n-        Lit_::LitStr(ref is, style) => Constant::Str(is.to_string(), style),\n-        Lit_::LitByte(b) => Constant::Byte(b),\n-        Lit_::LitByteStr(ref s) => Constant::Binary(s.clone()),\n-        Lit_::LitChar(c) => Constant::Char(c),\n-        Lit_::LitInt(value, ty) => Constant::Int(value, ty),\n-        Lit_::LitFloat(ref is, ty) => Constant::Float(is.to_string(), ty.into()),\n-        Lit_::LitFloatUnsuffixed(ref is) => Constant::Float(is.to_string(), FloatWidth::FwAny),\n-        Lit_::LitBool(b) => Constant::Bool(b),\n+        LitKind::Str(ref is, style) => Constant::Str(is.to_string(), style),\n+        LitKind::Byte(b) => Constant::Byte(b),\n+        LitKind::ByteStr(ref s) => Constant::Binary(s.clone()),\n+        LitKind::Char(c) => Constant::Char(c),\n+        LitKind::Int(value, ty) => Constant::Int(value, ty, Sign::Plus),\n+        LitKind::Float(ref is, ty) => Constant::Float(is.to_string(), ty.into()),\n+        LitKind::FloatUnsuffixed(ref is) => Constant::Float(is.to_string(), FloatWidth::FwAny),\n+        LitKind::Bool(b) => Constant::Bool(b),\n     }\n }\n \n@@ -189,21 +187,21 @@ fn constant_not(o: Constant) -> Option<Constant> {\n     use self::Constant::*;\n     match o {\n         Bool(b) => Some(Bool(!b)),\n-        Int(::std::u64::MAX, SignedIntLit(_, Plus)) => None,\n-        Int(value, SignedIntLit(ity, Plus)) => Some(Int(value + 1, SignedIntLit(ity, Minus))),\n-        Int(0, SignedIntLit(ity, Minus)) => Some(Int(1, SignedIntLit(ity, Minus))),\n-        Int(value, SignedIntLit(ity, Minus)) => Some(Int(value - 1, SignedIntLit(ity, Plus))),\n-        Int(value, UnsignedIntLit(ity)) => {\n+        Int(::std::u64::MAX, LitIntType::Signed(_), Sign::Plus) => None,\n+        Int(value, LitIntType::Signed(ity), Sign::Plus) => Some(Int(value + 1, LitIntType::Signed(ity), Sign::Minus)),\n+        Int(0, LitIntType::Signed(ity), Sign::Minus) => Some(Int(1, LitIntType::Signed(ity), Sign::Minus)),\n+        Int(value, LitIntType::Signed(ity), Sign::Minus) => Some(Int(value - 1, LitIntType::Signed(ity), Sign::Plus)),\n+        Int(value, LitIntType::Unsigned(ity), Sign::Plus) => {\n             let mask = match ity {\n-                UintTy::TyU8 => ::std::u8::MAX as u64,\n-                UintTy::TyU16 => ::std::u16::MAX as u64,\n-                UintTy::TyU32 => ::std::u32::MAX as u64,\n-                UintTy::TyU64 => ::std::u64::MAX,\n-                UintTy::TyUs => {\n+                UintTy::U8 => ::std::u8::MAX as u64,\n+                UintTy::U16 => ::std::u16::MAX as u64,\n+                UintTy::U32 => ::std::u32::MAX as u64,\n+                UintTy::U64 => ::std::u64::MAX,\n+                UintTy::Us => {\n                     return None;\n                 }  // refuse to guess\n             };\n-            Some(Int(!value & mask, UnsignedIntLit(ity)))\n+            Some(Int(!value & mask, LitIntType::Unsigned(ity), Sign::Plus))\n         },\n         _ => None,\n     }\n@@ -213,8 +211,8 @@ fn constant_negate(o: Constant) -> Option<Constant> {\n     use syntax::ast::LitIntType::*;\n     use self::Constant::*;\n     match o {\n-        Int(value, SignedIntLit(ity, sign)) => Some(Int(value, SignedIntLit(ity, neg_sign(sign)))),\n-        Int(value, UnsuffixedIntLit(sign)) => Some(Int(value, UnsuffixedIntLit(neg_sign(sign)))),\n+        Int(value, LitIntType::Signed(ity), sign) => Some(Int(value, LitIntType::Signed(ity), neg_sign(sign))),\n+        Int(value, LitIntType::Unsuffixed, sign) => Some(Int(value, LitIntType::Unsuffixed, neg_sign(sign))),\n         Float(is, ty) => Some(Float(neg_float_str(is), ty)),\n         _ => None,\n     }\n@@ -235,78 +233,32 @@ fn neg_float_str(s: String) -> String {\n     }\n }\n \n-/// is the given LitIntType negative?\n-///\n-/// Examples\n-///\n-/// ```\n-/// assert!(is_negative(UnsuffixedIntLit(Minus)));\n-/// ```\n-pub fn is_negative(ty: LitIntType) -> bool {\n-    match ty {\n-        LitIntType::SignedIntLit(_, sign) | LitIntType::UnsuffixedIntLit(sign) => sign == Minus,\n-        LitIntType::UnsignedIntLit(_) => false,\n-    }\n-}\n-\n-fn unify_int_type(l: LitIntType, r: LitIntType, s: Sign) -> Option<LitIntType> {\n+fn unify_int_type(l: LitIntType, r: LitIntType) -> Option<LitIntType> {\n     use syntax::ast::LitIntType::*;\n     match (l, r) {\n-        (SignedIntLit(lty, _), SignedIntLit(rty, _)) => {\n+        (Signed(lty), Signed(rty)) => {\n             if lty == rty {\n-                Some(SignedIntLit(lty, s))\n+                Some(LitIntType::Signed(lty))\n             } else {\n                 None\n             }\n         }\n-        (UnsignedIntLit(lty), UnsignedIntLit(rty)) => {\n-            if s == Plus && lty == rty {\n-                Some(UnsignedIntLit(lty))\n-            } else {\n-                None\n-            }\n-        }\n-        (UnsuffixedIntLit(_), UnsuffixedIntLit(_)) => Some(UnsuffixedIntLit(s)),\n-        (SignedIntLit(lty, _), UnsuffixedIntLit(_)) => Some(SignedIntLit(lty, s)),\n-        (UnsignedIntLit(lty), UnsuffixedIntLit(rs)) => {\n-            if rs == Plus {\n-                Some(UnsignedIntLit(lty))\n-            } else {\n-                None\n-            }\n-        }\n-        (UnsuffixedIntLit(_), SignedIntLit(rty, _)) => Some(SignedIntLit(rty, s)),\n-        (UnsuffixedIntLit(ls), UnsignedIntLit(rty)) => {\n-            if ls == Plus {\n-                Some(UnsignedIntLit(rty))\n+        (Unsigned(lty), Unsigned(rty)) => {\n+            if lty == rty {\n+                Some(LitIntType::Unsigned(lty))\n             } else {\n                 None\n             }\n         }\n+        (Unsuffixed, Unsuffixed) => Some(Unsuffixed),\n+        (Signed(lty), Unsuffixed) => Some(Signed(lty)),\n+        (Unsigned(lty), Unsuffixed) => Some(Unsigned(lty)),\n+        (Unsuffixed, Signed(rty)) => Some(Signed(rty)),\n+        (Unsuffixed, Unsigned(rty)) => Some(Unsigned(rty)),\n         _ => None,\n     }\n }\n \n-fn add_neg_int(pos: u64, pty: LitIntType, neg: u64, nty: LitIntType) -> Option<Constant> {\n-    if neg > pos {\n-        unify_int_type(nty, pty, Minus).map(|ty| Constant::Int(neg - pos, ty))\n-    } else {\n-        unify_int_type(nty, pty, Plus).map(|ty| Constant::Int(pos - neg, ty))\n-    }\n-}\n-\n-fn sub_int(l: u64, lty: LitIntType, r: u64, rty: LitIntType, neg: bool) -> Option<Constant> {\n-    unify_int_type(lty,\n-                   rty,\n-                   if neg {\n-                       Minus\n-                   } else {\n-                       Plus\n-                   })\n-        .and_then(|ty| l.checked_sub(r).map(|v| Constant::Int(v, ty)))\n-}\n-\n-\n pub fn constant(lcx: &LateContext, e: &Expr) -> Option<(Constant, bool)> {\n     let mut cx = ConstEvalLateContext {\n         lcx: Some(lcx),\n@@ -412,23 +364,9 @@ impl<'c, 'cc> ConstEvalLateContext<'c, 'cc> {\n                 self.binop_apply(left, right, |l, r| {\n                     match (l, r) {\n                         (Constant::Byte(l8), Constant::Byte(r8)) => l8.checked_add(r8).map(Constant::Byte),\n-                        (Constant::Int(l64, lty), Constant::Int(r64, rty)) => {\n-                            let (ln, rn) = (is_negative(lty), is_negative(rty));\n-                            if ln == rn {\n-                                unify_int_type(lty,\n-                                               rty,\n-                                               if ln {\n-                                                   Minus\n-                                               } else {\n-                                                   Plus\n-                                               })\n-                                    .and_then(|ty| l64.checked_add(r64).map(|v| Constant::Int(v, ty)))\n-                            } else if ln {\n-                                add_neg_int(r64, rty, l64, lty)\n-                            } else {\n-                                add_neg_int(l64, lty, r64, rty)\n-                            }\n-                        }\n+                        (Constant::Int(l64, lty, lsign), Constant::Int(r64, rty, rsign)) => {\n+                            add_ints(l64, r64, lty, rty, lsign, rsign)\n+                        },\n                         // TODO: float (would need bignum library?)\n                         _ => None,\n                     }\n@@ -444,20 +382,9 @@ impl<'c, 'cc> ConstEvalLateContext<'c, 'cc> {\n                                 Some(Constant::Byte(l8 - r8))\n                             }\n                         }\n-                        (Constant::Int(l64, lty), Constant::Int(r64, rty)) => {\n-                            match (is_negative(lty), is_negative(rty)) {\n-                                (false, false) => sub_int(l64, lty, r64, rty, r64 > l64),\n-                                (true, true) => sub_int(l64, lty, r64, rty, l64 > r64),\n-                                (true, false) => {\n-                                    unify_int_type(lty, rty, Minus)\n-                                        .and_then(|ty| l64.checked_add(r64).map(|v| Constant::Int(v, ty)))\n-                                }\n-                                (false, true) => {\n-                                    unify_int_type(lty, rty, Plus)\n-                                        .and_then(|ty| l64.checked_add(r64).map(|v| Constant::Int(v, ty)))\n-                                }\n-                            }\n-                        }\n+                        (Constant::Int(l64, lty, lsign), Constant::Int(r64, rty, rsign)) => {\n+                            add_ints(l64, r64, lty, rty, lsign, neg_sign(rsign))\n+                        },\n                         _ => None,\n                     }\n                 })\n@@ -487,16 +414,10 @@ impl<'c, 'cc> ConstEvalLateContext<'c, 'cc> {\n     {\n         self.binop_apply(left, right, |l, r| {\n             match (l, r) {\n-                (Constant::Int(l64, lty), Constant::Int(r64, rty)) => {\n+                (Constant::Int(l64, lty, lsign), Constant::Int(r64, rty, rsign)) => {\n                     f(l64, r64).and_then(|value| {\n-                        unify_int_type(lty,\n-                                       rty,\n-                                       if is_negative(lty) == is_negative(rty) {\n-                                           Plus\n-                                       } else {\n-                                           Minus\n-                                       })\n-                            .map(|ty| Constant::Int(value, ty))\n+                        let sign = if lsign == rsign { Sign::Plus } else { Sign::Minus };\n+                        unify_int_type(lty, rty).map(|ty| Constant::Int(value, ty, sign))\n                     })\n                 }\n                 _ => None,\n@@ -511,8 +432,12 @@ impl<'c, 'cc> ConstEvalLateContext<'c, 'cc> {\n             match (l, r) {\n                 (Constant::Bool(l), Constant::Bool(r)) => Some(Constant::Bool(f(l as u64, r as u64) != 0)),\n                 (Constant::Byte(l8), Constant::Byte(r8)) => Some(Constant::Byte(f(l8 as u64, r8 as u64) as u8)),\n-                (Constant::Int(l, lty), Constant::Int(r, rty)) => {\n-                    unify_int_type(lty, rty, Plus).map(|ty| Constant::Int(f(l, r), ty))\n+                (Constant::Int(l, lty, lsign), Constant::Int(r, rty, rsign)) => {\n+                    if lsign == Sign::Plus && rsign == Sign::Plus {\n+                        unify_int_type(lty, rty).map(|ty| Constant::Int(f(l, r), ty, Sign::Plus))\n+                    } else {\n+                        None\n+                    }\n                 }\n                 _ => None,\n             }\n@@ -555,3 +480,21 @@ impl<'c, 'cc> ConstEvalLateContext<'c, 'cc> {\n         })\n     }\n }\n+\n+fn add_ints(l64: u64, r64: u64, lty: LitIntType, rty: LitIntType, lsign: Sign, rsign: Sign) -> Option<Constant> {\n+    let ty = if let Some(ty) = unify_int_type(lty, rty) { ty } else { return None; };\n+    match (lsign, rsign) {\n+        (Sign::Plus, Sign::Plus) => l64.checked_add(r64).map(|v| Constant::Int(v, ty, Sign::Plus)),\n+        (Sign::Plus, Sign::Minus) => if r64 > l64 {\n+            Some(Constant::Int(r64 - l64, ty, Sign::Minus))\n+        } else {\n+            Some(Constant::Int(l64 - r64, ty, Sign::Plus))\n+        },\n+        (Sign::Minus, Sign::Minus) =>  l64.checked_add(r64).map(|v| Constant::Int(v, ty, Sign::Minus)),\n+        (Sign::Minus, Sign::Plus) => if l64 > r64 {\n+            Some(Constant::Int(l64 - r64, ty, Sign::Minus))\n+        } else {\n+            Some(Constant::Int(r64 - l64, ty, Sign::Plus))\n+        },\n+    }\n+}"}, {"sha": "e9eef8247134732c6f98d0fa5bd063f2447c0590", "filename": "src/derive.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3f34b65747546aefeceb2edc4e8e4dc03c82e7f7/src%2Fderive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f34b65747546aefeceb2edc4e8e4dc03c82e7f7/src%2Fderive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fderive.rs?ref=3f34b65747546aefeceb2edc4e8e4dc03c82e7f7", "patch": "@@ -2,7 +2,7 @@ use rustc::lint::*;\n use rustc::middle::ty::fast_reject::simplify_type;\n use rustc::middle::ty;\n use rustc_front::hir::*;\n-use syntax::ast::{Attribute, MetaItem_};\n+use syntax::ast::{Attribute, MetaItemKind};\n use syntax::codemap::Span;\n use utils::{CLONE_TRAIT_PATH, HASH_PATH};\n use utils::{match_path, span_lint_and_then};\n@@ -170,7 +170,7 @@ fn check_copy_clone<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, span: Span, trait_ref:\n \n /// Checks for the `#[automatically_derived]` attribute all `#[derive]`d implementations have.\n fn is_automatically_derived(attr: &Attribute) -> bool {\n-    if let MetaItem_::MetaWord(ref word) = attr.node.value.node {\n+    if let MetaItemKind::Word(ref word) = attr.node.value.node {\n         word == &\"automatically_derived\"\n     } else {\n         false"}, {"sha": "c77e42e69c9ed5bfe6045a7330998dd97c6b1eca", "filename": "src/enum_variants.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3f34b65747546aefeceb2edc4e8e4dc03c82e7f7/src%2Fenum_variants.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f34b65747546aefeceb2edc4e8e4dc03c82e7f7/src%2Fenum_variants.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fenum_variants.rs?ref=3f34b65747546aefeceb2edc4e8e4dc03c82e7f7", "patch": "@@ -41,7 +41,7 @@ fn partial_rmatch(left: &str, right: &str) -> usize {\n \n impl EarlyLintPass for EnumVariantNames {\n     fn check_item(&mut self, cx: &EarlyContext, item: &Item) {\n-        if let ItemEnum(ref def, _) = item.node {\n+        if let ItemKind::Enum(ref def, _) = item.node {\n             if def.variants.len() < 2 {\n                 return;\n             }"}, {"sha": "b033b234122c92476f5823e4225a036410dee957", "filename": "src/identity_op.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/3f34b65747546aefeceb2edc4e8e4dc03c82e7f7/src%2Fidentity_op.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f34b65747546aefeceb2edc4e8e4dc03c82e7f7/src%2Fidentity_op.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fidentity_op.rs?ref=3f34b65747546aefeceb2edc4e8e4dc03c82e7f7", "patch": "@@ -2,7 +2,7 @@ use rustc::lint::*;\n use rustc_front::hir::*;\n use syntax::codemap::Span;\n \n-use consts::{constant_simple, is_negative, Constant};\n+use consts::{constant_simple, Constant, Sign};\n use utils::{span_lint, snippet, in_macro};\n \n /// **What it does:** This lint checks for identity operations, e.g. `x + 0`.\n@@ -55,11 +55,11 @@ impl LateLintPass for IdentityOp {\n \n \n fn check(cx: &LateContext, e: &Expr, m: i8, span: Span, arg: Span) {\n-    if let Some(Constant::Int(v, ty)) = constant_simple(e) {\n+    if let Some(Constant::Int(v, _, sign)) = constant_simple(e) {\n         if match m {\n             0 => v == 0,\n-            -1 => is_negative(ty) && v == 1,\n-            1 => !is_negative(ty) && v == 1,\n+            -1 => sign == Sign::Minus && v == 1,\n+            1 => sign == Sign::Plus && v == 1,\n             _ => unreachable!(),\n         } {\n             span_lint(cx,"}, {"sha": "9bfb3b87ed180c0dadb7a694f15e1730a6f8bce6", "filename": "src/items_after_statements.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/3f34b65747546aefeceb2edc4e8e4dc03c82e7f7/src%2Fitems_after_statements.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f34b65747546aefeceb2edc4e8e4dc03c82e7f7/src%2Fitems_after_statements.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fitems_after_statements.rs?ref=3f34b65747546aefeceb2edc4e8e4dc03c82e7f7", "patch": "@@ -47,15 +47,15 @@ impl EarlyLintPass for ItemsAfterStatemets {\n         }\n         let mut stmts = item.stmts.iter().map(|stmt| &stmt.node);\n         // skip initial items\n-        while let Some(&StmtDecl(ref decl, _)) = stmts.next() {\n-            if let DeclLocal(_) = decl.node {\n+        while let Some(&StmtKind::Decl(ref decl, _)) = stmts.next() {\n+            if let DeclKind::Local(_) = decl.node {\n                 break;\n             }\n         }\n         // lint on all further items\n         for stmt in stmts {\n-            if let StmtDecl(ref decl, _) = *stmt {\n-                if let DeclItem(ref it) = decl.node {\n+            if let StmtKind::Decl(ref decl, _) = *stmt {\n+                if let DeclKind::Item(ref it) = decl.node {\n                     if in_macro(cx, it.span) {\n                         return;\n                     }"}, {"sha": "4f3c2367370d1c0c4b2aca8e16286c7e9a593df1", "filename": "src/len_zero.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3f34b65747546aefeceb2edc4e8e4dc03c82e7f7/src%2Flen_zero.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f34b65747546aefeceb2edc4e8e4dc03c82e7f7/src%2Flen_zero.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flen_zero.rs?ref=3f34b65747546aefeceb2edc4e8e4dc03c82e7f7", "patch": "@@ -6,7 +6,7 @@ use syntax::codemap::{Span, Spanned};\n use rustc::middle::def_id::DefId;\n use rustc::middle::ty::{self, MethodTraitItemId, ImplOrTraitItemId};\n \n-use syntax::ast::{Lit, Lit_};\n+use syntax::ast::{Lit, LitKind};\n \n use utils::{get_item_name, snippet, span_lint, walk_ptrs_ty};\n \n@@ -151,7 +151,7 @@ fn check_cmp(cx: &LateContext, span: Span, left: &Expr, right: &Expr, op: &str)\n }\n \n fn check_len_zero(cx: &LateContext, span: Span, name: &Name, args: &[P<Expr>], lit: &Lit, op: &str) {\n-    if let Spanned{node: Lit_::LitInt(0, _), ..} = *lit {\n+    if let Spanned{node: LitKind::Int(0, _), ..} = *lit {\n         if name.as_str() == \"len\" && args.len() == 1 && has_is_empty(cx, &args[0]) {\n             span_lint(cx,\n                       LEN_ZERO,"}, {"sha": "ca410a413bda894e1d36cc2fc69338a07b63997a", "filename": "src/matches.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/3f34b65747546aefeceb2edc4e8e4dc03c82e7f7/src%2Fmatches.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f34b65747546aefeceb2edc4e8e4dc03c82e7f7/src%2Fmatches.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fmatches.rs?ref=3f34b65747546aefeceb2edc4e8e4dc03c82e7f7", "patch": "@@ -5,7 +5,7 @@ use rustc::middle::const_eval::{eval_const_expr_partial, ConstVal};\n use rustc::middle::ty;\n use rustc_front::hir::*;\n use std::cmp::Ordering;\n-use syntax::ast::Lit_::LitBool;\n+use syntax::ast::LitKind;\n use syntax::codemap::Span;\n \n use utils::{COW_PATH, OPTION_PATH, RESULT_PATH};\n@@ -238,8 +238,8 @@ fn check_match_bool(cx: &LateContext, ex: &Expr, arms: &[Arm], expr: &Expr) {\n             let exprs = if let PatLit(ref arm_bool) = arms[0].pats[0].node {\n                 if let ExprLit(ref lit) = arm_bool.node {\n                     match lit.node {\n-                        LitBool(true) => Some((&*arms[0].body, &*arms[1].body)),\n-                        LitBool(false) => Some((&*arms[1].body, &*arms[0].body)),\n+                        LitKind::Bool(true) => Some((&*arms[0].body, &*arms[1].body)),\n+                        LitKind::Bool(false) => Some((&*arms[1].body, &*arms[0].body)),\n                         _ => None,\n                     }\n                 } else {"}, {"sha": "8a51ba27b8effebbff6883d9cfec058a3b0cd9af", "filename": "src/mutex_atomic.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3f34b65747546aefeceb2edc4e8e4dc03c82e7f7/src%2Fmutex_atomic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f34b65747546aefeceb2edc4e8e4dc03c82e7f7/src%2Fmutex_atomic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fmutex_atomic.rs?ref=3f34b65747546aefeceb2edc4e8e4dc03c82e7f7", "patch": "@@ -56,8 +56,8 @@ impl LateLintPass for MutexAtomic {\n                                        behaviour and not the internal type, consider using Mutex<()>.\",\n                                       atomic_name);\n                     match *mutex_param {\n-                        ty::TyUint(t) if t != ast::TyUs => span_lint(cx, MUTEX_INTEGER, expr.span, &msg),\n-                        ty::TyInt(t) if t != ast::TyIs => span_lint(cx, MUTEX_INTEGER, expr.span, &msg),\n+                        ty::TyUint(t) if t != ast::UintTy::Us => span_lint(cx, MUTEX_INTEGER, expr.span, &msg),\n+                        ty::TyInt(t) if t != ast::IntTy::Is => span_lint(cx, MUTEX_INTEGER, expr.span, &msg),\n                         _ => span_lint(cx, MUTEX_ATOMIC, expr.span, &msg),\n                     };\n                 }"}, {"sha": "fe46988dccbbe63f2d605fce32b62c5ee60fea85", "filename": "src/needless_bool.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3f34b65747546aefeceb2edc4e8e4dc03c82e7f7/src%2Fneedless_bool.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f34b65747546aefeceb2edc4e8e4dc03c82e7f7/src%2Fneedless_bool.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fneedless_bool.rs?ref=3f34b65747546aefeceb2edc4e8e4dc03c82e7f7", "patch": "@@ -5,7 +5,7 @@\n use rustc::lint::*;\n use rustc_front::hir::*;\n \n-use syntax::ast::Lit_;\n+use syntax::ast::LitKind;\n use syntax::codemap::Spanned;\n \n use utils::{span_lint, span_lint_and_then, snippet};\n@@ -164,7 +164,7 @@ fn fetch_bool_expr(expr: &Expr) -> Option<bool> {\n     match expr.node {\n         ExprBlock(ref block) => fetch_bool_block(block),\n         ExprLit(ref lit_ptr) => {\n-            if let Lit_::LitBool(value) = lit_ptr.node {\n+            if let LitKind::Bool(value) = lit_ptr.node {\n                 Some(value)\n             } else {\n                 None"}, {"sha": "8b1c4a90fdf4acf54e18d8593808b1b504c35660", "filename": "src/open_options.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3f34b65747546aefeceb2edc4e8e4dc03c82e7f7/src%2Fopen_options.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f34b65747546aefeceb2edc4e8e4dc03c82e7f7/src%2Fopen_options.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fopen_options.rs?ref=3f34b65747546aefeceb2edc4e8e4dc03c82e7f7", "patch": "@@ -2,7 +2,7 @@ use rustc::lint::*;\n use rustc_front::hir::{Expr, ExprMethodCall, ExprLit};\n use utils::{walk_ptrs_ty_depth, match_type, span_lint, OPEN_OPTIONS_PATH};\n use syntax::codemap::{Span, Spanned};\n-use syntax::ast::Lit_::LitBool;\n+use syntax::ast::LitKind;\n \n /// **What it does:** This lint checks for duplicate open options as well as combinations that make no sense.\n ///\n@@ -65,7 +65,7 @@ fn get_open_options(cx: &LateContext, argument: &Expr, options: &mut Vec<(OpenOp\n \n             let argument_option = match arguments[1].node {\n                 ExprLit(ref span) => {\n-                    if let Spanned {node: LitBool(lit), ..} = **span {\n+                    if let Spanned {node: LitKind::Bool(lit), ..} = **span {\n                         if lit {\n                             Argument::True\n                         } else {"}, {"sha": "b76def8d2f3cb449713d6cafd7d0ba9d39e75ba1", "filename": "src/panic.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3f34b65747546aefeceb2edc4e8e4dc03c82e7f7/src%2Fpanic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f34b65747546aefeceb2edc4e8e4dc03c82e7f7/src%2Fpanic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fpanic.rs?ref=3f34b65747546aefeceb2edc4e8e4dc03c82e7f7", "patch": "@@ -1,6 +1,6 @@\n use rustc::lint::*;\n use rustc_front::hir::*;\n-use syntax::ast::Lit_::LitStr;\n+use syntax::ast::LitKind;\n \n use utils::{span_lint, in_external_macro, match_path, BEGIN_UNWIND};\n \n@@ -37,7 +37,7 @@ impl LateLintPass for PanicPass {\n             let ExprPath(None, ref path) = fun.node,\n             match_path(path, &BEGIN_UNWIND),\n             let ExprLit(ref lit) = params[0].node,\n-            let LitStr(ref string, _) = lit.node,\n+            let LitKind::Str(ref string, _) = lit.node,\n             string.contains('{'),\n             let Some(sp) = cx.sess().codemap()\n                              .with_expn_info(expr.span.expn_id,"}, {"sha": "d498510f97a384bed182f37af8e82a57db70fb05", "filename": "src/precedence.rs", "status": "modified", "additions": 12, "deletions": 10, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/3f34b65747546aefeceb2edc4e8e4dc03c82e7f7/src%2Fprecedence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f34b65747546aefeceb2edc4e8e4dc03c82e7f7/src%2Fprecedence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fprecedence.rs?ref=3f34b65747546aefeceb2edc4e8e4dc03c82e7f7", "patch": "@@ -32,7 +32,7 @@ impl LintPass for Precedence {\n \n impl EarlyLintPass for Precedence {\n     fn check_expr(&mut self, cx: &EarlyContext, expr: &Expr) {\n-        if let ExprBinary(Spanned { node: op, ..}, ref left, ref right) = expr.node {\n+        if let ExprKind::Binary(Spanned { node: op, ..}, ref left, ref right) = expr.node {\n             if !is_bit_op(op) {\n                 return;\n             }\n@@ -71,12 +71,12 @@ impl EarlyLintPass for Precedence {\n             }\n         }\n \n-        if let ExprUnary(UnNeg, ref rhs) = expr.node {\n-            if let ExprMethodCall(_, _, ref args) = rhs.node {\n+        if let ExprKind::Unary(UnOp::Neg, ref rhs) = expr.node {\n+            if let ExprKind::MethodCall(_, _, ref args) = rhs.node {\n                 if let Some(slf) = args.first() {\n-                    if let ExprLit(ref lit) = slf.node {\n+                    if let ExprKind::Lit(ref lit) = slf.node {\n                         match lit.node {\n-                            LitInt(..) | LitFloat(..) | LitFloatUnsuffixed(..) => {\n+                            LitKind::Int(..) | LitKind::Float(..) | LitKind::FloatUnsuffixed(..) => {\n                                 span_lint(cx,\n                                           PRECEDENCE,\n                                           expr.span,\n@@ -95,21 +95,23 @@ impl EarlyLintPass for Precedence {\n \n fn is_arith_expr(expr: &Expr) -> bool {\n     match expr.node {\n-        ExprBinary(Spanned { node: op, ..}, _, _) => is_arith_op(op),\n+        ExprKind::Binary(Spanned { node: op, ..}, _, _) => is_arith_op(op),\n         _ => false,\n     }\n }\n \n-fn is_bit_op(op: BinOp_) -> bool {\n+fn is_bit_op(op: BinOpKind) -> bool {\n+    use syntax::ast::BinOpKind::*;\n     match op {\n-        BiBitXor | BiBitAnd | BiBitOr | BiShl | BiShr => true,\n+        BitXor | BitAnd | BitOr | Shl | Shr => true,\n         _ => false,\n     }\n }\n \n-fn is_arith_op(op: BinOp_) -> bool {\n+fn is_arith_op(op: BinOpKind) -> bool {\n+    use syntax::ast::BinOpKind::*;\n     match op {\n-        BiAdd | BiSub | BiMul | BiDiv | BiRem => true,\n+        Add | Sub | Mul | Div | Rem => true,\n         _ => false,\n     }\n }"}, {"sha": "5103391e9ddc11bee12a4149f0cf1e3fece3f1db", "filename": "src/regex.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/3f34b65747546aefeceb2edc4e8e4dc03c82e7f7/src%2Fregex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f34b65747546aefeceb2edc4e8e4dc03c82e7f7/src%2Fregex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fregex.rs?ref=3f34b65747546aefeceb2edc4e8e4dc03c82e7f7", "patch": "@@ -1,7 +1,7 @@\n use regex_syntax;\n use std::error::Error;\n use std::collections::HashSet;\n-use syntax::ast::Lit_::LitStr;\n+use syntax::ast::LitKind;\n use syntax::codemap::{Span, BytePos};\n use syntax::parse::token::InternedString;\n use rustc_front::hir::*;\n@@ -75,7 +75,7 @@ impl LateLintPass for RegexPass {\n             match_path(path, &REGEX_NEW_PATH) && args.len() == 1\n         ], {\n             if let ExprLit(ref lit) = args[0].node {\n-                if let LitStr(ref r, _) = lit.node {\n+                if let LitKind::Str(ref r, _) = lit.node {\n                     match regex_syntax::Expr::parse(r) {\n                         Ok(r) => {\n                             if let Some(repl) = is_trivial_regex(&r) {\n@@ -176,8 +176,8 @@ impl<'v, 't: 'v> Visitor<'v> for RegexVisitor<'v, 't> {\n                 if self.spans.contains(&span) {\n                     return;\n                 }\n-                span_lint(self.cx, \n-                          REGEX_MACRO, \n+                span_lint(self.cx,\n+                          REGEX_MACRO,\n                           span,\n                           \"`regex!(_)` found. \\\n                           Please use `Regex::new(_)`, which is faster for now.\");"}, {"sha": "63864eafcd2d18e7de113951f917671f26f429fd", "filename": "src/returns.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/3f34b65747546aefeceb2edc4e8e4dc03c82e7f7/src%2Freturns.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f34b65747546aefeceb2edc4e8e4dc03c82e7f7/src%2Freturns.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Freturns.rs?ref=3f34b65747546aefeceb2edc4e8e4dc03c82e7f7", "patch": "@@ -40,8 +40,8 @@ impl ReturnPass {\n         if let Some(ref expr) = block.expr {\n             self.check_final_expr(cx, expr);\n         } else if let Some(stmt) = block.stmts.last() {\n-            if let StmtSemi(ref expr, _) = stmt.node {\n-                if let ExprRet(Some(ref inner)) = expr.node {\n+            if let StmtKind::Semi(ref expr, _) = stmt.node {\n+                if let ExprKind::Ret(Some(ref inner)) = expr.node {\n                     self.emit_return_lint(cx, (stmt.span, inner.span));\n                 }\n             }\n@@ -52,22 +52,22 @@ impl ReturnPass {\n     fn check_final_expr(&mut self, cx: &EarlyContext, expr: &Expr) {\n         match expr.node {\n             // simple return is always \"bad\"\n-            ExprRet(Some(ref inner)) => {\n+            ExprKind::Ret(Some(ref inner)) => {\n                 self.emit_return_lint(cx, (expr.span, inner.span));\n             }\n             // a whole block? check it!\n-            ExprBlock(ref block) => {\n+            ExprKind::Block(ref block) => {\n                 self.check_block_return(cx, block);\n             }\n             // an if/if let expr, check both exprs\n             // note, if without else is going to be a type checking error anyways\n             // (except for unit type functions) so we don't match it\n-            ExprIf(_, ref ifblock, Some(ref elsexpr)) => {\n+            ExprKind::If(_, ref ifblock, Some(ref elsexpr)) => {\n                 self.check_block_return(cx, ifblock);\n                 self.check_final_expr(cx, elsexpr);\n             }\n             // a match expr, check all arms\n-            ExprMatch(_, ref arms) => {\n+            ExprKind::Match(_, ref arms) => {\n                 for arm in arms {\n                     self.check_final_expr(cx, &arm.body);\n                 }\n@@ -94,11 +94,11 @@ impl ReturnPass {\n             [\n                 let Some(stmt) = block.stmts.last(),\n                 let Some(ref retexpr) = block.expr,\n-                let StmtDecl(ref decl, _) = stmt.node,\n-                let DeclLocal(ref local) = decl.node,\n+                let StmtKind::Decl(ref decl, _) = stmt.node,\n+                let DeclKind::Local(ref local) = decl.node,\n                 let Some(ref initexpr) = local.init,\n                 let PatIdent(_, Spanned { node: id, .. }, _) = local.pat.node,\n-                let ExprPath(_, ref path) = retexpr.node,\n+                let ExprKind::Path(_, ref path) = retexpr.node,\n                 match_path_ast(path, &[&id.name.as_str()])\n             ], {\n                 self.emit_let_lint(cx, retexpr.span, initexpr.span);"}, {"sha": "7b4b2e2c5ec764fe8cf2d3e37234c574a1912e54", "filename": "src/strings.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3f34b65747546aefeceb2edc4e8e4dc03c82e7f7/src%2Fstrings.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f34b65747546aefeceb2edc4e8e4dc03c82e7f7/src%2Fstrings.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fstrings.rs?ref=3f34b65747546aefeceb2edc4e8e4dc03c82e7f7", "patch": "@@ -133,13 +133,13 @@ impl LintPass for StringLitAsBytes {\n impl LateLintPass for StringLitAsBytes {\n     fn check_expr(&mut self, cx: &LateContext, e: &Expr) {\n         use std::ascii::AsciiExt;\n-        use syntax::ast::Lit_::LitStr;\n+        use syntax::ast::LitKind;\n         use utils::{snippet, in_macro};\n \n         if let ExprMethodCall(ref name, _, ref args) = e.node {\n             if name.node.as_str() == \"as_bytes\" {\n                 if let ExprLit(ref lit) = args[0].node {\n-                    if let LitStr(ref lit_content, _) = lit.node {\n+                    if let LitKind::Str(ref lit_content, _) = lit.node {\n                         if lit_content.chars().all(|c| c.is_ascii()) && !in_macro(cx, e.span) {\n                             let msg = format!(\"calling `as_bytes()` on a string literal. \\\n                                                Consider using a byte string literal instead: \\"}, {"sha": "7cfcc76193d4510e8ad8a05e1a5e4a7a2f76f632", "filename": "src/types.rs", "status": "modified", "additions": 27, "deletions": 27, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/3f34b65747546aefeceb2edc4e8e4dc03c82e7f7/src%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f34b65747546aefeceb2edc4e8e4dc03c82e7f7/src%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftypes.rs?ref=3f34b65747546aefeceb2edc4e8e4dc03c82e7f7", "patch": "@@ -235,7 +235,7 @@ fn int_ty_to_nbits(typ: &ty::TyS) -> usize {\n \n fn is_isize_or_usize(typ: &ty::TyS) -> bool {\n     match typ.sty {\n-        ty::TyInt(IntTy::TyIs) | ty::TyUint(UintTy::TyUs) => true,\n+        ty::TyInt(IntTy::Is) | ty::TyUint(UintTy::Us) => true,\n         _ => false,\n     }\n }\n@@ -360,7 +360,7 @@ impl LateLintPass for CastPass {\n                 match (cast_from.is_integral(), cast_to.is_integral()) {\n                     (true, false) => {\n                         let from_nbits = int_ty_to_nbits(cast_from);\n-                        let to_nbits = if let ty::TyFloat(FloatTy::TyF32) = cast_to.sty {\n+                        let to_nbits = if let ty::TyFloat(FloatTy::F32) = cast_to.sty {\n                             32\n                         } else {\n                             64\n@@ -391,7 +391,7 @@ impl LateLintPass for CastPass {\n                         check_truncation_and_wrapping(cx, expr, cast_from, cast_to);\n                     }\n                     (false, false) => {\n-                        if let (&ty::TyFloat(FloatTy::TyF64), &ty::TyFloat(FloatTy::TyF32)) = (&cast_from.sty, &cast_to.sty) {\n+                        if let (&ty::TyFloat(FloatTy::F64), &ty::TyFloat(FloatTy::F32)) = (&cast_from.sty, &cast_to.sty) {\n                             span_lint(cx,\n                                       CAST_POSSIBLE_TRUNCATION,\n                                       expr.span,\n@@ -560,12 +560,12 @@ impl LintPass for CharLitAsU8 {\n \n impl LateLintPass for CharLitAsU8 {\n     fn check_expr(&mut self, cx: &LateContext, expr: &Expr) {\n-        use syntax::ast::{Lit_, UintTy};\n+        use syntax::ast::{LitKind, UintTy};\n \n         if let ExprCast(ref e, _) = expr.node {\n             if let ExprLit(ref l) = e.node {\n-                if let Lit_::LitChar(_) = l.node {\n-                    if ty::TyUint(UintTy::TyU8) == cx.tcx.expr_ty(expr).sty && !in_macro(cx, expr.span) {\n+                if let LitKind::Char(_) = l.node {\n+                    if ty::TyUint(UintTy::U8) == cx.tcx.expr_ty(expr).sty && !in_macro(cx, expr.span) {\n                         let msg = \"casting character literal to u8. `char`s \\\n                                    are 4 bytes wide in rust, so casting to u8 \\\n                                    truncates them\";\n@@ -676,31 +676,31 @@ fn detect_extreme_expr<'a>(cx: &LateContext, expr: &'a Expr) -> Option<ExtremeEx\n     let which = match (ty, cv) {\n         (&ty::TyBool, Bool(false)) => Minimum,\n \n-        (&ty::TyInt(IntTy::TyIs), Int(x)) if x == ::std::isize::MIN as i64 => Minimum,\n-        (&ty::TyInt(IntTy::TyI8), Int(x)) if x == ::std::i8::MIN as i64 => Minimum,\n-        (&ty::TyInt(IntTy::TyI16), Int(x)) if x == ::std::i16::MIN as i64 => Minimum,\n-        (&ty::TyInt(IntTy::TyI32), Int(x)) if x == ::std::i32::MIN as i64 => Minimum,\n-        (&ty::TyInt(IntTy::TyI64), Int(x)) if x == ::std::i64::MIN as i64 => Minimum,\n+        (&ty::TyInt(IntTy::Is), Int(x)) if x == ::std::isize::MIN as i64 => Minimum,\n+        (&ty::TyInt(IntTy::I8), Int(x)) if x == ::std::i8::MIN as i64 => Minimum,\n+        (&ty::TyInt(IntTy::I16), Int(x)) if x == ::std::i16::MIN as i64 => Minimum,\n+        (&ty::TyInt(IntTy::I32), Int(x)) if x == ::std::i32::MIN as i64 => Minimum,\n+        (&ty::TyInt(IntTy::I64), Int(x)) if x == ::std::i64::MIN as i64 => Minimum,\n \n-        (&ty::TyUint(UintTy::TyUs), Uint(x)) if x == ::std::usize::MIN as u64 => Minimum,\n-        (&ty::TyUint(UintTy::TyU8), Uint(x)) if x == ::std::u8::MIN as u64 => Minimum,\n-        (&ty::TyUint(UintTy::TyU16), Uint(x)) if x == ::std::u16::MIN as u64 => Minimum,\n-        (&ty::TyUint(UintTy::TyU32), Uint(x)) if x == ::std::u32::MIN as u64 => Minimum,\n-        (&ty::TyUint(UintTy::TyU64), Uint(x)) if x == ::std::u64::MIN as u64 => Minimum,\n+        (&ty::TyUint(UintTy::Us), Uint(x)) if x == ::std::usize::MIN as u64 => Minimum,\n+        (&ty::TyUint(UintTy::U8), Uint(x)) if x == ::std::u8::MIN as u64 => Minimum,\n+        (&ty::TyUint(UintTy::U16), Uint(x)) if x == ::std::u16::MIN as u64 => Minimum,\n+        (&ty::TyUint(UintTy::U32), Uint(x)) if x == ::std::u32::MIN as u64 => Minimum,\n+        (&ty::TyUint(UintTy::U64), Uint(x)) if x == ::std::u64::MIN as u64 => Minimum,\n \n         (&ty::TyBool, Bool(true)) => Maximum,\n \n-        (&ty::TyInt(IntTy::TyIs), Int(x)) if x == ::std::isize::MAX as i64 => Maximum,\n-        (&ty::TyInt(IntTy::TyI8), Int(x)) if x == ::std::i8::MAX as i64 => Maximum,\n-        (&ty::TyInt(IntTy::TyI16), Int(x)) if x == ::std::i16::MAX as i64 => Maximum,\n-        (&ty::TyInt(IntTy::TyI32), Int(x)) if x == ::std::i32::MAX as i64 => Maximum,\n-        (&ty::TyInt(IntTy::TyI64), Int(x)) if x == ::std::i64::MAX as i64 => Maximum,\n-\n-        (&ty::TyUint(UintTy::TyUs), Uint(x)) if x == ::std::usize::MAX as u64 => Maximum,\n-        (&ty::TyUint(UintTy::TyU8), Uint(x)) if x == ::std::u8::MAX as u64 => Maximum,\n-        (&ty::TyUint(UintTy::TyU16), Uint(x)) if x == ::std::u16::MAX as u64 => Maximum,\n-        (&ty::TyUint(UintTy::TyU32), Uint(x)) if x == ::std::u32::MAX as u64 => Maximum,\n-        (&ty::TyUint(UintTy::TyU64), Uint(x)) if x == ::std::u64::MAX as u64 => Maximum,\n+        (&ty::TyInt(IntTy::Is), Int(x)) if x == ::std::isize::MAX as i64 => Maximum,\n+        (&ty::TyInt(IntTy::I8), Int(x)) if x == ::std::i8::MAX as i64 => Maximum,\n+        (&ty::TyInt(IntTy::I16), Int(x)) if x == ::std::i16::MAX as i64 => Maximum,\n+        (&ty::TyInt(IntTy::I32), Int(x)) if x == ::std::i32::MAX as i64 => Maximum,\n+        (&ty::TyInt(IntTy::I64), Int(x)) if x == ::std::i64::MAX as i64 => Maximum,\n+\n+        (&ty::TyUint(UintTy::Us), Uint(x)) if x == ::std::usize::MAX as u64 => Maximum,\n+        (&ty::TyUint(UintTy::U8), Uint(x)) if x == ::std::u8::MAX as u64 => Maximum,\n+        (&ty::TyUint(UintTy::U16), Uint(x)) if x == ::std::u16::MAX as u64 => Maximum,\n+        (&ty::TyUint(UintTy::U32), Uint(x)) if x == ::std::u32::MAX as u64 => Maximum,\n+        (&ty::TyUint(UintTy::U64), Uint(x)) if x == ::std::u64::MAX as u64 => Maximum,\n \n         _ => return None,\n     };"}, {"sha": "c8d810b9e710d970706b33cf458224798da4de88", "filename": "src/unicode.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3f34b65747546aefeceb2edc4e8e4dc03c82e7f7/src%2Funicode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f34b65747546aefeceb2edc4e8e4dc03c82e7f7/src%2Funicode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Funicode.rs?ref=3f34b65747546aefeceb2edc4e8e4dc03c82e7f7", "patch": "@@ -2,7 +2,7 @@ use rustc::lint::*;\n use rustc_front::hir::*;\n use syntax::codemap::Span;\n \n-use syntax::ast::Lit_;\n+use syntax::ast::LitKind;\n \n use unicode_normalization::UnicodeNormalization;\n \n@@ -59,7 +59,7 @@ impl LintPass for Unicode {\n impl LateLintPass for Unicode {\n     fn check_expr(&mut self, cx: &LateContext, expr: &Expr) {\n         if let ExprLit(ref lit) = expr.node {\n-            if let Lit_::LitStr(_, _) = lit.node {\n+            if let LitKind::Str(_, _) = lit.node {\n                 check_str(cx, lit.span)\n             }\n         }"}, {"sha": "cd4a34d95b3821a703f220be164997494b15ea8b", "filename": "src/utils.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/3f34b65747546aefeceb2edc4e8e4dc03c82e7f7/src%2Futils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f34b65747546aefeceb2edc4e8e4dc03c82e7f7/src%2Futils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Futils.rs?ref=3f34b65747546aefeceb2edc4e8e4dc03c82e7f7", "patch": "@@ -10,8 +10,7 @@ use std::borrow::Cow;\n use std::mem;\n use std::ops::{Deref, DerefMut};\n use std::str::FromStr;\n-use syntax::ast::Lit_;\n-use syntax::ast;\n+use syntax::ast::{LitKind, self};\n use syntax::codemap::{ExpnInfo, Span, ExpnFormat};\n use syntax::errors::DiagnosticBuilder;\n use syntax::ptr::P;\n@@ -531,7 +530,7 @@ pub fn walk_ptrs_ty_depth(ty: ty::Ty) -> (ty::Ty, usize) {\n pub fn is_integer_literal(expr: &Expr, value: u64) -> bool {\n     // FIXME: use constant folding\n     if let ExprLit(ref spanned) = expr.node {\n-        if let Lit_::LitInt(v, _) = spanned.node {\n+        if let LitKind::Int(v, _) = spanned.node {\n             return v == value;\n         }\n     }\n@@ -575,9 +574,9 @@ fn parse_attrs<F: FnMut(u64)>(sess: &Session, attrs: &[ast::Attribute], name: &'\n         if attr.is_sugared_doc {\n             continue;\n         }\n-        if let ast::MetaNameValue(ref key, ref value) = attr.value.node {\n+        if let ast::MetaItemKind::NameValue(ref key, ref value) = attr.value.node {\n             if *key == name {\n-                if let Lit_::LitStr(ref s, _) = value.node {\n+                if let LitKind::Str(ref s, _) = value.node {\n                     if let Ok(value) = FromStr::from_str(s) {\n                         f(value)\n                     } else {"}, {"sha": "1d639c8092bd23505907c47a951014a7e9fcaad4", "filename": "tests/consts.rs", "status": "modified", "additions": 17, "deletions": 19, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/3f34b65747546aefeceb2edc4e8e4dc03c82e7f7/tests%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f34b65747546aefeceb2edc4e8e4dc03c82e7f7/tests%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fconsts.rs?ref=3f34b65747546aefeceb2edc4e8e4dc03c82e7f7", "patch": "@@ -11,13 +11,11 @@ use syntax::parse::token::InternedString;\n use syntax::ptr::P;\n use syntax::codemap::{Spanned, COMMAND_LINE_SP};\n \n-use syntax::ast::Lit_::*;\n-use syntax::ast::Lit_;\n-use syntax::ast::LitIntType::*;\n-use syntax::ast::StrStyle::*;\n-use syntax::ast::Sign::*;\n+use syntax::ast::LitKind;\n+use syntax::ast::LitIntType;\n+use syntax::ast::StrStyle;\n \n-use clippy::consts::{constant_simple, Constant};\n+use clippy::consts::{constant_simple, Constant, Sign};\n \n fn spanned<T>(t: T) -> Spanned<T> {\n     Spanned{ node: t, span: COMMAND_LINE_SP }\n@@ -32,7 +30,7 @@ fn expr(n: Expr_) -> Expr {\n     }\n }\n \n-fn lit(l: Lit_) -> Expr {\n+fn lit(l: LitKind) -> Expr {\n     expr(ExprLit(P(spanned(l))))\n }\n \n@@ -46,26 +44,26 @@ fn check(expect: Constant, expr: &Expr) {\n \n const TRUE : Constant = Constant::Bool(true);\n const FALSE : Constant = Constant::Bool(false);\n-const ZERO : Constant = Constant::Int(0, UnsuffixedIntLit(Plus));\n-const ONE : Constant = Constant::Int(1, UnsuffixedIntLit(Plus));\n-const TWO : Constant = Constant::Int(2, UnsuffixedIntLit(Plus));\n+const ZERO : Constant = Constant::Int(0, LitIntType::Unsuffixed, Sign::Plus);\n+const ONE : Constant = Constant::Int(1, LitIntType::Unsuffixed, Sign::Plus);\n+const TWO : Constant = Constant::Int(2, LitIntType::Unsuffixed, Sign::Plus);\n \n #[test]\n fn test_lit() {\n-    check(TRUE, &lit(LitBool(true)));\n-    check(FALSE, &lit(LitBool(false)));\n-    check(ZERO, &lit(LitInt(0, UnsuffixedIntLit(Plus))));\n-    check(Constant::Str(\"cool!\".into(), CookedStr), &lit(LitStr(\n-        InternedString::new(\"cool!\"), CookedStr)));\n+    check(TRUE, &lit(LitKind::Bool(true)));\n+    check(FALSE, &lit(LitKind::Bool(false)));\n+    check(ZERO, &lit(LitKind::Int(0, LitIntType::Unsuffixed)));\n+    check(Constant::Str(\"cool!\".into(), StrStyle::Cooked), &lit(LitKind::Str(\n+        InternedString::new(\"cool!\"), StrStyle::Cooked)));\n }\n \n #[test]\n fn test_ops() {\n-    check(TRUE, &binop(BiOr, lit(LitBool(false)), lit(LitBool(true))));\n-    check(FALSE, &binop(BiAnd, lit(LitBool(false)), lit(LitBool(true))));\n+    check(TRUE, &binop(BiOr, lit(LitKind::Bool(false)), lit(LitKind::Bool(true))));\n+    check(FALSE, &binop(BiAnd, lit(LitKind::Bool(false)), lit(LitKind::Bool(true))));\n \n-    let litzero = lit(LitInt(0, UnsuffixedIntLit(Plus)));\n-    let litone = lit(LitInt(1, UnsuffixedIntLit(Plus)));\n+    let litzero = lit(LitKind::Int(0, LitIntType::Unsuffixed));\n+    let litone = lit(LitKind::Int(1, LitIntType::Unsuffixed));\n     check(TRUE, &binop(BiEq, litzero.clone(), litzero.clone()));\n     check(TRUE, &binop(BiGe, litzero.clone(), litzero.clone()));\n     check(TRUE, &binop(BiLe, litzero.clone(), litzero.clone()));"}]}