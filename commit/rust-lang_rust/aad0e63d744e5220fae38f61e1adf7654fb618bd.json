{"sha": "aad0e63d744e5220fae38f61e1adf7654fb618bd", "node_id": "MDY6Q29tbWl0NzI0NzEyOmFhZDBlNjNkNzQ0ZTUyMjBmYWUzOGY2MWUxYWRmNzY1NGZiNjE4YmQ=", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2020-04-01T10:41:46Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2020-04-01T10:41:46Z"}, "message": "Merge #3779\n\n3779: Complete only missing fields in pats r=matklad a=SomeoneToIgnore\n\nA follow-up for https://github.com/rust-analyzer/rust-analyzer/pull/3694\r\n\r\nSame name vs string [issue](https://github.com/rust-analyzer/rust-analyzer/pull/3694#discussion_r396986819) persists here, now I'm able to obtain `ast::Name`, but I see no way to convert it into `hir::Name` or vice versa.\n\nCo-authored-by: Kirill Bulatov <mail4score@gmail.com>", "tree": {"sha": "29b22aec4ad8a83de910da7f7ec5dbde8940fa8b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/29b22aec4ad8a83de910da7f7ec5dbde8940fa8b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/aad0e63d744e5220fae38f61e1adf7654fb618bd", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJehG/qCRBK7hj4Ov3rIwAAdHIIAI2OtWVrCrRObx/dODwZymxK\nGfCQ2/qwn20X48sNYIujS2/DQIai4K6HAO6rPeQAcolQSGGp/a6zaZBPM9FbiAyR\nAeY0edjFK0R/pfbpDbTk9/1o+kFwbfhU1pMbP5oljGP5zhxIyZU53QtXdiOSi1Gd\naqWznn9ugaJMu3nHJthE6aMYHuANnG27HFX2PQiZ/RQRyP1pQh4xLkaIf0FGrErb\nj7ZfPcZZmQYdF5Tp5qEhpj17CilcY50doXMEjltO/4LvaFbw9MWyrJOSZLfqs4x5\nHv34LcNMdTkCltwszFuJCfCUqoVR3WHgmNNmuj/+lVfzRkY6gLMSlQaWzNXyrIw=\n=c+QW\n-----END PGP SIGNATURE-----\n", "payload": "tree 29b22aec4ad8a83de910da7f7ec5dbde8940fa8b\nparent ab284f30ce8a31e9c3d98f29b86bc8067d94376c\nparent 1335608dae47cf8baa1dd2e8809264b030e85c3e\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1585737706 +0000\ncommitter GitHub <noreply@github.com> 1585737706 +0000\n\nMerge #3779\n\n3779: Complete only missing fields in pats r=matklad a=SomeoneToIgnore\n\nA follow-up for https://github.com/rust-analyzer/rust-analyzer/pull/3694\r\n\r\nSame name vs string [issue](https://github.com/rust-analyzer/rust-analyzer/pull/3694#discussion_r396986819) persists here, now I'm able to obtain `ast::Name`, but I see no way to convert it into `hir::Name` or vice versa.\n\nCo-authored-by: Kirill Bulatov <mail4score@gmail.com>\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/aad0e63d744e5220fae38f61e1adf7654fb618bd", "html_url": "https://github.com/rust-lang/rust/commit/aad0e63d744e5220fae38f61e1adf7654fb618bd", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/aad0e63d744e5220fae38f61e1adf7654fb618bd/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ab284f30ce8a31e9c3d98f29b86bc8067d94376c", "url": "https://api.github.com/repos/rust-lang/rust/commits/ab284f30ce8a31e9c3d98f29b86bc8067d94376c", "html_url": "https://github.com/rust-lang/rust/commit/ab284f30ce8a31e9c3d98f29b86bc8067d94376c"}, {"sha": "1335608dae47cf8baa1dd2e8809264b030e85c3e", "url": "https://api.github.com/repos/rust-lang/rust/commits/1335608dae47cf8baa1dd2e8809264b030e85c3e", "html_url": "https://github.com/rust-lang/rust/commit/1335608dae47cf8baa1dd2e8809264b030e85c3e"}], "stats": {"total": 776, "additions": 413, "deletions": 363}, "files": [{"sha": "93157bbba63f4879e7a6dfef5fe6cbcb1b705194", "filename": "crates/ra_ide/src/completion.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/aad0e63d744e5220fae38f61e1adf7654fb618bd/crates%2Fra_ide%2Fsrc%2Fcompletion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aad0e63d744e5220fae38f61e1adf7654fb618bd/crates%2Fra_ide%2Fsrc%2Fcompletion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Fcompletion.rs?ref=aad0e63d744e5220fae38f61e1adf7654fb618bd", "patch": "@@ -5,8 +5,7 @@ mod completion_context;\n mod presentation;\n \n mod complete_dot;\n-mod complete_record_literal;\n-mod complete_record_pattern;\n+mod complete_record;\n mod complete_pattern;\n mod complete_fn_param;\n mod complete_keyword;\n@@ -89,8 +88,7 @@ pub(crate) fn completions(\n     complete_path::complete_path(&mut acc, &ctx);\n     complete_scope::complete_scope(&mut acc, &ctx);\n     complete_dot::complete_dot(&mut acc, &ctx);\n-    complete_record_literal::complete_record_literal(&mut acc, &ctx);\n-    complete_record_pattern::complete_record_pattern(&mut acc, &ctx);\n+    complete_record::complete_record(&mut acc, &ctx);\n     complete_pattern::complete_pattern(&mut acc, &ctx);\n     complete_postfix::complete_postfix(&mut acc, &ctx);\n     complete_macro_in_item_position::complete_macro_in_item_position(&mut acc, &ctx);"}, {"sha": "01dd8c6db70853f5b0b176179b9acd35764ce4fb", "filename": "crates/ra_ide/src/completion/complete_record.rs", "status": "added", "additions": 411, "deletions": 0, "changes": 411, "blob_url": "https://github.com/rust-lang/rust/blob/aad0e63d744e5220fae38f61e1adf7654fb618bd/crates%2Fra_ide%2Fsrc%2Fcompletion%2Fcomplete_record.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aad0e63d744e5220fae38f61e1adf7654fb618bd/crates%2Fra_ide%2Fsrc%2Fcompletion%2Fcomplete_record.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Fcompletion%2Fcomplete_record.rs?ref=aad0e63d744e5220fae38f61e1adf7654fb618bd", "patch": "@@ -0,0 +1,411 @@\n+//! Complete fields in record literals and patterns.\n+use crate::completion::{CompletionContext, Completions};\n+use ra_syntax::{ast, ast::NameOwner, SmolStr};\n+\n+pub(super) fn complete_record(acc: &mut Completions, ctx: &CompletionContext) -> Option<()> {\n+    let (ty, variant, already_present_fields) =\n+        match (ctx.record_lit_pat.as_ref(), ctx.record_lit_syntax.as_ref()) {\n+            (None, None) => return None,\n+            (Some(_), Some(_)) => panic!(\"A record cannot be both a literal and a pattern\"),\n+            (Some(record_pat), _) => (\n+                ctx.sema.type_of_pat(&record_pat.clone().into())?,\n+                ctx.sema.resolve_record_pattern(record_pat)?,\n+                pattern_ascribed_fields(record_pat),\n+            ),\n+            (_, Some(record_lit)) => (\n+                ctx.sema.type_of_expr(&record_lit.clone().into())?,\n+                ctx.sema.resolve_record_literal(record_lit)?,\n+                literal_ascribed_fields(record_lit),\n+            ),\n+        };\n+\n+    for (field, field_ty) in ty.variant_fields(ctx.db, variant).into_iter().filter(|(field, _)| {\n+        // FIXME: already_present_names better be `Vec<hir::Name>`\n+        !already_present_fields.contains(&SmolStr::from(field.name(ctx.db).to_string()))\n+    }) {\n+        acc.add_field(ctx, field, &field_ty);\n+    }\n+    Some(())\n+}\n+\n+fn literal_ascribed_fields(record_lit: &ast::RecordLit) -> Vec<SmolStr> {\n+    record_lit\n+        .record_field_list()\n+        .map(|field_list| field_list.fields())\n+        .map(|fields| {\n+            fields\n+                .into_iter()\n+                .filter_map(|field| field.name_ref())\n+                .map(|name_ref| name_ref.text().clone())\n+                .collect()\n+        })\n+        .unwrap_or_default()\n+}\n+\n+fn pattern_ascribed_fields(record_pat: &ast::RecordPat) -> Vec<SmolStr> {\n+    record_pat\n+        .record_field_pat_list()\n+        .map(|pat_list| {\n+            pat_list\n+                .record_field_pats()\n+                .filter_map(|fild_pat| fild_pat.name())\n+                .chain(pat_list.bind_pats().filter_map(|bind_pat| bind_pat.name()))\n+                .map(|name| name.text().clone())\n+                .collect()\n+        })\n+        .unwrap_or_default()\n+}\n+\n+#[cfg(test)]\n+mod tests {\n+    mod record_lit_tests {\n+        use crate::completion::{test_utils::do_completion, CompletionItem, CompletionKind};\n+        use insta::assert_debug_snapshot;\n+\n+        fn complete(code: &str) -> Vec<CompletionItem> {\n+            do_completion(code, CompletionKind::Reference)\n+        }\n+\n+        #[test]\n+        fn test_record_pattern_field() {\n+            let completions = complete(\n+                r\"\n+            struct S { foo: u32 }\n+\n+            fn process(f: S) {\n+                match f {\n+                    S { f<|>: 92 } => (),\n+                }\n+            }\n+            \",\n+            );\n+            assert_debug_snapshot!(completions, @r###\"\n+        [\n+            CompletionItem {\n+                label: \"foo\",\n+                source_range: [117; 118),\n+                delete: [117; 118),\n+                insert: \"foo\",\n+                kind: Field,\n+                detail: \"u32\",\n+            },\n+        ]\n+        \"###);\n+        }\n+\n+        #[test]\n+        fn test_record_pattern_enum_variant() {\n+            let completions = complete(\n+                r\"\n+            enum E {\n+                S { foo: u32, bar: () }\n+            }\n+\n+            fn process(e: E) {\n+                match e {\n+                    E::S { <|> } => (),\n+                }\n+            }\n+            \",\n+            );\n+            assert_debug_snapshot!(completions, @r###\"\n+        [\n+            CompletionItem {\n+                label: \"bar\",\n+                source_range: [161; 161),\n+                delete: [161; 161),\n+                insert: \"bar\",\n+                kind: Field,\n+                detail: \"()\",\n+            },\n+            CompletionItem {\n+                label: \"foo\",\n+                source_range: [161; 161),\n+                delete: [161; 161),\n+                insert: \"foo\",\n+                kind: Field,\n+                detail: \"u32\",\n+            },\n+        ]\n+        \"###);\n+        }\n+\n+        #[test]\n+        fn test_record_pattern_field_in_simple_macro() {\n+            let completions = complete(\n+                r\"\n+            macro_rules! m { ($e:expr) => { $e } }\n+            struct S { foo: u32 }\n+\n+            fn process(f: S) {\n+                m!(match f {\n+                    S { f<|>: 92 } => (),\n+                })\n+            }\n+            \",\n+            );\n+            assert_debug_snapshot!(completions, @r###\"\n+        [\n+            CompletionItem {\n+                label: \"foo\",\n+                source_range: [171; 172),\n+                delete: [171; 172),\n+                insert: \"foo\",\n+                kind: Field,\n+                detail: \"u32\",\n+            },\n+        ]\n+        \"###);\n+        }\n+\n+        #[test]\n+        fn only_missing_fields_are_completed_in_destruct_pats() {\n+            let completions = complete(\n+                r\"\n+            struct S {\n+                foo1: u32,\n+                foo2: u32,\n+                bar: u32,\n+                baz: u32,\n+            }\n+\n+            fn main() {\n+                let s = S {\n+                    foo1: 1,\n+                    foo2: 2,\n+                    bar: 3,\n+                    baz: 4,\n+                };\n+                if let S { foo1, foo2: a, <|> } = s {}\n+            }\n+            \",\n+            );\n+            assert_debug_snapshot!(completions, @r###\"\n+        [\n+            CompletionItem {\n+                label: \"bar\",\n+                source_range: [372; 372),\n+                delete: [372; 372),\n+                insert: \"bar\",\n+                kind: Field,\n+                detail: \"u32\",\n+            },\n+            CompletionItem {\n+                label: \"baz\",\n+                source_range: [372; 372),\n+                delete: [372; 372),\n+                insert: \"baz\",\n+                kind: Field,\n+                detail: \"u32\",\n+            },\n+        ]\n+        \"###);\n+        }\n+    }\n+\n+    mod record_pat_tests {\n+        use crate::completion::{test_utils::do_completion, CompletionItem, CompletionKind};\n+        use insta::assert_debug_snapshot;\n+\n+        fn complete(code: &str) -> Vec<CompletionItem> {\n+            do_completion(code, CompletionKind::Reference)\n+        }\n+\n+        #[test]\n+        fn test_record_literal_deprecated_field() {\n+            let completions = complete(\n+                r\"\n+            struct A {\n+                #[deprecated]\n+                the_field: u32,\n+            }\n+            fn foo() {\n+               A { the<|> }\n+            }\n+            \",\n+            );\n+            assert_debug_snapshot!(completions, @r###\"\n+        [\n+            CompletionItem {\n+                label: \"the_field\",\n+                source_range: [142; 145),\n+                delete: [142; 145),\n+                insert: \"the_field\",\n+                kind: Field,\n+                detail: \"u32\",\n+                deprecated: true,\n+            },\n+        ]\n+        \"###);\n+        }\n+\n+        #[test]\n+        fn test_record_literal_field() {\n+            let completions = complete(\n+                r\"\n+            struct A { the_field: u32 }\n+            fn foo() {\n+               A { the<|> }\n+            }\n+            \",\n+            );\n+            assert_debug_snapshot!(completions, @r###\"\n+        [\n+            CompletionItem {\n+                label: \"the_field\",\n+                source_range: [83; 86),\n+                delete: [83; 86),\n+                insert: \"the_field\",\n+                kind: Field,\n+                detail: \"u32\",\n+            },\n+        ]\n+        \"###);\n+        }\n+\n+        #[test]\n+        fn test_record_literal_enum_variant() {\n+            let completions = complete(\n+                r\"\n+            enum E {\n+                A { a: u32 }\n+            }\n+            fn foo() {\n+                let _ = E::A { <|> }\n+            }\n+            \",\n+            );\n+            assert_debug_snapshot!(completions, @r###\"\n+        [\n+            CompletionItem {\n+                label: \"a\",\n+                source_range: [119; 119),\n+                delete: [119; 119),\n+                insert: \"a\",\n+                kind: Field,\n+                detail: \"u32\",\n+            },\n+        ]\n+        \"###);\n+        }\n+\n+        #[test]\n+        fn test_record_literal_two_structs() {\n+            let completions = complete(\n+                r\"\n+            struct A { a: u32 }\n+            struct B { b: u32 }\n+\n+            fn foo() {\n+               let _: A = B { <|> }\n+            }\n+            \",\n+            );\n+            assert_debug_snapshot!(completions, @r###\"\n+        [\n+            CompletionItem {\n+                label: \"b\",\n+                source_range: [119; 119),\n+                delete: [119; 119),\n+                insert: \"b\",\n+                kind: Field,\n+                detail: \"u32\",\n+            },\n+        ]\n+        \"###);\n+        }\n+\n+        #[test]\n+        fn test_record_literal_generic_struct() {\n+            let completions = complete(\n+                r\"\n+            struct A<T> { a: T }\n+\n+            fn foo() {\n+               let _: A<u32> = A { <|> }\n+            }\n+            \",\n+            );\n+            assert_debug_snapshot!(completions, @r###\"\n+        [\n+            CompletionItem {\n+                label: \"a\",\n+                source_range: [93; 93),\n+                delete: [93; 93),\n+                insert: \"a\",\n+                kind: Field,\n+                detail: \"u32\",\n+            },\n+        ]\n+        \"###);\n+        }\n+\n+        #[test]\n+        fn test_record_literal_field_in_simple_macro() {\n+            let completions = complete(\n+                r\"\n+            macro_rules! m { ($e:expr) => { $e } }\n+            struct A { the_field: u32 }\n+            fn foo() {\n+               m!(A { the<|> })\n+            }\n+            \",\n+            );\n+            assert_debug_snapshot!(completions, @r###\"\n+        [\n+            CompletionItem {\n+                label: \"the_field\",\n+                source_range: [137; 140),\n+                delete: [137; 140),\n+                insert: \"the_field\",\n+                kind: Field,\n+                detail: \"u32\",\n+            },\n+        ]\n+        \"###);\n+        }\n+\n+        #[test]\n+        fn only_missing_fields_are_completed() {\n+            let completions = complete(\n+                r\"\n+            struct S {\n+                foo1: u32,\n+                foo2: u32,\n+                bar: u32,\n+                baz: u32,\n+            }\n+\n+            fn main() {\n+                let foo1 = 1;\n+                let s = S {\n+                    foo1,\n+                    foo2: 5,\n+                    <|>\n+                }\n+            }\n+            \",\n+            );\n+            assert_debug_snapshot!(completions, @r###\"\n+        [\n+            CompletionItem {\n+                label: \"bar\",\n+                source_range: [302; 302),\n+                delete: [302; 302),\n+                insert: \"bar\",\n+                kind: Field,\n+                detail: \"u32\",\n+            },\n+            CompletionItem {\n+                label: \"baz\",\n+                source_range: [302; 302),\n+                delete: [302; 302),\n+                insert: \"baz\",\n+                kind: Field,\n+                detail: \"u32\",\n+            },\n+        ]\n+        \"###);\n+        }\n+    }\n+}"}, {"sha": "e4e764f58242c79dfdc4f3527790d83c48cbc21c", "filename": "crates/ra_ide/src/completion/complete_record_literal.rs", "status": "removed", "additions": 0, "deletions": 241, "changes": 241, "blob_url": "https://github.com/rust-lang/rust/blob/ab284f30ce8a31e9c3d98f29b86bc8067d94376c/crates%2Fra_ide%2Fsrc%2Fcompletion%2Fcomplete_record_literal.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab284f30ce8a31e9c3d98f29b86bc8067d94376c/crates%2Fra_ide%2Fsrc%2Fcompletion%2Fcomplete_record_literal.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Fcompletion%2Fcomplete_record_literal.rs?ref=ab284f30ce8a31e9c3d98f29b86bc8067d94376c", "patch": "@@ -1,241 +0,0 @@\n-//! FIXME: write short doc here\n-\n-use crate::completion::{CompletionContext, Completions};\n-use ra_syntax::SmolStr;\n-\n-/// Complete fields in fields literals.\n-pub(super) fn complete_record_literal(acc: &mut Completions, ctx: &CompletionContext) {\n-    let (ty, variant) = match ctx.record_lit_syntax.as_ref().and_then(|it| {\n-        Some((ctx.sema.type_of_expr(&it.clone().into())?, ctx.sema.resolve_record_literal(it)?))\n-    }) {\n-        Some(it) => it,\n-        _ => return,\n-    };\n-\n-    let already_present_names: Vec<SmolStr> = ctx\n-        .record_lit_syntax\n-        .as_ref()\n-        .and_then(|record_literal| record_literal.record_field_list())\n-        .map(|field_list| field_list.fields())\n-        .map(|fields| {\n-            fields\n-                .into_iter()\n-                .filter_map(|field| field.name_ref())\n-                .map(|name_ref| name_ref.text().clone())\n-                .collect()\n-        })\n-        .unwrap_or_default();\n-\n-    for (field, field_ty) in ty.variant_fields(ctx.db, variant) {\n-        if !already_present_names.contains(&SmolStr::from(field.name(ctx.db).to_string())) {\n-            acc.add_field(ctx, field, &field_ty);\n-        }\n-    }\n-}\n-\n-#[cfg(test)]\n-mod tests {\n-    use crate::completion::{test_utils::do_completion, CompletionItem, CompletionKind};\n-    use insta::assert_debug_snapshot;\n-\n-    fn complete(code: &str) -> Vec<CompletionItem> {\n-        do_completion(code, CompletionKind::Reference)\n-    }\n-\n-    #[test]\n-    fn test_record_literal_deprecated_field() {\n-        let completions = complete(\n-            r\"\n-            struct A {\n-                #[deprecated]\n-                the_field: u32,\n-            }\n-            fn foo() {\n-               A { the<|> }\n-            }\n-            \",\n-        );\n-        assert_debug_snapshot!(completions, @r###\"\n-        [\n-            CompletionItem {\n-                label: \"the_field\",\n-                source_range: [142; 145),\n-                delete: [142; 145),\n-                insert: \"the_field\",\n-                kind: Field,\n-                detail: \"u32\",\n-                deprecated: true,\n-            },\n-        ]\n-        \"###);\n-    }\n-\n-    #[test]\n-    fn test_record_literal_field() {\n-        let completions = complete(\n-            r\"\n-            struct A { the_field: u32 }\n-            fn foo() {\n-               A { the<|> }\n-            }\n-            \",\n-        );\n-        assert_debug_snapshot!(completions, @r###\"\n-        [\n-            CompletionItem {\n-                label: \"the_field\",\n-                source_range: [83; 86),\n-                delete: [83; 86),\n-                insert: \"the_field\",\n-                kind: Field,\n-                detail: \"u32\",\n-            },\n-        ]\n-        \"###);\n-    }\n-\n-    #[test]\n-    fn test_record_literal_enum_variant() {\n-        let completions = complete(\n-            r\"\n-            enum E {\n-                A { a: u32 }\n-            }\n-            fn foo() {\n-                let _ = E::A { <|> }\n-            }\n-            \",\n-        );\n-        assert_debug_snapshot!(completions, @r###\"\n-        [\n-            CompletionItem {\n-                label: \"a\",\n-                source_range: [119; 119),\n-                delete: [119; 119),\n-                insert: \"a\",\n-                kind: Field,\n-                detail: \"u32\",\n-            },\n-        ]\n-        \"###);\n-    }\n-\n-    #[test]\n-    fn test_record_literal_two_structs() {\n-        let completions = complete(\n-            r\"\n-            struct A { a: u32 }\n-            struct B { b: u32 }\n-\n-            fn foo() {\n-               let _: A = B { <|> }\n-            }\n-            \",\n-        );\n-        assert_debug_snapshot!(completions, @r###\"\n-        [\n-            CompletionItem {\n-                label: \"b\",\n-                source_range: [119; 119),\n-                delete: [119; 119),\n-                insert: \"b\",\n-                kind: Field,\n-                detail: \"u32\",\n-            },\n-        ]\n-        \"###);\n-    }\n-\n-    #[test]\n-    fn test_record_literal_generic_struct() {\n-        let completions = complete(\n-            r\"\n-            struct A<T> { a: T }\n-\n-            fn foo() {\n-               let _: A<u32> = A { <|> }\n-            }\n-            \",\n-        );\n-        assert_debug_snapshot!(completions, @r###\"\n-        [\n-            CompletionItem {\n-                label: \"a\",\n-                source_range: [93; 93),\n-                delete: [93; 93),\n-                insert: \"a\",\n-                kind: Field,\n-                detail: \"u32\",\n-            },\n-        ]\n-        \"###);\n-    }\n-\n-    #[test]\n-    fn test_record_literal_field_in_simple_macro() {\n-        let completions = complete(\n-            r\"\n-            macro_rules! m { ($e:expr) => { $e } }\n-            struct A { the_field: u32 }\n-            fn foo() {\n-               m!(A { the<|> })\n-            }\n-            \",\n-        );\n-        assert_debug_snapshot!(completions, @r###\"\n-        [\n-            CompletionItem {\n-                label: \"the_field\",\n-                source_range: [137; 140),\n-                delete: [137; 140),\n-                insert: \"the_field\",\n-                kind: Field,\n-                detail: \"u32\",\n-            },\n-        ]\n-        \"###);\n-    }\n-\n-    #[test]\n-    fn only_missing_fields_are_completed() {\n-        let completions = complete(\n-            r\"\n-            struct S {\n-                foo1: u32,\n-                foo2: u32,\n-                bar: u32,\n-                baz: u32,\n-            }\n-\n-            fn main() {\n-                let foo1 = 1;\n-                let s = S {\n-                    foo1,\n-                    foo2: 5,\n-                    <|>\n-                }\n-            }\n-            \",\n-        );\n-        assert_debug_snapshot!(completions, @r###\"\n-        [\n-            CompletionItem {\n-                label: \"bar\",\n-                source_range: [302; 302),\n-                delete: [302; 302),\n-                insert: \"bar\",\n-                kind: Field,\n-                detail: \"u32\",\n-            },\n-            CompletionItem {\n-                label: \"baz\",\n-                source_range: [302; 302),\n-                delete: [302; 302),\n-                insert: \"baz\",\n-                kind: Field,\n-                detail: \"u32\",\n-            },\n-        ]\n-        \"###);\n-    }\n-}"}, {"sha": "962376428c48c154c90250fd117b03408f6001ea", "filename": "crates/ra_ide/src/completion/complete_record_pattern.rs", "status": "removed", "additions": 0, "deletions": 118, "changes": 118, "blob_url": "https://github.com/rust-lang/rust/blob/ab284f30ce8a31e9c3d98f29b86bc8067d94376c/crates%2Fra_ide%2Fsrc%2Fcompletion%2Fcomplete_record_pattern.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab284f30ce8a31e9c3d98f29b86bc8067d94376c/crates%2Fra_ide%2Fsrc%2Fcompletion%2Fcomplete_record_pattern.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Fcompletion%2Fcomplete_record_pattern.rs?ref=ab284f30ce8a31e9c3d98f29b86bc8067d94376c", "patch": "@@ -1,118 +0,0 @@\n-//! FIXME: write short doc here\n-\n-use crate::completion::{CompletionContext, Completions};\n-\n-pub(super) fn complete_record_pattern(acc: &mut Completions, ctx: &CompletionContext) {\n-    let (ty, variant) = match ctx.record_lit_pat.as_ref().and_then(|it| {\n-        Some((ctx.sema.type_of_pat(&it.clone().into())?, ctx.sema.resolve_record_pattern(it)?))\n-    }) {\n-        Some(it) => it,\n-        _ => return,\n-    };\n-\n-    for (field, field_ty) in ty.variant_fields(ctx.db, variant) {\n-        acc.add_field(ctx, field, &field_ty);\n-    }\n-}\n-\n-#[cfg(test)]\n-mod tests {\n-    use crate::completion::{test_utils::do_completion, CompletionItem, CompletionKind};\n-    use insta::assert_debug_snapshot;\n-\n-    fn complete(code: &str) -> Vec<CompletionItem> {\n-        do_completion(code, CompletionKind::Reference)\n-    }\n-\n-    #[test]\n-    fn test_record_pattern_field() {\n-        let completions = complete(\n-            r\"\n-            struct S { foo: u32 }\n-\n-            fn process(f: S) {\n-                match f {\n-                    S { f<|>: 92 } => (),\n-                }\n-            }\n-            \",\n-        );\n-        assert_debug_snapshot!(completions, @r###\"\n-        [\n-            CompletionItem {\n-                label: \"foo\",\n-                source_range: [117; 118),\n-                delete: [117; 118),\n-                insert: \"foo\",\n-                kind: Field,\n-                detail: \"u32\",\n-            },\n-        ]\n-        \"###);\n-    }\n-\n-    #[test]\n-    fn test_record_pattern_enum_variant() {\n-        let completions = complete(\n-            r\"\n-            enum E {\n-                S { foo: u32, bar: () }\n-            }\n-\n-            fn process(e: E) {\n-                match e {\n-                    E::S { <|> } => (),\n-                }\n-            }\n-            \",\n-        );\n-        assert_debug_snapshot!(completions, @r###\"\n-        [\n-            CompletionItem {\n-                label: \"bar\",\n-                source_range: [161; 161),\n-                delete: [161; 161),\n-                insert: \"bar\",\n-                kind: Field,\n-                detail: \"()\",\n-            },\n-            CompletionItem {\n-                label: \"foo\",\n-                source_range: [161; 161),\n-                delete: [161; 161),\n-                insert: \"foo\",\n-                kind: Field,\n-                detail: \"u32\",\n-            },\n-        ]\n-        \"###);\n-    }\n-\n-    #[test]\n-    fn test_record_pattern_field_in_simple_macro() {\n-        let completions = complete(\n-            r\"\n-            macro_rules! m { ($e:expr) => { $e } }\n-            struct S { foo: u32 }\n-\n-            fn process(f: S) {\n-                m!(match f {\n-                    S { f<|>: 92 } => (),\n-                })\n-            }\n-            \",\n-        );\n-        assert_debug_snapshot!(completions, @r###\"\n-        [\n-            CompletionItem {\n-                label: \"foo\",\n-                source_range: [171; 172),\n-                delete: [171; 172),\n-                insert: \"foo\",\n-                kind: Field,\n-                detail: \"u32\",\n-            },\n-        ]\n-        \"###);\n-    }\n-}"}]}