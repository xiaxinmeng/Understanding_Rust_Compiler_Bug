{"sha": "02c9e73e6ca7e2bd444d39182f8dee7e2ba4a609", "node_id": "C_kwDOAAsO6NoAKDAyYzllNzNlNmNhN2UyYmQ0NDRkMzkxODJmOGRlZTdlMmJhNGE2MDk", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-01-14T14:20:17Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-01-14T14:20:17Z"}, "message": "Auto merge of #92681 - Aaron1011:task-deps-ref, r=cjgillot\n\nIntroduce new `TaskDepsRef` enum to track allow/ignore/forbid status", "tree": {"sha": "0be846dc706b5e67b88e8b6e9262acb900b5d10d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0be846dc706b5e67b88e8b6e9262acb900b5d10d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/02c9e73e6ca7e2bd444d39182f8dee7e2ba4a609", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/02c9e73e6ca7e2bd444d39182f8dee7e2ba4a609", "html_url": "https://github.com/rust-lang/rust/commit/02c9e73e6ca7e2bd444d39182f8dee7e2ba4a609", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/02c9e73e6ca7e2bd444d39182f8dee7e2ba4a609/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "86f7f78f05ff8295aad2ad2a31770ce4408cc849", "url": "https://api.github.com/repos/rust-lang/rust/commits/86f7f78f05ff8295aad2ad2a31770ce4408cc849", "html_url": "https://github.com/rust-lang/rust/commit/86f7f78f05ff8295aad2ad2a31770ce4408cc849"}, {"sha": "f64cd87ca6169f118bad20ee23acced0e67cc6ea", "url": "https://api.github.com/repos/rust-lang/rust/commits/f64cd87ca6169f118bad20ee23acced0e67cc6ea", "html_url": "https://github.com/rust-lang/rust/commit/f64cd87ca6169f118bad20ee23acced0e67cc6ea"}], "stats": {"total": 148, "additions": 87, "deletions": 61}, "files": [{"sha": "cf50378ad606baa93e44abc69d7bbf0ff098aac5", "filename": "compiler/rustc_middle/src/dep_graph/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/02c9e73e6ca7e2bd444d39182f8dee7e2ba4a609/compiler%2Frustc_middle%2Fsrc%2Fdep_graph%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02c9e73e6ca7e2bd444d39182f8dee7e2ba4a609/compiler%2Frustc_middle%2Fsrc%2Fdep_graph%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fdep_graph%2Fmod.rs?ref=02c9e73e6ca7e2bd444d39182f8dee7e2ba4a609", "patch": "@@ -1,6 +1,5 @@\n use crate::ty::{self, TyCtxt};\n use rustc_data_structures::profiling::SelfProfilerRef;\n-use rustc_data_structures::sync::Lock;\n use rustc_query_system::ich::StableHashingContext;\n use rustc_session::Session;\n \n@@ -17,6 +16,7 @@ crate use dep_node::{make_compile_codegen_unit, make_compile_mono_item};\n \n pub type DepGraph = rustc_query_system::dep_graph::DepGraph<DepKind>;\n pub type TaskDeps = rustc_query_system::dep_graph::TaskDeps<DepKind>;\n+pub type TaskDepsRef<'a> = rustc_query_system::dep_graph::TaskDepsRef<'a, DepKind>;\n pub type DepGraphQuery = rustc_query_system::dep_graph::DepGraphQuery<DepKind>;\n pub type SerializedDepGraph = rustc_query_system::dep_graph::SerializedDepGraph<DepKind>;\n pub type EdgeFilter = rustc_query_system::dep_graph::debug::EdgeFilter<DepKind>;\n@@ -45,7 +45,7 @@ impl rustc_query_system::dep_graph::DepKind for DepKind {\n         write!(f, \")\")\n     }\n \n-    fn with_deps<OP, R>(task_deps: Option<&Lock<TaskDeps>>, op: OP) -> R\n+    fn with_deps<OP, R>(task_deps: TaskDepsRef<'_>, op: OP) -> R\n     where\n         OP: FnOnce() -> R,\n     {\n@@ -58,7 +58,7 @@ impl rustc_query_system::dep_graph::DepKind for DepKind {\n \n     fn read_deps<OP>(op: OP)\n     where\n-        OP: for<'a> FnOnce(Option<&'a Lock<TaskDeps>>),\n+        OP: for<'a> FnOnce(TaskDepsRef<'a>),\n     {\n         ty::tls::with_context_opt(|icx| {\n             let icx = if let Some(icx) = icx { icx } else { return };"}, {"sha": "ecc6da6da12a71be85d598686b934d451632a9a7", "filename": "compiler/rustc_middle/src/ty/context.rs", "status": "modified", "additions": 9, "deletions": 3, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/02c9e73e6ca7e2bd444d39182f8dee7e2ba4a609/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02c9e73e6ca7e2bd444d39182f8dee7e2ba4a609/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs?ref=02c9e73e6ca7e2bd444d39182f8dee7e2ba4a609", "patch": "@@ -1661,7 +1661,7 @@ CloneLiftImpls! { for<'tcx> { Constness, traits::WellFormedLoc, } }\n pub mod tls {\n     use super::{ptr_eq, GlobalCtxt, TyCtxt};\n \n-    use crate::dep_graph::{DepKind, TaskDeps};\n+    use crate::dep_graph::{DepKind, TaskDepsRef};\n     use crate::ty::query;\n     use rustc_data_structures::sync::{self, Lock};\n     use rustc_data_structures::thin_vec::ThinVec;\n@@ -1697,13 +1697,19 @@ pub mod tls {\n \n         /// The current dep graph task. This is used to add dependencies to queries\n         /// when executing them.\n-        pub task_deps: Option<&'a Lock<TaskDeps>>,\n+        pub task_deps: TaskDepsRef<'a>,\n     }\n \n     impl<'a, 'tcx> ImplicitCtxt<'a, 'tcx> {\n         pub fn new(gcx: &'tcx GlobalCtxt<'tcx>) -> Self {\n             let tcx = TyCtxt { gcx };\n-            ImplicitCtxt { tcx, query: None, diagnostics: None, layout_depth: 0, task_deps: None }\n+            ImplicitCtxt {\n+                tcx,\n+                query: None,\n+                diagnostics: None,\n+                layout_depth: 0,\n+                task_deps: TaskDepsRef::Ignore,\n+            }\n         }\n     }\n "}, {"sha": "a080b4a3e9ab58b5eba37cba571782db85d4b7af", "filename": "compiler/rustc_query_system/src/dep_graph/graph.rs", "status": "modified", "additions": 70, "deletions": 51, "changes": 121, "blob_url": "https://github.com/rust-lang/rust/blob/02c9e73e6ca7e2bd444d39182f8dee7e2ba4a609/compiler%2Frustc_query_system%2Fsrc%2Fdep_graph%2Fgraph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02c9e73e6ca7e2bd444d39182f8dee7e2ba4a609/compiler%2Frustc_query_system%2Fsrc%2Fdep_graph%2Fgraph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_query_system%2Fsrc%2Fdep_graph%2Fgraph.rs?ref=02c9e73e6ca7e2bd444d39182f8dee7e2ba4a609", "patch": "@@ -9,6 +9,7 @@ use rustc_data_structures::sync::{AtomicU32, AtomicU64, Lock, Lrc, Ordering};\n use rustc_index::vec::IndexVec;\n use rustc_serialize::opaque::{FileEncodeResult, FileEncoder};\n use smallvec::{smallvec, SmallVec};\n+use std::assert_matches::assert_matches;\n use std::collections::hash_map::Entry;\n use std::fmt::Debug;\n use std::hash::Hash;\n@@ -165,7 +166,11 @@ impl<K: DepKind> DepGraph<K> {\n     pub fn assert_ignored(&self) {\n         if let Some(..) = self.data {\n             K::read_deps(|task_deps| {\n-                assert!(task_deps.is_none(), \"expected no task dependency tracking\");\n+                assert_matches!(\n+                    task_deps,\n+                    TaskDepsRef::Ignore,\n+                    \"expected no task dependency tracking\"\n+                );\n             })\n         }\n     }\n@@ -174,7 +179,7 @@ impl<K: DepKind> DepGraph<K> {\n     where\n         OP: FnOnce() -> R,\n     {\n-        K::with_deps(None, op)\n+        K::with_deps(TaskDepsRef::Ignore, op)\n     }\n \n     /// Used to wrap the deserialization of a query result from disk,\n@@ -227,10 +232,7 @@ impl<K: DepKind> DepGraph<K> {\n     where\n         OP: FnOnce() -> R,\n     {\n-        let mut deps = TaskDeps::default();\n-        deps.read_allowed = false;\n-        let deps = Lock::new(deps);\n-        K::with_deps(Some(&deps), op)\n+        K::with_deps(TaskDepsRef::Forbid, op)\n     }\n \n     /// Starts a new dep-graph task. Dep-graph tasks are specified\n@@ -313,10 +315,15 @@ impl<K: DepKind> DepGraph<K> {\n                 reads: SmallVec::new(),\n                 read_set: Default::default(),\n                 phantom_data: PhantomData,\n-                read_allowed: true,\n             }))\n         };\n-        let result = K::with_deps(task_deps.as_ref(), || task(cx, arg));\n+\n+        let task_deps_ref = match &task_deps {\n+            Some(deps) => TaskDepsRef::Allow(deps),\n+            None => TaskDepsRef::Ignore,\n+        };\n+\n+        let result = K::with_deps(task_deps_ref, || task(cx, arg));\n         let edges = task_deps.map_or_else(|| smallvec![], |lock| lock.into_inner().reads);\n \n         let dcx = cx.dep_context();\n@@ -369,7 +376,7 @@ impl<K: DepKind> DepGraph<K> {\n \n         if let Some(ref data) = self.data {\n             let task_deps = Lock::new(TaskDeps::default());\n-            let result = K::with_deps(Some(&task_deps), op);\n+            let result = K::with_deps(TaskDepsRef::Allow(&task_deps), op);\n             let task_deps = task_deps.into_inner();\n             let task_deps = task_deps.reads;\n \n@@ -422,47 +429,47 @@ impl<K: DepKind> DepGraph<K> {\n     pub fn read_index(&self, dep_node_index: DepNodeIndex) {\n         if let Some(ref data) = self.data {\n             K::read_deps(|task_deps| {\n-                if let Some(task_deps) = task_deps {\n-                    let mut task_deps = task_deps.lock();\n-                    let task_deps = &mut *task_deps;\n-\n-                    if !task_deps.read_allowed {\n-                        panic!(\"Illegal read of: {:?}\", dep_node_index);\n+                let mut task_deps = match task_deps {\n+                    TaskDepsRef::Allow(deps) => deps.lock(),\n+                    TaskDepsRef::Ignore => return,\n+                    TaskDepsRef::Forbid => {\n+                        panic!(\"Illegal read of: {:?}\", dep_node_index)\n                     }\n+                };\n+                let task_deps = &mut *task_deps;\n \n-                    if cfg!(debug_assertions) {\n-                        data.current.total_read_count.fetch_add(1, Relaxed);\n-                    }\n+                if cfg!(debug_assertions) {\n+                    data.current.total_read_count.fetch_add(1, Relaxed);\n+                }\n \n-                    // As long as we only have a low number of reads we can avoid doing a hash\n-                    // insert and potentially allocating/reallocating the hashmap\n-                    let new_read = if task_deps.reads.len() < TASK_DEPS_READS_CAP {\n-                        task_deps.reads.iter().all(|other| *other != dep_node_index)\n-                    } else {\n-                        task_deps.read_set.insert(dep_node_index)\n-                    };\n-                    if new_read {\n-                        task_deps.reads.push(dep_node_index);\n-                        if task_deps.reads.len() == TASK_DEPS_READS_CAP {\n-                            // Fill `read_set` with what we have so far so we can use the hashset\n-                            // next time\n-                            task_deps.read_set.extend(task_deps.reads.iter().copied());\n-                        }\n+                // As long as we only have a low number of reads we can avoid doing a hash\n+                // insert and potentially allocating/reallocating the hashmap\n+                let new_read = if task_deps.reads.len() < TASK_DEPS_READS_CAP {\n+                    task_deps.reads.iter().all(|other| *other != dep_node_index)\n+                } else {\n+                    task_deps.read_set.insert(dep_node_index)\n+                };\n+                if new_read {\n+                    task_deps.reads.push(dep_node_index);\n+                    if task_deps.reads.len() == TASK_DEPS_READS_CAP {\n+                        // Fill `read_set` with what we have so far so we can use the hashset\n+                        // next time\n+                        task_deps.read_set.extend(task_deps.reads.iter().copied());\n+                    }\n \n-                        #[cfg(debug_assertions)]\n-                        {\n-                            if let Some(target) = task_deps.node {\n-                                if let Some(ref forbidden_edge) = data.current.forbidden_edge {\n-                                    let src = forbidden_edge.index_to_node.lock()[&dep_node_index];\n-                                    if forbidden_edge.test(&src, &target) {\n-                                        panic!(\"forbidden edge {:?} -> {:?} created\", src, target)\n-                                    }\n+                    #[cfg(debug_assertions)]\n+                    {\n+                        if let Some(target) = task_deps.node {\n+                            if let Some(ref forbidden_edge) = data.current.forbidden_edge {\n+                                let src = forbidden_edge.index_to_node.lock()[&dep_node_index];\n+                                if forbidden_edge.test(&src, &target) {\n+                                    panic!(\"forbidden edge {:?} -> {:?} created\", src, target)\n                                 }\n                             }\n                         }\n-                    } else if cfg!(debug_assertions) {\n-                        data.current.total_duplicate_read_count.fetch_add(1, Relaxed);\n                     }\n+                } else if cfg!(debug_assertions) {\n+                    data.current.total_duplicate_read_count.fetch_add(1, Relaxed);\n                 }\n             })\n         }\n@@ -1185,29 +1192,41 @@ impl<K: DepKind> CurrentDepGraph<K> {\n const TASK_DEPS_READS_CAP: usize = 8;\n type EdgesVec = SmallVec<[DepNodeIndex; TASK_DEPS_READS_CAP]>;\n \n-pub struct TaskDeps<K> {\n+#[derive(Debug, Clone, Copy)]\n+pub enum TaskDepsRef<'a, K: DepKind> {\n+    /// New dependencies can be added to the\n+    /// `TaskDeps`. This is used when executing a 'normal' query\n+    /// (no `eval_always` modifier)\n+    Allow(&'a Lock<TaskDeps<K>>),\n+    /// New dependencies are ignored. This is used when\n+    /// executing an `eval_always` query, since there's no\n+    /// need to track dependencies for a query that's always\n+    /// re-executed. This is also used for `dep_graph.with_ignore`\n+    Ignore,\n+    /// Any attempt to add new dependencies will cause a panic.\n+    /// This is used when decoding a query result from disk,\n+    /// to ensure that the decoding process doesn't itself\n+    /// require the execution of any queries.\n+    Forbid,\n+}\n+\n+#[derive(Debug)]\n+pub struct TaskDeps<K: DepKind> {\n     #[cfg(debug_assertions)]\n     node: Option<DepNode<K>>,\n     reads: EdgesVec,\n     read_set: FxHashSet<DepNodeIndex>,\n     phantom_data: PhantomData<DepNode<K>>,\n-    /// Whether or not we allow `DepGraph::read_index` to run.\n-    /// This is normally true, except inside `with_query_deserialization`,\n-    /// where it set to `false` to enforce that no new `DepNode` edges are\n-    /// created. See the documentation of `with_query_deserialization` for\n-    /// more details.\n-    read_allowed: bool,\n }\n \n-impl<K> Default for TaskDeps<K> {\n+impl<K: DepKind> Default for TaskDeps<K> {\n     fn default() -> Self {\n         Self {\n             #[cfg(debug_assertions)]\n             node: None,\n             reads: EdgesVec::new(),\n             read_set: FxHashSet::default(),\n             phantom_data: PhantomData,\n-            read_allowed: true,\n         }\n     }\n }"}, {"sha": "5907ae309ca377abb9c5e81966f8999fa6e18a94", "filename": "compiler/rustc_query_system/src/dep_graph/mod.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/02c9e73e6ca7e2bd444d39182f8dee7e2ba4a609/compiler%2Frustc_query_system%2Fsrc%2Fdep_graph%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02c9e73e6ca7e2bd444d39182f8dee7e2ba4a609/compiler%2Frustc_query_system%2Fsrc%2Fdep_graph%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_query_system%2Fsrc%2Fdep_graph%2Fmod.rs?ref=02c9e73e6ca7e2bd444d39182f8dee7e2ba4a609", "patch": "@@ -5,13 +5,14 @@ mod query;\n mod serialized;\n \n pub use dep_node::{DepNode, DepNodeParams, WorkProductId};\n-pub use graph::{hash_result, DepGraph, DepNodeColor, DepNodeIndex, TaskDeps, WorkProduct};\n+pub use graph::{\n+    hash_result, DepGraph, DepNodeColor, DepNodeIndex, TaskDeps, TaskDepsRef, WorkProduct,\n+};\n pub use query::DepGraphQuery;\n pub use serialized::{SerializedDepGraph, SerializedDepNodeIndex};\n \n use crate::ich::StableHashingContext;\n use rustc_data_structures::profiling::SelfProfilerRef;\n-use rustc_data_structures::sync::Lock;\n use rustc_serialize::{opaque::FileEncoder, Encodable};\n use rustc_session::Session;\n \n@@ -90,12 +91,12 @@ pub trait DepKind: Copy + fmt::Debug + Eq + Hash + Send + Encodable<FileEncoder>\n     fn debug_node(node: &DepNode<Self>, f: &mut fmt::Formatter<'_>) -> fmt::Result;\n \n     /// Execute the operation with provided dependencies.\n-    fn with_deps<OP, R>(deps: Option<&Lock<TaskDeps<Self>>>, op: OP) -> R\n+    fn with_deps<OP, R>(deps: TaskDepsRef<'_, Self>, op: OP) -> R\n     where\n         OP: FnOnce() -> R;\n \n     /// Access dependencies from current implicit context.\n     fn read_deps<OP>(op: OP)\n     where\n-        OP: for<'a> FnOnce(Option<&'a Lock<TaskDeps<Self>>>);\n+        OP: for<'a> FnOnce(TaskDepsRef<'a, Self>);\n }"}]}