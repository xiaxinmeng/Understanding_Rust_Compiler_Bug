{"sha": "b38d7f65388fabf383d3e3a4e4c3a56403f57542", "node_id": "MDY6Q29tbWl0NzI0NzEyOmIzOGQ3ZjY1Mzg4ZmFiZjM4M2QzZTNhNGU0YzNhNTY0MDNmNTc1NDI=", "commit": {"author": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2012-11-30T00:41:39Z"}, "committer": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2012-11-30T00:41:47Z"}, "message": "Remove more uses of #[merge]", "tree": {"sha": "0f4fcd01c75af515097dc5a79ba8f65d22adf871", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0f4fcd01c75af515097dc5a79ba8f65d22adf871"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b38d7f65388fabf383d3e3a4e4c3a56403f57542", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b38d7f65388fabf383d3e3a4e4c3a56403f57542", "html_url": "https://github.com/rust-lang/rust/commit/b38d7f65388fabf383d3e3a4e4c3a56403f57542", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b38d7f65388fabf383d3e3a4e4c3a56403f57542/comments", "author": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "committer": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d1c558394f52cc5295d8c7ce1fafc08927ab8106", "url": "https://api.github.com/repos/rust-lang/rust/commits/d1c558394f52cc5295d8c7ce1fafc08927ab8106", "html_url": "https://github.com/rust-lang/rust/commit/d1c558394f52cc5295d8c7ce1fafc08927ab8106"}], "stats": {"total": 7306, "additions": 3654, "deletions": 3652}, "files": [{"sha": "5807e338ebd9fea7622abbf634fdf97c240e057b", "filename": "src/librustc/middle/typeck/check.rs", "status": "removed", "additions": 0, "deletions": 2905, "changes": 2905, "blob_url": "https://github.com/rust-lang/rust/blob/d1c558394f52cc5295d8c7ce1fafc08927ab8106/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d1c558394f52cc5295d8c7ce1fafc08927ab8106/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck.rs?ref=d1c558394f52cc5295d8c7ce1fafc08927ab8106"}, {"sha": "1c2cb4604e5a2bfe018eab96222e259ceb4b5bfd", "filename": "src/librustc/middle/typeck/check/mod.rs", "status": "modified", "additions": 2906, "deletions": 0, "changes": 2906, "blob_url": "https://github.com/rust-lang/rust/blob/b38d7f65388fabf383d3e3a4e4c3a56403f57542/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b38d7f65388fabf383d3e3a4e4c3a56403f57542/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs?ref=b38d7f65388fabf383d3e3a4e4c3a56403f57542"}, {"sha": "b4ffd92c0a8cb5d37f790335936dbb91e1862fad", "filename": "src/librustc/middle/typeck/infer.rs", "status": "removed", "additions": 0, "deletions": 745, "changes": 745, "blob_url": "https://github.com/rust-lang/rust/blob/d1c558394f52cc5295d8c7ce1fafc08927ab8106/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d1c558394f52cc5295d8c7ce1fafc08927ab8106/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer.rs?ref=d1c558394f52cc5295d8c7ce1fafc08927ab8106", "patch": "@@ -1,745 +0,0 @@\n-/*!\n-\n-# Type inference engine\n-\n-This is loosely based on standard HM-type inference, but with an\n-extension to try and accommodate subtyping.  There is nothing\n-principled about this extension; it's sound---I hope!---but it's a\n-heuristic, ultimately, and does not guarantee that it finds a valid\n-typing even if one exists (in fact, there are known scenarios where it\n-fails, some of which may eventually become problematic).\n-\n-## Key idea\n-\n-The main change is that each type variable T is associated with a\n-lower-bound L and an upper-bound U.  L and U begin as bottom and top,\n-respectively, but gradually narrow in response to new constraints\n-being introduced.  When a variable is finally resolved to a concrete\n-type, it can (theoretically) select any type that is a supertype of L\n-and a subtype of U.\n-\n-There are several critical invariants which we maintain:\n-\n-- the upper-bound of a variable only becomes lower and the lower-bound\n-  only becomes higher over time;\n-- the lower-bound L is always a subtype of the upper bound U;\n-- the lower-bound L and upper-bound U never refer to other type variables,\n-  but only to types (though those types may contain type variables).\n-\n-> An aside: if the terms upper- and lower-bound confuse you, think of\n-> \"supertype\" and \"subtype\".  The upper-bound is a \"supertype\"\n-> (super=upper in Latin, or something like that anyway) and the lower-bound\n-> is a \"subtype\" (sub=lower in Latin).  I find it helps to visualize\n-> a simple class hierarchy, like Java minus interfaces and\n-> primitive types.  The class Object is at the root (top) and other\n-> types lie in between.  The bottom type is then the Null type.\n-> So the tree looks like:\n->\n->             Object\n->             /    \\\n->         String   Other\n->             \\    /\n->             (null)\n->\n-> So the upper bound type is the \"supertype\" and the lower bound is the\n-> \"subtype\" (also, super and sub mean upper and lower in Latin, or something\n-> like that anyway).\n-\n-## Satisfying constraints\n-\n-At a primitive level, there is only one form of constraint that the\n-inference understands: a subtype relation.  So the outside world can\n-say \"make type A a subtype of type B\".  If there are variables\n-involved, the inferencer will adjust their upper- and lower-bounds as\n-needed to ensure that this relation is satisfied. (We also allow \"make\n-type A equal to type B\", but this is translated into \"A <: B\" and \"B\n-<: A\")\n-\n-As stated above, we always maintain the invariant that type bounds\n-never refer to other variables.  This keeps the inference relatively\n-simple, avoiding the scenario of having a kind of graph where we have\n-to pump constraints along and reach a fixed point, but it does impose\n-some heuristics in the case where the user is relating two type\n-variables A <: B.\n-\n-Combining two variables such that variable A will forever be a subtype\n-of variable B is the trickiest part of the algorithm because there is\n-often no right choice---that is, the right choice will depend on\n-future constraints which we do not yet know. The problem comes about\n-because both A and B have bounds that can be adjusted in the future.\n-Let's look at some of the cases that can come up.\n-\n-Imagine, to start, the best case, where both A and B have an upper and\n-lower bound (that is, the bounds are not top nor bot respectively). In\n-that case, if we're lucky, A.ub <: B.lb, and so we know that whatever\n-A and B should become, they will forever have the desired subtyping\n-relation.  We can just leave things as they are.\n-\n-### Option 1: Unify\n-\n-However, suppose that A.ub is *not* a subtype of B.lb.  In\n-that case, we must make a decision.  One option is to unify A\n-and B so that they are one variable whose bounds are:\n-\n-    UB = GLB(A.ub, B.ub)\n-    LB = LUB(A.lb, B.lb)\n-\n-(Note that we will have to verify that LB <: UB; if it does not, the\n-types are not intersecting and there is an error) In that case, A <: B\n-holds trivially because A==B.  However, we have now lost some\n-flexibility, because perhaps the user intended for A and B to end up\n-as different types and not the same type.\n-\n-Pictorally, what this does is to take two distinct variables with\n-(hopefully not completely) distinct type ranges and produce one with\n-the intersection.\n-\n-                      B.ub                  B.ub\n-                       /\\                    /\n-               A.ub   /  \\           A.ub   /\n-               /   \\ /    \\              \\ /\n-              /     X      \\              UB\n-             /     / \\      \\            / \\\n-            /     /   /      \\          /   /\n-            \\     \\  /       /          \\  /\n-             \\      X       /             LB\n-              \\    / \\     /             / \\\n-               \\  /   \\   /             /   \\\n-               A.lb    B.lb          A.lb    B.lb\n-\n-\n-### Option 2: Relate UB/LB\n-\n-Another option is to keep A and B as distinct variables but set their\n-bounds in such a way that, whatever happens, we know that A <: B will hold.\n-This can be achieved by ensuring that A.ub <: B.lb.  In practice there\n-are two ways to do that, depicted pictorally here:\n-\n-        Before                Option #1            Option #2\n-\n-                 B.ub                B.ub                B.ub\n-                  /\\                 /  \\                /  \\\n-          A.ub   /  \\        A.ub   /(B')\\       A.ub   /(B')\\\n-          /   \\ /    \\           \\ /     /           \\ /     /\n-         /     X      \\         __UB____/             UB    /\n-        /     / \\      \\       /  |                   |    /\n-       /     /   /      \\     /   |                   |   /\n-       \\     \\  /       /    /(A')|                   |  /\n-        \\      X       /    /     LB            ______LB/\n-         \\    / \\     /    /     / \\           / (A')/ \\\n-          \\  /   \\   /     \\    /   \\          \\    /   \\\n-          A.lb    B.lb       A.lb    B.lb        A.lb    B.lb\n-\n-In these diagrams, UB and LB are defined as before.  As you can see,\n-the new ranges `A'` and `B'` are quite different from the range that\n-would be produced by unifying the variables.\n-\n-### What we do now\n-\n-Our current technique is to *try* (transactionally) to relate the\n-existing bounds of A and B, if there are any (i.e., if `UB(A) != top\n-&& LB(B) != bot`).  If that succeeds, we're done.  If it fails, then\n-we merge A and B into same variable.\n-\n-This is not clearly the correct course.  For example, if `UB(A) !=\n-top` but `LB(B) == bot`, we could conceivably set `LB(B)` to `UB(A)`\n-and leave the variables unmerged.  This is sometimes the better\n-course, it depends on the program.\n-\n-The main case which fails today that I would like to support is:\n-\n-    fn foo<T>(x: T, y: T) { ... }\n-\n-    fn bar() {\n-        let x: @mut int = @mut 3;\n-        let y: @int = @3;\n-        foo(x, y);\n-    }\n-\n-In principle, the inferencer ought to find that the parameter `T` to\n-`foo(x, y)` is `@const int`.  Today, however, it does not; this is\n-because the type variable `T` is merged with the type variable for\n-`X`, and thus inherits its UB/LB of `@mut int`.  This leaves no\n-flexibility for `T` to later adjust to accommodate `@int`.\n-\n-### What to do when not all bounds are present\n-\n-In the prior discussion we assumed that A.ub was not top and B.lb was\n-not bot.  Unfortunately this is rarely the case.  Often type variables\n-have \"lopsided\" bounds.  For example, if a variable in the program has\n-been initialized but has not been used, then its corresponding type\n-variable will have a lower bound but no upper bound.  When that\n-variable is then used, we would like to know its upper bound---but we\n-don't have one!  In this case we'll do different things depending on\n-how the variable is being used.\n-\n-## Transactional support\n-\n-Whenever we adjust merge variables or adjust their bounds, we always\n-keep a record of the old value.  This allows the changes to be undone.\n-\n-## Regions\n-\n-I've only talked about type variables here, but region variables\n-follow the same principle.  They have upper- and lower-bounds.  A\n-region A is a subregion of a region B if A being valid implies that B\n-is valid.  This basically corresponds to the block nesting structure:\n-the regions for outer block scopes are superregions of those for inner\n-block scopes.\n-\n-## Integral type variables\n-\n-There is a third variety of type variable that we use only for\n-inferring the types of unsuffixed integer literals.  Integral type\n-variables differ from general-purpose type variables in that there's\n-no subtyping relationship among the various integral types, so instead\n-of associating each variable with an upper and lower bound, we\n-represent the set of possible integral types it can take on with an\n-`int_ty_set`, which is a bitvector with one bit for each integral\n-type.  Because intersecting these sets with each other is simpler than\n-merging bounds, we don't need to do so transactionally as we do for\n-general-purpose type variables.\n-\n-We could conceivably define a subtyping relationship among integral\n-types based on their ranges, but we choose not to open that particular\n-can of worms.  Our strategy is to treat integral type variables as\n-unknown until the typing context constrains them to a unique integral\n-type, at which point they take on that type.  If the typing context\n-overconstrains the type, it's a type error; if we reach the point at\n-which type variables must be resolved and an integral type variable is\n-still underconstrained, it defaults to `int` as a last resort.\n-\n-Floating point types are handled similarly to integral types.\n-\n-## GLB/LUB\n-\n-Computing the greatest-lower-bound and least-upper-bound of two\n-types/regions is generally straightforward except when type variables\n-are involved. In that case, we follow a similar \"try to use the bounds\n-when possible but otherwise merge the variables\" strategy.  In other\n-words, `GLB(A, B)` where `A` and `B` are variables will often result\n-in `A` and `B` being merged and the result being `A`.\n-\n-## Type assignment\n-\n-We have a notion of assignability which differs somewhat from\n-subtyping; in particular it may cause region borrowing to occur.  See\n-the big comment later in this file on Type Assignment for specifics.\n-\n-### In conclusion\n-\n-I showed you three ways to relate `A` and `B`.  There are also more,\n-of course, though I'm not sure if there are any more sensible options.\n-The main point is that there are various options, each of which\n-produce a distinct range of types for `A` and `B`.  Depending on what\n-the correct values for A and B are, one of these options will be the\n-right choice: but of course we don't know the right values for A and B\n-yet, that's what we're trying to find!  In our code, we opt to unify\n-(Option #1).\n-\n-# Implementation details\n-\n-We make use of a trait-like impementation strategy to consolidate\n-duplicated code between subtypes, GLB, and LUB computations.  See the\n-section on \"Type Combining\" below for details.\n-\n-*/\n-\n-#[warn(deprecated_mode)];\n-#[warn(deprecated_pattern)];\n-\n-use std::smallintmap;\n-use std::smallintmap::smallintmap;\n-use std::map::HashMap;\n-use middle::ty;\n-use middle::ty::{TyVid, IntVid, FloatVid, RegionVid, vid,\n-                 ty_int, ty_uint, get, terr_fn, TyVar, IntVar, FloatVar};\n-use syntax::{ast, ast_util};\n-use syntax::ast::{ret_style, purity};\n-use util::ppaux::{ty_to_str, mt_to_str};\n-use result::{Result, Ok, Err, map_vec, map_vec2, iter_vec2};\n-use ty::{mk_fn, type_is_bot};\n-use check::regionmanip::{replace_bound_regions_in_fn_ty};\n-use util::common::{indent, indenter};\n-use ast::{unsafe_fn, impure_fn, pure_fn, extern_fn};\n-use ast::{m_const, m_imm, m_mutbl};\n-use dvec::DVec;\n-use region_inference::{RegionVarBindings};\n-use ast_util::dummy_sp;\n-use cmp::Eq;\n-\n-// From submodules:\n-use resolve::{resolve_nested_tvar, resolve_rvar, resolve_ivar, resolve_all,\n-                 force_tvar, force_rvar, force_ivar, force_all, not_regions,\n-                 resolve_and_force_all_but_regions, resolver};\n-use unify::{vals_and_bindings, root};\n-use integral::{int_ty_set, int_ty_set_all};\n-use floating::{float_ty_set, float_ty_set_all};\n-use combine::{combine_fields, eq_tys};\n-use assignment::Assign;\n-use to_str::ToStr;\n-\n-use sub::Sub;\n-use lub::Lub;\n-use glb::Glb;\n-\n-export infer_ctxt;\n-export new_infer_ctxt;\n-export mk_subty, can_mk_subty;\n-export mk_subr;\n-export mk_eqty;\n-export mk_assignty, can_mk_assignty;\n-export resolve_nested_tvar, resolve_rvar, resolve_ivar, resolve_all;\n-export force_tvar, force_rvar, force_ivar, force_all;\n-export resolve_and_force_all_but_regions, not_regions;\n-export resolve_type, resolve_region;\n-export resolve_borrowings;\n-export methods; // for infer_ctxt\n-export unify_methods; // for infer_ctxt\n-export cres, fres, fixup_err, fixup_err_to_str;\n-export assignment;\n-export root, to_str;\n-export int_ty_set_all;\n-\n-type bound<T:Copy> = Option<T>;\n-type bounds<T:Copy> = {lb: bound<T>, ub: bound<T>};\n-\n-type cres<T> = Result<T,ty::type_err>; // \"combine result\"\n-type ures = cres<()>; // \"unify result\"\n-type fres<T> = Result<T, fixup_err>; // \"fixup result\"\n-type ares = cres<Option<@ty::AutoAdjustment>>; // \"assignment result\"\n-\n-enum infer_ctxt = @{\n-    tcx: ty::ctxt,\n-\n-    // We instantiate vals_and_bindings with bounds<ty::t> because the\n-    // types that might instantiate a general type variable have an\n-    // order, represented by its upper and lower bounds.\n-    ty_var_bindings: vals_and_bindings<ty::TyVid, bounds<ty::t>>,\n-\n-    // The types that might instantiate an integral type variable are\n-    // represented by an int_ty_set.\n-    int_var_bindings: vals_and_bindings<ty::IntVid, int_ty_set>,\n-\n-    // The types that might instantiate a floating-point type variable are\n-    // represented by an float_ty_set.\n-    float_var_bindings: vals_and_bindings<ty::FloatVid, float_ty_set>,\n-\n-    // For region variables.\n-    region_vars: RegionVarBindings,\n-\n-    // For keeping track of existing type and region variables.\n-    ty_var_counter: @mut uint,\n-    int_var_counter: @mut uint,\n-    float_var_counter: @mut uint,\n-    region_var_counter: @mut uint\n-};\n-\n-enum fixup_err {\n-    unresolved_int_ty(IntVid),\n-    unresolved_ty(TyVid),\n-    cyclic_ty(TyVid),\n-    unresolved_region(RegionVid),\n-    region_var_bound_by_region_var(RegionVid, RegionVid)\n-}\n-\n-fn fixup_err_to_str(f: fixup_err) -> ~str {\n-    match f {\n-      unresolved_int_ty(_) => ~\"unconstrained integral type\",\n-      unresolved_ty(_) => ~\"unconstrained type\",\n-      cyclic_ty(_) => ~\"cyclic type of infinite size\",\n-      unresolved_region(_) => ~\"unconstrained region\",\n-      region_var_bound_by_region_var(r1, r2) => {\n-        fmt!(\"region var %? bound by another region var %?; this is \\\n-              a bug in rustc\", r1, r2)\n-      }\n-    }\n-}\n-\n-fn new_vals_and_bindings<V:Copy, T:Copy>() -> vals_and_bindings<V, T> {\n-    vals_and_bindings {\n-        vals: smallintmap::mk(),\n-        mut bindings: ~[]\n-    }\n-}\n-\n-fn new_infer_ctxt(tcx: ty::ctxt) -> infer_ctxt {\n-    infer_ctxt(@{tcx: tcx,\n-                 ty_var_bindings: new_vals_and_bindings(),\n-                 int_var_bindings: new_vals_and_bindings(),\n-                 float_var_bindings: new_vals_and_bindings(),\n-                 region_vars: RegionVarBindings(tcx),\n-                 ty_var_counter: @mut 0u,\n-                 int_var_counter: @mut 0u,\n-                 float_var_counter: @mut 0u,\n-                 region_var_counter: @mut 0u})}\n-\n-fn mk_subty(cx: infer_ctxt, a_is_expected: bool, span: span,\n-            a: ty::t, b: ty::t) -> ures {\n-    debug!(\"mk_subty(%s <: %s)\", a.to_str(cx), b.to_str(cx));\n-    do indent {\n-        do cx.commit {\n-            cx.sub(a_is_expected, span).tys(a, b)\n-        }\n-    }.to_ures()\n-}\n-\n-fn can_mk_subty(cx: infer_ctxt, a: ty::t, b: ty::t) -> ures {\n-    debug!(\"can_mk_subty(%s <: %s)\", a.to_str(cx), b.to_str(cx));\n-    do indent {\n-        do cx.probe {\n-            cx.sub(true, ast_util::dummy_sp()).tys(a, b)\n-        }\n-    }.to_ures()\n-}\n-\n-fn mk_subr(cx: infer_ctxt, a_is_expected: bool, span: span,\n-           a: ty::Region, b: ty::Region) -> ures {\n-    debug!(\"mk_subr(%s <: %s)\", a.to_str(cx), b.to_str(cx));\n-    do indent {\n-        do cx.commit {\n-            cx.sub(a_is_expected, span).regions(a, b)\n-        }\n-    }.to_ures()\n-}\n-\n-fn mk_eqty(cx: infer_ctxt, a_is_expected: bool, span: span,\n-           a: ty::t, b: ty::t) -> ures {\n-    debug!(\"mk_eqty(%s <: %s)\", a.to_str(cx), b.to_str(cx));\n-    do indent {\n-        do cx.commit {\n-            let suber = cx.sub(a_is_expected, span);\n-            eq_tys(&suber, a, b)\n-        }\n-    }.to_ures()\n-}\n-\n-fn mk_assignty(cx: infer_ctxt, a_is_expected: bool, span: span,\n-               a: ty::t, b: ty::t) -> ares {\n-    debug!(\"mk_assignty(%s -> %s)\", a.to_str(cx), b.to_str(cx));\n-    do indent {\n-        do cx.commit {\n-            Assign(cx.combine_fields(a_is_expected, span)).tys(a, b)\n-        }\n-    }\n-}\n-\n-fn can_mk_assignty(cx: infer_ctxt, a: ty::t, b: ty::t) -> ures {\n-    debug!(\"can_mk_assignty(%s -> %s)\", a.to_str(cx), b.to_str(cx));\n-    do indent {\n-        do cx.probe {\n-            let span = ast_util::dummy_sp();\n-            Assign(cx.combine_fields(true, span)).tys(a, b)\n-        }\n-    }.to_ures()\n-}\n-\n-// See comment on the type `resolve_state` below\n-fn resolve_type(cx: infer_ctxt, a: ty::t, modes: uint)\n-    -> fres<ty::t> {\n-    resolver(cx, modes).resolve_type_chk(a)\n-}\n-\n-fn resolve_region(cx: infer_ctxt, r: ty::Region, modes: uint)\n-    -> fres<ty::Region> {\n-    resolver(cx, modes).resolve_region_chk(r)\n-}\n-\n-/*\n-fn resolve_borrowings(cx: infer_ctxt) {\n-    for cx.borrowings.each |item| {\n-        match resolve_region(cx, item.scope, resolve_all|force_all) {\n-          Ok(region) => {\n-            debug!(\"borrowing for expr %d resolved to region %?, mutbl %?\",\n-                   item.expr_id, region, item.mutbl);\n-            cx.tcx.borrowings.insert(\n-                item.expr_id, {region: region, mutbl: item.mutbl});\n-          }\n-\n-          Err(e) => {\n-            let str = fixup_err_to_str(e);\n-            cx.tcx.sess.span_err(\n-                item.span,\n-                fmt!(\"could not resolve lifetime for borrow: %s\", str));\n-          }\n-        }\n-    }\n-}\n-*/\n-\n-trait then {\n-    fn then<T:Copy>(f: fn() -> Result<T,ty::type_err>)\n-        -> Result<T,ty::type_err>;\n-}\n-\n-impl ures: then {\n-    fn then<T:Copy>(f: fn() -> Result<T,ty::type_err>)\n-        -> Result<T,ty::type_err> {\n-        self.chain(|_i| f())\n-    }\n-}\n-\n-trait ToUres {\n-    fn to_ures() -> ures;\n-}\n-\n-impl<T> cres<T>: ToUres {\n-    fn to_ures() -> ures {\n-        match self {\n-          Ok(_v) => Ok(()),\n-          Err(e) => Err(e)\n-        }\n-    }\n-}\n-\n-trait CresCompare<T> {\n-    fn compare(t: T, f: fn() -> ty::type_err) -> cres<T>;\n-}\n-\n-impl<T:Copy Eq> cres<T>: CresCompare<T> {\n-    fn compare(t: T, f: fn() -> ty::type_err) -> cres<T> {\n-        do self.chain |s| {\n-            if s == t {\n-                self\n-            } else {\n-                Err(f())\n-            }\n-        }\n-    }\n-}\n-\n-fn uok() -> ures {\n-    Ok(())\n-}\n-\n-fn rollback_to<V:Copy vid, T:Copy>(\n-    vb: &vals_and_bindings<V, T>, len: uint) {\n-\n-    while vb.bindings.len() != len {\n-        let (vid, old_v) = vb.bindings.pop();\n-        vb.vals.insert(vid.to_uint(), old_v);\n-    }\n-}\n-\n-struct Snapshot {\n-    ty_var_bindings_len: uint,\n-    int_var_bindings_len: uint,\n-    region_vars_snapshot: uint,\n-}\n-\n-impl infer_ctxt {\n-    fn combine_fields(a_is_expected: bool,\n-                      span: span) -> combine_fields {\n-        combine_fields {infcx: self,\n-                        a_is_expected: a_is_expected,\n-                        span: span}\n-    }\n-\n-    fn sub(a_is_expected: bool, span: span) -> Sub {\n-        Sub(self.combine_fields(a_is_expected, span))\n-    }\n-\n-    fn in_snapshot() -> bool {\n-        self.region_vars.in_snapshot()\n-    }\n-\n-    fn start_snapshot() -> Snapshot {\n-        Snapshot {\n-            ty_var_bindings_len:\n-                self.ty_var_bindings.bindings.len(),\n-            int_var_bindings_len:\n-                self.int_var_bindings.bindings.len(),\n-            region_vars_snapshot:\n-                self.region_vars.start_snapshot(),\n-        }\n-    }\n-\n-    fn rollback_to(snapshot: &Snapshot) {\n-        debug!(\"rollback!\");\n-        rollback_to(&self.ty_var_bindings, snapshot.ty_var_bindings_len);\n-\n-        // FIXME(#3211) -- int_var not transactional\n-        //rollback_to(&self.int_var_bindings,\n-        //            snapshot.int_var_bindings_len);\n-\n-        self.region_vars.rollback_to(\n-            snapshot.region_vars_snapshot);\n-    }\n-\n-    /// Execute `f` and commit the bindings if successful\n-    fn commit<T,E>(f: fn() -> Result<T,E>) -> Result<T,E> {\n-        assert !self.in_snapshot();\n-\n-        debug!(\"commit()\");\n-        do indent {\n-            let r = self.try(f);\n-\n-            self.ty_var_bindings.bindings.truncate(0);\n-            self.int_var_bindings.bindings.truncate(0);\n-            self.region_vars.commit();\n-            move r\n-        }\n-    }\n-\n-    /// Execute `f`, unroll bindings on failure\n-    fn try<T,E>(f: fn() -> Result<T,E>) -> Result<T,E> {\n-        debug!(\"try()\");\n-        do indent {\n-            let snapshot = self.start_snapshot();\n-            let r = f();\n-            match r {\n-              Ok(_) => (),\n-              Err(_) => self.rollback_to(&snapshot)\n-            }\n-            move r\n-        }\n-    }\n-\n-    /// Execute `f` then unroll any bindings it creates\n-    fn probe<T,E>(f: fn() -> Result<T,E>) -> Result<T,E> {\n-        debug!(\"probe()\");\n-        do indent {\n-            let snapshot = self.start_snapshot();\n-            let r = self.try(f);\n-            self.rollback_to(&snapshot);\n-            move r\n-        }\n-    }\n-}\n-\n-impl infer_ctxt {\n-    fn next_ty_var_id() -> TyVid {\n-        let id = *self.ty_var_counter;\n-        *self.ty_var_counter += 1u;\n-        self.ty_var_bindings.vals.insert(id,\n-                                         root({lb: None, ub: None}, 0u));\n-        return TyVid(id);\n-    }\n-\n-    fn next_ty_var() -> ty::t {\n-        ty::mk_var(self.tcx, self.next_ty_var_id())\n-    }\n-\n-    fn next_ty_vars(n: uint) -> ~[ty::t] {\n-        vec::from_fn(n, |_i| self.next_ty_var())\n-    }\n-\n-    fn next_int_var_id() -> IntVid {\n-        let id = *self.int_var_counter;\n-        *self.int_var_counter += 1u;\n-\n-        self.int_var_bindings.vals.insert(id,\n-                              root(int_ty_set_all(), 0u));\n-        return IntVid(id);\n-    }\n-\n-    fn next_int_var() -> ty::t {\n-        ty::mk_int_var(self.tcx, self.next_int_var_id())\n-    }\n-\n-    fn next_float_var_id() -> FloatVid {\n-        let id = *self.float_var_counter;\n-        *self.float_var_counter += 1;\n-\n-        self.float_var_bindings.vals.insert(id, root(float_ty_set_all(), 0));\n-        return FloatVid(id);\n-    }\n-\n-    fn next_float_var() -> ty::t {\n-        ty::mk_float_var(self.tcx, self.next_float_var_id())\n-    }\n-\n-    fn next_region_var_nb(span: span) -> ty::Region {\n-        ty::re_infer(ty::ReVar(self.region_vars.new_region_var(span)))\n-    }\n-\n-    fn next_region_var_with_lb(span: span,\n-                               lb_region: ty::Region) -> ty::Region {\n-        let region_var = self.next_region_var_nb(span);\n-\n-        // add lb_region as a lower bound on the newly built variable\n-        assert self.region_vars.make_subregion(span,\n-                                               lb_region,\n-                                               region_var).is_ok();\n-\n-        return region_var;\n-    }\n-\n-    fn next_region_var(span: span, scope_id: ast::node_id) -> ty::Region {\n-        self.next_region_var_with_lb(span, ty::re_scope(scope_id))\n-    }\n-\n-    fn resolve_regions() {\n-        self.region_vars.resolve_regions();\n-    }\n-\n-    fn ty_to_str(t: ty::t) -> ~str {\n-        ty_to_str(self.tcx,\n-                  self.resolve_type_vars_if_possible(t))\n-    }\n-\n-    fn resolve_type_vars_if_possible(typ: ty::t) -> ty::t {\n-        match resolve_type(self, typ, resolve_nested_tvar | resolve_ivar) {\n-          result::Ok(new_type) => new_type,\n-          result::Err(_) => typ\n-        }\n-    }\n-\n-    fn type_error_message(sp: span, mk_msg: fn(~str) -> ~str,\n-                          actual_ty: ty::t, err: Option<&ty::type_err>) {\n-        let actual_ty = self.resolve_type_vars_if_possible(actual_ty);\n-\n-        // Don't report an error if actual type is ty_err.\n-        match ty::get(actual_ty).sty {\n-            ty::ty_err => return,\n-            _           => ()\n-        }\n-        let error_str = err.map_default(~\"\", |t_err|\n-                         fmt!(\" (%s)\",\n-                              ty::type_err_to_str(self.tcx, *t_err)));\n-        self.tcx.sess.span_err(sp,\n-           fmt!(\"%s%s\", mk_msg(self.ty_to_str(actual_ty)),\n-                error_str));\n-        err.iter(|err|\n-             ty::note_and_explain_type_err(self.tcx, *err));\n-    }\n-\n-    fn report_mismatched_types(sp: span, e: ty::t, a: ty::t,\n-                               err: &ty::type_err) {\n-        // Don't report an error if expected is ty_err\n-        let resolved_expected =\n-            self.resolve_type_vars_if_possible(e);\n-        let mk_msg = match ty::get(resolved_expected).sty {\n-            ty::ty_err => return,\n-            _ => {\n-                // if I leave out : ~str, it infers &str and complains\n-                |actual: ~str| {\n-                    fmt!(\"mismatched types: expected `%s` but found `%s`\",\n-                         self.ty_to_str(resolved_expected), actual)\n-                }\n-            }\n-        };\n-        self.type_error_message(sp, mk_msg, a, Some(err));\n-    }\n-\n-    fn replace_bound_regions_with_fresh_regions(\n-        &self, span: span,\n-        fty: &ty::FnTy) -> (ty::FnTy, isr_alist)\n-    {\n-        let {fn_ty, isr, _} =\n-            replace_bound_regions_in_fn_ty(self.tcx, @Nil, None, fty, |br| {\n-                // N.B.: The name of the bound region doesn't have anything to\n-                // do with the region variable that's created for it.  The\n-                // only thing we're doing with `br` here is using it in the\n-                // debug message.\n-                let rvar = self.next_region_var_nb(span);\n-                debug!(\"Bound region %s maps to %?\",\n-                       bound_region_to_str(self.tcx, br),\n-                       rvar);\n-                rvar\n-            });\n-        (fn_ty, isr)\n-    }\n-\n-}\n-"}, {"sha": "ec637635f95d1a1736548b835c51148866163772", "filename": "src/librustc/middle/typeck/infer/mod.rs", "status": "modified", "additions": 746, "deletions": 0, "changes": 746, "blob_url": "https://github.com/rust-lang/rust/blob/b38d7f65388fabf383d3e3a4e4c3a56403f57542/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b38d7f65388fabf383d3e3a4e4c3a56403f57542/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fmod.rs?ref=b38d7f65388fabf383d3e3a4e4c3a56403f57542", "patch": "@@ -1,4 +1,307 @@\n+/*!\n+\n+# Type inference engine\n+\n+This is loosely based on standard HM-type inference, but with an\n+extension to try and accommodate subtyping.  There is nothing\n+principled about this extension; it's sound---I hope!---but it's a\n+heuristic, ultimately, and does not guarantee that it finds a valid\n+typing even if one exists (in fact, there are known scenarios where it\n+fails, some of which may eventually become problematic).\n+\n+## Key idea\n+\n+The main change is that each type variable T is associated with a\n+lower-bound L and an upper-bound U.  L and U begin as bottom and top,\n+respectively, but gradually narrow in response to new constraints\n+being introduced.  When a variable is finally resolved to a concrete\n+type, it can (theoretically) select any type that is a supertype of L\n+and a subtype of U.\n+\n+There are several critical invariants which we maintain:\n+\n+- the upper-bound of a variable only becomes lower and the lower-bound\n+  only becomes higher over time;\n+- the lower-bound L is always a subtype of the upper bound U;\n+- the lower-bound L and upper-bound U never refer to other type variables,\n+  but only to types (though those types may contain type variables).\n+\n+> An aside: if the terms upper- and lower-bound confuse you, think of\n+> \"supertype\" and \"subtype\".  The upper-bound is a \"supertype\"\n+> (super=upper in Latin, or something like that anyway) and the lower-bound\n+> is a \"subtype\" (sub=lower in Latin).  I find it helps to visualize\n+> a simple class hierarchy, like Java minus interfaces and\n+> primitive types.  The class Object is at the root (top) and other\n+> types lie in between.  The bottom type is then the Null type.\n+> So the tree looks like:\n+>\n+>             Object\n+>             /    \\\n+>         String   Other\n+>             \\    /\n+>             (null)\n+>\n+> So the upper bound type is the \"supertype\" and the lower bound is the\n+> \"subtype\" (also, super and sub mean upper and lower in Latin, or something\n+> like that anyway).\n+\n+## Satisfying constraints\n+\n+At a primitive level, there is only one form of constraint that the\n+inference understands: a subtype relation.  So the outside world can\n+say \"make type A a subtype of type B\".  If there are variables\n+involved, the inferencer will adjust their upper- and lower-bounds as\n+needed to ensure that this relation is satisfied. (We also allow \"make\n+type A equal to type B\", but this is translated into \"A <: B\" and \"B\n+<: A\")\n+\n+As stated above, we always maintain the invariant that type bounds\n+never refer to other variables.  This keeps the inference relatively\n+simple, avoiding the scenario of having a kind of graph where we have\n+to pump constraints along and reach a fixed point, but it does impose\n+some heuristics in the case where the user is relating two type\n+variables A <: B.\n+\n+Combining two variables such that variable A will forever be a subtype\n+of variable B is the trickiest part of the algorithm because there is\n+often no right choice---that is, the right choice will depend on\n+future constraints which we do not yet know. The problem comes about\n+because both A and B have bounds that can be adjusted in the future.\n+Let's look at some of the cases that can come up.\n+\n+Imagine, to start, the best case, where both A and B have an upper and\n+lower bound (that is, the bounds are not top nor bot respectively). In\n+that case, if we're lucky, A.ub <: B.lb, and so we know that whatever\n+A and B should become, they will forever have the desired subtyping\n+relation.  We can just leave things as they are.\n+\n+### Option 1: Unify\n+\n+However, suppose that A.ub is *not* a subtype of B.lb.  In\n+that case, we must make a decision.  One option is to unify A\n+and B so that they are one variable whose bounds are:\n+\n+    UB = GLB(A.ub, B.ub)\n+    LB = LUB(A.lb, B.lb)\n+\n+(Note that we will have to verify that LB <: UB; if it does not, the\n+types are not intersecting and there is an error) In that case, A <: B\n+holds trivially because A==B.  However, we have now lost some\n+flexibility, because perhaps the user intended for A and B to end up\n+as different types and not the same type.\n+\n+Pictorally, what this does is to take two distinct variables with\n+(hopefully not completely) distinct type ranges and produce one with\n+the intersection.\n+\n+                      B.ub                  B.ub\n+                       /\\                    /\n+               A.ub   /  \\           A.ub   /\n+               /   \\ /    \\              \\ /\n+              /     X      \\              UB\n+             /     / \\      \\            / \\\n+            /     /   /      \\          /   /\n+            \\     \\  /       /          \\  /\n+             \\      X       /             LB\n+              \\    / \\     /             / \\\n+               \\  /   \\   /             /   \\\n+               A.lb    B.lb          A.lb    B.lb\n+\n+\n+### Option 2: Relate UB/LB\n+\n+Another option is to keep A and B as distinct variables but set their\n+bounds in such a way that, whatever happens, we know that A <: B will hold.\n+This can be achieved by ensuring that A.ub <: B.lb.  In practice there\n+are two ways to do that, depicted pictorally here:\n+\n+        Before                Option #1            Option #2\n+\n+                 B.ub                B.ub                B.ub\n+                  /\\                 /  \\                /  \\\n+          A.ub   /  \\        A.ub   /(B')\\       A.ub   /(B')\\\n+          /   \\ /    \\           \\ /     /           \\ /     /\n+         /     X      \\         __UB____/             UB    /\n+        /     / \\      \\       /  |                   |    /\n+       /     /   /      \\     /   |                   |   /\n+       \\     \\  /       /    /(A')|                   |  /\n+        \\      X       /    /     LB            ______LB/\n+         \\    / \\     /    /     / \\           / (A')/ \\\n+          \\  /   \\   /     \\    /   \\          \\    /   \\\n+          A.lb    B.lb       A.lb    B.lb        A.lb    B.lb\n+\n+In these diagrams, UB and LB are defined as before.  As you can see,\n+the new ranges `A'` and `B'` are quite different from the range that\n+would be produced by unifying the variables.\n+\n+### What we do now\n+\n+Our current technique is to *try* (transactionally) to relate the\n+existing bounds of A and B, if there are any (i.e., if `UB(A) != top\n+&& LB(B) != bot`).  If that succeeds, we're done.  If it fails, then\n+we merge A and B into same variable.\n+\n+This is not clearly the correct course.  For example, if `UB(A) !=\n+top` but `LB(B) == bot`, we could conceivably set `LB(B)` to `UB(A)`\n+and leave the variables unmerged.  This is sometimes the better\n+course, it depends on the program.\n+\n+The main case which fails today that I would like to support is:\n+\n+    fn foo<T>(x: T, y: T) { ... }\n+\n+    fn bar() {\n+        let x: @mut int = @mut 3;\n+        let y: @int = @3;\n+        foo(x, y);\n+    }\n+\n+In principle, the inferencer ought to find that the parameter `T` to\n+`foo(x, y)` is `@const int`.  Today, however, it does not; this is\n+because the type variable `T` is merged with the type variable for\n+`X`, and thus inherits its UB/LB of `@mut int`.  This leaves no\n+flexibility for `T` to later adjust to accommodate `@int`.\n+\n+### What to do when not all bounds are present\n+\n+In the prior discussion we assumed that A.ub was not top and B.lb was\n+not bot.  Unfortunately this is rarely the case.  Often type variables\n+have \"lopsided\" bounds.  For example, if a variable in the program has\n+been initialized but has not been used, then its corresponding type\n+variable will have a lower bound but no upper bound.  When that\n+variable is then used, we would like to know its upper bound---but we\n+don't have one!  In this case we'll do different things depending on\n+how the variable is being used.\n+\n+## Transactional support\n+\n+Whenever we adjust merge variables or adjust their bounds, we always\n+keep a record of the old value.  This allows the changes to be undone.\n+\n+## Regions\n+\n+I've only talked about type variables here, but region variables\n+follow the same principle.  They have upper- and lower-bounds.  A\n+region A is a subregion of a region B if A being valid implies that B\n+is valid.  This basically corresponds to the block nesting structure:\n+the regions for outer block scopes are superregions of those for inner\n+block scopes.\n+\n+## Integral type variables\n+\n+There is a third variety of type variable that we use only for\n+inferring the types of unsuffixed integer literals.  Integral type\n+variables differ from general-purpose type variables in that there's\n+no subtyping relationship among the various integral types, so instead\n+of associating each variable with an upper and lower bound, we\n+represent the set of possible integral types it can take on with an\n+`int_ty_set`, which is a bitvector with one bit for each integral\n+type.  Because intersecting these sets with each other is simpler than\n+merging bounds, we don't need to do so transactionally as we do for\n+general-purpose type variables.\n+\n+We could conceivably define a subtyping relationship among integral\n+types based on their ranges, but we choose not to open that particular\n+can of worms.  Our strategy is to treat integral type variables as\n+unknown until the typing context constrains them to a unique integral\n+type, at which point they take on that type.  If the typing context\n+overconstrains the type, it's a type error; if we reach the point at\n+which type variables must be resolved and an integral type variable is\n+still underconstrained, it defaults to `int` as a last resort.\n+\n+Floating point types are handled similarly to integral types.\n+\n+## GLB/LUB\n+\n+Computing the greatest-lower-bound and least-upper-bound of two\n+types/regions is generally straightforward except when type variables\n+are involved. In that case, we follow a similar \"try to use the bounds\n+when possible but otherwise merge the variables\" strategy.  In other\n+words, `GLB(A, B)` where `A` and `B` are variables will often result\n+in `A` and `B` being merged and the result being `A`.\n+\n+## Type assignment\n+\n+We have a notion of assignability which differs somewhat from\n+subtyping; in particular it may cause region borrowing to occur.  See\n+the big comment later in this file on Type Assignment for specifics.\n+\n+### In conclusion\n+\n+I showed you three ways to relate `A` and `B`.  There are also more,\n+of course, though I'm not sure if there are any more sensible options.\n+The main point is that there are various options, each of which\n+produce a distinct range of types for `A` and `B`.  Depending on what\n+the correct values for A and B are, one of these options will be the\n+right choice: but of course we don't know the right values for A and B\n+yet, that's what we're trying to find!  In our code, we opt to unify\n+(Option #1).\n+\n+# Implementation details\n+\n+We make use of a trait-like impementation strategy to consolidate\n+duplicated code between subtypes, GLB, and LUB computations.  See the\n+section on \"Type Combining\" below for details.\n+\n+*/\n+\n #[legacy_exports];\n+#[warn(deprecated_mode)];\n+#[warn(deprecated_pattern)];\n+\n+use std::smallintmap;\n+use std::smallintmap::smallintmap;\n+use std::map::HashMap;\n+use middle::ty;\n+use middle::ty::{TyVid, IntVid, FloatVid, RegionVid, vid,\n+                 ty_int, ty_uint, get, terr_fn, TyVar, IntVar, FloatVar};\n+use syntax::{ast, ast_util};\n+use syntax::ast::{ret_style, purity};\n+use util::ppaux::{ty_to_str, mt_to_str};\n+use result::{Result, Ok, Err, map_vec, map_vec2, iter_vec2};\n+use ty::{mk_fn, type_is_bot};\n+use check::regionmanip::{replace_bound_regions_in_fn_ty};\n+use util::common::{indent, indenter};\n+use ast::{unsafe_fn, impure_fn, pure_fn, extern_fn};\n+use ast::{m_const, m_imm, m_mutbl};\n+use dvec::DVec;\n+use region_inference::{RegionVarBindings};\n+use ast_util::dummy_sp;\n+use cmp::Eq;\n+\n+// From submodules:\n+use resolve::{resolve_nested_tvar, resolve_rvar, resolve_ivar, resolve_all,\n+                 force_tvar, force_rvar, force_ivar, force_all, not_regions,\n+                 resolve_and_force_all_but_regions, resolver};\n+use unify::{vals_and_bindings, root};\n+use integral::{int_ty_set, int_ty_set_all};\n+use floating::{float_ty_set, float_ty_set_all};\n+use combine::{combine_fields, eq_tys};\n+use assignment::Assign;\n+use to_str::ToStr;\n+\n+use sub::Sub;\n+use lub::Lub;\n+use glb::Glb;\n+\n+export infer_ctxt;\n+export new_infer_ctxt;\n+export mk_subty, can_mk_subty;\n+export mk_subr;\n+export mk_eqty;\n+export mk_assignty, can_mk_assignty;\n+export resolve_nested_tvar, resolve_rvar, resolve_ivar, resolve_all;\n+export force_tvar, force_rvar, force_ivar, force_all;\n+export resolve_and_force_all_but_regions, not_regions;\n+export resolve_type, resolve_region;\n+export resolve_borrowings;\n+export methods; // for infer_ctxt\n+export unify_methods; // for infer_ctxt\n+export cres, fres, fixup_err, fixup_err_to_str;\n+export assignment;\n+export root, to_str;\n+export int_ty_set_all;\n+\n #[legacy_exports]\n mod assignment;\n #[legacy_exports]\n@@ -22,3 +325,446 @@ mod sub;\n mod to_str;\n #[legacy_exports]\n mod unify;\n+\n+type bound<T:Copy> = Option<T>;\n+type bounds<T:Copy> = {lb: bound<T>, ub: bound<T>};\n+\n+type cres<T> = Result<T,ty::type_err>; // \"combine result\"\n+type ures = cres<()>; // \"unify result\"\n+type fres<T> = Result<T, fixup_err>; // \"fixup result\"\n+type ares = cres<Option<@ty::AutoAdjustment>>; // \"assignment result\"\n+\n+enum infer_ctxt = @{\n+    tcx: ty::ctxt,\n+\n+    // We instantiate vals_and_bindings with bounds<ty::t> because the\n+    // types that might instantiate a general type variable have an\n+    // order, represented by its upper and lower bounds.\n+    ty_var_bindings: vals_and_bindings<ty::TyVid, bounds<ty::t>>,\n+\n+    // The types that might instantiate an integral type variable are\n+    // represented by an int_ty_set.\n+    int_var_bindings: vals_and_bindings<ty::IntVid, int_ty_set>,\n+\n+    // The types that might instantiate a floating-point type variable are\n+    // represented by an float_ty_set.\n+    float_var_bindings: vals_and_bindings<ty::FloatVid, float_ty_set>,\n+\n+    // For region variables.\n+    region_vars: RegionVarBindings,\n+\n+    // For keeping track of existing type and region variables.\n+    ty_var_counter: @mut uint,\n+    int_var_counter: @mut uint,\n+    float_var_counter: @mut uint,\n+    region_var_counter: @mut uint\n+};\n+\n+enum fixup_err {\n+    unresolved_int_ty(IntVid),\n+    unresolved_ty(TyVid),\n+    cyclic_ty(TyVid),\n+    unresolved_region(RegionVid),\n+    region_var_bound_by_region_var(RegionVid, RegionVid)\n+}\n+\n+fn fixup_err_to_str(f: fixup_err) -> ~str {\n+    match f {\n+      unresolved_int_ty(_) => ~\"unconstrained integral type\",\n+      unresolved_ty(_) => ~\"unconstrained type\",\n+      cyclic_ty(_) => ~\"cyclic type of infinite size\",\n+      unresolved_region(_) => ~\"unconstrained region\",\n+      region_var_bound_by_region_var(r1, r2) => {\n+        fmt!(\"region var %? bound by another region var %?; this is \\\n+              a bug in rustc\", r1, r2)\n+      }\n+    }\n+}\n+\n+fn new_vals_and_bindings<V:Copy, T:Copy>() -> vals_and_bindings<V, T> {\n+    vals_and_bindings {\n+        vals: smallintmap::mk(),\n+        mut bindings: ~[]\n+    }\n+}\n+\n+fn new_infer_ctxt(tcx: ty::ctxt) -> infer_ctxt {\n+    infer_ctxt(@{tcx: tcx,\n+                 ty_var_bindings: new_vals_and_bindings(),\n+                 int_var_bindings: new_vals_and_bindings(),\n+                 float_var_bindings: new_vals_and_bindings(),\n+                 region_vars: RegionVarBindings(tcx),\n+                 ty_var_counter: @mut 0u,\n+                 int_var_counter: @mut 0u,\n+                 float_var_counter: @mut 0u,\n+                 region_var_counter: @mut 0u})}\n+\n+fn mk_subty(cx: infer_ctxt, a_is_expected: bool, span: span,\n+            a: ty::t, b: ty::t) -> ures {\n+    debug!(\"mk_subty(%s <: %s)\", a.to_str(cx), b.to_str(cx));\n+    do indent {\n+        do cx.commit {\n+            cx.sub(a_is_expected, span).tys(a, b)\n+        }\n+    }.to_ures()\n+}\n+\n+fn can_mk_subty(cx: infer_ctxt, a: ty::t, b: ty::t) -> ures {\n+    debug!(\"can_mk_subty(%s <: %s)\", a.to_str(cx), b.to_str(cx));\n+    do indent {\n+        do cx.probe {\n+            cx.sub(true, ast_util::dummy_sp()).tys(a, b)\n+        }\n+    }.to_ures()\n+}\n+\n+fn mk_subr(cx: infer_ctxt, a_is_expected: bool, span: span,\n+           a: ty::Region, b: ty::Region) -> ures {\n+    debug!(\"mk_subr(%s <: %s)\", a.to_str(cx), b.to_str(cx));\n+    do indent {\n+        do cx.commit {\n+            cx.sub(a_is_expected, span).regions(a, b)\n+        }\n+    }.to_ures()\n+}\n+\n+fn mk_eqty(cx: infer_ctxt, a_is_expected: bool, span: span,\n+           a: ty::t, b: ty::t) -> ures {\n+    debug!(\"mk_eqty(%s <: %s)\", a.to_str(cx), b.to_str(cx));\n+    do indent {\n+        do cx.commit {\n+            let suber = cx.sub(a_is_expected, span);\n+            eq_tys(&suber, a, b)\n+        }\n+    }.to_ures()\n+}\n+\n+fn mk_assignty(cx: infer_ctxt, a_is_expected: bool, span: span,\n+               a: ty::t, b: ty::t) -> ares {\n+    debug!(\"mk_assignty(%s -> %s)\", a.to_str(cx), b.to_str(cx));\n+    do indent {\n+        do cx.commit {\n+            Assign(cx.combine_fields(a_is_expected, span)).tys(a, b)\n+        }\n+    }\n+}\n+\n+fn can_mk_assignty(cx: infer_ctxt, a: ty::t, b: ty::t) -> ures {\n+    debug!(\"can_mk_assignty(%s -> %s)\", a.to_str(cx), b.to_str(cx));\n+    do indent {\n+        do cx.probe {\n+            let span = ast_util::dummy_sp();\n+            Assign(cx.combine_fields(true, span)).tys(a, b)\n+        }\n+    }.to_ures()\n+}\n+\n+// See comment on the type `resolve_state` below\n+fn resolve_type(cx: infer_ctxt, a: ty::t, modes: uint)\n+    -> fres<ty::t> {\n+    resolver(cx, modes).resolve_type_chk(a)\n+}\n+\n+fn resolve_region(cx: infer_ctxt, r: ty::Region, modes: uint)\n+    -> fres<ty::Region> {\n+    resolver(cx, modes).resolve_region_chk(r)\n+}\n+\n+/*\n+fn resolve_borrowings(cx: infer_ctxt) {\n+    for cx.borrowings.each |item| {\n+        match resolve_region(cx, item.scope, resolve_all|force_all) {\n+          Ok(region) => {\n+            debug!(\"borrowing for expr %d resolved to region %?, mutbl %?\",\n+                   item.expr_id, region, item.mutbl);\n+            cx.tcx.borrowings.insert(\n+                item.expr_id, {region: region, mutbl: item.mutbl});\n+          }\n+\n+          Err(e) => {\n+            let str = fixup_err_to_str(e);\n+            cx.tcx.sess.span_err(\n+                item.span,\n+                fmt!(\"could not resolve lifetime for borrow: %s\", str));\n+          }\n+        }\n+    }\n+}\n+*/\n+\n+trait then {\n+    fn then<T:Copy>(f: fn() -> Result<T,ty::type_err>)\n+        -> Result<T,ty::type_err>;\n+}\n+\n+impl ures: then {\n+    fn then<T:Copy>(f: fn() -> Result<T,ty::type_err>)\n+        -> Result<T,ty::type_err> {\n+        self.chain(|_i| f())\n+    }\n+}\n+\n+trait ToUres {\n+    fn to_ures() -> ures;\n+}\n+\n+impl<T> cres<T>: ToUres {\n+    fn to_ures() -> ures {\n+        match self {\n+          Ok(_v) => Ok(()),\n+          Err(e) => Err(e)\n+        }\n+    }\n+}\n+\n+trait CresCompare<T> {\n+    fn compare(t: T, f: fn() -> ty::type_err) -> cres<T>;\n+}\n+\n+impl<T:Copy Eq> cres<T>: CresCompare<T> {\n+    fn compare(t: T, f: fn() -> ty::type_err) -> cres<T> {\n+        do self.chain |s| {\n+            if s == t {\n+                self\n+            } else {\n+                Err(f())\n+            }\n+        }\n+    }\n+}\n+\n+fn uok() -> ures {\n+    Ok(())\n+}\n+\n+fn rollback_to<V:Copy vid, T:Copy>(\n+    vb: &vals_and_bindings<V, T>, len: uint) {\n+\n+    while vb.bindings.len() != len {\n+        let (vid, old_v) = vb.bindings.pop();\n+        vb.vals.insert(vid.to_uint(), old_v);\n+    }\n+}\n+\n+struct Snapshot {\n+    ty_var_bindings_len: uint,\n+    int_var_bindings_len: uint,\n+    region_vars_snapshot: uint,\n+}\n+\n+impl infer_ctxt {\n+    fn combine_fields(a_is_expected: bool,\n+                      span: span) -> combine_fields {\n+        combine_fields {infcx: self,\n+                        a_is_expected: a_is_expected,\n+                        span: span}\n+    }\n+\n+    fn sub(a_is_expected: bool, span: span) -> Sub {\n+        Sub(self.combine_fields(a_is_expected, span))\n+    }\n+\n+    fn in_snapshot() -> bool {\n+        self.region_vars.in_snapshot()\n+    }\n+\n+    fn start_snapshot() -> Snapshot {\n+        Snapshot {\n+            ty_var_bindings_len:\n+                self.ty_var_bindings.bindings.len(),\n+            int_var_bindings_len:\n+                self.int_var_bindings.bindings.len(),\n+            region_vars_snapshot:\n+                self.region_vars.start_snapshot(),\n+        }\n+    }\n+\n+    fn rollback_to(snapshot: &Snapshot) {\n+        debug!(\"rollback!\");\n+        rollback_to(&self.ty_var_bindings, snapshot.ty_var_bindings_len);\n+\n+        // FIXME(#3211) -- int_var not transactional\n+        //rollback_to(&self.int_var_bindings,\n+        //            snapshot.int_var_bindings_len);\n+\n+        self.region_vars.rollback_to(\n+            snapshot.region_vars_snapshot);\n+    }\n+\n+    /// Execute `f` and commit the bindings if successful\n+    fn commit<T,E>(f: fn() -> Result<T,E>) -> Result<T,E> {\n+        assert !self.in_snapshot();\n+\n+        debug!(\"commit()\");\n+        do indent {\n+            let r = self.try(f);\n+\n+            self.ty_var_bindings.bindings.truncate(0);\n+            self.int_var_bindings.bindings.truncate(0);\n+            self.region_vars.commit();\n+            move r\n+        }\n+    }\n+\n+    /// Execute `f`, unroll bindings on failure\n+    fn try<T,E>(f: fn() -> Result<T,E>) -> Result<T,E> {\n+        debug!(\"try()\");\n+        do indent {\n+            let snapshot = self.start_snapshot();\n+            let r = f();\n+            match r {\n+              Ok(_) => (),\n+              Err(_) => self.rollback_to(&snapshot)\n+            }\n+            move r\n+        }\n+    }\n+\n+    /// Execute `f` then unroll any bindings it creates\n+    fn probe<T,E>(f: fn() -> Result<T,E>) -> Result<T,E> {\n+        debug!(\"probe()\");\n+        do indent {\n+            let snapshot = self.start_snapshot();\n+            let r = self.try(f);\n+            self.rollback_to(&snapshot);\n+            move r\n+        }\n+    }\n+}\n+\n+impl infer_ctxt {\n+    fn next_ty_var_id() -> TyVid {\n+        let id = *self.ty_var_counter;\n+        *self.ty_var_counter += 1u;\n+        self.ty_var_bindings.vals.insert(id,\n+                                         root({lb: None, ub: None}, 0u));\n+        return TyVid(id);\n+    }\n+\n+    fn next_ty_var() -> ty::t {\n+        ty::mk_var(self.tcx, self.next_ty_var_id())\n+    }\n+\n+    fn next_ty_vars(n: uint) -> ~[ty::t] {\n+        vec::from_fn(n, |_i| self.next_ty_var())\n+    }\n+\n+    fn next_int_var_id() -> IntVid {\n+        let id = *self.int_var_counter;\n+        *self.int_var_counter += 1u;\n+\n+        self.int_var_bindings.vals.insert(id,\n+                              root(int_ty_set_all(), 0u));\n+        return IntVid(id);\n+    }\n+\n+    fn next_int_var() -> ty::t {\n+        ty::mk_int_var(self.tcx, self.next_int_var_id())\n+    }\n+\n+    fn next_float_var_id() -> FloatVid {\n+        let id = *self.float_var_counter;\n+        *self.float_var_counter += 1;\n+\n+        self.float_var_bindings.vals.insert(id, root(float_ty_set_all(), 0));\n+        return FloatVid(id);\n+    }\n+\n+    fn next_float_var() -> ty::t {\n+        ty::mk_float_var(self.tcx, self.next_float_var_id())\n+    }\n+\n+    fn next_region_var_nb(span: span) -> ty::Region {\n+        ty::re_infer(ty::ReVar(self.region_vars.new_region_var(span)))\n+    }\n+\n+    fn next_region_var_with_lb(span: span,\n+                               lb_region: ty::Region) -> ty::Region {\n+        let region_var = self.next_region_var_nb(span);\n+\n+        // add lb_region as a lower bound on the newly built variable\n+        assert self.region_vars.make_subregion(span,\n+                                               lb_region,\n+                                               region_var).is_ok();\n+\n+        return region_var;\n+    }\n+\n+    fn next_region_var(span: span, scope_id: ast::node_id) -> ty::Region {\n+        self.next_region_var_with_lb(span, ty::re_scope(scope_id))\n+    }\n+\n+    fn resolve_regions() {\n+        self.region_vars.resolve_regions();\n+    }\n+\n+    fn ty_to_str(t: ty::t) -> ~str {\n+        ty_to_str(self.tcx,\n+                  self.resolve_type_vars_if_possible(t))\n+    }\n+\n+    fn resolve_type_vars_if_possible(typ: ty::t) -> ty::t {\n+        match resolve_type(self, typ, resolve_nested_tvar | resolve_ivar) {\n+          result::Ok(new_type) => new_type,\n+          result::Err(_) => typ\n+        }\n+    }\n+\n+    fn type_error_message(sp: span, mk_msg: fn(~str) -> ~str,\n+                          actual_ty: ty::t, err: Option<&ty::type_err>) {\n+        let actual_ty = self.resolve_type_vars_if_possible(actual_ty);\n+\n+        // Don't report an error if actual type is ty_err.\n+        match ty::get(actual_ty).sty {\n+            ty::ty_err => return,\n+            _           => ()\n+        }\n+        let error_str = err.map_default(~\"\", |t_err|\n+                         fmt!(\" (%s)\",\n+                              ty::type_err_to_str(self.tcx, *t_err)));\n+        self.tcx.sess.span_err(sp,\n+           fmt!(\"%s%s\", mk_msg(self.ty_to_str(actual_ty)),\n+                error_str));\n+        err.iter(|err|\n+             ty::note_and_explain_type_err(self.tcx, *err));\n+    }\n+\n+    fn report_mismatched_types(sp: span, e: ty::t, a: ty::t,\n+                               err: &ty::type_err) {\n+        // Don't report an error if expected is ty_err\n+        let resolved_expected =\n+            self.resolve_type_vars_if_possible(e);\n+        let mk_msg = match ty::get(resolved_expected).sty {\n+            ty::ty_err => return,\n+            _ => {\n+                // if I leave out : ~str, it infers &str and complains\n+                |actual: ~str| {\n+                    fmt!(\"mismatched types: expected `%s` but found `%s`\",\n+                         self.ty_to_str(resolved_expected), actual)\n+                }\n+            }\n+        };\n+        self.type_error_message(sp, mk_msg, a, Some(err));\n+    }\n+\n+    fn replace_bound_regions_with_fresh_regions(\n+        &self, span: span,\n+        fty: &ty::FnTy) -> (ty::FnTy, isr_alist)\n+    {\n+        let {fn_ty, isr, _} =\n+            replace_bound_regions_in_fn_ty(self.tcx, @Nil, None, fty, |br| {\n+                // N.B.: The name of the bound region doesn't have anything to\n+                // do with the region variable that's created for it.  The\n+                // only thing we're doing with `br` here is using it in the\n+                // debug message.\n+                let rvar = self.next_region_var_nb(span);\n+                debug!(\"Bound region %s maps to %?\",\n+                       bound_region_to_str(self.tcx, br),\n+                       rvar);\n+                rvar\n+            });\n+        (fn_ty, isr)\n+    }\n+\n+}\n+"}, {"sha": "655c09f684623402b85685905eee986565b3f8f5", "filename": "src/librustc/middle/typeck/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b38d7f65388fabf383d3e3a4e4c3a56403f57542/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b38d7f65388fabf383d3e3a4e4c3a56403f57542/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fmod.rs?ref=b38d7f65388fabf383d3e3a4e4c3a56403f57542", "patch": "@@ -79,13 +79,13 @@ export vtable_static, vtable_param, vtable_trait;\n export provided_methods_map;\n \n #[legacy_exports]\n-#[merge = \"check/mod.rs\"]\n+#[path = \"check/mod.rs\"]\n pub mod check;\n #[legacy_exports]\n mod rscope;\n #[legacy_exports]\n mod astconv;\n-#[merge = \"infer/mod.rs\"]\n+#[path = \"infer/mod.rs\"]\n mod infer;\n #[legacy_exports]\n mod collect;"}]}