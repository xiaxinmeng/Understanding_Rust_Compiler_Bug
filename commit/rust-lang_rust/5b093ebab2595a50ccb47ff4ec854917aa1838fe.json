{"sha": "5b093ebab2595a50ccb47ff4ec854917aa1838fe", "node_id": "MDY6Q29tbWl0NzI0NzEyOjViMDkzZWJhYjI1OTVhNTBjY2I0N2ZmNGVjODU0OTE3YWExODM4ZmU=", "commit": {"author": {"name": "Michael Woerister", "email": "michaelwoerister@posteo.net", "date": "2016-11-04T21:37:42Z"}, "committer": {"name": "Michael Woerister", "email": "michaelwoerister@posteo.net", "date": "2016-11-14T00:49:46Z"}, "message": "Make names of types used in LLVM IR stable.\n\nBefore this PR, type names could depend on the cratenum being used\nfor a given crate and also on the source location of closures.\nBoth are undesirable for incremental compilation where we cache\nLLVM IR and don't want it to depend on formatting or in which\norder crates are loaded.", "tree": {"sha": "138ef39770a4a3910c2ee7aa2be02a38e0603698", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/138ef39770a4a3910c2ee7aa2be02a38e0603698"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5b093ebab2595a50ccb47ff4ec854917aa1838fe", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5b093ebab2595a50ccb47ff4ec854917aa1838fe", "html_url": "https://github.com/rust-lang/rust/commit/5b093ebab2595a50ccb47ff4ec854917aa1838fe", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5b093ebab2595a50ccb47ff4ec854917aa1838fe/comments", "author": {"login": "michaelwoerister", "id": 1825894, "node_id": "MDQ6VXNlcjE4MjU4OTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1825894?v=4", "gravatar_id": "", "url": "https://api.github.com/users/michaelwoerister", "html_url": "https://github.com/michaelwoerister", "followers_url": "https://api.github.com/users/michaelwoerister/followers", "following_url": "https://api.github.com/users/michaelwoerister/following{/other_user}", "gists_url": "https://api.github.com/users/michaelwoerister/gists{/gist_id}", "starred_url": "https://api.github.com/users/michaelwoerister/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/michaelwoerister/subscriptions", "organizations_url": "https://api.github.com/users/michaelwoerister/orgs", "repos_url": "https://api.github.com/users/michaelwoerister/repos", "events_url": "https://api.github.com/users/michaelwoerister/events{/privacy}", "received_events_url": "https://api.github.com/users/michaelwoerister/received_events", "type": "User", "site_admin": false}, "committer": {"login": "michaelwoerister", "id": 1825894, "node_id": "MDQ6VXNlcjE4MjU4OTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1825894?v=4", "gravatar_id": "", "url": "https://api.github.com/users/michaelwoerister", "html_url": "https://github.com/michaelwoerister", "followers_url": "https://api.github.com/users/michaelwoerister/followers", "following_url": "https://api.github.com/users/michaelwoerister/following{/other_user}", "gists_url": "https://api.github.com/users/michaelwoerister/gists{/gist_id}", "starred_url": "https://api.github.com/users/michaelwoerister/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/michaelwoerister/subscriptions", "organizations_url": "https://api.github.com/users/michaelwoerister/orgs", "repos_url": "https://api.github.com/users/michaelwoerister/repos", "events_url": "https://api.github.com/users/michaelwoerister/events{/privacy}", "received_events_url": "https://api.github.com/users/michaelwoerister/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "876b7610100a6609db04be010144062f582cfb8c", "url": "https://api.github.com/repos/rust-lang/rust/commits/876b7610100a6609db04be010144062f582cfb8c", "html_url": "https://github.com/rust-lang/rust/commit/876b7610100a6609db04be010144062f582cfb8c"}], "stats": {"total": 566, "additions": 318, "deletions": 248}, "files": [{"sha": "bf3e682f86f699e0e55a4d1e4dca1eff71c30d1a", "filename": "src/librustc_data_structures/base_n.rs", "status": "added", "additions": 64, "deletions": 0, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/5b093ebab2595a50ccb47ff4ec854917aa1838fe/src%2Flibrustc_data_structures%2Fbase_n.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b093ebab2595a50ccb47ff4ec854917aa1838fe/src%2Flibrustc_data_structures%2Fbase_n.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Fbase_n.rs?ref=5b093ebab2595a50ccb47ff4ec854917aa1838fe", "patch": "@@ -0,0 +1,64 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+/// Convert unsigned integers into a string representation with some base.\n+/// Bases up to and including 36 can be used for case-insensitive things.\n+\n+use std::str;\n+\n+pub const MAX_BASE: u64 = 64;\n+const BASE_64: &'static [u8; MAX_BASE as usize] =\n+    b\"0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ@$\";\n+\n+#[inline]\n+pub fn push_str(mut n: u64, base: u64, output: &mut String) {\n+    debug_assert!(base >= 2 && base <= MAX_BASE);\n+    let mut s = [0u8; 64];\n+    let mut index = 0;\n+\n+    loop {\n+        s[index] = BASE_64[(n % base) as usize];\n+        index += 1;\n+        n /= base;\n+\n+        if n == 0 {\n+            break;\n+        }\n+    }\n+    &mut s[0..index].reverse();\n+    output.push_str(str::from_utf8(&s[0..index]).unwrap());\n+}\n+\n+#[inline]\n+pub fn encode(n: u64, base: u64) -> String {\n+    let mut s = String::with_capacity(13);\n+    push_str(n, base, &mut s);\n+    s\n+}\n+\n+#[test]\n+fn test_encode() {\n+    fn test(n: u64, base: u64) {\n+        assert_eq!(Ok(n), u64::from_str_radix(&encode(n, base)[..], base as u32));\n+    }\n+\n+    for base in 2..37 {\n+        test(0, base);\n+        test(1, base);\n+        test(35, base);\n+        test(36, base);\n+        test(37, base);\n+        test(u64::max_value(), base);\n+\n+        for i in 0 .. 1_000 {\n+            test(i * 983, base);\n+        }\n+    }\n+}"}, {"sha": "de13b9bf4be10c909c7b864ccf9c39cab94741b7", "filename": "src/librustc_data_structures/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/5b093ebab2595a50ccb47ff4ec854917aa1838fe/src%2Flibrustc_data_structures%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b093ebab2595a50ccb47ff4ec854917aa1838fe/src%2Flibrustc_data_structures%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Flib.rs?ref=5b093ebab2595a50ccb47ff4ec854917aa1838fe", "patch": "@@ -47,6 +47,7 @@ extern crate libc;\n pub mod array_vec;\n pub mod accumulate_vec;\n pub mod small_vec;\n+pub mod base_n;\n pub mod bitslice;\n pub mod blake2b;\n pub mod bitvec;"}, {"sha": "223200957cb7c27754fc1333c8562f737edceaa1", "filename": "src/librustc_incremental/persist/fs.rs", "status": "modified", "additions": 15, "deletions": 40, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/5b093ebab2595a50ccb47ff4ec854917aa1838fe/src%2Flibrustc_incremental%2Fpersist%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b093ebab2595a50ccb47ff4ec854917aa1838fe/src%2Flibrustc_incremental%2Fpersist%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fpersist%2Ffs.rs?ref=5b093ebab2595a50ccb47ff4ec854917aa1838fe", "patch": "@@ -119,7 +119,7 @@ use rustc::hir::svh::Svh;\n use rustc::session::Session;\n use rustc::ty::TyCtxt;\n use rustc::util::fs as fs_util;\n-use rustc_data_structures::flock;\n+use rustc_data_structures::{flock, base_n};\n use rustc_data_structures::fx::{FxHashSet, FxHashMap};\n \n use std::ffi::OsString;\n@@ -135,6 +135,12 @@ const DEP_GRAPH_FILENAME: &'static str = \"dep-graph.bin\";\n const WORK_PRODUCTS_FILENAME: &'static str = \"work-products.bin\";\n const METADATA_HASHES_FILENAME: &'static str = \"metadata.bin\";\n \n+// We encode integers using the following base, so they are shorter than decimal\n+// or hexadecimal numbers (we want short file and directory names). Since these\n+// numbers will be used in file names, we choose an encoding that is not\n+// case-sensitive (as opposed to base64, for example).\n+const INT_ENCODE_BASE: u64 = 36;\n+\n pub fn dep_graph_path(sess: &Session) -> PathBuf {\n     in_incr_comp_dir_sess(sess, DEP_GRAPH_FILENAME)\n }\n@@ -327,7 +333,7 @@ pub fn finalize_session_directory(sess: &Session, svh: Svh) {\n     let mut new_sub_dir_name = String::from(&old_sub_dir_name[.. dash_indices[2] + 1]);\n \n     // Append the svh\n-    new_sub_dir_name.push_str(&encode_base_36(svh.as_u64()));\n+    base_n::push_str(svh.as_u64(), INT_ENCODE_BASE, &mut new_sub_dir_name);\n \n     // Create the full path\n     let new_path = incr_comp_session_dir.parent().unwrap().join(new_sub_dir_name);\n@@ -433,7 +439,8 @@ fn generate_session_dir_path(crate_dir: &Path) -> PathBuf {\n \n     let directory_name = format!(\"s-{}-{}-working\",\n                                   timestamp,\n-                                  encode_base_36(random_number as u64));\n+                                  base_n::encode(random_number as u64,\n+                                                 INT_ENCODE_BASE));\n     debug!(\"generate_session_dir_path: directory_name = {}\", directory_name);\n     let directory_path = crate_dir.join(directory_name);\n     debug!(\"generate_session_dir_path: directory_path = {}\", directory_path.display());\n@@ -562,27 +569,11 @@ fn extract_timestamp_from_session_dir(directory_name: &str)\n     string_to_timestamp(&directory_name[dash_indices[0]+1 .. dash_indices[1]])\n }\n \n-const BASE_36: &'static [u8] = b\"0123456789abcdefghijklmnopqrstuvwxyz\";\n-\n-fn encode_base_36(mut n: u64) -> String {\n-    let mut s = Vec::with_capacity(13);\n-    loop {\n-        s.push(BASE_36[(n % 36) as usize]);\n-        n /= 36;\n-\n-        if n == 0 {\n-            break;\n-        }\n-    }\n-    s.reverse();\n-    String::from_utf8(s).unwrap()\n-}\n-\n fn timestamp_to_string(timestamp: SystemTime) -> String {\n     let duration = timestamp.duration_since(UNIX_EPOCH).unwrap();\n     let micros = duration.as_secs() * 1_000_000 +\n                 (duration.subsec_nanos() as u64) / 1000;\n-    encode_base_36(micros)\n+    base_n::encode(micros, INT_ENCODE_BASE)\n }\n \n fn string_to_timestamp(s: &str) -> Result<SystemTime, ()> {\n@@ -629,7 +620,7 @@ pub fn find_metadata_hashes_for(tcx: TyCtxt, cnum: CrateNum) -> Option<PathBuf>\n     };\n \n     let target_svh = tcx.sess.cstore.crate_hash(cnum);\n-    let target_svh = encode_base_36(target_svh.as_u64());\n+    let target_svh = base_n::encode(target_svh.as_u64(), INT_ENCODE_BASE);\n \n     let sub_dir = find_metadata_hashes_iter(&target_svh, dir_entries.filter_map(|e| {\n         e.ok().map(|e| e.file_name().to_string_lossy().into_owned())\n@@ -677,7 +668,9 @@ fn crate_path(sess: &Session,\n     let mut hasher = DefaultHasher::new();\n     crate_disambiguator.hash(&mut hasher);\n \n-    let crate_name = format!(\"{}-{}\", crate_name, encode_base_36(hasher.finish()));\n+    let crate_name = format!(\"{}-{}\",\n+                             crate_name,\n+                             base_n::encode(hasher.finish(), INT_ENCODE_BASE));\n     incr_dir.join(crate_name)\n }\n \n@@ -1049,21 +1042,3 @@ fn test_find_metadata_hashes_iter()\n         None\n     );\n }\n-\n-#[test]\n-fn test_encode_base_36() {\n-    fn test(n: u64) {\n-        assert_eq!(Ok(n), u64::from_str_radix(&encode_base_36(n)[..], 36));\n-    }\n-\n-    test(0);\n-    test(1);\n-    test(35);\n-    test(36);\n-    test(37);\n-    test(u64::max_value());\n-\n-    for i in 0 .. 1_000 {\n-        test(i * 983);\n-    }\n-}"}, {"sha": "0c0b7fbf4afeab483d41a26f8697cfc352741945", "filename": "src/librustc_trans/base.rs", "status": "modified", "additions": 10, "deletions": 2, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/5b093ebab2595a50ccb47ff4ec854917aa1838fe/src%2Flibrustc_trans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b093ebab2595a50ccb47ff4ec854917aa1838fe/src%2Flibrustc_trans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fbase.rs?ref=5b093ebab2595a50ccb47ff4ec854917aa1838fe", "patch": "@@ -74,7 +74,7 @@ use monomorphize::{self, Instance};\n use partitioning::{self, PartitioningStrategy, CodegenUnit};\n use symbol_map::SymbolMap;\n use symbol_names_test;\n-use trans_item::TransItem;\n+use trans_item::{TransItem, DefPathBasedNames};\n use type_::Type;\n use type_of;\n use value::Value;\n@@ -1004,7 +1004,15 @@ impl<'blk, 'tcx> FunctionContext<'blk, 'tcx> {\n }\n \n pub fn trans_instance<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, instance: Instance<'tcx>) {\n-    let _s = StatRecorder::new(ccx, ccx.tcx().item_path_str(instance.def));\n+    let _s = if ccx.sess().trans_stats() {\n+        let mut instance_name = String::new();\n+        DefPathBasedNames::new(ccx.tcx(), true, true)\n+            .push_def_path(instance.def, &mut instance_name);\n+        Some(StatRecorder::new(ccx, instance_name))\n+    } else {\n+        None\n+    };\n+\n     // this is an info! to allow collecting monomorphization statistics\n     // and to allow finding the last function before LLVM aborts from\n     // release builds."}, {"sha": "0fc6436e63cd8e352559ecbb872190586461fd9a", "filename": "src/librustc_trans/collector.rs", "status": "modified", "additions": 19, "deletions": 1, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/5b093ebab2595a50ccb47ff4ec854917aa1838fe/src%2Flibrustc_trans%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b093ebab2595a50ccb47ff4ec854917aa1838fe/src%2Flibrustc_trans%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcollector.rs?ref=5b093ebab2595a50ccb47ff4ec854917aa1838fe", "patch": "@@ -213,7 +213,7 @@ use glue::{self, DropGlueKind};\n use monomorphize::{self, Instance};\n use util::nodemap::{FxHashSet, FxHashMap, DefIdMap};\n \n-use trans_item::{TransItem, type_to_string, def_id_to_string};\n+use trans_item::{TransItem, DefPathBasedNames};\n \n #[derive(PartialEq, Eq, Hash, Clone, Copy, Debug)]\n pub enum TransItemCollectionMode {\n@@ -1234,3 +1234,21 @@ fn visit_mir_and_promoted<'tcx, V: MirVisitor<'tcx>>(mut visitor: V, mir: &mir::\n         visitor.visit_mir(promoted);\n     }\n }\n+\n+fn def_id_to_string<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                              def_id: DefId)\n+                              -> String {\n+    let mut output = String::new();\n+    let printer = DefPathBasedNames::new(tcx, false, false);\n+    printer.push_def_path(def_id, &mut output);\n+    output\n+}\n+\n+fn type_to_string<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                            ty: ty::Ty<'tcx>)\n+                            -> String {\n+    let mut output = String::new();\n+    let printer = DefPathBasedNames::new(tcx, false, false);\n+    printer.push_type_name(ty, &mut output);\n+    output\n+}"}, {"sha": "f7af2d6b855dfe216e8f8d1689b126c39d47e564", "filename": "src/librustc_trans/context.rs", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/5b093ebab2595a50ccb47ff4ec854917aa1838fe/src%2Flibrustc_trans%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b093ebab2595a50ccb47ff4ec854917aa1838fe/src%2Flibrustc_trans%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcontext.rs?ref=5b093ebab2595a50ccb47ff4ec854917aa1838fe", "patch": "@@ -26,6 +26,7 @@ use monomorphize::Instance;\n use partitioning::CodegenUnit;\n use trans_item::TransItem;\n use type_::Type;\n+use rustc_data_structures::base_n;\n use rustc::ty::subst::Substs;\n use rustc::ty::{self, Ty, TyCtxt};\n use session::config::NoDebugInfo;\n@@ -975,7 +976,11 @@ impl<'b, 'tcx> CrateContext<'b, 'tcx> {\n         self.local().local_gen_sym_counter.set(idx + 1);\n         // Include a '.' character, so there can be no accidental conflicts with\n         // user defined names\n-        format!(\"{}.{}\", prefix, idx)\n+        let mut name = String::with_capacity(prefix.len() + 6);\n+        name.push_str(prefix);\n+        name.push_str(\".\");\n+        base_n::push_str(idx as u64, base_n::MAX_BASE, &mut name);\n+        name\n     }\n }\n "}, {"sha": "94a68de7f8670efd1017a0cf2511b3f0e9c868b1", "filename": "src/librustc_trans/trans_item.rs", "status": "modified", "additions": 195, "deletions": 182, "changes": 377, "blob_url": "https://github.com/rust-lang/rust/blob/5b093ebab2595a50ccb47ff4ec854917aa1838fe/src%2Flibrustc_trans%2Ftrans_item.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b093ebab2595a50ccb47ff4ec854917aa1838fe/src%2Flibrustc_trans%2Ftrans_item.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans_item.rs?ref=5b093ebab2595a50ccb47ff4ec854917aa1838fe", "patch": "@@ -34,6 +34,7 @@ use type_of;\n use glue;\n use abi::{Abi, FnType};\n use back::symbol_names;\n+use std::fmt::Write;\n \n #[derive(PartialEq, Eq, Clone, Copy, Debug, Hash)]\n pub enum TransItem<'tcx> {\n@@ -307,7 +308,8 @@ impl<'a, 'tcx> TransItem<'tcx> {\n                     DropGlueKind::Ty(_) => s.push_str(\"drop-glue \"),\n                     DropGlueKind::TyContents(_) => s.push_str(\"drop-glue-contents \"),\n                 };\n-                push_unique_type_name(tcx, dg.ty(), &mut s);\n+                let printer = DefPathBasedNames::new(tcx, false, false);\n+                printer.push_type_name(dg.ty(), &mut s);\n                 s\n             }\n             TransItem::Fn(instance) => {\n@@ -326,7 +328,8 @@ impl<'a, 'tcx> TransItem<'tcx> {\n                                         -> String {\n             let mut result = String::with_capacity(32);\n             result.push_str(prefix);\n-            push_instance_as_string(tcx, instance, &mut result);\n+            let printer = DefPathBasedNames::new(tcx, false, false);\n+            printer.push_instance_as_string(instance, &mut result);\n             result\n         }\n     }\n@@ -367,209 +370,219 @@ impl<'a, 'tcx> TransItem<'tcx> {\n \n /// Same as `unique_type_name()` but with the result pushed onto the given\n /// `output` parameter.\n-pub fn push_unique_type_name<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                                       t: Ty<'tcx>,\n-                                       output: &mut String) {\n-    match t.sty {\n-        ty::TyBool              => output.push_str(\"bool\"),\n-        ty::TyChar              => output.push_str(\"char\"),\n-        ty::TyStr               => output.push_str(\"str\"),\n-        ty::TyNever             => output.push_str(\"!\"),\n-        ty::TyInt(ast::IntTy::Is)    => output.push_str(\"isize\"),\n-        ty::TyInt(ast::IntTy::I8)    => output.push_str(\"i8\"),\n-        ty::TyInt(ast::IntTy::I16)   => output.push_str(\"i16\"),\n-        ty::TyInt(ast::IntTy::I32)   => output.push_str(\"i32\"),\n-        ty::TyInt(ast::IntTy::I64)   => output.push_str(\"i64\"),\n-        ty::TyUint(ast::UintTy::Us)   => output.push_str(\"usize\"),\n-        ty::TyUint(ast::UintTy::U8)   => output.push_str(\"u8\"),\n-        ty::TyUint(ast::UintTy::U16)  => output.push_str(\"u16\"),\n-        ty::TyUint(ast::UintTy::U32)  => output.push_str(\"u32\"),\n-        ty::TyUint(ast::UintTy::U64)  => output.push_str(\"u64\"),\n-        ty::TyFloat(ast::FloatTy::F32) => output.push_str(\"f32\"),\n-        ty::TyFloat(ast::FloatTy::F64) => output.push_str(\"f64\"),\n-        ty::TyAdt(adt_def, substs) => {\n-            push_item_name(tcx, adt_def.did, output);\n-            push_type_params(tcx, substs, &[], output);\n-        },\n-        ty::TyTuple(component_types) => {\n-            output.push('(');\n-            for &component_type in component_types {\n-                push_unique_type_name(tcx, component_type, output);\n-                output.push_str(\", \");\n-            }\n-            if !component_types.is_empty() {\n-                output.pop();\n-                output.pop();\n-            }\n-            output.push(')');\n-        },\n-        ty::TyBox(inner_type) => {\n-            output.push_str(\"Box<\");\n-            push_unique_type_name(tcx, inner_type, output);\n-            output.push('>');\n-        },\n-        ty::TyRawPtr(ty::TypeAndMut { ty: inner_type, mutbl } ) => {\n-            output.push('*');\n-            match mutbl {\n-                hir::MutImmutable => output.push_str(\"const \"),\n-                hir::MutMutable => output.push_str(\"mut \"),\n-            }\n+pub struct DefPathBasedNames<'a, 'tcx: 'a> {\n+    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+    omit_disambiguators: bool,\n+    omit_local_crate_name: bool,\n+}\n \n-            push_unique_type_name(tcx, inner_type, output);\n-        },\n-        ty::TyRef(_, ty::TypeAndMut { ty: inner_type, mutbl }) => {\n-            output.push('&');\n-            if mutbl == hir::MutMutable {\n-                output.push_str(\"mut \");\n-            }\n+impl<'a, 'tcx> DefPathBasedNames<'a, 'tcx> {\n+    pub fn new(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+               omit_disambiguators: bool,\n+               omit_local_crate_name: bool)\n+               -> Self {\n+        DefPathBasedNames {\n+            tcx: tcx,\n+            omit_disambiguators: omit_disambiguators,\n+            omit_local_crate_name: omit_local_crate_name,\n+        }\n+    }\n \n-            push_unique_type_name(tcx, inner_type, output);\n-        },\n-        ty::TyArray(inner_type, len) => {\n-            output.push('[');\n-            push_unique_type_name(tcx, inner_type, output);\n-            output.push_str(&format!(\"; {}\", len));\n-            output.push(']');\n-        },\n-        ty::TySlice(inner_type) => {\n-            output.push('[');\n-            push_unique_type_name(tcx, inner_type, output);\n-            output.push(']');\n-        },\n-        ty::TyTrait(ref trait_data) => {\n-            push_item_name(tcx, trait_data.principal.def_id(), output);\n-            push_type_params(tcx,\n-                             trait_data.principal.skip_binder().substs,\n-                             &trait_data.projection_bounds,\n-                             output);\n-        },\n-        ty::TyFnDef(.., &ty::BareFnTy{ unsafety, abi, ref sig } ) |\n-        ty::TyFnPtr(&ty::BareFnTy{ unsafety, abi, ref sig } ) => {\n-            if unsafety == hir::Unsafety::Unsafe {\n-                output.push_str(\"unsafe \");\n-            }\n+    pub fn push_type_name(&self, t: Ty<'tcx>, output: &mut String) {\n+        match t.sty {\n+            ty::TyBool              => output.push_str(\"bool\"),\n+            ty::TyChar              => output.push_str(\"char\"),\n+            ty::TyStr               => output.push_str(\"str\"),\n+            ty::TyNever             => output.push_str(\"!\"),\n+            ty::TyInt(ast::IntTy::Is)    => output.push_str(\"isize\"),\n+            ty::TyInt(ast::IntTy::I8)    => output.push_str(\"i8\"),\n+            ty::TyInt(ast::IntTy::I16)   => output.push_str(\"i16\"),\n+            ty::TyInt(ast::IntTy::I32)   => output.push_str(\"i32\"),\n+            ty::TyInt(ast::IntTy::I64)   => output.push_str(\"i64\"),\n+            ty::TyUint(ast::UintTy::Us)   => output.push_str(\"usize\"),\n+            ty::TyUint(ast::UintTy::U8)   => output.push_str(\"u8\"),\n+            ty::TyUint(ast::UintTy::U16)  => output.push_str(\"u16\"),\n+            ty::TyUint(ast::UintTy::U32)  => output.push_str(\"u32\"),\n+            ty::TyUint(ast::UintTy::U64)  => output.push_str(\"u64\"),\n+            ty::TyFloat(ast::FloatTy::F32) => output.push_str(\"f32\"),\n+            ty::TyFloat(ast::FloatTy::F64) => output.push_str(\"f64\"),\n+            ty::TyAdt(adt_def, substs) => {\n+                self.push_def_path(adt_def.did, output);\n+                self.push_type_params(substs, &[], output);\n+            },\n+            ty::TyTuple(component_types) => {\n+                output.push('(');\n+                for &component_type in component_types {\n+                    self.push_type_name(component_type, output);\n+                    output.push_str(\", \");\n+                }\n+                if !component_types.is_empty() {\n+                    output.pop();\n+                    output.pop();\n+                }\n+                output.push(')');\n+            },\n+            ty::TyBox(inner_type) => {\n+                output.push_str(\"Box<\");\n+                self.push_type_name(inner_type, output);\n+                output.push('>');\n+            },\n+            ty::TyRawPtr(ty::TypeAndMut { ty: inner_type, mutbl } ) => {\n+                output.push('*');\n+                match mutbl {\n+                    hir::MutImmutable => output.push_str(\"const \"),\n+                    hir::MutMutable => output.push_str(\"mut \"),\n+                }\n \n-            if abi != ::abi::Abi::Rust {\n-                output.push_str(\"extern \\\"\");\n-                output.push_str(abi.name());\n-                output.push_str(\"\\\" \");\n-            }\n+                self.push_type_name(inner_type, output);\n+            },\n+            ty::TyRef(_, ty::TypeAndMut { ty: inner_type, mutbl }) => {\n+                output.push('&');\n+                if mutbl == hir::MutMutable {\n+                    output.push_str(\"mut \");\n+                }\n \n-            output.push_str(\"fn(\");\n+                self.push_type_name(inner_type, output);\n+            },\n+            ty::TyArray(inner_type, len) => {\n+                output.push('[');\n+                self.push_type_name(inner_type, output);\n+                write!(output, \"; {}\", len).unwrap();\n+                output.push(']');\n+            },\n+            ty::TySlice(inner_type) => {\n+                output.push('[');\n+                self.push_type_name(inner_type, output);\n+                output.push(']');\n+            },\n+            ty::TyTrait(ref trait_data) => {\n+                self.push_def_path(trait_data.principal.def_id(), output);\n+                self.push_type_params(trait_data.principal.skip_binder().substs,\n+                                      &trait_data.projection_bounds,\n+                                      output);\n+            },\n+            ty::TyFnDef(.., &ty::BareFnTy{ unsafety, abi, ref sig } ) |\n+            ty::TyFnPtr(&ty::BareFnTy{ unsafety, abi, ref sig } ) => {\n+                if unsafety == hir::Unsafety::Unsafe {\n+                    output.push_str(\"unsafe \");\n+                }\n \n-            let sig = tcx.erase_late_bound_regions_and_normalize(sig);\n-            if !sig.inputs.is_empty() {\n-                for &parameter_type in &sig.inputs {\n-                    push_unique_type_name(tcx, parameter_type, output);\n-                    output.push_str(\", \");\n+                if abi != ::abi::Abi::Rust {\n+                    output.push_str(\"extern \\\"\");\n+                    output.push_str(abi.name());\n+                    output.push_str(\"\\\" \");\n                 }\n-                output.pop();\n-                output.pop();\n-            }\n \n-            if sig.variadic {\n-                if !sig.inputs.is_empty() {\n-                    output.push_str(\", ...\");\n-                } else {\n-                    output.push_str(\"...\");\n+                output.push_str(\"fn(\");\n+\n+                let ty::FnSig {\n+                    inputs: sig_inputs,\n+                    output: sig_output,\n+                    variadic: sig_variadic\n+                } = self.tcx.erase_late_bound_regions_and_normalize(sig);\n+\n+                if !sig_inputs.is_empty() {\n+                    for &parameter_type in &sig_inputs {\n+                        self.push_type_name(parameter_type, output);\n+                        output.push_str(\", \");\n+                    }\n+                    output.pop();\n+                    output.pop();\n+                }\n+\n+                if sig_variadic {\n+                    if !sig_inputs.is_empty() {\n+                        output.push_str(\", ...\");\n+                    } else {\n+                        output.push_str(\"...\");\n+                    }\n                 }\n-            }\n \n-            output.push(')');\n+                output.push(')');\n \n-            if !sig.output.is_nil() {\n-                output.push_str(\" -> \");\n-                push_unique_type_name(tcx, sig.output, output);\n+                if !sig_output.is_nil() {\n+                    output.push_str(\" -> \");\n+                    self.push_type_name(sig_output, output);\n+                }\n+            },\n+            ty::TyClosure(def_id, ref closure_substs) => {\n+                self.push_def_path(def_id, output);\n+                let generics = self.tcx.item_generics(self.tcx.closure_base_def_id(def_id));\n+                let substs = closure_substs.substs.truncate_to(self.tcx, generics);\n+                self.push_type_params(substs, &[], output);\n+            }\n+            ty::TyError |\n+            ty::TyInfer(_) |\n+            ty::TyProjection(..) |\n+            ty::TyParam(_) |\n+            ty::TyAnon(..) => {\n+                bug!(\"DefPathBasedNames: Trying to create type name for \\\n+                                         unexpected type: {:?}\", t);\n             }\n-        },\n-        ty::TyClosure(def_id, closure_substs) => {\n-            push_item_name(tcx, def_id, output);\n-            output.push_str(\"{\");\n-            output.push_str(&format!(\"{}:{}\", def_id.krate, def_id.index.as_usize()));\n-            output.push_str(\"}\");\n-            let generics = tcx.item_generics(tcx.closure_base_def_id(def_id));\n-            let substs = closure_substs.substs.truncate_to(tcx, generics);\n-            push_type_params(tcx, substs, &[], output);\n-        }\n-        ty::TyError |\n-        ty::TyInfer(_) |\n-        ty::TyProjection(..) |\n-        ty::TyParam(_) |\n-        ty::TyAnon(..) => {\n-            bug!(\"debuginfo: Trying to create type name for \\\n-                  unexpected type: {:?}\", t);\n         }\n     }\n-}\n-\n-fn push_item_name(tcx: TyCtxt,\n-                  def_id: DefId,\n-                  output: &mut String) {\n-    let def_path = tcx.def_path(def_id);\n \n-    // some_crate::\n-    output.push_str(&tcx.crate_name(def_path.krate));\n-    output.push_str(\"::\");\n+    pub fn push_def_path(&self,\n+                         def_id: DefId,\n+                         output: &mut String) {\n+        let def_path = self.tcx.def_path(def_id);\n \n-    // foo::bar::ItemName::\n-    for part in tcx.def_path(def_id).data {\n-        output.push_str(&format!(\"{}[{}]::\",\n-                        part.data.as_interned_str(),\n-                        part.disambiguator));\n-    }\n+        // some_crate::\n+        if !(self.omit_local_crate_name && def_id.is_local()) {\n+            output.push_str(&self.tcx.crate_name(def_path.krate));\n+            output.push_str(\"::\");\n+        }\n \n-    // remove final \"::\"\n-    output.pop();\n-    output.pop();\n-}\n+        // foo::bar::ItemName::\n+        for part in self.tcx.def_path(def_id).data {\n+            if self.omit_disambiguators {\n+                write!(output, \"{}::\", part.data.as_interned_str()).unwrap();\n+            } else {\n+                write!(output, \"{}[{}]::\",\n+                       part.data.as_interned_str(),\n+                       part.disambiguator).unwrap();\n+            }\n+        }\n \n-fn push_type_params<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                              substs: &Substs<'tcx>,\n-                              projections: &[ty::PolyExistentialProjection<'tcx>],\n-                              output: &mut String) {\n-    if substs.types().next().is_none() && projections.is_empty() {\n-        return;\n+        // remove final \"::\"\n+        output.pop();\n+        output.pop();\n     }\n \n-    output.push('<');\n-\n-    for type_parameter in substs.types() {\n-        push_unique_type_name(tcx, type_parameter, output);\n-        output.push_str(\", \");\n-    }\n+    pub fn push_type_params(&self,\n+                            substs: &Substs<'tcx>,\n+                            projections: &[ty::PolyExistentialProjection<'tcx>],\n+                            output: &mut String) {\n+        if substs.types().next().is_none() && projections.is_empty() {\n+            return;\n+        }\n \n-    for projection in projections {\n-        let projection = projection.skip_binder();\n-        let name = &projection.item_name.as_str();\n-        output.push_str(name);\n-        output.push_str(\"=\");\n-        push_unique_type_name(tcx, projection.ty, output);\n-        output.push_str(\", \");\n-    }\n+        output.push('<');\n \n-    output.pop();\n-    output.pop();\n+        for type_parameter in substs.types() {\n+            self.push_type_name(type_parameter, output);\n+            output.push_str(\", \");\n+        }\n \n-    output.push('>');\n-}\n+        for projection in projections {\n+            let projection = projection.skip_binder();\n+            let name = &projection.item_name.as_str();\n+            output.push_str(name);\n+            output.push_str(\"=\");\n+            self.push_type_name(projection.ty, output);\n+            output.push_str(\", \");\n+        }\n \n-fn push_instance_as_string<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                                     instance: Instance<'tcx>,\n-                                     output: &mut String) {\n-    push_item_name(tcx, instance.def, output);\n-    push_type_params(tcx, instance.substs, &[], output);\n-}\n+        output.pop();\n+        output.pop();\n \n-pub fn def_id_to_string(tcx: TyCtxt, def_id: DefId) -> String {\n-    let mut output = String::new();\n-    push_item_name(tcx, def_id, &mut output);\n-    output\n-}\n+        output.push('>');\n+    }\n \n-pub fn type_to_string<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                                ty: Ty<'tcx>)\n-                                -> String {\n-    let mut output = String::new();\n-    push_unique_type_name(tcx, ty, &mut output);\n-    output\n+    pub fn push_instance_as_string(&self,\n+                                   instance: Instance<'tcx>,\n+                                   output: &mut String) {\n+        self.push_def_path(instance.def, output);\n+        self.push_type_params(instance.substs, &[], output);\n+    }\n }"}, {"sha": "16d4f97200cb2147ad07734f45ee6cfc266d4f52", "filename": "src/librustc_trans/type_of.rs", "status": "modified", "additions": 8, "deletions": 22, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/5b093ebab2595a50ccb47ff4ec854917aa1838fe/src%2Flibrustc_trans%2Ftype_of.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b093ebab2595a50ccb47ff4ec854917aa1838fe/src%2Flibrustc_trans%2Ftype_of.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftype_of.rs?ref=5b093ebab2595a50ccb47ff4ec854917aa1838fe", "patch": "@@ -10,14 +10,12 @@\n \n #![allow(non_camel_case_types)]\n \n-use rustc::hir::def_id::DefId;\n use abi::FnType;\n use adt;\n use common::*;\n use machine;\n use rustc::ty::{self, Ty, TypeFoldable};\n-use rustc::ty::subst::Substs;\n-\n+use trans_item::DefPathBasedNames;\n use type_::Type;\n \n use syntax::ast;\n@@ -282,12 +280,12 @@ pub fn in_memory_type_of<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>, t: Ty<'tcx>) ->\n           let n = t.simd_size(cx.tcx()) as u64;\n           Type::vector(&llet, n)\n       }\n-      ty::TyAdt(def, substs) => {\n+      ty::TyAdt(..) => {\n           // Only create the named struct, but don't fill it in. We\n           // fill it in *after* placing it into the type cache. This\n           // avoids creating more than one copy of the enum when one\n           // of the enum's variants refers to the enum itself.\n-          let name = llvm_type_name(cx, def.did, substs);\n+          let name = llvm_type_name(cx, t);\n           adt::incomplete_type_of(cx, t, &name[..])\n       }\n \n@@ -319,21 +317,9 @@ pub fn align_of<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>, t: Ty<'tcx>)\n     layout.align(&cx.tcx().data_layout).abi() as machine::llalign\n }\n \n-fn llvm_type_name<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n-                            did: DefId,\n-                            substs: &Substs<'tcx>)\n-                            -> String {\n-    let base = cx.tcx().item_path_str(did);\n-    let strings: Vec<String> = substs.types().map(|t| t.to_string()).collect();\n-    let tstr = if strings.is_empty() {\n-        base\n-    } else {\n-        format!(\"{}<{}>\", base, strings.join(\", \"))\n-    };\n-\n-    if did.is_local() {\n-        tstr\n-    } else {\n-        format!(\"{}.{}\", did.krate, tstr)\n-    }\n+fn llvm_type_name<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>, ty: Ty<'tcx>) -> String {\n+    let mut name = String::with_capacity(32);\n+    let printer = DefPathBasedNames::new(cx.tcx(), true, true);\n+    printer.push_type_name(ty, &mut name);\n+    name\n }"}]}