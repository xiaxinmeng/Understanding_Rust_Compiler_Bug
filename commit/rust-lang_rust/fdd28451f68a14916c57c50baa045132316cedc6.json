{"sha": "fdd28451f68a14916c57c50baa045132316cedc6", "node_id": "MDY6Q29tbWl0NzI0NzEyOmZkZDI4NDUxZjY4YTE0OTE2YzU3YzUwYmFhMDQ1MTMyMzE2Y2VkYzY=", "commit": {"author": {"name": "Jed Davis", "email": "jld@panix.com", "date": "2013-02-24T06:53:40Z"}, "committer": {"name": "Jed Davis", "email": "jld@panix.com", "date": "2013-03-07T04:41:57Z"}, "message": "Convert expr_struct to use adt, and try to share code with tuples.", "tree": {"sha": "5e09450668aa3e302d64e02b1e3696f978f77994", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5e09450668aa3e302d64e02b1e3696f978f77994"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/fdd28451f68a14916c57c50baa045132316cedc6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/fdd28451f68a14916c57c50baa045132316cedc6", "html_url": "https://github.com/rust-lang/rust/commit/fdd28451f68a14916c57c50baa045132316cedc6", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/fdd28451f68a14916c57c50baa045132316cedc6/comments", "author": {"login": "jld", "id": 254973, "node_id": "MDQ6VXNlcjI1NDk3Mw==", "avatar_url": "https://avatars.githubusercontent.com/u/254973?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jld", "html_url": "https://github.com/jld", "followers_url": "https://api.github.com/users/jld/followers", "following_url": "https://api.github.com/users/jld/following{/other_user}", "gists_url": "https://api.github.com/users/jld/gists{/gist_id}", "starred_url": "https://api.github.com/users/jld/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jld/subscriptions", "organizations_url": "https://api.github.com/users/jld/orgs", "repos_url": "https://api.github.com/users/jld/repos", "events_url": "https://api.github.com/users/jld/events{/privacy}", "received_events_url": "https://api.github.com/users/jld/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jld", "id": 254973, "node_id": "MDQ6VXNlcjI1NDk3Mw==", "avatar_url": "https://avatars.githubusercontent.com/u/254973?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jld", "html_url": "https://github.com/jld", "followers_url": "https://api.github.com/users/jld/followers", "following_url": "https://api.github.com/users/jld/following{/other_user}", "gists_url": "https://api.github.com/users/jld/gists{/gist_id}", "starred_url": "https://api.github.com/users/jld/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jld/subscriptions", "organizations_url": "https://api.github.com/users/jld/orgs", "repos_url": "https://api.github.com/users/jld/repos", "events_url": "https://api.github.com/users/jld/events{/privacy}", "received_events_url": "https://api.github.com/users/jld/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5cbc2571c1a4df75750fcb726120db06eb61c1f9", "url": "https://api.github.com/repos/rust-lang/rust/commits/5cbc2571c1a4df75750fcb726120db06eb61c1f9", "html_url": "https://github.com/rust-lang/rust/commit/5cbc2571c1a4df75750fcb726120db06eb61c1f9"}], "stats": {"total": 179, "additions": 73, "deletions": 106}, "files": [{"sha": "978ee641a7151a8a10ff5a5a7b1418539220b4e3", "filename": "src/librustc/middle/trans/expr.rs", "status": "modified", "additions": 73, "deletions": 106, "changes": 179, "blob_url": "https://github.com/rust-lang/rust/blob/fdd28451f68a14916c57c50baa045132316cedc6/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fdd28451f68a14916c57c50baa045132316cedc6/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs?ref=fdd28451f68a14916c57c50baa045132316cedc6", "patch": "@@ -604,7 +604,8 @@ fn trans_rvalue_dps_unadjusted(bcx: block, expr: @ast::expr,\n         }\n         ast::expr_tup(ref args) => {\n             let repr = adt::represent_type(bcx.ccx(), expr_ty(bcx, expr));\n-            return trans_adt(bcx, &repr, 0, *args, dest);\n+            return trans_adt(bcx, &repr, 0, args.mapi(|i, arg| (i, *arg)),\n+                             None, dest);\n         }\n         ast::expr_lit(@codemap::spanned {node: ast::lit_str(s), _}) => {\n             return tvec::trans_lit_str(bcx, expr, s, dest);\n@@ -885,7 +886,7 @@ fn trans_lvalue_unadjusted(bcx: block, expr: @ast::expr) -> DatumBlock {\n         let _icx = bcx.insn_ctxt(\"trans_rec_field\");\n \n         let base_datum = unpack_datum!(bcx, trans_to_datum(bcx, base));\n-        do with_field_tys(bcx.tcx(), base_datum.ty, None) |_dtor, field_tys| {\n+        do with_field_tys(bcx.tcx(), base_datum.ty, None) |_disr, field_tys| {\n             let ix = ty::field_idx_strict(bcx.tcx(), field, field_tys);\n             DatumBlock {\n                 datum: base_datum.GEPi(bcx,\n@@ -1098,15 +1099,14 @@ pub fn trans_local_var(bcx: block, def: ast::def) -> Datum {\n pub fn with_field_tys<R>(tcx: ty::ctxt,\n                          ty: ty::t,\n                          node_id_opt: Option<ast::node_id>,\n-                         op: fn(bool, (&[ty::field])) -> R) -> R {\n+                         op: fn(int, (&[ty::field])) -> R) -> R {\n     match ty::get(ty).sty {\n         ty::ty_rec(ref fields) => {\n-            op(false, *fields)\n+            op(0, *fields)\n         }\n \n         ty::ty_struct(did, ref substs) => {\n-            let has_dtor = ty::ty_dtor(tcx, did).is_present();\n-            op(has_dtor, struct_mutable_fields(tcx, did, substs))\n+            op(0, struct_mutable_fields(tcx, did, substs))\n         }\n \n         ty::ty_enum(_, ref substs) => {\n@@ -1120,8 +1120,10 @@ pub fn with_field_tys<R>(tcx: ty::ctxt,\n                 }\n                 Some(node_id) => {\n                     match tcx.def_map.get(&node_id) {\n-                        ast::def_variant(_, variant_id) => {\n-                            op(false, struct_mutable_fields(\n+                        ast::def_variant(enum_id, variant_id) => {\n+                            let variant_info = ty::enum_variant_with_id(\n+                                tcx, enum_id, variant_id);\n+                            op(variant_info.disr_val, struct_mutable_fields(\n                                 tcx, variant_id, substs))\n                         }\n                         _ => {\n@@ -1150,135 +1152,100 @@ fn trans_rec_or_struct(bcx: block,\n     let _icx = bcx.insn_ctxt(\"trans_rec\");\n     let mut bcx = bcx;\n \n-    // Handle the case where the result is ignored.\n-    let addr;\n-    match dest {\n-        SaveIn(p) => {\n-            addr = p;\n-        }\n-        Ignore => {\n-            // just evaluate the values for each field and drop them\n-            // on the floor\n-            for vec::each(fields) |fld| {\n-                bcx = trans_into(bcx, fld.node.expr, Ignore);\n-            }\n-            return bcx;\n-        }\n-    }\n-\n-    // If this is a struct-like variant, write in the discriminant if\n-    // necessary, position the address at the right location, and cast the\n-    // address.\n     let ty = node_id_type(bcx, id);\n     let tcx = bcx.tcx();\n-    let addr = match ty::get(ty).sty {\n-        ty::ty_enum(_, ref substs) => {\n-            match tcx.def_map.get(&id) {\n-                ast::def_variant(enum_id, variant_id) => {\n-                    let variant_info = ty::enum_variant_with_id(\n-                        tcx, enum_id, variant_id);\n-                    let addr = if ty::enum_is_univariant(tcx, enum_id) {\n-                        addr\n-                    } else {\n-                        Store(bcx,\n-                              C_int(bcx.ccx(), variant_info.disr_val),\n-                              GEPi(bcx, addr, [0, 0]));\n-                        GEPi(bcx, addr, [0, 1])\n-                    };\n-                    let fields = ty::struct_mutable_fields(\n-                        tcx, variant_id, substs);\n-                    let field_lltys = do fields.map |field| {\n-                        type_of::type_of(bcx.ccx(),\n-                                ty::subst_tps(\n-                                    tcx, substs.tps, None, field.mt.ty))\n-                    };\n-                    PointerCast(bcx, addr,\n-                                T_ptr(T_struct(~[T_struct(field_lltys)])))\n+    do with_field_tys(tcx, ty, Some(id)) |discr, field_tys| {\n+        let mut need_base = vec::from_elem(field_tys.len(), true);\n+\n+        let numbered_fields = do fields.map |field| {\n+            match do vec::position(field_tys) |field_ty| {\n+                field_ty.ident == field.node.ident\n+            } {\n+                Some(i) => {\n+                    need_base[i] = false;\n+                    (i, field.node.expr)\n                 }\n-                _ => {\n-                    tcx.sess.bug(~\"resolve didn't write the right def in for \\\n-                                   this struct-like variant\")\n+                None => {\n+                    tcx.sess.span_bug(field.span,\n+                                      ~\"Couldn't find field in struct type\")\n                 }\n             }\n-        }\n-        _ => addr\n-    };\n-\n-    do with_field_tys(tcx, ty, Some(id)) |has_dtor, field_tys| {\n-        // evaluate each of the fields and store them into their\n-        // correct locations\n-        let mut temp_cleanups = ~[];\n-        for fields.each |field| {\n-            let ix = ty::field_idx_strict(tcx, field.node.ident, field_tys);\n-            let dest = GEPi(bcx, addr, struct_field(ix));\n-            bcx = trans_into(bcx, field.node.expr, SaveIn(dest));\n-            add_clean_temp_mem(bcx, dest, field_tys[ix].mt.ty);\n-            temp_cleanups.push(dest);\n-        }\n-\n-        // copy over any remaining fields from the base (for\n-        // functional record update)\n-        for base.each |base_expr| {\n-            let base_datum = unpack_datum!(\n-                bcx, trans_to_datum(bcx, *base_expr));\n-\n-            // Copy/move over inherited fields\n-            for field_tys.eachi |i, field_ty| {\n-                if !fields.any(|f| f.node.ident == field_ty.ident) {\n-                    let dest = GEPi(bcx, addr, struct_field(i));\n-                    let base_field =\n-                        base_datum.GEPi(bcx,\n-                                        struct_field(i),\n-                                        field_ty.mt.ty,\n-                                        ZeroMem);\n-                    bcx = base_field.store_to(bcx, base_expr.id, INIT, dest);\n+        };\n+        let optbase = match base {\n+            Some(base_expr) => {\n+                let mut leftovers = ~[];\n+                for need_base.eachi |i, b| {\n+                    if *b {\n+                        leftovers.push((i, field_tys[i].mt.ty))\n+                    }\n                 }\n+                Some(StructBaseInfo {expr: base_expr,\n+                                     fields: leftovers })\n             }\n-        }\n-\n-        // Add the drop flag if necessary.\n-        if has_dtor {\n-            let dest = GEPi(bcx, addr, struct_dtor());\n-            Store(bcx, C_u8(1), dest);\n-        }\n+            None => {\n+                if need_base.any(|b| *b) {\n+                    // XXX should be span bug\n+                    tcx.sess.bug(~\"missing fields and no base expr\")\n+                }\n+                None\n+            }\n+        };\n \n-        // Now revoke the cleanups as we pass responsibility for the data\n-        // structure on to the caller\n-        for temp_cleanups.each |cleanup| {\n-            revoke_clean(bcx, *cleanup);\n-        }\n-        bcx\n+        let repr = adt::represent_type(bcx.ccx(), ty);\n+        trans_adt(bcx, &repr, discr, numbered_fields, optbase, dest)\n     }\n }\n \n-fn trans_adt(bcx: block, repr: &adt::Repr, discr: int, elts: &[@ast::expr],\n+struct StructBaseInfo {\n+    expr: @ast::expr,\n+    fields: ~[(uint, ty::t)]\n+}\n+\n+fn trans_adt(bcx: block, repr: &adt::Repr, discr: int,\n+             fields: &[(uint, @ast::expr)],\n+             optbase: Option<StructBaseInfo>,\n              dest: Dest) -> block {\n-    let _icx = bcx.insn_ctxt(\"trans_tup\");\n+    let _icx = bcx.insn_ctxt(\"trans_adt\");\n     let mut bcx = bcx;\n     let addr = match dest {\n         Ignore => {\n-            for vec::each(elts) |ex| {\n-                bcx = trans_into(bcx, *ex, Ignore);\n+            for fields.each |&(_i, e)| {\n+                bcx = trans_into(bcx, e, Ignore);\n+            }\n+            for optbase.each |sbi| {\n+                bcx = trans_into(bcx, sbi.expr, Ignore);\n             }\n             return bcx;\n         }\n-        SaveIn(pos) => pos,\n+        SaveIn(pos) => pos\n     };\n     let mut temp_cleanups = ~[];\n     adt::trans_set_discr(bcx, repr, addr, discr);\n-    for vec::eachi(elts) |i, e| {\n+    for fields.each |&(i, e)| {\n         let dest = adt::trans_GEP(bcx, repr, addr, discr, i);\n-        let e_ty = expr_ty(bcx, *e);\n-        bcx = trans_into(bcx, *e, SaveIn(dest));\n+        let e_ty = expr_ty(bcx, e);\n+        bcx = trans_into(bcx, e, SaveIn(dest));\n         add_clean_temp_mem(bcx, dest, e_ty);\n         temp_cleanups.push(dest);\n     }\n+    for optbase.each |base| {\n+        let base_datum = unpack_datum!(bcx, trans_to_datum(bcx, base.expr));\n+        for base.fields.each |&(i, t)| {\n+            let datum =\n+                // XXX convert this to adt\n+                base_datum.GEPi(bcx, struct_field(i), t, ZeroMem);\n+            let dest = adt::trans_GEP(bcx, repr, addr, discr, i);\n+            bcx = datum.store_to(bcx, base.expr.id, INIT, dest);\n+        }\n+    }\n+\n     for vec::each(temp_cleanups) |cleanup| {\n         revoke_clean(bcx, *cleanup);\n     }\n     return bcx;\n }\n \n+\n fn trans_immediate_lit(bcx: block, expr: @ast::expr,\n                        lit: ast::lit) -> DatumBlock {\n     // must not be a string constant, that is a RvalueDpsExpr"}]}