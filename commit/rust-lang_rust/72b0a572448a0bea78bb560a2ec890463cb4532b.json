{"sha": "72b0a572448a0bea78bb560a2ec890463cb4532b", "node_id": "C_kwDOAAsO6NoAKDcyYjBhNTcyNDQ4YTBiZWE3OGJiNTYwYTJlYzg5MDQ2M2NiNDUzMmI", "commit": {"author": {"name": "Noah Lev", "email": "camelidcamel@gmail.com", "date": "2021-11-07T17:19:25Z"}, "committer": {"name": "Noah Lev", "email": "camelidcamel@gmail.com", "date": "2021-11-07T17:19:58Z"}, "message": "Remove Clean impl for `Vec<T>`", "tree": {"sha": "c742aa65b505eae3a38f6d739b0d718b2aafaea4", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c742aa65b505eae3a38f6d739b0d718b2aafaea4"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/72b0a572448a0bea78bb560a2ec890463cb4532b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/72b0a572448a0bea78bb560a2ec890463cb4532b", "html_url": "https://github.com/rust-lang/rust/commit/72b0a572448a0bea78bb560a2ec890463cb4532b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/72b0a572448a0bea78bb560a2ec890463cb4532b/comments", "author": {"login": "camelid", "id": 37223377, "node_id": "MDQ6VXNlcjM3MjIzMzc3", "avatar_url": "https://avatars.githubusercontent.com/u/37223377?v=4", "gravatar_id": "", "url": "https://api.github.com/users/camelid", "html_url": "https://github.com/camelid", "followers_url": "https://api.github.com/users/camelid/followers", "following_url": "https://api.github.com/users/camelid/following{/other_user}", "gists_url": "https://api.github.com/users/camelid/gists{/gist_id}", "starred_url": "https://api.github.com/users/camelid/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/camelid/subscriptions", "organizations_url": "https://api.github.com/users/camelid/orgs", "repos_url": "https://api.github.com/users/camelid/repos", "events_url": "https://api.github.com/users/camelid/events{/privacy}", "received_events_url": "https://api.github.com/users/camelid/received_events", "type": "User", "site_admin": false}, "committer": {"login": "camelid", "id": 37223377, "node_id": "MDQ6VXNlcjM3MjIzMzc3", "avatar_url": "https://avatars.githubusercontent.com/u/37223377?v=4", "gravatar_id": "", "url": "https://api.github.com/users/camelid", "html_url": "https://github.com/camelid", "followers_url": "https://api.github.com/users/camelid/followers", "following_url": "https://api.github.com/users/camelid/following{/other_user}", "gists_url": "https://api.github.com/users/camelid/gists{/gist_id}", "starred_url": "https://api.github.com/users/camelid/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/camelid/subscriptions", "organizations_url": "https://api.github.com/users/camelid/orgs", "repos_url": "https://api.github.com/users/camelid/repos", "events_url": "https://api.github.com/users/camelid/events{/privacy}", "received_events_url": "https://api.github.com/users/camelid/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "efe4d7ca7e463692b56275a7cccbec4c54eb4f3f", "url": "https://api.github.com/repos/rust-lang/rust/commits/efe4d7ca7e463692b56275a7cccbec4c54eb4f3f", "html_url": "https://github.com/rust-lang/rust/commit/efe4d7ca7e463692b56275a7cccbec4c54eb4f3f"}], "stats": {"total": 96, "additions": 47, "deletions": 49}, "files": [{"sha": "f44589f60675f5dbe8bb38c358121be812d540d1", "filename": "src/librustdoc/clean/blanket_impl.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/72b0a572448a0bea78bb560a2ec890463cb4532b/src%2Flibrustdoc%2Fclean%2Fblanket_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/72b0a572448a0bea78bb560a2ec890463cb4532b/src%2Flibrustdoc%2Fclean%2Fblanket_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fblanket_impl.rs?ref=72b0a572448a0bea78bb560a2ec890463cb4532b", "patch": "@@ -121,8 +121,8 @@ impl<'a, 'tcx> BlanketImplFinder<'a, 'tcx> {\n                             .tcx\n                             .associated_items(impl_def_id)\n                             .in_definition_order()\n-                            .collect::<Vec<_>>()\n-                            .clean(self.cx),\n+                            .map(|x| x.clean(self.cx))\n+                            .collect::<Vec<_>>(),\n                         polarity: ty::ImplPolarity::Positive,\n                         kind: ImplKind::Blanket(box trait_ref.self_ty().clean(self.cx)),\n                     }),"}, {"sha": "d670288270a403cfb4b4c2757a56b36a973ed9d0", "filename": "src/librustdoc/clean/inline.rs", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/72b0a572448a0bea78bb560a2ec890463cb4532b/src%2Flibrustdoc%2Fclean%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/72b0a572448a0bea78bb560a2ec890463cb4532b/src%2Flibrustdoc%2Fclean%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Finline.rs?ref=72b0a572448a0bea78bb560a2ec890463cb4532b", "patch": "@@ -255,7 +255,7 @@ fn build_struct(cx: &mut DocContext<'_>, did: DefId) -> clean::Struct {\n     clean::Struct {\n         struct_type: variant.ctor_kind,\n         generics: (cx.tcx.generics_of(did), predicates).clean(cx),\n-        fields: variant.fields.clean(cx),\n+        fields: variant.fields.iter().map(|x| x.clean(cx)).collect(),\n         fields_stripped: false,\n     }\n }\n@@ -264,11 +264,9 @@ fn build_union(cx: &mut DocContext<'_>, did: DefId) -> clean::Union {\n     let predicates = cx.tcx.explicit_predicates_of(did);\n     let variant = cx.tcx.adt_def(did).non_enum_variant();\n \n-    clean::Union {\n-        generics: (cx.tcx.generics_of(did), predicates).clean(cx),\n-        fields: variant.fields.clean(cx),\n-        fields_stripped: false,\n-    }\n+    let generics = (cx.tcx.generics_of(did), predicates).clean(cx);\n+    let fields = variant.fields.iter().map(|x| x.clean(cx)).collect();\n+    clean::Union { generics, fields, fields_stripped: false }\n }\n \n fn build_type_alias(cx: &mut DocContext<'_>, did: DefId) -> clean::Typedef {"}, {"sha": "8f2609efc55d26e44c67d304841b52cfcff8b433", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 41, "deletions": 41, "changes": 82, "blob_url": "https://github.com/rust-lang/rust/blob/72b0a572448a0bea78bb560a2ec890463cb4532b/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/72b0a572448a0bea78bb560a2ec890463cb4532b/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=72b0a572448a0bea78bb560a2ec890463cb4532b", "patch": "@@ -55,12 +55,6 @@ crate trait Clean<T> {\n     fn clean(&self, cx: &mut DocContext<'_>) -> T;\n }\n \n-impl<T: Clean<U>, U> Clean<Vec<U>> for [T] {\n-    fn clean(&self, cx: &mut DocContext<'_>) -> Vec<U> {\n-        self.iter().map(|x| x.clean(cx)).collect()\n-    }\n-}\n-\n impl<T: Clean<U>, U> Clean<U> for &T {\n     fn clean(&self, cx: &mut DocContext<'_>) -> U {\n         (**self).clean(cx)\n@@ -274,14 +268,14 @@ impl Clean<WherePredicate> for hir::WherePredicate<'_> {\n                     .collect();\n                 WherePredicate::BoundPredicate {\n                     ty: wbp.bounded_ty.clean(cx),\n-                    bounds: wbp.bounds.clean(cx),\n+                    bounds: wbp.bounds.iter().map(|x| x.clean(cx)).collect(),\n                     bound_params,\n                 }\n             }\n \n             hir::WherePredicate::RegionPredicate(ref wrp) => WherePredicate::RegionPredicate {\n                 lifetime: wrp.lifetime.clean(cx),\n-                bounds: wrp.bounds.clean(cx),\n+                bounds: wrp.bounds.iter().map(|x| x.clean(cx)).collect(),\n             },\n \n             hir::WherePredicate::EqPredicate(ref wrp) => {\n@@ -446,7 +440,7 @@ impl Clean<GenericParamDef> for hir::GenericParam<'_> {\n                 self.name.ident().name,\n                 GenericParamDefKind::Type {\n                     did: cx.tcx.hir().local_def_id(self.hir_id).to_def_id(),\n-                    bounds: self.bounds.clean(cx),\n+                    bounds: self.bounds.iter().map(|x| x.clean(cx)).collect(),\n                     default: default.map(|t| t.clean(cx)).map(Box::new),\n                     synthetic,\n                 },\n@@ -517,8 +511,10 @@ impl Clean<Generics> for hir::Generics<'_> {\n         }\n         params.extend(impl_trait_params);\n \n-        let mut generics =\n-            Generics { params, where_predicates: self.where_clause.predicates.clean(cx) };\n+        let mut generics = Generics {\n+            params,\n+            where_predicates: self.where_clause.predicates.iter().map(|x| x.clean(cx)).collect(),\n+        };\n \n         // Some duplicates are generated for ?Sized bounds between type params and where\n         // predicates. The point in here is to move the bounds definitions from type params\n@@ -887,7 +883,7 @@ impl Clean<PolyTrait> for hir::PolyTraitRef<'_> {\n     fn clean(&self, cx: &mut DocContext<'_>) -> PolyTrait {\n         PolyTrait {\n             trait_: self.trait_ref.clean(cx),\n-            generic_params: self.bound_generic_params.clean(cx),\n+            generic_params: self.bound_generic_params.iter().map(|x| x.clean(cx)).collect(),\n         }\n     }\n }\n@@ -922,7 +918,9 @@ impl Clean<Item> for hir::TraitItem<'_> {\n                     TyMethodItem(t)\n                 }\n                 hir::TraitItemKind::Type(bounds, ref default) => {\n-                    AssocTypeItem(bounds.clean(cx), default.map(|t| t.clean(cx)))\n+                    let bounds = bounds.iter().map(|x| x.clean(cx)).collect();\n+                    let default = default.map(|t| t.clean(cx));\n+                    AssocTypeItem(bounds, default)\n                 }\n             };\n             let what_rustc_thinks =\n@@ -1256,7 +1254,7 @@ fn clean_qpath(hir_ty: &hir::Ty<'_>, cx: &mut DocContext<'_>) -> Type {\n             let trait_def = cx.tcx.associated_item(p.res.def_id()).container.id();\n             let trait_ = self::Path {\n                 res: Res::Def(DefKind::Trait, trait_def),\n-                segments: trait_segments.clean(cx),\n+                segments: trait_segments.iter().map(|x| x.clean(cx)).collect(),\n             };\n             register_res(cx, trait_.res);\n             Type::QPath {\n@@ -1322,11 +1320,11 @@ impl Clean<Type> for hir::Ty<'_> {\n                 let length = print_const(cx, ct.eval(cx.tcx, param_env));\n                 Array(box ty.clean(cx), length)\n             }\n-            TyKind::Tup(tys) => Tuple(tys.clean(cx)),\n+            TyKind::Tup(tys) => Tuple(tys.iter().map(|x| x.clean(cx)).collect()),\n             TyKind::OpaqueDef(item_id, _) => {\n                 let item = cx.tcx.hir().item(item_id);\n                 if let hir::ItemKind::OpaqueTy(ref ty) = item.kind {\n-                    ImplTrait(ty.bounds.clean(cx))\n+                    ImplTrait(ty.bounds.iter().map(|x| x.clean(cx)).collect())\n                 } else {\n                     unreachable!()\n                 }\n@@ -1466,7 +1464,7 @@ impl<'tcx> Clean<Type> for Ty<'tcx> {\n \n                 DynTrait(bounds, lifetime)\n             }\n-            ty::Tuple(t) => Tuple(t.iter().map(|t| t.expect_ty()).collect::<Vec<_>>().clean(cx)),\n+            ty::Tuple(t) => Tuple(t.iter().map(|t| t.expect_ty().clean(cx)).collect()),\n \n             ty::Projection(ref data) => data.clean(cx),\n \n@@ -1699,7 +1697,7 @@ impl Clean<Variant> for hir::VariantData<'_> {\n \n impl Clean<Path> for hir::Path<'_> {\n     fn clean(&self, cx: &mut DocContext<'_>) -> Path {\n-        Path { res: self.res, segments: self.segments.clean(cx) }\n+        Path { res: self.res, segments: self.segments.iter().map(|x| x.clean(cx)).collect() }\n     }\n }\n \n@@ -1709,24 +1707,24 @@ impl Clean<GenericArgs> for hir::GenericArgs<'_> {\n             let output = self.bindings[0].ty().clean(cx);\n             let output =\n                 if output != Type::Tuple(Vec::new()) { Some(Box::new(output)) } else { None };\n-            GenericArgs::Parenthesized { inputs: self.inputs().clean(cx), output }\n+            let inputs = self.inputs().iter().map(|x| x.clean(cx)).collect();\n+            GenericArgs::Parenthesized { inputs, output }\n         } else {\n-            GenericArgs::AngleBracketed {\n-                args: self\n-                    .args\n-                    .iter()\n-                    .map(|arg| match arg {\n-                        hir::GenericArg::Lifetime(lt) if !lt.is_elided() => {\n-                            GenericArg::Lifetime(lt.clean(cx))\n-                        }\n-                        hir::GenericArg::Lifetime(_) => GenericArg::Lifetime(Lifetime::elided()),\n-                        hir::GenericArg::Type(ty) => GenericArg::Type(ty.clean(cx)),\n-                        hir::GenericArg::Const(ct) => GenericArg::Const(Box::new(ct.clean(cx))),\n-                        hir::GenericArg::Infer(_inf) => GenericArg::Infer,\n-                    })\n-                    .collect(),\n-                bindings: self.bindings.clean(cx),\n-            }\n+            let args = self\n+                .args\n+                .iter()\n+                .map(|arg| match arg {\n+                    hir::GenericArg::Lifetime(lt) if !lt.is_elided() => {\n+                        GenericArg::Lifetime(lt.clean(cx))\n+                    }\n+                    hir::GenericArg::Lifetime(_) => GenericArg::Lifetime(Lifetime::elided()),\n+                    hir::GenericArg::Type(ty) => GenericArg::Type(ty.clean(cx)),\n+                    hir::GenericArg::Const(ct) => GenericArg::Const(Box::new(ct.clean(cx))),\n+                    hir::GenericArg::Infer(_inf) => GenericArg::Infer,\n+                })\n+                .collect();\n+            let bindings = self.bindings.iter().map(|x| x.clean(cx)).collect();\n+            GenericArgs::AngleBracketed { args, bindings }\n         }\n     }\n }\n@@ -1740,7 +1738,9 @@ impl Clean<PathSegment> for hir::PathSegment<'_> {\n impl Clean<BareFunctionDecl> for hir::BareFnTy<'_> {\n     fn clean(&self, cx: &mut DocContext<'_>) -> BareFunctionDecl {\n         let (generic_params, decl) = enter_impl_trait(cx, |cx| {\n-            (self.generic_params.clean(cx), (&*self.decl, self.param_names).clean(cx))\n+            let generic_params = self.generic_params.iter().map(|x| x.clean(cx)).collect();\n+            let decl = (self.decl, self.param_names).clean(cx);\n+            (generic_params, decl)\n         });\n         BareFunctionDecl { unsafety: self.unsafety, abi: self.abi, decl, generic_params }\n     }\n@@ -1763,7 +1763,7 @@ impl Clean<Vec<Item>> for (&hir::Item<'_>, Option<Symbol>) {\n                     kind: ConstantKind::Local { body: body_id, def_id },\n                 }),\n                 ItemKind::OpaqueTy(ref ty) => OpaqueTyItem(OpaqueTy {\n-                    bounds: ty.bounds.clean(cx),\n+                    bounds: ty.bounds.iter().map(|x| x.clean(cx)).collect(),\n                     generics: ty.generics.clean(cx),\n                 }),\n                 ItemKind::TyAlias(hir_ty, ref generics) => {\n@@ -1785,17 +1785,17 @@ impl Clean<Vec<Item>> for (&hir::Item<'_>, Option<Symbol>) {\n                 }),\n                 ItemKind::TraitAlias(ref generics, bounds) => TraitAliasItem(TraitAlias {\n                     generics: generics.clean(cx),\n-                    bounds: bounds.clean(cx),\n+                    bounds: bounds.iter().map(|x| x.clean(cx)).collect(),\n                 }),\n                 ItemKind::Union(ref variant_data, ref generics) => UnionItem(Union {\n                     generics: generics.clean(cx),\n-                    fields: variant_data.fields().clean(cx),\n+                    fields: variant_data.fields().iter().map(|x| x.clean(cx)).collect(),\n                     fields_stripped: false,\n                 }),\n                 ItemKind::Struct(ref variant_data, ref generics) => StructItem(Struct {\n                     struct_type: CtorKind::from_hir(variant_data),\n                     generics: generics.clean(cx),\n-                    fields: variant_data.fields().clean(cx),\n+                    fields: variant_data.fields().iter().map(|x| x.clean(cx)).collect(),\n                     fields_stripped: false,\n                 }),\n                 ItemKind::Impl(ref impl_) => return clean_impl(impl_, item.hir_id(), cx),\n@@ -1815,7 +1815,7 @@ impl Clean<Vec<Item>> for (&hir::Item<'_>, Option<Symbol>) {\n                         unsafety,\n                         items,\n                         generics: generics.clean(cx),\n-                        bounds: bounds.clean(cx),\n+                        bounds: bounds.iter().map(|x| x.clean(cx)).collect(),\n                         is_auto: is_auto.clean(cx),\n                     })\n                 }"}]}