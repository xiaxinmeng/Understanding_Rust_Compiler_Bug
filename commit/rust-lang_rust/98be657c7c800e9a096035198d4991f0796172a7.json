{"sha": "98be657c7c800e9a096035198d4991f0796172a7", "node_id": "C_kwDOAAsO6NoAKDk4YmU2NTdjN2M4MDBlOWEwOTYwMzUxOThkNDk5MWYwNzk2MTcyYTc", "commit": {"author": {"name": "Matthias Kr\u00fcger", "email": "matthias.krueger@famsik.de", "date": "2022-11-15T00:40:42Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2022-11-15T00:40:42Z"}, "message": "Rollup merge of #103842 - andrewpollack:add-fuchsia-test-script, r=tmandry\n\nAdding Fuchsia compiler testing script, docs\n\nAdding Fuchsia compiler testing script and related docs updates\n\nr? `@tmandry`\n\ncc. `@djkoloski`", "tree": {"sha": "2b07385e34cf335b04bf1e36b8659b1715f8f202", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2b07385e34cf335b04bf1e36b8659b1715f8f202"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/98be657c7c800e9a096035198d4991f0796172a7", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJjcuAKCRBK7hj4Ov3rIwAAGD0IAJHRA3n+OmwLBRqd8GDnsBKy\nHrVwHGOPc0ahv70YwgYdK6MZ+dTnlBjz8x37xUtL7hpjOWMg7BoCetbY64kiCTrP\nELdCe/Dbu5I8LjSD2nDsYGiuQO8InkbXouUKdX8Cn9KuVgdgHBDcgwaWEIxhx/2B\naBk3IajTVxPRpXnbWjJx8f67jAsf+ek6QujeQUU9Y7hhvDwKf7rEcx2pEV7907Ry\nbPKP83PF9UKSMWqYPwf6T3BzCZP/Kk6GFYXhumuP8kdNALz4wyqMes+4hRwaSjNj\nQC/Glr1McgRdgPuomsw0nS3d75BnbdgTFmk7stp5q9yskTqOimIdQ2Ba1YGFi64=\n=viCB\n-----END PGP SIGNATURE-----\n", "payload": "tree 2b07385e34cf335b04bf1e36b8659b1715f8f202\nparent 96ddd32c4bfb1d78f0cd03eb068b1710a8cebeef\nparent e1636b83e323415539d6b487dc1571728d13eb81\nauthor Matthias Kr\u00fcger <matthias.krueger@famsik.de> 1668472842 +0100\ncommitter GitHub <noreply@github.com> 1668472842 +0100\n\nRollup merge of #103842 - andrewpollack:add-fuchsia-test-script, r=tmandry\n\nAdding Fuchsia compiler testing script, docs\n\nAdding Fuchsia compiler testing script and related docs updates\n\nr? `@tmandry`\n\ncc. `@djkoloski`\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/98be657c7c800e9a096035198d4991f0796172a7", "html_url": "https://github.com/rust-lang/rust/commit/98be657c7c800e9a096035198d4991f0796172a7", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/98be657c7c800e9a096035198d4991f0796172a7/comments", "author": {"login": "matthiaskrgr", "id": 476013, "node_id": "MDQ6VXNlcjQ3NjAxMw==", "avatar_url": "https://avatars.githubusercontent.com/u/476013?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matthiaskrgr", "html_url": "https://github.com/matthiaskrgr", "followers_url": "https://api.github.com/users/matthiaskrgr/followers", "following_url": "https://api.github.com/users/matthiaskrgr/following{/other_user}", "gists_url": "https://api.github.com/users/matthiaskrgr/gists{/gist_id}", "starred_url": "https://api.github.com/users/matthiaskrgr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matthiaskrgr/subscriptions", "organizations_url": "https://api.github.com/users/matthiaskrgr/orgs", "repos_url": "https://api.github.com/users/matthiaskrgr/repos", "events_url": "https://api.github.com/users/matthiaskrgr/events{/privacy}", "received_events_url": "https://api.github.com/users/matthiaskrgr/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "96ddd32c4bfb1d78f0cd03eb068b1710a8cebeef", "url": "https://api.github.com/repos/rust-lang/rust/commits/96ddd32c4bfb1d78f0cd03eb068b1710a8cebeef", "html_url": "https://github.com/rust-lang/rust/commit/96ddd32c4bfb1d78f0cd03eb068b1710a8cebeef"}, {"sha": "e1636b83e323415539d6b487dc1571728d13eb81", "url": "https://api.github.com/repos/rust-lang/rust/commits/e1636b83e323415539d6b487dc1571728d13eb81", "html_url": "https://github.com/rust-lang/rust/commit/e1636b83e323415539d6b487dc1571728d13eb81"}], "stats": {"total": 1097, "additions": 1095, "deletions": 2}, "files": [{"sha": "a2708d16947f0c92ed302106fba70382792eee2f", "filename": "src/ci/docker/scripts/fuchsia-test-runner.py", "status": "added", "additions": 1041, "deletions": 0, "changes": 1041, "blob_url": "https://github.com/rust-lang/rust/blob/98be657c7c800e9a096035198d4991f0796172a7/src%2Fci%2Fdocker%2Fscripts%2Ffuchsia-test-runner.py", "raw_url": "https://github.com/rust-lang/rust/raw/98be657c7c800e9a096035198d4991f0796172a7/src%2Fci%2Fdocker%2Fscripts%2Ffuchsia-test-runner.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fscripts%2Ffuchsia-test-runner.py?ref=98be657c7c800e9a096035198d4991f0796172a7", "patch": "@@ -0,0 +1,1041 @@\n+#!/usr/bin/env python3\n+\n+\"\"\"\n+The Rust toolchain test runner for Fuchsia.\n+\n+For instructions on running the compiler test suite, see\n+https://doc.rust-lang.org/stable/rustc/platform-support/fuchsia.html#aarch64-fuchsia-and-x86_64-fuchsia\n+\"\"\"\n+\n+import argparse\n+from dataclasses import dataclass\n+import glob\n+import hashlib\n+import json\n+import os\n+import platform\n+import re\n+import shutil\n+import signal\n+import subprocess\n+import sys\n+from typing import ClassVar, List\n+\n+\n+@dataclass\n+class TestEnvironment:\n+    rust_dir: str\n+    sdk_dir: str\n+    target_arch: str\n+    package_server_pid: int = None\n+    emu_addr: str = None\n+    libstd_name: str = None\n+    libtest_name: str = None\n+    verbose: bool = False\n+\n+    @staticmethod\n+    def tmp_dir():\n+        tmp_dir = os.environ.get(\"TEST_TOOLCHAIN_TMP_DIR\")\n+        if tmp_dir is not None:\n+            return os.path.abspath(tmp_dir)\n+        return os.path.join(os.path.dirname(__file__), \"tmp~\")\n+\n+    @classmethod\n+    def env_file_path(cls):\n+        return os.path.join(cls.tmp_dir(), \"test_env.json\")\n+\n+    @classmethod\n+    def from_args(cls, args):\n+        return cls(\n+            os.path.abspath(args.rust),\n+            os.path.abspath(args.sdk),\n+            args.target_arch,\n+            verbose=args.verbose,\n+        )\n+\n+    @classmethod\n+    def read_from_file(cls):\n+        with open(cls.env_file_path(), encoding=\"utf-8\") as f:\n+            test_env = json.loads(f.read())\n+            return cls(\n+                test_env[\"rust_dir\"],\n+                test_env[\"sdk_dir\"],\n+                test_env[\"target_arch\"],\n+                libstd_name=test_env[\"libstd_name\"],\n+                libtest_name=test_env[\"libtest_name\"],\n+                emu_addr=test_env[\"emu_addr\"],\n+                package_server_pid=test_env[\"package_server_pid\"],\n+                verbose=test_env[\"verbose\"],\n+            )\n+\n+    def image_name(self):\n+        if self.target_arch == \"x64\":\n+            return \"qemu-x64\"\n+        if self.target_arch == \"arm64\":\n+            return \"qemu-arm64\"\n+        raise Exception(f\"Unrecognized target architecture {self.target_arch}\")\n+\n+    def write_to_file(self):\n+        with open(self.env_file_path(), \"w\", encoding=\"utf-8\") as f:\n+            f.write(json.dumps(self.__dict__))\n+\n+    def ssh_dir(self):\n+        return os.path.join(self.tmp_dir(), \"ssh\")\n+\n+    def ssh_keyfile_path(self):\n+        return os.path.join(self.ssh_dir(), \"fuchsia_ed25519\")\n+\n+    def ssh_authfile_path(self):\n+        return os.path.join(self.ssh_dir(), \"fuchsia_authorized_keys\")\n+\n+    def vdl_output_path(self):\n+        return os.path.join(self.tmp_dir(), \"vdl_output\")\n+\n+    def package_server_log_path(self):\n+        return os.path.join(self.tmp_dir(), \"package_server_log\")\n+\n+    def emulator_log_path(self):\n+        return os.path.join(self.tmp_dir(), \"emulator_log\")\n+\n+    def packages_dir(self):\n+        return os.path.join(self.tmp_dir(), \"packages\")\n+\n+    def output_dir(self):\n+        return os.path.join(self.tmp_dir(), \"output\")\n+\n+    TEST_REPO_NAME: ClassVar[str] = \"rust-testing\"\n+\n+    def repo_dir(self):\n+        return os.path.join(self.tmp_dir(), self.TEST_REPO_NAME)\n+\n+    def rustlib_dir(self):\n+        if self.target_arch == \"x64\":\n+            return \"x86_64-fuchsia\"\n+        if self.target_arch == \"arm64\":\n+            return \"aarch64-fuchsia\"\n+        raise Exception(f\"Unrecognized target architecture {self.target_arch}\")\n+\n+    def libs_dir(self):\n+        return os.path.join(\n+            self.rust_dir,\n+            \"lib\",\n+        )\n+\n+    def rustlibs_dir(self):\n+        return os.path.join(\n+            self.libs_dir(),\n+            \"rustlib\",\n+            self.rustlib_dir(),\n+            \"lib\",\n+        )\n+\n+    def sdk_arch(self):\n+        machine = platform.machine()\n+        if machine == \"x86_64\":\n+            return \"x64\"\n+        if machine == \"arm\":\n+            return \"a64\"\n+        raise Exception(f\"Unrecognized host architecture {machine}\")\n+\n+    def tool_path(self, tool):\n+        return os.path.join(self.sdk_dir, \"tools\", self.sdk_arch(), tool)\n+\n+    def host_arch_triple(self):\n+        machine = platform.machine()\n+        if machine == \"x86_64\":\n+            return \"x86_64-unknown-linux-gnu\"\n+        if machine == \"arm\":\n+            return \"aarch64-unknown-linux-gnu\"\n+        raise Exception(f\"Unrecognized host architecture {machine}\")\n+\n+    def zxdb_script_path(self):\n+        return os.path.join(self.tmp_dir(), \"zxdb_script\")\n+\n+    def log_info(self, msg):\n+        print(msg)\n+\n+    def log_debug(self, msg):\n+        if self.verbose:\n+            print(msg)\n+\n+    def subprocess_output(self):\n+        if self.verbose:\n+            return sys.stdout\n+        return subprocess.DEVNULL\n+\n+    def ffx_daemon_log_path(self):\n+        return os.path.join(self.tmp_dir(), \"ffx_daemon_log\")\n+\n+    def ffx_isolate_dir(self):\n+        return os.path.join(self.tmp_dir(), \"ffx_isolate\")\n+\n+    def ffx_home_dir(self):\n+        return os.path.join(self.ffx_isolate_dir(), \"user-home\")\n+\n+    def ffx_tmp_dir(self):\n+        return os.path.join(self.ffx_isolate_dir(), \"tmp\")\n+\n+    def ffx_log_dir(self):\n+        return os.path.join(self.ffx_isolate_dir(), \"log\")\n+\n+    def ffx_user_config_dir(self):\n+        return os.path.join(self.ffx_xdg_config_home(), \"Fuchsia\", \"ffx\", \"config\")\n+\n+    def ffx_user_config_path(self):\n+        return os.path.join(self.ffx_user_config_dir(), \"config.json\")\n+\n+    def ffx_xdg_config_home(self):\n+        if platform.system() == \"Darwin\":\n+            return os.path.join(self.ffx_home_dir(), \"Library\", \"Preferences\")\n+        return os.path.join(self.ffx_home_dir(), \".local\", \"share\")\n+\n+    def ffx_ascendd_path(self):\n+        return os.path.join(self.ffx_tmp_dir(), \"ascendd\")\n+\n+    def start_ffx_isolation(self):\n+        # Most of this is translated directly from ffx's isolate library\n+        os.mkdir(self.ffx_isolate_dir())\n+        os.mkdir(self.ffx_home_dir())\n+        os.mkdir(self.ffx_tmp_dir())\n+        os.mkdir(self.ffx_log_dir())\n+\n+        fuchsia_dir = os.path.join(self.ffx_home_dir(), \".fuchsia\")\n+        os.mkdir(fuchsia_dir)\n+\n+        fuchsia_debug_dir = os.path.join(fuchsia_dir, \"debug\")\n+        os.mkdir(fuchsia_debug_dir)\n+\n+        metrics_dir = os.path.join(fuchsia_dir, \"metrics\")\n+        os.mkdir(metrics_dir)\n+\n+        analytics_path = os.path.join(metrics_dir, \"analytics-status\")\n+        with open(analytics_path, \"w\", encoding=\"utf-8\") as analytics_file:\n+            print(\"0\", file=analytics_file)\n+\n+        ffx_path = os.path.join(metrics_dir, \"ffx\")\n+        with open(ffx_path, \"w\", encoding=\"utf-8\") as ffx_file:\n+            print(\"1\", file=ffx_file)\n+\n+        os.makedirs(self.ffx_user_config_dir())\n+\n+        with open(\n+            self.ffx_user_config_path(), \"w\", encoding=\"utf-8\"\n+        ) as config_json_file:\n+            user_config_for_test = {\n+                \"log\": {\n+                    \"enabled\": True,\n+                    \"dir\": self.ffx_log_dir(),\n+                },\n+                \"overnet\": {\n+                    \"socket\": self.ffx_ascendd_path(),\n+                },\n+                \"ssh\": {\n+                    \"pub\": self.ssh_authfile_path(),\n+                    \"priv\": self.ssh_keyfile_path(),\n+                },\n+                \"test\": {\n+                    \"is_isolated\": True,\n+                    \"experimental_structured_output\": True,\n+                },\n+            }\n+            print(json.dumps(user_config_for_test), file=config_json_file)\n+\n+        ffx_env_path = os.path.join(self.ffx_user_config_dir(), \".ffx_env\")\n+        with open(ffx_env_path, \"w\", encoding=\"utf-8\") as ffx_env_file:\n+            ffx_env_config_for_test = {\n+                \"user\": self.ffx_user_config_path(),\n+                \"build\": None,\n+                \"global\": None,\n+            }\n+            print(json.dumps(ffx_env_config_for_test), file=ffx_env_file)\n+\n+        # Start ffx daemon\n+        # We want this to be a long-running process that persists after the script finishes\n+        # pylint: disable=consider-using-with\n+        with open(\n+            self.ffx_daemon_log_path(), \"w\", encoding=\"utf-8\"\n+        ) as ffx_daemon_log_file:\n+            subprocess.Popen(\n+                [\n+                    self.tool_path(\"ffx\"),\n+                    \"--config\",\n+                    self.ffx_user_config_path(),\n+                    \"daemon\",\n+                    \"start\",\n+                ],\n+                env=self.ffx_cmd_env(),\n+                stdout=ffx_daemon_log_file,\n+                stderr=ffx_daemon_log_file,\n+            )\n+\n+    def ffx_cmd_env(self):\n+        result = {\n+            \"HOME\": self.ffx_home_dir(),\n+            \"XDG_CONFIG_HOME\": self.ffx_xdg_config_home(),\n+            \"ASCENDD\": self.ffx_ascendd_path(),\n+            \"FUCHSIA_SSH_KEY\": self.ssh_keyfile_path(),\n+            # We want to use our own specified temp directory\n+            \"TMP\": self.tmp_dir(),\n+            \"TEMP\": self.tmp_dir(),\n+            \"TMPDIR\": self.tmp_dir(),\n+            \"TEMPDIR\": self.tmp_dir(),\n+        }\n+\n+        return result\n+\n+    def stop_ffx_isolation(self):\n+        subprocess.check_call(\n+            [\n+                self.tool_path(\"ffx\"),\n+                \"--config\",\n+                self.ffx_user_config_path(),\n+                \"daemon\",\n+                \"stop\",\n+            ],\n+            env=self.ffx_cmd_env(),\n+            stdout=self.subprocess_output(),\n+            stderr=self.subprocess_output(),\n+        )\n+\n+    def start(self):\n+        \"\"\"Sets up the testing environment and prepares to run tests.\n+\n+        Args:\n+            args: The command-line arguments to this command.\n+\n+        During setup, this function will:\n+        - Locate necessary shared libraries\n+        - Create a new temp directory (this is where all temporary files are stored)\n+        - Start an emulator\n+        - Start an update server\n+        - Create a new package repo and register it with the emulator\n+        - Write test environment settings to a temporary file\n+        \"\"\"\n+\n+        # Initialize temp directory\n+        if not os.path.exists(self.tmp_dir()):\n+            os.mkdir(self.tmp_dir())\n+        elif len(os.listdir(self.tmp_dir())) != 0:\n+            raise Exception(f\"Temp directory is not clean (in {self.tmp_dir()})\")\n+\n+        os.mkdir(self.ssh_dir())\n+        os.mkdir(self.output_dir())\n+\n+        # Find libstd and libtest\n+        libstd_paths = glob.glob(os.path.join(self.rustlibs_dir(), \"libstd-*.so\"))\n+        libtest_paths = glob.glob(os.path.join(self.rustlibs_dir(), \"libtest-*.so\"))\n+\n+        if not libstd_paths:\n+            raise Exception(f\"Failed to locate libstd (in {self.rustlibs_dir()})\")\n+\n+        if not libtest_paths:\n+            raise Exception(f\"Failed to locate libtest (in {self.rustlibs_dir()})\")\n+\n+        self.libstd_name = os.path.basename(libstd_paths[0])\n+        self.libtest_name = os.path.basename(libtest_paths[0])\n+\n+        # Generate SSH keys for the emulator to use\n+        self.log_info(\"Generating SSH keys...\")\n+        subprocess.check_call(\n+            [\n+                \"ssh-keygen\",\n+                \"-N\",\n+                \"\",\n+                \"-t\",\n+                \"ed25519\",\n+                \"-f\",\n+                self.ssh_keyfile_path(),\n+                \"-C\",\n+                \"Generated by test_toolchain.py\",\n+            ],\n+            stdout=self.subprocess_output(),\n+            stderr=self.subprocess_output(),\n+        )\n+        authfile_contents = subprocess.check_output(\n+            [\n+                \"ssh-keygen\",\n+                \"-y\",\n+                \"-f\",\n+                self.ssh_keyfile_path(),\n+            ],\n+            stderr=self.subprocess_output(),\n+        )\n+        with open(self.ssh_authfile_path(), \"wb\") as authfile:\n+            authfile.write(authfile_contents)\n+\n+        # Start ffx isolation\n+        self.log_info(\"Starting ffx isolation...\")\n+        self.start_ffx_isolation()\n+\n+        # Start emulator (this will generate the vdl output)\n+        self.log_info(\"Starting emulator...\")\n+        subprocess.check_call(\n+            [\n+                self.tool_path(\"fvdl\"),\n+                \"--sdk\",\n+                \"start\",\n+                \"--tuntap\",\n+                \"--headless\",\n+                \"--nointeractive\",\n+                \"--ssh\",\n+                self.ssh_dir(),\n+                \"--vdl-output\",\n+                self.vdl_output_path(),\n+                \"--emulator-log\",\n+                self.emulator_log_path(),\n+                \"--image-name\",\n+                self.image_name(),\n+            ],\n+            stdout=self.subprocess_output(),\n+            stderr=self.subprocess_output(),\n+        )\n+\n+        # Parse vdl output for relevant information\n+        with open(self.vdl_output_path(), encoding=\"utf-8\") as f:\n+            vdl_content = f.read()\n+            matches = re.search(\n+                r'network_address:\\s+\"\\[([0-9a-f]{1,4}:(:[0-9a-f]{1,4}){4}%qemu)\\]\"',\n+                vdl_content,\n+            )\n+            self.emu_addr = matches.group(1)\n+\n+        # Create new package repo\n+        self.log_info(\"Creating package repo...\")\n+        subprocess.check_call(\n+            [\n+                self.tool_path(\"pm\"),\n+                \"newrepo\",\n+                \"-repo\",\n+                self.repo_dir(),\n+            ],\n+            stdout=self.subprocess_output(),\n+            stderr=self.subprocess_output(),\n+        )\n+\n+        # Start package server\n+        self.log_info(\"Starting package server...\")\n+        with open(\n+            self.package_server_log_path(), \"w\", encoding=\"utf-8\"\n+        ) as package_server_log:\n+            # We want this to be a long-running process that persists after the script finishes\n+            # pylint: disable=consider-using-with\n+            self.package_server_pid = subprocess.Popen(\n+                [\n+                    self.tool_path(\"pm\"),\n+                    \"serve\",\n+                    \"-vt\",\n+                    \"-repo\",\n+                    self.repo_dir(),\n+                    \"-l\",\n+                    \":8084\",\n+                ],\n+                stdout=package_server_log,\n+                stderr=package_server_log,\n+            ).pid\n+\n+        # Register package server with emulator\n+        self.log_info(\"Registering package server...\")\n+        ssh_client = subprocess.check_output(\n+            [\n+                \"ssh\",\n+                \"-i\",\n+                self.ssh_keyfile_path(),\n+                \"-o\",\n+                \"StrictHostKeyChecking=accept-new\",\n+                self.emu_addr,\n+                \"-f\",\n+                \"echo $SSH_CLIENT\",\n+            ],\n+            text=True,\n+        )\n+        repo_addr = ssh_client.split()[0].replace(\"%\", \"%25\")\n+        repo_url = f\"http://[{repo_addr}]:8084/config.json\"\n+        subprocess.check_call(\n+            [\n+                \"ssh\",\n+                \"-i\",\n+                self.ssh_keyfile_path(),\n+                \"-o\",\n+                \"StrictHostKeyChecking=accept-new\",\n+                self.emu_addr,\n+                \"-f\",\n+                f\"pkgctl repo add url -f 1 -n {self.TEST_REPO_NAME} {repo_url}\",\n+            ],\n+            stdout=self.subprocess_output(),\n+            stderr=self.subprocess_output(),\n+        )\n+\n+        # Write to file\n+        self.write_to_file()\n+\n+        self.log_info(\"Success! Your environment is ready to run tests.\")\n+\n+    # FIXME: shardify this\n+    # `facet` statement required for TCP testing via\n+    # protocol `fuchsia.posix.socket.Provider`. See\n+    # https://fuchsia.dev/fuchsia-src/development/testing/components/test_runner_framework?hl=en#legacy_non-hermetic_tests\n+    CML_TEMPLATE: ClassVar[\n+        str\n+    ] = \"\"\"\n+    {{\n+        program: {{\n+            runner: \"elf_test_runner\",\n+            binary: \"bin/{exe_name}\",\n+            forward_stderr_to: \"log\",\n+            forward_stdout_to: \"log\",\n+            environ: [{env_vars}\n+            ]\n+        }},\n+        capabilities: [\n+            {{ protocol: \"fuchsia.test.Suite\" }},\n+        ],\n+        expose: [\n+            {{\n+                protocol: \"fuchsia.test.Suite\",\n+                from: \"self\",\n+            }},\n+        ],\n+        use: [\n+            {{ storage: \"data\", path: \"/data\" }},\n+            {{ protocol: [ \"fuchsia.process.Launcher\" ] }},\n+            {{ protocol: [ \"fuchsia.posix.socket.Provider\" ] }}\n+        ],\n+        facets: {{\n+            \"fuchsia.test\": {{ type: \"system\" }},\n+        }},\n+    }}\n+    \"\"\"\n+\n+    MANIFEST_TEMPLATE = \"\"\"\n+    meta/package={package_dir}/meta/package\n+    meta/{package_name}.cm={package_dir}/meta/{package_name}.cm\n+    bin/{exe_name}={bin_path}\n+    lib/{libstd_name}={rust_dir}/lib/rustlib/{rustlib_dir}/lib/{libstd_name}\n+    lib/{libtest_name}={rust_dir}/lib/rustlib/{rustlib_dir}/lib/{libtest_name}\n+    lib/ld.so.1={sdk_dir}/arch/{target_arch}/sysroot/lib/libc.so\n+    lib/libzircon.so={sdk_dir}/arch/{target_arch}/sysroot/lib/libzircon.so\n+    lib/libfdio.so={sdk_dir}/arch/{target_arch}/lib/libfdio.so\n+    \"\"\"\n+\n+    TEST_ENV_VARS: ClassVar[List[str]] = [\n+        \"TEST_EXEC_ENV\",\n+        \"RUST_MIN_STACK\",\n+        \"RUST_BACKTRACE\",\n+        \"RUST_NEWRT\",\n+        \"RUST_LOG\",\n+        \"RUST_TEST_THREADS\",\n+    ]\n+\n+    def run(self, args):\n+        \"\"\"Runs the requested test in the testing environment.\n+\n+        Args:\n+        args: The command-line arguments to this command.\n+        Returns:\n+        The return code of the test (0 for success, else failure).\n+\n+        To run a test, this function will:\n+        - Create, compile, archive, and publish a test package\n+        - Run the test package on the emulator\n+        - Forward the test's stdout and stderr as this script's stdout and stderr\n+        \"\"\"\n+\n+        bin_path = os.path.abspath(args.bin_path)\n+\n+        # Build a unique, deterministic name for the test using the name of the\n+        # binary and the last 6 hex digits of the hash of the full path\n+        def path_checksum(path):\n+            m = hashlib.sha256()\n+            m.update(path.encode(\"utf-8\"))\n+            return m.hexdigest()[0:6]\n+\n+        base_name = os.path.basename(os.path.dirname(args.bin_path))\n+        exe_name = base_name.lower().replace(\".\", \"_\")\n+        package_name = f\"{exe_name}_{path_checksum(bin_path)}\"\n+\n+        package_dir = os.path.join(self.packages_dir(), package_name)\n+        cml_path = os.path.join(package_dir, \"meta\", f\"{package_name}.cml\")\n+        cm_path = os.path.join(package_dir, \"meta\", f\"{package_name}.cm\")\n+        manifest_path = os.path.join(package_dir, f\"{package_name}.manifest\")\n+        far_path = os.path.join(package_dir, f\"{package_name}-0.far\")\n+\n+        shared_libs = args.shared_libs[: args.n]\n+        arguments = args.shared_libs[args.n :]\n+\n+        test_output_dir = os.path.join(self.output_dir(), package_name)\n+\n+        # Clean and create temporary output directory\n+        if os.path.exists(test_output_dir):\n+            shutil.rmtree(test_output_dir)\n+\n+        os.mkdir(test_output_dir)\n+\n+        # Open log file\n+        log_path = os.path.join(test_output_dir, \"log\")\n+        with open(log_path, \"w\", encoding=\"utf-8\") as log_file:\n+\n+            def log(msg):\n+                print(msg, file=log_file)\n+                log_file.flush()\n+\n+            log(f\"Bin path: {bin_path}\")\n+\n+            log(\"Setting up package...\")\n+\n+            # Set up package\n+            subprocess.check_call(\n+                [\n+                    self.tool_path(\"pm\"),\n+                    \"-o\",\n+                    package_dir,\n+                    \"-n\",\n+                    package_name,\n+                    \"init\",\n+                ],\n+                stdout=log_file,\n+                stderr=log_file,\n+            )\n+\n+            log(\"Writing CML...\")\n+\n+            # Write and compile CML\n+            with open(cml_path, \"w\", encoding=\"utf-8\") as cml:\n+                # Collect environment variables\n+                env_vars = \"\"\n+                for var_name in self.TEST_ENV_VARS:\n+                    var_value = os.getenv(var_name)\n+                    if var_value is not None:\n+                        env_vars += f'\\n            \"{var_name}={var_value}\",'\n+\n+                # Default to no backtrace for test suite\n+                if os.getenv(\"RUST_BACKTRACE\") == None:\n+                    env_vars += f'\\n            \"RUST_BACKTRACE=0\",'\n+\n+                cml.write(\n+                    self.CML_TEMPLATE.format(env_vars=env_vars, exe_name=exe_name)\n+                )\n+\n+            log(\"Compiling CML...\")\n+\n+            subprocess.check_call(\n+                [\n+                    self.tool_path(\"cmc\"),\n+                    \"compile\",\n+                    cml_path,\n+                    \"--includepath\",\n+                    \".\",\n+                    \"--output\",\n+                    cm_path,\n+                ],\n+                stdout=log_file,\n+                stderr=log_file,\n+            )\n+\n+            log(\"Writing manifest...\")\n+\n+            # Write, build, and archive manifest\n+            with open(manifest_path, \"w\", encoding=\"utf-8\") as manifest:\n+                manifest.write(\n+                    self.MANIFEST_TEMPLATE.format(\n+                        bin_path=bin_path,\n+                        exe_name=exe_name,\n+                        package_dir=package_dir,\n+                        package_name=package_name,\n+                        rust_dir=self.rust_dir,\n+                        rustlib_dir=self.rustlib_dir(),\n+                        sdk_dir=self.sdk_dir,\n+                        libstd_name=self.libstd_name,\n+                        libtest_name=self.libtest_name,\n+                        target_arch=self.target_arch,\n+                    )\n+                )\n+                for shared_lib in shared_libs:\n+                    manifest.write(f\"lib/{os.path.basename(shared_lib)}={shared_lib}\\n\")\n+\n+            log(\"Compiling and archiving manifest...\")\n+\n+            subprocess.check_call(\n+                [\n+                    self.tool_path(\"pm\"),\n+                    \"-o\",\n+                    package_dir,\n+                    \"-m\",\n+                    manifest_path,\n+                    \"build\",\n+                ],\n+                stdout=log_file,\n+                stderr=log_file,\n+            )\n+            subprocess.check_call(\n+                [\n+                    self.tool_path(\"pm\"),\n+                    \"-o\",\n+                    package_dir,\n+                    \"-m\",\n+                    manifest_path,\n+                    \"archive\",\n+                ],\n+                stdout=log_file,\n+                stderr=log_file,\n+            )\n+\n+            log(\"Publishing package to repo...\")\n+\n+            # Publish package to repo\n+            subprocess.check_call(\n+                [\n+                    self.tool_path(\"pm\"),\n+                    \"publish\",\n+                    \"-a\",\n+                    \"-repo\",\n+                    self.repo_dir(),\n+                    \"-f\",\n+                    far_path,\n+                ],\n+                stdout=log_file,\n+                stderr=log_file,\n+            )\n+\n+            log(\"Running ffx test...\")\n+\n+            # Run test on emulator\n+            subprocess.run(\n+                [\n+                    self.tool_path(\"ffx\"),\n+                    \"--config\",\n+                    self.ffx_user_config_path(),\n+                    \"test\",\n+                    \"run\",\n+                    f\"fuchsia-pkg://{self.TEST_REPO_NAME}/{package_name}#meta/{package_name}.cm\",\n+                    \"--min-severity-logs\",\n+                    \"TRACE\",\n+                    \"--output-directory\",\n+                    test_output_dir,\n+                    \"--\",\n+                ]\n+                + arguments,\n+                env=self.ffx_cmd_env(),\n+                check=False,\n+                stdout=log_file,\n+                stderr=log_file,\n+            )\n+\n+            log(\"Reporting test suite output...\")\n+\n+            # Read test suite output\n+            run_summary_path = os.path.join(test_output_dir, \"run_summary.json\")\n+            if os.path.exists(run_summary_path):\n+                with open(run_summary_path, encoding=\"utf-8\") as f:\n+                    run_summary = json.loads(f.read())\n+\n+                suite = run_summary[\"data\"][\"suites\"][0]\n+                case = suite[\"cases\"][0]\n+\n+                return_code = 0 if case[\"outcome\"] == \"PASSED\" else 1\n+\n+                artifacts = case[\"artifacts\"]\n+                artifact_dir = case[\"artifact_dir\"]\n+                stdout_path = None\n+                stderr_path = None\n+\n+                for path, artifact in artifacts.items():\n+                    artifact_path = os.path.join(test_output_dir, artifact_dir, path)\n+                    artifact_type = artifact[\"artifact_type\"]\n+\n+                    if artifact_type == \"STDERR\":\n+                        stderr_path = artifact_path\n+                    elif artifact_type == \"STDOUT\":\n+                        stdout_path = artifact_path\n+\n+                if stdout_path is not None and os.path.exists(stdout_path):\n+                    with open(stdout_path, encoding=\"utf-8\") as f:\n+                        print(f.read(), file=sys.stdout, end=\"\")\n+\n+                if stderr_path is not None and os.path.exists(stderr_path):\n+                    with open(stderr_path, encoding=\"utf-8\") as f:\n+                        print(f.read(), file=sys.stderr, end=\"\")\n+            else:\n+                log(\"Failed to open test run summary\")\n+                return_code = 254\n+\n+            log(\"Done!\")\n+\n+        return return_code\n+\n+    def stop(self):\n+        \"\"\"Shuts down and cleans up the testing environment.\n+\n+        Args:\n+        args: The command-line arguments to this command.\n+        Returns:\n+        The return code of the test (0 for success, else failure).\n+\n+        During cleanup, this function will stop the emulator, package server, and\n+        update server, then delete all temporary files. If an error is encountered\n+        while stopping any running processes, the temporary files will not be deleted.\n+        Passing --delete-tmp will force the process to delete the files anyway.\n+        \"\"\"\n+\n+        self.log_debug(\"Reporting logs...\")\n+\n+        # Print test log files\n+        for test_dir in os.listdir(self.output_dir()):\n+            log_path = os.path.join(self.output_dir(), test_dir, \"log\")\n+            self.log_debug(f\"\\n---- Logs for test '{test_dir}' ----\\n\")\n+            if os.path.exists(log_path):\n+                with open(log_path, encoding=\"utf-8\") as log:\n+                    self.log_debug(log.read())\n+            else:\n+                self.log_debug(\"No logs found\")\n+\n+        # Print the emulator log\n+        self.log_debug(\"\\n---- Emulator logs ----\\n\")\n+        if os.path.exists(self.emulator_log_path()):\n+            with open(self.emulator_log_path(), encoding=\"utf-8\") as log:\n+                self.log_debug(log.read())\n+        else:\n+            self.log_debug(\"No emulator logs found\")\n+\n+        # Print the package server log\n+        self.log_debug(\"\\n---- Package server log ----\\n\")\n+        if os.path.exists(self.package_server_log_path()):\n+            with open(self.package_server_log_path(), encoding=\"utf-8\") as log:\n+                self.log_debug(log.read())\n+        else:\n+            self.log_debug(\"No package server log found\")\n+\n+        # Print the ffx daemon log\n+        self.log_debug(\"\\n---- ffx daemon log ----\\n\")\n+        if os.path.exists(self.ffx_daemon_log_path()):\n+            with open(self.ffx_daemon_log_path(), encoding=\"utf-8\") as log:\n+                self.log_debug(log.read())\n+        else:\n+            self.log_debug(\"No ffx daemon log found\")\n+\n+        # Stop package server\n+        self.log_info(\"Stopping package server...\")\n+        os.kill(self.package_server_pid, signal.SIGTERM)\n+\n+        # Shut down the emulator\n+        self.log_info(\"Stopping emulator...\")\n+        subprocess.check_call(\n+            [\n+                self.tool_path(\"fvdl\"),\n+                \"--sdk\",\n+                \"kill\",\n+                \"--launched-proto\",\n+                self.vdl_output_path(),\n+            ],\n+            stdout=self.subprocess_output(),\n+            stderr=self.subprocess_output(),\n+        )\n+\n+        # Stop ffx isolation\n+        self.log_info(\"Stopping ffx isolation...\")\n+        self.stop_ffx_isolation()\n+\n+    def delete_tmp(self):\n+        # Remove temporary files\n+        self.log_info(\"Deleting temporary files...\")\n+        shutil.rmtree(self.tmp_dir(), ignore_errors=True)\n+\n+    def debug(self, args):\n+        command = [\n+            self.tool_path(\"ffx\"),\n+            \"--config\",\n+            self.ffx_user_config_path(),\n+            \"debug\",\n+            \"connect\",\n+            \"--\",\n+            \"--build-id-dir\",\n+            os.path.join(self.sdk_dir, \".build-id\"),\n+            \"--build-id-dir\",\n+            os.path.join(self.libs_dir(), \".build-id\"),\n+        ]\n+\n+        # Add rust source if it's available\n+        if args.rust_src is not None:\n+            command += [\n+                \"--build-dir\",\n+                args.rust_src,\n+            ]\n+\n+        # Add fuchsia source if it's available\n+        if args.fuchsia_src is not None:\n+            command += [\n+                \"--build-dir\",\n+                os.path.join(args.fuchsia_src, \"out\", \"default\"),\n+            ]\n+\n+        # Load debug symbols for the test binary and automatically attach\n+        if args.test is not None:\n+            if args.rust_src is None:\n+                raise Exception(\n+                    \"A Rust source path is required with the `test` argument\"\n+                )\n+\n+            test_name = os.path.splitext(os.path.basename(args.test))[0]\n+\n+            build_dir = os.path.join(\n+                args.rust_src,\n+                \"fuchsia-build\",\n+                self.host_arch_triple(),\n+            )\n+            test_dir = os.path.join(\n+                build_dir,\n+                \"test\",\n+                os.path.dirname(args.test),\n+                test_name,\n+            )\n+\n+            with open(self.zxdb_script_path(), mode=\"w\", encoding=\"utf-8\") as f:\n+                print(f\"attach {test_name[:31]}\", file=f)\n+\n+            command += [\n+                \"--symbol-path\",\n+                test_dir,\n+                \"-S\",\n+                self.zxdb_script_path(),\n+            ]\n+\n+        # Add any other zxdb arguments the user passed\n+        if args.zxdb_args is not None:\n+            command += args.zxdb_args\n+\n+        # Connect to the running emulator with zxdb\n+        subprocess.run(command, env=self.ffx_cmd_env(), check=False)\n+\n+\n+def start(args):\n+    test_env = TestEnvironment.from_args(args)\n+    test_env.start()\n+    return 0\n+\n+\n+def run(args):\n+    test_env = TestEnvironment.read_from_file()\n+    return test_env.run(args)\n+\n+\n+def stop(args):\n+    test_env = TestEnvironment.read_from_file()\n+    test_env.stop()\n+    if not args.no_delete:\n+        test_env.delete_tmp()\n+    return 0\n+\n+\n+def delete_tmp(args):\n+    del args\n+    test_env = TestEnvironment.read_from_file()\n+    test_env.delete_tmp()\n+    return 0\n+\n+\n+def debug(args):\n+    test_env = TestEnvironment.read_from_file()\n+    test_env.debug(args)\n+    return 0\n+\n+\n+def main():\n+    parser = argparse.ArgumentParser()\n+\n+    def print_help(args):\n+        del args\n+        parser.print_help()\n+        return 0\n+\n+    parser.set_defaults(func=print_help)\n+\n+    subparsers = parser.add_subparsers(help=\"valid sub-commands\")\n+\n+    start_parser = subparsers.add_parser(\n+        \"start\", help=\"initializes the testing environment\"\n+    )\n+    start_parser.add_argument(\n+        \"--rust\",\n+        help=\"the directory of the installed Rust compiler for Fuchsia\",\n+        required=True,\n+    )\n+    start_parser.add_argument(\n+        \"--sdk\",\n+        help=\"the directory of the fuchsia SDK\",\n+        required=True,\n+    )\n+    start_parser.add_argument(\n+        \"--verbose\",\n+        help=\"prints more output from executed processes\",\n+        action=\"store_true\",\n+    )\n+    start_parser.add_argument(\n+        \"--target-arch\",\n+        help=\"the architecture of the image to test\",\n+        required=True,\n+    )\n+    start_parser.set_defaults(func=start)\n+\n+    run_parser = subparsers.add_parser(\n+        \"run\", help=\"run a test in the testing environment\"\n+    )\n+    run_parser.add_argument(\n+        \"n\", help=\"the number of shared libs passed along with the executable\", type=int\n+    )\n+    run_parser.add_argument(\"bin_path\", help=\"path to the binary to run\")\n+    run_parser.add_argument(\n+        \"shared_libs\",\n+        help=\"the shared libs passed along with the binary\",\n+        nargs=argparse.REMAINDER,\n+    )\n+    run_parser.set_defaults(func=run)\n+\n+    stop_parser = subparsers.add_parser(\n+        \"stop\", help=\"shuts down and cleans up the testing environment\"\n+    )\n+    stop_parser.add_argument(\n+        \"--no-delete\",\n+        default=False,\n+        action=\"store_true\",\n+        help=\"don't delete temporary files after stopping\",\n+    )\n+    stop_parser.set_defaults(func=stop)\n+\n+    delete_parser = subparsers.add_parser(\n+        \"delete-tmp\",\n+        help=\"deletes temporary files after the testing environment has been manually cleaned up\",\n+    )\n+    delete_parser.set_defaults(func=delete_tmp)\n+\n+    debug_parser = subparsers.add_parser(\n+        \"debug\",\n+        help=\"connect to the active testing environment with zxdb\",\n+    )\n+    debug_parser.add_argument(\n+        \"--rust-src\",\n+        default=None,\n+        help=\"the path to the Rust source being tested\",\n+    )\n+    debug_parser.add_argument(\n+        \"--fuchsia-src\",\n+        default=None,\n+        help=\"the path to the Fuchsia source\",\n+    )\n+    debug_parser.add_argument(\n+        \"--test\",\n+        default=None,\n+        help=\"the path to the test to debug (e.g. ui/box/new.rs)\",\n+    )\n+    debug_parser.add_argument(\n+        \"zxdb_args\",\n+        default=None,\n+        nargs=argparse.REMAINDER,\n+        help=\"any additional arguments to pass to zxdb\",\n+    )\n+    debug_parser.set_defaults(func=debug)\n+\n+    args = parser.parse_args()\n+    return args.func(args)\n+\n+\n+if __name__ == \"__main__\":\n+    sys.exit(main())"}, {"sha": "62cad19d0ec3328a1793196e8c0301470cfb3af8", "filename": "src/doc/rustc/src/platform-support/fuchsia.md", "status": "modified", "additions": 54, "deletions": 2, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/98be657c7c800e9a096035198d4991f0796172a7/src%2Fdoc%2Frustc%2Fsrc%2Fplatform-support%2Ffuchsia.md", "raw_url": "https://github.com/rust-lang/rust/raw/98be657c7c800e9a096035198d4991f0796172a7/src%2Fdoc%2Frustc%2Fsrc%2Fplatform-support%2Ffuchsia.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Frustc%2Fsrc%2Fplatform-support%2Ffuchsia.md?ref=98be657c7c800e9a096035198d4991f0796172a7", "patch": "@@ -641,8 +641,60 @@ available on the [Fuchsia devsite].\n \n ### Running the compiler test suite\n \n-Running the Rust test suite on Fuchsia is [not currently supported], but work is\n-underway to enable it.\n+Pre-requisites for running the Rust test suite on Fuchsia are:\n+1. Checkout of Rust source.\n+1. Setup of `config-env.sh` and `config.toml` from \"[Targeting Fuchsia with a compiler built from source](#targeting-fuchsia-with-a-compiler-built-from-source)\".\n+1. Download of the Fuchsia SDK. Minimum supported SDK version is [9.20220726.1.1](https://chrome-infra-packages.appspot.com/p/fuchsia/sdk/core/linux-amd64/+/version:9.20220726.1.1)\n+\n+Interfacing with the Fuchsia emulator is handled by our test runner script located\n+at `${RUST_SRC_PATH}/src/ci/docker/scripts/fuchsia-test-runner.py`.\n+\n+We start by activating our Fuchsia test environment. From a terminal:\n+\n+**Issue command from ${RUST_SRC_PATH}**\n+```sh\n+src/ci/docker/scripts/fuchsia-test-runner.py start\n+    --rust .\n+    --sdk ${SDK_PATH}\n+    --target-arch {x64,arm64}\n+```\n+\n+Next, for ease of commands, we copy `config-env.sh` and `config.toml` into our Rust source\n+code path, `${RUST_SRC_PATH}`.\n+\n+From there, we utilize `x.py` to run our tests, using the test runner script to\n+run the tests on our emulator. To run the full `src/test/ui` test suite:\n+\n+**Run from ${RUST_SRC_PATH}**\n+```sh\n+( \\\n+    source config-env.sh &&                                                   \\\n+    ./x.py                                                                    \\\n+    --config config.toml                                                      \\\n+    --stage=2                                                                 \\\n+    test src/test/ui                                                          \\\n+    --target x86_64-fuchsia                                                   \\\n+    --run=always --jobs 1                                                     \\\n+    --test-args --target-rustcflags -L                                        \\\n+    --test-args --target-rustcflags ${SDK_PATH}/arch/{x64|arm64}/sysroot/lib  \\\n+    --test-args --target-rustcflags -L                                        \\\n+    --test-args --target-rustcflags ${SDK_PATH}/arch/{x64|arm64}/lib          \\\n+    --test-args --target-rustcflags -Cpanic=abort                             \\\n+    --test-args --target-rustcflags -Zpanic_abort_tests                       \\\n+    --test-args --remote-test-client                                          \\\n+    --test-args src/ci/docker/scripts/fuchsia-test-runner.py                  \\\n+)\n+```\n+\n+*Note: The test suite cannot be run in parallel at the moment, so `x.py`\n+must be run with `--jobs 1` to ensure only one test runs at a time.*\n+\n+When finished, stop the test environment:\n+\n+**Issue command from ${RUST_SRC_PATH}**\n+```sh\n+src/ci/docker/scripts/fuchsia-test-runner.py stop\n+```\n \n ## Debugging\n "}]}