{"sha": "f048fc0fde7255ddec07d6cfed4131adf8f3f241", "node_id": "MDY6Q29tbWl0NzI0NzEyOmYwNDhmYzBmZGU3MjU1ZGRlYzA3ZDZjZmVkNDEzMWFkZjhmM2YyNDE=", "commit": {"author": {"name": "Seiichi Uchida", "email": "seuchida@gmail.com", "date": "2019-03-17T05:04:11Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2019-03-17T05:04:11Z"}, "message": "Merge pull request #3448 from topecongiro/use-new_sub_parser_from_file\n\nSupport path clarity module even when we start from internal module", "tree": {"sha": "df8682d8bf3115474917a246427b694e4b9dd9f5", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/df8682d8bf3115474917a246427b694e4b9dd9f5"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f048fc0fde7255ddec07d6cfed4131adf8f3f241", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJcjdVLCRBK7hj4Ov3rIwAAdHIIAJ883dWZdA868LNacUPERiAd\nr1867LPX9AMeOIbtU9uNGSEWHJ4vLArEl0S7pTpVXcFZAL1+RqbNnvAPrgAPwKH6\nHWMxaZoI4IumwbODzQu04anI9BTNByux1xXoqRPuD+qzPP8KS5nC5hVz0nBNfjL2\nFR+eBkxnoRZrM0b3KNyTs8O/elWX3GOxZw6UjOlb9mjeCAPe2OqCZV4W+zKsz/0f\ng8I0sO0V2lUO7fs836bKEB6I34ShKFsEu4lcApfWvvf6NT1o1/QFWhQp5rDY0GWm\nq+0NnoWKFqy66OqNGvM+I3vIi9pzioC5NcFGeqSzbce8DMO7EO+2p3f3c232XpU=\n=+LaJ\n-----END PGP SIGNATURE-----\n", "payload": "tree df8682d8bf3115474917a246427b694e4b9dd9f5\nparent ad6d89842a30550e29ac37b93dbf4d8bd0ea2bd5\nparent be0ada27f4d0686b77e8119b223129d104985187\nauthor Seiichi Uchida <seuchida@gmail.com> 1552799051 +0900\ncommitter GitHub <noreply@github.com> 1552799051 +0900\n\nMerge pull request #3448 from topecongiro/use-new_sub_parser_from_file\n\nSupport path clarity module even when we start from internal module"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f048fc0fde7255ddec07d6cfed4131adf8f3f241", "html_url": "https://github.com/rust-lang/rust/commit/f048fc0fde7255ddec07d6cfed4131adf8f3f241", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f048fc0fde7255ddec07d6cfed4131adf8f3f241/comments", "author": {"login": "topecongiro", "id": 21980157, "node_id": "MDQ6VXNlcjIxOTgwMTU3", "avatar_url": "https://avatars.githubusercontent.com/u/21980157?v=4", "gravatar_id": "", "url": "https://api.github.com/users/topecongiro", "html_url": "https://github.com/topecongiro", "followers_url": "https://api.github.com/users/topecongiro/followers", "following_url": "https://api.github.com/users/topecongiro/following{/other_user}", "gists_url": "https://api.github.com/users/topecongiro/gists{/gist_id}", "starred_url": "https://api.github.com/users/topecongiro/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/topecongiro/subscriptions", "organizations_url": "https://api.github.com/users/topecongiro/orgs", "repos_url": "https://api.github.com/users/topecongiro/repos", "events_url": "https://api.github.com/users/topecongiro/events{/privacy}", "received_events_url": "https://api.github.com/users/topecongiro/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ad6d89842a30550e29ac37b93dbf4d8bd0ea2bd5", "url": "https://api.github.com/repos/rust-lang/rust/commits/ad6d89842a30550e29ac37b93dbf4d8bd0ea2bd5", "html_url": "https://github.com/rust-lang/rust/commit/ad6d89842a30550e29ac37b93dbf4d8bd0ea2bd5"}, {"sha": "be0ada27f4d0686b77e8119b223129d104985187", "url": "https://api.github.com/repos/rust-lang/rust/commits/be0ada27f4d0686b77e8119b223129d104985187", "html_url": "https://github.com/rust-lang/rust/commit/be0ada27f4d0686b77e8119b223129d104985187"}], "stats": {"total": 319, "additions": 230, "deletions": 89}, "files": [{"sha": "a23c312bd2ae75afbacc3ccdd34ee1dbd0780ec9", "filename": "src/formatting.rs", "status": "modified", "additions": 30, "deletions": 5, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/f048fc0fde7255ddec07d6cfed4131adf8f3f241/src%2Fformatting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f048fc0fde7255ddec07d6cfed4131adf8f3f241/src%2Fformatting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fformatting.rs?ref=f048fc0fde7255ddec07d6cfed4131adf8f3f241", "patch": "@@ -10,7 +10,7 @@ use syntax::ast;\n use syntax::errors::emitter::{ColorConfig, EmitterWriter};\n use syntax::errors::{DiagnosticBuilder, Handler};\n use syntax::parse::{self, ParseSess};\n-use syntax::source_map::{FilePathMapping, SourceMap, Span};\n+use syntax::source_map::{FilePathMapping, SourceMap, Span, DUMMY_SP};\n \n use crate::comment::{CharClasses, FullCodeCharKind};\n use crate::config::{Config, FileName, Verbosity};\n@@ -73,7 +73,14 @@ fn format_project<T: FormatHandler>(\n     let source_map = Rc::new(SourceMap::new(FilePathMapping::empty()));\n     let mut parse_session = make_parse_sess(source_map.clone(), config);\n     let mut report = FormatReport::new();\n-    let krate = match parse_crate(input, &parse_session, config, &mut report) {\n+    let directory_ownership = input.to_directory_ownership();\n+    let krate = match parse_crate(\n+        input,\n+        &parse_session,\n+        config,\n+        &mut report,\n+        directory_ownership,\n+    ) {\n         Ok(krate) => krate,\n         // Surface parse error via Session (errors are merged there from report)\n         Err(ErrorKind::ParseError) => return Ok(report),\n@@ -87,8 +94,14 @@ fn format_project<T: FormatHandler>(\n \n     let mut context = FormatContext::new(&krate, report, parse_session, config, handler);\n \n-    let files = modules::list_files(&krate, context.parse_session.source_map())?;\n-    for (path, module) in files {\n+    let files = modules::ModResolver::new(\n+        context.parse_session.source_map(),\n+        directory_ownership.unwrap_or(parse::DirectoryOwnership::UnownedViaMod(false)),\n+        input_is_stdin,\n+    )\n+    .visit_crate(&krate)\n+    .map_err(|e| io::Error::new(io::ErrorKind::Other, e))?;\n+    for (path, (module, _)) in files {\n         if (config.skip_children() && path != main_file) || config.ignore().skip_file(&path) {\n             continue;\n         }\n@@ -593,16 +606,28 @@ fn parse_crate(\n     parse_session: &ParseSess,\n     config: &Config,\n     report: &mut FormatReport,\n+    directory_ownership: Option<parse::DirectoryOwnership>,\n ) -> Result<ast::Crate, ErrorKind> {\n     let input_is_stdin = input.is_text();\n \n     let parser = match input {\n-        Input::File(file) => Ok(parse::new_parser_from_file(parse_session, &file)),\n+        Input::File(ref file) => {\n+            // Use `new_sub_parser_from_file` when we the input is a submodule.\n+            Ok(if let Some(dir_own) = directory_ownership {\n+                parse::new_sub_parser_from_file(parse_session, file, dir_own, None, DUMMY_SP)\n+            } else {\n+                parse::new_parser_from_file(parse_session, file)\n+            })\n+        }\n         Input::Text(text) => parse::maybe_new_parser_from_source_str(\n             parse_session,\n             syntax::source_map::FileName::Custom(\"stdin\".to_owned()),\n             text,\n         )\n+        .map(|mut parser| {\n+            parser.recurse_into_file_modules = false;\n+            parser\n+        })\n         .map_err(|diags| {\n             diags\n                 .into_iter()"}, {"sha": "b1090e95ff374c12531c694428ef73576419b2e1", "filename": "src/lib.rs", "status": "modified", "additions": 19, "deletions": 1, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/f048fc0fde7255ddec07d6cfed4131adf8f3f241/src%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f048fc0fde7255ddec07d6cfed4131adf8f3f241/src%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib.rs?ref=f048fc0fde7255ddec07d6cfed4131adf8f3f241", "patch": "@@ -20,7 +20,7 @@ use std::path::PathBuf;\n use std::rc::Rc;\n \n use failure::Fail;\n-use syntax::ast;\n+use syntax::{ast, parse::DirectoryOwnership};\n \n use crate::comment::LineClasses;\n use crate::formatting::{FormatErrorMap, FormattingError, ReportedErrors, SourceFile};\n@@ -586,6 +586,24 @@ impl Input {\n             Input::Text(..) => FileName::Stdin,\n         }\n     }\n+\n+    fn to_directory_ownership(&self) -> Option<DirectoryOwnership> {\n+        match self {\n+            Input::File(ref file) => {\n+                // If there exists a directory with the same name as an input,\n+                // then the input should be parsed as a sub module.\n+                let file_stem = file.file_stem()?;\n+                if file.parent()?.to_path_buf().join(file_stem).is_dir() {\n+                    Some(DirectoryOwnership::Owned {\n+                        relative: file_stem.to_str().map(ast::Ident::from_str),\n+                    })\n+                } else {\n+                    None\n+                }\n+            }\n+            _ => None,\n+        }\n+    }\n }\n \n #[cfg(test)]"}, {"sha": "01a0784c6f41c06061a023ca6331e7312392ce09", "filename": "src/modules.rs", "status": "modified", "additions": 147, "deletions": 82, "changes": 229, "blob_url": "https://github.com/rust-lang/rust/blob/f048fc0fde7255ddec07d6cfed4131adf8f3f241/src%2Fmodules.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f048fc0fde7255ddec07d6cfed4131adf8f3f241/src%2Fmodules.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fmodules.rs?ref=f048fc0fde7255ddec07d6cfed4131adf8f3f241", "patch": "@@ -1,5 +1,4 @@\n use std::collections::BTreeMap;\n-use std::io;\n use std::path::{Path, PathBuf};\n \n use syntax::ast;\n@@ -8,25 +7,157 @@ use syntax::source_map;\n use syntax_pos::symbol::Symbol;\n \n use crate::config::FileName;\n+use crate::items::is_mod_decl;\n use crate::utils::contains_skip;\n \n-/// List all the files containing modules of a crate.\n-/// If a file is used twice in a crate, it appears only once.\n-pub fn list_files<'a>(\n-    krate: &'a ast::Crate,\n-    source_map: &source_map::SourceMap,\n-) -> Result<BTreeMap<FileName, &'a ast::Mod>, io::Error> {\n-    let mut result = BTreeMap::new(); // Enforce file order determinism\n-    let root_filename = source_map.span_to_filename(krate.span);\n-    {\n-        let parent = match root_filename {\n-            source_map::FileName::Real(ref path) => path.parent().unwrap(),\n-            _ => Path::new(\"\"),\n+type FileModMap<'a> = BTreeMap<FileName, (&'a ast::Mod, &'a str)>;\n+\n+/// Maps each module to the corresponding file.\n+pub struct ModResolver<'a, 'b> {\n+    source_map: &'b source_map::SourceMap,\n+    directory: Directory,\n+    file_map: FileModMap<'a>,\n+    is_input_stdin: bool,\n+}\n+\n+#[derive(Clone)]\n+struct Directory {\n+    path: PathBuf,\n+    ownership: DirectoryOwnership,\n+}\n+\n+impl<'a, 'b> ModResolver<'a, 'b> {\n+    /// Creates a new `ModResolver`.\n+    pub fn new(\n+        source_map: &'b source_map::SourceMap,\n+        directory_ownership: DirectoryOwnership,\n+        is_input_stdin: bool,\n+    ) -> Self {\n+        ModResolver {\n+            directory: Directory {\n+                path: PathBuf::new(),\n+                ownership: directory_ownership,\n+            },\n+            file_map: BTreeMap::new(),\n+            source_map,\n+            is_input_stdin,\n+        }\n+    }\n+\n+    /// Creates a map that maps a file name to the module in AST.\n+    pub fn visit_crate(mut self, krate: &'a ast::Crate) -> Result<FileModMap<'a>, String> {\n+        let root_filename = self.source_map.span_to_filename(krate.span);\n+        self.directory.path = match root_filename {\n+            source_map::FileName::Real(ref path) => path\n+                .parent()\n+                .expect(\"Parent directory should exists\")\n+                .to_path_buf(),\n+            _ => PathBuf::new(),\n+        };\n+\n+        // Skip visiting sub modules when the input is from stdin.\n+        if !self.is_input_stdin {\n+            self.visit_mod(&krate.module)?;\n+        }\n+\n+        self.file_map\n+            .insert(root_filename.into(), (&krate.module, \"\"));\n+        Ok(self.file_map)\n+    }\n+\n+    fn visit_mod(&mut self, module: &'a ast::Mod) -> Result<(), String> {\n+        for item in &module.items {\n+            if let ast::ItemKind::Mod(ref sub_mod) = item.node {\n+                if contains_skip(&item.attrs) {\n+                    continue;\n+                }\n+\n+                let old_direcotry = self.directory.clone();\n+                if is_mod_decl(item) {\n+                    // mod foo;\n+                    // Look for an extern file.\n+                    let (mod_path, directory_ownership) =\n+                        self.find_external_module(item.ident, &item.attrs)?;\n+                    self.file_map.insert(\n+                        FileName::Real(mod_path.clone()),\n+                        (sub_mod, item.ident.name.as_str().get()),\n+                    );\n+                    self.directory = Directory {\n+                        path: mod_path.parent().unwrap().to_path_buf(),\n+                        ownership: directory_ownership,\n+                    }\n+                } else {\n+                    // An internal module (`mod foo { /* ... */ }`);\n+                    if let Some(path) = find_path_value(&item.attrs) {\n+                        // All `#[path]` files are treated as though they are a `mod.rs` file.\n+                        self.directory = Directory {\n+                            path: Path::new(&path.as_str()).to_path_buf(),\n+                            ownership: DirectoryOwnership::Owned { relative: None },\n+                        };\n+                    } else {\n+                        self.push_inline_mod_directory(item.ident, &item.attrs);\n+                    }\n+                }\n+                self.visit_mod(sub_mod)?;\n+                self.directory = old_direcotry;\n+            }\n+        }\n+        Ok(())\n+    }\n+\n+    fn find_external_module(\n+        &self,\n+        mod_name: ast::Ident,\n+        attrs: &[ast::Attribute],\n+    ) -> Result<(PathBuf, DirectoryOwnership), String> {\n+        if let Some(path) = parser::Parser::submod_path_from_attr(attrs, &self.directory.path) {\n+            return Ok((path, DirectoryOwnership::Owned { relative: None }));\n+        }\n+\n+        let relative = match self.directory.ownership {\n+            DirectoryOwnership::Owned { relative } => relative,\n+            DirectoryOwnership::UnownedViaBlock | DirectoryOwnership::UnownedViaMod(_) => None,\n         };\n-        list_submodules(&krate.module, parent, None, source_map, &mut result)?;\n+        match parser::Parser::default_submod_path(\n+            mod_name,\n+            relative,\n+            &self.directory.path,\n+            self.source_map,\n+        )\n+        .result\n+        {\n+            Ok(parser::ModulePathSuccess {\n+                path,\n+                directory_ownership,\n+                ..\n+            }) => Ok((path, directory_ownership)),\n+            Err(_) => Err(format!(\n+                \"Failed to find module {} in {:?} {:?}\",\n+                mod_name, self.directory.path, relative,\n+            )),\n+        }\n+    }\n+\n+    fn push_inline_mod_directory(&mut self, id: ast::Ident, attrs: &[ast::Attribute]) {\n+        if let Some(path) = find_path_value(attrs) {\n+            self.directory.path.push(&path.as_str());\n+            self.directory.ownership = DirectoryOwnership::Owned { relative: None };\n+        } else {\n+            // We have to push on the current module name in the case of relative\n+            // paths in order to ensure that any additional module paths from inline\n+            // `mod x { ... }` come after the relative extension.\n+            //\n+            // For example, a `mod z { ... }` inside `x/y.rs` should set the current\n+            // directory path to `/x/y/z`, not `/x/z` with a relative offset of `y`.\n+            if let DirectoryOwnership::Owned { relative } = &mut self.directory.ownership {\n+                if let Some(ident) = relative.take() {\n+                    // remove the relative offset\n+                    self.directory.path.push(ident.as_str());\n+                }\n+            }\n+            self.directory.path.push(&id.as_str());\n+        }\n     }\n-    result.insert(root_filename.into(), &krate.module);\n-    Ok(result)\n }\n \n fn path_value(attr: &ast::Attribute) -> Option<Symbol> {\n@@ -43,69 +174,3 @@ fn path_value(attr: &ast::Attribute) -> Option<Symbol> {\n fn find_path_value(attrs: &[ast::Attribute]) -> Option<Symbol> {\n     attrs.iter().flat_map(path_value).next()\n }\n-\n-/// Recursively list all external modules included in a module.\n-fn list_submodules<'a>(\n-    module: &'a ast::Mod,\n-    search_dir: &Path,\n-    relative: Option<ast::Ident>,\n-    source_map: &source_map::SourceMap,\n-    result: &mut BTreeMap<FileName, &'a ast::Mod>,\n-) -> Result<(), io::Error> {\n-    debug!(\"list_submodules: search_dir: {:?}\", search_dir);\n-    for item in &module.items {\n-        if let ast::ItemKind::Mod(ref sub_mod) = item.node {\n-            if !contains_skip(&item.attrs) {\n-                let is_internal = source_map.span_to_filename(item.span)\n-                    == source_map.span_to_filename(sub_mod.inner);\n-                let (dir_path, relative) = if is_internal {\n-                    if let Some(path) = find_path_value(&item.attrs) {\n-                        (search_dir.join(&path.as_str()), None)\n-                    } else {\n-                        (search_dir.join(&item.ident.to_string()), None)\n-                    }\n-                } else {\n-                    let (mod_path, relative) =\n-                        module_file(item.ident, &item.attrs, search_dir, relative, source_map)?;\n-                    let dir_path = mod_path.parent().unwrap().to_owned();\n-                    result.insert(FileName::Real(mod_path), sub_mod);\n-                    (dir_path, relative)\n-                };\n-                list_submodules(sub_mod, &dir_path, relative, source_map, result)?;\n-            }\n-        }\n-    }\n-    Ok(())\n-}\n-\n-/// Finds the file corresponding to an external mod\n-fn module_file(\n-    id: ast::Ident,\n-    attrs: &[ast::Attribute],\n-    dir_path: &Path,\n-    relative: Option<ast::Ident>,\n-    source_map: &source_map::SourceMap,\n-) -> Result<(PathBuf, Option<ast::Ident>), io::Error> {\n-    if let Some(path) = parser::Parser::submod_path_from_attr(attrs, dir_path) {\n-        return Ok((path, None));\n-    }\n-\n-    match parser::Parser::default_submod_path(id, relative, dir_path, source_map).result {\n-        Ok(parser::ModulePathSuccess {\n-            path,\n-            directory_ownership,\n-            ..\n-        }) => {\n-            let relative = if let DirectoryOwnership::Owned { relative } = directory_ownership {\n-                relative\n-            } else {\n-                None\n-            };\n-            Ok((path, relative))\n-        }\n-        Err(_) => Err(io::Error::new(\n-            io::ErrorKind::Other,\n-            format!(\"Couldn't find module {}\", id),\n-        )),\n-    }\n-}"}, {"sha": "61d7c88884a86c3a227009bccb4a47d8856921b1", "filename": "src/test/mod.rs", "status": "modified", "additions": 18, "deletions": 1, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/f048fc0fde7255ddec07d6cfed4131adf8f3f241/src%2Ftest%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f048fc0fde7255ddec07d6cfed4131adf8f3f241/src%2Ftest%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmod.rs?ref=f048fc0fde7255ddec07d6cfed4131adf8f3f241", "patch": "@@ -17,6 +17,19 @@ use crate::{FormatReport, Input, Session};\n const DIFF_CONTEXT_SIZE: usize = 3;\n const CONFIGURATIONS_FILE_NAME: &str = \"Configurations.md\";\n \n+// A list of files on which we want to skip testing.\n+const SKIP_FILE_WHITE_LIST: &[&str] = &[\n+    // We want to make sure that the `skip_children` is correctly working,\n+    // so we do not want to test this file directly.\n+    \"configs/skip_children/foo/mod.rs\",\n+];\n+\n+fn is_file_skip(path: &Path) -> bool {\n+    SKIP_FILE_WHITE_LIST\n+        .iter()\n+        .any(|file_path| path.ends_with(file_path))\n+}\n+\n // Returns a `Vec` containing `PathBuf`s of files with an  `rs` extension in the\n // given path. The `recursive` argument controls if files from subdirectories\n // are also returned.\n@@ -31,7 +44,7 @@ fn get_test_files(path: &Path, recursive: bool) -> Vec<PathBuf> {\n             let path = entry.path();\n             if path.is_dir() && recursive {\n                 files.append(&mut get_test_files(&path, recursive));\n-            } else if path.extension().map_or(false, |f| f == \"rs\") {\n+            } else if path.extension().map_or(false, |f| f == \"rs\") && !is_file_skip(&path) {\n                 files.push(path);\n             }\n         }\n@@ -231,6 +244,10 @@ fn idempotence_tests() {\n // no warnings are emitted.\n #[test]\n fn self_tests() {\n+    match option_env!(\"CFG_RELEASE_CHANNEL\") {\n+        None | Some(\"nightly\") => {}\n+        _ => return, // Issue-3443: these tests require nightly\n+    }\n     let mut files = get_test_files(Path::new(\"tests\"), false);\n     let bin_directories = vec![\"cargo-fmt\", \"git-rustfmt\", \"bin\", \"format-diff\"];\n     for dir in bin_directories {"}, {"sha": "d7ff6cdb8290ee1cc59460ad245d23605bafb30f", "filename": "tests/source/configs/skip_children/foo/mod.rs", "status": "added", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/f048fc0fde7255ddec07d6cfed4131adf8f3f241/tests%2Fsource%2Fconfigs%2Fskip_children%2Ffoo%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f048fc0fde7255ddec07d6cfed4131adf8f3f241/tests%2Fsource%2Fconfigs%2Fskip_children%2Ffoo%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fsource%2Fconfigs%2Fskip_children%2Ffoo%2Fmod.rs?ref=f048fc0fde7255ddec07d6cfed4131adf8f3f241", "patch": "@@ -0,0 +1,3 @@\n+fn skip_formatting_this() {\n+    println ! ( \"Skip this\" ) ;\n+}"}, {"sha": "cd247fabfe340e5e34676214c60253ddb7706823", "filename": "tests/source/path_clarity/foo.rs", "status": "added", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f048fc0fde7255ddec07d6cfed4131adf8f3f241/tests%2Fsource%2Fpath_clarity%2Ffoo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f048fc0fde7255ddec07d6cfed4131adf8f3f241/tests%2Fsource%2Fpath_clarity%2Ffoo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fsource%2Fpath_clarity%2Ffoo.rs?ref=f048fc0fde7255ddec07d6cfed4131adf8f3f241", "patch": "@@ -0,0 +1,2 @@\n+// rustfmt-edition: 2018\n+mod bar;"}, {"sha": "8c1be504c09083b883a14ceeaa5dddab80b61bf6", "filename": "tests/source/path_clarity/foo/bar.rs", "status": "added", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/f048fc0fde7255ddec07d6cfed4131adf8f3f241/tests%2Fsource%2Fpath_clarity%2Ffoo%2Fbar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f048fc0fde7255ddec07d6cfed4131adf8f3f241/tests%2Fsource%2Fpath_clarity%2Ffoo%2Fbar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fsource%2Fpath_clarity%2Ffoo%2Fbar.rs?ref=f048fc0fde7255ddec07d6cfed4131adf8f3f241", "patch": "@@ -0,0 +1,3 @@\n+pub fn fn_in_bar( ) {\n+    println!( \"foo/bar.rs\" );\n+}"}, {"sha": "d7ff6cdb8290ee1cc59460ad245d23605bafb30f", "filename": "tests/target/configs/skip_children/foo/mod.rs", "status": "added", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/f048fc0fde7255ddec07d6cfed4131adf8f3f241/tests%2Ftarget%2Fconfigs%2Fskip_children%2Ffoo%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f048fc0fde7255ddec07d6cfed4131adf8f3f241/tests%2Ftarget%2Fconfigs%2Fskip_children%2Ffoo%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ftarget%2Fconfigs%2Fskip_children%2Ffoo%2Fmod.rs?ref=f048fc0fde7255ddec07d6cfed4131adf8f3f241", "patch": "@@ -0,0 +1,3 @@\n+fn skip_formatting_this() {\n+    println ! ( \"Skip this\" ) ;\n+}"}, {"sha": "cd247fabfe340e5e34676214c60253ddb7706823", "filename": "tests/target/path_clarity/foo.rs", "status": "added", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f048fc0fde7255ddec07d6cfed4131adf8f3f241/tests%2Ftarget%2Fpath_clarity%2Ffoo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f048fc0fde7255ddec07d6cfed4131adf8f3f241/tests%2Ftarget%2Fpath_clarity%2Ffoo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ftarget%2Fpath_clarity%2Ffoo.rs?ref=f048fc0fde7255ddec07d6cfed4131adf8f3f241", "patch": "@@ -0,0 +1,2 @@\n+// rustfmt-edition: 2018\n+mod bar;"}, {"sha": "b18a7d3499c545bcafe2c5b27d39de1f78083483", "filename": "tests/target/path_clarity/foo/bar.rs", "status": "added", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/f048fc0fde7255ddec07d6cfed4131adf8f3f241/tests%2Ftarget%2Fpath_clarity%2Ffoo%2Fbar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f048fc0fde7255ddec07d6cfed4131adf8f3f241/tests%2Ftarget%2Fpath_clarity%2Ffoo%2Fbar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ftarget%2Fpath_clarity%2Ffoo%2Fbar.rs?ref=f048fc0fde7255ddec07d6cfed4131adf8f3f241", "patch": "@@ -0,0 +1,3 @@\n+pub fn fn_in_bar() {\n+    println!(\"foo/bar.rs\");\n+}"}]}