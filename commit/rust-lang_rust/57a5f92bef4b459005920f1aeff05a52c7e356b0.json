{"sha": "57a5f92bef4b459005920f1aeff05a52c7e356b0", "node_id": "MDY6Q29tbWl0NzI0NzEyOjU3YTVmOTJiZWY0YjQ1OTAwNTkyMGYxYWVmZjA1YTUyYzdlMzU2YjA=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-11-10T02:15:28Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-11-10T02:15:28Z"}, "message": "Auto merge of #66259 - JohnTitor:rollup-x9nk1e2, r=JohnTitor\n\nRollup of 7 pull requests\n\nSuccessful merges:\n\n - #65719 (Refactor sync::Once)\n - #65831 (Don't cast directly from &[T; N] to *const T)\n - #66048 (Correct error in documentation for Ipv4Addr method)\n - #66058 (Correct deprecated `is_global` IPv6 documentation)\n - #66216 ([mir-opt] Handle return place in ConstProp and improve SimplifyLocals pass)\n - #66217 (invalid_value lint: use diagnostic items)\n - #66235 (rustc_metadata: don't let LLVM confuse rmeta blobs for COFF object files.)\n\nFailed merges:\n\nr? @ghost", "tree": {"sha": "c35f9a7411db7dce9f6dda1a6d75c19775ee8fce", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c35f9a7411db7dce9f6dda1a6d75c19775ee8fce"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/57a5f92bef4b459005920f1aeff05a52c7e356b0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/57a5f92bef4b459005920f1aeff05a52c7e356b0", "html_url": "https://github.com/rust-lang/rust/commit/57a5f92bef4b459005920f1aeff05a52c7e356b0", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/57a5f92bef4b459005920f1aeff05a52c7e356b0/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c296b2d8309100b27a89707b29f2583aa17e0d3e", "url": "https://api.github.com/repos/rust-lang/rust/commits/c296b2d8309100b27a89707b29f2583aa17e0d3e", "html_url": "https://github.com/rust-lang/rust/commit/c296b2d8309100b27a89707b29f2583aa17e0d3e"}, {"sha": "0fec5ab2bbebbff9dab927133ed9b2dc972b6ab2", "url": "https://api.github.com/repos/rust-lang/rust/commits/0fec5ab2bbebbff9dab927133ed9b2dc972b6ab2", "html_url": "https://github.com/rust-lang/rust/commit/0fec5ab2bbebbff9dab927133ed9b2dc972b6ab2"}], "stats": {"total": 649, "additions": 423, "deletions": 226}, "files": [{"sha": "e05b40052ee769cf81e05b2be117807fc24ac7e0", "filename": "src/libcore/mem/maybe_uninit.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/57a5f92bef4b459005920f1aeff05a52c7e356b0/src%2Flibcore%2Fmem%2Fmaybe_uninit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/57a5f92bef4b459005920f1aeff05a52c7e356b0/src%2Flibcore%2Fmem%2Fmaybe_uninit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fmem%2Fmaybe_uninit.rs?ref=57a5f92bef4b459005920f1aeff05a52c7e356b0", "patch": "@@ -256,6 +256,7 @@ impl<T> MaybeUninit<T> {\n     /// [type]: union.MaybeUninit.html\n     #[stable(feature = \"maybe_uninit\", since = \"1.36.0\")]\n     #[inline(always)]\n+    #[cfg_attr(all(not(bootstrap)), rustc_diagnostic_item = \"maybe_uninit_uninit\")]\n     pub const fn uninit() -> MaybeUninit<T> {\n         MaybeUninit { uninit: () }\n     }\n@@ -339,6 +340,7 @@ impl<T> MaybeUninit<T> {\n     /// ```\n     #[stable(feature = \"maybe_uninit\", since = \"1.36.0\")]\n     #[inline]\n+    #[cfg_attr(all(not(bootstrap)), rustc_diagnostic_item = \"maybe_uninit_zeroed\")]\n     pub fn zeroed() -> MaybeUninit<T> {\n         let mut u = MaybeUninit::<T>::uninit();\n         unsafe {"}, {"sha": "dc7c36ff03c4e07062bf06e34103ce38be849160", "filename": "src/libcore/mem/mod.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/57a5f92bef4b459005920f1aeff05a52c7e356b0/src%2Flibcore%2Fmem%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/57a5f92bef4b459005920f1aeff05a52c7e356b0/src%2Flibcore%2Fmem%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fmem%2Fmod.rs?ref=57a5f92bef4b459005920f1aeff05a52c7e356b0", "patch": "@@ -468,6 +468,7 @@ pub const fn needs_drop<T>() -> bool {\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[allow(deprecated_in_future)]\n #[allow(deprecated)]\n+#[cfg_attr(all(not(bootstrap)), rustc_diagnostic_item = \"mem_zeroed\")]\n pub unsafe fn zeroed<T>() -> T {\n     intrinsics::panic_if_uninhabited::<T>();\n     intrinsics::init()\n@@ -496,6 +497,7 @@ pub unsafe fn zeroed<T>() -> T {\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[allow(deprecated_in_future)]\n #[allow(deprecated)]\n+#[cfg_attr(all(not(bootstrap)), rustc_diagnostic_item = \"mem_uninitialized\")]\n pub unsafe fn uninitialized<T>() -> T {\n     intrinsics::panic_if_uninhabited::<T>();\n     intrinsics::uninit()"}, {"sha": "1d5ed4273abf68393c912d42141aa9253a87d01a", "filename": "src/librustc/ty/adjustment.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/57a5f92bef4b459005920f1aeff05a52c7e356b0/src%2Flibrustc%2Fty%2Fadjustment.rs", "raw_url": "https://github.com/rust-lang/rust/raw/57a5f92bef4b459005920f1aeff05a52c7e356b0/src%2Flibrustc%2Fty%2Fadjustment.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fadjustment.rs?ref=57a5f92bef4b459005920f1aeff05a52c7e356b0", "patch": "@@ -20,6 +20,9 @@ pub enum PointerCast {\n     /// Go from a mut raw pointer to a const raw pointer.\n     MutToConstPointer,\n \n+    /// Go from `*const [T; N]` to `*const T`\n+    ArrayToPointer,\n+\n     /// Unsize a pointer/reference value, e.g., `&[T; n]` to\n     /// `&[T]`. Note that the source could be a thin or fat pointer.\n     /// This will do things like convert thin pointers to fat"}, {"sha": "81e7ef64e975a88363ec49e416858a3d0bd5083f", "filename": "src/librustc_codegen_ssa/lib.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/57a5f92bef4b459005920f1aeff05a52c7e356b0/src%2Flibrustc_codegen_ssa%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/57a5f92bef4b459005920f1aeff05a52c7e356b0/src%2Flibrustc_codegen_ssa%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Flib.rs?ref=57a5f92bef4b459005920f1aeff05a52c7e356b0", "patch": "@@ -59,7 +59,8 @@ pub struct ModuleCodegen<M> {\n     pub kind: ModuleKind,\n }\n \n-pub const METADATA_FILENAME: &str = \"rust.metadata.bin\";\n+// FIXME(eddyb) maybe include the crate name in this?\n+pub const METADATA_FILENAME: &str = \"lib.rmeta\";\n pub const RLIB_BYTECODE_EXTENSION: &str = \"bc.z\";\n \n "}, {"sha": "981fdf2298419822e543cf51e3fb48deb61a30aa", "filename": "src/librustc_codegen_ssa/mir/rvalue.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/57a5f92bef4b459005920f1aeff05a52c7e356b0/src%2Flibrustc_codegen_ssa%2Fmir%2Frvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/57a5f92bef4b459005920f1aeff05a52c7e356b0/src%2Flibrustc_codegen_ssa%2Fmir%2Frvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fmir%2Frvalue.rs?ref=57a5f92bef4b459005920f1aeff05a52c7e356b0", "patch": "@@ -269,6 +269,7 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n                         }\n                     }\n                     mir::CastKind::Pointer(PointerCast::MutToConstPointer)\n+                    | mir::CastKind::Pointer(PointerCast::ArrayToPointer)\n                     | mir::CastKind::Misc => {\n                         assert!(bx.cx().is_backend_immediate(cast));\n                         let ll_t_out = bx.cx().immediate_backend_type(cast);"}, {"sha": "9d1fa4613b8d4dfce171672a9bf69b6186678104", "filename": "src/librustc_lint/builtin.rs", "status": "modified", "additions": 8, "deletions": 13, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/57a5f92bef4b459005920f1aeff05a52c7e356b0/src%2Flibrustc_lint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/57a5f92bef4b459005920f1aeff05a52c7e356b0/src%2Flibrustc_lint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Fbuiltin.rs?ref=57a5f92bef4b459005920f1aeff05a52c7e356b0", "patch": "@@ -1903,29 +1903,23 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for InvalidValue {\n \n         /// Determine if this expression is a \"dangerous initialization\".\n         fn is_dangerous_init(cx: &LateContext<'_, '_>, expr: &hir::Expr) -> Option<InitKind> {\n-            const ZEROED_PATH: &[Symbol] = &[sym::core, sym::mem, sym::zeroed];\n-            const UININIT_PATH: &[Symbol] = &[sym::core, sym::mem, sym::uninitialized];\n             // `transmute` is inside an anonymous module (the `extern` block?);\n             // `Invalid` represents the empty string and matches that.\n+            // FIXME(#66075): use diagnostic items.  Somehow, that does not seem to work\n+            // on intrinsics right now.\n             const TRANSMUTE_PATH: &[Symbol] =\n                 &[sym::core, sym::intrinsics, kw::Invalid, sym::transmute];\n-            const MU_ZEROED_PATH: &[Symbol] =\n-                &[sym::core, sym::mem, sym::maybe_uninit, sym::MaybeUninit, sym::zeroed];\n-            const MU_UNINIT_PATH: &[Symbol] =\n-                &[sym::core, sym::mem, sym::maybe_uninit, sym::MaybeUninit, sym::uninit];\n \n             if let hir::ExprKind::Call(ref path_expr, ref args) = expr.kind {\n                 // Find calls to `mem::{uninitialized,zeroed}` methods.\n                 if let hir::ExprKind::Path(ref qpath) = path_expr.kind {\n                     let def_id = cx.tables.qpath_res(qpath, path_expr.hir_id).opt_def_id()?;\n \n-                    if cx.match_def_path(def_id, ZEROED_PATH) {\n+                    if cx.tcx.is_diagnostic_item(sym::mem_zeroed, def_id) {\n                         return Some(InitKind::Zeroed);\n-                    }\n-                    if cx.match_def_path(def_id, UININIT_PATH) {\n+                    } else if cx.tcx.is_diagnostic_item(sym::mem_uninitialized, def_id) {\n                         return Some(InitKind::Uninit);\n-                    }\n-                    if cx.match_def_path(def_id, TRANSMUTE_PATH) {\n+                    } else if cx.match_def_path(def_id, TRANSMUTE_PATH) {\n                         if is_zero(&args[0]) {\n                             return Some(InitKind::Zeroed);\n                         }\n@@ -1940,9 +1934,10 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for InvalidValue {\n                     if let hir::ExprKind::Call(ref path_expr, _) = args[0].kind {\n                         if let hir::ExprKind::Path(ref qpath) = path_expr.kind {\n                             let def_id = cx.tables.qpath_res(qpath, path_expr.hir_id).opt_def_id()?;\n-                            if cx.match_def_path(def_id, MU_ZEROED_PATH) {\n+\n+                            if cx.tcx.is_diagnostic_item(sym::maybe_uninit_zeroed, def_id) {\n                                 return Some(InitKind::Zeroed);\n-                            } else if cx.match_def_path(def_id, MU_UNINIT_PATH) {\n+                            } else if cx.tcx.is_diagnostic_item(sym::maybe_uninit_uninit, def_id) {\n                                 return Some(InitKind::Uninit);\n                             }\n                         }"}, {"sha": "990a3d984b225ef8776c23788f89eb682985ce7d", "filename": "src/librustc_metadata/rmeta/mod.rs", "status": "modified", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/57a5f92bef4b459005920f1aeff05a52c7e356b0/src%2Flibrustc_metadata%2Frmeta%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/57a5f92bef4b459005920f1aeff05a52c7e356b0/src%2Flibrustc_metadata%2Frmeta%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Frmeta%2Fmod.rs?ref=57a5f92bef4b459005920f1aeff05a52c7e356b0", "patch": "@@ -37,18 +37,15 @@ crate fn rustc_version() -> String {\n /// Metadata encoding version.\n /// N.B., increment this if you change the format of metadata such that\n /// the rustc version can't be found to compare with `rustc_version()`.\n-const METADATA_VERSION: u8 = 4;\n+const METADATA_VERSION: u8 = 5;\n \n /// Metadata header which includes `METADATA_VERSION`.\n-/// To get older versions of rustc to ignore this metadata,\n-/// there are 4 zero bytes at the start, which are treated\n-/// as a length of 0 by old compilers.\n ///\n /// This header is followed by the position of the `CrateRoot`,\n /// which is encoded as a 32-bit big-endian unsigned integer,\n /// and further followed by the rustc version string.\n-crate const METADATA_HEADER: &[u8; 12] =\n-    &[0, 0, 0, 0, b'r', b'u', b's', b't', 0, 0, 0, METADATA_VERSION];\n+crate const METADATA_HEADER: &[u8; 8] =\n+    &[b'r', b'u', b's', b't', 0, 0, 0, METADATA_VERSION];\n \n /// Additional metadata for a `Lazy<T>` where `T` may not be `Sized`,\n /// e.g. for `Lazy<[T]>`, this is the length (count of `T` values)."}, {"sha": "d5fd214a9d9880e1db102e4d92c4f420a50a7cf1", "filename": "src/librustc_mir/borrow_check/nll/type_check/mod.rs", "status": "modified", "additions": 108, "deletions": 54, "changes": 162, "blob_url": "https://github.com/rust-lang/rust/blob/57a5f92bef4b459005920f1aeff05a52c7e356b0/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/57a5f92bef4b459005920f1aeff05a52c7e356b0/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fmod.rs?ref=57a5f92bef4b459005920f1aeff05a52c7e356b0", "patch": "@@ -36,6 +36,7 @@ use rustc::traits::query::type_op::custom::CustomTypeOp;\n use rustc::traits::query::{Fallible, NoSolution};\n use rustc::traits::{self, ObligationCause, PredicateObligations};\n use rustc::ty::adjustment::{PointerCast};\n+use rustc::ty::cast::CastTy;\n use rustc::ty::fold::TypeFoldable;\n use rustc::ty::subst::{Subst, SubstsRef, GenericArgKind, UserSubsts};\n use rustc::ty::{\n@@ -2177,72 +2178,125 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n                                 ty_from,\n                                 ty_to,\n                                 terr\n-                            )\n+                            );\n                         }\n                     }\n \n-                    CastKind::Misc => {\n-                        if let ty::Ref(_, mut ty_from, _) = op.ty(body, tcx).kind {\n-                            let (mut ty_to, mutability) = if let ty::RawPtr(ty::TypeAndMut {\n-                                ty: ty_to,\n-                                mutbl,\n-                            }) = ty.kind {\n-                                (ty_to, mutbl)\n-                            } else {\n+                    CastKind::Pointer(PointerCast::ArrayToPointer)  => {\n+                        let ty_from = op.ty(body, tcx);\n+\n+                        let opt_ty_elem = match ty_from.kind {\n+                            ty::RawPtr(\n+                                ty::TypeAndMut { mutbl: hir::MutImmutable, ty: array_ty }\n+                            ) => {\n+                                match array_ty.kind {\n+                                    ty::Array(ty_elem, _) => Some(ty_elem),\n+                                    _ => None,\n+                                }\n+                            }\n+                            _ => None,\n+                        };\n+\n+                        let ty_elem = match opt_ty_elem {\n+                            Some(ty_elem) => ty_elem,\n+                            None => {\n                                 span_mirbug!(\n                                     self,\n                                     rvalue,\n-                                    \"invalid cast types {:?} -> {:?}\",\n-                                    op.ty(body, tcx),\n+                                    \"ArrayToPointer cast from unexpected type {:?}\",\n+                                    ty_from,\n+                                );\n+                                return;\n+                            }\n+                        };\n+\n+                        let ty_to = match ty.kind {\n+                            ty::RawPtr(\n+                                ty::TypeAndMut { mutbl: hir::MutImmutable, ty: ty_to }\n+                            ) => {\n+                                ty_to\n+                            }\n+                            _ => {\n+                                span_mirbug!(\n+                                    self,\n+                                    rvalue,\n+                                    \"ArrayToPointer cast to unexpected type {:?}\",\n                                     ty,\n                                 );\n                                 return;\n-                            };\n-\n-                            // Handle the direct cast from `&[T; N]` to `*const T` by unwrapping\n-                            // any array we find.\n-                            while let ty::Array(ty_elem_from, _) = ty_from.kind {\n-                                ty_from = ty_elem_from;\n-                                if let ty::Array(ty_elem_to, _) = ty_to.kind {\n-                                    ty_to = ty_elem_to;\n-                                } else {\n-                                    break;\n-                                }\n                             }\n+                        };\n \n-                            if let hir::MutMutable = mutability {\n-                                if let Err(terr) = self.eq_types(\n-                                    ty_from,\n-                                    ty_to,\n-                                    location.to_locations(),\n-                                    ConstraintCategory::Cast,\n-                                ) {\n-                                    span_mirbug!(\n-                                        self,\n-                                        rvalue,\n-                                        \"equating {:?} with {:?} yields {:?}\",\n-                                        ty_from,\n-                                        ty_to,\n-                                        terr\n-                                    )\n-                                }\n-                            } else {\n-                                if let Err(terr) = self.sub_types(\n-                                    ty_from,\n-                                    ty_to,\n-                                    location.to_locations(),\n-                                    ConstraintCategory::Cast,\n-                                ) {\n-                                    span_mirbug!(\n-                                        self,\n-                                        rvalue,\n-                                        \"relating {:?} with {:?} yields {:?}\",\n-                                        ty_from,\n-                                        ty_to,\n-                                        terr\n-                                    )\n+                        if let Err(terr) = self.sub_types(\n+                            ty_elem,\n+                            ty_to,\n+                            location.to_locations(),\n+                            ConstraintCategory::Cast,\n+                        ) {\n+                            span_mirbug!(\n+                                self,\n+                                rvalue,\n+                                \"relating {:?} with {:?} yields {:?}\",\n+                                ty_elem,\n+                                ty_to,\n+                                terr\n+                            )\n+                        }\n+                    }\n+\n+                    CastKind::Misc => {\n+                        let ty_from = op.ty(body, tcx);\n+                        let cast_ty_from = CastTy::from_ty(ty_from);\n+                        let cast_ty_to = CastTy::from_ty(ty);\n+                        match (cast_ty_from, cast_ty_to) {\n+                            (Some(CastTy::RPtr(ref_tm)), Some(CastTy::Ptr(ptr_tm))) => {\n+                                if let hir::MutMutable = ptr_tm.mutbl {\n+                                    if let Err(terr) = self.eq_types(\n+                                        ref_tm.ty,\n+                                        ptr_tm.ty,\n+                                        location.to_locations(),\n+                                        ConstraintCategory::Cast,\n+                                    ) {\n+                                        span_mirbug!(\n+                                            self,\n+                                            rvalue,\n+                                            \"equating {:?} with {:?} yields {:?}\",\n+                                            ref_tm.ty,\n+                                            ptr_tm.ty,\n+                                            terr\n+                                        )\n+                                    }\n+                                } else {\n+                                    if let Err(terr) = self.sub_types(\n+                                        ref_tm.ty,\n+                                        ptr_tm.ty,\n+                                        location.to_locations(),\n+                                        ConstraintCategory::Cast,\n+                                    ) {\n+                                        span_mirbug!(\n+                                            self,\n+                                            rvalue,\n+                                            \"relating {:?} with {:?} yields {:?}\",\n+                                            ref_tm.ty,\n+                                            ptr_tm.ty,\n+                                            terr\n+                                        )\n+                                    }\n                                 }\n-                            }\n+                            },\n+                            (None, _)\n+                            | (_, None)\n+                            | (_, Some(CastTy::FnPtr))\n+                            | (Some(CastTy::Float), Some(CastTy::Ptr(_)))\n+                            | (Some(CastTy::Ptr(_)), Some(CastTy::Float))\n+                            | (Some(CastTy::FnPtr), Some(CastTy::Float)) => span_mirbug!(\n+                                self,\n+                                rvalue,\n+                                \"Invalid cast {:?} -> {:?}\",\n+                                ty_from,\n+                                ty,\n+                            ),\n+                            _ => (),\n                         }\n                     }\n                 }"}, {"sha": "fbdc4ceeeede853a3a1cf4de0ef889529d04ce14", "filename": "src/librustc_mir/hair/cx/expr.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/57a5f92bef4b459005920f1aeff05a52c7e356b0/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/57a5f92bef4b459005920f1aeff05a52c7e356b0/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs?ref=57a5f92bef4b459005920f1aeff05a52c7e356b0", "patch": "@@ -628,6 +628,11 @@ fn make_mirror_unadjusted<'a, 'tcx>(\n             let cast = if cx.tables().is_coercion_cast(source.hir_id) {\n                 // Convert the lexpr to a vexpr.\n                 ExprKind::Use { source: source.to_ref() }\n+            } else if cx.tables().expr_ty(source).is_region_ptr() {\n+                // Special cased so that we can type check that the element\n+                // type of the source matches the pointed to type of the\n+                // destination.\n+                ExprKind::Pointer { source: source.to_ref(), cast: PointerCast::ArrayToPointer }\n             } else {\n                 // check whether this is casting an enum variant discriminant\n                 // to prevent cycles, we refer to the discriminant initializer"}, {"sha": "1fb8b3ca63fcf228739a3729a12603888a24f27b", "filename": "src/librustc_mir/interpret/cast.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/57a5f92bef4b459005920f1aeff05a52c7e356b0/src%2Flibrustc_mir%2Finterpret%2Fcast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/57a5f92bef4b459005920f1aeff05a52c7e356b0/src%2Flibrustc_mir%2Finterpret%2Fcast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fcast.rs?ref=57a5f92bef4b459005920f1aeff05a52c7e356b0", "patch": "@@ -26,7 +26,9 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                 self.unsize_into(src, dest)?;\n             }\n \n-            Misc | Pointer(PointerCast::MutToConstPointer) => {\n+            Misc\n+            | Pointer(PointerCast::MutToConstPointer)\n+            | Pointer(PointerCast::ArrayToPointer) => {\n                 let src = self.read_immediate(src)?;\n                 let res = self.cast_immediate(src, dest.layout)?;\n                 self.write_immediate(res, dest)?;"}, {"sha": "a0d04bd593212ff828d3ee3462f863b45a4fe2f2", "filename": "src/librustc_mir/transform/const_prop.rs", "status": "modified", "additions": 30, "deletions": 5, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/57a5f92bef4b459005920f1aeff05a52c7e356b0/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/57a5f92bef4b459005920f1aeff05a52c7e356b0/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs?ref=57a5f92bef4b459005920f1aeff05a52c7e356b0", "patch": "@@ -9,7 +9,7 @@ use rustc::hir::def_id::DefId;\n use rustc::mir::{\n     AggregateKind, Constant, Location, Place, PlaceBase, Body, Operand, Rvalue, Local, UnOp,\n     StatementKind, Statement, LocalKind, TerminatorKind, Terminator,  ClearCrossCrate, SourceInfo,\n-    BinOp, SourceScope, SourceScopeLocalData, LocalDecl, BasicBlock,\n+    BinOp, SourceScope, SourceScopeLocalData, LocalDecl, BasicBlock, RETURN_PLACE,\n };\n use rustc::mir::visit::{\n     Visitor, PlaceContext, MutatingUseContext, MutVisitor, NonMutatingUseContext,\n@@ -25,6 +25,7 @@ use rustc::ty::layout::{\n     LayoutOf, TyLayout, LayoutError, HasTyCtxt, TargetDataLayout, HasDataLayout,\n };\n \n+use crate::rustc::ty::subst::Subst;\n use crate::interpret::{\n     self, InterpCx, ScalarMaybeUndef, Immediate, OpTy,\n     StackPopCleanup, LocalValue, LocalState, AllocId, Frame,\n@@ -269,6 +270,7 @@ struct ConstPropagator<'mir, 'tcx> {\n     param_env: ParamEnv<'tcx>,\n     source_scope_local_data: ClearCrossCrate<IndexVec<SourceScope, SourceScopeLocalData>>,\n     local_decls: IndexVec<Local, LocalDecl<'tcx>>,\n+    ret: Option<OpTy<'tcx, ()>>,\n }\n \n impl<'mir, 'tcx> LayoutOf for ConstPropagator<'mir, 'tcx> {\n@@ -308,11 +310,21 @@ impl<'mir, 'tcx> ConstPropagator<'mir, 'tcx> {\n         let mut ecx = InterpCx::new(tcx.at(span), param_env, ConstPropMachine, ());\n         let can_const_prop = CanConstProp::check(body);\n \n+        let substs = &InternalSubsts::identity_for_item(tcx, def_id);\n+\n+        let ret =\n+            ecx\n+                .layout_of(body.return_ty().subst(tcx, substs))\n+                .ok()\n+                // Don't bother allocating memory for ZST types which have no values.\n+                .filter(|ret_layout| !ret_layout.is_zst())\n+                .map(|ret_layout| ecx.allocate(ret_layout, MemoryKind::Stack));\n+\n         ecx.push_stack_frame(\n-            Instance::new(def_id, &InternalSubsts::identity_for_item(tcx, def_id)),\n+            Instance::new(def_id, substs),\n             span,\n             dummy_body,\n-            None,\n+            ret.map(Into::into),\n             StackPopCleanup::None {\n                 cleanup: false,\n             },\n@@ -327,6 +339,7 @@ impl<'mir, 'tcx> ConstPropagator<'mir, 'tcx> {\n             source_scope_local_data,\n             //FIXME(wesleywiser) we can't steal this because `Visitor::super_visit_body()` needs it\n             local_decls: body.local_decls.clone(),\n+            ret: ret.map(Into::into),\n         }\n     }\n \n@@ -335,6 +348,15 @@ impl<'mir, 'tcx> ConstPropagator<'mir, 'tcx> {\n     }\n \n     fn get_const(&self, local: Local) -> Option<Const<'tcx>> {\n+        if local == RETURN_PLACE {\n+            // Try to read the return place as an immediate so that if it is representable as a\n+            // scalar, we can handle it as such, but otherwise, just return the value as is.\n+            return match self.ret.map(|ret| self.ecx.try_read_immediate(ret)) {\n+                Some(Ok(Ok(imm))) => Some(imm.into()),\n+                _ => self.ret,\n+            };\n+        }\n+\n         self.ecx.access_local(self.ecx.frame(), local, None).ok()\n     }\n \n@@ -643,7 +665,8 @@ impl CanConstProp {\n             //        lint for x != y\n             // FIXME(oli-obk): lint variables until they are used in a condition\n             // FIXME(oli-obk): lint if return value is constant\n-            *val = body.local_kind(local) == LocalKind::Temp;\n+            let local_kind = body.local_kind(local);\n+            *val = local_kind == LocalKind::Temp || local_kind == LocalKind::ReturnPointer;\n \n             if !*val {\n                 trace!(\"local {:?} can't be propagated because it's not a temporary\", local);\n@@ -731,7 +754,9 @@ impl<'mir, 'tcx> MutVisitor<'tcx> for ConstPropagator<'mir, 'tcx> {\n                             }\n                         } else {\n                             trace!(\"can't propagate into {:?}\", local);\n-                            self.remove_const(local);\n+                            if local != RETURN_PLACE {\n+                                self.remove_const(local);\n+                            }\n                         }\n                     }\n                 }"}, {"sha": "ab4b6153aa135c409a4453920a3e3d8062a24b8c", "filename": "src/librustc_mir/transform/qualify_min_const_fn.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/57a5f92bef4b459005920f1aeff05a52c7e356b0/src%2Flibrustc_mir%2Ftransform%2Fqualify_min_const_fn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/57a5f92bef4b459005920f1aeff05a52c7e356b0/src%2Flibrustc_mir%2Ftransform%2Fqualify_min_const_fn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fqualify_min_const_fn.rs?ref=57a5f92bef4b459005920f1aeff05a52c7e356b0", "patch": "@@ -150,7 +150,8 @@ fn check_rvalue(\n                 _ => check_operand(tcx, operand, span, def_id, body),\n             }\n         }\n-        Rvalue::Cast(CastKind::Pointer(PointerCast::MutToConstPointer), operand, _) => {\n+        Rvalue::Cast(CastKind::Pointer(PointerCast::MutToConstPointer), operand, _)\n+        | Rvalue::Cast(CastKind::Pointer(PointerCast::ArrayToPointer), operand, _) => {\n             check_operand(tcx, operand, span, def_id, body)\n         }\n         Rvalue::Cast(CastKind::Pointer(PointerCast::UnsafeFnPointer), _, _) |"}, {"sha": "f6b09f20bab679976b7af399128144c01a3c6670", "filename": "src/librustc_mir/transform/simplify.rs", "status": "modified", "additions": 15, "deletions": 8, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/57a5f92bef4b459005920f1aeff05a52c7e356b0/src%2Flibrustc_mir%2Ftransform%2Fsimplify.rs", "raw_url": "https://github.com/rust-lang/rust/raw/57a5f92bef4b459005920f1aeff05a52c7e356b0/src%2Flibrustc_mir%2Ftransform%2Fsimplify.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fsimplify.rs?ref=57a5f92bef4b459005920f1aeff05a52c7e356b0", "patch": "@@ -359,13 +359,20 @@ impl<'a, 'tcx> Visitor<'tcx> for DeclMarker<'a, 'tcx> {\n         // Ignore stores of constants because `ConstProp` and `CopyProp` can remove uses of many\n         // of these locals. However, if the local is still needed, then it will be referenced in\n         // another place and we'll mark it as being used there.\n-        if ctx == PlaceContext::MutatingUse(MutatingUseContext::Store) {\n-            let stmt =\n-                &self.body.basic_blocks()[location.block].statements[location.statement_index];\n-            if let StatementKind::Assign(box (p, Rvalue::Use(Operand::Constant(c)))) = &stmt.kind {\n-                if p.as_local().is_some() {\n-                    trace!(\"skipping store of const value {:?} to {:?}\", c, local);\n-                    return;\n+        if ctx == PlaceContext::MutatingUse(MutatingUseContext::Store) ||\n+           ctx == PlaceContext::MutatingUse(MutatingUseContext::Projection) {\n+            let block = &self.body.basic_blocks()[location.block];\n+            if location.statement_index != block.statements.len() {\n+                let stmt =\n+                    &block.statements[location.statement_index];\n+\n+                if let StatementKind::Assign(\n+                    box (p, Rvalue::Use(Operand::Constant(c)))\n+                ) = &stmt.kind {\n+                    if !p.is_indirect() {\n+                        trace!(\"skipping store of const value {:?} to {:?}\", c, p);\n+                        return;\n+                    }\n                 }\n             }\n         }\n@@ -392,7 +399,7 @@ impl<'tcx> MutVisitor<'tcx> for LocalUpdater<'tcx> {\n                     self.map[*l].is_some()\n                 }\n                 StatementKind::Assign(box (place, _)) => {\n-                    if let Some(local) = place.as_local() {\n+                    if let PlaceBase::Local(local) = place.base {\n                         self.map[local].is_some()\n                     } else {\n                         true"}, {"sha": "6ef3ec00dc3d3214228fa153bcd82536d1ba1677", "filename": "src/librustc_typeck/check/cast.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/57a5f92bef4b459005920f1aeff05a52c7e356b0/src%2Flibrustc_typeck%2Fcheck%2Fcast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/57a5f92bef4b459005920f1aeff05a52c7e356b0/src%2Flibrustc_typeck%2Fcheck%2Fcast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcast.rs?ref=57a5f92bef4b459005920f1aeff05a52c7e356b0", "patch": "@@ -636,6 +636,15 @@ impl<'a, 'tcx> CastCheck<'tcx> {\n                 // need to special-case obtaining a raw pointer\n                 // from a region pointer to a vector.\n \n+                // Coerce to a raw pointer so that we generate AddressOf in MIR.\n+                let array_ptr_type = fcx.tcx.mk_ptr(m_expr);\n+                fcx.try_coerce(self.expr, self.expr_ty, array_ptr_type, AllowTwoPhase::No)\n+                    .unwrap_or_else(|_| bug!(\n+                        \"could not cast from reference to array to pointer to array ({:?} to {:?})\",\n+                        self.expr_ty,\n+                        array_ptr_type,\n+                    ));\n+\n                 // this will report a type mismatch if needed\n                 fcx.demand_eqtype(self.span, ety, m_cast.ty);\n                 return Ok(CastKind::ArrayPtrCast);"}, {"sha": "21f674af8cffb20a01e3150e634c05e73df6280d", "filename": "src/libstd/net/ip.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/57a5f92bef4b459005920f1aeff05a52c7e356b0/src%2Flibstd%2Fnet%2Fip.rs", "raw_url": "https://github.com/rust-lang/rust/raw/57a5f92bef4b459005920f1aeff05a52c7e356b0/src%2Flibstd%2Fnet%2Fip.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnet%2Fip.rs?ref=57a5f92bef4b459005920f1aeff05a52c7e356b0", "patch": "@@ -536,7 +536,7 @@ impl Ipv4Addr {\n     /// // the broadcast address is not global\n     /// assert_eq!(Ipv4Addr::new(255, 255, 255, 255).is_global(), false);\n     ///\n-    /// // the broadcast address is not global\n+    /// // the address space designated for documentation is not global\n     /// assert_eq!(Ipv4Addr::new(192, 0, 2, 255).is_global(), false);\n     /// assert_eq!(Ipv4Addr::new(198, 51, 100, 65).is_global(), false);\n     /// assert_eq!(Ipv4Addr::new(203, 0, 113, 6).is_global(), false);\n@@ -1130,7 +1130,7 @@ impl Ipv6Addr {\n     /// The following return [`false`]:\n     ///\n     /// - the loopback address\n-    /// - link-local, site-local, and unique local unicast addresses\n+    /// - link-local and unique local unicast addresses\n     /// - interface-, link-, realm-, admin- and site-local multicast addresses\n     ///\n     /// [`true`]: ../../std/primitive.bool.html"}, {"sha": "e8e395247f9c199dc5d2ca4e0e00c7a66c91a639", "filename": "src/libstd/sync/once.rs", "status": "modified", "additions": 166, "deletions": 125, "changes": 291, "blob_url": "https://github.com/rust-lang/rust/blob/57a5f92bef4b459005920f1aeff05a52c7e356b0/src%2Flibstd%2Fsync%2Fonce.rs", "raw_url": "https://github.com/rust-lang/rust/raw/57a5f92bef4b459005920f1aeff05a52c7e356b0/src%2Flibstd%2Fsync%2Fonce.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fonce.rs?ref=57a5f92bef4b459005920f1aeff05a52c7e356b0", "patch": "@@ -51,11 +51,43 @@\n //\n // You'll find a few more details in the implementation, but that's the gist of\n // it!\n-\n+//\n+// Atomic orderings:\n+// When running `Once` we deal with multiple atomics:\n+// `Once.state_and_queue` and an unknown number of `Waiter.signaled`.\n+// * `state_and_queue` is used (1) as a state flag, (2) for synchronizing the\n+//   result of the `Once`, and (3) for synchronizing `Waiter` nodes.\n+//     - At the end of the `call_inner` function we have to make sure the result\n+//       of the `Once` is acquired. So every load which can be the only one to\n+//       load COMPLETED must have at least Acquire ordering, which means all\n+//       three of them.\n+//     - `WaiterQueue::Drop` is the only place that may store COMPLETED, and\n+//       must do so with Release ordering to make the result available.\n+//     - `wait` inserts `Waiter` nodes as a pointer in `state_and_queue`, and\n+//       needs to make the nodes available with Release ordering. The load in\n+//       its `compare_and_swap` can be Relaxed because it only has to compare\n+//       the atomic, not to read other data.\n+//     - `WaiterQueue::Drop` must see the `Waiter` nodes, so it must load\n+//       `state_and_queue` with Acquire ordering.\n+//     - There is just one store where `state_and_queue` is used only as a\n+//       state flag, without having to synchronize data: switching the state\n+//       from INCOMPLETE to RUNNING in `call_inner`. This store can be Relaxed,\n+//       but the read has to be Acquire because of the requirements mentioned\n+//       above.\n+// * `Waiter.signaled` is both used as a flag, and to protect a field with\n+//   interior mutability in `Waiter`. `Waiter.thread` is changed in\n+//   `WaiterQueue::Drop` which then sets `signaled` with Release ordering.\n+//   After `wait` loads `signaled` with Acquire and sees it is true, it needs to\n+//   see the changes to drop the `Waiter` struct correctly.\n+// * There is one place where the two atomics `Once.state_and_queue` and\n+//   `Waiter.signaled` come together, and might be reordered by the compiler or\n+//   processor. Because both use Aquire ordering such a reordering is not\n+//   allowed, so no need for SeqCst.\n+\n+use crate::cell::Cell;\n use crate::fmt;\n use crate::marker;\n-use crate::ptr;\n-use crate::sync::atomic::{AtomicUsize, AtomicBool, Ordering};\n+use crate::sync::atomic::{AtomicBool, AtomicUsize, Ordering};\n use crate::thread::{self, Thread};\n \n /// A synchronization primitive which can be used to run a one-time global\n@@ -78,10 +110,10 @@ use crate::thread::{self, Thread};\n /// ```\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct Once {\n-    // This `state` word is actually an encoded version of just a pointer to a\n-    // `Waiter`, so we add the `PhantomData` appropriately.\n-    state: AtomicUsize,\n-    _marker: marker::PhantomData<*mut Waiter>,\n+    // `state_and_queue` is actually an a pointer to a `Waiter` with extra state\n+    // bits, so we add the `PhantomData` appropriately.\n+    state_and_queue: AtomicUsize,\n+    _marker: marker::PhantomData<*const Waiter>,\n }\n \n // The `PhantomData` of a raw pointer removes these two auto traits, but we\n@@ -117,12 +149,12 @@ pub struct OnceState {\n #[rustc_deprecated(\n     since = \"1.38.0\",\n     reason = \"the `new` function is now preferred\",\n-    suggestion = \"Once::new()\",\n+    suggestion = \"Once::new()\"\n )]\n pub const ONCE_INIT: Once = Once::new();\n \n-// Four states that a Once can be in, encoded into the lower bits of `state` in\n-// the Once structure.\n+// Four states that a Once can be in, encoded into the lower bits of\n+// `state_and_queue` in the Once structure.\n const INCOMPLETE: usize = 0x0;\n const POISONED: usize = 0x1;\n const RUNNING: usize = 0x2;\n@@ -132,28 +164,32 @@ const COMPLETE: usize = 0x3;\n // this is in the RUNNING state.\n const STATE_MASK: usize = 0x3;\n \n-// Representation of a node in the linked list of waiters in the RUNNING state.\n+// Representation of a node in the linked list of waiters, used while in the\n+// RUNNING state.\n+// Note: `Waiter` can't hold a mutable pointer to the next thread, because then\n+// `wait` would both hand out a mutable reference to its `Waiter` node, and keep\n+// a shared reference to check `signaled`. Instead we hold shared references and\n+// use interior mutability.\n+#[repr(align(4))] // Ensure the two lower bits are free to use as state bits.\n struct Waiter {\n-    thread: Option<Thread>,\n+    thread: Cell<Option<Thread>>,\n     signaled: AtomicBool,\n-    next: *mut Waiter,\n+    next: *const Waiter,\n }\n \n-// Helper struct used to clean up after a closure call with a `Drop`\n-// implementation to also run on panic.\n-struct Finish<'a> {\n-    panicked: bool,\n-    me: &'a Once,\n+// Head of a linked list of waiters.\n+// Every node is a struct on the stack of a waiting thread.\n+// Will wake up the waiters when it gets dropped, i.e. also on panic.\n+struct WaiterQueue<'a> {\n+    state_and_queue: &'a AtomicUsize,\n+    set_state_on_drop_to: usize,\n }\n \n impl Once {\n     /// Creates a new `Once` value.\n     #[stable(feature = \"once_new\", since = \"1.2.0\")]\n     pub const fn new() -> Once {\n-        Once {\n-            state: AtomicUsize::new(INCOMPLETE),\n-            _marker: marker::PhantomData,\n-        }\n+        Once { state_and_queue: AtomicUsize::new(INCOMPLETE), _marker: marker::PhantomData }\n     }\n \n     /// Performs an initialization routine once and only once. The given closure\n@@ -214,7 +250,10 @@ impl Once {\n     ///\n     /// [poison]: struct.Mutex.html#poisoning\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn call_once<F>(&self, f: F) where F: FnOnce() {\n+    pub fn call_once<F>(&self, f: F)\n+    where\n+        F: FnOnce(),\n+    {\n         // Fast path check\n         if self.is_completed() {\n             return;\n@@ -271,16 +310,17 @@ impl Once {\n     /// INIT.call_once(|| {});\n     /// ```\n     #[unstable(feature = \"once_poison\", issue = \"33577\")]\n-    pub fn call_once_force<F>(&self, f: F) where F: FnOnce(&OnceState) {\n+    pub fn call_once_force<F>(&self, f: F)\n+    where\n+        F: FnOnce(&OnceState),\n+    {\n         // Fast path check\n         if self.is_completed() {\n             return;\n         }\n \n         let mut f = Some(f);\n-        self.call_inner(true, &mut |p| {\n-            f.take().unwrap()(&OnceState { poisoned: p })\n-        });\n+        self.call_inner(true, &mut |p| f.take().unwrap()(&OnceState { poisoned: p }));\n     }\n \n     /// Returns `true` if some `call_once` call has completed\n@@ -329,8 +369,8 @@ impl Once {\n         // An `Acquire` load is enough because that makes all the initialization\n         // operations visible to us, and, this being a fast path, weaker\n         // ordering helps with performance. This `Acquire` synchronizes with\n-        // `SeqCst` operations on the slow path.\n-        self.state.load(Ordering::Acquire) == COMPLETE\n+        // `Release` operations on the slow path.\n+        self.state_and_queue.load(Ordering::Acquire) == COMPLETE\n     }\n \n     // This is a non-generic function to reduce the monomorphization cost of\n@@ -345,124 +385,124 @@ impl Once {\n     // currently no way to take an `FnOnce` and call it via virtual dispatch\n     // without some allocation overhead.\n     #[cold]\n-    fn call_inner(&self,\n-                  ignore_poisoning: bool,\n-                  init: &mut dyn FnMut(bool)) {\n-\n-        // This cold path uses SeqCst consistently because the\n-        // performance difference really does not matter there, and\n-        // SeqCst minimizes the chances of something going wrong.\n-        let mut state = self.state.load(Ordering::SeqCst);\n-\n-        'outer: loop {\n-            match state {\n-                // If we're complete, then there's nothing to do, we just\n-                // jettison out as we shouldn't run the closure.\n-                COMPLETE => return,\n-\n-                // If we're poisoned and we're not in a mode to ignore\n-                // poisoning, then we panic here to propagate the poison.\n+    fn call_inner(&self, ignore_poisoning: bool, init: &mut dyn FnMut(bool)) {\n+        let mut state_and_queue = self.state_and_queue.load(Ordering::Acquire);\n+        loop {\n+            match state_and_queue {\n+                COMPLETE => break,\n                 POISONED if !ignore_poisoning => {\n+                    // Panic to propagate the poison.\n                     panic!(\"Once instance has previously been poisoned\");\n                 }\n-\n-                // Otherwise if we see a poisoned or otherwise incomplete state\n-                // we will attempt to move ourselves into the RUNNING state. If\n-                // we succeed, then the queue of waiters starts at null (all 0\n-                // bits).\n-                POISONED |\n-                INCOMPLETE => {\n-                    let old = self.state.compare_and_swap(state, RUNNING,\n-                                                          Ordering::SeqCst);\n-                    if old != state {\n-                        state = old;\n-                        continue\n+                POISONED | INCOMPLETE => {\n+                    // Try to register this thread as the one RUNNING.\n+                    let old = self.state_and_queue.compare_and_swap(\n+                        state_and_queue,\n+                        RUNNING,\n+                        Ordering::Acquire,\n+                    );\n+                    if old != state_and_queue {\n+                        state_and_queue = old;\n+                        continue;\n                     }\n-\n-                    // Run the initialization routine, letting it know if we're\n-                    // poisoned or not. The `Finish` struct is then dropped, and\n-                    // the `Drop` implementation here is responsible for waking\n-                    // up other waiters both in the normal return and panicking\n-                    // case.\n-                    let mut complete = Finish {\n-                        panicked: true,\n-                        me: self,\n+                    // `waiter_queue` will manage other waiting threads, and\n+                    // wake them up on drop.\n+                    let mut waiter_queue = WaiterQueue {\n+                        state_and_queue: &self.state_and_queue,\n+                        set_state_on_drop_to: POISONED,\n                     };\n-                    init(state == POISONED);\n-                    complete.panicked = false;\n-                    return\n+                    // Run the initialization function, letting it know if we're\n+                    // poisoned or not.\n+                    init(state_and_queue == POISONED);\n+                    waiter_queue.set_state_on_drop_to = COMPLETE;\n+                    break;\n                 }\n-\n-                // All other values we find should correspond to the RUNNING\n-                // state with an encoded waiter list in the more significant\n-                // bits. We attempt to enqueue ourselves by moving us to the\n-                // head of the list and bail out if we ever see a state that's\n-                // not RUNNING.\n                 _ => {\n-                    assert!(state & STATE_MASK == RUNNING);\n-                    let mut node = Waiter {\n-                        thread: Some(thread::current()),\n-                        signaled: AtomicBool::new(false),\n-                        next: ptr::null_mut(),\n-                    };\n-                    let me = &mut node as *mut Waiter as usize;\n-                    assert!(me & STATE_MASK == 0);\n-\n-                    while state & STATE_MASK == RUNNING {\n-                        node.next = (state & !STATE_MASK) as *mut Waiter;\n-                        let old = self.state.compare_and_swap(state,\n-                                                              me | RUNNING,\n-                                                              Ordering::SeqCst);\n-                        if old != state {\n-                            state = old;\n-                            continue\n-                        }\n-\n-                        // Once we've enqueued ourselves, wait in a loop.\n-                        // Afterwards reload the state and continue with what we\n-                        // were doing from before.\n-                        while !node.signaled.load(Ordering::SeqCst) {\n-                            thread::park();\n-                        }\n-                        state = self.state.load(Ordering::SeqCst);\n-                        continue 'outer\n-                    }\n+                    // All other values must be RUNNING with possibly a\n+                    // pointer to the waiter queue in the more significant bits.\n+                    assert!(state_and_queue & STATE_MASK == RUNNING);\n+                    wait(&self.state_and_queue, state_and_queue);\n+                    state_and_queue = self.state_and_queue.load(Ordering::Acquire);\n                 }\n             }\n         }\n     }\n }\n \n+fn wait(state_and_queue: &AtomicUsize, mut current_state: usize) {\n+    // Note: the following code was carefully written to avoid creating a\n+    // mutable reference to `node` that gets aliased.\n+    loop {\n+        // Don't queue this thread if the status is no longer running,\n+        // otherwise we will not be woken up.\n+        if current_state & STATE_MASK != RUNNING {\n+            return;\n+        }\n+\n+        // Create the node for our current thread.\n+        let node = Waiter {\n+            thread: Cell::new(Some(thread::current())),\n+            signaled: AtomicBool::new(false),\n+            next: (current_state & !STATE_MASK) as *const Waiter,\n+        };\n+        let me = &node as *const Waiter as usize;\n+\n+        // Try to slide in the node at the head of the linked list, making sure\n+        // that another thread didn't just replace the head of the linked list.\n+        let old = state_and_queue.compare_and_swap(current_state, me | RUNNING, Ordering::Release);\n+        if old != current_state {\n+            current_state = old;\n+            continue;\n+        }\n+\n+        // We have enqueued ourselves, now lets wait.\n+        // It is important not to return before being signaled, otherwise we\n+        // would drop our `Waiter` node and leave a hole in the linked list\n+        // (and a dangling reference). Guard against spurious wakeups by\n+        // reparking ourselves until we are signaled.\n+        while !node.signaled.load(Ordering::Acquire) {\n+            // If the managing thread happens to signal and unpark us before we\n+            // can park ourselves, the result could be this thread never gets\n+            // unparked. Luckily `park` comes with the guarantee that if it got\n+            // an `unpark` just before on an unparked thread is does not park.\n+            thread::park();\n+        }\n+        break;\n+    }\n+}\n+\n #[stable(feature = \"std_debug\", since = \"1.16.0\")]\n impl fmt::Debug for Once {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         f.pad(\"Once { .. }\")\n     }\n }\n \n-impl Drop for Finish<'_> {\n+impl Drop for WaiterQueue<'_> {\n     fn drop(&mut self) {\n-        // Swap out our state with however we finished. We should only ever see\n-        // an old state which was RUNNING.\n-        let queue = if self.panicked {\n-            self.me.state.swap(POISONED, Ordering::SeqCst)\n-        } else {\n-            self.me.state.swap(COMPLETE, Ordering::SeqCst)\n-        };\n-        assert_eq!(queue & STATE_MASK, RUNNING);\n+        // Swap out our state with however we finished.\n+        let state_and_queue =\n+            self.state_and_queue.swap(self.set_state_on_drop_to, Ordering::AcqRel);\n+\n+        // We should only ever see an old state which was RUNNING.\n+        assert_eq!(state_and_queue & STATE_MASK, RUNNING);\n \n-        // Decode the RUNNING to a list of waiters, then walk that entire list\n-        // and wake them up. Note that it is crucial that after we store `true`\n-        // in the node it can be free'd! As a result we load the `thread` to\n-        // signal ahead of time and then unpark it after the store.\n+        // Walk the entire linked list of waiters and wake them up (in lifo\n+        // order, last to register is first to wake up).\n         unsafe {\n-            let mut queue = (queue & !STATE_MASK) as *mut Waiter;\n+            // Right after setting `node.signaled = true` the other thread may\n+            // free `node` if there happens to be has a spurious wakeup.\n+            // So we have to take out the `thread` field and copy the pointer to\n+            // `next` first.\n+            let mut queue = (state_and_queue & !STATE_MASK) as *const Waiter;\n             while !queue.is_null() {\n                 let next = (*queue).next;\n-                let thread = (*queue).thread.take().unwrap();\n-                (*queue).signaled.store(true, Ordering::SeqCst);\n-                thread.unpark();\n+                let thread = (*queue).thread.replace(None).unwrap();\n+                (*queue).signaled.store(true, Ordering::Release);\n+                // ^- FIXME (maybe): This is another case of issue #55005\n+                // `store()` has a potentially dangling ref to `signaled`.\n                 queue = next;\n+                thread.unpark();\n             }\n         }\n     }\n@@ -518,10 +558,10 @@ impl OnceState {\n \n #[cfg(all(test, not(target_os = \"emscripten\")))]\n mod tests {\n+    use super::Once;\n     use crate::panic;\n     use crate::sync::mpsc::channel;\n     use crate::thread;\n-    use super::Once;\n \n     #[test]\n     fn smoke_once() {\n@@ -541,8 +581,10 @@ mod tests {\n         let (tx, rx) = channel();\n         for _ in 0..10 {\n             let tx = tx.clone();\n-            thread::spawn(move|| {\n-                for _ in 0..4 { thread::yield_now() }\n+            thread::spawn(move || {\n+                for _ in 0..4 {\n+                    thread::yield_now()\n+                }\n                 unsafe {\n                     O.call_once(|| {\n                         assert!(!RUN);\n@@ -631,6 +673,5 @@ mod tests {\n \n         assert!(t1.join().is_ok());\n         assert!(t2.join().is_ok());\n-\n     }\n }"}, {"sha": "f07d56e7ea25cb944d7008340be53f29edbd08b4", "filename": "src/libsyntax_pos/symbol.rs", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/57a5f92bef4b459005920f1aeff05a52c7e356b0/src%2Flibsyntax_pos%2Fsymbol.rs", "raw_url": "https://github.com/rust-lang/rust/raw/57a5f92bef4b459005920f1aeff05a52c7e356b0/src%2Flibsyntax_pos%2Fsymbol.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_pos%2Fsymbol.rs?ref=57a5f92bef4b459005920f1aeff05a52c7e356b0", "patch": "@@ -418,9 +418,10 @@ symbols! {\n         match_beginning_vert,\n         match_default_bindings,\n         may_dangle,\n-        maybe_uninit,\n-        MaybeUninit,\n-        mem,\n+        maybe_uninit_uninit,\n+        maybe_uninit_zeroed,\n+        mem_uninitialized,\n+        mem_zeroed,\n         member_constraints,\n         message,\n         meta,\n@@ -713,8 +714,6 @@ symbols! {\n         underscore_imports,\n         underscore_lifetimes,\n         uniform_paths,\n-        uninit,\n-        uninitialized,\n         universal_impl_trait,\n         unmarked_api,\n         unreachable_code,\n@@ -745,7 +744,6 @@ symbols! {\n         windows,\n         windows_subsystem,\n         Yield,\n-        zeroed,\n     }\n }\n "}, {"sha": "7ae1798c7a2e783a1a10fe58d57024159bfd1831", "filename": "src/test/incremental/hashes/struct_constructors.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/57a5f92bef4b459005920f1aeff05a52c7e356b0/src%2Ftest%2Fincremental%2Fhashes%2Fstruct_constructors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/57a5f92bef4b459005920f1aeff05a52c7e356b0/src%2Ftest%2Fincremental%2Fhashes%2Fstruct_constructors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fincremental%2Fhashes%2Fstruct_constructors.rs?ref=57a5f92bef4b459005920f1aeff05a52c7e356b0", "patch": "@@ -152,7 +152,7 @@ pub fn change_constructor_path_regular_struct() {\n }\n \n #[cfg(not(cfail1))]\n-#[rustc_clean(cfg=\"cfail2\", except=\"HirBody,optimized_mir,mir_built,typeck_tables_of\")]\n+#[rustc_clean(cfg=\"cfail2\", except=\"HirBody,mir_built,typeck_tables_of\")]\n #[rustc_clean(cfg=\"cfail3\")]\n pub fn change_constructor_path_regular_struct() {\n     let _ = RegularStruct2 {\n@@ -213,7 +213,7 @@ pub fn change_constructor_path_tuple_struct() {\n }\n \n #[cfg(not(cfail1))]\n-#[rustc_clean(cfg=\"cfail2\", except=\"HirBody,optimized_mir,mir_built,typeck_tables_of\")]\n+#[rustc_clean(cfg=\"cfail2\", except=\"HirBody,mir_built,typeck_tables_of\")]\n #[rustc_clean(cfg=\"cfail3\")]\n pub fn change_constructor_path_tuple_struct() {\n     let _ = TupleStruct2(0, 1, 2);"}, {"sha": "cc9951b554dcec24f9a37e0da8e4417a2f221de2", "filename": "src/test/mir-opt/const_prop/return_place.rs", "status": "added", "additions": 54, "deletions": 0, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/57a5f92bef4b459005920f1aeff05a52c7e356b0/src%2Ftest%2Fmir-opt%2Fconst_prop%2Freturn_place.rs", "raw_url": "https://github.com/rust-lang/rust/raw/57a5f92bef4b459005920f1aeff05a52c7e356b0/src%2Ftest%2Fmir-opt%2Fconst_prop%2Freturn_place.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fconst_prop%2Freturn_place.rs?ref=57a5f92bef4b459005920f1aeff05a52c7e356b0", "patch": "@@ -0,0 +1,54 @@\n+// compile-flags: -C overflow-checks=on\n+\n+fn add() -> u32 {\n+    2 + 2\n+}\n+\n+fn main() {\n+    add();\n+}\n+\n+// END RUST SOURCE\n+// START rustc.add.ConstProp.before.mir\n+// fn add() -> u32 {\n+//     let mut _0: u32;\n+//     let mut _1: (u32, bool);\n+//     bb0: {\n+//         _1 = CheckedAdd(const 2u32, const 2u32);\n+//         assert(!move (_1.1: bool), \"attempt to add with overflow\") -> bb1;\n+//     }\n+//     bb1: {\n+//         _0 = move (_1.0: u32);\n+//         return;\n+//     }\n+//     bb2 (cleanup): {\n+//         resume;\n+//     }\n+// }\n+// END rustc.add.ConstProp.before.mir\n+// START rustc.add.ConstProp.after.mir\n+// fn add() -> u32 {\n+//     let mut _0: u32;\n+//     let mut _1: (u32, bool);\n+//     bb0: {\n+//         _1 = (const 4u32, const false);\n+//         assert(!const false, \"attempt to add with overflow\") -> bb1;\n+//     }\n+//     bb1: {\n+//         _0 = const 4u32;\n+//         return;\n+//     }\n+//     bb2 (cleanup): {\n+//         resume;\n+//     }\n+// }\n+// END rustc.add.ConstProp.after.mir\n+// START rustc.add.PreCodegen.before.mir\n+// fn add() -> u32 {\n+//     let mut _0: u32;\n+//     bb0: {\n+//         _0 = const 4u32;\n+//         return;\n+//     }\n+// }\n+// END rustc.add.PreCodegen.before.mir"}, {"sha": "c75713c3ee53d1798915a4abfd36c4144a0669ec", "filename": "src/test/run-make-fulldeps/invalid-library/Makefile", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/57a5f92bef4b459005920f1aeff05a52c7e356b0/src%2Ftest%2Frun-make-fulldeps%2Finvalid-library%2FMakefile", "raw_url": "https://github.com/rust-lang/rust/raw/57a5f92bef4b459005920f1aeff05a52c7e356b0/src%2Ftest%2Frun-make-fulldeps%2Finvalid-library%2FMakefile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make-fulldeps%2Finvalid-library%2FMakefile?ref=57a5f92bef4b459005920f1aeff05a52c7e356b0", "patch": "@@ -1,6 +1,6 @@\n -include ../tools.mk\n \n all:\n-\ttouch $(TMPDIR)/rust.metadata.bin\n-\t$(AR) crus $(TMPDIR)/libfoo-ffffffff-1.0.rlib $(TMPDIR)/rust.metadata.bin\n+\ttouch $(TMPDIR)/lib.rmeta\n+\t$(AR) crus $(TMPDIR)/libfoo-ffffffff-1.0.rlib $(TMPDIR)/lib.rmeta\n \t$(RUSTC) foo.rs 2>&1 | $(CGREP) \"can't find crate for\""}]}