{"sha": "619d19c3181e4793de789302d60a0343f0081139", "node_id": "MDY6Q29tbWl0NzI0NzEyOjYxOWQxOWMzMTgxZTQ3OTNkZTc4OTMwMmQ2MGEwMzQzZjAwODExMzk=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-04-08T23:09:06Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-04-08T23:09:06Z"}, "message": "Auto merge of #83941 - wesleywiser:win_dbginfo_closures, r=nagisa\n\nImprove debuginfo for closures and async functions on Windows MSVC\n\nThe issue was that the resulting debuginfo was too complex for LLVM to\ntranslate into CodeView records correctly. As a result, it simply\nignored the debuginfo which meant Windows debuggers could not display\nany closed over variables when stepping inside a closure or async fn.\n\nThis fixes that by creating additional allocas on the stack so that\nthe resulting debuginfo is simple (just `*my_variable.dbg.spill`) and\nLLVM can generate the correct CV records.\n\nI also updated some of our existing tests to run in CDB to cover this case.\n\nBefore (closure):\n\n![image](https://user-images.githubusercontent.com/831192/113756857-e6dc4200-96df-11eb-8d6d-b7ed7a84aad5.png)\n\nAfter (closure):\n\n![image](https://user-images.githubusercontent.com/831192/113757067-2e62ce00-96e0-11eb-89f7-7dc8ab89b1b8.png)\n\nBefore (async):\n\n![image](https://user-images.githubusercontent.com/831192/114077916-4e2bfa80-9876-11eb-9f15-e302d1faa652.png)\n\nAfter (async):\n\n![image](https://user-images.githubusercontent.com/831192/114077677-0d33e600-9876-11eb-8ce3-cac20a9ea94a.png)\n\nFixes #83709", "tree": {"sha": "1847b21594093408df688dab8de6c79f6e2c2bb1", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1847b21594093408df688dab8de6c79f6e2c2bb1"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/619d19c3181e4793de789302d60a0343f0081139", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/619d19c3181e4793de789302d60a0343f0081139", "html_url": "https://github.com/rust-lang/rust/commit/619d19c3181e4793de789302d60a0343f0081139", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/619d19c3181e4793de789302d60a0343f0081139/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2e495d2e845cf27740e3665f718acfd3aa17253e", "url": "https://api.github.com/repos/rust-lang/rust/commits/2e495d2e845cf27740e3665f718acfd3aa17253e", "html_url": "https://github.com/rust-lang/rust/commit/2e495d2e845cf27740e3665f718acfd3aa17253e"}, {"sha": "533002d3a1f7f95f167323174205b57564b576a6", "url": "https://api.github.com/repos/rust-lang/rust/commits/533002d3a1f7f95f167323174205b57564b576a6", "html_url": "https://github.com/rust-lang/rust/commit/533002d3a1f7f95f167323174205b57564b576a6"}], "stats": {"total": 157, "additions": 142, "deletions": 15}, "files": [{"sha": "6bb20545f07bea36fed1ea8a0092aa0ef2c4d327", "filename": "compiler/rustc_codegen_ssa/src/mir/debuginfo.rs", "status": "modified", "additions": 39, "deletions": 15, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/619d19c3181e4793de789302d60a0343f0081139/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fdebuginfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/619d19c3181e4793de789302d60a0343f0081139/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fdebuginfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fdebuginfo.rs?ref=619d19c3181e4793de789302d60a0343f0081139", "patch": "@@ -6,7 +6,7 @@ use rustc_middle::ty;\n use rustc_session::config::DebugInfo;\n use rustc_span::symbol::{kw, Symbol};\n use rustc_span::{BytePos, Span};\n-use rustc_target::abi::{LayoutOf, Size};\n+use rustc_target::abi::Size;\n \n use super::operand::{OperandRef, OperandValue};\n use super::place::PlaceRef;\n@@ -265,33 +265,25 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n                 None => continue,\n             };\n \n-            let mut layout = base.layout;\n             let mut direct_offset = Size::ZERO;\n             // FIXME(eddyb) use smallvec here.\n             let mut indirect_offsets = vec![];\n+            let mut place = base;\n \n             for elem in &var.projection[..] {\n                 match *elem {\n                     mir::ProjectionElem::Deref => {\n                         indirect_offsets.push(Size::ZERO);\n-                        layout = bx.cx().layout_of(\n-                            layout\n-                                .ty\n-                                .builtin_deref(true)\n-                                .unwrap_or_else(|| {\n-                                    span_bug!(var.source_info.span, \"cannot deref `{}`\", layout.ty)\n-                                })\n-                                .ty,\n-                        );\n+                        place = place.project_deref(bx);\n                     }\n                     mir::ProjectionElem::Field(field, _) => {\n                         let i = field.index();\n                         let offset = indirect_offsets.last_mut().unwrap_or(&mut direct_offset);\n-                        *offset += layout.fields.offset(i);\n-                        layout = layout.field(bx.cx(), i);\n+                        *offset += place.layout.fields.offset(i);\n+                        place = place.project_field(bx, i);\n                     }\n                     mir::ProjectionElem::Downcast(_, variant) => {\n-                        layout = layout.for_variant(bx.cx(), variant);\n+                        place = place.project_downcast(bx, variant);\n                     }\n                     _ => span_bug!(\n                         var.source_info.span,\n@@ -301,7 +293,39 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n                 }\n             }\n \n-            bx.dbg_var_addr(dbg_var, dbg_loc, base.llval, direct_offset, &indirect_offsets);\n+            // When targeting MSVC, create extra allocas for arguments instead of pointing multiple\n+            // dbg_var_addr() calls into the same alloca with offsets. MSVC uses CodeView records\n+            // not DWARF and LLVM doesn't support translating the resulting\n+            // [DW_OP_deref, DW_OP_plus_uconst, offset, DW_OP_deref] debug info to CodeView.\n+            // Creating extra allocas on the stack makes the resulting debug info simple enough\n+            // that LLVM can generate correct CodeView records and thus the values appear in the\n+            // debugger. (#83709)\n+            let should_create_individual_allocas = bx.cx().sess().target.is_like_msvc\n+                && self.mir.local_kind(local) == mir::LocalKind::Arg\n+                // LLVM can handle simple things but anything more complex than just a direct\n+                // offset or one indirect offset of 0 is too complex for it to generate CV records\n+                // correctly.\n+                && (direct_offset != Size::ZERO\n+                    || !matches!(&indirect_offsets[..], [Size::ZERO] | []));\n+\n+            if should_create_individual_allocas {\n+                // Create a variable which will be a pointer to the actual value\n+                let ptr_ty = bx.tcx().mk_ty(ty::RawPtr(ty::TypeAndMut {\n+                    mutbl: mir::Mutability::Mut,\n+                    ty: place.layout.ty,\n+                }));\n+                let ptr_layout = bx.layout_of(ptr_ty);\n+                let alloca = PlaceRef::alloca(bx, ptr_layout);\n+                bx.set_var_name(alloca.llval, &(var.name.to_string() + \".dbg.spill\"));\n+\n+                // Write the pointer to the variable\n+                bx.store(place.llval, alloca.llval, alloca.align);\n+\n+                // Point the debug info to `*alloca` for the current variable\n+                bx.dbg_var_addr(dbg_var, dbg_loc, alloca.llval, Size::ZERO, &[Size::ZERO]);\n+            } else {\n+                bx.dbg_var_addr(dbg_var, dbg_loc, base.llval, direct_offset, &indirect_offsets);\n+            }\n         }\n     }\n "}, {"sha": "a9e7ebf6d43f72f178551e95592679bd8f683a0a", "filename": "compiler/rustc_codegen_ssa/src/mir/place.rs", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/619d19c3181e4793de789302d60a0343f0081139/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fplace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/619d19c3181e4793de789302d60a0343f0081139/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fplace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fplace.rs?ref=619d19c3181e4793de789302d60a0343f0081139", "patch": "@@ -402,6 +402,18 @@ impl<'a, 'tcx, V: CodegenObject> PlaceRef<'tcx, V> {\n         downcast\n     }\n \n+    pub fn project_deref<Bx: BuilderMethods<'a, 'tcx, Value = V>>(&self, bx: &mut Bx) -> Self {\n+        let target_ty = self.layout.ty.builtin_deref(true).expect(\"failed to deref\");\n+        let layout = bx.layout_of(target_ty.ty);\n+\n+        PlaceRef {\n+            llval: bx.load(self.llval, self.align),\n+            llextra: None,\n+            layout,\n+            align: layout.align.abi,\n+        }\n+    }\n+\n     pub fn storage_live<Bx: BuilderMethods<'a, 'tcx, Value = V>>(&self, bx: &mut Bx) {\n         bx.lifetime_start(self.llval, self.layout.size);\n     }"}, {"sha": "695cdc4f41fa30f53361bebd46fc9bc46dd95a8b", "filename": "src/test/debuginfo/var-captured-in-nested-closure.rs", "status": "modified", "additions": 49, "deletions": 0, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/619d19c3181e4793de789302d60a0343f0081139/src%2Ftest%2Fdebuginfo%2Fvar-captured-in-nested-closure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/619d19c3181e4793de789302d60a0343f0081139/src%2Ftest%2Fdebuginfo%2Fvar-captured-in-nested-closure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebuginfo%2Fvar-captured-in-nested-closure.rs?ref=619d19c3181e4793de789302d60a0343f0081139", "patch": "@@ -83,6 +83,55 @@\n // lldbr-check:(isize) closure_local = 8\n // lldb-command:continue\n \n+\n+// === CDB TESTS ===================================================================================\n+\n+// cdb-command: g\n+\n+// cdb-command: dx variable\n+// cdb-check:variable         : 1 [Type: [...]]\n+// cdb-command: dx constant\n+// cdb-check:constant         : 2 [Type: [...]]\n+// cdb-command: dx a_struct\n+// cdb-check:a_struct         [Type: var_captured_in_nested_closure::Struct]\n+// cdb-check:    [+0x[...]] a                : -3 [Type: [...]]\n+// cdb-check:    [+0x[...]] b                : 4.500000 [Type: [...]]\n+// cdb-check:    [+0x[...]] c                : 0x5 [Type: unsigned [...]]\n+// cdb-command: dx struct_ref\n+// cdb-check:struct_ref       : 0x[...] [Type: var_captured_in_nested_closure::Struct *]\n+// cdb-check:    [+0x[...]] a                : -3 [Type: [...]]\n+// cdb-check:    [+0x[...]] b                : 4.500000 [Type: [...]]\n+// cdb-check:    [+0x[...]] c                : 0x5 [Type: unsigned [...]]\n+// cdb-command: dx owned\n+// cdb-check:owned            : 0x[...] : 6 [Type: [...] *]\n+// cdb-check:    6 [Type: [...]]\n+// cdb-command: dx closure_local\n+// cdb-check:closure_local    : 8 [Type: [...]]\n+// cdb-command: dx nested_closure\n+// cdb-check:nested_closure   [Type: var_captured_in_nested_closure::main::{{closure}}::closure-0]\n+\n+// cdb-command: g\n+\n+// cdb-command: dx variable\n+// cdb-check:variable         : 1 [Type: [...]]\n+// cdb-command: dx constant\n+// cdb-check:constant         : 2 [Type: [...]]\n+// cdb-command: dx a_struct\n+// cdb-check:a_struct         [Type: var_captured_in_nested_closure::Struct]\n+// cdb-check:    [+0x[...]] a                : -3 [Type: [...]]\n+// cdb-check:    [+0x[...]] b                : 4.500000 [Type: [...]]\n+// cdb-check:    [+0x[...]] c                : 0x5 [Type: unsigned [...]]\n+// cdb-command: dx struct_ref\n+// cdb-check:struct_ref       : 0x[...] [Type: var_captured_in_nested_closure::Struct *]\n+// cdb-check:    [+0x[...]] a                : -3 [Type: [...]]\n+// cdb-check:    [+0x[...]] b                : 4.500000 [Type: [...]]\n+// cdb-check:    [+0x[...]] c                : 0x5 [Type: unsigned [...]]\n+// cdb-command: dx owned\n+// cdb-check:owned            : 0x[...] : 6 [Type: [...] *]\n+// cdb-check:    6 [Type: [...]]\n+// cdb-command: dx closure_local\n+// cdb-check:closure_local    : 8 [Type: [...]]\n+\n #![allow(unused_variables)]\n #![feature(box_syntax)]\n #![feature(omit_gdb_pretty_printer_section)]"}, {"sha": "1bbb79c37a4e70a58e93a782484c59246eff4064", "filename": "src/test/debuginfo/var-captured-in-stack-closure.rs", "status": "modified", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/619d19c3181e4793de789302d60a0343f0081139/src%2Ftest%2Fdebuginfo%2Fvar-captured-in-stack-closure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/619d19c3181e4793de789302d60a0343f0081139/src%2Ftest%2Fdebuginfo%2Fvar-captured-in-stack-closure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebuginfo%2Fvar-captured-in-stack-closure.rs?ref=619d19c3181e4793de789302d60a0343f0081139", "patch": "@@ -73,6 +73,48 @@\n // lldbg-check:[...]$9 = 6\n // lldbr-check:(isize) *owned = 6\n \n+\n+// === CDB TESTS ===================================================================================\n+\n+// cdb-command: g\n+\n+// cdb-command: dx variable\n+// cdb-check:variable         : 1 [Type: [...]]\n+// cdb-command: dx constant\n+// cdb-check:constant         : 2 [Type: [...]]\n+// cdb-command: dx a_struct\n+// cdb-check:a_struct         [Type: var_captured_in_stack_closure::Struct]\n+// cdb-check:    [+0x[...]] a                : -3 [Type: [...]]\n+// cdb-check:    [+0x[...]] b                : 4.500000 [Type: [...]]\n+// cdb-check:    [+0x[...]] c                : 0x5 [Type: unsigned [...]]\n+// cdb-command: dx struct_ref\n+// cdb-check:struct_ref       : 0x[...] [Type: var_captured_in_stack_closure::Struct *]\n+// cdb-check:    [+0x[...]] a                : -3 [Type: [...]]\n+// cdb-check:    [+0x[...]] b                : 4.500000 [Type: [...]]\n+// cdb-check:    [+0x[...]] c                : 0x5 [Type: unsigned [...]]\n+// cdb-command: dx owned\n+// cdb-check:owned            : 0x[...] : 6 [Type: [...] *]\n+\n+\n+// cdb-command: g\n+\n+// cdb-command: dx variable\n+// cdb-check:variable         : 2 [Type: [...]]\n+// cdb-command: dx constant\n+// cdb-check:constant         : 2 [Type: [...]]\n+// cdb-command: dx a_struct\n+// cdb-check:a_struct         [Type: var_captured_in_stack_closure::Struct]\n+// cdb-check:    [+0x[...]] a                : -3 [Type: [...]]\n+// cdb-check:    [+0x[...]] b                : 4.500000 [Type: [...]]\n+// cdb-check:    [+0x[...]] c                : 0x5 [Type: unsigned [...]]\n+// cdb-command: dx struct_ref\n+// cdb-check:struct_ref       : 0x[...] [Type: var_captured_in_stack_closure::Struct *]\n+// cdb-check:    [+0x[...]] a                : -3 [Type: [...]]\n+// cdb-check:    [+0x[...]] b                : 4.500000 [Type: [...]]\n+// cdb-check:    [+0x[...]] c                : 0x5 [Type: unsigned [...]]\n+// cdb-command: dx owned\n+// cdb-check:owned            : 0x[...] : 6 [Type: [...] *]\n+\n #![feature(box_syntax)]\n #![allow(unused_variables)]\n #![feature(omit_gdb_pretty_printer_section)]"}]}