{"sha": "551d921de0f13c54093ab4f6a3adbe69292e091a", "node_id": "C_kwDOAAsO6NoAKDU1MWQ5MjFkZTBmMTNjNTQwOTNhYjRmNmEzYWRiZTY5MjkyZTA5MWE", "commit": {"author": {"name": "Jan Behrens", "email": "jbe@magnetkern.de", "date": "2022-07-19T09:40:40Z"}, "committer": {"name": "Jan Behrens", "email": "jbe@magnetkern.de", "date": "2022-07-19T09:40:40Z"}, "message": "docs: Improve AsRef / AsMut docs on blanket impls\n\n- Explicitly mention that `AsRef` and `AsMut` do not auto-dereference\n  generally for all dereferencable types (but only if inner type is a\n  shared and/or mutable reference)\n- Give advice to not use `AsRef` or `AsMut` for the sole purpose of\n  dereferencing\n- Suggest providing a transitive `AsRef` or `AsMut` implementation for\n  types which implement `Deref`\n- Add new section \"Reflexivity\" in documentation comments for `AsRef`\n  and `AsMut`\n- Provide better example for `AsMut`\n- Added heading \"Relation to `Borrow`\" in `AsRef`'s docs to improve\n  structure\n\nIssue #45742 and a corresponding FIXME in the libcore suggest that\n`AsRef` and `AsMut` should provide a blanket implementation over\n`Deref`. As that is difficult to realize at the moment, this commit\nupdates the documentation to better describe the status-quo and to give\nadvice on how to use `AsRef` and `AsMut`.", "tree": {"sha": "029a334c4a5c19ce8c5a294b790259f5d65d6c39", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/029a334c4a5c19ce8c5a294b790259f5d65d6c39"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/551d921de0f13c54093ab4f6a3adbe69292e091a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/551d921de0f13c54093ab4f6a3adbe69292e091a", "html_url": "https://github.com/rust-lang/rust/commit/551d921de0f13c54093ab4f6a3adbe69292e091a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/551d921de0f13c54093ab4f6a3adbe69292e091a/comments", "author": {"login": "JanBeh", "id": 76393822, "node_id": "MDQ6VXNlcjc2MzkzODIy", "avatar_url": "https://avatars.githubusercontent.com/u/76393822?v=4", "gravatar_id": "", "url": "https://api.github.com/users/JanBeh", "html_url": "https://github.com/JanBeh", "followers_url": "https://api.github.com/users/JanBeh/followers", "following_url": "https://api.github.com/users/JanBeh/following{/other_user}", "gists_url": "https://api.github.com/users/JanBeh/gists{/gist_id}", "starred_url": "https://api.github.com/users/JanBeh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/JanBeh/subscriptions", "organizations_url": "https://api.github.com/users/JanBeh/orgs", "repos_url": "https://api.github.com/users/JanBeh/repos", "events_url": "https://api.github.com/users/JanBeh/events{/privacy}", "received_events_url": "https://api.github.com/users/JanBeh/received_events", "type": "User", "site_admin": false}, "committer": {"login": "JanBeh", "id": 76393822, "node_id": "MDQ6VXNlcjc2MzkzODIy", "avatar_url": "https://avatars.githubusercontent.com/u/76393822?v=4", "gravatar_id": "", "url": "https://api.github.com/users/JanBeh", "html_url": "https://github.com/JanBeh", "followers_url": "https://api.github.com/users/JanBeh/followers", "following_url": "https://api.github.com/users/JanBeh/following{/other_user}", "gists_url": "https://api.github.com/users/JanBeh/gists{/gist_id}", "starred_url": "https://api.github.com/users/JanBeh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/JanBeh/subscriptions", "organizations_url": "https://api.github.com/users/JanBeh/orgs", "repos_url": "https://api.github.com/users/JanBeh/repos", "events_url": "https://api.github.com/users/JanBeh/events{/privacy}", "received_events_url": "https://api.github.com/users/JanBeh/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c3f35504d15e80b4727872c17c8c2f4bbaee58cf", "url": "https://api.github.com/repos/rust-lang/rust/commits/c3f35504d15e80b4727872c17c8c2f4bbaee58cf", "html_url": "https://github.com/rust-lang/rust/commit/c3f35504d15e80b4727872c17c8c2f4bbaee58cf"}], "stats": {"total": 177, "additions": 159, "deletions": 18}, "files": [{"sha": "dd0d6478c3a209fc0686c73814031d1cea188595", "filename": "library/core/src/convert/mod.rs", "status": "modified", "additions": 159, "deletions": 18, "changes": 177, "blob_url": "https://github.com/rust-lang/rust/blob/551d921de0f13c54093ab4f6a3adbe69292e091a/library%2Fcore%2Fsrc%2Fconvert%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/551d921de0f13c54093ab4f6a3adbe69292e091a/library%2Fcore%2Fsrc%2Fconvert%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fconvert%2Fmod.rs?ref=551d921de0f13c54093ab4f6a3adbe69292e091a", "patch": "@@ -25,6 +25,7 @@\n //! # Generic Implementations\n //!\n //! - [`AsRef`] and [`AsMut`] auto-dereference if the inner type is a reference\n+//!   (but not generally for all [dereferenceable types][core::ops::Deref])\n //! - [`From`]`<U> for T` implies [`Into`]`<T> for U`\n //! - [`TryFrom`]`<U> for T` implies [`TryInto`]`<T> for U`\n //! - [`From`] and [`Into`] are reflexive, which means that all types can\n@@ -108,10 +109,12 @@ pub const fn identity<T>(x: T) -> T {\n /// If you need to do a costly conversion it is better to implement [`From`] with type\n /// `&T` or write a custom function.\n ///\n+/// # Relation to `Borrow`\n+///\n /// `AsRef` has the same signature as [`Borrow`], but [`Borrow`] is different in a few aspects:\n ///\n /// - Unlike `AsRef`, [`Borrow`] has a blanket impl for any `T`, and can be used to accept either\n-///   a reference or a value.\n+///   a reference or a value. (See also note on `AsRef`'s reflexibility below.)\n /// - [`Borrow`] also requires that [`Hash`], [`Eq`] and [`Ord`] for a borrowed value are\n ///   equivalent to those of the owned value. For this reason, if you want to\n ///   borrow only a single field of a struct you can implement `AsRef`, but not [`Borrow`].\n@@ -121,9 +124,55 @@ pub const fn identity<T>(x: T) -> T {\n ///\n /// # Generic Implementations\n ///\n-/// - `AsRef` auto-dereferences if the inner type is a reference or a mutable\n-///   reference (e.g.: `foo.as_ref()` will work the same if `foo` has type\n-///   `&mut Foo` or `&&mut Foo`)\n+/// `AsRef` auto-dereferences if the inner type is a reference or a mutable reference\n+/// (e.g.: `foo.as_ref()` will work the same if `foo` has type `&mut Foo` or `&&mut Foo`).\n+///\n+/// Note that due to historic reasons, the above currently does not hold generally for all\n+/// [dereferenceable types], e.g. `foo.as_ref()` will *not* work the same as\n+/// `Box::new(foo).as_ref()`. Instead, many smart pointers provide an `as_ref` implementation which\n+/// simply returns a reference to the [pointed-to value] (but do not perform a cheap\n+/// reference-to-reference conversion for that value). However, [`AsRef::as_ref`] should not be\n+/// used for the sole purpose of dereferencing; instead ['`Deref` coercion'] can be used:\n+///\n+/// [dereferenceable types]: core::ops::Deref\n+/// [pointed-to value]: core::ops::Deref::Target\n+/// ['`Deref` coercion']: core::ops::Deref#more-on-deref-coercion\n+///\n+/// ```\n+/// let x = Box::new(5i32);\n+/// // Avoid this:\n+/// // let y: &i32 = x.as_ref();\n+/// // Better just write:\n+/// let y: &i32 = &x;\n+/// ```\n+///\n+/// Types which implement [`Deref`][core::ops::Deref] should consider implementing `AsRef` as\n+/// follows:\n+///\n+/// ```\n+/// impl<T> AsRef<T> for SomeType\n+/// where\n+///     T: ?Sized,\n+///     <SomeType as Deref>::Target: AsRef<T>,\n+/// {\n+///     fn as_ref(&self) -> &T {\n+///         self.deref().as_ref()\n+///     }\n+/// }\n+/// ```\n+///\n+/// # Reflexivity\n+///\n+/// Ideally, `AsRef` would be reflexive, that is there is an `impl<T: ?Sized> AsRef<T> for T`, with\n+/// [`as_ref`][AsRef::as_ref] simply returning its argument unchanged.\n+/// Such a blanket implementation is currently *not* provided due to technical restrictions of\n+/// Rust's type system (it would be overlapping with another existing blanket implementation for\n+/// `&T where T: AsRef<U>` which allows `AsRef` to auto-dereference, see \"Generic Implementations\"\n+/// above).\n+///\n+/// A trivial implementation of `AsRef<T> for T` must be added explicitly for a particular type `T`\n+/// where needed or desired. Note, however, that not all types from `std` contain such an\n+/// implementation, and those cannot be added by external code due to orphan rules.\n ///\n /// # Examples\n ///\n@@ -170,29 +219,121 @@ pub trait AsRef<T: ?Sized> {\n ///\n /// # Generic Implementations\n ///\n-/// - `AsMut` auto-dereferences if the inner type is a mutable reference\n-///   (e.g.: `foo.as_mut()` will work the same if `foo` has type `&mut Foo`\n-///   or `&mut &mut Foo`)\n+/// `AsMut` auto-dereferences if the inner type is a mutable reference\n+/// (e.g.: `foo.as_mut()` will work the same if `foo` has type `&mut Foo` or `&mut &mut Foo`).\n+///\n+/// Note that due to historic reasons, the above currently does not hold generally for all\n+/// [mutably dereferenceable types], e.g. `foo.as_mut()` will *not* work the same as\n+/// `Box::new(foo).as_mut()`. Instead, many smart pointers provide an `as_mut` implementation which\n+/// simply returns a reference to the [pointed-to value] (but do not perform a cheap\n+/// reference-to-reference conversion for that value). However, [`AsMut::as_mut`] should not be\n+/// used for the sole purpose of mutable dereferencing; instead ['`Deref` coercion'] can be used:\n+///\n+/// [mutably dereferenceable types]: core::ops::DerefMut\n+/// [pointed-to value]: core::ops::Deref::Target\n+/// ['`Deref` coercion']: core::ops::DerefMut#more-on-deref-coercion\n+///\n+/// ```\n+/// let mut x = Box::new(5i32);\n+/// // Avoid this:\n+/// // let y: &mut i32 = x.as_mut();\n+/// // Better just write:\n+/// let y: &mut i32 = &mut x;\n+/// ```\n+///\n+/// Types which implement [`DerefMut`](core::ops::DerefMut) should consider to add an\n+/// implementation of `AsMut` as follows:\n+///\n+/// ```\n+/// impl<T> AsMut<T> for SomeType\n+/// where\n+///     <SomeType as Deref>::Target: AsMut<T>,\n+/// {\n+///     fn as_mut(&mut self) -> &mut T {\n+///         self.deref_mut().as_mut()\n+///     }\n+/// }\n+/// ```\n+///\n+/// # Reflexivity\n+///\n+/// Ideally, `AsMut` would be reflexive, that is there is an `impl<T: ?Sized> AsMut<T> for T`, with\n+/// [`as_mut`][AsMut::as_mut] simply returning its argument unchanged.\n+/// Such a blanket implementation is currently *not* provided due to technical restrictions of\n+/// Rust's type system (it would be overlapping with another existing blanket implementation for\n+/// `&mut T where T: AsMut<U>` which allows `AsMut` to auto-dereference, see \"Generic\n+/// Implementations\" above).\n+///\n+/// A trivial implementation of `AsMut<T> for T` must be added explicitly for a particular type `T`\n+/// where needed or desired. Note, however, that not all types from `std` contain such an\n+/// implementation, and those cannot be added by external code due to orphan rules.\n ///\n /// # Examples\n ///\n-/// Using `AsMut` as trait bound for a generic function we can accept all mutable references\n-/// that can be converted to type `&mut T`. Because [`Box<T>`] implements `AsMut<T>` we can\n-/// write a function `add_one` that takes all arguments that can be converted to `&mut u64`.\n-/// Because [`Box<T>`] implements `AsMut<T>`, `add_one` accepts arguments of type\n-/// `&mut Box<u64>` as well:\n+/// Using `AsMut` as trait bound for a generic function, we can accept all mutable references that\n+/// can be converted to type `&mut T`. Unlike [dereference], which has a single [target type],\n+/// there can be multiple implementations of `AsMut` for a type. In particular, `Vec<T>` implements\n+/// both `AsMut<Vec<T>>` and `AsMut<[T]>`.\n+///\n+/// In the following, the example functions `caesar` and `null_terminate` provide a generic\n+/// interface which work with any type that can be converted by cheap mutable-to-mutable conversion\n+/// into a byte slice or byte `Vec`, respectively.\n+///\n+/// [dereference]: core::ops::DerefMut\n+/// [target type]: core::ops::Deref::Target\n ///\n /// ```\n-/// fn add_one<T: AsMut<u64>>(num: &mut T) {\n-///     *num.as_mut() += 1;\n+/// struct Document {\n+///     info: String,\n+///     content: Vec<u8>,\n /// }\n ///\n-/// let mut boxed_num = Box::new(0);\n-/// add_one(&mut boxed_num);\n-/// assert_eq!(*boxed_num, 1);\n+/// impl<T: ?Sized> AsMut<T> for Document\n+/// where\n+///     Vec<u8>: AsMut<T>,\n+/// {\n+///     fn as_mut(&mut self) -> &mut T {\n+///         self.content.as_mut()\n+///     }\n+/// }\n+///\n+/// fn caesar<T: AsMut<[u8]>>(data: &mut T, key: u8) {\n+///     for byte in data.as_mut() {\n+///         *byte = byte.wrapping_add(key);\n+///     }\n+/// }\n+///\n+/// fn null_terminate<T: AsMut<Vec<u8>>>(data: &mut T) {\n+///     // Using a non-generic inner function, which contains most of the\n+///     // functionality, helps to minimize monomorphization overhead.\n+///     fn doit(data: &mut Vec<u8>) {\n+///         let len = data.len();\n+///         if len == 0 || data[len-1] != 0 {\n+///             data.push(0);\n+///         }\n+///     }\n+///     doit(data.as_mut());\n+/// }\n+///\n+/// fn main() {\n+///     let mut v: Vec<u8> = vec![1, 2, 3];\n+///     caesar(&mut v, 5);\n+///     assert_eq!(v, [6, 7, 8]);\n+///     null_terminate(&mut v);\n+///     assert_eq!(v, [6, 7, 8, 0]);\n+///     let mut doc = Document {\n+///         info: String::from(\"Example\"),\n+///         content: vec![17, 19, 8],\n+///     };\n+///     caesar(&mut doc, 1);\n+///     assert_eq!(doc.content, [18, 20, 9]);\n+///     null_terminate(&mut doc);\n+///     assert_eq!(doc.content, [18, 20, 9, 0]);\n+/// }\n /// ```\n ///\n-/// [`Box<T>`]: ../../std/boxed/struct.Box.html\n+/// Note, however, that APIs don't need to be generic. In many cases taking a `&mut [u8]` or\n+/// `&mut Vec<u8>`, for example, is the better choice (callers need to pass the correct type then).\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[cfg_attr(not(test), rustc_diagnostic_item = \"AsMut\")]\n pub trait AsMut<T: ?Sized> {"}]}