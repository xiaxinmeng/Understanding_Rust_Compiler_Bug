{"sha": "16e620c052016010b2f17070a98bdc1e7e849ab3", "node_id": "MDY6Q29tbWl0NzI0NzEyOjE2ZTYyMGMwNTIwMTYwMTBiMmYxNzA3MGE5OGJkYzFlN2U4NDlhYjM=", "commit": {"author": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2019-10-30T13:12:55Z"}, "committer": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2019-10-30T14:43:11Z"}, "message": "move raw_items to hir_def", "tree": {"sha": "a00ec9181595cea9e340da3ead490348ff7b1666", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a00ec9181595cea9e340da3ead490348ff7b1666"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/16e620c052016010b2f17070a98bdc1e7e849ab3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/16e620c052016010b2f17070a98bdc1e7e849ab3", "html_url": "https://github.com/rust-lang/rust/commit/16e620c052016010b2f17070a98bdc1e7e849ab3", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/16e620c052016010b2f17070a98bdc1e7e849ab3/comments", "author": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "committer": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f996b6019bd2f388bd9994ea83f25487eb111560", "url": "https://api.github.com/repos/rust-lang/rust/commits/f996b6019bd2f388bd9994ea83f25487eb111560", "html_url": "https://github.com/rust-lang/rust/commit/f996b6019bd2f388bd9994ea83f25487eb111560"}], "stats": {"total": 2057, "additions": 1059, "deletions": 998}, "files": [{"sha": "fdacd82a70e36ac564e7322f74198de98850dd76", "filename": "Cargo.lock", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/16e620c052016010b2f17070a98bdc1e7e849ab3/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/16e620c052016010b2f17070a98bdc1e7e849ab3/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=16e620c052016010b2f17070a98bdc1e7e849ab3", "patch": "@@ -1019,11 +1019,18 @@ name = \"ra_hir_def\"\n version = \"0.1.0\"\n dependencies = [\n  \"log 0.4.8 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"once_cell 1.2.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"ra_arena 0.1.0\",\n+ \"ra_cfg 0.1.0\",\n  \"ra_db 0.1.0\",\n  \"ra_hir_expand 0.1.0\",\n+ \"ra_mbe 0.1.0\",\n  \"ra_prof 0.1.0\",\n  \"ra_syntax 0.1.0\",\n+ \"ra_tt 0.1.0\",\n+ \"relative-path 1.0.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"rustc-hash 1.0.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"test_utils 0.1.0\",\n ]\n \n [[package]]"}, {"sha": "988a671b81b2f0793411c5b52bbc88ef32c7f2ee", "filename": "crates/ra_hir/src/attr.rs", "status": "modified", "additions": 1, "deletions": 90, "changes": 91, "blob_url": "https://github.com/rust-lang/rust/blob/16e620c052016010b2f17070a98bdc1e7e849ab3/crates%2Fra_hir%2Fsrc%2Fattr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16e620c052016010b2f17070a98bdc1e7e849ab3/crates%2Fra_hir%2Fsrc%2Fattr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fattr.rs?ref=16e620c052016010b2f17070a98bdc1e7e849ab3", "patch": "@@ -1,90 +1 @@\n-//! A higher level attributes based on TokenTree, with also some shortcuts.\n-\n-use std::sync::Arc;\n-\n-use mbe::ast_to_token_tree;\n-use ra_cfg::CfgOptions;\n-use ra_syntax::{\n-    ast::{self, AstNode, AttrsOwner},\n-    SmolStr,\n-};\n-use tt::Subtree;\n-\n-use crate::{db::AstDatabase, path::Path, HirFileId, Source};\n-\n-#[derive(Debug, Clone, PartialEq, Eq)]\n-pub(crate) struct Attr {\n-    pub(crate) path: Path,\n-    pub(crate) input: Option<AttrInput>,\n-}\n-\n-#[derive(Debug, Clone, PartialEq, Eq)]\n-pub enum AttrInput {\n-    Literal(SmolStr),\n-    TokenTree(Subtree),\n-}\n-\n-impl Attr {\n-    pub(crate) fn from_src(\n-        Source { file_id, ast }: Source<ast::Attr>,\n-        db: &impl AstDatabase,\n-    ) -> Option<Attr> {\n-        let path = Path::from_src(Source { file_id, ast: ast.path()? }, db)?;\n-        let input = match ast.input() {\n-            None => None,\n-            Some(ast::AttrInput::Literal(lit)) => {\n-                // FIXME: escape? raw string?\n-                let value = lit.syntax().first_token()?.text().trim_matches('\"').into();\n-                Some(AttrInput::Literal(value))\n-            }\n-            Some(ast::AttrInput::TokenTree(tt)) => {\n-                Some(AttrInput::TokenTree(ast_to_token_tree(&tt)?.0))\n-            }\n-        };\n-\n-        Some(Attr { path, input })\n-    }\n-\n-    pub(crate) fn from_attrs_owner(\n-        file_id: HirFileId,\n-        owner: &dyn AttrsOwner,\n-        db: &impl AstDatabase,\n-    ) -> Option<Arc<[Attr]>> {\n-        let mut attrs = owner.attrs().peekable();\n-        if attrs.peek().is_none() {\n-            // Avoid heap allocation\n-            return None;\n-        }\n-        Some(attrs.flat_map(|ast| Attr::from_src(Source { file_id, ast }, db)).collect())\n-    }\n-\n-    pub(crate) fn is_simple_atom(&self, name: &str) -> bool {\n-        // FIXME: Avoid cloning\n-        self.path.as_ident().map_or(false, |s| s.to_string() == name)\n-    }\n-\n-    // FIXME: handle cfg_attr :-)\n-    pub(crate) fn as_cfg(&self) -> Option<&Subtree> {\n-        if !self.is_simple_atom(\"cfg\") {\n-            return None;\n-        }\n-        match &self.input {\n-            Some(AttrInput::TokenTree(subtree)) => Some(subtree),\n-            _ => None,\n-        }\n-    }\n-\n-    pub(crate) fn as_path(&self) -> Option<&SmolStr> {\n-        if !self.is_simple_atom(\"path\") {\n-            return None;\n-        }\n-        match &self.input {\n-            Some(AttrInput::Literal(it)) => Some(it),\n-            _ => None,\n-        }\n-    }\n-\n-    pub(crate) fn is_cfg_enabled(&self, cfg_options: &CfgOptions) -> Option<bool> {\n-        cfg_options.is_cfg_enabled(self.as_cfg()?)\n-    }\n-}\n+pub use hir_def::attr::*;"}, {"sha": "de1377aa45ab67e29fbbe110f95643a15a0e9d54", "filename": "crates/ra_hir/src/code_model.rs", "status": "modified", "additions": 3, "deletions": 27, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/16e620c052016010b2f17070a98bdc1e7e849ab3/crates%2Fra_hir%2Fsrc%2Fcode_model.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16e620c052016010b2f17070a98bdc1e7e849ab3/crates%2Fra_hir%2Fsrc%2Fcode_model.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fcode_model.rs?ref=16e620c052016010b2f17070a98bdc1e7e849ab3", "patch": "@@ -6,7 +6,7 @@ pub(crate) mod docs;\n use std::sync::Arc;\n \n use hir_def::{CrateModuleId, ModuleId};\n-use ra_db::{CrateId, Edition, FileId};\n+use ra_db::{CrateId, Edition};\n use ra_syntax::ast::{self, NameOwner, TypeAscriptionOwner};\n \n use crate::{\n@@ -33,7 +33,7 @@ use crate::{\n     },\n     type_ref::Mutability,\n     type_ref::TypeRef,\n-    AsName, AstId, Either, HasSource, Name, Ty,\n+    AsName, Either, HasSource, Name, Ty,\n };\n \n /// hir::Crate describes a single crate. It's the main interface with which\n@@ -147,31 +147,7 @@ impl_froms!(\n     BuiltinType\n );\n \n-pub enum ModuleSource {\n-    SourceFile(ast::SourceFile),\n-    Module(ast::Module),\n-}\n-\n-impl ModuleSource {\n-    pub(crate) fn new(\n-        db: &(impl DefDatabase + AstDatabase),\n-        file_id: Option<FileId>,\n-        decl_id: Option<AstId<ast::Module>>,\n-    ) -> ModuleSource {\n-        match (file_id, decl_id) {\n-            (Some(file_id), _) => {\n-                let source_file = db.parse(file_id).tree();\n-                ModuleSource::SourceFile(source_file)\n-            }\n-            (None, Some(item_id)) => {\n-                let module = item_id.to_node(db);\n-                assert!(module.item_list().is_some(), \"expected inline module\");\n-                ModuleSource::Module(module)\n-            }\n-            (None, None) => panic!(),\n-        }\n-    }\n-}\n+pub use hir_def::ModuleSource;\n \n impl Module {\n     pub(crate) fn new(krate: Crate, crate_module_id: CrateModuleId) -> Module {"}, {"sha": "142d7338df8db56e3495f96a0fcfac6b6537a7e3", "filename": "crates/ra_hir/src/db.rs", "status": "modified", "additions": 4, "deletions": 13, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/16e620c052016010b2f17070a98bdc1e7e849ab3/crates%2Fra_hir%2Fsrc%2Fdb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16e620c052016010b2f17070a98bdc1e7e849ab3/crates%2Fra_hir%2Fsrc%2Fdb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fdb.rs?ref=16e620c052016010b2f17070a98bdc1e7e849ab3", "patch": "@@ -12,15 +12,15 @@ use crate::{\n     ids,\n     impl_block::{ImplBlock, ImplSourceMap, ModuleImplBlocks},\n     lang_item::{LangItemTarget, LangItems},\n-    nameres::{CrateDefMap, ImportSourceMap, Namespace, RawItems},\n+    nameres::{CrateDefMap, Namespace},\n     traits::TraitData,\n     ty::{\n         method_resolution::CrateImplBlocks, traits::Impl, CallableDef, FnSig, GenericPredicate,\n         InferenceResult, Substs, Ty, TypableDef, TypeCtor,\n     },\n     type_alias::TypeAliasData,\n-    Const, ConstData, Crate, DefWithBody, Enum, ExprScopes, FnData, Function, HirFileId, Module,\n-    Static, Struct, StructField, Trait, TypeAlias,\n+    Const, ConstData, Crate, DefWithBody, Enum, ExprScopes, FnData, Function, Module, Static,\n+    Struct, StructField, Trait, TypeAlias,\n };\n \n pub use hir_def::db::{InternDatabase, InternDatabaseStorage};\n@@ -32,7 +32,7 @@ pub use hir_expand::db::{\n // This database uses `AstDatabase` internally,\n #[salsa::query_group(DefDatabaseStorage)]\n #[salsa::requires(AstDatabase)]\n-pub trait DefDatabase: InternDatabase + HirDebugDatabase + AstDatabase {\n+pub trait DefDatabase: HirDebugDatabase + hir_def::db::DefDatabase2 {\n     #[salsa::invoke(crate::adt::StructData::struct_data_query)]\n     fn struct_data(&self, s: Struct) -> Arc<StructData>;\n \n@@ -45,15 +45,6 @@ pub trait DefDatabase: InternDatabase + HirDebugDatabase + AstDatabase {\n     #[salsa::invoke(crate::traits::TraitItemsIndex::trait_items_index)]\n     fn trait_items_index(&self, module: Module) -> crate::traits::TraitItemsIndex;\n \n-    #[salsa::invoke(RawItems::raw_items_with_source_map_query)]\n-    fn raw_items_with_source_map(\n-        &self,\n-        file_id: HirFileId,\n-    ) -> (Arc<RawItems>, Arc<ImportSourceMap>);\n-\n-    #[salsa::invoke(RawItems::raw_items_query)]\n-    fn raw_items(&self, file_id: HirFileId) -> Arc<RawItems>;\n-\n     #[salsa::invoke(CrateDefMap::crate_def_map_query)]\n     fn crate_def_map(&self, krate: Crate) -> Arc<CrateDefMap>;\n "}, {"sha": "44498dd388c4fbb605642dd459dd66c7468381b2", "filename": "crates/ra_hir/src/either.rs", "status": "modified", "additions": 1, "deletions": 54, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/16e620c052016010b2f17070a98bdc1e7e849ab3/crates%2Fra_hir%2Fsrc%2Feither.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16e620c052016010b2f17070a98bdc1e7e849ab3/crates%2Fra_hir%2Fsrc%2Feither.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Feither.rs?ref=16e620c052016010b2f17070a98bdc1e7e849ab3", "patch": "@@ -1,54 +1 @@\n-//! FIXME: write short doc here\n-\n-#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]\n-pub enum Either<A, B> {\n-    A(A),\n-    B(B),\n-}\n-\n-impl<A, B> Either<A, B> {\n-    pub fn either<R, F1, F2>(self, f1: F1, f2: F2) -> R\n-    where\n-        F1: FnOnce(A) -> R,\n-        F2: FnOnce(B) -> R,\n-    {\n-        match self {\n-            Either::A(a) => f1(a),\n-            Either::B(b) => f2(b),\n-        }\n-    }\n-    pub fn map<U, V, F1, F2>(self, f1: F1, f2: F2) -> Either<U, V>\n-    where\n-        F1: FnOnce(A) -> U,\n-        F2: FnOnce(B) -> V,\n-    {\n-        match self {\n-            Either::A(a) => Either::A(f1(a)),\n-            Either::B(b) => Either::B(f2(b)),\n-        }\n-    }\n-    pub fn map_a<U, F>(self, f: F) -> Either<U, B>\n-    where\n-        F: FnOnce(A) -> U,\n-    {\n-        self.map(f, |it| it)\n-    }\n-    pub fn a(self) -> Option<A> {\n-        match self {\n-            Either::A(it) => Some(it),\n-            Either::B(_) => None,\n-        }\n-    }\n-    pub fn b(self) -> Option<B> {\n-        match self {\n-            Either::A(_) => None,\n-            Either::B(it) => Some(it),\n-        }\n-    }\n-    pub fn as_ref(&self) -> Either<&A, &B> {\n-        match self {\n-            Either::A(it) => Either::A(it),\n-            Either::B(it) => Either::B(it),\n-        }\n-    }\n-}\n+pub use hir_def::either::*;"}, {"sha": "697c8dc8490f6a0eebc08eb183393895cb7e1235", "filename": "crates/ra_hir/src/from_source.rs", "status": "modified", "additions": 1, "deletions": 41, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/16e620c052016010b2f17070a98bdc1e7e849ab3/crates%2Fra_hir%2Fsrc%2Ffrom_source.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16e620c052016010b2f17070a98bdc1e7e849ab3/crates%2Fra_hir%2Fsrc%2Ffrom_source.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Ffrom_source.rs?ref=16e620c052016010b2f17070a98bdc1e7e849ab3", "patch": "@@ -1,11 +1,6 @@\n //! FIXME: write short doc here\n \n-use ra_db::{FileId, FilePosition};\n-use ra_syntax::{\n-    algo::find_node_at_offset,\n-    ast::{self, AstNode, NameOwner},\n-    SyntaxNode,\n-};\n+use ra_syntax::ast::{self, AstNode, NameOwner};\n \n use crate::{\n     db::{AstDatabase, DefDatabase, HirDatabase},\n@@ -129,41 +124,6 @@ impl FromSource for StructField {\n     }\n }\n \n-// FIXME: simplify it\n-impl ModuleSource {\n-    pub fn from_position(\n-        db: &(impl DefDatabase + AstDatabase),\n-        position: FilePosition,\n-    ) -> ModuleSource {\n-        let parse = db.parse(position.file_id);\n-        match &find_node_at_offset::<ast::Module>(parse.tree().syntax(), position.offset) {\n-            Some(m) if !m.has_semi() => ModuleSource::Module(m.clone()),\n-            _ => {\n-                let source_file = parse.tree();\n-                ModuleSource::SourceFile(source_file)\n-            }\n-        }\n-    }\n-\n-    pub fn from_child_node(\n-        db: &(impl DefDatabase + AstDatabase),\n-        file_id: FileId,\n-        child: &SyntaxNode,\n-    ) -> ModuleSource {\n-        if let Some(m) = child.ancestors().filter_map(ast::Module::cast).find(|it| !it.has_semi()) {\n-            ModuleSource::Module(m)\n-        } else {\n-            let source_file = db.parse(file_id).tree();\n-            ModuleSource::SourceFile(source_file)\n-        }\n-    }\n-\n-    pub fn from_file_id(db: &(impl DefDatabase + AstDatabase), file_id: FileId) -> ModuleSource {\n-        let source_file = db.parse(file_id).tree();\n-        ModuleSource::SourceFile(source_file)\n-    }\n-}\n-\n impl Module {\n     pub fn from_declaration(db: &impl HirDatabase, src: Source<ast::Module>) -> Option<Self> {\n         let src_parent = Source {"}, {"sha": "b49f615bf3514ad830bcf4a22ce361dfc4c7aa9e", "filename": "crates/ra_hir/src/lib.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/16e620c052016010b2f17070a98bdc1e7e849ab3/crates%2Fra_hir%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16e620c052016010b2f17070a98bdc1e7e849ab3/crates%2Fra_hir%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Flib.rs?ref=16e620c052016010b2f17070a98bdc1e7e849ab3", "patch": "@@ -59,10 +59,7 @@ pub mod from_source;\n #[cfg(test)]\n mod marks;\n \n-use hir_expand::{\n-    ast_id_map::{AstIdMap, FileAstId},\n-    AstId,\n-};\n+use hir_expand::AstId;\n \n use crate::{ids::MacroFileKind, name::AsName, resolve::Resolver};\n "}, {"sha": "b423489a11178a533f6cd2b3425de9037f0fc17f", "filename": "crates/ra_hir/src/marks.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/16e620c052016010b2f17070a98bdc1e7e849ab3/crates%2Fra_hir%2Fsrc%2Fmarks.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16e620c052016010b2f17070a98bdc1e7e849ab3/crates%2Fra_hir%2Fsrc%2Fmarks.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fmarks.rs?ref=16e620c052016010b2f17070a98bdc1e7e849ab3", "patch": "@@ -2,6 +2,7 @@\n \n test_utils::marks!(\n     bogus_paths\n+    // FIXME: restore this mark once hir is split\n     name_res_works_for_broken_modules\n     can_import_enum_variant\n     type_var_cycles_resolve_completely"}, {"sha": "bb2d78abe2f0ec21d2d60a72495127cecb86984a", "filename": "crates/ra_hir/src/mock.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/16e620c052016010b2f17070a98bdc1e7e849ab3/crates%2Fra_hir%2Fsrc%2Fmock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16e620c052016010b2f17070a98bdc1e7e849ab3/crates%2Fra_hir%2Fsrc%2Fmock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fmock.rs?ref=16e620c052016010b2f17070a98bdc1e7e849ab3", "patch": "@@ -17,6 +17,7 @@ use crate::{db, debug::HirDebugHelper, diagnostics::DiagnosticSink};\n pub const WORKSPACE: SourceRootId = SourceRootId(0);\n \n #[salsa::database(\n+    hir_def::db::DefDatabase2Storage,\n     ra_db::SourceDatabaseExtStorage,\n     ra_db::SourceDatabaseStorage,\n     db::InternDatabaseStorage,"}, {"sha": "cf66f88adf7a78bdfbe04e672d2f52b12c199ab6", "filename": "crates/ra_hir/src/name.rs", "status": "modified", "additions": 1, "deletions": 142, "changes": 143, "blob_url": "https://github.com/rust-lang/rust/blob/16e620c052016010b2f17070a98bdc1e7e849ab3/crates%2Fra_hir%2Fsrc%2Fname.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16e620c052016010b2f17070a98bdc1e7e849ab3/crates%2Fra_hir%2Fsrc%2Fname.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fname.rs?ref=16e620c052016010b2f17070a98bdc1e7e849ab3", "patch": "@@ -1,142 +1 @@\n-//! FIXME: write short doc here\n-\n-use std::fmt;\n-\n-use ra_syntax::{ast, SmolStr};\n-\n-/// `Name` is a wrapper around string, which is used in hir for both references\n-/// and declarations. In theory, names should also carry hygiene info, but we are\n-/// not there yet!\n-#[derive(Debug, Clone, PartialEq, Eq, Hash, PartialOrd, Ord)]\n-pub struct Name(Repr);\n-\n-#[derive(Debug, Clone, PartialEq, Eq, Hash, PartialOrd, Ord)]\n-enum Repr {\n-    Text(SmolStr),\n-    TupleField(usize),\n-}\n-\n-impl fmt::Display for Name {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        match &self.0 {\n-            Repr::Text(text) => fmt::Display::fmt(&text, f),\n-            Repr::TupleField(idx) => fmt::Display::fmt(&idx, f),\n-        }\n-    }\n-}\n-\n-impl Name {\n-    /// Note: this is private to make creating name from random string hard.\n-    /// Hopefully, this should allow us to integrate hygiene cleaner in the\n-    /// future, and to switch to interned representation of names.\n-    const fn new_text(text: SmolStr) -> Name {\n-        Name(Repr::Text(text))\n-    }\n-\n-    pub(crate) fn new_tuple_field(idx: usize) -> Name {\n-        Name(Repr::TupleField(idx))\n-    }\n-\n-    /// Shortcut to create inline plain text name\n-    const fn new_inline_ascii(len: usize, text: &[u8]) -> Name {\n-        Name::new_text(SmolStr::new_inline_from_ascii(len, text))\n-    }\n-\n-    /// Resolve a name from the text of token.\n-    fn resolve(raw_text: &SmolStr) -> Name {\n-        let raw_start = \"r#\";\n-        if raw_text.as_str().starts_with(raw_start) {\n-            Name::new_text(SmolStr::new(&raw_text[raw_start.len()..]))\n-        } else {\n-            Name::new_text(raw_text.clone())\n-        }\n-    }\n-\n-    pub(crate) fn missing() -> Name {\n-        Name::new_text(\"[missing name]\".into())\n-    }\n-\n-    pub(crate) fn as_tuple_index(&self) -> Option<usize> {\n-        match self.0 {\n-            Repr::TupleField(idx) => Some(idx),\n-            _ => None,\n-        }\n-    }\n-}\n-\n-pub(crate) trait AsName {\n-    fn as_name(&self) -> Name;\n-}\n-\n-impl AsName for ast::NameRef {\n-    fn as_name(&self) -> Name {\n-        match self.as_tuple_field() {\n-            Some(idx) => Name::new_tuple_field(idx),\n-            None => Name::resolve(self.text()),\n-        }\n-    }\n-}\n-\n-impl AsName for ast::Name {\n-    fn as_name(&self) -> Name {\n-        Name::resolve(self.text())\n-    }\n-}\n-\n-impl AsName for ast::FieldKind {\n-    fn as_name(&self) -> Name {\n-        match self {\n-            ast::FieldKind::Name(nr) => nr.as_name(),\n-            ast::FieldKind::Index(idx) => Name::new_tuple_field(idx.text().parse().unwrap()),\n-        }\n-    }\n-}\n-\n-impl AsName for ra_db::Dependency {\n-    fn as_name(&self) -> Name {\n-        Name::new_text(self.name.clone())\n-    }\n-}\n-\n-// Primitives\n-pub(crate) const ISIZE: Name = Name::new_inline_ascii(5, b\"isize\");\n-pub(crate) const I8: Name = Name::new_inline_ascii(2, b\"i8\");\n-pub(crate) const I16: Name = Name::new_inline_ascii(3, b\"i16\");\n-pub(crate) const I32: Name = Name::new_inline_ascii(3, b\"i32\");\n-pub(crate) const I64: Name = Name::new_inline_ascii(3, b\"i64\");\n-pub(crate) const I128: Name = Name::new_inline_ascii(4, b\"i128\");\n-pub(crate) const USIZE: Name = Name::new_inline_ascii(5, b\"usize\");\n-pub(crate) const U8: Name = Name::new_inline_ascii(2, b\"u8\");\n-pub(crate) const U16: Name = Name::new_inline_ascii(3, b\"u16\");\n-pub(crate) const U32: Name = Name::new_inline_ascii(3, b\"u32\");\n-pub(crate) const U64: Name = Name::new_inline_ascii(3, b\"u64\");\n-pub(crate) const U128: Name = Name::new_inline_ascii(4, b\"u128\");\n-pub(crate) const F32: Name = Name::new_inline_ascii(3, b\"f32\");\n-pub(crate) const F64: Name = Name::new_inline_ascii(3, b\"f64\");\n-pub(crate) const BOOL: Name = Name::new_inline_ascii(4, b\"bool\");\n-pub(crate) const CHAR: Name = Name::new_inline_ascii(4, b\"char\");\n-pub(crate) const STR: Name = Name::new_inline_ascii(3, b\"str\");\n-\n-// Special names\n-pub(crate) const SELF_PARAM: Name = Name::new_inline_ascii(4, b\"self\");\n-pub(crate) const SELF_TYPE: Name = Name::new_inline_ascii(4, b\"Self\");\n-pub(crate) const MACRO_RULES: Name = Name::new_inline_ascii(11, b\"macro_rules\");\n-\n-// Components of known path (value or mod name)\n-pub(crate) const STD: Name = Name::new_inline_ascii(3, b\"std\");\n-pub(crate) const ITER: Name = Name::new_inline_ascii(4, b\"iter\");\n-pub(crate) const OPS: Name = Name::new_inline_ascii(3, b\"ops\");\n-pub(crate) const FUTURE: Name = Name::new_inline_ascii(6, b\"future\");\n-pub(crate) const RESULT: Name = Name::new_inline_ascii(6, b\"result\");\n-pub(crate) const BOXED: Name = Name::new_inline_ascii(5, b\"boxed\");\n-\n-// Components of known path (type name)\n-pub(crate) const INTO_ITERATOR_TYPE: Name = Name::new_inline_ascii(12, b\"IntoIterator\");\n-pub(crate) const ITEM_TYPE: Name = Name::new_inline_ascii(4, b\"Item\");\n-pub(crate) const TRY_TYPE: Name = Name::new_inline_ascii(3, b\"Try\");\n-pub(crate) const OK_TYPE: Name = Name::new_inline_ascii(2, b\"Ok\");\n-pub(crate) const FUTURE_TYPE: Name = Name::new_inline_ascii(6, b\"Future\");\n-pub(crate) const RESULT_TYPE: Name = Name::new_inline_ascii(6, b\"Result\");\n-pub(crate) const OUTPUT_TYPE: Name = Name::new_inline_ascii(6, b\"Output\");\n-pub(crate) const TARGET_TYPE: Name = Name::new_inline_ascii(6, b\"Target\");\n-pub(crate) const BOX_TYPE: Name = Name::new_inline_ascii(3, b\"Box\");\n+pub use hir_def::name::*;"}, {"sha": "39f585b446a9850726db321c6e575c7becdf5884", "filename": "crates/ra_hir/src/nameres.rs", "status": "modified", "additions": 4, "deletions": 7, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/16e620c052016010b2f17070a98bdc1e7e849ab3/crates%2Fra_hir%2Fsrc%2Fnameres.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16e620c052016010b2f17070a98bdc1e7e849ab3/crates%2Fra_hir%2Fsrc%2Fnameres.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fnameres.rs?ref=16e620c052016010b2f17070a98bdc1e7e849ab3", "patch": "@@ -48,7 +48,6 @@\n //! on the result\n \n mod per_ns;\n-mod raw;\n mod collector;\n mod mod_resolution;\n #[cfg(test)]\n@@ -74,12 +73,9 @@ use crate::{\n     Trait,\n };\n \n-pub(crate) use self::raw::{ImportSourceMap, RawItems};\n+pub use self::per_ns::{Namespace, PerNs};\n \n-pub use self::{\n-    per_ns::{Namespace, PerNs},\n-    raw::ImportId,\n-};\n+pub use hir_def::nameres::raw::ImportId;\n \n /// Contains all top-level defs from a macro-expanded crate\n #[derive(Debug, PartialEq, Eq)]\n@@ -328,7 +324,8 @@ impl CrateDefMap {\n     ) -> ResolvePathResult {\n         let mut segments = path.segments.iter().enumerate();\n         let mut curr_per_ns: PerNs = match path.kind {\n-            PathKind::DollarCrate(krate) => {\n+            PathKind::DollarCrate(crate_id) => {\n+                let krate = Crate { crate_id };\n                 if krate == self.krate {\n                     tested_by!(macro_dollar_crate_self);\n                     PerNs::types(Module::new(self.krate, self.root).into())"}, {"sha": "2dd0a5877799484479945c9f09d762a648dca508", "filename": "crates/ra_hir/src/nameres/collector.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/16e620c052016010b2f17070a98bdc1e7e849ab3/crates%2Fra_hir%2Fsrc%2Fnameres%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16e620c052016010b2f17070a98bdc1e7e849ab3/crates%2Fra_hir%2Fsrc%2Fnameres%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fnameres%2Fcollector.rs?ref=16e620c052016010b2f17070a98bdc1e7e849ab3", "patch": "@@ -1,5 +1,6 @@\n //! FIXME: write short doc here\n \n+use hir_def::nameres::raw;\n use ra_cfg::CfgOptions;\n use ra_db::FileId;\n use ra_syntax::{ast, SmolStr};\n@@ -12,7 +13,7 @@ use crate::{\n     ids::{AstItemDef, LocationCtx, MacroCallId, MacroCallLoc, MacroDefId, MacroFileKind},\n     name::MACRO_RULES,\n     nameres::{\n-        diagnostics::DefDiagnostic, mod_resolution::ModDir, raw, Crate, CrateDefMap, CrateModuleId,\n+        diagnostics::DefDiagnostic, mod_resolution::ModDir, Crate, CrateDefMap, CrateModuleId,\n         ModuleData, ModuleDef, PerNs, ReachedFixedPoint, Resolution, ResolveMode,\n     },\n     Adt, AstId, Const, Enum, Function, HirFileId, MacroDef, Module, Name, Path, PathKind, Static,"}, {"sha": "abfe8b1c346e28ee6387b4a2fde473a1bcde939f", "filename": "crates/ra_hir/src/nameres/tests/mod_resolution.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/16e620c052016010b2f17070a98bdc1e7e849ab3/crates%2Fra_hir%2Fsrc%2Fnameres%2Ftests%2Fmod_resolution.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16e620c052016010b2f17070a98bdc1e7e849ab3/crates%2Fra_hir%2Fsrc%2Fnameres%2Ftests%2Fmod_resolution.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fnameres%2Ftests%2Fmod_resolution.rs?ref=16e620c052016010b2f17070a98bdc1e7e849ab3", "patch": "@@ -2,7 +2,7 @@ use super::*;\n \n #[test]\n fn name_res_works_for_broken_modules() {\n-    covers!(name_res_works_for_broken_modules);\n+    // covers!(name_res_works_for_broken_modules);\n     let map = def_map(\n         \"\n         //- /lib.rs"}, {"sha": "7f0ff4bfc77334bef10da4977dea57d11086c660", "filename": "crates/ra_hir/src/path.rs", "status": "modified", "additions": 1, "deletions": 422, "changes": 423, "blob_url": "https://github.com/rust-lang/rust/blob/16e620c052016010b2f17070a98bdc1e7e849ab3/crates%2Fra_hir%2Fsrc%2Fpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16e620c052016010b2f17070a98bdc1e7e849ab3/crates%2Fra_hir%2Fsrc%2Fpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fpath.rs?ref=16e620c052016010b2f17070a98bdc1e7e849ab3", "patch": "@@ -1,422 +1 @@\n-//! FIXME: write short doc here\n-\n-use std::{iter, sync::Arc};\n-\n-use ra_syntax::{\n-    ast::{self, NameOwner, TypeAscriptionOwner},\n-    AstNode,\n-};\n-\n-use crate::{db::AstDatabase, name, type_ref::TypeRef, AsName, Crate, Name, Source};\n-\n-#[derive(Debug, Clone, PartialEq, Eq, Hash)]\n-pub struct Path {\n-    pub kind: PathKind,\n-    pub segments: Vec<PathSegment>,\n-}\n-\n-#[derive(Debug, Clone, PartialEq, Eq, Hash)]\n-pub struct PathSegment {\n-    pub name: Name,\n-    pub args_and_bindings: Option<Arc<GenericArgs>>,\n-}\n-\n-/// Generic arguments to a path segment (e.g. the `i32` in `Option<i32>`). This\n-/// can (in the future) also include bindings of associated types, like in\n-/// `Iterator<Item = Foo>`.\n-#[derive(Debug, Clone, PartialEq, Eq, Hash)]\n-pub struct GenericArgs {\n-    pub args: Vec<GenericArg>,\n-    /// This specifies whether the args contain a Self type as the first\n-    /// element. This is the case for path segments like `<T as Trait>`, where\n-    /// `T` is actually a type parameter for the path `Trait` specifying the\n-    /// Self type. Otherwise, when we have a path `Trait<X, Y>`, the Self type\n-    /// is left out.\n-    pub has_self_type: bool,\n-    /// Associated type bindings like in `Iterator<Item = T>`.\n-    pub bindings: Vec<(Name, TypeRef)>,\n-}\n-\n-/// A single generic argument.\n-#[derive(Debug, Clone, PartialEq, Eq, Hash)]\n-pub enum GenericArg {\n-    Type(TypeRef),\n-    // or lifetime...\n-}\n-\n-#[derive(Debug, Clone, PartialEq, Eq, Hash)]\n-pub enum PathKind {\n-    Plain,\n-    Self_,\n-    Super,\n-    Crate,\n-    // Absolute path\n-    Abs,\n-    // Type based path like `<T>::foo`\n-    Type(Box<TypeRef>),\n-    // `$crate` from macro expansion\n-    DollarCrate(Crate),\n-}\n-\n-impl Path {\n-    /// Calls `cb` with all paths, represented by this use item.\n-    pub fn expand_use_item(\n-        item_src: Source<ast::UseItem>,\n-        db: &impl AstDatabase,\n-        mut cb: impl FnMut(Path, &ast::UseTree, bool, Option<Name>),\n-    ) {\n-        if let Some(tree) = item_src.ast.use_tree() {\n-            expand_use_tree(\n-                None,\n-                tree,\n-                &|| item_src.file_id.macro_crate(db).map(|crate_id| Crate { crate_id }),\n-                &mut cb,\n-            );\n-        }\n-    }\n-\n-    pub fn from_simple_segments(kind: PathKind, segments: impl IntoIterator<Item = Name>) -> Path {\n-        Path {\n-            kind,\n-            segments: segments\n-                .into_iter()\n-                .map(|name| PathSegment { name, args_and_bindings: None })\n-                .collect(),\n-        }\n-    }\n-\n-    /// Converts an `ast::Path` to `Path`. Works with use trees.\n-    /// DEPRECATED: It does not handle `$crate` from macro call.\n-    pub fn from_ast(path: ast::Path) -> Option<Path> {\n-        Path::parse(path, &|| None)\n-    }\n-\n-    /// Converts an `ast::Path` to `Path`. Works with use trees.\n-    /// It correctly handles `$crate` based path from macro call.\n-    pub fn from_src(source: Source<ast::Path>, db: &impl AstDatabase) -> Option<Path> {\n-        let file_id = source.file_id;\n-        Path::parse(source.ast, &|| file_id.macro_crate(db).map(|crate_id| Crate { crate_id }))\n-    }\n-\n-    fn parse(mut path: ast::Path, macro_crate: &impl Fn() -> Option<Crate>) -> Option<Path> {\n-        let mut kind = PathKind::Plain;\n-        let mut segments = Vec::new();\n-        loop {\n-            let segment = path.segment()?;\n-\n-            if segment.has_colon_colon() {\n-                kind = PathKind::Abs;\n-            }\n-\n-            match segment.kind()? {\n-                ast::PathSegmentKind::Name(name) => {\n-                    if name.text() == \"$crate\" {\n-                        if let Some(macro_crate) = macro_crate() {\n-                            kind = PathKind::DollarCrate(macro_crate);\n-                            break;\n-                        }\n-                    }\n-\n-                    let args = segment\n-                        .type_arg_list()\n-                        .and_then(GenericArgs::from_ast)\n-                        .or_else(|| {\n-                            GenericArgs::from_fn_like_path_ast(\n-                                segment.param_list(),\n-                                segment.ret_type(),\n-                            )\n-                        })\n-                        .map(Arc::new);\n-                    let segment = PathSegment { name: name.as_name(), args_and_bindings: args };\n-                    segments.push(segment);\n-                }\n-                ast::PathSegmentKind::Type { type_ref, trait_ref } => {\n-                    assert!(path.qualifier().is_none()); // this can only occur at the first segment\n-\n-                    let self_type = TypeRef::from_ast(type_ref?);\n-\n-                    match trait_ref {\n-                        // <T>::foo\n-                        None => {\n-                            kind = PathKind::Type(Box::new(self_type));\n-                        }\n-                        // <T as Trait<A>>::Foo desugars to Trait<Self=T, A>::Foo\n-                        Some(trait_ref) => {\n-                            let path = Path::parse(trait_ref.path()?, macro_crate)?;\n-                            kind = path.kind;\n-                            let mut prefix_segments = path.segments;\n-                            prefix_segments.reverse();\n-                            segments.extend(prefix_segments);\n-                            // Insert the type reference (T in the above example) as Self parameter for the trait\n-                            let mut last_segment = segments.last_mut()?;\n-                            if last_segment.args_and_bindings.is_none() {\n-                                last_segment.args_and_bindings =\n-                                    Some(Arc::new(GenericArgs::empty()));\n-                            };\n-                            let args = last_segment.args_and_bindings.as_mut().unwrap();\n-                            let mut args_inner = Arc::make_mut(args);\n-                            args_inner.has_self_type = true;\n-                            args_inner.args.insert(0, GenericArg::Type(self_type));\n-                        }\n-                    }\n-                }\n-                ast::PathSegmentKind::CrateKw => {\n-                    kind = PathKind::Crate;\n-                    break;\n-                }\n-                ast::PathSegmentKind::SelfKw => {\n-                    kind = PathKind::Self_;\n-                    break;\n-                }\n-                ast::PathSegmentKind::SuperKw => {\n-                    kind = PathKind::Super;\n-                    break;\n-                }\n-            }\n-            path = match qualifier(&path) {\n-                Some(it) => it,\n-                None => break,\n-            };\n-        }\n-        segments.reverse();\n-        return Some(Path { kind, segments });\n-\n-        fn qualifier(path: &ast::Path) -> Option<ast::Path> {\n-            if let Some(q) = path.qualifier() {\n-                return Some(q);\n-            }\n-            // FIXME: this bottom up traversal is not too precise.\n-            // Should we handle do a top-down analysis, recording results?\n-            let use_tree_list = path.syntax().ancestors().find_map(ast::UseTreeList::cast)?;\n-            let use_tree = use_tree_list.parent_use_tree();\n-            use_tree.path()\n-        }\n-    }\n-\n-    /// Converts an `ast::NameRef` into a single-identifier `Path`.\n-    pub fn from_name_ref(name_ref: &ast::NameRef) -> Path {\n-        name_ref.as_name().into()\n-    }\n-\n-    /// `true` is this path is a single identifier, like `foo`\n-    pub fn is_ident(&self) -> bool {\n-        self.kind == PathKind::Plain && self.segments.len() == 1\n-    }\n-\n-    /// `true` if this path is just a standalone `self`\n-    pub fn is_self(&self) -> bool {\n-        self.kind == PathKind::Self_ && self.segments.is_empty()\n-    }\n-\n-    /// If this path is a single identifier, like `foo`, return its name.\n-    pub fn as_ident(&self) -> Option<&Name> {\n-        if self.kind != PathKind::Plain || self.segments.len() > 1 {\n-            return None;\n-        }\n-        self.segments.first().map(|s| &s.name)\n-    }\n-\n-    pub fn expand_macro_expr(&self) -> Option<Name> {\n-        self.as_ident().and_then(|name| Some(name.clone()))\n-    }\n-\n-    pub fn is_type_relative(&self) -> bool {\n-        match self.kind {\n-            PathKind::Type(_) => true,\n-            _ => false,\n-        }\n-    }\n-}\n-\n-impl GenericArgs {\n-    pub(crate) fn from_ast(node: ast::TypeArgList) -> Option<GenericArgs> {\n-        let mut args = Vec::new();\n-        for type_arg in node.type_args() {\n-            let type_ref = TypeRef::from_ast_opt(type_arg.type_ref());\n-            args.push(GenericArg::Type(type_ref));\n-        }\n-        // lifetimes ignored for now\n-        let mut bindings = Vec::new();\n-        for assoc_type_arg in node.assoc_type_args() {\n-            if let Some(name_ref) = assoc_type_arg.name_ref() {\n-                let name = name_ref.as_name();\n-                let type_ref = TypeRef::from_ast_opt(assoc_type_arg.type_ref());\n-                bindings.push((name, type_ref));\n-            }\n-        }\n-        if args.is_empty() && bindings.is_empty() {\n-            None\n-        } else {\n-            Some(GenericArgs { args, has_self_type: false, bindings })\n-        }\n-    }\n-\n-    /// Collect `GenericArgs` from the parts of a fn-like path, i.e. `Fn(X, Y)\n-    /// -> Z` (which desugars to `Fn<(X, Y), Output=Z>`).\n-    pub(crate) fn from_fn_like_path_ast(\n-        params: Option<ast::ParamList>,\n-        ret_type: Option<ast::RetType>,\n-    ) -> Option<GenericArgs> {\n-        let mut args = Vec::new();\n-        let mut bindings = Vec::new();\n-        if let Some(params) = params {\n-            let mut param_types = Vec::new();\n-            for param in params.params() {\n-                let type_ref = TypeRef::from_ast_opt(param.ascribed_type());\n-                param_types.push(type_ref);\n-            }\n-            let arg = GenericArg::Type(TypeRef::Tuple(param_types));\n-            args.push(arg);\n-        }\n-        if let Some(ret_type) = ret_type {\n-            let type_ref = TypeRef::from_ast_opt(ret_type.type_ref());\n-            bindings.push((name::OUTPUT_TYPE, type_ref))\n-        }\n-        if args.is_empty() && bindings.is_empty() {\n-            None\n-        } else {\n-            Some(GenericArgs { args, has_self_type: false, bindings })\n-        }\n-    }\n-\n-    pub(crate) fn empty() -> GenericArgs {\n-        GenericArgs { args: Vec::new(), has_self_type: false, bindings: Vec::new() }\n-    }\n-}\n-\n-impl From<Name> for Path {\n-    fn from(name: Name) -> Path {\n-        Path::from_simple_segments(PathKind::Plain, iter::once(name))\n-    }\n-}\n-\n-fn expand_use_tree(\n-    prefix: Option<Path>,\n-    tree: ast::UseTree,\n-    macro_crate: &impl Fn() -> Option<Crate>,\n-    cb: &mut impl FnMut(Path, &ast::UseTree, bool, Option<Name>),\n-) {\n-    if let Some(use_tree_list) = tree.use_tree_list() {\n-        let prefix = match tree.path() {\n-            // E.g. use something::{{{inner}}};\n-            None => prefix,\n-            // E.g. `use something::{inner}` (prefix is `None`, path is `something`)\n-            // or `use something::{path::{inner::{innerer}}}` (prefix is `something::path`, path is `inner`)\n-            Some(path) => match convert_path(prefix, path, macro_crate) {\n-                Some(it) => Some(it),\n-                None => return, // FIXME: report errors somewhere\n-            },\n-        };\n-        for child_tree in use_tree_list.use_trees() {\n-            expand_use_tree(prefix.clone(), child_tree, macro_crate, cb);\n-        }\n-    } else {\n-        let alias = tree.alias().and_then(|a| a.name()).map(|a| a.as_name());\n-        if let Some(ast_path) = tree.path() {\n-            // Handle self in a path.\n-            // E.g. `use something::{self, <...>}`\n-            if ast_path.qualifier().is_none() {\n-                if let Some(segment) = ast_path.segment() {\n-                    if segment.kind() == Some(ast::PathSegmentKind::SelfKw) {\n-                        if let Some(prefix) = prefix {\n-                            cb(prefix, &tree, false, alias);\n-                            return;\n-                        }\n-                    }\n-                }\n-            }\n-            if let Some(path) = convert_path(prefix, ast_path, macro_crate) {\n-                let is_glob = tree.has_star();\n-                cb(path, &tree, is_glob, alias)\n-            }\n-            // FIXME: report errors somewhere\n-            // We get here if we do\n-        }\n-    }\n-}\n-\n-fn convert_path(\n-    prefix: Option<Path>,\n-    path: ast::Path,\n-    macro_crate: &impl Fn() -> Option<Crate>,\n-) -> Option<Path> {\n-    let prefix = if let Some(qual) = path.qualifier() {\n-        Some(convert_path(prefix, qual, macro_crate)?)\n-    } else {\n-        prefix\n-    };\n-\n-    let segment = path.segment()?;\n-    let res = match segment.kind()? {\n-        ast::PathSegmentKind::Name(name) => {\n-            if name.text() == \"$crate\" {\n-                if let Some(krate) = macro_crate() {\n-                    return Some(Path::from_simple_segments(\n-                        PathKind::DollarCrate(krate),\n-                        iter::empty(),\n-                    ));\n-                }\n-            }\n-\n-            // no type args in use\n-            let mut res = prefix\n-                .unwrap_or_else(|| Path { kind: PathKind::Plain, segments: Vec::with_capacity(1) });\n-            res.segments.push(PathSegment {\n-                name: name.as_name(),\n-                args_and_bindings: None, // no type args in use\n-            });\n-            res\n-        }\n-        ast::PathSegmentKind::CrateKw => {\n-            if prefix.is_some() {\n-                return None;\n-            }\n-            Path::from_simple_segments(PathKind::Crate, iter::empty())\n-        }\n-        ast::PathSegmentKind::SelfKw => {\n-            if prefix.is_some() {\n-                return None;\n-            }\n-            Path::from_simple_segments(PathKind::Self_, iter::empty())\n-        }\n-        ast::PathSegmentKind::SuperKw => {\n-            if prefix.is_some() {\n-                return None;\n-            }\n-            Path::from_simple_segments(PathKind::Super, iter::empty())\n-        }\n-        ast::PathSegmentKind::Type { .. } => {\n-            // not allowed in imports\n-            return None;\n-        }\n-    };\n-    Some(res)\n-}\n-\n-pub mod known {\n-    use super::{Path, PathKind};\n-    use crate::name;\n-\n-    pub fn std_iter_into_iterator() -> Path {\n-        Path::from_simple_segments(\n-            PathKind::Abs,\n-            vec![name::STD, name::ITER, name::INTO_ITERATOR_TYPE],\n-        )\n-    }\n-\n-    pub fn std_ops_try() -> Path {\n-        Path::from_simple_segments(PathKind::Abs, vec![name::STD, name::OPS, name::TRY_TYPE])\n-    }\n-\n-    pub fn std_result_result() -> Path {\n-        Path::from_simple_segments(PathKind::Abs, vec![name::STD, name::RESULT, name::RESULT_TYPE])\n-    }\n-\n-    pub fn std_future_future() -> Path {\n-        Path::from_simple_segments(PathKind::Abs, vec![name::STD, name::FUTURE, name::FUTURE_TYPE])\n-    }\n-\n-    pub fn std_boxed_box() -> Path {\n-        Path::from_simple_segments(PathKind::Abs, vec![name::STD, name::BOXED, name::BOX_TYPE])\n-    }\n-}\n+pub use hir_def::path::*;"}, {"sha": "bd56ddbe61aecd57fe3b6d7d82981fa22dd1ad87", "filename": "crates/ra_hir/src/type_ref.rs", "status": "modified", "additions": 1, "deletions": 162, "changes": 163, "blob_url": "https://github.com/rust-lang/rust/blob/16e620c052016010b2f17070a98bdc1e7e849ab3/crates%2Fra_hir%2Fsrc%2Ftype_ref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16e620c052016010b2f17070a98bdc1e7e849ab3/crates%2Fra_hir%2Fsrc%2Ftype_ref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Ftype_ref.rs?ref=16e620c052016010b2f17070a98bdc1e7e849ab3", "patch": "@@ -1,162 +1 @@\n-//! HIR for references to types. Paths in these are not yet resolved. They can\n-//! be directly created from an ast::TypeRef, without further queries.\n-\n-use ra_syntax::ast::{self, TypeAscriptionOwner, TypeBoundsOwner};\n-\n-use crate::Path;\n-\n-#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]\n-pub enum Mutability {\n-    Shared,\n-    Mut,\n-}\n-\n-impl Mutability {\n-    pub fn from_mutable(mutable: bool) -> Mutability {\n-        if mutable {\n-            Mutability::Mut\n-        } else {\n-            Mutability::Shared\n-        }\n-    }\n-\n-    pub fn as_keyword_for_ref(self) -> &'static str {\n-        match self {\n-            Mutability::Shared => \"\",\n-            Mutability::Mut => \"mut \",\n-        }\n-    }\n-\n-    pub fn as_keyword_for_ptr(self) -> &'static str {\n-        match self {\n-            Mutability::Shared => \"const \",\n-            Mutability::Mut => \"mut \",\n-        }\n-    }\n-}\n-\n-/// Compare ty::Ty\n-#[derive(Clone, PartialEq, Eq, Hash, Debug)]\n-pub enum TypeRef {\n-    Never,\n-    Placeholder,\n-    Tuple(Vec<TypeRef>),\n-    Path(Path),\n-    RawPtr(Box<TypeRef>, Mutability),\n-    Reference(Box<TypeRef>, Mutability),\n-    Array(Box<TypeRef> /*, Expr*/),\n-    Slice(Box<TypeRef>),\n-    /// A fn pointer. Last element of the vector is the return type.\n-    Fn(Vec<TypeRef>),\n-    // For\n-    ImplTrait(Vec<TypeBound>),\n-    DynTrait(Vec<TypeBound>),\n-    Error,\n-}\n-\n-#[derive(Clone, PartialEq, Eq, Hash, Debug)]\n-pub enum TypeBound {\n-    Path(Path),\n-    // also for<> bounds\n-    // also Lifetimes\n-    Error,\n-}\n-\n-impl TypeRef {\n-    /// Converts an `ast::TypeRef` to a `hir::TypeRef`.\n-    pub(crate) fn from_ast(node: ast::TypeRef) -> Self {\n-        match node {\n-            ast::TypeRef::ParenType(inner) => TypeRef::from_ast_opt(inner.type_ref()),\n-            ast::TypeRef::TupleType(inner) => {\n-                TypeRef::Tuple(inner.fields().map(TypeRef::from_ast).collect())\n-            }\n-            ast::TypeRef::NeverType(..) => TypeRef::Never,\n-            ast::TypeRef::PathType(inner) => {\n-                // FIXME: Use `Path::from_src`\n-                inner.path().and_then(Path::from_ast).map(TypeRef::Path).unwrap_or(TypeRef::Error)\n-            }\n-            ast::TypeRef::PointerType(inner) => {\n-                let inner_ty = TypeRef::from_ast_opt(inner.type_ref());\n-                let mutability = Mutability::from_mutable(inner.is_mut());\n-                TypeRef::RawPtr(Box::new(inner_ty), mutability)\n-            }\n-            ast::TypeRef::ArrayType(inner) => {\n-                TypeRef::Array(Box::new(TypeRef::from_ast_opt(inner.type_ref())))\n-            }\n-            ast::TypeRef::SliceType(inner) => {\n-                TypeRef::Slice(Box::new(TypeRef::from_ast_opt(inner.type_ref())))\n-            }\n-            ast::TypeRef::ReferenceType(inner) => {\n-                let inner_ty = TypeRef::from_ast_opt(inner.type_ref());\n-                let mutability = Mutability::from_mutable(inner.is_mut());\n-                TypeRef::Reference(Box::new(inner_ty), mutability)\n-            }\n-            ast::TypeRef::PlaceholderType(_inner) => TypeRef::Placeholder,\n-            ast::TypeRef::FnPointerType(inner) => {\n-                let ret_ty = TypeRef::from_ast_opt(inner.ret_type().and_then(|rt| rt.type_ref()));\n-                let mut params = if let Some(pl) = inner.param_list() {\n-                    pl.params().map(|p| p.ascribed_type()).map(TypeRef::from_ast_opt).collect()\n-                } else {\n-                    Vec::new()\n-                };\n-                params.push(ret_ty);\n-                TypeRef::Fn(params)\n-            }\n-            // for types are close enough for our purposes to the inner type for now...\n-            ast::TypeRef::ForType(inner) => TypeRef::from_ast_opt(inner.type_ref()),\n-            ast::TypeRef::ImplTraitType(inner) => {\n-                TypeRef::ImplTrait(type_bounds_from_ast(inner.type_bound_list()))\n-            }\n-            ast::TypeRef::DynTraitType(inner) => {\n-                TypeRef::DynTrait(type_bounds_from_ast(inner.type_bound_list()))\n-            }\n-        }\n-    }\n-\n-    pub(crate) fn from_ast_opt(node: Option<ast::TypeRef>) -> Self {\n-        if let Some(node) = node {\n-            TypeRef::from_ast(node)\n-        } else {\n-            TypeRef::Error\n-        }\n-    }\n-\n-    pub fn unit() -> TypeRef {\n-        TypeRef::Tuple(Vec::new())\n-    }\n-}\n-\n-pub(crate) fn type_bounds_from_ast(type_bounds_opt: Option<ast::TypeBoundList>) -> Vec<TypeBound> {\n-    if let Some(type_bounds) = type_bounds_opt {\n-        type_bounds.bounds().map(TypeBound::from_ast).collect()\n-    } else {\n-        vec![]\n-    }\n-}\n-\n-impl TypeBound {\n-    pub(crate) fn from_ast(node: ast::TypeBound) -> Self {\n-        match node.kind() {\n-            ast::TypeBoundKind::PathType(path_type) => {\n-                let path = match path_type.path() {\n-                    Some(p) => p,\n-                    None => return TypeBound::Error,\n-                };\n-                // FIXME: Use `Path::from_src`\n-                let path = match Path::from_ast(path) {\n-                    Some(p) => p,\n-                    None => return TypeBound::Error,\n-                };\n-                TypeBound::Path(path)\n-            }\n-            ast::TypeBoundKind::ForType(_) | ast::TypeBoundKind::Lifetime(_) => TypeBound::Error,\n-        }\n-    }\n-\n-    pub fn as_path(&self) -> Option<&Path> {\n-        match self {\n-            TypeBound::Path(p) => Some(p),\n-            _ => None,\n-        }\n-    }\n-}\n+pub use hir_def::type_ref::*;"}, {"sha": "746c907e80dabe4b23c10aa4f1bad2d768557330", "filename": "crates/ra_hir_def/Cargo.toml", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/16e620c052016010b2f17070a98bdc1e7e849ab3/crates%2Fra_hir_def%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/16e620c052016010b2f17070a98bdc1e7e849ab3/crates%2Fra_hir_def%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2FCargo.toml?ref=16e620c052016010b2f17070a98bdc1e7e849ab3", "patch": "@@ -6,9 +6,16 @@ authors = [\"rust-analyzer developers\"]\n \n [dependencies]\n log = \"0.4.5\"\n+once_cell = \"1.0.1\"\n+relative-path = \"1.0.0\"\n+rustc-hash = \"1.0\"\n \n ra_arena = { path = \"../ra_arena\" }\n ra_db = { path = \"../ra_db\" }\n ra_syntax = { path = \"../ra_syntax\" }\n ra_prof = { path = \"../ra_prof\" }\n hir_expand = { path = \"../ra_hir_expand\", package = \"ra_hir_expand\" }\n+test_utils = { path = \"../test_utils\" }\n+mbe = { path = \"../ra_mbe\", package = \"ra_mbe\" }\n+ra_cfg = { path = \"../ra_cfg\" }\n+tt = { path = \"../ra_tt\", package = \"ra_tt\" }"}, {"sha": "248f03cdfdd4203c3566c5033fcff498bb8c5467", "filename": "crates/ra_hir_def/src/attr.rs", "status": "added", "additions": 91, "deletions": 0, "changes": 91, "blob_url": "https://github.com/rust-lang/rust/blob/16e620c052016010b2f17070a98bdc1e7e849ab3/crates%2Fra_hir_def%2Fsrc%2Fattr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16e620c052016010b2f17070a98bdc1e7e849ab3/crates%2Fra_hir_def%2Fsrc%2Fattr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Fattr.rs?ref=16e620c052016010b2f17070a98bdc1e7e849ab3", "patch": "@@ -0,0 +1,91 @@\n+//! A higher level attributes based on TokenTree, with also some shortcuts.\n+\n+use std::sync::Arc;\n+\n+use hir_expand::db::AstDatabase;\n+use mbe::ast_to_token_tree;\n+use ra_cfg::CfgOptions;\n+use ra_syntax::{\n+    ast::{self, AstNode, AttrsOwner},\n+    SmolStr,\n+};\n+use tt::Subtree;\n+\n+use crate::{path::Path, HirFileId, Source};\n+\n+#[derive(Debug, Clone, PartialEq, Eq)]\n+pub struct Attr {\n+    pub(crate) path: Path,\n+    pub(crate) input: Option<AttrInput>,\n+}\n+\n+#[derive(Debug, Clone, PartialEq, Eq)]\n+pub enum AttrInput {\n+    Literal(SmolStr),\n+    TokenTree(Subtree),\n+}\n+\n+impl Attr {\n+    pub(crate) fn from_src(\n+        Source { file_id, ast }: Source<ast::Attr>,\n+        db: &impl AstDatabase,\n+    ) -> Option<Attr> {\n+        let path = Path::from_src(Source { file_id, ast: ast.path()? }, db)?;\n+        let input = match ast.input() {\n+            None => None,\n+            Some(ast::AttrInput::Literal(lit)) => {\n+                // FIXME: escape? raw string?\n+                let value = lit.syntax().first_token()?.text().trim_matches('\"').into();\n+                Some(AttrInput::Literal(value))\n+            }\n+            Some(ast::AttrInput::TokenTree(tt)) => {\n+                Some(AttrInput::TokenTree(ast_to_token_tree(&tt)?.0))\n+            }\n+        };\n+\n+        Some(Attr { path, input })\n+    }\n+\n+    pub fn from_attrs_owner(\n+        file_id: HirFileId,\n+        owner: &dyn AttrsOwner,\n+        db: &impl AstDatabase,\n+    ) -> Option<Arc<[Attr]>> {\n+        let mut attrs = owner.attrs().peekable();\n+        if attrs.peek().is_none() {\n+            // Avoid heap allocation\n+            return None;\n+        }\n+        Some(attrs.flat_map(|ast| Attr::from_src(Source { file_id, ast }, db)).collect())\n+    }\n+\n+    pub fn is_simple_atom(&self, name: &str) -> bool {\n+        // FIXME: Avoid cloning\n+        self.path.as_ident().map_or(false, |s| s.to_string() == name)\n+    }\n+\n+    // FIXME: handle cfg_attr :-)\n+    pub fn as_cfg(&self) -> Option<&Subtree> {\n+        if !self.is_simple_atom(\"cfg\") {\n+            return None;\n+        }\n+        match &self.input {\n+            Some(AttrInput::TokenTree(subtree)) => Some(subtree),\n+            _ => None,\n+        }\n+    }\n+\n+    pub fn as_path(&self) -> Option<&SmolStr> {\n+        if !self.is_simple_atom(\"path\") {\n+            return None;\n+        }\n+        match &self.input {\n+            Some(AttrInput::Literal(it)) => Some(it),\n+            _ => None,\n+        }\n+    }\n+\n+    pub fn is_cfg_enabled(&self, cfg_options: &CfgOptions) -> Option<bool> {\n+        cfg_options.is_cfg_enabled(self.as_cfg()?)\n+    }\n+}"}, {"sha": "b271636b07e7b003f87c104d5a753a75de59d477", "filename": "crates/ra_hir_def/src/db.rs", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/16e620c052016010b2f17070a98bdc1e7e849ab3/crates%2Fra_hir_def%2Fsrc%2Fdb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16e620c052016010b2f17070a98bdc1e7e849ab3/crates%2Fra_hir_def%2Fsrc%2Fdb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Fdb.rs?ref=16e620c052016010b2f17070a98bdc1e7e849ab3", "patch": "@@ -1,15 +1,21 @@\n //! Defines database & queries for name resolution.\n+use std::sync::Arc;\n \n+use hir_expand::{db::AstDatabase, HirFileId};\n use ra_db::{salsa, SourceDatabase};\n use ra_syntax::ast;\n \n+use crate::nameres::raw::{ImportSourceMap, RawItems};\n+\n #[salsa::query_group(InternDatabaseStorage)]\n pub trait InternDatabase: SourceDatabase {\n     #[salsa::interned]\n     fn intern_function(&self, loc: crate::ItemLoc<ast::FnDef>) -> crate::FunctionId;\n     #[salsa::interned]\n     fn intern_struct(&self, loc: crate::ItemLoc<ast::StructDef>) -> crate::StructId;\n     #[salsa::interned]\n+    fn intern_union(&self, loc: crate::ItemLoc<ast::StructDef>) -> crate::UnionId;\n+    #[salsa::interned]\n     fn intern_enum(&self, loc: crate::ItemLoc<ast::EnumDef>) -> crate::EnumId;\n     #[salsa::interned]\n     fn intern_const(&self, loc: crate::ItemLoc<ast::ConstDef>) -> crate::ConstId;\n@@ -20,3 +26,15 @@ pub trait InternDatabase: SourceDatabase {\n     #[salsa::interned]\n     fn intern_type_alias(&self, loc: crate::ItemLoc<ast::TypeAliasDef>) -> crate::TypeAliasId;\n }\n+\n+#[salsa::query_group(DefDatabase2Storage)]\n+pub trait DefDatabase2: InternDatabase + AstDatabase {\n+    #[salsa::invoke(RawItems::raw_items_with_source_map_query)]\n+    fn raw_items_with_source_map(\n+        &self,\n+        file_id: HirFileId,\n+    ) -> (Arc<RawItems>, Arc<ImportSourceMap>);\n+\n+    #[salsa::invoke(RawItems::raw_items_query)]\n+    fn raw_items(&self, file_id: HirFileId) -> Arc<RawItems>;\n+}"}, {"sha": "83583ef8bd3ca81e587a106e6bb60053f1deb3e9", "filename": "crates/ra_hir_def/src/either.rs", "status": "added", "additions": 54, "deletions": 0, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/16e620c052016010b2f17070a98bdc1e7e849ab3/crates%2Fra_hir_def%2Fsrc%2Feither.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16e620c052016010b2f17070a98bdc1e7e849ab3/crates%2Fra_hir_def%2Fsrc%2Feither.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Feither.rs?ref=16e620c052016010b2f17070a98bdc1e7e849ab3", "patch": "@@ -0,0 +1,54 @@\n+//! FIXME: write short doc here\n+\n+#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]\n+pub enum Either<A, B> {\n+    A(A),\n+    B(B),\n+}\n+\n+impl<A, B> Either<A, B> {\n+    pub fn either<R, F1, F2>(self, f1: F1, f2: F2) -> R\n+    where\n+        F1: FnOnce(A) -> R,\n+        F2: FnOnce(B) -> R,\n+    {\n+        match self {\n+            Either::A(a) => f1(a),\n+            Either::B(b) => f2(b),\n+        }\n+    }\n+    pub fn map<U, V, F1, F2>(self, f1: F1, f2: F2) -> Either<U, V>\n+    where\n+        F1: FnOnce(A) -> U,\n+        F2: FnOnce(B) -> V,\n+    {\n+        match self {\n+            Either::A(a) => Either::A(f1(a)),\n+            Either::B(b) => Either::B(f2(b)),\n+        }\n+    }\n+    pub fn map_a<U, F>(self, f: F) -> Either<U, B>\n+    where\n+        F: FnOnce(A) -> U,\n+    {\n+        self.map(f, |it| it)\n+    }\n+    pub fn a(self) -> Option<A> {\n+        match self {\n+            Either::A(it) => Some(it),\n+            Either::B(_) => None,\n+        }\n+    }\n+    pub fn b(self) -> Option<B> {\n+        match self {\n+            Either::A(_) => None,\n+            Either::B(it) => Some(it),\n+        }\n+    }\n+    pub fn as_ref(&self) -> Either<&A, &B> {\n+        match self {\n+            Either::A(it) => Either::A(it),\n+            Either::B(it) => Either::B(it),\n+        }\n+    }\n+}"}, {"sha": "95d50332568a37611e605a96872f260467f8b30a", "filename": "crates/ra_hir_def/src/lib.rs", "status": "modified", "additions": 94, "deletions": 1, "changes": 95, "blob_url": "https://github.com/rust-lang/rust/blob/16e620c052016010b2f17070a98bdc1e7e849ab3/crates%2Fra_hir_def%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16e620c052016010b2f17070a98bdc1e7e849ab3/crates%2Fra_hir_def%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Flib.rs?ref=16e620c052016010b2f17070a98bdc1e7e849ab3", "patch": "@@ -8,12 +8,20 @@\n //! actually true.\n \n pub mod db;\n+pub mod either;\n+pub mod attr;\n+pub mod name;\n+pub mod path;\n+pub mod type_ref;\n+\n+// FIXME: this should be private\n+pub mod nameres;\n \n use std::hash::{Hash, Hasher};\n \n use hir_expand::{ast_id_map::FileAstId, db::AstDatabase, AstId, HirFileId};\n use ra_arena::{impl_arena_id, RawId};\n-use ra_db::{salsa, CrateId};\n+use ra_db::{salsa, CrateId, FileId};\n use ra_syntax::{ast, AstNode, SyntaxNode};\n \n use crate::db::InternDatabase;\n@@ -24,6 +32,68 @@ pub struct Source<T> {\n     pub ast: T,\n }\n \n+pub enum ModuleSource {\n+    SourceFile(ast::SourceFile),\n+    Module(ast::Module),\n+}\n+\n+impl ModuleSource {\n+    pub fn new(\n+        db: &impl db::DefDatabase2,\n+        file_id: Option<FileId>,\n+        decl_id: Option<AstId<ast::Module>>,\n+    ) -> ModuleSource {\n+        match (file_id, decl_id) {\n+            (Some(file_id), _) => {\n+                let source_file = db.parse(file_id).tree();\n+                ModuleSource::SourceFile(source_file)\n+            }\n+            (None, Some(item_id)) => {\n+                let module = item_id.to_node(db);\n+                assert!(module.item_list().is_some(), \"expected inline module\");\n+                ModuleSource::Module(module)\n+            }\n+            (None, None) => panic!(),\n+        }\n+    }\n+\n+    // FIXME: this methods do not belong here\n+    pub fn from_position(\n+        db: &impl db::DefDatabase2,\n+        position: ra_db::FilePosition,\n+    ) -> ModuleSource {\n+        let parse = db.parse(position.file_id);\n+        match &ra_syntax::algo::find_node_at_offset::<ast::Module>(\n+            parse.tree().syntax(),\n+            position.offset,\n+        ) {\n+            Some(m) if !m.has_semi() => ModuleSource::Module(m.clone()),\n+            _ => {\n+                let source_file = parse.tree();\n+                ModuleSource::SourceFile(source_file)\n+            }\n+        }\n+    }\n+\n+    pub fn from_child_node(\n+        db: &impl db::DefDatabase2,\n+        file_id: FileId,\n+        child: &SyntaxNode,\n+    ) -> ModuleSource {\n+        if let Some(m) = child.ancestors().filter_map(ast::Module::cast).find(|it| !it.has_semi()) {\n+            ModuleSource::Module(m)\n+        } else {\n+            let source_file = db.parse(file_id).tree();\n+            ModuleSource::SourceFile(source_file)\n+        }\n+    }\n+\n+    pub fn from_file_id(db: &impl db::DefDatabase2, file_id: FileId) -> ModuleSource {\n+        let source_file = db.parse(file_id).tree();\n+        ModuleSource::SourceFile(source_file)\n+    }\n+}\n+\n impl<T> Source<T> {\n     pub fn map<F: FnOnce(T) -> U, U>(self, f: F) -> Source<U> {\n         Source { file_id: self.file_id, ast: f(self.ast) }\n@@ -155,6 +225,18 @@ impl AstItemDef<ast::StructDef> for StructId {\n     }\n }\n \n+#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n+pub struct UnionId(salsa::InternId);\n+impl_intern_key!(UnionId);\n+impl AstItemDef<ast::StructDef> for UnionId {\n+    fn intern(db: &impl InternDatabase, loc: ItemLoc<ast::StructDef>) -> Self {\n+        db.intern_union(loc)\n+    }\n+    fn lookup_intern(self, db: &impl InternDatabase) -> ItemLoc<ast::StructDef> {\n+        db.lookup_intern_union(self)\n+    }\n+}\n+\n #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n pub struct EnumId(salsa::InternId);\n impl_intern_key!(EnumId);\n@@ -167,6 +249,17 @@ impl AstItemDef<ast::EnumDef> for EnumId {\n     }\n }\n \n+// FIXME: rename to `VariantId`, only enums can ave variants\n+#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n+pub struct EnumVariantId {\n+    parent: EnumId,\n+    local_id: LocalEnumVariantId,\n+}\n+\n+#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n+pub(crate) struct LocalEnumVariantId(RawId);\n+impl_arena_id!(LocalEnumVariantId);\n+\n #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n pub struct ConstId(salsa::InternId);\n impl_intern_key!(ConstId);"}, {"sha": "720896ee8ebfa7f948fc0a1566c1c37b6a37bbcc", "filename": "crates/ra_hir_def/src/name.rs", "status": "added", "additions": 142, "deletions": 0, "changes": 142, "blob_url": "https://github.com/rust-lang/rust/blob/16e620c052016010b2f17070a98bdc1e7e849ab3/crates%2Fra_hir_def%2Fsrc%2Fname.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16e620c052016010b2f17070a98bdc1e7e849ab3/crates%2Fra_hir_def%2Fsrc%2Fname.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Fname.rs?ref=16e620c052016010b2f17070a98bdc1e7e849ab3", "patch": "@@ -0,0 +1,142 @@\n+//! FIXME: write short doc here\n+\n+use std::fmt;\n+\n+use ra_syntax::{ast, SmolStr};\n+\n+/// `Name` is a wrapper around string, which is used in hir for both references\n+/// and declarations. In theory, names should also carry hygiene info, but we are\n+/// not there yet!\n+#[derive(Debug, Clone, PartialEq, Eq, Hash, PartialOrd, Ord)]\n+pub struct Name(Repr);\n+\n+#[derive(Debug, Clone, PartialEq, Eq, Hash, PartialOrd, Ord)]\n+enum Repr {\n+    Text(SmolStr),\n+    TupleField(usize),\n+}\n+\n+impl fmt::Display for Name {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        match &self.0 {\n+            Repr::Text(text) => fmt::Display::fmt(&text, f),\n+            Repr::TupleField(idx) => fmt::Display::fmt(&idx, f),\n+        }\n+    }\n+}\n+\n+impl Name {\n+    /// Note: this is private to make creating name from random string hard.\n+    /// Hopefully, this should allow us to integrate hygiene cleaner in the\n+    /// future, and to switch to interned representation of names.\n+    const fn new_text(text: SmolStr) -> Name {\n+        Name(Repr::Text(text))\n+    }\n+\n+    pub fn new_tuple_field(idx: usize) -> Name {\n+        Name(Repr::TupleField(idx))\n+    }\n+\n+    /// Shortcut to create inline plain text name\n+    const fn new_inline_ascii(len: usize, text: &[u8]) -> Name {\n+        Name::new_text(SmolStr::new_inline_from_ascii(len, text))\n+    }\n+\n+    /// Resolve a name from the text of token.\n+    fn resolve(raw_text: &SmolStr) -> Name {\n+        let raw_start = \"r#\";\n+        if raw_text.as_str().starts_with(raw_start) {\n+            Name::new_text(SmolStr::new(&raw_text[raw_start.len()..]))\n+        } else {\n+            Name::new_text(raw_text.clone())\n+        }\n+    }\n+\n+    pub fn missing() -> Name {\n+        Name::new_text(\"[missing name]\".into())\n+    }\n+\n+    pub fn as_tuple_index(&self) -> Option<usize> {\n+        match self.0 {\n+            Repr::TupleField(idx) => Some(idx),\n+            _ => None,\n+        }\n+    }\n+}\n+\n+pub trait AsName {\n+    fn as_name(&self) -> Name;\n+}\n+\n+impl AsName for ast::NameRef {\n+    fn as_name(&self) -> Name {\n+        match self.as_tuple_field() {\n+            Some(idx) => Name::new_tuple_field(idx),\n+            None => Name::resolve(self.text()),\n+        }\n+    }\n+}\n+\n+impl AsName for ast::Name {\n+    fn as_name(&self) -> Name {\n+        Name::resolve(self.text())\n+    }\n+}\n+\n+impl AsName for ast::FieldKind {\n+    fn as_name(&self) -> Name {\n+        match self {\n+            ast::FieldKind::Name(nr) => nr.as_name(),\n+            ast::FieldKind::Index(idx) => Name::new_tuple_field(idx.text().parse().unwrap()),\n+        }\n+    }\n+}\n+\n+impl AsName for ra_db::Dependency {\n+    fn as_name(&self) -> Name {\n+        Name::new_text(self.name.clone())\n+    }\n+}\n+\n+// Primitives\n+pub const ISIZE: Name = Name::new_inline_ascii(5, b\"isize\");\n+pub const I8: Name = Name::new_inline_ascii(2, b\"i8\");\n+pub const I16: Name = Name::new_inline_ascii(3, b\"i16\");\n+pub const I32: Name = Name::new_inline_ascii(3, b\"i32\");\n+pub const I64: Name = Name::new_inline_ascii(3, b\"i64\");\n+pub const I128: Name = Name::new_inline_ascii(4, b\"i128\");\n+pub const USIZE: Name = Name::new_inline_ascii(5, b\"usize\");\n+pub const U8: Name = Name::new_inline_ascii(2, b\"u8\");\n+pub const U16: Name = Name::new_inline_ascii(3, b\"u16\");\n+pub const U32: Name = Name::new_inline_ascii(3, b\"u32\");\n+pub const U64: Name = Name::new_inline_ascii(3, b\"u64\");\n+pub const U128: Name = Name::new_inline_ascii(4, b\"u128\");\n+pub const F32: Name = Name::new_inline_ascii(3, b\"f32\");\n+pub const F64: Name = Name::new_inline_ascii(3, b\"f64\");\n+pub const BOOL: Name = Name::new_inline_ascii(4, b\"bool\");\n+pub const CHAR: Name = Name::new_inline_ascii(4, b\"char\");\n+pub const STR: Name = Name::new_inline_ascii(3, b\"str\");\n+\n+// Special names\n+pub const SELF_PARAM: Name = Name::new_inline_ascii(4, b\"self\");\n+pub const SELF_TYPE: Name = Name::new_inline_ascii(4, b\"Self\");\n+pub const MACRO_RULES: Name = Name::new_inline_ascii(11, b\"macro_rules\");\n+\n+// Components of known path (value or mod name)\n+pub const STD: Name = Name::new_inline_ascii(3, b\"std\");\n+pub const ITER: Name = Name::new_inline_ascii(4, b\"iter\");\n+pub const OPS: Name = Name::new_inline_ascii(3, b\"ops\");\n+pub const FUTURE: Name = Name::new_inline_ascii(6, b\"future\");\n+pub const RESULT: Name = Name::new_inline_ascii(6, b\"result\");\n+pub const BOXED: Name = Name::new_inline_ascii(5, b\"boxed\");\n+\n+// Components of known path (type name)\n+pub const INTO_ITERATOR_TYPE: Name = Name::new_inline_ascii(12, b\"IntoIterator\");\n+pub const ITEM_TYPE: Name = Name::new_inline_ascii(4, b\"Item\");\n+pub const TRY_TYPE: Name = Name::new_inline_ascii(3, b\"Try\");\n+pub const OK_TYPE: Name = Name::new_inline_ascii(2, b\"Ok\");\n+pub const FUTURE_TYPE: Name = Name::new_inline_ascii(6, b\"Future\");\n+pub const RESULT_TYPE: Name = Name::new_inline_ascii(6, b\"Result\");\n+pub const OUTPUT_TYPE: Name = Name::new_inline_ascii(6, b\"Output\");\n+pub const TARGET_TYPE: Name = Name::new_inline_ascii(6, b\"Target\");\n+pub const BOX_TYPE: Name = Name::new_inline_ascii(3, b\"Box\");"}, {"sha": "1a3f7667d2a25169f41f3d1dcd3057349f54d0c7", "filename": "crates/ra_hir_def/src/nameres.rs", "status": "added", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/16e620c052016010b2f17070a98bdc1e7e849ab3/crates%2Fra_hir_def%2Fsrc%2Fnameres.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16e620c052016010b2f17070a98bdc1e7e849ab3/crates%2Fra_hir_def%2Fsrc%2Fnameres.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Fnameres.rs?ref=16e620c052016010b2f17070a98bdc1e7e849ab3", "patch": "@@ -0,0 +1 @@\n+pub mod raw;"}, {"sha": "13b9fbf48f61cc179d267f3135e20bdf17e4e55b", "filename": "crates/ra_hir_def/src/nameres/raw.rs", "status": "renamed", "additions": 33, "deletions": 29, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/16e620c052016010b2f17070a98bdc1e7e849ab3/crates%2Fra_hir_def%2Fsrc%2Fnameres%2Fraw.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16e620c052016010b2f17070a98bdc1e7e849ab3/crates%2Fra_hir_def%2Fsrc%2Fnameres%2Fraw.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Fnameres%2Fraw.rs?ref=16e620c052016010b2f17070a98bdc1e7e849ab3", "patch": "@@ -2,6 +2,7 @@\n \n use std::{ops::Index, sync::Arc};\n \n+use hir_expand::{ast_id_map::AstIdMap, db::AstDatabase};\n use ra_arena::{impl_arena_id, map::ArenaMap, Arena, RawId};\n use ra_syntax::{\n     ast::{self, AttrsOwner, NameOwner},\n@@ -11,8 +12,11 @@ use test_utils::tested_by;\n \n use crate::{\n     attr::Attr,\n-    db::{AstDatabase, DefDatabase},\n-    AsName, AstIdMap, Either, FileAstId, HirFileId, ModuleSource, Name, Path, Source,\n+    db::DefDatabase2,\n+    either::Either,\n+    name::{AsName, Name},\n+    path::Path,\n+    FileAstId, HirFileId, ModuleSource, Source,\n };\n \n /// `RawItems` is a set of top-level items in a file (except for impls).\n@@ -48,7 +52,7 @@ impl ImportSourceMap {\n         self.map.insert(import, ptr)\n     }\n \n-    pub(crate) fn get(&self, source: &ModuleSource, import: ImportId) -> ImportSource {\n+    pub fn get(&self, source: &ModuleSource, import: ImportId) -> ImportSource {\n         let file = match source {\n             ModuleSource::SourceFile(file) => file.clone(),\n             ModuleSource::Module(m) => m.syntax().ancestors().find_map(SourceFile::cast).unwrap(),\n@@ -60,14 +64,14 @@ impl ImportSourceMap {\n \n impl RawItems {\n     pub(crate) fn raw_items_query(\n-        db: &(impl DefDatabase + AstDatabase),\n+        db: &(impl DefDatabase2 + AstDatabase),\n         file_id: HirFileId,\n     ) -> Arc<RawItems> {\n         db.raw_items_with_source_map(file_id).0\n     }\n \n     pub(crate) fn raw_items_with_source_map_query(\n-        db: &(impl DefDatabase + AstDatabase),\n+        db: &(impl DefDatabase2 + AstDatabase),\n         file_id: HirFileId,\n     ) -> (Arc<RawItems>, Arc<ImportSourceMap>) {\n         let mut collector = RawItemsCollector {\n@@ -87,7 +91,7 @@ impl RawItems {\n         (Arc::new(collector.raw_items), Arc::new(collector.source_map))\n     }\n \n-    pub(super) fn items(&self) -> &[RawItem] {\n+    pub fn items(&self) -> &[RawItem] {\n         &self.items\n     }\n }\n@@ -124,31 +128,31 @@ impl Index<Macro> for RawItems {\n type Attrs = Option<Arc<[Attr]>>;\n \n #[derive(Debug, PartialEq, Eq, Clone)]\n-pub(super) struct RawItem {\n+pub struct RawItem {\n     attrs: Attrs,\n-    pub(super) kind: RawItemKind,\n+    pub kind: RawItemKind,\n }\n \n impl RawItem {\n-    pub(super) fn attrs(&self) -> &[Attr] {\n+    pub fn attrs(&self) -> &[Attr] {\n         self.attrs.as_ref().map_or(&[], |it| &*it)\n     }\n }\n \n #[derive(Debug, PartialEq, Eq, Clone, Copy)]\n-pub(super) enum RawItemKind {\n+pub enum RawItemKind {\n     Module(Module),\n     Import(ImportId),\n     Def(Def),\n     Macro(Macro),\n }\n \n #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n-pub(super) struct Module(RawId);\n+pub struct Module(RawId);\n impl_arena_id!(Module);\n \n #[derive(Debug, PartialEq, Eq)]\n-pub(super) enum ModuleData {\n+pub enum ModuleData {\n     Declaration { name: Name, ast_id: FileAstId<ast::Module> },\n     Definition { name: Name, ast_id: FileAstId<ast::Module>, items: Vec<RawItem> },\n }\n@@ -159,26 +163,26 @@ impl_arena_id!(ImportId);\n \n #[derive(Debug, Clone, PartialEq, Eq)]\n pub struct ImportData {\n-    pub(super) path: Path,\n-    pub(super) alias: Option<Name>,\n-    pub(super) is_glob: bool,\n-    pub(super) is_prelude: bool,\n-    pub(super) is_extern_crate: bool,\n-    pub(super) is_macro_use: bool,\n+    pub path: Path,\n+    pub alias: Option<Name>,\n+    pub is_glob: bool,\n+    pub is_prelude: bool,\n+    pub is_extern_crate: bool,\n+    pub is_macro_use: bool,\n }\n \n #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n-pub(super) struct Def(RawId);\n+pub struct Def(RawId);\n impl_arena_id!(Def);\n \n #[derive(Debug, PartialEq, Eq)]\n-pub(super) struct DefData {\n-    pub(super) name: Name,\n-    pub(super) kind: DefKind,\n+pub struct DefData {\n+    pub name: Name,\n+    pub kind: DefKind,\n }\n \n #[derive(Debug, PartialEq, Eq, Clone, Copy)]\n-pub(super) enum DefKind {\n+pub enum DefKind {\n     Function(FileAstId<ast::FnDef>),\n     Struct(FileAstId<ast::StructDef>),\n     Union(FileAstId<ast::StructDef>),\n@@ -190,15 +194,15 @@ pub(super) enum DefKind {\n }\n \n #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n-pub(super) struct Macro(RawId);\n+pub struct Macro(RawId);\n impl_arena_id!(Macro);\n \n #[derive(Debug, PartialEq, Eq)]\n-pub(super) struct MacroData {\n-    pub(super) ast_id: FileAstId<ast::MacroCall>,\n-    pub(super) path: Path,\n-    pub(super) name: Option<Name>,\n-    pub(super) export: bool,\n+pub struct MacroData {\n+    pub ast_id: FileAstId<ast::MacroCall>,\n+    pub path: Path,\n+    pub name: Option<Name>,\n+    pub export: bool,\n }\n \n struct RawItemsCollector<DB> {", "previous_filename": "crates/ra_hir/src/nameres/raw.rs"}, {"sha": "fe060437df8f7fb688d0cb6e83dee99d0574ed59", "filename": "crates/ra_hir_def/src/path.rs", "status": "added", "additions": 423, "deletions": 0, "changes": 423, "blob_url": "https://github.com/rust-lang/rust/blob/16e620c052016010b2f17070a98bdc1e7e849ab3/crates%2Fra_hir_def%2Fsrc%2Fpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16e620c052016010b2f17070a98bdc1e7e849ab3/crates%2Fra_hir_def%2Fsrc%2Fpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Fpath.rs?ref=16e620c052016010b2f17070a98bdc1e7e849ab3", "patch": "@@ -0,0 +1,423 @@\n+//! FIXME: write short doc here\n+\n+use std::{iter, sync::Arc};\n+\n+use hir_expand::db::AstDatabase;\n+use ra_db::CrateId;\n+use ra_syntax::{\n+    ast::{self, NameOwner, TypeAscriptionOwner},\n+    AstNode,\n+};\n+\n+use crate::{\n+    name::{self, AsName, Name},\n+    type_ref::TypeRef,\n+    Source,\n+};\n+\n+#[derive(Debug, Clone, PartialEq, Eq, Hash)]\n+pub struct Path {\n+    pub kind: PathKind,\n+    pub segments: Vec<PathSegment>,\n+}\n+\n+#[derive(Debug, Clone, PartialEq, Eq, Hash)]\n+pub struct PathSegment {\n+    pub name: Name,\n+    pub args_and_bindings: Option<Arc<GenericArgs>>,\n+}\n+\n+/// Generic arguments to a path segment (e.g. the `i32` in `Option<i32>`). This\n+/// can (in the future) also include bindings of associated types, like in\n+/// `Iterator<Item = Foo>`.\n+#[derive(Debug, Clone, PartialEq, Eq, Hash)]\n+pub struct GenericArgs {\n+    pub args: Vec<GenericArg>,\n+    /// This specifies whether the args contain a Self type as the first\n+    /// element. This is the case for path segments like `<T as Trait>`, where\n+    /// `T` is actually a type parameter for the path `Trait` specifying the\n+    /// Self type. Otherwise, when we have a path `Trait<X, Y>`, the Self type\n+    /// is left out.\n+    pub has_self_type: bool,\n+    /// Associated type bindings like in `Iterator<Item = T>`.\n+    pub bindings: Vec<(Name, TypeRef)>,\n+}\n+\n+/// A single generic argument.\n+#[derive(Debug, Clone, PartialEq, Eq, Hash)]\n+pub enum GenericArg {\n+    Type(TypeRef),\n+    // or lifetime...\n+}\n+\n+#[derive(Debug, Clone, PartialEq, Eq, Hash)]\n+pub enum PathKind {\n+    Plain,\n+    Self_,\n+    Super,\n+    Crate,\n+    // Absolute path\n+    Abs,\n+    // Type based path like `<T>::foo`\n+    Type(Box<TypeRef>),\n+    // `$crate` from macro expansion\n+    DollarCrate(CrateId),\n+}\n+\n+impl Path {\n+    /// Calls `cb` with all paths, represented by this use item.\n+    pub fn expand_use_item(\n+        item_src: Source<ast::UseItem>,\n+        db: &impl AstDatabase,\n+        mut cb: impl FnMut(Path, &ast::UseTree, bool, Option<Name>),\n+    ) {\n+        if let Some(tree) = item_src.ast.use_tree() {\n+            expand_use_tree(None, tree, &|| item_src.file_id.macro_crate(db), &mut cb);\n+        }\n+    }\n+\n+    pub fn from_simple_segments(kind: PathKind, segments: impl IntoIterator<Item = Name>) -> Path {\n+        Path {\n+            kind,\n+            segments: segments\n+                .into_iter()\n+                .map(|name| PathSegment { name, args_and_bindings: None })\n+                .collect(),\n+        }\n+    }\n+\n+    /// Converts an `ast::Path` to `Path`. Works with use trees.\n+    /// DEPRECATED: It does not handle `$crate` from macro call.\n+    pub fn from_ast(path: ast::Path) -> Option<Path> {\n+        Path::parse(path, &|| None)\n+    }\n+\n+    /// Converts an `ast::Path` to `Path`. Works with use trees.\n+    /// It correctly handles `$crate` based path from macro call.\n+    pub fn from_src(source: Source<ast::Path>, db: &impl AstDatabase) -> Option<Path> {\n+        let file_id = source.file_id;\n+        Path::parse(source.ast, &|| file_id.macro_crate(db))\n+    }\n+\n+    fn parse(mut path: ast::Path, macro_crate: &impl Fn() -> Option<CrateId>) -> Option<Path> {\n+        let mut kind = PathKind::Plain;\n+        let mut segments = Vec::new();\n+        loop {\n+            let segment = path.segment()?;\n+\n+            if segment.has_colon_colon() {\n+                kind = PathKind::Abs;\n+            }\n+\n+            match segment.kind()? {\n+                ast::PathSegmentKind::Name(name) => {\n+                    if name.text() == \"$crate\" {\n+                        if let Some(macro_crate) = macro_crate() {\n+                            kind = PathKind::DollarCrate(macro_crate);\n+                            break;\n+                        }\n+                    }\n+\n+                    let args = segment\n+                        .type_arg_list()\n+                        .and_then(GenericArgs::from_ast)\n+                        .or_else(|| {\n+                            GenericArgs::from_fn_like_path_ast(\n+                                segment.param_list(),\n+                                segment.ret_type(),\n+                            )\n+                        })\n+                        .map(Arc::new);\n+                    let segment = PathSegment { name: name.as_name(), args_and_bindings: args };\n+                    segments.push(segment);\n+                }\n+                ast::PathSegmentKind::Type { type_ref, trait_ref } => {\n+                    assert!(path.qualifier().is_none()); // this can only occur at the first segment\n+\n+                    let self_type = TypeRef::from_ast(type_ref?);\n+\n+                    match trait_ref {\n+                        // <T>::foo\n+                        None => {\n+                            kind = PathKind::Type(Box::new(self_type));\n+                        }\n+                        // <T as Trait<A>>::Foo desugars to Trait<Self=T, A>::Foo\n+                        Some(trait_ref) => {\n+                            let path = Path::parse(trait_ref.path()?, macro_crate)?;\n+                            kind = path.kind;\n+                            let mut prefix_segments = path.segments;\n+                            prefix_segments.reverse();\n+                            segments.extend(prefix_segments);\n+                            // Insert the type reference (T in the above example) as Self parameter for the trait\n+                            let mut last_segment = segments.last_mut()?;\n+                            if last_segment.args_and_bindings.is_none() {\n+                                last_segment.args_and_bindings =\n+                                    Some(Arc::new(GenericArgs::empty()));\n+                            };\n+                            let args = last_segment.args_and_bindings.as_mut().unwrap();\n+                            let mut args_inner = Arc::make_mut(args);\n+                            args_inner.has_self_type = true;\n+                            args_inner.args.insert(0, GenericArg::Type(self_type));\n+                        }\n+                    }\n+                }\n+                ast::PathSegmentKind::CrateKw => {\n+                    kind = PathKind::Crate;\n+                    break;\n+                }\n+                ast::PathSegmentKind::SelfKw => {\n+                    kind = PathKind::Self_;\n+                    break;\n+                }\n+                ast::PathSegmentKind::SuperKw => {\n+                    kind = PathKind::Super;\n+                    break;\n+                }\n+            }\n+            path = match qualifier(&path) {\n+                Some(it) => it,\n+                None => break,\n+            };\n+        }\n+        segments.reverse();\n+        return Some(Path { kind, segments });\n+\n+        fn qualifier(path: &ast::Path) -> Option<ast::Path> {\n+            if let Some(q) = path.qualifier() {\n+                return Some(q);\n+            }\n+            // FIXME: this bottom up traversal is not too precise.\n+            // Should we handle do a top-down analysis, recording results?\n+            let use_tree_list = path.syntax().ancestors().find_map(ast::UseTreeList::cast)?;\n+            let use_tree = use_tree_list.parent_use_tree();\n+            use_tree.path()\n+        }\n+    }\n+\n+    /// Converts an `ast::NameRef` into a single-identifier `Path`.\n+    pub fn from_name_ref(name_ref: &ast::NameRef) -> Path {\n+        name_ref.as_name().into()\n+    }\n+\n+    /// `true` is this path is a single identifier, like `foo`\n+    pub fn is_ident(&self) -> bool {\n+        self.kind == PathKind::Plain && self.segments.len() == 1\n+    }\n+\n+    /// `true` if this path is just a standalone `self`\n+    pub fn is_self(&self) -> bool {\n+        self.kind == PathKind::Self_ && self.segments.is_empty()\n+    }\n+\n+    /// If this path is a single identifier, like `foo`, return its name.\n+    pub fn as_ident(&self) -> Option<&Name> {\n+        if self.kind != PathKind::Plain || self.segments.len() > 1 {\n+            return None;\n+        }\n+        self.segments.first().map(|s| &s.name)\n+    }\n+\n+    pub fn expand_macro_expr(&self) -> Option<Name> {\n+        self.as_ident().and_then(|name| Some(name.clone()))\n+    }\n+\n+    pub fn is_type_relative(&self) -> bool {\n+        match self.kind {\n+            PathKind::Type(_) => true,\n+            _ => false,\n+        }\n+    }\n+}\n+\n+impl GenericArgs {\n+    pub fn from_ast(node: ast::TypeArgList) -> Option<GenericArgs> {\n+        let mut args = Vec::new();\n+        for type_arg in node.type_args() {\n+            let type_ref = TypeRef::from_ast_opt(type_arg.type_ref());\n+            args.push(GenericArg::Type(type_ref));\n+        }\n+        // lifetimes ignored for now\n+        let mut bindings = Vec::new();\n+        for assoc_type_arg in node.assoc_type_args() {\n+            if let Some(name_ref) = assoc_type_arg.name_ref() {\n+                let name = name_ref.as_name();\n+                let type_ref = TypeRef::from_ast_opt(assoc_type_arg.type_ref());\n+                bindings.push((name, type_ref));\n+            }\n+        }\n+        if args.is_empty() && bindings.is_empty() {\n+            None\n+        } else {\n+            Some(GenericArgs { args, has_self_type: false, bindings })\n+        }\n+    }\n+\n+    /// Collect `GenericArgs` from the parts of a fn-like path, i.e. `Fn(X, Y)\n+    /// -> Z` (which desugars to `Fn<(X, Y), Output=Z>`).\n+    pub(crate) fn from_fn_like_path_ast(\n+        params: Option<ast::ParamList>,\n+        ret_type: Option<ast::RetType>,\n+    ) -> Option<GenericArgs> {\n+        let mut args = Vec::new();\n+        let mut bindings = Vec::new();\n+        if let Some(params) = params {\n+            let mut param_types = Vec::new();\n+            for param in params.params() {\n+                let type_ref = TypeRef::from_ast_opt(param.ascribed_type());\n+                param_types.push(type_ref);\n+            }\n+            let arg = GenericArg::Type(TypeRef::Tuple(param_types));\n+            args.push(arg);\n+        }\n+        if let Some(ret_type) = ret_type {\n+            let type_ref = TypeRef::from_ast_opt(ret_type.type_ref());\n+            bindings.push((name::OUTPUT_TYPE, type_ref))\n+        }\n+        if args.is_empty() && bindings.is_empty() {\n+            None\n+        } else {\n+            Some(GenericArgs { args, has_self_type: false, bindings })\n+        }\n+    }\n+\n+    pub(crate) fn empty() -> GenericArgs {\n+        GenericArgs { args: Vec::new(), has_self_type: false, bindings: Vec::new() }\n+    }\n+}\n+\n+impl From<Name> for Path {\n+    fn from(name: Name) -> Path {\n+        Path::from_simple_segments(PathKind::Plain, iter::once(name))\n+    }\n+}\n+\n+fn expand_use_tree(\n+    prefix: Option<Path>,\n+    tree: ast::UseTree,\n+    macro_crate: &impl Fn() -> Option<CrateId>,\n+    cb: &mut impl FnMut(Path, &ast::UseTree, bool, Option<Name>),\n+) {\n+    if let Some(use_tree_list) = tree.use_tree_list() {\n+        let prefix = match tree.path() {\n+            // E.g. use something::{{{inner}}};\n+            None => prefix,\n+            // E.g. `use something::{inner}` (prefix is `None`, path is `something`)\n+            // or `use something::{path::{inner::{innerer}}}` (prefix is `something::path`, path is `inner`)\n+            Some(path) => match convert_path(prefix, path, macro_crate) {\n+                Some(it) => Some(it),\n+                None => return, // FIXME: report errors somewhere\n+            },\n+        };\n+        for child_tree in use_tree_list.use_trees() {\n+            expand_use_tree(prefix.clone(), child_tree, macro_crate, cb);\n+        }\n+    } else {\n+        let alias = tree.alias().and_then(|a| a.name()).map(|a| a.as_name());\n+        if let Some(ast_path) = tree.path() {\n+            // Handle self in a path.\n+            // E.g. `use something::{self, <...>}`\n+            if ast_path.qualifier().is_none() {\n+                if let Some(segment) = ast_path.segment() {\n+                    if segment.kind() == Some(ast::PathSegmentKind::SelfKw) {\n+                        if let Some(prefix) = prefix {\n+                            cb(prefix, &tree, false, alias);\n+                            return;\n+                        }\n+                    }\n+                }\n+            }\n+            if let Some(path) = convert_path(prefix, ast_path, macro_crate) {\n+                let is_glob = tree.has_star();\n+                cb(path, &tree, is_glob, alias)\n+            }\n+            // FIXME: report errors somewhere\n+            // We get here if we do\n+        }\n+    }\n+}\n+\n+fn convert_path(\n+    prefix: Option<Path>,\n+    path: ast::Path,\n+    macro_crate: &impl Fn() -> Option<CrateId>,\n+) -> Option<Path> {\n+    let prefix = if let Some(qual) = path.qualifier() {\n+        Some(convert_path(prefix, qual, macro_crate)?)\n+    } else {\n+        prefix\n+    };\n+\n+    let segment = path.segment()?;\n+    let res = match segment.kind()? {\n+        ast::PathSegmentKind::Name(name) => {\n+            if name.text() == \"$crate\" {\n+                if let Some(krate) = macro_crate() {\n+                    return Some(Path::from_simple_segments(\n+                        PathKind::DollarCrate(krate),\n+                        iter::empty(),\n+                    ));\n+                }\n+            }\n+\n+            // no type args in use\n+            let mut res = prefix\n+                .unwrap_or_else(|| Path { kind: PathKind::Plain, segments: Vec::with_capacity(1) });\n+            res.segments.push(PathSegment {\n+                name: name.as_name(),\n+                args_and_bindings: None, // no type args in use\n+            });\n+            res\n+        }\n+        ast::PathSegmentKind::CrateKw => {\n+            if prefix.is_some() {\n+                return None;\n+            }\n+            Path::from_simple_segments(PathKind::Crate, iter::empty())\n+        }\n+        ast::PathSegmentKind::SelfKw => {\n+            if prefix.is_some() {\n+                return None;\n+            }\n+            Path::from_simple_segments(PathKind::Self_, iter::empty())\n+        }\n+        ast::PathSegmentKind::SuperKw => {\n+            if prefix.is_some() {\n+                return None;\n+            }\n+            Path::from_simple_segments(PathKind::Super, iter::empty())\n+        }\n+        ast::PathSegmentKind::Type { .. } => {\n+            // not allowed in imports\n+            return None;\n+        }\n+    };\n+    Some(res)\n+}\n+\n+pub mod known {\n+    use super::{Path, PathKind};\n+    use crate::name;\n+\n+    pub fn std_iter_into_iterator() -> Path {\n+        Path::from_simple_segments(\n+            PathKind::Abs,\n+            vec![name::STD, name::ITER, name::INTO_ITERATOR_TYPE],\n+        )\n+    }\n+\n+    pub fn std_ops_try() -> Path {\n+        Path::from_simple_segments(PathKind::Abs, vec![name::STD, name::OPS, name::TRY_TYPE])\n+    }\n+\n+    pub fn std_result_result() -> Path {\n+        Path::from_simple_segments(PathKind::Abs, vec![name::STD, name::RESULT, name::RESULT_TYPE])\n+    }\n+\n+    pub fn std_future_future() -> Path {\n+        Path::from_simple_segments(PathKind::Abs, vec![name::STD, name::FUTURE, name::FUTURE_TYPE])\n+    }\n+\n+    pub fn std_boxed_box() -> Path {\n+        Path::from_simple_segments(PathKind::Abs, vec![name::STD, name::BOXED, name::BOX_TYPE])\n+    }\n+}"}, {"sha": "8af061116de8719c7b68397e64d0a27a9acc302d", "filename": "crates/ra_hir_def/src/type_ref.rs", "status": "added", "additions": 162, "deletions": 0, "changes": 162, "blob_url": "https://github.com/rust-lang/rust/blob/16e620c052016010b2f17070a98bdc1e7e849ab3/crates%2Fra_hir_def%2Fsrc%2Ftype_ref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16e620c052016010b2f17070a98bdc1e7e849ab3/crates%2Fra_hir_def%2Fsrc%2Ftype_ref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Ftype_ref.rs?ref=16e620c052016010b2f17070a98bdc1e7e849ab3", "patch": "@@ -0,0 +1,162 @@\n+//! HIR for references to types. Paths in these are not yet resolved. They can\n+//! be directly created from an ast::TypeRef, without further queries.\n+\n+use ra_syntax::ast::{self, TypeAscriptionOwner, TypeBoundsOwner};\n+\n+use crate::path::Path;\n+\n+#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]\n+pub enum Mutability {\n+    Shared,\n+    Mut,\n+}\n+\n+impl Mutability {\n+    pub fn from_mutable(mutable: bool) -> Mutability {\n+        if mutable {\n+            Mutability::Mut\n+        } else {\n+            Mutability::Shared\n+        }\n+    }\n+\n+    pub fn as_keyword_for_ref(self) -> &'static str {\n+        match self {\n+            Mutability::Shared => \"\",\n+            Mutability::Mut => \"mut \",\n+        }\n+    }\n+\n+    pub fn as_keyword_for_ptr(self) -> &'static str {\n+        match self {\n+            Mutability::Shared => \"const \",\n+            Mutability::Mut => \"mut \",\n+        }\n+    }\n+}\n+\n+/// Compare ty::Ty\n+#[derive(Clone, PartialEq, Eq, Hash, Debug)]\n+pub enum TypeRef {\n+    Never,\n+    Placeholder,\n+    Tuple(Vec<TypeRef>),\n+    Path(Path),\n+    RawPtr(Box<TypeRef>, Mutability),\n+    Reference(Box<TypeRef>, Mutability),\n+    Array(Box<TypeRef> /*, Expr*/),\n+    Slice(Box<TypeRef>),\n+    /// A fn pointer. Last element of the vector is the return type.\n+    Fn(Vec<TypeRef>),\n+    // For\n+    ImplTrait(Vec<TypeBound>),\n+    DynTrait(Vec<TypeBound>),\n+    Error,\n+}\n+\n+#[derive(Clone, PartialEq, Eq, Hash, Debug)]\n+pub enum TypeBound {\n+    Path(Path),\n+    // also for<> bounds\n+    // also Lifetimes\n+    Error,\n+}\n+\n+impl TypeRef {\n+    /// Converts an `ast::TypeRef` to a `hir::TypeRef`.\n+    pub fn from_ast(node: ast::TypeRef) -> Self {\n+        match node {\n+            ast::TypeRef::ParenType(inner) => TypeRef::from_ast_opt(inner.type_ref()),\n+            ast::TypeRef::TupleType(inner) => {\n+                TypeRef::Tuple(inner.fields().map(TypeRef::from_ast).collect())\n+            }\n+            ast::TypeRef::NeverType(..) => TypeRef::Never,\n+            ast::TypeRef::PathType(inner) => {\n+                // FIXME: Use `Path::from_src`\n+                inner.path().and_then(Path::from_ast).map(TypeRef::Path).unwrap_or(TypeRef::Error)\n+            }\n+            ast::TypeRef::PointerType(inner) => {\n+                let inner_ty = TypeRef::from_ast_opt(inner.type_ref());\n+                let mutability = Mutability::from_mutable(inner.is_mut());\n+                TypeRef::RawPtr(Box::new(inner_ty), mutability)\n+            }\n+            ast::TypeRef::ArrayType(inner) => {\n+                TypeRef::Array(Box::new(TypeRef::from_ast_opt(inner.type_ref())))\n+            }\n+            ast::TypeRef::SliceType(inner) => {\n+                TypeRef::Slice(Box::new(TypeRef::from_ast_opt(inner.type_ref())))\n+            }\n+            ast::TypeRef::ReferenceType(inner) => {\n+                let inner_ty = TypeRef::from_ast_opt(inner.type_ref());\n+                let mutability = Mutability::from_mutable(inner.is_mut());\n+                TypeRef::Reference(Box::new(inner_ty), mutability)\n+            }\n+            ast::TypeRef::PlaceholderType(_inner) => TypeRef::Placeholder,\n+            ast::TypeRef::FnPointerType(inner) => {\n+                let ret_ty = TypeRef::from_ast_opt(inner.ret_type().and_then(|rt| rt.type_ref()));\n+                let mut params = if let Some(pl) = inner.param_list() {\n+                    pl.params().map(|p| p.ascribed_type()).map(TypeRef::from_ast_opt).collect()\n+                } else {\n+                    Vec::new()\n+                };\n+                params.push(ret_ty);\n+                TypeRef::Fn(params)\n+            }\n+            // for types are close enough for our purposes to the inner type for now...\n+            ast::TypeRef::ForType(inner) => TypeRef::from_ast_opt(inner.type_ref()),\n+            ast::TypeRef::ImplTraitType(inner) => {\n+                TypeRef::ImplTrait(type_bounds_from_ast(inner.type_bound_list()))\n+            }\n+            ast::TypeRef::DynTraitType(inner) => {\n+                TypeRef::DynTrait(type_bounds_from_ast(inner.type_bound_list()))\n+            }\n+        }\n+    }\n+\n+    pub fn from_ast_opt(node: Option<ast::TypeRef>) -> Self {\n+        if let Some(node) = node {\n+            TypeRef::from_ast(node)\n+        } else {\n+            TypeRef::Error\n+        }\n+    }\n+\n+    pub fn unit() -> TypeRef {\n+        TypeRef::Tuple(Vec::new())\n+    }\n+}\n+\n+pub(crate) fn type_bounds_from_ast(type_bounds_opt: Option<ast::TypeBoundList>) -> Vec<TypeBound> {\n+    if let Some(type_bounds) = type_bounds_opt {\n+        type_bounds.bounds().map(TypeBound::from_ast).collect()\n+    } else {\n+        vec![]\n+    }\n+}\n+\n+impl TypeBound {\n+    pub fn from_ast(node: ast::TypeBound) -> Self {\n+        match node.kind() {\n+            ast::TypeBoundKind::PathType(path_type) => {\n+                let path = match path_type.path() {\n+                    Some(p) => p,\n+                    None => return TypeBound::Error,\n+                };\n+                // FIXME: Use `Path::from_src`\n+                let path = match Path::from_ast(path) {\n+                    Some(p) => p,\n+                    None => return TypeBound::Error,\n+                };\n+                TypeBound::Path(path)\n+            }\n+            ast::TypeBoundKind::ForType(_) | ast::TypeBoundKind::Lifetime(_) => TypeBound::Error,\n+        }\n+    }\n+\n+    pub fn as_path(&self) -> Option<&Path> {\n+        match self {\n+            TypeBound::Path(p) => Some(p),\n+            _ => None,\n+        }\n+    }\n+}"}, {"sha": "3c0ef8f1c05a9eede76d7937d400e2112fd613a8", "filename": "crates/ra_hir_expand/src/lib.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/16e620c052016010b2f17070a98bdc1e7e849ab3/crates%2Fra_hir_expand%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16e620c052016010b2f17070a98bdc1e7e849ab3/crates%2Fra_hir_expand%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_expand%2Fsrc%2Flib.rs?ref=16e620c052016010b2f17070a98bdc1e7e849ab3", "patch": "@@ -12,7 +12,7 @@ use std::hash::{Hash, Hasher};\n use ra_db::{salsa, CrateId, FileId};\n use ra_syntax::ast::{self, AstNode};\n \n-use crate::{ast_id_map::FileAstId, db::AstDatabase};\n+use crate::ast_id_map::FileAstId;\n \n /// Input to the analyzer is a set of files, where each file is identified by\n /// `FileId` and contains source code. However, another source of source code in\n@@ -50,7 +50,7 @@ impl From<MacroFile> for HirFileId {\n impl HirFileId {\n     /// For macro-expansion files, returns the file original source file the\n     /// expansion originated from.\n-    pub fn original_file(self, db: &dyn AstDatabase) -> FileId {\n+    pub fn original_file(self, db: &dyn db::AstDatabase) -> FileId {\n         match self.0 {\n             HirFileIdRepr::FileId(file_id) => file_id,\n             HirFileIdRepr::MacroFile(macro_file) => {\n@@ -61,7 +61,7 @@ impl HirFileId {\n     }\n \n     /// Get the crate which the macro lives in, if it is a macro file.\n-    pub fn macro_crate(self, db: &dyn AstDatabase) -> Option<CrateId> {\n+    pub fn macro_crate(self, db: &dyn db::AstDatabase) -> Option<CrateId> {\n         match self.0 {\n             HirFileIdRepr::FileId(_) => None,\n             HirFileIdRepr::MacroFile(macro_file) => {\n@@ -154,7 +154,7 @@ impl<N: AstNode> AstId<N> {\n         self.file_id\n     }\n \n-    pub fn to_node(&self, db: &dyn AstDatabase) -> N {\n+    pub fn to_node(&self, db: &dyn db::AstDatabase) -> N {\n         let root = db.parse_or_expand(self.file_id).unwrap();\n         db.ast_id_map(self.file_id).get(self.file_ast_id).to_node(&root)\n     }"}]}