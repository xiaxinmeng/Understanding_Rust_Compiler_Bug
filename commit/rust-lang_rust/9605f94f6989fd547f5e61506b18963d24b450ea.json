{"sha": "9605f94f6989fd547f5e61506b18963d24b450ea", "node_id": "MDY6Q29tbWl0NzI0NzEyOjk2MDVmOTRmNjk4OWZkNTQ3ZjVlNjE1MDZiMTg5NjNkMjRiNDUwZWE=", "commit": {"author": {"name": "Dylan DPC", "email": "dylan.dpc@gmail.com", "date": "2020-09-03T00:22:02Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2020-09-03T00:22:02Z"}, "message": "Rollup merge of #76142 - CDirkx:const-ip, r=ecstatic-morse\n\nMake all methods of `std::net::Ipv4Addr` const\n\nMake the following methods of `std::net::Ipv4Addr` unstable const under the `const_ipv4` feature:\n - `octets`\n - `is_loopback`\n - `is_private`\n - `is_link_local`\n - `is_global` (unstable)\n - `is_shared` (unstable)\n - `is_ietf_protocol_assignment` (unstable)\n - `is_benchmarking` (unstable)\n - `is_reserved` (unstable)\n - `is_multicast`\n - `is_broadcast`\n - `is_documentation`\n - `to_ipv6_compatible`\n - `to_ipv6_mapped`\n\nThis would make all methods of `Ipv6Addr` const.\n\nOf these methods, `is_global`, `is_broadcast`, `to_ipv6_compatible`, and `to_ipv6_mapped` require a change in implementation.\n\nPart of #76205", "tree": {"sha": "7da8a2202b7241447b1ca151d50abb378d70961f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7da8a2202b7241447b1ca151d50abb378d70961f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9605f94f6989fd547f5e61506b18963d24b450ea", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJfUDcqCRBK7hj4Ov3rIwAAdHIIAFIpz8ECZNVCj/v3SUh9wbNV\nS7Wl4qHspLoi7BQm4QZp3JrdTft4/hM4MrhIdIi0lYi99DNGD/frrEf6XfYJweAD\nG1Wit2FaexEEiuHWHdUn4ek6Psr6iTYAVQVSDDpW1+2MQ+kRrBiqnXfmutHE7cq6\nrlkepMxecR4AC0GKvJjSFr6C3jTY0GMiy3vRwUIoQOvWrxXFtHYAjwILRDVGH7oh\n1Z2qAtfDlrobKDexChNRaXOG7ZlcpUtUQhU1O0KOao8+te3iiWvNekbgR/h5msuW\nzK7rCFnd1Jd6MxkZhDhxN9rV2p7PeNa76UZ8jM6XGzYDHed/COqml5Qy6wqkRDs=\n=AKdJ\n-----END PGP SIGNATURE-----\n", "payload": "tree 7da8a2202b7241447b1ca151d50abb378d70961f\nparent 10aa3d3f89195f6cab93700f2514744c814a4881\nparent 0c77257e56a20a81f5b4e4452cae5e460ad30140\nauthor Dylan DPC <dylan.dpc@gmail.com> 1599092522 +0200\ncommitter GitHub <noreply@github.com> 1599092522 +0200\n\nRollup merge of #76142 - CDirkx:const-ip, r=ecstatic-morse\n\nMake all methods of `std::net::Ipv4Addr` const\n\nMake the following methods of `std::net::Ipv4Addr` unstable const under the `const_ipv4` feature:\n - `octets`\n - `is_loopback`\n - `is_private`\n - `is_link_local`\n - `is_global` (unstable)\n - `is_shared` (unstable)\n - `is_ietf_protocol_assignment` (unstable)\n - `is_benchmarking` (unstable)\n - `is_reserved` (unstable)\n - `is_multicast`\n - `is_broadcast`\n - `is_documentation`\n - `to_ipv6_compatible`\n - `to_ipv6_mapped`\n\nThis would make all methods of `Ipv6Addr` const.\n\nOf these methods, `is_global`, `is_broadcast`, `to_ipv6_compatible`, and `to_ipv6_mapped` require a change in implementation.\n\nPart of #76205\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9605f94f6989fd547f5e61506b18963d24b450ea", "html_url": "https://github.com/rust-lang/rust/commit/9605f94f6989fd547f5e61506b18963d24b450ea", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9605f94f6989fd547f5e61506b18963d24b450ea/comments", "author": {"login": "Dylan-DPC", "id": 99973273, "node_id": "U_kgDOBfV4mQ", "avatar_url": "https://avatars.githubusercontent.com/u/99973273?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Dylan-DPC", "html_url": "https://github.com/Dylan-DPC", "followers_url": "https://api.github.com/users/Dylan-DPC/followers", "following_url": "https://api.github.com/users/Dylan-DPC/following{/other_user}", "gists_url": "https://api.github.com/users/Dylan-DPC/gists{/gist_id}", "starred_url": "https://api.github.com/users/Dylan-DPC/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Dylan-DPC/subscriptions", "organizations_url": "https://api.github.com/users/Dylan-DPC/orgs", "repos_url": "https://api.github.com/users/Dylan-DPC/repos", "events_url": "https://api.github.com/users/Dylan-DPC/events{/privacy}", "received_events_url": "https://api.github.com/users/Dylan-DPC/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "10aa3d3f89195f6cab93700f2514744c814a4881", "url": "https://api.github.com/repos/rust-lang/rust/commits/10aa3d3f89195f6cab93700f2514744c814a4881", "html_url": "https://github.com/rust-lang/rust/commit/10aa3d3f89195f6cab93700f2514744c814a4881"}, {"sha": "0c77257e56a20a81f5b4e4452cae5e460ad30140", "url": "https://api.github.com/repos/rust-lang/rust/commits/0c77257e56a20a81f5b4e4452cae5e460ad30140", "html_url": "https://github.com/rust-lang/rust/commit/0c77257e56a20a81f5b4e4452cae5e460ad30140"}], "stats": {"total": 115, "additions": 97, "deletions": 18}, "files": [{"sha": "dc57c1c1f44db7198be286c6348fc3e65dc62766", "filename": "library/std/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/9605f94f6989fd547f5e61506b18963d24b450ea/library%2Fstd%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9605f94f6989fd547f5e61506b18963d24b450ea/library%2Fstd%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Flib.rs?ref=9605f94f6989fd547f5e61506b18963d24b450ea", "patch": "@@ -240,6 +240,7 @@\n #![feature(const_fn_transmute)]\n #![feature(const_ipv6)]\n #![feature(const_raw_ptr_deref)]\n+#![feature(const_ipv4)]\n #![feature(container_error_extra)]\n #![feature(core_intrinsics)]\n #![feature(custom_test_frameworks)]"}, {"sha": "3f9afae880f932d0f3fed9763480fddb1d2802c0", "filename": "library/std/src/net/ip.rs", "status": "modified", "additions": 38, "deletions": 18, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/9605f94f6989fd547f5e61506b18963d24b450ea/library%2Fstd%2Fsrc%2Fnet%2Fip.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9605f94f6989fd547f5e61506b18963d24b450ea/library%2Fstd%2Fsrc%2Fnet%2Fip.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fnet%2Fip.rs?ref=9605f94f6989fd547f5e61506b18963d24b450ea", "patch": "@@ -365,8 +365,9 @@ impl Ipv4Addr {\n     /// let addr = Ipv4Addr::new(127, 0, 0, 1);\n     /// assert_eq!(addr.octets(), [127, 0, 0, 1]);\n     /// ```\n+    #[rustc_const_unstable(feature = \"const_ipv4\", issue = \"76205\")]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn octets(&self) -> [u8; 4] {\n+    pub const fn octets(&self) -> [u8; 4] {\n         // This returns the order we want because s_addr is stored in big-endian.\n         self.inner.s_addr.to_ne_bytes()\n     }\n@@ -408,8 +409,9 @@ impl Ipv4Addr {\n     /// assert_eq!(Ipv4Addr::new(127, 0, 0, 1).is_loopback(), true);\n     /// assert_eq!(Ipv4Addr::new(45, 22, 13, 197).is_loopback(), false);\n     /// ```\n+    #[rustc_const_unstable(feature = \"const_ipv4\", issue = \"76205\")]\n     #[stable(since = \"1.7.0\", feature = \"ip_17\")]\n-    pub fn is_loopback(&self) -> bool {\n+    pub const fn is_loopback(&self) -> bool {\n         self.octets()[0] == 127\n     }\n \n@@ -437,8 +439,9 @@ impl Ipv4Addr {\n     /// assert_eq!(Ipv4Addr::new(192, 168, 0, 2).is_private(), true);\n     /// assert_eq!(Ipv4Addr::new(192, 169, 0, 2).is_private(), false);\n     /// ```\n+    #[rustc_const_unstable(feature = \"const_ipv4\", issue = \"76205\")]\n     #[stable(since = \"1.7.0\", feature = \"ip_17\")]\n-    pub fn is_private(&self) -> bool {\n+    pub const fn is_private(&self) -> bool {\n         match self.octets() {\n             [10, ..] => true,\n             [172, b, ..] if b >= 16 && b <= 31 => true,\n@@ -463,8 +466,9 @@ impl Ipv4Addr {\n     /// assert_eq!(Ipv4Addr::new(169, 254, 10, 65).is_link_local(), true);\n     /// assert_eq!(Ipv4Addr::new(16, 89, 10, 65).is_link_local(), false);\n     /// ```\n+    #[rustc_const_unstable(feature = \"const_ipv4\", issue = \"76205\")]\n     #[stable(since = \"1.7.0\", feature = \"ip_17\")]\n-    pub fn is_link_local(&self) -> bool {\n+    pub const fn is_link_local(&self) -> bool {\n         match self.octets() {\n             [169, 254, ..] => true,\n             _ => false,\n@@ -542,10 +546,13 @@ impl Ipv4Addr {\n     /// assert_eq!(Ipv4Addr::new(1, 1, 1, 1).is_global(), true);\n     /// assert_eq!(Ipv4Addr::new(80, 9, 12, 3).is_global(), true);\n     /// ```\n-    pub fn is_global(&self) -> bool {\n+    #[rustc_const_unstable(feature = \"const_ipv4\", issue = \"76205\")]\n+    pub const fn is_global(&self) -> bool {\n         // check if this address is 192.0.0.9 or 192.0.0.10. These addresses are the only two\n         // globally routable addresses in the 192.0.0.0/24 range.\n-        if u32::from(*self) == 0xc0000009 || u32::from(*self) == 0xc000000a {\n+        if u32::from_be_bytes(self.octets()) == 0xc0000009\n+            || u32::from_be_bytes(self.octets()) == 0xc000000a\n+        {\n             return true;\n         }\n         !self.is_private()\n@@ -577,7 +584,8 @@ impl Ipv4Addr {\n     /// assert_eq!(Ipv4Addr::new(100, 127, 255, 255).is_shared(), true);\n     /// assert_eq!(Ipv4Addr::new(100, 128, 0, 0).is_shared(), false);\n     /// ```\n-    pub fn is_shared(&self) -> bool {\n+    #[rustc_const_unstable(feature = \"const_ipv4\", issue = \"76205\")]\n+    pub const fn is_shared(&self) -> bool {\n         self.octets()[0] == 100 && (self.octets()[1] & 0b1100_0000 == 0b0100_0000)\n     }\n \n@@ -609,7 +617,8 @@ impl Ipv4Addr {\n     /// assert_eq!(Ipv4Addr::new(192, 0, 1, 0).is_ietf_protocol_assignment(), false);\n     /// assert_eq!(Ipv4Addr::new(191, 255, 255, 255).is_ietf_protocol_assignment(), false);\n     /// ```\n-    pub fn is_ietf_protocol_assignment(&self) -> bool {\n+    #[rustc_const_unstable(feature = \"const_ipv4\", issue = \"76205\")]\n+    pub const fn is_ietf_protocol_assignment(&self) -> bool {\n         self.octets()[0] == 192 && self.octets()[1] == 0 && self.octets()[2] == 0\n     }\n \n@@ -632,7 +641,8 @@ impl Ipv4Addr {\n     /// assert_eq!(Ipv4Addr::new(198, 19, 255, 255).is_benchmarking(), true);\n     /// assert_eq!(Ipv4Addr::new(198, 20, 0, 0).is_benchmarking(), false);\n     /// ```\n-    pub fn is_benchmarking(&self) -> bool {\n+    #[rustc_const_unstable(feature = \"const_ipv4\", issue = \"76205\")]\n+    pub const fn is_benchmarking(&self) -> bool {\n         self.octets()[0] == 198 && (self.octets()[1] & 0xfe) == 18\n     }\n \n@@ -664,7 +674,8 @@ impl Ipv4Addr {\n     /// // The broadcast address is not considered as reserved for future use by this implementation\n     /// assert_eq!(Ipv4Addr::new(255, 255, 255, 255).is_reserved(), false);\n     /// ```\n-    pub fn is_reserved(&self) -> bool {\n+    #[rustc_const_unstable(feature = \"const_ipv4\", issue = \"76205\")]\n+    pub const fn is_reserved(&self) -> bool {\n         self.octets()[0] & 240 == 240 && !self.is_broadcast()\n     }\n \n@@ -685,8 +696,9 @@ impl Ipv4Addr {\n     /// assert_eq!(Ipv4Addr::new(236, 168, 10, 65).is_multicast(), true);\n     /// assert_eq!(Ipv4Addr::new(172, 16, 10, 65).is_multicast(), false);\n     /// ```\n+    #[rustc_const_unstable(feature = \"const_ipv4\", issue = \"76205\")]\n     #[stable(since = \"1.7.0\", feature = \"ip_17\")]\n-    pub fn is_multicast(&self) -> bool {\n+    pub const fn is_multicast(&self) -> bool {\n         self.octets()[0] >= 224 && self.octets()[0] <= 239\n     }\n \n@@ -705,9 +717,10 @@ impl Ipv4Addr {\n     /// assert_eq!(Ipv4Addr::new(255, 255, 255, 255).is_broadcast(), true);\n     /// assert_eq!(Ipv4Addr::new(236, 168, 10, 65).is_broadcast(), false);\n     /// ```\n+    #[rustc_const_unstable(feature = \"const_ipv4\", issue = \"76205\")]\n     #[stable(since = \"1.7.0\", feature = \"ip_17\")]\n-    pub fn is_broadcast(&self) -> bool {\n-        self == &Self::BROADCAST\n+    pub const fn is_broadcast(&self) -> bool {\n+        u32::from_be_bytes(self.octets()) == u32::from_be_bytes(Self::BROADCAST.octets())\n     }\n \n     /// Returns [`true`] if this address is in a range designated for documentation.\n@@ -731,8 +744,9 @@ impl Ipv4Addr {\n     /// assert_eq!(Ipv4Addr::new(203, 0, 113, 6).is_documentation(), true);\n     /// assert_eq!(Ipv4Addr::new(193, 34, 17, 19).is_documentation(), false);\n     /// ```\n+    #[rustc_const_unstable(feature = \"const_ipv4\", issue = \"76205\")]\n     #[stable(since = \"1.7.0\", feature = \"ip_17\")]\n-    pub fn is_documentation(&self) -> bool {\n+    pub const fn is_documentation(&self) -> bool {\n         match self.octets() {\n             [192, 0, 2, _] => true,\n             [198, 51, 100, _] => true,\n@@ -760,10 +774,13 @@ impl Ipv4Addr {\n     ///     Ipv6Addr::new(0, 0, 0, 0, 0, 0, 49152, 767)\n     /// );\n     /// ```\n+    #[rustc_const_unstable(feature = \"const_ipv4\", issue = \"76205\")]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn to_ipv6_compatible(&self) -> Ipv6Addr {\n+    pub const fn to_ipv6_compatible(&self) -> Ipv6Addr {\n         let [a, b, c, d] = self.octets();\n-        Ipv6Addr::from([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, a, b, c, d])\n+        Ipv6Addr {\n+            inner: c::in6_addr { s6_addr: [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, a, b, c, d] },\n+        }\n     }\n \n     /// Converts this address to an IPv4-mapped [`IPv6` address].\n@@ -780,10 +797,13 @@ impl Ipv4Addr {\n     /// assert_eq!(Ipv4Addr::new(192, 0, 2, 255).to_ipv6_mapped(),\n     ///            Ipv6Addr::new(0, 0, 0, 0, 0, 65535, 49152, 767));\n     /// ```\n+    #[rustc_const_unstable(feature = \"const_ipv4\", issue = \"76205\")]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn to_ipv6_mapped(&self) -> Ipv6Addr {\n+    pub const fn to_ipv6_mapped(&self) -> Ipv6Addr {\n         let [a, b, c, d] = self.octets();\n-        Ipv6Addr::from([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0xFF, 0xFF, a, b, c, d])\n+        Ipv6Addr {\n+            inner: c::in6_addr { s6_addr: [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0xFF, 0xFF, a, b, c, d] },\n+        }\n     }\n }\n "}, {"sha": "8c676999ae734c1952b339ad6a99b9b6403368d9", "filename": "src/test/ui/consts/std/net/ipv4.rs", "status": "added", "additions": 58, "deletions": 0, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/9605f94f6989fd547f5e61506b18963d24b450ea/src%2Ftest%2Fui%2Fconsts%2Fstd%2Fnet%2Fipv4.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9605f94f6989fd547f5e61506b18963d24b450ea/src%2Ftest%2Fui%2Fconsts%2Fstd%2Fnet%2Fipv4.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fstd%2Fnet%2Fipv4.rs?ref=9605f94f6989fd547f5e61506b18963d24b450ea", "patch": "@@ -0,0 +1,58 @@\n+// run-pass\n+\n+#![feature(ip)]\n+#![feature(const_ipv4)]\n+\n+use std::net::{Ipv4Addr, Ipv6Addr};\n+\n+fn main() {\n+    const IP_ADDRESS: Ipv4Addr = Ipv4Addr::new(127, 0, 0, 1);\n+    assert_eq!(IP_ADDRESS, Ipv4Addr::LOCALHOST);\n+\n+    const OCTETS: [u8; 4] = IP_ADDRESS.octets();\n+    assert_eq!(OCTETS, [127, 0, 0, 1]);\n+\n+    const IS_UNSPECIFIED : bool = IP_ADDRESS.is_unspecified();\n+    assert!(!IS_UNSPECIFIED);\n+\n+    const IS_LOOPBACK : bool = IP_ADDRESS.is_loopback();\n+    assert!(IS_LOOPBACK);\n+\n+    const IS_PRIVATE : bool = IP_ADDRESS.is_private();\n+    assert!(!IS_PRIVATE);\n+\n+    const IS_LINK_LOCAL : bool = IP_ADDRESS.is_link_local();\n+    assert!(!IS_LINK_LOCAL);\n+\n+    const IS_GLOBAL : bool = IP_ADDRESS.is_global();\n+    assert!(!IS_GLOBAL);\n+\n+    const IS_SHARED : bool = IP_ADDRESS.is_shared();\n+    assert!(!IS_SHARED);\n+\n+    const IS_IETF_PROTOCOL_ASSIGNMENT : bool = IP_ADDRESS.is_ietf_protocol_assignment();\n+    assert!(!IS_IETF_PROTOCOL_ASSIGNMENT);\n+\n+    const IS_BENCHMARKING : bool = IP_ADDRESS.is_benchmarking();\n+    assert!(!IS_BENCHMARKING);\n+\n+    const IS_RESERVED : bool = IP_ADDRESS.is_reserved();\n+    assert!(!IS_RESERVED);\n+\n+    const IS_MULTICAST : bool = IP_ADDRESS.is_multicast();\n+    assert!(!IS_MULTICAST);\n+\n+    const IS_BROADCAST : bool = IP_ADDRESS.is_broadcast();\n+    assert!(!IS_BROADCAST);\n+\n+    const IS_DOCUMENTATION : bool = IP_ADDRESS.is_documentation();\n+    assert!(!IS_DOCUMENTATION);\n+\n+    const IP_V6_COMPATIBLE : Ipv6Addr = IP_ADDRESS.to_ipv6_compatible();\n+    assert_eq!(IP_V6_COMPATIBLE,\n+        Ipv6Addr::from([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 127, 0, 0, 1]));\n+\n+    const IP_V6_MAPPED : Ipv6Addr = IP_ADDRESS.to_ipv6_mapped();\n+    assert_eq!(IP_V6_MAPPED,\n+        Ipv6Addr::from([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 255, 255, 127, 0, 0, 1]));\n+}"}]}