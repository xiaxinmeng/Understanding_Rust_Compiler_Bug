{"sha": "31a07b0ce662e95119a76cce8dcfc29d2055f738", "node_id": "MDY6Q29tbWl0NzI0NzEyOjMxYTA3YjBjZTY2MmU5NTExOWE3NmNjZThkY2ZjMjlkMjA1NWY3Mzg=", "commit": {"author": {"name": "Eduard Burtescu", "email": "edy.burt@gmail.com", "date": "2016-05-02T15:07:47Z"}, "committer": {"name": "Eduard Burtescu", "email": "edy.burt@gmail.com", "date": "2016-05-11T01:14:58Z"}, "message": "rustc_typeck: Generalize over 'tcx != 'gcx.", "tree": {"sha": "377d11b243e3e4347b7019ca883c0847aed7014d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/377d11b243e3e4347b7019ca883c0847aed7014d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/31a07b0ce662e95119a76cce8dcfc29d2055f738", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/31a07b0ce662e95119a76cce8dcfc29d2055f738", "html_url": "https://github.com/rust-lang/rust/commit/31a07b0ce662e95119a76cce8dcfc29d2055f738", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/31a07b0ce662e95119a76cce8dcfc29d2055f738/comments", "author": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "committer": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3a3013613a437e0f10cf3d978c9352c94dc284df", "url": "https://api.github.com/repos/rust-lang/rust/commits/3a3013613a437e0f10cf3d978c9352c94dc284df", "html_url": "https://github.com/rust-lang/rust/commit/3a3013613a437e0f10cf3d978c9352c94dc284df"}], "stats": {"total": 1830, "additions": 942, "deletions": 888}, "files": [{"sha": "e6d9db20eceffd9b511b7e43f3f3a43df7bc5939", "filename": "src/librustc/infer/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/31a07b0ce662e95119a76cce8dcfc29d2055f738/src%2Flibrustc%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31a07b0ce662e95119a76cce8dcfc29d2055f738/src%2Flibrustc%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fmod.rs?ref=31a07b0ce662e95119a76cce8dcfc29d2055f738", "patch": "@@ -89,7 +89,7 @@ pub struct InferCtxt<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n     float_unification_table: RefCell<UnificationTable<ty::FloatVid>>,\n \n     // For region variables.\n-    region_vars: RegionVarBindings<'a, 'tcx>,\n+    region_vars: RegionVarBindings<'a, 'gcx, 'tcx>,\n \n     pub parameter_environment: ty::ParameterEnvironment<'gcx>,\n "}, {"sha": "c9037d6b12aa8ee7302a4e1cae6d7417a881e83b", "filename": "src/librustc/infer/region_inference/graphviz.rs", "status": "modified", "additions": 15, "deletions": 13, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/31a07b0ce662e95119a76cce8dcfc29d2055f738/src%2Flibrustc%2Finfer%2Fregion_inference%2Fgraphviz.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31a07b0ce662e95119a76cce8dcfc29d2055f738/src%2Flibrustc%2Finfer%2Fregion_inference%2Fgraphviz.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fregion_inference%2Fgraphviz.rs?ref=31a07b0ce662e95119a76cce8dcfc29d2055f738", "patch": "@@ -53,8 +53,10 @@ graphs will be printed.                                                     \\n\\\n \");\n }\n \n-pub fn maybe_print_constraints_for<'a, 'tcx>(region_vars: &RegionVarBindings<'a, 'tcx>,\n-                                             subject_node: ast::NodeId) {\n+pub fn maybe_print_constraints_for<'a, 'gcx, 'tcx>(\n+    region_vars: &RegionVarBindings<'a, 'gcx, 'tcx>,\n+    subject_node: ast::NodeId)\n+{\n     let tcx = region_vars.tcx;\n \n     if !region_vars.tcx.sess.opts.debugging_opts.print_region_graph {\n@@ -118,8 +120,8 @@ pub fn maybe_print_constraints_for<'a, 'tcx>(region_vars: &RegionVarBindings<'a,\n     }\n }\n \n-struct ConstraintGraph<'a, 'tcx: 'a> {\n-    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+struct ConstraintGraph<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n+    tcx: TyCtxt<'a, 'gcx, 'tcx>,\n     graph_name: String,\n     map: &'a FnvHashMap<Constraint, SubregionOrigin<'tcx>>,\n     node_ids: FnvHashMap<Node, usize>,\n@@ -138,11 +140,11 @@ enum Edge {\n     EnclScope(CodeExtent, CodeExtent),\n }\n \n-impl<'a, 'tcx> ConstraintGraph<'a, 'tcx> {\n-    fn new(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+impl<'a, 'gcx, 'tcx> ConstraintGraph<'a, 'gcx, 'tcx> {\n+    fn new(tcx: TyCtxt<'a, 'gcx, 'tcx>,\n            name: String,\n            map: &'a ConstraintMap<'tcx>)\n-           -> ConstraintGraph<'a, 'tcx> {\n+           -> ConstraintGraph<'a, 'gcx, 'tcx> {\n         let mut i = 0;\n         let mut node_ids = FnvHashMap();\n         {\n@@ -173,7 +175,7 @@ impl<'a, 'tcx> ConstraintGraph<'a, 'tcx> {\n     }\n }\n \n-impl<'a, 'tcx> dot::Labeller<'a> for ConstraintGraph<'a, 'tcx> {\n+impl<'a, 'gcx, 'tcx> dot::Labeller<'a> for ConstraintGraph<'a, 'gcx, 'tcx> {\n     type Node = Node;\n     type Edge = Edge;\n     fn graph_id(&self) -> dot::Id {\n@@ -226,7 +228,7 @@ fn edge_to_nodes(e: &Edge) -> (Node, Node) {\n     }\n }\n \n-impl<'a, 'tcx> dot::GraphWalk<'a> for ConstraintGraph<'a, 'tcx> {\n+impl<'a, 'gcx, 'tcx> dot::GraphWalk<'a> for ConstraintGraph<'a, 'gcx, 'tcx> {\n     type Node = Node;\n     type Edge = Edge;\n     fn nodes(&self) -> dot::Nodes<Node> {\n@@ -258,10 +260,10 @@ impl<'a, 'tcx> dot::GraphWalk<'a> for ConstraintGraph<'a, 'tcx> {\n \n pub type ConstraintMap<'tcx> = FnvHashMap<Constraint, SubregionOrigin<'tcx>>;\n \n-fn dump_region_constraints_to<'a, 'tcx: 'a>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                                            map: &ConstraintMap<'tcx>,\n-                                            path: &str)\n-                                            -> io::Result<()> {\n+fn dump_region_constraints_to<'a, 'gcx, 'tcx>(tcx: TyCtxt<'a, 'gcx, 'tcx>,\n+                                              map: &ConstraintMap<'tcx>,\n+                                              path: &str)\n+                                              -> io::Result<()> {\n     debug!(\"dump_region_constraints map (len: {}) path: {}\",\n            map.len(),\n            path);"}, {"sha": "b889d0a9daab6259037fffa03cf6bc348c59da20", "filename": "src/librustc/infer/region_inference/mod.rs", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/31a07b0ce662e95119a76cce8dcfc29d2055f738/src%2Flibrustc%2Finfer%2Fregion_inference%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31a07b0ce662e95119a76cce8dcfc29d2055f738/src%2Flibrustc%2Finfer%2Fregion_inference%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fregion_inference%2Fmod.rs?ref=31a07b0ce662e95119a76cce8dcfc29d2055f738", "patch": "@@ -190,8 +190,8 @@ impl SameRegions {\n \n pub type CombineMap = FnvHashMap<TwoRegions, RegionVid>;\n \n-pub struct RegionVarBindings<'a, 'tcx: 'a> {\n-    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+pub struct RegionVarBindings<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n+    tcx: TyCtxt<'a, 'gcx, 'tcx>,\n     var_origins: RefCell<Vec<RegionVariableOrigin>>,\n \n     // Constraints of the form `A <= B` introduced by the region\n@@ -253,8 +253,8 @@ pub struct RegionSnapshot {\n     skolemization_count: u32,\n }\n \n-impl<'a, 'tcx> RegionVarBindings<'a, 'tcx> {\n-    pub fn new(tcx: TyCtxt<'a, 'tcx, 'tcx>) -> RegionVarBindings<'a, 'tcx> {\n+impl<'a, 'gcx, 'tcx> RegionVarBindings<'a, 'gcx, 'tcx> {\n+    pub fn new(tcx: TyCtxt<'a, 'gcx, 'tcx>) -> RegionVarBindings<'a, 'gcx, 'tcx> {\n         RegionVarBindings {\n             tcx: tcx,\n             var_origins: RefCell::new(Vec::new()),\n@@ -600,7 +600,7 @@ impl<'a, 'tcx> RegionVarBindings<'a, 'tcx> {\n                            origin: SubregionOrigin<'tcx>,\n                            mut relate: F)\n                            -> Region\n-        where F: FnMut(&RegionVarBindings<'a, 'tcx>, Region, Region)\n+        where F: FnMut(&RegionVarBindings<'a, 'gcx, 'tcx>, Region, Region)\n     {\n         let vars = TwoRegions { a: a, b: b };\n         match self.combine_map(t).borrow().get(&vars) {\n@@ -816,7 +816,7 @@ struct RegionAndOrigin<'tcx> {\n \n type RegionGraph = graph::Graph<(), Constraint>;\n \n-impl<'a, 'tcx> RegionVarBindings<'a, 'tcx> {\n+impl<'a, 'gcx, 'tcx> RegionVarBindings<'a, 'gcx, 'tcx> {\n     fn infer_variable_values(&self,\n                              free_regions: &FreeRegionMap,\n                              errors: &mut Vec<RegionResolutionError<'tcx>>,\n@@ -1249,11 +1249,11 @@ impl<'a, 'tcx> RegionVarBindings<'a, 'tcx> {\n         let WalkState {result, dup_found, ..} = state;\n         return (result, dup_found);\n \n-        fn process_edges<'a, 'tcx>(this: &RegionVarBindings<'a, 'tcx>,\n-                                   state: &mut WalkState<'tcx>,\n-                                   graph: &RegionGraph,\n-                                   source_vid: RegionVid,\n-                                   dir: Direction) {\n+        fn process_edges<'a, 'gcx, 'tcx>(this: &RegionVarBindings<'a, 'gcx, 'tcx>,\n+                                         state: &mut WalkState<'tcx>,\n+                                         graph: &RegionGraph,\n+                                         source_vid: RegionVid,\n+                                         dir: Direction) {\n             debug!(\"process_edges(source_vid={:?}, dir={:?})\", source_vid, dir);\n \n             let source_node_index = NodeIndex(source_vid.index as usize);\n@@ -1362,16 +1362,16 @@ impl<'tcx> fmt::Display for GenericKind<'tcx> {\n     }\n }\n \n-impl<'a, 'tcx> GenericKind<'tcx> {\n-    pub fn to_ty(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>) -> Ty<'tcx> {\n+impl<'a, 'gcx, 'tcx> GenericKind<'tcx> {\n+    pub fn to_ty(&self, tcx: TyCtxt<'a, 'gcx, 'tcx>) -> Ty<'tcx> {\n         match *self {\n             GenericKind::Param(ref p) => p.to_ty(tcx),\n             GenericKind::Projection(ref p) => tcx.mk_projection(p.trait_ref.clone(), p.item_name),\n         }\n     }\n }\n \n-impl<'a, 'tcx> VerifyBound {\n+impl<'a, 'gcx, 'tcx> VerifyBound {\n     fn for_each_region(&self, f: &mut FnMut(ty::Region)) {\n         match self {\n             &VerifyBound::AnyRegion(ref rs) |\n@@ -1424,7 +1424,7 @@ impl<'a, 'tcx> VerifyBound {\n         }\n     }\n \n-    fn is_met(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+    fn is_met(&self, tcx: TyCtxt<'a, 'gcx, 'tcx>,\n               free_regions: &FreeRegionMap,\n               var_values: &Vec<VarValue>,\n               min: ty::Region)"}, {"sha": "4129c53c98863f69ec39e10ce0dffe2d7ed067f8", "filename": "src/librustc/middle/astconv_util.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/31a07b0ce662e95119a76cce8dcfc29d2055f738/src%2Flibrustc%2Fmiddle%2Fastconv_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31a07b0ce662e95119a76cce8dcfc29d2055f738/src%2Flibrustc%2Fmiddle%2Fastconv_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fastconv_util.rs?ref=31a07b0ce662e95119a76cce8dcfc29d2055f738", "patch": "@@ -20,7 +20,7 @@ use ty::{Ty, TyCtxt};\n use syntax::codemap::Span;\n use hir as ast;\n \n-impl<'a, 'tcx> TyCtxt<'a, 'tcx, 'tcx> {\n+impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n pub fn prohibit_type_params(self, segments: &[ast::PathSegment]) {\n     for segment in segments {\n         for typ in segment.parameters.types() {"}, {"sha": "4cee8c5d89ae62e9f8b8a0f946e7a1e9d9c45a98", "filename": "src/librustc/middle/expr_use_visitor.rs", "status": "modified", "additions": 9, "deletions": 11, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/31a07b0ce662e95119a76cce8dcfc29d2055f738/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31a07b0ce662e95119a76cce8dcfc29d2055f738/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs?ref=31a07b0ce662e95119a76cce8dcfc29d2055f738", "patch": "@@ -209,8 +209,7 @@ enum OverloadedCallType {\n }\n \n impl OverloadedCallType {\n-    fn from_trait_id<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, trait_id: DefId)\n-                               -> OverloadedCallType {\n+    fn from_trait_id(tcx: TyCtxt, trait_id: DefId) -> OverloadedCallType {\n         for &(maybe_function_trait, overloaded_call_type) in &[\n             (tcx.lang_items.fn_once_trait(), FnOnceOverloadedCall),\n             (tcx.lang_items.fn_mut_trait(), FnMutOverloadedCall),\n@@ -227,8 +226,7 @@ impl OverloadedCallType {\n         bug!(\"overloaded call didn't map to known function trait\")\n     }\n \n-    fn from_method_id<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, method_id: DefId)\n-                                -> OverloadedCallType {\n+    fn from_method_id(tcx: TyCtxt, method_id: DefId) -> OverloadedCallType {\n         let method = tcx.impl_or_trait_item(method_id);\n         OverloadedCallType::from_trait_id(tcx, method.container().id())\n     }\n@@ -271,9 +269,9 @@ enum PassArgs {\n     ByRef,\n }\n \n-impl<'a, 'tcx> ExprUseVisitor<'a, 'tcx, 'tcx> {\n+impl<'a, 'gcx, 'tcx> ExprUseVisitor<'a, 'gcx, 'tcx> {\n     pub fn new(delegate: &'a mut (Delegate<'tcx>+'a),\n-               infcx: &'a InferCtxt<'a, 'tcx, 'tcx>) -> Self\n+               infcx: &'a InferCtxt<'a, 'gcx, 'tcx>) -> Self\n     {\n         ExprUseVisitor {\n             mc: mc::MemCategorizationContext::new(infcx),\n@@ -305,7 +303,7 @@ impl<'a, 'tcx> ExprUseVisitor<'a, 'tcx, 'tcx> {\n         }\n     }\n \n-    fn tcx(&self) -> TyCtxt<'a, 'tcx, 'tcx> {\n+    fn tcx(&self) -> TyCtxt<'a, 'gcx, 'tcx> {\n         self.mc.infcx.tcx\n     }\n \n@@ -1184,10 +1182,10 @@ impl<'a, 'tcx> ExprUseVisitor<'a, 'tcx, 'tcx> {\n     }\n }\n \n-fn copy_or_move<'a, 'tcx>(infcx: &InferCtxt<'a, 'tcx, 'tcx>,\n-                          cmt: &mc::cmt<'tcx>,\n-                          move_reason: MoveReason)\n-                          -> ConsumeMode\n+fn copy_or_move<'a, 'gcx, 'tcx>(infcx: &InferCtxt<'a, 'gcx, 'tcx>,\n+                                cmt: &mc::cmt<'tcx>,\n+                                move_reason: MoveReason)\n+                                -> ConsumeMode\n {\n     if infcx.type_moves_by_default(cmt.ty, cmt.span) {\n         Move(move_reason)"}, {"sha": "e4ce89767139a23157a2f29543d288f4ae0dd724", "filename": "src/librustc/middle/free_region.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/31a07b0ce662e95119a76cce8dcfc29d2055f738/src%2Flibrustc%2Fmiddle%2Ffree_region.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31a07b0ce662e95119a76cce8dcfc29d2055f738/src%2Flibrustc%2Fmiddle%2Ffree_region.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ffree_region.rs?ref=31a07b0ce662e95119a76cce8dcfc29d2055f738", "patch": "@@ -120,11 +120,11 @@ impl FreeRegionMap {\n \n     /// Determines whether one region is a subregion of another.  This is intended to run *after\n     /// inference* and sadly the logic is somewhat duplicated with the code in infer.rs.\n-    pub fn is_subregion_of<'a, 'tcx>(&self,\n-                                     tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                                     sub_region: ty::Region,\n-                                     super_region: ty::Region)\n-                                     -> bool {\n+    pub fn is_subregion_of(&self,\n+                           tcx: TyCtxt,\n+                           sub_region: ty::Region,\n+                           super_region: ty::Region)\n+                           -> bool {\n         let result = sub_region == super_region || {\n             match (sub_region, super_region) {\n                 (ty::ReEmpty, _) |"}, {"sha": "3999b02425de6737d6e84ef9d2d653b0001fefe6", "filename": "src/librustc/middle/mem_categorization.rs", "status": "modified", "additions": 12, "deletions": 18, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/31a07b0ce662e95119a76cce8dcfc29d2055f738/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31a07b0ce662e95119a76cce8dcfc29d2055f738/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs?ref=31a07b0ce662e95119a76cce8dcfc29d2055f738", "patch": "@@ -302,9 +302,7 @@ impl MutabilityCategory {\n         ret\n     }\n \n-    fn from_local<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                            id: ast::NodeId)\n-                            -> MutabilityCategory {\n+    fn from_local(tcx: TyCtxt, id: ast::NodeId) -> MutabilityCategory {\n         let ret = match tcx.map.get(id) {\n             ast_map::NodeLocal(p) => match p.node {\n                 PatKind::Ident(bind_mode, _, _) => {\n@@ -360,13 +358,13 @@ impl MutabilityCategory {\n     }\n }\n \n-impl<'a, 'tcx> MemCategorizationContext<'a, 'tcx, 'tcx> {\n-    pub fn new(infcx: &'a InferCtxt<'a, 'tcx, 'tcx>)\n-               -> MemCategorizationContext<'a, 'tcx, 'tcx> {\n+impl<'a, 'gcx, 'tcx> MemCategorizationContext<'a, 'gcx, 'tcx> {\n+    pub fn new(infcx: &'a InferCtxt<'a, 'gcx, 'tcx>)\n+               -> MemCategorizationContext<'a, 'gcx, 'tcx> {\n         MemCategorizationContext { infcx: infcx }\n     }\n \n-    fn tcx(&self) -> TyCtxt<'a, 'tcx, 'tcx> {\n+    fn tcx(&self) -> TyCtxt<'a, 'gcx, 'tcx> {\n         self.infcx.tcx\n     }\n \n@@ -1074,9 +1072,7 @@ impl<'a, 'tcx> MemCategorizationContext<'a, 'tcx, 'tcx> {\n                              slice_pat: &hir::Pat)\n                              -> McResult<(cmt<'tcx>, hir::Mutability, ty::Region)> {\n         let slice_ty = self.node_ty(slice_pat.id)?;\n-        let (slice_mutbl, slice_r) = vec_slice_info(self.tcx(),\n-                                                    slice_pat,\n-                                                    slice_ty);\n+        let (slice_mutbl, slice_r) = vec_slice_info(slice_pat, slice_ty);\n         let context = InteriorOffsetKind::Pattern;\n         let cmt_vec = self.deref_vec(slice_pat, vec_cmt, context)?;\n         let cmt_slice = self.cat_index(slice_pat, cmt_vec, context)?;\n@@ -1085,14 +1081,12 @@ impl<'a, 'tcx> MemCategorizationContext<'a, 'tcx, 'tcx> {\n         /// In a pattern like [a, b, ..c], normally `c` has slice type, but if you have [a, b,\n         /// ..ref c], then the type of `ref c` will be `&&[]`, so to extract the slice details we\n         /// have to recurse through rptrs.\n-        fn vec_slice_info<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                                    pat: &hir::Pat,\n-                                    slice_ty: Ty)\n-                                    -> (hir::Mutability, ty::Region) {\n+        fn vec_slice_info(pat: &hir::Pat, slice_ty: Ty)\n+                          -> (hir::Mutability, ty::Region) {\n             match slice_ty.sty {\n                 ty::TyRef(r, ref mt) => match mt.ty.sty {\n                     ty::TySlice(_) => (mt.mutbl, *r),\n-                    _ => vec_slice_info(tcx, pat, mt.ty),\n+                    _ => vec_slice_info(pat, mt.ty),\n                 },\n \n                 _ => {\n@@ -1140,15 +1134,15 @@ impl<'a, 'tcx> MemCategorizationContext<'a, 'tcx, 'tcx> {\n     }\n \n     pub fn cat_pattern<F>(&self, cmt: cmt<'tcx>, pat: &hir::Pat, mut op: F) -> McResult<()>\n-        where F: FnMut(&MemCategorizationContext<'a, 'tcx, 'tcx>, cmt<'tcx>, &hir::Pat),\n+        where F: FnMut(&MemCategorizationContext<'a, 'gcx, 'tcx>, cmt<'tcx>, &hir::Pat),\n     {\n         self.cat_pattern_(cmt, pat, &mut op)\n     }\n \n     // FIXME(#19596) This is a workaround, but there should be a better way to do this\n     fn cat_pattern_<F>(&self, cmt: cmt<'tcx>, pat: &hir::Pat, op: &mut F)\n                        -> McResult<()>\n-        where F : FnMut(&MemCategorizationContext<'a, 'tcx, 'tcx>, cmt<'tcx>, &hir::Pat),\n+        where F : FnMut(&MemCategorizationContext<'a, 'gcx, 'tcx>, cmt<'tcx>, &hir::Pat),\n     {\n         // Here, `cmt` is the categorization for the value being\n         // matched and pat is the pattern it is being matched against.\n@@ -1466,7 +1460,7 @@ impl<'tcx> cmt_<'tcx> {\n     }\n \n \n-    pub fn descriptive_string<'a>(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>) -> String {\n+    pub fn descriptive_string(&self, tcx: TyCtxt) -> String {\n         match self.cat {\n             Categorization::StaticItem => {\n                 \"static item\".to_string()"}, {"sha": "f5610de062fb3f76926d88cc7d0a420f5a3a7146", "filename": "src/librustc/ty/context.rs", "status": "modified", "additions": 35, "deletions": 4, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/31a07b0ce662e95119a76cce8dcfc29d2055f738/src%2Flibrustc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31a07b0ce662e95119a76cce8dcfc29d2055f738/src%2Flibrustc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fcontext.rs?ref=31a07b0ce662e95119a76cce8dcfc29d2055f738", "patch": "@@ -92,7 +92,7 @@ struct CtxtInterners<'tcx> {\n     type_list: RefCell<FnvHashSet<InternedTyList<'tcx>>>,\n     substs: RefCell<FnvHashSet<InternedSubsts<'tcx>>>,\n     bare_fn: RefCell<FnvHashSet<&'tcx BareFnTy<'tcx>>>,\n-    region: RefCell<FnvHashSet<&'tcx Region>>,\n+    region: RefCell<FnvHashSet<InternedRegion<'tcx>>>,\n     stability: RefCell<FnvHashSet<&'tcx attr::Stability>>,\n     layout: RefCell<FnvHashSet<&'tcx Layout>>,\n }\n@@ -740,6 +740,23 @@ impl<'a, 'tcx> Lift<'tcx> for &'a Substs<'a> {\n     }\n }\n \n+impl<'a, 'tcx> Lift<'tcx> for &'a Region {\n+    type Lifted = &'tcx Region;\n+    fn lift_to_tcx<'b, 'gcx>(&self, tcx: TyCtxt<'b, 'gcx, 'tcx>) -> Option<&'tcx Region> {\n+        if let Some(&InternedRegion { region }) = tcx.interners.region.borrow().get(*self) {\n+            if *self as *const _ == region as *const _ {\n+                return Some(region);\n+            }\n+        }\n+        // Also try in the global tcx if we're not that.\n+        if !tcx.is_global() {\n+            self.lift_to_tcx(tcx.global_tcx())\n+        } else {\n+            None\n+        }\n+    }\n+}\n+\n impl<'a, 'tcx> Lift<'tcx> for &'a [Ty<'a>] {\n     type Lifted = &'tcx [Ty<'tcx>];\n     fn lift_to_tcx<'b, 'gcx>(&self, tcx: TyCtxt<'b, 'gcx, 'tcx>) -> Option<&'tcx [Ty<'tcx>]> {\n@@ -953,6 +970,18 @@ impl<'tcx: 'lcx, 'lcx> Borrow<Substs<'lcx>> for InternedSubsts<'tcx> {\n     }\n }\n \n+/// An entry in the region interner.\n+#[derive(PartialEq, Eq, Hash)]\n+struct InternedRegion<'tcx> {\n+    region: &'tcx Region\n+}\n+\n+impl<'tcx> Borrow<Region> for InternedRegion<'tcx> {\n+    fn borrow<'a>(&'a self) -> &'a Region {\n+        self.region\n+    }\n+}\n+\n fn bound_list_is_sorted(bounds: &[ty::PolyProjectionPredicate]) -> bool {\n     bounds.is_empty() ||\n         bounds[1..].iter().enumerate().all(\n@@ -1006,12 +1035,14 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n     }\n \n     pub fn mk_region(self, region: Region) -> &'tcx Region {\n-        if let Some(region) = self.interners.region.borrow().get(&region) {\n-            return *region;\n+        if let Some(interned) = self.interners.region.borrow().get(&region) {\n+            return interned.region;\n         }\n \n         let region = self.interners.arenas.region.alloc(region);\n-        self.interners.region.borrow_mut().insert(region);\n+        self.interners.region.borrow_mut().insert(InternedRegion {\n+            region: region\n+        });\n         region\n     }\n "}, {"sha": "7bede488964510ee0c829dfd44b20cdef5a362c3", "filename": "src/librustc/ty/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/31a07b0ce662e95119a76cce8dcfc29d2055f738/src%2Flibrustc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31a07b0ce662e95119a76cce8dcfc29d2055f738/src%2Flibrustc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmod.rs?ref=31a07b0ce662e95119a76cce8dcfc29d2055f738", "patch": "@@ -1590,7 +1590,7 @@ impl<'a, 'gcx, 'tcx, 'container> AdtDefData<'gcx, 'container> {\n         }\n     }\n \n-    fn calculate_dtorck(&'gcx self, tcx: TyCtxt<'a, 'gcx, 'tcx>) {\n+    fn calculate_dtorck(&'gcx self, tcx: TyCtxt) {\n         if tcx.is_adt_dtorck(self) {\n             self.flags.set(self.flags.get() | AdtFlags::IS_DTORCK);\n         }\n@@ -1611,7 +1611,7 @@ impl<'a, 'gcx, 'tcx, 'container> AdtDefData<'gcx, 'container> {\n     /// true, this type being safe for destruction requires it to be\n     /// alive; Otherwise, only the contents are required to be.\n     #[inline]\n-    pub fn is_dtorck(&'gcx self, tcx: TyCtxt<'a, 'gcx, 'tcx>) -> bool {\n+    pub fn is_dtorck(&'gcx self, tcx: TyCtxt) -> bool {\n         if !self.flags.get().intersects(AdtFlags::IS_DTORCK_VALID) {\n             self.calculate_dtorck(tcx)\n         }\n@@ -2932,7 +2932,7 @@ pub enum ExplicitSelfCategory {\n     ByBox,\n }\n \n-impl<'a, 'tcx> TyCtxt<'a, 'tcx, 'tcx> {\n+impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n     pub fn with_freevars<T, F>(self, fid: NodeId, f: F) -> T where\n         F: FnOnce(&[hir::Freevar]) -> T,\n     {"}, {"sha": "284019ed6a29c57512480e8df4bcf4ef688d181b", "filename": "src/librustc/ty/structural_impls.rs", "status": "modified", "additions": 76, "deletions": 1, "changes": 77, "blob_url": "https://github.com/rust-lang/rust/blob/31a07b0ce662e95119a76cce8dcfc29d2055f738/src%2Flibrustc%2Fty%2Fstructural_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31a07b0ce662e95119a76cce8dcfc29d2055f738/src%2Flibrustc%2Fty%2Fstructural_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fstructural_impls.rs?ref=31a07b0ce662e95119a76cce8dcfc29d2055f738", "patch": "@@ -32,7 +32,10 @@ impl<'tcx, A: Lift<'tcx>, B: Lift<'tcx>> Lift<'tcx> for (A, B) {\n impl<'tcx, T: Lift<'tcx>> Lift<'tcx> for Option<T> {\n     type Lifted = Option<T::Lifted>;\n     fn lift_to_tcx<'a, 'gcx>(&self, tcx: TyCtxt<'a, 'gcx, 'tcx>) -> Option<Self::Lifted> {\n-        self.as_ref().map(|x| tcx.lift(x))\n+        match *self {\n+            Some(ref x) => tcx.lift(x).map(Some),\n+            None => Some(None)\n+        }\n     }\n }\n \n@@ -63,6 +66,13 @@ impl<'tcx, T: Lift<'tcx>> Lift<'tcx> for [T] {\n     }\n }\n \n+impl<'tcx, T: Lift<'tcx>> Lift<'tcx> for Vec<T> {\n+    type Lifted = Vec<T::Lifted>;\n+    fn lift_to_tcx<'a, 'gcx>(&self, tcx: TyCtxt<'a, 'gcx, 'tcx>) -> Option<Self::Lifted> {\n+        tcx.lift(&self[..])\n+    }\n+}\n+\n impl<'tcx> Lift<'tcx> for ty::Region {\n     type Lifted = Self;\n     fn lift_to_tcx(&self, _: TyCtxt) -> Option<ty::Region> {\n@@ -140,6 +150,71 @@ impl<'a, 'tcx> Lift<'tcx> for ty::ClosureSubsts<'a> {\n     }\n }\n \n+impl<'a, 'tcx> Lift<'tcx> for ty::ItemSubsts<'a> {\n+    type Lifted = ty::ItemSubsts<'tcx>;\n+    fn lift_to_tcx<'b, 'gcx>(&self, tcx: TyCtxt<'b, 'gcx, 'tcx>) -> Option<Self::Lifted> {\n+        tcx.lift(&self.substs).map(|substs| {\n+            ty::ItemSubsts {\n+                substs: substs\n+            }\n+        })\n+    }\n+}\n+\n+impl<'a, 'tcx> Lift<'tcx> for ty::adjustment::AutoRef<'a> {\n+    type Lifted = ty::adjustment::AutoRef<'tcx>;\n+    fn lift_to_tcx<'b, 'gcx>(&self, tcx: TyCtxt<'b, 'gcx, 'tcx>) -> Option<Self::Lifted> {\n+        match *self {\n+            ty::adjustment::AutoPtr(r, m) => {\n+                tcx.lift(&r).map(|r| ty::adjustment::AutoPtr(r, m))\n+            }\n+            ty::adjustment::AutoUnsafe(m) => {\n+                Some(ty::adjustment::AutoUnsafe(m))\n+            }\n+        }\n+    }\n+}\n+\n+impl<'a, 'tcx> Lift<'tcx> for ty::FnOutput<'a> {\n+    type Lifted = ty::FnOutput<'tcx>;\n+    fn lift_to_tcx<'b, 'gcx>(&self, tcx: TyCtxt<'b, 'gcx, 'tcx>) -> Option<Self::Lifted> {\n+        match *self {\n+            ty::FnConverging(ty) => {\n+                tcx.lift(&ty).map(ty::FnConverging)\n+            }\n+            ty::FnDiverging => Some(ty::FnDiverging)\n+        }\n+    }\n+}\n+\n+impl<'a, 'tcx> Lift<'tcx> for ty::FnSig<'a> {\n+    type Lifted = ty::FnSig<'tcx>;\n+    fn lift_to_tcx<'b, 'gcx>(&self, tcx: TyCtxt<'b, 'gcx, 'tcx>) -> Option<Self::Lifted> {\n+        tcx.lift(&self.inputs[..]).and_then(|inputs| {\n+            tcx.lift(&self.output).map(|output| {\n+                ty::FnSig {\n+                    inputs: inputs,\n+                    output: output,\n+                    variadic: self.variadic\n+                }\n+            })\n+        })\n+    }\n+}\n+\n+impl<'a, 'tcx> Lift<'tcx> for ty::ClosureTy<'a> {\n+    type Lifted = ty::ClosureTy<'tcx>;\n+    fn lift_to_tcx<'b, 'gcx>(&self, tcx: TyCtxt<'b, 'gcx, 'tcx>) -> Option<Self::Lifted> {\n+        tcx.lift(&self.sig).map(|sig| {\n+            ty::ClosureTy {\n+                sig: sig,\n+                unsafety: self.unsafety,\n+                abi: self.abi\n+            }\n+        })\n+    }\n+}\n+\n impl<'tcx, T: Lift<'tcx>> Lift<'tcx> for ty::error::ExpectedFound<T> {\n     type Lifted = ty::error::ExpectedFound<T::Lifted>;\n     fn lift_to_tcx<'a, 'gcx>(&self, tcx: TyCtxt<'a, 'gcx, 'tcx>) -> Option<Self::Lifted> {"}, {"sha": "4b96527cbe17868c1b5c238619dd262e83265a10", "filename": "src/librustc/ty/util.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/31a07b0ce662e95119a76cce8dcfc29d2055f738/src%2Flibrustc%2Fty%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31a07b0ce662e95119a76cce8dcfc29d2055f738/src%2Flibrustc%2Fty%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Futil.rs?ref=31a07b0ce662e95119a76cce8dcfc29d2055f738", "patch": "@@ -489,7 +489,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n     /// `adt` that do not strictly outlive the adt value itself.\n     /// (This allows programs to make cyclic structures without\n     /// resorting to unasfe means; see RFCs 769 and 1238).\n-    pub fn is_adt_dtorck(self, adt: ty::AdtDef<'tcx>) -> bool {\n+    pub fn is_adt_dtorck(self, adt: ty::AdtDef) -> bool {\n         let dtor_method = match adt.destructor() {\n             Some(dtor) => dtor,\n             None => return false"}, {"sha": "b6f1e86780b851e0098209d1c61fa70c605325b7", "filename": "src/librustc_typeck/astconv.rs", "status": "modified", "additions": 476, "deletions": 527, "changes": 1003, "blob_url": "https://github.com/rust-lang/rust/blob/31a07b0ce662e95119a76cce8dcfc29d2055f738/src%2Flibrustc_typeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31a07b0ce662e95119a76cce8dcfc29d2055f738/src%2Flibrustc_typeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fastconv.rs?ref=31a07b0ce662e95119a76cce8dcfc29d2055f738", "patch": "@@ -149,6 +149,27 @@ pub trait AstConv<'gcx, 'tcx> {\n     fn set_tainted_by_errors(&self);\n }\n \n+#[derive(PartialEq, Eq)]\n+pub enum PathParamMode {\n+    // Any path in a type context.\n+    Explicit,\n+    // The `module::Type` in `module::Type::method` in an expression.\n+    Optional\n+}\n+\n+struct ConvertedBinding<'tcx> {\n+    item_name: ast::Name,\n+    ty: Ty<'tcx>,\n+    span: Span,\n+}\n+\n+struct SelfInfo<'a, 'tcx> {\n+    untransformed_self_ty: Ty<'tcx>,\n+    explicit_self: &'a hir::ExplicitSelf,\n+}\n+\n+type TraitAndProjections<'tcx> = (ty::PolyTraitRef<'tcx>, Vec<ty::PolyProjectionPredicate<'tcx>>);\n+\n pub fn ast_region_to_region(tcx: TyCtxt, lifetime: &hir::Lifetime)\n                             -> ty::Region {\n     let r = match tcx.named_region_map.get(&lifetime.id) {\n@@ -254,21 +275,21 @@ fn report_elision_failure(\n     }\n }\n \n-pub fn opt_ast_region_to_region<'tcx>(\n-    this: &AstConv<'tcx, 'tcx>,\n+impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n+pub fn opt_ast_region_to_region(&self,\n     rscope: &RegionScope,\n     default_span: Span,\n     opt_lifetime: &Option<hir::Lifetime>) -> ty::Region\n {\n     let r = match *opt_lifetime {\n         Some(ref lifetime) => {\n-            ast_region_to_region(this.tcx(), lifetime)\n+            ast_region_to_region(self.tcx(), lifetime)\n         }\n \n         None => match rscope.anon_regions(default_span, 1) {\n             Ok(rs) => rs[0],\n             Err(params) => {\n-                let mut err = struct_span_err!(this.tcx().sess, default_span, E0106,\n+                let mut err = struct_span_err!(self.tcx().sess, default_span, E0106,\n                                                \"missing lifetime specifier\");\n                 if let Some(params) = params {\n                     report_elision_failure(&mut err, params);\n@@ -288,16 +309,15 @@ pub fn opt_ast_region_to_region<'tcx>(\n \n /// Given a path `path` that refers to an item `I` with the declared generics `decl_generics`,\n /// returns an appropriate set of substitutions for this particular reference to `I`.\n-pub fn ast_path_substs_for_ty<'tcx>(\n-    this: &AstConv<'tcx, 'tcx>,\n+pub fn ast_path_substs_for_ty(&self,\n     rscope: &RegionScope,\n     span: Span,\n     param_mode: PathParamMode,\n     decl_generics: &ty::Generics<'tcx>,\n     item_segment: &hir::PathSegment)\n     -> Substs<'tcx>\n {\n-    let tcx = this.tcx();\n+    let tcx = self.tcx();\n \n     // ast_path_substs() is only called to convert paths that are\n     // known to refer to traits, types, or structs. In these cases,\n@@ -312,7 +332,7 @@ pub fn ast_path_substs_for_ty<'tcx>(\n \n     let (regions, types, assoc_bindings) = match item_segment.parameters {\n         hir::AngleBracketedParameters(ref data) => {\n-            convert_angle_bracketed_parameters(this, rscope, span, decl_generics, data)\n+            self.convert_angle_bracketed_parameters(rscope, span, decl_generics, data)\n         }\n         hir::ParenthesizedParameters(..) => {\n             span_err!(tcx.sess, span, E0214,\n@@ -324,34 +344,24 @@ pub fn ast_path_substs_for_ty<'tcx>(\n         }\n     };\n \n-    assoc_bindings.first().map(|b| this.tcx().prohibit_projection(b.span));\n-\n-    create_substs_for_ast_path(this,\n-                               span,\n-                               param_mode,\n-                               decl_generics,\n-                               None,\n-                               types,\n-                               regions)\n-}\n+    assoc_bindings.first().map(|b| self.tcx().prohibit_projection(b.span));\n \n-#[derive(PartialEq, Eq)]\n-pub enum PathParamMode {\n-    // Any path in a type context.\n-    Explicit,\n-    // The `module::Type` in `module::Type::method` in an expression.\n-    Optional\n+    self.create_substs_for_ast_path(span,\n+                                    param_mode,\n+                                    decl_generics,\n+                                    None,\n+                                    types,\n+                                    regions)\n }\n \n-fn create_region_substs<'tcx>(\n-    this: &AstConv<'tcx, 'tcx>,\n+fn create_region_substs(&self,\n     rscope: &RegionScope,\n     span: Span,\n     decl_generics: &ty::Generics<'tcx>,\n     regions_provided: Vec<ty::Region>)\n     -> Substs<'tcx>\n {\n-    let tcx = this.tcx();\n+    let tcx = self.tcx();\n \n     // If the type is parameterized by this region, then replace this\n     // region with the current anon region binding (in other words,\n@@ -387,8 +397,7 @@ fn create_region_substs<'tcx>(\n /// The `region_substs` should be the result of `create_region_substs`\n /// -- that is, a substitution with no types but the correct number of\n /// regions.\n-fn create_substs_for_ast_path<'tcx>(\n-    this: &AstConv<'tcx, 'tcx>,\n+fn create_substs_for_ast_path(&self,\n     span: Span,\n     param_mode: PathParamMode,\n     decl_generics: &ty::Generics<'tcx>,\n@@ -397,7 +406,7 @@ fn create_substs_for_ast_path<'tcx>(\n     region_substs: Substs<'tcx>)\n     -> Substs<'tcx>\n {\n-    let tcx = this.tcx();\n+    let tcx = self.tcx();\n \n     debug!(\"create_substs_for_ast_path(decl_generics={:?}, self_ty={:?}, \\\n            types_provided={:?}, region_substs={:?})\",\n@@ -414,16 +423,15 @@ fn create_substs_for_ast_path<'tcx>(\n                                                .take_while(|x| x.default.is_none())\n                                                .count();\n \n-    let mut type_substs = get_type_substs_for_defs(this,\n-                                                   span,\n-                                                   types_provided,\n-                                                   param_mode,\n-                                                   ty_param_defs,\n-                                                   region_substs.clone(),\n-                                                   self_ty);\n+    let mut type_substs = self.get_type_substs_for_defs(span,\n+                                                        types_provided,\n+                                                        param_mode,\n+                                                        ty_param_defs,\n+                                                        region_substs.clone(),\n+                                                        self_ty);\n \n     let supplied_ty_param_count = type_substs.len();\n-    check_type_argument_count(this.tcx(), span, supplied_ty_param_count,\n+    check_type_argument_count(self.tcx(), span, supplied_ty_param_count,\n                               required_ty_param_count, formal_ty_param_count);\n \n     if supplied_ty_param_count < required_ty_param_count {\n@@ -489,14 +497,14 @@ fn create_substs_for_ast_path<'tcx>(\n \n /// Returns types_provided if it is not empty, otherwise populating the\n /// type parameters with inference variables as appropriate.\n-fn get_type_substs_for_defs<'tcx>(this: &AstConv<'tcx, 'tcx>,\n-                                  span: Span,\n-                                  types_provided: Vec<Ty<'tcx>>,\n-                                  param_mode: PathParamMode,\n-                                  ty_param_defs: &[ty::TypeParameterDef<'tcx>],\n-                                  mut substs: Substs<'tcx>,\n-                                  self_ty: Option<Ty<'tcx>>)\n-                                  -> Vec<Ty<'tcx>>\n+fn get_type_substs_for_defs(&self,\n+                            span: Span,\n+                            types_provided: Vec<Ty<'tcx>>,\n+                            param_mode: PathParamMode,\n+                            ty_param_defs: &[ty::TypeParameterDef<'tcx>],\n+                            mut substs: Substs<'tcx>,\n+                            self_ty: Option<Ty<'tcx>>)\n+                            -> Vec<Ty<'tcx>>\n {\n     fn default_type_parameter<'tcx>(p: &ty::TypeParameterDef<'tcx>, self_ty: Option<Ty<'tcx>>)\n                                     -> Option<ty::TypeParameterDef<'tcx>>\n@@ -515,48 +523,42 @@ fn get_type_substs_for_defs<'tcx>(this: &AstConv<'tcx, 'tcx>,\n     if param_mode == PathParamMode::Optional && types_provided.is_empty() {\n         ty_param_defs\n             .iter()\n-            .map(|p| this.ty_infer(default_type_parameter(p, self_ty), Some(&mut substs),\n+            .map(|p| self.ty_infer(default_type_parameter(p, self_ty), Some(&mut substs),\n                                    Some(TypeSpace), span))\n             .collect()\n     } else {\n         types_provided\n     }\n }\n \n-struct ConvertedBinding<'tcx> {\n-    item_name: ast::Name,\n-    ty: Ty<'tcx>,\n-    span: Span,\n-}\n-\n-fn convert_angle_bracketed_parameters<'tcx>(this: &AstConv<'tcx, 'tcx>,\n-                                            rscope: &RegionScope,\n-                                            span: Span,\n-                                            decl_generics: &ty::Generics<'tcx>,\n-                                            data: &hir::AngleBracketedParameterData)\n-                                            -> (Substs<'tcx>,\n-                                                Vec<Ty<'tcx>>,\n-                                                Vec<ConvertedBinding<'tcx>>)\n+fn convert_angle_bracketed_parameters(&self,\n+                                      rscope: &RegionScope,\n+                                      span: Span,\n+                                      decl_generics: &ty::Generics<'tcx>,\n+                                      data: &hir::AngleBracketedParameterData)\n+                                      -> (Substs<'tcx>,\n+                                          Vec<Ty<'tcx>>,\n+                                          Vec<ConvertedBinding<'tcx>>)\n {\n     let regions: Vec<_> =\n         data.lifetimes.iter()\n-                      .map(|l| ast_region_to_region(this.tcx(), l))\n+                      .map(|l| ast_region_to_region(self.tcx(), l))\n                       .collect();\n \n     let region_substs =\n-        create_region_substs(this, rscope, span, decl_generics, regions);\n+        self.create_region_substs(rscope, span, decl_generics, regions);\n \n     let types: Vec<_> =\n         data.types.iter()\n                   .enumerate()\n-                  .map(|(i,t)| ast_ty_arg_to_ty(this, rscope, decl_generics,\n-                                                i, &region_substs, t))\n+                  .map(|(i,t)| self.ast_ty_arg_to_ty(rscope, decl_generics,\n+                                                     i, &region_substs, t))\n                   .collect();\n \n     let assoc_bindings: Vec<_> =\n         data.bindings.iter()\n                      .map(|b| ConvertedBinding { item_name: b.name,\n-                                                 ty: ast_ty_to_ty(this, rscope, &b.ty),\n+                                                 ty: self.ast_ty_to_ty(rscope, &b.ty),\n                                                  span: b.span })\n                      .collect();\n \n@@ -566,11 +568,11 @@ fn convert_angle_bracketed_parameters<'tcx>(this: &AstConv<'tcx, 'tcx>,\n /// Returns the appropriate lifetime to use for any output lifetimes\n /// (if one exists) and a vector of the (pattern, number of lifetimes)\n /// corresponding to each input type/pattern.\n-fn find_implied_output_region<'tcx>(this: &AstConv<'tcx, 'tcx>,\n-                                    input_tys: &[Ty<'tcx>],\n-                                    input_pats: Vec<String>) -> ElidedLifetime\n+fn find_implied_output_region(&self,\n+                              input_tys: &[Ty<'tcx>],\n+                              input_pats: Vec<String>) -> ElidedLifetime\n {\n-    let tcx = this.tcx();\n+    let tcx = self.tcx();\n     let mut lifetimes_for_params = Vec::new();\n     let mut possible_implied_output_region = None;\n \n@@ -602,59 +604,57 @@ fn find_implied_output_region<'tcx>(this: &AstConv<'tcx, 'tcx>,\n     }\n }\n \n-fn convert_ty_with_lifetime_elision<'tcx>(this: &AstConv<'tcx, 'tcx>,\n-                                          elided_lifetime: ElidedLifetime,\n-                                          ty: &hir::Ty)\n-                                          -> Ty<'tcx>\n+fn convert_ty_with_lifetime_elision(&self,\n+                                    elided_lifetime: ElidedLifetime,\n+                                    ty: &hir::Ty)\n+                                    -> Ty<'tcx>\n {\n     match elided_lifetime {\n         Ok(implied_output_region) => {\n             let rb = ElidableRscope::new(implied_output_region);\n-            ast_ty_to_ty(this, &rb, ty)\n+            self.ast_ty_to_ty(&rb, ty)\n         }\n         Err(param_lifetimes) => {\n             // All regions must be explicitly specified in the output\n             // if the lifetime elision rules do not apply. This saves\n             // the user from potentially-confusing errors.\n             let rb = UnelidableRscope::new(param_lifetimes);\n-            ast_ty_to_ty(this, &rb, ty)\n+            self.ast_ty_to_ty(&rb, ty)\n         }\n     }\n }\n \n-fn convert_parenthesized_parameters<'tcx>(this: &AstConv<'tcx, 'tcx>,\n-                                          rscope: &RegionScope,\n-                                          span: Span,\n-                                          decl_generics: &ty::Generics<'tcx>,\n-                                          data: &hir::ParenthesizedParameterData)\n-                                          -> (Substs<'tcx>,\n-                                              Vec<Ty<'tcx>>,\n-                                              Vec<ConvertedBinding<'tcx>>)\n+fn convert_parenthesized_parameters(&self,\n+                                    rscope: &RegionScope,\n+                                    span: Span,\n+                                    decl_generics: &ty::Generics<'tcx>,\n+                                    data: &hir::ParenthesizedParameterData)\n+                                    -> (Substs<'tcx>,\n+                                        Vec<Ty<'tcx>>,\n+                                        Vec<ConvertedBinding<'tcx>>)\n {\n     let region_substs =\n-        create_region_substs(this, rscope, span, decl_generics, Vec::new());\n+        self.create_region_substs(rscope, span, decl_generics, Vec::new());\n \n     let binding_rscope = BindingRscope::new();\n     let inputs =\n         data.inputs.iter()\n-                   .map(|a_t| ast_ty_arg_to_ty(this, &binding_rscope, decl_generics,\n-                                               0, &region_substs, a_t))\n+                   .map(|a_t| self.ast_ty_arg_to_ty(&binding_rscope, decl_generics,\n+                                                    0, &region_substs, a_t))\n                    .collect::<Vec<Ty<'tcx>>>();\n \n     let input_params = vec![String::new(); inputs.len()];\n-    let implied_output_region = find_implied_output_region(this, &inputs, input_params);\n+    let implied_output_region = self.find_implied_output_region(&inputs, input_params);\n \n-    let input_ty = this.tcx().mk_tup(inputs);\n+    let input_ty = self.tcx().mk_tup(inputs);\n \n     let (output, output_span) = match data.output {\n         Some(ref output_ty) => {\n-            (convert_ty_with_lifetime_elision(this,\n-                                              implied_output_region,\n-                                              &output_ty),\n+            (self.convert_ty_with_lifetime_elision(implied_output_region, &output_ty),\n              output_ty.span)\n         }\n         None => {\n-            (this.tcx().mk_nil(), data.span)\n+            (self.tcx().mk_nil(), data.span)\n         }\n     };\n \n@@ -667,24 +667,22 @@ fn convert_parenthesized_parameters<'tcx>(this: &AstConv<'tcx, 'tcx>,\n     (region_substs, vec![input_ty], vec![output_binding])\n }\n \n-pub fn instantiate_poly_trait_ref<'tcx>(\n-    this: &AstConv<'tcx, 'tcx>,\n+pub fn instantiate_poly_trait_ref(&self,\n     rscope: &RegionScope,\n     ast_trait_ref: &hir::PolyTraitRef,\n     self_ty: Option<Ty<'tcx>>,\n     poly_projections: &mut Vec<ty::PolyProjectionPredicate<'tcx>>)\n     -> ty::PolyTraitRef<'tcx>\n {\n     let trait_ref = &ast_trait_ref.trait_ref;\n-    let trait_def_id = trait_def_id(this, trait_ref);\n-    ast_path_to_poly_trait_ref(this,\n-                               rscope,\n-                               trait_ref.path.span,\n-                               PathParamMode::Explicit,\n-                               trait_def_id,\n-                               self_ty,\n-                               trait_ref.path.segments.last().unwrap(),\n-                               poly_projections)\n+    let trait_def_id = self.trait_def_id(trait_ref);\n+    self.ast_path_to_poly_trait_ref(rscope,\n+                                    trait_ref.path.span,\n+                                    PathParamMode::Explicit,\n+                                    trait_def_id,\n+                                    self_ty,\n+                                    trait_ref.path.segments.last().unwrap(),\n+                                    poly_projections)\n }\n \n /// Instantiates the path for the given trait reference, assuming that it's\n@@ -693,39 +691,36 @@ pub fn instantiate_poly_trait_ref<'tcx>(\n ///\n /// If the `projections` argument is `None`, then assoc type bindings like `Foo<T=X>`\n /// are disallowed. Otherwise, they are pushed onto the vector given.\n-pub fn instantiate_mono_trait_ref<'tcx>(\n-    this: &AstConv<'tcx, 'tcx>,\n+pub fn instantiate_mono_trait_ref(&self,\n     rscope: &RegionScope,\n     trait_ref: &hir::TraitRef,\n     self_ty: Option<Ty<'tcx>>)\n     -> ty::TraitRef<'tcx>\n {\n-    let trait_def_id = trait_def_id(this, trait_ref);\n-    ast_path_to_mono_trait_ref(this,\n-                               rscope,\n-                               trait_ref.path.span,\n-                               PathParamMode::Explicit,\n-                               trait_def_id,\n-                               self_ty,\n-                               trait_ref.path.segments.last().unwrap())\n+    let trait_def_id = self.trait_def_id(trait_ref);\n+    self.ast_path_to_mono_trait_ref(rscope,\n+                                    trait_ref.path.span,\n+                                    PathParamMode::Explicit,\n+                                    trait_def_id,\n+                                    self_ty,\n+                                    trait_ref.path.segments.last().unwrap())\n }\n \n-fn trait_def_id<'tcx>(this: &AstConv<'tcx, 'tcx>, trait_ref: &hir::TraitRef) -> DefId {\n+fn trait_def_id(&self, trait_ref: &hir::TraitRef) -> DefId {\n     let path = &trait_ref.path;\n-    match ::lookup_full_def(this.tcx(), path.span, trait_ref.ref_id) {\n+    match ::lookup_full_def(self.tcx(), path.span, trait_ref.ref_id) {\n         Def::Trait(trait_def_id) => trait_def_id,\n         Def::Err => {\n-            this.tcx().sess.fatal(\"cannot continue compilation due to previous error\");\n+            self.tcx().sess.fatal(\"cannot continue compilation due to previous error\");\n         }\n         _ => {\n-            span_fatal!(this.tcx().sess, path.span, E0245, \"`{}` is not a trait\",\n+            span_fatal!(self.tcx().sess, path.span, E0245, \"`{}` is not a trait\",\n                         path);\n         }\n     }\n }\n \n-fn object_path_to_poly_trait_ref<'a,'tcx>(\n-    this: &AstConv<'tcx, 'tcx>,\n+fn object_path_to_poly_trait_ref(&self,\n     rscope: &RegionScope,\n     span: Span,\n     param_mode: PathParamMode,\n@@ -734,18 +729,16 @@ fn object_path_to_poly_trait_ref<'a,'tcx>(\n     mut projections: &mut Vec<ty::PolyProjectionPredicate<'tcx>>)\n     -> ty::PolyTraitRef<'tcx>\n {\n-    ast_path_to_poly_trait_ref(this,\n-                               rscope,\n-                               span,\n-                               param_mode,\n-                               trait_def_id,\n-                               None,\n-                               trait_segment,\n-                               projections)\n+    self.ast_path_to_poly_trait_ref(rscope,\n+                                    span,\n+                                    param_mode,\n+                                    trait_def_id,\n+                                    None,\n+                                    trait_segment,\n+                                    projections)\n }\n \n-fn ast_path_to_poly_trait_ref<'a,'tcx>(\n-    this: &AstConv<'tcx, 'tcx>,\n+fn ast_path_to_poly_trait_ref(&self,\n     rscope: &RegionScope,\n     span: Span,\n     param_mode: PathParamMode,\n@@ -764,13 +757,12 @@ fn ast_path_to_poly_trait_ref<'a,'tcx>(\n     let shifted_rscope = &ShiftedRscope::new(rscope);\n \n     let (substs, assoc_bindings) =\n-        create_substs_for_ast_trait_ref(this,\n-                                        shifted_rscope,\n-                                        span,\n-                                        param_mode,\n-                                        trait_def_id,\n-                                        self_ty,\n-                                        trait_segment);\n+        self.create_substs_for_ast_trait_ref(shifted_rscope,\n+                                             span,\n+                                             param_mode,\n+                                             trait_def_id,\n+                                             self_ty,\n+                                             trait_segment);\n     let poly_trait_ref = ty::Binder(ty::TraitRef::new(trait_def_id, substs));\n \n     {\n@@ -780,10 +772,9 @@ fn ast_path_to_poly_trait_ref<'a,'tcx>(\n             .filter_map(|binding| {\n                 // specify type to assert that error was already reported in Err case:\n                 let predicate: Result<_, ErrorReported> =\n-                    ast_type_binding_to_poly_projection_predicate(this,\n-                                                                  poly_trait_ref.clone(),\n-                                                                  self_ty,\n-                                                                  binding);\n+                    self.ast_type_binding_to_poly_projection_predicate(poly_trait_ref.clone(),\n+                                                                       self_ty,\n+                                                                       binding);\n                 predicate.ok() // ok to ignore Err() because ErrorReported (see above)\n             });\n         poly_projections.extend(converted_bindings);\n@@ -794,44 +785,43 @@ fn ast_path_to_poly_trait_ref<'a,'tcx>(\n     poly_trait_ref\n }\n \n-fn ast_path_to_mono_trait_ref<'a,'tcx>(this: &AstConv<'tcx, 'tcx>,\n-                                       rscope: &RegionScope,\n-                                       span: Span,\n-                                       param_mode: PathParamMode,\n-                                       trait_def_id: DefId,\n-                                       self_ty: Option<Ty<'tcx>>,\n-                                       trait_segment: &hir::PathSegment)\n-                                       -> ty::TraitRef<'tcx>\n+fn ast_path_to_mono_trait_ref(&self,\n+                              rscope: &RegionScope,\n+                              span: Span,\n+                              param_mode: PathParamMode,\n+                              trait_def_id: DefId,\n+                              self_ty: Option<Ty<'tcx>>,\n+                              trait_segment: &hir::PathSegment)\n+                              -> ty::TraitRef<'tcx>\n {\n     let (substs, assoc_bindings) =\n-        create_substs_for_ast_trait_ref(this,\n-                                        rscope,\n-                                        span,\n-                                        param_mode,\n-                                        trait_def_id,\n-                                        self_ty,\n-                                        trait_segment);\n-    assoc_bindings.first().map(|b| this.tcx().prohibit_projection(b.span));\n+        self.create_substs_for_ast_trait_ref(rscope,\n+                                             span,\n+                                             param_mode,\n+                                             trait_def_id,\n+                                             self_ty,\n+                                             trait_segment);\n+    assoc_bindings.first().map(|b| self.tcx().prohibit_projection(b.span));\n     ty::TraitRef::new(trait_def_id, substs)\n }\n \n-fn create_substs_for_ast_trait_ref<'a,'tcx>(this: &AstConv<'tcx, 'tcx>,\n-                                            rscope: &RegionScope,\n-                                            span: Span,\n-                                            param_mode: PathParamMode,\n-                                            trait_def_id: DefId,\n-                                            self_ty: Option<Ty<'tcx>>,\n-                                            trait_segment: &hir::PathSegment)\n-                                            -> (&'tcx Substs<'tcx>, Vec<ConvertedBinding<'tcx>>)\n+fn create_substs_for_ast_trait_ref(&self,\n+                                   rscope: &RegionScope,\n+                                   span: Span,\n+                                   param_mode: PathParamMode,\n+                                   trait_def_id: DefId,\n+                                   self_ty: Option<Ty<'tcx>>,\n+                                   trait_segment: &hir::PathSegment)\n+                                   -> (&'tcx Substs<'tcx>, Vec<ConvertedBinding<'tcx>>)\n {\n     debug!(\"create_substs_for_ast_trait_ref(trait_segment={:?})\",\n            trait_segment);\n \n-    let trait_def = match this.get_trait_def(span, trait_def_id) {\n+    let trait_def = match self.get_trait_def(span, trait_def_id) {\n         Ok(trait_def) => trait_def,\n         Err(ErrorReported) => {\n             // No convenient way to recover from a cycle here. Just bail. Sorry!\n-            this.tcx().sess.abort_if_errors();\n+            self.tcx().sess.abort_if_errors();\n             bug!(\"ErrorReported returned, but no errors reports?\")\n         }\n     };\n@@ -840,49 +830,47 @@ fn create_substs_for_ast_trait_ref<'a,'tcx>(this: &AstConv<'tcx, 'tcx>,\n         hir::AngleBracketedParameters(ref data) => {\n             // For now, require that parenthetical notation be used\n             // only with `Fn()` etc.\n-            if !this.tcx().sess.features.borrow().unboxed_closures && trait_def.paren_sugar {\n-                emit_feature_err(&this.tcx().sess.parse_sess.span_diagnostic,\n+            if !self.tcx().sess.features.borrow().unboxed_closures && trait_def.paren_sugar {\n+                emit_feature_err(&self.tcx().sess.parse_sess.span_diagnostic,\n                                  \"unboxed_closures\", span, GateIssue::Language,\n                                  \"\\\n                     the precise format of `Fn`-family traits' type parameters is \\\n                     subject to change. Use parenthetical notation (Fn(Foo, Bar) -> Baz) instead\");\n             }\n \n-            convert_angle_bracketed_parameters(this, rscope, span, &trait_def.generics, data)\n+            self.convert_angle_bracketed_parameters(rscope, span, &trait_def.generics, data)\n         }\n         hir::ParenthesizedParameters(ref data) => {\n             // For now, require that parenthetical notation be used\n             // only with `Fn()` etc.\n-            if !this.tcx().sess.features.borrow().unboxed_closures && !trait_def.paren_sugar {\n-                emit_feature_err(&this.tcx().sess.parse_sess.span_diagnostic,\n+            if !self.tcx().sess.features.borrow().unboxed_closures && !trait_def.paren_sugar {\n+                emit_feature_err(&self.tcx().sess.parse_sess.span_diagnostic,\n                                  \"unboxed_closures\", span, GateIssue::Language,\n                                  \"\\\n                     parenthetical notation is only stable when used with `Fn`-family traits\");\n             }\n \n-            convert_parenthesized_parameters(this, rscope, span, &trait_def.generics, data)\n+            self.convert_parenthesized_parameters(rscope, span, &trait_def.generics, data)\n         }\n     };\n \n-    let substs = create_substs_for_ast_path(this,\n-                                            span,\n-                                            param_mode,\n-                                            &trait_def.generics,\n-                                            self_ty,\n-                                            types,\n-                                            regions);\n+    let substs = self.create_substs_for_ast_path(span,\n+                                                 param_mode,\n+                                                 &trait_def.generics,\n+                                                 self_ty,\n+                                                 types,\n+                                                 regions);\n \n-    (this.tcx().mk_substs(substs), assoc_bindings)\n+    (self.tcx().mk_substs(substs), assoc_bindings)\n }\n \n-fn ast_type_binding_to_poly_projection_predicate<'tcx>(\n-    this: &AstConv<'tcx, 'tcx>,\n+fn ast_type_binding_to_poly_projection_predicate(&self,\n     mut trait_ref: ty::PolyTraitRef<'tcx>,\n     self_ty: Option<Ty<'tcx>>,\n     binding: &ConvertedBinding<'tcx>)\n     -> Result<ty::PolyProjectionPredicate<'tcx>, ErrorReported>\n {\n-    let tcx = this.tcx();\n+    let tcx = self.tcx();\n \n     // Given something like `U : SomeTrait<T=X>`, we want to produce a\n     // predicate like `<U as SomeTrait>::T = X`. This is somewhat\n@@ -901,7 +889,7 @@ fn ast_type_binding_to_poly_projection_predicate<'tcx>(\n     // We want to produce `<B as SuperTrait<int>>::T == foo`.\n \n     // Simple case: X is defined in the current trait.\n-    if this.trait_defines_associated_type_named(trait_ref.def_id(), binding.item_name) {\n+    if self.trait_defines_associated_type_named(trait_ref.def_id(), binding.item_name) {\n         return Ok(ty::Binder(ty::ProjectionPredicate {      // <-------------------+\n             projection_ty: ty::ProjectionTy {               //                     |\n                 trait_ref: trait_ref.skip_binder().clone(), // Binder moved here --+\n@@ -928,11 +916,11 @@ fn ast_type_binding_to_poly_projection_predicate<'tcx>(\n                                                  tcx.mk_substs(dummy_substs)));\n     }\n \n-    this.ensure_super_predicates(binding.span, trait_ref.def_id())?;\n+    self.ensure_super_predicates(binding.span, trait_ref.def_id())?;\n \n     let mut candidates: Vec<ty::PolyTraitRef> =\n         traits::supertraits(tcx, trait_ref.clone())\n-        .filter(|r| this.trait_defines_associated_type_named(r.def_id(), binding.item_name))\n+        .filter(|r| self.trait_defines_associated_type_named(r.def_id(), binding.item_name))\n         .collect();\n \n     // If converting for an object type, then remove the dummy-ty from `Self` now.\n@@ -947,11 +935,10 @@ fn ast_type_binding_to_poly_projection_predicate<'tcx>(\n         }\n     }\n \n-    let candidate = one_bound_for_assoc_type(this,\n-                                             candidates,\n-                                             &trait_ref.to_string(),\n-                                             &binding.item_name.as_str(),\n-                                             binding.span)?;\n+    let candidate = self.one_bound_for_assoc_type(candidates,\n+                                                  &trait_ref.to_string(),\n+                                                  &binding.item_name.as_str(),\n+                                                  binding.span)?;\n \n     Ok(ty::Binder(ty::ProjectionPredicate {             // <-------------------------+\n         projection_ty: ty::ProjectionTy {               //                           |\n@@ -962,17 +949,16 @@ fn ast_type_binding_to_poly_projection_predicate<'tcx>(\n     }))\n }\n \n-fn ast_path_to_ty<'tcx>(\n-    this: &AstConv<'tcx, 'tcx>,\n+fn ast_path_to_ty(&self,\n     rscope: &RegionScope,\n     span: Span,\n     param_mode: PathParamMode,\n     did: DefId,\n     item_segment: &hir::PathSegment)\n     -> Ty<'tcx>\n {\n-    let tcx = this.tcx();\n-    let (generics, decl_ty) = match this.get_item_type_scheme(span, did) {\n+    let tcx = self.tcx();\n+    let (generics, decl_ty) = match self.get_item_type_scheme(span, did) {\n         Ok(ty::TypeScheme { generics,  ty: decl_ty }) => {\n             (generics, decl_ty)\n         }\n@@ -981,29 +967,26 @@ fn ast_path_to_ty<'tcx>(\n         }\n     };\n \n-    let substs = ast_path_substs_for_ty(this,\n-                                        rscope,\n-                                        span,\n-                                        param_mode,\n-                                        &generics,\n-                                        item_segment);\n+    let substs = self.ast_path_substs_for_ty(rscope,\n+                                             span,\n+                                             param_mode,\n+                                             &generics,\n+                                             item_segment);\n \n     // FIXME(#12938): This is a hack until we have full support for DST.\n-    if Some(did) == this.tcx().lang_items.owned_box() {\n+    if Some(did) == self.tcx().lang_items.owned_box() {\n         assert_eq!(substs.types.len(TypeSpace), 1);\n-        return this.tcx().mk_box(*substs.types.get(TypeSpace, 0));\n+        return self.tcx().mk_box(*substs.types.get(TypeSpace, 0));\n     }\n \n-    decl_ty.subst(this.tcx(), &substs)\n+    decl_ty.subst(self.tcx(), &substs)\n }\n \n-type TraitAndProjections<'tcx> = (ty::PolyTraitRef<'tcx>, Vec<ty::PolyProjectionPredicate<'tcx>>);\n-\n-fn ast_ty_to_trait_ref<'tcx>(this: &AstConv<'tcx, 'tcx>,\n-                             rscope: &RegionScope,\n-                             ty: &hir::Ty,\n-                             bounds: &[hir::TyParamBound])\n-                             -> Result<TraitAndProjections<'tcx>, ErrorReported>\n+fn ast_ty_to_trait_ref(&self,\n+                       rscope: &RegionScope,\n+                       ty: &hir::Ty,\n+                       bounds: &[hir::TyParamBound])\n+                       -> Result<TraitAndProjections<'tcx>, ErrorReported>\n {\n     /*!\n      * In a type like `Foo + Send`, we want to wait to collect the\n@@ -1018,30 +1001,30 @@ fn ast_ty_to_trait_ref<'tcx>(this: &AstConv<'tcx, 'tcx>,\n \n     match ty.node {\n         hir::TyPath(None, ref path) => {\n-            let def = match this.tcx().def_map.borrow().get(&ty.id) {\n+            let def = match self.tcx().def_map.borrow().get(&ty.id) {\n                 Some(&def::PathResolution { base_def, depth: 0, .. }) => Some(base_def),\n                 _ => None\n             };\n             match def {\n                 Some(Def::Trait(trait_def_id)) => {\n                     let mut projection_bounds = Vec::new();\n-                    let trait_ref = object_path_to_poly_trait_ref(this,\n-                                                                  rscope,\n-                                                                  path.span,\n-                                                                  PathParamMode::Explicit,\n-                                                                  trait_def_id,\n-                                                                  path.segments.last().unwrap(),\n-                                                                  &mut projection_bounds);\n+                    let trait_ref =\n+                        self.object_path_to_poly_trait_ref(rscope,\n+                                                           path.span,\n+                                                           PathParamMode::Explicit,\n+                                                           trait_def_id,\n+                                                           path.segments.last().unwrap(),\n+                                                           &mut projection_bounds);\n                     Ok((trait_ref, projection_bounds))\n                 }\n                 _ => {\n-                    span_err!(this.tcx().sess, ty.span, E0172, \"expected a reference to a trait\");\n+                    span_err!(self.tcx().sess, ty.span, E0172, \"expected a reference to a trait\");\n                     Err(ErrorReported)\n                 }\n             }\n         }\n         _ => {\n-            let mut err = struct_span_err!(this.tcx().sess, ty.span, E0178,\n+            let mut err = struct_span_err!(self.tcx().sess, ty.span, E0178,\n                                            \"expected a path on the left-hand side of `+`, not `{}`\",\n                                            pprust::ty_to_string(ty));\n             let hi = bounds.iter().map(|x| match *x {\n@@ -1083,34 +1066,33 @@ fn ast_ty_to_trait_ref<'tcx>(this: &AstConv<'tcx, 'tcx>,\n     }\n }\n \n-fn trait_ref_to_object_type<'tcx>(this: &AstConv<'tcx, 'tcx>,\n-                                  rscope: &RegionScope,\n-                                  span: Span,\n-                                  trait_ref: ty::PolyTraitRef<'tcx>,\n-                                  projection_bounds: Vec<ty::PolyProjectionPredicate<'tcx>>,\n-                                  bounds: &[hir::TyParamBound])\n-                                  -> Ty<'tcx>\n+fn trait_ref_to_object_type(&self,\n+                            rscope: &RegionScope,\n+                            span: Span,\n+                            trait_ref: ty::PolyTraitRef<'tcx>,\n+                            projection_bounds: Vec<ty::PolyProjectionPredicate<'tcx>>,\n+                            bounds: &[hir::TyParamBound])\n+                            -> Ty<'tcx>\n {\n-    let existential_bounds = conv_existential_bounds(this,\n-                                                     rscope,\n-                                                     span,\n-                                                     trait_ref.clone(),\n-                                                     projection_bounds,\n-                                                     bounds);\n-\n-    let result = make_object_type(this, span, trait_ref, existential_bounds);\n+    let existential_bounds = self.conv_existential_bounds(rscope,\n+                                                          span,\n+                                                          trait_ref.clone(),\n+                                                          projection_bounds,\n+                                                          bounds);\n+\n+    let result = self.make_object_type(span, trait_ref, existential_bounds);\n     debug!(\"trait_ref_to_object_type: result={:?}\",\n            result);\n \n     result\n }\n \n-fn make_object_type<'tcx>(this: &AstConv<'tcx, 'tcx>,\n-                          span: Span,\n-                          principal: ty::PolyTraitRef<'tcx>,\n-                          bounds: ty::ExistentialBounds<'tcx>)\n-                          -> Ty<'tcx> {\n-    let tcx = this.tcx();\n+fn make_object_type(&self,\n+                    span: Span,\n+                    principal: ty::PolyTraitRef<'tcx>,\n+                    bounds: ty::ExistentialBounds<'tcx>)\n+                    -> Ty<'tcx> {\n+    let tcx = self.tcx();\n     let object = ty::TraitTy {\n         principal: principal,\n         bounds: bounds\n@@ -1119,7 +1101,7 @@ fn make_object_type<'tcx>(this: &AstConv<'tcx, 'tcx>,\n         object.principal_trait_ref_with_self_ty(tcx, tcx.types.err);\n \n     // ensure the super predicates and stop if we encountered an error\n-    if this.ensure_super_predicates(span, principal.def_id()).is_err() {\n+    if self.ensure_super_predicates(span, principal.def_id()).is_err() {\n         return tcx.types.err;\n     }\n \n@@ -1162,12 +1144,12 @@ fn make_object_type<'tcx>(this: &AstConv<'tcx, 'tcx>,\n     tcx.mk_trait(object.principal, object.bounds)\n }\n \n-fn report_ambiguous_associated_type(tcx: TyCtxt,\n+fn report_ambiguous_associated_type(&self,\n                                     span: Span,\n                                     type_str: &str,\n                                     trait_str: &str,\n                                     name: &str) {\n-    span_err!(tcx.sess, span, E0223,\n+    span_err!(self.tcx().sess, span, E0223,\n               \"ambiguous associated type; specify the type using the syntax \\\n                `<{} as {}>::{}`\",\n               type_str, trait_str, name);\n@@ -1178,61 +1160,60 @@ fn report_ambiguous_associated_type(tcx: TyCtxt,\n // (which might be `Self`, but only if it is the `Self` of a trait, not an\n // impl). This function will fail if there are no suitable bounds or there is\n // any ambiguity.\n-fn find_bound_for_assoc_item<'tcx>(this: &AstConv<'tcx, 'tcx>,\n-                                   ty_param_node_id: ast::NodeId,\n-                                   ty_param_name: ast::Name,\n-                                   assoc_name: ast::Name,\n-                                   span: Span)\n-                                   -> Result<ty::PolyTraitRef<'tcx>, ErrorReported>\n+fn find_bound_for_assoc_item(&self,\n+                             ty_param_node_id: ast::NodeId,\n+                             ty_param_name: ast::Name,\n+                             assoc_name: ast::Name,\n+                             span: Span)\n+                             -> Result<ty::PolyTraitRef<'tcx>, ErrorReported>\n {\n-    let tcx = this.tcx();\n+    let tcx = self.tcx();\n \n-    let bounds = match this.get_type_parameter_bounds(span, ty_param_node_id) {\n+    let bounds = match self.get_type_parameter_bounds(span, ty_param_node_id) {\n         Ok(v) => v,\n         Err(ErrorReported) => {\n             return Err(ErrorReported);\n         }\n     };\n \n     // Ensure the super predicates and stop if we encountered an error.\n-    if bounds.iter().any(|b| this.ensure_super_predicates(span, b.def_id()).is_err()) {\n+    if bounds.iter().any(|b| self.ensure_super_predicates(span, b.def_id()).is_err()) {\n         return Err(ErrorReported);\n     }\n \n     // Check that there is exactly one way to find an associated type with the\n     // correct name.\n     let suitable_bounds: Vec<_> =\n         traits::transitive_bounds(tcx, &bounds)\n-        .filter(|b| this.trait_defines_associated_type_named(b.def_id(), assoc_name))\n+        .filter(|b| self.trait_defines_associated_type_named(b.def_id(), assoc_name))\n         .collect();\n \n-    one_bound_for_assoc_type(this,\n-                             suitable_bounds,\n-                             &ty_param_name.as_str(),\n-                             &assoc_name.as_str(),\n-                             span)\n+    self.one_bound_for_assoc_type(suitable_bounds,\n+                                  &ty_param_name.as_str(),\n+                                  &assoc_name.as_str(),\n+                                  span)\n }\n \n \n // Checks that bounds contains exactly one element and reports appropriate\n // errors otherwise.\n-fn one_bound_for_assoc_type<'tcx>(this: &AstConv<'tcx, 'tcx>,\n-                                  bounds: Vec<ty::PolyTraitRef<'tcx>>,\n-                                  ty_param_name: &str,\n-                                  assoc_name: &str,\n-                                  span: Span)\n+fn one_bound_for_assoc_type(&self,\n+                            bounds: Vec<ty::PolyTraitRef<'tcx>>,\n+                            ty_param_name: &str,\n+                            assoc_name: &str,\n+                            span: Span)\n     -> Result<ty::PolyTraitRef<'tcx>, ErrorReported>\n {\n     if bounds.is_empty() {\n-        span_err!(this.tcx().sess, span, E0220,\n+        span_err!(self.tcx().sess, span, E0220,\n                   \"associated type `{}` not found for `{}`\",\n                   assoc_name,\n                   ty_param_name);\n         return Err(ErrorReported);\n     }\n \n     if bounds.len() > 1 {\n-        let mut err = struct_span_err!(this.tcx().sess, span, E0221,\n+        let mut err = struct_span_err!(self.tcx().sess, span, E0221,\n                                        \"ambiguous associated type `{}` in bounds of `{}`\",\n                                        assoc_name,\n                                        ty_param_name);\n@@ -1255,14 +1236,14 @@ fn one_bound_for_assoc_type<'tcx>(this: &AstConv<'tcx, 'tcx>,\n // the whole path.\n // Will fail except for T::A and Self::A; i.e., if ty/ty_path_def are not a type\n // parameter or Self.\n-fn associated_path_def_to_ty<'tcx>(this: &AstConv<'tcx, 'tcx>,\n-                                   span: Span,\n-                                   ty: Ty<'tcx>,\n-                                   ty_path_def: Def,\n-                                   item_segment: &hir::PathSegment)\n-                                   -> (Ty<'tcx>, Def)\n+fn associated_path_def_to_ty(&self,\n+                             span: Span,\n+                             ty: Ty<'tcx>,\n+                             ty_path_def: Def,\n+                             item_segment: &hir::PathSegment)\n+                             -> (Ty<'tcx>, Def)\n {\n-    let tcx = this.tcx();\n+    let tcx = self.tcx();\n     let assoc_name = item_segment.identifier.name;\n \n     debug!(\"associated_path_def_to_ty: {:?}::{}\", ty, assoc_name);\n@@ -1276,65 +1257,61 @@ fn associated_path_def_to_ty<'tcx>(this: &AstConv<'tcx, 'tcx>,\n             // `Self` in an impl of a trait - we have a concrete self type and a\n             // trait reference.\n             let trait_ref = tcx.impl_trait_ref(tcx.map.local_def_id(impl_id)).unwrap();\n-            let trait_ref = if let Some(free_substs) = this.get_free_substs() {\n+            let trait_ref = if let Some(free_substs) = self.get_free_substs() {\n                 trait_ref.subst(tcx, free_substs)\n             } else {\n                 trait_ref\n             };\n \n-            if this.ensure_super_predicates(span, trait_did).is_err() {\n+            if self.ensure_super_predicates(span, trait_did).is_err() {\n                 return (tcx.types.err, ty_path_def);\n             }\n \n             let candidates: Vec<ty::PolyTraitRef> =\n                 traits::supertraits(tcx, ty::Binder(trait_ref))\n-                .filter(|r| this.trait_defines_associated_type_named(r.def_id(),\n+                .filter(|r| self.trait_defines_associated_type_named(r.def_id(),\n                                                                      assoc_name))\n                 .collect();\n \n-            match one_bound_for_assoc_type(this,\n-                                           candidates,\n-                                           \"Self\",\n-                                           &assoc_name.as_str(),\n-                                           span) {\n+            match self.one_bound_for_assoc_type(candidates,\n+                                                \"Self\",\n+                                                &assoc_name.as_str(),\n+                                                span) {\n                 Ok(bound) => bound,\n                 Err(ErrorReported) => return (tcx.types.err, ty_path_def),\n             }\n         }\n         (&ty::TyParam(_), Def::SelfTy(Some(trait_did), None)) => {\n             let trait_node_id = tcx.map.as_local_node_id(trait_did).unwrap();\n-            match find_bound_for_assoc_item(this,\n-                                            trait_node_id,\n-                                            keywords::SelfType.name(),\n-                                            assoc_name,\n-                                            span) {\n+            match self.find_bound_for_assoc_item(trait_node_id,\n+                                                 keywords::SelfType.name(),\n+                                                 assoc_name,\n+                                                 span) {\n                 Ok(bound) => bound,\n                 Err(ErrorReported) => return (tcx.types.err, ty_path_def),\n             }\n         }\n         (&ty::TyParam(_), Def::TyParam(_, _, param_did, param_name)) => {\n             let param_node_id = tcx.map.as_local_node_id(param_did).unwrap();\n-            match find_bound_for_assoc_item(this,\n-                                            param_node_id,\n-                                            param_name,\n-                                            assoc_name,\n-                                            span) {\n+            match self.find_bound_for_assoc_item(param_node_id,\n+                                                 param_name,\n+                                                 assoc_name,\n+                                                 span) {\n                 Ok(bound) => bound,\n                 Err(ErrorReported) => return (tcx.types.err, ty_path_def),\n             }\n         }\n         _ => {\n-            report_ambiguous_associated_type(tcx,\n-                                             span,\n-                                             &ty.to_string(),\n-                                             \"Trait\",\n-                                             &assoc_name.as_str());\n+            self.report_ambiguous_associated_type(span,\n+                                                  &ty.to_string(),\n+                                                  \"Trait\",\n+                                                  &assoc_name.as_str());\n             return (tcx.types.err, ty_path_def);\n         }\n     };\n \n     let trait_did = bound.0.def_id;\n-    let ty = this.projected_ty_from_poly_trait_ref(span, bound, assoc_name);\n+    let ty = self.projected_ty_from_poly_trait_ref(span, bound, assoc_name);\n \n     let item_did = if let Some(trait_id) = tcx.map.as_local_node_id(trait_did) {\n         // `ty::trait_items` used below requires information generated\n@@ -1357,45 +1334,43 @@ fn associated_path_def_to_ty<'tcx>(this: &AstConv<'tcx, 'tcx>,\n     (ty, Def::AssociatedTy(trait_did, item_did))\n }\n \n-fn qpath_to_ty<'tcx>(this: &AstConv<'tcx, 'tcx>,\n-                     rscope: &RegionScope,\n-                     span: Span,\n-                     param_mode: PathParamMode,\n-                     opt_self_ty: Option<Ty<'tcx>>,\n-                     trait_def_id: DefId,\n-                     trait_segment: &hir::PathSegment,\n-                     item_segment: &hir::PathSegment)\n-                     -> Ty<'tcx>\n+fn qpath_to_ty(&self,\n+               rscope: &RegionScope,\n+               span: Span,\n+               param_mode: PathParamMode,\n+               opt_self_ty: Option<Ty<'tcx>>,\n+               trait_def_id: DefId,\n+               trait_segment: &hir::PathSegment,\n+               item_segment: &hir::PathSegment)\n+               -> Ty<'tcx>\n {\n-    let tcx = this.tcx();\n+    let tcx = self.tcx();\n \n     tcx.prohibit_type_params(slice::ref_slice(item_segment));\n \n     let self_ty = if let Some(ty) = opt_self_ty {\n         ty\n     } else {\n         let path_str = tcx.item_path_str(trait_def_id);\n-        report_ambiguous_associated_type(tcx,\n-                                         span,\n-                                         \"Type\",\n-                                         &path_str,\n-                                         &item_segment.identifier.name.as_str());\n+        self.report_ambiguous_associated_type(span,\n+                                              \"Type\",\n+                                              &path_str,\n+                                              &item_segment.identifier.name.as_str());\n         return tcx.types.err;\n     };\n \n     debug!(\"qpath_to_ty: self_type={:?}\", self_ty);\n \n-    let trait_ref = ast_path_to_mono_trait_ref(this,\n-                                               rscope,\n-                                               span,\n-                                               param_mode,\n-                                               trait_def_id,\n-                                               Some(self_ty),\n-                                               trait_segment);\n+    let trait_ref = self.ast_path_to_mono_trait_ref(rscope,\n+                                                    span,\n+                                                    param_mode,\n+                                                    trait_def_id,\n+                                                    Some(self_ty),\n+                                                    trait_segment);\n \n     debug!(\"qpath_to_ty: trait_ref={:?}\", trait_ref);\n \n-    this.projected_ty(span, trait_ref, item_segment.identifier.name)\n+    self.projected_ty(span, trait_ref, item_segment.identifier.name)\n }\n \n /// Convert a type supplied as value for a type argument from AST into our\n@@ -1412,68 +1387,66 @@ fn qpath_to_ty<'tcx>(this: &AstConv<'tcx, 'tcx>,\n /// * `region_substs`: a partial substitution consisting of\n ///   only the region type parameters being supplied to this type.\n /// * `ast_ty`: the ast representation of the type being supplied\n-pub fn ast_ty_arg_to_ty<'tcx>(this: &AstConv<'tcx, 'tcx>,\n-                              rscope: &RegionScope,\n-                              decl_generics: &ty::Generics<'tcx>,\n-                              index: usize,\n-                              region_substs: &Substs<'tcx>,\n-                              ast_ty: &hir::Ty)\n-                              -> Ty<'tcx>\n+pub fn ast_ty_arg_to_ty(&self,\n+                        rscope: &RegionScope,\n+                        decl_generics: &ty::Generics<'tcx>,\n+                        index: usize,\n+                        region_substs: &Substs<'tcx>,\n+                        ast_ty: &hir::Ty)\n+                        -> Ty<'tcx>\n {\n-    let tcx = this.tcx();\n+    let tcx = self.tcx();\n \n     if let Some(def) = decl_generics.types.opt_get(TypeSpace, index) {\n         let object_lifetime_default = def.object_lifetime_default.subst(tcx, region_substs);\n         let rscope1 = &ObjectLifetimeDefaultRscope::new(rscope, object_lifetime_default);\n-        ast_ty_to_ty(this, rscope1, ast_ty)\n+        self.ast_ty_to_ty(rscope1, ast_ty)\n     } else {\n-        ast_ty_to_ty(this, rscope, ast_ty)\n+        self.ast_ty_to_ty(rscope, ast_ty)\n     }\n }\n \n // Check the base def in a PathResolution and convert it to a Ty. If there are\n // associated types in the PathResolution, these will need to be separately\n // resolved.\n-fn base_def_to_ty<'tcx>(this: &AstConv<'tcx, 'tcx>,\n-                        rscope: &RegionScope,\n-                        span: Span,\n-                        param_mode: PathParamMode,\n-                        def: &Def,\n-                        opt_self_ty: Option<Ty<'tcx>>,\n-                        base_segments: &[hir::PathSegment])\n-                        -> Ty<'tcx> {\n-    let tcx = this.tcx();\n+fn base_def_to_ty(&self,\n+                  rscope: &RegionScope,\n+                  span: Span,\n+                  param_mode: PathParamMode,\n+                  def: &Def,\n+                  opt_self_ty: Option<Ty<'tcx>>,\n+                  base_segments: &[hir::PathSegment])\n+                  -> Ty<'tcx> {\n+    let tcx = self.tcx();\n \n     match *def {\n         Def::Trait(trait_def_id) => {\n             // N.B. this case overlaps somewhat with\n             // TyObjectSum, see that fn for details\n             let mut projection_bounds = Vec::new();\n \n-            let trait_ref = object_path_to_poly_trait_ref(this,\n-                                                          rscope,\n-                                                          span,\n-                                                          param_mode,\n-                                                          trait_def_id,\n-                                                          base_segments.last().unwrap(),\n-                                                          &mut projection_bounds);\n+            let trait_ref =\n+                self.object_path_to_poly_trait_ref(rscope,\n+                                                   span,\n+                                                   param_mode,\n+                                                   trait_def_id,\n+                                                   base_segments.last().unwrap(),\n+                                                   &mut projection_bounds);\n \n             tcx.prohibit_type_params(base_segments.split_last().unwrap().1);\n-            trait_ref_to_object_type(this,\n-                                     rscope,\n-                                     span,\n-                                     trait_ref,\n-                                     projection_bounds,\n-                                     &[])\n+            self.trait_ref_to_object_type(rscope,\n+                                          span,\n+                                          trait_ref,\n+                                          projection_bounds,\n+                                          &[])\n         }\n         Def::Enum(did) | Def::TyAlias(did) | Def::Struct(did) => {\n             tcx.prohibit_type_params(base_segments.split_last().unwrap().1);\n-            ast_path_to_ty(this,\n-                           rscope,\n-                           span,\n-                           param_mode,\n-                           did,\n-                           base_segments.last().unwrap())\n+            self.ast_path_to_ty(rscope,\n+                                span,\n+                                param_mode,\n+                                did,\n+                                base_segments.last().unwrap())\n         }\n         Def::TyParam(space, index, _, name) => {\n             tcx.prohibit_type_params(base_segments);\n@@ -1483,7 +1456,7 @@ fn base_def_to_ty<'tcx>(this: &AstConv<'tcx, 'tcx>,\n             // Self in impl (we know the concrete type).\n             tcx.prohibit_type_params(base_segments);\n             let ty = tcx.node_id_to_type(impl_id);\n-            if let Some(free_substs) = this.get_free_substs() {\n+            if let Some(free_substs) = self.get_free_substs() {\n                 ty.subst(tcx, free_substs)\n             } else {\n                 ty\n@@ -1496,14 +1469,13 @@ fn base_def_to_ty<'tcx>(this: &AstConv<'tcx, 'tcx>,\n         }\n         Def::AssociatedTy(trait_did, _) => {\n             tcx.prohibit_type_params(&base_segments[..base_segments.len()-2]);\n-            qpath_to_ty(this,\n-                        rscope,\n-                        span,\n-                        param_mode,\n-                        opt_self_ty,\n-                        trait_did,\n-                        &base_segments[base_segments.len()-2],\n-                        base_segments.last().unwrap())\n+            self.qpath_to_ty(rscope,\n+                             span,\n+                             param_mode,\n+                             opt_self_ty,\n+                             trait_did,\n+                             &base_segments[base_segments.len()-2],\n+                             base_segments.last().unwrap())\n         }\n         Def::Mod(..) => {\n             // Used as sentinel by callers to indicate the `<T>::A::B::C` form.\n@@ -1522,48 +1494,46 @@ fn base_def_to_ty<'tcx>(this: &AstConv<'tcx, 'tcx>,\n             tcx.prim_ty_to_ty(base_segments, prim_ty)\n         }\n         Def::Err => {\n-            this.set_tainted_by_errors();\n-            return this.tcx().types.err;\n+            self.set_tainted_by_errors();\n+            return self.tcx().types.err;\n         }\n         _ => {\n             span_err!(tcx.sess, span, E0248,\n                       \"found value `{}` used as a type\",\n                       tcx.item_path_str(def.def_id()));\n-            return this.tcx().types.err;\n+            return self.tcx().types.err;\n         }\n     }\n }\n \n // Note that both base_segments and assoc_segments may be empty, although not at\n // the same time.\n-pub fn finish_resolving_def_to_ty<'tcx>(this: &AstConv<'tcx, 'tcx>,\n-                                        rscope: &RegionScope,\n-                                        span: Span,\n-                                        param_mode: PathParamMode,\n-                                        def: &Def,\n-                                        opt_self_ty: Option<Ty<'tcx>>,\n-                                        base_segments: &[hir::PathSegment],\n-                                        assoc_segments: &[hir::PathSegment])\n-                                        -> Ty<'tcx> {\n-    let mut ty = base_def_to_ty(this,\n-                                rscope,\n-                                span,\n-                                param_mode,\n-                                def,\n-                                opt_self_ty,\n-                                base_segments);\n+pub fn finish_resolving_def_to_ty(&self,\n+                                  rscope: &RegionScope,\n+                                  span: Span,\n+                                  param_mode: PathParamMode,\n+                                  def: &Def,\n+                                  opt_self_ty: Option<Ty<'tcx>>,\n+                                  base_segments: &[hir::PathSegment],\n+                                  assoc_segments: &[hir::PathSegment])\n+                                  -> Ty<'tcx> {\n+    let mut ty = self.base_def_to_ty(rscope,\n+                                     span,\n+                                     param_mode,\n+                                     def,\n+                                     opt_self_ty,\n+                                     base_segments);\n     let mut def = *def;\n     // If any associated type segments remain, attempt to resolve them.\n     for segment in assoc_segments {\n         if ty.sty == ty::TyError {\n             break;\n         }\n         // This is pretty bad (it will fail except for T::A and Self::A).\n-        let (a_ty, a_def) = associated_path_def_to_ty(this,\n-                                                      span,\n-                                                      ty,\n-                                                      def,\n-                                                      segment);\n+        let (a_ty, a_def) = self.associated_path_def_to_ty(span,\n+                                                           ty,\n+                                                           def,\n+                                                           segment);\n         ty = a_ty;\n         def = a_def;\n     }\n@@ -1572,63 +1542,58 @@ pub fn finish_resolving_def_to_ty<'tcx>(this: &AstConv<'tcx, 'tcx>,\n \n /// Parses the programmer's textual representation of a type into our\n /// internal notion of a type.\n-pub fn ast_ty_to_ty<'tcx>(this: &AstConv<'tcx, 'tcx>,\n-                          rscope: &RegionScope,\n-                          ast_ty: &hir::Ty)\n-                          -> Ty<'tcx>\n-{\n+pub fn ast_ty_to_ty(&self, rscope: &RegionScope, ast_ty: &hir::Ty) -> Ty<'tcx> {\n     debug!(\"ast_ty_to_ty(id={:?}, ast_ty={:?})\",\n            ast_ty.id, ast_ty);\n \n-    let tcx = this.tcx();\n+    let tcx = self.tcx();\n \n     match ast_ty.node {\n         hir::TyVec(ref ty) => {\n-            tcx.mk_slice(ast_ty_to_ty(this, rscope, &ty))\n+            tcx.mk_slice(self.ast_ty_to_ty(rscope, &ty))\n         }\n         hir::TyObjectSum(ref ty, ref bounds) => {\n-            match ast_ty_to_trait_ref(this, rscope, &ty, bounds) {\n+            match self.ast_ty_to_trait_ref(rscope, &ty, bounds) {\n                 Ok((trait_ref, projection_bounds)) => {\n-                    trait_ref_to_object_type(this,\n-                                             rscope,\n-                                             ast_ty.span,\n-                                             trait_ref,\n-                                             projection_bounds,\n-                                             bounds)\n+                    self.trait_ref_to_object_type(rscope,\n+                                                  ast_ty.span,\n+                                                  trait_ref,\n+                                                  projection_bounds,\n+                                                  bounds)\n                 }\n                 Err(ErrorReported) => {\n-                    this.tcx().types.err\n+                    self.tcx().types.err\n                 }\n             }\n         }\n         hir::TyPtr(ref mt) => {\n             tcx.mk_ptr(ty::TypeAndMut {\n-                ty: ast_ty_to_ty(this, rscope, &mt.ty),\n+                ty: self.ast_ty_to_ty(rscope, &mt.ty),\n                 mutbl: mt.mutbl\n             })\n         }\n         hir::TyRptr(ref region, ref mt) => {\n-            let r = opt_ast_region_to_region(this, rscope, ast_ty.span, region);\n+            let r = self.opt_ast_region_to_region(rscope, ast_ty.span, region);\n             debug!(\"TyRef r={:?}\", r);\n             let rscope1 =\n                 &ObjectLifetimeDefaultRscope::new(\n                     rscope,\n                     ty::ObjectLifetimeDefault::Specific(r));\n-            let t = ast_ty_to_ty(this, rscope1, &mt.ty);\n+            let t = self.ast_ty_to_ty(rscope1, &mt.ty);\n             tcx.mk_ref(tcx.mk_region(r), ty::TypeAndMut {ty: t, mutbl: mt.mutbl})\n         }\n         hir::TyTup(ref fields) => {\n             let flds = fields.iter()\n-                             .map(|t| ast_ty_to_ty(this, rscope, &t))\n+                             .map(|t| self.ast_ty_to_ty(rscope, &t))\n                              .collect();\n             tcx.mk_tup(flds)\n         }\n         hir::TyBareFn(ref bf) => {\n             require_c_abi_if_variadic(tcx, &bf.decl, bf.abi, ast_ty.span);\n-            tcx.mk_fn_ptr(ty_of_bare_fn(this, bf.unsafety, bf.abi, &bf.decl))\n+            tcx.mk_fn_ptr(self.ty_of_bare_fn(bf.unsafety, bf.abi, &bf.decl))\n         }\n         hir::TyPolyTraitRef(ref bounds) => {\n-            conv_ty_poly_trait_ref(this, rscope, ast_ty.span, bounds)\n+            self.conv_ty_poly_trait_ref(rscope, ast_ty.span, bounds)\n         }\n         hir::TyPath(ref maybe_qself, ref path) => {\n             let path_res = if let Some(&d) = tcx.def_map.borrow().get(&ast_ty.id) {\n@@ -1645,16 +1610,15 @@ pub fn ast_ty_to_ty<'tcx>(this: &AstConv<'tcx, 'tcx>,\n             let def = path_res.base_def;\n             let base_ty_end = path.segments.len() - path_res.depth;\n             let opt_self_ty = maybe_qself.as_ref().map(|qself| {\n-                ast_ty_to_ty(this, rscope, &qself.ty)\n+                self.ast_ty_to_ty(rscope, &qself.ty)\n             });\n-            let ty = finish_resolving_def_to_ty(this,\n-                                                rscope,\n-                                                ast_ty.span,\n-                                                PathParamMode::Explicit,\n-                                                &def,\n-                                                opt_self_ty,\n-                                                &path.segments[..base_ty_end],\n-                                                &path.segments[base_ty_end..]);\n+            let ty = self.finish_resolving_def_to_ty(rscope,\n+                                                     ast_ty.span,\n+                                                     PathParamMode::Explicit,\n+                                                     &def,\n+                                                     opt_self_ty,\n+                                                     &path.segments[..base_ty_end],\n+                                                     &path.segments[base_ty_end..]);\n \n             if path_res.depth != 0 && ty.sty != ty::TyError {\n                 // Write back the new resolution.\n@@ -1668,16 +1632,16 @@ pub fn ast_ty_to_ty<'tcx>(this: &AstConv<'tcx, 'tcx>,\n         }\n         hir::TyFixedLengthVec(ref ty, ref e) => {\n             let hint = UncheckedExprHint(tcx.types.usize);\n-            match eval_const_expr_partial(tcx, &e, hint, None) {\n+            match eval_const_expr_partial(tcx.global_tcx(), &e, hint, None) {\n                 Ok(ConstVal::Integral(ConstInt::Usize(i))) => {\n                     let i = i.as_u64(tcx.sess.target.uint_type);\n                     assert_eq!(i as usize as u64, i);\n-                    tcx.mk_array(ast_ty_to_ty(this, rscope, &ty), i as usize)\n+                    tcx.mk_array(self.ast_ty_to_ty(rscope, &ty), i as usize)\n                 },\n                 Ok(val) => {\n                     span_err!(tcx.sess, ast_ty.span, E0249,\n                               \"expected usize value for array length, got {}\", val.description());\n-                    this.tcx().types.err\n+                    self.tcx().types.err\n                 },\n                 // array length errors happen before the global constant check\n                 // so we need to report the real error\n@@ -1690,7 +1654,7 @@ pub fn ast_ty_to_ty<'tcx>(this: &AstConv<'tcx, 'tcx>,\n                         span_note!(&mut err, ast_ty.span, \"for array length here\")\n                     }\n                     err.emit();\n-                    this.tcx().types.err\n+                    self.tcx().types.err\n                 }\n             }\n         }\n@@ -1704,61 +1668,55 @@ pub fn ast_ty_to_ty<'tcx>(this: &AstConv<'tcx, 'tcx>,\n             // values in a ExprClosure, or as\n             // the type of local variables. Both of these cases are\n             // handled specially and will not descend into this routine.\n-            this.ty_infer(None, None, None, ast_ty.span)\n+            self.ty_infer(None, None, None, ast_ty.span)\n         }\n     }\n }\n \n-pub fn ty_of_arg<'tcx>(this: &AstConv<'tcx, 'tcx>,\n-                       rscope: &RegionScope,\n-                       a: &hir::Arg,\n-                       expected_ty: Option<Ty<'tcx>>)\n-                       -> Ty<'tcx>\n+pub fn ty_of_arg(&self,\n+                 rscope: &RegionScope,\n+                 a: &hir::Arg,\n+                 expected_ty: Option<Ty<'tcx>>)\n+                 -> Ty<'tcx>\n {\n     match a.ty.node {\n         hir::TyInfer if expected_ty.is_some() => expected_ty.unwrap(),\n-        hir::TyInfer => this.ty_infer(None, None, None, a.ty.span),\n-        _ => ast_ty_to_ty(this, rscope, &a.ty),\n+        hir::TyInfer => self.ty_infer(None, None, None, a.ty.span),\n+        _ => self.ast_ty_to_ty(rscope, &a.ty),\n     }\n }\n \n-struct SelfInfo<'a, 'tcx> {\n-    untransformed_self_ty: Ty<'tcx>,\n-    explicit_self: &'a hir::ExplicitSelf,\n-}\n-\n-pub fn ty_of_method<'tcx>(this: &AstConv<'tcx, 'tcx>,\n-                          sig: &hir::MethodSig,\n-                          untransformed_self_ty: Ty<'tcx>)\n-                          -> (&'tcx ty::BareFnTy<'tcx>, ty::ExplicitSelfCategory) {\n+pub fn ty_of_method(&self,\n+                    sig: &hir::MethodSig,\n+                    untransformed_self_ty: Ty<'tcx>)\n+                    -> (&'tcx ty::BareFnTy<'tcx>, ty::ExplicitSelfCategory) {\n     let self_info = Some(SelfInfo {\n         untransformed_self_ty: untransformed_self_ty,\n         explicit_self: &sig.explicit_self,\n     });\n     let (bare_fn_ty, optional_explicit_self_category) =\n-        ty_of_method_or_bare_fn(this,\n-                                sig.unsafety,\n-                                sig.abi,\n-                                self_info,\n-                                &sig.decl);\n+        self.ty_of_method_or_bare_fn(sig.unsafety,\n+                                     sig.abi,\n+                                     self_info,\n+                                     &sig.decl);\n     (bare_fn_ty, optional_explicit_self_category.unwrap())\n }\n \n-pub fn ty_of_bare_fn<'tcx>(this: &AstConv<'tcx, 'tcx>,\n-                           unsafety: hir::Unsafety, abi: abi::Abi,\n-                           decl: &hir::FnDecl)\n-                           -> &'tcx ty::BareFnTy<'tcx> {\n-    let (bare_fn_ty, _) = ty_of_method_or_bare_fn(this, unsafety, abi, None, decl);\n+pub fn ty_of_bare_fn(&self,\n+                     unsafety: hir::Unsafety, abi: abi::Abi,\n+                     decl: &hir::FnDecl)\n+                     -> &'tcx ty::BareFnTy<'tcx> {\n+    let (bare_fn_ty, _) = self.ty_of_method_or_bare_fn(unsafety, abi, None, decl);\n     bare_fn_ty\n }\n \n-fn ty_of_method_or_bare_fn<'a, 'tcx>(this: &AstConv<'tcx, 'tcx>,\n-                                     unsafety: hir::Unsafety,\n-                                     abi: abi::Abi,\n-                                     opt_self_info: Option<SelfInfo<'a, 'tcx>>,\n-                                     decl: &hir::FnDecl)\n-                                     -> (&'tcx ty::BareFnTy<'tcx>,\n-                                         Option<ty::ExplicitSelfCategory>)\n+fn ty_of_method_or_bare_fn<'a>(&self,\n+                               unsafety: hir::Unsafety,\n+                               abi: abi::Abi,\n+                               opt_self_info: Option<SelfInfo<'a, 'tcx>>,\n+                               decl: &hir::FnDecl)\n+                               -> (&'tcx ty::BareFnTy<'tcx>,\n+                                   Option<ty::ExplicitSelfCategory>)\n {\n     debug!(\"ty_of_method_or_bare_fn\");\n \n@@ -1773,7 +1731,7 @@ fn ty_of_method_or_bare_fn<'a, 'tcx>(this: &AstConv<'tcx, 'tcx>,\n     // region of the self parameter.\n     let (self_ty, explicit_self_category) = match opt_self_info {\n         None => (None, None),\n-        Some(self_info) => determine_self_type(this, &rb, self_info)\n+        Some(self_info) => self.determine_self_type(&rb, self_info)\n     };\n \n     // HACK(eddyb) replace the fake self type in the AST with the actual type.\n@@ -1783,7 +1741,7 @@ fn ty_of_method_or_bare_fn<'a, 'tcx>(this: &AstConv<'tcx, 'tcx>,\n         &decl.inputs[..]\n     };\n     let arg_tys: Vec<Ty> =\n-        arg_params.iter().map(|a| ty_of_arg(this, &rb, a, None)).collect();\n+        arg_params.iter().map(|a| self.ty_of_arg(&rb, a, None)).collect();\n     let arg_pats: Vec<String> =\n         arg_params.iter().map(|a| pprust::pat_to_string(&a.pat)).collect();\n \n@@ -1792,19 +1750,18 @@ fn ty_of_method_or_bare_fn<'a, 'tcx>(this: &AstConv<'tcx, 'tcx>,\n     // have that lifetime.\n     let implied_output_region = match explicit_self_category {\n         Some(ty::ExplicitSelfCategory::ByReference(region, _)) => Ok(region),\n-        _ => find_implied_output_region(this, &arg_tys, arg_pats)\n+        _ => self.find_implied_output_region(&arg_tys, arg_pats)\n     };\n \n     let output_ty = match decl.output {\n         hir::Return(ref output) =>\n-            ty::FnConverging(convert_ty_with_lifetime_elision(this,\n-                                                              implied_output_region,\n-                                                              &output)),\n-        hir::DefaultReturn(..) => ty::FnConverging(this.tcx().mk_nil()),\n+            ty::FnConverging(self.convert_ty_with_lifetime_elision(implied_output_region,\n+                                                                   &output)),\n+        hir::DefaultReturn(..) => ty::FnConverging(self.tcx().mk_nil()),\n         hir::NoReturn(..) => ty::FnDiverging\n     };\n \n-    (this.tcx().mk_bare_fn(ty::BareFnTy {\n+    (self.tcx().mk_bare_fn(ty::BareFnTy {\n         unsafety: unsafety,\n         abi: abi,\n         sig: ty::Binder(ty::FnSig {\n@@ -1815,10 +1772,10 @@ fn ty_of_method_or_bare_fn<'a, 'tcx>(this: &AstConv<'tcx, 'tcx>,\n     }), explicit_self_category)\n }\n \n-fn determine_self_type<'a, 'tcx>(this: &AstConv<'tcx, 'tcx>,\n-                                 rscope: &RegionScope,\n-                                 self_info: SelfInfo<'a, 'tcx>)\n-                                 -> (Option<Ty<'tcx>>, Option<ty::ExplicitSelfCategory>)\n+fn determine_self_type<'a>(&self,\n+                           rscope: &RegionScope,\n+                           self_info: SelfInfo<'a, 'tcx>)\n+                           -> (Option<Ty<'tcx>>, Option<ty::ExplicitSelfCategory>)\n {\n     let self_ty = self_info.untransformed_self_ty;\n     return match self_info.explicit_self.node {\n@@ -1828,20 +1785,19 @@ fn determine_self_type<'a, 'tcx>(this: &AstConv<'tcx, 'tcx>,\n         }\n         hir::SelfRegion(ref lifetime, mutability, _) => {\n             let region =\n-                opt_ast_region_to_region(this,\n-                                         rscope,\n-                                         self_info.explicit_self.span,\n-                                         lifetime);\n-            (Some(this.tcx().mk_ref(\n-                this.tcx().mk_region(region),\n+                self.opt_ast_region_to_region(rscope,\n+                                              self_info.explicit_self.span,\n+                                              lifetime);\n+            (Some(self.tcx().mk_ref(\n+                self.tcx().mk_region(region),\n                 ty::TypeAndMut {\n                     ty: self_ty,\n                     mutbl: mutability\n                 })),\n              Some(ty::ExplicitSelfCategory::ByReference(region, mutability)))\n         }\n         hir::SelfExplicit(ref ast_type, _) => {\n-            let explicit_type = ast_ty_to_ty(this, rscope, &ast_type);\n+            let explicit_type = self.ast_ty_to_ty(rscope, &ast_type);\n \n             // We wish to (for now) categorize an explicit self\n             // declaration like `self: SomeType` into either `self`,\n@@ -1906,8 +1862,7 @@ fn determine_self_type<'a, 'tcx>(this: &AstConv<'tcx, 'tcx>,\n     }\n }\n \n-pub fn ty_of_closure<'tcx>(\n-    this: &AstConv<'tcx, 'tcx>,\n+pub fn ty_of_closure(&self,\n     unsafety: hir::Unsafety,\n     decl: &hir::FnDecl,\n     abi: abi::Abi,\n@@ -1931,7 +1886,7 @@ pub fn ty_of_closure<'tcx>(\n                 None\n             }\n         });\n-        ty_of_arg(this, &rb, a, expected_arg_ty)\n+        self.ty_of_arg(&rb, a, expected_arg_ty)\n     }).collect();\n \n     let expected_ret_ty = expected_sig.map(|e| e.output);\n@@ -1946,9 +1901,9 @@ pub fn ty_of_closure<'tcx>(\n         _ if is_infer && expected_ret_ty.is_some() =>\n             expected_ret_ty.unwrap(),\n         _ if is_infer =>\n-            ty::FnConverging(this.ty_infer(None, None, None, decl.output.span())),\n+            ty::FnConverging(self.ty_infer(None, None, None, decl.output.span())),\n         hir::Return(ref output) =>\n-            ty::FnConverging(ast_ty_to_ty(this, &rb, &output)),\n+            ty::FnConverging(self.ast_ty_to_ty(&rb, &output)),\n         hir::DefaultReturn(..) => bug!(),\n         hir::NoReturn(..) => ty::FnDiverging\n     };\n@@ -1969,8 +1924,7 @@ pub fn ty_of_closure<'tcx>(\n /// `ExistentialBounds` struct. The `main_trait_refs` argument specifies the `Foo` -- it is absent\n /// for closures. Eventually this should all be normalized, I think, so that there is no \"main\n /// trait ref\" and instead we just have a flat list of bounds as the existential type.\n-fn conv_existential_bounds<'tcx>(\n-    this: &AstConv<'tcx, 'tcx>,\n+fn conv_existential_bounds(&self,\n     rscope: &RegionScope,\n     span: Span,\n     principal_trait_ref: ty::PolyTraitRef<'tcx>,\n@@ -1979,48 +1933,44 @@ fn conv_existential_bounds<'tcx>(\n     -> ty::ExistentialBounds<'tcx>\n {\n     let partitioned_bounds =\n-        partition_bounds(this.tcx(), span, ast_bounds);\n+        partition_bounds(self.tcx(), span, ast_bounds);\n \n-    conv_existential_bounds_from_partitioned_bounds(\n-        this, rscope, span, principal_trait_ref, projection_bounds, partitioned_bounds)\n+    self.conv_existential_bounds_from_partitioned_bounds(\n+        rscope, span, principal_trait_ref, projection_bounds, partitioned_bounds)\n }\n \n-fn conv_ty_poly_trait_ref<'tcx>(\n-    this: &AstConv<'tcx, 'tcx>,\n+fn conv_ty_poly_trait_ref(&self,\n     rscope: &RegionScope,\n     span: Span,\n     ast_bounds: &[hir::TyParamBound])\n     -> Ty<'tcx>\n {\n-    let mut partitioned_bounds = partition_bounds(this.tcx(), span, &ast_bounds[..]);\n+    let mut partitioned_bounds = partition_bounds(self.tcx(), span, &ast_bounds[..]);\n \n     let mut projection_bounds = Vec::new();\n     let main_trait_bound = if !partitioned_bounds.trait_bounds.is_empty() {\n         let trait_bound = partitioned_bounds.trait_bounds.remove(0);\n-        instantiate_poly_trait_ref(this,\n-                                   rscope,\n-                                   trait_bound,\n-                                   None,\n-                                   &mut projection_bounds)\n+        self.instantiate_poly_trait_ref(rscope,\n+                                        trait_bound,\n+                                        None,\n+                                        &mut projection_bounds)\n     } else {\n-        span_err!(this.tcx().sess, span, E0224,\n+        span_err!(self.tcx().sess, span, E0224,\n                   \"at least one non-builtin trait is required for an object type\");\n-        return this.tcx().types.err;\n+        return self.tcx().types.err;\n     };\n \n     let bounds =\n-        conv_existential_bounds_from_partitioned_bounds(this,\n-                                                        rscope,\n-                                                        span,\n-                                                        main_trait_bound.clone(),\n-                                                        projection_bounds,\n-                                                        partitioned_bounds);\n-\n-    make_object_type(this, span, main_trait_bound, bounds)\n+        self.conv_existential_bounds_from_partitioned_bounds(rscope,\n+                                                             span,\n+                                                             main_trait_bound.clone(),\n+                                                             projection_bounds,\n+                                                             partitioned_bounds);\n+\n+    self.make_object_type(span, main_trait_bound, bounds)\n }\n \n-pub fn conv_existential_bounds_from_partitioned_bounds<'tcx>(\n-    this: &AstConv<'tcx, 'tcx>,\n+pub fn conv_existential_bounds_from_partitioned_bounds(&self,\n     rscope: &RegionScope,\n     span: Span,\n     principal_trait_ref: ty::PolyTraitRef<'tcx>,\n@@ -2035,24 +1985,23 @@ pub fn conv_existential_bounds_from_partitioned_bounds<'tcx>(\n \n     if !trait_bounds.is_empty() {\n         let b = &trait_bounds[0];\n-        span_err!(this.tcx().sess, b.trait_ref.path.span, E0225,\n+        span_err!(self.tcx().sess, b.trait_ref.path.span, E0225,\n                   \"only the builtin traits can be used as closure or object bounds\");\n     }\n \n     let region_bound =\n-        compute_object_lifetime_bound(this,\n-                                      span,\n-                                      &region_bounds,\n-                                      principal_trait_ref,\n-                                      builtin_bounds);\n+        self.compute_object_lifetime_bound(span,\n+                                           &region_bounds,\n+                                           principal_trait_ref,\n+                                           builtin_bounds);\n \n     let region_bound = match region_bound {\n         Some(r) => r,\n         None => {\n             match rscope.object_lifetime_default(span) {\n                 Some(r) => r,\n                 None => {\n-                    span_err!(this.tcx().sess, span, E0228,\n+                    span_err!(self.tcx().sess, span, E0228,\n                               \"the lifetime bound for this object type cannot be deduced \\\n                                from context; please supply an explicit bound\");\n                     ty::ReStatic\n@@ -2070,15 +2019,14 @@ pub fn conv_existential_bounds_from_partitioned_bounds<'tcx>(\n /// (if any) we can use to summarize this type. The basic idea is that we will use the bound the\n /// user provided, if they provided one, and otherwise search the supertypes of trait bounds for\n /// region bounds. It may be that we can derive no bound at all, in which case we return `None`.\n-fn compute_object_lifetime_bound<'tcx>(\n-    this: &AstConv<'tcx, 'tcx>,\n+fn compute_object_lifetime_bound(&self,\n     span: Span,\n     explicit_region_bounds: &[&hir::Lifetime],\n     principal_trait_ref: ty::PolyTraitRef<'tcx>,\n     builtin_bounds: ty::BuiltinBounds)\n     -> Option<ty::Region> // if None, use the default\n {\n-    let tcx = this.tcx();\n+    let tcx = self.tcx();\n \n     debug!(\"compute_opt_region_bound(explicit_region_bounds={:?}, \\\n            principal_trait_ref={:?}, builtin_bounds={:?})\",\n@@ -2097,7 +2045,7 @@ fn compute_object_lifetime_bound<'tcx>(\n         return Some(ast_region_to_region(tcx, r));\n     }\n \n-    if let Err(ErrorReported) = this.ensure_super_predicates(span,principal_trait_ref.def_id()) {\n+    if let Err(ErrorReported) = self.ensure_super_predicates(span,principal_trait_ref.def_id()) {\n         return Some(ty::ReStatic);\n     }\n \n@@ -2128,6 +2076,7 @@ fn compute_object_lifetime_bound<'tcx>(\n     }\n     return Some(r);\n }\n+}\n \n pub struct PartitionedBounds<'a> {\n     pub builtin_bounds: ty::BuiltinBounds,\n@@ -2137,10 +2086,10 @@ pub struct PartitionedBounds<'a> {\n \n /// Divides a list of bounds from the AST into three groups: builtin bounds (Copy, Sized etc),\n /// general trait bounds, and region bounds.\n-pub fn partition_bounds<'a, 'b, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                                      _span: Span,\n-                                      ast_bounds: &'b [hir::TyParamBound])\n-                                      -> PartitionedBounds<'b>\n+pub fn partition_bounds<'a, 'b, 'gcx, 'tcx>(tcx: TyCtxt<'a, 'gcx, 'tcx>,\n+                                            _span: Span,\n+                                            ast_bounds: &'b [hir::TyParamBound])\n+                                            -> PartitionedBounds<'b>\n {\n     let mut builtin_bounds = ty::BuiltinBounds::empty();\n     let mut region_bounds = Vec::new();\n@@ -2227,8 +2176,8 @@ pub struct Bounds<'tcx> {\n     pub projection_bounds: Vec<ty::PolyProjectionPredicate<'tcx>>,\n }\n \n-impl<'a, 'tcx> Bounds<'tcx> {\n-    pub fn predicates(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>, param_ty: Ty<'tcx>)\n+impl<'a, 'gcx, 'tcx> Bounds<'tcx> {\n+    pub fn predicates(&self, tcx: TyCtxt<'a, 'gcx, 'tcx>, param_ty: Ty<'tcx>)\n                       -> Vec<ty::Predicate<'tcx>>\n     {\n         let mut vec = Vec::new();"}, {"sha": "899e4f62cc32cbedb56119e372319c6c98351001", "filename": "src/librustc_typeck/check/_match.rs", "status": "modified", "additions": 13, "deletions": 16, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/31a07b0ce662e95119a76cce8dcfc29d2055f738/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31a07b0ce662e95119a76cce8dcfc29d2055f738/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2F_match.rs?ref=31a07b0ce662e95119a76cce8dcfc29d2055f738", "patch": "@@ -16,7 +16,6 @@ use rustc::ty::subst::Substs;\n use rustc::ty::{self, Ty, TypeFoldable, LvaluePreference};\n use check::{FnCtxt, Expectation};\n use lint;\n-use require_same_types;\n use util::nodemap::FnvHashMap;\n use session::Session;\n \n@@ -56,8 +55,8 @@ fn bad_struct_kind_err(sess: &Session, pat: &hir::Pat, path: &hir::Path, lint: b\n     }\n }\n \n-impl<'a, 'tcx> PatCtxt<'a, 'tcx, 'tcx> {\n-pub fn check_pat(&self, pat: &'tcx hir::Pat, expected: Ty<'tcx>) {\n+impl<'a, 'gcx, 'tcx> PatCtxt<'a, 'gcx, 'tcx> {\n+pub fn check_pat(&self, pat: &'gcx hir::Pat, expected: Ty<'tcx>) {\n     let tcx = self.tcx;\n \n     debug!(\"check_pat(pat={:?},expected={:?})\", pat, expected);\n@@ -133,10 +132,8 @@ pub fn check_pat(&self, pat: &'tcx hir::Pat, expected: Ty<'tcx>) {\n             }\n \n             // Check that the types of the end-points can be unified.\n-            let types_unify = require_same_types(\n-                self.ccx, Some(self), pat.span, rhs_ty, lhs_ty,\n-                \"mismatched types in range\",\n-            );\n+            let types_unify = self.require_same_types(pat.span, rhs_ty, lhs_ty,\n+                                                      \"mismatched types in range\");\n \n             // It's ok to return without a message as `require_same_types` prints an error.\n             if !types_unify {\n@@ -455,11 +452,11 @@ pub fn check_dereferencable(&self, span: Span, expected: Ty<'tcx>, inner: &hir::\n }\n }\n \n-impl<'a, 'tcx> FnCtxt<'a, 'tcx, 'tcx> {\n+impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n pub fn check_match(&self,\n-                   expr: &'tcx hir::Expr,\n-                   discrim: &'tcx hir::Expr,\n-                   arms: &'tcx [hir::Arm],\n+                   expr: &'gcx hir::Expr,\n+                   discrim: &'gcx hir::Expr,\n+                   arms: &'gcx [hir::Arm],\n                    expected: Expectation<'tcx>,\n                    match_src: hir::MatchSource) {\n     let tcx = self.tcx;\n@@ -578,9 +575,9 @@ pub fn check_match(&self,\n }\n }\n \n-impl<'a, 'tcx> PatCtxt<'a, 'tcx, 'tcx> {\n-pub fn check_pat_struct(&self, pat: &'tcx hir::Pat,\n-                        path: &hir::Path, fields: &'tcx [Spanned<hir::FieldPat>],\n+impl<'a, 'gcx, 'tcx> PatCtxt<'a, 'gcx, 'tcx> {\n+pub fn check_pat_struct(&self, pat: &'gcx hir::Pat,\n+                        path: &hir::Path, fields: &'gcx [Spanned<hir::FieldPat>],\n                         etc: bool, expected: Ty<'tcx>) {\n     let tcx = self.tcx;\n \n@@ -617,7 +614,7 @@ pub fn check_pat_struct(&self, pat: &'tcx hir::Pat,\n fn check_pat_enum(&self,\n                   pat: &hir::Pat,\n                   path: &hir::Path,\n-                  subpats: Option<&'tcx [P<hir::Pat>]>,\n+                  subpats: Option<&'gcx [P<hir::Pat>]>,\n                   expected: Ty<'tcx>,\n                   is_tuple_struct_pat: bool)\n {\n@@ -764,7 +761,7 @@ fn check_pat_enum(&self,\n /// `etc` is true if the pattern said '...' and false otherwise.\n pub fn check_struct_pat_fields(&self,\n                                span: Span,\n-                               fields: &'tcx [Spanned<hir::FieldPat>],\n+                               fields: &'gcx [Spanned<hir::FieldPat>],\n                                variant: ty::VariantDef<'tcx>,\n                                substs: &Substs<'tcx>,\n                                etc: bool) {"}, {"sha": "04b0248ccdac25ac2b4e8efce1b8dc0e0fda3b62", "filename": "src/librustc_typeck/check/assoc.rs", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/31a07b0ce662e95119a76cce8dcfc29d2055f738/src%2Flibrustc_typeck%2Fcheck%2Fassoc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31a07b0ce662e95119a76cce8dcfc29d2055f738/src%2Flibrustc_typeck%2Fcheck%2Fassoc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fassoc.rs?ref=31a07b0ce662e95119a76cce8dcfc29d2055f738", "patch": "@@ -16,12 +16,13 @@ use syntax::ast;\n use syntax::codemap::Span;\n \n //FIXME(@jroesch): Ideally we should be able to drop the fulfillment_cx argument.\n-pub fn normalize_associated_types_in<'a,'tcx,T>(infcx: &InferCtxt<'a,'tcx, 'tcx>,\n-                                                fulfillment_cx: &mut FulfillmentContext<'tcx>,\n-                                                span: Span,\n-                                                body_id: ast::NodeId,\n-                                                value: &T)\n-                                                -> T\n+pub fn normalize_associated_types_in<'a, 'gcx, 'tcx, T>(\n+    infcx: &InferCtxt<'a, 'gcx, 'tcx>,\n+    fulfillment_cx: &mut FulfillmentContext<'tcx>,\n+    span: Span,\n+    body_id: ast::NodeId,\n+    value: &T) -> T\n+\n     where T : TypeFoldable<'tcx>\n {\n     debug!(\"normalize_associated_types_in(value={:?})\", value);"}, {"sha": "9de78168fe792c9a777c02181a9852747a5cf1be", "filename": "src/librustc_typeck/check/callee.rs", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/31a07b0ce662e95119a76cce8dcfc29d2055f738/src%2Flibrustc_typeck%2Fcheck%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31a07b0ce662e95119a76cce8dcfc29d2055f738/src%2Flibrustc_typeck%2Fcheck%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcallee.rs?ref=31a07b0ce662e95119a76cce8dcfc29d2055f738", "patch": "@@ -63,11 +63,11 @@ enum CallStep<'tcx> {\n     Overloaded(ty::MethodCallee<'tcx>)\n }\n \n-impl<'a, 'tcx> FnCtxt<'a, 'tcx, 'tcx> {\n+impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n pub fn check_call(&self,\n-                  call_expr: &'tcx hir::Expr,\n-                  callee_expr: &'tcx hir::Expr,\n-                  arg_exprs: &'tcx [P<hir::Expr>],\n+                  call_expr: &'gcx hir::Expr,\n+                  callee_expr: &'gcx hir::Expr,\n+                  arg_exprs: &'gcx [P<hir::Expr>],\n                   expected: Expectation<'tcx>)\n {\n     self.check_expr(callee_expr);\n@@ -104,8 +104,8 @@ pub fn check_call(&self,\n }\n \n fn try_overloaded_call_step(&self,\n-                            call_expr: &'tcx hir::Expr,\n-                            callee_expr: &'tcx hir::Expr,\n+                            call_expr: &'gcx hir::Expr,\n+                            callee_expr: &'gcx hir::Expr,\n                             adjusted_ty: Ty<'tcx>,\n                             autoderefs: usize)\n                             -> Option<CallStep<'tcx>>\n@@ -205,7 +205,7 @@ fn try_overloaded_call_traits(&self,\n fn confirm_builtin_call(&self,\n                         call_expr: &hir::Expr,\n                         callee_ty: Ty<'tcx>,\n-                        arg_exprs: &'tcx [P<hir::Expr>],\n+                        arg_exprs: &'gcx [P<hir::Expr>],\n                         expected: Expectation<'tcx>)\n {\n     let error_fn_sig;\n@@ -275,7 +275,7 @@ fn confirm_builtin_call(&self,\n \n fn confirm_deferred_closure_call(&self,\n                                  call_expr: &hir::Expr,\n-                                 arg_exprs: &'tcx [P<hir::Expr>],\n+                                 arg_exprs: &'gcx [P<hir::Expr>],\n                                  expected: Expectation<'tcx>,\n                                  fn_sig: ty::FnSig<'tcx>)\n {\n@@ -302,8 +302,8 @@ fn confirm_deferred_closure_call(&self,\n \n fn confirm_overloaded_call(&self,\n                            call_expr: &hir::Expr,\n-                           callee_expr: &'tcx hir::Expr,\n-                           arg_exprs: &'tcx [P<hir::Expr>],\n+                           callee_expr: &'gcx hir::Expr,\n+                           arg_exprs: &'gcx [P<hir::Expr>],\n                            expected: Expectation<'tcx>,\n                            method_callee: ty::MethodCallee<'tcx>)\n {\n@@ -328,17 +328,17 @@ fn write_overloaded_call_method_map(&self,\n }\n \n #[derive(Debug)]\n-struct CallResolution<'tcx> {\n-    call_expr: &'tcx hir::Expr,\n-    callee_expr: &'tcx hir::Expr,\n+struct CallResolution<'gcx: 'tcx, 'tcx> {\n+    call_expr: &'gcx hir::Expr,\n+    callee_expr: &'gcx hir::Expr,\n     adjusted_ty: Ty<'tcx>,\n     autoderefs: usize,\n     fn_sig: ty::FnSig<'tcx>,\n     closure_def_id: DefId,\n }\n \n-impl<'tcx> DeferredCallResolution<'tcx> for CallResolution<'tcx> {\n-    fn resolve<'a>(&mut self, fcx: &FnCtxt<'a,'tcx, 'tcx>) {\n+impl<'gcx, 'tcx> DeferredCallResolution<'gcx, 'tcx> for CallResolution<'gcx, 'tcx> {\n+    fn resolve<'a>(&mut self, fcx: &FnCtxt<'a, 'gcx, 'tcx>) {\n         debug!(\"DeferredCallResolution::resolve() {:?}\",\n                self);\n \n@@ -348,7 +348,7 @@ impl<'tcx> DeferredCallResolution<'tcx> for CallResolution<'tcx> {\n \n         // We may now know enough to figure out fn vs fnmut etc.\n         match fcx.try_overloaded_call_traits(self.call_expr, self.callee_expr,\n-                                         self.adjusted_ty, self.autoderefs) {\n+                                             self.adjusted_ty, self.autoderefs) {\n             Some(method_callee) => {\n                 // One problem is that when we get here, we are going\n                 // to have a newly instantiated function signature"}, {"sha": "bdf26eab20f5316976966ce413601fef9492ca4b", "filename": "src/librustc_typeck/check/cast.rs", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/31a07b0ce662e95119a76cce8dcfc29d2055f738/src%2Flibrustc_typeck%2Fcheck%2Fcast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31a07b0ce662e95119a76cce8dcfc29d2055f738/src%2Flibrustc_typeck%2Fcheck%2Fcast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcast.rs?ref=31a07b0ce662e95119a76cce8dcfc29d2055f738", "patch": "@@ -72,7 +72,7 @@ enum UnsizeKind<'tcx> {\n     OfParam(&'tcx ty::ParamTy)\n }\n \n-impl<'a, 'tcx> FnCtxt<'a, 'tcx, 'tcx> {\n+impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n /// Returns the kind of unsize information of t, or None\n /// if t is sized or it is unknown.\n fn unsize_kind(&self, t: Ty<'tcx>) -> Option<UnsizeKind<'tcx>> {\n@@ -109,8 +109,8 @@ enum CastError {\n     NonScalar,\n }\n \n-impl<'a, 'tcx> CastCheck<'tcx> {\n-    pub fn new(fcx: &FnCtxt<'a, 'tcx, 'tcx>,\n+impl<'a, 'gcx, 'tcx> CastCheck<'tcx> {\n+    pub fn new(fcx: &FnCtxt<'a, 'gcx, 'tcx>,\n                expr: &'tcx hir::Expr,\n                expr_ty: Ty<'tcx>,\n                cast_ty: Ty<'tcx>,\n@@ -139,7 +139,7 @@ impl<'a, 'tcx> CastCheck<'tcx> {\n         }\n     }\n \n-    fn report_cast_error(&self, fcx: &FnCtxt<'a, 'tcx, 'tcx>, e: CastError) {\n+    fn report_cast_error(&self, fcx: &FnCtxt<'a, 'gcx, 'tcx>, e: CastError) {\n         match e {\n             CastError::NeedViaPtr |\n             CastError::NeedViaThinPtr |\n@@ -202,7 +202,7 @@ impl<'a, 'tcx> CastCheck<'tcx> {\n         }\n     }\n \n-    fn report_cast_to_unsized_type(&self, fcx: &FnCtxt<'a, 'tcx, 'tcx>) {\n+    fn report_cast_to_unsized_type(&self, fcx: &FnCtxt<'a, 'gcx, 'tcx>) {\n         if\n             self.cast_ty.references_error() ||\n             self.expr_ty.references_error()\n@@ -256,7 +256,7 @@ impl<'a, 'tcx> CastCheck<'tcx> {\n         err.emit();\n     }\n \n-    fn trivial_cast_lint(&self, fcx: &FnCtxt<'a, 'tcx, 'tcx>) {\n+    fn trivial_cast_lint(&self, fcx: &FnCtxt<'a, 'gcx, 'tcx>) {\n         let t_cast = self.cast_ty;\n         let t_expr = self.expr_ty;\n         if t_cast.is_numeric() && t_expr.is_numeric() {\n@@ -281,7 +281,7 @@ impl<'a, 'tcx> CastCheck<'tcx> {\n \n     }\n \n-    pub fn check(mut self, fcx: &FnCtxt<'a, 'tcx, 'tcx>) {\n+    pub fn check(mut self, fcx: &FnCtxt<'a, 'gcx, 'tcx>) {\n         self.expr_ty = fcx.structurally_resolved_type(self.span, self.expr_ty);\n         self.cast_ty = fcx.structurally_resolved_type(self.span, self.cast_ty);\n \n@@ -309,7 +309,7 @@ impl<'a, 'tcx> CastCheck<'tcx> {\n     /// Check a cast, and report an error if one exists. In some cases, this\n     /// can return Ok and create type errors in the fcx rather than returning\n     /// directly. coercion-cast is handled in check instead of here.\n-    fn do_check(&self, fcx: &FnCtxt<'a, 'tcx, 'tcx>) -> Result<CastKind, CastError> {\n+    fn do_check(&self, fcx: &FnCtxt<'a, 'gcx, 'tcx>) -> Result<CastKind, CastError> {\n         use rustc::ty::cast::IntTy::*;\n         use rustc::ty::cast::CastTy::*;\n \n@@ -376,7 +376,7 @@ impl<'a, 'tcx> CastCheck<'tcx> {\n     }\n \n     fn check_ptr_ptr_cast(&self,\n-                          fcx: &FnCtxt<'a, 'tcx, 'tcx>,\n+                          fcx: &FnCtxt<'a, 'gcx, 'tcx>,\n                           m_expr: &'tcx ty::TypeAndMut<'tcx>,\n                           m_cast: &'tcx ty::TypeAndMut<'tcx>)\n                           -> Result<CastKind, CastError>\n@@ -403,7 +403,7 @@ impl<'a, 'tcx> CastCheck<'tcx> {\n     }\n \n     fn check_fptr_ptr_cast(&self,\n-                           fcx: &FnCtxt<'a, 'tcx, 'tcx>,\n+                           fcx: &FnCtxt<'a, 'gcx, 'tcx>,\n                            m_cast: &'tcx ty::TypeAndMut<'tcx>)\n                            -> Result<CastKind, CastError>\n     {\n@@ -417,7 +417,7 @@ impl<'a, 'tcx> CastCheck<'tcx> {\n     }\n \n     fn check_ptr_addr_cast(&self,\n-                           fcx: &FnCtxt<'a, 'tcx, 'tcx>,\n+                           fcx: &FnCtxt<'a, 'gcx, 'tcx>,\n                            m_expr: &'tcx ty::TypeAndMut<'tcx>)\n                            -> Result<CastKind, CastError>\n     {\n@@ -431,7 +431,7 @@ impl<'a, 'tcx> CastCheck<'tcx> {\n     }\n \n     fn check_ref_cast(&self,\n-                      fcx: &FnCtxt<'a, 'tcx, 'tcx>,\n+                      fcx: &FnCtxt<'a, 'gcx, 'tcx>,\n                       m_expr: &'tcx ty::TypeAndMut<'tcx>,\n                       m_cast: &'tcx ty::TypeAndMut<'tcx>)\n                       -> Result<CastKind, CastError>\n@@ -457,7 +457,7 @@ impl<'a, 'tcx> CastCheck<'tcx> {\n     }\n \n     fn check_addr_ptr_cast(&self,\n-                           fcx: &FnCtxt<'a, 'tcx, 'tcx>,\n+                           fcx: &FnCtxt<'a, 'gcx, 'tcx>,\n                            m_cast: &'tcx ty::TypeAndMut<'tcx>)\n                            -> Result<CastKind, CastError>\n     {\n@@ -469,13 +469,13 @@ impl<'a, 'tcx> CastCheck<'tcx> {\n         }\n     }\n \n-    fn try_coercion_cast(&self, fcx: &FnCtxt<'a, 'tcx, 'tcx>) -> bool {\n+    fn try_coercion_cast(&self, fcx: &FnCtxt<'a, 'gcx, 'tcx>) -> bool {\n         fcx.try_coerce(self.expr, self.cast_ty).is_ok()\n     }\n \n }\n \n-impl<'a, 'tcx> FnCtxt<'a, 'tcx, 'tcx> {\n+impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n     fn type_is_known_to_be_sized(&self,\n                                  ty: Ty<'tcx>,\n                                  span: Span)"}, {"sha": "43c1f9d367e464fa5c47b7eff4fa867997705ef4", "filename": "src/librustc_typeck/check/closure.rs", "status": "modified", "additions": 9, "deletions": 16, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/31a07b0ce662e95119a76cce8dcfc29d2055f738/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31a07b0ce662e95119a76cce8dcfc29d2055f738/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs?ref=31a07b0ce662e95119a76cce8dcfc29d2055f738", "patch": "@@ -12,19 +12,19 @@\n \n use super::{check_fn, Expectation, FnCtxt};\n \n-use astconv;\n+use astconv::AstConv;\n use rustc::ty::subst;\n use rustc::ty::{self, ToPolyTraitRef, Ty};\n use std::cmp;\n use syntax::abi::Abi;\n use rustc::hir;\n \n-impl<'a, 'tcx> FnCtxt<'a, 'tcx, 'tcx> {\n+impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n pub fn check_expr_closure(&self,\n                           expr: &hir::Expr,\n                           _capture: hir::CaptureClause,\n-                          decl: &'tcx hir::FnDecl,\n-                          body: &'tcx hir::Block,\n+                          decl: &'gcx hir::FnDecl,\n+                          body: &'gcx hir::Block,\n                           expected: Expectation<'tcx>) {\n     debug!(\"check_expr_closure(expr={:?},expected={:?})\",\n            expr,\n@@ -43,16 +43,16 @@ pub fn check_expr_closure(&self,\n fn check_closure(&self,\n                  expr: &hir::Expr,\n                  opt_kind: Option<ty::ClosureKind>,\n-                 decl: &'tcx hir::FnDecl,\n-                 body: &'tcx hir::Block,\n+                 decl: &'gcx hir::FnDecl,\n+                 body: &'gcx hir::Block,\n                  expected_sig: Option<ty::FnSig<'tcx>>) {\n     let expr_def_id = self.tcx.map.local_def_id(expr.id);\n \n     debug!(\"check_closure opt_kind={:?} expected_sig={:?}\",\n            opt_kind,\n            expected_sig);\n \n-    let mut fn_ty = astconv::ty_of_closure(self,\n+    let mut fn_ty = AstConv::ty_of_closure(self,\n                                            hir::Unsafety::Normal,\n                                            decl,\n                                            Abi::RustCall,\n@@ -68,22 +68,15 @@ fn check_closure(&self,\n            expr.id, upvar_tys);\n \n     let closure_type = self.tcx.mk_closure(expr_def_id,\n-        self.tcx.mk_substs(self.parameter_environment.free_substs.clone()),\n+        self.parameter_environment.free_substs,\n         upvar_tys);\n \n     self.write_ty(expr.id, closure_type);\n \n     let fn_sig = self.tcx.liberate_late_bound_regions(\n         self.tcx.region_maps.call_site_extent(expr.id, body.id), &fn_ty.sig);\n \n-    check_fn(self.ccx,\n-             hir::Unsafety::Normal,\n-             expr.id,\n-             &fn_sig,\n-             decl,\n-             expr.id,\n-             &body,\n-             self);\n+    check_fn(self, hir::Unsafety::Normal, expr.id, &fn_sig, decl, expr.id, &body);\n \n     // Tuple up the arguments and insert the resulting function type into\n     // the `closures` table."}, {"sha": "55786a03eeb5436e009d4b1a9a30b38327c6f1d4", "filename": "src/librustc_typeck/check/coercion.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/31a07b0ce662e95119a76cce8dcfc29d2055f738/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31a07b0ce662e95119a76cce8dcfc29d2055f738/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs?ref=31a07b0ce662e95119a76cce8dcfc29d2055f738", "patch": "@@ -105,8 +105,8 @@ fn coerce_mutbls<'tcx>(from_mutbl: hir::Mutability,\n     }\n }\n \n-impl<'f, 'tcx> Coerce<'f, 'tcx, 'tcx> {\n-    fn new(fcx: &'f FnCtxt<'f, 'tcx, 'tcx>, origin: TypeOrigin) -> Self {\n+impl<'f, 'gcx, 'tcx> Coerce<'f, 'gcx, 'tcx> {\n+    fn new(fcx: &'f FnCtxt<'f, 'gcx, 'tcx>, origin: TypeOrigin) -> Self {\n         Coerce {\n             fcx: fcx,\n             origin: origin,\n@@ -594,11 +594,11 @@ impl<'f, 'tcx> Coerce<'f, 'tcx, 'tcx> {\n     }\n }\n \n-fn apply<'a, 'b, 'tcx, E, I>(coerce: &mut Coerce<'a, 'tcx, 'tcx>,\n-                             exprs: &E,\n-                             a: Ty<'tcx>,\n-                             b: Ty<'tcx>)\n-                             -> CoerceResult<'tcx>\n+fn apply<'a, 'b, 'gcx, 'tcx, E, I>(coerce: &mut Coerce<'a, 'gcx, 'tcx>,\n+                                   exprs: &E,\n+                                   a: Ty<'tcx>,\n+                                   b: Ty<'tcx>)\n+                                   -> CoerceResult<'tcx>\n     where E: Fn() -> I,\n           I: IntoIterator<Item=&'b hir::Expr> {\n \n@@ -617,7 +617,7 @@ fn apply<'a, 'b, 'tcx, E, I>(coerce: &mut Coerce<'a, 'tcx, 'tcx>,\n     Ok((ty, adjustment))\n }\n \n-impl<'a, 'tcx> FnCtxt<'a, 'tcx, 'tcx> {\n+impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n /// Attempt to coerce an expression to a type, and return the\n /// adjusted type of the expression, if successful.\n /// Adjustments are only recorded if the coercion succeeded."}, {"sha": "065425c86c7e45b6d1797e38578cbb8fba2127d7", "filename": "src/librustc_typeck/check/demand.rs", "status": "modified", "additions": 13, "deletions": 1, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/31a07b0ce662e95119a76cce8dcfc29d2055f738/src%2Flibrustc_typeck%2Fcheck%2Fdemand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31a07b0ce662e95119a76cce8dcfc29d2055f738/src%2Flibrustc_typeck%2Fcheck%2Fdemand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fdemand.rs?ref=31a07b0ce662e95119a76cce8dcfc29d2055f738", "patch": "@@ -16,7 +16,7 @@ use rustc::infer::{InferOk, TypeOrigin};\n use syntax::codemap::Span;\n use rustc::hir;\n \n-impl<'a, 'tcx> FnCtxt<'a, 'tcx, 'tcx> {\n+impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n // Requires that the two types unify, and prints an error message if\n // they don't.\n pub fn demand_suptype(&self, sp: Span, expected: Ty<'tcx>, actual: Ty<'tcx>) {\n@@ -54,4 +54,16 @@ pub fn demand_coerce(&self, expr: &hir::Expr, expected: Ty<'tcx>) {\n         self.report_mismatched_types(origin, expected, expr_ty, e);\n     }\n }\n+\n+pub fn require_same_types(&self, span: Span, t1: Ty<'tcx>, t2: Ty<'tcx>, msg: &str)\n+                          -> bool {\n+    if let Err(err) = self.eq_types(false, TypeOrigin::Misc(span), t1, t2) {\n+        let found_ty = self.resolve_type_vars_if_possible(&t1);\n+        let expected_ty = self.resolve_type_vars_if_possible(&t2);\n+        ::emit_type_err(self.tcx, span, found_ty, expected_ty, &err, msg);\n+        false\n+    } else {\n+        true\n+    }\n+}\n }"}, {"sha": "862dae4bb33e61f4f43372188cf2711aec2c786b", "filename": "src/librustc_typeck/check/dropck.rs", "status": "modified", "additions": 13, "deletions": 11, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/31a07b0ce662e95119a76cce8dcfc29d2055f738/src%2Flibrustc_typeck%2Fcheck%2Fdropck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31a07b0ce662e95119a76cce8dcfc29d2055f738/src%2Flibrustc_typeck%2Fcheck%2Fdropck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fdropck.rs?ref=31a07b0ce662e95119a76cce8dcfc29d2055f738", "patch": "@@ -16,7 +16,7 @@ use middle::free_region::FreeRegionMap;\n use rustc::infer::{self, InferCtxt};\n use middle::region;\n use rustc::ty::subst::{self, Subst};\n-use rustc::ty::{self, Ty};\n+use rustc::ty::{self, Ty, TyCtxt};\n use rustc::traits::{self, ProjectionMode};\n use util::nodemap::FnvHashSet;\n \n@@ -274,10 +274,12 @@ fn ensure_drop_predicates_are_implied_by_item_defn<'a, 'tcx>(\n /// ensuring that they do not access data nor invoke methods of\n /// values that have been previously dropped).\n ///\n-pub fn check_safety_of_destructor_if_necessary<'a, 'tcx>(rcx: &mut RegionCtxt<'a, 'tcx, 'tcx>,\n-                                                         typ: ty::Ty<'tcx>,\n-                                                         span: Span,\n-                                                         scope: region::CodeExtent) {\n+pub fn check_safety_of_destructor_if_necessary<'a, 'gcx, 'tcx>(\n+    rcx: &mut RegionCtxt<'a, 'gcx, 'tcx>,\n+    typ: ty::Ty<'tcx>,\n+    span: Span,\n+    scope: region::CodeExtent)\n+{\n     debug!(\"check_safety_of_destructor_if_necessary typ: {:?} scope: {:?}\",\n            typ, scope);\n \n@@ -354,8 +356,8 @@ struct DropckContext<'a, 'b: 'a, 'gcx: 'b+'tcx, 'tcx: 'b> {\n }\n \n // `context` is used for reporting overflow errors\n-fn iterate_over_potentially_unsafe_regions_in_type<'a, 'b, 'tcx>(\n-    cx: &mut DropckContext<'a, 'b, 'tcx, 'tcx>,\n+fn iterate_over_potentially_unsafe_regions_in_type<'a, 'b, 'gcx, 'tcx>(\n+    cx: &mut DropckContext<'a, 'b, 'gcx, 'tcx>,\n     context: TypeContext,\n     ty: Ty<'tcx>,\n     depth: usize) -> Result<(), Error<'tcx>>\n@@ -410,7 +412,7 @@ fn iterate_over_potentially_unsafe_regions_in_type<'a, 'b, 'tcx>(\n     // unbounded type parameter `T`, we must resume the recursive\n     // analysis on `T` (since it would be ignored by\n     // type_must_outlive).\n-    if has_dtor_of_interest(cx, ty) {\n+    if has_dtor_of_interest(tcx, ty) {\n         debug!(\"iterate_over_potentially_unsafe_regions_in_type \\\n                 {}ty: {} - is a dtorck type!\",\n                (0..depth).map(|_| ' ').collect::<String>(),\n@@ -500,11 +502,11 @@ fn iterate_over_potentially_unsafe_regions_in_type<'a, 'b, 'tcx>(\n     }\n }\n \n-fn has_dtor_of_interest<'a, 'b, 'tcx>(cx: &DropckContext<'a, 'b, 'tcx, 'tcx>,\n-                                      ty: ty::Ty<'tcx>) -> bool {\n+fn has_dtor_of_interest<'a, 'gcx, 'tcx>(tcx: TyCtxt<'a, 'gcx, 'tcx>,\n+                                        ty: Ty<'tcx>) -> bool {\n     match ty.sty {\n         ty::TyEnum(def, _) | ty::TyStruct(def, _) => {\n-            def.is_dtorck(cx.rcx.tcx)\n+            def.is_dtorck(tcx)\n         }\n         ty::TyTrait(..) | ty::TyProjection(..) => {\n             debug!(\"ty: {:?} isn't known, and therefore is a dropck type\", ty);"}, {"sha": "c02139140aed5fa1079be3b692563fa44d134fdb", "filename": "src/librustc_typeck/check/intrinsic.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/31a07b0ce662e95119a76cce8dcfc29d2055f738/src%2Flibrustc_typeck%2Fcheck%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31a07b0ce662e95119a76cce8dcfc29d2055f738/src%2Flibrustc_typeck%2Fcheck%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fintrinsic.rs?ref=31a07b0ce662e95119a76cce8dcfc29d2055f738", "patch": "@@ -56,7 +56,6 @@ fn equate_intrinsic_type<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n              i_n_tps, n_tps);\n     } else {\n         require_same_types(ccx,\n-                           None,\n                            it.span,\n                            i_ty.ty,\n                            fty,"}, {"sha": "3360f9dab78466cdf96da372c89a5b581c9b8e83", "filename": "src/librustc_typeck/check/method/confirm.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/31a07b0ce662e95119a76cce8dcfc29d2055f738/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31a07b0ce662e95119a76cce8dcfc29d2055f738/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs?ref=31a07b0ce662e95119a76cce8dcfc29d2055f738", "patch": "@@ -52,11 +52,11 @@ struct InstantiatedMethodSig<'tcx> {\n     method_predicates: ty::InstantiatedPredicates<'tcx>,\n }\n \n-impl<'a, 'tcx> FnCtxt<'a, 'tcx, 'tcx> {\n+impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n pub fn confirm_method(&self,\n                       span: Span,\n-                      self_expr: &'tcx hir::Expr,\n-                      call_expr: &'tcx hir::Expr,\n+                      self_expr: &'gcx hir::Expr,\n+                      call_expr: &'gcx hir::Expr,\n                       unadjusted_self_ty: Ty<'tcx>,\n                       pick: probe::Pick<'tcx>,\n                       supplied_method_types: Vec<Ty<'tcx>>)\n@@ -72,12 +72,12 @@ pub fn confirm_method(&self,\n }\n }\n \n-impl<'a,'tcx> ConfirmContext<'a,'tcx, 'tcx> {\n-    fn new(fcx: &'a FnCtxt<'a, 'tcx, 'tcx>,\n+impl<'a, 'gcx, 'tcx> ConfirmContext<'a, 'gcx, 'tcx> {\n+    fn new(fcx: &'a FnCtxt<'a, 'gcx, 'tcx>,\n            span: Span,\n-           self_expr: &'tcx hir::Expr,\n-           call_expr: &'tcx hir::Expr)\n-           -> ConfirmContext<'a, 'tcx, 'tcx>\n+           self_expr: &'gcx hir::Expr,\n+           call_expr: &'gcx hir::Expr)\n+           -> ConfirmContext<'a, 'gcx, 'tcx>\n     {\n         ConfirmContext { fcx: fcx, span: span, self_expr: self_expr, call_expr: call_expr }\n     }\n@@ -286,7 +286,7 @@ impl<'a,'tcx> ConfirmContext<'a,'tcx, 'tcx> {\n     }\n \n     fn extract_trait_ref<R, F>(&mut self, self_ty: Ty<'tcx>, mut closure: F) -> R where\n-        F: FnMut(&mut ConfirmContext<'a, 'tcx, 'tcx>, Ty<'tcx>, &ty::TraitTy<'tcx>) -> R,\n+        F: FnMut(&mut ConfirmContext<'a, 'gcx, 'tcx>, Ty<'tcx>, &ty::TraitTy<'tcx>) -> R,\n     {\n         // If we specified that this is an object method, then the\n         // self-type ought to be something that can be dereferenced to"}, {"sha": "f30abbaba0e9bf4190b61d05a7bd10bc47dbf0f1", "filename": "src/librustc_typeck/check/method/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/31a07b0ce662e95119a76cce8dcfc29d2055f738/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31a07b0ce662e95119a76cce8dcfc29d2055f738/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs?ref=31a07b0ce662e95119a76cce8dcfc29d2055f738", "patch": "@@ -78,7 +78,7 @@ pub enum CandidateSource {\n     TraitSource(/* trait id */ DefId),\n }\n \n-impl<'a, 'tcx> FnCtxt<'a, 'tcx, 'tcx> {\n+impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n /// Determines whether the type `self_ty` supports a method name `method_name` or not.\n pub fn method_exists(&self,\n                      span: Span,\n@@ -116,8 +116,8 @@ pub fn lookup_method(&self,\n                      method_name: ast::Name,\n                      self_ty: ty::Ty<'tcx>,\n                      supplied_method_types: Vec<ty::Ty<'tcx>>,\n-                     call_expr: &'tcx hir::Expr,\n-                     self_expr: &'tcx hir::Expr)\n+                     call_expr: &'gcx hir::Expr,\n+                     self_expr: &'gcx hir::Expr)\n                      -> Result<ty::MethodCallee<'tcx>, MethodError<'tcx>>\n {\n     debug!(\"lookup(method_name={}, self_ty={:?}, call_expr={:?}, self_expr={:?})\","}, {"sha": "8ce92892e9a4c0f5553d9c12cd0d3e1f75a876b5", "filename": "src/librustc_typeck/check/method/probe.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/31a07b0ce662e95119a76cce8dcfc29d2055f738/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31a07b0ce662e95119a76cce8dcfc29d2055f738/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs?ref=31a07b0ce662e95119a76cce8dcfc29d2055f738", "patch": "@@ -136,7 +136,7 @@ pub enum Mode {\n     Path\n }\n \n-impl<'a, 'tcx> FnCtxt<'a, 'tcx, 'tcx> {\n+impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n pub fn probe_method(&self,\n                     span: Span,\n                     mode: Mode,\n@@ -241,14 +241,14 @@ fn create_steps(&self,\n }\n }\n \n-impl<'a,'tcx> ProbeContext<'a,'tcx, 'tcx> {\n-    fn new(fcx: &'a FnCtxt<'a,'tcx, 'tcx>,\n+impl<'a, 'gcx, 'tcx> ProbeContext<'a, 'gcx, 'tcx> {\n+    fn new(fcx: &'a FnCtxt<'a, 'gcx, 'tcx>,\n            span: Span,\n            mode: Mode,\n            item_name: ast::Name,\n            steps: Vec<CandidateStep<'tcx>>,\n            opt_simplified_steps: Option<Vec<ty::fast_reject::SimplifiedType>>)\n-           -> ProbeContext<'a,'tcx, 'tcx>\n+           -> ProbeContext<'a, 'gcx, 'tcx>\n     {\n         ProbeContext {\n             fcx: fcx,\n@@ -554,7 +554,7 @@ impl<'a,'tcx> ProbeContext<'a,'tcx, 'tcx> {\n         mut mk_cand: F,\n     ) where\n         F: for<'b> FnMut(\n-            &mut ProbeContext<'b, 'tcx, 'tcx>,\n+            &mut ProbeContext<'b, 'gcx, 'tcx>,\n             ty::PolyTraitRef<'tcx>,\n             ty::ImplOrTraitItem<'tcx>,\n         ),"}, {"sha": "ed60f9b6e7c178af3fa0c56ae30199e335eaec22", "filename": "src/librustc_typeck/check/method/suggest.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/31a07b0ce662e95119a76cce8dcfc29d2055f738/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31a07b0ce662e95119a76cce8dcfc29d2055f738/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs?ref=31a07b0ce662e95119a76cce8dcfc29d2055f738", "patch": "@@ -39,7 +39,7 @@ use std::cmp::Ordering;\n use super::{MethodError, NoMatchData, CandidateSource};\n use super::probe::Mode;\n \n-impl<'a, 'tcx> FnCtxt<'a, 'tcx, 'tcx> {\n+impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n fn is_fn_ty(&self, ty: &Ty<'tcx>, span: Span) -> bool {\n     let tcx = self.tcx;\n     match ty.sty {"}, {"sha": "9e771d95bbd0434bebc49a9f58d6b89e47b927ec", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 79, "deletions": 81, "changes": 160, "blob_url": "https://github.com/rust-lang/rust/blob/31a07b0ce662e95119a76cce8dcfc29d2055f738/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31a07b0ce662e95119a76cce8dcfc29d2055f738/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=31a07b0ce662e95119a76cce8dcfc29d2055f738", "patch": "@@ -80,7 +80,7 @@ pub use self::Expectation::*;\n pub use self::compare_method::{compare_impl_method, compare_const_impl};\n use self::TupleArgumentsFlag::*;\n \n-use astconv::{self, ast_region_to_region, ast_ty_to_ty, AstConv, PathParamMode};\n+use astconv::{AstConv, ast_region_to_region, PathParamMode};\n use check::_match::PatCtxt;\n use dep_graph::DepNode;\n use fmt_macros::{Parser, Piece, Position};\n@@ -168,7 +168,7 @@ pub struct Inherited<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n     // decision. We keep these deferred resolutions grouped by the\n     // def-id of the closure, so that once we decide, we can easily go\n     // back and process them.\n-    deferred_call_resolutions: RefCell<DefIdMap<Vec<DeferredCallResolutionHandler<'tcx>>>>,\n+    deferred_call_resolutions: RefCell<DefIdMap<Vec<DeferredCallResolutionHandler<'gcx, 'tcx>>>>,\n \n     deferred_cast_checks: RefCell<Vec<cast::CastCheck<'tcx>>>,\n }\n@@ -180,11 +180,11 @@ impl<'a, 'gcx, 'tcx> Deref for Inherited<'a, 'gcx, 'tcx> {\n     }\n }\n \n-trait DeferredCallResolution<'tcx> {\n-    fn resolve<'a>(&mut self, fcx: &FnCtxt<'a,'tcx, 'tcx>);\n+trait DeferredCallResolution<'gcx, 'tcx> {\n+    fn resolve<'a>(&mut self, fcx: &FnCtxt<'a, 'gcx, 'tcx>);\n }\n \n-type DeferredCallResolutionHandler<'tcx> = Box<DeferredCallResolution<'tcx>+'tcx>;\n+type DeferredCallResolutionHandler<'gcx, 'tcx> = Box<DeferredCallResolution<'gcx, 'tcx>+'tcx>;\n \n /// When type-checking an expression, we propagate downward\n /// whatever type hint we are able in the form of an `Expectation`.\n@@ -204,7 +204,7 @@ pub enum Expectation<'tcx> {\n     ExpectRvalueLikeUnsized(Ty<'tcx>),\n }\n \n-impl<'a, 'tcx> Expectation<'tcx> {\n+impl<'a, 'gcx, 'tcx> Expectation<'tcx> {\n     // Disregard \"castable to\" expectations because they\n     // can lead us astray. Consider for example `if cond\n     // {22} else {c} as u8` -- if we propagate the\n@@ -221,7 +221,7 @@ impl<'a, 'tcx> Expectation<'tcx> {\n     // an expected type. Otherwise, we might write parts of the type\n     // when checking the 'then' block which are incompatible with the\n     // 'else' branch.\n-    fn adjust_for_branches(&self, fcx: &FnCtxt<'a, 'tcx, 'tcx>) -> Expectation<'tcx> {\n+    fn adjust_for_branches(&self, fcx: &FnCtxt<'a, 'gcx, 'tcx>) -> Expectation<'tcx> {\n         match *self {\n             ExpectHasType(ety) => {\n                 let ety = fcx.shallow_resolve(ety);\n@@ -257,7 +257,7 @@ impl<'a, 'tcx> Expectation<'tcx> {\n     /// which still is useful, because it informs integer literals and the like.\n     /// See the test case `test/run-pass/coerce-expect-unsized.rs` and #20169\n     /// for examples of where this comes up,.\n-    fn rvalue_hint(fcx: &FnCtxt<'a, 'tcx, 'tcx>, ty: Ty<'tcx>) -> Expectation<'tcx> {\n+    fn rvalue_hint(fcx: &FnCtxt<'a, 'gcx, 'tcx>, ty: Ty<'tcx>) -> Expectation<'tcx> {\n         match fcx.tcx.struct_tail(ty).sty {\n             ty::TySlice(_) | ty::TyStr | ty::TyTrait(..) => {\n                 ExpectRvalueLikeUnsized(ty)\n@@ -269,7 +269,7 @@ impl<'a, 'tcx> Expectation<'tcx> {\n     // Resolves `expected` by a single level if it is a variable. If\n     // there is no expected type or resolution is not possible (e.g.,\n     // no constraints yet present), just returns `None`.\n-    fn resolve(self, fcx: &FnCtxt<'a, 'tcx, 'tcx>) -> Expectation<'tcx> {\n+    fn resolve(self, fcx: &FnCtxt<'a, 'gcx, 'tcx>) -> Expectation<'tcx> {\n         match self {\n             NoExpectation => {\n                 NoExpectation\n@@ -286,7 +286,7 @@ impl<'a, 'tcx> Expectation<'tcx> {\n         }\n     }\n \n-    fn to_option(self, fcx: &FnCtxt<'a, 'tcx, 'tcx>) -> Option<Ty<'tcx>> {\n+    fn to_option(self, fcx: &FnCtxt<'a, 'gcx, 'tcx>) -> Option<Ty<'tcx>> {\n         match self.resolve(fcx) {\n             NoExpectation => None,\n             ExpectCastableToType(ty) |\n@@ -295,7 +295,7 @@ impl<'a, 'tcx> Expectation<'tcx> {\n         }\n     }\n \n-    fn only_has_type(self, fcx: &FnCtxt<'a, 'tcx, 'tcx>) -> Option<Ty<'tcx>> {\n+    fn only_has_type(self, fcx: &FnCtxt<'a, 'gcx, 'tcx>) -> Option<Ty<'tcx>> {\n         match self.resolve(fcx) {\n             ExpectHasType(ty) => Some(ty),\n             _ => None\n@@ -372,7 +372,7 @@ impl<'a, 'gcx, 'tcx> Deref for FnCtxt<'a, 'gcx, 'tcx> {\n     }\n }\n \n-impl<'a, 'tcx> Inherited<'a, 'tcx, 'tcx> {\n+impl<'a, 'gcx, 'tcx> Inherited<'a, 'gcx, 'tcx> {\n     fn enter<F, R>(ccx: &'a CrateCtxt<'a, 'tcx>,\n                    param_env: ty::ParameterEnvironment<'tcx>,\n                    f: F) -> R\n@@ -493,16 +493,15 @@ fn check_bare_fn<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n \n     Inherited::enter(ccx, param_env, |inh| {\n         // Compute the fty from point of view of inside fn.\n-        let fn_scope = ccx.tcx.region_maps.call_site_extent(fn_id, body.id);\n+        let fn_scope = inh.tcx.region_maps.call_site_extent(fn_id, body.id);\n         let fn_sig =\n-            fn_ty.sig.subst(ccx.tcx, &inh.parameter_environment.free_substs);\n+            fn_ty.sig.subst(inh.tcx, &inh.parameter_environment.free_substs);\n         let fn_sig =\n-            ccx.tcx.liberate_late_bound_regions(fn_scope, &fn_sig);\n+            inh.tcx.liberate_late_bound_regions(fn_scope, &fn_sig);\n         let fn_sig =\n             inh.normalize_associated_types_in(body.span, body.id, &fn_sig);\n \n-        let fcx = check_fn(ccx, fn_ty.unsafety, fn_id, &fn_sig,\n-                           decl, fn_id, body, &inh);\n+        let fcx = check_fn(&inh, fn_ty.unsafety, fn_id, &fn_sig, decl, fn_id, body);\n \n         fcx.select_all_obligations_and_apply_defaults();\n         fcx.closure_analyze_fn(body);\n@@ -519,7 +518,7 @@ struct GatherLocalsVisitor<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n     fcx: &'a FnCtxt<'a, 'gcx, 'tcx>\n }\n \n-impl<'a, 'tcx> GatherLocalsVisitor<'a, 'tcx, 'tcx> {\n+impl<'a, 'gcx, 'tcx> GatherLocalsVisitor<'a, 'gcx, 'tcx> {\n     fn assign(&mut self, _span: Span, nid: ast::NodeId, ty_opt: Option<Ty<'tcx>>) -> Ty<'tcx> {\n         match ty_opt {\n             None => {\n@@ -537,9 +536,9 @@ impl<'a, 'tcx> GatherLocalsVisitor<'a, 'tcx, 'tcx> {\n     }\n }\n \n-impl<'a, 'tcx> Visitor<'tcx> for GatherLocalsVisitor<'a, 'tcx, 'tcx> {\n+impl<'a, 'gcx, 'tcx> Visitor<'gcx> for GatherLocalsVisitor<'a, 'gcx, 'tcx> {\n     // Add explicitly-declared locals.\n-    fn visit_local(&mut self, local: &'tcx hir::Local) {\n+    fn visit_local(&mut self, local: &'gcx hir::Local) {\n         let o_ty = match local.ty {\n             Some(ref ty) => Some(self.fcx.to_ty(&ty)),\n             None => None\n@@ -553,7 +552,7 @@ impl<'a, 'tcx> Visitor<'tcx> for GatherLocalsVisitor<'a, 'tcx, 'tcx> {\n     }\n \n     // Add pattern bindings.\n-    fn visit_pat(&mut self, p: &'tcx hir::Pat) {\n+    fn visit_pat(&mut self, p: &'gcx hir::Pat) {\n         if let PatKind::Ident(_, ref path1, _) = p.node {\n             if pat_util::pat_is_binding(&self.fcx.tcx.def_map.borrow(), p) {\n                 let var_ty = self.assign(p.span, p.id, None);\n@@ -571,7 +570,7 @@ impl<'a, 'tcx> Visitor<'tcx> for GatherLocalsVisitor<'a, 'tcx, 'tcx> {\n         intravisit::walk_pat(self, p);\n     }\n \n-    fn visit_block(&mut self, b: &'tcx hir::Block) {\n+    fn visit_block(&mut self, b: &'gcx hir::Block) {\n         // non-obvious: the `blk` variable maps to region lb, so\n         // we have to keep this up-to-date.  This\n         // is... unfortunate.  It'd be nice to not need this.\n@@ -580,7 +579,7 @@ impl<'a, 'tcx> Visitor<'tcx> for GatherLocalsVisitor<'a, 'tcx, 'tcx> {\n \n     // Since an expr occurs as part of the type fixed size arrays we\n     // need to record the type for that node\n-    fn visit_ty(&mut self, t: &'tcx hir::Ty) {\n+    fn visit_ty(&mut self, t: &'gcx hir::Ty) {\n         match t.node {\n             hir::TyFixedLengthVec(ref ty, ref count_expr) => {\n                 self.visit_ty(&ty);\n@@ -595,8 +594,8 @@ impl<'a, 'tcx> Visitor<'tcx> for GatherLocalsVisitor<'a, 'tcx, 'tcx> {\n     }\n \n     // Don't descend into the bodies of nested closures\n-    fn visit_fn(&mut self, _: intravisit::FnKind<'tcx>, _: &'tcx hir::FnDecl,\n-                _: &'tcx hir::Block, _: Span, _: ast::NodeId) { }\n+    fn visit_fn(&mut self, _: intravisit::FnKind<'gcx>, _: &'gcx hir::FnDecl,\n+                _: &'gcx hir::Block, _: Span, _: ast::NodeId) { }\n }\n \n /// Helper used by check_bare_fn and check_expr_fn. Does the grungy work of checking a function\n@@ -605,17 +604,16 @@ impl<'a, 'tcx> Visitor<'tcx> for GatherLocalsVisitor<'a, 'tcx, 'tcx> {\n ///\n /// * ...\n /// * inherited: other fields inherited from the enclosing fn (if any)\n-fn check_fn<'a, 'tcx>(ccx: &'a CrateCtxt<'a, 'tcx>,\n-                      unsafety: hir::Unsafety,\n-                      unsafety_id: ast::NodeId,\n-                      fn_sig: &ty::FnSig<'tcx>,\n-                      decl: &'tcx hir::FnDecl,\n-                      fn_id: ast::NodeId,\n-                      body: &'tcx hir::Block,\n-                      inherited: &'a Inherited<'a, 'tcx, 'tcx>)\n-                      -> FnCtxt<'a, 'tcx, 'tcx>\n+fn check_fn<'a, 'gcx, 'tcx>(inherited: &'a Inherited<'a, 'gcx, 'tcx>,\n+                            unsafety: hir::Unsafety,\n+                            unsafety_id: ast::NodeId,\n+                            fn_sig: &ty::FnSig<'tcx>,\n+                            decl: &'gcx hir::FnDecl,\n+                            fn_id: ast::NodeId,\n+                            body: &'gcx hir::Block)\n+                            -> FnCtxt<'a, 'gcx, 'tcx>\n {\n-    let tcx = ccx.tcx;\n+    let tcx = inherited.tcx;\n \n     let arg_tys = &fn_sig.inputs;\n     let ret_ty = fn_sig.output;\n@@ -1244,8 +1242,8 @@ pub fn check_enum_variants<'a,'tcx>(ccx: &CrateCtxt<'a,'tcx>,\n     check_representable(ccx.tcx, sp, id, \"enum\");\n }\n \n-impl<'a, 'tcx> AstConv<'tcx, 'tcx> for FnCtxt<'a, 'tcx, 'tcx> {\n-    fn tcx<'b>(&'b self) -> TyCtxt<'b, 'tcx, 'tcx> { self.tcx }\n+impl<'a, 'gcx, 'tcx> AstConv<'gcx, 'tcx> for FnCtxt<'a, 'gcx, 'tcx> {\n+    fn tcx<'b>(&'b self) -> TyCtxt<'b, 'gcx, 'tcx> { self.tcx }\n \n     fn get_item_type_scheme(&self, _: Span, id: DefId)\n                             -> Result<ty::TypeScheme<'tcx>, ErrorReported>\n@@ -1356,7 +1354,7 @@ impl<'a, 'tcx> AstConv<'tcx, 'tcx> for FnCtxt<'a, 'tcx, 'tcx> {\n     }\n }\n \n-impl<'a, 'tcx> RegionScope for FnCtxt<'a, 'tcx, 'tcx> {\n+impl<'a, 'gcx, 'tcx> RegionScope for FnCtxt<'a, 'gcx, 'tcx> {\n     fn object_lifetime_default(&self, span: Span) -> Option<ty::Region> {\n         Some(self.base_object_lifetime_default(span))\n     }\n@@ -1413,11 +1411,11 @@ enum TupleArgumentsFlag {\n     TupleArguments,\n }\n \n-impl<'a, 'tcx> FnCtxt<'a, 'tcx, 'tcx> {\n-    pub fn new(inh: &'a Inherited<'a, 'tcx, 'tcx>,\n+impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n+    pub fn new(inh: &'a Inherited<'a, 'gcx, 'tcx>,\n                rty: ty::FnOutput<'tcx>,\n                body_id: ast::NodeId)\n-               -> FnCtxt<'a, 'tcx, 'tcx> {\n+               -> FnCtxt<'a, 'gcx, 'tcx> {\n         FnCtxt {\n             body_id: body_id,\n             writeback_errors: Cell::new(false),\n@@ -1473,14 +1471,14 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx, 'tcx> {\n \n     fn record_deferred_call_resolution(&self,\n                                        closure_def_id: DefId,\n-                                       r: DeferredCallResolutionHandler<'tcx>) {\n+                                       r: DeferredCallResolutionHandler<'gcx, 'tcx>) {\n         let mut deferred_call_resolutions = self.deferred_call_resolutions.borrow_mut();\n         deferred_call_resolutions.entry(closure_def_id).or_insert(vec![]).push(r);\n     }\n \n     fn remove_deferred_call_resolutions(&self,\n                                         closure_def_id: DefId)\n-                                        -> Vec<DeferredCallResolutionHandler<'tcx>>\n+                                        -> Vec<DeferredCallResolutionHandler<'gcx, 'tcx>>\n     {\n         let mut deferred_call_resolutions = self.deferred_call_resolutions.borrow_mut();\n         deferred_call_resolutions.remove(&closure_def_id).unwrap_or(Vec::new())\n@@ -1619,7 +1617,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx, 'tcx> {\n             self.tcx.lookup_item_type(did);\n         let type_predicates =\n             self.tcx.lookup_predicates(did);\n-        let substs = astconv::ast_path_substs_for_ty(self, self,\n+        let substs = AstConv::ast_path_substs_for_ty(self, self,\n                                                      path.span,\n                                                      PathParamMode::Optional,\n                                                      &type_scheme.generics,\n@@ -1723,7 +1721,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx, 'tcx> {\n     }\n \n     pub fn to_ty(&self, ast_t: &hir::Ty) -> Ty<'tcx> {\n-        let t = ast_ty_to_ty(self, self, ast_t);\n+        let t = AstConv::ast_ty_to_ty(self, self, ast_t);\n         self.register_wf_obligation(t, ast_t.span, traits::MiscObligation);\n         t\n     }\n@@ -2325,7 +2323,7 @@ fn make_overloaded_lvalue_return_type(&self,\n \n fn lookup_indexing(&self,\n                    expr: &hir::Expr,\n-                   base_expr: &'tcx hir::Expr,\n+                   base_expr: &'gcx hir::Expr,\n                    base_ty: Ty<'tcx>,\n                    idx_ty: Ty<'tcx>,\n                    lvalue_pref: LvaluePreference)\n@@ -2367,7 +2365,7 @@ fn lookup_indexing(&self,\n fn try_index_step(&self,\n                   method_call: MethodCall,\n                   expr: &hir::Expr,\n-                  base_expr: &'tcx hir::Expr,\n+                  base_expr: &'gcx hir::Expr,\n                   adjusted_ty: Ty<'tcx>,\n                   autoderefs: usize,\n                   unsize: bool,\n@@ -2442,8 +2440,8 @@ fn try_index_step(&self,\n fn check_method_argument_types(&self,\n                                sp: Span,\n                                method_fn_ty: Ty<'tcx>,\n-                               callee_expr: &'tcx hir::Expr,\n-                               args_no_rcvr: &'tcx [P<hir::Expr>],\n+                               callee_expr: &'gcx hir::Expr,\n+                               args_no_rcvr: &'gcx [P<hir::Expr>],\n                                tuple_arguments: TupleArgumentsFlag,\n                                expected: Expectation<'tcx>)\n                                -> ty::FnOutput<'tcx> {\n@@ -2482,7 +2480,7 @@ fn check_argument_types(&self,\n                         sp: Span,\n                         fn_inputs: &[Ty<'tcx>],\n                         expected_arg_tys: &[Ty<'tcx>],\n-                        args: &'tcx [P<hir::Expr>],\n+                        args: &'gcx [P<hir::Expr>],\n                         variadic: bool,\n                         tuple_arguments: TupleArgumentsFlag) {\n     let tcx = self.tcx;\n@@ -2756,42 +2754,42 @@ fn check_lit(&self,\n }\n \n fn check_expr_eq_type(&self,\n-                      expr: &'tcx hir::Expr,\n+                      expr: &'gcx hir::Expr,\n                       expected: Ty<'tcx>) {\n     self.check_expr_with_hint(expr, expected);\n     self.demand_eqtype(expr.span, expected, self.expr_ty(expr));\n }\n \n pub fn check_expr_has_type(&self,\n-                           expr: &'tcx hir::Expr,\n+                           expr: &'gcx hir::Expr,\n                            expected: Ty<'tcx>) {\n     self.check_expr_with_hint(expr, expected);\n     self.demand_suptype(expr.span, expected, self.expr_ty(expr));\n }\n \n fn check_expr_coercable_to_type(&self,\n-                                expr: &'tcx hir::Expr,\n+                                expr: &'gcx hir::Expr,\n                                 expected: Ty<'tcx>) {\n     self.check_expr_with_hint(expr, expected);\n     self.demand_coerce(expr, expected);\n }\n \n-fn check_expr_with_hint(&self, expr: &'tcx hir::Expr,\n+fn check_expr_with_hint(&self, expr: &'gcx hir::Expr,\n                         expected: Ty<'tcx>) {\n     self.check_expr_with_expectation(expr, ExpectHasType(expected))\n }\n \n fn check_expr_with_expectation(&self,\n-                               expr: &'tcx hir::Expr,\n+                               expr: &'gcx hir::Expr,\n                                expected: Expectation<'tcx>) {\n     self.check_expr_with_expectation_and_lvalue_pref(expr, expected, NoPreference)\n }\n \n-fn check_expr(&self, expr: &'tcx hir::Expr)  {\n+fn check_expr(&self, expr: &'gcx hir::Expr)  {\n     self.check_expr_with_expectation(expr, NoExpectation)\n }\n \n-fn check_expr_with_lvalue_pref(&self, expr: &'tcx hir::Expr,\n+fn check_expr_with_lvalue_pref(&self, expr: &'gcx hir::Expr,\n                                lvalue_pref: LvaluePreference)  {\n     self.check_expr_with_expectation_and_lvalue_pref(expr, NoExpectation, lvalue_pref)\n }\n@@ -2867,9 +2865,9 @@ fn expected_types_for_fn_args(&self,\n \n     // Checks a method call.\n     fn check_method_call(&self,\n-                         expr: &'tcx hir::Expr,\n+                         expr: &'gcx hir::Expr,\n                          method_name: Spanned<ast::Name>,\n-                         args: &'tcx [P<hir::Expr>],\n+                         args: &'gcx [P<hir::Expr>],\n                          tps: &[P<hir::Ty>],\n                          expected: Expectation<'tcx>,\n                          lvalue_pref: LvaluePreference) {\n@@ -2914,9 +2912,9 @@ fn expected_types_for_fn_args(&self,\n     // A generic function for checking the then and else in an if\n     // or if-else.\n     fn check_then_else(&self,\n-                       cond_expr: &'tcx hir::Expr,\n-                       then_blk: &'tcx hir::Block,\n-                       opt_else_expr: Option<&'tcx hir::Expr>,\n+                       cond_expr: &'gcx hir::Expr,\n+                       then_blk: &'gcx hir::Block,\n+                       opt_else_expr: Option<&'gcx hir::Expr>,\n                        id: ast::NodeId,\n                        sp: Span,\n                        expected: Expectation<'tcx>) {\n@@ -2989,9 +2987,9 @@ fn expected_types_for_fn_args(&self,\n \n     // Check field access expressions\n     fn check_field(&self,\n-                   expr: &'tcx hir::Expr,\n+                   expr: &'gcx hir::Expr,\n                    lvalue_pref: LvaluePreference,\n-                   base: &'tcx hir::Expr,\n+                   base: &'gcx hir::Expr,\n                    field: &Spanned<ast::Name>) {\n         self.check_expr_with_lvalue_pref(base, lvalue_pref);\n         let expr_t = self.structurally_resolved_type(expr.span,\n@@ -3080,9 +3078,9 @@ fn expected_types_for_fn_args(&self,\n \n     // Check tuple index expressions\n     fn check_tup_field(&self,\n-                       expr: &'tcx hir::Expr,\n+                       expr: &'gcx hir::Expr,\n                        lvalue_pref: LvaluePreference,\n-                       base: &'tcx hir::Expr,\n+                       base: &'gcx hir::Expr,\n                        idx: codemap::Spanned<usize>) {\n         self.check_expr_with_lvalue_pref(base, lvalue_pref);\n         let expr_t = self.structurally_resolved_type(expr.span,\n@@ -3180,7 +3178,7 @@ fn expected_types_for_fn_args(&self,\n                                 adt_ty: Ty<'tcx>,\n                                 span: Span,\n                                 variant: ty::VariantDef<'tcx>,\n-                                ast_fields: &'tcx [hir::Field],\n+                                ast_fields: &'gcx [hir::Field],\n                                 check_completeness: bool) {\n         let tcx = self.tcx;\n         let substs = match adt_ty.sty {\n@@ -3237,8 +3235,8 @@ fn expected_types_for_fn_args(&self,\n \n     fn check_struct_fields_on_error(&self,\n                                     id: ast::NodeId,\n-                                    fields: &'tcx [hir::Field],\n-                                    base_expr: &'tcx Option<P<hir::Expr>>) {\n+                                    fields: &'gcx [hir::Field],\n+                                    base_expr: &'gcx Option<P<hir::Expr>>) {\n         // Make sure to still write the types\n         // otherwise we might ICE\n         self.write_error(id);\n@@ -3254,8 +3252,8 @@ fn expected_types_for_fn_args(&self,\n     fn check_expr_struct(&self,\n                          expr: &hir::Expr,\n                          path: &hir::Path,\n-                         fields: &'tcx [hir::Field],\n-                         base_expr: &'tcx Option<P<hir::Expr>>)\n+                         fields: &'gcx [hir::Field],\n+                         base_expr: &'gcx Option<P<hir::Expr>>)\n     {\n         let tcx = self.tcx;\n \n@@ -3315,7 +3313,7 @@ fn expected_types_for_fn_args(&self,\n /// that there are actually multiple representations for `TyError`, so avoid\n /// that when err needs to be handled differently.\n fn check_expr_with_expectation_and_lvalue_pref(&self,\n-                                               expr: &'tcx hir::Expr,\n+                                               expr: &'gcx hir::Expr,\n                                                expected: Expectation<'tcx>,\n                                                lvalue_pref: LvaluePreference) {\n     debug!(\">> typechecking: expr={:?} expected={:?}\",\n@@ -3666,7 +3664,7 @@ fn check_expr_with_expectation_and_lvalue_pref(&self,\n       }\n       hir::ExprRepeat(ref element, ref count_expr) => {\n         self.check_expr_has_type(&count_expr, tcx.types.usize);\n-        let count = eval_repeat_count(self.tcx, &count_expr);\n+        let count = eval_repeat_count(self.tcx.global_tcx(), &count_expr);\n \n         let uty = match expected {\n             ExpectHasType(uty) => {\n@@ -3827,7 +3825,7 @@ pub fn resolve_ty_and_def_ufcs<'b>(&self,\n         let mut def = path_res.base_def;\n         let ty_segments = path.segments.split_last().unwrap().1;\n         let base_ty_end = path.segments.len() - path_res.depth;\n-        let ty = astconv::finish_resolving_def_to_ty(self, self, span,\n+        let ty = AstConv::finish_resolving_def_to_ty(self, self, span,\n                                                      PathParamMode::Optional,\n                                                      &mut def,\n                                                      opt_self_ty,\n@@ -3864,8 +3862,8 @@ pub fn resolve_ty_and_def_ufcs<'b>(&self,\n }\n \n pub fn check_decl_initializer(&self,\n-                              local: &'tcx hir::Local,\n-                              init: &'tcx hir::Expr)\n+                              local: &'gcx hir::Local,\n+                              init: &'gcx hir::Expr)\n {\n     let ref_bindings = self.tcx.pat_contains_ref_binding(&local.pat);\n \n@@ -3887,7 +3885,7 @@ pub fn check_decl_initializer(&self,\n     };\n }\n \n-pub fn check_decl_local(&self, local: &'tcx hir::Local)  {\n+pub fn check_decl_local(&self, local: &'gcx hir::Local)  {\n     let tcx = self.tcx;\n \n     let t = self.local_ty(local.span, local.id);\n@@ -3912,7 +3910,7 @@ pub fn check_decl_local(&self, local: &'tcx hir::Local)  {\n     }\n }\n \n-pub fn check_stmt(&self, stmt: &'tcx hir::Stmt)  {\n+pub fn check_stmt(&self, stmt: &'gcx hir::Stmt)  {\n     let node_id;\n     let mut saw_bot = false;\n     let mut saw_err = false;\n@@ -3956,7 +3954,7 @@ pub fn check_stmt(&self, stmt: &'tcx hir::Stmt)  {\n     }\n }\n \n-pub fn check_block_no_value(&self, blk: &'tcx hir::Block)  {\n+pub fn check_block_no_value(&self, blk: &'gcx hir::Block)  {\n     self.check_block_with_expected(blk, ExpectHasType(self.tcx.mk_nil()));\n     let blkty = self.node_ty(blk.id);\n     if blkty.references_error() {\n@@ -3968,7 +3966,7 @@ pub fn check_block_no_value(&self, blk: &'tcx hir::Block)  {\n }\n \n fn check_block_with_expected(&self,\n-                             blk: &'tcx hir::Block,\n+                             blk: &'gcx hir::Block,\n                              expected: Expectation<'tcx>) {\n     let prev = {\n         let mut fcx_ps = self.ps.borrow_mut();\n@@ -4047,7 +4045,7 @@ fn check_block_with_expected(&self,\n \n fn check_const_with_ty(&self,\n                        _: Span,\n-                       e: &'tcx hir::Expr,\n+                       e: &'gcx hir::Expr,\n                        declty: Ty<'tcx>) {\n     // Gather locals in statics (because of block expressions).\n     // This is technically unnecessary because locals in static items are forbidden,"}, {"sha": "3986b866033e45f795200f6c85f363d7b3e81437", "filename": "src/librustc_typeck/check/op.rs", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/31a07b0ce662e95119a76cce8dcfc29d2055f738/src%2Flibrustc_typeck%2Fcheck%2Fop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31a07b0ce662e95119a76cce8dcfc29d2055f738/src%2Flibrustc_typeck%2Fcheck%2Fop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fop.rs?ref=31a07b0ce662e95119a76cce8dcfc29d2055f738", "patch": "@@ -17,13 +17,13 @@ use syntax::ast;\n use syntax::parse::token;\n use rustc::hir;\n \n-impl<'a, 'tcx> FnCtxt<'a, 'tcx, 'tcx> {\n+impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n /// Check a `a <op>= b`\n pub fn check_binop_assign(&self,\n-                          expr: &'tcx hir::Expr,\n+                          expr: &'gcx hir::Expr,\n                           op: hir::BinOp,\n-                          lhs_expr: &'tcx hir::Expr,\n-                          rhs_expr: &'tcx hir::Expr)\n+                          lhs_expr: &'gcx hir::Expr,\n+                          rhs_expr: &'gcx hir::Expr)\n {\n     self.check_expr_with_lvalue_pref(lhs_expr, PreferMutLvalue);\n \n@@ -47,10 +47,10 @@ pub fn check_binop_assign(&self,\n \n /// Check a potentially overloaded binary operator.\n pub fn check_binop(&self,\n-                   expr: &'tcx hir::Expr,\n+                   expr: &'gcx hir::Expr,\n                    op: hir::BinOp,\n-                   lhs_expr: &'tcx hir::Expr,\n-                   rhs_expr: &'tcx hir::Expr)\n+                   lhs_expr: &'gcx hir::Expr,\n+                   rhs_expr: &'gcx hir::Expr)\n {\n     let tcx = self.tcx;\n \n@@ -106,9 +106,9 @@ pub fn check_binop(&self,\n }\n \n fn enforce_builtin_binop_types(&self,\n-                               lhs_expr: &'tcx hir::Expr,\n+                               lhs_expr: &'gcx hir::Expr,\n                                lhs_ty: Ty<'tcx>,\n-                               rhs_expr: &'tcx hir::Expr,\n+                               rhs_expr: &'gcx hir::Expr,\n                                rhs_ty: Ty<'tcx>,\n                                op: hir::BinOp)\n                                -> Ty<'tcx>\n@@ -144,10 +144,10 @@ fn enforce_builtin_binop_types(&self,\n }\n \n fn check_overloaded_binop(&self,\n-                          expr: &'tcx hir::Expr,\n-                          lhs_expr: &'tcx hir::Expr,\n+                          expr: &'gcx hir::Expr,\n+                          lhs_expr: &'gcx hir::Expr,\n                           lhs_ty: Ty<'tcx>,\n-                          rhs_expr: &'tcx hir::Expr,\n+                          rhs_expr: &'gcx hir::Expr,\n                           op: hir::BinOp,\n                           is_assign: IsAssign)\n                           -> (Ty<'tcx>, Ty<'tcx>)\n@@ -222,8 +222,8 @@ pub fn check_user_unop(&self,\n                        op_str: &str,\n                        mname: &str,\n                        trait_did: Option<DefId>,\n-                       ex: &'tcx hir::Expr,\n-                       operand_expr: &'tcx hir::Expr,\n+                       ex: &'gcx hir::Expr,\n+                       operand_expr: &'gcx hir::Expr,\n                        operand_ty: Ty<'tcx>,\n                        op: hir::UnOp)\n                        -> Ty<'tcx>\n@@ -294,7 +294,7 @@ fn name_and_trait_def_id(&self,\n }\n \n fn lookup_op_method(&self,\n-                    expr: &'tcx hir::Expr,\n+                    expr: &'gcx hir::Expr,\n                     lhs_ty: Ty<'tcx>,\n                     other_tys: Vec<Ty<'tcx>>,\n                     opname: ast::Name,"}, {"sha": "931f77951eb266da806faa5c3251fcf6e56f0c51", "filename": "src/librustc_typeck/check/regionck.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/31a07b0ce662e95119a76cce8dcfc29d2055f738/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31a07b0ce662e95119a76cce8dcfc29d2055f738/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs?ref=31a07b0ce662e95119a76cce8dcfc29d2055f738", "patch": "@@ -113,7 +113,7 @@ macro_rules! ignore_err {\n ///////////////////////////////////////////////////////////////////////////\n // PUBLIC ENTRY POINTS\n \n-impl<'a, 'tcx> FnCtxt<'a, 'tcx, 'tcx> {\n+impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n pub fn regionck_expr(&self, e: &hir::Expr) {\n     let mut rcx = RegionCtxt::new(self, RepeatingScope(e.id), e.id, Subject(e.id));\n     if self.err_count_since_creation() == 0 {\n@@ -198,11 +198,11 @@ impl<'a, 'gcx, 'tcx> Deref for RegionCtxt<'a, 'gcx, 'tcx> {\n pub struct RepeatingScope(ast::NodeId);\n pub enum SubjectNode { Subject(ast::NodeId), None }\n \n-impl<'a, 'tcx> RegionCtxt<'a, 'tcx, 'tcx> {\n-    pub fn new(fcx: &'a FnCtxt<'a, 'tcx, 'tcx>,\n+impl<'a, 'gcx, 'tcx> RegionCtxt<'a, 'gcx, 'tcx> {\n+    pub fn new(fcx: &'a FnCtxt<'a, 'gcx, 'tcx>,\n                initial_repeating_scope: RepeatingScope,\n                initial_body_id: ast::NodeId,\n-               subject: SubjectNode) -> RegionCtxt<'a, 'tcx, 'tcx> {\n+               subject: SubjectNode) -> RegionCtxt<'a, 'gcx, 'tcx> {\n         let RepeatingScope(initial_repeating_scope) = initial_repeating_scope;\n         RegionCtxt {\n             fcx: fcx,\n@@ -487,7 +487,7 @@ fn constrain_bindings_in_pat(&mut self, pat: &hir::Pat) {\n }\n }\n \n-impl<'a, 'tcx, 'v> Visitor<'v> for RegionCtxt<'a, 'tcx, 'tcx> {\n+impl<'a, 'gcx, 'tcx, 'v> Visitor<'v> for RegionCtxt<'a, 'gcx, 'tcx> {\n     // (..) FIXME(#3238) should use visit_pat, not visit_arm/visit_local,\n     // However, right now we run into an issue whereby some free\n     // regions are not properly related if they appear within the\n@@ -794,7 +794,7 @@ fn visit_expr(&mut self, expr: &hir::Expr) {\n }\n }\n \n-impl<'a, 'tcx> RegionCtxt<'a, 'tcx, 'tcx> {\n+impl<'a, 'gcx, 'tcx> RegionCtxt<'a, 'gcx, 'tcx> {\n fn constrain_cast(&mut self,\n                   cast_expr: &hir::Expr,\n                   source_expr: &hir::Expr)\n@@ -1151,7 +1151,7 @@ fn link_fn_args(&self, body_scope: CodeExtent, args: &[hir::Arg]) {\n /// Link lifetimes of any ref bindings in `root_pat` to the pointers found in the discriminant, if\n /// needed.\n fn link_pattern<'t>(&self,\n-                    mc: mc::MemCategorizationContext<'a, 'tcx, 'tcx>,\n+                    mc: mc::MemCategorizationContext<'a, 'gcx, 'tcx>,\n                     discr_cmt: mc::cmt<'tcx>,\n                     root_pat: &hir::Pat) {\n     debug!(\"link_pattern(discr_cmt={:?}, root_pat={:?})\","}, {"sha": "10c16391bf7973374216cd01b280f23f563cf6a5", "filename": "src/librustc_typeck/check/upvar.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/31a07b0ce662e95119a76cce8dcfc29d2055f738/src%2Flibrustc_typeck%2Fcheck%2Fupvar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31a07b0ce662e95119a76cce8dcfc29d2055f738/src%2Flibrustc_typeck%2Fcheck%2Fupvar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fupvar.rs?ref=31a07b0ce662e95119a76cce8dcfc29d2055f738", "patch": "@@ -56,7 +56,7 @@ use rustc::hir::intravisit::{self, Visitor};\n ///////////////////////////////////////////////////////////////////////////\n // PUBLIC ENTRY POINTS\n \n-impl<'a, 'tcx> FnCtxt<'a, 'tcx, 'tcx> {\n+impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n pub fn closure_analyze_fn(&self, body: &hir::Block) {\n     let mut seed = SeedBorrowKind::new(self);\n     seed.visit_block(body);\n@@ -90,7 +90,7 @@ struct SeedBorrowKind<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n     closures_with_inferred_kinds: HashSet<ast::NodeId>,\n }\n \n-impl<'a, 'tcx, 'v> Visitor<'v> for SeedBorrowKind<'a, 'tcx, 'tcx> {\n+impl<'a, 'gcx, 'tcx, 'v> Visitor<'v> for SeedBorrowKind<'a, 'gcx, 'tcx> {\n     fn visit_expr(&mut self, expr: &hir::Expr) {\n         match expr.node {\n             hir::ExprClosure(cc, _, ref body, _) => {\n@@ -104,8 +104,8 @@ impl<'a, 'tcx, 'v> Visitor<'v> for SeedBorrowKind<'a, 'tcx, 'tcx> {\n     }\n }\n \n-impl<'a,'tcx> SeedBorrowKind<'a,'tcx, 'tcx> {\n-    fn new(fcx: &'a FnCtxt<'a,'tcx, 'tcx>) -> SeedBorrowKind<'a,'tcx, 'tcx> {\n+impl<'a, 'gcx, 'tcx> SeedBorrowKind<'a, 'gcx, 'tcx> {\n+    fn new(fcx: &'a FnCtxt<'a, 'gcx, 'tcx>) -> SeedBorrowKind<'a, 'gcx, 'tcx> {\n         SeedBorrowKind { fcx: fcx, closures_with_inferred_kinds: HashSet::new() }\n     }\n \n@@ -157,10 +157,10 @@ struct AdjustBorrowKind<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n     closures_with_inferred_kinds: &'a HashSet<ast::NodeId>,\n }\n \n-impl<'a,'tcx> AdjustBorrowKind<'a,'tcx, 'tcx> {\n-    fn new(fcx: &'a FnCtxt<'a,'tcx, 'tcx>,\n+impl<'a, 'gcx, 'tcx> AdjustBorrowKind<'a, 'gcx, 'tcx> {\n+    fn new(fcx: &'a FnCtxt<'a, 'gcx, 'tcx>,\n            closures_with_inferred_kinds: &'a HashSet<ast::NodeId>)\n-           -> AdjustBorrowKind<'a,'tcx, 'tcx> {\n+           -> AdjustBorrowKind<'a, 'gcx, 'tcx> {\n         AdjustBorrowKind { fcx: fcx, closures_with_inferred_kinds: closures_with_inferred_kinds }\n     }\n \n@@ -492,7 +492,7 @@ impl<'a,'tcx> AdjustBorrowKind<'a,'tcx, 'tcx> {\n     }\n }\n \n-impl<'a, 'tcx, 'v> Visitor<'v> for AdjustBorrowKind<'a, 'tcx, 'tcx> {\n+impl<'a, 'gcx, 'tcx, 'v> Visitor<'v> for AdjustBorrowKind<'a, 'gcx, 'tcx> {\n     fn visit_fn(&mut self,\n                 fn_kind: intravisit::FnKind<'v>,\n                 decl: &'v hir::FnDecl,\n@@ -505,7 +505,7 @@ impl<'a, 'tcx, 'v> Visitor<'v> for AdjustBorrowKind<'a, 'tcx, 'tcx> {\n     }\n }\n \n-impl<'a,'tcx> euv::Delegate<'tcx> for AdjustBorrowKind<'a,'tcx, 'tcx> {\n+impl<'a, 'gcx, 'tcx> euv::Delegate<'tcx> for AdjustBorrowKind<'a, 'gcx, 'tcx> {\n     fn consume(&mut self,\n                _consume_id: ast::NodeId,\n                _consume_span: Span,"}, {"sha": "7739bb6bb8fd491db3c4dada83b4b038851b7607", "filename": "src/librustc_typeck/check/wfcheck.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/31a07b0ce662e95119a76cce8dcfc29d2055f738/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31a07b0ce662e95119a76cce8dcfc29d2055f738/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs?ref=31a07b0ce662e95119a76cce8dcfc29d2055f738", "patch": "@@ -410,10 +410,8 @@ impl<'ccx, 'tcx> CheckTypeWellFormedVisitor<'ccx, 'tcx> {\n \n         debug!(\"check_method_receiver: receiver ty = {:?}\", rcvr_ty);\n \n-        let _ = ::require_same_types(\n-            fcx.ccx, Some(fcx), span,\n-            sig.inputs[0], rcvr_ty,\n-            \"mismatched method receiver\");\n+        fcx.require_same_types(span, sig.inputs[0], rcvr_ty,\n+                               \"mismatched method receiver\");\n     }\n \n     fn check_variances_for_type_defn(&self,"}, {"sha": "1c7496d611eaa71aa2dc1da81a4cad2b2b9d689f", "filename": "src/librustc_typeck/check/writeback.rs", "status": "modified", "additions": 25, "deletions": 17, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/31a07b0ce662e95119a76cce8dcfc29d2055f738/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31a07b0ce662e95119a76cce8dcfc29d2055f738/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs?ref=31a07b0ce662e95119a76cce8dcfc29d2055f738", "patch": "@@ -34,7 +34,7 @@ use rustc::hir;\n ///////////////////////////////////////////////////////////////////////////\n // Entry point functions\n \n-impl<'a, 'tcx> FnCtxt<'a, 'tcx, 'tcx> {\n+impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n pub fn resolve_type_vars_in_expr(&self, e: &hir::Expr) {\n     assert_eq!(self.writeback_errors.get(), false);\n     let mut wbcx = WritebackCx::new(self);\n@@ -78,12 +78,12 @@ struct WritebackCx<'cx, 'gcx: 'cx+'tcx, 'tcx: 'cx> {\n     fcx: &'cx FnCtxt<'cx, 'gcx, 'tcx>,\n }\n \n-impl<'cx, 'tcx> WritebackCx<'cx, 'tcx, 'tcx> {\n-    fn new(fcx: &'cx FnCtxt<'cx, 'tcx, 'tcx>) -> WritebackCx<'cx, 'tcx, 'tcx> {\n+impl<'cx, 'gcx, 'tcx> WritebackCx<'cx, 'gcx, 'tcx> {\n+    fn new(fcx: &'cx FnCtxt<'cx, 'gcx, 'tcx>) -> WritebackCx<'cx, 'gcx, 'tcx> {\n         WritebackCx { fcx: fcx }\n     }\n \n-    fn tcx(&self) -> TyCtxt<'cx, 'tcx, 'tcx> {\n+    fn tcx(&self) -> TyCtxt<'cx, 'gcx, 'tcx> {\n         self.fcx.tcx\n     }\n \n@@ -134,7 +134,7 @@ impl<'cx, 'tcx> WritebackCx<'cx, 'tcx, 'tcx> {\n // below. In general, a function is made into a `visitor` if it must\n // traffic in node-ids or update tables in the type context etc.\n \n-impl<'cx, 'tcx, 'v> Visitor<'v> for WritebackCx<'cx, 'tcx, 'tcx> {\n+impl<'cx, 'gcx, 'tcx, 'v> Visitor<'v> for WritebackCx<'cx, 'gcx, 'tcx> {\n     fn visit_stmt(&mut self, s: &hir::Stmt) {\n         if self.fcx.writeback_errors.get() {\n             return;\n@@ -214,7 +214,7 @@ impl<'cx, 'tcx, 'v> Visitor<'v> for WritebackCx<'cx, 'tcx, 'tcx> {\n     }\n }\n \n-impl<'cx, 'tcx> WritebackCx<'cx, 'tcx, 'tcx> {\n+impl<'cx, 'gcx, 'tcx> WritebackCx<'cx, 'gcx, 'tcx> {\n     fn visit_upvar_borrow_map(&self) {\n         if self.fcx.writeback_errors.get() {\n             return;\n@@ -359,8 +359,16 @@ impl<'cx, 'tcx> WritebackCx<'cx, 'tcx, 'tcx> {\n         }\n     }\n \n-    fn resolve<T:TypeFoldable<'tcx>>(&self, t: &T, reason: ResolveReason) -> T {\n-        t.fold_with(&mut Resolver::new(self.fcx, reason))\n+    fn resolve<T>(&self, x: &T, reason: ResolveReason) -> T::Lifted\n+        where T: TypeFoldable<'tcx> + ty::Lift<'gcx>\n+    {\n+        let x = x.fold_with(&mut Resolver::new(self.fcx, reason));\n+        if let Some(lifted) = self.tcx().lift_to_global(&x) {\n+            lifted\n+        } else {\n+            span_bug!(reason.span(self.tcx()),\n+                      \"writeback: `{:?}` missing from the global type context\", x);\n+        }\n     }\n }\n \n@@ -378,8 +386,8 @@ enum ResolveReason {\n     ResolvingFieldTypes(ast::NodeId)\n }\n \n-impl ResolveReason {\n-    fn span<'a, 'tcx>(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>) -> Span {\n+impl<'a, 'gcx, 'tcx> ResolveReason {\n+    fn span(&self, tcx: TyCtxt<'a, 'gcx, 'tcx>) -> Span {\n         match *self {\n             ResolvingExpr(s) => s,\n             ResolvingLocal(s) => s,\n@@ -415,18 +423,18 @@ struct Resolver<'cx, 'gcx: 'cx+'tcx, 'tcx: 'cx> {\n     reason: ResolveReason,\n }\n \n-impl<'cx, 'tcx> Resolver<'cx, 'tcx, 'tcx> {\n-    fn new(fcx: &'cx FnCtxt<'cx, 'tcx, 'tcx>,\n+impl<'cx, 'gcx, 'tcx> Resolver<'cx, 'gcx, 'tcx> {\n+    fn new(fcx: &'cx FnCtxt<'cx, 'gcx, 'tcx>,\n            reason: ResolveReason)\n-           -> Resolver<'cx, 'tcx, 'tcx>\n+           -> Resolver<'cx, 'gcx, 'tcx>\n     {\n         Resolver::from_infcx(fcx, &fcx.writeback_errors, reason)\n     }\n \n-    fn from_infcx(infcx: &'cx InferCtxt<'cx, 'tcx, 'tcx>,\n+    fn from_infcx(infcx: &'cx InferCtxt<'cx, 'gcx, 'tcx>,\n                   writeback_errors: &'cx Cell<bool>,\n                   reason: ResolveReason)\n-                  -> Resolver<'cx, 'tcx, 'tcx>\n+                  -> Resolver<'cx, 'gcx, 'tcx>\n     {\n         Resolver { infcx: infcx,\n                    tcx: infcx.tcx,\n@@ -480,8 +488,8 @@ impl<'cx, 'tcx> Resolver<'cx, 'tcx, 'tcx> {\n     }\n }\n \n-impl<'cx, 'tcx> TypeFolder<'tcx, 'tcx> for Resolver<'cx, 'tcx, 'tcx> {\n-    fn tcx<'a>(&'a self) -> TyCtxt<'a, 'tcx, 'tcx> {\n+impl<'cx, 'gcx, 'tcx> TypeFolder<'gcx, 'tcx> for Resolver<'cx, 'gcx, 'tcx> {\n+    fn tcx<'a>(&'a self) -> TyCtxt<'a, 'gcx, 'tcx> {\n         self.tcx\n     }\n "}, {"sha": "797a1509ebee51001ca797a884bc7a8e8e8b8465", "filename": "src/librustc_typeck/collect.rs", "status": "modified", "additions": 20, "deletions": 20, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/31a07b0ce662e95119a76cce8dcfc29d2055f738/src%2Flibrustc_typeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31a07b0ce662e95119a76cce8dcfc29d2055f738/src%2Flibrustc_typeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcollect.rs?ref=31a07b0ce662e95119a76cce8dcfc29d2055f738", "patch": "@@ -58,7 +58,7 @@ There are some shortcomings in this design:\n \n */\n \n-use astconv::{self, AstConv, ty_of_arg, ast_ty_to_ty, ast_region_to_region};\n+use astconv::{AstConv, ast_region_to_region, Bounds, PartitionedBounds, partition_bounds};\n use lint;\n use hir::def::Def;\n use hir::def_id::DefId;\n@@ -291,7 +291,7 @@ impl<'a,'tcx> CrateCtxt<'a,'tcx> {\n \n impl<'a,'tcx> ItemCtxt<'a,'tcx> {\n     fn to_ty<RS:RegionScope>(&self, rs: &RS, ast_ty: &hir::Ty) -> Ty<'tcx> {\n-        ast_ty_to_ty(self, rs, ast_ty)\n+        AstConv::ast_ty_to_ty(self, rs, ast_ty)\n     }\n }\n \n@@ -559,7 +559,7 @@ fn convert_method<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n         ty_generic_predicates_for_fn(ccx, &sig.generics, rcvr_ty_predicates);\n \n     let (fty, explicit_self_category) =\n-        astconv::ty_of_method(&ccx.icx(&(rcvr_ty_predicates, &sig.generics)),\n+        AstConv::ty_of_method(&ccx.icx(&(rcvr_ty_predicates, &sig.generics)),\n                               sig, untransformed_rcvr_ty);\n \n     let def_id = ccx.tcx.map.local_def_id(id);\n@@ -712,7 +712,7 @@ fn convert_item(ccx: &CrateCtxt, it: &hir::Item) {\n         },\n         hir::ItemDefaultImpl(_, ref ast_trait_ref) => {\n             let trait_ref =\n-                astconv::instantiate_mono_trait_ref(&ccx.icx(&()),\n+                AstConv::instantiate_mono_trait_ref(&ccx.icx(&()),\n                                                     &ExplicitRscope,\n                                                     ast_trait_ref,\n                                                     None);\n@@ -742,7 +742,7 @@ fn convert_item(ccx: &CrateCtxt, it: &hir::Item) {\n                                    TypeScheme { generics: ty_generics.clone(),\n                                                 ty: selfty });\n             let trait_ref = opt_trait_ref.as_ref().map(|ast_trait_ref| {\n-                astconv::instantiate_mono_trait_ref(&ccx.icx(&ty_predicates),\n+                AstConv::instantiate_mono_trait_ref(&ccx.icx(&ty_predicates),\n                                                     &ExplicitRscope,\n                                                     ast_trait_ref,\n                                                     Some(selfty))\n@@ -1452,7 +1452,7 @@ fn compute_type_scheme_of_item<'a,'tcx>(ccx: &CrateCtxt<'a,'tcx>,\n         }\n         hir::ItemFn(ref decl, unsafety, _, abi, ref generics, _) => {\n             let ty_generics = ty_generics_for_fn(ccx, generics, &ty::Generics::empty());\n-            let tofd = astconv::ty_of_bare_fn(&ccx.icx(generics), unsafety, abi, &decl);\n+            let tofd = AstConv::ty_of_bare_fn(&ccx.icx(generics), unsafety, abi, &decl);\n             let def_id = ccx.tcx.map.local_def_id(it.id);\n             let substs = mk_item_substs(ccx, &ty_generics);\n             let ty = tcx.mk_fn_def(def_id, substs, tofd);\n@@ -1582,7 +1582,7 @@ fn compute_type_scheme_of_foreign_item<'a, 'tcx>(\n         hir::ForeignItemStatic(ref t, _) => {\n             ty::TypeScheme {\n                 generics: ty::Generics::empty(),\n-                ty: ast_ty_to_ty(&ccx.icx(&()), &ExplicitRscope, t)\n+                ty: AstConv::ast_ty_to_ty(&ccx.icx(&()), &ExplicitRscope, t)\n             }\n         }\n     }\n@@ -1793,9 +1793,9 @@ fn ty_generic_predicates<'a,'tcx>(ccx: &CrateCtxt<'a,'tcx>,\n     for predicate in &where_clause.predicates {\n         match predicate {\n             &hir::WherePredicate::BoundPredicate(ref bound_pred) => {\n-                let ty = ast_ty_to_ty(&ccx.icx(&(base_predicates, ast_generics)),\n-                                      &ExplicitRscope,\n-                                      &bound_pred.bounded_ty);\n+                let ty = AstConv::ast_ty_to_ty(&ccx.icx(&(base_predicates, ast_generics)),\n+                                               &ExplicitRscope,\n+                                               &bound_pred.bounded_ty);\n \n                 for bound in bound_pred.bounds.iter() {\n                     match bound {\n@@ -1887,7 +1887,7 @@ fn convert_default_type_parameter<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n                                             index: u32)\n                                             -> Ty<'tcx>\n {\n-    let ty = ast_ty_to_ty(&ccx.icx(&()), &ExplicitRscope, &path);\n+    let ty = AstConv::ast_ty_to_ty(&ccx.icx(&()), &ExplicitRscope, &path);\n \n     for leaf_ty in ty.walk() {\n         if let ty::TyParam(p) = leaf_ty.sty {\n@@ -1991,7 +1991,7 @@ fn compute_object_lifetime_default<'a,'tcx>(ccx: &CrateCtxt<'a,'tcx>,\n                       hir::TraitTyParamBound(..) =>\n                           None,\n                       hir::RegionTyParamBound(ref lifetime) =>\n-                          Some(astconv::ast_region_to_region(ccx.tcx, lifetime)),\n+                          Some(ast_region_to_region(ccx.tcx, lifetime)),\n                   }\n               })\n               .collect()\n@@ -2034,7 +2034,7 @@ fn compute_bounds<'tcx>(astconv: &AstConv<'tcx, 'tcx>,\n                         ast_bounds: &[hir::TyParamBound],\n                         sized_by_default: SizedByDefault,\n                         span: Span)\n-                        -> astconv::Bounds<'tcx>\n+                        -> Bounds<'tcx>\n {\n     let mut bounds =\n         conv_param_bounds(astconv,\n@@ -2090,7 +2090,7 @@ fn conv_poly_trait_ref<'tcx>(astconv: &AstConv<'tcx, 'tcx>,\n                              projections: &mut Vec<ty::PolyProjectionPredicate<'tcx>>)\n                              -> ty::PolyTraitRef<'tcx>\n {\n-    astconv::instantiate_poly_trait_ref(astconv,\n+    AstConv::instantiate_poly_trait_ref(astconv,\n                                         &ExplicitRscope,\n                                         trait_ref,\n                                         Some(param_ty),\n@@ -2101,14 +2101,14 @@ fn conv_param_bounds<'a,'tcx>(astconv: &AstConv<'tcx, 'tcx>,\n                               span: Span,\n                               param_ty: ty::Ty<'tcx>,\n                               ast_bounds: &[hir::TyParamBound])\n-                              -> astconv::Bounds<'tcx>\n+                              -> Bounds<'tcx>\n {\n     let tcx = astconv.tcx();\n-    let astconv::PartitionedBounds {\n+    let PartitionedBounds {\n         builtin_bounds,\n         trait_bounds,\n         region_bounds\n-    } = astconv::partition_bounds(tcx, span, &ast_bounds);\n+    } = partition_bounds(tcx, span, &ast_bounds);\n \n     let mut projection_bounds = Vec::new();\n \n@@ -2125,7 +2125,7 @@ fn conv_param_bounds<'a,'tcx>(astconv: &AstConv<'tcx, 'tcx>,\n                      .map(|r| ast_region_to_region(tcx, r))\n                      .collect();\n \n-    astconv::Bounds {\n+    Bounds {\n         region_bounds: region_bounds,\n         builtin_bounds: builtin_bounds,\n         trait_bounds: trait_bounds,\n@@ -2157,12 +2157,12 @@ fn compute_type_scheme_of_foreign_fn_decl<'a, 'tcx>(\n     let rb = BindingRscope::new();\n     let input_tys = decl.inputs\n                         .iter()\n-                        .map(|a| ty_of_arg(&ccx.icx(ast_generics), &rb, a, None))\n+                        .map(|a| AstConv::ty_of_arg(&ccx.icx(ast_generics), &rb, a, None))\n                         .collect::<Vec<_>>();\n \n     let output = match decl.output {\n         hir::Return(ref ty) =>\n-            ty::FnConverging(ast_ty_to_ty(&ccx.icx(ast_generics), &rb, &ty)),\n+            ty::FnConverging(AstConv::ast_ty_to_ty(&ccx.icx(ast_generics), &rb, &ty)),\n         hir::DefaultReturn(..) =>\n             ty::FnConverging(ccx.tcx.mk_nil()),\n         hir::NoReturn(..) =>"}, {"sha": "3c46d962198f9ab45f6f3e0451be93f96002af89", "filename": "src/librustc_typeck/lib.rs", "status": "modified", "additions": 24, "deletions": 27, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/31a07b0ce662e95119a76cce8dcfc29d2055f738/src%2Flibrustc_typeck%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31a07b0ce662e95119a76cce8dcfc29d2055f738/src%2Flibrustc_typeck%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Flib.rs?ref=31a07b0ce662e95119a76cce8dcfc29d2055f738", "patch": "@@ -104,7 +104,7 @@ pub use rustc::util;\n use dep_graph::DepNode;\n use hir::map as hir_map;\n use hir::def::Def;\n-use rustc::infer::{self, InferCtxt, TypeOrigin};\n+use rustc::infer::{InferCtxt, TypeOrigin};\n use rustc::ty::subst::Substs;\n use rustc::ty::{self, Ty, TyCtxt, TypeFoldable};\n use rustc::traits::ProjectionMode;\n@@ -192,36 +192,33 @@ fn require_c_abi_if_variadic(tcx: TyCtxt,\n     }\n }\n \n+pub fn emit_type_err<'a, 'gcx, 'tcx>(tcx: TyCtxt<'a, 'gcx, 'tcx>,\n+                                     span: Span,\n+                                     found_ty: Ty<'tcx>,\n+                                     expected_ty: Ty<'tcx>,\n+                                     terr: &ty::error::TypeError<'tcx>,\n+                                     msg: &str) {\n+    let mut err = struct_span_err!(tcx.sess, span, E0211, \"{}\", msg);\n+    err = err.span_label(span, &terr);\n+    err = err.note_expected_found(&\"type\", &expected_ty, &found_ty);\n+    tcx.note_and_explain_type_err(&mut err, terr, span);\n+    err.emit();\n+}\n+\n fn require_same_types<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n-                                maybe_infcx: Option<&infer::InferCtxt<'a, 'tcx, 'tcx>>,\n                                 span: Span,\n                                 t1: Ty<'tcx>,\n                                 t2: Ty<'tcx>,\n                                 msg: &str)\n-                                -> bool\n-{\n-    let err = if let Some(infcx) = maybe_infcx {\n-        infcx.eq_types(false, TypeOrigin::Misc(span), t1, t2).err()\n-    } else {\n-        InferCtxt::enter(ccx.tcx, None, None, ProjectionMode::AnyFinal, |infcx| {\n-            infcx.eq_types(false, TypeOrigin::Misc(span), t1, t2).err()\n-        })\n-    };\n-\n-    if let Some(ref terr) = err {\n-        let mut err = struct_span_err!(ccx.tcx.sess, span, E0211, \"{}\", msg);\n-        err = err.span_label(span, &terr);\n-        let (mut expected_ty, mut found_ty) = (t2, t1);\n-        if let Some(infcx) = maybe_infcx {\n-            expected_ty = infcx.resolve_type_vars_if_possible(&expected_ty);\n-            found_ty = infcx.resolve_type_vars_if_possible(&found_ty);\n+                                -> bool {\n+    InferCtxt::enter(ccx.tcx, None, None, ProjectionMode::AnyFinal, |infcx| {\n+        if let Err(err) = infcx.eq_types(false, TypeOrigin::Misc(span), t1, t2) {\n+            emit_type_err(infcx.tcx, span, t1, t2, &err, msg);\n+            false\n+        } else {\n+            true\n         }\n-        err = err.note_expected_found(&\"type\", &expected_ty, &found_ty);\n-        ccx.tcx.note_and_explain_type_err(&mut err, terr, span);\n-        err.emit();\n-    }\n-\n-    err.is_none()\n+    })\n }\n \n fn check_main_fn_ty(ccx: &CrateCtxt,\n@@ -258,7 +255,7 @@ fn check_main_fn_ty(ccx: &CrateCtxt,\n                 })\n             }));\n \n-            require_same_types(ccx, None, main_span, main_t, se_ty,\n+            require_same_types(ccx, main_span, main_t, se_ty,\n                                \"main function has wrong type\");\n         }\n         _ => {\n@@ -307,7 +304,7 @@ fn check_start_fn_ty(ccx: &CrateCtxt,\n                 }),\n             }));\n \n-            require_same_types(ccx, None, start_span, start_t, se_ty,\n+            require_same_types(ccx, start_span, start_t, se_ty,\n                                \"start function has wrong type\");\n         }\n         _ => {"}]}