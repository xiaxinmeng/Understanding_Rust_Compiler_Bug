{"sha": "d11936251a93d7395169dfab9088c4dde0cca180", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQxMTkzNjI1MWE5M2Q3Mzk1MTY5ZGZhYjkwODhjNGRkZTBjY2ExODA=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2016-07-08T15:34:36Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2016-07-08T15:34:36Z"}, "message": "Auto merge of #33890 - michaelwoerister:collector-driven-trans, r=eddyb\n\nDrive trans from the output of the translation item collector\n\nThis PR changes the way how translation works above the item level. Instead of walking the HIR and calling `trans_item()` on everything encountered (while instantiating monomorphizations on-demand), we now just process the list of translation items generated by the `trans::collector`. Using the collector has the benefit of being able to know the exact set of monomorphizations and symbols before actually running translation, something that is crucial for incremental compilation (but also has [other benefits](https://github.com/rust-lang/rust/pull/33602)).\n\nThe collector has existed for quite a while now, but so far it's output was only used for running some auto-tests. With this PR it becomes the only source of truth about what gets translated.\n\nOne modification we had to make, compared to the initial approach, is that closures are not represented as their own `TransItems`. Doing so, while still supporting non-MIR-based translation, would have been prohibitively complex, and not worth the trouble since legacy-trans will disappear sooner or later. Once there is solely MIR-trans, it would be a good idea to make closures `TransItems` again.\n\nThis PR removes the most obvious functions and tables that are not needed anymore, but there's definitely still more cleanup possible later on (e.g. `monomorphize::monomorphic_fn()` does very little at this point). Since there are already more than 10 commits in here, doing this in a separate PR seems to be a better idea.\n\nThese changes definitely warrant a crater run.\n\nThanks @Aatch, for taking on one of the more tedious tasks during the dev-sprint!\nThanks @eddyb, for doing some nice refactorings to symbol name generation and making sure these landed so I could use them!\n\ncc @rust-lang/compiler\ncc @rust-lang/tools", "tree": {"sha": "79276667da2f9765e79517ced48f1686351c4b0c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/79276667da2f9765e79517ced48f1686351c4b0c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d11936251a93d7395169dfab9088c4dde0cca180", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d11936251a93d7395169dfab9088c4dde0cca180", "html_url": "https://github.com/rust-lang/rust/commit/d11936251a93d7395169dfab9088c4dde0cca180", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d11936251a93d7395169dfab9088c4dde0cca180/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e7751e436ba4ff05dd844e330ee50afb7123e1fa", "url": "https://api.github.com/repos/rust-lang/rust/commits/e7751e436ba4ff05dd844e330ee50afb7123e1fa", "html_url": "https://github.com/rust-lang/rust/commit/e7751e436ba4ff05dd844e330ee50afb7123e1fa"}, {"sha": "1c03bfe3b43c06bc439c5369a180958eb4360361", "url": "https://api.github.com/repos/rust-lang/rust/commits/1c03bfe3b43c06bc439c5369a180958eb4360361", "html_url": "https://github.com/rust-lang/rust/commit/1c03bfe3b43c06bc439c5369a180958eb4360361"}], "stats": {"total": 2295, "additions": 1389, "deletions": 906}, "files": [{"sha": "5ccc96210be78d7d56cc8b739544ec05a1fce18e", "filename": "src/librustc/session/config.rs", "status": "modified", "additions": 56, "deletions": 9, "changes": 65, "blob_url": "https://github.com/rust-lang/rust/blob/d11936251a93d7395169dfab9088c4dde0cca180/src%2Flibrustc%2Fsession%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d11936251a93d7395169dfab9088c4dde0cca180/src%2Flibrustc%2Fsession%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fsession%2Fconfig.rs?ref=d11936251a93d7395169dfab9088c4dde0cca180", "patch": "@@ -197,23 +197,70 @@ pub struct OutputFilenames {\n     pub outputs: HashMap<OutputType, Option<PathBuf>>,\n }\n \n+/// Codegen unit names generated by the numbered naming scheme will contain this\n+/// marker right before the index of the codegen unit.\n+pub const NUMBERED_CODEGEN_UNIT_MARKER: &'static str = \".cgu-\";\n+\n impl OutputFilenames {\n     pub fn path(&self, flavor: OutputType) -> PathBuf {\n         self.outputs.get(&flavor).and_then(|p| p.to_owned())\n             .or_else(|| self.single_output_file.clone())\n-            .unwrap_or_else(|| self.temp_path(flavor))\n+            .unwrap_or_else(|| self.temp_path(flavor, None))\n     }\n \n-    pub fn temp_path(&self, flavor: OutputType) -> PathBuf {\n+    /// Get the path where a compilation artifact of the given type for the\n+    /// given codegen unit should be placed on disk. If codegen_unit_name is\n+    /// None, a path distinct from those of any codegen unit will be generated.\n+    pub fn temp_path(&self,\n+                     flavor: OutputType,\n+                     codegen_unit_name: Option<&str>)\n+                     -> PathBuf {\n+        let extension = match flavor {\n+            OutputType::Bitcode => \"bc\",\n+            OutputType::Assembly => \"s\",\n+            OutputType::LlvmAssembly => \"ll\",\n+            OutputType::Object => \"o\",\n+            OutputType::DepInfo => \"d\",\n+            OutputType::Exe => \"\",\n+        };\n+\n+        self.temp_path_ext(extension, codegen_unit_name)\n+    }\n+\n+    /// Like temp_path, but also supports things where there is no corresponding\n+    /// OutputType, like no-opt-bitcode or lto-bitcode.\n+    pub fn temp_path_ext(&self,\n+                         ext: &str,\n+                         codegen_unit_name: Option<&str>)\n+                         -> PathBuf {\n         let base = self.out_directory.join(&self.filestem());\n-        match flavor {\n-            OutputType::Bitcode => base.with_extension(\"bc\"),\n-            OutputType::Assembly => base.with_extension(\"s\"),\n-            OutputType::LlvmAssembly => base.with_extension(\"ll\"),\n-            OutputType::Object => base.with_extension(\"o\"),\n-            OutputType::DepInfo => base.with_extension(\"d\"),\n-            OutputType::Exe => base,\n+\n+        let mut extension = String::new();\n+\n+        if let Some(codegen_unit_name) = codegen_unit_name {\n+            if codegen_unit_name.contains(NUMBERED_CODEGEN_UNIT_MARKER) {\n+                // If we use the numbered naming scheme for modules, we don't want\n+                // the files to look like <crate-name><extra>.<crate-name>.<index>.<ext>\n+                // but simply <crate-name><extra>.<index>.<ext>\n+                let marker_offset = codegen_unit_name.rfind(NUMBERED_CODEGEN_UNIT_MARKER)\n+                                                     .unwrap();\n+                let index_offset = marker_offset + NUMBERED_CODEGEN_UNIT_MARKER.len();\n+                extension.push_str(&codegen_unit_name[index_offset .. ]);\n+            } else {\n+                extension.push_str(codegen_unit_name);\n+            };\n+        }\n+\n+        if !ext.is_empty() {\n+            if !extension.is_empty() {\n+                extension.push_str(\".\");\n+            }\n+\n+            extension.push_str(ext);\n         }\n+\n+        let path = base.with_extension(&extension[..]);\n+        path\n     }\n \n     pub fn with_extension(&self, extension: &str) -> PathBuf {"}, {"sha": "eef2b6e6f37b412c0df669583a8ea4bc920e88e5", "filename": "src/librustc_driver/driver.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d11936251a93d7395169dfab9088c4dde0cca180/src%2Flibrustc_driver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d11936251a93d7395169dfab9088c4dde0cca180/src%2Flibrustc_driver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Fdriver.rs?ref=d11936251a93d7395169dfab9088c4dde0cca180", "patch": "@@ -1081,7 +1081,7 @@ pub fn phase_5_run_llvm_passes(sess: &Session,\n \n         // Remove assembly source, unless --save-temps was specified\n         if !sess.opts.cg.save_temps {\n-            fs::remove_file(&outputs.temp_path(OutputType::Assembly)).unwrap();\n+            fs::remove_file(&outputs.temp_path(OutputType::Assembly, None)).unwrap();\n         }\n     } else {\n         time(sess.time_passes(),"}, {"sha": "6c2a09f8060c5a4b36fb87e1701d74bff6f62ed7", "filename": "src/librustc_trans/abi.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/d11936251a93d7395169dfab9088c4dde0cca180/src%2Flibrustc_trans%2Fabi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d11936251a93d7395169dfab9088c4dde0cca180/src%2Flibrustc_trans%2Fabi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fabi.rs?ref=d11936251a93d7395169dfab9088c4dde0cca180", "patch": "@@ -229,6 +229,7 @@ impl ArgType {\n ///\n /// I will do my best to describe this structure, but these\n /// comments are reverse-engineered and may be inaccurate. -NDM\n+#[derive(Clone)]\n pub struct FnType {\n     /// The LLVM types of each argument.\n     pub args: Vec<ArgType>,"}, {"sha": "a9f3d2f8a175485b954c016e6d2e207a7c4084ff", "filename": "src/librustc_trans/back/link.rs", "status": "modified", "additions": 8, "deletions": 7, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/d11936251a93d7395169dfab9088c4dde0cca180/src%2Flibrustc_trans%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d11936251a93d7395169dfab9088c4dde0cca180/src%2Flibrustc_trans%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fback%2Flink.rs?ref=d11936251a93d7395169dfab9088c4dde0cca180", "patch": "@@ -205,7 +205,7 @@ pub fn link_binary(sess: &Session,\n \n     // Remove the temporary object file and metadata if we aren't saving temps\n     if !sess.opts.cg.save_temps {\n-        for obj in object_filenames(sess, outputs) {\n+        for obj in object_filenames(trans, outputs) {\n             remove(sess, &obj);\n         }\n         remove(sess, &outputs.with_extension(\"metadata.o\"));\n@@ -316,7 +316,7 @@ fn link_binary_output(sess: &Session,\n                       crate_type: config::CrateType,\n                       outputs: &OutputFilenames,\n                       crate_name: &str) -> PathBuf {\n-    let objects = object_filenames(sess, outputs);\n+    let objects = object_filenames(trans, outputs);\n     let default_filename = filename_for_input(sess, crate_type, crate_name,\n                                               outputs);\n     let out_filename = outputs.outputs.get(&OutputType::Exe)\n@@ -356,10 +356,11 @@ fn link_binary_output(sess: &Session,\n     out_filename\n }\n \n-fn object_filenames(sess: &Session, outputs: &OutputFilenames) -> Vec<PathBuf> {\n-    (0..sess.opts.cg.codegen_units).map(|i| {\n-        let ext = format!(\"{}.o\", i);\n-        outputs.temp_path(OutputType::Object).with_extension(&ext)\n+fn object_filenames(trans: &CrateTranslation,\n+                    outputs: &OutputFilenames)\n+                    -> Vec<PathBuf> {\n+    trans.modules.iter().map(|module| {\n+        outputs.temp_path(OutputType::Object, Some(&module.name[..]))\n     }).collect()\n }\n \n@@ -497,7 +498,7 @@ fn link_rlib<'a>(sess: &'a Session,\n                 ab.add_file(&bc_deflated_filename);\n \n                 // See the bottom of back::write::run_passes for an explanation\n-                // of when we do and don't keep .0.bc files around.\n+                // of when we do and don't keep .#module-name#.bc files around.\n                 let user_wants_numbered_bitcode =\n                         sess.opts.output_types.contains_key(&OutputType::Bitcode) &&\n                         sess.opts.cg.codegen_units > 1;"}, {"sha": "69e4a50804fadc5ca4c7a5f917ff4452cf3e9987", "filename": "src/librustc_trans/back/lto.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/d11936251a93d7395169dfab9088c4dde0cca180/src%2Flibrustc_trans%2Fback%2Flto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d11936251a93d7395169dfab9088c4dde0cca180/src%2Flibrustc_trans%2Fback%2Flto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fback%2Flto.rs?ref=d11936251a93d7395169dfab9088c4dde0cca180", "patch": "@@ -22,12 +22,12 @@ use libc;\n use flate;\n \n use std::ffi::CString;\n+use std::path::Path;\n \n pub fn run(sess: &session::Session, llmod: ModuleRef,\n            tm: TargetMachineRef, reachable: &[String],\n            config: &ModuleConfig,\n-           name_extra: &str,\n-           output_names: &config::OutputFilenames) {\n+           temp_no_opt_bc_filename: &Path) {\n     if sess.opts.cg.prefer_dynamic {\n         sess.struct_err(\"cannot prefer dynamic linking when performing LTO\")\n             .note(\"only 'staticlib', 'bin', and 'cdylib' outputs are \\\n@@ -132,8 +132,7 @@ pub fn run(sess: &session::Session, llmod: ModuleRef,\n     }\n \n     if sess.opts.cg.save_temps {\n-        let path = output_names.with_extension(&format!(\"{}.no-opt.lto.bc\", name_extra));\n-        let cstr = path2cstr(&path);\n+        let cstr = path2cstr(temp_no_opt_bc_filename);\n         unsafe {\n             llvm::LLVMWriteBitcodeToFile(llmod, cstr.as_ptr());\n         }"}, {"sha": "ebb6e0baf20a00e8c837a18249c5e9853e706caf", "filename": "src/librustc_trans/back/symbol_names.rs", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/d11936251a93d7395169dfab9088c4dde0cca180/src%2Flibrustc_trans%2Fback%2Fsymbol_names.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d11936251a93d7395169dfab9088c4dde0cca180/src%2Flibrustc_trans%2Fback%2Fsymbol_names.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fback%2Fsymbol_names.rs?ref=d11936251a93d7395169dfab9088c4dde0cca180", "patch": "@@ -304,6 +304,19 @@ impl ItemPathBuffer for SymbolPathBuffer {\n     }\n }\n \n+pub fn exported_name_from_type_and_prefix<'a, 'tcx>(scx: &SharedCrateContext<'a, 'tcx>,\n+                                                    t: ty::Ty<'tcx>,\n+                                                    prefix: &str)\n+                                                    -> String {\n+    let empty_def_path = DefPath {\n+        data: vec![],\n+        krate: cstore::LOCAL_CRATE,\n+    };\n+    let hash = get_symbol_hash(scx, &empty_def_path, t, &[]);\n+    let path = [token::intern_and_get_ident(prefix)];\n+    mangle(path.iter().cloned(), Some(&hash[..]))\n+}\n+\n /// Only symbols that are invisible outside their compilation unit should use a\n /// name generated by this function.\n pub fn internal_name_from_type_and_suffix<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,"}, {"sha": "071960f1944cfe941a62467a88f9872b7354e2f0", "filename": "src/librustc_trans/back/write.rs", "status": "modified", "additions": 97, "deletions": 71, "changes": 168, "blob_url": "https://github.com/rust-lang/rust/blob/d11936251a93d7395169dfab9088c4dde0cca180/src%2Flibrustc_trans%2Fback%2Fwrite.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d11936251a93d7395169dfab9088c4dde0cca180/src%2Flibrustc_trans%2Fback%2Fwrite.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fback%2Fwrite.rs?ref=d11936251a93d7395169dfab9088c4dde0cca180", "patch": "@@ -423,9 +423,9 @@ unsafe extern \"C\" fn diagnostic_handler(info: DiagnosticInfoRef, user: *mut c_vo\n unsafe fn optimize_and_codegen(cgcx: &CodegenContext,\n                                mtrans: ModuleTranslation,\n                                config: ModuleConfig,\n-                               name_extra: String,\n                                output_names: OutputFilenames) {\n-    let ModuleTranslation { llmod, llcx } = mtrans;\n+    let llmod = mtrans.llmod;\n+    let llcx = mtrans.llcx;\n     let tm = config.tm;\n \n     // llcx doesn't outlive this function, so we can put this on the stack.\n@@ -438,9 +438,10 @@ unsafe fn optimize_and_codegen(cgcx: &CodegenContext,\n     llvm::LLVMSetInlineAsmDiagnosticHandler(llcx, inline_asm_handler, fv);\n     llvm::LLVMContextSetDiagnosticHandler(llcx, diagnostic_handler, fv);\n \n+    let module_name = Some(&mtrans.name[..]);\n+\n     if config.emit_no_opt_bc {\n-        let ext = format!(\"{}.no-opt.bc\", name_extra);\n-        let out = output_names.with_extension(&ext);\n+        let out = output_names.temp_path_ext(\"no-opt.bc\", module_name);\n         let out = path2cstr(&out);\n         llvm::LLVMWriteBitcodeToFile(llmod, out.as_ptr());\n     }\n@@ -512,13 +513,18 @@ unsafe fn optimize_and_codegen(cgcx: &CodegenContext,\n \n         match cgcx.lto_ctxt {\n             Some((sess, reachable)) if sess.lto() =>  {\n-                time(sess.time_passes(), \"all lto passes\", ||\n-                     lto::run(sess, llmod, tm, reachable, &config,\n-                              &name_extra, &output_names));\n-\n+                time(sess.time_passes(), \"all lto passes\", || {\n+                    let temp_no_opt_bc_filename =\n+                        output_names.temp_path_ext(\"no-opt.lto.bc\", module_name);\n+                    lto::run(sess,\n+                             llmod,\n+                             tm,\n+                             reachable,\n+                             &config,\n+                             &temp_no_opt_bc_filename);\n+                });\n                 if config.emit_lto_bc {\n-                    let name = format!(\"{}.lto.bc\", name_extra);\n-                    let out = output_names.with_extension(&name);\n+                    let out = output_names.temp_path_ext(\"lto.bc\", module_name);\n                     let out = path2cstr(&out);\n                     llvm::LLVMWriteBitcodeToFile(llmod, out.as_ptr());\n                 }\n@@ -556,8 +562,8 @@ unsafe fn optimize_and_codegen(cgcx: &CodegenContext,\n     let write_obj = config.emit_obj && !config.obj_is_bitcode;\n     let copy_bc_to_obj = config.emit_obj && config.obj_is_bitcode;\n \n-    let bc_out = output_names.with_extension(&format!(\"{}.bc\", name_extra));\n-    let obj_out = output_names.with_extension(&format!(\"{}.o\", name_extra));\n+    let bc_out = output_names.temp_path(OutputType::Bitcode, module_name);\n+    let obj_out = output_names.temp_path(OutputType::Object, module_name);\n \n     if write_bc {\n         let bc_out_c = path2cstr(&bc_out);\n@@ -566,8 +572,7 @@ unsafe fn optimize_and_codegen(cgcx: &CodegenContext,\n \n     time(config.time_passes, &format!(\"codegen passes [{}]\", cgcx.worker), || {\n         if config.emit_ir {\n-            let ext = format!(\"{}.ll\", name_extra);\n-            let out = output_names.with_extension(&ext);\n+            let out = output_names.temp_path(OutputType::LlvmAssembly, module_name);\n             let out = path2cstr(&out);\n             with_codegen(tm, llmod, config.no_builtins, |cpm| {\n                 llvm::LLVMRustPrintModule(cpm, llmod, out.as_ptr());\n@@ -576,7 +581,7 @@ unsafe fn optimize_and_codegen(cgcx: &CodegenContext,\n         }\n \n         if config.emit_asm {\n-            let path = output_names.with_extension(&format!(\"{}.s\", name_extra));\n+            let path = output_names.temp_path(OutputType::Assembly, module_name);\n \n             // We can't use the same module for asm and binary output, because that triggers\n             // various errors like invalid IR or broken binaries, so we might have to clone the\n@@ -713,27 +718,29 @@ pub fn run_passes(sess: &Session,\n \n     {\n         let work = build_work_item(sess,\n-                                   trans.metadata_module,\n+                                   trans.metadata_module.clone(),\n                                    metadata_config.clone(),\n-                                   crate_output.clone(),\n-                                   \"metadata\".to_string());\n+                                   crate_output.clone());\n         work_items.push(work);\n     }\n \n-    for (index, mtrans) in trans.modules.iter().enumerate() {\n+    for mtrans in trans.modules.iter() {\n         let work = build_work_item(sess,\n-                                   *mtrans,\n+                                   mtrans.clone(),\n                                    modules_config.clone(),\n-                                   crate_output.clone(),\n-                                   format!(\"{}\", index));\n+                                   crate_output.clone());\n         work_items.push(work);\n     }\n \n     // Process the work items, optionally using worker threads.\n-    if sess.opts.cg.codegen_units == 1 {\n+    // NOTE: This code is not really adapted to incremental compilation where\n+    //       the compiler decides the number of codegen units (and will\n+    //       potentially create hundreds of them).\n+    let num_workers = work_items.len() - 1;\n+    if num_workers == 1 {\n         run_work_singlethreaded(sess, &trans.reachable, work_items);\n     } else {\n-        run_work_multithreaded(sess, work_items, sess.opts.cg.codegen_units);\n+        run_work_multithreaded(sess, work_items, num_workers);\n     }\n \n     // All codegen is finished.\n@@ -748,32 +755,42 @@ pub fn run_passes(sess: &Session,\n         }\n     };\n \n-    let copy_if_one_unit = |ext: &str,\n-                            output_type: OutputType,\n+    let copy_if_one_unit = |output_type: OutputType,\n                             keep_numbered: bool| {\n-        if sess.opts.cg.codegen_units == 1 {\n+        if trans.modules.len() == 1 {\n             // 1) Only one codegen unit.  In this case it's no difficulty\n             //    to copy `foo.0.x` to `foo.x`.\n-            copy_gracefully(&crate_output.with_extension(ext),\n+            let module_name = Some(&(trans.modules[0].name)[..]);\n+            let path = crate_output.temp_path(output_type, module_name);\n+            copy_gracefully(&path,\n                             &crate_output.path(output_type));\n             if !sess.opts.cg.save_temps && !keep_numbered {\n-                // The user just wants `foo.x`, not `foo.0.x`.\n-                remove(sess, &crate_output.with_extension(ext));\n+                // The user just wants `foo.x`, not `foo.#module-name#.x`.\n+                remove(sess, &path);\n             }\n-        } else if crate_output.outputs.contains_key(&output_type) {\n-            // 2) Multiple codegen units, with `--emit foo=some_name`.  We have\n-            //    no good solution for this case, so warn the user.\n-            sess.warn(&format!(\"ignoring emit path because multiple .{} files \\\n-                                were produced\", ext));\n-        } else if crate_output.single_output_file.is_some() {\n-            // 3) Multiple codegen units, with `-o some_name`.  We have\n-            //    no good solution for this case, so warn the user.\n-            sess.warn(&format!(\"ignoring -o because multiple .{} files \\\n-                                were produced\", ext));\n         } else {\n-            // 4) Multiple codegen units, but no explicit name.  We\n-            //    just leave the `foo.0.x` files in place.\n-            // (We don't have to do any work in this case.)\n+            let ext = crate_output.temp_path(output_type, None)\n+                                  .extension()\n+                                  .unwrap()\n+                                  .to_str()\n+                                  .unwrap()\n+                                  .to_owned();\n+\n+            if crate_output.outputs.contains_key(&output_type) {\n+                // 2) Multiple codegen units, with `--emit foo=some_name`.  We have\n+                //    no good solution for this case, so warn the user.\n+                sess.warn(&format!(\"ignoring emit path because multiple .{} files \\\n+                                    were produced\", ext));\n+            } else if crate_output.single_output_file.is_some() {\n+                // 3) Multiple codegen units, with `-o some_name`.  We have\n+                //    no good solution for this case, so warn the user.\n+                sess.warn(&format!(\"ignoring -o because multiple .{} files \\\n+                                    were produced\", ext));\n+            } else {\n+                // 4) Multiple codegen units, but no explicit name.  We\n+                //    just leave the `foo.0.x` files in place.\n+                // (We don't have to do any work in this case.)\n+            }\n         }\n     };\n \n@@ -789,17 +806,17 @@ pub fn run_passes(sess: &Session,\n                 // Copy to .bc, but always keep the .0.bc.  There is a later\n                 // check to figure out if we should delete .0.bc files, or keep\n                 // them for making an rlib.\n-                copy_if_one_unit(\"0.bc\", OutputType::Bitcode, true);\n+                copy_if_one_unit(OutputType::Bitcode, true);\n             }\n             OutputType::LlvmAssembly => {\n-                copy_if_one_unit(\"0.ll\", OutputType::LlvmAssembly, false);\n+                copy_if_one_unit(OutputType::LlvmAssembly, false);\n             }\n             OutputType::Assembly => {\n-                copy_if_one_unit(\"0.s\", OutputType::Assembly, false);\n+                copy_if_one_unit(OutputType::Assembly, false);\n             }\n             OutputType::Object => {\n                 user_wants_objects = true;\n-                copy_if_one_unit(\"0.o\", OutputType::Object, true);\n+                copy_if_one_unit(OutputType::Object, true);\n             }\n             OutputType::Exe |\n             OutputType::DepInfo => {}\n@@ -810,51 +827,55 @@ pub fn run_passes(sess: &Session,\n     // Clean up unwanted temporary files.\n \n     // We create the following files by default:\n-    //  - crate.0.bc\n-    //  - crate.0.o\n+    //  - crate.#module-name#.bc\n+    //  - crate.#module-name#.o\n     //  - crate.metadata.bc\n     //  - crate.metadata.o\n     //  - crate.o (linked from crate.##.o)\n-    //  - crate.bc (copied from crate.0.bc)\n+    //  - crate.bc (copied from crate.##.bc)\n     // We may create additional files if requested by the user (through\n     // `-C save-temps` or `--emit=` flags).\n \n     if !sess.opts.cg.save_temps {\n-        // Remove the temporary .0.o objects.  If the user didn't\n+        // Remove the temporary .#module-name#.o objects.  If the user didn't\n         // explicitly request bitcode (with --emit=bc), and the bitcode is not\n-        // needed for building an rlib, then we must remove .0.bc as well.\n+        // needed for building an rlib, then we must remove .#module-name#.bc as\n+        // well.\n \n-        // Specific rules for keeping .0.bc:\n+        // Specific rules for keeping .#module-name#.bc:\n         //  - If we're building an rlib (`needs_crate_bitcode`), then keep\n         //    it.\n         //  - If the user requested bitcode (`user_wants_bitcode`), and\n         //    codegen_units > 1, then keep it.\n         //  - If the user requested bitcode but codegen_units == 1, then we\n-        //    can toss .0.bc because we copied it to .bc earlier.\n+        //    can toss .#module-name#.bc because we copied it to .bc earlier.\n         //  - If we're not building an rlib and the user didn't request\n-        //    bitcode, then delete .0.bc.\n+        //    bitcode, then delete .#module-name#.bc.\n         // If you change how this works, also update back::link::link_rlib,\n-        // where .0.bc files are (maybe) deleted after making an rlib.\n+        // where .#module-name#.bc files are (maybe) deleted after making an\n+        // rlib.\n         let keep_numbered_bitcode = needs_crate_bitcode ||\n                 (user_wants_bitcode && sess.opts.cg.codegen_units > 1);\n \n         let keep_numbered_objects = needs_crate_object ||\n                 (user_wants_objects && sess.opts.cg.codegen_units > 1);\n \n-        for i in 0..trans.modules.len() {\n+        for module_name in trans.modules.iter().map(|m| Some(&m.name[..])) {\n             if modules_config.emit_obj && !keep_numbered_objects {\n-                let ext = format!(\"{}.o\", i);\n-                remove(sess, &crate_output.with_extension(&ext));\n+                let path = crate_output.temp_path(OutputType::Object, module_name);\n+                remove(sess, &path);\n             }\n \n             if modules_config.emit_bc && !keep_numbered_bitcode {\n-                let ext = format!(\"{}.bc\", i);\n-                remove(sess, &crate_output.with_extension(&ext));\n+                let path = crate_output.temp_path(OutputType::Bitcode, module_name);\n+                remove(sess, &path);\n             }\n         }\n \n         if metadata_config.emit_bc && !user_wants_bitcode {\n-            remove(sess, &crate_output.with_extension(\"metadata.bc\"));\n+            let path = crate_output.temp_path(OutputType::Bitcode,\n+                                              Some(&trans.metadata_module.name[..]));\n+            remove(sess, &path);\n         }\n     }\n \n@@ -874,28 +895,31 @@ pub fn run_passes(sess: &Session,\n struct WorkItem {\n     mtrans: ModuleTranslation,\n     config: ModuleConfig,\n-    output_names: OutputFilenames,\n-    name_extra: String\n+    output_names: OutputFilenames\n }\n \n fn build_work_item(sess: &Session,\n                    mtrans: ModuleTranslation,\n                    config: ModuleConfig,\n-                   output_names: OutputFilenames,\n-                   name_extra: String)\n+                   output_names: OutputFilenames)\n                    -> WorkItem\n {\n     let mut config = config;\n     config.tm = create_target_machine(sess);\n-    WorkItem { mtrans: mtrans, config: config, output_names: output_names,\n-               name_extra: name_extra }\n+    WorkItem {\n+        mtrans: mtrans,\n+        config: config,\n+        output_names: output_names\n+    }\n }\n \n fn execute_work_item(cgcx: &CodegenContext,\n                      work_item: WorkItem) {\n     unsafe {\n-        optimize_and_codegen(cgcx, work_item.mtrans, work_item.config,\n-                             work_item.name_extra, work_item.output_names);\n+        optimize_and_codegen(cgcx,\n+                             work_item.mtrans,\n+                             work_item.config,\n+                             work_item.output_names);\n     }\n }\n \n@@ -914,6 +938,8 @@ fn run_work_singlethreaded(sess: &Session,\n fn run_work_multithreaded(sess: &Session,\n                           work_items: Vec<WorkItem>,\n                           num_workers: usize) {\n+    assert!(num_workers > 0);\n+\n     // Run some workers to process the work items.\n     let work_items_arc = Arc::new(Mutex::new(work_items));\n     let mut diag_emitter = SharedEmitter::new();\n@@ -981,7 +1007,7 @@ pub fn run_assembler(sess: &Session, outputs: &OutputFilenames) {\n     let (pname, mut cmd, _) = get_linker(sess);\n \n     cmd.arg(\"-c\").arg(\"-o\").arg(&outputs.path(OutputType::Object))\n-                           .arg(&outputs.temp_path(OutputType::Assembly));\n+                           .arg(&outputs.temp_path(OutputType::Assembly, None));\n     debug!(\"{:?}\", cmd);\n \n     match cmd.output() {"}, {"sha": "c080d1f06d00f2a0d9a5bdc1d2f0f817f059d546", "filename": "src/librustc_trans/base.rs", "status": "modified", "additions": 210, "deletions": 257, "changes": 467, "blob_url": "https://github.com/rust-lang/rust/blob/d11936251a93d7395169dfab9088c4dde0cca180/src%2Flibrustc_trans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d11936251a93d7395169dfab9088c4dde0cca180/src%2Flibrustc_trans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fbase.rs?ref=d11936251a93d7395169dfab9088c4dde0cca180", "patch": "@@ -25,8 +25,6 @@\n \n #![allow(non_camel_case_types)]\n \n-pub use self::ValueOrigin::*;\n-\n use super::CrateTranslation;\n use super::ModuleTranslation;\n \n@@ -60,7 +58,7 @@ use callee::{Callee, CallArgs, ArgExprs, ArgVals};\n use cleanup::{self, CleanupMethods, DropHint};\n use closure;\n use common::{Block, C_bool, C_bytes_in_context, C_i32, C_int, C_uint, C_integral};\n-use collector::{self, TransItemState, TransItemCollectionMode};\n+use collector::{self, TransItemCollectionMode};\n use common::{C_null, C_struct_in_context, C_u64, C_u8, C_undef};\n use common::{CrateContext, DropFlagHintsMap, Field, FunctionContext};\n use common::{Result, NodeIdAndSpan, VariantInfo};\n@@ -75,12 +73,14 @@ use debuginfo::{self, DebugLoc, ToDebugLoc};\n use declare;\n use expr;\n use glue;\n+use inline;\n use machine;\n use machine::{llalign_of_min, llsize_of, llsize_of_real};\n use meth;\n use mir;\n use monomorphize::{self, Instance};\n use partitioning::{self, PartitioningStrategy, CodegenUnit};\n+use symbol_map::SymbolMap;\n use symbol_names_test;\n use trans_item::TransItem;\n use tvec;\n@@ -98,6 +98,7 @@ use libc::c_uint;\n use std::ffi::{CStr, CString};\n use std::cell::{Cell, RefCell};\n use std::collections::{HashMap, HashSet};\n+use std::rc::Rc;\n use std::str;\n use std::{i8, i16, i32, i64};\n use syntax_pos::{Span, DUMMY_SP};\n@@ -1829,10 +1830,6 @@ pub fn trans_closure<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n                                closure_env: closure::ClosureEnv) {\n     ccx.stats().n_closures.set(ccx.stats().n_closures.get() + 1);\n \n-    if collector::collecting_debug_information(ccx.shared()) {\n-        ccx.record_translation_item_as_generated(TransItem::Fn(instance));\n-    }\n-\n     let _icx = push_ctxt(\"trans_closure\");\n     if !ccx.sess().no_landing_pads() {\n         attributes::emit_uwtable(llfndecl, true);\n@@ -1917,35 +1914,47 @@ pub fn trans_closure<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n     fcx.finish(bcx, fn_cleanup_debug_loc.debug_loc());\n }\n \n-/// Creates an LLVM function corresponding to a source language function.\n-pub fn trans_fn<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n-                          decl: &hir::FnDecl,\n-                          body: &hir::Block,\n-                          llfndecl: ValueRef,\n-                          param_substs: &'tcx Substs<'tcx>,\n-                          id: ast::NodeId) {\n-    let _s = StatRecorder::new(ccx, ccx.tcx().node_path_str(id));\n-    debug!(\"trans_fn(param_substs={:?})\", param_substs);\n-    let _icx = push_ctxt(\"trans_fn\");\n-    let def_id = if let Some(&def_id) = ccx.external_srcs().borrow().get(&id) {\n-        def_id\n-    } else {\n-        ccx.tcx().map.local_def_id(id)\n-    };\n-    let fn_ty = ccx.tcx().lookup_item_type(def_id).ty;\n-    let fn_ty = monomorphize::apply_param_substs(ccx.tcx(), param_substs, &fn_ty);\n+pub fn trans_instance<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, instance: Instance<'tcx>) {\n+    let instance = inline::maybe_inline_instance(ccx, instance);\n+\n+    let fn_node_id = ccx.tcx().map.as_local_node_id(instance.def).unwrap();\n+\n+    let _s = StatRecorder::new(ccx, ccx.tcx().node_path_str(fn_node_id));\n+    debug!(\"trans_instance(instance={:?})\", instance);\n+    let _icx = push_ctxt(\"trans_instance\");\n+\n+    let item = ccx.tcx().map.find(fn_node_id).unwrap();\n+\n+    let fn_ty = ccx.tcx().lookup_item_type(instance.def).ty;\n+    let fn_ty = ccx.tcx().erase_regions(&fn_ty);\n+    let fn_ty = monomorphize::apply_param_substs(ccx.tcx(), instance.substs, &fn_ty);\n+\n     let sig = ccx.tcx().erase_late_bound_regions(fn_ty.fn_sig());\n     let sig = ccx.tcx().normalize_associated_type(&sig);\n     let abi = fn_ty.fn_abi();\n-    trans_closure(ccx,\n-                  decl,\n-                  body,\n-                  llfndecl,\n-                  Instance::new(def_id, param_substs),\n-                  id,\n-                  &sig,\n-                  abi,\n-                  closure::ClosureEnv::NotClosure);\n+\n+    let lldecl = match ccx.instances().borrow().get(&instance) {\n+        Some(&val) => val,\n+        None => bug!(\"Instance `{:?}` not already declared\", instance)\n+    };\n+\n+    match item {\n+        hir_map::NodeItem(&hir::Item {\n+            node: hir::ItemFn(ref decl, _, _, _, _, ref body), ..\n+        }) |\n+        hir_map::NodeTraitItem(&hir::TraitItem {\n+            node: hir::MethodTraitItem(\n+                hir::MethodSig { ref decl, .. }, Some(ref body)), ..\n+        }) |\n+        hir_map::NodeImplItem(&hir::ImplItem {\n+            node: hir::ImplItemKind::Method(\n+                hir::MethodSig { ref decl, .. }, ref body), ..\n+        }) => {\n+            trans_closure(ccx, decl, body, lldecl, instance,\n+                          fn_node_id, &sig, abi, closure::ClosureEnv::NotClosure);\n+        }\n+        _ => bug!(\"Instance is a {:?}?\", item)\n+    }\n }\n \n pub fn trans_named_tuple_constructor<'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n@@ -2171,86 +2180,10 @@ pub fn llvm_linkage_by_name(name: &str) -> Option<Linkage> {\n     }\n }\n \n-\n-/// Enum describing the origin of an LLVM `Value`, for linkage purposes.\n-#[derive(Copy, Clone)]\n-pub enum ValueOrigin {\n-    /// The LLVM `Value` is in this context because the corresponding item was\n-    /// assigned to the current compilation unit.\n-    OriginalTranslation,\n-    /// The `Value`'s corresponding item was assigned to some other compilation\n-    /// unit, but the `Value` was translated in this context anyway because the\n-    /// item is marked `#[inline]`.\n-    InlinedCopy,\n-}\n-\n-/// Set the appropriate linkage for an LLVM `ValueRef` (function or global).\n-/// If the `llval` is the direct translation of a specific Rust item, `id`\n-/// should be set to the `NodeId` of that item.  (This mapping should be\n-/// 1-to-1, so monomorphizations and drop/visit glue should have `id` set to\n-/// `None`.)  `llval_origin` indicates whether `llval` is the translation of an\n-/// item assigned to `ccx`'s compilation unit or an inlined copy of an item\n-/// assigned to a different compilation unit.\n-pub fn update_linkage(ccx: &CrateContext,\n-                      llval: ValueRef,\n-                      id: Option<ast::NodeId>,\n-                      llval_origin: ValueOrigin) {\n-    match llval_origin {\n-        InlinedCopy => {\n-            // `llval` is a translation of an item defined in a separate\n-            // compilation unit.  This only makes sense if there are at least\n-            // two compilation units.\n-            assert!(ccx.sess().opts.cg.codegen_units > 1 ||\n-                    ccx.sess().opts.debugging_opts.incremental.is_some());\n-            // `llval` is a copy of something defined elsewhere, so use\n-            // `AvailableExternallyLinkage` to avoid duplicating code in the\n-            // output.\n-            llvm::SetLinkage(llval, llvm::AvailableExternallyLinkage);\n-            return;\n-        },\n-        OriginalTranslation => {},\n-    }\n-\n-    if let Some(id) = id {\n-        let item = ccx.tcx().map.get(id);\n-        if let hir_map::NodeItem(i) = item {\n-            if let Some(name) = attr::first_attr_value_str_by_name(&i.attrs, \"linkage\") {\n-                if let Some(linkage) = llvm_linkage_by_name(&name) {\n-                    llvm::SetLinkage(llval, linkage);\n-                } else {\n-                    ccx.sess().span_fatal(i.span, \"invalid linkage specified\");\n-                }\n-                return;\n-            }\n-        }\n-    }\n-\n-    let (is_reachable, is_generic) = if let Some(id) = id {\n-        (ccx.reachable().contains(&id), false)\n-    } else {\n-        (false, true)\n-    };\n-\n-    // We need external linkage for items reachable from other translation units, this include\n-    // other codegen units in case of parallel compilations.\n-    if is_reachable || ccx.sess().opts.cg.codegen_units > 1 {\n-        if is_generic {\n-            // This only happens with multiple codegen units, in which case we need to use weak_odr\n-            // linkage because other crates might expose the same symbol. We cannot use\n-            // linkonce_odr here because the symbol might then get dropped before the other codegen\n-            // units get to link it.\n-            llvm::SetUniqueComdat(ccx.llmod(), llval);\n-            llvm::SetLinkage(llval, llvm::WeakODRLinkage);\n-        } else {\n-            llvm::SetLinkage(llval, llvm::ExternalLinkage);\n-        }\n-    } else {\n-        llvm::SetLinkage(llval, llvm::InternalLinkage);\n-    }\n-}\n-\n-fn set_global_section(ccx: &CrateContext, llval: ValueRef, i: &hir::Item) {\n-    if let Some(sect) = attr::first_attr_value_str_by_name(&i.attrs, \"link_section\") {\n+pub fn set_link_section(ccx: &CrateContext,\n+                        llval: ValueRef,\n+                        attrs: &[ast::Attribute]) {\n+    if let Some(sect) = attr::first_attr_value_str_by_name(attrs, \"link_section\") {\n         if contains_null(&sect) {\n             ccx.sess().fatal(&format!(\"Illegal null byte in link_section value: `{}`\", &sect));\n         }\n@@ -2261,109 +2194,60 @@ fn set_global_section(ccx: &CrateContext, llval: ValueRef, i: &hir::Item) {\n     }\n }\n \n-pub fn trans_item(ccx: &CrateContext, item: &hir::Item) {\n+fn trans_item(ccx: &CrateContext, item: &hir::Item) {\n     let _icx = push_ctxt(\"trans_item\");\n \n-    let tcx = ccx.tcx();\n-    let from_external = ccx.external_srcs().borrow().contains_key(&item.id);\n-\n     match item.node {\n-        hir::ItemFn(ref decl, _, _, _, ref generics, ref body) => {\n-            if !generics.is_type_parameterized() {\n-                let trans_everywhere = attr::requests_inline(&item.attrs);\n-                // Ignore `trans_everywhere` for cross-crate inlined items\n-                // (`from_external`).  `trans_item` will be called once for each\n-                // compilation unit that references the item, so it will still get\n-                // translated everywhere it's needed.\n-                for (ref ccx, is_origin) in ccx.maybe_iter(!from_external && trans_everywhere) {\n-                    let def_id = tcx.map.local_def_id(item.id);\n-                    let empty_substs = ccx.empty_substs_for_def_id(def_id);\n-                    let llfn = Callee::def(ccx, def_id, empty_substs).reify(ccx).val;\n-                    trans_fn(ccx, &decl, &body, llfn, empty_substs, item.id);\n-                    set_global_section(ccx, llfn, item);\n-                    update_linkage(ccx,\n-                                   llfn,\n-                                   Some(item.id),\n-                                   if is_origin {\n-                                       OriginalTranslation\n-                                   } else {\n-                                       InlinedCopy\n-                                   });\n-\n-                    if is_entry_fn(ccx.sess(), item.id) {\n-                        create_entry_wrapper(ccx, item.span, llfn);\n-                        // check for the #[rustc_error] annotation, which forces an\n-                        // error in trans. This is used to write compile-fail tests\n-                        // that actually test that compilation succeeds without\n-                        // reporting an error.\n-                        if tcx.has_attr(def_id, \"rustc_error\") {\n-                            tcx.sess.span_fatal(item.span, \"compilation successful\");\n-                        }\n-                    }\n-                }\n-            }\n-        }\n-        hir::ItemImpl(_, _, ref generics, _, _, ref impl_items) => {\n-            // Both here and below with generic methods, be sure to recurse and look for\n-            // items that we need to translate.\n-            if !generics.ty_params.is_empty() {\n-                return;\n-            }\n-\n-            for impl_item in impl_items {\n-                if let hir::ImplItemKind::Method(ref sig, ref body) = impl_item.node {\n-                    if sig.generics.ty_params.is_empty() {\n-                        let trans_everywhere = attr::requests_inline(&impl_item.attrs);\n-                        for (ref ccx, is_origin) in ccx.maybe_iter(trans_everywhere) {\n-                            let def_id = tcx.map.local_def_id(impl_item.id);\n-                            let empty_substs = ccx.empty_substs_for_def_id(def_id);\n-                            let llfn = Callee::def(ccx, def_id, empty_substs).reify(ccx).val;\n-                            trans_fn(ccx, &sig.decl, body, llfn, empty_substs, impl_item.id);\n-                            update_linkage(ccx, llfn, Some(impl_item.id),\n-                                if is_origin {\n-                                    OriginalTranslation\n-                                } else {\n-                                    InlinedCopy\n-                                });\n-                        }\n-                    }\n-                }\n-            }\n-        }\n         hir::ItemEnum(ref enum_definition, ref gens) => {\n             if gens.ty_params.is_empty() {\n                 // sizes only make sense for non-generic types\n                 enum_variant_size_lint(ccx, enum_definition, item.span, item.id);\n             }\n         }\n-        hir::ItemStatic(_, m, ref expr) => {\n-            let g = match consts::trans_static(ccx, m, expr, item.id, &item.attrs) {\n-                Ok(g) => g,\n-                Err(err) => ccx.tcx().sess.span_fatal(expr.span, &err.description()),\n-            };\n-            set_global_section(ccx, g, item);\n-            update_linkage(ccx, g, Some(item.id), OriginalTranslation);\n+        hir::ItemFn(..) |\n+        hir::ItemImpl(..) |\n+        hir::ItemStatic(..) => {\n+            // Don't do anything here. Translation has been moved to\n+            // being \"collector-driven\".\n         }\n         _ => {}\n     }\n }\n \n-pub fn is_entry_fn(sess: &Session, node_id: ast::NodeId) -> bool {\n-    match *sess.entry_fn.borrow() {\n-        Some((entry_id, _)) => node_id == entry_id,\n-        None => false,\n+/// Create the `main` function which will initialise the rust runtime and call\n+/// users\u2019 main function.\n+pub fn maybe_create_entry_wrapper(ccx: &CrateContext) {\n+    let (main_def_id, span) = match *ccx.sess().entry_fn.borrow() {\n+        Some((id, span)) => {\n+            (ccx.tcx().map.local_def_id(id), span)\n+        }\n+        None => return,\n+    };\n+\n+    // check for the #[rustc_error] annotation, which forces an\n+    // error in trans. This is used to write compile-fail tests\n+    // that actually test that compilation succeeds without\n+    // reporting an error.\n+    if ccx.tcx().has_attr(main_def_id, \"rustc_error\") {\n+        ccx.tcx().sess.span_fatal(span, \"compilation successful\");\n+    }\n+\n+    let instance = Instance::mono(ccx.shared(), main_def_id);\n+\n+    if !ccx.codegen_unit().items.contains_key(&TransItem::Fn(instance)) {\n+        // We want to create the wrapper in the same codegen unit as Rust's main\n+        // function.\n+        return;\n     }\n-}\n \n-/// Create the `main` function which will initialise the rust runtime and call users\u2019 main\n-/// function.\n-pub fn create_entry_wrapper(ccx: &CrateContext, sp: Span, main_llfn: ValueRef) {\n+    let main_llfn = Callee::def(ccx, main_def_id, instance.substs).reify(ccx).val;\n+\n     let et = ccx.sess().entry_type.get().unwrap();\n     match et {\n         config::EntryMain => {\n-            create_entry_fn(ccx, sp, main_llfn, true);\n+            create_entry_fn(ccx, span, main_llfn, true);\n         }\n-        config::EntryStart => create_entry_fn(ccx, sp, main_llfn, false),\n+        config::EntryStart => create_entry_fn(ccx, span, main_llfn, false),\n         config::EntryNone => {}    // Do nothing.\n     }\n \n@@ -2484,16 +2368,16 @@ fn internalize_symbols(cx: &CrateContextList, reachable: &HashSet<&str>) {\n                 let linkage = llvm::LLVMGetLinkage(val);\n                 // We only care about external declarations (not definitions)\n                 // and available_externally definitions.\n-                if !(linkage == llvm::ExternalLinkage as c_uint &&\n-                     llvm::LLVMIsDeclaration(val) != 0) &&\n-                   !(linkage == llvm::AvailableExternallyLinkage as c_uint) {\n-                    continue;\n+                let is_available_externally = linkage == llvm::AvailableExternallyLinkage as c_uint;\n+                let is_decl = llvm::LLVMIsDeclaration(val) != 0;\n+\n+                if is_decl || is_available_externally {\n+                    let name = CStr::from_ptr(llvm::LLVMGetValueName(val))\n+                        .to_bytes()\n+                        .to_vec();\n+                    declared.insert(name);\n                 }\n \n-                let name = CStr::from_ptr(llvm::LLVMGetValueName(val))\n-                               .to_bytes()\n-                               .to_vec();\n-                declared.insert(name);\n             }\n         }\n \n@@ -2503,21 +2387,27 @@ fn internalize_symbols(cx: &CrateContextList, reachable: &HashSet<&str>) {\n         for ccx in cx.iter() {\n             for val in iter_globals(ccx.llmod()).chain(iter_functions(ccx.llmod())) {\n                 let linkage = llvm::LLVMGetLinkage(val);\n+\n+                let is_external = linkage == llvm::ExternalLinkage as c_uint;\n+                let is_weak_odr = linkage == llvm::WeakODRLinkage as c_uint;\n+                let is_decl = llvm::LLVMIsDeclaration(val) != 0;\n+\n                 // We only care about external definitions.\n-                if !((linkage == llvm::ExternalLinkage as c_uint ||\n-                      linkage == llvm::WeakODRLinkage as c_uint) &&\n-                     llvm::LLVMIsDeclaration(val) == 0) {\n-                    continue;\n-                }\n+                if (is_external || is_weak_odr) && !is_decl {\n+\n+                    let name = CStr::from_ptr(llvm::LLVMGetValueName(val))\n+                                .to_bytes()\n+                                .to_vec();\n+\n+                    let is_declared = declared.contains(&name);\n+                    let reachable = reachable.contains(str::from_utf8(&name).unwrap());\n+\n+                    if !is_declared && !reachable {\n+                        llvm::SetLinkage(val, llvm::InternalLinkage);\n+                        llvm::SetDLLStorageClass(val, llvm::DefaultStorageClass);\n+                        llvm::UnsetComdat(val);\n+                    }\n \n-                let name = CStr::from_ptr(llvm::LLVMGetValueName(val))\n-                               .to_bytes()\n-                               .to_vec();\n-                if !declared.contains(&name) &&\n-                   !reachable.contains(str::from_utf8(&name).unwrap()) {\n-                    llvm::SetLinkage(val, llvm::InternalLinkage);\n-                    llvm::SetDLLStorageClass(val, llvm::DefaultStorageClass);\n-                    llvm::UnsetComdat(val);\n                 }\n             }\n         }\n@@ -2611,8 +2501,8 @@ fn iter_functions(llmod: llvm::ModuleRef) -> ValueIter {\n ///\n /// This list is later used by linkers to determine the set of symbols needed to\n /// be exposed from a dynamic library and it's also encoded into the metadata.\n-pub fn filter_reachable_ids(scx: &SharedCrateContext) -> NodeSet {\n-    scx.reachable().iter().map(|x| *x).filter(|&id| {\n+pub fn filter_reachable_ids(tcx: TyCtxt, reachable: NodeSet) -> NodeSet {\n+    reachable.into_iter().filter(|&id| {\n         // Next, we want to ignore some FFI functions that are not exposed from\n         // this crate. Reachable FFI functions can be lumped into two\n         // categories:\n@@ -2626,9 +2516,9 @@ pub fn filter_reachable_ids(scx: &SharedCrateContext) -> NodeSet {\n         //\n         // As a result, if this id is an FFI item (foreign item) then we only\n         // let it through if it's included statically.\n-        match scx.tcx().map.get(id) {\n+        match tcx.map.get(id) {\n             hir_map::NodeForeignItem(..) => {\n-                scx.sess().cstore.is_statically_included_foreign_item(id)\n+                tcx.sess.cstore.is_statically_included_foreign_item(id)\n             }\n \n             // Only consider nodes that actually have exported symbols.\n@@ -2638,8 +2528,8 @@ pub fn filter_reachable_ids(scx: &SharedCrateContext) -> NodeSet {\n                 node: hir::ItemFn(..), .. }) |\n             hir_map::NodeImplItem(&hir::ImplItem {\n                 node: hir::ImplItemKind::Method(..), .. }) => {\n-                let def_id = scx.tcx().map.local_def_id(id);\n-                let scheme = scx.tcx().lookup_item_type(def_id);\n+                let def_id = tcx.map.local_def_id(id);\n+                let scheme = tcx.lookup_item_type(def_id);\n                 scheme.generics.types.is_empty()\n             }\n \n@@ -2661,6 +2551,7 @@ pub fn trans_crate<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     let krate = tcx.map.krate();\n \n     let ty::CrateAnalysis { export_map, reachable, name, .. } = analysis;\n+    let reachable = filter_reachable_ids(tcx, reachable);\n \n     let check_overflow = if let Some(v) = tcx.sess.opts.debugging_opts.force_overflow_checks {\n         v\n@@ -2684,29 +2575,34 @@ pub fn trans_crate<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                                              reachable,\n                                              check_overflow,\n                                              check_dropflag);\n-\n-    let reachable_symbol_ids = filter_reachable_ids(&shared_ccx);\n-\n     // Translate the metadata.\n     let metadata = time(tcx.sess.time_passes(), \"write metadata\", || {\n-        write_metadata(&shared_ccx, &reachable_symbol_ids)\n+        write_metadata(&shared_ccx, shared_ccx.reachable())\n     });\n \n     let metadata_module = ModuleTranslation {\n+        name: \"metadata\".to_string(),\n         llcx: shared_ccx.metadata_llcx(),\n         llmod: shared_ccx.metadata_llmod(),\n     };\n     let no_builtins = attr::contains_name(&krate.attrs, \"no_builtins\");\n \n-    let codegen_units = collect_and_partition_translation_items(&shared_ccx);\n+    // Run the translation item collector and partition the collected items into\n+    // codegen units.\n+    let (codegen_units, symbol_map) = collect_and_partition_translation_items(&shared_ccx);\n     let codegen_unit_count = codegen_units.len();\n-    assert!(tcx.sess.opts.cg.codegen_units == codegen_unit_count ||\n-            tcx.sess.opts.debugging_opts.incremental.is_some());\n \n-    let crate_context_list = CrateContextList::new(&shared_ccx, codegen_units);\n+    let symbol_map = Rc::new(symbol_map);\n \n+    let crate_context_list = CrateContextList::new(&shared_ccx,\n+                                                   codegen_units,\n+                                                   symbol_map.clone());\n     let modules = crate_context_list.iter()\n-        .map(|ccx| ModuleTranslation { llcx: ccx.llcx(), llmod: ccx.llmod() })\n+        .map(|ccx| ModuleTranslation {\n+            name: String::from(&ccx.codegen_unit().name[..]),\n+            llcx: ccx.llcx(),\n+            llmod: ccx.llmod()\n+        })\n         .collect();\n \n     // Skip crate items and just output metadata in -Z no-trans mode.\n@@ -2723,33 +2619,57 @@ pub fn trans_crate<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         };\n     }\n \n-    {\n-        let ccx = crate_context_list.get_ccx(0);\n+    // Instantiate translation items without filling out definitions yet...\n+    for ccx in crate_context_list.iter() {\n+        let trans_items = ccx.codegen_unit()\n+                             .items_in_deterministic_order(tcx, &symbol_map);\n \n-        // Translate all items. See `TransModVisitor` for\n-        // details on why we walk in this particular way.\n-        {\n-            let _icx = push_ctxt(\"text\");\n-            intravisit::walk_mod(&mut TransItemsWithinModVisitor { ccx: &ccx }, &krate.module);\n-            krate.visit_all_items(&mut TransModVisitor { ccx: &ccx });\n+        for (trans_item, linkage) in trans_items {\n+            trans_item.predefine(&ccx, linkage);\n         }\n-\n-        collector::print_collection_results(ccx.shared());\n-\n-        symbol_names_test::report_symbol_names(&ccx);\n     }\n \n+    // ... and now that we have everything pre-defined, fill out those definitions.\n     for ccx in crate_context_list.iter() {\n-        if ccx.sess().opts.debuginfo != NoDebugInfo {\n-            debuginfo::finalize(&ccx);\n+        let trans_items = ccx.codegen_unit()\n+                             .items_in_deterministic_order(tcx, &symbol_map);\n+\n+        for (trans_item, _) in trans_items {\n+           trans_item.define(&ccx);\n         }\n+\n+        // If this codegen unit contains the main function, also create the\n+        // wrapper here\n+        maybe_create_entry_wrapper(&ccx);\n+\n+        // Run replace-all-uses-with for statics that need it\n         for &(old_g, new_g) in ccx.statics_to_rauw().borrow().iter() {\n             unsafe {\n                 let bitcast = llvm::LLVMConstPointerCast(new_g, llvm::LLVMTypeOf(old_g));\n                 llvm::LLVMReplaceAllUsesWith(old_g, bitcast);\n                 llvm::LLVMDeleteGlobal(old_g);\n             }\n         }\n+\n+        // Finalize debuginfo\n+        if ccx.sess().opts.debuginfo != NoDebugInfo {\n+            debuginfo::finalize(&ccx);\n+        }\n+    }\n+\n+    symbol_names_test::report_symbol_names(&shared_ccx);\n+\n+    {\n+        let ccx = crate_context_list.get_ccx(0);\n+\n+        // FIXME: #34018\n+        // At this point, we only walk the HIR for running\n+        // enum_variant_size_lint(). This should arguably be moved somewhere\n+        // else.\n+        {\n+            intravisit::walk_mod(&mut TransItemsWithinModVisitor { ccx: &ccx }, &krate.module);\n+            krate.visit_all_items(&mut TransModVisitor { ccx: &ccx });\n+        }\n     }\n \n     if shared_ccx.sess().trans_stats() {\n@@ -2759,6 +2679,8 @@ pub fn trans_crate<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         println!(\"n_null_glues: {}\", stats.n_null_glues.get());\n         println!(\"n_real_glues: {}\", stats.n_real_glues.get());\n \n+        println!(\"n_fallback_instantiations: {}\", stats.n_fallback_instantiations.get());\n+\n         println!(\"n_fns: {}\", stats.n_fns.get());\n         println!(\"n_monos: {}\", stats.n_monos.get());\n         println!(\"n_inlines: {}\", stats.n_inlines.get());\n@@ -2775,17 +2697,19 @@ pub fn trans_crate<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n             }\n         }\n     }\n+\n     if shared_ccx.sess().count_llvm_insns() {\n         for (k, v) in shared_ccx.stats().llvm_insns.borrow().iter() {\n             println!(\"{:7} {}\", *v, *k);\n         }\n     }\n \n     let sess = shared_ccx.sess();\n-    let mut reachable_symbols = reachable_symbol_ids.iter().map(|&id| {\n+    let mut reachable_symbols = shared_ccx.reachable().iter().map(|&id| {\n         let def_id = shared_ccx.tcx().map.local_def_id(id);\n-        Instance::mono(&shared_ccx, def_id).symbol_name(&shared_ccx)\n+        symbol_for_def_id(def_id, &shared_ccx, &symbol_map)\n     }).collect::<Vec<_>>();\n+\n     if sess.entry_fn.borrow().is_some() {\n         reachable_symbols.push(\"main\".to_string());\n     }\n@@ -2807,7 +2731,7 @@ pub fn trans_crate<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         reachable_symbols.extend(syms.into_iter().filter(|did| {\n             sess.cstore.is_extern_item(shared_ccx.tcx(), *did)\n         }).map(|did| {\n-            Instance::mono(&shared_ccx, did).symbol_name(&shared_ccx)\n+            symbol_for_def_id(did, &shared_ccx, &symbol_map)\n         }));\n     }\n \n@@ -2822,6 +2746,7 @@ pub fn trans_crate<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     }\n \n     let linker_info = LinkerInfo::new(&shared_ccx, &reachable_symbols);\n+\n     CrateTranslation {\n         modules: modules,\n         metadata_module: metadata_module,\n@@ -2900,7 +2825,7 @@ impl<'a, 'tcx, 'v> Visitor<'v> for TransItemsWithinModVisitor<'a, 'tcx> {\n }\n \n fn collect_and_partition_translation_items<'a, 'tcx>(scx: &SharedCrateContext<'a, 'tcx>)\n-                                                     -> Vec<CodegenUnit<'tcx>> {\n+                                                     -> (Vec<CodegenUnit<'tcx>>, SymbolMap<'tcx>) {\n     let time_passes = scx.sess().time_passes();\n \n     let collection_mode = match scx.sess().opts.debugging_opts.print_trans_items {\n@@ -2923,10 +2848,13 @@ fn collect_and_partition_translation_items<'a, 'tcx>(scx: &SharedCrateContext<'a\n         None => TransItemCollectionMode::Lazy\n     };\n \n-    let (items, inlining_map) = time(time_passes, \"translation item collection\", || {\n-        collector::collect_crate_translation_items(&scx, collection_mode)\n+    let (items, inlining_map) =\n+        time(time_passes, \"translation item collection\", || {\n+            collector::collect_crate_translation_items(&scx, collection_mode)\n     });\n \n+    let symbol_map = SymbolMap::build(scx, items.iter().cloned());\n+\n     let strategy = if scx.sess().opts.debugging_opts.incremental.is_some() {\n         PartitioningStrategy::PerModule\n     } else {\n@@ -2937,9 +2865,21 @@ fn collect_and_partition_translation_items<'a, 'tcx>(scx: &SharedCrateContext<'a\n         partitioning::partition(scx.tcx(),\n                                 items.iter().cloned(),\n                                 strategy,\n-                                &inlining_map)\n+                                &inlining_map,\n+                                scx.reachable())\n     });\n \n+    assert!(scx.tcx().sess.opts.cg.codegen_units == codegen_units.len() ||\n+            scx.tcx().sess.opts.debugging_opts.incremental.is_some());\n+\n+    {\n+        let mut ccx_map = scx.translation_items().borrow_mut();\n+\n+        for trans_item in items.iter().cloned() {\n+            ccx_map.insert(trans_item);\n+        }\n+    }\n+\n     if scx.sess().opts.debugging_opts.print_trans_items.is_some() {\n         let mut item_to_cgus = HashMap::new();\n \n@@ -2991,13 +2931,26 @@ fn collect_and_partition_translation_items<'a, 'tcx>(scx: &SharedCrateContext<'a\n         for item in item_keys {\n             println!(\"TRANS_ITEM {}\", item);\n         }\n+    }\n \n-        let mut ccx_map = scx.translation_items().borrow_mut();\n+    (codegen_units, symbol_map)\n+}\n \n-        for cgi in items {\n-            ccx_map.insert(cgi, TransItemState::PredictedButNotGenerated);\n+fn symbol_for_def_id<'a, 'tcx>(def_id: DefId,\n+                               scx: &SharedCrateContext<'a, 'tcx>,\n+                               symbol_map: &SymbolMap<'tcx>)\n+                               -> String {\n+    // Just try to look things up in the symbol map. If nothing's there, we\n+    // recompute.\n+    if let Some(node_id) = scx.tcx().map.as_local_node_id(def_id) {\n+        if let Some(sym) = symbol_map.get(TransItem::Static(node_id)) {\n+            return sym.to_owned();\n         }\n     }\n \n-    codegen_units\n+    let instance = Instance::mono(scx, def_id);\n+\n+    symbol_map.get(TransItem::Fn(instance))\n+              .map(str::to_owned)\n+              .unwrap_or_else(|| instance.symbol_name(scx))\n }"}, {"sha": "983ee564c35b1051fcc447b514d4719d05578707", "filename": "src/librustc_trans/callee.rs", "status": "modified", "additions": 7, "deletions": 4, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/d11936251a93d7395169dfab9088c4dde0cca180/src%2Flibrustc_trans%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d11936251a93d7395169dfab9088c4dde0cca180/src%2Flibrustc_trans%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcallee.rs?ref=d11936251a93d7395169dfab9088c4dde0cca180", "patch": "@@ -46,6 +46,7 @@ use intrinsic;\n use machine::llalign_of_min;\n use meth;\n use monomorphize::{self, Instance};\n+use trans_item::TransItem;\n use type_::Type;\n use type_of;\n use value::Value;\n@@ -302,7 +303,7 @@ pub fn trans_fn_pointer_shim<'a, 'tcx>(\n     let tcx = ccx.tcx();\n \n     // Normalize the type for better caching.\n-    let bare_fn_ty = tcx.erase_regions(&bare_fn_ty);\n+    let bare_fn_ty = tcx.normalize_associated_type(&bare_fn_ty);\n \n     // If this is an impl of `Fn` or `FnMut` trait, the receiver is `&self`.\n     let is_by_ref = match closure_kind {\n@@ -468,7 +469,7 @@ fn get_fn<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n         // Should be either intra-crate or inlined.\n         assert_eq!(def_id.krate, LOCAL_CRATE);\n \n-        let substs = tcx.mk_substs(substs.clone().erase_regions());\n+        let substs = tcx.normalize_associated_type(&substs);\n         let (val, fn_ty) = monomorphize::monomorphic_fn(ccx, def_id, substs);\n         let fn_ptr_ty = match fn_ty.sty {\n             ty::TyFnDef(_, _, fty) => {\n@@ -536,13 +537,15 @@ fn get_fn<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n     // reference. It also occurs when testing libcore and in some\n     // other weird situations. Annoying.\n \n-    let sym = instance.symbol_name(ccx.shared());\n+    let sym = ccx.symbol_map().get_or_compute(ccx.shared(),\n+                                              TransItem::Fn(instance));\n+\n     let llptrty = type_of::type_of(ccx, fn_ptr_ty);\n     let llfn = if let Some(llfn) = declare::get_declared_value(ccx, &sym) {\n         if let Some(span) = local_item {\n             if declare::get_defined_value(ccx, &sym).is_some() {\n                 ccx.sess().span_fatal(span,\n-                    &format!(\"symbol `{}` is already defined\", sym));\n+                    &format!(\"symbol `{}` is already defined\", &sym));\n             }\n         }\n "}, {"sha": "b992ba362a98321ef64505b7858cff6f021b85ff", "filename": "src/librustc_trans/closure.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/d11936251a93d7395169dfab9088c4dde0cca180/src%2Flibrustc_trans%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d11936251a93d7395169dfab9088c4dde0cca180/src%2Flibrustc_trans%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fclosure.rs?ref=d11936251a93d7395169dfab9088c4dde0cca180", "patch": "@@ -10,7 +10,7 @@\n \n use arena::TypedArena;\n use back::symbol_names;\n-use llvm::{ValueRef, get_param, get_params};\n+use llvm::{self, ValueRef, get_param, get_params};\n use rustc::hir::def_id::DefId;\n use abi::{Abi, FnType};\n use adt;\n@@ -167,7 +167,7 @@ fn get_or_create_closure_declaration<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n             variadic: false\n         })\n     }));\n-    let llfn = declare::define_internal_fn(ccx, &symbol, function_type);\n+    let llfn = declare::declare_fn(ccx, &symbol, function_type);\n \n     // set an inline hint for all closures\n     attributes::inline(llfn, attributes::InlineAttr::Hint);\n@@ -211,6 +211,8 @@ pub fn trans_closure_expr<'a, 'tcx>(dest: Dest<'a, 'tcx>,\n            id, closure_def_id, closure_substs);\n \n     let llfn = get_or_create_closure_declaration(ccx, closure_def_id, closure_substs);\n+    llvm::SetLinkage(llfn, llvm::WeakODRLinkage);\n+    llvm::SetUniqueComdat(ccx.llmod(), llfn);\n \n     // Get the type of this closure. Use the current `param_substs` as\n     // the closure substitutions. This makes sense because the closure\n@@ -377,7 +379,7 @@ fn trans_fn_once_adapter_shim<'a, 'tcx>(\n     // Create the by-value helper.\n     let function_name =\n         symbol_names::internal_name_from_type_and_suffix(ccx, llonce_fn_ty, \"once_shim\");\n-    let lloncefn = declare::define_internal_fn(ccx, &function_name, llonce_fn_ty);\n+    let lloncefn = declare::declare_fn(ccx, &function_name, llonce_fn_ty);\n     attributes::set_frame_pointer_elimination(ccx, lloncefn);\n \n     let (block_arena, fcx): (TypedArena<_>, FunctionContext);"}, {"sha": "ba2cd2ba699926ca40e274f5e015f590b2c04f19", "filename": "src/librustc_trans/collector.rs", "status": "modified", "additions": 61, "deletions": 126, "changes": 187, "blob_url": "https://github.com/rust-lang/rust/blob/d11936251a93d7395169dfab9088c4dde0cca180/src%2Flibrustc_trans%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d11936251a93d7395169dfab9088c4dde0cca180/src%2Flibrustc_trans%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcollector.rs?ref=d11936251a93d7395169dfab9088c4dde0cca180", "patch": "@@ -205,6 +205,7 @@ use rustc::mir::visit::Visitor as MirVisitor;\n use syntax::abi::Abi;\n use errors;\n use syntax_pos::DUMMY_SP;\n+use syntax::ast::NodeId;\n use base::custom_coerce_unsize_info;\n use context::SharedCrateContext;\n use common::{fulfill_obligation, normalize_and_test_predicates, type_is_sized};\n@@ -349,17 +350,14 @@ fn collect_items_rec<'a, 'tcx: 'a>(scx: &SharedCrateContext<'a, 'tcx>,\n                 || format!(\"Could not find MIR for static: {:?}\", def_id));\n \n             let empty_substs = scx.empty_substs_for_def_id(def_id);\n-            let mut visitor = MirNeighborCollector {\n+            let visitor = MirNeighborCollector {\n                 scx: scx,\n                 mir: &mir,\n                 output: &mut neighbors,\n                 param_substs: empty_substs\n             };\n \n-            visitor.visit_mir(&mir);\n-            for promoted in &mir.promoted {\n-                visitor.visit_mir(promoted);\n-            }\n+            visit_mir_and_promoted(visitor, &mir);\n         }\n         TransItem::Fn(instance) => {\n             // Keep track of the monomorphization recursion depth\n@@ -372,17 +370,14 @@ fn collect_items_rec<'a, 'tcx: 'a>(scx: &SharedCrateContext<'a, 'tcx>,\n             let mir = errors::expect(scx.sess().diagnostic(), scx.get_mir(instance.def),\n                 || format!(\"Could not find MIR for function: {}\", instance));\n \n-            let mut visitor = MirNeighborCollector {\n+            let visitor = MirNeighborCollector {\n                 scx: scx,\n                 mir: &mir,\n                 output: &mut neighbors,\n                 param_substs: instance.substs\n             };\n \n-            visitor.visit_mir(&mir);\n-            for promoted in &mir.promoted {\n-                visitor.visit_mir(promoted);\n-            }\n+            visit_mir_and_promoted(visitor, &mir);\n         }\n     }\n \n@@ -456,12 +451,25 @@ impl<'a, 'tcx> MirVisitor<'tcx> for MirNeighborCollector<'a, 'tcx> {\n         match *rvalue {\n             mir::Rvalue::Aggregate(mir::AggregateKind::Closure(def_id,\n                                                                ref substs), _) => {\n-                assert!(can_have_local_instance(self.scx.tcx(), def_id));\n-                let trans_item = create_fn_trans_item(self.scx.tcx(),\n-                                                      def_id,\n-                                                      substs.func_substs,\n-                                                      self.param_substs);\n-                self.output.push(trans_item);\n+                let mir = errors::expect(self.scx.sess().diagnostic(),\n+                                         self.scx.get_mir(def_id),\n+                                         || {\n+                    format!(\"Could not find MIR for closure: {:?}\", def_id)\n+                });\n+\n+                let concrete_substs = monomorphize::apply_param_substs(self.scx.tcx(),\n+                                                                       self.param_substs,\n+                                                                       &substs.func_substs);\n+                let concrete_substs = self.scx.tcx().erase_regions(&concrete_substs);\n+\n+                let visitor = MirNeighborCollector {\n+                    scx: self.scx,\n+                    mir: &mir,\n+                    output: self.output,\n+                    param_substs: concrete_substs\n+                };\n+\n+                visit_mir_and_promoted(visitor, &mir);\n             }\n             // When doing an cast from a regular pointer to a fat pointer, we\n             // have to instantiate all methods of the trait being cast to, so we\n@@ -624,7 +632,8 @@ impl<'a, 'tcx> MirVisitor<'tcx> for MirNeighborCollector<'a, 'tcx> {\n                             let operand_ty = monomorphize::apply_param_substs(tcx,\n                                                                               self.param_substs,\n                                                                               &mt.ty);\n-                            self.output.push(TransItem::DropGlue(DropGlueKind::Ty(operand_ty)));\n+                            let ty = glue::get_drop_glue_type(tcx, operand_ty);\n+                            self.output.push(TransItem::DropGlue(DropGlueKind::Ty(ty)));\n                         } else {\n                             bug!(\"Has the drop_in_place() intrinsic's signature changed?\")\n                         }\n@@ -1070,7 +1079,6 @@ impl<'b, 'a, 'v> hir_visit::Visitor<'v> for RootCollector<'b, 'a, 'v> {\n             hir::ItemTy(..)          |\n             hir::ItemDefaultImpl(..) |\n             hir::ItemTrait(..)       |\n-            hir::ItemConst(..)       |\n             hir::ItemMod(..)         => {\n                 // Nothing to do, just keep recursing...\n             }\n@@ -1107,9 +1115,14 @@ impl<'b, 'a, 'v> hir_visit::Visitor<'v> for RootCollector<'b, 'a, 'v> {\n                                         self.scx.tcx().map.local_def_id(item.id)));\n                 self.output.push(TransItem::Static(item.id));\n             }\n-            hir::ItemFn(_, _, constness, _, ref generics, _) => {\n-                if !generics.is_type_parameterized() &&\n-                   constness == hir::Constness::NotConst {\n+            hir::ItemConst(..) => {\n+                debug!(\"RootCollector: ItemConst({})\",\n+                       def_id_to_string(self.scx.tcx(),\n+                                        self.scx.tcx().map.local_def_id(item.id)));\n+                add_roots_for_const_item(self.scx, item.id, self.output);\n+            }\n+            hir::ItemFn(_, _, _, _, ref generics, _) => {\n+                if !generics.is_type_parameterized() {\n                     let def_id = self.scx.tcx().map.local_def_id(item.id);\n \n                     debug!(\"RootCollector: ItemFn({})\",\n@@ -1129,9 +1142,8 @@ impl<'b, 'a, 'v> hir_visit::Visitor<'v> for RootCollector<'b, 'a, 'v> {\n         match ii.node {\n             hir::ImplItemKind::Method(hir::MethodSig {\n                 ref generics,\n-                constness,\n                 ..\n-            }, _) if constness == hir::Constness::NotConst => {\n+            }, _) => {\n                 let hir_map = &self.scx.tcx().map;\n                 let parent_node_id = hir_map.get_parent_node(ii.id);\n                 let is_impl_generic = match hir_map.expect_item(parent_node_id) {\n@@ -1228,111 +1240,34 @@ fn create_trans_items_for_default_impls<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     }\n }\n \n-#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n-pub enum TransItemState {\n-    PredictedAndGenerated,\n-    PredictedButNotGenerated,\n-    NotPredictedButGenerated,\n-}\n+// There are no translation items for constants themselves but their\n+// initializers might still contain something that produces translation items,\n+// such as cast that introduce a new vtable.\n+fn add_roots_for_const_item<'a, 'tcx>(scx: &SharedCrateContext<'a, 'tcx>,\n+                                      const_item_node_id: NodeId,\n+                                      output: &mut Vec<TransItem<'tcx>>)\n+{\n+    let def_id = scx.tcx().map.local_def_id(const_item_node_id);\n+\n+    // Scan the MIR in order to find function calls, closures, and\n+    // drop-glue\n+    let mir = errors::expect(scx.sess().diagnostic(), scx.get_mir(def_id),\n+        || format!(\"Could not find MIR for const: {:?}\", def_id));\n+\n+    let empty_substs = scx.empty_substs_for_def_id(def_id);\n+    let visitor = MirNeighborCollector {\n+        scx: scx,\n+        mir: &mir,\n+        output: output,\n+        param_substs: empty_substs\n+    };\n \n-pub fn collecting_debug_information(scx: &SharedCrateContext) -> bool {\n-    return cfg!(debug_assertions) &&\n-           scx.sess().opts.debugging_opts.print_trans_items.is_some();\n+    visit_mir_and_promoted(visitor, &mir);\n }\n \n-pub fn print_collection_results<'a, 'tcx>(scx: &SharedCrateContext<'a, 'tcx>) {\n-    use std::hash::{Hash, SipHasher, Hasher};\n-\n-    if !collecting_debug_information(scx) {\n-        return;\n-    }\n-\n-    fn hash<T: Hash>(t: &T) -> u64 {\n-        let mut s = SipHasher::new();\n-        t.hash(&mut s);\n-        s.finish()\n-    }\n-\n-    let trans_items = scx.translation_items().borrow();\n-\n-    {\n-        // Check for duplicate item keys\n-        let mut item_keys = FnvHashMap();\n-\n-        for (item, item_state) in trans_items.iter() {\n-            let k = item.to_string(scx.tcx());\n-\n-            if item_keys.contains_key(&k) {\n-                let prev: (TransItem, TransItemState) = item_keys[&k];\n-                debug!(\"DUPLICATE KEY: {}\", k);\n-                debug!(\" (1) {:?}, {:?}, hash: {}, raw: {}\",\n-                       prev.0,\n-                       prev.1,\n-                       hash(&prev.0),\n-                       prev.0.to_raw_string());\n-\n-                debug!(\" (2) {:?}, {:?}, hash: {}, raw: {}\",\n-                       *item,\n-                       *item_state,\n-                       hash(item),\n-                       item.to_raw_string());\n-            } else {\n-                item_keys.insert(k, (*item, *item_state));\n-            }\n-        }\n-    }\n-\n-    let mut predicted_but_not_generated = FnvHashSet();\n-    let mut not_predicted_but_generated = FnvHashSet();\n-    let mut predicted = FnvHashSet();\n-    let mut generated = FnvHashSet();\n-\n-    for (item, item_state) in trans_items.iter() {\n-        let item_key = item.to_string(scx.tcx());\n-\n-        match *item_state {\n-            TransItemState::PredictedAndGenerated => {\n-                predicted.insert(item_key.clone());\n-                generated.insert(item_key);\n-            }\n-            TransItemState::PredictedButNotGenerated => {\n-                predicted_but_not_generated.insert(item_key.clone());\n-                predicted.insert(item_key);\n-            }\n-            TransItemState::NotPredictedButGenerated => {\n-                not_predicted_but_generated.insert(item_key.clone());\n-                generated.insert(item_key);\n-            }\n-        }\n-    }\n-\n-    debug!(\"Total number of translation items predicted: {}\", predicted.len());\n-    debug!(\"Total number of translation items generated: {}\", generated.len());\n-    debug!(\"Total number of translation items predicted but not generated: {}\",\n-           predicted_but_not_generated.len());\n-    debug!(\"Total number of translation items not predicted but generated: {}\",\n-           not_predicted_but_generated.len());\n-\n-    if generated.len() > 0 {\n-        debug!(\"Failed to predict {}% of translation items\",\n-               (100 * not_predicted_but_generated.len()) / generated.len());\n-    }\n-    if generated.len() > 0 {\n-        debug!(\"Predict {}% too many translation items\",\n-               (100 * predicted_but_not_generated.len()) / generated.len());\n-    }\n-\n-    debug!(\"\");\n-    debug!(\"Not predicted but generated:\");\n-    debug!(\"============================\");\n-    for item in not_predicted_but_generated {\n-        debug!(\" - {}\", item);\n-    }\n-\n-    debug!(\"\");\n-    debug!(\"Predicted but not generated:\");\n-    debug!(\"============================\");\n-    for item in predicted_but_not_generated {\n-        debug!(\" - {}\", item);\n+fn visit_mir_and_promoted<'tcx, V: MirVisitor<'tcx>>(mut visitor: V, mir: &mir::Mir<'tcx>) {\n+    visitor.visit_mir(&mir);\n+    for promoted in &mir.promoted {\n+        visitor.visit_mir(promoted);\n     }\n }"}, {"sha": "5732fded362f58fd132c16b8313be3ac021783b9", "filename": "src/librustc_trans/consts.rs", "status": "modified", "additions": 41, "deletions": 30, "changes": 71, "blob_url": "https://github.com/rust-lang/rust/blob/d11936251a93d7395169dfab9088c4dde0cca180/src%2Flibrustc_trans%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d11936251a93d7395169dfab9088c4dde0cca180/src%2Flibrustc_trans%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fconsts.rs?ref=d11936251a93d7395169dfab9088c4dde0cca180", "patch": "@@ -21,7 +21,6 @@ use rustc::hir::map as hir_map;\n use {abi, adt, closure, debuginfo, expr, machine};\n use base::{self, push_ctxt};\n use callee::Callee;\n-use collector;\n use trans_item::TransItem;\n use common::{type_is_sized, C_nil, const_get_elt};\n use common::{CrateContext, C_integral, C_floating, C_bool, C_str_slice, C_bytes, val_ty};\n@@ -1013,31 +1012,41 @@ pub fn get_static<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, def_id: DefId)\n         return Datum::new(g, ty, Lvalue::new(\"static\"));\n     }\n \n-    let sym = instance.symbol_name(ccx.shared());\n-\n     let g = if let Some(id) = ccx.tcx().map.as_local_node_id(def_id) {\n+\n         let llty = type_of::type_of(ccx, ty);\n-        match ccx.tcx().map.get(id) {\n+        let (g, attrs) = match ccx.tcx().map.get(id) {\n             hir_map::NodeItem(&hir::Item {\n-                span, node: hir::ItemStatic(..), ..\n+                ref attrs, span, node: hir::ItemStatic(..), ..\n             }) => {\n-                // If this static came from an external crate, then\n-                // we need to get the symbol from metadata instead of\n-                // using the current crate's name/version\n-                // information in the hash of the symbol\n-                debug!(\"making {}\", sym);\n-\n-                // Create the global before evaluating the initializer;\n-                // this is necessary to allow recursive statics.\n-                declare::define_global(ccx, &sym, llty).unwrap_or_else(|| {\n-                    ccx.sess().span_fatal(span,\n-                        &format!(\"symbol `{}` is already defined\", sym))\n-                })\n+                let sym = ccx.symbol_map()\n+                             .get(TransItem::Static(id))\n+                             .expect(\"Local statics should always be in the SymbolMap\");\n+                // Make sure that this is never executed for something inlined.\n+                assert!(!ccx.external_srcs().borrow().contains_key(&id));\n+\n+                let defined_in_current_codegen_unit = ccx.codegen_unit()\n+                                                         .items\n+                                                         .contains_key(&TransItem::Static(id));\n+                if defined_in_current_codegen_unit {\n+                    if declare::get_declared_value(ccx, sym).is_none() {\n+                        span_bug!(span, \"trans: Static not properly pre-defined?\");\n+                    }\n+                } else {\n+                    if declare::get_declared_value(ccx, sym).is_some() {\n+                        span_bug!(span, \"trans: Conflicting symbol names for static?\");\n+                    }\n+                }\n+\n+                let g = declare::define_global(ccx, sym, llty).unwrap();\n+\n+                (g, attrs)\n             }\n \n             hir_map::NodeForeignItem(&hir::ForeignItem {\n                 ref attrs, span, node: hir::ForeignItemStatic(..), ..\n             }) => {\n+                let sym = instance.symbol_name(ccx.shared());\n                 let g = if let Some(name) =\n                         attr::first_attr_value_str_by_name(&attrs, \"linkage\") {\n                     // If this is a static with a linkage specified, then we need to handle\n@@ -1072,7 +1081,7 @@ pub fn get_static<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, def_id: DefId)\n                         real_name.push_str(&sym);\n                         let g2 = declare::define_global(ccx, &real_name, llty).unwrap_or_else(||{\n                             ccx.sess().span_fatal(span,\n-                                &format!(\"symbol `{}` is already defined\", sym))\n+                                &format!(\"symbol `{}` is already defined\", &sym))\n                         });\n                         llvm::SetLinkage(g2, llvm::InternalLinkage);\n                         llvm::LLVMSetInitializer(g2, g1);\n@@ -1083,18 +1092,22 @@ pub fn get_static<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, def_id: DefId)\n                     declare::declare_global(ccx, &sym, llty)\n                 };\n \n-                for attr in attrs {\n-                    if attr.check_name(\"thread_local\") {\n-                        llvm::set_thread_local(g, true);\n-                    }\n-                }\n-\n-                g\n+                (g, attrs)\n             }\n \n             item => bug!(\"get_static: expected static, found {:?}\", item)\n+        };\n+\n+        for attr in attrs {\n+            if attr.check_name(\"thread_local\") {\n+                llvm::set_thread_local(g, true);\n+            }\n         }\n+\n+        g\n     } else {\n+        let sym = instance.symbol_name(ccx.shared());\n+\n         // FIXME(nagisa): perhaps the map of externs could be offloaded to llvm somehow?\n         // FIXME(nagisa): investigate whether it can be changed into define_global\n         let g = declare::declare_global(ccx, &sym, type_of::type_of(ccx, ty));\n@@ -1126,11 +1139,6 @@ pub fn trans_static(ccx: &CrateContext,\n                     id: ast::NodeId,\n                     attrs: &[ast::Attribute])\n                     -> Result<ValueRef, ConstEvalErr> {\n-\n-    if collector::collecting_debug_information(ccx.shared()) {\n-        ccx.record_translation_item_as_generated(TransItem::Static(id));\n-    }\n-\n     unsafe {\n         let _icx = push_ctxt(\"trans_static\");\n         let def_id = ccx.tcx().map.local_def_id(id);\n@@ -1197,6 +1205,9 @@ pub fn trans_static(ccx: &CrateContext,\n                                \"thread_local\") {\n             llvm::set_thread_local(g, true);\n         }\n+\n+        base::set_link_section(ccx, g, attrs);\n+\n         Ok(g)\n     }\n }"}, {"sha": "b8d231db40a2af48aeda9bc1061b5f3f580f20a2", "filename": "src/librustc_trans/context.rs", "status": "modified", "additions": 22, "deletions": 35, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/d11936251a93d7395169dfab9088c4dde0cca180/src%2Flibrustc_trans%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d11936251a93d7395169dfab9088c4dde0cca180/src%2Flibrustc_trans%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcontext.rs?ref=d11936251a93d7395169dfab9088c4dde0cca180", "patch": "@@ -28,13 +28,13 @@ use mir::CachedMir;\n use monomorphize::Instance;\n \n use partitioning::CodegenUnit;\n-use collector::TransItemState;\n use trans_item::TransItem;\n use type_::{Type, TypeNames};\n use rustc::ty::subst::{Substs, VecPerParamSpace};\n use rustc::ty::{self, Ty, TyCtxt};\n use session::config::NoDebugInfo;\n use session::Session;\n+use symbol_map::SymbolMap;\n use util::sha2::Sha256;\n use util::nodemap::{NodeMap, NodeSet, DefIdMap, FnvHashMap, FnvHashSet};\n \n@@ -46,11 +46,13 @@ use std::rc::Rc;\n use std::str;\n use syntax::ast;\n use syntax::parse::token::InternedString;\n+use abi::FnType;\n \n pub struct Stats {\n     pub n_glues_created: Cell<usize>,\n     pub n_null_glues: Cell<usize>,\n     pub n_real_glues: Cell<usize>,\n+    pub n_fallback_instantiations: Cell<usize>,\n     pub n_fns: Cell<usize>,\n     pub n_monos: Cell<usize>,\n     pub n_inlines: Cell<usize>,\n@@ -80,11 +82,9 @@ pub struct SharedCrateContext<'a, 'tcx: 'a> {\n     mir_map: &'a MirMap<'tcx>,\n     mir_cache: RefCell<DefIdMap<Rc<mir::Mir<'tcx>>>>,\n \n-    available_monomorphizations: RefCell<FnvHashSet<String>>,\n-    available_drop_glues: RefCell<FnvHashMap<DropGlueKind<'tcx>, String>>,\n     use_dll_storage_attrs: bool,\n \n-    translation_items: RefCell<FnvHashMap<TransItem<'tcx>, TransItemState>>,\n+    translation_items: RefCell<FnvHashSet<TransItem<'tcx>>>,\n     trait_cache: RefCell<DepTrackingMap<TraitSelectionCache<'tcx>>>,\n }\n \n@@ -99,7 +99,7 @@ pub struct LocalCrateContext<'tcx> {\n     codegen_unit: CodegenUnit<'tcx>,\n     needs_unwind_cleanup_cache: RefCell<FnvHashMap<Ty<'tcx>, bool>>,\n     fn_pointer_shims: RefCell<FnvHashMap<Ty<'tcx>, ValueRef>>,\n-    drop_glues: RefCell<FnvHashMap<DropGlueKind<'tcx>, ValueRef>>,\n+    drop_glues: RefCell<FnvHashMap<DropGlueKind<'tcx>, (ValueRef, FnType)>>,\n     /// Track mapping of external ids to local items imported for inlining\n     external: RefCell<DefIdMap<Option<ast::NodeId>>>,\n     /// Backwards version of the `external` map (inlined items to where they\n@@ -172,6 +172,8 @@ pub struct LocalCrateContext<'tcx> {\n \n     /// Depth of the current type-of computation - used to bail out\n     type_of_depth: Cell<usize>,\n+\n+    symbol_map: Rc<SymbolMap<'tcx>>,\n }\n \n // Implement DepTrackingMapConfig for `trait_cache`\n@@ -198,12 +200,13 @@ pub struct CrateContextList<'a, 'tcx: 'a> {\n impl<'a, 'tcx: 'a> CrateContextList<'a, 'tcx> {\n \n     pub fn new(shared_ccx: &'a SharedCrateContext<'a, 'tcx>,\n-               codegen_units: Vec<CodegenUnit<'tcx>>)\n+               codegen_units: Vec<CodegenUnit<'tcx>>,\n+               symbol_map: Rc<SymbolMap<'tcx>>)\n                -> CrateContextList<'a, 'tcx> {\n         CrateContextList {\n             shared: shared_ccx,\n             local_ccxs: codegen_units.into_iter().map(|codegen_unit| {\n-                LocalCrateContext::new(shared_ccx, codegen_unit)\n+                LocalCrateContext::new(shared_ccx, codegen_unit, symbol_map.clone())\n             }).collect()\n         }\n     }\n@@ -403,6 +406,7 @@ impl<'b, 'tcx> SharedCrateContext<'b, 'tcx> {\n                 n_glues_created: Cell::new(0),\n                 n_null_glues: Cell::new(0),\n                 n_real_glues: Cell::new(0),\n+                n_fallback_instantiations: Cell::new(0),\n                 n_fns: Cell::new(0),\n                 n_monos: Cell::new(0),\n                 n_inlines: Cell::new(0),\n@@ -413,10 +417,8 @@ impl<'b, 'tcx> SharedCrateContext<'b, 'tcx> {\n             },\n             check_overflow: check_overflow,\n             check_drop_flag_for_sanity: check_drop_flag_for_sanity,\n-            available_monomorphizations: RefCell::new(FnvHashSet()),\n-            available_drop_glues: RefCell::new(FnvHashMap()),\n             use_dll_storage_attrs: use_dll_storage_attrs,\n-            translation_items: RefCell::new(FnvHashMap()),\n+            translation_items: RefCell::new(FnvHashSet()),\n             trait_cache: RefCell::new(DepTrackingMap::new(tcx.dep_graph.clone())),\n         }\n     }\n@@ -479,7 +481,7 @@ impl<'b, 'tcx> SharedCrateContext<'b, 'tcx> {\n         }\n     }\n \n-    pub fn translation_items(&self) -> &RefCell<FnvHashMap<TransItem<'tcx>, TransItemState>> {\n+    pub fn translation_items(&self) -> &RefCell<FnvHashSet<TransItem<'tcx>>> {\n         &self.translation_items\n     }\n \n@@ -515,7 +517,8 @@ impl<'b, 'tcx> SharedCrateContext<'b, 'tcx> {\n \n impl<'tcx> LocalCrateContext<'tcx> {\n     fn new<'a>(shared: &SharedCrateContext<'a, 'tcx>,\n-               codegen_unit: CodegenUnit<'tcx>)\n+               codegen_unit: CodegenUnit<'tcx>,\n+               symbol_map: Rc<SymbolMap<'tcx>>)\n            -> LocalCrateContext<'tcx> {\n         unsafe {\n             // Append \".rs\" to LLVM module identifier.\n@@ -574,6 +577,7 @@ impl<'tcx> LocalCrateContext<'tcx> {\n                 intrinsics: RefCell::new(FnvHashMap()),\n                 n_llvm_insns: Cell::new(0),\n                 type_of_depth: Cell::new(0),\n+                symbol_map: symbol_map,\n             };\n \n             let (int_type, opaque_vec_type, str_slice_ty, mut local_ccx) = {\n@@ -730,7 +734,8 @@ impl<'b, 'tcx> CrateContext<'b, 'tcx> {\n         &self.local().fn_pointer_shims\n     }\n \n-    pub fn drop_glues<'a>(&'a self) -> &'a RefCell<FnvHashMap<DropGlueKind<'tcx>, ValueRef>> {\n+    pub fn drop_glues<'a>(&'a self)\n+                          -> &'a RefCell<FnvHashMap<DropGlueKind<'tcx>, (ValueRef, FnType)>> {\n         &self.local().drop_glues\n     }\n \n@@ -816,14 +821,6 @@ impl<'b, 'tcx> CrateContext<'b, 'tcx> {\n         &self.shared.stats\n     }\n \n-    pub fn available_monomorphizations<'a>(&'a self) -> &'a RefCell<FnvHashSet<String>> {\n-        &self.shared.available_monomorphizations\n-    }\n-\n-    pub fn available_drop_glues(&self) -> &RefCell<FnvHashMap<DropGlueKind<'tcx>, String>> {\n-        &self.shared.available_drop_glues\n-    }\n-\n     pub fn int_type(&self) -> Type {\n         self.local().int_type\n     }\n@@ -900,22 +897,12 @@ impl<'b, 'tcx> CrateContext<'b, 'tcx> {\n         self.shared.get_mir(def_id)\n     }\n \n-    pub fn translation_items(&self) -> &RefCell<FnvHashMap<TransItem<'tcx>, TransItemState>> {\n-        &self.shared.translation_items\n+    pub fn symbol_map(&self) -> &SymbolMap<'tcx> {\n+        &*self.local().symbol_map\n     }\n \n-    pub fn record_translation_item_as_generated(&self, cgi: TransItem<'tcx>) {\n-        if self.sess().opts.debugging_opts.print_trans_items.is_none() {\n-            return;\n-        }\n-\n-        let mut codegen_items = self.translation_items().borrow_mut();\n-\n-        if codegen_items.contains_key(&cgi) {\n-            codegen_items.insert(cgi, TransItemState::PredictedAndGenerated);\n-        } else {\n-            codegen_items.insert(cgi, TransItemState::NotPredictedButGenerated);\n-        }\n+    pub fn translation_items(&self) -> &RefCell<FnvHashSet<TransItem<'tcx>>> {\n+        &self.shared.translation_items\n     }\n \n     /// Given the def-id of some item that has no type parameters, make"}, {"sha": "2746d3fb6b0b6788e76397504e968b60d460491f", "filename": "src/librustc_trans/declare.rs", "status": "modified", "additions": 17, "deletions": 7, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/d11936251a93d7395169dfab9088c4dde0cca180/src%2Flibrustc_trans%2Fdeclare.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d11936251a93d7395169dfab9088c4dde0cca180/src%2Flibrustc_trans%2Fdeclare.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fdeclare.rs?ref=d11936251a93d7395169dfab9088c4dde0cca180", "patch": "@@ -138,24 +138,34 @@ pub fn define_global(ccx: &CrateContext, name: &str, ty: Type) -> Option<ValueRe\n     }\n }\n \n-\n /// Declare a Rust function with an intention to define it.\n ///\n /// Use this function when you intend to define a function. This function will\n /// return panic if the name already has a definition associated with it. This\n /// can happen with #[no_mangle] or #[export_name], for example.\n-pub fn define_internal_fn<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n-                                    name: &str,\n-                                    fn_type: ty::Ty<'tcx>) -> ValueRef {\n+pub fn define_fn<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n+                           name: &str,\n+                           fn_type: ty::Ty<'tcx>) -> ValueRef {\n     if get_defined_value(ccx, name).is_some() {\n         ccx.sess().fatal(&format!(\"symbol `{}` already defined\", name))\n     } else {\n-        let llfn = declare_fn(ccx, name, fn_type);\n-        llvm::SetLinkage(llfn, llvm::InternalLinkage);\n-        llfn\n+        declare_fn(ccx, name, fn_type)\n     }\n }\n \n+/// Declare a Rust function with an intention to define it.\n+///\n+/// Use this function when you intend to define a function. This function will\n+/// return panic if the name already has a definition associated with it. This\n+/// can happen with #[no_mangle] or #[export_name], for example.\n+pub fn define_internal_fn<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n+                                    name: &str,\n+                                    fn_type: ty::Ty<'tcx>) -> ValueRef {\n+    let llfn = define_fn(ccx, name, fn_type);\n+    llvm::SetLinkage(llfn, llvm::InternalLinkage);\n+    llfn\n+}\n+\n \n /// Get declared value by name.\n pub fn get_declared_value(ccx: &CrateContext, name: &str) -> Option<ValueRef> {"}, {"sha": "b8dd7273a8331df4ac0c1fec8dbbe3572c25cf2e", "filename": "src/librustc_trans/expr.rs", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/d11936251a93d7395169dfab9088c4dde0cca180/src%2Flibrustc_trans%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d11936251a93d7395169dfab9088c4dde0cca180/src%2Flibrustc_trans%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fexpr.rs?ref=d11936251a93d7395169dfab9088c4dde0cca180", "patch": "@@ -1695,11 +1695,13 @@ fn trans_scalar_binop<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n }\n \n // refinement types would obviate the need for this\n+#[derive(Clone, Copy)]\n enum lazy_binop_ty {\n     lazy_and,\n     lazy_or,\n }\n \n+\n fn trans_lazy_binop<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                                 binop_expr: &hir::Expr,\n                                 op: lazy_binop_ty,\n@@ -1717,6 +1719,17 @@ fn trans_lazy_binop<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n         return immediate_rvalue_bcx(past_lhs, lhs, binop_ty).to_expr_datumblock();\n     }\n \n+    // If the rhs can never be reached, don't generate code for it.\n+    if let Some(cond_val) = const_to_opt_uint(lhs) {\n+        match (cond_val, op) {\n+            (0, lazy_and) |\n+            (1, lazy_or)  => {\n+                return immediate_rvalue_bcx(past_lhs, lhs, binop_ty).to_expr_datumblock();\n+            }\n+            _ => { /* continue */ }\n+        }\n+    }\n+\n     let join = fcx.new_id_block(\"join\", binop_expr.id);\n     let before_rhs = fcx.new_id_block(\"before_rhs\", b.id);\n "}, {"sha": "ef7d0ea165d609d4487e50ece1e65a2869d61940", "filename": "src/librustc_trans/glue.rs", "status": "modified", "additions": 31, "deletions": 49, "changes": 80, "blob_url": "https://github.com/rust-lang/rust/blob/d11936251a93d7395169dfab9088c4dde0cca180/src%2Flibrustc_trans%2Fglue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d11936251a93d7395169dfab9088c4dde0cca180/src%2Flibrustc_trans%2Fglue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fglue.rs?ref=d11936251a93d7395169dfab9088c4dde0cca180", "patch": "@@ -14,26 +14,21 @@\n \n use std;\n \n-use attributes;\n-use back::symbol_names;\n use llvm;\n use llvm::{ValueRef, get_param};\n use middle::lang_items::ExchangeFreeFnLangItem;\n use rustc::ty::subst::{Substs};\n use rustc::traits;\n use rustc::ty::{self, Ty, TyCtxt, TypeFoldable};\n-use abi::{Abi, FnType};\n use adt;\n use adt::GetDtorType; // for tcx.dtor_type()\n use base::*;\n use build::*;\n use callee::{Callee, ArgVals};\n use cleanup;\n use cleanup::CleanupMethods;\n-use collector;\n use common::*;\n use debuginfo::DebugLoc;\n-use declare;\n use expr;\n use machine::*;\n use monomorphize;\n@@ -236,57 +231,50 @@ impl<'tcx> DropGlueKind<'tcx> {\n \n fn get_drop_glue_core<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n                                 g: DropGlueKind<'tcx>) -> ValueRef {\n-    debug!(\"make drop glue for {:?}\", g);\n     let g = g.map_ty(|t| get_drop_glue_type(ccx.tcx(), t));\n-    debug!(\"drop glue type {:?}\", g);\n     match ccx.drop_glues().borrow().get(&g) {\n-        Some(&glue) => return glue,\n-        _ => { }\n+        Some(&(glue, _)) => return glue,\n+        None => {\n+            debug!(\"Could not find drop glue for {:?} -- {} -- {}. \\\n+                    Falling back to on-demand instantiation.\",\n+                    g,\n+                    TransItem::DropGlue(g).to_raw_string(),\n+                    ccx.codegen_unit().name);\n+\n+            ccx.stats().n_fallback_instantiations.set(ccx.stats()\n+                                                         .n_fallback_instantiations\n+                                                         .get() + 1);\n+        }\n     }\n-    let t = g.ty();\n \n-    let tcx = ccx.tcx();\n-    let sig = ty::FnSig {\n-        inputs: vec![tcx.mk_mut_ptr(tcx.types.i8)],\n-        output: ty::FnOutput::FnConverging(tcx.mk_nil()),\n-        variadic: false,\n-    };\n-    // Create a FnType for fn(*mut i8) and substitute the real type in\n-    // later - that prevents FnType from splitting fat pointers up.\n-    let mut fn_ty = FnType::new(ccx, Abi::Rust, &sig, &[]);\n-    fn_ty.args[0].original_ty = type_of(ccx, t).ptr_to();\n-    let llfnty = fn_ty.llvm_type(ccx);\n-\n-    // To avoid infinite recursion, don't `make_drop_glue` until after we've\n-    // added the entry to the `drop_glues` cache.\n-    if let Some(old_sym) = ccx.available_drop_glues().borrow().get(&g) {\n-        let llfn = declare::declare_cfn(ccx, &old_sym, llfnty);\n-        ccx.drop_glues().borrow_mut().insert(g, llfn);\n-        return llfn;\n-    };\n+    // FIXME: #34151\n+    // Normally, getting here would indicate a bug in trans::collector,\n+    // since it seems to have missed a translation item. When we are\n+    // translating with non-MIR-based trans, however, the results of the\n+    // collector are not entirely reliable since it bases its analysis\n+    // on MIR. Thus, we'll instantiate the missing function on demand in\n+    // this codegen unit, so that things keep working.\n \n-    let suffix = match g {\n-        DropGlueKind::Ty(_) => \"drop\",\n-        DropGlueKind::TyContents(_) => \"drop_contents\",\n-    };\n+    TransItem::DropGlue(g).predefine(ccx, llvm::InternalLinkage);\n+    TransItem::DropGlue(g).define(ccx);\n \n-    let fn_nm = symbol_names::internal_name_from_type_and_suffix(ccx, t, suffix);\n-    assert!(declare::get_defined_value(ccx, &fn_nm).is_none());\n-    let llfn = declare::declare_cfn(ccx, &fn_nm, llfnty);\n-    attributes::set_frame_pointer_elimination(ccx, llfn);\n-    ccx.available_drop_glues().borrow_mut().insert(g, fn_nm);\n-    ccx.drop_glues().borrow_mut().insert(g, llfn);\n+    // Now that we made sure that the glue function is in ccx.drop_glues,\n+    // give it another try\n+    get_drop_glue_core(ccx, g)\n+}\n \n-    let _s = StatRecorder::new(ccx, format!(\"drop {:?}\", t));\n+pub fn implement_drop_glue<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n+                                     g: DropGlueKind<'tcx>) {\n+    let tcx = ccx.tcx();\n+    assert_eq!(g.ty(), get_drop_glue_type(tcx, g.ty()));\n+    let (llfn, fn_ty) = ccx.drop_glues().borrow().get(&g).unwrap().clone();\n \n     let (arena, fcx): (TypedArena<_>, FunctionContext);\n     arena = TypedArena::new();\n     fcx = FunctionContext::new(ccx, llfn, fn_ty, None, &arena);\n \n     let bcx = fcx.init(false, None);\n \n-    update_linkage(ccx, llfn, None, OriginalTranslation);\n-\n     ccx.stats().n_glues_created.set(ccx.stats().n_glues_created.get() + 1);\n     // All glue functions take values passed *by alias*; this is a\n     // requirement since in many contexts glue is invoked indirectly and\n@@ -298,10 +286,9 @@ fn get_drop_glue_core<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n \n     let bcx = make_drop_glue(bcx, get_param(llfn, 0), g);\n     fcx.finish(bcx, DebugLoc::None);\n-\n-    llfn\n }\n \n+\n fn trans_struct_drop_flag<'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n                                       t: Ty<'tcx>,\n                                       struct_data: ValueRef)\n@@ -494,11 +481,6 @@ pub fn size_and_align_of_dst<'blk, 'tcx>(bcx: &BlockAndBuilder<'blk, 'tcx>,\n \n fn make_drop_glue<'blk, 'tcx>(bcx: Block<'blk, 'tcx>, v0: ValueRef, g: DropGlueKind<'tcx>)\n                               -> Block<'blk, 'tcx> {\n-    if collector::collecting_debug_information(bcx.ccx().shared()) {\n-        bcx.ccx()\n-           .record_translation_item_as_generated(TransItem::DropGlue(g));\n-    }\n-\n     let t = g.ty();\n \n     let skip_dtor = match g { DropGlueKind::Ty(_) => false, DropGlueKind::TyContents(_) => true };"}, {"sha": "4077b894d62d4456a76dc16f1baf83ab83b78f16", "filename": "src/librustc_trans/inline.rs", "status": "modified", "additions": 12, "deletions": 52, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/d11936251a93d7395169dfab9088c4dde0cca180/src%2Flibrustc_trans%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d11936251a93d7395169dfab9088c4dde0cca180/src%2Flibrustc_trans%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Finline.rs?ref=d11936251a93d7395169dfab9088c4dde0cca180", "patch": "@@ -8,13 +8,11 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use llvm::{AvailableExternallyLinkage, InternalLinkage, SetLinkage};\n use middle::cstore::{FoundAst, InlinedItem};\n use rustc::hir::def_id::DefId;\n-use rustc::ty::subst::Substs;\n-use base::{push_ctxt, trans_item, trans_fn};\n-use callee::Callee;\n+use base::push_ctxt;\n use common::*;\n+use monomorphize::Instance;\n \n use rustc::dep_graph::DepNode;\n use rustc::hir;\n@@ -52,30 +50,6 @@ fn instantiate_inline(ccx: &CrateContext, fn_id: DefId) -> Option<DefId> {\n             ccx.external_srcs().borrow_mut().insert(item.id, fn_id);\n \n             ccx.stats().n_inlines.set(ccx.stats().n_inlines.get() + 1);\n-            trans_item(ccx, item);\n-\n-            if let hir::ItemFn(_, _, _, _, ref generics, _) = item.node {\n-                // Generics have no symbol, so they can't be given any linkage.\n-                if !generics.is_type_parameterized() {\n-                    let linkage = if ccx.sess().opts.cg.codegen_units == 1 {\n-                        // We could use AvailableExternallyLinkage here,\n-                        // but InternalLinkage allows LLVM to optimize more\n-                        // aggressively (at the cost of sometimes\n-                        // duplicating code).\n-                        InternalLinkage\n-                    } else {\n-                        // With multiple compilation units, duplicated code\n-                        // is more of a problem.  Also, `codegen_units > 1`\n-                        // means the user is okay with losing some\n-                        // performance.\n-                        AvailableExternallyLinkage\n-                    };\n-                    let empty_substs = tcx.mk_substs(Substs::empty());\n-                    let def_id = tcx.map.local_def_id(item.id);\n-                    let llfn = Callee::def(ccx, def_id, empty_substs).reify(ccx).val;\n-                    SetLinkage(llfn, linkage);\n-                }\n-            }\n \n             item.id\n         }\n@@ -135,35 +109,12 @@ fn instantiate_inline(ccx: &CrateContext, fn_id: DefId) -> Option<DefId> {\n             // don't.\n             trait_item.id\n         }\n-        FoundAst::Found(&InlinedItem::ImplItem(impl_did, ref impl_item)) => {\n+        FoundAst::Found(&InlinedItem::ImplItem(_, ref impl_item)) => {\n             ccx.external().borrow_mut().insert(fn_id, Some(impl_item.id));\n             ccx.external_srcs().borrow_mut().insert(impl_item.id, fn_id);\n \n             ccx.stats().n_inlines.set(ccx.stats().n_inlines.get() + 1);\n \n-            // Translate monomorphic impl methods immediately.\n-            if let hir::ImplItemKind::Method(ref sig, ref body) = impl_item.node {\n-                let impl_tpt = tcx.lookup_item_type(impl_did);\n-                if impl_tpt.generics.types.is_empty() &&\n-                        sig.generics.ty_params.is_empty() {\n-                    let def_id = tcx.map.local_def_id(impl_item.id);\n-                    let empty_substs = ccx.empty_substs_for_def_id(def_id);\n-                    let llfn = Callee::def(ccx, def_id, empty_substs).reify(ccx).val;\n-                    trans_fn(ccx,\n-                             &sig.decl,\n-                             body,\n-                             llfn,\n-                             empty_substs,\n-                             impl_item.id);\n-                    // See linkage comments on items.\n-                    if ccx.sess().opts.cg.codegen_units == 1 {\n-                        SetLinkage(llfn, InternalLinkage);\n-                    } else {\n-                        SetLinkage(llfn, AvailableExternallyLinkage);\n-                    }\n-                }\n-            }\n-\n             impl_item.id\n         }\n     };\n@@ -184,3 +135,12 @@ pub fn get_local_instance(ccx: &CrateContext, fn_id: DefId)\n pub fn maybe_instantiate_inline(ccx: &CrateContext, fn_id: DefId) -> DefId {\n     get_local_instance(ccx, fn_id).unwrap_or(fn_id)\n }\n+\n+pub fn maybe_inline_instance<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n+                                       instance: Instance<'tcx>) -> Instance<'tcx> {\n+    let def_id = maybe_instantiate_inline(ccx, instance.def);\n+    Instance {\n+        def: def_id,\n+        substs: instance.substs\n+    }\n+}"}, {"sha": "fa0a1fdc37523dbff9f012d6a0bb33f82baf93a1", "filename": "src/librustc_trans/lib.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d11936251a93d7395169dfab9088c4dde0cca180/src%2Flibrustc_trans%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d11936251a93d7395169dfab9088c4dde0cca180/src%2Flibrustc_trans%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Flib.rs?ref=d11936251a93d7395169dfab9088c4dde0cca180", "patch": "@@ -122,15 +122,17 @@ mod meth;\n mod mir;\n mod monomorphize;\n mod partitioning;\n+mod symbol_map;\n mod symbol_names_test;\n mod trans_item;\n mod tvec;\n mod type_;\n mod type_of;\n mod value;\n \n-#[derive(Copy, Clone)]\n+#[derive(Clone)]\n pub struct ModuleTranslation {\n+    pub name: String,\n     pub llcx: llvm::ContextRef,\n     pub llmod: llvm::ModuleRef,\n }"}, {"sha": "00c0e91103500d21a26f02eff544778948f2befd", "filename": "src/librustc_trans/monomorphize.rs", "status": "modified", "additions": 29, "deletions": 26, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/d11936251a93d7395169dfab9088c4dde0cca180/src%2Flibrustc_trans%2Fmonomorphize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d11936251a93d7395169dfab9088c4dde0cca180/src%2Flibrustc_trans%2Fmonomorphize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmonomorphize.rs?ref=d11936251a93d7395169dfab9088c4dde0cca180", "patch": "@@ -17,7 +17,6 @@ use rustc::ty::subst::{Subst, Substs};\n use rustc::ty::{self, Ty, TypeFoldable, TyCtxt};\n use attributes;\n use base::{push_ctxt};\n-use base::trans_fn;\n use base;\n use common::*;\n use declare;\n@@ -27,17 +26,16 @@ use rustc::util::ppaux;\n \n use rustc::hir;\n \n-use syntax::attr;\n use errors;\n \n use std::fmt;\n+use trans_item::TransItem;\n \n pub fn monomorphic_fn<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n                                 fn_id: DefId,\n                                 psubsts: &'tcx subst::Substs<'tcx>)\n                                 -> (ValueRef, Ty<'tcx>) {\n     debug!(\"monomorphic_fn(fn_id={:?}, real_substs={:?})\", fn_id, psubsts);\n-\n     assert!(!psubsts.types.needs_infer() && !psubsts.types.has_param_types());\n \n     let _icx = push_ctxt(\"monomorphic_fn\");\n@@ -53,6 +51,8 @@ pub fn monomorphic_fn<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n     if let Some(&val) = ccx.instances().borrow().get(&instance) {\n         debug!(\"leaving monomorphic fn {:?}\", instance);\n         return (val, mono_ty);\n+    } else {\n+        assert!(!ccx.codegen_unit().items.contains_key(&TransItem::Fn(instance)));\n     }\n \n     debug!(\"monomorphic_fn({:?})\", instance);\n@@ -84,9 +84,10 @@ pub fn monomorphic_fn<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n         monomorphizing.insert(fn_id, depth + 1);\n     }\n \n-    let symbol = instance.symbol_name(ccx.shared());\n+    let symbol = ccx.symbol_map().get_or_compute(ccx.shared(),\n+                                                 TransItem::Fn(instance));\n \n-    debug!(\"monomorphize_fn mangled to {}\", symbol);\n+    debug!(\"monomorphize_fn mangled to {}\", &symbol);\n     assert!(declare::get_defined_value(ccx, &symbol).is_none());\n \n     // FIXME(nagisa): perhaps needs a more fine grained selection?\n@@ -109,33 +110,35 @@ pub fn monomorphic_fn<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n         });\n     match map_node {\n         hir_map::NodeItem(&hir::Item {\n-            ref attrs, node: hir::ItemFn(ref decl, _, _, _, _, ref body), ..\n-        }) |\n-        hir_map::NodeTraitItem(&hir::TraitItem {\n-            ref attrs, node: hir::MethodTraitItem(\n-                hir::MethodSig { ref decl, .. }, Some(ref body)), ..\n+            ref attrs,\n+            node: hir::ItemFn(..), ..\n         }) |\n         hir_map::NodeImplItem(&hir::ImplItem {\n             ref attrs, node: hir::ImplItemKind::Method(\n-                hir::MethodSig { ref decl, .. }, ref body), ..\n+                hir::MethodSig { .. }, _), ..\n+        }) |\n+        hir_map::NodeTraitItem(&hir::TraitItem {\n+            ref attrs, node: hir::MethodTraitItem(\n+                hir::MethodSig { .. }, Some(_)), ..\n         }) => {\n-            attributes::from_fn_attrs(ccx, attrs, lldecl);\n-\n-            let is_first = !ccx.available_monomorphizations().borrow()\n-                                                             .contains(&symbol);\n-            if is_first {\n-                ccx.available_monomorphizations().borrow_mut().insert(symbol.clone());\n-            }\n+            let trans_item = TransItem::Fn(instance);\n \n-            let trans_everywhere = attr::requests_inline(attrs);\n-            if trans_everywhere || is_first {\n-                let origin = if is_first { base::OriginalTranslation } else { base::InlinedCopy };\n-                base::update_linkage(ccx, lldecl, None, origin);\n-                trans_fn(ccx, decl, body, lldecl, psubsts, fn_node_id);\n-            } else {\n-                // We marked the value as using internal linkage earlier, but that is illegal for\n-                // declarations, so switch back to external linkage.\n+            if ccx.shared().translation_items().borrow().contains(&trans_item) {\n+                attributes::from_fn_attrs(ccx, attrs, lldecl);\n                 llvm::SetLinkage(lldecl, llvm::ExternalLinkage);\n+            } else {\n+                // FIXME: #34151\n+                // Normally, getting here would indicate a bug in trans::collector,\n+                // since it seems to have missed a translation item. When we are\n+                // translating with non-MIR based trans, however, the results of\n+                // the collector are not entirely reliable since it bases its\n+                // analysis on MIR. Thus, we'll instantiate the missing function\n+                // privately in this codegen unit, so that things keep working.\n+                ccx.stats().n_fallback_instantiations.set(ccx.stats()\n+                                                             .n_fallback_instantiations\n+                                                             .get() + 1);\n+                trans_item.predefine(ccx, llvm::InternalLinkage);\n+                trans_item.define(ccx);\n             }\n         }\n "}, {"sha": "8073359ede87ebc058689e317e484ac862390aac", "filename": "src/librustc_trans/partitioning.rs", "status": "modified", "additions": 217, "deletions": 35, "changes": 252, "blob_url": "https://github.com/rust-lang/rust/blob/d11936251a93d7395169dfab9088c4dde0cca180/src%2Flibrustc_trans%2Fpartitioning.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d11936251a93d7395169dfab9088c4dde0cca180/src%2Flibrustc_trans%2Fpartitioning.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fpartitioning.rs?ref=d11936251a93d7395169dfab9088c4dde0cca180", "patch": "@@ -121,16 +121,15 @@ use llvm;\n use monomorphize;\n use rustc::hir::def_id::DefId;\n use rustc::hir::map::DefPathData;\n+use rustc::session::config::NUMBERED_CODEGEN_UNIT_MARKER;\n use rustc::ty::TyCtxt;\n use rustc::ty::item_path::characteristic_def_id_of_type;\n+use std::cmp::Ordering;\n+use symbol_map::SymbolMap;\n+use syntax::ast::NodeId;\n use syntax::parse::token::{self, InternedString};\n use trans_item::TransItem;\n-use util::nodemap::{FnvHashMap, FnvHashSet};\n-\n-pub struct CodegenUnit<'tcx> {\n-    pub name: InternedString,\n-    pub items: FnvHashMap<TransItem<'tcx>, llvm::Linkage>,\n-}\n+use util::nodemap::{FnvHashMap, FnvHashSet, NodeSet};\n \n pub enum PartitioningStrategy {\n     /// Generate one codegen unit per source-level module.\n@@ -140,25 +139,95 @@ pub enum PartitioningStrategy {\n     FixedUnitCount(usize)\n }\n \n+pub struct CodegenUnit<'tcx> {\n+    pub name: InternedString,\n+    pub items: FnvHashMap<TransItem<'tcx>, llvm::Linkage>,\n+}\n+\n+impl<'tcx> CodegenUnit<'tcx> {\n+    pub fn items_in_deterministic_order(&self,\n+                                        tcx: TyCtxt,\n+                                        symbol_map: &SymbolMap)\n+                                        -> Vec<(TransItem<'tcx>, llvm::Linkage)> {\n+        let mut items: Vec<(TransItem<'tcx>, llvm::Linkage)> =\n+            self.items.iter().map(|(item, linkage)| (*item, *linkage)).collect();\n+\n+        // The codegen tests rely on items being process in the same order as\n+        // they appear in the file, so for local items, we sort by node_id first\n+        items.sort_by(|&(trans_item1, _), &(trans_item2, _)| {\n+            let node_id1 = local_node_id(tcx, trans_item1);\n+            let node_id2 = local_node_id(tcx, trans_item2);\n+\n+            match (node_id1, node_id2) {\n+                (None, None) => {\n+                    let symbol_name1 = symbol_map.get(trans_item1).unwrap();\n+                    let symbol_name2 = symbol_map.get(trans_item2).unwrap();\n+                    symbol_name1.cmp(symbol_name2)\n+                }\n+                // In the following two cases we can avoid looking up the symbol\n+                (None, Some(_)) => Ordering::Less,\n+                (Some(_), None) => Ordering::Greater,\n+                (Some(node_id1), Some(node_id2)) => {\n+                    let ordering = node_id1.cmp(&node_id2);\n+\n+                    if ordering != Ordering::Equal {\n+                        return ordering;\n+                    }\n+\n+                    let symbol_name1 = symbol_map.get(trans_item1).unwrap();\n+                    let symbol_name2 = symbol_map.get(trans_item2).unwrap();\n+                    symbol_name1.cmp(symbol_name2)\n+                }\n+            }\n+        });\n+\n+        return items;\n+\n+        fn local_node_id(tcx: TyCtxt, trans_item: TransItem) -> Option<NodeId> {\n+            match trans_item {\n+                TransItem::Fn(instance) => {\n+                    tcx.map.as_local_node_id(instance.def)\n+                }\n+                TransItem::Static(node_id) => Some(node_id),\n+                TransItem::DropGlue(_) => None,\n+            }\n+        }\n+    }\n+}\n+\n+\n // Anything we can't find a proper codegen unit for goes into this.\n const FALLBACK_CODEGEN_UNIT: &'static str = \"__rustc_fallback_codegen_unit\";\n \n pub fn partition<'a, 'tcx, I>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                               trans_items: I,\n                               strategy: PartitioningStrategy,\n-                              inlining_map: &InliningMap<'tcx>)\n+                              inlining_map: &InliningMap<'tcx>,\n+                              reachable: &NodeSet)\n                               -> Vec<CodegenUnit<'tcx>>\n     where I: Iterator<Item = TransItem<'tcx>>\n {\n+    if let PartitioningStrategy::FixedUnitCount(1) = strategy {\n+        // If there is only a single codegen-unit, we can use a very simple\n+        // scheme and don't have to bother with doing much analysis.\n+        return vec![single_codegen_unit(tcx, trans_items, reachable)];\n+    }\n+\n     // In the first step, we place all regular translation items into their\n     // respective 'home' codegen unit. Regular translation items are all\n     // functions and statics defined in the local crate.\n-    let mut initial_partitioning = place_root_translation_items(tcx, trans_items);\n+    let mut initial_partitioning = place_root_translation_items(tcx,\n+                                                                trans_items,\n+                                                                reachable);\n+\n+    debug_dump(tcx, \"INITIAL PARTITONING:\", initial_partitioning.codegen_units.iter());\n \n     // If the partitioning should produce a fixed count of codegen units, merge\n     // until that count is reached.\n     if let PartitioningStrategy::FixedUnitCount(count) = strategy {\n         merge_codegen_units(&mut initial_partitioning, count, &tcx.crate_name[..]);\n+\n+        debug_dump(tcx, \"POST MERGING:\", initial_partitioning.codegen_units.iter());\n     }\n \n     // In the next step, we use the inlining map to determine which addtional\n@@ -167,7 +236,16 @@ pub fn partition<'a, 'tcx, I>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     // local functions the definition of which is marked with #[inline].\n     let post_inlining = place_inlined_translation_items(initial_partitioning,\n                                                         inlining_map);\n-    post_inlining.0\n+\n+    debug_dump(tcx, \"POST INLINING:\", post_inlining.0.iter());\n+\n+    // Finally, sort by codegen unit name, so that we get deterministic results\n+    let mut result = post_inlining.0;\n+    result.sort_by(|cgu1, cgu2| {\n+        (&cgu1.name[..]).cmp(&cgu2.name[..])\n+    });\n+\n+    result\n }\n \n struct PreInliningPartitioning<'tcx> {\n@@ -178,23 +256,20 @@ struct PreInliningPartitioning<'tcx> {\n struct PostInliningPartitioning<'tcx>(Vec<CodegenUnit<'tcx>>);\n \n fn place_root_translation_items<'a, 'tcx, I>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                                             trans_items: I)\n+                                             trans_items: I,\n+                                             _reachable: &NodeSet)\n                                              -> PreInliningPartitioning<'tcx>\n     where I: Iterator<Item = TransItem<'tcx>>\n {\n     let mut roots = FnvHashSet();\n     let mut codegen_units = FnvHashMap();\n \n     for trans_item in trans_items {\n-        let is_root = match trans_item {\n-            TransItem::Static(..) => true,\n-            TransItem::DropGlue(..) => false,\n-            TransItem::Fn(_) => !trans_item.is_from_extern_crate(),\n-        };\n+        let is_root = !trans_item.is_instantiated_only_on_demand();\n \n         if is_root {\n             let characteristic_def_id = characteristic_def_id_of_trans_item(tcx, trans_item);\n-            let is_volatile = trans_item.is_lazily_instantiated();\n+            let is_volatile = trans_item.is_generic_fn();\n \n             let codegen_unit_name = match characteristic_def_id {\n                 Some(def_id) => compute_codegen_unit_name(tcx, def_id, is_volatile),\n@@ -218,7 +293,18 @@ fn place_root_translation_items<'a, 'tcx, I>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                         TransItem::Static(..) => llvm::ExternalLinkage,\n                         TransItem::DropGlue(..) => unreachable!(),\n                         // Is there any benefit to using ExternalLinkage?:\n-                        TransItem::Fn(..) => llvm::WeakODRLinkage,\n+                        TransItem::Fn(ref instance) => {\n+                            if instance.substs.types.is_empty() {\n+                                // This is a non-generic functions, we always\n+                                // make it visible externally on the chance that\n+                                // it might be used in another codegen unit.\n+                                llvm::ExternalLinkage\n+                            } else {\n+                                // In the current setup, generic functions cannot\n+                                // be roots.\n+                                unreachable!()\n+                            }\n+                        }\n                     }\n                 }\n             };\n@@ -258,7 +344,7 @@ fn merge_codegen_units<'tcx>(initial_partitioning: &mut PreInliningPartitioning<\n     // translation items in a given unit. This could be improved on.\n     while codegen_units.len() > target_cgu_count {\n         // Sort small cgus to the back\n-        codegen_units.as_mut_slice().sort_by_key(|cgu| -(cgu.items.len() as i64));\n+        codegen_units.sort_by_key(|cgu| -(cgu.items.len() as i64));\n         let smallest = codegen_units.pop().unwrap();\n         let second_smallest = codegen_units.last_mut().unwrap();\n \n@@ -281,10 +367,6 @@ fn merge_codegen_units<'tcx>(initial_partitioning: &mut PreInliningPartitioning<\n             items: FnvHashMap()\n         });\n     }\n-\n-    fn numbered_codegen_unit_name(crate_name: &str, index: usize) -> InternedString {\n-        token::intern_and_get_ident(&format!(\"{}.{}\", crate_name, index)[..])\n-    }\n }\n \n fn place_inlined_translation_items<'tcx>(initial_partitioning: PreInliningPartitioning<'tcx>,\n@@ -309,20 +391,30 @@ fn place_inlined_translation_items<'tcx>(initial_partitioning: PreInliningPartit\n             if let Some(linkage) = codegen_unit.items.get(&trans_item) {\n                 // This is a root, just copy it over\n                 new_codegen_unit.items.insert(trans_item, *linkage);\n+            } else if initial_partitioning.roots.contains(&trans_item) {\n+                // This item will be instantiated in some other codegen unit,\n+                // so we just add it here with AvailableExternallyLinkage\n+                // FIXME(mw): I have not seen it happening yet but having\n+                //            available_externally here could potentially lead\n+                //            to the same problem with exception handling tables\n+                //            as in the case below.\n+                new_codegen_unit.items.insert(trans_item,\n+                                              llvm::AvailableExternallyLinkage);\n+            } else if trans_item.is_from_extern_crate() && !trans_item.is_generic_fn() {\n+                // FIXME(mw): It would be nice if we could mark these as\n+                // `AvailableExternallyLinkage`, since they should have\n+                // been instantiated in the extern crate. But this\n+                // sometimes leads to crashes on Windows because LLVM\n+                // does not handle exception handling table instantiation\n+                // reliably in that case.\n+                new_codegen_unit.items.insert(trans_item, llvm::InternalLinkage);\n             } else {\n-                if initial_partitioning.roots.contains(&trans_item) {\n-                    // This item will be instantiated in some other codegen unit,\n-                    // so we just add it here with AvailableExternallyLinkage\n-                    new_codegen_unit.items.insert(trans_item,\n-                                                  llvm::AvailableExternallyLinkage);\n-                } else {\n-                    // We can't be sure if this will also be instantiated\n-                    // somewhere else, so we add an instance here with\n-                    // LinkOnceODRLinkage. That way the item can be discarded if\n-                    // it's not needed (inlined) after all.\n-                    new_codegen_unit.items.insert(trans_item,\n-                                                  llvm::LinkOnceODRLinkage);\n-                }\n+                assert!(trans_item.is_instantiated_only_on_demand());\n+                // We can't be sure if this will also be instantiated\n+                // somewhere else, so we add an instance here with\n+                // InternalLinkage so we don't get any conflicts.\n+                new_codegen_unit.items.insert(trans_item,\n+                                              llvm::InternalLinkage);\n             }\n         }\n \n@@ -410,3 +502,93 @@ fn compute_codegen_unit_name<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n \n     return token::intern_and_get_ident(&mod_path[..]);\n }\n+\n+fn single_codegen_unit<'a, 'tcx, I>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                                    trans_items: I,\n+                                    reachable: &NodeSet)\n+                                    -> CodegenUnit<'tcx>\n+    where I: Iterator<Item = TransItem<'tcx>>\n+{\n+    let mut items = FnvHashMap();\n+\n+    for trans_item in trans_items {\n+        let linkage = trans_item.explicit_linkage(tcx).unwrap_or_else(|| {\n+            match trans_item {\n+                TransItem::Static(node_id) => {\n+                    if reachable.contains(&node_id) {\n+                        llvm::ExternalLinkage\n+                    } else {\n+                        llvm::PrivateLinkage\n+                    }\n+                }\n+                TransItem::DropGlue(_) => {\n+                    llvm::InternalLinkage\n+                }\n+                TransItem::Fn(instance) => {\n+                    if trans_item.is_generic_fn() {\n+                        // FIXME(mw): Assigning internal linkage to all\n+                        // monomorphizations is potentially a waste of space\n+                        // since monomorphizations could be shared between\n+                        // crates. The main reason for making them internal is\n+                        // a limitation in MingW's binutils that cannot deal\n+                        // with COFF object that have more than 2^15 sections,\n+                        // which is something that can happen for large programs\n+                        // when every function gets put into its own COMDAT\n+                        // section.\n+                        llvm::InternalLinkage\n+                    } else if trans_item.is_from_extern_crate() {\n+                        // FIXME(mw): It would be nice if we could mark these as\n+                        // `AvailableExternallyLinkage`, since they should have\n+                        // been instantiated in the extern crate. But this\n+                        // sometimes leads to crashes on Windows because LLVM\n+                        // does not handle exception handling table instantiation\n+                        // reliably in that case.\n+                        llvm::InternalLinkage\n+                    } else if reachable.contains(&tcx.map\n+                                                     .as_local_node_id(instance.def)\n+                                                     .unwrap()) {\n+                        llvm::ExternalLinkage\n+                    } else {\n+                        // Functions that are not visible outside this crate can\n+                        // be marked as internal.\n+                        llvm::InternalLinkage\n+                    }\n+                }\n+            }\n+        });\n+\n+        items.insert(trans_item, linkage);\n+    }\n+\n+    CodegenUnit {\n+        name: numbered_codegen_unit_name(&tcx.crate_name[..], 0),\n+        items: items\n+    }\n+}\n+\n+fn numbered_codegen_unit_name(crate_name: &str, index: usize) -> InternedString {\n+    token::intern_and_get_ident(&format!(\"{}{}{}\",\n+        crate_name,\n+        NUMBERED_CODEGEN_UNIT_MARKER,\n+        index)[..])\n+}\n+\n+fn debug_dump<'a, 'b, 'tcx, I>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                               label: &str,\n+                               cgus: I)\n+    where I: Iterator<Item=&'b CodegenUnit<'tcx>>,\n+          'tcx: 'a + 'b\n+{\n+    if cfg!(debug_assertions) {\n+        debug!(\"{}\", label);\n+        for cgu in cgus {\n+            debug!(\"CodegenUnit {}:\", cgu.name);\n+\n+            for (trans_item, linkage) in &cgu.items {\n+                debug!(\" - {} [{:?}]\", trans_item.to_string(tcx), linkage);\n+            }\n+\n+            debug!(\"\");\n+        }\n+    }\n+}"}, {"sha": "3faaa085dce14f3721642bd610065cab672f05db", "filename": "src/librustc_trans/symbol_map.rs", "status": "added", "additions": 128, "deletions": 0, "changes": 128, "blob_url": "https://github.com/rust-lang/rust/blob/d11936251a93d7395169dfab9088c4dde0cca180/src%2Flibrustc_trans%2Fsymbol_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d11936251a93d7395169dfab9088c4dde0cca180/src%2Flibrustc_trans%2Fsymbol_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fsymbol_map.rs?ref=d11936251a93d7395169dfab9088c4dde0cca180", "patch": "@@ -0,0 +1,128 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use context::SharedCrateContext;\n+use monomorphize::Instance;\n+use rustc::ty::TyCtxt;\n+use std::borrow::Cow;\n+use syntax::codemap::Span;\n+use trans_item::TransItem;\n+use util::nodemap::FnvHashMap;\n+\n+// In the SymbolMap we collect the symbol names of all translation items of\n+// the current crate. This map exists as a performance optimization. Symbol\n+// names of translation items are deterministic and fully defined by the item.\n+// Thus they could also always be recomputed if needed.\n+\n+pub struct SymbolMap<'tcx> {\n+    index: FnvHashMap<TransItem<'tcx>, (usize, usize)>,\n+    arena: String,\n+}\n+\n+impl<'tcx> SymbolMap<'tcx> {\n+\n+    pub fn build<'a, I>(scx: &SharedCrateContext<'a, 'tcx>,\n+                        trans_items: I)\n+                        -> SymbolMap<'tcx>\n+        where I: Iterator<Item=TransItem<'tcx>>\n+    {\n+        // Check for duplicate symbol names\n+        let mut symbols: Vec<_> = trans_items.map(|trans_item| {\n+            (trans_item, trans_item.compute_symbol_name(scx))\n+        }).collect();\n+\n+        (&mut symbols[..]).sort_by(|&(_, ref sym1), &(_, ref sym2)|{\n+            sym1.cmp(sym2)\n+        });\n+\n+        for pair in (&symbols[..]).windows(2) {\n+            let sym1 = &pair[0].1;\n+            let sym2 = &pair[1].1;\n+\n+            if *sym1 == *sym2 {\n+                let trans_item1 = pair[0].0;\n+                let trans_item2 = pair[1].0;\n+\n+                let span1 = get_span(scx.tcx(), trans_item1);\n+                let span2 = get_span(scx.tcx(), trans_item2);\n+\n+                // Deterministically select one of the spans for error reporting\n+                let span = match (span1, span2) {\n+                    (Some(span1), Some(span2)) => {\n+                        Some(if span1.lo.0 > span2.lo.0 {\n+                            span1\n+                        } else {\n+                            span2\n+                        })\n+                    }\n+                    (Some(span), None) |\n+                    (None, Some(span)) => Some(span),\n+                    _ => None\n+                };\n+\n+                let error_message = format!(\"symbol `{}` is already defined\", sym1);\n+\n+                if let Some(span) = span {\n+                    scx.sess().span_fatal(span, &error_message)\n+                } else {\n+                    scx.sess().fatal(&error_message)\n+                }\n+            }\n+        }\n+\n+        let mut symbol_map = SymbolMap {\n+            index: FnvHashMap(),\n+            arena: String::with_capacity(1024),\n+        };\n+\n+        for (trans_item, symbol) in symbols {\n+            let start_index = symbol_map.arena.len();\n+            symbol_map.arena.push_str(&symbol[..]);\n+            let end_index = symbol_map.arena.len();\n+            let prev_entry = symbol_map.index.insert(trans_item,\n+                                                     (start_index, end_index));\n+            if prev_entry.is_some() {\n+                bug!(\"TransItem encountered twice?\")\n+            }\n+        }\n+\n+        fn get_span<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                              trans_item: TransItem<'tcx>) -> Option<Span> {\n+            match trans_item {\n+                TransItem::Fn(Instance { def, .. }) => {\n+                    tcx.map.as_local_node_id(def)\n+                }\n+                TransItem::Static(node_id) => Some(node_id),\n+                TransItem::DropGlue(_) => None,\n+            }.map(|node_id| {\n+                tcx.map.span(node_id)\n+            })\n+        }\n+\n+        symbol_map\n+    }\n+\n+    pub fn get(&self, trans_item: TransItem<'tcx>) -> Option<&str> {\n+        self.index.get(&trans_item).map(|&(start_index, end_index)| {\n+            &self.arena[start_index .. end_index]\n+        })\n+    }\n+\n+    pub fn get_or_compute<'map, 'scx>(&'map self,\n+                                      scx: &SharedCrateContext<'scx, 'tcx>,\n+                                      trans_item: TransItem<'tcx>)\n+                                      -> Cow<'map, str> {\n+        if let Some(sym) = self.get(trans_item) {\n+            Cow::from(sym)\n+        } else {\n+            Cow::from(trans_item.compute_symbol_name(scx))\n+        }\n+    }\n+}"}, {"sha": "9a7fe54e0d9f5a9f3dc55cfb96e9efc8af1294e2", "filename": "src/librustc_trans/symbol_names_test.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/d11936251a93d7395169dfab9088c4dde0cca180/src%2Flibrustc_trans%2Fsymbol_names_test.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d11936251a93d7395169dfab9088c4dde0cca180/src%2Flibrustc_trans%2Fsymbol_names_test.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fsymbol_names_test.rs?ref=d11936251a93d7395169dfab9088c4dde0cca180", "patch": "@@ -19,40 +19,40 @@ use rustc::hir::intravisit::{self, Visitor};\n use syntax::ast;\n use syntax::attr::AttrMetaMethods;\n \n-use common::CrateContext;\n+use common::SharedCrateContext;\n use monomorphize::Instance;\n \n const SYMBOL_NAME: &'static str = \"rustc_symbol_name\";\n const ITEM_PATH: &'static str = \"rustc_item_path\";\n \n-pub fn report_symbol_names(ccx: &CrateContext) {\n+pub fn report_symbol_names(scx: &SharedCrateContext) {\n     // if the `rustc_attrs` feature is not enabled, then the\n     // attributes we are interested in cannot be present anyway, so\n     // skip the walk.\n-    let tcx = ccx.tcx();\n+    let tcx = scx.tcx();\n     if !tcx.sess.features.borrow().rustc_attrs {\n         return;\n     }\n \n     let _ignore = tcx.dep_graph.in_ignore();\n-    let mut visitor = SymbolNamesTest { ccx: ccx };\n+    let mut visitor = SymbolNamesTest { scx: scx };\n     tcx.map.krate().visit_all_items(&mut visitor);\n }\n \n struct SymbolNamesTest<'a, 'tcx:'a> {\n-    ccx: &'a CrateContext<'a, 'tcx>,\n+    scx: &'a SharedCrateContext<'a, 'tcx>,\n }\n \n impl<'a, 'tcx> SymbolNamesTest<'a, 'tcx> {\n     fn process_attrs(&mut self,\n                      node_id: ast::NodeId) {\n-        let tcx = self.ccx.tcx();\n+        let tcx = self.scx.tcx();\n         let def_id = tcx.map.local_def_id(node_id);\n         for attr in tcx.get_attrs(def_id).iter() {\n             if attr.check_name(SYMBOL_NAME) {\n                 // for now, can only use on monomorphic names\n-                let instance = Instance::mono(self.ccx.shared(), def_id);\n-                let name = instance.symbol_name(self.ccx.shared());\n+                let instance = Instance::mono(self.scx, def_id);\n+                let name = instance.symbol_name(self.scx);\n                 tcx.sess.span_err(attr.span, &format!(\"symbol-name({})\", name));\n             } else if attr.check_name(ITEM_PATH) {\n                 let path = tcx.item_path_str(def_id);"}, {"sha": "b7b18b2631bee91f5148405b28713265fa0b9758", "filename": "src/librustc_trans/trans_item.rs", "status": "modified", "additions": 322, "deletions": 109, "changes": 431, "blob_url": "https://github.com/rust-lang/rust/blob/d11936251a93d7395169dfab9088c4dde0cca180/src%2Flibrustc_trans%2Ftrans_item.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d11936251a93d7395169dfab9088c4dde0cca180/src%2Flibrustc_trans%2Ftrans_item.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans_item.rs?ref=d11936251a93d7395169dfab9088c4dde0cca180", "patch": "@@ -14,18 +14,28 @@\n //! item-path. This is used for unit testing the code that generates\n //! paths etc in all kinds of annoying scenarios.\n \n-use base::llvm_linkage_by_name;\n+use attributes;\n+use base;\n+use consts;\n+use context::{CrateContext, SharedCrateContext};\n+use declare;\n use glue::DropGlueKind;\n use llvm;\n-use monomorphize::Instance;\n+use monomorphize::{self, Instance};\n+use inline;\n use rustc::hir;\n+use rustc::hir::map as hir_map;\n use rustc::hir::def_id::DefId;\n-use rustc::ty::{self, Ty, TyCtxt};\n+use rustc::ty::{self, Ty, TyCtxt, TypeFoldable};\n use rustc::ty::subst;\n use std::hash::{Hash, Hasher};\n use syntax::ast::{self, NodeId};\n-use syntax::attr;\n+use syntax::{attr,errors};\n use syntax::parse::token;\n+use type_of;\n+use glue;\n+use abi::{Abi, FnType};\n+use back::symbol_names;\n \n #[derive(PartialEq, Eq, Clone, Copy, Debug)]\n pub enum TransItem<'tcx> {\n@@ -54,6 +64,314 @@ impl<'tcx> Hash for TransItem<'tcx> {\n     }\n }\n \n+impl<'a, 'tcx> TransItem<'tcx> {\n+\n+    pub fn define(&self, ccx: &CrateContext<'a, 'tcx>) {\n+\n+        debug!(\"BEGIN IMPLEMENTING '{} ({})' in cgu {}\",\n+                  self.to_string(ccx.tcx()),\n+                  self.to_raw_string(),\n+                  ccx.codegen_unit().name);\n+\n+        match *self {\n+            TransItem::Static(node_id) => {\n+                let item = ccx.tcx().map.expect_item(node_id);\n+                if let hir::ItemStatic(_, m, ref expr) = item.node {\n+                    match consts::trans_static(&ccx, m, expr, item.id, &item.attrs) {\n+                        Ok(_) => { /* Cool, everything's alright. */ },\n+                        Err(err) => ccx.tcx().sess.span_fatal(expr.span, &err.description()),\n+                    };\n+                } else {\n+                    span_bug!(item.span, \"Mismatch between hir::Item type and TransItem type\")\n+                }\n+            }\n+            TransItem::Fn(instance) => {\n+                base::trans_instance(&ccx, instance);\n+            }\n+            TransItem::DropGlue(dg) => {\n+                glue::implement_drop_glue(&ccx, dg);\n+            }\n+        }\n+\n+        debug!(\"END IMPLEMENTING '{} ({})' in cgu {}\",\n+               self.to_string(ccx.tcx()),\n+               self.to_raw_string(),\n+               ccx.codegen_unit().name);\n+    }\n+\n+    pub fn predefine(&self,\n+                     ccx: &CrateContext<'a, 'tcx>,\n+                     linkage: llvm::Linkage) {\n+        debug!(\"BEGIN PREDEFINING '{} ({})' in cgu {}\",\n+               self.to_string(ccx.tcx()),\n+               self.to_raw_string(),\n+               ccx.codegen_unit().name);\n+\n+        let symbol_name = ccx.symbol_map()\n+                             .get_or_compute(ccx.shared(), *self);\n+\n+        debug!(\"symbol {}\", &symbol_name);\n+\n+        match *self {\n+            TransItem::Static(node_id) => {\n+                TransItem::predefine_static(ccx, node_id, linkage, &symbol_name);\n+            }\n+            TransItem::Fn(instance) => {\n+                TransItem::predefine_fn(ccx, instance, linkage, &symbol_name);\n+            }\n+            TransItem::DropGlue(dg) => {\n+                TransItem::predefine_drop_glue(ccx, dg, linkage, &symbol_name);\n+            }\n+        }\n+\n+        debug!(\"END PREDEFINING '{} ({})' in cgu {}\",\n+               self.to_string(ccx.tcx()),\n+               self.to_raw_string(),\n+               ccx.codegen_unit().name);\n+    }\n+\n+    fn predefine_static(ccx: &CrateContext<'a, 'tcx>,\n+                        node_id: ast::NodeId,\n+                        linkage: llvm::Linkage,\n+                        symbol_name: &str) {\n+        let def_id = ccx.tcx().map.local_def_id(node_id);\n+        let ty = ccx.tcx().lookup_item_type(def_id).ty;\n+        let llty = type_of::type_of(ccx, ty);\n+\n+        match ccx.tcx().map.get(node_id) {\n+            hir::map::NodeItem(&hir::Item {\n+                span, node: hir::ItemStatic(..), ..\n+            }) => {\n+                let g = declare::define_global(ccx, symbol_name, llty).unwrap_or_else(|| {\n+                    ccx.sess().span_fatal(span,\n+                        &format!(\"symbol `{}` is already defined\", symbol_name))\n+                });\n+\n+                llvm::SetLinkage(g, linkage);\n+            }\n+\n+            item => bug!(\"predefine_static: expected static, found {:?}\", item)\n+        }\n+    }\n+\n+    fn predefine_fn(ccx: &CrateContext<'a, 'tcx>,\n+                    instance: Instance<'tcx>,\n+                    linkage: llvm::Linkage,\n+                    symbol_name: &str) {\n+        assert!(!instance.substs.types.needs_infer() &&\n+                !instance.substs.types.has_param_types());\n+\n+        let instance = inline::maybe_inline_instance(ccx, instance);\n+\n+        let item_ty = ccx.tcx().lookup_item_type(instance.def).ty;\n+        let item_ty = ccx.tcx().erase_regions(&item_ty);\n+        let mono_ty = monomorphize::apply_param_substs(ccx.tcx(), instance.substs, &item_ty);\n+\n+        let fn_node_id = ccx.tcx().map.as_local_node_id(instance.def).unwrap();\n+        let map_node = errors::expect(\n+            ccx.sess().diagnostic(),\n+            ccx.tcx().map.find(fn_node_id),\n+            || {\n+                format!(\"while instantiating `{}`, couldn't find it in \\\n+                     the item map (may have attempted to monomorphize \\\n+                     an item defined in a different crate?)\",\n+                    instance)\n+            });\n+\n+        match map_node {\n+            hir_map::NodeItem(&hir::Item {\n+                ref attrs, node: hir::ItemFn(..), ..\n+            }) |\n+            hir_map::NodeTraitItem(&hir::TraitItem {\n+                ref attrs, node: hir::MethodTraitItem(..), ..\n+            }) |\n+            hir_map::NodeImplItem(&hir::ImplItem {\n+                ref attrs, node: hir::ImplItemKind::Method(..), ..\n+            }) => {\n+                let lldecl = declare::declare_fn(ccx, symbol_name, mono_ty);\n+                llvm::SetLinkage(lldecl, linkage);\n+                base::set_link_section(ccx, lldecl, attrs);\n+                if linkage == llvm::LinkOnceODRLinkage ||\n+                   linkage == llvm::WeakODRLinkage {\n+                    llvm::SetUniqueComdat(ccx.llmod(), lldecl);\n+                }\n+\n+                attributes::from_fn_attrs(ccx, attrs, lldecl);\n+                ccx.instances().borrow_mut().insert(instance, lldecl);\n+            }\n+            _ => bug!(\"Invalid item for TransItem::Fn: `{:?}`\", map_node)\n+        };\n+\n+    }\n+\n+    fn predefine_drop_glue(ccx: &CrateContext<'a, 'tcx>,\n+                           dg: glue::DropGlueKind<'tcx>,\n+                           linkage: llvm::Linkage,\n+                           symbol_name: &str) {\n+        let tcx = ccx.tcx();\n+        assert_eq!(dg.ty(), glue::get_drop_glue_type(tcx, dg.ty()));\n+        let t = dg.ty();\n+\n+        let sig = ty::FnSig {\n+            inputs: vec![tcx.mk_mut_ptr(tcx.types.i8)],\n+            output: ty::FnOutput::FnConverging(tcx.mk_nil()),\n+            variadic: false,\n+        };\n+\n+        // Create a FnType for fn(*mut i8) and substitute the real type in\n+        // later - that prevents FnType from splitting fat pointers up.\n+        let mut fn_ty = FnType::new(ccx, Abi::Rust, &sig, &[]);\n+        fn_ty.args[0].original_ty = type_of::type_of(ccx, t).ptr_to();\n+        let llfnty = fn_ty.llvm_type(ccx);\n+\n+        assert!(declare::get_defined_value(ccx, symbol_name).is_none());\n+        let llfn = declare::declare_cfn(ccx, symbol_name, llfnty);\n+        llvm::SetLinkage(llfn, linkage);\n+        if linkage == llvm::LinkOnceODRLinkage ||\n+           linkage == llvm::WeakODRLinkage {\n+            llvm::SetUniqueComdat(ccx.llmod(), llfn);\n+        }\n+        attributes::set_frame_pointer_elimination(ccx, llfn);\n+        ccx.drop_glues().borrow_mut().insert(dg, (llfn, fn_ty));\n+    }\n+\n+    pub fn compute_symbol_name(&self,\n+                               scx: &SharedCrateContext<'a, 'tcx>) -> String {\n+        match *self {\n+            TransItem::Fn(instance) => instance.symbol_name(scx),\n+            TransItem::Static(node_id) => {\n+                let def_id = scx.tcx().map.local_def_id(node_id);\n+                Instance::mono(scx, def_id).symbol_name(scx)\n+            }\n+            TransItem::DropGlue(dg) => {\n+                let prefix = match dg {\n+                    DropGlueKind::Ty(_) => \"drop\",\n+                    DropGlueKind::TyContents(_) => \"drop_contents\",\n+                };\n+                symbol_names::exported_name_from_type_and_prefix(scx, dg.ty(), prefix)\n+            }\n+        }\n+    }\n+\n+    pub fn requests_inline(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>) -> bool {\n+        match *self {\n+            TransItem::Fn(ref instance) => {\n+                !instance.substs.types.is_empty() || {\n+                    let attributes = tcx.get_attrs(instance.def);\n+                    attr::requests_inline(&attributes[..])\n+                }\n+            }\n+            TransItem::DropGlue(..) => true,\n+            TransItem::Static(..)   => false,\n+        }\n+    }\n+\n+    pub fn is_from_extern_crate(&self) -> bool {\n+        match *self {\n+            TransItem::Fn(ref instance) => !instance.def.is_local(),\n+            TransItem::DropGlue(..) |\n+            TransItem::Static(..)   => false,\n+        }\n+    }\n+\n+    pub fn is_instantiated_only_on_demand(&self) -> bool {\n+        match *self {\n+            TransItem::Fn(ref instance) => !instance.def.is_local() ||\n+                                           !instance.substs.types.is_empty(),\n+            TransItem::DropGlue(..) => true,\n+            TransItem::Static(..)   => false,\n+        }\n+    }\n+\n+    pub fn is_generic_fn(&self) -> bool {\n+        match *self {\n+            TransItem::Fn(ref instance) => !instance.substs.types.is_empty(),\n+            TransItem::DropGlue(..) |\n+            TransItem::Static(..)   => false,\n+        }\n+    }\n+\n+    pub fn explicit_linkage(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>) -> Option<llvm::Linkage> {\n+        let def_id = match *self {\n+            TransItem::Fn(ref instance) => instance.def,\n+            TransItem::Static(node_id) => tcx.map.local_def_id(node_id),\n+            TransItem::DropGlue(..) => return None,\n+        };\n+\n+        let attributes = tcx.get_attrs(def_id);\n+        if let Some(name) = attr::first_attr_value_str_by_name(&attributes, \"linkage\") {\n+            if let Some(linkage) = base::llvm_linkage_by_name(&name) {\n+                Some(linkage)\n+            } else {\n+                let span = tcx.map.span_if_local(def_id);\n+                if let Some(span) = span {\n+                    tcx.sess.span_fatal(span, \"invalid linkage specified\")\n+                } else {\n+                    tcx.sess.fatal(&format!(\"invalid linkage specified: {}\", name))\n+                }\n+            }\n+        } else {\n+            None\n+        }\n+    }\n+\n+    pub fn to_string(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>) -> String {\n+        let hir_map = &tcx.map;\n+\n+        return match *self {\n+            TransItem::DropGlue(dg) => {\n+                let mut s = String::with_capacity(32);\n+                match dg {\n+                    DropGlueKind::Ty(_) => s.push_str(\"drop-glue \"),\n+                    DropGlueKind::TyContents(_) => s.push_str(\"drop-glue-contents \"),\n+                };\n+                push_unique_type_name(tcx, dg.ty(), &mut s);\n+                s\n+            }\n+            TransItem::Fn(instance) => {\n+                to_string_internal(tcx, \"fn \", instance)\n+            },\n+            TransItem::Static(node_id) => {\n+                let def_id = hir_map.local_def_id(node_id);\n+                let instance = Instance::new(def_id,\n+                                             tcx.mk_substs(subst::Substs::empty()));\n+                to_string_internal(tcx, \"static \", instance)\n+            },\n+        };\n+\n+        fn to_string_internal<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                                        prefix: &str,\n+                                        instance: Instance<'tcx>)\n+                                        -> String {\n+            let mut result = String::with_capacity(32);\n+            result.push_str(prefix);\n+            push_instance_as_string(tcx, instance, &mut result);\n+            result\n+        }\n+    }\n+\n+    pub fn to_raw_string(&self) -> String {\n+        match *self {\n+            TransItem::DropGlue(dg) => {\n+                let prefix = match dg {\n+                    DropGlueKind::Ty(_) => \"Ty\",\n+                    DropGlueKind::TyContents(_) => \"TyContents\",\n+                };\n+                format!(\"DropGlue({}: {})\", prefix, dg.ty() as *const _ as usize)\n+            }\n+            TransItem::Fn(instance) => {\n+                format!(\"Fn({:?}, {})\",\n+                         instance.def,\n+                         instance.substs as *const _ as usize)\n+            }\n+            TransItem::Static(id) => {\n+                format!(\"Static({:?})\", id)\n+            }\n+        }\n+    }\n+}\n+\n+\n //=-----------------------------------------------------------------------------\n // TransItem String Keys\n //=-----------------------------------------------------------------------------\n@@ -277,108 +595,3 @@ pub fn type_to_string<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     push_unique_type_name(tcx, ty, &mut output);\n     output\n }\n-\n-impl<'tcx> TransItem<'tcx> {\n-\n-    pub fn requests_inline<'a>(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>) -> bool {\n-        match *self {\n-            TransItem::Fn(ref instance) => {\n-                let attributes = tcx.get_attrs(instance.def);\n-                attr::requests_inline(&attributes[..])\n-            }\n-            TransItem::DropGlue(..) => true,\n-            TransItem::Static(..)   => false,\n-        }\n-    }\n-\n-    pub fn is_from_extern_crate(&self) -> bool {\n-        match *self {\n-            TransItem::Fn(ref instance) => !instance.def.is_local(),\n-            TransItem::DropGlue(..) |\n-            TransItem::Static(..)   => false,\n-        }\n-    }\n-\n-    pub fn is_lazily_instantiated(&self) -> bool {\n-        match *self {\n-            TransItem::Fn(ref instance) => !instance.substs.types.is_empty(),\n-            TransItem::DropGlue(..) => true,\n-            TransItem::Static(..)   => false,\n-        }\n-    }\n-\n-    pub fn explicit_linkage<'a>(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>) -> Option<llvm::Linkage> {\n-        let def_id = match *self {\n-            TransItem::Fn(ref instance) => instance.def,\n-            TransItem::Static(node_id) => tcx.map.local_def_id(node_id),\n-            TransItem::DropGlue(..) => return None,\n-        };\n-\n-        let attributes = tcx.get_attrs(def_id);\n-        if let Some(name) = attr::first_attr_value_str_by_name(&attributes, \"linkage\") {\n-            if let Some(linkage) = llvm_linkage_by_name(&name) {\n-                Some(linkage)\n-            } else {\n-                let span = tcx.map.span_if_local(def_id);\n-                if let Some(span) = span {\n-                    tcx.sess.span_fatal(span, \"invalid linkage specified\")\n-                } else {\n-                    tcx.sess.fatal(&format!(\"invalid linkage specified: {}\", name))\n-                }\n-            }\n-        } else {\n-            None\n-        }\n-    }\n-\n-    pub fn to_string<'a>(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>) -> String {\n-        let hir_map = &tcx.map;\n-\n-        return match *self {\n-            TransItem::DropGlue(dg) => {\n-                let mut s = String::with_capacity(32);\n-                match dg {\n-                    DropGlueKind::Ty(_) => s.push_str(\"drop-glue \"),\n-                    DropGlueKind::TyContents(_) => s.push_str(\"drop-glue-contents \"),\n-                };\n-                push_unique_type_name(tcx, dg.ty(), &mut s);\n-                s\n-            }\n-            TransItem::Fn(instance) => {\n-                to_string_internal(tcx, \"fn \", instance)\n-            },\n-            TransItem::Static(node_id) => {\n-                let def_id = hir_map.local_def_id(node_id);\n-                let empty_substs = tcx.mk_substs(subst::Substs::empty());\n-                let instance = Instance::new(def_id, empty_substs);\n-                to_string_internal(tcx, \"static \", instance)\n-            },\n-        };\n-\n-        fn to_string_internal<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                                        prefix: &str,\n-                                        instance: Instance<'tcx>)\n-                                        -> String {\n-            let mut result = String::with_capacity(32);\n-            result.push_str(prefix);\n-            push_instance_as_string(tcx, instance, &mut result);\n-            result\n-        }\n-    }\n-\n-    pub fn to_raw_string(&self) -> String {\n-        match *self {\n-            TransItem::DropGlue(dg) => {\n-                format!(\"DropGlue({})\", dg.ty() as *const _ as usize)\n-            }\n-            TransItem::Fn(instance) => {\n-                format!(\"Fn({:?}, {})\",\n-                         instance.def,\n-                         instance.substs as *const _ as usize)\n-            }\n-            TransItem::Static(id) => {\n-                format!(\"Static({:?})\", id)\n-            }\n-        }\n-    }\n-}"}, {"sha": "7ca76af03bb04659562890d6b4f223fffe0d748f", "filename": "src/llvm", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": null, "raw_url": null, "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fllvm?ref=d11936251a93d7395169dfab9088c4dde0cca180", "patch": "@@ -1 +1 @@\n-Subproject commit 80ad955b60b3ac02d0462a4a65fcea597d0ebfb1\n+Subproject commit 7ca76af03bb04659562890d6b4f223fffe0d748f"}, {"sha": "1953fc5a6b48c3c9008973e89e61f095263bd486", "filename": "src/rustllvm/llvm-auto-clean-trigger", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d11936251a93d7395169dfab9088c4dde0cca180/src%2Frustllvm%2Fllvm-auto-clean-trigger", "raw_url": "https://github.com/rust-lang/rust/raw/d11936251a93d7395169dfab9088c4dde0cca180/src%2Frustllvm%2Fllvm-auto-clean-trigger", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustllvm%2Fllvm-auto-clean-trigger?ref=d11936251a93d7395169dfab9088c4dde0cca180", "patch": "@@ -1,4 +1,4 @@\n # If this file is modified, then llvm will be forcibly cleaned and then rebuilt.\n # The actual contents of this file do not matter, but to trigger a change on the\n # build bots then the contents should be changed so git updates the mtime.\n-2016-04-28\n+2016-06-23"}, {"sha": "2b5ac7e8d80dec5efd06e5c570a74780f4216305", "filename": "src/test/codegen-units/item-collection/cross-crate-closures.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/d11936251a93d7395169dfab9088c4dde0cca180/src%2Ftest%2Fcodegen-units%2Fitem-collection%2Fcross-crate-closures.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d11936251a93d7395169dfab9088c4dde0cca180/src%2Ftest%2Fcodegen-units%2Fitem-collection%2Fcross-crate-closures.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen-units%2Fitem-collection%2Fcross-crate-closures.rs?ref=d11936251a93d7395169dfab9088c4dde0cca180", "patch": "@@ -8,6 +8,11 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+// In the current version of the collector that still has to support\n+// legacy-trans, closures do not generate their own TransItems, so we are\n+// ignoring this test until MIR trans has taken over completely\n+// ignore-test\n+\n // ignore-tidy-linelength\n // compile-flags:-Zprint-trans-items=eager\n "}, {"sha": "278e9189dd6a72b8cc2ffdb3dfa6def8557111e9", "filename": "src/test/codegen-units/item-collection/non-generic-closures.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/d11936251a93d7395169dfab9088c4dde0cca180/src%2Ftest%2Fcodegen-units%2Fitem-collection%2Fnon-generic-closures.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d11936251a93d7395169dfab9088c4dde0cca180/src%2Ftest%2Fcodegen-units%2Fitem-collection%2Fnon-generic-closures.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen-units%2Fitem-collection%2Fnon-generic-closures.rs?ref=d11936251a93d7395169dfab9088c4dde0cca180", "patch": "@@ -8,6 +8,11 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+// In the current version of the collector that still has to support\n+// legacy-trans, closures do not generate their own TransItems, so we are\n+// ignoring this test until MIR trans has taken over completely\n+// ignore-test\n+\n // ignore-tidy-linelength\n // compile-flags:-Zprint-trans-items=eager\n "}, {"sha": "910ffd2959ed089400ec7691b95710e808db1631", "filename": "src/test/codegen-units/partitioning/extern-drop-glue.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/d11936251a93d7395169dfab9088c4dde0cca180/src%2Ftest%2Fcodegen-units%2Fpartitioning%2Fextern-drop-glue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d11936251a93d7395169dfab9088c4dde0cca180/src%2Ftest%2Fcodegen-units%2Fpartitioning%2Fextern-drop-glue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen-units%2Fpartitioning%2Fextern-drop-glue.rs?ref=d11936251a93d7395169dfab9088c4dde0cca180", "patch": "@@ -20,15 +20,15 @@\n // aux-build:cgu_extern_drop_glue.rs\n extern crate cgu_extern_drop_glue;\n \n-//~ TRANS_ITEM drop-glue cgu_extern_drop_glue::Struct[0] @@ extern_drop_glue[OnceODR] extern_drop_glue-mod1[OnceODR]\n-//~ TRANS_ITEM drop-glue-contents cgu_extern_drop_glue::Struct[0] @@ extern_drop_glue[OnceODR] extern_drop_glue-mod1[OnceODR]\n+//~ TRANS_ITEM drop-glue cgu_extern_drop_glue::Struct[0] @@ extern_drop_glue[Internal] extern_drop_glue-mod1[Internal]\n+//~ TRANS_ITEM drop-glue-contents cgu_extern_drop_glue::Struct[0] @@ extern_drop_glue[Internal] extern_drop_glue-mod1[Internal]\n \n struct LocalStruct(cgu_extern_drop_glue::Struct);\n \n-//~ TRANS_ITEM fn extern_drop_glue::user[0] @@ extern_drop_glue[WeakODR]\n+//~ TRANS_ITEM fn extern_drop_glue::user[0] @@ extern_drop_glue[External]\n fn user()\n {\n-    //~ TRANS_ITEM drop-glue extern_drop_glue::LocalStruct[0] @@ extern_drop_glue[OnceODR]\n+    //~ TRANS_ITEM drop-glue extern_drop_glue::LocalStruct[0] @@ extern_drop_glue[Internal]\n     let _ = LocalStruct(cgu_extern_drop_glue::Struct(0));\n }\n \n@@ -37,10 +37,10 @@ mod mod1 {\n \n     struct LocalStruct(cgu_extern_drop_glue::Struct);\n \n-    //~ TRANS_ITEM fn extern_drop_glue::mod1[0]::user[0] @@ extern_drop_glue-mod1[WeakODR]\n+    //~ TRANS_ITEM fn extern_drop_glue::mod1[0]::user[0] @@ extern_drop_glue-mod1[External]\n     fn user()\n     {\n-        //~ TRANS_ITEM drop-glue extern_drop_glue::mod1[0]::LocalStruct[0] @@ extern_drop_glue-mod1[OnceODR]\n+        //~ TRANS_ITEM drop-glue extern_drop_glue::mod1[0]::LocalStruct[0] @@ extern_drop_glue-mod1[Internal]\n         let _ = LocalStruct(cgu_extern_drop_glue::Struct(0));\n     }\n }"}, {"sha": "58f904f48a17dad25d5d4625182610bec2fbffce", "filename": "src/test/codegen-units/partitioning/extern-generic.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/d11936251a93d7395169dfab9088c4dde0cca180/src%2Ftest%2Fcodegen-units%2Fpartitioning%2Fextern-generic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d11936251a93d7395169dfab9088c4dde0cca180/src%2Ftest%2Fcodegen-units%2Fpartitioning%2Fextern-generic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen-units%2Fpartitioning%2Fextern-generic.rs?ref=d11936251a93d7395169dfab9088c4dde0cca180", "patch": "@@ -19,23 +19,23 @@\n // aux-build:cgu_generic_function.rs\n extern crate cgu_generic_function;\n \n-//~ TRANS_ITEM fn extern_generic::user[0] @@ extern_generic[WeakODR]\n+//~ TRANS_ITEM fn extern_generic::user[0] @@ extern_generic[External]\n fn user() {\n     let _ = cgu_generic_function::foo(\"abc\");\n }\n \n mod mod1 {\n     use cgu_generic_function;\n \n-    //~ TRANS_ITEM fn extern_generic::mod1[0]::user[0] @@ extern_generic-mod1[WeakODR]\n+    //~ TRANS_ITEM fn extern_generic::mod1[0]::user[0] @@ extern_generic-mod1[External]\n     fn user() {\n         let _ = cgu_generic_function::foo(\"abc\");\n     }\n \n     mod mod1 {\n         use cgu_generic_function;\n \n-        //~ TRANS_ITEM fn extern_generic::mod1[0]::mod1[0]::user[0] @@ extern_generic-mod1-mod1[WeakODR]\n+        //~ TRANS_ITEM fn extern_generic::mod1[0]::mod1[0]::user[0] @@ extern_generic-mod1-mod1[External]\n         fn user() {\n             let _ = cgu_generic_function::foo(\"abc\");\n         }\n@@ -45,20 +45,20 @@ mod mod1 {\n mod mod2 {\n     use cgu_generic_function;\n \n-    //~ TRANS_ITEM fn extern_generic::mod2[0]::user[0] @@ extern_generic-mod2[WeakODR]\n+    //~ TRANS_ITEM fn extern_generic::mod2[0]::user[0] @@ extern_generic-mod2[External]\n     fn user() {\n         let _ = cgu_generic_function::foo(\"abc\");\n     }\n }\n \n mod mod3 {\n-    //~ TRANS_ITEM fn extern_generic::mod3[0]::non_user[0] @@ extern_generic-mod3[WeakODR]\n+    //~ TRANS_ITEM fn extern_generic::mod3[0]::non_user[0] @@ extern_generic-mod3[External]\n     fn non_user() {}\n }\n \n // Make sure the two generic functions from the extern crate get instantiated\n // privately in every module they are use in.\n-//~ TRANS_ITEM fn cgu_generic_function::foo[0]<&str> @@ extern_generic[OnceODR] extern_generic-mod1[OnceODR] extern_generic-mod2[OnceODR] extern_generic-mod1-mod1[OnceODR]\n-//~ TRANS_ITEM fn cgu_generic_function::bar[0]<&str> @@ extern_generic[OnceODR] extern_generic-mod1[OnceODR] extern_generic-mod2[OnceODR] extern_generic-mod1-mod1[OnceODR]\n+//~ TRANS_ITEM fn cgu_generic_function::foo[0]<&str> @@ extern_generic[Internal] extern_generic-mod1[Internal] extern_generic-mod2[Internal] extern_generic-mod1-mod1[Internal]\n+//~ TRANS_ITEM fn cgu_generic_function::bar[0]<&str> @@ extern_generic[Internal] extern_generic-mod1[Internal] extern_generic-mod2[Internal] extern_generic-mod1-mod1[Internal]\n \n //~ TRANS_ITEM drop-glue i8"}, {"sha": "118513f65541b30e046a4c8a882b368e28eb19e3", "filename": "src/test/codegen-units/partitioning/inlining-from-extern-crate.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/d11936251a93d7395169dfab9088c4dde0cca180/src%2Ftest%2Fcodegen-units%2Fpartitioning%2Finlining-from-extern-crate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d11936251a93d7395169dfab9088c4dde0cca180/src%2Ftest%2Fcodegen-units%2Fpartitioning%2Finlining-from-extern-crate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen-units%2Fpartitioning%2Finlining-from-extern-crate.rs?ref=d11936251a93d7395169dfab9088c4dde0cca180", "patch": "@@ -21,10 +21,10 @@ extern crate cgu_explicit_inlining;\n // This test makes sure that items inlined from external crates are privately\n // instantiated in every codegen unit they are used in.\n \n-//~ TRANS_ITEM fn cgu_explicit_inlining::inlined[0] @@ inlining_from_extern_crate[OnceODR] inlining_from_extern_crate-mod1[OnceODR]\n-//~ TRANS_ITEM fn cgu_explicit_inlining::always_inlined[0] @@ inlining_from_extern_crate[OnceODR] inlining_from_extern_crate-mod2[OnceODR]\n+//~ TRANS_ITEM fn cgu_explicit_inlining::inlined[0] @@ inlining_from_extern_crate[Internal] inlining_from_extern_crate-mod1[Internal]\n+//~ TRANS_ITEM fn cgu_explicit_inlining::always_inlined[0] @@ inlining_from_extern_crate[Internal] inlining_from_extern_crate-mod2[Internal]\n \n-//~ TRANS_ITEM fn inlining_from_extern_crate::user[0] @@ inlining_from_extern_crate[WeakODR]\n+//~ TRANS_ITEM fn inlining_from_extern_crate::user[0] @@ inlining_from_extern_crate[External]\n pub fn user()\n {\n     cgu_explicit_inlining::inlined();\n@@ -37,7 +37,7 @@ pub fn user()\n mod mod1 {\n     use cgu_explicit_inlining;\n \n-    //~ TRANS_ITEM fn inlining_from_extern_crate::mod1[0]::user[0] @@ inlining_from_extern_crate-mod1[WeakODR]\n+    //~ TRANS_ITEM fn inlining_from_extern_crate::mod1[0]::user[0] @@ inlining_from_extern_crate-mod1[External]\n     pub fn user()\n     {\n         cgu_explicit_inlining::inlined();\n@@ -50,7 +50,7 @@ mod mod1 {\n mod mod2 {\n     use cgu_explicit_inlining;\n \n-    //~ TRANS_ITEM fn inlining_from_extern_crate::mod2[0]::user[0] @@ inlining_from_extern_crate-mod2[WeakODR]\n+    //~ TRANS_ITEM fn inlining_from_extern_crate::mod2[0]::user[0] @@ inlining_from_extern_crate-mod2[External]\n     pub fn user()\n     {\n         cgu_explicit_inlining::always_inlined();"}, {"sha": "f61e3fe12931e0ddb6041ca5d240f3f804b01236", "filename": "src/test/codegen-units/partitioning/local-drop-glue.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/d11936251a93d7395169dfab9088c4dde0cca180/src%2Ftest%2Fcodegen-units%2Fpartitioning%2Flocal-drop-glue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d11936251a93d7395169dfab9088c4dde0cca180/src%2Ftest%2Fcodegen-units%2Fpartitioning%2Flocal-drop-glue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen-units%2Fpartitioning%2Flocal-drop-glue.rs?ref=d11936251a93d7395169dfab9088c4dde0cca180", "patch": "@@ -16,23 +16,23 @@\n #![allow(dead_code)]\n #![crate_type=\"lib\"]\n \n-//~ TRANS_ITEM drop-glue local_drop_glue::Struct[0] @@ local_drop_glue[OnceODR] local_drop_glue-mod1[OnceODR]\n-//~ TRANS_ITEM drop-glue-contents local_drop_glue::Struct[0] @@ local_drop_glue[OnceODR] local_drop_glue-mod1[OnceODR]\n+//~ TRANS_ITEM drop-glue local_drop_glue::Struct[0] @@ local_drop_glue[Internal] local_drop_glue-mod1[Internal]\n+//~ TRANS_ITEM drop-glue-contents local_drop_glue::Struct[0] @@ local_drop_glue[Internal] local_drop_glue-mod1[Internal]\n struct Struct {\n     _a: u32\n }\n \n impl Drop for Struct {\n-    //~ TRANS_ITEM fn local_drop_glue::{{impl}}[0]::drop[0] @@ local_drop_glue[WeakODR]\n+    //~ TRANS_ITEM fn local_drop_glue::{{impl}}[0]::drop[0] @@ local_drop_glue[External]\n     fn drop(&mut self) {}\n }\n \n-//~ TRANS_ITEM drop-glue local_drop_glue::Outer[0] @@ local_drop_glue[OnceODR]\n+//~ TRANS_ITEM drop-glue local_drop_glue::Outer[0] @@ local_drop_glue[Internal]\n struct Outer {\n     _a: Struct\n }\n \n-//~ TRANS_ITEM fn local_drop_glue::user[0] @@ local_drop_glue[WeakODR]\n+//~ TRANS_ITEM fn local_drop_glue::user[0] @@ local_drop_glue[External]\n fn user()\n {\n     let _ = Outer {\n@@ -46,14 +46,14 @@ mod mod1\n {\n     use super::Struct;\n \n-    //~ TRANS_ITEM drop-glue local_drop_glue::mod1[0]::Struct2[0] @@ local_drop_glue-mod1[OnceODR]\n+    //~ TRANS_ITEM drop-glue local_drop_glue::mod1[0]::Struct2[0] @@ local_drop_glue-mod1[Internal]\n     struct Struct2 {\n         _a: Struct,\n-        //~ TRANS_ITEM drop-glue (u32, local_drop_glue::Struct[0]) @@ local_drop_glue-mod1[OnceODR]\n+        //~ TRANS_ITEM drop-glue (u32, local_drop_glue::Struct[0]) @@ local_drop_glue-mod1[Internal]\n         _b: (u32, Struct),\n     }\n \n-    //~ TRANS_ITEM fn local_drop_glue::mod1[0]::user[0] @@ local_drop_glue-mod1[WeakODR]\n+    //~ TRANS_ITEM fn local_drop_glue::mod1[0]::user[0] @@ local_drop_glue-mod1[External]\n     fn user()\n     {\n         let _ = Struct2 {"}, {"sha": "2d744169d3f8e5800a086956b8201953ba66347c", "filename": "src/test/codegen-units/partitioning/local-generic.rs", "status": "modified", "additions": 8, "deletions": 11, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/d11936251a93d7395169dfab9088c4dde0cca180/src%2Ftest%2Fcodegen-units%2Fpartitioning%2Flocal-generic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d11936251a93d7395169dfab9088c4dde0cca180/src%2Ftest%2Fcodegen-units%2Fpartitioning%2Flocal-generic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen-units%2Fpartitioning%2Flocal-generic.rs?ref=d11936251a93d7395169dfab9088c4dde0cca180", "patch": "@@ -16,32 +16,29 @@\n #![allow(dead_code)]\n #![crate_type=\"lib\"]\n \n-// Used in different modules/codegen units but always instantiated in the same\n-// codegen unit.\n-\n-//~ TRANS_ITEM fn local_generic::generic[0]<u32> @@ local_generic.volatile[WeakODR]\n-//~ TRANS_ITEM fn local_generic::generic[0]<u64> @@ local_generic.volatile[WeakODR]\n-//~ TRANS_ITEM fn local_generic::generic[0]<char> @@ local_generic.volatile[WeakODR]\n-//~ TRANS_ITEM fn local_generic::generic[0]<&str> @@ local_generic.volatile[WeakODR]\n+//~ TRANS_ITEM fn local_generic::generic[0]<u32> @@ local_generic[Internal]\n+//~ TRANS_ITEM fn local_generic::generic[0]<u64> @@ local_generic-mod1[Internal]\n+//~ TRANS_ITEM fn local_generic::generic[0]<char> @@ local_generic-mod1-mod1[Internal]\n+//~ TRANS_ITEM fn local_generic::generic[0]<&str> @@ local_generic-mod2[Internal]\n pub fn generic<T>(x: T) -> T { x }\n \n-//~ TRANS_ITEM fn local_generic::user[0] @@ local_generic[WeakODR]\n+//~ TRANS_ITEM fn local_generic::user[0] @@ local_generic[External]\n fn user() {\n     let _ = generic(0u32);\n }\n \n mod mod1 {\n     pub use super::generic;\n \n-    //~ TRANS_ITEM fn local_generic::mod1[0]::user[0] @@ local_generic-mod1[WeakODR]\n+    //~ TRANS_ITEM fn local_generic::mod1[0]::user[0] @@ local_generic-mod1[External]\n     fn user() {\n         let _ = generic(0u64);\n     }\n \n     mod mod1 {\n         use super::generic;\n \n-        //~ TRANS_ITEM fn local_generic::mod1[0]::mod1[0]::user[0] @@ local_generic-mod1-mod1[WeakODR]\n+        //~ TRANS_ITEM fn local_generic::mod1[0]::mod1[0]::user[0] @@ local_generic-mod1-mod1[External]\n         fn user() {\n             let _ = generic('c');\n         }\n@@ -51,7 +48,7 @@ mod mod1 {\n mod mod2 {\n     use super::generic;\n \n-    //~ TRANS_ITEM fn local_generic::mod2[0]::user[0] @@ local_generic-mod2[WeakODR]\n+    //~ TRANS_ITEM fn local_generic::mod2[0]::user[0] @@ local_generic-mod2[External]\n     fn user() {\n         let _ = generic(\"abc\");\n     }"}, {"sha": "5eb1cbc2199f759bccd5003c3275b0c1e7417d5c", "filename": "src/test/codegen-units/partitioning/local-inlining.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/d11936251a93d7395169dfab9088c4dde0cca180/src%2Ftest%2Fcodegen-units%2Fpartitioning%2Flocal-inlining.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d11936251a93d7395169dfab9088c4dde0cca180/src%2Ftest%2Fcodegen-units%2Fpartitioning%2Flocal-inlining.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen-units%2Fpartitioning%2Flocal-inlining.rs?ref=d11936251a93d7395169dfab9088c4dde0cca180", "patch": "@@ -19,7 +19,7 @@\n mod inline {\n \n     // Important: This function should show up in all codegen units where it is inlined\n-    //~ TRANS_ITEM fn local_inlining::inline[0]::inlined_function[0] @@ local_inlining-inline[WeakODR] local_inlining-user1[Available] local_inlining-user2[Available]\n+    //~ TRANS_ITEM fn local_inlining::inline[0]::inlined_function[0] @@ local_inlining-inline[External] local_inlining-user1[Available] local_inlining-user2[Available]\n     #[inline(always)]\n     pub fn inlined_function()\n     {\n@@ -30,7 +30,7 @@ mod inline {\n mod user1 {\n     use super::inline;\n \n-    //~ TRANS_ITEM fn local_inlining::user1[0]::foo[0] @@ local_inlining-user1[WeakODR]\n+    //~ TRANS_ITEM fn local_inlining::user1[0]::foo[0] @@ local_inlining-user1[External]\n     fn foo() {\n         inline::inlined_function();\n     }\n@@ -39,15 +39,15 @@ mod user1 {\n mod user2 {\n     use super::inline;\n \n-    //~ TRANS_ITEM fn local_inlining::user2[0]::bar[0] @@ local_inlining-user2[WeakODR]\n+    //~ TRANS_ITEM fn local_inlining::user2[0]::bar[0] @@ local_inlining-user2[External]\n     fn bar() {\n         inline::inlined_function();\n     }\n }\n \n mod non_user {\n \n-    //~ TRANS_ITEM fn local_inlining::non_user[0]::baz[0] @@ local_inlining-non_user[WeakODR]\n+    //~ TRANS_ITEM fn local_inlining::non_user[0]::baz[0] @@ local_inlining-non_user[External]\n     fn baz() {\n \n     }"}, {"sha": "28c4698eabd1fe636f802e828447d433cbffb067", "filename": "src/test/codegen-units/partitioning/local-transitive-inlining.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/d11936251a93d7395169dfab9088c4dde0cca180/src%2Ftest%2Fcodegen-units%2Fpartitioning%2Flocal-transitive-inlining.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d11936251a93d7395169dfab9088c4dde0cca180/src%2Ftest%2Fcodegen-units%2Fpartitioning%2Flocal-transitive-inlining.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen-units%2Fpartitioning%2Flocal-transitive-inlining.rs?ref=d11936251a93d7395169dfab9088c4dde0cca180", "patch": "@@ -18,7 +18,7 @@\n \n mod inline {\n \n-    //~ TRANS_ITEM fn local_transitive_inlining::inline[0]::inlined_function[0] @@ local_transitive_inlining-inline[WeakODR] local_transitive_inlining-direct_user[Available] local_transitive_inlining-indirect_user[Available]\n+    //~ TRANS_ITEM fn local_transitive_inlining::inline[0]::inlined_function[0] @@ local_transitive_inlining-inline[External] local_transitive_inlining-direct_user[Available] local_transitive_inlining-indirect_user[Available]\n     #[inline(always)]\n     pub fn inlined_function()\n     {\n@@ -29,7 +29,7 @@ mod inline {\n mod direct_user {\n     use super::inline;\n \n-    //~ TRANS_ITEM fn local_transitive_inlining::direct_user[0]::foo[0] @@ local_transitive_inlining-direct_user[WeakODR] local_transitive_inlining-indirect_user[Available]\n+    //~ TRANS_ITEM fn local_transitive_inlining::direct_user[0]::foo[0] @@ local_transitive_inlining-direct_user[External] local_transitive_inlining-indirect_user[Available]\n     #[inline(always)]\n     pub fn foo() {\n         inline::inlined_function();\n@@ -39,15 +39,15 @@ mod direct_user {\n mod indirect_user {\n     use super::direct_user;\n \n-    //~ TRANS_ITEM fn local_transitive_inlining::indirect_user[0]::bar[0] @@ local_transitive_inlining-indirect_user[WeakODR]\n+    //~ TRANS_ITEM fn local_transitive_inlining::indirect_user[0]::bar[0] @@ local_transitive_inlining-indirect_user[External]\n     fn bar() {\n         direct_user::foo();\n     }\n }\n \n mod non_user {\n \n-    //~ TRANS_ITEM fn local_transitive_inlining::non_user[0]::baz[0] @@ local_transitive_inlining-non_user[WeakODR]\n+    //~ TRANS_ITEM fn local_transitive_inlining::non_user[0]::baz[0] @@ local_transitive_inlining-non_user[External]\n     fn baz() {\n \n     }"}, {"sha": "1ea5aafd401d20cff73e7d507e10e0e111510e1b", "filename": "src/test/codegen-units/partitioning/methods-are-with-self-type.rs", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/d11936251a93d7395169dfab9088c4dde0cca180/src%2Ftest%2Fcodegen-units%2Fpartitioning%2Fmethods-are-with-self-type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d11936251a93d7395169dfab9088c4dde0cca180/src%2Ftest%2Fcodegen-units%2Fpartitioning%2Fmethods-are-with-self-type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen-units%2Fpartitioning%2Fmethods-are-with-self-type.rs?ref=d11936251a93d7395169dfab9088c4dde0cca180", "patch": "@@ -8,6 +8,11 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+// Currently, all generic functions are instantiated in each codegen unit that\n+// uses them, even those not marked with #[inline], so this test does not make\n+// much sense at the moment.\n+// ignore-test\n+\n // ignore-tidy-linelength\n // We specify -Z incremental here because we want to test the partitioning for\n // incremental compilation\n@@ -25,10 +30,10 @@ mod mod1 {\n     // Even though the impl is in `mod1`, the methods should end up in the\n     // parent module, since that is where their self-type is.\n     impl SomeType {\n-        //~ TRANS_ITEM fn methods_are_with_self_type::mod1[0]::{{impl}}[0]::method[0] @@ methods_are_with_self_type[WeakODR]\n+        //~ TRANS_ITEM fn methods_are_with_self_type::mod1[0]::{{impl}}[0]::method[0] @@ methods_are_with_self_type[External]\n         fn method(&self) {}\n \n-        //~ TRANS_ITEM fn methods_are_with_self_type::mod1[0]::{{impl}}[0]::associated_fn[0] @@ methods_are_with_self_type[WeakODR]\n+        //~ TRANS_ITEM fn methods_are_with_self_type::mod1[0]::{{impl}}[0]::associated_fn[0] @@ methods_are_with_self_type[External]\n         fn associated_fn() {}\n     }\n "}, {"sha": "4da64110321688400ba7b734460abd4b5e344ada", "filename": "src/test/codegen-units/partitioning/regular-modules.rs", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/d11936251a93d7395169dfab9088c4dde0cca180/src%2Ftest%2Fcodegen-units%2Fpartitioning%2Fregular-modules.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d11936251a93d7395169dfab9088c4dde0cca180/src%2Ftest%2Fcodegen-units%2Fpartitioning%2Fregular-modules.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen-units%2Fpartitioning%2Fregular-modules.rs?ref=d11936251a93d7395169dfab9088c4dde0cca180", "patch": "@@ -16,37 +16,37 @@\n #![allow(dead_code)]\n #![crate_type=\"lib\"]\n \n-//~ TRANS_ITEM fn regular_modules::foo[0] @@ regular_modules[WeakODR]\n+//~ TRANS_ITEM fn regular_modules::foo[0] @@ regular_modules[External]\n fn foo() {}\n \n-//~ TRANS_ITEM fn regular_modules::bar[0] @@ regular_modules[WeakODR]\n+//~ TRANS_ITEM fn regular_modules::bar[0] @@ regular_modules[External]\n fn bar() {}\n \n //~ TRANS_ITEM static regular_modules::BAZ[0] @@ regular_modules[External]\n static BAZ: u64 = 0;\n \n mod mod1 {\n \n-    //~ TRANS_ITEM fn regular_modules::mod1[0]::foo[0] @@ regular_modules-mod1[WeakODR]\n+    //~ TRANS_ITEM fn regular_modules::mod1[0]::foo[0] @@ regular_modules-mod1[External]\n     fn foo() {}\n-    //~ TRANS_ITEM fn regular_modules::mod1[0]::bar[0] @@ regular_modules-mod1[WeakODR]\n+    //~ TRANS_ITEM fn regular_modules::mod1[0]::bar[0] @@ regular_modules-mod1[External]\n     fn bar() {}\n     //~ TRANS_ITEM static regular_modules::mod1[0]::BAZ[0] @@ regular_modules-mod1[External]\n     static BAZ: u64 = 0;\n \n     mod mod1 {\n-        //~ TRANS_ITEM fn regular_modules::mod1[0]::mod1[0]::foo[0] @@ regular_modules-mod1-mod1[WeakODR]\n+        //~ TRANS_ITEM fn regular_modules::mod1[0]::mod1[0]::foo[0] @@ regular_modules-mod1-mod1[External]\n         fn foo() {}\n-        //~ TRANS_ITEM fn regular_modules::mod1[0]::mod1[0]::bar[0] @@ regular_modules-mod1-mod1[WeakODR]\n+        //~ TRANS_ITEM fn regular_modules::mod1[0]::mod1[0]::bar[0] @@ regular_modules-mod1-mod1[External]\n         fn bar() {}\n         //~ TRANS_ITEM static regular_modules::mod1[0]::mod1[0]::BAZ[0] @@ regular_modules-mod1-mod1[External]\n         static BAZ: u64 = 0;\n     }\n \n     mod mod2 {\n-        //~ TRANS_ITEM fn regular_modules::mod1[0]::mod2[0]::foo[0] @@ regular_modules-mod1-mod2[WeakODR]\n+        //~ TRANS_ITEM fn regular_modules::mod1[0]::mod2[0]::foo[0] @@ regular_modules-mod1-mod2[External]\n         fn foo() {}\n-        //~ TRANS_ITEM fn regular_modules::mod1[0]::mod2[0]::bar[0] @@ regular_modules-mod1-mod2[WeakODR]\n+        //~ TRANS_ITEM fn regular_modules::mod1[0]::mod2[0]::bar[0] @@ regular_modules-mod1-mod2[External]\n         fn bar() {}\n         //~ TRANS_ITEM static regular_modules::mod1[0]::mod2[0]::BAZ[0] @@ regular_modules-mod1-mod2[External]\n         static BAZ: u64 = 0;\n@@ -55,26 +55,26 @@ mod mod1 {\n \n mod mod2 {\n \n-    //~ TRANS_ITEM fn regular_modules::mod2[0]::foo[0] @@ regular_modules-mod2[WeakODR]\n+    //~ TRANS_ITEM fn regular_modules::mod2[0]::foo[0] @@ regular_modules-mod2[External]\n     fn foo() {}\n-    //~ TRANS_ITEM fn regular_modules::mod2[0]::bar[0] @@ regular_modules-mod2[WeakODR]\n+    //~ TRANS_ITEM fn regular_modules::mod2[0]::bar[0] @@ regular_modules-mod2[External]\n     fn bar() {}\n     //~ TRANS_ITEM static regular_modules::mod2[0]::BAZ[0] @@ regular_modules-mod2[External]\n     static BAZ: u64 = 0;\n \n     mod mod1 {\n-        //~ TRANS_ITEM fn regular_modules::mod2[0]::mod1[0]::foo[0] @@ regular_modules-mod2-mod1[WeakODR]\n+        //~ TRANS_ITEM fn regular_modules::mod2[0]::mod1[0]::foo[0] @@ regular_modules-mod2-mod1[External]\n         fn foo() {}\n-        //~ TRANS_ITEM fn regular_modules::mod2[0]::mod1[0]::bar[0] @@ regular_modules-mod2-mod1[WeakODR]\n+        //~ TRANS_ITEM fn regular_modules::mod2[0]::mod1[0]::bar[0] @@ regular_modules-mod2-mod1[External]\n         fn bar() {}\n         //~ TRANS_ITEM static regular_modules::mod2[0]::mod1[0]::BAZ[0] @@ regular_modules-mod2-mod1[External]\n         static BAZ: u64 = 0;\n     }\n \n     mod mod2 {\n-        //~ TRANS_ITEM fn regular_modules::mod2[0]::mod2[0]::foo[0] @@ regular_modules-mod2-mod2[WeakODR]\n+        //~ TRANS_ITEM fn regular_modules::mod2[0]::mod2[0]::foo[0] @@ regular_modules-mod2-mod2[External]\n         fn foo() {}\n-        //~ TRANS_ITEM fn regular_modules::mod2[0]::mod2[0]::bar[0] @@ regular_modules-mod2-mod2[WeakODR]\n+        //~ TRANS_ITEM fn regular_modules::mod2[0]::mod2[0]::bar[0] @@ regular_modules-mod2-mod2[External]\n         fn bar() {}\n         //~ TRANS_ITEM static regular_modules::mod2[0]::mod2[0]::BAZ[0] @@ regular_modules-mod2-mod2[External]\n         static BAZ: u64 = 0;"}, {"sha": "ffe1ec278b8dd3e0b99075d4bf615a9acfec2b69", "filename": "src/test/codegen-units/partitioning/statics.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d11936251a93d7395169dfab9088c4dde0cca180/src%2Ftest%2Fcodegen-units%2Fpartitioning%2Fstatics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d11936251a93d7395169dfab9088c4dde0cca180/src%2Ftest%2Fcodegen-units%2Fpartitioning%2Fstatics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen-units%2Fpartitioning%2Fstatics.rs?ref=d11936251a93d7395169dfab9088c4dde0cca180", "patch": "@@ -21,7 +21,7 @@ static FOO: u32 = 0;\n //~ TRANS_ITEM static statics::BAR[0] @@ statics[External]\n static BAR: u32 = 0;\n \n-//~ TRANS_ITEM fn statics::function[0] @@ statics[WeakODR]\n+//~ TRANS_ITEM fn statics::function[0] @@ statics[External]\n fn function() {\n     //~ TRANS_ITEM static statics::function[0]::FOO[0] @@ statics[External]\n     static FOO: u32 = 0;\n@@ -37,7 +37,7 @@ mod mod1 {\n     //~ TRANS_ITEM static statics::mod1[0]::BAR[0] @@ statics-mod1[External]\n     static BAR: u32 = 0;\n \n-    //~ TRANS_ITEM fn statics::mod1[0]::function[0] @@ statics-mod1[WeakODR]\n+    //~ TRANS_ITEM fn statics::mod1[0]::function[0] @@ statics-mod1[External]\n     fn function() {\n         //~ TRANS_ITEM static statics::mod1[0]::function[0]::FOO[0] @@ statics-mod1[External]\n         static FOO: u32 = 0;"}, {"sha": "25f8c130469973d888c617dca289abc639386b54", "filename": "src/test/codegen/drop.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/d11936251a93d7395169dfab9088c4dde0cca180/src%2Ftest%2Fcodegen%2Fdrop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d11936251a93d7395169dfab9088c4dde0cca180/src%2Ftest%2Fcodegen%2Fdrop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen%2Fdrop.rs?ref=d11936251a93d7395169dfab9088c4dde0cca180", "patch": "@@ -31,13 +31,13 @@ pub fn droppy() {\n // that's one new drop call per call to possibly_unwinding(), and finally 3 drop calls for the\n // regular function exit. We used to have problems with quadratic growths of drop calls in such\n // functions.\n-// CHECK: call{{.*}}SomeUniqueName{{.*}}drop\n-// CHECK: call{{.*}}SomeUniqueName{{.*}}drop\n-// CHECK: call{{.*}}SomeUniqueName{{.*}}drop\n-// CHECK: call{{.*}}SomeUniqueName{{.*}}drop\n-// CHECK: call{{.*}}SomeUniqueName{{.*}}drop\n-// CHECK: call{{.*}}SomeUniqueName{{.*}}drop\n-// CHECK-NOT: call{{.*}}SomeUniqueName{{.*}}drop\n+// CHECK: call{{.*}}drop{{.*}}SomeUniqueName\n+// CHECK: call{{.*}}drop{{.*}}SomeUniqueName\n+// CHECK: call{{.*}}drop{{.*}}SomeUniqueName\n+// CHECK: call{{.*}}drop{{.*}}SomeUniqueName\n+// CHECK: call{{.*}}drop{{.*}}SomeUniqueName\n+// CHECK: call{{.*}}drop{{.*}}SomeUniqueName\n+// CHECK-NOT: call{{.*}}drop{{.*}}SomeUniqueName\n // The next line checks for the } that ends the function definition\n // CHECK-LABEL: {{^[}]}}\n     let _s = SomeUniqueName;"}]}