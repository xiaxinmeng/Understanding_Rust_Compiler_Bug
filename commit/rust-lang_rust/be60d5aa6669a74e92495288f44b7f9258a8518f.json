{"sha": "be60d5aa6669a74e92495288f44b7f9258a8518f", "node_id": "MDY6Q29tbWl0NzI0NzEyOmJlNjBkNWFhNjY2OWE3NGU5MjQ5NTI4OGY0NGI3ZjkyNThhODUxOGY=", "commit": {"author": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2018-01-20T18:49:58Z"}, "committer": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2018-01-20T18:49:58Z"}, "message": "Drop more high-order stuff", "tree": {"sha": "b115c6605755e903902ec2971ce2529cb87e3b8a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b115c6605755e903902ec2971ce2529cb87e3b8a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/be60d5aa6669a74e92495288f44b7f9258a8518f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/be60d5aa6669a74e92495288f44b7f9258a8518f", "html_url": "https://github.com/rust-lang/rust/commit/be60d5aa6669a74e92495288f44b7f9258a8518f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/be60d5aa6669a74e92495288f44b7f9258a8518f/comments", "author": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "committer": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "111743d82c31bcaeb3cd7abbb261c0e038c2d909", "url": "https://api.github.com/repos/rust-lang/rust/commits/111743d82c31bcaeb3cd7abbb261c0e038c2d909", "html_url": "https://github.com/rust-lang/rust/commit/111743d82c31bcaeb3cd7abbb261c0e038c2d909"}], "stats": {"total": 193, "additions": 100, "deletions": 93}, "files": [{"sha": "8b5e5bcfe71ec04b529f160c7ffb829e7ec72553", "filename": "src/parser/event_parser/grammar/attributes.rs", "status": "modified", "additions": 24, "deletions": 9, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/be60d5aa6669a74e92495288f44b7f9258a8518f/src%2Fparser%2Fevent_parser%2Fgrammar%2Fattributes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/be60d5aa6669a74e92495288f44b7f9258a8518f/src%2Fparser%2Fevent_parser%2Fgrammar%2Fattributes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fparser%2Fevent_parser%2Fgrammar%2Fattributes.rs?ref=be60d5aa6669a74e92495288f44b7f9258a8518f", "patch": "@@ -1,5 +1,6 @@\n use super::*;\n \n+#[derive(PartialEq, Eq)]\n enum AttrKind {\n     Inner, Outer\n }\n@@ -14,18 +15,27 @@ pub(super) fn outer_attributes(p: &mut Parser) {\n \n \n fn attribute(p: &mut Parser, kind: AttrKind) -> bool {\n-    fn attr_tail(p: &mut Parser) {\n-        meta_item(p) && p.expect(R_BRACK);\n-    }\n-\n-    match kind {\n-        AttrKind::Inner => node_if(p, [POUND, EXCL, L_BRACK], ATTR, attr_tail),\n-        AttrKind::Outer => node_if(p, [POUND, L_BRACK], ATTR, attr_tail),\n+    if p.at(POUND) {\n+        if kind == AttrKind::Inner && p.raw_lookahead(1) != EXCL {\n+            return false;\n+        }\n+        p.start(ATTR);\n+        p.bump();\n+        if kind == AttrKind::Inner {\n+            p.bump();\n+        }\n+        p.expect(L_BRACK) && meta_item(p) && p.expect(R_BRACK);\n+        p.finish();\n+        true\n+    } else {\n+        false\n     }\n }\n \n fn meta_item(p: &mut Parser) -> bool {\n-    node_if(p, IDENT, META_ITEM, |p| {\n+    if p.at(IDENT) {\n+        p.start(META_ITEM);\n+        p.bump();\n         if p.eat(EQ) {\n             if !expressions::literal(p) {\n                 p.error()\n@@ -36,7 +46,12 @@ fn meta_item(p: &mut Parser) -> bool {\n             comma_list(p, R_PAREN, meta_item_inner);\n             p.expect(R_PAREN);\n         }\n-    })\n+        p.finish();\n+        true\n+    } else {\n+        false\n+    }\n+\n }\n \n fn meta_item_inner(p: &mut Parser) -> bool {"}, {"sha": "0f65193c9217a14d6e036f2bda04a7b98dea0b61", "filename": "src/parser/event_parser/grammar/expressions.rs", "status": "modified", "additions": 13, "deletions": 8, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/be60d5aa6669a74e92495288f44b7f9258a8518f/src%2Fparser%2Fevent_parser%2Fgrammar%2Fexpressions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/be60d5aa6669a74e92495288f44b7f9258a8518f/src%2Fparser%2Fevent_parser%2Fgrammar%2Fexpressions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fparser%2Fevent_parser%2Fgrammar%2Fexpressions.rs?ref=be60d5aa6669a74e92495288f44b7f9258a8518f", "patch": "@@ -1,11 +1,16 @@\n use super::*;\n \n pub(super) fn literal(p: &mut Parser) -> bool {\n-    let literals = [\n-        TRUE_KW, FALSE_KW,\n-        INT_NUMBER, FLOAT_NUMBER,\n-        BYTE, CHAR,\n-        STRING, RAW_STRING, BYTE_STRING, RAW_BYTE_STRING,\n-    ];\n-    node_if(p, AnyOf(&literals), LITERAL, |_| ())\n-}\n\\ No newline at end of file\n+    match p.current() {\n+        TRUE_KW | FALSE_KW |\n+        INT_NUMBER | FLOAT_NUMBER |\n+        BYTE | CHAR |\n+        STRING | RAW_STRING | BYTE_STRING | RAW_BYTE_STRING => {\n+            p.start(LITERAL);\n+            p.bump();\n+            p.finish();\n+            true\n+        }\n+        _ => false\n+    }\n+}"}, {"sha": "4514f0dab4a314cd866ba8747302330b7877ccb0", "filename": "src/parser/event_parser/grammar/items.rs", "status": "modified", "additions": 34, "deletions": 31, "changes": 65, "blob_url": "https://github.com/rust-lang/rust/blob/be60d5aa6669a74e92495288f44b7f9258a8518f/src%2Fparser%2Fevent_parser%2Fgrammar%2Fitems.rs", "raw_url": "https://github.com/rust-lang/rust/raw/be60d5aa6669a74e92495288f44b7f9258a8518f/src%2Fparser%2Fevent_parser%2Fgrammar%2Fitems.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fparser%2Fevent_parser%2Fgrammar%2Fitems.rs?ref=be60d5aa6669a74e92495288f44b7f9258a8518f", "patch": "@@ -7,7 +7,7 @@ pub(super) fn mod_contents(p: &mut Parser) {\n     }\n }\n \n-fn item(p: &mut Parser){\n+fn item(p: &mut Parser) {\n     let attrs_start = p.mark();\n     attributes::outer_attributes(p);\n     visibility(p);\n@@ -51,7 +51,7 @@ fn struct_item(p: &mut Parser) {\n     fn struct_inner(p: &mut Parser) {\n         if !p.expect(IDENT) {\n             p.finish();\n-            return\n+            return;\n         }\n         generic_parameters(p);\n         match p.current() {\n@@ -60,31 +60,31 @@ fn struct_item(p: &mut Parser) {\n                 match p.current() {\n                     SEMI => {\n                         p.bump();\n-                        return\n+                        return;\n                     }\n                     L_CURLY => named_fields(p),\n                     _ => { //TODO: special case `(` error message\n                         p.error()\n                             .message(\"expected `;` or `{`\")\n                             .emit();\n-                        return\n+                        return;\n                     }\n                 }\n             }\n             SEMI => {\n                 p.bump();\n-                return\n+                return;\n             }\n             L_CURLY => named_fields(p),\n             L_PAREN => {\n                 tuple_fields(p);\n                 p.expect(SEMI);\n-            },\n+            }\n             _ => {\n                 p.error()\n                     .message(\"expected `;`, `{`, or `(`\")\n                     .emit();\n-                return\n+                return;\n             }\n         }\n     }\n@@ -108,7 +108,7 @@ fn named_fields(p: &mut Parser) {\n \n fn tuple_fields(p: &mut Parser) {\n     if !p.expect(L_PAREN) {\n-        return\n+        return;\n     }\n     comma_list(p, R_PAREN, |p| {\n         tuple_field(p);\n@@ -124,11 +124,9 @@ fn tuple_fields(p: &mut Parser) {\n     }\n }\n \n-fn generic_parameters(_: &mut Parser) {\n-}\n+fn generic_parameters(_: &mut Parser) {}\n \n-fn where_clause(_: &mut Parser) {\n-}\n+fn where_clause(_: &mut Parser) {}\n \n fn extern_crate_item(p: &mut Parser) {\n     p.start(EXTERN_CRATE_ITEM);\n@@ -168,24 +166,29 @@ fn use_item(p: &mut Parser) {\n     p.expect(SEMI);\n     p.finish();\n \n-    fn use_tree(p: &mut Parser) -> bool{\n-        if node_if(p, STAR, USE_TREE, |_| ()) {\n-            return true\n-        }\n-        if node_if(p, [COLONCOLON, STAR], USE_TREE, |_| ()) {\n-           return true\n-        }\n-        if [COLONCOLON, L_CURLY].is_ahead(p) || L_CURLY.is_ahead(p) {\n-            node(p, USE_TREE, |p| {\n-                p.eat(COLONCOLON);\n+    fn use_tree(p: &mut Parser) -> bool {\n+        let la = p.raw_lookahead(1);\n+        match (p.current(), la) {\n+            (STAR, _) => {\n+                p.start(USE_TREE);\n+                p.bump();\n+            }\n+            (COLONCOLON, STAR) => {\n+                p.start(USE_TREE);\n+                p.bump();\n+                p.bump();\n+            }\n+            (L_CURLY, _) | (COLONCOLON, L_CURLY) => {\n+                p.start(USE_TREE);\n+                if p.at(COLONCOLON) {\n+                    p.bump();\n+                }\n                 p.curly_block(|p| {\n                     comma_list(p, EOF, use_tree);\n                 });\n-            });\n-            return true;\n-        }\n-        if paths::is_path_start(p) {\n-            node(p, USE_TREE, |p| {\n+            }\n+            _ if paths::is_path_start(p) => {\n+                p.start(USE_TREE);\n                 paths::use_path(p);\n                 match p.current() {\n                     AS_KW => {\n@@ -212,15 +215,15 @@ fn use_item(p: &mut Parser) {\n                     }\n                     _ => (),\n                 }\n-            });\n-            return true;\n+            }\n+            _ => return false,\n         }\n-        false\n+        p.finish();\n+        return true;\n     }\n }\n \n \n-\n fn fn_item(p: &mut Parser) {\n     p.start(FN_ITEM);\n "}, {"sha": "c3d0c8c1069f383f3e48352984a96f8affea9fa9", "filename": "src/parser/event_parser/grammar/mod.rs", "status": "modified", "additions": 0, "deletions": 15, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/be60d5aa6669a74e92495288f44b7f9258a8518f/src%2Fparser%2Fevent_parser%2Fgrammar%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/be60d5aa6669a74e92495288f44b7f9258a8518f/src%2Fparser%2Fevent_parser%2Fgrammar%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fparser%2Fevent_parser%2Fgrammar%2Fmod.rs?ref=be60d5aa6669a74e92495288f44b7f9258a8518f", "patch": "@@ -46,21 +46,6 @@ fn alias(p: &mut Parser) -> bool {\n     true //FIXME: return false if three are errors\n }\n \n-fn node_if<F: FnOnce(&mut Parser), L: Lookahead>(\n-    p: &mut Parser,\n-    first: L,\n-    node_kind: SyntaxKind,\n-    rest: F\n-) -> bool {\n-    first.is_ahead(p) && { node(p, node_kind, |p| { L::consume(p); rest(p); }); true }\n-}\n-\n-fn node<F: FnOnce(&mut Parser)>(p: &mut Parser, node_kind: SyntaxKind, rest: F) {\n-    p.start(node_kind);\n-    rest(p);\n-    p.finish();\n-}\n-\n fn repeat<F: FnMut(&mut Parser) -> bool>(p: &mut Parser, mut f: F) {\n     loop {\n         let pos = p.pos();"}, {"sha": "f5124cfce963b5d7f49298a24266ae534c68d688", "filename": "src/parser/event_parser/grammar/paths.rs", "status": "modified", "additions": 29, "deletions": 30, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/be60d5aa6669a74e92495288f44b7f9258a8518f/src%2Fparser%2Fevent_parser%2Fgrammar%2Fpaths.rs", "raw_url": "https://github.com/rust-lang/rust/raw/be60d5aa6669a74e92495288f44b7f9258a8518f/src%2Fparser%2Fevent_parser%2Fgrammar%2Fpaths.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fparser%2Fevent_parser%2Fgrammar%2Fpaths.rs?ref=be60d5aa6669a74e92495288f44b7f9258a8518f", "patch": "@@ -1,6 +1,6 @@\n use super::*;\n \n-pub (crate) fn is_path_start(p: &Parser) -> bool {\n+pub(crate) fn is_path_start(p: &Parser) -> bool {\n     AnyOf(&[IDENT, SELF_KW, SUPER_KW, COLONCOLON]).is_ahead(p)\n }\n \n@@ -9,39 +9,38 @@ pub(crate) fn use_path(p: &mut Parser) {\n         return;\n     }\n     let mut prev = p.mark();\n-    node(p, PATH, |p| {\n-        path_segment(p, true);\n-    });\n-    repeat(p, |p| {\n+    p.start(PATH);\n+    path_segment(p, true);\n+    p.finish();\n+    loop {\n         let curr = p.mark();\n-        if p.current() == COLONCOLON && !items::is_use_tree_start(p.raw_lookahead(1)) {\n-            node(p, PATH, |p| {\n-                p.bump();\n-                path_segment(p, false);\n-                p.forward_parent(prev, curr);\n-                prev = curr;\n-            });\n-            true\n+        if p.at(COLONCOLON) && !items::is_use_tree_start(p.raw_lookahead(1)) {\n+            p.start(PATH);\n+            p.bump();\n+            path_segment(p, false);\n+            p.forward_parent(prev, curr);\n+            prev = curr;\n+            p.finish();\n         } else {\n-            false\n+            break;\n         }\n-    });\n+    }\n }\n \n fn path_segment(p: &mut Parser, first: bool) {\n-    node(p, PATH_SEGMENT, |p| {\n-        if first {\n-            p.eat(COLONCOLON);\n+    p.start(PATH_SEGMENT);\n+    if first {\n+        p.eat(COLONCOLON);\n+    }\n+    match p.current() {\n+        IDENT | SELF_KW | SUPER_KW => {\n+            p.bump();\n         }\n-        match p.current() {\n-            IDENT | SELF_KW | SUPER_KW => {\n-                p.bump();\n-            },\n-            _ => {\n-                p.error()\n-                    .message(\"expected identifier\")\n-                    .emit();\n-            }\n-        };\n-    })\n-}\n\\ No newline at end of file\n+        _ => {\n+            p.error()\n+                .message(\"expected identifier\")\n+                .emit();\n+        }\n+    };\n+    p.finish();\n+}"}]}