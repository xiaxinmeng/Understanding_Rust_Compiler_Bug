{"sha": "a7e2b3e879790284b64529e3fb7d659274420a90", "node_id": "C_kwDOAAsO6NoAKGE3ZTJiM2U4Nzk3OTAyODRiNjQ1MjllM2ZiN2Q2NTkyNzQ0MjBhOTA", "commit": {"author": {"name": "Aaron Kofsky", "email": "aaronko@umich.edu", "date": "2022-06-04T23:52:12Z"}, "committer": {"name": "Aaron Kofsky", "email": "aaronko@umich.edu", "date": "2022-06-04T23:52:12Z"}, "message": "Move local functions to outer scope.", "tree": {"sha": "766f71e088b311f38f0996a5d6f007c90c2b18d9", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/766f71e088b311f38f0996a5d6f007c90c2b18d9"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a7e2b3e879790284b64529e3fb7d659274420a90", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a7e2b3e879790284b64529e3fb7d659274420a90", "html_url": "https://github.com/rust-lang/rust/commit/a7e2b3e879790284b64529e3fb7d659274420a90", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a7e2b3e879790284b64529e3fb7d659274420a90/comments", "author": {"login": "a2aaron", "id": 15718048, "node_id": "MDQ6VXNlcjE1NzE4MDQ4", "avatar_url": "https://avatars.githubusercontent.com/u/15718048?v=4", "gravatar_id": "", "url": "https://api.github.com/users/a2aaron", "html_url": "https://github.com/a2aaron", "followers_url": "https://api.github.com/users/a2aaron/followers", "following_url": "https://api.github.com/users/a2aaron/following{/other_user}", "gists_url": "https://api.github.com/users/a2aaron/gists{/gist_id}", "starred_url": "https://api.github.com/users/a2aaron/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/a2aaron/subscriptions", "organizations_url": "https://api.github.com/users/a2aaron/orgs", "repos_url": "https://api.github.com/users/a2aaron/repos", "events_url": "https://api.github.com/users/a2aaron/events{/privacy}", "received_events_url": "https://api.github.com/users/a2aaron/received_events", "type": "User", "site_admin": false}, "committer": {"login": "a2aaron", "id": 15718048, "node_id": "MDQ6VXNlcjE1NzE4MDQ4", "avatar_url": "https://avatars.githubusercontent.com/u/15718048?v=4", "gravatar_id": "", "url": "https://api.github.com/users/a2aaron", "html_url": "https://github.com/a2aaron", "followers_url": "https://api.github.com/users/a2aaron/followers", "following_url": "https://api.github.com/users/a2aaron/following{/other_user}", "gists_url": "https://api.github.com/users/a2aaron/gists{/gist_id}", "starred_url": "https://api.github.com/users/a2aaron/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/a2aaron/subscriptions", "organizations_url": "https://api.github.com/users/a2aaron/orgs", "repos_url": "https://api.github.com/users/a2aaron/repos", "events_url": "https://api.github.com/users/a2aaron/events{/privacy}", "received_events_url": "https://api.github.com/users/a2aaron/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6b179e3a67a2242b63892a1831ba217d968c2f62", "url": "https://api.github.com/repos/rust-lang/rust/commits/6b179e3a67a2242b63892a1831ba217d968c2f62", "html_url": "https://github.com/rust-lang/rust/commit/6b179e3a67a2242b63892a1831ba217d968c2f62"}], "stats": {"total": 134, "additions": 65, "deletions": 69}, "files": [{"sha": "c2d1cff313b871339f58efb24a4d598190631dfc", "filename": "compiler/rustc_lint/src/let_underscore.rs", "status": "modified", "additions": 65, "deletions": 69, "changes": 134, "blob_url": "https://github.com/rust-lang/rust/blob/a7e2b3e879790284b64529e3fb7d659274420a90/compiler%2Frustc_lint%2Fsrc%2Flet_underscore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a7e2b3e879790284b64529e3fb7d659274420a90/compiler%2Frustc_lint%2Fsrc%2Flet_underscore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Flet_underscore.rs?ref=a7e2b3e879790284b64529e3fb7d659274420a90", "patch": "@@ -175,74 +175,72 @@ impl<'tcx> LateLintPass<'tcx> for LetUnderscore {\n                 })\n             }\n         }\n+    }\n+}\n \n-        fn build_and_emit_lint(\n-            lint: LintDiagnosticBuilder<'_, ()>,\n-            local: &hir::Local<'_>,\n-            init_span: rustc_span::Span,\n-            msg: &str,\n-        ) {\n-            lint.build(msg)\n-                .span_suggestion_verbose(\n-                    local.pat.span,\n-                    \"consider binding to an unused variable\",\n-                    \"_unused\",\n-                    Applicability::MachineApplicable,\n-                )\n-                .span_suggestion_verbose(\n-                    init_span,\n-                    \"consider explicitly droping with `std::mem::drop`\",\n-                    \"drop(...)\",\n-                    Applicability::HasPlaceholders,\n-                )\n-                .emit();\n-        }\n+fn build_and_emit_lint(\n+    lint: LintDiagnosticBuilder<'_, ()>,\n+    local: &hir::Local<'_>,\n+    init_span: rustc_span::Span,\n+    msg: &str,\n+) {\n+    lint.build(msg)\n+        .span_suggestion_verbose(\n+            local.pat.span,\n+            \"consider binding to an unused variable\",\n+            \"_unused\",\n+            Applicability::MachineApplicable,\n+        )\n+        .span_suggestion_verbose(\n+            init_span,\n+            \"consider explicitly droping with `std::mem::drop`\",\n+            \"drop(...)\",\n+            Applicability::HasPlaceholders,\n+        )\n+        .emit();\n+}\n \n-        // return true if `ty` is a type that is marked as `must_use`\n-        fn is_must_use_ty<'tcx>(cx: &LateContext<'tcx>, ty: Ty<'tcx>) -> bool {\n-            match ty.kind() {\n-                ty::Adt(adt, _) => has_must_use_attr(cx, adt.did()),\n-                ty::Foreign(ref did) => has_must_use_attr(cx, *did),\n-                ty::Slice(ty)\n-                | ty::Array(ty, _)\n-                | ty::RawPtr(ty::TypeAndMut { ty, .. })\n-                | ty::Ref(_, ty, _) => {\n-                    // for the Array case we don't need to care for the len == 0 case\n-                    // because we don't want to lint functions returning empty arrays\n-                    is_must_use_ty(cx, *ty)\n-                }\n-                ty::Tuple(substs) => substs.iter().any(|ty| is_must_use_ty(cx, ty)),\n-                ty::Opaque(ref def_id, _) => {\n-                    for (predicate, _) in cx.tcx.explicit_item_bounds(*def_id) {\n-                        if let ty::PredicateKind::Trait(trait_predicate) =\n-                            predicate.kind().skip_binder()\n-                        {\n-                            if has_must_use_attr(cx, trait_predicate.trait_ref.def_id) {\n-                                return true;\n-                            }\n-                        }\n+// return true if `ty` is a type that is marked as `must_use`\n+fn is_must_use_ty<'tcx>(cx: &LateContext<'tcx>, ty: Ty<'tcx>) -> bool {\n+    match ty.kind() {\n+        ty::Adt(adt, _) => has_must_use_attr(cx, adt.did()),\n+        ty::Foreign(ref did) => has_must_use_attr(cx, *did),\n+        ty::Slice(ty)\n+        | ty::Array(ty, _)\n+        | ty::RawPtr(ty::TypeAndMut { ty, .. })\n+        | ty::Ref(_, ty, _) => {\n+            // for the Array case we don't need to care for the len == 0 case\n+            // because we don't want to lint functions returning empty arrays\n+            is_must_use_ty(cx, *ty)\n+        }\n+        ty::Tuple(substs) => substs.iter().any(|ty| is_must_use_ty(cx, ty)),\n+        ty::Opaque(ref def_id, _) => {\n+            for (predicate, _) in cx.tcx.explicit_item_bounds(*def_id) {\n+                if let ty::PredicateKind::Trait(trait_predicate) = predicate.kind().skip_binder() {\n+                    if has_must_use_attr(cx, trait_predicate.trait_ref.def_id) {\n+                        return true;\n                     }\n-                    false\n                 }\n-                ty::Dynamic(binder, _) => {\n-                    for predicate in binder.iter() {\n-                        if let ty::ExistentialPredicate::Trait(ref trait_ref) =\n-                            predicate.skip_binder()\n-                        {\n-                            if has_must_use_attr(cx, trait_ref.def_id) {\n-                                return true;\n-                            }\n-                        }\n+            }\n+            false\n+        }\n+        ty::Dynamic(binder, _) => {\n+            for predicate in binder.iter() {\n+                if let ty::ExistentialPredicate::Trait(ref trait_ref) = predicate.skip_binder() {\n+                    if has_must_use_attr(cx, trait_ref.def_id) {\n+                        return true;\n                     }\n-                    false\n                 }\n-                _ => false,\n             }\n+            false\n         }\n+        _ => false,\n+    }\n+}\n \n-        // check if expr is calling method or function with #[must_use] attribute\n-        fn is_must_use_func_call(cx: &LateContext<'_>, expr: &hir::Expr<'_>) -> bool {\n-            let did = match expr.kind {\n+// check if expr is calling method or function with #[must_use] attribute\n+fn is_must_use_func_call(cx: &LateContext<'_>, expr: &hir::Expr<'_>) -> bool {\n+    let did = match expr.kind {\n                 hir::ExprKind::Call(path, _) if let hir::ExprKind::Path(ref qpath) = path.kind => {\n                     if let hir::def::Res::Def(_, did) = cx.qpath_res(qpath, path.hir_id) {\n                         Some(did)\n@@ -256,15 +254,13 @@ impl<'tcx> LateLintPass<'tcx> for LetUnderscore {\n                 _ => None,\n             };\n \n-            did.map_or(false, |did| has_must_use_attr(cx, did))\n-        }\n+    did.map_or(false, |did| has_must_use_attr(cx, did))\n+}\n \n-        // returns true if DefId contains a `#[must_use]` attribute\n-        fn has_must_use_attr(cx: &LateContext<'_>, did: hir::def_id::DefId) -> bool {\n-            cx.tcx\n-                .get_attrs(did, rustc_span::sym::must_use)\n-                .find(|a| a.has_name(rustc_span::sym::must_use))\n-                .is_some()\n-        }\n-    }\n+// returns true if DefId contains a `#[must_use]` attribute\n+fn has_must_use_attr(cx: &LateContext<'_>, did: hir::def_id::DefId) -> bool {\n+    cx.tcx\n+        .get_attrs(did, rustc_span::sym::must_use)\n+        .find(|a| a.has_name(rustc_span::sym::must_use))\n+        .is_some()\n }"}]}