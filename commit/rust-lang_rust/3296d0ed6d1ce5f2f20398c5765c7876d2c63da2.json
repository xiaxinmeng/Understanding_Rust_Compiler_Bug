{"sha": "3296d0ed6d1ce5f2f20398c5765c7876d2c63da2", "node_id": "MDY6Q29tbWl0NzI0NzEyOjMyOTZkMGVkNmQxY2U1ZjJmMjAzOThjNTc2NWM3ODc2ZDJjNjNkYTI=", "commit": {"author": {"name": "Matthew Jasper", "email": "mjjasper1@gmail.com", "date": "2019-08-11T13:16:12Z"}, "committer": {"name": "Matthew Jasper", "email": "mjjasper1@gmail.com", "date": "2019-08-17T08:12:32Z"}, "message": "Remove gensyms from built-in derives\n\nAlso make them generally more hygienic with name resolution.", "tree": {"sha": "357c94fddf9b3dda667931ab5d560c80bfa8cba2", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/357c94fddf9b3dda667931ab5d560c80bfa8cba2"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3296d0ed6d1ce5f2f20398c5765c7876d2c63da2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3296d0ed6d1ce5f2f20398c5765c7876d2c63da2", "html_url": "https://github.com/rust-lang/rust/commit/3296d0ed6d1ce5f2f20398c5765c7876d2c63da2", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3296d0ed6d1ce5f2f20398c5765c7876d2c63da2/comments", "author": {"login": "matthewjasper", "id": 20113453, "node_id": "MDQ6VXNlcjIwMTEzNDUz", "avatar_url": "https://avatars.githubusercontent.com/u/20113453?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matthewjasper", "html_url": "https://github.com/matthewjasper", "followers_url": "https://api.github.com/users/matthewjasper/followers", "following_url": "https://api.github.com/users/matthewjasper/following{/other_user}", "gists_url": "https://api.github.com/users/matthewjasper/gists{/gist_id}", "starred_url": "https://api.github.com/users/matthewjasper/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matthewjasper/subscriptions", "organizations_url": "https://api.github.com/users/matthewjasper/orgs", "repos_url": "https://api.github.com/users/matthewjasper/repos", "events_url": "https://api.github.com/users/matthewjasper/events{/privacy}", "received_events_url": "https://api.github.com/users/matthewjasper/received_events", "type": "User", "site_admin": false}, "committer": {"login": "matthewjasper", "id": 20113453, "node_id": "MDQ6VXNlcjIwMTEzNDUz", "avatar_url": "https://avatars.githubusercontent.com/u/20113453?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matthewjasper", "html_url": "https://github.com/matthewjasper", "followers_url": "https://api.github.com/users/matthewjasper/followers", "following_url": "https://api.github.com/users/matthewjasper/following{/other_user}", "gists_url": "https://api.github.com/users/matthewjasper/gists{/gist_id}", "starred_url": "https://api.github.com/users/matthewjasper/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matthewjasper/subscriptions", "organizations_url": "https://api.github.com/users/matthewjasper/orgs", "repos_url": "https://api.github.com/users/matthewjasper/repos", "events_url": "https://api.github.com/users/matthewjasper/events{/privacy}", "received_events_url": "https://api.github.com/users/matthewjasper/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0280e8ffcc6d58319c58506cd769e71ebdc79c06", "url": "https://api.github.com/repos/rust-lang/rust/commits/0280e8ffcc6d58319c58506cd769e71ebdc79c06", "html_url": "https://github.com/rust-lang/rust/commit/0280e8ffcc6d58319c58506cd769e71ebdc79c06"}], "stats": {"total": 274, "additions": 188, "deletions": 86}, "files": [{"sha": "55687c3175b9dbfe83f82a5fd4945eb1341522b4", "filename": "src/libsyntax_ext/deriving/cmp/ord.rs", "status": "modified", "additions": 30, "deletions": 29, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/3296d0ed6d1ce5f2f20398c5765c7876d2c63da2/src%2Flibsyntax_ext%2Fderiving%2Fcmp%2Ford.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3296d0ed6d1ce5f2f20398c5765c7876d2c63da2/src%2Flibsyntax_ext%2Fderiving%2Fcmp%2Ford.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fderiving%2Fcmp%2Ford.rs?ref=3296d0ed6d1ce5f2f20398c5765c7876d2c63da2", "patch": "@@ -43,17 +43,18 @@ pub fn expand_deriving_ord(cx: &mut ExtCtxt<'_>,\n }\n \n \n-pub fn ordering_collapsed(cx: &mut ExtCtxt<'_>,\n-                          span: Span,\n-                          self_arg_tags: &[ast::Ident])\n-                          -> P<ast::Expr> {\n+pub fn ordering_collapsed(\n+    cx: &mut ExtCtxt<'_>,\n+    span: Span,\n+    self_arg_tags: &[ast::Ident],\n+) -> P<ast::Expr> {\n     let lft = cx.expr_ident(span, self_arg_tags[0]);\n     let rgt = cx.expr_addr_of(span, cx.expr_ident(span, self_arg_tags[1]));\n-    cx.expr_method_call(span, lft, cx.ident_of(\"cmp\"), vec![rgt])\n+    cx.expr_method_call(span, lft, ast::Ident::new(sym::cmp, span), vec![rgt])\n }\n \n pub fn cs_cmp(cx: &mut ExtCtxt<'_>, span: Span, substr: &Substructure<'_>) -> P<Expr> {\n-    let test_id = cx.ident_of(\"cmp\").gensym();\n+    let test_id = ast::Ident::new(sym::cmp, span);\n     let equals_path = cx.path_global(span, cx.std_path(&[sym::cmp, sym::Ordering, sym::Equal]));\n \n     let cmp_path = cx.std_path(&[sym::cmp, sym::Ord, sym::cmp]);\n@@ -75,34 +76,34 @@ pub fn cs_cmp(cx: &mut ExtCtxt<'_>, span: Span, substr: &Substructure<'_>) -> P<\n             // as the outermost one, and the last as the innermost.\n             false,\n             |cx, span, old, self_f, other_fs| {\n-        // match new {\n-        //     ::std::cmp::Ordering::Equal => old,\n-        //     cmp => cmp\n-        // }\n+                // match new {\n+                //     ::std::cmp::Ordering::Equal => old,\n+                //     cmp => cmp\n+                // }\n \n-        let new = {\n-            let other_f = match other_fs {\n-                [o_f] => o_f,\n-                _ => cx.span_bug(span, \"not exactly 2 arguments in `derive(Ord)`\"),\n-            };\n+                let new = {\n+                    let other_f = match other_fs {\n+                        [o_f] => o_f,\n+                        _ => cx.span_bug(span, \"not exactly 2 arguments in `derive(Ord)`\"),\n+                    };\n \n-            let args = vec![\n-                    cx.expr_addr_of(span, self_f),\n-                    cx.expr_addr_of(span, other_f.clone()),\n-                ];\n+                    let args = vec![\n+                            cx.expr_addr_of(span, self_f),\n+                            cx.expr_addr_of(span, other_f.clone()),\n+                        ];\n \n-            cx.expr_call_global(span, cmp_path.clone(), args)\n-        };\n+                    cx.expr_call_global(span, cmp_path.clone(), args)\n+                };\n \n-        let eq_arm = cx.arm(span,\n-                            vec![cx.pat_path(span, equals_path.clone())],\n-                            old);\n-        let neq_arm = cx.arm(span,\n-                             vec![cx.pat_ident(span, test_id)],\n-                             cx.expr_ident(span, test_id));\n+                let eq_arm = cx.arm(span,\n+                                    vec![cx.pat_path(span, equals_path.clone())],\n+                                    old);\n+                let neq_arm = cx.arm(span,\n+                                     vec![cx.pat_ident(span, test_id)],\n+                                     cx.expr_ident(span, test_id));\n \n-        cx.expr_match(span, new, vec![eq_arm, neq_arm])\n-    },\n+                cx.expr_match(span, new, vec![eq_arm, neq_arm])\n+            },\n             cx.expr_path(equals_path.clone()),\n             Box::new(|cx, span, (self_args, tag_tuple), _non_self_args| {\n         if self_args.len() != 2 {"}, {"sha": "740b92a9b7978bbf9ac21a122bcbf0524450de17", "filename": "src/libsyntax_ext/deriving/cmp/partial_ord.rs", "status": "modified", "additions": 8, "deletions": 7, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/3296d0ed6d1ce5f2f20398c5765c7876d2c63da2/src%2Flibsyntax_ext%2Fderiving%2Fcmp%2Fpartial_ord.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3296d0ed6d1ce5f2f20398c5765c7876d2c63da2/src%2Flibsyntax_ext%2Fderiving%2Fcmp%2Fpartial_ord.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fderiving%2Fcmp%2Fpartial_ord.rs?ref=3296d0ed6d1ce5f2f20398c5765c7876d2c63da2", "patch": "@@ -94,11 +94,12 @@ pub enum OrderingOp {\n     GeOp,\n }\n \n-pub fn some_ordering_collapsed(cx: &mut ExtCtxt<'_>,\n-                               span: Span,\n-                               op: OrderingOp,\n-                               self_arg_tags: &[ast::Ident])\n-                               -> P<ast::Expr> {\n+pub fn some_ordering_collapsed(\n+    cx: &mut ExtCtxt<'_>,\n+    span: Span,\n+    op: OrderingOp,\n+    self_arg_tags: &[ast::Ident],\n+) -> P<ast::Expr> {\n     let lft = cx.expr_ident(span, self_arg_tags[0]);\n     let rgt = cx.expr_addr_of(span, cx.expr_ident(span, self_arg_tags[1]));\n     let op_str = match op {\n@@ -108,11 +109,11 @@ pub fn some_ordering_collapsed(cx: &mut ExtCtxt<'_>,\n         GtOp => \"gt\",\n         GeOp => \"ge\",\n     };\n-    cx.expr_method_call(span, lft, cx.ident_of(op_str), vec![rgt])\n+    cx.expr_method_call(span, lft, ast::Ident::from_str_and_span(op_str, span), vec![rgt])\n }\n \n pub fn cs_partial_cmp(cx: &mut ExtCtxt<'_>, span: Span, substr: &Substructure<'_>) -> P<Expr> {\n-    let test_id = cx.ident_of(\"cmp\").gensym();\n+    let test_id = ast::Ident::new(sym::cmp, span);\n     let ordering = cx.path_global(span, cx.std_path(&[sym::cmp, sym::Ordering, sym::Equal]));\n     let ordering_expr = cx.expr_path(ordering.clone());\n     let equals_expr = cx.expr_some(span, ordering_expr);"}, {"sha": "441535410480b678593f9025868dd0e1c2d84924", "filename": "src/libsyntax_ext/deriving/debug.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/3296d0ed6d1ce5f2f20398c5765c7876d2c63da2/src%2Flibsyntax_ext%2Fderiving%2Fdebug.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3296d0ed6d1ce5f2f20398c5765c7876d2c63da2/src%2Flibsyntax_ext%2Fderiving%2Fdebug.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fderiving%2Fdebug.rs?ref=3296d0ed6d1ce5f2f20398c5765c7876d2c63da2", "patch": "@@ -62,7 +62,7 @@ fn show_substructure(cx: &mut ExtCtxt<'_>, span: Span, substr: &Substructure<'_>\n     // We want to make sure we have the ctxt set so that we can use unstable methods\n     let span = span.with_ctxt(cx.backtrace());\n     let name = cx.expr_lit(span, ast::LitKind::Str(ident.name, ast::StrStyle::Cooked));\n-    let builder = Ident::from_str(\"debug_trait_builder\").gensym();\n+    let builder = Ident::from_str_and_span(\"debug_trait_builder\", span);\n     let builder_expr = cx.expr_ident(span, builder.clone());\n \n     let fmt = substr.nonself_args[0].clone();\n@@ -73,7 +73,7 @@ fn show_substructure(cx: &mut ExtCtxt<'_>, span: Span, substr: &Substructure<'_>\n             // tuple struct/\"normal\" variant\n             let expr =\n                 cx.expr_method_call(span, fmt, Ident::from_str(\"debug_tuple\"), vec![name]);\n-            stmts.push(cx.stmt_let(DUMMY_SP, true, builder, expr));\n+            stmts.push(cx.stmt_let(span, true, builder, expr));\n \n             for field in fields {\n                 // Use double indirection to make sure this works for unsized types\n@@ -82,7 +82,7 @@ fn show_substructure(cx: &mut ExtCtxt<'_>, span: Span, substr: &Substructure<'_>\n \n                 let expr = cx.expr_method_call(span,\n                                                 builder_expr.clone(),\n-                                                Ident::with_dummy_span(sym::field),\n+                                                Ident::new(sym::field, span),\n                                                 vec![field]);\n \n                 // Use `let _ = expr;` to avoid triggering the\n@@ -106,7 +106,7 @@ fn show_substructure(cx: &mut ExtCtxt<'_>, span: Span, substr: &Substructure<'_>\n                 let field = cx.expr_addr_of(field.span, field);\n                 let expr = cx.expr_method_call(span,\n                                                 builder_expr.clone(),\n-                                                Ident::with_dummy_span(sym::field),\n+                                                Ident::new(sym::field, span),\n                                                 vec![name, field]);\n                 stmts.push(stmt_let_undescore(cx, span, expr));\n             }"}, {"sha": "9b6f8518de046dc16e2049aa593150d06ed5909f", "filename": "src/libsyntax_ext/deriving/decodable.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/3296d0ed6d1ce5f2f20398c5765c7876d2c63da2/src%2Flibsyntax_ext%2Fderiving%2Fdecodable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3296d0ed6d1ce5f2f20398c5765c7876d2c63da2/src%2Flibsyntax_ext%2Fderiving%2Fdecodable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fderiving%2Fdecodable.rs?ref=3296d0ed6d1ce5f2f20398c5765c7876d2c63da2", "patch": "@@ -1,6 +1,6 @@\n-//! The compiler code necessary for `#[derive(Decodable)]`. See encodable.rs for more.\n+//! The compiler code necessary for `#[derive(RustcDecodable)]`. See encodable.rs for more.\n \n-use crate::deriving::{self, pathvec_std};\n+use crate::deriving::pathvec_std;\n use crate::deriving::generic::*;\n use crate::deriving::generic::ty::*;\n \n@@ -17,7 +17,7 @@ pub fn expand_deriving_rustc_decodable(cx: &mut ExtCtxt<'_>,\n                                        item: &Annotatable,\n                                        push: &mut dyn FnMut(Annotatable)) {\n     let krate = \"rustc_serialize\";\n-    let typaram = &*deriving::hygienic_type_parameter(item, \"__D\");\n+    let typaram = \"__D\";\n \n     let trait_def = TraitDef {\n         span,"}, {"sha": "8b18fb25e90c121e7bea4120927c5f5111d3f483", "filename": "src/libsyntax_ext/deriving/encodable.rs", "status": "modified", "additions": 12, "deletions": 9, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/3296d0ed6d1ce5f2f20398c5765c7876d2c63da2/src%2Flibsyntax_ext%2Fderiving%2Fencodable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3296d0ed6d1ce5f2f20398c5765c7876d2c63da2/src%2Flibsyntax_ext%2Fderiving%2Fencodable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fderiving%2Fencodable.rs?ref=3296d0ed6d1ce5f2f20398c5765c7876d2c63da2", "patch": "@@ -1,11 +1,12 @@\n-//! The compiler code necessary to implement the `#[derive(Encodable)]`\n-//! (and `Decodable`, in `decodable.rs`) extension. The idea here is that\n-//! type-defining items may be tagged with `#[derive(Encodable, Decodable)]`.\n+//! The compiler code necessary to implement the `#[derive(RustcEncodable)]`\n+//! (and `RustcDecodable`, in `decodable.rs`) extension. The idea here is that\n+//! type-defining items may be tagged with\n+//! `#[derive(RustcEncodable, RustcDecodable)]`.\n //!\n //! For example, a type like:\n //!\n //! ```\n-//! #[derive(Encodable, Decodable)]\n+//! #[derive(RustcEncodable, RustcDecodable)]\n //! struct Node { id: usize }\n //! ```\n //!\n@@ -40,15 +41,17 @@\n //! references other non-built-in types. A type definition like:\n //!\n //! ```\n-//! # #[derive(Encodable, Decodable)] struct Span;\n-//! #[derive(Encodable, Decodable)]\n+//! # #[derive(RustcEncodable, RustcDecodable)]\n+//! # struct Span;\n+//! #[derive(RustcEncodable, RustcDecodable)]\n //! struct Spanned<T> { node: T, span: Span }\n //! ```\n //!\n //! would yield functions like:\n //!\n //! ```\n-//! # #[derive(Encodable, Decodable)] struct Span;\n+//! # #[derive(RustcEncodable, RustcDecodable)]\n+//! # struct Span;\n //! # struct Spanned<T> { node: T, span: Span }\n //! impl<\n //!     S: Encoder<E>,\n@@ -82,7 +85,7 @@\n //! }\n //! ```\n \n-use crate::deriving::{self, pathvec_std};\n+use crate::deriving::pathvec_std;\n use crate::deriving::generic::*;\n use crate::deriving::generic::ty::*;\n \n@@ -98,7 +101,7 @@ pub fn expand_deriving_rustc_encodable(cx: &mut ExtCtxt<'_>,\n                                        item: &Annotatable,\n                                        push: &mut dyn FnMut(Annotatable)) {\n     let krate = \"rustc_serialize\";\n-    let typaram = &*deriving::hygienic_type_parameter(item, \"__S\");\n+    let typaram = \"__S\";\n \n     let trait_def = TraitDef {\n         span,"}, {"sha": "1475bac0688460444c50fe5f7688048251c813b8", "filename": "src/libsyntax_ext/deriving/generic/mod.rs", "status": "modified", "additions": 7, "deletions": 4, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/3296d0ed6d1ce5f2f20398c5765c7876d2c63da2/src%2Flibsyntax_ext%2Fderiving%2Fgeneric%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3296d0ed6d1ce5f2f20398c5765c7876d2c63da2/src%2Flibsyntax_ext%2Fderiving%2Fgeneric%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fderiving%2Fgeneric%2Fmod.rs?ref=3296d0ed6d1ce5f2f20398c5765c7876d2c63da2", "patch": "@@ -890,7 +890,7 @@ impl<'a> MethodDef<'a> {\n \n         for (ty, name) in self.args.iter() {\n             let ast_ty = ty.to_ty(cx, trait_.span, type_ident, generics);\n-            let ident = cx.ident_of(name).gensym();\n+            let ident = ast::Ident::from_str_and_span(name, trait_.span);\n             arg_tys.push((ident, ast_ty));\n \n             let arg_expr = cx.expr_ident(trait_.span, ident);\n@@ -1210,7 +1210,7 @@ impl<'a> MethodDef<'a> {\n         let vi_idents = self_arg_names.iter()\n             .map(|name| {\n                 let vi_suffix = format!(\"{}_vi\", &name[..]);\n-                cx.ident_of(&vi_suffix[..]).gensym()\n+                ast::Ident::from_str_and_span(&vi_suffix[..], trait_.span)\n             })\n             .collect::<Vec<ast::Ident>>();\n \n@@ -1387,7 +1387,10 @@ impl<'a> MethodDef<'a> {\n                 let variant_value =\n                     deriving::call_intrinsic(cx, sp, \"discriminant_value\", vec![self_addr]);\n \n-                let target_ty = cx.ty_ident(sp, cx.ident_of(target_type_name));\n+                let target_ty = cx.ty_ident(\n+                    sp,\n+                    ast::Ident::from_str_and_span(target_type_name, sp),\n+                );\n                 let variant_disr = cx.expr_cast(sp, variant_value, target_ty);\n                 let let_stmt = cx.stmt_let(sp, false, ident, variant_disr);\n                 index_let_stmts.push(let_stmt);\n@@ -1588,7 +1591,7 @@ impl<'a> TraitDef<'a> {\n         let mut ident_exprs = Vec::new();\n         for (i, struct_field) in struct_def.fields().iter().enumerate() {\n             let sp = struct_field.span.with_ctxt(self.span.ctxt());\n-            let ident = cx.ident_of(&format!(\"{}_{}\", prefix, i)).gensym();\n+            let ident = ast::Ident::from_str_and_span(&format!(\"{}_{}\", prefix, i), self.span);\n             paths.push(ident.with_span_pos(sp));\n             let val = cx.expr_path(cx.path_ident(sp, ident));\n             let val = if use_temporaries {"}, {"sha": "7fcf036fc817690de2c57b082cd317dc8ae68918", "filename": "src/libsyntax_ext/deriving/generic/ty.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3296d0ed6d1ce5f2f20398c5765c7876d2c63da2/src%2Flibsyntax_ext%2Fderiving%2Fgeneric%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3296d0ed6d1ce5f2f20398c5765c7876d2c63da2/src%2Flibsyntax_ext%2Fderiving%2Fgeneric%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fderiving%2Fgeneric%2Fty.rs?ref=3296d0ed6d1ce5f2f20398c5765c7876d2c63da2", "patch": "@@ -72,7 +72,7 @@ impl<'a> Path<'a> {\n                    self_ty: Ident,\n                    self_generics: &Generics)\n                    -> ast::Path {\n-        let mut idents = self.path.iter().map(|s| cx.ident_of(*s)).collect();\n+        let mut idents = self.path.iter().map(|s| Ident::from_str_and_span(*s, span)).collect();\n         let lt = mk_lifetimes(cx, span, &self.lifetime);\n         let tys: Vec<P<ast::Ty>> =\n             self.params.iter().map(|t| t.to_ty(cx, span, self_ty, self_generics)).collect();\n@@ -209,7 +209,7 @@ fn mk_ty_param(cx: &ExtCtxt<'_>,\n             cx.trait_bound(path)\n         })\n         .collect();\n-    cx.typaram(span, cx.ident_of(name), attrs.to_owned(), bounds, None)\n+    cx.typaram(span, ast::Ident::from_str_and_span(name, span), attrs.to_owned(), bounds, None)\n }\n \n fn mk_generics(params: Vec<ast::GenericParam>, span: Span) -> Generics {"}, {"sha": "2fc594abd705e38290571dbc5a4a3b1fb6e27b21", "filename": "src/libsyntax_ext/deriving/hash.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3296d0ed6d1ce5f2f20398c5765c7876d2c63da2/src%2Flibsyntax_ext%2Fderiving%2Fhash.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3296d0ed6d1ce5f2f20398c5765c7876d2c63da2/src%2Flibsyntax_ext%2Fderiving%2Fhash.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fderiving%2Fhash.rs?ref=3296d0ed6d1ce5f2f20398c5765c7876d2c63da2", "patch": "@@ -16,7 +16,7 @@ pub fn expand_deriving_hash(cx: &mut ExtCtxt<'_>,\n \n     let path = Path::new_(pathvec_std!(cx, hash::Hash), None, vec![], PathKind::Std);\n \n-    let typaram = &*deriving::hygienic_type_parameter(item, \"__H\");\n+    let typaram = \"__H\";\n \n     let arg = Path::new_local(typaram);\n     let hash_trait_def = TraitDef {"}, {"sha": "da68eea0c50e72606f7f845eb8c036749b5163ed", "filename": "src/libsyntax_ext/deriving/mod.rs", "status": "modified", "additions": 0, "deletions": 27, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/3296d0ed6d1ce5f2f20398c5765c7876d2c63da2/src%2Flibsyntax_ext%2Fderiving%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3296d0ed6d1ce5f2f20398c5765c7876d2c63da2/src%2Flibsyntax_ext%2Fderiving%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fderiving%2Fmod.rs?ref=3296d0ed6d1ce5f2f20398c5765c7876d2c63da2", "patch": "@@ -54,33 +54,6 @@ impl MultiItemModifier for BuiltinDerive {\n     }\n }\n \n-/// Construct a name for the inner type parameter that can't collide with any type parameters of\n-/// the item. This is achieved by starting with a base and then concatenating the names of all\n-/// other type parameters.\n-// FIXME(aburka): use real hygiene when that becomes possible\n-fn hygienic_type_parameter(item: &Annotatable, base: &str) -> String {\n-    let mut typaram = String::from(base);\n-    if let Annotatable::Item(ref item) = *item {\n-        match item.node {\n-            ast::ItemKind::Struct(_, ast::Generics { ref params, .. }) |\n-            ast::ItemKind::Enum(_, ast::Generics { ref params, .. }) => {\n-                for param in params {\n-                    match param.kind {\n-                        ast::GenericParamKind::Type { .. } => {\n-                            typaram.push_str(&param.ident.as_str());\n-                        }\n-                        _ => {}\n-                    }\n-                }\n-            }\n-\n-            _ => {}\n-        }\n-    }\n-\n-    typaram\n-}\n-\n /// Constructs an expression that calls an intrinsic\n fn call_intrinsic(cx: &ExtCtxt<'_>,\n                   span: Span,"}, {"sha": "4fa83c490383c3f9074e8ba99fb85e75433b54c5", "filename": "src/test/ui/derives/derive-hygiene.rs", "status": "added", "additions": 121, "deletions": 0, "changes": 121, "blob_url": "https://github.com/rust-lang/rust/blob/3296d0ed6d1ce5f2f20398c5765c7876d2c63da2/src%2Ftest%2Fui%2Fderives%2Fderive-hygiene.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3296d0ed6d1ce5f2f20398c5765c7876d2c63da2/src%2Ftest%2Fui%2Fderives%2Fderive-hygiene.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fderives%2Fderive-hygiene.rs?ref=3296d0ed6d1ce5f2f20398c5765c7876d2c63da2", "patch": "@@ -0,0 +1,121 @@\n+// Make sure that built-in derives don't rely on the user not declaring certain\n+// names to work properly.\n+\n+// check-pass\n+\n+#![allow(nonstandard_style)]\n+#![feature(decl_macro)]\n+\n+use std::prelude::v1::test as inline;\n+\n+static f: () = ();\n+static cmp: () = ();\n+static other: () = ();\n+static state: () = ();\n+static __self_0_0: () = ();\n+static __self_1_0: () = ();\n+static __self_vi: () = ();\n+static __arg_1_0: () = ();\n+static debug_trait_builder: () = ();\n+\n+struct isize;\n+trait i16 {}\n+\n+trait MethodsInDerives: Sized {\n+    fn debug_tuple(self) {}\n+    fn debug_struct(self) {}\n+    fn field(self) {}\n+    fn finish(self) {}\n+    fn clone(self) {}\n+    fn cmp(self) {}\n+    fn partial_cmp(self) {}\n+    fn eq(self) {}\n+    fn ne(self) {}\n+    fn le(self) {}\n+    fn lt(self) {}\n+    fn ge(self) {}\n+    fn gt(self) {}\n+    fn hash(self) {}\n+}\n+\n+trait GenericAny<T, U> {}\n+impl<S, T, U> GenericAny<T, U> for S {}\n+\n+#[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Debug, Hash)]\n+enum __H { V(i32), }\n+\n+#[repr(i16)]\n+#[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Debug, Hash)]\n+enum W { A, B }\n+\n+#[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Debug, Default, Hash)]\n+struct X<A: GenericAny<A, self::X<i32>>> {\n+    A: A,\n+}\n+\n+#[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Debug, Default, Hash)]\n+struct Y<B>(B)\n+where\n+    B: From<B>;\n+\n+#[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Debug, Hash)]\n+enum Z<C> {\n+    C(C),\n+    B { C: C },\n+}\n+\n+// Make sure that we aren't using `self::` in paths, since it doesn't work in\n+// non-module scopes.\n+const NON_MODULE: () = {\n+    #[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Debug, Hash)]\n+    enum __H { V(i32), }\n+\n+    #[repr(i16)]\n+    #[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Debug, Hash)]\n+    enum W { A, B }\n+\n+    #[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Debug, Default, Hash)]\n+    struct X<A: Fn(A) -> self::X<i32>> {\n+        A: A,\n+    }\n+\n+    #[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Debug, Default, Hash)]\n+    struct Y<B>(B)\n+    where\n+        B: From<B>;\n+\n+    #[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Debug, Hash)]\n+    enum Z<C> {\n+        C(C),\n+        B { C: C },\n+    }\n+};\n+\n+macro m() {\n+    #[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Debug, Hash)]\n+    enum __H { V(i32), }\n+\n+    #[repr(i16)]\n+    #[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Debug, Hash)]\n+    enum W { A, B }\n+\n+    #[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Debug, Default, Hash)]\n+    struct X<A: GenericAny<A, self::X<i32>>> {\n+        A: A,\n+    }\n+\n+    #[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Debug, Default, Hash)]\n+    struct Y<B>(B)\n+    where\n+        B: From<B>;\n+\n+    #[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Debug, Hash)]\n+    enum Z<C> {\n+        C(C),\n+        B { C: C },\n+    }\n+}\n+\n+m!();\n+\n+fn main() {}"}]}