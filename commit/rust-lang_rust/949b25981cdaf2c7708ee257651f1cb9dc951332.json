{"sha": "949b25981cdaf2c7708ee257651f1cb9dc951332", "node_id": "C_kwDOAAsO6NoAKDk0OWIyNTk4MWNkYWYyYzc3MDhlZTI1NzY1MWYxY2I5ZGM5NTEzMzI", "commit": {"author": {"name": "Michael Wright", "email": "mikerite@lavabit.com", "date": "2021-11-09T03:44:02Z"}, "committer": {"name": "Michael Wright", "email": "mikerite@lavabit.com", "date": "2021-11-09T03:44:02Z"}, "message": "Change `Bound` to `EndBound`\n\nOnly the end bounds of ranges can actually be included or excluded. This\ncommit changes the SpannedRange type to reflect that. Update `Kind::value`\nto and `Kind::cmp` for this change. `Kind::cmp` gets flipped to check value\nfirst and then the bound details and is much shorter.", "tree": {"sha": "3b68321f7012e75ca2c9bcb0b1b2d364f045bf4c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3b68321f7012e75ca2c9bcb0b1b2d364f045bf4c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/949b25981cdaf2c7708ee257651f1cb9dc951332", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/949b25981cdaf2c7708ee257651f1cb9dc951332", "html_url": "https://github.com/rust-lang/rust/commit/949b25981cdaf2c7708ee257651f1cb9dc951332", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/949b25981cdaf2c7708ee257651f1cb9dc951332/comments", "author": null, "committer": null, "parents": [{"sha": "98416d7f6ca4cc803d423e0897ccdf1deb08fe31", "url": "https://api.github.com/repos/rust-lang/rust/commits/98416d7f6ca4cc803d423e0897ccdf1deb08fe31", "html_url": "https://github.com/rust-lang/rust/commit/98416d7f6ca4cc803d423e0897ccdf1deb08fe31"}], "stats": {"total": 78, "additions": 36, "deletions": 42}, "files": [{"sha": "7a528cb0b3891e4f5e2de0c58df2a807be3c6e4a", "filename": "clippy_lints/src/matches.rs", "status": "modified", "additions": 36, "deletions": 42, "changes": 78, "blob_url": "https://github.com/rust-lang/rust/blob/949b25981cdaf2c7708ee257651f1cb9dc951332/clippy_lints%2Fsrc%2Fmatches.rs", "raw_url": "https://github.com/rust-lang/rust/raw/949b25981cdaf2c7708ee257651f1cb9dc951332/clippy_lints%2Fsrc%2Fmatches.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmatches.rs?ref=949b25981cdaf2c7708ee257651f1cb9dc951332", "patch": "@@ -1614,8 +1614,8 @@ fn all_ranges<'tcx>(cx: &LateContext<'tcx>, arms: &'tcx [Arm<'_>], ty: Ty<'tcx>)\n                     let rhs_val = rhs.int_value(cx, ty)?;\n \n                     let rhs_bound = match range_end {\n-                        RangeEnd::Included => Bound::Included(rhs_val),\n-                        RangeEnd::Excluded => Bound::Excluded(rhs_val),\n+                        RangeEnd::Included => EndBound::Included(rhs_val),\n+                        RangeEnd::Excluded => EndBound::Excluded(rhs_val),\n                     };\n                     return Some(SpannedRange {\n                         span: pat.span,\n@@ -1627,7 +1627,7 @@ fn all_ranges<'tcx>(cx: &LateContext<'tcx>, arms: &'tcx [Arm<'_>], ty: Ty<'tcx>)\n                     let value = constant_full_int(cx, cx.typeck_results(), value)?;\n                     return Some(SpannedRange {\n                         span: pat.span,\n-                        node: (value, Bound::Included(value)),\n+                        node: (value, EndBound::Included(value)),\n                     });\n                 }\n             }\n@@ -1636,16 +1636,16 @@ fn all_ranges<'tcx>(cx: &LateContext<'tcx>, arms: &'tcx [Arm<'_>], ty: Ty<'tcx>)\n         .collect()\n }\n \n-#[derive(Copy, Clone, Debug, Eq, PartialEq)]\n-pub enum Bound<T> {\n+#[derive(Clone, Copy, Debug, Eq, PartialEq)]\n+pub enum EndBound<T> {\n     Included(T),\n     Excluded(T),\n }\n \n #[derive(Debug, Eq, PartialEq)]\n pub struct SpannedRange<T> {\n     pub span: Span,\n-    pub node: (T, Bound<T>),\n+    pub node: (T, EndBound<T>),\n }\n \n // Checks if arm has the form `None => None`\n@@ -1701,14 +1701,13 @@ where\n     #[derive(Copy, Clone, Debug, Eq, PartialEq)]\n     enum Kind<'a, T> {\n         Start(T, &'a SpannedRange<T>),\n-        End(Bound<T>, &'a SpannedRange<T>),\n+        End(EndBound<T>, &'a SpannedRange<T>),\n     }\n \n     impl<'a, T: Copy> Kind<'a, T> {\n-        fn value(self) -> Bound<T> {\n+        fn value(self) -> T {\n             match self {\n-                Kind::Start(t, _) => Bound::Included(t),\n-                Kind::End(t, _) => t,\n+                Kind::Start(t, _) | Kind::End(EndBound::Included(t) | EndBound::Excluded(t), _) => t,\n             }\n         }\n     }\n@@ -1721,28 +1720,23 @@ where\n \n     impl<'a, T: Copy + Ord> Ord for Kind<'a, T> {\n         fn cmp(&self, other: &Self) -> Ordering {\n-            match (self.value(), other.value()) {\n-                (Bound::Included(a), Bound::Included(b)) | (Bound::Excluded(a), Bound::Excluded(b)) => {\n-                    let value_cmp = a.cmp(&b);\n-                    // In the case of ties, starts come before ends\n-                    if value_cmp == Ordering::Equal {\n-                        match (self, other) {\n-                            (Kind::Start(..), Kind::End(..)) => Ordering::Less,\n-                            (Kind::End(..), Kind::Start(..)) => Ordering::Greater,\n-                            _ => Ordering::Equal,\n-                        }\n-                    } else {\n-                        value_cmp\n-                    }\n-                },\n-                (Bound::Included(a), Bound::Excluded(b)) => match a.cmp(&b) {\n-                    Ordering::Equal => Ordering::Greater,\n-                    other => other,\n-                },\n-                (Bound::Excluded(a), Bound::Included(b)) => match a.cmp(&b) {\n-                    Ordering::Equal => Ordering::Less,\n-                    other => other,\n+            match self.value().cmp(&other.value()) {\n+                Ordering::Equal => match (self, other) {\n+                    // End excluded before start and end included\n+                    (Kind::End(EndBound::Excluded(_), _), Kind::Start(..) | Kind::End(EndBound::Included(_), _)) => {\n+                        Ordering::Less\n+                    },\n+                    (Kind::Start(..) | Kind::End(EndBound::Included(_), _), Kind::End(EndBound::Excluded(_), _)) => {\n+                        Ordering::Greater\n+                    },\n+\n+                    // Start before end included\n+                    (Kind::Start(..), Kind::End(EndBound::Included(_), _)) => Ordering::Less,\n+                    (Kind::End(EndBound::Included(_), _), Kind::Start(..)) => Ordering::Greater,\n+\n+                    _ => Ordering::Equal,\n                 },\n+                other => other,\n             }\n         }\n     }\n@@ -2224,29 +2218,29 @@ fn test_overlapping() {\n     };\n \n     assert_eq!(None, overlapping::<u8>(&[]));\n-    assert_eq!(None, overlapping(&[sp(1, Bound::Included(4))]));\n+    assert_eq!(None, overlapping(&[sp(1, EndBound::Included(4))]));\n     assert_eq!(\n         None,\n-        overlapping(&[sp(1, Bound::Included(4)), sp(5, Bound::Included(6))])\n+        overlapping(&[sp(1, EndBound::Included(4)), sp(5, EndBound::Included(6))])\n     );\n     assert_eq!(\n         None,\n         overlapping(&[\n-            sp(1, Bound::Included(4)),\n-            sp(5, Bound::Included(6)),\n-            sp(10, Bound::Included(11))\n+            sp(1, EndBound::Included(4)),\n+            sp(5, EndBound::Included(6)),\n+            sp(10, EndBound::Included(11))\n         ],)\n     );\n     assert_eq!(\n-        Some((&sp(1, Bound::Included(4)), &sp(3, Bound::Included(6)))),\n-        overlapping(&[sp(1, Bound::Included(4)), sp(3, Bound::Included(6))])\n+        Some((&sp(1, EndBound::Included(4)), &sp(3, EndBound::Included(6)))),\n+        overlapping(&[sp(1, EndBound::Included(4)), sp(3, EndBound::Included(6))])\n     );\n     assert_eq!(\n-        Some((&sp(5, Bound::Included(6)), &sp(6, Bound::Included(11)))),\n+        Some((&sp(5, EndBound::Included(6)), &sp(6, EndBound::Included(11)))),\n         overlapping(&[\n-            sp(1, Bound::Included(4)),\n-            sp(5, Bound::Included(6)),\n-            sp(6, Bound::Included(11))\n+            sp(1, EndBound::Included(4)),\n+            sp(5, EndBound::Included(6)),\n+            sp(6, EndBound::Included(11))\n         ],)\n     );\n }"}]}