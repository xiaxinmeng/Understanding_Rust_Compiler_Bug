{"sha": "6e794dcc8bc9435bf979d8d5cd6af465ab3004b8", "node_id": "C_kwDOAAsO6NoAKDZlNzk0ZGNjOGJjOTQzNWJmOTc5ZDhkNWNkNmFmNDY1YWIzMDA0Yjg", "commit": {"author": {"name": "Michael Goulet", "email": "michael@errs.io", "date": "2022-12-28T18:35:16Z"}, "committer": {"name": "Michael Goulet", "email": "michael@errs.io", "date": "2022-12-28T18:41:22Z"}, "message": "Address review comments", "tree": {"sha": "2e22950f59e200dfa6dc8286967547e6c4dd2945", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2e22950f59e200dfa6dc8286967547e6c4dd2945"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6e794dcc8bc9435bf979d8d5cd6af465ab3004b8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6e794dcc8bc9435bf979d8d5cd6af465ab3004b8", "html_url": "https://github.com/rust-lang/rust/commit/6e794dcc8bc9435bf979d8d5cd6af465ab3004b8", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6e794dcc8bc9435bf979d8d5cd6af465ab3004b8/comments", "author": {"login": "compiler-errors", "id": 3674314, "node_id": "MDQ6VXNlcjM2NzQzMTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/3674314?v=4", "gravatar_id": "", "url": "https://api.github.com/users/compiler-errors", "html_url": "https://github.com/compiler-errors", "followers_url": "https://api.github.com/users/compiler-errors/followers", "following_url": "https://api.github.com/users/compiler-errors/following{/other_user}", "gists_url": "https://api.github.com/users/compiler-errors/gists{/gist_id}", "starred_url": "https://api.github.com/users/compiler-errors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/compiler-errors/subscriptions", "organizations_url": "https://api.github.com/users/compiler-errors/orgs", "repos_url": "https://api.github.com/users/compiler-errors/repos", "events_url": "https://api.github.com/users/compiler-errors/events{/privacy}", "received_events_url": "https://api.github.com/users/compiler-errors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "compiler-errors", "id": 3674314, "node_id": "MDQ6VXNlcjM2NzQzMTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/3674314?v=4", "gravatar_id": "", "url": "https://api.github.com/users/compiler-errors", "html_url": "https://github.com/compiler-errors", "followers_url": "https://api.github.com/users/compiler-errors/followers", "following_url": "https://api.github.com/users/compiler-errors/following{/other_user}", "gists_url": "https://api.github.com/users/compiler-errors/gists{/gist_id}", "starred_url": "https://api.github.com/users/compiler-errors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/compiler-errors/subscriptions", "organizations_url": "https://api.github.com/users/compiler-errors/orgs", "repos_url": "https://api.github.com/users/compiler-errors/repos", "events_url": "https://api.github.com/users/compiler-errors/events{/privacy}", "received_events_url": "https://api.github.com/users/compiler-errors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "992ba801c271aeb087b1619467c487e35bae4e65", "url": "https://api.github.com/repos/rust-lang/rust/commits/992ba801c271aeb087b1619467c487e35bae4e65", "html_url": "https://github.com/rust-lang/rust/commit/992ba801c271aeb087b1619467c487e35bae4e65"}], "stats": {"total": 64, "additions": 29, "deletions": 35}, "files": [{"sha": "d91ef882bc4b8e93da9d28dc49bc3fce328ca8f1", "filename": "compiler/rustc_infer/src/infer/error_reporting/note.rs", "status": "modified", "additions": 29, "deletions": 35, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/6e794dcc8bc9435bf979d8d5cd6af465ab3004b8/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnote.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e794dcc8bc9435bf979d8d5cd6af465ab3004b8/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnote.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnote.rs?ref=6e794dcc8bc9435bf979d8d5cd6af465ab3004b8", "patch": "@@ -324,13 +324,8 @@ impl<'tcx> TypeErrCtxt<'_, 'tcx> {\n                     &format!(\"`{}: {}`\", sup, sub),\n                 );\n                 // We should only suggest rewriting the `where` clause if the predicate is within that `where` clause\n-                if self\n-                    .tcx\n-                    .hir()\n-                    .get_generics(impl_item_def_id)\n-                    .unwrap()\n-                    .where_clause_span\n-                    .contains(span)\n+                if let Some(generics) = self.tcx.hir().get_generics(impl_item_def_id)\n+                    && generics.where_clause_span.contains(span)\n                 {\n                     self.suggest_copy_trait_method_bounds(\n                         trait_item_def_id,\n@@ -390,52 +385,51 @@ impl<'tcx> TypeErrCtxt<'_, 'tcx> {\n         // but right now it's not really very smart when it comes to implicit `Sized`\n         // predicates and bounds on the trait itself.\n \n-        let impl_def_id =\n-            self.tcx.associated_item(impl_item_def_id).impl_container(self.tcx).unwrap();\n-        let trait_substs = self\n+        let Some(impl_def_id) =\n+            self.tcx.associated_item(impl_item_def_id).impl_container(self.tcx) else { return; };\n+        let Some(trait_ref) = self\n             .tcx\n             .impl_trait_ref(impl_def_id)\n-            .unwrap()\n+            else { return; };\n+        let trait_substs = trait_ref\n             // Replace the explicit self type with `Self` for better suggestion rendering\n             .with_self_ty(self.tcx, self.tcx.mk_ty_param(0, kw::SelfUpper))\n             .substs;\n         let trait_item_substs =\n             ty::InternalSubsts::identity_for_item(self.tcx, impl_item_def_id.to_def_id())\n                 .rebase_onto(self.tcx, impl_def_id, trait_substs);\n \n-        let mut is_suggestable = true;\n-        let trait_predicates = self\n+        let Ok(trait_predicates) = self\n             .tcx\n             .bound_explicit_predicates_of(trait_item_def_id)\n             .map_bound(|p| p.predicates)\n             .subst_iter_copied(self.tcx, trait_item_substs)\n             .map(|(pred, _)| {\n-                if !pred.is_suggestable(self.tcx, false) {\n-                    is_suggestable = false;\n+                if pred.is_suggestable(self.tcx, false) {\n+                    Ok(pred.to_string())\n+                } else {\n+                    Err(())\n                 }\n-                pred.to_string()\n             })\n-            .collect::<Vec<_>>();\n+            .collect::<Result<Vec<_>, ()>>() else { return; };\n \n-        let generics = self.tcx.hir().get_generics(impl_item_def_id).unwrap();\n+        let Some(generics) = self.tcx.hir().get_generics(impl_item_def_id) else { return; };\n \n-        if is_suggestable {\n-            if trait_predicates.is_empty() {\n-                err.span_suggestion_verbose(\n-                    generics.where_clause_span,\n-                    \"remove the `where` clause\",\n-                    String::new(),\n-                    Applicability::MachineApplicable,\n-                );\n-            } else {\n-                let space = if generics.where_clause_span.is_empty() { \" \" } else { \"\" };\n-                err.span_suggestion_verbose(\n-                    generics.where_clause_span,\n-                    \"copy the `where` clause predicates from the trait\",\n-                    format!(\"{space}where {}\", trait_predicates.join(\", \")),\n-                    Applicability::MachineApplicable,\n-                );\n-            }\n+        if trait_predicates.is_empty() {\n+            err.span_suggestion_verbose(\n+                generics.where_clause_span,\n+                \"remove the `where` clause\",\n+                String::new(),\n+                Applicability::MachineApplicable,\n+            );\n+        } else {\n+            let space = if generics.where_clause_span.is_empty() { \" \" } else { \"\" };\n+            err.span_suggestion_verbose(\n+                generics.where_clause_span,\n+                \"copy the `where` clause predicates from the trait\",\n+                format!(\"{space}where {}\", trait_predicates.join(\", \")),\n+                Applicability::MachineApplicable,\n+            );\n         }\n     }\n "}]}