{"sha": "91cad3961484407eef2c89fd1329d8139013f669", "node_id": "MDY6Q29tbWl0NzI0NzEyOjkxY2FkMzk2MTQ4NDQwN2VlZjJjODlmZDEzMjlkODEzOTAxM2Y2Njk=", "commit": {"author": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2018-11-02T09:52:07Z"}, "committer": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2018-11-05T08:59:05Z"}, "message": "visit_aggregate with an iterator; fix some comment typos", "tree": {"sha": "715a2a44e9b7ed59a4b3029887b890505f4a3e27", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/715a2a44e9b7ed59a4b3029887b890505f4a3e27"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/91cad3961484407eef2c89fd1329d8139013f669", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/91cad3961484407eef2c89fd1329d8139013f669", "html_url": "https://github.com/rust-lang/rust/commit/91cad3961484407eef2c89fd1329d8139013f669", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/91cad3961484407eef2c89fd1329d8139013f669/comments", "author": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "committer": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "996a42557e2816cd577120f464c52b865ef8a924", "url": "https://api.github.com/repos/rust-lang/rust/commits/996a42557e2816cd577120f464c52b865ef8a924", "html_url": "https://github.com/rust-lang/rust/commit/996a42557e2816cd577120f464c52b865ef8a924"}], "stats": {"total": 105, "additions": 65, "deletions": 40}, "files": [{"sha": "819a966c0a6c46cf2289b095c2ba5ce74c09f639", "filename": "src/librustc_mir/interpret/validity.rs", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/91cad3961484407eef2c89fd1329d8139013f669/src%2Flibrustc_mir%2Finterpret%2Fvalidity.rs", "raw_url": "https://github.com/rust-lang/rust/raw/91cad3961484407eef2c89fd1329d8139013f669/src%2Flibrustc_mir%2Finterpret%2Fvalidity.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fvalidity.rs?ref=91cad3961484407eef2c89fd1329d8139013f669", "patch": "@@ -470,8 +470,11 @@ impl<'rt, 'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>>\n         }\n     }\n \n-    fn visit_array(&mut self, op: OpTy<'tcx, M::PointerTag>) -> EvalResult<'tcx>\n-    {\n+    fn visit_aggregate(\n+        &mut self,\n+        op: OpTy<'tcx, M::PointerTag>,\n+        fields: impl Iterator<Item=EvalResult<'tcx, Self::V>>,\n+    ) -> EvalResult<'tcx> {\n         match op.layout.ty.sty {\n             ty::Str => {\n                 let mplace = op.to_mem_place(); // strings are never immediate\n@@ -538,7 +541,7 @@ impl<'rt, 'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>>\n                 }\n             }\n             _ => {\n-                self.walk_array(op)? // default handler\n+                self.walk_aggregate(op, fields)? // default handler\n             }\n         }\n         Ok(())"}, {"sha": "80c7e075bd7f9333bbcf5055364004f1954fa001", "filename": "src/librustc_mir/interpret/visitor.rs", "status": "modified", "additions": 59, "deletions": 37, "changes": 96, "blob_url": "https://github.com/rust-lang/rust/blob/91cad3961484407eef2c89fd1329d8139013f669/src%2Flibrustc_mir%2Finterpret%2Fvisitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/91cad3961484407eef2c89fd1329d8139013f669/src%2Flibrustc_mir%2Finterpret%2Fvisitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fvisitor.rs?ref=91cad3961484407eef2c89fd1329d8139013f669", "patch": "@@ -13,29 +13,29 @@ use super::{\n \n // A thing that we can project into, and that has a layout.\n // This wouldn't have to depend on `Machine` but with the current type inference,\n-// that's just more convenient to work with (avoids repeading all the `Machine` bounds).\n+// that's just more convenient to work with (avoids repeating all the `Machine` bounds).\n pub trait Value<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>>: Copy\n {\n-    // Get this value's layout.\n+    /// Get this value's layout.\n     fn layout(&self) -> TyLayout<'tcx>;\n \n-    // Make this into an `OpTy`.\n+    /// Make this into an `OpTy`.\n     fn to_op(\n         self,\n         ecx: &EvalContext<'a, 'mir, 'tcx, M>,\n     ) -> EvalResult<'tcx, OpTy<'tcx, M::PointerTag>>;\n \n-    // Create this from an `MPlaceTy`.\n+    /// Create this from an `MPlaceTy`.\n     fn from_mem_place(MPlaceTy<'tcx, M::PointerTag>) -> Self;\n \n-    // Project to the given enum variant.\n+    /// Project to the given enum variant.\n     fn project_downcast(\n         self,\n         ecx: &EvalContext<'a, 'mir, 'tcx, M>,\n         variant: usize,\n     ) -> EvalResult<'tcx, Self>;\n \n-    // Project to the n-th field.\n+    /// Project to the n-th field.\n     fn project_field(\n         self,\n         ecx: &mut EvalContext<'a, 'mir, 'tcx, M>,\n@@ -166,27 +166,32 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> Value<'a, 'mir, 'tcx, M>\n pub trait ValueVisitor<'a, 'mir, 'tcx: 'mir+'a, M: Machine<'a, 'mir, 'tcx>>: Sized {\n     type V: Value<'a, 'mir, 'tcx, M>;\n \n-    // The visitor must have an `EvalContext` in it.\n+    /// The visitor must have an `EvalContext` in it.\n     fn ecx(&mut self) -> &mut EvalContext<'a, 'mir, 'tcx, M>;\n \n-    // Recursie actions, ready to be overloaded.\n-    /// Visit the given value, dispatching as appropriate to more speicalized visitors.\n+    // Recursive actions, ready to be overloaded.\n+    /// Visit the given value, dispatching as appropriate to more specialized visitors.\n     #[inline(always)]\n     fn visit_value(&mut self, v: Self::V) -> EvalResult<'tcx>\n     {\n         self.walk_value(v)\n     }\n-    /// Visit the given value as a union.\n+    /// Visit the given value as a union.  No automatic recursion can happen here.\n     #[inline(always)]\n     fn visit_union(&mut self, _v: Self::V) -> EvalResult<'tcx>\n     {\n         Ok(())\n     }\n-    /// Visit the given value as an array.\n+    /// Visit this vale as an aggregate, you are even getting an iterator yielding\n+    /// all the fields (still in an `EvalResult`, you have to do error handling yourself).\n+    /// Recurses into the fields.\n     #[inline(always)]\n-    fn visit_array(&mut self, v: Self::V) -> EvalResult<'tcx>\n-    {\n-        self.walk_array(v)\n+    fn visit_aggregate(\n+        &mut self,\n+        v: Self::V,\n+        fields: impl Iterator<Item=EvalResult<'tcx, Self::V>>,\n+    ) -> EvalResult<'tcx> {\n+        self.walk_aggregate(v, fields)\n     }\n     /// Called each time we recurse down to a field, passing in old and new value.\n     /// This gives the visitor the chance to track the stack of nested fields that\n@@ -201,39 +206,39 @@ pub trait ValueVisitor<'a, 'mir, 'tcx: 'mir+'a, M: Machine<'a, 'mir, 'tcx>>: Siz\n         self.visit_value(new_val)\n     }\n \n-    // Actions on the leaves, ready to be overloaded.\n     /// Called whenever we reach a value with uninhabited layout.\n-    /// Recursing to fields will continue after this!\n+    /// Recursing to fields will *always* continue after this!  This is not meant to control\n+    /// whether and how we descend recursively/ into the scalar's fields if there are any, it is\n+    /// meant to provide the chance for additional checks when a value of uninhabited layout is\n+    /// detected.\n     #[inline(always)]\n     fn visit_uninhabited(&mut self) -> EvalResult<'tcx>\n     { Ok(()) }\n     /// Called whenever we reach a value with scalar layout.\n-    /// We do NOT provide a `ScalarMaybeUndef` here to avoid accessing memory\n-    /// if the visitor is not even interested in scalars.\n-    /// Recursing to fields will continue after this!\n+    /// We do NOT provide a `ScalarMaybeUndef` here to avoid accessing memory if the visitor is not\n+    /// even interested in scalars.\n+    /// Recursing to fields will *always* continue after this!  This is not meant to control\n+    /// whether and how we descend recursively/ into the scalar's fields if there are any, it is\n+    /// meant to provide the chance for additional checks when a value of scalar layout is detected.\n     #[inline(always)]\n     fn visit_scalar(&mut self, _v: Self::V, _layout: &layout::Scalar) -> EvalResult<'tcx>\n     { Ok(()) }\n+\n     /// Called whenever we reach a value of primitive type.  There can be no recursion\n-    /// below such a value.\n+    /// below such a value.  This is the leave function.\n     #[inline(always)]\n     fn visit_primitive(&mut self, _val: ImmTy<'tcx, M::PointerTag>) -> EvalResult<'tcx>\n     { Ok(()) }\n \n     // Default recursors. Not meant to be overloaded.\n-    fn walk_array(&mut self, v: Self::V) -> EvalResult<'tcx>\n-    {\n-        // Let's get an mplace first.\n-        let mplace = if v.layout().is_zst() {\n-            // it's a ZST, the memory content cannot matter\n-            MPlaceTy::dangling(v.layout(), self.ecx())\n-        } else {\n-            // non-ZST array/slice/str cannot be immediate\n-            v.to_op(self.ecx())?.to_mem_place()\n-        };\n+    fn walk_aggregate(\n+        &mut self,\n+        v: Self::V,\n+        fields: impl Iterator<Item=EvalResult<'tcx, Self::V>>,\n+    ) -> EvalResult<'tcx> {\n         // Now iterate over it.\n-        for (i, field) in self.ecx().mplace_array_fields(mplace)?.enumerate() {\n-            self.visit_field(v, i, Value::from_mem_place(field?))?;\n+        for (idx, field_val) in fields.enumerate() {\n+            self.visit_field(v, idx, field_val?)?;\n         }\n         Ok(())\n     }\n@@ -312,13 +317,30 @@ pub trait ValueVisitor<'a, 'mir, 'tcx: 'mir+'a, M: Machine<'a, 'mir, 'tcx>>: Siz\n                 self.visit_union(v)?;\n             },\n             layout::FieldPlacement::Arbitrary { ref offsets, .. } => {\n-                for i in 0..offsets.len() {\n-                    let val = v.project_field(self.ecx(), i as u64)?;\n-                    self.visit_field(v, i, val)?;\n-                }\n+                // We collect in a vec because otherwise there are lifetime errors:\n+                // Projecting to a field needs (mutable!) access to `ecx`.\n+                let fields: Vec<EvalResult<'tcx, Self::V>> =\n+                    (0..offsets.len()).map(|i| {\n+                        v.project_field(self.ecx(), i as u64)\n+                    })\n+                    .collect();\n+                self.visit_aggregate(v, fields.into_iter())?;\n             },\n             layout::FieldPlacement::Array { .. } => {\n-                self.visit_array(v)?;\n+                // Let's get an mplace first.\n+                let mplace = if v.layout().is_zst() {\n+                    // it's a ZST, the memory content cannot matter\n+                    MPlaceTy::dangling(v.layout(), self.ecx())\n+                } else {\n+                    // non-ZST array/slice/str cannot be immediate\n+                    v.to_op(self.ecx())?.to_mem_place()\n+                };\n+                // Now we can go over all the fields.\n+                let iter = self.ecx().mplace_array_fields(mplace)?\n+                    .map(|f| f.and_then(|f| {\n+                        Ok(Value::from_mem_place(f))\n+                    }));\n+                self.visit_aggregate(v, iter)?;\n             }\n         }\n         Ok(())"}]}