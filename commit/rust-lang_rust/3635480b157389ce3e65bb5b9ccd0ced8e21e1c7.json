{"sha": "3635480b157389ce3e65bb5b9ccd0ced8e21e1c7", "node_id": "MDY6Q29tbWl0NzI0NzEyOjM2MzU0ODBiMTU3Mzg5Y2UzZTY1YmI1YjljY2QwY2VkOGUyMWUxYzc=", "commit": {"author": {"name": "Erick Tryzelaar", "email": "erick.tryzelaar@gmail.com", "date": "2013-02-24T18:20:24Z"}, "committer": {"name": "Erick Tryzelaar", "email": "erick.tryzelaar@gmail.com", "date": "2013-02-26T06:30:32Z"}, "message": "libsyntax: change expect to take &token::Token", "tree": {"sha": "665341932326c25c37d36f66c320ef76f7e18b76", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/665341932326c25c37d36f66c320ef76f7e18b76"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3635480b157389ce3e65bb5b9ccd0ced8e21e1c7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3635480b157389ce3e65bb5b9ccd0ced8e21e1c7", "html_url": "https://github.com/rust-lang/rust/commit/3635480b157389ce3e65bb5b9ccd0ced8e21e1c7", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3635480b157389ce3e65bb5b9ccd0ced8e21e1c7/comments", "author": {"login": "erickt", "id": 84711, "node_id": "MDQ6VXNlcjg0NzEx", "avatar_url": "https://avatars.githubusercontent.com/u/84711?v=4", "gravatar_id": "", "url": "https://api.github.com/users/erickt", "html_url": "https://github.com/erickt", "followers_url": "https://api.github.com/users/erickt/followers", "following_url": "https://api.github.com/users/erickt/following{/other_user}", "gists_url": "https://api.github.com/users/erickt/gists{/gist_id}", "starred_url": "https://api.github.com/users/erickt/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/erickt/subscriptions", "organizations_url": "https://api.github.com/users/erickt/orgs", "repos_url": "https://api.github.com/users/erickt/repos", "events_url": "https://api.github.com/users/erickt/events{/privacy}", "received_events_url": "https://api.github.com/users/erickt/received_events", "type": "User", "site_admin": false}, "committer": {"login": "erickt", "id": 84711, "node_id": "MDQ6VXNlcjg0NzEx", "avatar_url": "https://avatars.githubusercontent.com/u/84711?v=4", "gravatar_id": "", "url": "https://api.github.com/users/erickt", "html_url": "https://github.com/erickt", "followers_url": "https://api.github.com/users/erickt/followers", "following_url": "https://api.github.com/users/erickt/following{/other_user}", "gists_url": "https://api.github.com/users/erickt/gists{/gist_id}", "starred_url": "https://api.github.com/users/erickt/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/erickt/subscriptions", "organizations_url": "https://api.github.com/users/erickt/orgs", "repos_url": "https://api.github.com/users/erickt/repos", "events_url": "https://api.github.com/users/erickt/events{/privacy}", "received_events_url": "https://api.github.com/users/erickt/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f3965829ffd1e2eb4e2b8c4c8f151379f504ed7f", "url": "https://api.github.com/repos/rust-lang/rust/commits/f3965829ffd1e2eb4e2b8c4c8f151379f504ed7f", "html_url": "https://github.com/rust-lang/rust/commit/f3965829ffd1e2eb4e2b8c4c8f151379f504ed7f"}], "stats": {"total": 166, "additions": 84, "deletions": 82}, "files": [{"sha": "07db67d3173b27005cf120d8c74f1069692a3b32", "filename": "src/libsyntax/ext/pipes/parse_proto.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3635480b157389ce3e65bb5b9ccd0ced8e21e1c7/src%2Flibsyntax%2Fext%2Fpipes%2Fparse_proto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3635480b157389ce3e65bb5b9ccd0ced8e21e1c7/src%2Flibsyntax%2Fext%2Fpipes%2Fparse_proto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fpipes%2Fparse_proto.rs?ref=3635480b157389ce3e65bb5b9ccd0ced8e21e1c7", "patch": "@@ -39,7 +39,7 @@ pub impl proto_parser for parser::Parser {\n         let id = self.parse_ident();\n         let name = *self.interner.get(id);\n \n-        self.expect(token::COLON);\n+        self.expect(&token::COLON);\n         let dir = match *self.token {\n           token::IDENT(n, _) => self.interner.get(n),\n           _ => fail!()\n@@ -79,7 +79,7 @@ pub impl proto_parser for parser::Parser {\n         }\n         else { ~[] };\n \n-        self.expect(token::RARROW);\n+        self.expect(&token::RARROW);\n \n         let next = match *self.token {\n           token::IDENT(_, _) => {"}, {"sha": "e5487eaac38bffdaafc3257c3d446fb85a981124", "filename": "src/libsyntax/parse/attr.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/3635480b157389ce3e65bb5b9ccd0ced8e21e1c7/src%2Flibsyntax%2Fparse%2Fattr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3635480b157389ce3e65bb5b9ccd0ced8e21e1c7/src%2Flibsyntax%2Fparse%2Fattr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fattr.rs?ref=3635480b157389ce3e65bb5b9ccd0ced8e21e1c7", "patch": "@@ -61,15 +61,15 @@ impl parser_attr for Parser {\n \n     fn parse_attribute(style: ast::attr_style) -> ast::attribute {\n         let lo = self.span.lo;\n-        self.expect(token::POUND);\n+        self.expect(&token::POUND);\n         return self.parse_attribute_naked(style, lo);\n     }\n \n     fn parse_attribute_naked(style: ast::attr_style, lo: BytePos) ->\n         ast::attribute {\n-        self.expect(token::LBRACKET);\n+        self.expect(&token::LBRACKET);\n         let meta_item = self.parse_meta_item();\n-        self.expect(token::RBRACKET);\n+        self.expect(&token::RBRACKET);\n         let mut hi = self.span.hi;\n         return spanned(lo, hi, ast::attribute_ { style: style,\n                                                  value: meta_item,"}, {"sha": "aa4ffb7fc7ab385449c470768d00470b3bb01117", "filename": "src/libsyntax/parse/common.rs", "status": "modified", "additions": 13, "deletions": 12, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/3635480b157389ce3e65bb5b9ccd0ced8e21e1c7/src%2Flibsyntax%2Fparse%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3635480b157389ce3e65bb5b9ccd0ced8e21e1c7/src%2Flibsyntax%2Fparse%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fcommon.rs?ref=3635480b157389ce3e65bb5b9ccd0ced8e21e1c7", "patch": "@@ -64,15 +64,16 @@ pub impl Parser {\n \n     // expect and consume the token t. Signal an error if\n     // the next token is not t.\n-    fn expect(t: token::Token) {\n-        if *self.token == t {\n+    fn expect(t: &token::Token) {\n+        if *self.token == *t {\n             self.bump();\n         } else {\n-            let mut s: ~str = ~\"expected `\";\n-            s += token_to_str(self.reader, t);\n-            s += ~\"` but found `\";\n-            s += token_to_str(self.reader, *self.token);\n-            self.fatal(s + ~\"`\");\n+            self.fatal(\n+                fmt!(\"expected `%s` but found `%s`\",\n+                    token_to_str(self.reader, *t),\n+                    token_to_str(self.reader, *self.token)\n+                )\n+            )\n         }\n     }\n \n@@ -230,7 +231,7 @@ pub impl Parser {\n             match sep {\n               Some(ref t) => {\n                 if first { first = false; }\n-                else { self.expect(*t); }\n+                else { self.expect(t); }\n               }\n               _ => ()\n             }\n@@ -252,7 +253,7 @@ pub impl Parser {\n     fn parse_seq_lt_gt<T:Copy>(sep: Option<token::Token>,\n                                 f: fn(Parser) -> T) -> spanned<~[T]> {\n         let lo = self.span.lo;\n-        self.expect(token::LT);\n+        self.expect(&token::LT);\n         let result = self.parse_seq_to_before_gt::<T>(sep, f);\n         let hi = self.span.hi;\n         self.expect_gt();\n@@ -280,7 +281,7 @@ pub impl Parser {\n             match sep.sep {\n               Some(ref t) => {\n                 if first { first = false; }\n-                else { self.expect(*t); }\n+                else { self.expect(t); }\n               }\n               _ => ()\n             }\n@@ -297,7 +298,7 @@ pub impl Parser {\n                                    +ket: token::Token,\n                                     sep: SeqSep,\n                                     f: fn(Parser) -> T) -> ~[T] {\n-        self.expect(bra);\n+        self.expect(&bra);\n         let result = self.parse_seq_to_before_end::<T>(ket, sep, f);\n         self.bump();\n         return result;\n@@ -308,7 +309,7 @@ pub impl Parser {\n     fn parse_seq<T:Copy>(bra: token::Token, ket: token::Token, sep: SeqSep,\n                           f: fn(Parser) -> T) -> spanned<~[T]> {\n         let lo = self.span.lo;\n-        self.expect(bra);\n+        self.expect(&bra);\n         let result = self.parse_seq_to_before_end::<T>(ket, sep, f);\n         let hi = self.span.hi;\n         self.bump();"}, {"sha": "da7a0e0e4d3293eb84364ac9ffdd1495b637c29a", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 66, "deletions": 65, "changes": 131, "blob_url": "https://github.com/rust-lang/rust/blob/3635480b157389ce3e65bb5b9ccd0ced8e21e1c7/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3635480b157389ce3e65bb5b9ccd0ced8e21e1c7/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=3635480b157389ce3e65bb5b9ccd0ced8e21e1c7", "patch": "@@ -419,7 +419,7 @@ pub impl Parser {\n         */\n         if self.eat(&token::LT) {\n             let _lifetimes = self.parse_lifetimes();\n-            self.expect(token::GT);\n+            self.expect(&token::GT);\n         }\n         let inputs = self.parse_unspanned_seq(\n             token::LPAREN, token::RPAREN,\n@@ -512,7 +512,7 @@ pub impl Parser {\n         let lo = self.span.lo;\n         let mutbl = self.parse_mutability();\n         let id = self.parse_ident();\n-        self.expect(token::COLON);\n+        self.expect(&token::COLON);\n         let ty = self.parse_ty(false);\n         spanned(\n             lo,\n@@ -565,7 +565,7 @@ pub impl Parser {\n \n     // Parses something like \"&x\"\n     fn parse_region() -> @region {\n-        self.expect(token::BINOP(token::AND));\n+        self.expect(&token::BINOP(token::AND));\n \n         match *self.token {\n           token::IDENT(sid, _) => {\n@@ -605,7 +605,7 @@ pub impl Parser {\n                 }\n                 let t = if ts.len() == 1 && !one_tuple { ts[0].node }\n                 else { ty_tup(ts) };\n-                self.expect(token::RPAREN);\n+                self.expect(&token::RPAREN);\n                 t\n             }\n         } else if *self.token == token::AT {\n@@ -627,15 +627,15 @@ pub impl Parser {\n             }\n             ty_rec(elems)\n         } else if *self.token == token::LBRACKET {\n-            self.expect(token::LBRACKET);\n+            self.expect(&token::LBRACKET);\n             let mt = self.parse_mt();\n \n             // Parse the `* 3` in `[ int * 3 ]`\n             let t = match self.maybe_parse_fixed_vstore_with_star() {\n                 None => ty_vec(mt),\n                 Some(suffix) => ty_fixed_length_vec(mt, suffix)\n             };\n-            self.expect(token::RBRACKET);\n+            self.expect(&token::RBRACKET);\n             t\n         } else if *self.token == token::BINOP(token::AND) {\n             self.bump();\n@@ -778,7 +778,7 @@ pub impl Parser {\n             m = self.parse_arg_mode();\n             is_mutbl = self.eat_keyword(&~\"mut\");\n             let pat = self.parse_pat(false);\n-            self.expect(token::COLON);\n+            self.expect(&token::COLON);\n             pat\n         } else {\n             m = infer(self.get_id());\n@@ -853,7 +853,7 @@ pub impl Parser {\n           token::LIT_FLOAT_UNSUFFIXED(s) =>\n             lit_float_unsuffixed(self.id_to_str(s)),\n           token::LIT_STR(s) => lit_str(self.id_to_str(s)),\n-          token::LPAREN => { self.expect(token::RPAREN); lit_nil },\n+          token::LPAREN => { self.expect(&token::RPAREN); lit_nil },\n           _ => { self.unexpected_last(tok); }\n         }\n     }\n@@ -893,7 +893,7 @@ pub impl Parser {\n \n             if is_not_last {\n                 ids.push(parse_ident(self));\n-                self.expect(token::MOD_SEP);\n+                self.expect(&token::MOD_SEP);\n             } else {\n                 ids.push(parse_last_ident(self));\n                 break;\n@@ -931,7 +931,8 @@ pub impl Parser {\n             // ought to and have to sort it out later.\n             if *self.token == token::BINOP(token::SLASH)\n                 && self.look_ahead(1u) == token::BINOP(token::AND) {\n-                self.expect(token::BINOP(token::SLASH));\n+\n+                self.expect(&token::BINOP(token::SLASH));\n                 Some(self.parse_region())\n             } else {\n                 None\n@@ -1041,7 +1042,7 @@ pub impl Parser {\n         let lo = self.span.lo;\n         let m = self.parse_mutability();\n         let i = self.parse_ident();\n-        self.expect(sep);\n+        self.expect(&sep);\n         let e = self.parse_expr();\n         spanned(lo, e.span.hi, ast::field_ { mutbl: m, ident: i, expr: e })\n     }\n@@ -1108,7 +1109,7 @@ pub impl Parser {\n                 }\n             }\n             hi = self.span.hi;\n-            self.expect(token::RPAREN);\n+            self.expect(&token::RPAREN);\n \n             return if es.len() == 1 && !one_tuple {\n                 self.mk_expr(lo, self.span.hi, expr_paren(es[0]))\n@@ -1169,7 +1170,7 @@ pub impl Parser {\n                     self.bump();\n                     self.bump();\n                     let count = self.parse_expr();\n-                    self.expect(token::RBRACKET);\n+                    self.expect(&token::RBRACKET);\n                     ex = expr_repeat(first_expr, count, mutbl);\n                 } else if *self.token == token::COMMA {\n                     // Vector with two or more elements.\n@@ -1181,19 +1182,19 @@ pub impl Parser {\n                     ex = expr_vec(~[first_expr] + remaining_exprs, mutbl);\n                 } else {\n                     // Vector with one element.\n-                    self.expect(token::RBRACKET);\n+                    self.expect(&token::RBRACKET);\n                     ex = expr_vec(~[first_expr], mutbl);\n                 }\n             }\n             hi = self.span.hi;\n         } else if self.eat_keyword(&~\"log\") {\n-            self.expect(token::LPAREN);\n+            self.expect(&token::LPAREN);\n             let lvl = self.parse_expr();\n-            self.expect(token::COMMA);\n+            self.expect(&token::COMMA);\n             let e = self.parse_expr();\n             ex = expr_log(ast::log_other, lvl, e);\n             hi = self.span.hi;\n-            self.expect(token::RPAREN);\n+            self.expect(&token::RPAREN);\n         } else if self.eat_keyword(&~\"assert\") {\n             let e = self.parse_expr();\n             ex = expr_assert(e);\n@@ -1249,7 +1250,7 @@ pub impl Parser {\n                             break;\n                         }\n \n-                        self.expect(token::COMMA);\n+                        self.expect(&token::COMMA);\n \n                         if self.eat(&token::DOTDOT) {\n                             base = Some(self.parse_expr());\n@@ -1264,7 +1265,7 @@ pub impl Parser {\n                     }\n \n                     hi = pth.span.hi;\n-                    self.expect(token::RBRACE);\n+                    self.expect(&token::RBRACE);\n                     ex = expr_struct(pth, fields, base);\n                     return self.mk_expr(lo, hi, ex);\n                 }\n@@ -1282,7 +1283,7 @@ pub impl Parser {\n     }\n \n     fn parse_block_expr(lo: BytePos, blk_mode: blk_check_mode) -> @expr {\n-        self.expect(token::LBRACE);\n+        self.expect(&token::LBRACE);\n         let blk = self.parse_block_tail(lo, blk_mode);\n         return self.mk_expr(blk.span.lo, blk.span.hi, expr_block(blk));\n     }\n@@ -1308,7 +1309,7 @@ pub impl Parser {\n                     hi = self.span.hi;\n                     self.bump();\n                     let tys = if self.eat(&token::MOD_SEP) {\n-                        self.expect(token::LT);\n+                        self.expect(&token::LT);\n                         self.parse_seq_to_gt(Some(token::COMMA),\n                                              |p| p.parse_ty(false))\n                     } else {\n@@ -1355,7 +1356,7 @@ pub impl Parser {\n                 self.bump();\n                 let ix = self.parse_expr();\n                 hi = ix.span.hi;\n-                self.expect(token::RBRACKET);\n+                self.expect(&token::RBRACKET);\n                 e = self.mk_expr(lo, hi, expr_index(e, ix));\n               }\n \n@@ -1480,7 +1481,7 @@ pub impl Parser {\n         let mut ret_val = ~[];\n         let mut lparens = 0u;\n \n-        self.expect(bra);\n+        self.expect(&bra);\n \n         while *self.token != ket || lparens > 0u {\n             if *self.token == token::LPAREN { lparens += 1u; }\n@@ -1510,7 +1511,7 @@ pub impl Parser {\n                 match_seq(ms, sep, zerok, name_idx_lo, *name_idx)\n             } else {\n                 let bound_to = self.parse_ident();\n-                self.expect(token::COLON);\n+                self.expect(&token::COLON);\n                 let nt_name = self.parse_ident();\n                 let m = match_nonterminal(bound_to, nt_name, *name_idx);\n                 *name_idx += 1u;\n@@ -1882,7 +1883,7 @@ pub impl Parser {\n             let opt_ident;\n             if is_labeled_loop_header {\n                 opt_ident = Some(self.parse_ident());\n-                self.expect(token::COLON);\n+                self.expect(&token::COLON);\n             } else {\n                 opt_ident = None;\n             }\n@@ -1914,7 +1915,7 @@ pub impl Parser {\n     }\n \n     fn parse_record_literal() -> expr_ {\n-        self.expect(token::LBRACE);\n+        self.expect(&token::LBRACE);\n         let mut fields = ~[self.parse_field(token::COLON)];\n         let mut base = None;\n         while *self.token != token::RBRACE {\n@@ -1929,36 +1930,36 @@ pub impl Parser {\n                 break;\n             }\n \n-            self.expect(token::COMMA);\n+            self.expect(&token::COMMA);\n             if *self.token == token::RBRACE {\n                 // record ends by an optional trailing comma\n                 break;\n             }\n             fields.push(self.parse_field(token::COLON));\n         }\n-        self.expect(token::RBRACE);\n+        self.expect(&token::RBRACE);\n         self.warn(~\"REC\");\n         return expr_rec(fields, base);\n     }\n \n     fn parse_match_expr() -> @expr {\n         let lo = self.last_span.lo;\n         let discriminant = self.parse_expr();\n-        self.expect(token::LBRACE);\n+        self.expect(&token::LBRACE);\n         let mut arms: ~[arm] = ~[];\n         while *self.token != token::RBRACE {\n             let pats = self.parse_pats();\n             let mut guard = None;\n             if self.eat_keyword(&~\"if\") { guard = Some(self.parse_expr()); }\n-            self.expect(token::FAT_ARROW);\n+            self.expect(&token::FAT_ARROW);\n             let expr = self.parse_expr_res(RESTRICT_STMT_EXPR);\n \n             let require_comma =\n                 !classify::expr_is_simple_block(expr)\n                 && *self.token != token::RBRACE;\n \n             if require_comma {\n-                self.expect(token::COMMA);\n+                self.expect(&token::COMMA);\n             } else {\n                 self.eat(&token::COMMA);\n             }\n@@ -2029,7 +2030,7 @@ pub impl Parser {\n \n         while *self.token != token::RBRACKET {\n             if first { first = false; }\n-            else { self.expect(token::COMMA); }\n+            else { self.expect(&token::COMMA); }\n \n             let mut is_tail = false;\n             if *self.token == token::DOTDOT {\n@@ -2061,7 +2062,7 @@ pub impl Parser {\n         let mut first = true;\n         while *self.token != token::RBRACE {\n             if first { first = false; }\n-            else { self.expect(token::COMMA); }\n+            else { self.expect(&token::COMMA); }\n \n             if *self.token == token::UNDERSCORE {\n                 self.bump();\n@@ -2199,17 +2200,17 @@ pub impl Parser {\n                         fields.push(self.parse_pat(refutable));\n                     }\n                 }\n-                if fields.len() == 1 { self.expect(token::COMMA); }\n+                if fields.len() == 1 { self.expect(&token::COMMA); }\n                 hi = self.span.hi;\n-                self.expect(token::RPAREN);\n+                self.expect(&token::RPAREN);\n                 pat = pat_tup(fields);\n             }\n           }\n           token::LBRACKET => {\n             self.bump();\n             let (elements, tail) = self.parse_pat_vec_elements(refutable);\n             hi = self.span.hi;\n-            self.expect(token::RBRACKET);\n+            self.expect(&token::RBRACKET);\n             pat = ast::pat_vec(elements, tail);\n           }\n           copy tok => {\n@@ -2271,7 +2272,7 @@ pub impl Parser {\n                                     // This is a \"top constructor only\" pat\n                                       self.bump(); self.bump();\n                                       star_pat = true;\n-                                      self.expect(token::RPAREN);\n+                                      self.expect(&token::RPAREN);\n                                   }\n                                 _ => {\n                                     args = self.parse_unspanned_seq(\n@@ -2379,7 +2380,7 @@ pub impl Parser {\n             self.fatal(~\"expected ident\");\n         }\n         let name = self.parse_ident();\n-        self.expect(token::COLON);\n+        self.expect(&token::COLON);\n         let ty = self.parse_ty(false);\n         @spanned(lo, self.last_span.hi, ast::struct_field_ {\n             kind: named_field(name, is_mutbl, pr),\n@@ -2498,7 +2499,7 @@ pub impl Parser {\n         if self.eat_keyword(&~\"unsafe\") {\n             self.obsolete(*self.span, ObsoleteUnsafeBlock);\n         }\n-        self.expect(token::LBRACE);\n+        self.expect(&token::LBRACE);\n         let (inner, next) =\n             maybe_parse_inner_attrs_and_next(self, parse_attrs);\n         return (inner, self.parse_block_tail_(lo, default_blk, next));\n@@ -2603,7 +2604,7 @@ pub impl Parser {\n                             stmts.push(stmt);\n \n                             if classify::stmt_ends_with_semi(*stmt) {\n-                                self.expect(token::SEMI);\n+                                self.expect(&token::SEMI);\n                             }\n                         }\n                     }\n@@ -2778,7 +2779,7 @@ pub impl Parser {\n             }\n         }\n \n-        self.expect(token::LPAREN);\n+        self.expect(&token::LPAREN);\n \n         // A bit of complexity and lookahead is needed here in order to to be\n         // backwards compatible.\n@@ -2831,7 +2832,7 @@ pub impl Parser {\n                                              parse_arg_fn);\n         }\n \n-        self.expect(token::RPAREN);\n+        self.expect(&token::RPAREN);\n \n         let hi = self.span.hi;\n \n@@ -3005,7 +3006,7 @@ pub impl Parser {\n \n         let mut meths = ~[];\n         if !self.eat(&token::SEMI) {\n-            self.expect(token::LBRACE);\n+            self.expect(&token::LBRACE);\n             while !self.eat(&token::RBRACE) {\n                 meths.push(self.parse_method());\n             }\n@@ -3112,7 +3113,7 @@ pub impl Parser {\n                 };\n                 @spanned(lo, p.span.hi, struct_field_)\n             };\n-            self.expect(token::SEMI);\n+            self.expect(&token::SEMI);\n         } else if self.eat(&token::SEMI) {\n             // It's a unit-like struct.\n             is_tuple_like = true;\n@@ -3270,11 +3271,11 @@ pub impl Parser {\n \n     fn parse_item_const() -> item_info {\n         let id = self.parse_value_ident();\n-        self.expect(token::COLON);\n+        self.expect(&token::COLON);\n         let ty = self.parse_ty(false);\n-        self.expect(token::EQ);\n+        self.expect(&token::EQ);\n         let e = self.parse_expr();\n-        self.expect(token::SEMI);\n+        self.expect(&token::SEMI);\n         (id, item_const(ty, e), None)\n     }\n \n@@ -3288,10 +3289,10 @@ pub impl Parser {\n             (id, m, Some(attrs))\n         } else {\n             self.push_mod_path(id, outer_attrs);\n-            self.expect(token::LBRACE);\n+            self.expect(&token::LBRACE);\n             let (inner, next) = self.parse_inner_attrs_and_next();\n             let m = self.parse_mod_items(token::RBRACE, next);\n-            self.expect(token::RBRACE);\n+            self.expect(&token::RBRACE);\n             self.pop_mod_path();\n             (id, item_mod(m), Some(inner))\n         };\n@@ -3404,7 +3405,7 @@ pub impl Parser {\n         let (ident, tps) = self.parse_fn_header();\n         let decl = self.parse_fn_decl(|p| p.parse_arg());\n         let mut hi = self.span.hi;\n-        self.expect(token::SEMI);\n+        self.expect(&token::SEMI);\n         @ast::foreign_item { ident: ident,\n                              attrs: attrs,\n                              node: foreign_item_fn(decl, purity, tps),\n@@ -3418,10 +3419,10 @@ pub impl Parser {\n         let lo = self.span.lo;\n         self.expect_keyword(&~\"const\");\n         let ident = self.parse_ident();\n-        self.expect(token::COLON);\n+        self.expect(&token::COLON);\n         let ty = self.parse_ty(false);\n         let hi = self.span.hi;\n-        self.expect(token::SEMI);\n+        self.expect(&token::SEMI);\n         @ast::foreign_item { ident: ident,\n                              attrs: attrs,\n                              node: foreign_item_const(ty),\n@@ -3535,7 +3536,7 @@ pub impl Parser {\n \n             let (inner, next) = self.parse_inner_attrs_and_next();\n             let m = self.parse_foreign_mod_items(sort, abi, next);\n-            self.expect(token::RBRACE);\n+            self.expect(&token::RBRACE);\n \n             return iovi_item(self.mk_item(lo, self.last_span.hi, ident,\n                                      item_foreign_mod(m), visibility,\n@@ -3552,7 +3553,7 @@ pub impl Parser {\n \n         // extern mod foo;\n         let metadata = self.parse_optional_meta();\n-        self.expect(token::SEMI);\n+        self.expect(&token::SEMI);\n         iovi_view_item(@ast::view_item {\n             node: view_item_extern_mod(ident, metadata, self.get_id()),\n             attrs: attrs,\n@@ -3571,15 +3572,15 @@ pub impl Parser {\n         let (_, ident) = self.parse_type_decl();\n         self.parse_region_param();\n         let tps = self.parse_ty_params();\n-        self.expect(token::EQ);\n+        self.expect(&token::EQ);\n         let ty = self.parse_ty(false);\n-        self.expect(token::SEMI);\n+        self.expect(&token::SEMI);\n         (ident, item_ty(ty, tps), None)\n     }\n \n     fn parse_region_param() {\n         if self.eat(&token::BINOP(token::SLASH)) {\n-            self.expect(token::BINOP(token::AND));\n+            self.expect(&token::BINOP(token::AND));\n         }\n     }\n \n@@ -3641,7 +3642,7 @@ pub impl Parser {\n                 if common_fields.is_some() {\n                     self.fatal(~\"duplicate declaration of shared fields\");\n                 }\n-                self.expect(token::LBRACE);\n+                self.expect(&token::LBRACE);\n                 common_fields = Some(self.parse_struct_def());\n                 loop;\n             }\n@@ -3653,7 +3654,7 @@ pub impl Parser {\n             let mut args = ~[], disr_expr = None;\n             if self.eat_keyword(&~\"enum\") {\n                 ident = self.parse_ident();\n-                self.expect(token::LBRACE);\n+                self.expect(&token::LBRACE);\n                 let nested_enum_def = self.parse_enum_def(ty_params);\n                 kind = enum_variant_kind(nested_enum_def);\n                 needs_comma = false;\n@@ -3698,7 +3699,7 @@ pub impl Parser {\n \n             if needs_comma && !self.eat(&token::COMMA) { break; }\n         }\n-        self.expect(token::RBRACE);\n+        self.expect(&token::RBRACE);\n         if (have_disr && !all_nullary) {\n             self.fatal(~\"discriminator values can only be used with a c-like \\\n                         enum\");\n@@ -3715,7 +3716,7 @@ pub impl Parser {\n         if *self.token == token::EQ {\n             self.bump();\n             let ty = self.parse_ty(false);\n-            self.expect(token::SEMI);\n+            self.expect(&token::SEMI);\n             let variant = spanned(ty.span.lo, ty.span.hi, ast::variant_ {\n                 name: id,\n                 attrs: ~[],\n@@ -3737,7 +3738,7 @@ pub impl Parser {\n                 None\n             );\n         }\n-        self.expect(token::LBRACE);\n+        self.expect(&token::LBRACE);\n \n         let enum_definition = self.parse_enum_def(ty_params);\n         (id, item_enum(enum_definition, ty_params), None)\n@@ -3883,7 +3884,7 @@ pub impl Parser {\n         } else if self.eat_keyword(&~\"use\") {\n             // USE ITEM\n             let view_item = self.parse_use();\n-            self.expect(token::SEMI);\n+            self.expect(&token::SEMI);\n             return iovi_view_item(@ast::view_item {\n                 node: view_item,\n                 attrs: attrs,\n@@ -3902,7 +3903,7 @@ pub impl Parser {\n \n             // item macro.\n             let pth = self.parse_path_without_tps();\n-            self.expect(token::NOT);\n+            self.expect(&token::NOT);\n \n             // a 'special' identifier (like what `macro_rules!` uses)\n             // is optional. We should eventually unify invoc syntax\n@@ -4082,7 +4083,7 @@ pub impl Parser {\n         } else {\n             self.bug(~\"expected view item\");\n         };\n-        self.expect(token::SEMI);\n+        self.expect(&token::SEMI);\n         @ast::view_item { node: node,\n                           attrs: attrs,\n                           vis: vis,"}]}