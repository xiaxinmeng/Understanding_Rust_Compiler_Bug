{"sha": "d3c03d098747be06286f2aebc1e76f8c08352fdf", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQzYzAzZDA5ODc0N2JlMDYyODZmMmFlYmMxZTc2ZjhjMDgzNTJmZGY=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-06-27T05:06:22Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-06-27T05:06:22Z"}, "message": "Auto merge of #26569 - alexcrichton:msvc-llvm-update, r=brson\n\nNow that LLVM has been updated, the only remaining roadblock to implementing\r\nunwinding for MSVC is to fill out the runtime support in `std::rt::unwind::seh`.\r\nThis commit does precisely that, fixing up some other bits and pieces along the\r\nway:\r\n\r\n* The `seh` unwinding module now uses `RaiseException` to initiate a panic.\r\n* The `rust_try.ll` file was rewritten for MSVC (as it's quite different) and is\r\n  located at `rust_try_msvc_64.ll`, only included on MSVC builds for now.\r\n* The personality function for all landing pads generated by LLVM is hard-wired\r\n  to `__C_specific_handler` instead of the standard `rust_eh_personality` lang\r\n  item. This is required to get LLVM to emit SEH unwinding information instead\r\n  of DWARF unwinding information. This also means that on MSVC the\r\n  `rust_eh_personality` function is entirely unused (but is defined as it's a\r\n  lang item).\r\n\r\nMore details about how panicking works on SEH can be found in the\r\n`rust_try_msvc_64.ll` or `seh.rs` files, but I'm always open to adding more\r\ncomments!\r\n\r\nA key aspect of this PR is missing, however, which is that **unwinding is still\r\nturned off by default for MSVC**. There is a [bug in llvm][llvm-bug] which\r\ncauses optimizations to inline enough landing pads that LLVM chokes. If the\r\ncompiler is optimized at `-O1` (where inlining isn't enabled) then it can\r\nbootstrap with unwinding enabled, but when optimized at `-O2` (inlining is\r\nenabled) then it hits a fatal LLVM error.\r\n\r\n[llvm-bug]: https://llvm.org/bugs/show_bug.cgi?id=23884", "tree": {"sha": "2059612a95a7a6032f8321b7fab55b1c5b6766c6", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2059612a95a7a6032f8321b7fab55b1c5b6766c6"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d3c03d098747be06286f2aebc1e76f8c08352fdf", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d3c03d098747be06286f2aebc1e76f8c08352fdf", "html_url": "https://github.com/rust-lang/rust/commit/d3c03d098747be06286f2aebc1e76f8c08352fdf", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d3c03d098747be06286f2aebc1e76f8c08352fdf/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "773052a608736b873906f9bf1c3fd222d0b54764", "url": "https://api.github.com/repos/rust-lang/rust/commits/773052a608736b873906f9bf1c3fd222d0b54764", "html_url": "https://github.com/rust-lang/rust/commit/773052a608736b873906f9bf1c3fd222d0b54764"}, {"sha": "759a7f1f66490191a6f809c9709151d6d27cea87", "url": "https://api.github.com/repos/rust-lang/rust/commits/759a7f1f66490191a6f809c9709151d6d27cea87", "html_url": "https://github.com/rust-lang/rust/commit/759a7f1f66490191a6f809c9709151d6d27cea87"}], "stats": {"total": 458, "additions": 326, "deletions": 132}, "files": [{"sha": "edeffcdd09b9bfd8299ceb2d97a45d7d93430e7f", "filename": "mk/cfg/x86_64-pc-windows-msvc.mk", "status": "modified", "additions": 0, "deletions": 58, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/d3c03d098747be06286f2aebc1e76f8c08352fdf/mk%2Fcfg%2Fx86_64-pc-windows-msvc.mk", "raw_url": "https://github.com/rust-lang/rust/raw/d3c03d098747be06286f2aebc1e76f8c08352fdf/mk%2Fcfg%2Fx86_64-pc-windows-msvc.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Fcfg%2Fx86_64-pc-windows-msvc.mk?ref=d3c03d098747be06286f2aebc1e76f8c08352fdf", "patch": "@@ -23,64 +23,6 @@ CFG_RUN_x86_64-pc-windows-msvc=$(2)\n CFG_RUN_TARG_x86_64-pc-windows-msvc=$(call CFG_RUN_x86_64-pc-windows-msvc,,$(2))\n CFG_GNU_TRIPLE_x86_64-pc-windows-msvc := x86_64-pc-win32\n \n-# These two environment variables are scraped by the `./configure` script and\n-# are necessary for `cl.exe` to find standard headers (the INCLUDE variable) and\n-# for `link.exe` to find standard libraries (the LIB variable).\n-ifdef CFG_MSVC_INCLUDE_PATH\n-export INCLUDE := $(CFG_MSVC_INCLUDE_PATH)\n-endif\n-ifdef CFG_MSVC_LIB_PATH\n-export LIB := $(CFG_MSVC_LIB_PATH)\n-endif\n-\n-# Unfortunately `link.exe` is also a program in `/usr/bin` on MinGW installs,\n-# but it's not the one that we want. As a result we make sure that our detected\n-# `link.exe` shows up in PATH first.\n-ifdef CFG_MSVC_LINK\n-export PATH := $(CFG_MSVC_ROOT)/VC/bin/amd64:$(PATH)\n-endif\n-\n-# There are more comments about this available in the target specification for\n-# Windows MSVC in the compiler, but the gist of it is that we use `llvm-ar.exe`\n-# instead of `lib.exe` for assembling archives, so we need to inject this custom\n-# dependency here.\n-NATIVE_TOOL_DEPS_core_T_x86_64-pc-windows-msvc += llvm-ar.exe\n-INSTALLED_BINS_x86_64-pc-windows-msvc += llvm-ar.exe\n-\n-# When working with MSVC on windows, each DLL needs to explicitly declare its\n-# interface to the outside world through some means. The options for doing so\n-# include:\n-#\n-# 1. A custom attribute on each function itself\n-# 2. A linker argument saying what to export\n-# 3. A file which lists all symbols that need to be exported\n-#\n-# The Rust compiler takes care (1) for us for all Rust code by annotating all\n-# public-facing functions with dllexport, but we have a few native dependencies\n-# which need to cross the DLL boundary. The most important of these dependencies\n-# is LLVM which is linked into `rustc_llvm.dll` but primarily used from\n-# `rustc_trans.dll`. This means that many of LLVM's C API functions need to be\n-# exposed from `rustc_llvm.dll` to be forwarded over the boundary.\n-#\n-# Unfortunately, at this time, LLVM does not handle this sort of exportation on\n-# Windows for us, so we're forced to do it ourselves if we want it (which seems\n-# like the path of least resistance right now). To do this we generate a `.DEF`\n-# file [1] which we then custom-pass to the linker when building the rustc_llvm\n-# crate. This DEF file list all symbols that are exported from\n-# `src/librustc_llvm/lib.rs` and is generated by a small python script.\n-#\n-# Fun times!\n-#\n-# [1]: https://msdn.microsoft.com/en-us/library/28d6s79h.aspx\n-RUSTFLAGS_rustc_llvm_T_x86_64-pc-windows-msvc += \\\n-\t-C link-args=\"-DEF:x86_64-pc-windows-msvc/rt/rustc_llvm.def\"\n-CUSTOM_DEPS_rustc_llvm_T_x86_64-pc-windows-msvc += \\\n-\tx86_64-pc-windows-msvc/rt/rustc_llvm.def\n-\n-x86_64-pc-windows-msvc/rt/rustc_llvm.def: $(S)src/etc/mklldef.py \\\n-\t\t\t$(S)src/librustc_llvm/lib.rs\n-\t$(CFG_PYTHON) $^ $@ rustc_llvm-$(CFG_FILENAME_EXTRA)\n-\n # All windows nightiles are currently a GNU triple, so this MSVC triple is not\n # bootstrapping from itself. This is relevant during stage0, and other parts of\n # the build system take this into account."}, {"sha": "abc9cc038d0221b0a6801b93cbbe349386f50430", "filename": "mk/platform.mk", "status": "modified", "additions": 69, "deletions": 0, "changes": 69, "blob_url": "https://github.com/rust-lang/rust/blob/d3c03d098747be06286f2aebc1e76f8c08352fdf/mk%2Fplatform.mk", "raw_url": "https://github.com/rust-lang/rust/raw/d3c03d098747be06286f2aebc1e76f8c08352fdf/mk%2Fplatform.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Fplatform.mk?ref=d3c03d098747be06286f2aebc1e76f8c08352fdf", "patch": "@@ -238,3 +238,72 @@ endef\n \n $(foreach target,$(CFG_TARGET), \\\n   $(eval $(call CFG_MAKE_TOOLCHAIN,$(target))))\n+\n+# These two environment variables are scraped by the `./configure` script and\n+# are necessary for `cl.exe` to find standard headers (the INCLUDE variable) and\n+# for `link.exe` to find standard libraries (the LIB variable).\n+ifdef CFG_MSVC_INCLUDE_PATH\n+export INCLUDE := $(CFG_MSVC_INCLUDE_PATH)\n+endif\n+ifdef CFG_MSVC_LIB_PATH\n+export LIB := $(CFG_MSVC_LIB_PATH)\n+endif\n+\n+# Unfortunately `link.exe` is also a program in `/usr/bin` on MinGW installs,\n+# but it's not the one that we want. As a result we make sure that our detected\n+# `link.exe` shows up in PATH first.\n+ifdef CFG_MSVC_LINK\n+export PATH := $(CFG_MSVC_ROOT)/VC/bin/amd64:$(PATH)\n+endif\n+\n+# There are more comments about this available in the target specification for\n+# Windows MSVC in the compiler, but the gist of it is that we use `llvm-ar.exe`\n+# instead of `lib.exe` for assembling archives, so we need to inject this custom\n+# dependency here.\n+define ADD_LLVM_AR_TO_MSVC_DEPS\n+ifeq ($$(findstring msvc,$(1)),msvc)\n+NATIVE_TOOL_DEPS_core_T_$(1) += llvm-ar.exe\n+INSTALLED_BINS_$(1) += llvm-ar.exe\n+endif\n+endef\n+\n+$(foreach target,$(CFG_TARGET), \\\n+  $(eval $(call ADD_LLVM_AR_TO_MSVC_DEPS,$(target))))\n+\n+# When working with MSVC on windows, each DLL needs to explicitly declare its\n+# interface to the outside world through some means. The options for doing so\n+# include:\n+#\n+# 1. A custom attribute on each function itself\n+# 2. A linker argument saying what to export\n+# 3. A file which lists all symbols that need to be exported\n+#\n+# The Rust compiler takes care (1) for us for all Rust code by annotating all\n+# public-facing functions with dllexport, but we have a few native dependencies\n+# which need to cross the DLL boundary. The most important of these dependencies\n+# is LLVM which is linked into `rustc_llvm.dll` but primarily used from\n+# `rustc_trans.dll`. This means that many of LLVM's C API functions need to be\n+# exposed from `rustc_llvm.dll` to be forwarded over the boundary.\n+#\n+# Unfortunately, at this time, LLVM does not handle this sort of exportation on\n+# Windows for us, so we're forced to do it ourselves if we want it (which seems\n+# like the path of least resistance right now). To do this we generate a `.DEF`\n+# file [1] which we then custom-pass to the linker when building the rustc_llvm\n+# crate. This DEF file list all symbols that are exported from\n+# `src/librustc_llvm/lib.rs` and is generated by a small python script.\n+#\n+# Fun times!\n+#\n+# [1]: https://msdn.microsoft.com/en-us/library/28d6s79h.aspx\n+define ADD_RUSTC_LLVM_DEF_TO_MSVC\n+ifeq ($$(findstring msvc,$(1)),msvc)\n+RUSTFLAGS_rustc_llvm_T_$(1) += -C link-args=\"-DEF:$(1)/rt/rustc_llvm.def\"\n+CUSTOM_DEPS_rustc_llvm_T_$(1) += $(1)/rt/rustc_llvm.def\n+\n+$(1)/rt/rustc_llvm.def: $$(S)src/etc/mklldef.py $$(S)src/librustc_llvm/lib.rs\n+\t$$(CFG_PYTHON) $$^ $$@ rustc_llvm-$$(CFG_FILENAME_EXTRA)\n+endif\n+endef\n+\n+$(foreach target,$(CFG_TARGET), \\\n+  $(eval $(call ADD_RUSTC_LLVM_DEF_TO_MSVC,$(target))))"}, {"sha": "6513cf107726a63735b2cda209ab98793fbe250f", "filename": "mk/rt.mk", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/d3c03d098747be06286f2aebc1e76f8c08352fdf/mk%2Frt.mk", "raw_url": "https://github.com/rust-lang/rust/raw/d3c03d098747be06286f2aebc1e76f8c08352fdf/mk%2Frt.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Frt.mk?ref=d3c03d098747be06286f2aebc1e76f8c08352fdf", "patch": "@@ -53,9 +53,12 @@ NATIVE_DEPS_hoedown_$(1) := hoedown/src/autolink.c \\\n NATIVE_DEPS_miniz_$(1) = miniz.c\n NATIVE_DEPS_rust_builtin_$(1) := rust_builtin.c \\\n \t\t\trust_android_dummy.c\n-NATIVE_DEPS_rustrt_native_$(1) := \\\n-\t\t\trust_try.ll \\\n-\t\t\tarch/$$(HOST_$(1))/record_sp.S\n+NATIVE_DEPS_rustrt_native_$(1) := arch/$$(HOST_$(1))/record_sp.S\n+ifeq ($$(findstring msvc,$(1)),msvc)\n+NATIVE_DEPS_rustrt_native_$(1) += rust_try_msvc_64.ll\n+else\n+NATIVE_DEPS_rustrt_native_$(1) += rust_try.ll\n+endif\n NATIVE_DEPS_rust_test_helpers_$(1) := rust_test_helpers.c\n NATIVE_DEPS_morestack_$(1) := arch/$$(HOST_$(1))/morestack.S\n "}, {"sha": "cf5feabcc57e2df0fecf0b48e1f260489c0a5c03", "filename": "src/librustc_trans/back/link.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d3c03d098747be06286f2aebc1e76f8c08352fdf/src%2Flibrustc_trans%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d3c03d098747be06286f2aebc1e76f8c08352fdf/src%2Flibrustc_trans%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fback%2Flink.rs?ref=d3c03d098747be06286f2aebc1e76f8c08352fdf", "patch": "@@ -1214,11 +1214,13 @@ fn add_upstream_rust_crates(cmd: &mut Linker, sess: &Session,\n \n         // Just need to tell the linker about where the library lives and\n         // what its name is\n-        if let Some(dir) = cratepath.parent() {\n+        let parent = cratepath.parent();\n+        if let Some(dir) = parent {\n             cmd.include_path(&fix_windows_verbatim_for_gcc(dir));\n         }\n         let filestem = cratepath.file_stem().unwrap().to_str().unwrap();\n-        cmd.link_dylib(&unlib(&sess.target, filestem));\n+        cmd.link_rust_dylib(&unlib(&sess.target, filestem),\n+                            parent.unwrap_or(Path::new(\"\")));\n     }\n }\n "}, {"sha": "7253334d6998989c95104d671e630869565a5cee", "filename": "src/librustc_trans/back/linker.rs", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/d3c03d098747be06286f2aebc1e76f8c08352fdf/src%2Flibrustc_trans%2Fback%2Flinker.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d3c03d098747be06286f2aebc1e76f8c08352fdf/src%2Flibrustc_trans%2Fback%2Flinker.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fback%2Flinker.rs?ref=d3c03d098747be06286f2aebc1e76f8c08352fdf", "patch": "@@ -11,6 +11,7 @@\n use std::ffi::OsString;\n use std::path::{Path, PathBuf};\n use std::process::Command;\n+use std::fs;\n \n use rustc_back::archive;\n use session::Session;\n@@ -25,6 +26,7 @@ use session::config;\n /// MSVC linker (e.g. `link.exe`) is being used.\n pub trait Linker {\n     fn link_dylib(&mut self, lib: &str);\n+    fn link_rust_dylib(&mut self, lib: &str, path: &Path);\n     fn link_framework(&mut self, framework: &str);\n     fn link_staticlib(&mut self, lib: &str);\n     fn link_rlib(&mut self, lib: &Path);\n@@ -67,6 +69,10 @@ impl<'a> Linker for GnuLinker<'a> {\n     fn position_independent_executable(&mut self) { self.cmd.arg(\"-pie\"); }\n     fn args(&mut self, args: &[String]) { self.cmd.args(args); }\n \n+    fn link_rust_dylib(&mut self, lib: &str, _path: &Path) {\n+        self.cmd.arg(\"-l\").arg(lib);\n+    }\n+\n     fn link_framework(&mut self, framework: &str) {\n         self.cmd.arg(\"-framework\").arg(framework);\n     }\n@@ -189,6 +195,18 @@ impl<'a> Linker for MsvcLinker<'a> {\n     fn link_dylib(&mut self, lib: &str) {\n         self.cmd.arg(&format!(\"{}.lib\", lib));\n     }\n+\n+    fn link_rust_dylib(&mut self, lib: &str, path: &Path) {\n+        // When producing a dll, the MSVC linker may not actually emit a\n+        // `foo.lib` file if the dll doesn't actually export any symbols, so we\n+        // check to see if the file is there and just omit linking to it if it's\n+        // not present.\n+        let name = format!(\"{}.lib\", lib);\n+        if fs::metadata(&path.join(&name)).is_ok() {\n+            self.cmd.arg(name);\n+        }\n+    }\n+\n     fn link_staticlib(&mut self, lib: &str) {\n         self.cmd.arg(&format!(\"{}.lib\", lib));\n     }"}, {"sha": "b7e761fa4b991d62c603e6e60c98dac72f63a13d", "filename": "src/librustc_trans/trans/cleanup.rs", "status": "modified", "additions": 21, "deletions": 3, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/d3c03d098747be06286f2aebc1e76f8c08352fdf/src%2Flibrustc_trans%2Ftrans%2Fcleanup.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d3c03d098747be06286f2aebc1e76f8c08352fdf/src%2Flibrustc_trans%2Ftrans%2Fcleanup.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fcleanup.rs?ref=d3c03d098747be06286f2aebc1e76f8c08352fdf", "patch": "@@ -856,18 +856,36 @@ impl<'blk, 'tcx> CleanupHelperMethods<'blk, 'tcx> for FunctionContext<'blk, 'tcx\n         // this function, so we just codegen a generic reference to it. We don't\n         // specify any of the types for the function, we just make it a symbol\n         // that LLVM can later use.\n+        //\n+        // Note that MSVC is a little special here in that we don't use the\n+        // `eh_personality` lang item at all. Currently LLVM has support for\n+        // both Dwarf and SEH unwind mechanisms for MSVC targets and uses the\n+        // *name of the personality function* to decide what kind of unwind side\n+        // tables/landing pads to emit. It looks like Dwarf is used by default,\n+        // injecting a dependency on the `_Unwind_Resume` symbol for resuming\n+        // an \"exception\", but for MSVC we want to force SEH. This means that we\n+        // can't actually have the personality function be our standard\n+        // `rust_eh_personality` function, but rather we wired it up to the\n+        // CRT's custom `__C_specific_handler` personality funciton, which\n+        // forces LLVM to consider landing pads as \"landing pads for SEH\".\n+        let target = &self.ccx.sess().target.target;\n         let llpersonality = match pad_bcx.tcx().lang_items.eh_personality() {\n-            Some(def_id) => {\n+            Some(def_id) if !target.options.is_like_msvc => {\n                 callee::trans_fn_ref(pad_bcx.ccx(), def_id, ExprId(0),\n                                      pad_bcx.fcx.param_substs).val\n             }\n-            None => {\n+            _ => {\n                 let mut personality = self.ccx.eh_personality().borrow_mut();\n                 match *personality {\n                     Some(llpersonality) => llpersonality,\n                     None => {\n+                        let name = if target.options.is_like_msvc {\n+                            \"__C_specific_handler\"\n+                        } else {\n+                            \"rust_eh_personality\"\n+                        };\n                         let fty = Type::variadic_func(&[], &Type::i32(self.ccx));\n-                        let f = declare::declare_cfn(self.ccx, \"rust_eh_personality\", fty,\n+                        let f = declare::declare_cfn(self.ccx, name, fty,\n                                                      self.ccx.tcx().types.i32);\n                         *personality = Some(f);\n                         f"}, {"sha": "632ab4f8e253750c23028b7d71fe2f1dabfa5ad4", "filename": "src/libstd/rt/unwind/seh.rs", "status": "modified", "additions": 122, "deletions": 9, "changes": 131, "blob_url": "https://github.com/rust-lang/rust/blob/d3c03d098747be06286f2aebc1e76f8c08352fdf/src%2Flibstd%2Frt%2Funwind%2Fseh.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d3c03d098747be06286f2aebc1e76f8c08352fdf/src%2Flibstd%2Frt%2Funwind%2Fseh.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Funwind%2Fseh.rs?ref=d3c03d098747be06286f2aebc1e76f8c08352fdf", "patch": "@@ -8,23 +8,136 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+//! Win64 SEH (see http://msdn.microsoft.com/en-us/library/1eyas8tf.aspx)\n+//!\n+//! On Windows (currently only on MSVC), the default exception handling\n+//! mechanism is Structured Exception Handling (SEH). This is quite different\n+//! than Dwarf-based exception handling (e.g. what other unix platforms use) in\n+//! terms of compiler internals, so LLVM is required to have a good deal of\n+//! extra support for SEH. Currently this support is somewhat lacking, so what's\n+//! here is the bare bones of SEH support.\n+//!\n+//! In a nutshell, what happens here is:\n+//!\n+//! 1. The `panic` function calls the standard Windows function `RaiseException`\n+//!    with a Rust-specific code, triggering the unwinding process.\n+//! 2. All landing pads generated by the compiler (just \"cleanup\" landing pads)\n+//!    use the personality function `__C_specific_handler`, a function in the\n+//!    CRT, and the unwinding code in Windows will use this personality function\n+//!    to execute all cleanup code on the stack.\n+//! 3. Eventually the \"catch\" code in `rust_try` (located in\n+//!    src/rt/rust_try_msvc_64.ll) is executed, which will ensure that the\n+//!    exception being caught is indeed a Rust exception, returning control back\n+//!    into Rust.\n+//!\n+//! Some specific differences from the gcc-based exception handling are:\n+//!\n+//! * Rust has no custom personality function, it is instead *always*\n+//!   __C_specific_handler, so the filtering is done in a C++-like manner\n+//!   instead of in the personality function itself. Note that the specific\n+//!   syntax for this (found in the rust_try_msvc_64.ll) is taken from an LLVM\n+//!   test case for SEH.\n+//! * We've got some data to transmit across the unwinding boundary,\n+//!   specifically a `Box<Any + Send + 'static>`. In Dwarf-based unwinding this\n+//!   data is part of the payload of the exception, but I have not currently\n+//!   figured out how to do this with LLVM's bindings. Judging by some comments\n+//!   in the LLVM test cases this may not even be possible currently with LLVM,\n+//!   so this is just abandoned entirely. Instead the data is stored in a\n+//!   thread-local in `panic` and retrieved during `cleanup`.\n+//!\n+//! So given all that, the bindings here are pretty small,\n+\n+#![allow(bad_style)]\n+\n use prelude::v1::*;\n \n use any::Any;\n-use intrinsics;\n-use libc::c_void;\n+use libc::{c_ulong, DWORD, c_void};\n+use sys_common::thread_local::StaticKey;\n+\n+//                        0x R U S T\n+const RUST_PANIC: DWORD = 0x52555354;\n+static PANIC_DATA: StaticKey = StaticKey::new(None);\n+\n+// This function is provided by kernel32.dll\n+extern \"system\" {\n+    fn RaiseException(dwExceptionCode: DWORD,\n+                      dwExceptionFlags: DWORD,\n+                      nNumberOfArguments: DWORD,\n+                      lpArguments: *const c_ulong);\n+}\n+\n+#[repr(C)]\n+pub struct EXCEPTION_POINTERS {\n+    ExceptionRecord: *mut EXCEPTION_RECORD,\n+    ContextRecord: *mut CONTEXT,\n+}\n+\n+enum CONTEXT {}\n+\n+#[repr(C)]\n+struct EXCEPTION_RECORD {\n+    ExceptionCode: DWORD,\n+    ExceptionFlags: DWORD,\n+    ExceptionRecord: *mut _EXCEPTION_RECORD,\n+    ExceptionAddress: *mut c_void,\n+    NumberParameters: DWORD,\n+    ExceptionInformation: [*mut c_ulong; EXCEPTION_MAXIMUM_PARAMETERS],\n+}\n \n-pub unsafe fn panic(_data: Box<Any + Send + 'static>) -> ! {\n-    intrinsics::abort();\n+enum _EXCEPTION_RECORD {}\n+\n+const EXCEPTION_MAXIMUM_PARAMETERS: usize = 15;\n+\n+pub unsafe fn panic(data: Box<Any + Send + 'static>) -> ! {\n+    // See module docs above for an explanation of why `data` is stored in a\n+    // thread local instead of being passed as an argument to the\n+    // `RaiseException` function (which can in theory carry along arbitrary\n+    // data).\n+    let exception = Box::new(data);\n+    rtassert!(PANIC_DATA.get().is_null());\n+    PANIC_DATA.set(Box::into_raw(exception) as *mut u8);\n+\n+    RaiseException(RUST_PANIC, 0, 0, 0 as *const _);\n+    rtabort!(\"could not unwind stack\");\n }\n \n-pub unsafe fn cleanup(_ptr: *mut c_void) -> Box<Any + Send + 'static> {\n-    intrinsics::abort();\n+pub unsafe fn cleanup(ptr: *mut c_void) -> Box<Any + Send + 'static> {\n+    // The `ptr` here actually corresponds to the code of the exception, and our\n+    // real data is stored in our thread local.\n+    rtassert!(ptr as DWORD == RUST_PANIC);\n+\n+    let data = PANIC_DATA.get() as *mut Box<Any + Send + 'static>;\n+    PANIC_DATA.set(0 as *mut u8);\n+    rtassert!(!data.is_null());\n+\n+    *Box::from_raw(data)\n }\n \n+// This is required by the compiler to exist (e.g. it's a lang item), but it's\n+// never actually called by the compiler because __C_specific_handler is the\n+// personality function that is always used. Hence this is just an aborting\n+// stub.\n #[lang = \"eh_personality\"]\n-#[no_mangle]\n-pub extern fn rust_eh_personality() {}\n+fn rust_eh_personality() {\n+    unsafe { ::intrinsics::abort() }\n+}\n \n+// This is a function referenced from `rust_try_msvc_64.ll` which is used to\n+// filter the exceptions being caught by that function.\n+//\n+// In theory local variables can be accessed through the `rbp` parameter of this\n+// function, but a comment in an LLVM test case indicates that this is not\n+// implemented in LLVM, so this is just an idempotent function which doesn't\n+// ferry along any other information.\n+//\n+// This function just takes a look at the current EXCEPTION_RECORD being thrown\n+// to ensure that it's code is RUST_PANIC, which was set by the call to\n+// `RaiseException` above in the `panic` function.\n #[no_mangle]\n-pub extern fn rust_eh_personality_catch() {}\n+pub extern fn __rust_try_filter(eh_ptrs: *mut EXCEPTION_POINTERS,\n+                                _rbp: *mut c_void) -> i32 {\n+    unsafe {\n+        ((*(*eh_ptrs).ExceptionRecord).ExceptionCode == RUST_PANIC) as i32\n+    }\n+}"}, {"sha": "bda136d84780b98d503b03a2826a1cf34fc083d9", "filename": "src/rt/rust_try_msvc_64.ll", "status": "added", "additions": 78, "deletions": 0, "changes": 78, "blob_url": "https://github.com/rust-lang/rust/blob/d3c03d098747be06286f2aebc1e76f8c08352fdf/src%2Frt%2Frust_try_msvc_64.ll", "raw_url": "https://github.com/rust-lang/rust/raw/d3c03d098747be06286f2aebc1e76f8c08352fdf/src%2Frt%2Frust_try_msvc_64.ll", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_try_msvc_64.ll?ref=d3c03d098747be06286f2aebc1e76f8c08352fdf", "patch": "@@ -0,0 +1,78 @@\n+; Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+; file at the top-level directory of this distribution and at\n+; http://rust-lang.org/COPYRIGHT.\n+;\n+; Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+; http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+; <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+; option. This file may not be copied, modified, or distributed\n+; except according to those terms.\n+\n+; 64-bit MSVC's definition of the `rust_try` function. This function can't be\n+; defined in Rust as it's a \"try-catch\" block that's not expressible in Rust's\n+; syntax, so we're using LLVM to produce an object file with the associated\n+; handler.\n+;\n+; To use the correct system implementation details, this file is separate from\n+; the standard rust_try.ll as we need specifically use the __C_specific_handler\n+; personality function or otherwise LLVM doesn't emit SEH handling tables.\n+; There's also a few fiddly bits about SEH right now in LLVM that require us to\n+; structure this a fairly particular way!\n+;\n+; See also: src/libstd/rt/unwind/seh.rs\n+\n+define i8* @rust_try(void (i8*)* %f, i8* %env) {\n+    invoke void %f(i8* %env)\n+        to label %normal\n+        unwind label %catch\n+\n+normal:\n+    ret i8* null\n+\n+; Here's where most of the magic happens, this is the only landing pad in rust\n+; tagged with \"catch\" to indicate that we're catching an exception. The other\n+; catch handlers in rust_try.ll just catch *all* exceptions, but that's because\n+; most exceptions are already filtered out by their personality function.\n+;\n+; For MSVC we're just using a standard personality function that we can't\n+; customize, so we need to do the exception filtering ourselves, and this is\n+; currently performed by the `__rust_try_filter` function. This function,\n+; specified in the landingpad instruction, will be invoked by Windows SEH\n+; routines and will return whether the exception in question can be caught (aka\n+; the Rust runtime is the one that threw the exception).\n+;\n+; To get this to compile (currently LLVM segfaults if it's not in this\n+; particular structure), when the landingpad is executing we test to make sure\n+; that the ID of the exception being thrown is indeed the one that we were\n+; expecting. If it's not, we resume the exception, and otherwise we return the\n+; pointer that we got\n+;\n+; Full disclosure: It's not clear to me what this `llvm.eh.typeid` stuff is\n+; doing *other* then just allowing LLVM to compile this file without\n+; segfaulting. I would expect the entire landing pad to just be:\n+;\n+;     %vals = landingpad ...\n+;     %ehptr = extractvalue { i8*, i32 } %vals, 0\n+;     ret i8* %ehptr\n+;\n+; but apparently LLVM chokes on this, so we do the more complicated thing to\n+; placate it.\n+catch:\n+    %vals = landingpad { i8*, i32 } personality i8* bitcast (i32 (...)* @__C_specific_handler to i8*)\n+        catch i8* bitcast (i32 (i8*, i8*)* @__rust_try_filter to i8*)\n+    %ehptr = extractvalue { i8*, i32 } %vals, 0\n+    %sel = extractvalue { i8*, i32 } %vals, 1\n+    %filter_sel = call i32 @llvm.eh.typeid.for(i8* bitcast (i32 (i8*, i8*)* @__rust_try_filter to i8*))\n+    %is_filter = icmp eq i32 %sel, %filter_sel\n+    br i1 %is_filter, label %catch-return, label %catch-resume\n+\n+catch-return:\n+    ret i8* %ehptr\n+\n+catch-resume:\n+    resume { i8*, i32 } %vals\n+}\n+\n+declare i32 @__C_specific_handler(...)\n+declare i32 @__rust_try_filter(i8*, i8*)\n+declare i32 @llvm.eh.typeid.for(i8*) readnone nounwind"}, {"sha": "4b60a370187af15bbb3ea1b05edc1c3aa11fd83f", "filename": "src/test/auxiliary/lang-item-public.rs", "status": "modified", "additions": 7, "deletions": 28, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/d3c03d098747be06286f2aebc1e76f8c08352fdf/src%2Ftest%2Fauxiliary%2Flang-item-public.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d3c03d098747be06286f2aebc1e76f8c08352fdf/src%2Ftest%2Fauxiliary%2Flang-item-public.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Flang-item-public.rs?ref=d3c03d098747be06286f2aebc1e76f8c08352fdf", "patch": "@@ -8,42 +8,21 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#![feature(no_std)]\n+#![feature(no_std, core, libc)]\n #![no_std]\n #![feature(lang_items)]\n \n-#[lang=\"sized\"]\n-pub trait Sized { }\n-\n-#[lang=\"panic\"]\n-fn panic(_: &(&'static str, &'static str, usize)) -> ! { loop {} }\n+extern crate core;\n+extern crate libc;\n \n #[lang = \"stack_exhausted\"]\n extern fn stack_exhausted() {}\n \n #[lang = \"eh_personality\"]\n extern fn eh_personality() {}\n \n-#[lang=\"copy\"]\n-pub trait Copy {\n-    // Empty.\n-}\n-\n-#[lang=\"rem\"]\n-pub trait Rem<RHS=Self> {\n-    type Output = Self;\n-    fn rem(self, rhs: RHS) -> Self::Output;\n-}\n-\n-impl Rem for isize {\n-    type Output = isize;\n-\n-    #[inline]\n-    fn rem(self, other: isize) -> isize {\n-        // if you use `self % other` here, as one would expect, you\n-        // get back an error because of potential failure/overflow,\n-        // which tries to invoke error fns that don't have the\n-        // appropriate signatures anymore. So...just return 0.\n-        0\n-    }\n+#[lang = \"panic_fmt\"]\n+extern fn rust_begin_unwind(msg: core::fmt::Arguments, file: &'static str,\n+                            line: u32) -> ! {\n+    loop {}\n }"}, {"sha": "57a32ba599f93d0aeda49e41a1bed2f166fe0dd6", "filename": "src/test/run-pass/lang-item-public.rs", "status": "modified", "additions": 1, "deletions": 29, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/d3c03d098747be06286f2aebc1e76f8c08352fdf/src%2Ftest%2Frun-pass%2Flang-item-public.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d3c03d098747be06286f2aebc1e76f8c08352fdf/src%2Ftest%2Frun-pass%2Flang-item-public.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Flang-item-public.rs?ref=d3c03d098747be06286f2aebc1e76f8c08352fdf", "patch": "@@ -11,39 +11,11 @@\n // aux-build:lang-item-public.rs\n // ignore-android\n \n-#![feature(lang_items, start, no_std)]\n+#![feature(start, no_std)]\n #![no_std]\n \n extern crate lang_item_public as lang_lib;\n \n-#[cfg(target_os = \"linux\")]\n-#[link(name = \"c\")]\n-extern {}\n-\n-#[cfg(target_os = \"android\")]\n-#[link(name = \"c\")]\n-extern {}\n-\n-#[cfg(target_os = \"freebsd\")]\n-#[link(name = \"execinfo\")]\n-extern {}\n-\n-#[cfg(target_os = \"freebsd\")]\n-#[link(name = \"c\")]\n-extern {}\n-\n-#[cfg(target_os = \"dragonfly\")]\n-#[link(name = \"c\")]\n-extern {}\n-\n-#[cfg(any(target_os = \"bitrig\", target_os = \"openbsd\"))]\n-#[link(name = \"c\")]\n-extern {}\n-\n-#[cfg(target_os = \"macos\")]\n-#[link(name = \"System\")]\n-extern {}\n-\n #[start]\n fn main(_: isize, _: *const *const u8) -> isize {\n     1_isize % 1_isize"}]}