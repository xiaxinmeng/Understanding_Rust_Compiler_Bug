{"sha": "7672bff3780ef0e7ba5313bf23644465644e19e6", "node_id": "MDY6Q29tbWl0NzI0NzEyOjc2NzJiZmYzNzgwZWYwZTdiYTUzMTNiZjIzNjQ0NDY1NjQ0ZTE5ZTY=", "commit": {"author": {"name": "Mazdak Farrokhzad", "email": "twingoow@gmail.com", "date": "2019-12-01T10:07:49Z"}, "committer": {"name": "Mazdak Farrokhzad", "email": "twingoow@gmail.com", "date": "2019-12-12T16:54:48Z"}, "message": "Unify associated function parsing.", "tree": {"sha": "9b7530f48523da9cfb6407ca8aed4fba155f5241", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9b7530f48523da9cfb6407ca8aed4fba155f5241"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7672bff3780ef0e7ba5313bf23644465644e19e6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7672bff3780ef0e7ba5313bf23644465644e19e6", "html_url": "https://github.com/rust-lang/rust/commit/7672bff3780ef0e7ba5313bf23644465644e19e6", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7672bff3780ef0e7ba5313bf23644465644e19e6/comments", "author": {"login": "Centril", "id": 855702, "node_id": "MDQ6VXNlcjg1NTcwMg==", "avatar_url": "https://avatars.githubusercontent.com/u/855702?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Centril", "html_url": "https://github.com/Centril", "followers_url": "https://api.github.com/users/Centril/followers", "following_url": "https://api.github.com/users/Centril/following{/other_user}", "gists_url": "https://api.github.com/users/Centril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Centril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Centril/subscriptions", "organizations_url": "https://api.github.com/users/Centril/orgs", "repos_url": "https://api.github.com/users/Centril/repos", "events_url": "https://api.github.com/users/Centril/events{/privacy}", "received_events_url": "https://api.github.com/users/Centril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Centril", "id": 855702, "node_id": "MDQ6VXNlcjg1NTcwMg==", "avatar_url": "https://avatars.githubusercontent.com/u/855702?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Centril", "html_url": "https://github.com/Centril", "followers_url": "https://api.github.com/users/Centril/followers", "following_url": "https://api.github.com/users/Centril/following{/other_user}", "gists_url": "https://api.github.com/users/Centril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Centril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Centril/subscriptions", "organizations_url": "https://api.github.com/users/Centril/orgs", "repos_url": "https://api.github.com/users/Centril/repos", "events_url": "https://api.github.com/users/Centril/events{/privacy}", "received_events_url": "https://api.github.com/users/Centril/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "10270bcd30d1d85a003412e597e367f2e7c89942", "url": "https://api.github.com/repos/rust-lang/rust/commits/10270bcd30d1d85a003412e597e367f2e7c89942", "html_url": "https://github.com/rust-lang/rust/commit/10270bcd30d1d85a003412e597e367f2e7c89942"}], "stats": {"total": 66, "additions": 24, "deletions": 42}, "files": [{"sha": "32cc156783cc3e77f2deb3ef7a72fad7b78aa395", "filename": "src/librustc_parse/parser/item.rs", "status": "modified", "additions": 23, "deletions": 42, "changes": 65, "blob_url": "https://github.com/rust-lang/rust/blob/7672bff3780ef0e7ba5313bf23644465644e19e6/src%2Flibrustc_parse%2Fparser%2Fitem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7672bff3780ef0e7ba5313bf23644465644e19e6/src%2Flibrustc_parse%2Fparser%2Fitem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_parse%2Fparser%2Fitem.rs?ref=7672bff3780ef0e7ba5313bf23644465644e19e6", "patch": "@@ -6,7 +6,7 @@ use crate::maybe_whole;\n use rustc_errors::{PResult, Applicability, DiagnosticBuilder, StashKey};\n use rustc_error_codes::*;\n use syntax::ast::{self, DUMMY_NODE_ID, Ident, Attribute, AttrKind, AttrStyle, AnonConst, Item};\n-use syntax::ast::{ItemKind, ImplItem, ImplItemKind, TraitItem, TraitItemKind, UseTree, UseTreeKind};\n+use syntax::ast::{ItemKind, ImplItem, TraitItem, TraitItemKind, UseTree, UseTreeKind};\n use syntax::ast::{AssocItemKind};\n use syntax::ast::{PathSegment, IsAuto, Constness, IsAsync, Unsafety, Defaultness, Extern, StrLit};\n use syntax::ast::{Visibility, VisibilityKind, Mutability, FnHeader, ForeignItem, ForeignItemKind};\n@@ -705,7 +705,7 @@ impl<'a> Parser<'a> {\n             // FIXME: code copied from `parse_macro_use_or_failure` -- use abstraction!\n             (Ident::invalid(), ast::ImplItemKind::Macro(mac), Generics::default())\n         } else {\n-            self.parse_impl_method(at_end, &mut attrs)?\n+            self.parse_assoc_fn(at_end, &mut attrs, |_| true)?\n         };\n \n         Ok(ImplItem {\n@@ -876,7 +876,11 @@ impl<'a> Parser<'a> {\n             // trait item macro.\n             (Ident::invalid(), TraitItemKind::Macro(mac), Generics::default())\n         } else {\n-            self.parse_trait_item_method(at_end, &mut attrs)?\n+            // This is somewhat dubious; We don't want to allow\n+            // param names to be left off if there is a definition...\n+            //\n+            // We don't allow param names to be left off in edition 2018.\n+            self.parse_assoc_fn(at_end, &mut attrs, |t| t.span.rust_2018())?\n         };\n \n         Ok(TraitItem {\n@@ -1823,48 +1827,40 @@ impl<'a> Parser<'a> {\n         })\n     }\n \n-    /// Parses a method or a macro invocation in a trait impl.\n-    fn parse_impl_method(\n-        &mut self,\n-        at_end: &mut bool,\n-        attrs: &mut Vec<Attribute>,\n-    ) -> PResult<'a, (Ident, ImplItemKind, Generics)> {\n-        let (ident, sig, generics) = self.parse_method_sig(|_| true)?;\n-        let body = self.parse_trait_method_body(at_end, attrs)?;\n-        Ok((ident, ast::ImplItemKind::Method(sig, body), generics))\n-    }\n-\n-    fn parse_trait_item_method(\n+    fn parse_assoc_fn(\n         &mut self,\n         at_end: &mut bool,\n         attrs: &mut Vec<Attribute>,\n-    ) -> PResult<'a, (Ident, TraitItemKind, Generics)> {\n-        // This is somewhat dubious; We don't want to allow\n-        // argument names to be left off if there is a definition...\n-        //\n-        // We don't allow argument names to be left off in edition 2018.\n-        let (ident, sig, generics) = self.parse_method_sig(|t| t.span.rust_2018())?;\n-        let body = self.parse_trait_method_body(at_end, attrs)?;\n-        Ok((ident, TraitItemKind::Method(sig, body), generics))\n+        is_name_required: fn(&token::Token) -> bool,\n+    ) -> PResult<'a, (Ident, AssocItemKind, Generics)> {\n+        let header = self.parse_fn_front_matter()?;\n+        let (ident, decl, generics) = self.parse_fn_sig(ParamCfg {\n+            is_self_allowed: true,\n+            allow_c_variadic: false,\n+            is_name_required,\n+        })?;\n+        let sig = FnSig { header, decl };\n+        let body = self.parse_assoc_fn_body(at_end, attrs)?;\n+        Ok((ident, AssocItemKind::Method(sig, body), generics))\n     }\n \n-    /// Parse the \"body\" of a method in a trait item definition.\n+    /// Parse the \"body\" of a method in an associated item definition.\n     /// This can either be `;` when there's no body,\n     /// or e.g. a block when the method is a provided one.\n-    fn parse_trait_method_body(\n+    fn parse_assoc_fn_body(\n         &mut self,\n         at_end: &mut bool,\n         attrs: &mut Vec<Attribute>,\n     ) -> PResult<'a, Option<P<Block>>> {\n         Ok(match self.token.kind {\n             token::Semi => {\n-                debug!(\"parse_trait_method_body(): parsing required method\");\n+                debug!(\"parse_assoc_fn_body(): parsing required method\");\n                 self.bump();\n                 *at_end = true;\n                 None\n             }\n             token::OpenDelim(token::Brace) => {\n-                debug!(\"parse_trait_method_body(): parsing provided method\");\n+                debug!(\"parse_assoc_fn_body(): parsing provided method\");\n                 *at_end = true;\n                 let (inner_attrs, body) = self.parse_inner_attrs_and_block()?;\n                 attrs.extend(inner_attrs.iter().cloned());\n@@ -1885,21 +1881,6 @@ impl<'a> Parser<'a> {\n         })\n     }\n \n-    /// Parse the \"signature\", including the identifier, parameters, and generics\n-    /// of a method. The body is not parsed as that differs between `trait`s and `impl`s.\n-    fn parse_method_sig(\n-        &mut self,\n-        is_name_required: fn(&token::Token) -> bool,\n-    ) -> PResult<'a, (Ident, FnSig, Generics)> {\n-        let header = self.parse_fn_front_matter()?;\n-        let (ident, decl, generics) = self.parse_fn_sig(ParamCfg {\n-            is_self_allowed: true,\n-            allow_c_variadic: false,\n-            is_name_required,\n-        })?;\n-        Ok((ident, FnSig { header, decl }, generics))\n-    }\n-\n     /// Parses all the \"front matter\" for a `fn` declaration, up to\n     /// and including the `fn` keyword:\n     ///"}, {"sha": "5866f9db078fd9c0e1789cc673aa37b34080c20c", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/7672bff3780ef0e7ba5313bf23644465644e19e6/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7672bff3780ef0e7ba5313bf23644465644e19e6/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=7672bff3780ef0e7ba5313bf23644465644e19e6", "patch": "@@ -1640,6 +1640,7 @@ pub enum AssocItemKind  {\n     Const(P<Ty>, Option<P<Expr>>),\n \n     /// An associated function.\n+    /// FIXME(Centril): Rename to `Fn`.\n     Method(FnSig, Option<P<Block>>),\n \n     /// An associated type."}]}