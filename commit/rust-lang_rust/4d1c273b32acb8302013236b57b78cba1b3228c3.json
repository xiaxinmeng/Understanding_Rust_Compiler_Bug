{"sha": "4d1c273b32acb8302013236b57b78cba1b3228c3", "node_id": "C_kwDOAAsO6NoAKDRkMWMyNzNiMzJhY2I4MzAyMDEzMjM2YjU3Yjc4Y2JhMWIzMjI4YzM", "commit": {"author": {"name": "Dylan DPC", "email": "99973273+Dylan-DPC@users.noreply.github.com", "date": "2022-08-23T15:10:01Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2022-08-23T15:10:01Z"}, "message": "Rollup merge of #99249 - cjgillot:no-reparse-fn, r=fee1-dead\n\nDo not re-parse function signatures to suggest generics\n\nThis PR uses the existing resolution rib infrastructure to channel the correct span information to suggest generic parameters.  This allows to avoid re-parsing a function's source code.\n\nDrive-by cleanup: this removes useless `FnItemRibKind` from late resolution ribs.  All the use cases are already covered by `ItemRibKind` and `AssocItemRibKind` which have more precise semantics.", "tree": {"sha": "7f885eb61f5914fe8771e23c4818e88c14176151", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7f885eb61f5914fe8771e23c4818e88c14176151"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4d1c273b32acb8302013236b57b78cba1b3228c3", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJjBO3JCRBK7hj4Ov3rIwAA4MgIAH8QPvRmxMYNn47Dwohqp1Sl\n7PW0cfEP6km086PZY2Ma5IXZUQaCtMya2SwyvECLBg4i3JlqlnJVEfWMbuZe4Y7b\njmfjBToUH5QYvTSVUqwAWmdAmK1QJMTd2RlOfGbJbMWfUJ4C7usRMli+YOyWxQOC\nyK8rWF8h9kzy3u1ysqkemZbPAmHIaGJD/LoSA2bencdNTc93QtismBzAWKfQSOgg\nEa5ZnXCIW5irskDmYhVIQ0QoORXx9zdagtDeew2zAlIks0WFI3770MAlDdwJUIZh\n2OUK7uHfYknh6jtCliuUHImDsOHqqZ5mIbhQJK1UfNQTk4lBE0sMfStKVmsoRUU=\n=/v6v\n-----END PGP SIGNATURE-----\n", "payload": "tree 7f885eb61f5914fe8771e23c4818e88c14176151\nparent 1cff5642037b83ce1239a624bbe617a9aa0d59b1\nparent dff428013dde1e89b6c644b9649f0dc53ceac354\nauthor Dylan DPC <99973273+Dylan-DPC@users.noreply.github.com> 1661267401 +0530\ncommitter GitHub <noreply@github.com> 1661267401 +0530\n\nRollup merge of #99249 - cjgillot:no-reparse-fn, r=fee1-dead\n\nDo not re-parse function signatures to suggest generics\n\nThis PR uses the existing resolution rib infrastructure to channel the correct span information to suggest generic parameters.  This allows to avoid re-parsing a function's source code.\n\nDrive-by cleanup: this removes useless `FnItemRibKind` from late resolution ribs.  All the use cases are already covered by `ItemRibKind` and `AssocItemRibKind` which have more precise semantics.\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4d1c273b32acb8302013236b57b78cba1b3228c3", "html_url": "https://github.com/rust-lang/rust/commit/4d1c273b32acb8302013236b57b78cba1b3228c3", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4d1c273b32acb8302013236b57b78cba1b3228c3/comments", "author": {"login": "Dylan-DPC", "id": 99973273, "node_id": "U_kgDOBfV4mQ", "avatar_url": "https://avatars.githubusercontent.com/u/99973273?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Dylan-DPC", "html_url": "https://github.com/Dylan-DPC", "followers_url": "https://api.github.com/users/Dylan-DPC/followers", "following_url": "https://api.github.com/users/Dylan-DPC/following{/other_user}", "gists_url": "https://api.github.com/users/Dylan-DPC/gists{/gist_id}", "starred_url": "https://api.github.com/users/Dylan-DPC/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Dylan-DPC/subscriptions", "organizations_url": "https://api.github.com/users/Dylan-DPC/orgs", "repos_url": "https://api.github.com/users/Dylan-DPC/repos", "events_url": "https://api.github.com/users/Dylan-DPC/events{/privacy}", "received_events_url": "https://api.github.com/users/Dylan-DPC/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1cff5642037b83ce1239a624bbe617a9aa0d59b1", "url": "https://api.github.com/repos/rust-lang/rust/commits/1cff5642037b83ce1239a624bbe617a9aa0d59b1", "html_url": "https://github.com/rust-lang/rust/commit/1cff5642037b83ce1239a624bbe617a9aa0d59b1"}, {"sha": "dff428013dde1e89b6c644b9649f0dc53ceac354", "url": "https://api.github.com/repos/rust-lang/rust/commits/dff428013dde1e89b6c644b9649f0dc53ceac354", "html_url": "https://github.com/rust-lang/rust/commit/dff428013dde1e89b6c644b9649f0dc53ceac354"}], "stats": {"total": 352, "additions": 134, "deletions": 218}, "files": [{"sha": "25013036d87493017476c616b04671b1d81548b2", "filename": "compiler/rustc_resolve/src/diagnostics.rs", "status": "modified", "additions": 15, "deletions": 18, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/4d1c273b32acb8302013236b57b78cba1b3228c3/compiler%2Frustc_resolve%2Fsrc%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4d1c273b32acb8302013236b57b78cba1b3228c3/compiler%2Frustc_resolve%2Fsrc%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Fdiagnostics.rs?ref=4d1c273b32acb8302013236b57b78cba1b3228c3", "patch": "@@ -511,7 +511,7 @@ impl<'a> Resolver<'a> {\n                 err.span_label(span, \"use of generic parameter from outer function\");\n \n                 let sm = self.session.source_map();\n-                match outer_res {\n+                let def_id = match outer_res {\n                     Res::SelfTy { trait_: maybe_trait_defid, alias_to: maybe_impl_defid } => {\n                         if let Some(impl_span) =\n                             maybe_impl_defid.and_then(|(def_id, _)| self.opt_span(def_id))\n@@ -536,40 +536,37 @@ impl<'a> Resolver<'a> {\n                         if let Some(span) = self.opt_span(def_id) {\n                             err.span_label(span, \"type parameter from outer function\");\n                         }\n+                        def_id\n                     }\n                     Res::Def(DefKind::ConstParam, def_id) => {\n                         if let Some(span) = self.opt_span(def_id) {\n                             err.span_label(span, \"const parameter from outer function\");\n                         }\n+                        def_id\n                     }\n                     _ => {\n                         bug!(\n                             \"GenericParamsFromOuterFunction should only be used with Res::SelfTy, \\\n                             DefKind::TyParam or DefKind::ConstParam\"\n                         );\n                     }\n-                }\n+                };\n \n-                if has_generic_params == HasGenericParams::Yes {\n+                if let HasGenericParams::Yes(span) = has_generic_params {\n                     // Try to retrieve the span of the function signature and generate a new\n                     // message with a local type or const parameter.\n                     let sugg_msg = \"try using a local generic parameter instead\";\n-                    if let Some((sugg_span, snippet)) = sm.generate_local_type_param_snippet(span) {\n-                        // Suggest the modification to the user\n-                        err.span_suggestion(\n-                            sugg_span,\n-                            sugg_msg,\n-                            snippet,\n-                            Applicability::MachineApplicable,\n-                        );\n-                    } else if let Some(sp) = sm.generate_fn_name_span(span) {\n-                        err.span_label(\n-                            sp,\n-                            \"try adding a local generic parameter in this method instead\",\n-                        );\n+                    let name = self.opt_name(def_id).unwrap_or(sym::T);\n+                    let (span, snippet) = if span.is_empty() {\n+                        let snippet = format!(\"<{}>\", name);\n+                        (span, snippet)\n                     } else {\n-                        err.help(\"try using a local generic parameter instead\");\n-                    }\n+                        let span = sm.span_through_char(span, '<').shrink_to_hi();\n+                        let snippet = format!(\"{}, \", name);\n+                        (span, snippet)\n+                    };\n+                    // Suggest the modification to the user\n+                    err.span_suggestion(span, sugg_msg, snippet, Applicability::MaybeIncorrect);\n                 }\n \n                 err"}, {"sha": "41a0c76d83a9539768a276532392e9b8d7853c41", "filename": "compiler/rustc_resolve/src/ident.rs", "status": "modified", "additions": 12, "deletions": 16, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/4d1c273b32acb8302013236b57b78cba1b3228c3/compiler%2Frustc_resolve%2Fsrc%2Fident.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4d1c273b32acb8302013236b57b78cba1b3228c3/compiler%2Frustc_resolve%2Fsrc%2Fident.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Fident.rs?ref=4d1c273b32acb8302013236b57b78cba1b3228c3", "patch": "@@ -13,7 +13,9 @@ use rustc_span::{Span, DUMMY_SP};\n \n use std::ptr;\n \n-use crate::late::{ConstantItemKind, HasGenericParams, PathSource, Rib, RibKind};\n+use crate::late::{\n+    ConstantHasGenerics, ConstantItemKind, HasGenericParams, PathSource, Rib, RibKind,\n+};\n use crate::macros::{sub_namespace_match, MacroRulesScope};\n use crate::{AmbiguityError, AmbiguityErrorMisc, AmbiguityKind, Determinacy, Finalize};\n use crate::{ImportKind, LexicalScopeBinding, Module, ModuleKind, ModuleOrUniformRoot};\n@@ -1103,7 +1105,7 @@ impl<'a> Resolver<'a> {\n                         | ForwardGenericParamBanRibKind => {\n                             // Nothing to do. Continue.\n                         }\n-                        ItemRibKind(_) | FnItemRibKind | AssocItemRibKind => {\n+                        ItemRibKind(_) | AssocItemRibKind => {\n                             // This was an attempt to access an upvar inside a\n                             // named function item. This is not allowed, so we\n                             // report an error.\n@@ -1168,10 +1170,10 @@ impl<'a> Resolver<'a> {\n                     let has_generic_params: HasGenericParams = match rib.kind {\n                         NormalRibKind\n                         | ClosureOrAsyncRibKind\n-                        | AssocItemRibKind\n                         | ModuleRibKind(..)\n                         | MacroDefinition(..)\n                         | InlineAsmSymRibKind\n+                        | AssocItemRibKind\n                         | ForwardGenericParamBanRibKind => {\n                             // Nothing to do. Continue.\n                             continue;\n@@ -1180,7 +1182,9 @@ impl<'a> Resolver<'a> {\n                         ConstantItemRibKind(trivial, _) => {\n                             let features = self.session.features_untracked();\n                             // HACK(min_const_generics): We currently only allow `N` or `{ N }`.\n-                            if !(trivial == HasGenericParams::Yes || features.generic_const_exprs) {\n+                            if !(trivial == ConstantHasGenerics::Yes\n+                                || features.generic_const_exprs)\n+                            {\n                                 // HACK(min_const_generics): If we encounter `Self` in an anonymous constant\n                                 // we can't easily tell if it's generic at this stage, so we instead remember\n                                 // this and then enforce the self type to be concrete later on.\n@@ -1207,7 +1211,6 @@ impl<'a> Resolver<'a> {\n \n                         // This was an attempt to use a type parameter outside its scope.\n                         ItemRibKind(has_generic_params) => has_generic_params,\n-                        FnItemRibKind => HasGenericParams::Yes,\n                         ConstParamTyRibKind => {\n                             if let Some(span) = finalize {\n                                 self.report_error(\n@@ -1232,28 +1235,22 @@ impl<'a> Resolver<'a> {\n                 }\n             }\n             Res::Def(DefKind::ConstParam, _) => {\n-                let mut ribs = ribs.iter().peekable();\n-                if let Some(Rib { kind: FnItemRibKind, .. }) = ribs.peek() {\n-                    // When declaring const parameters inside function signatures, the first rib\n-                    // is always a `FnItemRibKind`. In this case, we can skip it, to avoid it\n-                    // (spuriously) conflicting with the const param.\n-                    ribs.next();\n-                }\n-\n                 for rib in ribs {\n                     let has_generic_params = match rib.kind {\n                         NormalRibKind\n                         | ClosureOrAsyncRibKind\n-                        | AssocItemRibKind\n                         | ModuleRibKind(..)\n                         | MacroDefinition(..)\n                         | InlineAsmSymRibKind\n+                        | AssocItemRibKind\n                         | ForwardGenericParamBanRibKind => continue,\n \n                         ConstantItemRibKind(trivial, _) => {\n                             let features = self.session.features_untracked();\n                             // HACK(min_const_generics): We currently only allow `N` or `{ N }`.\n-                            if !(trivial == HasGenericParams::Yes || features.generic_const_exprs) {\n+                            if !(trivial == ConstantHasGenerics::Yes\n+                                || features.generic_const_exprs)\n+                            {\n                                 if let Some(span) = finalize {\n                                     self.report_error(\n                                         span,\n@@ -1272,7 +1269,6 @@ impl<'a> Resolver<'a> {\n                         }\n \n                         ItemRibKind(has_generic_params) => has_generic_params,\n-                        FnItemRibKind => HasGenericParams::Yes,\n                         ConstParamTyRibKind => {\n                             if let Some(span) = finalize {\n                                 self.report_error("}, {"sha": "693ec86616ee431e3ff70e2bbeeef37228ba70f2", "filename": "compiler/rustc_resolve/src/late.rs", "status": "modified", "additions": 38, "deletions": 38, "changes": 76, "blob_url": "https://github.com/rust-lang/rust/blob/4d1c273b32acb8302013236b57b78cba1b3228c3/compiler%2Frustc_resolve%2Fsrc%2Flate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4d1c273b32acb8302013236b57b78cba1b3228c3/compiler%2Frustc_resolve%2Fsrc%2Flate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Flate.rs?ref=4d1c273b32acb8302013236b57b78cba1b3228c3", "patch": "@@ -91,13 +91,20 @@ enum PatBoundCtx {\n }\n \n /// Does this the item (from the item rib scope) allow generic parameters?\n-#[derive(Copy, Clone, Debug, Eq, PartialEq)]\n+#[derive(Copy, Clone, Debug)]\n pub(crate) enum HasGenericParams {\n+    Yes(Span),\n+    No,\n+}\n+\n+/// May this constant have generics?\n+#[derive(Copy, Clone, Debug, Eq, PartialEq)]\n+pub(crate) enum ConstantHasGenerics {\n     Yes,\n     No,\n }\n \n-impl HasGenericParams {\n+impl ConstantHasGenerics {\n     fn force_yes_if(self, b: bool) -> Self {\n         if b { Self::Yes } else { self }\n     }\n@@ -125,18 +132,14 @@ pub(crate) enum RibKind<'a> {\n     /// We passed through a closure. Disallow labels.\n     ClosureOrAsyncRibKind,\n \n-    /// We passed through a function definition. Disallow upvars.\n-    /// Permit only those const parameters that are specified in the function's generics.\n-    FnItemRibKind,\n-\n     /// We passed through an item scope. Disallow upvars.\n     ItemRibKind(HasGenericParams),\n \n     /// We're in a constant item. Can't refer to dynamic stuff.\n     ///\n     /// The item may reference generic parameters in trivial constant expressions.\n     /// All other constants aren't allowed to use generic params at all.\n-    ConstantItemRibKind(HasGenericParams, Option<(Ident, ConstantItemKind)>),\n+    ConstantItemRibKind(ConstantHasGenerics, Option<(Ident, ConstantItemKind)>),\n \n     /// We passed through a module.\n     ModuleRibKind(Module<'a>),\n@@ -165,7 +168,6 @@ impl RibKind<'_> {\n         match self {\n             NormalRibKind\n             | ClosureOrAsyncRibKind\n-            | FnItemRibKind\n             | ConstantItemRibKind(..)\n             | ModuleRibKind(_)\n             | MacroDefinition(_)\n@@ -182,7 +184,6 @@ impl RibKind<'_> {\n \n             AssocItemRibKind\n             | ClosureOrAsyncRibKind\n-            | FnItemRibKind\n             | ItemRibKind(..)\n             | ConstantItemRibKind(..)\n             | ModuleRibKind(..)\n@@ -751,7 +752,7 @@ impl<'a: 'ast, 'ast> Visitor<'ast> for LateResolutionVisitor<'a, '_, 'ast> {\n                 self.with_lifetime_rib(LifetimeRibKind::Item, |this| {\n                     this.with_generic_param_rib(\n                         &generics.params,\n-                        ItemRibKind(HasGenericParams::Yes),\n+                        ItemRibKind(HasGenericParams::Yes(generics.span)),\n                         LifetimeRibKind::Generics {\n                             binder: foreign_item.id,\n                             kind: LifetimeBinderKind::Item,\n@@ -765,7 +766,7 @@ impl<'a: 'ast, 'ast> Visitor<'ast> for LateResolutionVisitor<'a, '_, 'ast> {\n                 self.with_lifetime_rib(LifetimeRibKind::Item, |this| {\n                     this.with_generic_param_rib(\n                         &generics.params,\n-                        ItemRibKind(HasGenericParams::Yes),\n+                        ItemRibKind(HasGenericParams::Yes(generics.span)),\n                         LifetimeRibKind::Generics {\n                             binder: foreign_item.id,\n                             kind: LifetimeBinderKind::Function,\n@@ -786,7 +787,8 @@ impl<'a: 'ast, 'ast> Visitor<'ast> for LateResolutionVisitor<'a, '_, 'ast> {\n         }\n     }\n     fn visit_fn(&mut self, fn_kind: FnKind<'ast>, sp: Span, fn_id: NodeId) {\n-        let rib_kind = match fn_kind {\n+        let previous_value = self.diagnostic_metadata.current_function;\n+        match fn_kind {\n             // Bail if the function is foreign, and thus cannot validly have\n             // a body, or if there's no body for some other reason.\n             FnKind::Fn(FnCtxt::Foreign, _, sig, _, generics, _)\n@@ -809,20 +811,18 @@ impl<'a: 'ast, 'ast> Visitor<'ast> for LateResolutionVisitor<'a, '_, 'ast> {\n                 );\n                 return;\n             }\n-            FnKind::Fn(FnCtxt::Free, ..) => FnItemRibKind,\n-            FnKind::Fn(FnCtxt::Assoc(_), ..) => NormalRibKind,\n-            FnKind::Closure(..) => ClosureOrAsyncRibKind,\n+            FnKind::Fn(..) => {\n+                self.diagnostic_metadata.current_function = Some((fn_kind, sp));\n+            }\n+            // Do not update `current_function` for closures: it suggests `self` parameters.\n+            FnKind::Closure(..) => {}\n         };\n-        let previous_value = self.diagnostic_metadata.current_function;\n-        if matches!(fn_kind, FnKind::Fn(..)) {\n-            self.diagnostic_metadata.current_function = Some((fn_kind, sp));\n-        }\n         debug!(\"(resolving function) entering function\");\n \n         // Create a value rib for the function.\n-        self.with_rib(ValueNS, rib_kind, |this| {\n+        self.with_rib(ValueNS, ClosureOrAsyncRibKind, |this| {\n             // Create a label rib for the function.\n-            this.with_label_rib(FnItemRibKind, |this| {\n+            this.with_label_rib(ClosureOrAsyncRibKind, |this| {\n                 match fn_kind {\n                     FnKind::Fn(_, _, sig, _, generics, body) => {\n                         this.visit_generics(generics);\n@@ -995,7 +995,7 @@ impl<'a: 'ast, 'ast> Visitor<'ast> for LateResolutionVisitor<'a, '_, 'ast> {\n                             // non-trivial constants this is doesn't matter.\n                             self.with_constant_rib(\n                                 IsRepeatExpr::No,\n-                                HasGenericParams::Yes,\n+                                ConstantHasGenerics::Yes,\n                                 None,\n                                 |this| {\n                                     this.smart_resolve_path(\n@@ -2071,7 +2071,7 @@ impl<'a: 'ast, 'b, 'ast> LateResolutionVisitor<'a, 'b, 'ast> {\n         self.with_current_self_item(item, |this| {\n             this.with_generic_param_rib(\n                 &generics.params,\n-                ItemRibKind(HasGenericParams::Yes),\n+                ItemRibKind(HasGenericParams::Yes(generics.span)),\n                 LifetimeRibKind::Generics {\n                     binder: item.id,\n                     kind: LifetimeBinderKind::Item,\n@@ -2141,7 +2141,7 @@ impl<'a: 'ast, 'b, 'ast> LateResolutionVisitor<'a, 'b, 'ast> {\n             ItemKind::TyAlias(box TyAlias { ref generics, .. }) => {\n                 self.with_generic_param_rib(\n                     &generics.params,\n-                    ItemRibKind(HasGenericParams::Yes),\n+                    ItemRibKind(HasGenericParams::Yes(generics.span)),\n                     LifetimeRibKind::Generics {\n                         binder: item.id,\n                         kind: LifetimeBinderKind::Item,\n@@ -2154,7 +2154,7 @@ impl<'a: 'ast, 'b, 'ast> LateResolutionVisitor<'a, 'b, 'ast> {\n             ItemKind::Fn(box Fn { ref generics, .. }) => {\n                 self.with_generic_param_rib(\n                     &generics.params,\n-                    ItemRibKind(HasGenericParams::Yes),\n+                    ItemRibKind(HasGenericParams::Yes(generics.span)),\n                     LifetimeRibKind::Generics {\n                         binder: item.id,\n                         kind: LifetimeBinderKind::Function,\n@@ -2186,7 +2186,7 @@ impl<'a: 'ast, 'b, 'ast> LateResolutionVisitor<'a, 'b, 'ast> {\n                 // Create a new rib for the trait-wide type parameters.\n                 self.with_generic_param_rib(\n                     &generics.params,\n-                    ItemRibKind(HasGenericParams::Yes),\n+                    ItemRibKind(HasGenericParams::Yes(generics.span)),\n                     LifetimeRibKind::Generics {\n                         binder: item.id,\n                         kind: LifetimeBinderKind::Item,\n@@ -2210,7 +2210,7 @@ impl<'a: 'ast, 'b, 'ast> LateResolutionVisitor<'a, 'b, 'ast> {\n                 // Create a new rib for the trait-wide type parameters.\n                 self.with_generic_param_rib(\n                     &generics.params,\n-                    ItemRibKind(HasGenericParams::Yes),\n+                    ItemRibKind(HasGenericParams::Yes(generics.span)),\n                     LifetimeRibKind::Generics {\n                         binder: item.id,\n                         kind: LifetimeBinderKind::Item,\n@@ -2251,7 +2251,7 @@ impl<'a: 'ast, 'b, 'ast> LateResolutionVisitor<'a, 'b, 'ast> {\n                             // so it doesn't matter whether this is a trivial constant.\n                             this.with_constant_rib(\n                                 IsRepeatExpr::No,\n-                                HasGenericParams::Yes,\n+                                ConstantHasGenerics::Yes,\n                                 Some((item.ident, constant_item_kind)),\n                                 |this| this.visit_expr(expr),\n                             );\n@@ -2450,7 +2450,7 @@ impl<'a: 'ast, 'b, 'ast> LateResolutionVisitor<'a, 'b, 'ast> {\n     fn with_constant_rib(\n         &mut self,\n         is_repeat: IsRepeatExpr,\n-        may_use_generics: HasGenericParams,\n+        may_use_generics: ConstantHasGenerics,\n         item: Option<(Ident, ConstantItemKind)>,\n         f: impl FnOnce(&mut Self),\n     ) {\n@@ -2517,7 +2517,7 @@ impl<'a: 'ast, 'b, 'ast> LateResolutionVisitor<'a, 'b, 'ast> {\n                             |this| {\n                                 this.with_constant_rib(\n                                     IsRepeatExpr::No,\n-                                    HasGenericParams::Yes,\n+                                    ConstantHasGenerics::Yes,\n                                     None,\n                                     |this| this.visit_expr(expr),\n                                 )\n@@ -2598,7 +2598,7 @@ impl<'a: 'ast, 'b, 'ast> LateResolutionVisitor<'a, 'b, 'ast> {\n         // If applicable, create a rib for the type parameters.\n         self.with_generic_param_rib(\n             &generics.params,\n-            ItemRibKind(HasGenericParams::Yes),\n+            ItemRibKind(HasGenericParams::Yes(generics.span)),\n             LifetimeRibKind::Generics {\n                 span: generics.span,\n                 binder: item_id,\n@@ -2689,7 +2689,7 @@ impl<'a: 'ast, 'b, 'ast> LateResolutionVisitor<'a, 'b, 'ast> {\n                     self.with_lifetime_rib(LifetimeRibKind::Elided(LifetimeRes::Infer), |this| {\n                         this.with_constant_rib(\n                             IsRepeatExpr::No,\n-                            HasGenericParams::Yes,\n+                            ConstantHasGenerics::Yes,\n                             None,\n                             |this| this.visit_expr(expr),\n                         )\n@@ -3696,9 +3696,9 @@ impl<'a: 'ast, 'b, 'ast> LateResolutionVisitor<'a, 'b, 'ast> {\n         self.with_constant_rib(\n             is_repeat,\n             if constant.value.is_potential_trivial_const_param() {\n-                HasGenericParams::Yes\n+                ConstantHasGenerics::Yes\n             } else {\n-                HasGenericParams::No\n+                ConstantHasGenerics::No\n             },\n             None,\n             |this| visit::walk_anon_const(this, constant),\n@@ -3707,8 +3707,8 @@ impl<'a: 'ast, 'b, 'ast> LateResolutionVisitor<'a, 'b, 'ast> {\n \n     fn resolve_inline_const(&mut self, constant: &'ast AnonConst) {\n         debug!(\"resolve_anon_const {constant:?}\");\n-        self.with_constant_rib(IsRepeatExpr::No, HasGenericParams::Yes, None, |this| {\n-            visit::walk_anon_const(this, constant);\n+        self.with_constant_rib(IsRepeatExpr::No, ConstantHasGenerics::Yes, None, |this| {\n+            visit::walk_anon_const(this, constant)\n         });\n     }\n \n@@ -3814,9 +3814,9 @@ impl<'a: 'ast, 'b, 'ast> LateResolutionVisitor<'a, 'b, 'ast> {\n                         self.with_constant_rib(\n                             IsRepeatExpr::No,\n                             if argument.is_potential_trivial_const_param() {\n-                                HasGenericParams::Yes\n+                                ConstantHasGenerics::Yes\n                             } else {\n-                                HasGenericParams::No\n+                                ConstantHasGenerics::No\n                             },\n                             None,\n                             |this| {"}, {"sha": "eb727debc91bb558cc3ff4bea34771fe13dcb4f5", "filename": "compiler/rustc_resolve/src/lib.rs", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/4d1c273b32acb8302013236b57b78cba1b3228c3/compiler%2Frustc_resolve%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4d1c273b32acb8302013236b57b78cba1b3228c3/compiler%2Frustc_resolve%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Flib.rs?ref=4d1c273b32acb8302013236b57b78cba1b3228c3", "patch": "@@ -1945,6 +1945,16 @@ impl<'a> Resolver<'a> {\n         def_id.as_local().map(|def_id| self.source_span[def_id])\n     }\n \n+    /// Retrieves the name of the given `DefId`.\n+    #[inline]\n+    pub fn opt_name(&self, def_id: DefId) -> Option<Symbol> {\n+        let def_key = match def_id.as_local() {\n+            Some(def_id) => self.definitions.def_key(def_id),\n+            None => self.cstore().def_key(def_id),\n+        };\n+        def_key.get_opt_name()\n+    }\n+\n     /// Checks if an expression refers to a function marked with\n     /// `#[rustc_legacy_const_generics]` and returns the argument index list\n     /// from the attribute."}, {"sha": "a32cabab4c407281a0190e9dba473a863086b8bf", "filename": "compiler/rustc_span/src/source_map.rs", "status": "modified", "additions": 0, "deletions": 87, "changes": 87, "blob_url": "https://github.com/rust-lang/rust/blob/4d1c273b32acb8302013236b57b78cba1b3228c3/compiler%2Frustc_span%2Fsrc%2Fsource_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4d1c273b32acb8302013236b57b78cba1b3228c3/compiler%2Frustc_span%2Fsrc%2Fsource_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_span%2Fsrc%2Fsource_map.rs?ref=4d1c273b32acb8302013236b57b78cba1b3228c3", "patch": "@@ -982,93 +982,6 @@ impl SourceMap {\n         self.files().iter().fold(0, |a, f| a + f.count_lines())\n     }\n \n-    pub fn generate_fn_name_span(&self, span: Span) -> Option<Span> {\n-        let prev_span = self.span_extend_to_prev_str(span, \"fn\", true, true)?;\n-        if let Ok(snippet) = self.span_to_snippet(prev_span) {\n-            debug!(\n-                \"generate_fn_name_span: span={:?}, prev_span={:?}, snippet={:?}\",\n-                span, prev_span, snippet\n-            );\n-\n-            if snippet.is_empty() {\n-                return None;\n-            };\n-\n-            let len = snippet\n-                .find(|c: char| !c.is_alphanumeric() && c != '_')\n-                .expect(\"no label after fn\");\n-            Some(prev_span.with_hi(BytePos(prev_span.lo().0 + len as u32)))\n-        } else {\n-            None\n-        }\n-    }\n-\n-    /// Takes the span of a type parameter in a function signature and try to generate a span for\n-    /// the function name (with generics) and a new snippet for this span with the pointed type\n-    /// parameter as a new local type parameter.\n-    ///\n-    /// For instance:\n-    /// ```rust,ignore (pseudo-Rust)\n-    /// // Given span\n-    /// fn my_function(param: T)\n-    /// //                    ^ Original span\n-    ///\n-    /// // Result\n-    /// fn my_function(param: T)\n-    /// // ^^^^^^^^^^^ Generated span with snippet `my_function<T>`\n-    /// ```\n-    ///\n-    /// Attention: The method used is very fragile since it essentially duplicates the work of the\n-    /// parser. If you need to use this function or something similar, please consider updating the\n-    /// `SourceMap` functions and this function to something more robust.\n-    pub fn generate_local_type_param_snippet(&self, span: Span) -> Option<(Span, String)> {\n-        // Try to extend the span to the previous \"fn\" keyword to retrieve the function\n-        // signature.\n-        if let Some(sugg_span) = self.span_extend_to_prev_str(span, \"fn\", false, true) {\n-            if let Ok(snippet) = self.span_to_snippet(sugg_span) {\n-                // Consume the function name.\n-                let mut offset = snippet\n-                    .find(|c: char| !c.is_alphanumeric() && c != '_')\n-                    .expect(\"no label after fn\");\n-\n-                // Consume the generics part of the function signature.\n-                let mut bracket_counter = 0;\n-                let mut last_char = None;\n-                for c in snippet[offset..].chars() {\n-                    match c {\n-                        '<' => bracket_counter += 1,\n-                        '>' => bracket_counter -= 1,\n-                        '(' => {\n-                            if bracket_counter == 0 {\n-                                break;\n-                            }\n-                        }\n-                        _ => {}\n-                    }\n-                    offset += c.len_utf8();\n-                    last_char = Some(c);\n-                }\n-\n-                // Adjust the suggestion span to encompass the function name with its generics.\n-                let sugg_span = sugg_span.with_hi(BytePos(sugg_span.lo().0 + offset as u32));\n-\n-                // Prepare the new suggested snippet to append the type parameter that triggered\n-                // the error in the generics of the function signature.\n-                let mut new_snippet = if last_char == Some('>') {\n-                    format!(\"{}, \", &snippet[..(offset - '>'.len_utf8())])\n-                } else {\n-                    format!(\"{}<\", &snippet[..offset])\n-                };\n-                new_snippet\n-                    .push_str(&self.span_to_snippet(span).unwrap_or_else(|_| \"T\".to_string()));\n-                new_snippet.push('>');\n-\n-                return Some((sugg_span, new_snippet));\n-            }\n-        }\n-\n-        None\n-    }\n     pub fn ensure_source_file_source_present(&self, source_file: Lrc<SourceFile>) -> bool {\n         source_file.add_external_src(|| {\n             match source_file.name {"}, {"sha": "c8978845ffb0d35699e65e56c7aa2164a9aa7308", "filename": "compiler/rustc_span/src/symbol.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/4d1c273b32acb8302013236b57b78cba1b3228c3/compiler%2Frustc_span%2Fsrc%2Fsymbol.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4d1c273b32acb8302013236b57b78cba1b3228c3/compiler%2Frustc_span%2Fsrc%2Fsymbol.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_span%2Fsrc%2Fsymbol.rs?ref=4d1c273b32acb8302013236b57b78cba1b3228c3", "patch": "@@ -280,6 +280,7 @@ symbols! {\n         StructuralPartialEq,\n         SubdiagnosticMessage,\n         Sync,\n+        T,\n         Target,\n         ToOwned,\n         ToString,"}, {"sha": "df171c2531a7a901c68615582ca45b2275cf40f5", "filename": "compiler/rustc_typeck/src/check/compare_method.rs", "status": "modified", "additions": 7, "deletions": 9, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/4d1c273b32acb8302013236b57b78cba1b3228c3/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcompare_method.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4d1c273b32acb8302013236b57b78cba1b3228c3/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcompare_method.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcompare_method.rs?ref=4d1c273b32acb8302013236b57b78cba1b3228c3", "patch": "@@ -858,8 +858,7 @@ fn compare_synthetic_generics<'tcx>(\n     {\n         if impl_synthetic != trait_synthetic {\n             let impl_def_id = impl_def_id.expect_local();\n-            let impl_hir_id = tcx.hir().local_def_id_to_hir_id(impl_def_id);\n-            let impl_span = tcx.hir().span(impl_hir_id);\n+            let impl_span = tcx.def_span(impl_def_id);\n             let trait_span = tcx.def_span(trait_def_id);\n             let mut err = struct_span_err!(\n                 tcx.sess,\n@@ -878,17 +877,16 @@ fn compare_synthetic_generics<'tcx>(\n                         // try taking the name from the trait impl\n                         // FIXME: this is obviously suboptimal since the name can already be used\n                         // as another generic argument\n-                        let new_name = tcx.sess.source_map().span_to_snippet(trait_span).ok()?;\n+                        let new_name = tcx.opt_item_name(trait_def_id)?;\n                         let trait_m = trait_m.def_id.as_local()?;\n-                        let trait_m = tcx.hir().trait_item(hir::TraitItemId { def_id: trait_m });\n+                        let trait_m = tcx.hir().expect_trait_item(trait_m);\n \n                         let impl_m = impl_m.def_id.as_local()?;\n-                        let impl_m = tcx.hir().impl_item(hir::ImplItemId { def_id: impl_m });\n+                        let impl_m = tcx.hir().expect_impl_item(impl_m);\n \n                         // in case there are no generics, take the spot between the function name\n                         // and the opening paren of the argument list\n-                        let new_generics_span =\n-                            tcx.sess.source_map().generate_fn_name_span(impl_span)?.shrink_to_hi();\n+                        let new_generics_span = tcx.def_ident_span(impl_def_id)?.shrink_to_hi();\n                         // in case there are generics, just replace them\n                         let generics_span =\n                             impl_m.generics.span.substitute_dummy(new_generics_span);\n@@ -900,7 +898,7 @@ fn compare_synthetic_generics<'tcx>(\n                             \"try changing the `impl Trait` argument to a generic parameter\",\n                             vec![\n                                 // replace `impl Trait` with `T`\n-                                (impl_span, new_name),\n+                                (impl_span, new_name.to_string()),\n                                 // replace impl method generics with trait method generics\n                                 // This isn't quite right, as users might have changed the names\n                                 // of the generics, but it works for the common case\n@@ -917,7 +915,7 @@ fn compare_synthetic_generics<'tcx>(\n                     err.span_label(impl_span, \"expected `impl Trait`, found generic parameter\");\n                     (|| {\n                         let impl_m = impl_m.def_id.as_local()?;\n-                        let impl_m = tcx.hir().impl_item(hir::ImplItemId { def_id: impl_m });\n+                        let impl_m = tcx.hir().expect_impl_item(impl_m);\n                         let input_tys = match impl_m.kind {\n                             hir::ImplItemKind::Fn(ref sig, _) => sig.decl.inputs,\n                             _ => unreachable!(),"}, {"sha": "e3bf38b702e755b767cbb35fcd37cfc3b7828760", "filename": "src/test/ui/const-generics/early/const-param-from-outer-fn.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4d1c273b32acb8302013236b57b78cba1b3228c3/src%2Ftest%2Fui%2Fconst-generics%2Fearly%2Fconst-param-from-outer-fn.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/4d1c273b32acb8302013236b57b78cba1b3228c3/src%2Ftest%2Fui%2Fconst-generics%2Fearly%2Fconst-param-from-outer-fn.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fearly%2Fconst-param-from-outer-fn.stderr?ref=4d1c273b32acb8302013236b57b78cba1b3228c3", "patch": "@@ -4,7 +4,7 @@ error[E0401]: can't use generic parameters from outer function\n LL | fn foo<const X: u32>() {\n    |              - const parameter from outer function\n LL |     fn bar() -> u32 {\n-   |        --- try adding a local generic parameter in this method instead\n+   |           - help: try using a local generic parameter instead: `<X>`\n LL |         X\n    |         ^ use of generic parameter from outer function\n "}, {"sha": "b0e2ef5b6f7e3d65c101e62994552805c9775500", "filename": "src/test/ui/error-codes/E0401.stderr", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/4d1c273b32acb8302013236b57b78cba1b3228c3/src%2Ftest%2Fui%2Ferror-codes%2FE0401.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/4d1c273b32acb8302013236b57b78cba1b3228c3/src%2Ftest%2Fui%2Ferror-codes%2FE0401.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ferror-codes%2FE0401.stderr?ref=4d1c273b32acb8302013236b57b78cba1b3228c3", "patch": "@@ -4,9 +4,9 @@ error[E0401]: can't use generic parameters from outer function\n LL | fn foo<T>(x: T) {\n    |        - type parameter from outer function\n LL |     fn bfnr<U, V: Baz<U>, W: Fn()>(y: T) {\n-   |        ---------------------------    ^ use of generic parameter from outer function\n-   |        |\n-   |        help: try using a local generic parameter instead: `bfnr<U, V: Baz<U>, W: Fn(), T>`\n+   |             -                         ^ use of generic parameter from outer function\n+   |             |\n+   |             help: try using a local generic parameter instead: `T,`\n \n error[E0401]: can't use generic parameters from outer function\n   --> $DIR/E0401.rs:9:16\n@@ -15,7 +15,7 @@ LL | fn foo<T>(x: T) {\n    |        - type parameter from outer function\n ...\n LL |     fn baz<U,\n-   |        --- try adding a local generic parameter in this method instead\n+   |            - help: try using a local generic parameter instead: `T,`\n ...\n LL |            (y: T) {\n    |                ^ use of generic parameter from outer function"}, {"sha": "c7b5c33618d5f7b3237ebd49c23cae34b53e2d81", "filename": "src/test/ui/generics/issue-98432.stderr", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/4d1c273b32acb8302013236b57b78cba1b3228c3/src%2Ftest%2Fui%2Fgenerics%2Fissue-98432.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/4d1c273b32acb8302013236b57b78cba1b3228c3/src%2Ftest%2Fui%2Fgenerics%2Fissue-98432.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fgenerics%2Fissue-98432.stderr?ref=4d1c273b32acb8302013236b57b78cba1b3228c3", "patch": "@@ -5,9 +5,9 @@ LL | impl<T> Struct<T> {\n    |      - type parameter from outer function\n LL |     const CONST: fn() = || {\n LL |         struct _Obligation where T:;\n-   |                                  ^ use of generic parameter from outer function\n-   |\n-   = help: try using a local generic parameter instead\n+   |                           -      ^ use of generic parameter from outer function\n+   |                           |\n+   |                           help: try using a local generic parameter instead: `<T>`\n \n error: aborting due to previous error\n "}, {"sha": "aa0b5ce64b4213b275969d528b73d78eaa5e6813", "filename": "src/test/ui/issues/issue-3214.stderr", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/4d1c273b32acb8302013236b57b78cba1b3228c3/src%2Ftest%2Fui%2Fissues%2Fissue-3214.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/4d1c273b32acb8302013236b57b78cba1b3228c3/src%2Ftest%2Fui%2Fissues%2Fissue-3214.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-3214.stderr?ref=4d1c273b32acb8302013236b57b78cba1b3228c3", "patch": "@@ -2,10 +2,9 @@ error[E0401]: can't use generic parameters from outer function\n   --> $DIR/issue-3214.rs:3:12\n    |\n LL | fn foo<T>() {\n-   |    --- - type parameter from outer function\n-   |    |\n-   |    try adding a local generic parameter in this method instead\n+   |        - type parameter from outer function\n LL |     struct Foo {\n+   |               - help: try using a local generic parameter instead: `<T>`\n LL |         x: T,\n    |            ^ use of generic parameter from outer function\n "}, {"sha": "3a79215d3ae9c4c62ed13177f5bc49c437621716", "filename": "src/test/ui/issues/issue-5997-enum.stderr", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/4d1c273b32acb8302013236b57b78cba1b3228c3/src%2Ftest%2Fui%2Fissues%2Fissue-5997-enum.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/4d1c273b32acb8302013236b57b78cba1b3228c3/src%2Ftest%2Fui%2Fissues%2Fissue-5997-enum.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-5997-enum.stderr?ref=4d1c273b32acb8302013236b57b78cba1b3228c3", "patch": "@@ -2,11 +2,11 @@ error[E0401]: can't use generic parameters from outer function\n   --> $DIR/issue-5997-enum.rs:2:16\n    |\n LL | fn f<Z>() -> bool {\n-   |    - - type parameter from outer function\n-   |    |\n-   |    try adding a local generic parameter in this method instead\n+   |      - type parameter from outer function\n LL |     enum E { V(Z) }\n-   |                ^ use of generic parameter from outer function\n+   |           -    ^ use of generic parameter from outer function\n+   |           |\n+   |           help: try using a local generic parameter instead: `<Z>`\n \n error: aborting due to previous error\n "}, {"sha": "d2e97f767719fc56884861bd2aa11a529913e193", "filename": "src/test/ui/issues/issue-5997-struct.stderr", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/4d1c273b32acb8302013236b57b78cba1b3228c3/src%2Ftest%2Fui%2Fissues%2Fissue-5997-struct.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/4d1c273b32acb8302013236b57b78cba1b3228c3/src%2Ftest%2Fui%2Fissues%2Fissue-5997-struct.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-5997-struct.stderr?ref=4d1c273b32acb8302013236b57b78cba1b3228c3", "patch": "@@ -2,11 +2,11 @@ error[E0401]: can't use generic parameters from outer function\n   --> $DIR/issue-5997-struct.rs:2:14\n    |\n LL | fn f<T>() -> bool {\n-   |    - - type parameter from outer function\n-   |    |\n-   |    try adding a local generic parameter in this method instead\n+   |      - type parameter from outer function\n LL |     struct S(T);\n-   |              ^ use of generic parameter from outer function\n+   |             -^ use of generic parameter from outer function\n+   |             |\n+   |             help: try using a local generic parameter instead: `<T>`\n \n error: aborting due to previous error\n "}, {"sha": "8f4746f5ec3bdb2e0e4aae9ff386866a6ae44c64", "filename": "src/test/ui/nested-ty-params.stderr", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/4d1c273b32acb8302013236b57b78cba1b3228c3/src%2Ftest%2Fui%2Fnested-ty-params.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/4d1c273b32acb8302013236b57b78cba1b3228c3/src%2Ftest%2Fui%2Fnested-ty-params.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnested-ty-params.stderr?ref=4d1c273b32acb8302013236b57b78cba1b3228c3", "patch": "@@ -4,19 +4,19 @@ error[E0401]: can't use generic parameters from outer function\n LL | fn hd<U>(v: Vec<U> ) -> U {\n    |       - type parameter from outer function\n LL |     fn hd1(w: [U]) -> U { return w[0]; }\n-   |        ---     ^ use of generic parameter from outer function\n-   |        |\n-   |        help: try using a local generic parameter instead: `hd1<U>`\n+   |           -    ^ use of generic parameter from outer function\n+   |           |\n+   |           help: try using a local generic parameter instead: `<U>`\n \n error[E0401]: can't use generic parameters from outer function\n   --> $DIR/nested-ty-params.rs:3:23\n    |\n LL | fn hd<U>(v: Vec<U> ) -> U {\n    |       - type parameter from outer function\n LL |     fn hd1(w: [U]) -> U { return w[0]; }\n-   |        ---            ^ use of generic parameter from outer function\n-   |        |\n-   |        help: try using a local generic parameter instead: `hd1<U>`\n+   |           -           ^ use of generic parameter from outer function\n+   |           |\n+   |           help: try using a local generic parameter instead: `<U>`\n \n error: aborting due to 2 previous errors\n "}, {"sha": "b6282c2d0703b8fae7a0517bbddfc505cdccee24", "filename": "src/test/ui/resolve/bad-type-env-capture.stderr", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/4d1c273b32acb8302013236b57b78cba1b3228c3/src%2Ftest%2Fui%2Fresolve%2Fbad-type-env-capture.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/4d1c273b32acb8302013236b57b78cba1b3228c3/src%2Ftest%2Fui%2Fresolve%2Fbad-type-env-capture.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fresolve%2Fbad-type-env-capture.stderr?ref=4d1c273b32acb8302013236b57b78cba1b3228c3", "patch": "@@ -4,9 +4,9 @@ error[E0401]: can't use generic parameters from outer function\n LL | fn foo<T>() {\n    |        - type parameter from outer function\n LL |     fn bar(b: T) { }\n-   |        ---    ^ use of generic parameter from outer function\n-   |        |\n-   |        help: try using a local generic parameter instead: `bar<T>`\n+   |           -   ^ use of generic parameter from outer function\n+   |           |\n+   |           help: try using a local generic parameter instead: `<T>`\n \n error: aborting due to previous error\n "}, {"sha": "5176efc3a6be71cdec18386b30c74ec79016fdb2", "filename": "src/test/ui/resolve/issue-3021-c.stderr", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/4d1c273b32acb8302013236b57b78cba1b3228c3/src%2Ftest%2Fui%2Fresolve%2Fissue-3021-c.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/4d1c273b32acb8302013236b57b78cba1b3228c3/src%2Ftest%2Fui%2Fresolve%2Fissue-3021-c.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fresolve%2Fissue-3021-c.stderr?ref=4d1c273b32acb8302013236b57b78cba1b3228c3", "patch": "@@ -3,22 +3,22 @@ error[E0401]: can't use generic parameters from outer function\n    |\n LL | fn siphash<T>() {\n    |            - type parameter from outer function\n-...\n+LL |\n+LL |     trait U {\n+   |            - help: try using a local generic parameter instead: `<T>`\n LL |         fn g(&self, x: T) -> T;\n-   |            -           ^ use of generic parameter from outer function\n-   |            |\n-   |            help: try using a local generic parameter instead: `g<T>`\n+   |                        ^ use of generic parameter from outer function\n \n error[E0401]: can't use generic parameters from outer function\n   --> $DIR/issue-3021-c.rs:4:30\n    |\n LL | fn siphash<T>() {\n    |            - type parameter from outer function\n-...\n+LL |\n+LL |     trait U {\n+   |            - help: try using a local generic parameter instead: `<T>`\n LL |         fn g(&self, x: T) -> T;\n-   |            -                 ^ use of generic parameter from outer function\n-   |            |\n-   |            help: try using a local generic parameter instead: `g<T>`\n+   |                              ^ use of generic parameter from outer function\n \n error: aborting due to 2 previous errors\n "}, {"sha": "0a6d1cc3bcd45fe00be2b9c68b62329bb6678eb1", "filename": "src/test/ui/resolve/resolve-type-param-in-item-in-trait.stderr", "status": "modified", "additions": 10, "deletions": 8, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/4d1c273b32acb8302013236b57b78cba1b3228c3/src%2Ftest%2Fui%2Fresolve%2Fresolve-type-param-in-item-in-trait.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/4d1c273b32acb8302013236b57b78cba1b3228c3/src%2Ftest%2Fui%2Fresolve%2Fresolve-type-param-in-item-in-trait.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fresolve%2Fresolve-type-param-in-item-in-trait.stderr?ref=4d1c273b32acb8302013236b57b78cba1b3228c3", "patch": "@@ -4,8 +4,8 @@ error[E0401]: can't use generic parameters from outer function\n LL | trait TraitA<A> {\n    |              - type parameter from outer function\n LL |     fn outer(&self) {\n-   |        ----- try adding a local generic parameter in this method instead\n LL |         enum Foo<B> {\n+   |                  - help: try using a local generic parameter instead: `A,`\n LL |             Variance(A)\n    |                      ^ use of generic parameter from outer function\n \n@@ -15,19 +15,21 @@ error[E0401]: can't use generic parameters from outer function\n LL | trait TraitB<A> {\n    |              - type parameter from outer function\n LL |     fn outer(&self) {\n-   |        ----- try adding a local generic parameter in this method instead\n LL |         struct Foo<B>(A);\n-   |                       ^ use of generic parameter from outer function\n+   |                    -  ^ use of generic parameter from outer function\n+   |                    |\n+   |                    help: try using a local generic parameter instead: `A,`\n \n error[E0401]: can't use generic parameters from outer function\n   --> $DIR/resolve-type-param-in-item-in-trait.rs:23:28\n    |\n LL | trait TraitC<A> {\n    |              - type parameter from outer function\n LL |     fn outer(&self) {\n-   |        ----- try adding a local generic parameter in this method instead\n LL |         struct Foo<B> { a: A }\n-   |                            ^ use of generic parameter from outer function\n+   |                    -       ^ use of generic parameter from outer function\n+   |                    |\n+   |                    help: try using a local generic parameter instead: `A,`\n \n error[E0401]: can't use generic parameters from outer function\n   --> $DIR/resolve-type-param-in-item-in-trait.rs:30:22\n@@ -36,9 +38,9 @@ LL | trait TraitD<A> {\n    |              - type parameter from outer function\n LL |     fn outer(&self) {\n LL |         fn foo<B>(a: A) { }\n-   |            ------    ^ use of generic parameter from outer function\n-   |            |\n-   |            help: try using a local generic parameter instead: `foo<B, A>`\n+   |                -     ^ use of generic parameter from outer function\n+   |                |\n+   |                help: try using a local generic parameter instead: `A,`\n \n error: aborting due to 4 previous errors\n "}, {"sha": "7f18b4510f4b2b3651e66bd34d5834193990d9d8", "filename": "src/test/ui/type/type-arg-out-of-scope.stderr", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/4d1c273b32acb8302013236b57b78cba1b3228c3/src%2Ftest%2Fui%2Ftype%2Ftype-arg-out-of-scope.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/4d1c273b32acb8302013236b57b78cba1b3228c3/src%2Ftest%2Fui%2Ftype%2Ftype-arg-out-of-scope.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype%2Ftype-arg-out-of-scope.stderr?ref=4d1c273b32acb8302013236b57b78cba1b3228c3", "patch": "@@ -4,19 +4,19 @@ error[E0401]: can't use generic parameters from outer function\n LL | fn foo<T>(x: T) {\n    |        - type parameter from outer function\n LL |     fn bar(f: Box<dyn FnMut(T) -> T>) { }\n-   |        ---                  ^ use of generic parameter from outer function\n-   |        |\n-   |        help: try using a local generic parameter instead: `bar<T>`\n+   |           -                 ^ use of generic parameter from outer function\n+   |           |\n+   |           help: try using a local generic parameter instead: `<T>`\n \n error[E0401]: can't use generic parameters from outer function\n   --> $DIR/type-arg-out-of-scope.rs:3:35\n    |\n LL | fn foo<T>(x: T) {\n    |        - type parameter from outer function\n LL |     fn bar(f: Box<dyn FnMut(T) -> T>) { }\n-   |        ---                        ^ use of generic parameter from outer function\n-   |        |\n-   |        help: try using a local generic parameter instead: `bar<T>`\n+   |           -                       ^ use of generic parameter from outer function\n+   |           |\n+   |           help: try using a local generic parameter instead: `<T>`\n \n error: aborting due to 2 previous errors\n "}]}