{"sha": "d99805982b57eb7827da2b66a21121b4c76b41e9", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQ5OTgwNTk4MmI1N2ViNzgyN2RhMmI2NmEyMTEyMWI0Yzc2YjQxZTk=", "commit": {"author": {"name": "Oli Scherer", "email": "github35764891676564198441@oli-obk.de", "date": "2021-07-26T16:57:18Z"}, "committer": {"name": "Oli Scherer", "email": "github35764891676564198441@oli-obk.de", "date": "2021-08-06T10:12:31Z"}, "message": "Move opaque type cache into `InferCtxt`", "tree": {"sha": "5678651e09963cc635804150a5c20fe754cc52d7", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5678651e09963cc635804150a5c20fe754cc52d7"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d99805982b57eb7827da2b66a21121b4c76b41e9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d99805982b57eb7827da2b66a21121b4c76b41e9", "html_url": "https://github.com/rust-lang/rust/commit/d99805982b57eb7827da2b66a21121b4c76b41e9", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d99805982b57eb7827da2b66a21121b4c76b41e9/comments", "author": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "committer": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1f94abcda6884893d4723304102089198caa0839", "url": "https://api.github.com/repos/rust-lang/rust/commits/1f94abcda6884893d4723304102089198caa0839", "html_url": "https://github.com/rust-lang/rust/commit/1f94abcda6884893d4723304102089198caa0839"}], "stats": {"total": 209, "additions": 102, "deletions": 107}, "files": [{"sha": "62bfe03427e1c0d46ee9ebca3d47c36ab44181c6", "filename": "compiler/rustc_infer/src/infer/mod.rs", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/d99805982b57eb7827da2b66a21121b4c76b41e9/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d99805982b57eb7827da2b66a21121b4c76b41e9/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fmod.rs?ref=d99805982b57eb7827da2b66a21121b4c76b41e9", "patch": "@@ -4,6 +4,7 @@ pub use self::RegionVariableOrigin::*;\n pub use self::SubregionOrigin::*;\n pub use self::ValuePairs::*;\n \n+use self::opaque_types::OpaqueTypeDecl;\n pub(crate) use self::undo_log::{InferCtxtUndoLogs, Snapshot, UndoLog};\n \n use crate::traits::{self, ObligationCause, PredicateObligations, TraitEngine};\n@@ -12,6 +13,7 @@ use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n use rustc_data_structures::sync::Lrc;\n use rustc_data_structures::undo_log::Rollback;\n use rustc_data_structures::unify as ut;\n+use rustc_data_structures::vec_map::VecMap;\n use rustc_errors::DiagnosticBuilder;\n use rustc_hir as hir;\n use rustc_hir::def_id::{DefId, LocalDefId};\n@@ -25,6 +27,7 @@ use rustc_middle::ty::fold::{TypeFoldable, TypeFolder};\n use rustc_middle::ty::relate::RelateResult;\n use rustc_middle::ty::subst::{GenericArg, GenericArgKind, InternalSubsts, SubstsRef};\n pub use rustc_middle::ty::IntVarValue;\n+use rustc_middle::ty::OpaqueTypeKey;\n use rustc_middle::ty::{self, GenericParamDefKind, InferConst, Ty, TyCtxt};\n use rustc_middle::ty::{ConstVid, FloatVid, IntVid, TyVid};\n use rustc_session::config::BorrowckMode;\n@@ -59,6 +62,7 @@ pub mod lattice;\n mod lexical_region_resolve;\n mod lub;\n pub mod nll_relate;\n+pub mod opaque_types;\n pub mod outlives;\n pub mod region_constraints;\n pub mod resolve;\n@@ -191,6 +195,19 @@ pub struct InferCtxtInner<'tcx> {\n     region_obligations: Vec<(hir::HirId, RegionObligation<'tcx>)>,\n \n     undo_log: InferCtxtUndoLogs<'tcx>,\n+\n+    // Opaque types found in explicit return types and their\n+    // associated fresh inference variable. Writeback resolves these\n+    // variables to get the concrete type, which can be used to\n+    // 'de-opaque' OpaqueTypeDecl, after typeck is done with all functions.\n+    pub opaque_types: VecMap<OpaqueTypeKey<'tcx>, OpaqueTypeDecl<'tcx>>,\n+\n+    /// A map from inference variables created from opaque\n+    /// type instantiations (`ty::Infer`) to the actual opaque\n+    /// type (`ty::Opaque`). Used during fallback to map unconstrained\n+    /// opaque type inference variables to their corresponding\n+    /// opaque type.\n+    pub opaque_types_vars: FxHashMap<Ty<'tcx>, Ty<'tcx>>,\n }\n \n impl<'tcx> InferCtxtInner<'tcx> {\n@@ -204,6 +221,8 @@ impl<'tcx> InferCtxtInner<'tcx> {\n             float_unification_storage: ut::UnificationTableStorage::new(),\n             region_constraint_storage: Some(RegionConstraintStorage::new()),\n             region_obligations: vec![],\n+            opaque_types: Default::default(),\n+            opaque_types_vars: Default::default(),\n         }\n     }\n "}, {"sha": "4a1cbf597db3544f3c1c8dad5e0f881100e858a9", "filename": "compiler/rustc_infer/src/infer/opaque_types.rs", "status": "added", "additions": 70, "deletions": 0, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/d99805982b57eb7827da2b66a21121b4c76b41e9/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fopaque_types.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d99805982b57eb7827da2b66a21121b4c76b41e9/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fopaque_types.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fopaque_types.rs?ref=d99805982b57eb7827da2b66a21121b4c76b41e9", "patch": "@@ -0,0 +1,70 @@\n+use rustc_data_structures::vec_map::VecMap;\n+use rustc_hir as hir;\n+use rustc_middle::ty::{OpaqueTypeKey, Ty};\n+use rustc_span::Span;\n+\n+pub type OpaqueTypeMap<'tcx> = VecMap<OpaqueTypeKey<'tcx>, OpaqueTypeDecl<'tcx>>;\n+\n+/// Information about the opaque types whose values we\n+/// are inferring in this function (these are the `impl Trait` that\n+/// appear in the return type).\n+#[derive(Copy, Clone, Debug)]\n+pub struct OpaqueTypeDecl<'tcx> {\n+    /// The opaque type (`ty::Opaque`) for this declaration.\n+    pub opaque_type: Ty<'tcx>,\n+\n+    /// The span of this particular definition of the opaque type. So\n+    /// for example:\n+    ///\n+    /// ```ignore (incomplete snippet)\n+    /// type Foo = impl Baz;\n+    /// fn bar() -> Foo {\n+    /// //          ^^^ This is the span we are looking for!\n+    /// }\n+    /// ```\n+    ///\n+    /// In cases where the fn returns `(impl Trait, impl Trait)` or\n+    /// other such combinations, the result is currently\n+    /// over-approximated, but better than nothing.\n+    pub definition_span: Span,\n+\n+    /// The type variable that represents the value of the opaque type\n+    /// that we require. In other words, after we compile this function,\n+    /// we will be created a constraint like:\n+    ///\n+    ///     Foo<'a, T> = ?C\n+    ///\n+    /// where `?C` is the value of this type variable. =) It may\n+    /// naturally refer to the type and lifetime parameters in scope\n+    /// in this function, though ultimately it should only reference\n+    /// those that are arguments to `Foo` in the constraint above. (In\n+    /// other words, `?C` should not include `'b`, even though it's a\n+    /// lifetime parameter on `foo`.)\n+    pub concrete_ty: Ty<'tcx>,\n+\n+    /// Returns `true` if the `impl Trait` bounds include region bounds.\n+    /// For example, this would be true for:\n+    ///\n+    ///     fn foo<'a, 'b, 'c>() -> impl Trait<'c> + 'a + 'b\n+    ///\n+    /// but false for:\n+    ///\n+    ///     fn foo<'c>() -> impl Trait<'c>\n+    ///\n+    /// unless `Trait` was declared like:\n+    ///\n+    ///     trait Trait<'c>: 'c\n+    ///\n+    /// in which case it would be true.\n+    ///\n+    /// This is used during regionck to decide whether we need to\n+    /// impose any additional constraints to ensure that region\n+    /// variables in `concrete_ty` wind up being constrained to\n+    /// something from `substs` (or, at minimum, things that outlive\n+    /// the fn body). (Ultimately, writeback is responsible for this\n+    /// check.)\n+    pub has_required_region_bounds: bool,\n+\n+    /// The origin of the opaque type.\n+    pub origin: hir::OpaqueTyOrigin,\n+}"}, {"sha": "5ff1cf777f95c34feff3d68af91c4370901cb9c4", "filename": "compiler/rustc_trait_selection/src/opaque_types.rs", "status": "modified", "additions": 5, "deletions": 78, "changes": 83, "blob_url": "https://github.com/rust-lang/rust/blob/d99805982b57eb7827da2b66a21121b4c76b41e9/compiler%2Frustc_trait_selection%2Fsrc%2Fopaque_types.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d99805982b57eb7827da2b66a21121b4c76b41e9/compiler%2Frustc_trait_selection%2Fsrc%2Fopaque_types.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Fopaque_types.rs?ref=d99805982b57eb7827da2b66a21121b4c76b41e9", "patch": "@@ -2,11 +2,11 @@ use crate::infer::InferCtxtExt as _;\n use crate::traits::{self, ObligationCause, PredicateObligation};\n use rustc_data_structures::fx::FxHashMap;\n use rustc_data_structures::sync::Lrc;\n-use rustc_data_structures::vec_map::VecMap;\n use rustc_hir as hir;\n use rustc_hir::def_id::{DefId, LocalDefId};\n use rustc_infer::infer::error_reporting::unexpected_hidden_region_diagnostic;\n use rustc_infer::infer::free_regions::FreeRegionRelations;\n+use rustc_infer::infer::opaque_types::{OpaqueTypeDecl, OpaqueTypeMap};\n use rustc_infer::infer::type_variable::{TypeVariableOrigin, TypeVariableOriginKind};\n use rustc_infer::infer::{self, InferCtxt, InferOk};\n use rustc_middle::ty::fold::{BottomUpFolder, TypeFoldable, TypeFolder, TypeVisitor};\n@@ -16,72 +16,6 @@ use rustc_span::Span;\n \n use std::ops::ControlFlow;\n \n-pub type OpaqueTypeMap<'tcx> = VecMap<OpaqueTypeKey<'tcx>, OpaqueTypeDecl<'tcx>>;\n-\n-/// Information about the opaque types whose values we\n-/// are inferring in this function (these are the `impl Trait` that\n-/// appear in the return type).\n-#[derive(Copy, Clone, Debug)]\n-pub struct OpaqueTypeDecl<'tcx> {\n-    /// The opaque type (`ty::Opaque`) for this declaration.\n-    pub opaque_type: Ty<'tcx>,\n-\n-    /// The span of this particular definition of the opaque type. So\n-    /// for example:\n-    ///\n-    /// ```ignore (incomplete snippet)\n-    /// type Foo = impl Baz;\n-    /// fn bar() -> Foo {\n-    /// //          ^^^ This is the span we are looking for!\n-    /// }\n-    /// ```\n-    ///\n-    /// In cases where the fn returns `(impl Trait, impl Trait)` or\n-    /// other such combinations, the result is currently\n-    /// over-approximated, but better than nothing.\n-    pub definition_span: Span,\n-\n-    /// The type variable that represents the value of the opaque type\n-    /// that we require. In other words, after we compile this function,\n-    /// we will be created a constraint like:\n-    ///\n-    ///     Foo<'a, T> = ?C\n-    ///\n-    /// where `?C` is the value of this type variable. =) It may\n-    /// naturally refer to the type and lifetime parameters in scope\n-    /// in this function, though ultimately it should only reference\n-    /// those that are arguments to `Foo` in the constraint above. (In\n-    /// other words, `?C` should not include `'b`, even though it's a\n-    /// lifetime parameter on `foo`.)\n-    pub concrete_ty: Ty<'tcx>,\n-\n-    /// Returns `true` if the `impl Trait` bounds include region bounds.\n-    /// For example, this would be true for:\n-    ///\n-    ///     fn foo<'a, 'b, 'c>() -> impl Trait<'c> + 'a + 'b\n-    ///\n-    /// but false for:\n-    ///\n-    ///     fn foo<'c>() -> impl Trait<'c>\n-    ///\n-    /// unless `Trait` was declared like:\n-    ///\n-    ///     trait Trait<'c>: 'c\n-    ///\n-    /// in which case it would be true.\n-    ///\n-    /// This is used during regionck to decide whether we need to\n-    /// impose any additional constraints to ensure that region\n-    /// variables in `concrete_ty` wind up being constrained to\n-    /// something from `substs` (or, at minimum, things that outlive\n-    /// the fn body). (Ultimately, writeback is responsible for this\n-    /// check.)\n-    pub has_required_region_bounds: bool,\n-\n-    /// The origin of the opaque type.\n-    pub origin: hir::OpaqueTyOrigin,\n-}\n-\n /// Whether member constraints should be generated for all opaque types\n #[derive(Debug)]\n pub enum GenerateMemberConstraints {\n@@ -105,11 +39,7 @@ pub trait InferCtxtExt<'tcx> {\n         value_span: Span,\n     ) -> InferOk<'tcx, (T, OpaqueTypeMap<'tcx>)>;\n \n-    fn constrain_opaque_types<FRR: FreeRegionRelations<'tcx>>(\n-        &self,\n-        opaque_types: &OpaqueTypeMap<'tcx>,\n-        free_region_relations: &FRR,\n-    );\n+    fn constrain_opaque_types<FRR: FreeRegionRelations<'tcx>>(&self, free_region_relations: &FRR);\n \n     fn constrain_opaque_type<FRR: FreeRegionRelations<'tcx>>(\n         &self,\n@@ -350,12 +280,9 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n     /// - `opaque_types` -- the map produced by `instantiate_opaque_types`\n     /// - `free_region_relations` -- something that can be used to relate\n     ///   the free regions (`'a`) that appear in the impl trait.\n-    fn constrain_opaque_types<FRR: FreeRegionRelations<'tcx>>(\n-        &self,\n-        opaque_types: &OpaqueTypeMap<'tcx>,\n-        free_region_relations: &FRR,\n-    ) {\n-        for &(opaque_type_key, opaque_defn) in opaque_types {\n+    fn constrain_opaque_types<FRR: FreeRegionRelations<'tcx>>(&self, free_region_relations: &FRR) {\n+        let opaque_types = self.inner.borrow().opaque_types.clone();\n+        for (opaque_type_key, opaque_defn) in opaque_types {\n             self.constrain_opaque_type(\n                 opaque_type_key,\n                 &opaque_defn,"}, {"sha": "41642db3daab84d93e80580f8f1862f1cb532c5b", "filename": "compiler/rustc_typeck/src/check/fn_ctxt/_impl.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/d99805982b57eb7827da2b66a21121b4c76b41e9/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2F_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d99805982b57eb7827da2b66a21121b4c76b41e9/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2F_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2F_impl.rs?ref=d99805982b57eb7827da2b66a21121b4c76b41e9", "patch": "@@ -385,8 +385,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 value_span,\n             ));\n \n-        let mut opaque_types = self.opaque_types.borrow_mut();\n-        let mut opaque_types_vars = self.opaque_types_vars.borrow_mut();\n+        let mut infcx = self.infcx.inner.borrow_mut();\n \n         for (ty, decl) in opaque_type_map {\n             if let Some(feature) = feature {\n@@ -402,8 +401,8 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                     }\n                 }\n             }\n-            let _ = opaque_types.insert(ty, decl);\n-            let _ = opaque_types_vars.insert(decl.concrete_ty, decl.opaque_type);\n+            let _ = infcx.opaque_types.insert(ty, decl);\n+            let _ = infcx.opaque_types_vars.insert(decl.concrete_ty, decl.opaque_type);\n         }\n \n         value\n@@ -726,7 +725,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 // We treat this as a non-defining use by making the inference\n                 // variable fall back to the opaque type itself.\n                 if let FallbackMode::All = mode {\n-                    if let Some(opaque_ty) = self.opaque_types_vars.borrow().get(ty) {\n+                    if let Some(opaque_ty) = self.infcx.inner.borrow().opaque_types_vars.get(ty) {\n                         debug!(\n                             \"fallback_if_possible: falling back opaque type var {:?} to {:?}\",\n                             ty, opaque_ty"}, {"sha": "fb7beae70ba1ea4075a7f83cba657ea4fadc1eb6", "filename": "compiler/rustc_typeck/src/check/inherited.rs", "status": "modified", "additions": 1, "deletions": 19, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/d99805982b57eb7827da2b66a21121b4c76b41e9/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Finherited.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d99805982b57eb7827da2b66a21121b4c76b41e9/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Finherited.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Finherited.rs?ref=d99805982b57eb7827da2b66a21121b4c76b41e9", "patch": "@@ -1,18 +1,15 @@\n use super::callee::DeferredCallResolution;\n use super::MaybeInProgressTables;\n \n-use rustc_data_structures::fx::FxHashMap;\n-use rustc_data_structures::vec_map::VecMap;\n use rustc_hir as hir;\n use rustc_hir::def_id::{DefIdMap, LocalDefId};\n use rustc_hir::HirIdMap;\n use rustc_infer::infer;\n use rustc_infer::infer::{InferCtxt, InferOk, TyCtxtInferExt};\n use rustc_middle::ty::fold::TypeFoldable;\n-use rustc_middle::ty::{self, OpaqueTypeKey, Ty, TyCtxt};\n+use rustc_middle::ty::{self, Ty, TyCtxt};\n use rustc_span::{self, Span};\n use rustc_trait_selection::infer::InferCtxtExt as _;\n-use rustc_trait_selection::opaque_types::OpaqueTypeDecl;\n use rustc_trait_selection::traits::{self, ObligationCause, TraitEngine, TraitEngineExt};\n \n use std::cell::RefCell;\n@@ -55,19 +52,6 @@ pub struct Inherited<'a, 'tcx> {\n     pub(super) deferred_generator_interiors:\n         RefCell<Vec<(hir::BodyId, Ty<'tcx>, hir::GeneratorKind)>>,\n \n-    // Opaque types found in explicit return types and their\n-    // associated fresh inference variable. Writeback resolves these\n-    // variables to get the concrete type, which can be used to\n-    // 'de-opaque' OpaqueTypeDecl, after typeck is done with all functions.\n-    pub(super) opaque_types: RefCell<VecMap<OpaqueTypeKey<'tcx>, OpaqueTypeDecl<'tcx>>>,\n-\n-    /// A map from inference variables created from opaque\n-    /// type instantiations (`ty::Infer`) to the actual opaque\n-    /// type (`ty::Opaque`). Used during fallback to map unconstrained\n-    /// opaque type inference variables to their corresponding\n-    /// opaque type.\n-    pub(super) opaque_types_vars: RefCell<FxHashMap<Ty<'tcx>, Ty<'tcx>>>,\n-\n     pub(super) body_id: Option<hir::BodyId>,\n }\n \n@@ -124,8 +108,6 @@ impl Inherited<'a, 'tcx> {\n             deferred_call_resolutions: RefCell::new(Default::default()),\n             deferred_cast_checks: RefCell::new(Vec::new()),\n             deferred_generator_interiors: RefCell::new(Vec::new()),\n-            opaque_types: RefCell::new(Default::default()),\n-            opaque_types_vars: RefCell::new(Default::default()),\n             body_id,\n         }\n     }"}, {"sha": "ca6828cfdf68de599fee44ff104038bbb081a59c", "filename": "compiler/rustc_typeck/src/check/regionck.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/d99805982b57eb7827da2b66a21121b4c76b41e9/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fregionck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d99805982b57eb7827da2b66a21121b4c76b41e9/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fregionck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fregionck.rs?ref=d99805982b57eb7827da2b66a21121b4c76b41e9", "patch": "@@ -291,10 +291,7 @@ impl<'a, 'tcx> RegionCtxt<'a, 'tcx> {\n         self.visit_body(body);\n         self.visit_region_obligations(body_id.hir_id);\n \n-        self.constrain_opaque_types(\n-            &self.fcx.opaque_types.borrow(),\n-            self.outlives_environment.free_region_map(),\n-        );\n+        self.constrain_opaque_types(self.outlives_environment.free_region_map());\n     }\n \n     fn visit_region_obligations(&mut self, hir_id: hir::HirId) {"}, {"sha": "959ab69a679eb1d6075b02f1f42a2daf021679e1", "filename": "compiler/rustc_typeck/src/check/writeback.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/d99805982b57eb7827da2b66a21121b4c76b41e9/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fwriteback.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d99805982b57eb7827da2b66a21121b4c76b41e9/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fwriteback.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fwriteback.rs?ref=d99805982b57eb7827da2b66a21121b4c76b41e9", "patch": "@@ -498,7 +498,8 @@ impl<'cx, 'tcx> WritebackCx<'cx, 'tcx> {\n     }\n \n     fn visit_opaque_types(&mut self, span: Span) {\n-        for &(opaque_type_key, opaque_defn) in self.fcx.opaque_types.borrow().iter() {\n+        let opaque_types = self.fcx.infcx.inner.borrow().opaque_types.clone();\n+        for (opaque_type_key, opaque_defn) in opaque_types {\n             let hir_id =\n                 self.tcx().hir().local_def_id_to_hir_id(opaque_type_key.def_id.expect_local());\n             let instantiated_ty = self.resolve(opaque_defn.concrete_ty, &hir_id);"}]}