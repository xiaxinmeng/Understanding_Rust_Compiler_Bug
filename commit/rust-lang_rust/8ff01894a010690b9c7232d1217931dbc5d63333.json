{"sha": "8ff01894a010690b9c7232d1217931dbc5d63333", "node_id": "C_kwDOAAsO6NoAKDhmZjAxODk0YTAxMDY5MGI5YzcyMzJkMTIxNzkzMWRiYzVkNjMzMzM", "commit": {"author": {"name": "SparrowLii", "email": "liyuan179@huawei.com", "date": "2022-05-06T04:11:42Z"}, "committer": {"name": "SparrowLii", "email": "liyuan179@huawei.com", "date": "2022-05-06T04:11:42Z"}, "message": "turn `append_place_to_string` from recursion into iteration", "tree": {"sha": "ad0d79d3369832ef390431ce92df87111567250a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ad0d79d3369832ef390431ce92df87111567250a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8ff01894a010690b9c7232d1217931dbc5d63333", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8ff01894a010690b9c7232d1217931dbc5d63333", "html_url": "https://github.com/rust-lang/rust/commit/8ff01894a010690b9c7232d1217931dbc5d63333", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8ff01894a010690b9c7232d1217931dbc5d63333/comments", "author": {"login": "SparrowLii", "id": 68270294, "node_id": "MDQ6VXNlcjY4MjcwMjk0", "avatar_url": "https://avatars.githubusercontent.com/u/68270294?v=4", "gravatar_id": "", "url": "https://api.github.com/users/SparrowLii", "html_url": "https://github.com/SparrowLii", "followers_url": "https://api.github.com/users/SparrowLii/followers", "following_url": "https://api.github.com/users/SparrowLii/following{/other_user}", "gists_url": "https://api.github.com/users/SparrowLii/gists{/gist_id}", "starred_url": "https://api.github.com/users/SparrowLii/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/SparrowLii/subscriptions", "organizations_url": "https://api.github.com/users/SparrowLii/orgs", "repos_url": "https://api.github.com/users/SparrowLii/repos", "events_url": "https://api.github.com/users/SparrowLii/events{/privacy}", "received_events_url": "https://api.github.com/users/SparrowLii/received_events", "type": "User", "site_admin": false}, "committer": {"login": "SparrowLii", "id": 68270294, "node_id": "MDQ6VXNlcjY4MjcwMjk0", "avatar_url": "https://avatars.githubusercontent.com/u/68270294?v=4", "gravatar_id": "", "url": "https://api.github.com/users/SparrowLii", "html_url": "https://github.com/SparrowLii", "followers_url": "https://api.github.com/users/SparrowLii/followers", "following_url": "https://api.github.com/users/SparrowLii/following{/other_user}", "gists_url": "https://api.github.com/users/SparrowLii/gists{/gist_id}", "starred_url": "https://api.github.com/users/SparrowLii/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/SparrowLii/subscriptions", "organizations_url": "https://api.github.com/users/SparrowLii/orgs", "repos_url": "https://api.github.com/users/SparrowLii/repos", "events_url": "https://api.github.com/users/SparrowLii/events{/privacy}", "received_events_url": "https://api.github.com/users/SparrowLii/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "12d3f107c1634ed41a800e220ccf99b665d906d8", "url": "https://api.github.com/repos/rust-lang/rust/commits/12d3f107c1634ed41a800e220ccf99b665d906d8", "html_url": "https://github.com/rust-lang/rust/commit/12d3f107c1634ed41a800e220ccf99b665d906d8"}], "stats": {"total": 210, "additions": 78, "deletions": 132}, "files": [{"sha": "05d29503180ef73a6b9aacdfb97a931f92f1d8db", "filename": "compiler/rustc_borrowck/src/diagnostics/mod.rs", "status": "modified", "additions": 78, "deletions": 132, "changes": 210, "blob_url": "https://github.com/rust-lang/rust/blob/8ff01894a010690b9c7232d1217931dbc5d63333/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ff01894a010690b9c7232d1217931dbc5d63333/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fmod.rs?ref=8ff01894a010690b9c7232d1217931dbc5d63333", "patch": "@@ -1,5 +1,6 @@\n //! Borrow checker diagnostics.\n \n+use itertools::Itertools;\n use rustc_const_eval::util::{call_kind, CallDesugaringKind};\n use rustc_errors::{Applicability, Diagnostic};\n use rustc_hir as hir;\n@@ -161,158 +162,103 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n     }\n \n     /// End-user visible description of `place` if one can be found.\n-    /// If the place is a temporary for instance, None will be returned.\n+    /// If the place is a temporary for instance, `None` will be returned.\n     pub(super) fn describe_place(&self, place_ref: PlaceRef<'tcx>) -> Option<String> {\n         self.describe_place_with_options(place_ref, IncludingDowncast(false))\n     }\n \n-    /// End-user visible description of `place` if one can be found. If the\n-    /// place is a temporary for instance, None will be returned.\n-    /// `IncludingDowncast` parameter makes the function return `Err` if `ProjectionElem` is\n+    /// End-user visible description of `place` if one can be found. If the place is a temporary\n+    /// for instance, `None` will be returned.\n+    /// `IncludingDowncast` parameter makes the function return `None` if `ProjectionElem` is\n     /// `Downcast` and `IncludingDowncast` is true\n     pub(super) fn describe_place_with_options(\n         &self,\n         place: PlaceRef<'tcx>,\n         including_downcast: IncludingDowncast,\n     ) -> Option<String> {\n+        let local = place.local;\n+        let mut autoderef_index = None;\n         let mut buf = String::new();\n-        match self.append_place_to_string(place, &mut buf, false, &including_downcast) {\n-            Ok(()) => Some(buf),\n-            Err(()) => None,\n-        }\n-    }\n-\n-    /// Appends end-user visible description of `place` to `buf`.\n-    fn append_place_to_string(\n-        &self,\n-        place: PlaceRef<'tcx>,\n-        buf: &mut String,\n-        mut autoderef: bool,\n-        including_downcast: &IncludingDowncast,\n-    ) -> Result<(), ()> {\n-        match place {\n-            PlaceRef { local, projection: [] } => {\n-                self.append_local_to_string(local, buf)?;\n-            }\n-            PlaceRef { local, projection: [ProjectionElem::Deref] }\n-                if self.body.local_decls[local].is_ref_for_guard() =>\n-            {\n-                self.append_place_to_string(\n-                    PlaceRef { local, projection: &[] },\n-                    buf,\n-                    autoderef,\n-                    &including_downcast,\n-                )?;\n-            }\n-            PlaceRef { local, projection: [ProjectionElem::Deref] }\n-                if self.body.local_decls[local].is_ref_to_static() =>\n-            {\n-                let local_info = &self.body.local_decls[local].local_info;\n-                if let Some(box LocalInfo::StaticRef { def_id, .. }) = *local_info {\n-                    buf.push_str(self.infcx.tcx.item_name(def_id).as_str());\n-                } else {\n-                    unreachable!();\n-                }\n-            }\n-            PlaceRef { local, projection: [proj_base @ .., elem] } => {\n-                match elem {\n-                    ProjectionElem::Deref => {\n-                        let upvar_field_projection = self.is_upvar_field_projection(place);\n-                        if let Some(field) = upvar_field_projection {\n-                            let var_index = field.index();\n-                            let name = self.upvars[var_index].place.to_string(self.infcx.tcx);\n-                            if self.upvars[var_index].by_ref {\n-                                buf.push_str(&name);\n-                            } else {\n-                                buf.push('*');\n-                                buf.push_str(&name);\n-                            }\n-                        } else {\n-                            if autoderef {\n-                                // FIXME turn this recursion into iteration\n-                                self.append_place_to_string(\n-                                    PlaceRef { local, projection: proj_base },\n-                                    buf,\n-                                    autoderef,\n-                                    &including_downcast,\n-                                )?;\n-                            } else {\n-                                buf.push('*');\n-                                self.append_place_to_string(\n-                                    PlaceRef { local, projection: proj_base },\n-                                    buf,\n-                                    autoderef,\n-                                    &including_downcast,\n-                                )?;\n-                            }\n+        let mut ok = self.append_local_to_string(local, &mut buf);\n+\n+        for (index, elem) in place.projection.into_iter().enumerate() {\n+            match elem {\n+                ProjectionElem::Deref => {\n+                    if index == 0 {\n+                        if self.body.local_decls[local].is_ref_for_guard() {\n+                            continue;\n                         }\n-                    }\n-                    ProjectionElem::Downcast(..) => {\n-                        self.append_place_to_string(\n-                            PlaceRef { local, projection: proj_base },\n-                            buf,\n-                            autoderef,\n-                            &including_downcast,\n-                        )?;\n-                        if including_downcast.0 {\n-                            return Err(());\n+                        if let Some(box LocalInfo::StaticRef { def_id, .. }) =\n+                            &self.body.local_decls[local].local_info\n+                        {\n+                            buf.push_str(self.infcx.tcx.item_name(*def_id).as_str());\n+                            ok = Ok(());\n+                            continue;\n                         }\n                     }\n-                    ProjectionElem::Field(field, _ty) => {\n-                        autoderef = true;\n-\n-                        // FIXME(project-rfc_2229#36): print capture precisely here.\n-                        let upvar_field_projection = self.is_upvar_field_projection(place);\n-                        if let Some(field) = upvar_field_projection {\n-                            let var_index = field.index();\n-                            let name = self.upvars[var_index].place.to_string(self.infcx.tcx);\n-                            buf.push_str(&name);\n-                        } else {\n-                            let field_name = self\n-                                .describe_field(PlaceRef { local, projection: proj_base }, *field);\n-                            self.append_place_to_string(\n-                                PlaceRef { local, projection: proj_base },\n-                                buf,\n-                                autoderef,\n-                                &including_downcast,\n-                            )?;\n-                            buf.push('.');\n-                            buf.push_str(&field_name);\n+                    if let Some(field) = self.is_upvar_field_projection(PlaceRef {\n+                        local,\n+                        projection: place.projection.split_at(index + 1).0,\n+                    }) {\n+                        let var_index = field.index();\n+                        buf = self.upvars[var_index].place.to_string(self.infcx.tcx);\n+                        ok = Ok(());\n+                        if !self.upvars[var_index].by_ref {\n+                            buf.insert(0, '*');\n                         }\n-                    }\n-                    ProjectionElem::Index(index) => {\n-                        autoderef = true;\n-\n-                        self.append_place_to_string(\n-                            PlaceRef { local, projection: proj_base },\n-                            buf,\n-                            autoderef,\n-                            &including_downcast,\n-                        )?;\n-                        buf.push('[');\n-                        if self.append_local_to_string(*index, buf).is_err() {\n-                            buf.push('_');\n+                    } else {\n+                        if autoderef_index.is_none() {\n+                            autoderef_index =\n+                                match place.projection.into_iter().rev().find_position(|elem| {\n+                                    !matches!(\n+                                        elem,\n+                                        ProjectionElem::Deref | ProjectionElem::Downcast(..)\n+                                    )\n+                                }) {\n+                                    Some((index, _)) => Some(place.projection.len() - index),\n+                                    None => Some(0),\n+                                };\n+                        }\n+                        if index >= autoderef_index.unwrap() {\n+                            buf.insert(0, '*');\n                         }\n-                        buf.push(']');\n                     }\n-                    ProjectionElem::ConstantIndex { .. } | ProjectionElem::Subslice { .. } => {\n-                        autoderef = true;\n-                        // Since it isn't possible to borrow an element on a particular index and\n-                        // then use another while the borrow is held, don't output indices details\n-                        // to avoid confusing the end-user\n-                        self.append_place_to_string(\n-                            PlaceRef { local, projection: proj_base },\n-                            buf,\n-                            autoderef,\n-                            &including_downcast,\n-                        )?;\n-                        buf.push_str(\"[..]\");\n+                }\n+                ProjectionElem::Downcast(..) if including_downcast.0 => return None,\n+                ProjectionElem::Downcast(..) => (),\n+                ProjectionElem::Field(field, _ty) => {\n+                    // FIXME(project-rfc_2229#36): print capture precisely here.\n+                    if let Some(field) = self.is_upvar_field_projection(PlaceRef {\n+                        local,\n+                        projection: place.projection.split_at(index + 1).0,\n+                    }) {\n+                        buf = self.upvars[field.index()].place.to_string(self.infcx.tcx);\n+                        ok = Ok(());\n+                    } else {\n+                        let field_name = self.describe_field(\n+                            PlaceRef { local, projection: place.projection.split_at(index).0 },\n+                            *field,\n+                        );\n+                        buf.push('.');\n+                        buf.push_str(&field_name);\n                     }\n-                };\n+                }\n+                ProjectionElem::Index(index) => {\n+                    buf.push('[');\n+                    if self.append_local_to_string(*index, &mut buf).is_err() {\n+                        buf.push('_');\n+                    }\n+                    buf.push(']');\n+                }\n+                ProjectionElem::ConstantIndex { .. } | ProjectionElem::Subslice { .. } => {\n+                    // Since it isn't possible to borrow an element on a particular index and\n+                    // then use another while the borrow is held, don't output indices details\n+                    // to avoid confusing the end-user\n+                    buf.push_str(\"[..]\");\n+                }\n             }\n         }\n-\n-        Ok(())\n+        ok.ok().map(|_| buf)\n     }\n \n     /// Appends end-user visible description of the `local` place to `buf`. If `local` doesn't have"}]}