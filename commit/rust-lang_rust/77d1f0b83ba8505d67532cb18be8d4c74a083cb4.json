{"sha": "77d1f0b83ba8505d67532cb18be8d4c74a083cb4", "node_id": "MDY6Q29tbWl0NzI0NzEyOjc3ZDFmMGI4M2JhODUwNWQ2NzUzMmNiMThiZThkNGM3NGEwODNjYjQ=", "commit": {"author": {"name": "Jakub Bukaj", "email": "jakub@jakub.cc", "date": "2014-11-23T19:11:50Z"}, "committer": {"name": "Jakub Bukaj", "email": "jakub@jakub.cc", "date": "2014-11-23T19:11:50Z"}, "message": "rollup merge of #19193: scialex/rc-counts\n\nThese functions allow you to see how many weak and strong references\nthere are to an `Arc`, `Rc`, or an `rc::Weak`. Due to the design of\n`Arc` it is not possible to get the number of weak references of an\narbitrary `arc::Weak`. Look in `arc.rs` for a more in-depth explanation.\n\nOn `arc::Arc` and `arc::Weak` these operations are wait-free and atomic.\n\nThis sort of information is useful for creating dynamically cleared caches for use in OS development, for example holding pages of files in memory until the address space is needed for something else.", "tree": {"sha": "b94b79a4814b6e9a8e08dd21c246c3403f8530d8", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b94b79a4814b6e9a8e08dd21c246c3403f8530d8"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/77d1f0b83ba8505d67532cb18be8d4c74a083cb4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/77d1f0b83ba8505d67532cb18be8d4c74a083cb4", "html_url": "https://github.com/rust-lang/rust/commit/77d1f0b83ba8505d67532cb18be8d4c74a083cb4", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/77d1f0b83ba8505d67532cb18be8d4c74a083cb4/comments", "author": null, "committer": null, "parents": [{"sha": "1e5de8cf3cde5f8cc7376c637d072b765c6403fe", "url": "https://api.github.com/repos/rust-lang/rust/commits/1e5de8cf3cde5f8cc7376c637d072b765c6403fe", "html_url": "https://github.com/rust-lang/rust/commit/1e5de8cf3cde5f8cc7376c637d072b765c6403fe"}, {"sha": "69861df831a2d0c551b46a291c2530aeeab6c704", "url": "https://api.github.com/repos/rust-lang/rust/commits/69861df831a2d0c551b46a291c2530aeeab6c704", "html_url": "https://github.com/rust-lang/rust/commit/69861df831a2d0c551b46a291c2530aeeab6c704"}], "stats": {"total": 104, "additions": 100, "deletions": 4}, "files": [{"sha": "4f744b0b2dee1b271a2e99e646871dd65cd92920", "filename": "src/liballoc/arc.rs", "status": "modified", "additions": 54, "deletions": 1, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/77d1f0b83ba8505d67532cb18be8d4c74a083cb4/src%2Fliballoc%2Farc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/77d1f0b83ba8505d67532cb18be8d4c74a083cb4/src%2Fliballoc%2Farc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Farc.rs?ref=77d1f0b83ba8505d67532cb18be8d4c74a083cb4", "patch": "@@ -119,6 +119,16 @@ impl<T> Arc<T> {\n     }\n }\n \n+/// Get the number of weak references to this value.\n+#[inline]\n+#[experimental]\n+pub fn weak_count<T>(this: &Arc<T>) -> uint { this.inner().weak.load(atomic::SeqCst) - 1 }\n+\n+/// Get the number of strong references to this value.\n+#[inline]\n+#[experimental]\n+pub fn strong_count<T>(this: &Arc<T>) -> uint { this.inner().strong.load(atomic::SeqCst) }\n+\n #[unstable = \"waiting on stability of Clone\"]\n impl<T> Clone for Arc<T> {\n     /// Duplicate an atomically reference counted wrapper.\n@@ -321,7 +331,7 @@ mod tests {\n     use std::sync::atomic;\n     use std::task;\n     use std::vec::Vec;\n-    use super::{Arc, Weak};\n+    use super::{Arc, Weak, weak_count, strong_count};\n     use std::sync::Mutex;\n \n     struct Canary(*mut atomic::AtomicUint);\n@@ -465,6 +475,49 @@ mod tests {\n         drop(arc_weak);\n     }\n \n+    #[test]\n+    fn test_strong_count() {\n+        let a = Arc::new(0u32);\n+        assert!(strong_count(&a) == 1);\n+        let w = a.downgrade();\n+        assert!(strong_count(&a) == 1);\n+        let b = w.upgrade().expect(\"\");\n+        assert!(strong_count(&b) == 2);\n+        assert!(strong_count(&a) == 2);\n+        drop(w);\n+        drop(a);\n+        assert!(strong_count(&b) == 1);\n+        let c = b.clone();\n+        assert!(strong_count(&b) == 2);\n+        assert!(strong_count(&c) == 2);\n+    }\n+\n+    #[test]\n+    fn test_weak_count() {\n+        let a = Arc::new(0u32);\n+        assert!(strong_count(&a) == 1);\n+        assert!(weak_count(&a) == 0);\n+        let w = a.downgrade();\n+        assert!(strong_count(&a) == 1);\n+        assert!(weak_count(&a) == 1);\n+        let x = w.clone();\n+        assert!(weak_count(&a) == 2);\n+        drop(w);\n+        drop(x);\n+        assert!(strong_count(&a) == 1);\n+        assert!(weak_count(&a) == 0);\n+        let c = a.clone();\n+        assert!(strong_count(&a) == 2);\n+        assert!(weak_count(&a) == 0);\n+        let d = c.downgrade();\n+        assert!(weak_count(&c) == 1);\n+        assert!(strong_count(&c) == 2);\n+\n+        drop(a);\n+        drop(c);\n+        drop(d);\n+    }\n+\n     #[test]\n     fn show_arc() {\n         let a = Arc::new(5u32);"}, {"sha": "df84ac9aec93550a467539c36bb312880a5f0de9", "filename": "src/liballoc/rc.rs", "status": "modified", "additions": 46, "deletions": 3, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/77d1f0b83ba8505d67532cb18be8d4c74a083cb4/src%2Fliballoc%2Frc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/77d1f0b83ba8505d67532cb18be8d4c74a083cb4/src%2Fliballoc%2Frc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Frc.rs?ref=77d1f0b83ba8505d67532cb18be8d4c74a083cb4", "patch": "@@ -213,15 +213,24 @@ impl<T> Rc<T> {\n     }\n }\n \n+/// Get the number of weak references to this value.\n+#[inline]\n+#[experimental]\n+pub fn weak_count<T>(this: &Rc<T>) -> uint { this.weak() - 1 }\n+\n+/// Get the number of strong references to this value.\n+#[inline]\n+#[experimental]\n+pub fn strong_count<T>(this: &Rc<T>) -> uint { this.strong() }\n+\n /// Returns true if the `Rc` currently has unique ownership.\n ///\n /// Unique ownership means that there are no other `Rc` or `Weak` values\n /// that share the same contents.\n #[inline]\n #[experimental]\n pub fn is_unique<T>(rc: &Rc<T>) -> bool {\n-    // note that we hold both a strong and a weak reference\n-    rc.strong() == 1 && rc.weak() == 1\n+    weak_count(rc) == 0 && strong_count(rc) == 1\n }\n \n /// Unwraps the contained value if the `Rc` has unique ownership.\n@@ -489,7 +498,7 @@ impl<T> RcBoxPtr<T> for Weak<T> {\n #[cfg(test)]\n #[allow(experimental)]\n mod tests {\n-    use super::{Rc, Weak};\n+    use super::{Rc, Weak, weak_count, strong_count};\n     use std::cell::RefCell;\n     use std::option::{Option, Some, None};\n     use std::result::{Err, Ok};\n@@ -566,6 +575,40 @@ mod tests {\n         assert!(super::is_unique(&x));\n     }\n \n+    #[test]\n+    fn test_strong_count() {\n+        let a = Rc::new(0u32);\n+        assert!(strong_count(&a) == 1);\n+        let w = a.downgrade();\n+        assert!(strong_count(&a) == 1);\n+        let b = w.upgrade().expect(\"upgrade of live rc failed\");\n+        assert!(strong_count(&b) == 2);\n+        assert!(strong_count(&a) == 2);\n+        drop(w);\n+        drop(a);\n+        assert!(strong_count(&b) == 1);\n+        let c = b.clone();\n+        assert!(strong_count(&b) == 2);\n+        assert!(strong_count(&c) == 2);\n+    }\n+\n+    #[test]\n+    fn test_weak_count() {\n+        let a = Rc::new(0u32);\n+        assert!(strong_count(&a) == 1);\n+        assert!(weak_count(&a) == 0);\n+        let w = a.downgrade();\n+        assert!(strong_count(&a) == 1);\n+        assert!(weak_count(&a) == 1);\n+        drop(w);\n+        assert!(strong_count(&a) == 1);\n+        assert!(weak_count(&a) == 0);\n+        let c = a.clone();\n+        assert!(strong_count(&a) == 2);\n+        assert!(weak_count(&a) == 0);\n+        drop(c);\n+    }\n+\n     #[test]\n     fn try_unwrap() {\n         let x = Rc::new(3u);"}]}