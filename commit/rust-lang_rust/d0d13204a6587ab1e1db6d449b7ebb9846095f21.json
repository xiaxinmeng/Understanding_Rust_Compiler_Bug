{"sha": "d0d13204a6587ab1e1db6d449b7ebb9846095f21", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQwZDEzMjA0YTY1ODdhYjFlMWRiNmQ0NDliN2ViYjk4NDYwOTVmMjE=", "commit": {"author": {"name": "Eduard-Mihai Burtescu", "email": "edy.burt@gmail.com", "date": "2018-01-05T04:14:44Z"}, "committer": {"name": "Eduard-Mihai Burtescu", "email": "edy.burt@gmail.com", "date": "2018-01-14T06:52:16Z"}, "message": "rustc_trans: collapse {Local,Shared}CrateContext.", "tree": {"sha": "41f054d223f08f3ba2c485dd1d121cea6f3aa690", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/41f054d223f08f3ba2c485dd1d121cea6f3aa690"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d0d13204a6587ab1e1db6d449b7ebb9846095f21", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d0d13204a6587ab1e1db6d449b7ebb9846095f21", "html_url": "https://github.com/rust-lang/rust/commit/d0d13204a6587ab1e1db6d449b7ebb9846095f21", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d0d13204a6587ab1e1db6d449b7ebb9846095f21/comments", "author": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "committer": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b762c2d9dd47e75905cdeae6bef81a745f09534c", "url": "https://api.github.com/repos/rust-lang/rust/commits/b762c2d9dd47e75905cdeae6bef81a745f09534c", "html_url": "https://github.com/rust-lang/rust/commit/b762c2d9dd47e75905cdeae6bef81a745f09534c"}], "stats": {"total": 356, "additions": 113, "deletions": 243}, "files": [{"sha": "b18d4efceac5b682d15c336ebc85904db3158ee1", "filename": "src/librustc_trans/base.rs", "status": "modified", "additions": 9, "deletions": 12, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/d0d13204a6587ab1e1db6d449b7ebb9846095f21/src%2Flibrustc_trans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d0d13204a6587ab1e1db6d449b7ebb9846095f21/src%2Flibrustc_trans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fbase.rs?ref=d0d13204a6587ab1e1db6d449b7ebb9846095f21", "patch": "@@ -57,9 +57,9 @@ use builder::Builder;\n use callee;\n use common::{C_bool, C_bytes_in_context, C_i32, C_usize};\n use rustc_mir::monomorphize::collector::{self, MonoItemCollectionMode};\n-use common::{self, C_struct_in_context, C_array, CrateContext, val_ty};\n+use common::{self, C_struct_in_context, C_array, val_ty};\n use consts;\n-use context::{self, LocalCrateContext, SharedCrateContext};\n+use context::{self, CrateContext};\n use debuginfo;\n use declare;\n use meth;\n@@ -232,13 +232,13 @@ pub fn unsize_thin_ptr<'a, 'tcx>(\n          &ty::TyRawPtr(ty::TypeAndMut { ty: b, .. })) |\n         (&ty::TyRawPtr(ty::TypeAndMut { ty: a, .. }),\n          &ty::TyRawPtr(ty::TypeAndMut { ty: b, .. })) => {\n-            assert!(bcx.ccx.shared().type_is_sized(a));\n+            assert!(bcx.ccx.type_is_sized(a));\n             let ptr_ty = bcx.ccx.layout_of(b).llvm_type(bcx.ccx).ptr_to();\n             (bcx.pointercast(src, ptr_ty), unsized_info(bcx.ccx, a, b, None))\n         }\n         (&ty::TyAdt(def_a, _), &ty::TyAdt(def_b, _)) if def_a.is_box() && def_b.is_box() => {\n             let (a, b) = (src_ty.boxed_ty(), dst_ty.boxed_ty());\n-            assert!(bcx.ccx.shared().type_is_sized(a));\n+            assert!(bcx.ccx.type_is_sized(a));\n             let ptr_ty = bcx.ccx.layout_of(b).llvm_type(bcx.ccx).ptr_to();\n             (bcx.pointercast(src, ptr_ty), unsized_info(bcx.ccx, a, b, None))\n         }\n@@ -721,7 +721,6 @@ pub fn trans_crate<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     let link_meta = link::build_link_meta(crate_hash);\n     let exported_symbol_node_ids = find_exported_symbols(tcx);\n \n-    let shared_ccx = SharedCrateContext::new(tcx);\n     // Translate the metadata.\n     let llmod_id = \"metadata\";\n     let (metadata_llcx, metadata_llmod, metadata) =\n@@ -770,7 +769,7 @@ pub fn trans_crate<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     // Run the translation item collector and partition the collected items into\n     // codegen units.\n     let codegen_units =\n-        shared_ccx.tcx().collect_and_partition_translation_items(LOCAL_CRATE).1;\n+        tcx.collect_and_partition_translation_items(LOCAL_CRATE).1;\n     let codegen_units = (*codegen_units).clone();\n \n     // Force all codegen_unit queries so they are already either red or green\n@@ -910,7 +909,7 @@ pub fn trans_crate<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n \n     symbol_names_test::report_symbol_names(tcx);\n \n-    if shared_ccx.sess().trans_stats() {\n+    if tcx.sess.trans_stats() {\n         println!(\"--- trans stats ---\");\n         println!(\"n_glues_created: {}\", all_stats.n_glues_created);\n         println!(\"n_null_glues: {}\", all_stats.n_null_glues);\n@@ -926,7 +925,7 @@ pub fn trans_crate<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         }\n     }\n \n-    if shared_ccx.sess().count_llvm_insns() {\n+    if tcx.sess.count_llvm_insns() {\n         for (k, v) in all_stats.llvm_insns.iter() {\n             println!(\"{:7} {}\", *v, *k);\n         }\n@@ -1204,10 +1203,8 @@ fn compile_codegen_unit<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                                    .to_fingerprint().to_hex());\n \n         // Instantiate translation items without filling out definitions yet...\n-        let scx = SharedCrateContext::new(tcx);\n-        let lcx = LocalCrateContext::new(&scx, cgu, &llmod_id);\n+        let ccx = CrateContext::new(tcx, cgu, &llmod_id);\n         let module = {\n-            let ccx = CrateContext::new(&scx, &lcx);\n             let trans_items = ccx.codegen_unit()\n                                  .items_in_deterministic_order(ccx.tcx());\n             for &(trans_item, (linkage, visibility)) in &trans_items {\n@@ -1268,7 +1265,7 @@ fn compile_codegen_unit<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n             }\n         };\n \n-        (lcx.into_stats(), module)\n+        (ccx.into_stats(), module)\n     }\n }\n "}, {"sha": "4df1cb289c99ba235d177aec75efbbc0ff2c9d5e", "filename": "src/librustc_trans/common.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d0d13204a6587ab1e1db6d449b7ebb9846095f21/src%2Flibrustc_trans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d0d13204a6587ab1e1db6d449b7ebb9846095f21/src%2Flibrustc_trans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcommon.rs?ref=d0d13204a6587ab1e1db6d449b7ebb9846095f21", "patch": "@@ -38,7 +38,7 @@ use syntax::abi::Abi;\n use syntax::symbol::InternedString;\n use syntax_pos::{Span, DUMMY_SP};\n \n-pub use context::{CrateContext, SharedCrateContext};\n+pub use context::CrateContext;\n \n pub fn type_needs_drop<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, ty: Ty<'tcx>) -> bool {\n     ty.needs_drop(tcx, ty::ParamEnv::empty(traits::Reveal::All))"}, {"sha": "e7b521d9a567a4c8e99ee57030a4c7f014f735f4", "filename": "src/librustc_trans/consts.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d0d13204a6587ab1e1db6d449b7ebb9846095f21/src%2Flibrustc_trans%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d0d13204a6587ab1e1db6d449b7ebb9846095f21/src%2Flibrustc_trans%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fconsts.rs?ref=d0d13204a6587ab1e1db6d449b7ebb9846095f21", "patch": "@@ -299,7 +299,7 @@ pub fn trans_static<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n         // As an optimization, all shared statics which do not have interior\n         // mutability are placed into read-only memory.\n         if m != hir::MutMutable {\n-            if ccx.shared().type_is_freeze(ty) {\n+            if ccx.type_is_freeze(ty) {\n                 llvm::LLVMSetGlobalConstant(g, llvm::True);\n             }\n         }"}, {"sha": "924b41f9f2be2991e0e9b9770b8c93cbf6344169", "filename": "src/librustc_trans/context.rs", "status": "modified", "additions": 75, "deletions": 200, "changes": 275, "blob_url": "https://github.com/rust-lang/rust/blob/d0d13204a6587ab1e1db6d449b7ebb9846095f21/src%2Flibrustc_trans%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d0d13204a6587ab1e1db6d449b7ebb9846095f21/src%2Flibrustc_trans%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcontext.rs?ref=d0d13204a6587ab1e1db6d449b7ebb9846095f21", "patch": "@@ -11,10 +11,9 @@\n use common;\n use llvm;\n use llvm::{ContextRef, ModuleRef, ValueRef};\n-use rustc::dep_graph::{DepGraph, DepGraphSafe};\n+use rustc::dep_graph::DepGraphSafe;\n use rustc::hir;\n use rustc::hir::def_id::DefId;\n-use rustc::ich::StableHashingContext;\n use rustc::traits;\n use debuginfo;\n use callee;\n@@ -28,7 +27,6 @@ use type_of::PointeeInfo;\n \n use rustc_data_structures::base_n;\n use rustc::mir::mono::Stats;\n-use rustc_data_structures::stable_hasher::StableHashingContextProvider;\n use rustc::session::config::{self, NoDebugInfo};\n use rustc::session::Session;\n use rustc::ty::layout::{LayoutError, LayoutOf, Size, TyLayout};\n@@ -41,26 +39,18 @@ use std::ptr;\n use std::iter;\n use std::str;\n use std::sync::Arc;\n-use std::marker::PhantomData;\n use syntax::symbol::InternedString;\n use abi::Abi;\n \n-/// The shared portion of a `CrateContext`.  There is one `SharedCrateContext`\n-/// per crate.  The data here is shared between all compilation units of the\n-/// crate, so it must not contain references to any LLVM data structures\n-/// (aside from metadata-related ones).\n-pub struct SharedCrateContext<'a, 'tcx: 'a> {\n+/// There is one `CrateContext` per compilation unit. Each one has its own LLVM\n+/// `ContextRef` so that several compilation units may be optimized in parallel.\n+/// All other LLVM data structures in the `CrateContext` are tied to that `ContextRef`.\n+pub struct CrateContext<'a, 'tcx: 'a> {\n     tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     check_overflow: bool,\n     use_dll_storage_attrs: bool,\n     tls_model: llvm::ThreadLocalMode,\n-}\n \n-/// The local portion of a `CrateContext`.  There is one `LocalCrateContext`\n-/// per compilation unit.  Each one has its own LLVM `ContextRef` so that\n-/// several compilation units may be optimized in parallel.  All other LLVM\n-/// data structures in the `LocalCrateContext` are tied to that `ContextRef`.\n-pub struct LocalCrateContext<'a, 'tcx: 'a> {\n     llmod: ModuleRef,\n     llcx: ContextRef,\n     stats: RefCell<Stats>,\n@@ -115,41 +105,11 @@ pub struct LocalCrateContext<'a, 'tcx: 'a> {\n \n     /// A counter that is used for generating local symbol names\n     local_gen_sym_counter: Cell<usize>,\n-\n-    /// A placeholder so we can add lifetimes\n-    placeholder: PhantomData<&'a ()>,\n-}\n-\n-/// A CrateContext value binds together one LocalCrateContext with the\n-/// SharedCrateContext. It exists as a convenience wrapper, so we don't have to\n-/// pass around (SharedCrateContext, LocalCrateContext) tuples all over trans.\n-pub struct CrateContext<'a, 'tcx: 'a> {\n-    shared: &'a SharedCrateContext<'a, 'tcx>,\n-    local_ccx: &'a LocalCrateContext<'a, 'tcx>,\n-}\n-\n-impl<'a, 'tcx> CrateContext<'a, 'tcx> {\n-    pub fn new(shared: &'a SharedCrateContext<'a, 'tcx>,\n-               local_ccx: &'a LocalCrateContext<'a, 'tcx>)\n-               -> Self {\n-        CrateContext { shared, local_ccx }\n-    }\n }\n \n impl<'a, 'tcx> DepGraphSafe for CrateContext<'a, 'tcx> {\n }\n \n-impl<'a, 'tcx> DepGraphSafe for SharedCrateContext<'a, 'tcx> {\n-}\n-\n-impl<'a, 'tcx> StableHashingContextProvider for SharedCrateContext<'a, 'tcx> {\n-    type ContextType = StableHashingContext<'tcx>;\n-\n-    fn create_stable_hashing_context(&self) -> Self::ContextType {\n-        self.tcx.create_stable_hashing_context()\n-    }\n-}\n-\n pub fn get_reloc_model(sess: &Session) -> llvm::RelocMode {\n     let reloc_model_arg = match sess.opts.cg.relocation_model {\n         Some(ref s) => &s[..],\n@@ -252,8 +212,11 @@ pub unsafe fn create_context_and_module(sess: &Session, mod_name: &str) -> (Cont\n     (llcx, llmod)\n }\n \n-impl<'b, 'tcx> SharedCrateContext<'b, 'tcx> {\n-    pub fn new(tcx: TyCtxt<'b, 'tcx, 'tcx>) -> SharedCrateContext<'b, 'tcx> {\n+impl<'a, 'tcx> CrateContext<'a, 'tcx> {\n+    pub fn new(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+               codegen_unit: Arc<CodegenUnit<'tcx>>,\n+               llmod_id: &str)\n+               -> CrateContext<'a, 'tcx> {\n         // An interesting part of Windows which MSVC forces our hand on (and\n         // apparently MinGW didn't) is the usage of `dllimport` and `dllexport`\n         // attributes in LLVM IR as well as native dependencies (in C these\n@@ -303,78 +266,25 @@ impl<'b, 'tcx> SharedCrateContext<'b, 'tcx> {\n \n         let tls_model = get_tls_model(&tcx.sess);\n \n-        SharedCrateContext {\n-            tcx,\n-            check_overflow,\n-            use_dll_storage_attrs,\n-            tls_model,\n-        }\n-    }\n-\n-    pub fn type_needs_drop(&self, ty: Ty<'tcx>) -> bool {\n-        common::type_needs_drop(self.tcx, ty)\n-    }\n-\n-    pub fn type_is_sized(&self, ty: Ty<'tcx>) -> bool {\n-        common::type_is_sized(self.tcx, ty)\n-    }\n-\n-    pub fn type_is_freeze(&self, ty: Ty<'tcx>) -> bool {\n-        common::type_is_freeze(self.tcx, ty)\n-    }\n-\n-    pub fn type_has_metadata(&self, ty: Ty<'tcx>) -> bool {\n-        use syntax_pos::DUMMY_SP;\n-        if ty.is_sized(self.tcx, ty::ParamEnv::empty(traits::Reveal::All), DUMMY_SP) {\n-            return false;\n-        }\n-\n-        let tail = self.tcx.struct_tail(ty);\n-        match tail.sty {\n-            ty::TyForeign(..) => false,\n-            ty::TyStr | ty::TySlice(..) | ty::TyDynamic(..) => true,\n-            _ => bug!(\"unexpected unsized tail: {:?}\", tail.sty),\n-        }\n-    }\n-\n-    pub fn tcx(&self) -> TyCtxt<'b, 'tcx, 'tcx> {\n-        self.tcx\n-    }\n-\n-    pub fn sess<'a>(&'a self) -> &'a Session {\n-        &self.tcx.sess\n-    }\n-\n-    pub fn dep_graph<'a>(&'a self) -> &'a DepGraph {\n-        &self.tcx.dep_graph\n-    }\n-\n-    pub fn use_dll_storage_attrs(&self) -> bool {\n-        self.use_dll_storage_attrs\n-    }\n-}\n-\n-impl<'a, 'tcx> LocalCrateContext<'a, 'tcx> {\n-    pub fn new(shared: &SharedCrateContext<'a, 'tcx>,\n-               codegen_unit: Arc<CodegenUnit<'tcx>>,\n-               llmod_id: &str)\n-               -> LocalCrateContext<'a, 'tcx> {\n         unsafe {\n-            let (llcx, llmod) = create_context_and_module(&shared.tcx.sess,\n+            let (llcx, llmod) = create_context_and_module(&tcx.sess,\n                                                           &llmod_id[..]);\n \n-            let dbg_cx = if shared.tcx.sess.opts.debuginfo != NoDebugInfo {\n+            let dbg_cx = if tcx.sess.opts.debuginfo != NoDebugInfo {\n                 let dctx = debuginfo::CrateDebugContext::new(llmod);\n-                debuginfo::metadata::compile_unit_metadata(shared,\n+                debuginfo::metadata::compile_unit_metadata(tcx,\n                                                            codegen_unit.name(),\n-                                                           &dctx,\n-                                                           shared.tcx.sess);\n+                                                           &dctx);\n                 Some(dctx)\n             } else {\n                 None\n             };\n \n-            let local_ccx = LocalCrateContext {\n+            let mut ccx = CrateContext {\n+                tcx,\n+                check_overflow,\n+                use_dll_storage_attrs,\n+                tls_model,\n                 llmod,\n                 llcx,\n                 stats: RefCell::new(Stats::default()),\n@@ -397,41 +307,9 @@ impl<'a, 'tcx> LocalCrateContext<'a, 'tcx> {\n                 rust_try_fn: Cell::new(None),\n                 intrinsics: RefCell::new(FxHashMap()),\n                 local_gen_sym_counter: Cell::new(0),\n-                placeholder: PhantomData,\n-            };\n-\n-            let (isize_ty, mut local_ccx) = {\n-                // Do a little dance to create a dummy CrateContext, so we can\n-                // create some things in the LLVM module of this codegen unit\n-                let mut local_ccxs = vec![local_ccx];\n-                let isize_ty = {\n-                    let dummy_ccx = LocalCrateContext::dummy_ccx(shared,\n-                                                                 local_ccxs.as_mut_slice());\n-                    Type::isize(&dummy_ccx)\n-                };\n-                (isize_ty, local_ccxs.pop().unwrap())\n             };\n-\n-            local_ccx.isize_ty = isize_ty;\n-\n-            local_ccx\n-        }\n-    }\n-\n-    /// Create a dummy `CrateContext` from `self` and  the provided\n-    /// `SharedCrateContext`.  This is somewhat dangerous because `self` may\n-    /// not be fully initialized.\n-    ///\n-    /// This is used in the `LocalCrateContext` constructor to allow calling\n-    /// functions that expect a complete `CrateContext`, even before the local\n-    /// portion is fully initialized and attached to the `SharedCrateContext`.\n-    fn dummy_ccx(shared: &'a SharedCrateContext<'a, 'tcx>,\n-                 local_ccxs: &'a [LocalCrateContext<'a, 'tcx>])\n-                 -> CrateContext<'a, 'tcx> {\n-        assert!(local_ccxs.len() == 1);\n-        CrateContext {\n-            shared,\n-            local_ccx: &local_ccxs[0]\n+            ccx.isize_ty = Type::isize(&ccx);\n+            ccx\n         }\n     }\n \n@@ -441,20 +319,12 @@ impl<'a, 'tcx> LocalCrateContext<'a, 'tcx> {\n }\n \n impl<'b, 'tcx> CrateContext<'b, 'tcx> {\n-    pub fn shared(&self) -> &'b SharedCrateContext<'b, 'tcx> {\n-        self.shared\n-    }\n-\n-    fn local(&self) -> &'b LocalCrateContext<'b, 'tcx> {\n-        self.local_ccx\n-    }\n-\n     pub fn tcx(&self) -> TyCtxt<'b, 'tcx, 'tcx> {\n-        self.shared.tcx\n+        self.tcx\n     }\n \n     pub fn sess<'a>(&'a self) -> &'a Session {\n-        &self.shared.tcx.sess\n+        &self.tcx.sess\n     }\n \n     pub fn get_intrinsic(&self, key: &str) -> ValueRef {\n@@ -468,105 +338,105 @@ impl<'b, 'tcx> CrateContext<'b, 'tcx> {\n     }\n \n     pub fn llmod(&self) -> ModuleRef {\n-        self.local().llmod\n+        self.llmod\n     }\n \n     pub fn llcx(&self) -> ContextRef {\n-        self.local().llcx\n+        self.llcx\n     }\n \n     pub fn codegen_unit(&self) -> &CodegenUnit<'tcx> {\n-        &self.local().codegen_unit\n+        &self.codegen_unit\n     }\n \n     pub fn td(&self) -> llvm::TargetDataRef {\n         unsafe { llvm::LLVMRustGetModuleDataLayout(self.llmod()) }\n     }\n \n     pub fn instances<'a>(&'a self) -> &'a RefCell<FxHashMap<Instance<'tcx>, ValueRef>> {\n-        &self.local().instances\n+        &self.instances\n     }\n \n     pub fn vtables<'a>(&'a self)\n         -> &'a RefCell<FxHashMap<(Ty<'tcx>,\n                                   Option<ty::PolyExistentialTraitRef<'tcx>>), ValueRef>> {\n-        &self.local().vtables\n+        &self.vtables\n     }\n \n     pub fn const_cstr_cache<'a>(&'a self) -> &'a RefCell<FxHashMap<InternedString, ValueRef>> {\n-        &self.local().const_cstr_cache\n+        &self.const_cstr_cache\n     }\n \n     pub fn const_unsized<'a>(&'a self) -> &'a RefCell<FxHashMap<ValueRef, ValueRef>> {\n-        &self.local().const_unsized\n+        &self.const_unsized\n     }\n \n     pub fn const_globals<'a>(&'a self) -> &'a RefCell<FxHashMap<ValueRef, ValueRef>> {\n-        &self.local().const_globals\n+        &self.const_globals\n     }\n \n     pub fn statics<'a>(&'a self) -> &'a RefCell<FxHashMap<ValueRef, DefId>> {\n-        &self.local().statics\n+        &self.statics\n     }\n \n     pub fn statics_to_rauw<'a>(&'a self) -> &'a RefCell<Vec<(ValueRef, ValueRef)>> {\n-        &self.local().statics_to_rauw\n+        &self.statics_to_rauw\n     }\n \n     pub fn used_statics<'a>(&'a self) -> &'a RefCell<Vec<ValueRef>> {\n-        &self.local().used_statics\n+        &self.used_statics\n     }\n \n     pub fn lltypes<'a>(&'a self) -> &'a RefCell<FxHashMap<(Ty<'tcx>, Option<usize>), Type>> {\n-        &self.local().lltypes\n+        &self.lltypes\n     }\n \n     pub fn scalar_lltypes<'a>(&'a self) -> &'a RefCell<FxHashMap<Ty<'tcx>, Type>> {\n-        &self.local().scalar_lltypes\n+        &self.scalar_lltypes\n     }\n \n     pub fn pointee_infos<'a>(&'a self)\n                              -> &'a RefCell<FxHashMap<(Ty<'tcx>, Size), Option<PointeeInfo>>> {\n-        &self.local().pointee_infos\n+        &self.pointee_infos\n     }\n \n     pub fn stats<'a>(&'a self) -> &'a RefCell<Stats> {\n-        &self.local().stats\n+        &self.stats\n     }\n \n     pub fn isize_ty(&self) -> Type {\n-        self.local().isize_ty\n+        self.isize_ty\n     }\n \n     pub fn dbg_cx<'a>(&'a self) -> &'a Option<debuginfo::CrateDebugContext<'tcx>> {\n-        &self.local().dbg_cx\n+        &self.dbg_cx\n     }\n \n     pub fn rust_try_fn<'a>(&'a self) -> &'a Cell<Option<ValueRef>> {\n-        &self.local().rust_try_fn\n+        &self.rust_try_fn\n     }\n \n     fn intrinsics<'a>(&'a self) -> &'a RefCell<FxHashMap<&'static str, ValueRef>> {\n-        &self.local().intrinsics\n+        &self.intrinsics\n     }\n \n     pub fn check_overflow(&self) -> bool {\n-        self.shared.check_overflow\n+        self.check_overflow\n     }\n \n     pub fn use_dll_storage_attrs(&self) -> bool {\n-        self.shared.use_dll_storage_attrs()\n+        self.use_dll_storage_attrs\n     }\n \n     pub fn tls_model(&self) -> llvm::ThreadLocalMode {\n-        self.shared.tls_model\n+        self.tls_model\n     }\n \n     /// Generate a new symbol name with the given prefix. This symbol name must\n     /// only be used for definitions with `internal` or `private` linkage.\n     pub fn generate_local_symbol_name(&self, prefix: &str) -> String {\n-        let idx = self.local().local_gen_sym_counter.get();\n-        self.local().local_gen_sym_counter.set(idx + 1);\n+        let idx = self.local_gen_sym_counter.get();\n+        self.local_gen_sym_counter.set(idx + 1);\n         // Include a '.' character, so there can be no accidental conflicts with\n         // user defined names\n         let mut name = String::with_capacity(prefix.len() + 6);\n@@ -597,7 +467,7 @@ impl<'b, 'tcx> CrateContext<'b, 'tcx> {\n         // `rust_eh_personality` function, but rather we wired it up to the\n         // CRT's custom personality function, which forces LLVM to consider\n         // landing pads as \"landing pads for SEH\".\n-        if let Some(llpersonality) = self.local().eh_personality.get() {\n+        if let Some(llpersonality) = self.eh_personality.get() {\n             return llpersonality\n         }\n         let tcx = self.tcx();\n@@ -615,15 +485,15 @@ impl<'b, 'tcx> CrateContext<'b, 'tcx> {\n                 declare::declare_cfn(self, name, fty)\n             }\n         };\n-        self.local().eh_personality.set(Some(llfn));\n+        self.eh_personality.set(Some(llfn));\n         llfn\n     }\n \n     // Returns a ValueRef of the \"eh_unwind_resume\" lang item if one is defined,\n     // otherwise declares it as an external function.\n     pub fn eh_unwind_resume(&self) -> ValueRef {\n         use attributes;\n-        let unwresume = &self.local().eh_unwind_resume;\n+        let unwresume = &self.eh_unwind_resume;\n         if let Some(llfn) = unwresume.get() {\n             return llfn;\n         }\n@@ -649,33 +519,47 @@ impl<'b, 'tcx> CrateContext<'b, 'tcx> {\n         unwresume.set(Some(llfn));\n         llfn\n     }\n-}\n \n-impl<'a, 'tcx> ty::layout::HasDataLayout for &'a SharedCrateContext<'a, 'tcx> {\n-    fn data_layout(&self) -> &ty::layout::TargetDataLayout {\n-        &self.tcx.data_layout\n+    pub fn type_needs_drop(&self, ty: Ty<'tcx>) -> bool {\n+        common::type_needs_drop(self.tcx, ty)\n     }\n-}\n \n-impl<'a, 'tcx> ty::layout::HasTyCtxt<'tcx> for &'a SharedCrateContext<'a, 'tcx> {\n-    fn tcx<'b>(&'b self) -> TyCtxt<'b, 'tcx, 'tcx> {\n-        self.tcx\n+    pub fn type_is_sized(&self, ty: Ty<'tcx>) -> bool {\n+        common::type_is_sized(self.tcx, ty)\n+    }\n+\n+    pub fn type_is_freeze(&self, ty: Ty<'tcx>) -> bool {\n+        common::type_is_freeze(self.tcx, ty)\n+    }\n+\n+    pub fn type_has_metadata(&self, ty: Ty<'tcx>) -> bool {\n+        use syntax_pos::DUMMY_SP;\n+        if ty.is_sized(self.tcx, ty::ParamEnv::empty(traits::Reveal::All), DUMMY_SP) {\n+            return false;\n+        }\n+\n+        let tail = self.tcx.struct_tail(ty);\n+        match tail.sty {\n+            ty::TyForeign(..) => false,\n+            ty::TyStr | ty::TySlice(..) | ty::TyDynamic(..) => true,\n+            _ => bug!(\"unexpected unsized tail: {:?}\", tail.sty),\n+        }\n     }\n }\n \n impl<'a, 'tcx> ty::layout::HasDataLayout for &'a CrateContext<'a, 'tcx> {\n     fn data_layout(&self) -> &ty::layout::TargetDataLayout {\n-        &self.shared.tcx.data_layout\n+        &self.tcx.data_layout\n     }\n }\n \n impl<'a, 'tcx> ty::layout::HasTyCtxt<'tcx> for &'a CrateContext<'a, 'tcx> {\n     fn tcx<'b>(&'b self) -> TyCtxt<'b, 'tcx, 'tcx> {\n-        self.shared.tcx\n+        self.tcx\n     }\n }\n \n-impl<'a, 'tcx> LayoutOf<Ty<'tcx>> for &'a SharedCrateContext<'a, 'tcx> {\n+impl<'a, 'tcx> LayoutOf<Ty<'tcx>> for &'a CrateContext<'a, 'tcx> {\n     type TyLayout = TyLayout<'tcx>;\n \n     fn layout_of(self, ty: Ty<'tcx>) -> Self::TyLayout {\n@@ -688,15 +572,6 @@ impl<'a, 'tcx> LayoutOf<Ty<'tcx>> for &'a SharedCrateContext<'a, 'tcx> {\n     }\n }\n \n-impl<'a, 'tcx> LayoutOf<Ty<'tcx>> for &'a CrateContext<'a, 'tcx> {\n-    type TyLayout = TyLayout<'tcx>;\n-\n-\n-    fn layout_of(self, ty: Ty<'tcx>) -> Self::TyLayout {\n-        self.shared.layout_of(ty)\n-    }\n-}\n-\n /// Declare any llvm intrinsics that you might need\n fn declare_intrinsic(ccx: &CrateContext, key: &str) -> Option<ValueRef> {\n     macro_rules! ifn {"}, {"sha": "7cd65b8708ee009efbd24a7510bffb0816dc81d7", "filename": "src/librustc_trans/debuginfo/metadata.rs", "status": "modified", "additions": 12, "deletions": 14, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/d0d13204a6587ab1e1db6d449b7ebb9846095f21/src%2Flibrustc_trans%2Fdebuginfo%2Fmetadata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d0d13204a6587ab1e1db6d449b7ebb9846095f21/src%2Flibrustc_trans%2Fdebuginfo%2Fmetadata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fdebuginfo%2Fmetadata.rs?ref=d0d13204a6587ab1e1db6d449b7ebb9846095f21", "patch": "@@ -18,7 +18,6 @@ use super::namespace::mangled_name_of_item;\n use super::type_names::compute_debuginfo_type_name;\n use super::{CrateDebugContext};\n use abi;\n-use context::SharedCrateContext;\n \n use llvm::{self, ValueRef};\n use llvm::debuginfo::{DIType, DIFile, DIScope, DIDescriptor,\n@@ -31,9 +30,9 @@ use rustc::ty::util::TypeIdHasher;\n use rustc::ich::Fingerprint;\n use rustc::ty::Instance;\n use common::CrateContext;\n-use rustc::ty::{self, AdtKind, Ty};\n+use rustc::ty::{self, AdtKind, Ty, TyCtxt};\n use rustc::ty::layout::{self, Align, LayoutOf, Size, TyLayout};\n-use rustc::session::{Session, config};\n+use rustc::session::config;\n use rustc::util::nodemap::FxHashMap;\n use rustc::util::common::path2cstr;\n \n@@ -785,21 +784,20 @@ fn pointer_type_metadata<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n     }\n }\n \n-pub fn compile_unit_metadata(scc: &SharedCrateContext,\n+pub fn compile_unit_metadata(tcx: TyCtxt,\n                              codegen_unit_name: &str,\n-                             debug_context: &CrateDebugContext,\n-                             sess: &Session)\n+                             debug_context: &CrateDebugContext)\n                              -> DIDescriptor {\n-    let mut name_in_debuginfo = match sess.local_crate_source_file {\n+    let mut name_in_debuginfo = match tcx.sess.local_crate_source_file {\n         Some(ref path) => path.clone(),\n-        None => PathBuf::from(&*scc.tcx().crate_name(LOCAL_CRATE).as_str()),\n+        None => PathBuf::from(&*tcx.crate_name(LOCAL_CRATE).as_str()),\n     };\n \n     // The OSX linker has an idiosyncrasy where it will ignore some debuginfo\n     // if multiple object files with the same DW_AT_name are linked together.\n     // As a workaround we generate unique names for each object file. Those do\n     // not correspond to an actual source file but that should be harmless.\n-    if scc.sess().target.target.options.is_like_osx {\n+    if tcx.sess.target.target.options.is_like_osx {\n         name_in_debuginfo.push(\"@\");\n         name_in_debuginfo.push(codegen_unit_name);\n     }\n@@ -811,7 +809,7 @@ pub fn compile_unit_metadata(scc: &SharedCrateContext,\n \n     let name_in_debuginfo = name_in_debuginfo.to_string_lossy().into_owned();\n     let name_in_debuginfo = CString::new(name_in_debuginfo).unwrap();\n-    let work_dir = CString::new(&sess.working_dir.0.to_string_lossy()[..]).unwrap();\n+    let work_dir = CString::new(&tcx.sess.working_dir.0.to_string_lossy()[..]).unwrap();\n     let producer = CString::new(producer).unwrap();\n     let flags = \"\\0\";\n     let split_name = \"\\0\";\n@@ -825,20 +823,20 @@ pub fn compile_unit_metadata(scc: &SharedCrateContext,\n             DW_LANG_RUST,\n             file_metadata,\n             producer.as_ptr(),\n-            sess.opts.optimize != config::OptLevel::No,\n+            tcx.sess.opts.optimize != config::OptLevel::No,\n             flags.as_ptr() as *const _,\n             0,\n             split_name.as_ptr() as *const _);\n \n-        if sess.opts.debugging_opts.profile {\n+        if tcx.sess.opts.debugging_opts.profile {\n             let cu_desc_metadata = llvm::LLVMRustMetadataAsValue(debug_context.llcontext,\n                                                                  unit_metadata);\n \n             let gcov_cu_info = [\n                 path_to_mdstring(debug_context.llcontext,\n-                                 &scc.tcx().output_filenames(LOCAL_CRATE).with_extension(\"gcno\")),\n+                                 &tcx.output_filenames(LOCAL_CRATE).with_extension(\"gcno\")),\n                 path_to_mdstring(debug_context.llcontext,\n-                                 &scc.tcx().output_filenames(LOCAL_CRATE).with_extension(\"gcda\")),\n+                                 &tcx.output_filenames(LOCAL_CRATE).with_extension(\"gcda\")),\n                 cu_desc_metadata,\n             ];\n             let gcov_metadata = llvm::LLVMMDNodeInContext(debug_context.llcontext,"}, {"sha": "d636aa74bf6a6f8f2dd1cdf3e9e006ebaefe5f45", "filename": "src/librustc_trans/glue.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d0d13204a6587ab1e1db6d449b7ebb9846095f21/src%2Flibrustc_trans%2Fglue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d0d13204a6587ab1e1db6d449b7ebb9846095f21/src%2Flibrustc_trans%2Fglue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fglue.rs?ref=d0d13204a6587ab1e1db6d449b7ebb9846095f21", "patch": "@@ -27,7 +27,7 @@ pub fn size_and_align_of_dst<'a, 'tcx>(bcx: &Builder<'a, 'tcx>, t: Ty<'tcx>, inf\n                                        -> (ValueRef, ValueRef) {\n     debug!(\"calculate size of DST: {}; with lost info: {:?}\",\n            t, Value(info));\n-    if bcx.ccx.shared().type_is_sized(t) {\n+    if bcx.ccx.type_is_sized(t) {\n         let (size, align) = bcx.ccx.size_and_align_of(t);\n         debug!(\"size_and_align_of_dst t={} info={:?} size: {:?} align: {:?}\",\n                t, Value(info), size, align);"}, {"sha": "3687eec656eafa254b933b33565471747a7bf261", "filename": "src/librustc_trans/intrinsic.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d0d13204a6587ab1e1db6d449b7ebb9846095f21/src%2Flibrustc_trans%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d0d13204a6587ab1e1db6d449b7ebb9846095f21/src%2Flibrustc_trans%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fintrinsic.rs?ref=d0d13204a6587ab1e1db6d449b7ebb9846095f21", "patch": "@@ -196,7 +196,7 @@ pub fn trans_intrinsic_call<'a, 'tcx>(bcx: &Builder<'a, 'tcx>,\n         \"needs_drop\" => {\n             let tp_ty = substs.type_at(0);\n \n-            C_bool(ccx, bcx.ccx.shared().type_needs_drop(tp_ty))\n+            C_bool(ccx, bcx.ccx.type_needs_drop(tp_ty))\n         }\n         \"offset\" => {\n             let ptr = args[0].immediate();\n@@ -620,7 +620,7 @@ pub fn trans_intrinsic_call<'a, 'tcx>(bcx: &Builder<'a, 'tcx>,\n                         // This assumes the type is \"simple\", i.e. no\n                         // destructors, and the contents are SIMD\n                         // etc.\n-                        assert!(!bcx.ccx.shared().type_needs_drop(arg.layout.ty));\n+                        assert!(!bcx.ccx.type_needs_drop(arg.layout.ty));\n                         let (ptr, align) = match arg.val {\n                             OperandValue::Ref(ptr, align) => (ptr, align),\n                             _ => bug!()"}, {"sha": "7e9003b20ec0acc51a5fc9d5db5a1d43181035f0", "filename": "src/librustc_trans/mir/analyze.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d0d13204a6587ab1e1db6d449b7ebb9846095f21/src%2Flibrustc_trans%2Fmir%2Fanalyze.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d0d13204a6587ab1e1db6d449b7ebb9846095f21/src%2Flibrustc_trans%2Fmir%2Fanalyze.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Fanalyze.rs?ref=d0d13204a6587ab1e1db6d449b7ebb9846095f21", "patch": "@@ -204,7 +204,7 @@ impl<'mir, 'a, 'tcx> Visitor<'tcx> for LocalAnalyzer<'mir, 'a, 'tcx> {\n                 let ty = self.cx.monomorphize(&ty.to_ty(self.cx.ccx.tcx()));\n \n                 // Only need the place if we're actually dropping it.\n-                if self.cx.ccx.shared().type_needs_drop(ty) {\n+                if self.cx.ccx.type_needs_drop(ty) {\n                     self.mark_as_memory(index);\n                 }\n             }"}, {"sha": "97065ff99a503e9d4f499774671479c44d1a78c2", "filename": "src/librustc_trans/mir/constant.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/d0d13204a6587ab1e1db6d449b7ebb9846095f21/src%2Flibrustc_trans%2Fmir%2Fconstant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d0d13204a6587ab1e1db6d449b7ebb9846095f21/src%2Flibrustc_trans%2Fmir%2Fconstant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Fconstant.rs?ref=d0d13204a6587ab1e1db6d449b7ebb9846095f21", "patch": "@@ -528,7 +528,7 @@ impl<'a, 'tcx> MirConstContext<'a, 'tcx> {\n                     .projection_ty(tcx, &projection.elem);\n                 let base = tr_base.to_const(span);\n                 let projected_ty = self.monomorphize(&projected_ty).to_ty(tcx);\n-                let has_metadata = self.ccx.shared().type_has_metadata(projected_ty);\n+                let has_metadata = self.ccx.type_has_metadata(projected_ty);\n \n                 let (projected, llextra) = match projection.elem {\n                     mir::ProjectionElem::Deref => {\n@@ -742,7 +742,7 @@ impl<'a, 'tcx> MirConstContext<'a, 'tcx> {\n                     mir::CastKind::Unsize => {\n                         let pointee_ty = operand.ty.builtin_deref(true, ty::NoPreference)\n                             .expect(\"consts: unsizing got non-pointer type\").ty;\n-                        let (base, old_info) = if !self.ccx.shared().type_is_sized(pointee_ty) {\n+                        let (base, old_info) = if !self.ccx.type_is_sized(pointee_ty) {\n                             // Normally, the source is a thin pointer and we are\n                             // adding extra info to make a fat pointer. The exception\n                             // is when we are upcasting an existing object fat pointer\n@@ -857,7 +857,7 @@ impl<'a, 'tcx> MirConstContext<'a, 'tcx> {\n                 let base = match tr_place.base {\n                     Base::Value(llval) => {\n                         // FIXME: may be wrong for &*(&simd_vec as &fmt::Debug)\n-                        let align = if self.ccx.shared().type_is_sized(ty) {\n+                        let align = if self.ccx.type_is_sized(ty) {\n                             self.ccx.align_of(ty)\n                         } else {\n                             self.ccx.tcx().data_layout.pointer_align\n@@ -872,7 +872,7 @@ impl<'a, 'tcx> MirConstContext<'a, 'tcx> {\n                     Base::Static(llval) => llval\n                 };\n \n-                let ptr = if self.ccx.shared().type_is_sized(ty) {\n+                let ptr = if self.ccx.type_is_sized(ty) {\n                     base\n                 } else {\n                     C_fat_ptr(self.ccx, base, tr_place.llextra)\n@@ -941,7 +941,7 @@ impl<'a, 'tcx> MirConstContext<'a, 'tcx> {\n             }\n \n             mir::Rvalue::NullaryOp(mir::NullOp::SizeOf, ty) => {\n-                assert!(self.ccx.shared().type_is_sized(ty));\n+                assert!(self.ccx.type_is_sized(ty));\n                 let llval = C_usize(self.ccx, self.ccx.size_of(ty).bytes());\n                 Const::new(llval, tcx.types.usize)\n             }"}, {"sha": "144ce3d4b76a7efca6b85fbd68e0ad8f1fc649a6", "filename": "src/librustc_trans/mir/place.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d0d13204a6587ab1e1db6d449b7ebb9846095f21/src%2Flibrustc_trans%2Fmir%2Fplace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d0d13204a6587ab1e1db6d449b7ebb9846095f21/src%2Flibrustc_trans%2Fmir%2Fplace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Fplace.rs?ref=d0d13204a6587ab1e1db6d449b7ebb9846095f21", "patch": "@@ -178,7 +178,7 @@ impl<'a, 'tcx> PlaceRef<'tcx> {\n             PlaceRef {\n                 // HACK(eddyb) have to bitcast pointers until LLVM removes pointee types.\n                 llval: bcx.pointercast(llval, field.llvm_type(ccx).ptr_to()),\n-                llextra: if ccx.shared().type_has_metadata(field.ty) {\n+                llextra: if ccx.type_has_metadata(field.ty) {\n                     self.llextra\n                 } else {\n                     ptr::null_mut()"}, {"sha": "620f9258f2f0a47f0e8e7d6e32ad34ae72bb2906", "filename": "src/librustc_trans/mir/rvalue.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d0d13204a6587ab1e1db6d449b7ebb9846095f21/src%2Flibrustc_trans%2Fmir%2Frvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d0d13204a6587ab1e1db6d449b7ebb9846095f21/src%2Flibrustc_trans%2Fmir%2Frvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Frvalue.rs?ref=d0d13204a6587ab1e1db6d449b7ebb9846095f21", "patch": "@@ -341,7 +341,7 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n \n                 // Note: places are indirect, so storing the `llval` into the\n                 // destination effectively creates a reference.\n-                let val = if !bcx.ccx.shared().type_has_metadata(ty) {\n+                let val = if !bcx.ccx.type_has_metadata(ty) {\n                     OperandValue::Immediate(tr_place.llval)\n                 } else {\n                     OperandValue::Pair(tr_place.llval, tr_place.llextra)\n@@ -435,7 +435,7 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n             }\n \n             mir::Rvalue::NullaryOp(mir::NullOp::SizeOf, ty) => {\n-                assert!(bcx.ccx.shared().type_is_sized(ty));\n+                assert!(bcx.ccx.type_is_sized(ty));\n                 let val = C_usize(bcx.ccx, bcx.ccx.size_of(ty).bytes());\n                 let tcx = bcx.tcx();\n                 (bcx, OperandRef {"}, {"sha": "9ab801baf30132f10ec7cfc0ab756229f40da88f", "filename": "src/librustc_trans/type_of.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d0d13204a6587ab1e1db6d449b7ebb9846095f21/src%2Flibrustc_trans%2Ftype_of.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d0d13204a6587ab1e1db6d449b7ebb9846095f21/src%2Flibrustc_trans%2Ftype_of.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftype_of.rs?ref=d0d13204a6587ab1e1db6d449b7ebb9846095f21", "patch": "@@ -417,14 +417,14 @@ impl<'tcx> LayoutLlvmExt<'tcx> for TyLayout<'tcx> {\n                 let (size, align) = ccx.size_and_align_of(mt.ty);\n \n                 let kind = match mt.mutbl {\n-                    hir::MutImmutable => if ccx.shared().type_is_freeze(mt.ty) {\n+                    hir::MutImmutable => if ccx.type_is_freeze(mt.ty) {\n                         PointerKind::Frozen\n                     } else {\n                         PointerKind::Shared\n                     },\n                     hir::MutMutable => {\n-                        if ccx.shared().tcx().sess.opts.debugging_opts.mutable_noalias ||\n-                           ccx.shared().tcx().sess.panic_strategy() == PanicStrategy::Abort {\n+                        if ccx.tcx().sess.opts.debugging_opts.mutable_noalias ||\n+                           ccx.tcx().sess.panic_strategy() == PanicStrategy::Abort {\n                             PointerKind::UniqueBorrowed\n                         } else {\n                             PointerKind::Shared"}]}