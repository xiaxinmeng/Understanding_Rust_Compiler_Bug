{"sha": "3a38554f86e5e1b41b111ed8ccc688e84a9d5ae4", "node_id": "MDY6Q29tbWl0NzI0NzEyOjNhMzg1NTRmODZlNWUxYjQxYjExMWVkOGNjYzY4OGU4NGE5ZDVhZTQ=", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2020-10-14T20:52:41Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2020-10-14T20:52:41Z"}, "message": "Merge #6231\n\n6231: Factor macro_rules and format-string highlighting out into submodules r=Veykril a=Veykril\n\nThis moves `format`-like macro string highlighting and macro_rules highlight skipping out of the main module.\n\nCo-authored-by: Lukas Wirth <lukastw97@gmail.com>", "tree": {"sha": "5cdd20f9717015f4f6601ee0ff06222283a9c721", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5cdd20f9717015f4f6601ee0ff06222283a9c721"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3a38554f86e5e1b41b111ed8ccc688e84a9d5ae4", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJfh2UZCRBK7hj4Ov3rIwAAdHIIAIXArylUUmbGI4yXJXGeZsYy\n80IEU8WBWLZX+88q9M6mPbLJxpaatAQLvVsGosWmH/UTtxzURjP4uD3DQg662CvW\n9+ktkjV/FpNs/HhttiNZSUNk4vYZJ/C0XEEpQJZ7Bq7jbeNVshYQPgwuEwLsc7R1\nBxMY5hOPHE+GSHmtYjOx/UDGlLdDARz8xrLeHFeHt53dQ+T4Elx1sLEmaPCGJRnT\nbYv0Cd1kNNDJ/CitjemBB1EpeNj1dree6D6TU5RNVkdIOMz34brwiftYpIeULmjG\ns007s5db6+tqqfo/exQRWiTZZxEGxtJc6XsFaGHihtgvGugzgLy/kEeDI4T5cC8=\n=XLXf\n-----END PGP SIGNATURE-----\n", "payload": "tree 5cdd20f9717015f4f6601ee0ff06222283a9c721\nparent b2205bd1079c2f517a8a504eac6bafc713eb6fef\nparent bab29e65eb87f4765fb22d58bff723780980eeb6\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1602708761 +0000\ncommitter GitHub <noreply@github.com> 1602708761 +0000\n\nMerge #6231\n\n6231: Factor macro_rules and format-string highlighting out into submodules r=Veykril a=Veykril\n\nThis moves `format`-like macro string highlighting and macro_rules highlight skipping out of the main module.\n\nCo-authored-by: Lukas Wirth <lukastw97@gmail.com>\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3a38554f86e5e1b41b111ed8ccc688e84a9d5ae4", "html_url": "https://github.com/rust-lang/rust/commit/3a38554f86e5e1b41b111ed8ccc688e84a9d5ae4", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3a38554f86e5e1b41b111ed8ccc688e84a9d5ae4/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b2205bd1079c2f517a8a504eac6bafc713eb6fef", "url": "https://api.github.com/repos/rust-lang/rust/commits/b2205bd1079c2f517a8a504eac6bafc713eb6fef", "html_url": "https://github.com/rust-lang/rust/commit/b2205bd1079c2f517a8a504eac6bafc713eb6fef"}, {"sha": "bab29e65eb87f4765fb22d58bff723780980eeb6", "url": "https://api.github.com/repos/rust-lang/rust/commits/bab29e65eb87f4765fb22d58bff723780980eeb6", "html_url": "https://github.com/rust-lang/rust/commit/bab29e65eb87f4765fb22d58bff723780980eeb6"}], "stats": {"total": 421, "additions": 231, "deletions": 190}, "files": [{"sha": "527888306be884423ba3307bcc54d491e84aee04", "filename": "crates/ide/src/syntax_highlighting.rs", "status": "modified", "additions": 24, "deletions": 190, "changes": 214, "blob_url": "https://github.com/rust-lang/rust/blob/3a38554f86e5e1b41b111ed8ccc688e84a9d5ae4/crates%2Fide%2Fsrc%2Fsyntax_highlighting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3a38554f86e5e1b41b111ed8ccc688e84a9d5ae4/crates%2Fide%2Fsrc%2Fsyntax_highlighting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fsyntax_highlighting.rs?ref=3a38554f86e5e1b41b111ed8ccc688e84a9d5ae4", "patch": "@@ -1,6 +1,8 @@\n-mod tags;\n+mod format;\n mod html;\n mod injection;\n+mod macro_rules;\n+mod tags;\n #[cfg(test)]\n mod tests;\n \n@@ -17,9 +19,11 @@ use syntax::{\n     SyntaxNode, SyntaxToken, TextRange, WalkEvent, T,\n };\n \n-use crate::FileId;\n+use crate::{\n+    syntax_highlighting::{format::FormatStringHighlighter, macro_rules::MacroRulesHighlighter},\n+    FileId,\n+};\n \n-use ast::FormatSpecifier;\n pub(crate) use html::highlight_as_html;\n pub use tags::{Highlight, HighlightModifier, HighlightModifiers, HighlightTag};\n \n@@ -68,8 +72,9 @@ pub(crate) fn highlight(\n     // When we leave a node, the we use it to flatten the highlighted ranges.\n     let mut stack = HighlightedRangeStack::new();\n \n-    let mut current_macro_call: Option<(ast::MacroCall, Option<MacroMatcherParseState>)> = None;\n-    let mut format_string: Option<SyntaxElement> = None;\n+    let mut current_macro_call: Option<ast::MacroCall> = None;\n+    let mut format_string_highlighter = FormatStringHighlighter::default();\n+    let mut macro_rules_highlighter = MacroRulesHighlighter::default();\n \n     // Walk all nodes, keeping track of whether we are inside a macro or not.\n     // If in macro, expand it first and highlight the expanded code.\n@@ -99,9 +104,8 @@ pub(crate) fn highlight(\n                         binding_hash: None,\n                     });\n                 }\n-                let mut is_macro_rules = None;\n                 if let Some(name) = mc.is_macro_rules() {\n-                    is_macro_rules = Some(MacroMatcherParseState::new());\n+                    macro_rules_highlighter.init();\n                     if let Some((highlight, binding_hash)) = highlight_element(\n                         &sema,\n                         &mut bindings_shadow_count,\n@@ -115,13 +119,14 @@ pub(crate) fn highlight(\n                         });\n                     }\n                 }\n-                current_macro_call = Some((mc.clone(), is_macro_rules));\n+                current_macro_call = Some(mc.clone());\n                 continue;\n             }\n             WalkEvent::Leave(Some(mc)) => {\n-                assert!(current_macro_call.map(|it| it.0) == Some(mc));\n+                assert!(current_macro_call == Some(mc));\n                 current_macro_call = None;\n-                format_string = None;\n+                format_string_highlighter = FormatStringHighlighter::default();\n+                macro_rules_highlighter = MacroRulesHighlighter::default();\n             }\n             _ => (),\n         }\n@@ -148,20 +153,6 @@ pub(crate) fn highlight(\n             WalkEvent::Leave(_) => continue,\n         };\n \n-        // check if in matcher part of a macro_rules rule\n-        if let Some((_, Some(ref mut state))) = current_macro_call {\n-            if let Some(tok) = element.as_token() {\n-                if matches!(\n-                    update_macro_rules_state(tok, state),\n-                    RuleState::Matcher | RuleState::Expander\n-                ) {\n-                    if skip_metavariables(element.clone()) {\n-                        continue;\n-                    }\n-                }\n-            }\n-        }\n-\n         let range = element.text_range();\n \n         let element_to_highlight = if current_macro_call.is_some() && element.kind() != COMMENT {\n@@ -173,29 +164,9 @@ pub(crate) fn highlight(\n             let token = sema.descend_into_macros(token.clone());\n             let parent = token.parent();\n \n-            // Check if macro takes a format string and remember it for highlighting later.\n-            // The macros that accept a format string expand to a compiler builtin macros\n-            // `format_args` and `format_args_nl`.\n-            if let Some(name) = parent\n-                .parent()\n-                .and_then(ast::MacroCall::cast)\n-                .and_then(|mc| mc.path())\n-                .and_then(|p| p.segment())\n-                .and_then(|s| s.name_ref())\n-            {\n-                match name.text().as_str() {\n-                    \"format_args\" | \"format_args_nl\" => {\n-                        format_string = parent\n-                            .children_with_tokens()\n-                            .filter(|t| t.kind() != WHITESPACE)\n-                            .nth(1)\n-                            .filter(|e| {\n-                                ast::String::can_cast(e.kind())\n-                                    || ast::RawString::can_cast(e.kind())\n-                            })\n-                    }\n-                    _ => {}\n-                }\n+            format_string_highlighter.check_for_format_string(&parent);\n+            if let Some(tok) = element.as_token() {\n+                macro_rules_highlighter.advance(tok);\n             }\n \n             // We only care Name and Name_ref\n@@ -214,31 +185,20 @@ pub(crate) fn highlight(\n             }\n         }\n \n-        let is_format_string = format_string.as_ref() == Some(&element_to_highlight);\n-\n         if let Some((highlight, binding_hash)) = highlight_element(\n             &sema,\n             &mut bindings_shadow_count,\n             syntactic_name_ref_highlighting,\n             element_to_highlight.clone(),\n         ) {\n-            stack.add(HighlightedRange { range, highlight, binding_hash });\n+            if macro_rules_highlighter.highlight(element_to_highlight.clone()).is_none() {\n+                stack.add(HighlightedRange { range, highlight, binding_hash });\n+            }\n+\n             if let Some(string) =\n                 element_to_highlight.as_token().cloned().and_then(ast::String::cast)\n             {\n-                if is_format_string {\n-                    stack.push();\n-                    string.lex_format_specifier(|piece_range, kind| {\n-                        if let Some(highlight) = highlight_format_specifier(kind) {\n-                            stack.add(HighlightedRange {\n-                                range: piece_range + range.start(),\n-                                highlight: highlight.into(),\n-                                binding_hash: None,\n-                            });\n-                        }\n-                    });\n-                    stack.pop();\n-                }\n+                format_string_highlighter.highlight_format_string(&mut stack, &string, range);\n                 // Highlight escape sequences\n                 if let Some(char_ranges) = string.char_ranges() {\n                     stack.push();\n@@ -256,19 +216,7 @@ pub(crate) fn highlight(\n             } else if let Some(string) =\n                 element_to_highlight.as_token().cloned().and_then(ast::RawString::cast)\n             {\n-                if is_format_string {\n-                    stack.push();\n-                    string.lex_format_specifier(|piece_range, kind| {\n-                        if let Some(highlight) = highlight_format_specifier(kind) {\n-                            stack.add(HighlightedRange {\n-                                range: piece_range + range.start(),\n-                                highlight: highlight.into(),\n-                                binding_hash: None,\n-                            });\n-                        }\n-                    });\n-                    stack.pop();\n-                }\n+                format_string_highlighter.highlight_format_string(&mut stack, &string, range);\n             }\n         }\n     }\n@@ -436,24 +384,6 @@ impl HighlightedRangeStack {\n     }\n }\n \n-fn highlight_format_specifier(kind: FormatSpecifier) -> Option<HighlightTag> {\n-    Some(match kind {\n-        FormatSpecifier::Open\n-        | FormatSpecifier::Close\n-        | FormatSpecifier::Colon\n-        | FormatSpecifier::Fill\n-        | FormatSpecifier::Align\n-        | FormatSpecifier::Sign\n-        | FormatSpecifier::NumberSign\n-        | FormatSpecifier::DollarSign\n-        | FormatSpecifier::Dot\n-        | FormatSpecifier::Asterisk\n-        | FormatSpecifier::QuestionMark => HighlightTag::FormatSpecifier,\n-        FormatSpecifier::Integer | FormatSpecifier::Zero => HighlightTag::NumericLiteral,\n-        FormatSpecifier::Identifier => HighlightTag::Local,\n-    })\n-}\n-\n fn macro_call_range(macro_call: &ast::MacroCall) -> Option<TextRange> {\n     let path = macro_call.path()?;\n     let name_ref = path.segment()?.name_ref()?;\n@@ -934,99 +864,3 @@ fn highlight_name_ref_by_syntax(name: ast::NameRef, sema: &Semantics<RootDatabas\n         _ => default.into(),\n     }\n }\n-\n-struct MacroMatcherParseState {\n-    /// Opening and corresponding closing bracket of the matcher or expander of the current rule\n-    paren_ty: Option<(SyntaxKind, SyntaxKind)>,\n-    paren_level: usize,\n-    rule_state: RuleState,\n-    /// Whether we are inside the outer `{` `}` macro block that holds the rules\n-    in_invoc_body: bool,\n-}\n-\n-impl MacroMatcherParseState {\n-    fn new() -> Self {\n-        MacroMatcherParseState {\n-            paren_ty: None,\n-            paren_level: 0,\n-            in_invoc_body: false,\n-            rule_state: RuleState::None,\n-        }\n-    }\n-}\n-\n-#[derive(Copy, Clone, PartialEq)]\n-enum RuleState {\n-    Matcher,\n-    Expander,\n-    Between,\n-    None,\n-}\n-\n-impl RuleState {\n-    fn transition(&mut self) {\n-        *self = match self {\n-            RuleState::Matcher => RuleState::Between,\n-            RuleState::Expander => RuleState::None,\n-            RuleState::Between => RuleState::Expander,\n-            RuleState::None => RuleState::Matcher,\n-        };\n-    }\n-}\n-\n-fn update_macro_rules_state(tok: &SyntaxToken, state: &mut MacroMatcherParseState) -> RuleState {\n-    if !state.in_invoc_body {\n-        if tok.kind() == T!['{'] {\n-            state.in_invoc_body = true;\n-        }\n-        return state.rule_state;\n-    }\n-\n-    match state.paren_ty {\n-        Some((open, close)) => {\n-            if tok.kind() == open {\n-                state.paren_level += 1;\n-            } else if tok.kind() == close {\n-                state.paren_level -= 1;\n-                if state.paren_level == 0 {\n-                    let res = state.rule_state;\n-                    state.rule_state.transition();\n-                    state.paren_ty = None;\n-                    return res;\n-                }\n-            }\n-        }\n-        None => {\n-            match tok.kind() {\n-                T!['('] => {\n-                    state.paren_ty = Some((T!['('], T![')']));\n-                }\n-                T!['{'] => {\n-                    state.paren_ty = Some((T!['{'], T!['}']));\n-                }\n-                T!['['] => {\n-                    state.paren_ty = Some((T!['['], T![']']));\n-                }\n-                _ => (),\n-            }\n-            if state.paren_ty.is_some() {\n-                state.paren_level = 1;\n-                state.rule_state.transition();\n-            }\n-        }\n-    }\n-    state.rule_state\n-}\n-\n-fn skip_metavariables(element: SyntaxElement) -> bool {\n-    let tok = match element.as_token() {\n-        Some(tok) => tok,\n-        None => return false,\n-    };\n-    let is_fragment = || tok.prev_token().map(|tok| tok.kind()) == Some(T![$]);\n-    match tok.kind() {\n-        IDENT if is_fragment() => true,\n-        kind if kind.is_keyword() && is_fragment() => true,\n-        _ => false,\n-    }\n-}"}, {"sha": "71bde24f08929c04f4603acf6c920e0cb5167946", "filename": "crates/ide/src/syntax_highlighting/format.rs", "status": "added", "additions": 78, "deletions": 0, "changes": 78, "blob_url": "https://github.com/rust-lang/rust/blob/3a38554f86e5e1b41b111ed8ccc688e84a9d5ae4/crates%2Fide%2Fsrc%2Fsyntax_highlighting%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3a38554f86e5e1b41b111ed8ccc688e84a9d5ae4/crates%2Fide%2Fsrc%2Fsyntax_highlighting%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fsyntax_highlighting%2Fformat.rs?ref=3a38554f86e5e1b41b111ed8ccc688e84a9d5ae4", "patch": "@@ -0,0 +1,78 @@\n+//! Syntax highlighting for format macro strings.\n+use syntax::{\n+    ast::{self, FormatSpecifier, HasFormatSpecifier},\n+    AstNode, AstToken, SyntaxElement, SyntaxKind, SyntaxNode, TextRange,\n+};\n+\n+use crate::{syntax_highlighting::HighlightedRangeStack, HighlightTag, HighlightedRange};\n+\n+#[derive(Default)]\n+pub(super) struct FormatStringHighlighter {\n+    format_string: Option<SyntaxElement>,\n+}\n+\n+impl FormatStringHighlighter {\n+    pub(super) fn check_for_format_string(&mut self, parent: &SyntaxNode) {\n+        // Check if macro takes a format string and remember it for highlighting later.\n+        // The macros that accept a format string expand to a compiler builtin macros\n+        // `format_args` and `format_args_nl`.\n+        if let Some(name) = parent\n+            .parent()\n+            .and_then(ast::MacroCall::cast)\n+            .and_then(|mc| mc.path())\n+            .and_then(|p| p.segment())\n+            .and_then(|s| s.name_ref())\n+        {\n+            match name.text().as_str() {\n+                \"format_args\" | \"format_args_nl\" => {\n+                    self.format_string = parent\n+                        .children_with_tokens()\n+                        .filter(|t| t.kind() != SyntaxKind::WHITESPACE)\n+                        .nth(1)\n+                        .filter(|e| {\n+                            ast::String::can_cast(e.kind()) || ast::RawString::can_cast(e.kind())\n+                        })\n+                }\n+                _ => {}\n+            }\n+        }\n+    }\n+    pub(super) fn highlight_format_string(\n+        &self,\n+        range_stack: &mut HighlightedRangeStack,\n+        string: &impl HasFormatSpecifier,\n+        range: TextRange,\n+    ) {\n+        if self.format_string.as_ref() == Some(&SyntaxElement::from(string.syntax().clone())) {\n+            range_stack.push();\n+            string.lex_format_specifier(|piece_range, kind| {\n+                if let Some(highlight) = highlight_format_specifier(kind) {\n+                    range_stack.add(HighlightedRange {\n+                        range: piece_range + range.start(),\n+                        highlight: highlight.into(),\n+                        binding_hash: None,\n+                    });\n+                }\n+            });\n+            range_stack.pop();\n+        }\n+    }\n+}\n+\n+fn highlight_format_specifier(kind: FormatSpecifier) -> Option<HighlightTag> {\n+    Some(match kind {\n+        FormatSpecifier::Open\n+        | FormatSpecifier::Close\n+        | FormatSpecifier::Colon\n+        | FormatSpecifier::Fill\n+        | FormatSpecifier::Align\n+        | FormatSpecifier::Sign\n+        | FormatSpecifier::NumberSign\n+        | FormatSpecifier::DollarSign\n+        | FormatSpecifier::Dot\n+        | FormatSpecifier::Asterisk\n+        | FormatSpecifier::QuestionMark => HighlightTag::FormatSpecifier,\n+        FormatSpecifier::Integer | FormatSpecifier::Zero => HighlightTag::NumericLiteral,\n+        FormatSpecifier::Identifier => HighlightTag::Local,\n+    })\n+}"}, {"sha": "4462af47ed7df3f172401b65495f58be2fc3ebe4", "filename": "crates/ide/src/syntax_highlighting/macro_rules.rs", "status": "added", "additions": 129, "deletions": 0, "changes": 129, "blob_url": "https://github.com/rust-lang/rust/blob/3a38554f86e5e1b41b111ed8ccc688e84a9d5ae4/crates%2Fide%2Fsrc%2Fsyntax_highlighting%2Fmacro_rules.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3a38554f86e5e1b41b111ed8ccc688e84a9d5ae4/crates%2Fide%2Fsrc%2Fsyntax_highlighting%2Fmacro_rules.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fsyntax_highlighting%2Fmacro_rules.rs?ref=3a38554f86e5e1b41b111ed8ccc688e84a9d5ae4", "patch": "@@ -0,0 +1,129 @@\n+//! Syntax highlighting for macro_rules!.\n+use syntax::{SyntaxElement, SyntaxKind, SyntaxToken, TextRange, T};\n+\n+use crate::{HighlightTag, HighlightedRange};\n+\n+#[derive(Default)]\n+pub(super) struct MacroRulesHighlighter {\n+    state: Option<MacroMatcherParseState>,\n+}\n+\n+impl MacroRulesHighlighter {\n+    pub(super) fn init(&mut self) {\n+        self.state = Some(MacroMatcherParseState::default());\n+    }\n+\n+    pub(super) fn advance(&mut self, token: &SyntaxToken) {\n+        if let Some(state) = self.state.as_mut() {\n+            update_macro_rules_state(state, token);\n+        }\n+    }\n+\n+    pub(super) fn highlight(&self, element: SyntaxElement) -> Option<HighlightedRange> {\n+        if let Some(state) = self.state.as_ref() {\n+            if matches!(state.rule_state, RuleState::Matcher | RuleState::Expander) {\n+                if let Some(range) = is_metavariable(element) {\n+                    return Some(HighlightedRange {\n+                        range,\n+                        highlight: HighlightTag::UnresolvedReference.into(),\n+                        binding_hash: None,\n+                    });\n+                }\n+            }\n+        }\n+        None\n+    }\n+}\n+\n+struct MacroMatcherParseState {\n+    /// Opening and corresponding closing bracket of the matcher or expander of the current rule\n+    paren_ty: Option<(SyntaxKind, SyntaxKind)>,\n+    paren_level: usize,\n+    rule_state: RuleState,\n+    /// Whether we are inside the outer `{` `}` macro block that holds the rules\n+    in_invoc_body: bool,\n+}\n+\n+impl Default for MacroMatcherParseState {\n+    fn default() -> Self {\n+        MacroMatcherParseState {\n+            paren_ty: None,\n+            paren_level: 0,\n+            in_invoc_body: false,\n+            rule_state: RuleState::None,\n+        }\n+    }\n+}\n+\n+#[derive(Copy, Clone, Debug, PartialEq)]\n+enum RuleState {\n+    Matcher,\n+    Expander,\n+    Between,\n+    None,\n+}\n+\n+impl RuleState {\n+    fn transition(&mut self) {\n+        *self = match self {\n+            RuleState::Matcher => RuleState::Between,\n+            RuleState::Expander => RuleState::None,\n+            RuleState::Between => RuleState::Expander,\n+            RuleState::None => RuleState::Matcher,\n+        };\n+    }\n+}\n+\n+fn update_macro_rules_state(state: &mut MacroMatcherParseState, tok: &SyntaxToken) {\n+    if !state.in_invoc_body {\n+        if tok.kind() == T!['{'] {\n+            state.in_invoc_body = true;\n+        }\n+        return;\n+    }\n+\n+    match state.paren_ty {\n+        Some((open, close)) => {\n+            if tok.kind() == open {\n+                state.paren_level += 1;\n+            } else if tok.kind() == close {\n+                state.paren_level -= 1;\n+                if state.paren_level == 0 {\n+                    state.rule_state.transition();\n+                    state.paren_ty = None;\n+                }\n+            }\n+        }\n+        None => {\n+            match tok.kind() {\n+                T!['('] => {\n+                    state.paren_ty = Some((T!['('], T![')']));\n+                }\n+                T!['{'] => {\n+                    state.paren_ty = Some((T!['{'], T!['}']));\n+                }\n+                T!['['] => {\n+                    state.paren_ty = Some((T!['['], T![']']));\n+                }\n+                _ => (),\n+            }\n+            if state.paren_ty.is_some() {\n+                state.paren_level = 1;\n+                state.rule_state.transition();\n+            }\n+        }\n+    }\n+}\n+\n+fn is_metavariable(element: SyntaxElement) -> Option<TextRange> {\n+    let tok = element.as_token()?;\n+    match tok.kind() {\n+        kind if kind == SyntaxKind::IDENT || kind.is_keyword() => {\n+            if let Some(_dollar) = tok.prev_token().filter(|t| t.kind() == SyntaxKind::DOLLAR) {\n+                return Some(tok.text_range());\n+            }\n+        }\n+        _ => (),\n+    };\n+    None\n+}"}]}