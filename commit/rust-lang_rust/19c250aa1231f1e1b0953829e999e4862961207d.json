{"sha": "19c250aa1231f1e1b0953829e999e4862961207d", "node_id": "C_kwDOAAsO6NoAKDE5YzI1MGFhMTIzMWYxZTFiMDk1MzgyOWU5OTllNDg2Mjk2MTIwN2Q", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-12-04T14:03:12Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-12-04T14:03:12Z"}, "message": "Auto merge of #103293 - est31:untwist_and_drop_order, r=nagisa\n\nRemove drop order twist of && and || and make them associative\n\nPreviously a short circuiting binop chain (chain of && or ||s) would drop the temporaries created by the first element after all the other elements, and otherwise follow evaluation order. So `f(1).g() && f(2).g() && f(3).g() && f(4).g()` would drop the temporaries in the order `2,3,4,1`. This made `&&` and `||` non-associative regarding drop order. In other words, adding ()'s to the expression would change drop order: `f(1).g() && (f(2).g() && f(3).g()) && f(4).g()` for example would drop in the order `3,2,4,1`.\n\nAs, except for the bool result, there is no data returned by the sub-expressions of the short circuiting binops, we can safely discard of any temporaries created by the sub-expr. Previously, code was already putting the rhs's into terminating scopes, but missed it for the lhs's.\n\nThis commit addresses this \"twist\". We now also put the lhs into a terminating scope. The drop order of the above expressions becomes `1,2,3,4`.\n\nThere might be code relying on the current order, and therefore I'd recommend doing a crater run to gauge the impact. I'd argue that such code is already quite wonky as it is one `foo() &&` addition away from breaking. ~~For the impact, I don't expect any *build* failures, as the compiler gets strictly more tolerant: shortening the lifetime of temporaries only expands the list of programs the compiler accepts as valid. There might be *runtime* failures caused by this change however.~~ Edit: both build and runtime failures are possible, e.g. see the example provided by dtolnay [below](https://github.com/rust-lang/rust/pull/103293#issuecomment-1285341113). Edit2: the crater run has finished and [results](https://github.com/rust-lang/rust/pull/103293#issuecomment-1292275203) are that there is only one build failure which is easy to fix with a +/- 1 line diff.\n\nI've included a testcase that now compiles thanks to this patch.\n\nThe breakage is also limited to drop order relative to conditionals in the && chain: that is, in code like this:\n\n```Rust\nlet hello = foo().hi() && bar().world();\nprintln!(\"hi\");\n```\n\nwe already drop the temporaries of `foo().hi()` before we reach \"hi\".\n\nI'd ideally have this PR merged before let chains are stabilized. If this PR is taking too long, I'd love to have a more restricted version of this change limited to `&&`'s in let chains: the `&&`'s of such chains are quite special anyways as they accept `let` bindings, in there the `&&` is therefore more a part of the \"if let chain\" construct than a construct of its own.\n\nFixes #103107\n\nStatus: waiting on [this accepted FCP](https://github.com/rust-lang/rust/pull/103293#issuecomment-1293411354) finishing.", "tree": {"sha": "3cc371607876b426569303c8be07de7327548d12", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3cc371607876b426569303c8be07de7327548d12"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/19c250aa1231f1e1b0953829e999e4862961207d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/19c250aa1231f1e1b0953829e999e4862961207d", "html_url": "https://github.com/rust-lang/rust/commit/19c250aa1231f1e1b0953829e999e4862961207d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/19c250aa1231f1e1b0953829e999e4862961207d/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "344889e963742e87181d3c023e2a1ea7d95f9468", "url": "https://api.github.com/repos/rust-lang/rust/commits/344889e963742e87181d3c023e2a1ea7d95f9468", "html_url": "https://github.com/rust-lang/rust/commit/344889e963742e87181d3c023e2a1ea7d95f9468"}, {"sha": "a59a2d3f6a80001b0610f03cfc7a6452b63f8935", "url": "https://api.github.com/repos/rust-lang/rust/commits/a59a2d3f6a80001b0610f03cfc7a6452b63f8935", "html_url": "https://github.com/rust-lang/rust/commit/a59a2d3f6a80001b0610f03cfc7a6452b63f8935"}], "stats": {"total": 181, "additions": 165, "deletions": 16}, "files": [{"sha": "b315ebad4686c37d4bac86575a991a744e2c27f0", "filename": "compiler/rustc_hir_analysis/src/check/region.rs", "status": "modified", "additions": 38, "deletions": 9, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/19c250aa1231f1e1b0953829e999e4862961207d/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fregion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/19c250aa1231f1e1b0953829e999e4862961207d/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fregion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fregion.rs?ref=19c250aa1231f1e1b0953829e999e4862961207d", "patch": "@@ -241,17 +241,46 @@ fn resolve_expr<'tcx>(visitor: &mut RegionResolutionVisitor<'tcx>, expr: &'tcx h\n             // scopes, meaning that temporaries cannot outlive them.\n             // This ensures fixed size stacks.\n             hir::ExprKind::Binary(\n-                source_map::Spanned { node: hir::BinOpKind::And, .. },\n-                _,\n-                ref r,\n-            )\n-            | hir::ExprKind::Binary(\n-                source_map::Spanned { node: hir::BinOpKind::Or, .. },\n-                _,\n+                source_map::Spanned { node: hir::BinOpKind::And | hir::BinOpKind::Or, .. },\n+                ref l,\n                 ref r,\n             ) => {\n-                // For shortcircuiting operators, mark the RHS as a terminating\n-                // scope since it only executes conditionally.\n+                // expr is a short circuiting operator (|| or &&). As its\n+                // functionality can't be overridden by traits, it always\n+                // processes bool sub-expressions. bools are Copy and thus we\n+                // can drop any temporaries in evaluation (read) order\n+                // (with the exception of potentially failing let expressions).\n+                // We achieve this by enclosing the operands in a terminating\n+                // scope, both the LHS and the RHS.\n+\n+                // We optimize this a little in the presence of chains.\n+                // Chains like a && b && c get lowered to AND(AND(a, b), c).\n+                // In here, b and c are RHS, while a is the only LHS operand in\n+                // that chain. This holds true for longer chains as well: the\n+                // leading operand is always the only LHS operand that is not a\n+                // binop itself. Putting a binop like AND(a, b) into a\n+                // terminating scope is not useful, thus we only put the LHS\n+                // into a terminating scope if it is not a binop.\n+\n+                let terminate_lhs = match l.kind {\n+                    // let expressions can create temporaries that live on\n+                    hir::ExprKind::Let(_) => false,\n+                    // binops already drop their temporaries, so there is no\n+                    // need to put them into a terminating scope.\n+                    // This is purely an optimization to reduce the number of\n+                    // terminating scopes.\n+                    hir::ExprKind::Binary(\n+                        source_map::Spanned {\n+                            node: hir::BinOpKind::And | hir::BinOpKind::Or, ..\n+                        },\n+                        ..,\n+                    ) => false,\n+                    // otherwise: mark it as terminating\n+                    _ => true,\n+                };\n+                if terminate_lhs {\n+                    terminating(l.hir_id.local_id);\n+                }\n \n                 // `Let` expressions (in a let-chain) shouldn't be terminating, as their temporaries\n                 // should live beyond the immediate expression"}, {"sha": "5ce1fd54a9e62027a7f53517d8fb03fb74c14207", "filename": "src/test/ui/drop/drop_order.rs", "status": "modified", "additions": 90, "deletions": 7, "changes": 97, "blob_url": "https://github.com/rust-lang/rust/blob/19c250aa1231f1e1b0953829e999e4862961207d/src%2Ftest%2Fui%2Fdrop%2Fdrop_order.rs", "raw_url": "https://github.com/rust-lang/rust/raw/19c250aa1231f1e1b0953829e999e4862961207d/src%2Ftest%2Fui%2Fdrop%2Fdrop_order.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fdrop%2Fdrop_order.rs?ref=19c250aa1231f1e1b0953829e999e4862961207d", "patch": "@@ -43,7 +43,7 @@ impl DropOrderCollector {\n         }\n \n         if {\n-            if self.option_loud_drop(7).is_some() && self.option_loud_drop(6).is_some() {\n+            if self.option_loud_drop(6).is_some() && self.option_loud_drop(7).is_some() {\n                 self.loud_drop(8);\n                 true\n             } else {\n@@ -118,17 +118,85 @@ impl DropOrderCollector {\n         }\n     }\n \n+    fn and_chain(&self) {\n+        // issue-103107\n+        if self.option_loud_drop(1).is_some() // 1\n+            && self.option_loud_drop(2).is_some() // 2\n+            && self.option_loud_drop(3).is_some() // 3\n+            && self.option_loud_drop(4).is_some() // 4\n+            && self.option_loud_drop(5).is_some() // 5\n+        {\n+            self.print(6); // 6\n+        }\n+\n+        let _ = self.option_loud_drop(7).is_some() // 1\n+            && self.option_loud_drop(8).is_some() // 2\n+            && self.option_loud_drop(9).is_some(); // 3\n+        self.print(10); // 4\n+\n+        // Test associativity\n+        if self.option_loud_drop(11).is_some() // 1\n+            && (self.option_loud_drop(12).is_some() // 2\n+            && self.option_loud_drop(13).is_some() // 3\n+            && self.option_loud_drop(14).is_some()) // 4\n+            && self.option_loud_drop(15).is_some() // 5\n+        {\n+            self.print(16); // 6\n+        }\n+    }\n+\n+    fn or_chain(&self) {\n+        // issue-103107\n+        if self.option_loud_drop(1).is_none() // 1\n+            || self.option_loud_drop(2).is_none() // 2\n+            || self.option_loud_drop(3).is_none() // 3\n+            || self.option_loud_drop(4).is_none() // 4\n+            || self.option_loud_drop(5).is_some() // 5\n+        {\n+            self.print(6); // 6\n+        }\n+\n+        let _ = self.option_loud_drop(7).is_none() // 1\n+            || self.option_loud_drop(8).is_none() // 2\n+            || self.option_loud_drop(9).is_none(); // 3\n+        self.print(10); // 4\n+\n+        // Test associativity\n+        if self.option_loud_drop(11).is_none() // 1\n+            || (self.option_loud_drop(12).is_none() // 2\n+            || self.option_loud_drop(13).is_none() // 3\n+            || self.option_loud_drop(14).is_none()) // 4\n+            || self.option_loud_drop(15).is_some() // 5\n+        {\n+            self.print(16); // 6\n+        }\n+    }\n+\n+    fn mixed_and_or_chain(&self) {\n+        // issue-103107\n+        if self.option_loud_drop(1).is_none() // 1\n+            || self.option_loud_drop(2).is_none() // 2\n+            || self.option_loud_drop(3).is_some() // 3\n+            && self.option_loud_drop(4).is_some() // 4\n+            && self.option_loud_drop(5).is_none() // 5\n+            || self.option_loud_drop(6).is_none() // 6\n+            || self.option_loud_drop(7).is_some() // 7\n+        {\n+            self.print(8); // 8\n+        }\n+    }\n+\n     fn let_chain(&self) {\n         // take the \"then\" branch\n-        if self.option_loud_drop(2).is_some() // 2\n-            && self.option_loud_drop(1).is_some() // 1\n+        if self.option_loud_drop(1).is_some() // 1\n+            && self.option_loud_drop(2).is_some() // 2\n             && let Some(_d) = self.option_loud_drop(4) { // 4\n             self.print(3); // 3\n         }\n \n         // take the \"else\" branch\n-        if self.option_loud_drop(6).is_some() // 2\n-            && self.option_loud_drop(5).is_some() // 1\n+        if self.option_loud_drop(5).is_some() // 1\n+            && self.option_loud_drop(6).is_some() // 2\n             && let None = self.option_loud_drop(8) { // 4\n             unreachable!();\n         } else {\n@@ -152,8 +220,8 @@ impl DropOrderCollector {\n             }\n \n         // let exprs last\n-        if self.option_loud_drop(20).is_some() // 2\n-            && self.option_loud_drop(19).is_some() // 1\n+        if self.option_loud_drop(19).is_some() // 1\n+            && self.option_loud_drop(20).is_some() // 2\n             && let Some(_d) = self.option_loud_drop(23) // 5\n             && let Some(_e) = self.option_loud_drop(22) { // 4\n                 self.print(21); // 3\n@@ -187,6 +255,21 @@ fn main() {\n     collector.if_();\n     collector.assert_sorted();\n \n+    println!(\"-- and chain --\");\n+    let collector = DropOrderCollector::default();\n+    collector.and_chain();\n+    collector.assert_sorted();\n+\n+    println!(\"-- or chain --\");\n+    let collector = DropOrderCollector::default();\n+    collector.or_chain();\n+    collector.assert_sorted();\n+\n+    println!(\"-- mixed and/or chain --\");\n+    let collector = DropOrderCollector::default();\n+    collector.mixed_and_or_chain();\n+    collector.assert_sorted();\n+\n     println!(\"-- if let --\");\n     let collector = DropOrderCollector::default();\n     collector.if_let();"}, {"sha": "5f447595662edd74aa749b1f5c44c73eebb139b2", "filename": "src/test/ui/drop/issue-103107.rs", "status": "added", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/19c250aa1231f1e1b0953829e999e4862961207d/src%2Ftest%2Fui%2Fdrop%2Fissue-103107.rs", "raw_url": "https://github.com/rust-lang/rust/raw/19c250aa1231f1e1b0953829e999e4862961207d/src%2Ftest%2Fui%2Fdrop%2Fissue-103107.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fdrop%2Fissue-103107.rs?ref=19c250aa1231f1e1b0953829e999e4862961207d", "patch": "@@ -0,0 +1,37 @@\n+// check-pass\n+// compile-flags: -Z validate-mir\n+\n+struct Foo<'a>(&'a mut u32);\n+\n+impl<'a> Drop for Foo<'a> {\n+    fn drop(&mut self) {\n+        *self.0 = 0;\n+    }\n+}\n+\n+fn and() {\n+    let mut foo = 0;\n+    // This used to compile also before the fix\n+    if true && *Foo(&mut foo).0 == 0 && ({ foo = 0; true}) {}\n+\n+    // This used to fail before the fix\n+    if *Foo(&mut foo).0 == 0 && ({ foo = 0; true}) {}\n+\n+    println!(\"{foo}\");\n+}\n+\n+fn or() {\n+    let mut foo = 0;\n+    // This used to compile also before the fix\n+    if false || *Foo(&mut foo).0 == 1 || ({ foo = 0; true}) {}\n+\n+    // This used to fail before the fix\n+    if *Foo(&mut foo).0 == 1 || ({ foo = 0; true}) {}\n+\n+    println!(\"{foo}\");\n+}\n+\n+fn main() {\n+    and();\n+    or();\n+}"}]}