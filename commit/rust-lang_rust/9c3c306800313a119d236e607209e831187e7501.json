{"sha": "9c3c306800313a119d236e607209e831187e7501", "node_id": "MDY6Q29tbWl0NzI0NzEyOjljM2MzMDY4MDAzMTNhMTE5ZDIzNmU2MDcyMDllODMxMTg3ZTc1MDE=", "commit": {"author": {"name": "Eduard-Mihai Burtescu", "email": "edy.burt@gmail.com", "date": "2017-02-13T23:11:24Z"}, "committer": {"name": "Eduard-Mihai Burtescu", "email": "edy.burt@gmail.com", "date": "2017-02-25T16:35:25Z"}, "message": "rustc_typeck: move the leaves (generics, trait_def, adt_def) to on-demand.", "tree": {"sha": "0902bdecb464a73f10431b1a6191a438066fb7a9", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0902bdecb464a73f10431b1a6191a438066fb7a9"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9c3c306800313a119d236e607209e831187e7501", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9c3c306800313a119d236e607209e831187e7501", "html_url": "https://github.com/rust-lang/rust/commit/9c3c306800313a119d236e607209e831187e7501", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9c3c306800313a119d236e607209e831187e7501/comments", "author": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "committer": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3146ee86723e329ccfb23c6b72594dc96d8e9497", "url": "https://api.github.com/repos/rust-lang/rust/commits/3146ee86723e329ccfb23c6b72594dc96d8e9497", "html_url": "https://github.com/rust-lang/rust/commit/3146ee86723e329ccfb23c6b72594dc96d8e9497"}], "stats": {"total": 623, "additions": 288, "deletions": 335}, "files": [{"sha": "6323f1dc0d4c4a8da2f00a60797851a88b2edbe8", "filename": "src/librustc/util/ppaux.rs", "status": "modified", "additions": 1, "deletions": 10, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/9c3c306800313a119d236e607209e831187e7501/src%2Flibrustc%2Futil%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c3c306800313a119d236e607209e831187e7501/src%2Flibrustc%2Futil%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fppaux.rs?ref=9c3c306800313a119d236e607209e831187e7501", "patch": "@@ -750,16 +750,7 @@ impl<'tcx> fmt::Display for ty::TypeVariants<'tcx> {\n             TyInfer(infer_ty) => write!(f, \"{}\", infer_ty),\n             TyError => write!(f, \"[type error]\"),\n             TyParam(ref param_ty) => write!(f, \"{}\", param_ty),\n-            TyAdt(def, substs) => {\n-                ty::tls::with(|tcx| {\n-                    if def.did.is_local() &&\n-                          !tcx.maps.ty.borrow().contains_key(&def.did) {\n-                        write!(f, \"{}<..>\", tcx.item_path_str(def.did))\n-                    } else {\n-                        parameterized(f, substs, def.did, &[])\n-                    }\n-                })\n-            }\n+            TyAdt(def, substs) => parameterized(f, substs, def.did, &[]),\n             TyDynamic(data, r) => {\n                 write!(f, \"{}\", data)?;\n                 let r = r.to_string();"}, {"sha": "96824d19b900d8809dbd0585233a95f229935722", "filename": "src/librustc_driver/driver.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/9c3c306800313a119d236e607209e831187e7501/src%2Flibrustc_driver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c3c306800313a119d236e607209e831187e7501/src%2Flibrustc_driver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Fdriver.rs?ref=9c3c306800313a119d236e607209e831187e7501", "patch": "@@ -873,6 +873,7 @@ pub fn phase_3_run_analysis_passes<'tcx, F, R>(sess: &'tcx Session,\n \n     let mut local_providers = ty::maps::Providers::default();\n     mir::mir_map::provide(&mut local_providers);\n+    typeck::provide(&mut local_providers);\n \n     let mut extern_providers = ty::maps::Providers::default();\n     cstore::provide(&mut extern_providers);"}, {"sha": "54a2c40322ea019f55df5ecd65961a29ee4212b9", "filename": "src/librustc_typeck/astconv.rs", "status": "modified", "additions": 4, "deletions": 11, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/9c3c306800313a119d236e607209e831187e7501/src%2Flibrustc_typeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c3c306800313a119d236e607209e831187e7501/src%2Flibrustc_typeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fastconv.rs?ref=9c3c306800313a119d236e607209e831187e7501", "patch": "@@ -51,16 +51,9 @@ pub trait AstConv<'gcx, 'tcx> {\n     /// A cache used for the result of `ast_ty_to_ty_cache`\n     fn ast_ty_to_ty_cache(&self) -> &RefCell<NodeMap<Ty<'tcx>>>;\n \n-    /// Returns the generic type and lifetime parameters for an item.\n-    fn get_generics(&self, id: DefId) -> &'tcx ty::Generics;\n-\n     /// Identify the type for an item, like a type alias, fn, or struct.\n     fn get_item_type(&self, span: Span, id: DefId) -> Ty<'tcx>;\n \n-    /// Returns the `TraitDef` for a given trait. This allows you to\n-    /// figure out the set of type parameters defined on the trait.\n-    fn get_trait_def(&self, id: DefId) -> &'tcx ty::TraitDef;\n-\n     /// Ensure that the super-predicates for the trait with the given\n     /// id are available and also for the transitive set of\n     /// super-predicates.\n@@ -248,7 +241,7 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n         // If the type is parameterized by this region, then replace this\n         // region with the current anon region binding (in other words,\n         // whatever & would get replaced with).\n-        let decl_generics = self.get_generics(def_id);\n+        let decl_generics = tcx.item_generics(def_id);\n         let expected_num_region_params = decl_generics.regions.len();\n         let supplied_num_region_params = lifetimes.len();\n         if expected_num_region_params != supplied_num_region_params {\n@@ -485,7 +478,7 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n         debug!(\"create_substs_for_ast_trait_ref(trait_segment={:?})\",\n                trait_segment);\n \n-        let trait_def = self.get_trait_def(trait_def_id);\n+        let trait_def = self.tcx().lookup_trait_def(trait_def_id);\n \n         match trait_segment.parameters {\n             hir::AngleBracketedParameters(_) => {\n@@ -1019,7 +1012,7 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n                 let node_id = tcx.hir.as_local_node_id(did).unwrap();\n                 let item_id = tcx.hir.get_parent_node(node_id);\n                 let item_def_id = tcx.hir.local_def_id(item_id);\n-                let generics = self.get_generics(item_def_id);\n+                let generics = tcx.item_generics(item_def_id);\n                 let index = generics.type_param_to_index[&tcx.hir.local_def_id(node_id).index];\n                 tcx.mk_param(index, tcx.hir.name(node_id))\n             }\n@@ -1186,7 +1179,7 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n                 // Create the anonymized type.\n                 if allow {\n                     let def_id = tcx.hir.local_def_id(ast_ty.id);\n-                    self.get_generics(def_id);\n+                    tcx.item_generics(def_id);\n                     let substs = Substs::identity_for_item(tcx, def_id);\n                     let ty = tcx.mk_anon(tcx.hir.local_def_id(ast_ty.id), substs);\n "}, {"sha": "c6d3af547eb020ed78d3acad6bbca5a1dccab575", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/9c3c306800313a119d236e607209e831187e7501/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c3c306800313a119d236e607209e831187e7501/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=9c3c306800313a119d236e607209e831187e7501", "patch": "@@ -1353,18 +1353,10 @@ impl<'a, 'gcx, 'tcx> AstConv<'gcx, 'tcx> for FnCtxt<'a, 'gcx, 'tcx> {\n         &self.ast_ty_to_ty_cache\n     }\n \n-    fn get_generics(&self, id: DefId) -> &'tcx ty::Generics {\n-        self.tcx().item_generics(id)\n-    }\n-\n     fn get_item_type(&self, _: Span, id: DefId) -> Ty<'tcx> {\n         self.tcx().item_type(id)\n     }\n \n-    fn get_trait_def(&self, id: DefId) -> &'tcx ty::TraitDef {\n-        self.tcx().lookup_trait_def(id)\n-    }\n-\n     fn ensure_super_predicates(&self, _: Span, _: DefId) {\n         // all super predicates are ensured during collect pass\n     }"}, {"sha": "68e42f5b27ad0fb5338ee41421b404da8c01a7a2", "filename": "src/librustc_typeck/collect.rs", "status": "modified", "additions": 277, "deletions": 306, "changes": 583, "blob_url": "https://github.com/rust-lang/rust/blob/9c3c306800313a119d236e607209e831187e7501/src%2Flibrustc_typeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c3c306800313a119d236e607209e831187e7501/src%2Flibrustc_typeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcollect.rs?ref=9c3c306800313a119d236e607209e831187e7501", "patch": "@@ -68,6 +68,7 @@ use rustc_const_eval::{ConstContext, report_const_eval_err};\n use rustc::ty::subst::Substs;\n use rustc::ty::{ToPredicate, ImplContainer, AssociatedItemContainer, TraitContainer, ReprOptions};\n use rustc::ty::{self, AdtKind, ToPolyTraitRef, Ty, TyCtxt};\n+use rustc::ty::maps::Providers;\n use rustc::ty::util::IntTypeExt;\n use rustc::dep_graph::DepNode;\n use util::common::MemoizationMap;\n@@ -95,6 +96,15 @@ pub fn collect_item_types<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>) {\n     tcx.visit_all_item_likes_in_krate(DepNode::CollectItem, &mut visitor.as_deep_visitor());\n }\n \n+pub fn provide(providers: &mut Providers) {\n+    *providers = Providers {\n+        generics,\n+        trait_def,\n+        adt_def,\n+        ..*providers\n+    };\n+}\n+\n ///////////////////////////////////////////////////////////////////////////\n \n /// Context specific to some particular item. This is what implements\n@@ -189,7 +199,7 @@ impl<'a, 'tcx> Visitor<'tcx> for CollectItemTypesVisitor<'a, 'tcx> {\n     fn visit_expr(&mut self, expr: &'tcx hir::Expr) {\n         if let hir::ExprClosure(..) = expr.node {\n             let def_id = self.tcx.hir.local_def_id(expr.id);\n-            generics_of_def_id(self.tcx, def_id);\n+            self.tcx.item_generics(def_id);\n             type_of_def_id(self.tcx, def_id);\n         }\n         intravisit::walk_expr(self, expr);\n@@ -198,7 +208,7 @@ impl<'a, 'tcx> Visitor<'tcx> for CollectItemTypesVisitor<'a, 'tcx> {\n     fn visit_ty(&mut self, ty: &'tcx hir::Ty) {\n         if let hir::TyImplTrait(..) = ty.node {\n             let def_id = self.tcx.hir.local_def_id(ty.id);\n-            generics_of_def_id(self.tcx, def_id);\n+            self.tcx.item_generics(def_id);\n         }\n         intravisit::walk_ty(self, ty);\n     }\n@@ -244,26 +254,12 @@ impl<'a, 'tcx> AstConv<'tcx, 'tcx> for ItemCtxt<'a, 'tcx> {\n         &self.tcx.ast_ty_to_ty_cache\n     }\n \n-    fn get_generics(&self, id: DefId) -> &'tcx ty::Generics {\n-        generics_of_def_id(self.tcx, id)\n-    }\n-\n     fn get_item_type(&self, span: Span, id: DefId) -> Ty<'tcx> {\n         self.tcx.cycle_check(span, ty::maps::Query::ty(id), || {\n             type_of_def_id(self.tcx, id)\n         })\n     }\n \n-    fn get_trait_def(&self, def_id: DefId) -> &'tcx ty::TraitDef {\n-        let tcx = self.tcx;\n-\n-        if let Some(trait_id) = tcx.hir.as_local_node_id(def_id) {\n-            trait_def_of_item(self.tcx, tcx.hir.expect_item(trait_id))\n-        } else {\n-            tcx.lookup_trait_def(def_id)\n-        }\n-    }\n-\n     /// Ensure that the (transitive) super predicates for\n     /// `trait_def_id` are available. This will report a cycle error\n     /// if a trait `X` (transitively) extends itself in some form.\n@@ -362,15 +358,15 @@ impl<'a, 'tcx> AstConv<'tcx, 'tcx> for ItemCtxt<'a, 'tcx> {\n         let param_id = tcx.hir.as_local_node_id(def_id).unwrap();\n         let param_owner = tcx.hir.ty_param_owner(param_id);\n         let param_owner_def_id = tcx.hir.local_def_id(param_owner);\n-        let generics = generics_of_def_id(tcx, param_owner_def_id);\n+        let generics = tcx.item_generics(param_owner_def_id);\n         let index = generics.type_param_to_index[&def_id.index];\n         let ty = tcx.mk_param(index, tcx.hir.ty_param_name(param_id));\n \n         // Don't look for bounds where the type parameter isn't in scope.\n         let parent = if item_def_id == param_owner_def_id {\n             None\n         } else {\n-            generics_of_def_id(tcx, item_def_id).parent\n+            tcx.item_generics(item_def_id).parent\n         };\n \n         let mut results = parent.map_or(vec![], |parent| {\n@@ -407,7 +403,7 @@ impl<'a, 'tcx> AstConv<'tcx, 'tcx> for ItemCtxt<'a, 'tcx> {\n                         if param_id == item_node_id {\n                             results.push(ty::TraitRef {\n                                 def_id: item_def_id,\n-                                substs: mk_item_substs(tcx, item_def_id)\n+                                substs: Substs::identity_for_item(tcx, item_def_id)\n                             }.to_predicate());\n                         }\n                         generics\n@@ -491,7 +487,7 @@ fn convert_field<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                            field: &hir::StructField,\n                            ty_f: &'tcx ty::FieldDef)\n {\n-    generics_of_def_id(tcx, ty_f.did);\n+    tcx.item_generics(ty_f.did);\n     let tt = ItemCtxt::new(tcx, ty_f.did).to_ty(&field.ty);\n     tcx.maps.ty.borrow_mut().insert(ty_f.did, tt);\n     tcx.maps.predicates.borrow_mut().insert(ty_f.did, ty::GenericPredicates {\n@@ -506,7 +502,7 @@ fn convert_method<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     let def_id = tcx.hir.local_def_id(id);\n \n     let fty = AstConv::ty_of_fn(&ItemCtxt::new(tcx, def_id), sig.unsafety, sig.abi, &sig.decl);\n-    let substs = mk_item_substs(tcx, def_id);\n+    let substs = Substs::identity_for_item(tcx, def_id);\n     let fty = tcx.mk_fn_def(def_id, substs, fty);\n     tcx.maps.ty.borrow_mut().insert(def_id, fty);\n \n@@ -597,7 +593,7 @@ fn convert_item<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, it: &hir::Item) {\n             }\n         }\n         hir::ItemEnum(ref enum_definition, _) => {\n-            generics_of_def_id(tcx, def_id);\n+            tcx.item_generics(def_id);\n             predicates_of_item(tcx, it);\n             let ty = type_of_def_id(tcx, def_id);\n             convert_enum_variant_types(tcx,\n@@ -617,7 +613,7 @@ fn convert_item<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, it: &hir::Item) {\n                                                          Some(trait_ref));\n         }\n         hir::ItemImpl(.., ref opt_trait_ref, _, _) => {\n-            generics_of_def_id(tcx, def_id);\n+            tcx.item_generics(def_id);\n             let selfty = type_of_def_id(tcx, def_id);\n \n             let trait_ref = opt_trait_ref.as_ref().map(|ast_trait_ref| {\n@@ -628,14 +624,14 @@ fn convert_item<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, it: &hir::Item) {\n             predicates_of_item(tcx, it);\n         },\n         hir::ItemTrait(..) => {\n-            generics_of_def_id(tcx, def_id);\n-            trait_def_of_item(tcx, it);\n+            tcx.item_generics(def_id);\n+            tcx.lookup_trait_def(def_id);\n             icx.ensure_super_predicates(it.span, def_id);\n             predicates_of_item(tcx, it);\n         },\n         hir::ItemStruct(ref struct_def, _) |\n         hir::ItemUnion(ref struct_def, _) => {\n-            generics_of_def_id(tcx, def_id);\n+            tcx.item_generics(def_id);\n             predicates_of_item(tcx, it);\n             let ty = type_of_def_id(tcx, def_id);\n \n@@ -651,12 +647,12 @@ fn convert_item<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, it: &hir::Item) {\n         },\n         hir::ItemTy(_, ref generics) => {\n             ensure_no_ty_param_bounds(tcx, it.span, generics, \"type\");\n-            generics_of_def_id(tcx, def_id);\n+            tcx.item_generics(def_id);\n             predicates_of_item(tcx, it);\n             type_of_def_id(tcx, def_id);\n         },\n         _ => {\n-            generics_of_def_id(tcx, def_id);\n+            tcx.item_generics(def_id);\n             predicates_of_item(tcx, it);\n             type_of_def_id(tcx, def_id);\n         },\n@@ -671,7 +667,7 @@ fn convert_trait_item<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, trait_item: &hir::T\n     let def_id = tcx.hir.local_def_id(trait_item.id);\n     match trait_item.node {\n         hir::TraitItemKind::Const(ref ty, _) => {\n-            generics_of_def_id(tcx, def_id);\n+            tcx.item_generics(def_id);\n             let ty = ItemCtxt::new(tcx, def_id).to_ty(&ty);\n             convert_associated_const(tcx,\n                                      TraitContainer(trait_def_id),\n@@ -680,7 +676,7 @@ fn convert_trait_item<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, trait_item: &hir::T\n         }\n \n         hir::TraitItemKind::Type(_, ref opt_ty) => {\n-            generics_of_def_id(tcx, def_id);\n+            tcx.item_generics(def_id);\n \n             let typ = opt_ty.as_ref().map(|ty| ItemCtxt::new(tcx, def_id).to_ty(&ty));\n \n@@ -701,7 +697,7 @@ fn convert_impl_item<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, impl_item: &hir::Imp\n     let def_id = tcx.hir.local_def_id(impl_item.id);\n     match impl_item.node {\n         hir::ImplItemKind::Const(ref ty, _) => {\n-            generics_of_def_id(tcx, def_id);\n+            tcx.item_generics(def_id);\n             let ty = ItemCtxt::new(tcx, def_id).to_ty(&ty);\n             convert_associated_const(tcx,\n                                      ImplContainer(impl_def_id),\n@@ -710,7 +706,7 @@ fn convert_impl_item<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, impl_item: &hir::Imp\n         }\n \n         hir::ImplItemKind::Type(ref ty) => {\n-            generics_of_def_id(tcx, def_id);\n+            tcx.item_generics(def_id);\n \n             if tcx.impl_trait_ref(impl_def_id).is_none() {\n                 span_err!(tcx.sess, impl_item.span, E0202,\n@@ -733,12 +729,12 @@ fn convert_variant_ctor<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                                   variant: &'tcx ty::VariantDef,\n                                   ty: Ty<'tcx>) {\n     let def_id = tcx.hir.local_def_id(ctor_id);\n-    generics_of_def_id(tcx, def_id);\n+    tcx.item_generics(def_id);\n     let ctor_ty = match variant.ctor_kind {\n         CtorKind::Fictive | CtorKind::Const => ty,\n         CtorKind::Fn => {\n             let inputs = variant.fields.iter().map(|field| tcx.item_type(field.did));\n-            let substs = mk_item_substs(tcx, def_id);\n+            let substs = Substs::identity_for_item(tcx, def_id);\n             tcx.mk_fn_def(def_id, substs, ty::Binder(tcx.mk_fn_sig(\n                 inputs,\n                 ty,\n@@ -835,39 +831,62 @@ fn convert_struct_variant<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     }\n }\n \n-fn convert_struct_def<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                                it: &hir::Item,\n-                                def: &hir::VariantData)\n-                                -> &'tcx ty::AdtDef\n-{\n-    let did = tcx.hir.local_def_id(it.id);\n-    // Use separate constructor id for unit/tuple structs and reuse did for braced structs.\n-    let ctor_id = if !def.is_struct() { Some(tcx.hir.local_def_id(def.id())) } else { None };\n-    let variants = vec![convert_struct_variant(tcx, ctor_id.unwrap_or(did), it.name,\n-                                               ty::VariantDiscr::Relative(0), def)];\n-    let adt = tcx.alloc_adt_def(did, AdtKind::Struct, variants,\n-        ReprOptions::new(tcx, did));\n-    if let Some(ctor_id) = ctor_id {\n-        // Make adt definition available through constructor id as well.\n-        tcx.maps.adt_def.borrow_mut().insert(ctor_id, adt);\n-    }\n+fn adt_def<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                     def_id: DefId)\n+                     -> &'tcx ty::AdtDef {\n+    use rustc::hir::map::*;\n+    use rustc::hir::*;\n \n-    tcx.maps.adt_def.borrow_mut().insert(did, adt);\n-    adt\n-}\n+    let node_id = tcx.hir.as_local_node_id(def_id).unwrap();\n+    let item = match tcx.hir.get(node_id) {\n+        NodeItem(item) => item,\n \n-fn convert_union_def<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                                it: &hir::Item,\n-                                def: &hir::VariantData)\n-                                -> &'tcx ty::AdtDef\n-{\n-    let did = tcx.hir.local_def_id(it.id);\n-    let variants = vec![convert_struct_variant(tcx, did, it.name,\n-                                               ty::VariantDiscr::Relative(0), def)];\n+        // Make adt definition available through constructor id as well.\n+        NodeStructCtor(_) => {\n+            return tcx.lookup_adt_def(tcx.hir.get_parent_did(node_id));\n+        }\n+\n+        _ => bug!()\n+    };\n \n-    let adt = tcx.alloc_adt_def(did, AdtKind::Union, variants, ReprOptions::new(tcx, did));\n-    tcx.maps.adt_def.borrow_mut().insert(did, adt);\n-    adt\n+    let repr = ReprOptions::new(tcx, def_id);\n+    let (kind, variants) = match item.node {\n+        ItemEnum(ref def, _) => {\n+            let mut distance_from_explicit = 0;\n+            (AdtKind::Enum, def.variants.iter().map(|v| {\n+                let did = tcx.hir.local_def_id(v.node.data.id());\n+                let discr = if let Some(e) = v.node.disr_expr {\n+                    distance_from_explicit = 0;\n+                    ty::VariantDiscr::Explicit(tcx.hir.local_def_id(e.node_id))\n+                } else {\n+                    ty::VariantDiscr::Relative(distance_from_explicit)\n+                };\n+                distance_from_explicit += 1;\n+\n+                convert_struct_variant(tcx, did, v.node.name, discr, &v.node.data)\n+            }).collect())\n+        }\n+        ItemStruct(ref def, _) => {\n+            // Use separate constructor id for unit/tuple structs and reuse did for braced structs.\n+            let ctor_id = if !def.is_struct() {\n+                Some(tcx.hir.local_def_id(def.id()))\n+            } else {\n+                None\n+            };\n+            (AdtKind::Struct, vec![\n+                convert_struct_variant(tcx, ctor_id.unwrap_or(def_id), item.name,\n+                                       ty::VariantDiscr::Relative(0), def)\n+            ])\n+        }\n+        ItemUnion(ref def, _) => {\n+            (AdtKind::Union, vec![\n+                convert_struct_variant(tcx, def_id, item.name,\n+                                       ty::VariantDiscr::Relative(0), def)\n+            ])\n+        }\n+        _ => bug!()\n+    };\n+    tcx.alloc_adt_def(def_id, kind, variants, repr)\n }\n \n fn evaluate_disr_expr<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n@@ -924,31 +943,6 @@ fn evaluate_disr_expr<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     }\n }\n \n-fn convert_enum_def<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                              it: &hir::Item,\n-                              def: &hir::EnumDef)\n-                              -> &'tcx ty::AdtDef\n-{\n-    let mut distance_from_explicit = 0;\n-    let variants = def.variants.iter().map(|v| {\n-        let did = tcx.hir.local_def_id(v.node.data.id());\n-        let discr = if let Some(e) = v.node.disr_expr {\n-            distance_from_explicit = 0;\n-            ty::VariantDiscr::Explicit(tcx.hir.local_def_id(e.node_id))\n-        } else {\n-            ty::VariantDiscr::Relative(distance_from_explicit)\n-        };\n-        distance_from_explicit += 1;\n-\n-        convert_struct_variant(tcx, did, v.node.name, discr, &v.node.data)\n-    }).collect();\n-\n-    let did = tcx.hir.local_def_id(it.id);\n-    let adt = tcx.alloc_adt_def(did, AdtKind::Enum, variants, ReprOptions::new(tcx, did));\n-    tcx.maps.adt_def.borrow_mut().insert(did, adt);\n-    adt\n-}\n-\n /// Ensures that the super-predicates of the trait with def-id\n /// trait_def_id are converted and stored. This also ensures that\n /// the transitive super-predicates are converted;\n@@ -1000,227 +994,221 @@ fn super_predicates<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     }\n }\n \n-fn trait_def_of_item<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, it: &hir::Item) -> &'tcx ty::TraitDef {\n-    let def_id = tcx.hir.local_def_id(it.id);\n+fn trait_def<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                       def_id: DefId)\n+                       -> &'tcx ty::TraitDef {\n+    let node_id = tcx.hir.as_local_node_id(def_id).unwrap();\n+    let item = tcx.hir.expect_item(node_id);\n \n-    tcx.maps.trait_def.memoize(def_id, || {\n-        let unsafety = match it.node {\n-            hir::ItemTrait(unsafety, ..) => unsafety,\n-            _ => span_bug!(it.span, \"trait_def_of_item invoked on non-trait\"),\n-        };\n+    let unsafety = match item.node {\n+        hir::ItemTrait(unsafety, ..) => unsafety,\n+        _ => span_bug!(item.span, \"trait_def_of_item invoked on non-trait\"),\n+    };\n \n-        let paren_sugar = tcx.has_attr(def_id, \"rustc_paren_sugar\");\n-        if paren_sugar && !tcx.sess.features.borrow().unboxed_closures {\n-            let mut err = tcx.sess.struct_span_err(\n-                it.span,\n-                \"the `#[rustc_paren_sugar]` attribute is a temporary means of controlling \\\n-                which traits can use parenthetical notation\");\n-            help!(&mut err,\n-                \"add `#![feature(unboxed_closures)]` to \\\n-                the crate attributes to use it\");\n-            err.emit();\n-        }\n+    let paren_sugar = tcx.has_attr(def_id, \"rustc_paren_sugar\");\n+    if paren_sugar && !tcx.sess.features.borrow().unboxed_closures {\n+        let mut err = tcx.sess.struct_span_err(\n+            item.span,\n+            \"the `#[rustc_paren_sugar]` attribute is a temporary means of controlling \\\n+             which traits can use parenthetical notation\");\n+        help!(&mut err,\n+            \"add `#![feature(unboxed_closures)]` to \\\n+             the crate attributes to use it\");\n+        err.emit();\n+    }\n \n-        let def_path_hash = tcx.def_path(def_id).deterministic_hash(tcx);\n-        tcx.alloc_trait_def(ty::TraitDef::new(def_id, unsafety, paren_sugar, def_path_hash))\n-    })\n+    let def_path_hash = tcx.def_path(def_id).deterministic_hash(tcx);\n+    tcx.alloc_trait_def(ty::TraitDef::new(def_id, unsafety, paren_sugar, def_path_hash))\n }\n \n-fn generics_of_def_id<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                                def_id: DefId)\n-                                -> &'tcx ty::Generics {\n-    let node_id = if let Some(id) = tcx.hir.as_local_node_id(def_id) {\n-        id\n-    } else {\n-        return tcx.item_generics(def_id);\n-    };\n-    tcx.maps.generics.memoize(def_id, || {\n-        use rustc::hir::map::*;\n-        use rustc::hir::*;\n+fn generics<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                      def_id: DefId)\n+                      -> &'tcx ty::Generics {\n+    use rustc::hir::map::*;\n+    use rustc::hir::*;\n \n-        let node = tcx.hir.get(node_id);\n-        let parent_def_id = match node {\n-            NodeImplItem(_) |\n-            NodeTraitItem(_) |\n-            NodeVariant(_) |\n-            NodeStructCtor(_) |\n-            NodeField(_) => {\n-                let parent_id = tcx.hir.get_parent(node_id);\n-                Some(tcx.hir.local_def_id(parent_id))\n-            }\n-            NodeExpr(&hir::Expr { node: hir::ExprClosure(..), .. }) => {\n-                Some(tcx.closure_base_def_id(def_id))\n-            }\n-            NodeTy(&hir::Ty { node: hir::TyImplTrait(..), .. }) => {\n-                let mut parent_id = node_id;\n-                loop {\n-                    match tcx.hir.get(parent_id) {\n-                        NodeItem(_) | NodeImplItem(_) | NodeTraitItem(_) => break,\n-                        _ => {\n-                            parent_id = tcx.hir.get_parent_node(parent_id);\n-                        }\n+    let node_id = tcx.hir.as_local_node_id(def_id).unwrap();\n+\n+    let node = tcx.hir.get(node_id);\n+    let parent_def_id = match node {\n+        NodeImplItem(_) |\n+        NodeTraitItem(_) |\n+        NodeVariant(_) |\n+        NodeStructCtor(_) |\n+        NodeField(_) => {\n+            let parent_id = tcx.hir.get_parent(node_id);\n+            Some(tcx.hir.local_def_id(parent_id))\n+        }\n+        NodeExpr(&hir::Expr { node: hir::ExprClosure(..), .. }) => {\n+            Some(tcx.closure_base_def_id(def_id))\n+        }\n+        NodeTy(&hir::Ty { node: hir::TyImplTrait(..), .. }) => {\n+            let mut parent_id = node_id;\n+            loop {\n+                match tcx.hir.get(parent_id) {\n+                    NodeItem(_) | NodeImplItem(_) | NodeTraitItem(_) => break,\n+                    _ => {\n+                        parent_id = tcx.hir.get_parent_node(parent_id);\n                     }\n                 }\n-                Some(tcx.hir.local_def_id(parent_id))\n             }\n-            _ => None\n-        };\n+            Some(tcx.hir.local_def_id(parent_id))\n+        }\n+        _ => None\n+    };\n \n-        let mut opt_self = None;\n-        let mut allow_defaults = false;\n+    let mut opt_self = None;\n+    let mut allow_defaults = false;\n \n-        let no_generics = hir::Generics::empty();\n-        let ast_generics = match node {\n-            NodeTraitItem(item) => {\n-                match item.node {\n-                    TraitItemKind::Method(ref sig, _) => &sig.generics,\n-                    _ => &no_generics\n-                }\n+    let no_generics = hir::Generics::empty();\n+    let ast_generics = match node {\n+        NodeTraitItem(item) => {\n+            match item.node {\n+                TraitItemKind::Method(ref sig, _) => &sig.generics,\n+                _ => &no_generics\n             }\n+        }\n \n-            NodeImplItem(item) => {\n-                match item.node {\n-                    ImplItemKind::Method(ref sig, _) => &sig.generics,\n-                    _ => &no_generics\n-                }\n+        NodeImplItem(item) => {\n+            match item.node {\n+                ImplItemKind::Method(ref sig, _) => &sig.generics,\n+                _ => &no_generics\n             }\n+        }\n \n-            NodeItem(item) => {\n-                match item.node {\n-                    ItemFn(.., ref generics, _) |\n-                    ItemImpl(_, _, ref generics, ..) => generics,\n-\n-                    ItemTy(_, ref generics) |\n-                    ItemEnum(_, ref generics) |\n-                    ItemStruct(_, ref generics) |\n-                    ItemUnion(_, ref generics) => {\n-                        allow_defaults = true;\n-                        generics\n-                    }\n-\n-                    ItemTrait(_, ref generics, ..) => {\n-                        // Add in the self type parameter.\n-                        //\n-                        // Something of a hack: use the node id for the trait, also as\n-                        // the node id for the Self type parameter.\n-                        let param_id = item.id;\n-\n-                        opt_self = Some(ty::TypeParameterDef {\n-                            index: 0,\n-                            name: keywords::SelfType.name(),\n-                            def_id: tcx.hir.local_def_id(param_id),\n-                            has_default: false,\n-                            object_lifetime_default: rl::Set1::Empty,\n-                            pure_wrt_drop: false,\n-                        });\n-\n-                        allow_defaults = true;\n-                        generics\n-                    }\n+        NodeItem(item) => {\n+            match item.node {\n+                ItemFn(.., ref generics, _) |\n+                ItemImpl(_, _, ref generics, ..) => generics,\n+\n+                ItemTy(_, ref generics) |\n+                ItemEnum(_, ref generics) |\n+                ItemStruct(_, ref generics) |\n+                ItemUnion(_, ref generics) => {\n+                    allow_defaults = true;\n+                    generics\n+                }\n \n-                    _ => &no_generics\n+                ItemTrait(_, ref generics, ..) => {\n+                    // Add in the self type parameter.\n+                    //\n+                    // Something of a hack: use the node id for the trait, also as\n+                    // the node id for the Self type parameter.\n+                    let param_id = item.id;\n+\n+                    opt_self = Some(ty::TypeParameterDef {\n+                        index: 0,\n+                        name: keywords::SelfType.name(),\n+                        def_id: tcx.hir.local_def_id(param_id),\n+                        has_default: false,\n+                        object_lifetime_default: rl::Set1::Empty,\n+                        pure_wrt_drop: false,\n+                    });\n+\n+                    allow_defaults = true;\n+                    generics\n                 }\n+\n+                _ => &no_generics\n             }\n+        }\n \n-            NodeForeignItem(item) => {\n-                match item.node {\n-                    ForeignItemStatic(..) => &no_generics,\n-                    ForeignItemFn(_, _, ref generics) => generics\n-                }\n+        NodeForeignItem(item) => {\n+            match item.node {\n+                ForeignItemStatic(..) => &no_generics,\n+                ForeignItemFn(_, _, ref generics) => generics\n             }\n+        }\n \n-            _ => &no_generics\n-        };\n+        _ => &no_generics\n+    };\n \n-        let has_self = opt_self.is_some();\n-        let mut parent_has_self = false;\n-        let mut own_start = has_self as u32;\n-        let (parent_regions, parent_types) = parent_def_id.map_or((0, 0), |def_id| {\n-            let generics = generics_of_def_id(tcx, def_id);\n-            assert_eq!(has_self, false);\n-            parent_has_self = generics.has_self;\n-            own_start = generics.count() as u32;\n-            (generics.parent_regions + generics.regions.len() as u32,\n-             generics.parent_types + generics.types.len() as u32)\n-        });\n+    let has_self = opt_self.is_some();\n+    let mut parent_has_self = false;\n+    let mut own_start = has_self as u32;\n+    let (parent_regions, parent_types) = parent_def_id.map_or((0, 0), |def_id| {\n+        let generics = tcx.item_generics(def_id);\n+        assert_eq!(has_self, false);\n+        parent_has_self = generics.has_self;\n+        own_start = generics.count() as u32;\n+        (generics.parent_regions + generics.regions.len() as u32,\n+            generics.parent_types + generics.types.len() as u32)\n+    });\n \n-        let early_lifetimes = early_bound_lifetimes_from_generics(tcx, ast_generics);\n-        let regions = early_lifetimes.enumerate().map(|(i, l)| {\n-            let issue_32330 = tcx.named_region_map.issue_32330\n-                                                      .get(&l.lifetime.id)\n-                                                      .cloned();\n-            ty::RegionParameterDef {\n-                name: l.lifetime.name,\n-                index: own_start + i as u32,\n-                def_id: tcx.hir.local_def_id(l.lifetime.id),\n-                pure_wrt_drop: l.pure_wrt_drop,\n-                issue_32330: issue_32330,\n-            }\n-        }).collect::<Vec<_>>();\n+    let early_lifetimes = early_bound_lifetimes_from_generics(tcx, ast_generics);\n+    let regions = early_lifetimes.enumerate().map(|(i, l)| {\n+        let issue_32330 = tcx.named_region_map.issue_32330.get(&l.lifetime.id).cloned();\n+        ty::RegionParameterDef {\n+            name: l.lifetime.name,\n+            index: own_start + i as u32,\n+            def_id: tcx.hir.local_def_id(l.lifetime.id),\n+            pure_wrt_drop: l.pure_wrt_drop,\n+            issue_32330: issue_32330,\n+        }\n+    }).collect::<Vec<_>>();\n \n-        let object_lifetime_defaults =\n-            tcx.named_region_map.object_lifetime_defaults.get(&node_id);\n+    let object_lifetime_defaults =\n+        tcx.named_region_map.object_lifetime_defaults.get(&node_id);\n \n-        // Now create the real type parameters.\n-        let type_start = own_start + regions.len() as u32;\n-        let types = ast_generics.ty_params.iter().enumerate().map(|(i, p)| {\n-            if p.name == keywords::SelfType.name() {\n-                span_bug!(p.span, \"`Self` should not be the name of a regular parameter\");\n-            }\n+    // Now create the real type parameters.\n+    let type_start = own_start + regions.len() as u32;\n+    let types = ast_generics.ty_params.iter().enumerate().map(|(i, p)| {\n+        if p.name == keywords::SelfType.name() {\n+            span_bug!(p.span, \"`Self` should not be the name of a regular parameter\");\n+        }\n \n-            if !allow_defaults && p.default.is_some() {\n-                if !tcx.sess.features.borrow().default_type_parameter_fallback {\n-                    tcx.sess.add_lint(\n-                        lint::builtin::INVALID_TYPE_PARAM_DEFAULT,\n-                        p.id,\n-                        p.span,\n-                        format!(\"defaults for type parameters are only allowed in `struct`, \\\n-                                 `enum`, `type`, or `trait` definitions.\"));\n-                }\n+        if !allow_defaults && p.default.is_some() {\n+            if !tcx.sess.features.borrow().default_type_parameter_fallback {\n+                tcx.sess.add_lint(\n+                    lint::builtin::INVALID_TYPE_PARAM_DEFAULT,\n+                    p.id,\n+                    p.span,\n+                    format!(\"defaults for type parameters are only allowed in `struct`, \\\n+                             `enum`, `type`, or `trait` definitions.\"));\n             }\n+        }\n \n-            ty::TypeParameterDef {\n+        ty::TypeParameterDef {\n+            index: type_start + i as u32,\n+            name: p.name,\n+            def_id: tcx.hir.local_def_id(p.id),\n+            has_default: p.default.is_some(),\n+            object_lifetime_default:\n+                object_lifetime_defaults.map_or(rl::Set1::Empty, |o| o[i]),\n+            pure_wrt_drop: p.pure_wrt_drop,\n+        }\n+    });\n+    let mut types: Vec<_> = opt_self.into_iter().chain(types).collect();\n+\n+    // provide junk type parameter defs - the only place that\n+    // cares about anything but the length is instantiation,\n+    // and we don't do that for closures.\n+    if let NodeExpr(&hir::Expr { node: hir::ExprClosure(..), .. }) = node {\n+        tcx.with_freevars(node_id, |fv| {\n+            types.extend(fv.iter().enumerate().map(|(i, _)| ty::TypeParameterDef {\n                 index: type_start + i as u32,\n-                name: p.name,\n-                def_id: tcx.hir.local_def_id(p.id),\n-                has_default: p.default.is_some(),\n-                object_lifetime_default:\n-                    object_lifetime_defaults.map_or(rl::Set1::Empty, |o| o[i]),\n-                pure_wrt_drop: p.pure_wrt_drop,\n-            }\n+                name: Symbol::intern(\"<upvar>\"),\n+                def_id: def_id,\n+                has_default: false,\n+                object_lifetime_default: rl::Set1::Empty,\n+                pure_wrt_drop: false,\n+            }));\n         });\n-        let mut types: Vec<_> = opt_self.into_iter().chain(types).collect();\n-\n-        // provide junk type parameter defs - the only place that\n-        // cares about anything but the length is instantiation,\n-        // and we don't do that for closures.\n-        if let NodeExpr(&hir::Expr { node: hir::ExprClosure(..), .. }) = node {\n-            tcx.with_freevars(node_id, |fv| {\n-                types.extend(fv.iter().enumerate().map(|(i, _)| ty::TypeParameterDef {\n-                    index: type_start + i as u32,\n-                    name: Symbol::intern(\"<upvar>\"),\n-                    def_id: def_id,\n-                    has_default: false,\n-                    object_lifetime_default: rl::Set1::Empty,\n-                    pure_wrt_drop: false,\n-               }));\n-            });\n-        }\n+    }\n \n-        let mut type_param_to_index = BTreeMap::new();\n-        for param in &types {\n-            type_param_to_index.insert(param.def_id.index, param.index);\n-        }\n+    let mut type_param_to_index = BTreeMap::new();\n+    for param in &types {\n+        type_param_to_index.insert(param.def_id.index, param.index);\n+    }\n \n-        tcx.alloc_generics(ty::Generics {\n-            parent: parent_def_id,\n-            parent_regions: parent_regions,\n-            parent_types: parent_types,\n-            regions: regions,\n-            types: types,\n-            type_param_to_index: type_param_to_index,\n-            has_self: has_self || parent_has_self\n-        })\n+    tcx.alloc_generics(ty::Generics {\n+        parent: parent_def_id,\n+        parent_regions: parent_regions,\n+        parent_types: parent_types,\n+        regions: regions,\n+        types: types,\n+        type_param_to_index: type_param_to_index,\n+        has_self: has_self || parent_has_self\n     })\n }\n \n@@ -1237,7 +1225,7 @@ fn type_of_def_id<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         use rustc::hir::*;\n \n         // Alway bring in generics, as computing the type needs them.\n-        generics_of_def_id(tcx, def_id);\n+        tcx.item_generics(def_id);\n \n         let icx = ItemCtxt::new(tcx, def_id);\n \n@@ -1250,22 +1238,14 @@ fn type_of_def_id<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                     }\n                     ItemFn(ref decl, unsafety, _, abi, _, _) => {\n                         let tofd = AstConv::ty_of_fn(&icx, unsafety, abi, &decl);\n-                        let substs = mk_item_substs(tcx, def_id);\n+                        let substs = Substs::identity_for_item(tcx, def_id);\n                         tcx.mk_fn_def(def_id, substs, tofd)\n                     }\n-                    ItemEnum(ref ei, _) => {\n-                        let def = convert_enum_def(tcx, item, ei);\n-                        let substs = mk_item_substs(tcx, def_id);\n-                        tcx.mk_adt(def, substs)\n-                    }\n-                    ItemStruct(ref si, _) => {\n-                        let def = convert_struct_def(tcx, item, si);\n-                        let substs = mk_item_substs(tcx, def_id);\n-                        tcx.mk_adt(def, substs)\n-                    }\n-                    ItemUnion(ref un, _) => {\n-                        let def = convert_union_def(tcx, item, un);\n-                        let substs = mk_item_substs(tcx, def_id);\n+                    ItemEnum(..) |\n+                    ItemStruct(..) |\n+                    ItemUnion(..) => {\n+                        let def = tcx.lookup_adt_def(def_id);\n+                        let substs = Substs::identity_for_item(tcx, def_id);\n                         tcx.mk_adt(def, substs)\n                     }\n                     ItemDefaultImpl(..) |\n@@ -1337,7 +1317,7 @@ fn convert_foreign_item<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     // moral failing, but at the moment it seems like the only\n     // convenient way to extract the ABI. - ndm\n     let def_id = tcx.hir.local_def_id(it.id);\n-    generics_of_def_id(tcx, def_id);\n+    tcx.item_generics(def_id);\n     type_of_def_id(tcx, def_id);\n \n     let no_generics = hir::Generics::empty();\n@@ -1413,7 +1393,7 @@ fn ty_generic_predicates<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                                    def_id: DefId,\n                                    ast_generics: &hir::Generics) {\n     let icx = ItemCtxt::new(tcx, def_id);\n-    let generics = generics_of_def_id(tcx, def_id);\n+    let generics = tcx.item_generics(def_id);\n     let parent_count = generics.parent_count() as u32;\n     let has_own_self = generics.has_self && parent_count == 0;\n \n@@ -1426,7 +1406,7 @@ fn ty_generic_predicates<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                 hir::ItemTrait(.., ref items) => {\n                     (Some((ty::TraitRef {\n                         def_id: def_id,\n-                        substs: mk_item_substs(tcx, def_id)\n+                        substs: Substs::identity_for_item(tcx, def_id)\n                     }, items)), None)\n                 }\n                 hir::ItemImpl(..) => {\n@@ -1692,15 +1672,6 @@ fn compute_type_of_foreign_fn_decl<'a, 'tcx>(\n         }\n     }\n \n-    let substs = mk_item_substs(tcx, def_id);\n+    let substs = Substs::identity_for_item(tcx, def_id);\n     tcx.mk_fn_def(def_id, substs, fty)\n }\n-\n-fn mk_item_substs<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                            def_id: DefId)\n-                            -> &'tcx Substs<'tcx> {\n-    // FIXME(eddyb) Do this request from Substs::for_item in librustc.\n-    generics_of_def_id(tcx, def_id);\n-\n-    Substs::identity_for_item(tcx, def_id)\n-}"}, {"sha": "8e6e83bf3013f0f6cf6d5c8157ac1481fd7cfd00", "filename": "src/librustc_typeck/lib.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/9c3c306800313a119d236e607209e831187e7501/src%2Flibrustc_typeck%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c3c306800313a119d236e607209e831187e7501/src%2Flibrustc_typeck%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Flib.rs?ref=9c3c306800313a119d236e607209e831187e7501", "patch": "@@ -110,6 +110,7 @@ use hir::map as hir_map;\n use rustc::infer::InferOk;\n use rustc::ty::subst::Substs;\n use rustc::ty::{self, Ty, TyCtxt};\n+use rustc::ty::maps::Providers;\n use rustc::traits::{ObligationCause, ObligationCauseCode, Reveal};\n use session::config;\n use util::common::time;\n@@ -284,6 +285,10 @@ fn check_for_entry_fn<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>) {\n     }\n }\n \n+pub fn provide(providers: &mut Providers) {\n+    collect::provide(providers);\n+}\n+\n pub fn check_crate<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>)\n                              -> Result<(), usize> {\n     let time_passes = tcx.sess.time_passes();"}]}