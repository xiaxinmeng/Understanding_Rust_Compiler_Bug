{"sha": "45aa5c0f90124e926662f2c2c2d9efca065e0397", "node_id": "C_kwDOAAsO6NoAKDQ1YWE1YzBmOTAxMjRlOTI2NjYyZjJjMmMyZDllZmNhMDY1ZTAzOTc", "commit": {"author": {"name": "Michael Goulet", "email": "michael@errs.io", "date": "2023-01-17T20:16:30Z"}, "committer": {"name": "Michael Goulet", "email": "michael@errs.io", "date": "2023-01-18T14:59:15Z"}, "message": "Auto and alias traits", "tree": {"sha": "87d03497d2bf6aee587b3e1fe7074260aa713c50", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/87d03497d2bf6aee587b3e1fe7074260aa713c50"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/45aa5c0f90124e926662f2c2c2d9efca065e0397", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/45aa5c0f90124e926662f2c2c2d9efca065e0397", "html_url": "https://github.com/rust-lang/rust/commit/45aa5c0f90124e926662f2c2c2d9efca065e0397", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/45aa5c0f90124e926662f2c2c2d9efca065e0397/comments", "author": {"login": "compiler-errors", "id": 3674314, "node_id": "MDQ6VXNlcjM2NzQzMTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/3674314?v=4", "gravatar_id": "", "url": "https://api.github.com/users/compiler-errors", "html_url": "https://github.com/compiler-errors", "followers_url": "https://api.github.com/users/compiler-errors/followers", "following_url": "https://api.github.com/users/compiler-errors/following{/other_user}", "gists_url": "https://api.github.com/users/compiler-errors/gists{/gist_id}", "starred_url": "https://api.github.com/users/compiler-errors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/compiler-errors/subscriptions", "organizations_url": "https://api.github.com/users/compiler-errors/orgs", "repos_url": "https://api.github.com/users/compiler-errors/repos", "events_url": "https://api.github.com/users/compiler-errors/events{/privacy}", "received_events_url": "https://api.github.com/users/compiler-errors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "compiler-errors", "id": 3674314, "node_id": "MDQ6VXNlcjM2NzQzMTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/3674314?v=4", "gravatar_id": "", "url": "https://api.github.com/users/compiler-errors", "html_url": "https://github.com/compiler-errors", "followers_url": "https://api.github.com/users/compiler-errors/followers", "following_url": "https://api.github.com/users/compiler-errors/following{/other_user}", "gists_url": "https://api.github.com/users/compiler-errors/gists{/gist_id}", "starred_url": "https://api.github.com/users/compiler-errors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/compiler-errors/subscriptions", "organizations_url": "https://api.github.com/users/compiler-errors/orgs", "repos_url": "https://api.github.com/users/compiler-errors/repos", "events_url": "https://api.github.com/users/compiler-errors/events{/privacy}", "received_events_url": "https://api.github.com/users/compiler-errors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3d87a8e84850e2f5edc0f87ab2f4d3c2b67a48ac", "url": "https://api.github.com/repos/rust-lang/rust/commits/3d87a8e84850e2f5edc0f87ab2f4d3c2b67a48ac", "html_url": "https://github.com/rust-lang/rust/commit/3d87a8e84850e2f5edc0f87ab2f4d3c2b67a48ac"}], "stats": {"total": 190, "additions": 169, "deletions": 21}, "files": [{"sha": "db7dd2e5e75d7e873abb0ee9f18eef334753c641", "filename": "compiler/rustc_middle/src/ty/mod.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/45aa5c0f90124e926662f2c2c2d9efca065e0397/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45aa5c0f90124e926662f2c2c2d9efca065e0397/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs?ref=45aa5c0f90124e926662f2c2c2d9efca065e0397", "patch": "@@ -2382,6 +2382,11 @@ impl<'tcx> TyCtxt<'tcx> {\n         self.trait_def(trait_def_id).has_auto_impl\n     }\n \n+    /// Returns `true` if this is a trait alias.\n+    pub fn trait_is_alias(self, trait_def_id: DefId) -> bool {\n+        self.def_kind(trait_def_id) == DefKind::TraitAlias\n+    }\n+\n     pub fn trait_is_coinductive(self, trait_def_id: DefId) -> bool {\n         self.trait_is_auto(trait_def_id) || self.lang_items().sized_trait() == Some(trait_def_id)\n     }"}, {"sha": "0759c42338249f199326f3d2ec10510f742d3a0a", "filename": "compiler/rustc_trait_selection/src/solve/assembly.rs", "status": "modified", "additions": 19, "deletions": 6, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/45aa5c0f90124e926662f2c2c2d9efca065e0397/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fassembly.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45aa5c0f90124e926662f2c2c2d9efca065e0397/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fassembly.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fassembly.rs?ref=45aa5c0f90124e926662f2c2c2d9efca065e0397", "patch": "@@ -92,15 +92,25 @@ pub(super) trait GoalKind<'tcx>: TypeFoldable<'tcx> + Copy {\n         impl_def_id: DefId,\n     ) -> QueryResult<'tcx>;\n \n-    fn consider_builtin_sized_candidate(\n+    fn consider_assumption(\n         ecx: &mut EvalCtxt<'_, 'tcx>,\n         goal: Goal<'tcx, Self>,\n+        assumption: ty::Predicate<'tcx>,\n     ) -> QueryResult<'tcx>;\n \n-    fn consider_assumption(\n+    fn consider_auto_trait_candidate(\n+        ecx: &mut EvalCtxt<'_, 'tcx>,\n+        goal: Goal<'tcx, Self>,\n+    ) -> QueryResult<'tcx>;\n+\n+    fn consider_trait_alias_candidate(\n+        ecx: &mut EvalCtxt<'_, 'tcx>,\n+        goal: Goal<'tcx, Self>,\n+    ) -> QueryResult<'tcx>;\n+\n+    fn consider_builtin_sized_candidate(\n         ecx: &mut EvalCtxt<'_, 'tcx>,\n         goal: Goal<'tcx, Self>,\n-        assumption: ty::Predicate<'tcx>,\n     ) -> QueryResult<'tcx>;\n }\n impl<'tcx> EvalCtxt<'_, 'tcx> {\n@@ -198,7 +208,11 @@ impl<'tcx> EvalCtxt<'_, 'tcx> {\n     ) {\n         let lang_items = self.tcx().lang_items();\n         let trait_def_id = goal.predicate.trait_def_id(self.tcx());\n-        let result = if lang_items.sized_trait() == Some(trait_def_id) {\n+        let result = if self.tcx().trait_is_auto(trait_def_id) {\n+            G::consider_auto_trait_candidate(self, goal)\n+        } else if self.tcx().trait_is_alias(trait_def_id) {\n+            G::consider_trait_alias_candidate(self, goal)\n+        } else if lang_items.sized_trait() == Some(trait_def_id) {\n             G::consider_builtin_sized_candidate(self, goal)\n         } else {\n             Err(NoSolution)\n@@ -315,8 +329,7 @@ impl<'tcx> EvalCtxt<'_, 'tcx> {\n         for assumption in\n             elaborate_predicates(tcx, bounds.iter().map(|bound| bound.with_self_ty(tcx, self_ty)))\n         {\n-            match G::consider_assumption(self, goal, assumption.predicate)\n-            {\n+            match G::consider_assumption(self, goal, assumption.predicate) {\n                 Ok(result) => {\n                     candidates.push(Candidate { source: CandidateSource::BuiltinImpl, result })\n                 }"}, {"sha": "3c74de09802d5e1aa696481f26d2ab99893edcb3", "filename": "compiler/rustc_trait_selection/src/solve/project_goals.rs", "status": "modified", "additions": 21, "deletions": 7, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/45aa5c0f90124e926662f2c2c2d9efca065e0397/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fproject_goals.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45aa5c0f90124e926662f2c2c2d9efca065e0397/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fproject_goals.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fproject_goals.rs?ref=45aa5c0f90124e926662f2c2c2d9efca065e0397", "patch": "@@ -290,13 +290,6 @@ impl<'tcx> assembly::GoalKind<'tcx> for ProjectionPredicate<'tcx> {\n         })\n     }\n \n-    fn consider_builtin_sized_candidate(\n-        _ecx: &mut EvalCtxt<'_, 'tcx>,\n-        goal: Goal<'tcx, Self>,\n-    ) -> QueryResult<'tcx> {\n-        bug!(\"`Sized` does not have an associated type: {:?}\", goal);\n-    }\n-\n     fn consider_assumption(\n         ecx: &mut EvalCtxt<'_, 'tcx>,\n         goal: Goal<'tcx, Self>,\n@@ -333,6 +326,27 @@ impl<'tcx> assembly::GoalKind<'tcx> for ProjectionPredicate<'tcx> {\n             Err(NoSolution)\n         }\n     }\n+\n+    fn consider_auto_trait_candidate(\n+        _ecx: &mut EvalCtxt<'_, 'tcx>,\n+        goal: Goal<'tcx, Self>,\n+    ) -> QueryResult<'tcx> {\n+        bug!(\"auto traits do not have associated types: {:?}\", goal);\n+    }\n+\n+    fn consider_trait_alias_candidate(\n+        _ecx: &mut EvalCtxt<'_, 'tcx>,\n+        goal: Goal<'tcx, Self>,\n+    ) -> QueryResult<'tcx> {\n+        bug!(\"trait aliases do not have associated types: {:?}\", goal);\n+    }\n+\n+    fn consider_builtin_sized_candidate(\n+        _ecx: &mut EvalCtxt<'_, 'tcx>,\n+        goal: Goal<'tcx, Self>,\n+    ) -> QueryResult<'tcx> {\n+        bug!(\"`Sized` does not have an associated type: {:?}\", goal);\n+    }\n }\n \n /// This behavior is also implemented in `rustc_ty_utils` and in the old `project` code."}, {"sha": "1f18de2e7a9e0a73ec31aaaa404705afe2b94d7e", "filename": "compiler/rustc_trait_selection/src/solve/trait_goals.rs", "status": "modified", "additions": 124, "deletions": 8, "changes": 132, "blob_url": "https://github.com/rust-lang/rust/blob/45aa5c0f90124e926662f2c2c2d9efca065e0397/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Ftrait_goals.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45aa5c0f90124e926662f2c2c2d9efca065e0397/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Ftrait_goals.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Ftrait_goals.rs?ref=45aa5c0f90124e926662f2c2c2d9efca065e0397", "patch": "@@ -6,7 +6,7 @@ use super::assembly::{self, Candidate, CandidateSource};\n use super::infcx_ext::InferCtxtExt;\n use super::{EvalCtxt, Goal, QueryResult};\n use rustc_hir::def_id::DefId;\n-use rustc_infer::infer::LateBoundRegionConversionTime;\n+use rustc_infer::infer::InferCtxt;\n use rustc_infer::traits::query::NoSolution;\n use rustc_middle::ty::fast_reject::{DeepRejectCtxt, TreatParams};\n use rustc_middle::ty::{self, Ty, TyCtxt};\n@@ -58,13 +58,6 @@ impl<'tcx> assembly::GoalKind<'tcx> for TraitPredicate<'tcx> {\n         })\n     }\n \n-    fn consider_builtin_sized_candidate(\n-        _ecx: &mut EvalCtxt<'_, 'tcx>,\n-        _goal: Goal<'tcx, Self>,\n-    ) -> QueryResult<'tcx> {\n-        unimplemented!();\n-    }\n-\n     fn consider_assumption(\n         ecx: &mut EvalCtxt<'_, 'tcx>,\n         goal: Goal<'tcx, Self>,\n@@ -84,9 +77,61 @@ impl<'tcx> assembly::GoalKind<'tcx> for TraitPredicate<'tcx> {\n             Err(NoSolution)\n         }\n     }\n+\n+    fn consider_auto_trait_candidate(\n+        ecx: &mut EvalCtxt<'_, 'tcx>,\n+        goal: Goal<'tcx, Self>,\n+    ) -> QueryResult<'tcx> {\n+        ecx.infcx.probe(|_| {\n+            let constituent_tys =\n+                instantiate_constituent_tys_for_auto_trait(ecx.infcx, goal.predicate.self_ty())?;\n+            ecx.evaluate_goal_for_constituent_tys_and_make_canonical_response(goal, constituent_tys)\n+        })\n+    }\n+\n+    fn consider_trait_alias_candidate(\n+        ecx: &mut EvalCtxt<'_, 'tcx>,\n+        goal: Goal<'tcx, Self>,\n+    ) -> QueryResult<'tcx> {\n+        let tcx = ecx.tcx();\n+\n+        ecx.infcx.probe(|_| {\n+            let nested_obligations = tcx\n+                .predicates_of(goal.predicate.def_id())\n+                .instantiate(tcx, goal.predicate.trait_ref.substs);\n+            ecx.evaluate_all_and_make_canonical_response(\n+                nested_obligations.predicates.into_iter().map(|p| goal.with(tcx, p)).collect(),\n+            )\n+        })\n+    }\n+\n+    fn consider_builtin_sized_candidate(\n+        _ecx: &mut EvalCtxt<'_, 'tcx>,\n+        _goal: Goal<'tcx, Self>,\n+    ) -> QueryResult<'tcx> {\n+        unimplemented!();\n+    }\n }\n \n impl<'tcx> EvalCtxt<'_, 'tcx> {\n+    fn evaluate_goal_for_constituent_tys_and_make_canonical_response(\n+        &mut self,\n+        goal: Goal<'tcx, TraitPredicate<'tcx>>,\n+        constituent_tys: Vec<Ty<'tcx>>,\n+    ) -> QueryResult<'tcx> {\n+        self.evaluate_all_and_make_canonical_response(\n+            constituent_tys\n+                .into_iter()\n+                .map(|ty| {\n+                    goal.with(\n+                        self.tcx(),\n+                        ty::Binder::dummy(goal.predicate.with_self_ty(self.tcx(), ty)),\n+                    )\n+                })\n+                .collect(),\n+        )\n+    }\n+\n     pub(super) fn compute_trait_goal(\n         &mut self,\n         goal: Goal<'tcx, TraitPredicate<'tcx>>,\n@@ -162,3 +207,74 @@ impl<'tcx> EvalCtxt<'_, 'tcx> {\n         candidate\n     }\n }\n+\n+// Calculates the constituent types of a type for `auto trait` purposes.\n+//\n+// For types with an \"existential\" binder, i.e. generator witnesses, we also\n+// instantiate the binder with placeholders eagerly.\n+fn instantiate_constituent_tys_for_auto_trait<'tcx>(\n+    infcx: &InferCtxt<'tcx>,\n+    ty: Ty<'tcx>,\n+) -> Result<Vec<Ty<'tcx>>, NoSolution> {\n+    let tcx = infcx.tcx;\n+    match *ty.kind() {\n+        ty::Uint(_)\n+        | ty::Int(_)\n+        | ty::Bool\n+        | ty::Float(_)\n+        | ty::FnDef(..)\n+        | ty::FnPtr(_)\n+        | ty::Str\n+        | ty::Error(_)\n+        | ty::Infer(ty::IntVar(_) | ty::FloatVar(_))\n+        | ty::Never\n+        | ty::Char => Ok(vec![]),\n+\n+        ty::Placeholder(..)\n+        | ty::Dynamic(..)\n+        | ty::Param(..)\n+        | ty::Foreign(..)\n+        | ty::Alias(ty::Projection, ..)\n+        | ty::Bound(..)\n+        | ty::Infer(ty::TyVar(_)) => {\n+            // FIXME: Do we need to mark anything as ambiguous here? Yeah?\n+            Err(NoSolution)\n+        }\n+\n+        ty::Infer(ty::FreshTy(_) | ty::FreshIntTy(_) | ty::FreshFloatTy(_)) => bug!(),\n+\n+        ty::RawPtr(ty::TypeAndMut { ty: element_ty, .. }) | ty::Ref(_, element_ty, _) => {\n+            Ok(vec![element_ty])\n+        }\n+\n+        ty::Array(element_ty, _) | ty::Slice(element_ty) => Ok(vec![element_ty]),\n+\n+        ty::Tuple(ref tys) => {\n+            // (T1, ..., Tn) -- meets any bound that all of T1...Tn meet\n+            Ok(tys.iter().collect())\n+        }\n+\n+        ty::Closure(_, ref substs) => Ok(vec![substs.as_closure().tupled_upvars_ty()]),\n+\n+        ty::Generator(_, ref substs, _) => {\n+            let generator_substs = substs.as_generator();\n+            Ok(vec![generator_substs.tupled_upvars_ty(), generator_substs.witness()])\n+        }\n+\n+        ty::GeneratorWitness(types) => {\n+            Ok(infcx.replace_bound_vars_with_placeholders(types).to_vec())\n+        }\n+\n+        // For `PhantomData<T>`, we pass `T`.\n+        ty::Adt(def, substs) if def.is_phantom_data() => Ok(vec![substs.type_at(0)]),\n+\n+        ty::Adt(def, substs) => Ok(def.all_fields().map(|f| f.ty(tcx, substs)).collect()),\n+\n+        ty::Alias(ty::Opaque, ty::AliasTy { def_id, substs, .. }) => {\n+            // We can resolve the `impl Trait` to its concrete type,\n+            // which enforces a DAG between the functions requiring\n+            // the auto trait bounds in question.\n+            Ok(vec![tcx.bound_type_of(def_id).subst(tcx, substs)])\n+        }\n+    }\n+}"}]}