{"sha": "d20646b2d8033f31423b5bda3e56776df115e144", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQyMDY0NmIyZDgwMzNmMzE0MjNiNWJkYTNlNTY3NzZkZjExNWUxNDQ=", "commit": {"author": {"name": "Matthew Jasper", "email": "mjjasper1@gmail.com", "date": "2020-01-31T22:22:30Z"}, "committer": {"name": "Matthew Jasper", "email": "mjjasper1@gmail.com", "date": "2020-02-02T21:46:29Z"}, "message": "Address review comments\n\n* Handle arrays with const-generic lengths\n* Use closure for repeated code.", "tree": {"sha": "62750b99a4fe2be664b5c298be1fd915ff78f038", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/62750b99a4fe2be664b5c298be1fd915ff78f038"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d20646b2d8033f31423b5bda3e56776df115e144", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d20646b2d8033f31423b5bda3e56776df115e144", "html_url": "https://github.com/rust-lang/rust/commit/d20646b2d8033f31423b5bda3e56776df115e144", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d20646b2d8033f31423b5bda3e56776df115e144/comments", "author": {"login": "matthewjasper", "id": 20113453, "node_id": "MDQ6VXNlcjIwMTEzNDUz", "avatar_url": "https://avatars.githubusercontent.com/u/20113453?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matthewjasper", "html_url": "https://github.com/matthewjasper", "followers_url": "https://api.github.com/users/matthewjasper/followers", "following_url": "https://api.github.com/users/matthewjasper/following{/other_user}", "gists_url": "https://api.github.com/users/matthewjasper/gists{/gist_id}", "starred_url": "https://api.github.com/users/matthewjasper/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matthewjasper/subscriptions", "organizations_url": "https://api.github.com/users/matthewjasper/orgs", "repos_url": "https://api.github.com/users/matthewjasper/repos", "events_url": "https://api.github.com/users/matthewjasper/events{/privacy}", "received_events_url": "https://api.github.com/users/matthewjasper/received_events", "type": "User", "site_admin": false}, "committer": {"login": "matthewjasper", "id": 20113453, "node_id": "MDQ6VXNlcjIwMTEzNDUz", "avatar_url": "https://avatars.githubusercontent.com/u/20113453?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matthewjasper", "html_url": "https://github.com/matthewjasper", "followers_url": "https://api.github.com/users/matthewjasper/followers", "following_url": "https://api.github.com/users/matthewjasper/following{/other_user}", "gists_url": "https://api.github.com/users/matthewjasper/gists{/gist_id}", "starred_url": "https://api.github.com/users/matthewjasper/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matthewjasper/subscriptions", "organizations_url": "https://api.github.com/users/matthewjasper/orgs", "repos_url": "https://api.github.com/users/matthewjasper/repos", "events_url": "https://api.github.com/users/matthewjasper/events{/privacy}", "received_events_url": "https://api.github.com/users/matthewjasper/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d1965216a34dc2831cf44d2e15ad9d78403d10cc", "url": "https://api.github.com/repos/rust-lang/rust/commits/d1965216a34dc2831cf44d2e15ad9d78403d10cc", "html_url": "https://github.com/rust-lang/rust/commit/d1965216a34dc2831cf44d2e15ad9d78403d10cc"}], "stats": {"total": 68, "additions": 36, "deletions": 32}, "files": [{"sha": "6191d304719cb253240d43ae059846b82cc84849", "filename": "src/librustc/ty/util.rs", "status": "modified", "additions": 22, "deletions": 11, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/d20646b2d8033f31423b5bda3e56776df115e144/src%2Flibrustc%2Fty%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d20646b2d8033f31423b5bda3e56776df115e144/src%2Flibrustc%2Fty%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Futil.rs?ref=d20646b2d8033f31423b5bda3e56776df115e144", "patch": "@@ -18,6 +18,7 @@ use rustc_hir::def::DefKind;\n use rustc_hir::def_id::DefId;\n use rustc_macros::HashStable;\n use rustc_span::Span;\n+use rustc_target::abi::TargetDataLayout;\n use smallvec::SmallVec;\n use std::{cmp, fmt};\n use syntax::ast;\n@@ -726,7 +727,7 @@ impl<'tcx> ty::TyS<'tcx> {\n     #[inline]\n     pub fn needs_drop(&'tcx self, tcx: TyCtxt<'tcx>, param_env: ty::ParamEnv<'tcx>) -> bool {\n         // Avoid querying in simple cases.\n-        match needs_drop_components(self) {\n+        match needs_drop_components(self, &tcx.data_layout) {\n             Err(AlwaysRequiresDrop) => true,\n             Ok(components) => {\n                 let query_ty = match *components {\n@@ -736,7 +737,7 @@ impl<'tcx> ty::TyS<'tcx> {\n                     [component_ty] => component_ty,\n                     _ => self,\n                 };\n-                // This doesn't depend on regions, so try to minimize distinct.\n+                // This doesn't depend on regions, so try to minimize distinct\n                 // query keys used.\n                 let erased = tcx.normalize_erasing_regions(param_env, query_ty);\n                 tcx.needs_drop_raw(param_env.and(erased))\n@@ -992,7 +993,10 @@ impl<'tcx> ExplicitSelf<'tcx> {\n /// Returns a list of types such that the given type needs drop if and only if\n /// *any* of the returned types need drop. Returns `Err(AlwaysRequiresDrop)` if\n /// this type always needs drop.\n-pub fn needs_drop_components(ty: Ty<'tcx>) -> Result<SmallVec<[Ty<'tcx>; 4]>, AlwaysRequiresDrop> {\n+pub fn needs_drop_components(\n+    ty: Ty<'tcx>,\n+    target_layout: &TargetDataLayout,\n+) -> Result<SmallVec<[Ty<'tcx>; 2]>, AlwaysRequiresDrop> {\n     match ty.kind {\n         ty::Infer(ty::FreshIntTy(_))\n         | ty::Infer(ty::FreshFloatTy(_))\n@@ -1017,18 +1021,25 @@ pub fn needs_drop_components(ty: Ty<'tcx>) -> Result<SmallVec<[Ty<'tcx>; 4]>, Al\n         // state transformation pass\n         ty::Generator(..) | ty::Dynamic(..) | ty::Error => Err(AlwaysRequiresDrop),\n \n-        ty::Slice(ty) => needs_drop_components(ty),\n-        ty::Array(elem_ty, ..) => {\n-            match needs_drop_components(elem_ty) {\n+        ty::Slice(ty) => needs_drop_components(ty, target_layout),\n+        ty::Array(elem_ty, size) => {\n+            match needs_drop_components(elem_ty, target_layout) {\n                 Ok(v) if v.is_empty() => Ok(v),\n-                // Arrays of size zero don't need drop, even if their element\n-                // type does.\n-                _ => Ok(smallvec![ty]),\n+                res => match size.val.try_to_bits(target_layout.pointer_size) {\n+                    // Arrays of size zero don't need drop, even if their element\n+                    // type does.\n+                    Some(0) => Ok(SmallVec::new()),\n+                    Some(_) => res,\n+                    // We don't know which of the cases above we are in, so\n+                    // return the whole type and let the caller decide what to\n+                    // do.\n+                    None => Ok(smallvec![ty]),\n+                },\n             }\n         }\n         // If any field needs drop, then the whole tuple does.\n-        ty::Tuple(..) => ty.tuple_fields().try_fold(SmallVec::new(), |mut acc, elem| {\n-            acc.extend(needs_drop_components(elem)?);\n+        ty::Tuple(..) => ty.tuple_fields().try_fold(SmallVec::new(), move |mut acc, elem| {\n+            acc.extend(needs_drop_components(elem, target_layout)?);\n             Ok(acc)\n         }),\n "}, {"sha": "c01b3e384aec53fd4251295c0a7cf1e09343e2de", "filename": "src/librustc_ty/needs_drop.rs", "status": "modified", "additions": 14, "deletions": 21, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/d20646b2d8033f31423b5bda3e56776df115e144/src%2Flibrustc_ty%2Fneeds_drop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d20646b2d8033f31423b5bda3e56776df115e144/src%2Flibrustc_ty%2Fneeds_drop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_ty%2Fneeds_drop.rs?ref=d20646b2d8033f31423b5bda3e56776df115e144", "patch": "@@ -76,30 +76,25 @@ where\n                 return Some(Err(AlwaysRequiresDrop));\n             }\n \n-            let components = match needs_drop_components(ty) {\n+            let components = match needs_drop_components(ty, &tcx.data_layout) {\n                 Err(e) => return Some(Err(e)),\n                 Ok(components) => components,\n             };\n             debug!(\"needs_drop_components({:?}) = {:?}\", ty, components);\n \n+            let queue_type = move |this: &mut Self, component: Ty<'tcx>| {\n+                if this.seen_tys.insert(component) {\n+                    this.unchecked_tys.push((component, level + 1));\n+                }\n+            };\n+\n             for component in components {\n                 match component.kind {\n                     _ if component.is_copy_modulo_regions(tcx, self.param_env, DUMMY_SP) => (),\n \n-                    ty::Array(elem_ty, len) => {\n-                        // Zero-length arrays never contain anything to drop.\n-                        if len.try_eval_usize(tcx, self.param_env) != Some(0) {\n-                            if self.seen_tys.insert(elem_ty) {\n-                                self.unchecked_tys.push((elem_ty, level + 1));\n-                            }\n-                        }\n-                    }\n-\n                     ty::Closure(def_id, substs) => {\n                         for upvar_ty in substs.as_closure().upvar_tys(def_id, tcx) {\n-                            if self.seen_tys.insert(upvar_ty) {\n-                                self.unchecked_tys.push((upvar_ty, level + 1));\n-                            }\n+                            queue_type(self, upvar_ty);\n                         }\n                     }\n \n@@ -116,21 +111,19 @@ where\n                                 self.param_env,\n                                 required_ty.subst(tcx, substs),\n                             );\n-                            if self.seen_tys.insert(subst_ty) {\n-                                self.unchecked_tys.push((subst_ty, level + 1));\n-                            }\n+                            queue_type(self, subst_ty);\n                         }\n                     }\n-                    ty::Opaque(..) | ty::Projection(..) | ty::Param(_) => {\n+                    ty::Array(..) | ty::Opaque(..) | ty::Projection(..) | ty::Param(_) => {\n                         if ty == component {\n-                            // Return the type to the caller so they can decide\n-                            // what to do with it.\n+                            // Return the type to the caller: they may be able\n+                            // to normalize further than we can.\n                             return Some(Ok(component));\n-                        } else if self.seen_tys.insert(component) {\n+                        } else {\n                             // Store the type for later. We can't return here\n                             // because we would then lose any other components\n                             // of the type.\n-                            self.unchecked_tys.push((component, level + 1));\n+                            queue_type(self, component);\n                         }\n                     }\n                     _ => return Some(Err(AlwaysRequiresDrop)),"}]}