{"sha": "f98f6c717a6e709b9f0edd3cf0ea4f18e2ca9767", "node_id": "MDY6Q29tbWl0NzI0NzEyOmY5OGY2YzcxN2E2ZTcwOWI5ZjBlZGQzY2YwZWE0ZjE4ZTJjYTk3Njc=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2017-02-04T06:18:32Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2017-02-04T06:18:32Z"}, "message": "Pass -fPIC to native compiles on 32-bit\n\nThis is apparently a regression from 1.14.0 to 1.15.0. Previously we\npassed `-fPIC` to C compilers on i686 targets, but the `gcc` crate\napparently [explicitly] didn't do this. I don't recall why that was\navoided but it was [previously passed by the makefiles][mk] and this\nseems to have [caused a regression][regression] in Firefox, so this\ncommit reverts back to passing `-fPIC`.\n\n[explicitly]: https://github.com/alexcrichton/gcc-rs/commit/362bdf20\n[mk]: https://github.com/rust-lang/rust/blob/c781fc4a/mk/cfg/i686-unknown-linux-gnu.mk#L11\n[regression]: https://bugzilla.mozilla.org/show_bug.cgi?id=1336155", "tree": {"sha": "be7381585575d9cb64d8632876fbe4e221d13cf2", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/be7381585575d9cb64d8632876fbe4e221d13cf2"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f98f6c717a6e709b9f0edd3cf0ea4f18e2ca9767", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f98f6c717a6e709b9f0edd3cf0ea4f18e2ca9767", "html_url": "https://github.com/rust-lang/rust/commit/f98f6c717a6e709b9f0edd3cf0ea4f18e2ca9767", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f98f6c717a6e709b9f0edd3cf0ea4f18e2ca9767/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c781fc4a6a8af287f7abe141f035a638bc0165c3", "url": "https://api.github.com/repos/rust-lang/rust/commits/c781fc4a6a8af287f7abe141f035a638bc0165c3", "html_url": "https://github.com/rust-lang/rust/commit/c781fc4a6a8af287f7abe141f035a638bc0165c3"}], "stats": {"total": 1008, "additions": 590, "deletions": 418}, "files": [{"sha": "288a8b658335f5245b319659ef42a27b7ca4050f", "filename": "src/Cargo.lock", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/f98f6c717a6e709b9f0edd3cf0ea4f18e2ca9767/src%2FCargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/f98f6c717a6e709b9f0edd3cf0ea4f18e2ca9767/src%2FCargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2FCargo.lock?ref=f98f6c717a6e709b9f0edd3cf0ea4f18e2ca9767", "patch": "@@ -19,7 +19,7 @@ version = \"0.0.0\"\n dependencies = [\n  \"build_helper 0.1.0\",\n  \"core 0.0.0\",\n- \"gcc 0.3.40 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"gcc 0.3.43 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"libc 0.0.0\",\n ]\n \n@@ -42,7 +42,7 @@ dependencies = [\n  \"build_helper 0.1.0\",\n  \"cmake 0.1.18 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"filetime 0.1.10 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"gcc 0.3.40 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"gcc 0.3.43 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"getopts 0.2.14 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"libc 0.2.17 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"num_cpus 0.2.13 (registry+https://github.com/rust-lang/crates.io-index)\",\n@@ -74,7 +74,7 @@ name = \"cmake\"\n version = \"0.1.18\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n- \"gcc 0.3.40 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"gcc 0.3.43 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n [[package]]\n@@ -91,7 +91,7 @@ name = \"compiler_builtins\"\n version = \"0.0.0\"\n dependencies = [\n  \"core 0.0.0\",\n- \"gcc 0.3.40 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"gcc 0.3.43 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n [[package]]\n@@ -132,7 +132,7 @@ name = \"flate\"\n version = \"0.0.0\"\n dependencies = [\n  \"build_helper 0.1.0\",\n- \"gcc 0.3.40 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"gcc 0.3.43 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n [[package]]\n@@ -141,7 +141,7 @@ version = \"0.0.0\"\n \n [[package]]\n name = \"gcc\"\n-version = \"0.3.40\"\n+version = \"0.3.43\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n \n [[package]]\n@@ -396,7 +396,7 @@ name = \"rustc_llvm\"\n version = \"0.0.0\"\n dependencies = [\n  \"build_helper 0.1.0\",\n- \"gcc 0.3.40 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"gcc 0.3.43 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"rustc_bitflags 0.0.0\",\n ]\n \n@@ -539,7 +539,7 @@ version = \"0.0.0\"\n dependencies = [\n  \"arena 0.0.0\",\n  \"build_helper 0.1.0\",\n- \"gcc 0.3.40 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"gcc 0.3.43 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"log 0.0.0\",\n  \"rustc 0.0.0\",\n  \"rustc_back 0.0.0\",\n@@ -571,7 +571,7 @@ dependencies = [\n  \"collections 0.0.0\",\n  \"compiler_builtins 0.0.0\",\n  \"core 0.0.0\",\n- \"gcc 0.3.40 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"gcc 0.3.43 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"libc 0.0.0\",\n  \"panic_abort 0.0.0\",\n  \"panic_unwind 0.0.0\",\n@@ -661,7 +661,7 @@ dependencies = [\n \"checksum cmake 0.1.18 (registry+https://github.com/rust-lang/crates.io-index)\" = \"0e5bcf27e097a184c1df4437654ed98df3d7a516e8508a6ba45d8b092bbdf283\"\n \"checksum env_logger 0.3.5 (registry+https://github.com/rust-lang/crates.io-index)\" = \"15abd780e45b3ea4f76b4e9a26ff4843258dd8a3eed2775a0e7368c2e7936c2f\"\n \"checksum filetime 0.1.10 (registry+https://github.com/rust-lang/crates.io-index)\" = \"5363ab8e4139b8568a6237db5248646e5a8a2f89bd5ccb02092182b11fd3e922\"\n-\"checksum gcc 0.3.40 (registry+https://github.com/rust-lang/crates.io-index)\" = \"872db9e59486ef2b14f8e8c10e9ef02de2bccef6363d7f34835dedb386b3d950\"\n+\"checksum gcc 0.3.43 (registry+https://github.com/rust-lang/crates.io-index)\" = \"c07c758b972368e703a562686adb39125707cc1ef3399da8c019fc6c2498a75d\"\n \"checksum getopts 0.2.14 (registry+https://github.com/rust-lang/crates.io-index)\" = \"d9047cfbd08a437050b363d35ef160452c5fe8ea5187ae0a624708c91581d685\"\n \"checksum libc 0.2.17 (registry+https://github.com/rust-lang/crates.io-index)\" = \"044d1360593a78f5c8e5e710beccdc24ab71d1f01bc19a29bcacdba22e8475d8\"\n \"checksum log 0.3.6 (registry+https://github.com/rust-lang/crates.io-index)\" = \"ab83497bf8bf4ed2a74259c1c802351fcd67a65baa86394b6ba73c36f4838054\""}, {"sha": "69e2a953a176d45606baf48182ad85c5c2529e8c", "filename": "src/vendor/gcc/.cargo-checksum.json", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f98f6c717a6e709b9f0edd3cf0ea4f18e2ca9767/src%2Fvendor%2Fgcc%2F.cargo-checksum.json", "raw_url": "https://github.com/rust-lang/rust/raw/f98f6c717a6e709b9f0edd3cf0ea4f18e2ca9767/src%2Fvendor%2Fgcc%2F.cargo-checksum.json", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fvendor%2Fgcc%2F.cargo-checksum.json?ref=f98f6c717a6e709b9f0edd3cf0ea4f18e2ca9767", "patch": "@@ -1 +1 @@\n-{\"files\":{\".cargo-ok\":\"e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855\",\".gitignore\":\"f9b1ca6ae27d1c18215265024629a8960c31379f206d9ed20f64e0b2dcf79805\",\".travis.yml\":\"675ffe583db77282d010306f29e6d81e5070ab081deddd0300137dfbd2cb83de\",\"Cargo.toml\":\"19bb617b74de761515ef5d087fd0e30912fda1d7c22fd04fa211236dab99a509\",\"LICENSE-APACHE\":\"a60eea817514531668d7e00765731449fe14d059d3249e0bc93b36de45f759f2\",\"LICENSE-MIT\":\"378f5840b258e2779c39418f3f2d7b2ba96f1c7917dd6be0713f88305dbda397\",\"README.md\":\"ecb2d93f4c81edbd48d8742ff7887dc0a4530a5890967839090bbc972d49bebe\",\"appveyor.yml\":\"46c77d913eaa45871296942c2cd96ef092c9dcaf19201cb5c500a5107faeb06f\",\"src/bin/gcc-shim.rs\":\"11edfe1fc6f932bd42ffffda5145833302bc163e0b87dc0d54f4bd0997ad4708\",\"src/lib.rs\":\"7e7c60beccfdd145e876da81bb07dd09c5248dab0b26d93190bab4242799d51a\",\"src/registry.rs\":\"3e2a42581ebb82e325dd5600c6571cef937b35003b2927dc618967f5238a2058\",\"src/windows_registry.rs\":\"1f4211caec5a192b5f05c8a47efb27aa6a0ab976c659b9318a0cf603a28d6746\",\"tests/cc_env.rs\":\"d92c5e3d3d43ac244e63b2cd2c93a521fcf124bf1ccf8d4c6bfa7f8333d88976\",\"tests/support/mod.rs\":\"f4dad5a8133c3dd6678d9a3de057b82e624ef547b9b3e4ac9508a48962fc387b\",\"tests/test.rs\":\"164220f11be2eebc20315826513999970660a82feff8cc4b15b4e9d73d98324e\"},\"package\":\"872db9e59486ef2b14f8e8c10e9ef02de2bccef6363d7f34835dedb386b3d950\"}\n\\ No newline at end of file\n+{\"files\":{\".cargo-ok\":\"e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855\",\".gitignore\":\"4cc6445feac7e9a1f8f1e1c51cc3afd0cf7bb931e3c5a6f18c41258401652702\",\".travis.yml\":\"e68f9d10a8e367890cf734239c39952ee480cf0e8da9520b377df4a2b8ccc9e8\",\"Cargo.toml\":\"4c5eb683d4c57fff819ebf564a8db93b5c87284993def6bc066ba1e311d5b090\",\"LICENSE-APACHE\":\"a60eea817514531668d7e00765731449fe14d059d3249e0bc93b36de45f759f2\",\"LICENSE-MIT\":\"378f5840b258e2779c39418f3f2d7b2ba96f1c7917dd6be0713f88305dbda397\",\"README.md\":\"b1a639560fd536f2c3ab708a8e1066b675edd4d018dfa4e5e18d0d7327d81c15\",\"appveyor.yml\":\"46c77d913eaa45871296942c2cd96ef092c9dcaf19201cb5c500a5107faeb06f\",\"src/bin/gcc-shim.rs\":\"d6be9137cb48b86891e7b263adbf492e1193ffe682db9ba4a88eb1079b874b58\",\"src/lib.rs\":\"eb4ca086dd2ffa5e30f022f556d0def6d1142160da392afb328393b3f435e8f7\",\"src/registry.rs\":\"3876ef9573e3bbc050aef41a684b9a510cc1a91b15ae874fe032cf4377b4d116\",\"src/windows_registry.rs\":\"36c6a7f8322407faff2dcfd4789d0876d034885944bc0340ac7c1f7cbfc307f1\",\"tests/cc_env.rs\":\"d92c5e3d3d43ac244e63b2cd2c93a521fcf124bf1ccf8d4c6bfa7f8333d88976\",\"tests/support/mod.rs\":\"56bcfd1e2ff5ae8e581c71229444a3d96094bf689808808dd80e315bd6632083\",\"tests/test.rs\":\"b63e74d571e7d585edc53693bcf0caae88fc040613ace91e32437d4a62cddb6a\"},\"package\":\"c07c758b972368e703a562686adb39125707cc1ef3399da8c019fc6c2498a75d\"}\n\\ No newline at end of file"}, {"sha": "3b874ca574de0550d0ee2608988aeb9655940377", "filename": "src/vendor/gcc/.gitignore", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f98f6c717a6e709b9f0edd3cf0ea4f18e2ca9767/src%2Fvendor%2Fgcc%2F.gitignore", "raw_url": "https://github.com/rust-lang/rust/raw/f98f6c717a6e709b9f0edd3cf0ea4f18e2ca9767/src%2Fvendor%2Fgcc%2F.gitignore", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fvendor%2Fgcc%2F.gitignore?ref=f98f6c717a6e709b9f0edd3cf0ea4f18e2ca9767", "patch": "@@ -1,2 +1,4 @@\n target\n Cargo.lock\n+.idea\n+*.iml"}, {"sha": "10d3d13d876bcee206e5c1171d5038537bf0dd22", "filename": "src/vendor/gcc/.travis.yml", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/f98f6c717a6e709b9f0edd3cf0ea4f18e2ca9767/src%2Fvendor%2Fgcc%2F.travis.yml", "raw_url": "https://github.com/rust-lang/rust/raw/f98f6c717a6e709b9f0edd3cf0ea4f18e2ca9767/src%2Fvendor%2Fgcc%2F.travis.yml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fvendor%2Fgcc%2F.travis.yml?ref=f98f6c717a6e709b9f0edd3cf0ea4f18e2ca9767", "patch": "@@ -3,6 +3,13 @@ rust:\n   - stable\n   - beta\n   - nightly\n+matrix:\n+  include:\n+    # Minimum version supported\n+    - rust: 1.6.0\n+      install:\n+      script: cargo build\n+\n sudo: false\n install:\n   - if [ \"$TRAVIS_OS_NAME\" = \"linux\" ]; then OS=unknown-linux-gnu; else OS=apple-darwin; fi"}, {"sha": "9fee7788cefc85ef8c593130cc080729563efda4", "filename": "src/vendor/gcc/Cargo.toml", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/f98f6c717a6e709b9f0edd3cf0ea4f18e2ca9767/src%2Fvendor%2Fgcc%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/f98f6c717a6e709b9f0edd3cf0ea4f18e2ca9767/src%2Fvendor%2Fgcc%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fvendor%2Fgcc%2FCargo.toml?ref=f98f6c717a6e709b9f0edd3cf0ea4f18e2ca9767", "patch": "@@ -1,20 +1,24 @@\n [package]\n \n name = \"gcc\"\n-version = \"0.3.40\"\n+version = \"0.3.43\"\n authors = [\"Alex Crichton <alex@alexcrichton.com>\"]\n license = \"MIT/Apache-2.0\"\n repository = \"https://github.com/alexcrichton/gcc-rs\"\n-documentation = \"http://alexcrichton.com/gcc-rs\"\n+documentation = \"https://docs.rs/gcc\"\n description = \"\"\"\n A build-time dependency for Cargo build scripts to assist in invoking the native\n C compiler to compile native C code into a static archive to be linked into Rust\n code.\n \"\"\"\n keywords = [\"build-dependencies\"]\n \n+[badges]\n+travis-ci = { repository = \"alexcrichton/gcc-rs\" }\n+appveyor = { repository = \"alexcrichton/gcc-rs\" }\n+\n [dependencies]\n-rayon = { version = \"0.4\", optional = true }\n+rayon = { version = \"0.6\", optional = true }\n \n [features]\n parallel = [\"rayon\"]"}, {"sha": "2d3e5ed7387549a5fb81b5caea6c0b3931866f1a", "filename": "src/vendor/gcc/README.md", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f98f6c717a6e709b9f0edd3cf0ea4f18e2ca9767/src%2Fvendor%2Fgcc%2FREADME.md", "raw_url": "https://github.com/rust-lang/rust/raw/f98f6c717a6e709b9f0edd3cf0ea4f18e2ca9767/src%2Fvendor%2Fgcc%2FREADME.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fvendor%2Fgcc%2FREADME.md?ref=f98f6c717a6e709b9f0edd3cf0ea4f18e2ca9767", "patch": "@@ -5,7 +5,7 @@ A library to compile C/C++ code into a Rust library/application.\n [![Build Status](https://travis-ci.org/alexcrichton/gcc-rs.svg?branch=master)](https://travis-ci.org/alexcrichton/gcc-rs)\n [![Build status](https://ci.appveyor.com/api/projects/status/onu270iw98h81nwv?svg=true)](https://ci.appveyor.com/project/alexcrichton/gcc-rs)\n \n-[Documentation](http://alexcrichton.com/gcc-rs)\n+[Documentation](https://docs.rs/gcc)\n \n A simple library meant to be used as a build dependency with Cargo packages in\n order to build a set of C/C++ files into a static archive. Note that while this\n@@ -106,7 +106,9 @@ gcc = { version = \"0.3\", features = [\"parallel\"] }\n ```\n \n By default gcc-rs will limit parallelism to `$NUM_JOBS`, or if not present it\n-will limit it to the number of cpus on the machine.\n+will limit it to the number of cpus on the machine. If you are using cargo,\n+use `-jN` option of `build`, `test` and `run` commands as `$NUM_JOBS`\n+is supplied by cargo.\n \n ## Compile-time Requirements\n "}, {"sha": "7fd0ea8fa84b72bbf8da4aeb92d4a91021f46514", "filename": "src/vendor/gcc/src/bin/gcc-shim.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f98f6c717a6e709b9f0edd3cf0ea4f18e2ca9767/src%2Fvendor%2Fgcc%2Fsrc%2Fbin%2Fgcc-shim.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f98f6c717a6e709b9f0edd3cf0ea4f18e2ca9767/src%2Fvendor%2Fgcc%2Fsrc%2Fbin%2Fgcc-shim.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fvendor%2Fgcc%2Fsrc%2Fbin%2Fgcc-shim.rs?ref=f98f6c717a6e709b9f0edd3cf0ea4f18e2ca9767", "patch": "@@ -10,14 +10,14 @@ fn main() {\n     for i in 0.. {\n         let candidate = out_dir.join(format!(\"out{}\", i));\n         if candidate.exists() {\n-            continue\n+            continue;\n         }\n         let mut f = File::create(candidate).unwrap();\n         for arg in env::args().skip(1) {\n             writeln!(f, \"{}\", arg).unwrap();\n         }\n \n         File::create(out_dir.join(\"libfoo.a\")).unwrap();\n-        break\n+        break;\n     }\n }"}, {"sha": "f2d9da7f694218d8016fdb0787c4b8510e99887f", "filename": "src/vendor/gcc/src/lib.rs", "status": "modified", "additions": 368, "deletions": 247, "changes": 615, "blob_url": "https://github.com/rust-lang/rust/blob/f98f6c717a6e709b9f0edd3cf0ea4f18e2ca9767/src%2Fvendor%2Fgcc%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f98f6c717a6e709b9f0edd3cf0ea4f18e2ca9767/src%2Fvendor%2Fgcc%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fvendor%2Fgcc%2Fsrc%2Flib.rs?ref=f98f6c717a6e709b9f0edd3cf0ea4f18e2ca9767", "patch": "@@ -42,7 +42,7 @@\n //! }\n //! ```\n \n-#![doc(html_root_url = \"http://alexcrichton.com/gcc-rs\")]\n+#![doc(html_root_url = \"https://docs.rs/gcc/0.3\")]\n #![cfg_attr(test, deny(warnings))]\n #![deny(missing_docs)]\n \n@@ -52,10 +52,10 @@ extern crate rayon;\n use std::env;\n use std::ffi::{OsString, OsStr};\n use std::fs;\n-use std::io;\n use std::path::{PathBuf, Path};\n use std::process::{Command, Stdio};\n-use std::io::{BufReader, BufRead, Write};\n+use std::io::{self, BufReader, BufRead, Read, Write};\n+use std::thread;\n \n #[cfg(windows)]\n mod registry;\n@@ -94,6 +94,52 @@ pub struct Tool {\n     path: PathBuf,\n     args: Vec<OsString>,\n     env: Vec<(OsString, OsString)>,\n+    family: ToolFamily\n+}\n+\n+/// Represents the family of tools this tool belongs to.\n+///\n+/// Each family of tools differs in how and what arguments they accept.\n+///\n+/// Detection of a family is done on best-effort basis and may not accurately reflect the tool.\n+#[derive(Copy, Clone, Debug)]\n+enum ToolFamily {\n+    /// Tool is GNU Compiler Collection-like.\n+    Gnu,\n+    /// Tool is Clang-like. It differs from the GCC in a sense that it accepts superset of flags\n+    /// and its cross-compilation approach is different.\n+    Clang,\n+    /// Tool is the MSVC cl.exe.\n+    Msvc,\n+}\n+\n+impl ToolFamily {\n+    /// What the flag to request debug info for this family of tools look like\n+    fn debug_flag(&self) -> &'static str {\n+        match *self {\n+            ToolFamily::Msvc => \"/Z7\",\n+            ToolFamily::Gnu |\n+            ToolFamily::Clang => \"-g\",\n+        }\n+    }\n+\n+    /// What the flag to include directories into header search path looks like\n+    fn include_flag(&self) -> &'static str {\n+        match *self {\n+            ToolFamily::Msvc => \"/I\",\n+            ToolFamily::Gnu |\n+            ToolFamily::Clang => \"-I\",\n+        }\n+    }\n+\n+    /// What the flag to request macro-expanded source output looks like\n+    fn expand_flag(&self) -> &'static str {\n+        match *self {\n+            ToolFamily::Msvc => \"/E\",\n+            ToolFamily::Gnu |\n+            ToolFamily::Clang => \"-E\",\n+        }\n+    }\n }\n \n /// Compile a library from the given set of input C files.\n@@ -114,7 +160,7 @@ pub fn compile_library(output: &str, files: &[&str]) {\n     for f in files.iter() {\n         c.file(*f);\n     }\n-    c.compile(output)\n+    c.compile(output);\n }\n \n impl Config {\n@@ -194,8 +240,7 @@ impl Config {\n     /// otherwise cargo will link against the specified library.\n     ///\n     /// The given library name must not contain the `lib` prefix.\n-    pub fn cpp_link_stdlib(&mut self, cpp_link_stdlib: Option<&str>)\n-                           -> &mut Config {\n+    pub fn cpp_link_stdlib(&mut self, cpp_link_stdlib: Option<&str>) -> &mut Config {\n         self.cpp_link_stdlib = Some(cpp_link_stdlib.map(|s| s.into()));\n         self\n     }\n@@ -220,8 +265,7 @@ impl Config {\n     /// be used, otherwise `-stdlib` is added to the compile invocation.\n     ///\n     /// The given library name must not contain the `lib` prefix.\n-    pub fn cpp_set_stdlib(&mut self, cpp_set_stdlib: Option<&str>)\n-                          -> &mut Config {\n+    pub fn cpp_set_stdlib(&mut self, cpp_set_stdlib: Option<&str>) -> &mut Config {\n         self.cpp_set_stdlib = cpp_set_stdlib.map(|s| s.into());\n         self.cpp_link_stdlib(cpp_set_stdlib);\n         self\n@@ -322,7 +366,8 @@ impl Config {\n \n     #[doc(hidden)]\n     pub fn __set_env<A, B>(&mut self, a: A, b: B) -> &mut Config\n-        where A: AsRef<OsStr>, B: AsRef<OsStr>\n+        where A: AsRef<OsStr>,\n+              B: AsRef<OsStr>\n     {\n         self.env.push((a.as_ref().to_owned(), b.as_ref().to_owned()));\n         self\n@@ -355,18 +400,18 @@ impl Config {\n \n         if self.get_target().contains(\"msvc\") {\n             let compiler = self.get_base_compiler();\n-            let atlmfc_lib = compiler.env().iter().find(|&&(ref var, _)| {\n-                var == OsStr::new(\"LIB\")\n-            }).and_then(|&(_, ref lib_paths)| {\n-                env::split_paths(lib_paths).find(|path| {\n-                    let sub = Path::new(\"atlmfc/lib\");\n-                    path.ends_with(sub) || path.parent().map_or(false, |p| p.ends_with(sub))\n-                })\n-            });\n+            let atlmfc_lib = compiler.env()\n+                .iter()\n+                .find(|&&(ref var, _)| var.as_os_str() == OsStr::new(\"LIB\"))\n+                .and_then(|&(_, ref lib_paths)| {\n+                    env::split_paths(lib_paths).find(|path| {\n+                        let sub = Path::new(\"atlmfc/lib\");\n+                        path.ends_with(sub) || path.parent().map_or(false, |p| p.ends_with(sub))\n+                    })\n+                });\n \n             if let Some(atlmfc_lib) = atlmfc_lib {\n-                self.print(&format!(\"cargo:rustc-link-search=native={}\",\n-                                    atlmfc_lib.display()));\n+                self.print(&format!(\"cargo:rustc-link-search=native={}\", atlmfc_lib.display()));\n             }\n         }\n \n@@ -394,9 +439,7 @@ impl Config {\n         }\n         drop(rayon::initialize(cfg));\n \n-        objs.par_iter().weight_max().for_each(|&(ref src, ref dst)| {\n-            self.compile_object(src, dst)\n-        })\n+        objs.par_iter().weight_max().for_each(|&(ref src, ref dst)| self.compile_object(src, dst));\n     }\n \n     #[cfg(not(feature = \"parallel\"))]\n@@ -417,8 +460,12 @@ impl Config {\n             for &(ref a, ref b) in self.env.iter() {\n                 cmd.env(a, b);\n             }\n-            (cmd, compiler.path.file_name().unwrap()\n-                          .to_string_lossy().into_owned())\n+            (cmd,\n+             compiler.path\n+                 .file_name()\n+                 .unwrap()\n+                 .to_string_lossy()\n+                 .into_owned())\n         };\n         if msvc && is_asm {\n             cmd.arg(\"/Fo\").arg(dst);\n@@ -429,12 +476,35 @@ impl Config {\n         } else {\n             cmd.arg(\"-o\").arg(&dst);\n         }\n-        cmd.arg(if msvc {\"/c\"} else {\"-c\"});\n+        cmd.arg(if msvc { \"/c\" } else { \"-c\" });\n         cmd.arg(file);\n \n         run(&mut cmd, &name);\n     }\n \n+    /// Run the compiler, returning the macro-expanded version of the input files.\n+    ///\n+    /// This is only relevant for C and C++ files.\n+    pub fn expand(&self) -> Vec<u8> {\n+        let compiler = self.get_compiler();\n+        let mut cmd = compiler.to_command();\n+        for &(ref a, ref b) in self.env.iter() {\n+            cmd.env(a, b);\n+        }\n+        cmd.arg(compiler.family.expand_flag());\n+        for file in self.files.iter() {\n+            cmd.arg(file);\n+        }\n+\n+        let name = compiler.path\n+            .file_name()\n+            .unwrap()\n+            .to_string_lossy()\n+            .into_owned();\n+\n+        run(&mut cmd, &name)\n+    }\n+\n     /// Get the compiler that's in use for this configuration.\n     ///\n     /// This function will return a `Tool` which represents the culmination\n@@ -451,136 +521,159 @@ impl Config {\n     /// falling back to the default configuration.\n     pub fn get_compiler(&self) -> Tool {\n         let opt_level = self.get_opt_level();\n-        let debug = self.get_debug();\n         let target = self.get_target();\n-        let msvc = target.contains(\"msvc\");\n-        self.print(&format!(\"debug={} opt-level={}\", debug, opt_level));\n \n         let mut cmd = self.get_base_compiler();\n-        let nvcc = cmd.path.to_str()\n-            .map(|path| path.contains(\"nvcc\"))\n+        let nvcc = cmd.path.file_name()\n+            .and_then(|p| p.to_str()).map(|p| p.contains(\"nvcc\"))\n             .unwrap_or(false);\n \n-        if msvc {\n-            cmd.args.push(\"/nologo\".into());\n-            let features = env::var(\"CARGO_CFG_TARGET_FEATURE\")\n-                              .unwrap_or(String::new());\n-            if features.contains(\"crt-static\") {\n-                cmd.args.push(\"/MT\".into());\n-            } else {\n-                cmd.args.push(\"/MD\".into());\n-            }\n-            match &opt_level[..] {\n-                \"z\" | \"s\" => cmd.args.push(\"/Os\".into()),\n-                \"2\" => cmd.args.push(\"/O2\".into()),\n-                \"1\" => cmd.args.push(\"/O1\".into()),\n-                _ => {}\n+        // Non-target flags\n+        // If the flag is not conditioned on target variable, it belongs here :)\n+        match cmd.family {\n+            ToolFamily::Msvc => {\n+                cmd.args.push(\"/nologo\".into());\n+                let features = env::var(\"CARGO_CFG_TARGET_FEATURE\")\n+                                  .unwrap_or(String::new());\n+                if features.contains(\"crt-static\") {\n+                    cmd.args.push(\"/MT\".into());\n+                } else {\n+                    cmd.args.push(\"/MD\".into());\n+                }\n+                match &opt_level[..] {\n+                    \"z\" | \"s\" => cmd.args.push(\"/Os\".into()),\n+                    \"1\" => cmd.args.push(\"/O1\".into()),\n+                    // -O3 is a valid value for gcc and clang compilers, but not msvc. Cap to /O2.\n+                    \"2\" | \"3\" => cmd.args.push(\"/O2\".into()),\n+                    _ => {}\n+                }\n             }\n-            if target.contains(\"i586\") {\n-                cmd.args.push(\"/ARCH:IA32\".into());\n+            ToolFamily::Gnu |\n+            ToolFamily::Clang => {\n+                cmd.args.push(format!(\"-O{}\", opt_level).into());\n+                if !nvcc {\n+                    cmd.args.push(\"-ffunction-sections\".into());\n+                    cmd.args.push(\"-fdata-sections\".into());\n+                    if self.pic.unwrap_or(!target.contains(\"windows-gnu\")) {\n+                        cmd.args.push(\"-fPIC\".into());\n+                    }\n+                } else if self.pic.unwrap_or(false) {\n+                    cmd.args.push(\"-Xcompiler\".into());\n+                    cmd.args.push(\"\\'-fPIC\\'\".into());\n+                }\n             }\n-        } else if nvcc {\n-            cmd.args.push(format!(\"-O{}\", opt_level).into());\n-        } else {\n-            cmd.args.push(format!(\"-O{}\", opt_level).into());\n-            cmd.args.push(\"-ffunction-sections\".into());\n-            cmd.args.push(\"-fdata-sections\".into());\n         }\n         for arg in self.envflags(if self.cpp {\"CXXFLAGS\"} else {\"CFLAGS\"}) {\n             cmd.args.push(arg.into());\n         }\n \n-        if debug {\n-            cmd.args.push(if msvc {\"/Z7\"} else {\"-g\"}.into());\n+        if self.get_debug() {\n+            cmd.args.push(cmd.family.debug_flag().into());\n         }\n \n-        if target.contains(\"-ios\") {\n-            self.ios_flags(&mut cmd);\n-        } else if !msvc {\n-            if target.contains(\"i686\") || target.contains(\"i586\") {\n-                cmd.args.push(\"-m32\".into());\n-            } else if target.contains(\"x86_64\") || target.contains(\"powerpc64\") {\n-                cmd.args.push(\"-m64\".into());\n+        // Target flags\n+        match cmd.family {\n+            ToolFamily::Clang => {\n+                cmd.args.push(format!(\"--target={}\", target).into());\n             }\n-\n-            if !nvcc && self.pic.unwrap_or(!target.contains(\"i686\") && !target.contains(\"windows-gnu\")) {\n-                cmd.args.push(\"-fPIC\".into());\n-            } else if nvcc && self.pic.unwrap_or(false) {\n-                cmd.args.push(\"-Xcompiler\".into());\n-                cmd.args.push(\"\\'-fPIC\\'\".into());\n+            ToolFamily::Msvc => {\n+                if target.contains(\"i586\") {\n+                    cmd.args.push(\"/ARCH:IA32\".into());\n+                }\n             }\n+            ToolFamily::Gnu => {\n+                if target.contains(\"i686\") || target.contains(\"i586\") {\n+                    cmd.args.push(\"-m32\".into());\n+                } else if target.contains(\"x86_64\") || target.contains(\"powerpc64\") {\n+                    cmd.args.push(\"-m64\".into());\n+                }\n \n-            if target.contains(\"musl\") {\n-                cmd.args.push(\"-static\".into());\n-            }\n+                if target.contains(\"musl\") {\n+                    cmd.args.push(\"-static\".into());\n+                }\n \n-            // armv7 targets get to use armv7 instructions\n-            if target.starts_with(\"armv7-unknown-linux-\") {\n-                cmd.args.push(\"-march=armv7-a\".into());\n-            }\n+                // armv7 targets get to use armv7 instructions\n+                if target.starts_with(\"armv7-unknown-linux-\") {\n+                    cmd.args.push(\"-march=armv7-a\".into());\n+                }\n \n-            // On android we can guarantee some extra float instructions\n-            // (specified in the android spec online)\n-            if target.starts_with(\"armv7-linux-androideabi\") {\n-                cmd.args.push(\"-march=armv7-a\".into());\n-                cmd.args.push(\"-mfpu=vfpv3-d16\".into());\n-            }\n+                // On android we can guarantee some extra float instructions\n+                // (specified in the android spec online)\n+                if target.starts_with(\"armv7-linux-androideabi\") {\n+                    cmd.args.push(\"-march=armv7-a\".into());\n+                    cmd.args.push(\"-mfpu=vfpv3-d16\".into());\n+                }\n \n-            // For us arm == armv6 by default\n-            if target.starts_with(\"arm-unknown-linux-\") {\n-                cmd.args.push(\"-march=armv6\".into());\n-                cmd.args.push(\"-marm\".into());\n-            }\n+                // For us arm == armv6 by default\n+                if target.starts_with(\"arm-unknown-linux-\") {\n+                    cmd.args.push(\"-march=armv6\".into());\n+                    cmd.args.push(\"-marm\".into());\n+                }\n \n-            // Turn codegen down on i586 to avoid some instructions.\n-            if target.starts_with(\"i586-unknown-linux-\") {\n-                cmd.args.push(\"-march=pentium\".into());\n-            }\n+                // Turn codegen down on i586 to avoid some instructions.\n+                if target.starts_with(\"i586-unknown-linux-\") {\n+                    cmd.args.push(\"-march=pentium\".into());\n+                }\n \n-            // Set codegen level for i686 correctly\n-            if target.starts_with(\"i686-unknown-linux-\") {\n-                cmd.args.push(\"-march=i686\".into());\n-            }\n+                // Set codegen level for i686 correctly\n+                if target.starts_with(\"i686-unknown-linux-\") {\n+                    cmd.args.push(\"-march=i686\".into());\n+                }\n \n-            // Looks like `musl-gcc` makes is hard for `-m32` to make its way\n-            // all the way to the linker, so we need to actually instruct the\n-            // linker that we're generating 32-bit executables as well. This'll\n-            // typically only be used for build scripts which transitively use\n-            // these flags that try to compile executables.\n-            if target == \"i686-unknown-linux-musl\" {\n-                cmd.args.push(\"-Wl,-melf_i386\".into());\n-            }\n+                // Looks like `musl-gcc` makes is hard for `-m32` to make its way\n+                // all the way to the linker, so we need to actually instruct the\n+                // linker that we're generating 32-bit executables as well. This'll\n+                // typically only be used for build scripts which transitively use\n+                // these flags that try to compile executables.\n+                if target == \"i686-unknown-linux-musl\" {\n+                    cmd.args.push(\"-Wl,-melf_i386\".into());\n+                }\n \n-            if target.starts_with(\"thumb\") {\n-                cmd.args.push(\"-mthumb\".into());\n+                if target.starts_with(\"thumb\") {\n+                    cmd.args.push(\"-mthumb\".into());\n \n-                if target.ends_with(\"eabihf\") {\n-                    cmd.args.push(\"-mfloat-abi=hard\".into())\n+                    if target.ends_with(\"eabihf\") {\n+                        cmd.args.push(\"-mfloat-abi=hard\".into())\n+                    }\n                 }\n-            }\n-            if target.starts_with(\"thumbv6m\") {\n-                cmd.args.push(\"-march=armv6s-m\".into());\n-            }\n-            if target.starts_with(\"thumbv7em\") {\n-                cmd.args.push(\"-march=armv7e-m\".into());\n+                if target.starts_with(\"thumbv6m\") {\n+                    cmd.args.push(\"-march=armv6s-m\".into());\n+                }\n+                if target.starts_with(\"thumbv7em\") {\n+                    cmd.args.push(\"-march=armv7e-m\".into());\n \n-                if target.ends_with(\"eabihf\") {\n-                    cmd.args.push(\"-mfpu=fpv4-sp-d16\".into())\n+                    if target.ends_with(\"eabihf\") {\n+                        cmd.args.push(\"-mfpu=fpv4-sp-d16\".into())\n+                    }\n+                }\n+                if target.starts_with(\"thumbv7m\") {\n+                    cmd.args.push(\"-march=armv7-m\".into());\n                 }\n             }\n-            if target.starts_with(\"thumbv7m\") {\n-                cmd.args.push(\"-march=armv7-m\".into());\n-            }\n         }\n \n-        if self.cpp && !msvc {\n-            if let Some(ref stdlib) = self.cpp_set_stdlib {\n-                cmd.args.push(format!(\"-stdlib=lib{}\", stdlib).into());\n+        if target.contains(\"-ios\") {\n+            // FIXME: potential bug. iOS is always compiled with Clang, but Gcc compiler may be\n+            // detected instead.\n+            self.ios_flags(&mut cmd);\n+        }\n+\n+        if self.cpp {\n+            match (self.cpp_set_stdlib.as_ref(), cmd.family) {\n+                (None, _) => { }\n+                (Some(stdlib), ToolFamily::Gnu) |\n+                (Some(stdlib), ToolFamily::Clang) => {\n+                    cmd.args.push(format!(\"-stdlib=lib{}\", stdlib).into());\n+                }\n+                _ => {\n+                    println!(\"cargo:warning=cpp_set_stdlib is specified, but the {:?} compiler \\\n+                              does not support this option, ignored\", cmd.family);\n+                }\n             }\n         }\n \n         for directory in self.include_directories.iter() {\n-            cmd.args.push(if msvc {\"/I\"} else {\"-I\"}.into());\n+            cmd.args.push(cmd.family.include_flag().into());\n             cmd.args.push(directory.into());\n         }\n \n@@ -589,7 +682,7 @@ impl Config {\n         }\n \n         for &(ref key, ref value) in self.definitions.iter() {\n-            let lead = if msvc {\"/\"} else {\"-\"};\n+            let lead = if let ToolFamily::Msvc = cmd.family {\"/\"} else {\"-\"};\n             if let &Some(ref value) = value {\n                 cmd.args.push(format!(\"{}D{}={}\", lead, key, value).into());\n             } else {\n@@ -601,10 +694,12 @@ impl Config {\n \n     fn msvc_macro_assembler(&self) -> (Command, String) {\n         let target = self.get_target();\n-        let tool = if target.contains(\"x86_64\") {\"ml64.exe\"} else {\"ml.exe\"};\n-        let mut cmd = windows_registry::find(&target, tool).unwrap_or_else(|| {\n-            self.cmd(tool)\n-        });\n+        let tool = if target.contains(\"x86_64\") {\n+            \"ml64.exe\"\n+        } else {\n+            \"ml.exe\"\n+        };\n+        let mut cmd = windows_registry::find(&target, tool).unwrap_or_else(|| self.cmd(tool));\n         for directory in self.include_directories.iter() {\n             cmd.arg(\"/I\").arg(directory);\n         }\n@@ -635,31 +730,37 @@ impl Config {\n         if target.contains(\"msvc\") {\n             let mut cmd = match self.archiver {\n                 Some(ref s) => self.cmd(s),\n-                None => windows_registry::find(&target, \"lib.exe\")\n-                                         .unwrap_or(self.cmd(\"lib.exe\")),\n+                None => windows_registry::find(&target, \"lib.exe\").unwrap_or(self.cmd(\"lib.exe\")),\n             };\n             let mut out = OsString::from(\"/OUT:\");\n             out.push(dst);\n-            run(cmd.arg(out).arg(\"/nologo\")\n-                   .args(objects)\n-                   .args(&self.objects), \"lib.exe\");\n+            run(cmd.arg(out)\n+                    .arg(\"/nologo\")\n+                    .args(objects)\n+                    .args(&self.objects),\n+                \"lib.exe\");\n \n             // The Rust compiler will look for libfoo.a and foo.lib, but the\n             // MSVC linker will also be passed foo.lib, so be sure that both\n             // exist for now.\n             let lib_dst = dst.with_file_name(format!(\"{}.lib\", lib_name));\n             let _ = fs::remove_file(&lib_dst);\n-            fs::hard_link(&dst, &lib_dst).or_else(|_| {\n-                //if hard-link fails, just copy (ignoring the number of bytes written)\n-                fs::copy(&dst, &lib_dst).map(|_| ())\n-            }).ok().expect(\"Copying from {:?} to {:?} failed.\");;\n+            fs::hard_link(&dst, &lib_dst)\n+                .or_else(|_| {\n+                    // if hard-link fails, just copy (ignoring the number of bytes written)\n+                    fs::copy(&dst, &lib_dst).map(|_| ())\n+                })\n+                .ok()\n+                .expect(\"Copying from {:?} to {:?} failed.\");;\n         } else {\n             let ar = self.get_ar();\n             let cmd = ar.file_name().unwrap().to_string_lossy();\n-            run(self.cmd(&ar).arg(\"crs\")\n-                                 .arg(dst)\n-                                 .args(objects)\n-                                 .args(&self.objects), &cmd);\n+            run(self.cmd(&ar)\n+                    .arg(\"crs\")\n+                    .arg(dst)\n+                    .args(objects)\n+                    .args(&self.objects),\n+                &cmd);\n         }\n     }\n \n@@ -677,7 +778,7 @@ impl Config {\n             \"arm64\" | \"aarch64\" => ArchSpec::Device(\"arm64\"),\n             \"i386\" | \"i686\" => ArchSpec::Simulator(\"-m32\"),\n             \"x86_64\" => ArchSpec::Simulator(\"-m64\"),\n-            _ => fail(\"Unknown arch for iOS target\")\n+            _ => fail(\"Unknown arch for iOS target\"),\n         };\n \n         let sdk = match arch {\n@@ -686,7 +787,7 @@ impl Config {\n                 cmd.args.push(arch.into());\n                 cmd.args.push(\"-miphoneos-version-min=7.0\".into());\n                 \"iphoneos\"\n-            },\n+            }\n             ArchSpec::Simulator(arch) => {\n                 cmd.args.push(arch.into());\n                 cmd.args.push(\"-mios-simulator-version-min=7.0\".into());\n@@ -715,12 +816,12 @@ impl Config {\n         for &(ref a, ref b) in self.env.iter() {\n             cmd.env(a, b);\n         }\n-        return cmd\n+        return cmd;\n     }\n \n     fn get_base_compiler(&self) -> Tool {\n         if let Some(ref c) = self.compiler {\n-            return Tool::new(c.clone())\n+            return Tool::new(c.clone());\n         }\n         let host = self.get_host();\n         let target = self.get_target();\n@@ -729,87 +830,88 @@ impl Config {\n         } else {\n             (\"CC\", \"cl.exe\", \"gcc\", \"cc\")\n         };\n-        self.env_tool(env).map(|(tool, args)| {\n-            let mut t = Tool::new(PathBuf::from(tool));\n-            for arg in args {\n-                t.args.push(arg.into());\n-            }\n-            return t\n-        }).or_else(|| {\n-            if target.contains(\"emscripten\") {\n-                if self.cpp {\n-                    Some(Tool::new(PathBuf::from(\"em++\")))\n-                } else {\n-                    Some(Tool::new(PathBuf::from(\"emcc\")))\n+        self.env_tool(env)\n+            .map(|(tool, args)| {\n+                let mut t = Tool::new(PathBuf::from(tool));\n+                for arg in args {\n+                    t.args.push(arg.into());\n                 }\n-            } else {\n-                None\n-            }\n-        }).or_else(|| {\n-            windows_registry::find_tool(&target, \"cl.exe\")\n-        }).unwrap_or_else(|| {\n-            let compiler = if host.contains(\"windows\") &&\n-                              target.contains(\"windows\") {\n-                if target.contains(\"msvc\") {\n-                    msvc.to_string()\n+                return t;\n+            })\n+            .or_else(|| {\n+                if target.contains(\"emscripten\") {\n+                    if self.cpp {\n+                        Some(Tool::new(PathBuf::from(\"em++\")))\n+                    } else {\n+                        Some(Tool::new(PathBuf::from(\"emcc\")))\n+                    }\n                 } else {\n-                    format!(\"{}.exe\", gnu)\n+                    None\n                 }\n-            } else if target.contains(\"android\") {\n-                format!(\"{}-{}\", target, gnu)\n-            } else if self.get_host() != target {\n-                // CROSS_COMPILE is of the form: \"arm-linux-gnueabi-\"\n-                let cc_env = self.getenv(\"CROSS_COMPILE\");\n-                let cross_compile = cc_env.as_ref().map(|s| s.trim_right_matches('-'));\n-                let prefix = cross_compile.or(match &target[..] {\n-                    \"aarch64-unknown-linux-gnu\" => Some(\"aarch64-linux-gnu\"),\n-                    \"arm-unknown-linux-gnueabi\" => Some(\"arm-linux-gnueabi\"),\n-                    \"arm-unknown-linux-gnueabihf\"  => Some(\"arm-linux-gnueabihf\"),\n-                    \"arm-unknown-linux-musleabi\" => Some(\"arm-linux-musleabi\"),\n-                    \"arm-unknown-linux-musleabihf\"  => Some(\"arm-linux-musleabihf\"),\n-                    \"arm-unknown-netbsdelf-eabi\" => Some(\"arm--netbsdelf-eabi\"),\n-                    \"armv6-unknown-netbsdelf-eabihf\" => Some(\"armv6--netbsdelf-eabihf\"),\n-                    \"armv7-unknown-linux-gnueabihf\" => Some(\"arm-linux-gnueabihf\"),\n-                    \"armv7-unknown-linux-musleabihf\" => Some(\"arm-linux-musleabihf\"),\n-                    \"armv7-unknown-netbsdelf-eabihf\" => Some(\"armv7--netbsdelf-eabihf\"),\n-                    \"i686-pc-windows-gnu\" => Some(\"i686-w64-mingw32\"),\n-                    \"i686-unknown-linux-musl\" => Some(\"musl\"),\n-                    \"i686-unknown-netbsdelf\" => Some(\"i486--netbsdelf\"),\n-                    \"mips-unknown-linux-gnu\" => Some(\"mips-linux-gnu\"),\n-                    \"mipsel-unknown-linux-gnu\" => Some(\"mipsel-linux-gnu\"),\n-                    \"mips64-unknown-linux-gnuabi64\" => Some(\"mips64-linux-gnuabi64\"),\n-                    \"mips64el-unknown-linux-gnuabi64\" => Some(\"mips64el-linux-gnuabi64\"),\n-                    \"powerpc-unknown-linux-gnu\" => Some(\"powerpc-linux-gnu\"),\n-                    \"powerpc-unknown-netbsd\" => Some(\"powerpc--netbsd\"),\n-                    \"powerpc64-unknown-linux-gnu\" => Some(\"powerpc-linux-gnu\"),\n-                    \"powerpc64le-unknown-linux-gnu\" => Some(\"powerpc64le-linux-gnu\"),\n-                    \"s390x-unknown-linux-gnu\" => Some(\"s390x-linux-gnu\"),\n-                    \"sparc64-unknown-netbsd\" => Some(\"sparc64--netbsd\"),\n-                    \"thumbv6m-none-eabi\" => Some(\"arm-none-eabi\"),\n-                    \"thumbv7em-none-eabi\" => Some(\"arm-none-eabi\"),\n-                    \"thumbv7em-none-eabihf\" => Some(\"arm-none-eabi\"),\n-                    \"thumbv7m-none-eabi\" => Some(\"arm-none-eabi\"),\n-                    \"x86_64-pc-windows-gnu\" => Some(\"x86_64-w64-mingw32\"),\n-                    \"x86_64-rumprun-netbsd\" => Some(\"x86_64-rumprun-netbsd\"),\n-                    \"x86_64-unknown-linux-musl\" => Some(\"musl\"),\n-                    \"x86_64-unknown-netbsd\" => Some(\"x86_64--netbsd\"),\n-                    _ => None,\n-                });\n-                match prefix {\n-                    Some(prefix) => format!(\"{}-{}\", prefix, gnu),\n-                    None => default.to_string(),\n-                }\n-            } else {\n-                default.to_string()\n-            };\n-            Tool::new(PathBuf::from(compiler))\n-        })\n+            })\n+            .or_else(|| windows_registry::find_tool(&target, \"cl.exe\"))\n+            .unwrap_or_else(|| {\n+                let compiler = if host.contains(\"windows\") && target.contains(\"windows\") {\n+                    if target.contains(\"msvc\") {\n+                        msvc.to_string()\n+                    } else {\n+                        format!(\"{}.exe\", gnu)\n+                    }\n+                } else if target.contains(\"android\") {\n+                    format!(\"{}-{}\", target.replace(\"armv7\", \"arm\"), gnu)\n+                } else if self.get_host() != target {\n+                    // CROSS_COMPILE is of the form: \"arm-linux-gnueabi-\"\n+                    let cc_env = self.getenv(\"CROSS_COMPILE\");\n+                    let cross_compile = cc_env.as_ref().map(|s| s.trim_right_matches('-'));\n+                    let prefix = cross_compile.or(match &target[..] {\n+                        \"aarch64-unknown-linux-gnu\" => Some(\"aarch64-linux-gnu\"),\n+                        \"arm-unknown-linux-gnueabi\" => Some(\"arm-linux-gnueabi\"),\n+                        \"arm-unknown-linux-gnueabihf\" => Some(\"arm-linux-gnueabihf\"),\n+                        \"arm-unknown-linux-musleabi\" => Some(\"arm-linux-musleabi\"),\n+                        \"arm-unknown-linux-musleabihf\" => Some(\"arm-linux-musleabihf\"),\n+                        \"arm-unknown-netbsdelf-eabi\" => Some(\"arm--netbsdelf-eabi\"),\n+                        \"armv6-unknown-netbsdelf-eabihf\" => Some(\"armv6--netbsdelf-eabihf\"),\n+                        \"armv7-unknown-linux-gnueabihf\" => Some(\"arm-linux-gnueabihf\"),\n+                        \"armv7-unknown-linux-musleabihf\" => Some(\"arm-linux-musleabihf\"),\n+                        \"armv7-unknown-netbsdelf-eabihf\" => Some(\"armv7--netbsdelf-eabihf\"),\n+                        \"i686-pc-windows-gnu\" => Some(\"i686-w64-mingw32\"),\n+                        \"i686-unknown-linux-musl\" => Some(\"musl\"),\n+                        \"i686-unknown-netbsdelf\" => Some(\"i486--netbsdelf\"),\n+                        \"mips-unknown-linux-gnu\" => Some(\"mips-linux-gnu\"),\n+                        \"mipsel-unknown-linux-gnu\" => Some(\"mipsel-linux-gnu\"),\n+                        \"mips64-unknown-linux-gnuabi64\" => Some(\"mips64-linux-gnuabi64\"),\n+                        \"mips64el-unknown-linux-gnuabi64\" => Some(\"mips64el-linux-gnuabi64\"),\n+                        \"powerpc-unknown-linux-gnu\" => Some(\"powerpc-linux-gnu\"),\n+                        \"powerpc-unknown-netbsd\" => Some(\"powerpc--netbsd\"),\n+                        \"powerpc64-unknown-linux-gnu\" => Some(\"powerpc-linux-gnu\"),\n+                        \"powerpc64le-unknown-linux-gnu\" => Some(\"powerpc64le-linux-gnu\"),\n+                        \"s390x-unknown-linux-gnu\" => Some(\"s390x-linux-gnu\"),\n+                        \"sparc64-unknown-netbsd\" => Some(\"sparc64--netbsd\"),\n+                        \"thumbv6m-none-eabi\" => Some(\"arm-none-eabi\"),\n+                        \"thumbv7em-none-eabi\" => Some(\"arm-none-eabi\"),\n+                        \"thumbv7em-none-eabihf\" => Some(\"arm-none-eabi\"),\n+                        \"thumbv7m-none-eabi\" => Some(\"arm-none-eabi\"),\n+                        \"x86_64-pc-windows-gnu\" => Some(\"x86_64-w64-mingw32\"),\n+                        \"x86_64-rumprun-netbsd\" => Some(\"x86_64-rumprun-netbsd\"),\n+                        \"x86_64-unknown-linux-musl\" => Some(\"musl\"),\n+                        \"x86_64-unknown-netbsd\" => Some(\"x86_64--netbsd\"),\n+                        _ => None,\n+                    });\n+                    match prefix {\n+                        Some(prefix) => format!(\"{}-{}\", prefix, gnu),\n+                        None => default.to_string(),\n+                    }\n+                } else {\n+                    default.to_string()\n+                };\n+                Tool::new(PathBuf::from(compiler))\n+            })\n     }\n \n     fn get_var(&self, var_base: &str) -> Result<String, String> {\n         let target = self.get_target();\n         let host = self.get_host();\n-        let kind = if host == target {\"HOST\"} else {\"TARGET\"};\n+        let kind = if host == target { \"HOST\" } else { \"TARGET\" };\n         let target_u = target.replace(\"-\", \"_\");\n         let res = self.getenv(&format!(\"{}_{}\", var_base, target))\n             .or_else(|| self.getenv(&format!(\"{}_{}\", var_base, target_u)))\n@@ -823,8 +925,10 @@ impl Config {\n     }\n \n     fn envflags(&self, name: &str) -> Vec<String> {\n-        self.get_var(name).unwrap_or(String::new())\n-            .split(|c: char| c.is_whitespace()).filter(|s| !s.is_empty())\n+        self.get_var(name)\n+            .unwrap_or(String::new())\n+            .split(|c: char| c.is_whitespace())\n+            .filter(|s| !s.is_empty())\n             .map(|s| s.to_string())\n             .collect()\n     }\n@@ -834,8 +938,7 @@ impl Config {\n             let whitelist = [\"ccache\", \"distcc\"];\n             for t in whitelist.iter() {\n                 if tool.starts_with(t) && tool[t.len()..].starts_with(\" \") {\n-                    return (t.to_string(),\n-                            vec![tool[t.len()..].trim_left().to_string()])\n+                    return (t.to_string(), vec![tool[t.len()..].trim_left().to_string()]);\n                 }\n             }\n             (tool, Vec::new())\n@@ -860,17 +963,18 @@ impl Config {\n     }\n \n     fn get_ar(&self) -> PathBuf {\n-        self.archiver.clone().or_else(|| {\n-            self.get_var(\"AR\").map(PathBuf::from).ok()\n-        }).unwrap_or_else(|| {\n-            if self.get_target().contains(\"android\") {\n-                PathBuf::from(format!(\"{}-ar\", self.get_target()))\n-            } else if self.get_target().contains(\"emscripten\") {\n-                PathBuf::from(\"emar\")\n-            } else {\n-                PathBuf::from(\"ar\")\n-            }\n-        })\n+        self.archiver\n+            .clone()\n+            .or_else(|| self.get_var(\"AR\").map(PathBuf::from).ok())\n+            .unwrap_or_else(|| {\n+                if self.get_target().contains(\"android\") {\n+                    PathBuf::from(format!(\"{}-ar\", self.get_target().replace(\"armv7\", \"arm\")))\n+                } else if self.get_target().contains(\"emscripten\") {\n+                    PathBuf::from(\"emar\")\n+                } else {\n+                    PathBuf::from(\"ar\")\n+                }\n+            })\n     }\n \n     fn get_target(&self) -> String {\n@@ -882,19 +986,15 @@ impl Config {\n     }\n \n     fn get_opt_level(&self) -> String {\n-        self.opt_level.as_ref().cloned().unwrap_or_else(|| {\n-            self.getenv_unwrap(\"OPT_LEVEL\")\n-        })\n+        self.opt_level.as_ref().cloned().unwrap_or_else(|| self.getenv_unwrap(\"OPT_LEVEL\"))\n     }\n \n     fn get_debug(&self) -> bool {\n         self.debug.unwrap_or_else(|| self.getenv_unwrap(\"PROFILE\") == \"debug\")\n     }\n \n     fn get_out_dir(&self) -> PathBuf {\n-        self.out_dir.clone().unwrap_or_else(|| {\n-            env::var_os(\"OUT_DIR\").map(PathBuf::from).unwrap()\n-        })\n+        self.out_dir.clone().unwrap_or_else(|| env::var_os(\"OUT_DIR\").map(PathBuf::from).unwrap())\n     }\n \n     fn getenv(&self, v: &str) -> Option<String> {\n@@ -919,10 +1019,23 @@ impl Config {\n \n impl Tool {\n     fn new(path: PathBuf) -> Tool {\n+        // Try to detect family of the tool from its name, falling back to Gnu.\n+        let family = if let Some(fname) = path.file_name().and_then(|p| p.to_str()) {\n+            if fname.contains(\"clang\") {\n+                ToolFamily::Clang\n+            } else if fname.contains(\"cl\") {\n+                ToolFamily::Msvc\n+            } else {\n+                ToolFamily::Gnu\n+            }\n+        } else {\n+            ToolFamily::Gnu\n+        };\n         Tool {\n             path: path,\n             args: Vec::new(),\n             env: Vec::new(),\n+            family: family\n         }\n     }\n \n@@ -937,7 +1050,7 @@ impl Tool {\n         for &(ref k, ref v) in self.env.iter() {\n             cmd.env(k, v);\n         }\n-        return cmd\n+        cmd\n     }\n \n     /// Returns the path for this compiler.\n@@ -963,23 +1076,27 @@ impl Tool {\n     }\n }\n \n-fn run(cmd: &mut Command, program: &str) {\n+fn run(cmd: &mut Command, program: &str) -> Vec<u8> {\n     println!(\"running: {:?}\", cmd);\n     // Capture the standard error coming from these programs, and write it out\n     // with cargo:warning= prefixes. Note that this is a bit wonky to avoid\n     // requiring the output to be UTF-8, we instead just ship bytes from one\n     // location to another.\n-    let spawn_result = match cmd.stderr(Stdio::piped()).spawn() {\n+    let (spawn_result, stdout) = match cmd.stdout(Stdio::piped()).stderr(Stdio::piped()).spawn() {\n         Ok(mut child) => {\n             let stderr = BufReader::new(child.stderr.take().unwrap());\n-            for line in stderr.split(b'\\n').filter_map(|l| l.ok()) {\n-                print!(\"cargo:warning=\");\n-                std::io::stdout().write_all(&line).unwrap();\n-                println!(\"\");\n-            }\n-            child.wait()\n+            thread::spawn(move || {\n+                for line in stderr.split(b'\\n').filter_map(|l| l.ok()) {\n+                    print!(\"cargo:warning=\");\n+                    std::io::stdout().write_all(&line).unwrap();\n+                    println!(\"\");\n+                }\n+            });\n+            let mut stdout = vec![];\n+            child.stdout.take().unwrap().read_to_end(&mut stdout).unwrap();\n+            (child.wait(), stdout)\n         }\n-        Err(e) => Err(e),\n+        Err(e) => (Err(e), vec![]),\n     };\n     let status = match spawn_result {\n         Ok(status) => status,\n@@ -991,14 +1108,18 @@ fn run(cmd: &mut Command, program: &str) {\n                 \"\"\n             };\n             fail(&format!(\"failed to execute command: {}\\nIs `{}` \\\n-                           not installed?{}\", e, program, extra));\n+                           not installed?{}\",\n+                          e,\n+                          program,\n+                          extra));\n         }\n         Err(e) => fail(&format!(\"failed to execute command: {}\", e)),\n     };\n     println!(\"{:?}\", status);\n     if !status.success() {\n         fail(&format!(\"command did not execute successfully, got: {}\", status));\n     }\n+    stdout\n }\n \n fn fail(s: &str) -> ! {"}, {"sha": "a45272344db403c87e1005a7315e14a755f47804", "filename": "src/vendor/gcc/src/registry.rs", "status": "modified", "additions": 40, "deletions": 19, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/f98f6c717a6e709b9f0edd3cf0ea4f18e2ca9767/src%2Fvendor%2Fgcc%2Fsrc%2Fregistry.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f98f6c717a6e709b9f0edd3cf0ea4f18e2ca9767/src%2Fvendor%2Fgcc%2Fsrc%2Fregistry.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fvendor%2Fgcc%2Fsrc%2Fregistry.rs?ref=f98f6c717a6e709b9f0edd3cf0ea4f18e2ca9767", "patch": "@@ -40,21 +40,24 @@ extern \"system\" {\n                      lpSubKey: LPCWSTR,\n                      ulOptions: DWORD,\n                      samDesired: REGSAM,\n-                     phkResult: PHKEY) -> LONG;\n+                     phkResult: PHKEY)\n+                     -> LONG;\n     fn RegEnumKeyExW(key: HKEY,\n                      dwIndex: DWORD,\n                      lpName: LPWSTR,\n                      lpcName: LPDWORD,\n                      lpReserved: LPDWORD,\n                      lpClass: LPWSTR,\n                      lpcClass: LPDWORD,\n-                     lpftLastWriteTime: PFILETIME) -> LONG;\n+                     lpftLastWriteTime: PFILETIME)\n+                     -> LONG;\n     fn RegQueryValueExW(hKey: HKEY,\n                         lpValueName: LPCWSTR,\n                         lpReserved: LPDWORD,\n                         lpType: LPDWORD,\n                         lpData: LPBYTE,\n-                        lpcbData: LPDWORD) -> LONG;\n+                        lpcbData: LPDWORD)\n+                        -> LONG;\n     fn RegCloseKey(hKey: HKEY) -> LONG;\n }\n \n@@ -73,8 +76,7 @@ pub struct Iter<'a> {\n unsafe impl Sync for Repr {}\n unsafe impl Send for Repr {}\n \n-pub static LOCAL_MACHINE: RegistryKey =\n-    RegistryKey(Repr::Const(HKEY_LOCAL_MACHINE));\n+pub static LOCAL_MACHINE: RegistryKey = RegistryKey(Repr::Const(HKEY_LOCAL_MACHINE));\n \n impl RegistryKey {\n     fn raw(&self) -> HKEY {\n@@ -88,8 +90,11 @@ impl RegistryKey {\n         let key = key.encode_wide().chain(Some(0)).collect::<Vec<_>>();\n         let mut ret = 0 as *mut _;\n         let err = unsafe {\n-            RegOpenKeyExW(self.raw(), key.as_ptr(), 0,\n-                          KEY_READ | KEY_WOW64_32KEY, &mut ret)\n+            RegOpenKeyExW(self.raw(),\n+                          key.as_ptr(),\n+                          0,\n+                          KEY_READ | KEY_WOW64_32KEY,\n+                          &mut ret)\n         };\n         if err == ERROR_SUCCESS as LONG {\n             Ok(RegistryKey(Repr::Owned(OwnedKey(ret))))\n@@ -99,7 +104,10 @@ impl RegistryKey {\n     }\n \n     pub fn iter(&self) -> Iter {\n-        Iter { idx: 0.., key: self }\n+        Iter {\n+            idx: 0..,\n+            key: self,\n+        }\n     }\n \n     pub fn query_str(&self, name: &str) -> io::Result<OsString> {\n@@ -108,25 +116,31 @@ impl RegistryKey {\n         let mut len = 0;\n         let mut kind = 0;\n         unsafe {\n-            let err = RegQueryValueExW(self.raw(), name.as_ptr(), 0 as *mut _,\n-                                       &mut kind, 0 as *mut _, &mut len);\n+            let err = RegQueryValueExW(self.raw(),\n+                                       name.as_ptr(),\n+                                       0 as *mut _,\n+                                       &mut kind,\n+                                       0 as *mut _,\n+                                       &mut len);\n             if err != ERROR_SUCCESS as LONG {\n-                return Err(io::Error::from_raw_os_error(err as i32))\n+                return Err(io::Error::from_raw_os_error(err as i32));\n             }\n             if kind != REG_SZ {\n-                return Err(io::Error::new(io::ErrorKind::Other,\n-                                          \"registry key wasn't a string\"))\n+                return Err(io::Error::new(io::ErrorKind::Other, \"registry key wasn't a string\"));\n             }\n \n             // The length here is the length in bytes, but we're using wide\n             // characters so we need to be sure to halve it for the capacity\n             // passed in.\n             let mut v = Vec::with_capacity(len as usize / 2);\n-            let err = RegQueryValueExW(self.raw(), name.as_ptr(), 0 as *mut _,\n-                                       0 as *mut _, v.as_mut_ptr() as *mut _,\n+            let err = RegQueryValueExW(self.raw(),\n+                                       name.as_ptr(),\n+                                       0 as *mut _,\n+                                       0 as *mut _,\n+                                       v.as_mut_ptr() as *mut _,\n                                        &mut len);\n             if err != ERROR_SUCCESS as LONG {\n-                return Err(io::Error::from_raw_os_error(err as i32))\n+                return Err(io::Error::from_raw_os_error(err as i32));\n             }\n             v.set_len(len as usize / 2);\n \n@@ -142,7 +156,9 @@ impl RegistryKey {\n \n impl Drop for OwnedKey {\n     fn drop(&mut self) {\n-        unsafe { RegCloseKey(self.0); }\n+        unsafe {\n+            RegCloseKey(self.0);\n+        }\n     }\n }\n \n@@ -153,8 +169,13 @@ impl<'a> Iterator for Iter<'a> {\n         self.idx.next().and_then(|i| unsafe {\n             let mut v = Vec::with_capacity(256);\n             let mut len = v.capacity() as DWORD;\n-            let ret = RegEnumKeyExW(self.key.raw(), i, v.as_mut_ptr(), &mut len,\n-                                    0 as *mut _, 0 as *mut _, 0 as *mut _,\n+            let ret = RegEnumKeyExW(self.key.raw(),\n+                                    i,\n+                                    v.as_mut_ptr(),\n+                                    &mut len,\n+                                    0 as *mut _,\n+                                    0 as *mut _,\n+                                    0 as *mut _,\n                                     0 as *mut _);\n             if ret == ERROR_NO_MORE_ITEMS as LONG {\n                 None"}, {"sha": "08b1df5f9b24af3926861ae5f2b05cb97c2e3204", "filename": "src/vendor/gcc/src/windows_registry.rs", "status": "modified", "additions": 66, "deletions": 72, "changes": 138, "blob_url": "https://github.com/rust-lang/rust/blob/f98f6c717a6e709b9f0edd3cf0ea4f18e2ca9767/src%2Fvendor%2Fgcc%2Fsrc%2Fwindows_registry.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f98f6c717a6e709b9f0edd3cf0ea4f18e2ca9767/src%2Fvendor%2Fgcc%2Fsrc%2Fwindows_registry.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fvendor%2Fgcc%2Fsrc%2Fwindows_registry.rs?ref=f98f6c717a6e709b9f0edd3cf0ea4f18e2ca9767", "patch": "@@ -78,31 +78,29 @@ pub fn find_tool(target: &str, tool: &str) -> Option<Tool> {\n             add_env(&mut tool, \"LIB\", libs);\n             add_env(&mut tool, \"PATH\", path);\n             add_env(&mut tool, \"INCLUDE\", include);\n-            return tool\n+            tool\n         }\n     }\n \n     // This logic is all tailored for MSVC, if we're not that then bail out\n     // early.\n     if !target.contains(\"msvc\") {\n-        return None\n+        return None;\n     }\n \n     // Looks like msbuild isn't located in the same location as other tools like\n     // cl.exe and lib.exe. To handle this we probe for it manually with\n     // dedicated registry keys.\n     if tool.contains(\"msbuild\") {\n-        return find_msbuild(target)\n+        return find_msbuild(target);\n     }\n \n     // If VCINSTALLDIR is set, then someone's probably already run vcvars and we\n     // should just find whatever that indicates.\n     if env::var_os(\"VCINSTALLDIR\").is_some() {\n-        return env::var_os(\"PATH\").and_then(|path| {\n-            env::split_paths(&path).map(|p| p.join(tool)).find(|p| p.exists())\n-        }).map(|path| {\n-            Tool::new(path.into())\n-        })\n+        return env::var_os(\"PATH\")\n+            .and_then(|path| env::split_paths(&path).map(|p| p.join(tool)).find(|p| p.exists()))\n+            .map(|path| Tool::new(path.into()));\n     }\n \n     // Ok, if we're here, now comes the fun part of the probing. Default shells\n@@ -112,13 +110,10 @@ pub fn find_tool(target: &str, tool: &str) -> Option<Tool> {\n     // environment variables like `LIB`, `INCLUDE`, and `PATH` to ensure that\n     // the tool is actually usable.\n \n-    return find_msvc_latest(tool, target, \"15.0\").or_else(|| {\n-        find_msvc_latest(tool, target, \"14.0\")\n-    }).or_else(|| {\n-        find_msvc_12(tool, target)\n-    }).or_else(|| {\n-        find_msvc_11(tool, target)\n-    });\n+    return find_msvc_latest(tool, target, \"15.0\")\n+        .or_else(|| find_msvc_latest(tool, target, \"14.0\"))\n+        .or_else(|| find_msvc_12(tool, target))\n+        .or_else(|| find_msvc_11(tool, target));\n \n     // For MSVC 14 or newer we need to find the Universal CRT as well as either\n     // the Windows 10 SDK or Windows 8.1 SDK.\n@@ -151,7 +146,7 @@ pub fn find_tool(target: &str, tool: &str) -> Option<Tool> {\n             tool.include.push(sdk_include.join(\"winrt\"));\n             tool.include.push(sdk_include.join(\"shared\"));\n         } else {\n-            return None\n+            return None;\n         }\n         Some(tool.into_tool())\n     }\n@@ -198,26 +193,27 @@ pub fn find_tool(target: &str, tool: &str) -> Option<Tool> {\n     // Given a possible MSVC installation directory, we look for the linker and\n     // then add the MSVC library path.\n     fn get_tool(tool: &str, path: &Path, target: &str) -> Option<MsvcTool> {\n-        bin_subdir(target).into_iter().map(|(sub, host)| {\n-            (path.join(\"bin\").join(sub).join(tool),\n-             path.join(\"bin\").join(host))\n-        }).filter(|&(ref path, _)| {\n-            path.is_file()\n-        }).map(|(path, host)| {\n-            let mut tool = MsvcTool::new(path);\n-            tool.path.push(host);\n-            tool\n-        }).filter_map(|mut tool| {\n-            let sub = otry!(vc_lib_subdir(target));\n-            tool.libs.push(path.join(\"lib\").join(sub));\n-            tool.include.push(path.join(\"include\"));\n-            let atlmfc_path = path.join(\"atlmfc\");\n-            if atlmfc_path.exists() {\n-                tool.libs.push(atlmfc_path.join(\"lib\").join(sub));\n-                tool.include.push(atlmfc_path.join(\"include\"));\n-            }\n-            Some(tool)\n-        }).next()\n+        bin_subdir(target)\n+            .into_iter()\n+            .map(|(sub, host)| (path.join(\"bin\").join(sub).join(tool), path.join(\"bin\").join(host)))\n+            .filter(|&(ref path, _)| path.is_file())\n+            .map(|(path, host)| {\n+                let mut tool = MsvcTool::new(path);\n+                tool.path.push(host);\n+                tool\n+            })\n+            .filter_map(|mut tool| {\n+                let sub = otry!(vc_lib_subdir(target));\n+                tool.libs.push(path.join(\"lib\").join(sub));\n+                tool.include.push(path.join(\"include\"));\n+                let atlmfc_path = path.join(\"atlmfc\");\n+                if atlmfc_path.exists() {\n+                    tool.libs.push(atlmfc_path.join(\"lib\").join(sub));\n+                    tool.include.push(atlmfc_path.join(\"include\"));\n+                }\n+                Some(tool)\n+            })\n+            .next()\n     }\n \n     // To find MSVC we look in a specific registry key for the version we are\n@@ -240,17 +236,16 @@ pub fn find_tool(target: &str, tool: &str) -> Option<Tool> {\n         let key = otry!(LOCAL_MACHINE.open(key.as_ref()).ok());\n         let root = otry!(key.query_str(\"KitsRoot10\").ok());\n         let readdir = otry!(Path::new(&root).join(\"lib\").read_dir().ok());\n-        let max_libdir = otry!(readdir.filter_map(|dir| {\n-            dir.ok()\n-        }).map(|dir| {\n-            dir.path()\n-        }).filter(|dir| {\n-            dir.components().last().and_then(|c| {\n-                c.as_os_str().to_str()\n-            }).map(|c| {\n-                c.starts_with(\"10.\") && dir.join(\"ucrt\").is_dir()\n-            }).unwrap_or(false)\n-        }).max());\n+        let max_libdir = otry!(readdir.filter_map(|dir| dir.ok())\n+            .map(|dir| dir.path())\n+            .filter(|dir| {\n+                dir.components()\n+                    .last()\n+                    .and_then(|c| c.as_os_str().to_str())\n+                    .map(|c| c.starts_with(\"10.\") && dir.join(\"ucrt\").is_dir())\n+                    .unwrap_or(false)\n+            })\n+            .max());\n         let version = max_libdir.components().last().unwrap();\n         let version = version.as_os_str().to_str().unwrap().to_string();\n         Some((root.into(), version))\n@@ -270,12 +265,13 @@ pub fn find_tool(target: &str, tool: &str) -> Option<Tool> {\n         let root = otry!(key.query_str(\"InstallationFolder\").ok());\n         let readdir = otry!(Path::new(&root).join(\"lib\").read_dir().ok());\n         let mut dirs = readdir.filter_map(|dir| dir.ok())\n-                              .map(|dir| dir.path())\n-                              .collect::<Vec<_>>();\n+            .map(|dir| dir.path())\n+            .collect::<Vec<_>>();\n         dirs.sort();\n-        let dir = otry!(dirs.into_iter().rev().filter(|dir| {\n-            dir.join(\"um\").join(\"x64\").join(\"kernel32.lib\").is_file()\n-        }).next());\n+        let dir = otry!(dirs.into_iter()\n+            .rev()\n+            .filter(|dir| dir.join(\"um\").join(\"x64\").join(\"kernel32.lib\").is_file())\n+            .next());\n         let version = dir.components().last().unwrap();\n         let version = version.as_os_str().to_str().unwrap().to_string();\n         Some((root.into(), version))\n@@ -319,10 +315,8 @@ pub fn find_tool(target: &str, tool: &str) -> Option<Tool> {\n     fn bin_subdir(target: &str) -> Vec<(&'static str, &'static str)> {\n         let arch = target.split('-').next().unwrap();\n         match (arch, host_arch()) {\n-            (\"i586\", X86) |\n-            (\"i686\", X86) => vec![(\"\", \"\")],\n-            (\"i586\", X86_64) |\n-            (\"i686\", X86_64) => vec![(\"amd64_x86\", \"amd64\"), (\"\", \"\")],\n+            (\"i586\", X86) | (\"i686\", X86) => vec![(\"\", \"\")],\n+            (\"i586\", X86_64) | (\"i686\", X86_64) => vec![(\"amd64_x86\", \"amd64\"), (\"\", \"\")],\n             (\"x86_64\", X86) => vec![(\"x86_amd64\", \"\")],\n             (\"x86_64\", X86_64) => vec![(\"amd64\", \"amd64\"), (\"x86_amd64\", \"\")],\n             (\"arm\", X86) => vec![(\"x86_arm\", \"\")],\n@@ -393,9 +387,8 @@ pub fn find_tool(target: &str, tool: &str) -> Option<Tool> {\n         let mut max_vers = 0;\n         let mut max_key = None;\n         for subkey in key.iter().filter_map(|k| k.ok()) {\n-            let val = subkey.to_str().and_then(|s| {\n-                s.trim_left_matches(\"v\").replace(\".\", \"\").parse().ok()\n-            });\n+            let val = subkey.to_str()\n+                .and_then(|s| s.trim_left_matches(\"v\").replace(\".\", \"\").parse().ok());\n             let val = match val {\n                 Some(s) => s,\n                 None => continue,\n@@ -407,24 +400,25 @@ pub fn find_tool(target: &str, tool: &str) -> Option<Tool> {\n                 }\n             }\n         }\n-        return max_key\n+        max_key\n     }\n \n     // see http://stackoverflow.com/questions/328017/path-to-msbuild\n     fn find_msbuild(target: &str) -> Option<Tool> {\n         let key = r\"SOFTWARE\\Microsoft\\MSBuild\\ToolsVersions\";\n-        LOCAL_MACHINE.open(key.as_ref()).ok().and_then(|key| {\n-            max_version(&key).and_then(|(_vers, key)| {\n-                key.query_str(\"MSBuildToolsPath\").ok()\n+        LOCAL_MACHINE.open(key.as_ref())\n+            .ok()\n+            .and_then(|key| {\n+                max_version(&key).and_then(|(_vers, key)| key.query_str(\"MSBuildToolsPath\").ok())\n+            })\n+            .map(|path| {\n+                let mut path = PathBuf::from(path);\n+                path.push(\"MSBuild.exe\");\n+                let mut tool = Tool::new(path);\n+                if target.contains(\"x86_64\") {\n+                    tool.env.push((\"Platform\".into(), \"X64\".into()));\n+                }\n+                tool\n             })\n-        }).map(|path| {\n-            let mut path = PathBuf::from(path);\n-            path.push(\"MSBuild.exe\");\n-            let mut tool = Tool::new(path);\n-            if target.contains(\"x86_64\") {\n-                tool.env.push((\"Platform\".into(), \"X64\".into()));\n-            }\n-            tool\n-        })\n     }\n }"}, {"sha": "135a6635b5935ae206759a2c8dcd49e77829b1fe", "filename": "src/vendor/gcc/tests/support/mod.rs", "status": "modified", "additions": 20, "deletions": 22, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/f98f6c717a6e709b9f0edd3cf0ea4f18e2ca9767/src%2Fvendor%2Fgcc%2Ftests%2Fsupport%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f98f6c717a6e709b9f0edd3cf0ea4f18e2ca9767/src%2Fvendor%2Fgcc%2Ftests%2Fsupport%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fvendor%2Fgcc%2Ftests%2Fsupport%2Fmod.rs?ref=f98f6c717a6e709b9f0edd3cf0ea4f18e2ca9767", "patch": "@@ -37,55 +37,55 @@ impl Test {\n     pub fn gnu() -> Test {\n         let t = Test::new();\n         t.shim(\"cc\").shim(\"ar\");\n-        return t\n+        t\n     }\n \n     pub fn msvc() -> Test {\n         let mut t = Test::new();\n         t.shim(\"cl\").shim(\"lib.exe\");\n         t.msvc = true;\n-        return t\n+        t\n     }\n \n     pub fn shim(&self, name: &str) -> &Test {\n         let fname = format!(\"{}{}\", name, env::consts::EXE_SUFFIX);\n-        fs::hard_link(&self.gcc, self.td.path().join(&fname)).or_else(|_| {\n-            fs::copy(&self.gcc, self.td.path().join(&fname)).map(|_| ())\n-        }).unwrap();\n+        fs::hard_link(&self.gcc, self.td.path().join(&fname))\n+            .or_else(|_| fs::copy(&self.gcc, self.td.path().join(&fname)).map(|_| ()))\n+            .unwrap();\n         self\n     }\n \n     pub fn gcc(&self) -> gcc::Config {\n         let mut cfg = gcc::Config::new();\n-        let mut path = env::split_paths(&env::var_os(\"PATH\").unwrap())\n-                           .collect::<Vec<_>>();\n+        let mut path = env::split_paths(&env::var_os(\"PATH\").unwrap()).collect::<Vec<_>>();\n         path.insert(0, self.td.path().to_owned());\n         let target = if self.msvc {\n             \"x86_64-pc-windows-msvc\"\n         } else {\n             \"x86_64-unknown-linux-gnu\"\n         };\n \n-        cfg.target(target).host(target)\n-           .opt_level(2)\n-           .debug(false)\n-           .out_dir(self.td.path())\n-           .__set_env(\"PATH\", env::join_paths(path).unwrap())\n-           .__set_env(\"GCCTEST_OUT_DIR\", self.td.path());\n+        cfg.target(target)\n+            .host(target)\n+            .opt_level(2)\n+            .debug(false)\n+            .out_dir(self.td.path())\n+            .__set_env(\"PATH\", env::join_paths(path).unwrap())\n+            .__set_env(\"GCCTEST_OUT_DIR\", self.td.path());\n         if self.msvc {\n             cfg.compiler(self.td.path().join(\"cl\"));\n             cfg.archiver(self.td.path().join(\"lib.exe\"));\n         }\n-        return cfg\n+        cfg\n     }\n \n     pub fn cmd(&self, i: u32) -> Execution {\n         let mut s = String::new();\n-        File::open(self.td.path().join(format!(\"out{}\", i))).unwrap()\n-             .read_to_string(&mut s).unwrap();\n-        Execution {\n-            args: s.lines().map(|s| s.to_string()).collect(),\n-        }\n+        File::open(self.td.path().join(format!(\"out{}\", i)))\n+            .unwrap()\n+            .read_to_string(&mut s)\n+            .unwrap();\n+        Execution { args: s.lines().map(|s| s.to_string()).collect() }\n     }\n }\n \n@@ -107,8 +107,6 @@ impl Execution {\n     }\n \n     pub fn has(&self, p: &OsStr) -> bool {\n-        self.args.iter().any(|arg| {\n-            OsStr::new(arg) == p\n-        })\n+        self.args.iter().any(|arg| OsStr::new(arg) == p)\n     }\n }"}, {"sha": "5a034ff347b240de930e3a28ab5cb60bfa5d211a", "filename": "src/vendor/gcc/tests/test.rs", "status": "modified", "additions": 63, "deletions": 40, "changes": 103, "blob_url": "https://github.com/rust-lang/rust/blob/f98f6c717a6e709b9f0edd3cf0ea4f18e2ca9767/src%2Fvendor%2Fgcc%2Ftests%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f98f6c717a6e709b9f0edd3cf0ea4f18e2ca9767/src%2Fvendor%2Fgcc%2Ftests%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fvendor%2Fgcc%2Ftests%2Ftest.rs?ref=f98f6c717a6e709b9f0edd3cf0ea4f18e2ca9767", "patch": "@@ -9,14 +9,16 @@ mod support;\n fn gnu_smoke() {\n     let test = Test::gnu();\n     test.gcc()\n-        .file(\"foo.c\").compile(\"libfoo.a\");\n-\n-    test.cmd(0).must_have(\"-O2\")\n-               .must_have(\"foo.c\")\n-               .must_not_have(\"-g\")\n-               .must_have(\"-c\")\n-               .must_have(\"-ffunction-sections\")\n-               .must_have(\"-fdata-sections\");\n+        .file(\"foo.c\")\n+        .compile(\"libfoo.a\");\n+\n+    test.cmd(0)\n+        .must_have(\"-O2\")\n+        .must_have(\"foo.c\")\n+        .must_not_have(\"-g\")\n+        .must_have(\"-c\")\n+        .must_have(\"-ffunction-sections\")\n+        .must_have(\"-fdata-sections\");\n     test.cmd(1).must_have(test.td.path().join(\"foo.o\"));\n }\n \n@@ -25,32 +27,37 @@ fn gnu_opt_level_1() {\n     let test = Test::gnu();\n     test.gcc()\n         .opt_level(1)\n-        .file(\"foo.c\").compile(\"libfoo.a\");\n+        .file(\"foo.c\")\n+        .compile(\"libfoo.a\");\n \n-    test.cmd(0).must_have(\"-O1\")\n-               .must_not_have(\"-O2\");\n+    test.cmd(0)\n+        .must_have(\"-O1\")\n+        .must_not_have(\"-O2\");\n }\n \n #[test]\n fn gnu_opt_level_s() {\n     let test = Test::gnu();\n     test.gcc()\n         .opt_level_str(\"s\")\n-        .file(\"foo.c\").compile(\"libfoo.a\");\n+        .file(\"foo.c\")\n+        .compile(\"libfoo.a\");\n \n-    test.cmd(0).must_have(\"-Os\")\n-               .must_not_have(\"-O1\")\n-               .must_not_have(\"-O2\")\n-               .must_not_have(\"-O3\")\n-               .must_not_have(\"-Oz\");\n+    test.cmd(0)\n+        .must_have(\"-Os\")\n+        .must_not_have(\"-O1\")\n+        .must_not_have(\"-O2\")\n+        .must_not_have(\"-O3\")\n+        .must_not_have(\"-Oz\");\n }\n \n #[test]\n fn gnu_debug() {\n     let test = Test::gnu();\n     test.gcc()\n         .debug(true)\n-        .file(\"foo.c\").compile(\"libfoo.a\");\n+        .file(\"foo.c\")\n+        .compile(\"libfoo.a\");\n     test.cmd(0).must_have(\"-g\");\n }\n \n@@ -62,10 +69,12 @@ fn gnu_x86_64() {\n         test.gcc()\n             .target(&target)\n             .host(&target)\n-            .file(\"foo.c\").compile(\"libfoo.a\");\n+            .file(\"foo.c\")\n+            .compile(\"libfoo.a\");\n \n-        test.cmd(0).must_have(\"-fPIC\")\n-                   .must_have(\"-m64\");\n+        test.cmd(0)\n+            .must_have(\"-fPIC\")\n+            .must_have(\"-m64\");\n     }\n }\n \n@@ -78,7 +87,8 @@ fn gnu_x86_64_no_pic() {\n             .pic(false)\n             .target(&target)\n             .host(&target)\n-            .file(\"foo.c\").compile(\"libfoo.a\");\n+            .file(\"foo.c\")\n+            .compile(\"libfoo.a\");\n \n         test.cmd(0).must_not_have(\"-fPIC\");\n     }\n@@ -92,10 +102,12 @@ fn gnu_i686() {\n         test.gcc()\n             .target(&target)\n             .host(&target)\n-            .file(\"foo.c\").compile(\"libfoo.a\");\n+            .file(\"foo.c\")\n+            .compile(\"libfoo.a\");\n \n-        test.cmd(0).must_not_have(\"-fPIC\")\n-                   .must_have(\"-m32\");\n+        test.cmd(0)\n+            .must_not_have(\"-fPIC\")\n+            .must_have(\"-m32\");\n     }\n }\n \n@@ -108,7 +120,8 @@ fn gnu_i686_pic() {\n             .pic(true)\n             .target(&target)\n             .host(&target)\n-            .file(\"foo.c\").compile(\"libfoo.a\");\n+            .file(\"foo.c\")\n+            .compile(\"libfoo.a\");\n \n         test.cmd(0).must_have(\"-fPIC\");\n     }\n@@ -119,7 +132,8 @@ fn gnu_set_stdlib() {\n     let test = Test::gnu();\n     test.gcc()\n         .cpp_set_stdlib(Some(\"foo\"))\n-        .file(\"foo.c\").compile(\"libfoo.a\");\n+        .file(\"foo.c\")\n+        .compile(\"libfoo.a\");\n \n     test.cmd(0).must_not_have(\"-stdlib=foo\");\n }\n@@ -129,7 +143,8 @@ fn gnu_include() {\n     let test = Test::gnu();\n     test.gcc()\n         .include(\"foo/bar\")\n-        .file(\"foo.c\").compile(\"libfoo.a\");\n+        .file(\"foo.c\")\n+        .compile(\"libfoo.a\");\n \n     test.cmd(0).must_have(\"-I\").must_have(\"foo/bar\");\n }\n@@ -140,7 +155,8 @@ fn gnu_define() {\n     test.gcc()\n         .define(\"FOO\", Some(\"bar\"))\n         .define(\"BAR\", None)\n-        .file(\"foo.c\").compile(\"libfoo.a\");\n+        .file(\"foo.c\")\n+        .compile(\"libfoo.a\");\n \n     test.cmd(0).must_have(\"-DFOO=bar\").must_have(\"-DBAR\");\n }\n@@ -149,20 +165,23 @@ fn gnu_define() {\n fn gnu_compile_assembly() {\n     let test = Test::gnu();\n     test.gcc()\n-        .file(\"foo.S\").compile(\"libfoo.a\");\n+        .file(\"foo.S\")\n+        .compile(\"libfoo.a\");\n     test.cmd(0).must_have(\"foo.S\");\n }\n \n #[test]\n fn msvc_smoke() {\n     let test = Test::msvc();\n     test.gcc()\n-        .file(\"foo.c\").compile(\"libfoo.a\");\n-\n-    test.cmd(0).must_have(\"/O2\")\n-               .must_have(\"foo.c\")\n-               .must_not_have(\"/Z7\")\n-               .must_have(\"/c\");\n+        .file(\"foo.c\")\n+        .compile(\"libfoo.a\");\n+\n+    test.cmd(0)\n+        .must_have(\"/O2\")\n+        .must_have(\"foo.c\")\n+        .must_not_have(\"/Z7\")\n+        .must_have(\"/c\");\n     test.cmd(1).must_have(test.td.path().join(\"foo.o\"));\n }\n \n@@ -171,7 +190,8 @@ fn msvc_opt_level_0() {\n     let test = Test::msvc();\n     test.gcc()\n         .opt_level(0)\n-        .file(\"foo.c\").compile(\"libfoo.a\");\n+        .file(\"foo.c\")\n+        .compile(\"libfoo.a\");\n \n     test.cmd(0).must_not_have(\"/O2\");\n }\n@@ -181,7 +201,8 @@ fn msvc_debug() {\n     let test = Test::msvc();\n     test.gcc()\n         .debug(true)\n-        .file(\"foo.c\").compile(\"libfoo.a\");\n+        .file(\"foo.c\")\n+        .compile(\"libfoo.a\");\n     test.cmd(0).must_have(\"/Z7\");\n }\n \n@@ -190,7 +211,8 @@ fn msvc_include() {\n     let test = Test::msvc();\n     test.gcc()\n         .include(\"foo/bar\")\n-        .file(\"foo.c\").compile(\"libfoo.a\");\n+        .file(\"foo.c\")\n+        .compile(\"libfoo.a\");\n \n     test.cmd(0).must_have(\"/I\").must_have(\"foo/bar\");\n }\n@@ -201,7 +223,8 @@ fn msvc_define() {\n     test.gcc()\n         .define(\"FOO\", Some(\"bar\"))\n         .define(\"BAR\", None)\n-        .file(\"foo.c\").compile(\"libfoo.a\");\n+        .file(\"foo.c\")\n+        .compile(\"libfoo.a\");\n \n     test.cmd(0).must_have(\"/DFOO=bar\").must_have(\"/DBAR\");\n }"}]}