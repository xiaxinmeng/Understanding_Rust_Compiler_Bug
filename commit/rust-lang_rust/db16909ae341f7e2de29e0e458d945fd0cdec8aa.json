{"sha": "db16909ae341f7e2de29e0e458d945fd0cdec8aa", "node_id": "MDY6Q29tbWl0NzI0NzEyOmRiMTY5MDlhZTM0MWY3ZTJkZTI5ZTBlNDU4ZDk0NWZkMGNkZWM4YWE=", "commit": {"author": {"name": "Jorge Aparicio", "email": "japaricious@gmail.com", "date": "2016-08-13T02:15:42Z"}, "committer": {"name": "Jorge Aparicio", "email": "japaricious@gmail.com", "date": "2016-08-13T02:39:21Z"}, "message": "exclude `#![no_builtins]` crates from LTO\n\nthis prevents intrinsics like `memcpy` from being mis-optimized to\ninfinite recursive calls when LTO is used.\n\nfixes #31544\ncloses #35540", "tree": {"sha": "303973e52c430629803f6596e867bf42e2461574", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/303973e52c430629803f6596e867bf42e2461574"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/db16909ae341f7e2de29e0e458d945fd0cdec8aa", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/db16909ae341f7e2de29e0e458d945fd0cdec8aa", "html_url": "https://github.com/rust-lang/rust/commit/db16909ae341f7e2de29e0e458d945fd0cdec8aa", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/db16909ae341f7e2de29e0e458d945fd0cdec8aa/comments", "author": null, "committer": null, "parents": [{"sha": "8787a12334439d47e931be26fef53381ce337c3a", "url": "https://api.github.com/repos/rust-lang/rust/commits/8787a12334439d47e931be26fef53381ce337c3a", "html_url": "https://github.com/rust-lang/rust/commit/8787a12334439d47e931be26fef53381ce337c3a"}], "stats": {"total": 39, "additions": 28, "deletions": 11}, "files": [{"sha": "d17da74c87f399a014df7d24c644505f21a35005", "filename": "src/librustc_trans/back/link.rs", "status": "modified", "additions": 18, "deletions": 10, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/db16909ae341f7e2de29e0e458d945fd0cdec8aa/src%2Flibrustc_trans%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/db16909ae341f7e2de29e0e458d945fd0cdec8aa/src%2Flibrustc_trans%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fback%2Flink.rs?ref=db16909ae341f7e2de29e0e458d945fd0cdec8aa", "patch": "@@ -42,7 +42,7 @@ use std::process::Command;\n use std::str;\n use flate;\n use syntax::ast;\n-use syntax::attr::AttrMetaMethods;\n+use syntax::attr::{self, AttrMetaMethods};\n use syntax_pos::Span;\n \n // RLIB LLVM-BYTECODE OBJECT LAYOUT\n@@ -938,8 +938,10 @@ fn add_upstream_rust_crates(cmd: &mut Linker,\n             Linkage::NotLinked |\n             Linkage::IncludedFromDylib => {}\n             Linkage::Static => {\n+                let is_a_no_builtins_crate =\n+                    attr::contains_name(&sess.cstore.crate_attrs(cnum), \"no_builtins\");\n                 add_static_crate(cmd, sess, tmpdir, crate_type,\n-                                 &src.rlib.unwrap().0)\n+                                 &src.rlib.unwrap().0, is_a_no_builtins_crate)\n             }\n             Linkage::Dynamic => {\n                 add_dynamic_crate(cmd, sess, &src.dylib.unwrap().0)\n@@ -963,12 +965,16 @@ fn add_upstream_rust_crates(cmd: &mut Linker,\n     // * For LTO, we remove upstream object files.\n     // * For dylibs we remove metadata and bytecode from upstream rlibs\n     //\n-    // When performing LTO, all of the bytecode from the upstream libraries has\n-    // already been included in our object file output. As a result we need to\n-    // remove the object files in the upstream libraries so the linker doesn't\n-    // try to include them twice (or whine about duplicate symbols). We must\n-    // continue to include the rest of the rlib, however, as it may contain\n-    // static native libraries which must be linked in.\n+    // When performing LTO, almost(*) all of the bytecode from the upstream\n+    // libraries has already been included in our object file output. As a\n+    // result we need to remove the object files in the upstream libraries so\n+    // the linker doesn't try to include them twice (or whine about duplicate\n+    // symbols). We must continue to include the rest of the rlib, however, as\n+    // it may contain static native libraries which must be linked in.\n+    //\n+    // (*) Crates marked with `#![no_builtins]` don't participate in LTO and\n+    // their bytecode wasn't included. The object files in those libraries must\n+    // still be passed to the linker.\n     //\n     // When making a dynamic library, linkers by default don't include any\n     // object files in an archive if they're not necessary to resolve the link.\n@@ -988,7 +994,8 @@ fn add_upstream_rust_crates(cmd: &mut Linker,\n                         sess: &Session,\n                         tmpdir: &Path,\n                         crate_type: config::CrateType,\n-                        cratepath: &Path) {\n+                        cratepath: &Path,\n+                        is_a_no_builtins_crate: bool) {\n         if !sess.lto() && crate_type != config::CrateTypeDylib {\n             cmd.link_rlib(&fix_windows_verbatim_for_gcc(cratepath));\n             return\n@@ -1012,7 +1019,8 @@ fn add_upstream_rust_crates(cmd: &mut Linker,\n                 }\n                 let canonical = f.replace(\"-\", \"_\");\n                 let canonical_name = name.replace(\"-\", \"_\");\n-                if sess.lto() && canonical.starts_with(&canonical_name) &&\n+                if sess.lto() && !is_a_no_builtins_crate &&\n+                   canonical.starts_with(&canonical_name) &&\n                    canonical.ends_with(\".o\") {\n                     let num = &f[name.len()..f.len() - 2];\n                     if num.len() > 0 && num[1..].parse::<u32>().is_ok() {"}, {"sha": "016eb7c0cfb3ccdb2cebc5241485137dcf54213c", "filename": "src/librustc_trans/back/lto.rs", "status": "modified", "additions": 10, "deletions": 1, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/db16909ae341f7e2de29e0e458d945fd0cdec8aa/src%2Flibrustc_trans%2Fback%2Flto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/db16909ae341f7e2de29e0e458d945fd0cdec8aa/src%2Flibrustc_trans%2Fback%2Flto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fback%2Flto.rs?ref=db16909ae341f7e2de29e0e458d945fd0cdec8aa", "patch": "@@ -17,6 +17,7 @@ use llvm::{ModuleRef, TargetMachineRef, True, False};\n use rustc::util::common::time;\n use rustc::util::common::path2cstr;\n use back::write::{ModuleConfig, with_llvm_pmb};\n+use syntax::attr;\n \n use libc;\n use flate;\n@@ -52,7 +53,15 @@ pub fn run(sess: &session::Session, llmod: ModuleRef,\n     // For each of our upstream dependencies, find the corresponding rlib and\n     // load the bitcode from the archive. Then merge it into the current LLVM\n     // module that we've got.\n-    link::each_linked_rlib(sess, &mut |_, path| {\n+    link::each_linked_rlib(sess, &mut |cnum, path| {\n+        let is_a_no_builtins_crate =\n+            attr::contains_name(&sess.cstore.crate_attrs(cnum), \"no_builtins\");\n+\n+        // `#![no_builtins]` crates don't participate in LTO.\n+        if is_a_no_builtins_crate {\n+            return;\n+        }\n+\n         let archive = ArchiveRO::open(&path).expect(\"wanted an rlib\");\n         let bytecodes = archive.iter().filter_map(|child| {\n             child.ok().and_then(|c| c.name().map(|name| (name, c)))"}]}