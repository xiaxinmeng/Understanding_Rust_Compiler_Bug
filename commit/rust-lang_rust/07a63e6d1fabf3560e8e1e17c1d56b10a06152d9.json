{"sha": "07a63e6d1fabf3560e8e1e17c1d56b10a06152d9", "node_id": "MDY6Q29tbWl0NzI0NzEyOjA3YTYzZTZkMWZhYmYzNTYwZThlMWUxN2MxZDU2YjEwYTA2MTUyZDk=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-10-23T09:31:44Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-10-23T09:31:44Z"}, "message": "Auto merge of #78270 - JohnTitor:rollup-bldrjh5, r=JohnTitor\n\nRollup of 17 pull requests\n\nSuccessful merges:\n\n - #77268 (Link to \"Contributing to Rust\" rather than \"Getting Started\".)\n - #77339 (Implement TryFrom between NonZero types.)\n - #77488 (Mark `repr128` as `incomplete_features`)\n - #77890 (Fixing escaping to ensure generation of welformed json.)\n - #77918 (Cleanup network tests)\n - #77920 (Avoid extraneous space between visibility kw and ident for statics)\n - #77969 (Doc formating consistency between slice sort and sort_unstable, and big O notation consistency)\n - #78098 (Clean up and improve some docs)\n - #78116 (Make inline const work in range patterns)\n - #78153 (Sync LLVM submodule if it has been initialized)\n - #78163 (Clean up lib docs)\n - #78169 (Update cargo)\n - #78231 (Make closures inherit the parent function's target features)\n - #78235 (Explain where the closure return type was inferred)\n - #78255 (Reduce diagram mess in 'match arms have incompatible types' error)\n - #78263 (Add regression test of issue-77668)\n - #78265 (Add some inference-related regression tests about incorrect diagnostics)\n\nFailed merges:\n\nr? `@ghost`", "tree": {"sha": "12243a35e4aa227ca4b935b9448a90a68ecf30d9", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/12243a35e4aa227ca4b935b9448a90a68ecf30d9"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/07a63e6d1fabf3560e8e1e17c1d56b10a06152d9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/07a63e6d1fabf3560e8e1e17c1d56b10a06152d9", "html_url": "https://github.com/rust-lang/rust/commit/07a63e6d1fabf3560e8e1e17c1d56b10a06152d9", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/07a63e6d1fabf3560e8e1e17c1d56b10a06152d9/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a9cd294cf2775441e713c7ee2918b728733b99f5", "url": "https://api.github.com/repos/rust-lang/rust/commits/a9cd294cf2775441e713c7ee2918b728733b99f5", "html_url": "https://github.com/rust-lang/rust/commit/a9cd294cf2775441e713c7ee2918b728733b99f5"}, {"sha": "b5d2ff0fd873ff2ee21d900fa455772f06600c6d", "url": "https://api.github.com/repos/rust-lang/rust/commits/b5d2ff0fd873ff2ee21d900fa455772f06600c6d", "html_url": "https://github.com/rust-lang/rust/commit/b5d2ff0fd873ff2ee21d900fa455772f06600c6d"}], "stats": {"total": 634, "additions": 523, "deletions": 111}, "files": [{"sha": "b600074c1977066cb50339fcccd7eb85cd08cb58", "filename": "CONTRIBUTING.md", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/07a63e6d1fabf3560e8e1e17c1d56b10a06152d9/CONTRIBUTING.md", "raw_url": "https://github.com/rust-lang/rust/raw/07a63e6d1fabf3560e8e1e17c1d56b10a06152d9/CONTRIBUTING.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/CONTRIBUTING.md?ref=07a63e6d1fabf3560e8e1e17c1d56b10a06152d9", "patch": "@@ -2,14 +2,14 @@\n \n Thank you for your interest in contributing to Rust!\n \n-To get started, read the [Getting Started] guide in the [rustc-dev-guide].\n+To get started, read the [Contributing to Rust] chapter of the [rustc-dev-guide].\n \n ## Bug reports\n \n Did a compiler error message tell you to come here? If you want to create an ICE report,\n refer to [this section][contributing-bug-reports] and [open an issue][issue template].\n \n-[Getting Started]: https://rustc-dev-guide.rust-lang.org/getting-started.html\n+[Contributing to Rust]: https://rustc-dev-guide.rust-lang.org/contributing.html#contributing-to-rust\n [rustc-dev-guide]: https://rustc-dev-guide.rust-lang.org/\n [contributing-bug-reports]: https://rustc-dev-guide.rust-lang.org/contributing.html#bug-reports\n [issue template]: https://github.com/rust-lang/rust/issues/new/choose"}, {"sha": "94fbd52bcf0d715541eef1714fa9f9a70f2ce1a9", "filename": "Cargo.lock", "status": "modified", "additions": 14, "deletions": 1, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/07a63e6d1fabf3560e8e1e17c1d56b10a06152d9/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/07a63e6d1fabf3560e8e1e17c1d56b10a06152d9/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=07a63e6d1fabf3560e8e1e17c1d56b10a06152d9", "patch": "@@ -310,7 +310,7 @@ dependencies = [\n  \"crypto-hash\",\n  \"curl\",\n  \"curl-sys\",\n- \"env_logger 0.7.1\",\n+ \"env_logger 0.8.1\",\n  \"filetime\",\n  \"flate2\",\n  \"fwdansi\",\n@@ -1035,6 +1035,19 @@ dependencies = [\n  \"termcolor\",\n ]\n \n+[[package]]\n+name = \"env_logger\"\n+version = \"0.8.1\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"54532e3223c5af90a6a757c90b5c5521564b07e5e7a958681bcd2afad421cdcd\"\n+dependencies = [\n+ \"atty\",\n+ \"humantime 2.0.1\",\n+ \"log\",\n+ \"regex\",\n+ \"termcolor\",\n+]\n+\n [[package]]\n name = \"error_index_generator\"\n version = \"0.0.0\""}, {"sha": "04912fe409679641320b86dd0b9a71dc6f226990", "filename": "compiler/rustc_feature/src/active.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/07a63e6d1fabf3560e8e1e17c1d56b10a06152d9/compiler%2Frustc_feature%2Fsrc%2Factive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/07a63e6d1fabf3560e8e1e17c1d56b10a06152d9/compiler%2Frustc_feature%2Fsrc%2Factive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_feature%2Fsrc%2Factive.rs?ref=07a63e6d1fabf3560e8e1e17c1d56b10a06152d9", "patch": "@@ -622,6 +622,7 @@ pub const INCOMPLETE_FEATURES: &[Symbol] = &[\n     sym::lazy_normalization_consts,\n     sym::specialization,\n     sym::inline_const,\n+    sym::repr128,\n ];\n \n /// Some features are not allowed to be used together at the same time, if"}, {"sha": "3a0ec6327c18643297e2e4978e6e0ea513f397d3", "filename": "compiler/rustc_infer/src/infer/error_reporting/mod.rs", "status": "modified", "additions": 14, "deletions": 2, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/07a63e6d1fabf3560e8e1e17c1d56b10a06152d9/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/07a63e6d1fabf3560e8e1e17c1d56b10a06152d9/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fmod.rs?ref=07a63e6d1fabf3560e8e1e17c1d56b10a06152d9", "patch": "@@ -619,6 +619,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                 scrut_hir_id,\n                 opt_suggest_box_span,\n                 arm_span,\n+                scrut_span,\n                 ..\n             }) => match source {\n                 hir::MatchSource::IfLetDesugar { .. } => {\n@@ -664,18 +665,29 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                         Some(ty::error::ExpectedFound { expected, .. }) => expected,\n                         _ => last_ty,\n                     });\n-                    let msg = \"`match` arms have incompatible types\";\n-                    err.span_label(cause.span, msg);\n+                    let source_map = self.tcx.sess.source_map();\n+                    let mut any_multiline_arm = source_map.is_multiline(arm_span);\n                     if prior_arms.len() <= 4 {\n                         for sp in prior_arms {\n+                            any_multiline_arm |= source_map.is_multiline(*sp);\n                             err.span_label(*sp, format!(\"this is found to be of type `{}`\", t));\n                         }\n                     } else if let Some(sp) = prior_arms.last() {\n+                        any_multiline_arm |= source_map.is_multiline(*sp);\n                         err.span_label(\n                             *sp,\n                             format!(\"this and all prior arms are found to be of type `{}`\", t),\n                         );\n                     }\n+                    let outer_error_span = if any_multiline_arm {\n+                        // Cover just `match` and the scrutinee expression, not\n+                        // the entire match body, to reduce diagram noise.\n+                        cause.span.shrink_to_lo().to(scrut_span)\n+                    } else {\n+                        cause.span\n+                    };\n+                    let msg = \"`match` arms have incompatible types\";\n+                    err.span_label(outer_error_span, msg);\n                     if let Some(sp) = semi_span {\n                         err.span_suggestion_short(\n                             sp,"}, {"sha": "d060549ca8137191c73eae593251900541d7ae23", "filename": "compiler/rustc_middle/src/middle/region.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/07a63e6d1fabf3560e8e1e17c1d56b10a06152d9/compiler%2Frustc_middle%2Fsrc%2Fmiddle%2Fregion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/07a63e6d1fabf3560e8e1e17c1d56b10a06152d9/compiler%2Frustc_middle%2Fsrc%2Fmiddle%2Fregion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmiddle%2Fregion.rs?ref=07a63e6d1fabf3560e8e1e17c1d56b10a06152d9", "patch": "@@ -292,20 +292,20 @@ pub struct ScopeTree {\n     ///\n     /// Then:\n     ///\n-    ///     1. From the ordering guarantee of HIR visitors (see\n-    ///     `rustc_hir::intravisit`), `D` does not dominate `U`.\n+    ///   1. From the ordering guarantee of HIR visitors (see\n+    ///   `rustc_hir::intravisit`), `D` does not dominate `U`.\n     ///\n-    ///     2. Therefore, `D` is *potentially* storage-dead at `U` (because\n-    ///     we might visit `U` without ever getting to `D`).\n+    ///   2. Therefore, `D` is *potentially* storage-dead at `U` (because\n+    ///   we might visit `U` without ever getting to `D`).\n     ///\n-    ///     3. However, we guarantee that at each HIR point, each\n-    ///     binding/temporary is always either always storage-live\n-    ///     or always storage-dead. This is what is being guaranteed\n-    ///     by `terminating_scopes` including all blocks where the\n-    ///     count of executions is not guaranteed.\n+    ///   3. However, we guarantee that at each HIR point, each\n+    ///   binding/temporary is always either always storage-live\n+    ///   or always storage-dead. This is what is being guaranteed\n+    ///   by `terminating_scopes` including all blocks where the\n+    ///   count of executions is not guaranteed.\n     ///\n-    ///     4. By `2.` and `3.`, `D` is *statically* storage-dead at `U`,\n-    ///     QED.\n+    ///   4. By `2.` and `3.`, `D` is *statically* storage-dead at `U`,\n+    ///   QED.\n     ///\n     /// This property ought to not on (3) in an essential way -- it\n     /// is probably still correct even if we have \"unrestricted\" terminating"}, {"sha": "bbc46b8d6083562ae070a76b14133a1490ffbe7c", "filename": "compiler/rustc_middle/src/traits/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/07a63e6d1fabf3560e8e1e17c1d56b10a06152d9/compiler%2Frustc_middle%2Fsrc%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/07a63e6d1fabf3560e8e1e17c1d56b10a06152d9/compiler%2Frustc_middle%2Fsrc%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Ftraits%2Fmod.rs?ref=07a63e6d1fabf3560e8e1e17c1d56b10a06152d9", "patch": "@@ -343,6 +343,7 @@ static_assert_size!(ObligationCauseCode<'_>, 32);\n #[derive(Clone, Debug, PartialEq, Eq, Hash, Lift)]\n pub struct MatchExpressionArmCause<'tcx> {\n     pub arm_span: Span,\n+    pub scrut_span: Span,\n     pub semi_span: Option<Span>,\n     pub source: hir::MatchSource,\n     pub prior_arms: Vec<Span>,"}, {"sha": "7216d1305fd4bddeabc513820637057bba30d474", "filename": "compiler/rustc_mir_build/src/thir/pattern/_match.rs", "status": "modified", "additions": 32, "deletions": 8, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/07a63e6d1fabf3560e8e1e17c1d56b10a06152d9/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/07a63e6d1fabf3560e8e1e17c1d56b10a06152d9/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2F_match.rs?ref=07a63e6d1fabf3560e8e1e17c1d56b10a06152d9", "patch": "@@ -78,20 +78,26 @@\n //! new pattern `p`.\n //!\n //! For example, say we have the following:\n+//!\n //! ```\n-//!     // x: (Option<bool>, Result<()>)\n-//!     match x {\n-//!         (Some(true), _) => {}\n-//!         (None, Err(())) => {}\n-//!         (None, Err(_)) => {}\n-//!     }\n+//! // x: (Option<bool>, Result<()>)\n+//! match x {\n+//!     (Some(true), _) => {}\n+//!     (None, Err(())) => {}\n+//!     (None, Err(_)) => {}\n+//! }\n //! ```\n+//!\n //! Here, the matrix `P` starts as:\n+//!\n+//! ```\n //! [\n //!     [(Some(true), _)],\n //!     [(None, Err(()))],\n //!     [(None, Err(_))],\n //! ]\n+//! ```\n+//!\n //! We can tell it's not exhaustive, because `U(P, _)` is true (we're not covering\n //! `[(Some(false), _)]`, for instance). In addition, row 3 is not useful, because\n //! all the values it covers are already covered by row 2.\n@@ -178,10 +184,14 @@\n //! This special case is handled in `is_useful_specialized`.\n //!\n //! For example, if `P` is:\n+//!\n+//! ```\n //! [\n-//! [Some(true), _],\n-//! [None, 0],\n+//!     [Some(true), _],\n+//!     [None, 0],\n //! ]\n+//! ```\n+//!\n //! and `p` is [Some(false), 0], then we don't care about row 2 since we know `p` only\n //! matches values that row 2 doesn't. For row 1 however, we need to dig into the\n //! arguments of `Some` to know whether some new value is covered. So we compute\n@@ -198,10 +208,14 @@\n //! `U(P, p) := U(D(P), D(p))`\n //!\n //! For example, if `P` is:\n+//!\n+//! ```\n //! [\n //!     [_, true, _],\n //!     [None, false, 1],\n //! ]\n+//! ```\n+//!\n //! and `p` is [_, false, _], the `Some` constructor doesn't appear in `P`. So if we\n //! only had row 2, we'd know that `p` is useful. However row 1 starts with a\n //! wildcard, so we need to check whether `U([[true, _]], [false, 1])`.\n@@ -215,10 +229,14 @@\n //! `U(P, p) := \u2203(k \u03f5 constructors) U(S(k, P), S(k, p))`\n //!\n //! For example, if `P` is:\n+//!\n+//! ```\n //! [\n //!     [Some(true), _],\n //!     [None, false],\n //! ]\n+//! ```\n+//!\n //! and `p` is [_, false], both `None` and `Some` constructors appear in the first\n //! components of `P`. We will therefore try popping both constructors in turn: we\n //! compute `U([[true, _]], [_, false])` for the `Some` constructor, and `U([[false]],\n@@ -1496,6 +1514,7 @@ struct PatCtxt<'tcx> {\n /// multiple patterns.\n ///\n /// For example, if we are constructing a witness for the match against\n+///\n /// ```\n /// struct Pair(Option<(u32, u32)>, bool);\n ///\n@@ -1619,12 +1638,14 @@ fn all_constructors<'a, 'tcx>(\n             // actually match against them all themselves. So we always return only the fictitious\n             // constructor.\n             // E.g., in an example like:\n+            //\n             // ```\n             //     let err: io::ErrorKind = ...;\n             //     match err {\n             //         io::ErrorKind::NotFound => {},\n             //     }\n             // ```\n+            //\n             // we don't want to show every possible IO error, but instead have only `_` as the\n             // witness.\n             let is_declared_nonexhaustive = cx.is_foreign_non_exhaustive_enum(pcx.ty);\n@@ -2017,6 +2038,7 @@ crate fn is_useful<'p, 'tcx>(\n         let mut unreachable_branches = Vec::new();\n         // Subpatterns that are unreachable from all branches. E.g. in the following case, the last\n         // `true` is unreachable only from one branch, so it is overall reachable.\n+        //\n         // ```\n         // match (true, true) {\n         //     (true, true) => {}\n@@ -2161,10 +2183,12 @@ crate fn is_useful<'p, 'tcx>(\n             // to do this and instead report a single `_` witness:\n             // if the user didn't actually specify a constructor\n             // in this arm, e.g., in\n+            //\n             // ```\n             //     let x: (Direction, Direction, bool) = ...;\n             //     let (_, _, false) = x;\n             // ```\n+            //\n             // we don't want to show all 16 possible witnesses\n             // `(<direction-1>, <direction-2>, true)` - we are\n             // satisfied with `(_, _, true)`. In this case,"}, {"sha": "78c95428c7211f5991500995dad3498c65ca7770", "filename": "compiler/rustc_parse/src/parser/expr.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/07a63e6d1fabf3560e8e1e17c1d56b10a06152d9/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/07a63e6d1fabf3560e8e1e17c1d56b10a06152d9/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fexpr.rs?ref=07a63e6d1fabf3560e8e1e17c1d56b10a06152d9", "patch": "@@ -1062,8 +1062,8 @@ impl<'a> Parser<'a> {\n             })\n         } else if self.eat_keyword(kw::Unsafe) {\n             self.parse_block_expr(None, lo, BlockCheckMode::Unsafe(ast::UserProvided), attrs)\n-        } else if self.check_inline_const() {\n-            self.parse_const_expr(lo.to(self.token.span))\n+        } else if self.check_inline_const(0) {\n+            self.parse_const_block(lo.to(self.token.span))\n         } else if self.is_do_catch_block() {\n             self.recover_do_catch(attrs)\n         } else if self.is_try_block() {"}, {"sha": "8ff97453c14149700455c677c7c815c03fb4c141", "filename": "compiler/rustc_parse/src/parser/mod.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/07a63e6d1fabf3560e8e1e17c1d56b10a06152d9/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/07a63e6d1fabf3560e8e1e17c1d56b10a06152d9/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fmod.rs?ref=07a63e6d1fabf3560e8e1e17c1d56b10a06152d9", "patch": "@@ -522,9 +522,9 @@ impl<'a> Parser<'a> {\n         self.check_or_expected(self.token.can_begin_const_arg(), TokenType::Const)\n     }\n \n-    fn check_inline_const(&mut self) -> bool {\n-        self.check_keyword(kw::Const)\n-            && self.look_ahead(1, |t| match t.kind {\n+    fn check_inline_const(&self, dist: usize) -> bool {\n+        self.is_keyword_ahead(dist, &[kw::Const])\n+            && self.look_ahead(dist + 1, |t| match t.kind {\n                 token::Interpolated(ref nt) => matches!(**nt, token::NtBlock(..)),\n                 token::OpenDelim(DelimToken::Brace) => true,\n                 _ => false,\n@@ -864,7 +864,7 @@ impl<'a> Parser<'a> {\n     }\n \n     /// Parses inline const expressions.\n-    fn parse_const_expr(&mut self, span: Span) -> PResult<'a, P<Expr>> {\n+    fn parse_const_block(&mut self, span: Span) -> PResult<'a, P<Expr>> {\n         self.sess.gated_spans.gate(sym::inline_const, span);\n         self.eat_keyword(kw::Const);\n         let blk = self.parse_block()?;"}, {"sha": "27fe75a23b6a844c34b9af2634419c72cbe8edcd", "filename": "compiler/rustc_parse/src/parser/pat.rs", "status": "modified", "additions": 15, "deletions": 6, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/07a63e6d1fabf3560e8e1e17c1d56b10a06152d9/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fpat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/07a63e6d1fabf3560e8e1e17c1d56b10a06152d9/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fpat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fpat.rs?ref=07a63e6d1fabf3560e8e1e17c1d56b10a06152d9", "patch": "@@ -313,9 +313,15 @@ impl<'a> Parser<'a> {\n             let pat = self.parse_pat_with_range_pat(false, None)?;\n             self.sess.gated_spans.gate(sym::box_patterns, lo.to(self.prev_token.span));\n             PatKind::Box(pat)\n-        } else if self.check_inline_const() {\n+        } else if self.check_inline_const(0) {\n             // Parse `const pat`\n-            PatKind::Lit(self.parse_const_expr(lo.to(self.token.span))?)\n+            let const_expr = self.parse_const_block(lo.to(self.token.span))?;\n+\n+            if let Some(re) = self.parse_range_end() {\n+                self.parse_pat_range_begin_with(const_expr, re)?\n+            } else {\n+                PatKind::Lit(const_expr)\n+            }\n         } else if self.can_be_ident_pat() {\n             // Parse `ident @ pat`\n             // This can give false positives and parse nullary enums,\n@@ -717,16 +723,19 @@ impl<'a> Parser<'a> {\n \n     /// Is the token `dist` away from the current suitable as the start of a range patterns end?\n     fn is_pat_range_end_start(&self, dist: usize) -> bool {\n-        self.look_ahead(dist, |t| {\n-            t.is_path_start() // e.g. `MY_CONST`;\n+        self.check_inline_const(dist)\n+            || self.look_ahead(dist, |t| {\n+                t.is_path_start() // e.g. `MY_CONST`;\n                 || t.kind == token::Dot // e.g. `.5` for recovery;\n                 || t.can_begin_literal_maybe_minus() // e.g. `42`.\n                 || t.is_whole_expr()\n-        })\n+            })\n     }\n \n     fn parse_pat_range_end(&mut self) -> PResult<'a, P<Expr>> {\n-        if self.check_path() {\n+        if self.check_inline_const(0) {\n+            self.parse_const_block(self.token.span)\n+        } else if self.check_path() {\n             let lo = self.token.span;\n             let (qself, path) = if self.eat_lt() {\n                 // Parse a qualified path"}, {"sha": "398e013e62fb561b0f58da9bec9f8bb6c0388f95", "filename": "compiler/rustc_typeck/src/check/_match.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/07a63e6d1fabf3560e8e1e17c1d56b10a06152d9/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/07a63e6d1fabf3560e8e1e17c1d56b10a06152d9/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2F_match.rs?ref=07a63e6d1fabf3560e8e1e17c1d56b10a06152d9", "patch": "@@ -201,6 +201,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                         expr.span,\n                         ObligationCauseCode::MatchExpressionArm(box MatchExpressionArmCause {\n                             arm_span,\n+                            scrut_span: scrut.span,\n                             semi_span,\n                             source: match_src,\n                             prior_arms: other_arms.clone(),"}, {"sha": "6da3ecde329cfc0f72a7e9e62ba1e3ee0b2ae5eb", "filename": "compiler/rustc_typeck/src/check/coercion.rs", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/07a63e6d1fabf3560e8e1e17c1d56b10a06152d9/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcoercion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/07a63e6d1fabf3560e8e1e17c1d56b10a06152d9/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcoercion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcoercion.rs?ref=07a63e6d1fabf3560e8e1e17c1d56b10a06152d9", "patch": "@@ -1475,6 +1475,28 @@ impl<'tcx, 'exprs, E: AsCoercionSite> CoerceMany<'tcx, 'exprs, E> {\n         if let (Some(sp), Some(fn_output)) = (fcx.ret_coercion_span.borrow().as_ref(), fn_output) {\n             self.add_impl_trait_explanation(&mut err, cause, fcx, expected, *sp, fn_output);\n         }\n+\n+        if let Some(sp) = fcx.ret_coercion_span.borrow().as_ref() {\n+            // If the closure has an explicit return type annotation,\n+            // then a type error may occur at the first return expression we\n+            // see in the closure (if it conflicts with the declared\n+            // return type). Skip adding a note in this case, since it\n+            // would be incorrect.\n+            if !err.span.primary_spans().iter().any(|span| span == sp) {\n+                let hir = fcx.tcx.hir();\n+                let body_owner = hir.body_owned_by(hir.enclosing_body_owner(fcx.body_id));\n+                if fcx.tcx.is_closure(hir.body_owner_def_id(body_owner).to_def_id()) {\n+                    err.span_note(\n+                        *sp,\n+                        &format!(\n+                            \"return type inferred to be `{}` here\",\n+                            fcx.resolve_vars_if_possible(&expected)\n+                        ),\n+                    );\n+                }\n+            }\n+        }\n+\n         err\n     }\n "}, {"sha": "b30fb7be273f1fa2754db798ebb0d744ecfde337", "filename": "compiler/rustc_typeck/src/collect.rs", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/07a63e6d1fabf3560e8e1e17c1d56b10a06152d9/compiler%2Frustc_typeck%2Fsrc%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/07a63e6d1fabf3560e8e1e17c1d56b10a06152d9/compiler%2Frustc_typeck%2Fsrc%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcollect.rs?ref=07a63e6d1fabf3560e8e1e17c1d56b10a06152d9", "patch": "@@ -40,7 +40,7 @@ use rustc_middle::ty::query::Providers;\n use rustc_middle::ty::subst::InternalSubsts;\n use rustc_middle::ty::util::Discr;\n use rustc_middle::ty::util::IntTypeExt;\n-use rustc_middle::ty::{self, AdtKind, Const, ToPolyTraitRef, Ty, TyCtxt};\n+use rustc_middle::ty::{self, AdtKind, Const, DefIdTree, ToPolyTraitRef, Ty, TyCtxt};\n use rustc_middle::ty::{ReprOptions, ToPredicate, WithConstness};\n use rustc_session::config::SanitizerSet;\n use rustc_session::lint;\n@@ -2786,6 +2786,14 @@ fn codegen_fn_attrs(tcx: TyCtxt<'_>, id: DefId) -> CodegenFnAttrs {\n         }\n     });\n \n+    // #73631: closures inherit `#[target_feature]` annotations\n+    if tcx.features().target_feature_11 && tcx.is_closure(id) {\n+        let owner_id = tcx.parent(id).expect(\"closure should have a parent\");\n+        codegen_fn_attrs\n+            .target_features\n+            .extend(tcx.codegen_fn_attrs(owner_id).target_features.iter().copied())\n+    }\n+\n     // If a function uses #[target_feature] it can't be inlined into general\n     // purpose functions as they wouldn't have the right target features\n     // enabled. For that reason we also forbid #[inline(always)] as it can't be"}, {"sha": "7c834f034c1f157d1035caba65bfe49b14df201d", "filename": "library/alloc/src/raw_vec.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/07a63e6d1fabf3560e8e1e17c1d56b10a06152d9/library%2Falloc%2Fsrc%2Fraw_vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/07a63e6d1fabf3560e8e1e17c1d56b10a06152d9/library%2Falloc%2Fsrc%2Fraw_vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fraw_vec.rs?ref=07a63e6d1fabf3560e8e1e17c1d56b10a06152d9", "patch": "@@ -259,7 +259,7 @@ impl<T, A: AllocRef> RawVec<T, A> {\n     /// Ensures that the buffer contains at least enough space to hold `len +\n     /// additional` elements. If it doesn't already have enough capacity, will\n     /// reallocate enough space plus comfortable slack space to get amortized\n-    /// `O(1)` behavior. Will limit this behavior if it would needlessly cause\n+    /// *O*(1) behavior. Will limit this behavior if it would needlessly cause\n     /// itself to panic.\n     ///\n     /// If `len` exceeds `self.capacity()`, this may fail to actually allocate"}, {"sha": "3db66964941c3dbd679115f5d6d259ee242aa9ec", "filename": "library/alloc/src/slice.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/07a63e6d1fabf3560e8e1e17c1d56b10a06152d9/library%2Falloc%2Fsrc%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/07a63e6d1fabf3560e8e1e17c1d56b10a06152d9/library%2Falloc%2Fsrc%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fslice.rs?ref=07a63e6d1fabf3560e8e1e17c1d56b10a06152d9", "patch": "@@ -167,7 +167,7 @@ mod hack {\n impl<T> [T] {\n     /// Sorts the slice.\n     ///\n-    /// This sort is stable (i.e., does not reorder equal elements) and `O(n * log(n))` worst-case.\n+    /// This sort is stable (i.e., does not reorder equal elements) and *O*(*n* \\* log(*n*)) worst-case.\n     ///\n     /// When applicable, unstable sorting is preferred because it is generally faster than stable\n     /// sorting and it doesn't allocate auxiliary memory.\n@@ -202,7 +202,7 @@ impl<T> [T] {\n \n     /// Sorts the slice with a comparator function.\n     ///\n-    /// This sort is stable (i.e., does not reorder equal elements) and `O(n * log(n))` worst-case.\n+    /// This sort is stable (i.e., does not reorder equal elements) and *O*(*n* \\* log(*n*)) worst-case.\n     ///\n     /// The comparator function must define a total ordering for the elements in the slice. If\n     /// the ordering is not total, the order of the elements is unspecified. An order is a\n@@ -256,8 +256,8 @@ impl<T> [T] {\n \n     /// Sorts the slice with a key extraction function.\n     ///\n-    /// This sort is stable (i.e., does not reorder equal elements) and `O(m * n * log(n))`\n-    /// worst-case, where the key function is `O(m)`.\n+    /// This sort is stable (i.e., does not reorder equal elements) and *O*(*m* \\* *n* \\* log(*n*))\n+    /// worst-case, where the key function is *O*(*m*).\n     ///\n     /// For expensive key functions (e.g. functions that are not simple property accesses or\n     /// basic operations), [`sort_by_cached_key`](#method.sort_by_cached_key) is likely to be\n@@ -299,8 +299,8 @@ impl<T> [T] {\n     ///\n     /// During sorting, the key function is called only once per element.\n     ///\n-    /// This sort is stable (i.e., does not reorder equal elements) and `O(m * n + n * log(n))`\n-    /// worst-case, where the key function is `O(m)`.\n+    /// This sort is stable (i.e., does not reorder equal elements) and *O*(*m* \\* *n* + *n* \\* log(*n*))\n+    /// worst-case, where the key function is *O*(*m*).\n     ///\n     /// For simple key functions (e.g., functions that are property accesses or\n     /// basic operations), [`sort_by_key`](#method.sort_by_key) is likely to be\n@@ -944,7 +944,7 @@ where\n /// 1. for every `i` in `1..runs.len()`: `runs[i - 1].len > runs[i].len`\n /// 2. for every `i` in `2..runs.len()`: `runs[i - 2].len > runs[i - 1].len + runs[i].len`\n ///\n-/// The invariants ensure that the total running time is `O(n * log(n))` worst-case.\n+/// The invariants ensure that the total running time is *O*(*n* \\* log(*n*)) worst-case.\n fn merge_sort<T, F>(v: &mut [T], mut is_less: F)\n where\n     F: FnMut(&T, &T) -> bool,"}, {"sha": "72ed036637d8b074d512b7ab728671c3489e6ba0", "filename": "library/alloc/src/string.rs", "status": "modified", "additions": 10, "deletions": 9, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/07a63e6d1fabf3560e8e1e17c1d56b10a06152d9/library%2Falloc%2Fsrc%2Fstring.rs", "raw_url": "https://github.com/rust-lang/rust/raw/07a63e6d1fabf3560e8e1e17c1d56b10a06152d9/library%2Falloc%2Fsrc%2Fstring.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fstring.rs?ref=07a63e6d1fabf3560e8e1e17c1d56b10a06152d9", "patch": "@@ -1,8 +1,8 @@\n-//! A UTF-8 encoded, growable string.\n+//! A UTF-8\u2013encoded, growable string.\n //!\n-//! This module contains the [`String`] type, a trait for converting\n-//! [`ToString`]s, and several error types that may result from working with\n-//! [`String`]s.\n+//! This module contains the [`String`] type, the [`ToString`] trait for\n+//! converting to strings, and several error types that may result from\n+//! working with [`String`]s.\n //!\n //! # Examples\n //!\n@@ -57,7 +57,7 @@ use crate::collections::TryReserveError;\n use crate::str::{self, from_boxed_utf8_unchecked, Chars, FromStr, Utf8Error};\n use crate::vec::Vec;\n \n-/// A UTF-8 encoded, growable string.\n+/// A UTF-8\u2013encoded, growable string.\n ///\n /// The `String` type is the most common string type that has ownership over the\n /// contents of the string. It has a close relationship with its borrowed\n@@ -565,7 +565,7 @@ impl String {\n         Cow::Owned(res)\n     }\n \n-    /// Decode a UTF-16 encoded vector `v` into a `String`, returning [`Err`]\n+    /// Decode a UTF-16\u2013encoded vector `v` into a `String`, returning [`Err`]\n     /// if `v` contains any invalid data.\n     ///\n     /// # Examples\n@@ -599,7 +599,7 @@ impl String {\n         Ok(ret)\n     }\n \n-    /// Decode a UTF-16 encoded slice `v` into a `String`, replacing\n+    /// Decode a UTF-16\u2013encoded slice `v` into a `String`, replacing\n     /// invalid data with [the replacement character (`U+FFFD`)][U+FFFD].\n     ///\n     /// Unlike [`from_utf8_lossy`] which returns a [`Cow<'a, str>`],\n@@ -2191,8 +2191,9 @@ pub trait ToString {\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T: fmt::Display + ?Sized> ToString for T {\n     // A common guideline is to not inline generic functions. However,\n-    // remove `#[inline]` from this method causes non-negligible regression.\n-    // See <https://github.com/rust-lang/rust/pull/74852> as last attempt try to remove it.\n+    // removing `#[inline]` from this method causes non-negligible regressions.\n+    // See <https://github.com/rust-lang/rust/pull/74852>, the last attempt\n+    // to try to remove it.\n     #[inline]\n     default fn to_string(&self) -> String {\n         use fmt::Write;"}, {"sha": "5b3604db563c6092549d6f654c73dda99122bda0", "filename": "library/alloc/src/vec.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/07a63e6d1fabf3560e8e1e17c1d56b10a06152d9/library%2Falloc%2Fsrc%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/07a63e6d1fabf3560e8e1e17c1d56b10a06152d9/library%2Falloc%2Fsrc%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fvec.rs?ref=07a63e6d1fabf3560e8e1e17c1d56b10a06152d9", "patch": "@@ -259,7 +259,7 @@ use crate::raw_vec::RawVec;\n /// `Vec` does not guarantee any particular growth strategy when reallocating\n /// when full, nor when [`reserve`] is called. The current strategy is basic\n /// and it may prove desirable to use a non-constant growth factor. Whatever\n-/// strategy is used will of course guarantee `O(1)` amortized [`push`].\n+/// strategy is used will of course guarantee *O*(1) amortized [`push`].\n ///\n /// `vec![x; n]`, `vec![a, b, c, d]`, and\n /// [`Vec::with_capacity(n)`][`Vec::with_capacity`], will all produce a `Vec`"}, {"sha": "2dd5e813d6fb7bbe2e2d504f06b9992089cb1192", "filename": "library/core/src/convert/num.rs", "status": "modified", "additions": 46, "deletions": 0, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/07a63e6d1fabf3560e8e1e17c1d56b10a06152d9/library%2Fcore%2Fsrc%2Fconvert%2Fnum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/07a63e6d1fabf3560e8e1e17c1d56b10a06152d9/library%2Fcore%2Fsrc%2Fconvert%2Fnum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fconvert%2Fnum.rs?ref=07a63e6d1fabf3560e8e1e17c1d56b10a06152d9", "patch": "@@ -485,3 +485,49 @@ nzint_impl_try_from_int! { i32, NonZeroI32, #[stable(feature = \"nzint_try_from_i\n nzint_impl_try_from_int! { i64, NonZeroI64, #[stable(feature = \"nzint_try_from_int_conv\", since = \"1.46.0\")] }\n nzint_impl_try_from_int! { i128, NonZeroI128, #[stable(feature = \"nzint_try_from_int_conv\", since = \"1.46.0\")] }\n nzint_impl_try_from_int! { isize, NonZeroIsize, #[stable(feature = \"nzint_try_from_int_conv\", since = \"1.46.0\")] }\n+\n+macro_rules! nzint_impl_try_from_nzint {\n+    ($From:ty => $To:ty, $doc: expr) => {\n+        #[stable(feature = \"nzint_try_from_nzint_conv\", since = \"1.49.0\")]\n+        #[doc = $doc]\n+        impl TryFrom<$From> for $To {\n+            type Error = TryFromIntError;\n+\n+            #[inline]\n+            fn try_from(value: $From) -> Result<Self, Self::Error> {\n+                TryFrom::try_from(value.get()).map(|v| {\n+                    // SAFETY: $From is a NonZero type, so v is not zero.\n+                    unsafe { Self::new_unchecked(v) }\n+                })\n+            }\n+        }\n+    };\n+    ($To:ty: $($From: ty),*) => {$(\n+        nzint_impl_try_from_nzint!(\n+            $From => $To,\n+            concat!(\n+                \"Attempts to convert `\",\n+                stringify!($From),\n+                \"` to `\",\n+                stringify!($To),\n+                \"`.\",\n+            )\n+        );\n+    )*};\n+}\n+\n+// Non-zero int -> non-zero unsigned int\n+nzint_impl_try_from_nzint! { NonZeroU8: NonZeroI8, NonZeroU16, NonZeroI16, NonZeroU32, NonZeroI32, NonZeroU64, NonZeroI64, NonZeroU128, NonZeroI128, NonZeroUsize, NonZeroIsize }\n+nzint_impl_try_from_nzint! { NonZeroU16: NonZeroI8, NonZeroI16, NonZeroU32, NonZeroI32, NonZeroU64, NonZeroI64, NonZeroU128, NonZeroI128, NonZeroUsize, NonZeroIsize }\n+nzint_impl_try_from_nzint! { NonZeroU32: NonZeroI8, NonZeroI16, NonZeroI32, NonZeroU64, NonZeroI64, NonZeroU128, NonZeroI128, NonZeroUsize, NonZeroIsize }\n+nzint_impl_try_from_nzint! { NonZeroU64: NonZeroI8, NonZeroI16, NonZeroI32, NonZeroI64, NonZeroU128, NonZeroI128, NonZeroUsize, NonZeroIsize }\n+nzint_impl_try_from_nzint! { NonZeroU128: NonZeroI8, NonZeroI16, NonZeroI32, NonZeroI64, NonZeroI128, NonZeroUsize, NonZeroIsize }\n+nzint_impl_try_from_nzint! { NonZeroUsize: NonZeroI8, NonZeroI16, NonZeroU32, NonZeroI32, NonZeroU64, NonZeroI64, NonZeroU128, NonZeroI128, NonZeroIsize }\n+\n+// Non-zero int -> non-zero signed int\n+nzint_impl_try_from_nzint! { NonZeroI8: NonZeroU8, NonZeroU16, NonZeroI16, NonZeroU32, NonZeroI32, NonZeroU64, NonZeroI64, NonZeroU128, NonZeroI128, NonZeroUsize, NonZeroIsize }\n+nzint_impl_try_from_nzint! { NonZeroI16: NonZeroU16, NonZeroU32, NonZeroI32, NonZeroU64, NonZeroI64, NonZeroU128, NonZeroI128, NonZeroUsize, NonZeroIsize }\n+nzint_impl_try_from_nzint! { NonZeroI32: NonZeroU32, NonZeroU64, NonZeroI64, NonZeroU128, NonZeroI128, NonZeroUsize, NonZeroIsize }\n+nzint_impl_try_from_nzint! { NonZeroI64: NonZeroU64, NonZeroU128, NonZeroI128, NonZeroUsize, NonZeroIsize }\n+nzint_impl_try_from_nzint! { NonZeroI128: NonZeroU128, NonZeroUsize, NonZeroIsize }\n+nzint_impl_try_from_nzint! { NonZeroIsize: NonZeroU16, NonZeroU32, NonZeroI32, NonZeroU64, NonZeroI64, NonZeroU128, NonZeroI128, NonZeroUsize }"}, {"sha": "376ad321f64a3f2f99906979421e870dba7cd3d0", "filename": "library/core/src/slice/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/07a63e6d1fabf3560e8e1e17c1d56b10a06152d9/library%2Fcore%2Fsrc%2Fslice%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/07a63e6d1fabf3560e8e1e17c1d56b10a06152d9/library%2Fcore%2Fsrc%2Fslice%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fslice%2Fmod.rs?ref=07a63e6d1fabf3560e8e1e17c1d56b10a06152d9", "patch": "@@ -1945,10 +1945,10 @@ impl<T> [T] {\n     ///\n     /// The comparator function must define a total ordering for the elements in the slice. If\n     /// the ordering is not total, the order of the elements is unspecified. An order is a\n-    /// total order if it is (for all a, b and c):\n+    /// total order if it is (for all `a`, `b` and `c`):\n     ///\n-    /// * total and antisymmetric: exactly one of a < b, a == b or a > b is true; and\n-    /// * transitive, a < b and b < c implies a < c. The same must hold for both == and >.\n+    /// * total and antisymmetric: exactly one of `a < b`, `a == b` or `a > b` is true, and\n+    /// * transitive, `a < b` and `b < c` implies `a < c`. The same must hold for both `==` and `>`.\n     ///\n     /// For example, while [`f64`] doesn't implement [`Ord`] because `NaN != NaN`, we can use\n     /// `partial_cmp` as our sort function when we know the slice doesn't contain a `NaN`."}, {"sha": "af1ce007e8b7c826ab8e827f67151b6a2dfda532", "filename": "library/core/src/str/traits.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/07a63e6d1fabf3560e8e1e17c1d56b10a06152d9/library%2Fcore%2Fsrc%2Fstr%2Ftraits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/07a63e6d1fabf3560e8e1e17c1d56b10a06152d9/library%2Fcore%2Fsrc%2Fstr%2Ftraits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fstr%2Ftraits.rs?ref=07a63e6d1fabf3560e8e1e17c1d56b10a06152d9", "patch": "@@ -89,7 +89,7 @@ fn str_index_overflow_fail() -> ! {\n /// self`. Equivalent to `&self[0 .. len]` or `&mut self[0 .. len]`. Unlike\n /// other indexing operations, this can never panic.\n ///\n-/// This operation is `O(1)`.\n+/// This operation is *O*(1).\n ///\n /// Prior to 1.20.0, these indexing operations were still supported by\n /// direct implementation of `Index` and `IndexMut`.\n@@ -130,7 +130,7 @@ unsafe impl SliceIndex<str> for ops::RangeFull {\n /// Returns a slice of the given string from the byte range\n /// [`begin`, `end`).\n ///\n-/// This operation is `O(1)`.\n+/// This operation is *O*(1).\n ///\n /// Prior to 1.20.0, these indexing operations were still supported by\n /// direct implementation of `Index` and `IndexMut`.\n@@ -237,7 +237,7 @@ unsafe impl SliceIndex<str> for ops::Range<usize> {\n /// Returns a slice of the given string from the byte range [`0`, `end`).\n /// Equivalent to `&self[0 .. end]` or `&mut self[0 .. end]`.\n ///\n-/// This operation is `O(1)`.\n+/// This operation is *O*(1).\n ///\n /// Prior to 1.20.0, these indexing operations were still supported by\n /// direct implementation of `Index` and `IndexMut`.\n@@ -308,7 +308,7 @@ unsafe impl SliceIndex<str> for ops::RangeTo<usize> {\n /// `len`). Equivalent to `&self[begin .. len]` or `&mut self[begin ..\n /// len]`.\n ///\n-/// This operation is `O(1)`.\n+/// This operation is *O*(1).\n ///\n /// Prior to 1.20.0, these indexing operations were still supported by\n /// direct implementation of `Index` and `IndexMut`.\n@@ -385,7 +385,7 @@ unsafe impl SliceIndex<str> for ops::RangeFrom<usize> {\n /// self[begin .. end + 1]`, except if `end` has the maximum value for\n /// `usize`.\n ///\n-/// This operation is `O(1)`.\n+/// This operation is *O*(1).\n ///\n /// # Panics\n ///\n@@ -441,7 +441,7 @@ unsafe impl SliceIndex<str> for ops::RangeInclusive<usize> {\n /// Equivalent to `&self [0 .. end + 1]`, except if `end` has the maximum\n /// value for `usize`.\n ///\n-/// This operation is `O(1)`.\n+/// This operation is *O*(1).\n ///\n /// # Panics\n ///"}, {"sha": "38fd470a1c3227d936500b090e34816b609e8a8e", "filename": "library/std/src/fs/tests.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/07a63e6d1fabf3560e8e1e17c1d56b10a06152d9/library%2Fstd%2Fsrc%2Ffs%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/07a63e6d1fabf3560e8e1e17c1d56b10a06152d9/library%2Fstd%2Fsrc%2Ffs%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Ffs%2Ftests.rs?ref=07a63e6d1fabf3560e8e1e17c1d56b10a06152d9", "patch": "@@ -73,10 +73,9 @@ pub fn got_symlink_permission(tmpdir: &TempDir) -> bool {\n     let link = tmpdir.join(\"some_hopefully_unique_link_name\");\n \n     match symlink_file(r\"nonexisting_target\", link) {\n-        Ok(_) => true,\n         // ERROR_PRIVILEGE_NOT_HELD = 1314\n         Err(ref err) if err.raw_os_error() == Some(1314) => false,\n-        Err(_) => true,\n+        Ok(_) | Err(_) => true,\n     }\n }\n "}, {"sha": "fbed3d32d451af446ee6df0ccedb40fd0333b35f", "filename": "library/std/src/net/udp/tests.rs", "status": "modified", "additions": 4, "deletions": 10, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/07a63e6d1fabf3560e8e1e17c1d56b10a06152d9/library%2Fstd%2Fsrc%2Fnet%2Fudp%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/07a63e6d1fabf3560e8e1e17c1d56b10a06152d9/library%2Fstd%2Fsrc%2Fnet%2Fudp%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fnet%2Fudp%2Ftests.rs?ref=07a63e6d1fabf3560e8e1e17c1d56b10a06152d9", "patch": "@@ -152,19 +152,13 @@ fn udp_clone_two_write() {\n         let (done, rx) = channel();\n         let tx2 = tx.clone();\n         let _t = thread::spawn(move || {\n-            match sock3.send_to(&[1], &addr2) {\n-                Ok(..) => {\n-                    let _ = tx2.send(());\n-                }\n-                Err(..) => {}\n+            if sock3.send_to(&[1], &addr2).is_ok() {\n+                let _ = tx2.send(());\n             }\n             done.send(()).unwrap();\n         });\n-        match sock1.send_to(&[2], &addr2) {\n-            Ok(..) => {\n-                let _ = tx.send(());\n-            }\n-            Err(..) => {}\n+        if sock1.send_to(&[2], &addr2).is_ok() {\n+            let _ = tx.send(());\n         }\n         drop(tx);\n "}, {"sha": "4dc4162700c6e2be577ec184208cec6e6749c4eb", "filename": "library/test/src/formatters/json.rs", "status": "modified", "additions": 10, "deletions": 4, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/07a63e6d1fabf3560e8e1e17c1d56b10a06152d9/library%2Ftest%2Fsrc%2Fformatters%2Fjson.rs", "raw_url": "https://github.com/rust-lang/rust/raw/07a63e6d1fabf3560e8e1e17c1d56b10a06152d9/library%2Ftest%2Fsrc%2Fformatters%2Fjson.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Ftest%2Fsrc%2Fformatters%2Fjson.rs?ref=07a63e6d1fabf3560e8e1e17c1d56b10a06152d9", "patch": "@@ -39,9 +39,12 @@ impl<T: Write> JsonFormatter<T> {\n         stdout: Option<Cow<'_, str>>,\n         extra: Option<&str>,\n     ) -> io::Result<()> {\n+        // A doc test's name includes a filename which must be escaped for correct json.\n         self.write_message(&*format!(\n             r#\"{{ \"type\": \"{}\", \"name\": \"{}\", \"event\": \"{}\"\"#,\n-            ty, name, evt\n+            ty,\n+            EscapedString(name),\n+            evt\n         ))?;\n         if let Some(exec_time) = exec_time {\n             self.write_message(&*format!(r#\", \"exec_time\": \"{}\"\"#, exec_time))?;\n@@ -67,7 +70,7 @@ impl<T: Write> OutputFormatter for JsonFormatter<T> {\n     fn write_test_start(&mut self, desc: &TestDesc) -> io::Result<()> {\n         self.writeln_message(&*format!(\n             r#\"{{ \"type\": \"test\", \"event\": \"started\", \"name\": \"{}\" }}\"#,\n-            desc.name\n+            EscapedString(desc.name.as_slice())\n         ))\n     }\n \n@@ -140,7 +143,10 @@ impl<T: Write> OutputFormatter for JsonFormatter<T> {\n                      \\\"name\\\": \\\"{}\\\", \\\n                      \\\"median\\\": {}, \\\n                      \\\"deviation\\\": {}{} }}\",\n-                    desc.name, median, deviation, mbps\n+                    EscapedString(desc.name.as_slice()),\n+                    median,\n+                    deviation,\n+                    mbps\n                 );\n \n                 self.writeln_message(&*line)\n@@ -151,7 +157,7 @@ impl<T: Write> OutputFormatter for JsonFormatter<T> {\n     fn write_timeout(&mut self, desc: &TestDesc) -> io::Result<()> {\n         self.writeln_message(&*format!(\n             r#\"{{ \"type\": \"test\", \"event\": \"timeout\", \"name\": \"{}\" }}\"#,\n-            desc.name\n+            EscapedString(desc.name.as_slice())\n         ))\n     }\n "}, {"sha": "8fe0d2584f7a91d1d355913ffa5c21e20e1d27ef", "filename": "src/bootstrap/bootstrap.py", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/07a63e6d1fabf3560e8e1e17c1d56b10a06152d9/src%2Fbootstrap%2Fbootstrap.py", "raw_url": "https://github.com/rust-lang/rust/raw/07a63e6d1fabf3560e8e1e17c1d56b10a06152d9/src%2Fbootstrap%2Fbootstrap.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fbootstrap.py?ref=07a63e6d1fabf3560e8e1e17c1d56b10a06152d9", "patch": "@@ -893,10 +893,15 @@ def update_submodules(self):\n         ).decode(default_encoding).splitlines()]\n         filtered_submodules = []\n         submodules_names = []\n+        llvm_checked_out = os.path.exists(os.path.join(self.rust_root, \"src/llvm-project/.git\"))\n         for module in submodules:\n             if module.endswith(\"llvm-project\"):\n+                # Don't sync the llvm-project submodule either if an external LLVM\n+                # was provided, or if we are downloading LLVM. Also, if the\n+                # submodule has been initialized already, sync it anyways so that\n+                # it doesn't mess up contributor pull requests.\n                 if self.get_toml('llvm-config') or self.downloading_llvm():\n-                    if self.get_toml('lld') != 'true':\n+                    if self.get_toml('lld') != 'true' and not llvm_checked_out:\n                         continue\n             check = self.check_submodule(module, slow_submodules)\n             filtered_submodules.append((module, check))"}, {"sha": "387d86189b08f1cdf0dd41a08efcd88ea9672284", "filename": "src/doc/rustdoc/src/documentation-tests.md", "status": "modified", "additions": 15, "deletions": 13, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/07a63e6d1fabf3560e8e1e17c1d56b10a06152d9/src%2Fdoc%2Frustdoc%2Fsrc%2Fdocumentation-tests.md", "raw_url": "https://github.com/rust-lang/rust/raw/07a63e6d1fabf3560e8e1e17c1d56b10a06152d9/src%2Fdoc%2Frustdoc%2Fsrc%2Fdocumentation-tests.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Frustdoc%2Fsrc%2Fdocumentation-tests.md?ref=07a63e6d1fabf3560e8e1e17c1d56b10a06152d9", "patch": "@@ -16,8 +16,8 @@ The basic idea is this:\n The triple backticks start and end code blocks. If this were in a file named `foo.rs`,\n running `rustdoc --test foo.rs` will extract this example, and then run it as a test.\n \n-Please note that by default, if no language is set for the block code, `rustdoc`\n-assumes it is `Rust` code. So the following:\n+Please note that by default, if no language is set for the block code, rustdoc\n+assumes it is Rust code. So the following:\n \n ``````markdown\n ```rust\n@@ -44,7 +44,6 @@ the `assert!` family of macros works the same as other Rust code:\n \n ```rust\n let foo = \"foo\";\n-\n assert_eq!(foo, \"foo\");\n ```\n \n@@ -55,8 +54,9 @@ the code panics and the doctest fails.\n \n In the example above, you'll note something strange: there's no `main`\n function! Forcing you to write `main` for every example, no matter how small,\n-adds friction. So `rustdoc` processes your examples slightly before\n-running them. Here's the full algorithm rustdoc uses to preprocess examples:\n+adds friction and clutters the output. So `rustdoc` processes your examples\n+slightly before running them. Here's the full algorithm `rustdoc` uses to\n+preprocess examples:\n \n 1. Some common `allow` attributes are inserted, including\n    `unused_variables`, `unused_assignments`, `unused_mut`,\n@@ -78,10 +78,12 @@ Sometimes, you need some setup code, or other things that would distract\n from your example, but are important to make the tests work. Consider\n an example block that looks like this:\n \n-```text\n+```ignore\n+/// ```\n /// /// Some documentation.\n /// # fn foo() {} // this function will be hidden\n /// println!(\"Hello, World!\");\n+/// ```\n ```\n \n It will render like this:\n@@ -251,7 +253,7 @@ disambiguate the error type:\n This is an unfortunate consequence of the `?` operator adding an implicit\n conversion, so type inference fails because the type is not unique. Please note\n that you must write the `(())` in one sequence without intermediate whitespace\n-so that rustdoc understands you want an implicit `Result`-returning function.\n+so that `rustdoc` understands you want an implicit `Result`-returning function.\n \n ## Documenting macros\n \n@@ -359,7 +361,7 @@ the code with the 2015 edition.\n ## Syntax reference\n \n The *exact* syntax for code blocks, including the edge cases, can be found\n-in the [Fenced Code Blocks](https://spec.commonmark.org/0.28/#fenced-code-blocks)\n+in the [Fenced Code Blocks](https://spec.commonmark.org/0.29/#fenced-code-blocks)\n section of the CommonMark specification.\n \n Rustdoc also accepts *indented* code blocks as an alternative to fenced\n@@ -372,7 +374,7 @@ can indent each line by four or more spaces.\n ``````\n \n These, too, are documented in the CommonMark specification, in the\n-[Indented Code Blocks](https://spec.commonmark.org/0.28/#indented-code-blocks)\n+[Indented Code Blocks](https://spec.commonmark.org/0.29/#indented-code-blocks)\n section.\n \n However, it's preferable to use fenced code blocks over indented code blocks.\n@@ -388,7 +390,7 @@ documentation. To this end, Rustdoc allows you to have certain items only appear\n collecting doctests, so you can utilize doctest functionality without forcing the test to appear in\n docs, or to find an arbitrary private item to include it on.\n \n-When compiling a crate for use in doctests (with `--test` option), rustdoc will set `cfg(doctest)`.\n+When compiling a crate for use in doctests (with `--test` option), `rustdoc` will set `#[cfg(doctest)]`.\n Note that they will still link against only the public items of your crate; if you need to test\n private items, you need to write a unit test.\n \n@@ -407,18 +409,18 @@ pub struct MyStructOnlyTakesUsize;\n ```\n \n Note that the struct `MyStructOnlyTakesUsize` here isn't actually part of your public crate\n-API. The use of `#[cfg(doctest)]` makes sure that this struct only exists while rustdoc is\n+API. The use of `#[cfg(doctest)]` makes sure that this struct only exists while `rustdoc` is\n collecting doctests. This means that its doctest is executed when `--test` is passed to rustdoc,\n but is hidden from the public documentation.\n \n-Another possible use of `cfg(doctest)` is to test doctests that are included in your README file\n+Another possible use of `#[cfg(doctest)]` is to test doctests that are included in your README file\n without including it in your main documentation. For example, you could write this into your\n `lib.rs` to test your README as part of your doctests:\n \n ```rust,ignore\n #![feature(external_doc)]\n \n-#[doc(include=\"../README.md\")]\n+#[doc(include = \"../README.md\")]\n #[cfg(doctest)]\n pub struct ReadmeDoctests;\n ```"}, {"sha": "1726093c6facbba4d82ca313f2859fec46f4d473", "filename": "src/librustdoc/html/render/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/07a63e6d1fabf3560e8e1e17c1d56b10a06152d9/src%2Flibrustdoc%2Fhtml%2Frender%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/07a63e6d1fabf3560e8e1e17c1d56b10a06152d9/src%2Flibrustdoc%2Fhtml%2Frender%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender%2Fmod.rs?ref=07a63e6d1fabf3560e8e1e17c1d56b10a06152d9", "patch": "@@ -2384,7 +2384,7 @@ fn item_static(w: &mut Buffer, cx: &Context, it: &clean::Item, s: &clean::Static\n     render_attributes(w, it, false);\n     write!(\n         w,\n-        \"{vis}static {mutability} {name}: {typ}</pre>\",\n+        \"{vis}static {mutability}{name}: {typ}</pre>\",\n         vis = it.visibility.print_with_space(),\n         mutability = s.mutability.print_with_space(),\n         name = it.name.as_ref().unwrap(),"}, {"sha": "90dafd8b3480d4a17f891f07357d165f5010f60c", "filename": "src/test/rustdoc/static.rs", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/07a63e6d1fabf3560e8e1e17c1d56b10a06152d9/src%2Ftest%2Frustdoc%2Fstatic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/07a63e6d1fabf3560e8e1e17c1d56b10a06152d9/src%2Ftest%2Frustdoc%2Fstatic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fstatic.rs?ref=07a63e6d1fabf3560e8e1e17c1d56b10a06152d9", "patch": "@@ -0,0 +1,12 @@\n+// compile-flags: --document-private-items\n+\n+#![crate_type = \"lib\"]\n+\n+// @has static/static.FOO.html '//pre' 'static FOO: usize'\n+static FOO: usize = 1;\n+\n+// @has static/static.BAR.html '//pre' 'pub static BAR: usize'\n+pub static BAR: usize = 1;\n+\n+// @has static/static.BAZ.html '//pre' 'pub static mut BAZ: usize'\n+pub static mut BAZ: usize = 1;"}, {"sha": "1631bb303e54e0c702f88acdb8947d618c16d267", "filename": "src/test/ui/closures/closure-return-type-mismatch.rs", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/07a63e6d1fabf3560e8e1e17c1d56b10a06152d9/src%2Ftest%2Fui%2Fclosures%2Fclosure-return-type-mismatch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/07a63e6d1fabf3560e8e1e17c1d56b10a06152d9/src%2Ftest%2Fui%2Fclosures%2Fclosure-return-type-mismatch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fclosures%2Fclosure-return-type-mismatch.rs?ref=07a63e6d1fabf3560e8e1e17c1d56b10a06152d9", "patch": "@@ -0,0 +1,17 @@\n+fn main() {\n+    || {\n+        if false {\n+            return \"test\";\n+        }\n+        let a = true;\n+        a //~ ERROR mismatched types\n+    };\n+\n+    || -> bool {\n+        if false {\n+            return \"hello\" //~ ERROR mismatched types\n+        };\n+        let b = true;\n+        b\n+    };\n+}"}, {"sha": "3a89d30a05d2042b7106730d21aabcf5b20b2306", "filename": "src/test/ui/closures/closure-return-type-mismatch.stderr", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/07a63e6d1fabf3560e8e1e17c1d56b10a06152d9/src%2Ftest%2Fui%2Fclosures%2Fclosure-return-type-mismatch.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/07a63e6d1fabf3560e8e1e17c1d56b10a06152d9/src%2Ftest%2Fui%2Fclosures%2Fclosure-return-type-mismatch.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fclosures%2Fclosure-return-type-mismatch.stderr?ref=07a63e6d1fabf3560e8e1e17c1d56b10a06152d9", "patch": "@@ -0,0 +1,21 @@\n+error[E0308]: mismatched types\n+  --> $DIR/closure-return-type-mismatch.rs:7:9\n+   |\n+LL |         a\n+   |         ^ expected `&str`, found `bool`\n+   |\n+note: return type inferred to be `&str` here\n+  --> $DIR/closure-return-type-mismatch.rs:4:20\n+   |\n+LL |             return \"test\";\n+   |                    ^^^^^^\n+\n+error[E0308]: mismatched types\n+  --> $DIR/closure-return-type-mismatch.rs:12:20\n+   |\n+LL |             return \"hello\"\n+   |                    ^^^^^^^ expected `bool`, found `&str`\n+\n+error: aborting due to 2 previous errors\n+\n+For more information about this error, try `rustc --explain E0308`."}, {"sha": "b939a70dfc568a6c4e27d2e759b1ad18746d0cfc", "filename": "src/test/ui/enum-discriminant/discriminant_size.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/07a63e6d1fabf3560e8e1e17c1d56b10a06152d9/src%2Ftest%2Fui%2Fenum-discriminant%2Fdiscriminant_size.rs", "raw_url": "https://github.com/rust-lang/rust/raw/07a63e6d1fabf3560e8e1e17c1d56b10a06152d9/src%2Ftest%2Fui%2Fenum-discriminant%2Fdiscriminant_size.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fenum-discriminant%2Fdiscriminant_size.rs?ref=07a63e6d1fabf3560e8e1e17c1d56b10a06152d9", "patch": "@@ -1,5 +1,6 @@\n // run-pass\n #![feature(core_intrinsics, repr128)]\n+//~^ WARN the feature `repr128` is incomplete\n \n use std::intrinsics::discriminant_value;\n "}, {"sha": "efc7d998466cd3939f8d11636601b0ac34e57d56", "filename": "src/test/ui/enum-discriminant/discriminant_size.stderr", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/07a63e6d1fabf3560e8e1e17c1d56b10a06152d9/src%2Ftest%2Fui%2Fenum-discriminant%2Fdiscriminant_size.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/07a63e6d1fabf3560e8e1e17c1d56b10a06152d9/src%2Ftest%2Fui%2Fenum-discriminant%2Fdiscriminant_size.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fenum-discriminant%2Fdiscriminant_size.stderr?ref=07a63e6d1fabf3560e8e1e17c1d56b10a06152d9", "patch": "@@ -0,0 +1,11 @@\n+warning: the feature `repr128` is incomplete and may not be safe to use and/or cause compiler crashes\n+  --> $DIR/discriminant_size.rs:2:29\n+   |\n+LL | #![feature(core_intrinsics, repr128)]\n+   |                             ^^^^^^^\n+   |\n+   = note: `#[warn(incomplete_features)]` on by default\n+   = note: see issue #56071 <https://github.com/rust-lang/rust/issues/56071> for more information\n+\n+warning: 1 warning emitted\n+"}, {"sha": "ae389e11466452035905fe992002533ba57d20b1", "filename": "src/test/ui/enum-discriminant/issue-70509-partial_eq.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/07a63e6d1fabf3560e8e1e17c1d56b10a06152d9/src%2Ftest%2Fui%2Fenum-discriminant%2Fissue-70509-partial_eq.rs", "raw_url": "https://github.com/rust-lang/rust/raw/07a63e6d1fabf3560e8e1e17c1d56b10a06152d9/src%2Ftest%2Fui%2Fenum-discriminant%2Fissue-70509-partial_eq.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fenum-discriminant%2Fissue-70509-partial_eq.rs?ref=07a63e6d1fabf3560e8e1e17c1d56b10a06152d9", "patch": "@@ -1,5 +1,6 @@\n // run-pass\n #![feature(repr128, arbitrary_enum_discriminant)]\n+//~^ WARN the feature `repr128` is incomplete\n \n #[derive(PartialEq, Debug)]\n #[repr(i128)]"}, {"sha": "5bf6ea56ebc77867854cbb5ce4fe42ed91b8591e", "filename": "src/test/ui/enum-discriminant/issue-70509-partial_eq.stderr", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/07a63e6d1fabf3560e8e1e17c1d56b10a06152d9/src%2Ftest%2Fui%2Fenum-discriminant%2Fissue-70509-partial_eq.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/07a63e6d1fabf3560e8e1e17c1d56b10a06152d9/src%2Ftest%2Fui%2Fenum-discriminant%2Fissue-70509-partial_eq.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fenum-discriminant%2Fissue-70509-partial_eq.stderr?ref=07a63e6d1fabf3560e8e1e17c1d56b10a06152d9", "patch": "@@ -0,0 +1,11 @@\n+warning: the feature `repr128` is incomplete and may not be safe to use and/or cause compiler crashes\n+  --> $DIR/issue-70509-partial_eq.rs:2:12\n+   |\n+LL | #![feature(repr128, arbitrary_enum_discriminant)]\n+   |            ^^^^^^^\n+   |\n+   = note: `#[warn(incomplete_features)]` on by default\n+   = note: see issue #56071 <https://github.com/rust-lang/rust/issues/56071> for more information\n+\n+warning: 1 warning emitted\n+"}, {"sha": "00021a07b371952b37707df2dd6fa069d48561e2", "filename": "src/test/ui/enum-discriminant/repr128.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/07a63e6d1fabf3560e8e1e17c1d56b10a06152d9/src%2Ftest%2Fui%2Fenum-discriminant%2Frepr128.rs", "raw_url": "https://github.com/rust-lang/rust/raw/07a63e6d1fabf3560e8e1e17c1d56b10a06152d9/src%2Ftest%2Fui%2Fenum-discriminant%2Frepr128.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fenum-discriminant%2Frepr128.rs?ref=07a63e6d1fabf3560e8e1e17c1d56b10a06152d9", "patch": "@@ -1,5 +1,6 @@\n // run-pass\n #![feature(repr128, core_intrinsics, discriminant_kind)]\n+//~^ WARN the feature `repr128` is incomplete\n \n use std::intrinsics::discriminant_value;\n use std::marker::DiscriminantKind;"}, {"sha": "88adfb1742d5d3c51bc8e1dee8646a4df55f4ab9", "filename": "src/test/ui/enum-discriminant/repr128.stderr", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/07a63e6d1fabf3560e8e1e17c1d56b10a06152d9/src%2Ftest%2Fui%2Fenum-discriminant%2Frepr128.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/07a63e6d1fabf3560e8e1e17c1d56b10a06152d9/src%2Ftest%2Fui%2Fenum-discriminant%2Frepr128.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fenum-discriminant%2Frepr128.stderr?ref=07a63e6d1fabf3560e8e1e17c1d56b10a06152d9", "patch": "@@ -0,0 +1,11 @@\n+warning: the feature `repr128` is incomplete and may not be safe to use and/or cause compiler crashes\n+  --> $DIR/repr128.rs:2:12\n+   |\n+LL | #![feature(repr128, core_intrinsics, discriminant_kind)]\n+   |            ^^^^^^^\n+   |\n+   = note: `#[warn(incomplete_features)]` on by default\n+   = note: see issue #56071 <https://github.com/rust-lang/rust/issues/56071> for more information\n+\n+warning: 1 warning emitted\n+"}, {"sha": "4abc0542c51425e36bc547249daa71e316ce90e2", "filename": "src/test/ui/generator/type-mismatch-signature-deduction.stderr", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/07a63e6d1fabf3560e8e1e17c1d56b10a06152d9/src%2Ftest%2Fui%2Fgenerator%2Ftype-mismatch-signature-deduction.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/07a63e6d1fabf3560e8e1e17c1d56b10a06152d9/src%2Ftest%2Fui%2Fgenerator%2Ftype-mismatch-signature-deduction.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fgenerator%2Ftype-mismatch-signature-deduction.stderr?ref=07a63e6d1fabf3560e8e1e17c1d56b10a06152d9", "patch": "@@ -6,6 +6,11 @@ LL |         5\n    |\n    = note: expected type `std::result::Result<{integer}, _>`\n               found type `{integer}`\n+note: return type inferred to be `std::result::Result<{integer}, _>` here\n+  --> $DIR/type-mismatch-signature-deduction.rs:8:20\n+   |\n+LL |             return Ok(6);\n+   |                    ^^^^^\n \n error[E0271]: type mismatch resolving `<[generator@$DIR/type-mismatch-signature-deduction.rs:6:5: 14:6] as Generator>::Return == i32`\n   --> $DIR/type-mismatch-signature-deduction.rs:5:13"}, {"sha": "30063a0957c749e42f43372a96b57356ebc1b692", "filename": "src/test/ui/inference/issue-71732.rs", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/07a63e6d1fabf3560e8e1e17c1d56b10a06152d9/src%2Ftest%2Fui%2Finference%2Fissue-71732.rs", "raw_url": "https://github.com/rust-lang/rust/raw/07a63e6d1fabf3560e8e1e17c1d56b10a06152d9/src%2Ftest%2Fui%2Finference%2Fissue-71732.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Finference%2Fissue-71732.rs?ref=07a63e6d1fabf3560e8e1e17c1d56b10a06152d9", "patch": "@@ -0,0 +1,23 @@\n+// Regression test for #71732, it used to emit incorrect diagnostics, like:\n+// error[E0283]: type annotations needed\n+//  --> src/main.rs:5:10\n+//   |\n+// 5 |         .get(&\"key\".into())\n+//   |          ^^^ cannot infer type for struct `String`\n+//   |\n+//   = note: cannot satisfy `String: Borrow<_>`\n+// help: consider specifying the type argument in the method call\n+//   |\n+// 5 |         .get::<Q>(&\"key\".into())\n+//   |\n+\n+use std::collections::hash_map::HashMap;\n+\n+fn foo(parameters: &HashMap<String, String>) -> bool {\n+    parameters\n+        .get(&\"key\".into()) //~ ERROR: type annotations needed\n+        .and_then(|found: &String| Some(false))\n+        .unwrap_or(false)\n+}\n+\n+fn main() {}"}, {"sha": "17fad571385dc7815351ce80280c849422b14be2", "filename": "src/test/ui/inference/issue-71732.stderr", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/07a63e6d1fabf3560e8e1e17c1d56b10a06152d9/src%2Ftest%2Fui%2Finference%2Fissue-71732.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/07a63e6d1fabf3560e8e1e17c1d56b10a06152d9/src%2Ftest%2Fui%2Finference%2Fissue-71732.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Finference%2Fissue-71732.stderr?ref=07a63e6d1fabf3560e8e1e17c1d56b10a06152d9", "patch": "@@ -0,0 +1,13 @@\n+error[E0283]: type annotations needed\n+  --> $DIR/issue-71732.rs:18:10\n+   |\n+LL |         .get(&\"key\".into())\n+   |          ^^^  ------------ this method call resolves to `T`\n+   |          |\n+   |          cannot infer type for type parameter `Q` declared on the associated function `get`\n+   |\n+   = note: cannot satisfy `String: Borrow<_>`\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0283`."}, {"sha": "5e5a3babfe02038a1bc9e784ab3327bc14baa1e0", "filename": "src/test/ui/inference/issue-72616.rs", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/07a63e6d1fabf3560e8e1e17c1d56b10a06152d9/src%2Ftest%2Fui%2Finference%2Fissue-72616.rs", "raw_url": "https://github.com/rust-lang/rust/raw/07a63e6d1fabf3560e8e1e17c1d56b10a06152d9/src%2Ftest%2Fui%2Finference%2Fissue-72616.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Finference%2Fissue-72616.rs?ref=07a63e6d1fabf3560e8e1e17c1d56b10a06152d9", "patch": "@@ -0,0 +1,29 @@\n+// Regression test for #72616, it used to emit incorrect diagnostics, like:\n+// error[E0283]: type annotations needed for `String`\n+//  --> src/main.rs:8:30\n+//   |\n+// 5 |         let _: String = \"\".to_owned().try_into().unwrap();\n+//   |             - consider giving this pattern a type\n+// ...\n+// 8 |         if String::from(\"a\") == \"a\".try_into().unwrap() {}\n+//   |                              ^^ cannot infer type for struct `String`\n+//   |\n+//   = note: cannot satisfy `String: PartialEq<_>`\n+\n+use std::convert::TryInto;\n+\n+pub fn main() {\n+    {\n+        let _: String = \"\".to_owned().try_into().unwrap();\n+    }\n+    {\n+        if String::from(\"a\") == \"a\".try_into().unwrap() {}\n+        //~^ ERROR: type annotations needed\n+    }\n+    {\n+        let _: String = match \"_\".try_into() {\n+            Ok(a) => a,\n+            Err(_) => \"\".into(),\n+        };\n+    }\n+}"}, {"sha": "d811988c9c1d0f5c1c903d2828fb4fa72a4af421", "filename": "src/test/ui/inference/issue-72616.stderr", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/07a63e6d1fabf3560e8e1e17c1d56b10a06152d9/src%2Ftest%2Fui%2Finference%2Fissue-72616.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/07a63e6d1fabf3560e8e1e17c1d56b10a06152d9/src%2Ftest%2Fui%2Finference%2Fissue-72616.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Finference%2Fissue-72616.stderr?ref=07a63e6d1fabf3560e8e1e17c1d56b10a06152d9", "patch": "@@ -0,0 +1,13 @@\n+error[E0283]: type annotations needed\n+  --> $DIR/issue-72616.rs:20:30\n+   |\n+LL |         if String::from(\"a\") == \"a\".try_into().unwrap() {}\n+   |                              ^^ -------------- this method call resolves to `std::result::Result<T, <Self as TryInto<T>>::Error>`\n+   |                              |\n+   |                              cannot infer type\n+   |\n+   = note: cannot satisfy `String: PartialEq<_>`\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0283`."}, {"sha": "eefe43a1a2297fa04b38b93ec7bfc4b671cd143b", "filename": "src/test/ui/inline-const/const-match-pat-range.rs", "status": "added", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/07a63e6d1fabf3560e8e1e17c1d56b10a06152d9/src%2Ftest%2Fui%2Finline-const%2Fconst-match-pat-range.rs", "raw_url": "https://github.com/rust-lang/rust/raw/07a63e6d1fabf3560e8e1e17c1d56b10a06152d9/src%2Ftest%2Fui%2Finline-const%2Fconst-match-pat-range.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Finline-const%2Fconst-match-pat-range.rs?ref=07a63e6d1fabf3560e8e1e17c1d56b10a06152d9", "patch": "@@ -0,0 +1,38 @@\n+// build-pass\n+\n+#![allow(incomplete_features)]\n+#![feature(inline_const, half_open_range_patterns, exclusive_range_pattern)]\n+fn main() {\n+    const N: u32 = 10;\n+    let x: u32 = 3;\n+\n+    match x {\n+        1 ..= const { N + 1 } => {},\n+        _ => {},\n+    }\n+\n+    match x {\n+        const { N - 1 } ..= 10 => {},\n+        _ => {},\n+    }\n+\n+    match x {\n+        const { N - 1 } ..= const { N + 1 } => {},\n+        _ => {},\n+    }\n+\n+    match x {\n+        .. const { N + 1 } => {},\n+        _ => {},\n+    }\n+\n+    match x {\n+        const { N - 1 } .. => {},\n+        _ => {},\n+    }\n+\n+    match x {\n+        ..= const { N + 1 } => {},\n+        _ => {}\n+    }\n+}"}, {"sha": "581db033f92578cb5aa1648bdbfb86473a11bd42", "filename": "src/test/ui/issues/issue-43398.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/07a63e6d1fabf3560e8e1e17c1d56b10a06152d9/src%2Ftest%2Fui%2Fissues%2Fissue-43398.rs", "raw_url": "https://github.com/rust-lang/rust/raw/07a63e6d1fabf3560e8e1e17c1d56b10a06152d9/src%2Ftest%2Fui%2Fissues%2Fissue-43398.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-43398.rs?ref=07a63e6d1fabf3560e8e1e17c1d56b10a06152d9", "patch": "@@ -2,6 +2,7 @@\n \n #![feature(core_intrinsics)]\n #![feature(repr128)]\n+//~^ WARN the feature `repr128` is incomplete\n \n #[repr(i128)]\n enum Big { A, B }"}, {"sha": "9a394153bf62f242f243c596cd341e00eb2eea86", "filename": "src/test/ui/issues/issue-43398.stderr", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/07a63e6d1fabf3560e8e1e17c1d56b10a06152d9/src%2Ftest%2Fui%2Fissues%2Fissue-43398.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/07a63e6d1fabf3560e8e1e17c1d56b10a06152d9/src%2Ftest%2Fui%2Fissues%2Fissue-43398.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-43398.stderr?ref=07a63e6d1fabf3560e8e1e17c1d56b10a06152d9", "patch": "@@ -0,0 +1,11 @@\n+warning: the feature `repr128` is incomplete and may not be safe to use and/or cause compiler crashes\n+  --> $DIR/issue-43398.rs:4:12\n+   |\n+LL | #![feature(repr128)]\n+   |            ^^^^^^^\n+   |\n+   = note: `#[warn(incomplete_features)]` on by default\n+   = note: see issue #56071 <https://github.com/rust-lang/rust/issues/56071> for more information\n+\n+warning: 1 warning emitted\n+"}, {"sha": "fb4bf2b8b44e7642e5f68244b9057cd2234e4f8f", "filename": "src/test/ui/issues/issue-50865-private-impl-trait/auxiliary/lib.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/07a63e6d1fabf3560e8e1e17c1d56b10a06152d9/src%2Ftest%2Fui%2Fissues%2Fissue-50865-private-impl-trait%2Fauxiliary%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/07a63e6d1fabf3560e8e1e17c1d56b10a06152d9/src%2Ftest%2Fui%2Fissues%2Fissue-50865-private-impl-trait%2Fauxiliary%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-50865-private-impl-trait%2Fauxiliary%2Flib.rs?ref=07a63e6d1fabf3560e8e1e17c1d56b10a06152d9", "patch": "@@ -1,3 +1,7 @@\n+// revisions: default miropt\n+//[miropt]compile-flags: -Z mir-opt-level=2\n+// ~^ This flag is for #77668, it used to be ICE.\n+\n #![crate_type = \"lib\"]\n \n pub fn bar<P>( // Error won't happen if \"bar\" is not generic"}, {"sha": "37f6beabd33028fee52ad5f75bb337ac96dd5b2e", "filename": "src/test/ui/match/match-incompat-type-semi.rs", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/07a63e6d1fabf3560e8e1e17c1d56b10a06152d9/src%2Ftest%2Fui%2Fmatch%2Fmatch-incompat-type-semi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/07a63e6d1fabf3560e8e1e17c1d56b10a06152d9/src%2Ftest%2Fui%2Fmatch%2Fmatch-incompat-type-semi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmatch%2Fmatch-incompat-type-semi.rs?ref=07a63e6d1fabf3560e8e1e17c1d56b10a06152d9", "patch": "@@ -39,4 +39,14 @@ fn main() {\n         None => { //~ ERROR incompatible types\n         },\n     };\n+\n+    let _ = match Some(42) {\n+        Some(x) => \"rust-lang.org\"\n+            .chars()\n+            .skip(1)\n+            .chain(Some(x as u8 as char))\n+            .take(10)\n+            .any(char::is_alphanumeric),\n+        None => {} //~ ERROR incompatible types\n+    };\n }"}, {"sha": "008b1c1e93d6d8641ff095ca498eaaea7651ee61", "filename": "src/test/ui/match/match-incompat-type-semi.stderr", "status": "modified", "additions": 27, "deletions": 13, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/07a63e6d1fabf3560e8e1e17c1d56b10a06152d9/src%2Ftest%2Fui%2Fmatch%2Fmatch-incompat-type-semi.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/07a63e6d1fabf3560e8e1e17c1d56b10a06152d9/src%2Ftest%2Fui%2Fmatch%2Fmatch-incompat-type-semi.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmatch%2Fmatch-incompat-type-semi.stderr?ref=07a63e6d1fabf3560e8e1e17c1d56b10a06152d9", "patch": "@@ -56,19 +56,33 @@ LL | |     };\n error[E0308]: `match` arms have incompatible types\n   --> $DIR/match-incompat-type-semi.rs:39:17\n    |\n-LL |        let _ = match Some(42) {\n-   |   _____________-\n-LL |  |         Some(x) => {\n-LL |  |             x\n-   |  |             - this is found to be of type `{integer}`\n-LL |  |         },\n-LL |  |         None => {\n-   |  |_________________^\n-LL | ||         },\n-   | ||_________^ expected integer, found `()`\n-LL |  |     };\n-   |  |_____- `match` arms have incompatible types\n+LL |       let _ = match Some(42) {\n+   |               -------------- `match` arms have incompatible types\n+LL |           Some(x) => {\n+LL |               x\n+   |               - this is found to be of type `{integer}`\n+LL |           },\n+LL |           None => {\n+   |  _________________^\n+LL | |         },\n+   | |_________^ expected integer, found `()`\n+\n+error[E0308]: `match` arms have incompatible types\n+  --> $DIR/match-incompat-type-semi.rs:50:17\n+   |\n+LL |       let _ = match Some(42) {\n+   |               -------------- `match` arms have incompatible types\n+LL |           Some(x) => \"rust-lang.org\"\n+   |  ____________________-\n+LL | |             .chars()\n+LL | |             .skip(1)\n+LL | |             .chain(Some(x as u8 as char))\n+LL | |             .take(10)\n+LL | |             .any(char::is_alphanumeric),\n+   | |_______________________________________- this is found to be of type `bool`\n+LL |           None => {}\n+   |                   ^^ expected `bool`, found `()`\n \n-error: aborting due to 4 previous errors\n+error: aborting due to 5 previous errors\n \n For more information about this error, try `rustc --explain E0308`."}, {"sha": "5ec143fae234479231dd52c8ff13f4d08a68b958", "filename": "src/test/ui/parser/issue-66357-unexpected-unreachable.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/07a63e6d1fabf3560e8e1e17c1d56b10a06152d9/src%2Ftest%2Fui%2Fparser%2Fissue-66357-unexpected-unreachable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/07a63e6d1fabf3560e8e1e17c1d56b10a06152d9/src%2Ftest%2Fui%2Fparser%2Fissue-66357-unexpected-unreachable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fissue-66357-unexpected-unreachable.rs?ref=07a63e6d1fabf3560e8e1e17c1d56b10a06152d9", "patch": "@@ -13,4 +13,4 @@\n \n fn f() { |[](* }\n //~^ ERROR expected one of `,` or `:`, found `(`\n-//~| ERROR expected one of `&`, `(`, `)`, `-`, `...`, `..=`, `..`, `[`, `_`, `box`, `const`, `mut`, `ref`, `|`, identifier, or path, found `*`\n+//~| ERROR expected one of `&`, `(`, `)`, `-`, `...`, `..=`, `..`, `[`, `_`, `box`, `mut`, `ref`, `|`, identifier, or path, found `*`"}, {"sha": "c3810999d239509f6100bfbbe04b387e5a94b8ef", "filename": "src/test/ui/parser/issue-66357-unexpected-unreachable.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/07a63e6d1fabf3560e8e1e17c1d56b10a06152d9/src%2Ftest%2Fui%2Fparser%2Fissue-66357-unexpected-unreachable.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/07a63e6d1fabf3560e8e1e17c1d56b10a06152d9/src%2Ftest%2Fui%2Fparser%2Fissue-66357-unexpected-unreachable.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fissue-66357-unexpected-unreachable.stderr?ref=07a63e6d1fabf3560e8e1e17c1d56b10a06152d9", "patch": "@@ -4,7 +4,7 @@ error: expected one of `,` or `:`, found `(`\n LL | fn f() { |[](* }\n    |             ^ expected one of `,` or `:`\n \n-error: expected one of `&`, `(`, `)`, `-`, `...`, `..=`, `..`, `[`, `_`, `box`, `const`, `mut`, `ref`, `|`, identifier, or path, found `*`\n+error: expected one of `&`, `(`, `)`, `-`, `...`, `..=`, `..`, `[`, `_`, `box`, `mut`, `ref`, `|`, identifier, or path, found `*`\n   --> $DIR/issue-66357-unexpected-unreachable.rs:14:14\n    |\n LL | fn f() { |[](* }"}, {"sha": "af35bc2014bfe4b4f4bcae49ed616313848a2f00", "filename": "src/test/ui/rfcs/rfc-2396-target_feature-11/closures-inherit-target_feature.rs", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/07a63e6d1fabf3560e8e1e17c1d56b10a06152d9/src%2Ftest%2Fui%2Frfcs%2Frfc-2396-target_feature-11%2Fclosures-inherit-target_feature.rs", "raw_url": "https://github.com/rust-lang/rust/raw/07a63e6d1fabf3560e8e1e17c1d56b10a06152d9/src%2Ftest%2Fui%2Frfcs%2Frfc-2396-target_feature-11%2Fclosures-inherit-target_feature.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfcs%2Frfc-2396-target_feature-11%2Fclosures-inherit-target_feature.rs?ref=07a63e6d1fabf3560e8e1e17c1d56b10a06152d9", "patch": "@@ -0,0 +1,18 @@\n+// Tests #73631: closures inherit `#[target_feature]` annotations\n+\n+// check-pass\n+// only-x86_64\n+\n+#![feature(target_feature_11)]\n+\n+#[target_feature(enable=\"avx\")]\n+fn also_use_avx() {\n+    println!(\"Hello from AVX\")\n+}\n+\n+#[target_feature(enable=\"avx\")]\n+fn use_avx() -> Box<dyn Fn()> {\n+    Box::new(|| also_use_avx())\n+}\n+\n+fn main() {}"}, {"sha": "dd83ae55c871d94f060524656abab62ec40b4c40", "filename": "src/tools/cargo", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": null, "raw_url": null, "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fcargo?ref=07a63e6d1fabf3560e8e1e17c1d56b10a06152d9", "patch": "@@ -1 +1 @@\n-Subproject commit 79b397d72c557eb6444a2ba0dc00a211a226a35a\n+Subproject commit dd83ae55c871d94f060524656abab62ec40b4c40"}, {"sha": "e370a98df1acfdd13d35274052f9247e8a6189e5", "filename": "src/tools/clippy/tests/ui/auxiliary/proc_macro_attr.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/07a63e6d1fabf3560e8e1e17c1d56b10a06152d9/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fauxiliary%2Fproc_macro_attr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/07a63e6d1fabf3560e8e1e17c1d56b10a06152d9/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fauxiliary%2Fproc_macro_attr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fauxiliary%2Fproc_macro_attr.rs?ref=07a63e6d1fabf3560e8e1e17c1d56b10a06152d9", "patch": "@@ -3,6 +3,7 @@\n \n #![crate_type = \"proc-macro\"]\n #![feature(repr128, proc_macro_hygiene, proc_macro_quote, box_patterns)]\n+#![allow(incomplete_features)]\n #![allow(clippy::useless_conversion)]\n \n extern crate proc_macro;"}, {"sha": "cd5a5ae0aa75abe909b9896cc789a159d2bcf5c1", "filename": "src/tools/clippy/tests/ui/auxiliary/proc_macro_derive.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/07a63e6d1fabf3560e8e1e17c1d56b10a06152d9/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fauxiliary%2Fproc_macro_derive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/07a63e6d1fabf3560e8e1e17c1d56b10a06152d9/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fauxiliary%2Fproc_macro_derive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fauxiliary%2Fproc_macro_derive.rs?ref=07a63e6d1fabf3560e8e1e17c1d56b10a06152d9", "patch": "@@ -3,6 +3,7 @@\n \n #![crate_type = \"proc-macro\"]\n #![feature(repr128, proc_macro_quote)]\n+#![allow(incomplete_features)]\n \n extern crate proc_macro;\n "}, {"sha": "ed8e7a708a5e2ac4ad6cc309a9398617d0b74735", "filename": "src/tools/clippy/tests/ui/crashes/auxiliary/proc_macro_crash.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/07a63e6d1fabf3560e8e1e17c1d56b10a06152d9/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fcrashes%2Fauxiliary%2Fproc_macro_crash.rs", "raw_url": "https://github.com/rust-lang/rust/raw/07a63e6d1fabf3560e8e1e17c1d56b10a06152d9/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fcrashes%2Fauxiliary%2Fproc_macro_crash.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fcrashes%2Fauxiliary%2Fproc_macro_crash.rs?ref=07a63e6d1fabf3560e8e1e17c1d56b10a06152d9", "patch": "@@ -6,6 +6,7 @@\n // contain a proc-macro.\n \n #![feature(repr128)]\n+#![allow(incomplete_features)]\n #![crate_type = \"proc-macro\"]\n \n extern crate proc_macro;"}]}