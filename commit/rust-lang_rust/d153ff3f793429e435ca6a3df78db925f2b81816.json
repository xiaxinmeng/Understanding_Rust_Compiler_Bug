{"sha": "d153ff3f793429e435ca6a3df78db925f2b81816", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQxNTNmZjNmNzkzNDI5ZTQzNWNhNmEzZGY3OGRiOTI1ZjJiODE4MTY=", "commit": {"author": {"name": "Masaki Hara", "email": "ackie.h.gmai@gmail.com", "date": "2017-08-01T05:57:25Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2017-09-05T16:19:35Z"}, "message": "Print more detailed trait-ref for intercrate ambiguity.", "tree": {"sha": "abff4297f3a229470329de0c76483ea68e22c309", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/abff4297f3a229470329de0c76483ea68e22c309"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d153ff3f793429e435ca6a3df78db925f2b81816", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d153ff3f793429e435ca6a3df78db925f2b81816", "html_url": "https://github.com/rust-lang/rust/commit/d153ff3f793429e435ca6a3df78db925f2b81816", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d153ff3f793429e435ca6a3df78db925f2b81816/comments", "author": {"login": "qnighy", "id": 41755, "node_id": "MDQ6VXNlcjQxNzU1", "avatar_url": "https://avatars.githubusercontent.com/u/41755?v=4", "gravatar_id": "", "url": "https://api.github.com/users/qnighy", "html_url": "https://github.com/qnighy", "followers_url": "https://api.github.com/users/qnighy/followers", "following_url": "https://api.github.com/users/qnighy/following{/other_user}", "gists_url": "https://api.github.com/users/qnighy/gists{/gist_id}", "starred_url": "https://api.github.com/users/qnighy/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/qnighy/subscriptions", "organizations_url": "https://api.github.com/users/qnighy/orgs", "repos_url": "https://api.github.com/users/qnighy/repos", "events_url": "https://api.github.com/users/qnighy/events{/privacy}", "received_events_url": "https://api.github.com/users/qnighy/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "84bfc33face2cecadace55af6efd1db5fb3aee6f", "url": "https://api.github.com/repos/rust-lang/rust/commits/84bfc33face2cecadace55af6efd1db5fb3aee6f", "html_url": "https://github.com/rust-lang/rust/commit/84bfc33face2cecadace55af6efd1db5fb3aee6f"}], "stats": {"total": 73, "additions": 50, "deletions": 23}, "files": [{"sha": "693b9c147c2a3e55486817528f299eb83cac9c0c", "filename": "src/librustc/traits/select.rs", "status": "modified", "additions": 43, "deletions": 16, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/d153ff3f793429e435ca6a3df78db925f2b81816/src%2Flibrustc%2Ftraits%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d153ff3f793429e435ca6a3df78db925f2b81816/src%2Flibrustc%2Ftraits%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fselect.rs?ref=d153ff3f793429e435ca6a3df78db925f2b81816", "patch": "@@ -96,25 +96,36 @@ pub struct SelectionContext<'cx, 'gcx: 'cx+'tcx, 'tcx: 'cx> {\n \n #[derive(Clone)]\n pub enum IntercrateAmbiguityCause {\n-    DownstreamCrate(DefId),\n-    UpstreamCrateUpdate(DefId),\n+    DownstreamCrate {\n+        trait_desc: String,\n+        self_desc: Option<String>,\n+    },\n+    UpstreamCrateUpdate {\n+        trait_desc: String,\n+        self_desc: Option<String>,\n+    },\n }\n \n impl IntercrateAmbiguityCause {\n     /// Emits notes when the overlap is caused by complex intercrate ambiguities.\n     /// See #23980 for details.\n     pub fn add_intercrate_ambiguity_hint<'a, 'tcx>(&self,\n-                                                   tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                                                    err: &mut ::errors::DiagnosticBuilder) {\n         match self {\n-            &IntercrateAmbiguityCause::DownstreamCrate(def_id) => {\n-                err.note(&format!(\"downstream crates may implement `{}`\",\n-                                  tcx.item_path_str(def_id)));\n-            }\n-            &IntercrateAmbiguityCause::UpstreamCrateUpdate(def_id) => {\n-                err.note(&format!(\"upstream crates may add new impl for `{}` \\\n+            &IntercrateAmbiguityCause::DownstreamCrate { ref trait_desc, ref self_desc } => {\n+                let self_desc = if let &Some(ref ty) = self_desc {\n+                    format!(\" for type `{}`\", ty)\n+                } else { \"\".to_string() };\n+                err.note(&format!(\"downstream crates may implement trait `{}`{}\",\n+                                  trait_desc, self_desc));\n+            }\n+            &IntercrateAmbiguityCause::UpstreamCrateUpdate { ref trait_desc, ref self_desc } => {\n+                let self_desc = if let &Some(ref ty) = self_desc {\n+                    format!(\" for type `{}`\", ty)\n+                } else { \"\".to_string() };\n+                err.note(&format!(\"upstream crates may add new impl of trait `{}`{} \\\n                                   in future versions\",\n-                                  tcx.item_path_str(def_id)));\n+                                  trait_desc, self_desc));\n             }\n         }\n     }\n@@ -794,9 +805,17 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n             // Heuristics: show the diagnostics when there are no candidates in crate.\n             if let Ok(candidate_set) = self.assemble_candidates(stack) {\n                 if !candidate_set.ambiguous && candidate_set.vec.is_empty() {\n-                    let did = stack.fresh_trait_ref.def_id();\n-                    self.intercrate_ambiguity_causes.push(\n-                        IntercrateAmbiguityCause::DownstreamCrate(did));\n+                    let trait_ref = stack.obligation.predicate.skip_binder().trait_ref;\n+                    let self_ty = trait_ref.self_ty();\n+                    let cause = IntercrateAmbiguityCause::DownstreamCrate {\n+                        trait_desc: trait_ref.to_string(),\n+                        self_desc: if self_ty.has_concrete_skeleton() {\n+                            Some(self_ty.to_string())\n+                        } else {\n+                            None\n+                        },\n+                    };\n+                    self.intercrate_ambiguity_causes.push(cause);\n                 }\n             }\n             return EvaluatedToAmbig;\n@@ -1048,9 +1067,17 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n             // Heuristics: show the diagnostics when there are no candidates in crate.\n             let candidate_set = self.assemble_candidates(stack)?;\n             if !candidate_set.ambiguous && candidate_set.vec.is_empty() {\n-                let did = stack.obligation.predicate.def_id();\n-                self.intercrate_ambiguity_causes.push(\n-                    IntercrateAmbiguityCause::UpstreamCrateUpdate(did));\n+                let trait_ref = stack.obligation.predicate.skip_binder().trait_ref;\n+                let self_ty = trait_ref.self_ty();\n+                let cause = IntercrateAmbiguityCause::UpstreamCrateUpdate {\n+                    trait_desc: trait_ref.to_string(),\n+                    self_desc: if self_ty.has_concrete_skeleton() {\n+                        Some(self_ty.to_string())\n+                    } else {\n+                        None\n+                    },\n+                };\n+                self.intercrate_ambiguity_causes.push(cause);\n             }\n             return Ok(None);\n         }"}, {"sha": "f9332fc6697e02bff8cc67f6fcf98b8167d9883c", "filename": "src/librustc/traits/specialize/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d153ff3f793429e435ca6a3df78db925f2b81816/src%2Flibrustc%2Ftraits%2Fspecialize%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d153ff3f793429e435ca6a3df78db925f2b81816/src%2Flibrustc%2Ftraits%2Fspecialize%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fspecialize%2Fmod.rs?ref=d153ff3f793429e435ca6a3df78db925f2b81816", "patch": "@@ -340,7 +340,7 @@ pub(super) fn specialization_graph_provider<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx\n                 }\n \n                 for cause in &overlap.intercrate_ambiguity_causes {\n-                    cause.add_intercrate_ambiguity_hint(tcx, &mut err);\n+                    cause.add_intercrate_ambiguity_hint(&mut err);\n                 }\n \n                 err.emit();"}, {"sha": "76dcfe36e4fcdc80e8d07763964cda2ffc575a2e", "filename": "src/librustc_typeck/coherence/inherent_impls_overlap.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d153ff3f793429e435ca6a3df78db925f2b81816/src%2Flibrustc_typeck%2Fcoherence%2Finherent_impls_overlap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d153ff3f793429e435ca6a3df78db925f2b81816/src%2Flibrustc_typeck%2Fcoherence%2Finherent_impls_overlap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Finherent_impls_overlap.rs?ref=d153ff3f793429e435ca6a3df78db925f2b81816", "patch": "@@ -63,7 +63,7 @@ impl<'a, 'tcx> InherentOverlapChecker<'a, 'tcx> {\n                                    format!(\"other definition for `{}`\", name));\n \n                     for cause in &overlap.intercrate_ambiguity_causes {\n-                        cause.add_intercrate_ambiguity_hint(self.tcx, &mut err);\n+                        cause.add_intercrate_ambiguity_hint(&mut err);\n                     }\n \n                     err.emit();"}, {"sha": "9b8ad51c5ff7df0af56290e0cdea89f8246222dc", "filename": "src/test/compile-fail/coherence-overlap-issue-23516-inherent.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d153ff3f793429e435ca6a3df78db925f2b81816/src%2Ftest%2Fcompile-fail%2Fcoherence-overlap-issue-23516-inherent.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d153ff3f793429e435ca6a3df78db925f2b81816/src%2Ftest%2Fcompile-fail%2Fcoherence-overlap-issue-23516-inherent.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fcoherence-overlap-issue-23516-inherent.rs?ref=d153ff3f793429e435ca6a3df78db925f2b81816", "patch": "@@ -19,7 +19,7 @@ struct Cake<X>(X);\n impl<T:Sugar> Cake<T> { fn dummy(&self) { } }\n //~^ ERROR E0592\n //~| NOTE duplicate definitions for `dummy`\n-//~| NOTE upstream crates may add new impl for `Sugar` in future versions\n+//~| NOTE upstream crates may add new impl of trait `Sugar` for type `std::boxed::Box<_>`\n impl<U:Sugar> Cake<Box<U>> { fn dummy(&self) { } }\n //~^ NOTE other definition for `dummy`\n "}, {"sha": "950d1fe29bb91c1f80197542c1b03151173ddab3", "filename": "src/test/compile-fail/coherence-overlap-issue-23516.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d153ff3f793429e435ca6a3df78db925f2b81816/src%2Ftest%2Fcompile-fail%2Fcoherence-overlap-issue-23516.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d153ff3f793429e435ca6a3df78db925f2b81816/src%2Ftest%2Fcompile-fail%2Fcoherence-overlap-issue-23516.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fcoherence-overlap-issue-23516.rs?ref=d153ff3f793429e435ca6a3df78db925f2b81816", "patch": "@@ -19,6 +19,6 @@ impl<T:Sugar> Sweet for T { }\n impl<U:Sugar> Sweet for Box<U> { }\n //~^ ERROR E0119\n //~| NOTE conflicting implementation for `std::boxed::Box<_>`\n-//~| NOTE upstream crates may add new impl for `Sugar` in future versions\n+//~| NOTE upstream crates may add new impl of trait `Sugar` for type `std::boxed::Box<_>`\n \n fn main() { }"}, {"sha": "1d0c63110cecd41a3d9f515ec73a4817a07ba610", "filename": "src/test/compile-fail/coherence-overlap-upstream-inherent.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d153ff3f793429e435ca6a3df78db925f2b81816/src%2Ftest%2Fcompile-fail%2Fcoherence-overlap-upstream-inherent.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d153ff3f793429e435ca6a3df78db925f2b81816/src%2Ftest%2Fcompile-fail%2Fcoherence-overlap-upstream-inherent.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fcoherence-overlap-upstream-inherent.rs?ref=d153ff3f793429e435ca6a3df78db925f2b81816", "patch": "@@ -21,7 +21,7 @@ struct A<X>(X);\n impl<T> A<T> where T: Remote { fn dummy(&self) { } }\n //~^ ERROR E0592\n //~| NOTE duplicate definitions for `dummy`\n-//~| NOTE upstream crates may add new impl for `coherence_lib::Remote` in future versions\n+//~| NOTE upstream crates may add new impl of trait `coherence_lib::Remote` for type `i16`\n impl A<i16> { fn dummy(&self) { } }\n //~^ NOTE other definition for `dummy`\n "}, {"sha": "e978143a067c547f3aa6a0a0a09d88fc770198f6", "filename": "src/test/compile-fail/coherence-overlap-upstream.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d153ff3f793429e435ca6a3df78db925f2b81816/src%2Ftest%2Fcompile-fail%2Fcoherence-overlap-upstream.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d153ff3f793429e435ca6a3df78db925f2b81816/src%2Ftest%2Fcompile-fail%2Fcoherence-overlap-upstream.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fcoherence-overlap-upstream.rs?ref=d153ff3f793429e435ca6a3df78db925f2b81816", "patch": "@@ -23,6 +23,6 @@ impl<T> Foo for T where T: Remote {}\n impl Foo for i16 {}\n //~^ ERROR E0119\n //~| NOTE conflicting implementation for `i16`\n-//~| NOTE upstream crates may add new impl for `coherence_lib::Remote` in future versions\n+//~| NOTE upstream crates may add new impl of trait `coherence_lib::Remote` for type `i16`\n \n fn main() {}"}, {"sha": "eaf42cde22f762c44a64688bbadbce5f3302c97e", "filename": "src/test/ui/codemap_tests/overlapping_inherent_impls.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d153ff3f793429e435ca6a3df78db925f2b81816/src%2Ftest%2Fui%2Fcodemap_tests%2Foverlapping_inherent_impls.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d153ff3f793429e435ca6a3df78db925f2b81816/src%2Ftest%2Fui%2Fcodemap_tests%2Foverlapping_inherent_impls.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fcodemap_tests%2Foverlapping_inherent_impls.stderr?ref=d153ff3f793429e435ca6a3df78db925f2b81816", "patch": "@@ -25,7 +25,7 @@ error[E0592]: duplicate definitions with name `baz`\n 43 |     fn baz(&self) {}\n    |     ---------------- other definition for `baz`\n    |\n-   = note: upstream crates may add new impl for `std::marker::Copy` in future versions\n+   = note: upstream crates may add new impl of trait `std::marker::Copy` for type `std::vec::Vec<_>` in future versions\n \n error: aborting due to 3 previous errors\n "}]}