{"sha": "0feaccf5260bc59f7ee4294a2ecc875da669ad30", "node_id": "MDY6Q29tbWl0NzI0NzEyOjBmZWFjY2Y1MjYwYmM1OWY3ZWU0Mjk0YTJlY2M4NzVkYTY2OWFkMzA=", "commit": {"author": {"name": "Erick Tryzelaar", "email": "erick.tryzelaar@gmail.com", "date": "2013-09-17T04:12:18Z"}, "committer": {"name": "Erick Tryzelaar", "email": "erick.tryzelaar@gmail.com", "date": "2013-10-02T14:55:41Z"}, "message": "syntax: Add #[deriving(FromPrimitive)] syntax extension\n\nRight now this only works for c-style enums.", "tree": {"sha": "633a987e41b539c7d52acde7479f37a87f72022d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/633a987e41b539c7d52acde7479f37a87f72022d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0feaccf5260bc59f7ee4294a2ecc875da669ad30", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0feaccf5260bc59f7ee4294a2ecc875da669ad30", "html_url": "https://github.com/rust-lang/rust/commit/0feaccf5260bc59f7ee4294a2ecc875da669ad30", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0feaccf5260bc59f7ee4294a2ecc875da669ad30/comments", "author": {"login": "erickt", "id": 84711, "node_id": "MDQ6VXNlcjg0NzEx", "avatar_url": "https://avatars.githubusercontent.com/u/84711?v=4", "gravatar_id": "", "url": "https://api.github.com/users/erickt", "html_url": "https://github.com/erickt", "followers_url": "https://api.github.com/users/erickt/followers", "following_url": "https://api.github.com/users/erickt/following{/other_user}", "gists_url": "https://api.github.com/users/erickt/gists{/gist_id}", "starred_url": "https://api.github.com/users/erickt/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/erickt/subscriptions", "organizations_url": "https://api.github.com/users/erickt/orgs", "repos_url": "https://api.github.com/users/erickt/repos", "events_url": "https://api.github.com/users/erickt/events{/privacy}", "received_events_url": "https://api.github.com/users/erickt/received_events", "type": "User", "site_admin": false}, "committer": {"login": "erickt", "id": 84711, "node_id": "MDQ6VXNlcjg0NzEx", "avatar_url": "https://avatars.githubusercontent.com/u/84711?v=4", "gravatar_id": "", "url": "https://api.github.com/users/erickt", "html_url": "https://github.com/erickt", "followers_url": "https://api.github.com/users/erickt/followers", "following_url": "https://api.github.com/users/erickt/following{/other_user}", "gists_url": "https://api.github.com/users/erickt/gists{/gist_id}", "starred_url": "https://api.github.com/users/erickt/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/erickt/subscriptions", "organizations_url": "https://api.github.com/users/erickt/orgs", "repos_url": "https://api.github.com/users/erickt/repos", "events_url": "https://api.github.com/users/erickt/events{/privacy}", "received_events_url": "https://api.github.com/users/erickt/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d9d1dfc1955fabb7ee3a55e9c84cdcd5aad67417", "url": "https://api.github.com/repos/rust-lang/rust/commits/d9d1dfc1955fabb7ee3a55e9c84cdcd5aad67417", "html_url": "https://github.com/rust-lang/rust/commit/d9d1dfc1955fabb7ee3a55e9c84cdcd5aad67417"}], "stats": {"total": 190, "additions": 190, "deletions": 0}, "files": [{"sha": "56d116804f53e7e6222afb62e44d5d9b828fd1a7", "filename": "doc/rust.md", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0feaccf5260bc59f7ee4294a2ecc875da669ad30/doc%2Frust.md", "raw_url": "https://github.com/rust-lang/rust/raw/0feaccf5260bc59f7ee4294a2ecc875da669ad30/doc%2Frust.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Frust.md?ref=0feaccf5260bc59f7ee4294a2ecc875da669ad30", "patch": "@@ -1775,6 +1775,7 @@ Supported traits for `deriving` are:\n   `obj.to_str()` has similar output as `fmt!(\"%?\", obj)`, but it differs in that\n   each constituent field of the type must also implement `ToStr` and will have\n   `field.to_str()` invoked to build up the result.\n+* `FromPrimitive`, to create an instance from a numeric primitve.\n \n ### Stability\n One can indicate the stability of an API using the following attributes:"}, {"sha": "8e4f553cb83e370fc0a8375d516cbbe6873951e2", "filename": "src/libsyntax/ext/build.rs", "status": "modified", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/0feaccf5260bc59f7ee4294a2ecc875da669ad30/src%2Flibsyntax%2Fext%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0feaccf5260bc59f7ee4294a2ecc875da669ad30/src%2Flibsyntax%2Fext%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbuild.rs?ref=0feaccf5260bc59f7ee4294a2ecc875da669ad30", "patch": "@@ -113,6 +113,7 @@ pub trait AstBuilder {\n                         expr: @ast::Expr, ident: ast::Ident,\n                         args: ~[@ast::Expr]) -> @ast::Expr;\n     fn expr_block(&self, b: ast::Block) -> @ast::Expr;\n+    fn expr_cast(&self, sp: Span, expr: @ast::Expr, ty: ast::Ty) -> @ast::Expr;\n \n     fn field_imm(&self, span: Span, name: Ident, e: @ast::Expr) -> ast::Field;\n     fn expr_struct(&self, span: Span, path: ast::Path, fields: ~[ast::Field]) -> @ast::Expr;\n@@ -132,6 +133,9 @@ pub trait AstBuilder {\n     fn expr_str(&self, sp: Span, s: @str) -> @ast::Expr;\n     fn expr_str_uniq(&self, sp: Span, s: @str) -> @ast::Expr;\n \n+    fn expr_some(&self, sp: Span, expr: @ast::Expr) -> @ast::Expr;\n+    fn expr_none(&self, sp: Span) -> @ast::Expr;\n+\n     fn expr_unreachable(&self, span: Span) -> @ast::Expr;\n \n     fn pat(&self, span: Span, pat: ast::Pat_) -> @ast::Pat;\n@@ -564,6 +568,29 @@ impl AstBuilder for @ExtCtxt {\n     }\n \n \n+    fn expr_cast(&self, sp: Span, expr: @ast::Expr, ty: ast::Ty) -> @ast::Expr {\n+        self.expr(sp, ast::ExprCast(expr, ty))\n+    }\n+\n+\n+    fn expr_some(&self, sp: Span, expr: @ast::Expr) -> @ast::Expr {\n+        let some = ~[\n+            self.ident_of(\"std\"),\n+            self.ident_of(\"option\"),\n+            self.ident_of(\"Some\"),\n+        ];\n+        self.expr_call_global(sp, some, ~[expr])\n+    }\n+\n+    fn expr_none(&self, sp: Span) -> @ast::Expr {\n+        let none = self.path_global(sp, ~[\n+            self.ident_of(\"std\"),\n+            self.ident_of(\"option\"),\n+            self.ident_of(\"None\"),\n+        ]);\n+        self.expr_path(none)\n+    }\n+\n     fn expr_unreachable(&self, span: Span) -> @ast::Expr {\n         let loc = self.codemap().lookup_char_pos(span.lo);\n         self.expr_call_global("}, {"sha": "b3fd4f920d88f9645ec5d34ed41adb198f3a7db1", "filename": "src/libsyntax/ext/deriving/generic.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0feaccf5260bc59f7ee4294a2ecc875da669ad30/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0feaccf5260bc59f7ee4294a2ecc875da669ad30/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric.rs?ref=0feaccf5260bc59f7ee4294a2ecc875da669ad30", "patch": "@@ -1151,6 +1151,7 @@ pub fn cs_or(enum_nonmatch_f: EnumNonMatchFunc,\n              enum_nonmatch_f,\n              cx, span, substructure)\n }\n+\n /// cs_binop with binop == and\n #[inline]\n pub fn cs_and(enum_nonmatch_f: EnumNonMatchFunc,"}, {"sha": "3e65f7bdefbc51a22e0f840f934044beb0da1844", "filename": "src/libsyntax/ext/deriving/mod.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0feaccf5260bc59f7ee4294a2ecc875da669ad30/src%2Flibsyntax%2Fext%2Fderiving%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0feaccf5260bc59f7ee4294a2ecc875da669ad30/src%2Flibsyntax%2Fext%2Fderiving%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fmod.rs?ref=0feaccf5260bc59f7ee4294a2ecc875da669ad30", "patch": "@@ -32,6 +32,7 @@ pub mod rand;\n pub mod to_str;\n pub mod zero;\n pub mod default;\n+pub mod primitive;\n \n #[path=\"cmp/eq.rs\"]\n pub mod eq;\n@@ -97,9 +98,12 @@ pub fn expand_meta_deriving(cx: @ExtCtxt,\n                             \"Rand\" => expand!(rand::expand_deriving_rand),\n \n                             \"ToStr\" => expand!(to_str::expand_deriving_to_str),\n+\n                             \"Zero\" => expand!(zero::expand_deriving_zero),\n                             \"Default\" => expand!(default::expand_deriving_default),\n \n+                            \"FromPrimitive\" => expand!(primitive::expand_deriving_from_primitive),\n+\n                             ref tname => {\n                                 cx.span_err(titem.span, format!(\"unknown \\\n                                     `deriving` trait: `{}`\", *tname));"}, {"sha": "6e012eedfa364f24df696c8d57a322db7ca3b75e", "filename": "src/libsyntax/ext/deriving/primitive.rs", "status": "added", "additions": 120, "deletions": 0, "changes": 120, "blob_url": "https://github.com/rust-lang/rust/blob/0feaccf5260bc59f7ee4294a2ecc875da669ad30/src%2Flibsyntax%2Fext%2Fderiving%2Fprimitive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0feaccf5260bc59f7ee4294a2ecc875da669ad30/src%2Flibsyntax%2Fext%2Fderiving%2Fprimitive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fprimitive.rs?ref=0feaccf5260bc59f7ee4294a2ecc875da669ad30", "patch": "@@ -0,0 +1,120 @@\n+// Copyright 2012-2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use ast::{MetaItem, item, Expr};\n+use ast;\n+use codemap::Span;\n+use ext::base::ExtCtxt;\n+use ext::build::AstBuilder;\n+use ext::deriving::generic::*;\n+\n+pub fn expand_deriving_from_primitive(cx: @ExtCtxt,\n+                                      span: Span,\n+                                      mitem: @MetaItem,\n+                                      in_items: ~[@item]) -> ~[@item] {\n+    let trait_def = TraitDef {\n+        path: Path::new(~[\"std\", \"num\", \"FromPrimitive\"]),\n+        additional_bounds: ~[],\n+        generics: LifetimeBounds::empty(),\n+        methods: ~[\n+            MethodDef {\n+                name: \"from_int\",\n+                generics: LifetimeBounds::empty(),\n+                explicit_self: None,\n+                args: ~[\n+                    Literal(Path::new(~[\"int\"])),\n+                ],\n+                ret_ty: Literal(Path::new_(~[\"std\", \"option\", \"Option\"],\n+                                           None,\n+                                           ~[~Self],\n+                                           true)),\n+                const_nonmatching: false,\n+                combine_substructure: |c, s, sub| cs_from(\"int\", c, s, sub),\n+            },\n+            MethodDef {\n+                name: \"from_uint\",\n+                generics: LifetimeBounds::empty(),\n+                explicit_self: None,\n+                args: ~[\n+                    Literal(Path::new(~[\"uint\"])),\n+                ],\n+                ret_ty: Literal(Path::new_(~[\"std\", \"option\", \"Option\"],\n+                                           None,\n+                                           ~[~Self],\n+                                           true)),\n+                const_nonmatching: false,\n+                combine_substructure: |c, s, sub| cs_from(\"uint\", c, s, sub),\n+            },\n+        ]\n+    };\n+\n+    trait_def.expand(cx, span, mitem, in_items)\n+}\n+\n+fn cs_from(name: &str, cx: @ExtCtxt, span: Span, substr: &Substructure) -> @Expr {\n+    let n = match substr.nonself_args {\n+        [n] => n,\n+        _ => cx.span_bug(span, \"Incorrect number of arguments in `deriving(FromPrimitive)`\")\n+    };\n+\n+    return match *substr.fields {\n+        StaticEnum(enum_def, _) => {\n+            if enum_def.variants.is_empty() {\n+                cx.span_fatal(span, \"`FromPrimitive` cannot be derived for enums with no variants\");\n+            }\n+\n+            let mut arms = ~[];\n+\n+            for variant in enum_def.variants.iter() {\n+                match variant.node.kind {\n+                    ast::tuple_variant_kind(ref args) => {\n+                        if !args.is_empty() {\n+                            cx.span_fatal(span, \"`FromPrimitive` cannot be derived for \\\n+                                                 enum variants with arguments\");\n+                        }\n+\n+                        // expr for `$n == $variant as $name`\n+                        let variant = cx.expr_ident(span, variant.node.name);\n+                        let ty = cx.ty_ident(span, cx.ident_of(name));\n+                        let cast = cx.expr_cast(span, variant, ty);\n+                        let guard = cx.expr_binary(span, ast::BiEq, n, cast);\n+\n+                        // expr for `Some($variant)`\n+                        let body = cx.expr_some(span, variant);\n+\n+                        // arm for `_ if $guard => $body`\n+                        let arm = ast::Arm {\n+                            pats: ~[cx.pat_wild(span)],\n+                            guard: Some(guard),\n+                            body: cx.block_expr(body),\n+                        };\n+\n+                        arms.push(arm);\n+                    }\n+                    ast::struct_variant_kind(_) => {\n+                        cx.span_fatal(span, \"`FromPrimitive` cannot be derived for enums \\\n+                                             with struct variants\");\n+                    }\n+                }\n+            }\n+\n+            // arm for `_ => None`\n+            let arm = ast::Arm {\n+                pats: ~[cx.pat_wild(span)],\n+                guard: None,\n+                body: cx.block_expr(cx.expr_none(span)),\n+            };\n+            arms.push(arm);\n+\n+            cx.expr_match(span, n, arms)\n+        }\n+        _ => cx.bug(\"expected StaticEnum in deriving(FromPrimitive)\")\n+    };\n+}"}, {"sha": "9f1cab6977c7acaad040981e7465194e3ef45812", "filename": "src/test/run-pass/deriving-primitive.rs", "status": "added", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/0feaccf5260bc59f7ee4294a2ecc875da669ad30/src%2Ftest%2Frun-pass%2Fderiving-primitive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0feaccf5260bc59f7ee4294a2ecc875da669ad30/src%2Ftest%2Frun-pass%2Fderiving-primitive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fderiving-primitive.rs?ref=0feaccf5260bc59f7ee4294a2ecc875da669ad30", "patch": "@@ -0,0 +1,37 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use std::num::FromPrimitive;\n+use std::int;\n+\n+#[deriving(Eq, FromPrimitive)]\n+enum A {\n+    Foo = int::max_value,\n+    Bar = 1,\n+    Baz = 3,\n+    Qux,\n+}\n+\n+fn main() {\n+    let x: Option<A> = FromPrimitive::from_int(int::max_value);\n+    assert_eq!(x, Some(Foo));\n+\n+    let x: Option<A> = FromPrimitive::from_int(1);\n+    assert_eq!(x, Some(Bar));\n+\n+    let x: Option<A> = FromPrimitive::from_int(3);\n+    assert_eq!(x, Some(Baz));\n+\n+    let x: Option<A> = FromPrimitive::from_int(4);\n+    assert_eq!(x, Some(Qux));\n+\n+    let x: Option<A> = FromPrimitive::from_int(5);\n+    assert_eq!(x, None);\n+}"}]}