{"sha": "59df6c8eb917cba41c15e3366f29ee780c9c74df", "node_id": "C_kwDOAAsO6NoAKDU5ZGY2YzhlYjkxN2NiYTQxYzE1ZTMzNjZmMjllZTc4MGM5Yzc0ZGY", "commit": {"author": {"name": "Sean Chen", "email": "seanchen11235@gmail.com", "date": "2021-10-22T17:21:10Z"}, "committer": {"name": "Sean Chen", "email": "seanchen11235@gmail.com", "date": "2021-10-22T17:21:10Z"}, "message": "Try commiting again", "tree": {"sha": "0452a6a31e824d4930019211b5092db80ec98957", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0452a6a31e824d4930019211b5092db80ec98957"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/59df6c8eb917cba41c15e3366f29ee780c9c74df", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/59df6c8eb917cba41c15e3366f29ee780c9c74df", "html_url": "https://github.com/rust-lang/rust/commit/59df6c8eb917cba41c15e3366f29ee780c9c74df", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/59df6c8eb917cba41c15e3366f29ee780c9c74df/comments", "author": {"login": "seanchen1991", "id": 4572868, "node_id": "MDQ6VXNlcjQ1NzI4Njg=", "avatar_url": "https://avatars.githubusercontent.com/u/4572868?v=4", "gravatar_id": "", "url": "https://api.github.com/users/seanchen1991", "html_url": "https://github.com/seanchen1991", "followers_url": "https://api.github.com/users/seanchen1991/followers", "following_url": "https://api.github.com/users/seanchen1991/following{/other_user}", "gists_url": "https://api.github.com/users/seanchen1991/gists{/gist_id}", "starred_url": "https://api.github.com/users/seanchen1991/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/seanchen1991/subscriptions", "organizations_url": "https://api.github.com/users/seanchen1991/orgs", "repos_url": "https://api.github.com/users/seanchen1991/repos", "events_url": "https://api.github.com/users/seanchen1991/events{/privacy}", "received_events_url": "https://api.github.com/users/seanchen1991/received_events", "type": "User", "site_admin": false}, "committer": {"login": "seanchen1991", "id": 4572868, "node_id": "MDQ6VXNlcjQ1NzI4Njg=", "avatar_url": "https://avatars.githubusercontent.com/u/4572868?v=4", "gravatar_id": "", "url": "https://api.github.com/users/seanchen1991", "html_url": "https://github.com/seanchen1991", "followers_url": "https://api.github.com/users/seanchen1991/followers", "following_url": "https://api.github.com/users/seanchen1991/following{/other_user}", "gists_url": "https://api.github.com/users/seanchen1991/gists{/gist_id}", "starred_url": "https://api.github.com/users/seanchen1991/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/seanchen1991/subscriptions", "organizations_url": "https://api.github.com/users/seanchen1991/orgs", "repos_url": "https://api.github.com/users/seanchen1991/repos", "events_url": "https://api.github.com/users/seanchen1991/events{/privacy}", "received_events_url": "https://api.github.com/users/seanchen1991/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "547a6ffee0cf4da9929a9e3d49546dc87d607735", "url": "https://api.github.com/repos/rust-lang/rust/commits/547a6ffee0cf4da9929a9e3d49546dc87d607735", "html_url": "https://github.com/rust-lang/rust/commit/547a6ffee0cf4da9929a9e3d49546dc87d607735"}], "stats": {"total": 245, "additions": 244, "deletions": 1}, "files": [{"sha": "9fb8f2b9b8bc5d5213da9071fbdc503f1db5f69a", "filename": "library/std/src/error.rs", "status": "modified", "additions": 244, "deletions": 1, "changes": 245, "blob_url": "https://github.com/rust-lang/rust/blob/59df6c8eb917cba41c15e3366f29ee780c9c74df/library%2Fstd%2Fsrc%2Ferror.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59df6c8eb917cba41c15e3366f29ee780c9c74df/library%2Fstd%2Fsrc%2Ferror.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Ferror.rs?ref=59df6c8eb917cba41c15e3366f29ee780c9c74df", "patch": "@@ -25,7 +25,7 @@ use crate::backtrace::Backtrace;\n use crate::borrow::Cow;\n use crate::cell;\n use crate::char;\n-use crate::fmt::{self, Debug, Display};\n+use crate::fmt::{self, Debug, Display, Write};\n use crate::mem::transmute;\n use crate::num;\n use crate::str;\n@@ -807,3 +807,246 @@ impl dyn Error + Send + Sync {\n         })\n     }\n }\n+\n+/// An error reporter that exposes the entire error chain for printing.\n+/// It also exposes options for formatting the error chain, either entirely on a single line,\n+/// or in multi-line format with each cause in the error chain on a new line.\n+///\n+/// # Examples\n+///\n+/// ```\n+/// #![feature(error_reporter)]\n+///\n+/// use std::error::{Error, Report};\n+/// use std::fmt;\n+///\n+/// #[derive(Debug)]\n+/// struct SuperError {\n+///     side: SuperErrorSideKick,\n+/// }\n+///\n+/// impl fmt::Display for SuperError {\n+///     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+///         write!(f, \"SuperError is here!\")\n+///     }\n+/// }\n+///\n+/// impl Error for SuperError {\n+///     fn source(&self) -> Option<&(dyn Error + 'static)> {\n+///         Some(&self.side)\n+///     }\n+/// }\n+///\n+/// #[derive(Debug)]\n+/// struct SuperErrorSideKick;\n+///\n+/// impl fmt::Display for SuperErrorSideKick {\n+///     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+///         write!(f, \"SuperErrorSideKick is here!\")\n+///     }\n+/// }\n+///\n+/// impl Error for SuperErrorSideKick {}\n+///\n+/// fn main() {\n+///     let error = SuperError { side: SuperErrorSideKick };\n+///     let report = Report::new(&error).pretty();\n+///\n+///     println!(\"{}\", report);\n+/// }\n+/// ```\n+#[unstable(feature = \"error_reporter\", issue = \"90172\")]\n+pub struct Report<E> {\n+    source: E,\n+    show_backtrace: bool,\n+    pretty: bool,\n+}\n+\n+impl<E> Report<E>\n+where\n+    E: Error,\n+{\n+    /// Create a new `Report` from an input error.\n+    #[unstable(feature = \"error_reporter\", issue = \"90172\")]\n+    pub fn new(source: E) -> Report<E> {\n+        Report { source, show_backtrace: false, pretty: false }\n+    }\n+\n+    /// Enable pretty-printing the report.\n+    #[unstable(feature = \"error_reporter\", issue = \"90172\")]\n+    pub fn pretty(mut self) -> Self {\n+        self.pretty = true;\n+        self\n+    }\n+\n+    /// Enable showing a backtrace for the report.\n+    #[unstable(feature = \"error_reporter\", issue = \"90172\")]\n+    pub fn show_backtrace(mut self) -> Self {\n+        self.show_backtrace = true;\n+        self\n+    }\n+\n+    /// Format the report as a single line.\n+    #[unstable(feature = \"error_reporter\", issue = \"90172\")]\n+    fn fmt_singleline(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        write!(f, \"{}\", self.source)?;\n+\n+        let sources = self.source.source().into_iter().flat_map(<dyn Error>::chain);\n+\n+        for cause in sources {\n+            write!(f, \": {}\", cause)?;\n+        }\n+\n+        Ok(())\n+    }\n+\n+    /// Format the report as multiple lines, with each error cause on its own line.\n+    #[unstable(feature = \"error_reporter\", issue = \"90172\")]\n+    fn fmt_multiline(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        let error = &self.source;\n+\n+        write!(f, \"{}\", error)?;\n+\n+        if let Some(cause) = error.source() {\n+            write!(f, \"\\n\\nCaused by:\")?;\n+\n+            let multiple = cause.source().is_some();\n+            let format = if multiple {\n+                Format::Numbered { ind: 0 }\n+            } else {\n+                Format::Uniform { indentation: \"    \" }\n+            };\n+\n+            for error in cause.chain() {\n+                writeln!(f)?;\n+\n+                let mut indented = Indented { inner: f, needs_indent: true, format };\n+\n+                write!(indented, \"{}\", error)?;\n+            }\n+        }\n+\n+        if self.show_backtrace {\n+            let backtrace = error.backtrace();\n+\n+            if let Some(backtrace) = backtrace {\n+                let mut backtrace = backtrace.to_string();\n+\n+                write!(f, \"\\n\\n\")?;\n+                writeln!(f, \"Stack backtrace:\")?;\n+\n+                backtrace.truncate(backtrace.trim_end().len());\n+\n+                write!(f, \"{}\", backtrace)?;\n+            }\n+        }\n+\n+        Ok(())\n+    }\n+}\n+\n+#[unstable(feature = \"error_reporter\", issue = \"90172\")]\n+impl<E> From<E> for Report<E>\n+where\n+    E: Error,\n+{\n+    fn from(source: E) -> Self {\n+        Report::new(source)\n+    }\n+}\n+\n+#[unstable(feature = \"error_reporter\", issue = \"90172\")]\n+impl<E> fmt::Display for Report<E>\n+where\n+    E: Error,\n+{\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        if self.pretty { self.fmt_multiline(f) } else { self.fmt_singleline(f) }\n+    }\n+}\n+\n+// This type intentionally outputs the same format for `Display` and `Debug`for\n+// situations where you unwrap a `Report` or return it from main.\n+#[unstable(feature = \"error_reporter\", issue = \"90172\")]\n+impl<E> fmt::Debug for Report<E>\n+where\n+    E: Error,\n+{\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        fmt::Display::fmt(self, f)\n+    }\n+}\n+\n+/// Encapsulates how error sources are indented and formatted.\n+struct Indented<'a, D: ?Sized> {\n+    inner: &'a mut D,\n+    needs_indent: bool,\n+    format: Format,\n+}\n+\n+/// The possible variants that error sources can be formatted as.\n+#[derive(Clone, Copy)]\n+enum Format {\n+    /// Insert uniform indentation before every line.\n+    ///\n+    /// This format takes a static string as input and inserts it after every newline.\n+    Uniform {\n+        /// The string to insert as indentation.\n+        indentation: &'static str,\n+    },\n+    /// Inserts a number before the first line.\n+    ///\n+    /// This format hard codes the indentation level to match the indentation from\n+    /// `std::backtrace::Backtrace`.\n+    Numbered {\n+        /// The index to insert before the first line of output.\n+        ind: usize,\n+    },\n+}\n+\n+impl<D> Write for Indented<'_, D>\n+where\n+    D: Write + ?Sized,\n+{\n+    fn write_str(&mut self, s: &str) -> fmt::Result {\n+        for (ind, line) in s.split('\\n').enumerate() {\n+            if ind > 0 {\n+                self.inner.write_char('\\n')?;\n+                self.needs_indent = true;\n+            }\n+\n+            if self.needs_indent {\n+                if line.is_empty() {\n+                    continue;\n+                }\n+\n+                self.format.insert_indentation(ind, &mut self.inner)?;\n+                self.needs_indent = false;\n+            }\n+\n+            self.inner.write_fmt(format_args!(\"{}\", line))?;\n+        }\n+\n+        Ok(())\n+    }\n+}\n+\n+impl Format {\n+    /// Write the specified formatting to the write buffer.\n+    fn insert_indentation(&mut self, line: usize, f: &mut dyn Write) -> fmt::Result {\n+        match self {\n+            Format::Uniform { indentation } => {\n+                write!(f, \"{}\", indentation)\n+            }\n+            Format::Numbered { ind } => {\n+                if line == 0 {\n+                    write!(f, \"{: >4}: \", ind)?;\n+                    *ind += 1;\n+                    Ok(())\n+                } else {\n+                    write!(f, \"      \")\n+                }\n+            }\n+        }\n+    }\n+}"}]}