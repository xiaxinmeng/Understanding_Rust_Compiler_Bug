{"sha": "245857beb76094d07f8447c5072d9da386f42b91", "node_id": "C_kwDOAAsO6NoAKDI0NTg1N2JlYjc2MDk0ZDA3Zjg0NDdjNTA3MmQ5ZGEzODZmNDJiOTE", "commit": {"author": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2022-11-26T14:58:28Z"}, "committer": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2022-11-26T15:14:58Z"}, "message": "refactor try_resolve_did and also support resolving crates/modules", "tree": {"sha": "cdd594ef006cc27d664610109187c5ba6bbea943", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/cdd594ef006cc27d664610109187c5ba6bbea943"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/245857beb76094d07f8447c5072d9da386f42b91", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/245857beb76094d07f8447c5072d9da386f42b91", "html_url": "https://github.com/rust-lang/rust/commit/245857beb76094d07f8447c5072d9da386f42b91", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/245857beb76094d07f8447c5072d9da386f42b91/comments", "author": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "committer": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0822c311fb062d0e82094cb78a00b12786ed0fd4", "url": "https://api.github.com/repos/rust-lang/rust/commits/0822c311fb062d0e82094cb78a00b12786ed0fd4", "html_url": "https://github.com/rust-lang/rust/commit/0822c311fb062d0e82094cb78a00b12786ed0fd4"}], "stats": {"total": 80, "additions": 54, "deletions": 26}, "files": [{"sha": "bf086a7c623300cb8cb37fe4947e46b1d46beb85", "filename": "src/tools/miri/src/helpers.rs", "status": "modified", "additions": 54, "deletions": 26, "changes": 80, "blob_url": "https://github.com/rust-lang/rust/blob/245857beb76094d07f8447c5072d9da386f42b91/src%2Ftools%2Fmiri%2Fsrc%2Fhelpers.rs", "raw_url": "https://github.com/rust-lang/rust/raw/245857beb76094d07f8447c5072d9da386f42b91/src%2Ftools%2Fmiri%2Fsrc%2Fhelpers.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fsrc%2Fhelpers.rs?ref=245857beb76094d07f8447c5072d9da386f42b91", "patch": "@@ -74,38 +74,66 @@ const UNIX_IO_ERROR_TABLE: &[(&str, std::io::ErrorKind)] = {\n };\n \n /// Gets an instance for a path.\n-fn try_resolve_did<'tcx>(tcx: TyCtxt<'tcx>, path: &[&str], namespace: Namespace) -> Option<DefId> {\n-    tcx.crates(()).iter().find(|&&krate| tcx.crate_name(krate).as_str() == path[0]).and_then(\n-        |krate| {\n-            let krate = DefId { krate: *krate, index: CRATE_DEF_INDEX };\n-            let mut items = tcx.module_children(krate);\n-\n-            for &segment in &path[1..path.len() - 1] {\n-                let next_mod = items.iter().find(|item| {\n-                    item.ident.name.as_str() == segment\n-                        && tcx.def_kind(item.res.def_id()) == DefKind::Mod\n-                })?;\n-\n-                items = tcx.module_children(next_mod.res.def_id());\n-            }\n-\n-            let item_name = *path.last().unwrap();\n-\n-            let item = items.iter().find(|item| {\n-                item.ident.name.as_str() == item_name\n-                    && tcx.def_kind(item.res.def_id()).ns() == Some(namespace)\n-            })?;\n+///\n+/// A `None` namespace indicates we are looking for a module.\n+fn try_resolve_did<'tcx>(\n+    tcx: TyCtxt<'tcx>,\n+    path: &[&str],\n+    namespace: Option<Namespace>,\n+) -> Option<DefId> {\n+    /// Yield all children of the given item, that have the given name.\n+    fn find_children<'tcx: 'a, 'a>(\n+        tcx: TyCtxt<'tcx>,\n+        item: DefId,\n+        name: &'a str,\n+    ) -> impl Iterator<Item = DefId> + 'a {\n+        tcx.module_children(item)\n+            .iter()\n+            .filter(move |item| item.ident.name.as_str() == name)\n+            .map(move |item| item.res.def_id())\n+    }\n \n-            Some(item.res.def_id())\n-        },\n-    )\n+    // Take apart the path: leading crate, a sequence of modules, and potentially a final item.\n+    let (&crate_name, path) = path.split_first().expect(\"paths must have at least one segment\");\n+    let (modules, item) = if let Some(namespace) = namespace {\n+        let (&item_name, modules) =\n+            path.split_last().expect(\"non-module paths must have at least 2 segments\");\n+        (modules, Some((item_name, namespace)))\n+    } else {\n+        (path, None)\n+    };\n+\n+    // First find the crate.\n+    let krate =\n+        tcx.crates(()).iter().find(|&&krate| tcx.crate_name(krate).as_str() == crate_name)?;\n+    let mut cur_item = DefId { krate: *krate, index: CRATE_DEF_INDEX };\n+    // Then go over the modules.\n+    for &segment in modules {\n+        cur_item = find_children(tcx, cur_item, segment)\n+            .find(|item| tcx.def_kind(item) == DefKind::Mod)?;\n+    }\n+    // Finally, look up the desired item in this module, if any.\n+    match item {\n+        Some((item_name, namespace)) =>\n+            Some(\n+                find_children(tcx, cur_item, item_name)\n+                    .find(|item| tcx.def_kind(item).ns() == Some(namespace))?,\n+            ),\n+        None => Some(cur_item),\n+    }\n }\n \n pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n+    /// Checks if the given crate/module exists.\n+    fn have_module(&self, path: &[&str]) -> bool {\n+        try_resolve_did(*self.eval_context_ref().tcx, path, None).is_some()\n+    }\n+\n     /// Gets an instance for a path; fails gracefully if the path does not exist.\n     fn try_resolve_path(&self, path: &[&str], namespace: Namespace) -> Option<ty::Instance<'tcx>> {\n-        let did = try_resolve_did(self.eval_context_ref().tcx.tcx, path, namespace)?;\n-        Some(ty::Instance::mono(self.eval_context_ref().tcx.tcx, did))\n+        let tcx = self.eval_context_ref().tcx.tcx;\n+        let did = try_resolve_did(tcx, path, Some(namespace))?;\n+        Some(ty::Instance::mono(tcx, did))\n     }\n \n     /// Gets an instance for a path."}]}