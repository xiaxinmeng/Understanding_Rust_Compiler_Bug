{"sha": "82b5f1d8690ec538557ce3f355add91e3809ba51", "node_id": "MDY6Q29tbWl0NzI0NzEyOjgyYjVmMWQ4NjkwZWM1Mzg1NTdjZTNmMzU1YWRkOTFlMzgwOWJhNTE=", "commit": {"author": {"name": "Michael Woerister", "email": "michaelwoerister@posteo.net", "date": "2016-03-01T13:18:21Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2016-03-25T18:07:18Z"}, "message": "Remove old symbol naming code.", "tree": {"sha": "b9666e67bf553fc621c40412085d0dedf2c8d751", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b9666e67bf553fc621c40412085d0dedf2c8d751"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/82b5f1d8690ec538557ce3f355add91e3809ba51", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/82b5f1d8690ec538557ce3f355add91e3809ba51", "html_url": "https://github.com/rust-lang/rust/commit/82b5f1d8690ec538557ce3f355add91e3809ba51", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/82b5f1d8690ec538557ce3f355add91e3809ba51/comments", "author": {"login": "michaelwoerister", "id": 1825894, "node_id": "MDQ6VXNlcjE4MjU4OTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1825894?v=4", "gravatar_id": "", "url": "https://api.github.com/users/michaelwoerister", "html_url": "https://github.com/michaelwoerister", "followers_url": "https://api.github.com/users/michaelwoerister/followers", "following_url": "https://api.github.com/users/michaelwoerister/following{/other_user}", "gists_url": "https://api.github.com/users/michaelwoerister/gists{/gist_id}", "starred_url": "https://api.github.com/users/michaelwoerister/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/michaelwoerister/subscriptions", "organizations_url": "https://api.github.com/users/michaelwoerister/orgs", "repos_url": "https://api.github.com/users/michaelwoerister/repos", "events_url": "https://api.github.com/users/michaelwoerister/events{/privacy}", "received_events_url": "https://api.github.com/users/michaelwoerister/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2eebb7b60588902c51d6d8dd9e695c6babaa8aa2", "url": "https://api.github.com/repos/rust-lang/rust/commits/2eebb7b60588902c51d6d8dd9e695c6babaa8aa2", "html_url": "https://github.com/rust-lang/rust/commit/2eebb7b60588902c51d6d8dd9e695c6babaa8aa2"}], "stats": {"total": 236, "additions": 88, "deletions": 148}, "files": [{"sha": "a8e83bdb6b7f65ffeff80957d175d2d367b1dfd9", "filename": "src/librustc_trans/back/link.rs", "status": "modified", "additions": 0, "deletions": 144, "changes": 144, "blob_url": "https://github.com/rust-lang/rust/blob/82b5f1d8690ec538557ce3f355add91e3809ba51/src%2Flibrustc_trans%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/82b5f1d8690ec538557ce3f355add91e3809ba51/src%2Flibrustc_trans%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fback%2Flink.rs?ref=82b5f1d8690ec538557ce3f355add91e3809ba51", "patch": "@@ -22,9 +22,7 @@ use session::search_paths::PathKind;\n use session::Session;\n use middle::cstore::{self, CrateStore, LinkMeta};\n use middle::cstore::{LinkagePreference, NativeLibraryKind};\n-use middle::def_id::DefId;\n use middle::dependency_format::Linkage;\n-use middle::ty::TyCtxt;\n use trans::CrateTranslation;\n use util::common::time;\n use util::fs::fix_windows_verbatim_for_gcc;\n@@ -43,7 +41,6 @@ use std::str;\n use flate;\n use syntax::ast;\n use syntax::codemap::Span;\n-use syntax::parse::token::InternedString;\n use syntax::attr::AttrMetaMethods;\n \n use rustc_front::hir;\n@@ -78,58 +75,6 @@ pub const RLIB_BYTECODE_OBJECT_V1_DATA_OFFSET: usize =\n     RLIB_BYTECODE_OBJECT_V1_DATASIZE_OFFSET + 8;\n \n \n-/*\n- * Name mangling and its relationship to metadata. This is complex. Read\n- * carefully.\n- *\n- * The semantic model of Rust linkage is, broadly, that \"there's no global\n- * namespace\" between crates. Our aim is to preserve the illusion of this\n- * model despite the fact that it's not *quite* possible to implement on\n- * modern linkers. We initially didn't use system linkers at all, but have\n- * been convinced of their utility.\n- *\n- * There are a few issues to handle:\n- *\n- *  - Linkers operate on a flat namespace, so we have to flatten names.\n- *    We do this using the C++ namespace-mangling technique. Foo::bar\n- *    symbols and such.\n- *\n- *  - Symbols with the same name but different types need to get different\n- *    linkage-names. We do this by hashing a string-encoding of the type into\n- *    a fixed-size (currently 16-byte hex) cryptographic hash function (CHF:\n- *    we use SHA256) to \"prevent collisions\". This is not airtight but 16 hex\n- *    digits on uniform probability means you're going to need 2**32 same-name\n- *    symbols in the same process before you're even hitting birthday-paradox\n- *    collision probability.\n- *\n- *  - Symbols in different crates but with same names \"within\" the crate need\n- *    to get different linkage-names.\n- *\n- *  - The hash shown in the filename needs to be predictable and stable for\n- *    build tooling integration. It also needs to be using a hash function\n- *    which is easy to use from Python, make, etc.\n- *\n- * So here is what we do:\n- *\n- *  - Consider the package id; every crate has one (specified with crate_id\n- *    attribute).  If a package id isn't provided explicitly, we infer a\n- *    versionless one from the output name. The version will end up being 0.0\n- *    in this case. CNAME and CVERS are taken from this package id. For\n- *    example, github.com/mozilla/CNAME#CVERS.\n- *\n- *  - Define CMH as SHA256(crateid).\n- *\n- *  - Define CMH8 as the first 8 characters of CMH.\n- *\n- *  - Compile our crate to lib CNAME-CMH8-CVERS.so\n- *\n- *  - Define STH(sym) as SHA256(CMH, type_str(sym))\n- *\n- *  - Suffix a mangled sym with ::STH@CVERS, so that it is unique in the\n- *    name, non-name metadata, and type sense, and versioned in the way\n- *    system linkers understand.\n- */\n-\n pub fn find_crate_name(sess: Option<&Session>,\n                        attrs: &[ast::Attribute],\n                        input: &Input) -> String {\n@@ -191,95 +136,6 @@ pub fn build_link_meta(sess: &Session,\n     return r;\n }\n \n-pub fn def_to_string(_tcx: &TyCtxt, did: DefId) -> String {\n-    format!(\"{}:{}\", did.krate, did.index.as_usize())\n-}\n-\n-// Name sanitation. LLVM will happily accept identifiers with weird names, but\n-// gas doesn't!\n-// gas accepts the following characters in symbols: a-z, A-Z, 0-9, ., _, $\n-pub fn sanitize(s: &str) -> String {\n-    let mut result = String::new();\n-    for c in s.chars() {\n-        match c {\n-            // Escape these with $ sequences\n-            '@' => result.push_str(\"$SP$\"),\n-            '*' => result.push_str(\"$BP$\"),\n-            '&' => result.push_str(\"$RF$\"),\n-            '<' => result.push_str(\"$LT$\"),\n-            '>' => result.push_str(\"$GT$\"),\n-            '(' => result.push_str(\"$LP$\"),\n-            ')' => result.push_str(\"$RP$\"),\n-            ',' => result.push_str(\"$C$\"),\n-\n-            // '.' doesn't occur in types and functions, so reuse it\n-            // for ':' and '-'\n-            '-' | ':' => result.push('.'),\n-\n-            // These are legal symbols\n-            'a' ... 'z'\n-            | 'A' ... 'Z'\n-            | '0' ... '9'\n-            | '_' | '.' | '$' => result.push(c),\n-\n-            _ => {\n-                result.push('$');\n-                for c in c.escape_unicode().skip(1) {\n-                    match c {\n-                        '{' => {},\n-                        '}' => result.push('$'),\n-                        c => result.push(c),\n-                    }\n-                }\n-            }\n-        }\n-    }\n-\n-    // Underscore-qualify anything that didn't start as an ident.\n-    if !result.is_empty() &&\n-        result.as_bytes()[0] != '_' as u8 &&\n-        ! (result.as_bytes()[0] as char).is_xid_start() {\n-        return format!(\"_{}\", &result[..]);\n-    }\n-\n-    return result;\n-}\n-\n-pub fn mangle<PI: Iterator<Item=InternedString>>(path: PI, hash: Option<&str>) -> String {\n-    // Follow C++ namespace-mangling style, see\n-    // http://en.wikipedia.org/wiki/Name_mangling for more info.\n-    //\n-    // It turns out that on OSX you can actually have arbitrary symbols in\n-    // function names (at least when given to LLVM), but this is not possible\n-    // when using unix's linker. Perhaps one day when we just use a linker from LLVM\n-    // we won't need to do this name mangling. The problem with name mangling is\n-    // that it seriously limits the available characters. For example we can't\n-    // have things like &T in symbol names when one would theoretically\n-    // want them for things like impls of traits on that type.\n-    //\n-    // To be able to work on all platforms and get *some* reasonable output, we\n-    // use C++ name-mangling.\n-\n-    let mut n = String::from(\"_ZN\"); // _Z == Begin name-sequence, N == nested\n-\n-    fn push(n: &mut String, s: &str) {\n-        let sani = sanitize(s);\n-        n.push_str(&format!(\"{}{}\", sani.len(), sani));\n-    }\n-\n-    // First, connect each component with <len, name> pairs.\n-    for data in path {\n-        push(&mut n, &data);\n-    }\n-\n-    if let Some(s) = hash {\n-        push(&mut n, s)\n-    }\n-\n-    n.push('E'); // End name-sequence.\n-    n\n-}\n-\n pub fn get_linker(sess: &Session) -> (String, Command) {\n     if let Some(ref linker) = sess.opts.cg.linker {\n         (linker.clone(), Command::new(linker))"}, {"sha": "7f42cc673c73f98fbc9fb42d63ecb38c3b154844", "filename": "src/librustc_trans/back/symbol_names.rs", "status": "modified", "additions": 88, "deletions": 4, "changes": 92, "blob_url": "https://github.com/rust-lang/rust/blob/82b5f1d8690ec538557ce3f355add91e3809ba51/src%2Flibrustc_trans%2Fback%2Fsymbol_names.rs", "raw_url": "https://github.com/rust-lang/rust/raw/82b5f1d8690ec538557ce3f355add91e3809ba51/src%2Flibrustc_trans%2Fback%2Fsymbol_names.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fback%2Fsymbol_names.rs?ref=82b5f1d8690ec538557ce3f355add91e3809ba51", "patch": "@@ -107,9 +107,8 @@ use rustc::front::map::definitions::DefPath;\n \n use std::fmt::Write;\n use syntax::ast;\n-use syntax::parse::token;\n+use syntax::parse::token::{self, InternedString};\n use serialize::hex::ToHex;\n-use super::link;\n \n pub fn def_id_to_string<'tcx>(tcx: &ty::TyCtxt<'tcx>, def_id: DefId) -> String {\n \n@@ -207,7 +206,7 @@ fn exported_name_with_opt_suffix<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n         path.push(token::intern_and_get_ident(suffix));\n     }\n \n-    link::mangle(path.into_iter(), Some(&hash[..]))\n+    mangle(path.into_iter(), Some(&hash[..]))\n }\n \n pub fn exported_name<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n@@ -232,5 +231,90 @@ pub fn internal_name_from_type_and_suffix<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>\n     let path = [token::intern(&t.to_string()).as_str(),\n                 gensym_name(suffix).as_str()];\n     let hash = get_symbol_hash(ccx, &Vec::new(), cstore::LOCAL_CRATE, &[t]);\n-    link::mangle(path.iter().cloned(), Some(&hash[..]))\n+    mangle(path.iter().cloned(), Some(&hash[..]))\n+}\n+\n+// Name sanitation. LLVM will happily accept identifiers with weird names, but\n+// gas doesn't!\n+// gas accepts the following characters in symbols: a-z, A-Z, 0-9, ., _, $\n+pub fn sanitize(s: &str) -> String {\n+    let mut result = String::new();\n+    for c in s.chars() {\n+        match c {\n+            // Escape these with $ sequences\n+            '@' => result.push_str(\"$SP$\"),\n+            '*' => result.push_str(\"$BP$\"),\n+            '&' => result.push_str(\"$RF$\"),\n+            '<' => result.push_str(\"$LT$\"),\n+            '>' => result.push_str(\"$GT$\"),\n+            '(' => result.push_str(\"$LP$\"),\n+            ')' => result.push_str(\"$RP$\"),\n+            ',' => result.push_str(\"$C$\"),\n+\n+            // '.' doesn't occur in types and functions, so reuse it\n+            // for ':' and '-'\n+            '-' | ':' => result.push('.'),\n+\n+            // These are legal symbols\n+            'a' ... 'z'\n+            | 'A' ... 'Z'\n+            | '0' ... '9'\n+            | '_' | '.' | '$' => result.push(c),\n+\n+            _ => {\n+                result.push('$');\n+                for c in c.escape_unicode().skip(1) {\n+                    match c {\n+                        '{' => {},\n+                        '}' => result.push('$'),\n+                        c => result.push(c),\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    // Underscore-qualify anything that didn't start as an ident.\n+    if !result.is_empty() &&\n+        result.as_bytes()[0] != '_' as u8 &&\n+        ! (result.as_bytes()[0] as char).is_xid_start() {\n+        return format!(\"_{}\", &result[..]);\n+    }\n+\n+    return result;\n+}\n+\n+pub fn mangle<PI: Iterator<Item=InternedString>>(path: PI, hash: Option<&str>) -> String {\n+    // Follow C++ namespace-mangling style, see\n+    // http://en.wikipedia.org/wiki/Name_mangling for more info.\n+    //\n+    // It turns out that on OSX you can actually have arbitrary symbols in\n+    // function names (at least when given to LLVM), but this is not possible\n+    // when using unix's linker. Perhaps one day when we just use a linker from LLVM\n+    // we won't need to do this name mangling. The problem with name mangling is\n+    // that it seriously limits the available characters. For example we can't\n+    // have things like &T in symbol names when one would theoretically\n+    // want them for things like impls of traits on that type.\n+    //\n+    // To be able to work on all platforms and get *some* reasonable output, we\n+    // use C++ name-mangling.\n+\n+    let mut n = String::from(\"_ZN\"); // _Z == Begin name-sequence, N == nested\n+\n+    fn push(n: &mut String, s: &str) {\n+        let sani = sanitize(s);\n+        n.push_str(&format!(\"{}{}\", sani.len(), sani));\n+    }\n+\n+    // First, connect each component with <len, name> pairs.\n+    for data in path {\n+        push(&mut n, &data);\n+    }\n+\n+    if let Some(s) = hash {\n+        push(&mut n, s)\n+    }\n+\n+    n.push('E'); // End name-sequence.\n+    n\n }"}]}