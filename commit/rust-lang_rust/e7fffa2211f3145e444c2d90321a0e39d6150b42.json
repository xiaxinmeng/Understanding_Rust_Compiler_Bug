{"sha": "e7fffa2211f3145e444c2d90321a0e39d6150b42", "node_id": "MDY6Q29tbWl0NzI0NzEyOmU3ZmZmYTIyMTFmMzE0NWU0NDRjMmQ5MDMyMWEwZTM5ZDYxNTBiNDI=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-06-13T06:20:12Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-06-13T06:20:12Z"}, "message": "Auto merge of #42471 - nrc:save-sig-2, r=eddyb\n\nsave-analysis: signatures for everything!", "tree": {"sha": "4031dbe148243964f98dea97eb3c80e2f04f469d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4031dbe148243964f98dea97eb3c80e2f04f469d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e7fffa2211f3145e444c2d90321a0e39d6150b42", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e7fffa2211f3145e444c2d90321a0e39d6150b42", "html_url": "https://github.com/rust-lang/rust/commit/e7fffa2211f3145e444c2d90321a0e39d6150b42", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e7fffa2211f3145e444c2d90321a0e39d6150b42/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "add847a82d724ebb858987bdc47283ed8b9b8ad2", "url": "https://api.github.com/repos/rust-lang/rust/commits/add847a82d724ebb858987bdc47283ed8b9b8ad2", "html_url": "https://github.com/rust-lang/rust/commit/add847a82d724ebb858987bdc47283ed8b9b8ad2"}, {"sha": "ffd83fdf7deacc8f985dab0d44bfe1e2becf6543", "url": "https://api.github.com/repos/rust-lang/rust/commits/ffd83fdf7deacc8f985dab0d44bfe1e2becf6543", "html_url": "https://github.com/rust-lang/rust/commit/ffd83fdf7deacc8f985dab0d44bfe1e2becf6543"}], "stats": {"total": 1328, "additions": 1073, "deletions": 255}, "files": [{"sha": "efbbe36c981a884933937827d58d6f3eec2cde37", "filename": "src/Cargo.lock", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/e7fffa2211f3145e444c2d90321a0e39d6150b42/src%2FCargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/e7fffa2211f3145e444c2d90321a0e39d6150b42/src%2FCargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2FCargo.lock?ref=e7fffa2211f3145e444c2d90321a0e39d6150b42", "patch": "@@ -1040,7 +1040,7 @@ dependencies = [\n \n [[package]]\n name = \"rls-data\"\n-version = \"0.3.1\"\n+version = \"0.4.1\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n  \"rls-span 0.4.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n@@ -1049,7 +1049,7 @@ dependencies = [\n \n [[package]]\n name = \"rls-data\"\n-version = \"0.4.1\"\n+version = \"0.6.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n  \"rls-span 0.4.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n@@ -1372,7 +1372,7 @@ name = \"rustc_save_analysis\"\n version = \"0.0.0\"\n dependencies = [\n  \"log 0.3.7 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"rls-data 0.3.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"rls-data 0.6.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"rls-span 0.4.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"rustc 0.0.0\",\n  \"rustc-serialize 0.3.24 (registry+https://github.com/rust-lang/crates.io-index)\",\n@@ -2076,8 +2076,8 @@ source = \"registry+https://github.com/rust-lang/crates.io-index\"\n \"checksum regex-syntax 0.3.9 (registry+https://github.com/rust-lang/crates.io-index)\" = \"f9ec002c35e86791825ed294b50008eea9ddfc8def4420124fbc6b08db834957\"\n \"checksum regex-syntax 0.4.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"2f9191b1f57603095f105d317e375d19b1c9c5c3185ea9633a99a6dcbed04457\"\n \"checksum rls-analysis 0.3.2 (registry+https://github.com/rust-lang/crates.io-index)\" = \"8d77d58e8933752142b5b92e3f8ba6d6f1630be6da5627c492268a43f79ffbda\"\n-\"checksum rls-data 0.3.1 (registry+https://github.com/rust-lang/crates.io-index)\" = \"fc4277ce3c57f456b11fe3145b181a844a25201bab5cbaa1978457e6e2f27d47\"\n \"checksum rls-data 0.4.1 (registry+https://github.com/rust-lang/crates.io-index)\" = \"374a8fad31cc0681a7bfd8a04079dd4afd0e981d34e18a171b1a467445bdf51e\"\n+\"checksum rls-data 0.6.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"9e2087477364c34faca86c2476765deb1185dbae3c598cfb1eb040f3a74d22b5\"\n \"checksum rls-span 0.4.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"5d7c7046dc6a92f2ae02ed302746db4382e75131b9ce20ce967259f6b5867a6a\"\n \"checksum rls-vfs 0.4.2 (registry+https://github.com/rust-lang/crates.io-index)\" = \"ace07060dd154731b39254864245cbdd33c8f5f64fe1f630a089c72e2468f854\"\n \"checksum rustc-demangle 0.1.4 (registry+https://github.com/rust-lang/crates.io-index)\" = \"3058a43ada2c2d0b92b3ae38007a2d0fa5e9db971be260e0171408a4ff471c95\""}, {"sha": "53a82cf73e95b06d943959c6cd6a4516cc92ff2b", "filename": "src/librustc_save_analysis/Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e7fffa2211f3145e444c2d90321a0e39d6150b42/src%2Flibrustc_save_analysis%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/e7fffa2211f3145e444c2d90321a0e39d6150b42/src%2Flibrustc_save_analysis%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_save_analysis%2FCargo.toml?ref=e7fffa2211f3145e444c2d90321a0e39d6150b42", "patch": "@@ -14,7 +14,7 @@ rustc = { path = \"../librustc\" }\n rustc_typeck = { path = \"../librustc_typeck\" }\n syntax = { path = \"../libsyntax\" }\n syntax_pos = { path = \"../libsyntax_pos\" }\n-rls-data = \"0.3\"\n+rls-data = \"0.6\"\n rls-span = \"0.4\"\n # FIXME(#40527) should move rustc serialize out of tree\n rustc-serialize = \"0.3\""}, {"sha": "e15e3f6e79e26296a48b0bc798cfbfd30950f2a5", "filename": "src/librustc_save_analysis/data.rs", "status": "modified", "additions": 8, "deletions": 33, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/e7fffa2211f3145e444c2d90321a0e39d6150b42/src%2Flibrustc_save_analysis%2Fdata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7fffa2211f3145e444c2d90321a0e39d6150b42/src%2Flibrustc_save_analysis%2Fdata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_save_analysis%2Fdata.rs?ref=e7fffa2211f3145e444c2d90321a0e39d6150b42", "patch": "@@ -18,7 +18,7 @@ use rustc::hir::def_id::{CrateNum, DefId};\n use syntax::ast::{self, Attribute, NodeId};\n use syntax_pos::Span;\n \n-use rls_data::ExternalCrateData;\n+use rls_data::{ExternalCrateData, Signature};\n \n pub struct CrateData {\n     pub name: String,\n@@ -129,7 +129,7 @@ pub struct EnumData {\n     pub variants: Vec<NodeId>,\n     pub visibility: Visibility,\n     pub docs: String,\n-    pub sig: Signature,\n+    pub sig: Option<Signature>,\n     pub attributes: Vec<Attribute>,\n }\n \n@@ -165,7 +165,7 @@ pub struct FunctionData {\n     pub visibility: Visibility,\n     pub parent: Option<DefId>,\n     pub docs: String,\n-    pub sig: Signature,\n+    pub sig: Option<Signature>,\n     pub attributes: Vec<Attribute>,\n }\n \n@@ -251,7 +251,7 @@ pub struct MethodData {\n     pub parent: Option<DefId>,\n     pub visibility: Visibility,\n     pub docs: String,\n-    pub sig: Signature,\n+    pub sig: Option<Signature>,\n     pub attributes: Vec<Attribute>,\n }\n \n@@ -292,7 +292,7 @@ pub struct StructData {\n     pub fields: Vec<NodeId>,\n     pub visibility: Visibility,\n     pub docs: String,\n-    pub sig: Signature,\n+    pub sig: Option<Signature>,\n     pub attributes: Vec<Attribute>,\n }\n \n@@ -307,7 +307,7 @@ pub struct StructVariantData {\n     pub scope: NodeId,\n     pub parent: Option<DefId>,\n     pub docs: String,\n-    pub sig: Signature,\n+    pub sig: Option<Signature>,\n     pub attributes: Vec<Attribute>,\n }\n \n@@ -322,7 +322,7 @@ pub struct TraitData {\n     pub items: Vec<NodeId>,\n     pub visibility: Visibility,\n     pub docs: String,\n-    pub sig: Signature,\n+    pub sig: Option<Signature>,\n     pub attributes: Vec<Attribute>,\n }\n \n@@ -337,7 +337,7 @@ pub struct TupleVariantData {\n     pub scope: NodeId,\n     pub parent: Option<DefId>,\n     pub docs: String,\n-    pub sig: Signature,\n+    pub sig: Option<Signature>,\n     pub attributes: Vec<Attribute>,\n }\n \n@@ -419,28 +419,3 @@ pub struct VariableRefData {\n     pub scope: NodeId,\n     pub ref_id: DefId,\n }\n-\n-\n-/// Encodes information about the signature of a definition. This should have\n-/// enough information to create a nice display about a definition without\n-/// access to the source code.\n-#[derive(Clone, Debug)]\n-pub struct Signature {\n-    pub span: Span,\n-    pub text: String,\n-    // These identify the main identifier for the defintion as byte offsets into\n-    // `text`. E.g., of `foo` in `pub fn foo(...)`\n-    pub ident_start: usize,\n-    pub ident_end: usize,\n-    pub defs: Vec<SigElement>,\n-    pub refs: Vec<SigElement>,\n-}\n-\n-/// An element of a signature. `start` and `end` are byte offsets into the `text`\n-/// of the parent `Signature`.\n-#[derive(Clone, Debug)]\n-pub struct SigElement {\n-    pub id: DefId,\n-    pub start: usize,\n-    pub end: usize,\n-}"}, {"sha": "ea346d99e31b5a4ed47be3725d9a1cfb71001204", "filename": "src/librustc_save_analysis/dump_visitor.rs", "status": "modified", "additions": 40, "deletions": 40, "changes": 80, "blob_url": "https://github.com/rust-lang/rust/blob/e7fffa2211f3145e444c2d90321a0e39d6150b42/src%2Flibrustc_save_analysis%2Fdump_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7fffa2211f3145e444c2d90321a0e39d6150b42/src%2Flibrustc_save_analysis%2Fdump_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_save_analysis%2Fdump_visitor.rs?ref=e7fffa2211f3145e444c2d90321a0e39d6150b42", "patch": "@@ -48,12 +48,13 @@ use syntax::ptr::P;\n use syntax::codemap::Spanned;\n use syntax_pos::*;\n \n-use super::{escape, generated_code, SaveContext, PathCollector, docs_for_attrs};\n-use super::data::*;\n-use super::dump::Dump;\n-use super::external_data::{Lower, make_def_id};\n-use super::span_utils::SpanUtils;\n-use super::recorder;\n+use {escape, generated_code, SaveContext, PathCollector, docs_for_attrs};\n+use data::*;\n+use dump::Dump;\n+use external_data::{Lower, make_def_id};\n+use recorder;\n+use span_utils::SpanUtils;\n+use sig;\n \n use rls_data::ExternalCrateData;\n \n@@ -391,13 +392,13 @@ impl<'l, 'tcx: 'l, 'll, D: Dump + 'll> DumpVisitor<'l, 'tcx, 'll, D> {\n                       sig: &'l ast::MethodSig,\n                       body: Option<&'l ast::Block>,\n                       id: ast::NodeId,\n-                      name: ast::Name,\n+                      name: ast::Ident,\n                       vis: Visibility,\n                       attrs: &'l [Attribute],\n                       span: Span) {\n         debug!(\"process_method: {}:{}\", id, name);\n \n-        if let Some(method_data) = self.save_ctxt.get_method_data(id, name, span) {\n+        if let Some(method_data) = self.save_ctxt.get_method_data(id, name.name, span) {\n \n             let sig_str = ::make_signature(&sig.decl, &sig.generics);\n             if body.is_some() {\n@@ -423,7 +424,7 @@ impl<'l, 'tcx: 'l, 'll, D: Dump + 'll> DumpVisitor<'l, 'tcx, 'll, D> {\n                             Some(id) => {\n                                 for item in self.tcx.associated_items(id) {\n                                     if item.kind == ty::AssociatedKind::Method {\n-                                        if item.name == name {\n+                                        if item.name == name.name {\n                                             decl_id = Some(item.def_id);\n                                             break;\n                                         }\n@@ -455,7 +456,7 @@ impl<'l, 'tcx: 'l, 'll, D: Dump + 'll> DumpVisitor<'l, 'tcx, 'll, D> {\n                     parent: trait_id,\n                     visibility: vis,\n                     docs: docs_for_attrs(attrs),\n-                    sig: method_data.sig,\n+                    sig: sig::method_signature(id, name, sig, &self.save_ctxt),\n                     attributes: attrs.to_vec(),\n                 }.lower(self.tcx));\n             }\n@@ -580,13 +581,14 @@ impl<'l, 'tcx: 'l, 'll, D: Dump + 'll> DumpVisitor<'l, 'tcx, 'll, D> {\n                            name: ast::Name,\n                            span: Span,\n                            typ: &'l ast::Ty,\n-                           expr: &'l ast::Expr,\n+                           expr: Option<&'l ast::Expr>,\n                            parent_id: DefId,\n                            vis: Visibility,\n                            attrs: &'l [Attribute]) {\n         let qualname = format!(\"::{}\", self.tcx.node_path_str(id));\n \n         let sub_span = self.span.sub_span_after_keyword(span, keywords::Const);\n+        let value = expr.map(|e| self.span.snippet(e.span)).unwrap_or(String::new());\n \n         if !self.span.filter_generated(sub_span, span) {\n             self.dumper.variable(VariableData {\n@@ -595,20 +597,22 @@ impl<'l, 'tcx: 'l, 'll, D: Dump + 'll> DumpVisitor<'l, 'tcx, 'll, D> {\n                 id: id,\n                 name: name.to_string(),\n                 qualname: qualname,\n-                value: self.span.snippet(expr.span),\n+                value: value,\n                 type_value: ty_to_string(&typ),\n                 scope: self.cur_scope,\n                 parent: Some(parent_id),\n                 visibility: vis,\n                 docs: docs_for_attrs(attrs),\n-                sig: None,\n+                sig: sig::assoc_const_signature(id, name, typ, expr, &self.save_ctxt),\n                 attributes: attrs.to_vec(),\n             }.lower(self.tcx));\n         }\n \n         // walk type and init value\n         self.visit_ty(typ);\n-        self.visit_expr(expr);\n+        if let Some(expr) = expr {\n+            self.visit_expr(expr);\n+        }\n     }\n \n     // FIXME tuple structs should generate tuple-specific data.\n@@ -646,7 +650,7 @@ impl<'l, 'tcx: 'l, 'll, D: Dump + 'll> DumpVisitor<'l, 'tcx, 'll, D> {\n                 fields: fields,\n                 visibility: From::from(&item.vis),\n                 docs: docs_for_attrs(&item.attrs),\n-                sig: self.save_ctxt.sig_base(item),\n+                sig: sig::item_signature(item, &self.save_ctxt),\n                 attributes: item.attrs.clone(),\n             }.lower(self.tcx));\n         }\n@@ -679,18 +683,6 @@ impl<'l, 'tcx: 'l, 'll, D: Dump + 'll> DumpVisitor<'l, 'tcx, 'll, D> {\n             qualname.push_str(\"::\");\n             qualname.push_str(&name);\n \n-            let text = self.span.signature_string_for_span(variant.span);\n-            let ident_start = text.find(&name).unwrap();\n-            let ident_end = ident_start + name.len();\n-            let sig = Signature {\n-                span: variant.span,\n-                text: text,\n-                ident_start: ident_start,\n-                ident_end: ident_end,\n-                defs: vec![],\n-                refs: vec![],\n-            };\n-\n             match variant.node.data {\n                 ast::VariantData::Struct(ref fields, _) => {\n                     let sub_span = self.span.span_for_first_ident(variant.span);\n@@ -712,7 +704,7 @@ impl<'l, 'tcx: 'l, 'll, D: Dump + 'll> DumpVisitor<'l, 'tcx, 'll, D> {\n                             scope: enum_data.scope,\n                             parent: Some(make_def_id(item.id, &self.tcx.hir)),\n                             docs: docs_for_attrs(&variant.node.attrs),\n-                            sig: sig,\n+                            sig: sig::variant_signature(variant, &self.save_ctxt),\n                             attributes: variant.node.attrs.clone(),\n                         }.lower(self.tcx));\n                     }\n@@ -739,7 +731,7 @@ impl<'l, 'tcx: 'l, 'll, D: Dump + 'll> DumpVisitor<'l, 'tcx, 'll, D> {\n                             scope: enum_data.scope,\n                             parent: Some(make_def_id(item.id, &self.tcx.hir)),\n                             docs: docs_for_attrs(&variant.node.attrs),\n-                            sig: sig,\n+                            sig: sig::variant_signature(variant, &self.save_ctxt),\n                             attributes: variant.node.attrs.clone(),\n                         }.lower(self.tcx));\n                     }\n@@ -811,7 +803,7 @@ impl<'l, 'tcx: 'l, 'll, D: Dump + 'll> DumpVisitor<'l, 'tcx, 'll, D> {\n                 items: methods.iter().map(|i| i.id).collect(),\n                 visibility: From::from(&item.vis),\n                 docs: docs_for_attrs(&item.attrs),\n-                sig: self.save_ctxt.sig_base(item),\n+                sig: sig::item_signature(item, &self.save_ctxt),\n                 attributes: item.attrs.clone(),\n             }.lower(self.tcx));\n         }\n@@ -1133,12 +1125,12 @@ impl<'l, 'tcx: 'l, 'll, D: Dump + 'll> DumpVisitor<'l, 'tcx, 'll, D> {\n     fn process_trait_item(&mut self, trait_item: &'l ast::TraitItem, trait_id: DefId) {\n         self.process_macro_use(trait_item.span, trait_item.id);\n         match trait_item.node {\n-            ast::TraitItemKind::Const(ref ty, Some(ref expr)) => {\n+            ast::TraitItemKind::Const(ref ty, ref expr) => {\n                 self.process_assoc_const(trait_item.id,\n                                          trait_item.ident.name,\n                                          trait_item.span,\n                                          &ty,\n-                                         &expr,\n+                                         expr.as_ref().map(|e| &**e),\n                                          trait_id,\n                                          Visibility::Public,\n                                          &trait_item.attrs);\n@@ -1147,12 +1139,12 @@ impl<'l, 'tcx: 'l, 'll, D: Dump + 'll> DumpVisitor<'l, 'tcx, 'll, D> {\n                 self.process_method(sig,\n                                     body.as_ref().map(|x| &**x),\n                                     trait_item.id,\n-                                    trait_item.ident.name,\n+                                    trait_item.ident,\n                                     Visibility::Public,\n                                     &trait_item.attrs,\n                                     trait_item.span);\n             }\n-            ast::TraitItemKind::Type(ref _bounds, ref default_ty) => {\n+            ast::TraitItemKind::Type(ref bounds, ref default_ty) => {\n                 // FIXME do something with _bounds (for type refs)\n                 let name = trait_item.ident.name.to_string();\n                 let qualname = format!(\"::{}\", self.tcx.node_path_str(trait_item.id));\n@@ -1168,7 +1160,11 @@ impl<'l, 'tcx: 'l, 'll, D: Dump + 'll> DumpVisitor<'l, 'tcx, 'll, D> {\n                         visibility: Visibility::Public,\n                         parent: Some(trait_id),\n                         docs: docs_for_attrs(&trait_item.attrs),\n-                        sig: None,\n+                        sig: sig::assoc_type_signature(trait_item.id,\n+                                                       trait_item.ident,\n+                                                       Some(bounds),\n+                                                       default_ty.as_ref().map(|ty| &**ty),\n+                                                       &self.save_ctxt),\n                         attributes: trait_item.attrs.clone(),\n                     }.lower(self.tcx));\n                 }\n@@ -1177,7 +1173,6 @@ impl<'l, 'tcx: 'l, 'll, D: Dump + 'll> DumpVisitor<'l, 'tcx, 'll, D> {\n                     self.visit_ty(default_ty)\n                 }\n             }\n-            ast::TraitItemKind::Const(ref ty, None) => self.visit_ty(ty),\n             ast::TraitItemKind::Macro(_) => {}\n         }\n     }\n@@ -1190,7 +1185,7 @@ impl<'l, 'tcx: 'l, 'll, D: Dump + 'll> DumpVisitor<'l, 'tcx, 'll, D> {\n                                          impl_item.ident.name,\n                                          impl_item.span,\n                                          &ty,\n-                                         &expr,\n+                                         Some(expr),\n                                          impl_id,\n                                          From::from(&impl_item.vis),\n                                          &impl_item.attrs);\n@@ -1199,12 +1194,17 @@ impl<'l, 'tcx: 'l, 'll, D: Dump + 'll> DumpVisitor<'l, 'tcx, 'll, D> {\n                 self.process_method(sig,\n                                     Some(body),\n                                     impl_item.id,\n-                                    impl_item.ident.name,\n+                                    impl_item.ident,\n                                     From::from(&impl_item.vis),\n                                     &impl_item.attrs,\n                                     impl_item.span);\n             }\n-            ast::ImplItemKind::Type(ref ty) => self.visit_ty(ty),\n+            ast::ImplItemKind::Type(ref ty) => {\n+                // FIXME uses of the assoc type should ideally point to this\n+                // 'def' and the name here should be a ref to the def in the\n+                // trait.\n+                self.visit_ty(ty)\n+            }\n             ast::ImplItemKind::Macro(_) => {}\n         }\n     }\n@@ -1369,7 +1369,7 @@ impl<'l, 'tcx: 'l, 'll, D: Dump +'ll> Visitor<'l> for DumpVisitor<'l, 'tcx, 'll,\n                         visibility: From::from(&item.vis),\n                         parent: None,\n                         docs: docs_for_attrs(&item.attrs),\n-                        sig: Some(self.save_ctxt.sig_base(item)),\n+                        sig: sig::item_signature(item, &self.save_ctxt),\n                         attributes: item.attrs.clone(),\n                     }.lower(self.tcx));\n                 }"}, {"sha": "245a3bcc61795bf32be467652e67ce2696839f92", "filename": "src/librustc_save_analysis/external_data.rs", "status": "modified", "additions": 19, "deletions": 46, "changes": 65, "blob_url": "https://github.com/rust-lang/rust/blob/e7fffa2211f3145e444c2d90321a0e39d6150b42/src%2Flibrustc_save_analysis%2Fexternal_data.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7fffa2211f3145e444c2d90321a0e39d6150b42/src%2Flibrustc_save_analysis%2Fexternal_data.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_save_analysis%2Fexternal_data.rs?ref=e7fffa2211f3145e444c2d90321a0e39d6150b42", "patch": "@@ -16,9 +16,9 @@ use syntax::codemap::CodeMap;\n use syntax::print::pprust;\n use syntax_pos::Span;\n \n-use data::{self, Visibility, SigElement};\n+use data::{self, Visibility};\n \n-use rls_data::{SpanData, CratePreludeData, Attribute};\n+use rls_data::{SpanData, CratePreludeData, Attribute, Signature};\n use rls_span::{Column, Row};\n \n // FIXME: this should be pub(crate), but the current snapshot doesn't allow it yet\n@@ -103,7 +103,7 @@ pub struct EnumData {\n     pub variants: Vec<DefId>,\n     pub visibility: Visibility,\n     pub docs: String,\n-    pub sig: Signature,\n+    pub sig: Option<Signature>,\n     pub attributes: Vec<Attribute>,\n }\n \n@@ -121,7 +121,7 @@ impl Lower for data::EnumData {\n             variants: self.variants.into_iter().map(|id| make_def_id(id, &tcx.hir)).collect(),\n             visibility: self.visibility,\n             docs: self.docs,\n-            sig: self.sig.lower(tcx),\n+            sig: self.sig,\n             attributes: self.attributes.lower(tcx),\n         }\n     }\n@@ -186,7 +186,7 @@ pub struct FunctionData {\n     pub visibility: Visibility,\n     pub parent: Option<DefId>,\n     pub docs: String,\n-    pub sig: Signature,\n+    pub sig: Option<Signature>,\n     pub attributes: Vec<Attribute>,\n }\n \n@@ -205,7 +205,7 @@ impl Lower for data::FunctionData {\n             visibility: self.visibility,\n             parent: self.parent,\n             docs: self.docs,\n-            sig: self.sig.lower(tcx),\n+            sig: self.sig,\n             attributes: self.attributes.lower(tcx),\n         }\n     }\n@@ -355,7 +355,7 @@ pub struct MethodData {\n     pub visibility: Visibility,\n     pub parent: Option<DefId>,\n     pub docs: String,\n-    pub sig: Signature,\n+    pub sig: Option<Signature>,\n     pub attributes: Vec<Attribute>,\n }\n \n@@ -374,7 +374,7 @@ impl Lower for data::MethodData {\n             visibility: self.visibility,\n             parent: self.parent,\n             docs: self.docs,\n-            sig: self.sig.lower(tcx),\n+            sig: self.sig,\n             attributes: self.attributes.lower(tcx),\n         }\n     }\n@@ -410,7 +410,7 @@ impl Lower for data::ModData {\n             items: self.items.into_iter().map(|id| make_def_id(id, &tcx.hir)).collect(),\n             visibility: self.visibility,\n             docs: self.docs,\n-            sig: self.sig.map(|s| s.lower(tcx)),\n+            sig: self.sig,\n             attributes: self.attributes.lower(tcx),\n         }\n     }\n@@ -450,7 +450,7 @@ pub struct StructData {\n     pub fields: Vec<DefId>,\n     pub visibility: Visibility,\n     pub docs: String,\n-    pub sig: Signature,\n+    pub sig: Option<Signature>,\n     pub attributes: Vec<Attribute>,\n }\n \n@@ -469,7 +469,7 @@ impl Lower for data::StructData {\n             fields: self.fields.into_iter().map(|id| make_def_id(id, &tcx.hir)).collect(),\n             visibility: self.visibility,\n             docs: self.docs,\n-            sig: self.sig.lower(tcx),\n+            sig: self.sig,\n             attributes: self.attributes.lower(tcx),\n         }\n     }\n@@ -486,7 +486,7 @@ pub struct StructVariantData {\n     pub scope: DefId,\n     pub parent: Option<DefId>,\n     pub docs: String,\n-    pub sig: Signature,\n+    pub sig: Option<Signature>,\n     pub attributes: Vec<Attribute>,\n }\n \n@@ -504,7 +504,7 @@ impl Lower for data::StructVariantData {\n             scope: make_def_id(self.scope, &tcx.hir),\n             parent: self.parent,\n             docs: self.docs,\n-            sig: self.sig.lower(tcx),\n+            sig: self.sig,\n             attributes: self.attributes.lower(tcx),\n         }\n     }\n@@ -521,7 +521,7 @@ pub struct TraitData {\n     pub items: Vec<DefId>,\n     pub visibility: Visibility,\n     pub docs: String,\n-    pub sig: Signature,\n+    pub sig: Option<Signature>,\n     pub attributes: Vec<Attribute>,\n }\n \n@@ -539,7 +539,7 @@ impl Lower for data::TraitData {\n             items: self.items.into_iter().map(|id| make_def_id(id, &tcx.hir)).collect(),\n             visibility: self.visibility,\n             docs: self.docs,\n-            sig: self.sig.lower(tcx),\n+            sig: self.sig,\n             attributes: self.attributes.lower(tcx),\n         }\n     }\n@@ -556,7 +556,7 @@ pub struct TupleVariantData {\n     pub scope: DefId,\n     pub parent: Option<DefId>,\n     pub docs: String,\n-    pub sig: Signature,\n+    pub sig: Option<Signature>,\n     pub attributes: Vec<Attribute>,\n }\n \n@@ -574,7 +574,7 @@ impl Lower for data::TupleVariantData {\n             scope: make_def_id(self.scope, &tcx.hir),\n             parent: self.parent,\n             docs: self.docs,\n-            sig: self.sig.lower(tcx),\n+            sig: self.sig,\n             attributes: self.attributes.lower(tcx),\n         }\n     }\n@@ -608,7 +608,7 @@ impl Lower for data::TypeDefData {\n             visibility: self.visibility,\n             parent: self.parent,\n             docs: self.docs,\n-            sig: self.sig.map(|s| s.lower(tcx)),\n+            sig: self.sig,\n             attributes: self.attributes.lower(tcx),\n         }\n     }\n@@ -718,7 +718,7 @@ impl Lower for data::VariableData {\n             parent: self.parent,\n             visibility: self.visibility,\n             docs: self.docs,\n-            sig: self.sig.map(|s| s.lower(tcx)),\n+            sig: self.sig,\n             attributes: self.attributes.lower(tcx),\n         }\n     }\n@@ -746,30 +746,3 @@ impl Lower for data::VariableRefData {\n         }\n     }\n }\n-\n-#[derive(Clone, Debug)]\n-pub struct Signature {\n-    pub span: SpanData,\n-    pub text: String,\n-    // These identify the main identifier for the defintion as byte offsets into\n-    // `text`. E.g., of `foo` in `pub fn foo(...)`\n-    pub ident_start: usize,\n-    pub ident_end: usize,\n-    pub defs: Vec<SigElement>,\n-    pub refs: Vec<SigElement>,\n-}\n-\n-impl Lower for data::Signature {\n-    type Target = Signature;\n-\n-    fn lower(self, tcx: TyCtxt) -> Signature {\n-        Signature {\n-            span: span_from_span(self.span, tcx.sess.codemap()),\n-            text: self.text,\n-            ident_start: self.ident_start,\n-            ident_end: self.ident_end,\n-            defs: self.defs,\n-            refs: self.refs,\n-        }\n-    }\n-}"}, {"sha": "bddee6460ff9ceff438f1f38da0a2333e463481a", "filename": "src/librustc_save_analysis/json_api_dumper.rs", "status": "modified", "additions": 12, "deletions": 10, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/e7fffa2211f3145e444c2d90321a0e39d6150b42/src%2Flibrustc_save_analysis%2Fjson_api_dumper.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7fffa2211f3145e444c2d90321a0e39d6150b42/src%2Flibrustc_save_analysis%2Fjson_api_dumper.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_save_analysis%2Fjson_api_dumper.rs?ref=e7fffa2211f3145e444c2d90321a0e39d6150b42", "patch": "@@ -15,9 +15,9 @@ use rustc_serialize::json::as_json;\n use external_data::*;\n use data::{VariableKind, Visibility};\n use dump::Dump;\n-use json_dumper::id_from_def_id;\n+use id_from_def_id;\n \n-use rls_data::{Analysis, Import, ImportKind, Def, DefKind, CratePreludeData};\n+use rls_data::{Analysis, Import, ImportKind, Def, DefKind, CratePreludeData, Format};\n \n \n // A dumper to dump a restricted set of JSON information, designed for use with\n@@ -33,7 +33,9 @@ pub struct JsonApiDumper<'b, W: Write + 'b> {\n \n impl<'b, W: Write> JsonApiDumper<'b, W> {\n     pub fn new(writer: &'b mut W) -> JsonApiDumper<'b, W> {\n-        JsonApiDumper { output: writer, result: Analysis::new() }\n+        let mut result = Analysis::new();\n+        result.kind = Format::JsonApi;\n+        JsonApiDumper { output: writer, result }\n     }\n }\n \n@@ -133,7 +135,7 @@ impl Into<Option<Def>> for EnumData {\n                 children: self.variants.into_iter().map(|id| id_from_def_id(id)).collect(),\n                 decl_id: None,\n                 docs: self.docs,\n-                sig: Some(self.sig.into()),\n+                sig: self.sig,\n                 attributes: vec![],\n             }),\n             _ => None,\n@@ -154,7 +156,7 @@ impl Into<Option<Def>> for TupleVariantData {\n             children: vec![],\n             decl_id: None,\n             docs: self.docs,\n-            sig: Some(self.sig.into()),\n+            sig: self.sig,\n             attributes: vec![],\n         })\n     }\n@@ -172,7 +174,7 @@ impl Into<Option<Def>> for StructVariantData {\n             children: vec![],\n             decl_id: None,\n             docs: self.docs,\n-            sig: Some(self.sig.into()),\n+            sig: self.sig,\n             attributes: vec![],\n         })\n     }\n@@ -191,7 +193,7 @@ impl Into<Option<Def>> for StructData {\n             children: self.fields.into_iter().map(|id| id_from_def_id(id)).collect(),\n             decl_id: None,\n             docs: self.docs,\n-            sig: Some(self.sig.into()),\n+            sig: self.sig,\n             attributes: vec![],\n         }),\n             _ => None,\n@@ -212,7 +214,7 @@ impl Into<Option<Def>> for TraitData {\n                 parent: None,\n                 decl_id: None,\n                 docs: self.docs,\n-                sig: Some(self.sig.into()),\n+                sig: self.sig,\n                 attributes: vec![],\n             }),\n             _ => None,\n@@ -233,7 +235,7 @@ impl Into<Option<Def>> for FunctionData {\n                 parent: self.parent.map(|id| id_from_def_id(id)),\n                 decl_id: None,\n                 docs: self.docs,\n-                sig: Some(self.sig.into()),\n+                sig: self.sig,\n                 attributes: vec![],\n             }),\n             _ => None,\n@@ -254,7 +256,7 @@ impl Into<Option<Def>> for MethodData {\n                 parent: self.parent.map(|id| id_from_def_id(id)),\n                 decl_id: self.decl_id.map(|id| id_from_def_id(id)),\n                 docs: self.docs,\n-                sig: Some(self.sig.into()),\n+                sig: self.sig,\n                 attributes: vec![],\n             }),\n             _ => None,"}, {"sha": "58df612c687c3afdd8eeaa10bc53ae18ce08d11c", "filename": "src/librustc_save_analysis/json_dumper.rs", "status": "modified", "additions": 12, "deletions": 45, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/e7fffa2211f3145e444c2d90321a0e39d6150b42/src%2Flibrustc_save_analysis%2Fjson_dumper.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7fffa2211f3145e444c2d90321a0e39d6150b42/src%2Flibrustc_save_analysis%2Fjson_dumper.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_save_analysis%2Fjson_dumper.rs?ref=e7fffa2211f3145e444c2d90321a0e39d6150b42", "patch": "@@ -10,17 +10,16 @@\n \n use std::io::Write;\n \n-use rustc::hir::def_id::DefId;\n use rustc_serialize::json::as_json;\n \n use rls_data::{self, Id, Analysis, Import, ImportKind, Def, DefKind, Ref, RefKind, MacroRef,\n-               Relation, RelationKind, Signature, SigElement, CratePreludeData};\n+               Relation, RelationKind, CratePreludeData};\n use rls_span::{Column, Row};\n \n-use external_data;\n use external_data::*;\n-use data::{self, VariableKind};\n+use data::VariableKind;\n use dump::Dump;\n+use id_from_def_id;\n \n pub struct JsonDumper<O: DumpOutput> {\n     result: Analysis,\n@@ -121,7 +120,7 @@ impl<'b, O: DumpOutput + 'b> Dump for JsonDumper<O> {\n             children: data.items.into_iter().map(|id| id_from_def_id(id)).collect(),\n             decl_id: None,\n             docs: data.docs,\n-            sig: data.sig.map(|s| s.into()),\n+            sig: data.sig,\n             attributes: data.attributes.into_iter().map(|a| a.into()).collect(),\n         };\n         if def.span.file_name.to_str().unwrap() != def.value {\n@@ -164,15 +163,6 @@ impl<'b, O: DumpOutput + 'b> Dump for JsonDumper<O> {\n // method, but not the supplied method). In both cases, we are currently\n // ignoring it.\n \n-// DefId::index is a newtype and so the JSON serialisation is ugly. Therefore\n-// we use our own Id which is the same, but without the newtype.\n-pub fn id_from_def_id(id: DefId) -> Id {\n-    Id {\n-        krate: id.krate.as_u32(),\n-        index: id.index.as_u32(),\n-    }\n-}\n-\n impl Into<Import> for ExternCrateData {\n     fn into(self) -> Import {\n         Import {\n@@ -220,7 +210,7 @@ impl Into<Def> for EnumData {\n             children: self.variants.into_iter().map(|id| id_from_def_id(id)).collect(),\n             decl_id: None,\n             docs: self.docs,\n-            sig: Some(self.sig.into()),\n+            sig: self.sig,\n             attributes: self.attributes,\n         }\n     }\n@@ -239,7 +229,7 @@ impl Into<Def> for TupleVariantData {\n             children: vec![],\n             decl_id: None,\n             docs: self.docs,\n-            sig: Some(self.sig.into()),\n+            sig: self.sig,\n             attributes: self.attributes,\n         }\n     }\n@@ -257,7 +247,7 @@ impl Into<Def> for StructVariantData {\n             children: vec![],\n             decl_id: None,\n             docs: self.docs,\n-            sig: Some(self.sig.into()),\n+            sig: self.sig,\n             attributes: self.attributes,\n         }\n     }\n@@ -275,7 +265,7 @@ impl Into<Def> for StructData {\n             children: self.fields.into_iter().map(|id| id_from_def_id(id)).collect(),\n             decl_id: None,\n             docs: self.docs,\n-            sig: Some(self.sig.into()),\n+            sig: self.sig,\n             attributes: self.attributes,\n         }\n     }\n@@ -293,7 +283,7 @@ impl Into<Def> for TraitData {\n             children: self.items.into_iter().map(|id| id_from_def_id(id)).collect(),\n             decl_id: None,\n             docs: self.docs,\n-            sig: Some(self.sig.into()),\n+            sig: self.sig,\n             attributes: self.attributes,\n         }\n     }\n@@ -311,7 +301,7 @@ impl Into<Def> for FunctionData {\n             children: vec![],\n             decl_id: None,\n             docs: self.docs,\n-            sig: Some(self.sig.into()),\n+            sig: self.sig,\n             attributes: self.attributes,\n         }\n     }\n@@ -329,7 +319,7 @@ impl Into<Def> for MethodData {\n             children: vec![],\n             decl_id: self.decl_id.map(|id| id_from_def_id(id)),\n             docs: self.docs,\n-            sig: Some(self.sig.into()),\n+            sig: self.sig,\n             attributes: self.attributes,\n         }\n     }\n@@ -365,7 +355,7 @@ impl Into<Def> for TypeDefData {\n             children: vec![],\n             decl_id: None,\n             docs: String::new(),\n-            sig: self.sig.map(|s| s.into()),\n+            sig: self.sig,\n             attributes: self.attributes,\n         }\n     }\n@@ -480,26 +470,3 @@ impl Into<Relation> for InheritanceData {\n         }\n     }\n }\n-\n-impl Into<Signature> for external_data::Signature {\n-    fn into(self) -> Signature {\n-        Signature {\n-            span: self.span,\n-            text: self.text,\n-            ident_start: self.ident_start,\n-            ident_end: self.ident_end,\n-            defs: self.defs.into_iter().map(|s| s.into()).collect(),\n-            refs: self.refs.into_iter().map(|s| s.into()).collect(),\n-        }\n-    }\n-}\n-\n-impl Into<SigElement> for data::SigElement {\n-    fn into(self) -> SigElement {\n-        SigElement {\n-            id: id_from_def_id(self.id),\n-            start: self.start,\n-            end: self.end,\n-        }\n-    }\n-}"}, {"sha": "4802494f08ead317b242dff8b8cceb95872dd3fd", "filename": "src/librustc_save_analysis/lib.rs", "status": "modified", "additions": 31, "deletions": 68, "changes": 99, "blob_url": "https://github.com/rust-lang/rust/blob/e7fffa2211f3145e444c2d90321a0e39d6150b42/src%2Flibrustc_save_analysis%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7fffa2211f3145e444c2d90321a0e39d6150b42/src%2Flibrustc_save_analysis%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_save_analysis%2Flib.rs?ref=e7fffa2211f3145e444c2d90321a0e39d6150b42", "patch": "@@ -44,6 +44,7 @@ mod dump_visitor;\n pub mod external_data;\n #[macro_use]\n pub mod span_utils;\n+mod sig;\n \n use rustc::hir;\n use rustc::hir::def::Def;\n@@ -140,7 +141,7 @@ impl<'l, 'tcx: 'l> SaveContext<'l, 'tcx> {\n                     visibility: From::from(&item.vis),\n                     parent: None,\n                     docs: docs_for_attrs(&item.attrs),\n-                    sig: self.sig_base_extern(item),\n+                    sig: sig::foreign_item_signature(item, self),\n                     attributes: item.attrs.clone(),\n                 }))\n             }\n@@ -160,7 +161,7 @@ impl<'l, 'tcx: 'l> SaveContext<'l, 'tcx> {\n                     type_value: ty_to_string(ty),\n                     visibility: From::from(&item.vis),\n                     docs: docs_for_attrs(&item.attrs),\n-                    sig: Some(self.sig_base_extern(item)),\n+                    sig: sig::foreign_item_signature(item, self),\n                     attributes: item.attrs.clone(),\n                 }))\n             }\n@@ -186,7 +187,7 @@ impl<'l, 'tcx: 'l> SaveContext<'l, 'tcx> {\n                     visibility: From::from(&item.vis),\n                     parent: None,\n                     docs: docs_for_attrs(&item.attrs),\n-                    sig: self.sig_base(item),\n+                    sig: sig::item_signature(item, self),\n                     attributes: item.attrs.clone(),\n                 }))\n             }\n@@ -215,7 +216,7 @@ impl<'l, 'tcx: 'l> SaveContext<'l, 'tcx> {\n                     type_value: ty_to_string(&typ),\n                     visibility: From::from(&item.vis),\n                     docs: docs_for_attrs(&item.attrs),\n-                    sig: Some(self.sig_base(item)),\n+                    sig: sig::item_signature(item, self),\n                     attributes: item.attrs.clone(),\n                 }))\n             }\n@@ -235,7 +236,7 @@ impl<'l, 'tcx: 'l> SaveContext<'l, 'tcx> {\n                     type_value: ty_to_string(&typ),\n                     visibility: From::from(&item.vis),\n                     docs: docs_for_attrs(&item.attrs),\n-                    sig: Some(self.sig_base(item)),\n+                    sig: sig::item_signature(item, self),\n                     attributes: item.attrs.clone(),\n                 }))\n             }\n@@ -258,7 +259,7 @@ impl<'l, 'tcx: 'l> SaveContext<'l, 'tcx> {\n                     items: m.items.iter().map(|i| i.id).collect(),\n                     visibility: From::from(&item.vis),\n                     docs: docs_for_attrs(&item.attrs),\n-                    sig: Some(self.sig_base(item)),\n+                    sig: sig::item_signature(item, self),\n                     attributes: item.attrs.clone(),\n                 }))\n             }\n@@ -282,7 +283,7 @@ impl<'l, 'tcx: 'l> SaveContext<'l, 'tcx> {\n                     variants: def.variants.iter().map(|v| v.node.data.id()).collect(),\n                     visibility: From::from(&item.vis),\n                     docs: docs_for_attrs(&item.attrs),\n-                    sig: self.sig_base(item),\n+                    sig: sig::item_signature(item, self),\n                     attributes: item.attrs.clone(),\n                 }))\n             }\n@@ -346,18 +347,6 @@ impl<'l, 'tcx: 'l> SaveContext<'l, 'tcx> {\n             let def_id = self.tcx.hir.local_def_id(field.id);\n             let typ = self.tcx.type_of(def_id).to_string();\n \n-            let span = field.span;\n-            let text = self.span_utils.snippet(field.span);\n-            let ident_start = text.find(&name).unwrap();\n-            let ident_end = ident_start + name.len();\n-            let sig = Signature {\n-                span: span,\n-                text: text,\n-                ident_start: ident_start,\n-                ident_end: ident_end,\n-                defs: vec![],\n-                refs: vec![],\n-            };\n             Some(VariableData {\n                 id: field.id,\n                 kind: VariableKind::Field,\n@@ -370,7 +359,7 @@ impl<'l, 'tcx: 'l> SaveContext<'l, 'tcx> {\n                 type_value: typ,\n                 visibility: From::from(&field.vis),\n                 docs: docs_for_attrs(&field.attrs),\n-                sig: Some(sig),\n+                sig: sig::field_signature(field, self),\n                 attributes: field.attrs.clone(),\n             })\n         } else {\n@@ -380,8 +369,11 @@ impl<'l, 'tcx: 'l> SaveContext<'l, 'tcx> {\n \n     // FIXME would be nice to take a MethodItem here, but the ast provides both\n     // trait and impl flavours, so the caller must do the disassembly.\n-    pub fn get_method_data(&self, id: ast::NodeId,\n-                           name: ast::Name, span: Span) -> Option<FunctionData> {\n+    pub fn get_method_data(&self,\n+                           id: ast::NodeId,\n+                           name: ast::Name,\n+                           span: Span)\n+                           -> Option<FunctionData> {\n         // The qualname for a method is the trait name or name of the struct in an impl in\n         // which the method is declared in, followed by the method's name.\n         let (qualname, parent_scope, decl_id, vis, docs, attributes) =\n@@ -459,22 +451,9 @@ impl<'l, 'tcx: 'l> SaveContext<'l, 'tcx> {\n         let sub_span = self.span_utils.sub_span_after_keyword(span, keywords::Fn);\n         filter!(self.span_utils, sub_span, span, None);\n \n-        let name = name.to_string();\n-        let text = self.span_utils.signature_string_for_span(span);\n-        let ident_start = text.find(&name).unwrap();\n-        let ident_end = ident_start + name.len();\n-        let sig = Signature {\n-            span: span,\n-            text: text,\n-            ident_start: ident_start,\n-            ident_end: ident_end,\n-            defs: vec![],\n-            refs: vec![],\n-        };\n-\n         Some(FunctionData {\n             id: id,\n-            name: name,\n+            name: name.to_string(),\n             qualname: qualname,\n             declaration: decl_id,\n             span: sub_span.unwrap(),\n@@ -484,7 +463,7 @@ impl<'l, 'tcx: 'l> SaveContext<'l, 'tcx> {\n             visibility: vis,\n             parent: parent_scope,\n             docs: docs,\n-            sig: sig,\n+            sig: None,\n             attributes: attributes,\n         })\n     }\n@@ -786,36 +765,6 @@ impl<'l, 'tcx: 'l> SaveContext<'l, 'tcx> {\n         }\n     }\n \n-    fn sig_base(&self, item: &ast::Item) -> Signature {\n-        let text = self.span_utils.signature_string_for_span(item.span);\n-        let name = item.ident.to_string();\n-        let ident_start = text.find(&name).expect(\"Name not in signature?\");\n-        let ident_end = ident_start + name.len();\n-        Signature {\n-            span: Span { hi: item.span.lo + BytePos(text.len() as u32), ..item.span },\n-            text: text,\n-            ident_start: ident_start,\n-            ident_end: ident_end,\n-            defs: vec![],\n-            refs: vec![],\n-        }\n-    }\n-\n-    fn sig_base_extern(&self, item: &ast::ForeignItem) -> Signature {\n-        let text = self.span_utils.signature_string_for_span(item.span);\n-        let name = item.ident.to_string();\n-        let ident_start = text.find(&name).expect(\"Name not in signature?\");\n-        let ident_end = ident_start + name.len();\n-        Signature {\n-            span: Span { hi: item.span.lo + BytePos(text.len() as u32), ..item.span },\n-            text: text,\n-            ident_start: ident_start,\n-            ident_end: ident_end,\n-            defs: vec![],\n-            refs: vec![],\n-        }\n-    }\n-\n     #[inline]\n     pub fn enclosing_scope(&self, id: NodeId) -> NodeId {\n         self.tcx.hir.get_enclosing_scope(id).unwrap_or(CRATE_NODE_ID)\n@@ -1076,6 +1025,20 @@ fn escape(s: String) -> String {\n \n // Helper function to determine if a span came from a\n // macro expansion or syntax extension.\n-pub fn generated_code(span: Span) -> bool {\n+fn generated_code(span: Span) -> bool {\n     span.ctxt != NO_EXPANSION || span == DUMMY_SP\n }\n+\n+// DefId::index is a newtype and so the JSON serialisation is ugly. Therefore\n+// we use our own Id which is the same, but without the newtype.\n+fn id_from_def_id(id: DefId) -> rls_data::Id {\n+    rls_data::Id {\n+        krate: id.krate.as_u32(),\n+        index: id.index.as_u32(),\n+    }\n+}\n+\n+fn id_from_node_id(id: NodeId, scx: &SaveContext) -> rls_data::Id {\n+    let def_id = scx.tcx.hir.local_def_id(id);\n+    id_from_def_id(def_id)\n+}"}, {"sha": "1d03ab1383af1853505fa5edc88043e94b5702fb", "filename": "src/librustc_save_analysis/sig.rs", "status": "added", "additions": 925, "deletions": 0, "changes": 925, "blob_url": "https://github.com/rust-lang/rust/blob/e7fffa2211f3145e444c2d90321a0e39d6150b42/src%2Flibrustc_save_analysis%2Fsig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7fffa2211f3145e444c2d90321a0e39d6150b42/src%2Flibrustc_save_analysis%2Fsig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_save_analysis%2Fsig.rs?ref=e7fffa2211f3145e444c2d90321a0e39d6150b42", "patch": "@@ -0,0 +1,925 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// A signature is a string representation of an item's type signature, excluding\n+// any body. It also includes ids for any defs or refs in the signature. For\n+// example:\n+//\n+// ```\n+// fn foo(x: String) {\n+//     println!(\"{}\", x);\n+// }\n+// ```\n+// The signature string is something like \"fn foo(x: String) {}\" and the signature\n+// will have defs for `foo` and `x` and a ref for `String`.\n+//\n+// All signature text should parse in the correct context (i.e., in a module or\n+// impl, etc.). Clients may want to trim trailing `{}` or `;`. The text of a\n+// signature is not guaranteed to be stable (it may improve or change as the\n+// syntax changes, or whitespace or punctuation may change). It is also likely\n+// not to be pretty - no attempt is made to prettify the text. It is recommended\n+// that clients run the text through Rustfmt.\n+//\n+// This module generates Signatures for items by walking the AST and looking up\n+// references.\n+//\n+// Signatures do not include visibility info. I'm not sure if this is a feature\n+// or an ommission (FIXME).\n+//\n+// FIXME where clauses need implementing, defs/refs in generics are mostly missing.\n+\n+use {SaveContext, id_from_def_id, id_from_node_id};\n+\n+use rls_data::{Signature, SigElement};\n+\n+use rustc::hir::def::Def;\n+use syntax::ast::{self, NodeId};\n+use syntax::print::pprust;\n+\n+\n+pub fn item_signature(item: &ast::Item, scx: &SaveContext) -> Option<Signature> {\n+    item.make(0, None, scx).ok()\n+}\n+\n+pub fn foreign_item_signature(item: &ast::ForeignItem, scx: &SaveContext) -> Option<Signature> {\n+    item.make(0, None, scx).ok()\n+}\n+\n+/// Signature for a struct or tuple field declaration.\n+/// Does not include a trailing comma.\n+pub fn field_signature(field: &ast::StructField, scx: &SaveContext) -> Option<Signature> {\n+    field.make(0, None, scx).ok()\n+}\n+\n+/// Does not include a trailing comma.\n+pub fn variant_signature(variant: &ast::Variant, scx: &SaveContext) -> Option<Signature> {\n+    variant.node.make(0, None, scx).ok()\n+}\n+\n+pub fn method_signature(id: NodeId,\n+                        ident: ast::Ident,\n+                        m: &ast::MethodSig,\n+                        scx: &SaveContext)\n+                        -> Option<Signature> {\n+    make_method_signature(id, ident, m, scx).ok()\n+}\n+\n+pub fn assoc_const_signature(id: NodeId,\n+                             ident: ast::Name,\n+                             ty: &ast::Ty,\n+                             default: Option<&ast::Expr>,\n+                             scx: &SaveContext)\n+                             -> Option<Signature> {\n+    make_assoc_const_signature(id, ident, ty, default, scx).ok()\n+}\n+\n+pub fn assoc_type_signature(id: NodeId,\n+                            ident: ast::Ident,\n+                            bounds: Option<&ast::TyParamBounds>,\n+                            default: Option<&ast::Ty>,\n+                            scx: &SaveContext)\n+                            -> Option<Signature> {\n+    make_assoc_type_signature(id, ident, bounds, default, scx).ok()\n+}\n+\n+type Result = ::std::result::Result<Signature, &'static str>;\n+\n+trait Sig {\n+    fn make(&self, offset: usize, id: Option<NodeId>, scx: &SaveContext) -> Result;\n+}\n+\n+fn extend_sig(mut sig: Signature,\n+              text: String,\n+              defs: Vec<SigElement>,\n+              refs: Vec<SigElement>)\n+              -> Signature {\n+    sig.text = text;\n+    sig.defs.extend(defs.into_iter());\n+    sig.refs.extend(refs.into_iter());\n+    sig\n+}\n+\n+fn replace_text(mut sig: Signature, text: String) -> Signature {\n+    sig.text = text;\n+    sig\n+}\n+\n+fn merge_sigs(text: String, sigs: Vec<Signature>) -> Signature {\n+    let mut result = Signature {\n+        text,\n+        defs: vec![],\n+        refs: vec![],\n+    };\n+\n+    let (defs, refs): (Vec<_>, Vec<_>) = sigs.into_iter().map(|s| (s.defs, s.refs)).unzip();\n+\n+    result.defs.extend(defs.into_iter().flat_map(|ds| ds.into_iter()));\n+    result.refs.extend(refs.into_iter().flat_map(|rs| rs.into_iter()));\n+\n+    result\n+}\n+\n+fn text_sig(text: String) -> Signature {\n+    Signature {\n+        text: text,\n+        defs: vec![],\n+        refs: vec![],\n+    }\n+}\n+\n+impl Sig for ast::Ty {\n+    fn make(&self, offset: usize, _parent_id: Option<NodeId>, scx: &SaveContext) -> Result {\n+        let id = Some(self.id);\n+        match self.node {\n+            ast::TyKind::Slice(ref ty) => {\n+                let nested = ty.make(offset + 1, id, scx)?;\n+                let text = format!(\"[{}]\", nested.text);\n+                Ok(replace_text(nested, text))\n+            }\n+            ast::TyKind::Ptr(ref mt) => {\n+                let prefix = match mt.mutbl {\n+                    ast::Mutability::Mutable => \"*mut \",\n+                    ast::Mutability::Immutable => \"*const \",\n+                };\n+                let nested = mt.ty.make(offset + prefix.len(), id, scx)?;\n+                let text = format!(\"{}{}\", prefix, nested.text);\n+                Ok(replace_text(nested, text))\n+            }\n+            ast::TyKind::Rptr(ref lifetime, ref mt) => {\n+                let mut prefix = \"&\".to_owned();\n+                if let &Some(ref l) = lifetime {\n+                    prefix.push_str(&l.ident.to_string());\n+                    prefix.push(' ');\n+                }\n+                if let ast::Mutability::Mutable = mt.mutbl {\n+                    prefix.push_str(\"mut \");\n+                };\n+\n+                let nested = mt.ty.make(offset + prefix.len(), id, scx)?;\n+                let text = format!(\"{}{}\", prefix, nested.text);\n+                Ok(replace_text(nested, text))\n+            }\n+            ast::TyKind::Never => {\n+                Ok(text_sig(\"!\".to_owned()))\n+            },\n+            ast::TyKind::Tup(ref ts) => {\n+                let mut text = \"(\".to_owned();\n+                let mut defs = vec![];\n+                let mut refs = vec![];\n+                for t in ts {\n+                    let nested = t.make(offset + text.len(), id, scx)?;\n+                    text.push_str(&nested.text);\n+                    text.push(',');\n+                    defs.extend(nested.defs.into_iter());\n+                    refs.extend(nested.refs.into_iter());\n+                }\n+                text.push(')');\n+                Ok(Signature { text, defs, refs })\n+            }\n+            ast::TyKind::Paren(ref ty) => {\n+                let nested = ty.make(offset + 1, id, scx)?;\n+                let text = format!(\"({})\", nested.text);\n+                Ok(replace_text(nested, text))\n+            }\n+            ast::TyKind::BareFn(ref f) => {\n+                let mut text = String::new();\n+                if !f.lifetimes.is_empty() {\n+                    // FIXME defs, bounds on lifetimes\n+                    text.push_str(\"for<\");\n+                    text.push_str(&f.lifetimes.iter().map(|l|\n+                        l.lifetime.ident.to_string()).collect::<Vec<_>>().join(\", \"));\n+                    text.push('>');\n+                }\n+\n+                if f.unsafety == ast::Unsafety::Unsafe {\n+                    text.push_str(\"unsafe \");\n+                }\n+                if f.abi != ::syntax::abi::Abi::Rust {\n+                    text.push_str(\"extern\");\n+                    text.push_str(&f.abi.to_string());\n+                    text.push(' ');\n+                }\n+                text.push_str(\"fn(\");\n+\n+                let mut defs = vec![];\n+                let mut refs = vec![];\n+                for i in &f.decl.inputs {\n+                    let nested = i.ty.make(offset + text.len(), Some(i.id), scx)?;\n+                    text.push_str(&nested.text);\n+                    text.push(',');\n+                    defs.extend(nested.defs.into_iter());\n+                    refs.extend(nested.refs.into_iter());\n+                }\n+                text.push(')');\n+                if let ast::FunctionRetTy::Ty(ref t) = f.decl.output {\n+                    text.push_str(\" -> \");\n+                    let nested = t.make(offset + text.len(), None, scx)?;\n+                    text.push_str(&nested.text);\n+                    text.push(',');\n+                    defs.extend(nested.defs.into_iter());\n+                    refs.extend(nested.refs.into_iter());\n+                }\n+\n+                Ok(Signature { text, defs, refs })\n+            }\n+            ast::TyKind::Path(None, ref path) => {\n+                path.make(offset, id, scx)\n+            }\n+            ast::TyKind::Path(Some(ref qself), ref path) => {\n+                let nested_ty = qself.ty.make(offset + 1, id, scx)?;\n+                let prefix = if qself.position == 0 {\n+                    format!(\"<{}>::\", nested_ty.text)\n+                } else if qself.position == 1 {\n+                    let first = pprust::path_segment_to_string(&path.segments[0]);\n+                    format!(\"<{} as {}>::\", nested_ty.text, first)\n+                } else {\n+                    // FIXME handle path instead of elipses.\n+                    format!(\"<{} as ...>::\", nested_ty.text)\n+                };\n+\n+                let name = pprust::path_segment_to_string(path.segments.last().ok_or(\"Bad path\")?);\n+                let def = scx.get_path_def(id.ok_or(\"Missing id for Path\")?);\n+                let id = id_from_def_id(def.def_id());\n+                if path.segments.len() - qself.position == 1 {\n+                    let start = offset + prefix.len();\n+                    let end = start + name.len();\n+\n+                    Ok(Signature {\n+                        text: prefix + &name,\n+                        defs: vec![],\n+                        refs: vec![SigElement { id, start, end }],\n+                    })\n+                } else {\n+                    let start = offset + prefix.len() + 5;\n+                    let end = start + name.len();\n+                    // FIXME should put the proper path in there, not elipses.\n+                    Ok(Signature {\n+                        text: prefix + \"...::\" + &name,\n+                        defs: vec![],\n+                        refs: vec![SigElement { id, start, end }],\n+                    })\n+                }\n+            }\n+            ast::TyKind::TraitObject(ref bounds) => {\n+                // FIXME recurse into bounds\n+                let nested = pprust::bounds_to_string(bounds);\n+                Ok(text_sig(nested))\n+            }\n+            ast::TyKind::ImplTrait(ref bounds) => {\n+                // FIXME recurse into bounds\n+                let nested = pprust::bounds_to_string(bounds);\n+                Ok(text_sig(format!(\"impl {}\", nested)))\n+            }\n+            ast::TyKind::Array(ref ty, ref v) => {\n+                let nested_ty = ty.make(offset + 1, id, scx)?;\n+                let expr = pprust::expr_to_string(v).replace('\\n', \" \");\n+                let text = format!(\"[{}; {}]\", nested_ty.text, expr);\n+                Ok(replace_text(nested_ty, text))\n+            }\n+            ast::TyKind::Typeof(_) |\n+            ast::TyKind::Infer |\n+            ast::TyKind::Err |\n+            ast::TyKind::ImplicitSelf |\n+            ast::TyKind::Mac(_) => Err(\"Ty\"),\n+        }\n+    }\n+}\n+\n+impl Sig for ast::Item {\n+    fn make(&self, offset: usize, _parent_id: Option<NodeId>, scx: &SaveContext) -> Result {\n+        let id = Some(self.id);\n+\n+        match self.node {\n+            ast::ItemKind::Static(ref ty, m, ref expr) => {\n+                let mut text = \"static \".to_owned();\n+                if m == ast::Mutability::Mutable {\n+                    text.push_str(\"mut \");\n+                }\n+                let name = self.ident.to_string();\n+                let defs = vec![SigElement {\n+                    id: id_from_node_id(self.id, scx),\n+                    start: offset + text.len(),\n+                    end: offset + text.len() + name.len(),\n+                }];\n+                text.push_str(&name);\n+                text.push_str(\": \");\n+\n+                let ty = ty.make(offset + text.len(), id, scx)?;\n+                text.push_str(&ty.text);\n+                text.push_str(\" = \");\n+\n+                let expr = pprust::expr_to_string(expr).replace('\\n', \" \");\n+                text.push_str(&expr);\n+                text.push(';');\n+\n+                Ok(extend_sig(ty, text, defs, vec![]))\n+            }\n+            ast::ItemKind::Const(ref ty, ref expr) => {\n+                let mut text = \"const \".to_owned();\n+                let name = self.ident.to_string();\n+                let defs = vec![SigElement {\n+                    id: id_from_node_id(self.id, scx),\n+                    start: offset + text.len(),\n+                    end: offset + text.len() + name.len(),\n+                }];\n+                text.push_str(&name);\n+                text.push_str(\": \");\n+\n+                let ty = ty.make(offset + text.len(), id, scx)?;\n+                text.push_str(&ty.text);\n+                text.push_str(\" = \");\n+\n+                let expr = pprust::expr_to_string(expr).replace('\\n', \" \");\n+                text.push_str(&expr);\n+                text.push(';');\n+\n+                Ok(extend_sig(ty, text, defs, vec![]))\n+            }\n+            ast::ItemKind::Fn(ref decl, unsafety, constness, abi, ref generics, _) => {\n+                let mut text = String::new();\n+                if constness.node == ast::Constness::Const {\n+                    text.push_str(\"const \");\n+                }\n+                if unsafety == ast::Unsafety::Unsafe {\n+                    text.push_str(\"unsafe \");\n+                }\n+                if abi != ::syntax::abi::Abi::Rust {\n+                    text.push_str(\"extern\");\n+                    text.push_str(&abi.to_string());\n+                    text.push(' ');\n+                }\n+                text.push_str(\"fn \");\n+\n+                let mut sig = name_and_generics(text,\n+                                                offset,\n+                                                generics,\n+                                                self.id,\n+                                                self.ident,\n+                                                scx)?;\n+\n+                sig.text.push('(');\n+                for i in &decl.inputs {\n+                    // FIXME shoudl descend into patterns to add defs.\n+                    sig.text.push_str(&pprust::pat_to_string(&i.pat));\n+                    sig.text.push_str(\": \");\n+                    let nested = i.ty.make(offset + sig.text.len(), Some(i.id), scx)?;\n+                    sig.text.push_str(&nested.text);\n+                    sig.text.push(',');\n+                    sig.defs.extend(nested.defs.into_iter());\n+                    sig.refs.extend(nested.refs.into_iter());\n+                }\n+                sig.text.push(')');\n+\n+                if let ast::FunctionRetTy::Ty(ref t) = decl.output {\n+                    sig.text.push_str(\" -> \");\n+                    let nested = t.make(offset + sig.text.len(), None, scx)?;\n+                    sig.text.push_str(&nested.text);\n+                    sig.defs.extend(nested.defs.into_iter());\n+                    sig.refs.extend(nested.refs.into_iter());\n+                }\n+                sig.text.push_str(\" {}\");\n+\n+                Ok(sig)\n+            }\n+            ast::ItemKind::Mod(ref _mod) => {\n+                let mut text = \"mod \".to_owned();\n+                let name = self.ident.to_string();\n+                let defs = vec![SigElement {\n+                    id: id_from_node_id(self.id, scx),\n+                    start: offset + text.len(),\n+                    end: offset + text.len() + name.len(),\n+                }];\n+                text.push_str(&name);\n+                // Could be either `mod foo;` or `mod foo { ... }`, but we'll just puck one.\n+                text.push(';');\n+\n+                Ok(Signature {\n+                    text,\n+                    defs,\n+                    refs: vec![],\n+                })\n+            }\n+            ast::ItemKind::Ty(ref ty, ref generics) => {\n+                let text = \"type \".to_owned();\n+                let mut sig = name_and_generics(text,\n+                                                offset,\n+                                                generics,\n+                                                self.id,\n+                                                self.ident,\n+                                                scx)?;\n+\n+                sig.text.push_str(\" = \");\n+                let ty = ty.make(offset + sig.text.len(), id, scx)?;\n+                sig.text.push_str(&ty.text);\n+                sig.text.push(';');\n+\n+                Ok(merge_sigs(sig.text.clone(), vec![sig, ty]))\n+            }\n+            ast::ItemKind::Enum(_, ref generics) => {\n+                let text = \"enum \".to_owned();\n+                let mut sig = name_and_generics(text,\n+                                                offset,\n+                                                generics,\n+                                                self.id,\n+                                                self.ident,\n+                                                scx)?;\n+                sig.text.push_str(\" {}\");\n+                Ok(sig)\n+            }\n+            ast::ItemKind::Struct(_, ref generics) => {\n+                let text = \"struct \".to_owned();\n+                let mut sig = name_and_generics(text,\n+                                                offset,\n+                                                generics,\n+                                                self.id,\n+                                                self.ident,\n+                                                scx)?;\n+                sig.text.push_str(\" {}\");\n+                Ok(sig)\n+            }\n+            ast::ItemKind::Union(_, ref generics) => {\n+                let text = \"union \".to_owned();\n+                let mut sig = name_and_generics(text,\n+                                                offset,\n+                                                generics,\n+                                                self.id,\n+                                                self.ident,\n+                                                scx)?;\n+                sig.text.push_str(\" {}\");\n+                Ok(sig)\n+            }\n+            ast::ItemKind::Trait(unsafety, ref generics, ref bounds, _) => {\n+                let mut text = String::new();\n+                if unsafety == ast::Unsafety::Unsafe {\n+                    text.push_str(\"unsafe \");\n+                }\n+                text.push_str(\"trait \");\n+                let mut sig = name_and_generics(text,\n+                                                offset,\n+                                                generics,\n+                                                self.id,\n+                                                self.ident,\n+                                                scx)?;\n+\n+                if !bounds.is_empty() {\n+                    sig.text.push_str(\": \");\n+                    sig.text.push_str(&pprust::bounds_to_string(bounds));\n+                }\n+                // FIXME where clause\n+                sig.text.push_str(\" {}\");\n+\n+                Ok(sig)\n+            }\n+            ast::ItemKind::DefaultImpl(unsafety, ref trait_ref) => {\n+                let mut text = String::new();\n+                if unsafety == ast::Unsafety::Unsafe {\n+                    text.push_str(\"unsafe \");\n+                }\n+                text.push_str(\"impl \");\n+                let trait_sig = trait_ref.path.make(offset + text.len(), id, scx)?;\n+                text.push_str(&trait_sig.text);\n+                text.push_str(\" for .. {}\");\n+                Ok(replace_text(trait_sig, text))\n+            }\n+            ast::ItemKind::Impl(unsafety,\n+                                polarity,\n+                                defaultness,\n+                                ref generics,\n+                                ref opt_trait,\n+                                ref ty,\n+                                _) => {\n+                let mut text = String::new();\n+                if let ast::Defaultness::Default = defaultness {\n+                    text.push_str(\"default \");\n+                }\n+                if unsafety == ast::Unsafety::Unsafe {\n+                    text.push_str(\"unsafe \");\n+                }\n+                text.push_str(\"impl\");\n+\n+                let generics_sig = generics.make(offset + text.len(), id, scx)?;\n+                text.push_str(&generics_sig.text);\n+\n+                text.push(' ');\n+\n+                let trait_sig = if let Some(ref t) = *opt_trait {\n+                    if polarity == ast::ImplPolarity::Negative {\n+                        text.push('!');\n+                    }\n+                    let trait_sig = t.path.make(offset + text.len(), id, scx)?;\n+                    text.push_str(&trait_sig.text);\n+                    text.push_str(\" for \");\n+                    trait_sig\n+                } else {\n+                    text_sig(String::new())\n+                };\n+\n+                let ty_sig = ty.make(offset + text.len(), id, scx)?;\n+                text.push_str(&ty_sig.text);\n+\n+                text.push_str(\" {}\");\n+\n+                Ok(merge_sigs(text, vec![generics_sig, trait_sig, ty_sig]))\n+\n+                // FIXME where clause\n+            }\n+            ast::ItemKind::ForeignMod(_) => Err(\"extern mod\"),\n+            ast::ItemKind::GlobalAsm(_) => Err(\"glboal asm\"),\n+            ast::ItemKind::ExternCrate(_) => Err(\"extern crate\"),\n+            // FIXME should implement this (e.g., pub use).\n+            ast::ItemKind::Use(_) => Err(\"import\"),\n+            ast::ItemKind::Mac(..) |\n+            ast::ItemKind::MacroDef(_) => Err(\"Macro\"),\n+        }\n+    }\n+}\n+\n+impl Sig for ast::Path {\n+    fn make(&self, offset: usize, id: Option<NodeId>, scx: &SaveContext) -> Result {\n+        let def = scx.get_path_def(id.ok_or(\"Missing id for Path\")?);\n+\n+        let (name, start, end) = match def {\n+            Def::Label(..)  |\n+            Def::PrimTy(..) |\n+            Def::SelfTy(..) |\n+            Def::Err => {\n+                return Ok(Signature {\n+                    text: pprust::path_to_string(self),\n+                    defs: vec![],\n+                    refs: vec![],\n+                })\n+            }\n+            Def::AssociatedConst(..) |\n+            Def::Variant(..) |\n+            Def::VariantCtor(..) => {\n+                let len = self.segments.len();\n+                if len < 2 {\n+                    return Err(\"Bad path\");\n+                }\n+                // FIXME: really we should descend into the generics here and add SigElements for\n+                // them.\n+                // FIXME: would be nice to have a def for the first path segment.\n+                let seg1 = pprust::path_segment_to_string(&self.segments[len - 2]);\n+                let seg2 = pprust::path_segment_to_string(&self.segments[len - 1]);\n+                let start = offset + seg1.len() + 2;\n+                (format!(\"{}::{}\", seg1, seg2), start, start + seg2.len())\n+            }\n+            _ => {\n+                let name = pprust::path_segment_to_string(self.segments.last().ok_or(\"Bad path\")?);\n+                let end = offset + name.len();\n+                (name, offset, end)\n+            }\n+        };\n+\n+        let id = id_from_def_id(def.def_id());\n+        Ok(Signature {\n+            text: name,\n+            defs: vec![],\n+            refs: vec![SigElement { id, start, end }],\n+        })\n+    }\n+}\n+\n+// This does not cover the where clause, which must be processed separately.\n+impl Sig for ast::Generics {\n+    fn make(&self, offset: usize, _parent_id: Option<NodeId>, scx: &SaveContext) -> Result {\n+        let total = self.lifetimes.len() + self.ty_params.len();\n+        if total == 0 {\n+            return Ok(text_sig(String::new()));\n+        }\n+\n+        let mut text = \"<\".to_owned();\n+\n+        let mut defs = vec![];\n+        for l in &self.lifetimes {\n+            let mut l_text = l.lifetime.ident.to_string();\n+            defs.push(SigElement {\n+                id: id_from_node_id(l.lifetime.id, scx),\n+                start: offset + text.len(),\n+                end: offset + text.len() + l_text.len(),\n+            });\n+\n+            if !l.bounds.is_empty() {\n+                l_text.push_str(\": \");\n+                let bounds = l.bounds.iter().map(|l| {\n+                    l.ident.to_string()\n+                }).collect::<Vec<_>>().join(\" + \");\n+                l_text.push_str(&bounds);\n+                // FIXME add lifetime bounds refs.\n+            }\n+            text.push_str(&l_text);\n+            text.push(',');\n+        }\n+        for t in &self.ty_params {\n+            let mut t_text = t.ident.to_string();\n+            defs.push(SigElement {\n+                id: id_from_node_id(t.id, scx),\n+                start: offset + text.len(),\n+                end: offset + text.len() + t_text.len(),\n+            });\n+\n+            if !t.bounds.is_empty() {\n+                t_text.push_str(\": \");\n+                t_text.push_str(&pprust::bounds_to_string(&t.bounds));\n+                // FIXME descend properly into bounds.\n+            }\n+            text.push_str(&t_text);\n+            text.push(',');\n+        }\n+\n+        text.push('>');\n+        Ok(Signature {text, defs, refs: vec![] })\n+    }\n+}\n+\n+impl Sig for ast::StructField {\n+    fn make(&self, offset: usize, _parent_id: Option<NodeId>, scx: &SaveContext) -> Result {\n+        let mut text = String::new();\n+        let mut defs = None;\n+        if let Some(ref ident) = self.ident {\n+            text.push_str(&ident.to_string());\n+            defs = Some(SigElement {\n+                id: id_from_node_id(self.id, scx),\n+                start: offset,\n+                end: offset + text.len(),\n+            });\n+            text.push_str(\": \");\n+        }\n+\n+        let mut ty_sig = self.ty.make(offset + text.len(), Some(self.id), scx)?;\n+        text.push_str(&ty_sig.text);\n+        ty_sig.text = text;\n+        ty_sig.defs.extend(defs.into_iter());\n+        Ok(ty_sig)\n+    }\n+}\n+\n+\n+impl Sig for ast::Variant_ {\n+    fn make(&self, offset: usize, _parent_id: Option<NodeId>, scx: &SaveContext) -> Result {\n+        let mut text = self.name.to_string();\n+        match self.data {\n+            ast::VariantData::Struct(ref fields, id) => {\n+                let name_def = SigElement {\n+                    id: id_from_node_id(id, scx),\n+                    start: offset,\n+                    end: offset + text.len(),\n+                };\n+                text.push_str(\" { \");\n+                let mut defs = vec![name_def];\n+                let mut refs = vec![];\n+                for f in fields {\n+                    let field_sig = f.make(offset + text.len(), Some(id), scx)?;\n+                    text.push_str(&field_sig.text);\n+                    text.push_str(\", \");\n+                    defs.extend(field_sig.defs.into_iter());\n+                    refs.extend(field_sig.refs.into_iter());\n+                }\n+                text.push('}');\n+                Ok(Signature {\n+                    text,\n+                    defs: defs,\n+                    refs: refs,\n+                })\n+            }\n+            ast::VariantData::Tuple(ref fields, id) => {\n+                let name_def = SigElement {\n+                    id: id_from_node_id(id, scx),\n+                    start: offset,\n+                    end: offset + text.len(),\n+                };\n+                text.push('(');\n+                let mut defs = vec![name_def];\n+                let mut refs = vec![];\n+                for f in fields {\n+                    let field_sig = f.make(offset + text.len(), Some(id), scx)?;\n+                    text.push_str(&field_sig.text);\n+                    text.push_str(\", \");\n+                    defs.extend(field_sig.defs.into_iter());\n+                    refs.extend(field_sig.refs.into_iter());\n+                }\n+                text.push(')');\n+                Ok(Signature {\n+                    text,\n+                    defs: defs,\n+                    refs: refs,\n+                })\n+            }\n+            ast::VariantData::Unit(id) => {\n+                let name_def = SigElement {\n+                    id: id_from_node_id(id, scx),\n+                    start: offset,\n+                    end: offset + text.len(),\n+                };\n+                Ok(Signature {\n+                    text,\n+                    defs: vec![name_def],\n+                    refs: vec![],\n+                })\n+            }\n+        }\n+    }\n+}\n+\n+impl Sig for ast::ForeignItem {\n+    fn make(&self, offset: usize, _parent_id: Option<NodeId>, scx: &SaveContext) -> Result {\n+        let id = Some(self.id);\n+        match self.node {\n+            ast::ForeignItemKind::Fn(ref decl, ref generics) => {\n+                let mut text = String::new();\n+                text.push_str(\"fn \");\n+\n+                let mut sig = name_and_generics(text,\n+                                                offset,\n+                                                generics,\n+                                                self.id,\n+                                                self.ident,\n+                                                scx)?;\n+\n+                sig.text.push('(');\n+                for i in &decl.inputs {\n+                    // FIXME should descend into patterns to add defs.\n+                    sig.text.push_str(&pprust::pat_to_string(&i.pat));\n+                    sig.text.push_str(\": \");\n+                    let nested = i.ty.make(offset + sig.text.len(), Some(i.id), scx)?;\n+                    sig.text.push_str(&nested.text);\n+                    sig.text.push(',');\n+                    sig.defs.extend(nested.defs.into_iter());\n+                    sig.refs.extend(nested.refs.into_iter());\n+                }\n+                sig.text.push(')');\n+\n+                if let ast::FunctionRetTy::Ty(ref t) = decl.output {\n+                    sig.text.push_str(\" -> \");\n+                    let nested = t.make(offset + sig.text.len(), None, scx)?;\n+                    sig.text.push_str(&nested.text);\n+                    sig.defs.extend(nested.defs.into_iter());\n+                    sig.refs.extend(nested.refs.into_iter());\n+                }\n+                sig.text.push(';');\n+\n+                Ok(sig)\n+            }\n+            ast::ForeignItemKind::Static(ref ty, m) => {\n+                let mut text = \"static \".to_owned();\n+                if m {\n+                    text.push_str(\"mut \");\n+                }\n+                let name = self.ident.to_string();\n+                let defs = vec![SigElement {\n+                    id: id_from_node_id(self.id, scx),\n+                    start: offset + text.len(),\n+                    end: offset + text.len() + name.len(),\n+                }];\n+                text.push_str(&name);\n+                text.push_str(\": \");\n+\n+                let ty_sig = ty.make(offset + text.len(), id, scx)?;\n+                text.push(';');\n+\n+                Ok(extend_sig(ty_sig, text, defs, vec![]))\n+            }\n+        }\n+    }\n+}\n+\n+fn name_and_generics(mut text: String,\n+                     offset: usize,\n+                     generics: &ast::Generics,\n+                     id: NodeId,\n+                     name: ast::Ident,\n+                     scx: &SaveContext)\n+                     -> Result {\n+    let name = name.to_string();\n+    let def = SigElement {\n+        id: id_from_node_id(id, scx),\n+        start: offset + text.len(),\n+        end: offset + text.len() + name.len(),\n+    };\n+    text.push_str(&name);\n+    let generics: Signature = generics.make(offset + text.len(), Some(id), scx)?;\n+    // FIXME where clause\n+    let text = format!(\"{}{}\", text, generics.text);\n+    Ok(extend_sig(generics, text, vec![def], vec![]))\n+}\n+\n+\n+fn make_assoc_type_signature(id: NodeId,\n+                             ident: ast::Ident,\n+                             bounds: Option<&ast::TyParamBounds>,\n+                             default: Option<&ast::Ty>,\n+                             scx: &SaveContext)\n+                             -> Result {\n+    let mut text = \"type \".to_owned();\n+    let name = ident.to_string();\n+    let mut defs = vec![SigElement {\n+        id: id_from_node_id(id, scx),\n+        start: text.len(),\n+        end: text.len() + name.len(),\n+    }];\n+    let mut refs = vec![];\n+    text.push_str(&name);\n+    if let Some(bounds) = bounds {\n+        text.push_str(\": \");\n+        // FIXME should descend into bounds\n+        text.push_str(&pprust::bounds_to_string(bounds));\n+    }\n+    if let Some(default) = default {\n+        text.push_str(\" = \");\n+        let ty_sig = default.make(text.len(), Some(id), scx)?;\n+        text.push_str(&ty_sig.text);\n+        defs.extend(ty_sig.defs.into_iter());\n+        refs.extend(ty_sig.refs.into_iter());\n+    }\n+    text.push(';');\n+    Ok(Signature { text, defs, refs })\n+}\n+\n+fn make_assoc_const_signature(id: NodeId,\n+                              ident: ast::Name,\n+                              ty: &ast::Ty,\n+                              default: Option<&ast::Expr>,\n+                              scx: &SaveContext)\n+                              -> Result {\n+    let mut text = \"const \".to_owned();\n+    let name = ident.to_string();\n+    let mut defs = vec![SigElement {\n+        id: id_from_node_id(id, scx),\n+        start: text.len(),\n+        end: text.len() + name.len(),\n+    }];\n+    let mut refs = vec![];\n+    text.push_str(&name);\n+    text.push_str(\": \");\n+\n+    let ty_sig = ty.make(text.len(), Some(id), scx)?;\n+    text.push_str(&ty_sig.text);\n+    defs.extend(ty_sig.defs.into_iter());\n+    refs.extend(ty_sig.refs.into_iter());\n+\n+    if let Some(default) = default {\n+        text.push_str(\" = \");\n+        text.push_str(&pprust::expr_to_string(default));\n+    }\n+    text.push(';');\n+    Ok(Signature { text, defs, refs })\n+}\n+\n+fn make_method_signature(id: NodeId,\n+                         ident: ast::Ident,\n+                         m: &ast::MethodSig,\n+                         scx: &SaveContext)\n+                         -> Result {\n+    // FIXME code dup with function signature\n+    let mut text = String::new();\n+    if m.constness.node == ast::Constness::Const {\n+        text.push_str(\"const \");\n+    }\n+    if m.unsafety == ast::Unsafety::Unsafe {\n+        text.push_str(\"unsafe \");\n+    }\n+    if m.abi != ::syntax::abi::Abi::Rust {\n+        text.push_str(\"extern\");\n+        text.push_str(&m.abi.to_string());\n+        text.push(' ');\n+    }\n+    text.push_str(\"fn \");\n+\n+    let mut sig = name_and_generics(text,\n+                                    0,\n+                                    &m.generics,\n+                                    id,\n+                                    ident,\n+                                    scx)?;\n+\n+    sig.text.push('(');\n+    for i in &m.decl.inputs {\n+        // FIXME shoudl descend into patterns to add defs.\n+        sig.text.push_str(&pprust::pat_to_string(&i.pat));\n+        sig.text.push_str(\": \");\n+        let nested = i.ty.make(sig.text.len(), Some(i.id), scx)?;\n+        sig.text.push_str(&nested.text);\n+        sig.text.push(',');\n+        sig.defs.extend(nested.defs.into_iter());\n+        sig.refs.extend(nested.refs.into_iter());\n+    }\n+    sig.text.push(')');\n+\n+    if let ast::FunctionRetTy::Ty(ref t) = m.decl.output {\n+        sig.text.push_str(\" -> \");\n+        let nested = t.make(sig.text.len(), None, scx)?;\n+        sig.text.push_str(&nested.text);\n+        sig.defs.extend(nested.defs.into_iter());\n+        sig.refs.extend(nested.refs.into_iter());\n+    }\n+    sig.text.push_str(\" {}\");\n+\n+    Ok(sig)\n+}"}, {"sha": "34cda433d5250ee9c1b0bb47671372b7e695a095", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 20, "deletions": 7, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/e7fffa2211f3145e444c2d90321a0e39d6150b42/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7fffa2211f3145e444c2d90321a0e39d6150b42/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=e7fffa2211f3145e444c2d90321a0e39d6150b42", "patch": "@@ -370,6 +370,10 @@ pub fn path_to_string(p: &ast::Path) -> String {\n     to_string(|s| s.print_path(p, false, 0, false))\n }\n \n+pub fn path_segment_to_string(p: &ast::PathSegment) -> String {\n+    to_string(|s| s.print_path_segment(p, false))\n+}\n+\n pub fn ident_to_string(id: ast::Ident) -> String {\n     to_string(|s| s.print_ident(id))\n }\n@@ -2359,18 +2363,27 @@ impl<'a> State<'a> {\n             if i > 0 {\n                 word(&mut self.s, \"::\")?\n             }\n-            if segment.identifier.name != keywords::CrateRoot.name() &&\n-               segment.identifier.name != \"$crate\" {\n-                self.print_ident(segment.identifier)?;\n-                if let Some(ref parameters) = segment.parameters {\n-                    self.print_path_parameters(parameters, colons_before_params)?;\n-                }\n-            }\n+            self.print_path_segment(segment, colons_before_params)?;\n         }\n \n         Ok(())\n     }\n \n+    fn print_path_segment(&mut self,\n+                          segment: &ast::PathSegment,\n+                          colons_before_params: bool)\n+                          -> io::Result<()>\n+    {\n+        if segment.identifier.name != keywords::CrateRoot.name() &&\n+           segment.identifier.name != \"$crate\" {\n+            self.print_ident(segment.identifier)?;\n+            if let Some(ref parameters) = segment.parameters {\n+                self.print_path_parameters(parameters, colons_before_params)?;\n+            }\n+        }\n+        Ok(())\n+    }\n+\n     fn print_qpath(&mut self,\n                    path: &ast::Path,\n                    qself: &ast::QSelf,"}, {"sha": "0d0f3baad02d65d96befbb90e77bf8a326dd14f5", "filename": "src/tools/rls", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": null, "raw_url": null, "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frls?ref=e7fffa2211f3145e444c2d90321a0e39d6150b42", "patch": "@@ -1 +1 @@\n-Subproject commit bfe80cfa8db75500e67ca8762465d27662674637\n+Subproject commit 0d0f3baad02d65d96befbb90e77bf8a326dd14f5"}]}