{"sha": "0d32ff723ab807add5830af57c3ebbc9cae8e8b6", "node_id": "MDY6Q29tbWl0NzI0NzEyOjBkMzJmZjcyM2FiODA3YWRkNTgzMGFmNTdjM2ViYmM5Y2FlOGU4YjY=", "commit": {"author": {"name": "Graydon Hoare", "email": "graydon@mozilla.com", "date": "2011-05-13T20:29:41Z"}, "committer": {"name": "Graydon Hoare", "email": "graydon@mozilla.com", "date": "2011-05-13T20:29:50Z"}, "message": "Slight adjustments to shape, rename to type_glue.rs.", "tree": {"sha": "69ab77c5d02787f11fd943ddc9053bb303b127f6", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/69ab77c5d02787f11fd943ddc9053bb303b127f6"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0d32ff723ab807add5830af57c3ebbc9cae8e8b6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0d32ff723ab807add5830af57c3ebbc9cae8e8b6", "html_url": "https://github.com/rust-lang/rust/commit/0d32ff723ab807add5830af57c3ebbc9cae8e8b6", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0d32ff723ab807add5830af57c3ebbc9cae8e8b6/comments", "author": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "committer": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c97b05141ab6bf5410d55d8a879690ca6d51d667", "url": "https://api.github.com/repos/rust-lang/rust/commits/c97b05141ab6bf5410d55d8a879690ca6d51d667", "html_url": "https://github.com/rust-lang/rust/commit/c97b05141ab6bf5410d55d8a879690ca6d51d667"}], "stats": {"total": 204, "additions": 105, "deletions": 99}, "files": [{"sha": "c11431e7bc9875ac3503111914cdeebe462ceac9", "filename": "src/comp/middle/shape.rs", "status": "removed", "additions": 0, "deletions": 98, "changes": 98, "blob_url": "https://github.com/rust-lang/rust/blob/c97b05141ab6bf5410d55d8a879690ca6d51d667/src%2Fcomp%2Fmiddle%2Fshape.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c97b05141ab6bf5410d55d8a879690ca6d51d667/src%2Fcomp%2Fmiddle%2Fshape.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fshape.rs?ref=c97b05141ab6bf5410d55d8a879690ca6d51d667", "patch": "@@ -1,98 +0,0 @@\n-// The \"shape\" of a type is best defined as \"how a value of a type looks from\n-// the standpoint of a certain built-in operation\".\n-//\n-// This is used to collapse glues that would otherwise be separate. For\n-// instance, a boxed tuple of 3 ints and a boxed tuple of 3 uints look the\n-// same as far as reference count manipulation is concerned, so they get the\n-// same shape so that their reference count glues can be collapsed together.\n-// To give another example, an int and float have the same (nonexistent!) glue\n-// as far as reference counting is concerned, since they aren't reference\n-// counted.\n-\n-import front::ast;\n-import middle::trans::variant_info;\n-import middle::ty;\n-\n-type variant_getter = fn(&ast::def_id) -> vec[variant_info];\n-\n-\n-// Reference counting shapes.\n-\n-mod rc {\n-    // TODO: Re-export, so that users can just say shape::rc.\n-    // FIXME: The bottom two should be just \"vec[rc]\", but that causes an\n-    // infinite loop in trans.\n-    tag rc {\n-        rs_none;                        // No reference count.\n-        rs_ref;                         // Reference counted box.\n-        rs_tag(vec[@rc]);               // Discriminated union.\n-        rs_tup(vec[@rc]);               // Tuple.\n-    }\n-\n-    fn shape_of(&ty::ctxt tcx, variant_getter getter, ty::t t) -> rc {\n-        alt (ty::struct(tcx, t)) {\n-            // TODO: Or-patterns\n-            case (ty::ty_nil) { ret rs_none; }\n-            case (ty::ty_bool) { ret rs_none; }\n-            case (ty::ty_int) { ret rs_none; }\n-            case (ty::ty_uint) { ret rs_none; }\n-            case (ty::ty_machine(_)) { ret rs_none; }\n-            case (ty::ty_char) { ret rs_none; }\n-            case (ty::ty_str) { ret rs_none; }\n-            case (ty::ty_tag(?did, ?params)) {\n-                let vec[@rc] result = vec();\n-\n-                auto vinfos = getter(did);\n-                for (variant_info vinfo in vinfos) {\n-                    let vec[@rc] variant_rcs = vec();\n-                    for (ty::t typ in vinfo.args) {\n-                        auto ty_1 = ty::bind_params_in_type(tcx, typ);\n-                        ty_1 = ty::substitute_type_params(tcx, params, ty_1);\n-                        variant_rcs += vec(@shape_of(tcx, getter, ty_1));\n-                    }\n-                    result += vec(@rs_tup(variant_rcs));\n-                }\n-\n-                ret rs_tag(result);\n-            }\n-            case (ty::ty_box(_)) { ret rs_ref; }\n-            case (ty::ty_vec(_)) { ret rs_ref; }\n-            case (ty::ty_port(_)) { ret rs_ref; }\n-            case (ty::ty_chan(_)) { ret rs_ref; }\n-            case (ty::ty_task) { ret rs_ref; }\n-            case (ty::ty_tup(?mts)) {\n-                let vec[@rc] result = vec();\n-                for (ty::mt tm in mts) {\n-                    result += vec(@shape_of(tcx, getter, tm.ty));\n-                }\n-                ret rs_tup(result);\n-            }\n-            case (ty::ty_rec(?fields)) {\n-                let vec[@rc] result = vec();\n-                for (ty::field fld in fields) {\n-                    result += vec(@shape_of(tcx, getter, fld.mt.ty));\n-                }\n-                ret rs_tup(result);\n-            }\n-            case (ty::ty_fn(_, _, _)) { ret rs_ref; }\n-            case (ty::ty_native_fn(_, _, _)) { ret rs_ref; }\n-            case (ty::ty_obj(_)) { ret rs_ref; }\n-            case (ty::ty_var(_)) { log_err \"var in rc::shape_of()\"; fail; }\n-            case (ty::ty_local(_)) {\n-                log_err \"local in rc::shape_of()\";\n-                fail;\n-            }\n-            case (ty::ty_param(_)) {\n-                log_err \"param in rc::shape_of()\";\n-                fail;\n-            }\n-            case (ty::ty_bound_param(_)) {\n-                log_err \"bound param in rc::shape_of()\";\n-                fail;\n-            }\n-            case (ty::ty_type) { ret rs_ref; }\n-            case (ty::ty_native) { ret rs_none; }\n-        }\n-    }\n-}\n-"}, {"sha": "d9f16bb3bcd69f34c6493200ceb317895ec87bbd", "filename": "src/comp/middle/type_glue.rs", "status": "added", "additions": 104, "deletions": 0, "changes": 104, "blob_url": "https://github.com/rust-lang/rust/blob/0d32ff723ab807add5830af57c3ebbc9cae8e8b6/src%2Fcomp%2Fmiddle%2Ftype_glue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d32ff723ab807add5830af57c3ebbc9cae8e8b6/src%2Fcomp%2Fmiddle%2Ftype_glue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftype_glue.rs?ref=0d32ff723ab807add5830af57c3ebbc9cae8e8b6", "patch": "@@ -0,0 +1,104 @@\n+// The \"shape\" of a type is best defined as \"how a value of a type looks from\n+// the standpoint of a certain built-in operation\".\n+//\n+// This is used to collapse take/drop glues that would otherwise be\n+// separate. For instance, a boxed tuple of 3 ints and a boxed tuple of 3\n+// uints look the same as far as reference count manipulation is concerned, so\n+// they get the same shape so that their reference count glues can be\n+// collapsed together. To give another example, an int and float have the\n+// same (nonexistent!) glue as far as reference counting is concerned, since\n+// they aren't reference counted.\n+\n+import front::ast;\n+import middle::trans::variant_info;\n+import middle::ty;\n+\n+type variant_getter = fn(&ast::def_id) -> vec[variant_info];\n+\n+\n+// Reference counting shapes.\n+\n+tag rc_shape {\n+    rs_none;                        // No reference count.\n+    rs_ref;                         // Reference counted box.\n+    rs_pair;                        // Pair of code/const ptr + rc box.\n+    rs_tag(vec[vec[@rc_shape]]);    // Discriminated union.\n+    rs_tup(vec[@rc_shape]);         // Tuple.\n+}\n+\n+fn rc_shape_of(&ty::ctxt tcx, variant_getter getter, ty::t t) -> rc_shape {\n+    alt (ty::struct(tcx, t)) {\n+        // TODO: Or-patterns\n+        case (ty::ty_nil) { ret rs_none; }\n+        case (ty::ty_bool) { ret rs_none; }\n+        case (ty::ty_int) { ret rs_none; }\n+        case (ty::ty_uint) { ret rs_none; }\n+        case (ty::ty_machine(_)) { ret rs_none; }\n+        case (ty::ty_char) { ret rs_none; }\n+        case (ty::ty_str) { ret rs_none; }\n+        case (ty::ty_tag(?did, ?params)) {\n+            let vec[vec[@rc_shape]] result = vec();\n+\n+            auto vinfos = getter(did);\n+            for (variant_info vinfo in vinfos) {\n+                let vec[@rc_shape] variant_rcs = vec();\n+                for (ty::t typ in vinfo.args) {\n+                    auto ty_1 = ty::bind_params_in_type(tcx, typ);\n+                    ty_1 = ty::substitute_type_params(tcx, params, ty_1);\n+                    variant_rcs += vec(@rc_shape_of(tcx, getter, ty_1));\n+                }\n+                result += vec(variant_rcs);\n+            }\n+\n+            ret rs_tag(result);\n+        }\n+        case (ty::ty_box(_)) { ret rs_ref; }\n+        case (ty::ty_vec(_)) { ret rs_ref; }\n+        case (ty::ty_port(_)) { ret rs_ref; }\n+        case (ty::ty_chan(_)) { ret rs_ref; }\n+        case (ty::ty_task) { ret rs_ref; }\n+        case (ty::ty_tup(?mts)) {\n+            let vec[@rc_shape] result = vec();\n+            for (ty::mt tm in mts) {\n+                result += vec(@rc_shape_of(tcx, getter, tm.ty));\n+            }\n+            ret rs_tup(result);\n+        }\n+        case (ty::ty_rec(?fields)) {\n+            let vec[@rc_shape] result = vec();\n+            for (ty::field fld in fields) {\n+                result += vec(@rc_shape_of(tcx, getter, fld.mt.ty));\n+            }\n+            ret rs_tup(result);\n+        }\n+        case (ty::ty_fn(_, _, _)) { ret rs_pair; }\n+        case (ty::ty_native_fn(_, _, _)) { ret rs_pair; }\n+        case (ty::ty_obj(_)) { ret rs_pair; }\n+        case (ty::ty_var(_)) { log_err \"var in rc_shape_of()\"; fail; }\n+        case (ty::ty_local(_)) {\n+            log_err \"local in rc_shape_of()\";\n+            fail;\n+        }\n+        case (ty::ty_param(_)) {\n+            log_err \"param in rc_shape_of()\";\n+            fail;\n+        }\n+        case (ty::ty_bound_param(_)) {\n+            log_err \"bound param in rc::shape_of()\";\n+            fail;\n+        }\n+        case (ty::ty_type) { ret rs_ref; }\n+        case (ty::ty_native) { ret rs_none; }\n+    }\n+}\n+\n+//\n+// Local Variables:\n+// mode: rust\n+// fill-column: 78;\n+// indent-tabs-mode: nil\n+// c-basic-offset: 4\n+// buffer-file-coding-system: utf-8-unix\n+// compile-command: \"make -k -C $RBUILD 2>&1 | sed -e 's/\\\\/x\\\\//x:\\\\//g'\";\n+// End:\n+//"}, {"sha": "a0fb45c40ab67135701a74c157a223894dfda68f", "filename": "src/comp/rustc.rc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0d32ff723ab807add5830af57c3ebbc9cae8e8b6/src%2Fcomp%2Frustc.rc", "raw_url": "https://github.com/rust-lang/rust/raw/0d32ff723ab807add5830af57c3ebbc9cae8e8b6/src%2Fcomp%2Frustc.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Frustc.rc?ref=0d32ff723ab807add5830af57c3ebbc9cae8e8b6", "patch": "@@ -10,7 +10,7 @@ meta (name = \"rustc\",\n use std;\n \n mod middle {\n-    mod shape;\n+    mod type_glue;\n     mod trans;\n     mod ty;\n     mod fold;"}]}