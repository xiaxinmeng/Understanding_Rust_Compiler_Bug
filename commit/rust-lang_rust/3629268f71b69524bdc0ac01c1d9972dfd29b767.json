{"sha": "3629268f71b69524bdc0ac01c1d9972dfd29b767", "node_id": "MDY6Q29tbWl0NzI0NzEyOjM2MjkyNjhmNzFiNjk1MjRiZGMwYWMwMWMxZDk5NzJkZmQyOWI3Njc=", "commit": {"author": {"name": "Alexander Andreev", "email": "andreevlex.as@gmail.com", "date": "2019-07-29T12:16:58Z"}, "committer": {"name": "Alexander Andreev", "email": "andreevlex.as@gmail.com", "date": "2019-07-29T12:16:58Z"}, "message": "Fixed request changes.", "tree": {"sha": "4a75f52e0b043635aed2d97b94735e70ff7218a0", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4a75f52e0b043635aed2d97b94735e70ff7218a0"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3629268f71b69524bdc0ac01c1d9972dfd29b767", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3629268f71b69524bdc0ac01c1d9972dfd29b767", "html_url": "https://github.com/rust-lang/rust/commit/3629268f71b69524bdc0ac01c1d9972dfd29b767", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3629268f71b69524bdc0ac01c1d9972dfd29b767/comments", "author": {"login": "ava57r", "id": 20382553, "node_id": "MDQ6VXNlcjIwMzgyNTUz", "avatar_url": "https://avatars.githubusercontent.com/u/20382553?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ava57r", "html_url": "https://github.com/ava57r", "followers_url": "https://api.github.com/users/ava57r/followers", "following_url": "https://api.github.com/users/ava57r/following{/other_user}", "gists_url": "https://api.github.com/users/ava57r/gists{/gist_id}", "starred_url": "https://api.github.com/users/ava57r/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ava57r/subscriptions", "organizations_url": "https://api.github.com/users/ava57r/orgs", "repos_url": "https://api.github.com/users/ava57r/repos", "events_url": "https://api.github.com/users/ava57r/events{/privacy}", "received_events_url": "https://api.github.com/users/ava57r/received_events", "type": "User", "site_admin": false}, "committer": {"login": "ava57r", "id": 20382553, "node_id": "MDQ6VXNlcjIwMzgyNTUz", "avatar_url": "https://avatars.githubusercontent.com/u/20382553?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ava57r", "html_url": "https://github.com/ava57r", "followers_url": "https://api.github.com/users/ava57r/followers", "following_url": "https://api.github.com/users/ava57r/following{/other_user}", "gists_url": "https://api.github.com/users/ava57r/gists{/gist_id}", "starred_url": "https://api.github.com/users/ava57r/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ava57r/subscriptions", "organizations_url": "https://api.github.com/users/ava57r/orgs", "repos_url": "https://api.github.com/users/ava57r/repos", "events_url": "https://api.github.com/users/ava57r/events{/privacy}", "received_events_url": "https://api.github.com/users/ava57r/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "538ec1122baeccd85ab672fd0a9f1186d2171058", "url": "https://api.github.com/repos/rust-lang/rust/commits/538ec1122baeccd85ab672fd0a9f1186d2171058", "html_url": "https://github.com/rust-lang/rust/commit/538ec1122baeccd85ab672fd0a9f1186d2171058"}], "stats": {"total": 28, "additions": 19, "deletions": 9}, "files": [{"sha": "06b7322153203bbf8c97e6c2c7e799d662e65a08", "filename": "crates/ra_hir/src/nameres/collector.rs", "status": "modified", "additions": 19, "deletions": 9, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/3629268f71b69524bdc0ac01c1d9972dfd29b767/crates%2Fra_hir%2Fsrc%2Fnameres%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3629268f71b69524bdc0ac01c1d9972dfd29b767/crates%2Fra_hir%2Fsrc%2Fnameres%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fnameres%2Fcollector.rs?ref=3629268f71b69524bdc0ac01c1d9972dfd29b767", "patch": "@@ -105,8 +105,9 @@ where\n             module_id,\n             file_id: file_id.into(),\n             raw_items: &raw_items,\n+            parent_module: None,\n         }\n-        .collect(None, raw_items.items());\n+        .collect(raw_items.items());\n \n         // main name resolution fixed-point loop.\n         let mut i = 0;\n@@ -455,8 +456,14 @@ where\n         if !self.macro_stack_monitor.is_poison(macro_def_id) {\n             let file_id: HirFileId = macro_call_id.as_file(MacroFileKind::Items);\n             let raw_items = self.db.raw_items(file_id);\n-            ModCollector { def_collector: &mut *self, file_id, module_id, raw_items: &raw_items }\n-                .collect(None, raw_items.items());\n+            ModCollector {\n+                def_collector: &mut *self,\n+                file_id,\n+                module_id,\n+                raw_items: &raw_items,\n+                parent_module: None,\n+            }\n+            .collect(raw_items.items());\n         } else {\n             log::error!(\"Too deep macro expansion: {:?}\", macro_call_id);\n             self.def_map.poison_macros.insert(macro_def_id);\n@@ -476,16 +483,17 @@ struct ModCollector<'a, D> {\n     module_id: CrateModuleId,\n     file_id: HirFileId,\n     raw_items: &'a raw::RawItems,\n+    parent_module: Option<&'a Name>,\n }\n \n impl<DB> ModCollector<'_, &'_ mut DefCollector<&'_ DB>>\n where\n     DB: DefDatabase,\n {\n-    fn collect(&mut self, parent_module: Option<&Name>, items: &[raw::RawItem]) {\n+    fn collect(&mut self, items: &[raw::RawItem]) {\n         for item in items {\n             match *item {\n-                raw::RawItem::Module(m) => self.collect_module(parent_module, &self.raw_items[m]),\n+                raw::RawItem::Module(m) => self.collect_module(&self.raw_items[m]),\n                 raw::RawItem::Import(import) => self.def_collector.unresolved_imports.push((\n                     self.module_id,\n                     import,\n@@ -497,7 +505,7 @@ where\n         }\n     }\n \n-    fn collect_module(&mut self, _module: Option<&Name>, module: &raw::ModuleData) {\n+    fn collect_module(&mut self, module: &raw::ModuleData) {\n         match module {\n             // inline module, just recurse\n             raw::ModuleData::Definition { name, items, ast_id } => {\n@@ -508,8 +516,9 @@ where\n                     module_id,\n                     file_id: self.file_id,\n                     raw_items: self.raw_items,\n+                    parent_module: Some(name),\n                 }\n-                .collect(Some(name), &*items);\n+                .collect(&*items);\n             }\n             // out of line module, resolve, parse and recurse\n             raw::ModuleData::Declaration { name, ast_id, attr_path } => {\n@@ -521,7 +530,7 @@ where\n                     name,\n                     is_root,\n                     attr_path.as_ref(),\n-                    _module,\n+                    self.parent_module,\n                 ) {\n                     Ok(file_id) => {\n                         let module_id = self.push_child_module(name.clone(), ast_id, Some(file_id));\n@@ -531,8 +540,9 @@ where\n                             module_id,\n                             file_id: file_id.into(),\n                             raw_items: &raw_items,\n+                            parent_module: None,\n                         }\n-                        .collect(None, raw_items.items())\n+                        .collect(raw_items.items())\n                     }\n                     Err(candidate) => self.def_collector.def_map.diagnostics.push(\n                         DefDiagnostic::UnresolvedModule {"}]}