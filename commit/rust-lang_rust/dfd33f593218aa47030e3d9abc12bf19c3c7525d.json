{"sha": "dfd33f593218aa47030e3d9abc12bf19c3c7525d", "node_id": "MDY6Q29tbWl0NzI0NzEyOmRmZDMzZjU5MzIxOGFhNDcwMzBlM2Q5YWJjMTJiZjE5YzNjNzUyNWQ=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2018-06-08T13:29:41Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2018-06-26T14:49:24Z"}, "message": "move `make_query_response` into method on infcx", "tree": {"sha": "c14e04662228b64646013cc4ab0cb4465c1970f2", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c14e04662228b64646013cc4ab0cb4465c1970f2"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/dfd33f593218aa47030e3d9abc12bf19c3c7525d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/dfd33f593218aa47030e3d9abc12bf19c3c7525d", "html_url": "https://github.com/rust-lang/rust/commit/dfd33f593218aa47030e3d9abc12bf19c3c7525d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/dfd33f593218aa47030e3d9abc12bf19c3c7525d/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a1811cef764ebae9715947066c19ea171b7927f1", "url": "https://api.github.com/repos/rust-lang/rust/commits/a1811cef764ebae9715947066c19ea171b7927f1", "html_url": "https://github.com/rust-lang/rust/commit/a1811cef764ebae9715947066c19ea171b7927f1"}], "stats": {"total": 286, "additions": 148, "deletions": 138}, "files": [{"sha": "aff9136bad07ce0a15bfbe0d461885972041cd39", "filename": "src/librustc/infer/canonical/query_result.rs", "status": "modified", "additions": 130, "deletions": 1, "changes": 131, "blob_url": "https://github.com/rust-lang/rust/blob/dfd33f593218aa47030e3d9abc12bf19c3c7525d/src%2Flibrustc%2Finfer%2Fcanonical%2Fquery_result.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dfd33f593218aa47030e3d9abc12bf19c3c7525d/src%2Flibrustc%2Finfer%2Fcanonical%2Fquery_result.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fcanonical%2Fquery_result.rs?ref=dfd33f593218aa47030e3d9abc12bf19c3c7525d", "patch": "@@ -17,19 +17,148 @@\n //!\n //! [c]: https://rust-lang-nursery.github.io/rustc-guide/traits/canonicalization.html\n \n-use infer::canonical::{Canonical, CanonicalVarValues, QueryRegionConstraint, QueryResult};\n use infer::canonical::substitute::substitute_value;\n+use infer::canonical::{\n+    Canonical, CanonicalVarValues, Canonicalize, Certainty, QueryRegionConstraint, QueryResult,\n+};\n+use infer::region_constraints::{Constraint, RegionConstraintData};\n use infer::{InferCtxt, InferOk, InferResult};\n use rustc_data_structures::indexed_vec::Idx;\n use std::fmt::Debug;\n+use traits::query::NoSolution;\n+use traits::{FulfillmentContext, TraitEngine};\n use traits::{Obligation, ObligationCause, PredicateObligation};\n use ty::fold::TypeFoldable;\n use ty::subst::{Kind, UnpackedKind};\n use ty::{self, CanonicalVar};\n \n use rustc_data_structures::indexed_vec::IndexVec;\n \n+type CanonicalizedQueryResult<'gcx, 'tcx, T> =\n+    <QueryResult<'tcx, T> as Canonicalize<'gcx, 'tcx>>::Canonicalized;\n+\n impl<'cx, 'gcx, 'tcx> InferCtxt<'cx, 'gcx, 'tcx> {\n+    /// This method is meant to be invoked as the final step of a canonical query\n+    /// implementation. It is given:\n+    ///\n+    /// - the instantiated variables `inference_vars` created from the query key\n+    /// - the result `answer` of the query\n+    /// - a fulfillment context `fulfill_cx` that may contain various obligations which\n+    ///   have yet to be proven.\n+    ///\n+    /// Given this, the function will process the obligations pending\n+    /// in `fulfill_cx`:\n+    ///\n+    /// - If all the obligations can be proven successfully, it will\n+    ///   package up any resulting region obligations (extracted from\n+    ///   `infcx`) along with the fully resolved value `answer` into a\n+    ///   query result (which is then itself canonicalized).\n+    /// - If some obligations can be neither proven nor disproven, then\n+    ///   the same thing happens, but the resulting query is marked as ambiguous.\n+    /// - Finally, if any of the obligations result in a hard error,\n+    ///   then `Err(NoSolution)` is returned.\n+    pub fn make_canonicalized_query_result<T>(\n+        &self,\n+        inference_vars: CanonicalVarValues<'tcx>,\n+        answer: T,\n+        fulfill_cx: &mut FulfillmentContext<'tcx>,\n+    ) -> Result<CanonicalizedQueryResult<'gcx, 'tcx, T>, NoSolution>\n+    where\n+        T: Debug,\n+        QueryResult<'tcx, T>: Canonicalize<'gcx, 'tcx>,\n+    {\n+        let tcx = self.tcx;\n+\n+        debug!(\n+            \"make_query_response(\\\n+             inference_vars={:?}, \\\n+             answer={:?})\",\n+            inference_vars, answer,\n+        );\n+\n+        // Select everything, returning errors.\n+        let true_errors = match fulfill_cx.select_where_possible(self) {\n+            Ok(()) => vec![],\n+            Err(errors) => errors,\n+        };\n+        debug!(\"true_errors = {:#?}\", true_errors);\n+\n+        if !true_errors.is_empty() {\n+            // FIXME -- we don't indicate *why* we failed to solve\n+            debug!(\"make_query_response: true_errors={:#?}\", true_errors);\n+            return Err(NoSolution);\n+        }\n+\n+        // Anything left unselected *now* must be an ambiguity.\n+        let ambig_errors = match fulfill_cx.select_all_or_error(self) {\n+            Ok(()) => vec![],\n+            Err(errors) => errors,\n+        };\n+        debug!(\"ambig_errors = {:#?}\", ambig_errors);\n+\n+        let region_obligations = self.take_registered_region_obligations();\n+\n+        let region_constraints = self.with_region_constraints(|region_constraints| {\n+            let RegionConstraintData {\n+                constraints,\n+                verifys,\n+                givens,\n+            } = region_constraints;\n+\n+            assert!(verifys.is_empty());\n+            assert!(givens.is_empty());\n+\n+            let mut outlives: Vec<_> = constraints\n+            .into_iter()\n+            .map(|(k, _)| match *k {\n+                // Swap regions because we are going from sub (<=) to outlives\n+                // (>=).\n+                Constraint::VarSubVar(v1, v2) => ty::OutlivesPredicate(\n+                    tcx.mk_region(ty::ReVar(v2)).into(),\n+                    tcx.mk_region(ty::ReVar(v1)),\n+                ),\n+                Constraint::VarSubReg(v1, r2) => {\n+                    ty::OutlivesPredicate(r2.into(), tcx.mk_region(ty::ReVar(v1)))\n+                }\n+                Constraint::RegSubVar(r1, v2) => {\n+                    ty::OutlivesPredicate(tcx.mk_region(ty::ReVar(v2)).into(), r1)\n+                }\n+                Constraint::RegSubReg(r1, r2) => ty::OutlivesPredicate(r2.into(), r1),\n+            })\n+            .map(ty::Binder::dummy) // no bound regions in the code above\n+            .collect();\n+\n+            outlives.extend(\n+                region_obligations\n+                    .into_iter()\n+                    .map(|(_, r_o)| ty::OutlivesPredicate(r_o.sup_type.into(), r_o.sub_region))\n+                    .map(ty::Binder::dummy), // no bound regions in the code above\n+            );\n+\n+            outlives\n+        });\n+\n+        let certainty = if ambig_errors.is_empty() {\n+            Certainty::Proven\n+        } else {\n+            Certainty::Ambiguous\n+        };\n+\n+        let (canonical_result, _) = self.canonicalize_response(&QueryResult {\n+            var_values: inference_vars,\n+            region_constraints,\n+            certainty,\n+            value: answer,\n+        });\n+\n+        debug!(\n+            \"make_query_response: canonical_result = {:#?}\",\n+            canonical_result\n+        );\n+\n+        Ok(canonical_result)\n+    }\n+\n     /// Given the (canonicalized) result to a canonical query,\n     /// instantiates the result so it can be used, plugging in the\n     /// values from the canonical query. (Note that the result may"}, {"sha": "cd49aa2241b3c4ed11d26be824a7090bfee08760", "filename": "src/librustc_traits/dropck_outlives.rs", "status": "modified", "additions": 17, "deletions": 10, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/dfd33f593218aa47030e3d9abc12bf19c3c7525d/src%2Flibrustc_traits%2Fdropck_outlives.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dfd33f593218aa47030e3d9abc12bf19c3c7525d/src%2Flibrustc_traits%2Fdropck_outlives.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_traits%2Fdropck_outlives.rs?ref=dfd33f593218aa47030e3d9abc12bf19c3c7525d", "patch": "@@ -8,17 +8,16 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use rustc::infer::canonical::{Canonical, QueryResult};\n use rustc::hir::def_id::DefId;\n-use rustc::traits::{FulfillmentContext, Normalized, ObligationCause};\n+use rustc::infer::canonical::{Canonical, QueryResult};\n+use rustc::traits::query::dropck_outlives::{DropckOutlivesResult, DtorckConstraint};\n use rustc::traits::query::{CanonicalTyGoal, NoSolution};\n-use rustc::traits::query::dropck_outlives::{DtorckConstraint, DropckOutlivesResult};\n-use rustc::ty::{self, ParamEnvAnd, Ty, TyCtxt};\n+use rustc::traits::{FulfillmentContext, Normalized, ObligationCause};\n use rustc::ty::subst::{Subst, Substs};\n+use rustc::ty::{self, ParamEnvAnd, Ty, TyCtxt};\n use rustc::util::nodemap::FxHashSet;\n use rustc_data_structures::sync::Lrc;\n use syntax::codemap::{Span, DUMMY_SP};\n-use util;\n \n crate fn dropck_outlives<'tcx>(\n     tcx: TyCtxt<'_, 'tcx, 'tcx>,\n@@ -36,7 +35,10 @@ crate fn dropck_outlives<'tcx>(\n             canonical_inference_vars,\n         ) = infcx.instantiate_canonical_with_fresh_inference_vars(DUMMY_SP, &goal);\n \n-        let mut result = DropckOutlivesResult { kinds: vec![], overflows: vec![] };\n+        let mut result = DropckOutlivesResult {\n+            kinds: vec![],\n+            overflows: vec![],\n+        };\n \n         // A stack of types left to process. Each round, we pop\n         // something from the stack and invoke\n@@ -135,7 +137,7 @@ crate fn dropck_outlives<'tcx>(\n \n         debug!(\"dropck_outlives: result = {:#?}\", result);\n \n-        util::make_query_response(infcx, canonical_inference_vars, result, fulfill_cx)\n+        infcx.make_canonicalized_query_result(canonical_inference_vars, result, fulfill_cx)\n     })\n }\n \n@@ -184,7 +186,8 @@ fn dtorck_constraint_for_ty<'a, 'gcx, 'tcx>(\n             dtorck_constraint_for_ty(tcx, span, for_ty, depth + 1, ety)\n         }\n \n-        ty::TyTuple(tys) => tys.iter()\n+        ty::TyTuple(tys) => tys\n+            .iter()\n             .map(|ty| dtorck_constraint_for_ty(tcx, span, for_ty, depth + 1, ty))\n             .collect(),\n \n@@ -222,7 +225,10 @@ fn dtorck_constraint_for_ty<'a, 'gcx, 'tcx>(\n                 dtorck_types: vec![],\n                 overflows: vec![],\n             };\n-            debug!(\"dtorck_constraint: generator {:?} => {:?}\", def_id, constraint);\n+            debug!(\n+                \"dtorck_constraint: generator {:?} => {:?}\",\n+                def_id, constraint\n+            );\n \n             Ok(constraint)\n         }\n@@ -291,7 +297,8 @@ crate fn adt_dtorck_constraint<'a, 'tcx>(\n         return Ok(result);\n     }\n \n-    let mut result = def.all_fields()\n+    let mut result = def\n+        .all_fields()\n         .map(|field| tcx.type_of(field.did))\n         .map(|fty| dtorck_constraint_for_ty(tcx, span, fty, 0, fty))\n         .collect::<Result<DtorckConstraint, NoSolution>>()?;"}, {"sha": "830aa93c3c3d1968e286e8acd033612c32a10437", "filename": "src/librustc_traits/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/dfd33f593218aa47030e3d9abc12bf19c3c7525d/src%2Flibrustc_traits%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dfd33f593218aa47030e3d9abc12bf19c3c7525d/src%2Flibrustc_traits%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_traits%2Flib.rs?ref=dfd33f593218aa47030e3d9abc12bf19c3c7525d", "patch": "@@ -33,7 +33,6 @@ mod dropck_outlives;\n mod evaluate_obligation;\n mod normalize_projection_ty;\n mod normalize_erasing_regions;\n-mod util;\n pub mod lowering;\n \n use rustc::ty::query::Providers;"}, {"sha": "a9c4fef9f7dc19dba15fa042d965f912ee8f635a", "filename": "src/librustc_traits/normalize_projection_ty.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/dfd33f593218aa47030e3d9abc12bf19c3c7525d/src%2Flibrustc_traits%2Fnormalize_projection_ty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dfd33f593218aa47030e3d9abc12bf19c3c7525d/src%2Flibrustc_traits%2Fnormalize_projection_ty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_traits%2Fnormalize_projection_ty.rs?ref=dfd33f593218aa47030e3d9abc12bf19c3c7525d", "patch": "@@ -15,7 +15,6 @@ use rustc::ty::{ParamEnvAnd, TyCtxt};\n use rustc_data_structures::sync::Lrc;\n use syntax::ast::DUMMY_NODE_ID;\n use syntax_pos::DUMMY_SP;\n-use util;\n use std::sync::atomic::Ordering;\n \n crate fn normalize_projection_ty<'tcx>(\n@@ -43,8 +42,7 @@ crate fn normalize_projection_ty<'tcx>(\n \n         // Now that we have fulfilled as much as we can, create a solution\n         // from what we've learned.\n-        util::make_query_response(\n-            infcx,\n+        infcx.make_canonicalized_query_result(\n             canonical_inference_vars,\n             NormalizationResult { normalized_ty: answer },\n             fulfill_cx,"}, {"sha": "cdf20bdafadc40024990d6035823f5c416126b24", "filename": "src/librustc_traits/util.rs", "status": "removed", "additions": 0, "deletions": 123, "changes": 123, "blob_url": "https://github.com/rust-lang/rust/blob/a1811cef764ebae9715947066c19ea171b7927f1/src%2Flibrustc_traits%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a1811cef764ebae9715947066c19ea171b7927f1/src%2Flibrustc_traits%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_traits%2Futil.rs?ref=a1811cef764ebae9715947066c19ea171b7927f1", "patch": "@@ -1,123 +0,0 @@\n-// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-use rustc::infer::InferCtxt;\n-use rustc::infer::canonical::{CanonicalVarValues, Canonicalize, Certainty, QueryResult};\n-use rustc::infer::region_constraints::{Constraint, RegionConstraintData};\n-use rustc::traits::{FulfillmentContext, TraitEngine};\n-use rustc::traits::query::NoSolution;\n-use rustc::ty;\n-use std::fmt::Debug;\n-\n-/// The canonicalization form of `QueryResult<'tcx, T>`.\n-type CanonicalizedQueryResult<'gcx, 'tcx, T> =\n-    <QueryResult<'tcx, T> as Canonicalize<'gcx, 'tcx>>::Canonicalized;\n-\n-crate fn make_query_response<'gcx, 'tcx, T>(\n-    infcx: &InferCtxt<'_, 'gcx, 'tcx>,\n-    inference_vars: CanonicalVarValues<'tcx>,\n-    answer: T,\n-    fulfill_cx: &mut FulfillmentContext<'tcx>,\n-) -> Result<CanonicalizedQueryResult<'gcx, 'tcx, T>, NoSolution>\n-where\n-    T: Debug,\n-    QueryResult<'tcx, T>: Canonicalize<'gcx, 'tcx>,\n-{\n-    let tcx = infcx.tcx;\n-\n-    debug!(\n-        \"make_query_response(\\\n-         inference_vars={:?}, \\\n-         answer={:?})\",\n-        inference_vars, answer,\n-    );\n-\n-    // Select everything, returning errors.\n-    let true_errors = match fulfill_cx.select_where_possible(infcx) {\n-        Ok(()) => vec![],\n-        Err(errors) => errors,\n-    };\n-    debug!(\"true_errors = {:#?}\", true_errors);\n-\n-    if !true_errors.is_empty() {\n-        // FIXME -- we don't indicate *why* we failed to solve\n-        debug!(\"make_query_response: true_errors={:#?}\", true_errors);\n-        return Err(NoSolution);\n-    }\n-\n-    // Anything left unselected *now* must be an ambiguity.\n-    let ambig_errors = match fulfill_cx.select_all_or_error(infcx) {\n-        Ok(()) => vec![],\n-        Err(errors) => errors,\n-    };\n-    debug!(\"ambig_errors = {:#?}\", ambig_errors);\n-\n-    let region_obligations = infcx.take_registered_region_obligations();\n-\n-    let region_constraints = infcx.with_region_constraints(|region_constraints| {\n-        let RegionConstraintData {\n-            constraints,\n-            verifys,\n-            givens,\n-        } = region_constraints;\n-\n-        assert!(verifys.is_empty());\n-        assert!(givens.is_empty());\n-\n-        let mut outlives: Vec<_> = constraints\n-            .into_iter()\n-            .map(|(k, _)| match *k {\n-                // Swap regions because we are going from sub (<=) to outlives\n-                // (>=).\n-                Constraint::VarSubVar(v1, v2) => ty::OutlivesPredicate(\n-                    tcx.mk_region(ty::ReVar(v2)).into(),\n-                    tcx.mk_region(ty::ReVar(v1)),\n-                ),\n-                Constraint::VarSubReg(v1, r2) => {\n-                    ty::OutlivesPredicate(r2.into(), tcx.mk_region(ty::ReVar(v1)))\n-                }\n-                Constraint::RegSubVar(r1, v2) => {\n-                    ty::OutlivesPredicate(tcx.mk_region(ty::ReVar(v2)).into(), r1)\n-                }\n-                Constraint::RegSubReg(r1, r2) => ty::OutlivesPredicate(r2.into(), r1),\n-            })\n-            .map(ty::Binder::dummy) // no bound regions in the code above\n-            .collect();\n-\n-        outlives.extend(\n-            region_obligations\n-                .into_iter()\n-                .map(|(_, r_o)| ty::OutlivesPredicate(r_o.sup_type.into(), r_o.sub_region))\n-                .map(ty::Binder::dummy) // no bound regions in the code above\n-        );\n-\n-        outlives\n-    });\n-\n-    let certainty = if ambig_errors.is_empty() {\n-        Certainty::Proven\n-    } else {\n-        Certainty::Ambiguous\n-    };\n-\n-    let (canonical_result, _) = infcx.canonicalize_response(&QueryResult {\n-        var_values: inference_vars,\n-        region_constraints,\n-        certainty,\n-        value: answer,\n-    });\n-\n-    debug!(\n-        \"make_query_response: canonical_result = {:#?}\",\n-        canonical_result\n-    );\n-\n-    Ok(canonical_result)\n-}"}]}