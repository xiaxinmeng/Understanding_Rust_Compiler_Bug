{"sha": "7a4f39453cfbeab1c2220331f2eae8938165c964", "node_id": "MDY6Q29tbWl0NzI0NzEyOjdhNGYzOTQ1M2NmYmVhYjFjMjIyMDMzMWYyZWFlODkzODE2NWM5NjQ=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-10-18T10:44:08Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-10-18T10:44:08Z"}, "message": "Auto merge of #44501 - nikomatsakis:issue-44137-non-query-data-in-tcx, r=eddyb\n\nremove or encapsulate the remaining non-query data in tcx\n\nI wound up removing the existing cache around inhabitedness since it didn't seem to be adding much value. I reworked const rvalue promotion, but not that much (i.e., I did not split the computation into bits, as @eddyb had tossed out as a suggestion). But it's now demand driven, at least.\n\ncc @michaelwoerister -- see the `forbid_reads` change in last commit\n\nr? @eddyb -- since the trickiest of this PR is the work on const rvalue promotion\n\ncc #44137", "tree": {"sha": "7802302c7168b6e93c4741d0121c51fcf11d17b6", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7802302c7168b6e93c4741d0121c51fcf11d17b6"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7a4f39453cfbeab1c2220331f2eae8938165c964", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7a4f39453cfbeab1c2220331f2eae8938165c964", "html_url": "https://github.com/rust-lang/rust/commit/7a4f39453cfbeab1c2220331f2eae8938165c964", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7a4f39453cfbeab1c2220331f2eae8938165c964/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f6d7514545cbe83e771a400d04049b96dfb210cd", "url": "https://api.github.com/repos/rust-lang/rust/commits/f6d7514545cbe83e771a400d04049b96dfb210cd", "html_url": "https://github.com/rust-lang/rust/commit/f6d7514545cbe83e771a400d04049b96dfb210cd"}, {"sha": "7715f97279fe343c4dc78609b51b75cb0433a8b3", "url": "https://api.github.com/repos/rust-lang/rust/commits/7715f97279fe343c4dc78609b51b75cb0433a8b3", "html_url": "https://github.com/rust-lang/rust/commit/7715f97279fe343c4dc78609b51b75cb0433a8b3"}], "stats": {"total": 679, "additions": 438, "deletions": 241}, "files": [{"sha": "d67a74f681e23cb2f6802505aba2249fecb642a1", "filename": "CONTRIBUTING.md", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7a4f39453cfbeab1c2220331f2eae8938165c964/CONTRIBUTING.md", "raw_url": "https://github.com/rust-lang/rust/raw/7a4f39453cfbeab1c2220331f2eae8938165c964/CONTRIBUTING.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/CONTRIBUTING.md?ref=7a4f39453cfbeab1c2220331f2eae8938165c964", "patch": "@@ -360,8 +360,10 @@ git add path/to/submodule\n \n outside the submodule.\n \n-It can also be more convenient during development to set `submodules = false`\n-in the `config.toml` to prevent `x.py` from resetting to the original branch.\n+In order to prepare your PR, you can run the build locally by doing\n+`./x.py build src/tools/TOOL`. If you will be editing the sources\n+there, you may wish to set `submodules = false` in the `config.toml`\n+to prevent `x.py` from resetting to the original branch.\n \n ## Writing Documentation\n [writing-documentation]: #writing-documentation"}, {"sha": "f9e902b910504245c5d4635c264de985eea904a6", "filename": "src/librustc/dep_graph/dep_node.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7a4f39453cfbeab1c2220331f2eae8938165c964/src%2Flibrustc%2Fdep_graph%2Fdep_node.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a4f39453cfbeab1c2220331f2eae8938165c964/src%2Flibrustc%2Fdep_graph%2Fdep_node.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdep_graph%2Fdep_node.rs?ref=7a4f39453cfbeab1c2220331f2eae8938165c964", "patch": "@@ -554,6 +554,7 @@ define_dep_nodes!( <'tcx>\n     [] LookupDeprecationEntry(DefId),\n     [] ItemBodyNestedBodies(DefId),\n     [] ConstIsRvaluePromotableToStatic(DefId),\n+    [] RvaluePromotableMap(DefId),\n     [] ImplParent(DefId),\n     [] TraitOfItem(DefId),\n     [] IsExportedSymbol(DefId),\n@@ -609,6 +610,7 @@ define_dep_nodes!( <'tcx>\n     [] PostorderCnums,\n     [] HasCloneClosures(CrateNum),\n     [] HasCopyClosures(CrateNum),\n+    [] EraseRegionsTy { ty: Ty<'tcx> },\n \n     [] Freevars(DefId),\n     [] MaybeUnusedTraitImport(DefId),"}, {"sha": "64fe4626d6ee69e4a31ba10043fb396348949624", "filename": "src/librustc/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7a4f39453cfbeab1c2220331f2eae8938165c964/src%2Flibrustc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a4f39453cfbeab1c2220331f2eae8938165c964/src%2Flibrustc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flib.rs?ref=7a4f39453cfbeab1c2220331f2eae8938165c964", "patch": "@@ -60,7 +60,7 @@\n #![cfg_attr(stage0, feature(const_fn))]\n #![cfg_attr(not(stage0), feature(const_atomic_bool_new))]\n \n-#![recursion_limit=\"256\"]\n+#![recursion_limit=\"512\"]\n \n extern crate arena;\n #[macro_use] extern crate bitflags;"}, {"sha": "e62cc2a658a474cf6f1d75da9956ebc627afa813", "filename": "src/librustc/middle/expr_use_visitor.rs", "status": "modified", "additions": 19, "deletions": 3, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/7a4f39453cfbeab1c2220331f2eae8938165c964/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a4f39453cfbeab1c2220331f2eae8938165c964/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs?ref=7a4f39453cfbeab1c2220331f2eae8938165c964", "patch": "@@ -27,10 +27,11 @@ use middle::region;\n use ty::{self, TyCtxt, adjustment};\n \n use hir::{self, PatKind};\n-\n+use std::rc::Rc;\n use syntax::ast;\n use syntax::ptr::P;\n use syntax_pos::Span;\n+use util::nodemap::ItemLocalMap;\n \n ///////////////////////////////////////////////////////////////////////////\n // The Delegate trait\n@@ -262,15 +263,30 @@ macro_rules! return_if_err {\n }\n \n impl<'a, 'tcx> ExprUseVisitor<'a, 'tcx, 'tcx> {\n+    /// Creates the ExprUseVisitor, configuring it with the various options provided:\n+    ///\n+    /// - `delegate` -- who receives the callbacks\n+    /// - `param_env` --- parameter environment for trait lookups (esp. pertaining to `Copy`)\n+    /// - `region_scope_tree` --- region scope tree for the code being analyzed\n+    /// - `tables` --- typeck results for the code being analyzed\n+    /// - `rvalue_promotable_map` --- if you care about rvalue promotion, then provide\n+    ///   the map here (it can be computed with `tcx.rvalue_promotable_map(def_id)`).\n+    ///   `None` means that rvalues will be given more conservative lifetimes.\n+    ///\n+    /// See also `with_infer`, which is used *during* typeck.\n     pub fn new(delegate: &'a mut (Delegate<'tcx>+'a),\n                tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                param_env: ty::ParamEnv<'tcx>,\n                region_scope_tree: &'a region::ScopeTree,\n-               tables: &'a ty::TypeckTables<'tcx>)\n+               tables: &'a ty::TypeckTables<'tcx>,\n+               rvalue_promotable_map: Option<Rc<ItemLocalMap<bool>>>)\n                -> Self\n     {\n         ExprUseVisitor {\n-            mc: mc::MemCategorizationContext::new(tcx, region_scope_tree, tables),\n+            mc: mc::MemCategorizationContext::new(tcx,\n+                                                  region_scope_tree,\n+                                                  tables,\n+                                                  rvalue_promotable_map),\n             delegate,\n             param_env,\n         }"}, {"sha": "e0e30f8831676aa28cb69b3a062a156b2a819ea8", "filename": "src/librustc/middle/mem_categorization.rs", "status": "modified", "additions": 34, "deletions": 6, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/7a4f39453cfbeab1c2220331f2eae8938165c964/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a4f39453cfbeab1c2220331f2eae8938165c964/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs?ref=7a4f39453cfbeab1c2220331f2eae8938165c964", "patch": "@@ -86,6 +86,7 @@ use syntax_pos::Span;\n \n use std::fmt;\n use std::rc::Rc;\n+use util::nodemap::ItemLocalMap;\n \n #[derive(Clone, PartialEq)]\n pub enum Categorization<'tcx> {\n@@ -285,6 +286,7 @@ pub struct MemCategorizationContext<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n     pub tcx: TyCtxt<'a, 'gcx, 'tcx>,\n     pub region_scope_tree: &'a region::ScopeTree,\n     pub tables: &'a ty::TypeckTables<'tcx>,\n+    rvalue_promotable_map: Option<Rc<ItemLocalMap<bool>>>,\n     infcx: Option<&'a InferCtxt<'a, 'gcx, 'tcx>>,\n }\n \n@@ -392,21 +394,46 @@ impl MutabilityCategory {\n impl<'a, 'tcx> MemCategorizationContext<'a, 'tcx, 'tcx> {\n     pub fn new(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                region_scope_tree: &'a region::ScopeTree,\n-               tables: &'a ty::TypeckTables<'tcx>)\n+               tables: &'a ty::TypeckTables<'tcx>,\n+               rvalue_promotable_map: Option<Rc<ItemLocalMap<bool>>>)\n                -> MemCategorizationContext<'a, 'tcx, 'tcx> {\n-        MemCategorizationContext { tcx, region_scope_tree, tables, infcx: None }\n+        MemCategorizationContext {\n+            tcx,\n+            region_scope_tree,\n+            tables,\n+            rvalue_promotable_map,\n+            infcx: None\n+        }\n     }\n }\n \n impl<'a, 'gcx, 'tcx> MemCategorizationContext<'a, 'gcx, 'tcx> {\n+    /// Creates a `MemCategorizationContext` during type inference.\n+    /// This is used during upvar analysis and a few other places.\n+    /// Because the typeck tables are not yet complete, the results\n+    /// from the analysis must be used with caution:\n+    ///\n+    /// - rvalue promotions are not known, so the lifetimes of\n+    ///   temporaries may be overly conservative;\n+    /// - similarly, as the results of upvar analysis are not yet\n+    ///   known, the results around upvar accesses may be incorrect.\n     pub fn with_infer(infcx: &'a InferCtxt<'a, 'gcx, 'tcx>,\n                       region_scope_tree: &'a region::ScopeTree,\n                       tables: &'a ty::TypeckTables<'tcx>)\n                       -> MemCategorizationContext<'a, 'gcx, 'tcx> {\n+        let tcx = infcx.tcx;\n+\n+        // Subtle: we can't do rvalue promotion analysis until the\n+        // typeck phase is complete, which means that you can't trust\n+        // the rvalue lifetimes that result, but that's ok, since we\n+        // don't need to know those during type inference.\n+        let rvalue_promotable_map = None;\n+\n         MemCategorizationContext {\n-            tcx: infcx.tcx,\n+            tcx,\n             region_scope_tree,\n             tables,\n+            rvalue_promotable_map,\n             infcx: Some(infcx),\n         }\n     }\n@@ -869,8 +896,9 @@ impl<'a, 'gcx, 'tcx> MemCategorizationContext<'a, 'gcx, 'tcx> {\n                            span: Span,\n                            expr_ty: Ty<'tcx>)\n                            -> cmt<'tcx> {\n-        let promotable = self.tcx.rvalue_promotable_to_static.borrow().get(&id).cloned()\n-                                   .unwrap_or(false);\n+        let hir_id = self.tcx.hir.node_to_hir_id(id);\n+        let promotable = self.rvalue_promotable_map.as_ref().map(|m| m[&hir_id.local_id])\n+                                                            .unwrap_or(false);\n \n         // Always promote `[T; 0]` (even when e.g. borrowed mutably).\n         let promotable = match expr_ty.sty {\n@@ -885,7 +913,7 @@ impl<'a, 'gcx, 'tcx> MemCategorizationContext<'a, 'gcx, 'tcx> {\n         let re = if promotable {\n             self.tcx.types.re_static\n         } else {\n-            self.temporary_scope(self.tcx.hir.node_to_hir_id(id).local_id)\n+            self.temporary_scope(hir_id.local_id)\n         };\n         let ret = self.cat_rvalue(id, span, re, expr_ty);\n         debug!(\"cat_rvalue_node ret {:?}\", ret);"}, {"sha": "3d5e8ea583ccc71b3c78d0dd0160c58838183340", "filename": "src/librustc/ty/context.rs", "status": "modified", "additions": 0, "deletions": 12, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/7a4f39453cfbeab1c2220331f2eae8938165c964/src%2Flibrustc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a4f39453cfbeab1c2220331f2eae8938165c964/src%2Flibrustc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fcontext.rs?ref=7a4f39453cfbeab1c2220331f2eae8938165c964", "patch": "@@ -43,7 +43,6 @@ use ty::RegionKind;\n use ty::{TyVar, TyVid, IntVar, IntVid, FloatVar, FloatVid};\n use ty::TypeVariants::*;\n use ty::layout::{Layout, TargetDataLayout};\n-use ty::inhabitedness::DefIdForest;\n use ty::maps;\n use ty::steal::Steal;\n use ty::BindingMode;\n@@ -893,11 +892,6 @@ pub struct GlobalCtxt<'tcx> {\n     // Internal cache for metadata decoding. No need to track deps on this.\n     pub rcache: RefCell<FxHashMap<ty::CReaderCacheKey, Ty<'tcx>>>,\n \n-    // FIXME dep tracking -- should be harmless enough\n-    pub normalized_cache: RefCell<FxHashMap<Ty<'tcx>, Ty<'tcx>>>,\n-\n-    pub inhabitedness_cache: RefCell<FxHashMap<Ty<'tcx>, DefIdForest>>,\n-\n     /// Caches the results of trait selection. This cache is used\n     /// for things that do not have to do with the parameters in scope.\n     pub selection_cache: traits::SelectionCache<'tcx>,\n@@ -907,9 +901,6 @@ pub struct GlobalCtxt<'tcx> {\n     /// Merge this with `selection_cache`?\n     pub evaluation_cache: traits::EvaluationCache<'tcx>,\n \n-    /// Maps Expr NodeId's to `true` iff `&expr` can have 'static lifetime.\n-    pub rvalue_promotable_to_static: RefCell<NodeMap<bool>>,\n-\n     /// The definite name of the current crate after taking into account\n     /// attributes, commandline parameters, etc.\n     pub crate_name: Symbol,\n@@ -1178,11 +1169,8 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n             maps: maps::Maps::new(providers),\n             mir_passes,\n             rcache: RefCell::new(FxHashMap()),\n-            normalized_cache: RefCell::new(FxHashMap()),\n-            inhabitedness_cache: RefCell::new(FxHashMap()),\n             selection_cache: traits::SelectionCache::new(),\n             evaluation_cache: traits::EvaluationCache::new(),\n-            rvalue_promotable_to_static: RefCell::new(NodeMap()),\n             crate_name: Symbol::intern(crate_name),\n             data_layout,\n             layout_interner: RefCell::new(FxHashSet()),"}, {"sha": "4f8fca67949b5ddd645ffba529ec183e74290184", "filename": "src/librustc/ty/erase_regions.rs", "status": "added", "additions": 79, "deletions": 0, "changes": 79, "blob_url": "https://github.com/rust-lang/rust/blob/7a4f39453cfbeab1c2220331f2eae8938165c964/src%2Flibrustc%2Fty%2Ferase_regions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a4f39453cfbeab1c2220331f2eae8938165c964/src%2Flibrustc%2Fty%2Ferase_regions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Ferase_regions.rs?ref=7a4f39453cfbeab1c2220331f2eae8938165c964", "patch": "@@ -0,0 +1,79 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use ty::{self, Ty, TyCtxt};\n+use ty::fold::{TypeFolder, TypeFoldable};\n+\n+pub(super) fn provide(providers: &mut ty::maps::Providers) {\n+    *providers = ty::maps::Providers {\n+        erase_regions_ty,\n+        ..*providers\n+    };\n+}\n+\n+fn erase_regions_ty<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, ty: Ty<'tcx>) -> Ty<'tcx> {\n+    // NB: use `super_fold_with` here. If we used `fold_with`, it\n+    // could invoke the `erase_regions_ty` query recursively.\n+    ty.super_fold_with(&mut RegionEraserVisitor { tcx })\n+}\n+\n+impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n+    /// Returns an equivalent value with all free regions removed (note\n+    /// that late-bound regions remain, because they are important for\n+    /// subtyping, but they are anonymized and normalized as well)..\n+    pub fn erase_regions<T>(self, value: &T) -> T\n+        where T : TypeFoldable<'tcx>\n+    {\n+        let value1 = value.fold_with(&mut RegionEraserVisitor { tcx: self });\n+        debug!(\"erase_regions({:?}) = {:?}\", value, value1);\n+        value1\n+    }\n+}\n+\n+struct RegionEraserVisitor<'a, 'gcx: 'tcx, 'tcx: 'a> {\n+    tcx: TyCtxt<'a, 'gcx, 'tcx>,\n+}\n+\n+impl<'a, 'gcx, 'tcx> TypeFolder<'gcx, 'tcx> for RegionEraserVisitor<'a, 'gcx, 'tcx> {\n+    fn tcx<'b>(&'b self) -> TyCtxt<'b, 'gcx, 'tcx> {\n+        self.tcx\n+    }\n+\n+    fn fold_ty(&mut self, ty: Ty<'tcx>) -> Ty<'tcx> {\n+        if let Some(ty_lifted) = self.tcx.lift_to_global(&ty) {\n+            self.tcx.erase_regions_ty(ty_lifted)\n+        } else {\n+            ty.super_fold_with(self)\n+        }\n+    }\n+\n+    fn fold_binder<T>(&mut self, t: &ty::Binder<T>) -> ty::Binder<T>\n+        where T : TypeFoldable<'tcx>\n+    {\n+        let u = self.tcx.anonymize_late_bound_regions(t);\n+        u.super_fold_with(self)\n+    }\n+\n+    fn fold_region(&mut self, r: ty::Region<'tcx>) -> ty::Region<'tcx> {\n+        // because late-bound regions affect subtyping, we can't\n+        // erase the bound/free distinction, but we can replace\n+        // all free regions with 'erased.\n+        //\n+        // Note that we *CAN* replace early-bound regions -- the\n+        // type system never \"sees\" those, they get substituted\n+        // away. In trans, they will always be erased to 'erased\n+        // whenever a substitution occurs.\n+        match *r {\n+            ty::ReLateBound(..) => r,\n+            _ => self.tcx.types.re_erased\n+        }\n+    }\n+}\n+"}, {"sha": "edd4329fa419c39f03cbd4e1dd443d8271e705d7", "filename": "src/librustc/ty/fold.rs", "status": "modified", "additions": 0, "deletions": 61, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/7a4f39453cfbeab1c2220331f2eae8938165c964/src%2Flibrustc%2Fty%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a4f39453cfbeab1c2220331f2eae8938165c964/src%2Flibrustc%2Fty%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Ffold.rs?ref=7a4f39453cfbeab1c2220331f2eae8938165c964", "patch": "@@ -444,67 +444,6 @@ impl<'a, 'gcx, 'tcx> TypeFolder<'gcx, 'tcx> for RegionReplacer<'a, 'gcx, 'tcx> {\n     }\n }\n \n-///////////////////////////////////////////////////////////////////////////\n-// Region eraser\n-\n-impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n-    /// Returns an equivalent value with all free regions removed (note\n-    /// that late-bound regions remain, because they are important for\n-    /// subtyping, but they are anonymized and normalized as well)..\n-    pub fn erase_regions<T>(self, value: &T) -> T\n-        where T : TypeFoldable<'tcx>\n-    {\n-        let value1 = value.fold_with(&mut RegionEraser(self));\n-        debug!(\"erase_regions({:?}) = {:?}\",\n-               value, value1);\n-        return value1;\n-\n-        struct RegionEraser<'a, 'gcx: 'a+'tcx, 'tcx: 'a>(TyCtxt<'a, 'gcx, 'tcx>);\n-\n-        impl<'a, 'gcx, 'tcx> TypeFolder<'gcx, 'tcx> for RegionEraser<'a, 'gcx, 'tcx> {\n-            fn tcx<'b>(&'b self) -> TyCtxt<'b, 'gcx, 'tcx> { self.0 }\n-\n-            fn fold_ty(&mut self, ty: Ty<'tcx>) -> Ty<'tcx> {\n-                if let Some(u) = self.tcx().normalized_cache.borrow().get(&ty).cloned() {\n-                    return u;\n-                }\n-\n-                // FIXME(eddyb) should local contexts have a cache too?\n-                if let Some(ty_lifted) = self.tcx().lift_to_global(&ty) {\n-                    let tcx = self.tcx().global_tcx();\n-                    let t_norm = ty_lifted.super_fold_with(&mut RegionEraser(tcx));\n-                    tcx.normalized_cache.borrow_mut().insert(ty_lifted, t_norm);\n-                    t_norm\n-                } else {\n-                    ty.super_fold_with(self)\n-                }\n-            }\n-\n-            fn fold_binder<T>(&mut self, t: &ty::Binder<T>) -> ty::Binder<T>\n-                where T : TypeFoldable<'tcx>\n-            {\n-                let u = self.tcx().anonymize_late_bound_regions(t);\n-                u.super_fold_with(self)\n-            }\n-\n-            fn fold_region(&mut self, r: ty::Region<'tcx>) -> ty::Region<'tcx> {\n-                // because late-bound regions affect subtyping, we can't\n-                // erase the bound/free distinction, but we can replace\n-                // all free regions with 'erased.\n-                //\n-                // Note that we *CAN* replace early-bound regions -- the\n-                // type system never \"sees\" those, they get substituted\n-                // away. In trans, they will always be erased to 'erased\n-                // whenever a substitution occurs.\n-                match *r {\n-                    ty::ReLateBound(..) => r,\n-                    _ => self.tcx().types.re_erased\n-                }\n-            }\n-        }\n-    }\n-}\n-\n ///////////////////////////////////////////////////////////////////////////\n // Region shifter\n //"}, {"sha": "0072512464a0e95406d9d7ab3a9dde4b29efcb4a", "filename": "src/librustc/ty/inhabitedness/mod.rs", "status": "modified", "additions": 104, "deletions": 47, "changes": 151, "blob_url": "https://github.com/rust-lang/rust/blob/7a4f39453cfbeab1c2220331f2eae8938165c964/src%2Flibrustc%2Fty%2Finhabitedness%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a4f39453cfbeab1c2220331f2eae8938165c964/src%2Flibrustc%2Fty%2Finhabitedness%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Finhabitedness%2Fmod.rs?ref=7a4f39453cfbeab1c2220331f2eae8938165c964", "patch": "@@ -10,7 +10,7 @@\n \n use util::nodemap::{FxHashMap, FxHashSet};\n use ty::context::TyCtxt;\n-use ty::{AdtDef, VariantDef, FieldDef, TyS};\n+use ty::{AdtDef, VariantDef, FieldDef, Ty, TyS};\n use ty::{DefId, Substs};\n use ty::{AdtKind, Visibility};\n use ty::TypeVariants::*;\n@@ -62,13 +62,95 @@ mod def_id_forest;\n // This code should only compile in modules where the uninhabitedness of Foo is\n // visible.\n \n+impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n+    /// Checks whether a type is visibly uninhabited from a particular module.\n+    /// # Example\n+    /// ```rust\n+    /// enum Void {}\n+    /// mod a {\n+    ///     pub mod b {\n+    ///         pub struct SecretlyUninhabited {\n+    ///             _priv: !,\n+    ///         }\n+    ///     }\n+    /// }\n+    ///\n+    /// mod c {\n+    ///     pub struct AlsoSecretlyUninhabited {\n+    ///         _priv: Void,\n+    ///     }\n+    ///     mod d {\n+    ///     }\n+    /// }\n+    ///\n+    /// struct Foo {\n+    ///     x: a::b::SecretlyUninhabited,\n+    ///     y: c::AlsoSecretlyUninhabited,\n+    /// }\n+    /// ```\n+    /// In this code, the type `Foo` will only be visibly uninhabited inside the\n+    /// modules b, c and d. This effects pattern-matching on `Foo` or types that\n+    /// contain `Foo`.\n+    ///\n+    /// # Example\n+    /// ```rust\n+    /// let foo_result: Result<T, Foo> = ... ;\n+    /// let Ok(t) = foo_result;\n+    /// ```\n+    /// This code should only compile in modules where the uninhabitedness of Foo is\n+    /// visible.\n+    pub fn is_ty_uninhabited_from(self, module: DefId, ty: Ty<'tcx>) -> bool {\n+        // To check whether this type is uninhabited at all (not just from the\n+        // given node) you could check whether the forest is empty.\n+        // ```\n+        // forest.is_empty()\n+        // ```\n+        self.ty_inhabitedness_forest(ty).contains(self, module)\n+    }\n+\n+    pub fn is_ty_uninhabited_from_all_modules(self, ty: Ty<'tcx>) -> bool {\n+        !self.ty_inhabitedness_forest(ty).is_empty()\n+    }\n+\n+    fn ty_inhabitedness_forest(self, ty: Ty<'tcx>) -> DefIdForest {\n+        ty.uninhabited_from(&mut FxHashMap(), self)\n+    }\n+\n+    pub fn is_enum_variant_uninhabited_from(self,\n+                                            module: DefId,\n+                                            variant: &'tcx VariantDef,\n+                                            substs: &'tcx Substs<'tcx>)\n+                                            -> bool\n+    {\n+        self.variant_inhabitedness_forest(variant, substs).contains(self, module)\n+    }\n+\n+    pub fn is_variant_uninhabited_from_all_modules(self,\n+                                                   variant: &'tcx VariantDef,\n+                                                   substs: &'tcx Substs<'tcx>)\n+                                                   -> bool\n+    {\n+        !self.variant_inhabitedness_forest(variant, substs).is_empty()\n+    }\n+\n+    fn variant_inhabitedness_forest(self, variant: &'tcx VariantDef, substs: &'tcx Substs<'tcx>)\n+                                    -> DefIdForest {\n+        // Determine the ADT kind:\n+        let adt_def_id = self.adt_def_id_of_variant(variant);\n+        let adt_kind = self.adt_def(adt_def_id).adt_kind();\n+\n+        // Compute inhabitedness forest:\n+        variant.uninhabited_from(&mut FxHashMap(), self, substs, adt_kind)\n+    }\n+}\n+\n impl<'a, 'gcx, 'tcx> AdtDef {\n     /// Calculate the forest of DefIds from which this adt is visibly uninhabited.\n-    pub fn uninhabited_from(\n-                &self,\n-                visited: &mut FxHashMap<DefId, FxHashSet<&'tcx Substs<'tcx>>>,\n-                tcx: TyCtxt<'a, 'gcx, 'tcx>,\n-                substs: &'tcx Substs<'tcx>) -> DefIdForest\n+    fn uninhabited_from(\n+        &self,\n+        visited: &mut FxHashMap<DefId, FxHashSet<&'tcx Substs<'tcx>>>,\n+        tcx: TyCtxt<'a, 'gcx, 'tcx>,\n+        substs: &'tcx Substs<'tcx>) -> DefIdForest\n     {\n         DefIdForest::intersection(tcx, self.variants.iter().map(|v| {\n             v.uninhabited_from(visited, tcx, substs, self.adt_kind())\n@@ -78,12 +160,12 @@ impl<'a, 'gcx, 'tcx> AdtDef {\n \n impl<'a, 'gcx, 'tcx> VariantDef {\n     /// Calculate the forest of DefIds from which this variant is visibly uninhabited.\n-    pub fn uninhabited_from(\n-                &self,\n-                visited: &mut FxHashMap<DefId, FxHashSet<&'tcx Substs<'tcx>>>,\n-                tcx: TyCtxt<'a, 'gcx, 'tcx>,\n-                substs: &'tcx Substs<'tcx>,\n-                adt_kind: AdtKind) -> DefIdForest\n+    fn uninhabited_from(\n+        &self,\n+        visited: &mut FxHashMap<DefId, FxHashSet<&'tcx Substs<'tcx>>>,\n+        tcx: TyCtxt<'a, 'gcx, 'tcx>,\n+        substs: &'tcx Substs<'tcx>,\n+        adt_kind: AdtKind) -> DefIdForest\n     {\n         match adt_kind {\n             AdtKind::Union => {\n@@ -107,12 +189,12 @@ impl<'a, 'gcx, 'tcx> VariantDef {\n \n impl<'a, 'gcx, 'tcx> FieldDef {\n     /// Calculate the forest of DefIds from which this field is visibly uninhabited.\n-    pub fn uninhabited_from(\n-                &self,\n-                visited: &mut FxHashMap<DefId, FxHashSet<&'tcx Substs<'tcx>>>,\n-                tcx: TyCtxt<'a, 'gcx, 'tcx>,\n-                substs: &'tcx Substs<'tcx>,\n-                is_enum: bool) -> DefIdForest\n+    fn uninhabited_from(\n+        &self,\n+        visited: &mut FxHashMap<DefId, FxHashSet<&'tcx Substs<'tcx>>>,\n+        tcx: TyCtxt<'a, 'gcx, 'tcx>,\n+        substs: &'tcx Substs<'tcx>,\n+        is_enum: bool) -> DefIdForest\n     {\n         let mut data_uninhabitedness = move || {\n             self.ty(tcx, substs).uninhabited_from(visited, tcx)\n@@ -138,35 +220,10 @@ impl<'a, 'gcx, 'tcx> FieldDef {\n \n impl<'a, 'gcx, 'tcx> TyS<'tcx> {\n     /// Calculate the forest of DefIds from which this type is visibly uninhabited.\n-    pub fn uninhabited_from(\n-                &self,\n-                visited: &mut FxHashMap<DefId, FxHashSet<&'tcx Substs<'tcx>>>,\n-                tcx: TyCtxt<'a, 'gcx, 'tcx>) -> DefIdForest\n-    {\n-        match tcx.lift_to_global(&self) {\n-            Some(global_ty) => {\n-                {\n-                    let cache = tcx.inhabitedness_cache.borrow();\n-                    if let Some(forest) = cache.get(&global_ty) {\n-                        return forest.clone();\n-                    }\n-                }\n-                let forest = global_ty.uninhabited_from_inner(visited, tcx);\n-                let mut cache = tcx.inhabitedness_cache.borrow_mut();\n-                cache.insert(global_ty, forest.clone());\n-                forest\n-            },\n-            None => {\n-                let forest = self.uninhabited_from_inner(visited, tcx);\n-                forest\n-            },\n-        }\n-    }\n-\n-    fn uninhabited_from_inner(\n-                &self,\n-                visited: &mut FxHashMap<DefId, FxHashSet<&'tcx Substs<'tcx>>>,\n-                tcx: TyCtxt<'a, 'gcx, 'tcx>) -> DefIdForest\n+    fn uninhabited_from(\n+        &self,\n+        visited: &mut FxHashMap<DefId, FxHashSet<&'tcx Substs<'tcx>>>,\n+        tcx: TyCtxt<'a, 'gcx, 'tcx>) -> DefIdForest\n     {\n         match self.sty {\n             TyAdt(def, substs) => {"}, {"sha": "8f8cda0e0f1d1dff3c4be091232d5595ce0635bc", "filename": "src/librustc/ty/maps/config.rs", "status": "modified", "additions": 19, "deletions": 1, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/7a4f39453cfbeab1c2220331f2eae8938165c964/src%2Flibrustc%2Fty%2Fmaps%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a4f39453cfbeab1c2220331f2eae8938165c964/src%2Flibrustc%2Fty%2Fmaps%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmaps%2Fconfig.rs?ref=7a4f39453cfbeab1c2220331f2eae8938165c964", "patch": "@@ -29,7 +29,12 @@ pub(super) trait QueryDescription: QueryConfig {\n \n impl<M: QueryConfig<Key=DefId>> QueryDescription for M {\n     default fn describe(tcx: TyCtxt, def_id: DefId) -> String {\n-        format!(\"processing `{}`\", tcx.item_path_str(def_id))\n+        if !tcx.sess.verbose() {\n+            format!(\"processing `{}`\", tcx.item_path_str(def_id))\n+        } else {\n+            let name = unsafe { ::std::intrinsics::type_name::<M>() };\n+            format!(\"processing `{}` applied to `{:?}`\", name, def_id)\n+        }\n     }\n }\n \n@@ -70,6 +75,12 @@ impl<'tcx> QueryDescription for queries::super_predicates_of<'tcx> {\n     }\n }\n \n+impl<'tcx> QueryDescription for queries::erase_regions_ty<'tcx> {\n+    fn describe(_tcx: TyCtxt, ty: Ty<'tcx>) -> String {\n+        format!(\"erasing regions from `{:?}`\", ty)\n+    }\n+}\n+\n impl<'tcx> QueryDescription for queries::type_param_predicates<'tcx> {\n     fn describe(tcx: TyCtxt, (_, def_id): (DefId, DefId)) -> String {\n         let id = tcx.hir.as_local_node_id(def_id).unwrap();\n@@ -214,6 +225,13 @@ impl<'tcx> QueryDescription for queries::const_is_rvalue_promotable_to_static<'t\n     }\n }\n \n+impl<'tcx> QueryDescription for queries::rvalue_promotable_map<'tcx> {\n+    fn describe(tcx: TyCtxt, def_id: DefId) -> String {\n+        format!(\"checking which parts of `{}` are promotable to static\",\n+                tcx.item_path_str(def_id))\n+    }\n+}\n+\n impl<'tcx> QueryDescription for queries::is_mir_available<'tcx> {\n     fn describe(tcx: TyCtxt, def_id: DefId) -> String {\n         format!(\"checking if item is mir available: `{}`\","}, {"sha": "839042bf229aaffc87c99e44f9d4536931f36938", "filename": "src/librustc/ty/maps/mod.rs", "status": "modified", "additions": 11, "deletions": 1, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/7a4f39453cfbeab1c2220331f2eae8938165c964/src%2Flibrustc%2Fty%2Fmaps%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a4f39453cfbeab1c2220331f2eae8938165c964/src%2Flibrustc%2Fty%2Fmaps%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmaps%2Fmod.rs?ref=7a4f39453cfbeab1c2220331f2eae8938165c964", "patch": "@@ -37,7 +37,7 @@ use ty::{self, CrateInherentImpls, Ty, TyCtxt};\n use ty::layout::{Layout, LayoutError};\n use ty::steal::Steal;\n use ty::subst::Substs;\n-use util::nodemap::{DefIdSet, DefIdMap};\n+use util::nodemap::{DefIdSet, DefIdMap, ItemLocalMap};\n use util::common::{profq_msg, ProfileQueriesMsg};\n \n use rustc_data_structures::indexed_set::IdxSetBuf;\n@@ -231,6 +231,7 @@ define_maps! { <'tcx>\n     [] fn is_exported_symbol: IsExportedSymbol(DefId) -> bool,\n     [] fn item_body_nested_bodies: ItemBodyNestedBodies(DefId) -> ExternBodyNestedBodies,\n     [] fn const_is_rvalue_promotable_to_static: ConstIsRvaluePromotableToStatic(DefId) -> bool,\n+    [] fn rvalue_promotable_map: RvaluePromotableMap(DefId) -> Rc<ItemLocalMap<bool>>,\n     [] fn is_mir_available: IsMirAvailable(DefId) -> bool,\n     [] fn vtable_methods: vtable_methods_node(ty::PolyTraitRef<'tcx>)\n                           -> Rc<Vec<Option<(DefId, &'tcx Substs<'tcx>)>>>,\n@@ -343,12 +344,21 @@ define_maps! { <'tcx>\n \n     [] fn has_copy_closures: HasCopyClosures(CrateNum) -> bool,\n     [] fn has_clone_closures: HasCloneClosures(CrateNum) -> bool,\n+\n+    // Erases regions from `ty` to yield a new type.\n+    // Normally you would just use `tcx.erase_regions(&value)`,\n+    // however, which uses this query as a kind of cache.\n+    [] fn erase_regions_ty: erase_regions_ty(Ty<'tcx>) -> Ty<'tcx>,\n }\n \n //////////////////////////////////////////////////////////////////////\n // These functions are little shims used to find the dep-node for a\n // given query when there is not a *direct* mapping:\n \n+fn erase_regions_ty<'tcx>(ty: Ty<'tcx>) -> DepConstructor<'tcx> {\n+    DepConstructor::EraseRegionsTy { ty }\n+}\n+\n fn type_param_predicates<'tcx>((item_id, param_id): (DefId, DefId)) -> DepConstructor<'tcx> {\n     DepConstructor::TypeParamPredicates {\n         item_id,"}, {"sha": "343ac049ea2ffeaff23390fdc1938c8a138fe2ff", "filename": "src/librustc/ty/maps/plumbing.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7a4f39453cfbeab1c2220331f2eae8938165c964/src%2Flibrustc%2Fty%2Fmaps%2Fplumbing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a4f39453cfbeab1c2220331f2eae8938165c964/src%2Flibrustc%2Fty%2Fmaps%2Fplumbing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmaps%2Fplumbing.rs?ref=7a4f39453cfbeab1c2220331f2eae8938165c964", "patch": "@@ -701,6 +701,7 @@ pub fn force_from_dep_node<'a, 'gcx, 'lcx>(tcx: TyCtxt<'a, 'gcx, 'lcx>,\n         DepKind::CompileCodegenUnit |\n         DepKind::FulfillObligation |\n         DepKind::VtableMethods |\n+        DepKind::EraseRegionsTy |\n \n         // These are just odd\n         DepKind::Null |\n@@ -774,6 +775,7 @@ pub fn force_from_dep_node<'a, 'gcx, 'lcx>(tcx: TyCtxt<'a, 'gcx, 'lcx>,\n         DepKind::ConstIsRvaluePromotableToStatic => {\n             force!(const_is_rvalue_promotable_to_static, def_id!());\n         }\n+        DepKind::RvaluePromotableMap => { force!(rvalue_promotable_map, def_id!()); }\n         DepKind::ImplParent => { force!(impl_parent, def_id!()); }\n         DepKind::TraitOfItem => { force!(trait_of_item, def_id!()); }\n         DepKind::IsExportedSymbol => { force!(is_exported_symbol, def_id!()); }"}, {"sha": "129c81c5cd61f75cc0c96b628c324c5b44085973", "filename": "src/librustc/ty/mod.rs", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/7a4f39453cfbeab1c2220331f2eae8938165c964/src%2Flibrustc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a4f39453cfbeab1c2220331f2eae8938165c964/src%2Flibrustc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmod.rs?ref=7a4f39453cfbeab1c2220331f2eae8938165c964", "patch": "@@ -18,6 +18,7 @@ pub use self::fold::TypeFoldable;\n use hir::{map as hir_map, FreevarMap, TraitMap};\n use hir::def::{Def, CtorKind, ExportMap};\n use hir::def_id::{CrateNum, DefId, DefIndex, CRATE_DEF_INDEX, LOCAL_CRATE};\n+use hir::map::DefPathData;\n use ich::StableHashingContext;\n use middle::const_val::ConstVal;\n use middle::lang_items::{FnTraitLangItem, FnMutTraitLangItem, FnOnceTraitLangItem};\n@@ -89,6 +90,7 @@ pub mod adjustment;\n pub mod binding;\n pub mod cast;\n pub mod error;\n+mod erase_regions;\n pub mod fast_reject;\n pub mod fold;\n pub mod inhabitedness;\n@@ -2232,6 +2234,20 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n         }\n     }\n \n+    /// Given a `VariantDef`, returns the def-id of the `AdtDef` of which it is a part.\n+    pub fn adt_def_id_of_variant(self, variant_def: &'tcx VariantDef) -> DefId {\n+        let def_key = self.def_key(variant_def.did);\n+        match def_key.disambiguated_data.data {\n+            // for enum variants and tuple structs, the def-id of the ADT itself\n+            // is the *parent* of the variant\n+            DefPathData::EnumVariant(..) | DefPathData::StructCtor =>\n+                DefId { krate: variant_def.did.krate, index: def_key.parent.unwrap() },\n+\n+            // otherwise, for structs and unions, they share a def-id\n+            _ => variant_def.did,\n+        }\n+    }\n+\n     pub fn item_name(self, id: DefId) -> InternedString {\n         if let Some(id) = self.hir.as_local_node_id(id) {\n             self.hir.name(id).as_str()\n@@ -2560,6 +2576,7 @@ fn original_crate_name<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n pub fn provide(providers: &mut ty::maps::Providers) {\n     util::provide(providers);\n     context::provide(providers);\n+    erase_regions::provide(providers);\n     *providers = ty::maps::Providers {\n         associated_item,\n         associated_item_def_ids,"}, {"sha": "064627c21bfe64f98cd2e0323e990b2bf5655994", "filename": "src/librustc/ty/sty.rs", "status": "modified", "additions": 0, "deletions": 49, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/7a4f39453cfbeab1c2220331f2eae8938165c964/src%2Flibrustc%2Fty%2Fsty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a4f39453cfbeab1c2220331f2eae8938165c964/src%2Flibrustc%2Fty%2Fsty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fsty.rs?ref=7a4f39453cfbeab1c2220331f2eae8938165c964", "patch": "@@ -24,7 +24,6 @@ use std::cmp::Ordering;\n use syntax::abi;\n use syntax::ast::{self, Name};\n use syntax::symbol::keywords;\n-use util::nodemap::FxHashMap;\n \n use serialize;\n \n@@ -1070,54 +1069,6 @@ impl<'a, 'gcx, 'tcx> TyS<'tcx> {\n         }\n     }\n \n-    /// Checks whether a type is visibly uninhabited from a particular module.\n-    /// # Example\n-    /// ```rust\n-    /// enum Void {}\n-    /// mod a {\n-    ///     pub mod b {\n-    ///         pub struct SecretlyUninhabited {\n-    ///             _priv: !,\n-    ///         }\n-    ///     }\n-    /// }\n-    ///\n-    /// mod c {\n-    ///     pub struct AlsoSecretlyUninhabited {\n-    ///         _priv: Void,\n-    ///     }\n-    ///     mod d {\n-    ///     }\n-    /// }\n-    ///\n-    /// struct Foo {\n-    ///     x: a::b::SecretlyUninhabited,\n-    ///     y: c::AlsoSecretlyUninhabited,\n-    /// }\n-    /// ```\n-    /// In this code, the type `Foo` will only be visibly uninhabited inside the\n-    /// modules b, c and d. This effects pattern-matching on `Foo` or types that\n-    /// contain `Foo`.\n-    ///\n-    /// # Example\n-    /// ```rust\n-    /// let foo_result: Result<T, Foo> = ... ;\n-    /// let Ok(t) = foo_result;\n-    /// ```\n-    /// This code should only compile in modules where the uninhabitedness of Foo is\n-    /// visible.\n-    pub fn is_uninhabited_from(&self, module: DefId, tcx: TyCtxt<'a, 'gcx, 'tcx>) -> bool {\n-        let mut visited = FxHashMap::default();\n-        let forest = self.uninhabited_from(&mut visited, tcx);\n-\n-        // To check whether this type is uninhabited at all (not just from the\n-        // given node) you could check whether the forest is empty.\n-        // ```\n-        // forest.is_empty()\n-        // ```\n-        forest.contains(tcx, module)\n-    }\n-\n     pub fn is_primitive(&self) -> bool {\n         match self.sty {\n             TyBool | TyChar | TyInt(_) | TyUint(_) | TyFloat(_) => true,"}, {"sha": "6fd9ff4012efa6b23732c3161115447fc8c72615", "filename": "src/librustc_borrowck/borrowck/check_loans.rs", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/7a4f39453cfbeab1c2220331f2eae8938165c964/src%2Flibrustc_borrowck%2Fborrowck%2Fcheck_loans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a4f39453cfbeab1c2220331f2eae8938165c964/src%2Flibrustc_borrowck%2Fborrowck%2Fcheck_loans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fcheck_loans.rs?ref=7a4f39453cfbeab1c2220331f2eae8938165c964", "patch": "@@ -206,7 +206,13 @@ pub fn check_loans<'a, 'b, 'c, 'tcx>(bccx: &BorrowckCtxt<'a, 'tcx>,\n         all_loans,\n         param_env,\n     };\n-    euv::ExprUseVisitor::new(&mut clcx, bccx.tcx, param_env, &bccx.region_scope_tree, bccx.tables)\n+    let rvalue_promotable_map = bccx.tcx.rvalue_promotable_map(def_id);\n+    euv::ExprUseVisitor::new(&mut clcx,\n+                             bccx.tcx,\n+                             param_env,\n+                             &bccx.region_scope_tree,\n+                             bccx.tables,\n+                             Some(rvalue_promotable_map))\n         .consume_body(body);\n }\n "}, {"sha": "8654f2a50e46bf1c693c328d359feee85dfbba3a", "filename": "src/librustc_borrowck/borrowck/gather_loans/mod.rs", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/7a4f39453cfbeab1c2220331f2eae8938165c964/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a4f39453cfbeab1c2220331f2eae8938165c964/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fmod.rs?ref=7a4f39453cfbeab1c2220331f2eae8938165c964", "patch": "@@ -48,7 +48,13 @@ pub fn gather_loans_in_fn<'a, 'tcx>(bccx: &BorrowckCtxt<'a, 'tcx>,\n         move_error_collector: move_error::MoveErrorCollector::new(),\n     };\n \n-    euv::ExprUseVisitor::new(&mut glcx, bccx.tcx, param_env, &bccx.region_scope_tree, bccx.tables)\n+    let rvalue_promotable_map = bccx.tcx.rvalue_promotable_map(def_id);\n+    euv::ExprUseVisitor::new(&mut glcx,\n+                             bccx.tcx,\n+                             param_env,\n+                             &bccx.region_scope_tree,\n+                             bccx.tables,\n+                             Some(rvalue_promotable_map))\n         .consume_body(bccx.body);\n \n     glcx.report_potential_errors();"}, {"sha": "08f3b0a4c5fd1cfd0e1104fa852a58d7f1c14723", "filename": "src/librustc_const_eval/_match.rs", "status": "modified", "additions": 5, "deletions": 7, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/7a4f39453cfbeab1c2220331f2eae8938165c964/src%2Flibrustc_const_eval%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a4f39453cfbeab1c2220331f2eae8938165c964/src%2Flibrustc_const_eval%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_const_eval%2F_match.rs?ref=7a4f39453cfbeab1c2220331f2eae8938165c964", "patch": "@@ -25,7 +25,7 @@ use pattern::{PatternFoldable, PatternFolder};\n \n use rustc::hir::def_id::DefId;\n use rustc::hir::RangeEnd;\n-use rustc::ty::{self, AdtKind, Ty, TyCtxt, TypeFoldable};\n+use rustc::ty::{self, Ty, TyCtxt, TypeFoldable};\n \n use rustc::mir::Field;\n use rustc::util::common::ErrorReported;\n@@ -202,21 +202,19 @@ impl<'a, 'tcx> MatchCheckCtxt<'a, 'tcx> {\n \n     fn is_uninhabited(&self, ty: Ty<'tcx>) -> bool {\n         if self.tcx.sess.features.borrow().never_type {\n-            ty.is_uninhabited_from(self.module, self.tcx)\n+            self.tcx.is_ty_uninhabited_from(self.module, ty)\n         } else {\n             false\n         }\n     }\n \n     fn is_variant_uninhabited(&self,\n                               variant: &'tcx ty::VariantDef,\n-                              substs: &'tcx ty::subst::Substs<'tcx>) -> bool\n+                              substs: &'tcx ty::subst::Substs<'tcx>)\n+                              -> bool\n     {\n         if self.tcx.sess.features.borrow().never_type {\n-            let forest = variant.uninhabited_from(\n-                &mut FxHashMap::default(), self.tcx, substs, AdtKind::Enum\n-            );\n-            forest.contains(self.tcx, self.module)\n+            self.tcx.is_enum_variant_uninhabited_from(self.module, variant, substs)\n         } else {\n             false\n         }"}, {"sha": "e6a04c9c57a6c05eba0cf2b049b28beb37546a67", "filename": "src/librustc_const_eval/check_match.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7a4f39453cfbeab1c2220331f2eae8938165c964/src%2Flibrustc_const_eval%2Fcheck_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a4f39453cfbeab1c2220331f2eae8938165c964/src%2Flibrustc_const_eval%2Fcheck_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_const_eval%2Fcheck_match.rs?ref=7a4f39453cfbeab1c2220331f2eae8938165c964", "patch": "@@ -192,7 +192,7 @@ impl<'a, 'tcx> MatchVisitor<'a, 'tcx> {\n             let module = self.tcx.hir.get_module_parent(scrut.id);\n             if inlined_arms.is_empty() {\n                 let scrutinee_is_uninhabited = if self.tcx.sess.features.borrow().never_type {\n-                    pat_ty.is_uninhabited_from(module, self.tcx)\n+                    self.tcx.is_ty_uninhabited_from(module, pat_ty)\n                 } else {\n                     self.conservative_is_uninhabited(pat_ty)\n                 };\n@@ -526,7 +526,7 @@ fn check_for_mutation_in_guard(cx: &MatchVisitor, guard: &hir::Expr) {\n     let mut checker = MutationChecker {\n         cx,\n     };\n-    ExprUseVisitor::new(&mut checker, cx.tcx, cx.param_env, cx.region_scope_tree, cx.tables)\n+    ExprUseVisitor::new(&mut checker, cx.tcx, cx.param_env, cx.region_scope_tree, cx.tables, None)\n         .walk_expr(guard);\n }\n "}, {"sha": "7dbf93da38598d15476770230b867dd46fe1c1d8", "filename": "src/librustc_driver/driver.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/7a4f39453cfbeab1c2220331f2eae8938165c964/src%2Flibrustc_driver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a4f39453cfbeab1c2220331f2eae8938165c964/src%2Flibrustc_driver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Fdriver.rs?ref=7a4f39453cfbeab1c2220331f2eae8938165c964", "patch": "@@ -38,7 +38,7 @@ use rustc_typeck as typeck;\n use rustc_privacy;\n use rustc_plugin::registry::Registry;\n use rustc_plugin as plugin;\n-use rustc_passes::{ast_validation, no_asm, loops, consts, static_recursion, hir_stats};\n+use rustc_passes::{self, ast_validation, no_asm, loops, consts, static_recursion, hir_stats};\n use rustc_const_eval::{self, check_match};\n use super::Compilation;\n use ::DefaultTransCrate;\n@@ -973,6 +973,7 @@ pub fn phase_3_run_analysis_passes<'tcx, F, R>(sess: &'tcx Session,\n     traits::provide(&mut local_providers);\n     reachable::provide(&mut local_providers);\n     rustc_const_eval::provide(&mut local_providers);\n+    rustc_passes::provide(&mut local_providers);\n     middle::region::provide(&mut local_providers);\n     cstore::provide_local(&mut local_providers);\n     lint::provide(&mut local_providers);"}, {"sha": "722d0cad238f4f3f3eead66a3eb54e39626ce9c9", "filename": "src/librustc_metadata/astencode.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/7a4f39453cfbeab1c2220331f2eae8938165c964/src%2Flibrustc_metadata%2Fastencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a4f39453cfbeab1c2220331f2eae8938165c964/src%2Flibrustc_metadata%2Fastencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fastencode.rs?ref=7a4f39453cfbeab1c2220331f2eae8938165c964", "patch": "@@ -56,7 +56,8 @@ impl<'a, 'b, 'tcx> IsolatedEncoder<'a, 'b, 'tcx> {\n         };\n \n         let lazy_body = self.lazy(body);\n-        let tables = self.tcx.body_tables(body_id);\n+        let body_owner_def_id = self.tcx.hir.body_owner_def_id(body_id);\n+        let tables = self.tcx.typeck_tables_of(body_owner_def_id);\n         let lazy_tables = self.lazy(tables);\n \n         let mut visitor = NestedBodyCollector {\n@@ -67,7 +68,7 @@ impl<'a, 'b, 'tcx> IsolatedEncoder<'a, 'b, 'tcx> {\n         let lazy_nested_bodies = self.lazy_seq_ref_from_slice(&visitor.bodies_found);\n \n         let rvalue_promotable_to_static =\n-            self.tcx.rvalue_promotable_to_static.borrow()[&body.value.id];\n+            self.tcx.const_is_rvalue_promotable_to_static(body_owner_def_id);\n \n         self.lazy(&Ast {\n             body: lazy_body,"}, {"sha": "9b3f16f1ab4326b06369a1301008912449f1bb50", "filename": "src/librustc_mir/build/matches/simplify.rs", "status": "modified", "additions": 1, "deletions": 7, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/7a4f39453cfbeab1c2220331f2eae8938165c964/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fsimplify.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a4f39453cfbeab1c2220331f2eae8938165c964/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fsimplify.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fsimplify.rs?ref=7a4f39453cfbeab1c2220331f2eae8938165c964", "patch": "@@ -26,7 +26,6 @@ use build::{BlockAnd, BlockAndExtension, Builder};\n use build::matches::{Binding, MatchPair, Candidate};\n use hair::*;\n use rustc::mir::*;\n-use rustc_data_structures::fx::FxHashMap;\n \n use std::mem;\n \n@@ -102,12 +101,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                 if self.hir.tcx().sess.features.borrow().never_type {\n                     let irrefutable = adt_def.variants.iter().enumerate().all(|(i, v)| {\n                         i == variant_index || {\n-                            let mut visited = FxHashMap::default();\n-                            let node_set = v.uninhabited_from(&mut visited,\n-                                                              self.hir.tcx(),\n-                                                              substs,\n-                                                              adt_def.adt_kind());\n-                            !node_set.is_empty()\n+                            self.hir.tcx().is_variant_uninhabited_from_all_modules(v, substs)\n                         }\n                     });\n                     if irrefutable {"}, {"sha": "d3202ba4ab53548bad0e0353c30e1eb62ef8e80d", "filename": "src/librustc_passes/consts.rs", "status": "modified", "additions": 76, "deletions": 36, "changes": 112, "blob_url": "https://github.com/rust-lang/rust/blob/7a4f39453cfbeab1c2220331f2eae8938165c964/src%2Flibrustc_passes%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a4f39453cfbeab1c2220331f2eae8938165c964/src%2Flibrustc_passes%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Fconsts.rs?ref=7a4f39453cfbeab1c2220331f2eae8938165c964", "patch": "@@ -39,20 +39,79 @@ use rustc::middle::mem_categorization as mc;\n use rustc::middle::mem_categorization::Categorization;\n use rustc::mir::transform::MirSource;\n use rustc::ty::{self, Ty, TyCtxt};\n+use rustc::ty::maps::{queries, Providers};\n use rustc::ty::subst::Substs;\n use rustc::traits::Reveal;\n use rustc::util::common::ErrorReported;\n-use rustc::util::nodemap::NodeSet;\n+use rustc::util::nodemap::{ItemLocalMap, NodeSet};\n use rustc::lint::builtin::CONST_ERR;\n-\n use rustc::hir::{self, PatKind, RangeEnd};\n+use std::rc::Rc;\n use syntax::ast;\n use syntax_pos::{Span, DUMMY_SP};\n use rustc::hir::intravisit::{self, Visitor, NestedVisitorMap};\n \n-use std::collections::hash_map::Entry;\n use std::cmp::Ordering;\n \n+pub fn provide(providers: &mut Providers) {\n+    *providers = Providers {\n+        rvalue_promotable_map,\n+        const_is_rvalue_promotable_to_static,\n+        ..*providers\n+    };\n+}\n+\n+pub fn check_crate<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>) {\n+    for &body_id in &tcx.hir.krate().body_ids {\n+        let def_id = tcx.hir.body_owner_def_id(body_id);\n+        tcx.const_is_rvalue_promotable_to_static(def_id);\n+    }\n+    tcx.sess.abort_if_errors();\n+}\n+\n+fn const_is_rvalue_promotable_to_static<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                                                  def_id: DefId)\n+                                                  -> bool\n+{\n+    assert!(def_id.is_local());\n+\n+    let node_id = tcx.hir.as_local_node_id(def_id)\n+                     .expect(\"rvalue_promotable_map invoked with non-local def-id\");\n+    let body_id = tcx.hir.body_owned_by(node_id);\n+    let body_hir_id = tcx.hir.node_to_hir_id(body_id.node_id);\n+    tcx.rvalue_promotable_map(def_id).contains_key(&body_hir_id.local_id)\n+}\n+\n+fn rvalue_promotable_map<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                                   def_id: DefId)\n+                                   -> Rc<ItemLocalMap<bool>>\n+{\n+    let outer_def_id = tcx.closure_base_def_id(def_id);\n+    if outer_def_id != def_id {\n+        return tcx.rvalue_promotable_map(outer_def_id);\n+    }\n+\n+    let mut visitor = CheckCrateVisitor {\n+        tcx,\n+        tables: &ty::TypeckTables::empty(None),\n+        in_fn: false,\n+        in_static: false,\n+        promotable: false,\n+        mut_rvalue_borrows: NodeSet(),\n+        param_env: ty::ParamEnv::empty(Reveal::UserFacing),\n+        identity_substs: Substs::empty(),\n+        result_map: ItemLocalMap(),\n+    };\n+\n+    // `def_id` should be a `Body` owner\n+    let node_id = tcx.hir.as_local_node_id(def_id)\n+                     .expect(\"rvalue_promotable_map invoked with non-local def-id\");\n+    let body_id = tcx.hir.body_owned_by(node_id);\n+    visitor.visit_nested_body(body_id);\n+\n+    Rc::new(visitor.result_map)\n+}\n+\n struct CheckCrateVisitor<'a, 'tcx: 'a> {\n     tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     in_fn: bool,\n@@ -62,6 +121,7 @@ struct CheckCrateVisitor<'a, 'tcx: 'a> {\n     param_env: ty::ParamEnv<'tcx>,\n     identity_substs: &'tcx Substs<'tcx>,\n     tables: &'a ty::TypeckTables<'tcx>,\n+    result_map: ItemLocalMap<bool>,\n }\n \n impl<'a, 'gcx> CheckCrateVisitor<'a, 'gcx> {\n@@ -109,18 +169,11 @@ impl<'a, 'gcx> CheckCrateVisitor<'a, 'gcx> {\n \n impl<'a, 'tcx> Visitor<'tcx> for CheckCrateVisitor<'a, 'tcx> {\n     fn nested_visit_map<'this>(&'this mut self) -> NestedVisitorMap<'this, 'tcx> {\n+        // note that we *do* visit nested bodies, because we override `visit_nested_body` below\n         NestedVisitorMap::None\n     }\n \n     fn visit_nested_body(&mut self, body_id: hir::BodyId) {\n-        match self.tcx.rvalue_promotable_to_static.borrow_mut().entry(body_id.node_id) {\n-            Entry::Occupied(_) => return,\n-            Entry::Vacant(entry) => {\n-                // Prevent infinite recursion on re-entry.\n-                entry.insert(false);\n-            }\n-        }\n-\n         let item_id = self.tcx.hir.body_owner(body_id);\n         let item_def_id = self.tcx.hir.local_def_id(item_id);\n \n@@ -151,7 +204,7 @@ impl<'a, 'tcx> Visitor<'tcx> for CheckCrateVisitor<'a, 'tcx> {\n         let tcx = self.tcx;\n         let param_env = self.param_env;\n         let region_scope_tree = self.tcx.region_scope_tree(item_def_id);\n-        euv::ExprUseVisitor::new(self, tcx, param_env, &region_scope_tree, self.tables)\n+        euv::ExprUseVisitor::new(self, tcx, param_env, &region_scope_tree, self.tables, None)\n             .consume_body(body);\n \n         self.visit_body(body);\n@@ -270,7 +323,7 @@ impl<'a, 'tcx> Visitor<'tcx> for CheckCrateVisitor<'a, 'tcx> {\n             }\n         }\n \n-        self.tcx.rvalue_promotable_to_static.borrow_mut().insert(ex.id, self.promotable);\n+        self.result_map.insert(ex.hir_id.local_id, self.promotable);\n         self.promotable &= outer;\n     }\n }\n@@ -371,16 +424,17 @@ fn check_expr<'a, 'tcx>(v: &mut CheckCrateVisitor<'a, 'tcx>, e: &hir::Expr, node\n                     let promotable = if v.tcx.trait_of_item(did).is_some() {\n                         // Don't peek inside trait associated constants.\n                         false\n-                    } else if let Some(node_id) = v.tcx.hir.as_local_node_id(did) {\n-                        match v.tcx.hir.maybe_body_owned_by(node_id) {\n-                            Some(body) => {\n-                                v.visit_nested_body(body);\n-                                v.tcx.rvalue_promotable_to_static.borrow()[&body.node_id]\n-                            }\n-                            None => false\n-                        }\n                     } else {\n-                        v.tcx.const_is_rvalue_promotable_to_static(did)\n+                        queries::const_is_rvalue_promotable_to_static::try_get(v.tcx, e.span, did)\n+                            .unwrap_or_else(|mut err| {\n+                                // A cycle between constants ought to be reported elsewhere.\n+                                err.cancel();\n+                                v.tcx.sess.delay_span_bug(\n+                                    e.span,\n+                                    &format!(\"cycle encountered during const qualification: {:?}\",\n+                                             did));\n+                                false\n+                            })\n                     };\n \n                     // Just in case the type is more specific than the definition,\n@@ -513,20 +567,6 @@ fn check_adjustments<'a, 'tcx>(v: &mut CheckCrateVisitor<'a, 'tcx>, e: &hir::Exp\n     }\n }\n \n-pub fn check_crate<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>) {\n-    tcx.hir.krate().visit_all_item_likes(&mut CheckCrateVisitor {\n-        tcx,\n-        tables: &ty::TypeckTables::empty(None),\n-        in_fn: false,\n-        in_static: false,\n-        promotable: false,\n-        mut_rvalue_borrows: NodeSet(),\n-        param_env: ty::ParamEnv::empty(Reveal::UserFacing),\n-        identity_substs: Substs::empty(),\n-    }.as_deep_visitor());\n-    tcx.sess.abort_if_errors();\n-}\n-\n impl<'a, 'gcx, 'tcx> euv::Delegate<'tcx> for CheckCrateVisitor<'a, 'gcx> {\n     fn consume(&mut self,\n                _consume_id: ast::NodeId,"}, {"sha": "9a150abea6691dd912aef649541dec6584df16f4", "filename": "src/librustc_passes/lib.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7a4f39453cfbeab1c2220331f2eae8938165c964/src%2Flibrustc_passes%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a4f39453cfbeab1c2220331f2eae8938165c964/src%2Flibrustc_passes%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Flib.rs?ref=7a4f39453cfbeab1c2220331f2eae8938165c964", "patch": "@@ -33,6 +33,8 @@ extern crate syntax;\n extern crate syntax_pos;\n extern crate rustc_errors as errors;\n \n+use rustc::ty::maps::Providers;\n+\n mod diagnostics;\n \n pub mod ast_validation;\n@@ -44,3 +46,7 @@ pub mod no_asm;\n pub mod static_recursion;\n \n __build_diagnostic_array! { librustc_passes, DIAGNOSTICS }\n+\n+pub fn provide(providers: &mut Providers) {\n+    consts::provide(providers);\n+}"}, {"sha": "244aa65a3d568e86a666eb28c000b0abc8618eb8", "filename": "src/test/run-pass/issue-44402.rs", "status": "added", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/7a4f39453cfbeab1c2220331f2eae8938165c964/src%2Ftest%2Frun-pass%2Fissue-44402.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a4f39453cfbeab1c2220331f2eae8938165c964/src%2Ftest%2Frun-pass%2Fissue-44402.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-44402.rs?ref=7a4f39453cfbeab1c2220331f2eae8938165c964", "patch": "@@ -0,0 +1,36 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(never_type)]\n+\n+// Regression test for inhabitedness check. The old\n+// cache used to cause us to incorrectly decide\n+// that `test_b` was invalid.\n+\n+struct Foo {\n+    field1: !,\n+    field2: Option<&'static Bar>,\n+}\n+\n+struct Bar {\n+    field1: &'static Foo\n+}\n+\n+fn test_a() {\n+    let x: Option<Foo> = None;\n+    match x { None => () }\n+}\n+\n+fn test_b() {\n+    let x: Option<Bar> = None;\n+    match x { None => () }\n+}\n+\n+fn main() { }"}, {"sha": "f1684f4c5acbe42f5f8eb94ba87a3408b9bd5bc9", "filename": "src/tools/toolstate.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7a4f39453cfbeab1c2220331f2eae8938165c964/src%2Ftools%2Ftoolstate.toml", "raw_url": "https://github.com/rust-lang/rust/raw/7a4f39453cfbeab1c2220331f2eae8938165c964/src%2Ftools%2Ftoolstate.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Ftoolstate.toml?ref=7a4f39453cfbeab1c2220331f2eae8938165c964", "patch": "@@ -26,7 +26,7 @@\n miri = \"Broken\"\n \n # ping @Manishearth @llogiq @mcarton @oli-obk\n-clippy = \"Compiling\"\n+clippy = \"Broken\"\n \n # ping @nrc\n rls = \"Testing\""}]}