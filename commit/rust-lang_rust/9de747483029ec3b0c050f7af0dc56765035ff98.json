{"sha": "9de747483029ec3b0c050f7af0dc56765035ff98", "node_id": "C_kwDOAAsO6NoAKDlkZTc0NzQ4MzAyOWVjM2IwYzA1MGY3YWYwZGM1Njc2NTAzNWZmOTg", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-07-29T01:35:15Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-07-29T01:35:15Z"}, "message": "Auto merge of #99512 - nikic:llvm-15-fixes, r=cuviper\n\nLLVM 15 compatibility fixes\n\nThese are LLVM 15 compatibility fixes split out from #99464. There are three changes here:\n\n * Emit elementtype attribtue for ldrex/strex intrinsics. This is requires as part of the opaque pointers migration.\n * Make more tests compatible with opaque pointers. These are either new or aren't run on x86.\n * Remove a test for `#[rustc_allocator]`. Since #99574 there are more requirement on the function signature. I dropped the test entirely, since we already test the effect of the attribute elsewhere.\n * The main change: When a worker thread emits an error, wait for other threads to finish before unwinding the main thread and exiting. Otherwise workers may end up using globals for which destructors have already been run. This was probably never quite correct, but became an active problem with LLVM 15, because it started using global dtors in critical places, as part of ManagedStatic removal.\n\nFixes #99432 (and probably also #95679).\n\nr? `@cuviper`", "tree": {"sha": "39ea2cc79b1ec1d3336979dc9a53ae4c586af4cc", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/39ea2cc79b1ec1d3336979dc9a53ae4c586af4cc"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9de747483029ec3b0c050f7af0dc56765035ff98", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9de747483029ec3b0c050f7af0dc56765035ff98", "html_url": "https://github.com/rust-lang/rust/commit/9de747483029ec3b0c050f7af0dc56765035ff98", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9de747483029ec3b0c050f7af0dc56765035ff98/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c8893cc5e5628645ed7df0b3185e845f928ca08a", "url": "https://api.github.com/repos/rust-lang/rust/commits/c8893cc5e5628645ed7df0b3185e845f928ca08a", "html_url": "https://github.com/rust-lang/rust/commit/c8893cc5e5628645ed7df0b3185e845f928ca08a"}, {"sha": "1433b2979b3b51b40df31f9bf5aeca5f31ea6685", "url": "https://api.github.com/repos/rust-lang/rust/commits/1433b2979b3b51b40df31f9bf5aeca5f31ea6685", "html_url": "https://github.com/rust-lang/rust/commit/1433b2979b3b51b40df31f9bf5aeca5f31ea6685"}], "stats": {"total": 206, "additions": 103, "deletions": 103}, "files": [{"sha": "9eb3574e77b004c4a383451c6c1d17a2df061a05", "filename": "compiler/rustc_codegen_llvm/src/abi.rs", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/9de747483029ec3b0c050f7af0dc56765035ff98/compiler%2Frustc_codegen_llvm%2Fsrc%2Fabi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9de747483029ec3b0c050f7af0dc56765035ff98/compiler%2Frustc_codegen_llvm%2Fsrc%2Fabi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fabi.rs?ref=9de747483029ec3b0c050f7af0dc56765035ff98", "patch": "@@ -569,6 +569,22 @@ impl<'ll, 'tcx> FnAbiLlvmExt<'ll, 'tcx> for FnAbi<'tcx, Ty<'tcx>> {\n                 &[cmse_nonsecure_call],\n             );\n         }\n+\n+        // Some intrinsics require that an elementtype attribute (with the pointee type of a\n+        // pointer argument) is added to the callsite.\n+        let element_type_index = unsafe { llvm::LLVMRustGetElementTypeArgIndex(callsite) };\n+        if element_type_index >= 0 {\n+            let arg_ty = self.args[element_type_index as usize].layout.ty;\n+            let pointee_ty = arg_ty.builtin_deref(true).expect(\"Must be pointer argument\").ty;\n+            let element_type_attr = unsafe {\n+                llvm::LLVMRustCreateElementTypeAttr(bx.llcx, bx.layout_of(pointee_ty).llvm_type(bx))\n+            };\n+            attributes::apply_to_callsite(\n+                callsite,\n+                llvm::AttributePlace::Argument(element_type_index as u32),\n+                &[element_type_attr],\n+            );\n+        }\n     }\n }\n "}, {"sha": "3139f93bfefaee9c0daf0c01734d5442983f8b9d", "filename": "compiler/rustc_codegen_llvm/src/llvm/ffi.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/9de747483029ec3b0c050f7af0dc56765035ff98/compiler%2Frustc_codegen_llvm%2Fsrc%2Fllvm%2Fffi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9de747483029ec3b0c050f7af0dc56765035ff98/compiler%2Frustc_codegen_llvm%2Fsrc%2Fllvm%2Fffi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fllvm%2Fffi.rs?ref=9de747483029ec3b0c050f7af0dc56765035ff98", "patch": "@@ -1192,6 +1192,7 @@ extern \"C\" {\n     pub fn LLVMRustCreateDereferenceableOrNullAttr(C: &Context, bytes: u64) -> &Attribute;\n     pub fn LLVMRustCreateByValAttr<'a>(C: &'a Context, ty: &'a Type) -> &'a Attribute;\n     pub fn LLVMRustCreateStructRetAttr<'a>(C: &'a Context, ty: &'a Type) -> &'a Attribute;\n+    pub fn LLVMRustCreateElementTypeAttr<'a>(C: &'a Context, ty: &'a Type) -> &'a Attribute;\n     pub fn LLVMRustCreateUWTableAttr(C: &Context, async_: bool) -> &Attribute;\n     pub fn LLVMRustCreateAllocSizeAttr(C: &Context, size_arg: u32) -> &Attribute;\n     pub fn LLVMRustCreateAllocKindAttr(C: &Context, size_arg: u64) -> &Attribute;\n@@ -2541,4 +2542,6 @@ extern \"C\" {\n \n     #[allow(improper_ctypes)]\n     pub fn LLVMRustGetMangledName(V: &Value, out: &RustString);\n+\n+    pub fn LLVMRustGetElementTypeArgIndex(CallSite: &Value) -> i32;\n }"}, {"sha": "1b5ad87107af6ded64e8d7f9bc05e4e102f534ed", "filename": "compiler/rustc_codegen_ssa/src/back/write.rs", "status": "modified", "additions": 44, "deletions": 27, "changes": 71, "blob_url": "https://github.com/rust-lang/rust/blob/9de747483029ec3b0c050f7af0dc56765035ff98/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Fwrite.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9de747483029ec3b0c050f7af0dc56765035ff98/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Fwrite.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Fwrite.rs?ref=9de747483029ec3b0c050f7af0dc56765035ff98", "patch": "@@ -37,6 +37,7 @@ use rustc_target::spec::{MergeFunctions, SanitizerSet};\n use std::any::Any;\n use std::fs;\n use std::io;\n+use std::marker::PhantomData;\n use std::mem;\n use std::path::{Path, PathBuf};\n use std::str;\n@@ -475,10 +476,13 @@ pub fn start_async_codegen<B: ExtraBackendMethods>(\n         metadata_module,\n         crate_info,\n \n-        coordinator_send,\n         codegen_worker_receive,\n         shared_emitter_main,\n-        future: coordinator_thread,\n+        coordinator: Coordinator {\n+            sender: coordinator_send,\n+            future: Some(coordinator_thread),\n+            phantom: PhantomData,\n+        },\n         output_filenames: tcx.output_filenames(()).clone(),\n     }\n }\n@@ -1273,6 +1277,7 @@ fn start_executing_work<B: ExtraBackendMethods>(\n         // work to be done.\n         while !codegen_done\n             || running > 0\n+            || main_thread_worker_state == MainThreadWorkerState::LLVMing\n             || (!codegen_aborted\n                 && !(work_items.is_empty()\n                     && needs_fat_lto.is_empty()\n@@ -1470,14 +1475,12 @@ fn start_executing_work<B: ExtraBackendMethods>(\n                     if !cgcx.opts.unstable_opts.no_parallel_llvm {\n                         helper.request_token();\n                     }\n-                    assert!(!codegen_aborted);\n                     assert_eq!(main_thread_worker_state, MainThreadWorkerState::Codegenning);\n                     main_thread_worker_state = MainThreadWorkerState::Idle;\n                 }\n \n                 Message::CodegenComplete => {\n                     codegen_done = true;\n-                    assert!(!codegen_aborted);\n                     assert_eq!(main_thread_worker_state, MainThreadWorkerState::Codegenning);\n                     main_thread_worker_state = MainThreadWorkerState::Idle;\n                 }\n@@ -1489,10 +1492,8 @@ fn start_executing_work<B: ExtraBackendMethods>(\n                 // then conditions above will ensure no more work is spawned but\n                 // we'll keep executing this loop until `running` hits 0.\n                 Message::CodegenAborted => {\n-                    assert!(!codegen_aborted);\n                     codegen_done = true;\n                     codegen_aborted = true;\n-                    assert_eq!(main_thread_worker_state, MainThreadWorkerState::Codegenning);\n                 }\n                 Message::Done { result: Ok(compiled_module), worker_id } => {\n                     free_worker(worker_id);\n@@ -1532,13 +1533,20 @@ fn start_executing_work<B: ExtraBackendMethods>(\n                 Message::Done { result: Err(None), worker_id: _ } => {\n                     bug!(\"worker thread panicked\");\n                 }\n-                Message::Done { result: Err(Some(WorkerFatalError)), worker_id: _ } => {\n-                    return Err(());\n+                Message::Done { result: Err(Some(WorkerFatalError)), worker_id } => {\n+                    // Similar to CodegenAborted, wait for remaining work to finish.\n+                    free_worker(worker_id);\n+                    codegen_done = true;\n+                    codegen_aborted = true;\n                 }\n                 Message::CodegenItem => bug!(\"the coordinator should not receive codegen requests\"),\n             }\n         }\n \n+        if codegen_aborted {\n+            return Err(());\n+        }\n+\n         let needs_link = mem::take(&mut needs_link);\n         if !needs_link.is_empty() {\n             assert!(compiled_modules.is_empty());\n@@ -1828,25 +1836,47 @@ impl SharedEmitterMain {\n     }\n }\n \n+pub struct Coordinator<B: ExtraBackendMethods> {\n+    pub sender: Sender<Box<dyn Any + Send>>,\n+    future: Option<thread::JoinHandle<Result<CompiledModules, ()>>>,\n+    // Only used for the Message type.\n+    phantom: PhantomData<B>,\n+}\n+\n+impl<B: ExtraBackendMethods> Coordinator<B> {\n+    fn join(mut self) -> std::thread::Result<Result<CompiledModules, ()>> {\n+        self.future.take().unwrap().join()\n+    }\n+}\n+\n+impl<B: ExtraBackendMethods> Drop for Coordinator<B> {\n+    fn drop(&mut self) {\n+        if let Some(future) = self.future.take() {\n+            // If we haven't joined yet, signal to the coordinator that it should spawn no more\n+            // work, and wait for worker threads to finish.\n+            drop(self.sender.send(Box::new(Message::CodegenAborted::<B>)));\n+            drop(future.join());\n+        }\n+    }\n+}\n+\n pub struct OngoingCodegen<B: ExtraBackendMethods> {\n     pub backend: B,\n     pub metadata: EncodedMetadata,\n     pub metadata_module: Option<CompiledModule>,\n     pub crate_info: CrateInfo,\n-    pub coordinator_send: Sender<Box<dyn Any + Send>>,\n     pub codegen_worker_receive: Receiver<Message<B>>,\n     pub shared_emitter_main: SharedEmitterMain,\n-    pub future: thread::JoinHandle<Result<CompiledModules, ()>>,\n     pub output_filenames: Arc<OutputFilenames>,\n+    pub coordinator: Coordinator<B>,\n }\n \n impl<B: ExtraBackendMethods> OngoingCodegen<B> {\n     pub fn join(self, sess: &Session) -> (CodegenResults, FxHashMap<WorkProductId, WorkProduct>) {\n         let _timer = sess.timer(\"finish_ongoing_codegen\");\n \n         self.shared_emitter_main.check(sess, true);\n-        let future = self.future;\n-        let compiled_modules = sess.time(\"join_worker_thread\", || match future.join() {\n+        let compiled_modules = sess.time(\"join_worker_thread\", || match self.coordinator.join() {\n             Ok(Ok(compiled_modules)) => compiled_modules,\n             Ok(Err(())) => {\n                 sess.abort_if_errors();\n@@ -1894,26 +1924,13 @@ impl<B: ExtraBackendMethods> OngoingCodegen<B> {\n \n         // These are generally cheap and won't throw off scheduling.\n         let cost = 0;\n-        submit_codegened_module_to_llvm(&self.backend, &self.coordinator_send, module, cost);\n+        submit_codegened_module_to_llvm(&self.backend, &self.coordinator.sender, module, cost);\n     }\n \n     pub fn codegen_finished(&self, tcx: TyCtxt<'_>) {\n         self.wait_for_signal_to_codegen_item();\n         self.check_for_errors(tcx.sess);\n-        drop(self.coordinator_send.send(Box::new(Message::CodegenComplete::<B>)));\n-    }\n-\n-    /// Consumes this context indicating that codegen was entirely aborted, and\n-    /// we need to exit as quickly as possible.\n-    ///\n-    /// This method blocks the current thread until all worker threads have\n-    /// finished, and all worker threads should have exited or be real close to\n-    /// exiting at this point.\n-    pub fn codegen_aborted(self) {\n-        // Signal to the coordinator it should spawn no more work and start\n-        // shutdown.\n-        drop(self.coordinator_send.send(Box::new(Message::CodegenAborted::<B>)));\n-        drop(self.future.join());\n+        drop(self.coordinator.sender.send(Box::new(Message::CodegenComplete::<B>)));\n     }\n \n     pub fn check_for_errors(&self, sess: &Session) {"}, {"sha": "a840b27097492d2fe253255afe85d809ef4cd621", "filename": "compiler/rustc_codegen_ssa/src/base.rs", "status": "modified", "additions": 4, "deletions": 54, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/9de747483029ec3b0c050f7af0dc56765035ff98/compiler%2Frustc_codegen_ssa%2Fsrc%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9de747483029ec3b0c050f7af0dc56765035ff98/compiler%2Frustc_codegen_ssa%2Fsrc%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fbase.rs?ref=9de747483029ec3b0c050f7af0dc56765035ff98", "patch": "@@ -39,7 +39,6 @@ use rustc_target::abi::{Align, VariantIdx};\n \n use std::collections::BTreeSet;\n use std::convert::TryFrom;\n-use std::ops::{Deref, DerefMut};\n use std::time::{Duration, Instant};\n \n use itertools::Itertools;\n@@ -583,7 +582,6 @@ pub fn codegen_crate<B: ExtraBackendMethods>(\n         metadata_module,\n         codegen_units.len(),\n     );\n-    let ongoing_codegen = AbortCodegenOnDrop::<B>(Some(ongoing_codegen));\n \n     // Codegen an allocator shim, if necessary.\n     //\n@@ -704,7 +702,7 @@ pub fn codegen_crate<B: ExtraBackendMethods>(\n \n                 submit_codegened_module_to_llvm(\n                     &backend,\n-                    &ongoing_codegen.coordinator_send,\n+                    &ongoing_codegen.coordinator.sender,\n                     module,\n                     cost,\n                 );\n@@ -714,7 +712,7 @@ pub fn codegen_crate<B: ExtraBackendMethods>(\n                 submit_pre_lto_module_to_llvm(\n                     &backend,\n                     tcx,\n-                    &ongoing_codegen.coordinator_send,\n+                    &ongoing_codegen.coordinator.sender,\n                     CachedModuleCodegen {\n                         name: cgu.name().to_string(),\n                         source: cgu.previous_work_product(tcx),\n@@ -725,7 +723,7 @@ pub fn codegen_crate<B: ExtraBackendMethods>(\n             CguReuse::PostLto => {\n                 submit_post_lto_module_to_llvm(\n                     &backend,\n-                    &ongoing_codegen.coordinator_send,\n+                    &ongoing_codegen.coordinator.sender,\n                     CachedModuleCodegen {\n                         name: cgu.name().to_string(),\n                         source: cgu.previous_work_product(tcx),\n@@ -752,55 +750,7 @@ pub fn codegen_crate<B: ExtraBackendMethods>(\n     }\n \n     ongoing_codegen.check_for_errors(tcx.sess);\n-\n-    ongoing_codegen.into_inner()\n-}\n-\n-/// A curious wrapper structure whose only purpose is to call `codegen_aborted`\n-/// when it's dropped abnormally.\n-///\n-/// In the process of working on rust-lang/rust#55238 a mysterious segfault was\n-/// stumbled upon. The segfault was never reproduced locally, but it was\n-/// suspected to be related to the fact that codegen worker threads were\n-/// sticking around by the time the main thread was exiting, causing issues.\n-///\n-/// This structure is an attempt to fix that issue where the `codegen_aborted`\n-/// message will block until all workers have finished. This should ensure that\n-/// even if the main codegen thread panics we'll wait for pending work to\n-/// complete before returning from the main thread, hopefully avoiding\n-/// segfaults.\n-///\n-/// If you see this comment in the code, then it means that this workaround\n-/// worked! We may yet one day track down the mysterious cause of that\n-/// segfault...\n-struct AbortCodegenOnDrop<B: ExtraBackendMethods>(Option<OngoingCodegen<B>>);\n-\n-impl<B: ExtraBackendMethods> AbortCodegenOnDrop<B> {\n-    fn into_inner(mut self) -> OngoingCodegen<B> {\n-        self.0.take().unwrap()\n-    }\n-}\n-\n-impl<B: ExtraBackendMethods> Deref for AbortCodegenOnDrop<B> {\n-    type Target = OngoingCodegen<B>;\n-\n-    fn deref(&self) -> &OngoingCodegen<B> {\n-        self.0.as_ref().unwrap()\n-    }\n-}\n-\n-impl<B: ExtraBackendMethods> DerefMut for AbortCodegenOnDrop<B> {\n-    fn deref_mut(&mut self) -> &mut OngoingCodegen<B> {\n-        self.0.as_mut().unwrap()\n-    }\n-}\n-\n-impl<B: ExtraBackendMethods> Drop for AbortCodegenOnDrop<B> {\n-    fn drop(&mut self) {\n-        if let Some(codegen) = self.0.take() {\n-            codegen.codegen_aborted();\n-        }\n-    }\n+    ongoing_codegen\n }\n \n impl CrateInfo {"}, {"sha": "c333738ded4582f6fe35854ddc68ee43238e16b3", "filename": "compiler/rustc_llvm/llvm-wrapper/RustWrapper.cpp", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/9de747483029ec3b0c050f7af0dc56765035ff98/compiler%2Frustc_llvm%2Fllvm-wrapper%2FRustWrapper.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/9de747483029ec3b0c050f7af0dc56765035ff98/compiler%2Frustc_llvm%2Fllvm-wrapper%2FRustWrapper.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_llvm%2Fllvm-wrapper%2FRustWrapper.cpp?ref=9de747483029ec3b0c050f7af0dc56765035ff98", "patch": "@@ -6,6 +6,7 @@\n #include \"llvm/IR/GlobalVariable.h\"\n #include \"llvm/IR/Instructions.h\"\n #include \"llvm/IR/Intrinsics.h\"\n+#include \"llvm/IR/IntrinsicsARM.h\"\n #include \"llvm/IR/Mangler.h\"\n #include \"llvm/Object/Archive.h\"\n #include \"llvm/Object/COFFImportFile.h\"\n@@ -300,6 +301,14 @@ extern \"C\" LLVMAttributeRef LLVMRustCreateStructRetAttr(LLVMContextRef C, LLVMTy\n   return wrap(Attribute::getWithStructRetType(*unwrap(C), unwrap(Ty)));\n }\n \n+extern \"C\" LLVMAttributeRef LLVMRustCreateElementTypeAttr(LLVMContextRef C, LLVMTypeRef Ty) {\n+#if LLVM_VERSION_GE(15, 0)\n+  return wrap(Attribute::get(*unwrap(C), Attribute::ElementType, unwrap(Ty)));\n+#else\n+  report_fatal_error(\"Should not be needed on LLVM < 15\");\n+#endif\n+}\n+\n extern \"C\" LLVMAttributeRef LLVMRustCreateUWTableAttr(LLVMContextRef C, bool Async) {\n #if LLVM_VERSION_LT(15, 0)\n   return wrap(Attribute::get(*unwrap(C), Attribute::UWTable));\n@@ -1943,3 +1952,16 @@ extern \"C\" LLVMValueRef LLVMGetAggregateElement(LLVMValueRef C, unsigned Idx) {\n     return wrap(unwrap<Constant>(C)->getAggregateElement(Idx));\n }\n #endif\n+\n+extern \"C\" int32_t LLVMRustGetElementTypeArgIndex(LLVMValueRef CallSite) {\n+#if LLVM_VERSION_GE(15, 0)\n+    auto *CB = unwrap<CallBase>(CallSite);\n+    switch (CB->getIntrinsicID()) {\n+        case Intrinsic::arm_ldrex:\n+            return 0;\n+        case Intrinsic::arm_strex:\n+            return 1;\n+    }\n+#endif\n+    return -1;\n+}"}, {"sha": "bc650ebf5eeb6d1026f971532166db1bfaa1f380", "filename": "src/test/codegen/function-arguments.rs", "status": "modified", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/9de747483029ec3b0c050f7af0dc56765035ff98/src%2Ftest%2Fcodegen%2Ffunction-arguments.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9de747483029ec3b0c050f7af0dc56765035ff98/src%2Ftest%2Fcodegen%2Ffunction-arguments.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen%2Ffunction-arguments.rs?ref=9de747483029ec3b0c050f7af0dc56765035ff98", "patch": "@@ -233,10 +233,3 @@ pub fn enum_id_1(x: Option<Result<u16, u16>>) -> Option<Result<u16, u16>> {\n pub fn enum_id_2(x: Option<u8>) -> Option<u8> {\n   x\n }\n-\n-// CHECK: noalias {{i8\\*|ptr}} @allocator()\n-#[no_mangle]\n-#[rustc_allocator]\n-pub fn allocator() -> *const i8 {\n-  std::ptr::null()\n-}"}, {"sha": "df7e88f08c733338def809d89788ddce3d9942b8", "filename": "src/test/codegen/repr-transparent-aggregates-2.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/9de747483029ec3b0c050f7af0dc56765035ff98/src%2Ftest%2Fcodegen%2Frepr-transparent-aggregates-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9de747483029ec3b0c050f7af0dc56765035ff98/src%2Ftest%2Fcodegen%2Frepr-transparent-aggregates-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen%2Frepr-transparent-aggregates-2.rs?ref=9de747483029ec3b0c050f7af0dc56765035ff98", "patch": "@@ -37,19 +37,19 @@ pub enum TeBigS {\n     Variant(BigS),\n }\n \n-// CHECK: define void @test_BigS(%BigS* [[BIGS_RET_ATTRS1:.*]] sret(%BigS) [[BIGS_RET_ATTRS2:.*]], [16 x i32]\n+// CHECK: define void @test_BigS({{%BigS\\*|ptr}} [[BIGS_RET_ATTRS1:.*]] sret(%BigS) [[BIGS_RET_ATTRS2:.*]], [16 x i32]\n #[no_mangle]\n pub extern fn test_BigS(_: BigS) -> BigS { loop {} }\n \n-// CHECK: define void @test_TsBigS(%TsBigS* [[BIGS_RET_ATTRS1]] sret(%TsBigS) [[BIGS_RET_ATTRS2]], [16 x i32]\n+// CHECK: define void @test_TsBigS({{%TsBigS\\*|ptr}} [[BIGS_RET_ATTRS1]] sret(%TsBigS) [[BIGS_RET_ATTRS2]], [16 x i32]\n #[no_mangle]\n pub extern fn test_TsBigS(_: TsBigS) -> TsBigS { loop {} }\n \n-// CHECK: define void @test_TuBigS(%TuBigS* [[BIGS_RET_ATTRS1]] sret(%TuBigS) [[BIGS_RET_ATTRS2]], [16 x i32]\n+// CHECK: define void @test_TuBigS({{%TuBigS\\*|ptr}} [[BIGS_RET_ATTRS1]] sret(%TuBigS) [[BIGS_RET_ATTRS2]], [16 x i32]\n #[no_mangle]\n pub extern fn test_TuBigS(_: TuBigS) -> TuBigS { loop {} }\n \n-// CHECK: define void @test_TeBigS(%\"TeBigS::Variant\"* [[BIGS_RET_ATTRS1]] sret(%\"TeBigS::Variant\") [[BIGS_RET_ATTRS2]], [16 x i32]\n+// CHECK: define void @test_TeBigS({{%\"TeBigS::Variant\"\\*|ptr}} [[BIGS_RET_ATTRS1]] sret(%\"TeBigS::Variant\") [[BIGS_RET_ATTRS2]], [16 x i32]\n #[no_mangle]\n pub extern fn test_TeBigS(_: TeBigS) -> TeBigS { loop {} }\n \n@@ -73,18 +73,18 @@ pub enum TeBigU {\n     Variant(BigU),\n }\n \n-// CHECK: define void @test_BigU(%BigU* [[BIGU_RET_ATTRS1:.*]] sret(%BigU) [[BIGU_RET_ATTRS2:.*]], [16 x i32]\n+// CHECK: define void @test_BigU({{%BigU\\*|ptr}} [[BIGU_RET_ATTRS1:.*]] sret(%BigU) [[BIGU_RET_ATTRS2:.*]], [16 x i32]\n #[no_mangle]\n pub extern fn test_BigU(_: BigU) -> BigU { loop {} }\n \n-// CHECK: define void @test_TsBigU(%TsBigU* [[BIGU_RET_ATTRS1]] sret(%TsBigU) [[BIGU_RET_ATTRS2]], [16 x i32]\n+// CHECK: define void @test_TsBigU({{%TsBigU\\*|ptr}} [[BIGU_RET_ATTRS1]] sret(%TsBigU) [[BIGU_RET_ATTRS2]], [16 x i32]\n #[no_mangle]\n pub extern fn test_TsBigU(_: TsBigU) -> TsBigU { loop {} }\n \n-// CHECK: define void @test_TuBigU(%TuBigU* [[BIGU_RET_ATTRS1]] sret(%TuBigU) [[BIGU_RET_ATTRS2]], [16 x i32]\n+// CHECK: define void @test_TuBigU({{%TuBigU\\*|ptr}} [[BIGU_RET_ATTRS1]] sret(%TuBigU) [[BIGU_RET_ATTRS2]], [16 x i32]\n #[no_mangle]\n pub extern fn test_TuBigU(_: TuBigU) -> TuBigU { loop {} }\n \n-// CHECK: define void @test_TeBigU(%\"TeBigU::Variant\"* [[BIGU_RET_ATTRS1]] sret(%\"TeBigU::Variant\") [[BIGU_RET_ATTRS2]], [16 x i32]\n+// CHECK: define void @test_TeBigU({{%\"TeBigU::Variant\"\\*|ptr}} [[BIGU_RET_ATTRS1]] sret(%\"TeBigU::Variant\") [[BIGU_RET_ATTRS2]], [16 x i32]\n #[no_mangle]\n pub extern fn test_TeBigU(_: TeBigU) -> TeBigU { loop {} }"}, {"sha": "8be5186de9e773781e950955272cefc85d29a2ce", "filename": "src/test/codegen/sanitizer-cfi-emit-type-checks.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/9de747483029ec3b0c050f7af0dc56765035ff98/src%2Ftest%2Fcodegen%2Fsanitizer-cfi-emit-type-checks.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9de747483029ec3b0c050f7af0dc56765035ff98/src%2Ftest%2Fcodegen%2Fsanitizer-cfi-emit-type-checks.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen%2Fsanitizer-cfi-emit-type-checks.rs?ref=9de747483029ec3b0c050f7af0dc56765035ff98", "patch": "@@ -8,11 +8,10 @@\n pub fn foo(f: fn(i32) -> i32, arg: i32) -> i32 {\n     // CHECK-LABEL: define{{.*}}foo{{.*}}!type !{{[0-9]+}}\n     // CHECK:       start:\n-    // CHECK-NEXT:  %0 = bitcast i32 (i32)* %f to i8*\n-    // CHECK-NEXT:  %1 = call i1 @llvm.type.test(i8* %0, metadata !\"{{[[:print:]]+}}\")\n-    // CHECK-NEXT:  br i1 %1, label %type_test.pass, label %type_test.fail\n+    // CHECK:       [[TT:%.+]] = call i1 @llvm.type.test({{i8\\*|ptr}} {{%f|%0}}, metadata !\"{{[[:print:]]+}}\")\n+    // CHECK-NEXT:  br i1 [[TT]], label %type_test.pass, label %type_test.fail\n     // CHECK:       type_test.pass:\n-    // CHECK-NEXT:  %2 = call i32 %f(i32 %arg)\n+    // CHECK-NEXT:  {{%.+}} = call i32 %f(i32 %arg)\n     // CHECK-NEXT:  br label %bb1\n     // CHECK:       type_test.fail:\n     // CHECK-NEXT:  call void @llvm.trap()"}, {"sha": "bafc4c6592f52c9d7cfe6ab307f34d83fef78956", "filename": "src/test/codegen/sanitizer-cfi-emit-type-metadata-itanium-cxx-abi.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/9de747483029ec3b0c050f7af0dc56765035ff98/src%2Ftest%2Fcodegen%2Fsanitizer-cfi-emit-type-metadata-itanium-cxx-abi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9de747483029ec3b0c050f7af0dc56765035ff98/src%2Ftest%2Fcodegen%2Fsanitizer-cfi-emit-type-metadata-itanium-cxx-abi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen%2Fsanitizer-cfi-emit-type-metadata-itanium-cxx-abi.rs?ref=9de747483029ec3b0c050f7af0dc56765035ff98", "patch": "@@ -8,21 +8,21 @@\n pub fn foo(f: fn(i32) -> i32, arg: i32) -> i32 {\n     // CHECK-LABEL: define{{.*}}foo\n     // CHECK-SAME: {{.*}}!type ![[TYPE1:[0-9]+]]\n-    // CHECK:       %1 = call i1 @llvm.type.test(i8* %0, metadata !\"_ZTSFu3i32S_E\")\n+    // CHECK:       call i1 @llvm.type.test({{i8\\*|ptr}} {{%f|%0}}, metadata !\"_ZTSFu3i32S_E\")\n     f(arg)\n }\n \n pub fn bar(f: fn(i32, i32) -> i32, arg1: i32, arg2: i32) -> i32 {\n     // CHECK-LABEL: define{{.*}}bar\n     // CHECK-SAME: {{.*}}!type ![[TYPE2:[0-9]+]]\n-    // CHECK:       %1 = call i1 @llvm.type.test(i8* %0, metadata !\"_ZTSFu3i32S_S_E\")\n+    // CHECK:       call i1 @llvm.type.test({{i8\\*|ptr}} {{%f|%0}}, metadata !\"_ZTSFu3i32S_S_E\")\n     f(arg1, arg2)\n }\n \n pub fn baz(f: fn(i32, i32, i32) -> i32, arg1: i32, arg2: i32, arg3: i32) -> i32 {\n     // CHECK-LABEL: define{{.*}}baz\n     // CHECK-SAME: {{.*}}!type ![[TYPE3:[0-9]+]]\n-    // CHECK:       %1 = call i1 @llvm.type.test(i8* %0, metadata !\"_ZTSFu3i32S_S_S_E\")\n+    // CHECK:       call i1 @llvm.type.test({{i8\\*|ptr}} {{%f|%0}}, metadata !\"_ZTSFu3i32S_S_S_E\")\n     f(arg1, arg2, arg3)\n }\n "}]}