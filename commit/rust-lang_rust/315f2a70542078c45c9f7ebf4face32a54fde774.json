{"sha": "315f2a70542078c45c9f7ebf4face32a54fde774", "node_id": "MDY6Q29tbWl0NzI0NzEyOjMxNWYyYTcwNTQyMDc4YzQ1YzlmN2ViZjRmYWNlMzJhNTRmZGU3NzQ=", "commit": {"author": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2014-06-25T01:22:21Z"}, "committer": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2014-06-25T06:27:41Z"}, "message": "librustc: Don't try to perform the magical\nvector-reference-to-unsafe-pointer-to-element cast if the type to be\ncasted to is not fully specified.\n\nThis is a conservative change to fix the user-visible symptoms of the\nissue. A more flexible treatment would delay cast checks to after\nfunction typechecking.\n\nThis can break code that did:\n\n    let x: *u8 = &([0, 0]) as *_;\n\nChange this code to:\n\n    let x: *u8 = &([0, 0]) as *u8;\n\nCloses #14893.\n\n[breaking-change]", "tree": {"sha": "14bdeff6104a5799976cd6573423820da996bda3", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/14bdeff6104a5799976cd6573423820da996bda3"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/315f2a70542078c45c9f7ebf4face32a54fde774", "comment_count": 5, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/315f2a70542078c45c9f7ebf4face32a54fde774", "html_url": "https://github.com/rust-lang/rust/commit/315f2a70542078c45c9f7ebf4face32a54fde774", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/315f2a70542078c45c9f7ebf4face32a54fde774/comments", "author": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7a93beef7f692b34168ad69633f56483d38ad8fc", "url": "https://api.github.com/repos/rust-lang/rust/commits/7a93beef7f692b34168ad69633f56483d38ad8fc", "html_url": "https://github.com/rust-lang/rust/commit/7a93beef7f692b34168ad69633f56483d38ad8fc"}], "stats": {"total": 320, "additions": 191, "deletions": 129}, "files": [{"sha": "0b35eab5679f02cef52235797d9bf6ae85eaeb5e", "filename": "src/librustc/middle/typeck/check/mod.rs", "status": "modified", "additions": 160, "deletions": 129, "changes": 289, "blob_url": "https://github.com/rust-lang/rust/blob/315f2a70542078c45c9f7ebf4face32a54fde774/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/315f2a70542078c45c9f7ebf4face32a54fde774/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs?ref=315f2a70542078c45c9f7ebf4face32a54fde774", "patch": "@@ -1060,6 +1060,164 @@ fn compare_impl_method(tcx: &ty::ctxt,\n     }\n }\n \n+fn check_cast(fcx: &FnCtxt,\n+              e: &ast::Expr,\n+              t: &ast::Ty,\n+              id: ast::NodeId,\n+              span: Span) {\n+    // Find the type of `e`. Supply hints based on the type we are casting to,\n+    // if appropriate.\n+    let t_1 = fcx.to_ty(t);\n+    let t_1 = structurally_resolved_type(fcx, span, t_1);\n+\n+    if ty::type_is_scalar(t_1) {\n+        // Supply the type as a hint so as to influence integer\n+        // literals and other things that might care.\n+        check_expr_with_hint(fcx, e, t_1)\n+    } else {\n+        check_expr(fcx, e)\n+    }\n+\n+    let t_e = fcx.expr_ty(e);\n+\n+    debug!(\"t_1={}\", fcx.infcx().ty_to_str(t_1));\n+    debug!(\"t_e={}\", fcx.infcx().ty_to_str(t_e));\n+\n+    if ty::type_is_error(t_e) {\n+        fcx.write_error(id);\n+        return\n+    }\n+    if ty::type_is_bot(t_e) {\n+        fcx.write_bot(id);\n+        return\n+    }\n+\n+    if ty::type_is_trait(t_1) {\n+        // This will be looked up later on.\n+        fcx.write_ty(id, t_1);\n+        return\n+    }\n+\n+    let t_1 = structurally_resolved_type(fcx, span, t_1);\n+    let t_e = structurally_resolved_type(fcx, span, t_e);\n+\n+    if ty::type_is_nil(t_e) {\n+        fcx.type_error_message(span, |actual| {\n+            format!(\"cast from nil: `{}` as `{}`\",\n+                    actual,\n+                    fcx.infcx().ty_to_str(t_1))\n+        }, t_e, None);\n+    } else if ty::type_is_nil(t_1) {\n+        fcx.type_error_message(span, |actual| {\n+            format!(\"cast to nil: `{}` as `{}`\",\n+                    actual,\n+                    fcx.infcx().ty_to_str(t_1))\n+        }, t_e, None);\n+    }\n+\n+    let t_1_is_scalar = ty::type_is_scalar(t_1);\n+    let t_1_is_char = ty::type_is_char(t_1);\n+    let t_1_is_bare_fn = ty::type_is_bare_fn(t_1);\n+    let t_1_is_float = ty::type_is_floating_point(t_1);\n+\n+    // casts to scalars other than `char` and `bare fn` are trivial\n+    let t_1_is_trivial = t_1_is_scalar && !t_1_is_char && !t_1_is_bare_fn;\n+    if ty::type_is_c_like_enum(fcx.tcx(), t_e) && t_1_is_trivial {\n+        if t_1_is_float {\n+            fcx.type_error_message(span, |actual| {\n+                format!(\"illegal cast; cast through an \\\n+                         integer first: `{}` as `{}`\",\n+                        actual,\n+                        fcx.infcx().ty_to_str(t_1))\n+            }, t_e, None);\n+        }\n+        // casts from C-like enums are allowed\n+    } else if t_1_is_char {\n+        let t_e = fcx.infcx().resolve_type_vars_if_possible(t_e);\n+        if ty::get(t_e).sty != ty::ty_uint(ast::TyU8) {\n+            fcx.type_error_message(span, |actual| {\n+                format!(\"only `u8` can be cast as \\\n+                         `char`, not `{}`\", actual)\n+            }, t_e, None);\n+        }\n+    } else if ty::get(t_1).sty == ty::ty_bool {\n+        fcx.tcx()\n+           .sess\n+           .span_err(span,\n+                     \"cannot cast as `bool`, compare with zero instead\");\n+    } else if ty::type_is_region_ptr(t_e) && ty::type_is_unsafe_ptr(t_1) {\n+        fn is_vec(t: ty::t) -> bool {\n+            match ty::get(t).sty {\n+                ty::ty_vec(..) => true,\n+                ty::ty_ptr(ty::mt{ty: t, ..}) |\n+                ty::ty_rptr(_, ty::mt{ty: t, ..}) |\n+                ty::ty_box(t) |\n+                ty::ty_uniq(t) => {\n+                    match ty::get(t).sty {\n+                        ty::ty_vec(_, None) => true,\n+                        _ => false,\n+                    }\n+                }\n+                _ => false\n+            }\n+        }\n+        fn types_compatible(fcx: &FnCtxt, sp: Span,\n+                            t1: ty::t, t2: ty::t) -> bool {\n+            if !is_vec(t1) {\n+                // If the type being casted from is not a vector, this special\n+                // case does not apply.\n+                return false\n+            }\n+            if ty::type_needs_infer(t2) {\n+                // This prevents this special case from going off when casting\n+                // to a type that isn't fully specified; e.g. `as *_`. (Issue\n+                // #14893.)\n+                return false\n+            }\n+\n+            let el = ty::sequence_element_type(fcx.tcx(), t1);\n+            infer::mk_eqty(fcx.infcx(),\n+                           false,\n+                           infer::Misc(sp),\n+                           el,\n+                           t2).is_ok()\n+        }\n+\n+        // Due to the limitations of LLVM global constants,\n+        // region pointers end up pointing at copies of\n+        // vector elements instead of the original values.\n+        // To allow unsafe pointers to work correctly, we\n+        // need to special-case obtaining an unsafe pointer\n+        // from a region pointer to a vector.\n+\n+        /* this cast is only allowed from &[T] to *T or\n+        &T to *T. */\n+        match (&ty::get(t_e).sty, &ty::get(t_1).sty) {\n+            (&ty::ty_rptr(_, ty::mt { ty: mt1, mutbl: ast::MutImmutable }),\n+             &ty::ty_ptr(ty::mt { ty: mt2, mutbl: ast::MutImmutable }))\n+            if types_compatible(fcx, e.span, mt1, mt2) => {\n+                /* this case is allowed */\n+            }\n+            _ => {\n+                demand::coerce(fcx, e.span, t_1, &*e);\n+            }\n+        }\n+    } else if !(ty::type_is_scalar(t_e) && t_1_is_trivial) {\n+        /*\n+        If more type combinations should be supported than are\n+        supported here, then file an enhancement issue and\n+        record the issue number in this comment.\n+        */\n+        fcx.type_error_message(span, |actual| {\n+            format!(\"non-scalar cast: `{}` as `{}`\",\n+                    actual,\n+                    fcx.infcx().ty_to_str(t_1))\n+        }, t_e, None);\n+    }\n+\n+    fcx.write_ty(id, t_1);\n+}\n+\n impl<'a> AstConv for FnCtxt<'a> {\n     fn tcx<'a>(&'a self) -> &'a ty::ctxt { self.ccx.tcx }\n \n@@ -3049,11 +3207,8 @@ fn check_expr_with_unifier(fcx: &FnCtxt,\n             fcx.write_bot(id);\n         }\n       }\n-      ast::ExprCast(expr_from, t) => {\n-        let ty_to = fcx.to_ty(t);\n-        debug!(\"ExprCast ty_to={}\", fcx.infcx().ty_to_str(ty_to));\n-        check_cast(fcx, expr_from, ty_to);\n-        fcx.write_ty(id, ty_to);\n+      ast::ExprCast(ref e, ref t) => {\n+        check_cast(fcx, &**e, &**t, id, expr.span);\n       }\n       ast::ExprVec(ref args) => {\n         let t: ty::t = fcx.infcx().next_ty_var();\n@@ -3248,130 +3403,6 @@ impl Repr for Expectation {\n     }\n }\n \n-fn check_cast(fcx: &FnCtxt, expr_from: Gc<ast::Expr>, ty_to: ty::t) {\n-    // Find the type of `expr_from`. Supply hints based on the type\n-    // we are casting to, if appropriate.\n-    let ty_to = structurally_resolved_type(fcx, expr_from.span, ty_to);\n-    if ty::type_is_scalar(ty_to) {\n-        // Supply the type as a hint so as to influence integer\n-        // literals and other things that might care.\n-        check_expr_with_hint(fcx, expr_from, ty_to)\n-    } else {\n-        check_expr(fcx, expr_from)\n-    }\n-    let ty_from = fcx.expr_ty(expr_from);\n-\n-    // Object creation is checked during the vtable phase.\n-    if ty::type_is_trait(ty_to) {\n-        check_expr(fcx, expr_from);\n-        return;\n-    }\n-\n-    let ty_from = fcx.infcx().resolve_type_vars_if_possible(ty_from);\n-\n-    if ty::type_is_nil(ty_from) {\n-        fcx.type_error_message(expr_from.span, |actual| {\n-            format!(\"cast from nil: `{}` as `{}`\", actual,\n-                    fcx.infcx().ty_to_str(ty_to))\n-        }, ty_from, None);\n-        return;\n-    }\n-\n-    if ty::type_is_nil(ty_to) {\n-        fcx.type_error_message(expr_from.span, |actual| {\n-            format!(\"cast to nil: `{}` as `{}`\", actual,\n-                    fcx.infcx().ty_to_str(ty_to))\n-        }, ty_from, None);\n-        return;\n-    }\n-\n-    let t_e = structurally_resolved_type(fcx, expr_from.span, ty_from);\n-    let t_1 = structurally_resolved_type(fcx, expr_from.span, ty_to);\n-\n-    let to_is_scalar = ty::type_is_scalar(t_1);\n-    let to_is_float = ty::type_is_floating_point(t_1);\n-    let to_is_char = ty::type_is_char(t_1);\n-    let to_is_bare_fn = ty::type_is_bare_fn(t_1);\n-\n-    // casts to scalars other than `char` and `bare fn` are trivial\n-    let to_is_trivial = to_is_scalar &&\n-        !to_is_char && !to_is_bare_fn;\n-\n-    if ty::type_is_c_like_enum(fcx.tcx(), t_e) && to_is_trivial {\n-        if to_is_float {\n-            fcx.type_error_message(expr_from.span, |actual| {\n-                format!(\"illegal cast; cast through an integer first: `{}` \\\n-                         as `{}`\",\n-                        actual,\n-                        fcx.infcx().ty_to_str(t_1))\n-            }, ty_from, None);\n-        }\n-        // casts from C-like enums are allowed\n-    } else if to_is_char {\n-        if ty::get(ty_from).sty != ty::ty_uint(ast::TyU8) {\n-            fcx.type_error_message(expr_from.span, |actual| {\n-                format!(\"only `u8` can be cast as `char`, not `{}`\", actual)\n-            }, ty_from, None);\n-        }\n-    } else if ty::type_is_bool(t_1) {\n-        fcx.tcx().sess.span_err(expr_from.span,\n-                                \"cannot cast as `bool`, compare with zero instead\");\n-    } else if ty::type_is_region_ptr(t_e) && ty::type_is_unsafe_ptr(t_1) {\n-        fn is_vec(t: ty::t) -> bool {\n-            match ty::get(t).sty {\n-                ty::ty_vec(..) => true,\n-                ty::ty_ptr(ty::mt{ty: t, ..}) |\n-                ty::ty_rptr(_, ty::mt{ty: t, ..}) |\n-                ty::ty_box(t) |\n-                ty::ty_uniq(t) => match ty::get(t).sty {\n-                    ty::ty_vec(_, None) => true,\n-                    _ => false,\n-                },\n-                _ => false\n-            }\n-        }\n-        fn types_compatible(fcx: &FnCtxt, sp: Span,\n-                            t1: ty::t, t2: ty::t) -> bool {\n-            if !is_vec(t1) {\n-                false\n-            } else {\n-                let el = ty::sequence_element_type(fcx.tcx(),\n-                                                   t1);\n-                infer::mk_eqty(fcx.infcx(), false,\n-                               infer::Misc(sp), el, t2).is_ok()\n-            }\n-        }\n-\n-        // Due to the limitations of LLVM global constants,\n-        // region pointers end up pointing at copies of\n-        // vector elements instead of the original values.\n-        // To allow unsafe pointers to work correctly, we\n-        // need to special-case obtaining an unsafe pointer\n-        // from a region pointer to a vector.\n-\n-        /* this cast is only allowed from &[T] to *T or\n-        &T to *T. */\n-        match (&ty::get(t_e).sty, &ty::get(t_1).sty) {\n-            (&ty::ty_rptr(_, ty::mt { ty: mt1, mutbl: ast::MutImmutable }),\n-             &ty::ty_ptr(ty::mt { ty: mt2, mutbl: ast::MutImmutable }))\n-                if types_compatible(fcx, expr_from.span, mt1, mt2) => {\n-                    /* this case is allowed */\n-                }\n-            _ => {\n-                demand::coerce(fcx, expr_from.span, ty_to, expr_from);\n-            }\n-        }\n-    } else if !(ty::type_is_scalar(t_e) && to_is_trivial) {\n-        // If more type combinations should be supported than are\n-        // supported here, then file an enhancement issue and\n-        // record the issue number in this comment.\n-        fcx.type_error_message(expr_from.span, |actual| {\n-            format!(\"non-scalar cast: `{}` as `{}`\", actual,\n-                    fcx.infcx().ty_to_str(ty_to))\n-        }, ty_from, None);\n-    }\n-}\n-\n pub fn require_uint(fcx: &FnCtxt, sp: Span, t: ty::t) {\n     if !type_is_uint(fcx, sp, t) {\n         fcx.type_error_message(sp, |actual| {"}, {"sha": "da0f0f5f7c94bef708f8c783b6ec2956e9389cfc", "filename": "src/test/compile-fail/vector-cast-weirdness.rs", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/315f2a70542078c45c9f7ebf4face32a54fde774/src%2Ftest%2Fcompile-fail%2Fvector-cast-weirdness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/315f2a70542078c45c9f7ebf4face32a54fde774/src%2Ftest%2Fcompile-fail%2Fvector-cast-weirdness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fvector-cast-weirdness.rs?ref=315f2a70542078c45c9f7ebf4face32a54fde774", "patch": "@@ -0,0 +1,31 @@\n+// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Issue #14893. Tests that casts from vectors don't behave strangely in the\n+// presence of the `_` type shorthand notation.\n+\n+struct X {\n+    y: [u8, ..2],\n+}\n+\n+fn main() {\n+    let x1 = X { y: [0, 0] };\n+\n+    let p1: *u8 = &x1.y as *_;  //~ ERROR mismatched types\n+    let t1: *[u8, ..2] = &x1.y as *_;\n+    let h1: *[u8, ..2] = &x1.y as *[u8, ..2];\n+\n+    let mut x1 = X { y: [0, 0] };\n+\n+    let p1: *mut u8 = &mut x1.y as *mut _;  //~ ERROR mismatched types\n+    let t1: *mut [u8, ..2] = &mut x1.y as *mut _;\n+    let h1: *mut [u8, ..2] = &mut x1.y as *mut [u8, ..2];\n+}\n+"}]}