{"sha": "38eb0e551411ba0d175a55ed6d01bb529d1c8684", "node_id": "MDY6Q29tbWl0NzI0NzEyOjM4ZWIwZTU1MTQxMWJhMGQxNzVhNTVlZDZkMDFiYjUyOWQxYzg2ODQ=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-09-06T21:46:25Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-09-06T21:46:25Z"}, "message": "auto merge of #17012 : thestinger/rust/sized, r=nikomatsakis", "tree": {"sha": "2fa3fb56ae2926d90b30bec0d9555f034fa7d627", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2fa3fb56ae2926d90b30bec0d9555f034fa7d627"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/38eb0e551411ba0d175a55ed6d01bb529d1c8684", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/38eb0e551411ba0d175a55ed6d01bb529d1c8684", "html_url": "https://github.com/rust-lang/rust/commit/38eb0e551411ba0d175a55ed6d01bb529d1c8684", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/38eb0e551411ba0d175a55ed6d01bb529d1c8684/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d8a26184dc103025e7ad457ffd8deb391019dbfe", "url": "https://api.github.com/repos/rust-lang/rust/commits/d8a26184dc103025e7ad457ffd8deb391019dbfe", "html_url": "https://github.com/rust-lang/rust/commit/d8a26184dc103025e7ad457ffd8deb391019dbfe"}, {"sha": "c76e3caf104e3166c322cbce2e7ac547eb040ad4", "url": "https://api.github.com/repos/rust-lang/rust/commits/c76e3caf104e3166c322cbce2e7ac547eb040ad4", "html_url": "https://github.com/rust-lang/rust/commit/c76e3caf104e3166c322cbce2e7ac547eb040ad4"}], "stats": {"total": 273, "additions": 186, "deletions": 87}, "files": [{"sha": "c72a77702afff4ea2bfa636528374b3b40907b70", "filename": "src/liballoc/heap.rs", "status": "modified", "additions": 17, "deletions": 2, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/38eb0e551411ba0d175a55ed6d01bb529d1c8684/src%2Fliballoc%2Fheap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/38eb0e551411ba0d175a55ed6d01bb529d1c8684/src%2Fliballoc%2Fheap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fheap.rs?ref=38eb0e551411ba0d175a55ed6d01bb529d1c8684", "patch": "@@ -14,7 +14,7 @@\n \n use core::ptr::RawPtr;\n #[cfg(not(test))] use core::raw;\n-#[cfg(not(test))] use util;\n+#[cfg(stage0, not(test))] use util;\n \n /// Returns a pointer to `size` bytes of memory.\n ///\n@@ -119,7 +119,7 @@ unsafe fn exchange_free(ptr: *mut u8, size: uint, align: uint) {\n }\n \n // FIXME: #7496\n-#[cfg(not(test))]\n+#[cfg(stage0, not(test))]\n #[lang=\"closure_exchange_malloc\"]\n #[inline]\n #[allow(deprecated)]\n@@ -134,6 +134,21 @@ unsafe fn closure_exchange_malloc(drop_glue: fn(*mut u8), size: uint,\n     alloc as *mut u8\n }\n \n+// FIXME: #7496\n+#[cfg(not(stage0), not(test))]\n+#[lang=\"closure_exchange_malloc\"]\n+#[inline]\n+#[allow(deprecated)]\n+unsafe fn closure_exchange_malloc(drop_glue: fn(*mut u8), size: uint,\n+                                  align: uint) -> *mut u8 {\n+    let p = allocate(size, align);\n+\n+    let alloc = p as *mut raw::Box<()>;\n+    (*alloc).drop_glue = drop_glue;\n+\n+    alloc as *mut u8\n+}\n+\n #[cfg(jemalloc)]\n mod imp {\n     use core::option::{None, Option};"}, {"sha": "e91898548533c0a98034a97488af0f92153e1006", "filename": "src/libarena/lib.rs", "status": "modified", "additions": 50, "deletions": 47, "changes": 97, "blob_url": "https://github.com/rust-lang/rust/blob/38eb0e551411ba0d175a55ed6d01bb529d1c8684/src%2Flibarena%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/38eb0e551411ba0d175a55ed6d01bb529d1c8684/src%2Flibarena%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibarena%2Flib.rs?ref=38eb0e551411ba0d175a55ed6d01bb529d1c8684", "patch": "@@ -39,17 +39,18 @@ use std::mem;\n use std::num;\n use std::ptr;\n use std::rc::Rc;\n-use std::rt::heap::allocate;\n+use std::rt::heap::{allocate, deallocate};\n \n // The way arena uses arrays is really deeply awful. The arrays are\n // allocated, and have capacities reserved, but the fill for the array\n // will always stay at 0.\n #[deriving(Clone, PartialEq)]\n struct Chunk {\n-    data: Rc<RefCell<Vec<u8> >>,\n+    data: Rc<RefCell<Vec<u8>>>,\n     fill: Cell<uint>,\n     is_copy: Cell<bool>,\n }\n+\n impl Chunk {\n     fn capacity(&self) -> uint {\n         self.data.borrow().capacity()\n@@ -357,38 +358,37 @@ pub struct TypedArena<T> {\n     end: Cell<*const T>,\n \n     /// A pointer to the first arena segment.\n-    first: RefCell<TypedArenaChunkRef<T>>,\n+    first: RefCell<*mut TypedArenaChunk<T>>,\n }\n-type TypedArenaChunkRef<T> = Option<Box<TypedArenaChunk<T>>>;\n \n struct TypedArenaChunk<T> {\n     /// Pointer to the next arena segment.\n-    next: TypedArenaChunkRef<T>,\n+    next: *mut TypedArenaChunk<T>,\n \n     /// The number of elements that this chunk can hold.\n     capacity: uint,\n \n     // Objects follow here, suitably aligned.\n }\n \n+fn calculate_size<T>(capacity: uint) -> uint {\n+    let mut size = mem::size_of::<TypedArenaChunk<T>>();\n+    size = round_up(size, mem::min_align_of::<T>());\n+    let elem_size = mem::size_of::<T>();\n+    let elems_size = elem_size.checked_mul(&capacity).unwrap();\n+    size = size.checked_add(&elems_size).unwrap();\n+    size\n+}\n+\n impl<T> TypedArenaChunk<T> {\n     #[inline]\n-    fn new(next: Option<Box<TypedArenaChunk<T>>>, capacity: uint)\n-           -> Box<TypedArenaChunk<T>> {\n-        let mut size = mem::size_of::<TypedArenaChunk<T>>();\n-        size = round_up(size, mem::min_align_of::<T>());\n-        let elem_size = mem::size_of::<T>();\n-        let elems_size = elem_size.checked_mul(&capacity).unwrap();\n-        size = size.checked_add(&elems_size).unwrap();\n-\n-        let mut chunk = unsafe {\n-            let chunk = allocate(size, mem::min_align_of::<TypedArenaChunk<T>>());\n-            let mut chunk: Box<TypedArenaChunk<T>> = mem::transmute(chunk);\n-            ptr::write(&mut chunk.next, next);\n-            chunk\n-        };\n-\n-        chunk.capacity = capacity;\n+    unsafe fn new(next: *mut TypedArenaChunk<T>, capacity: uint)\n+           -> *mut TypedArenaChunk<T> {\n+        let size = calculate_size::<T>(capacity);\n+        let chunk = allocate(size, mem::min_align_of::<TypedArenaChunk<T>>())\n+                    as *mut TypedArenaChunk<T>;\n+        (*chunk).next = next;\n+        (*chunk).capacity = capacity;\n         chunk\n     }\n \n@@ -406,14 +406,13 @@ impl<T> TypedArenaChunk<T> {\n         }\n \n         // Destroy the next chunk.\n-        let next_opt = mem::replace(&mut self.next, None);\n-        match next_opt {\n-            None => {}\n-            Some(mut next) => {\n-                // We assume that the next chunk is completely filled.\n-                let capacity = next.capacity;\n-                next.destroy(capacity)\n-            }\n+        let next = self.next;\n+        let size = calculate_size::<T>(self.capacity);\n+        deallocate(self as *mut TypedArenaChunk<T> as *mut u8, size,\n+                   mem::min_align_of::<TypedArenaChunk<T>>());\n+        if next.is_not_null() {\n+            let capacity = (*next).capacity;\n+            (*next).destroy(capacity);\n         }\n     }\n \n@@ -448,11 +447,13 @@ impl<T> TypedArena<T> {\n     /// objects.\n     #[inline]\n     pub fn with_capacity(capacity: uint) -> TypedArena<T> {\n-        let chunk = TypedArenaChunk::<T>::new(None, capacity);\n-        TypedArena {\n-            ptr: Cell::new(chunk.start() as *const T),\n-            end: Cell::new(chunk.end() as *const T),\n-            first: RefCell::new(Some(chunk)),\n+        unsafe {\n+            let chunk = TypedArenaChunk::<T>::new(ptr::mut_null(), capacity);\n+            TypedArena {\n+                ptr: Cell::new((*chunk).start() as *const T),\n+                end: Cell::new((*chunk).end() as *const T),\n+                first: RefCell::new(chunk),\n+            }\n         }\n     }\n \n@@ -476,26 +477,28 @@ impl<T> TypedArena<T> {\n     /// Grows the arena.\n     #[inline(never)]\n     fn grow(&self) {\n-        let chunk = self.first.borrow_mut().take().unwrap();\n-        let new_capacity = chunk.capacity.checked_mul(&2).unwrap();\n-        let chunk = TypedArenaChunk::<T>::new(Some(chunk), new_capacity);\n-        self.ptr.set(chunk.start() as *const T);\n-        self.end.set(chunk.end() as *const T);\n-        *self.first.borrow_mut() = Some(chunk)\n+        unsafe {\n+            let chunk = *self.first.borrow_mut();\n+            let new_capacity = (*chunk).capacity.checked_mul(&2).unwrap();\n+            let chunk = TypedArenaChunk::<T>::new(chunk, new_capacity);\n+            self.ptr.set((*chunk).start() as *const T);\n+            self.end.set((*chunk).end() as *const T);\n+            *self.first.borrow_mut() = chunk\n+        }\n     }\n }\n \n #[unsafe_destructor]\n impl<T> Drop for TypedArena<T> {\n     fn drop(&mut self) {\n-        // Determine how much was filled.\n-        let start = self.first.borrow().as_ref().unwrap().start() as uint;\n-        let end = self.ptr.get() as uint;\n-        let diff = (end - start) / mem::size_of::<T>();\n-\n-        // Pass that to the `destroy` method.\n         unsafe {\n-            self.first.borrow_mut().as_mut().unwrap().destroy(diff)\n+            // Determine how much was filled.\n+            let start = self.first.borrow().as_ref().unwrap().start() as uint;\n+            let end = self.ptr.get() as uint;\n+            let diff = (end - start) / mem::size_of::<T>();\n+\n+            // Pass that to the `destroy` method.\n+            (**self.first.borrow_mut()).destroy(diff)\n         }\n     }\n }"}, {"sha": "04700f74943e50a11ce42b645ce727c42da9a3c1", "filename": "src/librustc/middle/trans/base.rs", "status": "modified", "additions": 33, "deletions": 2, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/38eb0e551411ba0d175a55ed6d01bb529d1c8684/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/38eb0e551411ba0d175a55ed6d01bb529d1c8684/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs?ref=38eb0e551411ba0d175a55ed6d01bb529d1c8684", "patch": "@@ -66,7 +66,7 @@ use middle::trans::glue;\n use middle::trans::inline;\n use middle::trans::intrinsic;\n use middle::trans::machine;\n-use middle::trans::machine::{llsize_of, llsize_of_real};\n+use middle::trans::machine::{llsize_of, llsize_of_real, llalign_of_min};\n use middle::trans::meth;\n use middle::trans::monomorphize;\n use middle::trans::tvec;\n@@ -382,13 +382,44 @@ pub fn malloc_raw_dyn<'a>(bcx: &'a Block<'a>,\n     Result::new(r.bcx, PointerCast(r.bcx, r.val, llty_ptr))\n }\n \n+pub fn malloc_raw_dyn_proc<'a>(\n+                      bcx: &'a Block<'a>,\n+                      t: ty::t, alloc_fn: LangItem) -> Result<'a> {\n+    let _icx = push_ctxt(\"malloc_raw_dyn_proc\");\n+    let ccx = bcx.ccx();\n+\n+    let langcall = require_alloc_fn(bcx, t, alloc_fn);\n+\n+    // Grab the TypeRef type of ptr_ty.\n+    let ptr_ty = ty::mk_uniq(bcx.tcx(), t);\n+    let ptr_llty = type_of(ccx, ptr_ty);\n+\n+    let llty = type_of(bcx.ccx(), t);\n+    let size = llsize_of(bcx.ccx(), llty);\n+    let llalign = C_uint(ccx, llalign_of_min(bcx.ccx(), llty) as uint);\n+\n+    // Allocate space:\n+    let drop_glue = glue::get_drop_glue(ccx, ty::mk_uniq(bcx.tcx(), t));\n+    let r = callee::trans_lang_call(\n+        bcx,\n+        langcall,\n+        [\n+            PointerCast(bcx, drop_glue, Type::glue_fn(ccx, Type::i8p(ccx)).ptr_to()),\n+            size,\n+            llalign\n+        ],\n+        None);\n+    Result::new(r.bcx, PointerCast(r.bcx, r.val, ptr_llty))\n+}\n+\n+\n pub fn malloc_raw_dyn_managed<'a>(\n                       bcx: &'a Block<'a>,\n                       t: ty::t,\n                       alloc_fn: LangItem,\n                       size: ValueRef)\n                       -> Result<'a> {\n-    let _icx = push_ctxt(\"malloc_raw_managed\");\n+    let _icx = push_ctxt(\"malloc_raw_dyn_managed\");\n     let ccx = bcx.ccx();\n \n     let langcall = require_alloc_fn(bcx, t, alloc_fn);"}, {"sha": "cdfb8e48a460e443d8c462655bc2937eb215a910", "filename": "src/librustc/middle/trans/cleanup.rs", "status": "modified", "additions": 55, "deletions": 0, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/38eb0e551411ba0d175a55ed6d01bb529d1c8684/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcleanup.rs", "raw_url": "https://github.com/rust-lang/rust/raw/38eb0e551411ba0d175a55ed6d01bb529d1c8684/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcleanup.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcleanup.rs?ref=38eb0e551411ba0d175a55ed6d01bb529d1c8684", "patch": "@@ -340,6 +340,27 @@ impl<'a> CleanupMethods<'a> for FunctionContext<'a> {\n         self.schedule_clean(cleanup_scope, drop as CleanupObj);\n     }\n \n+    fn schedule_free_slice(&self,\n+                           cleanup_scope: ScopeId,\n+                           val: ValueRef,\n+                           size: ValueRef,\n+                           align: ValueRef,\n+                           heap: Heap) {\n+        /*!\n+         * Schedules a call to `free(val)`. Note that this is a shallow\n+         * operation.\n+         */\n+\n+        let drop = box FreeSlice { ptr: val, size: size, align: align, heap: heap };\n+\n+        debug!(\"schedule_free_slice({:?}, val={}, heap={:?})\",\n+               cleanup_scope,\n+               self.ccx.tn().val_to_string(val),\n+               heap);\n+\n+        self.schedule_clean(cleanup_scope, drop as CleanupObj);\n+    }\n+\n     fn schedule_clean(&self,\n                       cleanup_scope: ScopeId,\n                       cleanup: CleanupObj) {\n@@ -926,6 +947,34 @@ impl Cleanup for FreeValue {\n     }\n }\n \n+pub struct FreeSlice {\n+    ptr: ValueRef,\n+    size: ValueRef,\n+    align: ValueRef,\n+    heap: Heap,\n+}\n+\n+impl Cleanup for FreeSlice {\n+    fn must_unwind(&self) -> bool {\n+        true\n+    }\n+\n+    fn clean_on_unwind(&self) -> bool {\n+        true\n+    }\n+\n+    fn trans<'a>(&self, bcx: &'a Block<'a>) -> &'a Block<'a> {\n+        match self.heap {\n+            HeapManaged => {\n+                glue::trans_free(bcx, self.ptr)\n+            }\n+            HeapExchange => {\n+                glue::trans_exchange_free_dyn(bcx, self.ptr, self.size, self.align)\n+            }\n+        }\n+    }\n+}\n+\n pub struct LifetimeEnd {\n     ptr: ValueRef,\n }\n@@ -1020,6 +1069,12 @@ pub trait CleanupMethods<'a> {\n                            val: ValueRef,\n                            heap: Heap,\n                            content_ty: ty::t);\n+    fn schedule_free_slice(&self,\n+                           cleanup_scope: ScopeId,\n+                           val: ValueRef,\n+                           size: ValueRef,\n+                           align: ValueRef,\n+                           heap: Heap);\n     fn schedule_clean(&self,\n                       cleanup_scope: ScopeId,\n                       cleanup: CleanupObj);"}, {"sha": "b90ac39cf1d28caca9c39915c11c9afbf7a454ce", "filename": "src/librustc/middle/trans/closure.rs", "status": "modified", "additions": 2, "deletions": 6, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/38eb0e551411ba0d175a55ed6d01bb529d1c8684/src%2Flibrustc%2Fmiddle%2Ftrans%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/38eb0e551411ba0d175a55ed6d01bb529d1c8684/src%2Flibrustc%2Fmiddle%2Ftrans%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fclosure.rs?ref=38eb0e551411ba0d175a55ed6d01bb529d1c8684", "patch": "@@ -24,7 +24,6 @@ use middle::trans::common::*;\n use middle::trans::datum::{Datum, DatumBlock, Expr, Lvalue, rvalue_scratch_datum};\n use middle::trans::debuginfo;\n use middle::trans::expr;\n-use middle::trans::machine::llsize_of;\n use middle::trans::type_of::*;\n use middle::trans::type_::Type;\n use middle::ty;\n@@ -144,15 +143,12 @@ fn allocate_cbox<'a>(bcx: &'a Block<'a>,\n     let tcx = bcx.tcx();\n \n     // Allocate and initialize the box:\n+    let cbox_ty = tuplify_box_ty(tcx, cdata_ty);\n     match store {\n         ty::UniqTraitStore => {\n-            let ty = type_of(bcx.ccx(), cdata_ty);\n-            let size = llsize_of(bcx.ccx(), ty);\n-            // we treat proc as @ here, which isn't ideal\n-            malloc_raw_dyn_managed(bcx, cdata_ty, ClosureExchangeMallocFnLangItem, size)\n+            malloc_raw_dyn_proc(bcx, cbox_ty, ClosureExchangeMallocFnLangItem)\n         }\n         ty::RegionTraitStore(..) => {\n-            let cbox_ty = tuplify_box_ty(tcx, cdata_ty);\n             let llbox = alloc_ty(bcx, cbox_ty, \"__closure\");\n             Result::new(bcx, llbox)\n         }"}, {"sha": "09d28f03392cfe2bf751e18e9bcc22ffbd9326f3", "filename": "src/librustc/middle/trans/glue.rs", "status": "modified", "additions": 7, "deletions": 16, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/38eb0e551411ba0d175a55ed6d01bb529d1c8684/src%2Flibrustc%2Fmiddle%2Ftrans%2Fglue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/38eb0e551411ba0d175a55ed6d01bb529d1c8684/src%2Flibrustc%2Fmiddle%2Ftrans%2Fglue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fglue.rs?ref=38eb0e551411ba0d175a55ed6d01bb529d1c8684", "patch": "@@ -53,7 +53,7 @@ pub fn trans_free<'a>(cx: &'a Block<'a>, v: ValueRef) -> &'a Block<'a> {\n         Some(expr::Ignore)).bcx\n }\n \n-fn trans_exchange_free_internal<'a>(cx: &'a Block<'a>, v: ValueRef, size: ValueRef,\n+pub fn trans_exchange_free_dyn<'a>(cx: &'a Block<'a>, v: ValueRef, size: ValueRef,\n                                align: ValueRef) -> &'a Block<'a> {\n     let _icx = push_ctxt(\"trans_exchange_free\");\n     let ccx = cx.ccx();\n@@ -65,10 +65,8 @@ fn trans_exchange_free_internal<'a>(cx: &'a Block<'a>, v: ValueRef, size: ValueR\n \n pub fn trans_exchange_free<'a>(cx: &'a Block<'a>, v: ValueRef, size: u64,\n                                align: u64) -> &'a Block<'a> {\n-    trans_exchange_free_internal(cx,\n-                                 v,\n-                                 C_uint(cx.ccx(), size as uint),\n-                                 C_uint(cx.ccx(), align as uint))\n+    trans_exchange_free_dyn(cx, v, C_uint(cx.ccx(), size as uint),\n+                            C_uint(cx.ccx(), align as uint))\n }\n \n pub fn trans_exchange_free_ty<'a>(bcx: &'a Block<'a>, ptr: ValueRef,\n@@ -111,17 +109,14 @@ pub fn get_drop_glue_type(ccx: &CrateContext, t: ty::t) -> ty::t {\n         return ty::mk_i8();\n     }\n     match ty::get(t).sty {\n-        ty::ty_box(typ) if !ty::type_needs_drop(tcx, typ) =>\n-            ty::mk_box(tcx, ty::mk_i8()),\n-\n         ty::ty_uniq(typ) if !ty::type_needs_drop(tcx, typ)\n                          && ty::type_is_sized(tcx, typ) => {\n             let llty = sizing_type_of(ccx, typ);\n             // `Box<ZeroSizeType>` does not allocate.\n             if llsize_of_alloc(ccx, llty) == 0 {\n                 ty::mk_i8()\n             } else {\n-                ty::mk_uniq(tcx, ty::mk_i8())\n+                t\n             }\n         }\n         _ => t\n@@ -470,7 +465,7 @@ fn make_drop_glue<'a>(bcx: &'a Block<'a>, v0: ValueRef, t: ty::t) -> &'a Block<'\n                         let info = GEPi(bcx, v0, [0, abi::slice_elt_len]);\n                         let info = Load(bcx, info);\n                         let (llsize, llalign) = size_and_align_of_dst(bcx, content_ty, info);\n-                        trans_exchange_free_internal(bcx, llbox, llsize, llalign)\n+                        trans_exchange_free_dyn(bcx, llbox, llsize, llalign)\n                     })\n                 }\n                 _ => {\n@@ -523,12 +518,8 @@ fn make_drop_glue<'a>(bcx: &'a Block<'a>, v0: ValueRef, t: ty::t) -> &'a Block<'\n             with_cond(bcx, IsNotNull(bcx, env), |bcx| {\n                 let dtor_ptr = GEPi(bcx, env, [0u, abi::box_field_tydesc]);\n                 let dtor = Load(bcx, dtor_ptr);\n-                let cdata = GEPi(bcx, env, [0u, abi::box_field_body]);\n-                Call(bcx, dtor, [PointerCast(bcx, cdata, Type::i8p(bcx.ccx()))], None);\n-\n-                // Free the environment itself\n-                // FIXME: #13994: pass align and size here\n-                trans_exchange_free(bcx, env, 0, 8)\n+                Call(bcx, dtor, [PointerCast(bcx, box_cell_v, Type::i8p(bcx.ccx()))], None);\n+                bcx\n             })\n         }\n         ty::ty_trait(..) => {"}, {"sha": "285105d22f675efbcdb2981154b7a5e208eae26c", "filename": "src/librustc/middle/trans/tvec.rs", "status": "modified", "additions": 18, "deletions": 13, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/38eb0e551411ba0d175a55ed6d01bb529d1c8684/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/38eb0e551411ba0d175a55ed6d01bb529d1c8684/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftvec.rs?ref=38eb0e551411ba0d175a55ed6d01bb529d1c8684", "patch": "@@ -25,6 +25,7 @@ use middle::trans::datum::*;\n use middle::trans::expr::{Dest, Ignore, SaveIn};\n use middle::trans::expr;\n use middle::trans::glue;\n+use middle::trans::machine;\n use middle::trans::machine::{nonzero_llsize_of, llsize_of_alloc};\n use middle::trans::type_::Type;\n use middle::trans::type_of;\n@@ -59,6 +60,7 @@ pub fn make_drop_glue_unboxed<'a>(\n                               -> &'a Block<'a> {\n     let not_null = IsNotNull(bcx, vptr);\n     with_cond(bcx, not_null, |bcx| {\n+        let ccx = bcx.ccx();\n         let tcx = bcx.tcx();\n         let _icx = push_ctxt(\"tvec::make_drop_glue_unboxed\");\n \n@@ -73,8 +75,11 @@ pub fn make_drop_glue_unboxed<'a>(\n         if should_deallocate {\n             let not_null = IsNotNull(bcx, dataptr);\n             with_cond(bcx, not_null, |bcx| {\n-                // FIXME: #13994: the old `Box<[T]>` will not support sized deallocation\n-                glue::trans_exchange_free(bcx, dataptr, 0, 8)\n+                let llty = type_of::type_of(ccx, unit_ty);\n+                let llsize = machine::llsize_of(ccx, llty);\n+                let llalign = C_uint(ccx, machine::llalign_of_min(ccx, llty) as uint);\n+                let size = Mul(bcx, llsize, get_len(bcx, vptr));\n+                glue::trans_exchange_free_dyn(bcx, dataptr, size, llalign)\n             })\n         } else {\n             bcx\n@@ -281,15 +286,16 @@ pub fn trans_uniq_vec<'a>(bcx: &'a Block<'a>,\n     debug!(\"    vt={}, count={:?}\", vt.to_string(ccx), count);\n     let vec_ty = node_id_type(bcx, uniq_expr.id);\n \n-    let unit_sz = nonzero_llsize_of(ccx, type_of::type_of(ccx, vt.unit_ty));\n+    let llty = type_of::type_of(ccx, vt.unit_ty);\n+    let unit_sz = nonzero_llsize_of(ccx, llty);\n     let llcount = if count < 4u {\n         C_int(ccx, 4)\n     } else {\n         C_uint(ccx, count)\n     };\n     let alloc = Mul(bcx, llcount, unit_sz);\n-    let llty_ptr = type_of::type_of(ccx, vt.unit_ty).ptr_to();\n-    let align = C_uint(ccx, 8);\n+    let llty_ptr = llty.ptr_to();\n+    let align = C_uint(ccx, machine::llalign_of_min(ccx, llty) as uint);\n     let Result { bcx: bcx, val: dataptr } = malloc_raw_dyn(bcx,\n                                                            llty_ptr,\n                                                            vec_ty,\n@@ -299,16 +305,15 @@ pub fn trans_uniq_vec<'a>(bcx: &'a Block<'a>,\n     // Create a temporary scope lest execution should fail while\n     // constructing the vector.\n     let temp_scope = fcx.push_custom_cleanup_scope();\n-    // FIXME: #13994: the old `Box<[T]> will not support sized deallocation,\n-    // this is a placeholder\n-    fcx.schedule_free_value(cleanup::CustomScope(temp_scope),\n-                            dataptr, cleanup::HeapExchange, vt.unit_ty);\n \n-        debug!(\"    alloc_uniq_vec() returned dataptr={}, len={}\",\n-               bcx.val_to_string(dataptr), count);\n+    fcx.schedule_free_slice(cleanup::CustomScope(temp_scope),\n+                            dataptr, alloc, align, cleanup::HeapExchange);\n \n-        let bcx = write_content(bcx, &vt, uniq_expr,\n-                                content_expr, SaveIn(dataptr));\n+    debug!(\"    alloc_uniq_vec() returned dataptr={}, len={}\",\n+           bcx.val_to_string(dataptr), count);\n+\n+    let bcx = write_content(bcx, &vt, uniq_expr,\n+                            content_expr, SaveIn(dataptr));\n \n     fcx.pop_custom_cleanup_scope(temp_scope);\n "}, {"sha": "d368477cd33abd74772ad23debdd32304b98875d", "filename": "src/libsyntax/owned_slice.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/38eb0e551411ba0d175a55ed6d01bb529d1c8684/src%2Flibsyntax%2Fowned_slice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/38eb0e551411ba0d175a55ed6d01bb529d1c8684/src%2Flibsyntax%2Fowned_slice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fowned_slice.rs?ref=38eb0e551411ba0d175a55ed6d01bb529d1c8684", "patch": "@@ -58,9 +58,12 @@ impl<T> OwnedSlice<T> {\n         if len == 0 {\n             OwnedSlice::empty()\n         } else {\n+            // drop excess capacity to avoid breaking sized deallocation\n+            v.shrink_to_fit();\n+\n             let p = v.as_mut_ptr();\n             // we own the allocation now\n-            unsafe {mem::forget(v)}\n+            unsafe { mem::forget(v) }\n \n             OwnedSlice { data: p, len: len }\n         }"}]}