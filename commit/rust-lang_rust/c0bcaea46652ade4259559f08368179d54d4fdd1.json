{"sha": "c0bcaea46652ade4259559f08368179d54d4fdd1", "node_id": "MDY6Q29tbWl0NzI0NzEyOmMwYmNhZWE0NjY1MmFkZTQyNTk1NTlmMDgzNjgxNzlkNTRkNGZkZDE=", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2020-05-20T07:22:53Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2020-05-20T07:22:53Z"}, "message": "Merge #4505\n\n4505: Infer return type of loops with value breaks r=flodiebold a=ruabmbua\n\nCreates a type variable to represent the return value of the loop.\r\nUses `coerce_merge_branch` on each break with the previous value, to determine the actual return value of the loop.\r\n\r\nResolves: https://github.com/rust-analyzer/rust-analyzer/issues/4492 , https://github.com/rust-analyzer/rust-analyzer/issues/4512\n\nCo-authored-by: Roland Ruckerbauer <roland.rucky@gmail.com>", "tree": {"sha": "d6f3f19a010aa8c4de653df0d2638d8fd3aa8e78", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d6f3f19a010aa8c4de653df0d2638d8fd3aa8e78"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c0bcaea46652ade4259559f08368179d54d4fdd1", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJexNrNCRBK7hj4Ov3rIwAAdHIIAGltTHLRWk2ZBuHNUgND+tOf\nhlUHXwWCa6bEmsrEE0Nqq5/wEBU89OvGLaMwlUGS3klZ79Lb4kecpfznZl+xpfEX\nbtOUuRuskLeT8cvdXWeamfcimYXdKKsDT5OC7waUj+tVemDsqL/v0IQJicHnsMdb\npOMlVFWSjg6y2lJUBqkOnznRSBgi/1oti0Yy1rSNGHiOOm22bJSkMESGHKJu/noA\njEh5Pc4TJsOASnZZwBTlNE45ZH+XR/e2VC30Hio1yUO5UKe5vFKQAG0e5ruNX4/V\nZs7NOHWdMplnPEYpceVS/zdnyIonx0Qdz0TAERdl7Oe7iTCnM5mf4y5xEN1M+L4=\n=rxhV\n-----END PGP SIGNATURE-----\n", "payload": "tree d6f3f19a010aa8c4de653df0d2638d8fd3aa8e78\nparent efac093093f1bd598957822e9e859b33c5f13e1f\nparent 45021cae551826727c32c7499c68ca48d046890f\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1589959373 +0000\ncommitter GitHub <noreply@github.com> 1589959373 +0000\n\nMerge #4505\n\n4505: Infer return type of loops with value breaks r=flodiebold a=ruabmbua\n\nCreates a type variable to represent the return value of the loop.\r\nUses `coerce_merge_branch` on each break with the previous value, to determine the actual return value of the loop.\r\n\r\nResolves: https://github.com/rust-analyzer/rust-analyzer/issues/4492 , https://github.com/rust-analyzer/rust-analyzer/issues/4512\n\nCo-authored-by: Roland Ruckerbauer <roland.rucky@gmail.com>\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c0bcaea46652ade4259559f08368179d54d4fdd1", "html_url": "https://github.com/rust-lang/rust/commit/c0bcaea46652ade4259559f08368179d54d4fdd1", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c0bcaea46652ade4259559f08368179d54d4fdd1/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "efac093093f1bd598957822e9e859b33c5f13e1f", "url": "https://api.github.com/repos/rust-lang/rust/commits/efac093093f1bd598957822e9e859b33c5f13e1f", "html_url": "https://github.com/rust-lang/rust/commit/efac093093f1bd598957822e9e859b33c5f13e1f"}, {"sha": "45021cae551826727c32c7499c68ca48d046890f", "url": "https://api.github.com/repos/rust-lang/rust/commits/45021cae551826727c32c7499c68ca48d046890f", "html_url": "https://github.com/rust-lang/rust/commit/45021cae551826727c32c7499c68ca48d046890f"}], "stats": {"total": 136, "additions": 106, "deletions": 30}, "files": [{"sha": "3e6e1e3331b0140bd7c0ca174326b51fcaeef142", "filename": "crates/ra_hir_ty/src/_match.rs", "status": "modified", "additions": 18, "deletions": 21, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/c0bcaea46652ade4259559f08368179d54d4fdd1/crates%2Fra_hir_ty%2Fsrc%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0bcaea46652ade4259559f08368179d54d4fdd1/crates%2Fra_hir_ty%2Fsrc%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2F_match.rs?ref=c0bcaea46652ade4259559f08368179d54d4fdd1", "patch": "@@ -1946,6 +1946,23 @@ mod tests {\n \n         check_no_diagnostic(content);\n     }\n+\n+    #[test]\n+    fn expr_diverges_missing_arm() {\n+        let content = r\"\n+            enum Either {\n+                A,\n+                B,\n+            }\n+            fn test_fn() {\n+                match loop {} {\n+                    Either::A => (),\n+                }\n+            }\n+        \";\n+\n+        check_no_diagnostic(content);\n+    }\n }\n \n #[cfg(test)]\n@@ -1997,26 +2014,6 @@ mod false_negatives {\n         check_no_diagnostic(content);\n     }\n \n-    #[test]\n-    fn expr_diverges_missing_arm() {\n-        let content = r\"\n-            enum Either {\n-                A,\n-                B,\n-            }\n-            fn test_fn() {\n-                match loop {} {\n-                    Either::A => (),\n-                }\n-            }\n-        \";\n-\n-        // This is a false negative.\n-        // Even though the match expression diverges, rustc fails\n-        // to compile here since `Either::B` is missing.\n-        check_no_diagnostic(content);\n-    }\n-\n     #[test]\n     fn expr_loop_missing_arm() {\n         let content = r\"\n@@ -2035,7 +2032,7 @@ mod false_negatives {\n         // We currently infer the type of `loop { break Foo::A }` to `!`, which\n         // causes us to skip the diagnostic since `Either::A` doesn't type check\n         // with `!`.\n-        check_no_diagnostic(content);\n+        check_diagnostic(content);\n     }\n \n     #[test]"}, {"sha": "957d6e0b5792d5f6d84a609e76ab5c2a57cd7382", "filename": "crates/ra_hir_ty/src/infer.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/c0bcaea46652ade4259559f08368179d54d4fdd1/crates%2Fra_hir_ty%2Fsrc%2Finfer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0bcaea46652ade4259559f08368179d54d4fdd1/crates%2Fra_hir_ty%2Fsrc%2Finfer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Finfer.rs?ref=c0bcaea46652ade4259559f08368179d54d4fdd1", "patch": "@@ -218,6 +218,7 @@ struct InferenceContext<'a> {\n #[derive(Clone, Debug)]\n struct BreakableContext {\n     pub may_break: bool,\n+    pub break_ty: Ty,\n }\n \n impl<'a> InferenceContext<'a> {"}, {"sha": "b28724f0e9461e03a6388b961feb77f58ae91ad4", "filename": "crates/ra_hir_ty/src/infer/expr.rs", "status": "modified", "additions": 24, "deletions": 9, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/c0bcaea46652ade4259559f08368179d54d4fdd1/crates%2Fra_hir_ty%2Fsrc%2Finfer%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0bcaea46652ade4259559f08368179d54d4fdd1/crates%2Fra_hir_ty%2Fsrc%2Finfer%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Finfer%2Fexpr.rs?ref=c0bcaea46652ade4259559f08368179d54d4fdd1", "patch": "@@ -93,22 +93,25 @@ impl<'a> InferenceContext<'a> {\n                 Ty::Unknown\n             }\n             Expr::Loop { body } => {\n-                self.breakables.push(BreakableContext { may_break: false });\n+                self.breakables.push(BreakableContext {\n+                    may_break: false,\n+                    break_ty: self.table.new_type_var(),\n+                });\n                 self.infer_expr(*body, &Expectation::has_type(Ty::unit()));\n \n                 let ctxt = self.breakables.pop().expect(\"breakable stack broken\");\n                 if ctxt.may_break {\n                     self.diverges = Diverges::Maybe;\n                 }\n-                // FIXME handle break with value\n+\n                 if ctxt.may_break {\n-                    Ty::unit()\n+                    ctxt.break_ty\n                 } else {\n                     Ty::simple(TypeCtor::Never)\n                 }\n             }\n             Expr::While { condition, body } => {\n-                self.breakables.push(BreakableContext { may_break: false });\n+                self.breakables.push(BreakableContext { may_break: false, break_ty: Ty::Unknown });\n                 // while let is desugared to a match loop, so this is always simple while\n                 self.infer_expr(*condition, &Expectation::has_type(Ty::simple(TypeCtor::Bool)));\n                 self.infer_expr(*body, &Expectation::has_type(Ty::unit()));\n@@ -120,7 +123,7 @@ impl<'a> InferenceContext<'a> {\n             Expr::For { iterable, body, pat } => {\n                 let iterable_ty = self.infer_expr(*iterable, &Expectation::none());\n \n-                self.breakables.push(BreakableContext { may_break: false });\n+                self.breakables.push(BreakableContext { may_break: false, break_ty: Ty::Unknown });\n                 let pat_ty =\n                     self.resolve_associated_type(iterable_ty, self.resolve_into_iter_item());\n \n@@ -229,17 +232,29 @@ impl<'a> InferenceContext<'a> {\n             }\n             Expr::Continue => Ty::simple(TypeCtor::Never),\n             Expr::Break { expr } => {\n-                if let Some(expr) = expr {\n-                    // FIXME handle break with value\n-                    self.infer_expr(*expr, &Expectation::none());\n-                }\n+                let val_ty = if let Some(expr) = expr {\n+                    self.infer_expr(*expr, &Expectation::none())\n+                } else {\n+                    Ty::unit()\n+                };\n+\n+                let last_ty = if let Some(ctxt) = self.breakables.last() {\n+                    ctxt.break_ty.clone()\n+                } else {\n+                    Ty::Unknown\n+                };\n+\n+                let merged_type = self.coerce_merge_branch(&last_ty, &val_ty);\n+\n                 if let Some(ctxt) = self.breakables.last_mut() {\n+                    ctxt.break_ty = merged_type;\n                     ctxt.may_break = true;\n                 } else {\n                     self.push_diagnostic(InferenceDiagnostic::BreakOutsideOfLoop {\n                         expr: tgt_expr,\n                     });\n                 }\n+\n                 Ty::simple(TypeCtor::Never)\n             }\n             Expr::Return { expr } => {"}, {"sha": "fd2208af280e8fca4d2891fc00f9bcdb0c4e19fa", "filename": "crates/ra_hir_ty/src/tests/simple.rs", "status": "modified", "additions": 63, "deletions": 0, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/c0bcaea46652ade4259559f08368179d54d4fdd1/crates%2Fra_hir_ty%2Fsrc%2Ftests%2Fsimple.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0bcaea46652ade4259559f08368179d54d4fdd1/crates%2Fra_hir_ty%2Fsrc%2Ftests%2Fsimple.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Ftests%2Fsimple.rs?ref=c0bcaea46652ade4259559f08368179d54d4fdd1", "patch": "@@ -1860,3 +1860,66 @@ fn test() {\n     \"###\n     );\n }\n+\n+#[test]\n+fn infer_loop_break_with_val() {\n+    assert_snapshot!(\n+        infer(r#\"\n+enum Option<T> { Some(T), None }\n+use Option::*;\n+\n+fn test() {\n+    let x = loop {\n+        if false {\n+            break None;\n+        }\n+\n+        break Some(true);\n+    };\n+}\n+\"#),\n+        @r###\"\n+    60..169 '{     ...  }; }': ()\n+    70..71 'x': Option<bool>\n+    74..166 'loop {...     }': Option<bool>\n+    79..166 '{     ...     }': ()\n+    89..133 'if fal...     }': ()\n+    92..97 'false': bool\n+    98..133 '{     ...     }': ()\n+    112..122 'break None': !\n+    118..122 'None': Option<bool>\n+    143..159 'break ...(true)': !\n+    149..153 'Some': Some<bool>(bool) -> Option<bool>\n+    149..159 'Some(true)': Option<bool>\n+    154..158 'true': bool\n+    \"###\n+    );\n+}\n+\n+#[test]\n+fn infer_loop_break_without_val() {\n+    assert_snapshot!(\n+        infer(r#\"\n+enum Option<T> { Some(T), None }\n+use Option::*;\n+\n+fn test() {\n+    let x = loop {\n+        if false {\n+            break;\n+        }\n+    };\n+}\n+\"#),\n+        @r###\"\n+    60..137 '{     ...  }; }': ()\n+    70..71 'x': ()\n+    74..134 'loop {...     }': ()\n+    79..134 '{     ...     }': ()\n+    89..128 'if fal...     }': ()\n+    92..97 'false': bool\n+    98..128 '{     ...     }': ()\n+    112..117 'break': !\n+    \"###\n+    );\n+}"}]}