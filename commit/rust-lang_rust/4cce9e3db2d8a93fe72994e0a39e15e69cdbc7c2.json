{"sha": "4cce9e3db2d8a93fe72994e0a39e15e69cdbc7c2", "node_id": "MDY6Q29tbWl0NzI0NzEyOjRjY2U5ZTNkYjJkOGE5M2ZlNzI5OTRlMGEzOWUxNWU2OWNkYmM3YzI=", "commit": {"author": {"name": "Christiaan Dirkx", "email": "christiaan@dirkx.email", "date": "2021-03-26T13:47:25Z"}, "committer": {"name": "Christiaan Dirkx", "email": "christiaan@dirkx.email", "date": "2021-03-26T13:47:25Z"}, "message": "Cache `GetProcessHeap`", "tree": {"sha": "c82a5d4a1f832329d1b03653264662adfcc8c4a9", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c82a5d4a1f832329d1b03653264662adfcc8c4a9"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4cce9e3db2d8a93fe72994e0a39e15e69cdbc7c2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4cce9e3db2d8a93fe72994e0a39e15e69cdbc7c2", "html_url": "https://github.com/rust-lang/rust/commit/4cce9e3db2d8a93fe72994e0a39e15e69cdbc7c2", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4cce9e3db2d8a93fe72994e0a39e15e69cdbc7c2/comments", "author": {"login": "CDirkx", "id": 11176562, "node_id": "MDQ6VXNlcjExMTc2NTYy", "avatar_url": "https://avatars.githubusercontent.com/u/11176562?v=4", "gravatar_id": "", "url": "https://api.github.com/users/CDirkx", "html_url": "https://github.com/CDirkx", "followers_url": "https://api.github.com/users/CDirkx/followers", "following_url": "https://api.github.com/users/CDirkx/following{/other_user}", "gists_url": "https://api.github.com/users/CDirkx/gists{/gist_id}", "starred_url": "https://api.github.com/users/CDirkx/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/CDirkx/subscriptions", "organizations_url": "https://api.github.com/users/CDirkx/orgs", "repos_url": "https://api.github.com/users/CDirkx/repos", "events_url": "https://api.github.com/users/CDirkx/events{/privacy}", "received_events_url": "https://api.github.com/users/CDirkx/received_events", "type": "User", "site_admin": false}, "committer": {"login": "CDirkx", "id": 11176562, "node_id": "MDQ6VXNlcjExMTc2NTYy", "avatar_url": "https://avatars.githubusercontent.com/u/11176562?v=4", "gravatar_id": "", "url": "https://api.github.com/users/CDirkx", "html_url": "https://github.com/CDirkx", "followers_url": "https://api.github.com/users/CDirkx/followers", "following_url": "https://api.github.com/users/CDirkx/following{/other_user}", "gists_url": "https://api.github.com/users/CDirkx/gists{/gist_id}", "starred_url": "https://api.github.com/users/CDirkx/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/CDirkx/subscriptions", "organizations_url": "https://api.github.com/users/CDirkx/orgs", "repos_url": "https://api.github.com/users/CDirkx/repos", "events_url": "https://api.github.com/users/CDirkx/events{/privacy}", "received_events_url": "https://api.github.com/users/CDirkx/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b01bf0e9d311332d7942619845281af4b9da54bb", "url": "https://api.github.com/repos/rust-lang/rust/commits/b01bf0e9d311332d7942619845281af4b9da54bb", "html_url": "https://github.com/rust-lang/rust/commit/b01bf0e9d311332d7942619845281af4b9da54bb"}], "stats": {"total": 70, "additions": 54, "deletions": 16}, "files": [{"sha": "bc4725dfc7b3995b8cf1fcb0600ce496566bbb5c", "filename": "library/std/src/sys/windows/alloc.rs", "status": "modified", "additions": 54, "deletions": 16, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/4cce9e3db2d8a93fe72994e0a39e15e69cdbc7c2/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Falloc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4cce9e3db2d8a93fe72994e0a39e15e69cdbc7c2/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Falloc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Falloc.rs?ref=4cce9e3db2d8a93fe72994e0a39e15e69cdbc7c2", "patch": "@@ -1,7 +1,9 @@\n #![deny(unsafe_op_in_unsafe_fn)]\n \n use crate::alloc::{GlobalAlloc, Layout, System};\n+use crate::ffi::c_void;\n use crate::ptr;\n+use crate::sync::atomic::{AtomicPtr, Ordering};\n use crate::sys::c;\n use crate::sys_common::alloc::{realloc_fallback, MIN_ALIGN};\n \n@@ -17,6 +19,9 @@ const HEAP_ZERO_MEMORY: c::DWORD = 0x00000008;\n extern \"system\" {\n     // Get a handle to the default heap of the current process, or null if the operation fails.\n     //\n+    // SAFETY: Successful calls to this function within the same process are assumed to\n+    // always return the same handle, which remains valid for the entire lifetime of the process.\n+    //\n     // See https://docs.microsoft.com/windows/win32/api/heapapi/nf-heapapi-getprocessheap\n     fn GetProcessHeap() -> c::HANDLE;\n \n@@ -66,29 +71,59 @@ extern \"system\" {\n     // Returns a nonzero value if the operation is successful, and zero if the operation fails.\n     //\n     // SAFETY:\n+    //  - `hHeap` must be a non-null handle returned by `GetProcessHeap`.\n     //  - `dwFlags` must be set to zero.\n     //  - `lpMem` must be a pointer to an allocated block returned by `HeapAlloc` or `HeapReAlloc`,\n     //     that has not already been freed.\n     // If the block was successfully freed, pointers pointing to the freed memory, such as `lpMem`,\n     // must not be dereferenced ever again.\n     //\n-    // Note that both `hHeap` is allowed to be any value, and `lpMem` is allowed to be null,\n-    // both of which will not cause the operation to fail.\n+    // Note that `lpMem` is allowed to be null, which will not cause the operation to fail.\n     //\n     // See https://docs.microsoft.com/windows/win32/api/heapapi/nf-heapapi-heapfree\n     fn HeapFree(hHeap: c::HANDLE, dwFlags: c::DWORD, lpMem: c::LPVOID) -> c::BOOL;\n }\n \n+// Cached handle to the default heap of the current process.\n+// Either a non-null handle returned by `GetProcessHeap`, or null when not yet initialized or `GetProcessHeap` failed.\n+static HEAP: AtomicPtr<c_void> = AtomicPtr::new(ptr::null_mut());\n+\n+// Get a handle to the default heap of the current process, or null if the operation fails.\n+// SAFETY: If this operation is successful, `HEAP` will be successfully initialized and contain\n+// a non-null handle returned by `GetProcessHeap`.\n+#[inline]\n+unsafe fn init_or_get_process_heap() -> c::HANDLE {\n+    let heap = HEAP.load(Ordering::Relaxed);\n+    if heap.is_null() {\n+        // `HEAP` has not yet been successfully initialized\n+        let heap = unsafe { GetProcessHeap() };\n+        if !heap.is_null() {\n+            // SAFETY: No locking is needed because within the same process,\n+            // successful calls to `GetProcessHeap` will always return the same value, even on different threads.\n+            HEAP.store(heap, Ordering::Relaxed);\n+\n+            // SAFETY: `HEAP` contains a non-null handle returned by `GetProcessHeap`\n+            heap\n+        } else {\n+            // Could not get the current process heap.\n+            ptr::null_mut()\n+        }\n+    } else {\n+        // SAFETY: `HEAP` contains a non-null handle returned by `GetProcessHeap`\n+        heap\n+    }\n+}\n+\n // Header containing a pointer to the start of an allocated block.\n-// SAFETY: size and alignment must be <= `MIN_ALIGN`.\n+// SAFETY: Size and alignment must be <= `MIN_ALIGN`.\n #[repr(C)]\n struct Header(*mut u8);\n \n-// Allocates a block of optionally zeroed memory for a given `layout`.\n-// Returns a pointer satisfying the guarantees of `System` about allocated pointers.\n+// Allocate a block of optionally zeroed memory for a given `layout`.\n+// SAFETY: Returns a pointer satisfying the guarantees of `System` about allocated pointers.\n #[inline]\n unsafe fn allocate(layout: Layout, zeroed: bool) -> *mut u8 {\n-    let heap = unsafe { GetProcessHeap() };\n+    let heap = unsafe { init_or_get_process_heap() };\n     if heap.is_null() {\n         // Allocation has failed, could not get the current process heap.\n         return ptr::null_mut();\n@@ -147,14 +182,14 @@ unsafe fn allocate(layout: Layout, zeroed: bool) -> *mut u8 {\n unsafe impl GlobalAlloc for System {\n     #[inline]\n     unsafe fn alloc(&self, layout: Layout) -> *mut u8 {\n-        // SAFETY: pointers returned by `allocate` satisfy the guarantees of `System`\n+        // SAFETY: Pointers returned by `allocate` satisfy the guarantees of `System`\n         let zeroed = false;\n         unsafe { allocate(layout, zeroed) }\n     }\n \n     #[inline]\n     unsafe fn alloc_zeroed(&self, layout: Layout) -> *mut u8 {\n-        // SAFETY: pointers returned by `allocate` satisfy the guarantees of `System`\n+        // SAFETY: Pointers returned by `allocate` satisfy the guarantees of `System`\n         let zeroed = true;\n         unsafe { allocate(layout, zeroed) }\n     }\n@@ -173,24 +208,27 @@ unsafe impl GlobalAlloc for System {\n             }\n         };\n \n+        // SAFETY: because `ptr` has been successfully allocated with this allocator,\n+        // `HEAP` must have been successfully initialized and contain a non-null handle\n+        // returned by `GetProcessHeap`.\n+        let heap = HEAP.load(Ordering::Relaxed);\n+\n         // SAFETY: `block` is a pointer to the start of an allocated block.\n         unsafe {\n-            let err = HeapFree(GetProcessHeap(), 0, block as c::LPVOID);\n+            let err = HeapFree(heap, 0, block as c::LPVOID);\n             debug_assert!(err != 0, \"Failed to free heap memory: {}\", c::GetLastError());\n         }\n     }\n \n     #[inline]\n     unsafe fn realloc(&self, ptr: *mut u8, layout: Layout, new_size: usize) -> *mut u8 {\n         if layout.align() <= MIN_ALIGN {\n-            let heap = unsafe { GetProcessHeap() };\n-            if heap.is_null() {\n-                // Reallocation has failed, could not get the current process heap.\n-                return ptr::null_mut();\n-            }\n+            // SAFETY: because `ptr` has been successfully allocated with this allocator,\n+            // `HEAP` must have been successfully initialized and contain a non-null handle\n+            // returned by `GetProcessHeap`.\n+            let heap = HEAP.load(Ordering::Relaxed);\n \n-            // SAFETY: `heap` is a non-null handle returned by `GetProcessHeap`,\n-            // `ptr` is a pointer to the start of an allocated block.\n+            // SAFETY: `ptr` is a pointer to the start of an allocated block.\n             // The returned pointer points to the start of an allocated block.\n             unsafe { HeapReAlloc(heap, 0, ptr as c::LPVOID, new_size) as *mut u8 }\n         } else {"}]}