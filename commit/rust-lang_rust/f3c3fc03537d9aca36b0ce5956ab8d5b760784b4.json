{"sha": "f3c3fc03537d9aca36b0ce5956ab8d5b760784b4", "node_id": "MDY6Q29tbWl0NzI0NzEyOmYzYzNmYzAzNTM3ZDlhY2EzNmIwY2U1OTU2YWI4ZDViNzYwNzg0YjQ=", "commit": {"author": {"name": "Graydon Hoare", "email": "graydon@mozilla.com", "date": "2011-01-14T01:42:28Z"}, "committer": {"name": "Graydon Hoare", "email": "graydon@mozilla.com", "date": "2011-01-14T01:42:28Z"}, "message": "Change single-ident expr_ident to greedy/fat multi-ident expr_path, to handle the module-path/value-indexing distinction.", "tree": {"sha": "802723cba8094d8aba500e9a8d6774c86ea2f54a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/802723cba8094d8aba500e9a8d6774c86ea2f54a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f3c3fc03537d9aca36b0ce5956ab8d5b760784b4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f3c3fc03537d9aca36b0ce5956ab8d5b760784b4", "html_url": "https://github.com/rust-lang/rust/commit/f3c3fc03537d9aca36b0ce5956ab8d5b760784b4", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f3c3fc03537d9aca36b0ce5956ab8d5b760784b4/comments", "author": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "committer": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3722326cd7dddf367edee4adf44fc3da89955428", "url": "https://api.github.com/repos/rust-lang/rust/commits/3722326cd7dddf367edee4adf44fc3da89955428", "html_url": "https://github.com/rust-lang/rust/commit/3722326cd7dddf367edee4adf44fc3da89955428"}], "stats": {"total": 268, "additions": 170, "deletions": 98}, "files": [{"sha": "1ee50c2a40eb2d1d9beae01e26b6c0166d1b0e5d", "filename": "src/comp/front/ast.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/f3c3fc03537d9aca36b0ce5956ab8d5b760784b4/src%2Fcomp%2Ffront%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f3c3fc03537d9aca36b0ce5956ab8d5b760784b4/src%2Fcomp%2Ffront%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Ffront%2Fast.rs?ref=f3c3fc03537d9aca36b0ce5956ab8d5b760784b4", "patch": "@@ -8,9 +8,8 @@ import util.common.ty_mach;\n \n type ident = str;\n \n-type name_ = rec(ident ident, vec[@ty] types);\n-type name = spanned[name_];\n-type path = vec[name];\n+type path_ = rec(vec[ident] idents, vec[@ty] types);\n+type path = spanned[path_];\n \n type crate_num = int;\n type def_num = int;\n@@ -158,7 +157,7 @@ tag expr_ {\n     expr_assign_op(binop, @expr /* TODO: @expr|is_lval */, @expr, ann);\n     expr_field(@expr, ident, ann);\n     expr_index(@expr, @expr, ann);\n-    expr_name(name, option.t[def], ann);\n+    expr_path(path, option.t[def], ann);\n }\n \n type lit = spanned[lit_];"}, {"sha": "c44da8f1cd44ae7a3573166f591d0ccf5037d51a", "filename": "src/comp/front/parser.rs", "status": "modified", "additions": 68, "deletions": 34, "changes": 102, "blob_url": "https://github.com/rust-lang/rust/blob/f3c3fc03537d9aca36b0ce5956ab8d5b760784b4/src%2Fcomp%2Ffront%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f3c3fc03537d9aca36b0ce5956ab8d5b760784b4/src%2Fcomp%2Ffront%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Ffront%2Fparser.rs?ref=f3c3fc03537d9aca36b0ce5956ab8d5b760784b4", "patch": "@@ -283,26 +283,7 @@ impure fn parse_ty(parser p) -> @ast.ty {\n         }\n \n         case (token.IDENT(_)) {\n-            let ast.path pth = vec();\n-            let bool more = true;\n-            while (more) {\n-                alt (p.peek()) {\n-                    case (token.IDENT(?i)) {\n-                        auto n = parse_name(p, i);\n-                        hi = n.span;\n-                        pth += n;\n-                        if (p.peek() == token.DOT) {\n-                            p.bump();\n-                        } else {\n-                            more = false;\n-                        }\n-                    }\n-                    case (_) {\n-                        more = false;\n-                    }\n-                }\n-            }\n-            t = ast.ty_path(pth, none[ast.def]);\n+            t = ast.ty_path(parse_path(p, true), none[ast.def]);\n         }\n \n         case (_) {\n@@ -391,14 +372,46 @@ impure fn parse_lit(parser p) -> option.t[ast.lit] {\n     ret some(spanned(lo, lo, lit));\n }\n \n-impure fn parse_name(parser p, ast.ident id) -> ast.name {\n+fn is_ident(token.token t) -> bool {\n+    alt (t) {\n+        case (token.IDENT(_)) { ret true; }\n+        case (_) {}\n+    }\n+    ret false;\n+}\n+\n+impure fn parse_path(parser p, bool greedy) -> ast.path {\n \n     auto lo = p.get_span();\n+    auto hi = lo;\n \n-    p.bump();\n+    let vec[ast.ident] ids = vec();\n+    let bool more = true;\n+    while (more) {\n+        alt (p.peek()) {\n+            case (token.IDENT(?i)) {\n+                hi = p.get_span();\n+                ids += i;\n+                p.bump();\n+                if (p.peek() == token.DOT) {\n+                    if (greedy) {\n+                        p.bump();\n+                        check (is_ident(p.peek()));\n+                    } else {\n+                        more = false;\n+                    }\n+                } else {\n+                    more = false;\n+                }\n+            }\n+            case (_) {\n+                more = false;\n+            }\n+        }\n+    }\n \n     let vec[@ast.ty] v = vec();\n-    let util.common.spanned[vec[@ast.ty]] tys = rec(node=v, span=lo);\n+    let util.common.spanned[vec[@ast.ty]] tys = rec(node=v, span=hi);\n \n     alt (p.peek()) {\n         case (token.LBRACKET) {\n@@ -411,7 +424,7 @@ impure fn parse_name(parser p, ast.ident id) -> ast.name {\n         case (_) {\n         }\n     }\n-    ret spanned(lo, tys.span, rec(ident=id, types=tys.node));\n+    ret spanned(lo, tys.span, rec(idents=ids, types=tys.node));\n }\n \n impure fn parse_mutabliity(parser p) -> ast.mutability {\n@@ -442,10 +455,10 @@ impure fn parse_bottom_expr(parser p) -> @ast.expr {\n \n     alt (p.peek()) {\n \n-        case (token.IDENT(?i)) {\n-            auto n = parse_name(p, i);\n-            hi = n.span;\n-            ex = ast.expr_name(n, none[ast.def], ast.ann_none);\n+        case (token.IDENT(_)) {\n+            auto pth = parse_path(p, false);\n+            hi = pth.span;\n+            ex = ast.expr_path(pth, none[ast.def], ast.ann_none);\n         }\n \n         case (token.LPAREN) {\n@@ -546,7 +559,29 @@ impure fn parse_bottom_expr(parser p) -> @ast.expr {\n     ret @spanned(lo, hi, ex);\n }\n \n-impure fn parse_path_expr(parser p) -> @ast.expr {\n+fn append_dot_ident_to_expr(span lo, span hi,\n+                            @ast.expr e, ast.ident i) -> @ast.expr {\n+    auto e_ = e.node;\n+    alt (e.node) {\n+        case (ast.expr_path(?pth, ?def, ?ann)) {\n+            if (_vec.len[@ast.ty](pth.node.types) == 0u) {\n+                auto idents_ = pth.node.idents;\n+                idents_ += i;\n+                auto pth_ = rec(node=rec(idents=idents_ with pth.node)\n+                                with pth);\n+                e_ = ast.expr_path(pth_, def, ann);\n+            } else {\n+                e_ = ast.expr_field(e, i, ann);\n+            }\n+        }\n+        case (_) {\n+            e_ = ast.expr_field(e, i, ast.ann_none);\n+        }\n+    }\n+    ret @spanned(lo, hi, e_);\n+}\n+\n+impure fn parse_dot_or_call_expr(parser p) -> @ast.expr {\n     auto lo = p.get_span();\n     auto e = parse_bottom_expr(p);\n     auto hi = e.span;\n@@ -576,8 +611,7 @@ impure fn parse_path_expr(parser p) -> @ast.expr {\n                     case (token.IDENT(?i)) {\n                         hi = p.get_span();\n                         p.bump();\n-                        auto e_ = ast.expr_field(e, i, ast.ann_none);\n-                        e = @spanned(lo, hi, e_);\n+                        e = append_dot_ident_to_expr(lo, hi, e, i);\n                     }\n \n                     case (token.LPAREN) {\n@@ -645,7 +679,7 @@ impure fn parse_prefix_expr(parser p) -> @ast.expr {\n                 }\n \n                 case (_) {\n-                    ret parse_path_expr(p);\n+                    ret parse_dot_or_call_expr(p);\n                 }\n             }\n         }\n@@ -658,7 +692,7 @@ impure fn parse_prefix_expr(parser p) -> @ast.expr {\n         }\n \n         case (_) {\n-            ret parse_path_expr(p);\n+            ret parse_dot_or_call_expr(p);\n         }\n     }\n     ret @spanned(lo, hi, ex);\n@@ -1254,7 +1288,7 @@ fn stmt_ends_with_semi(@ast.stmt stmt) -> bool {\n                                                 { ret true; }\n                 case (ast.expr_field(_,_,_))    { ret true; }\n                 case (ast.expr_index(_,_,_))    { ret true; }\n-                case (ast.expr_name(_,_,_))     { ret true; }\n+                case (ast.expr_path(_,_,_))     { ret true; }\n                 case (_)                        { fail; }\n             }\n         }"}, {"sha": "b96ca93897ba3e832a677c6c0517c7229b614324", "filename": "src/comp/middle/fold.rs", "status": "modified", "additions": 21, "deletions": 25, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/f3c3fc03537d9aca36b0ce5956ab8d5b760784b4/src%2Fcomp%2Fmiddle%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f3c3fc03537d9aca36b0ce5956ab8d5b760784b4/src%2Fcomp%2Fmiddle%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ffold.rs?ref=f3c3fc03537d9aca36b0ce5956ab8d5b760784b4", "patch": "@@ -11,7 +11,6 @@ import util.common.append;\n \n import front.ast;\n import front.ast.ident;\n-import front.ast.name;\n import front.ast.path;\n import front.ast.mutability;\n import front.ast.ty;\n@@ -34,8 +33,8 @@ import std._vec;\n type ast_fold[ENV] =\n     @rec\n     (\n-     // Name fold.\n-     (fn(&ENV e, &span sp, ast.name_ n) -> name)  fold_name,\n+     // Path fold.\n+     (fn(&ENV e, &span sp, ast.path_ p) -> path)  fold_path,\n \n      // Type folds.\n      (fn(&ENV e, &span sp) -> @ty)                fold_ty_nil,\n@@ -137,9 +136,9 @@ type ast_fold[ENV] =\n          ann a) -> @expr)                         fold_expr_index,\n \n      (fn(&ENV e, &span sp,\n-         &name n,\n+         &path p,\n          &option.t[def] d,\n-         ann a) -> @expr)                         fold_expr_name,\n+         ann a) -> @expr)                         fold_expr_path,\n \n      // Decl folds.\n      (fn(&ENV e, &span sp,\n@@ -249,13 +248,13 @@ type ast_fold[ENV] =\n \n //// Fold drivers.\n \n-fn fold_name[ENV](&ENV env, ast_fold[ENV] fld, &name n) -> name {\n+fn fold_path[ENV](&ENV env, ast_fold[ENV] fld, &path p) -> path {\n     let vec[@ast.ty] tys_ = vec();\n-    for (@ast.ty t in n.node.types) {\n+    for (@ast.ty t in p.node.types) {\n         append[@ast.ty](tys_, fold_ty(env, fld, t));\n     }\n-    let ast.name_ n_ = rec(ident=n.node.ident, types=tys_);\n-    ret fld.fold_name(env, n.span, n_);\n+    let ast.path_ p_ = rec(idents=p.node.idents, types=tys_);\n+    ret fld.fold_path(env, p.span, p_);\n }\n \n fn fold_ty[ENV](&ENV env, ast_fold[ENV] fld, @ty t) -> @ty {\n@@ -321,11 +320,8 @@ fn fold_ty[ENV](&ENV env, ast_fold[ENV] fld, @ty t) -> @ty {\n         }\n \n         case (ast.ty_path(?pth, ?ref_opt)) {\n-            let vec[ast.name] path = vec();\n-            for (ast.name n in pth) {\n-                path += fold_name(env, fld, n);\n-            }\n-            ret fld.fold_ty_path(env_, t.span, path, ref_opt);\n+            auto pth_ = fold_path(env, fld, pth);\n+            ret fld.fold_ty_path(env_, t.span, pth_, ref_opt);\n         }\n \n         case (ast.ty_mutable(?ty)) {\n@@ -550,9 +546,9 @@ fn fold_expr[ENV](&ENV env, ast_fold[ENV] fld, &@expr e) -> @expr {\n             ret fld.fold_expr_index(env_, e.span, ee, iix, t);\n         }\n \n-        case (ast.expr_name(?n, ?r, ?t)) {\n-            auto n_ = fold_name(env_, fld, n);\n-            ret fld.fold_expr_name(env_, e.span, n_, r, t);\n+        case (ast.expr_path(?p, ?r, ?t)) {\n+            auto p_ = fold_path(env_, fld, p);\n+            ret fld.fold_expr_path(env_, e.span, p_, r, t);\n         }\n     }\n \n@@ -809,10 +805,10 @@ fn respan[T](&span sp, &T t) -> spanned[T] {\n }\n \n \n-// Name identity.\n+// Path identity.\n \n-fn identity_fold_name[ENV](&ENV env, &span sp, ast.name_ n) -> name {\n-    ret respan(sp, n);\n+fn identity_fold_path[ENV](&ENV env, &span sp, ast.path_ p) -> path {\n+    ret respan(sp, p);\n }\n \n // Type identities.\n@@ -983,10 +979,10 @@ fn identity_fold_expr_index[ENV](&ENV env, &span sp,\n     ret @respan(sp, ast.expr_index(e, ix, a));\n }\n \n-fn identity_fold_expr_name[ENV](&ENV env, &span sp,\n-                                &name n, &option.t[def] d,\n+fn identity_fold_expr_path[ENV](&ENV env, &span sp,\n+                                &path p, &option.t[def] d,\n                                 ann a) -> @expr {\n-    ret @respan(sp, ast.expr_name(n, d, a));\n+    ret @respan(sp, ast.expr_path(p, d, a));\n }\n \n \n@@ -1176,7 +1172,7 @@ fn always_keep_going[ENV](&ENV e) -> bool {\n fn new_identity_fold[ENV]() -> ast_fold[ENV] {\n     ret @rec\n         (\n-         fold_name       = bind identity_fold_name[ENV](_,_,_),\n+         fold_path       = bind identity_fold_path[ENV](_,_,_),\n \n          fold_ty_nil     = bind identity_fold_ty_nil[ENV](_,_),\n          fold_ty_bool    = bind identity_fold_ty_bool[ENV](_,_),\n@@ -1214,7 +1210,7 @@ fn new_identity_fold[ENV]() -> ast_fold[ENV] {\n                        = bind identity_fold_expr_assign_op[ENV](_,_,_,_,_,_),\n          fold_expr_field  = bind identity_fold_expr_field[ENV](_,_,_,_,_),\n          fold_expr_index  = bind identity_fold_expr_index[ENV](_,_,_,_,_),\n-         fold_expr_name   = bind identity_fold_expr_name[ENV](_,_,_,_,_),\n+         fold_expr_path   = bind identity_fold_expr_path[ENV](_,_,_,_,_),\n \n          fold_decl_local  = bind identity_fold_decl_local[ENV](_,_,_),\n          fold_decl_item   = bind identity_fold_decl_item[ENV](_,_,_),"}, {"sha": "f7567590daae81691a4e4907d6d8d30b0d18ac5a", "filename": "src/comp/middle/resolve.rs", "status": "modified", "additions": 51, "deletions": 15, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/f3c3fc03537d9aca36b0ce5956ab8d5b760784b4/src%2Fcomp%2Fmiddle%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f3c3fc03537d9aca36b0ce5956ab8d5b760784b4/src%2Fcomp%2Fmiddle%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fresolve.rs?ref=f3c3fc03537d9aca36b0ce5956ab8d5b760784b4", "patch": "@@ -295,25 +295,63 @@ fn fold_pat_tag(&env e, &span sp, import_map index, ident i,\n     ret @fold.respan[ast.pat_](sp, ast.pat_tag(i, args, new_def, a));\n }\n \n-fn fold_expr_name(&env e, &span sp, import_map index,\n-                  &ast.name n, &option.t[def] d, ann a) -> @ast.expr {\n-\n-    if (_vec.len[@ast.ty](n.node.types) > 0u) {\n+// We received a path expression of the following form:\n+//\n+//     a.b.c.d\n+//\n+// Somewhere along this path there might be a split from a path-expr\n+// to a runtime field-expr. For example:\n+//\n+//     'a' could be the name of a variable in the local scope\n+//     and 'b.c.d' could be a field-sequence inside it.\n+//\n+// Or:\n+//\n+//     'a.b' could be a module path to a constant record, and 'c.d'\n+//     could be a field within it.\n+//\n+// Our job here is to figure out what the prefix of 'a.b.c.d' is that\n+// corresponds to a static binding-name (a module or slot, with no type info)\n+// and split that off as the 'primary' expr_path, with secondary expr_field\n+// expressions tacked on the end.\n+\n+fn fold_expr_path(&env e, &span sp, import_map index,\n+                  &ast.path p, &option.t[def] d, ann a) -> @ast.expr {\n+\n+    if (_vec.len[@ast.ty](p.node.types) > 0u) {\n         e.sess.unimpl(\"resolving name expr with ty params\");\n     }\n \n-    auto d_ = unwrap_def(lookup_name(e, some(index), n.node.ident));\n+    auto n_idents = _vec.len[ast.ident](p.node.idents);\n+\n+    check (n_idents != 0u);\n+    auto id0 = p.node.idents.(0);\n+\n+    auto d_ = unwrap_def(lookup_name(e, some(index), id0));\n \n     alt (d_) {\n         case (some[def](_)) {\n             // log \"resolved name \" + n.node.ident;\n         }\n         case (none[def]) {\n-            e.sess.span_err(sp, \"unresolved name: \" + n.node.ident);\n+            e.sess.span_err(sp, \"unresolved name: \" + id0);\n         }\n     }\n \n-    ret @fold.respan[ast.expr_](sp, ast.expr_name(n, d_, a));\n+    // FIXME: once espindola's modifications to lookup land, actually step\n+    // through the path doing speculative lookup, and extend the maximal\n+    // static prefix. For now we are always using the minimal prefix: first\n+    // ident is static anchor, rest turn into fields.\n+\n+    auto p_ = rec(node=rec(idents = vec(id0) with p.node) with p);\n+    auto ex = @fold.respan[ast.expr_](sp, ast.expr_path(p_, d_, a));\n+    auto i = 1u;\n+    while (i < n_idents) {\n+        auto id = p.node.idents.(i);\n+        ex = @fold.respan[ast.expr_](sp, ast.expr_field(ex, id, a));\n+        i += 1u;\n+    }\n+    ret ex;\n }\n \n fn fold_view_item_import(&env e, &span sp,\n@@ -339,26 +377,24 @@ fn fold_view_item_import(&env e, &span sp,\n fn fold_ty_path(&env e, &span sp, import_map index, ast.path p,\n                 &option.t[def] d) -> @ast.ty {\n \n-    let uint len = _vec.len[ast.name](p);\n+    let uint len = _vec.len[ast.ident](p.node.idents);\n     check (len != 0u);\n     if (len > 1u) {\n         e.sess.unimpl(\"resolving path ty with >1 component\");\n     }\n \n-    let ast.name n = p.(0);\n-\n-    if (_vec.len[@ast.ty](n.node.types) > 0u) {\n+    if (_vec.len[@ast.ty](p.node.types) > 0u) {\n         e.sess.unimpl(\"resolving path ty with ty params\");\n     }\n \n-    auto d_ = unwrap_def(lookup_name(e, some(index), n.node.ident));\n+    auto d_ = unwrap_def(lookup_name(e, some(index), p.node.idents.(0)));\n \n     alt (d_) {\n-        case (some[def](_)) {\n+        case (some[def](?d)) {\n             // log \"resolved name \" + n.node.ident;\n         }\n         case (none[def]) {\n-            e.sess.span_err(sp, \"unresolved name: \" + n.node.ident);\n+            e.sess.span_err(sp, \"unresolved name: \" + p.node.idents.(0));\n         }\n     }\n \n@@ -387,7 +423,7 @@ fn resolve_crate(session.session sess, @ast.crate crate) -> @ast.crate {\n \n     auto import_index = new_def_hash[def_wrap]();\n     fld = @rec( fold_pat_tag = bind fold_pat_tag(_,_,import_index,_,_,_,_),\n-                fold_expr_name = bind fold_expr_name(_,_,import_index,_,_,_),\n+                fold_expr_path = bind fold_expr_path(_,_,import_index,_,_,_),\n                 fold_view_item_import\n                     = bind fold_view_item_import(_,_,import_index,_,_),\n                 fold_ty_path = bind fold_ty_path(_,_,import_index,_,_),"}, {"sha": "594d7bc58a05d1fc2e84d2e6286c55e31445ca8f", "filename": "src/comp/middle/trans.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/f3c3fc03537d9aca36b0ce5956ab8d5b760784b4/src%2Fcomp%2Fmiddle%2Ftrans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f3c3fc03537d9aca36b0ce5956ab8d5b760784b4/src%2Fcomp%2Fmiddle%2Ftrans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans.rs?ref=f3c3fc03537d9aca36b0ce5956ab8d5b760784b4", "patch": "@@ -1772,7 +1772,7 @@ fn lval_val(@block_ctxt cx, ValueRef val) -> lval_result {\n             llobj=none[ValueRef]);\n }\n \n-fn trans_name(@block_ctxt cx, &ast.name n, &option.t[ast.def] dopt,\n+fn trans_path(@block_ctxt cx, &ast.path p, &option.t[ast.def] dopt,\n         &ast.ann ann) -> lval_result {\n     alt (dopt) {\n         case (some[ast.def](?def)) {\n@@ -1826,7 +1826,7 @@ fn trans_name(@block_ctxt cx, &ast.name n, &option.t[ast.def] dopt,\n             }\n         }\n         case (none[ast.def]) {\n-            cx.fcx.ccx.sess.err(\"unresolved expr_name in trans\");\n+            cx.fcx.ccx.sess.err(\"unresolved expr_path in trans\");\n         }\n     }\n     fail;\n@@ -1906,8 +1906,8 @@ impure fn trans_index(@block_ctxt cx, &ast.span sp, @ast.expr base,\n \n impure fn trans_lval(@block_ctxt cx, @ast.expr e) -> lval_result {\n     alt (e.node) {\n-        case (ast.expr_name(?n, ?dopt, ?ann)) {\n-            ret trans_name(cx, n, dopt, ann);\n+        case (ast.expr_path(?p, ?dopt, ?ann)) {\n+            ret trans_path(cx, p, dopt, ann);\n         }\n         case (ast.expr_field(?base, ?ident, ?ann)) {\n             ret trans_field(cx, e.span, base, ident, ann);"}, {"sha": "b55e8be69fc70c525a22018fd5dc40fe1061bf00", "filename": "src/comp/middle/ty.rs", "status": "modified", "additions": 14, "deletions": 11, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/f3c3fc03537d9aca36b0ce5956ab8d5b760784b4/src%2Fcomp%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f3c3fc03537d9aca36b0ce5956ab8d5b760784b4/src%2Fcomp%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fty.rs?ref=f3c3fc03537d9aca36b0ce5956ab8d5b760784b4", "patch": "@@ -146,22 +146,17 @@ fn ast_ty_to_str(&@ast.ty ty) -> str {\n     ret s;\n }\n \n-fn name_to_str(&ast.name nm) -> str {\n-    auto result = nm.node.ident;\n-    if (_vec.len[@ast.ty](nm.node.types) > 0u) {\n+fn path_to_str(&ast.path pth) -> str {\n+    auto result = _str.connect(pth.node.idents,  \".\");\n+    if (_vec.len[@ast.ty](pth.node.types) > 0u) {\n         auto f = ast_ty_to_str;\n         result += \"[\";\n-        result += _str.connect(_vec.map[@ast.ty,str](f, nm.node.types), \",\");\n+        result += _str.connect(_vec.map[@ast.ty,str](f, pth.node.types), \",\");\n         result += \"]\";\n     }\n     ret result;\n }\n \n-fn path_to_str(&ast.path path) -> str {\n-    auto f = name_to_str;\n-    ret _str.connect(_vec.map[ast.name,str](f, path), \".\");\n-}\n-\n fn ty_to_str(&@t typ) -> str {\n \n     fn fn_input_to_str(&rec(ast.mode mode, @t ty) input) -> str {\n@@ -632,7 +627,7 @@ fn expr_ty(@ast.expr expr) -> @t {\n                                               { ret ann_to_type(ann); }\n         case (ast.expr_field(_, _, ?ann))     { ret ann_to_type(ann); }\n         case (ast.expr_index(_, _, ?ann))     { ret ann_to_type(ann); }\n-        case (ast.expr_name(_, _, ?ann))      { ret ann_to_type(ann); }\n+        case (ast.expr_path(_, _, ?ann))      { ret ann_to_type(ann); }\n     }\n     fail;\n }\n@@ -697,7 +692,7 @@ fn is_lval(@ast.expr expr) -> bool {\n     alt (expr.node) {\n         case (ast.expr_field(_,_,_))    { ret true;  }\n         case (ast.expr_index(_,_,_))    { ret true;  }\n-        case (ast.expr_name(_,_,_))     { ret true;  }\n+        case (ast.expr_path(_,_,_))     { ret true;  }\n         case (_)                        { ret false; }\n     }\n }\n@@ -1238,3 +1233,11 @@ fn resolve_ty_params(@ast.item item, @t monoty) -> vec[@t] {\n     ret result_tys;\n }\n \n+// Local Variables:\n+// mode: rust\n+// fill-column: 78;\n+// indent-tabs-mode: nil\n+// c-basic-offset: 4\n+// buffer-file-coding-system: utf-8-unix\n+// compile-command: \"make -k -C ../.. 2>&1 | sed -e 's/\\\\/x\\\\//x:\\\\//g'\";\n+// End:"}, {"sha": "d159c76f3ff5f384e487d82b559eaeef7b476ae5", "filename": "src/comp/middle/typeck.rs", "status": "modified", "additions": 9, "deletions": 5, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/f3c3fc03537d9aca36b0ce5956ab8d5b760784b4/src%2Fcomp%2Fmiddle%2Ftypeck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f3c3fc03537d9aca36b0ce5956ab8d5b760784b4/src%2Fcomp%2Fmiddle%2Ftypeck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftypeck.rs?ref=f3c3fc03537d9aca36b0ce5956ab8d5b760784b4", "patch": "@@ -753,9 +753,9 @@ fn demand_expr(&@fn_ctxt fcx, @ty.t expected, @ast.expr e) -> @ast.expr {\n             auto t = demand(fcx, e.span, expected, ann_to_type(ann));\n             e_1 = ast.expr_index(base, index, ast.ann_type(t));\n         }\n-        case (ast.expr_name(?name, ?d, ?ann)) {\n+        case (ast.expr_path(?pth, ?d, ?ann)) {\n             auto t = demand(fcx, e.span, expected, ann_to_type(ann));\n-            e_1 = ast.expr_name(name, d, ast.ann_type(t));\n+            e_1 = ast.expr_path(pth, d, ast.ann_type(t));\n         }\n         case (_) {\n             fail;\n@@ -941,7 +941,7 @@ fn check_expr(&@fn_ctxt fcx, @ast.expr expr) -> @ast.expr {\n                                                        ast.ann_type(oper_t)));\n         }\n \n-        case (ast.expr_name(?name, ?defopt, _)) {\n+        case (ast.expr_path(?pth, ?defopt, _)) {\n             auto t = plain_ty(ty.ty_nil);\n             check (defopt != none[ast.def]);\n             alt (option.get[ast.def](defopt)) {\n@@ -980,16 +980,20 @@ fn check_expr(&@fn_ctxt fcx, @ast.expr expr) -> @ast.expr {\n                     t = generalize_ty(fcx.ccx, fcx.ccx.item_types.get(id));\n                 }\n \n+                case (ast.def_mod(_)) {\n+                    // Hopefully part of a path.\n+                }\n+\n                 case (_) {\n                     // FIXME: handle other names.\n                     fcx.ccx.sess.unimpl(\"definition variant for: \"\n-                                        + name.node.ident);\n+                                        + _str.connect(pth.node.idents, \".\"));\n                     fail;\n                 }\n             }\n \n             ret @fold.respan[ast.expr_](expr.span,\n-                                        ast.expr_name(name, defopt,\n+                                        ast.expr_path(pth, defopt,\n                                                       ast.ann_type(t)));\n         }\n "}]}