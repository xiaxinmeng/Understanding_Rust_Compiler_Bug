{"sha": "e6cfb56a5cee28b08ae9d2dcbb2552497ce922c1", "node_id": "MDY6Q29tbWl0NzI0NzEyOmU2Y2ZiNTZhNWNlZTI4YjA4YWU5ZDJkY2JiMjU1MjQ5N2NlOTIyYzE=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-10-09T10:57:25Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-10-09T10:57:25Z"}, "message": "auto merge of #17870 : thestinger/rust/alloc, r=eddyb\n\nUsing reallocate(old_ptr, old_size, new_size, align) makes a lot more\r\nsense than reallocate(old_ptr, new_size, align, old_size) and matches up\r\nwith the order used by existing platform APIs like mremap.\r\n\r\nCloses #17837\r\n\r\n[breaking-change]", "tree": {"sha": "df2b290dd8ef76719edfe6fd7f7c1d9dff5c2d26", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/df2b290dd8ef76719edfe6fd7f7c1d9dff5c2d26"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e6cfb56a5cee28b08ae9d2dcbb2552497ce922c1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e6cfb56a5cee28b08ae9d2dcbb2552497ce922c1", "html_url": "https://github.com/rust-lang/rust/commit/e6cfb56a5cee28b08ae9d2dcbb2552497ce922c1", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e6cfb56a5cee28b08ae9d2dcbb2552497ce922c1/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1b46b007d7d1acbbfb59c7e0f1307e6a378ab584", "url": "https://api.github.com/repos/rust-lang/rust/commits/1b46b007d7d1acbbfb59c7e0f1307e6a378ab584", "html_url": "https://github.com/rust-lang/rust/commit/1b46b007d7d1acbbfb59c7e0f1307e6a378ab584"}, {"sha": "1c6fd76f8073a420a82d85c45ea1697fb94d214b", "url": "https://api.github.com/repos/rust-lang/rust/commits/1c6fd76f8073a420a82d85c45ea1697fb94d214b", "html_url": "https://github.com/rust-lang/rust/commit/1c6fd76f8073a420a82d85c45ea1697fb94d214b"}], "stats": {"total": 77, "additions": 34, "deletions": 43}, "files": [{"sha": "9a4390747198c9652a7a04e9e8f93cf621100a27", "filename": "src/liballoc/heap.rs", "status": "modified", "additions": 14, "deletions": 19, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/e6cfb56a5cee28b08ae9d2dcbb2552497ce922c1/src%2Fliballoc%2Fheap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e6cfb56a5cee28b08ae9d2dcbb2552497ce922c1/src%2Fliballoc%2Fheap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fheap.rs?ref=e6cfb56a5cee28b08ae9d2dcbb2552497ce922c1", "patch": "@@ -31,9 +31,8 @@ pub unsafe fn allocate(size: uint, align: uint) -> *mut u8 {\n /// create the allocation referenced by `ptr`. The `old_size` parameter may also\n /// be the value returned by `usable_size` for the requested size.\n #[inline]\n-pub unsafe fn reallocate(ptr: *mut u8, size: uint, align: uint,\n-                         old_size: uint) -> *mut u8 {\n-    imp::reallocate(ptr, size, align, old_size)\n+pub unsafe fn reallocate(ptr: *mut u8, old_size: uint, size: uint, align: uint) -> *mut u8 {\n+    imp::reallocate(ptr, old_size, size, align)\n }\n \n /// Extends or shrinks the allocation referenced by `ptr` to `size` bytes of\n@@ -50,9 +49,8 @@ pub unsafe fn reallocate(ptr: *mut u8, size: uint, align: uint,\n /// create the allocation referenced by `ptr`. The `old_size` parameter may be\n /// any value in range_inclusive(requested_size, usable_size).\n #[inline]\n-pub unsafe fn reallocate_inplace(ptr: *mut u8, size: uint, align: uint,\n-                                 old_size: uint) -> bool {\n-    imp::reallocate_inplace(ptr, size, align, old_size)\n+pub unsafe fn reallocate_inplace(ptr: *mut u8, old_size: uint, size: uint, align: uint) -> bool {\n+    imp::reallocate_inplace(ptr, old_size, size, align)\n }\n \n /// Deallocates the memory referenced by `ptr`.\n@@ -170,8 +168,7 @@ mod imp {\n     }\n \n     #[inline]\n-    pub unsafe fn reallocate(ptr: *mut u8, size: uint, align: uint,\n-                             _old_size: uint) -> *mut u8 {\n+    pub unsafe fn reallocate(ptr: *mut u8, _old_size: uint, size: uint, align: uint) -> *mut u8 {\n         let flags = align_to_flags(align);\n         let ptr = je_rallocx(ptr as *mut c_void, size as size_t, flags) as *mut u8;\n         if ptr.is_null() {\n@@ -181,8 +178,8 @@ mod imp {\n     }\n \n     #[inline]\n-    pub unsafe fn reallocate_inplace(ptr: *mut u8, size: uint, align: uint,\n-                                     old_size: uint) -> bool {\n+    pub unsafe fn reallocate_inplace(ptr: *mut u8, old_size: uint, size: uint,\n+                                     align: uint) -> bool {\n         let flags = align_to_flags(align);\n         let new_size = je_xallocx(ptr as *mut c_void, size as size_t, 0, flags) as uint;\n         // checking for failure to shrink is tricky\n@@ -243,8 +240,7 @@ mod imp {\n     }\n \n     #[inline]\n-    pub unsafe fn reallocate(ptr: *mut u8, size: uint, align: uint,\n-                             old_size: uint) -> *mut u8 {\n+    pub unsafe fn reallocate(ptr: *mut u8, old_size: uint, size: uint, align: uint) -> *mut u8 {\n         if align <= MIN_ALIGN {\n             libc_heap::realloc_raw(ptr, size)\n         } else {\n@@ -256,8 +252,8 @@ mod imp {\n     }\n \n     #[inline]\n-    pub unsafe fn reallocate_inplace(_ptr: *mut u8, size: uint, _align: uint,\n-                                     old_size: uint) -> bool {\n+    pub unsafe fn reallocate_inplace(_ptr: *mut u8, old_size: uint, size: uint,\n+                                     _align: uint) -> bool {\n         size == old_size\n     }\n \n@@ -303,8 +299,7 @@ mod imp {\n     }\n \n     #[inline]\n-    pub unsafe fn reallocate(ptr: *mut u8, size: uint, align: uint,\n-                             _old_size: uint) -> *mut u8 {\n+    pub unsafe fn reallocate(ptr: *mut u8, _old_size: uint, size: uint, align: uint) -> *mut u8 {\n         if align <= MIN_ALIGN {\n             libc_heap::realloc_raw(ptr, size)\n         } else {\n@@ -318,8 +313,8 @@ mod imp {\n     }\n \n     #[inline]\n-    pub unsafe fn reallocate_inplace(_ptr: *mut u8, size: uint, _align: uint,\n-                                     old_size: uint) -> bool {\n+    pub unsafe fn reallocate_inplace(_ptr: *mut u8, old_size: uint, size: uint,\n+                                     _align: uint) -> bool {\n         size == old_size\n     }\n \n@@ -351,7 +346,7 @@ mod test {\n         unsafe {\n             let size = 4000;\n             let ptr = heap::allocate(size, 8);\n-            let ret = heap::reallocate_inplace(ptr, size, 8, size);\n+            let ret = heap::reallocate_inplace(ptr, size, size, 8);\n             heap::deallocate(ptr, size, 8);\n             assert!(ret);\n         }"}, {"sha": "894ca3d7f2e7859d65c7af871f43385dfb748790", "filename": "src/libcollections/vec.rs", "status": "modified", "additions": 6, "deletions": 9, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/e6cfb56a5cee28b08ae9d2dcbb2552497ce922c1/src%2Flibcollections%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e6cfb56a5cee28b08ae9d2dcbb2552497ce922c1/src%2Flibcollections%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fvec.rs?ref=e6cfb56a5cee28b08ae9d2dcbb2552497ce922c1", "patch": "@@ -622,12 +622,11 @@ impl<T: Clone> CloneableVector<T> for Vec<T> {\n \n // FIXME: #13996: need a way to mark the return value as `noalias`\n #[inline(never)]\n-unsafe fn alloc_or_realloc<T>(ptr: *mut T, size: uint, old_size: uint) -> *mut T {\n+unsafe fn alloc_or_realloc<T>(ptr: *mut T, old_size: uint, size: uint) -> *mut T {\n     if old_size == 0 {\n         allocate(size, mem::min_align_of::<T>()) as *mut T\n     } else {\n-        reallocate(ptr as *mut u8, size,\n-                   mem::min_align_of::<T>(), old_size) as *mut T\n+        reallocate(ptr as *mut u8, old_size, size, mem::min_align_of::<T>()) as *mut T\n     }\n }\n \n@@ -720,8 +719,7 @@ impl<T> Vec<T> {\n             let size = capacity.checked_mul(&mem::size_of::<T>())\n                                .expect(\"capacity overflow\");\n             unsafe {\n-                self.ptr = alloc_or_realloc(self.ptr, size,\n-                                            self.cap * mem::size_of::<T>());\n+                self.ptr = alloc_or_realloc(self.ptr, self.cap * mem::size_of::<T>(), size);\n             }\n             self.cap = capacity;\n         }\n@@ -751,9 +749,9 @@ impl<T> Vec<T> {\n                 // Overflow check is unnecessary as the vector is already at\n                 // least this large.\n                 self.ptr = reallocate(self.ptr as *mut u8,\n+                                      self.cap * mem::size_of::<T>(),\n                                       self.len * mem::size_of::<T>(),\n-                                      mem::min_align_of::<T>(),\n-                                      self.cap * mem::size_of::<T>()) as *mut T;\n+                                      mem::min_align_of::<T>()) as *mut T;\n             }\n             self.cap = self.len;\n         }\n@@ -1736,8 +1734,7 @@ impl<T> MutableSeq<T> for Vec<T> {\n             let size = max(old_size, 2 * mem::size_of::<T>()) * 2;\n             if old_size > size { fail!(\"capacity overflow\") }\n             unsafe {\n-                self.ptr = alloc_or_realloc(self.ptr, size,\n-                                            self.cap * mem::size_of::<T>());\n+                self.ptr = alloc_or_realloc(self.ptr, self.cap * mem::size_of::<T>(), size);\n             }\n             self.cap = max(self.cap, 2) * 2;\n         }"}, {"sha": "d8f48c7e6623bb4dfb5150b4504c19b36f3a9c43", "filename": "src/test/run-pass/realloc-16687.rs", "status": "modified", "additions": 14, "deletions": 15, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/e6cfb56a5cee28b08ae9d2dcbb2552497ce922c1/src%2Ftest%2Frun-pass%2Frealloc-16687.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e6cfb56a5cee28b08ae9d2dcbb2552497ce922c1/src%2Ftest%2Frun-pass%2Frealloc-16687.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Frealloc-16687.rs?ref=e6cfb56a5cee28b08ae9d2dcbb2552497ce922c1", "patch": "@@ -63,19 +63,18 @@ unsafe fn test_triangle() -> bool {\n \n         heap::deallocate(ptr, size, align);\n     }\n-    unsafe fn reallocate(ptr: *mut u8, size: uint, align: uint,\n-                             old_size: uint) -> *mut u8 {\n+    unsafe fn reallocate(ptr: *mut u8, old_size: uint, size: uint, align: uint) -> *mut u8 {\n         if PRINT {\n-            println!(\"reallocate(ptr=0x{:010x} size={:u} align={:u} old_size={:u})\",\n-                     ptr as uint, size, align, old_size);\n+            println!(\"reallocate(ptr=0x{:010x} old_size={:u} size={:u} align={:u})\",\n+                     ptr as uint, old_size, size, align);\n         }\n \n-        let ret = heap::reallocate(ptr, size, align, old_size);\n+        let ret = heap::reallocate(ptr, old_size, size, align);\n \n         if PRINT {\n-            println!(\"reallocate(ptr=0x{:010x} size={:u} align={:u} old_size={:u}) \\\n+            println!(\"reallocate(ptr=0x{:010x} old_size={:u} size={:u} align={:u}) \\\n                       ret: 0x{:010x}\",\n-                     ptr as uint, size, align, old_size, ret as uint);\n+                     ptr as uint, old_size, size, align, ret as uint);\n         }\n         ret\n     }\n@@ -125,10 +124,10 @@ unsafe fn test_triangle() -> bool {\n             let (p0, p1, old_size) = (ascend[2*i], ascend[2*i+1], idx_to_size(i));\n             assert!(old_size < new_size);\n \n-            ascend[2*i] = reallocate(p0, new_size, ALIGN, old_size);\n+            ascend[2*i] = reallocate(p0, old_size, new_size, ALIGN);\n             sanity_check(ascend.as_slice());\n \n-            ascend[2*i+1] = reallocate(p1, new_size, ALIGN, old_size);\n+            ascend[2*i+1] = reallocate(p1, old_size, new_size, ALIGN);\n             sanity_check(ascend.as_slice());\n         }\n     }\n@@ -140,10 +139,10 @@ unsafe fn test_triangle() -> bool {\n             let (p0, p1, new_size) = (ascend[2*i], ascend[2*i+1], idx_to_size(i));\n             assert!(new_size < old_size);\n \n-            ascend[2*i] = reallocate(p0, new_size, ALIGN, old_size);\n+            ascend[2*i] = reallocate(p0, old_size, new_size, ALIGN);\n             sanity_check(ascend.as_slice());\n \n-            ascend[2*i+1] = reallocate(p1, new_size, ALIGN, old_size);\n+            ascend[2*i+1] = reallocate(p1, old_size, new_size, ALIGN);\n             sanity_check(ascend.as_slice());\n         }\n     }\n@@ -155,10 +154,10 @@ unsafe fn test_triangle() -> bool {\n             let (p0, p1, old_size) = (ascend[2*i], ascend[2*i+1], idx_to_size(i));\n             assert!(old_size < new_size);\n \n-            ascend[2*i+1] = reallocate(p1, new_size, ALIGN, old_size);\n+            ascend[2*i+1] = reallocate(p1, old_size, new_size, ALIGN);\n             sanity_check(ascend.as_slice());\n \n-            ascend[2*i] = reallocate(p0, new_size, ALIGN, old_size);\n+            ascend[2*i] = reallocate(p0, old_size, new_size, ALIGN);\n             sanity_check(ascend.as_slice());\n         }\n     }\n@@ -170,10 +169,10 @@ unsafe fn test_triangle() -> bool {\n             let (p0, p1, new_size) = (ascend[2*i], ascend[2*i+1], idx_to_size(i));\n             assert!(new_size < old_size);\n \n-            ascend[2*i+1] = reallocate(p1, new_size, ALIGN, old_size);\n+            ascend[2*i+1] = reallocate(p1, old_size, new_size, ALIGN);\n             sanity_check(ascend.as_slice());\n \n-            ascend[2*i] = reallocate(p0, new_size, ALIGN, old_size);\n+            ascend[2*i] = reallocate(p0, old_size, new_size, ALIGN);\n             sanity_check(ascend.as_slice());\n         }\n     }"}]}