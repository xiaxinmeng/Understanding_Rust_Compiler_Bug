{"sha": "4b18fff2be74df9a2db5ee6ab418da322ad6ae18", "node_id": "MDY6Q29tbWl0NzI0NzEyOjRiMThmZmYyYmU3NGRmOWEyZGI1ZWU2YWI0MThkYTMyMmFkNmFlMTg=", "commit": {"author": {"name": "Huon Wilson", "email": "dbau.pp+github@gmail.com", "date": "2013-06-13T15:39:06Z"}, "committer": {"name": "Huon Wilson", "email": "dbau.pp+github@gmail.com", "date": "2013-06-16T00:50:28Z"}, "message": "std: convert str::{map,levdistance,subslice_offset} to methods.\n\nThe first two become map_chars and lev_distance. Also, remove a few\nallocations in rustdoc.", "tree": {"sha": "80a7b5caf2c7b2d1f6dc455fb725f4138f008f57", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/80a7b5caf2c7b2d1f6dc455fb725f4138f008f57"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4b18fff2be74df9a2db5ee6ab418da322ad6ae18", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4b18fff2be74df9a2db5ee6ab418da322ad6ae18", "html_url": "https://github.com/rust-lang/rust/commit/4b18fff2be74df9a2db5ee6ab418da322ad6ae18", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4b18fff2be74df9a2db5ee6ab418da322ad6ae18/comments", "author": {"login": "huonw", "id": 1203825, "node_id": "MDQ6VXNlcjEyMDM4MjU=", "avatar_url": "https://avatars.githubusercontent.com/u/1203825?v=4", "gravatar_id": "", "url": "https://api.github.com/users/huonw", "html_url": "https://github.com/huonw", "followers_url": "https://api.github.com/users/huonw/followers", "following_url": "https://api.github.com/users/huonw/following{/other_user}", "gists_url": "https://api.github.com/users/huonw/gists{/gist_id}", "starred_url": "https://api.github.com/users/huonw/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/huonw/subscriptions", "organizations_url": "https://api.github.com/users/huonw/orgs", "repos_url": "https://api.github.com/users/huonw/repos", "events_url": "https://api.github.com/users/huonw/events{/privacy}", "received_events_url": "https://api.github.com/users/huonw/received_events", "type": "User", "site_admin": false}, "committer": {"login": "huonw", "id": 1203825, "node_id": "MDQ6VXNlcjEyMDM4MjU=", "avatar_url": "https://avatars.githubusercontent.com/u/1203825?v=4", "gravatar_id": "", "url": "https://api.github.com/users/huonw", "html_url": "https://github.com/huonw", "followers_url": "https://api.github.com/users/huonw/followers", "following_url": "https://api.github.com/users/huonw/following{/other_user}", "gists_url": "https://api.github.com/users/huonw/gists{/gist_id}", "starred_url": "https://api.github.com/users/huonw/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/huonw/subscriptions", "organizations_url": "https://api.github.com/users/huonw/orgs", "repos_url": "https://api.github.com/users/huonw/repos", "events_url": "https://api.github.com/users/huonw/events{/privacy}", "received_events_url": "https://api.github.com/users/huonw/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c989b79127c5062df0a64d8c383de93c82a3d9b7", "url": "https://api.github.com/repos/rust-lang/rust/commits/c989b79127c5062df0a64d8c383de93c82a3d9b7", "html_url": "https://github.com/rust-lang/rust/commit/c989b79127c5062df0a64d8c383de93c82a3d9b7"}], "stats": {"total": 303, "additions": 148, "deletions": 155}, "files": [{"sha": "3e656b3e5940509cb7ff8be7b785101bef842afd", "filename": "src/librustc/middle/resolve.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4b18fff2be74df9a2db5ee6ab418da322ad6ae18/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b18fff2be74df9a2db5ee6ab418da322ad6ae18/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve.rs?ref=4b18fff2be74df9a2db5ee6ab418da322ad6ae18", "patch": "@@ -4845,7 +4845,7 @@ impl Resolver {\n         let mut smallest = 0;\n         for maybes.eachi |i, &other| {\n \n-            values[i] = str::levdistance(name, other);\n+            values[i] = name.lev_distance(other);\n \n             if values[i] <= values[smallest] {\n                 smallest = i;"}, {"sha": "d6cae1f2fa3f56378d790c7a1df0a4a25f2863db", "filename": "src/librustdoc/desc_to_brief_pass.rs", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/4b18fff2be74df9a2db5ee6ab418da322ad6ae18/src%2Flibrustdoc%2Fdesc_to_brief_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b18fff2be74df9a2db5ee6ab418da322ad6ae18/src%2Flibrustdoc%2Fdesc_to_brief_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fdesc_to_brief_pass.rs?ref=4b18fff2be74df9a2db5ee6ab418da322ad6ae18", "patch": "@@ -143,11 +143,9 @@ fn first_sentence_(s: &str) -> ~str {\n }\n \n pub fn paragraphs(s: &str) -> ~[~str] {\n-    let mut lines = ~[];\n-    for str::each_line_any(s) |line| { lines.push(line.to_owned()); }\n     let mut whitespace_lines = 0;\n     let mut accum = ~\"\";\n-    let paras = do lines.iter().fold(~[]) |paras, line| {\n+    let paras = do s.any_line_iter().fold(~[]) |paras, line| {\n         let mut res = paras;\n \n         if line.is_whitespace() {\n@@ -163,9 +161,9 @@ pub fn paragraphs(s: &str) -> ~[~str] {\n             whitespace_lines = 0;\n \n             accum = if accum.is_empty() {\n-                copy *line\n+                line.to_owned()\n             } else {\n-                accum + \"\\n\" + *line\n+                fmt!(\"%s\\n%s\", accum, line)\n             }\n         }\n "}, {"sha": "2e020cd9e5ada4961bfd834ff0161249a42a3d4d", "filename": "src/librustdoc/markdown_pass.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/4b18fff2be74df9a2db5ee6ab418da322ad6ae18/src%2Flibrustdoc%2Fmarkdown_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b18fff2be74df9a2db5ee6ab418da322ad6ae18/src%2Flibrustdoc%2Fmarkdown_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fmarkdown_pass.rs?ref=4b18fff2be74df9a2db5ee6ab418da322ad6ae18", "patch": "@@ -22,6 +22,7 @@ use markdown_writer::WriterFactory;\n use pass::Pass;\n use sort_pass;\n \n+use core::iterator::IteratorUtil;\n use core::cell::Cell;\n use core::str;\n use core::vec;\n@@ -466,10 +467,7 @@ fn write_variant(ctxt: &Ctxt, doc: doc::VariantDoc) {\n }\n \n fn list_item_indent(item: &str) -> ~str {\n-    let mut indented = ~[];\n-    for str::each_line_any(item) |line| {\n-        indented.push(line);\n-    }\n+    let indented = item.any_line_iter().collect::<~[&str]>();\n \n     // separate markdown elements within `*` lists must be indented by four\n     // spaces, or they will escape the list context. indenting everything"}, {"sha": "c44be7f597ed32117467050a1dc1e7088bfe00fb", "filename": "src/librustdoc/sectionalize_pass.rs", "status": "modified", "additions": 11, "deletions": 13, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/4b18fff2be74df9a2db5ee6ab418da322ad6ae18/src%2Flibrustdoc%2Fsectionalize_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b18fff2be74df9a2db5ee6ab418da322ad6ae18/src%2Flibrustdoc%2Fsectionalize_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fsectionalize_pass.rs?ref=4b18fff2be74df9a2db5ee6ab418da322ad6ae18", "patch": "@@ -19,7 +19,7 @@ use fold::Fold;\n use fold;\n use pass::Pass;\n \n-use core::str;\n+use core::iterator::IteratorUtil;\n \n pub fn mk_pass() -> Pass {\n     Pass {\n@@ -104,39 +104,37 @@ fn sectionalize(desc: Option<~str>) -> (Option<~str>, ~[doc::Section]) {\n     if desc.is_none() {\n         return (None, ~[]);\n     }\n-    let mut lines = ~[];\n-    for str::each_line_any(*desc.get_ref()) |line| { lines.push(line.to_owned()); }\n \n     let mut new_desc = None::<~str>;\n     let mut current_section = None;\n     let mut sections = ~[];\n \n-    for lines.each |line| {\n-        match parse_header(copy *line) {\n+    for desc.get_ref().any_line_iter().advance |line| {\n+        match parse_header(line) {\n           Some(header) => {\n             if current_section.is_some() {\n-                sections += [copy *current_section.get_ref()];\n+                sections.push(copy *current_section.get_ref());\n             }\n             current_section = Some(doc::Section {\n-                header: header,\n+                header: header.to_owned(),\n                 body: ~\"\"\n             });\n           }\n           None => {\n             match copy current_section {\n               Some(section) => {\n                 current_section = Some(doc::Section {\n-                    body: section.body + \"\\n\" + *line,\n+                    body: fmt!(\"%s\\n%s\", section.body, line),\n                     .. section\n                 });\n               }\n               None => {\n                 new_desc = match copy new_desc {\n                   Some(desc) => {\n-                    Some(desc + \"\\n\" + *line)\n+                    Some(fmt!(\"%s\\n%s\", desc, line))\n                   }\n                   None => {\n-                    Some(copy *line)\n+                    Some(line.to_owned())\n                   }\n                 };\n               }\n@@ -146,15 +144,15 @@ fn sectionalize(desc: Option<~str>) -> (Option<~str>, ~[doc::Section]) {\n     }\n \n     if current_section.is_some() {\n-        sections += [current_section.get()];\n+        sections.push(current_section.unwrap());\n     }\n \n     (new_desc, sections)\n }\n \n-fn parse_header(line: ~str) -> Option<~str> {\n+fn parse_header<'a>(line: &'a str) -> Option<&'a str> {\n     if line.starts_with(\"# \") {\n-        Some(line.slice(2u, line.len()).to_owned())\n+        Some(line.slice_from(2))\n     } else {\n         None\n     }"}, {"sha": "2bcf04c0262e0b4f6a0f49a7c9599f8f7f22bbbc", "filename": "src/librustdoc/unindent_pass.rs", "status": "modified", "additions": 15, "deletions": 16, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/4b18fff2be74df9a2db5ee6ab418da322ad6ae18/src%2Flibrustdoc%2Funindent_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b18fff2be74df9a2db5ee6ab418da322ad6ae18/src%2Flibrustdoc%2Funindent_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Funindent_pass.rs?ref=4b18fff2be74df9a2db5ee6ab418da322ad6ae18", "patch": "@@ -21,7 +21,6 @@ middle of a line, and each of the following lines is indented.\n \n use core::prelude::*;\n \n-use core::str;\n use core::uint;\n use pass::Pass;\n use text_pass;\n@@ -31,8 +30,7 @@ pub fn mk_pass() -> Pass {\n }\n \n fn unindent(s: &str) -> ~str {\n-    let mut lines = ~[];\n-    for str::each_line_any(s) |line| { lines.push(line.to_owned()); }\n+    let lines = s.any_line_iter().collect::<~[&str]>();\n     let mut saw_first_line = false;\n     let mut saw_second_line = false;\n     let min_indent = do lines.iter().fold(uint::max_value)\n@@ -76,19 +74,20 @@ fn unindent(s: &str) -> ~str {\n         }\n     };\n \n-    if !lines.is_empty() {\n-        let unindented = ~[lines.head().trim().to_owned()]\n-            + do lines.tail().map |line| {\n-            if line.is_whitespace() {\n-                copy *line\n-            } else {\n-                assert!(line.len() >= min_indent);\n-                line.slice(min_indent, line.len()).to_owned()\n-            }\n-        };\n-        unindented.connect(\"\\n\")\n-    } else {\n-        s.to_str()\n+    match lines {\n+        [head, .. tail] => {\n+            let mut unindented = ~[ head.trim() ];\n+            unindented.push_all(do tail.map |&line| {\n+                if line.is_whitespace() {\n+                    line\n+                } else {\n+                    assert!(line.len() >= min_indent);\n+                    line.slice_from(min_indent)\n+                }\n+            });\n+            unindented.connect(\"\\n\")\n+        }\n+        [] => s.to_owned()\n     }\n }\n "}, {"sha": "fbdbb1b3f74b559387a5621916248a59e2901fb1", "filename": "src/libstd/str.rs", "status": "modified", "additions": 110, "deletions": 108, "changes": 218, "blob_url": "https://github.com/rust-lang/rust/blob/4b18fff2be74df9a2db5ee6ab418da322ad6ae18/src%2Flibstd%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b18fff2be74df9a2db5ee6ab418da322ad6ae18/src%2Flibstd%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fstr.rs?ref=4b18fff2be74df9a2db5ee6ab418da322ad6ae18", "patch": "@@ -26,7 +26,7 @@ use clone::Clone;\n use cmp::{TotalOrd, Ordering, Less, Equal, Greater};\n use container::Container;\n use iter::Times;\n-use iterator::{Iterator, IteratorUtil, FilterIterator, AdditiveIterator};\n+use iterator::{Iterator, IteratorUtil, FilterIterator, AdditiveIterator, MapIterator};\n use libc;\n use option::{None, Option, Some};\n use old_iter::{BaseIter, EqIter};\n@@ -291,6 +291,10 @@ pub type WordIterator<'self> =\n     FilterIterator<'self, &'self str,\n              StrCharSplitIterator<'self, extern \"Rust\" fn(char) -> bool>>;\n \n+/// An iterator over the lines of a string, separated by either `\\n` or (`\\r\\n`).\n+pub type AnyLineIterator<'self> =\n+    MapIterator<'self, &'self str, &'self str, StrCharSplitIterator<'self, char>>;\n+\n impl<'self, Sep: CharEq> Iterator<&'self str> for StrCharSplitIterator<'self, Sep> {\n     #[inline]\n     fn next(&mut self) -> Option<&'self str> {\n@@ -400,56 +404,6 @@ impl<'self> Iterator<&'self str> for StrStrSplitIterator<'self> {\n     }\n }\n \n-/// Levenshtein Distance between two strings\n-pub fn levdistance(s: &str, t: &str) -> uint {\n-\n-    let slen = s.len();\n-    let tlen = t.len();\n-\n-    if slen == 0 { return tlen; }\n-    if tlen == 0 { return slen; }\n-\n-    let mut dcol = vec::from_fn(tlen + 1, |x| x);\n-\n-    for s.iter().enumerate().advance |(i, sc)| {\n-\n-        let mut current = i;\n-        dcol[0] = current + 1;\n-\n-        for t.iter().enumerate().advance |(j, tc)| {\n-\n-            let next = dcol[j + 1];\n-\n-            if sc == tc {\n-                dcol[j + 1] = current;\n-            } else {\n-                dcol[j + 1] = ::cmp::min(current, next);\n-                dcol[j + 1] = ::cmp::min(dcol[j + 1], dcol[j]) + 1;\n-            }\n-\n-            current = next;\n-        }\n-    }\n-\n-    return dcol[tlen];\n-}\n-\n-/**\n- * Splits a string into substrings separated by LF ('\\n')\n- * and/or CR LF (\"\\r\\n\")\n- */\n-pub fn each_line_any<'a>(s: &'a str, it: &fn(&'a str) -> bool) -> bool {\n-    for s.line_iter().advance |s| {\n-        let l = s.len();\n-        if l > 0u && s[l - 1u] == '\\r' as u8 {\n-            if !it( unsafe { raw::slice_bytes(s, 0, l - 1) } ) { return false; }\n-        } else {\n-            if !it( s ) { return false; }\n-        }\n-    }\n-    return true;\n-}\n-\n /** Splits a string into substrings with possibly internal whitespace,\n  *  each of them at most `lim` bytes long. The substrings have leading and trailing\n  *  whitespace removed, and are only cut at whitespace boundaries.\n@@ -751,21 +705,6 @@ impl<'self, S: Str> Equiv<S> for ~str {\n     fn equiv(&self, other: &S) -> bool { eq_slice(*self, other.as_slice()) }\n }\n \n-\n-/*\n-Section: Iterating through strings\n-*/\n-\n-/// Apply a function to each character\n-pub fn map(ss: &str, ff: &fn(char) -> char) -> ~str {\n-    let mut result = ~\"\";\n-    result.reserve(ss.len());\n-    for ss.iter().advance |cc| {\n-        result.push_char(ff(cc));\n-    }\n-    result\n-}\n-\n /*\n Section: Searching\n */\n@@ -989,40 +928,6 @@ pub fn as_buf<T>(s: &str, f: &fn(*u8, uint) -> T) -> T {\n     }\n }\n \n-/**\n- * Returns the byte offset of an inner slice relative to an enclosing outer slice\n- *\n- * # Example\n- *\n- * ~~~ {.rust}\n- * let string = \"a\\nb\\nc\";\n- * let mut lines = ~[];\n- * for string.line_iter().advance |line| { lines.push(line) }\n- *\n- * assert!(subslice_offset(string, lines[0]) == 0); // &\"a\"\n- * assert!(subslice_offset(string, lines[1]) == 2); // &\"b\"\n- * assert!(subslice_offset(string, lines[2]) == 4); // &\"c\"\n- * ~~~\n- */\n-#[inline(always)]\n-pub fn subslice_offset(outer: &str, inner: &str) -> uint {\n-    do as_buf(outer) |a, a_len| {\n-        do as_buf(inner) |b, b_len| {\n-            let a_start: uint;\n-            let a_end: uint;\n-            let b_start: uint;\n-            let b_end: uint;\n-            unsafe {\n-                a_start = cast::transmute(a); a_end = a_len + cast::transmute(a);\n-                b_start = cast::transmute(b); b_end = b_len + cast::transmute(b);\n-            }\n-            assert!(a_start <= b_start);\n-            assert!(b_end <= a_end);\n-            b_start - a_start\n-        }\n-    }\n-}\n-\n /// Unsafe operations\n pub mod raw {\n     use cast;\n@@ -1256,6 +1161,7 @@ pub trait StrSlice<'self> {\n     fn matches_index_iter(&self, sep: &'self str) -> StrMatchesIndexIterator<'self>;\n     fn split_str_iter(&self, &'self str) -> StrStrSplitIterator<'self>;\n     fn line_iter(&self) -> StrCharSplitIterator<'self, char>;\n+    fn any_line_iter(&self) -> AnyLineIterator<'self>;\n     fn word_iter(&self) -> WordIterator<'self>;\n     fn ends_with(&self, needle: &str) -> bool;\n     fn is_empty(&self) -> bool;\n@@ -1296,6 +1202,12 @@ pub trait StrSlice<'self> {\n     fn repeat(&self, nn: uint) -> ~str;\n \n     fn slice_shift_char(&self) -> (char, &'self str);\n+\n+    fn map_chars(&self, ff: &fn(char) -> char) -> ~str;\n+\n+    fn lev_distance(&self, t: &str) -> uint;\n+\n+    fn subslice_offset(&self, inner: &str) -> uint;\n }\n \n /// Extension methods for strings\n@@ -1437,6 +1349,17 @@ impl<'self> StrSlice<'self> for &'self str {\n     fn line_iter(&self) -> StrCharSplitIterator<'self, char> {\n         self.split_options_iter('\\n', self.len(), false)\n     }\n+\n+    /// An iterator over the lines of a string, separated by either\n+    /// `\\n` or (`\\r\\n`).\n+    fn any_line_iter(&self) -> AnyLineIterator<'self> {\n+        do self.line_iter().transform |line| {\n+            let l = line.len();\n+            if l > 0 && line[l - 1] == '\\r' as u8 { line.slice(0, l - 1) }\n+            else { line }\n+        }\n+    }\n+\n     /// An iterator over the words of a string (subsequences separated\n     /// by any sequence of whitespace).\n     #[inline]\n@@ -1921,6 +1844,85 @@ impl<'self> StrSlice<'self> for &'self str {\n     }\n \n \n+    /// Apply a function to each character.\n+    fn map_chars(&self, ff: &fn(char) -> char) -> ~str {\n+        let mut result = with_capacity(self.len());\n+        for self.iter().advance |cc| {\n+            result.push_char(ff(cc));\n+        }\n+        result\n+    }\n+\n+    /// Levenshtein Distance between two strings.\n+    fn lev_distance(&self, t: &str) -> uint {\n+        let slen = self.len();\n+        let tlen = t.len();\n+\n+        if slen == 0 { return tlen; }\n+        if tlen == 0 { return slen; }\n+\n+        let mut dcol = vec::from_fn(tlen + 1, |x| x);\n+\n+        for self.iter().enumerate().advance |(i, sc)| {\n+\n+            let mut current = i;\n+            dcol[0] = current + 1;\n+\n+            for t.iter().enumerate().advance |(j, tc)| {\n+\n+                let next = dcol[j + 1];\n+\n+                if sc == tc {\n+                    dcol[j + 1] = current;\n+                } else {\n+                    dcol[j + 1] = ::cmp::min(current, next);\n+                    dcol[j + 1] = ::cmp::min(dcol[j + 1], dcol[j]) + 1;\n+                }\n+\n+                current = next;\n+            }\n+        }\n+\n+        return dcol[tlen];\n+    }\n+\n+\n+    /**\n+     * Returns the byte offset of an inner slice relative to an enclosing outer slice.\n+     *\n+     * Fails if `inner` is not a direct slice contained within self.\n+     *\n+     * # Example\n+     *\n+     * ~~~ {.rust}\n+     * let string = \"a\\nb\\nc\";\n+     * let mut lines = ~[];\n+     * for string.line_iter().advance |line| { lines.push(line) }\n+     *\n+     * assert!(string.subslice_offset(lines[0]) == 0); // &\"a\"\n+     * assert!(string.subslice_offset(lines[1]) == 2); // &\"b\"\n+     * assert!(string.subslice_offset(lines[2]) == 4); // &\"c\"\n+     * ~~~\n+     */\n+    #[inline(always)]\n+    fn subslice_offset(&self, inner: &str) -> uint {\n+        do as_buf(*self) |a, a_len| {\n+            do as_buf(inner) |b, b_len| {\n+                let a_start: uint;\n+                let a_end: uint;\n+                let b_start: uint;\n+                let b_end: uint;\n+                unsafe {\n+                    a_start = cast::transmute(a); a_end = a_len + cast::transmute(a);\n+                    b_start = cast::transmute(b); b_end = b_len + cast::transmute(b);\n+                }\n+                assert!(a_start <= b_start);\n+                assert!(b_end <= a_end);\n+                b_start - a_start\n+            }\n+        }\n+    }\n+\n }\n \n #[allow(missing_doc)]\n@@ -3003,23 +3005,23 @@ mod tests {\n         let a = \"kernelsprite\";\n         let b = a.slice(7, a.len());\n         let c = a.slice(0, a.len() - 6);\n-        assert_eq!(subslice_offset(a, b), 7);\n-        assert_eq!(subslice_offset(a, c), 0);\n+        assert_eq!(a.subslice_offset(b), 7);\n+        assert_eq!(a.subslice_offset(c), 0);\n \n         let string = \"a\\nb\\nc\";\n         let mut lines = ~[];\n         for string.line_iter().advance |line| { lines.push(line) }\n-        assert_eq!(subslice_offset(string, lines[0]), 0);\n-        assert_eq!(subslice_offset(string, lines[1]), 2);\n-        assert_eq!(subslice_offset(string, lines[2]), 4);\n+        assert_eq!(string.subslice_offset(lines[0]), 0);\n+        assert_eq!(string.subslice_offset(lines[1]), 2);\n+        assert_eq!(string.subslice_offset(lines[2]), 4);\n     }\n \n     #[test]\n     #[should_fail]\n     fn test_subslice_offset_2() {\n         let a = \"alchemiter\";\n         let b = \"cruxtruder\";\n-        subslice_offset(a, b);\n+        a.subslice_offset(b);\n     }\n \n     #[test]\n@@ -3069,8 +3071,8 @@ mod tests {\n \n     #[test]\n     fn test_map() {\n-        assert_eq!(~\"\", map(\"\", |c| unsafe {libc::toupper(c as c_char)} as char));\n-        assert_eq!(~\"YMCA\", map(\"ymca\", |c| unsafe {libc::toupper(c as c_char)} as char));\n+        assert_eq!(~\"\", \"\".map_chars(|c| unsafe {libc::toupper(c as c_char)} as char));\n+        assert_eq!(~\"YMCA\", \"ymca\".map_chars(|c| unsafe {libc::toupper(c as c_char)} as char));\n     }\n \n     #[test]"}, {"sha": "82a7b55eeeec099b004ddeabce86c6cd2b8eebb8", "filename": "src/libsyntax/parse/comments.rs", "status": "modified", "additions": 6, "deletions": 8, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/4b18fff2be74df9a2db5ee6ab418da322ad6ae18/src%2Flibsyntax%2Fparse%2Fcomments.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b18fff2be74df9a2db5ee6ab418da322ad6ae18/src%2Flibsyntax%2Fparse%2Fcomments.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fcomments.rs?ref=4b18fff2be74df9a2db5ee6ab418da322ad6ae18", "patch": "@@ -89,12 +89,11 @@ pub fn strip_doc_comment_decoration(comment: &str) -> ~str {\n         }\n \n         return do lines.map |line| {\n-            let mut chars = ~[];\n-            for line.iter().advance |c| { chars.push(c) }\n+            let chars = line.iter().collect::<~[char]>();\n             if i > chars.len() {\n                 ~\"\"\n             } else {\n-                str::from_chars(chars.slice(i, chars.len()).to_owned())\n+                str::from_chars(chars.slice(i, chars.len()))\n             }\n         };\n     }\n@@ -103,14 +102,13 @@ pub fn strip_doc_comment_decoration(comment: &str) -> ~str {\n         // FIXME #5475:\n         // return comment.slice(3u, comment.len()).trim().to_owned();\n         let r = comment.slice(3u, comment.len()); return r.trim().to_owned();\n-\n     }\n \n     if comment.starts_with(\"/*\") {\n-        let mut lines = ~[];\n-        for str::each_line_any(comment.slice(3u, comment.len() - 2u)) |line| {\n-            lines.push(line.to_owned())\n-        }\n+        let lines = comment.slice(3u, comment.len() - 2u)\n+            .any_line_iter()\n+            .transform(|s| s.to_owned())\n+            .collect::<~[~str]>();\n         let lines = vertical_trim(lines);\n         let lines = block_trim(lines, ~\"\\t \", None);\n         let lines = block_trim(lines, ~\"*\", Some(1u));"}]}