{"sha": "0d531bfb881e6d303d09de9f212eaac72a9a218d", "node_id": "MDY6Q29tbWl0NzI0NzEyOjBkNTMxYmZiODgxZTZkMzAzZDA5ZGU5ZjIxMmVhYWM3MmE5YTIxOGQ=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2016-06-08T20:51:57Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2016-06-08T20:51:57Z"}, "message": "Auto merge of #33989 - eddyb:mir-viz, r=nikomatsakis\n\n[MIR] Make scopes debuginfo-specific (visibility scopes).\n\nFixes #32949 by having MIR (visibility) scopes mimic the lexical structure.\nUnlike #33235, this PR also removes all scopes without variable bindings.\n\nPrinting of scopes also changed, e.g. for:\n```rust\nfn foo(x: i32, y: i32) { let a = 0; let b = 0; let c = 0; }\n```\nBefore my changes:\n```rust\nfn foo(arg0: i32, arg1: i32) -> () {\n    let var0: i32;                       // \"x\" in scope 1 at <anon>:1:8: 1:9\n    let var1: i32;                       // \"y\" in scope 1 at <anon>:1:16: 1:17\n    let var2: i32;                       // \"a\" in scope 3 at <anon>:1:30: 1:31\n    let var3: i32;                       // \"b\" in scope 6 at <anon>:1:41: 1:42\n    let var4: i32;                       // \"c\" in scope 9 at <anon>:1:52: 1:53\n\n    ...\n\n    scope tree:\n    0 1 2 3 {\n        4 5\n        6 {\n            7 8\n            9 10 11\n        }\n    }\n}\n```\nAfter my changes:\n```rust\nfn foo(arg0: i32, arg1: i32) -> () {\n    scope 1 {\n        let var0: i32;                   // \"x\" in scope 1 at <anon>:1:8: 1:9\n        let var1: i32;                   // \"y\" in scope 1 at <anon>:1:16: 1:17\n        scope 2 {\n            let var2: i32;               // \"a\" in scope 2 at <anon>:1:30: 1:31\n            scope 3 {\n                let var3: i32;           // \"b\" in scope 3 at <anon>:1:41: 1:42\n                scope 4 {\n                    let var4: i32;       // \"c\" in scope 4 at <anon>:1:52: 1:53\n                }\n            }\n        }\n    }\n\n    ...\n}", "tree": {"sha": "1568111b5de55c3d3b744370dc55d2c4c2afd917", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1568111b5de55c3d3b744370dc55d2c4c2afd917"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0d531bfb881e6d303d09de9f212eaac72a9a218d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0d531bfb881e6d303d09de9f212eaac72a9a218d", "html_url": "https://github.com/rust-lang/rust/commit/0d531bfb881e6d303d09de9f212eaac72a9a218d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0d531bfb881e6d303d09de9f212eaac72a9a218d/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4b240fe96a8b8fcaa412624c398547dbc447a81e", "url": "https://api.github.com/repos/rust-lang/rust/commits/4b240fe96a8b8fcaa412624c398547dbc447a81e", "html_url": "https://github.com/rust-lang/rust/commit/4b240fe96a8b8fcaa412624c398547dbc447a81e"}, {"sha": "0c5930ef256131f8d0e4f020a5029a89944cf250", "url": "https://api.github.com/repos/rust-lang/rust/commits/0c5930ef256131f8d0e4f020a5029a89944cf250", "html_url": "https://github.com/rust-lang/rust/commit/0c5930ef256131f8d0e4f020a5029a89944cf250"}], "stats": {"total": 971, "additions": 478, "deletions": 493}, "files": [{"sha": "e6c22d0ea3446076fe097d915197d34694068bac", "filename": "src/librustc/mir/repr.rs", "status": "modified", "additions": 33, "deletions": 23, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/0d531bfb881e6d303d09de9f212eaac72a9a218d/src%2Flibrustc%2Fmir%2Frepr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d531bfb881e6d303d09de9f212eaac72a9a218d/src%2Flibrustc%2Fmir%2Frepr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Frepr.rs?ref=0d531bfb881e6d303d09de9f212eaac72a9a218d", "patch": "@@ -32,9 +32,9 @@ pub struct Mir<'tcx> {\n     /// that indexes into this vector.\n     pub basic_blocks: Vec<BasicBlockData<'tcx>>,\n \n-    /// List of lexical scopes; these are referenced by statements and\n-    /// used (eventually) for debuginfo. Indexed by a `ScopeId`.\n-    pub scopes: Vec<ScopeData>,\n+    /// List of visibility (lexical) scopes; these are referenced by statements\n+    /// and used (eventually) for debuginfo. Indexed by a `VisibilityScope`.\n+    pub visibility_scopes: Vec<VisibilityScopeData>,\n \n     /// Rvalues promoted from this function, such as borrows of constants.\n     /// Each of them is the Mir of a constant with the fn's type parameters\n@@ -100,6 +100,18 @@ impl<'tcx> IndexMut<BasicBlock> for Mir<'tcx> {\n     }\n }\n \n+/// Grouped information about the source code origin of a MIR entity.\n+/// Intended to be inspected by diagnostics and debuginfo.\n+/// Most passes can work with it as a whole, within a single function.\n+#[derive(Copy, Clone, Debug, PartialEq, Eq, RustcEncodable, RustcDecodable)]\n+pub struct SourceInfo {\n+    /// Source span for the AST pertaining to this MIR entity.\n+    pub span: Span,\n+\n+    /// The lexical visibility scope, i.e. which bindings can be seen.\n+    pub scope: VisibilityScope\n+}\n+\n ///////////////////////////////////////////////////////////////////////////\n // Mutability and borrow kinds\n \n@@ -172,11 +184,8 @@ pub struct VarDecl<'tcx> {\n     /// type inferred for this variable (`let x: ty = ...`)\n     pub ty: Ty<'tcx>,\n \n-    /// scope in which variable was declared\n-    pub scope: ScopeId,\n-\n-    /// span where variable was declared\n-    pub span: Span,\n+    /// source information (span, scope, etc.) for the declaration\n+    pub source_info: SourceInfo,\n }\n \n /// A \"temp\" is a temporary that we place on the stack. They are\n@@ -275,8 +284,7 @@ pub struct BasicBlockData<'tcx> {\n \n #[derive(Clone, Debug, RustcEncodable, RustcDecodable)]\n pub struct Terminator<'tcx> {\n-    pub span: Span,\n-    pub scope: ScopeId,\n+    pub source_info: SourceInfo,\n     pub kind: TerminatorKind<'tcx>\n }\n \n@@ -587,8 +595,7 @@ pub enum AssertMessage<'tcx> {\n \n #[derive(Clone, RustcEncodable, RustcDecodable)]\n pub struct Statement<'tcx> {\n-    pub span: Span,\n-    pub scope: ScopeId,\n+    pub source_info: SourceInfo,\n     pub kind: StatementKind<'tcx>,\n }\n \n@@ -754,29 +761,32 @@ impl<'tcx> Debug for Lvalue<'tcx> {\n ///////////////////////////////////////////////////////////////////////////\n // Scopes\n \n-impl Index<ScopeId> for Vec<ScopeData> {\n-    type Output = ScopeData;\n+impl Index<VisibilityScope> for Vec<VisibilityScopeData> {\n+    type Output = VisibilityScopeData;\n \n     #[inline]\n-    fn index(&self, index: ScopeId) -> &ScopeData {\n+    fn index(&self, index: VisibilityScope) -> &VisibilityScopeData {\n         &self[index.index()]\n     }\n }\n \n-impl IndexMut<ScopeId> for Vec<ScopeData> {\n+impl IndexMut<VisibilityScope> for Vec<VisibilityScopeData> {\n     #[inline]\n-    fn index_mut(&mut self, index: ScopeId) -> &mut ScopeData {\n+    fn index_mut(&mut self, index: VisibilityScope) -> &mut VisibilityScopeData {\n         &mut self[index.index()]\n     }\n }\n \n #[derive(Copy, Clone, Debug, Hash, PartialEq, Eq, RustcEncodable, RustcDecodable)]\n-pub struct ScopeId(u32);\n+pub struct VisibilityScope(u32);\n+\n+/// The visibility scope all arguments go into.\n+pub const ARGUMENT_VISIBILITY_SCOPE: VisibilityScope = VisibilityScope(0);\n \n-impl ScopeId {\n-    pub fn new(index: usize) -> ScopeId {\n+impl VisibilityScope {\n+    pub fn new(index: usize) -> VisibilityScope {\n         assert!(index < (u32::MAX as usize));\n-        ScopeId(index as u32)\n+        VisibilityScope(index as u32)\n     }\n \n     pub fn index(self) -> usize {\n@@ -785,9 +795,9 @@ impl ScopeId {\n }\n \n #[derive(Clone, Debug, RustcEncodable, RustcDecodable)]\n-pub struct ScopeData {\n+pub struct VisibilityScopeData {\n     pub span: Span,\n-    pub parent_scope: Option<ScopeId>,\n+    pub parent_scope: Option<VisibilityScope>,\n }\n \n ///////////////////////////////////////////////////////////////////////////"}, {"sha": "dbe48d6b09447735b02605c44ef9e4871184d060", "filename": "src/librustc/mir/visit.rs", "status": "modified", "additions": 36, "deletions": 27, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/0d531bfb881e6d303d09de9f212eaac72a9a218d/src%2Flibrustc%2Fmir%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d531bfb881e6d303d09de9f212eaac72a9a218d/src%2Flibrustc%2Fmir%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Fvisit.rs?ref=0d531bfb881e6d303d09de9f212eaac72a9a218d", "patch": "@@ -97,9 +97,9 @@ macro_rules! make_mir_visitor {\n                 self.super_basic_block_data(block, data);\n             }\n \n-            fn visit_scope_data(&mut self,\n-                                scope_data: & $($mutability)* ScopeData) {\n-                self.super_scope_data(scope_data);\n+            fn visit_visibility_scope_data(&mut self,\n+                                           scope_data: & $($mutability)* VisibilityScopeData) {\n+                self.super_visibility_scope_data(scope_data);\n             }\n \n             fn visit_statement(&mut self,\n@@ -186,6 +186,11 @@ macro_rules! make_mir_visitor {\n                 self.super_span(span);\n             }\n \n+            fn visit_source_info(&mut self,\n+                                 source_info: & $($mutability)* SourceInfo) {\n+                self.super_source_info(source_info);\n+            }\n+\n             fn visit_fn_output(&mut self,\n                                fn_output: & $($mutability)* FnOutput<'tcx>) {\n                 self.super_fn_output(fn_output);\n@@ -236,9 +241,9 @@ macro_rules! make_mir_visitor {\n                 self.super_arg_decl(arg_decl);\n             }\n \n-            fn visit_scope_id(&mut self,\n-                              scope_id: & $($mutability)* ScopeId) {\n-                self.super_scope_id(scope_id);\n+            fn visit_visibility_scope(&mut self,\n+                                      scope: & $($mutability)* VisibilityScope) {\n+                self.super_visibility_scope(scope);\n             }\n \n             // The `super_xxx` methods comprise the default behavior and are\n@@ -248,7 +253,7 @@ macro_rules! make_mir_visitor {\n                          mir: & $($mutability)* Mir<'tcx>) {\n                 let Mir {\n                     ref $($mutability)* basic_blocks,\n-                    ref $($mutability)* scopes,\n+                    ref $($mutability)* visibility_scopes,\n                     promoted: _, // Visited by passes separately.\n                     ref $($mutability)* return_ty,\n                     ref $($mutability)* var_decls,\n@@ -263,8 +268,8 @@ macro_rules! make_mir_visitor {\n                     self.visit_basic_block_data(block, data);\n                 }\n \n-                for scope in scopes {\n-                    self.visit_scope_data(scope);\n+                for scope in visibility_scopes {\n+                    self.visit_visibility_scope_data(scope);\n                 }\n \n                 self.visit_fn_output(return_ty);\n@@ -302,30 +307,28 @@ macro_rules! make_mir_visitor {\n                 }\n             }\n \n-            fn super_scope_data(&mut self,\n-                                scope_data: & $($mutability)* ScopeData) {\n-                let ScopeData {\n+            fn super_visibility_scope_data(&mut self,\n+                                           scope_data: & $($mutability)* VisibilityScopeData) {\n+                let VisibilityScopeData {\n                     ref $($mutability)* span,\n                     ref $($mutability)* parent_scope,\n                 } = *scope_data;\n \n                 self.visit_span(span);\n                 if let Some(ref $($mutability)* parent_scope) = *parent_scope {\n-                    self.visit_scope_id(parent_scope);\n+                    self.visit_visibility_scope(parent_scope);\n                 }\n             }\n \n             fn super_statement(&mut self,\n                                block: BasicBlock,\n                                statement: & $($mutability)* Statement<'tcx>) {\n                 let Statement {\n-                    ref $($mutability)* span,\n-                    ref $($mutability)* scope,\n+                    ref $($mutability)* source_info,\n                     ref $($mutability)* kind,\n                 } = *statement;\n \n-                self.visit_span(span);\n-                self.visit_scope_id(scope);\n+                self.visit_source_info(source_info);\n                 match *kind {\n                     StatementKind::Assign(ref $($mutability)* lvalue,\n                                           ref $($mutability)* rvalue) => {\n@@ -346,13 +349,11 @@ macro_rules! make_mir_visitor {\n                                 block: BasicBlock,\n                                 terminator: &$($mutability)* Terminator<'tcx>) {\n                 let Terminator {\n-                    ref $($mutability)* span,\n-                    ref $($mutability)* scope,\n+                    ref $($mutability)* source_info,\n                     ref $($mutability)* kind,\n                 } = *terminator;\n \n-                self.visit_span(span);\n-                self.visit_scope_id(scope);\n+                self.visit_source_info(source_info);\n                 self.visit_terminator_kind(block, kind);\n             }\n \n@@ -622,13 +623,11 @@ macro_rules! make_mir_visitor {\n                     mutability: _,\n                     name: _,\n                     ref $($mutability)* ty,\n-                    ref $($mutability)* scope,\n-                    ref $($mutability)* span,\n+                    ref $($mutability)* source_info,\n                 } = *var_decl;\n \n                 self.visit_ty(ty);\n-                self.visit_scope_id(scope);\n-                self.visit_span(span);\n+                self.visit_source_info(source_info);\n             }\n \n             fn super_temp_decl(&mut self,\n@@ -651,8 +650,8 @@ macro_rules! make_mir_visitor {\n                 self.visit_ty(ty);\n             }\n \n-            fn super_scope_id(&mut self,\n-                              _scope_id: & $($mutability)* ScopeId) {\n+            fn super_visibility_scope(&mut self,\n+                                      _scope: & $($mutability)* VisibilityScope) {\n             }\n \n             fn super_branch(&mut self,\n@@ -707,6 +706,16 @@ macro_rules! make_mir_visitor {\n             fn super_span(&mut self, _span: & $($mutability)* Span) {\n             }\n \n+            fn super_source_info(&mut self, source_info: & $($mutability)* SourceInfo) {\n+                let SourceInfo {\n+                    ref $($mutability)* span,\n+                    ref $($mutability)* scope,\n+                } = *source_info;\n+\n+                self.visit_span(span);\n+                self.visit_visibility_scope(scope);\n+            }\n+\n             fn super_fn_output(&mut self, fn_output: & $($mutability)* FnOutput<'tcx>) {\n                 match *fn_output {\n                     FnOutput::FnConverging(ref $($mutability)* ty) => {"}, {"sha": "8c528f10b57ba205e4e65a2661d69d971f232125", "filename": "src/librustc_borrowck/borrowck/mir/dataflow/sanity_check.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0d531bfb881e6d303d09de9f212eaac72a9a218d/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Fdataflow%2Fsanity_check.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d531bfb881e6d303d09de9f212eaac72a9a218d/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Fdataflow%2Fsanity_check.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Fdataflow%2Fsanity_check.rs?ref=0d531bfb881e6d303d09de9f212eaac72a9a218d", "patch": "@@ -151,7 +151,7 @@ fn each_block<'a, 'tcx, O>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n fn is_rustc_peek<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                            terminator: &'a Option<repr::Terminator<'tcx>>)\n                            -> Option<(&'a [repr::Operand<'tcx>], Span)> {\n-    if let Some(repr::Terminator { ref kind, span, .. }) = *terminator {\n+    if let Some(repr::Terminator { ref kind, source_info, .. }) = *terminator {\n         if let repr::TerminatorKind::Call { func: ref oper, ref args, .. } = *kind\n         {\n             if let repr::Operand::Constant(ref func) = *oper\n@@ -161,7 +161,7 @@ fn is_rustc_peek<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                     let name = tcx.item_name(def_id);\n                     if abi == Abi::RustIntrinsic || abi == Abi::PlatformIntrinsic {\n                         if name.as_str() == \"rustc_peek\" {\n-                            return Some((args, span));\n+                            return Some((args, source_info.span));\n                         }\n                     }\n                 }"}, {"sha": "b09db70e7b88aa391a3aac8032bbe7aaa0e79b17", "filename": "src/librustc_borrowck/borrowck/mir/elaborate_drops.rs", "status": "modified", "additions": 14, "deletions": 21, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/0d531bfb881e6d303d09de9f212eaac72a9a218d/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Felaborate_drops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d531bfb881e6d303d09de9f212eaac72a9a218d/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Felaborate_drops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Felaborate_drops.rs?ref=0d531bfb881e6d303d09de9f212eaac72a9a218d", "patch": "@@ -124,8 +124,7 @@ struct ElaborateDropsCtxt<'a, 'tcx: 'a> {\n \n #[derive(Copy, Clone, Debug)]\n struct DropCtxt<'a, 'tcx: 'a> {\n-    span: Span,\n-    scope: ScopeId,\n+    source_info: SourceInfo,\n     is_cleanup: bool,\n \n     init_data: &'a InitializationData,\n@@ -273,8 +272,7 @@ impl<'b, 'tcx> ElaborateDropsCtxt<'b, 'tcx> {\n                     let init_data = self.initialization_data_at(loc);\n                     let path = self.move_data().rev_lookup.find(location);\n                     self.elaborate_drop(&DropCtxt {\n-                        span: terminator.span,\n-                        scope: terminator.scope,\n+                        source_info: terminator.source_info,\n                         is_cleanup: data.is_cleanup,\n                         init_data: &init_data,\n                         lvalue: location,\n@@ -329,8 +327,7 @@ impl<'b, 'tcx> ElaborateDropsCtxt<'b, 'tcx> {\n \n         let assign = Statement {\n             kind: StatementKind::Assign(location.clone(), Rvalue::Use(value.clone())),\n-            span: terminator.span,\n-            scope: terminator.scope\n+            source_info: terminator.source_info\n         };\n \n         let unwind = unwind.unwrap_or(self.patch.resume_block());\n@@ -367,8 +364,7 @@ impl<'b, 'tcx> ElaborateDropsCtxt<'b, 'tcx> {\n             let path = self.move_data().rev_lookup.find(location);\n \n             self.elaborate_drop(&DropCtxt {\n-                span: terminator.span,\n-                scope: terminator.scope,\n+                source_info: terminator.source_info,\n                 is_cleanup: data.is_cleanup,\n                 init_data: &init_data,\n                 lvalue: location,\n@@ -513,8 +509,7 @@ impl<'b, 'tcx> ElaborateDropsCtxt<'b, 'tcx> {\n                     debug!(\"drop_ladder: for std field {} ({:?})\", i, lv);\n \n                     self.elaborated_drop_block(&DropCtxt {\n-                        span: c.span,\n-                        scope: c.scope,\n+                        source_info: c.source_info,\n                         is_cleanup: is_cleanup,\n                         init_data: c.init_data,\n                         lvalue: lv,\n@@ -527,8 +522,7 @@ impl<'b, 'tcx> ElaborateDropsCtxt<'b, 'tcx> {\n                     debug!(\"drop_ladder: for rest field {} ({:?})\", i, lv);\n \n                     let blk = self.complete_drop(&DropCtxt {\n-                        span: c.span,\n-                        scope: c.scope,\n+                        source_info: c.source_info,\n                         is_cleanup: is_cleanup,\n                         init_data: c.init_data,\n                         lvalue: lv,\n@@ -785,7 +779,7 @@ impl<'b, 'tcx> ElaborateDropsCtxt<'b, 'tcx> {\n         self.patch.new_block(BasicBlockData {\n             statements: vec![],\n             terminator: Some(Terminator {\n-                scope: c.scope, span: c.span, kind: k\n+                source_info: c.source_info, kind: k\n             }),\n             is_cleanup: is_cleanup\n         })\n@@ -858,11 +852,10 @@ impl<'b, 'tcx> ElaborateDropsCtxt<'b, 'tcx> {\n         let mut statements = vec![];\n         if let Some(&flag) = self.drop_flags.get(&c.path) {\n             statements.push(Statement {\n-                span: c.span,\n-                scope: c.scope,\n+                source_info: c.source_info,\n                 kind: StatementKind::Assign(\n                     Lvalue::Temp(flag),\n-                    self.constant_bool(c.span, false)\n+                    self.constant_bool(c.source_info.span, false)\n                 )\n             });\n         }\n@@ -880,9 +873,9 @@ impl<'b, 'tcx> ElaborateDropsCtxt<'b, 'tcx> {\n         self.patch.new_block(BasicBlockData {\n             statements: statements,\n             terminator: Some(Terminator {\n-                scope: c.scope, span: c.span, kind: TerminatorKind::Call {\n+                source_info: c.source_info, kind: TerminatorKind::Call {\n                     func: Operand::Constant(Constant {\n-                        span: c.span,\n+                        span: c.source_info.span,\n                         ty: fty,\n                         literal: Literal::Item {\n                             def_id: free_func,\n@@ -910,7 +903,7 @@ impl<'b, 'tcx> ElaborateDropsCtxt<'b, 'tcx> {\n             ty::TyStruct(def, _) | ty::TyEnum(def, _) => {\n                 if def.has_dtor() {\n                     self.tcx.sess.span_warn(\n-                        c.span,\n+                        c.source_info.span,\n                         &format!(\"dataflow bug??? moving out of type with dtor {:?}\",\n                                  c));\n                     true\n@@ -932,15 +925,15 @@ impl<'b, 'tcx> ElaborateDropsCtxt<'b, 'tcx> {\n \n     fn set_drop_flag(&mut self, loc: Location, path: MovePathIndex, val: DropFlagState) {\n         if let Some(&flag) = self.drop_flags.get(&path) {\n-            let span = self.patch.context_for_location(self.mir, loc).0;\n+            let span = self.patch.source_info_for_location(self.mir, loc).span;\n             let val = self.constant_bool(span, val.value());\n             self.patch.add_assign(loc, Lvalue::Temp(flag), val);\n         }\n     }\n \n     fn drop_flags_on_init(&mut self) {\n         let loc = Location { block: START_BLOCK, index: 0 };\n-        let span = self.patch.context_for_location(self.mir, loc).0;\n+        let span = self.patch.source_info_for_location(self.mir, loc).span;\n         let false_ = self.constant_bool(span, false);\n         for flag in self.drop_flags.values() {\n             self.patch.add_assign(loc, Lvalue::Temp(*flag), false_.clone());"}, {"sha": "b838881251da320fee3586c1e1e1a0d6f4e89c6f", "filename": "src/librustc_borrowck/borrowck/mir/patch.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/0d531bfb881e6d303d09de9f212eaac72a9a218d/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Fpatch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d531bfb881e6d303d09de9f212eaac72a9a218d/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Fpatch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Fpatch.rs?ref=0d531bfb881e6d303d09de9f212eaac72a9a218d", "patch": "@@ -11,7 +11,6 @@\n use super::gather_moves::Location;\n use rustc::ty::Ty;\n use rustc::mir::repr::*;\n-use syntax::codemap::Span;\n \n use std::iter;\n use std::u32;\n@@ -62,8 +61,10 @@ impl<'tcx> MirPatch<'tcx> {\n             result.new_block(BasicBlockData {\n                 statements: vec![],\n                 terminator: Some(Terminator {\n-                    span: mir.span,\n-                    scope: ScopeId::new(0),\n+                    source_info: SourceInfo {\n+                        span: mir.span,\n+                        scope: ARGUMENT_VISIBILITY_SCOPE\n+                    },\n                     kind: TerminatorKind::Resume\n                 }),\n                 is_cleanup: true\n@@ -154,31 +155,30 @@ impl<'tcx> MirPatch<'tcx> {\n             debug!(\"MirPatch: adding statement {:?} at loc {:?}+{}\",\n                    stmt, loc, delta);\n             loc.index += delta;\n-            let (span, scope) = Self::context_for_index(\n+            let source_info = Self::source_info_for_index(\n                 mir.basic_block_data(loc.block), loc\n             );\n             mir.basic_block_data_mut(loc.block).statements.insert(\n                 loc.index, Statement {\n-                    span: span,\n-                    scope: scope,\n+                    source_info: source_info,\n                     kind: stmt\n                 });\n             delta += 1;\n         }\n     }\n \n-    pub fn context_for_index(data: &BasicBlockData, loc: Location) -> (Span, ScopeId) {\n+    pub fn source_info_for_index(data: &BasicBlockData, loc: Location) -> SourceInfo {\n         match data.statements.get(loc.index) {\n-            Some(stmt) => (stmt.span, stmt.scope),\n-            None => (data.terminator().span, data.terminator().scope)\n+            Some(stmt) => stmt.source_info,\n+            None => data.terminator().source_info\n         }\n     }\n \n-    pub fn context_for_location(&self, mir: &Mir, loc: Location) -> (Span, ScopeId) {\n+    pub fn source_info_for_location(&self, mir: &Mir, loc: Location) -> SourceInfo {\n         let data = match loc.block.index().checked_sub(mir.basic_blocks.len()) {\n             Some(new) => &self.new_blocks[new],\n             None => mir.basic_block_data(loc.block)\n         };\n-        Self::context_for_index(data, loc)\n+        Self::source_info_for_index(data, loc)\n     }\n }"}, {"sha": "7e650c5bd3d06c03f34c3f9494ff1e8ec4df2a8f", "filename": "src/librustc_mir/build/block.rs", "status": "modified", "additions": 29, "deletions": 14, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/0d531bfb881e6d303d09de9f212eaac72a9a218d/src%2Flibrustc_mir%2Fbuild%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d531bfb881e6d303d09de9f212eaac72a9a218d/src%2Flibrustc_mir%2Fbuild%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fblock.rs?ref=0d531bfb881e6d303d09de9f212eaac72a9a218d", "patch": "@@ -22,7 +22,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                      ast_block: &'tcx hir::Block)\n                      -> BlockAnd<()> {\n         let Block { extent, span, stmts, expr } = self.hir.mirror(ast_block);\n-        self.in_scope(extent, block, move |this, _| {\n+        self.in_scope(extent, block, move |this| {\n             // This convoluted structure is to avoid using recursion as we walk down a list\n             // of statements. Basically, the structure we get back is something like:\n             //\n@@ -40,27 +40,40 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n             //\n             // First we build all the statements in the block.\n             let mut let_extent_stack = Vec::with_capacity(8);\n+            let outer_visibility_scope = this.visibility_scope;\n             for stmt in stmts {\n                 let Stmt { span: _, kind } = this.hir.mirror(stmt);\n                 match kind {\n                     StmtKind::Expr { scope, expr } => {\n-                        unpack!(block = this.in_scope(scope, block, |this, _| {\n+                        unpack!(block = this.in_scope(scope, block, |this| {\n                             let expr = this.hir.mirror(expr);\n                             this.stmt_expr(block, expr)\n                         }));\n                     }\n                     StmtKind::Let { remainder_scope, init_scope, pattern, initializer } => {\n-                        let remainder_scope_id = this.push_scope(remainder_scope, block);\n+                        let tcx = this.hir.tcx();\n+\n+                        // Enter the remainder scope, i.e. the bindings' destruction scope.\n+                        this.push_scope(remainder_scope, block);\n                         let_extent_stack.push(remainder_scope);\n-                        unpack!(block = this.in_scope(init_scope, block, move |this, _| {\n-                            // FIXME #30046                              ^~~~\n-                            if let Some(init) = initializer {\n-                                this.expr_into_pattern(block, remainder_scope_id, pattern, init)\n-                            } else {\n-                                this.declare_bindings(remainder_scope_id, &pattern);\n-                                block.unit()\n-                            }\n-                        }));\n+\n+                        // Declare the bindings, which may create a visibility scope.\n+                        let remainder_span = remainder_scope.span(&tcx.region_maps, &tcx.map);\n+                        let remainder_span = remainder_span.unwrap_or(span);\n+                        let scope = this.declare_bindings(None, remainder_span, &pattern);\n+\n+                        // Evaluate the initializer, if present.\n+                        if let Some(init) = initializer {\n+                            unpack!(block = this.in_scope(init_scope, block, move |this| {\n+                                // FIXME #30046                              ^~~~\n+                                this.expr_into_pattern(block, pattern, init)\n+                            }));\n+                        }\n+\n+                        // Enter the visibility scope, after evaluating the initializer.\n+                        if let Some(visibility_scope) = scope {\n+                            this.visibility_scope = visibility_scope;\n+                        }\n                     }\n                 }\n             }\n@@ -70,14 +83,16 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                 unpack!(block = this.into(destination, block, expr));\n             } else if dest_is_unit {\n                 // FIXME(#31472)\n-                let scope_id = this.innermost_scope_id();\n-                this.cfg.push_assign_unit(block, scope_id, span, destination);\n+                let source_info = this.source_info(span);\n+                this.cfg.push_assign_unit(block, source_info, destination);\n             }\n             // Finally, we pop all the let scopes before exiting out from the scope of block\n             // itself.\n             for extent in let_extent_stack.into_iter().rev() {\n                 unpack!(block = this.pop_scope(extent, block));\n             }\n+            // Restore the original visibility scope.\n+            this.visibility_scope = outer_visibility_scope;\n             block.unit()\n         })\n     }"}, {"sha": "95f87bf83261400414835ec98c9c6937ee1160c7", "filename": "src/librustc_mir/build/cfg.rs", "status": "modified", "additions": 8, "deletions": 15, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/0d531bfb881e6d303d09de9f212eaac72a9a218d/src%2Flibrustc_mir%2Fbuild%2Fcfg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d531bfb881e6d303d09de9f212eaac72a9a218d/src%2Flibrustc_mir%2Fbuild%2Fcfg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fcfg.rs?ref=0d531bfb881e6d303d09de9f212eaac72a9a218d", "patch": "@@ -15,7 +15,6 @@\n \n use build::{CFG, Location};\n use rustc::mir::repr::*;\n-use syntax::codemap::Span;\n \n impl<'tcx> CFG<'tcx> {\n     pub fn block_data(&self, blk: BasicBlock) -> &BasicBlockData<'tcx> {\n@@ -50,47 +49,41 @@ impl<'tcx> CFG<'tcx> {\n \n     pub fn push_assign(&mut self,\n                        block: BasicBlock,\n-                       scope: ScopeId,\n-                       span: Span,\n+                       source_info: SourceInfo,\n                        lvalue: &Lvalue<'tcx>,\n                        rvalue: Rvalue<'tcx>) {\n         self.push(block, Statement {\n-            scope: scope,\n-            span: span,\n+            source_info: source_info,\n             kind: StatementKind::Assign(lvalue.clone(), rvalue)\n         });\n     }\n \n     pub fn push_assign_constant(&mut self,\n                                 block: BasicBlock,\n-                                scope: ScopeId,\n-                                span: Span,\n+                                source_info: SourceInfo,\n                                 temp: &Lvalue<'tcx>,\n                                 constant: Constant<'tcx>) {\n-        self.push_assign(block, scope, span, temp,\n+        self.push_assign(block, source_info, temp,\n                          Rvalue::Use(Operand::Constant(constant)));\n     }\n \n     pub fn push_assign_unit(&mut self,\n                             block: BasicBlock,\n-                            scope: ScopeId,\n-                            span: Span,\n+                            source_info: SourceInfo,\n                             lvalue: &Lvalue<'tcx>) {\n-        self.push_assign(block, scope, span, lvalue, Rvalue::Aggregate(\n+        self.push_assign(block, source_info, lvalue, Rvalue::Aggregate(\n             AggregateKind::Tuple, vec![]\n         ));\n     }\n \n     pub fn terminate(&mut self,\n                      block: BasicBlock,\n-                     scope: ScopeId,\n-                     span: Span,\n+                     source_info: SourceInfo,\n                      kind: TerminatorKind<'tcx>) {\n         debug_assert!(self.block_data(block).terminator.is_none(),\n                       \"terminate: block {:?} already has a terminator set\", block);\n         self.block_data_mut(block).terminator = Some(Terminator {\n-            span: span,\n-            scope: scope,\n+            source_info: source_info,\n             kind: kind,\n         });\n     }"}, {"sha": "8e33cfa9b0b52241e4f1db275f96aa3af855bc67", "filename": "src/librustc_mir/build/expr/as_lvalue.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/0d531bfb881e6d303d09de9f212eaac72a9a218d/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_lvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d531bfb881e6d303d09de9f212eaac72a9a218d/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_lvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_lvalue.rs?ref=0d531bfb881e6d303d09de9f212eaac72a9a218d", "patch": "@@ -34,11 +34,11 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n         debug!(\"expr_as_lvalue(block={:?}, expr={:?})\", block, expr);\n \n         let this = self;\n-        let scope_id = this.innermost_scope_id();\n         let expr_span = expr.span;\n+        let source_info = this.source_info(expr_span);\n         match expr.kind {\n             ExprKind::Scope { extent, value } => {\n-                this.in_scope(extent, block, |this, _| this.as_lvalue(block, value))\n+                this.in_scope(extent, block, |this| this.as_lvalue(block, value))\n             }\n             ExprKind::Field { lhs, name } => {\n                 let lvalue = unpack!(block = this.as_lvalue(block, lhs));\n@@ -59,9 +59,9 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n \n                 // bounds check:\n                 let (len, lt) = (this.temp(usize_ty.clone()), this.temp(bool_ty));\n-                this.cfg.push_assign(block, scope_id, expr_span, // len = len(slice)\n+                this.cfg.push_assign(block, source_info, // len = len(slice)\n                                      &len, Rvalue::Len(slice.clone()));\n-                this.cfg.push_assign(block, scope_id, expr_span, // lt = idx < len\n+                this.cfg.push_assign(block, source_info, // lt = idx < len\n                                      &lt, Rvalue::BinaryOp(BinOp::Lt,\n                                                            idx.clone(),\n                                                            Operand::Consume(len.clone())));"}, {"sha": "beb9ca256abfd9248a93b3a4805838f1853be284", "filename": "src/librustc_mir/build/expr/as_operand.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0d531bfb881e6d303d09de9f212eaac72a9a218d/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_operand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d531bfb881e6d303d09de9f212eaac72a9a218d/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_operand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_operand.rs?ref=0d531bfb881e6d303d09de9f212eaac72a9a218d", "patch": "@@ -35,7 +35,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n         let this = self;\n \n         if let ExprKind::Scope { extent, value } = expr.kind {\n-            return this.in_scope(extent, block, |this, _| this.as_operand(block, value));\n+            return this.in_scope(extent, block, |this| this.as_operand(block, value));\n         }\n \n         let category = Category::of(&expr.kind).unwrap();"}, {"sha": "6524124c13b06a6abd771deba8e13d94376958a8", "filename": "src/librustc_mir/build/expr/as_rvalue.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/0d531bfb881e6d303d09de9f212eaac72a9a218d/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_rvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d531bfb881e6d303d09de9f212eaac72a9a218d/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_rvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_rvalue.rs?ref=0d531bfb881e6d303d09de9f212eaac72a9a218d", "patch": "@@ -41,12 +41,12 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n         debug!(\"expr_as_rvalue(block={:?}, expr={:?})\", block, expr);\n \n         let this = self;\n-        let scope_id = this.innermost_scope_id();\n         let expr_span = expr.span;\n+        let source_info = this.source_info(expr_span);\n \n         match expr.kind {\n             ExprKind::Scope { extent, value } => {\n-                this.in_scope(extent, block, |this, _| this.as_rvalue(block, value))\n+                this.in_scope(extent, block, |this| this.as_rvalue(block, value))\n             }\n             ExprKind::InlineAsm { asm, outputs, inputs } => {\n                 let outputs = outputs.into_iter().map(|output| {\n@@ -86,7 +86,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                     let minval = this.minval_literal(expr_span, expr.ty);\n                     let is_min = this.temp(bool_ty);\n \n-                    this.cfg.push_assign(block, scope_id, expr_span, &is_min,\n+                    this.cfg.push_assign(block, source_info, &is_min,\n                                          Rvalue::BinaryOp(BinOp::Eq, arg.clone(), minval));\n \n                     let err = ConstMathErr::Overflow(Op::Neg);\n@@ -99,8 +99,8 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                 let value = this.hir.mirror(value);\n                 let result = this.temp(expr.ty);\n                 // to start, malloc some memory of suitable type (thus far, uninitialized):\n-                this.cfg.push_assign(block, scope_id, expr_span, &result, Rvalue::Box(value.ty));\n-                this.in_scope(value_extents, block, |this, _| {\n+                this.cfg.push_assign(block, source_info, &result, Rvalue::Box(value.ty));\n+                this.in_scope(value_extents, block, |this| {\n                     // schedule a shallow free of that memory, lest we unwind:\n                     this.schedule_box_free(expr_span, value_extents, &result, value.ty);\n                     // initialize the box contents:\n@@ -245,13 +245,13 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n     pub fn build_binary_op(&mut self, mut block: BasicBlock,\n                            op: BinOp, span: Span, ty: ty::Ty<'tcx>,\n                            lhs: Operand<'tcx>, rhs: Operand<'tcx>) -> BlockAnd<Rvalue<'tcx>> {\n-        let scope_id = self.innermost_scope_id();\n+        let source_info = self.source_info(span);\n         let bool_ty = self.hir.bool_ty();\n         if self.hir.check_overflow() && op.is_checkable() && ty.is_integral() {\n             let result_tup = self.hir.tcx().mk_tup(vec![ty, bool_ty]);\n             let result_value = self.temp(result_tup);\n \n-            self.cfg.push_assign(block, scope_id, span,\n+            self.cfg.push_assign(block, source_info,\n                                  &result_value, Rvalue::CheckedBinaryOp(op,\n                                                                         lhs,\n                                                                         rhs));\n@@ -292,7 +292,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                 // Check for / 0\n                 let is_zero = self.temp(bool_ty);\n                 let zero = self.zero_literal(span, ty);\n-                self.cfg.push_assign(block, scope_id, span, &is_zero,\n+                self.cfg.push_assign(block, source_info, &is_zero,\n                                      Rvalue::BinaryOp(BinOp::Eq, rhs.clone(), zero));\n \n                 block = self.assert(block, Operand::Consume(is_zero), false,\n@@ -310,14 +310,14 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n \n                     // this does (rhs == -1) & (lhs == MIN). It could short-circuit instead\n \n-                    self.cfg.push_assign(block, scope_id, span, &is_neg_1,\n+                    self.cfg.push_assign(block, source_info, &is_neg_1,\n                                          Rvalue::BinaryOp(BinOp::Eq, rhs.clone(), neg_1));\n-                    self.cfg.push_assign(block, scope_id, span, &is_min,\n+                    self.cfg.push_assign(block, source_info, &is_min,\n                                          Rvalue::BinaryOp(BinOp::Eq, lhs.clone(), min));\n \n                     let is_neg_1 = Operand::Consume(is_neg_1);\n                     let is_min = Operand::Consume(is_min);\n-                    self.cfg.push_assign(block, scope_id, span, &of,\n+                    self.cfg.push_assign(block, source_info, &of,\n                                          Rvalue::BinaryOp(BinOp::BitAnd, is_neg_1, is_min));\n \n                     block = self.assert(block, Operand::Consume(of), false,"}, {"sha": "da128b8dd56266ada2214ddb9c5241505d11643d", "filename": "src/librustc_mir/build/expr/as_temp.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0d531bfb881e6d303d09de9f212eaac72a9a218d/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_temp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d531bfb881e6d303d09de9f212eaac72a9a218d/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_temp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_temp.rs?ref=0d531bfb881e6d303d09de9f212eaac72a9a218d", "patch": "@@ -30,7 +30,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n         let this = self;\n \n         if let ExprKind::Scope { extent, value } = expr.kind {\n-            return this.in_scope(extent, block, |this, _| this.as_temp(block, value));\n+            return this.in_scope(extent, block, |this| this.as_temp(block, value));\n         }\n \n         let expr_ty = expr.ty.clone();\n@@ -49,8 +49,8 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n             Category::Lvalue => {\n                 let lvalue = unpack!(block = this.as_lvalue(block, expr));\n                 let rvalue = Rvalue::Use(Operand::Consume(lvalue));\n-                let scope_id = this.innermost_scope_id();\n-                this.cfg.push_assign(block, scope_id, expr_span, &temp, rvalue);\n+                let source_info = this.source_info(expr_span);\n+                this.cfg.push_assign(block, source_info, &temp, rvalue);\n             }\n             _ => {\n                 unpack!(block = this.into(&temp, block, expr));"}, {"sha": "fd9ddc05ab5c4cfb3533fc42aadc4b2fce37d07d", "filename": "src/librustc_mir/build/expr/into.rs", "status": "modified", "additions": 18, "deletions": 35, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/0d531bfb881e6d303d09de9f212eaac72a9a218d/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Finto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d531bfb881e6d303d09de9f212eaac72a9a218d/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Finto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Finto.rs?ref=0d531bfb881e6d303d09de9f212eaac72a9a218d", "patch": "@@ -33,11 +33,11 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n         // just use the name `this` uniformly\n         let this = self;\n         let expr_span = expr.span;\n-        let scope_id = this.innermost_scope_id();\n+        let source_info = this.source_info(expr_span);\n \n         match expr.kind {\n             ExprKind::Scope { extent, value } => {\n-                this.in_scope(extent, block, |this, _| this.into(destination, block, value))\n+                this.in_scope(extent, block, |this| this.into(destination, block, value))\n             }\n             ExprKind::Block { body: ast_block } => {\n                 this.ast_block(destination, expr.ty.is_nil(), block, ast_block)\n@@ -50,7 +50,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n \n                 let mut then_block = this.cfg.start_new_block();\n                 let mut else_block = this.cfg.start_new_block();\n-                this.cfg.terminate(block, scope_id, expr_span, TerminatorKind::If {\n+                this.cfg.terminate(block, source_info, TerminatorKind::If {\n                     cond: operand,\n                     targets: (then_block, else_block)\n                 });\n@@ -61,19 +61,14 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                 } else {\n                     // Body of the `if` expression without an `else` clause must return `()`, thus\n                     // we implicitly generate a `else {}` if it is not specified.\n-                    let scope_id = this.innermost_scope_id();\n-                    this.cfg.push_assign_unit(else_block, scope_id, expr_span, destination);\n+                    this.cfg.push_assign_unit(else_block, source_info, destination);\n                     else_block\n                 };\n \n                 let join_block = this.cfg.start_new_block();\n-                this.cfg.terminate(then_block,\n-                                   scope_id,\n-                                   expr_span,\n+                this.cfg.terminate(then_block, source_info,\n                                    TerminatorKind::Goto { target: join_block });\n-                this.cfg.terminate(else_block,\n-                                   scope_id,\n-                                   expr_span,\n+                this.cfg.terminate(else_block, source_info,\n                                    TerminatorKind::Goto { target: join_block });\n \n                 join_block.unit()\n@@ -100,40 +95,34 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                     LogicalOp::And => (else_block, false_block),\n                     LogicalOp::Or => (true_block, else_block),\n                 };\n-                this.cfg.terminate(block,\n-                                   scope_id,\n-                                   expr_span,\n+                this.cfg.terminate(block, source_info,\n                                    TerminatorKind::If { cond: lhs, targets: blocks });\n \n                 let rhs = unpack!(else_block = this.as_operand(else_block, rhs));\n-                this.cfg.terminate(else_block, scope_id, expr_span, TerminatorKind::If {\n+                this.cfg.terminate(else_block, source_info, TerminatorKind::If {\n                     cond: rhs,\n                     targets: (true_block, false_block)\n                 });\n \n                 this.cfg.push_assign_constant(\n-                    true_block, scope_id, expr_span, destination,\n+                    true_block, source_info, destination,\n                     Constant {\n                         span: expr_span,\n                         ty: this.hir.bool_ty(),\n                         literal: this.hir.true_literal(),\n                     });\n \n                 this.cfg.push_assign_constant(\n-                    false_block, scope_id, expr_span, destination,\n+                    false_block, source_info, destination,\n                     Constant {\n                         span: expr_span,\n                         ty: this.hir.bool_ty(),\n                         literal: this.hir.false_literal(),\n                     });\n \n-                this.cfg.terminate(true_block,\n-                                   scope_id,\n-                                   expr_span,\n+                this.cfg.terminate(true_block, source_info,\n                                    TerminatorKind::Goto { target: join_block });\n-                this.cfg.terminate(false_block,\n-                                   scope_id,\n-                                   expr_span,\n+                this.cfg.terminate(false_block, source_info,\n                                    TerminatorKind::Goto { target: join_block });\n \n                 join_block.unit()\n@@ -158,9 +147,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                 let exit_block = this.cfg.start_new_block();\n \n                 // start the loop\n-                this.cfg.terminate(block,\n-                                   scope_id,\n-                                   expr_span,\n+                this.cfg.terminate(block, source_info,\n                                    TerminatorKind::Goto { target: loop_block });\n \n                 let might_break = this.in_loop_scope(loop_block, exit_block, move |this| {\n@@ -173,9 +160,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                         let loop_block_end;\n                         let cond = unpack!(loop_block_end = this.as_operand(loop_block, cond_expr));\n                         body_block = this.cfg.start_new_block();\n-                        this.cfg.terminate(loop_block_end,\n-                                           scope_id,\n-                                           expr_span,\n+                        this.cfg.terminate(loop_block_end, source_info,\n                                            TerminatorKind::If {\n                                                cond: cond,\n                                                targets: (body_block, exit_block)\n@@ -192,15 +177,13 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                     let tmp = this.get_unit_temp();\n                     // Execute the body, branching back to the test.\n                     let body_block_end = unpack!(this.into(&tmp, body_block, body));\n-                    this.cfg.terminate(body_block_end,\n-                                       scope_id,\n-                                       expr_span,\n+                    this.cfg.terminate(body_block_end, source_info,\n                                        TerminatorKind::Goto { target: loop_block });\n                 });\n                 // If the loop may reach its exit_block, we assign an empty tuple to the\n                 // destination to keep the MIR well-formed.\n                 if might_break {\n-                    this.cfg.push_assign_unit(exit_block, scope_id, expr_span, destination);\n+                    this.cfg.push_assign_unit(exit_block, source_info, destination);\n                 }\n                 exit_block.unit()\n             }\n@@ -219,7 +202,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n \n                 let success = this.cfg.start_new_block();\n                 let cleanup = this.diverge_cleanup();\n-                this.cfg.terminate(block, scope_id, expr_span, TerminatorKind::Call {\n+                this.cfg.terminate(block, source_info, TerminatorKind::Call {\n                     func: fun,\n                     args: args,\n                     cleanup: cleanup,\n@@ -269,7 +252,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                 });\n \n                 let rvalue = unpack!(block = this.as_rvalue(block, expr));\n-                this.cfg.push_assign(block, scope_id, expr_span, destination, rvalue);\n+                this.cfg.push_assign(block, source_info, destination, rvalue);\n                 block.unit()\n             }\n         }"}, {"sha": "ad55a3d8b73f268572cf19dd3cd3e877ad243493", "filename": "src/librustc_mir/build/expr/stmt.rs", "status": "modified", "additions": 5, "deletions": 8, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/0d531bfb881e6d303d09de9f212eaac72a9a218d/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fstmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d531bfb881e6d303d09de9f212eaac72a9a218d/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fstmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fstmt.rs?ref=0d531bfb881e6d303d09de9f212eaac72a9a218d", "patch": "@@ -20,18 +20,17 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n     pub fn stmt_expr(&mut self, mut block: BasicBlock, expr: Expr<'tcx>) -> BlockAnd<()> {\n         let this = self;\n         let expr_span = expr.span;\n-        let scope_id = this.innermost_scope_id();\n+        let source_info = this.source_info(expr.span);\n         // Handle a number of expressions that don't need a destination at all. This\n         // avoids needing a mountain of temporary `()` variables.\n         match expr.kind {\n             ExprKind::Scope { extent, value } => {\n                 let value = this.hir.mirror(value);\n-                this.in_scope(extent, block, |this, _| this.stmt_expr(block, value))\n+                this.in_scope(extent, block, |this| this.stmt_expr(block, value))\n             }\n             ExprKind::Assign { lhs, rhs } => {\n                 let lhs = this.hir.mirror(lhs);\n                 let rhs = this.hir.mirror(rhs);\n-                let scope_id = this.innermost_scope_id();\n                 let lhs_span = lhs.span;\n \n                 // Note: we evaluate assignments right-to-left. This\n@@ -50,7 +49,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                 } else {\n                     let rhs = unpack!(block = this.as_rvalue(block, rhs));\n                     let lhs = unpack!(block = this.as_lvalue(block, lhs));\n-                    this.cfg.push_assign(block, scope_id, expr_span, &lhs, rhs);\n+                    this.cfg.push_assign(block, source_info, &lhs, rhs);\n                     block.unit()\n                 }\n             }\n@@ -75,7 +74,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                 // (overloaded ops should be desugared into a call).\n                 let result = unpack!(block = this.build_binary_op(block, op, expr_span, lhs_ty,\n                                                   Operand::Consume(lhs.clone()), rhs));\n-                this.cfg.push_assign(block, scope_id, expr_span, &lhs, result);\n+                this.cfg.push_assign(block, source_info, &lhs, result);\n \n                 block.unit()\n             }\n@@ -93,8 +92,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                 block = match value {\n                     Some(value) => unpack!(this.into(&Lvalue::ReturnPointer, block, value)),\n                     None => {\n-                        this.cfg.push_assign_unit(block, scope_id,\n-                                                  expr_span, &Lvalue::ReturnPointer);\n+                        this.cfg.push_assign_unit(block, source_info, &Lvalue::ReturnPointer);\n                         block\n                     }\n                 };\n@@ -104,7 +102,6 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                 this.cfg.start_new_block().unit()\n             }\n             _ => {\n-                let expr_span = expr.span;\n                 let expr_ty = expr.ty;\n                 let temp = this.temp(expr.ty.clone());\n                 unpack!(block = this.into(&temp, block, expr));"}, {"sha": "6104679d6500f376f010f4503d6712d6e1f1745b", "filename": "src/librustc_mir/build/matches/mod.rs", "status": "modified", "additions": 49, "deletions": 69, "changes": 118, "blob_url": "https://github.com/rust-lang/rust/blob/0d531bfb881e6d303d09de9f212eaac72a9a218d/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d531bfb881e6d303d09de9f212eaac72a9a218d/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fmod.rs?ref=0d531bfb881e6d303d09de9f212eaac72a9a218d", "patch": "@@ -44,21 +44,11 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                         .collect(),\n         };\n \n-        // Get the body expressions and their scopes, while declaring bindings.\n-        let arm_bodies: Vec<_> = arms.iter().enumerate().map(|(i, arm)| {\n-            // Assume that all expressions are wrapped in Scope.\n+        // Get the arm bodies and their scopes, while declaring bindings.\n+        let arm_bodies: Vec<_> = arms.iter().map(|arm| {\n             let body = self.hir.mirror(arm.body.clone());\n-            match body.kind {\n-                ExprKind::Scope { extent, value } => {\n-                    let scope_id = self.push_scope(extent, arm_blocks.blocks[i]);\n-                    self.declare_bindings(scope_id, &arm.patterns[0]);\n-                    (extent, self.scopes.pop().unwrap(), value)\n-                }\n-                _ => {\n-                    span_bug!(body.span, \"arm body is not wrapped in Scope {:?}\",\n-                              body.kind);\n-                }\n-            }\n+            let scope = self.declare_bindings(None, body.span, &arm.patterns[0]);\n+            (body, scope.unwrap_or(self.visibility_scope))\n         }).collect();\n \n         // assemble a list of candidates: there is one candidate per\n@@ -99,63 +89,46 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n         // all the arm blocks will rejoin here\n         let end_block = self.cfg.start_new_block();\n \n-        let scope_id = self.innermost_scope_id();\n-        for (arm_index, (extent, scope, body)) in arm_bodies.into_iter().enumerate() {\n+        let outer_source_info = self.source_info(span);\n+        for (arm_index, (body, visibility_scope)) in arm_bodies.into_iter().enumerate() {\n             let mut arm_block = arm_blocks.blocks[arm_index];\n-            // Re-enter the scope we created the bindings in.\n-            self.scopes.push(scope);\n+            // Re-enter the visibility scope we created the bindings in.\n+            self.visibility_scope = visibility_scope;\n             unpack!(arm_block = self.into(destination, arm_block, body));\n-            unpack!(arm_block = self.pop_scope(extent, arm_block));\n-            self.cfg.terminate(arm_block,\n-                               scope_id,\n-                               span,\n+            self.cfg.terminate(arm_block, outer_source_info,\n                                TerminatorKind::Goto { target: end_block });\n         }\n+        self.visibility_scope = outer_source_info.scope;\n \n         end_block.unit()\n     }\n \n     pub fn expr_into_pattern(&mut self,\n                              mut block: BasicBlock,\n-                             var_scope_id: ScopeId, // lifetime of vars\n                              irrefutable_pat: Pattern<'tcx>,\n                              initializer: ExprRef<'tcx>)\n                              -> BlockAnd<()> {\n         // optimize the case of `let x = ...`\n         match *irrefutable_pat.kind {\n-            PatternKind::Binding { mutability,\n-                                   name,\n-                                   mode: BindingMode::ByValue,\n+            PatternKind::Binding { mode: BindingMode::ByValue,\n                                    var,\n-                                   ty,\n-                                   subpattern: None } => {\n-                let index = self.declare_binding(var_scope_id,\n-                                                 mutability,\n-                                                 name,\n-                                                 var,\n-                                                 ty,\n-                                                 irrefutable_pat.span);\n-                let lvalue = Lvalue::Var(index);\n+                                   subpattern: None, .. } => {\n+                let lvalue = Lvalue::Var(self.var_indices[&var]);\n                 return self.into(&lvalue, block, initializer);\n             }\n             _ => {}\n         }\n         let lvalue = unpack!(block = self.as_lvalue(block, initializer));\n         self.lvalue_into_pattern(block,\n-                                 var_scope_id,\n                                  irrefutable_pat,\n                                  &lvalue)\n     }\n \n     pub fn lvalue_into_pattern(&mut self,\n                                mut block: BasicBlock,\n-                               var_scope_id: ScopeId,\n                                irrefutable_pat: Pattern<'tcx>,\n                                initializer: &Lvalue<'tcx>)\n                                -> BlockAnd<()> {\n-        // first, creating the bindings\n-        self.declare_bindings(var_scope_id, &irrefutable_pat);\n-\n         // create a dummy candidate\n         let mut candidate = Candidate {\n             span: irrefutable_pat.span,\n@@ -182,32 +155,47 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n         block.unit()\n     }\n \n-    pub fn declare_bindings(&mut self, var_scope_id: ScopeId, pattern: &Pattern<'tcx>) {\n+    /// Declares the bindings of the given pattern and returns the visibility scope\n+    /// for the bindings in this patterns, if such a scope had to be created.\n+    /// NOTE: Declaring the bindings should always be done in their drop scope.\n+    pub fn declare_bindings(&mut self,\n+                            mut var_scope: Option<VisibilityScope>,\n+                            scope_span: Span,\n+                            pattern: &Pattern<'tcx>)\n+                            -> Option<VisibilityScope> {\n         match *pattern.kind {\n             PatternKind::Binding { mutability, name, mode: _, var, ty, ref subpattern } => {\n-                self.declare_binding(var_scope_id, mutability, name, var, ty, pattern.span);\n+                if var_scope.is_none() {\n+                    var_scope = Some(self.new_visibility_scope(scope_span));\n+                }\n+                let source_info = SourceInfo {\n+                    span: pattern.span,\n+                    scope: var_scope.unwrap()\n+                };\n+                self.declare_binding(source_info, mutability, name, var, ty);\n                 if let Some(subpattern) = subpattern.as_ref() {\n-                    self.declare_bindings(var_scope_id, subpattern);\n+                    var_scope = self.declare_bindings(var_scope, scope_span, subpattern);\n                 }\n             }\n             PatternKind::Array { ref prefix, ref slice, ref suffix } |\n             PatternKind::Slice { ref prefix, ref slice, ref suffix } => {\n                 for subpattern in prefix.iter().chain(slice).chain(suffix) {\n-                    self.declare_bindings(var_scope_id, subpattern);\n+                    var_scope = self.declare_bindings(var_scope, scope_span, subpattern);\n                 }\n             }\n             PatternKind::Constant { .. } | PatternKind::Range { .. } | PatternKind::Wild => {\n             }\n             PatternKind::Deref { ref subpattern } => {\n-                self.declare_bindings(var_scope_id, subpattern);\n+                var_scope = self.declare_bindings(var_scope, scope_span, subpattern);\n             }\n             PatternKind::Leaf { ref subpatterns } |\n             PatternKind::Variant { ref subpatterns, .. } => {\n                 for subpattern in subpatterns {\n-                    self.declare_bindings(var_scope_id, &subpattern.pattern);\n+                    var_scope = self.declare_bindings(var_scope, scope_span, &subpattern.pattern);\n                 }\n             }\n         }\n+        var_scope\n     }\n }\n \n@@ -396,17 +384,15 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                              mut otherwise: Vec<BasicBlock>)\n                              -> BasicBlock\n     {\n+        let source_info = self.source_info(span);\n         otherwise.sort();\n         otherwise.dedup(); // variant switches can introduce duplicate target blocks\n-        let scope_id = self.innermost_scope_id();\n         if otherwise.len() == 1 {\n             otherwise[0]\n         } else {\n             let join_block = self.cfg.start_new_block();\n             for block in otherwise {\n-                self.cfg.terminate(block,\n-                                   scope_id,\n-                                   span,\n+                self.cfg.terminate(block, source_info,\n                                    TerminatorKind::Goto { target: join_block });\n             }\n             join_block\n@@ -585,24 +571,20 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n \n         let arm_block = arm_blocks.blocks[candidate.arm_index];\n \n-        let scope_id = self.innermost_scope_id();\n         if let Some(guard) = candidate.guard {\n             // the block to branch to if the guard fails; if there is no\n             // guard, this block is simply unreachable\n             let guard = self.hir.mirror(guard);\n-            let guard_span = guard.span;\n+            let source_info = self.source_info(guard.span);\n             let cond = unpack!(block = self.as_operand(block, guard));\n             let otherwise = self.cfg.start_new_block();\n-            self.cfg.terminate(block,\n-                               scope_id,\n-                               guard_span,\n+            self.cfg.terminate(block, source_info,\n                                TerminatorKind::If { cond: cond,\n                                                     targets: (arm_block, otherwise)});\n             Some(otherwise)\n         } else {\n-            self.cfg.terminate(block,\n-                               scope_id,\n-                               candidate.span,\n+            let source_info = self.source_info(candidate.span);\n+            self.cfg.terminate(block, source_info,\n                                TerminatorKind::Goto { target: arm_block });\n             None\n         }\n@@ -628,35 +610,33 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                     Rvalue::Ref(region, borrow_kind, binding.source),\n             };\n \n-            let scope_id = self.innermost_scope_id();\n-            self.cfg.push_assign(block, scope_id, binding.span,\n+            let source_info = self.source_info(binding.span);\n+            self.cfg.push_assign(block, source_info,\n                                  &Lvalue::Var(var_index), rvalue);\n         }\n     }\n \n     fn declare_binding(&mut self,\n-                       var_scope_id: ScopeId,\n+                       source_info: SourceInfo,\n                        mutability: Mutability,\n                        name: Name,\n                        var_id: NodeId,\n-                       var_ty: Ty<'tcx>,\n-                       span: Span)\n+                       var_ty: Ty<'tcx>)\n                        -> u32\n     {\n-        debug!(\"declare_binding(var_id={:?}, name={:?}, var_ty={:?}, var_scope_id={:?}, span={:?})\",\n-               var_id, name, var_ty, var_scope_id, span);\n+        debug!(\"declare_binding(var_id={:?}, name={:?}, var_ty={:?}, source_info={:?})\",\n+               var_id, name, var_ty, source_info);\n \n         let index = self.var_decls.len();\n         self.var_decls.push(VarDecl::<'tcx> {\n-            scope: var_scope_id,\n+            source_info: source_info,\n             mutability: mutability,\n             name: name,\n             ty: var_ty.clone(),\n-            span: span,\n         });\n         let index = index as u32;\n-        let extent = self.scope_auxiliary[var_scope_id].extent;\n-        self.schedule_drop(span, extent, &Lvalue::Var(index), var_ty);\n+        let extent = self.extent_of_innermost_scope();\n+        self.schedule_drop(source_info.span, extent, &Lvalue::Var(index), var_ty);\n         self.var_indices.insert(var_id, index);\n \n         debug!(\"declare_binding: index={:?}\", index);"}, {"sha": "1f0c4bd9e0dd6e911ead8a22302a6f2bf46d893b", "filename": "src/librustc_mir/build/matches/test.rs", "status": "modified", "additions": 14, "deletions": 20, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/0d531bfb881e6d303d09de9f212eaac72a9a218d/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d531bfb881e6d303d09de9f212eaac72a9a218d/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Ftest.rs?ref=0d531bfb881e6d303d09de9f212eaac72a9a218d", "patch": "@@ -176,7 +176,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                         lvalue: &Lvalue<'tcx>,\n                         test: &Test<'tcx>)\n                         -> Vec<BasicBlock> {\n-        let scope_id = self.innermost_scope_id();\n+        let source_info = self.source_info(test.span);\n         match test.kind {\n             TestKind::Switch { adt_def, ref variants } => {\n                 let num_enum_variants = self.hir.num_variants(adt_def);\n@@ -193,7 +193,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                 }).collect();\n                 debug!(\"num_enum_variants: {}, num tested variants: {}, variants: {:?}\",\n                        num_enum_variants, variants.iter().count(), variants);\n-                self.cfg.terminate(block, scope_id, test.span, TerminatorKind::Switch {\n+                self.cfg.terminate(block, source_info, TerminatorKind::Switch {\n                     discr: lvalue.clone(),\n                     adt_def: adt_def,\n                     targets: target_blocks.clone()\n@@ -245,10 +245,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                     }\n                 };\n \n-                self.cfg.terminate(block,\n-                                   scope_id,\n-                                   test.span,\n-                                   term);\n+                self.cfg.terminate(block, source_info, term);\n                 targets\n             }\n \n@@ -265,7 +262,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                         if let ty::TyArray(_, _) = mt.ty.sty {\n                             ty = tcx.mk_imm_ref(region, tcx.mk_slice(tcx.types.u8));\n                             let val_slice = self.temp(ty);\n-                            self.cfg.push_assign(block, scope_id, test.span, &val_slice,\n+                            self.cfg.push_assign(block, source_info, &val_slice,\n                                                  Rvalue::Cast(CastKind::Unsize, val, ty));\n                             val = Operand::Consume(val_slice);\n                         }\n@@ -280,7 +277,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                     });\n \n                     let slice = self.temp(ty);\n-                    self.cfg.push_assign(block, scope_id, test.span, &slice,\n+                    self.cfg.push_assign(block, source_info, &slice,\n                                          Rvalue::Cast(CastKind::Unsize, array, ty));\n                     Operand::Consume(slice)\n                 } else {\n@@ -301,7 +298,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                     let eq_result = self.temp(bool_ty);\n                     let eq_block = self.cfg.start_new_block();\n                     let cleanup = self.diverge_cleanup();\n-                    self.cfg.terminate(block, scope_id, test.span, TerminatorKind::Call {\n+                    self.cfg.terminate(block, source_info, TerminatorKind::Call {\n                         func: Operand::Constant(Constant {\n                             span: test.span,\n                             ty: mty,\n@@ -314,7 +311,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n \n                     // check the result\n                     let block = self.cfg.start_new_block();\n-                    self.cfg.terminate(eq_block, scope_id, test.span, TerminatorKind::If {\n+                    self.cfg.terminate(eq_block, source_info, TerminatorKind::If {\n                         cond: Operand::Consume(eq_result),\n                         targets: (block, fail),\n                     });\n@@ -344,25 +341,22 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                 let (actual, result) = (self.temp(usize_ty), self.temp(bool_ty));\n \n                 // actual = len(lvalue)\n-                self.cfg.push_assign(block, scope_id, test.span,\n+                self.cfg.push_assign(block, source_info,\n                                      &actual, Rvalue::Len(lvalue.clone()));\n \n                 // expected = <N>\n-                let expected = self.push_usize(block, scope_id, test.span, len);\n+                let expected = self.push_usize(block, source_info, len);\n \n                 // result = actual == expected OR result = actual < expected\n-                self.cfg.push_assign(block,\n-                                     scope_id,\n-                                     test.span,\n-                                     &result,\n+                self.cfg.push_assign(block, source_info, &result,\n                                      Rvalue::BinaryOp(op,\n                                                       Operand::Consume(actual),\n                                                       Operand::Consume(expected)));\n \n                 // branch based on result\n                 let target_blocks: Vec<_> = vec![self.cfg.start_new_block(),\n                                                  self.cfg.start_new_block()];\n-                self.cfg.terminate(block, scope_id, test.span, TerminatorKind::If {\n+                self.cfg.terminate(block, source_info, TerminatorKind::If {\n                     cond: Operand::Consume(result),\n                     targets: (target_blocks[0], target_blocks[1])\n                 });\n@@ -383,13 +377,13 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n         let result = self.temp(bool_ty);\n \n         // result = op(left, right)\n-        let scope_id = self.innermost_scope_id();\n-        self.cfg.push_assign(block, scope_id, span, &result,\n+        let source_info = self.source_info(span);\n+        self.cfg.push_assign(block, source_info, &result,\n                              Rvalue::BinaryOp(op, left, right));\n \n         // branch based on result\n         let target_block = self.cfg.start_new_block();\n-        self.cfg.terminate(block, scope_id, span, TerminatorKind::If {\n+        self.cfg.terminate(block, source_info, TerminatorKind::If {\n             cond: Operand::Consume(result),\n             targets: (target_block, fail_block)\n         });"}, {"sha": "2e9cc96c046817d2a4f4fbd6330f3cc243c21926", "filename": "src/librustc_mir/build/matches/util.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0d531bfb881e6d303d09de9f212eaac72a9a218d/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d531bfb881e6d303d09de9f212eaac72a9a218d/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Futil.rs?ref=0d531bfb881e6d303d09de9f212eaac72a9a218d", "patch": "@@ -65,8 +65,8 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                 from_end: suffix_len,\n             };\n             let temp = self.temp(slice.ty.clone()); // no need to schedule drop, temp is always copy\n-            let scope_id = self.innermost_scope_id();\n-            self.cfg.push_assign(block, scope_id, slice.span, &temp, rvalue);\n+            let source_info = self.source_info(slice.span);\n+            self.cfg.push_assign(block, source_info, &temp, rvalue);\n             match_pairs.push(MatchPair::new(temp, slice));\n         }\n "}, {"sha": "a9d5c0c4f85c39314b86d0ff985b589b745f42a1", "filename": "src/librustc_mir/build/misc.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/0d531bfb881e6d303d09de9f212eaac72a9a218d/src%2Flibrustc_mir%2Fbuild%2Fmisc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d531bfb881e6d303d09de9f212eaac72a9a218d/src%2Flibrustc_mir%2Fbuild%2Fmisc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmisc.rs?ref=0d531bfb881e6d303d09de9f212eaac72a9a218d", "patch": "@@ -103,16 +103,15 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n \n     pub fn push_usize(&mut self,\n                       block: BasicBlock,\n-                      scope_id: ScopeId,\n-                      span: Span,\n+                      source_info: SourceInfo,\n                       value: u64)\n                       -> Lvalue<'tcx> {\n         let usize_ty = self.hir.usize_ty();\n         let temp = self.temp(usize_ty);\n         self.cfg.push_assign_constant(\n-            block, scope_id, span, &temp,\n+            block, source_info, &temp,\n             Constant {\n-                span: span,\n+                span: source_info.span,\n                 ty: self.hir.usize_ty(),\n                 literal: self.hir.usize_literal(value),\n             });"}, {"sha": "9c1b9fa4437e01110826ea8e525f42c509f9b673", "filename": "src/librustc_mir/build/mod.rs", "status": "modified", "additions": 41, "deletions": 19, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/0d531bfb881e6d303d09de9f212eaac72a9a218d/src%2Flibrustc_mir%2Fbuild%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d531bfb881e6d303d09de9f212eaac72a9a218d/src%2Flibrustc_mir%2Fbuild%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmod.rs?ref=0d531bfb881e6d303d09de9f212eaac72a9a218d", "patch": "@@ -15,6 +15,7 @@ use rustc::mir::repr::*;\n use rustc_data_structures::fnv::FnvHashMap;\n use rustc::hir;\n use std::ops::{Index, IndexMut};\n+use std::u32;\n use syntax::abi::Abi;\n use syntax::ast;\n use syntax::codemap::Span;\n@@ -43,7 +44,8 @@ pub struct Builder<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n \n     /// the vector of all scopes that we have created thus far;\n     /// we track this for debuginfo later\n-    scope_datas: Vec<ScopeData>,\n+    visibility_scopes: Vec<VisibilityScopeData>,\n+    visibility_scope: VisibilityScope,\n \n     var_decls: Vec<VarDecl<'tcx>>,\n     var_indices: FnvHashMap<ast::NodeId, u32>,\n@@ -61,6 +63,20 @@ struct CFG<'tcx> {\n     basic_blocks: Vec<BasicBlockData<'tcx>>,\n }\n \n+#[derive(Copy, Clone, Debug, PartialEq, Eq)]\n+pub struct ScopeId(u32);\n+\n+impl ScopeId {\n+    pub fn new(index: usize) -> ScopeId {\n+        assert!(index < (u32::MAX as usize));\n+        ScopeId(index as u32)\n+    }\n+\n+    pub fn index(self) -> usize {\n+        self.0 as usize\n+    }\n+}\n+\n /// For each scope, we track the extent (from the HIR) and a\n /// single-entry-multiple-exit subgraph that contains all the\n /// statements/terminators within it.\n@@ -179,17 +195,16 @@ pub fn construct_fn<'a, 'gcx, 'tcx, A>(hir: Cx<'a, 'gcx, 'tcx>,\n         tcx.region_maps.lookup_code_extent(\n             CodeExtentData::ParameterScope { fn_id: fn_id, body_id: body_id });\n     let mut block = START_BLOCK;\n-    let mut arg_decls = unpack!(block = builder.in_scope(call_site_extent, block,\n-                                                         |builder, call_site_scope_id| {\n-        let arg_decls = unpack!(block = builder.in_scope(arg_extent, block,\n-                                                         |builder, arg_scope_id| {\n-            builder.args_and_body(block, return_ty, arguments, arg_scope_id, ast_block)\n+    let mut arg_decls = unpack!(block = builder.in_scope(call_site_extent, block, |builder| {\n+        let arg_decls = unpack!(block = builder.in_scope(arg_extent, block, |builder| {\n+            builder.args_and_body(block, return_ty, arguments, arg_extent, ast_block)\n         }));\n \n+        let source_info = builder.source_info(span);\n         let return_block = builder.return_block();\n-        builder.cfg.terminate(block, call_site_scope_id, span,\n+        builder.cfg.terminate(block, source_info,\n                               TerminatorKind::Goto { target: return_block });\n-        builder.cfg.terminate(return_block, call_site_scope_id, span,\n+        builder.cfg.terminate(return_block, source_info,\n                               TerminatorKind::Return);\n         return_block.and(arg_decls)\n     }));\n@@ -241,14 +256,15 @@ pub fn construct_const<'a, 'gcx, 'tcx>(hir: Cx<'a, 'gcx, 'tcx>,\n \n     let extent = ROOT_CODE_EXTENT;\n     let mut block = START_BLOCK;\n-    let _ = builder.in_scope(extent, block, |builder, call_site_scope_id| {\n+    let _ = builder.in_scope(extent, block, |builder| {\n         let expr = builder.hir.mirror(ast_expr);\n         unpack!(block = builder.into(&Lvalue::ReturnPointer, block, expr));\n \n+        let source_info = builder.source_info(span);\n         let return_block = builder.return_block();\n-        builder.cfg.terminate(block, call_site_scope_id, span,\n+        builder.cfg.terminate(block, source_info,\n                               TerminatorKind::Goto { target: return_block });\n-        builder.cfg.terminate(return_block, call_site_scope_id, span,\n+        builder.cfg.terminate(return_block, source_info,\n                               TerminatorKind::Return);\n \n         return_block.unit()\n@@ -265,7 +281,8 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n             cfg: CFG { basic_blocks: vec![] },\n             fn_span: span,\n             scopes: vec![],\n-            scope_datas: vec![],\n+            visibility_scopes: vec![],\n+            visibility_scope: ARGUMENT_VISIBILITY_SCOPE,\n             scope_auxiliary: ScopeAuxiliaryVec { vec: vec![] },\n             loop_scopes: vec![],\n             temp_decls: vec![],\n@@ -277,6 +294,8 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n         };\n \n         assert_eq!(builder.cfg.start_new_block(), START_BLOCK);\n+        assert_eq!(builder.new_visibility_scope(span), ARGUMENT_VISIBILITY_SCOPE);\n+        builder.visibility_scopes[ARGUMENT_VISIBILITY_SCOPE].parent_scope = None;\n \n         builder\n     }\n@@ -294,7 +313,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n \n         (Mir {\n             basic_blocks: self.cfg.basic_blocks,\n-            scopes: self.scope_datas,\n+            visibility_scopes: self.visibility_scopes,\n             promoted: vec![],\n             var_decls: self.var_decls,\n             arg_decls: arg_decls,\n@@ -309,24 +328,22 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                         mut block: BasicBlock,\n                         return_ty: ty::FnOutput<'tcx>,\n                         arguments: A,\n-                        argument_scope_id: ScopeId,\n+                        argument_extent: CodeExtent,\n                         ast_block: &'gcx hir::Block)\n                         -> BlockAnd<Vec<ArgDecl<'tcx>>>\n         where A: Iterator<Item=(Ty<'gcx>, Option<&'gcx hir::Pat>)>\n     {\n         // to start, translate the argument patterns and collect the argument types.\n+        let mut scope = None;\n         let arg_decls = arguments.enumerate().map(|(index, (ty, pattern))| {\n             let lvalue = Lvalue::Arg(index as u32);\n             if let Some(pattern) = pattern {\n                 let pattern = self.hir.irrefutable_pat(pattern);\n-                unpack!(block = self.lvalue_into_pattern(block,\n-                                                         argument_scope_id,\n-                                                         pattern,\n-                                                         &lvalue));\n+                scope = self.declare_bindings(scope, ast_block.span, &pattern);\n+                unpack!(block = self.lvalue_into_pattern(block, pattern, &lvalue));\n             }\n \n             // Make sure we drop (parts of) the argument even when not matched on.\n-            let argument_extent = self.scope_auxiliary[argument_scope_id].extent;\n             self.schedule_drop(pattern.as_ref().map_or(ast_block.span, |pat| pat.span),\n                                argument_extent, &lvalue, ty);\n \n@@ -344,6 +361,11 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n             }\n         }).collect();\n \n+        // Enter the argument pattern bindings visibility scope, if it exists.\n+        if let Some(visibility_scope) = scope {\n+            self.visibility_scope = visibility_scope;\n+        }\n+\n         // FIXME(#32959): temporary hack for the issue at hand\n         let return_is_unit = if let ty::FnConverging(t) = return_ty {\n             t.is_nil()"}, {"sha": "2b7efa52cbd054c8131dfaed4e997e751aa8642f", "filename": "src/librustc_mir/build/scope.rs", "status": "modified", "additions": 61, "deletions": 41, "changes": 102, "blob_url": "https://github.com/rust-lang/rust/blob/0d531bfb881e6d303d09de9f212eaac72a9a218d/src%2Flibrustc_mir%2Fbuild%2Fscope.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d531bfb881e6d303d09de9f212eaac72a9a218d/src%2Flibrustc_mir%2Fbuild%2Fscope.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fscope.rs?ref=0d531bfb881e6d303d09de9f212eaac72a9a218d", "patch": "@@ -86,7 +86,7 @@ should go to.\n \n */\n \n-use build::{BlockAnd, BlockAndExtension, Builder, CFG, ScopeAuxiliary};\n+use build::{BlockAnd, BlockAndExtension, Builder, CFG, ScopeAuxiliary, ScopeId};\n use rustc::middle::region::{CodeExtent, CodeExtentData};\n use rustc::middle::lang_items;\n use rustc::ty::subst::{Substs, Subst, VecPerParamSpace};\n@@ -98,9 +98,12 @@ use rustc::middle::const_val::ConstVal;\n use rustc_const_math::ConstInt;\n \n pub struct Scope<'tcx> {\n-    /// the scope-id within the scope_datas\n+    /// the scope-id within the scope_auxiliary\n     id: ScopeId,\n \n+    /// The visibility scope this scope was created in.\n+    visibility_scope: VisibilityScope,\n+\n     /// the extent of this scope within source code; also stored in\n     /// `ScopeAuxiliary`, but kept here for convenience\n     extent: CodeExtent,\n@@ -204,6 +207,14 @@ impl<'tcx> Scope<'tcx> {\n             None\n         }\n     }\n+\n+    /// Given a span and this scope's visibility scope, make a SourceInfo.\n+    fn source_info(&self, span: Span) -> SourceInfo {\n+        SourceInfo {\n+            span: span,\n+            scope: self.visibility_scope\n+        }\n+    }\n }\n \n impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n@@ -237,11 +248,11 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n     /// Convenience wrapper that pushes a scope and then executes `f`\n     /// to build its contents, popping the scope afterwards.\n     pub fn in_scope<F, R>(&mut self, extent: CodeExtent, mut block: BasicBlock, f: F) -> BlockAnd<R>\n-        where F: FnOnce(&mut Builder<'a, 'gcx, 'tcx>, ScopeId) -> BlockAnd<R>\n+        where F: FnOnce(&mut Builder<'a, 'gcx, 'tcx>) -> BlockAnd<R>\n     {\n         debug!(\"in_scope(extent={:?}, block={:?})\", extent, block);\n-        let id = self.push_scope(extent, block);\n-        let rv = unpack!(block = f(self, id));\n+        self.push_scope(extent, block);\n+        let rv = unpack!(block = f(self));\n         unpack!(block = self.pop_scope(extent, block));\n         debug!(\"in_scope: exiting extent={:?} block={:?}\", extent, block);\n         block.and(rv)\n@@ -251,17 +262,13 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n     /// scope and call `pop_scope` afterwards. Note that these two\n     /// calls must be paired; using `in_scope` as a convenience\n     /// wrapper maybe preferable.\n-    pub fn push_scope(&mut self, extent: CodeExtent, entry: BasicBlock) -> ScopeId {\n+    pub fn push_scope(&mut self, extent: CodeExtent, entry: BasicBlock) {\n         debug!(\"push_scope({:?})\", extent);\n-        let parent_id = self.scopes.last().map(|s| s.id);\n-        let id = ScopeId::new(self.scope_datas.len());\n-        let tcx = self.hir.tcx();\n-        self.scope_datas.push(ScopeData {\n-            span: extent.span(&tcx.region_maps, &tcx.map).unwrap_or(DUMMY_SP),\n-            parent_scope: parent_id,\n-        });\n+        let id = ScopeId::new(self.scope_auxiliary.vec.len());\n+        let vis_scope = self.visibility_scope;\n         self.scopes.push(Scope {\n             id: id,\n+            visibility_scope: vis_scope,\n             extent: extent,\n             drops: vec![],\n             free: None,\n@@ -272,7 +279,6 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n             dom: self.cfg.current_location(entry),\n             postdoms: vec![]\n         });\n-        id\n     }\n \n     /// Pops a scope, which should have extent `extent`, adding any\n@@ -320,7 +326,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n             if let Some(ref free_data) = scope.free {\n                 let next = self.cfg.start_new_block();\n                 let free = build_free(self.hir.tcx(), &tmp, free_data, next);\n-                self.cfg.terminate(block, scope.id, span, free);\n+                self.cfg.terminate(block, scope.source_info(span), free);\n                 block = next;\n             }\n             self.scope_auxiliary[scope.id]\n@@ -334,11 +340,21 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                                             .next()\n                                             .unwrap();\n         self.cfg.terminate(block,\n-                           scope.id,\n-                           span,\n+                           scope.source_info(span),\n                            TerminatorKind::Goto { target: target });\n     }\n \n+    /// Creates a new visibility scope, nested in the current one.\n+    pub fn new_visibility_scope(&mut self, span: Span) -> VisibilityScope {\n+        let parent = self.visibility_scope;\n+        let scope = VisibilityScope::new(self.visibility_scopes.len());\n+        self.visibility_scopes.push(VisibilityScopeData {\n+            span: span,\n+            parent_scope: Some(parent),\n+        });\n+        scope\n+    }\n+\n     // Finding scopes\n     // ==============\n     /// Finds the loop scope for a given label. This is used for\n@@ -363,8 +379,12 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n         }.unwrap_or_else(|| span_bug!(span, \"no enclosing loop scope found?\"))\n     }\n \n-    pub fn innermost_scope_id(&self) -> ScopeId {\n-        self.scopes.last().map(|scope| scope.id).unwrap()\n+    /// Given a span and the current visibility scope, make a SourceInfo.\n+    pub fn source_info(&self, span: Span) -> SourceInfo {\n+        SourceInfo {\n+            span: span,\n+            scope: self.visibility_scope\n+        }\n     }\n \n     pub fn extent_of_innermost_scope(&self) -> CodeExtent {\n@@ -481,7 +501,9 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n             target\n         } else {\n             let resumeblk = cfg.start_new_cleanup_block();\n-            cfg.terminate(resumeblk, scopes[0].id, self.fn_span, TerminatorKind::Resume);\n+            cfg.terminate(resumeblk,\n+                          scopes[0].source_info(self.fn_span),\n+                          TerminatorKind::Resume);\n             *cached_resume_block = Some(resumeblk);\n             resumeblk\n         };\n@@ -502,12 +524,10 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n         if !self.hir.needs_drop(ty) {\n             return block.unit();\n         }\n-        let scope_id = self.innermost_scope_id();\n+        let source_info = self.source_info(span);\n         let next_target = self.cfg.start_new_block();\n         let diverge_target = self.diverge_cleanup();\n-        self.cfg.terminate(block,\n-                           scope_id,\n-                           span,\n+        self.cfg.terminate(block, source_info,\n                            TerminatorKind::Drop {\n                                location: location,\n                                target: next_target,\n@@ -522,12 +542,10 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                                   span: Span,\n                                   location: Lvalue<'tcx>,\n                                   value: Operand<'tcx>) -> BlockAnd<()> {\n-        let scope_id = self.innermost_scope_id();\n+        let source_info = self.source_info(span);\n         let next_target = self.cfg.start_new_block();\n         let diverge_target = self.diverge_cleanup();\n-        self.cfg.terminate(block,\n-                           scope_id,\n-                           span,\n+        self.cfg.terminate(block, source_info,\n                            TerminatorKind::DropAndReplace {\n                                location: location,\n                                value: value,\n@@ -562,18 +580,18 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n         let elems = vec![Operand::Constant(message),\n                          Operand::Constant(file),\n                          Operand::Constant(line)];\n-        let scope_id = self.innermost_scope_id();\n+        let source_info = self.source_info(span);\n         // FIXME: We should have this as a constant, rather than a stack variable (to not pollute\n         // icache with cold branch code), however to achieve that we either have to rely on rvalue\n         // promotion or have some way, in MIR, to create constants.\n-        self.cfg.push_assign(block, scope_id, span, &tuple, // [1]\n+        self.cfg.push_assign(block, source_info, &tuple, // [1]\n                              Rvalue::Aggregate(AggregateKind::Tuple, elems));\n         // [1] tuple = (message_arg, file_arg, line_arg);\n         // FIXME: is this region really correct here?\n-        self.cfg.push_assign(block, scope_id, span, &tuple_ref, // tuple_ref = &tuple;\n+        self.cfg.push_assign(block, source_info, &tuple_ref, // tuple_ref = &tuple;\n                              Rvalue::Ref(region, BorrowKind::Shared, tuple));\n         let cleanup = self.diverge_cleanup();\n-        self.cfg.terminate(block, scope_id, span, TerminatorKind::Call {\n+        self.cfg.terminate(block, source_info, TerminatorKind::Call {\n             func: Operand::Constant(func),\n             args: vec![Operand::Consume(tuple_ref)],\n             cleanup: cleanup,\n@@ -590,12 +608,12 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                   msg: AssertMessage<'tcx>,\n                   span: Span)\n                   -> BasicBlock {\n-        let scope_id = self.innermost_scope_id();\n+        let source_info = self.source_info(span);\n \n         let success_block = self.cfg.start_new_block();\n         let cleanup = self.diverge_cleanup();\n \n-        self.cfg.terminate(block, scope_id, span,\n+        self.cfg.terminate(block, source_info,\n                            TerminatorKind::Assert {\n                                cond: cond,\n                                expected: expected,\n@@ -658,7 +676,7 @@ fn build_scope_drops<'tcx>(cfg: &mut CFG<'tcx>,\n             earlier_scopes.iter().rev().flat_map(|s| s.cached_block()).next()\n         });\n         let next = cfg.start_new_block();\n-        cfg.terminate(block, scope.id, drop_data.span, TerminatorKind::Drop {\n+        cfg.terminate(block, scope.source_info(drop_data.span), TerminatorKind::Drop {\n             location: drop_data.location.clone(),\n             target: next,\n             unwind: on_diverge\n@@ -688,15 +706,19 @@ fn build_diverge_scope<'a, 'gcx, 'tcx>(tcx: TyCtxt<'a, 'gcx, 'tcx>,\n     // remainder. If everything is cached, we'll just walk right to\n     // left reading the cached results but never created anything.\n \n+    let visibility_scope = scope.visibility_scope;\n+    let source_info = |span| SourceInfo {\n+        span: span,\n+        scope: visibility_scope\n+    };\n+\n     // Next, build up any free.\n     if let Some(ref mut free_data) = scope.free {\n         target = if let Some(cached_block) = free_data.cached_block {\n             cached_block\n         } else {\n             let into = cfg.start_new_cleanup_block();\n-            cfg.terminate(into,\n-                          scope.id,\n-                          free_data.span,\n+            cfg.terminate(into, source_info(free_data.span),\n                           build_free(tcx, unit_temp, free_data, target));\n             free_data.cached_block = Some(into);\n             into\n@@ -711,9 +733,7 @@ fn build_diverge_scope<'a, 'gcx, 'tcx>(tcx: TyCtxt<'a, 'gcx, 'tcx>,\n             cached_block\n         } else {\n             let block = cfg.start_new_cleanup_block();\n-            cfg.terminate(block,\n-                          scope.id,\n-                          drop_data.span,\n+            cfg.terminate(block, source_info(drop_data.span),\n                           TerminatorKind::Drop {\n                               location: drop_data.location.clone(),\n                               target: target,"}, {"sha": "8c21928c2513b9869f2f2195526c4d729cec9c4b", "filename": "src/librustc_mir/pretty.rs", "status": "modified", "additions": 59, "deletions": 82, "changes": 141, "blob_url": "https://github.com/rust-lang/rust/blob/0d531bfb881e6d303d09de9f212eaac72a9a218d/src%2Flibrustc_mir%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d531bfb881e6d303d09de9f212eaac72a9a218d/src%2Flibrustc_mir%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fpretty.rs?ref=0d531bfb881e6d303d09de9f212eaac72a9a218d", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use build::{Location, ScopeAuxiliaryVec};\n+use build::{Location, ScopeAuxiliaryVec, ScopeId};\n use rustc::hir;\n use rustc::mir::repr::*;\n use rustc::mir::transform::MirSource;\n@@ -18,7 +18,6 @@ use std::fmt::Display;\n use std::fs;\n use std::io::{self, Write};\n use syntax::ast::NodeId;\n-use syntax::codemap::Span;\n \n const INDENT: &'static str = \"    \";\n /// Alignment for lining up comments following MIR statements\n@@ -139,20 +138,11 @@ pub fn write_mir_fn<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     write_mir_intro(tcx, src, mir, w)?;\n     for block in mir.all_basic_blocks() {\n         write_basic_block(tcx, block, mir, w, &annotations)?;\n+        if block.index() + 1 != mir.basic_blocks.len() {\n+            writeln!(w, \"\")?;\n+        }\n     }\n \n-    // construct a scope tree and write it out\n-    let mut scope_tree: FnvHashMap<Option<ScopeId>, Vec<ScopeId>> = FnvHashMap();\n-    for (index, scope_data) in mir.scopes.iter().enumerate() {\n-        scope_tree.entry(scope_data.parent_scope)\n-                  .or_insert(vec![])\n-                  .push(ScopeId::new(index));\n-    }\n-\n-    writeln!(w, \"{}scope tree:\", INDENT)?;\n-    write_scope_tree(tcx, mir, auxiliary, &scope_tree, w, None, 1, false)?;\n-    writeln!(w, \"\")?;\n-\n     writeln!(w, \"}}\")?;\n     Ok(())\n }\n@@ -189,7 +179,7 @@ fn write_basic_block(tcx: TyCtxt,\n         writeln!(w, \"{0:1$} // {2}\",\n                  indented_mir,\n                  ALIGN,\n-                 comment(tcx, statement.scope, statement.span))?;\n+                 comment(tcx, statement.source_info))?;\n \n         current_location.statement_index += 1;\n     }\n@@ -199,71 +189,64 @@ fn write_basic_block(tcx: TyCtxt,\n     writeln!(w, \"{0:1$} // {2}\",\n              indented_terminator,\n              ALIGN,\n-             comment(tcx, data.terminator().scope, data.terminator().span))?;\n+             comment(tcx, data.terminator().source_info))?;\n \n     writeln!(w, \"{}}}\\n\", INDENT)\n }\n \n-fn comment(tcx: TyCtxt, scope: ScopeId, span: Span) -> String {\n+fn comment(tcx: TyCtxt, SourceInfo { span, scope }: SourceInfo) -> String {\n     format!(\"scope {} at {}\", scope.index(), tcx.sess.codemap().span_to_string(span))\n }\n \n fn write_scope_tree(tcx: TyCtxt,\n                     mir: &Mir,\n-                    auxiliary: Option<&ScopeAuxiliaryVec>,\n-                    scope_tree: &FnvHashMap<Option<ScopeId>, Vec<ScopeId>>,\n+                    scope_tree: &FnvHashMap<VisibilityScope, Vec<VisibilityScope>>,\n                     w: &mut Write,\n-                    parent: Option<ScopeId>,\n-                    depth: usize,\n-                    same_line: bool)\n+                    parent: VisibilityScope,\n+                    depth: usize)\n                     -> io::Result<()> {\n-    let indent = if same_line {\n-        0\n-    } else {\n-        depth * INDENT.len()\n-    };\n+    let indent = depth * INDENT.len();\n \n     let children = match scope_tree.get(&parent) {\n         Some(childs) => childs,\n         None => return Ok(()),\n     };\n \n-    for (index, &child) in children.iter().enumerate() {\n-        if index == 0 && same_line {\n-            // We know we're going to output a scope, so prefix it with a space to separate it from\n-            // the previous scopes on this line\n-            write!(w, \" \")?;\n-        }\n-\n-        let data = &mir.scopes[child];\n-        assert_eq!(data.parent_scope, parent);\n-        write!(w, \"{0:1$}{2}\", \"\", indent, child.index())?;\n+    for &child in children {\n+        let data = &mir.visibility_scopes[child];\n+        assert_eq!(data.parent_scope, Some(parent));\n+        writeln!(w, \"{0:1$}scope {2} {{\", \"\", indent, child.index())?;\n \n-        let indent = indent + INDENT.len();\n+        // User variable types (including the user's name in a comment).\n+        for (i, var) in mir.var_decls.iter().enumerate() {\n+            // Skip if not declared in this scope.\n+            if var.source_info.scope != child {\n+                continue;\n+            }\n \n-        if let Some(auxiliary) = auxiliary {\n-            let extent = auxiliary[child].extent;\n-            let data = tcx.region_maps.code_extent_data(extent);\n-            writeln!(w, \"{0:1$}Extent: {2:?}\", \"\", indent, data)?;\n+            let mut_str = if var.mutability == Mutability::Mut {\n+                \"mut \"\n+            } else {\n+                \"\"\n+            };\n+\n+            let indent = indent + INDENT.len();\n+            let indented_var = format!(\"{0:1$}let {2}{3:?}: {4};\",\n+                                       INDENT,\n+                                       indent,\n+                                       mut_str,\n+                                       Lvalue::Var(i as u32),\n+                                       var.ty);\n+            writeln!(w, \"{0:1$} // \\\"{2}\\\" in {3}\",\n+                     indented_var,\n+                     ALIGN,\n+                     var.name,\n+                     comment(tcx, var.source_info))?;\n         }\n \n-        let child_count = scope_tree.get(&Some(child)).map(Vec::len).unwrap_or(0);\n-        if child_count < 2 {\n-            // Skip the braces when there's no or only a single subscope\n-            write_scope_tree(tcx, mir, auxiliary, scope_tree, w,\n-                             Some(child), depth, true)?;\n-        } else {\n-            // 2 or more child scopes? Put them in braces and on new lines.\n-            writeln!(w, \" {{\")?;\n-            write_scope_tree(tcx, mir, auxiliary, scope_tree, w,\n-                             Some(child), depth + 1, false)?;\n-\n-            write!(w, \"\\n{0:1$}}}\", \"\", depth * INDENT.len())?;\n-        }\n+        write_scope_tree(tcx, mir, scope_tree, w, child, depth + 1)?;\n \n-        if !same_line && index + 1 < children.len() {\n-            writeln!(w, \"\")?;\n-        }\n+        writeln!(w, \"{0:1$}}}\", \"\", depth * INDENT.len())?;\n     }\n \n     Ok(())\n@@ -278,7 +261,23 @@ fn write_mir_intro<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                              -> io::Result<()> {\n     write_mir_sig(tcx, src, mir, w)?;\n     writeln!(w, \" {{\")?;\n-    write_mir_decls(tcx, mir, w)\n+\n+    // construct a scope tree and write it out\n+    let mut scope_tree: FnvHashMap<VisibilityScope, Vec<VisibilityScope>> = FnvHashMap();\n+    for (index, scope_data) in mir.visibility_scopes.iter().enumerate() {\n+        if let Some(parent) = scope_data.parent_scope {\n+            scope_tree.entry(parent)\n+                      .or_insert(vec![])\n+                      .push(VisibilityScope::new(index));\n+        } else {\n+            // Only the argument scope has no parent, because it's the root.\n+            assert_eq!(index, ARGUMENT_VISIBILITY_SCOPE.index());\n+        }\n+    }\n+\n+    write_scope_tree(tcx, mir, &scope_tree, w, ARGUMENT_VISIBILITY_SCOPE, 1)?;\n+\n+    write_mir_decls(mir, w)\n }\n \n fn write_mir_sig(tcx: TyCtxt, src: MirSource, mir: &Mir, w: &mut Write)\n@@ -318,29 +317,7 @@ fn write_mir_sig(tcx: TyCtxt, src: MirSource, mir: &Mir, w: &mut Write)\n     }\n }\n \n-fn write_mir_decls(tcx: TyCtxt, mir: &Mir, w: &mut Write)\n-                   -> io::Result<()>\n-{\n-    // User variable types (including the user's name in a comment).\n-    for (i, var) in mir.var_decls.iter().enumerate() {\n-        let mut_str = if var.mutability == Mutability::Mut {\n-            \"mut \"\n-        } else {\n-            \"\"\n-        };\n-\n-        let indented_var = format!(\"{}let {}{:?}: {};\",\n-                                   INDENT,\n-                                   mut_str,\n-                                   Lvalue::Var(i as u32),\n-                                   var.ty);\n-        writeln!(w, \"{0:1$} // \\\"{2}\\\" in {3}\",\n-                 indented_var,\n-                 ALIGN,\n-                 var.name,\n-                 comment(tcx, var.scope, var.span))?;\n-    }\n-\n+fn write_mir_decls(mir: &Mir, w: &mut Write) -> io::Result<()> {\n     // Compiler-introduced temporary types.\n     for (i, temp) in mir.temp_decls.iter().enumerate() {\n         writeln!(w, \"{}let mut {:?}: {};\", INDENT, Lvalue::Temp(i as u32), temp.ty)?;"}, {"sha": "a90d8e93a50e627069727fd296ff1eaa5f0efe6a", "filename": "src/librustc_mir/transform/add_call_guards.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/0d531bfb881e6d303d09de9f212eaac72a9a218d/src%2Flibrustc_mir%2Ftransform%2Fadd_call_guards.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d531bfb881e6d303d09de9f212eaac72a9a218d/src%2Flibrustc_mir%2Ftransform%2Fadd_call_guards.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fadd_call_guards.rs?ref=0d531bfb881e6d303d09de9f212eaac72a9a218d", "patch": "@@ -66,15 +66,14 @@ impl<'tcx> MirPass<'tcx> for AddCallGuards {\n                         destination: Some((_, ref mut destination)),\n                         cleanup: Some(_),\n                         ..\n-                    }, span, scope\n+                    }, source_info\n                 }) if pred_count[destination.index()] > 1 => {\n                     // It's a critical edge, break it\n                     let call_guard = BasicBlockData {\n                         statements: vec![],\n                         is_cleanup: data.is_cleanup,\n                         terminator: Some(Terminator {\n-                            span: span,\n-                            scope: scope,\n+                            source_info: source_info,\n                             kind: TerminatorKind::Goto { target: *destination }\n                         })\n                     };"}, {"sha": "c9c574966c767f01703ec3602ff81ae0dcabe2c1", "filename": "src/librustc_mir/transform/promote_consts.rs", "status": "modified", "additions": 23, "deletions": 21, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/0d531bfb881e6d303d09de9f212eaac72a9a218d/src%2Flibrustc_mir%2Ftransform%2Fpromote_consts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d531bfb881e6d303d09de9f212eaac72a9a218d/src%2Flibrustc_mir%2Ftransform%2Fpromote_consts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fpromote_consts.rs?ref=0d531bfb881e6d303d09de9f212eaac72a9a218d", "patch": "@@ -117,18 +117,16 @@ impl<'tcx> Visitor<'tcx> for TempCollector {\n         }\n     }\n \n+    fn visit_source_info(&mut self, source_info: &SourceInfo) {\n+        self.span = source_info.span;\n+    }\n+\n     fn visit_statement(&mut self, bb: BasicBlock, statement: &Statement<'tcx>) {\n         assert_eq!(self.location.block, bb);\n-        self.span = statement.span;\n         self.super_statement(bb, statement);\n         self.location.statement_index += 1;\n     }\n \n-    fn visit_terminator(&mut self, bb: BasicBlock, terminator: &Terminator<'tcx>) {\n-        self.span = terminator.span;\n-        self.super_terminator(bb, terminator);\n-    }\n-\n     fn visit_basic_block_data(&mut self, bb: BasicBlock, data: &BasicBlockData<'tcx>) {\n         self.location.statement_index = 0;\n         self.location.block = bb;\n@@ -167,8 +165,10 @@ impl<'a, 'tcx> Promoter<'a, 'tcx> {\n         self.promoted.basic_blocks.push(BasicBlockData {\n             statements: vec![],\n             terminator: Some(Terminator {\n-                span: self.promoted.span,\n-                scope: ScopeId::new(0),\n+                source_info: SourceInfo {\n+                    span: self.promoted.span,\n+                    scope: ARGUMENT_VISIBILITY_SCOPE\n+                },\n                 kind: TerminatorKind::Return\n             }),\n             is_cleanup: false\n@@ -179,8 +179,10 @@ impl<'a, 'tcx> Promoter<'a, 'tcx> {\n     fn assign(&mut self, dest: Lvalue<'tcx>, rvalue: Rvalue<'tcx>, span: Span) {\n         let data = self.promoted.basic_blocks.last_mut().unwrap();\n         data.statements.push(Statement {\n-            span: span,\n-            scope: ScopeId::new(0),\n+            source_info: SourceInfo {\n+                span: span,\n+                scope: ARGUMENT_VISIBILITY_SCOPE\n+            },\n             kind: StatementKind::Assign(dest, rvalue)\n         });\n     }\n@@ -214,7 +216,7 @@ impl<'a, 'tcx> Promoter<'a, 'tcx> {\n         // First, take the Rvalue or Call out of the source MIR,\n         // or duplicate it, depending on keep_original.\n         let (mut rvalue, mut call) = (None, None);\n-        let span = if stmt_idx < no_stmts {\n+        let source_info = if stmt_idx < no_stmts {\n             let statement = &mut self.source[bb].statements[stmt_idx];\n             let StatementKind::Assign(_, ref mut rhs) = statement.kind;\n             if self.keep_original {\n@@ -223,11 +225,11 @@ impl<'a, 'tcx> Promoter<'a, 'tcx> {\n                 let unit = Rvalue::Aggregate(AggregateKind::Tuple, vec![]);\n                 rvalue = Some(mem::replace(rhs, unit));\n             }\n-            statement.span\n+            statement.source_info\n         } else if self.keep_original {\n             let terminator = self.source[bb].terminator().clone();\n             call = Some(terminator.kind);\n-            terminator.span\n+            terminator.source_info\n         } else {\n             let terminator = self.source[bb].terminator_mut();\n             let target = match terminator.kind {\n@@ -242,13 +244,13 @@ impl<'a, 'tcx> Promoter<'a, 'tcx> {\n                     dest.take().unwrap().1\n                 }\n                 ref kind => {\n-                    span_bug!(terminator.span, \"{:?} not promotable\", kind);\n+                    span_bug!(terminator.source_info.span, \"{:?} not promotable\", kind);\n                 }\n             };\n             call = Some(mem::replace(&mut terminator.kind, TerminatorKind::Goto {\n                 target: target\n             }));\n-            terminator.span\n+            terminator.source_info\n         };\n \n         // Then, recurse for components in the Rvalue or Call.\n@@ -266,7 +268,7 @@ impl<'a, 'tcx> Promoter<'a, 'tcx> {\n \n         // Inject the Rvalue or Call into the promoted MIR.\n         if stmt_idx < no_stmts {\n-            self.assign(new_temp, rvalue.unwrap(), span);\n+            self.assign(new_temp, rvalue.unwrap(), source_info.span);\n         } else {\n             let last = self.promoted.basic_blocks.len() - 1;\n             let new_target = self.new_block();\n@@ -278,7 +280,7 @@ impl<'a, 'tcx> Promoter<'a, 'tcx> {\n                 _ => bug!()\n             }\n             let terminator = &mut self.promoted.basic_blocks[last].terminator_mut();\n-            terminator.span = span;\n+            terminator.source_info.span = source_info.span;\n             terminator.kind = call;\n         }\n \n@@ -346,7 +348,7 @@ pub fn promote_candidates<'a, 'tcx>(mir: &mut Mir<'tcx>,\n                         continue;\n                     }\n                 }\n-                (statement.span, mir.lvalue_ty(tcx, dest).to_ty(tcx))\n+                (statement.source_info.span, mir.lvalue_ty(tcx, dest).to_ty(tcx))\n             }\n             Candidate::ShuffleIndices(bb) => {\n                 let terminator = mir[bb].terminator();\n@@ -355,19 +357,19 @@ pub fn promote_candidates<'a, 'tcx>(mir: &mut Mir<'tcx>,\n                         mir.operand_ty(tcx, &args[2])\n                     }\n                     _ => {\n-                        span_bug!(terminator.span,\n+                        span_bug!(terminator.source_info.span,\n                                   \"expected simd_shuffleN call to promote\");\n                     }\n                 };\n-                (terminator.span, ty)\n+                (terminator.source_info.span, ty)\n             }\n         };\n \n         let mut promoter = Promoter {\n             source: mir,\n             promoted: Mir {\n                 basic_blocks: vec![],\n-                scopes: vec![ScopeData {\n+                visibility_scopes: vec![VisibilityScopeData {\n                     span: span,\n                     parent_scope: None\n                 }],"}, {"sha": "92ac9b049f1276203f8da77d0cc62d90f76368e4", "filename": "src/librustc_mir/transform/qualify_consts.rs", "status": "modified", "additions": 10, "deletions": 7, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/0d531bfb881e6d303d09de9f212eaac72a9a218d/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d531bfb881e6d303d09de9f212eaac72a9a218d/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs?ref=0d531bfb881e6d303d09de9f212eaac72a9a218d", "patch": "@@ -377,11 +377,12 @@ impl<'a, 'tcx> Qualifier<'a, 'tcx, 'tcx> {\n                             let stmt_idx = location.statement_index;\n \n                             // Get the span for the initialization.\n-                            if stmt_idx < data.statements.len() {\n-                                self.span = data.statements[stmt_idx].span;\n+                            let source_info = if stmt_idx < data.statements.len() {\n+                                data.statements[stmt_idx].source_info\n                             } else {\n-                                self.span = data.terminator().span;\n-                            }\n+                                data.terminator().source_info\n+                            };\n+                            self.span = source_info.span;\n \n                             // Treat this as a statement in the AST.\n                             self.statement_like();\n@@ -830,7 +831,7 @@ impl<'a, 'tcx> Visitor<'tcx> for Qualifier<'a, 'tcx, 'tcx> {\n                 // Avoid a generic error for other uses of arguments.\n                 if self.qualif.intersects(Qualif::FN_ARGUMENT) {\n                     let decl = &self.mir.var_decls[index as usize];\n-                    span_err!(self.tcx.sess, decl.span, E0022,\n+                    span_err!(self.tcx.sess, decl.source_info.span, E0022,\n                               \"arguments of constant functions can only \\\n                                be immutable by-value bindings\");\n                     return;\n@@ -841,16 +842,18 @@ impl<'a, 'tcx> Visitor<'tcx> for Qualifier<'a, 'tcx, 'tcx> {\n         self.assign(dest);\n     }\n \n+    fn visit_source_info(&mut self, source_info: &SourceInfo) {\n+        self.span = source_info.span;\n+    }\n+\n     fn visit_statement(&mut self, bb: BasicBlock, statement: &Statement<'tcx>) {\n         assert_eq!(self.location.block, bb);\n-        self.span = statement.span;\n         self.nest(|this| this.super_statement(bb, statement));\n         self.location.statement_index += 1;\n     }\n \n     fn visit_terminator(&mut self, bb: BasicBlock, terminator: &Terminator<'tcx>) {\n         assert_eq!(self.location.block, bb);\n-        self.span = terminator.span;\n         self.nest(|this| this.super_terminator(bb, terminator));\n     }\n "}, {"sha": "4bfa3b16efa16124400b319de13a9940eb69f7a9", "filename": "src/librustc_mir/transform/type_check.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0d531bfb881e6d303d09de9f212eaac72a9a218d/src%2Flibrustc_mir%2Ftransform%2Ftype_check.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d531bfb881e6d303d09de9f212eaac72a9a218d/src%2Flibrustc_mir%2Ftransform%2Ftype_check.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Ftype_check.rs?ref=0d531bfb881e6d303d09de9f212eaac72a9a218d", "patch": "@@ -551,7 +551,7 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n     fn check_iscleanup(&mut self, mir: &Mir<'tcx>, block: &BasicBlockData<'tcx>)\n     {\n         let is_cleanup = block.is_cleanup;\n-        self.last_span = block.terminator().span;\n+        self.last_span = block.terminator().source_info.span;\n         match block.terminator().kind {\n             TerminatorKind::Goto { target } =>\n                 self.assert_iscleanup(mir, block, target, is_cleanup),\n@@ -617,8 +617,8 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n         debug!(\"run_on_mir: {:?}\", mir.span);\n         for block in &mir.basic_blocks {\n             for stmt in &block.statements {\n-                if stmt.span != DUMMY_SP {\n-                    self.last_span = stmt.span;\n+                if stmt.source_info.span != DUMMY_SP {\n+                    self.last_span = stmt.source_info.span;\n                 }\n                 self.check_stmt(mir, stmt);\n             }"}, {"sha": "f75f973f68aabd4932621a520ced6c8d2fd3be24", "filename": "src/librustc_trans/debuginfo/create_scope_map.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/0d531bfb881e6d303d09de9f212eaac72a9a218d/src%2Flibrustc_trans%2Fdebuginfo%2Fcreate_scope_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d531bfb881e6d303d09de9f212eaac72a9a218d/src%2Flibrustc_trans%2Fdebuginfo%2Fcreate_scope_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fdebuginfo%2Fcreate_scope_map.rs?ref=0d531bfb881e6d303d09de9f212eaac72a9a218d", "patch": "@@ -16,7 +16,7 @@ use llvm;\n use llvm::debuginfo::{DIScope, DISubprogram};\n use common::{CrateContext, FunctionContext};\n use rustc::hir::pat_util;\n-use rustc::mir::repr::{Mir, ScopeId};\n+use rustc::mir::repr::{Mir, VisibilityScope};\n use rustc::util::nodemap::NodeMap;\n \n use libc::c_uint;\n@@ -71,7 +71,7 @@ pub fn create_scope_map(cx: &CrateContext,\n /// If debuginfo is disabled, the returned vector is empty.\n pub fn create_mir_scopes(fcx: &FunctionContext) -> Vec<DIScope> {\n     let mir = fcx.mir.clone().expect(\"create_mir_scopes: missing MIR for fn\");\n-    let mut scopes = vec![ptr::null_mut(); mir.scopes.len()];\n+    let mut scopes = vec![ptr::null_mut(); mir.visibility_scopes.len()];\n \n     let fn_metadata = match fcx.debug_context {\n         FunctionDebugContext::RegularContext(box ref data) => data.fn_metadata,\n@@ -82,14 +82,14 @@ pub fn create_mir_scopes(fcx: &FunctionContext) -> Vec<DIScope> {\n     };\n \n     // Find all the scopes with variables defined in them.\n-    let mut has_variables = BitVector::new(mir.scopes.len());\n+    let mut has_variables = BitVector::new(mir.visibility_scopes.len());\n     for var in &mir.var_decls {\n-        has_variables.insert(var.scope.index());\n+        has_variables.insert(var.source_info.scope.index());\n     }\n \n     // Instantiate all scopes.\n-    for idx in 0..mir.scopes.len() {\n-        let scope = ScopeId::new(idx);\n+    for idx in 0..mir.visibility_scopes.len() {\n+        let scope = VisibilityScope::new(idx);\n         make_mir_scope(fcx.ccx, &mir, &has_variables, fn_metadata, scope, &mut scopes);\n     }\n \n@@ -100,14 +100,14 @@ fn make_mir_scope(ccx: &CrateContext,\n                   mir: &Mir,\n                   has_variables: &BitVector,\n                   fn_metadata: DISubprogram,\n-                  scope: ScopeId,\n+                  scope: VisibilityScope,\n                   scopes: &mut [DIScope]) {\n     let idx = scope.index();\n     if !scopes[idx].is_null() {\n         return;\n     }\n \n-    let scope_data = &mir.scopes[scope];\n+    let scope_data = &mir.visibility_scopes[scope];\n     let parent_scope = if let Some(parent) = scope_data.parent_scope {\n         make_mir_scope(ccx, mir, has_variables, fn_metadata, parent, scopes);\n         scopes[parent.index()]"}, {"sha": "6f9838a8932ef5ef834659cd3a70720019dfb6d2", "filename": "src/librustc_trans/mir/block.rs", "status": "modified", "additions": 6, "deletions": 8, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/0d531bfb881e6d303d09de9f212eaac72a9a218d/src%2Flibrustc_trans%2Fmir%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d531bfb881e6d303d09de9f212eaac72a9a218d/src%2Flibrustc_trans%2Fmir%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Fblock.rs?ref=0d531bfb881e6d303d09de9f212eaac72a9a218d", "patch": "@@ -106,8 +106,8 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n         let terminator = data.terminator();\n         debug!(\"trans_block: terminator: {:?}\", terminator);\n \n-        let debug_loc = DebugLoc::ScopeAt(self.scopes[terminator.scope.index()],\n-                                          terminator.span);\n+        let span = terminator.source_info.span;\n+        let debug_loc = self.debug_loc(terminator.source_info);\n         debug_loc.apply_to_bcx(&bcx);\n         debug_loc.apply(bcx.fcx());\n         match terminator.kind {\n@@ -245,7 +245,7 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n                 bcx = panic_block.build();\n \n                 // Get the location information.\n-                let loc = bcx.sess().codemap().lookup_char_pos(terminator.span.lo);\n+                let loc = bcx.sess().codemap().lookup_char_pos(span.lo);\n                 let filename = token::intern_and_get_ident(&loc.file.name);\n                 let filename = C_str_slice(bcx.ccx(), filename);\n                 let line = C_u32(bcx.ccx(), loc.line as u32);\n@@ -296,15 +296,14 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n                 // is also constant, then we can produce a warning.\n                 if const_cond == Some(!expected) {\n                     if let Some(err) = const_err {\n-                        let _ = consts::const_err(bcx.ccx(),\n-                                                  terminator.span,\n+                        let _ = consts::const_err(bcx.ccx(), span,\n                                                   Err::<(), _>(err),\n                                                   consts::TrueConst::No);\n                     }\n                 }\n \n                 // Obtain the panic entry point.\n-                let def_id = common::langcall(bcx.tcx(), Some(terminator.span), \"\", lang_item);\n+                let def_id = common::langcall(bcx.tcx(), Some(span), \"\", lang_item);\n                 let callee = Callee::def(bcx.ccx(), def_id,\n                     bcx.ccx().empty_substs_for_def_id(def_id));\n                 let llfn = callee.reify(bcx.ccx()).val;\n@@ -417,8 +416,7 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n                     if is_shuffle && idx == 2 {\n                         match *arg {\n                             mir::Operand::Consume(_) => {\n-                                span_bug!(terminator.span,\n-                                          \"shuffle indices must be constant\");\n+                                span_bug!(span, \"shuffle indices must be constant\");\n                             }\n                             mir::Operand::Constant(ref constant) => {\n                                 let val = self.trans_constant(&bcx, constant);"}, {"sha": "4e0cf729d4cd607816c1d529b34ecac3c8317622", "filename": "src/librustc_trans/mir/constant.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/0d531bfb881e6d303d09de9f212eaac72a9a218d/src%2Flibrustc_trans%2Fmir%2Fconstant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d531bfb881e6d303d09de9f212eaac72a9a218d/src%2Flibrustc_trans%2Fmir%2Fconstant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Fconstant.rs?ref=0d531bfb881e6d303d09de9f212eaac72a9a218d", "patch": "@@ -281,20 +281,21 @@ impl<'a, 'tcx> MirConstContext<'a, 'tcx> {\n         loop {\n             let data = self.mir.basic_block_data(bb);\n             for statement in &data.statements {\n+                let span = statement.source_info.span;\n                 match statement.kind {\n                     mir::StatementKind::Assign(ref dest, ref rvalue) => {\n                         let ty = self.mir.lvalue_ty(tcx, dest);\n                         let ty = self.monomorphize(&ty).to_ty(tcx);\n-                        match self.const_rvalue(rvalue, ty, statement.span) {\n-                            Ok(value) => self.store(dest, value, statement.span),\n+                        match self.const_rvalue(rvalue, ty, span) {\n+                            Ok(value) => self.store(dest, value, span),\n                             Err(err) => if failure.is_ok() { failure = Err(err); }\n                         }\n                     }\n                 }\n             }\n \n             let terminator = data.terminator();\n-            let span = terminator.span;\n+            let span = terminator.source_info.span;\n             bb = match terminator.kind {\n                 mir::TerminatorKind::Drop { target, .. } | // No dropping.\n                 mir::TerminatorKind::Goto { target } => target,"}, {"sha": "b58f5ed650a3987ce8ff0fd16cf48f10854d8196", "filename": "src/librustc_trans/mir/mod.rs", "status": "modified", "additions": 15, "deletions": 12, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/0d531bfb881e6d303d09de9f212eaac72a9a218d/src%2Flibrustc_trans%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d531bfb881e6d303d09de9f212eaac72a9a218d/src%2Flibrustc_trans%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Fmod.rs?ref=0d531bfb881e6d303d09de9f212eaac72a9a218d", "patch": "@@ -112,6 +112,12 @@ pub struct MirContext<'bcx, 'tcx:'bcx> {\n     scopes: Vec<DIScope>\n }\n \n+impl<'blk, 'tcx> MirContext<'blk, 'tcx> {\n+    pub fn debug_loc(&self, source_info: mir::SourceInfo) -> DebugLoc {\n+        DebugLoc::ScopeAt(self.scopes[source_info.scope.index()], source_info.span)\n+    }\n+}\n+\n enum TempRef<'tcx> {\n     Lvalue(LvalueRef<'tcx>),\n     Operand(Option<OperandRef<'tcx>>),\n@@ -166,12 +172,12 @@ pub fn trans_mir<'blk, 'tcx: 'blk>(fcx: &'blk FunctionContext<'blk, 'tcx>) {\n                             .map(|(mty, decl)| {\n         let lvalue = LvalueRef::alloca(&bcx, mty, &decl.name.as_str());\n \n-        let scope = scopes[decl.scope.index()];\n+        let scope = scopes[decl.source_info.scope.index()];\n         if !scope.is_null() && bcx.sess().opts.debuginfo == FullDebugInfo {\n             bcx.with_block(|bcx| {\n                 declare_local(bcx, decl.name, mty, scope,\n                               VariableAccess::DirectVariable { alloca: lvalue.llval },\n-                              VariableKind::LocalVariable, decl.span);\n+                              VariableKind::LocalVariable, decl.source_info.span);\n             });\n         }\n \n@@ -271,16 +277,13 @@ fn arg_value_refs<'bcx, 'tcx>(bcx: &BlockAndBuilder<'bcx, 'tcx>,\n     let mut idx = 0;\n     let mut llarg_idx = fcx.fn_ty.ret.is_indirect() as usize;\n \n-    // Get the argument scope assuming ScopeId(0) has no parent.\n-    let arg_scope = mir.scopes.get(0).and_then(|data| {\n-        let scope = scopes[0];\n-        if data.parent_scope.is_none() && !scope.is_null() &&\n-           bcx.sess().opts.debuginfo == FullDebugInfo {\n-            Some(scope)\n-        } else {\n-            None\n-        }\n-    });\n+    // Get the argument scope, if it exists and if we need it.\n+    let arg_scope = scopes[mir::ARGUMENT_VISIBILITY_SCOPE.index()];\n+    let arg_scope = if !arg_scope.is_null() && bcx.sess().opts.debuginfo == FullDebugInfo {\n+        Some(arg_scope)\n+    } else {\n+        None\n+    };\n \n     mir.arg_decls.iter().enumerate().map(|(arg_index, arg_decl)| {\n         let arg_ty = bcx.monomorphize(&arg_decl.ty);"}, {"sha": "544c47e471fd3666eb45ac3e3dfe4c17546bebbe", "filename": "src/librustc_trans/mir/statement.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0d531bfb881e6d303d09de9f212eaac72a9a218d/src%2Flibrustc_trans%2Fmir%2Fstatement.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d531bfb881e6d303d09de9f212eaac72a9a218d/src%2Flibrustc_trans%2Fmir%2Fstatement.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Fstatement.rs?ref=0d531bfb881e6d303d09de9f212eaac72a9a218d", "patch": "@@ -10,7 +10,6 @@\n \n use rustc::mir::repr as mir;\n use common::{self, BlockAndBuilder};\n-use debuginfo::DebugLoc;\n \n use super::MirContext;\n use super::TempRef;\n@@ -22,8 +21,7 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n                            -> BlockAndBuilder<'bcx, 'tcx> {\n         debug!(\"trans_statement(statement={:?})\", statement);\n \n-        let debug_loc = DebugLoc::ScopeAt(self.scopes[statement.scope.index()],\n-                                          statement.span);\n+        let debug_loc = self.debug_loc(statement.source_info);\n         debug_loc.apply_to_bcx(&bcx);\n         debug_loc.apply(bcx.fcx());\n         match statement.kind {\n@@ -46,7 +44,7 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n                                 let ty = bcx.monomorphize(&ty.to_ty(bcx.tcx()));\n \n                                 if !common::type_is_zero_size(bcx.ccx(), ty) {\n-                                    span_bug!(statement.span,\n+                                    span_bug!(statement.source_info.span,\n                                               \"operand {:?} already assigned\",\n                                               rvalue);\n                                 } else {"}, {"sha": "b5b6ca7572703cc65fab869385623d0d4b924be5", "filename": "src/test/debuginfo/function-prologue-stepping-no-stack-check.rs", "status": "modified", "additions": 1, "deletions": 12, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/0d531bfb881e6d303d09de9f212eaac72a9a218d/src%2Ftest%2Fdebuginfo%2Ffunction-prologue-stepping-no-stack-check.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d531bfb881e6d303d09de9f212eaac72a9a218d/src%2Ftest%2Fdebuginfo%2Ffunction-prologue-stepping-no-stack-check.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebuginfo%2Ffunction-prologue-stepping-no-stack-check.rs?ref=0d531bfb881e6d303d09de9f212eaac72a9a218d", "patch": "@@ -247,11 +247,10 @@\n // lldb-command:continue\n \n #![allow(dead_code, unused_assignments, unused_variables)]\n-#![feature(omit_gdb_pretty_printer_section, rustc_attrs)]\n+#![feature(omit_gdb_pretty_printer_section)]\n #![omit_gdb_pretty_printer_section]\n \n #[no_stack_check]\n-#[rustc_no_mir] // FIXME(#32949) MIR debuginfo shadows arguments with uninit vars.\n fn immediate_args(a: isize, b: bool, c: f64) {\n     println!(\"\");\n }\n@@ -268,51 +267,43 @@ struct BigStruct {\n }\n \n #[no_stack_check]\n-#[rustc_no_mir] // FIXME(#32949) MIR debuginfo shadows arguments with uninit vars.\n fn non_immediate_args(a: BigStruct, b: BigStruct) {\n     println!(\"\");\n }\n \n #[no_stack_check]\n-#[rustc_no_mir] // FIXME(#32949) MIR debuginfo shadows arguments with uninit vars.\n fn binding(a: i64, b: u64, c: f64) {\n     let x = 0;\n     println!(\"\");\n }\n \n #[no_stack_check]\n-#[rustc_no_mir] // FIXME(#32949) MIR debuginfo shadows arguments with uninit vars.\n fn assignment(mut a: u64, b: u64, c: f64) {\n     a = b;\n     println!(\"\");\n }\n \n #[no_stack_check]\n-#[rustc_no_mir] // FIXME(#32949) MIR debuginfo shadows arguments with uninit vars.\n fn function_call(x: u64, y: u64, z: f64) {\n     println!(\"Hi!\")\n }\n \n #[no_stack_check]\n-#[rustc_no_mir] // FIXME(#32949) MIR debuginfo shadows arguments with uninit vars.\n fn identifier(x: u64, y: u64, z: f64) -> u64 {\n     x\n }\n \n #[no_stack_check]\n-#[rustc_no_mir] // FIXME(#32949) MIR debuginfo shadows arguments with uninit vars.\n fn return_expr(x: u64, y: u64, z: f64) -> u64 {\n     return x;\n }\n \n #[no_stack_check]\n-#[rustc_no_mir] // FIXME(#32949) MIR debuginfo shadows arguments with uninit vars.\n fn arithmetic_expr(x: u64, y: u64, z: f64) -> u64 {\n     x + y\n }\n \n #[no_stack_check]\n-#[rustc_no_mir] // FIXME(#32949) MIR debuginfo shadows arguments with uninit vars.\n fn if_expr(x: u64, y: u64, z: f64) -> u64 {\n     if x + y < 1000 {\n         x\n@@ -322,7 +313,6 @@ fn if_expr(x: u64, y: u64, z: f64) -> u64 {\n }\n \n #[no_stack_check]\n-#[rustc_no_mir] // FIXME(#32949) MIR debuginfo shadows arguments with uninit vars.\n fn while_expr(mut x: u64, y: u64, z: u64) -> u64 {\n     while x + y < 1000 {\n         x += z\n@@ -331,7 +321,6 @@ fn while_expr(mut x: u64, y: u64, z: u64) -> u64 {\n }\n \n #[no_stack_check]\n-#[rustc_no_mir] // FIXME(#32949) MIR debuginfo shadows arguments with uninit vars.\n fn loop_expr(mut x: u64, y: u64, z: u64) -> u64 {\n     loop {\n         x += z;"}]}