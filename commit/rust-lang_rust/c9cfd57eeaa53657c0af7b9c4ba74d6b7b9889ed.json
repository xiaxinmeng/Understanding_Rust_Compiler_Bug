{"sha": "c9cfd57eeaa53657c0af7b9c4ba74d6b7b9889ed", "node_id": "MDY6Q29tbWl0NzI0NzEyOmM5Y2ZkNTdlZWFhNTM2NTdjMGFmN2I5YzRiYTc0ZDZiN2I5ODg5ZWQ=", "commit": {"author": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2019-07-20T17:04:34Z"}, "committer": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2019-07-20T17:12:06Z"}, "message": "switch to upstream rowan's API", "tree": {"sha": "422c1d8fb7f8af663df3c6c6183783253692acad", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/422c1d8fb7f8af663df3c6c6183783253692acad"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c9cfd57eeaa53657c0af7b9c4ba74d6b7b9889ed", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c9cfd57eeaa53657c0af7b9c4ba74d6b7b9889ed", "html_url": "https://github.com/rust-lang/rust/commit/c9cfd57eeaa53657c0af7b9c4ba74d6b7b9889ed", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c9cfd57eeaa53657c0af7b9c4ba74d6b7b9889ed/comments", "author": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "committer": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7bde8012cb28c44de7ffc779003781d385323808", "url": "https://api.github.com/repos/rust-lang/rust/commits/7bde8012cb28c44de7ffc779003781d385323808", "html_url": "https://github.com/rust-lang/rust/commit/7bde8012cb28c44de7ffc779003781d385323808"}], "stats": {"total": 942, "additions": 206, "deletions": 736}, "files": [{"sha": "8feaf27ecbd333be668d4ae1e91c7f74c81a2982", "filename": "Cargo.lock", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/c9cfd57eeaa53657c0af7b9c4ba74d6b7b9889ed/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/c9cfd57eeaa53657c0af7b9c4ba74d6b7b9889ed/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=c9cfd57eeaa53657c0af7b9c4ba74d6b7b9889ed", "patch": "@@ -263,11 +263,6 @@ dependencies = [\n  \"bitflags 1.1.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n-[[package]]\n-name = \"colosseum\"\n-version = \"0.2.2\"\n-source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-\n [[package]]\n name = \"console\"\n version = \"0.7.7\"\n@@ -484,6 +479,11 @@ dependencies = [\n  \"yansi 0.5.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n+[[package]]\n+name = \"format-buf\"\n+version = \"1.0.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+\n [[package]]\n name = \"fs_extra\"\n version = \"1.1.0\"\n@@ -1124,6 +1124,7 @@ name = \"ra_assists\"\n version = \"0.1.0\"\n dependencies = [\n  \"arrayvec 0.4.11 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"format-buf 1.0.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"itertools 0.8.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"join_to_string 0.1.3 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"once_cell 0.2.3 (registry+https://github.com/rust-lang/crates.io-index)\",\n@@ -1211,6 +1212,7 @@ dependencies = [\n name = \"ra_ide_api\"\n version = \"0.1.0\"\n dependencies = [\n+ \"format-buf 1.0.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"fst 0.3.3 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"insta 0.8.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"itertools 0.8.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n@@ -1313,7 +1315,7 @@ dependencies = [\n  \"itertools 0.8.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"ra_parser 0.1.0\",\n  \"ra_text_edit 0.1.0\",\n- \"rowan 0.5.6 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"rowan 0.6.0-pre.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"smol_str 0.1.12 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"test_utils 0.1.0\",\n  \"unicode-xid 0.1.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n@@ -1584,11 +1586,9 @@ dependencies = [\n \n [[package]]\n name = \"rowan\"\n-version = \"0.5.6\"\n+version = \"0.6.0-pre.1\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n- \"colosseum 0.2.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"parking_lot 0.9.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"rustc-hash 1.0.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"smol_str 0.1.12 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"text_unit 0.1.9 (registry+https://github.com/rust-lang/crates.io-index)\",\n@@ -2150,7 +2150,6 @@ source = \"registry+https://github.com/rust-lang/crates.io-index\"\n \"checksum clap 2.33.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"5067f5bb2d80ef5d68b4c87db81601f0b75bca627bc2ef76b141d7b846a3c6d9\"\n \"checksum clicolors-control 1.0.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"73abfd4c73d003a674ce5d2933fca6ce6c42480ea84a5ffe0a2dc39ed56300f9\"\n \"checksum cloudabi 0.0.3 (registry+https://github.com/rust-lang/crates.io-index)\" = \"ddfc5b9aa5d4507acaf872de71051dfd0e309860e88966e1051e462a077aac4f\"\n-\"checksum colosseum 0.2.2 (registry+https://github.com/rust-lang/crates.io-index)\" = \"370c83b49aedf022ee27942e8ae1d9de1cf40dc9653ee6550e4455d08f6406f9\"\n \"checksum console 0.7.7 (registry+https://github.com/rust-lang/crates.io-index)\" = \"8ca57c2c14b8a2bf3105bc9d15574aad80babf6a9c44b1058034cdf8bd169628\"\n \"checksum cpuprofiler 0.0.3 (registry+https://github.com/rust-lang/crates.io-index)\" = \"33f07976bb6821459632d7a18d97ccca005cb5c552f251f822c7c1781c1d7035\"\n \"checksum crossbeam-channel 0.3.8 (registry+https://github.com/rust-lang/crates.io-index)\" = \"0f0ed1a4de2235cabda8558ff5840bffb97fcb64c97827f354a451307df5f72b\"\n@@ -2177,6 +2176,7 @@ source = \"registry+https://github.com/rust-lang/crates.io-index\"\n \"checksum filetime 0.2.5 (registry+https://github.com/rust-lang/crates.io-index)\" = \"2f8c63033fcba1f51ef744505b3cad42510432b904c062afa67ad7ece008429d\"\n \"checksum fixedbitset 0.1.9 (registry+https://github.com/rust-lang/crates.io-index)\" = \"86d4de0081402f5e88cdac65c8dcdcc73118c1a7a465e2a05f0da05843a8ea33\"\n \"checksum flexi_logger 0.13.3 (registry+https://github.com/rust-lang/crates.io-index)\" = \"e9d3c4470d1ff8446baa0c13202646722886dde8dc4c5d33cb8242d70ece79d5\"\n+\"checksum format-buf 1.0.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"f7aea5a5909a74969507051a3b17adc84737e31a5f910559892aedce026f4d53\"\n \"checksum fs_extra 1.1.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"5f2a4a2034423744d2cc7ca2068453168dcdb82c438419e639a26bd87839c674\"\n \"checksum fsevent 0.4.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"5ab7d1bd1bd33cc98b0889831b72da23c0aa4df9cec7e0702f46ecea04b35db6\"\n \"checksum fsevent-sys 2.0.1 (registry+https://github.com/rust-lang/crates.io-index)\" = \"f41b048a94555da0f42f1d632e2e19510084fb8e303b0daa2816e733fb3644a0\"\n@@ -2275,7 +2275,7 @@ source = \"registry+https://github.com/rust-lang/crates.io-index\"\n \"checksum relative-path 0.4.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"0e7790c7f1cc73d831d28dc5a7deb316a006e7848e6a7f467cdb10a0a9e0fb1c\"\n \"checksum remove_dir_all 0.5.2 (registry+https://github.com/rust-lang/crates.io-index)\" = \"4a83fa3702a688b9359eccba92d153ac33fd2e8462f9e0e3fdf155239ea7792e\"\n \"checksum ron 0.4.2 (registry+https://github.com/rust-lang/crates.io-index)\" = \"17f52a24414403f81528b67488cf8edc4eda977d3af1646bb6b106a600ead78f\"\n-\"checksum rowan 0.5.6 (registry+https://github.com/rust-lang/crates.io-index)\" = \"0c433ffe99ac9b96fa9882805d05eee5d750c9202fb42d0546c556e5d70d54be\"\n+\"checksum rowan 0.6.0-pre.1 (registry+https://github.com/rust-lang/crates.io-index)\" = \"0eeee40f1a2724b7d0d9fa5f73a7804cd2f4c91b37ba9f785d429f31819d60df\"\n \"checksum rustc-demangle 0.1.15 (registry+https://github.com/rust-lang/crates.io-index)\" = \"a7f4dccf6f4891ebcc0c39f9b6eb1a83b9bf5d747cb439ec6fba4f3b977038af\"\n \"checksum rustc-hash 1.0.1 (registry+https://github.com/rust-lang/crates.io-index)\" = \"7540fc8b0c49f096ee9c961cda096467dce8084bec6bdca2fc83895fd9b28cb8\"\n \"checksum rustc_version 0.2.3 (registry+https://github.com/rust-lang/crates.io-index)\" = \"138e3e0acb6c9fb258b19b67cb8abd63c00679d2851805ea151465464fe9030a\""}, {"sha": "2113286a3010836adbdf9c608986258e4c4b8d37", "filename": "crates/ra_assists/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/c9cfd57eeaa53657c0af7b9c4ba74d6b7b9889ed/crates%2Fra_assists%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/c9cfd57eeaa53657c0af7b9c4ba74d6b7b9889ed/crates%2Fra_assists%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2FCargo.toml?ref=c9cfd57eeaa53657c0af7b9c4ba74d6b7b9889ed", "patch": "@@ -5,6 +5,7 @@ version = \"0.1.0\"\n authors = [\"rust-analyzer developers\"]\n \n [dependencies]\n+format-buf = \"1.0.0\"\n once_cell = \"0.2.0\"\n join_to_string = \"0.1.3\"\n itertools = \"0.8.0\""}, {"sha": "4b61f4031494ec137e2f36b03479b480035653a8", "filename": "crates/ra_assists/src/add_impl.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/c9cfd57eeaa53657c0af7b9c4ba74d6b7b9889ed/crates%2Fra_assists%2Fsrc%2Fadd_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9cfd57eeaa53657c0af7b9c4ba74d6b7b9889ed/crates%2Fra_assists%2Fsrc%2Fadd_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Fadd_impl.rs?ref=c9cfd57eeaa53657c0af7b9c4ba74d6b7b9889ed", "patch": "@@ -1,5 +1,4 @@\n-use std::fmt::Write;\n-\n+use format_buf::format;\n use hir::db::HirDatabase;\n use join_to_string::join;\n use ra_syntax::{\n@@ -19,7 +18,7 @@ pub(crate) fn add_impl(mut ctx: AssistCtx<impl HirDatabase>) -> Option<Assist> {\n         let mut buf = String::new();\n         buf.push_str(\"\\n\\nimpl\");\n         if let Some(type_params) = &type_params {\n-            write!(buf, \"{}\", type_params.syntax()).unwrap();\n+            format!(buf, \"{}\", type_params.syntax());\n         }\n         buf.push_str(\" \");\n         buf.push_str(name.text().as_str());"}, {"sha": "95b871b30c170d11c4edc086cae0a1697d798adb", "filename": "crates/ra_assists/src/ast_editor.rs", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/c9cfd57eeaa53657c0af7b9c4ba74d6b7b9889ed/crates%2Fra_assists%2Fsrc%2Fast_editor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9cfd57eeaa53657c0af7b9c4ba74d6b7b9889ed/crates%2Fra_assists%2Fsrc%2Fast_editor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Fast_editor.rs?ref=c9cfd57eeaa53657c0af7b9c4ba74d6b7b9889ed", "patch": "@@ -4,7 +4,10 @@ use arrayvec::ArrayVec;\n use hir::Name;\n use ra_fmt::leading_indent;\n use ra_syntax::{\n-    ast, AstNode, Direction, InsertPosition, SourceFile, SyntaxElement, SyntaxKind::*, T,\n+    algo::{insert_children, replace_children},\n+    ast, AstNode, Direction, InsertPosition, SourceFile, SyntaxElement,\n+    SyntaxKind::*,\n+    T,\n };\n use ra_text_edit::TextEditBuilder;\n \n@@ -38,7 +41,7 @@ impl<N: AstNode> AstEditor<N> {\n         position: InsertPosition<SyntaxElement>,\n         to_insert: impl Iterator<Item = SyntaxElement>,\n     ) -> N {\n-        let new_syntax = self.ast().syntax().insert_children(position, to_insert);\n+        let new_syntax = insert_children(self.ast().syntax(), position, to_insert);\n         N::cast(new_syntax).unwrap()\n     }\n \n@@ -48,7 +51,7 @@ impl<N: AstNode> AstEditor<N> {\n         to_delete: RangeInclusive<SyntaxElement>,\n         to_insert: impl Iterator<Item = SyntaxElement>,\n     ) -> N {\n-        let new_syntax = self.ast().syntax().replace_children(to_delete, to_insert);\n+        let new_syntax = replace_children(self.ast().syntax(), to_delete, to_insert);\n         N::cast(new_syntax).unwrap()\n     }\n "}, {"sha": "5eb7083103aaf8e75f8bd3d6d54ffa1a196c5101", "filename": "crates/ra_assists/src/introduce_variable.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/c9cfd57eeaa53657c0af7b9c4ba74d6b7b9889ed/crates%2Fra_assists%2Fsrc%2Fintroduce_variable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9cfd57eeaa53657c0af7b9c4ba74d6b7b9889ed/crates%2Fra_assists%2Fsrc%2Fintroduce_variable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Fintroduce_variable.rs?ref=c9cfd57eeaa53657c0af7b9c4ba74d6b7b9889ed", "patch": "@@ -1,5 +1,4 @@\n-use std::fmt::Write;\n-\n+use format_buf::format;\n use hir::db::HirDatabase;\n use ra_syntax::{\n     ast::{self, AstNode},\n@@ -37,7 +36,7 @@ pub(crate) fn introduce_variable(mut ctx: AssistCtx<impl HirDatabase>) -> Option\n             buf.push_str(\"let var_name = \");\n             TextUnit::of_str(\"let \")\n         };\n-        write!(buf, \"{}\", expr.syntax()).unwrap();\n+        format!(buf, \"{}\", expr.syntax());\n         let full_stmt = ast::ExprStmt::cast(anchor_stmt.clone());\n         let is_full_stmt = if let Some(expr_stmt) = &full_stmt {\n             Some(expr.syntax().clone()) == expr_stmt.expr().map(|e| e.syntax().clone())"}, {"sha": "127c9e068273e35bcb7624521b9ae01a75718de3", "filename": "crates/ra_assists/src/move_guard.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/c9cfd57eeaa53657c0af7b9c4ba74d6b7b9889ed/crates%2Fra_assists%2Fsrc%2Fmove_guard.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9cfd57eeaa53657c0af7b9c4ba74d6b7b9889ed/crates%2Fra_assists%2Fsrc%2Fmove_guard.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Fmove_guard.rs?ref=c9cfd57eeaa53657c0af7b9c4ba74d6b7b9889ed", "patch": "@@ -2,7 +2,7 @@ use hir::db::HirDatabase;\n use ra_syntax::{\n     ast,\n     ast::{AstNode, AstToken, IfExpr, MatchArm},\n-    SyntaxElement, TextUnit,\n+    TextUnit,\n };\n \n use crate::{Assist, AssistCtx, AssistId};\n@@ -18,10 +18,10 @@ pub(crate) fn move_guard_to_arm_body(mut ctx: AssistCtx<impl HirDatabase>) -> Op\n \n     ctx.add_action(AssistId(\"move_guard_to_arm_body\"), \"move guard to arm body\", |edit| {\n         edit.target(guard.syntax().text_range());\n-        let offseting_amount = match &space_before_guard {\n-            Some(SyntaxElement::Token(tok)) => {\n+        let offseting_amount = match space_before_guard.and_then(|it| it.into_token()) {\n+            Some(tok) => {\n                 if let Some(_) = ast::Whitespace::cast(tok.clone()) {\n-                    let ele = space_before_guard.unwrap().text_range();\n+                    let ele = tok.text_range();\n                     edit.delete(ele);\n                     ele.len()\n                 } else {"}, {"sha": "78a3db14d7e95c34d4001d7ca1ce6752c922e1e6", "filename": "crates/ra_ide_api/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/c9cfd57eeaa53657c0af7b9c4ba74d6b7b9889ed/crates%2Fra_ide_api%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/c9cfd57eeaa53657c0af7b9c4ba74d6b7b9889ed/crates%2Fra_ide_api%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_api%2FCargo.toml?ref=c9cfd57eeaa53657c0af7b9c4ba74d6b7b9889ed", "patch": "@@ -5,6 +5,7 @@ version = \"0.1.0\"\n authors = [\"rust-analyzer developers\"]\n \n [dependencies]\n+format-buf = \"1.0.0\"\n itertools = \"0.8.0\"\n join_to_string = \"0.1.3\"\n log = \"0.4.5\""}, {"sha": "825a033eed63b5df82aa42a64965f097376d83f8", "filename": "crates/ra_ide_api/src/display/short_label.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/c9cfd57eeaa53657c0af7b9c4ba74d6b7b9889ed/crates%2Fra_ide_api%2Fsrc%2Fdisplay%2Fshort_label.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9cfd57eeaa53657c0af7b9c4ba74d6b7b9889ed/crates%2Fra_ide_api%2Fsrc%2Fdisplay%2Fshort_label.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_api%2Fsrc%2Fdisplay%2Fshort_label.rs?ref=c9cfd57eeaa53657c0af7b9c4ba74d6b7b9889ed", "patch": "@@ -1,5 +1,4 @@\n-use std::fmt::Write;\n-\n+use format_buf::format;\n use ra_syntax::ast::{self, AstNode, NameOwner, TypeAscriptionOwner, VisibilityOwner};\n \n pub(crate) trait ShortLabel {\n@@ -73,7 +72,7 @@ where\n     let mut buf = short_label_from_node(node, prefix)?;\n \n     if let Some(type_ref) = node.ascribed_type() {\n-        write!(buf, \": {}\", type_ref.syntax()).unwrap();\n+        format!(buf, \": {}\", type_ref.syntax());\n     }\n \n     Some(buf)"}, {"sha": "f78c562afa08cab9ca1686b7c6794100ed623bb9", "filename": "crates/ra_ide_api/src/extend_selection.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/c9cfd57eeaa53657c0af7b9c4ba74d6b7b9889ed/crates%2Fra_ide_api%2Fsrc%2Fextend_selection.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9cfd57eeaa53657c0af7b9c4ba74d6b7b9889ed/crates%2Fra_ide_api%2Fsrc%2Fextend_selection.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_api%2Fsrc%2Fextend_selection.rs?ref=c9cfd57eeaa53657c0af7b9c4ba74d6b7b9889ed", "patch": "@@ -2,7 +2,7 @@ use ra_db::SourceDatabase;\n use ra_syntax::{\n     algo::{find_covering_element, find_token_at_offset, TokenAtOffset},\n     ast::{self, AstNode, AstToken},\n-    Direction, SyntaxElement,\n+    Direction, NodeOrToken,\n     SyntaxKind::*,\n     SyntaxNode, SyntaxToken, TextRange, TextUnit, T,\n };\n@@ -53,7 +53,7 @@ fn try_extend_selection(root: &SyntaxNode, range: TextRange) -> Option<TextRange\n         return Some(leaf_range);\n     };\n     let node = match find_covering_element(root, range) {\n-        SyntaxElement::Token(token) => {\n+        NodeOrToken::Token(token) => {\n             if token.text_range() != range {\n                 return Some(token.text_range());\n             }\n@@ -64,7 +64,7 @@ fn try_extend_selection(root: &SyntaxNode, range: TextRange) -> Option<TextRange\n             }\n             token.parent()\n         }\n-        SyntaxElement::Node(node) => node,\n+        NodeOrToken::Node(node) => node,\n     };\n     if node.text_range() != range {\n         return Some(node.text_range());\n@@ -153,8 +153,8 @@ fn extend_list_item(node: &SyntaxNode) -> Option<TextRange> {\n         node.siblings_with_tokens(dir)\n             .skip(1)\n             .skip_while(|node| match node {\n-                SyntaxElement::Node(_) => false,\n-                SyntaxElement::Token(it) => is_single_line_ws(it),\n+                NodeOrToken::Node(_) => false,\n+                NodeOrToken::Token(it) => is_single_line_ws(it),\n             })\n             .next()\n             .and_then(|it| it.into_token())"}, {"sha": "e60ae8cf62502eb796f353fd7b59b98c8c2a26db", "filename": "crates/ra_ide_api/src/folding_ranges.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/c9cfd57eeaa53657c0af7b9c4ba74d6b7b9889ed/crates%2Fra_ide_api%2Fsrc%2Ffolding_ranges.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9cfd57eeaa53657c0af7b9c4ba74d6b7b9889ed/crates%2Fra_ide_api%2Fsrc%2Ffolding_ranges.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_api%2Fsrc%2Ffolding_ranges.rs?ref=c9cfd57eeaa53657c0af7b9c4ba74d6b7b9889ed", "patch": "@@ -2,7 +2,7 @@ use rustc_hash::FxHashSet;\n \n use ra_syntax::{\n     ast::{self, AstNode, AstToken, VisibilityOwner},\n-    Direction, SourceFile, SyntaxElement,\n+    Direction, NodeOrToken, SourceFile,\n     SyntaxKind::{self, *},\n     SyntaxNode, TextRange,\n };\n@@ -31,8 +31,8 @@ pub(crate) fn folding_ranges(file: &SourceFile) -> Vec<Fold> {\n         // Fold items that span multiple lines\n         if let Some(kind) = fold_kind(element.kind()) {\n             let is_multiline = match &element {\n-                SyntaxElement::Node(node) => node.text().contains_char('\\n'),\n-                SyntaxElement::Token(token) => token.text().contains('\\n'),\n+                NodeOrToken::Node(node) => node.text().contains_char('\\n'),\n+                NodeOrToken::Token(token) => token.text().contains('\\n'),\n             };\n             if is_multiline {\n                 res.push(Fold { range: element.text_range(), kind });\n@@ -41,7 +41,7 @@ pub(crate) fn folding_ranges(file: &SourceFile) -> Vec<Fold> {\n         }\n \n         match element {\n-            SyntaxElement::Token(token) => {\n+            NodeOrToken::Token(token) => {\n                 // Fold groups of comments\n                 if let Some(comment) = ast::Comment::cast(token) {\n                     if !visited_comments.contains(&comment) {\n@@ -53,7 +53,7 @@ pub(crate) fn folding_ranges(file: &SourceFile) -> Vec<Fold> {\n                     }\n                 }\n             }\n-            SyntaxElement::Node(node) => {\n+            NodeOrToken::Node(node) => {\n                 // Fold groups of imports\n                 if node.kind() == USE_ITEM && !visited_imports.contains(&node) {\n                     if let Some(range) = contiguous_range_for_group(&node, &mut visited_imports) {\n@@ -108,7 +108,7 @@ fn contiguous_range_for_group_unless(\n     let mut last = first.clone();\n     for element in first.siblings_with_tokens(Direction::Next) {\n         let node = match element {\n-            SyntaxElement::Token(token) => {\n+            NodeOrToken::Token(token) => {\n                 if let Some(ws) = ast::Whitespace::cast(token) {\n                     if !ws.spans_multiple_lines() {\n                         // Ignore whitespace without blank lines\n@@ -119,7 +119,7 @@ fn contiguous_range_for_group_unless(\n                 // group ends here\n                 break;\n             }\n-            SyntaxElement::Node(node) => node,\n+            NodeOrToken::Node(node) => node,\n         };\n \n         // Stop if we find a node that doesn't belong to the group\n@@ -154,7 +154,7 @@ fn contiguous_range_for_comment(\n     let mut last = first.clone();\n     for element in first.syntax().siblings_with_tokens(Direction::Next) {\n         match element {\n-            SyntaxElement::Token(token) => {\n+            NodeOrToken::Token(token) => {\n                 if let Some(ws) = ast::Whitespace::cast(token.clone()) {\n                     if !ws.spans_multiple_lines() {\n                         // Ignore whitespace without blank lines\n@@ -173,7 +173,7 @@ fn contiguous_range_for_comment(\n                 // * A comment of a different flavor was reached\n                 break;\n             }\n-            SyntaxElement::Node(_) => break,\n+            NodeOrToken::Node(_) => break,\n         };\n     }\n "}, {"sha": "a2e4b6f3cfdb2d8e28379f74dde468e0a302e7e3", "filename": "crates/ra_ide_api/src/join_lines.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c9cfd57eeaa53657c0af7b9c4ba74d6b7b9889ed/crates%2Fra_ide_api%2Fsrc%2Fjoin_lines.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9cfd57eeaa53657c0af7b9c4ba74d6b7b9889ed/crates%2Fra_ide_api%2Fsrc%2Fjoin_lines.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_api%2Fsrc%2Fjoin_lines.rs?ref=c9cfd57eeaa53657c0af7b9c4ba74d6b7b9889ed", "patch": "@@ -3,7 +3,7 @@ use ra_fmt::{compute_ws, extract_trivial_expression};\n use ra_syntax::{\n     algo::{find_covering_element, non_trivia_sibling},\n     ast::{self, AstNode, AstToken},\n-    Direction, SourceFile, SyntaxElement,\n+    Direction, NodeOrToken, SourceFile,\n     SyntaxKind::{self, WHITESPACE},\n     SyntaxNode, SyntaxToken, TextRange, TextUnit, T,\n };\n@@ -23,8 +23,8 @@ pub fn join_lines(file: &SourceFile, range: TextRange) -> TextEdit {\n     };\n \n     let node = match find_covering_element(file.syntax(), range) {\n-        SyntaxElement::Node(node) => node,\n-        SyntaxElement::Token(token) => token.parent(),\n+        NodeOrToken::Node(node) => node,\n+        NodeOrToken::Token(token) => token.parent(),\n     };\n     let mut edit = TextEditBuilder::default();\n     for token in node.descendants_with_tokens().filter_map(|it| it.into_token()) {"}, {"sha": "a07e670fa441f29eb0eb8b911d28380b480c7be5", "filename": "crates/ra_ide_api/src/syntax_tree.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c9cfd57eeaa53657c0af7b9c4ba74d6b7b9889ed/crates%2Fra_ide_api%2Fsrc%2Fsyntax_tree.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9cfd57eeaa53657c0af7b9c4ba74d6b7b9889ed/crates%2Fra_ide_api%2Fsrc%2Fsyntax_tree.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_api%2Fsrc%2Fsyntax_tree.rs?ref=c9cfd57eeaa53657c0af7b9c4ba74d6b7b9889ed", "patch": "@@ -1,7 +1,7 @@\n use crate::db::RootDatabase;\r\n use ra_db::SourceDatabase;\r\n use ra_syntax::{\r\n-    algo, AstNode, SourceFile, SyntaxElement,\r\n+    algo, AstNode, NodeOrToken, SourceFile,\r\n     SyntaxKind::{RAW_STRING, STRING},\r\n     SyntaxToken, TextRange,\r\n };\r\n@@ -16,8 +16,8 @@ pub(crate) fn syntax_tree(\n     let parse = db.parse(file_id);\r\n     if let Some(text_range) = text_range {\r\n         let node = match algo::find_covering_element(parse.tree().syntax(), text_range) {\r\n-            SyntaxElement::Node(node) => node,\r\n-            SyntaxElement::Token(token) => {\r\n+            NodeOrToken::Node(node) => node,\r\n+            NodeOrToken::Token(token) => {\r\n                 if let Some(tree) = syntax_tree_for_string(&token, text_range) {\r\n                     return tree;\r\n                 }\r"}, {"sha": "8225759e76a9a1a7cb711fa15429858198f1b2b2", "filename": "crates/ra_mbe/src/syntax_bridge.rs", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/c9cfd57eeaa53657c0af7b9c4ba74d6b7b9889ed/crates%2Fra_mbe%2Fsrc%2Fsyntax_bridge.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9cfd57eeaa53657c0af7b9c4ba74d6b7b9889ed/crates%2Fra_mbe%2Fsrc%2Fsyntax_bridge.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_mbe%2Fsrc%2Fsyntax_bridge.rs?ref=c9cfd57eeaa53657c0af7b9c4ba74d6b7b9889ed", "patch": "@@ -1,12 +1,13 @@\n-use crate::subtree_source::SubtreeTokenSource;\n-use crate::ExpandError;\n use ra_parser::{ParseError, TreeSink};\n use ra_syntax::{\n-    ast, AstNode, AstToken, Parse, SmolStr, SyntaxElement, SyntaxKind, SyntaxKind::*, SyntaxNode,\n+    ast, AstNode, AstToken, NodeOrToken, Parse, SmolStr, SyntaxKind, SyntaxKind::*, SyntaxNode,\n     SyntaxTreeBuilder, TextRange, TextUnit, T,\n };\n use tt::buffer::{Cursor, TokenBuffer};\n \n+use crate::subtree_source::SubtreeTokenSource;\n+use crate::ExpandError;\n+\n /// Maps `tt::TokenId` to the relative range of the original token.\n #[derive(Default)]\n pub struct TokenMap {\n@@ -200,7 +201,7 @@ fn convert_tt(\n         }\n \n         match child {\n-            SyntaxElement::Token(token) => {\n+            NodeOrToken::Token(token) => {\n                 if let Some(doc_tokens) = convert_doc_comment(&token) {\n                     token_trees.extend(doc_tokens);\n                 } else if token.kind().is_trivia() {\n@@ -210,7 +211,7 @@ fn convert_tt(\n                     let char = token.text().chars().next().unwrap();\n \n                     let spacing = match child_iter.peek() {\n-                        Some(SyntaxElement::Token(token)) => {\n+                        Some(NodeOrToken::Token(token)) => {\n                             if token.kind().is_punct() {\n                                 tt::Spacing::Joint\n                             } else {\n@@ -241,7 +242,7 @@ fn convert_tt(\n                     token_trees.push(child);\n                 }\n             }\n-            SyntaxElement::Node(node) => {\n+            NodeOrToken::Node(node) => {\n                 let child = convert_tt(token_map, global_offset, &node)?.into();\n                 token_trees.push(child);\n             }"}, {"sha": "192e9007d6351eef3b2de990cf152e4bf8595fef", "filename": "crates/ra_mbe/src/tests.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c9cfd57eeaa53657c0af7b9c4ba74d6b7b9889ed/crates%2Fra_mbe%2Fsrc%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9cfd57eeaa53657c0af7b9c4ba74d6b7b9889ed/crates%2Fra_mbe%2Fsrc%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_mbe%2Fsrc%2Ftests.rs?ref=c9cfd57eeaa53657c0af7b9c4ba74d6b7b9889ed", "patch": "@@ -1,4 +1,4 @@\n-use ra_syntax::{ast, AstNode};\n+use ra_syntax::{ast, AstNode, NodeOrToken};\n \n use super::*;\n \n@@ -118,11 +118,11 @@ pub fn debug_dump_ignore_spaces(node: &ra_syntax::SyntaxNode) -> String {\n         match event {\n             WalkEvent::Enter(element) => {\n                 match element {\n-                    ra_syntax::SyntaxElement::Node(node) => {\n+                    NodeOrToken::Node(node) => {\n                         indent!();\n                         writeln!(buf, \"{:?}\", node.kind()).unwrap();\n                     }\n-                    ra_syntax::SyntaxElement::Token(token) => match token.kind() {\n+                    NodeOrToken::Token(token) => match token.kind() {\n                         ra_syntax::SyntaxKind::WHITESPACE => {}\n                         _ => {\n                             indent!();"}, {"sha": "97b6b047fa81e7ea8a172a444481497c92e4143d", "filename": "crates/ra_syntax/Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c9cfd57eeaa53657c0af7b9c4ba74d6b7b9889ed/crates%2Fra_syntax%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/c9cfd57eeaa53657c0af7b9c4ba74d6b7b9889ed/crates%2Fra_syntax%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2FCargo.toml?ref=c9cfd57eeaa53657c0af7b9c4ba74d6b7b9889ed", "patch": "@@ -10,7 +10,7 @@ repository = \"https://github.com/rust-analyzer/rust-analyzer\"\n [dependencies]\n unicode-xid = \"0.1.0\"\n itertools = \"0.8.0\"\n-rowan = \"0.5.6\"\n+rowan = \"0.6.0-pre.1\"\n \n # ideally, `serde` should be enabled by `ra_lsp_server`, but we enable it here\n # to reduce number of compilations"}, {"sha": "6bb46b02102c4a3dfb7349c14b8c2441836a365f", "filename": "crates/ra_syntax/src/algo.rs", "status": "modified", "additions": 104, "deletions": 13, "changes": 117, "blob_url": "https://github.com/rust-lang/rust/blob/c9cfd57eeaa53657c0af7b9c4ba74d6b7b9889ed/crates%2Fra_syntax%2Fsrc%2Falgo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9cfd57eeaa53657c0af7b9c4ba74d6b7b9889ed/crates%2Fra_syntax%2Fsrc%2Falgo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Falgo.rs?ref=c9cfd57eeaa53657c0af7b9c4ba74d6b7b9889ed", "patch": "@@ -1,17 +1,18 @@\n pub mod visit;\n \n+use std::ops::RangeInclusive;\n+\n use itertools::Itertools;\n \n-use crate::{AstNode, Direction, SyntaxElement, SyntaxNode, SyntaxToken, TextRange, TextUnit};\n+use crate::{\n+    AstNode, Direction, InsertPosition, NodeOrToken, SourceFile, SyntaxElement, SyntaxNode,\n+    SyntaxNodePtr, SyntaxToken, TextRange, TextUnit,\n+};\n \n pub use rowan::TokenAtOffset;\n \n pub fn find_token_at_offset(node: &SyntaxNode, offset: TextUnit) -> TokenAtOffset<SyntaxToken> {\n-    match node.0.token_at_offset(offset) {\n-        TokenAtOffset::None => TokenAtOffset::None,\n-        TokenAtOffset::Single(n) => TokenAtOffset::Single(SyntaxToken(n)),\n-        TokenAtOffset::Between(l, r) => TokenAtOffset::Between(SyntaxToken(l), SyntaxToken(r)),\n-    }\n+    node.token_at_offset(offset)\n }\n \n /// Returns ancestors of the node at the offset, sorted by length. This should\n@@ -44,20 +45,110 @@ pub fn find_node_at_offset<N: AstNode>(syntax: &SyntaxNode, offset: TextUnit) ->\n /// Finds the first sibling in the given direction which is not `trivia`\n pub fn non_trivia_sibling(element: SyntaxElement, direction: Direction) -> Option<SyntaxElement> {\n     return match element {\n-        SyntaxElement::Node(node) => node.siblings_with_tokens(direction).skip(1).find(not_trivia),\n-        SyntaxElement::Token(token) => {\n-            token.siblings_with_tokens(direction).skip(1).find(not_trivia)\n-        }\n+        NodeOrToken::Node(node) => node.siblings_with_tokens(direction).skip(1).find(not_trivia),\n+        NodeOrToken::Token(token) => token.siblings_with_tokens(direction).skip(1).find(not_trivia),\n     };\n \n     fn not_trivia(element: &SyntaxElement) -> bool {\n         match element {\n-            SyntaxElement::Node(_) => true,\n-            SyntaxElement::Token(token) => !token.kind().is_trivia(),\n+            NodeOrToken::Node(_) => true,\n+            NodeOrToken::Token(token) => !token.kind().is_trivia(),\n         }\n     }\n }\n \n pub fn find_covering_element(root: &SyntaxNode, range: TextRange) -> SyntaxElement {\n-    SyntaxElement::new(root.0.covering_node(range))\n+    root.covering_element(range)\n+}\n+\n+/// Adds specified children (tokens or nodes) to the current node at the\n+/// specific position.\n+///\n+/// This is a type-unsafe low-level editing API, if you need to use it,\n+/// prefer to create a type-safe abstraction on top of it instead.\n+pub fn insert_children(\n+    parent: &SyntaxNode,\n+    position: InsertPosition<SyntaxElement>,\n+    to_insert: impl Iterator<Item = SyntaxElement>,\n+) -> SyntaxNode {\n+    let mut delta = TextUnit::default();\n+    let to_insert = to_insert.map(|element| {\n+        delta += element.text_range().len();\n+        to_green_element(element)\n+    });\n+\n+    let old_children = parent.green().children();\n+\n+    let new_children = match &position {\n+        InsertPosition::First => {\n+            to_insert.chain(old_children.iter().cloned()).collect::<Box<[_]>>()\n+        }\n+        InsertPosition::Last => old_children.iter().cloned().chain(to_insert).collect::<Box<[_]>>(),\n+        InsertPosition::Before(anchor) | InsertPosition::After(anchor) => {\n+            let take_anchor = if let InsertPosition::After(_) = position { 1 } else { 0 };\n+            let split_at = position_of_child(parent, anchor.clone()) + take_anchor;\n+            let (before, after) = old_children.split_at(split_at);\n+            before\n+                .iter()\n+                .cloned()\n+                .chain(to_insert)\n+                .chain(after.iter().cloned())\n+                .collect::<Box<[_]>>()\n+        }\n+    };\n+\n+    with_children(parent, new_children)\n+}\n+\n+/// Replaces all nodes in `to_delete` with nodes from `to_insert`\n+///\n+/// This is a type-unsafe low-level editing API, if you need to use it,\n+/// prefer to create a type-safe abstraction on top of it instead.\n+pub fn replace_children(\n+    parent: &SyntaxNode,\n+    to_delete: RangeInclusive<SyntaxElement>,\n+    to_insert: impl Iterator<Item = SyntaxElement>,\n+) -> SyntaxNode {\n+    let start = position_of_child(parent, to_delete.start().clone());\n+    let end = position_of_child(parent, to_delete.end().clone());\n+    let old_children = parent.green().children();\n+\n+    let new_children = old_children[..start]\n+        .iter()\n+        .cloned()\n+        .chain(to_insert.map(to_green_element))\n+        .chain(old_children[end + 1..].iter().cloned())\n+        .collect::<Box<[_]>>();\n+    with_children(parent, new_children)\n+}\n+\n+fn with_children(\n+    parent: &SyntaxNode,\n+    new_children: Box<[NodeOrToken<rowan::GreenNode, rowan::GreenToken>]>,\n+) -> SyntaxNode {\n+    let len = new_children.iter().map(|it| it.text_len()).sum::<TextUnit>();\n+    let new_node =\n+        rowan::GreenNode::new(rowan::cursor::SyntaxKind(parent.kind() as u16), new_children);\n+    let new_file_node = parent.replace_with(new_node);\n+    let file = SourceFile::new(new_file_node);\n+\n+    // FIXME: use a more elegant way to re-fetch the node (#1185), make\n+    // `range` private afterwards\n+    let mut ptr = SyntaxNodePtr::new(parent);\n+    ptr.range = TextRange::offset_len(ptr.range().start(), len);\n+    ptr.to_node(file.syntax()).to_owned()\n+}\n+\n+fn position_of_child(parent: &SyntaxNode, child: SyntaxElement) -> usize {\n+    parent\n+        .children_with_tokens()\n+        .position(|it| it == child)\n+        .expect(\"element is not a child of current element\")\n+}\n+\n+fn to_green_element(element: SyntaxElement) -> NodeOrToken<rowan::GreenNode, rowan::GreenToken> {\n+    match element {\n+        NodeOrToken::Node(it) => it.green().clone().into(),\n+        NodeOrToken::Token(it) => it.green().clone().into(),\n+    }\n }"}, {"sha": "f9190d877914fb8de228e9d6bfc72c7cb9ff7154", "filename": "crates/ra_syntax/src/ast/expr_extensions.rs", "status": "modified", "additions": 5, "deletions": 8, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/c9cfd57eeaa53657c0af7b9c4ba74d6b7b9889ed/crates%2Fra_syntax%2Fsrc%2Fast%2Fexpr_extensions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9cfd57eeaa53657c0af7b9c4ba74d6b7b9889ed/crates%2Fra_syntax%2Fsrc%2Fast%2Fexpr_extensions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Fast%2Fexpr_extensions.rs?ref=c9cfd57eeaa53657c0af7b9c4ba74d6b7b9889ed", "patch": "@@ -2,7 +2,7 @@\n \n use crate::{\n     ast::{self, child_opt, children, AstChildren, AstNode},\n-    SmolStr, SyntaxElement,\n+    SmolStr,\n     SyntaxKind::*,\n     SyntaxToken, T,\n };\n@@ -229,14 +229,11 @@ pub enum LiteralKind {\n \n impl ast::Literal {\n     pub fn token(&self) -> SyntaxToken {\n-        let elem = self\n-            .syntax()\n+        self.syntax()\n             .children_with_tokens()\n-            .find(|e| e.kind() != ATTR && !e.kind().is_trivia());\n-        match elem {\n-            Some(SyntaxElement::Token(token)) => token,\n-            _ => unreachable!(),\n-        }\n+            .find(|e| e.kind() != ATTR && !e.kind().is_trivia())\n+            .and_then(|e| e.into_token())\n+            .unwrap()\n     }\n \n     pub fn kind(&self) -> LiteralKind {"}, {"sha": "d4873b39a81bbe4078ba314cd7be4b75047730de", "filename": "crates/ra_syntax/src/ast/extensions.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/c9cfd57eeaa53657c0af7b9c4ba74d6b7b9889ed/crates%2Fra_syntax%2Fsrc%2Fast%2Fextensions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9cfd57eeaa53657c0af7b9c4ba74d6b7b9889ed/crates%2Fra_syntax%2Fsrc%2Fast%2Fextensions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Fast%2Fextensions.rs?ref=c9cfd57eeaa53657c0af7b9c4ba74d6b7b9889ed", "patch": "@@ -24,10 +24,7 @@ impl ast::NameRef {\n }\n \n fn text_of_first_token(node: &SyntaxNode) -> &SmolStr {\n-    match node.0.green().children().first() {\n-        Some(rowan::GreenElement::Token(it)) => it.text(),\n-        _ => panic!(),\n-    }\n+    node.green().children().first().and_then(|it| it.as_token()).unwrap().text()\n }\n \n impl ast::Attr {"}, {"sha": "21c07d69a7a1b7a11dd6078f177b91fe564371d9", "filename": "crates/ra_syntax/src/lib.rs", "status": "modified", "additions": 7, "deletions": 9, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/c9cfd57eeaa53657c0af7b9c4ba74d6b7b9889ed/crates%2Fra_syntax%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9cfd57eeaa53657c0af7b9c4ba74d6b7b9889ed/crates%2Fra_syntax%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Flib.rs?ref=c9cfd57eeaa53657c0af7b9c4ba74d6b7b9889ed", "patch": "@@ -20,7 +20,6 @@\n //! [Swift]: <https://github.com/apple/swift/blob/13d593df6f359d0cb2fc81cfaac273297c539455/lib/Syntax/README.md>\n \n mod syntax_node;\n-mod syntax_text;\n mod syntax_error;\n mod parsing;\n mod validation;\n@@ -43,14 +42,13 @@ pub use crate::{\n     ptr::{AstPtr, SyntaxNodePtr},\n     syntax_error::{Location, SyntaxError, SyntaxErrorKind},\n     syntax_node::{\n-        Direction, InsertPosition, SyntaxElement, SyntaxNode, SyntaxToken, SyntaxTreeBuilder,\n-        WalkEvent,\n+        Direction, InsertPosition, NodeOrToken, SyntaxElement, SyntaxNode, SyntaxToken,\n+        SyntaxTreeBuilder, WalkEvent,\n     },\n-    syntax_text::SyntaxText,\n };\n pub use ra_parser::SyntaxKind;\n pub use ra_parser::T;\n-pub use rowan::{SmolStr, TextRange, TextUnit};\n+pub use rowan::{SmolStr, SyntaxText, TextRange, TextUnit};\n \n /// `Parse` is the result of the parsing: a syntax tree and a collection of\n /// errors.\n@@ -76,7 +74,7 @@ impl<T> Parse<T> {\n     }\n \n     pub fn syntax_node(&self) -> SyntaxNode {\n-        SyntaxNode::new(self.green.clone())\n+        SyntaxNode::new_root(self.green.clone())\n     }\n }\n \n@@ -147,7 +145,7 @@ pub use crate::ast::SourceFile;\n \n impl SourceFile {\n     fn new(green: GreenNode) -> SourceFile {\n-        let root = SyntaxNode::new(green);\n+        let root = SyntaxNode::new_root(green);\n         if cfg!(debug_assertions) {\n             validation::validate_block_structure(&root);\n         }\n@@ -267,8 +265,8 @@ fn api_walkthrough() {\n         match event {\n             WalkEvent::Enter(node) => {\n                 let text = match &node {\n-                    SyntaxElement::Node(it) => it.text().to_string(),\n-                    SyntaxElement::Token(it) => it.text().to_string(),\n+                    NodeOrToken::Node(it) => it.text().to_string(),\n+                    NodeOrToken::Token(it) => it.text().to_string(),\n                 };\n                 buf += &format!(\"{:indent$}{:?} {:?}\\n\", \" \", text, node.kind(), indent = indent);\n                 indent += 2;"}, {"sha": "65b8aa10d0f16e11ecc6f1a4e76ed848c3a7808f", "filename": "crates/ra_syntax/src/parsing/reparsing.rs", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/c9cfd57eeaa53657c0af7b9c4ba74d6b7b9889ed/crates%2Fra_syntax%2Fsrc%2Fparsing%2Freparsing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9cfd57eeaa53657c0af7b9c4ba74d6b7b9889ed/crates%2Fra_syntax%2Fsrc%2Fparsing%2Freparsing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Fparsing%2Freparsing.rs?ref=c9cfd57eeaa53657c0af7b9c4ba74d6b7b9889ed", "patch": "@@ -16,7 +16,7 @@ use crate::{\n         text_token_source::TextTokenSource,\n         text_tree_sink::TextTreeSink,\n     },\n-    syntax_node::{GreenNode, GreenToken, SyntaxElement, SyntaxNode},\n+    syntax_node::{GreenNode, GreenToken, NodeOrToken, SyntaxElement, SyntaxNode},\n     SyntaxError,\n     SyntaxKind::*,\n     TextRange, TextUnit, T,\n@@ -70,7 +70,8 @@ fn reparse_token<'node>(\n                 }\n             }\n \n-            let new_token = GreenToken::new(rowan::SyntaxKind(token.kind().into()), text.into());\n+            let new_token =\n+                GreenToken::new(rowan::cursor::SyntaxKind(token.kind().into()), text.into());\n             Some((token.replace_with(new_token), token.text_range()))\n         }\n         _ => None,\n@@ -98,8 +99,8 @@ fn get_text_after_edit(element: SyntaxElement, edit: &AtomTextEdit) -> String {\n     let edit =\n         AtomTextEdit::replace(edit.delete - element.text_range().start(), edit.insert.clone());\n     let text = match element {\n-        SyntaxElement::Token(token) => token.text().to_string(),\n-        SyntaxElement::Node(node) => node.text().to_string(),\n+        NodeOrToken::Token(token) => token.text().to_string(),\n+        NodeOrToken::Node(node) => node.text().to_string(),\n     };\n     edit.apply(text)\n }\n@@ -114,8 +115,8 @@ fn is_contextual_kw(text: &str) -> bool {\n fn find_reparsable_node(node: &SyntaxNode, range: TextRange) -> Option<(SyntaxNode, Reparser)> {\n     let node = algo::find_covering_element(node, range);\n     let mut ancestors = match node {\n-        SyntaxElement::Token(it) => it.parent().ancestors(),\n-        SyntaxElement::Node(it) => it.ancestors(),\n+        NodeOrToken::Token(it) => it.parent().ancestors(),\n+        NodeOrToken::Node(it) => it.ancestors(),\n     };\n     ancestors.find_map(|node| {\n         let first_child = node.first_child_or_token().map(|it| it.kind());"}, {"sha": "689dbefde7edbd53cc54fa2ccd516000c38b2e6f", "filename": "crates/ra_syntax/src/syntax_node.rs", "status": "modified", "additions": 22, "deletions": 461, "changes": 483, "blob_url": "https://github.com/rust-lang/rust/blob/c9cfd57eeaa53657c0af7b9c4ba74d6b7b9889ed/crates%2Fra_syntax%2Fsrc%2Fsyntax_node.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9cfd57eeaa53657c0af7b9c4ba74d6b7b9889ed/crates%2Fra_syntax%2Fsrc%2Fsyntax_node.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Fsyntax_node.rs?ref=c9cfd57eeaa53657c0af7b9c4ba74d6b7b9889ed", "patch": "@@ -6,15 +6,12 @@\n //! The *real* implementation is in the (language-agnostic) `rowan` crate, this\n //! modules just wraps its API.\n \n-use std::{fmt, iter::successors, ops::RangeInclusive};\n-\n use ra_parser::ParseError;\n-use rowan::GreenNodeBuilder;\n+use rowan::{GreenNodeBuilder, Language};\n \n use crate::{\n     syntax_error::{SyntaxError, SyntaxErrorKind},\n-    AstNode, Parse, SmolStr, SourceFile, SyntaxKind, SyntaxNodePtr, SyntaxText, TextRange,\n-    TextUnit,\n+    Parse, SmolStr, SyntaxKind, TextUnit,\n };\n \n pub use rowan::WalkEvent;\n@@ -28,465 +25,27 @@ pub enum InsertPosition<T> {\n     After(T),\n }\n \n-#[derive(PartialEq, Eq, Hash, Clone)]\n-pub struct SyntaxNode(pub(crate) rowan::cursor::SyntaxNode);\n-\n-impl fmt::Debug for SyntaxNode {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        if f.alternate() {\n-            let mut level = 0;\n-            for event in self.preorder_with_tokens() {\n-                match event {\n-                    WalkEvent::Enter(element) => {\n-                        for _ in 0..level {\n-                            write!(f, \"  \")?;\n-                        }\n-                        match element {\n-                            SyntaxElement::Node(node) => writeln!(f, \"{:?}\", node)?,\n-                            SyntaxElement::Token(token) => writeln!(f, \"{:?}\", token)?,\n-                        }\n-                        level += 1;\n-                    }\n-                    WalkEvent::Leave(_) => level -= 1,\n-                }\n-            }\n-            assert_eq!(level, 0);\n-            Ok(())\n-        } else {\n-            write!(f, \"{:?}@{:?}\", self.kind(), self.text_range())\n-        }\n-    }\n-}\n-\n-impl fmt::Display for SyntaxNode {\n-    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n-        fmt::Display::fmt(&self.text(), fmt)\n-    }\n-}\n-\n-#[derive(Debug, Clone, Copy, PartialEq, Eq)]\n-pub enum Direction {\n-    Next,\n-    Prev,\n-}\n-\n-impl SyntaxNode {\n-    pub(crate) fn new(green: GreenNode) -> SyntaxNode {\n-        let inner = rowan::cursor::SyntaxNode::new_root(green);\n-        SyntaxNode(inner)\n-    }\n-\n-    pub fn kind(&self) -> SyntaxKind {\n-        self.0.kind().0.into()\n-    }\n-\n-    pub fn text_range(&self) -> TextRange {\n-        self.0.text_range()\n-    }\n-\n-    pub fn text(&self) -> SyntaxText {\n-        SyntaxText::new(self.clone())\n-    }\n-\n-    pub fn parent(&self) -> Option<SyntaxNode> {\n-        self.0.parent().map(SyntaxNode)\n-    }\n-\n-    pub fn first_child(&self) -> Option<SyntaxNode> {\n-        self.0.first_child().map(SyntaxNode)\n-    }\n-\n-    pub fn first_child_or_token(&self) -> Option<SyntaxElement> {\n-        self.0.first_child_or_token().map(SyntaxElement::new)\n-    }\n-\n-    pub fn last_child(&self) -> Option<SyntaxNode> {\n-        self.0.last_child().map(SyntaxNode)\n-    }\n-\n-    pub fn last_child_or_token(&self) -> Option<SyntaxElement> {\n-        self.0.last_child_or_token().map(SyntaxElement::new)\n-    }\n-\n-    pub fn next_sibling(&self) -> Option<SyntaxNode> {\n-        self.0.next_sibling().map(SyntaxNode)\n-    }\n-\n-    pub fn next_sibling_or_token(&self) -> Option<SyntaxElement> {\n-        self.0.next_sibling_or_token().map(SyntaxElement::new)\n-    }\n-\n-    pub fn prev_sibling(&self) -> Option<SyntaxNode> {\n-        self.0.prev_sibling().map(SyntaxNode)\n-    }\n-\n-    pub fn prev_sibling_or_token(&self) -> Option<SyntaxElement> {\n-        self.0.prev_sibling_or_token().map(SyntaxElement::new)\n-    }\n-\n-    pub fn children(&self) -> SyntaxNodeChildren {\n-        SyntaxNodeChildren(self.0.children())\n-    }\n-\n-    pub fn children_with_tokens(&self) -> SyntaxElementChildren {\n-        SyntaxElementChildren(self.0.children_with_tokens())\n-    }\n-\n-    pub fn first_token(&self) -> Option<SyntaxToken> {\n-        self.0.first_token().map(SyntaxToken)\n-    }\n-\n-    pub fn last_token(&self) -> Option<SyntaxToken> {\n-        self.0.last_token().map(SyntaxToken)\n-    }\n-\n-    pub fn ancestors(&self) -> impl Iterator<Item = SyntaxNode> {\n-        successors(Some(self.clone()), |node| node.parent())\n-    }\n-\n-    pub fn descendants(&self) -> impl Iterator<Item = SyntaxNode> {\n-        self.preorder().filter_map(|event| match event {\n-            WalkEvent::Enter(node) => Some(node),\n-            WalkEvent::Leave(_) => None,\n-        })\n-    }\n-\n-    pub fn descendants_with_tokens(&self) -> impl Iterator<Item = SyntaxElement> {\n-        self.preorder_with_tokens().filter_map(|event| match event {\n-            WalkEvent::Enter(it) => Some(it),\n-            WalkEvent::Leave(_) => None,\n-        })\n-    }\n-\n-    pub fn siblings(&self, direction: Direction) -> impl Iterator<Item = SyntaxNode> {\n-        successors(Some(self.clone()), move |node| match direction {\n-            Direction::Next => node.next_sibling(),\n-            Direction::Prev => node.prev_sibling(),\n-        })\n-    }\n-\n-    pub fn siblings_with_tokens(\n-        &self,\n-        direction: Direction,\n-    ) -> impl Iterator<Item = SyntaxElement> {\n-        let me: SyntaxElement = self.clone().into();\n-        successors(Some(me), move |el| match direction {\n-            Direction::Next => el.next_sibling_or_token(),\n-            Direction::Prev => el.prev_sibling_or_token(),\n-        })\n-    }\n+#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]\n+pub enum RustLanguage {}\n+impl Language for RustLanguage {\n+    type Kind = SyntaxKind;\n \n-    pub fn preorder(&self) -> impl Iterator<Item = WalkEvent<SyntaxNode>> {\n-        self.0.preorder().map(|event| match event {\n-            WalkEvent::Enter(n) => WalkEvent::Enter(SyntaxNode(n)),\n-            WalkEvent::Leave(n) => WalkEvent::Leave(SyntaxNode(n)),\n-        })\n+    fn kind_from_raw(raw: rowan::cursor::SyntaxKind) -> SyntaxKind {\n+        SyntaxKind::from(raw.0)\n     }\n \n-    pub fn preorder_with_tokens(&self) -> impl Iterator<Item = WalkEvent<SyntaxElement>> {\n-        self.0.preorder_with_tokens().map(|event| match event {\n-            WalkEvent::Enter(n) => WalkEvent::Enter(SyntaxElement::new(n)),\n-            WalkEvent::Leave(n) => WalkEvent::Leave(SyntaxElement::new(n)),\n-        })\n-    }\n-\n-    pub(crate) fn replace_with(&self, replacement: GreenNode) -> GreenNode {\n-        self.0.replace_with(replacement)\n-    }\n-\n-    /// Adds specified children (tokens or nodes) to the current node at the\n-    /// specific position.\n-    ///\n-    /// This is a type-unsafe low-level editing API, if you need to use it,\n-    /// prefer to create a type-safe abstraction on top of it instead.\n-    pub fn insert_children(\n-        &self,\n-        position: InsertPosition<SyntaxElement>,\n-        to_insert: impl Iterator<Item = SyntaxElement>,\n-    ) -> SyntaxNode {\n-        let mut delta = TextUnit::default();\n-        let to_insert = to_insert.map(|element| {\n-            delta += element.text_len();\n-            to_green_element(element)\n-        });\n-\n-        let old_children = self.0.green().children();\n-\n-        let new_children = match &position {\n-            InsertPosition::First => {\n-                to_insert.chain(old_children.iter().cloned()).collect::<Box<[_]>>()\n-            }\n-            InsertPosition::Last => {\n-                old_children.iter().cloned().chain(to_insert).collect::<Box<[_]>>()\n-            }\n-            InsertPosition::Before(anchor) | InsertPosition::After(anchor) => {\n-                let take_anchor = if let InsertPosition::After(_) = position { 1 } else { 0 };\n-                let split_at = self.position_of_child(anchor.clone()) + take_anchor;\n-                let (before, after) = old_children.split_at(split_at);\n-                before\n-                    .iter()\n-                    .cloned()\n-                    .chain(to_insert)\n-                    .chain(after.iter().cloned())\n-                    .collect::<Box<[_]>>()\n-            }\n-        };\n-\n-        self.with_children(new_children)\n-    }\n-\n-    /// Replaces all nodes in `to_delete` with nodes from `to_insert`\n-    ///\n-    /// This is a type-unsafe low-level editing API, if you need to use it,\n-    /// prefer to create a type-safe abstraction on top of it instead.\n-    pub fn replace_children(\n-        &self,\n-        to_delete: RangeInclusive<SyntaxElement>,\n-        to_insert: impl Iterator<Item = SyntaxElement>,\n-    ) -> SyntaxNode {\n-        let start = self.position_of_child(to_delete.start().clone());\n-        let end = self.position_of_child(to_delete.end().clone());\n-        let old_children = self.0.green().children();\n-\n-        let new_children = old_children[..start]\n-            .iter()\n-            .cloned()\n-            .chain(to_insert.map(to_green_element))\n-            .chain(old_children[end + 1..].iter().cloned())\n-            .collect::<Box<[_]>>();\n-        self.with_children(new_children)\n-    }\n-\n-    fn with_children(&self, new_children: Box<[rowan::GreenElement]>) -> SyntaxNode {\n-        let len = new_children.iter().map(|it| it.text_len()).sum::<TextUnit>();\n-        let new_node = GreenNode::new(rowan::SyntaxKind(self.kind() as u16), new_children);\n-        let new_file_node = self.replace_with(new_node);\n-        let file = SourceFile::new(new_file_node);\n-\n-        // FIXME: use a more elegant way to re-fetch the node (#1185), make\n-        // `range` private afterwards\n-        let mut ptr = SyntaxNodePtr::new(self);\n-        ptr.range = TextRange::offset_len(ptr.range().start(), len);\n-        ptr.to_node(file.syntax()).to_owned()\n-    }\n-\n-    fn position_of_child(&self, child: SyntaxElement) -> usize {\n-        self.children_with_tokens()\n-            .position(|it| it == child)\n-            .expect(\"element is not a child of current element\")\n+    fn kind_to_raw(kind: SyntaxKind) -> rowan::cursor::SyntaxKind {\n+        rowan::cursor::SyntaxKind(kind.into())\n     }\n }\n \n-fn to_green_element(element: SyntaxElement) -> rowan::GreenElement {\n-    match element {\n-        SyntaxElement::Node(node) => node.0.green().clone().into(),\n-        SyntaxElement::Token(tok) => {\n-            GreenToken::new(rowan::SyntaxKind(tok.kind() as u16), tok.text().clone()).into()\n-        }\n-    }\n-}\n-\n-#[derive(Clone, PartialEq, Eq, Hash)]\n-pub struct SyntaxToken(pub(crate) rowan::cursor::SyntaxToken);\n-\n-impl fmt::Debug for SyntaxToken {\n-    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n-        write!(fmt, \"{:?}@{:?}\", self.kind(), self.text_range())?;\n-        if self.text().len() < 25 {\n-            return write!(fmt, \" {:?}\", self.text());\n-        }\n-        let text = self.text().as_str();\n-        for idx in 21..25 {\n-            if text.is_char_boundary(idx) {\n-                let text = format!(\"{} ...\", &text[..idx]);\n-                return write!(fmt, \" {:?}\", text);\n-            }\n-        }\n-        unreachable!()\n-    }\n-}\n+pub type SyntaxNode = rowan::SyntaxNode<RustLanguage>;\n+pub type SyntaxToken = rowan::SyntaxToken<RustLanguage>;\n+pub type SyntaxElement = rowan::NodeOrToken<SyntaxNode, SyntaxToken>;\n+pub type SyntaxNodeChildren = rowan::SyntaxNodeChildren<RustLanguage>;\n+pub type SyntaxElementChildren = rowan::SyntaxElementChildren<RustLanguage>;\n \n-impl fmt::Display for SyntaxToken {\n-    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n-        fmt::Display::fmt(self.text(), fmt)\n-    }\n-}\n-\n-impl SyntaxToken {\n-    pub fn kind(&self) -> SyntaxKind {\n-        self.0.kind().0.into()\n-    }\n-\n-    pub fn text(&self) -> &SmolStr {\n-        self.0.text()\n-    }\n-\n-    pub fn text_range(&self) -> TextRange {\n-        self.0.text_range()\n-    }\n-\n-    pub fn parent(&self) -> SyntaxNode {\n-        SyntaxNode(self.0.parent())\n-    }\n-\n-    pub fn next_sibling_or_token(&self) -> Option<SyntaxElement> {\n-        self.0.next_sibling_or_token().map(SyntaxElement::new)\n-    }\n-\n-    pub fn prev_sibling_or_token(&self) -> Option<SyntaxElement> {\n-        self.0.prev_sibling_or_token().map(SyntaxElement::new)\n-    }\n-\n-    pub fn siblings_with_tokens(\n-        &self,\n-        direction: Direction,\n-    ) -> impl Iterator<Item = SyntaxElement> {\n-        let me: SyntaxElement = self.clone().into();\n-        successors(Some(me), move |el| match direction {\n-            Direction::Next => el.next_sibling_or_token(),\n-            Direction::Prev => el.prev_sibling_or_token(),\n-        })\n-    }\n-\n-    pub fn next_token(&self) -> Option<SyntaxToken> {\n-        self.0.next_token().map(SyntaxToken)\n-    }\n-\n-    pub fn prev_token(&self) -> Option<SyntaxToken> {\n-        self.0.prev_token().map(SyntaxToken)\n-    }\n-\n-    pub(crate) fn replace_with(&self, new_token: GreenToken) -> GreenNode {\n-        self.0.replace_with(new_token)\n-    }\n-}\n-\n-#[derive(Debug, PartialEq, Eq, Hash, Clone)]\n-pub enum SyntaxElement {\n-    Node(SyntaxNode),\n-    Token(SyntaxToken),\n-}\n-\n-impl From<SyntaxNode> for SyntaxElement {\n-    fn from(node: SyntaxNode) -> Self {\n-        SyntaxElement::Node(node)\n-    }\n-}\n-\n-impl From<SyntaxToken> for SyntaxElement {\n-    fn from(token: SyntaxToken) -> Self {\n-        SyntaxElement::Token(token)\n-    }\n-}\n-\n-impl fmt::Display for SyntaxElement {\n-    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n-        match self {\n-            SyntaxElement::Node(it) => fmt::Display::fmt(it, fmt),\n-            SyntaxElement::Token(it) => fmt::Display::fmt(it, fmt),\n-        }\n-    }\n-}\n-\n-impl SyntaxElement {\n-    pub(crate) fn new(el: rowan::cursor::SyntaxElement) -> Self {\n-        match el {\n-            rowan::cursor::SyntaxElement::Node(it) => SyntaxElement::Node(SyntaxNode(it)),\n-            rowan::cursor::SyntaxElement::Token(it) => SyntaxElement::Token(SyntaxToken(it)),\n-        }\n-    }\n-\n-    pub fn kind(&self) -> SyntaxKind {\n-        match self {\n-            SyntaxElement::Node(it) => it.kind(),\n-            SyntaxElement::Token(it) => it.kind(),\n-        }\n-    }\n-\n-    pub fn as_node(&self) -> Option<&SyntaxNode> {\n-        match self {\n-            SyntaxElement::Node(node) => Some(node),\n-            SyntaxElement::Token(_) => None,\n-        }\n-    }\n-\n-    pub fn into_node(self) -> Option<SyntaxNode> {\n-        match self {\n-            SyntaxElement::Node(node) => Some(node),\n-            SyntaxElement::Token(_) => None,\n-        }\n-    }\n-\n-    pub fn as_token(&self) -> Option<&SyntaxToken> {\n-        match self {\n-            SyntaxElement::Node(_) => None,\n-            SyntaxElement::Token(token) => Some(token),\n-        }\n-    }\n-\n-    pub fn into_token(self) -> Option<SyntaxToken> {\n-        match self {\n-            SyntaxElement::Node(_) => None,\n-            SyntaxElement::Token(token) => Some(token),\n-        }\n-    }\n-\n-    pub fn next_sibling_or_token(&self) -> Option<SyntaxElement> {\n-        match self {\n-            SyntaxElement::Node(it) => it.next_sibling_or_token(),\n-            SyntaxElement::Token(it) => it.next_sibling_or_token(),\n-        }\n-    }\n-\n-    pub fn prev_sibling_or_token(&self) -> Option<SyntaxElement> {\n-        match self {\n-            SyntaxElement::Node(it) => it.prev_sibling_or_token(),\n-            SyntaxElement::Token(it) => it.prev_sibling_or_token(),\n-        }\n-    }\n-\n-    pub fn ancestors(&self) -> impl Iterator<Item = SyntaxNode> {\n-        match self {\n-            SyntaxElement::Node(it) => it.clone(),\n-            SyntaxElement::Token(it) => it.parent(),\n-        }\n-        .ancestors()\n-    }\n-\n-    pub fn text_range(&self) -> TextRange {\n-        match self {\n-            SyntaxElement::Node(it) => it.text_range(),\n-            SyntaxElement::Token(it) => it.text_range(),\n-        }\n-    }\n-\n-    fn text_len(&self) -> TextUnit {\n-        match self {\n-            SyntaxElement::Node(node) => node.0.green().text_len(),\n-            SyntaxElement::Token(token) => TextUnit::of_str(token.0.text()),\n-        }\n-    }\n-}\n-\n-#[derive(Clone, Debug)]\n-pub struct SyntaxNodeChildren(rowan::cursor::SyntaxNodeChildren);\n-\n-impl Iterator for SyntaxNodeChildren {\n-    type Item = SyntaxNode;\n-    fn next(&mut self) -> Option<SyntaxNode> {\n-        self.0.next().map(SyntaxNode)\n-    }\n-}\n-\n-#[derive(Clone, Debug)]\n-pub struct SyntaxElementChildren(rowan::cursor::SyntaxElementChildren);\n-\n-impl Iterator for SyntaxElementChildren {\n-    type Item = SyntaxElement;\n-    fn next(&mut self) -> Option<SyntaxElement> {\n-        self.0.next().map(SyntaxElement::new)\n-    }\n-}\n+pub use rowan::{Direction, NodeOrToken};\n \n pub struct SyntaxTreeBuilder {\n     errors: Vec<SyntaxError>,\n@@ -507,19 +66,21 @@ impl SyntaxTreeBuilder {\n \n     pub fn finish(self) -> Parse<SyntaxNode> {\n         let (green, errors) = self.finish_raw();\n-        let node = SyntaxNode::new(green);\n+        let node = SyntaxNode::new_root(green);\n         if cfg!(debug_assertions) {\n             crate::validation::validate_block_structure(&node);\n         }\n-        Parse::new(node.0.green().clone(), errors)\n+        Parse::new(node.green().clone(), errors)\n     }\n \n     pub fn token(&mut self, kind: SyntaxKind, text: SmolStr) {\n-        self.inner.token(rowan::SyntaxKind(kind.into()), text)\n+        let kind = RustLanguage::kind_to_raw(kind);\n+        self.inner.token(kind, text)\n     }\n \n     pub fn start_node(&mut self, kind: SyntaxKind) {\n-        self.inner.start_node(rowan::SyntaxKind(kind.into()))\n+        let kind = RustLanguage::kind_to_raw(kind);\n+        self.inner.start_node(kind)\n     }\n \n     pub fn finish_node(&mut self) {"}, {"sha": "652cb7a1e0845d59008bb5098404497c1ece1b5b", "filename": "crates/ra_syntax/src/syntax_text.rs", "status": "removed", "additions": 0, "deletions": 178, "changes": 178, "blob_url": "https://github.com/rust-lang/rust/blob/7bde8012cb28c44de7ffc779003781d385323808/crates%2Fra_syntax%2Fsrc%2Fsyntax_text.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bde8012cb28c44de7ffc779003781d385323808/crates%2Fra_syntax%2Fsrc%2Fsyntax_text.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Fsyntax_text.rs?ref=7bde8012cb28c44de7ffc779003781d385323808", "patch": "@@ -1,178 +0,0 @@\n-use std::{\n-    fmt,\n-    ops::{self, Bound},\n-};\n-\n-use crate::{SmolStr, SyntaxElement, SyntaxNode, TextRange, TextUnit};\n-\n-#[derive(Clone)]\n-pub struct SyntaxText {\n-    node: SyntaxNode,\n-    range: TextRange,\n-}\n-\n-impl SyntaxText {\n-    pub(crate) fn new(node: SyntaxNode) -> SyntaxText {\n-        let range = node.text_range();\n-        SyntaxText { node, range }\n-    }\n-\n-    pub fn try_fold_chunks<T, F, E>(&self, init: T, mut f: F) -> Result<T, E>\n-    where\n-        F: FnMut(T, &str) -> Result<T, E>,\n-    {\n-        self.node.descendants_with_tokens().try_fold(init, move |acc, element| {\n-            let res = match element {\n-                SyntaxElement::Token(token) => {\n-                    let range = match self.range.intersection(&token.text_range()) {\n-                        None => return Ok(acc),\n-                        Some(it) => it,\n-                    };\n-                    let slice = if range == token.text_range() {\n-                        token.text()\n-                    } else {\n-                        let range = range - token.text_range().start();\n-                        &token.text()[range]\n-                    };\n-                    f(acc, slice)?\n-                }\n-                SyntaxElement::Node(_) => acc,\n-            };\n-            Ok(res)\n-        })\n-    }\n-\n-    pub fn try_for_each_chunk<F: FnMut(&str) -> Result<(), E>, E>(\n-        &self,\n-        mut f: F,\n-    ) -> Result<(), E> {\n-        self.try_fold_chunks((), move |(), chunk| f(chunk))\n-    }\n-\n-    pub fn for_each_chunk<F: FnMut(&str)>(&self, mut f: F) {\n-        enum Void {}\n-        match self.try_for_each_chunk(|chunk| Ok::<(), Void>(f(chunk))) {\n-            Ok(()) => (),\n-            Err(void) => match void {},\n-        }\n-    }\n-\n-    pub fn to_smol_string(&self) -> SmolStr {\n-        self.to_string().into()\n-    }\n-\n-    pub fn contains_char(&self, c: char) -> bool {\n-        self.try_for_each_chunk(|chunk| if chunk.contains(c) { Err(()) } else { Ok(()) }).is_err()\n-    }\n-\n-    pub fn find_char(&self, c: char) -> Option<TextUnit> {\n-        let mut acc: TextUnit = 0.into();\n-        let res = self.try_for_each_chunk(|chunk| {\n-            if let Some(pos) = chunk.find(c) {\n-                let pos: TextUnit = (pos as u32).into();\n-                return Err(acc + pos);\n-            }\n-            acc += TextUnit::of_str(chunk);\n-            Ok(())\n-        });\n-        found(res)\n-    }\n-\n-    pub fn len(&self) -> TextUnit {\n-        self.range.len()\n-    }\n-\n-    pub fn is_empty(&self) -> bool {\n-        self.range.is_empty()\n-    }\n-\n-    pub fn slice(&self, range: impl ops::RangeBounds<TextUnit>) -> SyntaxText {\n-        let start = match range.start_bound() {\n-            Bound::Included(&b) => b,\n-            Bound::Excluded(_) => panic!(\"utf-aware slicing can't work this way\"),\n-            Bound::Unbounded => 0.into(),\n-        };\n-        let end = match range.end_bound() {\n-            Bound::Included(_) => panic!(\"utf-aware slicing can't work this way\"),\n-            Bound::Excluded(&b) => b,\n-            Bound::Unbounded => self.len(),\n-        };\n-        assert!(start <= end);\n-        let len = end - start;\n-        let start = self.range.start() + start;\n-        let end = start + len;\n-        assert!(\n-            start <= end,\n-            \"invalid slice, range: {:?}, slice: {:?}\",\n-            self.range,\n-            (range.start_bound(), range.end_bound()),\n-        );\n-        let range = TextRange::from_to(start, end);\n-        assert!(\n-            range.is_subrange(&self.range),\n-            \"invalid slice, range: {:?}, slice: {:?}\",\n-            self.range,\n-            range,\n-        );\n-        SyntaxText { node: self.node.clone(), range }\n-    }\n-\n-    pub fn char_at(&self, offset: impl Into<TextUnit>) -> Option<char> {\n-        let offset = offset.into();\n-        let mut start: TextUnit = 0.into();\n-        let res = self.try_for_each_chunk(|chunk| {\n-            let end = start + TextUnit::of_str(chunk);\n-            if start <= offset && offset < end {\n-                let off: usize = u32::from(offset - start) as usize;\n-                return Err(chunk[off..].chars().next().unwrap());\n-            }\n-            start = end;\n-            Ok(())\n-        });\n-        found(res)\n-    }\n-}\n-\n-fn found<T>(res: Result<(), T>) -> Option<T> {\n-    match res {\n-        Ok(()) => None,\n-        Err(it) => Some(it),\n-    }\n-}\n-\n-impl fmt::Debug for SyntaxText {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        fmt::Debug::fmt(&self.to_string(), f)\n-    }\n-}\n-\n-impl fmt::Display for SyntaxText {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        self.try_for_each_chunk(|chunk| fmt::Display::fmt(chunk, f))\n-    }\n-}\n-\n-impl From<SyntaxText> for String {\n-    fn from(text: SyntaxText) -> String {\n-        text.to_string()\n-    }\n-}\n-\n-impl PartialEq<str> for SyntaxText {\n-    fn eq(&self, mut rhs: &str) -> bool {\n-        self.try_for_each_chunk(|chunk| {\n-            if !rhs.starts_with(chunk) {\n-                return Err(());\n-            }\n-            rhs = &rhs[chunk.len()..];\n-            Ok(())\n-        })\n-        .is_ok()\n-    }\n-}\n-\n-impl PartialEq<&'_ str> for SyntaxText {\n-    fn eq(&self, rhs: &&str) -> bool {\n-        self == *rhs\n-    }\n-}"}]}