{"sha": "8d39bdd5f9e3a3f712d9a8e8aaea5c426fafd86c", "node_id": "MDY6Q29tbWl0NzI0NzEyOjhkMzliZGQ1ZjllM2EzZjcxMmQ5YThlOGFhZWE1YzQyNmZhZmQ4NmM=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2019-06-12T14:22:07Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2019-07-02T16:15:20Z"}, "message": "integrate reverse graph and upper-bound computation", "tree": {"sha": "4db6fb52076dee867f465dbed6fab02a73311e8d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4db6fb52076dee867f465dbed6fab02a73311e8d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8d39bdd5f9e3a3f712d9a8e8aaea5c426fafd86c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8d39bdd5f9e3a3f712d9a8e8aaea5c426fafd86c", "html_url": "https://github.com/rust-lang/rust/commit/8d39bdd5f9e3a3f712d9a8e8aaea5c426fafd86c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8d39bdd5f9e3a3f712d9a8e8aaea5c426fafd86c/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7fd0db7dd319cfb73664c8a068474dc8759ebabf", "url": "https://api.github.com/repos/rust-lang/rust/commits/7fd0db7dd319cfb73664c8a068474dc8759ebabf", "html_url": "https://github.com/rust-lang/rust/commit/7fd0db7dd319cfb73664c8a068474dc8759ebabf"}], "stats": {"total": 86, "additions": 69, "deletions": 17}, "files": [{"sha": "39818de231088311ed9b172fde17fab2684194f8", "filename": "src/librustc_mir/borrow_check/nll/region_infer/mod.rs", "status": "modified", "additions": 69, "deletions": 17, "changes": 86, "blob_url": "https://github.com/rust-lang/rust/blob/8d39bdd5f9e3a3f712d9a8e8aaea5c426fafd86c/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8d39bdd5f9e3a3f712d9a8e8aaea5c426fafd86c/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fmod.rs?ref=8d39bdd5f9e3a3f712d9a8e8aaea5c426fafd86c", "patch": "@@ -23,7 +23,9 @@ use rustc::ty::{self, subst::SubstsRef, RegionVid, Ty, TyCtxt, TypeFoldable};\n use rustc::util::common::{self, ErrorReported};\n use rustc_data_structures::bit_set::BitSet;\n use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n+use crate::rustc_data_structures::graph::WithSuccessors;\n use rustc_data_structures::graph::scc::Sccs;\n+use rustc_data_structures::graph::vec_graph::VecGraph;\n use rustc_data_structures::indexed_vec::IndexVec;\n use rustc_errors::{Diagnostic, DiagnosticBuilder};\n use syntax_pos::Span;\n@@ -60,10 +62,15 @@ pub struct RegionInferenceContext<'tcx> {\n     /// the SCC (see `constraint_sccs`) and for error reporting.\n     constraint_graph: Rc<NormalConstraintGraph>,\n \n-    /// The SCC computed from `constraints` and the constraint graph. Used to\n+    /// The SCC computed from `constraints` and the constraint\n+    /// graph. We have an edge from SCC A to SCC B if `A: B`. Used to\n     /// compute the values of each region.\n     constraint_sccs: Rc<Sccs<RegionVid, ConstraintSccIndex>>,\n \n+    /// Reverse of the SCC constraint graph -- i.e., an edge `A -> B`\n+    /// exists if `B: A`. Computed lazilly.\n+    rev_constraint_graph: Option<Rc<VecGraph<ConstraintSccIndex>>>,\n+\n     /// The \"pick R0 from [R1..Rn]\" constraints, indexed by SCC.\n     pick_constraints: Rc<PickConstraintSet<'tcx, ConstraintSccIndex>>,\n \n@@ -234,6 +241,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n             constraints,\n             constraint_graph,\n             constraint_sccs,\n+            rev_constraint_graph: None,\n             pick_constraints,\n             closure_bounds_mapping,\n             scc_universes,\n@@ -602,21 +610,19 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n                 .universal_regions_outlived_by(scc)\n                 .all(|lb| self.universal_region_relations.outlives(o_r, lb))\n         });\n+        debug!(\"apply_pick_constraint: after lb, option_regions={:?}\", option_regions);\n \n         // Now find all the *upper bounds* -- that is, each UB is a free\n         // region that must outlive pick region R0 (`UB: R0`). Therefore,\n-        // we need only keep an option O if `UB: O`.\n-        //\n-        // TODO -- need to implement the reverse graph construction for this\n-        //\n-        // let mut upper_bounds = ...;\n-        // option_regions.retain(|&o_r| {\n-        //     upper_bounds\n-        //         .all(|ub| self.universal_region_relations.outlives(\n-        //             ub,\n-        //             o_r,\n-        //         })\n-        // });\n+        // we need only keep an option O if `UB: O` for all UB.\n+        if option_regions.len() > 1 {\n+            let universal_region_relations = self.universal_region_relations.clone();\n+            for ub in self.upper_bounds(scc) {\n+                debug!(\"apply_pick_constraint: ub={:?}\", ub);\n+                option_regions.retain(|&o_r| universal_region_relations.outlives(ub, o_r));\n+            }\n+            debug!(\"apply_pick_constraint: after ub, option_regions={:?}\", option_regions);\n+        }\n \n         // If we ruled everything out, we're done.\n         if option_regions.is_empty() {\n@@ -656,8 +662,46 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n             }\n         }\n \n-        debug!(\"apply_pick_constraint: best_choice={:?}\", best_option);\n-        self.scc_values.add_element(scc, best_option)\n+        let best_option_scc = self.constraint_sccs.scc(best_option);\n+        debug!(\n+            \"apply_pick_constraint: best_choice={:?} best_option_scc={:?}\",\n+            best_option,\n+            best_option_scc,\n+        );\n+        self.scc_values.add_region(scc, best_option_scc)\n+    }\n+\n+    /// Compute and return the reverse SCC-based constraint graph (lazilly).\n+    fn upper_bounds(\n+        &mut self,\n+        scc0: ConstraintSccIndex,\n+    ) -> Vec<RegionVid> {\n+        // I wanted to return an `impl Iterator` here, but it's\n+        // annoying because the `rev_constraint_graph` is in a local\n+        // variable. We'd need a \"once-cell\" or some such thing to let\n+        // us borrow it for the right amount of time.\n+        let rev_constraint_graph = self.rev_constraint_graph();\n+        let scc_values = &self.scc_values;\n+        let mut duplicates = FxHashSet::default();\n+        rev_constraint_graph\n+            .depth_first_search(scc0)\n+            .skip(1)\n+            .flat_map(|scc1| scc_values.universal_regions_outlived_by(scc1))\n+            .filter(|&r| duplicates.insert(r))\n+            .collect()\n+    }\n+\n+    /// Compute and return the reverse SCC-based constraint graph (lazilly).\n+    fn rev_constraint_graph(\n+        &mut self,\n+    ) -> Rc<VecGraph<ConstraintSccIndex>> {\n+        if let Some(g) = &self.rev_constraint_graph {\n+            return g.clone();\n+        }\n+\n+        let rev_graph = Rc::new(self.constraint_sccs.reverse());\n+        self.rev_constraint_graph = Some(rev_graph.clone());\n+        rev_graph\n     }\n \n     /// Returns `true` if all the elements in the value of `scc_b` are nameable\n@@ -1145,8 +1189,16 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n     fn eval_outlives(&self, sup_region: RegionVid, sub_region: RegionVid) -> bool {\n         debug!(\"eval_outlives({:?}: {:?})\", sup_region, sub_region);\n \n-        debug!(\"eval_outlives: sup_region's value = {:?}\", self.region_value_str(sup_region),);\n-        debug!(\"eval_outlives: sub_region's value = {:?}\", self.region_value_str(sub_region),);\n+        debug!(\n+            \"eval_outlives: sup_region's value = {:?} universal={:?}\",\n+            self.region_value_str(sup_region),\n+            self.universal_regions.is_universal_region(sup_region),\n+        );\n+        debug!(\n+            \"eval_outlives: sub_region's value = {:?} universal={:?}\",\n+            self.region_value_str(sub_region),\n+            self.universal_regions.is_universal_region(sub_region),\n+        );\n \n         let sub_region_scc = self.constraint_sccs.scc(sub_region);\n         let sup_region_scc = self.constraint_sccs.scc(sup_region);"}]}