{"sha": "f7f0f843b70f1b6c4ac9e22789d93d7bf5569dc3", "node_id": "C_kwDOAAsO6NoAKGY3ZjBmODQzYjcwZjFiNmM0YWM5ZTIyNzg5ZDkzZDdiZjU1NjlkYzM", "commit": {"author": {"name": "Deadbeef", "email": "ent3rm4n@gmail.com", "date": "2021-12-09T14:42:17Z"}, "committer": {"name": "Deadbeef", "email": "ent3rm4n@gmail.com", "date": "2022-02-12T08:24:08Z"}, "message": "Improve error messages even more", "tree": {"sha": "f725f2399e03cccf9f4faf4babd7593705a21222", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f725f2399e03cccf9f4faf4babd7593705a21222"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f7f0f843b70f1b6c4ac9e22789d93d7bf5569dc3", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCAAdFiEE3RQPHNISvvEnSKtjbQF6ltjmwvkFAmIHbqgACgkQbQF6ltjm\nwvnn5Q//fBagTVVHUZKmgjAY8QgNsTe7EzFBytIIo7LWcHAjaAT84cbJbApxuqxZ\nWqeB1lMhhL472aN2rdPgIqs5yBgLtRicDt5Yty7cw/qzl5kOHbNnrchY83H7djfn\nW5NwSq6DMOQ5ETRFHc9EywoKdKhGSiVnrq9ZwwHVsCTypP7r4PEinYOWLIkmFOtQ\nItxQ3Xgy0JQVOtM56MjCVlb/f2TO9N0rWff20HPERJPANRqp2/jZe+2Vd/zU7QQA\nxcKIHyuaWGCB+eaP9FMEcbuoPNv8eyIEALT6asNh0ImxFv0mNFc9gRX6ByAHfEXV\nC6qo3KdYohErGKf3du1kAIbfrSRPZMkOhXXyxxQoS47oTsWs/XEzsGPKwqxjaxhy\n7PUUfWQiVsufDdBrsVAVNeCFO1Hph+xriY7FqwsFicKxmUNap35R02XmYsnRQH/W\nH7uyBC7MdTyMYhJMu+FSJ+N/A34vsyoOsbnJXatGld+SU99lM9e3zid56cw6lzQ+\nQnDXUnmlmYnZYf2MZ9PfBbvRsYWnLYOG0Ew5o9Sbp0bOEcY3gobe6r1H9MiK1XIj\nj5CemX1EO16MB9TH/bo7VcdK/9OV/nO/QzY7KcZl/HFRzbRIPvIQz/AJGE3Z2BiA\nfuDAeLLPpCjqcxi3xux8xCrdCgC1tRDku6PweRbVhYyHKLbJvnY=\n=jR9z\n-----END PGP SIGNATURE-----", "payload": "tree f725f2399e03cccf9f4faf4babd7593705a21222\nparent 1b0dcdc341ea3659fd8d91ff85605069098ca34b\nauthor Deadbeef <ent3rm4n@gmail.com> 1639060937 +0800\ncommitter Deadbeef <ent3rm4n@gmail.com> 1644654248 +1100\n\nImprove error messages even more\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f7f0f843b70f1b6c4ac9e22789d93d7bf5569dc3", "html_url": "https://github.com/rust-lang/rust/commit/f7f0f843b70f1b6c4ac9e22789d93d7bf5569dc3", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f7f0f843b70f1b6c4ac9e22789d93d7bf5569dc3/comments", "author": {"login": "fee1-dead", "id": 43851243, "node_id": "MDQ6VXNlcjQzODUxMjQz", "avatar_url": "https://avatars.githubusercontent.com/u/43851243?v=4", "gravatar_id": "", "url": "https://api.github.com/users/fee1-dead", "html_url": "https://github.com/fee1-dead", "followers_url": "https://api.github.com/users/fee1-dead/followers", "following_url": "https://api.github.com/users/fee1-dead/following{/other_user}", "gists_url": "https://api.github.com/users/fee1-dead/gists{/gist_id}", "starred_url": "https://api.github.com/users/fee1-dead/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/fee1-dead/subscriptions", "organizations_url": "https://api.github.com/users/fee1-dead/orgs", "repos_url": "https://api.github.com/users/fee1-dead/repos", "events_url": "https://api.github.com/users/fee1-dead/events{/privacy}", "received_events_url": "https://api.github.com/users/fee1-dead/received_events", "type": "User", "site_admin": false}, "committer": {"login": "fee1-dead", "id": 43851243, "node_id": "MDQ6VXNlcjQzODUxMjQz", "avatar_url": "https://avatars.githubusercontent.com/u/43851243?v=4", "gravatar_id": "", "url": "https://api.github.com/users/fee1-dead", "html_url": "https://github.com/fee1-dead", "followers_url": "https://api.github.com/users/fee1-dead/followers", "following_url": "https://api.github.com/users/fee1-dead/following{/other_user}", "gists_url": "https://api.github.com/users/fee1-dead/gists{/gist_id}", "starred_url": "https://api.github.com/users/fee1-dead/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/fee1-dead/subscriptions", "organizations_url": "https://api.github.com/users/fee1-dead/orgs", "repos_url": "https://api.github.com/users/fee1-dead/repos", "events_url": "https://api.github.com/users/fee1-dead/events{/privacy}", "received_events_url": "https://api.github.com/users/fee1-dead/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1b0dcdc341ea3659fd8d91ff85605069098ca34b", "url": "https://api.github.com/repos/rust-lang/rust/commits/1b0dcdc341ea3659fd8d91ff85605069098ca34b", "html_url": "https://github.com/rust-lang/rust/commit/1b0dcdc341ea3659fd8d91ff85605069098ca34b"}], "stats": {"total": 671, "additions": 433, "deletions": 238}, "files": [{"sha": "75913910f14c15fef5e9dcd5297467215dcd6afc", "filename": "compiler/rustc_borrowck/src/diagnostics/conflict_errors.rs", "status": "modified", "additions": 11, "deletions": 12, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/f7f0f843b70f1b6c4ac9e22789d93d7bf5569dc3/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fconflict_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f7f0f843b70f1b6c4ac9e22789d93d7bf5569dc3/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fconflict_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fconflict_errors.rs?ref=f7f0f843b70f1b6c4ac9e22789d93d7bf5569dc3", "patch": "@@ -1,4 +1,5 @@\n use either::Either;\n+use rustc_const_eval::util::{CallDesugaringKind, CallKind};\n use rustc_data_structures::fx::FxHashSet;\n use rustc_errors::{Applicability, DiagnosticBuilder};\n use rustc_hir as hir;\n@@ -26,7 +27,7 @@ use crate::{\n \n use super::{\n     explain_borrow::{BorrowExplanation, LaterUseKind},\n-    FnSelfUseKind, IncludingDowncast, RegionName, RegionNameSource, UseSpans,\n+    IncludingDowncast, RegionName, RegionNameSource, UseSpans,\n };\n \n #[derive(Debug)]\n@@ -195,7 +196,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                         .map(|n| format!(\"`{}`\", n))\n                         .unwrap_or_else(|| \"value\".to_owned());\n                     match kind {\n-                        FnSelfUseKind::FnOnceCall => {\n+                        CallKind::FnCall(once_did) if Some(once_did) == self.infcx.tcx.lang_items().fn_once_trait() => {\n                             err.span_label(\n                                 fn_call_span,\n                                 &format!(\n@@ -208,7 +209,8 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                                 \"this value implements `FnOnce`, which causes it to be moved when called\",\n                             );\n                         }\n-                        FnSelfUseKind::Operator { self_arg } => {\n+                        CallKind::Operator { self_arg, .. } => {\n+                            let self_arg = self_arg.unwrap();\n                             err.span_label(\n                                 fn_call_span,\n                                 &format!(\n@@ -235,12 +237,9 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                                 );\n                             }\n                         }\n-                        FnSelfUseKind::Normal {\n-                            self_arg,\n-                            implicit_into_iter,\n-                            is_option_or_result,\n-                        } => {\n-                            if implicit_into_iter {\n+                        CallKind::Normal { self_arg, desugaring, is_option_or_result } => {\n+                            let self_arg = self_arg.unwrap();\n+                            if let Some((CallDesugaringKind::ForLoopIntoIter, _)) = desugaring {\n                                 err.span_label(\n                                     fn_call_span,\n                                     &format!(\n@@ -305,8 +304,8 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                                     );\n                             }\n                         }\n-                        // Deref::deref takes &self, which cannot cause a move\n-                        FnSelfUseKind::DerefCoercion { .. } => unreachable!(),\n+                        // Other desugarings takes &self, which cannot cause a move\n+                        _ => unreachable!(),\n                     }\n                 } else {\n                     err.span_label(\n@@ -433,7 +432,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n             }\n \n             if let UseSpans::FnSelfUse {\n-                kind: FnSelfUseKind::DerefCoercion { deref_target, deref_target_ty },\n+                kind: CallKind::DerefCoercion { deref_target, deref_target_ty, .. },\n                 ..\n             } = use_spans\n             {"}, {"sha": "4400fed13b741ef8abe5339941f2183f44083747", "filename": "compiler/rustc_borrowck/src/diagnostics/mod.rs", "status": "modified", "additions": 22, "deletions": 93, "changes": 115, "blob_url": "https://github.com/rust-lang/rust/blob/f7f0f843b70f1b6c4ac9e22789d93d7bf5569dc3/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f7f0f843b70f1b6c4ac9e22789d93d7bf5569dc3/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fmod.rs?ref=f7f0f843b70f1b6c4ac9e22789d93d7bf5569dc3", "patch": "@@ -1,10 +1,10 @@\n //! Borrow checker diagnostics.\n \n+use rustc_const_eval::util::call_kind;\n use rustc_errors::DiagnosticBuilder;\n use rustc_hir as hir;\n use rustc_hir::def::Namespace;\n use rustc_hir::def_id::DefId;\n-use rustc_hir::lang_items::LangItemGroup;\n use rustc_hir::GeneratorKind;\n use rustc_middle::mir::{\n     AggregateKind, Constant, FakeReadCause, Field, Local, LocalInfo, LocalKind, Location, Operand,\n@@ -13,7 +13,7 @@ use rustc_middle::mir::{\n use rustc_middle::ty::print::Print;\n use rustc_middle::ty::{self, DefIdTree, Instance, Ty, TyCtxt};\n use rustc_mir_dataflow::move_paths::{InitLocation, LookupResult};\n-use rustc_span::{hygiene::DesugaringKind, symbol::sym, Span};\n+use rustc_span::{symbol::sym, Span};\n use rustc_target::abi::VariantIdx;\n \n use super::borrow_set::BorrowData;\n@@ -37,7 +37,7 @@ crate use mutability_errors::AccessKind;\n crate use outlives_suggestion::OutlivesSuggestionBuilder;\n crate use region_errors::{ErrorConstraintInfo, RegionErrorKind, RegionErrors};\n crate use region_name::{RegionName, RegionNameSource};\n-use rustc_span::symbol::Ident;\n+crate use rustc_const_eval::util::CallKind;\n \n pub(super) struct IncludingDowncast(pub(super) bool);\n \n@@ -563,46 +563,23 @@ pub(super) enum UseSpans<'tcx> {\n         fn_call_span: Span,\n         /// The definition span of the method being called\n         fn_span: Span,\n-        kind: FnSelfUseKind<'tcx>,\n+        kind: CallKind<'tcx>,\n     },\n     /// This access is caused by a `match` or `if let` pattern.\n     PatUse(Span),\n     /// This access has a single span associated to it: common case.\n     OtherUse(Span),\n }\n \n-#[derive(Copy, Clone, PartialEq, Eq, Debug)]\n-pub(super) enum FnSelfUseKind<'tcx> {\n-    /// A normal method call of the form `receiver.foo(a, b, c)`\n-    Normal {\n-        self_arg: Ident,\n-        implicit_into_iter: bool,\n-        /// Whether the self type of the method call has an `.as_ref()` method.\n-        /// Used for better diagnostics.\n-        is_option_or_result: bool,\n-    },\n-    /// A call to `FnOnce::call_once`, desugared from `my_closure(a, b, c)`\n-    FnOnceCall,\n-    /// A call to an operator trait, desuraged from operator syntax (e.g. `a << b`)\n-    Operator { self_arg: Ident },\n-    DerefCoercion {\n-        /// The `Span` of the `Target` associated type\n-        /// in the `Deref` impl we are using.\n-        deref_target: Span,\n-        /// The type `T::Deref` we are dereferencing to\n-        deref_target_ty: Ty<'tcx>,\n-    },\n-}\n-\n impl UseSpans<'_> {\n     pub(super) fn args_or_use(self) -> Span {\n         match self {\n             UseSpans::ClosureUse { args_span: span, .. }\n             | UseSpans::PatUse(span)\n             | UseSpans::OtherUse(span) => span,\n-            UseSpans::FnSelfUse {\n-                fn_call_span, kind: FnSelfUseKind::DerefCoercion { .. }, ..\n-            } => fn_call_span,\n+            UseSpans::FnSelfUse { fn_call_span, kind: CallKind::DerefCoercion { .. }, .. } => {\n+                fn_call_span\n+            }\n             UseSpans::FnSelfUse { var_span, .. } => var_span,\n         }\n     }\n@@ -613,9 +590,9 @@ impl UseSpans<'_> {\n             UseSpans::ClosureUse { path_span: span, .. }\n             | UseSpans::PatUse(span)\n             | UseSpans::OtherUse(span) => span,\n-            UseSpans::FnSelfUse {\n-                fn_call_span, kind: FnSelfUseKind::DerefCoercion { .. }, ..\n-            } => fn_call_span,\n+            UseSpans::FnSelfUse { fn_call_span, kind: CallKind::DerefCoercion { .. }, .. } => {\n+                fn_call_span\n+            }\n             UseSpans::FnSelfUse { var_span, .. } => var_span,\n         }\n     }\n@@ -626,9 +603,9 @@ impl UseSpans<'_> {\n             UseSpans::ClosureUse { capture_kind_span: span, .. }\n             | UseSpans::PatUse(span)\n             | UseSpans::OtherUse(span) => span,\n-            UseSpans::FnSelfUse {\n-                fn_call_span, kind: FnSelfUseKind::DerefCoercion { .. }, ..\n-            } => fn_call_span,\n+            UseSpans::FnSelfUse { fn_call_span, kind: CallKind::DerefCoercion { .. }, .. } => {\n+                fn_call_span\n+            }\n             UseSpans::FnSelfUse { var_span, .. } => var_span,\n         }\n     }\n@@ -904,67 +881,19 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                 return normal_ret;\n             };\n \n-            let tcx = self.infcx.tcx;\n-            let parent = tcx.parent(method_did);\n-            let is_fn_once = parent == tcx.lang_items().fn_once_trait();\n-            let is_operator = !from_hir_call\n-                && parent.map_or(false, |p| tcx.lang_items().group(LangItemGroup::Op).contains(&p));\n-            let is_deref = !from_hir_call && tcx.is_diagnostic_item(sym::deref_method, method_did);\n-            let fn_call_span = *fn_span;\n-\n-            let self_arg = tcx.fn_arg_names(method_did)[0];\n-\n-            debug!(\n-                \"terminator = {:?} from_hir_call={:?}\",\n-                self.body[location.block].terminator, from_hir_call\n+            let kind = call_kind(\n+                self.infcx.tcx,\n+                self.param_env,\n+                method_did,\n+                method_substs,\n+                *fn_span,\n+                *from_hir_call,\n+                Some(self.infcx.tcx.fn_arg_names(method_did)[0]),\n             );\n \n-            // Check for a 'special' use of 'self' -\n-            // an FnOnce call, an operator (e.g. `<<`), or a\n-            // deref coercion.\n-            let kind = if is_fn_once {\n-                Some(FnSelfUseKind::FnOnceCall)\n-            } else if is_operator {\n-                Some(FnSelfUseKind::Operator { self_arg })\n-            } else if is_deref {\n-                let deref_target =\n-                    tcx.get_diagnostic_item(sym::deref_target).and_then(|deref_target| {\n-                        Instance::resolve(tcx, self.param_env, deref_target, method_substs)\n-                            .transpose()\n-                    });\n-                if let Some(Ok(instance)) = deref_target {\n-                    let deref_target_ty = instance.ty(tcx, self.param_env);\n-                    Some(FnSelfUseKind::DerefCoercion {\n-                        deref_target: tcx.def_span(instance.def_id()),\n-                        deref_target_ty,\n-                    })\n-                } else {\n-                    None\n-                }\n-            } else {\n-                None\n-            };\n-\n-            let kind = kind.unwrap_or_else(|| {\n-                // This isn't a 'special' use of `self`\n-                debug!(\"move_spans: method_did={:?}, fn_call_span={:?}\", method_did, fn_call_span);\n-                let implicit_into_iter = Some(method_did) == tcx.lang_items().into_iter_fn()\n-                    && fn_call_span.desugaring_kind() == Some(DesugaringKind::ForLoop);\n-                let parent_self_ty = parent\n-                    .filter(|did| tcx.def_kind(*did) == rustc_hir::def::DefKind::Impl)\n-                    .and_then(|did| match tcx.type_of(did).kind() {\n-                        ty::Adt(def, ..) => Some(def.did),\n-                        _ => None,\n-                    });\n-                let is_option_or_result = parent_self_ty.map_or(false, |def_id| {\n-                    matches!(tcx.get_diagnostic_name(def_id), Some(sym::Option | sym::Result))\n-                });\n-                FnSelfUseKind::Normal { self_arg, implicit_into_iter, is_option_or_result }\n-            });\n-\n             return FnSelfUse {\n                 var_span: stmt.source_info.span,\n-                fn_call_span,\n+                fn_call_span: *fn_span,\n                 fn_span: self\n                     .infcx\n                     .tcx"}, {"sha": "b33b779eddaddb30f49f6b4fda8d0d112d45595a", "filename": "compiler/rustc_borrowck/src/diagnostics/move_errors.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f7f0f843b70f1b6c4ac9e22789d93d7bf5569dc3/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fmove_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f7f0f843b70f1b6c4ac9e22789d93d7bf5569dc3/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fmove_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fmove_errors.rs?ref=f7f0f843b70f1b6c4ac9e22789d93d7bf5569dc3", "patch": "@@ -1,3 +1,4 @@\n+use rustc_const_eval::util::CallDesugaringKind;\n use rustc_errors::{Applicability, DiagnosticBuilder};\n use rustc_infer::infer::TyCtxtInferExt;\n use rustc_middle::mir::*;\n@@ -8,7 +9,7 @@ use rustc_mir_dataflow::move_paths::{\n use rustc_span::{sym, Span, DUMMY_SP};\n use rustc_trait_selection::traits::type_known_to_meet_bound_modulo_regions;\n \n-use crate::diagnostics::{FnSelfUseKind, UseSpans};\n+use crate::diagnostics::{CallKind, UseSpans};\n use crate::prefixes::PrefixSet;\n use crate::MirBorrowckCtxt;\n \n@@ -410,7 +411,8 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n                 Applicability::MaybeIncorrect,\n             );\n         } else if let Some(UseSpans::FnSelfUse {\n-            kind: FnSelfUseKind::Normal { implicit_into_iter: true, .. },\n+            kind:\n+                CallKind::Normal { desugaring: Some((CallDesugaringKind::ForLoopIntoIter, _)), .. },\n             ..\n         }) = use_spans\n         {"}, {"sha": "bd16a8853a624c192ec051120a2a8fe9b9deccd2", "filename": "compiler/rustc_const_eval/src/transform/check_consts/check.rs", "status": "modified", "additions": 24, "deletions": 6, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/f7f0f843b70f1b6c4ac9e22789d93d7bf5569dc3/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fcheck_consts%2Fcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f7f0f843b70f1b6c4ac9e22789d93d7bf5569dc3/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fcheck_consts%2Fcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fcheck_consts%2Fcheck.rs?ref=f7f0f843b70f1b6c4ac9e22789d93d7bf5569dc3", "patch": "@@ -293,13 +293,13 @@ impl<'mir, 'tcx> Checker<'mir, 'tcx> {\n     }\n \n     /// Emits an error if an expression cannot be evaluated in the current context.\n-    pub fn check_op(&mut self, op: impl NonConstOp) {\n+    pub fn check_op(&mut self, op: impl NonConstOp<'tcx>) {\n         self.check_op_spanned(op, self.span);\n     }\n \n     /// Emits an error at the given `span` if an expression cannot be evaluated in the current\n     /// context.\n-    pub fn check_op_spanned<O: NonConstOp>(&mut self, op: O, span: Span) {\n+    pub fn check_op_spanned<O: NonConstOp<'tcx>>(&mut self, op: O, span: Span) {\n         let gate = match op.status_in_item(self.ccx) {\n             Status::Allowed => return,\n \n@@ -773,7 +773,7 @@ impl<'tcx> Visitor<'tcx> for Checker<'_, 'tcx> {\n         self.super_terminator(terminator, location);\n \n         match &terminator.kind {\n-            TerminatorKind::Call { func, args, .. } => {\n+            TerminatorKind::Call { func, args, fn_span, from_hir_call, .. } => {\n                 let ConstCx { tcx, body, param_env, .. } = *self.ccx;\n                 let caller = self.def_id().to_def_id();\n \n@@ -797,7 +797,13 @@ impl<'tcx> Visitor<'tcx> for Checker<'_, 'tcx> {\n                 if let Some(trait_id) = tcx.trait_of_item(callee) {\n                     trace!(\"attempting to call a trait method\");\n                     if !self.tcx.features().const_trait_impl {\n-                        self.check_op(ops::FnCallNonConst(callee, substs));\n+                        self.check_op(ops::FnCallNonConst {\n+                            caller,\n+                            callee,\n+                            substs,\n+                            span: *fn_span,\n+                            from_hir_call: *from_hir_call,\n+                        });\n                         return;\n                     }\n \n@@ -856,7 +862,13 @@ impl<'tcx> Visitor<'tcx> for Checker<'_, 'tcx> {\n                             }\n \n                             if !nonconst_call_permission {\n-                                self.check_op(ops::FnCallNonConst(callee, substs));\n+                                self.check_op(ops::FnCallNonConst {\n+                                    caller,\n+                                    callee,\n+                                    substs,\n+                                    span: *fn_span,\n+                                    from_hir_call: *from_hir_call,\n+                                });\n                                 return;\n                             }\n                         }\n@@ -925,7 +937,13 @@ impl<'tcx> Visitor<'tcx> for Checker<'_, 'tcx> {\n                     }\n \n                     if !nonconst_call_permission {\n-                        self.check_op(ops::FnCallNonConst(callee, substs));\n+                        self.check_op(ops::FnCallNonConst {\n+                            caller,\n+                            callee,\n+                            substs,\n+                            span: *fn_span,\n+                            from_hir_call: *from_hir_call,\n+                        });\n                         return;\n                     }\n                 }"}, {"sha": "c26b1e550ba23b505963b54fed5b1cab890c1c14", "filename": "compiler/rustc_const_eval/src/transform/check_consts/ops.rs", "status": "modified", "additions": 217, "deletions": 120, "changes": 337, "blob_url": "https://github.com/rust-lang/rust/blob/f7f0f843b70f1b6c4ac9e22789d93d7bf5569dc3/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fcheck_consts%2Fops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f7f0f843b70f1b6c4ac9e22789d93d7bf5569dc3/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fcheck_consts%2Fops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fcheck_consts%2Fops.rs?ref=f7f0f843b70f1b6c4ac9e22789d93d7bf5569dc3", "patch": "@@ -3,14 +3,20 @@\n use rustc_errors::{struct_span_err, Applicability, DiagnosticBuilder};\n use rustc_hir as hir;\n use rustc_hir::def_id::DefId;\n+use rustc_infer::infer::TyCtxtInferExt;\n+use rustc_infer::traits::{ImplSource, Obligation, ObligationCause};\n+use rustc_middle::mir;\n+use rustc_middle::ty::print::with_no_trimmed_paths;\n use rustc_middle::ty::subst::{GenericArgKind, SubstsRef};\n-use rustc_middle::{mir, ty::AssocKind};\n+use rustc_middle::ty::{suggest_constraining_type_param, Adt, Param, TraitPredicate, Ty};\n+use rustc_middle::ty::{Binder, BoundConstness, ImplPolarity, TraitRef};\n use rustc_session::parse::feature_err;\n use rustc_span::symbol::sym;\n-use rustc_span::{symbol::Ident, Span, Symbol};\n-use rustc_span::{BytePos, Pos};\n+use rustc_span::{BytePos, Pos, Span, Symbol};\n+use rustc_trait_selection::traits::SelectionContext;\n \n use super::ConstCx;\n+use crate::util::{call_kind, CallDesugaringKind, CallKind};\n \n #[derive(Clone, Copy, Debug, PartialEq, Eq)]\n pub enum Status {\n@@ -29,31 +35,31 @@ pub enum DiagnosticImportance {\n }\n \n /// An operation that is not *always* allowed in a const context.\n-pub trait NonConstOp: std::fmt::Debug {\n+pub trait NonConstOp<'tcx>: std::fmt::Debug {\n     /// Returns an enum indicating whether this operation is allowed within the given item.\n-    fn status_in_item(&self, _ccx: &ConstCx<'_, '_>) -> Status {\n+    fn status_in_item(&self, _ccx: &ConstCx<'_, 'tcx>) -> Status {\n         Status::Forbidden\n     }\n \n     fn importance(&self) -> DiagnosticImportance {\n         DiagnosticImportance::Primary\n     }\n \n-    fn build_error<'tcx>(&self, ccx: &ConstCx<'_, 'tcx>, span: Span) -> DiagnosticBuilder<'tcx>;\n+    fn build_error(&self, ccx: &ConstCx<'_, 'tcx>, span: Span) -> DiagnosticBuilder<'tcx>;\n }\n \n #[derive(Debug)]\n pub struct FloatingPointOp;\n-impl NonConstOp for FloatingPointOp {\n-    fn status_in_item(&self, ccx: &ConstCx<'_, '_>) -> Status {\n+impl<'tcx> NonConstOp<'tcx> for FloatingPointOp {\n+    fn status_in_item(&self, ccx: &ConstCx<'_, 'tcx>) -> Status {\n         if ccx.const_kind() == hir::ConstContext::ConstFn {\n             Status::Unstable(sym::const_fn_floating_point_arithmetic)\n         } else {\n             Status::Allowed\n         }\n     }\n \n-    fn build_error<'tcx>(&self, ccx: &ConstCx<'_, 'tcx>, span: Span) -> DiagnosticBuilder<'tcx> {\n+    fn build_error(&self, ccx: &ConstCx<'_, 'tcx>, span: Span) -> DiagnosticBuilder<'tcx> {\n         feature_err(\n             &ccx.tcx.sess.parse_sess,\n             sym::const_fn_floating_point_arithmetic,\n@@ -66,40 +72,120 @@ impl NonConstOp for FloatingPointOp {\n /// A function call where the callee is a pointer.\n #[derive(Debug)]\n pub struct FnCallIndirect;\n-impl NonConstOp for FnCallIndirect {\n-    fn build_error<'tcx>(&self, ccx: &ConstCx<'_, 'tcx>, span: Span) -> DiagnosticBuilder<'tcx> {\n+impl<'tcx> NonConstOp<'tcx> for FnCallIndirect {\n+    fn build_error(&self, ccx: &ConstCx<'_, 'tcx>, span: Span) -> DiagnosticBuilder<'tcx> {\n         ccx.tcx.sess.struct_span_err(span, \"function pointers are not allowed in const fn\")\n     }\n }\n \n /// A function call where the callee is not marked as `const`.\n-#[derive(Debug)]\n-pub struct FnCallNonConst<'tcx>(pub DefId, pub SubstsRef<'tcx>);\n-impl<'a> NonConstOp for FnCallNonConst<'a> {\n-    fn build_error<'tcx>(&self, ccx: &ConstCx<'_, 'tcx>, span: Span) -> DiagnosticBuilder<'tcx> {\n-        let FnCallNonConst(def_id, substs) = *self;\n-        let mut err = struct_span_err!(\n-            ccx.tcx.sess,\n-            span,\n-            E0015,\n-            \"cannot call non-const fn `{}` in {}s\",\n-            ccx.tcx.def_path_str_with_substs(def_id, substs),\n-            ccx.const_kind()\n-        );\n-        err.note(&format!(\n-            \"calls in {}s are limited to constant functions, \\\n-             tuple structs and tuple variants\",\n-            ccx.const_kind(),\n-        ));\n+#[derive(Debug, Clone, Copy)]\n+pub struct FnCallNonConst<'tcx> {\n+    pub caller: DefId,\n+    pub callee: DefId,\n+    pub substs: SubstsRef<'tcx>,\n+    pub span: Span,\n+    pub from_hir_call: bool,\n+}\n \n-        if let Some(trait_def_id) = ccx.tcx.lang_items().eq_trait() {\n-            if let Some(eq_item) = ccx.tcx.associated_items(trait_def_id).find_by_name_and_kind(\n-                ccx.tcx,\n-                Ident::with_dummy_span(sym::eq),\n-                AssocKind::Fn,\n-                trait_def_id,\n-            ) {\n-                if callee == eq_item.def_id && substs.len() == 2 {\n+impl<'tcx> NonConstOp<'tcx> for FnCallNonConst<'tcx> {\n+    fn build_error(&self, ccx: &ConstCx<'_, 'tcx>, _: Span) -> DiagnosticBuilder<'tcx> {\n+        let FnCallNonConst { caller, callee, substs, span, from_hir_call } = *self;\n+        let ConstCx { tcx, param_env, .. } = *ccx;\n+\n+        let diag_trait = |mut err, self_ty: Ty<'_>, trait_id| {\n+            let trait_ref = TraitRef::from_method(tcx, trait_id, substs);\n+\n+            match self_ty.kind() {\n+                Param(param_ty) => {\n+                    debug!(?param_ty);\n+                    if let Some(generics) = caller\n+                        .as_local()\n+                        .map(|id| tcx.hir().local_def_id_to_hir_id(id))\n+                        .map(|id| tcx.hir().get(id))\n+                        .as_ref()\n+                        .and_then(|node| node.generics())\n+                    {\n+                        let constraint = with_no_trimmed_paths(|| {\n+                            format!(\"~const {}\", trait_ref.print_only_trait_path())\n+                        });\n+                        suggest_constraining_type_param(\n+                            tcx,\n+                            generics,\n+                            &mut err,\n+                            &param_ty.name.as_str(),\n+                            &constraint,\n+                            None,\n+                        );\n+                    }\n+                }\n+                Adt(..) => {\n+                    let obligation = Obligation::new(\n+                        ObligationCause::dummy(),\n+                        param_env,\n+                        Binder::dummy(TraitPredicate {\n+                            trait_ref,\n+                            constness: BoundConstness::ConstIfConst,\n+                            polarity: ImplPolarity::Positive,\n+                        }),\n+                    );\n+\n+                    let implsrc = tcx.infer_ctxt().enter(|infcx| {\n+                        let mut selcx = SelectionContext::new(&infcx);\n+                        selcx.select(&obligation)\n+                    });\n+\n+                    if let Ok(Some(ImplSource::UserDefined(data))) = implsrc {\n+                        let span =\n+                            tcx.sess.source_map().guess_head_span(tcx.def_span(data.impl_def_id));\n+                        err.span_note(span, \"impl defined here, but it is not `const`\");\n+                    }\n+                }\n+                _ => {}\n+            }\n+\n+            err\n+        };\n+\n+        let call_kind = call_kind(tcx, ccx.param_env, callee, substs, span, from_hir_call, None);\n+\n+        debug!(?call_kind);\n+\n+        let mut err = match call_kind {\n+            CallKind::Normal { desugaring: Some((kind, self_ty)), .. } => {\n+                macro_rules! error {\n+                    ($fmt:literal) => {\n+                        struct_span_err!(tcx.sess, span, E0015, $fmt, self_ty, ccx.const_kind(),)\n+                    };\n+                }\n+\n+                let err = match kind {\n+                    CallDesugaringKind::ForLoopIntoIter => {\n+                        error!(\"cannot convert `{}` into an iterator in {}s\")\n+                    }\n+                    CallDesugaringKind::QuestionBranch => {\n+                        error!(\"`?` cannot determine the branch of `{}` in {}s\")\n+                    }\n+                    CallDesugaringKind::QuestionFromResidual => {\n+                        error!(\"`?` cannot convert from residual of `{}` in {}s\")\n+                    }\n+                    CallDesugaringKind::TryBlockFromOutput => {\n+                        error!(\"`try` block cannot convert `{}` to the result in {}s\")\n+                    }\n+                };\n+\n+                diag_trait(err, self_ty, kind.trait_def_id(tcx))\n+            }\n+            CallKind::Operator { trait_id, self_ty, .. } => {\n+                let mut err = struct_span_err!(\n+                    tcx.sess,\n+                    span,\n+                    E0015,\n+                    \"cannot call non-const operator in {}s\",\n+                    ccx.const_kind()\n+                );\n+\n+                if Some(trait_id) == ccx.tcx.lang_items().eq_trait() {\n                     match (substs[0].unpack(), substs[1].unpack()) {\n                         (GenericArgKind::Type(self_ty), GenericArgKind::Type(rhs_ty))\n                             if self_ty == rhs_ty\n@@ -137,8 +223,43 @@ impl<'a> NonConstOp for FnCallNonConst<'a> {\n                         _ => {}\n                     }\n                 }\n+\n+                diag_trait(err, self_ty, trait_id)\n             }\n-        }\n+            CallKind::DerefCoercion { deref_target, deref_target_ty, self_ty } => {\n+                let mut err = struct_span_err!(\n+                    tcx.sess,\n+                    span,\n+                    E0015,\n+                    \"cannot perform deref coercion on `{}` in {}s\",\n+                    self_ty,\n+                    ccx.const_kind()\n+                );\n+\n+                err.note(&format!(\"attempting to deref into `{}`\", deref_target_ty));\n+\n+                // Check first whether the source is accessible (issue #87060)\n+                if tcx.sess.source_map().span_to_snippet(deref_target).is_ok() {\n+                    err.span_note(deref_target, \"deref defined here\");\n+                }\n+\n+                diag_trait(err, self_ty, tcx.lang_items().deref_trait().unwrap())\n+            }\n+            _ => struct_span_err!(\n+                ccx.tcx.sess,\n+                span,\n+                E0015,\n+                \"cannot call non-const fn `{}` in {}s\",\n+                ccx.tcx.def_path_str_with_substs(callee, substs),\n+                ccx.const_kind(),\n+            ),\n+        };\n+\n+        err.note(&format!(\n+            \"calls in {}s are limited to constant functions, \\\n+             tuple structs and tuple variants\",\n+            ccx.const_kind(),\n+        ));\n \n         err\n     }\n@@ -150,8 +271,8 @@ impl<'a> NonConstOp for FnCallNonConst<'a> {\n #[derive(Debug)]\n pub struct FnCallUnstable(pub DefId, pub Option<Symbol>);\n \n-impl NonConstOp for FnCallUnstable {\n-    fn build_error<'tcx>(&self, ccx: &ConstCx<'_, 'tcx>, span: Span) -> DiagnosticBuilder<'tcx> {\n+impl<'tcx> NonConstOp<'tcx> for FnCallUnstable {\n+    fn build_error(&self, ccx: &ConstCx<'_, 'tcx>, span: Span) -> DiagnosticBuilder<'tcx> {\n         let FnCallUnstable(def_id, feature) = *self;\n \n         let mut err = ccx.tcx.sess.struct_span_err(\n@@ -176,16 +297,16 @@ impl NonConstOp for FnCallUnstable {\n \n #[derive(Debug)]\n pub struct FnPtrCast;\n-impl NonConstOp for FnPtrCast {\n-    fn status_in_item(&self, ccx: &ConstCx<'_, '_>) -> Status {\n+impl<'tcx> NonConstOp<'tcx> for FnPtrCast {\n+    fn status_in_item(&self, ccx: &ConstCx<'_, 'tcx>) -> Status {\n         if ccx.const_kind() != hir::ConstContext::ConstFn {\n             Status::Allowed\n         } else {\n             Status::Unstable(sym::const_fn_fn_ptr_basics)\n         }\n     }\n \n-    fn build_error<'tcx>(&self, ccx: &ConstCx<'_, 'tcx>, span: Span) -> DiagnosticBuilder<'tcx> {\n+    fn build_error(&self, ccx: &ConstCx<'_, 'tcx>, span: Span) -> DiagnosticBuilder<'tcx> {\n         feature_err(\n             &ccx.tcx.sess.parse_sess,\n             sym::const_fn_fn_ptr_basics,\n@@ -197,16 +318,16 @@ impl NonConstOp for FnPtrCast {\n \n #[derive(Debug)]\n pub struct Generator(pub hir::GeneratorKind);\n-impl NonConstOp for Generator {\n-    fn status_in_item(&self, _: &ConstCx<'_, '_>) -> Status {\n+impl<'tcx> NonConstOp<'tcx> for Generator {\n+    fn status_in_item(&self, _: &ConstCx<'_, 'tcx>) -> Status {\n         if let hir::GeneratorKind::Async(hir::AsyncGeneratorKind::Block) = self.0 {\n             Status::Unstable(sym::const_async_blocks)\n         } else {\n             Status::Forbidden\n         }\n     }\n \n-    fn build_error<'tcx>(&self, ccx: &ConstCx<'_, 'tcx>, span: Span) -> DiagnosticBuilder<'tcx> {\n+    fn build_error(&self, ccx: &ConstCx<'_, 'tcx>, span: Span) -> DiagnosticBuilder<'tcx> {\n         let msg = format!(\"{}s are not allowed in {}s\", self.0, ccx.const_kind());\n         if let hir::GeneratorKind::Async(hir::AsyncGeneratorKind::Block) = self.0 {\n             feature_err(&ccx.tcx.sess.parse_sess, sym::const_async_blocks, span, &msg)\n@@ -218,8 +339,8 @@ impl NonConstOp for Generator {\n \n #[derive(Debug)]\n pub struct HeapAllocation;\n-impl NonConstOp for HeapAllocation {\n-    fn build_error<'tcx>(&self, ccx: &ConstCx<'_, 'tcx>, span: Span) -> DiagnosticBuilder<'tcx> {\n+impl<'tcx> NonConstOp<'tcx> for HeapAllocation {\n+    fn build_error(&self, ccx: &ConstCx<'_, 'tcx>, span: Span) -> DiagnosticBuilder<'tcx> {\n         let mut err = struct_span_err!(\n             ccx.tcx.sess,\n             span,\n@@ -242,8 +363,8 @@ impl NonConstOp for HeapAllocation {\n \n #[derive(Debug)]\n pub struct InlineAsm;\n-impl NonConstOp for InlineAsm {\n-    fn build_error<'tcx>(&self, ccx: &ConstCx<'_, 'tcx>, span: Span) -> DiagnosticBuilder<'tcx> {\n+impl<'tcx> NonConstOp<'tcx> for InlineAsm {\n+    fn build_error(&self, ccx: &ConstCx<'_, 'tcx>, span: Span) -> DiagnosticBuilder<'tcx> {\n         struct_span_err!(\n             ccx.tcx.sess,\n             span,\n@@ -258,8 +379,8 @@ impl NonConstOp for InlineAsm {\n pub struct LiveDrop {\n     pub dropped_at: Option<Span>,\n }\n-impl NonConstOp for LiveDrop {\n-    fn build_error<'tcx>(&self, ccx: &ConstCx<'_, 'tcx>, span: Span) -> DiagnosticBuilder<'tcx> {\n+impl<'tcx> NonConstOp<'tcx> for LiveDrop {\n+    fn build_error(&self, ccx: &ConstCx<'_, 'tcx>, span: Span) -> DiagnosticBuilder<'tcx> {\n         let mut err = struct_span_err!(\n             ccx.tcx.sess,\n             span,\n@@ -278,16 +399,16 @@ impl NonConstOp for LiveDrop {\n /// A borrow of a type that contains an `UnsafeCell` somewhere. The borrow never escapes to\n /// the final value of the constant.\n pub struct TransientCellBorrow;\n-impl NonConstOp for TransientCellBorrow {\n-    fn status_in_item(&self, _: &ConstCx<'_, '_>) -> Status {\n+impl<'tcx> NonConstOp<'tcx> for TransientCellBorrow {\n+    fn status_in_item(&self, _: &ConstCx<'_, 'tcx>) -> Status {\n         Status::Unstable(sym::const_refs_to_cell)\n     }\n     fn importance(&self) -> DiagnosticImportance {\n         // The cases that cannot possibly work will already emit a `CellBorrow`, so we should\n         // not additionally emit a feature gate error if activating the feature gate won't work.\n         DiagnosticImportance::Secondary\n     }\n-    fn build_error<'tcx>(&self, ccx: &ConstCx<'_, 'tcx>, span: Span) -> DiagnosticBuilder<'tcx> {\n+    fn build_error(&self, ccx: &ConstCx<'_, 'tcx>, span: Span) -> DiagnosticBuilder<'tcx> {\n         feature_err(\n             &ccx.tcx.sess.parse_sess,\n             sym::const_refs_to_cell,\n@@ -302,8 +423,8 @@ impl NonConstOp for TransientCellBorrow {\n /// the final value of the constant, and thus we cannot allow this (for now). We may allow\n /// it in the future for static items.\n pub struct CellBorrow;\n-impl NonConstOp for CellBorrow {\n-    fn build_error<'tcx>(&self, ccx: &ConstCx<'_, 'tcx>, span: Span) -> DiagnosticBuilder<'tcx> {\n+impl<'tcx> NonConstOp<'tcx> for CellBorrow {\n+    fn build_error(&self, ccx: &ConstCx<'_, 'tcx>, span: Span) -> DiagnosticBuilder<'tcx> {\n         let mut err = struct_span_err!(\n             ccx.tcx.sess,\n             span,\n@@ -339,8 +460,8 @@ impl NonConstOp for CellBorrow {\n /// static or const items.\n pub struct MutBorrow(pub hir::BorrowKind);\n \n-impl NonConstOp for MutBorrow {\n-    fn status_in_item(&self, _ccx: &ConstCx<'_, '_>) -> Status {\n+impl<'tcx> NonConstOp<'tcx> for MutBorrow {\n+    fn status_in_item(&self, _ccx: &ConstCx<'_, 'tcx>) -> Status {\n         Status::Forbidden\n     }\n \n@@ -350,7 +471,7 @@ impl NonConstOp for MutBorrow {\n         DiagnosticImportance::Secondary\n     }\n \n-    fn build_error<'tcx>(&self, ccx: &ConstCx<'_, 'tcx>, span: Span) -> DiagnosticBuilder<'tcx> {\n+    fn build_error(&self, ccx: &ConstCx<'_, 'tcx>, span: Span) -> DiagnosticBuilder<'tcx> {\n         let raw = match self.0 {\n             hir::BorrowKind::Raw => \"raw \",\n             hir::BorrowKind::Ref => \"\",\n@@ -384,12 +505,12 @@ impl NonConstOp for MutBorrow {\n #[derive(Debug)]\n pub struct TransientMutBorrow(pub hir::BorrowKind);\n \n-impl NonConstOp for TransientMutBorrow {\n-    fn status_in_item(&self, _: &ConstCx<'_, '_>) -> Status {\n+impl<'tcx> NonConstOp<'tcx> for TransientMutBorrow {\n+    fn status_in_item(&self, _: &ConstCx<'_, 'tcx>) -> Status {\n         Status::Unstable(sym::const_mut_refs)\n     }\n \n-    fn build_error<'tcx>(&self, ccx: &ConstCx<'_, 'tcx>, span: Span) -> DiagnosticBuilder<'tcx> {\n+    fn build_error(&self, ccx: &ConstCx<'_, 'tcx>, span: Span) -> DiagnosticBuilder<'tcx> {\n         let raw = match self.0 {\n             hir::BorrowKind::Raw => \"raw \",\n             hir::BorrowKind::Ref => \"\",\n@@ -406,8 +527,8 @@ impl NonConstOp for TransientMutBorrow {\n \n #[derive(Debug)]\n pub struct MutDeref;\n-impl NonConstOp for MutDeref {\n-    fn status_in_item(&self, _: &ConstCx<'_, '_>) -> Status {\n+impl<'tcx> NonConstOp<'tcx> for MutDeref {\n+    fn status_in_item(&self, _: &ConstCx<'_, 'tcx>) -> Status {\n         Status::Unstable(sym::const_mut_refs)\n     }\n \n@@ -416,7 +537,7 @@ impl NonConstOp for MutDeref {\n         DiagnosticImportance::Secondary\n     }\n \n-    fn build_error<'tcx>(&self, ccx: &ConstCx<'_, 'tcx>, span: Span) -> DiagnosticBuilder<'tcx> {\n+    fn build_error(&self, ccx: &ConstCx<'_, 'tcx>, span: Span) -> DiagnosticBuilder<'tcx> {\n         feature_err(\n             &ccx.tcx.sess.parse_sess,\n             sym::const_mut_refs,\n@@ -429,8 +550,8 @@ impl NonConstOp for MutDeref {\n /// A call to a `panic()` lang item where the first argument is _not_ a `&str`.\n #[derive(Debug)]\n pub struct PanicNonStr;\n-impl NonConstOp for PanicNonStr {\n-    fn build_error<'tcx>(&self, ccx: &ConstCx<'_, 'tcx>, span: Span) -> DiagnosticBuilder<'tcx> {\n+impl<'tcx> NonConstOp<'tcx> for PanicNonStr {\n+    fn build_error(&self, ccx: &ConstCx<'_, 'tcx>, span: Span) -> DiagnosticBuilder<'tcx> {\n         ccx.tcx.sess.struct_span_err(\n             span,\n             \"argument to `panic!()` in a const context must have type `&str`\",\n@@ -443,8 +564,8 @@ impl NonConstOp for PanicNonStr {\n /// allocation base addresses that are not known at compile-time.\n #[derive(Debug)]\n pub struct RawPtrComparison;\n-impl NonConstOp for RawPtrComparison {\n-    fn build_error<'tcx>(&self, ccx: &ConstCx<'_, 'tcx>, span: Span) -> DiagnosticBuilder<'tcx> {\n+impl<'tcx> NonConstOp<'tcx> for RawPtrComparison {\n+    fn build_error(&self, ccx: &ConstCx<'_, 'tcx>, span: Span) -> DiagnosticBuilder<'tcx> {\n         let mut err = ccx\n             .tcx\n             .sess\n@@ -459,12 +580,12 @@ impl NonConstOp for RawPtrComparison {\n \n #[derive(Debug)]\n pub struct RawMutPtrDeref;\n-impl NonConstOp for RawMutPtrDeref {\n+impl<'tcx> NonConstOp<'tcx> for RawMutPtrDeref {\n     fn status_in_item(&self, _: &ConstCx<'_, '_>) -> Status {\n         Status::Unstable(sym::const_mut_refs)\n     }\n \n-    fn build_error<'tcx>(&self, ccx: &ConstCx<'_, 'tcx>, span: Span) -> DiagnosticBuilder<'tcx> {\n+    fn build_error(&self, ccx: &ConstCx<'_, 'tcx>, span: Span) -> DiagnosticBuilder<'tcx> {\n         feature_err(\n             &ccx.tcx.sess.parse_sess,\n             sym::const_mut_refs,\n@@ -479,8 +600,8 @@ impl NonConstOp for RawMutPtrDeref {\n /// allocation base addresses that are not known at compile-time.\n #[derive(Debug)]\n pub struct RawPtrToIntCast;\n-impl NonConstOp for RawPtrToIntCast {\n-    fn build_error<'tcx>(&self, ccx: &ConstCx<'_, 'tcx>, span: Span) -> DiagnosticBuilder<'tcx> {\n+impl<'tcx> NonConstOp<'tcx> for RawPtrToIntCast {\n+    fn build_error(&self, ccx: &ConstCx<'_, 'tcx>, span: Span) -> DiagnosticBuilder<'tcx> {\n         let mut err = ccx\n             .tcx\n             .sess\n@@ -496,16 +617,16 @@ impl NonConstOp for RawPtrToIntCast {\n /// An access to a (non-thread-local) `static`.\n #[derive(Debug)]\n pub struct StaticAccess;\n-impl NonConstOp for StaticAccess {\n-    fn status_in_item(&self, ccx: &ConstCx<'_, '_>) -> Status {\n+impl<'tcx> NonConstOp<'tcx> for StaticAccess {\n+    fn status_in_item(&self, ccx: &ConstCx<'_, 'tcx>) -> Status {\n         if let hir::ConstContext::Static(_) = ccx.const_kind() {\n             Status::Allowed\n         } else {\n             Status::Forbidden\n         }\n     }\n \n-    fn build_error<'tcx>(&self, ccx: &ConstCx<'_, 'tcx>, span: Span) -> DiagnosticBuilder<'tcx> {\n+    fn build_error(&self, ccx: &ConstCx<'_, 'tcx>, span: Span) -> DiagnosticBuilder<'tcx> {\n         let mut err = struct_span_err!(\n             ccx.tcx.sess,\n             span,\n@@ -530,8 +651,8 @@ impl NonConstOp for StaticAccess {\n /// An access to a thread-local `static`.\n #[derive(Debug)]\n pub struct ThreadLocalAccess;\n-impl NonConstOp for ThreadLocalAccess {\n-    fn build_error<'tcx>(&self, ccx: &ConstCx<'_, 'tcx>, span: Span) -> DiagnosticBuilder<'tcx> {\n+impl<'tcx> NonConstOp<'tcx> for ThreadLocalAccess {\n+    fn build_error(&self, ccx: &ConstCx<'_, 'tcx>, span: Span) -> DiagnosticBuilder<'tcx> {\n         struct_span_err!(\n             ccx.tcx.sess,\n             span,\n@@ -548,8 +669,8 @@ pub mod ty {\n \n     #[derive(Debug)]\n     pub struct MutRef(pub mir::LocalKind);\n-    impl NonConstOp for MutRef {\n-        fn status_in_item(&self, _ccx: &ConstCx<'_, '_>) -> Status {\n+    impl<'tcx> NonConstOp<'tcx> for MutRef {\n+        fn status_in_item(&self, _ccx: &ConstCx<'_, 'tcx>) -> Status {\n             Status::Unstable(sym::const_mut_refs)\n         }\n \n@@ -562,11 +683,7 @@ pub mod ty {\n             }\n         }\n \n-        fn build_error<'tcx>(\n-            &self,\n-            ccx: &ConstCx<'_, 'tcx>,\n-            span: Span,\n-        ) -> DiagnosticBuilder<'tcx> {\n+        fn build_error(&self, ccx: &ConstCx<'_, 'tcx>, span: Span) -> DiagnosticBuilder<'tcx> {\n             feature_err(\n                 &ccx.tcx.sess.parse_sess,\n                 sym::const_mut_refs,\n@@ -578,7 +695,7 @@ pub mod ty {\n \n     #[derive(Debug)]\n     pub struct FnPtr(pub mir::LocalKind);\n-    impl NonConstOp for FnPtr {\n+    impl<'tcx> NonConstOp<'tcx> for FnPtr {\n         fn importance(&self) -> DiagnosticImportance {\n             match self.0 {\n                 mir::LocalKind::Var | mir::LocalKind::Temp => DiagnosticImportance::Secondary,\n@@ -588,19 +705,15 @@ pub mod ty {\n             }\n         }\n \n-        fn status_in_item(&self, ccx: &ConstCx<'_, '_>) -> Status {\n+        fn status_in_item(&self, ccx: &ConstCx<'_, 'tcx>) -> Status {\n             if ccx.const_kind() != hir::ConstContext::ConstFn {\n                 Status::Allowed\n             } else {\n                 Status::Unstable(sym::const_fn_fn_ptr_basics)\n             }\n         }\n \n-        fn build_error<'tcx>(\n-            &self,\n-            ccx: &ConstCx<'_, 'tcx>,\n-            span: Span,\n-        ) -> DiagnosticBuilder<'tcx> {\n+        fn build_error(&self, ccx: &ConstCx<'_, 'tcx>, span: Span) -> DiagnosticBuilder<'tcx> {\n             feature_err(\n                 &ccx.tcx.sess.parse_sess,\n                 sym::const_fn_fn_ptr_basics,\n@@ -612,16 +725,12 @@ pub mod ty {\n \n     #[derive(Debug)]\n     pub struct ImplTrait;\n-    impl NonConstOp for ImplTrait {\n+    impl<'tcx> NonConstOp<'tcx> for ImplTrait {\n         fn status_in_item(&self, _: &ConstCx<'_, '_>) -> Status {\n             Status::Unstable(sym::const_impl_trait)\n         }\n \n-        fn build_error<'tcx>(\n-            &self,\n-            ccx: &ConstCx<'_, 'tcx>,\n-            span: Span,\n-        ) -> DiagnosticBuilder<'tcx> {\n+        fn build_error(&self, ccx: &ConstCx<'_, 'tcx>, span: Span) -> DiagnosticBuilder<'tcx> {\n             feature_err(\n                 &ccx.tcx.sess.parse_sess,\n                 sym::const_impl_trait,\n@@ -633,7 +742,7 @@ pub mod ty {\n \n     #[derive(Debug)]\n     pub struct TraitBound(pub mir::LocalKind);\n-    impl NonConstOp for TraitBound {\n+    impl<'tcx> NonConstOp<'tcx> for TraitBound {\n         fn importance(&self) -> DiagnosticImportance {\n             match self.0 {\n                 mir::LocalKind::Var | mir::LocalKind::Temp => DiagnosticImportance::Secondary,\n@@ -643,19 +752,15 @@ pub mod ty {\n             }\n         }\n \n-        fn status_in_item(&self, ccx: &ConstCx<'_, '_>) -> Status {\n+        fn status_in_item(&self, ccx: &ConstCx<'_, 'tcx>) -> Status {\n             if ccx.const_kind() != hir::ConstContext::ConstFn {\n                 Status::Allowed\n             } else {\n                 Status::Unstable(sym::const_fn_trait_bound)\n             }\n         }\n \n-        fn build_error<'tcx>(\n-            &self,\n-            ccx: &ConstCx<'_, 'tcx>,\n-            span: Span,\n-        ) -> DiagnosticBuilder<'tcx> {\n+        fn build_error(&self, ccx: &ConstCx<'_, 'tcx>, span: Span) -> DiagnosticBuilder<'tcx> {\n             let mut err = feature_err(\n                 &ccx.tcx.sess.parse_sess,\n                 sym::const_fn_trait_bound,\n@@ -676,7 +781,7 @@ pub mod ty {\n \n     #[derive(Debug)]\n     pub struct DynTrait(pub mir::LocalKind);\n-    impl NonConstOp for DynTrait {\n+    impl<'tcx> NonConstOp<'tcx> for DynTrait {\n         fn importance(&self) -> DiagnosticImportance {\n             match self.0 {\n                 mir::LocalKind::Var | mir::LocalKind::Temp => DiagnosticImportance::Secondary,\n@@ -686,19 +791,15 @@ pub mod ty {\n             }\n         }\n \n-        fn status_in_item(&self, ccx: &ConstCx<'_, '_>) -> Status {\n+        fn status_in_item(&self, ccx: &ConstCx<'_, 'tcx>) -> Status {\n             if ccx.const_kind() != hir::ConstContext::ConstFn {\n                 Status::Allowed\n             } else {\n                 Status::Unstable(sym::const_fn_trait_bound)\n             }\n         }\n \n-        fn build_error<'tcx>(\n-            &self,\n-            ccx: &ConstCx<'_, 'tcx>,\n-            span: Span,\n-        ) -> DiagnosticBuilder<'tcx> {\n+        fn build_error(&self, ccx: &ConstCx<'_, 'tcx>, span: Span) -> DiagnosticBuilder<'tcx> {\n             let mut err = feature_err(\n                 &ccx.tcx.sess.parse_sess,\n                 sym::const_fn_trait_bound,\n@@ -720,16 +821,12 @@ pub mod ty {\n     /// A trait bound with the `?const Trait` opt-out\n     #[derive(Debug)]\n     pub struct TraitBoundNotConst;\n-    impl NonConstOp for TraitBoundNotConst {\n-        fn status_in_item(&self, _: &ConstCx<'_, '_>) -> Status {\n+    impl<'tcx> NonConstOp<'tcx> for TraitBoundNotConst {\n+        fn status_in_item(&self, _: &ConstCx<'_, 'tcx>) -> Status {\n             Status::Unstable(sym::const_trait_bound_opt_out)\n         }\n \n-        fn build_error<'tcx>(\n-            &self,\n-            ccx: &ConstCx<'_, 'tcx>,\n-            span: Span,\n-        ) -> DiagnosticBuilder<'tcx> {\n+        fn build_error(&self, ccx: &ConstCx<'_, 'tcx>, span: Span) -> DiagnosticBuilder<'tcx> {\n             feature_err(\n                 &ccx.tcx.sess.parse_sess,\n                 sym::const_trait_bound_opt_out,"}, {"sha": "34925692664beca01b1b3104bde86c4951f19043", "filename": "compiler/rustc_const_eval/src/util/call_kind.rs", "status": "added", "additions": 145, "deletions": 0, "changes": 145, "blob_url": "https://github.com/rust-lang/rust/blob/f7f0f843b70f1b6c4ac9e22789d93d7bf5569dc3/compiler%2Frustc_const_eval%2Fsrc%2Futil%2Fcall_kind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f7f0f843b70f1b6c4ac9e22789d93d7bf5569dc3/compiler%2Frustc_const_eval%2Fsrc%2Futil%2Fcall_kind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Futil%2Fcall_kind.rs?ref=f7f0f843b70f1b6c4ac9e22789d93d7bf5569dc3", "patch": "@@ -0,0 +1,145 @@\n+//! Common logic for borrowck use-after-move errors when moved into a `fn(self)`,\n+//! as well as errors when attempting to call a non-const function in a const\n+//! context.\n+\n+use rustc_hir::def_id::DefId;\n+use rustc_hir::lang_items::LangItemGroup;\n+use rustc_middle::ty::subst::SubstsRef;\n+use rustc_middle::ty::{self, AssocItemContainer, DefIdTree, Instance, ParamEnv, Ty, TyCtxt};\n+use rustc_span::symbol::Ident;\n+use rustc_span::{sym, DesugaringKind, Span};\n+\n+#[derive(Clone, Copy, PartialEq, Eq, Debug)]\n+pub enum CallDesugaringKind {\n+    /// for _ in x {} calls x.into_iter()\n+    ForLoopIntoIter,\n+    /// x? calls x.branch()\n+    QuestionBranch,\n+    /// x? calls type_of(x)::from_residual()\n+    QuestionFromResidual,\n+    /// try { ..; x } calls type_of(x)::from_output(x)\n+    TryBlockFromOutput,\n+}\n+\n+impl CallDesugaringKind {\n+    pub fn trait_def_id(self, tcx: TyCtxt<'_>) -> DefId {\n+        match self {\n+            Self::ForLoopIntoIter => tcx.get_diagnostic_item(sym::IntoIterator).unwrap(),\n+            Self::QuestionBranch | Self::TryBlockFromOutput => {\n+                tcx.lang_items().try_trait().unwrap()\n+            }\n+            Self::QuestionFromResidual => tcx.get_diagnostic_item(sym::FromResidual).unwrap(),\n+        }\n+    }\n+}\n+\n+#[derive(Clone, Copy, PartialEq, Eq, Debug)]\n+pub enum CallKind<'tcx> {\n+    /// A normal method call of the form `receiver.foo(a, b, c)`\n+    Normal {\n+        self_arg: Option<Ident>,\n+        desugaring: Option<(CallDesugaringKind, Ty<'tcx>)>,\n+        /// Whether the self type of the method call has an `.as_ref()` method.\n+        /// Used for better diagnostics.\n+        is_option_or_result: bool,\n+    },\n+    /// A call to `Fn(..)::call(..)`, desugared from `my_closure(a, b, c)`\n+    FnCall(DefId),\n+    /// A call to an operator trait, desuraged from operator syntax (e.g. `a << b`)\n+    Operator { self_arg: Option<Ident>, trait_id: DefId, self_ty: Ty<'tcx> },\n+    DerefCoercion {\n+        /// The `Span` of the `Target` associated type\n+        /// in the `Deref` impl we are using.\n+        deref_target: Span,\n+        /// The type `T::Deref` we are dereferencing to\n+        deref_target_ty: Ty<'tcx>,\n+        self_ty: Ty<'tcx>,\n+    },\n+}\n+\n+pub fn call_kind<'tcx>(\n+    tcx: TyCtxt<'tcx>,\n+    param_env: ParamEnv<'tcx>,\n+    method_did: DefId,\n+    method_substs: SubstsRef<'tcx>,\n+    fn_call_span: Span,\n+    from_hir_call: bool,\n+    self_arg: Option<Ident>,\n+) -> CallKind<'tcx> {\n+    let parent = tcx.opt_associated_item(method_did).and_then(|assoc| match assoc.container {\n+        AssocItemContainer::ImplContainer(impl_did) => tcx.trait_id_of_impl(impl_did),\n+        AssocItemContainer::TraitContainer(trait_did) => Some(trait_did),\n+    });\n+\n+    let fn_call = (!from_hir_call)\n+        .then(|| parent)\n+        .flatten()\n+        .and_then(|p| tcx.lang_items().group(LangItemGroup::Fn).iter().find(|did| **did == p));\n+\n+    let operator = (!from_hir_call)\n+        .then(|| parent)\n+        .flatten()\n+        .and_then(|p| tcx.lang_items().group(LangItemGroup::Op).iter().find(|did| **did == p));\n+\n+    let is_deref = !from_hir_call && tcx.is_diagnostic_item(sym::deref_method, method_did);\n+\n+    // Check for a 'special' use of 'self' -\n+    // an FnOnce call, an operator (e.g. `<<`), or a\n+    // deref coercion.\n+    let kind = if let Some(&trait_id) = fn_call {\n+        Some(CallKind::FnCall(trait_id))\n+    } else if let Some(&trait_id) = operator {\n+        Some(CallKind::Operator { self_arg, trait_id, self_ty: method_substs.type_at(0) })\n+    } else if is_deref {\n+        let deref_target = tcx.get_diagnostic_item(sym::deref_target).and_then(|deref_target| {\n+            Instance::resolve(tcx, param_env, deref_target, method_substs).transpose()\n+        });\n+        if let Some(Ok(instance)) = deref_target {\n+            let deref_target_ty = instance.ty(tcx, param_env);\n+            Some(CallKind::DerefCoercion {\n+                deref_target: tcx.def_span(instance.def_id()),\n+                deref_target_ty,\n+                self_ty: method_substs.type_at(0),\n+            })\n+        } else {\n+            None\n+        }\n+    } else {\n+        None\n+    };\n+\n+    kind.unwrap_or_else(|| {\n+        // This isn't a 'special' use of `self`\n+        debug!(?method_did, ?fn_call_span);\n+        let desugaring = if Some(method_did) == tcx.lang_items().into_iter_fn()\n+            && fn_call_span.desugaring_kind() == Some(DesugaringKind::ForLoop)\n+        {\n+            Some((CallDesugaringKind::ForLoopIntoIter, method_substs.type_at(0)))\n+        } else if fn_call_span.desugaring_kind() == Some(DesugaringKind::QuestionMark) {\n+            if Some(method_did) == tcx.lang_items().branch_fn() {\n+                Some((CallDesugaringKind::QuestionBranch, method_substs.type_at(0)))\n+            } else if Some(method_did) == tcx.lang_items().from_residual_fn() {\n+                Some((CallDesugaringKind::QuestionFromResidual, method_substs.type_at(0)))\n+            } else {\n+                None\n+            }\n+        } else if Some(method_did) == tcx.lang_items().from_output_fn()\n+            && fn_call_span.desugaring_kind() == Some(DesugaringKind::TryBlock)\n+        {\n+            Some((CallDesugaringKind::TryBlockFromOutput, method_substs.type_at(0)))\n+        } else {\n+            None\n+        };\n+        let parent_self_ty = tcx\n+            .parent(method_did)\n+            .filter(|did| tcx.def_kind(*did) == rustc_hir::def::DefKind::Impl)\n+            .and_then(|did| match tcx.type_of(did).kind() {\n+                ty::Adt(def, ..) => Some(def.did),\n+                _ => None,\n+            });\n+        let is_option_or_result = parent_self_ty.map_or(false, |def_id| {\n+            matches!(tcx.get_diagnostic_name(def_id), Some(sym::Option | sym::Result))\n+        });\n+        CallKind::Normal { self_arg, desugaring, is_option_or_result }\n+    })\n+}"}, {"sha": "a1876bed83eca4a1bfac1eb0d781e1b707ea50de", "filename": "compiler/rustc_const_eval/src/util/mod.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f7f0f843b70f1b6c4ac9e22789d93d7bf5569dc3/compiler%2Frustc_const_eval%2Fsrc%2Futil%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f7f0f843b70f1b6c4ac9e22789d93d7bf5569dc3/compiler%2Frustc_const_eval%2Fsrc%2Futil%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Futil%2Fmod.rs?ref=f7f0f843b70f1b6c4ac9e22789d93d7bf5569dc3", "patch": "@@ -1,8 +1,10 @@\n pub mod aggregate;\n mod alignment;\n+mod call_kind;\n pub mod collect_writes;\n mod find_self_call;\n \n pub use self::aggregate::expand_aggregate;\n pub use self::alignment::is_disaligned;\n+pub use self::call_kind::{call_kind, CallDesugaringKind, CallKind};\n pub use self::find_self_call::find_self_call;"}, {"sha": "3e0bc2e58fc4cfc312e9abe492c09258a75ab08b", "filename": "compiler/rustc_hir/src/lang_items.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/f7f0f843b70f1b6c4ac9e22789d93d7bf5569dc3/compiler%2Frustc_hir%2Fsrc%2Flang_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f7f0f843b70f1b6c4ac9e22789d93d7bf5569dc3/compiler%2Frustc_hir%2Fsrc%2Flang_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir%2Fsrc%2Flang_items.rs?ref=f7f0f843b70f1b6c4ac9e22789d93d7bf5569dc3", "patch": "@@ -21,6 +21,7 @@ use std::lazy::SyncLazy;\n \n pub enum LangItemGroup {\n     Op,\n+    Fn,\n }\n \n const NUM_GROUPS: usize = 1;\n@@ -251,9 +252,9 @@ language_item_table! {\n     DerefTarget,             sym::deref_target,        deref_target,               Target::AssocTy,        GenericRequirement::None;\n     Receiver,                sym::receiver,            receiver_trait,             Target::Trait,          GenericRequirement::None;\n \n-    Fn,                      kw::Fn,                   fn_trait,                   Target::Trait,          GenericRequirement::Exact(1);\n-    FnMut,                   sym::fn_mut,              fn_mut_trait,               Target::Trait,          GenericRequirement::Exact(1);\n-    FnOnce,                  sym::fn_once,             fn_once_trait,              Target::Trait,          GenericRequirement::Exact(1);\n+    Fn(Fn),                  kw::Fn,                   fn_trait,                   Target::Trait,          GenericRequirement::Exact(1);\n+    FnMut(Fn),               sym::fn_mut,              fn_mut_trait,               Target::Trait,          GenericRequirement::Exact(1);\n+    FnOnce(Fn),              sym::fn_once,             fn_once_trait,              Target::Trait,          GenericRequirement::Exact(1);\n \n     FnOnceOutput,            sym::fn_once_output,      fn_once_output,             Target::AssocTy,        GenericRequirement::None;\n \n@@ -264,8 +265,8 @@ language_item_table! {\n     Unpin,                   sym::unpin,               unpin_trait,                Target::Trait,          GenericRequirement::None;\n     Pin,                     sym::pin,                 pin_type,                   Target::Struct,         GenericRequirement::None;\n \n-    PartialEq,               sym::eq,                  eq_trait,                   Target::Trait,          GenericRequirement::Exact(1);\n-    PartialOrd,              sym::partial_ord,         partial_ord_trait,          Target::Trait,          GenericRequirement::Exact(1);\n+    PartialEq(Op),           sym::eq,                  eq_trait,                   Target::Trait,          GenericRequirement::Exact(1);\n+    PartialOrd(Op),          sym::partial_ord,         partial_ord_trait,          Target::Trait,          GenericRequirement::Exact(1);\n \n     // A number of panic-related lang items. The `panic` item corresponds to divide-by-zero and\n     // various panic cases with `match`. The `panic_bounds_check` item is for indexing arrays."}, {"sha": "2e4515022636639ff158255341df74ff35290fff", "filename": "compiler/rustc_span/src/symbol.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f7f0f843b70f1b6c4ac9e22789d93d7bf5569dc3/compiler%2Frustc_span%2Fsrc%2Fsymbol.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f7f0f843b70f1b6c4ac9e22789d93d7bf5569dc3/compiler%2Frustc_span%2Fsrc%2Fsymbol.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_span%2Fsrc%2Fsymbol.rs?ref=f7f0f843b70f1b6c4ac9e22789d93d7bf5569dc3", "patch": "@@ -184,6 +184,7 @@ symbols! {\n         Formatter,\n         From,\n         FromIterator,\n+        FromResidual,\n         Future,\n         FxHashMap,\n         FxHashSet,"}, {"sha": "ba369e7f3aaa0a2af92477588d6e36e4500405d7", "filename": "library/core/src/ops/try_trait.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f7f0f843b70f1b6c4ac9e22789d93d7bf5569dc3/library%2Fcore%2Fsrc%2Fops%2Ftry_trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f7f0f843b70f1b6c4ac9e22789d93d7bf5569dc3/library%2Fcore%2Fsrc%2Fops%2Ftry_trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fops%2Ftry_trait.rs?ref=f7f0f843b70f1b6c4ac9e22789d93d7bf5569dc3", "patch": "@@ -302,6 +302,7 @@ pub trait Try: FromResidual {\n         enclosing_scope = \"this function should return `Result` or `Option` to accept `?`\"\n     ),\n )]\n+#[rustc_diagnostic_item = \"FromResidual\"]\n #[unstable(feature = \"try_trait_v2\", issue = \"84277\")]\n pub trait FromResidual<R = <Self as Try>::Residual> {\n     /// Constructs the type from a compatible `Residual` type."}]}