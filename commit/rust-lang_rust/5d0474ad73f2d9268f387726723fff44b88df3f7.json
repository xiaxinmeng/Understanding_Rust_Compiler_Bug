{"sha": "5d0474ad73f2d9268f387726723fff44b88df3f7", "node_id": "MDY6Q29tbWl0NzI0NzEyOjVkMDQ3NGFkNzNmMmQ5MjY4ZjM4NzcyNjcyM2ZmZjQ0Yjg4ZGYzZjc=", "commit": {"author": {"name": "kennytm", "email": "kennytm@gmail.com", "date": "2018-01-15T08:55:28Z"}, "committer": {"name": "kennytm", "email": "kennytm@gmail.com", "date": "2018-01-15T10:49:31Z"}, "message": "Rollup merge of #47126 - sdroege:exact-chunks, r=bluss\n\nAdd slice::ExactChunks and ::ExactChunksMut iterators\n\nThese guarantee that always the requested slice size will be returned\nand any leftoever elements at the end will be ignored. It allows llvm to\nget rid of bounds checks in the code using the iterator.\n\nThis is inspired by the same iterators provided by ndarray.\n\nFixes https://github.com/rust-lang/rust/issues/47115\n\nI'll add unit tests for all this if the general idea and behaviour makes sense for everybody.\nAlso see https://github.com/rust-lang/rust/issues/47115#issuecomment-354715511 for an example what this improves.", "tree": {"sha": "cf53cdd7104281472d4d80bfe20799063ca5d8d5", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/cf53cdd7104281472d4d80bfe20799063ca5d8d5"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5d0474ad73f2d9268f387726723fff44b88df3f7", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCAAdFiEEZ1R8CLMp8f2GxWoQ/vbIBR0OATwFAlpchzsACgkQ/vbIBR0O\nATzuaA/+KthZ4kaTVfp7VU/yiIwADzdsqusMKjJUJj2teSchS12VMLf/8AVH2a7e\nRP1F4IBemv85BJEXc7nApfWgoSvAHcGNQXWkZUhwjiA55e9paSvsJst+n0vM/FSU\ndARWEMt+2C7PzR1HZoZEBjU3V36IupZHInf6WHx5NsGxrI73HjSgGeBwRRsdNbte\nD8m3+pSIwUxdrrrl2Y7t3mvPL8dBAqqG7Z2p4nOsqqP1Lx8FD8o7fkqA4weEmrmV\nJUWG1HJqKXqBJdg3fwotRlxLoa2YChvCpEoPm9laKmf9NbAG83ezR+mEkojVdHWq\nCOBHDi286QoxlRsYYcLvHcBtKTnpS/sFT/JbJ3cs4tOUcZ80suEW0cgKUL9iBS+n\nqeGvBnc+6IsVXzInU163Tv2r5rrl9O/trOak6FbX9GCPC+vtqIrc8qRiQpNZx7+u\nq9Fg4COVgD5H7o7rbHdeveTeP7Rd4AtRi0Sd+xcJ/lhI1GboiUAhBsZ0e8Ij89DR\n6JrWSHziiWDZ/Xnw2qMh7rKrPEWTNr49gEYsLYE9Vi9ZnU9uj7DNBMXIgGwD6WvO\nblZD3HUtqs1feHh9GApTkzcOeTxjubUfmuWSFfsZC3StMsb6ti5F6OYc0WcKunC8\nnjcdLKleUKU/0+hrbLVYv/5yUckr6wvxCKunquQYpqWYBW6Vt0M=\n=bgDo\n-----END PGP SIGNATURE-----", "payload": "tree cf53cdd7104281472d4d80bfe20799063ca5d8d5\nparent 06112abd5f170e9f1ee06e212acb31976d6bb7c4\nparent 5f4fc8214279f2ffadbf2cc3a4c22b748c17bd15\nauthor kennytm <kennytm@gmail.com> 1516006528 +0800\ncommitter kennytm <kennytm@gmail.com> 1516013371 +0800\n\nRollup merge of #47126 - sdroege:exact-chunks, r=bluss\n\nAdd slice::ExactChunks and ::ExactChunksMut iterators\n\nThese guarantee that always the requested slice size will be returned\nand any leftoever elements at the end will be ignored. It allows llvm to\nget rid of bounds checks in the code using the iterator.\n\nThis is inspired by the same iterators provided by ndarray.\n\nFixes https://github.com/rust-lang/rust/issues/47115\n\nI'll add unit tests for all this if the general idea and behaviour makes sense for everybody.\nAlso see https://github.com/rust-lang/rust/issues/47115#issuecomment-354715511 for an example what this improves.\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5d0474ad73f2d9268f387726723fff44b88df3f7", "html_url": "https://github.com/rust-lang/rust/commit/5d0474ad73f2d9268f387726723fff44b88df3f7", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5d0474ad73f2d9268f387726723fff44b88df3f7/comments", "author": {"login": "kennytm", "id": 103023, "node_id": "MDQ6VXNlcjEwMzAyMw==", "avatar_url": "https://avatars.githubusercontent.com/u/103023?v=4", "gravatar_id": "", "url": "https://api.github.com/users/kennytm", "html_url": "https://github.com/kennytm", "followers_url": "https://api.github.com/users/kennytm/followers", "following_url": "https://api.github.com/users/kennytm/following{/other_user}", "gists_url": "https://api.github.com/users/kennytm/gists{/gist_id}", "starred_url": "https://api.github.com/users/kennytm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/kennytm/subscriptions", "organizations_url": "https://api.github.com/users/kennytm/orgs", "repos_url": "https://api.github.com/users/kennytm/repos", "events_url": "https://api.github.com/users/kennytm/events{/privacy}", "received_events_url": "https://api.github.com/users/kennytm/received_events", "type": "User", "site_admin": false}, "committer": {"login": "kennytm", "id": 103023, "node_id": "MDQ6VXNlcjEwMzAyMw==", "avatar_url": "https://avatars.githubusercontent.com/u/103023?v=4", "gravatar_id": "", "url": "https://api.github.com/users/kennytm", "html_url": "https://github.com/kennytm", "followers_url": "https://api.github.com/users/kennytm/followers", "following_url": "https://api.github.com/users/kennytm/following{/other_user}", "gists_url": "https://api.github.com/users/kennytm/gists{/gist_id}", "starred_url": "https://api.github.com/users/kennytm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/kennytm/subscriptions", "organizations_url": "https://api.github.com/users/kennytm/orgs", "repos_url": "https://api.github.com/users/kennytm/repos", "events_url": "https://api.github.com/users/kennytm/events{/privacy}", "received_events_url": "https://api.github.com/users/kennytm/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "06112abd5f170e9f1ee06e212acb31976d6bb7c4", "url": "https://api.github.com/repos/rust-lang/rust/commits/06112abd5f170e9f1ee06e212acb31976d6bb7c4", "html_url": "https://github.com/rust-lang/rust/commit/06112abd5f170e9f1ee06e212acb31976d6bb7c4"}, {"sha": "5f4fc8214279f2ffadbf2cc3a4c22b748c17bd15", "url": "https://api.github.com/repos/rust-lang/rust/commits/5f4fc8214279f2ffadbf2cc3a4c22b748c17bd15", "html_url": "https://github.com/rust-lang/rust/commit/5f4fc8214279f2ffadbf2cc3a4c22b748c17bd15"}], "stats": {"total": 482, "additions": 472, "deletions": 10}, "files": [{"sha": "d8ce28695ab6f3049a6ea5e0c5ec7fe6fe8b36de", "filename": "src/liballoc/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/5d0474ad73f2d9268f387726723fff44b88df3f7/src%2Fliballoc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d0474ad73f2d9268f387726723fff44b88df3f7/src%2Fliballoc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Flib.rs?ref=5d0474ad73f2d9268f387726723fff44b88df3f7", "patch": "@@ -124,6 +124,7 @@\n #![feature(unsize)]\n #![feature(allocator_internals)]\n #![feature(on_unimplemented)]\n+#![feature(exact_chunks)]\n \n #![cfg_attr(not(test), feature(fused, fn_traits, placement_new_protocol, swap_with_slice, i128))]\n #![cfg_attr(test, feature(test, box_heap))]"}, {"sha": "861f72bcf88ee42b2e5fcf711a9fc1a1a6c358f4", "filename": "src/liballoc/slice.rs", "status": "modified", "additions": 74, "deletions": 0, "changes": 74, "blob_url": "https://github.com/rust-lang/rust/blob/5d0474ad73f2d9268f387726723fff44b88df3f7/src%2Fliballoc%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d0474ad73f2d9268f387726723fff44b88df3f7/src%2Fliballoc%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fslice.rs?ref=5d0474ad73f2d9268f387726723fff44b88df3f7", "patch": "@@ -123,6 +123,8 @@ pub use core::slice::{from_raw_parts, from_raw_parts_mut};\n pub use core::slice::{from_ref, from_ref_mut};\n #[unstable(feature = \"slice_get_slice\", issue = \"35729\")]\n pub use core::slice::SliceIndex;\n+#[unstable(feature = \"exact_chunks\", issue = \"47115\")]\n+pub use core::slice::{ExactChunks, ExactChunksMut};\n \n ////////////////////////////////////////////////////////////////////////////////\n // Basic slice extension methods\n@@ -611,6 +613,9 @@ impl<T> [T] {\n     /// not divide the length of the slice, then the last chunk will\n     /// not have length `chunk_size`.\n     ///\n+    /// See [`exact_chunks`] for a variant of this iterator that returns chunks\n+    /// of always exactly `chunk_size` elements.\n+    ///\n     /// # Panics\n     ///\n     /// Panics if `chunk_size` is 0.\n@@ -631,11 +636,44 @@ impl<T> [T] {\n         core_slice::SliceExt::chunks(self, chunk_size)\n     }\n \n+    /// Returns an iterator over `chunk_size` elements of the slice at a\n+    /// time. The chunks are slices and do not overlap. If `chunk_size` does\n+    /// not divide the length of the slice, then the last up to `chunk_size-1`\n+    /// elements will be omitted.\n+    ///\n+    /// Due to each chunk having exactly `chunk_size` elements, the compiler\n+    /// can often optimize the resulting code better than in the case of\n+    /// [`chunks`].\n+    ///\n+    /// # Panics\n+    ///\n+    /// Panics if `chunk_size` is 0.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(exact_chunks)]\n+    ///\n+    /// let slice = ['l', 'o', 'r', 'e', 'm'];\n+    /// let mut iter = slice.exact_chunks(2);\n+    /// assert_eq!(iter.next().unwrap(), &['l', 'o']);\n+    /// assert_eq!(iter.next().unwrap(), &['r', 'e']);\n+    /// assert!(iter.next().is_none());\n+    /// ```\n+    #[unstable(feature = \"exact_chunks\", issue = \"47115\")]\n+    #[inline]\n+    pub fn exact_chunks(&self, chunk_size: usize) -> ExactChunks<T> {\n+        core_slice::SliceExt::exact_chunks(self, chunk_size)\n+    }\n+\n     /// Returns an iterator over `chunk_size` elements of the slice at a time.\n     /// The chunks are mutable slices, and do not overlap. If `chunk_size` does\n     /// not divide the length of the slice, then the last chunk will not\n     /// have length `chunk_size`.\n     ///\n+    /// See [`exact_chunks_mut`] for a variant of this iterator that returns chunks\n+    /// of always exactly `chunk_size` elements.\n+    ///\n     /// # Panics\n     ///\n     /// Panics if `chunk_size` is 0.\n@@ -660,6 +698,42 @@ impl<T> [T] {\n         core_slice::SliceExt::chunks_mut(self, chunk_size)\n     }\n \n+    /// Returns an iterator over `chunk_size` elements of the slice at a time.\n+    /// The chunks are mutable slices, and do not overlap. If `chunk_size` does\n+    /// not divide the length of the slice, then the last up to `chunk_size-1`\n+    /// elements will be omitted.\n+    ///\n+    ///\n+    /// Due to each chunk having exactly `chunk_size` elements, the compiler\n+    /// can often optimize the resulting code better than in the case of\n+    /// [`chunks_mut`].\n+    ///\n+    /// # Panics\n+    ///\n+    /// Panics if `chunk_size` is 0.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(exact_chunks)]\n+    ///\n+    /// let v = &mut [0, 0, 0, 0, 0];\n+    /// let mut count = 1;\n+    ///\n+    /// for chunk in v.exact_chunks_mut(2) {\n+    ///     for elem in chunk.iter_mut() {\n+    ///         *elem += count;\n+    ///     }\n+    ///     count += 1;\n+    /// }\n+    /// assert_eq!(v, &[1, 1, 2, 2, 0]);\n+    /// ```\n+    #[unstable(feature = \"exact_chunks\", issue = \"47115\")]\n+    #[inline]\n+    pub fn exact_chunks_mut(&mut self, chunk_size: usize) -> ExactChunksMut<T> {\n+        core_slice::SliceExt::exact_chunks_mut(self, chunk_size)\n+    }\n+\n     /// Divides one slice into two at an index.\n     ///\n     /// The first will contain all indices from `[0, mid)` (excluding"}, {"sha": "eee229bc6fdfa7aef1d6a908dcfa319a39cb25c1", "filename": "src/liballoc/tests/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/5d0474ad73f2d9268f387726723fff44b88df3f7/src%2Fliballoc%2Ftests%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d0474ad73f2d9268f387726723fff44b88df3f7/src%2Fliballoc%2Ftests%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Ftests%2Flib.rs?ref=5d0474ad73f2d9268f387726723fff44b88df3f7", "patch": "@@ -30,6 +30,7 @@\n #![feature(string_retain)]\n #![feature(unboxed_closures)]\n #![feature(unicode)]\n+#![feature(exact_chunks)]\n \n extern crate alloc_system;\n extern crate std_unicode;"}, {"sha": "1a9d26fd1a29150b5c18f950d49f0b5deb70aa4b", "filename": "src/liballoc/tests/slice.rs", "status": "modified", "additions": 58, "deletions": 2, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/5d0474ad73f2d9268f387726723fff44b88df3f7/src%2Fliballoc%2Ftests%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d0474ad73f2d9268f387726723fff44b88df3f7/src%2Fliballoc%2Ftests%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Ftests%2Fslice.rs?ref=5d0474ad73f2d9268f387726723fff44b88df3f7", "patch": "@@ -945,6 +945,30 @@ fn test_chunksator_0() {\n     let _it = v.chunks(0);\n }\n \n+#[test]\n+fn test_exact_chunksator() {\n+    let v = &[1, 2, 3, 4, 5];\n+\n+    assert_eq!(v.exact_chunks(2).len(), 2);\n+\n+    let chunks: &[&[_]] = &[&[1, 2], &[3, 4]];\n+    assert_eq!(v.exact_chunks(2).collect::<Vec<_>>(), chunks);\n+    let chunks: &[&[_]] = &[&[1, 2, 3]];\n+    assert_eq!(v.exact_chunks(3).collect::<Vec<_>>(), chunks);\n+    let chunks: &[&[_]] = &[];\n+    assert_eq!(v.exact_chunks(6).collect::<Vec<_>>(), chunks);\n+\n+    let chunks: &[&[_]] = &[&[3, 4], &[1, 2]];\n+    assert_eq!(v.exact_chunks(2).rev().collect::<Vec<_>>(), chunks);\n+}\n+\n+#[test]\n+#[should_panic]\n+fn test_exact_chunksator_0() {\n+    let v = &[1, 2, 3, 4];\n+    let _it = v.exact_chunks(0);\n+}\n+\n #[test]\n fn test_reverse_part() {\n     let mut values = [1, 2, 3, 4, 5];\n@@ -1159,7 +1183,7 @@ fn test_mut_chunks() {\n         }\n     }\n     let result = [0, 0, 0, 1, 1, 1, 2];\n-    assert!(v == result);\n+    assert_eq!(v, result);\n }\n \n #[test]\n@@ -1171,7 +1195,7 @@ fn test_mut_chunks_rev() {\n         }\n     }\n     let result = [2, 2, 2, 1, 1, 1, 0];\n-    assert!(v == result);\n+    assert_eq!(v, result);\n }\n \n #[test]\n@@ -1181,6 +1205,38 @@ fn test_mut_chunks_0() {\n     let _it = v.chunks_mut(0);\n }\n \n+#[test]\n+fn test_mut_exact_chunks() {\n+    let mut v = [0, 1, 2, 3, 4, 5, 6];\n+    assert_eq!(v.exact_chunks_mut(2).len(), 3);\n+    for (i, chunk) in v.exact_chunks_mut(3).enumerate() {\n+        for x in chunk {\n+            *x = i as u8;\n+        }\n+    }\n+    let result = [0, 0, 0, 1, 1, 1, 6];\n+    assert_eq!(v, result);\n+}\n+\n+#[test]\n+fn test_mut_exact_chunks_rev() {\n+    let mut v = [0, 1, 2, 3, 4, 5, 6];\n+    for (i, chunk) in v.exact_chunks_mut(3).rev().enumerate() {\n+        for x in chunk {\n+            *x = i as u8;\n+        }\n+    }\n+    let result = [1, 1, 1, 0, 0, 0, 6];\n+    assert_eq!(v, result);\n+}\n+\n+#[test]\n+#[should_panic]\n+fn test_mut_exact_chunks_0() {\n+    let mut v = [1, 2, 3, 4];\n+    let _it = v.exact_chunks_mut(0);\n+}\n+\n #[test]\n fn test_mut_last() {\n     let mut x = [1, 2, 3, 4, 5];"}, {"sha": "48e82666d35151cafa566bf965cddd874cb8b283", "filename": "src/libcore/slice/mod.rs", "status": "modified", "additions": 225, "deletions": 0, "changes": 225, "blob_url": "https://github.com/rust-lang/rust/blob/5d0474ad73f2d9268f387726723fff44b88df3f7/src%2Flibcore%2Fslice%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d0474ad73f2d9268f387726723fff44b88df3f7/src%2Flibcore%2Fslice%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fslice%2Fmod.rs?ref=5d0474ad73f2d9268f387726723fff44b88df3f7", "patch": "@@ -104,6 +104,9 @@ pub trait SliceExt {\n     #[stable(feature = \"core\", since = \"1.6.0\")]\n     fn chunks(&self, size: usize) -> Chunks<Self::Item>;\n \n+    #[unstable(feature = \"exact_chunks\", issue = \"47115\")]\n+    fn exact_chunks(&self, size: usize) -> ExactChunks<Self::Item>;\n+\n     #[stable(feature = \"core\", since = \"1.6.0\")]\n     fn get<I>(&self, index: I) -> Option<&I::Output>\n         where I: SliceIndex<Self>;\n@@ -181,6 +184,9 @@ pub trait SliceExt {\n     #[stable(feature = \"core\", since = \"1.6.0\")]\n     fn chunks_mut(&mut self, chunk_size: usize) -> ChunksMut<Self::Item>;\n \n+    #[unstable(feature = \"exact_chunks\", issue = \"47115\")]\n+    fn exact_chunks_mut(&mut self, size: usize) -> ExactChunksMut<Self::Item>;\n+\n     #[stable(feature = \"core\", since = \"1.6.0\")]\n     fn swap(&mut self, a: usize, b: usize);\n \n@@ -356,6 +362,14 @@ impl<T> SliceExt for [T] {\n         Chunks { v: self, chunk_size: chunk_size }\n     }\n \n+    #[inline]\n+    fn exact_chunks(&self, chunk_size: usize) -> ExactChunks<T> {\n+        assert!(chunk_size != 0);\n+        let rem = self.len() % chunk_size;\n+        let len = self.len() - rem;\n+        ExactChunks { v: &self[..len], chunk_size: chunk_size}\n+    }\n+\n     #[inline]\n     fn get<I>(&self, index: I) -> Option<&I::Output>\n         where I: SliceIndex<[T]>\n@@ -539,6 +553,14 @@ impl<T> SliceExt for [T] {\n         ChunksMut { v: self, chunk_size: chunk_size }\n     }\n \n+    #[inline]\n+    fn exact_chunks_mut(&mut self, chunk_size: usize) -> ExactChunksMut<T> {\n+        assert!(chunk_size != 0);\n+        let rem = self.len() % chunk_size;\n+        let len = self.len() - rem;\n+        ExactChunksMut { v: &mut self[..len], chunk_size: chunk_size}\n+    }\n+\n     #[inline]\n     fn swap(&mut self, a: usize, b: usize) {\n         unsafe {\n@@ -2378,6 +2400,209 @@ unsafe impl<'a, T> TrustedRandomAccess for ChunksMut<'a, T> {\n     fn may_have_side_effect() -> bool { false }\n }\n \n+/// An iterator over a slice in (non-overlapping) chunks (`chunk_size` elements at a\n+/// time).\n+///\n+/// When the slice len is not evenly divided by the chunk size, the last\n+/// up to `chunk_size-1` elements will be omitted.\n+///\n+/// This struct is created by the [`exact_chunks`] method on [slices].\n+///\n+/// [`exact_chunks`]: ../../std/primitive.slice.html#method.exact_chunks\n+/// [slices]: ../../std/primitive.slice.html\n+#[derive(Debug)]\n+#[unstable(feature = \"exact_chunks\", issue = \"47115\")]\n+pub struct ExactChunks<'a, T:'a> {\n+    v: &'a [T],\n+    chunk_size: usize\n+}\n+\n+// FIXME(#26925) Remove in favor of `#[derive(Clone)]`\n+#[unstable(feature = \"exact_chunks\", issue = \"47115\")]\n+impl<'a, T> Clone for ExactChunks<'a, T> {\n+    fn clone(&self) -> ExactChunks<'a, T> {\n+        ExactChunks {\n+            v: self.v,\n+            chunk_size: self.chunk_size,\n+        }\n+    }\n+}\n+\n+#[unstable(feature = \"exact_chunks\", issue = \"47115\")]\n+impl<'a, T> Iterator for ExactChunks<'a, T> {\n+    type Item = &'a [T];\n+\n+    #[inline]\n+    fn next(&mut self) -> Option<&'a [T]> {\n+        if self.v.len() < self.chunk_size {\n+            None\n+        } else {\n+            let (fst, snd) = self.v.split_at(self.chunk_size);\n+            self.v = snd;\n+            Some(fst)\n+        }\n+    }\n+\n+    #[inline]\n+    fn size_hint(&self) -> (usize, Option<usize>) {\n+        let n = self.v.len() / self.chunk_size;\n+        (n, Some(n))\n+    }\n+\n+    #[inline]\n+    fn count(self) -> usize {\n+        self.len()\n+    }\n+\n+    #[inline]\n+    fn nth(&mut self, n: usize) -> Option<Self::Item> {\n+        let (start, overflow) = n.overflowing_mul(self.chunk_size);\n+        if start >= self.v.len() || overflow {\n+            self.v = &[];\n+            None\n+        } else {\n+            let (_, snd) = self.v.split_at(start);\n+            self.v = snd;\n+            self.next()\n+        }\n+    }\n+\n+    #[inline]\n+    fn last(mut self) -> Option<Self::Item> {\n+        self.next_back()\n+    }\n+}\n+\n+#[unstable(feature = \"exact_chunks\", issue = \"47115\")]\n+impl<'a, T> DoubleEndedIterator for ExactChunks<'a, T> {\n+    #[inline]\n+    fn next_back(&mut self) -> Option<&'a [T]> {\n+        if self.v.len() < self.chunk_size {\n+            None\n+        } else {\n+            let (fst, snd) = self.v.split_at(self.v.len() - self.chunk_size);\n+            self.v = fst;\n+            Some(snd)\n+        }\n+    }\n+}\n+\n+#[unstable(feature = \"exact_chunks\", issue = \"47115\")]\n+impl<'a, T> ExactSizeIterator for ExactChunks<'a, T> {\n+    fn is_empty(&self) -> bool {\n+        self.v.is_empty()\n+    }\n+}\n+\n+#[unstable(feature = \"fused\", issue = \"35602\")]\n+impl<'a, T> FusedIterator for ExactChunks<'a, T> {}\n+\n+#[doc(hidden)]\n+unsafe impl<'a, T> TrustedRandomAccess for ExactChunks<'a, T> {\n+    unsafe fn get_unchecked(&mut self, i: usize) -> &'a [T] {\n+        let start = i * self.chunk_size;\n+        from_raw_parts(self.v.as_ptr().offset(start as isize), self.chunk_size)\n+    }\n+    fn may_have_side_effect() -> bool { false }\n+}\n+\n+/// An iterator over a slice in (non-overlapping) mutable chunks (`chunk_size`\n+/// elements at a time). When the slice len is not evenly divided by the chunk\n+/// size, the last up to `chunk_size-1` elements will be omitted.\n+///\n+/// This struct is created by the [`exact_chunks_mut`] method on [slices].\n+///\n+/// [`exact_chunks_mut`]: ../../std/primitive.slice.html#method.exact_chunks_mut\n+/// [slices]: ../../std/primitive.slice.html\n+#[derive(Debug)]\n+#[unstable(feature = \"exact_chunks\", issue = \"47115\")]\n+pub struct ExactChunksMut<'a, T:'a> {\n+    v: &'a mut [T],\n+    chunk_size: usize\n+}\n+\n+#[unstable(feature = \"exact_chunks\", issue = \"47115\")]\n+impl<'a, T> Iterator for ExactChunksMut<'a, T> {\n+    type Item = &'a mut [T];\n+\n+    #[inline]\n+    fn next(&mut self) -> Option<&'a mut [T]> {\n+        if self.v.len() < self.chunk_size {\n+            None\n+        } else {\n+            let tmp = mem::replace(&mut self.v, &mut []);\n+            let (head, tail) = tmp.split_at_mut(self.chunk_size);\n+            self.v = tail;\n+            Some(head)\n+        }\n+    }\n+\n+    #[inline]\n+    fn size_hint(&self) -> (usize, Option<usize>) {\n+        let n = self.v.len() / self.chunk_size;\n+        (n, Some(n))\n+    }\n+\n+    #[inline]\n+    fn count(self) -> usize {\n+        self.len()\n+    }\n+\n+    #[inline]\n+    fn nth(&mut self, n: usize) -> Option<&'a mut [T]> {\n+        let (start, overflow) = n.overflowing_mul(self.chunk_size);\n+        if start >= self.v.len() || overflow {\n+            self.v = &mut [];\n+            None\n+        } else {\n+            let tmp = mem::replace(&mut self.v, &mut []);\n+            let (_, snd) = tmp.split_at_mut(start);\n+            self.v = snd;\n+            self.next()\n+        }\n+    }\n+\n+    #[inline]\n+    fn last(mut self) -> Option<Self::Item> {\n+        self.next_back()\n+    }\n+}\n+\n+#[unstable(feature = \"exact_chunks\", issue = \"47115\")]\n+impl<'a, T> DoubleEndedIterator for ExactChunksMut<'a, T> {\n+    #[inline]\n+    fn next_back(&mut self) -> Option<&'a mut [T]> {\n+        if self.v.len() < self.chunk_size {\n+            None\n+        } else {\n+            let tmp = mem::replace(&mut self.v, &mut []);\n+            let tmp_len = tmp.len();\n+            let (head, tail) = tmp.split_at_mut(tmp_len - self.chunk_size);\n+            self.v = head;\n+            Some(tail)\n+        }\n+    }\n+}\n+\n+#[unstable(feature = \"exact_chunks\", issue = \"47115\")]\n+impl<'a, T> ExactSizeIterator for ExactChunksMut<'a, T> {\n+    fn is_empty(&self) -> bool {\n+        self.v.is_empty()\n+    }\n+}\n+\n+#[unstable(feature = \"fused\", issue = \"35602\")]\n+impl<'a, T> FusedIterator for ExactChunksMut<'a, T> {}\n+\n+#[doc(hidden)]\n+unsafe impl<'a, T> TrustedRandomAccess for ExactChunksMut<'a, T> {\n+    unsafe fn get_unchecked(&mut self, i: usize) -> &'a mut [T] {\n+        let start = i * self.chunk_size;\n+        from_raw_parts_mut(self.v.as_mut_ptr().offset(start as isize), self.chunk_size)\n+    }\n+    fn may_have_side_effect() -> bool { false }\n+}\n+\n //\n // Free functions\n //"}, {"sha": "2c0009569d75d60dccb391fe2a3a79332f96f929", "filename": "src/libcore/tests/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/5d0474ad73f2d9268f387726723fff44b88df3f7/src%2Flibcore%2Ftests%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d0474ad73f2d9268f387726723fff44b88df3f7/src%2Flibcore%2Ftests%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftests%2Flib.rs?ref=5d0474ad73f2d9268f387726723fff44b88df3f7", "patch": "@@ -42,6 +42,7 @@\n #![feature(try_from)]\n #![feature(try_trait)]\n #![feature(unique)]\n+#![feature(exact_chunks)]\n \n extern crate core;\n extern crate test;"}, {"sha": "f7a4a71e5cfda4909700cd455c5b762d6a3965cd", "filename": "src/libcore/tests/slice.rs", "status": "modified", "additions": 112, "deletions": 8, "changes": 120, "blob_url": "https://github.com/rust-lang/rust/blob/5d0474ad73f2d9268f387726723fff44b88df3f7/src%2Flibcore%2Ftests%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d0474ad73f2d9268f387726723fff44b88df3f7/src%2Flibcore%2Ftests%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftests%2Fslice.rs?ref=5d0474ad73f2d9268f387726723fff44b88df3f7", "patch": "@@ -117,12 +117,12 @@ fn test_chunks_count() {\n fn test_chunks_nth() {\n     let v: &[i32] = &[0, 1, 2, 3, 4, 5];\n     let mut c = v.chunks(2);\n-    assert_eq!(c.nth(1).unwrap()[1], 3);\n-    assert_eq!(c.next().unwrap()[0], 4);\n+    assert_eq!(c.nth(1).unwrap(), &[2, 3]);\n+    assert_eq!(c.next().unwrap(), &[4, 5]);\n \n     let v2: &[i32] = &[0, 1, 2, 3, 4];\n     let mut c2 = v2.chunks(3);\n-    assert_eq!(c2.nth(1).unwrap()[1], 4);\n+    assert_eq!(c2.nth(1).unwrap(), &[3, 4]);\n     assert_eq!(c2.next(), None);\n }\n \n@@ -168,24 +168,24 @@ fn test_chunks_mut_count() {\n fn test_chunks_mut_nth() {\n     let v: &mut [i32] = &mut [0, 1, 2, 3, 4, 5];\n     let mut c = v.chunks_mut(2);\n-    assert_eq!(c.nth(1).unwrap()[1], 3);\n-    assert_eq!(c.next().unwrap()[0], 4);\n+    assert_eq!(c.nth(1).unwrap(), &[2, 3]);\n+    assert_eq!(c.next().unwrap(), &[4, 5]);\n \n     let v2: &mut [i32] = &mut [0, 1, 2, 3, 4];\n     let mut c2 = v2.chunks_mut(3);\n-    assert_eq!(c2.nth(1).unwrap()[1], 4);\n+    assert_eq!(c2.nth(1).unwrap(), &[3, 4]);\n     assert_eq!(c2.next(), None);\n }\n \n #[test]\n fn test_chunks_mut_last() {\n     let v: &mut [i32] = &mut [0, 1, 2, 3, 4, 5];\n     let c = v.chunks_mut(2);\n-    assert_eq!(c.last().unwrap()[1], 5);\n+    assert_eq!(c.last().unwrap(), &[4, 5]);\n \n     let v2: &mut [i32] = &mut [0, 1, 2, 3, 4];\n     let c2 = v2.chunks_mut(2);\n-    assert_eq!(c2.last().unwrap()[0], 4);\n+    assert_eq!(c2.last().unwrap(), &[4]);\n }\n \n #[test]\n@@ -202,6 +202,110 @@ fn test_chunks_mut_zip() {\n     assert_eq!(v1, [13, 14, 19, 20, 14]);\n }\n \n+#[test]\n+fn test_exact_chunks_count() {\n+    let v: &[i32] = &[0, 1, 2, 3, 4, 5];\n+    let c = v.exact_chunks(3);\n+    assert_eq!(c.count(), 2);\n+\n+    let v2: &[i32] = &[0, 1, 2, 3, 4];\n+    let c2 = v2.exact_chunks(2);\n+    assert_eq!(c2.count(), 2);\n+\n+    let v3: &[i32] = &[];\n+    let c3 = v3.exact_chunks(2);\n+    assert_eq!(c3.count(), 0);\n+}\n+\n+#[test]\n+fn test_exact_chunks_nth() {\n+    let v: &[i32] = &[0, 1, 2, 3, 4, 5];\n+    let mut c = v.exact_chunks(2);\n+    assert_eq!(c.nth(1).unwrap(), &[2, 3]);\n+    assert_eq!(c.next().unwrap(), &[4, 5]);\n+\n+    let v2: &[i32] = &[0, 1, 2, 3, 4, 5, 6];\n+    let mut c2 = v2.exact_chunks(3);\n+    assert_eq!(c2.nth(1).unwrap(), &[3, 4, 5]);\n+    assert_eq!(c2.next(), None);\n+}\n+\n+#[test]\n+fn test_exact_chunks_last() {\n+    let v: &[i32] = &[0, 1, 2, 3, 4, 5];\n+    let c = v.exact_chunks(2);\n+    assert_eq!(c.last().unwrap(), &[4, 5]);\n+\n+    let v2: &[i32] = &[0, 1, 2, 3, 4];\n+    let c2 = v2.exact_chunks(2);\n+    assert_eq!(c2.last().unwrap(), &[2, 3]);\n+}\n+\n+#[test]\n+fn test_exact_chunks_zip() {\n+    let v1: &[i32] = &[0, 1, 2, 3, 4];\n+    let v2: &[i32] = &[6, 7, 8, 9, 10];\n+\n+    let res = v1.exact_chunks(2)\n+        .zip(v2.exact_chunks(2))\n+        .map(|(a, b)| a.iter().sum::<i32>() + b.iter().sum::<i32>())\n+        .collect::<Vec<_>>();\n+    assert_eq!(res, vec![14, 22]);\n+}\n+\n+#[test]\n+fn test_exact_chunks_mut_count() {\n+    let v: &mut [i32] = &mut [0, 1, 2, 3, 4, 5];\n+    let c = v.exact_chunks_mut(3);\n+    assert_eq!(c.count(), 2);\n+\n+    let v2: &mut [i32] = &mut [0, 1, 2, 3, 4];\n+    let c2 = v2.exact_chunks_mut(2);\n+    assert_eq!(c2.count(), 2);\n+\n+    let v3: &mut [i32] = &mut [];\n+    let c3 = v3.exact_chunks_mut(2);\n+    assert_eq!(c3.count(), 0);\n+}\n+\n+#[test]\n+fn test_exact_chunks_mut_nth() {\n+    let v: &mut [i32] = &mut [0, 1, 2, 3, 4, 5];\n+    let mut c = v.exact_chunks_mut(2);\n+    assert_eq!(c.nth(1).unwrap(), &[2, 3]);\n+    assert_eq!(c.next().unwrap(), &[4, 5]);\n+\n+    let v2: &mut [i32] = &mut [0, 1, 2, 3, 4, 5, 6];\n+    let mut c2 = v2.exact_chunks_mut(3);\n+    assert_eq!(c2.nth(1).unwrap(), &[3, 4, 5]);\n+    assert_eq!(c2.next(), None);\n+}\n+\n+#[test]\n+fn test_exact_chunks_mut_last() {\n+    let v: &mut [i32] = &mut [0, 1, 2, 3, 4, 5];\n+    let c = v.exact_chunks_mut(2);\n+    assert_eq!(c.last().unwrap(), &[4, 5]);\n+\n+    let v2: &mut [i32] = &mut [0, 1, 2, 3, 4];\n+    let c2 = v2.exact_chunks_mut(2);\n+    assert_eq!(c2.last().unwrap(), &[2, 3]);\n+}\n+\n+#[test]\n+fn test_exact_chunks_mut_zip() {\n+    let v1: &mut [i32] = &mut [0, 1, 2, 3, 4];\n+    let v2: &[i32] = &[6, 7, 8, 9, 10];\n+\n+    for (a, b) in v1.exact_chunks_mut(2).zip(v2.exact_chunks(2)) {\n+        let sum = b.iter().sum::<i32>();\n+        for v in a {\n+            *v += sum;\n+        }\n+    }\n+    assert_eq!(v1, [13, 14, 19, 20, 4]);\n+}\n+\n #[test]\n fn test_windows_count() {\n     let v: &[i32] = &[0, 1, 2, 3, 4, 5];"}]}