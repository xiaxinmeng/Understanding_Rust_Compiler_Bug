{"sha": "ab91c70cc69450bc69b76df0fd2faa82bda42d6b", "node_id": "MDY6Q29tbWl0NzI0NzEyOmFiOTFjNzBjYzY5NDUwYmM2OWI3NmRmMGZkMmZhYTgyYmRhNDJkNmI=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-07-14T00:50:33Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-07-14T00:50:33Z"}, "message": "Auto merge of #43216 - steveklabnik:rollup, r=steveklabnik\n\nRollup of 7 pull requests\n\n- Successful merges: #42926, #43125, #43157, #43167, #43187, #43203, #43204\n- Failed merges:", "tree": {"sha": "d79dcef1bcd5099dfe9617ac181dcbbc0baba97b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d79dcef1bcd5099dfe9617ac181dcbbc0baba97b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ab91c70cc69450bc69b76df0fd2faa82bda42d6b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ab91c70cc69450bc69b76df0fd2faa82bda42d6b", "html_url": "https://github.com/rust-lang/rust/commit/ab91c70cc69450bc69b76df0fd2faa82bda42d6b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ab91c70cc69450bc69b76df0fd2faa82bda42d6b/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b2c0707872082c890f332178f59fd02eea5b98f3", "url": "https://api.github.com/repos/rust-lang/rust/commits/b2c0707872082c890f332178f59fd02eea5b98f3", "html_url": "https://github.com/rust-lang/rust/commit/b2c0707872082c890f332178f59fd02eea5b98f3"}, {"sha": "da3f5b80ed8a0fb88aae2d2a462acc97b05ba911", "url": "https://api.github.com/repos/rust-lang/rust/commits/da3f5b80ed8a0fb88aae2d2a462acc97b05ba911", "html_url": "https://github.com/rust-lang/rust/commit/da3f5b80ed8a0fb88aae2d2a462acc97b05ba911"}], "stats": {"total": 346, "additions": 321, "deletions": 25}, "files": [{"sha": "40e9c003313ce49cadbad923393e036f4940953f", "filename": ".mailmap", "status": "modified", "additions": 11, "deletions": 1, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/ab91c70cc69450bc69b76df0fd2faa82bda42d6b/.mailmap", "raw_url": "https://github.com/rust-lang/rust/raw/ab91c70cc69450bc69b76df0fd2faa82bda42d6b/.mailmap", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/.mailmap?ref=ab91c70cc69450bc69b76df0fd2faa82bda42d6b", "patch": "@@ -6,6 +6,7 @@\n #\n \n Aaron Todd <github@opprobrio.us>\n+Aaron Power <theaaronepower@gmail.com>\n Abhishek Chanda <abhishek.becs@gmail.com> Abhishek Chanda <abhishek@cloudscaling.com>\n Adolfo Ochagav\u00eda <aochagavia92@gmail.com>\n Adrien T\u00e9tar <adri-from-59@hotmail.fr>\n@@ -56,18 +57,20 @@ Corey Richardson <corey@octayn.net> Elaine \"See More\" Nemo <corey@octayn.net>\n Cyryl P\u0142otnicki <cyplo@cyplo.net>\n Damien Schoof <damien.schoof@gmail.com>\n Daniel Ramos <dan@daramos.com>\n+Daniel J Rollins <drollins@financialforce.com>\n David Klein <david.klein@baesystemsdetica.com>\n David Manescu <david.manescu@gmail.com> <dman2626@uni.sydney.edu.au>\n David Ross <daboross@daboross.net>\n Derek Chiang <derekchiang93@gmail.com> Derek Chiang (Enchi Jiang) <derekchiang93@gmail.com>\n Diggory Hardy <diggory.hardy@gmail.com> Diggory Hardy <github@dhardy.name>\n Dylan Braithwaite <dylanbraithwaite1@gmail.com> <mail@dylanb.me>\n Dzmitry Malyshau <kvarkus@gmail.com>\n+E. Dunham <edunham@mozilla.com> edunham <edunham@mozilla.com>\n Eduardo Bautista <me@eduardobautista.com> <=>\n Eduardo Bautista <me@eduardobautista.com> <mail@eduardobautista.com>\n+Eduard-Mihai Burtescu <edy.burt@gmail.com>\n Elliott Slaughter <elliottslaughter@gmail.com> <eslaughter@mozilla.com>\n Elly Fong-Jones <elly@leptoquark.net>\n-Emily Dunham <edunham@mozilla.com> edunham <edunham@mozilla.com>\n Eric Holk <eric.holk@gmail.com> <eholk@cs.indiana.edu>\n Eric Holk <eric.holk@gmail.com> <eholk@mozilla.com>\n Eric Holmes <eric@ejholmes.net>\n@@ -83,6 +86,8 @@ Gareth Daniel Smith <garethdanielsmith@gmail.com> Gareth Smith <garethdanielsmit\n Georges Dubus <georges.dubus@gmail.com> <georges.dubus@compiletoi.net>\n Graham Fawcett <graham.fawcett@gmail.com> Graham Fawcett <fawcett@uwindsor.ca>\n Graydon Hoare <graydon@pobox.com> Graydon Hoare <graydon@mozilla.com>\n+Guillaume Gomez <guillaume1.gomez@gmail.com>\n+Guillaume Gomez <guillaume1.gomez@gmail.com> ggomez <ggomez@ggo.ifr.lan>\n Guillaume Gomez <guillaume1.gomez@gmail.com> Guillaume Gomez <ggomez@ggo.ifr.lan>\n Heather <heather@cynede.net> <Cynede@Gentoo.org>\n Heather <heather@cynede.net> <Heather@cynede.net>\n@@ -114,6 +119,7 @@ John Ka\u030are Alsaker <john.kare.alsaker@gmail.com>\n John Talling <inrustwetrust@users.noreply.github.com>\n Jonathan Bailey <jbailey@mozilla.com> <jbailey@jbailey-20809.local>\n Jonathan S <gereeter@gmail.com> Jonathan S <gereeter+code@gmail.com>\n+Jonathan Turner <probata@hotmail.com>\n Jorge Aparicio <japaric@linux.com> <japaricious@gmail.com>\n Joseph Martin <pythoner6@gmail.com>\n Jo\u00e3o Oliveira <hello@jxs.pt> joaoxsouls <joaoxsouls@gmail.com>\n@@ -136,6 +142,7 @@ NAKASHIMA, Makoto <makoto.nksm+github@gmail.com> <makoto.nksm@gmail.com>\n NAKASHIMA, Makoto <makoto.nksm+github@gmail.com> <makoto.nksm+github@gmail.com>\n Marcell Pardavi <marcell.pardavi@gmail.com>\n Margaret Meyerhofer <mmeyerho@andrew.cmu.edu> <mmeyerho@andrew>\n+Mark Simulacrum <mark.simulacrum@gmail.com>\n Mark Sinclair <mark.edward.x@gmail.com>\n Mark Sinclair <mark.edward.x@gmail.com> =Mark Sinclair <=125axel125@gmail.com>\n Markus Westerlind <marwes91@gmail.com> Markus <marwes91@gmail.com>\n@@ -171,6 +178,7 @@ Peter Zotov <whitequark@whitequark.org>\n Phil Dawes <phil@phildawes.net> Phil Dawes <pdawes@drw.com>\n Philipp Br\u00fcschweiler <blei42@gmail.com> <blei42@gmail.com>\n Philipp Br\u00fcschweiler <blei42@gmail.com> <bruphili@student.ethz.ch>\n+Philipp Matthias Sch\u00e4fer <philipp.matthias.schaefer@posteo.de>\n Przemys\u0142aw Weso\u0142ek <jest@go.art.pl> Przemek Weso\u0142ek <jest@go.art.pl>\n Rafael \u00c1vila de Esp\u00edndola <respindola@mozilla.com> Rafael Avila de Espindola <espindola@dream.(none)>\n Ralph Giles <giles@thaumas.net> Ralph Giles <giles@mozilla.com>\n@@ -189,11 +197,13 @@ S Pradeep Kumar <gohanpra@gmail.com>\n Scott Olson <scott@solson.me> Scott Olson <scott@scott-olson.org>\n Sean Gillespie <sean.william.g@gmail.com> swgillespie <sean.william.g@gmail.com>\n Seonghyun Kim <sh8281.kim@samsung.com>\n+Shyam Sundar B <shyambaskaran@outlook.com>\n Simon Barber-Dueck <sbarberdueck@gmail.com> Simon BD <simon@server>\n Simon Sapin <simon@exyr.org> <simon.sapin@exyr.org>\n Simonas Kazlauskas <git@kazlauskas.me> Simonas Kazlauskas <github@kazlauskas.me>\n startling <tdixon51793@gmail.com>\n Stepan Koltsov <stepan.koltsov@gmail.com> Stepan Koltsov <nga@yandex-team.ru>\n+Steve Klabnik <steve@steveklabnik.com>\n Steven Fackler <sfackler@gmail.com> <sfackler@palantir.com>\n Steven Stewart-Gallus <sstewartgallus00@langara.bc.ca> <sstewartgallus00@mylangara.bc.ca>\n Stuart Pernsteiner <stuart@pernsteiner.org> Stuart Pernsteiner <spernsteiner@mozilla.com>"}, {"sha": "d351bea477722fd8f4f2ea9dc8b8da74aab4e9e5", "filename": ".travis.yml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ab91c70cc69450bc69b76df0fd2faa82bda42d6b/.travis.yml", "raw_url": "https://github.com/rust-lang/rust/raw/ab91c70cc69450bc69b76df0fd2faa82bda42d6b/.travis.yml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/.travis.yml?ref=ab91c70cc69450bc69b76df0fd2faa82bda42d6b", "patch": "@@ -122,7 +122,7 @@ matrix:\n     - env: IMAGE=dist-x86_64-linux DEPLOY_ALT=1\n     - env: >\n         RUST_CHECK_TARGET=dist\n-        RUST_CONFIGURE_ARGS=\"--enable-extended\"\n+        RUST_CONFIGURE_ARGS=\"--enable-extended --enable-profiler\"\n         SRC=.\n         DEPLOY_ALT=1\n         RUSTC_RETRY_LINKER_ON_SEGFAULT=1"}, {"sha": "6bec9330186861d086f8e7c66a986e330a157c80", "filename": "CODE_OF_CONDUCT.md", "status": "added", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/ab91c70cc69450bc69b76df0fd2faa82bda42d6b/CODE_OF_CONDUCT.md", "raw_url": "https://github.com/rust-lang/rust/raw/ab91c70cc69450bc69b76df0fd2faa82bda42d6b/CODE_OF_CONDUCT.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/CODE_OF_CONDUCT.md?ref=ab91c70cc69450bc69b76df0fd2faa82bda42d6b", "patch": "@@ -0,0 +1,38 @@\n+# The Rust Code of Conduct\n+\n+A version of this document [can be found online](https://www.rust-lang.org/conduct.html).\n+\n+## Conduct\n+\n+**Contact**: [rust-mods@rust-lang.org](mailto:rust-mods@rust-lang.org)\n+\n+* We are committed to providing a friendly, safe and welcoming environment for all, regardless of level of experience, gender, gender identity and expression, sexual orientation, disability, personal appearance, body size, race, ethnicity, age, religion, nationality, or other similar characteristic.\n+* On IRC, please avoid using overtly sexual nicknames or other nicknames that might detract from a friendly, safe and welcoming environment for all.\n+* Please be kind and courteous. There's no need to be mean or rude.\n+* Respect that people have differences of opinion and that every design or implementation choice carries a trade-off and numerous costs. There is seldom a right answer.\n+* Please keep unstructured critique to a minimum. If you have solid ideas you want to experiment with, make a fork and see how it works.\n+* We will exclude you from interaction if you insult, demean or harass anyone. That is not welcome behaviour. We interpret the term \"harassment\" as including the definition in the <a href=\"http://citizencodeofconduct.org/\">Citizen Code of Conduct</a>; if you have any lack of clarity about what might be included in that concept, please read their definition. In particular, we don't tolerate behavior that excludes people in socially marginalized groups.\n+* Private harassment is also unacceptable. No matter who you are, if you feel you have been or are being harassed or made uncomfortable by a community member, please contact one of the channel ops or any of the [Rust moderation team](/team.html#Moderation) immediately. Whether you're a regular contributor or a newcomer, we care about making this community a safe place for you and we've got your back.\n+* Likewise any spamming, trolling, flaming, baiting or other attention-stealing behaviour is not welcome.\n+\n+## Moderation\n+\n+\n+These are the policies for upholding our community's standards of conduct. If you feel that a thread needs moderation, please contact the [Rust moderation team](/team.html#Moderation).\n+\n+1. Remarks that violate the Rust standards of conduct, including hateful, hurtful, oppressive, or exclusionary remarks, are not allowed. (Cursing is allowed, but never targeting another user, and never in a hateful manner.)\n+2. Remarks that moderators find inappropriate, whether listed in the code of conduct or not, are also not allowed.\n+3. Moderators will first respond to such remarks with a warning.\n+4. If the warning is unheeded, the user will be \"kicked,\" i.e., kicked out of the communication channel to cool off.\n+5. If the user comes back and continues to make trouble, they will be banned, i.e., indefinitely excluded.\n+6. Moderators may choose at their discretion to un-ban the user if it was a first offense and they offer the offended party a genuine apology.\n+7. If a moderator bans someone and you think it was unjustified, please take it up with that moderator, or with a different moderator, **in private**. Complaints about bans in-channel are not allowed.\n+8. Moderators are held to a higher standard than other community members. If a moderator creates an inappropriate situation, they should expect less leeway than others.\n+\n+In the Rust community we strive to go the extra step to look out for each other. Don't just aim to be technically unimpeachable, try to be your best self. In particular, avoid flirting with offensive or sensitive issues, particularly if they're off-topic; this all too often leads to unnecessary fights, hurt feelings, and damaged trust; worse, it can drive people away from the community entirely.\n+\n+And if someone takes issue with something you said or did, resist the urge to be defensive. Just stop doing what it was they complained about and apologize. Even if you feel you were misinterpreted or unfairly accused, chances are good there was something you could've communicated better \u2014 remember that it's your responsibility to make your fellow Rustaceans comfortable. Everyone wants to get along and we are all here first and foremost because we want to talk about cool technology. You will find that people will be eager to assume good intent and forgive as long as you earn their trust.\n+\n+The enforcement policies listed above apply to all official Rust venues; including official IRC channels (#rust, #rust-internals, #rust-tools, #rust-libs, #rustc, #rust-beginners, #rust-docs, #rust-community, #rust-lang, and #cargo); GitHub repositories under rust-lang, rust-lang-nursery, and rust-lang-deprecated; and all forums under rust-lang.org (users.rust-lang.org, internals.rust-lang.org). For other projects adopting the Rust Code of Conduct, please contact the maintainers of those projects for enforcement. If you wish to use this code of conduct for your own project, consider explicitly mentioning your moderation policy or making a copy with your own moderation policy so as to avoid confusion.\n+\n+*Adapted from the [Node.js Policy on Trolling](http://blog.izs.me/post/30036893703/policy-on-trolling) as well as the [Contributor Covenant v1.3.0](http://contributor-covenant.org/version/1/3/0/).*"}, {"sha": "582ca5d0f9de3b545118aacf62188ec659f673c7", "filename": "appveyor.yml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ab91c70cc69450bc69b76df0fd2faa82bda42d6b/appveyor.yml", "raw_url": "https://github.com/rust-lang/rust/raw/ab91c70cc69450bc69b76df0fd2faa82bda42d6b/appveyor.yml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/appveyor.yml?ref=ab91c70cc69450bc69b76df0fd2faa82bda42d6b", "patch": "@@ -75,7 +75,7 @@ environment:\n \n   # \"alternate\" deployment, see .travis.yml for more info\n   - MSYS_BITS: 64\n-    RUST_CONFIGURE_ARGS: --build=x86_64-pc-windows-msvc --enable-extended\n+    RUST_CONFIGURE_ARGS: --build=x86_64-pc-windows-msvc --enable-extended --enable-profiler\n     SCRIPT: python x.py dist\n     DEPLOY_ALT: 1\n "}, {"sha": "3f466d5031e7b6f4bd0d71838c0a11350dd517ec", "filename": "src/libstd/path.rs", "status": "modified", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/ab91c70cc69450bc69b76df0fd2faa82bda42d6b/src%2Flibstd%2Fpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab91c70cc69450bc69b76df0fd2faa82bda42d6b/src%2Flibstd%2Fpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpath.rs?ref=ab91c70cc69450bc69b76df0fd2faa82bda42d6b", "patch": "@@ -2216,12 +2216,22 @@ impl Path {\n     /// This function will traverse symbolic links to query information about the\n     /// destination file. In case of broken symbolic links this will return `false`.\n     ///\n+    /// If you cannot access the directory containing the file, e.g. because of a\n+    /// permission error, this will return `false`.\n+    ///\n     /// # Examples\n     ///\n     /// ```no_run\n     /// use std::path::Path;\n     /// assert_eq!(Path::new(\"does_not_exist.txt\").exists(), false);\n     /// ```\n+    ///\n+    /// # See Also\n+    ///\n+    /// This is a convenience function that coerces errors to false. If you want to\n+    /// check errors, call [fs::metadata].\n+    ///\n+    /// [fs::metadata]: ../../std/fs/fn.metadata.html\n     #[stable(feature = \"path_ext\", since = \"1.5.0\")]\n     pub fn exists(&self) -> bool {\n         fs::metadata(self).is_ok()\n@@ -2232,13 +2242,25 @@ impl Path {\n     /// This function will traverse symbolic links to query information about the\n     /// destination file. In case of broken symbolic links this will return `false`.\n     ///\n+    /// If you cannot access the directory containing the file, e.g. because of a\n+    /// permission error, this will return `false`.\n+    ///\n     /// # Examples\n     ///\n     /// ```no_run\n     /// use std::path::Path;\n     /// assert_eq!(Path::new(\"./is_a_directory/\").is_file(), false);\n     /// assert_eq!(Path::new(\"a_file.txt\").is_file(), true);\n     /// ```\n+    ///\n+    /// # See Also\n+    ///\n+    /// This is a convenience function that coerces errors to false. If you want to\n+    /// check errors, call [fs::metadata] and handle its Result. Then call\n+    /// [fs::Metadata::is_file] if it was Ok.\n+    ///\n+    /// [fs::metadata]: ../../std/fs/fn.metadata.html\n+    /// [fs::Metadata::is_file]: ../../std/fs/struct.Metadata.html#method.is_file\n     #[stable(feature = \"path_ext\", since = \"1.5.0\")]\n     pub fn is_file(&self) -> bool {\n         fs::metadata(self).map(|m| m.is_file()).unwrap_or(false)\n@@ -2249,13 +2271,25 @@ impl Path {\n     /// This function will traverse symbolic links to query information about the\n     /// destination file. In case of broken symbolic links this will return `false`.\n     ///\n+    /// If you cannot access the directory containing the file, e.g. because of a\n+    /// permission error, this will return `false`.\n+    ///\n     /// # Examples\n     ///\n     /// ```no_run\n     /// use std::path::Path;\n     /// assert_eq!(Path::new(\"./is_a_directory/\").is_dir(), true);\n     /// assert_eq!(Path::new(\"a_file.txt\").is_dir(), false);\n     /// ```\n+    ///\n+    /// # See Also\n+    ///\n+    /// This is a convenience function that coerces errors to false. If you want to\n+    /// check errors, call [fs::metadata] and handle its Result. Then call\n+    /// [fs::Metadata::is_dir] if it was Ok.\n+    ///\n+    /// [fs::metadata]: ../../std/fs/fn.metadata.html\n+    /// [fs::Metadata::is_dir]: ../../std/fs/struct.Metadata.html#method.is_dir\n     #[stable(feature = \"path_ext\", since = \"1.5.0\")]\n     pub fn is_dir(&self) -> bool {\n         fs::metadata(self).map(|m| m.is_dir()).unwrap_or(false)"}, {"sha": "918893097f8411d02f81854509df4e7fab00801d", "filename": "src/libstd/sys/redox/fs.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/ab91c70cc69450bc69b76df0fd2faa82bda42d6b/src%2Flibstd%2Fsys%2Fredox%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab91c70cc69450bc69b76df0fd2faa82bda42d6b/src%2Flibstd%2Fsys%2Fredox%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fredox%2Ffs.rs?ref=ab91c70cc69450bc69b76df0fd2faa82bda42d6b", "patch": "@@ -383,9 +383,10 @@ pub fn unlink(p: &Path) -> io::Result<()> {\n     Ok(())\n }\n \n-pub fn rename(_old: &Path, _new: &Path) -> io::Result<()> {\n-    ::sys_common::util::dumb_print(format_args!(\"Rename\\n\"));\n-    unimplemented!();\n+pub fn rename(old: &Path, new: &Path) -> io::Result<()> {\n+    copy(old, new)?;\n+    unlink(old)?;\n+    Ok(())\n }\n \n pub fn set_perm(p: &Path, perm: FilePermissions) -> io::Result<()> {"}, {"sha": "7c728ebb1af2e097f8d7889b9cf89f80a8d7ba10", "filename": "src/libstd/sys/redox/mod.rs", "status": "modified", "additions": 1, "deletions": 19, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/ab91c70cc69450bc69b76df0fd2faa82bda42d6b/src%2Flibstd%2Fsys%2Fredox%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab91c70cc69450bc69b76df0fd2faa82bda42d6b/src%2Flibstd%2Fsys%2Fredox%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fredox%2Fmod.rs?ref=ab91c70cc69450bc69b76df0fd2faa82bda42d6b", "patch": "@@ -39,25 +39,7 @@ pub mod thread_local;\n pub mod time;\n \n #[cfg(not(test))]\n-pub fn init() {\n-    use alloc::oom;\n-\n-    oom::set_oom_handler(oom_handler);\n-\n-    // A nicer handler for out-of-memory situations than the default one. This\n-    // one prints a message to stderr before aborting. It is critical that this\n-    // code does not allocate any memory since we are in an OOM situation. Any\n-    // errors are ignored while printing since there's nothing we can do about\n-    // them and we are about to exit anyways.\n-    fn oom_handler() -> ! {\n-        use intrinsics;\n-        let msg = \"fatal runtime error: out of memory\\n\";\n-        unsafe {\n-            let _ = syscall::write(2, msg.as_bytes());\n-            intrinsics::abort();\n-        }\n-    }\n-}\n+pub fn init() {}\n \n pub fn decode_error_kind(errno: i32) -> ErrorKind {\n     match errno {"}, {"sha": "42f989538c89066a2ee37d4feeb6197a8e93fb12", "filename": "src/test/run-pass/rfc1857-drop-order.rs", "status": "added", "additions": 231, "deletions": 0, "changes": 231, "blob_url": "https://github.com/rust-lang/rust/blob/ab91c70cc69450bc69b76df0fd2faa82bda42d6b/src%2Ftest%2Frun-pass%2Frfc1857-drop-order.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab91c70cc69450bc69b76df0fd2faa82bda42d6b/src%2Ftest%2Frun-pass%2Frfc1857-drop-order.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Frfc1857-drop-order.rs?ref=ab91c70cc69450bc69b76df0fd2faa82bda42d6b", "patch": "@@ -0,0 +1,231 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![allow(dead_code, unreachable_code)]\n+\n+use std::cell::RefCell;\n+use std::rc::Rc;\n+use std::panic::{self, AssertUnwindSafe, UnwindSafe};\n+\n+// This struct is used to record the order in which elements are dropped\n+struct PushOnDrop {\n+    vec: Rc<RefCell<Vec<u32>>>,\n+    val: u32\n+}\n+\n+impl PushOnDrop {\n+    fn new(val: u32, vec: Rc<RefCell<Vec<u32>>>) -> PushOnDrop {\n+        PushOnDrop { vec, val }\n+    }\n+}\n+\n+impl Drop for PushOnDrop {\n+    fn drop(&mut self) {\n+        self.vec.borrow_mut().push(self.val)\n+    }\n+}\n+\n+impl UnwindSafe for PushOnDrop { }\n+\n+// Structs\n+struct TestStruct {\n+    x: PushOnDrop,\n+    y: PushOnDrop,\n+    z: PushOnDrop\n+}\n+\n+// Tuple structs\n+struct TestTupleStruct(PushOnDrop, PushOnDrop, PushOnDrop);\n+\n+// Enum variants\n+enum TestEnum {\n+    Tuple(PushOnDrop, PushOnDrop, PushOnDrop),\n+    Struct { x: PushOnDrop, y: PushOnDrop, z: PushOnDrop }\n+}\n+\n+fn test_drop_tuple() {\n+    // Tuple fields are dropped in the same order they are declared\n+    let dropped_fields = Rc::new(RefCell::new(Vec::new()));\n+    let test_tuple = (PushOnDrop::new(1, dropped_fields.clone()),\n+                      PushOnDrop::new(2, dropped_fields.clone()));\n+    drop(test_tuple);\n+    assert_eq!(*dropped_fields.borrow(), &[1, 2]);\n+\n+    // Panic during construction means that fields are treated as local variables\n+    // Therefore they are dropped in reverse order of initialization\n+    let dropped_fields = Rc::new(RefCell::new(Vec::new()));\n+    let cloned = AssertUnwindSafe(dropped_fields.clone());\n+    panic::catch_unwind(|| {\n+        (PushOnDrop::new(2, cloned.clone()),\n+         PushOnDrop::new(1, cloned.clone()),\n+         panic!(\"this panic is catched :D\"));\n+    }).err().unwrap();\n+    assert_eq!(*dropped_fields.borrow(), &[1, 2]);\n+}\n+\n+fn test_drop_struct() {\n+    // Struct fields are dropped in the same order they are declared\n+    let dropped_fields = Rc::new(RefCell::new(Vec::new()));\n+    let test_struct = TestStruct {\n+        x: PushOnDrop::new(1, dropped_fields.clone()),\n+        y: PushOnDrop::new(2, dropped_fields.clone()),\n+        z: PushOnDrop::new(3, dropped_fields.clone()),\n+    };\n+    drop(test_struct);\n+    assert_eq!(*dropped_fields.borrow(), &[1, 2, 3]);\n+\n+    // The same holds for tuple structs\n+    let dropped_fields = Rc::new(RefCell::new(Vec::new()));\n+    let test_tuple_struct = TestTupleStruct(PushOnDrop::new(1, dropped_fields.clone()),\n+                                            PushOnDrop::new(2, dropped_fields.clone()),\n+                                            PushOnDrop::new(3, dropped_fields.clone()));\n+    drop(test_tuple_struct);\n+    assert_eq!(*dropped_fields.borrow(), &[1, 2, 3]);\n+\n+    // Panic during struct construction means that fields are treated as local variables\n+    // Therefore they are dropped in reverse order of initialization\n+    let dropped_fields = Rc::new(RefCell::new(Vec::new()));\n+    let cloned = AssertUnwindSafe(dropped_fields.clone());\n+    panic::catch_unwind(|| {\n+        TestStruct {\n+            x: PushOnDrop::new(2, cloned.clone()),\n+            y: PushOnDrop::new(1, cloned.clone()),\n+            z: panic!(\"this panic is catched :D\")\n+        };\n+    }).err().unwrap();\n+    assert_eq!(*dropped_fields.borrow(), &[1, 2]);\n+\n+    // Test with different initialization order\n+    let dropped_fields = Rc::new(RefCell::new(Vec::new()));\n+    let cloned = AssertUnwindSafe(dropped_fields.clone());\n+    panic::catch_unwind(|| {\n+        TestStruct {\n+            y: PushOnDrop::new(2, cloned.clone()),\n+            x: PushOnDrop::new(1, cloned.clone()),\n+            z: panic!(\"this panic is catched :D\")\n+        };\n+    }).err().unwrap();\n+    assert_eq!(*dropped_fields.borrow(), &[1, 2]);\n+\n+    // The same holds for tuple structs\n+    let dropped_fields = Rc::new(RefCell::new(Vec::new()));\n+    let cloned = AssertUnwindSafe(dropped_fields.clone());\n+    panic::catch_unwind(|| {\n+        TestTupleStruct(PushOnDrop::new(2, cloned.clone()),\n+                        PushOnDrop::new(1, cloned.clone()),\n+                        panic!(\"this panic is catched :D\"));\n+    }).err().unwrap();\n+    assert_eq!(*dropped_fields.borrow(), &[1, 2]);\n+}\n+\n+fn test_drop_enum() {\n+    // Enum variants are dropped in the same order they are declared\n+    let dropped_fields = Rc::new(RefCell::new(Vec::new()));\n+    let test_struct_enum = TestEnum::Struct {\n+        x: PushOnDrop::new(1, dropped_fields.clone()),\n+        y: PushOnDrop::new(2, dropped_fields.clone()),\n+        z: PushOnDrop::new(3, dropped_fields.clone())\n+    };\n+    drop(test_struct_enum);\n+    assert_eq!(*dropped_fields.borrow(), &[1, 2, 3]);\n+\n+    // The same holds for tuple enum variants\n+    let dropped_fields = Rc::new(RefCell::new(Vec::new()));\n+    let test_tuple_enum = TestEnum::Tuple(PushOnDrop::new(1, dropped_fields.clone()),\n+                                          PushOnDrop::new(2, dropped_fields.clone()),\n+                                          PushOnDrop::new(3, dropped_fields.clone()));\n+    drop(test_tuple_enum);\n+    assert_eq!(*dropped_fields.borrow(), &[1, 2, 3]);\n+\n+    // Panic during enum construction means that fields are treated as local variables\n+    // Therefore they are dropped in reverse order of initialization\n+    let dropped_fields = Rc::new(RefCell::new(Vec::new()));\n+    let cloned = AssertUnwindSafe(dropped_fields.clone());\n+    panic::catch_unwind(|| {\n+        TestEnum::Struct {\n+            x: PushOnDrop::new(2, cloned.clone()),\n+            y: PushOnDrop::new(1, cloned.clone()),\n+            z: panic!(\"this panic is catched :D\")\n+        };\n+    }).err().unwrap();\n+    assert_eq!(*dropped_fields.borrow(), &[1, 2]);\n+\n+    // Test with different initialization order\n+    let dropped_fields = Rc::new(RefCell::new(Vec::new()));\n+    let cloned = AssertUnwindSafe(dropped_fields.clone());\n+    panic::catch_unwind(|| {\n+        TestEnum::Struct {\n+            y: PushOnDrop::new(2, cloned.clone()),\n+            x: PushOnDrop::new(1, cloned.clone()),\n+            z: panic!(\"this panic is catched :D\")\n+        };\n+    }).err().unwrap();\n+    assert_eq!(*dropped_fields.borrow(), &[1, 2]);\n+\n+    // The same holds for tuple enum variants\n+    let dropped_fields = Rc::new(RefCell::new(Vec::new()));\n+    let cloned = AssertUnwindSafe(dropped_fields.clone());\n+    panic::catch_unwind(|| {\n+        TestEnum::Tuple(PushOnDrop::new(2, cloned.clone()),\n+                        PushOnDrop::new(1, cloned.clone()),\n+                        panic!(\"this panic is catched :D\"));\n+    }).err().unwrap();\n+    assert_eq!(*dropped_fields.borrow(), &[1, 2]);\n+}\n+\n+fn test_drop_list() {\n+    // Elements in a Vec are dropped in the same order they are pushed\n+    let dropped_fields = Rc::new(RefCell::new(Vec::new()));\n+    let xs = vec![PushOnDrop::new(1, dropped_fields.clone()),\n+                  PushOnDrop::new(2, dropped_fields.clone()),\n+                  PushOnDrop::new(3, dropped_fields.clone())];\n+    drop(xs);\n+    assert_eq!(*dropped_fields.borrow(), &[1, 2, 3]);\n+\n+    // The same holds for arrays\n+    let dropped_fields = Rc::new(RefCell::new(Vec::new()));\n+    let xs = [PushOnDrop::new(1, dropped_fields.clone()),\n+              PushOnDrop::new(2, dropped_fields.clone()),\n+              PushOnDrop::new(3, dropped_fields.clone())];\n+    drop(xs);\n+    assert_eq!(*dropped_fields.borrow(), &[1, 2, 3]);\n+\n+    // Panic during vec construction means that fields are treated as local variables\n+    // Therefore they are dropped in reverse order of initialization\n+    let dropped_fields = Rc::new(RefCell::new(Vec::new()));\n+    let cloned = AssertUnwindSafe(dropped_fields.clone());\n+    panic::catch_unwind(|| {\n+        vec![\n+            PushOnDrop::new(2, cloned.clone()),\n+            PushOnDrop::new(1, cloned.clone()),\n+            panic!(\"this panic is catched :D\")\n+        ];\n+    }).err().unwrap();\n+    assert_eq!(*dropped_fields.borrow(), &[1, 2]);\n+\n+    // The same holds for arrays\n+    let dropped_fields = Rc::new(RefCell::new(Vec::new()));\n+    let cloned = AssertUnwindSafe(dropped_fields.clone());\n+    panic::catch_unwind(|| {\n+        [\n+            PushOnDrop::new(2, cloned.clone()),\n+            PushOnDrop::new(1, cloned.clone()),\n+            panic!(\"this panic is catched :D\")\n+        ];\n+    }).err().unwrap();\n+    assert_eq!(*dropped_fields.borrow(), &[1, 2]);\n+}\n+\n+fn main() {\n+    test_drop_tuple();\n+    test_drop_struct();\n+    test_drop_enum();\n+    test_drop_list();\n+}"}]}