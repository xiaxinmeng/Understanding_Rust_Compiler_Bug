{"sha": "b04391c56555e518092fef78263d30d2dd3ac755", "node_id": "MDY6Q29tbWl0NzI0NzEyOmIwNDM5MWM1NjU1NWU1MTgwOTJmZWY3ODI2M2QzMGQyZGQzYWM3NTU=", "commit": {"author": {"name": "bjorn3", "email": "bjorn3@users.noreply.github.com", "date": "2018-06-11T16:49:17Z"}, "committer": {"name": "bjorn3", "email": "bjorn3@users.noreply.github.com", "date": "2018-06-11T16:51:40Z"}, "message": "Split create_ecx out of eval_main", "tree": {"sha": "c01cb2a7dfd737d60d7a07f2fc9189b5734b3c21", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c01cb2a7dfd737d60d7a07f2fc9189b5734b3c21"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b04391c56555e518092fef78263d30d2dd3ac755", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b04391c56555e518092fef78263d30d2dd3ac755", "html_url": "https://github.com/rust-lang/rust/commit/b04391c56555e518092fef78263d30d2dd3ac755", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b04391c56555e518092fef78263d30d2dd3ac755/comments", "author": {"login": "bjorn3", "id": 17426603, "node_id": "MDQ6VXNlcjE3NDI2NjAz", "avatar_url": "https://avatars.githubusercontent.com/u/17426603?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bjorn3", "html_url": "https://github.com/bjorn3", "followers_url": "https://api.github.com/users/bjorn3/followers", "following_url": "https://api.github.com/users/bjorn3/following{/other_user}", "gists_url": "https://api.github.com/users/bjorn3/gists{/gist_id}", "starred_url": "https://api.github.com/users/bjorn3/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bjorn3/subscriptions", "organizations_url": "https://api.github.com/users/bjorn3/orgs", "repos_url": "https://api.github.com/users/bjorn3/repos", "events_url": "https://api.github.com/users/bjorn3/events{/privacy}", "received_events_url": "https://api.github.com/users/bjorn3/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bjorn3", "id": 17426603, "node_id": "MDQ6VXNlcjE3NDI2NjAz", "avatar_url": "https://avatars.githubusercontent.com/u/17426603?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bjorn3", "html_url": "https://github.com/bjorn3", "followers_url": "https://api.github.com/users/bjorn3/followers", "following_url": "https://api.github.com/users/bjorn3/following{/other_user}", "gists_url": "https://api.github.com/users/bjorn3/gists{/gist_id}", "starred_url": "https://api.github.com/users/bjorn3/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bjorn3/subscriptions", "organizations_url": "https://api.github.com/users/bjorn3/orgs", "repos_url": "https://api.github.com/users/bjorn3/repos", "events_url": "https://api.github.com/users/bjorn3/events{/privacy}", "received_events_url": "https://api.github.com/users/bjorn3/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0f7513a4eecbbfd4babc69513d94abb568342bf0", "url": "https://api.github.com/repos/rust-lang/rust/commits/0f7513a4eecbbfd4babc69513d94abb568342bf0", "html_url": "https://github.com/rust-lang/rust/commit/0f7513a4eecbbfd4babc69513d94abb568342bf0"}], "stats": {"total": 197, "additions": 102, "deletions": 95}, "files": [{"sha": "cfe79f7602d7f0f160754adeb5e8b59bcad7bc1a", "filename": "src/lib.rs", "status": "modified", "additions": 102, "deletions": 95, "changes": 197, "blob_url": "https://github.com/rust-lang/rust/blob/b04391c56555e518092fef78263d30d2dd3ac755/src%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b04391c56555e518092fef78263d30d2dd3ac755/src%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib.rs?ref=b04391c56555e518092fef78263d30d2dd3ac755", "patch": "@@ -132,107 +132,116 @@ impl ScalarExt for Scalar {\n     }\n }\n \n-pub fn eval_main<'a, 'tcx: 'a>(\n+fn create_ecx<'a, 'mir: 'a, 'tcx: 'mir>(\n     tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     main_id: DefId,\n     start_wrapper: Option<DefId>,\n-) {\n-    fn run_main<'a, 'mir: 'a, 'tcx: 'mir>(\n-        ecx: &mut rustc_mir::interpret::EvalContext<'a, 'mir, 'tcx, Evaluator<'tcx>>,\n-        main_id: DefId,\n-        start_wrapper: Option<DefId>,\n-    ) -> EvalResult<'tcx> {\n-        let main_instance = ty::Instance::mono(ecx.tcx.tcx, main_id);\n-        let main_mir = ecx.load_mir(main_instance.def)?;\n-        let mut cleanup_ptr = None; // Scalar to be deallocated when we are done\n-\n-        if !main_mir.return_ty().is_nil() || main_mir.arg_count != 0 {\n-            return err!(Unimplemented(\n-                \"miri does not support main functions without `fn()` type signatures\"\n-                    .to_owned(),\n-            ));\n+) -> EvalResult<'tcx, (EvalContext<'a, 'mir, 'tcx, Evaluator<'tcx>>, Option<Pointer>)> {\n+    let mut ecx = EvalContext::new(tcx.at(syntax::codemap::DUMMY_SP), ty::ParamEnv::reveal_all(), Default::default(), Default::default());\n+\n+    let main_instance = ty::Instance::mono(ecx.tcx.tcx, main_id);\n+    let main_mir = ecx.load_mir(main_instance.def)?;\n+    let mut cleanup_ptr = None; // Scalar to be deallocated when we are done\n+\n+    if !main_mir.return_ty().is_nil() || main_mir.arg_count != 0 {\n+        return err!(Unimplemented(\n+            \"miri does not support main functions without `fn()` type signatures\"\n+                .to_owned(),\n+        ));\n+    }\n+\n+    if let Some(start_id) = start_wrapper {\n+        let main_ret_ty = ecx.tcx.fn_sig(main_id).output();\n+        let main_ret_ty = main_ret_ty.no_late_bound_regions().unwrap();\n+        let start_instance = ty::Instance::resolve(\n+            ecx.tcx.tcx,\n+            ty::ParamEnv::reveal_all(),\n+            start_id,\n+            ecx.tcx.mk_substs(\n+                ::std::iter::once(ty::subst::Kind::from(main_ret_ty)))\n+            ).unwrap();\n+        let start_mir = ecx.load_mir(start_instance.def)?;\n+\n+        if start_mir.arg_count != 3 {\n+            return err!(AbiViolation(format!(\n+                \"'start' lang item should have three arguments, but has {}\",\n+                start_mir.arg_count\n+            )));\n         }\n \n-        if let Some(start_id) = start_wrapper {\n-            let main_ret_ty = ecx.tcx.fn_sig(main_id).output();\n-            let main_ret_ty = main_ret_ty.no_late_bound_regions().unwrap();\n-            let start_instance = ty::Instance::resolve(\n-                ecx.tcx.tcx,\n-                ty::ParamEnv::reveal_all(),\n-                start_id,\n-                ecx.tcx.mk_substs(\n-                    ::std::iter::once(ty::subst::Kind::from(main_ret_ty)))).unwrap();\n-            let start_mir = ecx.load_mir(start_instance.def)?;\n-\n-            if start_mir.arg_count != 3 {\n-                return err!(AbiViolation(format!(\n-                    \"'start' lang item should have three arguments, but has {}\",\n-                    start_mir.arg_count\n-                )));\n-            }\n+        // Return value\n+        let size = ecx.tcx.data_layout.pointer_size;\n+        let align = ecx.tcx.data_layout.pointer_align;\n+        let ret_ptr = ecx.memory_mut().allocate(size, align, Some(MemoryKind::Stack))?;\n+        cleanup_ptr = Some(ret_ptr);\n \n-            // Return value\n-            let size = ecx.tcx.data_layout.pointer_size;\n-            let align = ecx.tcx.data_layout.pointer_align;\n-            let ret_ptr = ecx.memory_mut().allocate(size, align, Some(MemoryKind::Stack))?;\n-            cleanup_ptr = Some(ret_ptr);\n-\n-            // Push our stack frame\n-            ecx.push_stack_frame(\n-                start_instance,\n-                start_mir.span,\n-                start_mir,\n-                Place::from_ptr(ret_ptr, align),\n-                StackPopCleanup::None,\n-            )?;\n+        // Push our stack frame\n+        ecx.push_stack_frame(\n+            start_instance,\n+            start_mir.span,\n+            start_mir,\n+            Place::from_ptr(ret_ptr, align),\n+            StackPopCleanup::None,\n+        )?;\n \n-            let mut args = ecx.frame().mir.args_iter();\n-\n-            // First argument: pointer to main()\n-            let main_ptr = ecx.memory_mut().create_fn_alloc(main_instance);\n-            let dest = ecx.eval_place(&mir::Place::Local(args.next().unwrap()))?;\n-            let main_ty = main_instance.ty(ecx.tcx.tcx);\n-            let main_ptr_ty = ecx.tcx.mk_fn_ptr(main_ty.fn_sig(ecx.tcx.tcx));\n-            ecx.write_value(\n-                ValTy {\n-                    value: Value::Scalar(Scalar::Ptr(main_ptr)),\n-                    ty: main_ptr_ty,\n-                },\n-                dest,\n-            )?;\n+        let mut args = ecx.frame().mir.args_iter();\n \n-            // Second argument (argc): 1\n-            let dest = ecx.eval_place(&mir::Place::Local(args.next().unwrap()))?;\n-            let ty = ecx.tcx.types.isize;\n-            ecx.write_scalar(dest, Scalar::from_u128(1), ty)?;\n-\n-            // FIXME: extract main source file path\n-            // Third argument (argv): &[b\"foo\"]\n-            let dest = ecx.eval_place(&mir::Place::Local(args.next().unwrap()))?;\n-            let ty = ecx.tcx.mk_imm_ptr(ecx.tcx.mk_imm_ptr(ecx.tcx.types.u8));\n-            let foo = ecx.memory.allocate_bytes(b\"foo\\0\");\n-            let ptr_size = ecx.memory.pointer_size();\n-            let ptr_align = ecx.tcx.data_layout.pointer_align;\n-            let foo_ptr = ecx.memory.allocate(ptr_size, ptr_align, None)?;\n-            ecx.memory.write_scalar(foo_ptr.into(), ptr_align, Scalar::Ptr(foo), ptr_size, false)?;\n-            ecx.memory.mark_static_initialized(foo_ptr.alloc_id, Mutability::Immutable)?;\n-            ecx.write_ptr(dest, foo_ptr.into(), ty)?;\n-\n-            assert!(args.next().is_none(), \"start lang item has more arguments than expected\");\n-        } else {\n-            ecx.push_stack_frame(\n-                main_instance,\n-                main_mir.span,\n-                main_mir,\n-                Place::from_scalar_ptr(Scalar::from_u128(1), ty::layout::Align::from_bytes(1, 1).unwrap()),\n-                StackPopCleanup::None,\n-            )?;\n+        // First argument: pointer to main()\n+        let main_ptr = ecx.memory_mut().create_fn_alloc(main_instance);\n+        let dest = ecx.eval_place(&mir::Place::Local(args.next().unwrap()))?;\n+        let main_ty = main_instance.ty(ecx.tcx.tcx);\n+        let main_ptr_ty = ecx.tcx.mk_fn_ptr(main_ty.fn_sig(ecx.tcx.tcx));\n+        ecx.write_value(\n+            ValTy {\n+                value: Value::Scalar(Scalar::Ptr(main_ptr)),\n+                ty: main_ptr_ty,\n+            },\n+            dest,\n+        )?;\n \n-            // No arguments\n-            let mut args = ecx.frame().mir.args_iter();\n-            assert!(args.next().is_none(), \"main function must not have arguments\");\n-        }\n+        // Second argument (argc): 1\n+        let dest = ecx.eval_place(&mir::Place::Local(args.next().unwrap()))?;\n+        let ty = ecx.tcx.types.isize;\n+        ecx.write_scalar(dest, Scalar::from_u128(1), ty)?;\n \n+        // FIXME: extract main source file path\n+        // Third argument (argv): &[b\"foo\"]\n+        let dest = ecx.eval_place(&mir::Place::Local(args.next().unwrap()))?;\n+        let ty = ecx.tcx.mk_imm_ptr(ecx.tcx.mk_imm_ptr(ecx.tcx.types.u8));\n+        let foo = ecx.memory.allocate_bytes(b\"foo\\0\");\n+        let ptr_size = ecx.memory.pointer_size();\n+        let ptr_align = ecx.tcx.data_layout.pointer_align;\n+        let foo_ptr = ecx.memory.allocate(ptr_size, ptr_align, None)?;\n+        ecx.memory.write_scalar(foo_ptr.into(), ptr_align, Scalar::Ptr(foo), ptr_size, false)?;\n+        ecx.memory.mark_static_initialized(foo_ptr.alloc_id, Mutability::Immutable)?;\n+        ecx.write_ptr(dest, foo_ptr.into(), ty)?;\n+\n+        assert!(args.next().is_none(), \"start lang item has more arguments than expected\");\n+    } else {\n+        ecx.push_stack_frame(\n+            main_instance,\n+            main_mir.span,\n+            main_mir,\n+            Place::from_scalar_ptr(Scalar::from_u128(1), ty::layout::Align::from_bytes(1, 1).unwrap()),\n+            StackPopCleanup::None,\n+        )?;\n+\n+        // No arguments\n+        let mut args = ecx.frame().mir.args_iter();\n+        assert!(args.next().is_none(), \"main function must not have arguments\");\n+    }\n+\n+    Ok((ecx, cleanup_ptr))\n+}\n+\n+pub fn eval_main<'a, 'tcx: 'a>(\n+    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+    main_id: DefId,\n+    start_wrapper: Option<DefId>,\n+) {\n+    let (mut ecx, cleanup_ptr) = create_ecx(tcx, main_id, start_wrapper).expect(\"Couldn't create ecx\");\n+\n+    let res: EvalResult = do catch {\n         while ecx.step()? {}\n         ecx.run_tls_dtors()?;\n         if let Some(cleanup_ptr) = cleanup_ptr {\n@@ -242,11 +251,9 @@ pub fn eval_main<'a, 'tcx: 'a>(\n                 MemoryKind::Stack,\n             )?;\n         }\n-        Ok(())\n-    }\n+    };\n \n-    let mut ecx = EvalContext::new(tcx.at(syntax::codemap::DUMMY_SP), ty::ParamEnv::reveal_all(), Default::default(), Default::default());\n-    match run_main(&mut ecx, main_id, start_wrapper) {\n+    match res {\n         Ok(()) => {\n             let leaks = ecx.memory().leak_report();\n             if leaks != 0 {"}]}