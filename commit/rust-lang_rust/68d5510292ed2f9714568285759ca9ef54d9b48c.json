{"sha": "68d5510292ed2f9714568285759ca9ef54d9b48c", "node_id": "MDY6Q29tbWl0NzI0NzEyOjY4ZDU1MTAyOTJlZDJmOTcxNDU2ODI4NTc1OWNhOWVmNTRkOWI0OGM=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2013-11-13T22:48:45Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2013-11-19T17:59:21Z"}, "message": "Implement more native file I/O\n\nThis implements a fair amount of the unimpl() functionality in io::native\nrelating to filesystem operations. I've also modified all io::fs tests to run in\nboth a native and uv environment (so everything is actually tested).\n\nThere are a two bits of remaining functionality which I was unable to get\nworking:\n\n* change_file_times on windows\n* lstat on windows\n\nI think that change_file_times may just need a better interface, but lstat has a\nlarge implementation in libuv which I didn't want to tackle trying to copy.", "tree": {"sha": "6a0c7a0274a4942849982400cfb9277c2103fccf", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6a0c7a0274a4942849982400cfb9277c2103fccf"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/68d5510292ed2f9714568285759ca9ef54d9b48c", "comment_count": 5, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/68d5510292ed2f9714568285759ca9ef54d9b48c", "html_url": "https://github.com/rust-lang/rust/commit/68d5510292ed2f9714568285759ca9ef54d9b48c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/68d5510292ed2f9714568285759ca9ef54d9b48c/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f5f5d5aac762a554850d291165536ba752260303", "url": "https://api.github.com/repos/rust-lang/rust/commits/f5f5d5aac762a554850d291165536ba752260303", "html_url": "https://github.com/rust-lang/rust/commit/f5f5d5aac762a554850d291165536ba752260303"}], "stats": {"total": 1772, "additions": 1056, "deletions": 716}, "files": [{"sha": "d74acb5f59baa0a705d0bd01cb5a5df74be19e03", "filename": "src/libstd/io/buffered.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/68d5510292ed2f9714568285759ca9ef54d9b48c/src%2Flibstd%2Fio%2Fbuffered.rs", "raw_url": "https://github.com/rust-lang/rust/raw/68d5510292ed2f9714568285759ca9ef54d9b48c/src%2Flibstd%2Fio%2Fbuffered.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fbuffered.rs?ref=68d5510292ed2f9714568285759ca9ef54d9b48c", "patch": "@@ -391,7 +391,6 @@ mod test {\n     // newtype struct autoderef weirdness\n     #[test]\n     fn test_buffered_stream() {\n-        use rt;\n         struct S;\n \n         impl io::Writer for S {"}, {"sha": "cc3f8bacb24dccf403307c7787ee4e0faa71e386", "filename": "src/libstd/io/fs.rs", "status": "modified", "additions": 160, "deletions": 157, "changes": 317, "blob_url": "https://github.com/rust-lang/rust/blob/68d5510292ed2f9714568285759ca9ef54d9b48c/src%2Flibstd%2Fio%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/68d5510292ed2f9714568285759ca9ef54d9b48c/src%2Flibstd%2Fio%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Ffs.rs?ref=68d5510292ed2f9714568285759ca9ef54d9b48c", "patch": "@@ -191,7 +191,7 @@ impl File {\n     ///\n     /// This function will raise on the `io_error` condition on failure.\n     pub fn fsync(&mut self) {\n-        self.fd.fsync();\n+        self.fd.fsync().map_err(|e| io_error::cond.raise(e));\n     }\n \n     /// This function is similar to `fsync`, except that it may not synchronize\n@@ -203,23 +203,23 @@ impl File {\n     ///\n     /// This function will raise on the `io_error` condition on failure.\n     pub fn datasync(&mut self) {\n-        self.fd.datasync();\n+        self.fd.datasync().map_err(|e| io_error::cond.raise(e));\n     }\n \n-    /// Either truncates or extends the underlying file, as extended from the\n-    /// file's current position. This is equivalent to the unix `truncate`\n+    /// Either truncates or extends the underlying file, updating the size of\n+    /// this file to become `size`. This is equivalent to unix's `truncate`\n     /// function.\n     ///\n-    /// The offset given is added to the file's current position and the result\n-    /// is the new size of the file. If the new size is less than the current\n-    /// size, then the file is truncated. If the new size is greater than the\n-    /// current size, then the file is expanded to be filled with 0s.\n+    /// If the `size` is less than the current file's size, then the file will\n+    /// be shrunk. If it is greater than the current file's size, then the file\n+    /// will be extended to `size` and have all of the intermediate data filled\n+    /// in with 0s.\n     ///\n     /// # Errors\n     ///\n     /// On error, this function will raise on the `io_error` condition.\n-    pub fn truncate(&mut self, offset: i64) {\n-        self.fd.truncate(offset);\n+    pub fn truncate(&mut self, size: i64) {\n+        self.fd.truncate(size).map_err(|e| io_error::cond.raise(e));\n     }\n }\n \n@@ -715,29 +715,68 @@ impl path::Path {\n }\n \n #[cfg(test)]\n+#[allow(unused_imports)]\n mod test {\n     use prelude::*;\n-    use io::{SeekSet, SeekCur, SeekEnd, io_error, Read, Open, ReadWrite};\n+    use io::{SeekSet, SeekCur, SeekEnd, io_error, Read, Open,\n+             ReadWrite};\n     use io;\n     use str;\n-    use super::{File, rmdir, mkdir, readdir, rmdir_recursive, mkdir_recursive,\n-                copy, unlink, stat, symlink, link, readlink, chmod,\n-                lstat, change_file_times};\n+    use io::fs::{File, rmdir, mkdir, readdir, rmdir_recursive,\n+                 mkdir_recursive, copy, unlink, stat, symlink, link,\n+                 readlink, chmod, lstat, change_file_times};\n+    use util;\n+    use path::Path;\n+    use io;\n+    use ops::Drop;\n+\n+    struct TempDir(Path);\n+\n+    impl Drop for TempDir {\n+        fn drop(&mut self) {\n+            // Gee, seeing how we're testing the fs module I sure hope that we\n+            // at least implement this correctly!\n+            io::fs::rmdir_recursive(&**self);\n+        }\n+    }\n \n-    fn tmpdir() -> Path {\n+    fn tmpdir() -> TempDir {\n         use os;\n         use rand;\n         let ret = os::tmpdir().join(format!(\"rust-{}\", rand::random::<u32>()));\n-        mkdir(&ret, io::UserRWX);\n-        ret\n+        io::fs::mkdir(&ret, io::UserRWX);\n+        TempDir(ret)\n     }\n \n-    fn free<T>(_: T) {}\n+    macro_rules! test (\n+        { fn $name:ident() $b:block } => (\n+            mod $name {\n+                use prelude::*;\n+                use io::{SeekSet, SeekCur, SeekEnd, io_error, Read, Open,\n+                         ReadWrite};\n+                use io;\n+                use str;\n+                use io::fs::{File, rmdir, mkdir, readdir, rmdir_recursive,\n+                             mkdir_recursive, copy, unlink, stat, symlink, link,\n+                             readlink, chmod, lstat, change_file_times};\n+                use io::fs::test::tmpdir;\n+                use util;\n+\n+                fn f() $b\n+\n+                #[test] fn uv() { f() }\n+                #[test] fn native() {\n+                    use rt::test::run_in_newsched_task;\n+                    run_in_newsched_task(f);\n+                }\n+            }\n+        )\n+    )\n \n-    #[test]\n-    fn file_test_io_smoke_test() {\n+    test!(fn file_test_io_smoke_test() {\n         let message = \"it's alright. have a good time\";\n-        let filename = &Path::new(\"./tmp/file_rt_io_file_test.txt\");\n+        let tmpdir = tmpdir();\n+        let filename = &tmpdir.join(\"file_rt_io_file_test.txt\");\n         {\n             let mut write_stream = File::open_mode(filename, Open, ReadWrite);\n             write_stream.write(message.as_bytes());\n@@ -752,11 +791,11 @@ mod test {\n             assert!(read_str == message.to_owned());\n         }\n         unlink(filename);\n-    }\n+    })\n \n-    #[test]\n-    fn file_test_io_invalid_path_opened_without_create_should_raise_condition() {\n-        let filename = &Path::new(\"./tmp/file_that_does_not_exist.txt\");\n+    test!(fn invalid_path_raises() {\n+        let tmpdir = tmpdir();\n+        let filename = &tmpdir.join(\"file_that_does_not_exist.txt\");\n         let mut called = false;\n         do io_error::cond.trap(|_| {\n             called = true;\n@@ -765,25 +804,25 @@ mod test {\n             assert!(result.is_none());\n         }\n         assert!(called);\n-    }\n+    })\n \n-    #[test]\n-    fn file_test_iounlinking_invalid_path_should_raise_condition() {\n-        let filename = &Path::new(\"./tmp/file_another_file_that_does_not_exist.txt\");\n+    test!(fn file_test_iounlinking_invalid_path_should_raise_condition() {\n+        let tmpdir = tmpdir();\n+        let filename = &tmpdir.join(\"file_another_file_that_does_not_exist.txt\");\n         let mut called = false;\n         do io_error::cond.trap(|_| {\n             called = true;\n         }).inside {\n             unlink(filename);\n         }\n         assert!(called);\n-    }\n+    })\n \n-    #[test]\n-    fn file_test_io_non_positional_read() {\n+    test!(fn file_test_io_non_positional_read() {\n         let message = \"ten-four\";\n         let mut read_mem = [0, .. 8];\n-        let filename = &Path::new(\"./tmp/file_rt_io_file_test_positional.txt\");\n+        let tmpdir = tmpdir();\n+        let filename = &tmpdir.join(\"file_rt_io_file_test_positional.txt\");\n         {\n             let mut rw_stream = File::open_mode(filename, Open, ReadWrite);\n             rw_stream.write(message.as_bytes());\n@@ -802,16 +841,16 @@ mod test {\n         unlink(filename);\n         let read_str = str::from_utf8(read_mem);\n         assert!(read_str == message.to_owned());\n-    }\n+    })\n \n-    #[test]\n-    fn file_test_io_seek_and_tell_smoke_test() {\n+    test!(fn file_test_io_seek_and_tell_smoke_test() {\n         let message = \"ten-four\";\n         let mut read_mem = [0, .. 4];\n         let set_cursor = 4 as u64;\n         let mut tell_pos_pre_read;\n         let mut tell_pos_post_read;\n-        let filename = &Path::new(\"./tmp/file_rt_io_file_test_seeking.txt\");\n+        let tmpdir = tmpdir();\n+        let filename = &tmpdir.join(\"file_rt_io_file_test_seeking.txt\");\n         {\n             let mut rw_stream = File::open_mode(filename, Open, ReadWrite);\n             rw_stream.write(message.as_bytes());\n@@ -828,16 +867,16 @@ mod test {\n         assert!(read_str == message.slice(4, 8).to_owned());\n         assert!(tell_pos_pre_read == set_cursor);\n         assert!(tell_pos_post_read == message.len() as u64);\n-    }\n+    })\n \n-    #[test]\n-    fn file_test_io_seek_and_write() {\n+    test!(fn file_test_io_seek_and_write() {\n         let initial_msg =   \"food-is-yummy\";\n         let overwrite_msg =    \"-the-bar!!\";\n         let final_msg =     \"foo-the-bar!!\";\n         let seek_idx = 3;\n         let mut read_mem = [0, .. 13];\n-        let filename = &Path::new(\"./tmp/file_rt_io_file_test_seek_and_write.txt\");\n+        let tmpdir = tmpdir();\n+        let filename = &tmpdir.join(\"file_rt_io_file_test_seek_and_write.txt\");\n         {\n             let mut rw_stream = File::open_mode(filename, Open, ReadWrite);\n             rw_stream.write(initial_msg.as_bytes());\n@@ -851,17 +890,17 @@ mod test {\n         unlink(filename);\n         let read_str = str::from_utf8(read_mem);\n         assert!(read_str == final_msg.to_owned());\n-    }\n+    })\n \n-    #[test]\n-    fn file_test_io_seek_shakedown() {\n+    test!(fn file_test_io_seek_shakedown() {\n         use std::str;          // 01234567890123\n         let initial_msg =   \"qwer-asdf-zxcv\";\n         let chunk_one = \"qwer\";\n         let chunk_two = \"asdf\";\n         let chunk_three = \"zxcv\";\n         let mut read_mem = [0, .. 4];\n-        let filename = &Path::new(\"./tmp/file_rt_io_file_test_seek_shakedown.txt\");\n+        let tmpdir = tmpdir();\n+        let filename = &tmpdir.join(\"file_rt_io_file_test_seek_shakedown.txt\");\n         {\n             let mut rw_stream = File::open_mode(filename, Open, ReadWrite);\n             rw_stream.write(initial_msg.as_bytes());\n@@ -885,11 +924,11 @@ mod test {\n             assert!(read_str == chunk_one.to_owned());\n         }\n         unlink(filename);\n-    }\n+    })\n \n-    #[test]\n-    fn file_test_stat_is_correct_on_is_file() {\n-        let filename = &Path::new(\"./tmp/file_stat_correct_on_is_file.txt\");\n+    test!(fn file_test_stat_is_correct_on_is_file() {\n+        let tmpdir = tmpdir();\n+        let filename = &tmpdir.join(\"file_stat_correct_on_is_file.txt\");\n         {\n             let mut fs = File::open_mode(filename, Open, ReadWrite);\n             let msg = \"hw\";\n@@ -898,49 +937,49 @@ mod test {\n         let stat_res = stat(filename);\n         assert_eq!(stat_res.kind, io::TypeFile);\n         unlink(filename);\n-    }\n+    })\n \n-    #[test]\n-    fn file_test_stat_is_correct_on_is_dir() {\n-        let filename = &Path::new(\"./tmp/file_stat_correct_on_is_dir\");\n+    test!(fn file_test_stat_is_correct_on_is_dir() {\n+        let tmpdir = tmpdir();\n+        let filename = &tmpdir.join(\"file_stat_correct_on_is_dir\");\n         mkdir(filename, io::UserRWX);\n         let stat_res = filename.stat();\n         assert!(stat_res.kind == io::TypeDirectory);\n         rmdir(filename);\n-    }\n+    })\n \n-    #[test]\n-    fn file_test_fileinfo_false_when_checking_is_file_on_a_directory() {\n-        let dir = &Path::new(\"./tmp/fileinfo_false_on_dir\");\n+    test!(fn file_test_fileinfo_false_when_checking_is_file_on_a_directory() {\n+        let tmpdir = tmpdir();\n+        let dir = &tmpdir.join(\"fileinfo_false_on_dir\");\n         mkdir(dir, io::UserRWX);\n         assert!(dir.is_file() == false);\n         rmdir(dir);\n-    }\n+    })\n \n-    #[test]\n-    fn file_test_fileinfo_check_exists_before_and_after_file_creation() {\n-        let file = &Path::new(\"./tmp/fileinfo_check_exists_b_and_a.txt\");\n+    test!(fn file_test_fileinfo_check_exists_before_and_after_file_creation() {\n+        let tmpdir = tmpdir();\n+        let file = &tmpdir.join(\"fileinfo_check_exists_b_and_a.txt\");\n         File::create(file).write(bytes!(\"foo\"));\n         assert!(file.exists());\n         unlink(file);\n         assert!(!file.exists());\n-    }\n+    })\n \n-    #[test]\n-    fn file_test_directoryinfo_check_exists_before_and_after_mkdir() {\n-        let dir = &Path::new(\"./tmp/before_and_after_dir\");\n+    test!(fn file_test_directoryinfo_check_exists_before_and_after_mkdir() {\n+        let tmpdir = tmpdir();\n+        let dir = &tmpdir.join(\"before_and_after_dir\");\n         assert!(!dir.exists());\n         mkdir(dir, io::UserRWX);\n         assert!(dir.exists());\n         assert!(dir.is_dir());\n         rmdir(dir);\n         assert!(!dir.exists());\n-    }\n+    })\n \n-    #[test]\n-    fn file_test_directoryinfo_readdir() {\n+    test!(fn file_test_directoryinfo_readdir() {\n         use std::str;\n-        let dir = &Path::new(\"./tmp/di_readdir\");\n+        let tmpdir = tmpdir();\n+        let dir = &tmpdir.join(\"di_readdir\");\n         mkdir(dir, io::UserRWX);\n         let prefix = \"foo\";\n         for n in range(0,3) {\n@@ -966,15 +1005,13 @@ mod test {\n             unlink(f);\n         }\n         rmdir(dir);\n-    }\n+    })\n \n-    #[test]\n-    fn recursive_mkdir_slash() {\n+    test!(fn recursive_mkdir_slash() {\n         mkdir_recursive(&Path::new(\"/\"), io::UserRWX);\n-    }\n+    })\n \n-    #[test]\n-    fn unicode_path_is_dir() {\n+    test!(fn unicode_path_is_dir() {\n         assert!(Path::new(\".\").is_dir());\n         assert!(!Path::new(\"test/stdtest/fs.rs\").is_dir());\n \n@@ -990,12 +1027,9 @@ mod test {\n         File::create(&filepath); // ignore return; touch only\n         assert!(!filepath.is_dir());\n         assert!(filepath.exists());\n+    })\n \n-        rmdir_recursive(&tmpdir);\n-    }\n-\n-    #[test]\n-    fn unicode_path_exists() {\n+    test!(fn unicode_path_exists() {\n         assert!(Path::new(\".\").exists());\n         assert!(!Path::new(\"test/nonexistent-bogus-path\").exists());\n \n@@ -1005,11 +1039,9 @@ mod test {\n         mkdir(&unicode, io::UserRWX);\n         assert!(unicode.exists());\n         assert!(!Path::new(\"test/unicode-bogus-path-\uac01\u4e01\u30fc\u518d\u89c1\").exists());\n-        rmdir_recursive(&tmpdir);\n-    }\n+    })\n \n-    #[test]\n-    fn copy_file_does_not_exist() {\n+    test!(fn copy_file_does_not_exist() {\n         let from = Path::new(\"test/nonexistent-bogus-path\");\n         let to = Path::new(\"test/other-bogus-path\");\n         match io::result(|| copy(&from, &to)) {\n@@ -1019,10 +1051,9 @@ mod test {\n                 assert!(!to.exists());\n             }\n         }\n-    }\n+    })\n \n-    #[test]\n-    fn copy_file_ok() {\n+    test!(fn copy_file_ok() {\n         let tmpdir = tmpdir();\n         let input = tmpdir.join(\"in.txt\");\n         let out = tmpdir.join(\"out.txt\");\n@@ -1033,23 +1064,19 @@ mod test {\n         assert_eq!(contents.as_slice(), bytes!(\"hello\"));\n \n         assert_eq!(input.stat().perm, out.stat().perm);\n-        rmdir_recursive(&tmpdir);\n-    }\n+    })\n \n-    #[test]\n-    fn copy_file_dst_dir() {\n+    test!(fn copy_file_dst_dir() {\n         let tmpdir = tmpdir();\n         let out = tmpdir.join(\"out\");\n \n         File::create(&out);\n-        match io::result(|| copy(&out, &tmpdir)) {\n+        match io::result(|| copy(&out, &*tmpdir)) {\n             Ok(*) => fail!(), Err(*) => {}\n         }\n-        rmdir_recursive(&tmpdir);\n-    }\n+    })\n \n-    #[test]\n-    fn copy_file_dst_exists() {\n+    test!(fn copy_file_dst_exists() {\n         let tmpdir = tmpdir();\n         let input = tmpdir.join(\"in\");\n         let output = tmpdir.join(\"out\");\n@@ -1060,24 +1087,19 @@ mod test {\n \n         assert_eq!(File::open(&output).read_to_end(),\n                    (bytes!(\"foo\")).to_owned());\n+    })\n \n-        rmdir_recursive(&tmpdir);\n-    }\n-\n-    #[test]\n-    fn copy_file_src_dir() {\n+    test!(fn copy_file_src_dir() {\n         let tmpdir = tmpdir();\n         let out = tmpdir.join(\"out\");\n \n-        match io::result(|| copy(&tmpdir, &out)) {\n+        match io::result(|| copy(&*tmpdir, &out)) {\n             Ok(*) => fail!(), Err(*) => {}\n         }\n         assert!(!out.exists());\n-        rmdir_recursive(&tmpdir);\n-    }\n+    })\n \n-    #[test]\n-    fn copy_file_preserves_perm_bits() {\n+    test!(fn copy_file_preserves_perm_bits() {\n         let tmpdir = tmpdir();\n         let input = tmpdir.join(\"in.txt\");\n         let out = tmpdir.join(\"out.txt\");\n@@ -1089,56 +1111,51 @@ mod test {\n \n         chmod(&input, io::UserFile);\n         chmod(&out, io::UserFile);\n-        rmdir_recursive(&tmpdir);\n-    }\n+    })\n \n-    #[test]\n-    #[ignore(cfg(windows))] // FIXME(#10264) operation not permitted?\n-    fn symlinks_work() {\n+    #[cfg(not(windows))] // FIXME(#10264) operation not permitted?\n+    test!(fn symlinks_work() {\n         let tmpdir = tmpdir();\n         let input = tmpdir.join(\"in.txt\");\n         let out = tmpdir.join(\"out.txt\");\n \n         File::create(&input).write(\"foobar\".as_bytes());\n         symlink(&input, &out);\n-        assert_eq!(lstat(&out).kind, io::TypeSymlink);\n+        if cfg!(not(windows)) {\n+            assert_eq!(lstat(&out).kind, io::TypeSymlink);\n+        }\n         assert_eq!(stat(&out).size, stat(&input).size);\n         assert_eq!(File::open(&out).read_to_end(), (bytes!(\"foobar\")).to_owned());\n+    })\n \n-        rmdir_recursive(&tmpdir);\n-    }\n-\n-    #[test]\n-    #[ignore(cfg(windows))] // apparently windows doesn't like symlinks\n-    fn symlink_noexist() {\n+    #[cfg(not(windows))] // apparently windows doesn't like symlinks\n+    test!(fn symlink_noexist() {\n         let tmpdir = tmpdir();\n         // symlinks can point to things that don't exist\n         symlink(&tmpdir.join(\"foo\"), &tmpdir.join(\"bar\"));\n         assert!(readlink(&tmpdir.join(\"bar\")).unwrap() == tmpdir.join(\"foo\"));\n-        rmdir_recursive(&tmpdir);\n-    }\n+    })\n \n-    #[test]\n-    fn readlink_not_symlink() {\n+    test!(fn readlink_not_symlink() {\n         let tmpdir = tmpdir();\n-        match io::result(|| readlink(&tmpdir)) {\n+        match io::result(|| readlink(&*tmpdir)) {\n             Ok(*) => fail!(\"wanted a failure\"),\n             Err(*) => {}\n         }\n-        rmdir_recursive(&tmpdir);\n-    }\n+    })\n \n-    #[test]\n-    fn links_work() {\n+    test!(fn links_work() {\n         let tmpdir = tmpdir();\n         let input = tmpdir.join(\"in.txt\");\n         let out = tmpdir.join(\"out.txt\");\n \n         File::create(&input).write(\"foobar\".as_bytes());\n         link(&input, &out);\n-        assert_eq!(lstat(&out).kind, io::TypeFile);\n+        if cfg!(not(windows)) {\n+            assert_eq!(lstat(&out).kind, io::TypeFile);\n+            assert_eq!(stat(&out).unstable.nlink, 2);\n+        }\n         assert_eq!(stat(&out).size, stat(&input).size);\n-        assert_eq!(stat(&out).unstable.nlink, 2);\n         assert_eq!(File::open(&out).read_to_end(), (bytes!(\"foobar\")).to_owned());\n \n         // can't link to yourself\n@@ -1151,12 +1168,9 @@ mod test {\n             Ok(*) => fail!(\"wanted a failure\"),\n             Err(*) => {}\n         }\n+    })\n \n-        rmdir_recursive(&tmpdir);\n-    }\n-\n-    #[test]\n-    fn chmod_works() {\n+    test!(fn chmod_works() {\n         let tmpdir = tmpdir();\n         let file = tmpdir.join(\"in.txt\");\n \n@@ -1171,11 +1185,9 @@ mod test {\n         }\n \n         chmod(&file, io::UserFile);\n-        rmdir_recursive(&tmpdir);\n-    }\n+    })\n \n-    #[test]\n-    fn sync_doesnt_kill_anything() {\n+    test!(fn sync_doesnt_kill_anything() {\n         let tmpdir = tmpdir();\n         let path = tmpdir.join(\"in.txt\");\n \n@@ -1185,24 +1197,23 @@ mod test {\n         file.write(bytes!(\"foo\"));\n         file.fsync();\n         file.datasync();\n-        free(file);\n-\n-        rmdir_recursive(&tmpdir);\n-    }\n+        util::ignore(file);\n+    })\n \n-    #[test]\n-    fn truncate_works() {\n+    test!(fn truncate_works() {\n         let tmpdir = tmpdir();\n         let path = tmpdir.join(\"in.txt\");\n \n         let mut file = File::open_mode(&path, io::Open, io::ReadWrite).unwrap();\n         file.write(bytes!(\"foo\"));\n+        file.fsync();\n \n         // Do some simple things with truncation\n         assert_eq!(stat(&path).size, 3);\n         file.truncate(10);\n         assert_eq!(stat(&path).size, 10);\n         file.write(bytes!(\"bar\"));\n+        file.fsync();\n         assert_eq!(stat(&path).size, 10);\n         assert_eq!(File::open(&path).read_to_end(),\n                    (bytes!(\"foobar\", 0, 0, 0, 0)).to_owned());\n@@ -1213,16 +1224,14 @@ mod test {\n         file.truncate(2);\n         assert_eq!(stat(&path).size, 2);\n         file.write(bytes!(\"wut\"));\n+        file.fsync();\n         assert_eq!(stat(&path).size, 9);\n         assert_eq!(File::open(&path).read_to_end(),\n                    (bytes!(\"fo\", 0, 0, 0, 0, \"wut\")).to_owned());\n-        free(file);\n-\n-        rmdir_recursive(&tmpdir);\n-    }\n+        util::ignore(file);\n+    })\n \n-    #[test]\n-    fn open_flavors() {\n+    test!(fn open_flavors() {\n         let tmpdir = tmpdir();\n \n         match io::result(|| File::open_mode(&tmpdir.join(\"a\"), io::Open,\n@@ -1258,9 +1267,7 @@ mod test {\n             f.write(\"bar\".as_bytes());\n         }\n         assert_eq!(stat(&tmpdir.join(\"h\")).size, 3);\n-\n-        rmdir_recursive(&tmpdir);\n-    }\n+    })\n \n     #[test]\n     fn utime() {\n@@ -1271,8 +1278,6 @@ mod test {\n         change_file_times(&path, 1000, 2000);\n         assert_eq!(path.stat().accessed, 1000);\n         assert_eq!(path.stat().modified, 2000);\n-\n-        rmdir_recursive(&tmpdir);\n     }\n \n     #[test]\n@@ -1283,7 +1288,5 @@ mod test {\n             Ok(*) => fail!(),\n             Err(*) => {}\n         }\n-\n-        rmdir_recursive(&tmpdir);\n     }\n }"}, {"sha": "03d9dc7ef6e6b6d9e51fe06dce6b35756c5d93d3", "filename": "src/libstd/io/native/file.rs", "status": "modified", "additions": 639, "deletions": 451, "changes": 1090, "blob_url": "https://github.com/rust-lang/rust/blob/68d5510292ed2f9714568285759ca9ef54d9b48c/src%2Flibstd%2Fio%2Fnative%2Ffile.rs", "raw_url": "https://github.com/rust-lang/rust/raw/68d5510292ed2f9714568285759ca9ef54d9b48c/src%2Flibstd%2Fio%2Fnative%2Ffile.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fnative%2Ffile.rs?ref=68d5510292ed2f9714568285759ca9ef54d9b48c", "patch": "@@ -12,16 +12,26 @@\n \n #[allow(non_camel_case_types)];\n \n+use c_str::CString;\n use io::IoError;\n use io;\n+use libc::c_int;\n use libc;\n use ops::Drop;\n use option::{Some, None, Option};\n use os;\n+use path::{Path, GenericPath};\n use ptr::RawPtr;\n use result::{Result, Ok, Err};\n use rt::rtio;\n+use super::IoResult;\n+use unstable::intrinsics;\n use vec::ImmutableVector;\n+use vec;\n+\n+#[cfg(windows)] use os::win32::{as_utf16_p, fill_utf16_buf_and_decode};\n+#[cfg(windows)] use ptr;\n+#[cfg(windows)] use str;\n \n fn keep_going(data: &[u8], f: &fn(*u8, uint) -> i64) -> i64 {\n     #[cfg(windows)] static eintr: int = 0; // doesn't matter\n@@ -122,26 +132,157 @@ impl rtio::RtioFileStream for FileDesc {\n     fn write(&mut self, buf: &[u8]) -> Result<(), IoError> {\n         self.inner_write(buf)\n     }\n-    fn pread(&mut self, _buf: &mut [u8], _offset: u64) -> Result<int, IoError> {\n-        Err(super::unimpl())\n+    fn pread(&mut self, buf: &mut [u8], offset: u64) -> Result<int, IoError> {\n+        return os_pread(self.fd, vec::raw::to_ptr(buf), buf.len(), offset);\n+\n+        #[cfg(windows)]\n+        fn os_pread(fd: c_int, buf: *u8, amt: uint, offset: u64) -> IoResult<int> {\n+            unsafe {\n+                let mut overlap: libc::OVERLAPPED = intrinsics::init();\n+                let handle = libc::get_osfhandle(fd) as libc::HANDLE;\n+                let mut bytes_read = 0;\n+                overlap.Offset = offset as libc::DWORD;\n+                overlap.OffsetHigh = (offset >> 32) as libc::DWORD;\n+\n+                match libc::ReadFile(handle, buf as libc::LPVOID,\n+                                     amt as libc::DWORD,\n+                                     &mut bytes_read, &mut overlap) {\n+                    0 => Err(super::last_error()),\n+                    _ => Ok(bytes_read as int)\n+                }\n+            }\n+        }\n+\n+        #[cfg(unix)]\n+        fn os_pread(fd: c_int, buf: *u8, amt: uint, offset: u64) -> IoResult<int> {\n+            match unsafe {\n+                libc::pread(fd, buf as *libc::c_void, amt as libc::size_t,\n+                            offset as libc::off_t)\n+            } {\n+                -1 => Err(super::last_error()),\n+                n => Ok(n as int)\n+            }\n+        }\n     }\n-    fn pwrite(&mut self, _buf: &[u8], _offset: u64) -> Result<(), IoError> {\n-        Err(super::unimpl())\n+    fn pwrite(&mut self, buf: &[u8], offset: u64) -> Result<(), IoError> {\n+        return os_pwrite(self.fd, vec::raw::to_ptr(buf), buf.len(), offset);\n+\n+        #[cfg(windows)]\n+        fn os_pwrite(fd: c_int, buf: *u8, amt: uint, offset: u64) -> IoResult<()> {\n+            unsafe {\n+                let mut overlap: libc::OVERLAPPED = intrinsics::init();\n+                let handle = libc::get_osfhandle(fd) as libc::HANDLE;\n+                overlap.Offset = offset as libc::DWORD;\n+                overlap.OffsetHigh = (offset >> 32) as libc::DWORD;\n+\n+                match libc::WriteFile(handle, buf as libc::LPVOID,\n+                                      amt as libc::DWORD,\n+                                      ptr::mut_null(), &mut overlap) {\n+                    0 => Err(super::last_error()),\n+                    _ => Ok(()),\n+                }\n+            }\n+        }\n+\n+        #[cfg(unix)]\n+        fn os_pwrite(fd: c_int, buf: *u8, amt: uint, offset: u64) -> IoResult<()> {\n+            super::mkerr_libc(unsafe {\n+                libc::pwrite(fd, buf as *libc::c_void, amt as libc::size_t,\n+                             offset as libc::off_t)\n+            } as c_int)\n+        }\n     }\n-    fn seek(&mut self, _pos: i64, _whence: io::SeekStyle) -> Result<u64, IoError> {\n-        Err(super::unimpl())\n+    #[cfg(windows)]\n+    fn seek(&mut self, pos: i64, style: io::SeekStyle) -> Result<u64, IoError> {\n+        let whence = match style {\n+            io::SeekSet => libc::FILE_BEGIN,\n+            io::SeekEnd => libc::FILE_END,\n+            io::SeekCur => libc::FILE_CURRENT,\n+        };\n+        unsafe {\n+            let handle = libc::get_osfhandle(self.fd) as libc::HANDLE;\n+            let mut newpos = 0;\n+            match libc::SetFilePointerEx(handle, pos, &mut newpos, whence) {\n+                0 => Err(super::last_error()),\n+                _ => Ok(newpos as u64),\n+            }\n+        }\n+    }\n+    #[cfg(unix)]\n+    fn seek(&mut self, pos: i64, whence: io::SeekStyle) -> Result<u64, IoError> {\n+        let whence = match whence {\n+            io::SeekSet => libc::SEEK_SET,\n+            io::SeekEnd => libc::SEEK_END,\n+            io::SeekCur => libc::SEEK_CUR,\n+        };\n+        let n = unsafe { libc::lseek(self.fd, pos as libc::off_t, whence) };\n+        if n < 0 {\n+            Err(super::last_error())\n+        } else {\n+            Ok(n as u64)\n+        }\n     }\n     fn tell(&self) -> Result<u64, IoError> {\n-        Err(super::unimpl())\n+        let n = unsafe { libc::lseek(self.fd, 0, libc::SEEK_CUR) };\n+        if n < 0 {\n+            Err(super::last_error())\n+        } else {\n+            Ok(n as u64)\n+        }\n     }\n     fn fsync(&mut self) -> Result<(), IoError> {\n-        Err(super::unimpl())\n+        return os_fsync(self.fd);\n+\n+        #[cfg(windows)]\n+        fn os_fsync(fd: c_int) -> IoResult<()> {\n+            super::mkerr_winbool(unsafe {\n+                let handle = libc::get_osfhandle(fd);\n+                libc::FlushFileBuffers(handle as libc::HANDLE)\n+            })\n+        }\n+        #[cfg(unix)]\n+        fn os_fsync(fd: c_int) -> IoResult<()> {\n+            super::mkerr_libc(unsafe { libc::fsync(fd) })\n+        }\n     }\n+    #[cfg(windows)]\n+    fn datasync(&mut self) -> Result<(), IoError> { return self.fsync(); }\n+\n+    #[cfg(not(windows))]\n     fn datasync(&mut self) -> Result<(), IoError> {\n-        Err(super::unimpl())\n+        return super::mkerr_libc(os_datasync(self.fd));\n+\n+        #[cfg(target_os = \"macos\")]\n+        fn os_datasync(fd: c_int) -> c_int {\n+            unsafe { libc::fcntl(fd, libc::F_FULLFSYNC) }\n+        }\n+        #[cfg(target_os = \"linux\")]\n+        fn os_datasync(fd: c_int) -> c_int { unsafe { libc::fdatasync(fd) } }\n+        #[cfg(not(target_os = \"macos\"), not(target_os = \"linux\"))]\n+        fn os_datasync(fd: c_int) -> c_int { unsafe { libc::fsync(fd) } }\n     }\n-    fn truncate(&mut self, _offset: i64) -> Result<(), IoError> {\n-        Err(super::unimpl())\n+\n+    #[cfg(windows)]\n+    fn truncate(&mut self, offset: i64) -> Result<(), IoError> {\n+        let orig_pos = match self.tell() { Ok(i) => i, Err(e) => return Err(e) };\n+        match self.seek(offset, io::SeekSet) {\n+            Ok(_) => {}, Err(e) => return Err(e),\n+        };\n+        let ret = unsafe {\n+            let handle = libc::get_osfhandle(self.fd) as libc::HANDLE;\n+            match libc::SetEndOfFile(handle) {\n+                0 => Err(super::last_error()),\n+                _ => Ok(())\n+            }\n+        };\n+        self.seek(orig_pos as i64, io::SeekSet);\n+        return ret;\n+    }\n+    #[cfg(unix)]\n+    fn truncate(&mut self, offset: i64) -> Result<(), IoError> {\n+        super::mkerr_libc(unsafe {\n+            libc::ftruncate(self.fd, offset as libc::off_t)\n+        })\n     }\n }\n \n@@ -179,15 +320,25 @@ impl Drop for FileDesc {\n }\n \n pub struct CFile {\n-    priv file: *libc::FILE\n+    priv file: *libc::FILE,\n+    priv fd: FileDesc,\n }\n \n impl CFile {\n     /// Create a `CFile` from an open `FILE` pointer.\n     ///\n     /// The `CFile` takes ownership of the `FILE` pointer and will close it upon\n     /// destruction.\n-    pub fn new(file: *libc::FILE) -> CFile { CFile { file: file } }\n+    pub fn new(file: *libc::FILE) -> CFile {\n+        CFile {\n+            file: file,\n+            fd: FileDesc::new(unsafe { libc::fileno(file) }, false)\n+        }\n+    }\n+\n+    pub fn flush(&mut self) -> Result<(), IoError> {\n+        super::mkerr_libc(unsafe { libc::fflush(self.file) })\n+    }\n }\n \n impl rtio::RtioFileStream for CFile {\n@@ -221,11 +372,13 @@ impl rtio::RtioFileStream for CFile {\n         }\n     }\n \n-    fn pread(&mut self, _buf: &mut [u8], _offset: u64) -> Result<int, IoError> {\n-        Err(super::unimpl())\n+    fn pread(&mut self, buf: &mut [u8], offset: u64) -> Result<int, IoError> {\n+        self.flush();\n+        self.fd.pread(buf, offset)\n     }\n-    fn pwrite(&mut self, _buf: &[u8], _offset: u64) -> Result<(), IoError> {\n-        Err(super::unimpl())\n+    fn pwrite(&mut self, buf: &[u8], offset: u64) -> Result<(), IoError> {\n+        self.flush();\n+        self.fd.pwrite(buf, offset)\n     }\n     fn seek(&mut self, pos: i64, style: io::SeekStyle) -> Result<u64, IoError> {\n         let whence = match style {\n@@ -249,13 +402,16 @@ impl rtio::RtioFileStream for CFile {\n         }\n     }\n     fn fsync(&mut self) -> Result<(), IoError> {\n-        Err(super::unimpl())\n+        self.flush();\n+        self.fd.fsync()\n     }\n     fn datasync(&mut self) -> Result<(), IoError> {\n-        Err(super::unimpl())\n+        self.flush();\n+        self.fd.fsync()\n     }\n-    fn truncate(&mut self, _offset: i64) -> Result<(), IoError> {\n-        Err(super::unimpl())\n+    fn truncate(&mut self, offset: i64) -> Result<(), IoError> {\n+        self.flush();\n+        self.fd.truncate(offset)\n     }\n }\n \n@@ -265,529 +421,561 @@ impl Drop for CFile {\n     }\n }\n \n-#[cfg(test)]\n-mod tests {\n-    use libc;\n-    use os;\n-    use io::{io_error, SeekSet, Writer, Reader};\n-    use result::Ok;\n-    use super::{CFile, FileDesc};\n+pub fn open(path: &CString, fm: io::FileMode, fa: io::FileAccess)\n+        -> IoResult<FileDesc> {\n+    let flags = match fm {\n+        io::Open => 0,\n+        io::Append => libc::O_APPEND,\n+        io::Truncate => libc::O_TRUNC,\n+    };\n+    // Opening with a write permission must silently create the file.\n+    let (flags, mode) = match fa {\n+        io::Read => (flags | libc::O_RDONLY, 0),\n+        io::Write => (flags | libc::O_WRONLY | libc::O_CREAT,\n+                      libc::S_IRUSR | libc::S_IWUSR),\n+        io::ReadWrite => (flags | libc::O_RDWR | libc::O_CREAT,\n+                          libc::S_IRUSR | libc::S_IWUSR),\n+    };\n+\n+    return match os_open(path, flags, mode) {\n+        -1 => Err(super::last_error()),\n+        fd => Ok(FileDesc::new(fd, true)),\n+    };\n \n-    #[ignore(cfg(target_os = \"freebsd\"))] // hmm, maybe pipes have a tiny buffer\n-    fn test_file_desc() {\n-        // Run this test with some pipes so we don't have to mess around with\n-        // opening or closing files.\n-        unsafe {\n-            let os::Pipe { input, out } = os::pipe();\n-            let mut reader = FileDesc::new(input, true);\n-            let mut writer = FileDesc::new(out, true);\n-\n-            writer.inner_write(bytes!(\"test\"));\n-            let mut buf = [0u8, ..4];\n-            match reader.inner_read(buf) {\n-                Ok(4) => {\n-                    assert_eq!(buf[0], 't' as u8);\n-                    assert_eq!(buf[1], 'e' as u8);\n-                    assert_eq!(buf[2], 's' as u8);\n-                    assert_eq!(buf[3], 't' as u8);\n-                }\n-                r => fail!(\"invalid read: {:?}\", r)\n-            }\n-\n-            assert!(writer.inner_read(buf).is_err());\n-            assert!(reader.inner_write(buf).is_err());\n+    #[cfg(windows)]\n+    fn os_open(path: &CString, flags: c_int, mode: c_int) -> c_int {\n+        do as_utf16_p(path.as_str().unwrap()) |path| {\n+            unsafe { libc::wopen(path, flags, mode) }\n         }\n     }\n \n-    #[ignore(cfg(windows))] // apparently windows doesn't like tmpfile\n-    fn test_cfile() {\n-        unsafe {\n-            let f = libc::tmpfile();\n-            assert!(!f.is_null());\n-            let mut file = CFile::new(f);\n+    #[cfg(unix)]\n+    fn os_open(path: &CString, flags: c_int, mode: c_int) -> c_int {\n+        unsafe { libc::open(path.with_ref(|p| p), flags, mode) }\n+    }\n+}\n \n-            file.write(bytes!(\"test\"));\n-            let mut buf = [0u8, ..4];\n-            file.seek(0, SeekSet);\n-            match file.read(buf) {\n-                Ok(4) => {\n-                    assert_eq!(buf[0], 't' as u8);\n-                    assert_eq!(buf[1], 'e' as u8);\n-                    assert_eq!(buf[2], 's' as u8);\n-                    assert_eq!(buf[3], 't' as u8);\n-                }\n-                r => fail!(\"invalid read: {:?}\", r)\n+pub fn mkdir(p: &CString, mode: io::FilePermission) -> IoResult<()> {\n+    return os_mkdir(p, mode as c_int);\n+\n+    #[cfg(windows)]\n+    fn os_mkdir(p: &CString, _mode: c_int) -> IoResult<()> {\n+        super::mkerr_winbool(unsafe {\n+            // FIXME: turn mode into something useful? #2623\n+            do as_utf16_p(p.as_str().unwrap()) |buf| {\n+                libc::CreateDirectoryW(buf, ptr::mut_null())\n             }\n-        }\n+        })\n+    }\n+\n+    #[cfg(unix)]\n+    fn os_mkdir(p: &CString, mode: c_int) -> IoResult<()> {\n+        super::mkerr_libc(unsafe {\n+            libc::mkdir(p.with_ref(|p| p), mode as libc::mode_t)\n+        })\n     }\n }\n \n-// n.b. these functions were all part of the old `std::os` module. There's lots\n-//      of fun little nuances that were taken care of by these functions, but\n-//      they are all thread-blocking versions that are no longer desired (we now\n-//      use a non-blocking event loop implementation backed by libuv).\n-//\n-//      In theory we will have a thread-blocking version of the event loop (if\n-//      desired), so these functions may just need to get adapted to work in\n-//      those situtations. For now, I'm leaving the code around so it doesn't\n-//      get bitrotted instantaneously.\n-mod old_os {\n-    use prelude::*;\n-    use libc::{size_t, c_void, c_int};\n-    use libc;\n-    use vec;\n+pub fn readdir(p: &CString) -> IoResult<~[Path]> {\n+    fn prune(root: &CString, dirs: ~[Path]) -> ~[Path] {\n+        let root = unsafe { CString::new(root.with_ref(|p| p), false) };\n+        let root = Path::new(root);\n \n-    #[cfg(not(windows))] use c_str::CString;\n-    #[cfg(not(windows))] use libc::fclose;\n-    #[cfg(test)] #[cfg(windows)] use os;\n-    #[cfg(test)] use rand;\n-    #[cfg(windows)] use str;\n-    #[cfg(windows)] use ptr;\n+        dirs.move_iter().filter(|path| {\n+            path.as_vec() != bytes!(\".\") && path.as_vec() != bytes!(\"..\")\n+        }).map(|path| root.join(path)).collect()\n+    }\n \n-    // On Windows, wide character version of function must be used to support\n-    // unicode, so functions should be split into at least two versions,\n-    // which are for Windows and for non-Windows, if necessary.\n-    // See https://github.com/mozilla/rust/issues/9822 for more information.\n+    unsafe {\n+        #[cfg(not(windows))]\n+        unsafe fn get_list(p: &CString) -> IoResult<~[Path]> {\n+            use libc::{dirent_t};\n+            use libc::{opendir, readdir, closedir};\n+            extern {\n+                fn rust_list_dir_val(ptr: *dirent_t) -> *libc::c_char;\n+            }\n+            debug!(\"os::list_dir -- BEFORE OPENDIR\");\n \n-    mod rustrt {\n-        use libc::{c_char, c_int};\n-        use libc;\n+            let dir_ptr = do p.with_ref |buf| {\n+                opendir(buf)\n+            };\n \n-        extern {\n-            pub fn rust_path_is_dir(path: *libc::c_char) -> c_int;\n-            pub fn rust_path_exists(path: *libc::c_char) -> c_int;\n+            if (dir_ptr as uint != 0) {\n+                let mut paths = ~[];\n+                debug!(\"os::list_dir -- opendir() SUCCESS\");\n+                let mut entry_ptr = readdir(dir_ptr);\n+                while (entry_ptr as uint != 0) {\n+                    let cstr = CString::new(rust_list_dir_val(entry_ptr), false);\n+                    paths.push(Path::new(cstr));\n+                    entry_ptr = readdir(dir_ptr);\n+                }\n+                closedir(dir_ptr);\n+                Ok(paths)\n+            } else {\n+                Err(super::last_error())\n+            }\n         }\n \n-        // Uses _wstat instead of stat.\n         #[cfg(windows)]\n-        extern {\n-            pub fn rust_path_is_dir_u16(path: *u16) -> c_int;\n-            pub fn rust_path_exists_u16(path: *u16) -> c_int;\n+        unsafe fn get_list(p: &CString) -> IoResult<~[Path]> {\n+            use libc::consts::os::extra::INVALID_HANDLE_VALUE;\n+            use libc::{wcslen, free};\n+            use libc::funcs::extra::kernel32::{\n+                FindFirstFileW,\n+                FindNextFileW,\n+                FindClose,\n+            };\n+            use libc::types::os::arch::extra::HANDLE;\n+            use os::win32::{\n+                as_utf16_p\n+            };\n+            use rt::global_heap::malloc_raw;\n+\n+            #[nolink]\n+            extern {\n+                fn rust_list_dir_wfd_size() -> libc::size_t;\n+                fn rust_list_dir_wfd_fp_buf(wfd: *libc::c_void) -> *u16;\n+            }\n+            let p = CString::new(p.with_ref(|p| p), false);\n+            let p = Path::new(p);\n+            let star = p.join(\"*\");\n+            do as_utf16_p(star.as_str().unwrap()) |path_ptr| {\n+                let wfd_ptr = malloc_raw(rust_list_dir_wfd_size() as uint);\n+                let find_handle = FindFirstFileW(path_ptr, wfd_ptr as HANDLE);\n+                if find_handle as libc::c_int != INVALID_HANDLE_VALUE {\n+                    let mut paths = ~[];\n+                    let mut more_files = 1 as libc::c_int;\n+                    while more_files != 0 {\n+                        let fp_buf = rust_list_dir_wfd_fp_buf(wfd_ptr);\n+                        if fp_buf as uint == 0 {\n+                            fail!(\"os::list_dir() failure: got null ptr from wfd\");\n+                        }\n+                        else {\n+                            let fp_vec = vec::from_buf(\n+                                fp_buf, wcslen(fp_buf) as uint);\n+                            let fp_str = str::from_utf16(fp_vec);\n+                            paths.push(Path::new(fp_str));\n+                        }\n+                        more_files = FindNextFileW(find_handle, wfd_ptr as HANDLE);\n+                    }\n+                    FindClose(find_handle);\n+                    free(wfd_ptr);\n+                    Ok(paths)\n+                } else {\n+                    Err(super::last_error())\n+                }\n+            }\n         }\n+\n+        get_list(p).map(|paths| prune(p, paths))\n     }\n+}\n+\n+pub fn unlink(p: &CString) -> IoResult<()> {\n+    return os_unlink(p);\n \n-    /// Recursively walk a directory structure\n-    pub fn walk_dir(p: &Path, f: &fn(&Path) -> bool) -> bool {\n-        let r = list_dir(p);\n-        r.iter().advance(|q| {\n-            let path = &p.join(q);\n-            f(path) && (!path_is_dir(path) || walk_dir(path, |p| f(p)))\n+    #[cfg(windows)]\n+    fn os_unlink(p: &CString) -> IoResult<()> {\n+        super::mkerr_winbool(unsafe {\n+            do as_utf16_p(p.as_str().unwrap()) |buf| {\n+                libc::DeleteFileW(buf)\n+            }\n         })\n     }\n \n     #[cfg(unix)]\n-    /// Indicates whether a path represents a directory\n-    pub fn path_is_dir(p: &Path) -> bool {\n-        unsafe {\n-            do p.with_c_str |buf| {\n-                rustrt::rust_path_is_dir(buf) != 0 as c_int\n+    fn os_unlink(p: &CString) -> IoResult<()> {\n+        super::mkerr_libc(unsafe { libc::unlink(p.with_ref(|p| p)) })\n+    }\n+}\n+\n+pub fn rename(old: &CString, new: &CString) -> IoResult<()> {\n+    return os_rename(old, new);\n+\n+    #[cfg(windows)]\n+    fn os_rename(old: &CString, new: &CString) -> IoResult<()> {\n+        super::mkerr_winbool(unsafe {\n+            do as_utf16_p(old.as_str().unwrap()) |old| {\n+                do as_utf16_p(new.as_str().unwrap()) |new| {\n+                    libc::MoveFileExW(old, new, libc::MOVEFILE_REPLACE_EXISTING)\n+                }\n             }\n-        }\n+        })\n+    }\n+\n+    #[cfg(unix)]\n+    fn os_rename(old: &CString, new: &CString) -> IoResult<()> {\n+        super::mkerr_libc(unsafe {\n+            libc::rename(old.with_ref(|p| p), new.with_ref(|p| p))\n+        })\n     }\n+}\n \n+pub fn chmod(p: &CString, mode: io::FilePermission) -> IoResult<()> {\n+    return super::mkerr_libc(os_chmod(p, mode as c_int));\n \n     #[cfg(windows)]\n-    pub fn path_is_dir(p: &Path) -> bool {\n+    fn os_chmod(p: &CString, mode: c_int) -> c_int {\n         unsafe {\n-            do os::win32::as_utf16_p(p.as_str().unwrap()) |buf| {\n-                rustrt::rust_path_is_dir_u16(buf) != 0 as c_int\n+            do as_utf16_p(p.as_str().unwrap()) |p| {\n+                libc::wchmod(p, mode)\n             }\n         }\n     }\n \n     #[cfg(unix)]\n-    /// Indicates whether a path exists\n-    pub fn path_exists(p: &Path) -> bool {\n+    fn os_chmod(p: &CString, mode: c_int) -> c_int {\n+        unsafe { libc::chmod(p.with_ref(|p| p), mode as libc::mode_t) }\n+    }\n+}\n+\n+pub fn rmdir(p: &CString) -> IoResult<()> {\n+    return super::mkerr_libc(os_rmdir(p));\n+\n+    #[cfg(windows)]\n+    fn os_rmdir(p: &CString) -> c_int {\n         unsafe {\n-            do p.with_c_str |buf| {\n-                rustrt::rust_path_exists(buf) != 0 as c_int\n-            }\n+            do as_utf16_p(p.as_str().unwrap()) |p| { libc::wrmdir(p) }\n         }\n     }\n \n+    #[cfg(unix)]\n+    fn os_rmdir(p: &CString) -> c_int {\n+        unsafe { libc::rmdir(p.with_ref(|p| p)) }\n+    }\n+}\n+\n+pub fn chown(p: &CString, uid: int, gid: int) -> IoResult<()> {\n+    return super::mkerr_libc(os_chown(p, uid, gid));\n+\n+    // libuv has this as a no-op, so seems like this should as well?\n     #[cfg(windows)]\n-    pub fn path_exists(p: &Path) -> bool {\n+    fn os_chown(_p: &CString, _uid: int, _gid: int) -> c_int { 0 }\n+\n+    #[cfg(unix)]\n+    fn os_chown(p: &CString, uid: int, gid: int) -> c_int {\n         unsafe {\n-            do os::win32::as_utf16_p(p.as_str().unwrap()) |buf| {\n-                rustrt::rust_path_exists_u16(buf) != 0 as c_int\n-            }\n+            libc::chown(p.with_ref(|p| p), uid as libc::uid_t,\n+                        gid as libc::gid_t)\n         }\n     }\n+}\n \n-    /// Creates a directory at the specified path\n-    pub fn make_dir(p: &Path, mode: c_int) -> bool {\n-        return mkdir(p, mode);\n+pub fn readlink(p: &CString) -> IoResult<Path> {\n+    return os_readlink(p);\n \n-        #[cfg(windows)]\n-        fn mkdir(p: &Path, _mode: c_int) -> bool {\n+    // XXX: I have a feeling that this reads intermediate symlinks as well.\n+    #[cfg(windows)]\n+    fn os_readlink(p: &CString) -> IoResult<Path> {\n+        let handle = unsafe {\n+            do as_utf16_p(p.as_str().unwrap()) |p| {\n+                libc::CreateFileW(p,\n+                                  libc::GENERIC_READ,\n+                                  libc::FILE_SHARE_READ,\n+                                  ptr::mut_null(),\n+                                  libc::OPEN_EXISTING,\n+                                  libc::FILE_ATTRIBUTE_NORMAL,\n+                                  ptr::mut_null())\n+            }\n+        };\n+        if handle == ptr::mut_null() { return Err(super::last_error()) }\n+        let ret = do fill_utf16_buf_and_decode |buf, sz| {\n             unsafe {\n-                use os::win32::as_utf16_p;\n-                // FIXME: turn mode into something useful? #2623\n-                do as_utf16_p(p.as_str().unwrap()) |buf| {\n-                    libc::CreateDirectoryW(buf, ptr::mut_null())\n-                        != (0 as libc::BOOL)\n-                }\n+                libc::GetFinalPathNameByHandleW(handle, buf as *u16, sz,\n+                                                libc::VOLUME_NAME_NT)\n             }\n-        }\n+        };\n+        let ret = match ret {\n+            Some(s) => Ok(Path::new(s)),\n+            None => Err(super::last_error()),\n+        };\n+        unsafe { libc::CloseHandle(handle) };\n+        return ret;\n \n-        #[cfg(unix)]\n-        fn mkdir(p: &Path, mode: c_int) -> bool {\n-            do p.with_c_str |buf| {\n-                unsafe {\n-                    libc::mkdir(buf, mode as libc::mode_t) == (0 as c_int)\n-                }\n-            }\n-        }\n     }\n \n-    /// Creates a directory with a given mode.\n-    /// Returns true iff creation\n-    /// succeeded. Also creates all intermediate subdirectories\n-    /// if they don't already exist, giving all of them the same mode.\n-\n-    // tjc: if directory exists but with different permissions,\n-    // should we return false?\n-    pub fn mkdir_recursive(p: &Path, mode: c_int) -> bool {\n-        if path_is_dir(p) {\n-            return true;\n+    #[cfg(unix)]\n+    fn os_readlink(p: &CString) -> IoResult<Path> {\n+        let p = p.with_ref(|p| p);\n+        let mut len = unsafe { libc::pathconf(p, libc::_PC_NAME_MAX) };\n+        if len == -1 {\n+            len = 1024; // XXX: read PATH_MAX from C ffi?\n         }\n-        if p.filename().is_some() {\n-            let mut p_ = p.clone();\n-            p_.pop();\n-            if !mkdir_recursive(&p_, mode) {\n-                return false;\n+        let mut buf = vec::with_capacity::<u8>(len as uint);\n+        match unsafe {\n+            libc::readlink(p, vec::raw::to_ptr(buf) as *mut libc::c_char,\n+                           len as libc::size_t)\n+        } {\n+            -1 => Err(super::last_error()),\n+            n => {\n+                assert!(n > 0);\n+                unsafe { vec::raw::set_len(&mut buf, n as uint); }\n+                Ok(Path::new(buf))\n             }\n         }\n-        return make_dir(p, mode);\n     }\n+}\n \n-    /// Lists the contents of a directory\n-    ///\n-    /// Each resulting Path is a relative path with no directory component.\n-    pub fn list_dir(p: &Path) -> ~[Path] {\n-        unsafe {\n-            #[cfg(target_os = \"linux\")]\n-            #[cfg(target_os = \"android\")]\n-            #[cfg(target_os = \"freebsd\")]\n-            #[cfg(target_os = \"macos\")]\n-            unsafe fn get_list(p: &Path) -> ~[Path] {\n-                use libc::{dirent_t};\n-                use libc::{opendir, readdir, closedir};\n-                extern {\n-                    fn rust_list_dir_val(ptr: *dirent_t) -> *libc::c_char;\n-                }\n-                let mut paths = ~[];\n-                debug!(\"os::list_dir -- BEFORE OPENDIR\");\n-\n-                let dir_ptr = do p.with_c_str |buf| {\n-                    opendir(buf)\n-                };\n-\n-                if (dir_ptr as uint != 0) {\n-                    debug!(\"os::list_dir -- opendir() SUCCESS\");\n-                    let mut entry_ptr = readdir(dir_ptr);\n-                    while (entry_ptr as uint != 0) {\n-                        let cstr = CString::new(rust_list_dir_val(entry_ptr), false);\n-                        paths.push(Path::new(cstr));\n-                        entry_ptr = readdir(dir_ptr);\n-                    }\n-                    closedir(dir_ptr);\n-                }\n-                else {\n-                    debug!(\"os::list_dir -- opendir() FAILURE\");\n-                }\n-                debug!(\"os::list_dir -- AFTER -- \\\\#: {}\", paths.len());\n-                paths\n-            }\n-            #[cfg(windows)]\n-            unsafe fn get_list(p: &Path) -> ~[Path] {\n-                use libc::consts::os::extra::INVALID_HANDLE_VALUE;\n-                use libc::{wcslen, free};\n-                use libc::funcs::extra::kernel32::{\n-                    FindFirstFileW,\n-                    FindNextFileW,\n-                    FindClose,\n-                };\n-                use libc::types::os::arch::extra::HANDLE;\n-                use os::win32::{\n-                    as_utf16_p\n-                };\n-                use rt::global_heap::malloc_raw;\n-\n-                #[nolink]\n-                extern {\n-                    fn rust_list_dir_wfd_size() -> libc::size_t;\n-                    fn rust_list_dir_wfd_fp_buf(wfd: *libc::c_void) -> *u16;\n-                }\n-                let star = p.join(\"*\");\n-                do as_utf16_p(star.as_str().unwrap()) |path_ptr| {\n-                    let mut paths = ~[];\n-                    let wfd_ptr = malloc_raw(rust_list_dir_wfd_size() as uint);\n-                    let find_handle = FindFirstFileW(path_ptr, wfd_ptr as HANDLE);\n-                    if find_handle as libc::c_int != INVALID_HANDLE_VALUE {\n-                        let mut more_files = 1 as libc::c_int;\n-                        while more_files != 0 {\n-                            let fp_buf = rust_list_dir_wfd_fp_buf(wfd_ptr);\n-                            if fp_buf as uint == 0 {\n-                                fail!(\"os::list_dir() failure: got null ptr from wfd\");\n-                            }\n-                            else {\n-                                let fp_vec = vec::from_buf(\n-                                    fp_buf, wcslen(fp_buf) as uint);\n-                                let fp_str = str::from_utf16(fp_vec);\n-                                paths.push(Path::new(fp_str));\n-                            }\n-                            more_files = FindNextFileW(find_handle, wfd_ptr as HANDLE);\n-                        }\n-                        FindClose(find_handle);\n-                        free(wfd_ptr)\n-                    }\n-                    paths\n-                }\n-            }\n-            do get_list(p).move_iter().filter |path| {\n-                path.as_vec() != bytes!(\".\") && path.as_vec() != bytes!(\"..\")\n-            }.collect()\n-        }\n-    }\n+pub fn symlink(src: &CString, dst: &CString) -> IoResult<()> {\n+    return os_symlink(src, dst);\n \n-    /// Removes a directory at the specified path, after removing\n-    /// all its contents. Use carefully!\n-    pub fn remove_dir_recursive(p: &Path) -> bool {\n-        let mut error_happened = false;\n-        do walk_dir(p) |inner| {\n-            if !error_happened {\n-                if path_is_dir(inner) {\n-                    if !remove_dir_recursive(inner) {\n-                        error_happened = true;\n-                    }\n-                }\n-                else {\n-                    if !remove_file(inner) {\n-                        error_happened = true;\n-                    }\n-                }\n+    #[cfg(windows)]\n+    fn os_symlink(src: &CString, dst: &CString) -> IoResult<()> {\n+        super::mkerr_winbool(do as_utf16_p(src.as_str().unwrap()) |src| {\n+            do as_utf16_p(dst.as_str().unwrap()) |dst| {\n+                unsafe { libc::CreateSymbolicLinkW(dst, src, 0) }\n             }\n-            true\n-        };\n-        // Directory should now be empty\n-        !error_happened && remove_dir(p)\n+        })\n     }\n \n-    /// Removes a directory at the specified path\n-    pub fn remove_dir(p: &Path) -> bool {\n-       return rmdir(p);\n+    #[cfg(unix)]\n+    fn os_symlink(src: &CString, dst: &CString) -> IoResult<()> {\n+        super::mkerr_libc(unsafe {\n+            libc::symlink(src.with_ref(|p| p), dst.with_ref(|p| p))\n+        })\n+    }\n+}\n \n-        #[cfg(windows)]\n-        fn rmdir(p: &Path) -> bool {\n-            unsafe {\n-                use os::win32::as_utf16_p;\n-                return do as_utf16_p(p.as_str().unwrap()) |buf| {\n-                    libc::RemoveDirectoryW(buf) != (0 as libc::BOOL)\n-                };\n-            }\n-        }\n+pub fn link(src: &CString, dst: &CString) -> IoResult<()> {\n+    return os_link(src, dst);\n \n-        #[cfg(unix)]\n-        fn rmdir(p: &Path) -> bool {\n-            do p.with_c_str |buf| {\n-                unsafe {\n-                    libc::rmdir(buf) == (0 as c_int)\n-                }\n+    #[cfg(windows)]\n+    fn os_link(src: &CString, dst: &CString) -> IoResult<()> {\n+        super::mkerr_winbool(do as_utf16_p(src.as_str().unwrap()) |src| {\n+            do as_utf16_p(dst.as_str().unwrap()) |dst| {\n+                unsafe { libc::CreateHardLinkW(dst, src, ptr::mut_null()) }\n             }\n-        }\n+        })\n     }\n \n-    /// Deletes an existing file\n-    pub fn remove_file(p: &Path) -> bool {\n-        return unlink(p);\n+    #[cfg(unix)]\n+    fn os_link(src: &CString, dst: &CString) -> IoResult<()> {\n+        super::mkerr_libc(unsafe {\n+            libc::link(src.with_ref(|p| p), dst.with_ref(|p| p))\n+        })\n+    }\n+}\n \n-        #[cfg(windows)]\n-        fn unlink(p: &Path) -> bool {\n-            unsafe {\n-                use os::win32::as_utf16_p;\n-                return do as_utf16_p(p.as_str().unwrap()) |buf| {\n-                    libc::DeleteFileW(buf) != (0 as libc::BOOL)\n-                };\n-            }\n-        }\n-\n-        #[cfg(unix)]\n-        fn unlink(p: &Path) -> bool {\n-            unsafe {\n-                do p.with_c_str |buf| {\n-                    libc::unlink(buf) == (0 as c_int)\n-                }\n-            }\n+#[cfg(windows)]\n+fn mkstat(stat: &libc::stat, path: &CString) -> io::FileStat {\n+    let path = unsafe { CString::new(path.with_ref(|p| p), false) };\n+\n+    // FileStat times are in milliseconds\n+    fn mktime(secs: u64, nsecs: u64) -> u64 { secs * 1000 + nsecs / 1000000 }\n+\n+    let kind = match (stat.st_mode as c_int) & libc::S_IFMT {\n+        libc::S_IFREG => io::TypeFile,\n+        libc::S_IFDIR => io::TypeDirectory,\n+        libc::S_IFIFO => io::TypeNamedPipe,\n+        libc::S_IFBLK => io::TypeBlockSpecial,\n+        libc::S_IFLNK => io::TypeSymlink,\n+        _ => io::TypeUnknown,\n+    };\n+\n+    io::FileStat {\n+        path: Path::new(path),\n+        size: stat.st_size as u64,\n+        kind: kind,\n+        perm: (stat.st_mode) as io::FilePermission & io::AllPermissions,\n+        created: stat.st_ctime as u64,\n+        modified: stat.st_mtime as u64,\n+        accessed: stat.st_atime as u64,\n+        unstable: io::UnstableFileStat {\n+            device: stat.st_dev as u64,\n+            inode: stat.st_ino as u64,\n+            rdev: stat.st_rdev as u64,\n+            nlink: stat.st_nlink as u64,\n+            uid: stat.st_uid as u64,\n+            gid: stat.st_gid as u64,\n+            blksize: 0,\n+            blocks: 0,\n+            flags: 0,\n+            gen: 0,\n         }\n     }\n+}\n \n-    /// Renames an existing file or directory\n-    pub fn rename_file(old: &Path, new: &Path) -> bool {\n-        unsafe {\n-           do old.with_c_str |old_buf| {\n-                do new.with_c_str |new_buf| {\n-                    libc::rename(old_buf, new_buf) == (0 as c_int)\n-                }\n-           }\n+#[cfg(unix)]\n+fn mkstat(stat: &libc::stat, path: &CString) -> io::FileStat {\n+    let path = unsafe { CString::new(path.with_ref(|p| p), false) };\n+\n+    // FileStat times are in milliseconds\n+    fn mktime(secs: u64, nsecs: u64) -> u64 { secs * 1000 + nsecs / 1000000 }\n+\n+    let kind = match (stat.st_mode as c_int) & libc::S_IFMT {\n+        libc::S_IFREG => io::TypeFile,\n+        libc::S_IFDIR => io::TypeDirectory,\n+        libc::S_IFIFO => io::TypeNamedPipe,\n+        libc::S_IFBLK => io::TypeBlockSpecial,\n+        libc::S_IFLNK => io::TypeSymlink,\n+        _ => io::TypeUnknown,\n+    };\n+\n+    #[cfg(not(target_os = \"linux\"), not(target_os = \"android\"))]\n+    fn flags(stat: &libc::stat) -> u64 { stat.st_flags as u64 }\n+    #[cfg(target_os = \"linux\")] #[cfg(target_os = \"android\")]\n+    fn flags(_stat: &libc::stat) -> u64 { 0 }\n+\n+    #[cfg(not(target_os = \"linux\"), not(target_os = \"android\"))]\n+    fn gen(stat: &libc::stat) -> u64 { stat.st_gen as u64 }\n+    #[cfg(target_os = \"linux\")] #[cfg(target_os = \"android\")]\n+    fn gen(_stat: &libc::stat) -> u64 { 0 }\n+\n+    io::FileStat {\n+        path: Path::new(path),\n+        size: stat.st_size as u64,\n+        kind: kind,\n+        perm: (stat.st_mode) as io::FilePermission & io::AllPermissions,\n+        created: mktime(stat.st_ctime as u64, stat.st_ctime_nsec as u64),\n+        modified: mktime(stat.st_mtime as u64, stat.st_mtime_nsec as u64),\n+        accessed: mktime(stat.st_atime as u64, stat.st_atime_nsec as u64),\n+        unstable: io::UnstableFileStat {\n+            device: stat.st_dev as u64,\n+            inode: stat.st_ino as u64,\n+            rdev: stat.st_rdev as u64,\n+            nlink: stat.st_nlink as u64,\n+            uid: stat.st_uid as u64,\n+            gid: stat.st_gid as u64,\n+            blksize: stat.st_blksize as u64,\n+            blocks: stat.st_blocks as u64,\n+            flags: flags(stat),\n+            gen: gen(stat),\n         }\n     }\n+}\n \n-    /// Copies a file from one location to another\n-    pub fn copy_file(from: &Path, to: &Path) -> bool {\n-        return do_copy_file(from, to);\n+pub fn stat(p: &CString) -> IoResult<io::FileStat> {\n+    return os_stat(p);\n \n-        #[cfg(windows)]\n-        fn do_copy_file(from: &Path, to: &Path) -> bool {\n-            unsafe {\n-                use os::win32::as_utf16_p;\n-                return do as_utf16_p(from.as_str().unwrap()) |fromp| {\n-                    do as_utf16_p(to.as_str().unwrap()) |top| {\n-                        libc::CopyFileW(fromp, top, (0 as libc::BOOL)) !=\n-                            (0 as libc::BOOL)\n-                    }\n-                }\n+    #[cfg(windows)]\n+    fn os_stat(p: &CString) -> IoResult<io::FileStat> {\n+        let mut stat: libc::stat = unsafe { intrinsics::uninit() };\n+        do as_utf16_p(p.as_str().unwrap()) |up| {\n+            match unsafe { libc::wstat(up, &mut stat) } {\n+                0 => Ok(mkstat(&stat, p)),\n+                _ => Err(super::last_error()),\n             }\n         }\n+    }\n \n-        #[cfg(unix)]\n-        fn do_copy_file(from: &Path, to: &Path) -> bool {\n-            unsafe {\n-                let istream = do from.with_c_str |fromp| {\n-                    do \"rb\".with_c_str |modebuf| {\n-                        libc::fopen(fromp, modebuf)\n-                    }\n-                };\n-                if istream as uint == 0u {\n-                    return false;\n-                }\n-                // Preserve permissions\n-                let from_mode = from.stat().perm;\n-\n-                let ostream = do to.with_c_str |top| {\n-                    do \"w+b\".with_c_str |modebuf| {\n-                        libc::fopen(top, modebuf)\n-                    }\n-                };\n-                if ostream as uint == 0u {\n-                    fclose(istream);\n-                    return false;\n-                }\n-                let bufsize = 8192u;\n-                let mut buf = vec::with_capacity::<u8>(bufsize);\n-                let mut done = false;\n-                let mut ok = true;\n-                while !done {\n-                    do buf.as_mut_buf |b, _sz| {\n-                      let nread = libc::fread(b as *mut c_void, 1u as size_t,\n-                                              bufsize as size_t,\n-                                              istream);\n-                      if nread > 0 as size_t {\n-                          if libc::fwrite(b as *c_void, 1u as size_t, nread,\n-                                          ostream) != nread {\n-                              ok = false;\n-                              done = true;\n-                          }\n-                      } else {\n-                          done = true;\n-                      }\n-                  }\n-                }\n-                fclose(istream);\n-                fclose(ostream);\n-\n-                // Give the new file the old file's permissions\n-                if do to.with_c_str |to_buf| {\n-                    libc::chmod(to_buf, from_mode as libc::mode_t)\n-                } != 0 {\n-                    return false; // should be a condition...\n-                }\n-                return ok;\n-            }\n+    #[cfg(unix)]\n+    fn os_stat(p: &CString) -> IoResult<io::FileStat> {\n+        let mut stat: libc::stat = unsafe { intrinsics::uninit() };\n+        match unsafe { libc::stat(p.with_ref(|p| p), &mut stat) } {\n+            0 => Ok(mkstat(&stat, p)),\n+            _ => Err(super::last_error()),\n         }\n     }\n+}\n \n-    #[test]\n-    fn tmpdir() {\n-        let p = os::tmpdir();\n-        let s = p.as_str();\n-        assert!(s.is_some() && s.unwrap() != \".\");\n-    }\n+pub fn lstat(p: &CString) -> IoResult<io::FileStat> {\n+    return os_lstat(p);\n \n-    // Issue #712\n-    #[test]\n-    fn test_list_dir_no_invalid_memory_access() {\n-        list_dir(&Path::new(\".\"));\n+    // XXX: windows implementation is missing\n+    #[cfg(windows)]\n+    fn os_lstat(_p: &CString) -> IoResult<io::FileStat> {\n+        Err(super::unimpl())\n     }\n \n-    #[test]\n-    fn test_list_dir() {\n-        let dirs = list_dir(&Path::new(\".\"));\n-        // Just assuming that we've got some contents in the current directory\n-        assert!(dirs.len() > 0u);\n-\n-        for dir in dirs.iter() {\n-            debug!(\"{:?}\", (*dir).clone());\n+    #[cfg(unix)]\n+    fn os_lstat(p: &CString) -> IoResult<io::FileStat> {\n+        let mut stat: libc::stat = unsafe { intrinsics::uninit() };\n+        match unsafe { libc::lstat(p.with_ref(|p| p), &mut stat) } {\n+            0 => Ok(mkstat(&stat, p)),\n+            _ => Err(super::last_error()),\n         }\n     }\n+}\n+\n+pub fn utime(p: &CString, atime: u64, mtime: u64) -> IoResult<()> {\n+    return super::mkerr_libc(os_utime(p, atime, mtime));\n \n-    #[test]\n-    #[cfg(not(windows))]\n-    fn test_list_dir_root() {\n-        let dirs = list_dir(&Path::new(\"/\"));\n-        assert!(dirs.len() > 1);\n-    }\n-    #[test]\n     #[cfg(windows)]\n-    fn test_list_dir_root() {\n-        let dirs = list_dir(&Path::new(\"C:\\\\\"));\n-        assert!(dirs.len() > 1);\n+    fn os_utime(p: &CString, atime: u64, mtime: u64) -> c_int {\n+        let buf = libc::utimbuf {\n+            actime: (atime / 1000) as libc::time64_t,\n+            modtime: (mtime / 1000) as libc::time64_t,\n+        };\n+        unsafe {\n+            do as_utf16_p(p.as_str().unwrap()) |p| {\n+                libc::wutime(p, &buf)\n+            }\n+        }\n     }\n \n-    #[test]\n-    fn test_path_is_dir() {\n-        use io::fs::{mkdir_recursive};\n-        use io::{File, UserRWX};\n-\n-        assert!((path_is_dir(&Path::new(\".\"))));\n-        assert!((!path_is_dir(&Path::new(\"test/stdtest/fs.rs\"))));\n-\n-        let mut dirpath = os::tmpdir();\n-        dirpath.push(format!(\"rust-test-{}/test-\\uac00\\u4e00\\u30fc\\u4f60\\u597d\",\n-            rand::random::<u32>())); // \uac00\u4e00\u30fc\u4f60\u597d\n-        debug!(\"path_is_dir dirpath: {}\", dirpath.display());\n+    #[cfg(unix)]\n+    fn os_utime(p: &CString, atime: u64, mtime: u64) -> c_int {\n+        let buf = libc::utimbuf {\n+            actime: (atime / 1000) as libc::time_t,\n+            modtime: (mtime / 1000) as libc::time_t,\n+        };\n+        unsafe { libc::utime(p.with_ref(|p| p), &buf) }\n+    }\n+}\n \n-        mkdir_recursive(&dirpath, UserRWX);\n+#[cfg(test)]\n+mod tests {\n+    use io::native::file::{CFile, FileDesc};\n+    use io::fs;\n+    use io;\n+    use libc;\n+    use os;\n+    use path::Path;\n+    use rand;\n+    use result::Ok;\n+    use rt::rtio::RtioFileStream;\n \n-        assert!((path_is_dir(&dirpath)));\n+    fn tmpdir() -> Path {\n+        let ret = os::tmpdir().join(format!(\"rust-{}\", rand::random::<u32>()));\n+        fs::mkdir(&ret, io::UserRWX);\n+        ret\n+    }\n \n-        let mut filepath = dirpath;\n-        filepath.push(\"unicode-file-\\uac00\\u4e00\\u30fc\\u4f60\\u597d.rs\");\n-        debug!(\"path_is_dir filepath: {}\", filepath.display());\n+    #[ignore(cfg(target_os = \"freebsd\"))] // hmm, maybe pipes have a tiny buffer\n+    fn test_file_desc() {\n+        // Run this test with some pipes so we don't have to mess around with\n+        // opening or closing files.\n+        unsafe {\n+            let os::Pipe { input, out } = os::pipe();\n+            let mut reader = FileDesc::new(input, true);\n+            let mut writer = FileDesc::new(out, true);\n \n-        File::create(&filepath); // ignore return; touch only\n-        assert!((!path_is_dir(&filepath)));\n+            writer.inner_write(bytes!(\"test\"));\n+            let mut buf = [0u8, ..4];\n+            match reader.inner_read(buf) {\n+                Ok(4) => {\n+                    assert_eq!(buf[0], 't' as u8);\n+                    assert_eq!(buf[1], 'e' as u8);\n+                    assert_eq!(buf[2], 's' as u8);\n+                    assert_eq!(buf[3], 't' as u8);\n+                }\n+                r => fail!(\"invalid read: {:?}\", r)\n+            }\n \n-        assert!((!path_is_dir(&Path::new(\n-                     \"test/unicode-bogus-dir-\\uac00\\u4e00\\u30fc\\u4f60\\u597d\"))));\n+            assert!(writer.inner_read(buf).is_err());\n+            assert!(reader.inner_write(buf).is_err());\n+        }\n     }\n \n-    #[test]\n-    fn test_path_exists() {\n-        use io::fs::mkdir_recursive;\n-        use io::UserRWX;\n-\n-        assert!((path_exists(&Path::new(\".\"))));\n-        assert!((!path_exists(&Path::new(\n-                     \"test/nonexistent-bogus-path\"))));\n-\n-        let mut dirpath = os::tmpdir();\n-        dirpath.push(format!(\"rust-test-{}/test-\\uac01\\u4e01\\u30fc\\u518d\\u89c1\",\n-            rand::random::<u32>())); // \uac01\u4e01\u30fc\u518d\u89c1\n+    #[ignore(cfg(windows))] // apparently windows doesn't like tmpfile\n+    fn test_cfile() {\n+        unsafe {\n+            let f = libc::tmpfile();\n+            assert!(!f.is_null());\n+            let mut file = CFile::new(f);\n \n-        mkdir_recursive(&dirpath, UserRWX);\n-        assert!((path_exists(&dirpath)));\n-        assert!((!path_exists(&Path::new(\n-                     \"test/unicode-bogus-path-\\uac01\\u4e01\\u30fc\\u518d\\u89c1\"))));\n+            file.write(bytes!(\"test\"));\n+            let mut buf = [0u8, ..4];\n+            file.seek(0, io::SeekSet);\n+            match file.read(buf) {\n+                Ok(4) => {\n+                    assert_eq!(buf[0], 't' as u8);\n+                    assert_eq!(buf[1], 'e' as u8);\n+                    assert_eq!(buf[2], 's' as u8);\n+                    assert_eq!(buf[3], 't' as u8);\n+                }\n+                r => fail!(\"invalid read: {:?}\", r)\n+            }\n+        }\n     }\n }"}, {"sha": "cec0de00ec2b5f06cea114646be0279bbb22d66c", "filename": "src/libstd/io/native/mod.rs", "status": "modified", "additions": 56, "deletions": 34, "changes": 90, "blob_url": "https://github.com/rust-lang/rust/blob/68d5510292ed2f9714568285759ca9ef54d9b48c/src%2Flibstd%2Fio%2Fnative%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/68d5510292ed2f9714568285759ca9ef54d9b48c/src%2Flibstd%2Fio%2Fnative%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fnative%2Fmod.rs?ref=68d5510292ed2f9714568285759ca9ef54d9b48c", "patch": "@@ -90,6 +90,24 @@ fn last_error() -> IoError {\n     }\n }\n \n+// unix has nonzero values as errors\n+fn mkerr_libc(ret: libc::c_int) -> IoResult<()> {\n+    if ret != 0 {\n+        Err(last_error())\n+    } else {\n+        Ok(())\n+    }\n+}\n+\n+// windows has zero values as errors\n+fn mkerr_winbool(ret: libc::c_int) -> IoResult<()> {\n+    if ret == 0 {\n+        Err(last_error())\n+    } else {\n+        Ok(())\n+    }\n+}\n+\n /// Implementation of rt::rtio's IoFactory trait to generate handles to the\n /// native I/O functionality.\n pub struct IoFactory;\n@@ -125,51 +143,51 @@ impl rtio::IoFactory for IoFactory {\n         };\n         ~file::FileDesc::new(fd, close) as ~RtioFileStream\n     }\n-    fn fs_open(&mut self, _path: &CString, _fm: io::FileMode, _fa: io::FileAccess)\n+    fn fs_open(&mut self, path: &CString, fm: io::FileMode, fa: io::FileAccess)\n         -> IoResult<~RtioFileStream> {\n-        Err(unimpl())\n+        file::open(path, fm, fa).map(|fd| ~fd as ~RtioFileStream)\n     }\n-    fn fs_unlink(&mut self, _path: &CString) -> IoResult<()> {\n-        Err(unimpl())\n+    fn fs_unlink(&mut self, path: &CString) -> IoResult<()> {\n+        file::unlink(path)\n     }\n-    fn fs_stat(&mut self, _path: &CString) -> IoResult<io::FileStat> {\n-        Err(unimpl())\n+    fn fs_stat(&mut self, path: &CString) -> IoResult<io::FileStat> {\n+        file::stat(path)\n     }\n-    fn fs_mkdir(&mut self, _path: &CString,\n-                _mode: io::FilePermission) -> IoResult<()> {\n-        Err(unimpl())\n+    fn fs_mkdir(&mut self, path: &CString,\n+                mode: io::FilePermission) -> IoResult<()> {\n+        file::mkdir(path, mode)\n     }\n-    fn fs_chmod(&mut self, _path: &CString,\n-                _mode: io::FilePermission) -> IoResult<()> {\n-        Err(unimpl())\n+    fn fs_chmod(&mut self, path: &CString,\n+                mode: io::FilePermission) -> IoResult<()> {\n+        file::chmod(path, mode)\n     }\n-    fn fs_rmdir(&mut self, _path: &CString) -> IoResult<()> {\n-        Err(unimpl())\n+    fn fs_rmdir(&mut self, path: &CString) -> IoResult<()> {\n+        file::rmdir(path)\n     }\n-    fn fs_rename(&mut self, _path: &CString, _to: &CString) -> IoResult<()> {\n-        Err(unimpl())\n+    fn fs_rename(&mut self, path: &CString, to: &CString) -> IoResult<()> {\n+        file::rename(path, to)\n     }\n-    fn fs_readdir(&mut self, _path: &CString, _flags: c_int) -> IoResult<~[Path]> {\n-        Err(unimpl())\n+    fn fs_readdir(&mut self, path: &CString, _flags: c_int) -> IoResult<~[Path]> {\n+        file::readdir(path)\n     }\n-    fn fs_lstat(&mut self, _path: &CString) -> IoResult<io::FileStat> {\n-        Err(unimpl())\n+    fn fs_lstat(&mut self, path: &CString) -> IoResult<io::FileStat> {\n+        file::lstat(path)\n     }\n-    fn fs_chown(&mut self, _path: &CString, _uid: int, _gid: int) -> IoResult<()> {\n-        Err(unimpl())\n+    fn fs_chown(&mut self, path: &CString, uid: int, gid: int) -> IoResult<()> {\n+        file::chown(path, uid, gid)\n     }\n-    fn fs_readlink(&mut self, _path: &CString) -> IoResult<Path> {\n-        Err(unimpl())\n+    fn fs_readlink(&mut self, path: &CString) -> IoResult<Path> {\n+        file::readlink(path)\n     }\n-    fn fs_symlink(&mut self, _src: &CString, _dst: &CString) -> IoResult<()> {\n-        Err(unimpl())\n+    fn fs_symlink(&mut self, src: &CString, dst: &CString) -> IoResult<()> {\n+        file::symlink(src, dst)\n     }\n-    fn fs_link(&mut self, _src: &CString, _dst: &CString) -> IoResult<()> {\n-        Err(unimpl())\n+    fn fs_link(&mut self, src: &CString, dst: &CString) -> IoResult<()> {\n+        file::link(src, dst)\n     }\n-    fn fs_utime(&mut self, _src: &CString, _atime: u64,\n-                _mtime: u64) -> IoResult<()> {\n-        Err(unimpl())\n+    fn fs_utime(&mut self, src: &CString, atime: u64,\n+                mtime: u64) -> IoResult<()> {\n+        file::utime(src, atime, mtime)\n     }\n \n     // misc\n@@ -183,14 +201,18 @@ impl rtio::IoFactory for IoFactory {\n              io.move_iter().map(|p| p.map(|p| ~p as ~RtioPipe)).collect())\n         })\n     }\n-    fn pipe_open(&mut self, _fd: c_int) -> IoResult<~RtioPipe> {\n-        Err(unimpl())\n+    fn pipe_open(&mut self, fd: c_int) -> IoResult<~RtioPipe> {\n+        Ok(~file::FileDesc::new(fd, true) as ~RtioPipe)\n     }\n     fn tty_open(&mut self, fd: c_int, _readable: bool) -> IoResult<~RtioTTY> {\n         if unsafe { libc::isatty(fd) } != 0 {\n             Ok(~file::FileDesc::new(fd, true) as ~RtioTTY)\n         } else {\n-            Err(unimpl())\n+            Err(IoError {\n+                kind: io::MismatchedFileTypeForOperation,\n+                desc: \"file descriptor is not a TTY\",\n+                detail: None,\n+            })\n         }\n     }\n     fn signal(&mut self, _signal: Signum, _channel: SharedChan<Signum>)"}, {"sha": "49cac428cb23e19d01678f73a76a6d5aa13ae658", "filename": "src/libstd/io/stdio.rs", "status": "modified", "additions": 11, "deletions": 1, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/68d5510292ed2f9714568285759ca9ef54d9b48c/src%2Flibstd%2Fio%2Fstdio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/68d5510292ed2f9714568285759ca9ef54d9b48c/src%2Flibstd%2Fio%2Fstdio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fstdio.rs?ref=68d5510292ed2f9714568285759ca9ef54d9b48c", "patch": "@@ -316,12 +316,22 @@ impl Writer for StdWriter {\n #[cfg(test)]\n mod tests {\n     use super::*;\n+    use rt::test::run_in_newsched_task;\n \n     #[test]\n-    fn smoke() {\n+    fn smoke_uv() {\n         // Just make sure we can acquire handles\n         stdin();\n         stdout();\n         stderr();\n     }\n+\n+    #[test]\n+    fn smoke_native() {\n+        do run_in_newsched_task {\n+            stdin();\n+            stdout();\n+            stderr();\n+        }\n+    }\n }"}, {"sha": "b3528c5d3ab7f7f35e87e1daa17d4d178defcba6", "filename": "src/libstd/libc.rs", "status": "modified", "additions": 188, "deletions": 7, "changes": 195, "blob_url": "https://github.com/rust-lang/rust/blob/68d5510292ed2f9714568285759ca9ef54d9b48c/src%2Flibstd%2Flibc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/68d5510292ed2f9714568285759ca9ef54d9b48c/src%2Flibstd%2Flibc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Flibc.rs?ref=68d5510292ed2f9714568285759ca9ef54d9b48c", "patch": "@@ -329,6 +329,11 @@ pub mod types {\n                     __unused5: c_long,\n                 }\n \n+                pub struct utimbuf {\n+                    actime: time_t,\n+                    modtime: time_t,\n+                }\n+\n                 pub struct pthread_attr_t {\n                     __size: [u32, ..9]\n                 }\n@@ -365,6 +370,11 @@ pub mod types {\n                     st_ino: c_ulonglong\n                 }\n \n+                pub struct utimbuf {\n+                    actime: time_t,\n+                    modtime: time_t,\n+                }\n+\n                 pub struct pthread_attr_t {\n                     __size: [u32, ..9]\n                 }\n@@ -403,6 +413,11 @@ pub mod types {\n                     st_pad5: [c_long, ..14],\n                 }\n \n+                pub struct utimbuf {\n+                    actime: time_t,\n+                    modtime: time_t,\n+                }\n+\n                 pub struct pthread_attr_t {\n                     __size: [u32, ..9]\n                 }\n@@ -479,6 +494,11 @@ pub mod types {\n                     __unused: [c_long, ..3],\n                 }\n \n+                pub struct utimbuf {\n+                    actime: time_t,\n+                    modtime: time_t,\n+                }\n+\n                 pub struct pthread_attr_t {\n                     __size: [u64, ..7]\n                 }\n@@ -594,6 +614,11 @@ pub mod types {\n                     __unused: [uint8_t, ..2],\n                 }\n \n+                pub struct utimbuf {\n+                    actime: time_t,\n+                    modtime: time_t,\n+                }\n+\n                 pub type pthread_attr_t = *c_void;\n             }\n             pub mod posix08 {\n@@ -629,6 +654,12 @@ pub mod types {\n                     st_mtime: time64_t,\n                     st_ctime: time64_t,\n                 }\n+\n+                // note that this is called utimbuf64 in win32\n+                pub struct utimbuf {\n+                    actime: time64_t,\n+                    modtime: time64_t,\n+                }\n             }\n         }\n \n@@ -679,7 +710,7 @@ pub mod types {\n                 use libc::types::os::arch::c95::{c_char, c_int, c_uint, size_t};\n                 use libc::types::os::arch::c95::{c_long, c_ulong};\n                 use libc::types::os::arch::c95::{wchar_t};\n-                use libc::types::os::arch::c99::{c_ulonglong};\n+                use libc::types::os::arch::c99::{c_ulonglong, c_longlong};\n \n                 pub type BOOL = c_int;\n                 pub type BYTE = u8;\n@@ -692,8 +723,13 @@ pub mod types {\n                 pub type HANDLE = LPVOID;\n                 pub type HMODULE = c_uint;\n \n+                pub type LONG = c_long;\n+                pub type PLONG = *mut c_long;\n                 pub type LONG_PTR = c_long;\n \n+                pub type LARGE_INTEGER = c_longlong;\n+                pub type PLARGE_INTEGER = *mut c_longlong;\n+\n                 pub type LPCWSTR = *WCHAR;\n                 pub type LPCSTR = *CHAR;\n                 pub type LPCTSTR = *CHAR;\n@@ -795,6 +831,16 @@ pub mod types {\n                     Type: DWORD\n                 }\n                 pub type LPMEMORY_BASIC_INFORMATION = *mut MEMORY_BASIC_INFORMATION;\n+\n+                pub struct OVERLAPPED {\n+                    Internal: *c_ulong,\n+                    InternalHigh: *c_ulong,\n+                    Offset: DWORD,\n+                    OffsetHigh: DWORD,\n+                    hEvent: HANDLE,\n+                }\n+\n+                pub type LPOVERLAPPED = *mut OVERLAPPED;\n             }\n         }\n \n@@ -1065,6 +1111,11 @@ pub mod types {\n                     st_qspare: [int64_t, ..2],\n                 }\n \n+                pub struct utimbuf {\n+                    actime: time_t,\n+                    modtime: time_t,\n+                }\n+\n                 pub struct pthread_attr_t {\n                     __sig: c_long,\n                     __opaque: [c_char, ..36]\n@@ -1151,6 +1202,11 @@ pub mod types {\n                     st_qspare: [int64_t, ..2],\n                 }\n \n+                pub struct utimbuf {\n+                    actime: time_t,\n+                    modtime: time_t,\n+                }\n+\n                 pub struct pthread_attr_t {\n                     __sig: c_long,\n                     __opaque: [c_char, ..56]\n@@ -1337,6 +1393,72 @@ pub mod consts {\n             pub static PROCESSOR_ARCHITECTURE_IA64 : WORD = 6;\n             pub static PROCESSOR_ARCHITECTURE_AMD64 : WORD = 9;\n             pub static PROCESSOR_ARCHITECTURE_UNKNOWN : WORD = 0xffff;\n+\n+            pub static MOVEFILE_COPY_ALLOWED: DWORD = 2;\n+            pub static MOVEFILE_CREATE_HARDLINK: DWORD = 16;\n+            pub static MOVEFILE_DELAY_UNTIL_REBOOT: DWORD = 4;\n+            pub static MOVEFILE_FAIL_IF_NOT_TRACKABLE: DWORD = 32;\n+            pub static MOVEFILE_REPLACE_EXISTING: DWORD = 1;\n+            pub static MOVEFILE_WRITE_THROUGH: DWORD = 8;\n+\n+            pub static SYMBOLIC_LINK_FLAG_DIRECTORY: DWORD = 1;\n+\n+            pub static FILE_SHARE_DELETE: DWORD = 0x4;\n+            pub static FILE_SHARE_READ: DWORD = 0x1;\n+            pub static FILE_SHARE_WRITE: DWORD = 0x2;\n+\n+            pub static CREATE_ALWAYS: DWORD = 2;\n+            pub static CREATE_NEW: DWORD = 1;\n+            pub static OPEN_ALWAYS: DWORD = 4;\n+            pub static OPEN_EXISTING: DWORD = 3;\n+            pub static TRUNCATE_EXISTING: DWORD = 5;\n+\n+            pub static FILE_ATTRIBUTE_ARCHIVE: DWORD = 0x20;\n+            pub static FILE_ATTRIBUTE_COMPRESSED: DWORD = 0x800;\n+            pub static FILE_ATTRIBUTE_DEVICE: DWORD = 0x40;\n+            pub static FILE_ATTRIBUTE_DIRECTORY: DWORD = 0x10;\n+            pub static FILE_ATTRIBUTE_ENCRYPTED: DWORD = 0x4000;\n+            pub static FILE_ATTRIBUTE_HIDDEN: DWORD = 0x2;\n+            pub static FILE_ATTRIBUTE_INTEGRITY_STREAM: DWORD = 0x8000;\n+            pub static FILE_ATTRIBUTE_NORMAL: DWORD = 0x80;\n+            pub static FILE_ATTRIBUTE_NOT_CONTENT_INDEXED: DWORD = 0x2000;\n+            pub static FILE_ATTRIBUTE_NO_SCRUB_DATA: DWORD = 0x20000;\n+            pub static FILE_ATTRIBUTE_OFFLINE: DWORD = 0x1000;\n+            pub static FILE_ATTRIBUTE_READONLY: DWORD = 0x1;\n+            pub static FILE_ATTRIBUTE_REPARSE_POINT: DWORD = 0x400;\n+            pub static FILE_ATTRIBUTE_SPARSE_FILE: DWORD = 0x200;\n+            pub static FILE_ATTRIBUTE_SYSTEM: DWORD = 0x4;\n+            pub static FILE_ATTRIBUTE_TEMPORARY: DWORD = 0x100;\n+            pub static FILE_ATTRIBUTE_VIRTUAL: DWORD = 0x10000;\n+\n+            pub static FILE_FLAG_BACKUP_SEMANTICS: DWORD = 0x02000000;\n+            pub static FILE_FLAG_DELETE_ON_CLOSE: DWORD = 0x04000000;\n+            pub static FILE_FLAG_NO_BUFFERING: DWORD = 0x20000000;\n+            pub static FILE_FLAG_OPEN_NO_RECALL: DWORD = 0x00100000;\n+            pub static FILE_FLAG_OPEN_REPARSE_POINT: DWORD = 0x00200000;\n+            pub static FILE_FLAG_OVERLAPPED: DWORD = 0x40000000;\n+            pub static FILE_FLAG_POSIX_SEMANTICS: DWORD = 0x0100000;\n+            pub static FILE_FLAG_RANDOM_ACCESS: DWORD = 0x10000000;\n+            pub static FILE_FLAG_SESSION_AWARE: DWORD = 0x00800000;\n+            pub static FILE_FLAG_SEQUENTIAL_SCAN: DWORD = 0x08000000;\n+            pub static FILE_FLAG_WRITE_THROUGH: DWORD = 0x80000000;\n+\n+            pub static FILE_NAME_NORMALIZED: DWORD = 0x0;\n+            pub static FILE_NAME_OPENED: DWORD = 0x8;\n+\n+            pub static VOLUME_NAME_DOS: DWORD = 0x0;\n+            pub static VOLUME_NAME_GUID: DWORD = 0x1;\n+            pub static VOLUME_NAME_NONE: DWORD = 0x4;\n+            pub static VOLUME_NAME_NT: DWORD = 0x2;\n+\n+            pub static GENERIC_READ: DWORD = 0x80000000;\n+            pub static GENERIC_WRITE: DWORD = 0x40000000;\n+            pub static GENERIC_EXECUTE: DWORD = 0x20000000;\n+            pub static GENERIC_ALL: DWORD = 0x10000000;\n+\n+            pub static FILE_BEGIN: DWORD = 0;\n+            pub static FILE_CURRENT: DWORD = 1;\n+            pub static FILE_END: DWORD = 2;\n         }\n         pub mod sysconf {\n         }\n@@ -2873,18 +2995,26 @@ pub mod funcs {\n     pub mod posix88 {\n         #[nolink]\n         pub mod stat_ {\n-            use libc::types::os::common::posix01::stat;\n-            use libc::types::os::arch::c95::{c_int, c_char};\n+            use libc::types::os::common::posix01::{stat, utimbuf};\n+            use libc::types::os::arch::c95::{c_int, c_char, wchar_t};\n \n             extern {\n                 #[link_name = \"_chmod\"]\n                 pub fn chmod(path: *c_char, mode: c_int) -> c_int;\n+                #[link_name = \"_wchmod\"]\n+                pub fn wchmod(path: *wchar_t, mode: c_int) -> c_int;\n                 #[link_name = \"_mkdir\"]\n                 pub fn mkdir(path: *c_char) -> c_int;\n+                #[link_name = \"_wrmdir\"]\n+                pub fn wrmdir(path: *wchar_t) -> c_int;\n                 #[link_name = \"_fstat64\"]\n                 pub fn fstat(fildes: c_int, buf: *mut stat) -> c_int;\n                 #[link_name = \"_stat64\"]\n                 pub fn stat(path: *c_char, buf: *mut stat) -> c_int;\n+                #[link_name = \"_wstat64\"]\n+                pub fn wstat(path: *wchar_t, buf: *mut stat) -> c_int;\n+                #[link_name = \"_wutime64\"]\n+                pub fn wutime(file: *wchar_t, buf: *utimbuf) -> c_int;\n             }\n         }\n \n@@ -2907,11 +3037,14 @@ pub mod funcs {\n \n         #[nolink]\n         pub mod fcntl {\n-            use libc::types::os::arch::c95::{c_int, c_char};\n+            use libc::types::os::arch::c95::{c_int, c_char, wchar_t};\n             extern {\n                 #[link_name = \"_open\"]\n                 pub fn open(path: *c_char, oflag: c_int, mode: c_int)\n                             -> c_int;\n+                #[link_name = \"_wopen\"]\n+                pub fn wopen(path: *wchar_t, oflag: c_int, mode: c_int)\n+                            -> c_int;\n                 #[link_name = \"_creat\"]\n                 pub fn creat(path: *c_char, mode: c_int) -> c_int;\n             }\n@@ -3079,9 +3212,12 @@ pub mod funcs {\n             use libc::types::common::c95::c_void;\n             use libc::types::os::arch::c95::{c_char, c_int, c_long, c_uint};\n             use libc::types::os::arch::c95::{size_t};\n+            use libc::types::os::arch::posix01::utimbuf;\n             use libc::types::os::arch::posix88::{gid_t, off_t, pid_t};\n             use libc::types::os::arch::posix88::{ssize_t, uid_t};\n \n+            pub static _PC_NAME_MAX: c_int = 4;\n+\n             extern {\n                 pub fn access(path: *c_char, amode: c_int) -> c_int;\n                 pub fn alarm(seconds: c_uint) -> c_uint;\n@@ -3130,6 +3266,11 @@ pub mod funcs {\n                 pub fn unlink(c: *c_char) -> c_int;\n                 pub fn write(fd: c_int, buf: *c_void, count: size_t)\n                              -> ssize_t;\n+                pub fn pread(fd: c_int, buf: *c_void, count: size_t,\n+                             offset: off_t) -> ssize_t;\n+                pub fn pwrite(fd: c_int, buf: *c_void, count: size_t,\n+                              offset: off_t) -> ssize_t;\n+                pub fn utime(file: *c_char, buf: *utimbuf) -> c_int;\n             }\n         }\n \n@@ -3201,7 +3342,7 @@ pub mod funcs {\n         #[nolink]\n         pub mod unistd {\n             use libc::types::os::arch::c95::{c_char, c_int, size_t};\n-            use libc::types::os::arch::posix88::{ssize_t};\n+            use libc::types::os::arch::posix88::{ssize_t, off_t};\n \n             extern {\n                 pub fn readlink(path: *c_char,\n@@ -3221,6 +3362,8 @@ pub mod funcs {\n                 pub fn putenv(string: *c_char) -> c_int;\n \n                 pub fn symlink(path1: *c_char, path2: *c_char) -> c_int;\n+\n+                pub fn ftruncate(fd: c_int, length: off_t) -> c_int;\n             }\n         }\n \n@@ -3374,12 +3517,13 @@ pub mod funcs {\n             use libc::types::os::arch::extra::{BOOL, DWORD, SIZE_T, HMODULE};\n             use libc::types::os::arch::extra::{LPCWSTR, LPWSTR, LPCTSTR,\n                                                LPTSTR, LPTCH, LPDWORD, LPVOID,\n-                                               LPCVOID};\n+                                               LPCVOID, LPOVERLAPPED};\n             use libc::types::os::arch::extra::{LPSECURITY_ATTRIBUTES, LPSTARTUPINFO,\n                                                LPPROCESS_INFORMATION,\n                                                LPMEMORY_BASIC_INFORMATION,\n                                                LPSYSTEM_INFO};\n-            use libc::types::os::arch::extra::{HANDLE, LPHANDLE};\n+            use libc::types::os::arch::extra::{HANDLE, LPHANDLE, LARGE_INTEGER,\n+                                               PLARGE_INTEGER};\n \n             extern \"system\" {\n                 pub fn GetEnvironmentVariableW(n: LPCWSTR,\n@@ -3486,6 +3630,43 @@ pub mod funcs {\n                                      dwNumberOfBytesToMap: SIZE_T)\n                                      -> LPVOID;\n                 pub fn UnmapViewOfFile(lpBaseAddress: LPCVOID) -> BOOL;\n+                pub fn MoveFileExW(lpExistingFileName: LPCWSTR,\n+                                   lpNewFileName: LPCWSTR,\n+                                   dwFlags: DWORD) -> BOOL;\n+                pub fn CreateSymbolicLinkW(lpSymlinkFileName: LPCWSTR,\n+                                           lpTargetFileName: LPCWSTR,\n+                                           dwFlags: DWORD) -> BOOL;\n+                pub fn CreateHardLinkW(lpSymlinkFileName: LPCWSTR,\n+                                       lpTargetFileName: LPCWSTR,\n+                                       lpSecurityAttributes: LPSECURITY_ATTRIBUTES)\n+                                        -> BOOL;\n+                pub fn FlushFileBuffers(hFile: HANDLE) -> BOOL;\n+                pub fn CreateFileW(lpFileName: LPCWSTR,\n+                                   dwDesiredAccess: DWORD,\n+                                   dwShareMode: DWORD,\n+                                   lpSecurityAttributes: LPSECURITY_ATTRIBUTES,\n+                                   dwCreationDisposition: DWORD,\n+                                   dwFlagsAndAttributes: DWORD,\n+                                   hTemplateFile: HANDLE) -> HANDLE;\n+                pub fn GetFinalPathNameByHandleW(hFile: HANDLE,\n+                                                 lpszFilePath: LPCWSTR,\n+                                                 cchFilePath: DWORD,\n+                                                 dwFlags: DWORD) -> DWORD;\n+                pub fn ReadFile(hFile: HANDLE,\n+                                lpBuffer: LPVOID,\n+                                nNumberOfBytesToRead: DWORD,\n+                                lpNumberOfBytesRead: LPDWORD,\n+                                lpOverlapped: LPOVERLAPPED) -> BOOL;\n+                pub fn WriteFile(hFile: HANDLE,\n+                                 lpBuffer: LPVOID,\n+                                 nNumberOfBytesToRead: DWORD,\n+                                 lpNumberOfBytesRead: LPDWORD,\n+                                 lpOverlapped: LPOVERLAPPED) -> BOOL;\n+                pub fn SetFilePointerEx(hFile: HANDLE,\n+                                        liDistanceToMove: LARGE_INTEGER,\n+                                        lpNewFilePointer: PLARGE_INTEGER,\n+                                        dwMoveMethod: DWORD) -> BOOL;\n+                pub fn SetEndOfFile(hFile: HANDLE) -> BOOL;\n             }\n         }\n "}, {"sha": "c50bdc7c2c68c6da1604a66b3bf0fc5c0b2d0b4d", "filename": "src/rt/rust_builtin.c", "status": "modified", "additions": 0, "deletions": 56, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/68d5510292ed2f9714568285759ca9ef54d9b48c/src%2Frt%2Frust_builtin.c", "raw_url": "https://github.com/rust-lang/rust/raw/68d5510292ed2f9714568285759ca9ef54d9b48c/src%2Frt%2Frust_builtin.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_builtin.c?ref=68d5510292ed2f9714568285759ca9ef54d9b48c", "patch": "@@ -110,62 +110,6 @@ rust_list_dir_wfd_fp_buf(void* wfd) {\n }\n #endif\n \n-int\n-rust_path_is_dir(const char *path) {\n-    struct stat buf;\n-    if (stat(path, &buf)) {\n-        return 0;\n-    }\n-    return S_ISDIR(buf.st_mode);\n-}\n-\n-int\n-#if defined(__WIN32__)\n-rust_path_is_dir_u16(const wchar_t *path) {\n-    struct _stat buf;\n-    // Don't use GetFileAttributesW, it cannot get attributes of\n-    // some system files (e.g. pagefile.sys).\n-    if (_wstat(path, &buf)) {\n-        return 0;\n-    }\n-    return S_ISDIR(buf.st_mode);\n-}\n-#else\n-rust_path_is_dir_u16(const void *path) {\n-    // Wide version of function is only used on Windows.\n-    return 0;\n-}\n-#endif\n-\n-int\n-rust_path_exists(const char *path) {\n-    struct stat buf;\n-    if (stat(path, &buf)) {\n-        return 0;\n-    }\n-    return 1;\n-}\n-\n-int\n-#if defined(__WIN32__)\n-rust_path_exists_u16(const wchar_t *path) {\n-    struct _stat buf;\n-    if (_wstat(path, &buf)) {\n-        return 0;\n-    }\n-    return 1;\n-}\n-#else\n-rust_path_exists_u16(const void *path) {\n-    // Wide version of function is only used on Windows.\n-    return 0;\n-}\n-#endif\n-\n-FILE* rust_get_stdin() {return stdin;}\n-FILE* rust_get_stdout() {return stdout;}\n-FILE* rust_get_stderr() {return stderr;}\n-\n #if defined(__WIN32__)\n void\n rust_get_time(int64_t *sec, int32_t *nsec) {"}, {"sha": "2a3e687ee55551835127e4a11ccc795cf26b9614", "filename": "src/rt/rustrt.def.in", "status": "modified", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/68d5510292ed2f9714568285759ca9ef54d9b48c/src%2Frt%2Frustrt.def.in", "raw_url": "https://github.com/rust-lang/rust/raw/68d5510292ed2f9714568285759ca9ef54d9b48c/src%2Frt%2Frustrt.def.in", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frustrt.def.in?ref=68d5510292ed2f9714568285759ca9ef54d9b48c", "patch": "@@ -9,13 +9,6 @@ rust_localtime\n rust_timegm\n rust_mktime\n rust_precise_time_ns\n-rust_path_is_dir\n-rust_path_is_dir_u16\n-rust_path_exists\n-rust_path_exists_u16\n-rust_get_stdin\n-rust_get_stdout\n-rust_get_stderr\n rust_list_dir_val\n rust_list_dir_wfd_size\n rust_list_dir_wfd_fp_buf"}, {"sha": "6b0f328629eb17e4abde23d20304ef8be1cff875", "filename": "src/test/run-pass/conditional-compile.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/68d5510292ed2f9714568285759ca9ef54d9b48c/src%2Ftest%2Frun-pass%2Fconditional-compile.rs", "raw_url": "https://github.com/rust-lang/rust/raw/68d5510292ed2f9714568285759ca9ef54d9b48c/src%2Ftest%2Frun-pass%2Fconditional-compile.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fconditional-compile.rs?ref=68d5510292ed2f9714568285759ca9ef54d9b48c", "patch": "@@ -109,8 +109,8 @@ mod test_foreign_items {\n     pub mod rustrt {\n         extern {\n             #[cfg(bogus)]\n-            pub fn rust_get_stdin() -> ~str;\n-            pub fn rust_get_stdin() -> ~str;\n+            pub fn write() -> ~str;\n+            pub fn write() -> ~str;\n         }\n     }\n }"}]}