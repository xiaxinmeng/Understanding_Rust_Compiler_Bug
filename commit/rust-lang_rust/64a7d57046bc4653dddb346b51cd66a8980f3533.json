{"sha": "64a7d57046bc4653dddb346b51cd66a8980f3533", "node_id": "C_kwDOAAsO6NoAKDY0YTdkNTcwNDZiYzQ2NTNkZGRiMzQ2YjUxY2Q2NmE4OTgwZjM1MzM", "commit": {"author": {"name": "Nika Layzell", "email": "nika@thelayzells.com", "date": "2022-06-28T00:03:56Z"}, "committer": {"name": "Nika Layzell", "email": "nika@thelayzells.com", "date": "2022-06-28T13:54:29Z"}, "message": "review changes\n\nlonger names for RPC generics and reduced dependency on macros in the server.", "tree": {"sha": "99e98144d5fc04f147314b36735174dd910dd3a2", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/99e98144d5fc04f147314b36735174dd910dd3a2"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/64a7d57046bc4653dddb346b51cd66a8980f3533", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/64a7d57046bc4653dddb346b51cd66a8980f3533", "html_url": "https://github.com/rust-lang/rust/commit/64a7d57046bc4653dddb346b51cd66a8980f3533", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/64a7d57046bc4653dddb346b51cd66a8980f3533/comments", "author": {"login": "mystor", "id": 1261662, "node_id": "MDQ6VXNlcjEyNjE2NjI=", "avatar_url": "https://avatars.githubusercontent.com/u/1261662?v=4", "gravatar_id": "", "url": "https://api.github.com/users/mystor", "html_url": "https://github.com/mystor", "followers_url": "https://api.github.com/users/mystor/followers", "following_url": "https://api.github.com/users/mystor/following{/other_user}", "gists_url": "https://api.github.com/users/mystor/gists{/gist_id}", "starred_url": "https://api.github.com/users/mystor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/mystor/subscriptions", "organizations_url": "https://api.github.com/users/mystor/orgs", "repos_url": "https://api.github.com/users/mystor/repos", "events_url": "https://api.github.com/users/mystor/events{/privacy}", "received_events_url": "https://api.github.com/users/mystor/received_events", "type": "User", "site_admin": false}, "committer": {"login": "mystor", "id": 1261662, "node_id": "MDQ6VXNlcjEyNjE2NjI=", "avatar_url": "https://avatars.githubusercontent.com/u/1261662?v=4", "gravatar_id": "", "url": "https://api.github.com/users/mystor", "html_url": "https://github.com/mystor", "followers_url": "https://api.github.com/users/mystor/followers", "following_url": "https://api.github.com/users/mystor/following{/other_user}", "gists_url": "https://api.github.com/users/mystor/gists{/gist_id}", "starred_url": "https://api.github.com/users/mystor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/mystor/subscriptions", "organizations_url": "https://api.github.com/users/mystor/orgs", "repos_url": "https://api.github.com/users/mystor/repos", "events_url": "https://api.github.com/users/mystor/events{/privacy}", "received_events_url": "https://api.github.com/users/mystor/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f28dfdf1c777ff83660cec0b432acabde1a2f7a4", "url": "https://api.github.com/repos/rust-lang/rust/commits/f28dfdf1c777ff83660cec0b432acabde1a2f7a4", "html_url": "https://github.com/rust-lang/rust/commit/f28dfdf1c777ff83660cec0b432acabde1a2f7a4"}], "stats": {"total": 260, "additions": 128, "deletions": 132}, "files": [{"sha": "0e909e2f98270f9635832e5f67f821cfe769c52a", "filename": "compiler/rustc_expand/src/proc_macro_server.rs", "status": "modified", "additions": 95, "deletions": 104, "changes": 199, "blob_url": "https://github.com/rust-lang/rust/blob/64a7d57046bc4653dddb346b51cd66a8980f3533/compiler%2Frustc_expand%2Fsrc%2Fproc_macro_server.rs", "raw_url": "https://github.com/rust-lang/rust/raw/64a7d57046bc4653dddb346b51cd66a8980f3533/compiler%2Frustc_expand%2Fsrc%2Fproc_macro_server.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Fproc_macro_server.rs?ref=64a7d57046bc4653dddb346b51cd66a8980f3533", "patch": "@@ -55,8 +55,10 @@ impl FromInternal<(TokenStream, &mut Rustc<'_, '_>)>\n     fn from_internal((stream, rustc): (TokenStream, &mut Rustc<'_, '_>)) -> Self {\n         use rustc_ast::token::*;\n \n+        // Estimate the capacity as `stream.len()` rounded up to the next power\n+        // of two to limit the number of required reallocations.\n+        let mut trees = Vec::with_capacity(stream.len().next_power_of_two());\n         let mut cursor = stream.into_trees();\n-        let mut trees = Vec::new();\n \n         while let Some((tree, spacing)) = cursor.next_with_spacing() {\n             let joint = spacing == Joint;\n@@ -77,105 +79,88 @@ impl FromInternal<(TokenStream, &mut Rustc<'_, '_>)>\n                 tokenstream::TokenTree::Token(token) => token,\n             };\n \n-            macro_rules! tt {\n-                ($ty:ident { $($field:ident $(: $value:expr)*),+ $(,)? }) => (\n-                    trees.push(TokenTree::$ty(self::$ty {\n-                        $($field $(: $value)*,)+\n-                        span,\n-                    }))\n-                );\n-                ($ty:ident::$method:ident($($value:expr),*)) => (\n-                    trees.push(TokenTree::$ty(self::$ty::$method($($value,)* span)))\n-                );\n-            }\n-            macro_rules! op {\n-                ($a:expr) => {{\n-                    tt!(Punct { ch: $a, joint });\n-                }};\n-                ($a:expr, $b:expr) => {{\n-                    tt!(Punct { ch: $a, joint: true });\n-                    tt!(Punct { ch: $b, joint });\n-                }};\n-                ($a:expr, $b:expr, $c:expr) => {{\n-                    tt!(Punct { ch: $a, joint: true });\n-                    tt!(Punct { ch: $b, joint: true });\n-                    tt!(Punct { ch: $c, joint });\n-                }};\n-            }\n+            let mut op = |s: &str| {\n+                assert!(s.is_ascii());\n+                trees.extend(s.as_bytes().iter().enumerate().map(|(idx, &ch)| {\n+                    TokenTree::Punct(Punct { ch, joint: joint || idx != s.len() - 1, span })\n+                }));\n+            };\n \n             match kind {\n-                Eq => op!('='),\n-                Lt => op!('<'),\n-                Le => op!('<', '='),\n-                EqEq => op!('=', '='),\n-                Ne => op!('!', '='),\n-                Ge => op!('>', '='),\n-                Gt => op!('>'),\n-                AndAnd => op!('&', '&'),\n-                OrOr => op!('|', '|'),\n-                Not => op!('!'),\n-                Tilde => op!('~'),\n-                BinOp(Plus) => op!('+'),\n-                BinOp(Minus) => op!('-'),\n-                BinOp(Star) => op!('*'),\n-                BinOp(Slash) => op!('/'),\n-                BinOp(Percent) => op!('%'),\n-                BinOp(Caret) => op!('^'),\n-                BinOp(And) => op!('&'),\n-                BinOp(Or) => op!('|'),\n-                BinOp(Shl) => op!('<', '<'),\n-                BinOp(Shr) => op!('>', '>'),\n-                BinOpEq(Plus) => op!('+', '='),\n-                BinOpEq(Minus) => op!('-', '='),\n-                BinOpEq(Star) => op!('*', '='),\n-                BinOpEq(Slash) => op!('/', '='),\n-                BinOpEq(Percent) => op!('%', '='),\n-                BinOpEq(Caret) => op!('^', '='),\n-                BinOpEq(And) => op!('&', '='),\n-                BinOpEq(Or) => op!('|', '='),\n-                BinOpEq(Shl) => op!('<', '<', '='),\n-                BinOpEq(Shr) => op!('>', '>', '='),\n-                At => op!('@'),\n-                Dot => op!('.'),\n-                DotDot => op!('.', '.'),\n-                DotDotDot => op!('.', '.', '.'),\n-                DotDotEq => op!('.', '.', '='),\n-                Comma => op!(','),\n-                Semi => op!(';'),\n-                Colon => op!(':'),\n-                ModSep => op!(':', ':'),\n-                RArrow => op!('-', '>'),\n-                LArrow => op!('<', '-'),\n-                FatArrow => op!('=', '>'),\n-                Pound => op!('#'),\n-                Dollar => op!('$'),\n-                Question => op!('?'),\n-                SingleQuote => op!('\\''),\n-\n-                Ident(name, false) if name == kw::DollarCrate => tt!(Ident::dollar_crate()),\n-                Ident(name, is_raw) => tt!(Ident::new(rustc.sess(), name, is_raw)),\n+                Eq => op(\"=\"),\n+                Lt => op(\"<\"),\n+                Le => op(\"<=\"),\n+                EqEq => op(\"==\"),\n+                Ne => op(\"!=\"),\n+                Ge => op(\">=\"),\n+                Gt => op(\">\"),\n+                AndAnd => op(\"&&\"),\n+                OrOr => op(\"||\"),\n+                Not => op(\"!\"),\n+                Tilde => op(\"~\"),\n+                BinOp(Plus) => op(\"+\"),\n+                BinOp(Minus) => op(\"-\"),\n+                BinOp(Star) => op(\"*\"),\n+                BinOp(Slash) => op(\"/\"),\n+                BinOp(Percent) => op(\"%\"),\n+                BinOp(Caret) => op(\"^\"),\n+                BinOp(And) => op(\"&\"),\n+                BinOp(Or) => op(\"|\"),\n+                BinOp(Shl) => op(\"<<\"),\n+                BinOp(Shr) => op(\">>\"),\n+                BinOpEq(Plus) => op(\"+=\"),\n+                BinOpEq(Minus) => op(\"-=\"),\n+                BinOpEq(Star) => op(\"*=\"),\n+                BinOpEq(Slash) => op(\"/=\"),\n+                BinOpEq(Percent) => op(\"%=\"),\n+                BinOpEq(Caret) => op(\"^=\"),\n+                BinOpEq(And) => op(\"&=\"),\n+                BinOpEq(Or) => op(\"|=\"),\n+                BinOpEq(Shl) => op(\"<<=\"),\n+                BinOpEq(Shr) => op(\">>=\"),\n+                At => op(\"@\"),\n+                Dot => op(\".\"),\n+                DotDot => op(\"..\"),\n+                DotDotDot => op(\"...\"),\n+                DotDotEq => op(\"..=\"),\n+                Comma => op(\",\"),\n+                Semi => op(\";\"),\n+                Colon => op(\":\"),\n+                ModSep => op(\"::\"),\n+                RArrow => op(\"->\"),\n+                LArrow => op(\"<-\"),\n+                FatArrow => op(\"=>\"),\n+                Pound => op(\"#\"),\n+                Dollar => op(\"$\"),\n+                Question => op(\"?\"),\n+                SingleQuote => op(\"'\"),\n+\n+                Ident(name, false) if name == kw::DollarCrate => trees.push(TokenTree::Ident(Ident::dollar_crate(span))),\n+                Ident(name, is_raw) => trees.push(TokenTree::Ident(Ident::new(rustc.sess(), name, is_raw, span))),\n                 Lifetime(name) => {\n                     let ident = symbol::Ident::new(name, span).without_first_quote();\n-                    tt!(Punct { ch: '\\'', joint: true });\n-                    tt!(Ident::new(rustc.sess(), ident.name, false));\n+                    trees.extend([\n+                        TokenTree::Punct(Punct { ch: b'\\'', joint: true, span }),\n+                        TokenTree::Ident(Ident::new(rustc.sess(), ident.name, false, span)),\n+                    ]);\n                 }\n-                Literal(lit) => tt!(Literal { lit }),\n+                Literal(lit) => trees.push(TokenTree::Literal(self::Literal { lit, span })),\n                 DocComment(_, attr_style, data) => {\n                     let mut escaped = String::new();\n                     for ch in data.as_str().chars() {\n                         escaped.extend(ch.escape_debug());\n                     }\n-                    let stream = vec![\n+                    let stream = [\n                         Ident(sym::doc, false),\n                         Eq,\n                         TokenKind::lit(token::Str, Symbol::intern(&escaped), None),\n                     ]\n                     .into_iter()\n                     .map(|kind| tokenstream::TokenTree::token(kind, span))\n                     .collect();\n-                    tt!(Punct { ch: '#', joint: false });\n+                    trees.push(TokenTree::Punct(Punct { ch: b'#', joint: false, span }));\n                     if attr_style == ast::AttrStyle::Inner {\n-                        tt!(Punct { ch: '!', joint: false });\n+                        trees.push(TokenTree::Punct(Punct { ch: b'!', joint: false, span }));\n                     }\n                     trees.push(TokenTree::Group(Group {\n                         delimiter: pm::Delimiter::Bracket,\n@@ -190,6 +175,12 @@ impl FromInternal<(TokenStream, &mut Rustc<'_, '_>)>\n \n                 Interpolated(nt) => {\n                     let stream = TokenStream::from_nonterminal_ast(&nt);\n+                    // A hack used to pass AST fragments to attribute and derive\n+                    // macros as a single nonterminal token instead of a token\n+                    // stream.  Such token needs to be \"unwrapped\" and not\n+                    // represented as a delimited group.\n+                    // FIXME: It needs to be removed, but there are some\n+                    // compatibility issues (see #73345).\n                     if crate::base::nt_pretty_printing_compatibility_hack(&nt, rustc.sess()) {\n                         trees.extend(Self::from_internal((stream, rustc)));\n                     } else {\n@@ -254,28 +245,28 @@ impl ToInternal<TokenStream> for TokenTree<TokenStream, Span, Ident, Literal> {\n         };\n \n         let kind = match ch {\n-            '=' => Eq,\n-            '<' => Lt,\n-            '>' => Gt,\n-            '!' => Not,\n-            '~' => Tilde,\n-            '+' => BinOp(Plus),\n-            '-' => BinOp(Minus),\n-            '*' => BinOp(Star),\n-            '/' => BinOp(Slash),\n-            '%' => BinOp(Percent),\n-            '^' => BinOp(Caret),\n-            '&' => BinOp(And),\n-            '|' => BinOp(Or),\n-            '@' => At,\n-            '.' => Dot,\n-            ',' => Comma,\n-            ';' => Semi,\n-            ':' => Colon,\n-            '#' => Pound,\n-            '$' => Dollar,\n-            '?' => Question,\n-            '\\'' => SingleQuote,\n+            b'=' => Eq,\n+            b'<' => Lt,\n+            b'>' => Gt,\n+            b'!' => Not,\n+            b'~' => Tilde,\n+            b'+' => BinOp(Plus),\n+            b'-' => BinOp(Minus),\n+            b'*' => BinOp(Star),\n+            b'/' => BinOp(Slash),\n+            b'%' => BinOp(Percent),\n+            b'^' => BinOp(Caret),\n+            b'&' => BinOp(And),\n+            b'|' => BinOp(Or),\n+            b'@' => At,\n+            b'.' => Dot,\n+            b',' => Comma,\n+            b';' => Semi,\n+            b':' => Colon,\n+            b'#' => Pound,\n+            b'$' => Dollar,\n+            b'?' => Question,\n+            b'\\'' => SingleQuote,\n             _ => unreachable!(),\n         };\n "}, {"sha": "048ba3a8fdb79ff992931d5162fef9f690427baf", "filename": "library/proc_macro/src/bridge/mod.rs", "status": "modified", "additions": 27, "deletions": 26, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/64a7d57046bc4653dddb346b51cd66a8980f3533/library%2Fproc_macro%2Fsrc%2Fbridge%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/64a7d57046bc4653dddb346b51cd66a8980f3533/library%2Fproc_macro%2Fsrc%2Fbridge%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fproc_macro%2Fsrc%2Fbridge%2Fmod.rs?ref=64a7d57046bc4653dddb346b51cd66a8980f3533", "patch": "@@ -325,6 +325,7 @@ mark_noop! {\n     &'_ [u8],\n     &'_ str,\n     String,\n+    u8,\n     usize,\n     Delimiter,\n     Level,\n@@ -431,48 +432,48 @@ compound_traits!(\n );\n \n #[derive(Copy, Clone)]\n-pub struct DelimSpan<S> {\n-    pub open: S,\n-    pub close: S,\n-    pub entire: S,\n+pub struct DelimSpan<Span> {\n+    pub open: Span,\n+    pub close: Span,\n+    pub entire: Span,\n }\n \n-impl<S: Copy> DelimSpan<S> {\n-    pub fn from_single(span: S) -> Self {\n+impl<Span: Copy> DelimSpan<Span> {\n+    pub fn from_single(span: Span) -> Self {\n         DelimSpan { open: span, close: span, entire: span }\n     }\n }\n \n-compound_traits!(struct DelimSpan<Sp> { open, close, entire });\n+compound_traits!(struct DelimSpan<Span> { open, close, entire });\n \n #[derive(Clone)]\n-pub struct Group<T, S> {\n+pub struct Group<TokenStream, Span> {\n     pub delimiter: Delimiter,\n-    pub stream: Option<T>,\n-    pub span: DelimSpan<S>,\n+    pub stream: Option<TokenStream>,\n+    pub span: DelimSpan<Span>,\n }\n \n-compound_traits!(struct Group<T, Sp> { delimiter, stream, span });\n+compound_traits!(struct Group<TokenStream, Span> { delimiter, stream, span });\n \n #[derive(Clone)]\n-pub struct Punct<S> {\n-    pub ch: char,\n+pub struct Punct<Span> {\n+    pub ch: u8,\n     pub joint: bool,\n-    pub span: S,\n+    pub span: Span,\n }\n \n-compound_traits!(struct Punct<Sp> { ch, joint, span });\n+compound_traits!(struct Punct<Span> { ch, joint, span });\n \n #[derive(Clone)]\n-pub enum TokenTree<T, S, I, L> {\n-    Group(Group<T, S>),\n-    Punct(Punct<S>),\n-    Ident(I),\n-    Literal(L),\n+pub enum TokenTree<TokenStream, Span, Ident, Literal> {\n+    Group(Group<TokenStream, Span>),\n+    Punct(Punct<Span>),\n+    Ident(Ident),\n+    Literal(Literal),\n }\n \n compound_traits!(\n-    enum TokenTree<T, Sp, I, L> {\n+    enum TokenTree<TokenStream, Span, Ident, Literal> {\n         Group(tt),\n         Punct(tt),\n         Ident(tt),\n@@ -483,12 +484,12 @@ compound_traits!(\n /// Globals provided alongside the initial inputs for a macro expansion.\n /// Provides values such as spans which are used frequently to avoid RPC.\n #[derive(Clone)]\n-pub struct ExpnGlobals<S> {\n-    pub def_site: S,\n-    pub call_site: S,\n-    pub mixed_site: S,\n+pub struct ExpnGlobals<Span> {\n+    pub def_site: Span,\n+    pub call_site: Span,\n+    pub mixed_site: Span,\n }\n \n compound_traits!(\n-    struct ExpnGlobals<Sp> { def_site, call_site, mixed_site }\n+    struct ExpnGlobals<Span> { def_site, call_site, mixed_site }\n );"}, {"sha": "9ab5061c668078c06c8feaa27ab40ae79b31a85e", "filename": "library/proc_macro/src/lib.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/64a7d57046bc4653dddb346b51cd66a8980f3533/library%2Fproc_macro%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/64a7d57046bc4653dddb346b51cd66a8980f3533/library%2Fproc_macro%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fproc_macro%2Fsrc%2Flib.rs?ref=64a7d57046bc4653dddb346b51cd66a8980f3533", "patch": "@@ -969,13 +969,17 @@ impl Punct {\n         if !LEGAL_CHARS.contains(&ch) {\n             panic!(\"unsupported character `{:?}`\", ch);\n         }\n-        Punct(bridge::Punct { ch, joint: spacing == Spacing::Joint, span: Span::call_site().0 })\n+        Punct(bridge::Punct {\n+            ch: ch as u8,\n+            joint: spacing == Spacing::Joint,\n+            span: Span::call_site().0,\n+        })\n     }\n \n     /// Returns the value of this punctuation character as `char`.\n     #[stable(feature = \"proc_macro_lib2\", since = \"1.29.0\")]\n     pub fn as_char(&self) -> char {\n-        self.0.ch\n+        self.0.ch as char\n     }\n \n     /// Returns the spacing of this punctuation character, indicating whether it's immediately"}]}