{"sha": "526bb10701af099f6812077a57bf64b53e85dd4c", "node_id": "MDY6Q29tbWl0NzI0NzEyOjUyNmJiMTA3MDFhZjA5OWY2ODEyMDc3YTU3YmY2NGI1M2U4NWRkNGM=", "commit": {"author": {"name": "Joshua Nelson", "email": "jyn514@gmail.com", "date": "2021-03-29T17:50:40Z"}, "committer": {"name": "Joshua Nelson", "email": "jyn514@gmail.com", "date": "2021-03-29T17:50:40Z"}, "message": "Revert changes to sync data structures\n\nThere isn't currently a good reviewer for these, and I don't want to\nremove things that will just be added again. I plan to make a separate\nPR for these changes so the rest of the cleanup can land.", "tree": {"sha": "d6fb4972cfc9be7a4aed3df4755d539ee18ea2fa", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d6fb4972cfc9be7a4aed3df4755d539ee18ea2fa"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/526bb10701af099f6812077a57bf64b53e85dd4c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/526bb10701af099f6812077a57bf64b53e85dd4c", "html_url": "https://github.com/rust-lang/rust/commit/526bb10701af099f6812077a57bf64b53e85dd4c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/526bb10701af099f6812077a57bf64b53e85dd4c/comments", "author": {"login": "jyn514", "id": 23638587, "node_id": "MDQ6VXNlcjIzNjM4NTg3", "avatar_url": "https://avatars.githubusercontent.com/u/23638587?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jyn514", "html_url": "https://github.com/jyn514", "followers_url": "https://api.github.com/users/jyn514/followers", "following_url": "https://api.github.com/users/jyn514/following{/other_user}", "gists_url": "https://api.github.com/users/jyn514/gists{/gist_id}", "starred_url": "https://api.github.com/users/jyn514/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jyn514/subscriptions", "organizations_url": "https://api.github.com/users/jyn514/orgs", "repos_url": "https://api.github.com/users/jyn514/repos", "events_url": "https://api.github.com/users/jyn514/events{/privacy}", "received_events_url": "https://api.github.com/users/jyn514/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jyn514", "id": 23638587, "node_id": "MDQ6VXNlcjIzNjM4NTg3", "avatar_url": "https://avatars.githubusercontent.com/u/23638587?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jyn514", "html_url": "https://github.com/jyn514", "followers_url": "https://api.github.com/users/jyn514/followers", "following_url": "https://api.github.com/users/jyn514/following{/other_user}", "gists_url": "https://api.github.com/users/jyn514/gists{/gist_id}", "starred_url": "https://api.github.com/users/jyn514/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jyn514/subscriptions", "organizations_url": "https://api.github.com/users/jyn514/orgs", "repos_url": "https://api.github.com/users/jyn514/repos", "events_url": "https://api.github.com/users/jyn514/events{/privacy}", "received_events_url": "https://api.github.com/users/jyn514/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f3523544f114a4a4cc2ced3f1a53f5f3bc158751", "url": "https://api.github.com/repos/rust-lang/rust/commits/f3523544f114a4a4cc2ced3f1a53f5f3bc158751", "html_url": "https://github.com/rust-lang/rust/commit/f3523544f114a4a4cc2ced3f1a53f5f3bc158751"}], "stats": {"total": 110, "additions": 110, "deletions": 0}, "files": [{"sha": "26706cd2b1b770333f5a77ae607a17cf0ebcca3e", "filename": "compiler/rustc_data_structures/src/sync.rs", "status": "modified", "additions": 110, "deletions": 0, "changes": 110, "blob_url": "https://github.com/rust-lang/rust/blob/526bb10701af099f6812077a57bf64b53e85dd4c/compiler%2Frustc_data_structures%2Fsrc%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/526bb10701af099f6812077a57bf64b53e85dd4c/compiler%2Frustc_data_structures%2Fsrc%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_data_structures%2Fsrc%2Fsync.rs?ref=526bb10701af099f6812077a57bf64b53e85dd4c", "patch": "@@ -43,6 +43,46 @@ cfg_if! {\n         use std::ops::Add;\n         use std::panic::{resume_unwind, catch_unwind, AssertUnwindSafe};\n \n+        /// This is a single threaded variant of AtomicCell provided by crossbeam.\n+        /// Unlike `Atomic` this is intended for all `Copy` types,\n+        /// but it lacks the explicit ordering arguments.\n+        #[derive(Debug)]\n+        pub struct AtomicCell<T: Copy>(Cell<T>);\n+\n+        impl<T: Copy> AtomicCell<T> {\n+            #[inline]\n+            pub fn new(v: T) -> Self {\n+                AtomicCell(Cell::new(v))\n+            }\n+\n+            #[inline]\n+            pub fn get_mut(&mut self) -> &mut T {\n+                self.0.get_mut()\n+            }\n+        }\n+\n+        impl<T: Copy> AtomicCell<T> {\n+            #[inline]\n+            pub fn into_inner(self) -> T {\n+                self.0.into_inner()\n+            }\n+\n+            #[inline]\n+            pub fn load(&self) -> T {\n+                self.0.get()\n+            }\n+\n+            #[inline]\n+            pub fn store(&self, val: T) {\n+                self.0.set(val)\n+            }\n+\n+            #[inline]\n+            pub fn swap(&self, val: T) -> T {\n+                self.0.replace(val)\n+            }\n+        }\n+\n         /// This is a single threaded variant of `AtomicU64`, `AtomicUsize`, etc.\n         /// It differs from `AtomicCell` in that it has explicit ordering arguments\n         /// and is only intended for use with the native atomic types.\n@@ -59,6 +99,11 @@ cfg_if! {\n         }\n \n         impl<T: Copy> Atomic<T> {\n+            #[inline]\n+            pub fn into_inner(self) -> T {\n+                self.0.into_inner()\n+            }\n+\n             #[inline]\n             pub fn load(&self, _: Ordering) -> T {\n                 self.0.get()\n@@ -68,6 +113,11 @@ cfg_if! {\n             pub fn store(&self, val: T, _: Ordering) {\n                 self.0.set(val)\n             }\n+\n+            #[inline]\n+            pub fn swap(&self, val: T, _: Ordering) -> T {\n+                self.0.replace(val)\n+            }\n         }\n \n         impl<T: Copy + PartialEq> Atomic<T> {\n@@ -109,6 +159,22 @@ cfg_if! {\n             (oper_a(), oper_b())\n         }\n \n+        pub struct SerialScope;\n+\n+        impl SerialScope {\n+            pub fn spawn<F>(&self, f: F)\n+                where F: FnOnce(&SerialScope)\n+            {\n+                f(self)\n+            }\n+        }\n+\n+        pub fn scope<F, R>(f: F) -> R\n+            where F: FnOnce(&SerialScope) -> R\n+        {\n+            f(&SerialScope)\n+        }\n+\n         #[macro_export]\n         macro_rules! parallel {\n             ($($blocks:tt),*) => {\n@@ -180,6 +246,12 @@ cfg_if! {\n             pub fn new<F: FnMut(usize) -> T>(mut f: F) -> WorkerLocal<T> {\n                 WorkerLocal(OneThread::new(f(0)))\n             }\n+\n+            /// Returns the worker-local value for each thread\n+            #[inline]\n+            pub fn into_inner(self) -> Vec<T> {\n+                vec![OneThread::into_inner(self.0)]\n+            }\n         }\n \n         impl<T> Deref for WorkerLocal<T> {\n@@ -207,6 +279,16 @@ cfg_if! {\n                 self.0\n             }\n \n+            #[inline(always)]\n+            pub fn get_mut(&mut self) -> &mut T {\n+                &mut self.0\n+            }\n+\n+            #[inline(always)]\n+            pub fn lock(&self) -> &T {\n+                &self.0\n+            }\n+\n             #[inline(always)]\n             pub fn lock_mut(&mut self) -> &mut T {\n                 &mut self.0\n@@ -236,6 +318,8 @@ cfg_if! {\n \n         pub use std::sync::atomic::{AtomicBool, AtomicUsize, AtomicU32, AtomicU64};\n \n+        pub use crossbeam_utils::atomic::AtomicCell;\n+\n         pub use std::sync::Arc as Lrc;\n         pub use std::sync::Weak as Weak;\n \n@@ -437,6 +521,16 @@ impl<T> RwLock<T> {\n         RwLock(InnerRwLock::new(inner))\n     }\n \n+    #[inline(always)]\n+    pub fn into_inner(self) -> T {\n+        self.0.into_inner()\n+    }\n+\n+    #[inline(always)]\n+    pub fn get_mut(&mut self) -> &mut T {\n+        self.0.get_mut()\n+    }\n+\n     #[cfg(not(parallel_compiler))]\n     #[inline(always)]\n     pub fn read(&self) -> ReadGuard<'_, T> {\n@@ -453,6 +547,11 @@ impl<T> RwLock<T> {\n         }\n     }\n \n+    #[inline(always)]\n+    pub fn with_read_lock<F: FnOnce(&T) -> R, R>(&self, f: F) -> R {\n+        f(&*self.read())\n+    }\n+\n     #[cfg(not(parallel_compiler))]\n     #[inline(always)]\n     pub fn try_write(&self) -> Result<WriteGuard<'_, T>, ()> {\n@@ -481,6 +580,11 @@ impl<T> RwLock<T> {\n         }\n     }\n \n+    #[inline(always)]\n+    pub fn with_write_lock<F: FnOnce(&mut T) -> R, R>(&self, f: F) -> R {\n+        f(&mut *self.write())\n+    }\n+\n     #[inline(always)]\n     pub fn borrow(&self) -> ReadGuard<'_, T> {\n         self.read()\n@@ -529,6 +633,12 @@ impl<T> OneThread<T> {\n             inner,\n         }\n     }\n+\n+    #[inline(always)]\n+    pub fn into_inner(value: Self) -> T {\n+        value.check();\n+        value.inner\n+    }\n }\n \n impl<T> Deref for OneThread<T> {"}]}