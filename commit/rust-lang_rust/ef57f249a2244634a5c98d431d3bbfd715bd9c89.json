{"sha": "ef57f249a2244634a5c98d431d3bbfd715bd9c89", "node_id": "C_kwDOAAsO6NoAKGVmNTdmMjQ5YTIyNDQ2MzRhNWM5OGQ0MzFkM2JiZmQ3MTViZDljODk", "commit": {"author": {"name": "Wesley Wiser", "email": "wesleywiser@microsoft.com", "date": "2021-12-20T21:36:56Z"}, "committer": {"name": "Wesley Wiser", "email": "wesleywiser@microsoft.com", "date": "2021-12-20T22:08:29Z"}, "message": "[code coverage] Fix missing dead code in modules that are never called\n\nThe issue here is that the logic used to determine which CGU to put the\ndead function stubs in doesn't handle cases where a module is never\nassigned to a CGU.\n\nThe partitioning logic also caused issues in #85461 where inline\nfunctions were duplicated into multiple CGUs resulting in duplicate\nsymbols.\n\nThis commit fixes the issue by removing the complex logic used to assign\ndead code stubs to CGUs and replaces it with a much simplier model: we\npick one CGU to hold all the dead code stubs. We pick a CGU which has\nexported items which increases the likelihood the linker won't throw\naway our dead functions and we pick the smallest to minimize the impact\non compilation times for crates with very large CGUs.\n\nFixes #86177\nFixes #85718\nFixes #79622", "tree": {"sha": "d453ea22df1a9d58693ae18e76ba4fe28cc6cc12", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d453ea22df1a9d58693ae18e76ba4fe28cc6cc12"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ef57f249a2244634a5c98d431d3bbfd715bd9c89", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ef57f249a2244634a5c98d431d3bbfd715bd9c89", "html_url": "https://github.com/rust-lang/rust/commit/ef57f249a2244634a5c98d431d3bbfd715bd9c89", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ef57f249a2244634a5c98d431d3bbfd715bd9c89/comments", "author": {"login": "wesleywiser", "id": 831192, "node_id": "MDQ6VXNlcjgzMTE5Mg==", "avatar_url": "https://avatars.githubusercontent.com/u/831192?v=4", "gravatar_id": "", "url": "https://api.github.com/users/wesleywiser", "html_url": "https://github.com/wesleywiser", "followers_url": "https://api.github.com/users/wesleywiser/followers", "following_url": "https://api.github.com/users/wesleywiser/following{/other_user}", "gists_url": "https://api.github.com/users/wesleywiser/gists{/gist_id}", "starred_url": "https://api.github.com/users/wesleywiser/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/wesleywiser/subscriptions", "organizations_url": "https://api.github.com/users/wesleywiser/orgs", "repos_url": "https://api.github.com/users/wesleywiser/repos", "events_url": "https://api.github.com/users/wesleywiser/events{/privacy}", "received_events_url": "https://api.github.com/users/wesleywiser/received_events", "type": "User", "site_admin": false}, "committer": {"login": "wesleywiser", "id": 831192, "node_id": "MDQ6VXNlcjgzMTE5Mg==", "avatar_url": "https://avatars.githubusercontent.com/u/831192?v=4", "gravatar_id": "", "url": "https://api.github.com/users/wesleywiser", "html_url": "https://github.com/wesleywiser", "followers_url": "https://api.github.com/users/wesleywiser/followers", "following_url": "https://api.github.com/users/wesleywiser/following{/other_user}", "gists_url": "https://api.github.com/users/wesleywiser/gists{/gist_id}", "starred_url": "https://api.github.com/users/wesleywiser/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/wesleywiser/subscriptions", "organizations_url": "https://api.github.com/users/wesleywiser/orgs", "repos_url": "https://api.github.com/users/wesleywiser/repos", "events_url": "https://api.github.com/users/wesleywiser/events{/privacy}", "received_events_url": "https://api.github.com/users/wesleywiser/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "341d65d975453af9e548f1f668256604dc1f156a", "url": "https://api.github.com/repos/rust-lang/rust/commits/341d65d975453af9e548f1f668256604dc1f156a", "html_url": "https://github.com/rust-lang/rust/commit/341d65d975453af9e548f1f668256604dc1f156a"}], "stats": {"total": 199, "additions": 77, "deletions": 122}, "files": [{"sha": "ab3a0ef7f15db3e0caa4db384e2ca9fcc1fbe774", "filename": "compiler/rustc_codegen_llvm/src/coverageinfo/mapgen.rs", "status": "modified", "additions": 24, "deletions": 83, "changes": 107, "blob_url": "https://github.com/rust-lang/rust/blob/ef57f249a2244634a5c98d431d3bbfd715bd9c89/compiler%2Frustc_codegen_llvm%2Fsrc%2Fcoverageinfo%2Fmapgen.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef57f249a2244634a5c98d431d3bbfd715bd9c89/compiler%2Frustc_codegen_llvm%2Fsrc%2Fcoverageinfo%2Fmapgen.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fcoverageinfo%2Fmapgen.rs?ref=ef57f249a2244634a5c98d431d3bbfd715bd9c89", "patch": "@@ -5,12 +5,13 @@ use crate::llvm;\n use llvm::coverageinfo::CounterMappingRegion;\n use rustc_codegen_ssa::coverageinfo::map::{Counter, CounterExpression};\n use rustc_codegen_ssa::traits::{ConstMethods, CoverageInfoMethods};\n-use rustc_data_structures::fx::{FxHashMap, FxHashSet, FxIndexSet};\n-use rustc_hir::def_id::{DefId, DefIdSet};\n+use rustc_data_structures::fx::FxIndexSet;\n+use rustc_hir::def::DefKind;\n+use rustc_hir::def_id::DefIdSet;\n use rustc_llvm::RustString;\n+use rustc_middle::middle::codegen_fn_attrs::CodegenFnAttrFlags;\n use rustc_middle::mir::coverage::CodeRegion;\n use rustc_middle::ty::TyCtxt;\n-use rustc_span::Symbol;\n \n use std::ffi::CString;\n \n@@ -46,7 +47,7 @@ pub fn finalize<'ll, 'tcx>(cx: &CodegenCx<'ll, 'tcx>) {\n     // functions exist. Generate synthetic functions with a (required) single counter, and add the\n     // MIR `Coverage` code regions to the `function_coverage_map`, before calling\n     // `ctx.take_function_coverage_map()`.\n-    if !tcx.sess.instrument_coverage_except_unused_functions() {\n+    if cx.codegen_unit.is_code_coverage_dead_code_cgu() {\n         add_unused_functions(cx);\n     }\n \n@@ -271,17 +272,12 @@ fn save_function_record(\n /// `DefId`s (`tcx` query `mir_keys`) minus the codegenned `DefId`s (`tcx` query\n /// `codegened_and_inlined_items`).\n ///\n-/// *HOWEVER* the codegenned `DefId`s are partitioned across multiple `CodegenUnit`s (CGUs), and\n-/// this function is processing a `function_coverage_map` for the functions (`Instance`/`DefId`)\n-/// allocated to only one of those CGUs. We must NOT inject any unused functions's `CodeRegion`s\n-/// more than once, so we have to pick a CGUs `function_coverage_map` into which the unused\n-/// function will be inserted.\n+/// These unused functions are then codegen'd in one of the CGUs which is marked as the\n+/// \"code coverage dead code cgu\" during the partitioning process.\n fn add_unused_functions<'ll, 'tcx>(cx: &CodegenCx<'ll, 'tcx>) {\n-    let tcx = cx.tcx;\n+    assert!(cx.codegen_unit.is_code_coverage_dead_code_cgu());\n \n-    // FIXME(#79622): Can this solution be simplified and/or improved? Are there other sources\n-    // of compiler state data that might help (or better sources that could be exposed, but\n-    // aren't yet)?\n+    let tcx = cx.tcx;\n \n     let ignore_unused_generics = tcx.sess.instrument_coverage_except_unused_generics();\n \n@@ -299,79 +295,24 @@ fn add_unused_functions<'ll, 'tcx>(cx: &CodegenCx<'ll, 'tcx>) {\n \n     let codegenned_def_ids = tcx.codegened_and_inlined_items(());\n \n-    let mut unused_def_ids_by_file: FxHashMap<Symbol, Vec<DefId>> = FxHashMap::default();\n     for &non_codegenned_def_id in all_def_ids.difference(codegenned_def_ids) {\n-        // Make sure the non-codegenned (unused) function has at least one MIR\n-        // `Coverage` statement with a code region, and return its file name.\n-        if let Some(non_codegenned_file_name) = tcx.covered_file_name(non_codegenned_def_id) {\n-            let def_ids =\n-                unused_def_ids_by_file.entry(*non_codegenned_file_name).or_insert_with(Vec::new);\n-            def_ids.push(non_codegenned_def_id);\n-        }\n-    }\n-\n-    if unused_def_ids_by_file.is_empty() {\n-        // There are no unused functions with file names to add (in any CGU)\n-        return;\n-    }\n-\n-    // Each `CodegenUnit` (CGU) has its own function_coverage_map, and generates a specific binary\n-    // with its own coverage map.\n-    //\n-    // Each covered function `Instance` can be included in only one coverage map, produced from a\n-    // specific function_coverage_map, from a specific CGU.\n-    //\n-    // Since unused functions did not generate code, they are not associated with any CGU yet.\n-    //\n-    // To avoid injecting the unused functions in multiple coverage maps (for multiple CGUs)\n-    // determine which function_coverage_map has the responsibility for publishing unreachable\n-    // coverage, based on file name: For each unused function, find the CGU that generates the\n-    // first function (based on sorted `DefId`) from the same file.\n-    //\n-    // Add a new `FunctionCoverage` to the `function_coverage_map`, with unreachable code regions\n-    // for each region in it's MIR.\n-\n-    // Convert the `HashSet` of `codegenned_def_ids` to a sortable vector, and sort them.\n-    let mut sorted_codegenned_def_ids: Vec<DefId> = codegenned_def_ids.iter().copied().collect();\n-    sorted_codegenned_def_ids.sort_unstable();\n-\n-    let mut first_covered_def_id_by_file: FxHashMap<Symbol, DefId> = FxHashMap::default();\n-    for &def_id in sorted_codegenned_def_ids.iter() {\n-        if let Some(covered_file_name) = tcx.covered_file_name(def_id) {\n-            // Only add files known to have unused functions\n-            if unused_def_ids_by_file.contains_key(covered_file_name) {\n-                first_covered_def_id_by_file.entry(*covered_file_name).or_insert(def_id);\n+        // `all_def_ids` contains things besides just \"functions\" such as constants,\n+        // statics, etc. We need to filter those out.\n+        let kind = tcx.def_kind(non_codegenned_def_id);\n+        if matches!(kind, DefKind::Fn | DefKind::AssocFn | DefKind::Closure | DefKind::Generator) {\n+            let codegen_fn_attrs = tcx.codegen_fn_attrs(non_codegenned_def_id);\n+\n+            // If a function is marked `#[no_coverage]`, then skip generating a\n+            // dead code stub for it.\n+            if codegen_fn_attrs.flags.contains(CodegenFnAttrFlags::NO_COVERAGE) {\n+                debug!(\"skipping unused fn marked #[no_coverage]: {:?}\", non_codegenned_def_id);\n+                continue;\n             }\n-        }\n-    }\n-\n-    // Get the set of def_ids with coverage regions, known by *this* CoverageContext.\n-    let cgu_covered_def_ids: DefIdSet = match cx.coverage_context() {\n-        Some(ctx) => ctx\n-            .function_coverage_map\n-            .borrow()\n-            .keys()\n-            .map(|&instance| instance.def.def_id())\n-            .collect(),\n-        None => return,\n-    };\n-\n-    let cgu_covered_files: FxHashSet<Symbol> = first_covered_def_id_by_file\n-        .iter()\n-        .filter_map(\n-            |(&file_name, def_id)| {\n-                if cgu_covered_def_ids.contains(def_id) { Some(file_name) } else { None }\n-            },\n-        )\n-        .collect();\n \n-    // For each file for which this CGU is responsible for adding unused function coverage,\n-    // get the `def_id`s for each unused function (if any), define a synthetic function with a\n-    // single LLVM coverage counter, and add the function's coverage `CodeRegion`s. to the\n-    // function_coverage_map.\n-    for covered_file_name in cgu_covered_files {\n-        for def_id in unused_def_ids_by_file.remove(&covered_file_name).into_iter().flatten() {\n-            cx.define_unused_fn(def_id);\n+            debug!(\"generating unused fn: {:?}\", non_codegenned_def_id);\n+            cx.define_unused_fn(non_codegenned_def_id);\n+        } else {\n+            debug!(\"skipping unused {:?}: {:?}\", kind, non_codegenned_def_id);\n         }\n     }\n }"}, {"sha": "a9d65a31928741d5ec616b9ef2d2db575ffd423b", "filename": "compiler/rustc_middle/src/mir/mono.rs", "status": "modified", "additions": 21, "deletions": 1, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/ef57f249a2244634a5c98d431d3bbfd715bd9c89/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fmono.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef57f249a2244634a5c98d431d3bbfd715bd9c89/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fmono.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fmono.rs?ref=ef57f249a2244634a5c98d431d3bbfd715bd9c89", "patch": "@@ -247,6 +247,9 @@ pub struct CodegenUnit<'tcx> {\n     items: FxHashMap<MonoItem<'tcx>, (Linkage, Visibility)>,\n     size_estimate: Option<usize>,\n     primary: bool,\n+    /// True if this is CGU is used to hold code coverage information for dead code,\n+    /// false otherwise.\n+    is_code_coverage_dead_code_cgu: bool,\n }\n \n /// Specifies the linkage type for a `MonoItem`.\n@@ -277,7 +280,13 @@ pub enum Visibility {\n impl<'tcx> CodegenUnit<'tcx> {\n     #[inline]\n     pub fn new(name: Symbol) -> CodegenUnit<'tcx> {\n-        CodegenUnit { name, items: Default::default(), size_estimate: None, primary: false }\n+        CodegenUnit {\n+            name,\n+            items: Default::default(),\n+            size_estimate: None,\n+            primary: false,\n+            is_code_coverage_dead_code_cgu: false,\n+        }\n     }\n \n     pub fn name(&self) -> Symbol {\n@@ -304,6 +313,15 @@ impl<'tcx> CodegenUnit<'tcx> {\n         &mut self.items\n     }\n \n+    pub fn is_code_coverage_dead_code_cgu(&self) -> bool {\n+        self.is_code_coverage_dead_code_cgu\n+    }\n+\n+    /// Marks this CGU as the one used to contain code coverage information for dead code.\n+    pub fn make_code_coverage_dead_code_cgu(&mut self) {\n+        self.is_code_coverage_dead_code_cgu = true;\n+    }\n+\n     pub fn mangle_name(human_readable_name: &str) -> String {\n         // We generate a 80 bit hash from the name. This should be enough to\n         // avoid collisions and is still reasonably short for filenames.\n@@ -407,9 +425,11 @@ impl<'a, 'tcx> HashStable<StableHashingContext<'a>> for CodegenUnit<'tcx> {\n             // The size estimate is not relevant to the hash\n             size_estimate: _,\n             primary: _,\n+            is_code_coverage_dead_code_cgu,\n         } = *self;\n \n         name.hash_stable(hcx, hasher);\n+        is_code_coverage_dead_code_cgu.hash_stable(hcx, hasher);\n \n         let mut items: Vec<(Fingerprint, _)> = items\n             .iter()"}, {"sha": "5990e34f3406049f9620e046aed182a15639b0ca", "filename": "compiler/rustc_middle/src/query/mod.rs", "status": "modified", "additions": 0, "deletions": 10, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/ef57f249a2244634a5c98d431d3bbfd715bd9c89/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef57f249a2244634a5c98d431d3bbfd715bd9c89/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs?ref=ef57f249a2244634a5c98d431d3bbfd715bd9c89", "patch": "@@ -386,16 +386,6 @@ rustc_queries! {\n         storage(ArenaCacheSelector<'tcx>)\n     }\n \n-    /// Returns the name of the file that contains the function body, if instrumented for coverage.\n-    query covered_file_name(key: DefId) -> Option<Symbol> {\n-        desc {\n-            |tcx| \"retrieving the covered file name, if instrumented, for `{}`\",\n-            tcx.def_path_str(key)\n-        }\n-        storage(ArenaCacheSelector<'tcx>)\n-        cache_on_disk_if { key.is_local() }\n-    }\n-\n     /// Returns the `CodeRegions` for a function that has instrumented coverage, in case the\n     /// function was optimized out before codegen, and before being added to the Coverage Map.\n     query covered_code_regions(key: DefId) -> Vec<&'tcx mir::coverage::CodeRegion> {"}, {"sha": "46de6d939a1df69fbc48754e4c02d94fb3b6225d", "filename": "compiler/rustc_mir_transform/src/coverage/query.rs", "status": "modified", "additions": 0, "deletions": 20, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/ef57f249a2244634a5c98d431d3bbfd715bd9c89/compiler%2Frustc_mir_transform%2Fsrc%2Fcoverage%2Fquery.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef57f249a2244634a5c98d431d3bbfd715bd9c89/compiler%2Frustc_mir_transform%2Fsrc%2Fcoverage%2Fquery.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Fcoverage%2Fquery.rs?ref=ef57f249a2244634a5c98d431d3bbfd715bd9c89", "patch": "@@ -9,7 +9,6 @@ use rustc_span::def_id::DefId;\n /// A `query` provider for retrieving coverage information injected into MIR.\n pub(crate) fn provide(providers: &mut Providers) {\n     providers.coverageinfo = |tcx, def_id| coverageinfo(tcx, def_id);\n-    providers.covered_file_name = |tcx, def_id| covered_file_name(tcx, def_id);\n     providers.covered_code_regions = |tcx, def_id| covered_code_regions(tcx, def_id);\n }\n \n@@ -137,25 +136,6 @@ fn coverageinfo<'tcx>(tcx: TyCtxt<'tcx>, instance_def: ty::InstanceDef<'tcx>) ->\n     coverage_visitor.info\n }\n \n-fn covered_file_name(tcx: TyCtxt<'_>, def_id: DefId) -> Option<Symbol> {\n-    if tcx.is_mir_available(def_id) {\n-        let body = mir_body(tcx, def_id);\n-        for bb_data in body.basic_blocks().iter() {\n-            for statement in bb_data.statements.iter() {\n-                if let StatementKind::Coverage(box ref coverage) = statement.kind {\n-                    if let Some(code_region) = coverage.code_region.as_ref() {\n-                        if is_inlined(body, statement) {\n-                            continue;\n-                        }\n-                        return Some(code_region.file_name);\n-                    }\n-                }\n-            }\n-        }\n-    }\n-    return None;\n-}\n-\n fn covered_code_regions<'tcx>(tcx: TyCtxt<'tcx>, def_id: DefId) -> Vec<&'tcx CodeRegion> {\n     let body = mir_body(tcx, def_id);\n     body.basic_blocks()"}, {"sha": "463c213536448f1d4a902636686e744ac62523d2", "filename": "compiler/rustc_monomorphize/src/partitioning/mod.rs", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/ef57f249a2244634a5c98d431d3bbfd715bd9c89/compiler%2Frustc_monomorphize%2Fsrc%2Fpartitioning%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef57f249a2244634a5c98d431d3bbfd715bd9c89/compiler%2Frustc_monomorphize%2Fsrc%2Fpartitioning%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_monomorphize%2Fsrc%2Fpartitioning%2Fmod.rs?ref=ef57f249a2244634a5c98d431d3bbfd715bd9c89", "patch": "@@ -201,6 +201,24 @@ pub fn partition<'tcx>(\n         partitioner.internalize_symbols(cx, &mut post_inlining);\n     }\n \n+    let instrument_dead_code =\n+        tcx.sess.instrument_coverage() && !tcx.sess.instrument_coverage_except_unused_functions();\n+\n+    if instrument_dead_code {\n+        // Find the smallest CGU that has exported symbols and put the dead\n+        // function stubs in that CGU. We look for exported symbols to increase\n+        // the likelyhood the linker won't throw away the dead functions.\n+        let mut cgus_with_exported_symbols: Vec<_> = post_inlining\n+            .codegen_units\n+            .iter_mut()\n+            .filter(|cgu| cgu.items().iter().any(|(_, (linkage, _))| *linkage == Linkage::External))\n+            .collect();\n+        cgus_with_exported_symbols.sort_by_key(|cgu| cgu.size_estimate());\n+\n+        let dead_code_cgu = cgus_with_exported_symbols.last_mut().unwrap();\n+        dead_code_cgu.make_code_coverage_dead_code_cgu();\n+    }\n+\n     // Finally, sort by codegen unit name, so that we get deterministic results.\n     let PostInliningPartitioning {\n         codegen_units: mut result,"}, {"sha": "d902b7a412f3bd1402588e40a9da7ea130d55f50", "filename": "src/test/run-make-fulldeps/coverage-reports/expected_show_coverage.unused_mod.txt", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ef57f249a2244634a5c98d431d3bbfd715bd9c89/src%2Ftest%2Frun-make-fulldeps%2Fcoverage-reports%2Fexpected_show_coverage.unused_mod.txt", "raw_url": "https://github.com/rust-lang/rust/raw/ef57f249a2244634a5c98d431d3bbfd715bd9c89/src%2Ftest%2Frun-make-fulldeps%2Fcoverage-reports%2Fexpected_show_coverage.unused_mod.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make-fulldeps%2Fcoverage-reports%2Fexpected_show_coverage.unused_mod.txt?ref=ef57f249a2244634a5c98d431d3bbfd715bd9c89", "patch": "@@ -1,3 +1,9 @@\n+../coverage/lib/unused_mod_helper.rs:\n+    1|      0|pub fn never_called_function() {\n+    2|      0|    println!(\"I am never called\");\n+    3|      0|}\n+\n+../coverage/unused_mod.rs:\n     1|       |#[path = \"lib/unused_mod_helper.rs\"]\n     2|       |mod unused_module;\n     3|       |"}, {"sha": "c2d5143a61816f881992c53bf2c3fa2a412201dc", "filename": "src/test/run-make-fulldeps/coverage-reports/expected_show_coverage.uses_crate.txt", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/ef57f249a2244634a5c98d431d3bbfd715bd9c89/src%2Ftest%2Frun-make-fulldeps%2Fcoverage-reports%2Fexpected_show_coverage.uses_crate.txt", "raw_url": "https://github.com/rust-lang/rust/raw/ef57f249a2244634a5c98d431d3bbfd715bd9c89/src%2Ftest%2Frun-make-fulldeps%2Fcoverage-reports%2Fexpected_show_coverage.uses_crate.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make-fulldeps%2Fcoverage-reports%2Fexpected_show_coverage.uses_crate.txt?ref=ef57f249a2244634a5c98d431d3bbfd715bd9c89", "patch": "@@ -19,12 +19,12 @@\n    18|      2|    println!(\"used_only_from_bin_crate_generic_function with {:?}\", arg);\n    19|      2|}\n   ------------------\n-  | used_crate::used_only_from_bin_crate_generic_function::<&alloc::vec::Vec<i32>>:\n+  | used_crate::used_only_from_bin_crate_generic_function::<&str>:\n   |   17|      1|pub fn used_only_from_bin_crate_generic_function<T: Debug>(arg: T) {\n   |   18|      1|    println!(\"used_only_from_bin_crate_generic_function with {:?}\", arg);\n   |   19|      1|}\n   ------------------\n-  | used_crate::used_only_from_bin_crate_generic_function::<&str>:\n+  | used_crate::used_only_from_bin_crate_generic_function::<&alloc::vec::Vec<i32>>:\n   |   17|      1|pub fn used_only_from_bin_crate_generic_function<T: Debug>(arg: T) {\n   |   18|      1|    println!(\"used_only_from_bin_crate_generic_function with {:?}\", arg);\n   |   19|      1|}\n@@ -36,12 +36,12 @@\n    22|      2|    println!(\"used_only_from_this_lib_crate_generic_function with {:?}\", arg);\n    23|      2|}\n   ------------------\n-  | used_crate::used_only_from_this_lib_crate_generic_function::<alloc::vec::Vec<i32>>:\n+  | used_crate::used_only_from_this_lib_crate_generic_function::<&str>:\n   |   21|      1|pub fn used_only_from_this_lib_crate_generic_function<T: Debug>(arg: T) {\n   |   22|      1|    println!(\"used_only_from_this_lib_crate_generic_function with {:?}\", arg);\n   |   23|      1|}\n   ------------------\n-  | used_crate::used_only_from_this_lib_crate_generic_function::<&str>:\n+  | used_crate::used_only_from_this_lib_crate_generic_function::<alloc::vec::Vec<i32>>:\n   |   21|      1|pub fn used_only_from_this_lib_crate_generic_function<T: Debug>(arg: T) {\n   |   22|      1|    println!(\"used_only_from_this_lib_crate_generic_function with {:?}\", arg);\n   |   23|      1|}"}, {"sha": "dab31cbf4ac9eef4770d4c4a0b292c5da3f0aa25", "filename": "src/test/run-make-fulldeps/coverage-reports/expected_show_coverage.uses_inline_crate.txt", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/ef57f249a2244634a5c98d431d3bbfd715bd9c89/src%2Ftest%2Frun-make-fulldeps%2Fcoverage-reports%2Fexpected_show_coverage.uses_inline_crate.txt", "raw_url": "https://github.com/rust-lang/rust/raw/ef57f249a2244634a5c98d431d3bbfd715bd9c89/src%2Ftest%2Frun-make-fulldeps%2Fcoverage-reports%2Fexpected_show_coverage.uses_inline_crate.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make-fulldeps%2Fcoverage-reports%2Fexpected_show_coverage.uses_inline_crate.txt?ref=ef57f249a2244634a5c98d431d3bbfd715bd9c89", "patch": "@@ -42,12 +42,12 @@\n    40|      2|    println!(\"used_only_from_bin_crate_generic_function with {:?}\", arg);\n    41|      2|}\n   ------------------\n-  | used_inline_crate::used_only_from_bin_crate_generic_function::<&str>:\n+  | used_inline_crate::used_only_from_bin_crate_generic_function::<&alloc::vec::Vec<i32>>:\n   |   39|      1|pub fn used_only_from_bin_crate_generic_function<T: Debug>(arg: T) {\n   |   40|      1|    println!(\"used_only_from_bin_crate_generic_function with {:?}\", arg);\n   |   41|      1|}\n   ------------------\n-  | used_inline_crate::used_only_from_bin_crate_generic_function::<&alloc::vec::Vec<i32>>:\n+  | used_inline_crate::used_only_from_bin_crate_generic_function::<&str>:\n   |   39|      1|pub fn used_only_from_bin_crate_generic_function<T: Debug>(arg: T) {\n   |   40|      1|    println!(\"used_only_from_bin_crate_generic_function with {:?}\", arg);\n   |   41|      1|}\n@@ -61,12 +61,12 @@\n    46|      4|    println!(\"used_only_from_this_lib_crate_generic_function with {:?}\", arg);\n    47|      4|}\n   ------------------\n-  | used_inline_crate::used_only_from_this_lib_crate_generic_function::<&str>:\n+  | used_inline_crate::used_only_from_this_lib_crate_generic_function::<alloc::vec::Vec<i32>>:\n   |   45|      2|pub fn used_only_from_this_lib_crate_generic_function<T: Debug>(arg: T) {\n   |   46|      2|    println!(\"used_only_from_this_lib_crate_generic_function with {:?}\", arg);\n   |   47|      2|}\n   ------------------\n-  | used_inline_crate::used_only_from_this_lib_crate_generic_function::<alloc::vec::Vec<i32>>:\n+  | used_inline_crate::used_only_from_this_lib_crate_generic_function::<&str>:\n   |   45|      2|pub fn used_only_from_this_lib_crate_generic_function<T: Debug>(arg: T) {\n   |   46|      2|    println!(\"used_only_from_this_lib_crate_generic_function with {:?}\", arg);\n   |   47|      2|}"}]}