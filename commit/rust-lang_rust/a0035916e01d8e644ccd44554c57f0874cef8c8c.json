{"sha": "a0035916e01d8e644ccd44554c57f0874cef8c8c", "node_id": "MDY6Q29tbWl0NzI0NzEyOmEwMDM1OTE2ZTAxZDhlNjQ0Y2NkNDQ1NTRjNTdmMDg3NGNlZjhjOGM=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-08-20T19:06:46Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-08-20T19:06:46Z"}, "message": "Auto merge of #83093 - the8472:smaller-instant-hammer, r=Amanieu\n\nwhere available use AtomicU{64,128} instead of mutex for Instant backsliding protection\n\nThis decreases the overhead of backsliding protection on x86 systems with unreliable TSC, e.g. windows. And on aarch64 systems where 128bit atomics are available.\n\nThe following benchmarks were taken on x86_64 linux though by overriding `actually_monotonic()`, the numbers may look different on other platforms\n\n```\n# actually_monotonic() == true\ntest time::tests::instant_contention_01_threads                   ... bench:          44 ns/iter (+/- 0)\ntest time::tests::instant_contention_02_threads                   ... bench:          44 ns/iter (+/- 0)\ntest time::tests::instant_contention_04_threads                   ... bench:          44 ns/iter (+/- 0)\ntest time::tests::instant_contention_08_threads                   ... bench:          44 ns/iter (+/- 0)\ntest time::tests::instant_contention_16_threads                   ... bench:          44 ns/iter (+/- 0)\n\n# 1x AtomicU64\ntest time::tests::instant_contention_01_threads                   ... bench:          65 ns/iter (+/- 0)\ntest time::tests::instant_contention_02_threads                   ... bench:         157 ns/iter (+/- 20)\ntest time::tests::instant_contention_04_threads                   ... bench:         281 ns/iter (+/- 53)\ntest time::tests::instant_contention_08_threads                   ... bench:         555 ns/iter (+/- 77)\ntest time::tests::instant_contention_16_threads                   ... bench:         883 ns/iter (+/- 107)\n\n# mutex\ntest time::tests::instant_contention_01_threads                   ... bench:          60 ns/iter (+/- 2)\ntest time::tests::instant_contention_02_threads                   ... bench:         770 ns/iter (+/- 231)\ntest time::tests::instant_contention_04_threads                   ... bench:       1,347 ns/iter (+/- 45)\ntest time::tests::instant_contention_08_threads                   ... bench:       2,693 ns/iter (+/- 114)\ntest time::tests::instant_contention_16_threads                   ... bench:       5,244 ns/iter (+/- 487)\n```\n\nSince I don't have an arm machine with 128bit atomics I wasn't able to benchmark the AtomicU128 implementation.", "tree": {"sha": "c361d8d0aaf01cfa840ac7746445468be7a2a452", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c361d8d0aaf01cfa840ac7746445468be7a2a452"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a0035916e01d8e644ccd44554c57f0874cef8c8c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a0035916e01d8e644ccd44554c57f0874cef8c8c", "html_url": "https://github.com/rust-lang/rust/commit/a0035916e01d8e644ccd44554c57f0874cef8c8c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a0035916e01d8e644ccd44554c57f0874cef8c8c/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "914a1e2c517dfbaa23a4ec4a3eebefb3e2c253c2", "url": "https://api.github.com/repos/rust-lang/rust/commits/914a1e2c517dfbaa23a4ec4a3eebefb3e2c253c2", "html_url": "https://github.com/rust-lang/rust/commit/914a1e2c517dfbaa23a4ec4a3eebefb3e2c253c2"}, {"sha": "cd82b4246e7539822666c4bade1b4230550a8309", "url": "https://api.github.com/repos/rust-lang/rust/commits/cd82b4246e7539822666c4bade1b4230550a8309", "html_url": "https://github.com/rust-lang/rust/commit/cd82b4246e7539822666c4bade1b4230550a8309"}], "stats": {"total": 227, "additions": 215, "deletions": 12}, "files": [{"sha": "ec105f231e5a75c344327ffe565f06e8d976999c", "filename": "library/std/src/time.rs", "status": "modified", "additions": 2, "deletions": 10, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/a0035916e01d8e644ccd44554c57f0874cef8c8c/library%2Fstd%2Fsrc%2Ftime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a0035916e01d8e644ccd44554c57f0874cef8c8c/library%2Fstd%2Fsrc%2Ftime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Ftime.rs?ref=a0035916e01d8e644ccd44554c57f0874cef8c8c", "patch": "@@ -12,15 +12,14 @@\n \n #![stable(feature = \"time\", since = \"1.3.0\")]\n \n+mod monotonic;\n #[cfg(test)]\n mod tests;\n \n-use crate::cmp;\n use crate::error::Error;\n use crate::fmt;\n use crate::ops::{Add, AddAssign, Sub, SubAssign};\n use crate::sys::time;\n-use crate::sys_common::mutex::StaticMutex;\n use crate::sys_common::FromInner;\n \n #[stable(feature = \"time\", since = \"1.3.0\")]\n@@ -249,14 +248,7 @@ impl Instant {\n             return Instant(os_now);\n         }\n \n-        static LOCK: StaticMutex = StaticMutex::new();\n-        static mut LAST_NOW: time::Instant = time::Instant::zero();\n-        unsafe {\n-            let _lock = LOCK.lock();\n-            let now = cmp::max(LAST_NOW, os_now);\n-            LAST_NOW = now;\n-            Instant(now)\n-        }\n+        Instant(monotonic::monotonize(os_now))\n     }\n \n     /// Returns the amount of time elapsed from another instant to this one."}, {"sha": "27fee6acff331391c4df052191b49efd7bb34474", "filename": "library/std/src/time/monotonic.rs", "status": "added", "additions": 115, "deletions": 0, "changes": 115, "blob_url": "https://github.com/rust-lang/rust/blob/a0035916e01d8e644ccd44554c57f0874cef8c8c/library%2Fstd%2Fsrc%2Ftime%2Fmonotonic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a0035916e01d8e644ccd44554c57f0874cef8c8c/library%2Fstd%2Fsrc%2Ftime%2Fmonotonic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Ftime%2Fmonotonic.rs?ref=a0035916e01d8e644ccd44554c57f0874cef8c8c", "patch": "@@ -0,0 +1,115 @@\n+use crate::sys::time;\n+\n+#[inline]\n+pub(super) fn monotonize(raw: time::Instant) -> time::Instant {\n+    inner::monotonize(raw)\n+}\n+\n+#[cfg(all(target_has_atomic = \"64\", not(target_has_atomic = \"128\")))]\n+pub mod inner {\n+    use crate::sync::atomic::AtomicU64;\n+    use crate::sync::atomic::Ordering::*;\n+    use crate::sys::time;\n+    use crate::time::Duration;\n+\n+    pub(in crate::time) const ZERO: time::Instant = time::Instant::zero();\n+\n+    // bits 30 and 31 are never used since the nanoseconds part never exceeds 10^9\n+    const UNINITIALIZED: u64 = 0b11 << 30;\n+    static MONO: AtomicU64 = AtomicU64::new(UNINITIALIZED);\n+\n+    #[inline]\n+    pub(super) fn monotonize(raw: time::Instant) -> time::Instant {\n+        monotonize_impl(&MONO, raw)\n+    }\n+\n+    #[inline]\n+    pub(in crate::time) fn monotonize_impl(mono: &AtomicU64, raw: time::Instant) -> time::Instant {\n+        let delta = raw.checked_sub_instant(&ZERO).unwrap();\n+        let secs = delta.as_secs();\n+        // occupies no more than 30 bits (10^9 seconds)\n+        let nanos = delta.subsec_nanos() as u64;\n+\n+        // This wraps around every 136 years (2^32 seconds).\n+        // To detect backsliding we use wrapping arithmetic and declare forward steps smaller\n+        // than 2^31 seconds as expected and everything else as a backslide which will be\n+        // monotonized.\n+        // This could be a problem for programs that call instants at intervals greater\n+        // than 68 years. Interstellar probes may want to ensure that actually_monotonic() is true.\n+        let packed = (secs << 32) | nanos;\n+        let old = mono.load(Relaxed);\n+\n+        if old == UNINITIALIZED || packed.wrapping_sub(old) < u64::MAX / 2 {\n+            mono.store(packed, Relaxed);\n+            raw\n+        } else {\n+            // Backslide occurred. We reconstruct monotonized time from the upper 32 bit of the\n+            // passed in value and the 64bits loaded from the atomic\n+            let seconds_lower = old >> 32;\n+            let mut seconds_upper = secs & 0xffff_ffff_0000_0000;\n+            if secs & 0xffff_ffff > seconds_lower {\n+                // Backslide caused the lower 32bit of the seconds part to wrap.\n+                // This must be the case because the seconds part is larger even though\n+                // we are in the backslide branch, i.e. the seconds count should be smaller or equal.\n+                //\n+                // We assume that backslides are smaller than 2^32 seconds\n+                // which means we need to add 1 to the upper half to restore it.\n+                //\n+                // Example:\n+                // most recent observed time: 0xA1_0000_0000_0000_0000u128\n+                // bits stored in AtomicU64:     0x0000_0000_0000_0000u64\n+                // backslide by 1s\n+                // caller time is             0xA0_ffff_ffff_0000_0000u128\n+                // -> we can fix up the upper half time by adding 1 << 32\n+                seconds_upper = seconds_upper.wrapping_add(0x1_0000_0000);\n+            }\n+            let secs = seconds_upper | seconds_lower;\n+            let nanos = old as u32;\n+            ZERO.checked_add_duration(&Duration::new(secs, nanos)).unwrap()\n+        }\n+    }\n+}\n+\n+#[cfg(target_has_atomic = \"128\")]\n+pub mod inner {\n+    use crate::sync::atomic::AtomicU128;\n+    use crate::sync::atomic::Ordering::*;\n+    use crate::sys::time;\n+    use crate::time::Duration;\n+\n+    const ZERO: time::Instant = time::Instant::zero();\n+    static MONO: AtomicU128 = AtomicU128::new(0);\n+\n+    #[inline]\n+    pub(super) fn monotonize(raw: time::Instant) -> time::Instant {\n+        let delta = raw.checked_sub_instant(&ZERO).unwrap();\n+        // Split into seconds and nanos since Duration doesn't have a\n+        // constructor that takes an u128\n+        let secs = delta.as_secs() as u128;\n+        let nanos = delta.subsec_nanos() as u128;\n+        let timestamp: u128 = secs << 64 | nanos;\n+        let timestamp = MONO.fetch_max(timestamp, Relaxed).max(timestamp);\n+        let secs = (timestamp >> 64) as u64;\n+        let nanos = timestamp as u32;\n+        ZERO.checked_add_duration(&Duration::new(secs, nanos)).unwrap()\n+    }\n+}\n+\n+#[cfg(not(any(target_has_atomic = \"64\", target_has_atomic = \"128\")))]\n+pub mod inner {\n+    use crate::cmp;\n+    use crate::sys::time;\n+    use crate::sys_common::mutex::StaticMutex;\n+\n+    #[inline]\n+    pub(super) fn monotonize(os_now: time::Instant) -> time::Instant {\n+        static LOCK: StaticMutex = StaticMutex::new();\n+        static mut LAST_NOW: time::Instant = time::Instant::zero();\n+        unsafe {\n+            let _lock = LOCK.lock();\n+            let now = cmp::max(LAST_NOW, os_now);\n+            LAST_NOW = now;\n+            now\n+        }\n+    }\n+}"}, {"sha": "dc44c9346b6ef946be2cf61b92f22aacc5f37d9d", "filename": "library/std/src/time/tests.rs", "status": "modified", "additions": 98, "deletions": 2, "changes": 100, "blob_url": "https://github.com/rust-lang/rust/blob/a0035916e01d8e644ccd44554c57f0874cef8c8c/library%2Fstd%2Fsrc%2Ftime%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a0035916e01d8e644ccd44554c57f0874cef8c8c/library%2Fstd%2Fsrc%2Ftime%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Ftime%2Ftests.rs?ref=a0035916e01d8e644ccd44554c57f0874cef8c8c", "patch": "@@ -1,4 +1,6 @@\n use super::{Duration, Instant, SystemTime, UNIX_EPOCH};\n+#[cfg(not(target_arch = \"wasm32\"))]\n+use test::{black_box, Bencher};\n \n macro_rules! assert_almost_eq {\n     ($a:expr, $b:expr) => {{\n@@ -13,8 +15,34 @@ macro_rules! assert_almost_eq {\n #[test]\n fn instant_monotonic() {\n     let a = Instant::now();\n-    let b = Instant::now();\n-    assert!(b >= a);\n+    loop {\n+        let b = Instant::now();\n+        assert!(b >= a);\n+        if b > a {\n+            break;\n+        }\n+    }\n+}\n+\n+#[test]\n+#[cfg(not(target_arch = \"wasm32\"))]\n+fn instant_monotonic_concurrent() -> crate::thread::Result<()> {\n+    let threads: Vec<_> = (0..8)\n+        .map(|_| {\n+            crate::thread::spawn(|| {\n+                let mut old = Instant::now();\n+                for _ in 0..5_000_000 {\n+                    let new = Instant::now();\n+                    assert!(new >= old);\n+                    old = new;\n+                }\n+            })\n+        })\n+        .collect();\n+    for t in threads {\n+        t.join()?;\n+    }\n+    Ok(())\n }\n \n #[test]\n@@ -163,3 +191,71 @@ fn since_epoch() {\n     let hundred_twenty_years = thirty_years * 4;\n     assert!(a < hundred_twenty_years);\n }\n+\n+#[cfg(all(target_has_atomic = \"64\", not(target_has_atomic = \"128\")))]\n+#[test]\n+fn monotonizer_wrapping_backslide() {\n+    use super::monotonic::inner::{monotonize_impl, ZERO};\n+    use core::sync::atomic::AtomicU64;\n+\n+    let reference = AtomicU64::new(0);\n+\n+    let time = match ZERO.checked_add_duration(&Duration::from_secs(0xffff_ffff)) {\n+        Some(time) => time,\n+        None => {\n+            // platform cannot represent u32::MAX seconds so it won't have to deal with this kind\n+            // of overflow either\n+            return;\n+        }\n+    };\n+\n+    let monotonized = monotonize_impl(&reference, time);\n+    let expected = ZERO.checked_add_duration(&Duration::from_secs(1 << 32)).unwrap();\n+    assert_eq!(\n+        monotonized, expected,\n+        \"64bit monotonizer should handle overflows in the seconds part\"\n+    );\n+}\n+\n+macro_rules! bench_instant_threaded {\n+    ($bench_name:ident, $thread_count:expr) => {\n+        #[bench]\n+        #[cfg(not(target_arch = \"wasm32\"))]\n+        fn $bench_name(b: &mut Bencher) -> crate::thread::Result<()> {\n+            use crate::sync::atomic::{AtomicBool, Ordering};\n+            use crate::sync::Arc;\n+\n+            let running = Arc::new(AtomicBool::new(true));\n+\n+            let threads: Vec<_> = (0..$thread_count)\n+                .map(|_| {\n+                    let flag = Arc::clone(&running);\n+                    crate::thread::spawn(move || {\n+                        while flag.load(Ordering::Relaxed) {\n+                            black_box(Instant::now());\n+                        }\n+                    })\n+                })\n+                .collect();\n+\n+            b.iter(|| {\n+                let a = Instant::now();\n+                let b = Instant::now();\n+                assert!(b >= a);\n+            });\n+\n+            running.store(false, Ordering::Relaxed);\n+\n+            for t in threads {\n+                t.join()?;\n+            }\n+            Ok(())\n+        }\n+    };\n+}\n+\n+bench_instant_threaded!(instant_contention_01_threads, 0);\n+bench_instant_threaded!(instant_contention_02_threads, 1);\n+bench_instant_threaded!(instant_contention_04_threads, 3);\n+bench_instant_threaded!(instant_contention_08_threads, 7);\n+bench_instant_threaded!(instant_contention_16_threads, 15);"}]}