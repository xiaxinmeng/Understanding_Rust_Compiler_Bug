{"sha": "a9e82e145e61f4b9825b4622f78ea9364387ae70", "node_id": "MDY6Q29tbWl0NzI0NzEyOmE5ZTgyZTE0NWU2MWY0Yjk4MjViNDYyMmY3OGVhOTM2NDM4N2FlNzA=", "commit": {"author": {"name": "Kevin Butler", "email": "haqkrs@gmail.com", "date": "2014-06-20T00:30:12Z"}, "committer": {"name": "Kevin Butler", "email": "haqkrs@gmail.com", "date": "2014-07-04T00:26:48Z"}, "message": "liburl: rename and move path_from_str to Path::parse_str.\n\nurl::path_from_str => url::Path::parse_str\n\nThe FromStr trait still works, but its confusing to have a path_from_str\nfree function that retuns a Result, while the regular from_str style\nfunctions return an Option, hence the rename to indicate a Result.\n\n[breaking-change]", "tree": {"sha": "da7bedb668173a37ea74037e3a44cd08ebd0d8b7", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/da7bedb668173a37ea74037e3a44cd08ebd0d8b7"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a9e82e145e61f4b9825b4622f78ea9364387ae70", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a9e82e145e61f4b9825b4622f78ea9364387ae70", "html_url": "https://github.com/rust-lang/rust/commit/a9e82e145e61f4b9825b4622f78ea9364387ae70", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a9e82e145e61f4b9825b4622f78ea9364387ae70/comments", "author": {"login": "Ryman", "id": 994978, "node_id": "MDQ6VXNlcjk5NDk3OA==", "avatar_url": "https://avatars.githubusercontent.com/u/994978?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Ryman", "html_url": "https://github.com/Ryman", "followers_url": "https://api.github.com/users/Ryman/followers", "following_url": "https://api.github.com/users/Ryman/following{/other_user}", "gists_url": "https://api.github.com/users/Ryman/gists{/gist_id}", "starred_url": "https://api.github.com/users/Ryman/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Ryman/subscriptions", "organizations_url": "https://api.github.com/users/Ryman/orgs", "repos_url": "https://api.github.com/users/Ryman/repos", "events_url": "https://api.github.com/users/Ryman/events{/privacy}", "received_events_url": "https://api.github.com/users/Ryman/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Ryman", "id": 994978, "node_id": "MDQ6VXNlcjk5NDk3OA==", "avatar_url": "https://avatars.githubusercontent.com/u/994978?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Ryman", "html_url": "https://github.com/Ryman", "followers_url": "https://api.github.com/users/Ryman/followers", "following_url": "https://api.github.com/users/Ryman/following{/other_user}", "gists_url": "https://api.github.com/users/Ryman/gists{/gist_id}", "starred_url": "https://api.github.com/users/Ryman/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Ryman/subscriptions", "organizations_url": "https://api.github.com/users/Ryman/orgs", "repos_url": "https://api.github.com/users/Ryman/repos", "events_url": "https://api.github.com/users/Ryman/events{/privacy}", "received_events_url": "https://api.github.com/users/Ryman/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2194fd7569b227ba083c4f27e156af939e061c1b", "url": "https://api.github.com/repos/rust-lang/rust/commits/2194fd7569b227ba083c4f27e156af939e061c1b", "html_url": "https://github.com/rust-lang/rust/commit/2194fd7569b227ba083c4f27e156af939e061c1b"}], "stats": {"total": 60, "additions": 34, "deletions": 26}, "files": [{"sha": "dbdd7a6aa1736318da9facfccdb5c8b676bac878", "filename": "src/liburl/lib.rs", "status": "modified", "additions": 34, "deletions": 26, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/a9e82e145e61f4b9825b4622f78ea9364387ae70/src%2Fliburl%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a9e82e145e61f4b9825b4622f78ea9364387ae70/src%2Fliburl%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliburl%2Flib.rs?ref=a9e82e145e61f4b9825b4622f78ea9364387ae70", "patch": "@@ -60,7 +60,7 @@ pub struct Url {\n     /// `vec!((\"baz\".to_string(), \"qux\".to_string()))` represents the fragment\n     /// `baz=qux` in the above example.\n     pub query: Query,\n-    /// The fragment component, such as `quz`.  Doesn't include the leading `#` character.\n+    /// The fragment component, such as `quz`. Not including the leading `#` character.\n     pub fragment: Option<String>\n }\n \n@@ -72,7 +72,7 @@ pub struct Path {\n     /// `vec!((\"baz\".to_string(), \"qux\".to_string()))` represents the fragment\n     /// `baz=qux` in the above example.\n     pub query: Query,\n-    /// The fragment component, such as `quz`.  Doesn't include the leading `#` character.\n+    /// The fragment component, such as `quz`. Not including the leading `#` character.\n     pub fragment: Option<String>\n }\n \n@@ -152,6 +152,30 @@ impl Path {\n             fragment: fragment,\n         }\n     }\n+\n+    /// Parses a URL path, converting it from a string to a `Path` representation.\n+    ///\n+    /// # Arguments\n+    /// * rawpath - a string representing the path component of a URL.\n+    ///\n+    /// # Return value\n+    ///\n+    /// `Err(e)` if the string did not represent a valid URL path, where `e` is a\n+    /// `String` error message. Otherwise, `Ok(p)` where `p` is a `Path` struct\n+    /// representing the URL path.\n+    pub fn parse(rawpath: &str) -> Result<Path, String> {\n+        let (path, rest) = try!(get_path(rawpath, false));\n+\n+        // query and fragment\n+        let (query, fragment) = try!(get_query_fragment(rest.as_slice()));\n+\n+        Ok(Path{ path: path, query: query, fragment: fragment })\n+    }\n+}\n+\n+#[deprecated=\"use `Path::parse`\"]\n+pub fn path_from_str(s: &str) -> Result<Path, String> {\n+    Path::parse(s)\n }\n \n impl UserInfo {\n@@ -763,21 +787,6 @@ fn get_query_fragment(rawurl: &str) ->\n     return Ok((query_from_str(q.as_slice()), f));\n }\n \n-pub fn path_from_str(rawpath: &str) -> Result<Path, String> {\n-    let (path, rest) = match get_path(rawpath, false) {\n-        Ok(val) => val,\n-        Err(e) => return Err(e)\n-    };\n-\n-    // query and fragment\n-    let (query, fragment) = match get_query_fragment(rest.as_slice()) {\n-        Ok(val) => val,\n-        Err(e) => return Err(e),\n-    };\n-\n-    Ok(Path{ path: path, query: query, fragment: fragment })\n-}\n-\n impl FromStr for Url {\n     fn from_str(s: &str) -> Option<Url> {\n         match Url::parse(s) {\n@@ -789,7 +798,7 @@ impl FromStr for Url {\n \n impl FromStr for Path {\n     fn from_str(s: &str) -> Option<Path> {\n-        match path_from_str(s) {\n+        match Path::parse(s) {\n             Ok(path) => Some(path),\n             Err(_) => None\n         }\n@@ -957,9 +966,8 @@ fn test_get_path() {\n \n #[cfg(test)]\n mod tests {\n-    use {encode_form_urlencoded, decode_form_urlencoded,\n-         decode, encode, encode_component, decode_component,\n-         path_from_str, UserInfo, get_scheme, Url};\n+    use {encode_form_urlencoded, decode_form_urlencoded, decode, encode,\n+        encode_component, decode_component, UserInfo, get_scheme, Url, Path};\n \n     use std::collections::HashMap;\n \n@@ -982,7 +990,7 @@ mod tests {\n     fn test_path_parse() {\n         let path = \"/doc/~u?s=v#something\";\n \n-        let up = path_from_str(path);\n+        let up = from_str::<Path>(path);\n         let u = up.unwrap();\n         assert_eq!(&u.path, &\"/doc/~u\".to_string());\n         assert_eq!(&u.query, &vec!((\"s\".to_string(), \"v\".to_string())));\n@@ -1000,7 +1008,7 @@ mod tests {\n     #[test]\n     fn test_path_parse_host_slash() {\n         let pathstr = \"/\";\n-        let path = path_from_str(pathstr).unwrap();\n+        let path = from_str::<Path>(pathstr).unwrap();\n         assert!(path.path == \"/\".to_string());\n     }\n \n@@ -1031,7 +1039,7 @@ mod tests {\n     #[test]\n     fn test_path_with_underscores() {\n         let pathstr = \"/file_name.html\";\n-        let path = path_from_str(pathstr).unwrap();\n+        let path = from_str::<Path>(pathstr).unwrap();\n         assert!(path.path == \"/file_name.html\".to_string());\n     }\n \n@@ -1045,7 +1053,7 @@ mod tests {\n     #[test]\n     fn test_path_with_dashes() {\n         let pathstr = \"/file-name.html\";\n-        let path = path_from_str(pathstr).unwrap();\n+        let path = from_str::<Path>(pathstr).unwrap();\n         assert!(path.path == \"/file-name.html\".to_string());\n     }\n \n@@ -1132,7 +1140,7 @@ mod tests {\n     #[test]\n     fn test_path_component_encoding() {\n         let path = \"/doc%20uments?ba%25d%20=%23%26%2B\";\n-        let p = path_from_str(path).unwrap();\n+        let p = from_str::<Path>(path).unwrap();\n         assert!(p.path == \"/doc uments\".to_string());\n         assert!(p.query == vec!((\"ba%d \".to_string(), \"#&+\".to_string())));\n     }"}]}