{"sha": "74e6262ce4ad8efb8d0addd461fdf9d25bea9538", "node_id": "MDY6Q29tbWl0NzI0NzEyOjc0ZTYyNjJjZTRhZDhlZmI4ZDBhZGRkNDYxZmRmOWQyNWJlYTk1Mzg=", "commit": {"author": {"name": "Caleb Zulawski", "email": "caleb.zulawski@gmail.com", "date": "2021-06-13T19:47:32Z"}, "committer": {"name": "Caleb Zulawski", "email": "caleb.zulawski@gmail.com", "date": "2021-06-13T19:47:32Z"}, "message": "Add min/max/clamp", "tree": {"sha": "49de06563f151149ae13996cd6c2aa0ed9964fdd", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/49de06563f151149ae13996cd6c2aa0ed9964fdd"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/74e6262ce4ad8efb8d0addd461fdf9d25bea9538", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/74e6262ce4ad8efb8d0addd461fdf9d25bea9538", "html_url": "https://github.com/rust-lang/rust/commit/74e6262ce4ad8efb8d0addd461fdf9d25bea9538", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/74e6262ce4ad8efb8d0addd461fdf9d25bea9538/comments", "author": {"login": "calebzulawski", "id": 563826, "node_id": "MDQ6VXNlcjU2MzgyNg==", "avatar_url": "https://avatars.githubusercontent.com/u/563826?v=4", "gravatar_id": "", "url": "https://api.github.com/users/calebzulawski", "html_url": "https://github.com/calebzulawski", "followers_url": "https://api.github.com/users/calebzulawski/followers", "following_url": "https://api.github.com/users/calebzulawski/following{/other_user}", "gists_url": "https://api.github.com/users/calebzulawski/gists{/gist_id}", "starred_url": "https://api.github.com/users/calebzulawski/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/calebzulawski/subscriptions", "organizations_url": "https://api.github.com/users/calebzulawski/orgs", "repos_url": "https://api.github.com/users/calebzulawski/repos", "events_url": "https://api.github.com/users/calebzulawski/events{/privacy}", "received_events_url": "https://api.github.com/users/calebzulawski/received_events", "type": "User", "site_admin": false}, "committer": {"login": "calebzulawski", "id": 563826, "node_id": "MDQ6VXNlcjU2MzgyNg==", "avatar_url": "https://avatars.githubusercontent.com/u/563826?v=4", "gravatar_id": "", "url": "https://api.github.com/users/calebzulawski", "html_url": "https://github.com/calebzulawski", "followers_url": "https://api.github.com/users/calebzulawski/followers", "following_url": "https://api.github.com/users/calebzulawski/following{/other_user}", "gists_url": "https://api.github.com/users/calebzulawski/gists{/gist_id}", "starred_url": "https://api.github.com/users/calebzulawski/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/calebzulawski/subscriptions", "organizations_url": "https://api.github.com/users/calebzulawski/orgs", "repos_url": "https://api.github.com/users/calebzulawski/repos", "events_url": "https://api.github.com/users/calebzulawski/events{/privacy}", "received_events_url": "https://api.github.com/users/calebzulawski/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b936f34a5c4144db9135baaa07a1c12f73b5d316", "url": "https://api.github.com/repos/rust-lang/rust/commits/b936f34a5c4144db9135baaa07a1c12f73b5d316", "html_url": "https://github.com/rust-lang/rust/commit/b936f34a5c4144db9135baaa07a1c12f73b5d316"}], "stats": {"total": 132, "additions": 132, "deletions": 0}, "files": [{"sha": "7061b9b06748be00c244f615f3e1ae782baac8af", "filename": "crates/core_simd/src/vector/float.rs", "status": "modified", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/74e6262ce4ad8efb8d0addd461fdf9d25bea9538/crates%2Fcore_simd%2Fsrc%2Fvector%2Ffloat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74e6262ce4ad8efb8d0addd461fdf9d25bea9538/crates%2Fcore_simd%2Fsrc%2Fvector%2Ffloat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcore_simd%2Fsrc%2Fvector%2Ffloat.rs?ref=74e6262ce4ad8efb8d0addd461fdf9d25bea9538", "patch": "@@ -136,6 +136,47 @@ macro_rules! impl_float_vector {\n                 let magnitude = self.to_bits() & !Self::splat(-0.).to_bits();\n                 Self::from_bits(sign_bit | magnitude)\n             }\n+\n+            /// Returns the minimum of each lane.\n+            ///\n+            /// If one of the values is `NAN`, then the other value is returned.\n+            #[inline]\n+            pub fn min(self, other: Self) -> Self {\n+                // TODO consider using an intrinsic\n+                self.is_nan().select(\n+                    other,\n+                    self.lanes_ge(other).select(other, self)\n+                )\n+            }\n+\n+            /// Returns the maximum of each lane.\n+            ///\n+            /// If one of the values is `NAN`, then the other value is returned.\n+            #[inline]\n+            pub fn max(self, other: Self) -> Self {\n+                // TODO consider using an intrinsic\n+                self.is_nan().select(\n+                    other,\n+                    self.lanes_le(other).select(other, self)\n+                )\n+            }\n+\n+            /// Restrict each lane to a certain interval unless it is NaN.\n+            /// \n+            /// For each lane in `self`, returns the corresponding lane in `max` if the lane is\n+            /// greater than `max`, and the corresponding lane in `min` if the lane is less\n+            /// than `min`.  Otherwise returns the lane in `self`.\n+            #[inline]\n+            pub fn clamp(self, min: Self, max: Self) -> Self {\n+                assert!(\n+                    min.lanes_le(max).all(),\n+                    \"each lane in `min` must be less than or equal to the corresponding lane in `max`\",\n+                );\n+                let mut x = self;\n+                x = x.lanes_lt(min).select(min, x);\n+                x = x.lanes_gt(max).select(max, x);\n+                x\n+            }\n         }\n     };\n }"}, {"sha": "8ef2edc8370ab4ad828cf128076381b8729201de", "filename": "crates/core_simd/tests/ops_macros.rs", "status": "modified", "additions": 70, "deletions": 0, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/74e6262ce4ad8efb8d0addd461fdf9d25bea9538/crates%2Fcore_simd%2Ftests%2Fops_macros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74e6262ce4ad8efb8d0addd461fdf9d25bea9538/crates%2Fcore_simd%2Ftests%2Fops_macros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcore_simd%2Ftests%2Fops_macros.rs?ref=74e6262ce4ad8efb8d0addd461fdf9d25bea9538", "patch": "@@ -483,6 +483,76 @@ macro_rules! impl_float_tests {\n                     )\n                 }\n \n+                fn min<const LANES: usize>() {\n+                    // Regular conditions (both values aren't zero)\n+                    test_helpers::test_binary_elementwise(\n+                        &Vector::<LANES>::min,\n+                        &Scalar::min,\n+                        // Reject the case where both values are zero with different signs\n+                        &|a, b| {\n+                            for (a, b) in a.iter().zip(b.iter()) {\n+                                if *a == 0. && *b == 0. && a.signum() != b.signum() {\n+                                    return false;\n+                                }\n+                            }\n+                            true\n+                        }\n+                    );\n+\n+                    // Special case where both values are zero\n+                    let p_zero = Vector::<LANES>::splat(0.);\n+                    let n_zero = Vector::<LANES>::splat(-0.);\n+                    assert!(p_zero.min(n_zero).to_array().iter().all(|x| *x == 0.));\n+                    assert!(n_zero.min(p_zero).to_array().iter().all(|x| *x == 0.));\n+                }\n+\n+                fn max<const LANES: usize>() {\n+                    // Regular conditions (both values aren't zero)\n+                    test_helpers::test_binary_elementwise(\n+                        &Vector::<LANES>::max,\n+                        &Scalar::max,\n+                        // Reject the case where both values are zero with different signs\n+                        &|a, b| {\n+                            for (a, b) in a.iter().zip(b.iter()) {\n+                                if *a == 0. && *b == 0. && a.signum() != b.signum() {\n+                                    return false;\n+                                }\n+                            }\n+                            true\n+                        }\n+                    );\n+\n+                    // Special case where both values are zero\n+                    let p_zero = Vector::<LANES>::splat(0.);\n+                    let n_zero = Vector::<LANES>::splat(-0.);\n+                    assert!(p_zero.min(n_zero).to_array().iter().all(|x| *x == 0.));\n+                    assert!(n_zero.min(p_zero).to_array().iter().all(|x| *x == 0.));\n+                }\n+\n+                fn clamp<const LANES: usize>() {\n+                    test_helpers::test_3(&|value: [Scalar; LANES], mut min: [Scalar; LANES], mut max: [Scalar; LANES]| {\n+                        for (min, max) in min.iter_mut().zip(max.iter_mut()) {\n+                            if max < min {\n+                                core::mem::swap(min, max);\n+                            }\n+                            if min.is_nan() {\n+                                *min = Scalar::NEG_INFINITY;\n+                            }\n+                            if max.is_nan() {\n+                                *max = Scalar::INFINITY;\n+                            }\n+                        }\n+\n+                        let mut result_scalar = [Scalar::default(); LANES];\n+                        for i in 0..LANES {\n+                            result_scalar[i] = value[i].clamp(min[i], max[i]);\n+                        }\n+                        let result_vector = Vector::from_array(value).clamp(min.into(), max.into()).to_array();\n+                        test_helpers::prop_assert_biteq!(result_scalar, result_vector);\n+                        Ok(())\n+                    })\n+                }\n+\n                 fn horizontal_sum<const LANES: usize>() {\n                     test_helpers::test_1(&|x| {\n                         test_helpers::prop_assert_biteq! ("}, {"sha": "ff6d30a1afb71ae1e9d52471ec3970f7121021e7", "filename": "crates/test_helpers/src/lib.rs", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/74e6262ce4ad8efb8d0addd461fdf9d25bea9538/crates%2Ftest_helpers%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74e6262ce4ad8efb8d0addd461fdf9d25bea9538/crates%2Ftest_helpers%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Ftest_helpers%2Fsrc%2Flib.rs?ref=74e6262ce4ad8efb8d0addd461fdf9d25bea9538", "patch": "@@ -97,6 +97,27 @@ pub fn test_2<A: core::fmt::Debug + DefaultStrategy, B: core::fmt::Debug + Defau\n         .unwrap();\n }\n \n+/// Test a function that takes two values.\n+pub fn test_3<\n+    A: core::fmt::Debug + DefaultStrategy,\n+    B: core::fmt::Debug + DefaultStrategy,\n+    C: core::fmt::Debug + DefaultStrategy,\n+>(\n+    f: &dyn Fn(A, B, C) -> proptest::test_runner::TestCaseResult,\n+) {\n+    let mut runner = proptest::test_runner::TestRunner::default();\n+    runner\n+        .run(\n+            &(\n+                A::default_strategy(),\n+                B::default_strategy(),\n+                C::default_strategy(),\n+            ),\n+            |(a, b, c)| f(a, b, c),\n+        )\n+        .unwrap();\n+}\n+\n /// Test a unary vector function against a unary scalar function, applied elementwise.\n #[inline(never)]\n pub fn test_unary_elementwise<Scalar, ScalarResult, Vector, VectorResult, const LANES: usize>("}]}