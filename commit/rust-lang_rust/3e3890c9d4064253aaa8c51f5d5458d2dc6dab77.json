{"sha": "3e3890c9d4064253aaa8c51f5d5458d2dc6dab77", "node_id": "C_kwDOAAsO6NoAKDNlMzg5MGM5ZDQwNjQyNTNhYWE4YzUxZjVkNTQ1OGQyZGM2ZGFiNzc", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-11-08T08:21:51Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-11-08T08:21:51Z"}, "message": "Auto merge of #90675 - camelid:cleanup-impl, r=jyn514\n\nrustdoc: Cleanup `clean::Impl` and other parts of `clean`\n\nThis PR cleans up and reduces the size of `clean::Impl`, makes some other small performance improvements, and removes some Clean impls that are either unnecessary or potentially confusing.\n\nr? `@jyn514`", "tree": {"sha": "d65893418fc5a0d150c07c916222f1bafe6cef1b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d65893418fc5a0d150c07c916222f1bafe6cef1b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3e3890c9d4064253aaa8c51f5d5458d2dc6dab77", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3e3890c9d4064253aaa8c51f5d5458d2dc6dab77", "html_url": "https://github.com/rust-lang/rust/commit/3e3890c9d4064253aaa8c51f5d5458d2dc6dab77", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3e3890c9d4064253aaa8c51f5d5458d2dc6dab77/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b3074819f615758da44a667bf3cb98c59227e2f9", "url": "https://api.github.com/repos/rust-lang/rust/commits/b3074819f615758da44a667bf3cb98c59227e2f9", "html_url": "https://github.com/rust-lang/rust/commit/b3074819f615758da44a667bf3cb98c59227e2f9"}, {"sha": "b5817fada28cf21199ce4911b5cbde8bd1007c0d", "url": "https://api.github.com/repos/rust-lang/rust/commits/b5817fada28cf21199ce4911b5cbde8bd1007c0d", "html_url": "https://github.com/rust-lang/rust/commit/b5817fada28cf21199ce4911b5cbde8bd1007c0d"}], "stats": {"total": 301, "additions": 143, "deletions": 158}, "files": [{"sha": "2ccf17387d1c701febec22a676ea264bd07bb845", "filename": "src/librustdoc/clean/auto_trait.rs", "status": "modified", "additions": 5, "deletions": 7, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/3e3890c9d4064253aaa8c51f5d5458d2dc6dab77/src%2Flibrustdoc%2Fclean%2Fauto_trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e3890c9d4064253aaa8c51f5d5458d2dc6dab77/src%2Flibrustdoc%2Fclean%2Fauto_trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fauto_trait.rs?ref=3e3890c9d4064253aaa8c51f5d5458d2dc6dab77", "patch": "@@ -76,17 +76,17 @@ impl<'a, 'tcx> AutoTraitFinder<'a, 'tcx> {\n             new_generics\n         });\n \n-        let negative_polarity;\n+        let polarity;\n         let new_generics = match result {\n             AutoTraitResult::PositiveImpl(new_generics) => {\n-                negative_polarity = false;\n+                polarity = ty::ImplPolarity::Positive;\n                 if discard_positive_impl {\n                     return None;\n                 }\n                 new_generics\n             }\n             AutoTraitResult::NegativeImpl => {\n-                negative_polarity = true;\n+                polarity = ty::ImplPolarity::Negative;\n \n                 // For negative impls, we use the generic params, but *not* the predicates,\n                 // from the original type. Otherwise, the displayed impl appears to be a\n@@ -115,15 +115,13 @@ impl<'a, 'tcx> AutoTraitFinder<'a, 'tcx> {\n             visibility: Inherited,\n             def_id: ItemId::Auto { trait_: trait_def_id, for_: item_def_id },\n             kind: box ImplItem(Impl {\n-                span: Span::dummy(),\n                 unsafety: hir::Unsafety::Normal,\n                 generics: new_generics,\n                 trait_: Some(trait_ref.clean(self.cx)),\n                 for_: ty.clean(self.cx),\n                 items: Vec::new(),\n-                negative_polarity,\n-                synthetic: true,\n-                blanket_impl: None,\n+                polarity,\n+                kind: ImplKind::Auto,\n             }),\n             cfg: None,\n         })"}, {"sha": "f44589f60675f5dbe8bb38c358121be812d540d1", "filename": "src/librustdoc/clean/blanket_impl.rs", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/3e3890c9d4064253aaa8c51f5d5458d2dc6dab77/src%2Flibrustdoc%2Fclean%2Fblanket_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e3890c9d4064253aaa8c51f5d5458d2dc6dab77/src%2Flibrustdoc%2Fclean%2Fblanket_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fblanket_impl.rs?ref=3e3890c9d4064253aaa8c51f5d5458d2dc6dab77", "patch": "@@ -106,7 +106,6 @@ impl<'a, 'tcx> BlanketImplFinder<'a, 'tcx> {\n                     visibility: Inherited,\n                     def_id: ItemId::Blanket { impl_id: impl_def_id, for_: item_def_id },\n                     kind: box ImplItem(Impl {\n-                        span: Span::new(self.cx.tcx.def_span(impl_def_id)),\n                         unsafety: hir::Unsafety::Normal,\n                         generics: (\n                             self.cx.tcx.generics_of(impl_def_id),\n@@ -122,11 +121,10 @@ impl<'a, 'tcx> BlanketImplFinder<'a, 'tcx> {\n                             .tcx\n                             .associated_items(impl_def_id)\n                             .in_definition_order()\n-                            .collect::<Vec<_>>()\n-                            .clean(self.cx),\n-                        negative_polarity: false,\n-                        synthetic: false,\n-                        blanket_impl: Some(box trait_ref.self_ty().clean(self.cx)),\n+                            .map(|x| x.clean(self.cx))\n+                            .collect::<Vec<_>>(),\n+                        polarity: ty::ImplPolarity::Positive,\n+                        kind: ImplKind::Blanket(box trait_ref.self_ty().clean(self.cx)),\n                     }),\n                     cfg: None,\n                 });"}, {"sha": "d670288270a403cfb4b4c2757a56b36a973ed9d0", "filename": "src/librustdoc/clean/inline.rs", "status": "modified", "additions": 11, "deletions": 13, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/3e3890c9d4064253aaa8c51f5d5458d2dc6dab77/src%2Flibrustdoc%2Fclean%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e3890c9d4064253aaa8c51f5d5458d2dc6dab77/src%2Flibrustdoc%2Fclean%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Finline.rs?ref=3e3890c9d4064253aaa8c51f5d5458d2dc6dab77", "patch": "@@ -14,7 +14,9 @@ use rustc_middle::ty::{self, TyCtxt};\n use rustc_span::hygiene::MacroKind;\n use rustc_span::symbol::{kw, sym, Symbol};\n \n-use crate::clean::{self, utils, Attributes, AttributesExt, ItemId, NestedAttributesExt, Type};\n+use crate::clean::{\n+    self, utils, Attributes, AttributesExt, ImplKind, ItemId, NestedAttributesExt, Type,\n+};\n use crate::core::DocContext;\n use crate::formats::item_type::ItemType;\n \n@@ -242,7 +244,7 @@ fn build_enum(cx: &mut DocContext<'_>, did: DefId) -> clean::Enum {\n     clean::Enum {\n         generics: (cx.tcx.generics_of(did), predicates).clean(cx),\n         variants_stripped: false,\n-        variants: cx.tcx.adt_def(did).variants.clean(cx),\n+        variants: cx.tcx.adt_def(did).variants.iter().map(|v| v.clean(cx)).collect(),\n     }\n }\n \n@@ -253,7 +255,7 @@ fn build_struct(cx: &mut DocContext<'_>, did: DefId) -> clean::Struct {\n     clean::Struct {\n         struct_type: variant.ctor_kind,\n         generics: (cx.tcx.generics_of(did), predicates).clean(cx),\n-        fields: variant.fields.clean(cx),\n+        fields: variant.fields.iter().map(|x| x.clean(cx)).collect(),\n         fields_stripped: false,\n     }\n }\n@@ -262,11 +264,9 @@ fn build_union(cx: &mut DocContext<'_>, did: DefId) -> clean::Union {\n     let predicates = cx.tcx.explicit_predicates_of(did);\n     let variant = cx.tcx.adt_def(did).non_enum_variant();\n \n-    clean::Union {\n-        generics: (cx.tcx.generics_of(did), predicates).clean(cx),\n-        fields: variant.fields.clean(cx),\n-        fields_stripped: false,\n-    }\n+    let generics = (cx.tcx.generics_of(did), predicates).clean(cx);\n+    let fields = variant.fields.iter().map(|x| x.clean(cx)).collect();\n+    clean::Union { generics, fields, fields_stripped: false }\n }\n \n fn build_type_alias(cx: &mut DocContext<'_>, did: DefId) -> clean::Typedef {\n@@ -446,7 +446,7 @@ crate fn build_impl(\n         ),\n     };\n     let polarity = tcx.impl_polarity(did);\n-    let trait_ = associated_trait.clean(cx);\n+    let trait_ = associated_trait.map(|t| t.clean(cx));\n     if trait_.as_ref().map(|t| t.def_id()) == tcx.lang_items().deref_trait() {\n         super::build_deref_target_impls(cx, &trait_items, ret);\n     }\n@@ -490,15 +490,13 @@ crate fn build_impl(\n         did,\n         None,\n         clean::ImplItem(clean::Impl {\n-            span: clean::types::rustc_span(did, cx.tcx),\n             unsafety: hir::Unsafety::Normal,\n             generics,\n             trait_,\n             for_,\n             items: trait_items,\n-            negative_polarity: polarity.clean(cx),\n-            synthetic: false,\n-            blanket_impl: None,\n+            polarity,\n+            kind: ImplKind::Normal,\n         }),\n         box merged_attrs,\n         cx,"}, {"sha": "9d893f3d06d51978f3f3c05541253224f949da1f", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 47, "deletions": 87, "changes": 134, "blob_url": "https://github.com/rust-lang/rust/blob/3e3890c9d4064253aaa8c51f5d5458d2dc6dab77/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e3890c9d4064253aaa8c51f5d5458d2dc6dab77/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=3e3890c9d4064253aaa8c51f5d5458d2dc6dab77", "patch": "@@ -16,7 +16,6 @@ use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n use rustc_hir as hir;\n use rustc_hir::def::{CtorKind, DefKind, Res};\n use rustc_hir::def_id::{DefId, CRATE_DEF_INDEX, LOCAL_CRATE};\n-use rustc_index::vec::{Idx, IndexVec};\n use rustc_infer::infer::region_constraints::{Constraint, RegionConstraintData};\n use rustc_middle::middle::resolve_lifetime as rl;\n use rustc_middle::ty::fold::TypeFolder;\n@@ -34,7 +33,6 @@ use std::assert_matches::assert_matches;\n use std::collections::hash_map::Entry;\n use std::default::Default;\n use std::hash::Hash;\n-use std::rc::Rc;\n use std::{mem, vec};\n \n use crate::core::{self, DocContext, ImplTraitParam};\n@@ -56,36 +54,6 @@ crate trait Clean<T> {\n     fn clean(&self, cx: &mut DocContext<'_>) -> T;\n }\n \n-impl<T: Clean<U>, U> Clean<Vec<U>> for [T] {\n-    fn clean(&self, cx: &mut DocContext<'_>) -> Vec<U> {\n-        self.iter().map(|x| x.clean(cx)).collect()\n-    }\n-}\n-\n-impl<T: Clean<U>, U, V: Idx> Clean<IndexVec<V, U>> for IndexVec<V, T> {\n-    fn clean(&self, cx: &mut DocContext<'_>) -> IndexVec<V, U> {\n-        self.iter().map(|x| x.clean(cx)).collect()\n-    }\n-}\n-\n-impl<T: Clean<U>, U> Clean<U> for &T {\n-    fn clean(&self, cx: &mut DocContext<'_>) -> U {\n-        (**self).clean(cx)\n-    }\n-}\n-\n-impl<T: Clean<U>, U> Clean<U> for Rc<T> {\n-    fn clean(&self, cx: &mut DocContext<'_>) -> U {\n-        (**self).clean(cx)\n-    }\n-}\n-\n-impl<T: Clean<U>, U> Clean<Option<U>> for Option<T> {\n-    fn clean(&self, cx: &mut DocContext<'_>) -> Option<U> {\n-        self.as_ref().map(|v| v.clean(cx))\n-    }\n-}\n-\n impl Clean<Item> for doctree::Module<'_> {\n     fn clean(&self, cx: &mut DocContext<'_>) -> Item {\n         let mut items: Vec<Item> = vec![];\n@@ -287,14 +255,14 @@ impl Clean<WherePredicate> for hir::WherePredicate<'_> {\n                     .collect();\n                 WherePredicate::BoundPredicate {\n                     ty: wbp.bounded_ty.clean(cx),\n-                    bounds: wbp.bounds.clean(cx),\n+                    bounds: wbp.bounds.iter().map(|x| x.clean(cx)).collect(),\n                     bound_params,\n                 }\n             }\n \n             hir::WherePredicate::RegionPredicate(ref wrp) => WherePredicate::RegionPredicate {\n                 lifetime: wrp.lifetime.clean(cx),\n-                bounds: wrp.bounds.clean(cx),\n+                bounds: wrp.bounds.iter().map(|x| x.clean(cx)).collect(),\n             },\n \n             hir::WherePredicate::EqPredicate(ref wrp) => {\n@@ -459,8 +427,8 @@ impl Clean<GenericParamDef> for hir::GenericParam<'_> {\n                 self.name.ident().name,\n                 GenericParamDefKind::Type {\n                     did: cx.tcx.hir().local_def_id(self.hir_id).to_def_id(),\n-                    bounds: self.bounds.clean(cx),\n-                    default: default.clean(cx).map(Box::new),\n+                    bounds: self.bounds.iter().map(|x| x.clean(cx)).collect(),\n+                    default: default.map(|t| t.clean(cx)).map(Box::new),\n                     synthetic,\n                 },\n             ),\n@@ -530,8 +498,10 @@ impl Clean<Generics> for hir::Generics<'_> {\n         }\n         params.extend(impl_trait_params);\n \n-        let mut generics =\n-            Generics { params, where_predicates: self.where_clause.predicates.clean(cx) };\n+        let mut generics = Generics {\n+            params,\n+            where_predicates: self.where_clause.predicates.iter().map(|x| x.clean(cx)).collect(),\n+        };\n \n         // Some duplicates are generated for ?Sized bounds between type params and where\n         // predicates. The point in here is to move the bounds definitions from type params\n@@ -900,7 +870,7 @@ impl Clean<PolyTrait> for hir::PolyTraitRef<'_> {\n     fn clean(&self, cx: &mut DocContext<'_>) -> PolyTrait {\n         PolyTrait {\n             trait_: self.trait_ref.clean(cx),\n-            generic_params: self.bound_generic_params.clean(cx),\n+            generic_params: self.bound_generic_params.iter().map(|x| x.clean(cx)).collect(),\n         }\n     }\n }\n@@ -935,7 +905,9 @@ impl Clean<Item> for hir::TraitItem<'_> {\n                     TyMethodItem(t)\n                 }\n                 hir::TraitItemKind::Type(bounds, ref default) => {\n-                    AssocTypeItem(bounds.clean(cx), default.clean(cx))\n+                    let bounds = bounds.iter().map(|x| x.clean(cx)).collect();\n+                    let default = default.map(|t| t.clean(cx));\n+                    AssocTypeItem(bounds, default)\n                 }\n             };\n             let what_rustc_thinks =\n@@ -1127,7 +1099,7 @@ impl Clean<Item> for ty::AssocItem {\n                         None\n                     };\n \n-                    AssocTypeItem(bounds, ty.clean(cx))\n+                    AssocTypeItem(bounds, ty.map(|t| t.clean(cx)))\n                 } else {\n                     // FIXME: when could this happen? Associated items in inherent impls?\n                     let type_ = tcx.type_of(self.def_id).clean(cx);\n@@ -1269,7 +1241,7 @@ fn clean_qpath(hir_ty: &hir::Ty<'_>, cx: &mut DocContext<'_>) -> Type {\n             let trait_def = cx.tcx.associated_item(p.res.def_id()).container.id();\n             let trait_ = self::Path {\n                 res: Res::Def(DefKind::Trait, trait_def),\n-                segments: trait_segments.clean(cx),\n+                segments: trait_segments.iter().map(|x| x.clean(cx)).collect(),\n             };\n             register_res(cx, trait_.res);\n             Type::QPath {\n@@ -1335,11 +1307,11 @@ impl Clean<Type> for hir::Ty<'_> {\n                 let length = print_const(cx, ct.eval(cx.tcx, param_env));\n                 Array(box ty.clean(cx), length)\n             }\n-            TyKind::Tup(tys) => Tuple(tys.clean(cx)),\n+            TyKind::Tup(tys) => Tuple(tys.iter().map(|x| x.clean(cx)).collect()),\n             TyKind::OpaqueDef(item_id, _) => {\n                 let item = cx.tcx.hir().item(item_id);\n                 if let hir::ItemKind::OpaqueTy(ref ty) = item.kind {\n-                    ImplTrait(ty.bounds.clean(cx))\n+                    ImplTrait(ty.bounds.iter().map(|x| x.clean(cx)).collect())\n                 } else {\n                     unreachable!()\n                 }\n@@ -1479,7 +1451,7 @@ impl<'tcx> Clean<Type> for Ty<'tcx> {\n \n                 DynTrait(bounds, lifetime)\n             }\n-            ty::Tuple(t) => Tuple(t.iter().map(|t| t.expect_ty()).collect::<Vec<_>>().clean(cx)),\n+            ty::Tuple(t) => Tuple(t.iter().map(|t| t.expect_ty().clean(cx)).collect()),\n \n             ty::Projection(ref data) => data.clean(cx),\n \n@@ -1712,7 +1684,7 @@ impl Clean<Variant> for hir::VariantData<'_> {\n \n impl Clean<Path> for hir::Path<'_> {\n     fn clean(&self, cx: &mut DocContext<'_>) -> Path {\n-        Path { res: self.res, segments: self.segments.clean(cx) }\n+        Path { res: self.res, segments: self.segments.iter().map(|x| x.clean(cx)).collect() }\n     }\n }\n \n@@ -1722,24 +1694,24 @@ impl Clean<GenericArgs> for hir::GenericArgs<'_> {\n             let output = self.bindings[0].ty().clean(cx);\n             let output =\n                 if output != Type::Tuple(Vec::new()) { Some(Box::new(output)) } else { None };\n-            GenericArgs::Parenthesized { inputs: self.inputs().clean(cx), output }\n+            let inputs = self.inputs().iter().map(|x| x.clean(cx)).collect();\n+            GenericArgs::Parenthesized { inputs, output }\n         } else {\n-            GenericArgs::AngleBracketed {\n-                args: self\n-                    .args\n-                    .iter()\n-                    .map(|arg| match arg {\n-                        hir::GenericArg::Lifetime(lt) if !lt.is_elided() => {\n-                            GenericArg::Lifetime(lt.clean(cx))\n-                        }\n-                        hir::GenericArg::Lifetime(_) => GenericArg::Lifetime(Lifetime::elided()),\n-                        hir::GenericArg::Type(ty) => GenericArg::Type(ty.clean(cx)),\n-                        hir::GenericArg::Const(ct) => GenericArg::Const(Box::new(ct.clean(cx))),\n-                        hir::GenericArg::Infer(_inf) => GenericArg::Infer,\n-                    })\n-                    .collect(),\n-                bindings: self.bindings.clean(cx),\n-            }\n+            let args = self\n+                .args\n+                .iter()\n+                .map(|arg| match arg {\n+                    hir::GenericArg::Lifetime(lt) if !lt.is_elided() => {\n+                        GenericArg::Lifetime(lt.clean(cx))\n+                    }\n+                    hir::GenericArg::Lifetime(_) => GenericArg::Lifetime(Lifetime::elided()),\n+                    hir::GenericArg::Type(ty) => GenericArg::Type(ty.clean(cx)),\n+                    hir::GenericArg::Const(ct) => GenericArg::Const(Box::new(ct.clean(cx))),\n+                    hir::GenericArg::Infer(_inf) => GenericArg::Infer,\n+                })\n+                .collect();\n+            let bindings = self.bindings.iter().map(|x| x.clean(cx)).collect();\n+            GenericArgs::AngleBracketed { args, bindings }\n         }\n     }\n }\n@@ -1753,7 +1725,9 @@ impl Clean<PathSegment> for hir::PathSegment<'_> {\n impl Clean<BareFunctionDecl> for hir::BareFnTy<'_> {\n     fn clean(&self, cx: &mut DocContext<'_>) -> BareFunctionDecl {\n         let (generic_params, decl) = enter_impl_trait(cx, |cx| {\n-            (self.generic_params.clean(cx), (&*self.decl, self.param_names).clean(cx))\n+            let generic_params = self.generic_params.iter().map(|x| x.clean(cx)).collect();\n+            let decl = (self.decl, self.param_names).clean(cx);\n+            (generic_params, decl)\n         });\n         BareFunctionDecl { unsafety: self.unsafety, abi: self.abi, decl, generic_params }\n     }\n@@ -1776,7 +1750,7 @@ impl Clean<Vec<Item>> for (&hir::Item<'_>, Option<Symbol>) {\n                     kind: ConstantKind::Local { body: body_id, def_id },\n                 }),\n                 ItemKind::OpaqueTy(ref ty) => OpaqueTyItem(OpaqueTy {\n-                    bounds: ty.bounds.clean(cx),\n+                    bounds: ty.bounds.iter().map(|x| x.clean(cx)).collect(),\n                     generics: ty.generics.clean(cx),\n                 }),\n                 ItemKind::TyAlias(hir_ty, ref generics) => {\n@@ -1798,17 +1772,17 @@ impl Clean<Vec<Item>> for (&hir::Item<'_>, Option<Symbol>) {\n                 }),\n                 ItemKind::TraitAlias(ref generics, bounds) => TraitAliasItem(TraitAlias {\n                     generics: generics.clean(cx),\n-                    bounds: bounds.clean(cx),\n+                    bounds: bounds.iter().map(|x| x.clean(cx)).collect(),\n                 }),\n                 ItemKind::Union(ref variant_data, ref generics) => UnionItem(Union {\n                     generics: generics.clean(cx),\n-                    fields: variant_data.fields().clean(cx),\n+                    fields: variant_data.fields().iter().map(|x| x.clean(cx)).collect(),\n                     fields_stripped: false,\n                 }),\n                 ItemKind::Struct(ref variant_data, ref generics) => StructItem(Struct {\n                     struct_type: CtorKind::from_hir(variant_data),\n                     generics: generics.clean(cx),\n-                    fields: variant_data.fields().clean(cx),\n+                    fields: variant_data.fields().iter().map(|x| x.clean(cx)).collect(),\n                     fields_stripped: false,\n                 }),\n                 ItemKind::Impl(ref impl_) => return clean_impl(impl_, item.hir_id(), cx),\n@@ -1817,7 +1791,7 @@ impl Clean<Vec<Item>> for (&hir::Item<'_>, Option<Symbol>) {\n                     clean_fn_or_proc_macro(item, sig, generics, body_id, &mut name, cx)\n                 }\n                 ItemKind::Macro(ref macro_def) => MacroItem(Macro {\n-                    source: display_macro_source(cx, name, macro_def, def_id, &item.vis),\n+                    source: display_macro_source(cx, name, macro_def, def_id, item.vis),\n                 }),\n                 ItemKind::Trait(is_auto, unsafety, ref generics, bounds, item_ids) => {\n                     let items = item_ids\n@@ -1828,7 +1802,7 @@ impl Clean<Vec<Item>> for (&hir::Item<'_>, Option<Symbol>) {\n                         unsafety,\n                         items,\n                         generics: generics.clean(cx),\n-                        bounds: bounds.clean(cx),\n+                        bounds: bounds.iter().map(|x| x.clean(cx)).collect(),\n                         is_auto: is_auto.clean(cx),\n                     })\n                 }\n@@ -1856,22 +1830,10 @@ impl Clean<Item> for hir::Variant<'_> {\n     }\n }\n \n-impl Clean<bool> for ty::ImplPolarity {\n-    /// Returns whether the impl has negative polarity.\n-    fn clean(&self, _: &mut DocContext<'_>) -> bool {\n-        match self {\n-            &ty::ImplPolarity::Positive |\n-            // FIXME: do we want to do something else here?\n-            &ty::ImplPolarity::Reservation => false,\n-            &ty::ImplPolarity::Negative => true,\n-        }\n-    }\n-}\n-\n fn clean_impl(impl_: &hir::Impl<'_>, hir_id: hir::HirId, cx: &mut DocContext<'_>) -> Vec<Item> {\n     let tcx = cx.tcx;\n     let mut ret = Vec::new();\n-    let trait_ = impl_.of_trait.clean(cx);\n+    let trait_ = impl_.of_trait.as_ref().map(|t| t.clean(cx));\n     let items =\n         impl_.items.iter().map(|ii| tcx.hir().impl_item(ii.id).clean(cx)).collect::<Vec<_>>();\n     let def_id = tcx.hir().local_def_id(hir_id);\n@@ -1889,15 +1851,13 @@ fn clean_impl(impl_: &hir::Impl<'_>, hir_id: hir::HirId, cx: &mut DocContext<'_>\n     });\n     let mut make_item = |trait_: Option<Path>, for_: Type, items: Vec<Item>| {\n         let kind = ImplItem(Impl {\n-            span: types::rustc_span(tcx.hir().local_def_id(hir_id).to_def_id(), tcx),\n             unsafety: impl_.unsafety,\n             generics: impl_.generics.clean(cx),\n             trait_,\n             for_,\n             items,\n-            negative_polarity: tcx.impl_polarity(def_id).clean(cx),\n-            synthetic: false,\n-            blanket_impl: None,\n+            polarity: tcx.impl_polarity(def_id),\n+            kind: ImplKind::Normal,\n         });\n         Item::from_hir_id_and_parts(hir_id, None, kind, cx)\n     };"}, {"sha": "0dc1c24b16e195c6a03743bc1ce07535ec6d1558", "filename": "src/librustdoc/clean/types.rs", "status": "modified", "additions": 39, "deletions": 10, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/3e3890c9d4064253aaa8c51f5d5458d2dc6dab77/src%2Flibrustdoc%2Fclean%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e3890c9d4064253aaa8c51f5d5458d2dc6dab77/src%2Flibrustdoc%2Fclean%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Ftypes.rs?ref=3e3890c9d4064253aaa8c51f5d5458d2dc6dab77", "patch": "@@ -391,12 +391,19 @@ impl Item {\n             ItemKind::StrippedItem(k) => k,\n             _ => &*self.kind,\n         };\n-        if let ItemKind::ModuleItem(Module { span, .. }) | ItemKind::ImplItem(Impl { span, .. }) =\n-            kind\n-        {\n-            *span\n-        } else {\n-            self.def_id.as_def_id().map(|did| rustc_span(did, tcx)).unwrap_or_else(Span::dummy)\n+        match kind {\n+            ItemKind::ModuleItem(Module { span, .. }) => *span,\n+            ItemKind::ImplItem(Impl { kind: ImplKind::Auto, .. }) => Span::dummy(),\n+            ItemKind::ImplItem(Impl { kind: ImplKind::Blanket(_), .. }) => {\n+                if let ItemId::Blanket { impl_id, .. } = self.def_id {\n+                    rustc_span(impl_id, tcx)\n+                } else {\n+                    panic!(\"blanket impl item has non-blanket ID\")\n+                }\n+            }\n+            _ => {\n+                self.def_id.as_def_id().map(|did| rustc_span(did, tcx)).unwrap_or_else(Span::dummy)\n+            }\n         }\n     }\n \n@@ -2165,15 +2172,13 @@ impl Constant {\n \n #[derive(Clone, Debug)]\n crate struct Impl {\n-    crate span: Span,\n     crate unsafety: hir::Unsafety,\n     crate generics: Generics,\n     crate trait_: Option<Path>,\n     crate for_: Type,\n     crate items: Vec<Item>,\n-    crate negative_polarity: bool,\n-    crate synthetic: bool,\n-    crate blanket_impl: Option<Box<Type>>,\n+    crate polarity: ty::ImplPolarity,\n+    crate kind: ImplKind,\n }\n \n impl Impl {\n@@ -2186,6 +2191,30 @@ impl Impl {\n     }\n }\n \n+#[derive(Clone, Debug)]\n+crate enum ImplKind {\n+    Normal,\n+    Auto,\n+    Blanket(Box<Type>),\n+}\n+\n+impl ImplKind {\n+    crate fn is_auto(&self) -> bool {\n+        matches!(self, ImplKind::Auto)\n+    }\n+\n+    crate fn is_blanket(&self) -> bool {\n+        matches!(self, ImplKind::Blanket(_))\n+    }\n+\n+    crate fn as_blanket_ty(&self) -> Option<&Type> {\n+        match self {\n+            ImplKind::Blanket(ty) => Some(ty),\n+            _ => None,\n+        }\n+    }\n+}\n+\n #[derive(Clone, Debug)]\n crate struct Import {\n     crate kind: ImportKind,"}, {"sha": "a929cd094f8c3bcb6417d1f35c937786540c4888", "filename": "src/librustdoc/formats/cache.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3e3890c9d4064253aaa8c51f5d5458d2dc6dab77/src%2Flibrustdoc%2Fformats%2Fcache.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e3890c9d4064253aaa8c51f5d5458d2dc6dab77/src%2Flibrustdoc%2Fformats%2Fcache.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fformats%2Fcache.rs?ref=3e3890c9d4064253aaa8c51f5d5458d2dc6dab77", "patch": "@@ -228,7 +228,7 @@ impl<'a, 'tcx> DocFolder for CacheBuilder<'a, 'tcx> {\n         // Collect all the implementors of traits.\n         if let clean::ImplItem(ref i) = *item.kind {\n             if let Some(trait_) = &i.trait_ {\n-                if i.blanket_impl.is_none() {\n+                if !i.kind.is_blanket() {\n                     self.cache\n                         .implementors\n                         .entry(trait_.def_id())"}, {"sha": "4f2049132046d8a534a9c8e9069a15d836d5be84", "filename": "src/librustdoc/html/format.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/3e3890c9d4064253aaa8c51f5d5458d2dc6dab77/src%2Flibrustdoc%2Fhtml%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e3890c9d4064253aaa8c51f5d5458d2dc6dab77/src%2Flibrustdoc%2Fhtml%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fformat.rs?ref=3e3890c9d4064253aaa8c51f5d5458d2dc6dab77", "patch": "@@ -14,6 +14,7 @@ use rustc_data_structures::captures::Captures;\n use rustc_data_structures::fx::FxHashSet;\n use rustc_hir as hir;\n use rustc_hir::def_id::DefId;\n+use rustc_middle::ty;\n use rustc_middle::ty::TyCtxt;\n use rustc_span::def_id::CRATE_DEF_INDEX;\n use rustc_target::spec::abi::Abi;\n@@ -990,14 +991,15 @@ impl clean::Impl {\n             }\n \n             if let Some(ref ty) = self.trait_ {\n-                if self.negative_polarity {\n-                    write!(f, \"!\")?;\n+                match self.polarity {\n+                    ty::ImplPolarity::Positive | ty::ImplPolarity::Reservation => {}\n+                    ty::ImplPolarity::Negative => write!(f, \"!\")?,\n                 }\n                 fmt::Display::fmt(&ty.print(cx), f)?;\n                 write!(f, \" for \")?;\n             }\n \n-            if let Some(ref ty) = self.blanket_impl {\n+            if let Some(ref ty) = self.kind.as_blanket_ty() {\n                 fmt_type(ty, f, use_absolute, cx)?;\n             } else {\n                 fmt_type(&self.for_, f, use_absolute, cx)?;"}, {"sha": "fdadc68998dc663f98609c190841b75d3f09f5f8", "filename": "src/librustdoc/html/render/mod.rs", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/3e3890c9d4064253aaa8c51f5d5458d2dc6dab77/src%2Flibrustdoc%2Fhtml%2Frender%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e3890c9d4064253aaa8c51f5d5458d2dc6dab77/src%2Flibrustdoc%2Fhtml%2Frender%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender%2Fmod.rs?ref=3e3890c9d4064253aaa8c51f5d5458d2dc6dab77", "patch": "@@ -34,8 +34,8 @@ mod span_map;\n mod templates;\n mod write_shared;\n \n-crate use context::*;\n-crate use span_map::{collect_spans_and_sources, LinkFromSrc};\n+crate use self::context::*;\n+crate use self::span_map::{collect_spans_and_sources, LinkFromSrc};\n \n use std::collections::VecDeque;\n use std::default::Default;\n@@ -54,6 +54,7 @@ use rustc_hir::def::CtorKind;\n use rustc_hir::def_id::DefId;\n use rustc_hir::Mutability;\n use rustc_middle::middle::stability;\n+use rustc_middle::ty;\n use rustc_middle::ty::TyCtxt;\n use rustc_span::{\n     symbol::{kw, sym, Symbol},\n@@ -1147,9 +1148,9 @@ fn render_assoc_items_inner(\n         }\n \n         let (synthetic, concrete): (Vec<&&Impl>, Vec<&&Impl>) =\n-            traits.iter().partition(|t| t.inner_impl().synthetic);\n+            traits.iter().partition(|t| t.inner_impl().kind.is_auto());\n         let (blanket_impl, concrete): (Vec<&&Impl>, _) =\n-            concrete.into_iter().partition(|t| t.inner_impl().blanket_impl.is_some());\n+            concrete.into_iter().partition(|t| t.inner_impl().kind.is_blanket());\n \n         let mut impls = Buffer::empty_from(w);\n         render_impls(cx, &mut impls, &concrete, containing_item);\n@@ -2033,12 +2034,12 @@ fn sidebar_assoc_items(cx: &Context<'_>, out: &mut Buffer, it: &clean::Item) {\n                             let i_display = format!(\"{:#}\", i.print(cx));\n                             let out = Escape(&i_display);\n                             let encoded = small_url_encode(format!(\"{:#}\", i.print(cx)));\n-                            let generated = format!(\n-                                \"<a href=\\\"#impl-{}\\\">{}{}</a>\",\n-                                encoded,\n-                                if it.inner_impl().negative_polarity { \"!\" } else { \"\" },\n-                                out\n-                            );\n+                            let prefix = match it.inner_impl().polarity {\n+                                ty::ImplPolarity::Positive | ty::ImplPolarity::Reservation => \"\",\n+                                ty::ImplPolarity::Negative => \"!\",\n+                            };\n+                            let generated =\n+                                format!(\"<a href=\\\"#impl-{}\\\">{}{}</a>\", encoded, prefix, out);\n                             if links.insert(generated.clone()) { Some(generated) } else { None }\n                         } else {\n                             None\n@@ -2058,10 +2059,9 @@ fn sidebar_assoc_items(cx: &Context<'_>, out: &mut Buffer, it: &clean::Item) {\n             };\n \n             let (synthetic, concrete): (Vec<&Impl>, Vec<&Impl>) =\n-                v.iter().partition::<Vec<_>, _>(|i| i.inner_impl().synthetic);\n-            let (blanket_impl, concrete): (Vec<&Impl>, Vec<&Impl>) = concrete\n-                .into_iter()\n-                .partition::<Vec<_>, _>(|i| i.inner_impl().blanket_impl.is_some());\n+                v.iter().partition::<Vec<_>, _>(|i| i.inner_impl().kind.is_auto());\n+            let (blanket_impl, concrete): (Vec<&Impl>, Vec<&Impl>) =\n+                concrete.into_iter().partition::<Vec<_>, _>(|i| i.inner_impl().kind.is_blanket());\n \n             let concrete_format = format_impls(concrete);\n             let synthetic_format = format_impls(synthetic);"}, {"sha": "7ef773fe5ff29dde2338ef963426cb4d5b2b419f", "filename": "src/librustdoc/html/render/print_item.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3e3890c9d4064253aaa8c51f5d5458d2dc6dab77/src%2Flibrustdoc%2Fhtml%2Frender%2Fprint_item.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e3890c9d4064253aaa8c51f5d5458d2dc6dab77/src%2Flibrustdoc%2Fhtml%2Frender%2Fprint_item.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender%2Fprint_item.rs?ref=3e3890c9d4064253aaa8c51f5d5458d2dc6dab77", "patch": "@@ -746,7 +746,7 @@ fn item_trait(w: &mut Buffer, cx: &Context<'_>, it: &clean::Item, t: &clean::Tra\n         });\n \n         let (mut synthetic, mut concrete): (Vec<&&Impl>, Vec<&&Impl>) =\n-            local.iter().partition(|i| i.inner_impl().synthetic);\n+            local.iter().partition(|i| i.inner_impl().kind.is_auto());\n \n         synthetic.sort_by(|a, b| compare_impl(a, b, cx));\n         concrete.sort_by(|a, b| compare_impl(a, b, cx));"}, {"sha": "2d3b2490677e9b3e029cbad752a3a58368f6a965", "filename": "src/librustdoc/html/render/write_shared.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3e3890c9d4064253aaa8c51f5d5458d2dc6dab77/src%2Flibrustdoc%2Fhtml%2Frender%2Fwrite_shared.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e3890c9d4064253aaa8c51f5d5458d2dc6dab77/src%2Flibrustdoc%2Fhtml%2Frender%2Fwrite_shared.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender%2Fwrite_shared.rs?ref=3e3890c9d4064253aaa8c51f5d5458d2dc6dab77", "patch": "@@ -585,7 +585,7 @@ pub(super) fn write_shared(\n                 } else {\n                     Some(Implementor {\n                         text: imp.inner_impl().print(false, cx).to_string(),\n-                        synthetic: imp.inner_impl().synthetic,\n+                        synthetic: imp.inner_impl().kind.is_auto(),\n                         types: collect_paths_for_type(imp.inner_impl().for_.clone(), cache),\n                     })\n                 }"}, {"sha": "a46518ef489aa1b3bc1a53d38ad358800826b1ce", "filename": "src/librustdoc/json/conversions.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/3e3890c9d4064253aaa8c51f5d5458d2dc6dab77/src%2Flibrustdoc%2Fjson%2Fconversions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e3890c9d4064253aaa8c51f5d5458d2dc6dab77/src%2Flibrustdoc%2Fjson%2Fconversions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fjson%2Fconversions.rs?ref=3e3890c9d4064253aaa8c51f5d5458d2dc6dab77", "patch": "@@ -9,7 +9,7 @@ use std::fmt;\n \n use rustc_ast::ast;\n use rustc_hir::{def::CtorKind, def_id::DefId};\n-use rustc_middle::ty::TyCtxt;\n+use rustc_middle::ty::{self, TyCtxt};\n use rustc_span::def_id::CRATE_DEF_INDEX;\n use rustc_span::Pos;\n \n@@ -500,22 +500,22 @@ impl FromWithTcx<clean::Trait> for Trait {\n impl FromWithTcx<clean::Impl> for Impl {\n     fn from_tcx(impl_: clean::Impl, tcx: TyCtxt<'_>) -> Self {\n         let provided_trait_methods = impl_.provided_trait_methods(tcx);\n-        let clean::Impl {\n-            unsafety,\n-            generics,\n-            trait_,\n-            for_,\n-            items,\n-            negative_polarity,\n-            synthetic,\n-            blanket_impl,\n-            span: _span,\n-        } = impl_;\n+        let clean::Impl { unsafety, generics, trait_, for_, items, polarity, kind } = impl_;\n         // FIXME: should `trait_` be a clean::Path equivalent in JSON?\n         let trait_ = trait_.map(|path| {\n             let did = path.def_id();\n             clean::ResolvedPath { path, did }.into_tcx(tcx)\n         });\n+        // FIXME: use something like ImplKind in JSON?\n+        let (synthetic, blanket_impl) = match kind {\n+            clean::ImplKind::Normal => (false, None),\n+            clean::ImplKind::Auto => (true, None),\n+            clean::ImplKind::Blanket(ty) => (false, Some(*ty)),\n+        };\n+        let negative_polarity = match polarity {\n+            ty::ImplPolarity::Positive | ty::ImplPolarity::Reservation => false,\n+            ty::ImplPolarity::Negative => true,\n+        };\n         Impl {\n             is_unsafe: unsafety == rustc_hir::Unsafety::Unsafe,\n             generics: generics.into_tcx(tcx),\n@@ -528,7 +528,7 @@ impl FromWithTcx<clean::Impl> for Impl {\n             items: ids(items),\n             negative: negative_polarity,\n             synthetic,\n-            blanket_impl: blanket_impl.map(|x| (*x).into_tcx(tcx)),\n+            blanket_impl: blanket_impl.map(|x| x.into_tcx(tcx)),\n         }\n     }\n }"}, {"sha": "ea50134f00d477c485322b5ef9c0f423a4086d4c", "filename": "src/librustdoc/passes/collect_trait_impls.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3e3890c9d4064253aaa8c51f5d5458d2dc6dab77/src%2Flibrustdoc%2Fpasses%2Fcollect_trait_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e3890c9d4064253aaa8c51f5d5458d2dc6dab77/src%2Flibrustdoc%2Fpasses%2Fcollect_trait_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fcollect_trait_impls.rs?ref=3e3890c9d4064253aaa8c51f5d5458d2dc6dab77", "patch": "@@ -111,12 +111,12 @@ crate fn collect_trait_impls(mut krate: Crate, cx: &mut DocContext<'_>) -> Crate\n     }\n \n     new_items.retain(|it| {\n-        if let ImplItem(Impl { ref for_, ref trait_, ref blanket_impl, .. }) = *it.kind {\n+        if let ImplItem(Impl { ref for_, ref trait_, ref kind, .. }) = *it.kind {\n             cleaner.keep_impl(\n                 for_,\n                 trait_.as_ref().map(|t| t.def_id()) == cx.tcx.lang_items().deref_trait(),\n             ) || trait_.as_ref().map_or(false, |t| cleaner.keep_impl_with_def_id(t.def_id().into()))\n-                || blanket_impl.is_some()\n+                || kind.is_blanket()\n         } else {\n             true\n         }"}]}