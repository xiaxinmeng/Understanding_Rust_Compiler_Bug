{"sha": "f89856be6ccd1f63ef72d343587cd5d7932cfe8b", "node_id": "MDY6Q29tbWl0NzI0NzEyOmY4OTg1NmJlNmNjZDFmNjNlZjcyZDM0MzU4N2NkNWQ3OTMyY2ZlOGI=", "commit": {"author": {"name": "Eduard-Mihai Burtescu", "email": "edy.burt@gmail.com", "date": "2016-12-20T20:46:11Z"}, "committer": {"name": "Eduard-Mihai Burtescu", "email": "edy.burt@gmail.com", "date": "2016-12-28T09:29:19Z"}, "message": "rustc: move function arguments into hir::Body.", "tree": {"sha": "9b4f669599c395c6b0e5891f155ae898f113d636", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9b4f669599c395c6b0e5891f155ae898f113d636"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f89856be6ccd1f63ef72d343587cd5d7932cfe8b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f89856be6ccd1f63ef72d343587cd5d7932cfe8b", "html_url": "https://github.com/rust-lang/rust/commit/f89856be6ccd1f63ef72d343587cd5d7932cfe8b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f89856be6ccd1f63ef72d343587cd5d7932cfe8b/comments", "author": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "committer": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e64f64a2fc1deb955b42542fa399f2fa2b609866", "url": "https://api.github.com/repos/rust-lang/rust/commits/e64f64a2fc1deb955b42542fa399f2fa2b609866", "html_url": "https://github.com/rust-lang/rust/commit/e64f64a2fc1deb955b42542fa399f2fa2b609866"}], "stats": {"total": 1113, "additions": 545, "deletions": 568}, "files": [{"sha": "26e1dc7e0490c21f826b4657e67d13c04c4c8e81", "filename": "src/librustc/dep_graph/graph.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f89856be6ccd1f63ef72d343587cd5d7932cfe8b/src%2Flibrustc%2Fdep_graph%2Fgraph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f89856be6ccd1f63ef72d343587cd5d7932cfe8b/src%2Flibrustc%2Fdep_graph%2Fgraph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdep_graph%2Fgraph.rs?ref=f89856be6ccd1f63ef72d343587cd5d7932cfe8b", "patch": "@@ -51,6 +51,12 @@ impl DepGraph {\n         }\n     }\n \n+    /// True if we are actually building the full dep-graph.\n+    #[inline]\n+    pub fn is_fully_enabled(&self) -> bool {\n+        self.data.thread.is_fully_enabled()\n+    }\n+\n     pub fn query(&self) -> DepGraphQuery<DefId> {\n         self.data.thread.query()\n     }"}, {"sha": "4b171193b4af17f54dddbd2807f06a561daf1175", "filename": "src/librustc/hir/intravisit.rs", "status": "modified", "additions": 16, "deletions": 29, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/f89856be6ccd1f63ef72d343587cd5d7932cfe8b/src%2Flibrustc%2Fhir%2Fintravisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f89856be6ccd1f63ef72d343587cd5d7932cfe8b/src%2Flibrustc%2Fhir%2Fintravisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fintravisit.rs?ref=f89856be6ccd1f63ef72d343587cd5d7932cfe8b", "patch": "@@ -395,6 +395,10 @@ pub fn walk_mod<'v, V: Visitor<'v>>(visitor: &mut V, module: &'v Mod, mod_node_i\n }\n \n pub fn walk_body<'v, V: Visitor<'v>>(visitor: &mut V, body: &'v Body) {\n+    for argument in &body.arguments {\n+        visitor.visit_id(argument.id);\n+        visitor.visit_pat(&argument.pat);\n+    }\n     visitor.visit_expr(&body.value);\n }\n \n@@ -680,9 +684,12 @@ pub fn walk_foreign_item<'v, V: Visitor<'v>>(visitor: &mut V, foreign_item: &'v\n     visitor.visit_name(foreign_item.span, foreign_item.name);\n \n     match foreign_item.node {\n-        ForeignItemFn(ref function_declaration, ref generics) => {\n+        ForeignItemFn(ref function_declaration, ref names, ref generics) => {\n+            visitor.visit_generics(generics);\n             visitor.visit_fn_decl(function_declaration);\n-            visitor.visit_generics(generics)\n+            for name in names {\n+                visitor.visit_name(name.span, name.node);\n+            }\n         }\n         ForeignItemStatic(ref typ, _) => visitor.visit_ty(typ),\n     }\n@@ -750,18 +757,8 @@ pub fn walk_fn_ret_ty<'v, V: Visitor<'v>>(visitor: &mut V, ret_ty: &'v FunctionR\n }\n \n pub fn walk_fn_decl<'v, V: Visitor<'v>>(visitor: &mut V, function_declaration: &'v FnDecl) {\n-    for argument in &function_declaration.inputs {\n-        visitor.visit_id(argument.id);\n-        visitor.visit_pat(&argument.pat);\n-        visitor.visit_ty(&argument.ty)\n-    }\n-    walk_fn_ret_ty(visitor, &function_declaration.output)\n-}\n-\n-pub fn walk_fn_decl_nopat<'v, V: Visitor<'v>>(visitor: &mut V, function_declaration: &'v FnDecl) {\n-    for argument in &function_declaration.inputs {\n-        visitor.visit_id(argument.id);\n-        visitor.visit_ty(&argument.ty)\n+    for ty in &function_declaration.inputs {\n+        visitor.visit_ty(ty)\n     }\n     walk_fn_ret_ty(visitor, &function_declaration.output)\n }\n@@ -799,12 +796,15 @@ pub fn walk_trait_item<'v, V: Visitor<'v>>(visitor: &mut V, trait_item: &'v Trai\n             visitor.visit_ty(ty);\n             walk_list!(visitor, visit_nested_body, default);\n         }\n-        TraitItemKind::Method(ref sig, None) => {\n+        TraitItemKind::Method(ref sig, TraitMethod::Required(ref names)) => {\n             visitor.visit_id(trait_item.id);\n             visitor.visit_generics(&sig.generics);\n             visitor.visit_fn_decl(&sig.decl);\n+            for name in names {\n+                visitor.visit_name(name.span, name.node);\n+            }\n         }\n-        TraitItemKind::Method(ref sig, Some(body_id)) => {\n+        TraitItemKind::Method(ref sig, TraitMethod::Provided(body_id)) => {\n             visitor.visit_fn(FnKind::Method(trait_item.name,\n                                             sig,\n                                             None,\n@@ -1113,16 +1113,3 @@ impl<'a, 'ast> Visitor<'ast> for IdRangeComputingVisitor<'a, 'ast> {\n         self.result.add(id);\n     }\n }\n-\n-/// Computes the id range for a single fn body, ignoring nested items.\n-pub fn compute_id_range_for_fn_body<'v>(fk: FnKind<'v>,\n-                                        decl: &'v FnDecl,\n-                                        body: BodyId,\n-                                        sp: Span,\n-                                        id: NodeId,\n-                                        map: &map::Map<'v>)\n-                                        -> IdRange {\n-    let mut visitor = IdRangeComputingVisitor::new(map);\n-    visitor.visit_fn(fk, decl, body, sp, id);\n-    visitor.result()\n-}"}, {"sha": "9a2658f48f3d91f2cf7236120cd9b072c7febc3c", "filename": "src/librustc/hir/lowering.rs", "status": "modified", "additions": 43, "deletions": 28, "changes": 71, "blob_url": "https://github.com/rust-lang/rust/blob/f89856be6ccd1f63ef72d343587cd5d7932cfe8b/src%2Flibrustc%2Fhir%2Flowering.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f89856be6ccd1f63ef72d343587cd5d7932cfe8b/src%2Flibrustc%2Fhir%2Flowering.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Flowering.rs?ref=f89856be6ccd1f63ef72d343587cd5d7932cfe8b", "patch": "@@ -170,8 +170,12 @@ impl<'a> LoweringContext<'a> {\n         visit::walk_crate(&mut item_lowerer, c);\n     }\n \n-    fn record_body(&mut self, value: hir::Expr) -> hir::BodyId {\n+    fn record_body(&mut self, value: hir::Expr, decl: Option<&FnDecl>)\n+                   -> hir::BodyId {\n         let body = hir::Body {\n+            arguments: decl.map_or(hir_vec![], |decl| {\n+                decl.inputs.iter().map(|x| self.lower_arg(x)).collect()\n+            }),\n             value: value\n         };\n         let id = body.id();\n@@ -310,11 +314,11 @@ impl<'a> LoweringContext<'a> {\n                 TyKind::Array(ref ty, ref length) => {\n                     let length = self.lower_expr(length);\n                     hir::TyArray(self.lower_ty(ty),\n-                                 self.record_body(length))\n+                                 self.record_body(length, None))\n                 }\n                 TyKind::Typeof(ref expr) => {\n                     let expr = self.lower_expr(expr);\n-                    hir::TyTypeof(self.record_body(expr))\n+                    hir::TyTypeof(self.record_body(expr, None))\n                 }\n                 TyKind::PolyTraitRef(ref bounds) => {\n                     hir::TyPolyTraitRef(self.lower_bounds(bounds))\n@@ -343,7 +347,7 @@ impl<'a> LoweringContext<'a> {\n                 data: self.lower_variant_data(&v.node.data),\n                 disr_expr: v.node.disr_expr.as_ref().map(|e| {\n                     let e = self.lower_expr(e);\n-                    self.record_body(e)\n+                    self.record_body(e, None)\n                 }),\n             },\n             span: v.span,\n@@ -532,13 +536,24 @@ impl<'a> LoweringContext<'a> {\n         hir::Arg {\n             id: arg.id,\n             pat: self.lower_pat(&arg.pat),\n-            ty: self.lower_ty(&arg.ty),\n         }\n     }\n \n+    fn lower_fn_args_to_names(&mut self, decl: &FnDecl)\n+                              -> hir::HirVec<Spanned<Name>> {\n+        decl.inputs.iter().map(|arg| {\n+            match arg.pat.node {\n+                PatKind::Ident(_, ident, None) => {\n+                    respan(ident.span, ident.node.name)\n+                }\n+                _ => respan(arg.pat.span, keywords::Invalid.name()),\n+            }\n+        }).collect()\n+    }\n+\n     fn lower_fn_decl(&mut self, decl: &FnDecl) -> P<hir::FnDecl> {\n         P(hir::FnDecl {\n-            inputs: decl.inputs.iter().map(|x| self.lower_arg(x)).collect(),\n+            inputs: decl.inputs.iter().map(|arg| self.lower_ty(&arg.ty)).collect(),\n             output: match decl.output {\n                 FunctionRetTy::Ty(ref ty) => hir::Return(self.lower_ty(ty)),\n                 FunctionRetTy::Default(span) => hir::DefaultReturn(span),\n@@ -869,17 +884,17 @@ impl<'a> LoweringContext<'a> {\n                 let value = self.lower_expr(e);\n                 hir::ItemStatic(self.lower_ty(t),\n                                 self.lower_mutability(m),\n-                                self.record_body(value))\n+                                self.record_body(value, None))\n             }\n             ItemKind::Const(ref t, ref e) => {\n                 let value = self.lower_expr(e);\n                 hir::ItemConst(self.lower_ty(t),\n-                               self.record_body(value))\n+                               self.record_body(value, None))\n             }\n             ItemKind::Fn(ref decl, unsafety, constness, abi, ref generics, ref body) => {\n                 let body = self.lower_block(body);\n                 let body = self.expr_block(body, ThinVec::new());\n-                let body_id = self.record_body(body);\n+                let body_id = self.record_body(body, Some(decl));\n                 hir::ItemFn(self.lower_fn_decl(decl),\n                             self.lower_unsafety(unsafety),\n                             self.lower_constness(constness),\n@@ -948,16 +963,20 @@ impl<'a> LoweringContext<'a> {\n                         hir::TraitItemKind::Const(this.lower_ty(ty),\n                                                   default.as_ref().map(|x| {\n                             let value = this.lower_expr(x);\n-                            this.record_body(value)\n+                            this.record_body(value, None)\n                         }))\n                     }\n-                    TraitItemKind::Method(ref sig, ref body) => {\n+                    TraitItemKind::Method(ref sig, None) => {\n+                        let names = this.lower_fn_args_to_names(&sig.decl);\n                         hir::TraitItemKind::Method(this.lower_method_sig(sig),\n-                                                   body.as_ref().map(|x| {\n-                            let body = this.lower_block(x);\n-                            let expr = this.expr_block(body, ThinVec::new());\n-                            this.record_body(expr)\n-                        }))\n+                                                   hir::TraitMethod::Required(names))\n+                    }\n+                    TraitItemKind::Method(ref sig, Some(ref body)) => {\n+                        let body = this.lower_block(body);\n+                        let expr = this.expr_block(body, ThinVec::new());\n+                        let body_id = this.record_body(expr, Some(&sig.decl));\n+                        hir::TraitItemKind::Method(this.lower_method_sig(sig),\n+                                                   hir::TraitMethod::Provided(body_id))\n                     }\n                     TraitItemKind::Type(ref bounds, ref default) => {\n                         hir::TraitItemKind::Type(this.lower_bounds(bounds),\n@@ -1005,13 +1024,13 @@ impl<'a> LoweringContext<'a> {\n                 node: match i.node {\n                     ImplItemKind::Const(ref ty, ref expr) => {\n                         let value = this.lower_expr(expr);\n-                        let body_id = this.record_body(value);\n+                        let body_id = this.record_body(value, None);\n                         hir::ImplItemKind::Const(this.lower_ty(ty), body_id)\n                     }\n                     ImplItemKind::Method(ref sig, ref body) => {\n                         let body = this.lower_block(body);\n                         let expr = this.expr_block(body, ThinVec::new());\n-                        let body_id = this.record_body(expr);\n+                        let body_id = this.record_body(expr, Some(&sig.decl));\n                         hir::ImplItemKind::Method(this.lower_method_sig(sig), body_id)\n                     }\n                     ImplItemKind::Type(ref ty) => hir::ImplItemKind::Type(this.lower_ty(ty)),\n@@ -1097,7 +1116,9 @@ impl<'a> LoweringContext<'a> {\n                 attrs: this.lower_attrs(&i.attrs),\n                 node: match i.node {\n                     ForeignItemKind::Fn(ref fdec, ref generics) => {\n-                        hir::ForeignItemFn(this.lower_fn_decl(fdec), this.lower_generics(generics))\n+                        hir::ForeignItemFn(this.lower_fn_decl(fdec),\n+                                           this.lower_fn_args_to_names(fdec),\n+                                           this.lower_generics(generics))\n                     }\n                     ForeignItemKind::Static(ref t, m) => {\n                         hir::ForeignItemStatic(this.lower_ty(t), m)\n@@ -1367,7 +1388,7 @@ impl<'a> LoweringContext<'a> {\n                 ExprKind::Repeat(ref expr, ref count) => {\n                     let expr = P(self.lower_expr(expr));\n                     let count = self.lower_expr(count);\n-                    hir::ExprRepeat(expr, self.record_body(count))\n+                    hir::ExprRepeat(expr, self.record_body(count, None))\n                 }\n                 ExprKind::Tup(ref elts) => {\n                     hir::ExprTup(elts.iter().map(|x| self.lower_expr(x)).collect())\n@@ -1450,7 +1471,7 @@ impl<'a> LoweringContext<'a> {\n                         let expr = this.lower_expr(body);\n                         hir::ExprClosure(this.lower_capture_clause(capture_clause),\n                                          this.lower_fn_decl(decl),\n-                                         this.record_body(expr),\n+                                         this.record_body(expr, Some(decl)),\n                                          fn_decl_span)\n                     })\n                 }\n@@ -1734,13 +1755,7 @@ impl<'a> LoweringContext<'a> {\n                     // `::std::option::Option::Some(<pat>) => <body>`\n                     let pat_arm = {\n                         let body_block = self.lower_block(body);\n-                        let body_span = body_block.span;\n-                        let body_expr = P(hir::Expr {\n-                            id: self.next_id(),\n-                            node: hir::ExprBlock(body_block),\n-                            span: body_span,\n-                            attrs: ThinVec::new(),\n-                        });\n+                        let body_expr = P(self.expr_block(body_block, ThinVec::new()));\n                         let pat = self.lower_pat(pat);\n                         let some_pat = self.pat_some(e.span, pat);\n "}, {"sha": "6e08b52f9a2490bf1b8c0a8471723f8c9bc7f0cf", "filename": "src/librustc/hir/map/blocks.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/f89856be6ccd1f63ef72d343587cd5d7932cfe8b/src%2Flibrustc%2Fhir%2Fmap%2Fblocks.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f89856be6ccd1f63ef72d343587cd5d7932cfe8b/src%2Flibrustc%2Fhir%2Fmap%2Fblocks.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fblocks.rs?ref=f89856be6ccd1f63ef72d343587cd5d7932cfe8b", "patch": "@@ -62,7 +62,10 @@ impl MaybeFnLike for ast::Item {\n \n impl MaybeFnLike for ast::TraitItem {\n     fn is_fn_like(&self) -> bool {\n-        match self.node { ast::TraitItemKind::Method(_, Some(_)) => true, _ => false, }\n+        match self.node {\n+            ast::TraitItemKind::Method(_, ast::TraitMethod::Provided(_)) => true,\n+            _ => false,\n+        }\n     }\n }\n \n@@ -252,7 +255,7 @@ impl<'a> FnLikeNode<'a> {\n                 _ => bug!(\"item FnLikeNode that is not fn-like\"),\n             },\n             map::NodeTraitItem(ti) => match ti.node {\n-                ast::TraitItemKind::Method(ref sig, Some(body)) => {\n+                ast::TraitItemKind::Method(ref sig, ast::TraitMethod::Provided(body)) => {\n                     method(ti.id, ti.name, sig, None, body, ti.span, &ti.attrs)\n                 }\n                 _ => bug!(\"trait method FnLikeNode that is not fn-like\"),"}, {"sha": "330583c0d886b828be3b3b61c16b46e7eb4c7dfa", "filename": "src/librustc/hir/map/mod.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f89856be6ccd1f63ef72d343587cd5d7932cfe8b/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f89856be6ccd1f63ef72d343587cd5d7932cfe8b/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs?ref=f89856be6ccd1f63ef72d343587cd5d7932cfe8b", "patch": "@@ -389,7 +389,9 @@ impl<'ast> Map<'ast> {\n     fn is_trait_item_body(&self, node_id: NodeId, item: &TraitItem) -> bool {\n         match item.node {\n             TraitItemKind::Const(_, Some(body)) |\n-            TraitItemKind::Method(_, Some(body)) => body.node_id == node_id,\n+            TraitItemKind::Method(_, TraitMethod::Provided(body)) => {\n+                body.node_id == node_id\n+            }\n             _ => false\n         }\n     }"}, {"sha": "73097389c189b70d18fd5eb78d6dca6ae3f57731", "filename": "src/librustc/hir/mod.rs", "status": "modified", "additions": 14, "deletions": 4, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/f89856be6ccd1f63ef72d343587cd5d7932cfe8b/src%2Flibrustc%2Fhir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f89856be6ccd1f63ef72d343587cd5d7932cfe8b/src%2Flibrustc%2Fhir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmod.rs?ref=f89856be6ccd1f63ef72d343587cd5d7932cfe8b", "patch": "@@ -868,6 +868,7 @@ pub struct BodyId {\n /// The body of a function or constant value.\n #[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n pub struct Body {\n+    pub arguments: HirVec<Arg>,\n     pub value: Expr\n }\n \n@@ -1102,14 +1103,24 @@ pub struct TraitItem {\n     pub span: Span,\n }\n \n+/// A trait method's body (or just argument names).\n+#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n+pub enum TraitMethod {\n+    /// No default body in the trait, just a signature.\n+    Required(HirVec<Spanned<Name>>),\n+\n+    /// Both signature and body are provided in the trait.\n+    Provided(BodyId),\n+}\n+\n /// Represents a trait method or associated constant or type\n #[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n pub enum TraitItemKind {\n     /// An associated constant with an optional value (otherwise `impl`s\n     /// must contain a value)\n     Const(P<Ty>, Option<BodyId>),\n     /// A method with an optional body\n-    Method(MethodSig, Option<BodyId>),\n+    Method(MethodSig, TraitMethod),\n     /// An associated type with (possibly empty) bounds and optional concrete\n     /// type\n     Type(TyParamBounds, Option<P<Ty>>),\n@@ -1248,15 +1259,14 @@ pub struct InlineAsm {\n /// represents an argument in a function header\n #[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n pub struct Arg {\n-    pub ty: P<Ty>,\n     pub pat: P<Pat>,\n     pub id: NodeId,\n }\n \n /// Represents the header (not the body) of a function declaration\n #[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n pub struct FnDecl {\n-    pub inputs: HirVec<Arg>,\n+    pub inputs: HirVec<P<Ty>>,\n     pub output: FunctionRetTy,\n     pub variadic: bool,\n }\n@@ -1639,7 +1649,7 @@ pub struct ForeignItem {\n #[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n pub enum ForeignItem_ {\n     /// A foreign function\n-    ForeignItemFn(P<FnDecl>, Generics),\n+    ForeignItemFn(P<FnDecl>, HirVec<Spanned<Name>>, Generics),\n     /// A foreign static item (`static ext: u8`), with optional mutability\n     /// (the boolean is true when mutable)\n     ForeignItemStatic(P<Ty>, bool),"}, {"sha": "a7ffce37ee4460931093f3c642213e28b3edec1c", "filename": "src/librustc/hir/print.rs", "status": "modified", "additions": 110, "deletions": 84, "changes": 194, "blob_url": "https://github.com/rust-lang/rust/blob/f89856be6ccd1f63ef72d343587cd5d7932cfe8b/src%2Flibrustc%2Fhir%2Fprint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f89856be6ccd1f63ef72d343587cd5d7932cfe8b/src%2Flibrustc%2Fhir%2Fprint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fprint.rs?ref=f89856be6ccd1f63ef72d343587cd5d7932cfe8b", "patch": "@@ -20,7 +20,6 @@ use syntax::print::pp::{Breaks, eof};\n use syntax::print::pp::Breaks::{Consistent, Inconsistent};\n use syntax::print::pprust::{self as ast_pp, PrintState};\n use syntax::ptr::P;\n-use syntax::symbol::keywords;\n use syntax_pos::{self, BytePos};\n use errors;\n \n@@ -267,10 +266,6 @@ pub fn where_clause_to_string(i: &hir::WhereClause) -> String {\n     to_string(|s| s.print_where_clause(i))\n }\n \n-pub fn fn_block_to_string(p: &hir::FnDecl) -> String {\n-    to_string(|s| s.print_fn_block_args(p))\n-}\n-\n pub fn path_to_string(p: &hir::Path) -> String {\n     to_string(|s| s.print_path(p, false))\n }\n@@ -283,24 +278,35 @@ pub fn name_to_string(name: ast::Name) -> String {\n     to_string(|s| s.print_name(name))\n }\n \n-pub fn fun_to_string(decl: &hir::FnDecl,\n-                     unsafety: hir::Unsafety,\n-                     constness: hir::Constness,\n-                     name: ast::Name,\n-                     generics: &hir::Generics)\n-                     -> String {\n-    to_string(|s| {\n-        s.head(\"\")?;\n-        s.print_fn(decl,\n-                   unsafety,\n-                   constness,\n-                   Abi::Rust,\n-                   Some(name),\n-                   generics,\n-                   &hir::Inherited)?;\n-        s.end()?; // Close the head box\n-        s.end() // Close the outer box\n-    })\n+pub fn fn_decl_in_crate_to_string(krate: &hir::Crate,\n+                                  decl: &hir::FnDecl,\n+                                  unsafety: hir::Unsafety,\n+                                  constness: hir::Constness,\n+                                  name: ast::Name,\n+                                  generics: &hir::Generics,\n+                                  body_id: hir::BodyId)\n+                                  -> String {\n+\n+    let mut wr = Vec::new();\n+    {\n+        let mut s = rust_printer(Box::new(&mut wr), Some(krate));\n+        (|s: &mut State| {\n+            s.head(\"\")?;\n+            s.print_fn(decl,\n+                       unsafety,\n+                       constness,\n+                       Abi::Rust,\n+                       Some(name),\n+                       generics,\n+                       &hir::Inherited,\n+                       &[],\n+                       Some(body_id))?;\n+            s.end()?; // Close the head box\n+            s.end()?; // Close the outer box\n+            eof(&mut s.s)\n+        })(&mut s).unwrap();\n+    }\n+    String::from_utf8(wr).unwrap()\n }\n \n pub fn block_to_string(blk: &hir::Block) -> String {\n@@ -317,10 +323,6 @@ pub fn variant_to_string(var: &hir::Variant) -> String {\n     to_string(|s| s.print_variant(var))\n }\n \n-pub fn arg_to_string(arg: &hir::Arg) -> String {\n-    to_string(|s| s.print_arg(arg, false))\n-}\n-\n pub fn visibility_qualified(vis: &hir::Visibility, s: &str) -> String {\n     match *vis {\n         hir::Public => format!(\"pub {}\", s),\n@@ -569,15 +571,17 @@ impl<'a> State<'a> {\n         self.maybe_print_comment(item.span.lo)?;\n         self.print_outer_attributes(&item.attrs)?;\n         match item.node {\n-            hir::ForeignItemFn(ref decl, ref generics) => {\n+            hir::ForeignItemFn(ref decl, ref arg_names, ref generics) => {\n                 self.head(\"\")?;\n                 self.print_fn(decl,\n                               hir::Unsafety::Normal,\n                               hir::Constness::NotConst,\n                               Abi::Rust,\n                               Some(item.name),\n                               generics,\n-                              &item.vis)?;\n+                              &item.vis,\n+                              arg_names,\n+                              None)?;\n                 self.end()?; // end head-ibox\n                 word(&mut self.s, \";\")?;\n                 self.end() // end the outer fn box\n@@ -644,13 +648,14 @@ impl<'a> State<'a> {\n         }\n     }\n \n+    fn maybe_body(&mut self, body_id: hir::BodyId) -> Option<&'a hir::Body> {\n+        self.krate.map(|krate| krate.body(body_id))\n+    }\n+\n     fn print_body_id(&mut self, body_id: hir::BodyId) -> io::Result<()> {\n-        if let Some(krate) = self.krate {\n-            let expr = &krate.body(body_id).value;\n-            self.print_expr(expr)\n-        } else {\n-            Ok(())\n-        }\n+        self.maybe_body(body_id).map_or(Ok(()), |body| {\n+            self.print_expr(&body.value)\n+        })\n     }\n \n     /// Pretty-print an item\n@@ -734,7 +739,9 @@ impl<'a> State<'a> {\n                               abi,\n                               Some(item.name),\n                               typarams,\n-                              &item.vis)?;\n+                              &item.vis,\n+                              &[],\n+                              Some(body))?;\n                 word(&mut self.s, \" \")?;\n                 self.end()?; // need to close a box\n                 self.end()?; // need to close a box\n@@ -995,15 +1002,19 @@ impl<'a> State<'a> {\n     pub fn print_method_sig(&mut self,\n                             name: ast::Name,\n                             m: &hir::MethodSig,\n-                            vis: &hir::Visibility)\n+                            vis: &hir::Visibility,\n+                            arg_names: &[Spanned<ast::Name>],\n+                            body_id: Option<hir::BodyId>)\n                             -> io::Result<()> {\n         self.print_fn(&m.decl,\n                       m.unsafety,\n                       m.constness,\n                       m.abi,\n                       Some(name),\n                       &m.generics,\n-                      vis)\n+                      vis,\n+                      arg_names,\n+                      body_id)\n     }\n \n     pub fn print_trait_item_ref(&mut self, item_ref: &hir::TraitItemRef) -> io::Result<()> {\n@@ -1025,19 +1036,17 @@ impl<'a> State<'a> {\n             hir::TraitItemKind::Const(ref ty, default) => {\n                 self.print_associated_const(ti.name, &ty, default, &hir::Inherited)?;\n             }\n-            hir::TraitItemKind::Method(ref sig, body) => {\n-                if body.is_some() {\n-                    self.head(\"\")?;\n-                }\n-                self.print_method_sig(ti.name, sig, &hir::Inherited)?;\n-                if let Some(body) = body {\n-                    self.nbsp()?;\n-                    self.end()?; // need to close a box\n-                    self.end()?; // need to close a box\n-                    self.print_body_id(body)?;\n-                } else {\n-                    word(&mut self.s, \";\")?;\n-                }\n+            hir::TraitItemKind::Method(ref sig, hir::TraitMethod::Required(ref arg_names)) => {\n+                self.print_method_sig(ti.name, sig, &hir::Inherited, arg_names, None)?;\n+                word(&mut self.s, \";\")?;\n+            }\n+            hir::TraitItemKind::Method(ref sig, hir::TraitMethod::Provided(body)) => {\n+                self.head(\"\")?;\n+                self.print_method_sig(ti.name, sig, &hir::Inherited, &[], Some(body))?;\n+                self.nbsp()?;\n+                self.end()?; // need to close a box\n+                self.end()?; // need to close a box\n+                self.print_body_id(body)?;\n             }\n             hir::TraitItemKind::Type(ref bounds, ref default) => {\n                 self.print_associated_type(ti.name,\n@@ -1075,7 +1084,7 @@ impl<'a> State<'a> {\n             }\n             hir::ImplItemKind::Method(ref sig, body) => {\n                 self.head(\"\")?;\n-                self.print_method_sig(ii.name, sig, &ii.vis)?;\n+                self.print_method_sig(ii.name, sig, &ii.vis, &[], Some(body))?;\n                 self.nbsp()?;\n                 self.end()?; // need to close a box\n                 self.end()?; // need to close a box\n@@ -1442,7 +1451,7 @@ impl<'a> State<'a> {\n             hir::ExprClosure(capture_clause, ref decl, body, _fn_decl_span) => {\n                 self.print_capture_clause(capture_clause)?;\n \n-                self.print_fn_block_args(&decl)?;\n+                self.print_closure_args(&decl, body)?;\n                 space(&mut self.s)?;\n \n                 // this is a bare expression\n@@ -1966,7 +1975,9 @@ impl<'a> State<'a> {\n                     abi: Abi,\n                     name: Option<ast::Name>,\n                     generics: &hir::Generics,\n-                    vis: &hir::Visibility)\n+                    vis: &hir::Visibility,\n+                    arg_names: &[Spanned<ast::Name>],\n+                    body_id: Option<hir::BodyId>)\n                     -> io::Result<()> {\n         self.print_fn_header_info(unsafety, constness, abi, vis)?;\n \n@@ -1975,24 +1986,58 @@ impl<'a> State<'a> {\n             self.print_name(name)?;\n         }\n         self.print_generics(generics)?;\n-        self.print_fn_args_and_ret(decl)?;\n-        self.print_where_clause(&generics.where_clause)\n-    }\n \n-    pub fn print_fn_args_and_ret(&mut self, decl: &hir::FnDecl) -> io::Result<()> {\n         self.popen()?;\n-        self.commasep(Inconsistent, &decl.inputs, |s, arg| s.print_arg(arg, false))?;\n+        let mut i = 0;\n+        // Make sure we aren't supplied *both* `arg_names` and `body_id`.\n+        assert!(arg_names.is_empty() || body_id.is_none());\n+        let args = body_id.and_then(|body_id| self.maybe_body(body_id))\n+                          .map_or(&[][..], |body| &body.arguments[..]);\n+        self.commasep(Inconsistent, &decl.inputs, |s, ty| {\n+            s.ibox(indent_unit)?;\n+            if let Some(name) = arg_names.get(i) {\n+                word(&mut s.s, &name.node.as_str())?;\n+                word(&mut s.s, \":\")?;\n+                space(&mut s.s)?;\n+            } else if let Some(arg) = args.get(i) {\n+                s.print_pat(&arg.pat)?;\n+                word(&mut s.s, \":\")?;\n+                space(&mut s.s)?;\n+            }\n+            i += 1;\n+            s.print_type(ty)?;\n+            s.end()\n+        })?;\n         if decl.variadic {\n             word(&mut self.s, \", ...\")?;\n         }\n         self.pclose()?;\n \n-        self.print_fn_output(decl)\n+        self.print_fn_output(decl)?;\n+        self.print_where_clause(&generics.where_clause)\n     }\n \n-    pub fn print_fn_block_args(&mut self, decl: &hir::FnDecl) -> io::Result<()> {\n+    fn print_closure_args(&mut self, decl: &hir::FnDecl, body_id: hir::BodyId) -> io::Result<()> {\n         word(&mut self.s, \"|\")?;\n-        self.commasep(Inconsistent, &decl.inputs, |s, arg| s.print_arg(arg, true))?;\n+        let mut i = 0;\n+        let args = self.maybe_body(body_id).map_or(&[][..], |body| &body.arguments[..]);\n+        self.commasep(Inconsistent, &decl.inputs, |s, ty| {\n+            s.ibox(indent_unit)?;\n+\n+            if let Some(arg) = args.get(i) {\n+                s.print_pat(&arg.pat)?;\n+            } else {\n+                word(&mut s.s, \"_\")?;\n+            }\n+            i += 1;\n+\n+            if ty.node != hir::TyInfer {\n+                word(&mut s.s, \":\")?;\n+                space(&mut s.s)?;\n+                s.print_type(ty)?;\n+            }\n+            s.end()\n+        })?;\n         word(&mut self.s, \"|\")?;\n \n         if let hir::DefaultReturn(..) = decl.output {\n@@ -2164,27 +2209,6 @@ impl<'a> State<'a> {\n         self.print_type(&mt.ty)\n     }\n \n-    pub fn print_arg(&mut self, input: &hir::Arg, is_closure: bool) -> io::Result<()> {\n-        self.ibox(indent_unit)?;\n-        match input.ty.node {\n-            hir::TyInfer if is_closure => self.print_pat(&input.pat)?,\n-            _ => {\n-                let invalid = if let PatKind::Binding(_, _, name, _) = input.pat.node {\n-                    name.node == keywords::Invalid.name()\n-                } else {\n-                    false\n-                };\n-                if !invalid {\n-                    self.print_pat(&input.pat)?;\n-                    word(&mut self.s, \":\")?;\n-                    space(&mut self.s)?;\n-                }\n-                self.print_type(&input.ty)?;\n-            }\n-        }\n-        self.end()\n-    }\n-\n     pub fn print_fn_output(&mut self, decl: &hir::FnDecl) -> io::Result<()> {\n         if let hir::DefaultReturn(..) = decl.output {\n             return Ok(());\n@@ -2232,7 +2256,9 @@ impl<'a> State<'a> {\n                       abi,\n                       name,\n                       &generics,\n-                      &hir::Inherited)?;\n+                      &hir::Inherited,\n+                      &[],\n+                      None)?;\n         self.end()\n     }\n "}, {"sha": "7d8ee33b4bed7b92897a8ef6c67b37270b8902ff", "filename": "src/librustc/infer/error_reporting.rs", "status": "modified", "additions": 25, "deletions": 26, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/f89856be6ccd1f63ef72d343587cd5d7932cfe8b/src%2Flibrustc%2Finfer%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f89856be6ccd1f63ef72d343587cd5d7932cfe8b/src%2Flibrustc%2Finfer%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ferror_reporting.rs?ref=f89856be6ccd1f63ef72d343587cd5d7932cfe8b", "patch": "@@ -1051,8 +1051,8 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n             Some(ref node) => match *node {\n                 ast_map::NodeItem(ref item) => {\n                     match item.node {\n-                        hir::ItemFn(ref fn_decl, unsafety, constness, _, ref gen, _) => {\n-                            Some((fn_decl, gen, unsafety, constness, item.name, item.span))\n+                        hir::ItemFn(ref fn_decl, unsafety, constness, _, ref gen, body) => {\n+                            Some((fn_decl, gen, unsafety, constness, item.name, item.span, body))\n                         }\n                         _ => None,\n                     }\n@@ -1066,26 +1066,28 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                             return;\n                         }\n                     }\n-                    if let hir::ImplItemKind::Method(ref sig, _) = item.node {\n+                    if let hir::ImplItemKind::Method(ref sig, body) = item.node {\n                         Some((&sig.decl,\n                               &sig.generics,\n                               sig.unsafety,\n                               sig.constness,\n                               item.name,\n-                              item.span))\n+                              item.span,\n+                              body))\n                     } else {\n                         None\n                     }\n                 },\n                 ast_map::NodeTraitItem(item) => {\n                     match item.node {\n-                        hir::TraitItemKind::Method(ref sig, Some(_)) => {\n+                        hir::TraitItemKind::Method(ref sig, hir::TraitMethod::Provided(body)) => {\n                             Some((&sig.decl,\n                                   &sig.generics,\n                                   sig.unsafety,\n                                   sig.constness,\n                                   item.name,\n-                                  item.span))\n+                                  item.span,\n+                                  body))\n                         }\n                         _ => None,\n                     }\n@@ -1094,12 +1096,12 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n             },\n             None => None,\n         };\n-        let (fn_decl, generics, unsafety, constness, name, span)\n+        let (fn_decl, generics, unsafety, constness, name, span, body)\n                                     = node_inner.expect(\"expect item fn\");\n         let rebuilder = Rebuilder::new(self.tcx, fn_decl, generics, same_regions, &life_giver);\n         let (fn_decl, generics) = rebuilder.rebuild();\n         self.give_expl_lifetime_param(\n-            err, &fn_decl, unsafety, constness, name, &generics, span);\n+            err, &fn_decl, unsafety, constness, name, &generics, span, body);\n     }\n \n     pub fn issue_32330_warnings(&self, span: Span, issue32330s: &[ty::Issue32330]) {\n@@ -1375,23 +1377,14 @@ impl<'a, 'gcx, 'tcx> Rebuilder<'a, 'gcx, 'tcx> {\n     }\n \n     fn rebuild_args_ty(&self,\n-                       inputs: &[hir::Arg],\n+                       inputs: &[P<hir::Ty>],\n                        lifetime: hir::Lifetime,\n                        anon_nums: &HashSet<u32>,\n                        region_names: &HashSet<ast::Name>)\n-                       -> hir::HirVec<hir::Arg> {\n-        let mut new_inputs = Vec::new();\n-        for arg in inputs {\n-            let new_ty = self.rebuild_arg_ty_or_output(&arg.ty, lifetime,\n-                                                       anon_nums, region_names);\n-            let possibly_new_arg = hir::Arg {\n-                ty: new_ty,\n-                pat: arg.pat.clone(),\n-                id: arg.id\n-            };\n-            new_inputs.push(possibly_new_arg);\n-        }\n-        new_inputs.into()\n+                       -> hir::HirVec<P<hir::Ty>> {\n+        inputs.iter().map(|arg_ty| {\n+            self.rebuild_arg_ty_or_output(arg_ty, lifetime, anon_nums, region_names)\n+        }).collect()\n     }\n \n     fn rebuild_output(&self, ty: &hir::FunctionRetTy,\n@@ -1634,10 +1627,16 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                                 constness: hir::Constness,\n                                 name: ast::Name,\n                                 generics: &hir::Generics,\n-                                span: Span) {\n-        let suggested_fn = pprust::fun_to_string(decl, unsafety, constness, name, generics);\n-        let msg = format!(\"consider using an explicit lifetime \\\n-                           parameter as shown: {}\", suggested_fn);\n+                                span: Span,\n+                                body: hir::BodyId) {\n+        let s = pprust::fn_decl_in_crate_to_string(self.tcx.map.krate(),\n+                                                   decl,\n+                                                   unsafety,\n+                                                   constness,\n+                                                   name,\n+                                                   generics,\n+                                                   body);\n+        let msg = format!(\"consider using an explicit lifetime parameter as shown: {}\", s);\n         err.span_help(span, &msg[..]);\n     }\n "}, {"sha": "7dcc5aae8e7373ee561e03609de4e25b086c0fe7", "filename": "src/librustc/middle/cstore.rs", "status": "modified", "additions": 8, "deletions": 24, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/f89856be6ccd1f63ef72d343587cd5d7932cfe8b/src%2Flibrustc%2Fmiddle%2Fcstore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f89856be6ccd1f63ef72d343587cd5d7932cfe8b/src%2Flibrustc%2Fmiddle%2Fcstore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcstore.rs?ref=f89856be6ccd1f63ef72d343587cd5d7932cfe8b", "patch": "@@ -140,7 +140,6 @@ pub struct NativeLibrary {\n pub struct InlinedItem {\n     pub def_id: DefId,\n     pub body: hir::Body,\n-    pub const_fn_args: Vec<Option<DefId>>,\n }\n \n /// A borrowed version of `hir::InlinedItem`. This is what's encoded when saving\n@@ -149,41 +148,30 @@ pub struct InlinedItem {\n pub struct InlinedItemRef<'a> {\n     pub def_id: DefId,\n     pub body: &'a hir::Body,\n-    pub const_fn_args: Vec<Option<DefId>>,\n-}\n-\n-fn get_fn_args(decl: &hir::FnDecl) -> Vec<Option<DefId>> {\n-    decl.inputs.iter().map(|arg| match arg.pat.node {\n-        hir::PatKind::Binding(_, def_id, _, _) => Some(def_id),\n-        _ => None\n-    }).collect()\n }\n \n impl<'a, 'tcx> InlinedItemRef<'tcx> {\n     pub fn from_item(def_id: DefId,\n                      item: &hir::Item,\n                      tcx: TyCtxt<'a, 'tcx, 'tcx>)\n                      -> InlinedItemRef<'tcx> {\n-        let (body_id, args) = match item.node {\n-            hir::ItemFn(ref decl, _, _, _, _, body_id) =>\n-                (body_id, get_fn_args(decl)),\n-            hir::ItemConst(_, body_id) => (body_id, vec![]),\n+        let body_id = match item.node {\n+            hir::ItemFn(.., body_id) |\n+            hir::ItemConst(_, body_id) => body_id,\n             _ => bug!(\"InlinedItemRef::from_item wrong kind\")\n         };\n         InlinedItemRef {\n             def_id: def_id,\n             body: tcx.map.body(body_id),\n-            const_fn_args: args\n         }\n     }\n \n     pub fn from_trait_item(def_id: DefId,\n                            item: &hir::TraitItem,\n                            tcx: TyCtxt<'a, 'tcx, 'tcx>)\n                            -> InlinedItemRef<'tcx> {\n-        let (body_id, args) = match item.node {\n-            hir::TraitItemKind::Const(_, Some(body_id)) =>\n-                (body_id, vec![]),\n+        let body_id = match item.node {\n+            hir::TraitItemKind::Const(_, Some(body_id)) => body_id,\n             hir::TraitItemKind::Const(_, None) => {\n                 bug!(\"InlinedItemRef::from_trait_item called for const without body\")\n             },\n@@ -192,25 +180,21 @@ impl<'a, 'tcx> InlinedItemRef<'tcx> {\n         InlinedItemRef {\n             def_id: def_id,\n             body: tcx.map.body(body_id),\n-            const_fn_args: args\n         }\n     }\n \n     pub fn from_impl_item(def_id: DefId,\n                           item: &hir::ImplItem,\n                           tcx: TyCtxt<'a, 'tcx, 'tcx>)\n                           -> InlinedItemRef<'tcx> {\n-        let (body_id, args) = match item.node {\n-            hir::ImplItemKind::Method(ref sig, body_id) =>\n-                (body_id, get_fn_args(&sig.decl)),\n-            hir::ImplItemKind::Const(_, body_id) =>\n-                (body_id, vec![]),\n+        let body_id = match item.node {\n+            hir::ImplItemKind::Method(_, body_id) |\n+            hir::ImplItemKind::Const(_, body_id) => body_id,\n             _ => bug!(\"InlinedItemRef::from_impl_item wrong kind\")\n         };\n         InlinedItemRef {\n             def_id: def_id,\n             body: tcx.map.body(body_id),\n-            const_fn_args: args\n         }\n     }\n "}, {"sha": "3f2893a9e24a0d8188cf183fe765b60324274fb7", "filename": "src/librustc/middle/dataflow.rs", "status": "modified", "additions": 15, "deletions": 11, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/f89856be6ccd1f63ef72d343587cd5d7932cfe8b/src%2Flibrustc%2Fmiddle%2Fdataflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f89856be6ccd1f63ef72d343587cd5d7932cfe8b/src%2Flibrustc%2Fmiddle%2Fdataflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fdataflow.rs?ref=f89856be6ccd1f63ef72d343587cd5d7932cfe8b", "patch": "@@ -160,16 +160,16 @@ impl<'a, 'tcx, O:DataFlowOperator> pprust::PpAnn for DataFlowContext<'a, 'tcx, O\n     }\n }\n \n-fn build_nodeid_to_index(decl: Option<&hir::FnDecl>,\n+fn build_nodeid_to_index(body: Option<&hir::Body>,\n                          cfg: &cfg::CFG) -> NodeMap<Vec<CFGIndex>> {\n     let mut index = NodeMap();\n \n     // FIXME (#6298): Would it be better to fold formals from decl\n     // into cfg itself?  i.e. introduce a fn-based flow-graph in\n     // addition to the current block-based flow-graph, rather than\n     // have to put traversals like this here?\n-    if let Some(decl) = decl {\n-        add_entries_from_fn_decl(&mut index, decl, cfg.entry);\n+    if let Some(body) = body {\n+        add_entries_from_fn_body(&mut index, body, cfg.entry);\n     }\n \n     cfg.graph.each_node(|node_idx, node| {\n@@ -181,18 +181,22 @@ fn build_nodeid_to_index(decl: Option<&hir::FnDecl>,\n \n     return index;\n \n-    fn add_entries_from_fn_decl(index: &mut NodeMap<Vec<CFGIndex>>,\n-                                decl: &hir::FnDecl,\n+    /// Add mappings from the ast nodes for the formal bindings to\n+    /// the entry-node in the graph.\n+    fn add_entries_from_fn_body(index: &mut NodeMap<Vec<CFGIndex>>,\n+                                body: &hir::Body,\n                                 entry: CFGIndex) {\n-        //! add mappings from the ast nodes for the formal bindings to\n-        //! the entry-node in the graph.\n+        use hir::intravisit::Visitor;\n+\n         struct Formals<'a> {\n             entry: CFGIndex,\n             index: &'a mut NodeMap<Vec<CFGIndex>>,\n         }\n         let mut formals = Formals { entry: entry, index: index };\n-        intravisit::walk_fn_decl(&mut formals, decl);\n-        impl<'a, 'v> intravisit::Visitor<'v> for Formals<'a> {\n+        for arg in &body.arguments {\n+            formals.visit_pat(&arg.pat);\n+        }\n+        impl<'a, 'v> Visitor<'v> for Formals<'a> {\n             fn nested_visit_map<'this>(&'this mut self) -> intravisit::NestedVisitorMap<'this, 'v> {\n                 intravisit::NestedVisitorMap::None\n             }\n@@ -227,7 +231,7 @@ pub enum KillFrom {\n impl<'a, 'tcx, O:DataFlowOperator> DataFlowContext<'a, 'tcx, O> {\n     pub fn new(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                analysis_name: &'static str,\n-               decl: Option<&hir::FnDecl>,\n+               body: Option<&hir::Body>,\n                cfg: &cfg::CFG,\n                oper: O,\n                id_range: IdRange,\n@@ -250,7 +254,7 @@ impl<'a, 'tcx, O:DataFlowOperator> DataFlowContext<'a, 'tcx, O> {\n         let kills2 = zeroes;\n         let on_entry = vec![entry; num_nodes * words_per_id];\n \n-        let nodeid_to_index = build_nodeid_to_index(decl, cfg);\n+        let nodeid_to_index = build_nodeid_to_index(body, cfg);\n \n         DataFlowContext {\n             tcx: tcx,"}, {"sha": "76adee4e00c15684ec411deddddf5daa2232cb45", "filename": "src/librustc/middle/dead.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f89856be6ccd1f63ef72d343587cd5d7932cfe8b/src%2Flibrustc%2Fmiddle%2Fdead.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f89856be6ccd1f63ef72d343587cd5d7932cfe8b/src%2Flibrustc%2Fmiddle%2Fdead.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fdead.rs?ref=f89856be6ccd1f63ef72d343587cd5d7932cfe8b", "patch": "@@ -333,7 +333,7 @@ impl<'v, 'k> ItemLikeVisitor<'v> for LifeSeeder<'k> {\n                     let trait_item = self.krate.trait_item(trait_item_ref.id);\n                     match trait_item.node {\n                         hir::TraitItemKind::Const(_, Some(_)) |\n-                        hir::TraitItemKind::Method(_, Some(_)) => {\n+                        hir::TraitItemKind::Method(_, hir::TraitMethod::Provided(_)) => {\n                             if has_allow_dead_code_or_lang_attr(&trait_item.attrs) {\n                                 self.worklist.push(trait_item.id);\n                             }\n@@ -573,11 +573,11 @@ impl<'a, 'tcx> Visitor<'tcx> for DeadVisitor<'a, 'tcx> {\n     fn visit_trait_item(&mut self, trait_item: &'tcx hir::TraitItem) {\n         match trait_item.node {\n             hir::TraitItemKind::Const(_, Some(body_id)) |\n-            hir::TraitItemKind::Method(_, Some(body_id)) => {\n+            hir::TraitItemKind::Method(_, hir::TraitMethod::Provided(body_id)) => {\n                 self.visit_nested_body(body_id)\n             }\n             hir::TraitItemKind::Const(_, None) |\n-            hir::TraitItemKind::Method(_, None) |\n+            hir::TraitItemKind::Method(_, hir::TraitMethod::Required(_)) |\n             hir::TraitItemKind::Type(..) => {}\n         }\n     }"}, {"sha": "9ba26a0bf1de391dd89c8b822f9618d4d21165f4", "filename": "src/librustc/middle/expr_use_visitor.rs", "status": "modified", "additions": 5, "deletions": 12, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/f89856be6ccd1f63ef72d343587cd5d7932cfe8b/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f89856be6ccd1f63ef72d343587cd5d7932cfe8b/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs?ref=f89856be6ccd1f63ef72d343587cd5d7932cfe8b", "patch": "@@ -287,20 +287,11 @@ impl<'a, 'gcx, 'tcx> ExprUseVisitor<'a, 'gcx, 'tcx> {\n         }\n     }\n \n-    pub fn walk_fn(&mut self,\n-                   decl: &hir::FnDecl,\n-                   body: &hir::Body) {\n-        self.walk_arg_patterns(decl, &body.value);\n-        self.consume_expr(&body.value);\n-    }\n-\n-    fn walk_arg_patterns(&mut self,\n-                         decl: &hir::FnDecl,\n-                         body: &hir::Expr) {\n-        for arg in &decl.inputs {\n+    pub fn walk_fn(&mut self, body: &hir::Body) {\n+        for arg in &body.arguments {\n             let arg_ty = return_if_err!(self.mc.infcx.node_ty(arg.pat.id));\n \n-            let fn_body_scope_r = self.tcx().node_scope_region(body.id);\n+            let fn_body_scope_r = self.tcx().node_scope_region(body.value.id);\n             let arg_cmt = self.mc.cat_rvalue(\n                 arg.id,\n                 arg.pat.span,\n@@ -309,6 +300,8 @@ impl<'a, 'gcx, 'tcx> ExprUseVisitor<'a, 'gcx, 'tcx> {\n \n             self.walk_irrefutable_pat(arg_cmt, &arg.pat);\n         }\n+\n+        self.consume_expr(&body.value);\n     }\n \n     fn tcx(&self) -> TyCtxt<'a, 'gcx, 'tcx> {"}, {"sha": "021cb9bb72d515c98059267dab591dd48176dd2d", "filename": "src/librustc/middle/liveness.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/f89856be6ccd1f63ef72d343587cd5d7932cfe8b/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f89856be6ccd1f63ef72d343587cd5d7932cfe8b/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fliveness.rs?ref=f89856be6ccd1f63ef72d343587cd5d7932cfe8b", "patch": "@@ -381,7 +381,9 @@ fn visit_fn<'a, 'tcx: 'a>(ir: &mut IrMaps<'a, 'tcx>,\n \n     debug!(\"creating fn_maps: {:?}\", &fn_maps as *const IrMaps);\n \n-    for arg in &decl.inputs {\n+    let body = ir.tcx.map.body(body_id);\n+\n+    for arg in &body.arguments {\n         arg.pat.each_binding(|_bm, arg_id, _x, path1| {\n             debug!(\"adding argument {}\", arg_id);\n             let name = path1.node;\n@@ -404,16 +406,14 @@ fn visit_fn<'a, 'tcx: 'a>(ir: &mut IrMaps<'a, 'tcx>,\n         clean_exit_var: fn_maps.add_variable(CleanExit)\n     };\n \n-    let body = ir.tcx.map.body(body_id);\n-\n     // compute liveness\n     let mut lsets = Liveness::new(&mut fn_maps, specials);\n     let entry_ln = lsets.compute(&body.value);\n \n     // check for various error conditions\n     lsets.visit_body(body);\n     lsets.check_ret(id, sp, fk, entry_ln, body);\n-    lsets.warn_about_unused_args(decl, entry_ln);\n+    lsets.warn_about_unused_args(body, entry_ln);\n }\n \n fn visit_local<'a, 'tcx>(ir: &mut IrMaps<'a, 'tcx>, local: &'tcx hir::Local) {\n@@ -1502,8 +1502,8 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n         }\n     }\n \n-    fn warn_about_unused_args(&self, decl: &hir::FnDecl, entry_ln: LiveNode) {\n-        for arg in &decl.inputs {\n+    fn warn_about_unused_args(&self, body: &hir::Body, entry_ln: LiveNode) {\n+        for arg in &body.arguments {\n             arg.pat.each_binding(|_bm, p_id, sp, path1| {\n                 let var = self.variable(p_id, sp);\n                 // Ignore unused self."}, {"sha": "ee841afc02169e96d0d5cf15eb1197a2f6ca650c", "filename": "src/librustc/middle/reachable.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/f89856be6ccd1f63ef72d343587cd5d7932cfe8b/src%2Flibrustc%2Fmiddle%2Freachable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f89856be6ccd1f63ef72d343587cd5d7932cfe8b/src%2Flibrustc%2Fmiddle%2Freachable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Freachable.rs?ref=f89856be6ccd1f63ef72d343587cd5d7932cfe8b", "patch": "@@ -167,7 +167,8 @@ impl<'a, 'tcx> ReachableContext<'a, 'tcx> {\n             Some(ast_map::NodeTraitItem(trait_method)) => {\n                 match trait_method.node {\n                     hir::TraitItemKind::Const(_, ref default) => default.is_some(),\n-                    hir::TraitItemKind::Method(_, ref body) => body.is_some(),\n+                    hir::TraitItemKind::Method(_, hir::TraitMethod::Provided(_)) => true,\n+                    hir::TraitItemKind::Method(_, hir::TraitMethod::Required(_)) |\n                     hir::TraitItemKind::Type(..) => false,\n                 }\n             }\n@@ -275,11 +276,11 @@ impl<'a, 'tcx> ReachableContext<'a, 'tcx> {\n             ast_map::NodeTraitItem(trait_method) => {\n                 match trait_method.node {\n                     hir::TraitItemKind::Const(_, None) |\n-                    hir::TraitItemKind::Method(_, None) => {\n+                    hir::TraitItemKind::Method(_, hir::TraitMethod::Required(_)) => {\n                         // Keep going, nothing to get exported\n                     }\n                     hir::TraitItemKind::Const(_, Some(body_id)) |\n-                    hir::TraitItemKind::Method(_, Some(body_id)) => {\n+                    hir::TraitItemKind::Method(_, hir::TraitMethod::Provided(body_id)) => {\n                         self.visit_nested_body(body_id);\n                     }\n                     hir::TraitItemKind::Type(..) => {}"}, {"sha": "140beefb020bb6e3dc07617f1dbcf937dfbdecf3", "filename": "src/librustc/middle/resolve_lifetime.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/f89856be6ccd1f63ef72d343587cd5d7932cfe8b/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f89856be6ccd1f63ef72d343587cd5d7932cfe8b/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs?ref=f89856be6ccd1f63ef72d343587cd5d7932cfe8b", "patch": "@@ -190,7 +190,7 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n         // Items always introduce a new root scope\n         self.with(RootScope, |_, this| {\n             match item.node {\n-                hir::ForeignItemFn(ref decl, ref generics) => {\n+                hir::ForeignItemFn(ref decl, _, ref generics) => {\n                     this.visit_early_late(item.id, decl, generics, |this| {\n                         intravisit::walk_foreign_item(this, item);\n                     })\n@@ -266,7 +266,8 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n         // methods in an impl can reuse label names.\n         let saved = replace(&mut self.labels_in_fn, vec![]);\n \n-        if let hir::TraitItemKind::Method(ref sig, None) = trait_item.node {\n+        if let hir::TraitItemKind::Method(ref sig, hir::TraitMethod::Required(_)) =\n+                trait_item.node {\n             self.visit_early_late(\n                 trait_item.id,\n                 &sig.decl, &sig.generics,\n@@ -860,8 +861,8 @@ fn insert_late_bound_lifetimes(map: &mut NamedRegionMap,\n     debug!(\"insert_late_bound_lifetimes(decl={:?}, generics={:?})\", decl, generics);\n \n     let mut constrained_by_input = ConstrainedCollector { regions: FxHashSet() };\n-    for arg in &decl.inputs {\n-        constrained_by_input.visit_ty(&arg.ty);\n+    for arg_ty in &decl.inputs {\n+        constrained_by_input.visit_ty(arg_ty);\n     }\n \n     let mut appears_in_output = AllCollector {"}, {"sha": "b03a432de413107a4c4a25f69c552ba3a1db7679", "filename": "src/librustc/ty/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f89856be6ccd1f63ef72d343587cd5d7932cfe8b/src%2Flibrustc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f89856be6ccd1f63ef72d343587cd5d7932cfe8b/src%2Flibrustc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmod.rs?ref=f89856be6ccd1f63ef72d343587cd5d7932cfe8b", "patch": "@@ -1225,7 +1225,7 @@ impl<'a, 'tcx> ParameterEnvironment<'tcx> {\n                         // Use call-site for extent (unless this is a\n                         // trait method with no default; then fallback\n                         // to the method id).\n-                        let extent = if let Some(body_id) = *body {\n+                        let extent = if let hir::TraitMethod::Provided(body_id) = *body {\n                             // default impl: use call_site extent as free_id_outlive bound.\n                             tcx.region_maps.call_site_extent(id, body_id.node_id)\n                         } else {"}, {"sha": "f7249784dba45ced51aca533baf3a183703abcb4", "filename": "src/librustc_borrowck/borrowck/check_loans.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/f89856be6ccd1f63ef72d343587cd5d7932cfe8b/src%2Flibrustc_borrowck%2Fborrowck%2Fcheck_loans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f89856be6ccd1f63ef72d343587cd5d7932cfe8b/src%2Flibrustc_borrowck%2Fborrowck%2Fcheck_loans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fcheck_loans.rs?ref=f89856be6ccd1f63ef72d343587cd5d7932cfe8b", "patch": "@@ -189,7 +189,6 @@ pub fn check_loans<'a, 'b, 'c, 'tcx>(bccx: &BorrowckCtxt<'a, 'tcx>,\n                                      move_data: &move_data::FlowedMoveData<'c, 'tcx>,\n                                      all_loans: &[Loan<'tcx>],\n                                      fn_id: ast::NodeId,\n-                                     decl: &hir::FnDecl,\n                                      body: &hir::Body) {\n     debug!(\"check_loans(body id={})\", body.value.id);\n \n@@ -202,7 +201,7 @@ pub fn check_loans<'a, 'b, 'c, 'tcx>(bccx: &BorrowckCtxt<'a, 'tcx>,\n         all_loans: all_loans,\n         param_env: &infcx.parameter_environment\n     };\n-    euv::ExprUseVisitor::new(&mut clcx, &infcx).walk_fn(decl, body);\n+    euv::ExprUseVisitor::new(&mut clcx, &infcx).walk_fn(body);\n }\n \n #[derive(PartialEq)]"}, {"sha": "c9e526202fa68e9554311e83ec0389b399864a09", "filename": "src/librustc_borrowck/borrowck/gather_loans/mod.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/f89856be6ccd1f63ef72d343587cd5d7932cfe8b/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f89856be6ccd1f63ef72d343587cd5d7932cfe8b/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fmod.rs?ref=f89856be6ccd1f63ef72d343587cd5d7932cfe8b", "patch": "@@ -41,7 +41,6 @@ mod move_error;\n \n pub fn gather_loans_in_fn<'a, 'tcx>(bccx: &BorrowckCtxt<'a, 'tcx>,\n                                     fn_id: NodeId,\n-                                    decl: &hir::FnDecl,\n                                     body: &hir::Body)\n                                     -> (Vec<Loan<'tcx>>,\n                                         move_data::MoveData<'tcx>) {\n@@ -55,7 +54,7 @@ pub fn gather_loans_in_fn<'a, 'tcx>(bccx: &BorrowckCtxt<'a, 'tcx>,\n \n     let param_env = ty::ParameterEnvironment::for_item(bccx.tcx, fn_id);\n     let infcx = bccx.tcx.borrowck_fake_infer_ctxt(param_env);\n-    euv::ExprUseVisitor::new(&mut glcx, &infcx).walk_fn(decl, body);\n+    euv::ExprUseVisitor::new(&mut glcx, &infcx).walk_fn(body);\n \n     glcx.report_potential_errors();\n     let GatherLoanCtxt { all_loans, move_data, .. } = glcx;"}, {"sha": "1ba313015d59685c82af9830cd77a9923b20352d", "filename": "src/librustc_borrowck/borrowck/mod.rs", "status": "modified", "additions": 16, "deletions": 21, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/f89856be6ccd1f63ef72d343587cd5d7932cfe8b/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f89856be6ccd1f63ef72d343587cd5d7932cfe8b/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs?ref=f89856be6ccd1f63ef72d343587cd5d7932cfe8b", "patch": "@@ -179,7 +179,7 @@ fn borrowck_fn<'a, 'tcx>(this: &mut BorrowckCtxt<'a, 'tcx>,\n     let AnalysisData { all_loans,\n                        loans: loan_dfcx,\n                        move_data: flowed_moves } =\n-        build_borrowck_dataflow_data(this, fk, decl, &cfg, body, sp, id);\n+        build_borrowck_dataflow_data(this, &cfg, body, id);\n \n     move_data::fragments::instrument_move_fragments(&flowed_moves.move_data,\n                                                     this.tcx,\n@@ -194,31 +194,31 @@ fn borrowck_fn<'a, 'tcx>(this: &mut BorrowckCtxt<'a, 'tcx>,\n                              &flowed_moves,\n                              &all_loans[..],\n                              id,\n-                             decl,\n                              body);\n \n     intravisit::walk_fn(this, fk, decl, body_id, sp, id);\n }\n \n fn build_borrowck_dataflow_data<'a, 'tcx>(this: &mut BorrowckCtxt<'a, 'tcx>,\n-                                          fk: FnKind<'tcx>,\n-                                          decl: &'tcx hir::FnDecl,\n                                           cfg: &cfg::CFG,\n                                           body: &'tcx hir::Body,\n-                                          sp: Span,\n                                           id: ast::NodeId)\n                                           -> AnalysisData<'a, 'tcx>\n {\n     // Check the body of fn items.\n     let tcx = this.tcx;\n-    let id_range = intravisit::compute_id_range_for_fn_body(fk, decl, body.id(), sp, id, &tcx.map);\n+    let id_range = {\n+        let mut visitor = intravisit::IdRangeComputingVisitor::new(&tcx.map);\n+        visitor.visit_body(body);\n+        visitor.result()\n+    };\n     let (all_loans, move_data) =\n-        gather_loans::gather_loans_in_fn(this, id, decl, body);\n+        gather_loans::gather_loans_in_fn(this, id, body);\n \n     let mut loan_dfcx =\n         DataFlowContext::new(this.tcx,\n                              \"borrowck\",\n-                             Some(decl),\n+                             Some(body),\n                              cfg,\n                              LoanDataFlowOperator,\n                              id_range,\n@@ -235,7 +235,6 @@ fn build_borrowck_dataflow_data<'a, 'tcx>(this: &mut BorrowckCtxt<'a, 'tcx>,\n                                                       this.tcx,\n                                                       cfg,\n                                                       id_range,\n-                                                      decl,\n                                                       body);\n \n     AnalysisData { all_loans: all_loans,\n@@ -266,11 +265,8 @@ pub fn build_borrowck_dataflow_data_for_fn<'a, 'tcx>(\n     let body = tcx.map.body(fn_parts.body);\n \n     let dataflow_data = build_borrowck_dataflow_data(&mut bccx,\n-                                                     fn_parts.kind,\n-                                                     &fn_parts.decl,\n                                                      cfg,\n                                                      body,\n-                                                     fn_parts.span,\n                                                      fn_parts.id);\n \n     (bccx, dataflow_data)\n@@ -1121,22 +1117,21 @@ impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {\n                 if let Categorization::Deref(ref inner_cmt, ..) = err.cmt.cat {\n                     if let Categorization::Local(local_id) = inner_cmt.cat {\n                         let parent = self.tcx.map.get_parent_node(local_id);\n-                        let opt_fn_decl = FnLikeNode::from_node(self.tcx.map.get(parent))\n-                            .map(|fn_like| fn_like.decl());\n \n-                        if let Some(fn_decl) = opt_fn_decl {\n-                            if let Some(ref arg) = fn_decl.inputs.iter()\n-                                .find(|ref arg| arg.pat.id == local_id) {\n+                        if let Some(fn_like) = FnLikeNode::from_node(self.tcx.map.get(parent)) {\n+                            if let Some(i) = self.tcx.map.body(fn_like.body()).arguments.iter()\n+                                                     .position(|arg| arg.pat.id == local_id) {\n+                                let arg_ty = &fn_like.decl().inputs[i];\n                                 if let hir::TyRptr(\n                                     opt_lifetime,\n                                     hir::MutTy{mutbl: hir::Mutability::MutImmutable, ref ty}) =\n-                                    arg.ty.node {\n+                                    arg_ty.node {\n                                     if let Some(lifetime) = opt_lifetime {\n                                         if let Ok(snippet) = self.tcx.sess.codemap()\n                                             .span_to_snippet(ty.span) {\n                                             if let Ok(lifetime_snippet) = self.tcx.sess.codemap()\n                                                 .span_to_snippet(lifetime.span) {\n-                                                    db.span_label(arg.ty.span,\n+                                                    db.span_label(arg_ty.span,\n                                                                   &format!(\"use `&{} mut {}` \\\n                                                                             here to make mutable\",\n                                                                             lifetime_snippet,\n@@ -1145,9 +1140,9 @@ impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {\n                                         }\n                                     }\n                                     else if let Ok(snippet) = self.tcx.sess.codemap()\n-                                        .span_to_snippet(arg.ty.span) {\n+                                        .span_to_snippet(arg_ty.span) {\n                                         if snippet.starts_with(\"&\") {\n-                                            db.span_label(arg.ty.span,\n+                                            db.span_label(arg_ty.span,\n                                                           &format!(\"use `{}` here to make mutable\",\n                                                                    snippet.replace(\"&\", \"&mut \")));\n                                         }"}, {"sha": "a02aba7208c7fe4be3c6975eb1ac8d24a266e4d6", "filename": "src/librustc_borrowck/borrowck/move_data.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/f89856be6ccd1f63ef72d343587cd5d7932cfe8b/src%2Flibrustc_borrowck%2Fborrowck%2Fmove_data.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f89856be6ccd1f63ef72d343587cd5d7932cfe8b/src%2Flibrustc_borrowck%2Fborrowck%2Fmove_data.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fmove_data.rs?ref=f89856be6ccd1f63ef72d343587cd5d7932cfe8b", "patch": "@@ -655,21 +655,20 @@ impl<'a, 'tcx> FlowedMoveData<'a, 'tcx> {\n                tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                cfg: &cfg::CFG,\n                id_range: IdRange,\n-               decl: &hir::FnDecl,\n                body: &hir::Body)\n                -> FlowedMoveData<'a, 'tcx> {\n         let mut dfcx_moves =\n             DataFlowContext::new(tcx,\n                                  \"flowed_move_data_moves\",\n-                                 Some(decl),\n+                                 Some(body),\n                                  cfg,\n                                  MoveDataFlowOperator,\n                                  id_range,\n                                  move_data.moves.borrow().len());\n         let mut dfcx_assign =\n             DataFlowContext::new(tcx,\n                                  \"flowed_move_data_assigns\",\n-                                 Some(decl),\n+                                 Some(body),\n                                  cfg,\n                                  AssignDataFlowOperator,\n                                  id_range,"}, {"sha": "4c1fb90e54c7b0c4171adf0b17fcf94b37fe1084", "filename": "src/librustc_const_eval/check_match.rs", "status": "modified", "additions": 9, "deletions": 32, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/f89856be6ccd1f63ef72d343587cd5d7932cfe8b/src%2Flibrustc_const_eval%2Fcheck_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f89856be6ccd1f63ef72d343587cd5d7932cfe8b/src%2Flibrustc_const_eval%2Fcheck_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_const_eval%2Fcheck_match.rs?ref=f89856be6ccd1f63ef72d343587cd5d7932cfe8b", "patch": "@@ -43,39 +43,17 @@ struct OuterVisitor<'a, 'tcx: 'a> { tcx: TyCtxt<'a, 'tcx, 'tcx> }\n \n impl<'a, 'tcx> Visitor<'tcx> for OuterVisitor<'a, 'tcx> {\n     fn nested_visit_map<'this>(&'this mut self) -> NestedVisitorMap<'this, 'tcx> {\n-        NestedVisitorMap::None\n-    }\n-\n-    fn visit_expr(&mut self, _expr: &'tcx hir::Expr) {\n-        return // const, static and N in [T; N] - shouldn't contain anything\n-    }\n-\n-    fn visit_trait_item(&mut self, item: &'tcx hir::TraitItem) {\n-        if let hir::TraitItemKind::Const(..) = item.node {\n-            return // nothing worth match checking in a constant\n-        } else {\n-            intravisit::walk_trait_item(self, item);\n-        }\n-    }\n-\n-    fn visit_impl_item(&mut self, item: &'tcx hir::ImplItem) {\n-        if let hir::ImplItemKind::Const(..) = item.node {\n-            return // nothing worth match checking in a constant\n-        } else {\n-            intravisit::walk_impl_item(self, item);\n-        }\n+        NestedVisitorMap::OnlyBodies(&self.tcx.map)\n     }\n \n     fn visit_fn(&mut self, fk: FnKind<'tcx>, fd: &'tcx hir::FnDecl,\n                 b: hir::BodyId, s: Span, id: ast::NodeId) {\n-        if let FnKind::Closure(..) = fk {\n-            span_bug!(s, \"check_match: closure outside of function\")\n-        }\n+        intravisit::walk_fn(self, fk, fd, b, s, id);\n \n         MatchVisitor {\n             tcx: self.tcx,\n             param_env: &ty::ParameterEnvironment::for_item(self.tcx, id)\n-        }.visit_fn(fk, fd, b, s, id);\n+        }.visit_body(self.tcx.map.body(b));\n     }\n }\n \n@@ -96,7 +74,7 @@ struct MatchVisitor<'a, 'tcx: 'a> {\n \n impl<'a, 'tcx> Visitor<'tcx> for MatchVisitor<'a, 'tcx> {\n     fn nested_visit_map<'this>(&'this mut self) -> NestedVisitorMap<'this, 'tcx> {\n-        NestedVisitorMap::OnlyBodies(&self.tcx.map)\n+        NestedVisitorMap::None\n     }\n \n     fn visit_expr(&mut self, ex: &'tcx hir::Expr) {\n@@ -119,13 +97,12 @@ impl<'a, 'tcx> Visitor<'tcx> for MatchVisitor<'a, 'tcx> {\n         self.check_patterns(false, slice::ref_slice(&loc.pat));\n     }\n \n-    fn visit_fn(&mut self, fk: FnKind<'tcx>, fd: &'tcx hir::FnDecl,\n-                b: hir::BodyId, s: Span, n: ast::NodeId) {\n-        intravisit::walk_fn(self, fk, fd, b, s, n);\n+    fn visit_body(&mut self, body: &'tcx hir::Body) {\n+        intravisit::walk_body(self, body);\n \n-        for input in &fd.inputs {\n-            self.check_irrefutable(&input.pat, true);\n-            self.check_patterns(false, slice::ref_slice(&input.pat));\n+        for arg in &body.arguments {\n+            self.check_irrefutable(&arg.pat, true);\n+            self.check_patterns(false, slice::ref_slice(&arg.pat));\n         }\n     }\n }"}, {"sha": "e27a047663578ab015aeca93c3f244f59291a133", "filename": "src/librustc_const_eval/eval.rs", "status": "modified", "additions": 9, "deletions": 11, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/f89856be6ccd1f63ef72d343587cd5d7932cfe8b/src%2Flibrustc_const_eval%2Feval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f89856be6ccd1f63ef72d343587cd5d7932cfe8b/src%2Flibrustc_const_eval%2Feval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_const_eval%2Feval.rs?ref=f89856be6ccd1f63ef72d343587cd5d7932cfe8b", "patch": "@@ -870,18 +870,16 @@ pub fn eval_const_expr_partial<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n               Struct(_) => signal!(e, UnimplementedConstVal(\"tuple struct constructors\")),\n               callee => signal!(e, CallOn(callee)),\n           };\n-          let (arg_defs, body) = match lookup_const_fn_by_id(tcx, did) {\n-              Some(ConstFnNode::Inlined(ii)) => (ii.const_fn_args.clone(), &ii.body),\n-              Some(ConstFnNode::Local(fn_like)) =>\n-                  (fn_like.decl().inputs.iter()\n-                   .map(|arg| match arg.pat.node {\n-                       hir::PatKind::Binding(_, def_id, _, _) => Some(def_id),\n-                       _ => None\n-                   }).collect(),\n-                   tcx.map.body(fn_like.body())),\n+          let body = match lookup_const_fn_by_id(tcx, did) {\n+              Some(ConstFnNode::Inlined(ii)) => &ii.body,\n+              Some(ConstFnNode::Local(fn_like)) => tcx.map.body(fn_like.body()),\n               None => signal!(e, NonConstPath),\n           };\n-          let result = &body.value;\n+\n+          let arg_defs = body.arguments.iter().map(|arg| match arg.pat.node {\n+               hir::PatKind::Binding(_, def_id, _, _) => Some(def_id),\n+               _ => None\n+           }).collect::<Vec<_>>();\n           assert_eq!(arg_defs.len(), args.len());\n \n           let mut call_args = DefIdMap();\n@@ -899,7 +897,7 @@ pub fn eval_const_expr_partial<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n               }\n           }\n           debug!(\"const call({:?})\", call_args);\n-          eval_const_expr_partial(tcx, result, ty_hint, Some(&call_args))?\n+          eval_const_expr_partial(tcx, &body.value, ty_hint, Some(&call_args))?\n       },\n       hir::ExprLit(ref lit) => match lit_to_const(&lit.node, tcx, ety) {\n           Ok(val) => val,"}, {"sha": "4bb12667bbc147f861ed2583909c9758c89fcef0", "filename": "src/librustc_incremental/calculate_svh/svh_visitor.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f89856be6ccd1f63ef72d343587cd5d7932cfe8b/src%2Flibrustc_incremental%2Fcalculate_svh%2Fsvh_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f89856be6ccd1f63ef72d343587cd5d7932cfe8b/src%2Flibrustc_incremental%2Fcalculate_svh%2Fsvh_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fcalculate_svh%2Fsvh_visitor.rs?ref=f89856be6ccd1f63ef72d343587cd5d7932cfe8b", "patch": "@@ -476,8 +476,10 @@ enum SawTraitOrImplItemComponent {\n fn saw_trait_item(ti: &TraitItemKind) -> SawTraitOrImplItemComponent {\n     match *ti {\n         TraitItemKind::Const(..) => SawTraitOrImplItemConst,\n-        TraitItemKind::Method(ref sig, ref body) =>\n-            SawTraitOrImplItemMethod(sig.unsafety, sig.constness, sig.abi, body.is_some()),\n+        TraitItemKind::Method(ref sig, TraitMethod::Required(_)) =>\n+            SawTraitOrImplItemMethod(sig.unsafety, sig.constness, sig.abi, false),\n+        TraitItemKind::Method(ref sig, TraitMethod::Provided(_)) =>\n+            SawTraitOrImplItemMethod(sig.unsafety, sig.constness, sig.abi, true),\n         TraitItemKind::Type(..) => SawTraitOrImplItemType\n     }\n }"}, {"sha": "2baef47c214c28ae54b17906a0be338afc8e2253", "filename": "src/librustc_lint/bad_style.rs", "status": "modified", "additions": 7, "deletions": 12, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/f89856be6ccd1f63ef72d343587cd5d7932cfe8b/src%2Flibrustc_lint%2Fbad_style.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f89856be6ccd1f63ef72d343587cd5d7932cfe8b/src%2Flibrustc_lint%2Fbad_style.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Fbad_style.rs?ref=f89856be6ccd1f63ef72d343587cd5d7932cfe8b", "patch": "@@ -271,12 +271,15 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for NonSnakeCase {\n         }\n     }\n \n-    fn check_trait_item(&mut self, cx: &LateContext, trait_item: &hir::TraitItem) {\n-        if let hir::TraitItemKind::Method(_, None) = trait_item.node {\n+    fn check_trait_item(&mut self, cx: &LateContext, item: &hir::TraitItem) {\n+        if let hir::TraitItemKind::Method(_, hir::TraitMethod::Required(ref names)) = item.node {\n             self.check_snake_case(cx,\n                                   \"trait method\",\n-                                  &trait_item.name.as_str(),\n-                                  Some(trait_item.span));\n+                                  &item.name.as_str(),\n+                                  Some(item.span));\n+            for name in names {\n+                self.check_snake_case(cx, \"variable\", &name.node.as_str(), Some(name.span));\n+            }\n         }\n     }\n \n@@ -288,14 +291,6 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for NonSnakeCase {\n     }\n \n     fn check_pat(&mut self, cx: &LateContext, p: &hir::Pat) {\n-        // Exclude parameter names from foreign functions\n-        let parent_node = cx.tcx.map.get_parent_node(p.id);\n-        if let hir::map::NodeForeignItem(item) = cx.tcx.map.get(parent_node) {\n-            if let hir::ForeignItemFn(..) = item.node {\n-                return;\n-            }\n-        }\n-\n         if let &PatKind::Binding(_, _, ref path1, _) = &p.node {\n             self.check_snake_case(cx, \"variable\", &path1.node.as_str(), Some(p.span));\n         }"}, {"sha": "c021ffee81899002c9c6a4273fdec2c97df20d34", "filename": "src/librustc_lint/builtin.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f89856be6ccd1f63ef72d343587cd5d7932cfe8b/src%2Flibrustc_lint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f89856be6ccd1f63ef72d343587cd5d7932cfe8b/src%2Flibrustc_lint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Fbuiltin.rs?ref=f89856be6ccd1f63ef72d343587cd5d7932cfe8b", "patch": "@@ -240,11 +240,11 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for UnsafeCode {\n         }\n     }\n \n-    fn check_trait_item(&mut self, cx: &LateContext, trait_item: &hir::TraitItem) {\n-        if let hir::TraitItemKind::Method(ref sig, None) = trait_item.node {\n+    fn check_trait_item(&mut self, cx: &LateContext, item: &hir::TraitItem) {\n+        if let hir::TraitItemKind::Method(ref sig, hir::TraitMethod::Required(_)) = item.node {\n             if sig.unsafety == hir::Unsafety::Unsafe {\n                 cx.span_lint(UNSAFE_CODE,\n-                             trait_item.span,\n+                             item.span,\n                              \"declaration of an `unsafe` method\")\n             }\n         }"}, {"sha": "a3aa4af493aaf72bb1ffa2fc613980f2490f5d70", "filename": "src/librustc_lint/types.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f89856be6ccd1f63ef72d343587cd5d7932cfe8b/src%2Flibrustc_lint%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f89856be6ccd1f63ef72d343587cd5d7932cfe8b/src%2Flibrustc_lint%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Ftypes.rs?ref=f89856be6ccd1f63ef72d343587cd5d7932cfe8b", "patch": "@@ -679,7 +679,7 @@ impl<'a, 'tcx> ImproperCTypesVisitor<'a, 'tcx> {\n         let sig = self.cx.tcx.erase_late_bound_regions(&sig);\n \n         for (input_ty, input_hir) in sig.inputs().iter().zip(&decl.inputs) {\n-            self.check_type_for_ffi_and_report_errors(input_hir.ty.span, input_ty);\n+            self.check_type_for_ffi_and_report_errors(input_hir.span, input_ty);\n         }\n \n         if let hir::Return(ref ret_hir) = decl.output {\n@@ -713,7 +713,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for ImproperCTypes {\n             if nmod.abi != Abi::RustIntrinsic && nmod.abi != Abi::PlatformIntrinsic {\n                 for ni in &nmod.items {\n                     match ni.node {\n-                        hir::ForeignItemFn(ref decl, _) => {\n+                        hir::ForeignItemFn(ref decl, _, _) => {\n                             vis.check_foreign_fn(ni.id, decl);\n                         }\n                         hir::ForeignItemStatic(ref ty, _) => {"}, {"sha": "b7ee688117d93a07149632464d4eafcb6d1d2e9d", "filename": "src/librustc_lint/unused.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f89856be6ccd1f63ef72d343587cd5d7932cfe8b/src%2Flibrustc_lint%2Funused.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f89856be6ccd1f63ef72d343587cd5d7932cfe8b/src%2Flibrustc_lint%2Funused.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Funused.rs?ref=f89856be6ccd1f63ef72d343587cd5d7932cfe8b", "patch": "@@ -97,11 +97,11 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for UnusedMut {\n     fn check_fn(&mut self,\n                 cx: &LateContext,\n                 _: FnKind,\n-                decl: &hir::FnDecl,\n-                _: &hir::Body,\n+                _: &hir::FnDecl,\n+                body: &hir::Body,\n                 _: Span,\n                 _: ast::NodeId) {\n-        for a in &decl.inputs {\n+        for a in &body.arguments {\n             self.check_unused_mut_pat(cx, slice::ref_slice(&a.pat));\n         }\n     }"}, {"sha": "6a626e9942cb6b3e92cc97077e7cc5d5fc668072", "filename": "src/librustc_metadata/cstore_impl.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f89856be6ccd1f63ef72d343587cd5d7932cfe8b/src%2Flibrustc_metadata%2Fcstore_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f89856be6ccd1f63ef72d343587cd5d7932cfe8b/src%2Flibrustc_metadata%2Fcstore_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fcstore_impl.rs?ref=f89856be6ccd1f63ef72d343587cd5d7932cfe8b", "patch": "@@ -128,7 +128,11 @@ impl<'tcx> CrateStore<'tcx> for cstore::CStore {\n \n     fn fn_arg_names(&self, did: DefId) -> Vec<ast::Name>\n     {\n-        self.dep_graph.read(DepNode::MetaData(did));\n+        // FIXME(#38501) We've skipped a `read` on the `HirBody` of\n+        // a `fn` when encoding, so the dep-tracking wouldn't work.\n+        // This is only used by rustdoc anyway, which shouldn't have\n+        // incremental recompilation ever enabled.\n+        assert!(!self.dep_graph.is_fully_enabled());\n         self.get_crate_data(did.krate).get_fn_arg_names(did.index)\n     }\n "}, {"sha": "732887620cfaffc1411ff80b4a8a112e82d64313", "filename": "src/librustc_metadata/encoder.rs", "status": "modified", "additions": 30, "deletions": 14, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/f89856be6ccd1f63ef72d343587cd5d7932cfe8b/src%2Flibrustc_metadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f89856be6ccd1f63ef72d343587cd5d7932cfe8b/src%2Flibrustc_metadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fencoder.rs?ref=f89856be6ccd1f63ef72d343587cd5d7932cfe8b", "patch": "@@ -34,6 +34,7 @@ use std::io::Cursor;\n use std::rc::Rc;\n use std::u32;\n use syntax::ast::{self, CRATE_NODE_ID};\n+use syntax::codemap::Spanned;\n use syntax::attr;\n use syntax::symbol::Symbol;\n use syntax_pos;\n@@ -442,10 +443,18 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n         let kind = match trait_item.kind {\n             ty::AssociatedKind::Const => EntryKind::AssociatedConst(container),\n             ty::AssociatedKind::Method => {\n-                let fn_data = if let hir::TraitItemKind::Method(ref sig, _) = ast_item.node {\n+                let fn_data = if let hir::TraitItemKind::Method(_, ref m) = ast_item.node {\n+                    let arg_names = match *m {\n+                        hir::TraitMethod::Required(ref names) => {\n+                            self.encode_fn_arg_names(names)\n+                        }\n+                        hir::TraitMethod::Provided(body) => {\n+                            self.encode_fn_arg_names_for_body(body)\n+                        }\n+                    };\n                     FnData {\n                         constness: hir::Constness::NotConst,\n-                        arg_names: self.encode_fn_arg_names(&sig.decl),\n+                        arg_names: arg_names\n                     }\n                 } else {\n                     bug!()\n@@ -518,10 +527,10 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n         let kind = match impl_item.kind {\n             ty::AssociatedKind::Const => EntryKind::AssociatedConst(container),\n             ty::AssociatedKind::Method => {\n-                let fn_data = if let hir::ImplItemKind::Method(ref sig, _) = ast_item.node {\n+                let fn_data = if let hir::ImplItemKind::Method(ref sig, body) = ast_item.node {\n                     FnData {\n                         constness: sig.constness,\n-                        arg_names: self.encode_fn_arg_names(&sig.decl),\n+                        arg_names: self.encode_fn_arg_names_for_body(body),\n                     }\n                 } else {\n                     bug!()\n@@ -574,16 +583,23 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n         }\n     }\n \n-    fn encode_fn_arg_names(&mut self, decl: &hir::FnDecl) -> LazySeq<ast::Name> {\n-        self.lazy_seq(decl.inputs.iter().map(|arg| {\n-            if let PatKind::Binding(_, _, ref path1, _) = arg.pat.node {\n-                path1.node\n-            } else {\n-                Symbol::intern(\"\")\n+    fn encode_fn_arg_names_for_body(&mut self, body_id: hir::BodyId)\n+                                    -> LazySeq<ast::Name> {\n+        let _ignore = self.tcx.dep_graph.in_ignore();\n+        let body = self.tcx.map.body(body_id);\n+        self.lazy_seq(body.arguments.iter().map(|arg| {\n+            match arg.pat.node {\n+                PatKind::Binding(_, _, name, _) => name.node,\n+                _ => Symbol::intern(\"\")\n             }\n         }))\n     }\n \n+    fn encode_fn_arg_names(&mut self, names: &[Spanned<ast::Name>])\n+                           -> LazySeq<ast::Name> {\n+        self.lazy_seq(names.iter().map(|name| name.node))\n+    }\n+\n     fn encode_mir(&mut self, def_id: DefId) -> Option<Lazy<mir::Mir<'tcx>>> {\n         self.tcx.mir_map.borrow().get(&def_id).map(|mir| self.lazy(&*mir.borrow()))\n     }\n@@ -619,10 +635,10 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n             hir::ItemStatic(_, hir::MutMutable, _) => EntryKind::MutStatic,\n             hir::ItemStatic(_, hir::MutImmutable, _) => EntryKind::ImmStatic,\n             hir::ItemConst(..) => EntryKind::Const,\n-            hir::ItemFn(ref decl, _, constness, ..) => {\n+            hir::ItemFn(_, _, constness, .., body) => {\n                 let data = FnData {\n                     constness: constness,\n-                    arg_names: self.encode_fn_arg_names(&decl),\n+                    arg_names: self.encode_fn_arg_names_for_body(body),\n                 };\n \n                 EntryKind::Fn(self.lazy(&data))\n@@ -915,10 +931,10 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n         debug!(\"writing foreign item {}\", tcx.node_path_str(nitem.id));\n \n         let kind = match nitem.node {\n-            hir::ForeignItemFn(ref fndecl, _) => {\n+            hir::ForeignItemFn(_, ref names, _) => {\n                 let data = FnData {\n                     constness: hir::Constness::NotConst,\n-                    arg_names: self.encode_fn_arg_names(&fndecl),\n+                    arg_names: self.encode_fn_arg_names(names),\n                 };\n                 EntryKind::ForeignFn(self.lazy(&data))\n             }"}, {"sha": "63bb1bf20c06c41bccba9d59f7e7fb6f06017c44", "filename": "src/librustc_mir/build/matches/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f89856be6ccd1f63ef72d343587cd5d7932cfe8b/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f89856be6ccd1f63ef72d343587cd5d7932cfe8b/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fmod.rs?ref=f89856be6ccd1f63ef72d343587cd5d7932cfe8b", "patch": "@@ -729,7 +729,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n             name: Some(name),\n             source_info: Some(source_info),\n         });\n-        let extent = self.extent_of_innermost_scope();\n+        let extent = self.hir.tcx().region_maps.var_scope(var_id);\n         self.schedule_drop(source_info.span, extent, &Lvalue::Local(var), var_ty);\n         self.var_indices.insert(var_id, var);\n "}, {"sha": "cfdc1bf27df35411c6f008ba6f4aff42c821980e", "filename": "src/librustc_mir/build/mod.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/f89856be6ccd1f63ef72d343587cd5d7932cfe8b/src%2Flibrustc_mir%2Fbuild%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f89856be6ccd1f63ef72d343587cd5d7932cfe8b/src%2Flibrustc_mir%2Fbuild%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmod.rs?ref=f89856be6ccd1f63ef72d343587cd5d7932cfe8b", "patch": "@@ -126,7 +126,7 @@ pub fn construct_fn<'a, 'gcx, 'tcx, A>(hir: Cx<'a, 'gcx, 'tcx>,\n                                        arguments: A,\n                                        abi: Abi,\n                                        return_ty: Ty<'gcx>,\n-                                       body_id: hir::BodyId)\n+                                       body: &'gcx hir::Body)\n                                        -> Mir<'tcx>\n     where A: Iterator<Item=(Ty<'gcx>, Option<&'gcx hir::Pat>)>\n {\n@@ -138,15 +138,14 @@ pub fn construct_fn<'a, 'gcx, 'tcx, A>(hir: Cx<'a, 'gcx, 'tcx>,\n \n     let call_site_extent =\n         tcx.region_maps.lookup_code_extent(\n-            CodeExtentData::CallSiteScope { fn_id: fn_id, body_id: body_id.node_id });\n+            CodeExtentData::CallSiteScope { fn_id: fn_id, body_id: body.value.id });\n     let arg_extent =\n         tcx.region_maps.lookup_code_extent(\n-            CodeExtentData::ParameterScope { fn_id: fn_id, body_id: body_id.node_id });\n+            CodeExtentData::ParameterScope { fn_id: fn_id, body_id: body.value.id });\n     let mut block = START_BLOCK;\n     unpack!(block = builder.in_scope(call_site_extent, block, |builder| {\n         unpack!(block = builder.in_scope(arg_extent, block, |builder| {\n-            let ast_expr = &tcx.map.body(body_id).value;\n-            builder.args_and_body(block, &arguments, arg_extent, ast_expr)\n+            builder.args_and_body(block, &arguments, arg_extent, &body.value)\n         }));\n         // Attribute epilogue to function's closing brace\n         let fn_end = Span { lo: span.hi, ..span };"}, {"sha": "59a11782e08566744d1e027849a56e60e8506ce4", "filename": "src/librustc_mir/build/scope.rs", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f89856be6ccd1f63ef72d343587cd5d7932cfe8b/src%2Flibrustc_mir%2Fbuild%2Fscope.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f89856be6ccd1f63ef72d343587cd5d7932cfe8b/src%2Flibrustc_mir%2Fbuild%2Fscope.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fscope.rs?ref=f89856be6ccd1f63ef72d343587cd5d7932cfe8b", "patch": "@@ -253,7 +253,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                             f: F)\n         where F: FnOnce(&mut Builder<'a, 'gcx, 'tcx>)\n     {\n-        let extent = self.extent_of_innermost_scope();\n+        let extent = self.scopes.last().map(|scope| scope.extent).unwrap();\n         let loop_scope = LoopScope {\n             extent: extent.clone(),\n             continue_block: loop_block,\n@@ -411,10 +411,6 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n         }\n     }\n \n-    pub fn extent_of_innermost_scope(&self) -> CodeExtent {\n-        self.scopes.last().map(|scope| scope.extent).unwrap()\n-    }\n-\n     /// Returns the extent of the scope which should be exited by a\n     /// return.\n     pub fn extent_of_return_scope(&self) -> CodeExtent {"}, {"sha": "cbc53ea3c51c747ae5e38399e6ace1c76d4ee0cf", "filename": "src/librustc_mir/mir_map.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/f89856be6ccd1f63ef72d343587cd5d7932cfe8b/src%2Flibrustc_mir%2Fmir_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f89856be6ccd1f63ef72d343587cd5d7932cfe8b/src%2Flibrustc_mir%2Fmir_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fmir_map.rs?ref=f89856be6ccd1f63ef72d343587cd5d7932cfe8b", "patch": "@@ -234,8 +234,9 @@ impl<'a, 'tcx> Visitor<'tcx> for BuildMir<'a, 'tcx> {\n             (self.tcx.item_type(def_id).fn_abi(), None)\n         };\n \n+        let body = self.tcx.map.body(body_id);\n         let explicit_arguments =\n-            decl.inputs\n+            body.arguments\n                 .iter()\n                 .enumerate()\n                 .map(|(index, arg)| {\n@@ -244,7 +245,7 @@ impl<'a, 'tcx> Visitor<'tcx> for BuildMir<'a, 'tcx> {\n \n         let arguments = implicit_argument.into_iter().chain(explicit_arguments);\n         self.cx(MirSource::Fn(id)).build(|cx| {\n-            build::construct_fn(cx, id, arguments, abi, fn_sig.output(), body_id)\n+            build::construct_fn(cx, id, arguments, abi, fn_sig.output(), body)\n         });\n \n         intravisit::walk_fn(self, fk, decl, body_id, span, id);"}, {"sha": "11f39a8fdf86fca1a444f6b5fc358ae497b7ae17", "filename": "src/librustc_passes/consts.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f89856be6ccd1f63ef72d343587cd5d7932cfe8b/src%2Flibrustc_passes%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f89856be6ccd1f63ef72d343587cd5d7932cfe8b/src%2Flibrustc_passes%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Fconsts.rs?ref=f89856be6ccd1f63ef72d343587cd5d7932cfe8b", "patch": "@@ -166,7 +166,7 @@ impl<'a, 'gcx> CheckCrateVisitor<'a, 'gcx> {\n \n         let qualif = self.with_mode(mode, |this| {\n             let body = this.tcx.map.body(b);\n-            this.with_euv(Some(fn_id), |euv| euv.walk_fn(fd, body));\n+            this.with_euv(Some(fn_id), |euv| euv.walk_fn(body));\n             intravisit::walk_fn(this, fk, fd, b, s, fn_id);\n             this.qualif\n         });"}, {"sha": "e4151a66c313cc1c1fd1c929fd741cd7b62cd7f2", "filename": "src/librustc_passes/rvalues.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f89856be6ccd1f63ef72d343587cd5d7932cfe8b/src%2Flibrustc_passes%2Frvalues.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f89856be6ccd1f63ef72d343587cd5d7932cfe8b/src%2Flibrustc_passes%2Frvalues.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Frvalues.rs?ref=f89856be6ccd1f63ef72d343587cd5d7932cfe8b", "patch": "@@ -52,7 +52,7 @@ impl<'a, 'tcx> Visitor<'tcx> for RvalueContext<'a, 'tcx> {\n             };\n             let body = infcx.tcx.map.body(b);\n             let mut euv = euv::ExprUseVisitor::new(&mut delegate, &infcx);\n-            euv.walk_fn(fd, body);\n+            euv.walk_fn(body);\n         });\n         intravisit::walk_fn(self, fk, fd, b, s, fn_id)\n     }"}, {"sha": "5c49ace4917c39da28b991652cb031773c375e57", "filename": "src/librustc_typeck/astconv.rs", "status": "modified", "additions": 27, "deletions": 29, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/f89856be6ccd1f63ef72d343587cd5d7932cfe8b/src%2Flibrustc_typeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f89856be6ccd1f63ef72d343587cd5d7932cfe8b/src%2Flibrustc_typeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fastconv.rs?ref=f89856be6ccd1f63ef72d343587cd5d7932cfe8b", "patch": "@@ -227,6 +227,7 @@ pub fn ast_region_to_region<'a, 'gcx, 'tcx>(tcx: TyCtxt<'a, 'gcx, 'tcx>,\n }\n \n fn report_elision_failure(\n+    tcx: TyCtxt,\n     db: &mut DiagnosticBuilder,\n     params: Vec<ElisionFailureInfo>)\n {\n@@ -241,13 +242,14 @@ fn report_elision_failure(\n \n     for (i, info) in elided_params.into_iter().enumerate() {\n         let ElisionFailureInfo {\n-            name, lifetime_count: n, have_bound_regions\n+            parent, index, lifetime_count: n, have_bound_regions\n         } = info;\n \n-        let help_name = if name.is_empty() {\n-            format!(\"argument {}\", i + 1)\n+        let help_name = if let Some(body) = parent {\n+            let arg = &tcx.map.body(body).arguments[index];\n+            format!(\"`{}`\", pprust::pat_to_string(&arg.pat))\n         } else {\n-            format!(\"`{}`\", name)\n+            format!(\"argument {}\", index + 1)\n         };\n \n         m.push_str(&(if n == 1 {\n@@ -315,7 +317,7 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n                     err.span_label(ampersand_span, &format!(\"expected lifetime parameter\"));\n \n                     if let Some(params) = params {\n-                        report_elision_failure(&mut err, params);\n+                        report_elision_failure(self.tcx(), &mut err, params);\n                     }\n                     err.emit();\n                     ty::ReStatic\n@@ -540,15 +542,16 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n     /// corresponding to each input type/pattern.\n     fn find_implied_output_region<I>(&self,\n                                      input_tys: &[Ty<'tcx>],\n-                                     input_pats: I) -> ElidedLifetime\n-        where I: Iterator<Item=String>\n+                                     parent: Option<hir::BodyId>,\n+                                     input_indices: I) -> ElidedLifetime\n+        where I: Iterator<Item=usize>\n     {\n         let tcx = self.tcx();\n         let mut lifetimes_for_params = Vec::with_capacity(input_tys.len());\n         let mut possible_implied_output_region = None;\n         let mut lifetimes = 0;\n \n-        for input_type in input_tys.iter() {\n+        for (input_type, index) in input_tys.iter().zip(input_indices) {\n             let mut regions = FxHashSet();\n             let have_bound_regions = tcx.collect_regions(input_type, &mut regions);\n \n@@ -564,11 +567,9 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n                 possible_implied_output_region = regions.iter().cloned().next();\n             }\n \n-            // Use a placeholder for `name` because computing it can be\n-            // expensive and we don't want to do it until we know it's\n-            // necessary.\n             lifetimes_for_params.push(ElisionFailureInfo {\n-                name: String::new(),\n+                parent: parent,\n+                index: index,\n                 lifetime_count: regions.len(),\n                 have_bound_regions: have_bound_regions\n             });\n@@ -577,11 +578,6 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n         if lifetimes == 1 {\n             Ok(*possible_implied_output_region.unwrap())\n         } else {\n-            // Fill in the expensive `name` fields now that we know they're\n-            // needed.\n-            for (info, input_pat) in lifetimes_for_params.iter_mut().zip(input_pats) {\n-                info.name = input_pat;\n-            }\n             Err(Some(lifetimes_for_params))\n         }\n     }\n@@ -618,8 +614,8 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n         let inputs = self.tcx().mk_type_list(data.inputs.iter().map(|a_t| {\n             self.ast_ty_arg_to_ty(&binding_rscope, None, region_substs, a_t)\n         }));\n-        let input_params = iter::repeat(String::new()).take(inputs.len());\n-        let implied_output_region = self.find_implied_output_region(&inputs, input_params);\n+        let input_params = 0..inputs.len();\n+        let implied_output_region = self.find_implied_output_region(&inputs, None, input_params);\n \n         let (output, output_span) = match data.output {\n             Some(ref output_ty) => {\n@@ -1572,6 +1568,7 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n                                                               bf.abi,\n                                                               None,\n                                                               &bf.decl,\n+                                                              None,\n                                                               anon_scope,\n                                                               anon_scope);\n \n@@ -1696,26 +1693,28 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n \n     pub fn ty_of_arg(&self,\n                      rscope: &RegionScope,\n-                     a: &hir::Arg,\n+                     ty: &hir::Ty,\n                      expected_ty: Option<Ty<'tcx>>)\n                      -> Ty<'tcx>\n     {\n-        match a.ty.node {\n+        match ty.node {\n             hir::TyInfer if expected_ty.is_some() => expected_ty.unwrap(),\n-            hir::TyInfer => self.ty_infer(a.ty.span),\n-            _ => self.ast_ty_to_ty(rscope, &a.ty),\n+            hir::TyInfer => self.ty_infer(ty.span),\n+            _ => self.ast_ty_to_ty(rscope, ty),\n         }\n     }\n \n     pub fn ty_of_method(&self,\n                         sig: &hir::MethodSig,\n                         opt_self_value_ty: Option<Ty<'tcx>>,\n+                        body: Option<hir::BodyId>,\n                         anon_scope: Option<AnonTypeScope>)\n                         -> &'tcx ty::BareFnTy<'tcx> {\n         self.ty_of_method_or_bare_fn(sig.unsafety,\n                                      sig.abi,\n                                      opt_self_value_ty,\n                                      &sig.decl,\n+                                     body,\n                                      None,\n                                      anon_scope)\n     }\n@@ -1724,16 +1723,18 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n                          unsafety: hir::Unsafety,\n                          abi: abi::Abi,\n                          decl: &hir::FnDecl,\n+                         body: hir::BodyId,\n                          anon_scope: Option<AnonTypeScope>)\n                          -> &'tcx ty::BareFnTy<'tcx> {\n-        self.ty_of_method_or_bare_fn(unsafety, abi, None, decl, None, anon_scope)\n+        self.ty_of_method_or_bare_fn(unsafety, abi, None, decl, Some(body), None, anon_scope)\n     }\n \n     fn ty_of_method_or_bare_fn(&self,\n                                unsafety: hir::Unsafety,\n                                abi: abi::Abi,\n                                opt_self_value_ty: Option<Ty<'tcx>>,\n                                decl: &hir::FnDecl,\n+                               body: Option<hir::BodyId>,\n                                arg_anon_scope: Option<AnonTypeScope>,\n                                ret_anon_scope: Option<AnonTypeScope>)\n                                -> &'tcx ty::BareFnTy<'tcx>\n@@ -1764,12 +1765,9 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n             // reference) in the arguments, then any anonymous regions in the output\n             // have that lifetime.\n             _ => {\n-                let arg_params = &decl.inputs[has_self as usize..];\n                 let arg_tys = &input_tys[has_self as usize..];\n-\n-                self.find_implied_output_region(arg_tys,\n-                                                arg_params.iter()\n-                                                    .map(|a| pprust::pat_to_string(&a.pat)))\n+                let arg_params = has_self as usize..input_tys.len();\n+                self.find_implied_output_region(arg_tys, body, arg_params)\n \n             }\n         };"}, {"sha": "be10b77bd8b90c33ea0e5ea6c13c28945329a26e", "filename": "src/librustc_typeck/check/compare_method.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/f89856be6ccd1f63ef72d343587cd5d7932cfe8b/src%2Flibrustc_typeck%2Fcheck%2Fcompare_method.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f89856be6ccd1f63ef72d343587cd5d7932cfe8b/src%2Flibrustc_typeck%2Fcheck%2Fcompare_method.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcompare_method.rs?ref=f89856be6ccd1f63ef72d343587cd5d7932cfe8b", "patch": "@@ -456,15 +456,15 @@ fn extract_spans_for_error_reporting<'a, 'gcx, 'tcx>(infcx: &infer::InferCtxt<'a\n                 };\n \n                 impl_m_iter.zip(trait_m_iter).find(|&(ref impl_arg, ref trait_arg)| {\n-                    match (&impl_arg.ty.node, &trait_arg.ty.node) {\n+                    match (&impl_arg.node, &trait_arg.node) {\n                         (&hir::TyRptr(_, ref impl_mt), &hir::TyRptr(_, ref trait_mt)) |\n                         (&hir::TyPtr(ref impl_mt), &hir::TyPtr(ref trait_mt)) => {\n                             impl_mt.mutbl != trait_mt.mutbl\n                         }\n                         _ => false,\n                     }\n                 }).map(|(ref impl_arg, ref trait_arg)| {\n-                    (impl_arg.ty.span, Some(trait_arg.ty.span))\n+                    (impl_arg.span, Some(trait_arg.span))\n                 })\n                 .unwrap_or_else(|| (cause.span, tcx.map.span_if_local(trait_m.def_id)))\n             } else {\n@@ -489,7 +489,7 @@ fn extract_spans_for_error_reporting<'a, 'gcx, 'tcx>(infcx: &infer::InferCtxt<'a\n                          .filter_map(|(((impl_arg_ty, trait_arg_ty), impl_arg), trait_arg)| {\n                              match infcx.sub_types(true, &cause, trait_arg_ty, impl_arg_ty) {\n                                  Ok(_) => None,\n-                                 Err(_) => Some((impl_arg.ty.span, Some(trait_arg.ty.span))),\n+                                 Err(_) => Some((impl_arg.span, Some(trait_arg.span))),\n                              }\n                          })\n                          .next()\n@@ -680,7 +680,7 @@ fn compare_number_of_method_arguments<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n                     } else {\n                         0\n                     }) {\n-                        Some(arg.pat.span)\n+                        Some(arg.span)\n                     } else {\n                         trait_item_span\n                     }\n@@ -698,7 +698,7 @@ fn compare_number_of_method_arguments<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n                 } else {\n                     0\n                 }) {\n-                    arg.pat.span\n+                    arg.span\n                 } else {\n                     impl_m_span\n                 }"}, {"sha": "c733c0856c6da2d12ad75e949413eef0ff1bfa8a", "filename": "src/librustc_typeck/check/intrinsic.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f89856be6ccd1f63ef72d343587cd5d7932cfe8b/src%2Flibrustc_typeck%2Fcheck%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f89856be6ccd1f63ef72d343587cd5d7932cfe8b/src%2Flibrustc_typeck%2Fcheck%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fintrinsic.rs?ref=f89856be6ccd1f63ef72d343587cd5d7932cfe8b", "patch": "@@ -48,7 +48,7 @@ fn equate_intrinsic_type<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n     let i_n_tps = tcx.item_generics(def_id).types.len();\n     if i_n_tps != n_tps {\n         let span = match it.node {\n-            hir::ForeignItemFn(_, ref generics) => generics.span,\n+            hir::ForeignItemFn(_, _, ref generics) => generics.span,\n             hir::ForeignItemStatic(..) => it.span\n         };\n "}, {"sha": "e919075bc8f35dd9a8916188009cf6437603b8da", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 19, "deletions": 39, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/f89856be6ccd1f63ef72d343587cd5d7932cfe8b/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f89856be6ccd1f63ef72d343587cd5d7932cfe8b/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=f89856be6ccd1f63ef72d343587cd5d7932cfe8b", "patch": "@@ -681,8 +681,8 @@ fn check_bare_fn<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n         fcx.check_casts();\n         fcx.select_all_obligations_or_error(); // Casts can introduce new obligations.\n \n-        fcx.regionck_fn(fn_id, decl, body);\n-        fcx.resolve_type_vars_in_fn(decl, body, fn_id);\n+        fcx.regionck_fn(fn_id, body);\n+        fcx.resolve_type_vars_in_body(body, fn_id);\n     });\n }\n \n@@ -751,16 +751,6 @@ impl<'a, 'gcx, 'tcx> Visitor<'gcx> for GatherLocalsVisitor<'a, 'gcx, 'tcx> {\n         intravisit::walk_pat(self, p);\n     }\n \n-    fn visit_ty(&mut self, t: &'gcx hir::Ty) {\n-        match t.node {\n-            hir::TyBareFn(ref function_declaration) => {\n-                intravisit::walk_fn_decl_nopat(self, &function_declaration.decl);\n-                walk_list!(self, visit_lifetime_def, &function_declaration.lifetimes);\n-            }\n-            _ => intravisit::walk_ty(self, t)\n-        }\n-    }\n-\n     // Don't descend into the bodies of nested closures\n     fn visit_fn(&mut self, _: intravisit::FnKind<'gcx>, _: &'gcx hir::FnDecl,\n                 _: hir::BodyId, _: Span, _: ast::NodeId) { }\n@@ -796,31 +786,21 @@ fn check_fn<'a, 'gcx, 'tcx>(inherited: &'a Inherited<'a, 'gcx, 'tcx>,\n     fn_sig = fcx.tcx.mk_fn_sig(fn_sig.inputs().iter().cloned(), &fcx.ret_ty.unwrap(),\n                                fn_sig.variadic);\n \n-    {\n-        let mut visit = GatherLocalsVisitor { fcx: &fcx, };\n-\n-        // Add formal parameters.\n-        for (arg_ty, input) in fn_sig.inputs().iter().zip(&decl.inputs) {\n-            // The type of the argument must be well-formed.\n-            //\n-            // NB -- this is now checked in wfcheck, but that\n-            // currently only results in warnings, so we issue an\n-            // old-style WF obligation here so that we still get the\n-            // errors that we used to get.\n-            fcx.register_old_wf_obligation(arg_ty, input.ty.span, traits::MiscObligation);\n-\n-            // Create type variables for each argument.\n-            input.pat.each_binding(|_bm, pat_id, sp, _path| {\n-                let var_ty = visit.assign(sp, pat_id, None);\n-                fcx.require_type_is_sized(var_ty, sp, traits::VariableType(pat_id));\n-            });\n+    GatherLocalsVisitor { fcx: &fcx, }.visit_body(body);\n \n-            // Check the pattern.\n-            fcx.check_pat(&input.pat, arg_ty);\n-            fcx.write_ty(input.id, arg_ty);\n-        }\n+    // Add formal parameters.\n+    for (arg_ty, arg) in fn_sig.inputs().iter().zip(&body.arguments) {\n+        // The type of the argument must be well-formed.\n+        //\n+        // NB -- this is now checked in wfcheck, but that\n+        // currently only results in warnings, so we issue an\n+        // old-style WF obligation here so that we still get the\n+        // errors that we used to get.\n+        fcx.register_old_wf_obligation(arg_ty, arg.pat.span, traits::MiscObligation);\n \n-        visit.visit_body(body);\n+        // Check the pattern.\n+        fcx.check_pat(&arg.pat, arg_ty);\n+        fcx.write_ty(arg.id, arg_ty);\n     }\n \n     inherited.tables.borrow_mut().liberated_fn_sigs.insert(fn_id, fn_sig);\n@@ -910,7 +890,7 @@ pub fn check_item_type<'a,'tcx>(ccx: &CrateCtxt<'a,'tcx>, it: &'tcx hir::Item) {\n                     err.emit();\n                 }\n \n-                if let hir::ForeignItemFn(ref fn_decl, _) = item.node {\n+                if let hir::ForeignItemFn(ref fn_decl, _, _) = item.node {\n                     require_c_abi_if_variadic(ccx.tcx, fn_decl, m.abi, item.span);\n                 }\n             }\n@@ -954,10 +934,10 @@ pub fn check_item_body<'a,'tcx>(ccx: &CrateCtxt<'a,'tcx>, it: &'tcx hir::Item) {\n                 hir::TraitItemKind::Const(_, Some(expr)) => {\n                     check_const(ccx, expr, trait_item.id)\n                 }\n-                hir::TraitItemKind::Method(ref sig, Some(body_id)) => {\n+                hir::TraitItemKind::Method(ref sig, hir::TraitMethod::Provided(body_id)) => {\n                     check_bare_fn(ccx, &sig.decl, body_id, trait_item.id, trait_item.span);\n                 }\n-                hir::TraitItemKind::Method(_, None) |\n+                hir::TraitItemKind::Method(_, hir::TraitMethod::Required(_)) |\n                 hir::TraitItemKind::Const(_, None) |\n                 hir::TraitItemKind::Type(..) => {\n                     // Nothing to do.\n@@ -1269,7 +1249,7 @@ fn check_const_with_type<'a, 'tcx>(ccx: &'a CrateCtxt<'a, 'tcx>,\n         fcx.select_all_obligations_or_error();\n \n         fcx.regionck_expr(body);\n-        fcx.resolve_type_vars_in_expr(body, id);\n+        fcx.resolve_type_vars_in_body(body, id);\n     });\n }\n "}, {"sha": "bd63eb6ad25effeb2aa95536a598c8f5b48ba62d", "filename": "src/librustc_typeck/check/regionck.rs", "status": "modified", "additions": 5, "deletions": 8, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/f89856be6ccd1f63ef72d343587cd5d7932cfe8b/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f89856be6ccd1f63ef72d343587cd5d7932cfe8b/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs?ref=f89856be6ccd1f63ef72d343587cd5d7932cfe8b", "patch": "@@ -141,15 +141,14 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n \n     pub fn regionck_fn(&self,\n                        fn_id: ast::NodeId,\n-                       decl: &hir::FnDecl,\n                        body: &'gcx hir::Body) {\n         debug!(\"regionck_fn(id={})\", fn_id);\n         let node_id = body.value.id;\n         let mut rcx = RegionCtxt::new(self, RepeatingScope(node_id), node_id, Subject(fn_id));\n \n         if self.err_count_since_creation() == 0 {\n             // regionck assumes typeck succeeded\n-            rcx.visit_fn_body(fn_id, decl, body, self.tcx.map.span(fn_id));\n+            rcx.visit_fn_body(fn_id, body, self.tcx.map.span(fn_id));\n         }\n \n         rcx.free_region_map.relate_free_regions_from_predicates(\n@@ -268,7 +267,6 @@ impl<'a, 'gcx, 'tcx> RegionCtxt<'a, 'gcx, 'tcx> {\n \n     fn visit_fn_body(&mut self,\n                      id: ast::NodeId, // the id of the fn itself\n-                     fn_decl: &hir::FnDecl,\n                      body: &'gcx hir::Body,\n                      span: Span)\n     {\n@@ -303,8 +301,7 @@ impl<'a, 'gcx, 'tcx> RegionCtxt<'a, 'gcx, 'tcx> {\n \n         let old_body_id = self.set_body_id(body_id.node_id);\n         self.relate_free_regions(&fn_sig_tys[..], body_id.node_id, span);\n-        self.link_fn_args(self.tcx.region_maps.node_extent(body_id.node_id),\n-                          &fn_decl.inputs[..]);\n+        self.link_fn_args(self.tcx.region_maps.node_extent(body_id.node_id), &body.arguments);\n         self.visit_body(body);\n         self.visit_region_obligations(body_id.node_id);\n \n@@ -483,10 +480,10 @@ impl<'a, 'gcx, 'tcx> Visitor<'gcx> for RegionCtxt<'a, 'gcx, 'tcx> {\n         NestedVisitorMap::None\n     }\n \n-    fn visit_fn(&mut self, _fk: intravisit::FnKind<'gcx>, fd: &'gcx hir::FnDecl,\n+    fn visit_fn(&mut self, _fk: intravisit::FnKind<'gcx>, _: &'gcx hir::FnDecl,\n                 b: hir::BodyId, span: Span, id: ast::NodeId) {\n         let body = self.tcx.map.body(b);\n-        self.visit_fn_body(id, fd, body, span)\n+        self.visit_fn_body(id, body, span)\n     }\n \n     //visit_pat: visit_pat, // (..) see above\n@@ -1116,7 +1113,7 @@ impl<'a, 'gcx, 'tcx> RegionCtxt<'a, 'gcx, 'tcx> {\n         for arg in args {\n             let arg_ty = self.node_ty(arg.id);\n             let re_scope = self.tcx.mk_region(ty::ReScope(body_scope));\n-            let arg_cmt = mc.cat_rvalue(arg.id, arg.ty.span, re_scope, arg_ty);\n+            let arg_cmt = mc.cat_rvalue(arg.id, arg.pat.span, re_scope, arg_ty);\n             debug!(\"arg_ty={:?} arg_cmt={:?} arg={:?}\",\n                    arg_ty,\n                    arg_cmt,"}, {"sha": "af4fe2dc41b4ab47abb4d3a2d6b811b55300c613", "filename": "src/librustc_typeck/check/upvar.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/f89856be6ccd1f63ef72d343587cd5d7932cfe8b/src%2Flibrustc_typeck%2Fcheck%2Fupvar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f89856be6ccd1f63ef72d343587cd5d7932cfe8b/src%2Flibrustc_typeck%2Fcheck%2Fupvar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fupvar.rs?ref=f89856be6ccd1f63ef72d343587cd5d7932cfe8b", "patch": "@@ -157,7 +157,6 @@ impl<'a, 'gcx, 'tcx> AdjustBorrowKind<'a, 'gcx, 'tcx> {\n     fn analyze_closure(&mut self,\n                        id: ast::NodeId,\n                        span: Span,\n-                       decl: &hir::FnDecl,\n                        body: &hir::Body) {\n         /*!\n          * Analysis starting point.\n@@ -172,7 +171,7 @@ impl<'a, 'gcx, 'tcx> AdjustBorrowKind<'a, 'gcx, 'tcx> {\n                                                   mc::MemCategorizationOptions {\n                                                       during_closure_kind_inference: true\n                                                   });\n-            euv.walk_fn(decl, body);\n+            euv.walk_fn(body);\n         }\n \n         // Now that we've analyzed the closure, we know how each\n@@ -505,7 +504,7 @@ impl<'a, 'gcx, 'tcx> Visitor<'gcx> for AdjustBorrowKind<'a, 'gcx, 'tcx> {\n \n         let body = self.fcx.tcx.map.body(body);\n         self.visit_body(body);\n-        self.analyze_closure(id, span, decl, body);\n+        self.analyze_closure(id, span, body);\n     }\n }\n "}, {"sha": "c80db7fa4d0e02b47c5ab4b2b800f63f8065b886", "filename": "src/librustc_typeck/check/wfcheck.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f89856be6ccd1f63ef72d343587cd5d7932cfe8b/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f89856be6ccd1f63ef72d343587cd5d7932cfe8b/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs?ref=f89856be6ccd1f63ef72d343587cd5d7932cfe8b", "patch": "@@ -478,7 +478,7 @@ impl<'ccx, 'gcx> CheckTypeWellFormedVisitor<'ccx, 'gcx> {\n             return;\n         }\n \n-        let span = method_sig.decl.inputs[0].pat.span;\n+        let span = method_sig.decl.inputs[0].span;\n \n         let free_substs = &fcx.parameter_environment.free_substs;\n         let method_ty = fcx.tcx.item_type(method.def_id);"}, {"sha": "479d595ee73756baee14a7f7689611b6c9e877dd", "filename": "src/librustc_typeck/check/writeback.rs", "status": "modified", "additions": 11, "deletions": 40, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/f89856be6ccd1f63ef72d343587cd5d7932cfe8b/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f89856be6ccd1f63ef72d343587cd5d7932cfe8b/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs?ref=f89856be6ccd1f63ef72d343587cd5d7932cfe8b", "patch": "@@ -28,40 +28,21 @@ use syntax_pos::Span;\n \n use rustc::hir::print::pat_to_string;\n use rustc::hir::intravisit::{self, Visitor, NestedVisitorMap};\n-use rustc::hir::{self, PatKind};\n+use rustc::hir;\n \n ///////////////////////////////////////////////////////////////////////////\n-// Entry point functions\n+// Entry point\n \n impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n-    pub fn resolve_type_vars_in_expr(&self, body: &'gcx hir::Body, item_id: ast::NodeId) {\n+    pub fn resolve_type_vars_in_body(&self,\n+                                     body: &'gcx hir::Body,\n+                                     item_id: ast::NodeId) {\n         assert_eq!(self.writeback_errors.get(), false);\n         let mut wbcx = WritebackCx::new(self);\n-        wbcx.visit_body(body);\n-        wbcx.visit_upvar_borrow_map();\n-        wbcx.visit_closures();\n-        wbcx.visit_liberated_fn_sigs();\n-        wbcx.visit_fru_field_types();\n-        wbcx.visit_deferred_obligations(item_id);\n-        wbcx.visit_type_nodes();\n-    }\n-\n-    pub fn resolve_type_vars_in_fn(&self,\n-                                   decl: &'gcx hir::FnDecl,\n-                                   body: &'gcx hir::Body,\n-                                   item_id: ast::NodeId) {\n-        assert_eq!(self.writeback_errors.get(), false);\n-        let mut wbcx = WritebackCx::new(self);\n-        wbcx.visit_body(body);\n-        for arg in &decl.inputs {\n+        for arg in &body.arguments {\n             wbcx.visit_node_id(ResolvingPattern(arg.pat.span), arg.id);\n-            wbcx.visit_pat(&arg.pat);\n-\n-            // Privacy needs the type for the whole pattern, not just each binding\n-            if let PatKind::Binding(..) = arg.pat.node {} else {\n-                wbcx.visit_node_id(ResolvingPattern(arg.pat.span), arg.pat.id);\n-            }\n         }\n+        wbcx.visit_body(body);\n         wbcx.visit_upvar_borrow_map();\n         wbcx.visit_closures();\n         wbcx.visit_liberated_fn_sigs();\n@@ -211,12 +192,12 @@ impl<'cx, 'gcx, 'tcx> Visitor<'gcx> for WritebackCx<'cx, 'gcx, 'tcx> {\n         self.visit_method_map_entry(ResolvingExpr(e.span),\n                                     MethodCall::expr(e.id));\n \n-        if let hir::ExprClosure(_, ref decl, body, _) = e.node {\n-            for input in &decl.inputs {\n-                self.visit_node_id(ResolvingExpr(e.span), input.id);\n+        if let hir::ExprClosure(_, _, body, _) = e.node {\n+            let body = self.fcx.tcx.map.body(body);\n+            for arg in &body.arguments {\n+                self.visit_node_id(ResolvingExpr(e.span), arg.id);\n             }\n \n-            let body = self.fcx.tcx.map.body(body);\n             self.visit_body(body);\n         }\n \n@@ -257,16 +238,6 @@ impl<'cx, 'gcx, 'tcx> Visitor<'gcx> for WritebackCx<'cx, 'gcx, 'tcx> {\n         self.write_ty_to_tcx(l.id, var_ty);\n         intravisit::walk_local(self, l);\n     }\n-\n-    fn visit_ty(&mut self, t: &'gcx hir::Ty) {\n-        match t.node {\n-            hir::TyBareFn(ref function_declaration) => {\n-                intravisit::walk_fn_decl_nopat(self, &function_declaration.decl);\n-                walk_list!(self, visit_lifetime_def, &function_declaration.lifetimes);\n-            }\n-            _ => intravisit::walk_ty(self, t)\n-        }\n-    }\n }\n \n impl<'cx, 'gcx, 'tcx> WritebackCx<'cx, 'gcx, 'tcx> {"}, {"sha": "bbaf1b651109064ad009486ab4f2d981b88439ff", "filename": "src/librustc_typeck/collect.rs", "status": "modified", "additions": 17, "deletions": 12, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/f89856be6ccd1f63ef72d343587cd5d7932cfe8b/src%2Flibrustc_typeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f89856be6ccd1f63ef72d343587cd5d7932cfe8b/src%2Flibrustc_typeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcollect.rs?ref=f89856be6ccd1f63ef72d343587cd5d7932cfe8b", "patch": "@@ -640,7 +640,8 @@ fn convert_method<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n                             id: ast::NodeId,\n                             sig: &hir::MethodSig,\n                             untransformed_rcvr_ty: Ty<'tcx>,\n-                            rcvr_ty_predicates: &ty::GenericPredicates<'tcx>) {\n+                            body: Option<hir::BodyId>,\n+                            rcvr_ty_predicates: &ty::GenericPredicates<'tcx>,) {\n     let def_id = ccx.tcx.map.local_def_id(id);\n     let ty_generics = generics_of_def_id(ccx, def_id);\n \n@@ -658,7 +659,7 @@ fn convert_method<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n         None\n     };\n     let fty = AstConv::ty_of_method(&ccx.icx(&(rcvr_ty_predicates, &sig.generics)),\n-                                    sig, self_value_ty, anon_scope);\n+                                    sig, self_value_ty, body, anon_scope);\n \n     let substs = mk_item_substs(&ccx.icx(&(rcvr_ty_predicates, &sig.generics)),\n                                 ccx.tcx.map.span(id), def_id);\n@@ -865,10 +866,14 @@ fn convert_trait_item(ccx: &CrateCtxt, trait_item: &hir::TraitItem) {\n             convert_associated_type(ccx, TraitContainer(trait_def_id), trait_item.id, typ);\n         }\n \n-        hir::TraitItemKind::Method(ref sig, _) => {\n+        hir::TraitItemKind::Method(ref sig, ref method) => {\n+            let body = match *method {\n+                hir::TraitMethod::Required(_) => None,\n+                hir::TraitMethod::Provided(body) => Some(body)\n+            };\n             convert_method(ccx, TraitContainer(trait_def_id),\n                            trait_item.id, sig, tcx.mk_self_type(),\n-                           &trait_predicates);\n+                           body, &trait_predicates);\n         }\n     }\n }\n@@ -908,10 +913,10 @@ fn convert_impl_item(ccx: &CrateCtxt, impl_item: &hir::ImplItem) {\n             convert_associated_type(ccx, ImplContainer(impl_def_id), impl_item.id, Some(typ));\n         }\n \n-        hir::ImplItemKind::Method(ref sig, _) => {\n+        hir::ImplItemKind::Method(ref sig, body) => {\n             convert_method(ccx, ImplContainer(impl_def_id),\n                            impl_item.id, sig, impl_self_ty,\n-                           &impl_predicates);\n+                           Some(body), &impl_predicates);\n         }\n     }\n }\n@@ -1429,7 +1434,7 @@ fn generics_of_def_id<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n             NodeForeignItem(item) => {\n                 match item.node {\n                     ForeignItemStatic(..) => &no_generics,\n-                    ForeignItemFn(_, ref generics) => generics\n+                    ForeignItemFn(_, _, ref generics) => generics\n                 }\n             }\n \n@@ -1530,9 +1535,9 @@ fn type_of_def_id<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n                     ItemStatic(ref t, ..) | ItemConst(ref t, _) => {\n                         ccx.icx(&()).to_ty(&StaticRscope::new(&ccx.tcx), &t)\n                     }\n-                    ItemFn(ref decl, unsafety, _, abi, ref generics, _) => {\n+                    ItemFn(ref decl, unsafety, _, abi, ref generics, body) => {\n                         let tofd = AstConv::ty_of_bare_fn(&ccx.icx(generics), unsafety, abi, &decl,\n-                                                          Some(AnonTypeScope::new(def_id)));\n+                                                          body, Some(AnonTypeScope::new(def_id)));\n                         let substs = mk_item_substs(&ccx.icx(generics), item.span, def_id);\n                         ccx.tcx.mk_fn_def(def_id, substs, tofd)\n                     }\n@@ -1572,7 +1577,7 @@ fn type_of_def_id<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n                 let abi = ccx.tcx.map.get_foreign_abi(node_id);\n \n                 match foreign_item.node {\n-                    ForeignItemFn(ref fn_decl, ref generics) => {\n+                    ForeignItemFn(ref fn_decl, _, ref generics) => {\n                         compute_type_of_foreign_fn_decl(\n                             ccx, ccx.tcx.map.local_def_id(foreign_item.id),\n                             fn_decl, generics, abi)\n@@ -1637,7 +1642,7 @@ fn convert_foreign_item<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n \n     let no_generics = hir::Generics::empty();\n     let generics = match it.node {\n-        hir::ForeignItemFn(_, ref generics) => generics,\n+        hir::ForeignItemFn(_, _, ref generics) => generics,\n         hir::ForeignItemStatic(..) => &no_generics\n     };\n \n@@ -2073,7 +2078,7 @@ fn compute_type_of_foreign_fn_decl<'a, 'tcx>(\n             }\n         };\n         for (input, ty) in decl.inputs.iter().zip(&input_tys) {\n-            check(&input.ty, ty)\n+            check(&input, ty)\n         }\n         if let hir::Return(ref ty) = decl.output {\n             check(&ty, output)"}, {"sha": "3f5e443a20a6854b575a7a57fdf197102483da43", "filename": "src/librustc_typeck/rscope.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f89856be6ccd1f63ef72d343587cd5d7932cfe8b/src%2Flibrustc_typeck%2Frscope.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f89856be6ccd1f63ef72d343587cd5d7932cfe8b/src%2Flibrustc_typeck%2Frscope.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Frscope.rs?ref=f89856be6ccd1f63ef72d343587cd5d7932cfe8b", "patch": "@@ -8,6 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+use rustc::hir;\n use rustc::hir::def_id::DefId;\n use rustc::ty;\n use rustc::ty::subst::Substs;\n@@ -19,7 +20,10 @@ use syntax_pos::Span;\n \n #[derive(Clone)]\n pub struct ElisionFailureInfo {\n-    pub name: String,\n+    /// Where we can find the argument pattern.\n+    pub parent: Option<hir::BodyId>,\n+    /// The index of the argument in the original definition.\n+    pub index: usize,\n     pub lifetime_count: usize,\n     pub have_bound_regions: bool\n }"}, {"sha": "7516faab519622015294f48cc316ca00d374818c", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 60, "deletions": 61, "changes": 121, "blob_url": "https://github.com/rust-lang/rust/blob/f89856be6ccd1f63ef72d343587cd5d7932cfe8b/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f89856be6ccd1f63ef72d343587cd5d7932cfe8b/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=f89856be6ccd1f63ef72d343587cd5d7932cfe8b", "patch": "@@ -1030,22 +1030,14 @@ pub struct Method {\n     pub abi: Abi,\n }\n \n-impl Clean<Method> for hir::MethodSig {\n+impl<'a> Clean<Method> for (&'a hir::MethodSig, hir::BodyId) {\n     fn clean(&self, cx: &DocContext) -> Method {\n-        let decl = FnDecl {\n-            inputs: Arguments {\n-                values: self.decl.inputs.clean(cx),\n-            },\n-            output: self.decl.output.clean(cx),\n-            variadic: false,\n-            attrs: Attributes::default()\n-        };\n         Method {\n-            generics: self.generics.clean(cx),\n-            unsafety: self.unsafety,\n-            constness: self.constness,\n-            decl: decl,\n-            abi: self.abi\n+            generics: self.0.generics.clean(cx),\n+            unsafety: self.0.unsafety,\n+            constness: self.0.constness,\n+            decl: (&*self.0.decl, self.1).clean(cx),\n+            abi: self.0.abi\n         }\n     }\n }\n@@ -1058,25 +1050,6 @@ pub struct TyMethod {\n     pub abi: Abi,\n }\n \n-impl Clean<TyMethod> for hir::MethodSig {\n-    fn clean(&self, cx: &DocContext) -> TyMethod {\n-        let decl = FnDecl {\n-            inputs: Arguments {\n-                values: self.decl.inputs.clean(cx),\n-            },\n-            output: self.decl.output.clean(cx),\n-            variadic: false,\n-            attrs: Attributes::default()\n-        };\n-        TyMethod {\n-            unsafety: self.unsafety.clone(),\n-            decl: decl,\n-            generics: self.generics.clean(cx),\n-            abi: self.abi\n-        }\n-    }\n-}\n-\n #[derive(Clone, RustcEncodable, RustcDecodable, Debug)]\n pub struct Function {\n     pub decl: FnDecl,\n@@ -1097,7 +1070,7 @@ impl Clean<Item> for doctree::Function {\n             deprecation: self.depr.clean(cx),\n             def_id: cx.tcx.map.local_def_id(self.id),\n             inner: FunctionItem(Function {\n-                decl: self.decl.clean(cx),\n+                decl: (&self.decl, self.body).clean(cx),\n                 generics: self.generics.clean(cx),\n                 unsafety: self.unsafety,\n                 constness: self.constness,\n@@ -1130,14 +1103,47 @@ pub struct Arguments {\n     pub values: Vec<Argument>,\n }\n \n-impl Clean<FnDecl> for hir::FnDecl {\n+impl<'a> Clean<Arguments> for (&'a [P<hir::Ty>], &'a [Spanned<ast::Name>]) {\n+    fn clean(&self, cx: &DocContext) -> Arguments {\n+        Arguments {\n+            values: self.0.iter().enumerate().map(|(i, ty)| {\n+                let mut name = self.1.get(i).map(|n| n.node.to_string())\n+                                            .unwrap_or(String::new());\n+                if name.is_empty() {\n+                    name = \"_\".to_string();\n+                }\n+                Argument {\n+                    name: name,\n+                    type_: ty.clean(cx),\n+                }\n+            }).collect()\n+        }\n+    }\n+}\n+\n+impl<'a> Clean<Arguments> for (&'a [P<hir::Ty>], hir::BodyId) {\n+    fn clean(&self, cx: &DocContext) -> Arguments {\n+        let body = cx.tcx.map.body(self.1);\n+\n+        Arguments {\n+            values: self.0.iter().enumerate().map(|(i, ty)| {\n+                Argument {\n+                    name: name_from_pat(&body.arguments[i].pat),\n+                    type_: ty.clean(cx),\n+                }\n+            }).collect()\n+        }\n+    }\n+}\n+\n+impl<'a, A: Copy> Clean<FnDecl> for (&'a hir::FnDecl, A)\n+    where (&'a [P<hir::Ty>], A): Clean<Arguments>\n+{\n     fn clean(&self, cx: &DocContext) -> FnDecl {\n         FnDecl {\n-            inputs: Arguments {\n-                values: self.inputs.clean(cx),\n-            },\n-            output: self.output.clean(cx),\n-            variadic: self.variadic,\n+            inputs: (&self.0.inputs[..], self.1).clean(cx),\n+            output: self.0.output.clean(cx),\n+            variadic: self.0.variadic,\n             attrs: Attributes::default()\n         }\n     }\n@@ -1159,7 +1165,6 @@ impl<'a, 'tcx> Clean<FnDecl> for (DefId, &'a ty::PolyFnSig<'tcx>) {\n                 values: sig.skip_binder().inputs().iter().map(|t| {\n                     Argument {\n                         type_: t.clean(cx),\n-                        id: ast::CRATE_NODE_ID,\n                         name: names.next().map_or(\"\".to_string(), |name| name.to_string()),\n                     }\n                 }).collect(),\n@@ -1172,7 +1177,6 @@ impl<'a, 'tcx> Clean<FnDecl> for (DefId, &'a ty::PolyFnSig<'tcx>) {\n pub struct Argument {\n     pub type_: Type,\n     pub name: String,\n-    pub id: ast::NodeId,\n }\n \n #[derive(Clone, RustcEncodable, RustcDecodable, PartialEq, Debug)]\n@@ -1199,16 +1203,6 @@ impl Argument {\n     }\n }\n \n-impl Clean<Argument> for hir::Arg {\n-    fn clean(&self, cx: &DocContext) -> Argument {\n-        Argument {\n-            name: name_from_pat(&*self.pat),\n-            type_: (self.ty.clean(cx)),\n-            id: self.id\n-        }\n-    }\n-}\n-\n #[derive(Clone, RustcEncodable, RustcDecodable, PartialEq, Debug)]\n pub enum FunctionRetTy {\n     Return(Type),\n@@ -1274,11 +1268,16 @@ impl Clean<Item> for hir::TraitItem {\n                 AssociatedConstItem(ty.clean(cx),\n                                     default.map(|e| print_const_expr(cx, e)))\n             }\n-            hir::TraitItemKind::Method(ref sig, Some(_)) => {\n-                MethodItem(sig.clean(cx))\n+            hir::TraitItemKind::Method(ref sig, hir::TraitMethod::Provided(body)) => {\n+                MethodItem((sig, body).clean(cx))\n             }\n-            hir::TraitItemKind::Method(ref sig, None) => {\n-                TyMethodItem(sig.clean(cx))\n+            hir::TraitItemKind::Method(ref sig, hir::TraitMethod::Required(ref names)) => {\n+                TyMethodItem(TyMethod {\n+                    unsafety: sig.unsafety.clone(),\n+                    decl: (&*sig.decl, &names[..]).clean(cx),\n+                    generics: sig.generics.clean(cx),\n+                    abi: sig.abi\n+                })\n             }\n             hir::TraitItemKind::Type(ref bounds, ref default) => {\n                 AssociatedTypeItem(bounds.clean(cx), default.clean(cx))\n@@ -1304,8 +1303,8 @@ impl Clean<Item> for hir::ImplItem {\n                 AssociatedConstItem(ty.clean(cx),\n                                     Some(print_const_expr(cx, expr)))\n             }\n-            hir::ImplItemKind::Method(ref sig, _) => {\n-                MethodItem(sig.clean(cx))\n+            hir::ImplItemKind::Method(ref sig, body) => {\n+                MethodItem((sig, body).clean(cx))\n             }\n             hir::ImplItemKind::Type(ref ty) => TypedefItem(Typedef {\n                 type_: ty.clean(cx),\n@@ -2343,7 +2342,7 @@ impl Clean<BareFunctionDecl> for hir::BareFnTy {\n                 type_params: Vec::new(),\n                 where_predicates: Vec::new()\n             },\n-            decl: self.decl.clean(cx),\n+            decl: (&*self.decl, &[][..]).clean(cx),\n             abi: self.abi,\n         }\n     }\n@@ -2641,9 +2640,9 @@ impl Clean<Vec<Item>> for hir::ForeignMod {\n impl Clean<Item> for hir::ForeignItem {\n     fn clean(&self, cx: &DocContext) -> Item {\n         let inner = match self.node {\n-            hir::ForeignItemFn(ref decl, ref generics) => {\n+            hir::ForeignItemFn(ref decl, ref names, ref generics) => {\n                 ForeignFunctionItem(Function {\n-                    decl: decl.clean(cx),\n+                    decl: (&**decl, &names[..]).clean(cx),\n                     generics: generics.clean(cx),\n                     unsafety: hir::Unsafety::Unsafe,\n                     abi: Abi::Rust,"}, {"sha": "d819268240badca941579c315ac882df1194bcd0", "filename": "src/librustdoc/doctree.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f89856be6ccd1f63ef72d343587cd5d7932cfe8b/src%2Flibrustdoc%2Fdoctree.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f89856be6ccd1f63ef72d343587cd5d7932cfe8b/src%2Flibrustdoc%2Fdoctree.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fdoctree.rs?ref=f89856be6ccd1f63ef72d343587cd5d7932cfe8b", "patch": "@@ -156,6 +156,7 @@ pub struct Function {\n     pub whence: Span,\n     pub generics: hir::Generics,\n     pub abi: abi::Abi,\n+    pub body: hir::BodyId,\n }\n \n pub struct Typedef {"}, {"sha": "b0afc3d63f47932a0bc805092e48eff4ab3af833", "filename": "src/librustdoc/visit_ast.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/f89856be6ccd1f63ef72d343587cd5d7932cfe8b/src%2Flibrustdoc%2Fvisit_ast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f89856be6ccd1f63ef72d343587cd5d7932cfe8b/src%2Flibrustdoc%2Fvisit_ast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fvisit_ast.rs?ref=f89856be6ccd1f63ef72d343587cd5d7932cfe8b", "patch": "@@ -157,7 +157,8 @@ impl<'a, 'tcx> RustdocVisitor<'a, 'tcx> {\n                     unsafety: &hir::Unsafety,\n                     constness: hir::Constness,\n                     abi: &abi::Abi,\n-                    gen: &hir::Generics) -> Function {\n+                    gen: &hir::Generics,\n+                    body: hir::BodyId) -> Function {\n         debug!(\"Visiting fn\");\n         Function {\n             id: item.id,\n@@ -172,6 +173,7 @@ impl<'a, 'tcx> RustdocVisitor<'a, 'tcx> {\n             unsafety: *unsafety,\n             constness: constness,\n             abi: *abi,\n+            body: body,\n         }\n     }\n \n@@ -410,9 +412,9 @@ impl<'a, 'tcx> RustdocVisitor<'a, 'tcx> {\n                 om.structs.push(self.visit_variant_data(item, name, sd, gen)),\n             hir::ItemUnion(ref sd, ref gen) =>\n                 om.unions.push(self.visit_union_data(item, name, sd, gen)),\n-            hir::ItemFn(ref fd, ref unsafety, constness, ref abi, ref gen, _) =>\n+            hir::ItemFn(ref fd, ref unsafety, constness, ref abi, ref gen, body) =>\n                 om.fns.push(self.visit_fn(item, name, &**fd, unsafety,\n-                                          constness, abi, gen)),\n+                                          constness, abi, gen, body)),\n             hir::ItemTy(ref ty, ref gen) => {\n                 let t = Typedef {\n                     ty: ty.clone(),"}, {"sha": "eac134ff3cc7d6b287cf83a34ca4c67862897d20", "filename": "src/test/compile-fail/explicit-self-lifetime-mismatch.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f89856be6ccd1f63ef72d343587cd5d7932cfe8b/src%2Ftest%2Fcompile-fail%2Fexplicit-self-lifetime-mismatch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f89856be6ccd1f63ef72d343587cd5d7932cfe8b/src%2Ftest%2Fcompile-fail%2Fexplicit-self-lifetime-mismatch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fexplicit-self-lifetime-mismatch.rs?ref=f89856be6ccd1f63ef72d343587cd5d7932cfe8b", "patch": "@@ -14,8 +14,8 @@ struct Foo<'a,'b> {\n }\n \n impl<'a,'b> Foo<'a,'b> {\n-    fn bar(\n-        self\n+    fn bar(self:\n+           Foo<'b,'a>\n     //~^ ERROR mismatched method receiver\n     //~| expected type `Foo<'a, 'b>`\n     //~| found type `Foo<'b, 'a>`\n@@ -24,7 +24,7 @@ impl<'a,'b> Foo<'a,'b> {\n     //~| expected type `Foo<'a, 'b>`\n     //~| found type `Foo<'b, 'a>`\n     //~| lifetime mismatch\n-            : Foo<'b,'a>) {}\n+           ) {}\n }\n \n fn main() {}"}, {"sha": "bc401ae93404f0a45e099b022e781654715d5e2b", "filename": "src/test/incremental/hashes/trait_defs.rs", "status": "modified", "additions": 11, "deletions": 1, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/f89856be6ccd1f63ef72d343587cd5d7932cfe8b/src%2Ftest%2Fincremental%2Fhashes%2Ftrait_defs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f89856be6ccd1f63ef72d343587cd5d7932cfe8b/src%2Ftest%2Fincremental%2Fhashes%2Ftrait_defs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fincremental%2Fhashes%2Ftrait_defs.rs?ref=f89856be6ccd1f63ef72d343587cd5d7932cfe8b", "patch": "@@ -158,6 +158,7 @@ trait TraitAddParameterToMethod {\n #[cfg(cfail1)]\n trait TraitChangeMethodParameterName {\n     fn method(a: u32);\n+    fn with_default(x: i32) {}\n }\n \n #[cfg(not(cfail1))]\n@@ -166,11 +167,20 @@ trait TraitChangeMethodParameterName {\n #[rustc_metadata_dirty(cfg=\"cfail2\")]\n #[rustc_metadata_clean(cfg=\"cfail3\")]\n trait TraitChangeMethodParameterName {\n+    // FIXME(#38501) This should preferably always be clean.\n     #[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n     #[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n     #[rustc_metadata_dirty(cfg=\"cfail2\")]\n     #[rustc_metadata_clean(cfg=\"cfail3\")]\n     fn method(b: u32);\n+\n+    #[rustc_clean(label=\"Hir\", cfg=\"cfail2\")]\n+    #[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n+    #[rustc_dirty(label=\"HirBody\", cfg=\"cfail2\")]\n+    #[rustc_clean(label=\"HirBody\", cfg=\"cfail3\")]\n+    #[rustc_metadata_dirty(cfg=\"cfail2\")]\n+    #[rustc_metadata_clean(cfg=\"cfail3\")]\n+    fn with_default(y: i32) {}\n }\n \n \n@@ -303,7 +313,7 @@ trait TraitChangeModeSelfOwnToMut: Sized {\n #[cfg(not(cfail1))]\n #[rustc_clean(label=\"Hir\", cfg=\"cfail2\")]\n #[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n-#[rustc_metadata_dirty(cfg=\"cfail2\")]\n+#[rustc_metadata_clean(cfg=\"cfail2\")]\n #[rustc_metadata_clean(cfg=\"cfail3\")]\n trait TraitChangeModeSelfOwnToMut: Sized {\n     #[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]"}]}