{"sha": "07ff914be1c5e0702893191827b0c13308898b45", "node_id": "MDY6Q29tbWl0NzI0NzEyOjA3ZmY5MTRiZTFjNWUwNzAyODkzMTkxODI3YjBjMTMzMDg4OThiNDU=", "commit": {"author": {"name": "Eduard-Mihai Burtescu", "email": "edy.burt@gmail.com", "date": "2016-11-24T23:33:29Z"}, "committer": {"name": "Eduard-Mihai Burtescu", "email": "edy.burt@gmail.com", "date": "2016-11-29T19:24:26Z"}, "message": "rustc: simplify AdtDef by removing the field types and ty::ivar.", "tree": {"sha": "15ed885bac3160d11d65b0749d7f6f6626d39444", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/15ed885bac3160d11d65b0749d7f6f6626d39444"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/07ff914be1c5e0702893191827b0c13308898b45", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/07ff914be1c5e0702893191827b0c13308898b45", "html_url": "https://github.com/rust-lang/rust/commit/07ff914be1c5e0702893191827b0c13308898b45", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/07ff914be1c5e0702893191827b0c13308898b45/comments", "author": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "committer": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3f338eed99265fe5e9a167abb2e1f4a7ff2ea101", "url": "https://api.github.com/repos/rust-lang/rust/commits/3f338eed99265fe5e9a167abb2e1f4a7ff2ea101", "html_url": "https://github.com/rust-lang/rust/commit/3f338eed99265fe5e9a167abb2e1f4a7ff2ea101"}], "stats": {"total": 603, "additions": 199, "deletions": 404}, "files": [{"sha": "e261c699b6ac60a03a16d5a340f1cef80a3491bc", "filename": "src/librustc/dep_graph/dep_node.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/07ff914be1c5e0702893191827b0c13308898b45/src%2Flibrustc%2Fdep_graph%2Fdep_node.rs", "raw_url": "https://github.com/rust-lang/rust/raw/07ff914be1c5e0702893191827b0c13308898b45/src%2Flibrustc%2Fdep_graph%2Fdep_node.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdep_graph%2Fdep_node.rs?ref=07ff914be1c5e0702893191827b0c13308898b45", "patch": "@@ -110,7 +110,6 @@ pub enum DepNode<D: Clone + Debug> {\n     // predicates for an item wind up in `ItemSignature`).\n     AssociatedItems(D),\n     ItemSignature(D),\n-    FieldTy(D),\n     SizedConstraint(D),\n     AssociatedItemDefIds(D),\n     InherentImpls(D),\n@@ -161,7 +160,6 @@ impl<D: Clone + Debug> DepNode<D> {\n             TypeckItemBody,\n             AssociatedItems,\n             ItemSignature,\n-            FieldTy,\n             AssociatedItemDefIds,\n             InherentImpls,\n             TraitImpls,\n@@ -229,7 +227,6 @@ impl<D: Clone + Debug> DepNode<D> {\n             TransInlinedItem(ref d) => op(d).map(TransInlinedItem),\n             AssociatedItems(ref d) => op(d).map(AssociatedItems),\n             ItemSignature(ref d) => op(d).map(ItemSignature),\n-            FieldTy(ref d) => op(d).map(FieldTy),\n             SizedConstraint(ref d) => op(d).map(SizedConstraint),\n             AssociatedItemDefIds(ref d) => op(d).map(AssociatedItemDefIds),\n             InherentImpls(ref d) => op(d).map(InherentImpls),"}, {"sha": "f5dfc30f346cb05cfa40bfd9ad930d7aafb06217", "filename": "src/librustc/middle/cstore.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/07ff914be1c5e0702893191827b0c13308898b45/src%2Flibrustc%2Fmiddle%2Fcstore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/07ff914be1c5e0702893191827b0c13308898b45/src%2Flibrustc%2Fmiddle%2Fcstore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcstore.rs?ref=07ff914be1c5e0702893191827b0c13308898b45", "patch": "@@ -278,7 +278,7 @@ pub trait CrateStore<'tcx> {\n                          -> ty::Generics<'tcx>;\n     fn item_attrs(&self, def_id: DefId) -> Vec<ast::Attribute>;\n     fn trait_def<'a>(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>, def: DefId)-> ty::TraitDef;\n-    fn adt_def<'a>(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>, def: DefId) -> ty::AdtDefMaster<'tcx>;\n+    fn adt_def<'a>(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>, def: DefId) -> &'tcx ty::AdtDef;\n     fn fn_arg_names(&self, did: DefId) -> Vec<ast::Name>;\n     fn inherent_implementations_for_type(&self, def_id: DefId) -> Vec<DefId>;\n \n@@ -425,7 +425,7 @@ impl<'tcx> CrateStore<'tcx> for DummyCrateStore {\n     fn item_attrs(&self, def_id: DefId) -> Vec<ast::Attribute> { bug!(\"item_attrs\") }\n     fn trait_def<'a>(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>, def: DefId)-> ty::TraitDef\n         { bug!(\"trait_def\") }\n-    fn adt_def<'a>(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>, def: DefId) -> ty::AdtDefMaster<'tcx>\n+    fn adt_def<'a>(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>, def: DefId) -> &'tcx ty::AdtDef\n         { bug!(\"adt_def\") }\n     fn fn_arg_names(&self, did: DefId) -> Vec<ast::Name> { bug!(\"fn_arg_names\") }\n     fn inherent_implementations_for_type(&self, def_id: DefId) -> Vec<DefId> { vec![] }"}, {"sha": "b3e61f1e5706772c1eeffc77f0c19c3d9fa6c399", "filename": "src/librustc/middle/expr_use_visitor.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/07ff914be1c5e0702893191827b0c13308898b45/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/07ff914be1c5e0702893191827b0c13308898b45/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs?ref=07ff914be1c5e0702893191827b0c13308898b45", "patch": "@@ -701,7 +701,7 @@ impl<'a, 'gcx, 'tcx> ExprUseVisitor<'a, 'gcx, 'tcx> {\n         // are properly handled.\n         self.walk_expr(with_expr);\n \n-        fn contains_field_named(field: ty::FieldDef,\n+        fn contains_field_named(field: &ty::FieldDef,\n                                 fields: &[hir::Field])\n                                 -> bool\n         {"}, {"sha": "3cd35804732926d9689679b5c5d0dde745b6406b", "filename": "src/librustc/mir/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/07ff914be1c5e0702893191827b0c13308898b45/src%2Flibrustc%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/07ff914be1c5e0702893191827b0c13308898b45/src%2Flibrustc%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Fmod.rs?ref=07ff914be1c5e0702893191827b0c13308898b45", "patch": "@@ -462,7 +462,7 @@ pub enum TerminatorKind<'tcx> {\n     /// lvalue evaluates to some enum; jump depending on the branch\n     Switch {\n         discr: Lvalue<'tcx>,\n-        adt_def: AdtDef<'tcx>,\n+        adt_def: &'tcx AdtDef,\n         targets: Vec<BasicBlock>,\n     },\n \n@@ -866,7 +866,7 @@ pub enum ProjectionElem<'tcx, V> {\n     /// \"Downcast\" to a variant of an ADT. Currently, we only introduce\n     /// this for ADTs with more than one variant. It may be better to\n     /// just introduce it always, or always for enums.\n-    Downcast(AdtDef<'tcx>, usize),\n+    Downcast(&'tcx AdtDef, usize),\n }\n \n /// Alias for projections as they appear in lvalues, where the base is an lvalue\n@@ -1035,7 +1035,7 @@ pub enum AggregateKind<'tcx> {\n     /// The second field is variant number (discriminant), it's equal to 0\n     /// for struct and union expressions. The fourth field is active field\n     /// number and is present only for union expressions.\n-    Adt(AdtDef<'tcx>, usize, &'tcx Substs<'tcx>, Option<usize>),\n+    Adt(&'tcx AdtDef, usize, &'tcx Substs<'tcx>, Option<usize>),\n     Closure(DefId, ClosureSubsts<'tcx>),\n }\n "}, {"sha": "03530945e046df3651199a4438ffed8f80610f3d", "filename": "src/librustc/mir/tcx.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/07ff914be1c5e0702893191827b0c13308898b45/src%2Flibrustc%2Fmir%2Ftcx.rs", "raw_url": "https://github.com/rust-lang/rust/raw/07ff914be1c5e0702893191827b0c13308898b45/src%2Flibrustc%2Fmir%2Ftcx.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Ftcx.rs?ref=07ff914be1c5e0702893191827b0c13308898b45", "patch": "@@ -25,7 +25,7 @@ pub enum LvalueTy<'tcx> {\n     Ty { ty: Ty<'tcx> },\n \n     /// Downcast to a particular variant of an enum.\n-    Downcast { adt_def: AdtDef<'tcx>,\n+    Downcast { adt_def: &'tcx AdtDef,\n                substs: &'tcx Substs<'tcx>,\n                variant_index: usize },\n }"}, {"sha": "69b356552edec3ef027df5606903a4520499ffd8", "filename": "src/librustc/traits/select.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/07ff914be1c5e0702893191827b0c13308898b45/src%2Flibrustc%2Ftraits%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/07ff914be1c5e0702893191827b0c13308898b45/src%2Flibrustc%2Ftraits%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fselect.rs?ref=07ff914be1c5e0702893191827b0c13308898b45", "patch": "@@ -2557,7 +2557,7 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n             (&ty::TyAdt(def, substs_a), &ty::TyAdt(_, substs_b)) => {\n                 let fields = def\n                     .all_fields()\n-                    .map(|f| f.unsubst_ty())\n+                    .map(|f| tcx.item_type(f.did))\n                     .collect::<Vec<_>>();\n \n                 // The last field of the structure has to exist and contain type parameters."}, {"sha": "22b3d8d4dcd8d97a99ce95f33a6bf3c7adaa405d", "filename": "src/librustc/ty/context.rs", "status": "modified", "additions": 11, "deletions": 18, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/07ff914be1c5e0702893191827b0c13308898b45/src%2Flibrustc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/07ff914be1c5e0702893191827b0c13308898b45/src%2Flibrustc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fcontext.rs?ref=07ff914be1c5e0702893191827b0c13308898b45", "patch": "@@ -67,7 +67,7 @@ pub struct CtxtArenas<'tcx> {\n     // references\n     generics: TypedArena<ty::Generics<'tcx>>,\n     trait_def: TypedArena<ty::TraitDef>,\n-    adt_def: TypedArena<ty::AdtDefData<'tcx, 'tcx>>,\n+    adt_def: TypedArena<ty::AdtDef>,\n     mir: TypedArena<RefCell<Mir<'tcx>>>,\n }\n \n@@ -420,6 +420,7 @@ pub struct GlobalCtxt<'tcx> {\n     pub impl_trait_refs: RefCell<DepTrackingMap<maps::ImplTraitRefs<'tcx>>>,\n     pub trait_defs: RefCell<DepTrackingMap<maps::TraitDefs<'tcx>>>,\n     pub adt_defs: RefCell<DepTrackingMap<maps::AdtDefs<'tcx>>>,\n+    pub adt_sized_constraint: RefCell<DepTrackingMap<maps::AdtSizedConstraint<'tcx>>>,\n \n     /// Maps from the def-id of an item (trait/struct/enum/fn) to its\n     /// associated generics and predicates.\n@@ -687,22 +688,13 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n         self.global_interners.arenas.trait_def.alloc(def)\n     }\n \n-    pub fn insert_adt_def(self, did: DefId, adt_def: ty::AdtDefMaster<'gcx>) {\n-        // this will need a transmute when reverse-variance is removed\n-        if let Some(prev) = self.adt_defs.borrow_mut().insert(did, adt_def) {\n-            bug!(\"Tried to overwrite interned AdtDef: {:?}\", prev)\n-        }\n-    }\n-\n-    pub fn intern_adt_def(self,\n-                          did: DefId,\n-                          kind: AdtKind,\n-                          variants: Vec<ty::VariantDefData<'gcx, 'gcx>>)\n-                          -> ty::AdtDefMaster<'gcx> {\n-        let def = ty::AdtDefData::new(self, did, kind, variants);\n-        let interned = self.global_interners.arenas.adt_def.alloc(def);\n-        self.insert_adt_def(did, interned);\n-        interned\n+    pub fn alloc_adt_def(self,\n+                         did: DefId,\n+                         kind: AdtKind,\n+                         variants: Vec<ty::VariantDef>)\n+                         -> &'gcx ty::AdtDef {\n+        let def = ty::AdtDef::new(self, did, kind, variants);\n+        self.global_interners.arenas.adt_def.alloc(def)\n     }\n \n     pub fn intern_stability(self, stab: attr::Stability) -> &'gcx attr::Stability {\n@@ -798,6 +790,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n             impl_trait_refs: RefCell::new(DepTrackingMap::new(dep_graph.clone())),\n             trait_defs: RefCell::new(DepTrackingMap::new(dep_graph.clone())),\n             adt_defs: RefCell::new(DepTrackingMap::new(dep_graph.clone())),\n+            adt_sized_constraint: RefCell::new(DepTrackingMap::new(dep_graph.clone())),\n             generics: RefCell::new(DepTrackingMap::new(dep_graph.clone())),\n             predicates: RefCell::new(DepTrackingMap::new(dep_graph.clone())),\n             super_predicates: RefCell::new(DepTrackingMap::new(dep_graph.clone())),\n@@ -1346,7 +1339,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n         self.mk_imm_ref(self.mk_region(ty::ReStatic), self.mk_str())\n     }\n \n-    pub fn mk_adt(self, def: AdtDef<'tcx>, substs: &'tcx Substs<'tcx>) -> Ty<'tcx> {\n+    pub fn mk_adt(self, def: &'tcx AdtDef, substs: &'tcx Substs<'tcx>) -> Ty<'tcx> {\n         // take a copy of substs so that we own the vectors inside\n         self.mk_ty(TyAdt(def, substs))\n     }"}, {"sha": "634599406afb2fc49627a734559fccb5e0c4abc1", "filename": "src/librustc/ty/ivar.rs", "status": "removed", "additions": 0, "deletions": 90, "changes": 90, "blob_url": "https://github.com/rust-lang/rust/blob/3f338eed99265fe5e9a167abb2e1f4a7ff2ea101/src%2Flibrustc%2Fty%2Fivar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f338eed99265fe5e9a167abb2e1f4a7ff2ea101/src%2Flibrustc%2Fty%2Fivar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fivar.rs?ref=3f338eed99265fe5e9a167abb2e1f4a7ff2ea101", "patch": "@@ -1,90 +0,0 @@\n-// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-use dep_graph::DepNode;\n-use hir::def_id::DefId;\n-use ty::{Ty, TyS};\n-use ty::tls;\n-\n-use rustc_data_structures::ivar;\n-\n-use std::fmt;\n-use std::marker::PhantomData;\n-use core::nonzero::NonZero;\n-\n-/// An IVar that contains a Ty. 'lt is a (reverse-variant) upper bound\n-/// on the lifetime of the IVar. This is required because of variance\n-/// problems: the IVar needs to be variant with respect to 'tcx (so\n-/// it can be referred to from Ty) but can only be modified if its\n-/// lifetime is exactly 'tcx.\n-///\n-/// Safety invariants:\n-///     (A) self.0, if fulfilled, is a valid Ty<'tcx>\n-///     (B) no aliases to this value with a 'tcx longer than this\n-///         value's 'lt exist\n-///\n-/// Dependency tracking: each ivar does not know what node in the\n-/// dependency graph it is associated with, so when you get/fulfill\n-/// you must supply a `DepNode` id. This should always be the same id!\n-///\n-/// NonZero is used rather than Unique because Unique isn't Copy.\n-pub struct TyIVar<'tcx, 'lt: 'tcx>(ivar::Ivar<NonZero<*const TyS<'static>>>,\n-                                   PhantomData<fn(TyS<'lt>)->TyS<'tcx>>);\n-\n-impl<'tcx, 'lt> TyIVar<'tcx, 'lt> {\n-    #[inline]\n-    pub fn new() -> Self {\n-        // Invariant (A) satisfied because the IVar is unfulfilled\n-        // Invariant (B) because 'lt : 'tcx\n-        TyIVar(ivar::Ivar::new(), PhantomData)\n-    }\n-\n-    #[inline]\n-    pub fn get(&self, dep_node: DepNode<DefId>) -> Option<Ty<'tcx>> {\n-        tls::with(|tcx| tcx.dep_graph.read(dep_node));\n-        self.untracked_get()\n-    }\n-\n-    /// Reads the ivar without registered a dep-graph read. Use with\n-    /// caution.\n-    #[inline]\n-    pub fn untracked_get(&self) -> Option<Ty<'tcx>> {\n-        match self.0.get() {\n-            None => None,\n-            // valid because of invariant (A)\n-            Some(v) => Some(unsafe { &*(*v as *const TyS<'tcx>) })\n-        }\n-    }\n-\n-    #[inline]\n-    pub fn unwrap(&self, dep_node: DepNode<DefId>) -> Ty<'tcx> {\n-        self.get(dep_node).unwrap()\n-    }\n-\n-    pub fn fulfill(&self, dep_node: DepNode<DefId>, value: Ty<'lt>) {\n-        tls::with(|tcx| tcx.dep_graph.write(dep_node));\n-\n-        // Invariant (A) is fulfilled, because by (B), every alias\n-        // of this has a 'tcx longer than 'lt.\n-        let value: *const TyS<'lt> = value;\n-        // FIXME(27214): unneeded [as *const ()]\n-        let value = value as *const () as *const TyS<'static>;\n-        self.0.fulfill(unsafe { NonZero::new(value) })\n-    }\n-}\n-\n-impl<'tcx, 'lt> fmt::Debug for TyIVar<'tcx, 'lt> {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        match self.untracked_get() {\n-            Some(val) => write!(f, \"TyIVar({:?})\", val),\n-            None => f.write_str(\"TyIVar(<unfulfilled>)\")\n-        }\n-    }\n-}"}, {"sha": "42b3544421f8b01362b8efafff7104b6c5571fe2", "filename": "src/librustc/ty/maps.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/07ff914be1c5e0702893191827b0c13308898b45/src%2Flibrustc%2Fty%2Fmaps.rs", "raw_url": "https://github.com/rust-lang/rust/raw/07ff914be1c5e0702893191827b0c13308898b45/src%2Flibrustc%2Fty%2Fmaps.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmaps.rs?ref=07ff914be1c5e0702893191827b0c13308898b45", "patch": "@@ -40,7 +40,8 @@ dep_map_ty! { SuperPredicates: ItemSignature(DefId) -> ty::GenericPredicates<'tc\n dep_map_ty! { AssociatedItemDefIds: AssociatedItemDefIds(DefId) -> Rc<Vec<DefId>> }\n dep_map_ty! { ImplTraitRefs: ItemSignature(DefId) -> Option<ty::TraitRef<'tcx>> }\n dep_map_ty! { TraitDefs: ItemSignature(DefId) -> &'tcx ty::TraitDef }\n-dep_map_ty! { AdtDefs: ItemSignature(DefId) -> ty::AdtDefMaster<'tcx> }\n+dep_map_ty! { AdtDefs: ItemSignature(DefId) -> &'tcx ty::AdtDef }\n+dep_map_ty! { AdtSizedConstraint: SizedConstraint(DefId) -> Ty<'tcx> }\n dep_map_ty! { ItemVariances: ItemSignature(DefId) -> Rc<Vec<ty::Variance>> }\n dep_map_ty! { InherentImpls: InherentImpls(DefId) -> Vec<DefId> }\n dep_map_ty! { ReprHints: ReprHints(DefId) -> Rc<Vec<attr::ReprAttr>> }"}, {"sha": "d63290e388276d0d7356f1af978c96454b9d872e", "filename": "src/librustc/ty/mod.rs", "status": "modified", "additions": 77, "deletions": 165, "changes": 242, "blob_url": "https://github.com/rust-lang/rust/blob/07ff914be1c5e0702893191827b0c13308898b45/src%2Flibrustc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/07ff914be1c5e0702893191827b0c13308898b45/src%2Flibrustc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmod.rs?ref=07ff914be1c5e0702893191827b0c13308898b45", "patch": "@@ -99,7 +99,6 @@ pub mod util;\n mod contents;\n mod context;\n mod flags;\n-mod ivar;\n mod structural_impls;\n mod sty;\n \n@@ -1315,106 +1314,64 @@ bitflags! {\n     }\n }\n \n-pub type AdtDef<'tcx> = &'tcx AdtDefData<'tcx, 'static>;\n-pub type VariantDef<'tcx> = &'tcx VariantDefData<'tcx, 'static>;\n-pub type FieldDef<'tcx> = &'tcx FieldDefData<'tcx, 'static>;\n-\n-// See comment on AdtDefData for explanation\n-pub type AdtDefMaster<'tcx> = &'tcx AdtDefData<'tcx, 'tcx>;\n-pub type VariantDefMaster<'tcx> = &'tcx VariantDefData<'tcx, 'tcx>;\n-pub type FieldDefMaster<'tcx> = &'tcx FieldDefData<'tcx, 'tcx>;\n-\n-pub struct VariantDefData<'tcx, 'container: 'tcx> {\n+pub struct VariantDef {\n     /// The variant's DefId. If this is a tuple-like struct,\n     /// this is the DefId of the struct's ctor.\n     pub did: DefId,\n     pub name: Name, // struct's name if this is a struct\n     pub disr_val: Disr,\n-    pub fields: Vec<FieldDefData<'tcx, 'container>>,\n+    pub fields: Vec<FieldDef>,\n     pub ctor_kind: CtorKind,\n }\n \n-pub struct FieldDefData<'tcx, 'container: 'tcx> {\n+pub struct FieldDef {\n     pub did: DefId,\n     pub name: Name,\n     pub vis: Visibility,\n-    /// TyIVar is used here to allow for variance (see the doc at\n-    /// AdtDefData).\n-    ///\n-    /// Note: direct accesses to `ty` must also add dep edges.\n-    ty: ivar::TyIVar<'tcx, 'container>\n }\n \n /// The definition of an abstract data type - a struct or enum.\n ///\n /// These are all interned (by intern_adt_def) into the adt_defs\n /// table.\n-///\n-/// Because of the possibility of nested tcx-s, this type\n-/// needs 2 lifetimes: the traditional variant lifetime ('tcx)\n-/// bounding the lifetime of the inner types is of course necessary.\n-/// However, it is not sufficient - types from a child tcx must\n-/// not be leaked into the master tcx by being stored in an AdtDefData.\n-///\n-/// The 'container lifetime ensures that by outliving the container\n-/// tcx and preventing shorter-lived types from being inserted. When\n-/// write access is not needed, the 'container lifetime can be\n-/// erased to 'static, which can be done by the AdtDef wrapper.\n-pub struct AdtDefData<'tcx, 'container: 'tcx> {\n+pub struct AdtDef {\n     pub did: DefId,\n-    pub variants: Vec<VariantDefData<'tcx, 'container>>,\n+    pub variants: Vec<VariantDef>,\n     destructor: Cell<Option<DefId>>,\n-    flags: Cell<AdtFlags>,\n-    sized_constraint: ivar::TyIVar<'tcx, 'container>,\n+    flags: Cell<AdtFlags>\n }\n \n-impl<'tcx, 'container> PartialEq for AdtDefData<'tcx, 'container> {\n-    // AdtDefData are always interned and this is part of TyS equality\n+impl PartialEq for AdtDef {\n+    // AdtDef are always interned and this is part of TyS equality\n     #[inline]\n     fn eq(&self, other: &Self) -> bool { self as *const _ == other as *const _ }\n }\n \n-impl<'tcx, 'container> Eq for AdtDefData<'tcx, 'container> {}\n+impl Eq for AdtDef {}\n \n-impl<'tcx, 'container> Hash for AdtDefData<'tcx, 'container> {\n+impl Hash for AdtDef {\n     #[inline]\n     fn hash<H: Hasher>(&self, s: &mut H) {\n-        (self as *const AdtDefData).hash(s)\n+        (self as *const AdtDef).hash(s)\n     }\n }\n \n-impl<'tcx> serialize::UseSpecializedEncodable for AdtDef<'tcx> {\n+impl<'tcx> serialize::UseSpecializedEncodable for &'tcx AdtDef {\n     fn default_encode<S: Encoder>(&self, s: &mut S) -> Result<(), S::Error> {\n         self.did.encode(s)\n     }\n }\n \n-impl<'tcx> serialize::UseSpecializedDecodable for AdtDef<'tcx> {}\n-\n-impl<'a, 'gcx, 'tcx> AdtDefData<'tcx, 'static> {\n-    #[inline]\n-    pub fn is_uninhabited_recurse(&'tcx self,\n-                                  visited: &mut FxHashSet<(DefId, &'tcx Substs<'tcx>)>,\n-                                  block: Option<NodeId>,\n-                                  cx: TyCtxt<'a, 'gcx, 'tcx>,\n-                                  substs: &'tcx Substs<'tcx>) -> bool {\n-        if !visited.insert((self.did, substs)) {\n-            return false;\n-        };\n-        self.variants.iter().all(|v| {\n-            v.is_uninhabited_recurse(visited, block, cx, substs, self.is_union())\n-        })\n-    }\n-}\n+impl<'tcx> serialize::UseSpecializedDecodable for &'tcx AdtDef {}\n \n #[derive(Copy, Clone, Debug, Eq, PartialEq)]\n pub enum AdtKind { Struct, Union, Enum }\n \n-impl<'a, 'gcx, 'tcx, 'container> AdtDefData<'gcx, 'container> {\n+impl<'a, 'gcx, 'tcx> AdtDef {\n     fn new(tcx: TyCtxt<'a, 'gcx, 'tcx>,\n            did: DefId,\n            kind: AdtKind,\n-           variants: Vec<VariantDefData<'gcx, 'container>>) -> Self {\n+           variants: Vec<VariantDef>) -> Self {\n         let mut flags = AdtFlags::NO_ADT_FLAGS;\n         let attrs = tcx.get_attrs(did);\n         if attr::contains_name(&attrs, \"fundamental\") {\n@@ -1431,12 +1388,11 @@ impl<'a, 'gcx, 'tcx, 'container> AdtDefData<'gcx, 'container> {\n             AdtKind::Union => flags = flags | AdtFlags::IS_UNION,\n             AdtKind::Struct => {}\n         }\n-        AdtDefData {\n+        AdtDef {\n             did: did,\n             variants: variants,\n             flags: Cell::new(flags),\n             destructor: Cell::new(None),\n-            sized_constraint: ivar::TyIVar::new(),\n         }\n     }\n \n@@ -1447,6 +1403,20 @@ impl<'a, 'gcx, 'tcx, 'container> AdtDefData<'gcx, 'container> {\n         self.flags.set(self.flags.get() | AdtFlags::IS_DTORCK_VALID)\n     }\n \n+    #[inline]\n+    pub fn is_uninhabited_recurse(&self,\n+                                  visited: &mut FxHashSet<(DefId, &'tcx Substs<'tcx>)>,\n+                                  block: Option<NodeId>,\n+                                  tcx: TyCtxt<'a, 'gcx, 'tcx>,\n+                                  substs: &'tcx Substs<'tcx>) -> bool {\n+        if !visited.insert((self.did, substs)) {\n+            return false;\n+        };\n+        self.variants.iter().all(|v| {\n+            v.is_uninhabited_recurse(visited, block, tcx, substs, self.is_union())\n+        })\n+    }\n+\n     #[inline]\n     pub fn is_struct(&self) -> bool {\n         !self.is_union() && !self.is_enum()\n@@ -1526,7 +1496,7 @@ impl<'a, 'gcx, 'tcx, 'container> AdtDefData<'gcx, 'container> {\n \n     /// Asserts this is a struct and returns the struct's unique\n     /// variant.\n-    pub fn struct_variant(&self) -> &VariantDefData<'gcx, 'container> {\n+    pub fn struct_variant(&self) -> &VariantDef {\n         assert!(!self.is_enum());\n         &self.variants[0]\n     }\n@@ -1539,14 +1509,8 @@ impl<'a, 'gcx, 'tcx, 'container> AdtDefData<'gcx, 'container> {\n     /// Returns an iterator over all fields contained\n     /// by this ADT.\n     #[inline]\n-    pub fn all_fields(&self) ->\n-            iter::FlatMap<\n-                slice::Iter<VariantDefData<'gcx, 'container>>,\n-                slice::Iter<FieldDefData<'gcx, 'container>>,\n-                for<'s> fn(&'s VariantDefData<'gcx, 'container>)\n-                    -> slice::Iter<'s, FieldDefData<'gcx, 'container>>\n-            > {\n-        self.variants.iter().flat_map(VariantDefData::fields_iter)\n+    pub fn all_fields<'s>(&'s self) -> impl Iterator<Item = &'s FieldDef> {\n+        self.variants.iter().flat_map(|v| v.fields.iter())\n     }\n \n     #[inline]\n@@ -1559,7 +1523,7 @@ impl<'a, 'gcx, 'tcx, 'container> AdtDefData<'gcx, 'container> {\n             self.variants.iter().all(|v| v.fields.is_empty())\n     }\n \n-    pub fn variant_with_id(&self, vid: DefId) -> &VariantDefData<'gcx, 'container> {\n+    pub fn variant_with_id(&self, vid: DefId) -> &VariantDef {\n         self.variants\n             .iter()\n             .find(|v| v.did == vid)\n@@ -1573,7 +1537,7 @@ impl<'a, 'gcx, 'tcx, 'container> AdtDefData<'gcx, 'container> {\n             .expect(\"variant_index_with_id: unknown variant\")\n     }\n \n-    pub fn variant_of_def(&self, def: Def) -> &VariantDefData<'gcx, 'container> {\n+    pub fn variant_of_def(&self, def: Def) -> &VariantDef {\n         match def {\n             Def::Variant(vid) | Def::VariantCtor(vid, ..) => self.variant_with_id(vid),\n             Def::Struct(..) | Def::StructCtor(..) | Def::Union(..) |\n@@ -1596,9 +1560,7 @@ impl<'a, 'gcx, 'tcx, 'container> AdtDefData<'gcx, 'container> {\n             None => NoDtor,\n         }\n     }\n-}\n \n-impl<'a, 'gcx, 'tcx, 'container> AdtDefData<'tcx, 'container> {\n     /// Returns a simpler type such that `Self: Sized` if and only\n     /// if that type is Sized, or `TyErr` if this type is recursive.\n     ///\n@@ -1617,19 +1579,9 @@ impl<'a, 'gcx, 'tcx, 'container> AdtDefData<'tcx, 'container> {\n     /// Due to normalization being eager, this applies even if\n     /// the associated type is behind a pointer, e.g. issue #31299.\n     pub fn sized_constraint(&self, tcx: TyCtxt<'a, 'gcx, 'tcx>) -> Ty<'tcx> {\n-        match self.sized_constraint.get(DepNode::SizedConstraint(self.did)) {\n-            None => {\n-                let global_tcx = tcx.global_tcx();\n-                let this = global_tcx.lookup_adt_def_master(self.did);\n-                this.calculate_sized_constraint_inner(global_tcx, &mut Vec::new());\n-                self.sized_constraint(tcx)\n-            }\n-            Some(ty) => ty\n-        }\n+        self.calculate_sized_constraint_inner(tcx.global_tcx(), &mut Vec::new())\n     }\n-}\n \n-impl<'a, 'tcx> AdtDefData<'tcx, 'tcx> {\n     /// Calculates the Sized-constraint.\n     ///\n     /// As the Sized-constraint of enums can be a *set* of types,\n@@ -1645,42 +1597,41 @@ impl<'a, 'tcx> AdtDefData<'tcx, 'tcx> {\n     ///       such.\n     ///     - a TyError, if a type contained itself. The representability\n     ///       check should catch this case.\n-    fn calculate_sized_constraint_inner(&'tcx self,\n+    fn calculate_sized_constraint_inner(&self,\n                                         tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                                        stack: &mut Vec<AdtDefMaster<'tcx>>)\n+                                        stack: &mut Vec<DefId>)\n+                                        -> Ty<'tcx>\n     {\n-        let dep_node = || DepNode::SizedConstraint(self.did);\n+        if let Some(ty) = tcx.adt_sized_constraint.borrow().get(&self.did) {\n+            return ty;\n+        }\n \n         // Follow the memoization pattern: push the computation of\n         // DepNode::SizedConstraint as our current task.\n-        let _task = tcx.dep_graph.in_task(dep_node());\n-        if self.sized_constraint.untracked_get().is_some() {\n-            //                   ---------------\n-            // can skip the dep-graph read since we just pushed the task\n-            return;\n-        }\n+        let _task = tcx.dep_graph.in_task(DepNode::SizedConstraint(self.did));\n \n-        if stack.contains(&self) {\n+        if stack.contains(&self.did) {\n             debug!(\"calculate_sized_constraint: {:?} is recursive\", self);\n             // This should be reported as an error by `check_representable`.\n             //\n             // Consider the type as Sized in the meanwhile to avoid\n             // further errors.\n-            self.sized_constraint.fulfill(dep_node(), tcx.types.err);\n-            return;\n+            tcx.adt_sized_constraint.borrow_mut().insert(self.did, tcx.types.err);\n+            return tcx.types.err;\n         }\n \n-        stack.push(self);\n+        stack.push(self.did);\n \n         let tys : Vec<_> =\n             self.variants.iter().flat_map(|v| {\n                 v.fields.last()\n             }).flat_map(|f| {\n-                self.sized_constraint_for_ty(tcx, stack, f.unsubst_ty())\n+                let ty = tcx.item_type(f.did);\n+                self.sized_constraint_for_ty(tcx, stack, ty)\n             }).collect();\n \n         let self_ = stack.pop().unwrap();\n-        assert_eq!(self_, self);\n+        assert_eq!(self_, self.did);\n \n         let ty = match tys.len() {\n             _ if tys.references_error() => tcx.types.err,\n@@ -1689,24 +1640,26 @@ impl<'a, 'tcx> AdtDefData<'tcx, 'tcx> {\n             _ => tcx.intern_tup(&tys[..])\n         };\n \n-        match self.sized_constraint.get(dep_node()) {\n+        let old = tcx.adt_sized_constraint.borrow().get(&self.did).cloned();\n+        match old {\n             Some(old_ty) => {\n                 debug!(\"calculate_sized_constraint: {:?} recurred\", self);\n-                assert_eq!(old_ty, tcx.types.err)\n+                assert_eq!(old_ty, tcx.types.err);\n+                old_ty\n             }\n             None => {\n                 debug!(\"calculate_sized_constraint: {:?} => {:?}\", self, ty);\n-                self.sized_constraint.fulfill(dep_node(), ty)\n+                tcx.adt_sized_constraint.borrow_mut().insert(self.did, ty);\n+                ty\n             }\n         }\n     }\n \n-    fn sized_constraint_for_ty(\n-        &'tcx self,\n-        tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-        stack: &mut Vec<AdtDefMaster<'tcx>>,\n-        ty: Ty<'tcx>\n-    ) -> Vec<Ty<'tcx>> {\n+    fn sized_constraint_for_ty(&self,\n+                               tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                               stack: &mut Vec<DefId>,\n+                               ty: Ty<'tcx>)\n+                               -> Vec<Ty<'tcx>> {\n         let result = match ty.sty {\n             TyBool | TyChar | TyInt(..) | TyUint(..) | TyFloat(..) |\n             TyBox(..) | TyRawPtr(..) | TyRef(..) | TyFnDef(..) | TyFnPtr(_) |\n@@ -1728,12 +1681,9 @@ impl<'a, 'tcx> AdtDefData<'tcx, 'tcx> {\n \n             TyAdt(adt, substs) => {\n                 // recursive case\n-                let adt = tcx.lookup_adt_def_master(adt.did);\n-                adt.calculate_sized_constraint_inner(tcx, stack);\n                 let adt_ty =\n-                    adt.sized_constraint\n-                    .unwrap(DepNode::SizedConstraint(adt.did))\n-                    .subst(tcx, substs);\n+                    adt.calculate_sized_constraint_inner(tcx, stack)\n+                       .subst(tcx, substs);\n                 debug!(\"sized_constraint_for_ty({:?}) intermediate = {:?}\",\n                        ty, adt_ty);\n                 if let ty::TyTuple(ref tys) = adt_ty.sty {\n@@ -1782,16 +1732,11 @@ impl<'a, 'tcx> AdtDefData<'tcx, 'tcx> {\n     }\n }\n \n-impl<'tcx, 'container> VariantDefData<'tcx, 'container> {\n-    #[inline]\n-    fn fields_iter(&self) -> slice::Iter<FieldDefData<'tcx, 'container>> {\n-        self.fields.iter()\n-    }\n-\n+impl<'a, 'gcx, 'tcx> VariantDef {\n     #[inline]\n     pub fn find_field_named(&self,\n                             name: ast::Name)\n-                            -> Option<&FieldDefData<'tcx, 'container>> {\n+                            -> Option<&FieldDef> {\n         self.fields.iter().find(|f| f.name == name)\n     }\n \n@@ -1803,55 +1748,32 @@ impl<'tcx, 'container> VariantDefData<'tcx, 'container> {\n     }\n \n     #[inline]\n-    pub fn field_named(&self, name: ast::Name) -> &FieldDefData<'tcx, 'container> {\n+    pub fn field_named(&self, name: ast::Name) -> &FieldDef {\n         self.find_field_named(name).unwrap()\n     }\n-}\n \n-impl<'a, 'gcx, 'tcx> VariantDefData<'tcx, 'static> {\n     #[inline]\n-    pub fn is_uninhabited_recurse(&'tcx self,\n+    pub fn is_uninhabited_recurse(&self,\n                                   visited: &mut FxHashSet<(DefId, &'tcx Substs<'tcx>)>,\n                                   block: Option<NodeId>,\n-                                  cx: TyCtxt<'a, 'gcx, 'tcx>,\n+                                  tcx: TyCtxt<'a, 'gcx, 'tcx>,\n                                   substs: &'tcx Substs<'tcx>,\n                                   is_union: bool) -> bool {\n         if is_union {\n-            self.fields.iter().all(|f| f.is_uninhabited_recurse(visited, block, cx, substs))\n+            self.fields.iter().all(|f| f.is_uninhabited_recurse(visited, block, tcx, substs))\n         } else {\n-            self.fields.iter().any(|f| f.is_uninhabited_recurse(visited, block, cx, substs))\n+            self.fields.iter().any(|f| f.is_uninhabited_recurse(visited, block, tcx, substs))\n         }\n     }\n }\n \n-impl<'a, 'gcx, 'tcx, 'container> FieldDefData<'tcx, 'container> {\n-    pub fn new(did: DefId,\n-               name: Name,\n-               vis: Visibility) -> Self {\n-        FieldDefData {\n-            did: did,\n-            name: name,\n-            vis: vis,\n-            ty: ivar::TyIVar::new()\n-        }\n-    }\n-\n+impl<'a, 'gcx, 'tcx> FieldDef {\n     pub fn ty(&self, tcx: TyCtxt<'a, 'gcx, 'tcx>, subst: &Substs<'tcx>) -> Ty<'tcx> {\n-        self.unsubst_ty().subst(tcx, subst)\n-    }\n-\n-    pub fn unsubst_ty(&self) -> Ty<'tcx> {\n-        self.ty.unwrap(DepNode::FieldTy(self.did))\n-    }\n-\n-    pub fn fulfill_ty(&self, ty: Ty<'container>) {\n-        self.ty.fulfill(DepNode::FieldTy(self.did), ty);\n+        tcx.item_type(self.did).subst(tcx, subst)\n     }\n-}\n \n-impl<'a, 'gcx, 'tcx> FieldDefData<'tcx, 'static> {\n     #[inline]\n-    pub fn is_uninhabited_recurse(&'tcx self,\n+    pub fn is_uninhabited_recurse(&self,\n                                   visited: &mut FxHashSet<(DefId, &'tcx Substs<'tcx>)>,\n                                   block: Option<NodeId>,\n                                   tcx: TyCtxt<'a, 'gcx, 'tcx>,\n@@ -2301,7 +2223,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n \n     // Returns `ty::VariantDef` if `def` refers to a struct,\n     // or variant or their constructors, panics otherwise.\n-    pub fn expect_variant_def(self, def: Def) -> VariantDef<'tcx> {\n+    pub fn expect_variant_def(self, def: Def) -> &'tcx VariantDef {\n         match def {\n             Def::Variant(did) | Def::VariantCtor(did, ..) => {\n                 let enum_did = self.parent_def_id(did).unwrap();\n@@ -2403,21 +2325,11 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n         )\n     }\n \n-    /// Given the did of an ADT, return a master reference to its\n-    /// definition. Unless you are planning on fulfilling the ADT's fields,\n-    /// use lookup_adt_def instead.\n-    pub fn lookup_adt_def_master(self, did: DefId) -> AdtDefMaster<'gcx> {\n+    /// Given the did of an ADT, return a reference to its definition.\n+    pub fn lookup_adt_def(self, did: DefId) -> &'gcx AdtDef {\n         lookup_locally_or_in_crate_store(\n             \"adt_defs\", did, &self.adt_defs,\n-            || self.sess.cstore.adt_def(self.global_tcx(), did)\n-        )\n-    }\n-\n-    /// Given the did of an ADT, return a reference to its definition.\n-    pub fn lookup_adt_def(self, did: DefId) -> AdtDef<'gcx> {\n-        // when reverse-variance goes away, a transmute::<AdtDefMaster,AdtDef>\n-        // would be needed here.\n-        self.lookup_adt_def_master(did)\n+            || self.sess.cstore.adt_def(self.global_tcx(), did))\n     }\n \n     /// Given the did of an item, returns its generics."}, {"sha": "bd857f814d534c3f42909888d0a01d706ba29611", "filename": "src/librustc/ty/sty.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/07ff914be1c5e0702893191827b0c13308898b45/src%2Flibrustc%2Fty%2Fsty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/07ff914be1c5e0702893191827b0c13308898b45/src%2Flibrustc%2Fty%2Fsty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fsty.rs?ref=07ff914be1c5e0702893191827b0c13308898b45", "patch": "@@ -113,7 +113,7 @@ pub enum TypeVariants<'tcx> {\n     /// That is, even after substitution it is possible that there are type\n     /// variables. This happens when the `TyAdt` corresponds to an ADT\n     /// definition and not a concrete use of it.\n-    TyAdt(AdtDef<'tcx>, &'tcx Substs<'tcx>),\n+    TyAdt(&'tcx AdtDef, &'tcx Substs<'tcx>),\n \n     /// `Box<T>`; this is nominally a struct in the documentation, but is\n     /// special-cased internally. For example, it is possible to implicitly\n@@ -1228,7 +1228,7 @@ impl<'a, 'gcx, 'tcx> TyS<'tcx> {\n         }\n     }\n \n-    pub fn ty_adt_def(&self) -> Option<AdtDef<'tcx>> {\n+    pub fn ty_adt_def(&self) -> Option<&'tcx AdtDef> {\n         match self.sty {\n             TyAdt(adt, _) => Some(adt),\n             _ => None"}, {"sha": "bf8d49d981d242a4a33e91660a2454c24e663052", "filename": "src/librustc/ty/util.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/07ff914be1c5e0702893191827b0c13308898b45/src%2Flibrustc%2Fty%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/07ff914be1c5e0702893191827b0c13308898b45/src%2Flibrustc%2Fty%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Futil.rs?ref=07ff914be1c5e0702893191827b0c13308898b45", "patch": "@@ -365,7 +365,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n     /// `adt` that do not strictly outlive the adt value itself.\n     /// (This allows programs to make cyclic structures without\n     /// resorting to unasfe means; see RFCs 769 and 1238).\n-    pub fn is_adt_dtorck(self, adt: ty::AdtDef) -> bool {\n+    pub fn is_adt_dtorck(self, adt: &ty::AdtDef) -> bool {\n         let dtor_method = match adt.destructor() {\n             Some(dtor) => dtor,\n             None => return false\n@@ -767,7 +767,7 @@ impl<'a, 'tcx> ty::TyS<'tcx> {\n             }\n         }\n \n-        fn same_struct_or_enum<'tcx>(ty: Ty<'tcx>, def: ty::AdtDef<'tcx>) -> bool {\n+        fn same_struct_or_enum<'tcx>(ty: Ty<'tcx>, def: &'tcx ty::AdtDef) -> bool {\n             match ty.sty {\n                 TyAdt(ty_def, _) => {\n                      ty_def == def"}, {"sha": "57096c2b1e040f37eba0611a3153d929ab0a3699", "filename": "src/librustc/util/ppaux.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/07ff914be1c5e0702893191827b0c13308898b45/src%2Flibrustc%2Futil%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/07ff914be1c5e0702893191827b0c13308898b45/src%2Flibrustc%2Futil%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fppaux.rs?ref=07ff914be1c5e0702893191827b0c13308898b45", "patch": "@@ -440,7 +440,7 @@ impl fmt::Debug for ty::TraitDef {\n     }\n }\n \n-impl<'tcx, 'container> fmt::Debug for ty::AdtDefData<'tcx, 'container> {\n+impl fmt::Debug for ty::AdtDef {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         ty::tls::with(|tcx| {\n             write!(f, \"{}\", tcx.item_path_str(self.did))"}, {"sha": "c073141b914512db97ddac0d1897685ac4b9930d", "filename": "src/librustc_borrowck/borrowck/mir/elaborate_drops.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/07ff914be1c5e0702893191827b0c13308898b45/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Felaborate_drops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/07ff914be1c5e0702893191827b0c13308898b45/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Felaborate_drops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Felaborate_drops.rs?ref=07ff914be1c5e0702893191827b0c13308898b45", "patch": "@@ -442,7 +442,7 @@ impl<'b, 'tcx> ElaborateDropsCtxt<'b, 'tcx> {\n     fn move_paths_for_fields(&self,\n                              base_lv: &Lvalue<'tcx>,\n                              variant_path: MovePathIndex,\n-                             variant: ty::VariantDef<'tcx>,\n+                             variant: &'tcx ty::VariantDef,\n                              substs: &'tcx Substs<'tcx>)\n                              -> Vec<(Lvalue<'tcx>, Option<MovePathIndex>)>\n     {\n@@ -619,7 +619,7 @@ impl<'b, 'tcx> ElaborateDropsCtxt<'b, 'tcx> {\n     fn open_drop_for_variant<'a>(&mut self,\n                                  c: &DropCtxt<'a, 'tcx>,\n                                  drop_block: &mut Option<BasicBlock>,\n-                                 adt: ty::AdtDef<'tcx>,\n+                                 adt: &'tcx ty::AdtDef,\n                                  substs: &'tcx Substs<'tcx>,\n                                  variant_index: usize)\n                                  -> BasicBlock\n@@ -652,7 +652,7 @@ impl<'b, 'tcx> ElaborateDropsCtxt<'b, 'tcx> {\n     }\n \n     fn open_drop_for_adt<'a>(&mut self, c: &DropCtxt<'a, 'tcx>,\n-                             adt: ty::AdtDef<'tcx>, substs: &'tcx Substs<'tcx>)\n+                             adt: &'tcx ty::AdtDef, substs: &'tcx Substs<'tcx>)\n                              -> BasicBlock {\n         debug!(\"open_drop_for_adt({:?}, {:?}, {:?})\", c, adt, substs);\n "}, {"sha": "23771f4bae3dc109cb81e6b0383443c421f344ba", "filename": "src/librustc_const_eval/_match.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/07ff914be1c5e0702893191827b0c13308898b45/src%2Flibrustc_const_eval%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/07ff914be1c5e0702893191827b0c13308898b45/src%2Flibrustc_const_eval%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_const_eval%2F_match.rs?ref=07ff914be1c5e0702893191827b0c13308898b45", "patch": "@@ -223,10 +223,8 @@ pub enum Constructor {\n     Slice(usize),\n }\n \n-impl Constructor {\n-    fn variant_for_adt<'tcx, 'container, 'a>(&self,\n-                                             adt: &'a ty::AdtDefData<'tcx, 'container>)\n-                                             -> &'a ty::VariantDefData<'tcx, 'container> {\n+impl<'tcx> Constructor {\n+    fn variant_for_adt(&self, adt: &'tcx ty::AdtDef) -> &'tcx ty::VariantDef {\n         match self {\n             &Variant(vid) => adt.variant_with_id(vid),\n             &Single => {"}, {"sha": "e93178c89c22b865b20cc054b73883b806c4ea19", "filename": "src/librustc_const_eval/pattern.rs", "status": "modified", "additions": 10, "deletions": 20, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/07ff914be1c5e0702893191827b0c13308898b45/src%2Flibrustc_const_eval%2Fpattern.rs", "raw_url": "https://github.com/rust-lang/rust/raw/07ff914be1c5e0702893191827b0c13308898b45/src%2Flibrustc_const_eval%2Fpattern.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_const_eval%2Fpattern.rs?ref=07ff914be1c5e0702893191827b0c13308898b45", "patch": "@@ -66,7 +66,7 @@ pub enum PatternKind<'tcx> {\n \n     /// Foo(...) or Foo{...} or Foo, where `Foo` is a variant name from an adt with >1 variants\n     Variant {\n-        adt_def: AdtDef<'tcx>,\n+        adt_def: &'tcx AdtDef,\n         variant_index: usize,\n         subpatterns: Vec<FieldPattern<'tcx>>,\n     },\n@@ -487,32 +487,22 @@ impl<'tcx, T: PatternFoldable<'tcx>> PatternFoldable<'tcx> for Option<T> {\n     }\n }\n \n-macro_rules! CopyImpls {\n-    ($($ty:ty),+) => {\n+macro_rules! CloneImpls {\n+    (<$lt_tcx:tt> $($ty:ty),+) => {\n         $(\n-            impl<'tcx> PatternFoldable<'tcx> for $ty {\n-                fn super_fold_with<F: PatternFolder<'tcx>>(&self, _: &mut F) -> Self {\n-                    self.clone()\n-                }\n-            }\n-            )+\n-    }\n-}\n-\n-macro_rules! TcxCopyImpls {\n-    ($($ty:ident),+) => {\n-        $(\n-            impl<'tcx> PatternFoldable<'tcx> for $ty<'tcx> {\n-                fn super_fold_with<F: PatternFolder<'tcx>>(&self, _: &mut F) -> Self {\n-                    *self\n+            impl<$lt_tcx> PatternFoldable<$lt_tcx> for $ty {\n+                fn super_fold_with<F: PatternFolder<$lt_tcx>>(&self, _: &mut F) -> Self {\n+                    Clone::clone(self)\n                 }\n             }\n         )+\n     }\n }\n \n-CopyImpls!{ Span, Field, Mutability, ast::Name, ast::NodeId, usize, ConstVal }\n-TcxCopyImpls!{ Ty, BindingMode, AdtDef }\n+CloneImpls!{ <'tcx>\n+    Span, Field, Mutability, ast::Name, ast::NodeId, usize, ConstVal,\n+    Ty<'tcx>, BindingMode<'tcx>, &'tcx AdtDef\n+}\n \n impl<'tcx> PatternFoldable<'tcx> for FieldPattern<'tcx> {\n     fn super_fold_with<F: PatternFolder<'tcx>>(&self, folder: &mut F) -> Self {"}, {"sha": "1a6b5f06f6dda031443e9dccf87dd2c28cc3b9ff", "filename": "src/librustc_lint/types.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/07ff914be1c5e0702893191827b0c13308898b45/src%2Flibrustc_lint%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/07ff914be1c5e0702893191827b0c13308898b45/src%2Flibrustc_lint%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Ftypes.rs?ref=07ff914be1c5e0702893191827b0c13308898b45", "patch": "@@ -396,7 +396,7 @@ enum FfiResult {\n /// expanded to cover NonZero raw pointers and newtypes.\n /// FIXME: This duplicates code in trans.\n fn is_repr_nullable_ptr<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                                  def: ty::AdtDef<'tcx>,\n+                                  def: &'tcx ty::AdtDef,\n                                   substs: &Substs<'tcx>)\n                                   -> bool {\n     if def.variants.len() == 2 {"}, {"sha": "1c23932e8b707d10b61e8efd4dd3d03d3c2574a2", "filename": "src/librustc_metadata/cstore_impl.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/07ff914be1c5e0702893191827b0c13308898b45/src%2Flibrustc_metadata%2Fcstore_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/07ff914be1c5e0702893191827b0c13308898b45/src%2Flibrustc_metadata%2Fcstore_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fcstore_impl.rs?ref=07ff914be1c5e0702893191827b0c13308898b45", "patch": "@@ -116,7 +116,7 @@ impl<'tcx> CrateStore<'tcx> for cstore::CStore {\n         self.get_crate_data(def.krate).get_trait_def(def.index, tcx)\n     }\n \n-    fn adt_def<'a>(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>, def: DefId) -> ty::AdtDefMaster<'tcx>\n+    fn adt_def<'a>(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>, def: DefId) -> &'tcx ty::AdtDef\n     {\n         self.dep_graph.read(DepNode::MetaData(def));\n         self.get_crate_data(def.krate).get_adt_def(def.index, tcx)"}, {"sha": "89c15986bae8e3c5eb6b4b45877ae0af22c3dbc9", "filename": "src/librustc_metadata/decoder.rs", "status": "modified", "additions": 19, "deletions": 37, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/07ff914be1c5e0702893191827b0c13308898b45/src%2Flibrustc_metadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/07ff914be1c5e0702893191827b0c13308898b45/src%2Flibrustc_metadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fdecoder.rs?ref=07ff914be1c5e0702893191827b0c13308898b45", "patch": "@@ -409,8 +409,8 @@ impl<'a, 'tcx> SpecializedDecoder<&'tcx ty::BareFnTy<'tcx>> for DecodeContext<'a\n     }\n }\n \n-impl<'a, 'tcx> SpecializedDecoder<ty::AdtDef<'tcx>> for DecodeContext<'a, 'tcx> {\n-    fn specialized_decode(&mut self) -> Result<ty::AdtDef<'tcx>, Self::Error> {\n+impl<'a, 'tcx> SpecializedDecoder<&'tcx ty::AdtDef> for DecodeContext<'a, 'tcx> {\n+    fn specialized_decode(&mut self) -> Result<&'tcx ty::AdtDef, Self::Error> {\n         let def_id = DefId::decode(self)?;\n         Ok(self.tcx().lookup_adt_def(def_id))\n     }\n@@ -546,36 +546,34 @@ impl<'a, 'tcx> CrateMetadata {\n     fn get_variant(&self,\n                    item: &Entry<'tcx>,\n                    index: DefIndex)\n-                   -> (ty::VariantDefData<'tcx, 'tcx>, Option<DefIndex>) {\n+                   -> (ty::VariantDef, Option<DefIndex>) {\n         let data = match item.kind {\n             EntryKind::Variant(data) |\n             EntryKind::Struct(data) |\n             EntryKind::Union(data) => data.decode(self),\n             _ => bug!(),\n         };\n \n-        let fields = item.children\n-            .decode(self)\n-            .map(|index| {\n+        (ty::VariantDef {\n+            did: self.local_def_id(data.struct_ctor.unwrap_or(index)),\n+            name: self.item_name(item),\n+            fields: item.children.decode(self).map(|index| {\n                 let f = self.entry(index);\n-                ty::FieldDefData::new(self.local_def_id(index), self.item_name(&f), f.visibility)\n-            })\n-            .collect();\n-\n-        (ty::VariantDefData {\n-             did: self.local_def_id(data.struct_ctor.unwrap_or(index)),\n-             name: self.item_name(item),\n-             fields: fields,\n-             disr_val: ConstInt::Infer(data.disr),\n-             ctor_kind: data.ctor_kind,\n-         },\n-         data.struct_ctor)\n+                ty::FieldDef {\n+                    did: self.local_def_id(index),\n+                    name: self.item_name(&f),\n+                    vis: f.visibility\n+                }\n+            }).collect(),\n+            disr_val: ConstInt::Infer(data.disr),\n+            ctor_kind: data.ctor_kind,\n+        }, data.struct_ctor)\n     }\n \n     pub fn get_adt_def(&self,\n                        item_id: DefIndex,\n                        tcx: TyCtxt<'a, 'tcx, 'tcx>)\n-                       -> ty::AdtDefMaster<'tcx> {\n+                       -> &'tcx ty::AdtDef {\n         let item = self.entry(item_id);\n         let did = self.local_def_id(item_id);\n         let mut ctor_index = None;\n@@ -600,26 +598,10 @@ impl<'a, 'tcx> CrateMetadata {\n             _ => bug!(\"get_adt_def called on a non-ADT {:?}\", did),\n         };\n \n-        let adt = tcx.intern_adt_def(did, kind, variants);\n+        let adt = tcx.alloc_adt_def(did, kind, variants);\n         if let Some(ctor_index) = ctor_index {\n             // Make adt definition available through constructor id as well.\n-            tcx.insert_adt_def(self.local_def_id(ctor_index), adt);\n-        }\n-\n-        // this needs to be done *after* the variant is interned,\n-        // to support recursive structures\n-        for variant in &adt.variants {\n-            for field in &variant.fields {\n-                debug!(\"evaluating the type of {:?}::{:?}\",\n-                       variant.name,\n-                       field.name);\n-                let ty = self.get_type(field.did.index, tcx);\n-                field.fulfill_ty(ty);\n-                debug!(\"evaluating the type of {:?}::{:?}: {:?}\",\n-                       variant.name,\n-                       field.name,\n-                       ty);\n-            }\n+            tcx.adt_defs.borrow_mut().insert(self.local_def_id(ctor_index), adt);\n         }\n \n         adt"}, {"sha": "e06d940de7e58238713e82d98a13846ae6ccb87f", "filename": "src/librustc_mir/build/matches/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/07ff914be1c5e0702893191827b0c13308898b45/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/07ff914be1c5e0702893191827b0c13308898b45/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fmod.rs?ref=07ff914be1c5e0702893191827b0c13308898b45", "patch": "@@ -301,7 +301,7 @@ pub struct MatchPair<'pat, 'tcx:'pat> {\n enum TestKind<'tcx> {\n     // test the branches of enum\n     Switch {\n-        adt_def: AdtDef<'tcx>,\n+        adt_def: &'tcx AdtDef,\n         variants: BitVector,\n     },\n "}, {"sha": "cb449037aeba3eb9f610ec8ae32c8c095fd29b3c", "filename": "src/librustc_mir/build/matches/test.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/07ff914be1c5e0702893191827b0c13308898b45/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/07ff914be1c5e0702893191827b0c13308898b45/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Ftest.rs?ref=07ff914be1c5e0702893191827b0c13308898b45", "patch": "@@ -615,7 +615,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n \n     fn candidate_after_variant_switch<'pat>(&mut self,\n                                             match_pair_index: usize,\n-                                            adt_def: ty::AdtDef<'tcx>,\n+                                            adt_def: &'tcx ty::AdtDef,\n                                             variant_index: usize,\n                                             subpatterns: &'pat [FieldPattern<'tcx>],\n                                             candidate: &Candidate<'pat, 'tcx>)"}, {"sha": "e850f6c4b045cab7a9fcbdfa6d2921dc293dba0a", "filename": "src/librustc_mir/hair/cx/expr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/07ff914be1c5e0702893191827b0c13308898b45/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/07ff914be1c5e0702893191827b0c13308898b45/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs?ref=07ff914be1c5e0702893191827b0c13308898b45", "patch": "@@ -1003,7 +1003,7 @@ fn capture_freevar<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n }\n \n /// Converts a list of named fields (i.e. for struct-like struct/enum ADTs) into FieldExprRef.\n-fn field_refs<'tcx>(variant: VariantDef<'tcx>,\n+fn field_refs<'tcx>(variant: &'tcx VariantDef,\n                     fields: &'tcx [hir::Field])\n                     -> Vec<FieldExprRef<'tcx>>\n {"}, {"sha": "e7a6b40c830bdf4fbaf8be7ac228692b68ff67c2", "filename": "src/librustc_mir/hair/cx/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/07ff914be1c5e0702893191827b0c13308898b45/src%2Flibrustc_mir%2Fhair%2Fcx%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/07ff914be1c5e0702893191827b0c13308898b45/src%2Flibrustc_mir%2Fhair%2Fcx%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fcx%2Fmod.rs?ref=07ff914be1c5e0702893191827b0c13308898b45", "patch": "@@ -155,11 +155,11 @@ impl<'a, 'gcx, 'tcx> Cx<'a, 'gcx, 'tcx> {\n         bug!(\"found no method `{}` in `{:?}`\", method_name, trait_def_id);\n     }\n \n-    pub fn num_variants(&mut self, adt_def: ty::AdtDef) -> usize {\n+    pub fn num_variants(&mut self, adt_def: &ty::AdtDef) -> usize {\n         adt_def.variants.len()\n     }\n \n-    pub fn all_fields(&mut self, adt_def: ty::AdtDef, variant_index: usize) -> Vec<Field> {\n+    pub fn all_fields(&mut self, adt_def: &ty::AdtDef, variant_index: usize) -> Vec<Field> {\n         (0..adt_def.variants[variant_index].fields.len())\n             .map(Field::new)\n             .collect()"}, {"sha": "22c07f1903bacf4fbba9fef9c00ee6db88b4386e", "filename": "src/librustc_mir/hair/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/07ff914be1c5e0702893191827b0c13308898b45/src%2Flibrustc_mir%2Fhair%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/07ff914be1c5e0702893191827b0c13308898b45/src%2Flibrustc_mir%2Fhair%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fmod.rs?ref=07ff914be1c5e0702893191827b0c13308898b45", "patch": "@@ -221,7 +221,7 @@ pub enum ExprKind<'tcx> {\n         fields: Vec<ExprRef<'tcx>>,\n     },\n     Adt {\n-        adt_def: AdtDef<'tcx>,\n+        adt_def: &'tcx AdtDef,\n         variant_index: usize,\n         substs: &'tcx Substs<'tcx>,\n         fields: Vec<FieldExprRef<'tcx>>,"}, {"sha": "340d51093376c685e3eaba1de14811eac47adfdd", "filename": "src/librustc_privacy/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/07ff914be1c5e0702893191827b0c13308898b45/src%2Flibrustc_privacy%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/07ff914be1c5e0702893191827b0c13308898b45/src%2Flibrustc_privacy%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_privacy%2Flib.rs?ref=07ff914be1c5e0702893191827b0c13308898b45", "patch": "@@ -405,7 +405,7 @@ impl<'a, 'tcx> PrivacyVisitor<'a, 'tcx> {\n     }\n \n     // Checks that a field is in scope.\n-    fn check_field(&mut self, span: Span, def: ty::AdtDef<'tcx>, field: ty::FieldDef<'tcx>) {\n+    fn check_field(&mut self, span: Span, def: &'tcx ty::AdtDef, field: &'tcx ty::FieldDef) {\n         if !def.is_enum() && !field.vis.is_accessible_from(self.curitem, &self.tcx.map) {\n             struct_span_err!(self.tcx.sess, span, E0451, \"field `{}` of {} `{}` is private\",\n                       field.name, def.variant_descr(), self.tcx.item_path_str(def.did))"}, {"sha": "4cd28e0a46daf4b6f1752a37360c1aea85bead19", "filename": "src/librustc_save_analysis/dump_visitor.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/07ff914be1c5e0702893191827b0c13308898b45/src%2Flibrustc_save_analysis%2Fdump_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/07ff914be1c5e0702893191827b0c13308898b45/src%2Flibrustc_save_analysis%2Fdump_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_save_analysis%2Fdump_visitor.rs?ref=07ff914be1c5e0702893191827b0c13308898b45", "patch": "@@ -941,7 +941,7 @@ impl<'l, 'tcx: 'l, 'll, D: Dump + 'll> DumpVisitor<'l, 'tcx, 'll, D> {\n                           ex: &ast::Expr,\n                           path: &ast::Path,\n                           fields: &Vec<ast::Field>,\n-                          variant: ty::VariantDef,\n+                          variant: &ty::VariantDef,\n                           base: &Option<P<ast::Expr>>) {\n         self.write_sub_paths_truncated(path, false);\n "}, {"sha": "8a552335680a12207e3fe91cde874d369ea66271", "filename": "src/librustc_save_analysis/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/07ff914be1c5e0702893191827b0c13308898b45/src%2Flibrustc_save_analysis%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/07ff914be1c5e0702893191827b0c13308898b45/src%2Flibrustc_save_analysis%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_save_analysis%2Flib.rs?ref=07ff914be1c5e0702893191827b0c13308898b45", "patch": "@@ -622,7 +622,7 @@ impl<'l, 'tcx: 'l> SaveContext<'l, 'tcx> {\n \n     pub fn get_field_ref_data(&self,\n                               field_ref: &ast::Field,\n-                              variant: ty::VariantDef,\n+                              variant: &ty::VariantDef,\n                               parent: NodeId)\n                               -> Option<VariableRefData> {\n         let f = variant.field_named(field_ref.ident.node.name);"}, {"sha": "04bc0533254bc768215dd34db62a8cf60838768d", "filename": "src/librustc_trans/collector.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/07ff914be1c5e0702893191827b0c13308898b45/src%2Flibrustc_trans%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/07ff914be1c5e0702893191827b0c13308898b45/src%2Flibrustc_trans%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcollector.rs?ref=07ff914be1c5e0702893191827b0c13308898b45", "patch": "@@ -768,9 +768,10 @@ fn find_drop_glue_neighbors<'a, 'tcx>(scx: &SharedCrateContext<'a, 'tcx>,\n         }\n         ty::TyAdt(adt_def, substs) => {\n             for field in adt_def.all_fields() {\n+                let field_type = scx.tcx().item_type(field.did);\n                 let field_type = monomorphize::apply_param_substs(scx,\n                                                                   substs,\n-                                                                  &field.unsubst_ty());\n+                                                                  &field_type);\n                 let field_type = glue::get_drop_glue_type(scx.tcx(), field_type);\n \n                 if glue::type_needs_drop(scx.tcx(), field_type) {"}, {"sha": "477fd0e7f0bb6f2df7416d6701a650133a8351f3", "filename": "src/librustc_trans/debuginfo/metadata.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/07ff914be1c5e0702893191827b0c13308898b45/src%2Flibrustc_trans%2Fdebuginfo%2Fmetadata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/07ff914be1c5e0702893191827b0c13308898b45/src%2Flibrustc_trans%2Fdebuginfo%2Fmetadata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fdebuginfo%2Fmetadata.rs?ref=07ff914be1c5e0702893191827b0c13308898b45", "patch": "@@ -879,7 +879,7 @@ impl<'tcx> MemberDescriptionFactory<'tcx> {\n \n // Creates MemberDescriptions for the fields of a struct\n struct StructMemberDescriptionFactory<'tcx> {\n-    variant: ty::VariantDef<'tcx>,\n+    variant: &'tcx ty::VariantDef,\n     substs: &'tcx Substs<'tcx>,\n     is_simd: bool,\n     span: Span,\n@@ -1021,7 +1021,7 @@ fn prepare_tuple_metadata<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n //=-----------------------------------------------------------------------------\n \n struct UnionMemberDescriptionFactory<'tcx> {\n-    variant: ty::VariantDef<'tcx>,\n+    variant: &'tcx ty::VariantDef,\n     substs: &'tcx Substs<'tcx>,\n     span: Span,\n }\n@@ -1335,7 +1335,7 @@ enum EnumDiscriminantInfo {\n fn describe_enum_variant<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n                                    enum_type: Ty<'tcx>,\n                                    struct_def: &layout::Struct,\n-                                   variant: ty::VariantDef<'tcx>,\n+                                   variant: &'tcx ty::VariantDef,\n                                    discriminant_info: EnumDiscriminantInfo,\n                                    containing_scope: DIScope,\n                                    span: Span)\n@@ -1354,7 +1354,7 @@ fn describe_enum_variant<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n         ref l @ _ => bug!(\"This should be unreachable. Type is {:#?} layout is {:#?}\", enum_type, l)\n     };\n \n-    let mut field_tys = variant.fields.iter().map(|f: ty::FieldDef<'tcx>| {\n+    let mut field_tys = variant.fields.iter().map(|f| {\n         monomorphize::field_ty(cx.tcx(), &substs, f)\n     }).collect::<Vec<_>>();\n "}, {"sha": "e5395c4b3d5bd2bafcf1b42085c2ce56d6d307bd", "filename": "src/librustc_trans/glue.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/07ff914be1c5e0702893191827b0c13308898b45/src%2Flibrustc_trans%2Fglue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/07ff914be1c5e0702893191827b0c13308898b45/src%2Flibrustc_trans%2Fglue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fglue.rs?ref=07ff914be1c5e0702893191827b0c13308898b45", "patch": "@@ -504,7 +504,7 @@ fn drop_structural_ty<'blk, 'tcx>(cx: Block<'blk, 'tcx>,\n     fn iter_variant<'blk, 'tcx>(cx: Block<'blk, 'tcx>,\n                                 t: Ty<'tcx>,\n                                 av: adt::MaybeSizedValue,\n-                                variant: ty::VariantDef<'tcx>,\n+                                variant: &'tcx ty::VariantDef,\n                                 substs: &Substs<'tcx>)\n                                 -> Block<'blk, 'tcx> {\n         let _icx = push_ctxt(\"iter_variant\");"}, {"sha": "8f05cc793ef224f73b35f4eed64d3273b706874d", "filename": "src/librustc_trans/monomorphize.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/07ff914be1c5e0702893191827b0c13308898b45/src%2Flibrustc_trans%2Fmonomorphize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/07ff914be1c5e0702893191827b0c13308898b45/src%2Flibrustc_trans%2Fmonomorphize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmonomorphize.rs?ref=07ff914be1c5e0702893191827b0c13308898b45", "patch": "@@ -60,7 +60,7 @@ pub fn apply_param_substs<'a, 'tcx, T>(scx: &SharedCrateContext<'a, 'tcx>,\n /// Returns the normalized type of a struct field\n pub fn field_ty<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                           param_substs: &Substs<'tcx>,\n-                          f: ty::FieldDef<'tcx>)\n+                          f: &'tcx ty::FieldDef)\n                           -> Ty<'tcx>\n {\n     tcx.normalize_associated_type(&f.ty(tcx, param_substs))"}, {"sha": "92f7921a4bd7e61f8ced48615d843204fc416c48", "filename": "src/librustc_typeck/check/_match.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/07ff914be1c5e0702893191827b0c13308898b45/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/07ff914be1c5e0702893191827b0c13308898b45/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2F_match.rs?ref=07ff914be1c5e0702893191827b0c13308898b45", "patch": "@@ -626,7 +626,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                                adt_ty: Ty<'tcx>,\n                                pat_id: ast::NodeId,\n                                span: Span,\n-                               variant: ty::VariantDef<'tcx>,\n+                               variant: &'tcx ty::VariantDef,\n                                fields: &'gcx [Spanned<hir::FieldPat>],\n                                etc: bool) {\n         let tcx = self.tcx;"}, {"sha": "f4507054200b67d0d6a40d170a84a95cdedb4a98", "filename": "src/librustc_typeck/check/dropck.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/07ff914be1c5e0702893191827b0c13308898b45/src%2Flibrustc_typeck%2Fcheck%2Fdropck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/07ff914be1c5e0702893191827b0c13308898b45/src%2Flibrustc_typeck%2Fcheck%2Fdropck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fdropck.rs?ref=07ff914be1c5e0702893191827b0c13308898b45", "patch": "@@ -589,7 +589,7 @@ fn has_dtor_of_interest<'a, 'gcx, 'tcx>(tcx: TyCtxt<'a, 'gcx, 'tcx>,\n //\n // then revises input: `Foo<'r,i64,&'r i64>` to: `Foo<'static,i64,()>`\n fn revise_self_ty<'a, 'gcx, 'tcx>(tcx: TyCtxt<'a, 'gcx, 'tcx>,\n-                                  adt_def: ty::AdtDef<'tcx>,\n+                                  adt_def: &'tcx ty::AdtDef,\n                                   impl_def_id: DefId,\n                                   substs: &Substs<'tcx>)\n                                   -> Ty<'tcx> {"}, {"sha": "7535a25d769d32dfa7b9315726156a9fad607bb6", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/07ff914be1c5e0702893191827b0c13308898b45/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/07ff914be1c5e0702893191827b0c13308898b45/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=07ff914be1c5e0702893191827b0c13308898b45", "patch": "@@ -1985,7 +1985,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n     // Indifferent to privacy flags\n     pub fn field_ty(&self,\n                     span: Span,\n-                    field: ty::FieldDef<'tcx>,\n+                    field: &'tcx ty::FieldDef,\n                     substs: &Substs<'tcx>)\n                     -> Ty<'tcx>\n     {\n@@ -3071,7 +3071,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n     }\n \n     // Return an hint about the closest match in field names\n-    fn suggest_field_name(variant: ty::VariantDef<'tcx>,\n+    fn suggest_field_name(variant: &'tcx ty::VariantDef,\n                           field: &Spanned<ast::Name>,\n                           skip : Vec<InternedString>)\n                           -> Option<Symbol> {\n@@ -3164,7 +3164,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n \n     fn report_unknown_field(&self,\n                             ty: Ty<'tcx>,\n-                            variant: ty::VariantDef<'tcx>,\n+                            variant: &'tcx ty::VariantDef,\n                             field: &hir::Field,\n                             skip_fields: &[hir::Field],\n                             kind_name: &str) {\n@@ -3208,7 +3208,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                                 adt_ty: Ty<'tcx>,\n                                 expr_id: ast::NodeId,\n                                 span: Span,\n-                                variant: ty::VariantDef<'tcx>,\n+                                variant: &'tcx ty::VariantDef,\n                                 ast_fields: &'gcx [hir::Field],\n                                 check_completeness: bool) {\n         let tcx = self.tcx;\n@@ -3324,7 +3324,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n     pub fn check_struct_path(&self,\n                              qpath: &hir::QPath,\n                              node_id: ast::NodeId)\n-                             -> Option<(ty::VariantDef<'tcx>,  Ty<'tcx>)> {\n+                             -> Option<(&'tcx ty::VariantDef,  Ty<'tcx>)> {\n         let path_span = match *qpath {\n             hir::QPath::Resolved(_, ref path) => path.span,\n             hir::QPath::TypeRelative(ref qself, _) => qself.span"}, {"sha": "e18a4aefd9052623f597e51329f178d46eeb6500", "filename": "src/librustc_typeck/coherence/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/07ff914be1c5e0702893191827b0c13308898b45/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/07ff914be1c5e0702893191827b0c13308898b45/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs?ref=07ff914be1c5e0702893191827b0c13308898b45", "patch": "@@ -395,7 +395,7 @@ impl<'a, 'gcx, 'tcx> CoherenceChecker<'a, 'gcx, 'tcx> {\n                             .filter_map(|(i, f)| {\n                                 let (a, b) = (f.ty(tcx, substs_a), f.ty(tcx, substs_b));\n \n-                                if f.unsubst_ty().is_phantom_data() {\n+                                if tcx.item_type(f.did).is_phantom_data() {\n                                     // Ignore PhantomData fields\n                                     return None;\n                                 }"}, {"sha": "65e2b9f863b407ac57223317cbc349cf51415156", "filename": "src/librustc_typeck/collect.rs", "status": "modified", "additions": 29, "deletions": 18, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/07ff914be1c5e0702893191827b0c13308898b45/src%2Flibrustc_typeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/07ff914be1c5e0702893191827b0c13308898b45/src%2Flibrustc_typeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcollect.rs?ref=07ff914be1c5e0702893191827b0c13308898b45", "patch": "@@ -617,10 +617,10 @@ fn convert_field<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n                            struct_generics: &'tcx ty::Generics<'tcx>,\n                            struct_predicates: &ty::GenericPredicates<'tcx>,\n                            field: &hir::StructField,\n-                           ty_f: ty::FieldDefMaster<'tcx>)\n+                           ty_f: &'tcx ty::FieldDef)\n {\n     let tt = ccx.icx(struct_predicates).to_ty(&ExplicitRscope, &field.ty);\n-    ty_f.fulfill_ty(tt);\n+    ccx.tcx.item_types.borrow_mut().insert(ty_f.did, tt);\n \n     let def_id = ccx.tcx.map.local_def_id(field.id);\n     ccx.tcx.item_types.borrow_mut().insert(def_id, tt);\n@@ -732,7 +732,7 @@ fn convert_item(ccx: &CrateCtxt, it: &hir::Item) {\n             let generics = generics_of_def_id(ccx, def_id);\n             let predicates = predicates_of_item(ccx, it);\n             convert_enum_variant_types(ccx,\n-                                       tcx.lookup_adt_def_master(ccx.tcx.map.local_def_id(it.id)),\n+                                       tcx.lookup_adt_def(ccx.tcx.map.local_def_id(it.id)),\n                                        ty,\n                                        generics,\n                                        predicates,\n@@ -842,7 +842,7 @@ fn convert_item(ccx: &CrateCtxt, it: &hir::Item) {\n             let generics = generics_of_def_id(ccx, def_id);\n             let predicates = predicates_of_item(ccx, it);\n \n-            let variant = tcx.lookup_adt_def_master(def_id).struct_variant();\n+            let variant = tcx.lookup_adt_def(def_id).struct_variant();\n \n             for (f, ty_f) in struct_def.fields().iter().zip(variant.fields.iter()) {\n                 convert_field(ccx, generics, &predicates, f, ty_f)\n@@ -911,7 +911,7 @@ fn convert_impl_item(ccx: &CrateCtxt, impl_item: &hir::ImplItem) {\n \n fn convert_variant_ctor<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n                                   ctor_id: ast::NodeId,\n-                                  variant: ty::VariantDef<'tcx>,\n+                                  variant: &'tcx ty::VariantDef,\n                                   ty: Ty<'tcx>,\n                                   predicates: ty::GenericPredicates<'tcx>) {\n     let tcx = ccx.tcx;\n@@ -923,7 +923,7 @@ fn convert_variant_ctor<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n             let inputs: Vec<_> =\n                 variant.fields\n                 .iter()\n-                .map(|field| field.unsubst_ty())\n+                .map(|field| tcx.item_type(field.did))\n                 .collect();\n             let substs = mk_item_substs(&ccx.icx(&predicates),\n                                         ccx.tcx.map.span(ctor_id), def_id);\n@@ -943,7 +943,7 @@ fn convert_variant_ctor<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n }\n \n fn convert_enum_variant_types<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n-                                        def: ty::AdtDefMaster<'tcx>,\n+                                        def: &'tcx ty::AdtDef,\n                                         ty: Ty<'tcx>,\n                                         generics: &'tcx ty::Generics<'tcx>,\n                                         predicates: ty::GenericPredicates<'tcx>,\n@@ -971,7 +971,7 @@ fn convert_struct_variant<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n                                     name: ast::Name,\n                                     disr_val: ty::Disr,\n                                     def: &hir::VariantData)\n-                                    -> ty::VariantDefData<'tcx, 'tcx> {\n+                                    -> ty::VariantDef {\n     let mut seen_fields: FxHashMap<ast::Name, Span> = FxHashMap();\n     let node_id = ccx.tcx.map.as_local_node_id(did).unwrap();\n     let fields = def.fields().iter().map(|f| {\n@@ -988,10 +988,13 @@ fn convert_struct_variant<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n             seen_fields.insert(f.name, f.span);\n         }\n \n-        ty::FieldDefData::new(fid, f.name,\n-            ty::Visibility::from_hir(&f.vis, node_id, ccx.tcx))\n+        ty::FieldDef {\n+            did: fid,\n+            name: f.name,\n+            vis: ty::Visibility::from_hir(&f.vis, node_id, ccx.tcx)\n+        }\n     }).collect();\n-    ty::VariantDefData {\n+    ty::VariantDef {\n         did: did,\n         name: name,\n         disr_val: disr_val,\n@@ -1003,29 +1006,34 @@ fn convert_struct_variant<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n fn convert_struct_def<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n                                 it: &hir::Item,\n                                 def: &hir::VariantData)\n-                                -> ty::AdtDefMaster<'tcx>\n+                                -> &'tcx ty::AdtDef\n {\n     let did = ccx.tcx.map.local_def_id(it.id);\n     // Use separate constructor id for unit/tuple structs and reuse did for braced structs.\n     let ctor_id = if !def.is_struct() { Some(ccx.tcx.map.local_def_id(def.id())) } else { None };\n     let variants = vec![convert_struct_variant(ccx, ctor_id.unwrap_or(did), it.name,\n                                                ConstInt::Infer(0), def)];\n-    let adt = ccx.tcx.intern_adt_def(did, AdtKind::Struct, variants);\n+    let adt = ccx.tcx.alloc_adt_def(did, AdtKind::Struct, variants);\n     if let Some(ctor_id) = ctor_id {\n         // Make adt definition available through constructor id as well.\n-        ccx.tcx.insert_adt_def(ctor_id, adt);\n+        ccx.tcx.adt_defs.borrow_mut().insert(ctor_id, adt);\n     }\n+\n+    ccx.tcx.adt_defs.borrow_mut().insert(did, adt);\n     adt\n }\n \n fn convert_union_def<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n                                 it: &hir::Item,\n                                 def: &hir::VariantData)\n-                                -> ty::AdtDefMaster<'tcx>\n+                                -> &'tcx ty::AdtDef\n {\n     let did = ccx.tcx.map.local_def_id(it.id);\n     let variants = vec![convert_struct_variant(ccx, did, it.name, ConstInt::Infer(0), def)];\n-    ccx.tcx.intern_adt_def(did, AdtKind::Union, variants)\n+\n+    let adt = ccx.tcx.alloc_adt_def(did, AdtKind::Union, variants);\n+    ccx.tcx.adt_defs.borrow_mut().insert(did, adt);\n+    adt\n }\n \n     fn evaluate_disr_expr(ccx: &CrateCtxt, repr_ty: attr::IntType, e: &hir::Expr)\n@@ -1079,7 +1087,7 @@ fn convert_union_def<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n fn convert_enum_def<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n                               it: &hir::Item,\n                               def: &hir::EnumDef)\n-                              -> ty::AdtDefMaster<'tcx>\n+                              -> &'tcx ty::AdtDef\n {\n     let tcx = ccx.tcx;\n     let did = tcx.map.local_def_id(it.id);\n@@ -1107,7 +1115,10 @@ fn convert_enum_def<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n         let did = tcx.map.local_def_id(v.node.data.id());\n         convert_struct_variant(ccx, did, v.node.name, disr, &v.node.data)\n     }).collect();\n-    tcx.intern_adt_def(tcx.map.local_def_id(it.id), AdtKind::Enum, variants)\n+\n+    let adt = tcx.alloc_adt_def(did, AdtKind::Enum, variants);\n+    tcx.adt_defs.borrow_mut().insert(did, adt);\n+    adt\n }\n \n /// Ensures that the super-predicates of the trait with def-id"}, {"sha": "804354f6fe9103ecb794cc97b8bf3e153990bfc1", "filename": "src/librustc_typeck/variance/constraints.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/07ff914be1c5e0702893191827b0c13308898b45/src%2Flibrustc_typeck%2Fvariance%2Fconstraints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/07ff914be1c5e0702893191827b0c13308898b45/src%2Flibrustc_typeck%2Fvariance%2Fconstraints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fvariance%2Fconstraints.rs?ref=07ff914be1c5e0702893191827b0c13308898b45", "patch": "@@ -92,7 +92,7 @@ impl<'a, 'tcx, 'v> ItemLikeVisitor<'v> for ConstraintContext<'a, 'tcx> {\n \n                 for field in tcx.lookup_adt_def(did).all_fields() {\n                     self.add_constraints_from_ty(generics,\n-                                                 field.unsubst_ty(),\n+                                                 tcx.item_type(field.did),\n                                                  self.covariant);\n                 }\n             }"}, {"sha": "864d2c98bb2f36498a20d32cf1e85313e269b803", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/07ff914be1c5e0702893191827b0c13308898b45/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/07ff914be1c5e0702893191827b0c13308898b45/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=07ff914be1c5e0702893191827b0c13308898b45", "patch": "@@ -1942,7 +1942,7 @@ impl Clean<Item> for hir::StructField {\n     }\n }\n \n-impl<'tcx> Clean<Item> for ty::FieldDefData<'tcx, 'static> {\n+impl<'tcx> Clean<Item> for ty::FieldDef {\n     fn clean(&self, cx: &DocContext) -> Item {\n         Item {\n             name: Some(self.name).clean(cx),\n@@ -1952,7 +1952,7 @@ impl<'tcx> Clean<Item> for ty::FieldDefData<'tcx, 'static> {\n             stability: get_stability(cx, self.did),\n             deprecation: get_deprecation(cx, self.did),\n             def_id: self.did,\n-            inner: StructFieldItem(self.unsubst_ty().clean(cx)),\n+            inner: StructFieldItem(cx.tcx.item_type(self.did).clean(cx)),\n         }\n     }\n }\n@@ -2099,13 +2099,13 @@ impl Clean<Item> for doctree::Variant {\n     }\n }\n \n-impl<'tcx> Clean<Item> for ty::VariantDefData<'tcx, 'static> {\n+impl<'tcx> Clean<Item> for ty::VariantDef {\n     fn clean(&self, cx: &DocContext) -> Item {\n         let kind = match self.ctor_kind {\n             CtorKind::Const => VariantKind::CLike,\n             CtorKind::Fn => {\n                 VariantKind::Tuple(\n-                    self.fields.iter().map(|f| f.unsubst_ty().clean(cx)).collect()\n+                    self.fields.iter().map(|f| cx.tcx.item_type(f.did).clean(cx)).collect()\n                 )\n             }\n             CtorKind::Fictive => {\n@@ -2121,7 +2121,7 @@ impl<'tcx> Clean<Item> for ty::VariantDefData<'tcx, 'static> {\n                             def_id: field.did,\n                             stability: get_stability(cx, field.did),\n                             deprecation: get_deprecation(cx, field.did),\n-                            inner: StructFieldItem(field.unsubst_ty().clean(cx))\n+                            inner: StructFieldItem(cx.tcx.item_type(field.did).clean(cx))\n                         }\n                     }).collect()\n                 })"}]}