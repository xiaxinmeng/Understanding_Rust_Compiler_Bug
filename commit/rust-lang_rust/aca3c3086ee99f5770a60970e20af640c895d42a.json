{"sha": "aca3c3086ee99f5770a60970e20af640c895d42a", "node_id": "MDY6Q29tbWl0NzI0NzEyOmFjYTNjMzA4NmVlOTlmNTc3MGE2MDk3MGUyMGFmNjQwYzg5NWQ0MmE=", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2020-03-19T08:06:48Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2020-03-19T08:06:48Z"}, "message": "Merge #3629\n\n3629: Alternative aproach to plugin auto update r=matklad a=matklad\n\nThis is very much WIP (as in, I haven't run this once), but I like the result so far.\r\n\r\ncc @Veetaha \r\n\r\nThe primary focus here on simplification:\r\n\r\n* local simplification of data structures and control-flow: using union of strings instead of an enum, using unwrapped GitHub API responses\r\n* global simplification of control flow: all logic is now in `main.ts`, implemented as linear functions without abstractions. This is stateful side-effective code, so arguments from [Carmack](http://number-none.com/blow/john_carmack_on_inlined_code.html) very much apply. We need all user interractions, all mutations, and all network requests to happen in a single file. \r\n* as a side-effect of condensing everything to functions, we can get rid of various enums. The enums were basically a reified control flow:\r\n\r\n```\r\nenum E { A, B }\r\n\r\nfn foo() -> E {\r\n    if cond { E::A } else { E::B }\r\n}\r\n\r\nfn bar(e: E) {\r\n    match e {\r\n        E::A => do_a(),\r\n        E::B => do_b(),\r\n    }\r\n}\r\n\r\n==>>\r\n\r\nfn all() {\r\n    if cond { do_a() } else { do_b() }\r\n}\r\n```\r\n\r\n* simplification of model: we don't need to reinstall on settings update, we can just ask the user to reload, we don't need to handle nightly=>stable fallback, we can ask the user to reinstall extension, (todo) we don't need to parse out the date from the version, we can use build id for nightly and for stable we can write the info directly into package.json.\n\nCo-authored-by: Aleksey Kladov <aleksey.kladov@gmail.com>", "tree": {"sha": "2f0b3233cc4728436ba5e47a6e91e7df33585d43", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2f0b3233cc4728436ba5e47a6e91e7df33585d43"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/aca3c3086ee99f5770a60970e20af640c895d42a", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJecygYCRBK7hj4Ov3rIwAAdHIIAFIRo4lo3kh1y6t7HMrXqCkJ\nHm7EtiyXRKdYb9TdXr+EECxgodIdGTrL4Xoh+F5gjXw+TqK2fu/jgwW/xkTjIyYb\nlWfwHQiqmQZ6eGEI1lLss1PB9/OYuTwnWwVcICzC9zGP09WMCfmWlS3CaiMYsCKn\n4a/sSbPqxTttzjMUw1BDb1r8+ofgh3dhKKITqOG9Y4NE4r3rN/nOPH7kWacwCDdn\ni99Ve80etsGtsXj+Oj0cvpLC4Ih8saoxFIHAiy6XyFglnXhgNlsTGMkW4qE1wumi\nyIPGYLh6D2KgiA3knrmj6tWtQm2bMmNBAB8aJbOBAHUp/QbvpDySfkHhYye9Oqs=\n=QjVh\n-----END PGP SIGNATURE-----\n", "payload": "tree 2f0b3233cc4728436ba5e47a6e91e7df33585d43\nparent 55336722b3662cbdcc9e1b92a3e27ed0442d2452\nparent fb6e655de8a44c65275ad45a27bf5bd684670ba0\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1584605208 +0000\ncommitter GitHub <noreply@github.com> 1584605208 +0000\n\nMerge #3629\n\n3629: Alternative aproach to plugin auto update r=matklad a=matklad\n\nThis is very much WIP (as in, I haven't run this once), but I like the result so far.\r\n\r\ncc @Veetaha \r\n\r\nThe primary focus here on simplification:\r\n\r\n* local simplification of data structures and control-flow: using union of strings instead of an enum, using unwrapped GitHub API responses\r\n* global simplification of control flow: all logic is now in `main.ts`, implemented as linear functions without abstractions. This is stateful side-effective code, so arguments from [Carmack](http://number-none.com/blow/john_carmack_on_inlined_code.html) very much apply. We need all user interractions, all mutations, and all network requests to happen in a single file. \r\n* as a side-effect of condensing everything to functions, we can get rid of various enums. The enums were basically a reified control flow:\r\n\r\n```\r\nenum E { A, B }\r\n\r\nfn foo() -> E {\r\n    if cond { E::A } else { E::B }\r\n}\r\n\r\nfn bar(e: E) {\r\n    match e {\r\n        E::A => do_a(),\r\n        E::B => do_b(),\r\n    }\r\n}\r\n\r\n==>>\r\n\r\nfn all() {\r\n    if cond { do_a() } else { do_b() }\r\n}\r\n```\r\n\r\n* simplification of model: we don't need to reinstall on settings update, we can just ask the user to reload, we don't need to handle nightly=>stable fallback, we can ask the user to reinstall extension, (todo) we don't need to parse out the date from the version, we can use build id for nightly and for stable we can write the info directly into package.json.\n\nCo-authored-by: Aleksey Kladov <aleksey.kladov@gmail.com>\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/aca3c3086ee99f5770a60970e20af640c895d42a", "html_url": "https://github.com/rust-lang/rust/commit/aca3c3086ee99f5770a60970e20af640c895d42a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/aca3c3086ee99f5770a60970e20af640c895d42a/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "55336722b3662cbdcc9e1b92a3e27ed0442d2452", "url": "https://api.github.com/repos/rust-lang/rust/commits/55336722b3662cbdcc9e1b92a3e27ed0442d2452", "html_url": "https://github.com/rust-lang/rust/commit/55336722b3662cbdcc9e1b92a3e27ed0442d2452"}, {"sha": "fb6e655de8a44c65275ad45a27bf5bd684670ba0", "url": "https://api.github.com/repos/rust-lang/rust/commits/fb6e655de8a44c65275ad45a27bf5bd684670ba0", "html_url": "https://github.com/rust-lang/rust/commit/fb6e655de8a44c65275ad45a27bf5bd684670ba0"}], "stats": {"total": 956, "additions": 265, "deletions": 691}, "files": [{"sha": "ca70fb2098e5b3051be8922b9faaf10e6cd61e42", "filename": ".vscode/launch.json", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/aca3c3086ee99f5770a60970e20af640c895d42a/.vscode%2Flaunch.json", "raw_url": "https://github.com/rust-lang/rust/raw/aca3c3086ee99f5770a60970e20af640c895d42a/.vscode%2Flaunch.json", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/.vscode%2Flaunch.json?ref=aca3c3086ee99f5770a60970e20af640c895d42a", "patch": "@@ -16,6 +16,7 @@\n       \"request\": \"launch\",\n       \"runtimeExecutable\": \"${execPath}\",\n       \"args\": [\n+        // \"--user-data-dir=${workspaceFolder}/target/code\",\n         \"--disable-extensions\",\n         \"--extensionDevelopmentPath=${workspaceFolder}/editors/code\"\n       ],"}, {"sha": "150c36845b1be9d89887369d0a161dbf60d82167", "filename": "editors/code/package.json", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/aca3c3086ee99f5770a60970e20af640c895d42a/editors%2Fcode%2Fpackage.json", "raw_url": "https://github.com/rust-lang/rust/raw/aca3c3086ee99f5770a60970e20af640c895d42a/editors%2Fcode%2Fpackage.json", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/editors%2Fcode%2Fpackage.json?ref=aca3c3086ee99f5770a60970e20af640c895d42a", "patch": "@@ -228,7 +228,7 @@\n                     \"default\": \"stable\",\n                     \"markdownEnumDescriptions\": [\n                         \"`\\\"stable\\\"` updates are shipped weekly, they don't contain cutting-edge features from VSCode proposed APIs but have less bugs in general\",\n-                        \"`\\\"nightly\\\"` updates are shipped daily, they contain cutting-edge features and latest bug fixes. These releases help us get your feedback very quickly and speed up rust-analyzer development **drastically**\"\n+                        \"`\\\"nightly\\\"` updates are shipped daily (extension updates automatically by downloading artifacts directly from GitHub), they contain cutting-edge features and latest bug fixes. These releases help us get your feedback very quickly and speed up rust-analyzer development **drastically**\"\n                     ],\n                     \"markdownDescription\": \"Choose `\\\"nightly\\\"` updates to get the latest features and bug fixes every day. While `\\\"stable\\\"` releases occur weekly and don't contain cutting-edge features from VSCode proposed APIs\"\n                 },"}, {"sha": "03528b8252c2cd29e384e748671c59e296eb48d1", "filename": "editors/code/src/commands/server_version.ts", "status": "modified", "additions": 3, "deletions": 13, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/aca3c3086ee99f5770a60970e20af640c895d42a/editors%2Fcode%2Fsrc%2Fcommands%2Fserver_version.ts", "raw_url": "https://github.com/rust-lang/rust/raw/aca3c3086ee99f5770a60970e20af640c895d42a/editors%2Fcode%2Fsrc%2Fcommands%2Fserver_version.ts", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/editors%2Fcode%2Fsrc%2Fcommands%2Fserver_version.ts?ref=aca3c3086ee99f5770a60970e20af640c895d42a", "patch": "@@ -1,20 +1,10 @@\n-import * as vscode from 'vscode';\n-import { ensureServerBinary } from '../installation/server';\n+import * as vscode from \"vscode\";\n+import { spawnSync } from \"child_process\";\n import { Ctx, Cmd } from '../ctx';\n-import { spawnSync } from 'child_process';\n \n export function serverVersion(ctx: Ctx): Cmd {\n     return async () => {\n-        const binaryPath = await ensureServerBinary(ctx.config, ctx.state);\n-\n-        if (binaryPath == null) {\n-            throw new Error(\n-                \"Rust Analyzer Language Server is not available. \" +\n-                \"Please, ensure its [proper installation](https://rust-analyzer.github.io/manual.html#installation).\"\n-            );\n-        }\n-\n-        const version = spawnSync(binaryPath, [\"--version\"], { encoding: \"utf8\" }).stdout;\n+        const version = spawnSync(ctx.serverPath, [\"--version\"], { encoding: \"utf8\" }).stdout;\n         vscode.window.showInformationMessage('rust-analyzer version : ' + version);\n     };\n }"}, {"sha": "28698ab8eaada7d0fcdafb87ba1f61a96a1bcd5a", "filename": "editors/code/src/config.ts", "status": "modified", "additions": 7, "deletions": 96, "changes": 103, "blob_url": "https://github.com/rust-lang/rust/blob/aca3c3086ee99f5770a60970e20af640c895d42a/editors%2Fcode%2Fsrc%2Fconfig.ts", "raw_url": "https://github.com/rust-lang/rust/raw/aca3c3086ee99f5770a60970e20af640c895d42a/editors%2Fcode%2Fsrc%2Fconfig.ts", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/editors%2Fcode%2Fsrc%2Fconfig.ts?ref=aca3c3086ee99f5770a60970e20af640c895d42a", "patch": "@@ -1,9 +1,5 @@\n-import * as os from \"os\";\n import * as vscode from 'vscode';\n-import { ArtifactSource } from \"./installation/interfaces\";\n-import { log, vscodeReloadWindow } from \"./util\";\n-\n-const RA_LSP_DEBUG = process.env.__RA_LSP_SERVER_DEBUG;\n+import { log } from \"./util\";\n \n export interface InlayHintOptions {\n     typeHints: boolean;\n@@ -25,10 +21,7 @@ export interface CargoFeatures {\n     loadOutDirsFromCheck: boolean;\n }\n \n-export const enum UpdatesChannel {\n-    Stable = \"stable\",\n-    Nightly = \"nightly\"\n-}\n+export type UpdatesChannel = \"stable\" | \"nightly\";\n \n export const NIGHTLY_TAG = \"nightly\";\n export class Config {\n@@ -41,6 +34,7 @@ export class Config {\n         \"cargo-watch\",\n         \"highlighting.semanticTokens\",\n         \"inlayHints\",\n+        \"updates.channel\",\n     ]\n         .map(opt => `${this.rootSection}.${opt}`);\n \n@@ -94,100 +88,17 @@ export class Config {\n         );\n \n         if (userResponse === \"Reload now\") {\n-            await vscodeReloadWindow();\n+            await vscode.commands.executeCommand(\"workbench.action.reloadWindow\");\n         }\n     }\n \n-    private static replaceTildeWithHomeDir(path: string) {\n-        if (path.startsWith(\"~/\")) {\n-            return os.homedir() + path.slice(\"~\".length);\n-        }\n-        return path;\n-    }\n-\n-    /**\n-     * Name of the binary artifact for `rust-analyzer` that is published for\n-     * `platform` on GitHub releases. (It is also stored under the same name when\n-     * downloaded by the extension).\n-     */\n-    get prebuiltServerFileName(): null | string {\n-        // See possible `arch` values here:\n-        // https://nodejs.org/api/process.html#process_process_arch\n-\n-        switch (process.platform) {\n-\n-            case \"linux\": {\n-                switch (process.arch) {\n-                    case \"arm\":\n-                    case \"arm64\": return null;\n-\n-                    default: return \"rust-analyzer-linux\";\n-                }\n-            }\n-\n-            case \"darwin\": return \"rust-analyzer-mac\";\n-            case \"win32\": return \"rust-analyzer-windows.exe\";\n-\n-            // Users on these platforms yet need to manually build from sources\n-            case \"aix\":\n-            case \"android\":\n-            case \"freebsd\":\n-            case \"openbsd\":\n-            case \"sunos\":\n-            case \"cygwin\":\n-            case \"netbsd\": return null;\n-            // The list of platforms is exhaustive (see `NodeJS.Platform` type definition)\n-        }\n-    }\n-\n-    get installedExtensionUpdateChannel(): UpdatesChannel {\n-        return this.extensionReleaseTag === NIGHTLY_TAG\n-            ? UpdatesChannel.Nightly\n-            : UpdatesChannel.Stable;\n-    }\n-\n-    get serverSource(): null | ArtifactSource {\n-        const serverPath = RA_LSP_DEBUG ?? this.serverPath;\n-\n-        if (serverPath) {\n-            return {\n-                type: ArtifactSource.Type.ExplicitPath,\n-                path: Config.replaceTildeWithHomeDir(serverPath)\n-            };\n-        }\n-\n-        const prebuiltBinaryName = this.prebuiltServerFileName;\n-\n-        if (!prebuiltBinaryName) return null;\n-\n-        return this.createGithubReleaseSource(\n-            prebuiltBinaryName,\n-            this.extensionReleaseTag\n-        );\n-    }\n-\n-    private createGithubReleaseSource(file: string, tag: string): ArtifactSource.GithubRelease {\n-        return {\n-            type: ArtifactSource.Type.GithubRelease,\n-            file,\n-            tag,\n-            dir: this.ctx.globalStoragePath,\n-            repo: {\n-                name: \"rust-analyzer\",\n-                owner: \"rust-analyzer\",\n-            }\n-        };\n-    }\n-\n-    get nightlyVsixSource(): ArtifactSource.GithubRelease {\n-        return this.createGithubReleaseSource(\"rust-analyzer.vsix\", NIGHTLY_TAG);\n-    }\n+    get globalStoragePath(): string { return this.ctx.globalStoragePath; }\n \n     // We don't do runtime config validation here for simplicity. More on stackoverflow:\n     // https://stackoverflow.com/questions/60135780/what-is-the-best-way-to-type-check-the-configuration-for-vscode-extension\n \n-    private get serverPath() { return this.cfg.get(\"serverPath\") as null | string; }\n-    get updatesChannel() { return this.cfg.get(\"updates.channel\") as UpdatesChannel; }\n+    get serverPath() { return this.cfg.get(\"serverPath\") as null | string; }\n+    get channel() { return this.cfg.get<\"stable\" | \"nightly\">(\"updates.channel\")!; }\n     get askBeforeDownload() { return this.cfg.get(\"updates.askBeforeDownload\") as boolean; }\n     get highlightingSemanticTokens() { return this.cfg.get(\"highlighting.semanticTokens\") as boolean; }\n     get highlightingOn() { return this.cfg.get(\"highlightingOn\") as boolean; }"}, {"sha": "84c170ea8bde8d30c9445f548af20854ee0002ff", "filename": "editors/code/src/ctx.ts", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/aca3c3086ee99f5770a60970e20af640c895d42a/editors%2Fcode%2Fsrc%2Fctx.ts", "raw_url": "https://github.com/rust-lang/rust/raw/aca3c3086ee99f5770a60970e20af640c895d42a/editors%2Fcode%2Fsrc%2Fctx.ts", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/editors%2Fcode%2Fsrc%2Fctx.ts?ref=aca3c3086ee99f5770a60970e20af640c895d42a", "patch": "@@ -4,21 +4,20 @@ import * as lc from 'vscode-languageclient';\n import { Config } from './config';\n import { createClient } from './client';\n import { isRustEditor, RustEditor } from './util';\n-import { PersistentState } from './persistent_state';\n \n export class Ctx {\n     private constructor(\n         readonly config: Config,\n-        readonly state: PersistentState,\n         private readonly extCtx: vscode.ExtensionContext,\n-        readonly client: lc.LanguageClient\n+        readonly client: lc.LanguageClient,\n+        readonly serverPath: string,\n     ) {\n \n     }\n \n-    static async create(config: Config, state: PersistentState, extCtx: vscode.ExtensionContext, serverPath: string): Promise<Ctx> {\n+    static async create(config: Config, extCtx: vscode.ExtensionContext, serverPath: string): Promise<Ctx> {\n         const client = await createClient(config, serverPath);\n-        const res = new Ctx(config, state, extCtx, client);\n+        const res = new Ctx(config, extCtx, client, serverPath);\n         res.pushCleanup(client.start());\n         await client.onReady();\n         return res;"}, {"sha": "a1db96f052bf7e383914b85b3308c2fdf442a862", "filename": "editors/code/src/installation/extension.ts", "status": "removed", "additions": 0, "deletions": 146, "changes": 146, "blob_url": "https://github.com/rust-lang/rust/blob/55336722b3662cbdcc9e1b92a3e27ed0442d2452/editors%2Fcode%2Fsrc%2Finstallation%2Fextension.ts", "raw_url": "https://github.com/rust-lang/rust/raw/55336722b3662cbdcc9e1b92a3e27ed0442d2452/editors%2Fcode%2Fsrc%2Finstallation%2Fextension.ts", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/editors%2Fcode%2Fsrc%2Finstallation%2Fextension.ts?ref=55336722b3662cbdcc9e1b92a3e27ed0442d2452", "patch": "@@ -1,146 +0,0 @@\n-import * as vscode from \"vscode\";\n-import * as path from \"path\";\n-import { promises as fs } from 'fs';\n-\n-import { vscodeReinstallExtension, vscodeReloadWindow, log, vscodeInstallExtensionFromVsix, assert, notReentrant } from \"../util\";\n-import { Config, UpdatesChannel } from \"../config\";\n-import { ArtifactReleaseInfo, ArtifactSource } from \"./interfaces\";\n-import { downloadArtifactWithProgressUi } from \"./downloads\";\n-import { fetchArtifactReleaseInfo } from \"./fetch_artifact_release_info\";\n-import { PersistentState } from \"../persistent_state\";\n-\n-const HEURISTIC_NIGHTLY_RELEASE_PERIOD_IN_HOURS = 25;\n-\n-/**\n- * Installs `stable` or latest `nightly` version or does nothing if the current\n- * extension version is what's needed according to `desiredUpdateChannel`.\n- */\n-export async function ensureProperExtensionVersion(config: Config, state: PersistentState): Promise<never | void> {\n-    // User has built lsp server from sources, she should manage updates manually\n-    if (config.serverSource?.type === ArtifactSource.Type.ExplicitPath) return;\n-\n-    const currentUpdChannel = config.installedExtensionUpdateChannel;\n-    const desiredUpdChannel = config.updatesChannel;\n-\n-    if (currentUpdChannel === UpdatesChannel.Stable) {\n-        // Release date is present only when we are on nightly\n-        await state.installedNightlyExtensionReleaseDate.set(null);\n-    }\n-\n-    if (desiredUpdChannel === UpdatesChannel.Stable) {\n-        // VSCode should handle updates for stable channel\n-        if (currentUpdChannel === UpdatesChannel.Stable) return;\n-\n-        if (!await askToDownloadProperExtensionVersion(config)) return;\n-\n-        await vscodeReinstallExtension(config.extensionId);\n-        await vscodeReloadWindow(); // never returns\n-    }\n-\n-    if (currentUpdChannel === UpdatesChannel.Stable) {\n-        if (!await askToDownloadProperExtensionVersion(config)) return;\n-\n-        return await tryDownloadNightlyExtension(config, state);\n-    }\n-\n-    const currentExtReleaseDate = state.installedNightlyExtensionReleaseDate.get();\n-\n-    if (currentExtReleaseDate === null) {\n-        void vscode.window.showErrorMessage(\n-            \"Nightly release date must've been set during the installation. \" +\n-            \"Did you download and install the nightly .vsix package manually?\"\n-        );\n-        throw new Error(\"Nightly release date was not set in globalStorage\");\n-    }\n-\n-    const dateNow = new Date;\n-    const hoursSinceLastUpdate = diffInHours(currentExtReleaseDate, dateNow);\n-    log.debug(\n-        \"Current rust-analyzer nightly was downloaded\", hoursSinceLastUpdate,\n-        \"hours ago, namely:\", currentExtReleaseDate, \"and now is\", dateNow\n-    );\n-\n-    if (hoursSinceLastUpdate < HEURISTIC_NIGHTLY_RELEASE_PERIOD_IN_HOURS) {\n-        return;\n-    }\n-    if (!await askToDownloadProperExtensionVersion(config, \"The installed nightly version is most likely outdated. \")) {\n-        return;\n-    }\n-\n-    await tryDownloadNightlyExtension(config, state, releaseInfo => {\n-        assert(\n-            currentExtReleaseDate.getTime() === state.installedNightlyExtensionReleaseDate.get()?.getTime(),\n-            \"Other active VSCode instance has reinstalled the extension\"\n-        );\n-\n-        if (releaseInfo.releaseDate.getTime() === currentExtReleaseDate.getTime()) {\n-            vscode.window.showInformationMessage(\n-                \"Whoops, it appears that your nightly version is up-to-date. \" +\n-                \"There might be some problems with the upcomming nightly release \" +\n-                \"or you traveled too far into the future. Sorry for that \ud83d\ude05! \"\n-            );\n-            return false;\n-        }\n-        return true;\n-    });\n-}\n-\n-async function askToDownloadProperExtensionVersion(config: Config, reason = \"\") {\n-    if (!config.askBeforeDownload) return true;\n-\n-    const stableOrNightly = config.updatesChannel === UpdatesChannel.Stable ? \"stable\" : \"latest nightly\";\n-\n-    // In case of reentering this function and showing the same info message\n-    // (e.g. after we had shown this message, the user changed the config)\n-    // vscode will dismiss the already shown one (i.e. return undefined).\n-    // This behaviour is what we want, but likely it is not documented\n-\n-    const userResponse = await vscode.window.showInformationMessage(\n-        reason + `Do you want to download the ${stableOrNightly} rust-analyzer extension ` +\n-        `version and reload the window now?`,\n-        \"Download now\", \"Cancel\"\n-    );\n-    return userResponse === \"Download now\";\n-}\n-\n-/**\n- * Shutdowns the process in case of success (i.e. reloads the window) or throws an error.\n- *\n- * ACHTUNG!: this function has a crazy amount of state transitions, handling errors during\n- * each of them would result in a ton of code (especially accounting for cross-process\n- * shared mutable `globalState` access). Enforcing no reentrancy for this is best-effort.\n- */\n-const tryDownloadNightlyExtension = notReentrant(async (\n-    config: Config,\n-    state: PersistentState,\n-    shouldDownload: (releaseInfo: ArtifactReleaseInfo) => boolean = () => true\n-): Promise<never | void> => {\n-    const vsixSource = config.nightlyVsixSource;\n-    try {\n-        const releaseInfo = await fetchArtifactReleaseInfo(vsixSource.repo, vsixSource.file, vsixSource.tag);\n-\n-        if (!shouldDownload(releaseInfo)) return;\n-\n-        await downloadArtifactWithProgressUi(releaseInfo, vsixSource.file, vsixSource.dir, \"nightly extension\");\n-\n-        const vsixPath = path.join(vsixSource.dir, vsixSource.file);\n-\n-        await vscodeInstallExtensionFromVsix(vsixPath);\n-        await state.installedNightlyExtensionReleaseDate.set(releaseInfo.releaseDate);\n-        await fs.unlink(vsixPath);\n-\n-        await vscodeReloadWindow(); // never returns\n-    } catch (err) {\n-        log.downloadError(err, \"nightly extension\", vsixSource.repo.name);\n-    }\n-});\n-\n-function diffInHours(a: Date, b: Date): number {\n-    // Discard the time and time-zone information (to abstract from daylight saving time bugs)\n-    // https://stackoverflow.com/a/15289883/9259330\n-\n-    const utcA = Date.UTC(a.getFullYear(), a.getMonth(), a.getDate());\n-    const utcB = Date.UTC(b.getFullYear(), b.getMonth(), b.getDate());\n-\n-    return (utcA - utcB) / (1000 * 60 * 60);\n-}"}, {"sha": "1ad3b8338ba9b8077650e6c6b93bf62c5976677c", "filename": "editors/code/src/installation/fetch_artifact_release_info.ts", "status": "removed", "additions": 0, "deletions": 77, "changes": 77, "blob_url": "https://github.com/rust-lang/rust/blob/55336722b3662cbdcc9e1b92a3e27ed0442d2452/editors%2Fcode%2Fsrc%2Finstallation%2Ffetch_artifact_release_info.ts", "raw_url": "https://github.com/rust-lang/rust/raw/55336722b3662cbdcc9e1b92a3e27ed0442d2452/editors%2Fcode%2Fsrc%2Finstallation%2Ffetch_artifact_release_info.ts", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/editors%2Fcode%2Fsrc%2Finstallation%2Ffetch_artifact_release_info.ts?ref=55336722b3662cbdcc9e1b92a3e27ed0442d2452", "patch": "@@ -1,77 +0,0 @@\n-import fetch from \"node-fetch\";\n-import { GithubRepo, ArtifactReleaseInfo } from \"./interfaces\";\n-import { log } from \"../util\";\n-\n-const GITHUB_API_ENDPOINT_URL = \"https://api.github.com\";\n-\n-/**\n- * Fetches the release with `releaseTag` from GitHub `repo` and\n- * returns metadata about `artifactFileName` shipped with\n- * this release.\n- *\n- * @throws Error upon network failure or if no such repository, release, or artifact exists.\n- */\n-export async function fetchArtifactReleaseInfo(\n-    repo: GithubRepo,\n-    artifactFileName: string,\n-    releaseTag: string\n-): Promise<ArtifactReleaseInfo> {\n-\n-    const repoOwner = encodeURIComponent(repo.owner);\n-    const repoName = encodeURIComponent(repo.name);\n-\n-    const apiEndpointPath = `/repos/${repoOwner}/${repoName}/releases/tags/${releaseTag}`;\n-\n-    const requestUrl = GITHUB_API_ENDPOINT_URL + apiEndpointPath;\n-\n-    log.debug(\"Issuing request for released artifacts metadata to\", requestUrl);\n-\n-    const response = await fetch(requestUrl, { headers: { Accept: \"application/vnd.github.v3+json\" } });\n-\n-    if (!response.ok) {\n-        log.error(\"Error fetching artifact release info\", {\n-            requestUrl,\n-            releaseTag,\n-            artifactFileName,\n-            response: {\n-                headers: response.headers,\n-                status: response.status,\n-                body: await response.text(),\n-            }\n-        });\n-\n-        throw new Error(\n-            `Got response ${response.status} when trying to fetch ` +\n-            `\"${artifactFileName}\" artifact release info for ${releaseTag} release`\n-        );\n-    }\n-\n-    // We skip runtime type checks for simplicity (here we cast from `any` to `GithubRelease`)\n-    const release: GithubRelease = await response.json();\n-\n-    const artifact = release.assets.find(artifact => artifact.name === artifactFileName);\n-\n-    if (!artifact) {\n-        throw new Error(\n-            `Artifact ${artifactFileName} was not found in ${release.name} release!`\n-        );\n-    }\n-\n-    return {\n-        releaseName: release.name,\n-        releaseDate: new Date(release.published_at),\n-        downloadUrl: artifact.browser_download_url\n-    };\n-\n-    // We omit declaration of tremendous amount of fields that we are not using here\n-    interface GithubRelease {\n-        name: string;\n-        // eslint-disable-next-line camelcase\n-        published_at: string;\n-        assets: Array<{\n-            name: string;\n-            // eslint-disable-next-line camelcase\n-            browser_download_url: string;\n-        }>;\n-    }\n-}"}, {"sha": "1a8ea0884cb6aef08ff95defa6379fff29f3f00c", "filename": "editors/code/src/installation/interfaces.ts", "status": "removed", "additions": 0, "deletions": 63, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/55336722b3662cbdcc9e1b92a3e27ed0442d2452/editors%2Fcode%2Fsrc%2Finstallation%2Finterfaces.ts", "raw_url": "https://github.com/rust-lang/rust/raw/55336722b3662cbdcc9e1b92a3e27ed0442d2452/editors%2Fcode%2Fsrc%2Finstallation%2Finterfaces.ts", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/editors%2Fcode%2Fsrc%2Finstallation%2Finterfaces.ts?ref=55336722b3662cbdcc9e1b92a3e27ed0442d2452", "patch": "@@ -1,63 +0,0 @@\n-export interface GithubRepo {\n-    name: string;\n-    owner: string;\n-}\n-\n-/**\n- * Metadata about particular artifact retrieved from GitHub releases.\n- */\n-export interface ArtifactReleaseInfo {\n-    releaseDate: Date;\n-    releaseName: string;\n-    downloadUrl: string;\n-}\n-\n-/**\n- * Represents the source of a an artifact which is either specified by the user\n- * explicitly, or bundled by this extension from GitHub releases.\n- */\n-export type ArtifactSource = ArtifactSource.ExplicitPath | ArtifactSource.GithubRelease;\n-\n-export namespace ArtifactSource {\n-    /**\n-     * Type tag for `ArtifactSource` discriminated union.\n-     */\n-    export const enum Type { ExplicitPath, GithubRelease }\n-\n-    export interface ExplicitPath {\n-        type: Type.ExplicitPath;\n-\n-        /**\n-         * Filesystem path to the binary specified by the user explicitly.\n-         */\n-        path: string;\n-    }\n-\n-    export interface GithubRelease {\n-        type: Type.GithubRelease;\n-\n-        /**\n-         * Repository where the binary is stored.\n-         */\n-        repo: GithubRepo;\n-\n-\n-        // FIXME: add installationPath: string;\n-\n-        /**\n-         * Directory on the filesystem where the bundled binary is stored.\n-         */\n-        dir: string;\n-\n-        /**\n-         * Name of the binary file. It is stored under the same name on GitHub releases\n-         * and in local `.dir`.\n-         */\n-        file: string;\n-\n-        /**\n-         * Tag of github release that denotes a version required by this extension.\n-         */\n-        tag: string;\n-    }\n-}"}, {"sha": "05d32613158bcd90b40571cc4c42ce9eab721c7b", "filename": "editors/code/src/installation/server.ts", "status": "removed", "additions": 0, "deletions": 131, "changes": 131, "blob_url": "https://github.com/rust-lang/rust/blob/55336722b3662cbdcc9e1b92a3e27ed0442d2452/editors%2Fcode%2Fsrc%2Finstallation%2Fserver.ts", "raw_url": "https://github.com/rust-lang/rust/raw/55336722b3662cbdcc9e1b92a3e27ed0442d2452/editors%2Fcode%2Fsrc%2Finstallation%2Fserver.ts", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/editors%2Fcode%2Fsrc%2Finstallation%2Fserver.ts?ref=55336722b3662cbdcc9e1b92a3e27ed0442d2452", "patch": "@@ -1,131 +0,0 @@\n-import * as vscode from \"vscode\";\n-import * as path from \"path\";\n-import { spawnSync } from \"child_process\";\n-\n-import { ArtifactSource } from \"./interfaces\";\n-import { fetchArtifactReleaseInfo } from \"./fetch_artifact_release_info\";\n-import { downloadArtifactWithProgressUi } from \"./downloads\";\n-import { log, assert, notReentrant } from \"../util\";\n-import { Config, NIGHTLY_TAG } from \"../config\";\n-import { PersistentState } from \"../persistent_state\";\n-\n-export async function ensureServerBinary(config: Config, state: PersistentState): Promise<null | string> {\n-    const source = config.serverSource;\n-\n-    if (!source) {\n-        vscode.window.showErrorMessage(\n-            \"Unfortunately we don't ship binaries for your platform yet. \" +\n-            \"You need to manually clone rust-analyzer repository and \" +\n-            \"run `cargo xtask install --server` to build the language server from sources. \" +\n-            \"If you feel that your platform should be supported, please create an issue \" +\n-            \"about that [here](https://github.com/rust-analyzer/rust-analyzer/issues) and we \" +\n-            \"will consider it.\"\n-        );\n-        return null;\n-    }\n-\n-    switch (source.type) {\n-        case ArtifactSource.Type.ExplicitPath: {\n-            if (isBinaryAvailable(source.path)) {\n-                return source.path;\n-            }\n-\n-            vscode.window.showErrorMessage(\n-                `Unable to run ${source.path} binary. ` +\n-                `To use the pre-built language server, set \"rust-analyzer.serverPath\" ` +\n-                \"value to `null` or remove it from the settings to use it by default.\"\n-            );\n-            return null;\n-        }\n-        case ArtifactSource.Type.GithubRelease: {\n-            if (!shouldDownloadServer(state, source)) {\n-                return path.join(source.dir, source.file);\n-            }\n-\n-            if (config.askBeforeDownload) {\n-                const userResponse = await vscode.window.showInformationMessage(\n-                    `Language server version ${source.tag} for rust-analyzer is not installed. ` +\n-                    \"Do you want to download it now?\",\n-                    \"Download now\", \"Cancel\"\n-                );\n-                if (userResponse !== \"Download now\") return null;\n-            }\n-\n-            return await downloadServer(state, source);\n-        }\n-    }\n-}\n-\n-function shouldDownloadServer(\n-    state: PersistentState,\n-    source: ArtifactSource.GithubRelease,\n-): boolean {\n-    if (!isBinaryAvailable(path.join(source.dir, source.file))) return true;\n-\n-    const installed = {\n-        tag: state.serverReleaseTag.get(),\n-        date: state.serverReleaseDate.get()\n-    };\n-    const required = {\n-        tag: source.tag,\n-        date: state.installedNightlyExtensionReleaseDate.get()\n-    };\n-\n-    log.debug(\"Installed server:\", installed, \"required:\", required);\n-\n-    if (required.tag !== NIGHTLY_TAG || installed.tag !== NIGHTLY_TAG) {\n-        return required.tag !== installed.tag;\n-    }\n-\n-    assert(required.date !== null, \"Extension release date should have been saved during its installation\");\n-    assert(installed.date !== null, \"Server release date should have been saved during its installation\");\n-\n-    return installed.date.getTime() !== required.date.getTime();\n-}\n-\n-/**\n- * Enforcing no reentrancy for this is best-effort.\n- */\n-const downloadServer = notReentrant(async (\n-    state: PersistentState,\n-    source: ArtifactSource.GithubRelease,\n-): Promise<null | string> => {\n-    try {\n-        const releaseInfo = await fetchArtifactReleaseInfo(source.repo, source.file, source.tag);\n-\n-        await downloadArtifactWithProgressUi(releaseInfo, source.file, source.dir, \"language server\");\n-        await Promise.all([\n-            state.serverReleaseTag.set(releaseInfo.releaseName),\n-            state.serverReleaseDate.set(releaseInfo.releaseDate)\n-        ]);\n-    } catch (err) {\n-        log.downloadError(err, \"language server\", source.repo.name);\n-        return null;\n-    }\n-\n-    const binaryPath = path.join(source.dir, source.file);\n-\n-    assert(isBinaryAvailable(binaryPath),\n-        `Downloaded language server binary is not functional.` +\n-        `Downloaded from GitHub repo ${source.repo.owner}/${source.repo.name} ` +\n-        `to ${binaryPath}`\n-    );\n-\n-    vscode.window.showInformationMessage(\n-        \"Rust analyzer language server was successfully installed \ud83e\udd80\"\n-    );\n-\n-    return binaryPath;\n-});\n-\n-function isBinaryAvailable(binaryPath: string): boolean {\n-    const res = spawnSync(binaryPath, [\"--version\"]);\n-\n-    // ACHTUNG! `res` type declaration is inherently wrong, see\n-    // https://github.com/DefinitelyTyped/DefinitelyTyped/issues/42221\n-\n-    log.debug(\"Checked binary availablity via --version\", res);\n-    log.debug(binaryPath, \"--version output:\", res.output?.map(String));\n-\n-    return res.status === 0;\n-}"}, {"sha": "d907f3e6fe516ed4778c5b75372c2a299b3d7f9b", "filename": "editors/code/src/main.ts", "status": "modified", "additions": 138, "deletions": 20, "changes": 158, "blob_url": "https://github.com/rust-lang/rust/blob/aca3c3086ee99f5770a60970e20af640c895d42a/editors%2Fcode%2Fsrc%2Fmain.ts", "raw_url": "https://github.com/rust-lang/rust/raw/aca3c3086ee99f5770a60970e20af640c895d42a/editors%2Fcode%2Fsrc%2Fmain.ts", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/editors%2Fcode%2Fsrc%2Fmain.ts?ref=aca3c3086ee99f5770a60970e20af640c895d42a", "patch": "@@ -1,15 +1,18 @@\n import * as vscode from 'vscode';\n+import * as path from \"path\";\n+import * as os from \"os\";\n+import { promises as fs } from \"fs\";\n \n import * as commands from './commands';\n import { activateInlayHints } from './inlay_hints';\n import { activateStatusDisplay } from './status_display';\n import { Ctx } from './ctx';\n import { activateHighlighting } from './highlighting';\n-import { ensureServerBinary } from './installation/server';\n-import { Config } from './config';\n-import { log } from './util';\n-import { ensureProperExtensionVersion } from './installation/extension';\n+import { Config, NIGHTLY_TAG } from './config';\n+import { log, assert } from './util';\n import { PersistentState } from './persistent_state';\n+import { fetchRelease, download } from './net';\n+import { spawnSync } from 'child_process';\n \n let ctx: Ctx | undefined;\n \n@@ -35,27 +38,14 @@ export async function activate(context: vscode.ExtensionContext) {\n     context.subscriptions.push(defaultOnEnter);\n \n     const config = new Config(context);\n-    const state = new PersistentState(context);\n-\n-    vscode.workspace.onDidChangeConfiguration(() => ensureProperExtensionVersion(config, state).catch(log.error));\n-\n-    // Don't await the user response here, otherwise we will block the lsp server bootstrap\n-    void ensureProperExtensionVersion(config, state).catch(log.error);\n-\n-    const serverPath = await ensureServerBinary(config, state);\n-\n-    if (serverPath == null) {\n-        throw new Error(\n-            \"Rust Analyzer Language Server is not available. \" +\n-            \"Please, ensure its [proper installation](https://rust-analyzer.github.io/manual.html#installation).\"\n-        );\n-    }\n+    const state = new PersistentState(context.globalState);\n+    const serverPath = await bootstrap(config, state);\n \n     // Note: we try to start the server before we activate type hints so that it\n     // registers its `onDidChangeDocument` handler before us.\n     //\n     // This a horribly, horribly wrong way to deal with this problem.\n-    ctx = await Ctx.create(config, state, context, serverPath);\n+    ctx = await Ctx.create(config, context, serverPath);\n \n     // Commands which invokes manually via command palette, shortcut, etc.\n     ctx.registerCommand('reload', (ctx) => {\n@@ -109,3 +99,131 @@ export async function deactivate() {\n     await ctx?.client?.stop();\n     ctx = undefined;\n }\n+\n+async function bootstrap(config: Config, state: PersistentState): Promise<string> {\n+    await fs.mkdir(config.globalStoragePath, { recursive: true });\n+\n+    await bootstrapExtension(config, state);\n+    const path = await bootstrapServer(config, state);\n+\n+    return path;\n+}\n+\n+async function bootstrapExtension(config: Config, state: PersistentState): Promise<void> {\n+    if (config.channel === \"stable\") {\n+        if (config.extensionReleaseTag === NIGHTLY_TAG) {\n+            vscode.window.showWarningMessage(`You are running a nightly version of rust-analyzer extension.\n+To switch to stable, uninstall the extension and re-install it from the marketplace`);\n+        }\n+        return;\n+    };\n+\n+    const lastCheck = state.lastCheck;\n+    const now = Date.now();\n+\n+    const anHour = 60 * 60 * 1000;\n+    const shouldDownloadNightly = state.releaseId === undefined || (now - (lastCheck ?? 0)) > anHour;\n+\n+    if (!shouldDownloadNightly) return;\n+\n+    const release = await fetchRelease(\"nightly\").catch((e) => {\n+        log.error(e);\n+        if (state.releaseId === undefined) { // Show error only for the initial download\n+            vscode.window.showErrorMessage(`Failed to download rust-analyzer nightly ${e}`);\n+        }\n+        return undefined;\n+    });\n+    if (release === undefined || release.id === state.releaseId) return;\n+\n+    const userResponse = await vscode.window.showInformationMessage(\n+        \"New version of rust-analyzer (nightly) is available (requires reload).\",\n+        \"Update\"\n+    );\n+    if (userResponse !== \"Update\") return;\n+\n+    const artifact = release.assets.find(artifact => artifact.name === \"rust-analyzer.vsix\");\n+    assert(!!artifact, `Bad release: ${JSON.stringify(release)}`);\n+\n+    const dest = path.join(config.globalStoragePath, \"rust-analyzer.vsix\");\n+    await download(artifact.browser_download_url, dest, \"Downloading rust-analyzer extension\");\n+\n+    await vscode.commands.executeCommand(\"workbench.extensions.installExtension\", vscode.Uri.file(dest));\n+    await fs.unlink(dest);\n+\n+    await state.updateReleaseId(release.id);\n+    await state.updateLastCheck(now);\n+    await vscode.commands.executeCommand(\"workbench.action.reloadWindow\");\n+}\n+\n+async function bootstrapServer(config: Config, state: PersistentState): Promise<string> {\n+    const path = await getServer(config, state);\n+    if (!path) {\n+        throw new Error(\n+            \"Rust Analyzer Language Server is not available. \" +\n+            \"Please, ensure its [proper installation](https://rust-analyzer.github.io/manual.html#installation).\"\n+        );\n+    }\n+\n+    const res = spawnSync(path, [\"--version\"], { encoding: 'utf8' });\n+    log.debug(\"Checked binary availability via --version\", res);\n+    log.debug(res, \"--version output:\", res.output);\n+    if (res.status !== 0) {\n+        throw new Error(\n+            `Failed to execute ${path} --version`\n+        );\n+    }\n+\n+    return path;\n+}\n+\n+async function getServer(config: Config, state: PersistentState): Promise<string | undefined> {\n+    const explicitPath = process.env.__RA_LSP_SERVER_DEBUG ?? config.serverPath;\n+    if (explicitPath) {\n+        if (explicitPath.startsWith(\"~/\")) {\n+            return os.homedir() + explicitPath.slice(\"~\".length);\n+        }\n+        return explicitPath;\n+    };\n+\n+    let binaryName: string | undefined = undefined;\n+    if (process.arch === \"x64\" || process.arch === \"x32\") {\n+        if (process.platform === \"linux\") binaryName = \"rust-analyzer-linux\";\n+        if (process.platform === \"darwin\") binaryName = \"rust-analyzer-mac\";\n+        if (process.platform === \"win32\") binaryName = \"rust-analyzer-windows.exe\";\n+    }\n+    if (binaryName === undefined) {\n+        vscode.window.showErrorMessage(\n+            \"Unfortunately we don't ship binaries for your platform yet. \" +\n+            \"You need to manually clone rust-analyzer repository and \" +\n+            \"run `cargo xtask install --server` to build the language server from sources. \" +\n+            \"If you feel that your platform should be supported, please create an issue \" +\n+            \"about that [here](https://github.com/rust-analyzer/rust-analyzer/issues) and we \" +\n+            \"will consider it.\"\n+        );\n+        return undefined;\n+    }\n+\n+    const dest = path.join(config.globalStoragePath, binaryName);\n+    const exists = await fs.stat(dest).then(() => true, () => false);\n+    if (!exists) {\n+        await state.updateServerVersion(undefined);\n+    }\n+\n+    if (state.serverVersion === config.packageJsonVersion) return dest;\n+\n+    if (config.askBeforeDownload) {\n+        const userResponse = await vscode.window.showInformationMessage(\n+            `Language server version ${config.packageJsonVersion} for rust-analyzer is not installed.`,\n+            \"Download now\"\n+        );\n+        if (userResponse !== \"Download now\") return dest;\n+    }\n+\n+    const release = await fetchRelease(config.extensionReleaseTag);\n+    const artifact = release.assets.find(artifact => artifact.name === binaryName);\n+    assert(!!artifact, `Bad release: ${JSON.stringify(release)}`);\n+\n+    await download(artifact.browser_download_url, dest, \"Downloading rust-analyzer server\", { mode: 0o755 });\n+    await state.updateServerVersion(config.packageJsonVersion);\n+    return dest;\n+}"}, {"sha": "49221393731ec8c5b8f1d4ff7a23e69c17ac312a", "filename": "editors/code/src/net.ts", "status": "renamed", "additions": 83, "deletions": 49, "changes": 132, "blob_url": "https://github.com/rust-lang/rust/blob/aca3c3086ee99f5770a60970e20af640c895d42a/editors%2Fcode%2Fsrc%2Fnet.ts", "raw_url": "https://github.com/rust-lang/rust/raw/aca3c3086ee99f5770a60970e20af640c895d42a/editors%2Fcode%2Fsrc%2Fnet.ts", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/editors%2Fcode%2Fsrc%2Fnet.ts?ref=aca3c3086ee99f5770a60970e20af640c895d42a", "patch": "@@ -1,24 +1,101 @@\n import fetch from \"node-fetch\";\n import * as vscode from \"vscode\";\n-import * as path from \"path\";\n import * as fs from \"fs\";\n import * as stream from \"stream\";\n import * as util from \"util\";\n-import { log, assert } from \"../util\";\n-import { ArtifactReleaseInfo } from \"./interfaces\";\n+import { log, assert } from \"./util\";\n \n const pipeline = util.promisify(stream.pipeline);\n \n+const GITHUB_API_ENDPOINT_URL = \"https://api.github.com\";\n+const OWNER = \"rust-analyzer\";\n+const REPO = \"rust-analyzer\";\n+\n+export async function fetchRelease(\n+    releaseTag: string\n+): Promise<GithubRelease> {\n+\n+    const apiEndpointPath = `/repos/${OWNER}/${REPO}/releases/tags/${releaseTag}`;\n+\n+    const requestUrl = GITHUB_API_ENDPOINT_URL + apiEndpointPath;\n+\n+    log.debug(\"Issuing request for released artifacts metadata to\", requestUrl);\n+\n+    const response = await fetch(requestUrl, { headers: { Accept: \"application/vnd.github.v3+json\" } });\n+\n+    if (!response.ok) {\n+        log.error(\"Error fetching artifact release info\", {\n+            requestUrl,\n+            releaseTag,\n+            response: {\n+                headers: response.headers,\n+                status: response.status,\n+                body: await response.text(),\n+            }\n+        });\n+\n+        throw new Error(\n+            `Got response ${response.status} when trying to fetch ` +\n+            `release info for ${releaseTag} release`\n+        );\n+    }\n+\n+    // We skip runtime type checks for simplicity (here we cast from `any` to `GithubRelease`)\n+    const release: GithubRelease = await response.json();\n+    return release;\n+}\n+\n+// We omit declaration of tremendous amount of fields that we are not using here\n+export interface GithubRelease {\n+    name: string;\n+    id: number;\n+    // eslint-disable-next-line camelcase\n+    published_at: string;\n+    assets: Array<{\n+        name: string;\n+        // eslint-disable-next-line camelcase\n+        browser_download_url: string;\n+    }>;\n+}\n+\n+\n+export async function download(\n+    downloadUrl: string,\n+    destinationPath: string,\n+    progressTitle: string,\n+    { mode }: { mode?: number } = {},\n+) {\n+    await vscode.window.withProgress(\n+        {\n+            location: vscode.ProgressLocation.Notification,\n+            cancellable: false,\n+            title: progressTitle\n+        },\n+        async (progress, _cancellationToken) => {\n+            let lastPercentage = 0;\n+            await downloadFile(downloadUrl, destinationPath, mode, (readBytes, totalBytes) => {\n+                const newPercentage = (readBytes / totalBytes) * 100;\n+                progress.report({\n+                    message: newPercentage.toFixed(0) + \"%\",\n+                    increment: newPercentage - lastPercentage\n+                });\n+\n+                lastPercentage = newPercentage;\n+            });\n+        }\n+    );\n+}\n+\n /**\n  * Downloads file from `url` and stores it at `destFilePath` with `destFilePermissions`.\n  * `onProgress` callback is called on recieveing each chunk of bytes\n  * to track the progress of downloading, it gets the already read and total\n  * amount of bytes to read as its parameters.\n  */\n-export async function downloadFile(\n+async function downloadFile(\n     url: string,\n     destFilePath: fs.PathLike,\n-    destFilePermissions: number,\n+    mode: number | undefined,\n     onProgress: (readBytes: number, totalBytes: number) => void\n ): Promise<void> {\n     const res = await fetch(url);\n@@ -41,7 +118,7 @@ export async function downloadFile(\n         onProgress(readBytes, totalBytes);\n     });\n \n-    const destFileStream = fs.createWriteStream(destFilePath, { mode: destFilePermissions });\n+    const destFileStream = fs.createWriteStream(destFilePath, { mode });\n \n     await pipeline(res.body, destFileStream);\n     return new Promise<void>(resolve => {\n@@ -52,46 +129,3 @@ export async function downloadFile(\n         // Issue at nodejs repo: https://github.com/nodejs/node/issues/31776\n     });\n }\n-\n-/**\n- * Downloads artifact from given `downloadUrl`.\n- * Creates `installationDir` if it is not yet created and puts the artifact under\n- * `artifactFileName`.\n- * Displays info about the download progress in an info message printing the name\n- * of the artifact as `displayName`.\n- */\n-export async function downloadArtifactWithProgressUi(\n-    { downloadUrl, releaseName }: ArtifactReleaseInfo,\n-    artifactFileName: string,\n-    installationDir: string,\n-    displayName: string,\n-) {\n-    await fs.promises.mkdir(installationDir).catch(err => assert(\n-        err?.code === \"EEXIST\",\n-        `Couldn't create directory \"${installationDir}\" to download ` +\n-        `${artifactFileName} artifact: ${err?.message}`\n-    ));\n-\n-    const installationPath = path.join(installationDir, artifactFileName);\n-\n-    await vscode.window.withProgress(\n-        {\n-            location: vscode.ProgressLocation.Notification,\n-            cancellable: false, // FIXME: add support for canceling download?\n-            title: `Downloading rust-analyzer ${displayName} (${releaseName})`\n-        },\n-        async (progress, _cancellationToken) => {\n-            let lastPrecentage = 0;\n-            const filePermissions = 0o755; // (rwx, r_x, r_x)\n-            await downloadFile(downloadUrl, installationPath, filePermissions, (readBytes, totalBytes) => {\n-                const newPercentage = (readBytes / totalBytes) * 100;\n-                progress.report({\n-                    message: newPercentage.toFixed(0) + \"%\",\n-                    increment: newPercentage - lastPrecentage\n-                });\n-\n-                lastPrecentage = newPercentage;\n-            });\n-        }\n-    );\n-}", "previous_filename": "editors/code/src/installation/downloads.ts"}, {"sha": "138d11b89726bb4dfa5afd323727939267a11eff", "filename": "editors/code/src/persistent_state.ts", "status": "modified", "additions": 28, "deletions": 36, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/aca3c3086ee99f5770a60970e20af640c895d42a/editors%2Fcode%2Fsrc%2Fpersistent_state.ts", "raw_url": "https://github.com/rust-lang/rust/raw/aca3c3086ee99f5770a60970e20af640c895d42a/editors%2Fcode%2Fsrc%2Fpersistent_state.ts", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/editors%2Fcode%2Fsrc%2Fpersistent_state.ts?ref=aca3c3086ee99f5770a60970e20af640c895d42a", "patch": "@@ -1,49 +1,41 @@\n import * as vscode from 'vscode';\n-import { log } from \"./util\";\n+import { log } from './util';\n \n export class PersistentState {\n-    constructor(private readonly ctx: vscode.ExtensionContext) {\n+    constructor(private readonly globalState: vscode.Memento) {\n+        const { lastCheck, releaseId, serverVersion } = this;\n+        log.debug(\"PersistentState: \", { lastCheck, releaseId, serverVersion });\n     }\n \n-    readonly installedNightlyExtensionReleaseDate = new DateStorage(\n-        \"installed-nightly-extension-release-date\",\n-        this.ctx.globalState\n-    );\n-    readonly serverReleaseDate = new DateStorage(\"server-release-date\", this.ctx.globalState);\n-    readonly serverReleaseTag = new Storage<null | string>(\"server-release-tag\", this.ctx.globalState, null);\n-}\n-\n-\n-export class Storage<T> {\n-    constructor(\n-        private readonly key: string,\n-        private readonly storage: vscode.Memento,\n-        private readonly defaultVal: T\n-    ) { }\n-\n-    get(): T {\n-        const val = this.storage.get(this.key, this.defaultVal);\n-        log.debug(this.key, \"==\", val);\n-        return val;\n+    /**\n+     * Used to check for *nightly* updates once an hour.\n+     */\n+    get lastCheck(): number | undefined {\n+        return this.globalState.get(\"lastCheck\");\n     }\n-    async set(val: T) {\n-        log.debug(this.key, \"=\", val);\n-        await this.storage.update(this.key, val);\n+    async updateLastCheck(value: number) {\n+        await this.globalState.update(\"lastCheck\", value);\n     }\n-}\n-export class DateStorage {\n-    inner: Storage<null | string>;\n \n-    constructor(key: string, storage: vscode.Memento) {\n-        this.inner = new Storage(key, storage, null);\n+    /**\n+     * Release id of the *nightly* extension.\n+     * Used to check if we should update.\n+     */\n+    get releaseId(): number | undefined {\n+        return this.globalState.get(\"releaseId\");\n     }\n-\n-    get(): null | Date {\n-        const dateStr = this.inner.get();\n-        return dateStr ? new Date(dateStr) : null;\n+    async updateReleaseId(value: number) {\n+        await this.globalState.update(\"releaseId\", value);\n     }\n \n-    async set(date: null | Date) {\n-        await this.inner.set(date ? date.toString() : null);\n+    /**\n+     * Version of the extension that installed the server.\n+     * Used to check if we need to update the server.\n+     */\n+    get serverVersion(): string | undefined {\n+        return this.globalState.get(\"serverVersion\");\n+    }\n+    async updateServerVersion(value: string | undefined) {\n+        await this.globalState.update(\"serverVersion\", value);\n     }\n }"}, {"sha": "978a31751ec0ba7a81335266acc7f1ffa0ee56ed", "filename": "editors/code/src/util.ts", "status": "modified", "additions": 0, "deletions": 54, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/aca3c3086ee99f5770a60970e20af640c895d42a/editors%2Fcode%2Fsrc%2Futil.ts", "raw_url": "https://github.com/rust-lang/rust/raw/aca3c3086ee99f5770a60970e20af640c895d42a/editors%2Fcode%2Fsrc%2Futil.ts", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/editors%2Fcode%2Fsrc%2Futil.ts?ref=aca3c3086ee99f5770a60970e20af640c895d42a", "patch": "@@ -1,6 +1,5 @@\n import * as lc from \"vscode-languageclient\";\n import * as vscode from \"vscode\";\n-import { promises as dns } from \"dns\";\n import { strict as nativeAssert } from \"assert\";\n \n export function assert(condition: boolean, explanation: string): asserts condition {\n@@ -31,22 +30,6 @@ export const log = new class {\n         // eslint-disable-next-line no-console\n         console.error(message, ...optionalParams);\n     }\n-\n-    downloadError(err: Error, artifactName: string, repoName: string) {\n-        vscode.window.showErrorMessage(\n-            `Failed to download the rust-analyzer ${artifactName} from ${repoName} ` +\n-            `GitHub repository: ${err.message}`\n-        );\n-        log.error(err);\n-        dns.resolve('example.com').then(\n-            addrs => log.debug(\"DNS resolution for example.com was successful\", addrs),\n-            err => log.error(\n-                \"DNS resolution for example.com failed, \" +\n-                \"there might be an issue with Internet availability\",\n-                err\n-            )\n-        );\n-    }\n };\n \n export async function sendRequestWithRetry<TParam, TRet>(\n@@ -86,17 +69,6 @@ function sleep(ms: number) {\n     return new Promise(resolve => setTimeout(resolve, ms));\n }\n \n-export function notReentrant<TThis, TParams extends any[], TRet>(\n-    fn: (this: TThis, ...params: TParams) => Promise<TRet>\n-): typeof fn {\n-    let entered = false;\n-    return function(...params) {\n-        assert(!entered, `Reentrancy invariant for ${fn.name} is violated`);\n-        entered = true;\n-        return fn.apply(this, params).finally(() => entered = false);\n-    };\n-}\n-\n export type RustDocument = vscode.TextDocument & { languageId: \"rust\" };\n export type RustEditor = vscode.TextEditor & { document: RustDocument; id: string };\n \n@@ -110,29 +82,3 @@ export function isRustDocument(document: vscode.TextDocument): document is RustD\n export function isRustEditor(editor: vscode.TextEditor): editor is RustEditor {\n     return isRustDocument(editor.document);\n }\n-\n-/**\n- * @param extensionId The canonical extension identifier in the form of: `publisher.name`\n- */\n-export async function vscodeReinstallExtension(extensionId: string) {\n-    // Unfortunately there is no straightforward way as of now, these commands\n-    // were found in vscode source code.\n-\n-    log.debug(\"Uninstalling extension\", extensionId);\n-    await vscode.commands.executeCommand(\"workbench.extensions.uninstallExtension\", extensionId);\n-    log.debug(\"Installing extension\", extensionId);\n-    await vscode.commands.executeCommand(\"workbench.extensions.installExtension\", extensionId);\n-}\n-\n-export async function vscodeReloadWindow(): Promise<never> {\n-    await vscode.commands.executeCommand(\"workbench.action.reloadWindow\");\n-\n-    assert(false, \"unreachable\");\n-}\n-\n-export async function vscodeInstallExtensionFromVsix(vsixPath: string) {\n-    await vscode.commands.executeCommand(\n-        \"workbench.extensions.installExtension\",\n-        vscode.Uri.file(vsixPath)\n-    );\n-}"}]}