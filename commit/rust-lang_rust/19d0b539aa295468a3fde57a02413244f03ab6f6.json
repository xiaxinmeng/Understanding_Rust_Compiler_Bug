{"sha": "19d0b539aa295468a3fde57a02413244f03ab6f6", "node_id": "MDY6Q29tbWl0NzI0NzEyOjE5ZDBiNTM5YWEyOTU0NjhhM2ZkZTU3YTAyNDEzMjQ0ZjAzYWI2ZjY=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-06-06T19:42:19Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-06-06T19:42:19Z"}, "message": "Auto merge of #51263 - cramertj:futures-in-core, r=aturon\n\nAdd Future and task system to the standard library\n\nThis adds preliminary versions of the `std::future` and `std::task` modules in order to unblock development of async/await (https://github.com/rust-lang/rust/issues/50547). These shouldn't be considered as final forms of these libraries-- design questions about the libraries should be left on https://github.com/rust-lang/rfcs/pull/2418. Once that RFC (or a successor) is merged, these APIs will be adjusted as necessary.\n\nr? @aturon", "tree": {"sha": "040ec289e4fb6f623fc645eca86a3bc749cfc6a7", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/040ec289e4fb6f623fc645eca86a3bc749cfc6a7"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/19d0b539aa295468a3fde57a02413244f03ab6f6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/19d0b539aa295468a3fde57a02413244f03ab6f6", "html_url": "https://github.com/rust-lang/rust/commit/19d0b539aa295468a3fde57a02413244f03ab6f6", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/19d0b539aa295468a3fde57a02413244f03ab6f6/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "cb8ab33ed29544973da866bdc3eff509b3c3e789", "url": "https://api.github.com/repos/rust-lang/rust/commits/cb8ab33ed29544973da866bdc3eff509b3c3e789", "html_url": "https://github.com/rust-lang/rust/commit/cb8ab33ed29544973da866bdc3eff509b3c3e789"}, {"sha": "a6055c885917093faf37bcb834350df7b6ddca82", "url": "https://api.github.com/repos/rust-lang/rust/commits/a6055c885917093faf37bcb834350df7b6ddca82", "html_url": "https://github.com/rust-lang/rust/commit/a6055c885917093faf37bcb834350df7b6ddca82"}], "stats": {"total": 961, "additions": 961, "deletions": 0}, "files": [{"sha": "a64b94b6517590e0c351750e102f2e49f99b5dc9", "filename": "src/liballoc/boxed.rs", "status": "modified", "additions": 93, "deletions": 0, "changes": 93, "blob_url": "https://github.com/rust-lang/rust/blob/19d0b539aa295468a3fde57a02413244f03ab6f6/src%2Fliballoc%2Fboxed.rs", "raw_url": "https://github.com/rust-lang/rust/raw/19d0b539aa295468a3fde57a02413244f03ab6f6/src%2Fliballoc%2Fboxed.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fboxed.rs?ref=19d0b539aa295468a3fde57a02413244f03ab6f6", "patch": "@@ -59,12 +59,14 @@ use core::any::Any;\n use core::borrow;\n use core::cmp::Ordering;\n use core::fmt;\n+use core::future::Future;\n use core::hash::{Hash, Hasher};\n use core::iter::FusedIterator;\n use core::marker::{Unpin, Unsize};\n use core::mem::{self, PinMut};\n use core::ops::{CoerceUnsized, Deref, DerefMut, Generator, GeneratorState};\n use core::ptr::{self, NonNull, Unique};\n+use core::task::{Context, Poll, UnsafePoll, TaskObj};\n use core::convert::From;\n \n use raw_vec::RawVec;\n@@ -755,6 +757,7 @@ impl<T> Generator for Box<T>\n /// A pinned, heap allocated reference.\n #[unstable(feature = \"pin\", issue = \"49150\")]\n #[fundamental]\n+#[repr(transparent)]\n pub struct PinBox<T: ?Sized> {\n     inner: Box<T>,\n }\n@@ -771,14 +774,72 @@ impl<T> PinBox<T> {\n #[unstable(feature = \"pin\", issue = \"49150\")]\n impl<T: ?Sized> PinBox<T> {\n     /// Get a pinned reference to the data in this PinBox.\n+    #[inline]\n     pub fn as_pin_mut<'a>(&'a mut self) -> PinMut<'a, T> {\n         unsafe { PinMut::new_unchecked(&mut *self.inner) }\n     }\n \n+    /// Constructs a `PinBox` from a raw pointer.\n+    ///\n+    /// After calling this function, the raw pointer is owned by the\n+    /// resulting `PinBox`. Specifically, the `PinBox` destructor will call\n+    /// the destructor of `T` and free the allocated memory. Since the\n+    /// way `PinBox` allocates and releases memory is unspecified, the\n+    /// only valid pointer to pass to this function is the one taken\n+    /// from another `PinBox` via the [`PinBox::into_raw`] function.\n+    ///\n+    /// This function is unsafe because improper use may lead to\n+    /// memory problems. For example, a double-free may occur if the\n+    /// function is called twice on the same raw pointer.\n+    ///\n+    /// [`PinBox::into_raw`]: struct.PinBox.html#method.into_raw\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(pin)]\n+    /// use std::boxed::PinBox;\n+    /// let x = PinBox::new(5);\n+    /// let ptr = PinBox::into_raw(x);\n+    /// let x = unsafe { PinBox::from_raw(ptr) };\n+    /// ```\n+    #[inline]\n+    pub unsafe fn from_raw(raw: *mut T) -> Self {\n+        PinBox { inner: Box::from_raw(raw) }\n+    }\n+\n+    /// Consumes the `PinBox`, returning the wrapped raw pointer.\n+    ///\n+    /// After calling this function, the caller is responsible for the\n+    /// memory previously managed by the `PinBox`. In particular, the\n+    /// caller should properly destroy `T` and release the memory. The\n+    /// proper way to do so is to convert the raw pointer back into a\n+    /// `PinBox` with the [`PinBox::from_raw`] function.\n+    ///\n+    /// Note: this is an associated function, which means that you have\n+    /// to call it as `PinBox::into_raw(b)` instead of `b.into_raw()`. This\n+    /// is so that there is no conflict with a method on the inner type.\n+    ///\n+    /// [`PinBox::from_raw`]: struct.PinBox.html#method.from_raw\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(pin)]\n+    /// use std::boxed::PinBox;\n+    /// let x = PinBox::new(5);\n+    /// let ptr = PinBox::into_raw(x);\n+    /// ```\n+    #[inline]\n+    pub fn into_raw(b: PinBox<T>) -> *mut T {\n+        Box::into_raw(b.inner)\n+    }\n+\n     /// Get a mutable reference to the data inside this PinBox.\n     ///\n     /// This function is unsafe. Users must guarantee that the data is never\n     /// moved out of this reference.\n+    #[inline]\n     pub unsafe fn get_mut<'a>(this: &'a mut PinBox<T>) -> &'a mut T {\n         &mut *this.inner\n     }\n@@ -787,6 +848,7 @@ impl<T: ?Sized> PinBox<T> {\n     ///\n     /// This function is unsafe. Users must guarantee that the data is never\n     /// moved out of the box.\n+    #[inline]\n     pub unsafe fn unpin(this: PinBox<T>) -> Box<T> {\n         this.inner\n     }\n@@ -851,3 +913,34 @@ impl<T: ?Sized + Unsize<U>, U: ?Sized> CoerceUnsized<PinBox<U>> for PinBox<T> {}\n \n #[unstable(feature = \"pin\", issue = \"49150\")]\n impl<T: ?Sized> Unpin for PinBox<T> {}\n+\n+#[unstable(feature = \"futures_api\", issue = \"50547\")]\n+unsafe impl<F: Future<Output = ()> + Send + 'static> UnsafePoll for PinBox<F> {\n+    fn into_raw(self) -> *mut () {\n+        PinBox::into_raw(self) as *mut ()\n+    }\n+\n+    unsafe fn poll(task: *mut (), cx: &mut Context) -> Poll<()> {\n+        let ptr = task as *mut F;\n+        let pin: PinMut<F> = PinMut::new_unchecked(&mut *ptr);\n+        pin.poll(cx)\n+    }\n+\n+    unsafe fn drop(task: *mut ()) {\n+        drop(PinBox::from_raw(task as *mut F))\n+    }\n+}\n+\n+#[unstable(feature = \"futures_api\", issue = \"50547\")]\n+impl<F: Future<Output = ()> + Send + 'static> From<PinBox<F>> for TaskObj {\n+    fn from(boxed: PinBox<F>) -> Self {\n+        TaskObj::from_poll_task(boxed)\n+    }\n+}\n+\n+#[unstable(feature = \"futures_api\", issue = \"50547\")]\n+impl<F: Future<Output = ()> + Send + 'static> From<Box<F>> for TaskObj {\n+    fn from(boxed: Box<F>) -> Self {\n+        TaskObj::from_poll_task(PinBox::from(boxed))\n+    }\n+}"}, {"sha": "242c7d2e70f85ea74487fd47822470015b692454", "filename": "src/liballoc/lib.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/19d0b539aa295468a3fde57a02413244f03ab6f6/src%2Fliballoc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/19d0b539aa295468a3fde57a02413244f03ab6f6/src%2Fliballoc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Flib.rs?ref=19d0b539aa295468a3fde57a02413244f03ab6f6", "patch": "@@ -95,6 +95,7 @@\n #![feature(fmt_internals)]\n #![feature(from_ref)]\n #![feature(fundamental)]\n+#![feature(futures_api)]\n #![feature(lang_items)]\n #![feature(libc)]\n #![feature(needs_allocator)]\n@@ -103,6 +104,7 @@\n #![feature(pin)]\n #![feature(ptr_internals)]\n #![feature(ptr_offset_from)]\n+#![feature(repr_transparent)]\n #![feature(rustc_attrs)]\n #![feature(specialization)]\n #![feature(staged_api)]\n@@ -155,6 +157,10 @@ pub mod heap {\n     pub use alloc::*;\n }\n \n+#[unstable(feature = \"futures_api\",\n+           reason = \"futures in libcore are unstable\",\n+           issue = \"50547\")]\n+pub mod task;\n \n // Primitive types using the heaps above\n "}, {"sha": "7b1947b56b8c7dc725bbedcccb79bd794346f016", "filename": "src/liballoc/task.rs", "status": "added", "additions": 140, "deletions": 0, "changes": 140, "blob_url": "https://github.com/rust-lang/rust/blob/19d0b539aa295468a3fde57a02413244f03ab6f6/src%2Fliballoc%2Ftask.rs", "raw_url": "https://github.com/rust-lang/rust/raw/19d0b539aa295468a3fde57a02413244f03ab6f6/src%2Fliballoc%2Ftask.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Ftask.rs?ref=19d0b539aa295468a3fde57a02413244f03ab6f6", "patch": "@@ -0,0 +1,140 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! Types and Traits for working with asynchronous tasks.\n+\n+pub use core::task::*;\n+\n+#[cfg(target_has_atomic = \"ptr\")]\n+pub use self::if_arc::*;\n+\n+#[cfg(target_has_atomic = \"ptr\")]\n+mod if_arc {\n+    use super::*;\n+    use arc::Arc;\n+    use core::marker::PhantomData;\n+    use core::mem;\n+    use core::ptr::{self, NonNull};\n+\n+    /// A way of waking up a specific task.\n+    ///\n+    /// Any task executor must provide a way of signaling that a task it owns\n+    /// is ready to be `poll`ed again. Executors do so by implementing this trait.\n+    pub trait Wake: Send + Sync {\n+        /// Indicates that the associated task is ready to make progress and should\n+        /// be `poll`ed.\n+        ///\n+        /// Executors generally maintain a queue of \"ready\" tasks; `wake` should place\n+        /// the associated task onto this queue.\n+        fn wake(arc_self: &Arc<Self>);\n+\n+        /// Indicates that the associated task is ready to make progress and should\n+        /// be `poll`ed. This function is like `wake`, but can only be called from the\n+        /// thread on which this `Wake` was created.\n+        ///\n+        /// Executors generally maintain a queue of \"ready\" tasks; `wake_local` should place\n+        /// the associated task onto this queue.\n+        #[inline]\n+        unsafe fn wake_local(arc_self: &Arc<Self>) {\n+            Self::wake(arc_self);\n+        }\n+    }\n+\n+    #[cfg(target_has_atomic = \"ptr\")]\n+    struct ArcWrapped<T>(PhantomData<T>);\n+\n+    unsafe impl<T: Wake + 'static> UnsafeWake for ArcWrapped<T> {\n+        #[inline]\n+        unsafe fn clone_raw(&self) -> Waker {\n+            let me: *const ArcWrapped<T> = self;\n+            let arc = (*(&me as *const *const ArcWrapped<T> as *const Arc<T>)).clone();\n+            Waker::from(arc)\n+        }\n+\n+        #[inline]\n+        unsafe fn drop_raw(&self) {\n+            let mut me: *const ArcWrapped<T> = self;\n+            let me = &mut me as *mut *const ArcWrapped<T> as *mut Arc<T>;\n+            ptr::drop_in_place(me);\n+        }\n+\n+        #[inline]\n+        unsafe fn wake(&self) {\n+            let me: *const ArcWrapped<T> = self;\n+            T::wake(&*(&me as *const *const ArcWrapped<T> as *const Arc<T>))\n+        }\n+\n+        #[inline]\n+        unsafe fn wake_local(&self) {\n+            let me: *const ArcWrapped<T> = self;\n+            T::wake_local(&*(&me as *const *const ArcWrapped<T> as *const Arc<T>))\n+        }\n+    }\n+\n+    impl<T> From<Arc<T>> for Waker\n+        where T: Wake + 'static,\n+    {\n+        fn from(rc: Arc<T>) -> Self {\n+            unsafe {\n+                let ptr = mem::transmute::<Arc<T>, NonNull<ArcWrapped<T>>>(rc);\n+                Waker::new(ptr)\n+            }\n+        }\n+    }\n+\n+    /// Creates a `LocalWaker` from a local `wake`.\n+    ///\n+    /// This function requires that `wake` is \"local\" (created on the current thread).\n+    /// The resulting `LocalWaker` will call `wake.wake_local()` when awoken, and\n+    /// will call `wake.wake()` if awoken after being converted to a `Waker`.\n+    #[inline]\n+    pub unsafe fn local_waker<W: Wake + 'static>(wake: Arc<W>) -> LocalWaker {\n+        let ptr = mem::transmute::<Arc<W>, NonNull<ArcWrapped<W>>>(wake);\n+        LocalWaker::new(ptr)\n+    }\n+\n+    struct NonLocalAsLocal<T>(ArcWrapped<T>);\n+\n+    unsafe impl<T: Wake + 'static> UnsafeWake for NonLocalAsLocal<T> {\n+        #[inline]\n+        unsafe fn clone_raw(&self) -> Waker {\n+            self.0.clone_raw()\n+        }\n+\n+        #[inline]\n+        unsafe fn drop_raw(&self) {\n+            self.0.drop_raw()\n+        }\n+\n+        #[inline]\n+        unsafe fn wake(&self) {\n+            self.0.wake()\n+        }\n+\n+        #[inline]\n+        unsafe fn wake_local(&self) {\n+            // Since we're nonlocal, we can't call wake_local\n+            self.0.wake()\n+        }\n+    }\n+\n+    /// Creates a `LocalWaker` from a non-local `wake`.\n+    ///\n+    /// This function is similar to `local_waker`, but does not require that `wake`\n+    /// is local to the current thread. The resulting `LocalWaker` will call\n+    /// `wake.wake()` when awoken.\n+    #[inline]\n+    pub fn local_waker_from_nonlocal<W: Wake + 'static>(wake: Arc<W>) -> LocalWaker {\n+        unsafe {\n+            let ptr = mem::transmute::<Arc<W>, NonNull<NonLocalAsLocal<W>>>(wake);\n+            LocalWaker::new(ptr)\n+        }\n+    }\n+}"}, {"sha": "b4d087f8edb6df285bcbf74f8e923de9d404b090", "filename": "src/libcore/future.rs", "status": "added", "additions": 93, "deletions": 0, "changes": 93, "blob_url": "https://github.com/rust-lang/rust/blob/19d0b539aa295468a3fde57a02413244f03ab6f6/src%2Flibcore%2Ffuture.rs", "raw_url": "https://github.com/rust-lang/rust/raw/19d0b539aa295468a3fde57a02413244f03ab6f6/src%2Flibcore%2Ffuture.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ffuture.rs?ref=19d0b539aa295468a3fde57a02413244f03ab6f6", "patch": "@@ -0,0 +1,93 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![unstable(feature = \"futures_api\",\n+            reason = \"futures in libcore are unstable\",\n+            issue = \"50547\")]\n+\n+//! Asynchronous values.\n+\n+use mem::PinMut;\n+use task::{self, Poll};\n+\n+/// A future represents an asychronous computation.\n+///\n+/// A future is a value that may not have finished computing yet. This kind of\n+/// \"asynchronous value\" makes it possible for a thread to continue doing useful\n+/// work while it waits for the value to become available.\n+///\n+/// # The `poll` method\n+///\n+/// The core method of future, `poll`, *attempts* to resolve the future into a\n+/// final value. This method does not block if the value is not ready. Instead,\n+/// the current task is scheduled to be woken up when it's possible to make\n+/// further progress by `poll`ing again. The wake up is performed using\n+/// `cx.waker()`, a handle for waking up the current task.\n+///\n+/// When using a future, you generally won't call `poll` directly, but instead\n+/// `await!` the value.\n+pub trait Future {\n+    /// The result of the `Future`.\n+    type Output;\n+\n+    /// Attempt to resolve the future to a final value, registering\n+    /// the current task for wakeup if the value is not yet available.\n+    ///\n+    /// # Return value\n+    ///\n+    /// This function returns:\n+    ///\n+    /// - `Poll::Pending` if the future is not ready yet\n+    /// - `Poll::Ready(val)` with the result `val` of this future if it finished\n+    /// successfully.\n+    ///\n+    /// Once a future has finished, clients should not `poll` it again.\n+    ///\n+    /// When a future is not ready yet, `poll` returns\n+    /// [`Poll::Pending`](::task::Poll). The future will *also* register the\n+    /// interest of the current task in the value being produced. For example,\n+    /// if the future represents the availability of data on a socket, then the\n+    /// task is recorded so that when data arrives, it is woken up (via\n+    /// [`cx.waker()`](::task::Context::waker)). Once a task has been woken up,\n+    /// it should attempt to `poll` the future again, which may or may not\n+    /// produce a final value.\n+    ///\n+    /// Note that if `Pending` is returned it only means that the *current* task\n+    /// (represented by the argument `cx`) will receive a notification. Tasks\n+    /// from previous calls to `poll` will *not* receive notifications.\n+    ///\n+    /// # Runtime characteristics\n+    ///\n+    /// Futures alone are *inert*; they must be *actively* `poll`ed to make\n+    /// progress, meaning that each time the current task is woken up, it should\n+    /// actively re-`poll` pending futures that it still has an interest in.\n+    ///\n+    /// The `poll` function is not called repeatedly in a tight loop for\n+    /// futures, but only whenever the future itself is ready, as signaled via\n+    /// the `Waker` inside `task::Context`. If you're familiar with the\n+    /// `poll(2)` or `select(2)` syscalls on Unix it's worth noting that futures\n+    /// typically do *not* suffer the same problems of \"all wakeups must poll\n+    /// all events\"; they are more like `epoll(4)`.\n+    ///\n+    /// An implementation of `poll` should strive to return quickly, and must\n+    /// *never* block. Returning quickly prevents unnecessarily clogging up\n+    /// threads or event loops. If it is known ahead of time that a call to\n+    /// `poll` may end up taking awhile, the work should be offloaded to a\n+    /// thread pool (or something similar) to ensure that `poll` can return\n+    /// quickly.\n+    ///\n+    /// # Panics\n+    ///\n+    /// Once a future has completed (returned `Ready` from `poll`),\n+    /// then any future calls to `poll` may panic, block forever, or otherwise\n+    /// cause bad behavior. The `Future` trait itself provides no guarantees\n+    /// about the behavior of `poll` after a future has completed.\n+    fn poll(self: PinMut<Self>, cx: &mut task::Context) -> Poll<Self::Output>;\n+}"}, {"sha": "912cf2bc1e970e0b8d2da6a7965d3997b48833e9", "filename": "src/libcore/lib.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/19d0b539aa295468a3fde57a02413244f03ab6f6/src%2Flibcore%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/19d0b539aa295468a3fde57a02413244f03ab6f6/src%2Flibcore%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Flib.rs?ref=19d0b539aa295468a3fde57a02413244f03ab6f6", "patch": "@@ -101,6 +101,7 @@\n #![feature(optin_builtin_traits)]\n #![feature(prelude_import)]\n #![feature(repr_simd, platform_intrinsics)]\n+#![feature(repr_transparent)]\n #![feature(rustc_attrs)]\n #![feature(rustc_const_unstable)]\n #![feature(simd_ffi)]\n@@ -207,6 +208,10 @@ pub mod time;\n \n pub mod unicode;\n \n+/* Async */\n+pub mod future;\n+pub mod task;\n+\n /* Heap memory allocator trait */\n #[allow(missing_docs)]\n pub mod alloc;"}, {"sha": "e46a6d41d7acfc24d90fec0161e1ee2c07c19e13", "filename": "src/libcore/task.rs", "status": "added", "additions": 513, "deletions": 0, "changes": 513, "blob_url": "https://github.com/rust-lang/rust/blob/19d0b539aa295468a3fde57a02413244f03ab6f6/src%2Flibcore%2Ftask.rs", "raw_url": "https://github.com/rust-lang/rust/raw/19d0b539aa295468a3fde57a02413244f03ab6f6/src%2Flibcore%2Ftask.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftask.rs?ref=19d0b539aa295468a3fde57a02413244f03ab6f6", "patch": "@@ -0,0 +1,513 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![unstable(feature = \"futures_api\",\n+            reason = \"futures in libcore are unstable\",\n+            issue = \"50547\")]\n+\n+//! Types and Traits for working with asynchronous tasks.\n+\n+use fmt;\n+use ptr::NonNull;\n+\n+/// Indicates whether a value is available or if the current task has been\n+/// scheduled to receive a wakeup instead.\n+#[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd, Hash)]\n+pub enum Poll<T> {\n+    /// Represents that a value is immediately ready.\n+    Ready(T),\n+\n+    /// Represents that a value is not ready yet.\n+    ///\n+    /// When a function returns `Pending`, the function *must* also\n+    /// ensure that the current task is scheduled to be awoken when\n+    /// progress can be made.\n+    Pending,\n+}\n+\n+/// A `Waker` is a handle for waking up a task by notifying its executor that it\n+/// is ready to be run.\n+///\n+/// This handle contains a trait object pointing to an instance of the `UnsafeWake`\n+/// trait, allowing notifications to get routed through it.\n+#[repr(transparent)]\n+pub struct Waker {\n+    inner: NonNull<UnsafeWake>,\n+}\n+\n+unsafe impl Send for Waker {}\n+unsafe impl Sync for Waker {}\n+\n+impl Waker {\n+    /// Constructs a new `Waker` directly.\n+    ///\n+    /// Note that most code will not need to call this. Implementers of the\n+    /// `UnsafeWake` trait will typically provide a wrapper that calls this\n+    /// but you otherwise shouldn't call it directly.\n+    ///\n+    /// If you're working with the standard library then it's recommended to\n+    /// use the `Waker::from` function instead which works with the safe\n+    /// `Arc` type and the safe `Wake` trait.\n+    #[inline]\n+    pub unsafe fn new(inner: NonNull<UnsafeWake>) -> Self {\n+        Waker { inner: inner }\n+    }\n+\n+    /// Wake up the task associated with this `Waker`.\n+    #[inline]\n+    pub fn wake(&self) {\n+        unsafe { self.inner.as_ref().wake() }\n+    }\n+\n+    /// Returns whether or not this `Waker` and `other` awaken the same task.\n+    ///\n+    /// This function works on a best-effort basis, and may return false even\n+    /// when the `Waker`s would awaken the same task. However, if this function\n+    /// returns true, it is guaranteed that the `Waker`s will awaken the same\n+    /// task.\n+    ///\n+    /// This function is primarily used for optimization purposes.\n+    #[inline]\n+    pub fn will_wake(&self, other: &Waker) -> bool {\n+        self.inner == other.inner\n+    }\n+}\n+\n+impl Clone for Waker {\n+    #[inline]\n+    fn clone(&self) -> Self {\n+        unsafe {\n+            self.inner.as_ref().clone_raw()\n+        }\n+    }\n+}\n+\n+impl fmt::Debug for Waker {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        f.debug_struct(\"Waker\")\n+            .finish()\n+    }\n+}\n+\n+impl Drop for Waker {\n+    #[inline]\n+    fn drop(&mut self) {\n+        unsafe {\n+            self.inner.as_ref().drop_raw()\n+        }\n+    }\n+}\n+\n+/// A `LocalWaker` is a handle for waking up a task by notifying its executor that it\n+/// is ready to be run.\n+///\n+/// This is similar to the `Waker` type, but cannot be sent across threads.\n+/// Task executors can use this type to implement more optimized singlethreaded wakeup\n+/// behavior.\n+#[repr(transparent)]\n+pub struct LocalWaker {\n+    inner: NonNull<UnsafeWake>,\n+}\n+\n+impl !Send for LocalWaker {}\n+impl !Sync for LocalWaker {}\n+\n+impl LocalWaker {\n+    /// Constructs a new `LocalWaker` directly.\n+    ///\n+    /// Note that most code will not need to call this. Implementers of the\n+    /// `UnsafeWake` trait will typically provide a wrapper that calls this\n+    /// but you otherwise shouldn't call it directly.\n+    ///\n+    /// If you're working with the standard library then it's recommended to\n+    /// use the `LocalWaker::from` function instead which works with the safe\n+    /// `Rc` type and the safe `LocalWake` trait.\n+    ///\n+    /// For this function to be used safely, it must be sound to call `inner.wake_local()`\n+    /// on the current thread.\n+    #[inline]\n+    pub unsafe fn new(inner: NonNull<UnsafeWake>) -> Self {\n+        LocalWaker { inner: inner }\n+    }\n+\n+    /// Wake up the task associated with this `LocalWaker`.\n+    #[inline]\n+    pub fn wake(&self) {\n+        unsafe { self.inner.as_ref().wake_local() }\n+    }\n+\n+    /// Returns whether or not this `LocalWaker` and `other` `LocalWaker` awaken the same task.\n+    ///\n+    /// This function works on a best-effort basis, and may return false even\n+    /// when the `LocalWaker`s would awaken the same task. However, if this function\n+    /// returns true, it is guaranteed that the `LocalWaker`s will awaken the same\n+    /// task.\n+    ///\n+    /// This function is primarily used for optimization purposes.\n+    #[inline]\n+    pub fn will_wake(&self, other: &LocalWaker) -> bool {\n+        self.inner == other.inner\n+    }\n+\n+    /// Returns whether or not this `LocalWaker` and `other` `Waker` awaken the same task.\n+    ///\n+    /// This function works on a best-effort basis, and may return false even\n+    /// when the `Waker`s would awaken the same task. However, if this function\n+    /// returns true, it is guaranteed that the `LocalWaker`s will awaken the same\n+    /// task.\n+    ///\n+    /// This function is primarily used for optimization purposes.\n+    #[inline]\n+    pub fn will_wake_nonlocal(&self, other: &Waker) -> bool {\n+        self.inner == other.inner\n+    }\n+}\n+\n+impl From<LocalWaker> for Waker {\n+    #[inline]\n+    fn from(local_waker: LocalWaker) -> Self {\n+        Waker { inner: local_waker.inner }\n+    }\n+}\n+\n+impl Clone for LocalWaker {\n+    #[inline]\n+    fn clone(&self) -> Self {\n+        unsafe {\n+            LocalWaker { inner: self.inner.as_ref().clone_raw().inner }\n+        }\n+    }\n+}\n+\n+impl fmt::Debug for LocalWaker {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        f.debug_struct(\"Waker\")\n+            .finish()\n+    }\n+}\n+\n+impl Drop for LocalWaker {\n+    #[inline]\n+    fn drop(&mut self) {\n+        unsafe {\n+            self.inner.as_ref().drop_raw()\n+        }\n+    }\n+}\n+\n+/// An unsafe trait for implementing custom memory management for a `Waker` or `LocalWaker`.\n+///\n+/// A `Waker` conceptually is a cloneable trait object for `Wake`, and is\n+/// most often essentially just `Arc<dyn Wake>`. However, in some contexts\n+/// (particularly `no_std`), it's desirable to avoid `Arc` in favor of some\n+/// custom memory management strategy. This trait is designed to allow for such\n+/// customization.\n+///\n+/// When using `std`, a default implementation of the `UnsafeWake` trait is provided for\n+/// `Arc<T>` where `T: Wake` and `Rc<T>` where `T: LocalWake`.\n+///\n+/// Although the methods on `UnsafeWake` take pointers rather than references,\n+pub unsafe trait UnsafeWake: Send + Sync {\n+    /// Creates a clone of this `UnsafeWake` and stores it behind a `Waker`.\n+    ///\n+    /// This function will create a new uniquely owned handle that under the\n+    /// hood references the same notification instance. In other words calls\n+    /// to `wake` on the returned handle should be equivalent to calls to\n+    /// `wake` on this handle.\n+    ///\n+    /// # Unsafety\n+    ///\n+    /// This function is unsafe to call because it's asserting the `UnsafeWake`\n+    /// value is in a consistent state, i.e. hasn't been dropped.\n+    unsafe fn clone_raw(&self) -> Waker;\n+\n+    /// Drops this instance of `UnsafeWake`, deallocating resources\n+    /// associated with it.\n+    ///\n+    /// FIXME(cramertj)\n+    /// This method is intended to have a signature such as:\n+    ///\n+    /// ```ignore (not-a-doctest)\n+    /// fn drop_raw(self: *mut Self);\n+    /// ```\n+    ///\n+    /// Unfortunately in Rust today that signature is not object safe.\n+    /// Nevertheless it's recommended to implement this function *as if* that\n+    /// were its signature. As such it is not safe to call on an invalid\n+    /// pointer, nor is the validity of the pointer guaranteed after this\n+    /// function returns.\n+    ///\n+    /// # Unsafety\n+    ///\n+    /// This function is unsafe to call because it's asserting the `UnsafeWake`\n+    /// value is in a consistent state, i.e. hasn't been dropped.\n+    unsafe fn drop_raw(&self);\n+\n+    /// Indicates that the associated task is ready to make progress and should\n+    /// be `poll`ed.\n+    ///\n+    /// Executors generally maintain a queue of \"ready\" tasks; `wake` should place\n+    /// the associated task onto this queue.\n+    ///\n+    /// # Panics\n+    ///\n+    /// Implementations should avoid panicking, but clients should also be prepared\n+    /// for panics.\n+    ///\n+    /// # Unsafety\n+    ///\n+    /// This function is unsafe to call because it's asserting the `UnsafeWake`\n+    /// value is in a consistent state, i.e. hasn't been dropped.\n+    unsafe fn wake(&self);\n+\n+    /// Indicates that the associated task is ready to make progress and should\n+    /// be `poll`ed. This function is the same as `wake`, but can only be called\n+    /// from the thread that this `UnsafeWake` is \"local\" to. This allows for\n+    /// implementors to provide specialized wakeup behavior specific to the current\n+    /// thread. This function is called by `LocalWaker::wake`.\n+    ///\n+    /// Executors generally maintain a queue of \"ready\" tasks; `wake_local` should place\n+    /// the associated task onto this queue.\n+    ///\n+    /// # Panics\n+    ///\n+    /// Implementations should avoid panicking, but clients should also be prepared\n+    /// for panics.\n+    ///\n+    /// # Unsafety\n+    ///\n+    /// This function is unsafe to call because it's asserting the `UnsafeWake`\n+    /// value is in a consistent state, i.e. hasn't been dropped, and that the\n+    /// `UnsafeWake` hasn't moved from the thread on which it was created.\n+    unsafe fn wake_local(&self) {\n+        self.wake()\n+    }\n+}\n+\n+/// Information about the currently-running task.\n+///\n+/// Contexts are always tied to the stack, since they are set up specifically\n+/// when performing a single `poll` step on a task.\n+pub struct Context<'a> {\n+    local_waker: &'a LocalWaker,\n+    executor: &'a mut Executor,\n+}\n+\n+impl<'a> fmt::Debug for Context<'a> {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        f.debug_struct(\"Context\")\n+            .finish()\n+    }\n+}\n+\n+impl<'a> Context<'a> {\n+    /// Create a new task `Context` with the provided `local_waker`, `waker`, and `executor`.\n+    #[inline]\n+    pub fn new(local_waker: &'a LocalWaker, executor: &'a mut Executor) -> Context<'a> {\n+        Context {\n+            local_waker,\n+            executor,\n+        }\n+    }\n+\n+    /// Get the `LocalWaker` associated with the current task.\n+    #[inline]\n+    pub fn local_waker(&self) -> &'a LocalWaker {\n+        self.local_waker\n+    }\n+\n+    /// Get the `Waker` associated with the current task.\n+    #[inline]\n+    pub fn waker(&self) -> &'a Waker {\n+        unsafe { &*(self.local_waker as *const LocalWaker as *const Waker) }\n+    }\n+\n+    /// Get the default executor associated with this task.\n+    ///\n+    /// This method is useful primarily if you want to explicitly handle\n+    /// spawn failures.\n+    #[inline]\n+    pub fn executor(&mut self) -> &mut Executor {\n+        self.executor\n+    }\n+\n+    /// Produce a context like the current one, but using the given waker instead.\n+    ///\n+    /// This advanced method is primarily used when building \"internal\n+    /// schedulers\" within a task, where you want to provide some customized\n+    /// wakeup logic.\n+    #[inline]\n+    pub fn with_waker<'b>(&'b mut self, local_waker: &'b LocalWaker) -> Context<'b> {\n+        Context {\n+            local_waker,\n+            executor: self.executor,\n+        }\n+    }\n+\n+    /// Produce a context like the current one, but using the given executor\n+    /// instead.\n+    ///\n+    /// This advanced method is primarily used when building \"internal\n+    /// schedulers\" within a task.\n+    #[inline]\n+    pub fn with_executor<'b, E>(&'b mut self, executor: &'b mut E) -> Context<'b>\n+        where E: Executor\n+    {\n+        Context {\n+            local_waker: self.local_waker,\n+            executor: executor,\n+        }\n+    }\n+}\n+\n+/// A task executor.\n+///\n+/// A *task* is a `()`-producing async value that runs at the top level, and will\n+/// be `poll`ed until completion. It's also the unit at which wake-up\n+/// notifications occur. Executors, such as thread pools, allow tasks to be\n+/// spawned and are responsible for putting tasks onto ready queues when\n+/// they are woken up, and polling them when they are ready.\n+pub trait Executor {\n+    /// Spawn the given task, polling it until completion.\n+    ///\n+    /// # Errors\n+    ///\n+    /// The executor may be unable to spawn tasks, either because it has\n+    /// been shut down or is resource-constrained.\n+    fn spawn_obj(&mut self, task: TaskObj) -> Result<(), SpawnObjError>;\n+\n+    /// Determine whether the executor is able to spawn new tasks.\n+    ///\n+    /// # Returns\n+    ///\n+    /// An `Ok` return means the executor is *likely* (but not guaranteed)\n+    /// to accept a subsequent spawn attempt. Likewise, an `Err` return\n+    /// means that `spawn` is likely, but not guaranteed, to yield an error.\n+    #[inline]\n+    fn status(&self) -> Result<(), SpawnErrorKind> {\n+        Ok(())\n+    }\n+}\n+\n+/// A custom trait object for polling tasks, roughly akin to\n+/// `Box<Future<Output = ()> + Send>`.\n+pub struct TaskObj {\n+    ptr: *mut (),\n+    poll: unsafe fn(*mut (), &mut Context) -> Poll<()>,\n+    drop: unsafe fn(*mut ()),\n+}\n+\n+impl fmt::Debug for TaskObj {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        f.debug_struct(\"TaskObj\")\n+            .finish()\n+    }\n+}\n+\n+unsafe impl Send for TaskObj {}\n+unsafe impl Sync for TaskObj {}\n+\n+/// A custom implementation of a task trait object for `TaskObj`, providing\n+/// a hand-rolled vtable.\n+///\n+/// This custom representation is typically used only in `no_std` contexts,\n+/// where the default `Box`-based implementation is not available.\n+///\n+/// The implementor must guarantee that it is safe to call `poll` repeatedly (in\n+/// a non-concurrent fashion) with the result of `into_raw` until `drop` is\n+/// called.\n+pub unsafe trait UnsafePoll: Send + 'static {\n+    /// Convert a owned instance into a (conceptually owned) void pointer.\n+    fn into_raw(self) -> *mut ();\n+\n+    /// Poll the task represented by the given void pointer.\n+    ///\n+    /// # Safety\n+    ///\n+    /// The trait implementor must guarantee that it is safe to repeatedly call\n+    /// `poll` with the result of `into_raw` until `drop` is called; such calls\n+    /// are not, however, allowed to race with each other or with calls to `drop`.\n+    unsafe fn poll(task: *mut (), cx: &mut Context) -> Poll<()>;\n+\n+    /// Drops the task represented by the given void pointer.\n+    ///\n+    /// # Safety\n+    ///\n+    /// The trait implementor must guarantee that it is safe to call this\n+    /// function once per `into_raw` invocation; that call cannot race with\n+    /// other calls to `drop` or `poll`.\n+    unsafe fn drop(task: *mut ());\n+}\n+\n+impl TaskObj {\n+    /// Create a `TaskObj` from a custom trait object representation.\n+    #[inline]\n+    pub fn from_poll_task<T: UnsafePoll>(t: T) -> TaskObj {\n+        TaskObj {\n+            ptr: t.into_raw(),\n+            poll: T::poll,\n+            drop: T::drop,\n+        }\n+    }\n+\n+    /// Poll the task.\n+    ///\n+    /// The semantics here are identical to that for futures, but unlike\n+    /// futures only an `&mut self` reference is needed here.\n+    #[inline]\n+    pub fn poll_task(&mut self, cx: &mut Context) -> Poll<()> {\n+        unsafe {\n+            (self.poll)(self.ptr, cx)\n+        }\n+    }\n+}\n+\n+impl Drop for TaskObj {\n+    fn drop(&mut self) {\n+        unsafe {\n+            (self.drop)(self.ptr)\n+        }\n+    }\n+}\n+\n+/// Provides the reason that an executor was unable to spawn.\n+pub struct SpawnErrorKind {\n+    _hidden: (),\n+}\n+\n+impl fmt::Debug for SpawnErrorKind {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        f.debug_tuple(\"SpawnErrorKind\")\n+            .field(&\"shutdown\")\n+            .finish()\n+    }\n+}\n+\n+impl SpawnErrorKind {\n+    /// Spawning is failing because the executor has been shut down.\n+    pub fn shutdown() -> SpawnErrorKind {\n+        SpawnErrorKind { _hidden: () }\n+    }\n+\n+    /// Check whether this error is the `shutdown` error.\n+    pub fn is_shutdown(&self) -> bool {\n+        true\n+    }\n+}\n+\n+/// The result of a failed spawn\n+#[derive(Debug)]\n+pub struct SpawnObjError {\n+    /// The kind of error\n+    pub kind: SpawnErrorKind,\n+\n+    /// The task for which spawning was attempted\n+    pub task: TaskObj,\n+}"}, {"sha": "7bbc99b83be5665f91a74c2d401220fec362183a", "filename": "src/libstd/lib.rs", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/19d0b539aa295468a3fde57a02413244f03ab6f6/src%2Flibstd%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/19d0b539aa295468a3fde57a02413244f03ab6f6/src%2Flibstd%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Flib.rs?ref=19d0b539aa295468a3fde57a02413244f03ab6f6", "patch": "@@ -261,6 +261,7 @@\n #![feature(float_from_str_radix)]\n #![feature(fn_traits)]\n #![feature(fnbox)]\n+#![feature(futures_api)]\n #![feature(hashmap_internals)]\n #![feature(heap_api)]\n #![feature(int_error_internals)]\n@@ -282,6 +283,7 @@\n #![feature(panic_internals)]\n #![feature(panic_unwind)]\n #![feature(peek)]\n+#![feature(pin)]\n #![feature(placement_new_protocol)]\n #![feature(prelude_import)]\n #![feature(ptr_internals)]\n@@ -460,6 +462,20 @@ pub use core::u128;\n #[stable(feature = \"core_hint\", since = \"1.27.0\")]\n pub use core::hint;\n \n+#[unstable(feature = \"futures_api\",\n+           reason = \"futures in libcore are unstable\",\n+           issue = \"50547\")]\n+pub mod task {\n+    //! Types and Traits for working with asynchronous tasks.\n+    pub use core::task::*;\n+    pub use alloc_crate::task::*;\n+}\n+\n+#[unstable(feature = \"futures_api\",\n+           reason = \"futures in libcore are unstable\",\n+           issue = \"50547\")]\n+pub use core::future;\n+\n pub mod f32;\n pub mod f64;\n "}, {"sha": "3b5a1725b66cbcd3fd980a2018b0c4d88dd0bf82", "filename": "src/test/run-pass/futures-api.rs", "status": "added", "additions": 95, "deletions": 0, "changes": 95, "blob_url": "https://github.com/rust-lang/rust/blob/19d0b539aa295468a3fde57a02413244f03ab6f6/src%2Ftest%2Frun-pass%2Ffutures-api.rs", "raw_url": "https://github.com/rust-lang/rust/raw/19d0b539aa295468a3fde57a02413244f03ab6f6/src%2Ftest%2Frun-pass%2Ffutures-api.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ffutures-api.rs?ref=19d0b539aa295468a3fde57a02413244f03ab6f6", "patch": "@@ -0,0 +1,95 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(arbitrary_self_types, futures_api, pin)]\n+#![allow(unused)]\n+\n+use std::boxed::PinBox;\n+use std::future::Future;\n+use std::mem::PinMut;\n+use std::rc::Rc;\n+use std::sync::{\n+    Arc,\n+    atomic::{self, AtomicUsize},\n+};\n+use std::task::{\n+    Context, Poll,\n+    Wake, Waker, LocalWaker,\n+    Executor, TaskObj, SpawnObjError,\n+    local_waker, local_waker_from_nonlocal,\n+};\n+\n+struct Counter {\n+    local_wakes: AtomicUsize,\n+    nonlocal_wakes: AtomicUsize,\n+}\n+\n+impl Wake for Counter {\n+    fn wake(this: &Arc<Self>) {\n+        this.nonlocal_wakes.fetch_add(1, atomic::Ordering::SeqCst);\n+    }\n+\n+    unsafe fn wake_local(this: &Arc<Self>) {\n+        this.local_wakes.fetch_add(1, atomic::Ordering::SeqCst);\n+    }\n+}\n+\n+struct NoopExecutor;\n+\n+impl Executor for NoopExecutor {\n+    fn spawn_obj(&mut self, _: TaskObj) -> Result<(), SpawnObjError> {\n+        Ok(())\n+    }\n+}\n+\n+struct MyFuture;\n+\n+impl Future for MyFuture {\n+    type Output = ();\n+    fn poll(self: PinMut<Self>, cx: &mut Context) -> Poll<Self::Output> {\n+        // Ensure all the methods work appropriately\n+        cx.waker().wake();\n+        cx.waker().wake();\n+        cx.local_waker().wake();\n+        cx.executor().spawn_obj(PinBox::new(MyFuture).into()).unwrap();\n+        Poll::Ready(())\n+    }\n+}\n+\n+fn test_local_waker() {\n+    let counter = Arc::new(Counter {\n+        local_wakes: AtomicUsize::new(0),\n+        nonlocal_wakes: AtomicUsize::new(0),\n+    });\n+    let waker = unsafe { local_waker(counter.clone()) };\n+    let executor = &mut NoopExecutor;\n+    let cx = &mut Context::new(&waker, executor);\n+    assert_eq!(Poll::Ready(()), PinMut::new(&mut MyFuture).poll(cx));\n+    assert_eq!(1, counter.local_wakes.load(atomic::Ordering::SeqCst));\n+    assert_eq!(2, counter.nonlocal_wakes.load(atomic::Ordering::SeqCst));\n+}\n+\n+fn test_local_as_nonlocal_waker() {\n+    let counter = Arc::new(Counter {\n+        local_wakes: AtomicUsize::new(0),\n+        nonlocal_wakes: AtomicUsize::new(0),\n+    });\n+    let waker: LocalWaker = local_waker_from_nonlocal(counter.clone());\n+    let executor = &mut NoopExecutor;\n+    let cx = &mut Context::new(&waker, executor);\n+    assert_eq!(Poll::Ready(()), PinMut::new(&mut MyFuture).poll(cx));\n+    assert_eq!(0, counter.local_wakes.load(atomic::Ordering::SeqCst));\n+    assert_eq!(3, counter.nonlocal_wakes.load(atomic::Ordering::SeqCst));\n+}\n+\n+fn main() {\n+    test_local_waker();\n+    test_local_as_nonlocal_waker();\n+}"}]}