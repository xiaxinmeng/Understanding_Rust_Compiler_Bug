{"sha": "7908a1d65496b88626e4b7c193c81d777005d6f3", "node_id": "C_kwDOAAsO6NoAKDc5MDhhMWQ2NTQ5NmI4ODYyNmU0YjdjMTkzYzgxZDc3NzAwNWQ2ZjM", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-04-17T21:50:13Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-04-17T21:50:13Z"}, "message": "Auto merge of #110243 - WaffleLapkin:bless_tagged_pointers\ud83d\ude4f, r=Nilstrieb\n\nTagged pointers, now with strict provenance!\n\nThis is a big refactor of tagged pointers in rustc, with three main goals:\n1. Porting the code to the strict provenance\n2. Cleanup the code\n3. Document the code (and safety invariants) better\n\nThis PR has grown quite a bit (almost a complete rewrite at this point...), so I'm not sure what's the best way to review this, but reviewing commit-by-commit should be fine.\n\nr? `@Nilstrieb`", "tree": {"sha": "57fcc3246403748e7d993152f603dfcabe9c43d4", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/57fcc3246403748e7d993152f603dfcabe9c43d4"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7908a1d65496b88626e4b7c193c81d777005d6f3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7908a1d65496b88626e4b7c193c81d777005d6f3", "html_url": "https://github.com/rust-lang/rust/commit/7908a1d65496b88626e4b7c193c81d777005d6f3", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7908a1d65496b88626e4b7c193c81d777005d6f3/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "56e28e904d6b3404abaaeb65d33636cc35ca3f4b", "url": "https://api.github.com/repos/rust-lang/rust/commits/56e28e904d6b3404abaaeb65d33636cc35ca3f4b", "html_url": "https://github.com/rust-lang/rust/commit/56e28e904d6b3404abaaeb65d33636cc35ca3f4b"}, {"sha": "5571dd061dac07644b9d9a3e799deefbd9971496", "url": "https://api.github.com/repos/rust-lang/rust/commits/5571dd061dac07644b9d9a3e799deefbd9971496", "html_url": "https://github.com/rust-lang/rust/commit/5571dd061dac07644b9d9a3e799deefbd9971496"}], "stats": {"total": 890, "additions": 657, "deletions": 233}, "files": [{"sha": "0e5ecfd9bff6ea836dacdcc144e7e418abe4f45a", "filename": "compiler/rustc_data_structures/src/aligned.rs", "status": "added", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/7908a1d65496b88626e4b7c193c81d777005d6f3/compiler%2Frustc_data_structures%2Fsrc%2Faligned.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7908a1d65496b88626e4b7c193c81d777005d6f3/compiler%2Frustc_data_structures%2Fsrc%2Faligned.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_data_structures%2Fsrc%2Faligned.rs?ref=7908a1d65496b88626e4b7c193c81d777005d6f3", "patch": "@@ -0,0 +1,33 @@\n+use std::ptr::Alignment;\n+\n+/// Returns the ABI-required minimum alignment of a type in bytes.\n+///\n+/// This is equivalent to [`mem::align_of`], but also works for some unsized\n+/// types (e.g. slices or rustc's `List`s).\n+///\n+/// [`mem::align_of`]: std::mem::align_of\n+pub const fn align_of<T: ?Sized + Aligned>() -> Alignment {\n+    T::ALIGN\n+}\n+\n+/// A type with a statically known alignment.\n+///\n+/// # Safety\n+///\n+/// `Self::ALIGN` must be equal to the alignment of `Self`. For sized types it\n+/// is [`mem::align_of<Self>()`], for unsized types it depends on the type, for\n+/// example `[T]` has alignment of `T`.\n+///\n+/// [`mem::align_of<Self>()`]: std::mem::align_of\n+pub unsafe trait Aligned {\n+    /// Alignment of `Self`.\n+    const ALIGN: Alignment;\n+}\n+\n+unsafe impl<T> Aligned for T {\n+    const ALIGN: Alignment = Alignment::of::<Self>();\n+}\n+\n+unsafe impl<T> Aligned for [T] {\n+    const ALIGN: Alignment = Alignment::of::<T>();\n+}"}, {"sha": "7768e0fdeb13b6e9ec6d581727305b5070013240", "filename": "compiler/rustc_data_structures/src/lib.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/7908a1d65496b88626e4b7c193c81d777005d6f3/compiler%2Frustc_data_structures%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7908a1d65496b88626e4b7c193c81d777005d6f3/compiler%2Frustc_data_structures%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_data_structures%2Fsrc%2Flib.rs?ref=7908a1d65496b88626e4b7c193c81d777005d6f3", "patch": "@@ -29,6 +29,8 @@\n #![feature(get_mut_unchecked)]\n #![feature(lint_reasons)]\n #![feature(unwrap_infallible)]\n+#![feature(strict_provenance)]\n+#![feature(ptr_alignment_type)]\n #![allow(rustc::default_hash_types)]\n #![allow(rustc::potential_query_instability)]\n #![deny(rustc::untranslatable_diagnostic)]\n@@ -82,6 +84,7 @@ pub mod transitive_relation;\n pub mod vec_linked_list;\n pub mod work_queue;\n pub use atomic_ref::AtomicRef;\n+pub mod aligned;\n pub mod frozen;\n pub mod owned_slice;\n pub mod sso;"}, {"sha": "c26bffac67823f968f4fb7ab8a45a9af9cdcbd59", "filename": "compiler/rustc_data_structures/src/tagged_ptr.rs", "status": "modified", "additions": 183, "deletions": 87, "changes": 270, "blob_url": "https://github.com/rust-lang/rust/blob/7908a1d65496b88626e4b7c193c81d777005d6f3/compiler%2Frustc_data_structures%2Fsrc%2Ftagged_ptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7908a1d65496b88626e4b7c193c81d777005d6f3/compiler%2Frustc_data_structures%2Fsrc%2Ftagged_ptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_data_structures%2Fsrc%2Ftagged_ptr.rs?ref=7908a1d65496b88626e4b7c193c81d777005d6f3", "patch": "@@ -3,166 +3,262 @@\n //! In order to utilize the pointer packing, you must have two types: a pointer,\n //! and a tag.\n //!\n-//! The pointer must implement the `Pointer` trait, with the primary requirement\n-//! being conversion to and from a usize. Note that the pointer must be\n-//! dereferenceable, so raw pointers generally cannot implement the `Pointer`\n-//! trait. This implies that the pointer must also be nonzero.\n+//! The pointer must implement the [`Pointer`] trait, with the primary\n+//! requirement being convertible to and from a raw pointer. Note that the\n+//! pointer must be dereferenceable, so raw pointers generally cannot implement\n+//! the [`Pointer`] trait. This implies that the pointer must also be non-null.\n //!\n-//! Many common pointer types already implement the `Pointer` trait.\n+//! Many common pointer types already implement the [`Pointer`] trait.\n //!\n-//! The tag must implement the `Tag` trait. We assert that the tag and `Pointer`\n-//! are compatible at compile time.\n+//! The tag must implement the [`Tag`] trait.\n+//!\n+//! We assert that the tag and the [`Pointer`] types are compatible at compile\n+//! time.\n \n-use std::mem::ManuallyDrop;\n use std::ops::Deref;\n+use std::ptr::NonNull;\n use std::rc::Rc;\n use std::sync::Arc;\n \n+use crate::aligned::Aligned;\n+\n mod copy;\n mod drop;\n \n pub use copy::CopyTaggedPtr;\n pub use drop::TaggedPtr;\n \n-/// This describes the pointer type encapsulated by TaggedPtr.\n+/// This describes the pointer type encapsulated by [`TaggedPtr`] and\n+/// [`CopyTaggedPtr`].\n ///\n /// # Safety\n ///\n-/// The usize returned from `into_usize` must be a valid, dereferenceable,\n-/// pointer to `<Self as Deref>::Target`. Note that pointers to `Pointee` must\n-/// be thin, even though `Pointee` may not be sized.\n+/// The pointer returned from [`into_ptr`] must be a [valid], pointer to\n+/// [`<Self as Deref>::Target`].\n ///\n-/// Note that the returned pointer from `into_usize` should be castable to `&mut\n-/// <Self as Deref>::Target` if `Pointer: DerefMut`.\n+/// Note that if `Self` implements [`DerefMut`] the pointer returned from\n+/// [`into_ptr`] must be valid for writes (and thus calling [`NonNull::as_mut`]\n+/// on it must be safe).\n ///\n-/// The BITS constant must be correct. At least `BITS` bits, least-significant,\n-/// must be zero on all returned pointers from `into_usize`.\n+/// The [`BITS`] constant must be correct. [`BITS`] least-significant bits,\n+/// must be zero on all pointers returned from [`into_ptr`].\n ///\n-/// For example, if the alignment of `Pointee` is 2, then `BITS` should be 1.\n+/// For example, if the alignment of [`Self::Target`] is 2, then `BITS` should be 1.\n+///\n+/// [`BITS`]: Pointer::BITS\n+/// [`into_ptr`]: Pointer::into_ptr\n+/// [valid]: std::ptr#safety\n+/// [`<Self as Deref>::Target`]: Deref::Target\n+/// [`Self::Target`]: Deref::Target\n+/// [`DerefMut`]: std::ops::DerefMut\n pub unsafe trait Pointer: Deref {\n+    /// Number of unused (always zero) **least-significant bits** in this\n+    /// pointer, usually related to the pointees alignment.\n+    ///\n+    /// For example if [`BITS`] = `2`, then given `ptr = Self::into_ptr(..)`,\n+    /// `ptr.addr() & 0b11 == 0` must be true.\n+    ///\n     /// Most likely the value you want to use here is the following, unless\n-    /// your Pointee type is unsized (e.g., `ty::List<T>` in rustc) in which\n-    /// case you'll need to manually figure out what the right type to pass to\n-    /// align_of is.\n+    /// your [`Self::Target`] type is unsized (e.g., `ty::List<T>` in rustc)\n+    /// or your pointer is over/under aligned, in which case you'll need to\n+    /// manually figure out what the right type to pass to [`bits_for`] is, or\n+    /// what the value to set here.\n     ///\n-    /// ```ignore UNSOLVED (what to do about the Self)\n+    /// ```rust\n     /// # use std::ops::Deref;\n-    /// std::mem::align_of::<<Self as Deref>::Target>().trailing_zeros() as usize;\n+    /// # use rustc_data_structures::tagged_ptr::bits_for;\n+    /// # struct T;\n+    /// # impl Deref for T { type Target = u8; fn deref(&self) -> &u8 { &0 } }\n+    /// # impl T {\n+    /// const BITS: u32 = bits_for::<<Self as Deref>::Target>();\n+    /// # }\n     /// ```\n-    const BITS: usize;\n-    fn into_usize(self) -> usize;\n+    ///\n+    /// [`BITS`]: Pointer::BITS\n+    /// [`Self::Target`]: Deref::Target\n+    const BITS: u32;\n \n-    /// # Safety\n+    /// Turns this pointer into a raw, non-null pointer.\n+    ///\n+    /// The inverse of this function is [`from_ptr`].\n     ///\n-    /// The passed `ptr` must be returned from `into_usize`.\n+    /// This function guarantees that the least-significant [`Self::BITS`] bits\n+    /// are zero.\n     ///\n-    /// This acts as `ptr::read` semantically, it should not be called more than\n-    /// once on non-`Copy` `Pointer`s.\n-    unsafe fn from_usize(ptr: usize) -> Self;\n+    /// [`from_ptr`]: Pointer::from_ptr\n+    /// [`Self::BITS`]: Pointer::BITS\n+    fn into_ptr(self) -> NonNull<Self::Target>;\n \n-    /// This provides a reference to the `Pointer` itself, rather than the\n-    /// `Deref::Target`. It is used for cases where we want to call methods that\n-    /// may be implement differently for the Pointer than the Pointee (e.g.,\n-    /// `Rc::clone` vs cloning the inner value).\n+    /// Re-creates the original pointer, from a raw pointer returned by [`into_ptr`].\n     ///\n     /// # Safety\n     ///\n-    /// The passed `ptr` must be returned from `into_usize`.\n-    unsafe fn with_ref<R, F: FnOnce(&Self) -> R>(ptr: usize, f: F) -> R;\n+    /// The passed `ptr` must be returned from [`into_ptr`].\n+    ///\n+    /// This acts as [`ptr::read::<Self>()`] semantically, it should not be called more than\n+    /// once on non-[`Copy`] `Pointer`s.\n+    ///\n+    /// [`into_ptr`]: Pointer::into_ptr\n+    /// [`ptr::read::<Self>()`]: std::ptr::read\n+    unsafe fn from_ptr(ptr: NonNull<Self::Target>) -> Self;\n }\n \n-/// This describes tags that the `TaggedPtr` struct can hold.\n+/// This describes tags that the [`TaggedPtr`] struct can hold.\n ///\n /// # Safety\n ///\n-/// The BITS constant must be correct.\n+/// The [`BITS`] constant must be correct.\n+///\n+/// No more than [`BITS`] least-significant bits may be set in the returned usize.\n ///\n-/// No more than `BITS` least significant bits may be set in the returned usize.\n+/// [`BITS`]: Tag::BITS\n pub unsafe trait Tag: Copy {\n-    const BITS: usize;\n+    /// Number of least-significant bits in the return value of [`into_usize`]\n+    /// which may be non-zero. In other words this is the bit width of the\n+    /// value.\n+    ///\n+    /// [`into_usize`]: Tag::into_usize\n+    const BITS: u32;\n \n+    /// Turns this tag into an integer.\n+    ///\n+    /// The inverse of this function is [`from_usize`].\n+    ///\n+    /// This function guarantees that only the least-significant [`Self::BITS`]\n+    /// bits can be non-zero.\n+    ///\n+    /// [`from_usize`]: Tag::from_usize\n+    /// [`Self::BITS`]: Tag::BITS\n     fn into_usize(self) -> usize;\n \n+    /// Re-creates the tag from the integer returned by [`into_usize`].\n+    ///\n     /// # Safety\n     ///\n-    /// The passed `tag` must be returned from `into_usize`.\n+    /// The passed `tag` must be returned from [`into_usize`].\n+    ///\n+    /// [`into_usize`]: Tag::into_usize\n     unsafe fn from_usize(tag: usize) -> Self;\n }\n \n-unsafe impl<T> Pointer for Box<T> {\n-    const BITS: usize = std::mem::align_of::<T>().trailing_zeros() as usize;\n+unsafe impl<T: ?Sized + Aligned> Pointer for Box<T> {\n+    const BITS: u32 = bits_for::<Self::Target>();\n+\n     #[inline]\n-    fn into_usize(self) -> usize {\n-        Box::into_raw(self) as usize\n+    fn into_ptr(self) -> NonNull<T> {\n+        // Safety: pointers from `Box::into_raw` are valid & non-null\n+        unsafe { NonNull::new_unchecked(Box::into_raw(self)) }\n     }\n+\n     #[inline]\n-    unsafe fn from_usize(ptr: usize) -> Self {\n-        Box::from_raw(ptr as *mut T)\n-    }\n-    unsafe fn with_ref<R, F: FnOnce(&Self) -> R>(ptr: usize, f: F) -> R {\n-        let raw = ManuallyDrop::new(Self::from_usize(ptr));\n-        f(&raw)\n+    unsafe fn from_ptr(ptr: NonNull<T>) -> Self {\n+        // Safety: `ptr` comes from `into_ptr` which calls `Box::into_raw`\n+        Box::from_raw(ptr.as_ptr())\n     }\n }\n \n-unsafe impl<T> Pointer for Rc<T> {\n-    const BITS: usize = std::mem::align_of::<T>().trailing_zeros() as usize;\n+unsafe impl<T: ?Sized + Aligned> Pointer for Rc<T> {\n+    const BITS: u32 = bits_for::<Self::Target>();\n+\n     #[inline]\n-    fn into_usize(self) -> usize {\n-        Rc::into_raw(self) as usize\n+    fn into_ptr(self) -> NonNull<T> {\n+        // Safety: pointers from `Rc::into_raw` are valid & non-null\n+        unsafe { NonNull::new_unchecked(Rc::into_raw(self).cast_mut()) }\n+    }\n+\n+    #[inline]\n+    unsafe fn from_ptr(ptr: NonNull<T>) -> Self {\n+        // Safety: `ptr` comes from `into_ptr` which calls `Rc::into_raw`\n+        Rc::from_raw(ptr.as_ptr())\n     }\n+}\n+\n+unsafe impl<T: ?Sized + Aligned> Pointer for Arc<T> {\n+    const BITS: u32 = bits_for::<Self::Target>();\n+\n     #[inline]\n-    unsafe fn from_usize(ptr: usize) -> Self {\n-        Rc::from_raw(ptr as *const T)\n+    fn into_ptr(self) -> NonNull<T> {\n+        // Safety: pointers from `Arc::into_raw` are valid & non-null\n+        unsafe { NonNull::new_unchecked(Arc::into_raw(self).cast_mut()) }\n     }\n-    unsafe fn with_ref<R, F: FnOnce(&Self) -> R>(ptr: usize, f: F) -> R {\n-        let raw = ManuallyDrop::new(Self::from_usize(ptr));\n-        f(&raw)\n+\n+    #[inline]\n+    unsafe fn from_ptr(ptr: NonNull<T>) -> Self {\n+        // Safety: `ptr` comes from `into_ptr` which calls `Arc::into_raw`\n+        Arc::from_raw(ptr.as_ptr())\n     }\n }\n \n-unsafe impl<T> Pointer for Arc<T> {\n-    const BITS: usize = std::mem::align_of::<T>().trailing_zeros() as usize;\n+unsafe impl<'a, T: 'a + ?Sized + Aligned> Pointer for &'a T {\n+    const BITS: u32 = bits_for::<Self::Target>();\n+\n     #[inline]\n-    fn into_usize(self) -> usize {\n-        Arc::into_raw(self) as usize\n+    fn into_ptr(self) -> NonNull<T> {\n+        NonNull::from(self)\n     }\n+\n     #[inline]\n-    unsafe fn from_usize(ptr: usize) -> Self {\n-        Arc::from_raw(ptr as *const T)\n-    }\n-    unsafe fn with_ref<R, F: FnOnce(&Self) -> R>(ptr: usize, f: F) -> R {\n-        let raw = ManuallyDrop::new(Self::from_usize(ptr));\n-        f(&raw)\n+    unsafe fn from_ptr(ptr: NonNull<T>) -> Self {\n+        // Safety:\n+        // `ptr` comes from `into_ptr` which gets the pointer from a reference\n+        ptr.as_ref()\n     }\n }\n \n-unsafe impl<'a, T: 'a> Pointer for &'a T {\n-    const BITS: usize = std::mem::align_of::<T>().trailing_zeros() as usize;\n+unsafe impl<'a, T: 'a + ?Sized + Aligned> Pointer for &'a mut T {\n+    const BITS: u32 = bits_for::<Self::Target>();\n+\n     #[inline]\n-    fn into_usize(self) -> usize {\n-        self as *const T as usize\n+    fn into_ptr(self) -> NonNull<T> {\n+        NonNull::from(self)\n     }\n+\n     #[inline]\n-    unsafe fn from_usize(ptr: usize) -> Self {\n-        &*(ptr as *const T)\n-    }\n-    unsafe fn with_ref<R, F: FnOnce(&Self) -> R>(ptr: usize, f: F) -> R {\n-        f(&*(&ptr as *const usize as *const Self))\n+    unsafe fn from_ptr(mut ptr: NonNull<T>) -> Self {\n+        // Safety:\n+        // `ptr` comes from `into_ptr` which gets the pointer from a reference\n+        ptr.as_mut()\n     }\n }\n \n-unsafe impl<'a, T: 'a> Pointer for &'a mut T {\n-    const BITS: usize = std::mem::align_of::<T>().trailing_zeros() as usize;\n-    #[inline]\n+/// Returns the number of bits available for use for tags in a pointer to `T`\n+/// (this is based on `T`'s alignment).\n+pub const fn bits_for<T: ?Sized + Aligned>() -> u32 {\n+    crate::aligned::align_of::<T>().as_nonzero().trailing_zeros()\n+}\n+\n+/// A tag type used in [`CopyTaggedPtr`] and [`TaggedPtr`] tests.\n+#[derive(Copy, Clone, Debug, PartialEq, Eq)]\n+#[cfg(test)]\n+enum Tag2 {\n+    B00 = 0b00,\n+    B01 = 0b01,\n+    B10 = 0b10,\n+    B11 = 0b11,\n+}\n+\n+#[cfg(test)]\n+unsafe impl Tag for Tag2 {\n+    const BITS: u32 = 2;\n+\n     fn into_usize(self) -> usize {\n-        self as *mut T as usize\n+        self as _\n     }\n-    #[inline]\n-    unsafe fn from_usize(ptr: usize) -> Self {\n-        &mut *(ptr as *mut T)\n+\n+    unsafe fn from_usize(tag: usize) -> Self {\n+        match tag {\n+            0b00 => Tag2::B00,\n+            0b01 => Tag2::B01,\n+            0b10 => Tag2::B10,\n+            0b11 => Tag2::B11,\n+            _ => unreachable!(),\n+        }\n     }\n-    unsafe fn with_ref<R, F: FnOnce(&Self) -> R>(ptr: usize, f: F) -> R {\n-        f(&*(&ptr as *const usize as *const Self))\n+}\n+\n+#[cfg(test)]\n+impl<HCX> crate::stable_hasher::HashStable<HCX> for Tag2 {\n+    fn hash_stable(&self, hcx: &mut HCX, hasher: &mut crate::stable_hasher::StableHasher) {\n+        (*self as u8).hash_stable(hcx, hasher);\n     }\n }"}, {"sha": "691e92f196a2677601bec7ffddb2a6a584019023", "filename": "compiler/rustc_data_structures/src/tagged_ptr/copy.rs", "status": "modified", "additions": 223, "deletions": 89, "changes": 312, "blob_url": "https://github.com/rust-lang/rust/blob/7908a1d65496b88626e4b7c193c81d777005d6f3/compiler%2Frustc_data_structures%2Fsrc%2Ftagged_ptr%2Fcopy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7908a1d65496b88626e4b7c193c81d777005d6f3/compiler%2Frustc_data_structures%2Fsrc%2Ftagged_ptr%2Fcopy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_data_structures%2Fsrc%2Ftagged_ptr%2Fcopy.rs?ref=7908a1d65496b88626e4b7c193c81d777005d6f3", "patch": "@@ -1,78 +1,92 @@\n use super::{Pointer, Tag};\n use crate::stable_hasher::{HashStable, StableHasher};\n use std::fmt;\n+use std::hash::{Hash, Hasher};\n use std::marker::PhantomData;\n+use std::mem::ManuallyDrop;\n use std::num::NonZeroUsize;\n+use std::ops::{Deref, DerefMut};\n+use std::ptr::NonNull;\n \n-/// A `Copy` TaggedPtr.\n+/// A [`Copy`] tagged pointer.\n ///\n-/// You should use this instead of the `TaggedPtr` type in all cases where\n-/// `P: Copy`.\n+/// This is essentially `{ pointer: P, tag: T }` packed in a single pointer.\n+///\n+/// You should use this instead of the [`TaggedPtr`] type in all cases where\n+/// `P` implements [`Copy`].\n ///\n /// If `COMPARE_PACKED` is true, then the pointers will be compared and hashed without\n-/// unpacking. Otherwise we don't implement PartialEq/Eq/Hash; if you want that,\n-/// wrap the TaggedPtr.\n+/// unpacking. Otherwise we don't implement [`PartialEq`], [`Eq`] and [`Hash`];\n+/// if you want that, wrap the [`CopyTaggedPtr`].\n+///\n+/// [`TaggedPtr`]: crate::tagged_ptr::TaggedPtr\n pub struct CopyTaggedPtr<P, T, const COMPARE_PACKED: bool>\n where\n     P: Pointer,\n     T: Tag,\n {\n-    packed: NonZeroUsize,\n-    data: PhantomData<(P, T)>,\n-}\n-\n-impl<P, T, const COMPARE_PACKED: bool> Copy for CopyTaggedPtr<P, T, COMPARE_PACKED>\n-where\n-    P: Pointer,\n-    T: Tag,\n-    P: Copy,\n-{\n-}\n-\n-impl<P, T, const COMPARE_PACKED: bool> Clone for CopyTaggedPtr<P, T, COMPARE_PACKED>\n-where\n-    P: Pointer,\n-    T: Tag,\n-    P: Copy,\n-{\n-    fn clone(&self) -> Self {\n-        *self\n-    }\n+    /// This is semantically a pair of `pointer: P` and `tag: T` fields,\n+    /// however we pack them in a single pointer, to save space.\n+    ///\n+    /// We pack the tag into the **most**-significant bits of the pointer to\n+    /// ease retrieval of the value. A left shift is a multiplication and\n+    /// those are embeddable in instruction encoding, for example:\n+    ///\n+    /// ```asm\n+    /// // (<https://godbolt.org/z/jqcYPWEr3>)\n+    /// example::shift_read3:\n+    ///     mov     eax, dword ptr [8*rdi]\n+    ///     ret\n+    ///\n+    /// example::mask_read3:\n+    ///     and     rdi, -8\n+    ///     mov     eax, dword ptr [rdi]\n+    ///     ret\n+    /// ```\n+    ///\n+    /// This is ASM outputted by rustc for reads of values behind tagged\n+    /// pointers for different approaches of tagging:\n+    /// - `shift_read3` uses `<< 3` (the tag is in the most-significant bits)\n+    /// - `mask_read3` uses `& !0b111` (the tag is in the least-significant bits)\n+    ///\n+    /// The shift approach thus produces less instructions and is likely faster\n+    /// (see <https://godbolt.org/z/Y913sMdWb>).\n+    ///\n+    /// Encoding diagram:\n+    /// ```text\n+    /// [ packed.addr                     ]\n+    /// [ tag ] [ pointer.addr >> T::BITS ] <-- usize::BITS - T::BITS bits\n+    ///    ^\n+    ///    |\n+    /// T::BITS bits\n+    /// ```\n+    ///\n+    /// The tag can be retrieved by `packed.addr() >> T::BITS` and the pointer\n+    /// can be retrieved by `packed.map_addr(|addr| addr << T::BITS)`.\n+    packed: NonNull<P::Target>,\n+    tag_ghost: PhantomData<T>,\n }\n \n-// We pack the tag into the *upper* bits of the pointer to ease retrieval of the\n-// value; a left shift is a multiplication and those are embeddable in\n-// instruction encoding.\n-impl<P, T, const COMPARE_PACKED: bool> CopyTaggedPtr<P, T, COMPARE_PACKED>\n+// Note that even though `CopyTaggedPtr` is only really expected to work with\n+// `P: Copy`, can't add `P: Copy` bound, because `CopyTaggedPtr` is used in the\n+// `TaggedPtr`'s implementation.\n+impl<P, T, const CP: bool> CopyTaggedPtr<P, T, CP>\n where\n     P: Pointer,\n     T: Tag,\n {\n-    const TAG_BIT_SHIFT: usize = usize::BITS as usize - T::BITS;\n-    const ASSERTION: () = {\n-        assert!(T::BITS <= P::BITS);\n-        // Used for the transmute_copy's below\n-        assert!(std::mem::size_of::<&P::Target>() == std::mem::size_of::<usize>());\n-    };\n-\n+    /// Tags `pointer` with `tag`.\n+    ///\n+    /// Note that this leaks `pointer`: it won't be dropped when\n+    /// `CopyTaggedPtr` is dropped. If you have a pointer with a significant\n+    /// drop, use [`TaggedPtr`] instead.\n+    ///\n+    /// [`TaggedPtr`]: crate::tagged_ptr::TaggedPtr\n     pub fn new(pointer: P, tag: T) -> Self {\n-        // Trigger assert!\n-        let () = Self::ASSERTION;\n-        let packed_tag = tag.into_usize() << Self::TAG_BIT_SHIFT;\n-\n-        Self {\n-            // SAFETY: We know that the pointer is non-null, as it must be\n-            // dereferenceable per `Pointer` safety contract.\n-            packed: unsafe {\n-                NonZeroUsize::new_unchecked((P::into_usize(pointer) >> T::BITS) | packed_tag)\n-            },\n-            data: PhantomData,\n-        }\n+        Self { packed: Self::pack(P::into_ptr(pointer), tag), tag_ghost: PhantomData }\n     }\n \n-    pub(super) fn pointer_raw(&self) -> usize {\n-        self.packed.get() << T::BITS\n-    }\n+    /// Retrieves the pointer.\n     pub fn pointer(self) -> P\n     where\n         P: Copy,\n@@ -81,66 +95,138 @@ where\n         //\n         // Note that this isn't going to double-drop or anything because we have\n         // P: Copy\n-        unsafe { P::from_usize(self.pointer_raw()) }\n-    }\n-    pub fn pointer_ref(&self) -> &P::Target {\n-        // SAFETY: pointer_raw returns the original pointer\n-        unsafe { std::mem::transmute_copy(&self.pointer_raw()) }\n-    }\n-    pub fn pointer_mut(&mut self) -> &mut P::Target\n-    where\n-        P: std::ops::DerefMut,\n-    {\n-        // SAFETY: pointer_raw returns the original pointer\n-        unsafe { std::mem::transmute_copy(&self.pointer_raw()) }\n+        unsafe { P::from_ptr(self.pointer_raw()) }\n     }\n+\n+    /// Retrieves the tag.\n     #[inline]\n     pub fn tag(&self) -> T {\n-        unsafe { T::from_usize(self.packed.get() >> Self::TAG_BIT_SHIFT) }\n+        // Unpack the tag, according to the `self.packed` encoding scheme\n+        let tag = self.packed.addr().get() >> Self::TAG_BIT_SHIFT;\n+\n+        // Safety:\n+        // The shift retrieves the original value from `T::into_usize`,\n+        // satisfying `T::from_usize`'s preconditions.\n+        unsafe { T::from_usize(tag) }\n     }\n+\n+    /// Sets the tag to a new value.\n     #[inline]\n     pub fn set_tag(&mut self, tag: T) {\n-        let mut packed = self.packed.get();\n-        let new_tag = T::into_usize(tag) << Self::TAG_BIT_SHIFT;\n-        let tag_mask = (1 << T::BITS) - 1;\n-        packed &= !(tag_mask << Self::TAG_BIT_SHIFT);\n-        packed |= new_tag;\n-        self.packed = unsafe { NonZeroUsize::new_unchecked(packed) };\n+        self.packed = Self::pack(self.pointer_raw(), tag);\n+    }\n+\n+    const TAG_BIT_SHIFT: u32 = usize::BITS - T::BITS;\n+    const ASSERTION: () = { assert!(T::BITS <= P::BITS) };\n+\n+    /// Pack pointer `ptr` that comes from [`P::into_ptr`] with a `tag`,\n+    /// according to `self.packed` encoding scheme.\n+    ///\n+    /// [`P::into_ptr`]: Pointer::into_ptr\n+    fn pack(ptr: NonNull<P::Target>, tag: T) -> NonNull<P::Target> {\n+        // Trigger assert!\n+        let () = Self::ASSERTION;\n+\n+        let packed_tag = tag.into_usize() << Self::TAG_BIT_SHIFT;\n+\n+        ptr.map_addr(|addr| {\n+            // Safety:\n+            // - The pointer is `NonNull` => it's address is `NonZeroUsize`\n+            // - `P::BITS` least significant bits are always zero (`Pointer` contract)\n+            // - `T::BITS <= P::BITS` (from `Self::ASSERTION`)\n+            //\n+            // Thus `addr >> T::BITS` is guaranteed to be non-zero.\n+            //\n+            // `{non_zero} | packed_tag` can't make the value zero.\n+\n+            let packed = (addr.get() >> T::BITS) | packed_tag;\n+            unsafe { NonZeroUsize::new_unchecked(packed) }\n+        })\n+    }\n+\n+    /// Retrieves the original raw pointer from `self.packed`.\n+    pub(super) fn pointer_raw(&self) -> NonNull<P::Target> {\n+        self.packed.map_addr(|addr| unsafe { NonZeroUsize::new_unchecked(addr.get() << T::BITS) })\n+    }\n+\n+    /// This provides a reference to the `P` pointer itself, rather than the\n+    /// `Deref::Target`. It is used for cases where we want to call methods\n+    /// that may be implement differently for the Pointer than the Pointee\n+    /// (e.g., `Rc::clone` vs cloning the inner value).\n+    pub(super) fn with_pointer_ref<R>(&self, f: impl FnOnce(&P) -> R) -> R {\n+        // Safety:\n+        // - `self.raw.pointer_raw()` is originally returned from `P::into_ptr`\n+        //   and as such is valid for `P::from_ptr`.\n+        //   - This also allows us to not care whatever `f` panics or not.\n+        // - Even though we create a copy of the pointer, we store it inside\n+        //   `ManuallyDrop` and only access it by-ref, so we don't double-drop.\n+        //\n+        // Semantically this is just `f(&self.pointer)` (where `self.pointer`\n+        // is non-packed original pointer).\n+        //\n+        // Note that even though `CopyTaggedPtr` is only really expected to\n+        // work with `P: Copy`, we have to assume `P: ?Copy`, because\n+        // `CopyTaggedPtr` is used in the `TaggedPtr`'s implementation.\n+        let ptr = unsafe { ManuallyDrop::new(P::from_ptr(self.pointer_raw())) };\n+        f(&ptr)\n     }\n }\n \n-impl<P, T, const COMPARE_PACKED: bool> std::ops::Deref for CopyTaggedPtr<P, T, COMPARE_PACKED>\n+impl<P, T, const CP: bool> Copy for CopyTaggedPtr<P, T, CP>\n+where\n+    P: Pointer + Copy,\n+    T: Tag,\n+{\n+}\n+\n+impl<P, T, const CP: bool> Clone for CopyTaggedPtr<P, T, CP>\n+where\n+    P: Pointer + Copy,\n+    T: Tag,\n+{\n+    fn clone(&self) -> Self {\n+        *self\n+    }\n+}\n+\n+impl<P, T, const CP: bool> Deref for CopyTaggedPtr<P, T, CP>\n where\n     P: Pointer,\n     T: Tag,\n {\n     type Target = P::Target;\n+\n     fn deref(&self) -> &Self::Target {\n-        self.pointer_ref()\n+        // Safety:\n+        // `pointer_raw` returns the original pointer from `P::into_ptr` which,\n+        // by the `Pointer`'s contract, must be valid.\n+        unsafe { self.pointer_raw().as_ref() }\n     }\n }\n \n-impl<P, T, const COMPARE_PACKED: bool> std::ops::DerefMut for CopyTaggedPtr<P, T, COMPARE_PACKED>\n+impl<P, T, const CP: bool> DerefMut for CopyTaggedPtr<P, T, CP>\n where\n-    P: Pointer + std::ops::DerefMut,\n+    P: Pointer + DerefMut,\n     T: Tag,\n {\n     fn deref_mut(&mut self) -> &mut Self::Target {\n-        self.pointer_mut()\n+        // Safety:\n+        // `pointer_raw` returns the original pointer from `P::into_ptr` which,\n+        // by the `Pointer`'s contract, must be valid for writes if\n+        // `P: DerefMut`.\n+        unsafe { self.pointer_raw().as_mut() }\n     }\n }\n \n-impl<P, T, const COMPARE_PACKED: bool> fmt::Debug for CopyTaggedPtr<P, T, COMPARE_PACKED>\n+impl<P, T, const CP: bool> fmt::Debug for CopyTaggedPtr<P, T, CP>\n where\n-    P: Pointer,\n-    P::Target: fmt::Debug,\n+    P: Pointer + fmt::Debug,\n     T: Tag + fmt::Debug,\n {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        f.debug_struct(\"CopyTaggedPtr\")\n-            .field(\"pointer\", &self.pointer_ref())\n-            .field(\"tag\", &self.tag())\n-            .finish()\n+        self.with_pointer_ref(|ptr| {\n+            f.debug_struct(\"CopyTaggedPtr\").field(\"pointer\", ptr).field(\"tag\", &self.tag()).finish()\n+        })\n     }\n }\n \n@@ -161,25 +247,73 @@ where\n {\n }\n \n-impl<P, T> std::hash::Hash for CopyTaggedPtr<P, T, true>\n+impl<P, T> Hash for CopyTaggedPtr<P, T, true>\n where\n     P: Pointer,\n     T: Tag,\n {\n-    fn hash<H: std::hash::Hasher>(&self, state: &mut H) {\n+    fn hash<H: Hasher>(&self, state: &mut H) {\n         self.packed.hash(state);\n     }\n }\n \n-impl<P, T, HCX, const COMPARE_PACKED: bool> HashStable<HCX> for CopyTaggedPtr<P, T, COMPARE_PACKED>\n+impl<P, T, HCX, const CP: bool> HashStable<HCX> for CopyTaggedPtr<P, T, CP>\n where\n     P: Pointer + HashStable<HCX>,\n     T: Tag + HashStable<HCX>,\n {\n     fn hash_stable(&self, hcx: &mut HCX, hasher: &mut StableHasher) {\n-        unsafe {\n-            Pointer::with_ref(self.pointer_raw(), |p: &P| p.hash_stable(hcx, hasher));\n-        }\n+        self.with_pointer_ref(|ptr| ptr.hash_stable(hcx, hasher));\n         self.tag().hash_stable(hcx, hasher);\n     }\n }\n+\n+// Safety:\n+// `CopyTaggedPtr<P, T, ..>` is semantically just `{ ptr: P, tag: T }`, as such\n+// it's ok to implement `Sync` as long as `P: Sync, T: Sync`\n+unsafe impl<P, T, const CP: bool> Sync for CopyTaggedPtr<P, T, CP>\n+where\n+    P: Sync + Pointer,\n+    T: Sync + Tag,\n+{\n+}\n+\n+// Safety:\n+// `CopyTaggedPtr<P, T, ..>` is semantically just `{ ptr: P, tag: T }`, as such\n+// it's ok to implement `Send` as long as `P: Send, T: Send`\n+unsafe impl<P, T, const CP: bool> Send for CopyTaggedPtr<P, T, CP>\n+where\n+    P: Send + Pointer,\n+    T: Send + Tag,\n+{\n+}\n+\n+/// Test that `new` does not compile if there is not enough alignment for the\n+/// tag in the pointer.\n+///\n+/// ```compile_fail,E0080\n+/// use rustc_data_structures::tagged_ptr::{CopyTaggedPtr, Tag};\n+///\n+/// #[derive(Copy, Clone, Debug, PartialEq, Eq)]\n+/// enum Tag2 { B00 = 0b00, B01 = 0b01, B10 = 0b10, B11 = 0b11 };\n+///\n+/// unsafe impl Tag for Tag2 {\n+///     const BITS: u32 = 2;\n+///\n+///     fn into_usize(self) -> usize { todo!() }\n+///     unsafe fn from_usize(tag: usize) -> Self { todo!() }\n+/// }\n+///\n+/// let value = 12u16;\n+/// let reference = &value;\n+/// let tag = Tag2::B01;\n+///\n+/// let _ptr = CopyTaggedPtr::<_, _, true>::new(reference, tag);\n+/// ```\n+// For some reason miri does not get the compile error\n+// probably it `check`s instead of `build`ing?\n+#[cfg(not(miri))]\n+const _: () = ();\n+\n+#[cfg(test)]\n+mod tests;"}, {"sha": "bfcc2e603de43cc433b7d8262e79095b0747eefb", "filename": "compiler/rustc_data_structures/src/tagged_ptr/copy/tests.rs", "status": "added", "additions": 50, "deletions": 0, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/7908a1d65496b88626e4b7c193c81d777005d6f3/compiler%2Frustc_data_structures%2Fsrc%2Ftagged_ptr%2Fcopy%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7908a1d65496b88626e4b7c193c81d777005d6f3/compiler%2Frustc_data_structures%2Fsrc%2Ftagged_ptr%2Fcopy%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_data_structures%2Fsrc%2Ftagged_ptr%2Fcopy%2Ftests.rs?ref=7908a1d65496b88626e4b7c193c81d777005d6f3", "patch": "@@ -0,0 +1,50 @@\n+use std::ptr;\n+\n+use crate::stable_hasher::{HashStable, StableHasher};\n+use crate::tagged_ptr::{CopyTaggedPtr, Pointer, Tag, Tag2};\n+\n+#[test]\n+fn smoke() {\n+    let value = 12u32;\n+    let reference = &value;\n+    let tag = Tag2::B01;\n+\n+    let ptr = tag_ptr(reference, tag);\n+\n+    assert_eq!(ptr.tag(), tag);\n+    assert_eq!(*ptr, 12);\n+    assert!(ptr::eq(ptr.pointer(), reference));\n+\n+    let copy = ptr;\n+\n+    let mut ptr = ptr;\n+    ptr.set_tag(Tag2::B00);\n+    assert_eq!(ptr.tag(), Tag2::B00);\n+\n+    assert_eq!(copy.tag(), tag);\n+    assert_eq!(*copy, 12);\n+    assert!(ptr::eq(copy.pointer(), reference));\n+}\n+\n+#[test]\n+fn stable_hash_hashes_as_tuple() {\n+    let hash_packed = {\n+        let mut hasher = StableHasher::new();\n+        tag_ptr(&12, Tag2::B11).hash_stable(&mut (), &mut hasher);\n+\n+        hasher.finalize()\n+    };\n+\n+    let hash_tupled = {\n+        let mut hasher = StableHasher::new();\n+        (&12, Tag2::B11).hash_stable(&mut (), &mut hasher);\n+        hasher.finalize()\n+    };\n+\n+    assert_eq!(hash_packed, hash_tupled);\n+}\n+\n+/// Helper to create tagged pointers without specifying `COMPARE_PACKED` if it does not matter.\n+fn tag_ptr<P: Pointer, T: Tag>(ptr: P, tag: T) -> CopyTaggedPtr<P, T, true> {\n+    CopyTaggedPtr::new(ptr, tag)\n+}"}, {"sha": "d418c06b7ebb4ac463379562753f9c92d83ecf7b", "filename": "compiler/rustc_data_structures/src/tagged_ptr/drop.rs", "status": "modified", "additions": 77, "deletions": 39, "changes": 116, "blob_url": "https://github.com/rust-lang/rust/blob/7908a1d65496b88626e4b7c193c81d777005d6f3/compiler%2Frustc_data_structures%2Fsrc%2Ftagged_ptr%2Fdrop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7908a1d65496b88626e4b7c193c81d777005d6f3/compiler%2Frustc_data_structures%2Fsrc%2Ftagged_ptr%2Fdrop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_data_structures%2Fsrc%2Ftagged_ptr%2Fdrop.rs?ref=7908a1d65496b88626e4b7c193c81d777005d6f3", "patch": "@@ -1,14 +1,21 @@\n-use super::{Pointer, Tag};\n-use crate::stable_hasher::{HashStable, StableHasher};\n use std::fmt;\n+use std::hash::{Hash, Hasher};\n+use std::ops::{Deref, DerefMut};\n \n use super::CopyTaggedPtr;\n+use super::{Pointer, Tag};\n+use crate::stable_hasher::{HashStable, StableHasher};\n \n-/// A TaggedPtr implementing `Drop`.\n+/// A tagged pointer that supports pointers that implement [`Drop`].\n+///\n+/// This is essentially `{ pointer: P, tag: T }` packed in a single pointer.\n+///\n+/// You should use [`CopyTaggedPtr`] instead of the this type in all cases\n+/// where `P` implements [`Copy`].\n ///\n /// If `COMPARE_PACKED` is true, then the pointers will be compared and hashed without\n-/// unpacking. Otherwise we don't implement PartialEq/Eq/Hash; if you want that,\n-/// wrap the TaggedPtr.\n+/// unpacking. Otherwise we don't implement [`PartialEq`], [`Eq`] and [`Hash`];\n+/// if you want that, wrap the [`TaggedPtr`].\n pub struct TaggedPtr<P, T, const COMPARE_PACKED: bool>\n where\n     P: Pointer,\n@@ -17,81 +24,82 @@ where\n     raw: CopyTaggedPtr<P, T, COMPARE_PACKED>,\n }\n \n-impl<P, T, const COMPARE_PACKED: bool> Clone for TaggedPtr<P, T, COMPARE_PACKED>\n-where\n-    P: Pointer + Clone,\n-    T: Tag,\n-{\n-    fn clone(&self) -> Self {\n-        unsafe { Self::new(P::with_ref(self.raw.pointer_raw(), |p| p.clone()), self.raw.tag()) }\n-    }\n-}\n-\n-// We pack the tag into the *upper* bits of the pointer to ease retrieval of the\n-// value; a right shift is a multiplication and those are embeddable in\n-// instruction encoding.\n-impl<P, T, const COMPARE_PACKED: bool> TaggedPtr<P, T, COMPARE_PACKED>\n+impl<P, T, const CP: bool> TaggedPtr<P, T, CP>\n where\n     P: Pointer,\n     T: Tag,\n {\n+    /// Tags `pointer` with `tag`.\n     pub fn new(pointer: P, tag: T) -> Self {\n         TaggedPtr { raw: CopyTaggedPtr::new(pointer, tag) }\n     }\n \n-    pub fn pointer_ref(&self) -> &P::Target {\n-        self.raw.pointer_ref()\n-    }\n+    /// Retrieves the tag.\n     pub fn tag(&self) -> T {\n         self.raw.tag()\n     }\n+\n+    /// Sets the tag to a new value.\n+    pub fn set_tag(&mut self, tag: T) {\n+        self.raw.set_tag(tag)\n+    }\n }\n \n-impl<P, T, const COMPARE_PACKED: bool> std::ops::Deref for TaggedPtr<P, T, COMPARE_PACKED>\n+impl<P, T, const CP: bool> Clone for TaggedPtr<P, T, CP>\n+where\n+    P: Pointer + Clone,\n+    T: Tag,\n+{\n+    fn clone(&self) -> Self {\n+        let ptr = self.raw.with_pointer_ref(P::clone);\n+\n+        Self::new(ptr, self.tag())\n+    }\n+}\n+\n+impl<P, T, const CP: bool> Deref for TaggedPtr<P, T, CP>\n where\n     P: Pointer,\n     T: Tag,\n {\n     type Target = P::Target;\n     fn deref(&self) -> &Self::Target {\n-        self.raw.pointer_ref()\n+        self.raw.deref()\n     }\n }\n \n-impl<P, T, const COMPARE_PACKED: bool> std::ops::DerefMut for TaggedPtr<P, T, COMPARE_PACKED>\n+impl<P, T, const CP: bool> DerefMut for TaggedPtr<P, T, CP>\n where\n-    P: Pointer + std::ops::DerefMut,\n+    P: Pointer + DerefMut,\n     T: Tag,\n {\n     fn deref_mut(&mut self) -> &mut Self::Target {\n-        self.raw.pointer_mut()\n+        self.raw.deref_mut()\n     }\n }\n \n-impl<P, T, const COMPARE_PACKED: bool> Drop for TaggedPtr<P, T, COMPARE_PACKED>\n+impl<P, T, const CP: bool> Drop for TaggedPtr<P, T, CP>\n where\n     P: Pointer,\n     T: Tag,\n {\n     fn drop(&mut self) {\n         // No need to drop the tag, as it's Copy\n         unsafe {\n-            drop(P::from_usize(self.raw.pointer_raw()));\n+            drop(P::from_ptr(self.raw.pointer_raw()));\n         }\n     }\n }\n \n-impl<P, T, const COMPARE_PACKED: bool> fmt::Debug for TaggedPtr<P, T, COMPARE_PACKED>\n+impl<P, T, const CP: bool> fmt::Debug for TaggedPtr<P, T, CP>\n where\n-    P: Pointer,\n-    P::Target: fmt::Debug,\n+    P: Pointer + fmt::Debug,\n     T: Tag + fmt::Debug,\n {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        f.debug_struct(\"TaggedPtr\")\n-            .field(\"pointer\", &self.pointer_ref())\n-            .field(\"tag\", &self.tag())\n-            .finish()\n+        self.raw.with_pointer_ref(|ptr| {\n+            f.debug_struct(\"TaggedPtr\").field(\"pointer\", ptr).field(\"tag\", &self.tag()).finish()\n+        })\n     }\n }\n \n@@ -112,17 +120,17 @@ where\n {\n }\n \n-impl<P, T> std::hash::Hash for TaggedPtr<P, T, true>\n+impl<P, T> Hash for TaggedPtr<P, T, true>\n where\n     P: Pointer,\n     T: Tag,\n {\n-    fn hash<H: std::hash::Hasher>(&self, state: &mut H) {\n+    fn hash<H: Hasher>(&self, state: &mut H) {\n         self.raw.hash(state);\n     }\n }\n \n-impl<P, T, HCX, const COMPARE_PACKED: bool> HashStable<HCX> for TaggedPtr<P, T, COMPARE_PACKED>\n+impl<P, T, HCX, const CP: bool> HashStable<HCX> for TaggedPtr<P, T, CP>\n where\n     P: Pointer + HashStable<HCX>,\n     T: Tag + HashStable<HCX>,\n@@ -131,3 +139,33 @@ where\n         self.raw.hash_stable(hcx, hasher);\n     }\n }\n+\n+/// Test that `new` does not compile if there is not enough alignment for the\n+/// tag in the pointer.\n+///\n+/// ```compile_fail,E0080\n+/// use rustc_data_structures::tagged_ptr::{TaggedPtr, Tag};\n+///\n+/// #[derive(Copy, Clone, Debug, PartialEq, Eq)]\n+/// enum Tag2 { B00 = 0b00, B01 = 0b01, B10 = 0b10, B11 = 0b11 };\n+///\n+/// unsafe impl Tag for Tag2 {\n+///     const BITS: u32 = 2;\n+///\n+///     fn into_usize(self) -> usize { todo!() }\n+///     unsafe fn from_usize(tag: usize) -> Self { todo!() }\n+/// }\n+///\n+/// let value = 12u16;\n+/// let reference = &value;\n+/// let tag = Tag2::B01;\n+///\n+/// let _ptr = TaggedPtr::<_, _, true>::new(reference, tag);\n+/// ```\n+// For some reason miri does not get the compile error\n+// probably it `check`s instead of `build`ing?\n+#[cfg(not(miri))]\n+const _: () = ();\n+\n+#[cfg(test)]\n+mod tests;"}, {"sha": "2c17d678d3aa0ae6c84848ca5a5dd66aba95cc53", "filename": "compiler/rustc_data_structures/src/tagged_ptr/drop/tests.rs", "status": "added", "additions": 71, "deletions": 0, "changes": 71, "blob_url": "https://github.com/rust-lang/rust/blob/7908a1d65496b88626e4b7c193c81d777005d6f3/compiler%2Frustc_data_structures%2Fsrc%2Ftagged_ptr%2Fdrop%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7908a1d65496b88626e4b7c193c81d777005d6f3/compiler%2Frustc_data_structures%2Fsrc%2Ftagged_ptr%2Fdrop%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_data_structures%2Fsrc%2Ftagged_ptr%2Fdrop%2Ftests.rs?ref=7908a1d65496b88626e4b7c193c81d777005d6f3", "patch": "@@ -0,0 +1,71 @@\n+use std::{ptr, sync::Arc};\n+\n+use crate::tagged_ptr::{Pointer, Tag, Tag2, TaggedPtr};\n+\n+#[test]\n+fn smoke() {\n+    let value = 12u32;\n+    let reference = &value;\n+    let tag = Tag2::B01;\n+\n+    let ptr = tag_ptr(reference, tag);\n+\n+    assert_eq!(ptr.tag(), tag);\n+    assert_eq!(*ptr, 12);\n+\n+    let clone = ptr.clone();\n+    assert_eq!(clone.tag(), tag);\n+    assert_eq!(*clone, 12);\n+\n+    let mut ptr = ptr;\n+    ptr.set_tag(Tag2::B00);\n+    assert_eq!(ptr.tag(), Tag2::B00);\n+\n+    assert_eq!(clone.tag(), tag);\n+    assert_eq!(*clone, 12);\n+    assert!(ptr::eq(&*ptr, &*clone))\n+}\n+\n+#[test]\n+fn boxed() {\n+    let value = 12u32;\n+    let boxed = Box::new(value);\n+    let tag = Tag2::B01;\n+\n+    let ptr = tag_ptr(boxed, tag);\n+\n+    assert_eq!(ptr.tag(), tag);\n+    assert_eq!(*ptr, 12);\n+\n+    let clone = ptr.clone();\n+    assert_eq!(clone.tag(), tag);\n+    assert_eq!(*clone, 12);\n+\n+    let mut ptr = ptr;\n+    ptr.set_tag(Tag2::B00);\n+    assert_eq!(ptr.tag(), Tag2::B00);\n+\n+    assert_eq!(clone.tag(), tag);\n+    assert_eq!(*clone, 12);\n+    assert!(!ptr::eq(&*ptr, &*clone))\n+}\n+\n+#[test]\n+fn arclones() {\n+    let value = 12u32;\n+    let arc = Arc::new(value);\n+    let tag = Tag2::B01;\n+\n+    let ptr = tag_ptr(arc, tag);\n+\n+    assert_eq!(ptr.tag(), tag);\n+    assert_eq!(*ptr, 12);\n+\n+    let clone = ptr.clone();\n+    assert!(ptr::eq(&*ptr, &*clone))\n+}\n+\n+/// Helper to create tagged pointers without specifying `COMPARE_PACKED` if it does not matter.\n+fn tag_ptr<P: Pointer, T: Tag>(ptr: P, tag: T) -> TaggedPtr<P, T, true> {\n+    TaggedPtr::new(ptr, tag)\n+}"}, {"sha": "2fa769d3abb720241ab0560f9cc197c5ae27ffdd", "filename": "compiler/rustc_middle/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/7908a1d65496b88626e4b7c193c81d777005d6f3/compiler%2Frustc_middle%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7908a1d65496b88626e4b7c193c81d777005d6f3/compiler%2Frustc_middle%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Flib.rs?ref=7908a1d65496b88626e4b7c193c81d777005d6f3", "patch": "@@ -59,6 +59,7 @@\n #![feature(result_option_inspect)]\n #![feature(const_option)]\n #![feature(trait_alias)]\n+#![feature(ptr_alignment_type)]\n #![recursion_limit = \"512\"]\n #![allow(rustc::potential_query_instability)]\n "}, {"sha": "30f036e471c4260b35afa8a1dbca11d9e1ca4da8", "filename": "compiler/rustc_middle/src/ty/list.rs", "status": "modified", "additions": 13, "deletions": 17, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/7908a1d65496b88626e4b7c193c81d777005d6f3/compiler%2Frustc_middle%2Fsrc%2Fty%2Flist.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7908a1d65496b88626e4b7c193c81d777005d6f3/compiler%2Frustc_middle%2Fsrc%2Fty%2Flist.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Flist.rs?ref=7908a1d65496b88626e4b7c193c81d777005d6f3", "patch": "@@ -1,4 +1,5 @@\n use crate::arena::Arena;\n+use rustc_data_structures::aligned::{align_of, Aligned};\n use rustc_serialize::{Encodable, Encoder};\n use std::alloc::Layout;\n use std::cmp::Ordering;\n@@ -198,22 +199,17 @@ impl<'a, T: Copy> IntoIterator for &'a List<T> {\n \n unsafe impl<T: Sync> Sync for List<T> {}\n \n-unsafe impl<'a, T: 'a> rustc_data_structures::tagged_ptr::Pointer for &'a List<T> {\n-    const BITS: usize = std::mem::align_of::<usize>().trailing_zeros() as usize;\n-\n-    #[inline]\n-    fn into_usize(self) -> usize {\n-        self as *const List<T> as usize\n-    }\n-\n-    #[inline]\n-    unsafe fn from_usize(ptr: usize) -> &'a List<T> {\n-        &*(ptr as *const List<T>)\n-    }\n+// Safety:\n+// Layouts of `Equivalent<T>` and `List<T>` are the same, modulo opaque tail,\n+// thus aligns of `Equivalent<T>` and `List<T>` must be the same.\n+unsafe impl<T> Aligned for List<T> {\n+    const ALIGN: ptr::Alignment = {\n+        #[repr(C)]\n+        struct Equivalent<T> {\n+            _len: usize,\n+            _data: [T; 0],\n+        }\n \n-    unsafe fn with_ref<R, F: FnOnce(&Self) -> R>(ptr: usize, f: F) -> R {\n-        // `Self` is `&'a List<T>` which impls `Copy`, so this is fine.\n-        let ptr = Self::from_usize(ptr);\n-        f(&ptr)\n-    }\n+        align_of::<Equivalent<T>>()\n+    };\n }"}, {"sha": "1061c320793054a3191c2deb3c460e80c50d9ded", "filename": "compiler/rustc_middle/src/ty/mod.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7908a1d65496b88626e4b7c193c81d777005d6f3/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7908a1d65496b88626e4b7c193c81d777005d6f3/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs?ref=7908a1d65496b88626e4b7c193c81d777005d6f3", "patch": "@@ -1627,7 +1627,8 @@ struct ParamTag {\n }\n \n unsafe impl rustc_data_structures::tagged_ptr::Tag for ParamTag {\n-    const BITS: usize = 2;\n+    const BITS: u32 = 2;\n+\n     #[inline]\n     fn into_usize(self) -> usize {\n         match self {\n@@ -1637,6 +1638,7 @@ unsafe impl rustc_data_structures::tagged_ptr::Tag for ParamTag {\n             Self { reveal: traits::Reveal::All, constness: hir::Constness::Const } => 3,\n         }\n     }\n+\n     #[inline]\n     unsafe fn from_usize(ptr: usize) -> Self {\n         match ptr {"}]}