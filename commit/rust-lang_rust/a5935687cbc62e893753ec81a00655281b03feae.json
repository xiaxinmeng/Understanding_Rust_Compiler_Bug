{"sha": "a5935687cbc62e893753ec81a00655281b03feae", "node_id": "MDY6Q29tbWl0NzI0NzEyOmE1OTM1Njg3Y2JjNjJlODkzNzUzZWM4MWEwMDY1NTI4MWIwM2ZlYWU=", "commit": {"author": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2019-01-03T12:08:32Z"}, "committer": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2019-01-03T12:21:49Z"}, "message": "split assists over several files", "tree": {"sha": "f57f648b33797c8482735da800808f9709467ccf", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f57f648b33797c8482735da800808f9709467ccf"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a5935687cbc62e893753ec81a00655281b03feae", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a5935687cbc62e893753ec81a00655281b03feae", "html_url": "https://github.com/rust-lang/rust/commit/a5935687cbc62e893753ec81a00655281b03feae", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a5935687cbc62e893753ec81a00655281b03feae/comments", "author": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "committer": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5323e599964005bc58cf89c27201973bc1ff51dd", "url": "https://api.github.com/repos/rust-lang/rust/commits/5323e599964005bc58cf89c27201973bc1ff51dd", "html_url": "https://github.com/rust-lang/rust/commit/5323e599964005bc58cf89c27201973bc1ff51dd"}], "stats": {"total": 891, "additions": 488, "deletions": 403}, "files": [{"sha": "136e7f7dce50e2401cd4f96dc087af39e14aeb3c", "filename": "crates/ra_analysis/src/imp.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a5935687cbc62e893753ec81a00655281b03feae/crates%2Fra_analysis%2Fsrc%2Fimp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a5935687cbc62e893753ec81a00655281b03feae/crates%2Fra_analysis%2Fsrc%2Fimp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_analysis%2Fsrc%2Fimp.rs?ref=a5935687cbc62e893753ec81a00655281b03feae", "patch": "@@ -338,7 +338,7 @@ impl db::RootDatabase {\n             assists::flip_comma(&file, offset).map(|f| f()),\n             assists::add_derive(&file, offset).map(|f| f()),\n             assists::add_impl(&file, offset).map(|f| f()),\n-            assists::make_pub_crate(&file, offset).map(|f| f()),\n+            assists::change_visibility(&file, offset).map(|f| f()),\n             assists::introduce_variable(&file, frange.range).map(|f| f()),\n         ];\n         actions"}, {"sha": "b6e6dd628ef22d5d8f6ef8ad3f05b60d74f93fea", "filename": "crates/ra_editor/src/assists.rs", "status": "modified", "additions": 20, "deletions": 401, "changes": 421, "blob_url": "https://github.com/rust-lang/rust/blob/a5935687cbc62e893753ec81a00655281b03feae/crates%2Fra_editor%2Fsrc%2Fassists.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a5935687cbc62e893753ec81a00655281b03feae/crates%2Fra_editor%2Fsrc%2Fassists.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_editor%2Fsrc%2Fassists.rs?ref=a5935687cbc62e893753ec81a00655281b03feae", "patch": "@@ -1,415 +1,34 @@\n-use join_to_string::join;\n-\n-use ra_syntax::{\n-    algo::{find_covering_node, find_leaf_at_offset},\n-    ast::{self, AstNode, AttrsOwner, NameOwner, TypeParamsOwner},\n-    Direction, SourceFileNode,\n-    SyntaxKind::{COMMA, WHITESPACE, COMMENT, VISIBILITY, FN_KW, MOD_KW, STRUCT_KW, ENUM_KW, TRAIT_KW, FN_DEF, MODULE, STRUCT_DEF, ENUM_DEF, TRAIT_DEF},\n-    SyntaxNodeRef, TextRange, TextUnit,\n+//! This modules contains various \"assits\": suggestions for source code edits\n+//! which are likely to occur at a given cursor positon. For example, if the\n+//! cursor is on the `,`, a possible assist is swapping the elments around the\n+//! comma.\n+\n+mod flip_comma;\n+mod add_derive;\n+mod add_impl;\n+mod introduce_variable;\n+mod change_visibility;\n+\n+use ra_text_edit::TextEdit;\n+use ra_syntax::{Direction, SyntaxNodeRef, TextUnit};\n+\n+pub use self::{\n+    flip_comma::flip_comma,\n+    add_derive::add_derive,\n+    add_impl::add_impl,\n+    introduce_variable::introduce_variable,\n+    change_visibility::change_visibility,\n };\n \n-use crate::{find_node_at_offset, TextEdit, TextEditBuilder};\n-\n #[derive(Debug)]\n pub struct LocalEdit {\n     pub label: String,\n     pub edit: TextEdit,\n     pub cursor_position: Option<TextUnit>,\n }\n \n-pub fn flip_comma<'a>(\n-    file: &'a SourceFileNode,\n-    offset: TextUnit,\n-) -> Option<impl FnOnce() -> LocalEdit + 'a> {\n-    let syntax = file.syntax();\n-\n-    let comma = find_leaf_at_offset(syntax, offset).find(|leaf| leaf.kind() == COMMA)?;\n-    let prev = non_trivia_sibling(comma, Direction::Prev)?;\n-    let next = non_trivia_sibling(comma, Direction::Next)?;\n-    Some(move || {\n-        let mut edit = TextEditBuilder::new();\n-        edit.replace(prev.range(), next.text().to_string());\n-        edit.replace(next.range(), prev.text().to_string());\n-        LocalEdit {\n-            label: \"flip comma\".to_string(),\n-            edit: edit.finish(),\n-            cursor_position: None,\n-        }\n-    })\n-}\n-\n-pub fn add_derive<'a>(\n-    file: &'a SourceFileNode,\n-    offset: TextUnit,\n-) -> Option<impl FnOnce() -> LocalEdit + 'a> {\n-    let nominal = find_node_at_offset::<ast::NominalDef>(file.syntax(), offset)?;\n-    let node_start = derive_insertion_offset(nominal)?;\n-    return Some(move || {\n-        let derive_attr = nominal\n-            .attrs()\n-            .filter_map(|x| x.as_call())\n-            .filter(|(name, _arg)| name == \"derive\")\n-            .map(|(_name, arg)| arg)\n-            .next();\n-        let mut edit = TextEditBuilder::new();\n-        let offset = match derive_attr {\n-            None => {\n-                edit.insert(node_start, \"#[derive()]\\n\".to_string());\n-                node_start + TextUnit::of_str(\"#[derive(\")\n-            }\n-            Some(tt) => tt.syntax().range().end() - TextUnit::of_char(')'),\n-        };\n-        LocalEdit {\n-            label: \"add `#[derive]`\".to_string(),\n-            edit: edit.finish(),\n-            cursor_position: Some(offset),\n-        }\n-    });\n-\n-    // Insert `derive` after doc comments.\n-    fn derive_insertion_offset(nominal: ast::NominalDef) -> Option<TextUnit> {\n-        let non_ws_child = nominal\n-            .syntax()\n-            .children()\n-            .find(|it| it.kind() != COMMENT && it.kind() != WHITESPACE)?;\n-        Some(non_ws_child.range().start())\n-    }\n-}\n-\n-pub fn add_impl<'a>(\n-    file: &'a SourceFileNode,\n-    offset: TextUnit,\n-) -> Option<impl FnOnce() -> LocalEdit + 'a> {\n-    let nominal = find_node_at_offset::<ast::NominalDef>(file.syntax(), offset)?;\n-    let name = nominal.name()?;\n-\n-    Some(move || {\n-        let type_params = nominal.type_param_list();\n-        let mut edit = TextEditBuilder::new();\n-        let start_offset = nominal.syntax().range().end();\n-        let mut buf = String::new();\n-        buf.push_str(\"\\n\\nimpl\");\n-        if let Some(type_params) = type_params {\n-            type_params.syntax().text().push_to(&mut buf);\n-        }\n-        buf.push_str(\" \");\n-        buf.push_str(name.text().as_str());\n-        if let Some(type_params) = type_params {\n-            let lifetime_params = type_params\n-                .lifetime_params()\n-                .filter_map(|it| it.lifetime())\n-                .map(|it| it.text());\n-            let type_params = type_params\n-                .type_params()\n-                .filter_map(|it| it.name())\n-                .map(|it| it.text());\n-            join(lifetime_params.chain(type_params))\n-                .surround_with(\"<\", \">\")\n-                .to_buf(&mut buf);\n-        }\n-        buf.push_str(\" {\\n\");\n-        let offset = start_offset + TextUnit::of_str(&buf);\n-        buf.push_str(\"\\n}\");\n-        edit.insert(start_offset, buf);\n-        LocalEdit {\n-            label: \"add impl\".to_string(),\n-            edit: edit.finish(),\n-            cursor_position: Some(offset),\n-        }\n-    })\n-}\n-\n-pub fn introduce_variable<'a>(\n-    file: &'a SourceFileNode,\n-    range: TextRange,\n-) -> Option<impl FnOnce() -> LocalEdit + 'a> {\n-    let node = find_covering_node(file.syntax(), range);\n-    let expr = node.ancestors().filter_map(ast::Expr::cast).next()?;\n-\n-    let anchor_stmt = anchor_stmt(expr)?;\n-    let indent = anchor_stmt.prev_sibling()?;\n-    if indent.kind() != WHITESPACE {\n-        return None;\n-    }\n-    return Some(move || {\n-        let mut buf = String::new();\n-        let mut edit = TextEditBuilder::new();\n-\n-        buf.push_str(\"let var_name = \");\n-        expr.syntax().text().push_to(&mut buf);\n-        let is_full_stmt = if let Some(expr_stmt) = ast::ExprStmt::cast(anchor_stmt) {\n-            Some(expr.syntax()) == expr_stmt.expr().map(|e| e.syntax())\n-        } else {\n-            false\n-        };\n-        if is_full_stmt {\n-            edit.replace(expr.syntax().range(), buf);\n-        } else {\n-            buf.push_str(\";\");\n-            indent.text().push_to(&mut buf);\n-            edit.replace(expr.syntax().range(), \"var_name\".to_string());\n-            edit.insert(anchor_stmt.range().start(), buf);\n-        }\n-        let cursor_position = anchor_stmt.range().start() + TextUnit::of_str(\"let \");\n-        LocalEdit {\n-            label: \"introduce variable\".to_string(),\n-            edit: edit.finish(),\n-            cursor_position: Some(cursor_position),\n-        }\n-    });\n-\n-    /// Statement or last in the block expression, which will follow\n-    /// the freshly introduced var.\n-    fn anchor_stmt(expr: ast::Expr) -> Option<SyntaxNodeRef> {\n-        expr.syntax().ancestors().find(|&node| {\n-            if ast::Stmt::cast(node).is_some() {\n-                return true;\n-            }\n-            if let Some(expr) = node\n-                .parent()\n-                .and_then(ast::Block::cast)\n-                .and_then(|it| it.expr())\n-            {\n-                if expr.syntax() == node {\n-                    return true;\n-                }\n-            }\n-            false\n-        })\n-    }\n-}\n-\n-pub fn make_pub_crate<'a>(\n-    file: &'a SourceFileNode,\n-    offset: TextUnit,\n-) -> Option<impl FnOnce() -> LocalEdit + 'a> {\n-    let syntax = file.syntax();\n-\n-    let keyword = find_leaf_at_offset(syntax, offset).find(|leaf| match leaf.kind() {\n-        FN_KW | MOD_KW | STRUCT_KW | ENUM_KW | TRAIT_KW => true,\n-        _ => false,\n-    })?;\n-    let parent = keyword.parent()?;\n-    let def_kws = vec![FN_DEF, MODULE, STRUCT_DEF, ENUM_DEF, TRAIT_DEF];\n-    let node_start = parent.range().start();\n-    Some(move || {\n-        let mut edit = TextEditBuilder::new();\n-\n-        if !def_kws.iter().any(|&def_kw| def_kw == parent.kind())\n-            || parent.children().any(|child| child.kind() == VISIBILITY)\n-        {\n-            return LocalEdit {\n-                label: \"make pub crate\".to_string(),\n-                edit: edit.finish(),\n-                cursor_position: Some(offset),\n-            };\n-        }\n-\n-        edit.insert(node_start, \"pub(crate) \".to_string());\n-        LocalEdit {\n-            label: \"make pub crate\".to_string(),\n-            edit: edit.finish(),\n-            cursor_position: Some(node_start),\n-        }\n-    })\n-}\n-\n fn non_trivia_sibling(node: SyntaxNodeRef, direction: Direction) -> Option<SyntaxNodeRef> {\n     node.siblings(direction)\n         .skip(1)\n         .find(|node| !node.kind().is_trivia())\n }\n-\n-#[cfg(test)]\n-mod tests {\n-    use super::*;\n-    use crate::test_utils::{check_action, check_action_range};\n-\n-    #[test]\n-    fn test_swap_comma() {\n-        check_action(\n-            \"fn foo(x: i32,<|> y: Result<(), ()>) {}\",\n-            \"fn foo(y: Result<(), ()>,<|> x: i32) {}\",\n-            |file, off| flip_comma(file, off).map(|f| f()),\n-        )\n-    }\n-\n-    #[test]\n-    fn add_derive_new() {\n-        check_action(\n-            \"struct Foo { a: i32, <|>}\",\n-            \"#[derive(<|>)]\\nstruct Foo { a: i32, }\",\n-            |file, off| add_derive(file, off).map(|f| f()),\n-        );\n-        check_action(\n-            \"struct Foo { <|> a: i32, }\",\n-            \"#[derive(<|>)]\\nstruct Foo {  a: i32, }\",\n-            |file, off| add_derive(file, off).map(|f| f()),\n-        );\n-    }\n-\n-    #[test]\n-    fn add_derive_existing() {\n-        check_action(\n-            \"#[derive(Clone)]\\nstruct Foo { a: i32<|>, }\",\n-            \"#[derive(Clone<|>)]\\nstruct Foo { a: i32, }\",\n-            |file, off| add_derive(file, off).map(|f| f()),\n-        );\n-    }\n-\n-    #[test]\n-    fn add_derive_new_with_doc_comment() {\n-        check_action(\n-            \"\n-/// `Foo` is a pretty important struct.\n-/// It does stuff.\n-struct Foo { a: i32<|>, }\n-            \",\n-            \"\n-/// `Foo` is a pretty important struct.\n-/// It does stuff.\n-#[derive(<|>)]\n-struct Foo { a: i32, }\n-            \",\n-            |file, off| add_derive(file, off).map(|f| f()),\n-        );\n-    }\n-\n-    #[test]\n-    fn test_add_impl() {\n-        check_action(\n-            \"struct Foo {<|>}\\n\",\n-            \"struct Foo {}\\n\\nimpl Foo {\\n<|>\\n}\\n\",\n-            |file, off| add_impl(file, off).map(|f| f()),\n-        );\n-        check_action(\n-            \"struct Foo<T: Clone> {<|>}\",\n-            \"struct Foo<T: Clone> {}\\n\\nimpl<T: Clone> Foo<T> {\\n<|>\\n}\",\n-            |file, off| add_impl(file, off).map(|f| f()),\n-        );\n-        check_action(\n-            \"struct Foo<'a, T: Foo<'a>> {<|>}\",\n-            \"struct Foo<'a, T: Foo<'a>> {}\\n\\nimpl<'a, T: Foo<'a>> Foo<'a, T> {\\n<|>\\n}\",\n-            |file, off| add_impl(file, off).map(|f| f()),\n-        );\n-    }\n-\n-    #[test]\n-    fn test_introduce_var_simple() {\n-        check_action_range(\n-            \"\n-fn foo() {\n-    foo(<|>1 + 1<|>);\n-}\",\n-            \"\n-fn foo() {\n-    let <|>var_name = 1 + 1;\n-    foo(var_name);\n-}\",\n-            |file, range| introduce_variable(file, range).map(|f| f()),\n-        );\n-    }\n-\n-    #[test]\n-    fn test_introduce_var_expr_stmt() {\n-        check_action_range(\n-            \"\n-fn foo() {\n-    <|>1 + 1<|>;\n-}\",\n-            \"\n-fn foo() {\n-    let <|>var_name = 1 + 1;\n-}\",\n-            |file, range| introduce_variable(file, range).map(|f| f()),\n-        );\n-    }\n-\n-    #[test]\n-    fn test_introduce_var_part_of_expr_stmt() {\n-        check_action_range(\n-            \"\n-fn foo() {\n-    <|>1<|> + 1;\n-}\",\n-            \"\n-fn foo() {\n-    let <|>var_name = 1;\n-    var_name + 1;\n-}\",\n-            |file, range| introduce_variable(file, range).map(|f| f()),\n-        );\n-    }\n-\n-    #[test]\n-    fn test_introduce_var_last_expr() {\n-        check_action_range(\n-            \"\n-fn foo() {\n-    bar(<|>1 + 1<|>)\n-}\",\n-            \"\n-fn foo() {\n-    let <|>var_name = 1 + 1;\n-    bar(var_name)\n-}\",\n-            |file, range| introduce_variable(file, range).map(|f| f()),\n-        );\n-    }\n-\n-    #[test]\n-    fn test_introduce_var_last_full_expr() {\n-        check_action_range(\n-            \"\n-fn foo() {\n-    <|>bar(1 + 1)<|>\n-}\",\n-            \"\n-fn foo() {\n-    let <|>var_name = bar(1 + 1);\n-    var_name\n-}\",\n-            |file, range| introduce_variable(file, range).map(|f| f()),\n-        );\n-    }\n-\n-    #[test]\n-    fn test_make_pub_crate() {\n-        check_action(\n-            \"<|>fn foo() {}\",\n-            \"<|>pub(crate) fn foo() {}\",\n-            |file, off| make_pub_crate(file, off).map(|f| f()),\n-        );\n-        check_action(\n-            \"f<|>n foo() {}\",\n-            \"<|>pub(crate) fn foo() {}\",\n-            |file, off| make_pub_crate(file, off).map(|f| f()),\n-        );\n-        check_action(\n-            \"<|>struct Foo {}\",\n-            \"<|>pub(crate) struct Foo {}\",\n-            |file, off| make_pub_crate(file, off).map(|f| f()),\n-        );\n-        check_action(\"<|>mod foo {}\", \"<|>pub(crate) mod foo {}\", |file, off| {\n-            make_pub_crate(file, off).map(|f| f())\n-        });\n-        check_action(\n-            \"<|>trait Foo {}\",\n-            \"<|>pub(crate) trait Foo {}\",\n-            |file, off| make_pub_crate(file, off).map(|f| f()),\n-        );\n-        check_action(\"m<|>od {}\", \"<|>pub(crate) mod {}\", |file, off| {\n-            make_pub_crate(file, off).map(|f| f())\n-        });\n-        check_action(\n-            \"pub(crate) f<|>n foo() {}\",\n-            \"pub(crate) f<|>n foo() {}\",\n-            |file, off| make_pub_crate(file, off).map(|f| f()),\n-        );\n-        check_action(\n-            \"unsafe f<|>n foo() {}\",\n-            \"<|>pub(crate) unsafe fn foo() {}\",\n-            |file, off| make_pub_crate(file, off).map(|f| f()),\n-        );\n-    }\n-}"}, {"sha": "33d9d2c31390e6a1c2b8d75211c6050542ca053b", "filename": "crates/ra_editor/src/assists/add_derive.rs", "status": "added", "additions": 97, "deletions": 0, "changes": 97, "blob_url": "https://github.com/rust-lang/rust/blob/a5935687cbc62e893753ec81a00655281b03feae/crates%2Fra_editor%2Fsrc%2Fassists%2Fadd_derive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a5935687cbc62e893753ec81a00655281b03feae/crates%2Fra_editor%2Fsrc%2Fassists%2Fadd_derive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_editor%2Fsrc%2Fassists%2Fadd_derive.rs?ref=a5935687cbc62e893753ec81a00655281b03feae", "patch": "@@ -0,0 +1,97 @@\n+use ra_text_edit::TextEditBuilder;\n+use ra_syntax::{\n+    ast::{self, AstNode, AttrsOwner},\n+    SourceFileNode,\n+    SyntaxKind::{WHITESPACE, COMMENT},\n+    TextUnit,\n+};\n+\n+use crate::{\n+    find_node_at_offset,\n+    assists::LocalEdit,\n+};\n+\n+pub fn add_derive<'a>(\n+    file: &'a SourceFileNode,\n+    offset: TextUnit,\n+) -> Option<impl FnOnce() -> LocalEdit + 'a> {\n+    let nominal = find_node_at_offset::<ast::NominalDef>(file.syntax(), offset)?;\n+    let node_start = derive_insertion_offset(nominal)?;\n+    return Some(move || {\n+        let derive_attr = nominal\n+            .attrs()\n+            .filter_map(|x| x.as_call())\n+            .filter(|(name, _arg)| name == \"derive\")\n+            .map(|(_name, arg)| arg)\n+            .next();\n+        let mut edit = TextEditBuilder::new();\n+        let offset = match derive_attr {\n+            None => {\n+                edit.insert(node_start, \"#[derive()]\\n\".to_string());\n+                node_start + TextUnit::of_str(\"#[derive(\")\n+            }\n+            Some(tt) => tt.syntax().range().end() - TextUnit::of_char(')'),\n+        };\n+        LocalEdit {\n+            label: \"add `#[derive]`\".to_string(),\n+            edit: edit.finish(),\n+            cursor_position: Some(offset),\n+        }\n+    });\n+\n+    // Insert `derive` after doc comments.\n+    fn derive_insertion_offset(nominal: ast::NominalDef) -> Option<TextUnit> {\n+        let non_ws_child = nominal\n+            .syntax()\n+            .children()\n+            .find(|it| it.kind() != COMMENT && it.kind() != WHITESPACE)?;\n+        Some(non_ws_child.range().start())\n+    }\n+}\n+\n+#[cfg(test)]\n+mod tests {\n+    use super::*;\n+    use crate::test_utils::check_action;\n+\n+    #[test]\n+    fn add_derive_new() {\n+        check_action(\n+            \"struct Foo { a: i32, <|>}\",\n+            \"#[derive(<|>)]\\nstruct Foo { a: i32, }\",\n+            |file, off| add_derive(file, off).map(|f| f()),\n+        );\n+        check_action(\n+            \"struct Foo { <|> a: i32, }\",\n+            \"#[derive(<|>)]\\nstruct Foo {  a: i32, }\",\n+            |file, off| add_derive(file, off).map(|f| f()),\n+        );\n+    }\n+\n+    #[test]\n+    fn add_derive_existing() {\n+        check_action(\n+            \"#[derive(Clone)]\\nstruct Foo { a: i32<|>, }\",\n+            \"#[derive(Clone<|>)]\\nstruct Foo { a: i32, }\",\n+            |file, off| add_derive(file, off).map(|f| f()),\n+        );\n+    }\n+\n+    #[test]\n+    fn add_derive_new_with_doc_comment() {\n+        check_action(\n+            \"\n+/// `Foo` is a pretty important struct.\n+/// It does stuff.\n+struct Foo { a: i32<|>, }\n+            \",\n+            \"\n+/// `Foo` is a pretty important struct.\n+/// It does stuff.\n+#[derive(<|>)]\n+struct Foo { a: i32, }\n+            \",\n+            |file, off| add_derive(file, off).map(|f| f()),\n+        );\n+    }\n+}"}, {"sha": "50e00688e5c00c171d4f1c92383ace5cc1b41815", "filename": "crates/ra_editor/src/assists/add_impl.rs", "status": "added", "additions": 78, "deletions": 0, "changes": 78, "blob_url": "https://github.com/rust-lang/rust/blob/a5935687cbc62e893753ec81a00655281b03feae/crates%2Fra_editor%2Fsrc%2Fassists%2Fadd_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a5935687cbc62e893753ec81a00655281b03feae/crates%2Fra_editor%2Fsrc%2Fassists%2Fadd_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_editor%2Fsrc%2Fassists%2Fadd_impl.rs?ref=a5935687cbc62e893753ec81a00655281b03feae", "patch": "@@ -0,0 +1,78 @@\n+use join_to_string::join;\n+use ra_text_edit::TextEditBuilder;\n+use ra_syntax::{\n+    ast::{self, AstNode, NameOwner, TypeParamsOwner},\n+    SourceFileNode,\n+    TextUnit,\n+};\n+\n+use crate::{find_node_at_offset, assists::LocalEdit};\n+\n+pub fn add_impl<'a>(\n+    file: &'a SourceFileNode,\n+    offset: TextUnit,\n+) -> Option<impl FnOnce() -> LocalEdit + 'a> {\n+    let nominal = find_node_at_offset::<ast::NominalDef>(file.syntax(), offset)?;\n+    let name = nominal.name()?;\n+\n+    Some(move || {\n+        let type_params = nominal.type_param_list();\n+        let mut edit = TextEditBuilder::new();\n+        let start_offset = nominal.syntax().range().end();\n+        let mut buf = String::new();\n+        buf.push_str(\"\\n\\nimpl\");\n+        if let Some(type_params) = type_params {\n+            type_params.syntax().text().push_to(&mut buf);\n+        }\n+        buf.push_str(\" \");\n+        buf.push_str(name.text().as_str());\n+        if let Some(type_params) = type_params {\n+            let lifetime_params = type_params\n+                .lifetime_params()\n+                .filter_map(|it| it.lifetime())\n+                .map(|it| it.text());\n+            let type_params = type_params\n+                .type_params()\n+                .filter_map(|it| it.name())\n+                .map(|it| it.text());\n+            join(lifetime_params.chain(type_params))\n+                .surround_with(\"<\", \">\")\n+                .to_buf(&mut buf);\n+        }\n+        buf.push_str(\" {\\n\");\n+        let offset = start_offset + TextUnit::of_str(&buf);\n+        buf.push_str(\"\\n}\");\n+        edit.insert(start_offset, buf);\n+        LocalEdit {\n+            label: \"add impl\".to_string(),\n+            edit: edit.finish(),\n+            cursor_position: Some(offset),\n+        }\n+    })\n+}\n+\n+#[cfg(test)]\n+mod tests {\n+    use super::*;\n+    use crate::test_utils::check_action;\n+\n+    #[test]\n+    fn test_add_impl() {\n+        check_action(\n+            \"struct Foo {<|>}\\n\",\n+            \"struct Foo {}\\n\\nimpl Foo {\\n<|>\\n}\\n\",\n+            |file, off| add_impl(file, off).map(|f| f()),\n+        );\n+        check_action(\n+            \"struct Foo<T: Clone> {<|>}\",\n+            \"struct Foo<T: Clone> {}\\n\\nimpl<T: Clone> Foo<T> {\\n<|>\\n}\",\n+            |file, off| add_impl(file, off).map(|f| f()),\n+        );\n+        check_action(\n+            \"struct Foo<'a, T: Foo<'a>> {<|>}\",\n+            \"struct Foo<'a, T: Foo<'a>> {}\\n\\nimpl<'a, T: Foo<'a>> Foo<'a, T> {\\n<|>\\n}\",\n+            |file, off| add_impl(file, off).map(|f| f()),\n+        );\n+    }\n+\n+}"}, {"sha": "98c218f329bbeeb0e9e453bd557e6d0e5dca8693", "filename": "crates/ra_editor/src/assists/change_visibility.rs", "status": "added", "additions": 90, "deletions": 0, "changes": 90, "blob_url": "https://github.com/rust-lang/rust/blob/a5935687cbc62e893753ec81a00655281b03feae/crates%2Fra_editor%2Fsrc%2Fassists%2Fchange_visibility.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a5935687cbc62e893753ec81a00655281b03feae/crates%2Fra_editor%2Fsrc%2Fassists%2Fchange_visibility.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_editor%2Fsrc%2Fassists%2Fchange_visibility.rs?ref=a5935687cbc62e893753ec81a00655281b03feae", "patch": "@@ -0,0 +1,90 @@\n+use ra_text_edit::TextEditBuilder;\n+use ra_syntax::{\n+    SourceFileNode,\n+    algo::find_leaf_at_offset,\n+    SyntaxKind::{VISIBILITY, FN_KW, MOD_KW, STRUCT_KW, ENUM_KW, TRAIT_KW, FN_DEF, MODULE, STRUCT_DEF, ENUM_DEF, TRAIT_DEF},\n+    TextUnit,\n+};\n+\n+use crate::assists::LocalEdit;\n+\n+pub fn change_visibility<'a>(\n+    file: &'a SourceFileNode,\n+    offset: TextUnit,\n+) -> Option<impl FnOnce() -> LocalEdit + 'a> {\n+    let syntax = file.syntax();\n+\n+    let keyword = find_leaf_at_offset(syntax, offset).find(|leaf| match leaf.kind() {\n+        FN_KW | MOD_KW | STRUCT_KW | ENUM_KW | TRAIT_KW => true,\n+        _ => false,\n+    })?;\n+    let parent = keyword.parent()?;\n+    let def_kws = vec![FN_DEF, MODULE, STRUCT_DEF, ENUM_DEF, TRAIT_DEF];\n+    let node_start = parent.range().start();\n+    Some(move || {\n+        let mut edit = TextEditBuilder::new();\n+\n+        if !def_kws.iter().any(|&def_kw| def_kw == parent.kind())\n+            || parent.children().any(|child| child.kind() == VISIBILITY)\n+        {\n+            return LocalEdit {\n+                label: \"make pub crate\".to_string(),\n+                edit: edit.finish(),\n+                cursor_position: Some(offset),\n+            };\n+        }\n+\n+        edit.insert(node_start, \"pub(crate) \".to_string());\n+        LocalEdit {\n+            label: \"make pub crate\".to_string(),\n+            edit: edit.finish(),\n+            cursor_position: Some(node_start),\n+        }\n+    })\n+}\n+\n+#[cfg(test)]\n+mod tests {\n+    use super::*;\n+    use crate::test_utils::check_action;\n+\n+    #[test]\n+    fn test_change_visibility() {\n+        check_action(\n+            \"<|>fn foo() {}\",\n+            \"<|>pub(crate) fn foo() {}\",\n+            |file, off| change_visibility(file, off).map(|f| f()),\n+        );\n+        check_action(\n+            \"f<|>n foo() {}\",\n+            \"<|>pub(crate) fn foo() {}\",\n+            |file, off| change_visibility(file, off).map(|f| f()),\n+        );\n+        check_action(\n+            \"<|>struct Foo {}\",\n+            \"<|>pub(crate) struct Foo {}\",\n+            |file, off| change_visibility(file, off).map(|f| f()),\n+        );\n+        check_action(\"<|>mod foo {}\", \"<|>pub(crate) mod foo {}\", |file, off| {\n+            change_visibility(file, off).map(|f| f())\n+        });\n+        check_action(\n+            \"<|>trait Foo {}\",\n+            \"<|>pub(crate) trait Foo {}\",\n+            |file, off| change_visibility(file, off).map(|f| f()),\n+        );\n+        check_action(\"m<|>od {}\", \"<|>pub(crate) mod {}\", |file, off| {\n+            change_visibility(file, off).map(|f| f())\n+        });\n+        check_action(\n+            \"pub(crate) f<|>n foo() {}\",\n+            \"pub(crate) f<|>n foo() {}\",\n+            |file, off| change_visibility(file, off).map(|f| f()),\n+        );\n+        check_action(\n+            \"unsafe f<|>n foo() {}\",\n+            \"<|>pub(crate) unsafe fn foo() {}\",\n+            |file, off| change_visibility(file, off).map(|f| f()),\n+        );\n+    }\n+}"}, {"sha": "d8727db0d63d4b1da08d5f5cffeec245492ce88d", "filename": "crates/ra_editor/src/assists/flip_comma.rs", "status": "added", "additions": 45, "deletions": 0, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/a5935687cbc62e893753ec81a00655281b03feae/crates%2Fra_editor%2Fsrc%2Fassists%2Fflip_comma.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a5935687cbc62e893753ec81a00655281b03feae/crates%2Fra_editor%2Fsrc%2Fassists%2Fflip_comma.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_editor%2Fsrc%2Fassists%2Fflip_comma.rs?ref=a5935687cbc62e893753ec81a00655281b03feae", "patch": "@@ -0,0 +1,45 @@\n+use ra_text_edit::TextEditBuilder;\n+use ra_syntax::{\n+    algo::find_leaf_at_offset,\n+    Direction, SourceFileNode,\n+    SyntaxKind::COMMA,\n+    TextUnit,\n+};\n+\n+use crate::assists::{LocalEdit, non_trivia_sibling};\n+\n+pub fn flip_comma<'a>(\n+    file: &'a SourceFileNode,\n+    offset: TextUnit,\n+) -> Option<impl FnOnce() -> LocalEdit + 'a> {\n+    let syntax = file.syntax();\n+\n+    let comma = find_leaf_at_offset(syntax, offset).find(|leaf| leaf.kind() == COMMA)?;\n+    let prev = non_trivia_sibling(comma, Direction::Prev)?;\n+    let next = non_trivia_sibling(comma, Direction::Next)?;\n+    Some(move || {\n+        let mut edit = TextEditBuilder::new();\n+        edit.replace(prev.range(), next.text().to_string());\n+        edit.replace(next.range(), prev.text().to_string());\n+        LocalEdit {\n+            label: \"flip comma\".to_string(),\n+            edit: edit.finish(),\n+            cursor_position: None,\n+        }\n+    })\n+}\n+\n+#[cfg(test)]\n+mod tests {\n+    use super::*;\n+    use crate::test_utils::check_action;\n+\n+    #[test]\n+    fn test_swap_comma() {\n+        check_action(\n+            \"fn foo(x: i32,<|> y: Result<(), ()>) {}\",\n+            \"fn foo(y: Result<(), ()>,<|> x: i32) {}\",\n+            |file, off| flip_comma(file, off).map(|f| f()),\n+        )\n+    }\n+}"}, {"sha": "17ab521facd4cc322608da3697134321a47c820f", "filename": "crates/ra_editor/src/assists/introduce_variable.rs", "status": "added", "additions": 156, "deletions": 0, "changes": 156, "blob_url": "https://github.com/rust-lang/rust/blob/a5935687cbc62e893753ec81a00655281b03feae/crates%2Fra_editor%2Fsrc%2Fassists%2Fintroduce_variable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a5935687cbc62e893753ec81a00655281b03feae/crates%2Fra_editor%2Fsrc%2Fassists%2Fintroduce_variable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_editor%2Fsrc%2Fassists%2Fintroduce_variable.rs?ref=a5935687cbc62e893753ec81a00655281b03feae", "patch": "@@ -0,0 +1,156 @@\n+use ra_text_edit::TextEditBuilder;\n+use ra_syntax::{\n+    algo::{find_covering_node},\n+    ast::{self, AstNode},\n+    SourceFileNode,\n+    SyntaxKind::{WHITESPACE},\n+    SyntaxNodeRef, TextRange, TextUnit,\n+};\n+\n+use crate::assists::LocalEdit;\n+\n+pub fn introduce_variable<'a>(\n+    file: &'a SourceFileNode,\n+    range: TextRange,\n+) -> Option<impl FnOnce() -> LocalEdit + 'a> {\n+    let node = find_covering_node(file.syntax(), range);\n+    let expr = node.ancestors().filter_map(ast::Expr::cast).next()?;\n+\n+    let anchor_stmt = anchor_stmt(expr)?;\n+    let indent = anchor_stmt.prev_sibling()?;\n+    if indent.kind() != WHITESPACE {\n+        return None;\n+    }\n+    return Some(move || {\n+        let mut buf = String::new();\n+        let mut edit = TextEditBuilder::new();\n+\n+        buf.push_str(\"let var_name = \");\n+        expr.syntax().text().push_to(&mut buf);\n+        let is_full_stmt = if let Some(expr_stmt) = ast::ExprStmt::cast(anchor_stmt) {\n+            Some(expr.syntax()) == expr_stmt.expr().map(|e| e.syntax())\n+        } else {\n+            false\n+        };\n+        if is_full_stmt {\n+            edit.replace(expr.syntax().range(), buf);\n+        } else {\n+            buf.push_str(\";\");\n+            indent.text().push_to(&mut buf);\n+            edit.replace(expr.syntax().range(), \"var_name\".to_string());\n+            edit.insert(anchor_stmt.range().start(), buf);\n+        }\n+        let cursor_position = anchor_stmt.range().start() + TextUnit::of_str(\"let \");\n+        LocalEdit {\n+            label: \"introduce variable\".to_string(),\n+            edit: edit.finish(),\n+            cursor_position: Some(cursor_position),\n+        }\n+    });\n+\n+    /// Statement or last in the block expression, which will follow\n+    /// the freshly introduced var.\n+    fn anchor_stmt(expr: ast::Expr) -> Option<SyntaxNodeRef> {\n+        expr.syntax().ancestors().find(|&node| {\n+            if ast::Stmt::cast(node).is_some() {\n+                return true;\n+            }\n+            if let Some(expr) = node\n+                .parent()\n+                .and_then(ast::Block::cast)\n+                .and_then(|it| it.expr())\n+            {\n+                if expr.syntax() == node {\n+                    return true;\n+                }\n+            }\n+            false\n+        })\n+    }\n+}\n+\n+#[cfg(test)]\n+mod tests {\n+    use super::*;\n+    use crate::test_utils::check_action_range;\n+\n+    #[test]\n+    fn test_introduce_var_simple() {\n+        check_action_range(\n+            \"\n+fn foo() {\n+    foo(<|>1 + 1<|>);\n+}\",\n+            \"\n+fn foo() {\n+    let <|>var_name = 1 + 1;\n+    foo(var_name);\n+}\",\n+            |file, range| introduce_variable(file, range).map(|f| f()),\n+        );\n+    }\n+\n+    #[test]\n+    fn test_introduce_var_expr_stmt() {\n+        check_action_range(\n+            \"\n+fn foo() {\n+    <|>1 + 1<|>;\n+}\",\n+            \"\n+fn foo() {\n+    let <|>var_name = 1 + 1;\n+}\",\n+            |file, range| introduce_variable(file, range).map(|f| f()),\n+        );\n+    }\n+\n+    #[test]\n+    fn test_introduce_var_part_of_expr_stmt() {\n+        check_action_range(\n+            \"\n+fn foo() {\n+    <|>1<|> + 1;\n+}\",\n+            \"\n+fn foo() {\n+    let <|>var_name = 1;\n+    var_name + 1;\n+}\",\n+            |file, range| introduce_variable(file, range).map(|f| f()),\n+        );\n+    }\n+\n+    #[test]\n+    fn test_introduce_var_last_expr() {\n+        check_action_range(\n+            \"\n+fn foo() {\n+    bar(<|>1 + 1<|>)\n+}\",\n+            \"\n+fn foo() {\n+    let <|>var_name = 1 + 1;\n+    bar(var_name)\n+}\",\n+            |file, range| introduce_variable(file, range).map(|f| f()),\n+        );\n+    }\n+\n+    #[test]\n+    fn test_introduce_var_last_full_expr() {\n+        check_action_range(\n+            \"\n+fn foo() {\n+    <|>bar(1 + 1)<|>\n+}\",\n+            \"\n+fn foo() {\n+    let <|>var_name = bar(1 + 1);\n+    var_name\n+}\",\n+            |file, range| introduce_variable(file, range).map(|f| f()),\n+        );\n+    }\n+\n+}"}, {"sha": "ac283e2e0990f316d8c021ed6a3712abebf18567", "filename": "crates/ra_editor/src/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a5935687cbc62e893753ec81a00655281b03feae/crates%2Fra_editor%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a5935687cbc62e893753ec81a00655281b03feae/crates%2Fra_editor%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_editor%2Fsrc%2Flib.rs?ref=a5935687cbc62e893753ec81a00655281b03feae", "patch": "@@ -19,7 +19,7 @@ pub use self::{\n     typing::{join_lines, on_enter, on_eq_typed},\n     diagnostics::diagnostics\n };\n-use ra_text_edit::{TextEdit, TextEditBuilder};\n+use ra_text_edit::TextEditBuilder;\n use ra_syntax::{\n     algo::find_leaf_at_offset,\n     ast::{self, AstNode},"}]}