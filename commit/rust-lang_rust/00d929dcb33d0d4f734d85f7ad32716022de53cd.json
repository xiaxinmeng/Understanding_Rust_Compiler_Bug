{"sha": "00d929dcb33d0d4f734d85f7ad32716022de53cd", "node_id": "MDY6Q29tbWl0NzI0NzEyOjAwZDkyOWRjYjMzZDBkNGY3MzRkODVmN2FkMzI3MTYwMjJkZTUzY2Q=", "commit": {"author": {"name": "Trent Nadeau", "email": "tanadeau@gmail.com", "date": "2015-03-29T02:20:36Z"}, "committer": {"name": "Trent Nadeau", "email": "tanadeau@gmail.com", "date": "2015-04-02T01:53:37Z"}, "message": "Moved use of `box_syntax` unstable feature in docs to Unstable section.\n\nCreate a new section under the Unstable section for `box` syntax and\npatterns and removed their discussion from the Pointers section.", "tree": {"sha": "6c26c2dc401c2c0ca203c0c19b3eeb453e872918", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6c26c2dc401c2c0ca203c0c19b3eeb453e872918"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/00d929dcb33d0d4f734d85f7ad32716022de53cd", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/00d929dcb33d0d4f734d85f7ad32716022de53cd", "html_url": "https://github.com/rust-lang/rust/commit/00d929dcb33d0d4f734d85f7ad32716022de53cd", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/00d929dcb33d0d4f734d85f7ad32716022de53cd/comments", "author": {"login": "tanadeau", "id": 3734457, "node_id": "MDQ6VXNlcjM3MzQ0NTc=", "avatar_url": "https://avatars.githubusercontent.com/u/3734457?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tanadeau", "html_url": "https://github.com/tanadeau", "followers_url": "https://api.github.com/users/tanadeau/followers", "following_url": "https://api.github.com/users/tanadeau/following{/other_user}", "gists_url": "https://api.github.com/users/tanadeau/gists{/gist_id}", "starred_url": "https://api.github.com/users/tanadeau/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tanadeau/subscriptions", "organizations_url": "https://api.github.com/users/tanadeau/orgs", "repos_url": "https://api.github.com/users/tanadeau/repos", "events_url": "https://api.github.com/users/tanadeau/events{/privacy}", "received_events_url": "https://api.github.com/users/tanadeau/received_events", "type": "User", "site_admin": false}, "committer": {"login": "tanadeau", "id": 3734457, "node_id": "MDQ6VXNlcjM3MzQ0NTc=", "avatar_url": "https://avatars.githubusercontent.com/u/3734457?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tanadeau", "html_url": "https://github.com/tanadeau", "followers_url": "https://api.github.com/users/tanadeau/followers", "following_url": "https://api.github.com/users/tanadeau/following{/other_user}", "gists_url": "https://api.github.com/users/tanadeau/gists{/gist_id}", "starred_url": "https://api.github.com/users/tanadeau/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tanadeau/subscriptions", "organizations_url": "https://api.github.com/users/tanadeau/orgs", "repos_url": "https://api.github.com/users/tanadeau/repos", "events_url": "https://api.github.com/users/tanadeau/events{/privacy}", "received_events_url": "https://api.github.com/users/tanadeau/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d528aa9960cb9b937d8ef6c09905a6a8076d5f3a", "url": "https://api.github.com/repos/rust-lang/rust/commits/d528aa9960cb9b937d8ef6c09905a6a8076d5f3a", "html_url": "https://github.com/rust-lang/rust/commit/d528aa9960cb9b937d8ef6c09905a6a8076d5f3a"}], "stats": {"total": 187, "additions": 103, "deletions": 84}, "files": [{"sha": "11e62aff42f3fd6132c1d4df5280aaa74a134ba2", "filename": "src/doc/trpl/SUMMARY.md", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/00d929dcb33d0d4f734d85f7ad32716022de53cd/src%2Fdoc%2Ftrpl%2FSUMMARY.md", "raw_url": "https://github.com/rust-lang/rust/raw/00d929dcb33d0d4f734d85f7ad32716022de53cd/src%2Fdoc%2Ftrpl%2FSUMMARY.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2FSUMMARY.md?ref=00d929dcb33d0d4f734d85f7ad32716022de53cd", "patch": "@@ -43,5 +43,6 @@\n     * [Lang items](lang-items.md)\n     * [Link args](link-args.md)\n     * [Benchmark Tests](benchmark-tests.md)\n+    * [Box Syntax and Patterns](box-syntax-and-patterns.md)\n * [Conclusion](conclusion.md)\n * [Glossary](glossary.md)"}, {"sha": "839f07d9843226560fd27d2165e113f51905f84f", "filename": "src/doc/trpl/box-syntax-and-patterns.md", "status": "added", "additions": 100, "deletions": 0, "changes": 100, "blob_url": "https://github.com/rust-lang/rust/blob/00d929dcb33d0d4f734d85f7ad32716022de53cd/src%2Fdoc%2Ftrpl%2Fbox-syntax-and-patterns.md", "raw_url": "https://github.com/rust-lang/rust/raw/00d929dcb33d0d4f734d85f7ad32716022de53cd/src%2Fdoc%2Ftrpl%2Fbox-syntax-and-patterns.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Fbox-syntax-and-patterns.md?ref=00d929dcb33d0d4f734d85f7ad32716022de53cd", "patch": "@@ -0,0 +1,100 @@\n+%  Box Syntax and Patterns\n+\n+Currently the only stable way to create a `Box` is via the `Box::new` method.\n+Also it is not possible in stable Rust to destructure a `Box` in a match\n+pattern. The unstable `box` keyword can be used to both create and destructure\n+a `Box`. An example usage would be:\n+\n+```\n+#![feature(box_syntax, box_patterns)]\n+\n+fn main() {\n+    let b = Some(box 5);\n+    match b {\n+        Some(box n) if n < 0 => {\n+            println!(\"Box contains negative number {}\", n);\n+        },\n+        Some(box n) if n >= 0 => {\n+            println!(\"Box contains non-negative number {}\", n);\n+        },\n+        None => {\n+            println!(\"No box\");\n+        },\n+        _ => unreachable!()\n+    }\n+}\n+```\n+\n+Note that these features are currently hidden behind the `box_syntax` (box\n+creation) and `box_patterns` (destructuring and pattern matching) gates\n+because the syntax may still change in the future.\n+\n+# Returning Pointers\n+\n+In many languages with pointers, you'd return a pointer from a function\n+so as to avoid copying a large data structure. For example:\n+\n+```{rust}\n+struct BigStruct {\n+    one: i32,\n+    two: i32,\n+    // etc\n+    one_hundred: i32,\n+}\n+\n+fn foo(x: Box<BigStruct>) -> Box<BigStruct> {\n+    Box::new(*x)\n+}\n+\n+fn main() {\n+    let x = Box::new(BigStruct {\n+        one: 1,\n+        two: 2,\n+        one_hundred: 100,\n+    });\n+\n+    let y = foo(x);\n+}\n+```\n+\n+The idea is that by passing around a box, you're only copying a pointer, rather\n+than the hundred `int`s that make up the `BigStruct`.\n+\n+This is an antipattern in Rust. Instead, write this:\n+\n+```rust\n+#![feature(box_syntax)]\n+\n+struct BigStruct {\n+    one: i32,\n+    two: i32,\n+    // etc\n+    one_hundred: i32,\n+}\n+\n+fn foo(x: Box<BigStruct>) -> BigStruct {\n+    *x\n+}\n+\n+fn main() {\n+    let x = Box::new(BigStruct {\n+        one: 1,\n+        two: 2,\n+        one_hundred: 100,\n+    });\n+\n+    let y: Box<BigStruct> = box foo(x);\n+}\n+```\n+\n+This gives you flexibility without sacrificing performance.\n+\n+You may think that this gives us terrible performance: return a value and then\n+immediately box it up ?! Isn't this pattern the worst of both worlds? Rust is\n+smarter than that. There is no copy in this code. `main` allocates enough room\n+for the `box`, passes a pointer to that memory into `foo` as `x`, and then\n+`foo` writes the value straight into the `Box<T>`.\n+\n+This is important enough that it bears repeating: pointers are not for\n+optimizing returning values from your code. Allow the caller to choose how they\n+want to use your output."}, {"sha": "1b3f2a5b7734cc2dcdc44fd10e678dea53f5817b", "filename": "src/doc/trpl/pointers.md", "status": "modified", "additions": 2, "deletions": 84, "changes": 86, "blob_url": "https://github.com/rust-lang/rust/blob/00d929dcb33d0d4f734d85f7ad32716022de53cd/src%2Fdoc%2Ftrpl%2Fpointers.md", "raw_url": "https://github.com/rust-lang/rust/raw/00d929dcb33d0d4f734d85f7ad32716022de53cd/src%2Fdoc%2Ftrpl%2Fpointers.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Fpointers.md?ref=00d929dcb33d0d4f734d85f7ad32716022de53cd", "patch": "@@ -574,7 +574,7 @@ fn main() {\n ```\n \n We can mutably borrow `x` multiple times, but only if x itself is mutable, and\n-it may not be *simultaneously* borrowed: \n+it may not be *simultaneously* borrowed:\n \n ```{rust,ignore}\n fn increment(x: &mut i32) {\n@@ -595,8 +595,7 @@ Notice the signature of `increment()` requests a mutable reference.\n \n ## Best practices\n \n-Boxes are appropriate to use in two situations: Recursive data structures,\n-and occasionally, when returning data.\n+Boxes are most appropriate to use when defining recursive data structures.\n \n ### Recursive data structures\n \n@@ -630,14 +629,6 @@ we don't know the size, and therefore, we need to heap allocate our list.\n Working with recursive or other unknown-sized data structures is the primary\n use-case for boxes.\n \n-### Returning data\n-\n-This is important enough to have its own section entirely. The TL;DR is this:\n-you don't want to return pointers, even when you might in a language like C or\n-C++.\n-\n-See [Returning Pointers](#returning-pointers) below for more.\n-\n # Rc and Arc\n \n This part is coming soon.\n@@ -654,79 +645,6 @@ This part is coming soon.\n \n This part is coming soon.\n \n-# Returning Pointers\n-\n-In many languages with pointers, you'd return a pointer from a function\n-so as to avoid copying a large data structure. For example:\n-\n-```{rust}\n-struct BigStruct {\n-    one: i32,\n-    two: i32,\n-    // etc\n-    one_hundred: i32,\n-}\n-\n-fn foo(x: Box<BigStruct>) -> Box<BigStruct> {\n-    Box::new(*x)\n-}\n-\n-fn main() {\n-    let x = Box::new(BigStruct {\n-        one: 1,\n-        two: 2,\n-        one_hundred: 100,\n-    });\n-\n-    let y = foo(x);\n-}\n-```\n-\n-The idea is that by passing around a box, you're only copying a pointer, rather\n-than the hundred `int`s that make up the `BigStruct`.\n-\n-This is an antipattern in Rust. Instead, write this:\n-\n-```rust\n-#![feature(box_syntax)]\n-\n-struct BigStruct {\n-    one: i32,\n-    two: i32,\n-    // etc\n-    one_hundred: i32,\n-}\n-\n-fn foo(x: Box<BigStruct>) -> BigStruct {\n-    *x\n-}\n-\n-fn main() {\n-    let x = Box::new(BigStruct {\n-        one: 1,\n-        two: 2,\n-        one_hundred: 100,\n-    });\n-\n-    let y: Box<BigStruct> = box foo(x);\n-}\n-```\n-\n-Note that this uses the `box_syntax` feature gate, so this syntax may change in\n-the future.\n-\n-This gives you flexibility without sacrificing performance.\n-\n-You may think that this gives us terrible performance: return a value and then\n-immediately box it up ?! Isn't this pattern the worst of both worlds? Rust is\n-smarter than that. There is no copy in this code. `main` allocates enough room\n-for the `box`, passes a pointer to that memory into `foo` as `x`, and then\n-`foo` writes the value straight into the `Box<T>`.\n-\n-This is important enough that it bears repeating: pointers are not for\n-optimizing returning values from your code. Allow the caller to choose how they\n-want to use your output.\n-\n # Creating your own Pointers\n \n This part is coming soon."}]}