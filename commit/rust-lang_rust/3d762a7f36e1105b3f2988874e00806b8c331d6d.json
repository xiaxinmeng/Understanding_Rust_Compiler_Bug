{"sha": "3d762a7f36e1105b3f2988874e00806b8c331d6d", "node_id": "MDY6Q29tbWl0NzI0NzEyOjNkNzYyYTdmMzZlMTEwNWIzZjI5ODg4NzRlMDA4MDZiOGMzMzFkNmQ=", "commit": {"author": {"name": "Yuki Okushi", "email": "huyuumi.dev@gmail.com", "date": "2021-03-07T01:41:11Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2021-03-07T01:41:11Z"}, "message": "Rollup merge of #82402 - jyn514:module-cache-refcell, r=GuillaumeGomez\n\nRemove RefCell around `module_trait_cache`\n\nThis builds on https://github.com/rust-lang/rust/pull/82018 and should not be merged before.\n\n## Don't require a `DocContext` for `report_diagnostic`\n\nThis is needed for the next commit, which needs mutable access to the `cx` from\nwithin the `decorate` closure.\n\n- Change `as_local_hir_id` to an associated function, since it only\n  needs a `TyCtxt`\n- Change `source_span_for_markdown_range` to only take a `TyCtxt`\n\n##  Remove RefCell around module_trait_cache\n\nThis is mostly just changing lots of functions from `&DocContext` to `&mut DocContext`.", "tree": {"sha": "7eb5af5361e5072ed924f2b57356bf5cf2412cbd", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7eb5af5361e5072ed924f2b57356bf5cf2412cbd"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3d762a7f36e1105b3f2988874e00806b8c331d6d", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJgRC83CRBK7hj4Ov3rIwAAdHIIAJ+NjyMCz2NFP02cnJ6icRt6\nrCQaeZI5go94aqQFYSvt56J97HvYyz6TdwQNOQ0hRfmPzPehRgVTKCI1DDAFLaQa\nIuWPooaeOj5y5Gvx2BVfe5QuIIq9UPRojQ+ipQi2ZRooo5R0KLuzFO7IXG9rg1H4\n5/hmhpiiljs9+hrABS+gs35aH0mFzcg8iNbu4rfeUMv5vgfnRtuy0iC5YS/4ejpb\neyStKe8pdJ2I9RTAjZQCB3qG6yrgDWzw4kle6ulXMm20/1kWyO+OYYJ3RWDWiT9O\n//CTxVz0EbZDe0bUOrsVP4flQoPfolCxaBvzyuSGITOMGTGAF8B9zBLKHx4UjBA=\n=rrcI\n-----END PGP SIGNATURE-----\n", "payload": "tree 7eb5af5361e5072ed924f2b57356bf5cf2412cbd\nparent 1d5b2dc945124c619ebb3641c096c063ca8ca1e5\nparent 675edd0231fd799f130ae2d46e079b3753475449\nauthor Yuki Okushi <huyuumi.dev@gmail.com> 1615081271 +0900\ncommitter GitHub <noreply@github.com> 1615081271 +0900\n\nRollup merge of #82402 - jyn514:module-cache-refcell, r=GuillaumeGomez\n\nRemove RefCell around `module_trait_cache`\n\nThis builds on https://github.com/rust-lang/rust/pull/82018 and should not be merged before.\n\n## Don't require a `DocContext` for `report_diagnostic`\n\nThis is needed for the next commit, which needs mutable access to the `cx` from\nwithin the `decorate` closure.\n\n- Change `as_local_hir_id` to an associated function, since it only\n  needs a `TyCtxt`\n- Change `source_span_for_markdown_range` to only take a `TyCtxt`\n\n##  Remove RefCell around module_trait_cache\n\nThis is mostly just changing lots of functions from `&DocContext` to `&mut DocContext`.\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3d762a7f36e1105b3f2988874e00806b8c331d6d", "html_url": "https://github.com/rust-lang/rust/commit/3d762a7f36e1105b3f2988874e00806b8c331d6d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3d762a7f36e1105b3f2988874e00806b8c331d6d/comments", "author": {"login": "JohnTitor", "id": 25030997, "node_id": "MDQ6VXNlcjI1MDMwOTk3", "avatar_url": "https://avatars.githubusercontent.com/u/25030997?v=4", "gravatar_id": "", "url": "https://api.github.com/users/JohnTitor", "html_url": "https://github.com/JohnTitor", "followers_url": "https://api.github.com/users/JohnTitor/followers", "following_url": "https://api.github.com/users/JohnTitor/following{/other_user}", "gists_url": "https://api.github.com/users/JohnTitor/gists{/gist_id}", "starred_url": "https://api.github.com/users/JohnTitor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/JohnTitor/subscriptions", "organizations_url": "https://api.github.com/users/JohnTitor/orgs", "repos_url": "https://api.github.com/users/JohnTitor/repos", "events_url": "https://api.github.com/users/JohnTitor/events{/privacy}", "received_events_url": "https://api.github.com/users/JohnTitor/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1d5b2dc945124c619ebb3641c096c063ca8ca1e5", "url": "https://api.github.com/repos/rust-lang/rust/commits/1d5b2dc945124c619ebb3641c096c063ca8ca1e5", "html_url": "https://github.com/rust-lang/rust/commit/1d5b2dc945124c619ebb3641c096c063ca8ca1e5"}, {"sha": "675edd0231fd799f130ae2d46e079b3753475449", "url": "https://api.github.com/repos/rust-lang/rust/commits/675edd0231fd799f130ae2d46e079b3753475449", "html_url": "https://github.com/rust-lang/rust/commit/675edd0231fd799f130ae2d46e079b3753475449"}], "stats": {"total": 106, "additions": 56, "deletions": 50}, "files": [{"sha": "bcbc6e557d0a908921df32948ef45e7e8664394a", "filename": "src/librustdoc/core.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/3d762a7f36e1105b3f2988874e00806b8c331d6d/src%2Flibrustdoc%2Fcore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d762a7f36e1105b3f2988874e00806b8c331d6d/src%2Flibrustdoc%2Fcore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fcore.rs?ref=3d762a7f36e1105b3f2988874e00806b8c331d6d", "patch": "@@ -76,7 +76,7 @@ crate struct DocContext<'tcx> {\n     ///\n     /// See `collect_intra_doc_links::traits_implemented_by` for more details.\n     /// `map<module, set<trait>>`\n-    crate module_trait_cache: RefCell<FxHashMap<DefId, FxHashSet<DefId>>>,\n+    crate module_trait_cache: FxHashMap<DefId, FxHashSet<DefId>>,\n     /// This same cache is used throughout rustdoc, including in [`crate::html::render`].\n     crate cache: Cache,\n     /// Used by [`clean::inline`] to tell if an item has already been inlined.\n@@ -169,13 +169,13 @@ impl<'tcx> DocContext<'tcx> {\n \n     /// Like `hir().local_def_id_to_hir_id()`, but skips calling it on fake DefIds.\n     /// (This avoids a slice-index-out-of-bounds panic.)\n-    crate fn as_local_hir_id(&self, def_id: DefId) -> Option<HirId> {\n+    crate fn as_local_hir_id(tcx: TyCtxt<'_>, def_id: DefId) -> Option<HirId> {\n         if MAX_DEF_IDX.with(|m| {\n             m.borrow().get(&def_id.krate).map(|&idx| idx <= def_id.index).unwrap_or(false)\n         }) {\n             None\n         } else {\n-            def_id.as_local().map(|def_id| self.tcx.hir().local_def_id_to_hir_id(def_id))\n+            def_id.as_local().map(|def_id| tcx.hir().local_def_id_to_hir_id(def_id))\n         }\n     }\n }\n@@ -450,7 +450,7 @@ crate fn run_global_ctxt(\n             .cloned()\n             .filter(|trait_def_id| tcx.trait_is_auto(*trait_def_id))\n             .collect(),\n-        module_trait_cache: RefCell::new(FxHashMap::default()),\n+        module_trait_cache: FxHashMap::default(),\n         cache: Cache::new(access_levels, render_options.document_private),\n         inlined: FxHashSet::default(),\n         output_format,\n@@ -479,7 +479,7 @@ crate fn run_global_ctxt(\n                 https://doc.rust-lang.org/nightly/rustdoc/how-to-write-documentation.html\";\n             tcx.struct_lint_node(\n                 crate::lint::MISSING_CRATE_LEVEL_DOCS,\n-                ctxt.as_local_hir_id(m.def_id).unwrap(),\n+                DocContext::as_local_hir_id(tcx, m.def_id).unwrap(),\n                 |lint| {\n                     let mut diag =\n                         lint.build(\"no documentation found for this crate's top-level module\");"}, {"sha": "98886139f30882bf45efaf803eab359e03d54180", "filename": "src/librustdoc/passes/check_code_block_syntax.rs", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/3d762a7f36e1105b3f2988874e00806b8c331d6d/src%2Flibrustdoc%2Fpasses%2Fcheck_code_block_syntax.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d762a7f36e1105b3f2988874e00806b8c331d6d/src%2Flibrustdoc%2Fpasses%2Fcheck_code_block_syntax.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fcheck_code_block_syntax.rs?ref=3d762a7f36e1105b3f2988874e00806b8c331d6d", "patch": "@@ -48,9 +48,12 @@ impl<'a, 'tcx> SyntaxChecker<'a, 'tcx> {\n         let buffer = buffer.borrow();\n \n         if buffer.has_errors || is_empty {\n-            let mut diag = if let Some(sp) =\n-                super::source_span_for_markdown_range(self.cx, &dox, &code_block.range, &item.attrs)\n-            {\n+            let mut diag = if let Some(sp) = super::source_span_for_markdown_range(\n+                self.cx.tcx,\n+                &dox,\n+                &code_block.range,\n+                &item.attrs,\n+            ) {\n                 let (warning_message, suggest_using_text) = if buffer.has_errors {\n                     (\"could not parse code block as Rust code\", true)\n                 } else {"}, {"sha": "ec5994b762b8a9e385344e4c264cc87f2d795bf4", "filename": "src/librustdoc/passes/collect_intra_doc_links.rs", "status": "modified", "additions": 34, "deletions": 33, "changes": 67, "blob_url": "https://github.com/rust-lang/rust/blob/3d762a7f36e1105b3f2988874e00806b8c331d6d/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d762a7f36e1105b3f2988874e00806b8c331d6d/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs?ref=3d762a7f36e1105b3f2988874e00806b8c331d6d", "patch": "@@ -484,21 +484,23 @@ impl<'a, 'tcx> LinkCollector<'a, 'tcx> {\n     /// Resolves a string as a path within a particular namespace. Returns an\n     /// optional URL fragment in the case of variants and methods.\n     fn resolve<'path>(\n-        &self,\n+        &mut self,\n         path_str: &'path str,\n         ns: Namespace,\n         module_id: DefId,\n         extra_fragment: &Option<String>,\n     ) -> Result<(Res, Option<String>), ErrorKind<'path>> {\n-        let cx = &self.cx;\n+        let tcx = self.cx.tcx;\n \n         if let Some(res) = self.resolve_path(path_str, ns, module_id) {\n             match res {\n                 // FIXME(#76467): make this fallthrough to lookup the associated\n                 // item a separate function.\n                 Res::Def(DefKind::AssocFn | DefKind::AssocConst, _) => assert_eq!(ns, ValueNS),\n                 Res::Def(DefKind::AssocTy, _) => assert_eq!(ns, TypeNS),\n-                Res::Def(DefKind::Variant, _) => return handle_variant(cx, res, extra_fragment),\n+                Res::Def(DefKind::Variant, _) => {\n+                    return handle_variant(self.cx, res, extra_fragment);\n+                }\n                 // Not a trait item; just return what we found.\n                 Res::Primitive(ty) => {\n                     if extra_fragment.is_some() {\n@@ -565,13 +567,12 @@ impl<'a, 'tcx> LinkCollector<'a, 'tcx> {\n             ) => {\n                 debug!(\"looking for associated item named {} for item {:?}\", item_name, did);\n                 // Checks if item_name belongs to `impl SomeItem`\n-                let assoc_item = cx\n-                    .tcx\n+                let assoc_item = tcx\n                     .inherent_impls(did)\n                     .iter()\n                     .flat_map(|&imp| {\n-                        cx.tcx.associated_items(imp).find_by_name_and_namespace(\n-                            cx.tcx,\n+                        tcx.associated_items(imp).find_by_name_and_namespace(\n+                            tcx,\n                             Ident::with_dummy_span(item_name),\n                             ns,\n                             imp,\n@@ -587,7 +588,7 @@ impl<'a, 'tcx> LinkCollector<'a, 'tcx> {\n                     // something like [`ambi_fn`](<SomeStruct as SomeTrait>::ambi_fn)\n                     .or_else(|| {\n                         let kind =\n-                            resolve_associated_trait_item(did, module_id, item_name, ns, &self.cx);\n+                            resolve_associated_trait_item(did, module_id, item_name, ns, self.cx);\n                         debug!(\"got associated item kind {:?}\", kind);\n                         kind\n                     });\n@@ -611,7 +612,7 @@ impl<'a, 'tcx> LinkCollector<'a, 'tcx> {\n                     debug!(\"looking for variants or fields named {} for {:?}\", item_name, did);\n                     // FIXME(jynelson): why is this different from\n                     // `variant_field`?\n-                    match cx.tcx.type_of(did).kind() {\n+                    match tcx.type_of(did).kind() {\n                         ty::Adt(def, _) => {\n                             let field = if def.is_enum() {\n                                 def.all_fields().find(|item| item.ident.name == item_name)\n@@ -652,10 +653,9 @@ impl<'a, 'tcx> LinkCollector<'a, 'tcx> {\n                     None\n                 }\n             }\n-            Res::Def(DefKind::Trait, did) => cx\n-                .tcx\n+            Res::Def(DefKind::Trait, did) => tcx\n                 .associated_items(did)\n-                .find_by_name_and_namespace(cx.tcx, Ident::with_dummy_span(item_name), ns, did)\n+                .find_by_name_and_namespace(tcx, Ident::with_dummy_span(item_name), ns, did)\n                 .map(|item| {\n                     let kind = match item.kind {\n                         ty::AssocKind::Const => \"associatedconstant\",\n@@ -699,7 +699,7 @@ impl<'a, 'tcx> LinkCollector<'a, 'tcx> {\n     /// This returns the `Res` even if it was erroneous for some reason\n     /// (such as having invalid URL fragments or being in the wrong namespace).\n     fn check_full_res(\n-        &self,\n+        &mut self,\n         ns: Namespace,\n         path_str: &str,\n         module_id: DefId,\n@@ -733,7 +733,7 @@ fn resolve_associated_trait_item(\n     module: DefId,\n     item_name: Symbol,\n     ns: Namespace,\n-    cx: &DocContext<'_>,\n+    cx: &mut DocContext<'_>,\n ) -> Option<(ty::AssocKind, DefId)> {\n     // FIXME: this should also consider blanket impls (`impl<T> X for T`). Unfortunately\n     // `get_auto_trait_and_blanket_impls` is broken because the caching behavior is wrong. In the\n@@ -758,10 +758,10 @@ fn resolve_associated_trait_item(\n ///\n /// NOTE: this cannot be a query because more traits could be available when more crates are compiled!\n /// So it is not stable to serialize cross-crate.\n-fn traits_implemented_by(cx: &DocContext<'_>, type_: DefId, module: DefId) -> FxHashSet<DefId> {\n-    let mut cache = cx.module_trait_cache.borrow_mut();\n-    let in_scope_traits = cache.entry(module).or_insert_with(|| {\n-        cx.enter_resolver(|resolver| {\n+fn traits_implemented_by(cx: &mut DocContext<'_>, type_: DefId, module: DefId) -> FxHashSet<DefId> {\n+    let mut resolver = cx.resolver.borrow_mut();\n+    let in_scope_traits = cx.module_trait_cache.entry(module).or_insert_with(|| {\n+        resolver.access(|resolver| {\n             let parent_scope = &ParentScope::module(resolver.get_module(module), resolver);\n             resolver\n                 .traits_in_scope(None, parent_scope, SyntaxContext::root(), None)\n@@ -771,13 +771,14 @@ fn traits_implemented_by(cx: &DocContext<'_>, type_: DefId, module: DefId) -> Fx\n         })\n     });\n \n-    let ty = cx.tcx.type_of(type_);\n+    let tcx = cx.tcx;\n+    let ty = tcx.type_of(type_);\n     let iter = in_scope_traits.iter().flat_map(|&trait_| {\n         trace!(\"considering explicit impl for trait {:?}\", trait_);\n \n         // Look at each trait implementation to see if it's an impl for `did`\n-        cx.tcx.find_map_relevant_impl(trait_, ty, |impl_| {\n-            let trait_ref = cx.tcx.impl_trait_ref(impl_).expect(\"this is not an inherent impl\");\n+        tcx.find_map_relevant_impl(trait_, ty, |impl_| {\n+            let trait_ref = tcx.impl_trait_ref(impl_).expect(\"this is not an inherent impl\");\n             // Check if these are the same type.\n             let impl_type = trait_ref.self_ty();\n             trace!(\n@@ -1146,7 +1147,7 @@ impl LinkCollector<'_, '_> {\n                 suggest_disambiguator(resolved, diag, path_str, dox, sp, &ori_link.range);\n             };\n             report_diagnostic(\n-                self.cx,\n+                self.cx.tcx,\n                 BROKEN_INTRA_DOC_LINKS,\n                 &msg,\n                 &item,\n@@ -1220,7 +1221,7 @@ impl LinkCollector<'_, '_> {\n                         && !self.cx.tcx.features().intra_doc_pointers\n                     {\n                         let span = super::source_span_for_markdown_range(\n-                            self.cx,\n+                            self.cx.tcx,\n                             dox,\n                             &ori_link.range,\n                             &item.attrs,\n@@ -1308,7 +1309,7 @@ impl LinkCollector<'_, '_> {\n     /// After parsing the disambiguator, resolve the main part of the link.\n     // FIXME(jynelson): wow this is just so much\n     fn resolve_with_disambiguator(\n-        &self,\n+        &mut self,\n         key: &ResolutionInfo,\n         diag: DiagnosticInfo<'_>,\n     ) -> Option<(Res, Option<String>)> {\n@@ -1674,15 +1675,15 @@ impl Suggestion {\n /// parameter of the callback will contain it, and the primary span of the diagnostic will be set\n /// to it.\n fn report_diagnostic(\n-    cx: &DocContext<'_>,\n+    tcx: TyCtxt<'_>,\n     lint: &'static Lint,\n     msg: &str,\n     item: &Item,\n     dox: &str,\n     link_range: &Range<usize>,\n     decorate: impl FnOnce(&mut DiagnosticBuilder<'_>, Option<rustc_span::Span>),\n ) {\n-    let hir_id = match cx.as_local_hir_id(item.def_id) {\n+    let hir_id = match DocContext::as_local_hir_id(tcx, item.def_id) {\n         Some(hir_id) => hir_id,\n         None => {\n             // If non-local, no need to check anything.\n@@ -1694,10 +1695,10 @@ fn report_diagnostic(\n     let attrs = &item.attrs;\n     let sp = span_of_attrs(attrs).unwrap_or(item.source.span());\n \n-    cx.tcx.struct_span_lint_hir(lint, hir_id, sp, |lint| {\n+    tcx.struct_span_lint_hir(lint, hir_id, sp, |lint| {\n         let mut diag = lint.build(msg);\n \n-        let span = super::source_span_for_markdown_range(cx, dox, link_range, attrs);\n+        let span = super::source_span_for_markdown_range(tcx, dox, link_range, attrs);\n \n         if let Some(sp) = span {\n             diag.set_span(sp);\n@@ -1732,7 +1733,7 @@ fn report_diagnostic(\n /// handled earlier. For example, if passed `Item::Crate(std)` and `path_str`\n /// `std::io::Error::x`, this will resolve `std::io::Error`.\n fn resolution_failure(\n-    collector: &LinkCollector<'_, '_>,\n+    collector: &mut LinkCollector<'_, '_>,\n     item: &Item,\n     path_str: &str,\n     disambiguator: Option<Disambiguator>,\n@@ -1742,7 +1743,7 @@ fn resolution_failure(\n ) {\n     let tcx = collector.cx.tcx;\n     report_diagnostic(\n-        collector.cx,\n+        tcx,\n         BROKEN_INTRA_DOC_LINKS,\n         &format!(\"unresolved link to `{}`\", path_str),\n         item,\n@@ -1973,7 +1974,7 @@ fn anchor_failure(\n         ),\n     };\n \n-    report_diagnostic(cx, BROKEN_INTRA_DOC_LINKS, &msg, item, dox, &link_range, |diag, sp| {\n+    report_diagnostic(cx.tcx, BROKEN_INTRA_DOC_LINKS, &msg, item, dox, &link_range, |diag, sp| {\n         if let Some(sp) = sp {\n             diag.span_label(sp, \"contains invalid anchor\");\n         }\n@@ -2013,7 +2014,7 @@ fn ambiguity_error(\n         }\n     }\n \n-    report_diagnostic(cx, BROKEN_INTRA_DOC_LINKS, &msg, item, dox, &link_range, |diag, sp| {\n+    report_diagnostic(cx.tcx, BROKEN_INTRA_DOC_LINKS, &msg, item, dox, &link_range, |diag, sp| {\n         if let Some(sp) = sp {\n             diag.span_label(sp, \"ambiguous link\");\n         } else {\n@@ -2066,7 +2067,7 @@ fn privacy_error(cx: &DocContext<'_>, item: &Item, path_str: &str, dox: &str, li\n     let msg =\n         format!(\"public documentation for `{}` links to private item `{}`\", item_name, path_str);\n \n-    report_diagnostic(cx, PRIVATE_INTRA_DOC_LINKS, &msg, item, dox, &link.range, |diag, sp| {\n+    report_diagnostic(cx.tcx, PRIVATE_INTRA_DOC_LINKS, &msg, item, dox, &link.range, |diag, sp| {\n         if let Some(sp) = sp {\n             diag.span_label(sp, \"this item is private\");\n         }"}, {"sha": "951258db9e2a28edf79a366aafbf37408f0f0aea", "filename": "src/librustdoc/passes/doc_test_lints.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3d762a7f36e1105b3f2988874e00806b8c331d6d/src%2Flibrustdoc%2Fpasses%2Fdoc_test_lints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d762a7f36e1105b3f2988874e00806b8c331d6d/src%2Flibrustdoc%2Fpasses%2Fdoc_test_lints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fdoc_test_lints.rs?ref=3d762a7f36e1105b3f2988874e00806b8c331d6d", "patch": "@@ -82,7 +82,7 @@ crate fn should_have_doc_example(cx: &DocContext<'_>, item: &clean::Item) -> boo\n }\n \n crate fn look_for_tests<'tcx>(cx: &DocContext<'tcx>, dox: &str, item: &Item) {\n-    let hir_id = match cx.as_local_hir_id(item.def_id) {\n+    let hir_id = match DocContext::as_local_hir_id(cx.tcx, item.def_id) {\n         Some(hir_id) => hir_id,\n         None => {\n             // If non-local, no need to check anything."}, {"sha": "23364b6fec9d139de44c4ed212a0d4d2acaadceb", "filename": "src/librustdoc/passes/html_tags.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/3d762a7f36e1105b3f2988874e00806b8c331d6d/src%2Flibrustdoc%2Fpasses%2Fhtml_tags.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d762a7f36e1105b3f2988874e00806b8c331d6d/src%2Flibrustdoc%2Fpasses%2Fhtml_tags.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fhtml_tags.rs?ref=3d762a7f36e1105b3f2988874e00806b8c331d6d", "patch": "@@ -167,7 +167,8 @@ fn extract_tags(\n \n impl<'a, 'tcx> DocFolder for InvalidHtmlTagsLinter<'a, 'tcx> {\n     fn fold_item(&mut self, item: Item) -> Option<Item> {\n-        let hir_id = match self.cx.as_local_hir_id(item.def_id) {\n+        let tcx = self.cx.tcx;\n+        let hir_id = match DocContext::as_local_hir_id(tcx, item.def_id) {\n             Some(hir_id) => hir_id,\n             None => {\n                 // If non-local, no need to check anything.\n@@ -176,13 +177,13 @@ impl<'a, 'tcx> DocFolder for InvalidHtmlTagsLinter<'a, 'tcx> {\n         };\n         let dox = item.attrs.collapsed_doc_value().unwrap_or_default();\n         if !dox.is_empty() {\n-            let cx = &self.cx;\n             let report_diag = |msg: &str, range: &Range<usize>| {\n-                let sp = match super::source_span_for_markdown_range(cx, &dox, range, &item.attrs) {\n+                let sp = match super::source_span_for_markdown_range(tcx, &dox, range, &item.attrs)\n+                {\n                     Some(sp) => sp,\n                     None => span_of_attrs(&item.attrs).unwrap_or(item.source.span()),\n                 };\n-                cx.tcx.struct_span_lint_hir(crate::lint::INVALID_HTML_TAGS, hir_id, sp, |lint| {\n+                tcx.struct_span_lint_hir(crate::lint::INVALID_HTML_TAGS, hir_id, sp, |lint| {\n                     lint.build(msg).emit()\n                 });\n             };"}, {"sha": "4c639c8496db30108b4e468d0769fafd89deaf08", "filename": "src/librustdoc/passes/mod.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/3d762a7f36e1105b3f2988874e00806b8c331d6d/src%2Flibrustdoc%2Fpasses%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d762a7f36e1105b3f2988874e00806b8c331d6d/src%2Flibrustdoc%2Fpasses%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fmod.rs?ref=3d762a7f36e1105b3f2988874e00806b8c331d6d", "patch": "@@ -1,6 +1,7 @@\n //! Contains information about \"passes\", used to modify crate information during the documentation\n //! process.\n \n+use rustc_middle::ty::TyCtxt;\n use rustc_span::{InnerSpan, Span, DUMMY_SP};\n use std::ops::Range;\n \n@@ -167,7 +168,7 @@ crate fn span_of_attrs(attrs: &clean::Attributes) -> Option<Span> {\n /// attributes are not all sugared doc comments. It's difficult to calculate the correct span in\n /// that case due to escaping and other source features.\n crate fn source_span_for_markdown_range(\n-    cx: &DocContext<'_>,\n+    tcx: TyCtxt<'_>,\n     markdown: &str,\n     md_range: &Range<usize>,\n     attrs: &clean::Attributes,\n@@ -179,7 +180,7 @@ crate fn source_span_for_markdown_range(\n         return None;\n     }\n \n-    let snippet = cx.sess().source_map().span_to_snippet(span_of_attrs(attrs)?).ok()?;\n+    let snippet = tcx.sess.source_map().span_to_snippet(span_of_attrs(attrs)?).ok()?;\n \n     let starting_line = markdown[..md_range.start].matches('\\n').count();\n     let ending_line = starting_line + markdown[md_range.start..md_range.end].matches('\\n').count();"}, {"sha": "16ad940c627173d04b7d56142934c81d7e139dc7", "filename": "src/librustdoc/passes/non_autolinks.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3d762a7f36e1105b3f2988874e00806b8c331d6d/src%2Flibrustdoc%2Fpasses%2Fnon_autolinks.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d762a7f36e1105b3f2988874e00806b8c331d6d/src%2Flibrustdoc%2Fpasses%2Fnon_autolinks.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fnon_autolinks.rs?ref=3d762a7f36e1105b3f2988874e00806b8c331d6d", "patch": "@@ -60,7 +60,7 @@ crate fn check_non_autolinks(krate: Crate, cx: &mut DocContext<'_>) -> Crate {\n \n impl<'a, 'tcx> DocFolder for NonAutolinksLinter<'a, 'tcx> {\n     fn fold_item(&mut self, item: Item) -> Option<Item> {\n-        let hir_id = match self.cx.as_local_hir_id(item.def_id) {\n+        let hir_id = match DocContext::as_local_hir_id(self.cx.tcx, item.def_id) {\n             Some(hir_id) => hir_id,\n             None => {\n                 // If non-local, no need to check anything.\n@@ -70,7 +70,7 @@ impl<'a, 'tcx> DocFolder for NonAutolinksLinter<'a, 'tcx> {\n         let dox = item.attrs.collapsed_doc_value().unwrap_or_default();\n         if !dox.is_empty() {\n             let report_diag = |cx: &DocContext<'_>, msg: &str, url: &str, range: Range<usize>| {\n-                let sp = super::source_span_for_markdown_range(cx, &dox, &range, &item.attrs)\n+                let sp = super::source_span_for_markdown_range(cx.tcx, &dox, &range, &item.attrs)\n                     .or_else(|| span_of_attrs(&item.attrs))\n                     .unwrap_or(item.source.span());\n                 cx.tcx.struct_span_lint_hir(crate::lint::NON_AUTOLINKS, hir_id, sp, |lint| {"}]}