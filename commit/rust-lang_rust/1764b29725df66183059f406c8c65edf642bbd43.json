{"sha": "1764b29725df66183059f406c8c65edf642bbd43", "node_id": "MDY6Q29tbWl0NzI0NzEyOjE3NjRiMjk3MjVkZjY2MTgzMDU5ZjQwNmM4YzY1ZWRmNjQyYmJkNDM=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-05-12T17:44:06Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-05-12T17:44:06Z"}, "message": "Auto merge of #60679 - petrochenkov:lit2, r=matklad\n\nKeep original literal tokens in AST\n\nThe original literal tokens (`token::Lit`) are kept in AST until lowering to HIR.\n\nThe tokens are kept together with their lowered \"semantic\" representation (`ast::LitKind`), so the size of `ast::Lit` is increased (this also increases the size of meta-item structs used for processing built-in attributes).\nHowever, the size of `ast::Expr` stays the same.\n\nThe intent is to remove the \"semantic\" representation from AST eventually and keep literals as tokens until lowering to HIR (at least), and I'm going to work on that, but it would be good to land this sooner to unblock progress on the [lexer refactoring](https://github.com/rust-lang/rust/pull/59706).\n\nFixes a part of https://github.com/rust-lang/rust/issues/43081 (literal tokens that are passed to proc macros are always precise, including hexadecimal numbers, strings with their original escaping, etc)\nFixes a part of https://github.com/rust-lang/rust/issues/60495 (everything except for proc macro API doesn't need escaping anymore)\nThis also allows to eliminate a certain hack from the lexer (https://rust-lang.zulipchat.com/#narrow/stream/131828-t-compiler/topic/pretty-printing.20comments/near/165005357).\n\ncc @matklad", "tree": {"sha": "3a4dca92cceba00645c5a8f29c9f4d36b06cd61c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3a4dca92cceba00645c5a8f29c9f4d36b06cd61c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1764b29725df66183059f406c8c65edf642bbd43", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1764b29725df66183059f406c8c65edf642bbd43", "html_url": "https://github.com/rust-lang/rust/commit/1764b29725df66183059f406c8c65edf642bbd43", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1764b29725df66183059f406c8c65edf642bbd43/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0df1e57991e34825697b1659732c0716e7508519", "url": "https://api.github.com/repos/rust-lang/rust/commits/0df1e57991e34825697b1659732c0716e7508519", "html_url": "https://github.com/rust-lang/rust/commit/0df1e57991e34825697b1659732c0716e7508519"}, {"sha": "83ed781c017632d48746553bdb2bf3d1633d5ca4", "url": "https://api.github.com/repos/rust-lang/rust/commits/83ed781c017632d48746553bdb2bf3d1633d5ca4", "html_url": "https://github.com/rust-lang/rust/commit/83ed781c017632d48746553bdb2bf3d1633d5ca4"}], "stats": {"total": 1467, "additions": 671, "deletions": 796}, "files": [{"sha": "5b334b24e2f41df8b83325fd3f3be7be3b7b4ade", "filename": "src/librustc/hir/lowering.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1764b29725df66183059f406c8c65edf642bbd43/src%2Flibrustc%2Fhir%2Flowering.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1764b29725df66183059f406c8c65edf642bbd43/src%2Flibrustc%2Fhir%2Flowering.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Flowering.rs?ref=1764b29725df66183059f406c8c65edf642bbd43", "patch": "@@ -4100,7 +4100,7 @@ impl<'a> LoweringContext<'a> {\n                 let ohs = P(self.lower_expr(ohs));\n                 hir::ExprKind::Unary(op, ohs)\n             }\n-            ExprKind::Lit(ref l) => hir::ExprKind::Lit((*l).clone()),\n+            ExprKind::Lit(ref l) => hir::ExprKind::Lit(respan(l.span, l.node.clone())),\n             ExprKind::Cast(ref expr, ref ty) => {\n                 let expr = P(self.lower_expr(expr));\n                 hir::ExprKind::Cast(expr, self.lower_ty(ty, ImplTraitContext::disallowed()))"}, {"sha": "d645898692806c5925b86a792790fd2249cb08b7", "filename": "src/librustc/hir/mod.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/1764b29725df66183059f406c8c65edf642bbd43/src%2Flibrustc%2Fhir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1764b29725df66183059f406c8c65edf642bbd43/src%2Flibrustc%2Fhir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmod.rs?ref=1764b29725df66183059f406c8c65edf642bbd43", "patch": "@@ -20,7 +20,7 @@ use syntax_pos::{Span, DUMMY_SP, symbol::InternedString};\n use syntax::source_map::Spanned;\n use rustc_target::spec::abi::Abi;\n use syntax::ast::{self, CrateSugar, Ident, Name, NodeId, AsmDialect};\n-use syntax::ast::{Attribute, Label, Lit, StrStyle, FloatTy, IntTy, UintTy};\n+use syntax::ast::{Attribute, Label, LitKind, StrStyle, FloatTy, IntTy, UintTy};\n use syntax::attr::{InlineAttr, OptimizeAttr};\n use syntax::ext::hygiene::SyntaxContext;\n use syntax::ptr::P;\n@@ -1331,6 +1331,9 @@ impl BodyOwnerKind {\n     }\n }\n \n+/// A literal.\n+pub type Lit = Spanned<LitKind>;\n+\n /// A constant (expression) that's not an item or associated item,\n /// but needs its own `DefId` for type-checking, const-eval, etc.\n /// These are usually found nested inside types (e.g., array lengths)"}, {"sha": "475bf8d83723957639cd6a36471cdc782167cc26", "filename": "src/librustc/hir/print.rs", "status": "modified", "additions": 14, "deletions": 36, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/1764b29725df66183059f406c8c65edf642bbd43/src%2Flibrustc%2Fhir%2Fprint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1764b29725df66183059f406c8c65edf642bbd43/src%2Flibrustc%2Fhir%2Fprint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fprint.rs?ref=1764b29725df66183059f406c8c65edf642bbd43", "patch": "@@ -5,7 +5,7 @@ use syntax::parse::ParseSess;\n use syntax::parse::lexer::comments;\n use syntax::print::pp::{self, Breaks};\n use syntax::print::pp::Breaks::{Consistent, Inconsistent};\n-use syntax::print::pprust::PrintState;\n+use syntax::print::pprust::{self, PrintState};\n use syntax::ptr::P;\n use syntax::symbol::keywords;\n use syntax::util::parser::{self, AssocOp, Fixity};\n@@ -18,7 +18,6 @@ use crate::hir::{GenericParam, GenericParamKind, GenericArg};\n use std::borrow::Cow;\n use std::cell::Cell;\n use std::io::{self, Write, Read};\n-use std::iter::Peekable;\n use std::vec;\n \n pub enum AnnNode<'a> {\n@@ -76,7 +75,6 @@ pub struct State<'a> {\n     pub s: pp::Printer<'a>,\n     cm: Option<&'a SourceMap>,\n     comments: Option<Vec<comments::Comment>>,\n-    literals: Peekable<vec::IntoIter<comments::Literal>>,\n     cur_cmnt: usize,\n     boxes: Vec<pp::Breaks>,\n     ann: &'a (dyn PpAnn + 'a),\n@@ -98,14 +96,6 @@ impl<'a> PrintState<'a> for State<'a> {\n     fn cur_cmnt(&mut self) -> &mut usize {\n         &mut self.cur_cmnt\n     }\n-\n-    fn cur_lit(&mut self) -> Option<&comments::Literal> {\n-        self.literals.peek()\n-    }\n-\n-    fn bump_lit(&mut self) -> Option<comments::Literal> {\n-        self.literals.next()\n-    }\n }\n \n #[allow(non_upper_case_globals)]\n@@ -116,18 +106,16 @@ pub const default_columns: usize = 78;\n \n \n /// Requires you to pass an input filename and reader so that\n-/// it can scan the input text for comments and literals to\n-/// copy forward.\n+/// it can scan the input text for comments to copy forward.\n pub fn print_crate<'a>(cm: &'a SourceMap,\n                        sess: &ParseSess,\n                        krate: &hir::Crate,\n                        filename: FileName,\n                        input: &mut dyn Read,\n                        out: Box<dyn Write + 'a>,\n-                       ann: &'a dyn PpAnn,\n-                       is_expanded: bool)\n+                       ann: &'a dyn PpAnn)\n                        -> io::Result<()> {\n-    let mut s = State::new_from_input(cm, sess, filename, input, out, ann, is_expanded);\n+    let mut s = State::new_from_input(cm, sess, filename, input, out, ann);\n \n     // When printing the AST, we sometimes need to inject `#[no_std]` here.\n     // Since you can't compile the HIR, it's not necessary.\n@@ -143,36 +131,21 @@ impl<'a> State<'a> {\n                           filename: FileName,\n                           input: &mut dyn Read,\n                           out: Box<dyn Write + 'a>,\n-                          ann: &'a dyn PpAnn,\n-                          is_expanded: bool)\n+                          ann: &'a dyn PpAnn)\n                           -> State<'a> {\n-        let (cmnts, lits) = comments::gather_comments_and_literals(sess, filename, input);\n-\n-        State::new(cm,\n-                   out,\n-                   ann,\n-                   Some(cmnts),\n-                   // If the code is post expansion, don't use the table of\n-                   // literals, since it doesn't correspond with the literals\n-                   // in the AST anymore.\n-                   if is_expanded {\n-                       None\n-                   } else {\n-                       Some(lits)\n-                   })\n+        let comments = comments::gather_comments(sess, filename, input);\n+        State::new(cm, out, ann, Some(comments))\n     }\n \n     pub fn new(cm: &'a SourceMap,\n                out: Box<dyn Write + 'a>,\n                ann: &'a dyn PpAnn,\n-               comments: Option<Vec<comments::Comment>>,\n-               literals: Option<Vec<comments::Literal>>)\n+               comments: Option<Vec<comments::Comment>>)\n                -> State<'a> {\n         State {\n             s: pp::mk_printer(out, default_columns),\n             cm: Some(cm),\n             comments,\n-            literals: literals.unwrap_or_default().into_iter().peekable(),\n             cur_cmnt: 0,\n             boxes: Vec::new(),\n             ann,\n@@ -189,7 +162,6 @@ pub fn to_string<F>(ann: &dyn PpAnn, f: F) -> String\n             s: pp::mk_printer(Box::new(&mut wr), default_columns),\n             cm: None,\n             comments: None,\n-            literals: vec![].into_iter().peekable(),\n             cur_cmnt: 0,\n             boxes: Vec::new(),\n             ann,\n@@ -1276,6 +1248,12 @@ impl<'a> State<'a> {\n         self.print_expr_maybe_paren(expr, parser::PREC_PREFIX)\n     }\n \n+    fn print_literal(&mut self, lit: &hir::Lit) -> io::Result<()> {\n+        self.maybe_print_comment(lit.span.lo())?;\n+        let (token, suffix) = lit.node.to_lit_token();\n+        self.writer().word(pprust::literal_to_string(token, suffix))\n+    }\n+\n     pub fn print_expr(&mut self, expr: &hir::Expr) -> io::Result<()> {\n         self.maybe_print_comment(expr.span.lo())?;\n         self.print_outer_attributes(&expr.attrs)?;"}, {"sha": "4e5718cc5ef2a275e5057e0c42097ba040b80548", "filename": "src/librustc/ich/impls_syntax.rs", "status": "modified", "additions": 24, "deletions": 17, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/1764b29725df66183059f406c8c65edf642bbd43/src%2Flibrustc%2Fich%2Fimpls_syntax.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1764b29725df66183059f406c8c65edf642bbd43/src%2Flibrustc%2Fich%2Fimpls_syntax.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fimpls_syntax.rs?ref=1764b29725df66183059f406c8c65edf642bbd43", "patch": "@@ -162,7 +162,13 @@ impl_stable_hash_for!(enum ::syntax::ast::LitIntType {\n     Unsuffixed\n });\n \n-impl_stable_hash_for_spanned!(::syntax::ast::LitKind);\n+impl_stable_hash_for!(struct ::syntax::ast::Lit {\n+    node,\n+    token,\n+    suffix,\n+    span\n+});\n+\n impl_stable_hash_for!(enum ::syntax::ast::LitKind {\n     Str(value, style),\n     Err(value),\n@@ -175,6 +181,8 @@ impl_stable_hash_for!(enum ::syntax::ast::LitKind {\n     Bool(value)\n });\n \n+impl_stable_hash_for_spanned!(::syntax::ast::LitKind);\n+\n impl_stable_hash_for!(enum ::syntax::ast::IntTy { Isize, I8, I16, I32, I64, I128 });\n impl_stable_hash_for!(enum ::syntax::ast::UintTy { Usize, U8, U16, U32, U64, U128 });\n impl_stable_hash_for!(enum ::syntax::ast::FloatTy { F32, F64 });\n@@ -280,6 +288,19 @@ for tokenstream::TokenStream {\n     }\n }\n \n+impl_stable_hash_for!(enum token::Lit {\n+    Bool(val),\n+    Byte(val),\n+    Char(val),\n+    Err(val),\n+    Integer(val),\n+    Float(val),\n+    Str_(val),\n+    ByteStr(val),\n+    StrRaw(val, n),\n+    ByteStrRaw(val, n)\n+});\n+\n fn hash_token<'a, 'gcx, W: StableHasherResult>(\n     token: &token::Token,\n     hcx: &mut StableHashingContext<'a>,\n@@ -327,22 +348,8 @@ fn hash_token<'a, 'gcx, W: StableHasherResult>(\n         token::Token::CloseDelim(delim_token) => {\n             std_hash::Hash::hash(&delim_token, hasher);\n         }\n-        token::Token::Literal(ref lit, ref opt_name) => {\n-            mem::discriminant(lit).hash_stable(hcx, hasher);\n-            match *lit {\n-                token::Lit::Byte(val) |\n-                token::Lit::Char(val) |\n-                token::Lit::Err(val) |\n-                token::Lit::Integer(val) |\n-                token::Lit::Float(val) |\n-                token::Lit::Str_(val) |\n-                token::Lit::ByteStr(val) => val.hash_stable(hcx, hasher),\n-                token::Lit::StrRaw(val, n) |\n-                token::Lit::ByteStrRaw(val, n) => {\n-                    val.hash_stable(hcx, hasher);\n-                    n.hash_stable(hcx, hasher);\n-                }\n-            };\n+        token::Token::Literal(lit, opt_name) => {\n+            lit.hash_stable(hcx, hasher);\n             opt_name.hash_stable(hcx, hasher);\n         }\n "}, {"sha": "c74ed5ec30c3cade8d6b7b91cbf1dedc92a4af44", "filename": "src/librustc_driver/pretty.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/1764b29725df66183059f406c8c65edf642bbd43/src%2Flibrustc_driver%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1764b29725df66183059f406c8c65edf642bbd43/src%2Flibrustc_driver%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Fpretty.rs?ref=1764b29725df66183059f406c8c65edf642bbd43", "patch": "@@ -805,8 +805,7 @@ pub fn print_after_hir_lowering<'tcx>(\n                                             src_name,\n                                             &mut rdr,\n                                             box out,\n-                                            annotation.pp_ann(),\n-                                            true)\n+                                            annotation.pp_ann())\n                 })\n             }\n \n@@ -829,8 +828,7 @@ pub fn print_after_hir_lowering<'tcx>(\n                                                                          src_name,\n                                                                          &mut rdr,\n                                                                          box out,\n-                                                                         annotation.pp_ann(),\n-                                                                         true);\n+                                                                         annotation.pp_ann());\n                     for node_id in uii.all_matching_node_ids(hir_map) {\n                         let node = hir_map.get(node_id);\n                         pp_state.print_node(node)?;"}, {"sha": "38b6e2c197939769be2d3f3238bf2f9672b7df7c", "filename": "src/librustc_lint/types.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/1764b29725df66183059f406c8c65edf642bbd43/src%2Flibrustc_lint%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1764b29725df66183059f406c8c65edf642bbd43/src%2Flibrustc_lint%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Ftypes.rs?ref=1764b29725df66183059f406c8c65edf642bbd43", "patch": "@@ -62,7 +62,7 @@ impl TypeLimits {\n /// Returns `true` iff the lint was overridden.\n fn lint_overflowing_range_endpoint<'a, 'tcx>(\n     cx: &LateContext<'a, 'tcx>,\n-    lit: &ast::Lit,\n+    lit: &hir::Lit,\n     lit_val: u128,\n     max: u128,\n     expr: &'tcx hir::Expr,\n@@ -132,7 +132,7 @@ fn uint_ty_range(uint_ty: ast::UintTy) -> (u128, u128) {\n     }\n }\n \n-fn get_bin_hex_repr(cx: &LateContext<'_, '_>, lit: &ast::Lit) -> Option<String> {\n+fn get_bin_hex_repr(cx: &LateContext<'_, '_>, lit: &hir::Lit) -> Option<String> {\n     let src = cx.sess().source_map().span_to_snippet(lit.span).ok()?;\n     let firstch = src.chars().next()?;\n \n@@ -249,7 +249,7 @@ fn lint_int_literal<'a, 'tcx>(\n     cx: &LateContext<'a, 'tcx>,\n     type_limits: &TypeLimits,\n     e: &'tcx hir::Expr,\n-    lit: &ast::Lit,\n+    lit: &hir::Lit,\n     t: ast::IntTy,\n     v: u128,\n ) {\n@@ -301,7 +301,7 @@ fn lint_int_literal<'a, 'tcx>(\n fn lint_uint_literal<'a, 'tcx>(\n     cx: &LateContext<'a, 'tcx>,\n     e: &'tcx hir::Expr,\n-    lit: &ast::Lit,\n+    lit: &hir::Lit,\n     t: ast::UintTy,\n ) {\n     let uint_type = if let ast::UintTy::Usize = t {\n@@ -363,7 +363,7 @@ fn lint_literal<'a, 'tcx>(\n     cx: &LateContext<'a, 'tcx>,\n     type_limits: &TypeLimits,\n     e: &'tcx hir::Expr,\n-    lit: &ast::Lit,\n+    lit: &hir::Lit,\n ) {\n     match cx.tables.node_type(e.hir_id).sty {\n         ty::Int(t) => {"}, {"sha": "dc73ada1506c89be1bb8a550229eb1e0e45f798b", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1764b29725df66183059f406c8c65edf642bbd43/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1764b29725df66183059f406c8c65edf642bbd43/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=1764b29725df66183059f406c8c65edf642bbd43", "patch": "@@ -3083,7 +3083,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n \n     // AST fragment checking\n     fn check_lit(&self,\n-                 lit: &ast::Lit,\n+                 lit: &hir::Lit,\n                  expected: Expectation<'tcx>)\n                  -> Ty<'tcx>\n     {"}, {"sha": "b96ac19c1ea61a4dea12bcadd3b9bc02884873bf", "filename": "src/librustdoc/clean/cfg.rs", "status": "modified", "additions": 13, "deletions": 15, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/1764b29725df66183059f406c8c65edf642bbd43/src%2Flibrustdoc%2Fclean%2Fcfg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1764b29725df66183059f406c8c65edf642bbd43/src%2Flibrustdoc%2Fclean%2Fcfg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fcfg.rs?ref=1764b29725df66183059f406c8c65edf642bbd43", "patch": "@@ -414,10 +414,11 @@ impl<'a> fmt::Display for Html<'a> {\n mod test {\n     use super::Cfg;\n \n-    use syntax::symbol::Symbol;\n+    use syntax_pos::DUMMY_SP;\n     use syntax::ast::*;\n+    use syntax::attr;\n     use syntax::source_map::dummy_spanned;\n-    use syntax_pos::DUMMY_SP;\n+    use syntax::symbol::Symbol;\n     use syntax::with_globals;\n \n     fn word_cfg(s: &str) -> Cfg {\n@@ -592,14 +593,10 @@ mod test {\n             let mi = dummy_meta_item_word(\"all\");\n             assert_eq!(Cfg::parse(&mi), Ok(word_cfg(\"all\")));\n \n-            let mi = MetaItem {\n-                path: Path::from_ident(Ident::from_str(\"all\")),\n-                node: MetaItemKind::NameValue(dummy_spanned(LitKind::Str(\n-                    Symbol::intern(\"done\"),\n-                    StrStyle::Cooked,\n-                ))),\n-                span: DUMMY_SP,\n-            };\n+            let mi = attr::mk_name_value_item_str(\n+                Ident::from_str(\"all\"),\n+                dummy_spanned(Symbol::intern(\"done\"))\n+            );\n             assert_eq!(Cfg::parse(&mi), Ok(name_value_cfg(\"all\", \"done\")));\n \n             let mi = dummy_meta_item_list!(all, [a, b]);\n@@ -627,11 +624,12 @@ mod test {\n     #[test]\n     fn test_parse_err() {\n         with_globals(|| {\n-            let mi = MetaItem {\n-                path: Path::from_ident(Ident::from_str(\"foo\")),\n-                node: MetaItemKind::NameValue(dummy_spanned(LitKind::Bool(false))),\n-                span: DUMMY_SP,\n-            };\n+            let mi = attr::mk_name_value_item(\n+                DUMMY_SP,\n+                Ident::from_str(\"foo\"),\n+                LitKind::Bool(false),\n+                DUMMY_SP,\n+            );\n             assert!(Cfg::parse(&mi).is_err());\n \n             let mi = dummy_meta_item_list!(not, [a, b]);"}, {"sha": "5bb06516ac49e81ebaf917d4ea9b9dcb8fd6a407", "filename": "src/librustdoc/html/highlight.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1764b29725df66183059f406c8c65edf642bbd43/src%2Flibrustdoc%2Fhtml%2Fhighlight.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1764b29725df66183059f406c8c65edf642bbd43/src%2Flibrustdoc%2Fhtml%2Fhighlight.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fhighlight.rs?ref=1764b29725df66183059f406c8c65edf642bbd43", "patch": "@@ -318,6 +318,8 @@ impl<'a> Classifier<'a> {\n \n                     // Number literals.\n                     token::Integer(..) | token::Float(..) => Class::Number,\n+\n+                    token::Bool(..) => panic!(\"literal token contains `Lit::Bool`\"),\n                 }\n             }\n "}, {"sha": "aa176c892588388eab36d82ea0f931af791f137d", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 14, "deletions": 2, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/1764b29725df66183059f406c8c65edf642bbd43/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1764b29725df66183059f406c8c65edf642bbd43/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=1764b29725df66183059f406c8c65edf642bbd43", "patch": "@@ -6,6 +6,7 @@ pub use crate::symbol::{Ident, Symbol as Name};\n pub use crate::util::parser::ExprPrecedence;\n \n use crate::ext::hygiene::{Mark, SyntaxContext};\n+use crate::parse::token;\n use crate::print::pprust;\n use crate::ptr::P;\n use crate::source_map::{dummy_spanned, respan, Spanned};\n@@ -1350,8 +1351,19 @@ pub enum StrStyle {\n     Raw(u16),\n }\n \n-/// A literal.\n-pub type Lit = Spanned<LitKind>;\n+/// An AST literal.\n+#[derive(Clone, RustcEncodable, RustcDecodable, Debug)]\n+pub struct Lit {\n+    /// The original literal token as written in source code.\n+    pub token: token::Lit,\n+    /// The original literal suffix as written in source code.\n+    pub suffix: Option<Symbol>,\n+    /// The \"semantic\" representation of the literal lowered from the original tokens.\n+    /// Strings are unescaped, hexadecimal forms are eliminated, etc.\n+    /// FIXME: Remove this and only create the semantic representation during lowering to HIR.\n+    pub node: LitKind,\n+    pub span: Span,\n+}\n \n #[derive(Clone, RustcEncodable, RustcDecodable, Debug, Copy, Hash, PartialEq)]\n pub enum LitIntType {"}, {"sha": "07e4bbf78ffdf4666dbd171e10665c2768c4c011", "filename": "src/libsyntax/attr/mod.rs", "status": "modified", "additions": 12, "deletions": 86, "changes": 98, "blob_url": "https://github.com/rust-lang/rust/blob/1764b29725df66183059f406c8c65edf642bbd43/src%2Flibsyntax%2Fattr%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1764b29725df66183059f406c8c65edf642bbd43/src%2Flibsyntax%2Fattr%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fattr%2Fmod.rs?ref=1764b29725df66183059f406c8c65edf642bbd43", "patch": "@@ -14,9 +14,9 @@ pub use StabilityLevel::*;\n use crate::ast;\n use crate::ast::{AttrId, Attribute, AttrStyle, Name, Ident, Path, PathSegment};\n use crate::ast::{MetaItem, MetaItemKind, NestedMetaItem};\n-use crate::ast::{Lit, LitKind, Expr, ExprKind, Item, Local, Stmt, StmtKind, GenericParam};\n+use crate::ast::{Lit, LitKind, Expr, Item, Local, Stmt, StmtKind, GenericParam};\n use crate::mut_visit::visit_clobber;\n-use crate::source_map::{BytePos, Spanned, respan, dummy_spanned};\n+use crate::source_map::{BytePos, Spanned, dummy_spanned};\n use crate::parse::lexer::comments::{doc_comment_style, strip_doc_comment_decoration};\n use crate::parse::parser::Parser;\n use crate::parse::{self, ParseSess, PResult};\n@@ -350,12 +350,13 @@ impl Attribute {\n /* Constructors */\n \n pub fn mk_name_value_item_str(ident: Ident, value: Spanned<Symbol>) -> MetaItem {\n-    let value = respan(value.span, LitKind::Str(value.node, ast::StrStyle::Cooked));\n-    mk_name_value_item(ident.span.to(value.span), ident, value)\n+    let lit_kind = LitKind::Str(value.node, ast::StrStyle::Cooked);\n+    mk_name_value_item(ident.span.to(value.span), ident, lit_kind, value.span)\n }\n \n-pub fn mk_name_value_item(span: Span, ident: Ident, value: ast::Lit) -> MetaItem {\n-    MetaItem { path: Path::from_ident(ident), span, node: MetaItemKind::NameValue(value) }\n+pub fn mk_name_value_item(span: Span, ident: Ident, lit_kind: LitKind, lit_span: Span) -> MetaItem {\n+    let lit = Lit::from_lit_kind(lit_kind, lit_span);\n+    MetaItem { path: Path::from_ident(ident), span, node: MetaItemKind::NameValue(lit) }\n }\n \n pub fn mk_list_item(span: Span, ident: Ident, items: Vec<NestedMetaItem>) -> MetaItem {\n@@ -417,7 +418,8 @@ pub fn mk_spanned_attr_outer(sp: Span, id: AttrId, item: MetaItem) -> Attribute\n \n pub fn mk_sugared_doc_attr(id: AttrId, text: Symbol, span: Span) -> Attribute {\n     let style = doc_comment_style(&text.as_str());\n-    let lit = respan(span, LitKind::Str(text, ast::StrStyle::Cooked));\n+    let lit_kind = LitKind::Str(text, ast::StrStyle::Cooked);\n+    let lit = Lit::from_lit_kind(lit_kind, span);\n     Attribute {\n         id,\n         style,\n@@ -561,8 +563,7 @@ impl MetaItemKind {\n             Some(TokenTree::Token(_, token::Eq)) => {\n                 tokens.next();\n                 return if let Some(TokenTree::Token(span, token)) = tokens.next() {\n-                    LitKind::from_token(token)\n-                        .map(|lit| MetaItemKind::NameValue(Spanned { node: lit, span: span }))\n+                    Lit::from_token(&token, span, None).map(MetaItemKind::NameValue)\n                 } else {\n                     None\n                 };\n@@ -607,91 +608,16 @@ impl NestedMetaItem {\n         where I: Iterator<Item = TokenTree>,\n     {\n         if let Some(TokenTree::Token(span, token)) = tokens.peek().cloned() {\n-            if let Some(node) = LitKind::from_token(token) {\n+            if let Some(lit) = Lit::from_token(&token, span, None) {\n                 tokens.next();\n-                return Some(NestedMetaItem::Literal(respan(span, node)));\n+                return Some(NestedMetaItem::Literal(lit));\n             }\n         }\n \n         MetaItem::from_tokens(tokens).map(NestedMetaItem::MetaItem)\n     }\n }\n \n-impl Lit {\n-    crate fn tokens(&self) -> TokenStream {\n-        TokenTree::Token(self.span, self.node.token()).into()\n-    }\n-}\n-\n-impl LitKind {\n-    fn token(&self) -> Token {\n-        use std::ascii;\n-\n-        match *self {\n-            LitKind::Str(string, ast::StrStyle::Cooked) => {\n-                let escaped = string.as_str().escape_default().to_string();\n-                Token::Literal(token::Lit::Str_(Symbol::intern(&escaped)), None)\n-            }\n-            LitKind::Str(string, ast::StrStyle::Raw(n)) => {\n-                Token::Literal(token::Lit::StrRaw(string, n), None)\n-            }\n-            LitKind::ByteStr(ref bytes) => {\n-                let string = bytes.iter().cloned().flat_map(ascii::escape_default)\n-                    .map(Into::<char>::into).collect::<String>();\n-                Token::Literal(token::Lit::ByteStr(Symbol::intern(&string)), None)\n-            }\n-            LitKind::Byte(byte) => {\n-                let string: String = ascii::escape_default(byte).map(Into::<char>::into).collect();\n-                Token::Literal(token::Lit::Byte(Symbol::intern(&string)), None)\n-            }\n-            LitKind::Char(ch) => {\n-                let string: String = ch.escape_default().map(Into::<char>::into).collect();\n-                Token::Literal(token::Lit::Char(Symbol::intern(&string)), None)\n-            }\n-            LitKind::Int(n, ty) => {\n-                let suffix = match ty {\n-                    ast::LitIntType::Unsigned(ty) => Some(Symbol::intern(ty.ty_to_string())),\n-                    ast::LitIntType::Signed(ty) => Some(Symbol::intern(ty.ty_to_string())),\n-                    ast::LitIntType::Unsuffixed => None,\n-                };\n-                Token::Literal(token::Lit::Integer(Symbol::intern(&n.to_string())), suffix)\n-            }\n-            LitKind::Float(symbol, ty) => {\n-                Token::Literal(token::Lit::Float(symbol), Some(Symbol::intern(ty.ty_to_string())))\n-            }\n-            LitKind::FloatUnsuffixed(symbol) => Token::Literal(token::Lit::Float(symbol), None),\n-            LitKind::Bool(value) => Token::Ident(Ident::with_empty_ctxt(Symbol::intern(if value {\n-                \"true\"\n-            } else {\n-                \"false\"\n-            })), false),\n-            LitKind::Err(val) => Token::Literal(token::Lit::Err(val), None),\n-        }\n-    }\n-\n-    fn from_token(token: Token) -> Option<LitKind> {\n-        match token {\n-            Token::Ident(ident, false) if ident.name == \"true\" => Some(LitKind::Bool(true)),\n-            Token::Ident(ident, false) if ident.name == \"false\" => Some(LitKind::Bool(false)),\n-            Token::Interpolated(nt) => match *nt {\n-                token::NtExpr(ref v) | token::NtLiteral(ref v) => match v.node {\n-                    ExprKind::Lit(ref lit) => Some(lit.node.clone()),\n-                    _ => None,\n-                },\n-                _ => None,\n-            },\n-            Token::Literal(lit, suf) => {\n-                let (suffix_illegal, result) = parse::lit_token(lit, suf, None);\n-                if suffix_illegal && suf.is_some() {\n-                    return None;\n-                }\n-                result\n-            }\n-            _ => None,\n-        }\n-    }\n-}\n-\n pub trait HasAttrs: Sized {\n     fn attrs(&self) -> &[ast::Attribute];\n     fn visit_attrs<F: FnOnce(&mut Vec<ast::Attribute>)>(&mut self, f: F);"}, {"sha": "d24106f697e19f1470fd4a6adecfad08c73191b6", "filename": "src/libsyntax/ext/build.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/1764b29725df66183059f406c8c65edf642bbd43/src%2Flibsyntax%2Fext%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1764b29725df66183059f406c8c65edf642bbd43/src%2Flibsyntax%2Fext%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbuild.rs?ref=1764b29725df66183059f406c8c65edf642bbd43", "patch": "@@ -697,8 +697,9 @@ impl<'a> AstBuilder for ExtCtxt<'a> {\n         self.expr_struct(span, self.path_ident(span, id), fields)\n     }\n \n-    fn expr_lit(&self, sp: Span, lit: ast::LitKind) -> P<ast::Expr> {\n-        self.expr(sp, ast::ExprKind::Lit(respan(sp, lit)))\n+    fn expr_lit(&self, span: Span, lit_kind: ast::LitKind) -> P<ast::Expr> {\n+        let lit = ast::Lit::from_lit_kind(lit_kind, span);\n+        self.expr(span, ast::ExprKind::Lit(lit))\n     }\n     fn expr_usize(&self, span: Span, i: usize) -> P<ast::Expr> {\n         self.expr_lit(span, ast::LitKind::Int(i as u128,\n@@ -1164,10 +1165,10 @@ impl<'a> AstBuilder for ExtCtxt<'a> {\n         attr::mk_list_item(sp, Ident::with_empty_ctxt(name).with_span_pos(sp), mis)\n     }\n \n-    fn meta_name_value(&self, sp: Span, name: ast::Name, value: ast::LitKind)\n+    fn meta_name_value(&self, span: Span, name: ast::Name, lit_kind: ast::LitKind)\n                        -> ast::MetaItem {\n-        attr::mk_name_value_item(sp, Ident::with_empty_ctxt(name).with_span_pos(sp),\n-                                 respan(sp, value))\n+        attr::mk_name_value_item(span, Ident::with_empty_ctxt(name).with_span_pos(span),\n+                                 lit_kind, span)\n     }\n \n     fn item_use(&self, sp: Span,"}, {"sha": "dfd6f451c28d7779a3f2c50af7f3a8b772aa1a20", "filename": "src/libsyntax/parse/classify.rs", "status": "modified", "additions": 0, "deletions": 13, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/1764b29725df66183059f406c8c65edf642bbd43/src%2Flibsyntax%2Fparse%2Fclassify.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1764b29725df66183059f406c8c65edf642bbd43/src%2Flibsyntax%2Fparse%2Fclassify.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fclassify.rs?ref=1764b29725df66183059f406c8c65edf642bbd43", "patch": "@@ -25,16 +25,3 @@ pub fn expr_requires_semi_to_be_stmt(e: &ast::Expr) -> bool {\n         _ => true,\n     }\n }\n-\n-/// this statement requires a semicolon after it.\n-/// note that in one case (`stmt_semi`), we've already\n-/// seen the semicolon, and thus don't need another.\n-pub fn stmt_ends_with_semi(stmt: &ast::StmtKind) -> bool {\n-    match *stmt {\n-        ast::StmtKind::Local(_) => true,\n-        ast::StmtKind::Expr(ref e) => expr_requires_semi_to_be_stmt(e),\n-        ast::StmtKind::Item(_) |\n-        ast::StmtKind::Semi(..) |\n-        ast::StmtKind::Mac(..) => false,\n-    }\n-}"}, {"sha": "97d3fc002e9b0de49c84623274564834c2e54dbe", "filename": "src/libsyntax/parse/lexer/comments.rs", "status": "modified", "additions": 3, "deletions": 26, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/1764b29725df66183059f406c8c65edf642bbd43/src%2Flibsyntax%2Fparse%2Flexer%2Fcomments.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1764b29725df66183059f406c8c65edf642bbd43/src%2Flibsyntax%2Fparse%2Flexer%2Fcomments.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Flexer%2Fcomments.rs?ref=1764b29725df66183059f406c8c65edf642bbd43", "patch": "@@ -3,8 +3,7 @@ pub use CommentStyle::*;\n use crate::ast;\n use crate::source_map::SourceMap;\n use crate::parse::lexer::{is_block_doc_comment, is_pattern_whitespace};\n-use crate::parse::lexer::{self, ParseSess, StringReader, TokenAndSpan};\n-use crate::print::pprust;\n+use crate::parse::lexer::{self, ParseSess, StringReader};\n \n use syntax_pos::{BytePos, CharPos, Pos, FileName};\n use log::debug;\n@@ -339,16 +338,9 @@ fn consume_comment(rdr: &mut StringReader<'_>,\n     debug!(\"<<< consume comment\");\n }\n \n-#[derive(Clone)]\n-pub struct Literal {\n-    pub lit: String,\n-    pub pos: BytePos,\n-}\n-\n // it appears this function is called only from pprust... that's\n // probably not a good thing.\n-pub fn gather_comments_and_literals(sess: &ParseSess, path: FileName, srdr: &mut dyn Read)\n-    -> (Vec<Comment>, Vec<Literal>)\n+pub fn gather_comments(sess: &ParseSess, path: FileName, srdr: &mut dyn Read) -> Vec<Comment>\n {\n     let mut src = String::new();\n     srdr.read_to_string(&mut src).unwrap();\n@@ -357,7 +349,6 @@ pub fn gather_comments_and_literals(sess: &ParseSess, path: FileName, srdr: &mut\n     let mut rdr = lexer::StringReader::new_raw(sess, source_file, None);\n \n     let mut comments: Vec<Comment> = Vec::new();\n-    let mut literals: Vec<Literal> = Vec::new();\n     let mut code_to_the_left = false; // Only code\n     let mut anything_to_the_left = false; // Code or comments\n \n@@ -382,26 +373,12 @@ pub fn gather_comments_and_literals(sess: &ParseSess, path: FileName, srdr: &mut\n             }\n         }\n \n-        let bstart = rdr.pos;\n         rdr.next_token();\n-        // discard, and look ahead; we're working with internal state\n-        let TokenAndSpan { tok, sp } = rdr.peek();\n-        if tok.is_lit() {\n-            rdr.with_str_from(bstart, |s| {\n-                debug!(\"tok lit: {}\", s);\n-                literals.push(Literal {\n-                    lit: s.to_string(),\n-                    pos: sp.lo(),\n-                });\n-            })\n-        } else {\n-            debug!(\"tok: {}\", pprust::token_to_string(&tok));\n-        }\n         code_to_the_left = true;\n         anything_to_the_left = true;\n     }\n \n-    (comments, literals)\n+    comments\n }\n \n #[cfg(test)]"}, {"sha": "e76605cde32ab4376e5f4e5f50b127d07d8b877c", "filename": "src/libsyntax/parse/lexer/mod.rs", "status": "modified", "additions": 6, "deletions": 13, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/1764b29725df66183059f406c8c65edf642bbd43/src%2Flibsyntax%2Fparse%2Flexer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1764b29725df66183059f406c8c65edf642bbd43/src%2Flibsyntax%2Fparse%2Flexer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Flexer%2Fmod.rs?ref=1764b29725df66183059f406c8c65edf642bbd43", "patch": "@@ -262,18 +262,6 @@ impl<'a> StringReader<'a> {\n         }\n     }\n \n-    pub fn new(sess: &'a ParseSess,\n-               source_file: Lrc<syntax_pos::SourceFile>,\n-               override_span: Option<Span>) -> Self {\n-        let mut sr = StringReader::new_raw(sess, source_file, override_span);\n-        if sr.advance_token().is_err() {\n-            sr.emit_fatal_errors();\n-            FatalError.raise();\n-        }\n-\n-        sr\n-    }\n-\n     pub fn new_or_buffered_errs(sess: &'a ParseSess,\n                                 source_file: Lrc<syntax_pos::SourceFile>,\n                                 override_span: Option<Span>) -> Result<Self, Vec<Diagnostic>> {\n@@ -1627,7 +1615,12 @@ mod tests {\n                  teststr: String)\n                  -> StringReader<'a> {\n         let sf = sm.new_source_file(PathBuf::from(teststr.clone()).into(), teststr);\n-        StringReader::new(sess, sf, None)\n+        let mut sr = StringReader::new_raw(sess, sf, None);\n+        if sr.advance_token().is_err() {\n+            sr.emit_fatal_errors();\n+            FatalError.raise();\n+        }\n+        sr\n     }\n \n     #[test]"}, {"sha": "53195421ddceeb90f3cb4b25a14a0fab54aa9683", "filename": "src/libsyntax/parse/literal.rs", "status": "added", "additions": 487, "deletions": 0, "changes": 487, "blob_url": "https://github.com/rust-lang/rust/blob/1764b29725df66183059f406c8c65edf642bbd43/src%2Flibsyntax%2Fparse%2Fliteral.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1764b29725df66183059f406c8c65edf642bbd43/src%2Flibsyntax%2Fparse%2Fliteral.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fliteral.rs?ref=1764b29725df66183059f406c8c65edf642bbd43", "patch": "@@ -0,0 +1,487 @@\n+//! Code related to parsing literals.\n+\n+use crate::ast::{self, Ident, Lit, LitKind};\n+use crate::parse::parser::Parser;\n+use crate::parse::PResult;\n+use crate::parse::token::{self, Token};\n+use crate::parse::unescape::{unescape_str, unescape_char, unescape_byte_str, unescape_byte};\n+use crate::print::pprust;\n+use crate::symbol::{keywords, Symbol};\n+use crate::tokenstream::{TokenStream, TokenTree};\n+\n+use errors::{Applicability, Handler};\n+use log::debug;\n+use rustc_data_structures::sync::Lrc;\n+use syntax_pos::Span;\n+\n+use std::ascii;\n+\n+macro_rules! err {\n+    ($opt_diag:expr, |$span:ident, $diag:ident| $($body:tt)*) => {\n+        match $opt_diag {\n+            Some(($span, $diag)) => { $($body)* }\n+            None => return None,\n+        }\n+    }\n+}\n+\n+impl LitKind {\n+    /// Converts literal token with a suffix into a semantic literal.\n+    /// Works speculatively and may return `None` if diagnostic handler is not passed.\n+    /// If diagnostic handler is passed, always returns `Some`,\n+    /// possibly after reporting non-fatal errors and recovery.\n+    fn from_lit_token(\n+        lit: token::Lit,\n+        suf: Option<Symbol>,\n+        diag: Option<(Span, &Handler)>\n+    ) -> Option<LitKind> {\n+        if suf.is_some() && !lit.may_have_suffix() {\n+            err!(diag, |span, diag| {\n+                expect_no_suffix(span, diag, &format!(\"a {}\", lit.literal_name()), suf)\n+            });\n+        }\n+\n+        Some(match lit {\n+            token::Bool(i) => {\n+                assert!(i == keywords::True.name() || i == keywords::False.name());\n+                LitKind::Bool(i == keywords::True.name())\n+            }\n+            token::Byte(i) => {\n+                match unescape_byte(&i.as_str()) {\n+                    Ok(c) => LitKind::Byte(c),\n+                    Err(_) => LitKind::Err(i),\n+                }\n+            },\n+            token::Char(i) => {\n+                match unescape_char(&i.as_str()) {\n+                    Ok(c) => LitKind::Char(c),\n+                    Err(_) => LitKind::Err(i),\n+                }\n+            },\n+            token::Err(i) => LitKind::Err(i),\n+\n+            // There are some valid suffixes for integer and float literals,\n+            // so all the handling is done internally.\n+            token::Integer(s) => return integer_lit(&s.as_str(), suf, diag),\n+            token::Float(s) => return float_lit(&s.as_str(), suf, diag),\n+\n+            token::Str_(mut sym) => {\n+                // If there are no characters requiring special treatment we can\n+                // reuse the symbol from the Token. Otherwise, we must generate a\n+                // new symbol because the string in the LitKind is different to the\n+                // string in the Token.\n+                let mut has_error = false;\n+                let s = &sym.as_str();\n+                if s.as_bytes().iter().any(|&c| c == b'\\\\' || c == b'\\r') {\n+                    let mut buf = String::with_capacity(s.len());\n+                    unescape_str(s, &mut |_, unescaped_char| {\n+                        match unescaped_char {\n+                            Ok(c) => buf.push(c),\n+                            Err(_) => has_error = true,\n+                        }\n+                    });\n+                    if has_error {\n+                        return Some(LitKind::Err(sym));\n+                    }\n+                    sym = Symbol::intern(&buf)\n+                }\n+\n+                LitKind::Str(sym, ast::StrStyle::Cooked)\n+            }\n+            token::StrRaw(mut sym, n) => {\n+                // Ditto.\n+                let s = &sym.as_str();\n+                if s.contains('\\r') {\n+                    sym = Symbol::intern(&raw_str_lit(s));\n+                }\n+                LitKind::Str(sym, ast::StrStyle::Raw(n))\n+            }\n+            token::ByteStr(i) => {\n+                let s = &i.as_str();\n+                let mut buf = Vec::with_capacity(s.len());\n+                let mut has_error = false;\n+                unescape_byte_str(s, &mut |_, unescaped_byte| {\n+                    match unescaped_byte {\n+                        Ok(c) => buf.push(c),\n+                        Err(_) => has_error = true,\n+                    }\n+                });\n+                if has_error {\n+                    return Some(LitKind::Err(i));\n+                }\n+                buf.shrink_to_fit();\n+                LitKind::ByteStr(Lrc::new(buf))\n+            }\n+            token::ByteStrRaw(i, _) => {\n+                LitKind::ByteStr(Lrc::new(i.to_string().into_bytes()))\n+            }\n+        })\n+    }\n+\n+    /// Attempts to recover a token from semantic literal.\n+    /// This function is used when the original token doesn't exist (e.g. the literal is created\n+    /// by an AST-based macro) or unavailable (e.g. from HIR pretty-printing).\n+    pub fn to_lit_token(&self) -> (token::Lit, Option<Symbol>) {\n+        match *self {\n+            LitKind::Str(string, ast::StrStyle::Cooked) => {\n+                let escaped = string.as_str().escape_default().to_string();\n+                (token::Lit::Str_(Symbol::intern(&escaped)), None)\n+            }\n+            LitKind::Str(string, ast::StrStyle::Raw(n)) => {\n+                (token::Lit::StrRaw(string, n), None)\n+            }\n+            LitKind::ByteStr(ref bytes) => {\n+                let string = bytes.iter().cloned().flat_map(ascii::escape_default)\n+                    .map(Into::<char>::into).collect::<String>();\n+                (token::Lit::ByteStr(Symbol::intern(&string)), None)\n+            }\n+            LitKind::Byte(byte) => {\n+                let string: String = ascii::escape_default(byte).map(Into::<char>::into).collect();\n+                (token::Lit::Byte(Symbol::intern(&string)), None)\n+            }\n+            LitKind::Char(ch) => {\n+                let string: String = ch.escape_default().map(Into::<char>::into).collect();\n+                (token::Lit::Char(Symbol::intern(&string)), None)\n+            }\n+            LitKind::Int(n, ty) => {\n+                let suffix = match ty {\n+                    ast::LitIntType::Unsigned(ty) => Some(Symbol::intern(ty.ty_to_string())),\n+                    ast::LitIntType::Signed(ty) => Some(Symbol::intern(ty.ty_to_string())),\n+                    ast::LitIntType::Unsuffixed => None,\n+                };\n+                (token::Lit::Integer(Symbol::intern(&n.to_string())), suffix)\n+            }\n+            LitKind::Float(symbol, ty) => {\n+                (token::Lit::Float(symbol), Some(Symbol::intern(ty.ty_to_string())))\n+            }\n+            LitKind::FloatUnsuffixed(symbol) => (token::Lit::Float(symbol), None),\n+            LitKind::Bool(value) => {\n+                let kw = if value { keywords::True } else { keywords::False };\n+                (token::Lit::Bool(kw.name()), None)\n+            }\n+            LitKind::Err(val) => (token::Lit::Err(val), None),\n+        }\n+    }\n+}\n+\n+impl Lit {\n+    /// Converts literal token with a suffix into an AST literal.\n+    /// Works speculatively and may return `None` if diagnostic handler is not passed.\n+    /// If diagnostic handler is passed, may return `Some`,\n+    /// possibly after reporting non-fatal errors and recovery, or `None` for irrecoverable errors.\n+    crate fn from_token(\n+        token: &token::Token,\n+        span: Span,\n+        diag: Option<(Span, &Handler)>,\n+    ) -> Option<Lit> {\n+        let (token, suffix) = match *token {\n+            token::Ident(ident, false) if ident.name == keywords::True.name() ||\n+                                          ident.name == keywords::False.name() =>\n+                (token::Bool(ident.name), None),\n+            token::Literal(token, suffix) =>\n+                (token, suffix),\n+            token::Interpolated(ref nt) => {\n+                if let token::NtExpr(expr) | token::NtLiteral(expr) = &**nt {\n+                    if let ast::ExprKind::Lit(lit) = &expr.node {\n+                        return Some(lit.clone());\n+                    }\n+                }\n+                return None;\n+            }\n+            _ => return None,\n+        };\n+\n+        let node = LitKind::from_lit_token(token, suffix, diag)?;\n+        Some(Lit { node, token, suffix, span })\n+    }\n+\n+    /// Attempts to recover an AST literal from semantic literal.\n+    /// This function is used when the original token doesn't exist (e.g. the literal is created\n+    /// by an AST-based macro) or unavailable (e.g. from HIR pretty-printing).\n+    pub fn from_lit_kind(node: LitKind, span: Span) -> Lit {\n+        let (token, suffix) = node.to_lit_token();\n+        Lit { node, token, suffix, span }\n+    }\n+\n+    /// Losslessly convert an AST literal into a token stream.\n+    crate fn tokens(&self) -> TokenStream {\n+        let token = match self.token {\n+            token::Bool(symbol) => Token::Ident(Ident::with_empty_ctxt(symbol), false),\n+            token => Token::Literal(token, self.suffix),\n+        };\n+        TokenTree::Token(self.span, token).into()\n+    }\n+}\n+\n+impl<'a> Parser<'a> {\n+    /// Matches `lit = true | false | token_lit`.\n+    crate fn parse_lit(&mut self) -> PResult<'a, Lit> {\n+        let diag = Some((self.span, &self.sess.span_diagnostic));\n+        if let Some(lit) = Lit::from_token(&self.token, self.span, diag) {\n+            self.bump();\n+            return Ok(lit);\n+        } else if self.token == token::Dot {\n+            // Recover `.4` as `0.4`.\n+            let recovered = self.look_ahead(1, |t| {\n+                if let token::Literal(token::Integer(val), suf) = *t {\n+                    let next_span = self.look_ahead_span(1);\n+                    if self.span.hi() == next_span.lo() {\n+                        let sym = String::from(\"0.\") + &val.as_str();\n+                        let token = token::Literal(token::Float(Symbol::intern(&sym)), suf);\n+                        return Some((token, self.span.to(next_span)));\n+                    }\n+                }\n+                None\n+            });\n+            if let Some((token, span)) = recovered {\n+                self.diagnostic()\n+                    .struct_span_err(span, \"float literals must have an integer part\")\n+                    .span_suggestion(\n+                        span,\n+                        \"must have an integer part\",\n+                        pprust::token_to_string(&token),\n+                        Applicability::MachineApplicable,\n+                    )\n+                    .emit();\n+                let diag = Some((span, &self.sess.span_diagnostic));\n+                if let Some(lit) = Lit::from_token(&token, span, diag) {\n+                    self.bump();\n+                    self.bump();\n+                    return Ok(lit);\n+                }\n+            }\n+        }\n+\n+        Err(self.span_fatal(self.span, &format!(\"unexpected token: {}\", self.this_token_descr())))\n+    }\n+}\n+\n+crate fn expect_no_suffix(sp: Span, diag: &Handler, kind: &str, suffix: Option<ast::Name>) {\n+    match suffix {\n+        None => {/* everything ok */}\n+        Some(suf) => {\n+            let text = suf.as_str();\n+            if text.is_empty() {\n+                diag.span_bug(sp, \"found empty literal suffix in Some\")\n+            }\n+            let mut err = if kind == \"a tuple index\" &&\n+                [\"i32\", \"u32\", \"isize\", \"usize\"].contains(&text.to_string().as_str())\n+            {\n+                // #59553: warn instead of reject out of hand to allow the fix to percolate\n+                // through the ecosystem when people fix their macros\n+                let mut err = diag.struct_span_warn(\n+                    sp,\n+                    &format!(\"suffixes on {} are invalid\", kind),\n+                );\n+                err.note(&format!(\n+                    \"`{}` is *temporarily* accepted on tuple index fields as it was \\\n+                        incorrectly accepted on stable for a few releases\",\n+                    text,\n+                ));\n+                err.help(\n+                    \"on proc macros, you'll want to use `syn::Index::from` or \\\n+                        `proc_macro::Literal::*_unsuffixed` for code that will desugar \\\n+                        to tuple field access\",\n+                );\n+                err.note(\n+                    \"for more context, see https://github.com/rust-lang/rust/issues/60210\",\n+                );\n+                err\n+            } else {\n+                diag.struct_span_err(sp, &format!(\"suffixes on {} are invalid\", kind))\n+            };\n+            err.span_label(sp, format!(\"invalid suffix `{}`\", text));\n+            err.emit();\n+        }\n+    }\n+}\n+\n+/// Parses a string representing a raw string literal into its final form. The\n+/// only operation this does is convert embedded CRLF into a single LF.\n+fn raw_str_lit(lit: &str) -> String {\n+    debug!(\"raw_str_lit: given {}\", lit.escape_default());\n+    let mut res = String::with_capacity(lit.len());\n+\n+    let mut chars = lit.chars().peekable();\n+    while let Some(c) = chars.next() {\n+        if c == '\\r' {\n+            if *chars.peek().unwrap() != '\\n' {\n+                panic!(\"lexer accepted bare CR\");\n+            }\n+            chars.next();\n+            res.push('\\n');\n+        } else {\n+            res.push(c);\n+        }\n+    }\n+\n+    res.shrink_to_fit();\n+    res\n+}\n+\n+// check if `s` looks like i32 or u1234 etc.\n+fn looks_like_width_suffix(first_chars: &[char], s: &str) -> bool {\n+    s.starts_with(first_chars) && s[1..].chars().all(|c| c.is_ascii_digit())\n+}\n+\n+fn filtered_float_lit(data: Symbol, suffix: Option<Symbol>, diag: Option<(Span, &Handler)>)\n+                      -> Option<LitKind> {\n+    debug!(\"filtered_float_lit: {}, {:?}\", data, suffix);\n+    let suffix = match suffix {\n+        Some(suffix) => suffix,\n+        None => return Some(LitKind::FloatUnsuffixed(data)),\n+    };\n+\n+    Some(match &*suffix.as_str() {\n+        \"f32\" => LitKind::Float(data, ast::FloatTy::F32),\n+        \"f64\" => LitKind::Float(data, ast::FloatTy::F64),\n+        suf => {\n+            err!(diag, |span, diag| {\n+                if suf.len() >= 2 && looks_like_width_suffix(&['f'], suf) {\n+                    // if it looks like a width, lets try to be helpful.\n+                    let msg = format!(\"invalid width `{}` for float literal\", &suf[1..]);\n+                    diag.struct_span_err(span, &msg).help(\"valid widths are 32 and 64\").emit()\n+                } else {\n+                    let msg = format!(\"invalid suffix `{}` for float literal\", suf);\n+                    diag.struct_span_err(span, &msg)\n+                        .span_label(span, format!(\"invalid suffix `{}`\", suf))\n+                        .help(\"valid suffixes are `f32` and `f64`\")\n+                        .emit();\n+                }\n+            });\n+\n+            LitKind::FloatUnsuffixed(data)\n+        }\n+    })\n+}\n+fn float_lit(s: &str, suffix: Option<Symbol>, diag: Option<(Span, &Handler)>)\n+                 -> Option<LitKind> {\n+    debug!(\"float_lit: {:?}, {:?}\", s, suffix);\n+    // FIXME #2252: bounds checking float literals is deferred until trans\n+\n+    // Strip underscores without allocating a new String unless necessary.\n+    let s2;\n+    let s = if s.chars().any(|c| c == '_') {\n+        s2 = s.chars().filter(|&c| c != '_').collect::<String>();\n+        &s2\n+    } else {\n+        s\n+    };\n+\n+    filtered_float_lit(Symbol::intern(s), suffix, diag)\n+}\n+\n+fn integer_lit(s: &str, suffix: Option<Symbol>, diag: Option<(Span, &Handler)>)\n+                   -> Option<LitKind> {\n+    // s can only be ascii, byte indexing is fine\n+\n+    // Strip underscores without allocating a new String unless necessary.\n+    let s2;\n+    let mut s = if s.chars().any(|c| c == '_') {\n+        s2 = s.chars().filter(|&c| c != '_').collect::<String>();\n+        &s2\n+    } else {\n+        s\n+    };\n+\n+    debug!(\"integer_lit: {}, {:?}\", s, suffix);\n+\n+    let mut base = 10;\n+    let orig = s;\n+    let mut ty = ast::LitIntType::Unsuffixed;\n+\n+    if s.starts_with('0') && s.len() > 1 {\n+        match s.as_bytes()[1] {\n+            b'x' => base = 16,\n+            b'o' => base = 8,\n+            b'b' => base = 2,\n+            _ => { }\n+        }\n+    }\n+\n+    // 1f64 and 2f32 etc. are valid float literals.\n+    if let Some(suf) = suffix {\n+        if looks_like_width_suffix(&['f'], &suf.as_str()) {\n+            let err = match base {\n+                16 => Some(\"hexadecimal float literal is not supported\"),\n+                8 => Some(\"octal float literal is not supported\"),\n+                2 => Some(\"binary float literal is not supported\"),\n+                _ => None,\n+            };\n+            if let Some(err) = err {\n+                err!(diag, |span, diag| {\n+                    diag.struct_span_err(span, err)\n+                        .span_label(span, \"not supported\")\n+                        .emit();\n+                });\n+            }\n+            return filtered_float_lit(Symbol::intern(s), Some(suf), diag)\n+        }\n+    }\n+\n+    if base != 10 {\n+        s = &s[2..];\n+    }\n+\n+    if let Some(suf) = suffix {\n+        if suf.as_str().is_empty() {\n+            err!(diag, |span, diag| diag.span_bug(span, \"found empty literal suffix in Some\"));\n+        }\n+        ty = match &*suf.as_str() {\n+            \"isize\" => ast::LitIntType::Signed(ast::IntTy::Isize),\n+            \"i8\"  => ast::LitIntType::Signed(ast::IntTy::I8),\n+            \"i16\" => ast::LitIntType::Signed(ast::IntTy::I16),\n+            \"i32\" => ast::LitIntType::Signed(ast::IntTy::I32),\n+            \"i64\" => ast::LitIntType::Signed(ast::IntTy::I64),\n+            \"i128\" => ast::LitIntType::Signed(ast::IntTy::I128),\n+            \"usize\" => ast::LitIntType::Unsigned(ast::UintTy::Usize),\n+            \"u8\"  => ast::LitIntType::Unsigned(ast::UintTy::U8),\n+            \"u16\" => ast::LitIntType::Unsigned(ast::UintTy::U16),\n+            \"u32\" => ast::LitIntType::Unsigned(ast::UintTy::U32),\n+            \"u64\" => ast::LitIntType::Unsigned(ast::UintTy::U64),\n+            \"u128\" => ast::LitIntType::Unsigned(ast::UintTy::U128),\n+            suf => {\n+                // i<digits> and u<digits> look like widths, so lets\n+                // give an error message along those lines\n+                err!(diag, |span, diag| {\n+                    if looks_like_width_suffix(&['i', 'u'], suf) {\n+                        let msg = format!(\"invalid width `{}` for integer literal\", &suf[1..]);\n+                        diag.struct_span_err(span, &msg)\n+                            .help(\"valid widths are 8, 16, 32, 64 and 128\")\n+                            .emit();\n+                    } else {\n+                        let msg = format!(\"invalid suffix `{}` for numeric literal\", suf);\n+                        diag.struct_span_err(span, &msg)\n+                            .span_label(span, format!(\"invalid suffix `{}`\", suf))\n+                            .help(\"the suffix must be one of the integral types \\\n+                                   (`u32`, `isize`, etc)\")\n+                            .emit();\n+                    }\n+                });\n+\n+                ty\n+            }\n+        }\n+    }\n+\n+    debug!(\"integer_lit: the type is {:?}, base {:?}, the new string is {:?}, the original \\\n+           string was {:?}, the original suffix was {:?}\", ty, base, s, orig, suffix);\n+\n+    Some(match u128::from_str_radix(s, base) {\n+        Ok(r) => LitKind::Int(r, ty),\n+        Err(_) => {\n+            // small bases are lexed as if they were base 10, e.g, the string\n+            // might be `0b10201`. This will cause the conversion above to fail,\n+            // but these cases have errors in the lexer: we don't want to emit\n+            // two errors, and we especially don't want to emit this error since\n+            // it isn't necessarily true.\n+            let already_errored = base < 10 &&\n+                s.chars().any(|c| c.to_digit(10).map_or(false, |d| d >= base));\n+\n+            if !already_errored {\n+                err!(diag, |span, diag| diag.span_err(span, \"int literal is too large\"));\n+            }\n+            LitKind::Int(0, ty)\n+        }\n+    })\n+}"}, {"sha": "526143b28755fa204bd2de07c192a4072f6a8c33", "filename": "src/libsyntax/parse/mod.rs", "status": "modified", "additions": 6, "deletions": 289, "changes": 295, "blob_url": "https://github.com/rust-lang/rust/blob/1764b29725df66183059f406c8c65edf642bbd43/src%2Flibsyntax%2Fparse%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1764b29725df66183059f406c8c65edf642bbd43/src%2Flibsyntax%2Fparse%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fmod.rs?ref=1764b29725df66183059f406c8c65edf642bbd43", "patch": "@@ -5,7 +5,6 @@ use crate::early_buffered_lints::{BufferedEarlyLint, BufferedEarlyLintId};\n use crate::source_map::{SourceMap, FilePathMapping};\n use crate::feature_gate::UnstableFeatures;\n use crate::parse::parser::Parser;\n-use crate::symbol::Symbol;\n use crate::syntax::parse::parser::emit_unclosed_delims;\n use crate::tokenstream::{TokenStream, TokenTree};\n use crate::diagnostics::plugin::ErrorMap;\n@@ -14,7 +13,6 @@ use crate::print::pprust::token_to_string;\n use errors::{Applicability, FatalError, Level, Handler, ColorConfig, Diagnostic, DiagnosticBuilder};\n use rustc_data_structures::sync::{Lrc, Lock};\n use syntax_pos::{Span, SourceFile, FileName, MultiSpan};\n-use log::debug;\n \n use rustc_data_structures::fx::{FxHashSet, FxHashMap};\n use std::borrow::Cow;\n@@ -25,18 +23,15 @@ pub type PResult<'a, T> = Result<T, DiagnosticBuilder<'a>>;\n \n #[macro_use]\n pub mod parser;\n-\n+pub mod attr;\n pub mod lexer;\n pub mod token;\n-pub mod attr;\n-pub mod diagnostics;\n-\n-pub mod classify;\n-\n-pub(crate) mod unescape;\n-use unescape::{unescape_str, unescape_char, unescape_byte_str, unescape_byte};\n \n-pub(crate) mod unescape_error_reporting;\n+crate mod classify;\n+crate mod diagnostics;\n+crate mod literal;\n+crate mod unescape;\n+crate mod unescape_error_reporting;\n \n /// Info about a parsing session.\n pub struct ParseSess {\n@@ -334,284 +329,6 @@ pub fn stream_to_parser(sess: &ParseSess, stream: TokenStream) -> Parser<'_> {\n     Parser::new(sess, stream, None, true, false)\n }\n \n-/// Parses a string representing a raw string literal into its final form. The\n-/// only operation this does is convert embedded CRLF into a single LF.\n-fn raw_str_lit(lit: &str) -> String {\n-    debug!(\"raw_str_lit: given {}\", lit.escape_default());\n-    let mut res = String::with_capacity(lit.len());\n-\n-    let mut chars = lit.chars().peekable();\n-    while let Some(c) = chars.next() {\n-        if c == '\\r' {\n-            if *chars.peek().unwrap() != '\\n' {\n-                panic!(\"lexer accepted bare CR\");\n-            }\n-            chars.next();\n-            res.push('\\n');\n-        } else {\n-            res.push(c);\n-        }\n-    }\n-\n-    res.shrink_to_fit();\n-    res\n-}\n-\n-// check if `s` looks like i32 or u1234 etc.\n-fn looks_like_width_suffix(first_chars: &[char], s: &str) -> bool {\n-    s.starts_with(first_chars) && s[1..].chars().all(|c| c.is_ascii_digit())\n-}\n-\n-macro_rules! err {\n-    ($opt_diag:expr, |$span:ident, $diag:ident| $($body:tt)*) => {\n-        match $opt_diag {\n-            Some(($span, $diag)) => { $($body)* }\n-            None => return None,\n-        }\n-    }\n-}\n-\n-crate fn lit_token(lit: token::Lit, suf: Option<Symbol>, diag: Option<(Span, &Handler)>)\n-                 -> (bool /* suffix illegal? */, Option<ast::LitKind>) {\n-    use ast::LitKind;\n-\n-    match lit {\n-        token::Byte(i) => {\n-            let lit_kind = match unescape_byte(&i.as_str()) {\n-                Ok(c) => LitKind::Byte(c),\n-                Err(_) => LitKind::Err(i),\n-            };\n-            (true, Some(lit_kind))\n-        },\n-        token::Char(i) => {\n-            let lit_kind = match unescape_char(&i.as_str()) {\n-                Ok(c) => LitKind::Char(c),\n-                Err(_) => LitKind::Err(i),\n-            };\n-            (true, Some(lit_kind))\n-        },\n-        token::Err(i) => (true, Some(LitKind::Err(i))),\n-\n-        // There are some valid suffixes for integer and float literals,\n-        // so all the handling is done internally.\n-        token::Integer(s) => (false, integer_lit(&s.as_str(), suf, diag)),\n-        token::Float(s) => (false, float_lit(&s.as_str(), suf, diag)),\n-\n-        token::Str_(mut sym) => {\n-            // If there are no characters requiring special treatment we can\n-            // reuse the symbol from the Token. Otherwise, we must generate a\n-            // new symbol because the string in the LitKind is different to the\n-            // string in the Token.\n-            let mut has_error = false;\n-            let s = &sym.as_str();\n-            if s.as_bytes().iter().any(|&c| c == b'\\\\' || c == b'\\r') {\n-                let mut buf = String::with_capacity(s.len());\n-                unescape_str(s, &mut |_, unescaped_char| {\n-                    match unescaped_char {\n-                        Ok(c) => buf.push(c),\n-                        Err(_) => has_error = true,\n-                    }\n-                });\n-                if has_error {\n-                    return (true, Some(LitKind::Err(sym)));\n-                }\n-                sym = Symbol::intern(&buf)\n-            }\n-\n-            (true, Some(LitKind::Str(sym, ast::StrStyle::Cooked)))\n-        }\n-        token::StrRaw(mut sym, n) => {\n-            // Ditto.\n-            let s = &sym.as_str();\n-            if s.contains('\\r') {\n-                sym = Symbol::intern(&raw_str_lit(s));\n-            }\n-            (true, Some(LitKind::Str(sym, ast::StrStyle::Raw(n))))\n-        }\n-        token::ByteStr(i) => {\n-            let s = &i.as_str();\n-            let mut buf = Vec::with_capacity(s.len());\n-            let mut has_error = false;\n-            unescape_byte_str(s, &mut |_, unescaped_byte| {\n-                match unescaped_byte {\n-                    Ok(c) => buf.push(c),\n-                    Err(_) => has_error = true,\n-                }\n-            });\n-            if has_error {\n-                return (true, Some(LitKind::Err(i)));\n-            }\n-            buf.shrink_to_fit();\n-            (true, Some(LitKind::ByteStr(Lrc::new(buf))))\n-        }\n-        token::ByteStrRaw(i, _) => {\n-            (true, Some(LitKind::ByteStr(Lrc::new(i.to_string().into_bytes()))))\n-        }\n-    }\n-}\n-\n-fn filtered_float_lit(data: Symbol, suffix: Option<Symbol>, diag: Option<(Span, &Handler)>)\n-                      -> Option<ast::LitKind> {\n-    debug!(\"filtered_float_lit: {}, {:?}\", data, suffix);\n-    let suffix = match suffix {\n-        Some(suffix) => suffix,\n-        None => return Some(ast::LitKind::FloatUnsuffixed(data)),\n-    };\n-\n-    Some(match &*suffix.as_str() {\n-        \"f32\" => ast::LitKind::Float(data, ast::FloatTy::F32),\n-        \"f64\" => ast::LitKind::Float(data, ast::FloatTy::F64),\n-        suf => {\n-            err!(diag, |span, diag| {\n-                if suf.len() >= 2 && looks_like_width_suffix(&['f'], suf) {\n-                    // if it looks like a width, lets try to be helpful.\n-                    let msg = format!(\"invalid width `{}` for float literal\", &suf[1..]);\n-                    diag.struct_span_err(span, &msg).help(\"valid widths are 32 and 64\").emit()\n-                } else {\n-                    let msg = format!(\"invalid suffix `{}` for float literal\", suf);\n-                    diag.struct_span_err(span, &msg)\n-                        .span_label(span, format!(\"invalid suffix `{}`\", suf))\n-                        .help(\"valid suffixes are `f32` and `f64`\")\n-                        .emit();\n-                }\n-            });\n-\n-            ast::LitKind::FloatUnsuffixed(data)\n-        }\n-    })\n-}\n-fn float_lit(s: &str, suffix: Option<Symbol>, diag: Option<(Span, &Handler)>)\n-                 -> Option<ast::LitKind> {\n-    debug!(\"float_lit: {:?}, {:?}\", s, suffix);\n-    // FIXME #2252: bounds checking float literals is deferred until trans\n-\n-    // Strip underscores without allocating a new String unless necessary.\n-    let s2;\n-    let s = if s.chars().any(|c| c == '_') {\n-        s2 = s.chars().filter(|&c| c != '_').collect::<String>();\n-        &s2\n-    } else {\n-        s\n-    };\n-\n-    filtered_float_lit(Symbol::intern(s), suffix, diag)\n-}\n-\n-fn integer_lit(s: &str, suffix: Option<Symbol>, diag: Option<(Span, &Handler)>)\n-                   -> Option<ast::LitKind> {\n-    // s can only be ascii, byte indexing is fine\n-\n-    // Strip underscores without allocating a new String unless necessary.\n-    let s2;\n-    let mut s = if s.chars().any(|c| c == '_') {\n-        s2 = s.chars().filter(|&c| c != '_').collect::<String>();\n-        &s2\n-    } else {\n-        s\n-    };\n-\n-    debug!(\"integer_lit: {}, {:?}\", s, suffix);\n-\n-    let mut base = 10;\n-    let orig = s;\n-    let mut ty = ast::LitIntType::Unsuffixed;\n-\n-    if s.starts_with('0') && s.len() > 1 {\n-        match s.as_bytes()[1] {\n-            b'x' => base = 16,\n-            b'o' => base = 8,\n-            b'b' => base = 2,\n-            _ => { }\n-        }\n-    }\n-\n-    // 1f64 and 2f32 etc. are valid float literals.\n-    if let Some(suf) = suffix {\n-        if looks_like_width_suffix(&['f'], &suf.as_str()) {\n-            let err = match base {\n-                16 => Some(\"hexadecimal float literal is not supported\"),\n-                8 => Some(\"octal float literal is not supported\"),\n-                2 => Some(\"binary float literal is not supported\"),\n-                _ => None,\n-            };\n-            if let Some(err) = err {\n-                err!(diag, |span, diag| {\n-                    diag.struct_span_err(span, err)\n-                        .span_label(span, \"not supported\")\n-                        .emit();\n-                });\n-            }\n-            return filtered_float_lit(Symbol::intern(s), Some(suf), diag)\n-        }\n-    }\n-\n-    if base != 10 {\n-        s = &s[2..];\n-    }\n-\n-    if let Some(suf) = suffix {\n-        if suf.as_str().is_empty() {\n-            err!(diag, |span, diag| diag.span_bug(span, \"found empty literal suffix in Some\"));\n-        }\n-        ty = match &*suf.as_str() {\n-            \"isize\" => ast::LitIntType::Signed(ast::IntTy::Isize),\n-            \"i8\"  => ast::LitIntType::Signed(ast::IntTy::I8),\n-            \"i16\" => ast::LitIntType::Signed(ast::IntTy::I16),\n-            \"i32\" => ast::LitIntType::Signed(ast::IntTy::I32),\n-            \"i64\" => ast::LitIntType::Signed(ast::IntTy::I64),\n-            \"i128\" => ast::LitIntType::Signed(ast::IntTy::I128),\n-            \"usize\" => ast::LitIntType::Unsigned(ast::UintTy::Usize),\n-            \"u8\"  => ast::LitIntType::Unsigned(ast::UintTy::U8),\n-            \"u16\" => ast::LitIntType::Unsigned(ast::UintTy::U16),\n-            \"u32\" => ast::LitIntType::Unsigned(ast::UintTy::U32),\n-            \"u64\" => ast::LitIntType::Unsigned(ast::UintTy::U64),\n-            \"u128\" => ast::LitIntType::Unsigned(ast::UintTy::U128),\n-            suf => {\n-                // i<digits> and u<digits> look like widths, so lets\n-                // give an error message along those lines\n-                err!(diag, |span, diag| {\n-                    if looks_like_width_suffix(&['i', 'u'], suf) {\n-                        let msg = format!(\"invalid width `{}` for integer literal\", &suf[1..]);\n-                        diag.struct_span_err(span, &msg)\n-                            .help(\"valid widths are 8, 16, 32, 64 and 128\")\n-                            .emit();\n-                    } else {\n-                        let msg = format!(\"invalid suffix `{}` for numeric literal\", suf);\n-                        diag.struct_span_err(span, &msg)\n-                            .span_label(span, format!(\"invalid suffix `{}`\", suf))\n-                            .help(\"the suffix must be one of the integral types \\\n-                                   (`u32`, `isize`, etc)\")\n-                            .emit();\n-                    }\n-                });\n-\n-                ty\n-            }\n-        }\n-    }\n-\n-    debug!(\"integer_lit: the type is {:?}, base {:?}, the new string is {:?}, the original \\\n-           string was {:?}, the original suffix was {:?}\", ty, base, s, orig, suffix);\n-\n-    Some(match u128::from_str_radix(s, base) {\n-        Ok(r) => ast::LitKind::Int(r, ty),\n-        Err(_) => {\n-            // small bases are lexed as if they were base 10, e.g, the string\n-            // might be `0b10201`. This will cause the conversion above to fail,\n-            // but these cases have errors in the lexer: we don't want to emit\n-            // two errors, and we especially don't want to emit this error since\n-            // it isn't necessarily true.\n-            let already_errored = base < 10 &&\n-                s.chars().any(|c| c.to_digit(10).map_or(false, |d| d >= base));\n-\n-            if !already_errored {\n-                err!(diag, |span, diag| diag.span_err(span, \"int literal is too large\"));\n-            }\n-            ast::LitKind::Int(0, ty)\n-        }\n-    })\n-}\n-\n /// A sequence separator.\n pub struct SeqSep {\n     /// The seperator token."}, {"sha": "f95981680b940581f6b9557f99f16d6456c33d1d", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 6, "deletions": 132, "changes": 138, "blob_url": "https://github.com/rust-lang/rust/blob/1764b29725df66183059f406c8c65edf642bbd43/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1764b29725df66183059f406c8c65edf642bbd43/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=1764b29725df66183059f406c8c65edf642bbd43", "patch": "@@ -15,7 +15,7 @@ use crate::ast::{ForeignItem, ForeignItemKind, FunctionRetTy};\n use crate::ast::{GenericParam, GenericParamKind};\n use crate::ast::GenericArg;\n use crate::ast::{Ident, ImplItem, IsAsync, IsAuto, Item, ItemKind};\n-use crate::ast::{Label, Lifetime, Lit, LitKind};\n+use crate::ast::{Label, Lifetime};\n use crate::ast::{Local, LocalSource};\n use crate::ast::MacStmtStyle;\n use crate::ast::{Mac, Mac_, MacDelimiter};\n@@ -35,7 +35,7 @@ use crate::ast::{RangeEnd, RangeSyntax};\n use crate::{ast, attr};\n use crate::ext::base::DummyResult;\n use crate::source_map::{self, SourceMap, Spanned, respan};\n-use crate::parse::{self, SeqSep, classify, token};\n+use crate::parse::{SeqSep, classify, literal, token};\n use crate::parse::lexer::{TokenAndSpan, UnmatchedBrace};\n use crate::parse::lexer::comments::{doc_comment_style, strip_doc_comment_decoration};\n use crate::parse::token::DelimToken;\n@@ -46,7 +46,7 @@ use crate::ptr::P;\n use crate::parse::PResult;\n use crate::ThinVec;\n use crate::tokenstream::{self, DelimSpan, TokenTree, TokenStream, TreeAndJoint};\n-use crate::symbol::{Symbol, keywords};\n+use crate::symbol::{keywords, Symbol};\n \n use errors::{Applicability, DiagnosticBuilder, DiagnosticId, FatalError};\n use rustc_target::spec::abi::{self, Abi};\n@@ -613,19 +613,14 @@ impl<'a> Parser<'a> {\n         })\n     }\n \n-    fn this_token_descr(&self) -> String {\n+    crate fn this_token_descr(&self) -> String {\n         if let Some(prefix) = self.token_descr() {\n             format!(\"{} `{}`\", prefix, self.this_token_to_string())\n         } else {\n             format!(\"`{}`\", self.this_token_to_string())\n         }\n     }\n \n-    fn unexpected_last<T>(&self, t: &token::Token) -> PResult<'a, T> {\n-        let token_str = pprust::token_to_string(t);\n-        Err(self.span_fatal(self.prev_span, &format!(\"unexpected token: `{}`\", token_str)))\n-    }\n-\n     crate fn unexpected<T>(&mut self) -> PResult<'a, T> {\n         match self.expect_one_of(&[], &[]) {\n             Err(e) => Err(e),\n@@ -1109,43 +1104,7 @@ impl<'a> Parser<'a> {\n     }\n \n     fn expect_no_suffix(&self, sp: Span, kind: &str, suffix: Option<ast::Name>) {\n-        match suffix {\n-            None => {/* everything ok */}\n-            Some(suf) => {\n-                let text = suf.as_str();\n-                if text.is_empty() {\n-                    self.span_bug(sp, \"found empty literal suffix in Some\")\n-                }\n-                let mut err = if kind == \"a tuple index\" &&\n-                    [\"i32\", \"u32\", \"isize\", \"usize\"].contains(&text.to_string().as_str())\n-                {\n-                    // #59553: warn instead of reject out of hand to allow the fix to percolate\n-                    // through the ecosystem when people fix their macros\n-                    let mut err = self.struct_span_warn(\n-                        sp,\n-                        &format!(\"suffixes on {} are invalid\", kind),\n-                    );\n-                    err.note(&format!(\n-                        \"`{}` is *temporarily* accepted on tuple index fields as it was \\\n-                         incorrectly accepted on stable for a few releases\",\n-                        text,\n-                    ));\n-                    err.help(\n-                        \"on proc macros, you'll want to use `syn::Index::from` or \\\n-                         `proc_macro::Literal::*_unsuffixed` for code that will desugar \\\n-                         to tuple field access\",\n-                    );\n-                    err.note(\n-                        \"for more context, see https://github.com/rust-lang/rust/issues/60210\",\n-                    );\n-                    err\n-                } else {\n-                    self.struct_span_err(sp, &format!(\"suffixes on {} are invalid\", kind))\n-                };\n-                err.span_label(sp, format!(\"invalid suffix `{}`\", text));\n-                err.emit();\n-            }\n-        }\n+        literal::expect_no_suffix(sp, &self.sess.span_diagnostic, kind, suffix)\n     }\n \n     /// Attempts to consume a `<`. If `<<` is seen, replaces it with a single\n@@ -1423,7 +1382,7 @@ impl<'a> Parser<'a> {\n         })\n     }\n \n-    fn look_ahead_span(&self, dist: usize) -> Span {\n+    crate fn look_ahead_span(&self, dist: usize) -> Span {\n         if dist == 0 {\n             return self.span\n         }\n@@ -1452,9 +1411,6 @@ impl<'a> Parser<'a> {\n     crate fn struct_span_err<S: Into<MultiSpan>>(&self, sp: S, m: &str) -> DiagnosticBuilder<'a> {\n         self.sess.span_diagnostic.struct_span_err(sp, m)\n     }\n-    fn struct_span_warn<S: Into<MultiSpan>>(&self, sp: S, m: &str) -> DiagnosticBuilder<'a> {\n-        self.sess.span_diagnostic.struct_span_warn(sp, m)\n-    }\n     crate fn span_bug<S: Into<MultiSpan>>(&self, sp: S, m: &str) -> ! {\n         self.sess.span_diagnostic.span_bug(sp, m)\n     }\n@@ -2069,88 +2025,6 @@ impl<'a> Parser<'a> {\n         }\n     }\n \n-    /// Matches `token_lit = LIT_INTEGER | ...`.\n-    fn parse_lit_token(&mut self) -> PResult<'a, LitKind> {\n-        let out = match self.token {\n-            token::Interpolated(ref nt) => match **nt {\n-                token::NtExpr(ref v) | token::NtLiteral(ref v) => match v.node {\n-                    ExprKind::Lit(ref lit) => { lit.node.clone() }\n-                    _ => { return self.unexpected_last(&self.token); }\n-                },\n-                _ => { return self.unexpected_last(&self.token); }\n-            },\n-            token::Literal(lit, suf) => {\n-                let diag = Some((self.span, &self.sess.span_diagnostic));\n-                let (suffix_illegal, result) = parse::lit_token(lit, suf, diag);\n-\n-                if suffix_illegal {\n-                    let sp = self.span;\n-                    self.expect_no_suffix(sp, &format!(\"a {}\", lit.literal_name()), suf)\n-                }\n-\n-                result.unwrap()\n-            }\n-            token::Dot if self.look_ahead(1, |t| match t {\n-                token::Literal(parse::token::Lit::Integer(_) , _) => true,\n-                _ => false,\n-            }) => { // recover from `let x = .4;`\n-                let lo = self.span;\n-                self.bump();\n-                if let token::Literal(\n-                    parse::token::Lit::Integer(val),\n-                    suffix,\n-                ) = self.token {\n-                    let suffix = suffix.and_then(|s| {\n-                        let s = s.as_str();\n-                        if s == \"f32\" {\n-                            Some(\"f32\")\n-                        } else if s == \"f64\" {\n-                            Some(\"f64\")\n-                        } else {\n-                            None\n-                        }\n-                    }).unwrap_or(\"\");\n-                    self.bump();\n-                    let sp = lo.to(self.prev_span);\n-                    let mut err = self.diagnostic()\n-                        .struct_span_err(sp, \"float literals must have an integer part\");\n-                    err.span_suggestion(\n-                        sp,\n-                        \"must have an integer part\",\n-                        format!(\"0.{}{}\", val, suffix),\n-                        Applicability::MachineApplicable,\n-                    );\n-                    err.emit();\n-                    return Ok(match suffix {\n-                        \"f32\" => ast::LitKind::Float(val, ast::FloatTy::F32),\n-                        \"f64\" => ast::LitKind::Float(val, ast::FloatTy::F64),\n-                        _ => ast::LitKind::FloatUnsuffixed(val),\n-                    });\n-                } else {\n-                    unreachable!();\n-                };\n-            }\n-            _ => { return self.unexpected_last(&self.token); }\n-        };\n-\n-        self.bump();\n-        Ok(out)\n-    }\n-\n-    /// Matches `lit = true | false | token_lit`.\n-    crate fn parse_lit(&mut self) -> PResult<'a, Lit> {\n-        let lo = self.span;\n-        let lit = if self.eat_keyword(keywords::True) {\n-            LitKind::Bool(true)\n-        } else if self.eat_keyword(keywords::False) {\n-            LitKind::Bool(false)\n-        } else {\n-            let lit = self.parse_lit_token()?;\n-            lit\n-        };\n-        Ok(source_map::Spanned { node: lit, span: lo.to(self.prev_span) })\n-    }\n-\n     /// Matches `'-' lit | lit` (cf. `ast_validation::AstValidator::check_expr_within_pat`).\n     crate fn parse_literal_maybe_minus(&mut self) -> PResult<'a, P<Expr>> {\n         maybe_whole_expr!(self);"}, {"sha": "0c2ea70aa20c8e015c4576a1c2aed7a271eabdec", "filename": "src/libsyntax/parse/token.rs", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/1764b29725df66183059f406c8c65edf642bbd43/src%2Flibsyntax%2Fparse%2Ftoken.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1764b29725df66183059f406c8c65edf642bbd43/src%2Flibsyntax%2Fparse%2Ftoken.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Ftoken.rs?ref=1764b29725df66183059f406c8c65edf642bbd43", "patch": "@@ -61,6 +61,7 @@ impl DelimToken {\n \n #[derive(Clone, PartialEq, RustcEncodable, RustcDecodable, Hash, Debug, Copy)]\n pub enum Lit {\n+    Bool(ast::Name), // AST only, must never appear in a `Token`\n     Byte(ast::Name),\n     Char(ast::Name),\n     Err(ast::Name),\n@@ -72,9 +73,13 @@ pub enum Lit {\n     ByteStrRaw(ast::Name, u16), /* raw byte str delimited by n hash symbols */\n }\n \n+#[cfg(target_arch = \"x86_64\")]\n+static_assert!(MEM_SIZE_OF_LIT: mem::size_of::<Lit>() == 8);\n+\n impl Lit {\n     crate fn literal_name(&self) -> &'static str {\n         match *self {\n+            Bool(_) => panic!(\"literal token contains `Lit::Bool`\"),\n             Byte(_) => \"byte literal\",\n             Char(_) => \"char literal\",\n             Err(_) => \"invalid literal\",\n@@ -85,6 +90,13 @@ impl Lit {\n         }\n     }\n \n+    crate fn may_have_suffix(&self) -> bool {\n+        match *self {\n+            Integer(..) | Float(..) => true,\n+            _ => false,\n+        }\n+    }\n+\n     // See comments in `Nonterminal::to_tokenstream` for why we care about\n     // *probably* equal here rather than actual equality\n     fn probably_equal_for_proc_macro(&self, other: &Lit) -> bool {"}, {"sha": "0e8ac6c35b9bffb3846d68a58ddd9dcee6018212", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 32, "deletions": 125, "changes": 157, "blob_url": "https://github.com/rust-lang/rust/blob/1764b29725df66183059f406c8c65edf642bbd43/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1764b29725df66183059f406c8c65edf642bbd43/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=1764b29725df66183059f406c8c65edf642bbd43", "patch": "@@ -20,10 +20,8 @@ use rustc_target::spec::abi::{self, Abi};\n use syntax_pos::{self, BytePos};\n use syntax_pos::{DUMMY_SP, FileName};\n \n-use std::ascii;\n use std::borrow::Cow;\n use std::io::{self, Write, Read};\n-use std::iter::Peekable;\n use std::vec;\n \n pub enum AnnNode<'a> {\n@@ -49,8 +47,7 @@ impl PpAnn for NoAnn {}\n pub struct State<'a> {\n     pub s: pp::Printer<'a>,\n     cm: Option<&'a SourceMap>,\n-    comments: Option<Vec<comments::Comment> >,\n-    literals: Peekable<vec::IntoIter<comments::Literal>>,\n+    comments: Option<Vec<comments::Comment>>,\n     cur_cmnt: usize,\n     boxes: Vec<pp::Breaks>,\n     ann: &'a (dyn PpAnn+'a),\n@@ -62,7 +59,6 @@ fn rust_printer<'a>(writer: Box<dyn Write+'a>, ann: &'a dyn PpAnn) -> State<'a>\n         s: pp::mk_printer(writer, DEFAULT_COLUMNS),\n         cm: None,\n         comments: None,\n-        literals: vec![].into_iter().peekable(),\n         cur_cmnt: 0,\n         boxes: Vec::new(),\n         ann,\n@@ -75,8 +71,7 @@ pub const INDENT_UNIT: usize = 4;\n pub const DEFAULT_COLUMNS: usize = 78;\n \n /// Requires you to pass an input filename and reader so that\n-/// it can scan the input text for comments and literals to\n-/// copy forward.\n+/// it can scan the input text for comments to copy forward.\n pub fn print_crate<'a>(cm: &'a SourceMap,\n                        sess: &ParseSess,\n                        krate: &ast::Crate,\n@@ -118,36 +113,23 @@ impl<'a> State<'a> {\n                           out: Box<dyn Write+'a>,\n                           ann: &'a dyn PpAnn,\n                           is_expanded: bool) -> State<'a> {\n-        let (cmnts, lits) = comments::gather_comments_and_literals(sess, filename, input);\n-\n-        State::new(\n-            cm,\n-            out,\n-            ann,\n-            Some(cmnts),\n-            // If the code is post expansion, don't use the table of\n-            // literals, since it doesn't correspond with the literals\n-            // in the AST anymore.\n-            if is_expanded { None } else { Some(lits) },\n-            is_expanded\n-        )\n+        let comments = comments::gather_comments(sess, filename, input);\n+        State::new(cm, out, ann, Some(comments), is_expanded)\n     }\n \n     pub fn new(cm: &'a SourceMap,\n                out: Box<dyn Write+'a>,\n                ann: &'a dyn PpAnn,\n                comments: Option<Vec<comments::Comment>>,\n-               literals: Option<Vec<comments::Literal>>,\n                is_expanded: bool) -> State<'a> {\n         State {\n             s: pp::mk_printer(out, DEFAULT_COLUMNS),\n             cm: Some(cm),\n             comments,\n-            literals: literals.unwrap_or_default().into_iter().peekable(),\n             cur_cmnt: 0,\n             boxes: Vec::new(),\n             ann,\n-            is_expanded: is_expanded\n+            is_expanded,\n         }\n     }\n }\n@@ -180,6 +162,31 @@ fn binop_to_string(op: BinOpToken) -> &'static str {\n     }\n }\n \n+pub fn literal_to_string(lit: token::Lit, suffix: Option<ast::Name>) -> String {\n+    let mut out = match lit {\n+        token::Byte(b)           => format!(\"b'{}'\", b),\n+        token::Char(c)           => format!(\"'{}'\", c),\n+        token::Err(c)            => format!(\"'{}'\", c),\n+        token::Bool(c)           |\n+        token::Float(c)          |\n+        token::Integer(c)        => c.to_string(),\n+        token::Str_(s)           => format!(\"\\\"{}\\\"\", s),\n+        token::StrRaw(s, n)      => format!(\"r{delim}\\\"{string}\\\"{delim}\",\n+                                            delim=\"#\".repeat(n as usize),\n+                                            string=s),\n+        token::ByteStr(v)        => format!(\"b\\\"{}\\\"\", v),\n+        token::ByteStrRaw(s, n)  => format!(\"br{delim}\\\"{string}\\\"{delim}\",\n+                                            delim=\"#\".repeat(n as usize),\n+                                            string=s),\n+    };\n+\n+    if let Some(suffix) = suffix {\n+        out.push_str(&suffix.as_str())\n+    }\n+\n+    out\n+}\n+\n pub fn token_to_string(tok: &Token) -> String {\n     match *tok {\n         token::Eq                   => \"=\".to_string(),\n@@ -223,29 +230,7 @@ pub fn token_to_string(tok: &Token) -> String {\n         token::SingleQuote          => \"'\".to_string(),\n \n         /* Literals */\n-        token::Literal(lit, suf) => {\n-            let mut out = match lit {\n-                token::Byte(b)           => format!(\"b'{}'\", b),\n-                token::Char(c)           => format!(\"'{}'\", c),\n-                token::Err(c)            => format!(\"'{}'\", c),\n-                token::Float(c)          |\n-                token::Integer(c)        => c.to_string(),\n-                token::Str_(s)           => format!(\"\\\"{}\\\"\", s),\n-                token::StrRaw(s, n)      => format!(\"r{delim}\\\"{string}\\\"{delim}\",\n-                                                    delim=\"#\".repeat(n as usize),\n-                                                    string=s),\n-                token::ByteStr(v)         => format!(\"b\\\"{}\\\"\", v),\n-                token::ByteStrRaw(s, n)   => format!(\"br{delim}\\\"{string}\\\"{delim}\",\n-                                                    delim=\"#\".repeat(n as usize),\n-                                                    string=s),\n-            };\n-\n-            if let Some(s) = suf {\n-                out.push_str(&s.as_str())\n-            }\n-\n-            out\n-        }\n+        token::Literal(lit, suf) => literal_to_string(lit, suf),\n \n         /* Name components */\n         token::Ident(s, false)      => s.to_string(),\n@@ -438,8 +423,6 @@ pub trait PrintState<'a> {\n     fn boxes(&mut self) -> &mut Vec<pp::Breaks>;\n     fn comments(&mut self) -> &mut Option<Vec<comments::Comment>>;\n     fn cur_cmnt(&mut self) -> &mut usize;\n-    fn cur_lit(&mut self) -> Option<&comments::Literal>;\n-    fn bump_lit(&mut self) -> Option<comments::Literal>;\n \n     fn word_space<S: Into<Cow<'static, str>>>(&mut self, w: S) -> io::Result<()> {\n         self.writer().word(w)?;\n@@ -504,21 +487,6 @@ pub trait PrintState<'a> {\n         self.end()\n     }\n \n-    fn next_lit(&mut self, pos: BytePos) -> Option<comments::Literal> {\n-        while let Some(ltrl) = self.cur_lit().cloned() {\n-            if ltrl.pos > pos { break; }\n-\n-            // we don't need the value here since we're forced to clone cur_lit\n-            // due to lack of NLL.\n-            self.bump_lit();\n-            if ltrl.pos == pos {\n-                return Some(ltrl);\n-            }\n-        }\n-\n-        None\n-    }\n-\n     fn maybe_print_comment(&mut self, pos: BytePos) -> io::Result<()> {\n         while let Some(ref cmnt) = self.next_comment() {\n             if cmnt.pos < pos {\n@@ -606,60 +574,7 @@ pub trait PrintState<'a> {\n \n     fn print_literal(&mut self, lit: &ast::Lit) -> io::Result<()> {\n         self.maybe_print_comment(lit.span.lo())?;\n-        if let Some(ltrl) = self.next_lit(lit.span.lo()) {\n-            return self.writer().word(ltrl.lit.clone());\n-        }\n-        match lit.node {\n-            ast::LitKind::Str(st, style) => self.print_string(&st.as_str(), style),\n-            ast::LitKind::Err(st) => {\n-                let st = st.as_str().escape_debug().to_string();\n-                let mut res = String::with_capacity(st.len() + 2);\n-                res.push('\\'');\n-                res.push_str(&st);\n-                res.push('\\'');\n-                self.writer().word(res)\n-            }\n-            ast::LitKind::Byte(byte) => {\n-                let mut res = String::from(\"b'\");\n-                res.extend(ascii::escape_default(byte).map(|c| c as char));\n-                res.push('\\'');\n-                self.writer().word(res)\n-            }\n-            ast::LitKind::Char(ch) => {\n-                let mut res = String::from(\"'\");\n-                res.extend(ch.escape_default());\n-                res.push('\\'');\n-                self.writer().word(res)\n-            }\n-            ast::LitKind::Int(i, t) => {\n-                match t {\n-                    ast::LitIntType::Signed(st) => {\n-                        self.writer().word(st.val_to_string(i as i128))\n-                    }\n-                    ast::LitIntType::Unsigned(ut) => {\n-                        self.writer().word(ut.val_to_string(i))\n-                    }\n-                    ast::LitIntType::Unsuffixed => {\n-                        self.writer().word(i.to_string())\n-                    }\n-                }\n-            }\n-            ast::LitKind::Float(ref f, t) => {\n-                self.writer().word(format!(\"{}{}\", &f, t.ty_to_string()))\n-            }\n-            ast::LitKind::FloatUnsuffixed(ref f) => self.writer().word(f.as_str().to_string()),\n-            ast::LitKind::Bool(val) => {\n-                if val { self.writer().word(\"true\") } else { self.writer().word(\"false\") }\n-            }\n-            ast::LitKind::ByteStr(ref v) => {\n-                let mut escaped: String = String::new();\n-                for &ch in v.iter() {\n-                    escaped.extend(ascii::escape_default(ch)\n-                                         .map(|c| c as char));\n-                }\n-                self.writer().word(format!(\"b\\\"{}\\\"\", escaped))\n-            }\n-        }\n+        self.writer().word(literal_to_string(lit.token, lit.suffix))\n     }\n \n     fn print_string(&mut self, st: &str,\n@@ -880,14 +795,6 @@ impl<'a> PrintState<'a> for State<'a> {\n     fn cur_cmnt(&mut self) -> &mut usize {\n         &mut self.cur_cmnt\n     }\n-\n-    fn cur_lit(&mut self) -> Option<&comments::Literal> {\n-        self.literals.peek()\n-    }\n-\n-    fn bump_lit(&mut self) -> Option<comments::Literal> {\n-        self.literals.next()\n-    }\n }\n \n impl<'a> State<'a> {"}, {"sha": "571779dfa1ae72f740d58e14cdc87170ff622aa1", "filename": "src/test/ui/attr-eq-token-tree.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1764b29725df66183059f406c8c65edf642bbd43/src%2Ftest%2Fui%2Fattr-eq-token-tree.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/1764b29725df66183059f406c8c65edf642bbd43/src%2Ftest%2Fui%2Fattr-eq-token-tree.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fattr-eq-token-tree.stderr?ref=1764b29725df66183059f406c8c65edf642bbd43", "patch": "@@ -1,8 +1,8 @@\n error: unexpected token: `!`\n-  --> $DIR/attr-eq-token-tree.rs:3:11\n+  --> $DIR/attr-eq-token-tree.rs:3:13\n    |\n LL | #[my_attr = !]\n-   |           ^\n+   |             ^\n \n error: aborting due to previous error\n "}, {"sha": "359725a41c105892aedde9f8ecdcbc8460050c59", "filename": "src/test/ui/exclusive-range/exclusive_range_pattern_syntax_collision.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1764b29725df66183059f406c8c65edf642bbd43/src%2Ftest%2Fui%2Fexclusive-range%2Fexclusive_range_pattern_syntax_collision.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/1764b29725df66183059f406c8c65edf642bbd43/src%2Ftest%2Fui%2Fexclusive-range%2Fexclusive_range_pattern_syntax_collision.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fexclusive-range%2Fexclusive_range_pattern_syntax_collision.stderr?ref=1764b29725df66183059f406c8c65edf642bbd43", "patch": "@@ -1,8 +1,8 @@\n error: unexpected token: `,`\n-  --> $DIR/exclusive_range_pattern_syntax_collision.rs:5:15\n+  --> $DIR/exclusive_range_pattern_syntax_collision.rs:5:17\n    |\n LL |         [_, 99.., _] => {},\n-   |               ^^\n+   |                 ^\n \n error: aborting due to previous error\n "}, {"sha": "8f849d7b3f87c5a53f8af1f5d302b970afe481f0", "filename": "src/test/ui/exclusive-range/exclusive_range_pattern_syntax_collision2.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1764b29725df66183059f406c8c65edf642bbd43/src%2Ftest%2Fui%2Fexclusive-range%2Fexclusive_range_pattern_syntax_collision2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/1764b29725df66183059f406c8c65edf642bbd43/src%2Ftest%2Fui%2Fexclusive-range%2Fexclusive_range_pattern_syntax_collision2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fexclusive-range%2Fexclusive_range_pattern_syntax_collision2.stderr?ref=1764b29725df66183059f406c8c65edf642bbd43", "patch": "@@ -1,8 +1,8 @@\n error: unexpected token: `]`\n-  --> $DIR/exclusive_range_pattern_syntax_collision2.rs:5:15\n+  --> $DIR/exclusive_range_pattern_syntax_collision2.rs:5:17\n    |\n LL |         [_, 99..] => {},\n-   |               ^^\n+   |                 ^\n \n error: aborting due to previous error\n "}, {"sha": "d28ce25341d3ac89509674565b09e7635aae21e9", "filename": "src/test/ui/macros/macro-attribute.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1764b29725df66183059f406c8c65edf642bbd43/src%2Ftest%2Fui%2Fmacros%2Fmacro-attribute.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/1764b29725df66183059f406c8c65edf642bbd43/src%2Ftest%2Fui%2Fmacros%2Fmacro-attribute.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmacros%2Fmacro-attribute.stderr?ref=1764b29725df66183059f406c8c65edf642bbd43", "patch": "@@ -1,8 +1,8 @@\n error: unexpected token: `$`\n-  --> $DIR/macro-attribute.rs:1:7\n+  --> $DIR/macro-attribute.rs:1:9\n    |\n LL | #[doc = $not_there]\n-   |       ^\n+   |         ^\n \n error: aborting due to previous error\n "}, {"sha": "7c4ca3c017e7b33ad8634147566bf4c234fe64b6", "filename": "src/test/ui/malformed/malformed-interpolated.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/1764b29725df66183059f406c8c65edf642bbd43/src%2Ftest%2Fui%2Fmalformed%2Fmalformed-interpolated.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1764b29725df66183059f406c8c65edf642bbd43/src%2Ftest%2Fui%2Fmalformed%2Fmalformed-interpolated.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmalformed%2Fmalformed-interpolated.rs?ref=1764b29725df66183059f406c8c65edf642bbd43", "patch": "@@ -2,16 +2,15 @@\n \n macro_rules! check {\n     ($expr: expr) => (\n-        #[my_attr = $expr] //~ ERROR suffixed literals are not allowed in attributes\n-                           //~| ERROR unexpected token: `-0`\n+        #[my_attr = $expr] //~ ERROR unexpected token: `-0`\n                            //~| ERROR unexpected token: `0 + 0`\n         use main as _;\n     );\n }\n \n check!(\"0\"); // OK\n check!(0); // OK\n-check!(0u8); // ERROR, see above\n+check!(0u8); //~ ERROR suffixed literals are not allowed in attributes\n check!(-0); // ERROR, see above\n check!(0 + 0); // ERROR, see above\n "}, {"sha": "e805416172bab8d58133ea77e026cf0546341cc8", "filename": "src/test/ui/malformed/malformed-interpolated.stderr", "status": "modified", "additions": 7, "deletions": 10, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/1764b29725df66183059f406c8c65edf642bbd43/src%2Ftest%2Fui%2Fmalformed%2Fmalformed-interpolated.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/1764b29725df66183059f406c8c65edf642bbd43/src%2Ftest%2Fui%2Fmalformed%2Fmalformed-interpolated.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmalformed%2Fmalformed-interpolated.stderr?ref=1764b29725df66183059f406c8c65edf642bbd43", "patch": "@@ -1,28 +1,25 @@\n error: suffixed literals are not allowed in attributes\n-  --> $DIR/malformed-interpolated.rs:5:21\n+  --> $DIR/malformed-interpolated.rs:13:8\n    |\n-LL |         #[my_attr = $expr]\n-   |                     ^^^^^\n-...\n-LL | check!(0u8); // ERROR, see above\n-   | ------------ in this macro invocation\n+LL | check!(0u8);\n+   |        ^^^\n    |\n    = help: instead of using a suffixed literal (1u8, 1.0f32, etc.), use an unsuffixed version (1, 1.0, etc.).\n \n error: unexpected token: `-0`\n-  --> $DIR/malformed-interpolated.rs:5:19\n+  --> $DIR/malformed-interpolated.rs:5:21\n    |\n LL |         #[my_attr = $expr]\n-   |                   ^\n+   |                     ^^^^^\n ...\n LL | check!(-0); // ERROR, see above\n    | ----------- in this macro invocation\n \n error: unexpected token: `0 + 0`\n-  --> $DIR/malformed-interpolated.rs:5:19\n+  --> $DIR/malformed-interpolated.rs:5:21\n    |\n LL |         #[my_attr = $expr]\n-   |                   ^\n+   |                     ^^^^^\n ...\n LL | check!(0 + 0); // ERROR, see above\n    | -------------- in this macro invocation"}, {"sha": "2d772dae69125c74ffc2bf4358471a11cf086ca1", "filename": "src/test/ui/parser/attr-bad-meta-2.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1764b29725df66183059f406c8c65edf642bbd43/src%2Ftest%2Fui%2Fparser%2Fattr-bad-meta-2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/1764b29725df66183059f406c8c65edf642bbd43/src%2Ftest%2Fui%2Fparser%2Fattr-bad-meta-2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fattr-bad-meta-2.stderr?ref=1764b29725df66183059f406c8c65edf642bbd43", "patch": "@@ -1,8 +1,8 @@\n error: unexpected token: `]`\n-  --> $DIR/attr-bad-meta-2.rs:1:8\n+  --> $DIR/attr-bad-meta-2.rs:1:9\n    |\n LL | #[path =]\n-   |        ^\n+   |         ^\n \n error: aborting due to previous error\n "}, {"sha": "f9832214c6800b4c7ba8fc0012d47ecc78a86b22", "filename": "src/test/ui/parser/pat-tuple-5.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1764b29725df66183059f406c8c65edf642bbd43/src%2Ftest%2Fui%2Fparser%2Fpat-tuple-5.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/1764b29725df66183059f406c8c65edf642bbd43/src%2Ftest%2Fui%2Fparser%2Fpat-tuple-5.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fpat-tuple-5.stderr?ref=1764b29725df66183059f406c8c65edf642bbd43", "patch": "@@ -1,8 +1,8 @@\n error: unexpected token: `)`\n-  --> $DIR/pat-tuple-5.rs:3:14\n+  --> $DIR/pat-tuple-5.rs:3:16\n    |\n LL |         (pat ..) => {}\n-   |              ^^\n+   |                ^\n \n error: aborting due to previous error\n "}]}