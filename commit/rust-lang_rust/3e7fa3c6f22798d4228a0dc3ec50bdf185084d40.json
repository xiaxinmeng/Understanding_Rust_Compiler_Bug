{"sha": "3e7fa3c6f22798d4228a0dc3ec50bdf185084d40", "node_id": "MDY6Q29tbWl0NzI0NzEyOjNlN2ZhM2M2ZjIyNzk4ZDQyMjhhMGRjM2VjNTBiZGYxODUwODRkNDA=", "commit": {"author": {"name": "Oliver Scherer", "email": "github35764891676564198441@oli-obk.de", "date": "2019-12-25T00:04:32Z"}, "committer": {"name": "Oliver Scherer", "email": "github35764891676564198441@oli-obk.de", "date": "2019-12-26T11:10:36Z"}, "message": "Move const eval machine into its own module", "tree": {"sha": "d2c24117e045845de1ac866fb85abc3a73d19eda", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d2c24117e045845de1ac866fb85abc3a73d19eda"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3e7fa3c6f22798d4228a0dc3ec50bdf185084d40", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3e7fa3c6f22798d4228a0dc3ec50bdf185084d40", "html_url": "https://github.com/rust-lang/rust/commit/3e7fa3c6f22798d4228a0dc3ec50bdf185084d40", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3e7fa3c6f22798d4228a0dc3ec50bdf185084d40/comments", "author": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "committer": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c0b16b4e6aa94cd83fd2c029356ba537dc4502c6", "url": "https://api.github.com/repos/rust-lang/rust/commits/c0b16b4e6aa94cd83fd2c029356ba537dc4502c6", "html_url": "https://github.com/rust-lang/rust/commit/c0b16b4e6aa94cd83fd2c029356ba537dc4502c6"}], "stats": {"total": 713, "additions": 369, "deletions": 344}, "files": [{"sha": "833547d4d059be24ce59e54ae0341bd284aabc55", "filename": "src/librustc_mir/const_eval.rs", "status": "modified", "additions": 11, "deletions": 344, "changes": 355, "blob_url": "https://github.com/rust-lang/rust/blob/3e7fa3c6f22798d4228a0dc3ec50bdf185084d40/src%2Flibrustc_mir%2Fconst_eval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e7fa3c6f22798d4228a0dc3ec50bdf185084d40/src%2Flibrustc_mir%2Fconst_eval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fconst_eval.rs?ref=3e7fa3c6f22798d4228a0dc3ec50bdf185084d40", "patch": "@@ -1,39 +1,35 @@\n // Not in interpret to make sure we do not use private implementation details\n \n-use std::borrow::{Borrow, Cow};\n-use std::collections::hash_map::Entry;\n use std::convert::TryInto;\n use std::error::Error;\n use std::fmt;\n use std::hash::Hash;\n \n+use crate::interpret::eval_nullary_intrinsic;\n use crate::interpret::eval_nullary_intrinsic;\n use rustc::hir::def::DefKind;\n-use rustc::hir::def_id::DefId;\n use rustc::mir;\n use rustc::mir::interpret::{ConstEvalErr, ErrorHandled, ScalarMaybeUndef};\n use rustc::traits::Reveal;\n-use rustc::ty::layout::{self, HasTyCtxt, LayoutOf, VariantIdx};\n-use rustc::ty::{self, subst::Subst, Ty, TyCtxt};\n-use rustc_data_structures::fx::FxHashMap;\n+use rustc::ty::layout::{self, LayoutOf, VariantIdx};\n+use rustc::ty::{self, subst::Subst, TyCtxt};\n \n use syntax::{\n     source_map::{Span, DUMMY_SP},\n     symbol::Symbol,\n };\n \n use crate::interpret::{\n-    self, intern_const_alloc_recursive, snapshot, AllocId, Allocation, AssertMessage, ConstValue,\n-    GlobalId, ImmTy, Immediate, InterpCx, InterpErrorInfo, InterpResult, MPlaceTy, Machine, Memory,\n-    MemoryKind, OpTy, PlaceTy, Pointer, RawConst, RefTracking, Scalar, StackPopCleanup,\n+    intern_const_alloc_recursive, Allocation, ConstValue, GlobalId, ImmTy, Immediate, InterpCx,\n+    InterpErrorInfo, InterpResult, MPlaceTy, Machine, MemoryKind, OpTy, RawConst, RefTracking,\n+    Scalar, StackPopCleanup,\n };\n \n-/// Number of steps until the detector even starts doing anything.\n-/// Also, a warning is shown to the user when this number is reached.\n-const STEPS_UNTIL_DETECTOR_ENABLED: isize = 1_000_000;\n-/// The number of steps between loop detector snapshots.\n-/// Should be a power of two for performance reasons.\n-const DETECTOR_SNAPSHOT_PERIOD: isize = 256;\n+mod error;\n+mod machine;\n+\n+pub use error::*;\n+pub use machine::*;\n \n /// The `InterpCx` is only meant to be used to do field and index projections into constants for\n /// `simd_shuffle` and const patterns in match arms.\n@@ -173,335 +169,6 @@ fn eval_body_using_ecx<'mir, 'tcx>(\n     Ok(ret)\n }\n \n-#[derive(Clone, Debug)]\n-pub enum ConstEvalError {\n-    NeedsRfc(String),\n-    ConstAccessesStatic,\n-}\n-\n-impl<'tcx> Into<InterpErrorInfo<'tcx>> for ConstEvalError {\n-    fn into(self) -> InterpErrorInfo<'tcx> {\n-        err_unsup!(Unsupported(self.to_string())).into()\n-    }\n-}\n-\n-impl fmt::Display for ConstEvalError {\n-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        use self::ConstEvalError::*;\n-        match *self {\n-            NeedsRfc(ref msg) => {\n-                write!(f, \"\\\"{}\\\" needs an rfc before being allowed inside constants\", msg)\n-            }\n-            ConstAccessesStatic => write!(f, \"constant accesses static\"),\n-        }\n-    }\n-}\n-\n-impl Error for ConstEvalError {}\n-\n-// Extra machine state for CTFE, and the Machine instance\n-pub struct CompileTimeInterpreter<'mir, 'tcx> {\n-    /// When this value is negative, it indicates the number of interpreter\n-    /// steps *until* the loop detector is enabled. When it is positive, it is\n-    /// the number of steps after the detector has been enabled modulo the loop\n-    /// detector period.\n-    pub(super) steps_since_detector_enabled: isize,\n-\n-    /// Extra state to detect loops.\n-    pub(super) loop_detector: snapshot::InfiniteLoopDetector<'mir, 'tcx>,\n-}\n-\n-#[derive(Copy, Clone, Debug)]\n-pub struct MemoryExtra {\n-    /// Whether this machine may read from statics\n-    can_access_statics: bool,\n-}\n-\n-impl<'mir, 'tcx> CompileTimeInterpreter<'mir, 'tcx> {\n-    fn new() -> Self {\n-        CompileTimeInterpreter {\n-            loop_detector: Default::default(),\n-            steps_since_detector_enabled: -STEPS_UNTIL_DETECTOR_ENABLED,\n-        }\n-    }\n-}\n-\n-impl<K: Hash + Eq, V> interpret::AllocMap<K, V> for FxHashMap<K, V> {\n-    #[inline(always)]\n-    fn contains_key<Q: ?Sized + Hash + Eq>(&mut self, k: &Q) -> bool\n-    where\n-        K: Borrow<Q>,\n-    {\n-        FxHashMap::contains_key(self, k)\n-    }\n-\n-    #[inline(always)]\n-    fn insert(&mut self, k: K, v: V) -> Option<V> {\n-        FxHashMap::insert(self, k, v)\n-    }\n-\n-    #[inline(always)]\n-    fn remove<Q: ?Sized + Hash + Eq>(&mut self, k: &Q) -> Option<V>\n-    where\n-        K: Borrow<Q>,\n-    {\n-        FxHashMap::remove(self, k)\n-    }\n-\n-    #[inline(always)]\n-    fn filter_map_collect<T>(&self, mut f: impl FnMut(&K, &V) -> Option<T>) -> Vec<T> {\n-        self.iter().filter_map(move |(k, v)| f(k, &*v)).collect()\n-    }\n-\n-    #[inline(always)]\n-    fn get_or<E>(&self, k: K, vacant: impl FnOnce() -> Result<V, E>) -> Result<&V, E> {\n-        match self.get(&k) {\n-            Some(v) => Ok(v),\n-            None => {\n-                vacant()?;\n-                bug!(\"The CTFE machine shouldn't ever need to extend the alloc_map when reading\")\n-            }\n-        }\n-    }\n-\n-    #[inline(always)]\n-    fn get_mut_or<E>(&mut self, k: K, vacant: impl FnOnce() -> Result<V, E>) -> Result<&mut V, E> {\n-        match self.entry(k) {\n-            Entry::Occupied(e) => Ok(e.into_mut()),\n-            Entry::Vacant(e) => {\n-                let v = vacant()?;\n-                Ok(e.insert(v))\n-            }\n-        }\n-    }\n-}\n-\n-crate type CompileTimeEvalContext<'mir, 'tcx> =\n-    InterpCx<'mir, 'tcx, CompileTimeInterpreter<'mir, 'tcx>>;\n-\n-impl interpret::MayLeak for ! {\n-    #[inline(always)]\n-    fn may_leak(self) -> bool {\n-        // `self` is uninhabited\n-        self\n-    }\n-}\n-\n-impl<'mir, 'tcx> interpret::Machine<'mir, 'tcx> for CompileTimeInterpreter<'mir, 'tcx> {\n-    type MemoryKinds = !;\n-    type PointerTag = ();\n-    type ExtraFnVal = !;\n-\n-    type FrameExtra = ();\n-    type MemoryExtra = MemoryExtra;\n-    type AllocExtra = ();\n-\n-    type MemoryMap = FxHashMap<AllocId, (MemoryKind<!>, Allocation)>;\n-\n-    const STATIC_KIND: Option<!> = None; // no copying of statics allowed\n-\n-    // We do not check for alignment to avoid having to carry an `Align`\n-    // in `ConstValue::ByRef`.\n-    const CHECK_ALIGN: bool = false;\n-\n-    #[inline(always)]\n-    fn enforce_validity(_ecx: &InterpCx<'mir, 'tcx, Self>) -> bool {\n-        false // for now, we don't enforce validity\n-    }\n-\n-    fn find_mir_or_eval_fn(\n-        ecx: &mut InterpCx<'mir, 'tcx, Self>,\n-        instance: ty::Instance<'tcx>,\n-        args: &[OpTy<'tcx>],\n-        ret: Option<(PlaceTy<'tcx>, mir::BasicBlock)>,\n-        _unwind: Option<mir::BasicBlock>, // unwinding is not supported in consts\n-    ) -> InterpResult<'tcx, Option<&'mir mir::Body<'tcx>>> {\n-        debug!(\"find_mir_or_eval_fn: {:?}\", instance);\n-\n-        // Only check non-glue functions\n-        if let ty::InstanceDef::Item(def_id) = instance.def {\n-            // Execution might have wandered off into other crates, so we cannot do a stability-\n-            // sensitive check here.  But we can at least rule out functions that are not const\n-            // at all.\n-            if ecx.tcx.is_const_fn_raw(def_id) {\n-                // If this function is a `const fn` then as an optimization we can query this\n-                // evaluation immediately.\n-                //\n-                // For the moment we only do this for functions which take no arguments\n-                // (or all arguments are ZSTs) so that we don't memoize too much.\n-                //\n-                // Because `#[track_caller]` adds an implicit non-ZST argument, we also cannot\n-                // perform this optimization on items tagged with it.\n-                let no_implicit_args = !instance.def.requires_caller_location(ecx.tcx());\n-                if args.iter().all(|a| a.layout.is_zst()) && no_implicit_args {\n-                    let gid = GlobalId { instance, promoted: None };\n-                    ecx.eval_const_fn_call(gid, ret)?;\n-                    return Ok(None);\n-                }\n-            } else {\n-                // Some functions we support even if they are non-const -- but avoid testing\n-                // that for const fn!  We certainly do *not* want to actually call the fn\n-                // though, so be sure we return here.\n-                return if ecx.hook_panic_fn(instance, args, ret)? {\n-                    Ok(None)\n-                } else {\n-                    throw_unsup_format!(\"calling non-const function `{}`\", instance)\n-                };\n-            }\n-        }\n-        // This is a const fn. Call it.\n-        Ok(Some(match ecx.load_mir(instance.def, None) {\n-            Ok(body) => *body,\n-            Err(err) => {\n-                if let err_unsup!(NoMirFor(ref path)) = err.kind {\n-                    return Err(ConstEvalError::NeedsRfc(format!(\n-                        \"calling extern function `{}`\",\n-                        path\n-                    ))\n-                    .into());\n-                }\n-                return Err(err);\n-            }\n-        }))\n-    }\n-\n-    fn call_extra_fn(\n-        _ecx: &mut InterpCx<'mir, 'tcx, Self>,\n-        fn_val: !,\n-        _args: &[OpTy<'tcx>],\n-        _ret: Option<(PlaceTy<'tcx>, mir::BasicBlock)>,\n-        _unwind: Option<mir::BasicBlock>,\n-    ) -> InterpResult<'tcx> {\n-        match fn_val {}\n-    }\n-\n-    fn call_intrinsic(\n-        ecx: &mut InterpCx<'mir, 'tcx, Self>,\n-        span: Span,\n-        instance: ty::Instance<'tcx>,\n-        args: &[OpTy<'tcx>],\n-        ret: Option<(PlaceTy<'tcx>, mir::BasicBlock)>,\n-        _unwind: Option<mir::BasicBlock>,\n-    ) -> InterpResult<'tcx> {\n-        if ecx.emulate_intrinsic(span, instance, args, ret)? {\n-            return Ok(());\n-        }\n-        // An intrinsic that we do not support\n-        let intrinsic_name = ecx.tcx.item_name(instance.def_id());\n-        Err(ConstEvalError::NeedsRfc(format!(\"calling intrinsic `{}`\", intrinsic_name)).into())\n-    }\n-\n-    fn assert_panic(\n-        ecx: &mut InterpCx<'mir, 'tcx, Self>,\n-        _span: Span,\n-        msg: &AssertMessage<'tcx>,\n-        _unwind: Option<mir::BasicBlock>,\n-    ) -> InterpResult<'tcx> {\n-        use rustc::mir::interpret::PanicInfo::*;\n-        Err(match msg {\n-            BoundsCheck { ref len, ref index } => {\n-                let len = ecx\n-                    .read_immediate(ecx.eval_operand(len, None)?)\n-                    .expect(\"can't eval len\")\n-                    .to_scalar()?\n-                    .to_machine_usize(&*ecx)?;\n-                let index = ecx\n-                    .read_immediate(ecx.eval_operand(index, None)?)\n-                    .expect(\"can't eval index\")\n-                    .to_scalar()?\n-                    .to_machine_usize(&*ecx)?;\n-                err_panic!(BoundsCheck { len, index })\n-            }\n-            Overflow(op) => err_panic!(Overflow(*op)),\n-            OverflowNeg => err_panic!(OverflowNeg),\n-            DivisionByZero => err_panic!(DivisionByZero),\n-            RemainderByZero => err_panic!(RemainderByZero),\n-            ResumedAfterReturn(generator_kind) => err_panic!(ResumedAfterReturn(*generator_kind)),\n-            ResumedAfterPanic(generator_kind) => err_panic!(ResumedAfterPanic(*generator_kind)),\n-            Panic { .. } => bug!(\"`Panic` variant cannot occur in MIR\"),\n-        }\n-        .into())\n-    }\n-\n-    fn ptr_to_int(_mem: &Memory<'mir, 'tcx, Self>, _ptr: Pointer) -> InterpResult<'tcx, u64> {\n-        Err(ConstEvalError::NeedsRfc(\"pointer-to-integer cast\".to_string()).into())\n-    }\n-\n-    fn binary_ptr_op(\n-        _ecx: &InterpCx<'mir, 'tcx, Self>,\n-        _bin_op: mir::BinOp,\n-        _left: ImmTy<'tcx>,\n-        _right: ImmTy<'tcx>,\n-    ) -> InterpResult<'tcx, (Scalar, bool, Ty<'tcx>)> {\n-        Err(ConstEvalError::NeedsRfc(\"pointer arithmetic or comparison\".to_string()).into())\n-    }\n-\n-    fn find_foreign_static(\n-        _tcx: TyCtxt<'tcx>,\n-        _def_id: DefId,\n-    ) -> InterpResult<'tcx, Cow<'tcx, Allocation<Self::PointerTag>>> {\n-        throw_unsup!(ReadForeignStatic)\n-    }\n-\n-    #[inline(always)]\n-    fn init_allocation_extra<'b>(\n-        _memory_extra: &MemoryExtra,\n-        _id: AllocId,\n-        alloc: Cow<'b, Allocation>,\n-        _kind: Option<MemoryKind<!>>,\n-    ) -> (Cow<'b, Allocation<Self::PointerTag>>, Self::PointerTag) {\n-        // We do not use a tag so we can just cheaply forward the allocation\n-        (alloc, ())\n-    }\n-\n-    #[inline(always)]\n-    fn tag_static_base_pointer(_memory_extra: &MemoryExtra, _id: AllocId) -> Self::PointerTag {\n-        ()\n-    }\n-\n-    fn box_alloc(\n-        _ecx: &mut InterpCx<'mir, 'tcx, Self>,\n-        _dest: PlaceTy<'tcx>,\n-    ) -> InterpResult<'tcx> {\n-        Err(ConstEvalError::NeedsRfc(\"heap allocations via `box` keyword\".to_string()).into())\n-    }\n-\n-    fn before_terminator(ecx: &mut InterpCx<'mir, 'tcx, Self>) -> InterpResult<'tcx> {\n-        {\n-            let steps = &mut ecx.machine.steps_since_detector_enabled;\n-\n-            *steps += 1;\n-            if *steps < 0 {\n-                return Ok(());\n-            }\n-\n-            *steps %= DETECTOR_SNAPSHOT_PERIOD;\n-            if *steps != 0 {\n-                return Ok(());\n-            }\n-        }\n-\n-        let span = ecx.frame().span;\n-        ecx.machine.loop_detector.observe_and_analyze(*ecx.tcx, span, &ecx.memory, &ecx.stack[..])\n-    }\n-\n-    #[inline(always)]\n-    fn stack_push(_ecx: &mut InterpCx<'mir, 'tcx, Self>) -> InterpResult<'tcx> {\n-        Ok(())\n-    }\n-\n-    fn before_access_static(\n-        memory_extra: &MemoryExtra,\n-        _allocation: &Allocation,\n-    ) -> InterpResult<'tcx> {\n-        if memory_extra.can_access_statics {\n-            Ok(())\n-        } else {\n-            Err(ConstEvalError::ConstAccessesStatic.into())\n-        }\n-    }\n-}\n-\n /// Extracts a field of a (variant of a) const.\n // this function uses `unwrap` copiously, because an already validated constant must have valid\n // fields and can thus never fail outside of compiler bugs"}, {"sha": "8948cc0fc3ea5b1132a89110a28e0fab7349270e", "filename": "src/librustc_mir/const_eval/error.rs", "status": "added", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/3e7fa3c6f22798d4228a0dc3ec50bdf185084d40/src%2Flibrustc_mir%2Fconst_eval%2Ferror.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e7fa3c6f22798d4228a0dc3ec50bdf185084d40/src%2Flibrustc_mir%2Fconst_eval%2Ferror.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fconst_eval%2Ferror.rs?ref=3e7fa3c6f22798d4228a0dc3ec50bdf185084d40", "patch": "@@ -0,0 +1,30 @@\n+use std::error::Error;\n+use std::fmt;\n+\n+use crate::interpret::InterpErrorInfo;\n+\n+#[derive(Clone, Debug)]\n+pub enum ConstEvalError {\n+    NeedsRfc(String),\n+    ConstAccessesStatic,\n+}\n+\n+impl<'tcx> Into<InterpErrorInfo<'tcx>> for ConstEvalError {\n+    fn into(self) -> InterpErrorInfo<'tcx> {\n+        err_unsup!(Unsupported(self.to_string())).into()\n+    }\n+}\n+\n+impl fmt::Display for ConstEvalError {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        use self::ConstEvalError::*;\n+        match *self {\n+            NeedsRfc(ref msg) => {\n+                write!(f, \"\\\"{}\\\" needs an rfc before being allowed inside constants\", msg)\n+            }\n+            ConstAccessesStatic => write!(f, \"constant accesses static\"),\n+        }\n+    }\n+}\n+\n+impl Error for ConstEvalError {}"}, {"sha": "0e3794ee3ab8854e615d83f43e13979f95fcb7ff", "filename": "src/librustc_mir/const_eval/machine.rs", "status": "added", "additions": 328, "deletions": 0, "changes": 328, "blob_url": "https://github.com/rust-lang/rust/blob/3e7fa3c6f22798d4228a0dc3ec50bdf185084d40/src%2Flibrustc_mir%2Fconst_eval%2Fmachine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e7fa3c6f22798d4228a0dc3ec50bdf185084d40/src%2Flibrustc_mir%2Fconst_eval%2Fmachine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fconst_eval%2Fmachine.rs?ref=3e7fa3c6f22798d4228a0dc3ec50bdf185084d40", "patch": "@@ -0,0 +1,328 @@\n+use rustc::hir::def_id::DefId;\n+use rustc::mir;\n+use rustc::ty::layout::HasTyCtxt;\n+use rustc::ty::{self, Ty, TyCtxt};\n+use std::borrow::{Borrow, Cow};\n+use std::collections::hash_map::Entry;\n+use std::hash::Hash;\n+\n+use rustc_data_structures::fx::FxHashMap;\n+\n+use syntax::source_map::Span;\n+\n+use crate::interpret::{\n+    self, snapshot, AllocId, Allocation, AssertMessage, GlobalId, ImmTy, InterpCx, InterpResult,\n+    Memory, MemoryKind, OpTy, PlaceTy, Pointer, Scalar,\n+};\n+\n+use super::error::*;\n+\n+/// Number of steps until the detector even starts doing anything.\n+/// Also, a warning is shown to the user when this number is reached.\n+const STEPS_UNTIL_DETECTOR_ENABLED: isize = 1_000_000;\n+/// The number of steps between loop detector snapshots.\n+/// Should be a power of two for performance reasons.\n+const DETECTOR_SNAPSHOT_PERIOD: isize = 256;\n+\n+// Extra machine state for CTFE, and the Machine instance\n+pub struct CompileTimeInterpreter<'mir, 'tcx> {\n+    /// When this value is negative, it indicates the number of interpreter\n+    /// steps *until* the loop detector is enabled. When it is positive, it is\n+    /// the number of steps after the detector has been enabled modulo the loop\n+    /// detector period.\n+    pub(super) steps_since_detector_enabled: isize,\n+\n+    /// Extra state to detect loops.\n+    pub(super) loop_detector: snapshot::InfiniteLoopDetector<'mir, 'tcx>,\n+}\n+\n+#[derive(Copy, Clone, Debug)]\n+pub struct MemoryExtra {\n+    /// Whether this machine may read from statics\n+    can_access_statics: bool,\n+}\n+\n+impl<'mir, 'tcx> CompileTimeInterpreter<'mir, 'tcx> {\n+    fn new() -> Self {\n+        CompileTimeInterpreter {\n+            loop_detector: Default::default(),\n+            steps_since_detector_enabled: -STEPS_UNTIL_DETECTOR_ENABLED,\n+        }\n+    }\n+}\n+\n+impl<K: Hash + Eq, V> interpret::AllocMap<K, V> for FxHashMap<K, V> {\n+    #[inline(always)]\n+    fn contains_key<Q: ?Sized + Hash + Eq>(&mut self, k: &Q) -> bool\n+    where\n+        K: Borrow<Q>,\n+    {\n+        FxHashMap::contains_key(self, k)\n+    }\n+\n+    #[inline(always)]\n+    fn insert(&mut self, k: K, v: V) -> Option<V> {\n+        FxHashMap::insert(self, k, v)\n+    }\n+\n+    #[inline(always)]\n+    fn remove<Q: ?Sized + Hash + Eq>(&mut self, k: &Q) -> Option<V>\n+    where\n+        K: Borrow<Q>,\n+    {\n+        FxHashMap::remove(self, k)\n+    }\n+\n+    #[inline(always)]\n+    fn filter_map_collect<T>(&self, mut f: impl FnMut(&K, &V) -> Option<T>) -> Vec<T> {\n+        self.iter().filter_map(move |(k, v)| f(k, &*v)).collect()\n+    }\n+\n+    #[inline(always)]\n+    fn get_or<E>(&self, k: K, vacant: impl FnOnce() -> Result<V, E>) -> Result<&V, E> {\n+        match self.get(&k) {\n+            Some(v) => Ok(v),\n+            None => {\n+                vacant()?;\n+                bug!(\"The CTFE machine shouldn't ever need to extend the alloc_map when reading\")\n+            }\n+        }\n+    }\n+\n+    #[inline(always)]\n+    fn get_mut_or<E>(&mut self, k: K, vacant: impl FnOnce() -> Result<V, E>) -> Result<&mut V, E> {\n+        match self.entry(k) {\n+            Entry::Occupied(e) => Ok(e.into_mut()),\n+            Entry::Vacant(e) => {\n+                let v = vacant()?;\n+                Ok(e.insert(v))\n+            }\n+        }\n+    }\n+}\n+\n+crate type CompileTimeEvalContext<'mir, 'tcx> =\n+    InterpCx<'mir, 'tcx, CompileTimeInterpreter<'mir, 'tcx>>;\n+\n+impl interpret::MayLeak for ! {\n+    #[inline(always)]\n+    fn may_leak(self) -> bool {\n+        // `self` is uninhabited\n+        self\n+    }\n+}\n+\n+impl<'mir, 'tcx> interpret::Machine<'mir, 'tcx> for CompileTimeInterpreter<'mir, 'tcx> {\n+    type MemoryKinds = !;\n+    type PointerTag = ();\n+    type ExtraFnVal = !;\n+\n+    type FrameExtra = ();\n+    type MemoryExtra = MemoryExtra;\n+    type AllocExtra = ();\n+\n+    type MemoryMap = FxHashMap<AllocId, (MemoryKind<!>, Allocation)>;\n+\n+    const STATIC_KIND: Option<!> = None; // no copying of statics allowed\n+\n+    // We do not check for alignment to avoid having to carry an `Align`\n+    // in `ConstValue::ByRef`.\n+    const CHECK_ALIGN: bool = false;\n+\n+    #[inline(always)]\n+    fn enforce_validity(_ecx: &InterpCx<'mir, 'tcx, Self>) -> bool {\n+        false // for now, we don't enforce validity\n+    }\n+\n+    fn find_mir_or_eval_fn(\n+        ecx: &mut InterpCx<'mir, 'tcx, Self>,\n+        instance: ty::Instance<'tcx>,\n+        args: &[OpTy<'tcx>],\n+        ret: Option<(PlaceTy<'tcx>, mir::BasicBlock)>,\n+        _unwind: Option<mir::BasicBlock>, // unwinding is not supported in consts\n+    ) -> InterpResult<'tcx, Option<&'mir mir::Body<'tcx>>> {\n+        debug!(\"find_mir_or_eval_fn: {:?}\", instance);\n+\n+        // Only check non-glue functions\n+        if let ty::InstanceDef::Item(def_id) = instance.def {\n+            // Execution might have wandered off into other crates, so we cannot do a stability-\n+            // sensitive check here.  But we can at least rule out functions that are not const\n+            // at all.\n+            if ecx.tcx.is_const_fn_raw(def_id) {\n+                // If this function is a `const fn` then as an optimization we can query this\n+                // evaluation immediately.\n+                //\n+                // For the moment we only do this for functions which take no arguments\n+                // (or all arguments are ZSTs) so that we don't memoize too much.\n+                //\n+                // Because `#[track_caller]` adds an implicit non-ZST argument, we also cannot\n+                // perform this optimization on items tagged with it.\n+                let no_implicit_args = !instance.def.requires_caller_location(ecx.tcx());\n+                if args.iter().all(|a| a.layout.is_zst()) && no_implicit_args {\n+                    let gid = GlobalId { instance, promoted: None };\n+                    ecx.eval_const_fn_call(gid, ret)?;\n+                    return Ok(None);\n+                }\n+            } else {\n+                // Some functions we support even if they are non-const -- but avoid testing\n+                // that for const fn!  We certainly do *not* want to actually call the fn\n+                // though, so be sure we return here.\n+                return if ecx.hook_panic_fn(instance, args, ret)? {\n+                    Ok(None)\n+                } else {\n+                    throw_unsup_format!(\"calling non-const function `{}`\", instance)\n+                };\n+            }\n+        }\n+        // This is a const fn. Call it.\n+        Ok(Some(match ecx.load_mir(instance.def, None) {\n+            Ok(body) => *body,\n+            Err(err) => {\n+                if let err_unsup!(NoMirFor(ref path)) = err.kind {\n+                    return Err(ConstEvalError::NeedsRfc(format!(\n+                        \"calling extern function `{}`\",\n+                        path\n+                    ))\n+                    .into());\n+                }\n+                return Err(err);\n+            }\n+        }))\n+    }\n+\n+    fn call_extra_fn(\n+        _ecx: &mut InterpCx<'mir, 'tcx, Self>,\n+        fn_val: !,\n+        _args: &[OpTy<'tcx>],\n+        _ret: Option<(PlaceTy<'tcx>, mir::BasicBlock)>,\n+        _unwind: Option<mir::BasicBlock>,\n+    ) -> InterpResult<'tcx> {\n+        match fn_val {}\n+    }\n+\n+    fn call_intrinsic(\n+        ecx: &mut InterpCx<'mir, 'tcx, Self>,\n+        span: Span,\n+        instance: ty::Instance<'tcx>,\n+        args: &[OpTy<'tcx>],\n+        ret: Option<(PlaceTy<'tcx>, mir::BasicBlock)>,\n+        _unwind: Option<mir::BasicBlock>,\n+    ) -> InterpResult<'tcx> {\n+        if ecx.emulate_intrinsic(span, instance, args, ret)? {\n+            return Ok(());\n+        }\n+        // An intrinsic that we do not support\n+        let intrinsic_name = ecx.tcx.item_name(instance.def_id());\n+        Err(ConstEvalError::NeedsRfc(format!(\"calling intrinsic `{}`\", intrinsic_name)).into())\n+    }\n+\n+    fn assert_panic(\n+        ecx: &mut InterpCx<'mir, 'tcx, Self>,\n+        _span: Span,\n+        msg: &AssertMessage<'tcx>,\n+        _unwind: Option<mir::BasicBlock>,\n+    ) -> InterpResult<'tcx> {\n+        use rustc::mir::interpret::PanicInfo::*;\n+        Err(match msg {\n+            BoundsCheck { ref len, ref index } => {\n+                let len = ecx\n+                    .read_immediate(ecx.eval_operand(len, None)?)\n+                    .expect(\"can't eval len\")\n+                    .to_scalar()?\n+                    .to_machine_usize(&*ecx)?;\n+                let index = ecx\n+                    .read_immediate(ecx.eval_operand(index, None)?)\n+                    .expect(\"can't eval index\")\n+                    .to_scalar()?\n+                    .to_machine_usize(&*ecx)?;\n+                err_panic!(BoundsCheck { len, index })\n+            }\n+            Overflow(op) => err_panic!(Overflow(*op)),\n+            OverflowNeg => err_panic!(OverflowNeg),\n+            DivisionByZero => err_panic!(DivisionByZero),\n+            RemainderByZero => err_panic!(RemainderByZero),\n+            ResumedAfterReturn(generator_kind) => err_panic!(ResumedAfterReturn(*generator_kind)),\n+            ResumedAfterPanic(generator_kind) => err_panic!(ResumedAfterPanic(*generator_kind)),\n+            Panic { .. } => bug!(\"`Panic` variant cannot occur in MIR\"),\n+        }\n+        .into())\n+    }\n+\n+    fn ptr_to_int(_mem: &Memory<'mir, 'tcx, Self>, _ptr: Pointer) -> InterpResult<'tcx, u64> {\n+        Err(ConstEvalError::NeedsRfc(\"pointer-to-integer cast\".to_string()).into())\n+    }\n+\n+    fn binary_ptr_op(\n+        _ecx: &InterpCx<'mir, 'tcx, Self>,\n+        _bin_op: mir::BinOp,\n+        _left: ImmTy<'tcx>,\n+        _right: ImmTy<'tcx>,\n+    ) -> InterpResult<'tcx, (Scalar, bool, Ty<'tcx>)> {\n+        Err(ConstEvalError::NeedsRfc(\"pointer arithmetic or comparison\".to_string()).into())\n+    }\n+\n+    fn find_foreign_static(\n+        _tcx: TyCtxt<'tcx>,\n+        _def_id: DefId,\n+    ) -> InterpResult<'tcx, Cow<'tcx, Allocation<Self::PointerTag>>> {\n+        throw_unsup!(ReadForeignStatic)\n+    }\n+\n+    #[inline(always)]\n+    fn init_allocation_extra<'b>(\n+        _memory_extra: &MemoryExtra,\n+        _id: AllocId,\n+        alloc: Cow<'b, Allocation>,\n+        _kind: Option<MemoryKind<!>>,\n+    ) -> (Cow<'b, Allocation<Self::PointerTag>>, Self::PointerTag) {\n+        // We do not use a tag so we can just cheaply forward the allocation\n+        (alloc, ())\n+    }\n+\n+    #[inline(always)]\n+    fn tag_static_base_pointer(_memory_extra: &MemoryExtra, _id: AllocId) -> Self::PointerTag {\n+        ()\n+    }\n+\n+    fn box_alloc(\n+        _ecx: &mut InterpCx<'mir, 'tcx, Self>,\n+        _dest: PlaceTy<'tcx>,\n+    ) -> InterpResult<'tcx> {\n+        Err(ConstEvalError::NeedsRfc(\"heap allocations via `box` keyword\".to_string()).into())\n+    }\n+\n+    fn before_terminator(ecx: &mut InterpCx<'mir, 'tcx, Self>) -> InterpResult<'tcx> {\n+        {\n+            let steps = &mut ecx.machine.steps_since_detector_enabled;\n+\n+            *steps += 1;\n+            if *steps < 0 {\n+                return Ok(());\n+            }\n+\n+            *steps %= DETECTOR_SNAPSHOT_PERIOD;\n+            if *steps != 0 {\n+                return Ok(());\n+            }\n+        }\n+\n+        let span = ecx.frame().span;\n+        ecx.machine.loop_detector.observe_and_analyze(*ecx.tcx, span, &ecx.memory, &ecx.stack[..])\n+    }\n+\n+    #[inline(always)]\n+    fn stack_push(_ecx: &mut InterpCx<'mir, 'tcx, Self>) -> InterpResult<'tcx> {\n+        Ok(())\n+    }\n+\n+    fn before_access_static(\n+        memory_extra: &MemoryExtra,\n+        _allocation: &Allocation,\n+    ) -> InterpResult<'tcx> {\n+        if memory_extra.can_access_statics {\n+            Ok(())\n+        } else {\n+            Err(ConstEvalError::ConstAccessesStatic.into())\n+        }\n+    }\n+}"}]}