{"sha": "587b86377283ba7df557b506a9b5ed4ef00e175a", "node_id": "MDY6Q29tbWl0NzI0NzEyOjU4N2I4NjM3NzI4M2JhN2RmNTU3YjUwNmE5YjVlZDRlZjAwZTE3NWE=", "commit": {"author": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2011-09-07T23:17:06Z"}, "committer": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2011-09-12T00:31:38Z"}, "message": "Zero locals that have initializers that might fail\n\nThis will avoid running cleanups on uninitialized memory\n\nIssue #236", "tree": {"sha": "350494955065f582791ecd9ea8573b3124b9a605", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/350494955065f582791ecd9ea8573b3124b9a605"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/587b86377283ba7df557b506a9b5ed4ef00e175a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/587b86377283ba7df557b506a9b5ed4ef00e175a", "html_url": "https://github.com/rust-lang/rust/commit/587b86377283ba7df557b506a9b5ed4ef00e175a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/587b86377283ba7df557b506a9b5ed4ef00e175a/comments", "author": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "committer": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4eb3ce32801ddd9ad335bc82f70f245c5f3c797a", "url": "https://api.github.com/repos/rust-lang/rust/commits/4eb3ce32801ddd9ad335bc82f70f245c5f3c797a", "html_url": "https://github.com/rust-lang/rust/commit/4eb3ce32801ddd9ad335bc82f70f245c5f3c797a"}], "stats": {"total": 51, "additions": 27, "deletions": 24}, "files": [{"sha": "f90c5a15fb089e26bc3614639c453129d714cbc8", "filename": "src/comp/middle/trans.rs", "status": "modified", "additions": 27, "deletions": 24, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/587b86377283ba7df557b506a9b5ed4ef00e175a/src%2Fcomp%2Fmiddle%2Ftrans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/587b86377283ba7df557b506a9b5ed4ef00e175a/src%2Fcomp%2Fmiddle%2Ftrans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans.rs?ref=587b86377283ba7df557b506a9b5ed4ef00e175a", "patch": "@@ -4447,7 +4447,9 @@ fn init_local(bcx: @block_ctxt, local: &@ast::local) -> result {\n     // Make a note to drop this slot on the way out.\n     add_clean(bcx, llptr, ty);\n \n-    if must_zero(local) { bcx = zero_alloca(bcx, llptr, ty).bcx; }\n+    if must_zero(bcx_ccx(bcx), local) {\n+        bcx = zero_alloca(bcx, llptr, ty).bcx;\n+    }\n \n     alt local.node.init {\n       some(init) {\n@@ -4473,36 +4475,37 @@ fn init_local(bcx: @block_ctxt, local: &@ast::local) -> result {\n                                         bcx.fcx.lllocals, false);\n     ret rslt(bcx, llptr);\n \n-    fn must_zero(local: &@ast::local) -> bool {\n+    fn must_zero(ccx: &@crate_ctxt, local: &@ast::local) -> bool {\n         alt local.node.init {\n-          some(init) { might_not_init(init.expr) }\n+          some(init) { might_not_init(ccx, init.expr) }\n           none. { true }\n         }\n     }\n \n-    fn might_not_init(expr: &@ast::expr) -> bool {\n-        type env = @mutable bool;\n-        let e = @mutable false;\n-        // FIXME: Probably also need to account for expressions that\n-        // fail but since we don't unwind yet, it doesn't seem to be a\n-        // problem\n+    fn might_not_init(ccx: &@crate_ctxt, expr: &@ast::expr) -> bool {\n+        type env = {mutable mightnt: bool,\n+                    ccx: @crate_ctxt};\n+        let e = {mutable mightnt: false,\n+                 ccx: ccx};\n+        fn visit_expr(ex: &@ast::expr, e: &env, v: &vt<env>) {\n+            let might_not_init = alt ex.node {\n+              ast::expr_ret(_) { true }\n+              ast::expr_break. { true }\n+              ast::expr_cont. { true }\n+              _ {\n+                let ex_ty = ty::expr_ty(e.ccx.tcx, ex);\n+                ty::type_is_bot(e.ccx.tcx, ex_ty)\n+              }\n+            };\n+            if might_not_init {\n+                e.mightnt = true;\n+            } else { visit::visit_expr(ex, e, v); }\n+        }\n         let visitor =\n-            visit::mk_vt(\n-                         @{visit_expr:\n-                               fn (ex: &@ast::expr, e: &env, v: &vt<env>) {\n-                                   let might_not_init =\n-                                       alt ex.node {\n-                                         ast::expr_ret(_) { true }\n-                                         ast::expr_break. { true }\n-                                         ast::expr_cont. { true }\n-                                         _ { false }\n-                                       };\n-                                   if might_not_init {\n-                                       *e = true;\n-                                   } else { visit::visit_expr(ex, e, v); }\n-                               } with *visit::default_visitor()});\n+            visit::mk_vt(@{visit_expr: visit_expr\n+                           with *visit::default_visitor()});\n         visitor.visit_expr(expr, e, visitor);\n-        ret *e;\n+        ret e.mightnt;\n     }\n }\n "}]}