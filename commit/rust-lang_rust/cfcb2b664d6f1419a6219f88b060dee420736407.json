{"sha": "cfcb2b664d6f1419a6219f88b060dee420736407", "node_id": "MDY6Q29tbWl0NzI0NzEyOmNmY2IyYjY2NGQ2ZjE0MTlhNjIxOWY4OGIwNjBkZWU0MjA3MzY0MDc=", "commit": {"author": {"name": "Simonas Kazlauskas", "email": "git@kazlauskas.me", "date": "2021-06-13T19:06:11Z"}, "committer": {"name": "Simonas Kazlauskas", "email": "git@kazlauskas.me", "date": "2021-06-24T20:13:08Z"}, "message": "compiletest: ignore tests on a per-revision basis\n\nOtherwise something that ought to seemingly work like `//[x86]\nneeds-llvm-components: x86` or `//[nll_beyond]should-fail` do not get\nevaluated properly.", "tree": {"sha": "a5388c98051df9a0a1bd384e11d8b08b53601445", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a5388c98051df9a0a1bd384e11d8b08b53601445"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/cfcb2b664d6f1419a6219f88b060dee420736407", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/cfcb2b664d6f1419a6219f88b060dee420736407", "html_url": "https://github.com/rust-lang/rust/commit/cfcb2b664d6f1419a6219f88b060dee420736407", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/cfcb2b664d6f1419a6219f88b060dee420736407/comments", "author": {"login": "nagisa", "id": 679122, "node_id": "MDQ6VXNlcjY3OTEyMg==", "avatar_url": "https://avatars.githubusercontent.com/u/679122?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nagisa", "html_url": "https://github.com/nagisa", "followers_url": "https://api.github.com/users/nagisa/followers", "following_url": "https://api.github.com/users/nagisa/following{/other_user}", "gists_url": "https://api.github.com/users/nagisa/gists{/gist_id}", "starred_url": "https://api.github.com/users/nagisa/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nagisa/subscriptions", "organizations_url": "https://api.github.com/users/nagisa/orgs", "repos_url": "https://api.github.com/users/nagisa/repos", "events_url": "https://api.github.com/users/nagisa/events{/privacy}", "received_events_url": "https://api.github.com/users/nagisa/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nagisa", "id": 679122, "node_id": "MDQ6VXNlcjY3OTEyMg==", "avatar_url": "https://avatars.githubusercontent.com/u/679122?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nagisa", "html_url": "https://github.com/nagisa", "followers_url": "https://api.github.com/users/nagisa/followers", "following_url": "https://api.github.com/users/nagisa/following{/other_user}", "gists_url": "https://api.github.com/users/nagisa/gists{/gist_id}", "starred_url": "https://api.github.com/users/nagisa/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nagisa/subscriptions", "organizations_url": "https://api.github.com/users/nagisa/orgs", "repos_url": "https://api.github.com/users/nagisa/repos", "events_url": "https://api.github.com/users/nagisa/events{/privacy}", "received_events_url": "https://api.github.com/users/nagisa/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "493fe8008b33c576240bfa6979760e0e5482d5af", "url": "https://api.github.com/repos/rust-lang/rust/commits/493fe8008b33c576240bfa6979760e0e5482d5af", "html_url": "https://github.com/rust-lang/rust/commit/493fe8008b33c576240bfa6979760e0e5482d5af"}], "stats": {"total": 740, "additions": 357, "deletions": 383}, "files": [{"sha": "bf6ea6b67f9bbfbc63b898c135fa0fd94f19e057", "filename": "src/test/ui/asm/inline-syntax.arm.stderr", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/cfcb2b664d6f1419a6219f88b060dee420736407/src%2Ftest%2Fui%2Fasm%2Finline-syntax.arm.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/cfcb2b664d6f1419a6219f88b060dee420736407/src%2Ftest%2Fui%2Fasm%2Finline-syntax.arm.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasm%2Finline-syntax.arm.stderr?ref=cfcb2b664d6f1419a6219f88b060dee420736407", "patch": "@@ -13,7 +13,7 @@ LL | .intel_syntax noprefix\n    | ^\n \n error: unknown directive\n-  --> $DIR/inline-syntax.rs:29:15\n+  --> $DIR/inline-syntax.rs:31:15\n    |\n LL |         asm!(\".intel_syntax noprefix\", \"nop\");\n    |               ^\n@@ -25,7 +25,7 @@ LL |     .intel_syntax noprefix\n    |     ^\n \n error: unknown directive\n-  --> $DIR/inline-syntax.rs:32:15\n+  --> $DIR/inline-syntax.rs:34:15\n    |\n LL |         asm!(\".intel_syntax aaa noprefix\", \"nop\");\n    |               ^\n@@ -37,7 +37,7 @@ LL |     .intel_syntax aaa noprefix\n    |     ^\n \n error: unknown directive\n-  --> $DIR/inline-syntax.rs:35:15\n+  --> $DIR/inline-syntax.rs:37:15\n    |\n LL |         asm!(\".att_syntax noprefix\", \"nop\");\n    |               ^\n@@ -49,7 +49,7 @@ LL |     .att_syntax noprefix\n    |     ^\n \n error: unknown directive\n-  --> $DIR/inline-syntax.rs:38:15\n+  --> $DIR/inline-syntax.rs:40:15\n    |\n LL |         asm!(\".att_syntax bbb noprefix\", \"nop\");\n    |               ^\n@@ -61,7 +61,7 @@ LL |     .att_syntax bbb noprefix\n    |     ^\n \n error: unknown directive\n-  --> $DIR/inline-syntax.rs:41:15\n+  --> $DIR/inline-syntax.rs:43:15\n    |\n LL |         asm!(\".intel_syntax noprefix; nop\");\n    |               ^\n@@ -73,7 +73,7 @@ LL |     .intel_syntax noprefix; nop\n    |     ^\n \n error: unknown directive\n-  --> $DIR/inline-syntax.rs:47:13\n+  --> $DIR/inline-syntax.rs:49:13\n    |\n LL |             .intel_syntax noprefix\n    |             ^"}, {"sha": "dcbc17bb26089380e71045b68fde32f27a55978b", "filename": "src/test/ui/asm/inline-syntax.x86_64.stderr", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/cfcb2b664d6f1419a6219f88b060dee420736407/src%2Ftest%2Fui%2Fasm%2Finline-syntax.x86_64.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/cfcb2b664d6f1419a6219f88b060dee420736407/src%2Ftest%2Fui%2Fasm%2Finline-syntax.x86_64.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasm%2Finline-syntax.x86_64.stderr?ref=cfcb2b664d6f1419a6219f88b060dee420736407", "patch": "@@ -1,43 +1,43 @@\n warning: avoid using `.intel_syntax`, Intel syntax is the default\n-  --> $DIR/inline-syntax.rs:55:14\n+  --> $DIR/inline-syntax.rs:57:14\n    |\n LL | global_asm!(\".intel_syntax noprefix\", \"nop\");\n    |              ^^^^^^^^^^^^^^^^^^^^^^\n    |\n    = note: `#[warn(bad_asm_style)]` on by default\n \n warning: avoid using `.intel_syntax`, Intel syntax is the default\n-  --> $DIR/inline-syntax.rs:29:15\n+  --> $DIR/inline-syntax.rs:31:15\n    |\n LL |         asm!(\".intel_syntax noprefix\", \"nop\");\n    |               ^^^^^^^^^^^^^^^^^^^^^^\n \n warning: avoid using `.intel_syntax`, Intel syntax is the default\n-  --> $DIR/inline-syntax.rs:32:15\n+  --> $DIR/inline-syntax.rs:34:15\n    |\n LL |         asm!(\".intel_syntax aaa noprefix\", \"nop\");\n    |               ^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n warning: avoid using `.att_syntax`, prefer using `options(att_syntax)` instead\n-  --> $DIR/inline-syntax.rs:35:15\n+  --> $DIR/inline-syntax.rs:37:15\n    |\n LL |         asm!(\".att_syntax noprefix\", \"nop\");\n    |               ^^^^^^^^^^^^^^^^^^^^\n \n warning: avoid using `.att_syntax`, prefer using `options(att_syntax)` instead\n-  --> $DIR/inline-syntax.rs:38:15\n+  --> $DIR/inline-syntax.rs:40:15\n    |\n LL |         asm!(\".att_syntax bbb noprefix\", \"nop\");\n    |               ^^^^^^^^^^^^^^^^^^^^^^^^\n \n warning: avoid using `.intel_syntax`, Intel syntax is the default\n-  --> $DIR/inline-syntax.rs:41:15\n+  --> $DIR/inline-syntax.rs:43:15\n    |\n LL |         asm!(\".intel_syntax noprefix; nop\");\n    |               ^^^^^^^^^^^^^^^^^^^^^^\n \n warning: avoid using `.intel_syntax`, Intel syntax is the default\n-  --> $DIR/inline-syntax.rs:47:13\n+  --> $DIR/inline-syntax.rs:49:13\n    |\n LL |             .intel_syntax noprefix\n    |             ^^^^^^^^^^^^^^^^^^^^^^"}, {"sha": "50248a55838f2a5e993b121daa4702a34fc58c44", "filename": "src/test/ui/borrowck/two-phase-reservation-sharing-interference.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/cfcb2b664d6f1419a6219f88b060dee420736407/src%2Ftest%2Fui%2Fborrowck%2Ftwo-phase-reservation-sharing-interference.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cfcb2b664d6f1419a6219f88b060dee420736407/src%2Ftest%2Fui%2Fborrowck%2Ftwo-phase-reservation-sharing-interference.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fborrowck%2Ftwo-phase-reservation-sharing-interference.rs?ref=cfcb2b664d6f1419a6219f88b060dee420736407", "patch": "@@ -1,8 +1,8 @@\n // revisions: nll_target\n \n-// The following revisions are disabled due to missing support from two-phase beyond autorefs\n+// The nll_beyond revision is disabled due to missing support from two-phase beyond autorefs\n //[nll_beyond]compile-flags: -Z borrowck=mir -Z two-phase-beyond-autoref\n-//[nll_beyond] should-fail\n+//[nll_beyond]should-fail\n \n //[nll_target]compile-flags: -Z borrowck=mir\n "}, {"sha": "9e4521df8c34f4d84c065af641cf79abad1f29e8", "filename": "src/test/ui/cmse-nonsecure/cmse-nonsecure-call/params-on-registers.rs", "status": "modified", "additions": 11, "deletions": 3, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/cfcb2b664d6f1419a6219f88b060dee420736407/src%2Ftest%2Fui%2Fcmse-nonsecure%2Fcmse-nonsecure-call%2Fparams-on-registers.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cfcb2b664d6f1419a6219f88b060dee420736407/src%2Ftest%2Fui%2Fcmse-nonsecure%2Fcmse-nonsecure-call%2Fparams-on-registers.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fcmse-nonsecure%2Fcmse-nonsecure-call%2Fparams-on-registers.rs?ref=cfcb2b664d6f1419a6219f88b060dee420736407", "patch": "@@ -1,13 +1,21 @@\n // build-pass\n // compile-flags: --target thumbv8m.main-none-eabi --crate-type lib\n // needs-llvm-components: arm\n-#![feature(abi_c_cmse_nonsecure_call)]\n-#![no_std]\n+#![feature(abi_c_cmse_nonsecure_call, no_core, lang_items, intrinsics)]\n+#![no_core]\n+#[lang=\"sized\"]\n+pub trait Sized { }\n+#[lang=\"copy\"]\n+pub trait Copy { }\n+\n+extern \"rust-intrinsic\" {\n+    pub fn transmute<T, U>(e: T) -> U;\n+}\n \n #[no_mangle]\n pub fn test(a: u32, b: u32, c: u32, d: u32) -> u32 {\n     let non_secure_function = unsafe {\n-        core::mem::transmute::<usize, extern \"C-cmse-nonsecure-call\" fn(u32, u32, u32, u32) -> u32>(\n+        transmute::<usize, extern \"C-cmse-nonsecure-call\" fn(u32, u32, u32, u32) -> u32>(\n             0x10000004,\n         )\n     };"}, {"sha": "9697146d5c3d83623b7d2390bf07de83f65bb447", "filename": "src/test/ui/cmse-nonsecure/cmse-nonsecure-call/params-on-stack.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/cfcb2b664d6f1419a6219f88b060dee420736407/src%2Ftest%2Fui%2Fcmse-nonsecure%2Fcmse-nonsecure-call%2Fparams-on-stack.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cfcb2b664d6f1419a6219f88b060dee420736407/src%2Ftest%2Fui%2Fcmse-nonsecure%2Fcmse-nonsecure-call%2Fparams-on-stack.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fcmse-nonsecure%2Fcmse-nonsecure-call%2Fparams-on-stack.rs?ref=cfcb2b664d6f1419a6219f88b060dee420736407", "patch": "@@ -1,3 +1,4 @@\n+// build-fail\n // compile-flags: --target thumbv8m.main-none-eabi --crate-type lib\n // needs-llvm-components: arm\n // min-llvm-version: 11.0\n@@ -15,7 +16,7 @@ extern \"rust-intrinsic\" {\n #[no_mangle]\n pub fn test(a: u32, b: u32, c: u32, d: u32, e: u32) -> u32 {\n     let non_secure_function = unsafe {\n-        core::mem::transmute::<\n+        transmute::<\n             usize,\n             extern \"C-cmse-nonsecure-call\" fn(u32, u32, u32, u32, u32) -> u32>\n         ("}, {"sha": "f32b3709002e6c2db959b33f3b7b5e16381744f4", "filename": "src/test/ui/cmse-nonsecure/cmse-nonsecure-call/wrong-abi-location-1.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/cfcb2b664d6f1419a6219f88b060dee420736407/src%2Ftest%2Fui%2Fcmse-nonsecure%2Fcmse-nonsecure-call%2Fwrong-abi-location-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cfcb2b664d6f1419a6219f88b060dee420736407/src%2Ftest%2Fui%2Fcmse-nonsecure%2Fcmse-nonsecure-call%2Fwrong-abi-location-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fcmse-nonsecure%2Fcmse-nonsecure-call%2Fwrong-abi-location-1.rs?ref=cfcb2b664d6f1419a6219f88b060dee420736407", "patch": "@@ -1,6 +1,8 @@\n // compile-flags: --target thumbv8m.main-none-eabi --crate-type lib\n // needs-llvm-components: arm\n-#![feature(abi_c_cmse_nonsecure_call)]\n-#![no_std]\n+#![feature(abi_c_cmse_nonsecure_call, lang_items, no_core)]\n+#![no_core]\n+#[lang=\"sized\"]\n+trait Sized { }\n \n pub extern \"C-cmse-nonsecure-call\" fn test() {} //~ ERROR [E0781]"}, {"sha": "3564ab4b6cd4dd76241a6de8bac0f96d8d5516fe", "filename": "src/test/ui/cmse-nonsecure/cmse-nonsecure-call/wrong-abi-location-1.stderr", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/cfcb2b664d6f1419a6219f88b060dee420736407/src%2Ftest%2Fui%2Fcmse-nonsecure%2Fcmse-nonsecure-call%2Fwrong-abi-location-1.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/cfcb2b664d6f1419a6219f88b060dee420736407/src%2Ftest%2Fui%2Fcmse-nonsecure%2Fcmse-nonsecure-call%2Fwrong-abi-location-1.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fcmse-nonsecure%2Fcmse-nonsecure-call%2Fwrong-abi-location-1.stderr?ref=cfcb2b664d6f1419a6219f88b060dee420736407", "patch": "@@ -1,8 +1,8 @@\n-error[E0781]: the `\"cmse-nonsecure-call\"` ABI is only allowed on function pointers.\n-  --> $DIR/wrong-abi-location-1.rs:6:1\n+error[E0781]: the `\"C-cmse-nonsecure-call\"` ABI is only allowed on function pointers.\n+  --> $DIR/wrong-abi-location-1.rs:8:1\n    |\n-LL | pub extern \"C-cmse-nonsecure-call\" fn test() {} //~ ERROR [E0781]\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+LL | pub extern \"C-cmse-nonsecure-call\" fn test() {}\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: aborting due to previous error\n "}, {"sha": "6f8bb24aa69e84f120992167cb011b87e052fc0c", "filename": "src/test/ui/cmse-nonsecure/cmse-nonsecure-call/wrong-abi-location-2.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/cfcb2b664d6f1419a6219f88b060dee420736407/src%2Ftest%2Fui%2Fcmse-nonsecure%2Fcmse-nonsecure-call%2Fwrong-abi-location-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cfcb2b664d6f1419a6219f88b060dee420736407/src%2Ftest%2Fui%2Fcmse-nonsecure%2Fcmse-nonsecure-call%2Fwrong-abi-location-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fcmse-nonsecure%2Fcmse-nonsecure-call%2Fwrong-abi-location-2.rs?ref=cfcb2b664d6f1419a6219f88b060dee420736407", "patch": "@@ -1,7 +1,9 @@\n // compile-flags: --target thumbv8m.main-none-eabi --crate-type lib\n // needs-llvm-components: arm\n-#![feature(abi_c_cmse_nonsecure_call)]\n-#![no_std]\n+#![feature(abi_c_cmse_nonsecure_call, lang_items, no_core)]\n+#![no_core]\n+#[lang=\"sized\"]\n+trait Sized { }\n \n extern \"C-cmse-nonsecure-call\" { //~ ERROR [E0781]\n     fn test();"}, {"sha": "76073f548848a70bfaa1a47ab9c8ecefffbf7bff", "filename": "src/test/ui/cmse-nonsecure/cmse-nonsecure-call/wrong-abi-location-2.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/cfcb2b664d6f1419a6219f88b060dee420736407/src%2Ftest%2Fui%2Fcmse-nonsecure%2Fcmse-nonsecure-call%2Fwrong-abi-location-2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/cfcb2b664d6f1419a6219f88b060dee420736407/src%2Ftest%2Fui%2Fcmse-nonsecure%2Fcmse-nonsecure-call%2Fwrong-abi-location-2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fcmse-nonsecure%2Fcmse-nonsecure-call%2Fwrong-abi-location-2.stderr?ref=cfcb2b664d6f1419a6219f88b060dee420736407", "patch": "@@ -1,8 +1,8 @@\n error[E0781]: the `\"C-cmse-nonsecure-call\"` ABI is only allowed on function pointers.\n-  --> $DIR/wrong-abi-location-2.rs:6:1\n+  --> $DIR/wrong-abi-location-2.rs:8:1\n    |\n LL | / extern \"C-cmse-nonsecure-call\" {\n-LL | |     fn test(); //~ ERROR [E0781]\n+LL | |     fn test();\n LL | | }\n    | |_^\n "}, {"sha": "8cde9ba58b93b0a3e24c228cc01186d5074bd935", "filename": "src/test/ui/cmse-nonsecure/cmse-nonsecure-entry/params-on-registers.rs", "status": "modified", "additions": 8, "deletions": 4, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/cfcb2b664d6f1419a6219f88b060dee420736407/src%2Ftest%2Fui%2Fcmse-nonsecure%2Fcmse-nonsecure-entry%2Fparams-on-registers.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cfcb2b664d6f1419a6219f88b060dee420736407/src%2Ftest%2Fui%2Fcmse-nonsecure%2Fcmse-nonsecure-entry%2Fparams-on-registers.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fcmse-nonsecure%2Fcmse-nonsecure-entry%2Fparams-on-registers.rs?ref=cfcb2b664d6f1419a6219f88b060dee420736407", "patch": "@@ -1,11 +1,15 @@\n // build-pass\n // compile-flags: --target thumbv8m.main-none-eabi --crate-type lib\n // needs-llvm-components: arm\n-#![feature(cmse_nonsecure_entry)]\n-#![no_std]\n+#![feature(cmse_nonsecure_entry, no_core, lang_items)]\n+#![no_core]\n+#[lang=\"sized\"]\n+trait Sized { }\n+#[lang=\"copy\"]\n+trait Copy { }\n \n #[no_mangle]\n #[cmse_nonsecure_entry]\n-pub extern \"C\" fn entry_function(a: u32, b: u32, c: u32, d: u32) -> u32 {\n-    a + b + c + d\n+pub extern \"C\" fn entry_function(_: u32, _: u32, _: u32, d: u32) -> u32 {\n+    d\n }"}, {"sha": "74321fdfdde907b5694b04a5ea928f0a004dc587", "filename": "src/test/ui/cmse-nonsecure/cmse-nonsecure-entry/params-on-stack.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/cfcb2b664d6f1419a6219f88b060dee420736407/src%2Ftest%2Fui%2Fcmse-nonsecure%2Fcmse-nonsecure-entry%2Fparams-on-stack.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cfcb2b664d6f1419a6219f88b060dee420736407/src%2Ftest%2Fui%2Fcmse-nonsecure%2Fcmse-nonsecure-entry%2Fparams-on-stack.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fcmse-nonsecure%2Fcmse-nonsecure-entry%2Fparams-on-stack.rs?ref=cfcb2b664d6f1419a6219f88b060dee420736407", "patch": "@@ -1,3 +1,4 @@\n+// build-fail\n // compile-flags: --target thumbv8m.main-none-eabi --crate-type lib\n // needs-llvm-components: arm\n // min-llvm-version: 11.0"}, {"sha": "6320d296373c09236a8328d2069c4639fae4cf98", "filename": "src/test/ui/cmse-nonsecure/cmse-nonsecure-entry/wrong-abi.rs", "status": "modified", "additions": 7, "deletions": 4, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/cfcb2b664d6f1419a6219f88b060dee420736407/src%2Ftest%2Fui%2Fcmse-nonsecure%2Fcmse-nonsecure-entry%2Fwrong-abi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cfcb2b664d6f1419a6219f88b060dee420736407/src%2Ftest%2Fui%2Fcmse-nonsecure%2Fcmse-nonsecure-entry%2Fwrong-abi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fcmse-nonsecure%2Fcmse-nonsecure-entry%2Fwrong-abi.rs?ref=cfcb2b664d6f1419a6219f88b060dee420736407", "patch": "@@ -1,10 +1,13 @@\n // compile-flags: --target thumbv8m.main-none-eabi --crate-type lib\n // needs-llvm-components: arm\n-#![feature(cmse_nonsecure_entry)]\n-#![no_std]\n+#![feature(cmse_nonsecure_entry, no_core, lang_items)]\n+#![no_core]\n+#[lang=\"sized\"]\n+trait Sized { }\n \n #[no_mangle]\n #[cmse_nonsecure_entry]\n-pub fn entry_function(a: u32, b: u32, c: u32, d: u32) -> u32 { //~ ERROR [E0776]\n-    a + b + c + d\n+//~^ ERROR `#[cmse_nonsecure_entry]` requires C ABI [E0776]\n+pub fn entry_function(_: u32, _: u32, _: u32, d: u32) -> u32 {\n+    d\n }"}, {"sha": "36d76c9674adff6754947d238740eb24fc3554bc", "filename": "src/test/ui/cmse-nonsecure/cmse-nonsecure-entry/wrong-abi.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/cfcb2b664d6f1419a6219f88b060dee420736407/src%2Ftest%2Fui%2Fcmse-nonsecure%2Fcmse-nonsecure-entry%2Fwrong-abi.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/cfcb2b664d6f1419a6219f88b060dee420736407/src%2Ftest%2Fui%2Fcmse-nonsecure%2Fcmse-nonsecure-entry%2Fwrong-abi.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fcmse-nonsecure%2Fcmse-nonsecure-entry%2Fwrong-abi.stderr?ref=cfcb2b664d6f1419a6219f88b060dee420736407", "patch": "@@ -1,5 +1,5 @@\n-error[E0776]: `#[cmse_nonsecure_entry]` functions require C ABI\n-  --> $DIR/wrong-abi.rs:7:1\n+error[E0776]: `#[cmse_nonsecure_entry]` requires C ABI\n+  --> $DIR/wrong-abi.rs:9:1\n    |\n LL | #[cmse_nonsecure_entry]\n    | ^^^^^^^^^^^^^^^^^^^^^^^"}, {"sha": "e61486fdc6ffd22069596fdb3f80b9b45293b904", "filename": "src/test/ui/crate-loading/missing-std.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cfcb2b664d6f1419a6219f88b060dee420736407/src%2Ftest%2Fui%2Fcrate-loading%2Fmissing-std.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/cfcb2b664d6f1419a6219f88b060dee420736407/src%2Ftest%2Fui%2Fcrate-loading%2Fmissing-std.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fcrate-loading%2Fmissing-std.stderr?ref=cfcb2b664d6f1419a6219f88b060dee420736407", "patch": "@@ -1,5 +1,5 @@\n error[E0463]: can't find crate for `core`\n-  --> $DIR/missing-std.rs:5:1\n+  --> $DIR/missing-std.rs:6:1\n    |\n LL | extern crate core;\n    | ^^^^^^^^^^^^^^^^^^ can't find crate"}, {"sha": "764f20552773a2500373f95ae1cfa68ab72b416c", "filename": "src/tools/compiletest/src/header.rs", "status": "modified", "additions": 213, "deletions": 249, "changes": 462, "blob_url": "https://github.com/rust-lang/rust/blob/cfcb2b664d6f1419a6219f88b060dee420736407/src%2Ftools%2Fcompiletest%2Fsrc%2Fheader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cfcb2b664d6f1419a6219f88b060dee420736407/src%2Ftools%2Fcompiletest%2Fsrc%2Fheader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fcompiletest%2Fsrc%2Fheader.rs?ref=cfcb2b664d6f1419a6219f88b060dee420736407", "patch": "@@ -27,260 +27,29 @@ enum ParsedNameDirective {\n /// the test.\n #[derive(Default)]\n pub struct EarlyProps {\n-    pub ignore: bool,\n-    pub should_fail: bool,\n     pub aux: Vec<String>,\n     pub aux_crate: Vec<(String, String)>,\n     pub revisions: Vec<String>,\n }\n \n impl EarlyProps {\n     pub fn from_file(config: &Config, testfile: &Path) -> Self {\n-        let file = File::open(testfile).unwrap();\n+        let file = File::open(testfile).expect(\"open test file to parse earlyprops\");\n         Self::from_reader(config, testfile, file)\n     }\n \n     pub fn from_reader<R: Read>(config: &Config, testfile: &Path, rdr: R) -> Self {\n         let mut props = EarlyProps::default();\n-        let rustc_has_profiler_support = env::var_os(\"RUSTC_PROFILER_SUPPORT\").is_some();\n-        let rustc_has_sanitizer_support = env::var_os(\"RUSTC_SANITIZER_SUPPORT\").is_some();\n-        let has_asm_support = util::has_asm_support(&config.target);\n-        let has_asan = util::ASAN_SUPPORTED_TARGETS.contains(&&*config.target);\n-        let has_lsan = util::LSAN_SUPPORTED_TARGETS.contains(&&*config.target);\n-        let has_msan = util::MSAN_SUPPORTED_TARGETS.contains(&&*config.target);\n-        let has_tsan = util::TSAN_SUPPORTED_TARGETS.contains(&&*config.target);\n-        let has_hwasan = util::HWASAN_SUPPORTED_TARGETS.contains(&&*config.target);\n-        // for `-Z gcc-ld=lld`\n-        let has_rust_lld = config\n-            .compile_lib_path\n-            .join(\"rustlib\")\n-            .join(&config.target)\n-            .join(\"bin\")\n-            .join(\"gcc-ld\")\n-            .join(if config.host.contains(\"windows\") { \"ld.exe\" } else { \"ld\" })\n-            .exists();\n-\n-        iter_header(testfile, None, rdr, &mut |ln| {\n-            // we should check if any only-<platform> exists and if it exists\n-            // and does not matches the current platform, skip the test\n-            if !props.ignore {\n-                props.ignore = match config.parse_cfg_name_directive(ln, \"ignore\") {\n-                    ParsedNameDirective::Match => true,\n-                    ParsedNameDirective::NoMatch => props.ignore,\n-                };\n-\n-                if config.has_cfg_prefix(ln, \"only\") {\n-                    props.ignore = match config.parse_cfg_name_directive(ln, \"only\") {\n-                        ParsedNameDirective::Match => props.ignore,\n-                        ParsedNameDirective::NoMatch => true,\n-                    };\n-                }\n-\n-                if ignore_llvm(config, ln) {\n-                    props.ignore = true;\n-                }\n-\n-                if config.run_clang_based_tests_with.is_none()\n-                    && config.parse_needs_matching_clang(ln)\n-                {\n-                    props.ignore = true;\n-                }\n-\n-                if !has_asm_support && config.parse_name_directive(ln, \"needs-asm-support\") {\n-                    props.ignore = true;\n-                }\n-\n-                if !rustc_has_profiler_support && config.parse_needs_profiler_support(ln) {\n-                    props.ignore = true;\n-                }\n-\n-                if !config.run_enabled() && config.parse_name_directive(ln, \"needs-run-enabled\") {\n-                    props.ignore = true;\n-                }\n-\n-                if !rustc_has_sanitizer_support\n-                    && config.parse_name_directive(ln, \"needs-sanitizer-support\")\n-                {\n-                    props.ignore = true;\n-                }\n-\n-                if !has_asan && config.parse_name_directive(ln, \"needs-sanitizer-address\") {\n-                    props.ignore = true;\n-                }\n-\n-                if !has_lsan && config.parse_name_directive(ln, \"needs-sanitizer-leak\") {\n-                    props.ignore = true;\n-                }\n-\n-                if !has_msan && config.parse_name_directive(ln, \"needs-sanitizer-memory\") {\n-                    props.ignore = true;\n-                }\n-\n-                if !has_tsan && config.parse_name_directive(ln, \"needs-sanitizer-thread\") {\n-                    props.ignore = true;\n-                }\n-\n-                if !has_hwasan && config.parse_name_directive(ln, \"needs-sanitizer-hwaddress\") {\n-                    props.ignore = true;\n-                }\n-\n-                if config.target_panic == PanicStrategy::Abort\n-                    && config.parse_name_directive(ln, \"needs-unwind\")\n-                {\n-                    props.ignore = true;\n-                }\n-\n-                if config.target == \"wasm32-unknown-unknown\" && config.parse_check_run_results(ln) {\n-                    props.ignore = true;\n-                }\n-\n-                if config.debugger == Some(Debugger::Cdb) && ignore_cdb(config, ln) {\n-                    props.ignore = true;\n-                }\n-\n-                if config.debugger == Some(Debugger::Gdb) && ignore_gdb(config, ln) {\n-                    props.ignore = true;\n-                }\n-\n-                if config.debugger == Some(Debugger::Lldb) && ignore_lldb(config, ln) {\n-                    props.ignore = true;\n-                }\n-\n-                if !has_rust_lld && config.parse_name_directive(ln, \"needs-rust-lld\") {\n-                    props.ignore = true;\n-                }\n-            }\n-\n+        iter_header(testfile, rdr, &mut |_, ln| {\n             if let Some(s) = config.parse_aux_build(ln) {\n                 props.aux.push(s);\n             }\n-\n             if let Some(ac) = config.parse_aux_crate(ln) {\n                 props.aux_crate.push(ac);\n             }\n-\n             config.parse_and_update_revisions(ln, &mut props.revisions);\n-\n-            props.should_fail = props.should_fail || config.parse_name_directive(ln, \"should-fail\");\n         });\n-\n         return props;\n-\n-        fn ignore_cdb(config: &Config, line: &str) -> bool {\n-            if let Some(actual_version) = config.cdb_version {\n-                if let Some(min_version) = line.strip_prefix(\"min-cdb-version:\").map(str::trim) {\n-                    let min_version = extract_cdb_version(min_version).unwrap_or_else(|| {\n-                        panic!(\"couldn't parse version range: {:?}\", min_version);\n-                    });\n-\n-                    // Ignore if actual version is smaller than the minimum\n-                    // required version\n-                    return actual_version < min_version;\n-                }\n-            }\n-            false\n-        }\n-\n-        fn ignore_gdb(config: &Config, line: &str) -> bool {\n-            if let Some(actual_version) = config.gdb_version {\n-                if let Some(rest) = line.strip_prefix(\"min-gdb-version:\").map(str::trim) {\n-                    let (start_ver, end_ver) = extract_version_range(rest, extract_gdb_version)\n-                        .unwrap_or_else(|| {\n-                            panic!(\"couldn't parse version range: {:?}\", rest);\n-                        });\n-\n-                    if start_ver != end_ver {\n-                        panic!(\"Expected single GDB version\")\n-                    }\n-                    // Ignore if actual version is smaller than the minimum\n-                    // required version\n-                    return actual_version < start_ver;\n-                } else if let Some(rest) = line.strip_prefix(\"ignore-gdb-version:\").map(str::trim) {\n-                    let (min_version, max_version) =\n-                        extract_version_range(rest, extract_gdb_version).unwrap_or_else(|| {\n-                            panic!(\"couldn't parse version range: {:?}\", rest);\n-                        });\n-\n-                    if max_version < min_version {\n-                        panic!(\"Malformed GDB version range: max < min\")\n-                    }\n-\n-                    return actual_version >= min_version && actual_version <= max_version;\n-                }\n-            }\n-            false\n-        }\n-\n-        fn ignore_lldb(config: &Config, line: &str) -> bool {\n-            if let Some(actual_version) = config.lldb_version {\n-                if let Some(min_version) = line.strip_prefix(\"min-lldb-version:\").map(str::trim) {\n-                    let min_version = min_version.parse().unwrap_or_else(|e| {\n-                        panic!(\n-                            \"Unexpected format of LLDB version string: {}\\n{:?}\",\n-                            min_version, e\n-                        );\n-                    });\n-                    // Ignore if actual version is smaller the minimum required\n-                    // version\n-                    actual_version < min_version\n-                } else {\n-                    line.starts_with(\"rust-lldb\") && !config.lldb_native_rust\n-                }\n-            } else {\n-                false\n-            }\n-        }\n-\n-        fn ignore_llvm(config: &Config, line: &str) -> bool {\n-            if config.system_llvm && line.starts_with(\"no-system-llvm\") {\n-                return true;\n-            }\n-            if let Some(needed_components) =\n-                config.parse_name_value_directive(line, \"needs-llvm-components\")\n-            {\n-                let components: HashSet<_> = config.llvm_components.split_whitespace().collect();\n-                if let Some(missing_component) = needed_components\n-                    .split_whitespace()\n-                    .find(|needed_component| !components.contains(needed_component))\n-                {\n-                    if env::var_os(\"COMPILETEST_NEEDS_ALL_LLVM_COMPONENTS\").is_some() {\n-                        panic!(\"missing LLVM component: {}\", missing_component);\n-                    }\n-                    return true;\n-                }\n-            }\n-            if let Some(actual_version) = config.llvm_version {\n-                if let Some(rest) = line.strip_prefix(\"min-llvm-version:\").map(str::trim) {\n-                    let min_version = extract_llvm_version(rest).unwrap();\n-                    // Ignore if actual version is smaller the minimum required\n-                    // version\n-                    actual_version < min_version\n-                } else if let Some(rest) =\n-                    line.strip_prefix(\"min-system-llvm-version:\").map(str::trim)\n-                {\n-                    let min_version = extract_llvm_version(rest).unwrap();\n-                    // Ignore if using system LLVM and actual version\n-                    // is smaller the minimum required version\n-                    config.system_llvm && actual_version < min_version\n-                } else if let Some(rest) = line.strip_prefix(\"ignore-llvm-version:\").map(str::trim)\n-                {\n-                    // Syntax is: \"ignore-llvm-version: <version1> [- <version2>]\"\n-                    let (v_min, v_max) = extract_version_range(rest, extract_llvm_version)\n-                        .unwrap_or_else(|| {\n-                            panic!(\"couldn't parse version range: {:?}\", rest);\n-                        });\n-                    if v_max < v_min {\n-                        panic!(\"Malformed LLVM version range: max < min\")\n-                    }\n-                    // Ignore if version lies inside of range.\n-                    actual_version >= v_min && actual_version <= v_max\n-                } else {\n-                    false\n-                }\n-            } else {\n-                false\n-            }\n-        }\n     }\n }\n \n@@ -440,7 +209,11 @@ impl TestProps {\n         if !testfile.is_dir() {\n             let file = File::open(testfile).unwrap();\n \n-            iter_header(testfile, cfg, file, &mut |ln| {\n+            iter_header(testfile, file, &mut |revision, ln| {\n+                if revision.is_some() && revision != cfg {\n+                    return;\n+                }\n+\n                 if let Some(ep) = config.parse_error_pattern(ln) {\n                     self.error_patterns.push(ep);\n                 }\n@@ -672,12 +445,12 @@ impl TestProps {\n     }\n }\n \n-fn iter_header<R: Read>(testfile: &Path, cfg: Option<&str>, rdr: R, it: &mut dyn FnMut(&str)) {\n+fn iter_header<R: Read>(testfile: &Path, rdr: R, it: &mut dyn FnMut(Option<&str>, &str)) {\n     if testfile.is_dir() {\n         return;\n     }\n \n-    let comment = if testfile.to_string_lossy().ends_with(\".rs\") { \"//\" } else { \"#\" };\n+    let comment = if testfile.extension().map(|e| e == \"rs\") == Some(true) { \"//\" } else { \"#\" };\n \n     let mut rdr = BufReader::new(rdr);\n     let mut ln = String::new();\n@@ -699,18 +472,12 @@ fn iter_header<R: Read>(testfile: &Path, cfg: Option<&str>, rdr: R, it: &mut dyn\n             if let Some(close_brace) = ln.find(']') {\n                 let open_brace = ln.find('[').unwrap();\n                 let lncfg = &ln[open_brace + 1..close_brace];\n-                let matches = match cfg {\n-                    Some(s) => s == &lncfg[..],\n-                    None => false,\n-                };\n-                if matches {\n-                    it(ln[(close_brace + 1)..].trim_start());\n-                }\n+                it(Some(lncfg), ln[(close_brace + 1)..].trim_start());\n             } else {\n                 panic!(\"malformed condition directive: expected `{}[foo]`, found `{}`\", comment, ln)\n             }\n         } else if ln.starts_with(comment) {\n-            it(ln[comment.len()..].trim_start());\n+            it(None, ln[comment.len()..].trim_start());\n         }\n     }\n }\n@@ -1026,11 +793,12 @@ pub fn extract_llvm_version(version: &str) -> Option<u32> {\n     Some(version)\n }\n \n-// Takes a directive of the form \"<version1> [- <version2>]\",\n-// returns the numeric representation of <version1> and <version2> as\n-// tuple: (<version1> as u32, <version2> as u32)\n-// If the <version2> part is omitted, the second component of the tuple\n-// is the same as <version1>.\n+/// Takes a directive of the form \"<version1> [- <version2>]\",\n+/// returns the numeric representation of <version1> and <version2> as\n+/// tuple: (<version1> as u32, <version2> as u32)\n+///\n+/// If the <version2> part is omitted, the second component of the tuple\n+/// is the same as <version1>.\n fn extract_version_range<F>(line: &str, parse: F) -> Option<(u32, u32)>\n where\n     F: Fn(&str) -> Option<u32>,\n@@ -1056,3 +824,199 @@ where\n \n     Some((min, max))\n }\n+\n+pub fn make_test_description<R: Read>(\n+    config: &Config,\n+    name: test::TestName,\n+    path: &Path,\n+    src: R,\n+    cfg: Option<&str>,\n+) -> test::TestDesc {\n+    let mut ignore = false;\n+    let mut should_fail = false;\n+\n+    let rustc_has_profiler_support = env::var_os(\"RUSTC_PROFILER_SUPPORT\").is_some();\n+    let rustc_has_sanitizer_support = env::var_os(\"RUSTC_SANITIZER_SUPPORT\").is_some();\n+    let has_asm_support = util::has_asm_support(&config.target);\n+    let has_asan = util::ASAN_SUPPORTED_TARGETS.contains(&&*config.target);\n+    let has_lsan = util::LSAN_SUPPORTED_TARGETS.contains(&&*config.target);\n+    let has_msan = util::MSAN_SUPPORTED_TARGETS.contains(&&*config.target);\n+    let has_tsan = util::TSAN_SUPPORTED_TARGETS.contains(&&*config.target);\n+    let has_hwasan = util::HWASAN_SUPPORTED_TARGETS.contains(&&*config.target);\n+    // for `-Z gcc-ld=lld`\n+    let has_rust_lld = config\n+        .compile_lib_path\n+        .join(\"rustlib\")\n+        .join(&config.target)\n+        .join(\"bin\")\n+        .join(\"gcc-ld\")\n+        .join(if config.host.contains(\"windows\") { \"ld.exe\" } else { \"ld\" })\n+        .exists();\n+    iter_header(path, src, &mut |revision, ln| {\n+        if revision.is_some() && revision != cfg {\n+            return;\n+        }\n+        ignore = match config.parse_cfg_name_directive(ln, \"ignore\") {\n+            ParsedNameDirective::Match => true,\n+            ParsedNameDirective::NoMatch => ignore,\n+        };\n+        if config.has_cfg_prefix(ln, \"only\") {\n+            ignore = match config.parse_cfg_name_directive(ln, \"only\") {\n+                ParsedNameDirective::Match => ignore,\n+                ParsedNameDirective::NoMatch => true,\n+            };\n+        }\n+        ignore |= ignore_llvm(config, ln);\n+        ignore |=\n+            config.run_clang_based_tests_with.is_none() && config.parse_needs_matching_clang(ln);\n+        ignore |= !has_asm_support && config.parse_name_directive(ln, \"needs-asm-support\");\n+        ignore |= !rustc_has_profiler_support && config.parse_needs_profiler_support(ln);\n+        ignore |= !config.run_enabled() && config.parse_name_directive(ln, \"needs-run-enabled\");\n+        ignore |= !rustc_has_sanitizer_support\n+            && config.parse_name_directive(ln, \"needs-sanitizer-support\");\n+        ignore |= !has_asan && config.parse_name_directive(ln, \"needs-sanitizer-address\");\n+        ignore |= !has_lsan && config.parse_name_directive(ln, \"needs-sanitizer-leak\");\n+        ignore |= !has_msan && config.parse_name_directive(ln, \"needs-sanitizer-memory\");\n+        ignore |= !has_tsan && config.parse_name_directive(ln, \"needs-sanitizer-thread\");\n+        ignore |= !has_hwasan && config.parse_name_directive(ln, \"needs-sanitizer-hwaddress\");\n+        ignore |= config.target_panic == PanicStrategy::Abort\n+            && config.parse_name_directive(ln, \"needs-unwind\");\n+        ignore |= config.target == \"wasm32-unknown-unknown\" && config.parse_check_run_results(ln);\n+        ignore |= config.debugger == Some(Debugger::Cdb) && ignore_cdb(config, ln);\n+        ignore |= config.debugger == Some(Debugger::Gdb) && ignore_gdb(config, ln);\n+        ignore |= config.debugger == Some(Debugger::Lldb) && ignore_lldb(config, ln);\n+        ignore |= !has_rust_lld && config.parse_name_directive(ln, \"needs-rust-lld\");\n+        should_fail |= config.parse_name_directive(ln, \"should-fail\");\n+    });\n+\n+    // The `should-fail` annotation doesn't apply to pretty tests,\n+    // since we run the pretty printer across all tests by default.\n+    // If desired, we could add a `should-fail-pretty` annotation.\n+    let should_panic = match config.mode {\n+        crate::common::Pretty => test::ShouldPanic::No,\n+        _ if should_fail => test::ShouldPanic::Yes,\n+        _ => test::ShouldPanic::No,\n+    };\n+\n+    test::TestDesc {\n+        name,\n+        ignore,\n+        should_panic,\n+        allow_fail: false,\n+        #[cfg(not(bootstrap))]\n+        compile_fail: false,\n+        #[cfg(not(bootstrap))]\n+        no_run: false,\n+        test_type: test::TestType::Unknown,\n+    }\n+}\n+\n+fn ignore_cdb(config: &Config, line: &str) -> bool {\n+    if let Some(actual_version) = config.cdb_version {\n+        if let Some(min_version) = line.strip_prefix(\"min-cdb-version:\").map(str::trim) {\n+            let min_version = extract_cdb_version(min_version).unwrap_or_else(|| {\n+                panic!(\"couldn't parse version range: {:?}\", min_version);\n+            });\n+\n+            // Ignore if actual version is smaller than the minimum\n+            // required version\n+            return actual_version < min_version;\n+        }\n+    }\n+    false\n+}\n+\n+fn ignore_gdb(config: &Config, line: &str) -> bool {\n+    if let Some(actual_version) = config.gdb_version {\n+        if let Some(rest) = line.strip_prefix(\"min-gdb-version:\").map(str::trim) {\n+            let (start_ver, end_ver) = extract_version_range(rest, extract_gdb_version)\n+                .unwrap_or_else(|| {\n+                    panic!(\"couldn't parse version range: {:?}\", rest);\n+                });\n+\n+            if start_ver != end_ver {\n+                panic!(\"Expected single GDB version\")\n+            }\n+            // Ignore if actual version is smaller than the minimum\n+            // required version\n+            return actual_version < start_ver;\n+        } else if let Some(rest) = line.strip_prefix(\"ignore-gdb-version:\").map(str::trim) {\n+            let (min_version, max_version) = extract_version_range(rest, extract_gdb_version)\n+                .unwrap_or_else(|| {\n+                    panic!(\"couldn't parse version range: {:?}\", rest);\n+                });\n+\n+            if max_version < min_version {\n+                panic!(\"Malformed GDB version range: max < min\")\n+            }\n+\n+            return actual_version >= min_version && actual_version <= max_version;\n+        }\n+    }\n+    false\n+}\n+\n+fn ignore_lldb(config: &Config, line: &str) -> bool {\n+    if let Some(actual_version) = config.lldb_version {\n+        if let Some(min_version) = line.strip_prefix(\"min-lldb-version:\").map(str::trim) {\n+            let min_version = min_version.parse().unwrap_or_else(|e| {\n+                panic!(\"Unexpected format of LLDB version string: {}\\n{:?}\", min_version, e);\n+            });\n+            // Ignore if actual version is smaller the minimum required\n+            // version\n+            actual_version < min_version\n+        } else {\n+            line.starts_with(\"rust-lldb\") && !config.lldb_native_rust\n+        }\n+    } else {\n+        false\n+    }\n+}\n+\n+fn ignore_llvm(config: &Config, line: &str) -> bool {\n+    if config.system_llvm && line.starts_with(\"no-system-llvm\") {\n+        return true;\n+    }\n+    if let Some(needed_components) =\n+        config.parse_name_value_directive(line, \"needs-llvm-components\")\n+    {\n+        let components: HashSet<_> = config.llvm_components.split_whitespace().collect();\n+        if let Some(missing_component) = needed_components\n+            .split_whitespace()\n+            .find(|needed_component| !components.contains(needed_component))\n+        {\n+            if env::var_os(\"COMPILETEST_NEEDS_ALL_LLVM_COMPONENTS\").is_some() {\n+                panic!(\"missing LLVM component: {}\", missing_component);\n+            }\n+            return true;\n+        }\n+    }\n+    if let Some(actual_version) = config.llvm_version {\n+        if let Some(rest) = line.strip_prefix(\"min-llvm-version:\").map(str::trim) {\n+            let min_version = extract_llvm_version(rest).unwrap();\n+            // Ignore if actual version is smaller the minimum required\n+            // version\n+            actual_version < min_version\n+        } else if let Some(rest) = line.strip_prefix(\"min-system-llvm-version:\").map(str::trim) {\n+            let min_version = extract_llvm_version(rest).unwrap();\n+            // Ignore if using system LLVM and actual version\n+            // is smaller the minimum required version\n+            config.system_llvm && actual_version < min_version\n+        } else if let Some(rest) = line.strip_prefix(\"ignore-llvm-version:\").map(str::trim) {\n+            // Syntax is: \"ignore-llvm-version: <version1> [- <version2>]\"\n+            let (v_min, v_max) =\n+                extract_version_range(rest, extract_llvm_version).unwrap_or_else(|| {\n+                    panic!(\"couldn't parse version range: {:?}\", rest);\n+                });\n+            if v_max < v_min {\n+                panic!(\"Malformed LLVM version range: max < min\")\n+            }\n+            // Ignore if version lies inside of range.\n+            actual_version >= v_min && actual_version <= v_max\n+        } else {\n+            false\n+        }\n+    } else {\n+        false\n+    }\n+}"}, {"sha": "2485dbadab5bfdbb5bb6cb55f4ec336a90f98778", "filename": "src/tools/compiletest/src/header/tests.rs", "status": "modified", "additions": 62, "deletions": 51, "changes": 113, "blob_url": "https://github.com/rust-lang/rust/blob/cfcb2b664d6f1419a6219f88b060dee420736407/src%2Ftools%2Fcompiletest%2Fsrc%2Fheader%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cfcb2b664d6f1419a6219f88b060dee420736407/src%2Ftools%2Fcompiletest%2Fsrc%2Fheader%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fcompiletest%2Fsrc%2Fheader%2Ftests.rs?ref=cfcb2b664d6f1419a6219f88b060dee420736407", "patch": "@@ -1,7 +1,7 @@\n use std::path::Path;\n \n use crate::common::{Config, Debugger};\n-use crate::header::{parse_normalization_string, EarlyProps};\n+use crate::header::{make_test_description, parse_normalization_string, EarlyProps};\n \n #[test]\n fn test_parse_normalization_string() {\n@@ -66,6 +66,13 @@ fn parse_rs(config: &Config, contents: &str) -> EarlyProps {\n     EarlyProps::from_reader(config, Path::new(\"a.rs\"), bytes)\n }\n \n+fn check_ignore(config: &Config, contents: &str) -> bool {\n+    let tn = test::DynTestName(String::new());\n+    let p = Path::new(\"a.rs\");\n+    let d = make_test_description(&config, tn, p, std::io::Cursor::new(contents), None);\n+    d.ignore\n+}\n+\n fn parse_makefile(config: &Config, contents: &str) -> EarlyProps {\n     let bytes = contents.as_bytes();\n     EarlyProps::from_reader(config, Path::new(\"Makefile\"), bytes)\n@@ -74,9 +81,13 @@ fn parse_makefile(config: &Config, contents: &str) -> EarlyProps {\n #[test]\n fn should_fail() {\n     let config = config();\n+    let tn = test::DynTestName(String::new());\n+    let p = Path::new(\"a.rs\");\n \n-    assert!(!parse_rs(&config, \"\").should_fail);\n-    assert!(parse_rs(&config, \"// should-fail\").should_fail);\n+    let d = make_test_description(&config, tn.clone(), p, std::io::Cursor::new(\"\"), None);\n+    assert_eq!(d.should_panic, test::ShouldPanic::No);\n+    let d = make_test_description(&config, tn, p, std::io::Cursor::new(\"// should-fail\"), None);\n+    assert_eq!(d.should_panic, test::ShouldPanic::Yes);\n }\n \n #[test]\n@@ -112,97 +123,97 @@ fn no_system_llvm() {\n     let mut config = config();\n \n     config.system_llvm = false;\n-    assert!(!parse_rs(&config, \"// no-system-llvm\").ignore);\n+    assert!(!check_ignore(&config, \"// no-system-llvm\"));\n \n     config.system_llvm = true;\n-    assert!(parse_rs(&config, \"// no-system-llvm\").ignore);\n+    assert!(check_ignore(&config, \"// no-system-llvm\"));\n }\n \n #[test]\n fn llvm_version() {\n     let mut config = config();\n \n     config.llvm_version = Some(80102);\n-    assert!(parse_rs(&config, \"// min-llvm-version: 9.0\").ignore);\n+    assert!(check_ignore(&config, \"// min-llvm-version: 9.0\"));\n \n     config.llvm_version = Some(90001);\n-    assert!(parse_rs(&config, \"// min-llvm-version: 9.2\").ignore);\n+    assert!(check_ignore(&config, \"// min-llvm-version: 9.2\"));\n \n     config.llvm_version = Some(90301);\n-    assert!(!parse_rs(&config, \"// min-llvm-version: 9.2\").ignore);\n+    assert!(!check_ignore(&config, \"// min-llvm-version: 9.2\"));\n \n     config.llvm_version = Some(100000);\n-    assert!(!parse_rs(&config, \"// min-llvm-version: 9.0\").ignore);\n+    assert!(!check_ignore(&config, \"// min-llvm-version: 9.0\"));\n }\n \n #[test]\n fn ignore_target() {\n     let mut config = config();\n     config.target = \"x86_64-unknown-linux-gnu\".to_owned();\n \n-    assert!(parse_rs(&config, \"// ignore-x86_64-unknown-linux-gnu\").ignore);\n-    assert!(parse_rs(&config, \"// ignore-x86_64\").ignore);\n-    assert!(parse_rs(&config, \"// ignore-linux\").ignore);\n-    assert!(parse_rs(&config, \"// ignore-gnu\").ignore);\n-    assert!(parse_rs(&config, \"// ignore-64bit\").ignore);\n+    assert!(check_ignore(&config, \"// ignore-x86_64-unknown-linux-gnu\"));\n+    assert!(check_ignore(&config, \"// ignore-x86_64\"));\n+    assert!(check_ignore(&config, \"// ignore-linux\"));\n+    assert!(check_ignore(&config, \"// ignore-gnu\"));\n+    assert!(check_ignore(&config, \"// ignore-64bit\"));\n \n-    assert!(!parse_rs(&config, \"// ignore-i686\").ignore);\n-    assert!(!parse_rs(&config, \"// ignore-windows\").ignore);\n-    assert!(!parse_rs(&config, \"// ignore-msvc\").ignore);\n-    assert!(!parse_rs(&config, \"// ignore-32bit\").ignore);\n+    assert!(!check_ignore(&config, \"// ignore-i686\"));\n+    assert!(!check_ignore(&config, \"// ignore-windows\"));\n+    assert!(!check_ignore(&config, \"// ignore-msvc\"));\n+    assert!(!check_ignore(&config, \"// ignore-32bit\"));\n }\n \n #[test]\n fn only_target() {\n     let mut config = config();\n     config.target = \"x86_64-pc-windows-gnu\".to_owned();\n \n-    assert!(parse_rs(&config, \"// only-i686\").ignore);\n-    assert!(parse_rs(&config, \"// only-linux\").ignore);\n-    assert!(parse_rs(&config, \"// only-msvc\").ignore);\n-    assert!(parse_rs(&config, \"// only-32bit\").ignore);\n+    assert!(check_ignore(&config, \"// only-i686\"));\n+    assert!(check_ignore(&config, \"// only-linux\"));\n+    assert!(check_ignore(&config, \"// only-msvc\"));\n+    assert!(check_ignore(&config, \"// only-32bit\"));\n \n-    assert!(!parse_rs(&config, \"// only-x86_64-pc-windows-gnu\").ignore);\n-    assert!(!parse_rs(&config, \"// only-x86_64\").ignore);\n-    assert!(!parse_rs(&config, \"// only-windows\").ignore);\n-    assert!(!parse_rs(&config, \"// only-gnu\").ignore);\n-    assert!(!parse_rs(&config, \"// only-64bit\").ignore);\n+    assert!(!check_ignore(&config, \"// only-x86_64-pc-windows-gnu\"));\n+    assert!(!check_ignore(&config, \"// only-x86_64\"));\n+    assert!(!check_ignore(&config, \"// only-windows\"));\n+    assert!(!check_ignore(&config, \"// only-gnu\"));\n+    assert!(!check_ignore(&config, \"// only-64bit\"));\n }\n \n #[test]\n fn stage() {\n     let mut config = config();\n     config.stage_id = \"stage1\".to_owned();\n \n-    assert!(parse_rs(&config, \"// ignore-stage1\").ignore);\n-    assert!(!parse_rs(&config, \"// ignore-stage2\").ignore);\n+    assert!(check_ignore(&config, \"// ignore-stage1\"));\n+    assert!(!check_ignore(&config, \"// ignore-stage2\"));\n }\n \n #[test]\n fn cross_compile() {\n     let mut config = config();\n     config.host = \"x86_64-apple-darwin\".to_owned();\n     config.target = \"wasm32-unknown-unknown\".to_owned();\n-    assert!(parse_rs(&config, \"// ignore-cross-compile\").ignore);\n+    assert!(check_ignore(&config, \"// ignore-cross-compile\"));\n \n     config.target = config.host.clone();\n-    assert!(!parse_rs(&config, \"// ignore-cross-compile\").ignore);\n+    assert!(!check_ignore(&config, \"// ignore-cross-compile\"));\n }\n \n #[test]\n fn debugger() {\n     let mut config = config();\n     config.debugger = None;\n-    assert!(!parse_rs(&config, \"// ignore-cdb\").ignore);\n+    assert!(!check_ignore(&config, \"// ignore-cdb\"));\n \n     config.debugger = Some(Debugger::Cdb);\n-    assert!(parse_rs(&config, \"// ignore-cdb\").ignore);\n+    assert!(check_ignore(&config, \"// ignore-cdb\"));\n \n     config.debugger = Some(Debugger::Gdb);\n-    assert!(parse_rs(&config, \"// ignore-gdb\").ignore);\n+    assert!(check_ignore(&config, \"// ignore-gdb\"));\n \n     config.debugger = Some(Debugger::Lldb);\n-    assert!(parse_rs(&config, \"// ignore-lldb\").ignore);\n+    assert!(check_ignore(&config, \"// ignore-lldb\"));\n }\n \n #[test]\n@@ -211,42 +222,42 @@ fn sanitizers() {\n \n     // Target that supports all sanitizers:\n     config.target = \"x86_64-unknown-linux-gnu\".to_owned();\n-    assert!(!parse_rs(&config, \"// needs-sanitizer-address\").ignore);\n-    assert!(!parse_rs(&config, \"// needs-sanitizer-leak\").ignore);\n-    assert!(!parse_rs(&config, \"// needs-sanitizer-memory\").ignore);\n-    assert!(!parse_rs(&config, \"// needs-sanitizer-thread\").ignore);\n+    assert!(!check_ignore(&config, \"// needs-sanitizer-address\"));\n+    assert!(!check_ignore(&config, \"// needs-sanitizer-leak\"));\n+    assert!(!check_ignore(&config, \"// needs-sanitizer-memory\"));\n+    assert!(!check_ignore(&config, \"// needs-sanitizer-thread\"));\n \n     // Target that doesn't support sanitizers:\n     config.target = \"wasm32-unknown-emscripten\".to_owned();\n-    assert!(parse_rs(&config, \"// needs-sanitizer-address\").ignore);\n-    assert!(parse_rs(&config, \"// needs-sanitizer-leak\").ignore);\n-    assert!(parse_rs(&config, \"// needs-sanitizer-memory\").ignore);\n-    assert!(parse_rs(&config, \"// needs-sanitizer-thread\").ignore);\n+    assert!(check_ignore(&config, \"// needs-sanitizer-address\"));\n+    assert!(check_ignore(&config, \"// needs-sanitizer-leak\"));\n+    assert!(check_ignore(&config, \"// needs-sanitizer-memory\"));\n+    assert!(check_ignore(&config, \"// needs-sanitizer-thread\"));\n }\n \n #[test]\n fn asm_support() {\n     let mut config = config();\n \n     config.target = \"avr-unknown-gnu-atmega328\".to_owned();\n-    assert!(parse_rs(&config, \"// needs-asm-support\").ignore);\n+    assert!(check_ignore(&config, \"// needs-asm-support\"));\n \n     config.target = \"i686-unknown-netbsd\".to_owned();\n-    assert!(!parse_rs(&config, \"// needs-asm-support\").ignore);\n+    assert!(!check_ignore(&config, \"// needs-asm-support\"));\n }\n \n #[test]\n fn channel() {\n     let mut config = config();\n     config.channel = \"beta\".into();\n \n-    assert!(parse_rs(&config, \"// ignore-beta\").ignore);\n-    assert!(parse_rs(&config, \"// only-nightly\").ignore);\n-    assert!(parse_rs(&config, \"// only-stable\").ignore);\n+    assert!(check_ignore(&config, \"// ignore-beta\"));\n+    assert!(check_ignore(&config, \"// only-nightly\"));\n+    assert!(check_ignore(&config, \"// only-stable\"));\n \n-    assert!(!parse_rs(&config, \"// only-beta\").ignore);\n-    assert!(!parse_rs(&config, \"// ignore-nightly\").ignore);\n-    assert!(!parse_rs(&config, \"// ignore-stable\").ignore);\n+    assert!(!check_ignore(&config, \"// only-beta\"));\n+    assert!(!check_ignore(&config, \"// ignore-nightly\"));\n+    assert!(!check_ignore(&config, \"// ignore-stable\"));\n }\n \n #[test]"}, {"sha": "46432d5e4f5bcd9c1a73376e3d9a3b4bdf9e4115", "filename": "src/tools/compiletest/src/main.rs", "status": "modified", "additions": 21, "deletions": 43, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/cfcb2b664d6f1419a6219f88b060dee420736407/src%2Ftools%2Fcompiletest%2Fsrc%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cfcb2b664d6f1419a6219f88b060dee420736407/src%2Ftools%2Fcompiletest%2Fsrc%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fcompiletest%2Fsrc%2Fmain.rs?ref=cfcb2b664d6f1419a6219f88b060dee420736407", "patch": "@@ -8,7 +8,7 @@ extern crate test;\n use crate::common::{\n     expected_output_path, output_base_dir, output_relative_path, PanicStrategy, UI_EXTENSIONS,\n };\n-use crate::common::{CompareMode, Config, Debugger, Mode, PassMode, Pretty, TestPaths};\n+use crate::common::{CompareMode, Config, Debugger, Mode, PassMode, TestPaths};\n use crate::util::logv;\n use getopts::Options;\n use std::env;\n@@ -22,7 +22,7 @@ use test::ColorConfig;\n use tracing::*;\n use walkdir::WalkDir;\n \n-use self::header::EarlyProps;\n+use self::header::{make_test_description, EarlyProps};\n \n #[cfg(test)]\n mod tests;\n@@ -620,26 +620,13 @@ pub fn is_test(file_name: &OsString) -> bool {\n }\n \n fn make_test(config: &Config, testpaths: &TestPaths, inputs: &Stamp) -> Vec<test::TestDescAndFn> {\n-    let early_props = if config.mode == Mode::RunMake {\n-        // Allow `ignore` directives to be in the Makefile.\n-        EarlyProps::from_file(config, &testpaths.file.join(\"Makefile\"))\n+    let test_path = if config.mode == Mode::RunMake {\n+        // Parse directives in the Makefile\n+        testpaths.file.join(\"Makefile\")\n     } else {\n-        EarlyProps::from_file(config, &testpaths.file)\n-    };\n-\n-    // The `should-fail` annotation doesn't apply to pretty tests,\n-    // since we run the pretty printer across all tests by default.\n-    // If desired, we could add a `should-fail-pretty` annotation.\n-    let should_panic = match config.mode {\n-        Pretty => test::ShouldPanic::No,\n-        _ => {\n-            if early_props.should_fail {\n-                test::ShouldPanic::Yes\n-            } else {\n-                test::ShouldPanic::No\n-            }\n-        }\n+        PathBuf::from(&testpaths.file)\n     };\n+    let early_props = EarlyProps::from_file(config, &test_path);\n \n     // Incremental tests are special, they inherently cannot be run in parallel.\n     // `runtest::run` will be responsible for iterating over revisions.\n@@ -651,29 +638,20 @@ fn make_test(config: &Config, testpaths: &TestPaths, inputs: &Stamp) -> Vec<test\n     revisions\n         .into_iter()\n         .map(|revision| {\n-            let ignore = early_props.ignore\n-                // Ignore tests that already run and are up to date with respect to inputs.\n-                || is_up_to_date(\n-                    config,\n-                    testpaths,\n-                    &early_props,\n-                    revision.map(|s| s.as_str()),\n-                    inputs,\n-                );\n-            test::TestDescAndFn {\n-                desc: test::TestDesc {\n-                    name: make_test_name(config, testpaths, revision),\n-                    ignore,\n-                    should_panic,\n-                    allow_fail: false,\n-                    #[cfg(not(bootstrap))]\n-                    compile_fail: false,\n-                    #[cfg(not(bootstrap))]\n-                    no_run: false,\n-                    test_type: test::TestType::Unknown,\n-                },\n-                testfn: make_test_closure(config, testpaths, revision),\n-            }\n+            let src_file =\n+                std::fs::File::open(&test_path).expect(\"open test file to parse ignores\");\n+            let cfg = revision.map(|v| &**v);\n+            let test_name = crate::make_test_name(config, testpaths, revision);\n+            let mut desc = make_test_description(config, test_name, &test_path, src_file, cfg);\n+            // Ignore tests that already run and are up to date with respect to inputs.\n+            desc.ignore |= is_up_to_date(\n+                config,\n+                testpaths,\n+                &early_props,\n+                revision.map(|s| s.as_str()),\n+                inputs,\n+            );\n+            test::TestDescAndFn { desc, testfn: make_test_closure(config, testpaths, revision) }\n         })\n         .collect()\n }"}]}