{"sha": "469ecef422aab0364f87205f39f2830cbdfe6ab1", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQ2OWVjZWY0MjJhYWIwMzY0Zjg3MjA1ZjM5ZjI4MzBjYmRmZTZhYjE=", "commit": {"author": {"name": "Esteban K\u00fcber", "email": "esteban@kuber.com.ar", "date": "2017-01-21T02:57:21Z"}, "committer": {"name": "Esteban K\u00fcber", "email": "esteban@kuber.com.ar", "date": "2017-01-21T05:15:24Z"}, "message": "Fix multiple labels when some don't have message\n\nThe diagnostic emitter now accounts for labels with no text message,\npresenting the underline on its own, without drawing the line for the\nnon existing message below it. Go from\n\n```\nerror: foo\n --> test.rs:3:6\n  |\n3 |   a { b { c } d }\n  |   ----^^^^^^^----\n  |   |   |\n  |   |   `b` is a good letter\n  |\n```\n\nto\n\n```\nerror: foo\n --> test.rs:3:6\n  |\n3 |   a { b { c } d }\n  |   ----^^^^^^^----\n  |       |\n  |       `b` is a good letter\n```\n\nand from\n\n```\nerror: foo\n --> test.rs:3:6\n  |\n3 |   a { b { c } d }\n  |   ^^^^-------^^^^\n  |   |   |\n  |   |\n  |   `a` is a good letter\n```\n\nto\n\n```\nerror: foo\n --> test.rs:3:6\n  |\n3 |   a { b { c } d }\n  |   ^^^^-------^^^^ `a` is a good letter\n```", "tree": {"sha": "39050c81679d1f367fde29e9fc247c64d7b4963e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/39050c81679d1f367fde29e9fc247c64d7b4963e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/469ecef422aab0364f87205f39f2830cbdfe6ab1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/469ecef422aab0364f87205f39f2830cbdfe6ab1", "html_url": "https://github.com/rust-lang/rust/commit/469ecef422aab0364f87205f39f2830cbdfe6ab1", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/469ecef422aab0364f87205f39f2830cbdfe6ab1/comments", "author": {"login": "estebank", "id": 1606434, "node_id": "MDQ6VXNlcjE2MDY0MzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1606434?v=4", "gravatar_id": "", "url": "https://api.github.com/users/estebank", "html_url": "https://github.com/estebank", "followers_url": "https://api.github.com/users/estebank/followers", "following_url": "https://api.github.com/users/estebank/following{/other_user}", "gists_url": "https://api.github.com/users/estebank/gists{/gist_id}", "starred_url": "https://api.github.com/users/estebank/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/estebank/subscriptions", "organizations_url": "https://api.github.com/users/estebank/orgs", "repos_url": "https://api.github.com/users/estebank/repos", "events_url": "https://api.github.com/users/estebank/events{/privacy}", "received_events_url": "https://api.github.com/users/estebank/received_events", "type": "User", "site_admin": false}, "committer": {"login": "estebank", "id": 1606434, "node_id": "MDQ6VXNlcjE2MDY0MzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1606434?v=4", "gravatar_id": "", "url": "https://api.github.com/users/estebank", "html_url": "https://github.com/estebank", "followers_url": "https://api.github.com/users/estebank/followers", "following_url": "https://api.github.com/users/estebank/following{/other_user}", "gists_url": "https://api.github.com/users/estebank/gists{/gist_id}", "starred_url": "https://api.github.com/users/estebank/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/estebank/subscriptions", "organizations_url": "https://api.github.com/users/estebank/orgs", "repos_url": "https://api.github.com/users/estebank/repos", "events_url": "https://api.github.com/users/estebank/events{/privacy}", "received_events_url": "https://api.github.com/users/estebank/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f0b42075981d9914c39e848377a3e12f0adf37d7", "url": "https://api.github.com/repos/rust-lang/rust/commits/f0b42075981d9914c39e848377a3e12f0adf37d7", "html_url": "https://github.com/rust-lang/rust/commit/f0b42075981d9914c39e848377a3e12f0adf37d7"}], "stats": {"total": 500, "additions": 470, "deletions": 30}, "files": [{"sha": "dc5195fa285d8ce79750457a02855e5ca1077246", "filename": "src/librustc_errors/emitter.rs", "status": "modified", "additions": 47, "deletions": 30, "changes": 77, "blob_url": "https://github.com/rust-lang/rust/blob/469ecef422aab0364f87205f39f2830cbdfe6ab1/src%2Flibrustc_errors%2Femitter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/469ecef422aab0364f87205f39f2830cbdfe6ab1/src%2Flibrustc_errors%2Femitter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_errors%2Femitter.rs?ref=469ecef422aab0364f87205f39f2830cbdfe6ab1", "patch": "@@ -335,43 +335,56 @@ impl EmitterWriter {\n         // which is...less weird, at least. In fact, in general, if\n         // the rightmost span overlaps with any other span, we should\n         // use the \"hang below\" version, so we can at least make it\n-        // clear where the span *starts*.\n+        // clear where the span *starts*. There's an exception for this\n+        // logic, when the labels do not have a message:\n+        //\n+        //      fn foo(x: u32) {\n+        //      --------------\n+        //             |\n+        //             x_span\n+        //\n+        // instead of:\n+        //\n+        //      fn foo(x: u32) {\n+        //      --------------\n+        //      |      |\n+        //      |      x_span\n+        //      <EMPTY LINE>\n+        //\n         let mut annotations_position = vec![];\n         let mut line_len = 0;\n         let mut p = 0;\n         let mut ann_iter = annotations.iter().peekable();\n         while let Some(annotation) = ann_iter.next() {\n-            let is_line = if let AnnotationType::MultilineLine(_) = annotation.annotation_type {\n-                true\n-            } else {\n-                false\n-            };\n             let peek = ann_iter.peek();\n             if let Some(next) = peek {\n-                let next_is_line = if let AnnotationType::MultilineLine(_) = next.annotation_type {\n-                    true\n-                } else {\n-                    false\n-                };\n-\n-                if overlaps(next, annotation) && !is_line && !next_is_line {\n+                if overlaps(next, annotation) && !annotation.is_line() && !next.is_line()\n+                    && annotation.has_label()\n+                {\n+                    // This annotation needs a new line in the output.\n                     p += 1;\n                 }\n             }\n             annotations_position.push((p, annotation));\n             if let Some(next) = peek {\n-                let next_is_line = if let AnnotationType::MultilineLine(_) = next.annotation_type {\n-                    true\n-                } else {\n-                    false\n-                };\n                 let l = if let Some(ref label) = next.label {\n                     label.len() + 2\n                 } else {\n                     0\n                 };\n-                if (overlaps(next, annotation) || next.end_col + l > annotation.start_col)\n-                    && !is_line && !next_is_line\n+                if (overlaps(next, annotation)  // Do not allow two labels to be in the same line\n+                    || next.end_col + l > annotation.start_col)  // if they overlap including\n+                                                // padding, to avoid situations like:\n+                                                //\n+                                                //      fn foo(x: u32) {\n+                                                //      -------^------\n+                                                //      |      |\n+                                                //      fn_spanx_span\n+                                                //\n+                    && !annotation.is_line()    // Do not add a new line if this annotation or the\n+                    && !next.is_line()          // next are vertical line placeholders.\n+                    && annotation.has_label()   // Both labels must have some text, otherwise\n+                    && next.has_label()         // they are not overlapping.\n                 {\n                     p += 1;\n                 }\n@@ -408,6 +421,17 @@ impl EmitterWriter {\n             return;\n         }\n \n+        // Write the colunmn separator.\n+        //\n+        // After this we will have:\n+        //\n+        // 2 |   fn foo() {\n+        //   |\n+        //   |\n+        //   |\n+        // 3 |\n+        // 4 |   }\n+        //   |\n         for pos in 0..line_len + 1 {\n             draw_col_separator(buffer, line_offset + pos + 1, width_offset - 2);\n             buffer.putc(line_offset + pos + 1,\n@@ -468,7 +492,8 @@ impl EmitterWriter {\n                 Style::UnderlineSecondary\n             };\n             let pos = pos + 1;\n-            if pos > 1 {\n+\n+            if pos > 1 && annotation.has_label() {\n                 for p in line_offset + 1..line_offset + pos + 1 {\n                     buffer.putc(p,\n                                 code_offset + annotation.start_col,\n@@ -546,16 +571,8 @@ impl EmitterWriter {\n         //   | |  something about `foo`\n         //   | something about `fn foo()`\n         annotations_position.sort_by(|a, b| {\n-            fn len(a: &Annotation) -> usize {\n-                // Account for usize underflows\n-                if a.end_col > a.start_col {\n-                    a.end_col - a.start_col\n-                } else {\n-                    a.start_col - a.end_col\n-                }\n-            }\n             // Decreasing order\n-            len(a.1).cmp(&len(b.1)).reverse()\n+            a.1.len().cmp(&b.1.len()).reverse()\n         });\n \n         // Write the underlines."}, {"sha": "e70a5dd5ff816a453a5aabf7b459a99a419d2c50", "filename": "src/librustc_errors/snippet.rs", "status": "modified", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/469ecef422aab0364f87205f39f2830cbdfe6ab1/src%2Flibrustc_errors%2Fsnippet.rs", "raw_url": "https://github.com/rust-lang/rust/raw/469ecef422aab0364f87205f39f2830cbdfe6ab1/src%2Flibrustc_errors%2Fsnippet.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_errors%2Fsnippet.rs?ref=469ecef422aab0364f87205f39f2830cbdfe6ab1", "patch": "@@ -151,6 +151,15 @@ impl Annotation {\n         }\n     }\n \n+    /// Wether this annotation is a vertical line placeholder.\n+    pub fn is_line(&self) -> bool {\n+        if let AnnotationType::MultilineLine(_) = self.annotation_type {\n+            true\n+        } else {\n+            false\n+        }\n+    }\n+\n     pub fn is_multiline(&self) -> bool {\n         match self.annotation_type {\n             AnnotationType::Multiline(_) |\n@@ -161,6 +170,32 @@ impl Annotation {\n         }\n     }\n \n+    pub fn len(&self) -> usize {\n+        // Account for usize underflows\n+        if self.end_col > self.start_col {\n+            self.end_col - self.start_col\n+        } else {\n+            self.start_col - self.end_col\n+        }\n+    }\n+\n+    pub fn has_label(&self) -> bool {\n+        if let Some(ref label) = self.label {\n+            // Consider labels with no text as effectively not being there\n+            // to avoid weird output with unnecessary vertical lines, like:\n+            //\n+            //     X | fn foo(x: u32) {\n+            //       | -------^------\n+            //       | |      |\n+            //       | |\n+            //       |\n+            //\n+            // Note that this would be the complete output users would see.\n+            label.len() > 0\n+        } else {\n+            false\n+        }\n+    }\n }\n \n #[derive(Debug)]"}, {"sha": "c6d6e6237f2edfd71f904dc993c935f65f08373d", "filename": "src/libsyntax/test_snippet.rs", "status": "modified", "additions": 388, "deletions": 0, "changes": 388, "blob_url": "https://github.com/rust-lang/rust/blob/469ecef422aab0364f87205f39f2830cbdfe6ab1/src%2Flibsyntax%2Ftest_snippet.rs", "raw_url": "https://github.com/rust-lang/rust/raw/469ecef422aab0364f87205f39f2830cbdfe6ab1/src%2Flibsyntax%2Ftest_snippet.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ftest_snippet.rs?ref=469ecef422aab0364f87205f39f2830cbdfe6ab1", "patch": "@@ -494,6 +494,7 @@ error: foo\n \n \"#);\n }\n+\n #[test]\n fn overlaping_start_and_end() {\n     test_harness(r#\"\n@@ -544,3 +545,390 @@ error: foo\n \n \"#);\n }\n+\n+#[test]\n+fn multiple_labels_primary_without_message() {\n+    test_harness(r#\"\n+fn foo() {\n+  a { b { c } d }\n+}\n+\"#,\n+    vec![\n+        SpanLabel {\n+            start: Position {\n+                string: \"b\",\n+                count: 1,\n+            },\n+            end: Position {\n+                string: \"}\",\n+                count: 1,\n+            },\n+            label: \"\",\n+        },\n+        SpanLabel {\n+            start: Position {\n+                string: \"a\",\n+                count: 1,\n+            },\n+            end: Position {\n+                string: \"d\",\n+                count: 1,\n+            },\n+            label: \"`a` is a good letter\",\n+        },\n+        SpanLabel {\n+            start: Position {\n+                string: \"c\",\n+                count: 1,\n+            },\n+            end: Position {\n+                string: \"c\",\n+                count: 1,\n+            },\n+            label: \"\",\n+        },\n+    ],\n+    r#\"\n+error: foo\n+ --> test.rs:3:7\n+  |\n+3 |   a { b { c } d }\n+  |   ----^^^^-^^-- `a` is a good letter\n+\n+\"#);\n+}\n+\n+#[test]\n+fn multiple_labels_secondary_without_message() {\n+    test_harness(r#\"\n+fn foo() {\n+  a { b { c } d }\n+}\n+\"#,\n+    vec![\n+        SpanLabel {\n+            start: Position {\n+                string: \"a\",\n+                count: 1,\n+            },\n+            end: Position {\n+                string: \"d\",\n+                count: 1,\n+            },\n+            label: \"`a` is a good letter\",\n+        },\n+        SpanLabel {\n+            start: Position {\n+                string: \"b\",\n+                count: 1,\n+            },\n+            end: Position {\n+                string: \"}\",\n+                count: 1,\n+            },\n+            label: \"\",\n+        },\n+    ],\n+    r#\"\n+error: foo\n+ --> test.rs:3:3\n+  |\n+3 |   a { b { c } d }\n+  |   ^^^^-------^^ `a` is a good letter\n+\n+\"#);\n+}\n+\n+#[test]\n+fn multiple_labels_primary_without_message_2() {\n+    test_harness(r#\"\n+fn foo() {\n+  a { b { c } d }\n+}\n+\"#,\n+    vec![\n+        SpanLabel {\n+            start: Position {\n+                string: \"b\",\n+                count: 1,\n+            },\n+            end: Position {\n+                string: \"}\",\n+                count: 1,\n+            },\n+            label: \"`b` is a good letter\",\n+        },\n+        SpanLabel {\n+            start: Position {\n+                string: \"a\",\n+                count: 1,\n+            },\n+            end: Position {\n+                string: \"d\",\n+                count: 1,\n+            },\n+            label: \"\",\n+        },\n+        SpanLabel {\n+            start: Position {\n+                string: \"c\",\n+                count: 1,\n+            },\n+            end: Position {\n+                string: \"c\",\n+                count: 1,\n+            },\n+            label: \"\",\n+        },\n+    ],\n+    r#\"\n+error: foo\n+ --> test.rs:3:7\n+  |\n+3 |   a { b { c } d }\n+  |   ----^^^^-^^--\n+  |       |\n+  |       `b` is a good letter\n+\n+\"#);\n+}\n+\n+#[test]\n+fn multiple_labels_secondary_without_message_2() {\n+    test_harness(r#\"\n+fn foo() {\n+  a { b { c } d }\n+}\n+\"#,\n+    vec![\n+        SpanLabel {\n+            start: Position {\n+                string: \"a\",\n+                count: 1,\n+            },\n+            end: Position {\n+                string: \"d\",\n+                count: 1,\n+            },\n+            label: \"\",\n+        },\n+        SpanLabel {\n+            start: Position {\n+                string: \"b\",\n+                count: 1,\n+            },\n+            end: Position {\n+                string: \"}\",\n+                count: 1,\n+            },\n+            label: \"`b` is a good letter\",\n+        },\n+    ],\n+    r#\"\n+error: foo\n+ --> test.rs:3:3\n+  |\n+3 |   a { b { c } d }\n+  |   ^^^^-------^^\n+  |       |\n+  |       `b` is a good letter\n+\n+\"#);\n+}\n+\n+#[test]\n+fn multiple_labels_without_message() {\n+    test_harness(r#\"\n+fn foo() {\n+  a { b { c } d }\n+}\n+\"#,\n+    vec![\n+        SpanLabel {\n+            start: Position {\n+                string: \"a\",\n+                count: 1,\n+            },\n+            end: Position {\n+                string: \"d\",\n+                count: 1,\n+            },\n+            label: \"\",\n+        },\n+        SpanLabel {\n+            start: Position {\n+                string: \"b\",\n+                count: 1,\n+            },\n+            end: Position {\n+                string: \"}\",\n+                count: 1,\n+            },\n+            label: \"\",\n+        },\n+    ],\n+    r#\"\n+error: foo\n+ --> test.rs:3:3\n+  |\n+3 |   a { b { c } d }\n+  |   ^^^^-------^^\n+\n+\"#);\n+}\n+\n+#[test]\n+fn multiple_labels_without_message_2() {\n+    test_harness(r#\"\n+fn foo() {\n+  a { b { c } d }\n+}\n+\"#,\n+    vec![\n+        SpanLabel {\n+            start: Position {\n+                string: \"b\",\n+                count: 1,\n+            },\n+            end: Position {\n+                string: \"}\",\n+                count: 1,\n+            },\n+            label: \"\",\n+        },\n+        SpanLabel {\n+            start: Position {\n+                string: \"a\",\n+                count: 1,\n+            },\n+            end: Position {\n+                string: \"d\",\n+                count: 1,\n+            },\n+            label: \"\",\n+        },\n+        SpanLabel {\n+            start: Position {\n+                string: \"c\",\n+                count: 1,\n+            },\n+            end: Position {\n+                string: \"c\",\n+                count: 1,\n+            },\n+            label: \"\",\n+        },\n+    ],\n+    r#\"\n+error: foo\n+ --> test.rs:3:7\n+  |\n+3 |   a { b { c } d }\n+  |   ----^^^^-^^--\n+\n+\"#);\n+}\n+\n+#[test]\n+fn multiple_labels_with_message() {\n+    test_harness(r#\"\n+fn foo() {\n+  a { b { c } d }\n+}\n+\"#,\n+    vec![\n+        SpanLabel {\n+            start: Position {\n+                string: \"a\",\n+                count: 1,\n+            },\n+            end: Position {\n+                string: \"d\",\n+                count: 1,\n+            },\n+            label: \"`a` is a good letter\",\n+        },\n+        SpanLabel {\n+            start: Position {\n+                string: \"b\",\n+                count: 1,\n+            },\n+            end: Position {\n+                string: \"}\",\n+                count: 1,\n+            },\n+            label: \"`b` is a good letter\",\n+        },\n+    ],\n+    r#\"\n+error: foo\n+ --> test.rs:3:3\n+  |\n+3 |   a { b { c } d }\n+  |   ^^^^-------^^\n+  |   |   |\n+  |   |   `b` is a good letter\n+  |   `a` is a good letter\n+\n+\"#);\n+}\n+\n+#[test]\n+fn single_label_with_message() {\n+    test_harness(r#\"\n+fn foo() {\n+  a { b { c } d }\n+}\n+\"#,\n+    vec![\n+        SpanLabel {\n+            start: Position {\n+                string: \"a\",\n+                count: 1,\n+            },\n+            end: Position {\n+                string: \"d\",\n+                count: 1,\n+            },\n+            label: \"`a` is a good letter\",\n+        },\n+    ],\n+    r#\"\n+error: foo\n+ --> test.rs:3:3\n+  |\n+3 |   a { b { c } d }\n+  |   ^^^^^^^^^^^^^ `a` is a good letter\n+\n+\"#);\n+}\n+\n+#[test]\n+fn single_label_without_message() {\n+    test_harness(r#\"\n+fn foo() {\n+  a { b { c } d }\n+}\n+\"#,\n+    vec![\n+        SpanLabel {\n+            start: Position {\n+                string: \"a\",\n+                count: 1,\n+            },\n+            end: Position {\n+                string: \"d\",\n+                count: 1,\n+            },\n+            label: \"\",\n+        },\n+    ],\n+    r#\"\n+error: foo\n+ --> test.rs:3:3\n+  |\n+3 |   a { b { c } d }\n+  |   ^^^^^^^^^^^^^\n+\n+\"#);\n+}"}]}