{"sha": "354eb0da9f15950ac2c53a0f69d102cc4ba6597f", "node_id": "MDY6Q29tbWl0NzI0NzEyOjM1NGViMGRhOWYxNTk1MGFjMmM1M2EwZjY5ZDEwMmNjNGJhNjU5N2Y=", "commit": {"author": {"name": "bjorn3", "email": "bjorn3@users.noreply.github.com", "date": "2019-03-03T15:33:46Z"}, "committer": {"name": "bjorn3", "email": "bjorn3@users.noreply.github.com", "date": "2019-03-06T19:57:14Z"}, "message": "Fix write_cvalue type assert for late bound regions in trait objects", "tree": {"sha": "c7859085471682701bf4669ed92fbd2a236dad86", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c7859085471682701bf4669ed92fbd2a236dad86"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/354eb0da9f15950ac2c53a0f69d102cc4ba6597f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/354eb0da9f15950ac2c53a0f69d102cc4ba6597f", "html_url": "https://github.com/rust-lang/rust/commit/354eb0da9f15950ac2c53a0f69d102cc4ba6597f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/354eb0da9f15950ac2c53a0f69d102cc4ba6597f/comments", "author": {"login": "bjorn3", "id": 17426603, "node_id": "MDQ6VXNlcjE3NDI2NjAz", "avatar_url": "https://avatars.githubusercontent.com/u/17426603?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bjorn3", "html_url": "https://github.com/bjorn3", "followers_url": "https://api.github.com/users/bjorn3/followers", "following_url": "https://api.github.com/users/bjorn3/following{/other_user}", "gists_url": "https://api.github.com/users/bjorn3/gists{/gist_id}", "starred_url": "https://api.github.com/users/bjorn3/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bjorn3/subscriptions", "organizations_url": "https://api.github.com/users/bjorn3/orgs", "repos_url": "https://api.github.com/users/bjorn3/repos", "events_url": "https://api.github.com/users/bjorn3/events{/privacy}", "received_events_url": "https://api.github.com/users/bjorn3/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bjorn3", "id": 17426603, "node_id": "MDQ6VXNlcjE3NDI2NjAz", "avatar_url": "https://avatars.githubusercontent.com/u/17426603?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bjorn3", "html_url": "https://github.com/bjorn3", "followers_url": "https://api.github.com/users/bjorn3/followers", "following_url": "https://api.github.com/users/bjorn3/following{/other_user}", "gists_url": "https://api.github.com/users/bjorn3/gists{/gist_id}", "starred_url": "https://api.github.com/users/bjorn3/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bjorn3/subscriptions", "organizations_url": "https://api.github.com/users/bjorn3/orgs", "repos_url": "https://api.github.com/users/bjorn3/repos", "events_url": "https://api.github.com/users/bjorn3/events{/privacy}", "received_events_url": "https://api.github.com/users/bjorn3/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e09ae252992acb2d646e8f749d92752fac5f85c6", "url": "https://api.github.com/repos/rust-lang/rust/commits/e09ae252992acb2d646e8f749d92752fac5f85c6", "html_url": "https://github.com/rust-lang/rust/commit/e09ae252992acb2d646e8f749d92752fac5f85c6"}], "stats": {"total": 99, "additions": 59, "deletions": 40}, "files": [{"sha": "3e51d1e6904c560799bee6938c8e486494dec9b3", "filename": "src/common.rs", "status": "modified", "additions": 59, "deletions": 40, "changes": 99, "blob_url": "https://github.com/rust-lang/rust/blob/354eb0da9f15950ac2c53a0f69d102cc4ba6597f/src%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/354eb0da9f15950ac2c53a0f69d102cc4ba6597f/src%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcommon.rs?ref=354eb0da9f15950ac2c53a0f69d102cc4ba6597f", "patch": "@@ -320,51 +320,70 @@ impl<'a, 'tcx: 'a> CPlace<'tcx> {\n     }\n \n     pub fn write_cvalue(self, fx: &mut FunctionCx<'a, 'tcx, impl Backend>, from: CValue<'tcx>) {\n+        use rustc::hir::Mutability::*;\n+\n         let from_ty = from.layout().ty;\n         let to_ty = self.layout().ty;\n-        match (&from_ty.sty, &to_ty.sty) {\n-            (ty::Ref(_, t, src_mut), ty::Ref(_, u, dest_mut))\n-                if (if *dest_mut != crate::rustc::hir::Mutability::MutImmutable\n-                    && src_mut != dest_mut\n-                {\n-                    false\n-                } else if t != u {\n-                    false\n-                } else {\n-                    true\n-                }) =>\n-            {\n-                // &mut T -> &T is allowed\n-                // &'a T -> &'b T is allowed\n-            }\n-            (ty::FnPtr(_), ty::FnPtr(_)) => {\n-                let from_sig = fx.tcx.normalize_erasing_late_bound_regions(\n-                    ParamEnv::reveal_all(),\n-                    &from_ty.fn_sig(fx.tcx),\n-                );\n-                let to_sig = fx.tcx.normalize_erasing_late_bound_regions(\n-                    ParamEnv::reveal_all(),\n-                    &to_ty.fn_sig(fx.tcx),\n-                );\n-                assert_eq!(\n-                    from_sig, to_sig,\n-                    \"Can't write fn ptr with incompatible sig {:?} to place with sig {:?}\\n\\n{:#?}\",\n-                    from_sig, to_sig, fx,\n-                );\n-                // fn(&T) -> for<'l> fn(&'l T) is allowed\n-            }\n-            _ => {\n-                assert_eq!(\n-                    from_ty,\n-                    to_ty,\n-                    \"Can't write value with incompatible type {:?} to place with type {:?}\\n\\n{:#?}\",\n-                    from_ty.sty,\n-                    to_ty.sty,\n-                    fx,\n-                );\n+\n+        fn assert_assignable<'a, 'tcx: 'a>(fx: &FunctionCx<'a, 'tcx, impl Backend>, from_ty: Ty<'tcx>, to_ty: Ty<'tcx>) {\n+            match (&from_ty.sty, &to_ty.sty) {\n+                (ty::Ref(_, t, MutImmutable), ty::Ref(_, u, MutImmutable))\n+                | (ty::Ref(_, t, MutMutable), ty::Ref(_, u, MutImmutable))\n+                | (ty::Ref(_, t, MutMutable), ty::Ref(_, u, MutMutable)) => {\n+                    assert_assignable(fx, t, u);\n+                    // &mut T -> &T is allowed\n+                    // &'a T -> &'b T is allowed\n+                }\n+                (ty::Ref(_, _, MutImmutable), ty::Ref(_, _, MutMutable)) => {\n+                    panic!(\"Cant assign value of type {} to place of type {}\", from_ty.sty, to_ty.sty)\n+                }\n+                (ty::FnPtr(_), ty::FnPtr(_)) => {\n+                    let from_sig = fx.tcx.normalize_erasing_late_bound_regions(\n+                        ParamEnv::reveal_all(),\n+                        &from_ty.fn_sig(fx.tcx),\n+                    );\n+                    let to_sig = fx.tcx.normalize_erasing_late_bound_regions(\n+                        ParamEnv::reveal_all(),\n+                        &to_ty.fn_sig(fx.tcx),\n+                    );\n+                    assert_eq!(\n+                        from_sig, to_sig,\n+                        \"Can't write fn ptr with incompatible sig {:?} to place with sig {:?}\\n\\n{:#?}\",\n+                        from_sig, to_sig, fx,\n+                    );\n+                    // fn(&T) -> for<'l> fn(&'l T) is allowed\n+                }\n+                (ty::Dynamic(from_traits, _), ty::Dynamic(to_traits, _)) => {\n+                    let from_traits = fx.tcx.normalize_erasing_late_bound_regions(\n+                        ParamEnv::reveal_all(),\n+                        from_traits,\n+                    );\n+                    let to_traits = fx.tcx.normalize_erasing_late_bound_regions(\n+                        ParamEnv::reveal_all(),\n+                        to_traits,\n+                    );\n+                    assert_eq!(\n+                        from_traits, to_traits,\n+                        \"Can't write trait object of incompatible traits {:?} to place with traits {:?}\\n\\n{:#?}\",\n+                        from_traits, to_traits, fx,\n+                    );\n+                    // dyn for<'r> Trait<'r> -> dyn Trait<'_> is allowed\n+                }\n+                _ => {\n+                    assert_eq!(\n+                        from_ty,\n+                        to_ty,\n+                        \"Can't write value with incompatible type {:?} to place with type {:?}\\n\\n{:#?}\",\n+                        from_ty.sty,\n+                        to_ty.sty,\n+                        fx,\n+                    );\n+                }\n             }\n         }\n \n+        assert_assignable(fx, from_ty, to_ty);\n+\n         let (addr, dst_layout) = match self {\n             CPlace::Var(var, _) => {\n                 let data = from.load_scalar(fx);"}]}