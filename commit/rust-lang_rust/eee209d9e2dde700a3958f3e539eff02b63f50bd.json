{"sha": "eee209d9e2dde700a3958f3e539eff02b63f50bd", "node_id": "MDY6Q29tbWl0NzI0NzEyOmVlZTIwOWQ5ZTJkZGU3MDBhMzk1OGYzZTUzOWVmZjAyYjYzZjUwYmQ=", "commit": {"author": {"name": "James Miller", "email": "james@aatch.net", "date": "2014-12-15T23:21:08Z"}, "committer": {"name": "James Miller", "email": "james@aatch.net", "date": "2014-12-18T02:28:33Z"}, "message": "Only count nested returns when the outer return is reachable\n\nThis narrows the definition of nested returns such that only when the\nouter return has a chance of being executed (due to the inner return\nbeing conditional) do we mark the function as having nested returns.\n\nFixes #19684", "tree": {"sha": "822db6930a4286a44cc638cd11c7919908752538", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/822db6930a4286a44cc638cd11c7919908752538"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/eee209d9e2dde700a3958f3e539eff02b63f50bd", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/eee209d9e2dde700a3958f3e539eff02b63f50bd", "html_url": "https://github.com/rust-lang/rust/commit/eee209d9e2dde700a3958f3e539eff02b63f50bd", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/eee209d9e2dde700a3958f3e539eff02b63f50bd/comments", "author": {"login": "Aatch", "id": 342416, "node_id": "MDQ6VXNlcjM0MjQxNg==", "avatar_url": "https://avatars.githubusercontent.com/u/342416?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Aatch", "html_url": "https://github.com/Aatch", "followers_url": "https://api.github.com/users/Aatch/followers", "following_url": "https://api.github.com/users/Aatch/following{/other_user}", "gists_url": "https://api.github.com/users/Aatch/gists{/gist_id}", "starred_url": "https://api.github.com/users/Aatch/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Aatch/subscriptions", "organizations_url": "https://api.github.com/users/Aatch/orgs", "repos_url": "https://api.github.com/users/Aatch/repos", "events_url": "https://api.github.com/users/Aatch/events{/privacy}", "received_events_url": "https://api.github.com/users/Aatch/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Aatch", "id": 342416, "node_id": "MDQ6VXNlcjM0MjQxNg==", "avatar_url": "https://avatars.githubusercontent.com/u/342416?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Aatch", "html_url": "https://github.com/Aatch", "followers_url": "https://api.github.com/users/Aatch/followers", "following_url": "https://api.github.com/users/Aatch/following{/other_user}", "gists_url": "https://api.github.com/users/Aatch/gists{/gist_id}", "starred_url": "https://api.github.com/users/Aatch/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Aatch/subscriptions", "organizations_url": "https://api.github.com/users/Aatch/orgs", "repos_url": "https://api.github.com/users/Aatch/repos", "events_url": "https://api.github.com/users/Aatch/events{/privacy}", "received_events_url": "https://api.github.com/users/Aatch/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "22a9f250b5e2de64c13c0f056aec13eb086ef79d", "url": "https://api.github.com/repos/rust-lang/rust/commits/22a9f250b5e2de64c13c0f056aec13eb086ef79d", "html_url": "https://github.com/rust-lang/rust/commit/22a9f250b5e2de64c13c0f056aec13eb086ef79d"}], "stats": {"total": 143, "additions": 99, "deletions": 44}, "files": [{"sha": "0e9bd42a23a138a257896b1fb52194069ab4ea01", "filename": "src/librustc/middle/cfg/mod.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/eee209d9e2dde700a3958f3e539eff02b63f50bd/src%2Flibrustc%2Fmiddle%2Fcfg%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eee209d9e2dde700a3958f3e539eff02b63f50bd/src%2Flibrustc%2Fmiddle%2Fcfg%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcfg%2Fmod.rs?ref=eee209d9e2dde700a3958f3e539eff02b63f50bd", "patch": "@@ -49,4 +49,11 @@ impl CFG {\n                blk: &ast::Block) -> CFG {\n         construct::construct(tcx, blk)\n     }\n+\n+    pub fn node_is_reachable(&self, id: ast::NodeId) -> bool {\n+        for node in self.graph.depth_traverse(self.entry) {\n+            if node.id == id { return true }\n+        }\n+        return false;\n+    }\n }"}, {"sha": "4397f03a642867691e878c1e653ed5ce11664010", "filename": "src/librustc/middle/graph.rs", "status": "modified", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/eee209d9e2dde700a3958f3e539eff02b63f50bd/src%2Flibrustc%2Fmiddle%2Fgraph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eee209d9e2dde700a3958f3e539eff02b63f50bd/src%2Flibrustc%2Fmiddle%2Fgraph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fgraph.rs?ref=eee209d9e2dde700a3958f3e539eff02b63f50bd", "patch": "@@ -34,6 +34,7 @@\n \n use std::fmt::{Formatter, Error, Show};\n use std::uint;\n+use std::collections::BitvSet;\n \n pub struct Graph<N,E> {\n     nodes: Vec<Node<N>> ,\n@@ -294,6 +295,42 @@ impl<N,E> Graph<N,E> {\n             }\n         }\n     }\n+\n+    pub fn depth_traverse<'a>(&'a self, start: NodeIndex) -> DepthFirstTraversal<'a, N, E>  {\n+        DepthFirstTraversal {\n+            graph: self,\n+            stack: vec![start],\n+            visited: BitvSet::new()\n+        }\n+    }\n+}\n+\n+pub struct DepthFirstTraversal<'g, N:'g, E:'g> {\n+    graph: &'g Graph<N, E>,\n+    stack: Vec<NodeIndex>,\n+    visited: BitvSet\n+}\n+\n+impl<'g, N, E> Iterator<&'g N> for DepthFirstTraversal<'g, N, E> {\n+    fn next(&mut self) -> Option<&'g N> {\n+        while self.stack.len() > 0 {\n+            let idx = self.stack.pop().unwrap();\n+            if self.visited.contains(&idx.node_id()) {\n+                continue;\n+            }\n+            self.visited.insert(idx.node_id());\n+            self.graph.each_outgoing_edge(idx, |_, e| -> bool {\n+                if !self.visited.contains(&e.target().node_id()) {\n+                    self.stack.push(e.target());\n+                }\n+                true\n+            });\n+\n+            return Some(self.graph.node_data(idx));\n+        }\n+\n+        return None;\n+    }\n }\n \n pub fn each_edge_index<F>(max_edge_index: EdgeIndex, mut f: F) where"}, {"sha": "82d3edfa5e04583ea3c2f46e2c7c2e7a2230c201", "filename": "src/librustc_driver/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/eee209d9e2dde700a3958f3e539eff02b63f50bd/src%2Flibrustc_driver%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eee209d9e2dde700a3958f3e539eff02b63f50bd/src%2Flibrustc_driver%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Flib.rs?ref=eee209d9e2dde700a3958f3e539eff02b63f50bd", "patch": "@@ -472,7 +472,7 @@ pub fn list_metadata(sess: &Session, path: &Path,\n /// The diagnostic emitter yielded to the procedure should be used for reporting\n /// errors of the compiler.\n pub fn monitor<F:FnOnce()+Send>(f: F) {\n-    static STACK_SIZE: uint = 32000000; // 32MB\n+    static STACK_SIZE: uint = 8 * 1024 * 1024; // 8MB\n \n     let (tx, rx) = channel();\n     let w = io::ChanWriter::new(tx);"}, {"sha": "1a82a7131a7744a1d3069096c84002798ca8643b", "filename": "src/librustc_trans/trans/base.rs", "status": "modified", "additions": 51, "deletions": 43, "changes": 94, "blob_url": "https://github.com/rust-lang/rust/blob/eee209d9e2dde700a3958f3e539eff02b63f50bd/src%2Flibrustc_trans%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eee209d9e2dde700a3958f3e539eff02b63f50bd/src%2Flibrustc_trans%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fbase.rs?ref=eee209d9e2dde700a3958f3e539eff02b63f50bd", "patch": "@@ -38,6 +38,7 @@ use llvm::{BasicBlockRef, Linkage, ValueRef, Vector, get_param};\n use llvm;\n use metadata::{csearch, encoder, loader};\n use middle::astencode;\n+use middle::cfg;\n use middle::lang_items::{LangItem, ExchangeMallocFnLangItem, StartFnLangItem};\n use middle::subst;\n use middle::weak_lang_items;\n@@ -1305,47 +1306,33 @@ pub fn make_return_slot_pointer<'a, 'tcx>(fcx: &FunctionContext<'a, 'tcx>,\n     }\n }\n \n-struct CheckForNestedReturnsVisitor {\n+struct FindNestedReturn {\n     found: bool,\n-    in_return: bool\n }\n \n-impl CheckForNestedReturnsVisitor {\n-    fn explicit() -> CheckForNestedReturnsVisitor {\n-        CheckForNestedReturnsVisitor { found: false, in_return: false }\n-    }\n-    fn implicit() -> CheckForNestedReturnsVisitor {\n-        CheckForNestedReturnsVisitor { found: false, in_return: true }\n+impl FindNestedReturn {\n+    fn new() -> FindNestedReturn {\n+        FindNestedReturn { found: false }\n     }\n }\n \n-impl<'v> Visitor<'v> for CheckForNestedReturnsVisitor {\n+impl<'v> Visitor<'v> for FindNestedReturn {\n     fn visit_expr(&mut self, e: &ast::Expr) {\n         match e.node {\n             ast::ExprRet(..) => {\n-                if self.in_return {\n-                    self.found = true;\n-                } else {\n-                    self.in_return = true;\n-                    visit::walk_expr(self, e);\n-                    self.in_return = false;\n-                }\n+                self.found = true;\n             }\n             _ => visit::walk_expr(self, e)\n         }\n     }\n }\n \n-fn has_nested_returns(tcx: &ty::ctxt, id: ast::NodeId) -> bool {\n-    match tcx.map.find(id) {\n+fn build_cfg(tcx: &ty::ctxt, id: ast::NodeId) -> (ast::NodeId, Option<cfg::CFG>) {\n+    let blk = match tcx.map.find(id) {\n         Some(ast_map::NodeItem(i)) => {\n             match i.node {\n                 ast::ItemFn(_, _, _, _, ref blk) => {\n-                    let mut explicit = CheckForNestedReturnsVisitor::explicit();\n-                    let mut implicit = CheckForNestedReturnsVisitor::implicit();\n-                    visit::walk_item(&mut explicit, &*i);\n-                    visit::walk_expr_opt(&mut implicit, &blk.expr);\n-                    explicit.found || implicit.found\n+                    blk\n                 }\n                 _ => tcx.sess.bug(\"unexpected item variant in has_nested_returns\")\n             }\n@@ -1355,11 +1342,7 @@ fn has_nested_returns(tcx: &ty::ctxt, id: ast::NodeId) -> bool {\n                 ast::ProvidedMethod(ref m) => {\n                     match m.node {\n                         ast::MethDecl(_, _, _, _, _, _, ref blk, _) => {\n-                            let mut explicit = CheckForNestedReturnsVisitor::explicit();\n-                            let mut implicit = CheckForNestedReturnsVisitor::implicit();\n-                            visit::walk_method_helper(&mut explicit, &**m);\n-                            visit::walk_expr_opt(&mut implicit, &blk.expr);\n-                            explicit.found || implicit.found\n+                            blk\n                         }\n                         ast::MethMac(_) => tcx.sess.bug(\"unexpanded macro\")\n                     }\n@@ -1379,11 +1362,7 @@ fn has_nested_returns(tcx: &ty::ctxt, id: ast::NodeId) -> bool {\n                 ast::MethodImplItem(ref m) => {\n                     match m.node {\n                         ast::MethDecl(_, _, _, _, _, _, ref blk, _) => {\n-                            let mut explicit = CheckForNestedReturnsVisitor::explicit();\n-                            let mut implicit = CheckForNestedReturnsVisitor::implicit();\n-                            visit::walk_method_helper(&mut explicit, &**m);\n-                            visit::walk_expr_opt(&mut implicit, &blk.expr);\n-                            explicit.found || implicit.found\n+                            blk\n                         }\n                         ast::MethMac(_) => tcx.sess.bug(\"unexpanded macro\")\n                     }\n@@ -1397,24 +1376,47 @@ fn has_nested_returns(tcx: &ty::ctxt, id: ast::NodeId) -> bool {\n         Some(ast_map::NodeExpr(e)) => {\n             match e.node {\n                 ast::ExprClosure(_, _, _, ref blk) => {\n-                    let mut explicit = CheckForNestedReturnsVisitor::explicit();\n-                    let mut implicit = CheckForNestedReturnsVisitor::implicit();\n-                    visit::walk_expr(&mut explicit, e);\n-                    visit::walk_expr_opt(&mut implicit, &blk.expr);\n-                    explicit.found || implicit.found\n+                    blk\n                 }\n                 _ => tcx.sess.bug(\"unexpected expr variant in has_nested_returns\")\n             }\n         }\n-\n-        Some(ast_map::NodeVariant(..)) | Some(ast_map::NodeStructCtor(..)) => false,\n+        Some(ast_map::NodeVariant(..)) | Some(ast_map::NodeStructCtor(..)) => return (ast::DUMMY_NODE_ID, None),\n \n         // glue, shims, etc\n-        None if id == ast::DUMMY_NODE_ID => false,\n+        None if id == ast::DUMMY_NODE_ID => return (ast::DUMMY_NODE_ID, None),\n \n         _ => tcx.sess.bug(format!(\"unexpected variant in has_nested_returns: {}\",\n                                   tcx.map.path_to_string(id)).as_slice())\n+    };\n+\n+    (blk.id, Some(cfg::CFG::new(tcx, &**blk)))\n+}\n+\n+fn has_nested_returns(tcx: &ty::ctxt, cfg: &cfg::CFG, blk_id: ast::NodeId) -> bool {\n+    for n in cfg.graph.depth_traverse(cfg.entry) {\n+        match tcx.map.find(n.id) {\n+            Some(ast_map::NodeExpr(ex)) => {\n+                if let ast::ExprRet(Some(ref ret_expr)) = ex.node {\n+                    let mut visitor = FindNestedReturn::new();\n+                    visit::walk_expr(&mut visitor, &**ret_expr);\n+                    if visitor.found {\n+                        return true;\n+                    }\n+                }\n+            }\n+            Some(ast_map::NodeBlock(blk)) if blk.id == blk_id => {\n+                let mut visitor = FindNestedReturn::new();\n+                visit::walk_expr_opt(&mut visitor, &blk.expr);\n+                if visitor.found {\n+                    return true;\n+                }\n+            }\n+            _ => {}\n+        }\n     }\n+\n+    return false;\n }\n \n // NB: must keep 4 fns in sync:\n@@ -1453,7 +1455,12 @@ pub fn new_fn_ctxt<'a, 'tcx>(ccx: &'a CrateContext<'a, 'tcx>,\n         ty::FnDiverging => false\n     };\n     let debug_context = debuginfo::create_function_debug_context(ccx, id, param_substs, llfndecl);\n-    let nested_returns = has_nested_returns(ccx.tcx(), id);\n+    let (blk_id, cfg) = build_cfg(ccx.tcx(), id);\n+    let nested_returns = if let Some(ref cfg) = cfg {\n+       has_nested_returns(ccx.tcx(), cfg, blk_id)\n+    } else {\n+        false\n+    };\n \n     let mut fcx = FunctionContext {\n           llfn: llfndecl,\n@@ -1472,7 +1479,8 @@ pub fn new_fn_ctxt<'a, 'tcx>(ccx: &'a CrateContext<'a, 'tcx>,\n           block_arena: block_arena,\n           ccx: ccx,\n           debug_context: debug_context,\n-          scopes: RefCell::new(Vec::new())\n+          scopes: RefCell::new(Vec::new()),\n+          cfg: cfg\n     };\n \n     if has_env {"}, {"sha": "c8a628a33e7a1f7dbaa103887f35d613412944e1", "filename": "src/librustc_trans/trans/common.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/eee209d9e2dde700a3958f3e539eff02b63f50bd/src%2Flibrustc_trans%2Ftrans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eee209d9e2dde700a3958f3e539eff02b63f50bd/src%2Flibrustc_trans%2Ftrans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fcommon.rs?ref=eee209d9e2dde700a3958f3e539eff02b63f50bd", "patch": "@@ -18,6 +18,7 @@ use session::Session;\n use llvm;\n use llvm::{ValueRef, BasicBlockRef, BuilderRef, ContextRef};\n use llvm::{True, False, Bool};\n+use middle::cfg;\n use middle::def;\n use middle::infer;\n use middle::lang_items::LangItem;\n@@ -264,6 +265,8 @@ pub struct FunctionContext<'a, 'tcx: 'a> {\n \n     // Cleanup scopes.\n     pub scopes: RefCell<Vec<cleanup::CleanupScope<'a, 'tcx>>>,\n+\n+    pub cfg: Option<cfg::CFG>,\n }\n \n impl<'a, 'tcx> FunctionContext<'a, 'tcx> {"}]}