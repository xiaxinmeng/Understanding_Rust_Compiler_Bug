{"sha": "961bd48724a3b9e75685d23d8d0e52a20f6ccf68", "node_id": "MDY6Q29tbWl0NzI0NzEyOjk2MWJkNDg3MjRhM2I5ZTc1Njg1ZDIzZDhkMGU1MmEyMGY2Y2NmNjg=", "commit": {"author": {"name": "Elliott Slaughter", "email": "eslaughter@mozilla.com", "date": "2012-08-24T17:43:57Z"}, "committer": {"name": "Elliott Slaughter", "email": "eslaughter@mozilla.com", "date": "2012-09-07T16:21:22Z"}, "message": "gc: Fix for GC missing stack frames across segment boundaries.", "tree": {"sha": "3815a24c92cd9ba98ddcfd4780652f7763a97cf1", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3815a24c92cd9ba98ddcfd4780652f7763a97cf1"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/961bd48724a3b9e75685d23d8d0e52a20f6ccf68", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/961bd48724a3b9e75685d23d8d0e52a20f6ccf68", "html_url": "https://github.com/rust-lang/rust/commit/961bd48724a3b9e75685d23d8d0e52a20f6ccf68", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/961bd48724a3b9e75685d23d8d0e52a20f6ccf68/comments", "author": null, "committer": null, "parents": [{"sha": "578b036f9b0415852aae0af9286ff53630fa1c56", "url": "https://api.github.com/repos/rust-lang/rust/commits/578b036f9b0415852aae0af9286ff53630fa1c56", "html_url": "https://github.com/rust-lang/rust/commit/578b036f9b0415852aae0af9286ff53630fa1c56"}], "stats": {"total": 155, "additions": 113, "deletions": 42}, "files": [{"sha": "bf3c7df91fbc183d52bc562e9a3d88b9d98b12b0", "filename": "src/libcore/gc.rs", "status": "modified", "additions": 100, "deletions": 35, "changes": 135, "blob_url": "https://github.com/rust-lang/rust/blob/961bd48724a3b9e75685d23d8d0e52a20f6ccf68/src%2Flibcore%2Fgc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/961bd48724a3b9e75685d23d8d0e52a20f6ccf68/src%2Flibcore%2Fgc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fgc.rs?ref=961bd48724a3b9e75685d23d8d0e52a20f6ccf68", "patch": "@@ -1,19 +1,38 @@\n import stackwalk::Word;\n import libc::size_t;\n+import libc::uintptr_t;\n import send_map::linear::LinearMap;\n \n export Word;\n export gc;\n export cleanup_stack_for_failure;\n \n+// Mirrors rust_stack.h stk_seg\n+struct StackSegment {\n+    let prev: *StackSegment;\n+    let next: *StackSegment;\n+    let end: uintptr_t;\n+    // And other fields which we don't care about...\n+}\n+\n extern mod rustrt {\n     fn rust_annihilate_box(ptr: *Word);\n \n     #[rust_stack]\n-    fn rust_gc_metadata() -> *Word;\n+    fn rust_call_tydesc_glue(root: *Word, tydesc: *Word, field: size_t);\n \n     #[rust_stack]\n-    fn rust_call_tydesc_glue(root: *Word, tydesc: *Word, field: size_t);\n+    fn rust_gc_metadata() -> *Word;\n+\n+    fn rust_get_stack_segment() -> *StackSegment;\n+}\n+\n+unsafe fn is_frame_in_segment(fp: *Word, segment: *StackSegment) -> bool {\n+    let begin: Word = unsafe::reinterpret_cast(&segment);\n+    let end: Word = unsafe::reinterpret_cast(&(*segment).end);\n+    let frame: Word = unsafe::reinterpret_cast(&fp);\n+\n+    return begin <= frame && frame <= end;\n }\n \n type SafePoint = { sp_meta: *Word, fn_meta: *Word };\n@@ -44,6 +63,17 @@ unsafe fn is_safe_point(pc: *Word) -> Option<SafePoint> {\n \n type Visitor = fn(root: **Word, tydesc: *Word) -> bool;\n \n+unsafe fn bump<T, U>(ptr: *T, count: uint) -> *U {\n+    return unsafe::reinterpret_cast(&ptr::offset(ptr, count));\n+}\n+\n+unsafe fn align_to_pointer<T>(ptr: *T) -> *T {\n+    let align = sys::min_align_of::<*T>();\n+    let ptr: uint = unsafe::reinterpret_cast(&ptr);\n+    let ptr = (ptr + (align - 1)) & -align;\n+    return unsafe::reinterpret_cast(&ptr);\n+}\n+\n unsafe fn walk_safe_point(fp: *Word, sp: SafePoint, visitor: Visitor) {\n     let fp_bytes: *u8 = unsafe::reinterpret_cast(&fp);\n     let sp_meta_u32s: *u32 = unsafe::reinterpret_cast(&sp.sp_meta);\n@@ -97,7 +127,35 @@ const stack:           Memory = 4;\n \n const need_cleanup:    Memory = exchange_heap | stack;\n \n+unsafe fn find_segment_for_frame(fp: *Word, segment: *StackSegment)\n+    -> {segment: *StackSegment, boundary: bool} {\n+    // Check if frame is in either current frame or previous frame.\n+    let in_segment = is_frame_in_segment(fp, segment);\n+    let in_prev_segment = ptr::is_not_null((*segment).prev) &&\n+        is_frame_in_segment(fp, (*segment).prev);\n+\n+    // If frame is not in either segment, walk down segment list until\n+    // we find the segment containing this frame.\n+    if !in_segment && !in_prev_segment {\n+        let mut segment = segment;\n+        while ptr::is_not_null((*segment).next) &&\n+            is_frame_in_segment(fp, (*segment).next) {\n+            segment = (*segment).next;\n+        }\n+        return {segment: segment, boundary: false};\n+    }\n+\n+    // If frame is in previous frame, then we're at a boundary.\n+    if !in_segment && in_prev_segment {\n+        return {segment: (*segment).prev, boundary: true};\n+    }\n+\n+    // Otherwise, we're somewhere on the inside of the frame.\n+    return {segment: segment, boundary: false};\n+}\n+\n unsafe fn walk_gc_roots(mem: Memory, sentinel: **Word, visitor: Visitor) {\n+    let mut segment = rustrt::rust_get_stack_segment();\n     let mut last_ret: *Word = ptr::null();\n     // To avoid collecting memory used by the GC itself, skip stack\n     // frames until past the root GC stack frame. The root GC stack\n@@ -106,48 +164,55 @@ unsafe fn walk_gc_roots(mem: Memory, sentinel: **Word, visitor: Visitor) {\n     let mut reached_sentinel = ptr::is_null(sentinel);\n     for stackwalk::walk_stack |frame| {\n         unsafe {\n+            let pc = last_ret;\n+            let {segment: next_segment, boundary: boundary} =\n+                find_segment_for_frame(frame.fp, segment);\n+            segment = next_segment;\n+            let ret_offset = if boundary { 4 } else { 1 };\n+            last_ret = *ptr::offset(frame.fp, ret_offset) as *Word;\n+\n+            if ptr::is_null(pc) {\n+                again;\n+            }\n+\n             let mut delay_reached_sentinel = reached_sentinel;\n-            if ptr::is_not_null(last_ret) {\n-                let sp = is_safe_point(last_ret);\n-                match sp {\n-                  Some(sp_info) => {\n-                    for walk_safe_point(frame.fp, sp_info) |root, tydesc| {\n-                        // Skip roots until we see the sentinel.\n-                        if !reached_sentinel {\n-                            if root == sentinel {\n-                                delay_reached_sentinel = true;\n-                            }\n-                            again;\n+            let sp = is_safe_point(pc);\n+            match sp {\n+              Some(sp_info) => {\n+                for walk_safe_point(frame.fp, sp_info) |root, tydesc| {\n+                    // Skip roots until we see the sentinel.\n+                    if !reached_sentinel {\n+                        if root == sentinel {\n+                            delay_reached_sentinel = true;\n                         }\n+                        again;\n+                    }\n \n-                        // Skip null pointers, which can occur when a\n-                        // unique pointer has already been freed.\n-                        if ptr::is_null(*root) {\n-                            again;\n-                        }\n+                    // Skip null pointers, which can occur when a\n+                    // unique pointer has already been freed.\n+                    if ptr::is_null(*root) {\n+                        again;\n+                    }\n \n-                        if ptr::is_null(tydesc) {\n-                            // Root is a generic box.\n-                            let refcount = **root;\n-                            if mem | task_local_heap != 0 && refcount != -1 {\n-                                if !visitor(root, tydesc) { return; }\n-                            } else if mem | exchange_heap != 0\n-                                && refcount == -1 {\n-                                if !visitor(root, tydesc) { return; }\n-                            }\n-                        } else {\n-                            // Root is a non-immediate.\n-                            if mem | stack != 0 {\n-                                if !visitor(root, tydesc) { return; }\n-                            }\n+                    if ptr::is_null(tydesc) {\n+                        // Root is a generic box.\n+                        let refcount = **root;\n+                        if mem | task_local_heap != 0 && refcount != -1 {\n+                            if !visitor(root, tydesc) { return; }\n+                        } else if mem | exchange_heap != 0 && refcount == -1 {\n+                            if !visitor(root, tydesc) { return; }\n+                        }\n+                    } else {\n+                        // Root is a non-immediate.\n+                        if mem | stack != 0 {\n+                            if !visitor(root, tydesc) { return; }\n                         }\n                     }\n-                  }\n-                  None => ()\n                 }\n+              }\n+              None => ()\n             }\n             reached_sentinel = delay_reached_sentinel;\n-            last_ret = *ptr::offset(frame.fp, 1) as *Word;\n         }\n     }\n }"}, {"sha": "b72fdd15e3c0a3f0981b7f01f0c3c942a7b0f36d", "filename": "src/rt/rust_builtin.cpp", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/961bd48724a3b9e75685d23d8d0e52a20f6ccf68/src%2Frt%2Frust_builtin.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/961bd48724a3b9e75685d23d8d0e52a20f6ccf68/src%2Frt%2Frust_builtin.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_builtin.cpp?ref=961bd48724a3b9e75685d23d8d0e52a20f6ccf68", "patch": "@@ -610,6 +610,11 @@ rust_get_task() {\n     return rust_get_current_task();\n }\n \n+extern \"C\" CDECL stk_seg *\n+rust_get_stack_segment() {\n+    return rust_get_current_task()->stk;\n+}\n+\n extern \"C\" CDECL void\n start_task(rust_task *target, fn_env_pair *f) {\n     target->start(f->f, f->env, NULL);"}, {"sha": "baefe99ceee0bbe61fe00bc12f69a30a5901c821", "filename": "src/rt/rust_gc_metadata.cpp", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/961bd48724a3b9e75685d23d8d0e52a20f6ccf68/src%2Frt%2Frust_gc_metadata.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/961bd48724a3b9e75685d23d8d0e52a20f6ccf68/src%2Frt%2Frust_gc_metadata.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_gc_metadata.cpp?ref=961bd48724a3b9e75685d23d8d0e52a20f6ccf68", "patch": "@@ -6,9 +6,9 @@\n #include <vector>\n \n struct safe_point {\n-    size_t safe_point_loc;\n-    size_t safe_point_meta;\n-    size_t function_meta;\n+    uintptr_t safe_point_loc;\n+    uintptr_t safe_point_meta;\n+    uintptr_t function_meta;\n };\n \n struct update_gc_entry_args {\n@@ -19,7 +19,7 @@ static void\n update_gc_entry(const mod_entry* entry, void *cookie) {\n     update_gc_entry_args *args = (update_gc_entry_args *)cookie;\n     if (!strcmp(entry->name, \"_gc_module_metadata\")) {\n-        size_t *next = entry->state;\n+        uintptr_t *next = entry->state;\n         uint32_t num_safe_points = *(uint32_t *)next;\n         next++;\n \n@@ -37,7 +37,7 @@ cmp_safe_point(safe_point a, safe_point b) {\n     return a.safe_point_loc < b.safe_point_loc;\n }\n \n-size_t *global_safe_points = 0;\n+uintptr_t *global_safe_points = 0;\n \n void\n update_gc_metadata(const void* map) {\n@@ -50,10 +50,10 @@ update_gc_metadata(const void* map) {\n \n     // Serialize safe point list into format expected by runtime.\n     global_safe_points =\n-        (size_t *)malloc((safe_points.size()*3 + 1)*sizeof(size_t));\n+        (uintptr_t *)malloc((safe_points.size()*3 + 1)*sizeof(uintptr_t));\n     if (!global_safe_points) return;\n \n-    size_t *next = global_safe_points;\n+    uintptr_t *next = global_safe_points;\n     *(uint32_t *)next = safe_points.size();\n     next++;\n     for (uint32_t i = 0; i < safe_points.size(); i++) {"}, {"sha": "e9f2890893f9ebd174687bf1cd9ed67400b099fa", "filename": "src/rt/rustrt.def.in", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/961bd48724a3b9e75685d23d8d0e52a20f6ccf68/src%2Frt%2Frustrt.def.in", "raw_url": "https://github.com/rust-lang/rust/raw/961bd48724a3b9e75685d23d8d0e52a20f6ccf68/src%2Frt%2Frustrt.def.in", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frustrt.def.in?ref=961bd48724a3b9e75685d23d8d0e52a20f6ccf68", "patch": "@@ -54,6 +54,7 @@ rust_env_pairs\n rust_task_yield\n rust_task_is_unwinding\n rust_get_task\n+rust_get_stack_segment\n rust_task_weaken\n rust_task_unweaken\n sched_threads"}]}