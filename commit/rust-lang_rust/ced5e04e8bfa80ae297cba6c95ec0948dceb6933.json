{"sha": "ced5e04e8bfa80ae297cba6c95ec0948dceb6933", "node_id": "MDY6Q29tbWl0NzI0NzEyOmNlZDVlMDRlOGJmYTgwYWUyOTdjYmE2Yzk1ZWMwOTQ4ZGNlYjY5MzM=", "commit": {"author": {"name": "Eduard-Mihai Burtescu", "email": "edy.burt@gmail.com", "date": "2017-09-26T18:34:10Z"}, "committer": {"name": "Eduard-Mihai Burtescu", "email": "edy.burt@gmail.com", "date": "2017-11-19T00:14:33Z"}, "message": "rustc: optimize out uninhabited types and variants.", "tree": {"sha": "acb7b944d4fcdbb06ae6ecd786c7505616edc1ea", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/acb7b944d4fcdbb06ae6ecd786c7505616edc1ea"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ced5e04e8bfa80ae297cba6c95ec0948dceb6933", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ced5e04e8bfa80ae297cba6c95ec0948dceb6933", "html_url": "https://github.com/rust-lang/rust/commit/ced5e04e8bfa80ae297cba6c95ec0948dceb6933", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ced5e04e8bfa80ae297cba6c95ec0948dceb6933/comments", "author": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "committer": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f62e43da2891a65a484a917d84642544ed093ba2", "url": "https://api.github.com/repos/rust-lang/rust/commits/f62e43da2891a65a484a917d84642544ed093ba2", "html_url": "https://github.com/rust-lang/rust/commit/f62e43da2891a65a484a917d84642544ed093ba2"}], "stats": {"total": 289, "additions": 197, "deletions": 92}, "files": [{"sha": "0edd8f44f0ce192a99d0e4a3d079bc0ad7ba37ea", "filename": "src/librustc/ty/layout.rs", "status": "modified", "additions": 105, "deletions": 46, "changes": 151, "blob_url": "https://github.com/rust-lang/rust/blob/ced5e04e8bfa80ae297cba6c95ec0948dceb6933/src%2Flibrustc%2Fty%2Flayout.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ced5e04e8bfa80ae297cba6c95ec0948dceb6933/src%2Flibrustc%2Fty%2Flayout.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Flayout.rs?ref=ced5e04e8bfa80ae297cba6c95ec0948dceb6933", "patch": "@@ -755,6 +755,7 @@ impl FieldPlacement {\n /// in terms of categories of C types there are ABI rules for.\n #[derive(Clone, PartialEq, Eq, Hash, Debug)]\n pub enum Abi {\n+    Uninhabited,\n     Scalar(Scalar),\n     Vector,\n     Aggregate {\n@@ -768,15 +769,15 @@ impl Abi {\n     /// Returns true if the layout corresponds to an unsized type.\n     pub fn is_unsized(&self) -> bool {\n         match *self {\n-            Abi::Scalar(_) | Abi::Vector => false,\n+            Abi::Uninhabited | Abi::Scalar(_) | Abi::Vector => false,\n             Abi::Aggregate { sized, .. } => !sized\n         }\n     }\n \n     /// Returns true if the fields of the layout are packed.\n     pub fn is_packed(&self) -> bool {\n         match *self {\n-            Abi::Scalar(_) | Abi::Vector => false,\n+            Abi::Uninhabited | Abi::Scalar(_) | Abi::Vector => false,\n             Abi::Aggregate { packed, .. } => packed\n         }\n     }\n@@ -807,6 +808,7 @@ pub enum Variants {\n     /// `Some` is the identity function (with a non-null reference).\n     NicheFilling {\n         dataful_variant: usize,\n+        niche_variant: usize,\n         niche: Scalar,\n         niche_value: u128,\n         variants: Vec<CachedLayout>,\n@@ -855,6 +857,18 @@ impl CachedLayout {\n             primitive_align: align\n         }\n     }\n+\n+    fn uninhabited(field_count: usize) -> Self {\n+        let align = Align::from_bytes(1, 1).unwrap();\n+        CachedLayout {\n+            variants: Variants::Single { index: 0 },\n+            fields: FieldPlacement::Union(field_count),\n+            abi: Abi::Uninhabited,\n+            align,\n+            primitive_align: align,\n+            size: Size::from_bytes(0)\n+        }\n+    }\n }\n \n fn layout_raw<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n@@ -915,13 +929,14 @@ impl<'a, 'tcx> CachedLayout {\n                 bug!(\"struct cannot be packed and aligned\");\n             }\n \n-            let mut align = if packed {\n+            let base_align = if packed {\n                 dl.i8_align\n             } else {\n                 dl.aggregate_align\n             };\n \n-            let mut primitive_align = align;\n+            let mut align = base_align;\n+            let mut primitive_align = base_align;\n             let mut sized = true;\n \n             // Anything with repr(C) or repr(packed) doesn't optimize.\n@@ -978,13 +993,17 @@ impl<'a, 'tcx> CachedLayout {\n                 }\n             }\n \n-            for i in inverse_memory_index.iter() {\n-                let field = fields[*i as usize];\n+            for &i in &inverse_memory_index {\n+                let field = fields[i as usize];\n                 if !sized {\n                     bug!(\"univariant: field #{} of `{}` comes after unsized field\",\n                         offsets.len(), ty);\n                 }\n \n+                if field.abi == Abi::Uninhabited {\n+                    return Ok(CachedLayout::uninhabited(fields.len()));\n+                }\n+\n                 if field.is_unsized() {\n                     sized = false;\n                 }\n@@ -997,7 +1016,7 @@ impl<'a, 'tcx> CachedLayout {\n                 }\n \n                 debug!(\"univariant offset: {:?} field: {:#?}\", offset, field);\n-                offsets[*i as usize] = offset;\n+                offsets[i as usize] = offset;\n \n                 offset = offset.checked_add(field.size, dl)\n                     .ok_or(LayoutError::SizeOverflow(ty))?;\n@@ -1124,7 +1143,7 @@ impl<'a, 'tcx> CachedLayout {\n \n             // The never type.\n             ty::TyNever => {\n-                univariant(&[], &ReprOptions::default(), StructKind::AlwaysSized)?\n+                tcx.intern_layout(CachedLayout::uninhabited(0))\n             }\n \n             // Potentially-fat pointers.\n@@ -1278,11 +1297,15 @@ impl<'a, 'tcx> CachedLayout {\n                     }).collect::<Result<Vec<_>, _>>()\n                 }).collect::<Result<Vec<_>, _>>()?;\n \n-                if variants.is_empty() {\n-                    // Uninhabitable; represent as unit\n-                    // (Typechecking will reject discriminant-sizing attrs.)\n-\n-                    return univariant(&[], &def.repr, StructKind::AlwaysSized);\n+                let (inh_first, inh_second, inh_third) = {\n+                    let mut inh_variants = (0..variants.len()).filter(|&v| {\n+                        variants[v].iter().all(|f| f.abi != Abi::Uninhabited)\n+                    });\n+                    (inh_variants.next(), inh_variants.next(), inh_variants.next())\n+                };\n+                if inh_first.is_none() {\n+                    // Uninhabited because it has no variants, or only uninhabited ones.\n+                    return Ok(tcx.intern_layout(CachedLayout::uninhabited(0)));\n                 }\n \n                 if def.is_union() {\n@@ -1329,49 +1352,58 @@ impl<'a, 'tcx> CachedLayout {\n                     }));\n                 }\n \n-                if !def.is_enum() || (variants.len() == 1 &&\n-                                      !def.repr.inhibit_enum_layout_opt() &&\n-                                      !variants[0].is_empty()) {\n-                    // Struct, or union, or univariant enum equivalent to a struct.\n+                let is_struct = !def.is_enum() ||\n+                    // Only one variant is inhabited.\n+                    (inh_second.is_none() &&\n+                    // Representation optimizations are allowed.\n+                     !def.repr.inhibit_enum_layout_opt() &&\n+                    // Inhabited variant either has data ...\n+                     (!variants[inh_first.unwrap()].is_empty() ||\n+                    // ... or there other, uninhabited, variants.\n+                      variants.len() > 1));\n+                if is_struct {\n+                    // Struct, or univariant enum equivalent to a struct.\n                     // (Typechecking will reject discriminant-sizing attrs.)\n \n-                    let kind = if def.is_enum() || variants[0].len() == 0 {\n+                    let v = inh_first.unwrap();\n+                    let kind = if def.is_enum() || variants[v].len() == 0 {\n                         StructKind::AlwaysSized\n                     } else {\n                         let param_env = tcx.param_env(def.did);\n-                        let last_field = def.variants[0].fields.last().unwrap();\n+                        let last_field = def.variants[v].fields.last().unwrap();\n                         let always_sized = tcx.type_of(last_field.did)\n                           .is_sized(tcx, param_env, DUMMY_SP);\n                         if !always_sized { StructKind::MaybeUnsized }\n                         else { StructKind::AlwaysSized }\n                     };\n \n-                    return univariant(&variants[0], &def.repr, kind);\n+                    let mut st = univariant_uninterned(&variants[v], &def.repr, kind)?;\n+                    st.variants = Variants::Single { index: v };\n+                    return Ok(tcx.intern_layout(st));\n                 }\n \n                 let no_explicit_discriminants = def.variants.iter().enumerate()\n                     .all(|(i, v)| v.discr == ty::VariantDiscr::Relative(i));\n \n-                if variants.len() == 2 &&\n+                if inh_second.is_some() && inh_third.is_none() &&\n                    !def.repr.inhibit_enum_layout_opt() &&\n                    no_explicit_discriminants {\n                     // Nullable pointer optimization\n-                    for i in 0..2 {\n-                        if !variants[1 - i].iter().all(|f| f.is_zst()) {\n+                    let (a, b) = (inh_first.unwrap(), inh_second.unwrap());\n+                    for &(i, other) in &[(a, b), (b, a)] {\n+                        if !variants[other].iter().all(|f| f.is_zst()) {\n                             continue;\n                         }\n \n                         for (field_index, field) in variants[i].iter().enumerate() {\n                             if let Some((offset, niche, niche_value)) = field.find_niche(cx)? {\n-                                let mut st = vec![\n-                                    univariant_uninterned(&variants[0],\n-                                        &def.repr, StructKind::AlwaysSized)?,\n-                                    univariant_uninterned(&variants[1],\n-                                        &def.repr, StructKind::AlwaysSized)?\n-                                ];\n-                                for (i, v) in st.iter_mut().enumerate() {\n-                                    v.variants = Variants::Single { index: i };\n-                                }\n+                                let st = variants.iter().enumerate().map(|(j, v)| {\n+                                    let mut st = univariant_uninterned(v,\n+                                        &def.repr, StructKind::AlwaysSized)?;\n+                                    st.variants = Variants::Single { index: j };\n+                                    Ok(st)\n+                                }).collect::<Result<Vec<_>, _>>()?;\n+\n                                 let offset = st[i].fields.offset(field_index) + offset;\n                                 let CachedLayout {\n                                     size,\n@@ -1400,6 +1432,7 @@ impl<'a, 'tcx> CachedLayout {\n                                 return Ok(tcx.intern_layout(CachedLayout {\n                                     variants: Variants::NicheFilling {\n                                         dataful_variant: i,\n+                                        niche_variant: other,\n                                         niche,\n                                         niche_value,\n                                         variants: st,\n@@ -1419,11 +1452,15 @@ impl<'a, 'tcx> CachedLayout {\n                 }\n \n                 let (mut min, mut max) = (i128::max_value(), i128::min_value());\n-                for discr in def.discriminants(tcx) {\n+                for (i, discr) in def.discriminants(tcx).enumerate() {\n+                    if variants[i].iter().any(|f| f.abi == Abi::Uninhabited) {\n+                        continue;\n+                    }\n                     let x = discr.to_u128_unchecked() as i128;\n                     if x < min { min = x; }\n                     if x > max { max = x; }\n                 }\n+                assert!(min <= max, \"discriminant range is {}...{}\", min, max);\n                 let (min_ity, signed) = Integer::repr_discr(tcx, ty, &def.repr, min, max);\n \n                 let mut align = dl.aggregate_align;\n@@ -1498,6 +1535,9 @@ impl<'a, 'tcx> CachedLayout {\n                     let old_ity_size = min_ity.size();\n                     let new_ity_size = ity.size();\n                     for variant in &mut variants {\n+                        if variant.abi == Abi::Uninhabited {\n+                            continue;\n+                        }\n                         match variant.fields {\n                             FieldPlacement::Arbitrary { ref mut offsets, .. } => {\n                                 for i in offsets {\n@@ -1663,16 +1703,11 @@ impl<'a, 'tcx> CachedLayout {\n         };\n \n         match layout.variants {\n-            Variants::Single { .. } => {\n-                let variant_names = || {\n-                    adt_def.variants.iter().map(|v|format!(\"{}\", v.name)).collect::<Vec<_>>()\n-                };\n-                debug!(\"print-type-size `{:#?}` variants: {:?}\",\n-                       layout, variant_names());\n-                assert!(adt_def.variants.len() <= 1,\n-                        \"univariant with variants {:?}\", variant_names());\n-                if adt_def.variants.len() == 1 {\n-                    let variant_def = &adt_def.variants[0];\n+            Variants::Single { index } => {\n+                debug!(\"print-type-size `{:#?}` variant {}\",\n+                       layout, adt_def.variants[index].name);\n+                if !adt_def.variants.is_empty() {\n+                    let variant_def = &adt_def.variants[index];\n                     let fields: Vec<_> =\n                         variant_def.fields.iter().map(|f| f.name).collect();\n                     record(adt_kind.into(),\n@@ -1697,7 +1732,7 @@ impl<'a, 'tcx> CachedLayout {\n                             variant_def.fields.iter().map(|f| f.name).collect();\n                         build_variant_info(Some(variant_def.name),\n                                             &fields,\n-                                            layout.for_variant(i))\n+                                            layout.for_variant(cx, i))\n                     })\n                     .collect();\n                 record(adt_kind.into(), match layout.variants {\n@@ -1989,15 +2024,35 @@ impl<'a, 'tcx> LayoutOf<Ty<'tcx>> for (ty::maps::TyCtxtAt<'a, 'tcx, 'tcx>,\n }\n \n impl<'a, 'tcx> TyLayout<'tcx> {\n-    pub fn for_variant(&self, variant_index: usize) -> Self {\n+    pub fn for_variant<C>(&self, cx: C, variant_index: usize) -> Self\n+        where C: LayoutOf<Ty<'tcx>> + HasTyCtxt<'tcx>,\n+              C::TyLayout: MaybeResult<TyLayout<'tcx>>\n+    {\n         let cached = match self.variants {\n-            Variants::Single { .. } => self.cached,\n+            Variants::Single { index } if index == variant_index => self.cached,\n+\n+            Variants::Single { index } => {\n+                // Deny calling for_variant more than once for non-Single enums.\n+                cx.layout_of(self.ty).map_same(|layout| {\n+                    assert_eq!(layout.variants, Variants::Single { index });\n+                    layout\n+                });\n+\n+                let fields = match self.ty.sty {\n+                    ty::TyAdt(def, _) => def.variants[variant_index].fields.len(),\n+                    _ => bug!()\n+                };\n+                let mut cached = CachedLayout::uninhabited(fields);\n+                cached.variants = Variants::Single { index: variant_index };\n+                cx.tcx().intern_layout(cached)\n+            }\n \n             Variants::NicheFilling { ref variants, .. } |\n             Variants::Tagged { ref variants, .. } => {\n                 &variants[variant_index]\n             }\n         };\n+\n         assert_eq!(cached.variants, Variants::Single { index: variant_index });\n \n         TyLayout {\n@@ -2138,6 +2193,7 @@ impl<'a, 'tcx> TyLayout<'tcx> {\n     /// Returns true if the type is a ZST and not unsized.\n     pub fn is_zst(&self) -> bool {\n         match self.abi {\n+            Abi::Uninhabited => true,\n             Abi::Scalar(_) => false,\n             Abi::Vector => self.size.bytes() == 0,\n             Abi::Aggregate { sized, .. } => sized && self.size.bytes() == 0\n@@ -2241,11 +2297,13 @@ impl<'gcx> HashStable<StableHashingContext<'gcx>> for Variants {\n             }\n             NicheFilling {\n                 dataful_variant,\n+                niche_variant,\n                 ref niche,\n                 niche_value,\n                 ref variants,\n             } => {\n                 dataful_variant.hash_stable(hcx, hasher);\n+                niche_variant.hash_stable(hcx, hasher);\n                 niche.hash_stable(hcx, hasher);\n                 niche_value.hash_stable(hcx, hasher);\n                 variants.hash_stable(hcx, hasher);\n@@ -2285,6 +2343,7 @@ impl<'gcx> HashStable<StableHashingContext<'gcx>> for Abi {\n         mem::discriminant(self).hash_stable(hcx, hasher);\n \n         match *self {\n+            Uninhabited => {}\n             Scalar(ref value) => {\n                 value.hash_stable(hcx, hasher);\n             }"}, {"sha": "c4b90d94dd4b38a00b9291cfb7360f14f1763772", "filename": "src/librustc_trans/abi.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/ced5e04e8bfa80ae297cba6c95ec0948dceb6933/src%2Flibrustc_trans%2Fabi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ced5e04e8bfa80ae297cba6c95ec0948dceb6933/src%2Flibrustc_trans%2Fabi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fabi.rs?ref=ced5e04e8bfa80ae297cba6c95ec0948dceb6933", "patch": "@@ -278,6 +278,7 @@ pub trait LayoutExt<'tcx> {\n impl<'tcx> LayoutExt<'tcx> for TyLayout<'tcx> {\n     fn is_aggregate(&self) -> bool {\n         match self.abi {\n+            layout::Abi::Uninhabited |\n             layout::Abi::Scalar(_) |\n             layout::Abi::Vector => false,\n             layout::Abi::Aggregate { .. } => true\n@@ -286,6 +287,8 @@ impl<'tcx> LayoutExt<'tcx> for TyLayout<'tcx> {\n \n     fn homogeneous_aggregate<'a>(&self, ccx: &CrateContext<'a, 'tcx>) -> Option<Reg> {\n         match self.abi {\n+            layout::Abi::Uninhabited => None,\n+\n             // The primitive for this algorithm.\n             layout::Abi::Scalar(ref scalar) => {\n                 let kind = match scalar.value {"}, {"sha": "62540fac8b53e59d8feee7294f9743bad2e93a69", "filename": "src/librustc_trans/cabi_x86_64.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ced5e04e8bfa80ae297cba6c95ec0948dceb6933/src%2Flibrustc_trans%2Fcabi_x86_64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ced5e04e8bfa80ae297cba6c95ec0948dceb6933/src%2Flibrustc_trans%2Fcabi_x86_64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcabi_x86_64.rs?ref=ced5e04e8bfa80ae297cba6c95ec0948dceb6933", "patch": "@@ -65,6 +65,8 @@ fn classify_arg<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, arg: &ArgType<'tcx>)\n         }\n \n         match layout.abi {\n+            layout::Abi::Uninhabited => {}\n+\n             layout::Abi::Scalar(ref scalar) => {\n                 let reg = match scalar.value {\n                     layout::Int(..) |"}, {"sha": "e93eeb83619b6072c82e5dc9af2f452124cc8fcd", "filename": "src/librustc_trans/cabi_x86_win64.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/ced5e04e8bfa80ae297cba6c95ec0948dceb6933/src%2Flibrustc_trans%2Fcabi_x86_win64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ced5e04e8bfa80ae297cba6c95ec0948dceb6933/src%2Flibrustc_trans%2Fcabi_x86_win64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcabi_x86_win64.rs?ref=ced5e04e8bfa80ae297cba6c95ec0948dceb6933", "patch": "@@ -17,6 +17,7 @@ use rustc::ty::layout;\n pub fn compute_abi_info(fty: &mut FnType) {\n     let fixup = |a: &mut ArgType| {\n         match a.layout.abi {\n+            layout::Abi::Uninhabited => {}\n             layout::Abi::Aggregate { .. } => {\n                 match a.layout.size.bits() {\n                     8 => a.cast_to(Reg::i8()),"}, {"sha": "25a35274d3233d036d476f0b08d1f42751b53dae", "filename": "src/librustc_trans/debuginfo/metadata.rs", "status": "modified", "additions": 28, "deletions": 33, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/ced5e04e8bfa80ae297cba6c95ec0948dceb6933/src%2Flibrustc_trans%2Fdebuginfo%2Fmetadata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ced5e04e8bfa80ae297cba6c95ec0948dceb6933/src%2Flibrustc_trans%2Fdebuginfo%2Fmetadata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fdebuginfo%2Fmetadata.rs?ref=ced5e04e8bfa80ae297cba6c95ec0948dceb6933", "patch": "@@ -1130,43 +1130,38 @@ impl<'tcx> EnumMemberDescriptionFactory<'tcx> {\n                                       -> Vec<MemberDescription> {\n         let adt = &self.enum_type.ty_adt_def().unwrap();\n         match self.layout.variants {\n-            layout::Variants::Single { .. } => {\n-                assert!(adt.variants.len() <= 1);\n-\n-                if adt.variants.is_empty() {\n-                    vec![]\n-                } else {\n-                    let (variant_type_metadata, member_description_factory) =\n-                        describe_enum_variant(cx,\n-                                              self.layout,\n-                                              &adt.variants[0],\n-                                              NoDiscriminant,\n-                                              self.containing_scope,\n-                                              self.span);\n+            layout::Variants::Single { .. } if adt.variants.is_empty() => vec![],\n+            layout::Variants::Single { index } => {\n+                let (variant_type_metadata, member_description_factory) =\n+                    describe_enum_variant(cx,\n+                                          self.layout,\n+                                          &adt.variants[index],\n+                                          NoDiscriminant,\n+                                          self.containing_scope,\n+                                          self.span);\n \n-                    let member_descriptions =\n-                        member_description_factory.create_member_descriptions(cx);\n+                let member_descriptions =\n+                    member_description_factory.create_member_descriptions(cx);\n \n-                    set_members_of_composite_type(cx,\n-                                                  variant_type_metadata,\n-                                                  &member_descriptions[..]);\n-                    vec![\n-                        MemberDescription {\n-                            name: \"\".to_string(),\n-                            type_metadata: variant_type_metadata,\n-                            offset: Size::from_bytes(0),\n-                            size: self.layout.size,\n-                            align: self.layout.align,\n-                            flags: DIFlags::FlagZero\n-                        }\n-                    ]\n-                }\n+                set_members_of_composite_type(cx,\n+                                              variant_type_metadata,\n+                                              &member_descriptions[..]);\n+                vec![\n+                    MemberDescription {\n+                        name: \"\".to_string(),\n+                        type_metadata: variant_type_metadata,\n+                        offset: Size::from_bytes(0),\n+                        size: self.layout.size,\n+                        align: self.layout.align,\n+                        flags: DIFlags::FlagZero\n+                    }\n+                ]\n             }\n             layout::Variants::Tagged { ref variants, .. } => {\n                 let discriminant_info = RegularDiscriminant(self.discriminant_type_metadata\n                     .expect(\"\"));\n                 (0..variants.len()).map(|i| {\n-                    let variant = self.layout.for_variant(i);\n+                    let variant = self.layout.for_variant(cx, i);\n                     let (variant_type_metadata, member_desc_factory) =\n                         describe_enum_variant(cx,\n                                               variant,\n@@ -1191,8 +1186,8 @@ impl<'tcx> EnumMemberDescriptionFactory<'tcx> {\n                     }\n                 }).collect()\n             }\n-            layout::Variants::NicheFilling { dataful_variant, .. } => {\n-                let variant = self.layout.for_variant(dataful_variant);\n+            layout::Variants::NicheFilling { dataful_variant, niche_variant, .. } => {\n+                let variant = self.layout.for_variant(cx, dataful_variant);\n                 // Create a description of the non-null variant\n                 let (variant_type_metadata, member_description_factory) =\n                     describe_enum_variant(cx,\n@@ -1236,7 +1231,7 @@ impl<'tcx> EnumMemberDescriptionFactory<'tcx> {\n                                    self.layout,\n                                    self.layout.fields.offset(0),\n                                    self.layout.field(cx, 0).size);\n-                name.push_str(&adt.variants[1 - dataful_variant].name.as_str());\n+                name.push_str(&adt.variants[niche_variant].name.as_str());\n \n                 // Create the (singleton) list of descriptions of union members.\n                 vec!["}, {"sha": "d1b6e9073b843114f0214ce5fab4df8dc480911c", "filename": "src/librustc_trans/mir/block.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ced5e04e8bfa80ae297cba6c95ec0948dceb6933/src%2Flibrustc_trans%2Fmir%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ced5e04e8bfa80ae297cba6c95ec0948dceb6933/src%2Flibrustc_trans%2Fmir%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Fblock.rs?ref=ced5e04e8bfa80ae297cba6c95ec0948dceb6933", "patch": "@@ -710,7 +710,11 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n             Immediate(llval) => {\n                 for i in 0..tuple.layout.fields.count() {\n                     let field = tuple.layout.field(bcx.ccx, i);\n-                    let elem = bcx.extract_value(llval, tuple.layout.llvm_field_index(i));\n+                    let elem = if field.is_zst() {\n+                        C_undef(field.llvm_type(bcx.ccx))\n+                    } else {\n+                        bcx.extract_value(llval, tuple.layout.llvm_field_index(i))\n+                    };\n                     // If the tuple is immediate, the elements are as well\n                     let op = OperandRef {\n                         val: Immediate(base::to_immediate(bcx, elem, field)),"}, {"sha": "542893bd62b3918170cd91ebb44ff8ce61259bba", "filename": "src/librustc_trans/mir/constant.rs", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/ced5e04e8bfa80ae297cba6c95ec0948dceb6933/src%2Flibrustc_trans%2Fmir%2Fconstant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ced5e04e8bfa80ae297cba6c95ec0948dceb6933/src%2Flibrustc_trans%2Fmir%2Fconstant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Fconstant.rs?ref=ced5e04e8bfa80ae297cba6c95ec0948dceb6933", "patch": "@@ -1099,6 +1099,11 @@ fn trans_const_adt<'a, 'tcx>(\n         mir::AggregateKind::Adt(_, index, _, _) => index,\n         _ => 0,\n     };\n+\n+    if let layout::Abi::Uninhabited = l.abi {\n+        return Const::new(C_undef(l.llvm_type(ccx)), t);\n+    }\n+\n     match l.variants {\n         layout::Variants::Single { index } => {\n             assert_eq!(variant_index, index);\n@@ -1114,7 +1119,6 @@ fn trans_const_adt<'a, 'tcx>(\n \n                 Const::new(C_struct(ccx, &contents, l.is_packed()), t)\n             } else {\n-                assert_eq!(variant_index, 0);\n                 build_const_struct(ccx, l, vals, None)\n             }\n         }\n@@ -1132,12 +1136,12 @@ fn trans_const_adt<'a, 'tcx>(\n                 Const::new(discr, t)\n             } else {\n                 let discr = Const::new(discr, discr_field.ty);\n-                build_const_struct(ccx, l.for_variant(variant_index), vals, Some(discr))\n+                build_const_struct(ccx, l.for_variant(ccx, variant_index), vals, Some(discr))\n             }\n         }\n         layout::Variants::NicheFilling { dataful_variant, niche_value, .. } => {\n             if variant_index == dataful_variant {\n-                build_const_struct(ccx, l.for_variant(dataful_variant), vals, None)\n+                build_const_struct(ccx, l.for_variant(ccx, dataful_variant), vals, None)\n             } else {\n                 let niche = l.field(ccx, 0);\n                 let niche_llty = niche.llvm_type(ccx);"}, {"sha": "c6eb822ec876147866ca0fa14bfdd0ae2564e38b", "filename": "src/librustc_trans/mir/lvalue.rs", "status": "modified", "additions": 18, "deletions": 7, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/ced5e04e8bfa80ae297cba6c95ec0948dceb6933/src%2Flibrustc_trans%2Fmir%2Flvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ced5e04e8bfa80ae297cba6c95ec0948dceb6933/src%2Flibrustc_trans%2Fmir%2Flvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Flvalue.rs?ref=ced5e04e8bfa80ae297cba6c95ec0948dceb6933", "patch": "@@ -115,7 +115,7 @@ impl<'a, 'tcx> LvalueRef<'tcx> {\n                 assert_eq!(count, 0);\n                 self.llextra\n             } else {\n-                common::C_usize(ccx, count)\n+                C_usize(ccx, count)\n             }\n         } else {\n             bug!(\"unexpected layout `{:#?}` in LvalueRef::len\", self.layout)\n@@ -304,7 +304,12 @@ impl<'a, 'tcx> LvalueRef<'tcx> {\n                 };\n                 bcx.intcast(lldiscr, cast_to, signed)\n             }\n-            layout::Variants::NicheFilling { dataful_variant, niche_value, .. } => {\n+            layout::Variants::NicheFilling {\n+                dataful_variant,\n+                niche_variant,\n+                niche_value,\n+                ..\n+            } => {\n                 let niche_llty = discr.layout.llvm_type(bcx.ccx);\n                 // FIXME(eddyb) Check the actual primitive type here.\n                 let niche_llval = if niche_value == 0 {\n@@ -313,8 +318,9 @@ impl<'a, 'tcx> LvalueRef<'tcx> {\n                 } else {\n                     C_uint_big(niche_llty, niche_value)\n                 };\n-                let cmp = if dataful_variant == 0 { llvm::IntEQ } else { llvm::IntNE };\n-                bcx.intcast(bcx.icmp(cmp, lldiscr, niche_llval), cast_to, false)\n+                bcx.select(bcx.icmp(llvm::IntEQ, lldiscr, niche_llval),\n+                    C_uint(cast_to, niche_variant as u64),\n+                    C_uint(cast_to, dataful_variant as u64))\n             }\n         }\n     }\n@@ -324,7 +330,12 @@ impl<'a, 'tcx> LvalueRef<'tcx> {\n     pub fn trans_set_discr(&self, bcx: &Builder<'a, 'tcx>, variant_index: usize) {\n         match self.layout.variants {\n             layout::Variants::Single { index } => {\n-                assert_eq!(variant_index, index);\n+                if index != variant_index {\n+                    // If the layout of an enum is `Single`, all\n+                    // other variants are necessarily uninhabited.\n+                    assert_eq!(self.layout.for_variant(bcx.ccx, variant_index).abi,\n+                               layout::Abi::Uninhabited);\n+                }\n             }\n             layout::Variants::Tagged { .. } => {\n                 let ptr = self.project_field(bcx, 0);\n@@ -366,7 +377,7 @@ impl<'a, 'tcx> LvalueRef<'tcx> {\n     pub fn project_index(&self, bcx: &Builder<'a, 'tcx>, llindex: ValueRef)\n                          -> LvalueRef<'tcx> {\n         LvalueRef {\n-            llval: bcx.inbounds_gep(self.llval, &[common::C_usize(bcx.ccx, 0), llindex]),\n+            llval: bcx.inbounds_gep(self.llval, &[C_usize(bcx.ccx, 0), llindex]),\n             llextra: ptr::null_mut(),\n             layout: self.layout.field(bcx.ccx, 0),\n             alignment: self.alignment\n@@ -376,7 +387,7 @@ impl<'a, 'tcx> LvalueRef<'tcx> {\n     pub fn project_downcast(&self, bcx: &Builder<'a, 'tcx>, variant_index: usize)\n                             -> LvalueRef<'tcx> {\n         let mut downcast = *self;\n-        downcast.layout = self.layout.for_variant(variant_index);\n+        downcast.layout = self.layout.for_variant(bcx.ccx, variant_index);\n \n         // Cast to the appropriate variant struct type.\n         let variant_ty = downcast.layout.llvm_type(bcx.ccx);"}, {"sha": "d2f9ca3546812b84094fe0ff772bfcc9e2ef5148", "filename": "src/librustc_trans/type_of.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/ced5e04e8bfa80ae297cba6c95ec0948dceb6933/src%2Flibrustc_trans%2Ftype_of.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ced5e04e8bfa80ae297cba6c95ec0948dceb6933/src%2Flibrustc_trans%2Ftype_of.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftype_of.rs?ref=ced5e04e8bfa80ae297cba6c95ec0948dceb6933", "patch": "@@ -27,6 +27,7 @@ fn uncached_llvm_type<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n             return Type::vector(&layout.field(ccx, 0).llvm_type(ccx),\n                                 layout.fields.count() as u64);\n         }\n+        layout::Abi::Uninhabited |\n         layout::Abi::Aggregate { .. } => {}\n     }\n \n@@ -158,7 +159,9 @@ pub trait LayoutLlvmExt<'tcx> {\n impl<'tcx> LayoutLlvmExt<'tcx> for TyLayout<'tcx> {\n     fn is_llvm_immediate(&self) -> bool {\n         match self.abi {\n-            layout::Abi::Scalar(_) | layout::Abi::Vector => true,\n+            layout::Abi::Uninhabited |\n+            layout::Abi::Scalar(_) |\n+            layout::Abi::Vector => true,\n \n             layout::Abi::Aggregate { .. } => self.is_zst()\n         }\n@@ -230,7 +233,7 @@ impl<'tcx> LayoutLlvmExt<'tcx> for TyLayout<'tcx> {\n         let llty = if self.ty != normal_ty {\n             let mut layout = ccx.layout_of(normal_ty);\n             if let Some(v) = variant_index {\n-                layout = layout.for_variant(v);\n+                layout = layout.for_variant(ccx, v);\n             }\n             layout.llvm_type(ccx)\n         } else {"}, {"sha": "69cc4c933601e0eb685346f9d29932e6e0179c01", "filename": "src/test/ui/print_type_sizes/uninhabited.rs", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/ced5e04e8bfa80ae297cba6c95ec0948dceb6933/src%2Ftest%2Fui%2Fprint_type_sizes%2Funinhabited.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ced5e04e8bfa80ae297cba6c95ec0948dceb6933/src%2Ftest%2Fui%2Fprint_type_sizes%2Funinhabited.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fprint_type_sizes%2Funinhabited.rs?ref=ced5e04e8bfa80ae297cba6c95ec0948dceb6933", "patch": "@@ -0,0 +1,18 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// compile-flags: -Z print-type-sizes\n+\n+#![feature(never_type)]\n+\n+pub fn main() {\n+    let _x: Option<!> = None;\n+    let _y: Result<u32, !> = Ok(42);\n+}"}, {"sha": "2a8706f7ac5514591adba5f5d323cb0b356b1116", "filename": "src/test/ui/print_type_sizes/uninhabited.stdout", "status": "added", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/ced5e04e8bfa80ae297cba6c95ec0948dceb6933/src%2Ftest%2Fui%2Fprint_type_sizes%2Funinhabited.stdout", "raw_url": "https://github.com/rust-lang/rust/raw/ced5e04e8bfa80ae297cba6c95ec0948dceb6933/src%2Ftest%2Fui%2Fprint_type_sizes%2Funinhabited.stdout", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fprint_type_sizes%2Funinhabited.stdout?ref=ced5e04e8bfa80ae297cba6c95ec0948dceb6933", "patch": "@@ -0,0 +1,5 @@\n+print-type-size type: `std::result::Result<u32, !>`: 4 bytes, alignment: 4 bytes\n+print-type-size     variant `Ok`: 4 bytes\n+print-type-size         field `.0`: 4 bytes\n+print-type-size type: `std::option::Option<!>`: 0 bytes, alignment: 1 bytes\n+print-type-size     variant `None`: 0 bytes"}]}