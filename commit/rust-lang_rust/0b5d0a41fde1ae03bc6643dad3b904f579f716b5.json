{"sha": "0b5d0a41fde1ae03bc6643dad3b904f579f716b5", "node_id": "MDY6Q29tbWl0NzI0NzEyOjBiNWQwYTQxZmRlMWFlMDNiYzY2NDNkYWQzYjkwNGY1NzlmNzE2YjU=", "commit": {"author": {"name": "Ekaterina Babshukova", "email": "ekaterina.babshukova@yandex.ru", "date": "2019-10-03T00:00:47Z"}, "committer": {"name": "Ekaterina Babshukova", "email": "ekaterina.babshukova@yandex.ru", "date": "2019-10-22T20:47:31Z"}, "message": "replace a chain of `if let` by macro", "tree": {"sha": "9321dfe07dccf7bc36dbc3090073d1645c658d25", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9321dfe07dccf7bc36dbc3090073d1645c658d25"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0b5d0a41fde1ae03bc6643dad3b904f579f716b5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0b5d0a41fde1ae03bc6643dad3b904f579f716b5", "html_url": "https://github.com/rust-lang/rust/commit/0b5d0a41fde1ae03bc6643dad3b904f579f716b5", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0b5d0a41fde1ae03bc6643dad3b904f579f716b5/comments", "author": {"login": "viorina", "id": 6714973, "node_id": "MDQ6VXNlcjY3MTQ5NzM=", "avatar_url": "https://avatars.githubusercontent.com/u/6714973?v=4", "gravatar_id": "", "url": "https://api.github.com/users/viorina", "html_url": "https://github.com/viorina", "followers_url": "https://api.github.com/users/viorina/followers", "following_url": "https://api.github.com/users/viorina/following{/other_user}", "gists_url": "https://api.github.com/users/viorina/gists{/gist_id}", "starred_url": "https://api.github.com/users/viorina/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/viorina/subscriptions", "organizations_url": "https://api.github.com/users/viorina/orgs", "repos_url": "https://api.github.com/users/viorina/repos", "events_url": "https://api.github.com/users/viorina/events{/privacy}", "received_events_url": "https://api.github.com/users/viorina/received_events", "type": "User", "site_admin": false}, "committer": {"login": "viorina", "id": 6714973, "node_id": "MDQ6VXNlcjY3MTQ5NzM=", "avatar_url": "https://avatars.githubusercontent.com/u/6714973?v=4", "gravatar_id": "", "url": "https://api.github.com/users/viorina", "html_url": "https://github.com/viorina", "followers_url": "https://api.github.com/users/viorina/followers", "following_url": "https://api.github.com/users/viorina/following{/other_user}", "gists_url": "https://api.github.com/users/viorina/gists{/gist_id}", "starred_url": "https://api.github.com/users/viorina/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/viorina/subscriptions", "organizations_url": "https://api.github.com/users/viorina/orgs", "repos_url": "https://api.github.com/users/viorina/repos", "events_url": "https://api.github.com/users/viorina/events{/privacy}", "received_events_url": "https://api.github.com/users/viorina/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d6ae1b5f0f3e1b9b7f85dcdbd98e0c336b7a882d", "url": "https://api.github.com/repos/rust-lang/rust/commits/d6ae1b5f0f3e1b9b7f85dcdbd98e0c336b7a882d", "html_url": "https://github.com/rust-lang/rust/commit/d6ae1b5f0f3e1b9b7f85dcdbd98e0c336b7a882d"}], "stats": {"total": 342, "additions": 87, "deletions": 255}, "files": [{"sha": "df61c227ae957ff821cafbf0d212bc4112630d80", "filename": "crates/ra_hir/src/from_source.rs", "status": "modified", "additions": 1, "deletions": 39, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/0b5d0a41fde1ae03bc6643dad3b904f579f716b5/crates%2Fra_hir%2Fsrc%2Ffrom_source.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b5d0a41fde1ae03bc6643dad3b904f579f716b5/crates%2Fra_hir%2Fsrc%2Ffrom_source.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Ffrom_source.rs?ref=0b5d0a41fde1ae03bc6643dad3b904f579f716b5", "patch": "@@ -12,8 +12,7 @@ use crate::{\n     ids::{AstItemDef, LocationCtx},\n     name::AsName,\n     AssocItem, Const, Crate, Enum, EnumVariant, FieldSource, Function, HasSource, ImplBlock,\n-    Module, ModuleDef, ModuleSource, Source, Static, Struct, StructField, Trait, TypeAlias, Union,\n-    VariantDef,\n+    Module, ModuleSource, Source, Static, Struct, StructField, Trait, TypeAlias, Union, VariantDef,\n };\n \n pub trait FromSource: Sized {\n@@ -148,43 +147,6 @@ impl FromSource for AssocItem {\n     }\n }\n \n-// not fully matched\n-impl FromSource for ModuleDef {\n-    type Ast = ast::ModuleItem;\n-    fn from_source(db: &(impl DefDatabase + AstDatabase), src: Source<Self::Ast>) -> Option<Self> {\n-        macro_rules! def {\n-            ($kind:ident, $ast:ident) => {\n-                $kind::from_source(db, Source { file_id: src.file_id, ast: $ast })\n-                    .and_then(|it| Some(ModuleDef::from(it)))\n-            };\n-        }\n-\n-        match src.ast {\n-            ast::ModuleItem::FnDef(f) => def!(Function, f),\n-            ast::ModuleItem::ConstDef(c) => def!(Const, c),\n-            ast::ModuleItem::TypeAliasDef(a) => def!(TypeAlias, a),\n-            ast::ModuleItem::TraitDef(t) => def!(Trait, t),\n-            ast::ModuleItem::StaticDef(s) => def!(Static, s),\n-            ast::ModuleItem::StructDef(s) => {\n-                let src = Source { file_id: src.file_id, ast: s };\n-                let s = Struct::from_source(db, src)?;\n-                Some(ModuleDef::Adt(s.into()))\n-            }\n-            ast::ModuleItem::EnumDef(e) => {\n-                let src = Source { file_id: src.file_id, ast: e };\n-                let e = Enum::from_source(db, src)?;\n-                Some(ModuleDef::Adt(e.into()))\n-            }\n-            ast::ModuleItem::Module(ref m) if !m.has_semi() => {\n-                let src = Source { file_id: src.file_id, ast: ModuleSource::Module(m.clone()) };\n-                let module = Module::from_definition(db, src)?;\n-                Some(ModuleDef::Module(module))\n-            }\n-            _ => None,\n-        }\n-    }\n-}\n-\n // FIXME: simplify it\n impl ModuleSource {\n     pub fn from_position("}, {"sha": "0effeb8a16e53028e256523269aa0a60a1f86498", "filename": "crates/ra_ide_api/src/name_kind.rs", "status": "modified", "additions": 86, "deletions": 30, "changes": 116, "blob_url": "https://github.com/rust-lang/rust/blob/0b5d0a41fde1ae03bc6643dad3b904f579f716b5/crates%2Fra_ide_api%2Fsrc%2Fname_kind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b5d0a41fde1ae03bc6643dad3b904f579f716b5/crates%2Fra_ide_api%2Fsrc%2Fname_kind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_api%2Fsrc%2Fname_kind.rs?ref=0b5d0a41fde1ae03bc6643dad3b904f579f716b5", "patch": "@@ -102,36 +102,92 @@ pub(crate) fn classify_name(\n     let parent = name.syntax().parent()?;\n     let file_id = file_id.into();\n \n-    if let Some(pat) = ast::BindPat::cast(parent.clone()) {\n-        return Some(Pat(AstPtr::new(&pat)));\n+    macro_rules! match_ast {\n+        (match $node:ident {\n+            $( ast::$ast:ident($it:ident) => $res:block, )*\n+            _ => $catch_all:expr,\n+        }) => {{\n+            $( if let Some($it) = ast::$ast::cast($node.clone()) $res else )*\n+            { $catch_all }\n+        }};\n     }\n-    if let Some(var) = ast::EnumVariant::cast(parent.clone()) {\n-        let src = hir::Source { file_id, ast: var };\n-        let var = hir::EnumVariant::from_source(db, src)?;\n-        return Some(Def(var.into()));\n-    }\n-    if let Some(field) = ast::RecordFieldDef::cast(parent.clone()) {\n-        let src = hir::Source { file_id, ast: hir::FieldSource::Named(field) };\n-        let field = hir::StructField::from_source(db, src)?;\n-        return Some(FieldAccess(field));\n-    }\n-    if let Some(field) = ast::TupleFieldDef::cast(parent.clone()) {\n-        let src = hir::Source { file_id, ast: hir::FieldSource::Pos(field) };\n-        let field = hir::StructField::from_source(db, src)?;\n-        return Some(FieldAccess(field));\n-    }\n-    if let Some(_) = parent.parent().and_then(ast::ItemList::cast) {\n-        let ast = ast::ImplItem::cast(parent.clone())?;\n-        let src = hir::Source { file_id, ast };\n-        let item = hir::AssocItem::from_source(db, src)?;\n-        return Some(AssocItem(item));\n-    }\n-    if let Some(item) = ast::ModuleItem::cast(parent.clone()) {\n-        let src = hir::Source { file_id, ast: item };\n-        let def = hir::ModuleDef::from_source(db, src)?;\n-        return Some(Def(def));\n-    }\n-    // FIXME: TYPE_PARAM, ALIAS, MACRO_CALL; Union\n \n-    None\n+    // FIXME: add ast::MacroCall(it)\n+    match_ast! {\n+        match parent {\n+            ast::BindPat(it) => {\n+                let pat = AstPtr::new(&it);\n+                Some(Pat(pat))\n+            },\n+            ast::RecordFieldDef(it) => {\n+                let src = hir::Source { file_id, ast: hir::FieldSource::Named(it) };\n+                let field = hir::StructField::from_source(db, src)?;\n+                Some(FieldAccess(field))\n+            },\n+            ast::FnDef(it) => {\n+                if parent.parent().and_then(ast::ItemList::cast).is_some() {\n+                    let src = hir::Source { file_id, ast: ast::ImplItem::from(it) };\n+                    let item = hir::AssocItem::from_source(db, src)?;\n+                    Some(AssocItem(item))\n+                } else {\n+                    let src = hir::Source { file_id, ast: it };\n+                    let def = hir::Function::from_source(db, src)?;\n+                    Some(Def(def.into()))\n+                }\n+            },\n+            ast::ConstDef(it) => {\n+                if parent.parent().and_then(ast::ItemList::cast).is_some() {\n+                    let src = hir::Source { file_id, ast: ast::ImplItem::from(it) };\n+                    let item = hir::AssocItem::from_source(db, src)?;\n+                    Some(AssocItem(item))\n+                } else {\n+                    let src = hir::Source { file_id, ast: it };\n+                    let def = hir::Const::from_source(db, src)?;\n+                    Some(Def(def.into()))\n+                }\n+            },\n+            ast::TypeAliasDef(it) => {\n+                if parent.parent().and_then(ast::ItemList::cast).is_some() {\n+                    let src = hir::Source { file_id, ast: ast::ImplItem::from(it) };\n+                    let item = hir::AssocItem::from_source(db, src)?;\n+                    Some(AssocItem(item))\n+                } else {\n+                    let src = hir::Source { file_id, ast: it };\n+                    let def = hir::TypeAlias::from_source(db, src)?;\n+                    Some(Def(def.into()))\n+                }\n+            },\n+            ast::Module(it) => {\n+                let src = hir::Source { file_id, ast: hir::ModuleSource::Module(it) };\n+                let def = hir::Module::from_definition(db, src)?;\n+                Some(Def(def.into()))\n+            },\n+            ast::StructDef(it) => {\n+                let src = hir::Source { file_id, ast: it };\n+                let def = hir::Struct::from_source(db, src)?;\n+                Some(Def(def.into()))\n+            },\n+            ast::EnumDef(it) => {\n+                let src = hir::Source { file_id, ast: it };\n+                let def = hir::Enum::from_source(db, src)?;\n+                Some(Def(def.into()))\n+            },\n+            ast::TraitDef(it) => {\n+                let src = hir::Source { file_id, ast: it };\n+                let def = hir::Trait::from_source(db, src)?;\n+                Some(Def(def.into()))\n+            },\n+            ast::StaticDef(it) => {\n+                let src = hir::Source { file_id, ast: it };\n+                let def = hir::Static::from_source(db, src)?;\n+                Some(Def(def.into()))\n+            },\n+            ast::EnumVariant(it) => {\n+                let src = hir::Source { file_id, ast: it };\n+                let def = hir::EnumVariant::from_source(db, src)?;\n+                Some(Def(def.into()))\n+            },\n+            _ => None,\n+        }\n+    }\n }"}, {"sha": "ca1ac2b03098c58ed3159d745456e926995317b8", "filename": "crates/ra_ide_api/src/search_scope.rs", "status": "removed", "additions": 0, "deletions": 186, "changes": 186, "blob_url": "https://github.com/rust-lang/rust/blob/d6ae1b5f0f3e1b9b7f85dcdbd98e0c336b7a882d/crates%2Fra_ide_api%2Fsrc%2Fsearch_scope.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6ae1b5f0f3e1b9b7f85dcdbd98e0c336b7a882d/crates%2Fra_ide_api%2Fsrc%2Fsearch_scope.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_api%2Fsrc%2Fsearch_scope.rs?ref=d6ae1b5f0f3e1b9b7f85dcdbd98e0c336b7a882d", "patch": "@@ -1,186 +0,0 @@\n-pub enum SearchScope {\n-    Function(hir::Function),\n-    Module(hir::Module),\n-    Crate(hir::Crate),\n-    Crates(Vec<hir::Crate>),\n-}\n-\n-pub struct SearchScope{ \n-    pub scope: Vec<SyntaxNode>\n-}\n-\n-pub fn find_all_refs(db: &RootDatabase, decl: NameKind) -> Vec<ReferenceDescriptor> {\n-    let (module, visibility) = match decl {\n-        FieldAccess(field) => {\n-            let parent = field.parent_def(db);\n-            let module = parent.module(db);\n-            let visibility = match parent {\n-                VariantDef::Struct(s) => s.source(db).ast.visibility(),\n-                VariantDef::EnumVariant(v) => v.parent_enum(db).source(db).ast.visibility(),\n-            };\n-            (module, visibility)\n-        }\n-        AssocItem(item) => {\n-            let parent = item.parent_trait(db)?;\n-            let module = parent.module(db);\n-            let visibility = parent.source(db).ast.visibility();\n-            (module, visibility)\n-        }\n-        Def(def) => {\n-            let (module, visibility) = match def {\n-                ModuleDef::Module(m) => (m, ),\n-                ModuleDef::Function(f) => (f.module(db), f.source(db).ast.visibility()),\n-                ModuleDef::Adt::Struct(s) => (s.module(db), s.source(db).ast.visibility()),\n-                ModuleDef::Adt::Union(u) => (u.module(db), u.source(db).ast.visibility()),\n-                ModuleDef::Adt::Enum(e) => (e.module(db), e.source(db).ast.visibility()),\n-                ModuleDef::EnumVariant(v) => (v.module(db), v.source(db).ast.visibility()),\n-                ModuleDef::Const(c) => (c.module(db), c.source(db).ast.visibility()),\n-                ModuleDef::Static(s) => (s.module(db), s.source(db).ast.visibility()),\n-                ModuleDef::Trait(t) => (t.module(db), t.source(db).ast.visibility()),\n-                ModuleDef::TypeAlias(a) => (a.module(db), a.source(db).ast.visibility()),\n-                ModuleDef::BuiltinType(_) => return vec![];\n-            };\n-            (module, visibility)\n-        }\n-        // FIXME: add missing kinds\n-        _ => return vec![];\n-    };\n-    let scope = scope(db, module, visibility);\n-}\n-\n-fn scope(db: &RootDatabase, module: hir::Module, item_vis: Option<ast::Visibility>) -> SearchScope {\n-    if let Some(v) = item_vis {\n-        let krate = module.krate(db)?;\n-\n-        if v.syntax().text() == \"pub\" {\n-            SearchScope::Crate(krate)\n-        }\n-        if v.syntax().text() == \"pub(crate)\" {\n-            let crate_graph = db.crate_graph();\n-            let crates = crate_graph.iter().filter(|id| {\n-                crate_graph.dependencies(id).any(|d| d.crate_id() == krate.crate_id())\n-            }).map(|id| Crate { id }).collect::<Vec<_>>();\n-            crates.insert(0, krate);\n-            SearchScope::Crates(crates)\n-        }\n-        // FIXME: \"pub(super)\", \"pub(in path)\"\n-        SearchScope::Module(module)\n-    }\n-    SearchScope::Module(module)\n-}\n-\n-fn process_one(db, scope: SearchScope, pat) {\n-    match scope {\n-        SearchScope::Crate(krate) => {\n-            let text = db.file_text(position.file_id).as_str();\n-            let parse = SourceFile::parse(text);\n-            for (offset, name) in text.match_indices(pat) {\n-                if let Some() = find_node_at_offset<ast::NameRef>(parse, offset) {\n-                    \n-                }\n-            }\n-        }\n-    }\n-}\n-\n-#[cfg(test)]\n-mod tests {\n-    use crate::{\n-        mock_analysis::analysis_and_position, mock_analysis::single_file_with_position, FileId,\n-        ReferenceSearchResult,\n-    };\n-    use insta::assert_debug_snapshot;\n-    use test_utils::assert_eq_text;\n-\n-    #[test]\n-    fn test_find_all_refs_for_local() {\n-        let code = r#\"\n-            fn main() {\n-                let mut i = 1;\n-                let j = 1;\n-                i = i<|> + j;\n-\n-                {\n-                    i = 0;\n-                }\n-\n-                i = 5;\n-            }\n-        \"#;\n-\n-        let refs = get_all_refs(code);\n-        assert_eq!(refs.len(), 5);\n-    }\n-\n-    #[test]\n-    fn test_find_all_refs_for_param_inside() {\n-        let code = r#\"\n-    fn foo(i : u32) -> u32 {\n-        i<|>\n-    }\"#;\n-\n-        let refs = get_all_refs(code);\n-        assert_eq!(refs.len(), 2);\n-    }\n-\n-    #[test]\n-    fn test_find_all_refs_for_fn_param() {\n-        let code = r#\"\n-    fn foo(i<|> : u32) -> u32 {\n-        i\n-    }\"#;\n-\n-        let refs = get_all_refs(code);\n-        assert_eq!(refs.len(), 2);\n-    }\n-\n-    #[test]\n-    fn test_find_all_refs_field_name() {\n-        let code = r#\"\n-            //- /lib.rs\n-            struct Foo {\n-                spam<|>: u32,\n-            }\n-        \"#;\n-\n-        let refs = get_all_refs(code);\n-        assert_eq!(refs.len(), 1);\n-    }\n-\n-    #[test]\n-    fn test_find_all_refs_methods() {\n-        let code = r#\"\n-            //- /lib.rs\n-            struct Foo;\n-            impl Foo {\n-                pub fn a() {\n-                    self.b()\n-                }\n-                fn b(&self) {}\n-            }\n-        \"#;\n-\n-        let refs = get_all_refs(code);\n-        assert_eq!(refs.len(), 1);\n-    }\n-\n-    #[test]\n-    fn test_find_all_refs_pub_enum() {\n-        let code = r#\"\n-            //- /lib.rs\n-            pub enum Foo {\n-                A,\n-                B<|>,\n-                C,\n-            }\n-        \"#;\n-\n-        let refs = get_all_refs(code);\n-        assert_eq!(refs.len(), 1);\n-    }\n-\n-    fn get_all_refs(text: &str) -> ReferenceSearchResult {\n-        let (analysis, position) = single_file_with_position(text);\n-        analysis.find_all_refs(position).unwrap().unwrap()\n-    }\n-}\n\\ No newline at end of file"}]}