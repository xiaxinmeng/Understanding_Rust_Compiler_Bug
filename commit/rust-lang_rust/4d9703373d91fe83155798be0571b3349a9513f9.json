{"sha": "4d9703373d91fe83155798be0571b3349a9513f9", "node_id": "MDY6Q29tbWl0NzI0NzEyOjRkOTcwMzM3M2Q5MWZlODMxNTU3OThiZTA1NzFiMzM0OWE5NTEzZjk=", "commit": {"author": {"name": "leonardo.yvens", "email": "leoyvens@gmail.com", "date": "2017-12-15T18:04:25Z"}, "committer": {"name": "leonardo.yvens", "email": "leoyvens@gmail.com", "date": "2018-02-28T15:33:14Z"}, "message": "Type check defaults.\n\nAnd refactor duplicated code.", "tree": {"sha": "fb54495579002dd98a0148c7b804a1f3ad145a9d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/fb54495579002dd98a0148c7b804a1f3ad145a9d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4d9703373d91fe83155798be0571b3349a9513f9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4d9703373d91fe83155798be0571b3349a9513f9", "html_url": "https://github.com/rust-lang/rust/commit/4d9703373d91fe83155798be0571b3349a9513f9", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4d9703373d91fe83155798be0571b3349a9513f9/comments", "author": {"login": "leoyvens", "id": 9885558, "node_id": "MDQ6VXNlcjk4ODU1NTg=", "avatar_url": "https://avatars.githubusercontent.com/u/9885558?v=4", "gravatar_id": "", "url": "https://api.github.com/users/leoyvens", "html_url": "https://github.com/leoyvens", "followers_url": "https://api.github.com/users/leoyvens/followers", "following_url": "https://api.github.com/users/leoyvens/following{/other_user}", "gists_url": "https://api.github.com/users/leoyvens/gists{/gist_id}", "starred_url": "https://api.github.com/users/leoyvens/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/leoyvens/subscriptions", "organizations_url": "https://api.github.com/users/leoyvens/orgs", "repos_url": "https://api.github.com/users/leoyvens/repos", "events_url": "https://api.github.com/users/leoyvens/events{/privacy}", "received_events_url": "https://api.github.com/users/leoyvens/received_events", "type": "User", "site_admin": false}, "committer": {"login": "leoyvens", "id": 9885558, "node_id": "MDQ6VXNlcjk4ODU1NTg=", "avatar_url": "https://avatars.githubusercontent.com/u/9885558?v=4", "gravatar_id": "", "url": "https://api.github.com/users/leoyvens", "html_url": "https://github.com/leoyvens", "followers_url": "https://api.github.com/users/leoyvens/followers", "following_url": "https://api.github.com/users/leoyvens/following{/other_user}", "gists_url": "https://api.github.com/users/leoyvens/gists{/gist_id}", "starred_url": "https://api.github.com/users/leoyvens/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/leoyvens/subscriptions", "organizations_url": "https://api.github.com/users/leoyvens/orgs", "repos_url": "https://api.github.com/users/leoyvens/repos", "events_url": "https://api.github.com/users/leoyvens/events{/privacy}", "received_events_url": "https://api.github.com/users/leoyvens/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0ff9872b2280009f094af0df3dcdc542cc46a5fd", "url": "https://api.github.com/repos/rust-lang/rust/commits/0ff9872b2280009f094af0df3dcdc542cc46a5fd", "html_url": "https://github.com/rust-lang/rust/commit/0ff9872b2280009f094af0df3dcdc542cc46a5fd"}], "stats": {"total": 240, "additions": 218, "deletions": 22}, "files": [{"sha": "c3aaeae69633faebd537a52f13f8b6b4cac759e1", "filename": "src/librustc_typeck/check/wfcheck.rs", "status": "modified", "additions": 124, "deletions": 22, "changes": 146, "blob_url": "https://github.com/rust-lang/rust/blob/4d9703373d91fe83155798be0571b3349a9513f9/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4d9703373d91fe83155798be0571b3349a9513f9/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs?ref=4d9703373d91fe83155798be0571b3349a9513f9", "patch": "@@ -185,10 +185,7 @@ impl<'a, 'gcx> CheckTypeWellFormedVisitor<'a, 'gcx> {\n                     reject_shadowing_type_parameters(fcx.tcx, item.def_id);\n                     let sig = fcx.tcx.fn_sig(item.def_id);\n                     let sig = fcx.normalize_associated_types_in(span, &sig);\n-                    let predicates = fcx.tcx.predicates_of(item.def_id)\n-                        .instantiate_identity(fcx.tcx);\n-                    let predicates = fcx.normalize_associated_types_in(span, &predicates);\n-                    this.check_fn_or_method(fcx, span, sig, &predicates,\n+                    this.check_fn_or_method(fcx, span, sig,\n                                             item.def_id, &mut implied_bounds);\n                     let sig_if_method = sig_if_method.expect(\"bad signature for method\");\n                     this.check_method_receiver(fcx, sig_if_method, &item, self_ty);\n@@ -272,20 +269,17 @@ impl<'a, 'gcx> CheckTypeWellFormedVisitor<'a, 'gcx> {\n                 }\n             }\n \n-            let predicates = fcx.tcx.predicates_of(def_id).instantiate_identity(fcx.tcx);\n-            let predicates = fcx.normalize_associated_types_in(item.span, &predicates);\n-            this.check_where_clauses(fcx, item.span, &predicates);\n+            self.check_where_clauses(fcx, item.span, def_id);\n \n             vec![] // no implied bounds in a struct def'n\n         });\n     }\n \n     fn check_trait(&mut self, item: &hir::Item) {\n         let trait_def_id = self.tcx.hir.local_def_id(item.id);\n-        self.for_item(item).with_fcx(|fcx, this| {\n-            let predicates = fcx.tcx.predicates_of(trait_def_id).instantiate_identity(fcx.tcx);\n-            let predicates = fcx.normalize_associated_types_in(item.span, &predicates);\n-            this.check_where_clauses(fcx, item.span, &predicates);\n+        \n+        self.for_item(item).with_fcx(|fcx, _| {\n+            self.check_where_clauses(fcx, item.span, trait_def_id);\n             vec![]\n         });\n     }\n@@ -295,12 +289,8 @@ impl<'a, 'gcx> CheckTypeWellFormedVisitor<'a, 'gcx> {\n             let def_id = fcx.tcx.hir.local_def_id(item.id);\n             let sig = fcx.tcx.fn_sig(def_id);\n             let sig = fcx.normalize_associated_types_in(item.span, &sig);\n-\n-            let predicates = fcx.tcx.predicates_of(def_id).instantiate_identity(fcx.tcx);\n-            let predicates = fcx.normalize_associated_types_in(item.span, &predicates);\n-\n             let mut implied_bounds = vec![];\n-            this.check_fn_or_method(fcx, item.span, sig, &predicates,\n+            this.check_fn_or_method(fcx, item.span, sig,\n                                     def_id, &mut implied_bounds);\n             implied_bounds\n         })\n@@ -354,19 +344,132 @@ impl<'a, 'gcx> CheckTypeWellFormedVisitor<'a, 'gcx> {\n                 }\n             }\n \n-            let predicates = fcx.tcx.predicates_of(item_def_id).instantiate_identity(fcx.tcx);\n-            let predicates = fcx.normalize_associated_types_in(item.span, &predicates);\n-            this.check_where_clauses(fcx, item.span, &predicates);\n+            this.check_where_clauses(fcx, item.span, item_def_id);\n \n             fcx.impl_implied_bounds(item_def_id, item.span)\n         });\n     }\n \n+    /// Checks where clauses and inline bounds.\n     fn check_where_clauses<'fcx, 'tcx>(&mut self,\n                                        fcx: &FnCtxt<'fcx, 'gcx, 'tcx>,\n                                        span: Span,\n-                                       predicates: &ty::InstantiatedPredicates<'tcx>)\n+                                       def_id: DefId)\n     {\n+        use ty::subst::Subst;\n+        use ty::Predicate;\n+\n+        // Check that each default fulfills the bounds on it's parameter.\n+        // We go over each predicate and duplicate it, substituting defaults in the self type.\n+        let mut predicates = fcx.tcx.predicates_of(def_id);\n+        let mut default_predicates = Vec::new();\n+        for pred in &predicates.predicates {\n+            let mut self_ty = match pred {\n+                Predicate::Trait(trait_pred) => trait_pred.skip_binder().self_ty(),\n+                Predicate::TypeOutlives(outlives_pred) => (outlives_pred.0).0,\n+                Predicate::Projection(proj_pred) => {\n+                    fcx.tcx.mk_ty(ty::TyProjection(proj_pred.skip_binder().projection_ty))\n+                }\n+                // Lifetime params can't have defaults.\n+                Predicate::RegionOutlives(..) => continue,\n+                _ => bug!(\"Predicate {:?} not supported in where clauses.\", pred)\n+            };\n+\n+            let mut skip = false;\n+            let mut no_default = true;\n+            let generics = self.tcx.generics_of(def_id);\n+            let substs = ty::subst::Substs::for_item(fcx.tcx, def_id, |def, _| {\n+                // All regions are identity.\n+                fcx.tcx.mk_region(ty::ReEarlyBound(def.to_early_bound_region_data()))\n+            }, |def, _| {\n+                // No default or generic comes from parent, identity substitution.\n+                if !def.has_default || (def.index as usize) < generics.parent_count() {\n+                    fcx.tcx.mk_param_from_def(def)\n+                } else {\n+                    no_default = false;\n+                    // Has a default, use it in the substitution.\n+                    let default_ty = fcx.tcx.type_of(def.def_id);\n+                    // Skip `Self : Self` in traits, it's problematic.\n+                    // This means we probably check less than we could.\n+                    let should_skip = match self_ty.sty {\n+                        ty::TyParam(ref p) => {\n+                            // lhs is Self && rhs is Self\n+                            p.is_self() && match pred {\n+                                Predicate::Trait(p) => p.def_id() == def_id,\n+                                Predicate::TypeOutlives(_) => false,\n+                                _ => bug!(\"Unexpected predicate {:?}\", pred)\n+                            }\n+                        }\n+                        ty::TyProjection(ref proj) => {\n+                            let mut projection = proj;\n+                            let mut next_typ = &projection.substs[0].as_type().unwrap().sty;\n+                            // Dig through projections.\n+                            while let ty::TyProjection(ref proj) = next_typ {\n+                                projection = proj;\n+                                next_typ = &projection.substs[0].as_type().unwrap().sty;\n+                            }\n+                            let lhs_is_self = match next_typ {\n+                                ty::TyParam(ref p) => p.is_self(),\n+                                _ => false\n+                            };\n+                            let rhs = fcx.tcx.associated_item(projection.item_def_id)\n+                                                     .container\n+                                                     .assert_trait();\n+                            lhs_is_self && rhs == def_id\n+                        }\n+                        _ => false\n+                    };\n+                    skip = skip || should_skip;\n+\n+                   match default_ty.sty {\n+                        // Skip `Self: Sized` when `Self` is the default. Needed in traits.\n+                        ty::TyParam(ref p) if p.is_self() => {\n+                            if let Predicate::Trait(p) = pred {\n+                                if Some(p.def_id()) == fcx.tcx.lang_items().sized_trait() {\n+                                    skip = true;\n+                                }\n+                            }\n+                        }\n+                        _ => ()\n+                    }\n+                    default_ty\n+                }\n+            });\n+\n+            if skip || no_default {\n+                continue;\n+            }\n+\n+            self_ty = self_ty.subst(fcx.tcx, substs);\n+            default_predicates.push(match pred {\n+                Predicate::Trait(trait_pred) => {\n+                    let mut substs = trait_pred.skip_binder().trait_ref.substs.to_vec();\n+                    substs[0] = self_ty.into();\n+                    let substs = fcx.tcx.intern_substs(&substs);\n+                    let trait_ref = ty::Binder(ty::TraitRef::new(trait_pred.def_id(), substs));\n+                    Predicate::Trait(trait_ref.to_poly_trait_predicate())\n+                }\n+                Predicate::TypeOutlives(pred) => {\n+                    Predicate::TypeOutlives(ty::Binder(ty::OutlivesPredicate(self_ty, (pred.0).1)))\n+                }\n+                Predicate::Projection(proj_pred) => {\n+                    let projection_ty = match self_ty.sty {\n+                        ty::TyProjection(proj_ty) => proj_ty,\n+                        _ => bug!(\"self_ty not projection for projection predicate.\")\n+                    };\n+                    Predicate::Projection(ty::Binder(ty::ProjectionPredicate {\n+                                                        projection_ty,\n+                                                        ty: proj_pred.ty().skip_binder()\n+                                                    }))\n+                }\n+                _ => bug!(\"Predicate {:?} not supported for type params.\", pred)\n+            });\n+        }\n+\n+        predicates.predicates.extend(default_predicates);\n+        let predicates = predicates.instantiate_identity(fcx.tcx);\n+        let predicates = fcx.normalize_associated_types_in(span, &predicates);\n+\n         let obligations =\n             predicates.predicates\n                       .iter()\n@@ -385,7 +488,6 @@ impl<'a, 'gcx> CheckTypeWellFormedVisitor<'a, 'gcx> {\n                                       fcx: &FnCtxt<'fcx, 'gcx, 'tcx>,\n                                       span: Span,\n                                       sig: ty::PolyFnSig<'tcx>,\n-                                      predicates: &ty::InstantiatedPredicates<'tcx>,\n                                       def_id: DefId,\n                                       implied_bounds: &mut Vec<Ty<'tcx>>)\n     {\n@@ -402,7 +504,7 @@ impl<'a, 'gcx> CheckTypeWellFormedVisitor<'a, 'gcx> {\n         // FIXME(#25759) return types should not be implied bounds\n         implied_bounds.push(sig.output());\n \n-        self.check_where_clauses(fcx, span, predicates);\n+        self.check_where_clauses(fcx, span, def_id);\n     }\n \n     fn check_method_receiver<'fcx, 'tcx>(&mut self,"}, {"sha": "67b1d2c06e314cb650befe8cfe85160843f96623", "filename": "src/test/run-pass/type-macros-simple.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/4d9703373d91fe83155798be0571b3349a9513f9/src%2Ftest%2Frun-pass%2Ftype-macros-simple.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4d9703373d91fe83155798be0571b3349a9513f9/src%2Ftest%2Frun-pass%2Ftype-macros-simple.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftype-macros-simple.rs?ref=4d9703373d91fe83155798be0571b3349a9513f9", "patch": "@@ -34,3 +34,4 @@ fn issue_36540() {\n }\n \n trait Trait<T> {}\n+impl Trait<i32> for i32 {}"}, {"sha": "6e50dd46afc716148567d463164b707e57a0eeb6", "filename": "src/test/ui/type-check-defaults.rs", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/4d9703373d91fe83155798be0571b3349a9513f9/src%2Ftest%2Fui%2Ftype-check-defaults.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4d9703373d91fe83155798be0571b3349a9513f9/src%2Ftest%2Fui%2Ftype-check-defaults.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-check-defaults.rs?ref=4d9703373d91fe83155798be0571b3349a9513f9", "patch": "@@ -0,0 +1,31 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+// compile-flags: --error-format=human\n+\n+use std::iter::FromIterator;\n+use std::vec::IntoIter;\n+use std::ops::Add;\n+\n+struct Foo<T, U: FromIterator<T>>(T, U);\n+struct WellFormed<Z = Foo<i32, i32>>(Z);\n+\n+struct WellFormedProjection<A, T=<A as Iterator>::Item>(A, T);\n+\n+struct Bounds<T:Copy=String>(T);\n+\n+struct WhereClause<T=String>(T) where T: Copy;\n+\n+trait TraitBound<T:Copy=String> {}\n+\n+trait SelfBound<T:Copy=Self> {}\n+\n+trait FooTrait<T:Iterator = IntoIter<i32>> where T::Item : Add<u8> {}\n+\n+fn main() { }"}, {"sha": "6f9fee62e50769ac7ce137a0a6c007f9f05480d2", "filename": "src/test/ui/type-check-defaults.stderr", "status": "added", "additions": 62, "deletions": 0, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/4d9703373d91fe83155798be0571b3349a9513f9/src%2Ftest%2Fui%2Ftype-check-defaults.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/4d9703373d91fe83155798be0571b3349a9513f9/src%2Ftest%2Fui%2Ftype-check-defaults.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-check-defaults.stderr?ref=4d9703373d91fe83155798be0571b3349a9513f9", "patch": "@@ -0,0 +1,62 @@\n+error[E0277]: the trait bound `i32: std::iter::FromIterator<i32>` is not satisfied\n+  --> $DIR/type-check-defaults.rs:17:1\n+   |\n+17 | struct WellFormed<Z = Foo<i32, i32>>(Z);\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ a collection of type `i32` cannot be built from an iterator over elements of type `i32`\n+   |\n+   = help: the trait `std::iter::FromIterator<i32>` is not implemented for `i32`\n+   = note: required by `Foo`\n+\n+error[E0277]: the trait bound `A: std::iter::Iterator` is not satisfied\n+  --> $DIR/type-check-defaults.rs:19:1\n+   |\n+19 | struct WellFormedProjection<A, T=<A as Iterator>::Item>(A, T);\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ `A` is not an iterator; maybe try calling `.iter()` or a similar method\n+   |\n+   = help: the trait `std::iter::Iterator` is not implemented for `A`\n+   = help: consider adding a `where A: std::iter::Iterator` bound\n+\n+error[E0277]: the trait bound `std::string::String: std::marker::Copy` is not satisfied\n+  --> $DIR/type-check-defaults.rs:21:1\n+   |\n+21 | struct Bounds<T:Copy=String>(T);\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ the trait `std::marker::Copy` is not implemented for `std::string::String`\n+   |\n+   = note: required by `std::marker::Copy`\n+\n+error[E0277]: the trait bound `std::string::String: std::marker::Copy` is not satisfied\n+  --> $DIR/type-check-defaults.rs:23:1\n+   |\n+23 | struct WhereClause<T=String>(T) where T: Copy;\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ the trait `std::marker::Copy` is not implemented for `std::string::String`\n+   |\n+   = note: required by `std::marker::Copy`\n+\n+error[E0277]: the trait bound `std::string::String: std::marker::Copy` is not satisfied\n+  --> $DIR/type-check-defaults.rs:25:1\n+   |\n+25 | trait TraitBound<T:Copy=String> {}\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ the trait `std::marker::Copy` is not implemented for `std::string::String`\n+   |\n+   = note: required by `std::marker::Copy`\n+\n+error[E0277]: the trait bound `Self: std::marker::Copy` is not satisfied\n+  --> $DIR/type-check-defaults.rs:27:1\n+   |\n+27 | trait SelfBound<T:Copy=Self> {}\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ the trait `std::marker::Copy` is not implemented for `Self`\n+   |\n+   = help: consider adding a `where Self: std::marker::Copy` bound\n+   = note: required by `std::marker::Copy`\n+\n+error[E0277]: the trait bound `i32: std::ops::Add<u8>` is not satisfied\n+  --> $DIR/type-check-defaults.rs:29:1\n+   |\n+29 | trait FooTrait<T:Iterator = IntoIter<i32>> where T::Item : Add<u8> {}\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ no implementation for `i32 + u8`\n+   |\n+   = help: the trait `std::ops::Add<u8>` is not implemented for `i32`\n+   = note: required by `std::ops::Add`\n+\n+error: aborting due to 7 previous errors\n+"}]}