{"sha": "e34caaf42dd10b3cb8d14e6e99c2c8687fe6342e", "node_id": "C_kwDOAAsO6NoAKGUzNGNhYWY0MmRkMTBiM2NiOGQxNGU2ZTk5YzJjODY4N2ZlNjM0MmU", "commit": {"author": {"name": "Camille GILLOT", "email": "gillot.camille@gmail.com", "date": "2023-02-08T20:28:39Z"}, "committer": {"name": "Camille GILLOT", "email": "gillot.camille@gmail.com", "date": "2023-02-18T21:35:02Z"}, "message": "Remove overflow checks from ConstProp.", "tree": {"sha": "e5b74ecd2b2d7936beaec81252cc5d97e579847b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e5b74ecd2b2d7936beaec81252cc5d97e579847b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e34caaf42dd10b3cb8d14e6e99c2c8687fe6342e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e34caaf42dd10b3cb8d14e6e99c2c8687fe6342e", "html_url": "https://github.com/rust-lang/rust/commit/e34caaf42dd10b3cb8d14e6e99c2c8687fe6342e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e34caaf42dd10b3cb8d14e6e99c2c8687fe6342e/comments", "author": {"login": "cjgillot", "id": 1822483, "node_id": "MDQ6VXNlcjE4MjI0ODM=", "avatar_url": "https://avatars.githubusercontent.com/u/1822483?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cjgillot", "html_url": "https://github.com/cjgillot", "followers_url": "https://api.github.com/users/cjgillot/followers", "following_url": "https://api.github.com/users/cjgillot/following{/other_user}", "gists_url": "https://api.github.com/users/cjgillot/gists{/gist_id}", "starred_url": "https://api.github.com/users/cjgillot/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cjgillot/subscriptions", "organizations_url": "https://api.github.com/users/cjgillot/orgs", "repos_url": "https://api.github.com/users/cjgillot/repos", "events_url": "https://api.github.com/users/cjgillot/events{/privacy}", "received_events_url": "https://api.github.com/users/cjgillot/received_events", "type": "User", "site_admin": false}, "committer": {"login": "cjgillot", "id": 1822483, "node_id": "MDQ6VXNlcjE4MjI0ODM=", "avatar_url": "https://avatars.githubusercontent.com/u/1822483?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cjgillot", "html_url": "https://github.com/cjgillot", "followers_url": "https://api.github.com/users/cjgillot/followers", "following_url": "https://api.github.com/users/cjgillot/following{/other_user}", "gists_url": "https://api.github.com/users/cjgillot/gists{/gist_id}", "starred_url": "https://api.github.com/users/cjgillot/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cjgillot/subscriptions", "organizations_url": "https://api.github.com/users/cjgillot/orgs", "repos_url": "https://api.github.com/users/cjgillot/repos", "events_url": "https://api.github.com/users/cjgillot/events{/privacy}", "received_events_url": "https://api.github.com/users/cjgillot/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4bd2ebc58bed1ee5bf7ff934999e3db3c6e9f22d", "url": "https://api.github.com/repos/rust-lang/rust/commits/4bd2ebc58bed1ee5bf7ff934999e3db3c6e9f22d", "html_url": "https://github.com/rust-lang/rust/commit/4bd2ebc58bed1ee5bf7ff934999e3db3c6e9f22d"}], "stats": {"total": 204, "additions": 88, "deletions": 116}, "files": [{"sha": "33ee90ffc119dc132114f1fbd749e54364690004", "filename": "compiler/rustc_mir_transform/src/const_prop.rs", "status": "modified", "additions": 15, "deletions": 96, "changes": 111, "blob_url": "https://github.com/rust-lang/rust/blob/e34caaf42dd10b3cb8d14e6e99c2c8687fe6342e/compiler%2Frustc_mir_transform%2Fsrc%2Fconst_prop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e34caaf42dd10b3cb8d14e6e99c2c8687fe6342e/compiler%2Frustc_mir_transform%2Fsrc%2Fconst_prop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Fconst_prop.rs?ref=e34caaf42dd10b3cb8d14e6e99c2c8687fe6342e", "patch": "@@ -15,7 +15,7 @@ use rustc_middle::mir::visit::{\n };\n use rustc_middle::mir::{\n     BasicBlock, BinOp, Body, Constant, ConstantKind, Local, LocalDecl, LocalKind, Location,\n-    Operand, Place, Rvalue, SourceInfo, Statement, StatementKind, Terminator, TerminatorKind, UnOp,\n+    Operand, Place, Rvalue, SourceInfo, Statement, StatementKind, Terminator, TerminatorKind,\n     RETURN_PLACE,\n };\n use rustc_middle::ty::layout::{LayoutError, LayoutOf, LayoutOfHelpers, TyAndLayout};\n@@ -503,55 +503,6 @@ impl<'mir, 'tcx> ConstPropagator<'mir, 'tcx> {\n         }\n     }\n \n-    fn check_unary_op(&mut self, op: UnOp, arg: &Operand<'tcx>) -> Option<()> {\n-        if self.use_ecx(|this| {\n-            let val = this.ecx.read_immediate(&this.ecx.eval_operand(arg, None)?)?;\n-            let (_res, overflow, _ty) = this.ecx.overflowing_unary_op(op, &val)?;\n-            Ok(overflow)\n-        })? {\n-            // `AssertKind` only has an `OverflowNeg` variant, so make sure that is\n-            // appropriate to use.\n-            assert_eq!(op, UnOp::Neg, \"Neg is the only UnOp that can overflow\");\n-            return None;\n-        }\n-\n-        Some(())\n-    }\n-\n-    fn check_binary_op(\n-        &mut self,\n-        op: BinOp,\n-        left: &Operand<'tcx>,\n-        right: &Operand<'tcx>,\n-    ) -> Option<()> {\n-        let r = self.use_ecx(|this| this.ecx.read_immediate(&this.ecx.eval_operand(right, None)?));\n-        let l = self.use_ecx(|this| this.ecx.read_immediate(&this.ecx.eval_operand(left, None)?));\n-        // Check for exceeding shifts *even if* we cannot evaluate the LHS.\n-        if matches!(op, BinOp::Shr | BinOp::Shl) {\n-            let r = r.clone()?;\n-            // We need the type of the LHS. We cannot use `place_layout` as that is the type\n-            // of the result, which for checked binops is not the same!\n-            let left_ty = left.ty(self.local_decls, self.tcx);\n-            let left_size = self.ecx.layout_of(left_ty).ok()?.size;\n-            let right_size = r.layout.size;\n-            let r_bits = r.to_scalar().to_bits(right_size).ok();\n-            if r_bits.map_or(false, |b| b >= left_size.bits() as u128) {\n-                return None;\n-            }\n-        }\n-\n-        if let (Some(l), Some(r)) = (&l, &r) {\n-            // The remaining operators are handled through `overflowing_binary_op`.\n-            if self.use_ecx(|this| {\n-                let (_res, overflow, _ty) = this.ecx.overflowing_binary_op(op, l, r)?;\n-                Ok(overflow)\n-            })? {\n-                return None;\n-            }\n-        }\n-        Some(())\n-    }\n-\n     fn propagate_operand(&mut self, operand: &mut Operand<'tcx>) {\n         match *operand {\n             Operand::Copy(l) | Operand::Move(l) => {\n@@ -587,28 +538,6 @@ impl<'mir, 'tcx> ConstPropagator<'mir, 'tcx> {\n         //   2. Working around bugs in other parts of the compiler\n         //        - In this case, we'll return `None` from this function to stop evaluation.\n         match rvalue {\n-            // Additional checking: give lints to the user if an overflow would occur.\n-            // We do this here and not in the `Assert` terminator as that terminator is\n-            // only sometimes emitted (overflow checks can be disabled), but we want to always\n-            // lint.\n-            Rvalue::UnaryOp(op, arg) => {\n-                trace!(\"checking UnaryOp(op = {:?}, arg = {:?})\", op, arg);\n-                self.check_unary_op(*op, arg)?;\n-            }\n-            Rvalue::BinaryOp(op, box (left, right)) => {\n-                trace!(\"checking BinaryOp(op = {:?}, left = {:?}, right = {:?})\", op, left, right);\n-                self.check_binary_op(*op, left, right)?;\n-            }\n-            Rvalue::CheckedBinaryOp(op, box (left, right)) => {\n-                trace!(\n-                    \"checking CheckedBinaryOp(op = {:?}, left = {:?}, right = {:?})\",\n-                    op,\n-                    left,\n-                    right\n-                );\n-                self.check_binary_op(*op, left, right)?;\n-            }\n-\n             // Do not try creating references (#67862)\n             Rvalue::AddressOf(_, place) | Rvalue::Ref(_, _, place) => {\n                 trace!(\"skipping AddressOf | Ref for {:?}\", place);\n@@ -638,7 +567,10 @@ impl<'mir, 'tcx> ConstPropagator<'mir, 'tcx> {\n             | Rvalue::Cast(..)\n             | Rvalue::ShallowInitBox(..)\n             | Rvalue::Discriminant(..)\n-            | Rvalue::NullaryOp(..) => {}\n+            | Rvalue::NullaryOp(..)\n+            | Rvalue::UnaryOp(..)\n+            | Rvalue::BinaryOp(..)\n+            | Rvalue::CheckedBinaryOp(..) => {}\n         }\n \n         // FIXME we need to revisit this for #67176\n@@ -1079,31 +1011,18 @@ impl<'tcx> MutVisitor<'tcx> for ConstPropagator<'_, 'tcx> {\n         // Do NOT early return in this function, it does some crucial fixup of the state at the end!\n         match &mut terminator.kind {\n             TerminatorKind::Assert { expected, ref mut cond, .. } => {\n-                if let Some(ref value) = self.eval_operand(&cond) {\n-                    trace!(\"assertion on {:?} should be {:?}\", value, expected);\n-                    let expected = Scalar::from_bool(*expected);\n+                if let Some(ref value) = self.eval_operand(&cond)\n                     // FIXME should be used use_ecx rather than a local match... but we have\n                     // quite a few of these read_scalar/read_immediate that need fixing.\n-                    if let Ok(value_const) = self.ecx.read_scalar(&value) {\n-                        if expected != value_const {\n-                            // Poison all places this operand references so that further code\n-                            // doesn't use the invalid value\n-                            match cond {\n-                                Operand::Move(ref place) | Operand::Copy(ref place) => {\n-                                    Self::remove_const(&mut self.ecx, place.local);\n-                                }\n-                                Operand::Constant(_) => {}\n-                            }\n-                        } else {\n-                            if self.should_const_prop(value) {\n-                                *cond = self.operand_from_scalar(\n-                                    value_const,\n-                                    self.tcx.types.bool,\n-                                    source_info.span,\n-                                );\n-                            }\n-                        }\n-                    }\n+                    && let Ok(value_const) = self.ecx.read_scalar(&value)\n+                    && self.should_const_prop(value)\n+                {\n+                    trace!(\"assertion on {:?} should be {:?}\", value, expected);\n+                    *cond = self.operand_from_scalar(\n+                        value_const,\n+                        self.tcx.types.bool,\n+                        source_info.span,\n+                    );\n                 }\n             }\n             TerminatorKind::SwitchInt { ref mut discr, .. } => {"}, {"sha": "19019e3ef744aa8cd7121ef89da72eb654656b8a", "filename": "compiler/rustc_mir_transform/src/dataflow_const_prop.rs", "status": "modified", "additions": 1, "deletions": 6, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/e34caaf42dd10b3cb8d14e6e99c2c8687fe6342e/compiler%2Frustc_mir_transform%2Fsrc%2Fdataflow_const_prop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e34caaf42dd10b3cb8d14e6e99c2c8687fe6342e/compiler%2Frustc_mir_transform%2Fsrc%2Fdataflow_const_prop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Fdataflow_const_prop.rs?ref=e34caaf42dd10b3cb8d14e6e99c2c8687fe6342e", "patch": "@@ -180,12 +180,7 @@ impl<'tcx> ValueAnalysis<'tcx> for ConstAnalysis<'_, 'tcx> {\n                         let overflow = match overflow {\n                             FlatSet::Top => FlatSet::Top,\n                             FlatSet::Elem(overflow) => {\n-                                if overflow {\n-                                    // Overflow cannot be reliably propagated. See: https://github.com/rust-lang/rust/pull/101168#issuecomment-1288091446\n-                                    FlatSet::Top\n-                                } else {\n-                                    self.wrap_scalar(Scalar::from_bool(false), self.tcx.types.bool)\n-                                }\n+                                self.wrap_scalar(Scalar::from_bool(overflow), self.tcx.types.bool)\n                             }\n                             FlatSet::Bottom => FlatSet::Bottom,\n                         };"}, {"sha": "900061a484b3884b85d103d4c532b93ba6ac05d5", "filename": "tests/mir-opt/const_prop/bad_op_div_by_zero.main.ConstProp.diff", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/e34caaf42dd10b3cb8d14e6e99c2c8687fe6342e/tests%2Fmir-opt%2Fconst_prop%2Fbad_op_div_by_zero.main.ConstProp.diff", "raw_url": "https://github.com/rust-lang/rust/raw/e34caaf42dd10b3cb8d14e6e99c2c8687fe6342e/tests%2Fmir-opt%2Fconst_prop%2Fbad_op_div_by_zero.main.ConstProp.diff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fmir-opt%2Fconst_prop%2Fbad_op_div_by_zero.main.ConstProp.diff?ref=e34caaf42dd10b3cb8d14e6e99c2c8687fe6342e", "patch": "@@ -24,9 +24,10 @@\n           StorageLive(_3);                 // scope 1 at $DIR/bad_op_div_by_zero.rs:+2:18: +2:19\n -         _3 = _1;                         // scope 1 at $DIR/bad_op_div_by_zero.rs:+2:18: +2:19\n -         _4 = Eq(_3, const 0_i32);        // scope 1 at $DIR/bad_op_div_by_zero.rs:+2:14: +2:19\n+-         assert(!move _4, \"attempt to divide `{}` by zero\", const 1_i32) -> bb1; // scope 1 at $DIR/bad_op_div_by_zero.rs:+2:14: +2:19\n +         _3 = const 0_i32;                // scope 1 at $DIR/bad_op_div_by_zero.rs:+2:18: +2:19\n +         _4 = const true;                 // scope 1 at $DIR/bad_op_div_by_zero.rs:+2:14: +2:19\n-          assert(!move _4, \"attempt to divide `{}` by zero\", const 1_i32) -> bb1; // scope 1 at $DIR/bad_op_div_by_zero.rs:+2:14: +2:19\n++         assert(!const true, \"attempt to divide `{}` by zero\", const 1_i32) -> bb1; // scope 1 at $DIR/bad_op_div_by_zero.rs:+2:14: +2:19\n       }\n   \n       bb1: {"}, {"sha": "d03c23a3fb56c1893155f6bab9c589ba2f15bb7c", "filename": "tests/mir-opt/const_prop/inherit_overflow.main.ConstProp.diff", "status": "added", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/e34caaf42dd10b3cb8d14e6e99c2c8687fe6342e/tests%2Fmir-opt%2Fconst_prop%2Finherit_overflow.main.ConstProp.diff", "raw_url": "https://github.com/rust-lang/rust/raw/e34caaf42dd10b3cb8d14e6e99c2c8687fe6342e/tests%2Fmir-opt%2Fconst_prop%2Finherit_overflow.main.ConstProp.diff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fmir-opt%2Fconst_prop%2Finherit_overflow.main.ConstProp.diff?ref=e34caaf42dd10b3cb8d14e6e99c2c8687fe6342e", "patch": "@@ -0,0 +1,39 @@\n+- // MIR for `main` before ConstProp\n++ // MIR for `main` after ConstProp\n+  \n+  fn main() -> () {\n+      let mut _0: ();                      // return place in scope 0 at $DIR/inherit_overflow.rs:+0:11: +0:11\n+      let mut _1: u8;                      // in scope 0 at $DIR/inherit_overflow.rs:+3:13: +3:47\n+      let mut _2: u8;                      // in scope 0 at $DIR/inherit_overflow.rs:+3:13: +3:47\n+      let mut _3: u8;                      // in scope 0 at $DIR/inherit_overflow.rs:+3:13: +3:47\n+      scope 1 {\n+      }\n+      scope 2 (inlined <u8 as Add>::add) { // at $DIR/inherit_overflow.rs:8:13: 8:47\n+          debug self => _2;                // in scope 2 at $SRC_DIR/core/src/ops/arith.rs:LL:COL\n+          debug other => _3;               // in scope 2 at $SRC_DIR/core/src/ops/arith.rs:LL:COL\n+          let mut _4: (u8, bool);          // in scope 2 at $SRC_DIR/core/src/ops/arith.rs:LL:COL\n+      }\n+  \n+      bb0: {\n+          StorageLive(_1);                 // scope 0 at $DIR/inherit_overflow.rs:+3:13: +3:47\n+          StorageLive(_2);                 // scope 0 at $DIR/inherit_overflow.rs:+3:13: +3:47\n+          _2 = const u8::MAX;              // scope 0 at $DIR/inherit_overflow.rs:+3:13: +3:47\n+          StorageLive(_3);                 // scope 0 at $DIR/inherit_overflow.rs:+3:13: +3:47\n+          _3 = const 1_u8;                 // scope 0 at $DIR/inherit_overflow.rs:+3:13: +3:47\n+-         _4 = CheckedAdd(_2, _3);         // scope 2 at $SRC_DIR/core/src/ops/arith.rs:LL:COL\n+-         assert(!move (_4.1: bool), \"attempt to compute `{} + {}`, which would overflow\", _2, _3) -> bb1; // scope 2 at $SRC_DIR/core/src/ops/arith.rs:LL:COL\n++         _4 = const (0_u8, true);         // scope 2 at $SRC_DIR/core/src/ops/arith.rs:LL:COL\n++         assert(!const true, \"attempt to compute `{} + {}`, which would overflow\", _2, _3) -> bb1; // scope 2 at $SRC_DIR/core/src/ops/arith.rs:LL:COL\n+      }\n+  \n+      bb1: {\n+-         _1 = move (_4.0: u8);            // scope 2 at $SRC_DIR/core/src/ops/arith.rs:LL:COL\n++         _1 = const 0_u8;                 // scope 2 at $SRC_DIR/core/src/ops/arith.rs:LL:COL\n+          StorageDead(_3);                 // scope 0 at $DIR/inherit_overflow.rs:+3:13: +3:47\n+          StorageDead(_2);                 // scope 0 at $DIR/inherit_overflow.rs:+3:13: +3:47\n+          StorageDead(_1);                 // scope 0 at $DIR/inherit_overflow.rs:+3:47: +3:48\n+          _0 = const ();                   // scope 0 at $DIR/inherit_overflow.rs:+0:11: +4:2\n+          return;                          // scope 0 at $DIR/inherit_overflow.rs:+4:2: +4:2\n+      }\n+  }\n+  "}, {"sha": "541a8c5c3af28779366e6b21334e5681c5497933", "filename": "tests/mir-opt/const_prop/inherit_overflow.rs", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/e34caaf42dd10b3cb8d14e6e99c2c8687fe6342e/tests%2Fmir-opt%2Fconst_prop%2Finherit_overflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e34caaf42dd10b3cb8d14e6e99c2c8687fe6342e/tests%2Fmir-opt%2Fconst_prop%2Finherit_overflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fmir-opt%2Fconst_prop%2Finherit_overflow.rs?ref=e34caaf42dd10b3cb8d14e6e99c2c8687fe6342e", "patch": "@@ -0,0 +1,9 @@\n+// unit-test: ConstProp\n+// compile-flags: -Zmir-enable-passes=+Inline\n+\n+// EMIT_MIR inherit_overflow.main.ConstProp.diff\n+fn main() {\n+    // After inlining, this will contain a `CheckedBinaryOp`.\n+    // Propagating the overflow is ok as codegen will just skip emitting the panic.\n+    let _ = <u8 as std::ops::Add>::add(255, 1);\n+}"}, {"sha": "944afed8f465abd701e2c10dc3f59997cfc1364e", "filename": "tests/mir-opt/dataflow-const-prop/checked.main.DataflowConstProp.diff", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e34caaf42dd10b3cb8d14e6e99c2c8687fe6342e/tests%2Fmir-opt%2Fdataflow-const-prop%2Fchecked.main.DataflowConstProp.diff", "raw_url": "https://github.com/rust-lang/rust/raw/e34caaf42dd10b3cb8d14e6e99c2c8687fe6342e/tests%2Fmir-opt%2Fdataflow-const-prop%2Fchecked.main.DataflowConstProp.diff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fmir-opt%2Fdataflow-const-prop%2Fchecked.main.DataflowConstProp.diff?ref=e34caaf42dd10b3cb8d14e6e99c2c8687fe6342e", "patch": "@@ -61,7 +61,7 @@\n -         assert(!move (_10.1: bool), \"attempt to compute `{} + {}`, which would overflow\", move _9, const 1_i32) -> bb2; // scope 4 at $DIR/checked.rs:+6:13: +6:18\n +         _9 = const i32::MAX;             // scope 4 at $DIR/checked.rs:+6:13: +6:14\n +         _10 = CheckedAdd(const i32::MAX, const 1_i32); // scope 4 at $DIR/checked.rs:+6:13: +6:18\n-+         assert(!move (_10.1: bool), \"attempt to compute `{} + {}`, which would overflow\", const i32::MAX, const 1_i32) -> bb2; // scope 4 at $DIR/checked.rs:+6:13: +6:18\n++         assert(!const true, \"attempt to compute `{} + {}`, which would overflow\", const i32::MAX, const 1_i32) -> bb2; // scope 4 at $DIR/checked.rs:+6:13: +6:18\n       }\n   \n       bb2: {"}, {"sha": "29781e9ce18866feb12327d4f7c7378fcbce7e6f", "filename": "tests/mir-opt/dataflow-const-prop/inherit_overflow.main.DataflowConstProp.diff", "status": "modified", "additions": 17, "deletions": 9, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/e34caaf42dd10b3cb8d14e6e99c2c8687fe6342e/tests%2Fmir-opt%2Fdataflow-const-prop%2Finherit_overflow.main.DataflowConstProp.diff", "raw_url": "https://github.com/rust-lang/rust/raw/e34caaf42dd10b3cb8d14e6e99c2c8687fe6342e/tests%2Fmir-opt%2Fdataflow-const-prop%2Finherit_overflow.main.DataflowConstProp.diff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fmir-opt%2Fdataflow-const-prop%2Finherit_overflow.main.DataflowConstProp.diff?ref=e34caaf42dd10b3cb8d14e6e99c2c8687fe6342e", "patch": "@@ -5,26 +5,34 @@\n       let mut _0: ();                      // return place in scope 0 at $DIR/inherit_overflow.rs:+0:11: +0:11\n       let mut _1: u8;                      // in scope 0 at $DIR/inherit_overflow.rs:+3:13: +3:47\n       let mut _2: u8;                      // in scope 0 at $DIR/inherit_overflow.rs:+3:13: +3:47\n+      let mut _3: u8;                      // in scope 0 at $DIR/inherit_overflow.rs:+3:13: +3:47\n       scope 1 {\n       }\n-      scope 2 (inlined <u8 as Add>::add) { // at $DIR/inherit_overflow.rs:7:13: 7:47\n-          debug self => _1;                // in scope 2 at $SRC_DIR/core/src/ops/arith.rs:LL:COL\n-          debug other => _2;               // in scope 2 at $SRC_DIR/core/src/ops/arith.rs:LL:COL\n-          let mut _3: (u8, bool);          // in scope 2 at $SRC_DIR/core/src/ops/arith.rs:LL:COL\n+      scope 2 (inlined <u8 as Add>::add) { // at $DIR/inherit_overflow.rs:8:13: 8:47\n+          debug self => _2;                // in scope 2 at $SRC_DIR/core/src/ops/arith.rs:LL:COL\n+          debug other => _3;               // in scope 2 at $SRC_DIR/core/src/ops/arith.rs:LL:COL\n+          let mut _4: (u8, bool);          // in scope 2 at $SRC_DIR/core/src/ops/arith.rs:LL:COL\n       }\n   \n       bb0: {\n           StorageLive(_1);                 // scope 0 at $DIR/inherit_overflow.rs:+3:13: +3:47\n-          _1 = const u8::MAX;              // scope 0 at $DIR/inherit_overflow.rs:+3:13: +3:47\n           StorageLive(_2);                 // scope 0 at $DIR/inherit_overflow.rs:+3:13: +3:47\n-          _2 = const 1_u8;                 // scope 0 at $DIR/inherit_overflow.rs:+3:13: +3:47\n-          _3 = CheckedAdd(const u8::MAX, const 1_u8); // scope 2 at $SRC_DIR/core/src/ops/arith.rs:LL:COL\n-          assert(!move (_3.1: bool), \"attempt to compute `{} + {}`, which would overflow\", const u8::MAX, const 1_u8) -> bb1; // scope 2 at $SRC_DIR/core/src/ops/arith.rs:LL:COL\n+          _2 = const u8::MAX;              // scope 0 at $DIR/inherit_overflow.rs:+3:13: +3:47\n+          StorageLive(_3);                 // scope 0 at $DIR/inherit_overflow.rs:+3:13: +3:47\n+          _3 = const 1_u8;                 // scope 0 at $DIR/inherit_overflow.rs:+3:13: +3:47\n+-         _4 = CheckedAdd(_2, _3);         // scope 2 at $SRC_DIR/core/src/ops/arith.rs:LL:COL\n+-         assert(!move (_4.1: bool), \"attempt to compute `{} + {}`, which would overflow\", _2, _3) -> bb1; // scope 2 at $SRC_DIR/core/src/ops/arith.rs:LL:COL\n++         _4 = CheckedAdd(const u8::MAX, const 1_u8); // scope 2 at $SRC_DIR/core/src/ops/arith.rs:LL:COL\n++         assert(!const true, \"attempt to compute `{} + {}`, which would overflow\", const u8::MAX, const 1_u8) -> bb1; // scope 2 at $SRC_DIR/core/src/ops/arith.rs:LL:COL\n       }\n   \n       bb1: {\n+-         _1 = move (_4.0: u8);            // scope 2 at $SRC_DIR/core/src/ops/arith.rs:LL:COL\n++         _1 = const 0_u8;                 // scope 2 at $SRC_DIR/core/src/ops/arith.rs:LL:COL\n+          StorageDead(_3);                 // scope 0 at $DIR/inherit_overflow.rs:+3:13: +3:47\n           StorageDead(_2);                 // scope 0 at $DIR/inherit_overflow.rs:+3:13: +3:47\n-          StorageDead(_1);                 // scope 0 at $DIR/inherit_overflow.rs:+3:13: +3:47\n+          StorageDead(_1);                 // scope 0 at $DIR/inherit_overflow.rs:+3:47: +3:48\n+          _0 = const ();                   // scope 0 at $DIR/inherit_overflow.rs:+0:11: +4:2\n           return;                          // scope 0 at $DIR/inherit_overflow.rs:+4:2: +4:2\n       }\n   }"}, {"sha": "f4aba60f0c801666dc9a4b0031d85d781cd63111", "filename": "tests/mir-opt/dataflow-const-prop/inherit_overflow.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/e34caaf42dd10b3cb8d14e6e99c2c8687fe6342e/tests%2Fmir-opt%2Fdataflow-const-prop%2Finherit_overflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e34caaf42dd10b3cb8d14e6e99c2c8687fe6342e/tests%2Fmir-opt%2Fdataflow-const-prop%2Finherit_overflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fmir-opt%2Fdataflow-const-prop%2Finherit_overflow.rs?ref=e34caaf42dd10b3cb8d14e6e99c2c8687fe6342e", "patch": "@@ -1,8 +1,9 @@\n-// compile-flags: -Zunsound-mir-opts\n+// unit-test: DataflowConstProp\n+// compile-flags: -Zmir-enable-passes=+Inline\n \n // EMIT_MIR inherit_overflow.main.DataflowConstProp.diff\n fn main() {\n-    // After inlining, this will contain a `CheckedBinaryOp`. The overflow\n-    // must be ignored by the constant propagation to avoid triggering a panic.\n+    // After inlining, this will contain a `CheckedBinaryOp`.\n+    // Propagating the overflow is ok as codegen will just skip emitting the panic.\n     let _ = <u8 as std::ops::Add>::add(255, 1);\n }"}]}