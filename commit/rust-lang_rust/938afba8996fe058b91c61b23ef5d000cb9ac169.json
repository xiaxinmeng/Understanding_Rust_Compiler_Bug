{"sha": "938afba8996fe058b91c61b23ef5d000cb9ac169", "node_id": "C_kwDOAAsO6NoAKDkzOGFmYmE4OTk2ZmUwNThiOTFjNjFiMjNlZjVkMDAwY2I5YWMxNjk", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-03-12T17:03:44Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-03-12T17:03:44Z"}, "message": "Auto merge of #108845 - Zoxc:par-fix-2, r=cjgillot\n\nCheck that a query has not completed and is not executing before starting it\n\nThis fixes a race in the query system where we only checked if the query was currently executing, but not if it was already completed, causing queries to re-execute.\n\nr? `@cjgillot`", "tree": {"sha": "4997a8f66428c96eb69f135be696f2a4aafdb8b9", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4997a8f66428c96eb69f135be696f2a4aafdb8b9"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/938afba8996fe058b91c61b23ef5d000cb9ac169", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/938afba8996fe058b91c61b23ef5d000cb9ac169", "html_url": "https://github.com/rust-lang/rust/commit/938afba8996fe058b91c61b23ef5d000cb9ac169", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/938afba8996fe058b91c61b23ef5d000cb9ac169/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f41927f30943e4d57af62cfcedc9f07b819013e7", "url": "https://api.github.com/repos/rust-lang/rust/commits/f41927f30943e4d57af62cfcedc9f07b819013e7", "html_url": "https://github.com/rust-lang/rust/commit/f41927f30943e4d57af62cfcedc9f07b819013e7"}, {"sha": "955549955f0143191de9c68ea4bee01823ebebf7", "url": "https://api.github.com/repos/rust-lang/rust/commits/955549955f0143191de9c68ea4bee01823ebebf7", "html_url": "https://github.com/rust-lang/rust/commit/955549955f0143191de9c68ea4bee01823ebebf7"}], "stats": {"total": 27, "additions": 21, "deletions": 6}, "files": [{"sha": "005512cf53e25843f788635dfd97dfe87d00d0f1", "filename": "compiler/rustc_query_system/src/query/plumbing.rs", "status": "modified", "additions": 21, "deletions": 6, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/938afba8996fe058b91c61b23ef5d000cb9ac169/compiler%2Frustc_query_system%2Fsrc%2Fquery%2Fplumbing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/938afba8996fe058b91c61b23ef5d000cb9ac169/compiler%2Frustc_query_system%2Fsrc%2Fquery%2Fplumbing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_query_system%2Fsrc%2Fquery%2Fplumbing.rs?ref=938afba8996fe058b91c61b23ef5d000cb9ac169", "patch": "@@ -17,7 +17,7 @@ use rustc_data_structures::profiling::TimingGuard;\n #[cfg(parallel_compiler)]\n use rustc_data_structures::sharded::Sharded;\n use rustc_data_structures::stack::ensure_sufficient_stack;\n-use rustc_data_structures::sync::Lock;\n+use rustc_data_structures::sync::{Lock, LockGuard};\n use rustc_errors::{DiagnosticBuilder, ErrorGuaranteed, FatalError};\n use rustc_session::Session;\n use rustc_span::{Span, DUMMY_SP};\n@@ -178,16 +178,13 @@ where\n     fn try_start<'b, Qcx>(\n         qcx: &'b Qcx,\n         state: &'b QueryState<K, Qcx::DepKind>,\n+        mut state_lock: LockGuard<'b, FxHashMap<K, QueryResult<Qcx::DepKind>>>,\n         span: Span,\n         key: K,\n     ) -> TryGetJob<'b, K, D>\n     where\n         Qcx: QueryContext + HasDepContext<DepKind = D>,\n     {\n-        #[cfg(parallel_compiler)]\n-        let mut state_lock = state.active.get_shard_by_value(&key).lock();\n-        #[cfg(not(parallel_compiler))]\n-        let mut state_lock = state.active.lock();\n         let lock = &mut *state_lock;\n         let current_job_id = qcx.current_query_job();\n \n@@ -362,7 +359,25 @@ where\n     Qcx: QueryContext,\n {\n     let state = query.query_state(qcx);\n-    match JobOwner::<'_, Q::Key, Qcx::DepKind>::try_start(&qcx, state, span, key) {\n+    #[cfg(parallel_compiler)]\n+    let state_lock = state.active.get_shard_by_value(&key).lock();\n+    #[cfg(not(parallel_compiler))]\n+    let state_lock = state.active.lock();\n+\n+    // For the parallel compiler we need to check both the query cache and query state structures\n+    // while holding the state lock to ensure that 1) the query has not yet completed and 2) the\n+    // query is not still executing. Without checking the query cache here, we can end up\n+    // re-executing the query since `try_start` only checks that the query is not currently\n+    // executing, but another thread may have already completed the query and stores it result\n+    // in the query cache.\n+    if cfg!(parallel_compiler) && qcx.dep_context().sess().threads() > 1 {\n+        if let Some((value, index)) = query.query_cache(qcx).lookup(&key) {\n+            qcx.dep_context().profiler().query_cache_hit(index.into());\n+            return (value, Some(index));\n+        }\n+    }\n+\n+    match JobOwner::<'_, Q::Key, Qcx::DepKind>::try_start(&qcx, state, state_lock, span, key) {\n         TryGetJob::NotYetStarted(job) => {\n             let (result, dep_node_index) = execute_job(query, qcx, key.clone(), dep_node, job.id);\n             let cache = query.query_cache(qcx);"}]}