{"sha": "b8ead417a6c2c6befff26f05393a4c213bf4a66c", "node_id": "MDY6Q29tbWl0NzI0NzEyOmI4ZWFkNDE3YTZjMmM2YmVmZmYyNmYwNTM5M2E0YzIxM2JmNGE2NmM=", "commit": {"author": {"name": "Michael Woerister", "email": "michaelwoerister@posteo", "date": "2019-12-17T13:44:07Z"}, "committer": {"name": "Michael Woerister", "email": "michaelwoerister@posteo", "date": "2020-01-10T09:19:39Z"}, "message": "Initial support for recording query keys in self-profiling data.", "tree": {"sha": "3bf1b168fd1b00c1232d75e9f02a3ae0a39a091a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3bf1b168fd1b00c1232d75e9f02a3ae0a39a091a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b8ead417a6c2c6befff26f05393a4c213bf4a66c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b8ead417a6c2c6befff26f05393a4c213bf4a66c", "html_url": "https://github.com/rust-lang/rust/commit/b8ead417a6c2c6befff26f05393a4c213bf4a66c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b8ead417a6c2c6befff26f05393a4c213bf4a66c/comments", "author": {"login": "michaelwoerister", "id": 1825894, "node_id": "MDQ6VXNlcjE4MjU4OTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1825894?v=4", "gravatar_id": "", "url": "https://api.github.com/users/michaelwoerister", "html_url": "https://github.com/michaelwoerister", "followers_url": "https://api.github.com/users/michaelwoerister/followers", "following_url": "https://api.github.com/users/michaelwoerister/following{/other_user}", "gists_url": "https://api.github.com/users/michaelwoerister/gists{/gist_id}", "starred_url": "https://api.github.com/users/michaelwoerister/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/michaelwoerister/subscriptions", "organizations_url": "https://api.github.com/users/michaelwoerister/orgs", "repos_url": "https://api.github.com/users/michaelwoerister/repos", "events_url": "https://api.github.com/users/michaelwoerister/events{/privacy}", "received_events_url": "https://api.github.com/users/michaelwoerister/received_events", "type": "User", "site_admin": false}, "committer": {"login": "michaelwoerister", "id": 1825894, "node_id": "MDQ6VXNlcjE4MjU4OTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1825894?v=4", "gravatar_id": "", "url": "https://api.github.com/users/michaelwoerister", "html_url": "https://github.com/michaelwoerister", "followers_url": "https://api.github.com/users/michaelwoerister/followers", "following_url": "https://api.github.com/users/michaelwoerister/following{/other_user}", "gists_url": "https://api.github.com/users/michaelwoerister/gists{/gist_id}", "starred_url": "https://api.github.com/users/michaelwoerister/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/michaelwoerister/subscriptions", "organizations_url": "https://api.github.com/users/michaelwoerister/orgs", "repos_url": "https://api.github.com/users/michaelwoerister/repos", "events_url": "https://api.github.com/users/michaelwoerister/events{/privacy}", "received_events_url": "https://api.github.com/users/michaelwoerister/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "996511a45655e452ec3132094e08dcbebee36a67", "url": "https://api.github.com/repos/rust-lang/rust/commits/996511a45655e452ec3132094e08dcbebee36a67", "html_url": "https://github.com/rust-lang/rust/commit/996511a45655e452ec3132094e08dcbebee36a67"}], "stats": {"total": 406, "additions": 354, "deletions": 52}, "files": [{"sha": "71c4faae9bf772370881dc1ba2b7574f9374e7ca", "filename": "Cargo.lock", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b8ead417a6c2c6befff26f05393a4c213bf4a66c/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/b8ead417a6c2c6befff26f05393a4c213bf4a66c/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=b8ead417a6c2c6befff26f05393a4c213bf4a66c", "patch": "@@ -1995,9 +1995,9 @@ dependencies = [\n \n [[package]]\n name = \"measureme\"\n-version = \"0.6.0\"\n+version = \"0.7.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"36dcc09c1a633097649f7d48bde3d8a61d2a43c01ce75525e31fbbc82c0fccf4\"\n+checksum = \"ebefdcb02b2ddeee50178a218aeaf6d752d0777cd07914542f202cb7440e6e38\"\n dependencies = [\n  \"byteorder\",\n  \"memmap\","}, {"sha": "b9207cd36ff38366a53843475221a40ed77361e8", "filename": "src/librustc/Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b8ead417a6c2c6befff26f05393a4c213bf4a66c/src%2Flibrustc%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/b8ead417a6c2c6befff26f05393a4c213bf4a66c/src%2Flibrustc%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2FCargo.toml?ref=b8ead417a6c2c6befff26f05393a4c213bf4a66c", "patch": "@@ -36,6 +36,6 @@ parking_lot = \"0.9\"\n byteorder = { version = \"1.3\" }\n chalk-engine = { version = \"0.9.0\", default-features=false }\n smallvec = { version = \"1.0\", features = [\"union\", \"may_dangle\"] }\n-measureme = \"0.6.0\"\n+measureme = \"0.7.0\"\n rustc_error_codes = { path = \"../librustc_error_codes\" }\n rustc_session = { path = \"../librustc_session\" }"}, {"sha": "f41653e9eaae00885b3aad8b2a65736fdc7c5274", "filename": "src/librustc/dep_graph/graph.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b8ead417a6c2c6befff26f05393a4c213bf4a66c/src%2Flibrustc%2Fdep_graph%2Fgraph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8ead417a6c2c6befff26f05393a4c213bf4a66c/src%2Flibrustc%2Fdep_graph%2Fgraph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdep_graph%2Fgraph.rs?ref=b8ead417a6c2c6befff26f05393a4c213bf4a66c", "patch": "@@ -30,7 +30,7 @@ pub struct DepGraph {\n \n     /// This field is used for assigning DepNodeIndices when running in\n     /// non-incremental mode. Even in non-incremental mode we make sure that\n-    /// each task as a `DepNodeIndex` that uniquely identifies it. This unique\n+    /// each task has a `DepNodeIndex` that uniquely identifies it. This unique\n     /// ID is used for self-profiling.\n     virtual_dep_node_index: Lrc<AtomicU32>,\n }"}, {"sha": "6b272ab3d4a9bfd1a7feaad08d3a0252e6a7f5e3", "filename": "src/librustc/ty/query/mod.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/b8ead417a6c2c6befff26f05393a4c213bf4a66c/src%2Flibrustc%2Fty%2Fquery%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8ead417a6c2c6befff26f05393a4c213bf4a66c/src%2Flibrustc%2Fty%2Fquery%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fquery%2Fmod.rs?ref=b8ead417a6c2c6befff26f05393a4c213bf4a66c", "patch": "@@ -81,6 +81,9 @@ pub(crate) use self::config::QueryDescription;\n mod on_disk_cache;\n pub use self::on_disk_cache::OnDiskCache;\n \n+mod profiling_support;\n+pub use self::profiling_support::{IntoSelfProfilingString, QueryKeyStringBuilder};\n+\n // Each of these queries corresponds to a function pointer field in the\n // `Providers` struct for requesting a value of that type, and a method\n // on `tcx: TyCtxt` (and `tcx.at(span)`) for doing that request in a way"}, {"sha": "76425f589f70a2215527a015c149e009ae73ca31", "filename": "src/librustc/ty/query/plumbing.rs", "status": "modified", "additions": 29, "deletions": 36, "changes": 65, "blob_url": "https://github.com/rust-lang/rust/blob/b8ead417a6c2c6befff26f05393a4c213bf4a66c/src%2Flibrustc%2Fty%2Fquery%2Fplumbing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8ead417a6c2c6befff26f05393a4c213bf4a66c/src%2Flibrustc%2Fty%2Fquery%2Fplumbing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fquery%2Fplumbing.rs?ref=b8ead417a6c2c6befff26f05393a4c213bf4a66c", "patch": "@@ -701,42 +701,6 @@ macro_rules! define_queries_inner {\n                 }\n             }\n \n-            /// All self-profiling events generated by the query engine use a\n-            /// virtual `StringId`s for their `event_id`. This method makes all\n-            /// those virtual `StringId`s point to actual strings.\n-            ///\n-            /// If we are recording only summary data, the ids will point to\n-            /// just the query names. If we are recording query keys too, we\n-            /// allocate the corresponding strings here. (The latter is not yet\n-            /// implemented.)\n-            pub fn allocate_self_profile_query_strings(\n-                &self,\n-                profiler: &rustc_data_structures::profiling::SelfProfiler\n-            ) {\n-                // Walk the entire query cache and allocate the appropriate\n-                // string representation. Each cache entry is uniquely\n-                // identified by its dep_node_index.\n-                $({\n-                    let query_name_string_id =\n-                        profiler.get_or_alloc_cached_string(stringify!($name));\n-\n-                    let result_cache = self.$name.lock_shards();\n-\n-                    for shard in result_cache.iter() {\n-                        let query_invocation_ids = shard\n-                            .results\n-                            .values()\n-                            .map(|v| v.index)\n-                            .map(|dep_node_index| dep_node_index.into());\n-\n-                        profiler.bulk_map_query_invocation_id_to_single_string(\n-                            query_invocation_ids,\n-                            query_name_string_id\n-                        );\n-                    }\n-                })*\n-            }\n-\n             #[cfg(parallel_compiler)]\n             pub fn collect_active_jobs(&self) -> Vec<Lrc<QueryJob<$tcx>>> {\n                 let mut jobs = Vec::new();\n@@ -1040,6 +1004,35 @@ macro_rules! define_queries_inner {\n             pub fn $name(self, key: $K) -> $V {\n                 self.at(DUMMY_SP).$name(key)\n             })*\n+\n+            /// All self-profiling events generated by the query engine use\n+            /// virtual `StringId`s for their `event_id`. This method makes all\n+            /// those virtual `StringId`s point to actual strings.\n+            ///\n+            /// If we are recording only summary data, the ids will point to\n+            /// just the query names. If we are recording query keys too, we\n+            /// allocate the corresponding strings here.\n+            pub fn alloc_self_profile_query_strings(self) {\n+                use crate::ty::query::profiling_support::{\n+                    alloc_self_profile_query_strings_for_query_cache,\n+                    QueryKeyStringCache,\n+                };\n+\n+                if !self.prof.enabled() {\n+                    return;\n+                }\n+\n+                let mut string_cache = QueryKeyStringCache::new();\n+\n+                $({\n+                    alloc_self_profile_query_strings_for_query_cache(\n+                        self,\n+                        stringify!($name),\n+                        &self.queries.$name,\n+                        &mut string_cache,\n+                    );\n+                })*\n+            }\n         }\n \n         impl TyCtxtAt<$tcx> {"}, {"sha": "ef30bd63be01cbe79606ecfd3faf3366cdb9b78b", "filename": "src/librustc/ty/query/profiling_support.rs", "status": "added", "additions": 276, "deletions": 0, "changes": 276, "blob_url": "https://github.com/rust-lang/rust/blob/b8ead417a6c2c6befff26f05393a4c213bf4a66c/src%2Flibrustc%2Fty%2Fquery%2Fprofiling_support.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8ead417a6c2c6befff26f05393a4c213bf4a66c/src%2Flibrustc%2Fty%2Fquery%2Fprofiling_support.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fquery%2Fprofiling_support.rs?ref=b8ead417a6c2c6befff26f05393a4c213bf4a66c", "patch": "@@ -0,0 +1,276 @@\n+\n+use crate::hir::def_id::{CRATE_DEF_INDEX, CrateNum, DefId, DefIndex, LOCAL_CRATE};\n+use crate::hir::map::definitions::DefPathData;\n+use crate::ty::context::TyCtxt;\n+use crate::ty::query::config::QueryConfig;\n+use crate::ty::query::plumbing::QueryCache;\n+use measureme::{StringId, StringComponent};\n+use rustc_data_structures::fx::FxHashMap;\n+use rustc_data_structures::profiling::SelfProfiler;\n+use rustc_data_structures::sharded::Sharded;\n+use std::fmt::Debug;\n+use std::io::Write;\n+\n+pub struct QueryKeyStringCache {\n+    def_id_cache: FxHashMap<DefId, StringId>,\n+}\n+\n+impl QueryKeyStringCache {\n+    pub fn new() -> QueryKeyStringCache {\n+        QueryKeyStringCache {\n+            def_id_cache: Default::default(),\n+        }\n+    }\n+}\n+\n+pub struct QueryKeyStringBuilder<'p, 'c, 'tcx> {\n+    profiler: &'p SelfProfiler,\n+    tcx: TyCtxt<'tcx>,\n+    string_cache: &'c mut QueryKeyStringCache,\n+}\n+\n+impl<'p, 'c, 'tcx> QueryKeyStringBuilder<'p, 'c, 'tcx> {\n+\n+    pub fn new(\n+        profiler: &'p SelfProfiler,\n+        tcx: TyCtxt<'tcx>,\n+        string_cache: &'c mut QueryKeyStringCache,\n+    ) -> QueryKeyStringBuilder<'p, 'c, 'tcx> {\n+        QueryKeyStringBuilder {\n+            profiler,\n+            tcx,\n+            string_cache,\n+        }\n+    }\n+\n+    // The current implementation is rather crude. In the future it might be a\n+    // good idea to base this on `ty::print` in order to get nicer and more\n+    // efficient query keys.\n+    fn def_id_to_string_id(&mut self, def_id: DefId) -> StringId {\n+\n+        if let Some(&string_id) = self.string_cache.def_id_cache.get(&def_id) {\n+            return string_id;\n+        }\n+\n+        let def_key = self.tcx.def_key(def_id);\n+\n+        let (parent_string_id, start_index) = match def_key.parent {\n+            Some(parent_index) => {\n+                let parent_def_id = DefId {\n+                    index: parent_index,\n+                    krate: def_id.krate,\n+                };\n+\n+                (self.def_id_to_string_id(parent_def_id), 0)\n+            }\n+            None => {\n+                (StringId::INVALID, 2)\n+            }\n+        };\n+\n+        let dis_buffer = &mut [0u8; 16];\n+        let name;\n+        let dis;\n+        let end_index;\n+\n+        match def_key.disambiguated_data.data {\n+            DefPathData::CrateRoot => {\n+                name = self.tcx.original_crate_name(def_id.krate).as_str();\n+                dis = \"\";\n+                end_index = 3;\n+            }\n+            other => {\n+                name = other.as_symbol().as_str();\n+                if def_key.disambiguated_data.disambiguator == 0 {\n+                    dis = \"\";\n+                    end_index = 3;\n+                } else {\n+                    write!(&mut dis_buffer[..],\n+                           \"[{}]\",\n+                           def_key.disambiguated_data.disambiguator\n+                    ).unwrap();\n+                    let end_of_dis = dis_buffer.iter().position(|&c| c == b']').unwrap();\n+                    dis = std::str::from_utf8(&dis_buffer[.. end_of_dis + 1]).unwrap();\n+                    end_index = 4;\n+                }\n+            }\n+        }\n+\n+        let components = [\n+            StringComponent::Ref(parent_string_id),\n+            StringComponent::Value(\"::\"),\n+            StringComponent::Value(&name[..]),\n+            StringComponent::Value(dis)\n+        ];\n+\n+        let string_id = self.profiler.alloc_string(\n+            &components[start_index .. end_index]\n+        );\n+\n+        self.string_cache.def_id_cache.insert(def_id, string_id);\n+\n+        string_id\n+    }\n+}\n+\n+pub trait IntoSelfProfilingString {\n+    fn to_self_profile_string(\n+        &self,\n+        builder: &mut QueryKeyStringBuilder<'_, '_, '_>\n+    ) -> StringId;\n+}\n+\n+// The default implementation of `IntoSelfProfilingString` just uses `Debug`\n+// which is slow and causes lots of duplication of string data.\n+// The specialized impls below take care of making the `DefId` case more\n+// efficient.\n+impl<T: Debug> IntoSelfProfilingString for T {\n+\n+    default fn to_self_profile_string(\n+        &self,\n+        builder: &mut QueryKeyStringBuilder<'_, '_, '_>\n+    ) -> StringId {\n+        let s = format!(\"{:?}\", self);\n+        builder.profiler.alloc_string(&s[..])\n+    }\n+}\n+\n+impl IntoSelfProfilingString for DefId {\n+\n+    fn to_self_profile_string(\n+        &self,\n+        builder: &mut QueryKeyStringBuilder<'_, '_, '_>\n+    ) -> StringId {\n+        builder.def_id_to_string_id(*self)\n+    }\n+}\n+\n+impl IntoSelfProfilingString for CrateNum {\n+\n+    fn to_self_profile_string(\n+        &self,\n+        builder: &mut QueryKeyStringBuilder<'_, '_, '_>\n+    ) -> StringId {\n+        builder.def_id_to_string_id(DefId {\n+            krate: *self,\n+            index: CRATE_DEF_INDEX,\n+        })\n+    }\n+}\n+\n+impl IntoSelfProfilingString for DefIndex {\n+\n+    fn to_self_profile_string(\n+        &self,\n+        builder: &mut QueryKeyStringBuilder<'_, '_, '_>\n+    ) -> StringId {\n+        builder.def_id_to_string_id(DefId {\n+            krate: LOCAL_CRATE,\n+            index: *self,\n+        })\n+    }\n+}\n+\n+impl<T0, T1> IntoSelfProfilingString for (T0, T1)\n+    where T0: IntoSelfProfilingString+Debug,\n+          T1: IntoSelfProfilingString+Debug,\n+{\n+    default fn to_self_profile_string(\n+        &self,\n+        builder: &mut QueryKeyStringBuilder<'_, '_, '_>\n+    ) -> StringId {\n+\n+        let val0 = self.0.to_self_profile_string(builder);\n+        let val1 = self.1.to_self_profile_string(builder);\n+\n+        let components = &[\n+            StringComponent::Value(\"(\"),\n+            StringComponent::Ref(val0),\n+            StringComponent::Value(\",\"),\n+            StringComponent::Ref(val1),\n+            StringComponent::Value(\")\"),\n+        ];\n+\n+        builder.profiler.alloc_string(components)\n+    }\n+}\n+\n+/// Allocate the self-profiling query strings for a single query cache. This\n+/// method is called from `alloc_self_profile_query_strings` which knows all\n+/// the queries via macro magic.\n+pub(super) fn alloc_self_profile_query_strings_for_query_cache<'tcx, Q>(\n+    tcx: TyCtxt<'tcx>,\n+    query_name: &'static str,\n+    query_cache: &Sharded<QueryCache<'tcx, Q>>,\n+    string_cache: &mut QueryKeyStringCache,\n+) where Q: QueryConfig<'tcx> {\n+    tcx.prof.with_profiler(|profiler| {\n+        let event_id_builder = profiler.event_id_builder();\n+\n+        // Walk the entire query cache and allocate the appropriate\n+        // string representations. Each cache entry is uniquely\n+        // identified by its dep_node_index.\n+        if profiler.query_key_recording_enabled() {\n+            let mut query_string_builder =\n+                QueryKeyStringBuilder::new(profiler, tcx, string_cache);\n+\n+            let query_name = profiler.get_or_alloc_cached_string(query_name);\n+\n+            // Since building the string representation of query keys might\n+            // need to invoke queries itself, we cannot keep the query caches\n+            // locked while doing so. Instead we copy out the\n+            // `(query_key, dep_node_index)` pairs and release the lock again.\n+            let query_keys_and_indices = {\n+                let shards = query_cache.lock_shards();\n+                let len = shards.iter().map(|shard| shard.results.len()).sum();\n+\n+                let mut query_keys_and_indices = Vec::with_capacity(len);\n+\n+                for shard in &shards {\n+                    query_keys_and_indices.extend(shard.results.iter().map(|(q_key, q_val)| {\n+                        (q_key.clone(), q_val.index)\n+                    }));\n+                }\n+\n+                query_keys_and_indices\n+            };\n+\n+            // Now actually allocate the strings. If allocating the strings\n+            // generates new entries in the query cache, we'll miss them but\n+            // we don't actually care.\n+            for (query_key, dep_node_index) in query_keys_and_indices {\n+                // Translate the DepNodeIndex into a QueryInvocationId\n+                let query_invocation_id = dep_node_index.into();\n+\n+                // Create the string version of the query-key\n+                let query_key = query_key.to_self_profile_string(&mut query_string_builder);\n+                let event_id = event_id_builder.from_label_and_arg(query_name, query_key);\n+\n+                // Doing this in bulk might be a good idea:\n+                profiler.map_query_invocation_id_to_string(\n+                    query_invocation_id,\n+                    event_id.to_string_id(),\n+                );\n+            }\n+        } else {\n+            // In this branch we don't allocate query keys\n+            let query_name = profiler.get_or_alloc_cached_string(query_name);\n+            let event_id = event_id_builder.from_label(query_name).to_string_id();\n+\n+            let shards = query_cache.lock_shards();\n+\n+            for shard in shards.iter() {\n+                let query_invocation_ids = shard\n+                    .results\n+                    .values()\n+                    .map(|v| v.index)\n+                    .map(|dep_node_index| dep_node_index.into());\n+\n+                profiler.bulk_map_query_invocation_id_to_single_string(\n+                    query_invocation_ids,\n+                    event_id,\n+                );\n+            }\n+        }\n+    });\n+}"}, {"sha": "857aa9c1bcc2e7f09406a4b3c89c0e9273322706", "filename": "src/librustc_codegen_ssa/base.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b8ead417a6c2c6befff26f05393a4c213bf4a66c/src%2Flibrustc_codegen_ssa%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8ead417a6c2c6befff26f05393a4c213bf4a66c/src%2Flibrustc_codegen_ssa%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fbase.rs?ref=b8ead417a6c2c6befff26f05393a4c213bf4a66c", "patch": "@@ -722,10 +722,10 @@ fn finalize_tcx(tcx: TyCtxt<'_>) {\n \n     // We assume that no queries are run past here. If there are new queries\n     // after this point, they'll show up as \"<unknown>\" in self-profiling data.\n-    tcx.prof.with_profiler(|profiler| {\n+    {\n         let _prof_timer = tcx.prof.generic_activity(\"self_profile_alloc_query_strings\");\n-        tcx.queries.allocate_self_profile_query_strings(profiler);\n-    });\n+        tcx.alloc_self_profile_query_strings();\n+    }\n }\n \n impl CrateInfo {"}, {"sha": "d6ca11364ea96aa1af04ceab8b4ad49d47991cc7", "filename": "src/librustc_data_structures/Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b8ead417a6c2c6befff26f05393a4c213bf4a66c/src%2Flibrustc_data_structures%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/b8ead417a6c2c6befff26f05393a4c213bf4a66c/src%2Flibrustc_data_structures%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2FCargo.toml?ref=b8ead417a6c2c6befff26f05393a4c213bf4a66c", "patch": "@@ -26,7 +26,7 @@ rustc-hash = \"1.0.1\"\n smallvec = { version = \"1.0\", features = [\"union\", \"may_dangle\"] }\n rustc_index = { path = \"../librustc_index\", package = \"rustc_index\" }\n bitflags = \"1.2.1\"\n-measureme = \"0.6.0\"\n+measureme = \"0.7.0\"\n \n [dependencies.parking_lot]\n version = \"0.9\""}, {"sha": "066a6727bb49daf21e2930ed7a7979ef061e40c4", "filename": "src/librustc_data_structures/profiling.rs", "status": "modified", "additions": 38, "deletions": 8, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/b8ead417a6c2c6befff26f05393a4c213bf4a66c/src%2Flibrustc_data_structures%2Fprofiling.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8ead417a6c2c6befff26f05393a4c213bf4a66c/src%2Flibrustc_data_structures%2Fprofiling.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Fprofiling.rs?ref=b8ead417a6c2c6befff26f05393a4c213bf4a66c", "patch": "@@ -39,7 +39,7 @@\n //! ## `event_id` Assignment\n //!\n //! As far as `measureme` is concerned, `event_id`s are just strings. However,\n-//! it would incur way too much overhead to generate and persist each `event_id`\n+//! it would incur too much overhead to generate and persist each `event_id`\n //! string at the point where the event is recorded. In order to make this more\n //! efficient `measureme` has two features:\n //!\n@@ -56,7 +56,7 @@\n //!   ID be mapped to an actual string. This is used to cheaply generate\n //!   `event_id`s while the events actually occur, causing little timing\n //!   distortion, and then later map those `StringId`s, in bulk, to actual\n-//!   `event_id` strings. This way the largest part of tracing overhead is\n+//!   `event_id` strings. This way the largest part of the tracing overhead is\n //!   localized to one contiguous chunk of time.\n //!\n //! How are these `event_id`s generated in the compiler? For things that occur\n@@ -92,7 +92,7 @@ use std::thread::ThreadId;\n use std::time::{Duration, Instant};\n use std::u32;\n \n-use measureme::StringId;\n+use measureme::{EventId, EventIdBuilder, SerializableString, StringId};\n use parking_lot::RwLock;\n \n /// MmapSerializatioSink is faster on macOS and Linux\n@@ -123,6 +123,8 @@ bitflags::bitflags! {\n         const QUERY_BLOCKED      = 1 << 3;\n         const INCR_CACHE_LOADS   = 1 << 4;\n \n+        const QUERY_KEYS         = 1 << 5;\n+\n         const DEFAULT = Self::GENERIC_ACTIVITIES.bits |\n                         Self::QUERY_PROVIDERS.bits |\n                         Self::QUERY_BLOCKED.bits |\n@@ -142,6 +144,7 @@ const EVENT_FILTERS_BY_NAME: &[(&str, EventFilter)] = &[\n     (\"query-cache-hit\", EventFilter::QUERY_CACHE_HITS),\n     (\"query-blocked\", EventFilter::QUERY_BLOCKED),\n     (\"incr-cache-load\", EventFilter::INCR_CACHE_LOADS),\n+    (\"query-keys\", EventFilter::QUERY_KEYS),\n ];\n \n fn thread_id_to_u32(tid: ThreadId) -> u32 {\n@@ -253,6 +256,7 @@ impl SelfProfilerRef {\n     pub fn generic_activity(&self, event_id: &'static str) -> TimingGuard<'_> {\n         self.exec(EventFilter::GENERIC_ACTIVITIES, |profiler| {\n             let event_id = profiler.get_or_alloc_cached_string(event_id);\n+            let event_id = EventId::from_label(event_id);\n             TimingGuard::start(\n                 profiler,\n                 profiler.generic_activity_event_kind,\n@@ -266,7 +270,7 @@ impl SelfProfilerRef {\n     #[inline(always)]\n     pub fn query_provider(&self) -> TimingGuard<'_> {\n         self.exec(EventFilter::QUERY_PROVIDERS, |profiler| {\n-            TimingGuard::start(profiler, profiler.query_event_kind, StringId::INVALID)\n+            TimingGuard::start(profiler, profiler.query_event_kind, EventId::INVALID)\n         })\n     }\n \n@@ -289,7 +293,7 @@ impl SelfProfilerRef {\n             TimingGuard::start(\n                 profiler,\n                 profiler.query_blocked_event_kind,\n-                StringId::INVALID,\n+                EventId::INVALID,\n             )\n         })\n     }\n@@ -303,7 +307,7 @@ impl SelfProfilerRef {\n             TimingGuard::start(\n                 profiler,\n                 profiler.incremental_load_result_event_kind,\n-                StringId::INVALID,\n+                EventId::INVALID,\n             )\n         })\n     }\n@@ -319,7 +323,11 @@ impl SelfProfilerRef {\n             let event_id = StringId::new_virtual(query_invocation_id.0);\n             let thread_id = thread_id_to_u32(std::thread::current().id());\n \n-            profiler.profiler.record_instant_event(event_kind(profiler), event_id, thread_id);\n+            profiler.profiler.record_instant_event(\n+                event_kind(profiler),\n+                EventId::from_virtual(event_id),\n+                thread_id,\n+            );\n \n             TimingGuard::none()\n         }));\n@@ -330,6 +338,10 @@ impl SelfProfilerRef {\n             f(&profiler)\n         }\n     }\n+\n+    pub fn enabled(&self) -> bool {\n+        self.profiler.is_some()\n+    }\n }\n \n pub struct SelfProfiler {\n@@ -409,6 +421,15 @@ impl SelfProfiler {\n         })\n     }\n \n+    /// Allocates a new string in the profiling data. Does not do any caching\n+    /// or deduplication.\n+    pub fn alloc_string<STR: SerializableString + ?Sized>(&self, s: &STR) -> StringId {\n+        self.profiler.alloc_string(s)\n+    }\n+\n+    /// Gets a `StringId` for the given string. This method makes sure that\n+    /// any strings going through it will only be allocated once in the\n+    /// profiling data.\n     pub fn get_or_alloc_cached_string(&self, s: &'static str) -> StringId {\n         // Only acquire a read-lock first since we assume that the string is\n         // already present in the common case.\n@@ -445,6 +466,14 @@ impl SelfProfiler {\n         let from = from.map(|qid| StringId::new_virtual(qid.0));\n         self.profiler.bulk_map_virtual_to_single_concrete_string(from, to);\n     }\n+\n+    pub fn query_key_recording_enabled(&self) -> bool {\n+        self.event_filter_mask.contains(EventFilter::QUERY_KEYS)\n+    }\n+\n+    pub fn event_id_builder(&self) -> EventIdBuilder<'_, SerializationSink> {\n+        EventIdBuilder::new(&self.profiler)\n+    }\n }\n \n #[must_use]\n@@ -455,7 +484,7 @@ impl<'a> TimingGuard<'a> {\n     pub fn start(\n         profiler: &'a SelfProfiler,\n         event_kind: StringId,\n-        event_id: StringId,\n+        event_id: EventId,\n     ) -> TimingGuard<'a> {\n         let thread_id = thread_id_to_u32(std::thread::current().id());\n         let raw_profiler = &profiler.profiler;\n@@ -468,6 +497,7 @@ impl<'a> TimingGuard<'a> {\n     pub fn finish_with_query_invocation_id(self, query_invocation_id: QueryInvocationId) {\n         if let Some(guard) = self.0 {\n             let event_id = StringId::new_virtual(query_invocation_id.0);\n+            let event_id = EventId::from_virtual(event_id);\n             guard.finish_with_override_event_id(event_id);\n         }\n     }"}]}