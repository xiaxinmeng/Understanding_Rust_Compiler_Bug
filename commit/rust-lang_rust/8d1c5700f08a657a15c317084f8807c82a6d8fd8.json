{"sha": "8d1c5700f08a657a15c317084f8807c82a6d8fd8", "node_id": "MDY6Q29tbWl0NzI0NzEyOjhkMWM1NzAwZjA4YTY1N2ExNWMzMTcwODRmODgwN2M4MmE2ZDhmZDg=", "commit": {"author": {"name": "Corey Farwell", "email": "coreyf@rwell.org", "date": "2017-03-12T16:48:46Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2017-03-12T16:48:46Z"}, "message": "Rollup merge of #40369 - petrochenkov:segspan, r=eddyb\n\nGive spans to individual path segments in AST\n\nAnd use these spans in path resolution diagnostics.\n\nThe spans are spans of identifiers in segments, not whole segments. I'm not sure what spans are more useful in general, but identifier spans are a better fit for resolve errors.\n\nHIR still doesn't have spans.\n\nFixes https://github.com/rust-lang/rust/pull/38927#discussion_r95336667 https://github.com/rust-lang/rust/pull/38890#issuecomment-271731008\n\nr? @nrc @eddyb", "tree": {"sha": "abdbc4d3f992133c106c1ad7dbc13f5d44f9c44a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/abdbc4d3f992133c106c1ad7dbc13f5d44f9c44a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8d1c5700f08a657a15c317084f8807c82a6d8fd8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8d1c5700f08a657a15c317084f8807c82a6d8fd8", "html_url": "https://github.com/rust-lang/rust/commit/8d1c5700f08a657a15c317084f8807c82a6d8fd8", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8d1c5700f08a657a15c317084f8807c82a6d8fd8/comments", "author": {"login": "frewsxcv", "id": 416575, "node_id": "MDQ6VXNlcjQxNjU3NQ==", "avatar_url": "https://avatars.githubusercontent.com/u/416575?v=4", "gravatar_id": "", "url": "https://api.github.com/users/frewsxcv", "html_url": "https://github.com/frewsxcv", "followers_url": "https://api.github.com/users/frewsxcv/followers", "following_url": "https://api.github.com/users/frewsxcv/following{/other_user}", "gists_url": "https://api.github.com/users/frewsxcv/gists{/gist_id}", "starred_url": "https://api.github.com/users/frewsxcv/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/frewsxcv/subscriptions", "organizations_url": "https://api.github.com/users/frewsxcv/orgs", "repos_url": "https://api.github.com/users/frewsxcv/repos", "events_url": "https://api.github.com/users/frewsxcv/events{/privacy}", "received_events_url": "https://api.github.com/users/frewsxcv/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f88b24b34c6d17ebe4014bec5a0f7c2a57c529c7", "url": "https://api.github.com/repos/rust-lang/rust/commits/f88b24b34c6d17ebe4014bec5a0f7c2a57c529c7", "html_url": "https://github.com/rust-lang/rust/commit/f88b24b34c6d17ebe4014bec5a0f7c2a57c529c7"}, {"sha": "ffdcf7486656119328c3c6c1efef408abba3139f", "url": "https://api.github.com/repos/rust-lang/rust/commits/ffdcf7486656119328c3c6c1efef408abba3139f", "html_url": "https://github.com/rust-lang/rust/commit/ffdcf7486656119328c3c6c1efef408abba3139f"}], "stats": {"total": 212, "additions": 124, "deletions": 88}, "files": [{"sha": "104cc78597a4a501f89286355d633d99fc06fbfa", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 28, "deletions": 29, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/8d1c5700f08a657a15c317084f8807c82a6d8fd8/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8d1c5700f08a657a15c317084f8807c82a6d8fd8/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=8d1c5700f08a657a15c317084f8807c82a6d8fd8", "patch": "@@ -407,7 +407,7 @@ enum PathSource<'a> {\n     // Trait paths in bounds or impls.\n     Trait,\n     // Expression paths `path`, with optional parent context.\n-    Expr(Option<&'a ExprKind>),\n+    Expr(Option<&'a Expr>),\n     // Paths in path patterns `Path`.\n     Pat,\n     // Paths in struct expressions and patterns `Path { .. }`.\n@@ -464,7 +464,7 @@ impl<'a> PathSource<'a> {\n                 ValueNS => \"method or associated constant\",\n                 MacroNS => bug!(\"associated macro\"),\n             },\n-            PathSource::Expr(parent) => match parent {\n+            PathSource::Expr(parent) => match parent.map(|p| &p.node) {\n                 // \"function\" here means \"anything callable\" rather than `Def::Fn`,\n                 // this is not precise but usually more helpful than just \"value\".\n                 Some(&ExprKind::Call(..)) => \"function\",\n@@ -2200,14 +2200,16 @@ impl<'a> Resolver<'a> {\n                           source: PathSource)\n                           -> PathResolution {\n         let segments = &path.segments.iter().map(|seg| seg.identifier).collect::<Vec<_>>();\n-        self.smart_resolve_path_fragment(id, qself, segments, path.span, source)\n+        let ident_span = path.segments.last().map_or(path.span, |seg| seg.span);\n+        self.smart_resolve_path_fragment(id, qself, segments, path.span, ident_span, source)\n     }\n \n     fn smart_resolve_path_fragment(&mut self,\n                                    id: NodeId,\n                                    qself: Option<&QSelf>,\n                                    path: &[Ident],\n                                    span: Span,\n+                                   ident_span: Span,\n                                    source: PathSource)\n                                    -> PathResolution {\n         let ns = source.namespace();\n@@ -2219,9 +2221,9 @@ impl<'a> Resolver<'a> {\n             let expected = source.descr_expected();\n             let path_str = names_to_string(path);\n             let code = source.error_code(def.is_some());\n-            let (base_msg, fallback_label) = if let Some(def) = def {\n+            let (base_msg, fallback_label, base_span) = if let Some(def) = def {\n                 (format!(\"expected {}, found {} `{}`\", expected, def.kind_name(), path_str),\n-                 format!(\"not a {}\", expected))\n+                 format!(\"not a {}\", expected), span)\n             } else {\n                 let item_str = path[path.len() - 1];\n                 let (mod_prefix, mod_str) = if path.len() == 1 {\n@@ -2237,9 +2239,9 @@ impl<'a> Resolver<'a> {\n                     (mod_prefix, format!(\"`{}`\", names_to_string(mod_path)))\n                 };\n                 (format!(\"cannot find {} `{}` in {}{}\", expected, item_str, mod_prefix, mod_str),\n-                 format!(\"not found in {}\", mod_str))\n+                 format!(\"not found in {}\", mod_str), ident_span)\n             };\n-            let mut err = this.session.struct_span_err_with_code(span, &base_msg, code);\n+            let mut err = this.session.struct_span_err_with_code(base_span, &base_msg, code);\n \n             // Emit special messages for unresolved `Self` and `self`.\n             if is_self_type(path, ns) {\n@@ -2297,15 +2299,15 @@ impl<'a> Resolver<'a> {\n                         err.span_label(span, &format!(\"type aliases cannot be used for traits\"));\n                         return err;\n                     }\n-                    (Def::Mod(..), PathSource::Expr(Some(parent))) => match *parent {\n+                    (Def::Mod(..), PathSource::Expr(Some(parent))) => match parent.node {\n                         ExprKind::Field(_, ident) => {\n-                            err.span_label(span, &format!(\"did you mean `{}::{}`?\",\n-                                                           path_str, ident.node));\n+                            err.span_label(parent.span, &format!(\"did you mean `{}::{}`?\",\n+                                                                 path_str, ident.node));\n                             return err;\n                         }\n                         ExprKind::MethodCall(ident, ..) => {\n-                            err.span_label(span, &format!(\"did you mean `{}::{}(...)`?\",\n-                                                           path_str, ident.node));\n+                            err.span_label(parent.span, &format!(\"did you mean `{}::{}(...)`?\",\n+                                                                 path_str, ident.node));\n                             return err;\n                         }\n                         _ => {}\n@@ -2330,12 +2332,12 @@ impl<'a> Resolver<'a> {\n \n             // Try Levenshtein if nothing else worked.\n             if let Some(candidate) = this.lookup_typo_candidate(path, ns, is_expected) {\n-                err.span_label(span, &format!(\"did you mean `{}`?\", candidate));\n+                err.span_label(ident_span, &format!(\"did you mean `{}`?\", candidate));\n                 return err;\n             }\n \n             // Fallback label.\n-            err.span_label(span, &fallback_label);\n+            err.span_label(base_span, &fallback_label);\n             err\n         };\n         let report_errors = |this: &mut Self, def: Option<Def>| {\n@@ -2455,7 +2457,7 @@ impl<'a> Resolver<'a> {\n             // Make sure `A::B` in `<T as A>::B::C` is a trait item.\n             let ns = if qself.position + 1 == path.len() { ns } else { TypeNS };\n             let res = self.smart_resolve_path_fragment(id, None, &path[..qself.position + 1],\n-                                                       span, PathSource::TraitItem(ns));\n+                                                       span, span, PathSource::TraitItem(ns));\n             return Some(PathResolution::with_unresolved_segments(\n                 res.base_def(), res.unresolved_segments() + path.len() - qself.position - 1\n             ));\n@@ -2813,7 +2815,7 @@ impl<'a> Resolver<'a> {\n                                        path: &[Ident],\n                                        ns: Namespace,\n                                        filter_fn: FilterFn)\n-                                       -> Option<String>\n+                                       -> Option<Symbol>\n         where FilterFn: Fn(Def) -> bool\n     {\n         let add_module_candidates = |module: Module, names: &mut Vec<Name>| {\n@@ -2827,7 +2829,7 @@ impl<'a> Resolver<'a> {\n         };\n \n         let mut names = Vec::new();\n-        let prefix_str = if path.len() == 1 {\n+        if path.len() == 1 {\n             // Search in lexical scope.\n             // Walk backwards up the ribs in scope and collect candidates.\n             for rib in self.ribs[ns].iter().rev() {\n@@ -2861,21 +2863,19 @@ impl<'a> Resolver<'a> {\n                     names.push(*name);\n                 }\n             }\n-            String::new()\n         } else {\n             // Search in module.\n             let mod_path = &path[..path.len() - 1];\n             if let PathResult::Module(module) = self.resolve_path(mod_path, Some(TypeNS), None) {\n                 add_module_candidates(module, &mut names);\n             }\n-            names_to_string(mod_path) + \"::\"\n-        };\n+        }\n \n         let name = path[path.len() - 1].name;\n         // Make sure error reporting is deterministic.\n         names.sort_by_key(|name| name.as_str());\n         match find_best_match_for_name(names.iter(), &name.as_str(), None) {\n-            Some(found) if found != name => Some(format!(\"{}{}\", prefix_str, found)),\n+            Some(found) if found != name => Some(found),\n             _ => None,\n         }\n     }\n@@ -2898,7 +2898,7 @@ impl<'a> Resolver<'a> {\n         self.with_resolved_label(label, id, |this| this.visit_block(block));\n     }\n \n-    fn resolve_expr(&mut self, expr: &Expr, parent: Option<&ExprKind>) {\n+    fn resolve_expr(&mut self, expr: &Expr, parent: Option<&Expr>) {\n         // First, record candidate traits for this expression if it could\n         // result in the invocation of a method call.\n \n@@ -2979,11 +2979,11 @@ impl<'a> Resolver<'a> {\n \n             // Equivalent to `visit::walk_expr` + passing some context to children.\n             ExprKind::Field(ref subexpression, _) => {\n-                self.resolve_expr(subexpression, Some(&expr.node));\n+                self.resolve_expr(subexpression, Some(expr));\n             }\n             ExprKind::MethodCall(_, ref types, ref arguments) => {\n                 let mut arguments = arguments.iter();\n-                self.resolve_expr(arguments.next().unwrap(), Some(&expr.node));\n+                self.resolve_expr(arguments.next().unwrap(), Some(expr));\n                 for argument in arguments {\n                     self.resolve_expr(argument, None);\n                 }\n@@ -2999,7 +2999,7 @@ impl<'a> Resolver<'a> {\n                 });\n             }\n             ExprKind::Call(ref callee, ref arguments) => {\n-                self.resolve_expr(callee, Some(&expr.node));\n+                self.resolve_expr(callee, Some(expr));\n                 for argument in arguments {\n                     self.resolve_expr(argument, None);\n                 }\n@@ -3130,11 +3130,10 @@ impl<'a> Resolver<'a> {\n                 if ident.name == lookup_name && ns == namespace {\n                     if filter_fn(name_binding.def()) {\n                         // create the path\n-                        let span = name_binding.span;\n                         let mut segms = path_segments.clone();\n-                        segms.push(ident.into());\n+                        segms.push(ast::PathSegment::from_ident(ident, name_binding.span));\n                         let path = Path {\n-                            span: span,\n+                            span: name_binding.span,\n                             segments: segms,\n                         };\n                         // the entity is accessible in the following cases:\n@@ -3154,7 +3153,7 @@ impl<'a> Resolver<'a> {\n                 if let Some(module) = name_binding.module() {\n                     // form the path\n                     let mut path_segments = path_segments.clone();\n-                    path_segments.push(ident.into());\n+                    path_segments.push(ast::PathSegment::from_ident(ident, name_binding.span));\n \n                     if !in_module_is_extern || name_binding.vis == ty::Visibility::Public {\n                         // add the module to the lookup"}, {"sha": "dbdf3a0b21e691119a593de08a0e566ba1c0cd55", "filename": "src/librustc_resolve/macros.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/8d1c5700f08a657a15c317084f8807c82a6d8fd8/src%2Flibrustc_resolve%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8d1c5700f08a657a15c317084f8807c82a6d8fd8/src%2Flibrustc_resolve%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fmacros.rs?ref=8d1c5700f08a657a15c317084f8807c82a6d8fd8", "patch": "@@ -111,8 +111,11 @@ impl<'a> base::Resolver for Resolver<'a> {\n                     path.segments[0].identifier.name = keywords::CrateRoot.name();\n                     let module = self.0.resolve_crate_var(ident.ctxt);\n                     if !module.is_local() {\n+                        let span = path.segments[0].span;\n                         path.segments.insert(1, match module.kind {\n-                            ModuleKind::Def(_, name) => ast::Ident::with_empty_ctxt(name).into(),\n+                            ModuleKind::Def(_, name) => ast::PathSegment::from_ident(\n+                                ast::Ident::with_empty_ctxt(name), span\n+                            ),\n                             _ => unreachable!(),\n                         })\n                     }\n@@ -569,7 +572,6 @@ impl<'a> Resolver<'a> {\n             };\n             let ident = Ident::from_str(name);\n             self.lookup_typo_candidate(&vec![ident], MacroNS, is_macro)\n-                .as_ref().map(|s| Symbol::intern(s))\n         });\n \n         if let Some(suggestion) = suggestion {"}, {"sha": "fa320d2ca8b6ce52c4dc553c75cfc1900510ae00", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/8d1c5700f08a657a15c317084f8807c82a6d8fd8/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8d1c5700f08a657a15c317084f8807c82a6d8fd8/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=8d1c5700f08a657a15c317084f8807c82a6d8fd8", "patch": "@@ -134,7 +134,7 @@ impl Path {\n     pub fn from_ident(s: Span, identifier: Ident) -> Path {\n         Path {\n             span: s,\n-            segments: vec![identifier.into()],\n+            segments: vec![PathSegment::from_ident(identifier, s)],\n         }\n     }\n \n@@ -159,6 +159,8 @@ impl Path {\n pub struct PathSegment {\n     /// The identifier portion of this path segment.\n     pub identifier: Ident,\n+    /// Span of the segment identifier.\n+    pub span: Span,\n \n     /// Type/lifetime parameters attached to this path. They come in\n     /// two flavors: `Path<A,B,C>` and `Path(A,B) -> C`. Note that\n@@ -170,16 +172,14 @@ pub struct PathSegment {\n     pub parameters: Option<P<PathParameters>>,\n }\n \n-impl From<Ident> for PathSegment {\n-    fn from(id: Ident) -> Self {\n-        PathSegment { identifier: id, parameters: None }\n-    }\n-}\n-\n impl PathSegment {\n+    pub fn from_ident(ident: Ident, span: Span) -> Self {\n+        PathSegment { identifier: ident, span: span, parameters: None }\n+    }\n     pub fn crate_root() -> Self {\n         PathSegment {\n             identifier: keywords::CrateRoot.ident(),\n+            span: DUMMY_SP,\n             parameters: None,\n         }\n     }"}, {"sha": "e0fb46ff5eb095a01c659ab0a6e124c30f82c577", "filename": "src/libsyntax/ext/build.rs", "status": "modified", "additions": 12, "deletions": 7, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/8d1c5700f08a657a15c317084f8807c82a6d8fd8/src%2Flibsyntax%2Fext%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8d1c5700f08a657a15c317084f8807c82a6d8fd8/src%2Flibsyntax%2Fext%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbuild.rs?ref=8d1c5700f08a657a15c317084f8807c82a6d8fd8", "patch": "@@ -38,11 +38,11 @@ pub trait AstBuilder {\n \n     fn qpath(&self, self_type: P<ast::Ty>,\n              trait_path: ast::Path,\n-             ident: ast::Ident)\n+             ident: ast::SpannedIdent)\n              -> (ast::QSelf, ast::Path);\n     fn qpath_all(&self, self_type: P<ast::Ty>,\n                 trait_path: ast::Path,\n-                ident: ast::Ident,\n+                ident: ast::SpannedIdent,\n                 lifetimes: Vec<ast::Lifetime>,\n                 types: Vec<P<ast::Ty>>,\n                 bindings: Vec<ast::TypeBinding>)\n@@ -323,7 +323,7 @@ impl<'a> AstBuilder for ExtCtxt<'a> {\n             segments.push(ast::PathSegment::crate_root());\n         }\n \n-        segments.extend(idents.into_iter().map(Into::into));\n+        segments.extend(idents.into_iter().map(|i| ast::PathSegment::from_ident(i, sp)));\n         let parameters = if lifetimes.is_empty() && types.is_empty() && bindings.is_empty() {\n             None\n         } else {\n@@ -333,7 +333,11 @@ impl<'a> AstBuilder for ExtCtxt<'a> {\n                 bindings: bindings,\n             })))\n         };\n-        segments.push(ast::PathSegment { identifier: last_identifier, parameters: parameters });\n+        segments.push(ast::PathSegment {\n+            identifier: last_identifier,\n+            span: sp,\n+            parameters: parameters\n+        });\n         ast::Path {\n             span: sp,\n             segments: segments,\n@@ -346,7 +350,7 @@ impl<'a> AstBuilder for ExtCtxt<'a> {\n     fn qpath(&self,\n              self_type: P<ast::Ty>,\n              trait_path: ast::Path,\n-             ident: ast::Ident)\n+             ident: ast::SpannedIdent)\n              -> (ast::QSelf, ast::Path) {\n         self.qpath_all(self_type, trait_path, ident, vec![], vec![], vec![])\n     }\n@@ -357,7 +361,7 @@ impl<'a> AstBuilder for ExtCtxt<'a> {\n     fn qpath_all(&self,\n                  self_type: P<ast::Ty>,\n                  trait_path: ast::Path,\n-                 ident: ast::Ident,\n+                 ident: ast::SpannedIdent,\n                  lifetimes: Vec<ast::Lifetime>,\n                  types: Vec<P<ast::Ty>>,\n                  bindings: Vec<ast::TypeBinding>)\n@@ -369,7 +373,8 @@ impl<'a> AstBuilder for ExtCtxt<'a> {\n             bindings: bindings,\n         };\n         path.segments.push(ast::PathSegment {\n-            identifier: ident,\n+            identifier: ident.node,\n+            span: ident.span,\n             parameters: Some(P(ast::PathParameters::AngleBracketed(parameters))),\n         });\n "}, {"sha": "aa968f03d68874513c545eb5343608038a93b61c", "filename": "src/libsyntax/fold.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/8d1c5700f08a657a15c317084f8807c82a6d8fd8/src%2Flibsyntax%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8d1c5700f08a657a15c317084f8807c82a6d8fd8/src%2Flibsyntax%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffold.rs?ref=8d1c5700f08a657a15c317084f8807c82a6d8fd8", "patch": "@@ -434,8 +434,9 @@ pub fn noop_fold_usize<T: Folder>(i: usize, _: &mut T) -> usize {\n \n pub fn noop_fold_path<T: Folder>(Path { segments, span }: Path, fld: &mut T) -> Path {\n     Path {\n-        segments: segments.move_map(|PathSegment {identifier, parameters}| PathSegment {\n+        segments: segments.move_map(|PathSegment {identifier, span, parameters}| PathSegment {\n             identifier: fld.fold_ident(identifier),\n+            span: fld.new_span(span),\n             parameters: parameters.map(|ps| ps.map(|ps| fld.fold_path_parameters(ps))),\n         }),\n         span: fld.new_span(span)"}, {"sha": "88535f91379f72330ed449f407519d05b9edeb8a", "filename": "src/libsyntax/parse/mod.rs", "status": "modified", "additions": 11, "deletions": 7, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/8d1c5700f08a657a15c317084f8807c82a6d8fd8/src%2Flibsyntax%2Fparse%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8d1c5700f08a657a15c317084f8807c82a6d8fd8/src%2Flibsyntax%2Fparse%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fmod.rs?ref=8d1c5700f08a657a15c317084f8807c82a6d8fd8", "patch": "@@ -617,13 +617,17 @@ mod tests {\n         Span {lo: BytePos(a), hi: BytePos(b), expn_id: NO_EXPANSION}\n     }\n \n+    fn str2seg(s: &str, lo: u32, hi: u32) -> ast::PathSegment {\n+        ast::PathSegment::from_ident(Ident::from_str(s), sp(lo, hi))\n+    }\n+\n     #[test] fn path_exprs_1() {\n         assert!(string_to_expr(\"a\".to_string()) ==\n                    P(ast::Expr{\n                     id: ast::DUMMY_NODE_ID,\n                     node: ast::ExprKind::Path(None, ast::Path {\n                         span: sp(0, 1),\n-                        segments: vec![Ident::from_str(\"a\").into()],\n+                        segments: vec![str2seg(\"a\", 0, 1)],\n                     }),\n                     span: sp(0, 1),\n                     attrs: ThinVec::new(),\n@@ -637,8 +641,8 @@ mod tests {\n                     node: ast::ExprKind::Path(None, ast::Path {\n                         span: sp(0, 6),\n                         segments: vec![ast::PathSegment::crate_root(),\n-                                       Ident::from_str(\"a\").into(),\n-                                       Ident::from_str(\"b\").into()]\n+                                       str2seg(\"a\", 2, 3),\n+                                       str2seg(\"b\", 5, 6)]\n                     }),\n                     span: sp(0, 6),\n                     attrs: ThinVec::new(),\n@@ -744,7 +748,7 @@ mod tests {\n                         id: ast::DUMMY_NODE_ID,\n                         node:ast::ExprKind::Path(None, ast::Path{\n                             span: sp(7, 8),\n-                            segments: vec![Ident::from_str(\"d\").into()],\n+                            segments: vec![str2seg(\"d\", 7, 8)],\n                         }),\n                         span:sp(7,8),\n                         attrs: ThinVec::new(),\n@@ -761,7 +765,7 @@ mod tests {\n                            id: ast::DUMMY_NODE_ID,\n                            node: ast::ExprKind::Path(None, ast::Path {\n                                span:sp(0,1),\n-                               segments: vec![Ident::from_str(\"b\").into()],\n+                               segments: vec![str2seg(\"b\", 0, 1)],\n                             }),\n                            span: sp(0,1),\n                            attrs: ThinVec::new()})),\n@@ -802,7 +806,7 @@ mod tests {\n                                     ty: P(ast::Ty{id: ast::DUMMY_NODE_ID,\n                                                   node: ast::TyKind::Path(None, ast::Path{\n                                         span:sp(10,13),\n-                                        segments: vec![Ident::from_str(\"i32\").into()],\n+                                        segments: vec![str2seg(\"i32\", 10, 13)],\n                                         }),\n                                         span:sp(10,13)\n                                     }),\n@@ -844,7 +848,7 @@ mod tests {\n                                                 node: ast::ExprKind::Path(None,\n                                                       ast::Path{\n                                                         span:sp(17,18),\n-                                                        segments: vec![Ident::from_str(\"b\").into()],\n+                                                        segments: vec![str2seg(\"b\", 17, 18)],\n                                                       }),\n                                                 span: sp(17,18),\n                                                 attrs: ThinVec::new()})),"}, {"sha": "ff7918cc2783a55cd15ad64f0d60106045d1f9c4", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 18, "deletions": 11, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/8d1c5700f08a657a15c317084f8807c82a6d8fd8/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8d1c5700f08a657a15c317084f8807c82a6d8fd8/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=8d1c5700f08a657a15c317084f8807c82a6d8fd8", "patch": "@@ -27,7 +27,7 @@ use ast::Local;\n use ast::MacStmtStyle;\n use ast::Mac_;\n use ast::{MutTy, Mutability};\n-use ast::{Pat, PatKind};\n+use ast::{Pat, PatKind, PathSegment};\n use ast::{PolyTraitRef, QSelf};\n use ast::{Stmt, StmtKind};\n use ast::{VariantData, StructField};\n@@ -1811,7 +1811,7 @@ impl<'a> Parser<'a> {\n         };\n \n         if is_global {\n-            segments.insert(0, ast::PathSegment::crate_root());\n+            segments.insert(0, PathSegment::crate_root());\n         }\n \n         // Assemble the span.\n@@ -1829,11 +1829,12 @@ impl<'a> Parser<'a> {\n     /// - `a::b<T,U>::c<V,W>`\n     /// - `a::b<T,U>::c(V) -> W`\n     /// - `a::b<T,U>::c(V)`\n-    pub fn parse_path_segments_without_colons(&mut self) -> PResult<'a, Vec<ast::PathSegment>> {\n+    pub fn parse_path_segments_without_colons(&mut self) -> PResult<'a, Vec<PathSegment>> {\n         let mut segments = Vec::new();\n         loop {\n             // First, parse an identifier.\n             let identifier = self.parse_path_segment_ident()?;\n+            let ident_span = self.prev_span;\n \n             if self.check(&token::ModSep) && self.look_ahead(1, |t| *t == token::Lt) {\n                 self.bump();\n@@ -1881,7 +1882,11 @@ impl<'a> Parser<'a> {\n             };\n \n             // Assemble and push the result.\n-            segments.push(ast::PathSegment { identifier: identifier, parameters: parameters });\n+            segments.push(PathSegment {\n+                identifier: identifier,\n+                span: ident_span,\n+                parameters: parameters\n+            });\n \n             // Continue only if we see a `::`\n             if !self.eat(&token::ModSep) {\n@@ -1892,15 +1897,16 @@ impl<'a> Parser<'a> {\n \n     /// Examples:\n     /// - `a::b::<T,U>::c`\n-    pub fn parse_path_segments_with_colons(&mut self) -> PResult<'a, Vec<ast::PathSegment>> {\n+    pub fn parse_path_segments_with_colons(&mut self) -> PResult<'a, Vec<PathSegment>> {\n         let mut segments = Vec::new();\n         loop {\n             // First, parse an identifier.\n             let identifier = self.parse_path_segment_ident()?;\n+            let ident_span = self.prev_span;\n \n             // If we do not see a `::`, stop.\n             if !self.eat(&token::ModSep) {\n-                segments.push(identifier.into());\n+                segments.push(PathSegment::from_ident(identifier, ident_span));\n                 return Ok(segments);\n             }\n \n@@ -1909,8 +1915,9 @@ impl<'a> Parser<'a> {\n                 // Consumed `a::b::<`, go look for types\n                 let (lifetimes, types, bindings) = self.parse_generic_args()?;\n                 self.expect_gt()?;\n-                segments.push(ast::PathSegment {\n+                segments.push(PathSegment {\n                     identifier: identifier,\n+                    span: ident_span,\n                     parameters: ast::AngleBracketedParameterData {\n                         lifetimes: lifetimes,\n                         types: types,\n@@ -1924,22 +1931,22 @@ impl<'a> Parser<'a> {\n                 }\n             } else {\n                 // Consumed `a::`, go look for `b`\n-                segments.push(identifier.into());\n+                segments.push(PathSegment::from_ident(identifier, ident_span));\n             }\n         }\n     }\n \n     /// Examples:\n     /// - `a::b::c`\n     pub fn parse_path_segments_without_types(&mut self)\n-                                             -> PResult<'a, Vec<ast::PathSegment>> {\n+                                             -> PResult<'a, Vec<PathSegment>> {\n         let mut segments = Vec::new();\n         loop {\n             // First, parse an identifier.\n             let identifier = self.parse_path_segment_ident()?;\n \n             // Assemble and push the result.\n-            segments.push(identifier.into());\n+            segments.push(PathSegment::from_ident(identifier, self.prev_span));\n \n             // If we do not see a `::` or see `::{`/`::*`, stop.\n             if !self.check(&token::ModSep) || self.is_import_coupler() {\n@@ -5950,7 +5957,7 @@ impl<'a> Parser<'a> {\n             // `{foo, bar}`, `::{foo, bar}`, `*`, or `::*`.\n             self.eat(&token::ModSep);\n             let prefix = ast::Path {\n-                segments: vec![ast::PathSegment::crate_root()],\n+                segments: vec![PathSegment::crate_root()],\n                 span: mk_sp(lo, self.span.hi),\n             };\n             let view_path_kind = if self.eat(&token::BinOp(token::Star)) {"}, {"sha": "2192d203cdc23cce08e67e73d352d4e35640d5b4", "filename": "src/libsyntax/std_inject.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8d1c5700f08a657a15c317084f8807c82a6d8fd8/src%2Flibsyntax%2Fstd_inject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8d1c5700f08a657a15c317084f8807c82a6d8fd8/src%2Flibsyntax%2Fstd_inject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fstd_inject.rs?ref=8d1c5700f08a657a15c317084f8807c82a6d8fd8", "patch": "@@ -82,7 +82,7 @@ pub fn maybe_inject_crates_ref(sess: &ParseSess,\n         vis: ast::Visibility::Inherited,\n         node: ast::ItemKind::Use(P(codemap::dummy_spanned(ast::ViewPathGlob(ast::Path {\n             segments: [\"{{root}}\", name, \"prelude\", \"v1\"].into_iter().map(|name| {\n-                ast::Ident::from_str(name).into()\n+                ast::PathSegment::from_ident(ast::Ident::from_str(name), DUMMY_SP)\n             }).collect(),\n             span: span,\n         })))),"}, {"sha": "e052d2cda3a42469b000be576f82b416a08bb20c", "filename": "src/libsyntax/test.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8d1c5700f08a657a15c317084f8807c82a6d8fd8/src%2Flibsyntax%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8d1c5700f08a657a15c317084f8807c82a6d8fd8/src%2Flibsyntax%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ftest.rs?ref=8d1c5700f08a657a15c317084f8807c82a6d8fd8", "patch": "@@ -580,7 +580,7 @@ fn nospan<T>(t: T) -> codemap::Spanned<T> {\n fn path_node(ids: Vec<Ident>) -> ast::Path {\n     ast::Path {\n         span: DUMMY_SP,\n-        segments: ids.into_iter().map(Into::into).collect(),\n+        segments: ids.into_iter().map(|id| ast::PathSegment::from_ident(id, DUMMY_SP)).collect(),\n     }\n }\n "}, {"sha": "dc4b8eb24cd0a570ce18531a84024bd2e90ebff9", "filename": "src/libsyntax_ext/concat_idents.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8d1c5700f08a657a15c317084f8807c82a6d8fd8/src%2Flibsyntax_ext%2Fconcat_idents.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8d1c5700f08a657a15c317084f8807c82a6d8fd8/src%2Flibsyntax_ext%2Fconcat_idents.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fconcat_idents.rs?ref=8d1c5700f08a657a15c317084f8807c82a6d8fd8", "patch": "@@ -61,7 +61,7 @@ pub fn expand_syntax_ext<'cx>(cx: &'cx mut ExtCtxt,\n         fn path(&self) -> ast::Path {\n             ast::Path {\n                 span: self.span,\n-                segments: vec![self.ident.into()],\n+                segments: vec![ast::PathSegment::from_ident(self.ident, self.span)],\n             }\n         }\n     }"}, {"sha": "dd04c5ce356c626224f5eda92cbc93e69edc4d5c", "filename": "src/test/ui/resolve/enums-are-namespaced-xc.stderr", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/8d1c5700f08a657a15c317084f8807c82a6d8fd8/src%2Ftest%2Fui%2Fresolve%2Fenums-are-namespaced-xc.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8d1c5700f08a657a15c317084f8807c82a6d8fd8/src%2Ftest%2Fui%2Fresolve%2Fenums-are-namespaced-xc.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fresolve%2Fenums-are-namespaced-xc.stderr?ref=8d1c5700f08a657a15c317084f8807c82a6d8fd8", "patch": "@@ -1,26 +1,26 @@\n error[E0425]: cannot find value `A` in module `namespaced_enums`\n-  --> $DIR/enums-are-namespaced-xc.rs:15:13\n+  --> $DIR/enums-are-namespaced-xc.rs:15:31\n    |\n 15 |     let _ = namespaced_enums::A;\n-   |             ^^^^^^^^^^^^^^^^^^^ not found in `namespaced_enums`\n+   |                               ^ not found in `namespaced_enums`\n    |\n    = help: possible candidate is found in another module, you can import it into scope:\n              `use namespaced_enums::Foo::A;`\n \n error[E0425]: cannot find function `B` in module `namespaced_enums`\n-  --> $DIR/enums-are-namespaced-xc.rs:18:13\n+  --> $DIR/enums-are-namespaced-xc.rs:18:31\n    |\n 18 |     let _ = namespaced_enums::B(10);\n-   |             ^^^^^^^^^^^^^^^^^^^ not found in `namespaced_enums`\n+   |                               ^ not found in `namespaced_enums`\n    |\n    = help: possible candidate is found in another module, you can import it into scope:\n              `use namespaced_enums::Foo::B;`\n \n error[E0422]: cannot find struct, variant or union type `C` in module `namespaced_enums`\n-  --> $DIR/enums-are-namespaced-xc.rs:21:13\n+  --> $DIR/enums-are-namespaced-xc.rs:21:31\n    |\n 21 |     let _ = namespaced_enums::C { a: 10 };\n-   |             ^^^^^^^^^^^^^^^^^^^ not found in `namespaced_enums`\n+   |                               ^ not found in `namespaced_enums`\n    |\n    = help: possible candidate is found in another module, you can import it into scope:\n              `use namespaced_enums::Foo::C;`"}, {"sha": "4dff2620319e4607dcee7cf5fe92c79bd922a8ab", "filename": "src/test/ui/resolve/levenshtein.stderr", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/8d1c5700f08a657a15c317084f8807c82a6d8fd8/src%2Ftest%2Fui%2Fresolve%2Flevenshtein.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8d1c5700f08a657a15c317084f8807c82a6d8fd8/src%2Ftest%2Fui%2Fresolve%2Flevenshtein.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fresolve%2Flevenshtein.stderr?ref=8d1c5700f08a657a15c317084f8807c82a6d8fd8", "patch": "@@ -14,7 +14,7 @@ error[E0412]: cannot find type `Opiton` in this scope\n   --> $DIR/levenshtein.rs:20:10\n    |\n 20 | type B = Opiton<u8>; // Misspelled type name from the prelude.\n-   |          ^^^^^^^^^^ did you mean `Option`?\n+   |          ^^^^^^ did you mean `Option`?\n \n error[E0412]: cannot find type `Baz` in this scope\n   --> $DIR/levenshtein.rs:23:14\n@@ -35,16 +35,16 @@ error[E0425]: cannot find function `foobar` in this scope\n    |     ^^^^^^ did you mean `foo_bar`?\n \n error[E0412]: cannot find type `first` in module `m`\n-  --> $DIR/levenshtein.rs:32:12\n+  --> $DIR/levenshtein.rs:32:15\n    |\n 32 |     let b: m::first = m::second; // Misspelled item in module.\n-   |            ^^^^^^^^ did you mean `m::First`?\n+   |               ^^^^^ did you mean `First`?\n \n error[E0425]: cannot find value `second` in module `m`\n-  --> $DIR/levenshtein.rs:32:23\n+  --> $DIR/levenshtein.rs:32:26\n    |\n 32 |     let b: m::first = m::second; // Misspelled item in module.\n-   |                       ^^^^^^^^^ did you mean `m::Second`?\n+   |                          ^^^^^^ did you mean `Second`?\n \n error: aborting due to 8 previous errors\n "}, {"sha": "85fb1777dea233abf7e71dd53e577a29a7ba84b5", "filename": "src/test/ui/resolve/suggest-path-instead-of-mod-dot-item.stderr", "status": "modified", "additions": 27, "deletions": 9, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/8d1c5700f08a657a15c317084f8807c82a6d8fd8/src%2Ftest%2Fui%2Fresolve%2Fsuggest-path-instead-of-mod-dot-item.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8d1c5700f08a657a15c317084f8807c82a6d8fd8/src%2Ftest%2Fui%2Fresolve%2Fsuggest-path-instead-of-mod-dot-item.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fresolve%2Fsuggest-path-instead-of-mod-dot-item.stderr?ref=8d1c5700f08a657a15c317084f8807c82a6d8fd8", "patch": "@@ -2,55 +2,73 @@ error[E0423]: expected value, found module `a`\n   --> $DIR/suggest-path-instead-of-mod-dot-item.rs:27:5\n    |\n 27 |     a.I\n-   |     ^ did you mean `a::I`?\n+   |     ^--\n+   |     |\n+   |     did you mean `a::I`?\n \n error[E0423]: expected value, found module `a`\n   --> $DIR/suggest-path-instead-of-mod-dot-item.rs:33:5\n    |\n 33 |     a.g()\n-   |     ^ did you mean `a::g(...)`?\n+   |     ^----\n+   |     |\n+   |     did you mean `a::g(...)`?\n \n error[E0423]: expected value, found module `a`\n   --> $DIR/suggest-path-instead-of-mod-dot-item.rs:39:5\n    |\n 39 |     a.b.J\n-   |     ^ did you mean `a::b`?\n+   |     ^--\n+   |     |\n+   |     did you mean `a::b`?\n \n error[E0423]: expected value, found module `a::b`\n   --> $DIR/suggest-path-instead-of-mod-dot-item.rs:45:5\n    |\n 45 |     a::b.J\n-   |     ^^^^ did you mean `a::b::J`?\n+   |     ^^^^--\n+   |     |\n+   |     did you mean `a::b::J`?\n \n error[E0423]: expected value, found module `a`\n   --> $DIR/suggest-path-instead-of-mod-dot-item.rs:51:5\n    |\n 51 |     a.b.f();\n-   |     ^ did you mean `a::b`?\n+   |     ^--\n+   |     |\n+   |     did you mean `a::b`?\n \n error[E0423]: expected value, found module `a::b`\n   --> $DIR/suggest-path-instead-of-mod-dot-item.rs:55:12\n    |\n 55 |     v.push(a::b);\n-   |            ^^^^ did you mean `a::I`?\n+   |            ^^^-\n+   |               |\n+   |               did you mean `I`?\n \n error[E0423]: expected value, found module `a::b`\n   --> $DIR/suggest-path-instead-of-mod-dot-item.rs:61:5\n    |\n 61 |     a::b.f()\n-   |     ^^^^ did you mean `a::b::f(...)`?\n+   |     ^^^^----\n+   |     |\n+   |     did you mean `a::b::f(...)`?\n \n error[E0423]: expected value, found module `a::b`\n   --> $DIR/suggest-path-instead-of-mod-dot-item.rs:67:5\n    |\n 67 |     a::b\n-   |     ^^^^ did you mean `a::I`?\n+   |     ^^^-\n+   |        |\n+   |        did you mean `I`?\n \n error[E0423]: expected function, found module `a::b`\n   --> $DIR/suggest-path-instead-of-mod-dot-item.rs:73:5\n    |\n 73 |     a::b()\n-   |     ^^^^ did you mean `a::I`?\n+   |     ^^^-\n+   |        |\n+   |        did you mean `I`?\n \n error: main function not found\n "}, {"sha": "015dbfc3dc775fe509d4ac8e7bef1b8748332212", "filename": "src/test/ui/resolve/unboxed-closure-sugar-nonexistent-trait.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8d1c5700f08a657a15c317084f8807c82a6d8fd8/src%2Ftest%2Fui%2Fresolve%2Funboxed-closure-sugar-nonexistent-trait.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8d1c5700f08a657a15c317084f8807c82a6d8fd8/src%2Ftest%2Fui%2Fresolve%2Funboxed-closure-sugar-nonexistent-trait.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fresolve%2Funboxed-closure-sugar-nonexistent-trait.stderr?ref=8d1c5700f08a657a15c317084f8807c82a6d8fd8", "patch": "@@ -2,7 +2,7 @@ error[E0405]: cannot find trait `Nonexist` in this scope\n   --> $DIR/unboxed-closure-sugar-nonexistent-trait.rs:11:8\n    |\n 11 | fn f<F:Nonexist(isize) -> isize>(x: F) {}\n-   |        ^^^^^^^^^^^^^^^^^^^^^^^^ not found in this scope\n+   |        ^^^^^^^^ not found in this scope\n \n error[E0404]: expected trait, found type alias `Typedef`\n   --> $DIR/unboxed-closure-sugar-nonexistent-trait.rs:17:8"}]}