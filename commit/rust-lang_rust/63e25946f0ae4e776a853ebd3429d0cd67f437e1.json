{"sha": "63e25946f0ae4e776a853ebd3429d0cd67f437e1", "node_id": "MDY6Q29tbWl0NzI0NzEyOjYzZTI1OTQ2ZjBhZTRlNzc2YTg1M2ViZDM0MjlkMGNkNjdmNDM3ZTE=", "commit": {"author": {"name": "Jeff Olson", "email": "olson.jeffery@gmail.com", "date": "2012-08-18T15:05:27Z"}, "committer": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2012-09-08T21:22:15Z"}, "message": "core: port task.rs to comm::Chan/Port to pipes::Chan/Port", "tree": {"sha": "c46e0eea1cdefb35c6dcb873df575542b734f976", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c46e0eea1cdefb35c6dcb873df575542b734f976"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/63e25946f0ae4e776a853ebd3429d0cd67f437e1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/63e25946f0ae4e776a853ebd3429d0cd67f437e1", "html_url": "https://github.com/rust-lang/rust/commit/63e25946f0ae4e776a853ebd3429d0cd67f437e1", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/63e25946f0ae4e776a853ebd3429d0cd67f437e1/comments", "author": {"login": "olsonjeffery", "id": 10408, "node_id": "MDQ6VXNlcjEwNDA4", "avatar_url": "https://avatars.githubusercontent.com/u/10408?v=4", "gravatar_id": "", "url": "https://api.github.com/users/olsonjeffery", "html_url": "https://github.com/olsonjeffery", "followers_url": "https://api.github.com/users/olsonjeffery/followers", "following_url": "https://api.github.com/users/olsonjeffery/following{/other_user}", "gists_url": "https://api.github.com/users/olsonjeffery/gists{/gist_id}", "starred_url": "https://api.github.com/users/olsonjeffery/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/olsonjeffery/subscriptions", "organizations_url": "https://api.github.com/users/olsonjeffery/orgs", "repos_url": "https://api.github.com/users/olsonjeffery/repos", "events_url": "https://api.github.com/users/olsonjeffery/events{/privacy}", "received_events_url": "https://api.github.com/users/olsonjeffery/received_events", "type": "User", "site_admin": false}, "committer": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "940ef65e0e945f4c0e072ae4ebe86bfaddeb9710", "url": "https://api.github.com/repos/rust-lang/rust/commits/940ef65e0e945f4c0e072ae4ebe86bfaddeb9710", "html_url": "https://github.com/rust-lang/rust/commit/940ef65e0e945f4c0e072ae4ebe86bfaddeb9710"}], "stats": {"total": 173, "additions": 135, "deletions": 38}, "files": [{"sha": "b694118e86f272b349a67e737ecfece45aaeb6cd", "filename": "src/libcore/task.rs", "status": "modified", "additions": 135, "deletions": 38, "changes": 173, "blob_url": "https://github.com/rust-lang/rust/blob/63e25946f0ae4e776a853ebd3429d0cd67f437e1/src%2Flibcore%2Ftask.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63e25946f0ae4e776a853ebd3429d0cd67f437e1/src%2Flibcore%2Ftask.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftask.rs?ref=63e25946f0ae4e776a853ebd3429d0cd67f437e1", "patch": "@@ -29,6 +29,7 @@\n \n use cmp::Eq;\n use result::Result;\n+use pipes::{stream, Chan, Port};\n \n export Task;\n export TaskResult;\n@@ -77,6 +78,10 @@ export ThreadPerTask;\n export ManualThreads;\n export PlatformThread;\n \n+macro_rules! move_it {\n+    { $x:expr } => { unsafe { let y <- *ptr::addr_of($x); y } }\n+}\n+\n /* Data types */\n \n /// A handle to a task\n@@ -203,8 +208,8 @@ type SchedOpts = {\n type TaskOpts = {\n     linked: bool,\n     supervised: bool,\n-    notify_chan: Option<comm::Chan<Notification>>,\n-    sched: Option<SchedOpts>,\n+    mut notify_chan: Option<Chan<Notification>>,\n+    sched: option<SchedOpts>,\n };\n \n /**\n@@ -214,7 +219,7 @@ type TaskOpts = {\n  */\n // NB: Builders are designed to be single-use because they do stateful\n // things that get weird when reusing - e.g. if you create a result future\n-// it only applies to a single task, so then you have to maintain some\n+// it only applies to a single task, so then you have to maintain Some\n // potentially tricky state to ensure that everything behaves correctly\n // when you try to reuse the builder to spawn a new task. We'll just\n // sidestep that whole issue by making builders uncopyable and making\n@@ -248,7 +253,22 @@ priv impl TaskBuilder {\n             fail ~\"Cannot copy a task_builder\"; // Fake move mode on self\n         }\n         self.consumed = true;\n-        TaskBuilder({ can_not_copy: None, mut consumed: false,.. *self })\n+        let notify_chan = if self.opts.notify_chan == None {\n+            None\n+        } else {\n+            Some(option::swap_unwrap(&mut self.opts.notify_chan))\n+        };\n+        TaskBuilder({\n+            opts: {\n+                linked: self.opts.linked,\n+                supervised: self.opts.supervised,\n+                mut notify_chan: notify_chan,\n+                sched: self.opts.sched\n+            },\n+            gen_body: self.gen_body,\n+            can_not_copy: None,\n+            mut consumed: false\n+        })\n     }\n }\n \n@@ -258,8 +278,18 @@ impl TaskBuilder {\n      * the other will not be killed.\n      */\n     fn unlinked() -> TaskBuilder {\n+        let notify_chan = if self.opts.notify_chan == None {\n+            None\n+        } else {\n+            Some(option::swap_unwrap(&mut self.opts.notify_chan))\n+        };\n         TaskBuilder({\n-            opts: { linked: false,.. self.opts },\n+            opts: {\n+                linked: false,\n+                supervised: self.opts.supervised,\n+                mut notify_chan: notify_chan,\n+                sched: self.opts.sched\n+            },\n             can_not_copy: None,\n             .. *self.consume()\n         })\n@@ -270,8 +300,18 @@ impl TaskBuilder {\n      * the child.\n      */\n     fn supervised() -> TaskBuilder {\n+        let notify_chan = if self.opts.notify_chan == None {\n+            None\n+        } else {\n+            Some(option::swap_unwrap(&mut self.opts.notify_chan))\n+        };\n         TaskBuilder({\n-            opts: { linked: false, supervised: true,.. self.opts },\n+            opts: {\n+                linked: false,\n+                supervised: true,\n+                mut notify_chan: notify_chan,\n+                sched: self.opts.sched\n+            },\n             can_not_copy: None,\n             .. *self.consume()\n         })\n@@ -281,8 +321,18 @@ impl TaskBuilder {\n      * other will be killed.\n      */\n     fn linked() -> TaskBuilder {\n+        let notify_chan = if self.opts.notify_chan == None {\n+            None\n+        } else {\n+            Some(option::swap_unwrap(&mut self.opts.notify_chan))\n+        };\n         TaskBuilder({\n-            opts: { linked: true, supervised: false,.. self.opts },\n+            opts: {\n+                linked: true,\n+                supervised: false,\n+                mut notify_chan: notify_chan,\n+                sched: self.opts.sched\n+            },\n             can_not_copy: None,\n             .. *self.consume()\n         })\n@@ -316,11 +366,10 @@ impl TaskBuilder {\n         }\n \n         // Construct the future and give it to the caller.\n-        let po = comm::Port::<Notification>();\n-        let ch = comm::Chan(po);\n+        let (ch, po) = stream::<Notification>();\n \n         blk(do future::from_fn {\n-            match comm::recv(po) {\n+            match po.recv() {\n               Exit(_, result) => result\n             }\n         });\n@@ -334,9 +383,18 @@ impl TaskBuilder {\n     }\n     /// Configure a custom scheduler mode for the task.\n     fn sched_mode(mode: SchedMode) -> TaskBuilder {\n+        let notify_chan = if self.opts.notify_chan == None {\n+            None\n+        } else {\n+            Some(option::swap_unwrap(&mut self.opts.notify_chan))\n+        };\n         TaskBuilder({\n-            opts: { sched: Some({ mode: mode, foreign_stack_size: None}),\n-                    .. self.opts },\n+            opts: {\n+                linked: self.opts.linked,\n+                supervised: self.opts.supervised,\n+                mut notify_chan: notify_chan,\n+                sched: Some({ mode: mode, foreign_stack_size: None})\n+            },\n             can_not_copy: None,\n             .. *self.consume()\n         })\n@@ -356,7 +414,18 @@ impl TaskBuilder {\n      */\n     fn add_wrapper(wrapper: fn@(+fn~()) -> fn~()) -> TaskBuilder {\n         let prev_gen_body = self.gen_body;\n+        let notify_chan = if self.opts.notify_chan == None {\n+            None\n+        } else {\n+            Some(option::swap_unwrap(&mut self.opts.notify_chan))\n+        };\n         TaskBuilder({\n+            opts: {\n+                linked: self.opts.linked,\n+                supervised: self.opts.supervised,\n+                mut notify_chan: notify_chan,\n+                sched: self.opts.sched\n+            },\n             gen_body: |body| { wrapper(prev_gen_body(body)) },\n             can_not_copy: None,\n             .. *self.consume()\n@@ -377,7 +446,18 @@ impl TaskBuilder {\n      */\n     fn spawn(+f: fn~()) {\n         let x = self.consume();\n-        spawn_raw(x.opts, x.gen_body(f));\n+        let notify_chan = if self.opts.notify_chan == None {\n+            None\n+        } else {\n+            Some(option::swap_unwrap(&mut self.opts.notify_chan))\n+        };\n+        let opts = {\n+            linked: x.opts.linked,\n+            supervised: x.opts.supervised,\n+            mut notify_chan: notify_chan,\n+            sched: x.opts.sched\n+        };\n+        spawn_raw(opts, x.gen_body(f));\n     }\n     /// Runs a task, while transfering ownership of one argument to the child.\n     fn spawn_with<A: Send>(+arg: A, +f: fn~(+A)) {\n@@ -394,7 +474,7 @@ impl TaskBuilder {\n      * child task, passes the port to child's body, and returns a channel\n      * linked to the port to the parent.\n      *\n-     * This encapsulates some boilerplate handshaking logic that would\n+     * This encapsulates Some boilerplate handshaking logic that would\n      * otherwise be required to establish communication from the parent\n      * to the child.\n      */\n@@ -466,7 +546,7 @@ fn default_task_opts() -> TaskOpts {\n     {\n         linked: true,\n         supervised: false,\n-        notify_chan: None,\n+        mut notify_chan: None,\n         sched: None\n     }\n }\n@@ -872,7 +952,7 @@ fn each_ancestor(list:        &mut AncestorList,\n         // 'do_continue'  - Did the forward_blk succeed at this point? (i.e.,\n         //                  should we recurse? or should our callers unwind?)\n \n-        // The map defaults to none, because if ancestors is none, we're at\n+        // The map defaults to None, because if ancestors is None, we're at\n         // the end of the list, which doesn't make sense to coalesce.\n         return do (**ancestors).map_default((None,false)) |ancestor_arc| {\n             // NB: Takes a lock! (this ancestor node)\n@@ -950,7 +1030,11 @@ fn each_ancestor(list:        &mut AncestorList,\n struct TCB {\n     me:            *rust_task,\n     // List of tasks with whose fates this one's is intertwined.\n+<<<<<<< HEAD\n     tasks:         TaskGroupArc, // 'none' means the group has failed.\n+=======\n+    let tasks:         TaskGroupArc; // 'None' means the group has failed.\n+>>>>>>> core: port task.rs to comm::Chan/Port to pipes::Chan/Port\n     // Lists of tasks who will kill us if they fail, but whom we won't kill.\n     mut ancestors: AncestorList,\n     is_main:       bool,\n@@ -995,15 +1079,15 @@ fn TCB(me: *rust_task, +tasks: TaskGroupArc, +ancestors: AncestorList,\n }\n \n struct AutoNotify {\n-    notify_chan: comm::Chan<Notification>,\n+    notify_chan: Chan<Notification>,\n     mut failed:  bool,\n     drop {\n         let result = if self.failed { Failure } else { Success };\n-        comm::send(self.notify_chan, Exit(get_task(), result));\n+        self.notify_chan.send(Exit(get_task(), result));\n     }\n }\n \n-fn AutoNotify(chan: comm::Chan<Notification>) -> AutoNotify {\n+fn AutoNotify(chan: Chan<Notification>) -> AutoNotify {\n     AutoNotify {\n         notify_chan: chan,\n         failed: true // Un-set above when taskgroup successfully made.\n@@ -1013,7 +1097,7 @@ fn AutoNotify(chan: comm::Chan<Notification>) -> AutoNotify {\n fn enlist_in_taskgroup(state: TaskGroupInner, me: *rust_task,\n                        is_member: bool) -> bool {\n     let newstate = util::replace(state, None);\n-    // If 'none', the group was failing. Can't enlist.\n+    // If 'None', the group was failing. Can't enlist.\n     if newstate.is_some() {\n         let group = option::unwrap(newstate);\n         taskset_insert(if is_member { &mut group.members }\n@@ -1028,7 +1112,7 @@ fn enlist_in_taskgroup(state: TaskGroupInner, me: *rust_task,\n // NB: Runs in destructor/post-exit context. Can't 'fail'.\n fn leave_taskgroup(state: TaskGroupInner, me: *rust_task, is_member: bool) {\n     let newstate = util::replace(state, None);\n-    // If 'none', already failing and we've already gotten a kill signal.\n+    // If 'None', already failing and we've already gotten a kill signal.\n     if newstate.is_some() {\n         let group = option::unwrap(newstate);\n         taskset_remove(if is_member { &mut group.members }\n@@ -1048,9 +1132,9 @@ fn kill_taskgroup(state: TaskGroupInner, me: *rust_task, is_main: bool) {\n     // To do it differently, we'd have to use the runtime's task refcounting,\n     // but that could leave task structs around long after their task exited.\n     let newstate = util::replace(state, None);\n-    // Might already be none, if somebody is failing simultaneously.\n+    // Might already be None, if Somebody is failing simultaneously.\n     // That's ok; only one task needs to do the dirty work. (Might also\n-    // see 'none' if somebody already failed and we got a kill signal.)\n+    // see 'None' if Somebody already failed and we got a kill signal.)\n     if newstate.is_some() {\n         let group = option::unwrap(newstate);\n         for taskset_each(&group.members) |+sibling| {\n@@ -1067,7 +1151,7 @@ fn kill_taskgroup(state: TaskGroupInner, me: *rust_task, is_main: bool) {\n         if is_main {\n             rustrt::rust_task_kill_all(me);\n         }\n-        // Do NOT restore state to Some(..)! It stays none to indicate\n+        // Do NOT restore state to Some(..)! It stays None to indicate\n         // that the whole taskgroup is failing, to forbid new spawns.\n     }\n     // (note: multiple tasks may reach this point)\n@@ -1145,7 +1229,7 @@ fn gen_child_taskgroup(linked: bool, supervised: bool)\n         // Appease the borrow-checker. Really this wants to be written as:\n         // match ancestors\n         //    Some(ancestor_arc) { ancestor_list(Some(ancestor_arc.clone())) }\n-        //    none               { ancestor_list(none) }\n+        //    None               { ancestor_list(None) }\n         let tmp = util::replace(&mut **ancestors, None);\n         if tmp.is_some() {\n             let ancestor_arc = option::unwrap(tmp);\n@@ -1175,10 +1259,15 @@ fn spawn_raw(+opts: TaskOpts, +f: fn~()) {\n             };\n             assert !new_task.is_null();\n             // Getting killed after here would leak the task.\n+            let mut notify_chan = if opts.notify_chan == None {\n+                None\n+            } else {\n+                Some(option::swap_unwrap(&mut opts.notify_chan))\n+            };\n \n             let child_wrapper =\n                 make_child_wrapper(new_task, child_tg, ancestors, is_main,\n-                                   opts.notify_chan, f);\n+                                   notify_chan, f);\n             let fptr = ptr::addr_of(child_wrapper);\n             let closure: *rust_closure = unsafe::reinterpret_cast(&fptr);\n \n@@ -1198,17 +1287,25 @@ fn spawn_raw(+opts: TaskOpts, +f: fn~()) {\n     // (4) ...and runs the provided body function.\n     fn make_child_wrapper(child: *rust_task, +child_arc: TaskGroupArc,\n                           +ancestors: AncestorList, is_main: bool,\n-                          notify_chan: Option<comm::Chan<Notification>>,\n+                          +notify_chan: Option<Chan<Notification>>,\n                           +f: fn~()) -> fn~() {\n         let child_data = ~mut Some((child_arc, ancestors));\n-        return fn~() {\n+        return fn~(move notify_chan) {\n             // Agh. Get move-mode items into the closure. FIXME (#2829)\n             let mut (child_arc, ancestors) = option::swap_unwrap(child_data);\n             // Child task runs this code.\n \n             // Even if the below code fails to kick the child off, we must\n-            // send something on the notify channel.\n-            let notifier = notify_chan.map(|c| AutoNotify(c));\n+            // send Something on the notify channel.\n+\n+            //let mut notifier = None;//notify_chan.map(|c| AutoNotify(c));\n+            let notifier = match notify_chan {\n+                Some(notify_chan_value) => {\n+                    let moved_ncv = move_it!{notify_chan_value};\n+                    Some(AutoNotify(moved_ncv))\n+                }\n+                _ => None\n+            };\n \n             if enlist_many(child, &child_arc, &mut ancestors) {\n                 let group = @TCB(child, child_arc, ancestors,\n@@ -1221,7 +1318,7 @@ fn spawn_raw(+opts: TaskOpts, +f: fn~()) {\n         };\n \n         // Set up membership in taskgroup and descendantship in all ancestor\n-        // groups. If any enlistment fails, some task was already failing, so\n+        // groups. If any enlistment fails, Some task was already failing, so\n         // don't let the child task run, and undo every successful enlistment.\n         fn enlist_many(child: *rust_task, child_arc: &TaskGroupArc,\n                        ancestors: &mut AncestorList) -> bool {\n@@ -1387,7 +1484,7 @@ unsafe fn local_data_lookup<T: Owned>(\n         }\n     );\n     do map_pos.map |index| {\n-        // .get() is guaranteed because of \"none { false }\" above.\n+        // .get() is guaranteed because of \"None { false }\" above.\n         let (_, data_ptr, _) = (*map)[index].get();\n         (index, data_ptr)\n     }\n@@ -1452,7 +1549,7 @@ unsafe fn local_set<T: Owned>(\n         }\n         None => {\n             // Find an empty slot. If not, grow the vector.\n-            match (*map).position(|x| x.is_none()) {\n+            match (*map).position(|x| x.is_None()) {\n                 Some(empty_index) => (*map).set_elt(empty_index, new_entry),\n                 None => (*map).push(new_entry)\n             }\n@@ -1500,7 +1597,7 @@ unsafe fn local_data_set<T: Owned>(\n     local_set(rustrt::rust_get_task(), key, data)\n }\n /**\n- * Modify a task-local data value. If the function returns 'none', the\n+ * Modify a task-local data value. If the function returns 'None', the\n  * data is removed (and its reference dropped).\n  */\n unsafe fn local_data_modify<T: Owned>(\n@@ -1583,7 +1680,7 @@ fn test_cant_dup_task_builder() {\n // The following 8 tests test the following 2^3 combinations:\n // {un,}linked {un,}supervised failure propagation {up,down}wards.\n \n-// !!! These tests are dangerous. If something is buggy, they will hang, !!!\n+// !!! These tests are dangerous. If Something is buggy, they will hang, !!!\n // !!! instead of exiting cleanly. This might wedge the buildbots.       !!!\n \n #[test] #[ignore(cfg(windows))]\n@@ -2146,7 +2243,7 @@ fn test_tls_multitask() unsafe {\n     fn my_key(+_x: @~str) { }\n     local_data_set(my_key, @~\"parent data\");\n     do task::spawn unsafe {\n-        assert local_data_get(my_key).is_none(); // TLS shouldn't carry over.\n+        assert local_data_get(my_key).is_None(); // TLS shouldn't carry over.\n         local_data_set(my_key, @~\"child data\");\n         assert *(local_data_get(my_key).get()) == ~\"child data\";\n         // should be cleaned up for us\n@@ -2171,7 +2268,7 @@ fn test_tls_pop() unsafe {\n     local_data_set(my_key, @~\"weasel\");\n     assert *(local_data_pop(my_key).get()) == ~\"weasel\";\n     // Pop must remove the data from the map.\n-    assert local_data_pop(my_key).is_none();\n+    assert local_data_pop(my_key).is_None();\n }\n \n #[test]\n@@ -2198,7 +2295,7 @@ fn test_tls_crust_automorestack_memorial_bug() unsafe {\n     // This might result in a stack-canary clobber if the runtime fails to set\n     // sp_limit to 0 when calling the cleanup extern - it might automatically\n     // jump over to the rust stack, which causes next_c_sp to get recorded as\n-    // something within a rust stack segment. Then a subsequent upcall (esp.\n+    // Something within a rust stack segment. Then a subsequent upcall (esp.\n     // for logging, think vsnprintf) would run on a stack smaller than 1 MB.\n     fn my_key(+_x: @~str) { }\n     do task::spawn {"}]}