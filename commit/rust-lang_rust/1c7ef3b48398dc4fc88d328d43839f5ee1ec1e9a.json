{"sha": "1c7ef3b48398dc4fc88d328d43839f5ee1ec1e9a", "node_id": "C_kwDOAAsO6NoAKDFjN2VmM2I0ODM5OGRjNGZjODhkMzI4ZDQzODM5ZjVlZTFlYzFlOWE", "commit": {"author": {"name": "Matthias Kr\u00fcger", "email": "matthias.krueger@famsik.de", "date": "2023-03-24T00:22:06Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2023-03-24T00:22:06Z"}, "message": "Rollup merge of #109493 - compiler-errors:new-solver-vars-obligations, r=lcnr\n\nReturn nested obligations from canonical response var unification\n\nHandle alias-eq obligations being emitted from `instantiate_and_apply_query_response` in:\n* `EvalCtxt` - by processing the nested obligations in the next loop by `new_goals`\n* `FulfillCtxt` - by adding the nested obligations to the fulfillment's pending obligations\n* `InferCtxt::evaluate_obligation` - ~~by returning `EvaluationResult::EvaluatedToAmbig` (boo :-1:, see the FIXME)~~ same behavior as above, since we use fulfillment and `select_where_possible`\n\nThe only one that's truly sketchy is `evaluate_obligation`, but it's not hard to modify this behavior moving forward.\n\nFrom #109037, I think a smaller repro could be crafted if I were smarter, but I am not, so I just took this from #105878.\n\nr? `@lcnr` cc `@BoxyUwU`", "tree": {"sha": "c76a0ec290ac0c094dae19478e50f356eff9abaa", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c76a0ec290ac0c094dae19478e50f356eff9abaa"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1c7ef3b48398dc4fc88d328d43839f5ee1ec1e9a", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJkHO0uCRBK7hj4Ov3rIwAACysIAD20KtrmiymF2AmfkFWuip5h\ntN40N5Z6morScZSLu4QZV/DunAxHg+5XlAELnX/+olouqyJ8P+/ztSIzCrqrB5HY\njOiQ0Nx7h+vIxQFvFK4jI/L6siyg4Y8f0PQRPEeA11JQcUrYYQrtw5yxQBvuSCv0\npH0C1e+nvrFEAZ6ES8hXGHQWbgbY/Td0KR97VvoD0cEwFr72rzd+ixzXL+zdsL5m\nAdNExaCIfwYEfC/dxCrZe1+Hrfh3296Qq25KFU7sH36UErMhYfo0h+EL+UuA0bqW\nISOw4GWpTrEOzaRDpdgw7LLBaNIK2na6CqGfjwgqEPaDpcauwGGwxD/tj7+2LeQ=\n=aAGd\n-----END PGP SIGNATURE-----\n", "payload": "tree c76a0ec290ac0c094dae19478e50f356eff9abaa\nparent cca2630bc9879c844e6891d68c38ee5627e4d9c7\nparent 1680334928c7bf36d0bf4c3329aa34bbfd343c72\nauthor Matthias Kr\u00fcger <matthias.krueger@famsik.de> 1679617326 +0100\ncommitter GitHub <noreply@github.com> 1679617326 +0100\n\nRollup merge of #109493 - compiler-errors:new-solver-vars-obligations, r=lcnr\n\nReturn nested obligations from canonical response var unification\n\nHandle alias-eq obligations being emitted from `instantiate_and_apply_query_response` in:\n* `EvalCtxt` - by processing the nested obligations in the next loop by `new_goals`\n* `FulfillCtxt` - by adding the nested obligations to the fulfillment's pending obligations\n* `InferCtxt::evaluate_obligation` - ~~by returning `EvaluationResult::EvaluatedToAmbig` (boo :-1:, see the FIXME)~~ same behavior as above, since we use fulfillment and `select_where_possible`\n\nThe only one that's truly sketchy is `evaluate_obligation`, but it's not hard to modify this behavior moving forward.\n\nFrom #109037, I think a smaller repro could be crafted if I were smarter, but I am not, so I just took this from #105878.\n\nr? `@lcnr` cc `@BoxyUwU`\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1c7ef3b48398dc4fc88d328d43839f5ee1ec1e9a", "html_url": "https://github.com/rust-lang/rust/commit/1c7ef3b48398dc4fc88d328d43839f5ee1ec1e9a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1c7ef3b48398dc4fc88d328d43839f5ee1ec1e9a/comments", "author": {"login": "matthiaskrgr", "id": 476013, "node_id": "MDQ6VXNlcjQ3NjAxMw==", "avatar_url": "https://avatars.githubusercontent.com/u/476013?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matthiaskrgr", "html_url": "https://github.com/matthiaskrgr", "followers_url": "https://api.github.com/users/matthiaskrgr/followers", "following_url": "https://api.github.com/users/matthiaskrgr/following{/other_user}", "gists_url": "https://api.github.com/users/matthiaskrgr/gists{/gist_id}", "starred_url": "https://api.github.com/users/matthiaskrgr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matthiaskrgr/subscriptions", "organizations_url": "https://api.github.com/users/matthiaskrgr/orgs", "repos_url": "https://api.github.com/users/matthiaskrgr/repos", "events_url": "https://api.github.com/users/matthiaskrgr/events{/privacy}", "received_events_url": "https://api.github.com/users/matthiaskrgr/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "cca2630bc9879c844e6891d68c38ee5627e4d9c7", "url": "https://api.github.com/repos/rust-lang/rust/commits/cca2630bc9879c844e6891d68c38ee5627e4d9c7", "html_url": "https://github.com/rust-lang/rust/commit/cca2630bc9879c844e6891d68c38ee5627e4d9c7"}, {"sha": "1680334928c7bf36d0bf4c3329aa34bbfd343c72", "url": "https://api.github.com/repos/rust-lang/rust/commits/1680334928c7bf36d0bf4c3329aa34bbfd343c72", "html_url": "https://github.com/rust-lang/rust/commit/1680334928c7bf36d0bf4c3329aa34bbfd343c72"}], "stats": {"total": 130, "additions": 84, "deletions": 46}, "files": [{"sha": "efecaf33ef987a9579ab622f09c4d821760952aa", "filename": "compiler/rustc_trait_selection/src/solve/canonical/mod.rs", "status": "modified", "additions": 8, "deletions": 14, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/1c7ef3b48398dc4fc88d328d43839f5ee1ec1e9a/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fcanonical%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1c7ef3b48398dc4fc88d328d43839f5ee1ec1e9a/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fcanonical%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fcanonical%2Fmod.rs?ref=1c7ef3b48398dc4fc88d328d43839f5ee1ec1e9a", "patch": "@@ -99,20 +99,20 @@ impl<'tcx> EvalCtxt<'_, 'tcx> {\n         param_env: ty::ParamEnv<'tcx>,\n         original_values: Vec<ty::GenericArg<'tcx>>,\n         response: CanonicalResponse<'tcx>,\n-    ) -> Result<Certainty, NoSolution> {\n+    ) -> Result<(Certainty, Vec<Goal<'tcx, ty::Predicate<'tcx>>>), NoSolution> {\n         let substitution = self.compute_query_response_substitution(&original_values, &response);\n \n         let Response { var_values, external_constraints, certainty } =\n             response.substitute(self.tcx(), &substitution);\n \n-        self.unify_query_var_values(param_env, &original_values, var_values)?;\n+        let nested_goals = self.unify_query_var_values(param_env, &original_values, var_values)?;\n \n         // FIXME: implement external constraints.\n         let ExternalConstraintsData { region_constraints, opaque_types: _ } =\n             external_constraints.deref();\n         self.register_region_constraints(region_constraints);\n \n-        Ok(certainty)\n+        Ok((certainty, nested_goals))\n     }\n \n     /// This returns the substitutions to instantiate the bound variables of\n@@ -205,21 +205,15 @@ impl<'tcx> EvalCtxt<'_, 'tcx> {\n         param_env: ty::ParamEnv<'tcx>,\n         original_values: &[ty::GenericArg<'tcx>],\n         var_values: CanonicalVarValues<'tcx>,\n-    ) -> Result<(), NoSolution> {\n+    ) -> Result<Vec<Goal<'tcx, ty::Predicate<'tcx>>>, NoSolution> {\n         assert_eq!(original_values.len(), var_values.len());\n+\n+        let mut nested_goals = vec![];\n         for (&orig, response) in iter::zip(original_values, var_values.var_values) {\n-            // This can fail due to the occurs check, see\n-            // `tests/ui/typeck/lazy-norm/equating-projection-cyclically.rs` for an example\n-            // where that can happen.\n-            //\n-            // FIXME: To deal with #105787 I also expect us to emit nested obligations here at\n-            // some point. We can figure out how to deal with this once we actually have\n-            // an ICE.\n-            let nested_goals = self.eq_and_get_goals(param_env, orig, response)?;\n-            assert!(nested_goals.is_empty(), \"{nested_goals:?}\");\n+            nested_goals.extend(self.eq_and_get_goals(param_env, orig, response)?);\n         }\n \n-        Ok(())\n+        Ok(nested_goals)\n     }\n \n     fn register_region_constraints(&mut self, region_constraints: &QueryRegionConstraints<'tcx>) {"}, {"sha": "e47b5ae21b5afafcc5e155c74bb05c84224193b7", "filename": "compiler/rustc_trait_selection/src/solve/eval_ctxt.rs", "status": "modified", "additions": 9, "deletions": 8, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/1c7ef3b48398dc4fc88d328d43839f5ee1ec1e9a/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Feval_ctxt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1c7ef3b48398dc4fc88d328d43839f5ee1ec1e9a/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Feval_ctxt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Feval_ctxt.rs?ref=1c7ef3b48398dc4fc88d328d43839f5ee1ec1e9a", "patch": "@@ -70,17 +70,16 @@ pub trait InferCtxtEvalExt<'tcx> {\n     fn evaluate_root_goal(\n         &self,\n         goal: Goal<'tcx, ty::Predicate<'tcx>>,\n-    ) -> Result<(bool, Certainty), NoSolution>;\n+    ) -> Result<(bool, Certainty, Vec<Goal<'tcx, ty::Predicate<'tcx>>>), NoSolution>;\n }\n \n impl<'tcx> InferCtxtEvalExt<'tcx> for InferCtxt<'tcx> {\n     #[instrument(level = \"debug\", skip(self))]\n     fn evaluate_root_goal(\n         &self,\n         goal: Goal<'tcx, ty::Predicate<'tcx>>,\n-    ) -> Result<(bool, Certainty), NoSolution> {\n+    ) -> Result<(bool, Certainty, Vec<Goal<'tcx, ty::Predicate<'tcx>>>), NoSolution> {\n         let mode = if self.intercrate { SolverMode::Coherence } else { SolverMode::Normal };\n-\n         let mut search_graph = search_graph::SearchGraph::new(self.tcx, mode);\n \n         let mut ecx = EvalCtxt {\n@@ -152,13 +151,13 @@ impl<'a, 'tcx> EvalCtxt<'a, 'tcx> {\n         &mut self,\n         is_normalizes_to_hack: IsNormalizesToHack,\n         goal: Goal<'tcx, ty::Predicate<'tcx>>,\n-    ) -> Result<(bool, Certainty), NoSolution> {\n+    ) -> Result<(bool, Certainty, Vec<Goal<'tcx, ty::Predicate<'tcx>>>), NoSolution> {\n         let (orig_values, canonical_goal) = self.canonicalize_goal(goal);\n         let canonical_response =\n             EvalCtxt::evaluate_canonical_goal(self.tcx(), self.search_graph, canonical_goal)?;\n \n         let has_changed = !canonical_response.value.var_values.is_identity();\n-        let certainty = self.instantiate_and_apply_query_response(\n+        let (certainty, nested_goals) = self.instantiate_and_apply_query_response(\n             goal.param_env,\n             orig_values,\n             canonical_response,\n@@ -186,7 +185,7 @@ impl<'a, 'tcx> EvalCtxt<'a, 'tcx> {\n             assert_eq!(certainty, canonical_response.value.certainty);\n         }\n \n-        Ok((has_changed, certainty))\n+        Ok((has_changed, certainty, nested_goals))\n     }\n \n     fn compute_goal(&mut self, goal: Goal<'tcx, ty::Predicate<'tcx>>) -> QueryResult<'tcx> {\n@@ -263,13 +262,14 @@ impl<'a, 'tcx> EvalCtxt<'a, 'tcx> {\n                 let mut has_changed = Err(Certainty::Yes);\n \n                 if let Some(goal) = goals.normalizes_to_hack_goal.take() {\n-                    let (_, certainty) = match this.evaluate_goal(\n+                    let (_, certainty, nested_goals) = match this.evaluate_goal(\n                         IsNormalizesToHack::Yes,\n                         goal.with(this.tcx(), ty::Binder::dummy(goal.predicate)),\n                     ) {\n                         Ok(r) => r,\n                         Err(NoSolution) => return Some(Err(NoSolution)),\n                     };\n+                    new_goals.goals.extend(nested_goals);\n \n                     if goal.predicate.projection_ty\n                         != this.resolve_vars_if_possible(goal.predicate.projection_ty)\n@@ -308,11 +308,12 @@ impl<'a, 'tcx> EvalCtxt<'a, 'tcx> {\n                 }\n \n                 for nested_goal in goals.goals.drain(..) {\n-                    let (changed, certainty) =\n+                    let (changed, certainty, nested_goals) =\n                         match this.evaluate_goal(IsNormalizesToHack::No, nested_goal) {\n                             Ok(result) => result,\n                             Err(NoSolution) => return Some(Err(NoSolution)),\n                         };\n+                    new_goals.goals.extend(nested_goals);\n \n                     if changed {\n                         has_changed = Ok(());"}, {"sha": "76a2a5879114dc9377d15c8d03464bbf5a3657b4", "filename": "compiler/rustc_trait_selection/src/solve/fulfill.rs", "status": "modified", "additions": 12, "deletions": 2, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/1c7ef3b48398dc4fc88d328d43839f5ee1ec1e9a/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Ffulfill.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1c7ef3b48398dc4fc88d328d43839f5ee1ec1e9a/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Ffulfill.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Ffulfill.rs?ref=1c7ef3b48398dc4fc88d328d43839f5ee1ec1e9a", "patch": "@@ -1,6 +1,7 @@\n use std::mem;\n \n use rustc_infer::infer::InferCtxt;\n+use rustc_infer::traits::Obligation;\n use rustc_infer::traits::{\n     query::NoSolution, FulfillmentError, FulfillmentErrorCode, MismatchedProjectionTypes,\n     PredicateObligation, SelectionError, TraitEngine,\n@@ -61,7 +62,7 @@ impl<'tcx> TraitEngine<'tcx> for FulfillmentCtxt<'tcx> {\n             let mut has_changed = false;\n             for obligation in mem::take(&mut self.obligations) {\n                 let goal = obligation.clone().into();\n-                let (changed, certainty) = match infcx.evaluate_root_goal(goal) {\n+                let (changed, certainty, nested_goals) = match infcx.evaluate_root_goal(goal) {\n                     Ok(result) => result,\n                     Err(NoSolution) => {\n                         errors.push(FulfillmentError {\n@@ -125,7 +126,16 @@ impl<'tcx> TraitEngine<'tcx> for FulfillmentCtxt<'tcx> {\n                         continue;\n                     }\n                 };\n-\n+                // Push any nested goals that we get from unifying our canonical response\n+                // with our obligation onto the fulfillment context.\n+                self.obligations.extend(nested_goals.into_iter().map(|goal| {\n+                    Obligation::new(\n+                        infcx.tcx,\n+                        obligation.cause.clone(),\n+                        goal.param_env,\n+                        goal.predicate,\n+                    )\n+                }));\n                 has_changed |= changed;\n                 match certainty {\n                     Certainty::Yes => {}"}, {"sha": "edbe2de8105e6a2378284dc31b1e71610ed0c85b", "filename": "compiler/rustc_trait_selection/src/traits/query/evaluate_obligation.rs", "status": "modified", "additions": 14, "deletions": 22, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/1c7ef3b48398dc4fc88d328d43839f5ee1ec1e9a/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fquery%2Fevaluate_obligation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1c7ef3b48398dc4fc88d328d43839f5ee1ec1e9a/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fquery%2Fevaluate_obligation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fquery%2Fevaluate_obligation.rs?ref=1c7ef3b48398dc4fc88d328d43839f5ee1ec1e9a", "patch": "@@ -1,9 +1,8 @@\n-use rustc_middle::traits::solve::{Certainty, Goal, MaybeCause};\n+use rustc_infer::traits::{TraitEngine, TraitEngineExt};\n use rustc_middle::ty;\n \n use crate::infer::canonical::OriginalQueryValues;\n use crate::infer::InferCtxt;\n-use crate::solve::InferCtxtEvalExt;\n use crate::traits::{EvaluationResult, OverflowError, PredicateObligation, SelectionContext};\n \n pub trait InferCtxtExt<'tcx> {\n@@ -81,27 +80,20 @@ impl<'tcx> InferCtxtExt<'tcx> for InferCtxt<'tcx> {\n \n         if self.tcx.trait_solver_next() {\n             self.probe(|snapshot| {\n-                if let Ok((_, certainty)) =\n-                    self.evaluate_root_goal(Goal::new(self.tcx, param_env, obligation.predicate))\n-                {\n-                    match certainty {\n-                        Certainty::Yes => {\n-                            if self.opaque_types_added_in_snapshot(snapshot) {\n-                                Ok(EvaluationResult::EvaluatedToOkModuloOpaqueTypes)\n-                            } else if self.region_constraints_added_in_snapshot(snapshot).is_some()\n-                            {\n-                                Ok(EvaluationResult::EvaluatedToOkModuloRegions)\n-                            } else {\n-                                Ok(EvaluationResult::EvaluatedToOk)\n-                            }\n-                        }\n-                        Certainty::Maybe(MaybeCause::Ambiguity) => {\n-                            Ok(EvaluationResult::EvaluatedToAmbig)\n-                        }\n-                        Certainty::Maybe(MaybeCause::Overflow) => Err(OverflowError::Canonical),\n-                    }\n-                } else {\n+                let mut fulfill_cx = crate::solve::FulfillmentCtxt::new();\n+                fulfill_cx.register_predicate_obligation(self, obligation.clone());\n+                // True errors\n+                // FIXME(-Ztrait-solver=next): Overflows are reported as ambig here, is that OK?\n+                if !fulfill_cx.select_where_possible(self).is_empty() {\n                     Ok(EvaluationResult::EvaluatedToErr)\n+                } else if !fulfill_cx.select_all_or_error(self).is_empty() {\n+                    Ok(EvaluationResult::EvaluatedToAmbig)\n+                } else if self.opaque_types_added_in_snapshot(snapshot) {\n+                    Ok(EvaluationResult::EvaluatedToOkModuloOpaqueTypes)\n+                } else if self.region_constraints_added_in_snapshot(snapshot).is_some() {\n+                    Ok(EvaluationResult::EvaluatedToOkModuloRegions)\n+                } else {\n+                    Ok(EvaluationResult::EvaluatedToOk)\n                 }\n             })\n         } else {"}, {"sha": "4f429f018edf74943edbdf1428bd88768a5eec9f", "filename": "compiler/rustc_trait_selection/src/traits/select/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/1c7ef3b48398dc4fc88d328d43839f5ee1ec1e9a/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1c7ef3b48398dc4fc88d328d43839f5ee1ec1e9a/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fmod.rs?ref=1c7ef3b48398dc4fc88d328d43839f5ee1ec1e9a", "patch": "@@ -618,6 +618,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         let mut fulfill_cx = crate::solve::FulfillmentCtxt::new();\n         fulfill_cx.register_predicate_obligations(self.infcx, predicates);\n         // True errors\n+        // FIXME(-Ztrait-solver=next): Overflows are reported as ambig here, is that OK?\n         if !fulfill_cx.select_where_possible(self.infcx).is_empty() {\n             return Ok(EvaluatedToErr);\n         }"}, {"sha": "4bfb6323a53662b32f8db005a7eb4a8ca5024e94", "filename": "tests/ui/traits/new-solver/alias-eq-in-canonical-response.rs", "status": "added", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/1c7ef3b48398dc4fc88d328d43839f5ee1ec1e9a/tests%2Fui%2Ftraits%2Fnew-solver%2Falias-eq-in-canonical-response.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1c7ef3b48398dc4fc88d328d43839f5ee1ec1e9a/tests%2Fui%2Ftraits%2Fnew-solver%2Falias-eq-in-canonical-response.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ftraits%2Fnew-solver%2Falias-eq-in-canonical-response.rs?ref=1c7ef3b48398dc4fc88d328d43839f5ee1ec1e9a", "patch": "@@ -0,0 +1,40 @@\n+// check-pass\n+// compile-flags: -Ztrait-solver=next\n+\n+trait Foo {\n+    type Gat<'a>\n+    where\n+        Self: 'a;\n+    fn bar(&self) -> Self::Gat<'_>;\n+}\n+\n+enum Option<T> {\n+    Some(T),\n+    None,\n+}\n+\n+impl<T> Option<T> {\n+    fn as_ref(&self) -> Option<&T> {\n+        match self {\n+            Option::Some(t) => Option::Some(t),\n+            Option::None => Option::None,\n+        }\n+    }\n+\n+    fn map<U>(self, f: impl FnOnce(T) -> U) -> Option<U> {\n+        match self {\n+            Option::Some(t) => Option::Some(f(t)),\n+            Option::None => Option::None,\n+        }\n+    }\n+}\n+\n+impl<T: Foo + 'static> Foo for Option<T> {\n+    type Gat<'a> = Option<<T as Foo>::Gat<'a>> where Self: 'a;\n+\n+    fn bar(&self) -> Self::Gat<'_> {\n+        self.as_ref().map(Foo::bar)\n+    }\n+}\n+\n+fn main() {}"}]}