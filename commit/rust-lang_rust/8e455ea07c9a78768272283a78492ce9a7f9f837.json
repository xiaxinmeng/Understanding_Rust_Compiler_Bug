{"sha": "8e455ea07c9a78768272283a78492ce9a7f9f837", "node_id": "MDY6Q29tbWl0NzI0NzEyOjhlNDU1ZWEwN2M5YTc4NzY4MjcyMjgzYTc4NDkyY2U5YTdmOWY4Mzc=", "commit": {"author": {"name": "Brian Koropoff", "email": "bkoropoff@gmail.com", "date": "2014-10-04T02:40:19Z"}, "committer": {"name": "Brian Koropoff", "email": "bkoropoff@gmail.com", "date": "2014-10-04T02:40:19Z"}, "message": "Fix type visitor glue for unboxed closures\n\nThis is a quick fix that prevents an ICE by mimicing the visitor\nglue for boxed closures and bare functions.  Ideally, the `TyVisitor`\ninterface will be improved in the future to allow representing\nmore information about unboxed closures such as Fn/FnMut/FnOnce\nstatus, capture mode, and captured free variable types and offsets.\n\nCloses issue #17737", "tree": {"sha": "b381787b155c7af910d60c45ba9e59e9921699c7", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b381787b155c7af910d60c45ba9e59e9921699c7"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8e455ea07c9a78768272283a78492ce9a7f9f837", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8e455ea07c9a78768272283a78492ce9a7f9f837", "html_url": "https://github.com/rust-lang/rust/commit/8e455ea07c9a78768272283a78492ce9a7f9f837", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8e455ea07c9a78768272283a78492ce9a7f9f837/comments", "author": {"login": "bkoropoff", "id": 2101303, "node_id": "MDQ6VXNlcjIxMDEzMDM=", "avatar_url": "https://avatars.githubusercontent.com/u/2101303?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bkoropoff", "html_url": "https://github.com/bkoropoff", "followers_url": "https://api.github.com/users/bkoropoff/followers", "following_url": "https://api.github.com/users/bkoropoff/following{/other_user}", "gists_url": "https://api.github.com/users/bkoropoff/gists{/gist_id}", "starred_url": "https://api.github.com/users/bkoropoff/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bkoropoff/subscriptions", "organizations_url": "https://api.github.com/users/bkoropoff/orgs", "repos_url": "https://api.github.com/users/bkoropoff/repos", "events_url": "https://api.github.com/users/bkoropoff/events{/privacy}", "received_events_url": "https://api.github.com/users/bkoropoff/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bkoropoff", "id": 2101303, "node_id": "MDQ6VXNlcjIxMDEzMDM=", "avatar_url": "https://avatars.githubusercontent.com/u/2101303?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bkoropoff", "html_url": "https://github.com/bkoropoff", "followers_url": "https://api.github.com/users/bkoropoff/followers", "following_url": "https://api.github.com/users/bkoropoff/following{/other_user}", "gists_url": "https://api.github.com/users/bkoropoff/gists{/gist_id}", "starred_url": "https://api.github.com/users/bkoropoff/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bkoropoff/subscriptions", "organizations_url": "https://api.github.com/users/bkoropoff/orgs", "repos_url": "https://api.github.com/users/bkoropoff/repos", "events_url": "https://api.github.com/users/bkoropoff/events{/privacy}", "received_events_url": "https://api.github.com/users/bkoropoff/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "136ab3c6b1efc6605f317280f13d53a940ea7a8e", "url": "https://api.github.com/repos/rust-lang/rust/commits/136ab3c6b1efc6605f317280f13d53a940ea7a8e", "html_url": "https://github.com/rust-lang/rust/commit/136ab3c6b1efc6605f317280f13d53a940ea7a8e"}], "stats": {"total": 54, "additions": 36, "deletions": 18}, "files": [{"sha": "bff1a0400a9d158ec29ebc1aeb70ec2344fa24a3", "filename": "src/librustc/middle/trans/reflect.rs", "status": "modified", "additions": 36, "deletions": 18, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/8e455ea07c9a78768272283a78492ce9a7f9f837/src%2Flibrustc%2Fmiddle%2Ftrans%2Freflect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8e455ea07c9a78768272283a78492ce9a7f9f837/src%2Flibrustc%2Fmiddle%2Ftrans%2Freflect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Freflect.rs?ref=8e455ea07c9a78768272283a78492ce9a7f9f837", "patch": "@@ -127,6 +127,22 @@ impl<'a, 'blk, 'tcx> Reflector<'a, 'blk, 'tcx> {\n         self.visit(name, []);\n     }\n \n+    fn visit_closure_ty(&mut self, fty: &ty::ClosureTy, is_unboxed: bool) {\n+        let pureval = ast_fn_style_constant(fty.fn_style);\n+        let sigilval = match fty.store {\n+            ty::UniqTraitStore => 2u,\n+            ty::RegionTraitStore(..) => 4u,\n+        };\n+        let retval = if ty::type_is_bot(fty.sig.output) {0u} else {1u};\n+        let extra = vec!(self.c_uint(pureval),\n+                         self.c_uint(sigilval),\n+                         self.c_uint(fty.sig.inputs.len()),\n+                         self.c_uint(retval));\n+        self.visit(\"enter_fn\", extra.as_slice());\n+        self.visit_sig(retval, &fty.sig, is_unboxed);\n+        self.visit(\"leave_fn\", extra.as_slice());\n+    }\n+\n     // Entrypoint\n     pub fn visit_ty(&mut self, t: ty::t) {\n         let bcx = self.bcx;\n@@ -247,20 +263,8 @@ impl<'a, 'blk, 'tcx> Reflector<'a, 'blk, 'tcx> {\n \n           // FIXME (#2594): fetch constants out of intrinsic\n           // FIXME (#4809): visitor should break out bare fns from other fns\n-          ty::ty_closure(ref fty) => {\n-            let pureval = ast_fn_style_constant(fty.fn_style);\n-            let sigilval = match fty.store {\n-                ty::UniqTraitStore => 2u,\n-                ty::RegionTraitStore(..) => 4u,\n-            };\n-            let retval = if ty::type_is_bot(fty.sig.output) {0u} else {1u};\n-            let extra = vec!(self.c_uint(pureval),\n-                          self.c_uint(sigilval),\n-                          self.c_uint(fty.sig.inputs.len()),\n-                          self.c_uint(retval));\n-            self.visit(\"enter_fn\", extra.as_slice());\n-            self.visit_sig(retval, &fty.sig);\n-            self.visit(\"leave_fn\", extra.as_slice());\n+          ty::ty_closure(box ref fty) => {\n+              self.visit_closure_ty(fty, false);\n           }\n \n           // FIXME (#2594): fetch constants out of intrinsic:: for the\n@@ -274,7 +278,7 @@ impl<'a, 'blk, 'tcx> Reflector<'a, 'blk, 'tcx> {\n                           self.c_uint(fty.sig.inputs.len()),\n                           self.c_uint(retval));\n             self.visit(\"enter_fn\", extra.as_slice());\n-            self.visit_sig(retval, &fty.sig);\n+            self.visit_sig(retval, &fty.sig, false);\n             self.visit(\"leave_fn\", extra.as_slice());\n           }\n \n@@ -388,16 +392,30 @@ impl<'a, 'blk, 'tcx> Reflector<'a, 'blk, 'tcx> {\n           // Miscellaneous extra types\n           ty::ty_infer(_) => self.leaf(\"infer\"),\n           ty::ty_err => self.leaf(\"err\"),\n-          ty::ty_unboxed_closure(..) => self.leaf(\"err\"),\n+          ty::ty_unboxed_closure(ref def_id, _) => {\n+              let closure_map = tcx.unboxed_closures.borrow();\n+              let fty = &closure_map.find(def_id).unwrap().closure_type;\n+              self.visit_closure_ty(fty, true);\n+          }\n           ty::ty_param(ref p) => {\n               let extra = vec!(self.c_uint(p.idx));\n               self.visit(\"param\", extra.as_slice())\n           }\n         }\n     }\n \n-    pub fn visit_sig(&mut self, retval: uint, sig: &ty::FnSig) {\n-        for (i, arg) in sig.inputs.iter().enumerate() {\n+    pub fn visit_sig(&mut self, retval: uint, sig: &ty::FnSig, is_unboxed: bool) {\n+        let args = if is_unboxed {\n+            match ty::get(sig.inputs[0]).sty {\n+                ty::ty_tup(ref contents) => contents.iter(),\n+                ty::ty_nil => [].iter(),\n+                _ => unreachable!()\n+            }\n+        } else {\n+            sig.inputs.iter()\n+        };\n+\n+        for (i, arg) in args.enumerate() {\n             let modeval = 5u;   // \"by copy\"\n             let extra = vec!(self.c_uint(i),\n                          self.c_uint(modeval),"}]}