{"sha": "054199766cab624d0e1ea27c82b18753dabb7400", "node_id": "MDY6Q29tbWl0NzI0NzEyOjA1NDE5OTc2NmNhYjYyNGQwZTFlYTI3YzgyYjE4NzUzZGFiYjc0MDA=", "commit": {"author": {"name": "Nick Cameron", "email": "ncameron@mozilla.com", "date": "2017-01-16T00:54:36Z"}, "committer": {"name": "Nick Cameron", "email": "ncameron@mozilla.com", "date": "2017-01-16T00:54:36Z"}, "message": "proc macros/qquote: Handle empty delimited tokens", "tree": {"sha": "c8c969146c26a43c2361fea4554440f1a4e5b72c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c8c969146c26a43c2361fea4554440f1a4e5b72c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/054199766cab624d0e1ea27c82b18753dabb7400", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/054199766cab624d0e1ea27c82b18753dabb7400", "html_url": "https://github.com/rust-lang/rust/commit/054199766cab624d0e1ea27c82b18753dabb7400", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/054199766cab624d0e1ea27c82b18753dabb7400/comments", "author": {"login": "nrc", "id": 762626, "node_id": "MDQ6VXNlcjc2MjYyNg==", "avatar_url": "https://avatars.githubusercontent.com/u/762626?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nrc", "html_url": "https://github.com/nrc", "followers_url": "https://api.github.com/users/nrc/followers", "following_url": "https://api.github.com/users/nrc/following{/other_user}", "gists_url": "https://api.github.com/users/nrc/gists{/gist_id}", "starred_url": "https://api.github.com/users/nrc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nrc/subscriptions", "organizations_url": "https://api.github.com/users/nrc/orgs", "repos_url": "https://api.github.com/users/nrc/repos", "events_url": "https://api.github.com/users/nrc/events{/privacy}", "received_events_url": "https://api.github.com/users/nrc/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nrc", "id": 762626, "node_id": "MDQ6VXNlcjc2MjYyNg==", "avatar_url": "https://avatars.githubusercontent.com/u/762626?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nrc", "html_url": "https://github.com/nrc", "followers_url": "https://api.github.com/users/nrc/followers", "following_url": "https://api.github.com/users/nrc/following{/other_user}", "gists_url": "https://api.github.com/users/nrc/gists{/gist_id}", "starred_url": "https://api.github.com/users/nrc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nrc/subscriptions", "organizations_url": "https://api.github.com/users/nrc/orgs", "repos_url": "https://api.github.com/users/nrc/repos", "events_url": "https://api.github.com/users/nrc/events{/privacy}", "received_events_url": "https://api.github.com/users/nrc/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ac5046cf67e51df286e7c8df02d67c302d4c4d09", "url": "https://api.github.com/repos/rust-lang/rust/commits/ac5046cf67e51df286e7c8df02d67c302d4c4d09", "html_url": "https://github.com/rust-lang/rust/commit/ac5046cf67e51df286e7c8df02d67c302d4c4d09"}], "stats": {"total": 153, "additions": 113, "deletions": 40}, "files": [{"sha": "03873b20c18cbef5f6936b1eded890555ed81770", "filename": "src/libproc_macro_plugin/qquote.rs", "status": "modified", "additions": 43, "deletions": 40, "changes": 83, "blob_url": "https://github.com/rust-lang/rust/blob/054199766cab624d0e1ea27c82b18753dabb7400/src%2Flibproc_macro_plugin%2Fqquote.rs", "raw_url": "https://github.com/rust-lang/rust/raw/054199766cab624d0e1ea27c82b18753dabb7400/src%2Flibproc_macro_plugin%2Fqquote.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibproc_macro_plugin%2Fqquote.rs?ref=054199766cab624d0e1ea27c82b18753dabb7400", "patch": "@@ -60,14 +60,14 @@ pub fn qquote<'cx>(cx: &'cx mut ExtCtxt, sp: Span, tts: &[TokenTree])\n struct QDelimited {\n     delim: token::DelimToken,\n     open_span: Span,\n-    tts: Vec<QTT>,\n+    tts: Vec<Qtt>,\n     close_span: Span,\n }\n \n #[derive(Debug)]\n-enum QTT {\n+enum Qtt {\n     TT(TokenTree),\n-    QDL(QDelimited),\n+    Delimited(QDelimited),\n     QIdent(TokenTree),\n }\n \n@@ -103,10 +103,10 @@ fn qquoter<'cx>(cx: &'cx mut ExtCtxt, ts: TokenStream) -> TokenStream {\n    }\n }\n \n-fn qquote_iter<'cx>(cx: &'cx mut ExtCtxt, depth: i64, ts: TokenStream) -> (Bindings, Vec<QTT>) {\n+fn qquote_iter<'cx>(cx: &'cx mut ExtCtxt, depth: i64, ts: TokenStream) -> (Bindings, Vec<Qtt>) {\n     let mut depth = depth;\n     let mut bindings: Bindings = Vec::new();\n-    let mut output: Vec<QTT> = Vec::new();\n+    let mut output: Vec<Qtt> = Vec::new();\n \n     let mut iter = ts.iter();\n \n@@ -133,32 +133,32 @@ fn qquote_iter<'cx>(cx: &'cx mut ExtCtxt, depth: i64, ts: TokenStream) -> (Bindi\n                     for b in bindings.clone() {\n                         debug!(\"{:?} = {}\", b.0, pprust::tts_to_string(&b.1.to_tts()[..]));\n                     }\n-                    output.push(QTT::QIdent(as_tt(Token::Ident(new_id.clone()))));\n+                    output.push(Qtt::QIdent(as_tt(Token::Ident(new_id.clone()))));\n                 } else {\n                     depth = depth - 1;\n-                    output.push(QTT::TT(next.clone()));\n+                    output.push(Qtt::TT(next.clone()));\n                 }\n             }\n             TokenTree::Token(_, Token::Ident(id)) if is_qquote(id) => {\n                 depth = depth + 1;\n             }\n             TokenTree::Delimited(_, ref dl) => {\n                 let br = qquote_iter(cx, depth, TokenStream::from_tts(dl.tts.clone().to_owned()));\n-                let mut bind_ = br.0;\n-                let res_ = br.1;\n-                bindings.append(&mut bind_);\n+                let mut nested_bindings = br.0;\n+                let nested = br.1;\n+                bindings.append(&mut nested_bindings);\n \n                 let new_dl = QDelimited {\n                     delim: dl.delim,\n                     open_span: dl.open_span,\n-                    tts: res_,\n+                    tts: nested,\n                     close_span: dl.close_span,\n                 };\n \n-                output.push(QTT::QDL(new_dl));\n+                output.push(Qtt::Delimited(new_dl));\n             }\n             t => {\n-                output.push(QTT::TT(t));\n+                output.push(Qtt::TT(t));\n             }\n         }\n     }\n@@ -188,9 +188,9 @@ fn unravel_concats(tss: Vec<TokenStream>) -> TokenStream {\n     output\n }\n \n-/// This converts the vector of QTTs into a seet of Bindings for construction and the main\n+/// This converts the vector of Qtts into a set of Bindings for construction and the main\n /// body as a TokenStream.\n-fn convert_complex_tts<'cx>(cx: &'cx mut ExtCtxt, tts: Vec<QTT>) -> (Bindings, TokenStream) {\n+fn convert_complex_tts<'cx>(cx: &'cx mut ExtCtxt, tts: Vec<Qtt>) -> (Bindings, TokenStream) {\n     let mut pushes: Vec<TokenStream> = Vec::new();\n     let mut bindings: Bindings = Vec::new();\n \n@@ -203,28 +203,37 @@ fn convert_complex_tts<'cx>(cx: &'cx mut ExtCtxt, tts: Vec<QTT>) -> (Bindings, T\n         }\n         let next = next.unwrap();\n         match next {\n-            QTT::TT(TokenTree::Token(_, t)) => {\n+            Qtt::TT(TokenTree::Token(_, t)) => {\n                 let token_out = emit_token(t);\n                 pushes.push(token_out);\n             }\n             // FIXME handle sequence repetition tokens\n-            QTT::QDL(qdl) => {\n-                debug!(\"  QDL: {:?} \", qdl.tts);\n-                let new_id = Ident::with_empty_ctxt(Symbol::gensym(\"qdl_tmp\"));\n-                let mut cct_rec = convert_complex_tts(cx, qdl.tts);\n-                bindings.append(&mut cct_rec.0);\n-                bindings.push((new_id, cct_rec.1));\n-\n-                let sep = build_delim_tok(qdl.delim);\n-\n-                pushes.push(build_mod_call(\n-                    vec![Ident::from_str(\"proc_macro_tokens\"),\n-                         Ident::from_str(\"build\"),\n-                         Ident::from_str(\"build_delimited\")],\n-                    concat(from_tokens(vec![Token::Ident(new_id)]), concat(lex(\",\"), sep)),\n-                ));\n+            Qtt::Delimited(qdl) => {\n+                debug!(\"  Delimited: {:?} \", qdl.tts);\n+                let fresh_id = Ident::with_empty_ctxt(Symbol::gensym(\"qdl_tmp\"));\n+                let (mut nested_bindings, nested_toks) = convert_complex_tts(cx, qdl.tts);\n+\n+                let body = if nested_toks.is_empty() {\n+                    assert!(nested_bindings.is_empty());\n+                    build_mod_call(vec![Ident::from_str(\"TokenStream\"),\n+                                        Ident::from_str(\"mk_empty\")],\n+                                   TokenStream::mk_empty())\n+                } else {\n+                    bindings.append(&mut nested_bindings);\n+                    bindings.push((fresh_id, nested_toks));\n+                    TokenStream::from_tokens(vec![Token::Ident(fresh_id)])\n+                };\n+\n+                let delimitiers = build_delim_tok(qdl.delim);\n+\n+                pushes.push(build_mod_call(vec![Ident::from_str(\"proc_macro_tokens\"),\n+                                                Ident::from_str(\"build\"),\n+                                                Ident::from_str(\"build_delimited\")],\n+                                           flatten(vec![body,\n+                                                        lex(\",\"),\n+                                                        delimitiers].into_iter())));\n             }\n-            QTT::QIdent(t) => {\n+            Qtt::QIdent(t) => {\n                 pushes.push(TokenStream::from_tts(vec![t]));\n                 pushes.push(TokenStream::mk_empty());\n             }\n@@ -240,14 +249,8 @@ fn convert_complex_tts<'cx>(cx: &'cx mut ExtCtxt, tts: Vec<QTT>) -> (Bindings, T\n // Utilities\n \n /// Unravels Bindings into a TokenStream of `let` declarations.\n-fn unravel(binds: Bindings) -> TokenStream {\n-    let mut output = TokenStream::mk_empty();\n-\n-    for b in binds {\n-        output = concat(output, build_let(b.0, b.1));\n-    }\n-\n-    output\n+fn unravel(bindings: Bindings) -> TokenStream {\n+    flatten(bindings.into_iter().map(|(a, b)| build_let(a, b)))\n }\n \n /// Checks if the Ident is `unquote`."}, {"sha": "89c84b6bc221acda2ecc0af85494dbd5e4f4a09c", "filename": "src/libproc_macro_tokens/build.rs", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/054199766cab624d0e1ea27c82b18753dabb7400/src%2Flibproc_macro_tokens%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/054199766cab624d0e1ea27c82b18753dabb7400/src%2Flibproc_macro_tokens%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibproc_macro_tokens%2Fbuild.rs?ref=054199766cab624d0e1ea27c82b18753dabb7400", "patch": "@@ -24,6 +24,19 @@ pub fn concat(ts1: TokenStream, ts2: TokenStream) -> TokenStream {\n     TokenStream::concat(ts1, ts2)\n }\n \n+/// Flatten a sequence of TokenStreams into a single TokenStream.\n+pub fn flatten<T: Iterator<Item=TokenStream>>(mut iter: T) -> TokenStream {\n+    match iter.next() {\n+        Some(mut ts) => {\n+            for next in iter {\n+                ts = TokenStream::concat(ts, next);\n+            }\n+            ts\n+        }\n+        None => TokenStream::mk_empty()\n+    }\n+}\n+\n /// Checks if two identifiers have the same name, disregarding context. This allows us to\n /// fake 'reserved' keywords.\n // FIXME We really want `free-identifier-=?` (a la Dybvig 1993). von Tander 2007 is"}, {"sha": "a2dbb0a96d9671dbb184b8dd4f0036720139c8e0", "filename": "src/test/run-pass-fulldeps/auxiliary/hello_macro.rs", "status": "added", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/054199766cab624d0e1ea27c82b18753dabb7400/src%2Ftest%2Frun-pass-fulldeps%2Fauxiliary%2Fhello_macro.rs", "raw_url": "https://github.com/rust-lang/rust/raw/054199766cab624d0e1ea27c82b18753dabb7400/src%2Ftest%2Frun-pass-fulldeps%2Fauxiliary%2Fhello_macro.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass-fulldeps%2Fauxiliary%2Fhello_macro.rs?ref=054199766cab624d0e1ea27c82b18753dabb7400", "patch": "@@ -0,0 +1,35 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(plugin)]\n+#![feature(plugin_registrar)]\n+#![feature(rustc_private)]\n+#![plugin(proc_macro_plugin)]\n+\n+extern crate rustc_plugin;\n+extern crate proc_macro_tokens;\n+extern crate syntax;\n+\n+use syntax::ext::proc_macro_shim::prelude::*;\n+use proc_macro_tokens::prelude::*;\n+\n+use rustc_plugin::Registry;\n+\n+#[plugin_registrar]\n+pub fn plugin_registrar(reg: &mut Registry) {\n+    reg.register_macro(\"hello\", hello);\n+}\n+\n+// This macro is not very interesting, but it does contain delimited tokens with\n+// no content - `()` and `{}` - which has caused problems in the past.\n+fn hello<'cx>(cx: &'cx mut ExtCtxt, sp: Span, tts: &[TokenTree]) -> Box<MacResult + 'cx> {\n+    let output = qquote!({ fn hello() {} hello(); });\n+    build_block_emitter(cx, sp, output)\n+}"}, {"sha": "bdbea8a419416f7db089719dcb19587c913bc711", "filename": "src/test/run-pass-fulldeps/macro-quote-empty-delims.rs", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/054199766cab624d0e1ea27c82b18753dabb7400/src%2Ftest%2Frun-pass-fulldeps%2Fmacro-quote-empty-delims.rs", "raw_url": "https://github.com/rust-lang/rust/raw/054199766cab624d0e1ea27c82b18753dabb7400/src%2Ftest%2Frun-pass-fulldeps%2Fmacro-quote-empty-delims.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass-fulldeps%2Fmacro-quote-empty-delims.rs?ref=054199766cab624d0e1ea27c82b18753dabb7400", "patch": "@@ -0,0 +1,22 @@\n+// Copyright 2012-2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Test that a macro can emit delimiters with nothing inside - `()`, `{}`\n+\n+// aux-build:hello_macro.rs\n+// ignore-stage1\n+\n+#![feature(plugin)]\n+#![feature(rustc_private)]\n+#![plugin(hello_macro)]\n+\n+fn main() {\n+    hello!();\n+}"}]}