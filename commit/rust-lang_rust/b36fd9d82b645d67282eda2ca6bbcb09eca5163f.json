{"sha": "b36fd9d82b645d67282eda2ca6bbcb09eca5163f", "node_id": "MDY6Q29tbWl0NzI0NzEyOmIzNmZkOWQ4MmI2NDVkNjcyODJlZGEyY2E2YmJjYjA5ZWNhNTE2M2Y=", "commit": {"author": {"name": "bjorn3", "email": "bjorn3@users.noreply.github.com", "date": "2021-02-21T09:49:55Z"}, "committer": {"name": "bjorn3", "email": "bjorn3@users.noreply.github.com", "date": "2021-02-21T09:49:55Z"}, "message": "Remove unnecessary parts from alloc_system", "tree": {"sha": "63d8244b7067e77f8be8923f41bf336d4c313541", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/63d8244b7067e77f8be8923f41bf336d4c313541"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b36fd9d82b645d67282eda2ca6bbcb09eca5163f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b36fd9d82b645d67282eda2ca6bbcb09eca5163f", "html_url": "https://github.com/rust-lang/rust/commit/b36fd9d82b645d67282eda2ca6bbcb09eca5163f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b36fd9d82b645d67282eda2ca6bbcb09eca5163f/comments", "author": {"login": "bjorn3", "id": 17426603, "node_id": "MDQ6VXNlcjE3NDI2NjAz", "avatar_url": "https://avatars.githubusercontent.com/u/17426603?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bjorn3", "html_url": "https://github.com/bjorn3", "followers_url": "https://api.github.com/users/bjorn3/followers", "following_url": "https://api.github.com/users/bjorn3/following{/other_user}", "gists_url": "https://api.github.com/users/bjorn3/gists{/gist_id}", "starred_url": "https://api.github.com/users/bjorn3/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bjorn3/subscriptions", "organizations_url": "https://api.github.com/users/bjorn3/orgs", "repos_url": "https://api.github.com/users/bjorn3/repos", "events_url": "https://api.github.com/users/bjorn3/events{/privacy}", "received_events_url": "https://api.github.com/users/bjorn3/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bjorn3", "id": 17426603, "node_id": "MDQ6VXNlcjE3NDI2NjAz", "avatar_url": "https://avatars.githubusercontent.com/u/17426603?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bjorn3", "html_url": "https://github.com/bjorn3", "followers_url": "https://api.github.com/users/bjorn3/followers", "following_url": "https://api.github.com/users/bjorn3/following{/other_user}", "gists_url": "https://api.github.com/users/bjorn3/gists{/gist_id}", "starred_url": "https://api.github.com/users/bjorn3/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bjorn3/subscriptions", "organizations_url": "https://api.github.com/users/bjorn3/orgs", "repos_url": "https://api.github.com/users/bjorn3/repos", "events_url": "https://api.github.com/users/bjorn3/events{/privacy}", "received_events_url": "https://api.github.com/users/bjorn3/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a8f3877c361f368ee045025f2c5d055cd9f66b0f", "url": "https://api.github.com/repos/rust-lang/rust/commits/a8f3877c361f368ee045025f2c5d055cd9f66b0f", "html_url": "https://github.com/rust-lang/rust/commit/a8f3877c361f368ee045025f2c5d055cd9f66b0f"}], "stats": {"total": 136, "additions": 4, "deletions": 132}, "files": [{"sha": "09b13db772611106fed2de4757e0b055fafe4444", "filename": "build_sysroot/alloc_system/Cargo.toml", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b36fd9d82b645d67282eda2ca6bbcb09eca5163f/build_sysroot%2Falloc_system%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/b36fd9d82b645d67282eda2ca6bbcb09eca5163f/build_sysroot%2Falloc_system%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/build_sysroot%2Falloc_system%2FCargo.toml?ref=b36fd9d82b645d67282eda2ca6bbcb09eca5163f", "patch": "@@ -2,11 +2,13 @@\n authors = [\"The Rust Project Developers\", \"bjorn3 (edited to be usable outside the rust source)\"]\n name = \"alloc_system\"\n version = \"0.0.0\"\n+\n [lib]\n name = \"alloc_system\"\n path = \"lib.rs\"\n test = false\n doc = false\n+\n [dependencies]\n core = { path = \"../sysroot_src/library/core\" }\n libc = { version = \"0.2.43\", features = ['rustc-dep-of-std'], default-features = false }"}, {"sha": "405ccbae6d62c285c41a37f3b564de55c0038e43", "filename": "build_sysroot/alloc_system/lib.rs", "status": "modified", "additions": 2, "deletions": 132, "changes": 134, "blob_url": "https://github.com/rust-lang/rust/blob/b36fd9d82b645d67282eda2ca6bbcb09eca5163f/build_sysroot%2Falloc_system%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b36fd9d82b645d67282eda2ca6bbcb09eca5163f/build_sysroot%2Falloc_system%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/build_sysroot%2Falloc_system%2Flib.rs?ref=b36fd9d82b645d67282eda2ca6bbcb09eca5163f", "patch": "@@ -8,66 +8,24 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n #![no_std]\n-#![allow(unused_attributes)]\n-#![unstable(feature = \"alloc_system\",\n-            reason = \"this library is unlikely to be stabilized in its current \\\n-                      form or name\",\n-            issue = \"32838\")]\n #![feature(allocator_api)]\n-#![feature(core_intrinsics)]\n-#![feature(nll)]\n-#![feature(staged_api)]\n-#![feature(rustc_attrs)]\n-#![feature(alloc_layout_extra)]\n-#![cfg_attr(\n-    all(target_arch = \"wasm32\", not(target_os = \"emscripten\")),\n-    feature(integer_atomics, stdsimd)\n-)]\n #![cfg_attr(any(unix, target_os = \"redox\"), feature(libc))]\n+\n // The minimum alignment guaranteed by the architecture. This value is used to\n // add fast paths for low alignment values.\n #[cfg(all(any(target_arch = \"x86\",\n               target_arch = \"arm\",\n               target_arch = \"mips\",\n               target_arch = \"powerpc\",\n-              target_arch = \"powerpc64\",\n-              target_arch = \"asmjs\",\n-              target_arch = \"wasm32\")))]\n-#[allow(dead_code)]\n+              target_arch = \"powerpc64\")))]\n const MIN_ALIGN: usize = 8;\n #[cfg(all(any(target_arch = \"x86_64\",\n               target_arch = \"aarch64\",\n               target_arch = \"mips64\",\n               target_arch = \"s390x\",\n               target_arch = \"sparc64\")))]\n-#[allow(dead_code)]\n const MIN_ALIGN: usize = 16;\n \n-/// The default memory allocator provided by the operating system.\n-///\n-/// This is based on `malloc` on Unix platforms and `HeapAlloc` on Windows,\n-/// plus related functions.\n-///\n-/// This type can be used in a `static` item\n-/// with the `#[global_allocator]` attribute\n-/// to force the global allocator to be the system\u2019s one.\n-/// (The default is jemalloc for executables, on some platforms.)\n-///\n-/// ```rust\n-/// use std::alloc::System;\n-///\n-/// #[global_allocator]\n-/// static A: System = System;\n-///\n-/// fn main() {\n-///     let a = Box::new(4); // Allocates from the system allocator.\n-///     println!(\"{}\", a);\n-/// }\n-/// ```\n-///\n-/// It can also be used directly to allocate memory\n-/// independently of the standard library\u2019s global allocator.\n-#[stable(feature = \"alloc_system_type\", since = \"1.28.0\")]\n pub struct System;\n #[cfg(any(windows, unix, target_os = \"redox\"))]\n mod realloc_fallback {\n@@ -96,7 +54,6 @@ mod platform {\n     use MIN_ALIGN;\n     use System;\n     use core::alloc::{GlobalAlloc, Layout};\n-    #[stable(feature = \"alloc_system_type\", since = \"1.28.0\")]\n     unsafe impl GlobalAlloc for System {\n         #[inline]\n         unsafe fn alloc(&self, layout: Layout) -> *mut u8 {\n@@ -221,7 +178,6 @@ mod platform {\n         };\n         ptr as *mut u8\n     }\n-    #[stable(feature = \"alloc_system_type\", since = \"1.28.0\")]\n     unsafe impl GlobalAlloc for System {\n         #[inline]\n         unsafe fn alloc(&self, layout: Layout) -> *mut u8 {\n@@ -254,89 +210,3 @@ mod platform {\n         }\n     }\n }\n-// This is an implementation of a global allocator on the wasm32 platform when\n-// emscripten is not in use. In that situation there's no actual runtime for us\n-// to lean on for allocation, so instead we provide our own!\n-//\n-// The wasm32 instruction set has two instructions for getting the current\n-// amount of memory and growing the amount of memory. These instructions are the\n-// foundation on which we're able to build an allocator, so we do so! Note that\n-// the instructions are also pretty \"global\" and this is the \"global\" allocator\n-// after all!\n-//\n-// The current allocator here is the `dlmalloc` crate which we've got included\n-// in the rust-lang/rust repository as a submodule. The crate is a port of\n-// dlmalloc.c from C to Rust and is basically just so we can have \"pure Rust\"\n-// for now which is currently technically required (can't link with C yet).\n-//\n-// The crate itself provides a global allocator which on wasm has no\n-// synchronization as there are no threads!\n-#[cfg(all(target_arch = \"wasm32\", not(target_os = \"emscripten\")))]\n-mod platform {\n-    extern crate dlmalloc;\n-    use core::alloc::{GlobalAlloc, Layout};\n-    use System;\n-    static mut DLMALLOC: dlmalloc::Dlmalloc = dlmalloc::DLMALLOC_INIT;\n-    #[stable(feature = \"alloc_system_type\", since = \"1.28.0\")]\n-    unsafe impl GlobalAlloc for System {\n-        #[inline]\n-        unsafe fn alloc(&self, layout: Layout) -> *mut u8 {\n-            let _lock = lock::lock();\n-            DLMALLOC.malloc(layout.size(), layout.align())\n-        }\n-        #[inline]\n-        unsafe fn alloc_zeroed(&self, layout: Layout) -> *mut u8 {\n-            let _lock = lock::lock();\n-            DLMALLOC.calloc(layout.size(), layout.align())\n-        }\n-        #[inline]\n-        unsafe fn dealloc(&self, ptr: *mut u8, layout: Layout) {\n-            let _lock = lock::lock();\n-            DLMALLOC.free(ptr, layout.size(), layout.align())\n-        }\n-        #[inline]\n-        unsafe fn realloc(&self, ptr: *mut u8, layout: Layout, new_size: usize) -> *mut u8 {\n-            let _lock = lock::lock();\n-            DLMALLOC.realloc(ptr, layout.size(), layout.align(), new_size)\n-        }\n-    }\n-    #[cfg(target_feature = \"atomics\")]\n-    mod lock {\n-        use core::arch::wasm32;\n-        use core::sync::atomic::{AtomicI32, Ordering::SeqCst};\n-        static LOCKED: AtomicI32 = AtomicI32::new(0);\n-        pub struct DropLock;\n-        pub fn lock() -> DropLock {\n-            loop {\n-                if LOCKED.swap(1, SeqCst) == 0 {\n-                    return DropLock\n-                }\n-                unsafe {\n-                    let r = wasm32::atomic::wait_i32(\n-                        &LOCKED as *const AtomicI32 as *mut i32,\n-                        1,  // expected value\n-                        -1, // timeout\n-                    );\n-                    debug_assert!(r == 0 || r == 1);\n-                }\n-            }\n-        }\n-        impl Drop for DropLock {\n-            fn drop(&mut self) {\n-                let r = LOCKED.swap(0, SeqCst);\n-                debug_assert_eq!(r, 1);\n-                unsafe {\n-                    wasm32::atomic::wake(\n-                        &LOCKED as *const AtomicI32 as *mut i32,\n-                        1, // only one thread\n-                    );\n-                }\n-            }\n-        }\n-    }\n-    #[cfg(not(target_feature = \"atomics\"))]\n-    mod lock {\n-        #[inline]\n-        pub fn lock() {} // no atomics, no threads, that's easy!\n-    }\n-}"}]}