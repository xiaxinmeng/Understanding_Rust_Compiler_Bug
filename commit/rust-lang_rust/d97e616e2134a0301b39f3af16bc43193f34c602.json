{"sha": "d97e616e2134a0301b39f3af16bc43193f34c602", "node_id": "C_kwDOAAsO6NoAKGQ5N2U2MTZlMjEzNGEwMzAxYjM5ZjNhZjE2YmM0MzE5M2YzNGM2MDI", "commit": {"author": {"name": "Michael Goulet", "email": "michael@errs.io", "date": "2022-08-26T22:56:28Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2022-08-26T22:56:28Z"}, "message": "Rollup merge of #100836 - hampuslidin:migrate-attr-crate-diagnostics, r=davidtwco\n\nMigrate `rustc_attr` crate diagnostics\n\nHi!\n\nThis is my first PR to the rustc project, excited to be part of the development! This PR is part of the diagnostics effort, to make diagnostics translatable.\n\n`@rustbot` label +A-translation", "tree": {"sha": "99a02e7521769ccfbb92108569aa2f82ac475d85", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/99a02e7521769ccfbb92108569aa2f82ac475d85"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d97e616e2134a0301b39f3af16bc43193f34c602", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJjCU+cCRBK7hj4Ov3rIwAAAA4IAB06D+EnEql/sBwIFs2sgpmq\nX2sMpJ1zoZb9V6ecqDDGdpNxe+860VuHu36cImna0nHhphoohayNCJba9apTtm4W\n/W8eufovTir9VWs/kbJ6GgOlmAuk352S+YMmDQ5JId8+0PMg/TB2FdQmK5oWoOtf\ngeUpf6xtGgcf9NDHsjrETkDtr1Tba4bEUJjqpaBNcnfSEGDcTilGEuZMR3jXLpzZ\nCTXEhp+7fySLKW0V5H3fe8WzBcS/2Em+S/J7B2yHK5v2cfH50dimcmqKpc6oIH5g\nF+icDbp4Dh8z1R9cz+U0SP1M6cKvpjDjYqPqxjghJ14Ugg5tzVVDsh+ZEYIqkDg=\n=jmpd\n-----END PGP SIGNATURE-----\n", "payload": "tree 99a02e7521769ccfbb92108569aa2f82ac475d85\nparent 54744601bfae6d3e09ea8c958beab8d58e850434\nparent afd34765f6ef42bd3472040933f07dbb56621565\nauthor Michael Goulet <michael@errs.io> 1661554588 -0700\ncommitter GitHub <noreply@github.com> 1661554588 -0700\n\nRollup merge of #100836 - hampuslidin:migrate-attr-crate-diagnostics, r=davidtwco\n\nMigrate `rustc_attr` crate diagnostics\n\nHi!\n\nThis is my first PR to the rustc project, excited to be part of the development! This PR is part of the diagnostics effort, to make diagnostics translatable.\n\n`@rustbot` label +A-translation\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d97e616e2134a0301b39f3af16bc43193f34c602", "html_url": "https://github.com/rust-lang/rust/commit/d97e616e2134a0301b39f3af16bc43193f34c602", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d97e616e2134a0301b39f3af16bc43193f34c602/comments", "author": {"login": "compiler-errors", "id": 3674314, "node_id": "MDQ6VXNlcjM2NzQzMTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/3674314?v=4", "gravatar_id": "", "url": "https://api.github.com/users/compiler-errors", "html_url": "https://github.com/compiler-errors", "followers_url": "https://api.github.com/users/compiler-errors/followers", "following_url": "https://api.github.com/users/compiler-errors/following{/other_user}", "gists_url": "https://api.github.com/users/compiler-errors/gists{/gist_id}", "starred_url": "https://api.github.com/users/compiler-errors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/compiler-errors/subscriptions", "organizations_url": "https://api.github.com/users/compiler-errors/orgs", "repos_url": "https://api.github.com/users/compiler-errors/repos", "events_url": "https://api.github.com/users/compiler-errors/events{/privacy}", "received_events_url": "https://api.github.com/users/compiler-errors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "54744601bfae6d3e09ea8c958beab8d58e850434", "url": "https://api.github.com/repos/rust-lang/rust/commits/54744601bfae6d3e09ea8c958beab8d58e850434", "html_url": "https://github.com/rust-lang/rust/commit/54744601bfae6d3e09ea8c958beab8d58e850434"}, {"sha": "afd34765f6ef42bd3472040933f07dbb56621565", "url": "https://api.github.com/repos/rust-lang/rust/commits/afd34765f6ef42bd3472040933f07dbb56621565", "html_url": "https://github.com/rust-lang/rust/commit/afd34765f6ef42bd3472040933f07dbb56621565"}], "stats": {"total": 838, "additions": 621, "deletions": 217}, "files": [{"sha": "65edab78ce74ece4c3b2cb1098b7db250851346b", "filename": "compiler/rustc_attr/src/builtin.rs", "status": "modified", "additions": 113, "deletions": 217, "changes": 330, "blob_url": "https://github.com/rust-lang/rust/blob/d97e616e2134a0301b39f3af16bc43193f34c602/compiler%2Frustc_attr%2Fsrc%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d97e616e2134a0301b39f3af16bc43193f34c602/compiler%2Frustc_attr%2Fsrc%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_attr%2Fsrc%2Fbuiltin.rs?ref=d97e616e2134a0301b39f3af16bc43193f34c602", "patch": "@@ -3,7 +3,6 @@\n use rustc_ast as ast;\n use rustc_ast::{Attribute, Lit, LitKind, MetaItem, MetaItemKind, NestedMetaItem, NodeId};\n use rustc_ast_pretty::pprust;\n-use rustc_errors::{struct_span_err, Applicability};\n use rustc_feature::{find_gated_cfg, is_builtin_attr_name, Features, GatedCfg};\n use rustc_macros::HashStable_Generic;\n use rustc_session::lint::builtin::UNEXPECTED_CFGS;\n@@ -14,6 +13,8 @@ use rustc_span::hygiene::Transparency;\n use rustc_span::{symbol::sym, symbol::Symbol, Span};\n use std::num::NonZeroU32;\n \n+use crate::session_diagnostics::{self, IncorrectReprFormatGenericCause};\n+\n pub fn is_builtin_attr(attr: &Attribute) -> bool {\n     attr.is_doc_comment() || attr.ident().filter(|ident| is_builtin_attr_name(ident.name)).is_some()\n }\n@@ -25,46 +26,38 @@ enum AttrError {\n     NonIdentFeature,\n     MissingFeature,\n     MultipleStabilityLevels,\n-    UnsupportedLiteral(&'static str, /* is_bytestr */ bool),\n+    UnsupportedLiteral(UnsupportedLiteralReason, /* is_bytestr */ bool),\n+}\n+\n+pub(crate) enum UnsupportedLiteralReason {\n+    Generic,\n+    CfgString,\n+    DeprecatedString,\n+    DeprecatedKvPair,\n }\n \n fn handle_errors(sess: &ParseSess, span: Span, error: AttrError) {\n-    let diag = &sess.span_diagnostic;\n     match error {\n         AttrError::MultipleItem(item) => {\n-            struct_span_err!(diag, span, E0538, \"multiple '{}' items\", item).emit();\n+            sess.emit_err(session_diagnostics::MultipleItem { span, item });\n         }\n         AttrError::UnknownMetaItem(item, expected) => {\n-            let expected = expected.iter().map(|name| format!(\"`{}`\", name)).collect::<Vec<_>>();\n-            struct_span_err!(diag, span, E0541, \"unknown meta item '{}'\", item)\n-                .span_label(span, format!(\"expected one of {}\", expected.join(\", \")))\n-                .emit();\n+            sess.emit_err(session_diagnostics::UnknownMetaItem { span, item, expected });\n         }\n         AttrError::MissingSince => {\n-            struct_span_err!(diag, span, E0542, \"missing 'since'\").emit();\n+            sess.emit_err(session_diagnostics::MissingSince { span });\n         }\n         AttrError::NonIdentFeature => {\n-            struct_span_err!(diag, span, E0546, \"'feature' is not an identifier\").emit();\n+            sess.emit_err(session_diagnostics::NonIdentFeature { span });\n         }\n         AttrError::MissingFeature => {\n-            struct_span_err!(diag, span, E0546, \"missing 'feature'\").emit();\n+            sess.emit_err(session_diagnostics::MissingFeature { span });\n         }\n         AttrError::MultipleStabilityLevels => {\n-            struct_span_err!(diag, span, E0544, \"multiple stability levels\").emit();\n+            sess.emit_err(session_diagnostics::MultipleStabilityLevels { span });\n         }\n-        AttrError::UnsupportedLiteral(msg, is_bytestr) => {\n-            let mut err = struct_span_err!(diag, span, E0565, \"{}\", msg);\n-            if is_bytestr {\n-                if let Ok(lint_str) = sess.source_map().span_to_snippet(span) {\n-                    err.span_suggestion(\n-                        span,\n-                        \"consider removing the prefix\",\n-                        &lint_str[1..],\n-                        Applicability::MaybeIncorrect,\n-                    );\n-                }\n-            }\n-            err.emit();\n+        AttrError::UnsupportedLiteral(reason, is_bytestr) => {\n+            sess.emit_err(session_diagnostics::UnsupportedLiteral { span, reason, is_bytestr });\n         }\n     }\n }\n@@ -243,8 +236,6 @@ where\n     let mut promotable = false;\n     let mut allowed_through_unstable_modules = false;\n \n-    let diagnostic = &sess.parse_sess.span_diagnostic;\n-\n     'outer: for attr in attrs_iter {\n         if ![\n             sym::rustc_const_unstable,\n@@ -284,7 +275,7 @@ where\n                     *item = Some(v);\n                     true\n                 } else {\n-                    struct_span_err!(diagnostic, meta.span, E0539, \"incorrect meta item\").emit();\n+                    sess.emit_err(session_diagnostics::IncorrectMetaItem { span: meta.span });\n                     false\n                 }\n             };\n@@ -326,7 +317,7 @@ where\n                             handle_errors(\n                                 &sess.parse_sess,\n                                 meta.span(),\n-                                AttrError::UnsupportedLiteral(\"unsupported literal\", false),\n+                                AttrError::UnsupportedLiteral(UnsupportedLiteralReason::Generic, false),\n                             );\n                             continue 'outer;\n                         };\n@@ -350,39 +341,28 @@ where\n                                 // is a name/value pair string literal.\n                                 issue_num = match issue.unwrap().as_str() {\n                                     \"none\" => None,\n-                                    issue => {\n-                                        let emit_diag = |msg: &str| {\n-                                            struct_span_err!(\n-                                                diagnostic,\n-                                                mi.span,\n-                                                E0545,\n-                                                \"`issue` must be a non-zero numeric string \\\n-                                                or \\\"none\\\"\",\n-                                            )\n-                                            .span_label(mi.name_value_literal_span().unwrap(), msg)\n-                                            .emit();\n-                                        };\n-                                        match issue.parse() {\n-                                            Ok(0) => {\n-                                                emit_diag(\n-                                                    \"`issue` must not be \\\"0\\\", \\\n-                                                    use \\\"none\\\" instead\",\n-                                                );\n-                                                continue 'outer;\n-                                            }\n-                                            Ok(num) => NonZeroU32::new(num),\n-                                            Err(err) => {\n-                                                emit_diag(&err.to_string());\n-                                                continue 'outer;\n-                                            }\n+                                    issue => match issue.parse::<NonZeroU32>() {\n+                                        Ok(num) => Some(num),\n+                                        Err(err) => {\n+                                            sess.emit_err(\n+                                                session_diagnostics::InvalidIssueString {\n+                                                    span: mi.span,\n+                                                    cause: session_diagnostics::InvalidIssueStringCause::from_int_error_kind(\n+                                                        mi.name_value_literal_span().unwrap(),\n+                                                        err.kind(),\n+                                                    ),\n+                                                },\n+                                            );\n+                                            continue 'outer;\n                                         }\n-                                    }\n+                                    },\n                                 };\n                             }\n                             sym::soft => {\n                                 if !mi.is_word() {\n-                                    let msg = \"`soft` should not have any arguments\";\n-                                    sess.parse_sess.span_diagnostic.span_err(mi.span, msg);\n+                                    sess.emit_err(session_diagnostics::SoftNoArgs {\n+                                        span: mi.span,\n+                                    });\n                                 }\n                                 is_soft = true;\n                             }\n@@ -440,8 +420,7 @@ where\n                             continue;\n                         }\n                         _ => {\n-                            struct_span_err!(diagnostic, attr.span, E0547, \"missing 'issue'\")\n-                                .emit();\n+                            sess.emit_err(session_diagnostics::MissingIssue { span: attr.span });\n                             continue;\n                         }\n                     }\n@@ -494,7 +473,10 @@ where\n                                 handle_errors(\n                                     &sess.parse_sess,\n                                     lit.span,\n-                                    AttrError::UnsupportedLiteral(\"unsupported literal\", false),\n+                                    AttrError::UnsupportedLiteral(\n+                                        UnsupportedLiteralReason::Generic,\n+                                        false,\n+                                    ),\n                                 );\n                                 continue 'outer;\n                             }\n@@ -533,14 +515,7 @@ where\n         if let Some((ref mut stab, _)) = const_stab {\n             stab.promotable = promotable;\n         } else {\n-            struct_span_err!(\n-                diagnostic,\n-                item_sp,\n-                E0717,\n-                \"`rustc_promotable` attribute must be paired with either a `rustc_const_unstable` \\\n-                or a `rustc_const_stable` attribute\"\n-            )\n-            .emit();\n+            sess.emit_err(session_diagnostics::RustcPromotablePairing { span: item_sp });\n         }\n     }\n \n@@ -555,13 +530,7 @@ where\n         {\n             *allowed_through_unstable_modules = true;\n         } else {\n-            struct_span_err!(\n-                diagnostic,\n-                item_sp,\n-                E0789,\n-                \"`rustc_allowed_through_unstable_modules` attribute must be paired with a `stable` attribute\"\n-            )\n-            .emit();\n+            sess.emit_err(session_diagnostics::RustcAllowedUnstablePairing { span: item_sp });\n         }\n     }\n \n@@ -675,25 +644,18 @@ pub fn eval_condition(\n                     NestedMetaItem::Literal(Lit { span, .. })\n                     | NestedMetaItem::MetaItem(MetaItem { span, .. }),\n                 ] => {\n-                    sess.span_diagnostic\n-                        .struct_span_err(*span, \"expected a version literal\")\n-                        .emit();\n+                    sess.emit_err(session_diagnostics::ExpectedVersionLiteral { span: *span });\n                     return false;\n                 }\n                 [..] => {\n-                    sess.span_diagnostic\n-                        .struct_span_err(cfg.span, \"expected single version literal\")\n-                        .emit();\n+                    sess.emit_err(session_diagnostics::ExpectedSingleVersionLiteral {\n+                        span: cfg.span,\n+                    });\n                     return false;\n                 }\n             };\n             let Some(min_version) = parse_version(min_version.as_str(), false) else {\n-                sess.span_diagnostic\n-                    .struct_span_warn(\n-                        *span,\n-                        \"unknown version literal format, assuming it refers to a future version\",\n-                    )\n-                    .emit();\n+                sess.emit_warning(session_diagnostics::UnknownVersionLiteral { span: *span });\n                 return false;\n             };\n             let rustc_version = parse_version(env!(\"CFG_RELEASE\"), true).unwrap();\n@@ -711,7 +673,7 @@ pub fn eval_condition(\n                     handle_errors(\n                         sess,\n                         mi.span(),\n-                        AttrError::UnsupportedLiteral(\"unsupported literal\", false),\n+                        AttrError::UnsupportedLiteral(UnsupportedLiteralReason::Generic, false),\n                     );\n                     return false;\n                 }\n@@ -736,13 +698,9 @@ pub fn eval_condition(\n                     }),\n                 sym::not => {\n                     if mis.len() != 1 {\n-                        struct_span_err!(\n-                            sess.span_diagnostic,\n-                            cfg.span,\n-                            E0536,\n-                            \"expected 1 cfg-pattern\"\n-                        )\n-                        .emit();\n+                        sess.emit_err(session_diagnostics::ExpectedOneCfgPattern {\n+                            span: cfg.span,\n+                        });\n                         return false;\n                     }\n \n@@ -768,29 +726,24 @@ pub fn eval_condition(\n                     })\n                 }\n                 _ => {\n-                    struct_span_err!(\n-                        sess.span_diagnostic,\n-                        cfg.span,\n-                        E0537,\n-                        \"invalid predicate `{}`\",\n-                        pprust::path_to_string(&cfg.path)\n-                    )\n-                    .emit();\n+                    sess.emit_err(session_diagnostics::InvalidPredicate {\n+                        span: cfg.span,\n+                        predicate: pprust::path_to_string(&cfg.path),\n+                    });\n                     false\n                 }\n             }\n         }\n         ast::MetaItemKind::Word | MetaItemKind::NameValue(..) if cfg.path.segments.len() != 1 => {\n-            sess.span_diagnostic\n-                .span_err(cfg.path.span, \"`cfg` predicate key must be an identifier\");\n+            sess.emit_err(session_diagnostics::CfgPredicateIdentifier { span: cfg.path.span });\n             true\n         }\n         MetaItemKind::NameValue(ref lit) if !lit.kind.is_str() => {\n             handle_errors(\n                 sess,\n                 lit.span,\n                 AttrError::UnsupportedLiteral(\n-                    \"literal in `cfg` predicate value must be a string\",\n+                    UnsupportedLiteralReason::CfgString,\n                     lit.kind.is_bytestr(),\n                 ),\n             );\n@@ -834,7 +787,6 @@ where\n     I: Iterator<Item = &'a Attribute>,\n {\n     let mut depr: Option<(Deprecation, Span)> = None;\n-    let diagnostic = &sess.parse_sess.span_diagnostic;\n     let is_rustc = sess.features_untracked().staged_api;\n \n     'outer: for attr in attrs_iter {\n@@ -870,14 +822,14 @@ where\n                                 &sess.parse_sess,\n                                 lit.span,\n                                 AttrError::UnsupportedLiteral(\n-                                    \"literal in `deprecated` \\\n-                                    value must be a string\",\n+                                    UnsupportedLiteralReason::DeprecatedString,\n                                     lit.kind.is_bytestr(),\n                                 ),\n                             );\n                         } else {\n-                            struct_span_err!(diagnostic, meta.span, E0551, \"incorrect meta item\")\n-                                .emit();\n+                            sess.emit_err(session_diagnostics::IncorrectMetaItem2 {\n+                                span: meta.span,\n+                            });\n                         }\n \n                         false\n@@ -899,14 +851,11 @@ where\n                             }\n                             sym::suggestion => {\n                                 if !sess.features_untracked().deprecated_suggestion {\n-                                    let mut diag = sess.struct_span_err(\n-                                        mi.span,\n-                                        \"suggestions on deprecated items are unstable\",\n-                                    );\n-                                    if sess.is_nightly_build() {\n-                                        diag.help(\"add `#![feature(deprecated_suggestion)]` to the crate root\");\n-                                    }\n-                                    diag.note(\"see #94785 for more details\").emit();\n+                                    sess.emit_err(session_diagnostics::DeprecatedItemSuggestion {\n+                                        span: mi.span,\n+                                        is_nightly: sess.is_nightly_build().then_some(()),\n+                                        details: (),\n+                                    });\n                                 }\n \n                                 if !get(mi, &mut suggestion) {\n@@ -934,7 +883,7 @@ where\n                                 &sess.parse_sess,\n                                 lit.span,\n                                 AttrError::UnsupportedLiteral(\n-                                    \"item in `deprecated` must be a key/value pair\",\n+                                    UnsupportedLiteralReason::DeprecatedKvPair,\n                                     false,\n                                 ),\n                             );\n@@ -952,7 +901,7 @@ where\n             }\n \n             if note.is_none() {\n-                struct_span_err!(diagnostic, attr.span, E0543, \"missing 'note'\").emit();\n+                sess.emit_err(session_diagnostics::MissingNote { span: attr.span });\n                 continue;\n             }\n         }\n@@ -1022,19 +971,9 @@ pub fn parse_repr_attr(sess: &Session, attr: &Attribute) -> Vec<ReprAttr> {\n                     sym::simd => Some(ReprSimd),\n                     sym::transparent => Some(ReprTransparent),\n                     sym::align => {\n-                        let mut err = struct_span_err!(\n-                            diagnostic,\n-                            item.span(),\n-                            E0589,\n-                            \"invalid `repr(align)` attribute: `align` needs an argument\"\n-                        );\n-                        err.span_suggestion(\n-                            item.span(),\n-                            \"supply an argument here\",\n-                            \"align(...)\",\n-                            Applicability::HasPlaceholders,\n-                        );\n-                        err.emit();\n+                        sess.emit_err(session_diagnostics::InvalidReprAlignNeedArg {\n+                            span: item.span(),\n+                        });\n                         recognised = true;\n                         None\n                     }\n@@ -1063,109 +1002,66 @@ pub fn parse_repr_attr(sess: &Session, attr: &Attribute) -> Vec<ReprAttr> {\n                     || int_type_of_word(name).is_some()\n                 {\n                     recognised = true;\n-                    struct_span_err!(\n-                                diagnostic,\n-                                item.span(),\n-                                E0552,\n-                                \"invalid representation hint: `{}` does not take a parenthesized argument list\",\n-                                name.to_ident_string(),\n-                            ).emit();\n+                    sess.emit_err(session_diagnostics::InvalidReprHintNoParen {\n+                        span: item.span(),\n+                        name: name.to_ident_string(),\n+                    });\n                 }\n                 if let Some(literal_error) = literal_error {\n-                    struct_span_err!(\n-                        diagnostic,\n-                        item.span(),\n-                        E0589,\n-                        \"invalid `repr({})` attribute: {}\",\n-                        name.to_ident_string(),\n-                        literal_error\n-                    )\n-                    .emit();\n+                    sess.emit_err(session_diagnostics::InvalidReprGeneric {\n+                        span: item.span(),\n+                        repr_arg: name.to_ident_string(),\n+                        error_part: literal_error,\n+                    });\n                 }\n             } else if let Some(meta_item) = item.meta_item() {\n                 if let MetaItemKind::NameValue(ref value) = meta_item.kind {\n                     if meta_item.has_name(sym::align) || meta_item.has_name(sym::packed) {\n                         let name = meta_item.name_or_empty().to_ident_string();\n                         recognised = true;\n-                        let mut err = struct_span_err!(\n-                            diagnostic,\n-                            item.span(),\n-                            E0693,\n-                            \"incorrect `repr({})` attribute format\",\n-                            name,\n-                        );\n-                        match value.kind {\n-                            ast::LitKind::Int(int, ast::LitIntType::Unsuffixed) => {\n-                                err.span_suggestion(\n-                                    item.span(),\n-                                    \"use parentheses instead\",\n-                                    format!(\"{}({})\", name, int),\n-                                    Applicability::MachineApplicable,\n-                                );\n-                            }\n-                            ast::LitKind::Str(s, _) => {\n-                                err.span_suggestion(\n-                                    item.span(),\n-                                    \"use parentheses instead\",\n-                                    format!(\"{}({})\", name, s),\n-                                    Applicability::MachineApplicable,\n-                                );\n-                            }\n-                            _ => {}\n-                        }\n-                        err.emit();\n+                        sess.emit_err(session_diagnostics::IncorrectReprFormatGeneric {\n+                            span: item.span(),\n+                            repr_arg: &name,\n+                            cause: IncorrectReprFormatGenericCause::from_lit_kind(\n+                                item.span(),\n+                                &value.kind,\n+                                &name,\n+                            ),\n+                        });\n                     } else {\n                         if matches!(\n                             meta_item.name_or_empty(),\n                             sym::C | sym::simd | sym::transparent\n                         ) || int_type_of_word(meta_item.name_or_empty()).is_some()\n                         {\n                             recognised = true;\n-                            struct_span_err!(\n-                                diagnostic,\n-                                meta_item.span,\n-                                E0552,\n-                                \"invalid representation hint: `{}` does not take a value\",\n-                                meta_item.name_or_empty().to_ident_string(),\n-                            )\n-                            .emit();\n+                            sess.emit_err(session_diagnostics::InvalidReprHintNoValue {\n+                                span: meta_item.span,\n+                                name: meta_item.name_or_empty().to_ident_string(),\n+                            });\n                         }\n                     }\n                 } else if let MetaItemKind::List(_) = meta_item.kind {\n                     if meta_item.has_name(sym::align) {\n                         recognised = true;\n-                        struct_span_err!(\n-                            diagnostic,\n-                            meta_item.span,\n-                            E0693,\n-                            \"incorrect `repr(align)` attribute format: \\\n-                                 `align` takes exactly one argument in parentheses\"\n-                        )\n-                        .emit();\n+                        sess.emit_err(session_diagnostics::IncorrectReprFormatAlignOneArg {\n+                            span: meta_item.span,\n+                        });\n                     } else if meta_item.has_name(sym::packed) {\n                         recognised = true;\n-                        struct_span_err!(\n-                            diagnostic,\n-                            meta_item.span,\n-                            E0552,\n-                            \"incorrect `repr(packed)` attribute format: \\\n-                                 `packed` takes exactly one parenthesized argument, \\\n-                                 or no parentheses at all\"\n-                        )\n-                        .emit();\n+                        sess.emit_err(session_diagnostics::IncorrectReprFormatPackedOneOrZeroArg {\n+                            span: meta_item.span,\n+                        });\n                     } else if matches!(\n                         meta_item.name_or_empty(),\n                         sym::C | sym::simd | sym::transparent\n                     ) || int_type_of_word(meta_item.name_or_empty()).is_some()\n                     {\n                         recognised = true;\n-                        struct_span_err!(\n-                                diagnostic,\n-                                meta_item.span,\n-                                E0552,\n-                                \"invalid representation hint: `{}` does not take a parenthesized argument list\",\n-                                meta_item.name_or_empty().to_ident_string(),\n-                            ).emit();\n+                        sess.emit_err(session_diagnostics::InvalidReprHintNoParen {\n+                            span: meta_item.span,\n+                            name: meta_item.name_or_empty().to_ident_string(),\n+                        });\n                     }\n                 }\n             }\n@@ -1262,10 +1158,10 @@ fn allow_unstable<'a>(\n     let list = attrs\n         .filter_map(move |attr| {\n             attr.meta_item_list().or_else(|| {\n-                sess.diagnostic().span_err(\n-                    attr.span,\n-                    &format!(\"`{}` expects a list of feature names\", symbol.to_ident_string()),\n-                );\n+                sess.emit_err(session_diagnostics::ExpectsFeatureList {\n+                    span: attr.span,\n+                    name: symbol.to_ident_string(),\n+                });\n                 None\n             })\n         })\n@@ -1274,10 +1170,10 @@ fn allow_unstable<'a>(\n     list.into_iter().filter_map(move |it| {\n         let name = it.ident().map(|ident| ident.name);\n         if name.is_none() {\n-            sess.diagnostic().span_err(\n-                it.span(),\n-                &format!(\"`{}` expects feature names\", symbol.to_ident_string()),\n-            );\n+            sess.emit_err(session_diagnostics::ExpectsFeatures {\n+                span: it.span(),\n+                name: symbol.to_ident_string(),\n+            });\n         }\n         name\n     })"}, {"sha": "3a43f1aad02d63c40262b5c2f38640014669ef74", "filename": "compiler/rustc_attr/src/lib.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/d97e616e2134a0301b39f3af16bc43193f34c602/compiler%2Frustc_attr%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d97e616e2134a0301b39f3af16bc43193f34c602/compiler%2Frustc_attr%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_attr%2Fsrc%2Flib.rs?ref=d97e616e2134a0301b39f3af16bc43193f34c602", "patch": "@@ -5,11 +5,14 @@\n //! to this crate.\n \n #![feature(let_else)]\n+#![deny(rustc::untranslatable_diagnostic)]\n+#![deny(rustc::diagnostic_outside_of_impl)]\n \n #[macro_use]\n extern crate rustc_macros;\n \n mod builtin;\n+mod session_diagnostics;\n \n pub use builtin::*;\n pub use IntType::*;"}, {"sha": "a75e7409fba18ce9b1b6eb6fa9418095bc6d91da", "filename": "compiler/rustc_attr/src/session_diagnostics.rs", "status": "added", "additions": 397, "deletions": 0, "changes": 397, "blob_url": "https://github.com/rust-lang/rust/blob/d97e616e2134a0301b39f3af16bc43193f34c602/compiler%2Frustc_attr%2Fsrc%2Fsession_diagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d97e616e2134a0301b39f3af16bc43193f34c602/compiler%2Frustc_attr%2Fsrc%2Fsession_diagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_attr%2Fsrc%2Fsession_diagnostics.rs?ref=d97e616e2134a0301b39f3af16bc43193f34c602", "patch": "@@ -0,0 +1,397 @@\n+use std::num::IntErrorKind;\n+\n+use rustc_ast as ast;\n+use rustc_errors::{error_code, fluent, Applicability, DiagnosticBuilder, ErrorGuaranteed};\n+use rustc_macros::SessionDiagnostic;\n+use rustc_session::{parse::ParseSess, SessionDiagnostic};\n+use rustc_span::{Span, Symbol};\n+\n+use crate::UnsupportedLiteralReason;\n+\n+#[derive(SessionDiagnostic)]\n+#[diag(attr::expected_one_cfg_pattern, code = \"E0536\")]\n+pub(crate) struct ExpectedOneCfgPattern {\n+    #[primary_span]\n+    pub span: Span,\n+}\n+\n+#[derive(SessionDiagnostic)]\n+#[diag(attr::invalid_predicate, code = \"E0537\")]\n+pub(crate) struct InvalidPredicate {\n+    #[primary_span]\n+    pub span: Span,\n+\n+    pub predicate: String,\n+}\n+\n+#[derive(SessionDiagnostic)]\n+#[diag(attr::multiple_item, code = \"E0538\")]\n+pub(crate) struct MultipleItem {\n+    #[primary_span]\n+    pub span: Span,\n+\n+    pub item: String,\n+}\n+\n+#[derive(SessionDiagnostic)]\n+#[diag(attr::incorrect_meta_item, code = \"E0539\")]\n+pub(crate) struct IncorrectMetaItem {\n+    #[primary_span]\n+    pub span: Span,\n+}\n+\n+// Error code: E0541\n+pub(crate) struct UnknownMetaItem<'a> {\n+    pub span: Span,\n+    pub item: String,\n+    pub expected: &'a [&'a str],\n+}\n+\n+// Manual implementation to be able to format `expected` items correctly.\n+impl<'a> SessionDiagnostic<'a> for UnknownMetaItem<'_> {\n+    fn into_diagnostic(self, sess: &'a ParseSess) -> DiagnosticBuilder<'a, ErrorGuaranteed> {\n+        let expected = self.expected.iter().map(|name| format!(\"`{}`\", name)).collect::<Vec<_>>();\n+        let mut diag = sess.span_diagnostic.struct_span_err_with_code(\n+            self.span,\n+            fluent::attr::unknown_meta_item,\n+            error_code!(E0541),\n+        );\n+        diag.set_arg(\"item\", self.item);\n+        diag.set_arg(\"expected\", expected.join(\", \"));\n+        diag.span_label(self.span, fluent::attr::label);\n+        diag\n+    }\n+}\n+\n+#[derive(SessionDiagnostic)]\n+#[diag(attr::missing_since, code = \"E0542\")]\n+pub(crate) struct MissingSince {\n+    #[primary_span]\n+    pub span: Span,\n+}\n+\n+#[derive(SessionDiagnostic)]\n+#[diag(attr::missing_note, code = \"E0543\")]\n+pub(crate) struct MissingNote {\n+    #[primary_span]\n+    pub span: Span,\n+}\n+\n+#[derive(SessionDiagnostic)]\n+#[diag(attr::multiple_stability_levels, code = \"E0544\")]\n+pub(crate) struct MultipleStabilityLevels {\n+    #[primary_span]\n+    pub span: Span,\n+}\n+\n+#[derive(SessionDiagnostic)]\n+#[diag(attr::invalid_issue_string, code = \"E0545\")]\n+pub(crate) struct InvalidIssueString {\n+    #[primary_span]\n+    pub span: Span,\n+\n+    #[subdiagnostic]\n+    pub cause: Option<InvalidIssueStringCause>,\n+}\n+\n+// The error kinds of `IntErrorKind` are duplicated here in order to allow the messages to be\n+// translatable.\n+#[derive(SessionSubdiagnostic)]\n+pub(crate) enum InvalidIssueStringCause {\n+    #[label(attr::must_not_be_zero)]\n+    MustNotBeZero {\n+        #[primary_span]\n+        span: Span,\n+    },\n+\n+    #[label(attr::empty)]\n+    Empty {\n+        #[primary_span]\n+        span: Span,\n+    },\n+\n+    #[label(attr::invalid_digit)]\n+    InvalidDigit {\n+        #[primary_span]\n+        span: Span,\n+    },\n+\n+    #[label(attr::pos_overflow)]\n+    PosOverflow {\n+        #[primary_span]\n+        span: Span,\n+    },\n+\n+    #[label(attr::neg_overflow)]\n+    NegOverflow {\n+        #[primary_span]\n+        span: Span,\n+    },\n+}\n+\n+impl InvalidIssueStringCause {\n+    pub fn from_int_error_kind(span: Span, kind: &IntErrorKind) -> Option<Self> {\n+        match kind {\n+            IntErrorKind::Empty => Some(Self::Empty { span }),\n+            IntErrorKind::InvalidDigit => Some(Self::InvalidDigit { span }),\n+            IntErrorKind::PosOverflow => Some(Self::PosOverflow { span }),\n+            IntErrorKind::NegOverflow => Some(Self::NegOverflow { span }),\n+            IntErrorKind::Zero => Some(Self::MustNotBeZero { span }),\n+            _ => None,\n+        }\n+    }\n+}\n+\n+#[derive(SessionDiagnostic)]\n+#[diag(attr::missing_feature, code = \"E0546\")]\n+pub(crate) struct MissingFeature {\n+    #[primary_span]\n+    pub span: Span,\n+}\n+\n+#[derive(SessionDiagnostic)]\n+#[diag(attr::non_ident_feature, code = \"E0546\")]\n+pub(crate) struct NonIdentFeature {\n+    #[primary_span]\n+    pub span: Span,\n+}\n+\n+#[derive(SessionDiagnostic)]\n+#[diag(attr::missing_issue, code = \"E0547\")]\n+pub(crate) struct MissingIssue {\n+    #[primary_span]\n+    pub span: Span,\n+}\n+\n+// FIXME: This diagnostic is identical to `IncorrectMetaItem`, barring the error code. Consider\n+// changing this to `IncorrectMetaItem`. See #51489.\n+#[derive(SessionDiagnostic)]\n+#[diag(attr::incorrect_meta_item, code = \"E0551\")]\n+pub(crate) struct IncorrectMetaItem2 {\n+    #[primary_span]\n+    pub span: Span,\n+}\n+\n+// FIXME: Why is this the same error code as `InvalidReprHintNoParen` and `InvalidReprHintNoValue`?\n+// It is more similar to `IncorrectReprFormatGeneric`.\n+#[derive(SessionDiagnostic)]\n+#[diag(attr::incorrect_repr_format_packed_one_or_zero_arg, code = \"E0552\")]\n+pub(crate) struct IncorrectReprFormatPackedOneOrZeroArg {\n+    #[primary_span]\n+    pub span: Span,\n+}\n+\n+#[derive(SessionDiagnostic)]\n+#[diag(attr::invalid_repr_hint_no_paren, code = \"E0552\")]\n+pub(crate) struct InvalidReprHintNoParen {\n+    #[primary_span]\n+    pub span: Span,\n+\n+    pub name: String,\n+}\n+\n+#[derive(SessionDiagnostic)]\n+#[diag(attr::invalid_repr_hint_no_value, code = \"E0552\")]\n+pub(crate) struct InvalidReprHintNoValue {\n+    #[primary_span]\n+    pub span: Span,\n+\n+    pub name: String,\n+}\n+\n+// Error code: E0565\n+pub(crate) struct UnsupportedLiteral {\n+    pub span: Span,\n+    pub reason: UnsupportedLiteralReason,\n+    pub is_bytestr: bool,\n+}\n+\n+impl<'a> SessionDiagnostic<'a> for UnsupportedLiteral {\n+    fn into_diagnostic(self, sess: &'a ParseSess) -> DiagnosticBuilder<'a, ErrorGuaranteed> {\n+        let mut diag = sess.span_diagnostic.struct_span_err_with_code(\n+            self.span,\n+            match self.reason {\n+                UnsupportedLiteralReason::Generic => fluent::attr::unsupported_literal_generic,\n+                UnsupportedLiteralReason::CfgString => fluent::attr::unsupported_literal_cfg_string,\n+                UnsupportedLiteralReason::DeprecatedString => {\n+                    fluent::attr::unsupported_literal_deprecated_string\n+                }\n+                UnsupportedLiteralReason::DeprecatedKvPair => {\n+                    fluent::attr::unsupported_literal_deprecated_kv_pair\n+                }\n+            },\n+            error_code!(E0565),\n+        );\n+        if self.is_bytestr {\n+            if let Ok(lint_str) = sess.source_map().span_to_snippet(self.span) {\n+                diag.span_suggestion(\n+                    self.span,\n+                    fluent::attr::unsupported_literal_suggestion,\n+                    &lint_str[1..],\n+                    Applicability::MaybeIncorrect,\n+                );\n+            }\n+        }\n+        diag\n+    }\n+}\n+\n+#[derive(SessionDiagnostic)]\n+#[diag(attr::invalid_repr_align_need_arg, code = \"E0589\")]\n+pub(crate) struct InvalidReprAlignNeedArg {\n+    #[primary_span]\n+    #[suggestion(code = \"align(...)\", applicability = \"has-placeholders\")]\n+    pub span: Span,\n+}\n+\n+#[derive(SessionDiagnostic)]\n+#[diag(attr::invalid_repr_generic, code = \"E0589\")]\n+pub(crate) struct InvalidReprGeneric<'a> {\n+    #[primary_span]\n+    pub span: Span,\n+\n+    pub repr_arg: String,\n+    pub error_part: &'a str,\n+}\n+\n+#[derive(SessionDiagnostic)]\n+#[diag(attr::incorrect_repr_format_align_one_arg, code = \"E0693\")]\n+pub(crate) struct IncorrectReprFormatAlignOneArg {\n+    #[primary_span]\n+    pub span: Span,\n+}\n+\n+#[derive(SessionDiagnostic)]\n+#[diag(attr::incorrect_repr_format_generic, code = \"E0693\")]\n+pub(crate) struct IncorrectReprFormatGeneric<'a> {\n+    #[primary_span]\n+    pub span: Span,\n+\n+    pub repr_arg: &'a str,\n+\n+    #[subdiagnostic]\n+    pub cause: Option<IncorrectReprFormatGenericCause<'a>>,\n+}\n+\n+#[derive(SessionSubdiagnostic)]\n+pub(crate) enum IncorrectReprFormatGenericCause<'a> {\n+    #[suggestion(attr::suggestion, code = \"{name}({int})\", applicability = \"machine-applicable\")]\n+    Int {\n+        #[primary_span]\n+        span: Span,\n+\n+        #[skip_arg]\n+        name: &'a str,\n+\n+        #[skip_arg]\n+        int: u128,\n+    },\n+\n+    #[suggestion(\n+        attr::suggestion,\n+        code = \"{name}({symbol})\",\n+        applicability = \"machine-applicable\"\n+    )]\n+    Symbol {\n+        #[primary_span]\n+        span: Span,\n+\n+        #[skip_arg]\n+        name: &'a str,\n+\n+        #[skip_arg]\n+        symbol: Symbol,\n+    },\n+}\n+\n+impl<'a> IncorrectReprFormatGenericCause<'a> {\n+    pub fn from_lit_kind(span: Span, kind: &ast::LitKind, name: &'a str) -> Option<Self> {\n+        match kind {\n+            ast::LitKind::Int(int, ast::LitIntType::Unsuffixed) => {\n+                Some(Self::Int { span, name, int: *int })\n+            }\n+            ast::LitKind::Str(symbol, _) => Some(Self::Symbol { span, name, symbol: *symbol }),\n+            _ => None,\n+        }\n+    }\n+}\n+\n+#[derive(SessionDiagnostic)]\n+#[diag(attr::rustc_promotable_pairing, code = \"E0717\")]\n+pub(crate) struct RustcPromotablePairing {\n+    #[primary_span]\n+    pub span: Span,\n+}\n+\n+#[derive(SessionDiagnostic)]\n+#[diag(attr::rustc_allowed_unstable_pairing, code = \"E0789\")]\n+pub(crate) struct RustcAllowedUnstablePairing {\n+    #[primary_span]\n+    pub span: Span,\n+}\n+\n+#[derive(SessionDiagnostic)]\n+#[diag(attr::cfg_predicate_identifier)]\n+pub(crate) struct CfgPredicateIdentifier {\n+    #[primary_span]\n+    pub span: Span,\n+}\n+\n+#[derive(SessionDiagnostic)]\n+#[diag(attr::deprecated_item_suggestion)]\n+pub(crate) struct DeprecatedItemSuggestion {\n+    #[primary_span]\n+    pub span: Span,\n+\n+    #[help]\n+    pub is_nightly: Option<()>,\n+\n+    #[note]\n+    pub details: (),\n+}\n+\n+#[derive(SessionDiagnostic)]\n+#[diag(attr::expected_single_version_literal)]\n+pub(crate) struct ExpectedSingleVersionLiteral {\n+    #[primary_span]\n+    pub span: Span,\n+}\n+\n+#[derive(SessionDiagnostic)]\n+#[diag(attr::expected_version_literal)]\n+pub(crate) struct ExpectedVersionLiteral {\n+    #[primary_span]\n+    pub span: Span,\n+}\n+\n+#[derive(SessionDiagnostic)]\n+#[diag(attr::expects_feature_list)]\n+pub(crate) struct ExpectsFeatureList {\n+    #[primary_span]\n+    pub span: Span,\n+\n+    pub name: String,\n+}\n+\n+#[derive(SessionDiagnostic)]\n+#[diag(attr::expects_features)]\n+pub(crate) struct ExpectsFeatures {\n+    #[primary_span]\n+    pub span: Span,\n+\n+    pub name: String,\n+}\n+\n+#[derive(SessionDiagnostic)]\n+#[diag(attr::soft_no_args)]\n+pub(crate) struct SoftNoArgs {\n+    #[primary_span]\n+    pub span: Span,\n+}\n+\n+#[derive(SessionDiagnostic)]\n+#[diag(attr::unknown_version_literal)]\n+pub(crate) struct UnknownVersionLiteral {\n+    #[primary_span]\n+    pub span: Span,\n+}"}, {"sha": "a7f8c993d4225316129e515ef4e2a84bbe872137", "filename": "compiler/rustc_error_messages/locales/en-US/attr.ftl", "status": "added", "additions": 107, "deletions": 0, "changes": 107, "blob_url": "https://github.com/rust-lang/rust/blob/d97e616e2134a0301b39f3af16bc43193f34c602/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fattr.ftl", "raw_url": "https://github.com/rust-lang/rust/raw/d97e616e2134a0301b39f3af16bc43193f34c602/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fattr.ftl", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fattr.ftl?ref=d97e616e2134a0301b39f3af16bc43193f34c602", "patch": "@@ -0,0 +1,107 @@\n+attr_expected_one_cfg_pattern =\n+    expected 1 cfg-pattern\n+\n+attr_invalid_predicate =\n+    invalid predicate `{$predicate}`\n+\n+attr_multiple_item =\n+    multiple '{$item}' items\n+\n+attr_incorrect_meta_item =\n+    incorrect meta item\n+\n+attr_unknown_meta_item =\n+    unknown meta item '{$item}'\n+    .label = expected one of {$expected}\n+\n+attr_missing_since =\n+    missing 'since'\n+\n+attr_missing_note =\n+    missing 'note'\n+\n+attr_multiple_stability_levels =\n+    multiple stability levels\n+\n+attr_invalid_issue_string =\n+    `issue` must be a non-zero numeric string or \"none\"\n+    .must_not_be_zero = `issue` must not be \"0\", use \"none\" instead\n+    .empty = cannot parse integer from empty string\n+    .invalid_digit = invalid digit found in string\n+    .pos_overflow = number too large to fit in target type\n+    .neg_overflow = number too small to fit in target type\n+\n+attr_missing_feature =\n+    missing 'feature'\n+\n+attr_non_ident_feature =\n+    'feature' is not an identifier\n+\n+attr_missing_issue =\n+    missing 'issue'\n+\n+attr_incorrect_repr_format_packed_one_or_zero_arg =\n+    incorrect `repr(packed)` attribute format: `packed` takes exactly one parenthesized argument, or no parentheses at all\n+\n+attr_invalid_repr_hint_no_paren =\n+    invalid representation hint: `{$name}` does not take a parenthesized argument list\n+\n+attr_invalid_repr_hint_no_value =\n+    invalid representation hint: `{$name}` does not take a value\n+\n+attr_unsupported_literal_generic =\n+    unsupported literal\n+attr_unsupported_literal_cfg_string =\n+    literal in `cfg` predicate value must be a string\n+attr_unsupported_literal_deprecated_string =\n+    literal in `deprecated` value must be a string\n+attr_unsupported_literal_deprecated_kv_pair =\n+    item in `deprecated` must be a key/value pair\n+attr_unsupported_literal_suggestion =\n+    consider removing the prefix\n+\n+attr_invalid_repr_align_need_arg =\n+    invalid `repr(align)` attribute: `align` needs an argument\n+    .suggestion = supply an argument here\n+\n+attr_invalid_repr_generic =\n+    invalid `repr({$repr_arg})` attribute: {$error_part}\n+\n+attr_incorrect_repr_format_align_one_arg =\n+    incorrect `repr(align)` attribute format: `align` takes exactly one argument in parentheses\n+\n+attr_incorrect_repr_format_generic =\n+    incorrect `repr({$repr_arg})` attribute format\n+    .suggestion = use parentheses instead\n+\n+attr_rustc_promotable_pairing =\n+    `rustc_promotable` attribute must be paired with either a `rustc_const_unstable` or a `rustc_const_stable` attribute\n+\n+attr_rustc_allowed_unstable_pairing =\n+    `rustc_allowed_through_unstable_modules` attribute must be paired with a `stable` attribute\n+\n+attr_cfg_predicate_identifier =\n+    `cfg` predicate key must be an identifier\n+\n+attr_deprecated_item_suggestion =\n+    suggestions on deprecated items are unstable\n+    .help = add `#![feature(deprecated_suggestion)]` to the crate root\n+    .note = see #94785 for more details\n+\n+attr_expected_single_version_literal =\n+    expected single version literal\n+\n+attr_expected_version_literal =\n+    expected a version literal\n+\n+attr_expects_feature_list =\n+    `{$name}` expects a list of feature names\n+\n+attr_expects_features =\n+    `{$name}` expects feature names\n+\n+attr_soft_no_args =\n+    `soft` should not have any arguments\n+\n+attr_unknown_version_literal =\n+    unknown version literal format, assuming it refers to a future version"}, {"sha": "a3dabde3dbe0f47132faa1a1f71699de23cae193", "filename": "compiler/rustc_error_messages/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/d97e616e2134a0301b39f3af16bc43193f34c602/compiler%2Frustc_error_messages%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d97e616e2134a0301b39f3af16bc43193f34c602/compiler%2Frustc_error_messages%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_error_messages%2Fsrc%2Flib.rs?ref=d97e616e2134a0301b39f3af16bc43193f34c602", "patch": "@@ -34,6 +34,7 @@ pub use unic_langid::{langid, LanguageIdentifier};\n fluent_messages! {\n     ast_lowering => \"../locales/en-US/ast_lowering.ftl\",\n     ast_passes => \"../locales/en-US/ast_passes.ftl\",\n+    attr => \"../locales/en-US/attr.ftl\",\n     borrowck => \"../locales/en-US/borrowck.ftl\",\n     builtin_macros => \"../locales/en-US/builtin_macros.ftl\",\n     const_eval => \"../locales/en-US/const_eval.ftl\","}]}