{"sha": "06985c68592112ef256eb08140f38a30b602d35c", "node_id": "MDY6Q29tbWl0NzI0NzEyOjA2OTg1YzY4NTkyMTEyZWYyNTZlYjA4MTQwZjM4YTMwYjYwMmQzNWM=", "commit": {"author": {"name": "Mazdak Farrokhzad", "email": "twingoow@gmail.com", "date": "2019-12-19T09:30:01Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2019-12-19T09:30:01Z"}, "message": "Rollup merge of #67406 - ohadravid:suggest-assoc-type, r=estebank\n\nSuggest associated type when the specified one cannot be found\n\nFixes #67386, so code like this:\n```\nuse std::ops::Deref;\n\nfn homura<T: Deref<Trget = i32>>(_: T) {}\n\nfn main() {}\n```\n\nresults in:\n```\nerror[E0220]: associated type `Trget` not found for `std::ops::Deref`\n --> type-binding.rs:6:20\n  |\n6 | fn homura<T: Deref<Trget = i32>>(_: T) {}\n  |                    ^^^^^^^^^^^ help: there is an associated type with a similar name: `Target`\n\nerror: aborting due to previous error\n```\n\n(The `help` is new)\n\nI used an `all_candidates: impl Fn() -> Iterator<...>` instead of `collect`ing to avoid the cost of allocating the Vec when no errors are found, at the expense of a little added complexity.\n\nr? @estebank", "tree": {"sha": "9fb998a8d7f0d19bc4ad5a7e37ee1fa694e27de6", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9fb998a8d7f0d19bc4ad5a7e37ee1fa694e27de6"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/06985c68592112ef256eb08140f38a30b602d35c", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJd+0MaCRBK7hj4Ov3rIwAAdHIIAHd9Xy3rcSUClRY5amV0efve\n7Yoy7jQRA2nI/3k93LHL8qtj1wM49e/WXSt1cXHOi7DEiA1G4l9EwzKBsTHDOAzd\nWgtDuLHtd2qdUBs4PWPuFmeq/X1pytWhsq7mEZmOHVPFOwtFfA343VCKfqKtUOCz\nq8YjN59MDTyqbGkMXosxdCgGbAbbA4au0Hydc40pi40NHO48YeIAxVvzmMJk7Ohr\n86KFClaQbitufJny8sflJXGuTu3KDF0H4VLzqw/T1BzqnuZEYX7XWIDTLrPUqhGv\nYxdWq4COC4YhqM8n4mbK65P71TtAjtHeGDcHHs2HKCgrl8uJLZHDVgJT9mKlQZo=\n=PmGb\n-----END PGP SIGNATURE-----\n", "payload": "tree 9fb998a8d7f0d19bc4ad5a7e37ee1fa694e27de6\nparent cfa7581028c182b541917b4ee13af8f639842971\nparent a4a2fc0af33ef5a4e1211c5d3e4f0eeca02322f8\nauthor Mazdak Farrokhzad <twingoow@gmail.com> 1576747801 +0100\ncommitter GitHub <noreply@github.com> 1576747801 +0100\n\nRollup merge of #67406 - ohadravid:suggest-assoc-type, r=estebank\n\nSuggest associated type when the specified one cannot be found\n\nFixes #67386, so code like this:\n```\nuse std::ops::Deref;\n\nfn homura<T: Deref<Trget = i32>>(_: T) {}\n\nfn main() {}\n```\n\nresults in:\n```\nerror[E0220]: associated type `Trget` not found for `std::ops::Deref`\n --> type-binding.rs:6:20\n  |\n6 | fn homura<T: Deref<Trget = i32>>(_: T) {}\n  |                    ^^^^^^^^^^^ help: there is an associated type with a similar name: `Target`\n\nerror: aborting due to previous error\n```\n\n(The `help` is new)\n\nI used an `all_candidates: impl Fn() -> Iterator<...>` instead of `collect`ing to avoid the cost of allocating the Vec when no errors are found, at the expense of a little added complexity.\n\nr? @estebank\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/06985c68592112ef256eb08140f38a30b602d35c", "html_url": "https://github.com/rust-lang/rust/commit/06985c68592112ef256eb08140f38a30b602d35c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/06985c68592112ef256eb08140f38a30b602d35c/comments", "author": {"login": "Centril", "id": 855702, "node_id": "MDQ6VXNlcjg1NTcwMg==", "avatar_url": "https://avatars.githubusercontent.com/u/855702?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Centril", "html_url": "https://github.com/Centril", "followers_url": "https://api.github.com/users/Centril/followers", "following_url": "https://api.github.com/users/Centril/following{/other_user}", "gists_url": "https://api.github.com/users/Centril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Centril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Centril/subscriptions", "organizations_url": "https://api.github.com/users/Centril/orgs", "repos_url": "https://api.github.com/users/Centril/repos", "events_url": "https://api.github.com/users/Centril/events{/privacy}", "received_events_url": "https://api.github.com/users/Centril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "cfa7581028c182b541917b4ee13af8f639842971", "url": "https://api.github.com/repos/rust-lang/rust/commits/cfa7581028c182b541917b4ee13af8f639842971", "html_url": "https://github.com/rust-lang/rust/commit/cfa7581028c182b541917b4ee13af8f639842971"}, {"sha": "a4a2fc0af33ef5a4e1211c5d3e4f0eeca02322f8", "url": "https://api.github.com/repos/rust-lang/rust/commits/a4a2fc0af33ef5a4e1211c5d3e4f0eeca02322f8", "html_url": "https://github.com/rust-lang/rust/commit/a4a2fc0af33ef5a4e1211c5d3e4f0eeca02322f8"}], "stats": {"total": 105, "additions": 73, "deletions": 32}, "files": [{"sha": "290f86d626e6cbf948b4fdbb1ca0f5760bacdc3a", "filename": "src/librustc_typeck/astconv.rs", "status": "modified", "additions": 72, "deletions": 31, "changes": 103, "blob_url": "https://github.com/rust-lang/rust/blob/06985c68592112ef256eb08140f38a30b602d35c/src%2Flibrustc_typeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06985c68592112ef256eb08140f38a30b602d35c/src%2Flibrustc_typeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fastconv.rs?ref=06985c68592112ef256eb08140f38a30b602d35c", "patch": "@@ -1145,11 +1145,8 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n         } else {\n             // Otherwise, we have to walk through the supertraits to find\n             // those that do.\n-            let candidates = traits::supertraits(tcx, trait_ref).filter(|r| {\n-                self.trait_defines_associated_type_named(r.def_id(), binding.item_name)\n-            });\n             self.one_bound_for_assoc_type(\n-                candidates,\n+                || traits::supertraits(tcx, trait_ref),\n                 &trait_ref.print_only_trait_path().to_string(),\n                 binding.item_name,\n                 binding.span\n@@ -1531,50 +1528,48 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n \n         debug!(\"find_bound_for_assoc_item: predicates={:#?}\", predicates);\n \n-        let bounds = predicates.iter().filter_map(|(p, _)| p.to_opt_poly_trait_ref());\n-\n-        // Check that there is exactly one way to find an associated type with the\n-        // correct name.\n-        let suitable_bounds = traits::transitive_bounds(tcx, bounds)\n-            .filter(|b| self.trait_defines_associated_type_named(b.def_id(), assoc_name));\n-\n         let param_hir_id = tcx.hir().as_local_hir_id(ty_param_def_id).unwrap();\n         let param_name = tcx.hir().ty_param_name(param_hir_id);\n-        self.one_bound_for_assoc_type(suitable_bounds,\n-                                      &param_name.as_str(),\n-                                      assoc_name,\n-                                      span)\n+        self.one_bound_for_assoc_type(\n+            || traits::transitive_bounds(tcx, predicates\n+                .iter().filter_map(|(p, _)| p.to_opt_poly_trait_ref())),\n+            &param_name.as_str(),\n+            assoc_name,\n+            span,\n+        )\n     }\n \n-    // Checks that `bounds` contains exactly one element and reports appropriate\n-    // errors otherwise.\n     fn one_bound_for_assoc_type<I>(&self,\n-                                   mut bounds: I,\n+                                   all_candidates: impl Fn() -> I,\n                                    ty_param_name: &str,\n                                    assoc_name: ast::Ident,\n                                    span: Span)\n         -> Result<ty::PolyTraitRef<'tcx>, ErrorReported>\n         where I: Iterator<Item = ty::PolyTraitRef<'tcx>>\n     {\n-        let bound = match bounds.next() {\n+        let mut matching_candidates = all_candidates().filter(|r| {\n+            self.trait_defines_associated_type_named(r.def_id(), assoc_name)\n+        });\n+\n+        let bound = match matching_candidates.next() {\n             Some(bound) => bound,\n             None => {\n-                struct_span_err!(self.tcx().sess, span, E0220,\n-                                 \"associated type `{}` not found for `{}`\",\n-                                 assoc_name,\n-                                 ty_param_name)\n-                    .span_label(span, format!(\"associated type `{}` not found\", assoc_name))\n-                    .emit();\n+                self.complain_about_assoc_type_not_found(\n+                    all_candidates,\n+                    ty_param_name,\n+                    assoc_name,\n+                    span\n+                );\n                 return Err(ErrorReported);\n             }\n         };\n \n         debug!(\"one_bound_for_assoc_type: bound = {:?}\", bound);\n \n-        if let Some(bound2) = bounds.next() {\n+        if let Some(bound2) = matching_candidates.next() {\n             debug!(\"one_bound_for_assoc_type: bound2 = {:?}\", bound2);\n \n-            let bounds = iter::once(bound).chain(iter::once(bound2)).chain(bounds);\n+            let bounds = iter::once(bound).chain(iter::once(bound2)).chain(matching_candidates);\n             let mut err = struct_span_err!(\n                 self.tcx().sess, span, E0221,\n                 \"ambiguous associated type `{}` in bounds of `{}`\",\n@@ -1606,6 +1601,50 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n         return Ok(bound);\n     }\n \n+    fn complain_about_assoc_type_not_found<I>(&self,\n+                                              all_candidates: impl Fn() -> I,\n+                                              ty_param_name: &str,\n+                                              assoc_name: ast::Ident,\n+                                              span: Span)\n+    where I: Iterator<Item = ty::PolyTraitRef<'tcx>> {\n+        let mut err = struct_span_err!(self.tcx().sess, span, E0220,\n+                                 \"associated type `{}` not found for `{}`\",\n+                                 assoc_name,\n+                                 ty_param_name);\n+\n+        let all_candidate_names: Vec<_> = all_candidates()\n+            .map(|r| self.tcx().associated_items(r.def_id()))\n+            .flatten()\n+            .filter_map(|item|\n+                if item.kind == ty::AssocKind::Type {\n+                    Some(item.ident.name)\n+                } else {\n+                    None\n+                }\n+            )\n+            .collect();\n+\n+        if let Some(suggested_name) = find_best_match_for_name(\n+            all_candidate_names.iter(),\n+            &assoc_name.as_str(),\n+            None,\n+        ) {\n+            err.span_suggestion(\n+                span,\n+                \"there is an associated type with a similar name\",\n+                suggested_name.to_string(),\n+                Applicability::MaybeIncorrect,\n+            );\n+        } else {\n+            err.span_label(\n+                span,\n+                format!(\"associated type `{}` not found\", assoc_name)\n+            );\n+        }\n+\n+        err.emit();\n+    }\n+\n     // Create a type from a path to an associated type.\n     // For a path `A::B::C::D`, `qself_ty` and `qself_def` are the type and def for `A::B::C`\n     // and item_segment is the path segment for `D`. We return a type and a def for\n@@ -1660,10 +1699,12 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n                     }\n                 };\n \n-                let candidates = traits::supertraits(tcx, ty::Binder::bind(trait_ref))\n-                    .filter(|r| self.trait_defines_associated_type_named(r.def_id(), assoc_ident));\n-\n-                self.one_bound_for_assoc_type(candidates, \"Self\", assoc_ident, span)?\n+                self.one_bound_for_assoc_type(\n+                    || traits::supertraits(tcx, ty::Binder::bind(trait_ref)),\n+                    \"Self\",\n+                    assoc_ident,\n+                    span\n+                )?\n             }\n             (&ty::Param(_), Res::SelfTy(Some(param_did), None)) |\n             (&ty::Param(_), Res::Def(DefKind::TyParam, param_did)) => {"}, {"sha": "c3e954555325e915bbd692120a391edd7ad410d6", "filename": "src/test/ui/span/type-binding.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/06985c68592112ef256eb08140f38a30b602d35c/src%2Ftest%2Fui%2Fspan%2Ftype-binding.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/06985c68592112ef256eb08140f38a30b602d35c/src%2Ftest%2Fui%2Fspan%2Ftype-binding.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fspan%2Ftype-binding.stderr?ref=06985c68592112ef256eb08140f38a30b602d35c", "patch": "@@ -2,7 +2,7 @@ error[E0220]: associated type `Trget` not found for `std::ops::Deref`\n   --> $DIR/type-binding.rs:6:20\n    |\n LL | fn homura<T: Deref<Trget = i32>>(_: T) {}\n-   |                    ^^^^^^^^^^^ associated type `Trget` not found\n+   |                    ^^^^^^^^^^^ help: there is an associated type with a similar name: `Target`\n \n error: aborting due to previous error\n "}]}