{"sha": "bc82c13e973bddd59a55f2fbff6286b398eb68eb", "node_id": "C_kwDOAAsO6NoAKGJjODJjMTNlOTczYmRkZDU5YTU1ZjJmYmZmNjI4NmIzOThlYjY4ZWI", "commit": {"author": {"name": "Jannis Christopher K\u00f6hl", "email": "mail@koehl.dev", "date": "2022-09-23T13:15:14Z"}, "committer": {"name": "Jannis Christopher K\u00f6hl", "email": "mail@koehl.dev", "date": "2022-11-07T09:35:16Z"}, "message": "Track Scalar instead of ScalarInt for const prop", "tree": {"sha": "9b2c05c09ab4a4cab7072c85e33c6556451746f1", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9b2c05c09ab4a4cab7072c85e33c6556451746f1"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/bc82c13e973bddd59a55f2fbff6286b398eb68eb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/bc82c13e973bddd59a55f2fbff6286b398eb68eb", "html_url": "https://github.com/rust-lang/rust/commit/bc82c13e973bddd59a55f2fbff6286b398eb68eb", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/bc82c13e973bddd59a55f2fbff6286b398eb68eb/comments", "author": {"login": "jachris", "id": 30163784, "node_id": "MDQ6VXNlcjMwMTYzNzg0", "avatar_url": "https://avatars.githubusercontent.com/u/30163784?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jachris", "html_url": "https://github.com/jachris", "followers_url": "https://api.github.com/users/jachris/followers", "following_url": "https://api.github.com/users/jachris/following{/other_user}", "gists_url": "https://api.github.com/users/jachris/gists{/gist_id}", "starred_url": "https://api.github.com/users/jachris/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jachris/subscriptions", "organizations_url": "https://api.github.com/users/jachris/orgs", "repos_url": "https://api.github.com/users/jachris/repos", "events_url": "https://api.github.com/users/jachris/events{/privacy}", "received_events_url": "https://api.github.com/users/jachris/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jachris", "id": 30163784, "node_id": "MDQ6VXNlcjMwMTYzNzg0", "avatar_url": "https://avatars.githubusercontent.com/u/30163784?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jachris", "html_url": "https://github.com/jachris", "followers_url": "https://api.github.com/users/jachris/followers", "following_url": "https://api.github.com/users/jachris/following{/other_user}", "gists_url": "https://api.github.com/users/jachris/gists{/gist_id}", "starred_url": "https://api.github.com/users/jachris/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jachris/subscriptions", "organizations_url": "https://api.github.com/users/jachris/orgs", "repos_url": "https://api.github.com/users/jachris/repos", "events_url": "https://api.github.com/users/jachris/events{/privacy}", "received_events_url": "https://api.github.com/users/jachris/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "817c27744ddd6627dcc05fc35f92534b6be6435b", "url": "https://api.github.com/repos/rust-lang/rust/commits/817c27744ddd6627dcc05fc35f92534b6be6435b", "html_url": "https://github.com/rust-lang/rust/commit/817c27744ddd6627dcc05fc35f92534b6be6435b"}], "stats": {"total": 71, "additions": 29, "deletions": 42}, "files": [{"sha": "334af0c6e8e6b8fdef0d01eacdb65f5fe408a34e", "filename": "compiler/rustc_mir_transform/src/dataflow_const_prop.rs", "status": "modified", "additions": 29, "deletions": 42, "changes": 71, "blob_url": "https://github.com/rust-lang/rust/blob/bc82c13e973bddd59a55f2fbff6286b398eb68eb/compiler%2Frustc_mir_transform%2Fsrc%2Fdataflow_const_prop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc82c13e973bddd59a55f2fbff6286b398eb68eb/compiler%2Frustc_mir_transform%2Fsrc%2Fdataflow_const_prop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Fdataflow_const_prop.rs?ref=bc82c13e973bddd59a55f2fbff6286b398eb68eb", "patch": "@@ -2,7 +2,7 @@ use rustc_const_eval::interpret::{ConstValue, ImmTy, Immediate, InterpCx, Scalar\n use rustc_data_structures::fx::FxHashMap;\n use rustc_middle::mir::visit::{MutVisitor, Visitor};\n use rustc_middle::mir::*;\n-use rustc_middle::ty::{self, ScalarInt, Ty, TyCtxt};\n+use rustc_middle::ty::{self, Ty, TyCtxt};\n use rustc_mir_dataflow::value_analysis::{\n     Map, ProjElem, State, ValueAnalysis, ValueOrPlace, ValueOrPlaceOrRef,\n };\n@@ -43,7 +43,7 @@ struct ConstAnalysis<'tcx> {\n }\n \n impl<'tcx> ValueAnalysis<'tcx> for ConstAnalysis<'tcx> {\n-    type Value = FlatSet<Const<'tcx>>;\n+    type Value = FlatSet<ScalarTy<'tcx>>;\n \n     const NAME: &'static str = \"ConstAnalysis\";\n \n@@ -136,8 +136,7 @@ impl<'tcx> ValueAnalysis<'tcx> for ConstAnalysis<'tcx> {\n             .literal\n             .eval(self.tcx, self.param_env)\n             .try_to_scalar()\n-            .and_then(|scalar| scalar.try_to_int().ok())\n-            .map(|value| FlatSet::Elem(Const::Scalar(value, constant.ty())))\n+            .map(|value| FlatSet::Elem(ScalarTy(value, constant.ty())))\n             .unwrap_or(FlatSet::Top)\n     }\n \n@@ -161,8 +160,9 @@ impl<'tcx> ValueAnalysis<'tcx> for ConstAnalysis<'tcx> {\n                     };\n                     let result = match value {\n                         FlatSet::Top => FlatSet::Top,\n-                        FlatSet::Elem(Const::Scalar(scalar, _)) => {\n-                            FlatSet::Elem(scalar.assert_bits(scalar.size()))\n+                        FlatSet::Elem(ScalarTy(scalar, _)) => {\n+                            let int = scalar.assert_int();\n+                            FlatSet::Elem(int.assert_bits(int.size()))\n                         }\n                         FlatSet::Bottom => FlatSet::Bottom,\n                     };\n@@ -188,18 +188,11 @@ impl<'tcx> ValueAnalysis<'tcx> for ConstAnalysis<'tcx> {\n }\n \n #[derive(Clone, PartialEq, Eq)]\n-enum Const<'tcx> {\n-    // FIXME: If there won't be any other cases, make it a struct.\n-    Scalar(ScalarInt, Ty<'tcx>),\n-}\n+struct ScalarTy<'tcx>(Scalar, Ty<'tcx>);\n \n-impl<'tcx> std::fmt::Debug for Const<'tcx> {\n+impl<'tcx> std::fmt::Debug for ScalarTy<'tcx> {\n     fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n-        match *self {\n-            Self::Scalar(scalar, ty) => {\n-                std::fmt::Display::fmt(&ConstantKind::Val(ConstValue::Scalar(scalar.into()), ty), f)\n-            }\n-        }\n+        std::fmt::Display::fmt(&ConstantKind::Val(ConstValue::Scalar(self.0), self.1), f)\n     }\n }\n \n@@ -215,25 +208,20 @@ impl<'tcx> ConstAnalysis<'tcx> {\n \n     fn binary_op(\n         &self,\n-        state: &mut State<FlatSet<Const<'tcx>>>,\n+        state: &mut State<FlatSet<ScalarTy<'tcx>>>,\n         op: BinOp,\n         left: &Operand<'tcx>,\n         right: &Operand<'tcx>,\n-    ) -> (FlatSet<Const<'tcx>>, FlatSet<Const<'tcx>>) {\n+    ) -> (FlatSet<ScalarTy<'tcx>>, FlatSet<ScalarTy<'tcx>>) {\n         let left = self.eval_operand(left, state);\n         let right = self.eval_operand(right, state);\n         match (left, right) {\n             (FlatSet::Elem(left), FlatSet::Elem(right)) => {\n                 match self.ecx.overflowing_binary_op(op, &left, &right) {\n-                    Ok((val, overflow, ty)) => {\n-                        let val = val\n-                            .try_to_int()\n-                            .ok()\n-                            .map(|val| self.wrap_scalar(val, ty))\n-                            .unwrap_or(FlatSet::Top);\n-                        let overflow = self.wrap_scalar(overflow.into(), self.tcx.types.bool);\n-                        (val, overflow)\n-                    }\n+                    Ok((val, overflow, ty)) => (\n+                        self.wrap_scalar(val, ty),\n+                        self.wrap_scalar(Scalar::from_bool(overflow), self.tcx.types.bool),\n+                    ),\n                     _ => (FlatSet::Top, FlatSet::Top),\n                 }\n             }\n@@ -248,7 +236,7 @@ impl<'tcx> ConstAnalysis<'tcx> {\n     fn eval_operand(\n         &self,\n         op: &Operand<'tcx>,\n-        state: &mut State<FlatSet<Const<'tcx>>>,\n+        state: &mut State<FlatSet<ScalarTy<'tcx>>>,\n     ) -> FlatSet<ImmTy<'tcx>> {\n         let value = match self.handle_operand(op, state) {\n             ValueOrPlace::Value(value) => value,\n@@ -257,57 +245,56 @@ impl<'tcx> ConstAnalysis<'tcx> {\n         };\n         match value {\n             FlatSet::Top => FlatSet::Top,\n-            FlatSet::Elem(Const::Scalar(value, ty)) => {\n+            FlatSet::Elem(ScalarTy(scalar, ty)) => {\n                 let layout = self\n                     .tcx\n                     .layout_of(ty::ParamEnv::empty().and(ty))\n                     .expect(\"this should not happen\"); // FIXME\n-                FlatSet::Elem(ImmTy::from_scalar(value.into(), layout))\n+                FlatSet::Elem(ImmTy::from_scalar(scalar, layout))\n             }\n             FlatSet::Bottom => FlatSet::Bottom,\n         }\n     }\n \n-    fn wrap_scalar(&self, scalar: ScalarInt, ty: Ty<'tcx>) -> FlatSet<Const<'tcx>> {\n-        FlatSet::Elem(Const::Scalar(scalar, ty))\n+    fn wrap_scalar(&self, scalar: Scalar, ty: Ty<'tcx>) -> FlatSet<ScalarTy<'tcx>> {\n+        FlatSet::Elem(ScalarTy(scalar, ty))\n     }\n \n-    fn wrap_immediate(&self, imm: Immediate, ty: Ty<'tcx>) -> FlatSet<Const<'tcx>> {\n+    fn wrap_immediate(&self, imm: Immediate, ty: Ty<'tcx>) -> FlatSet<ScalarTy<'tcx>> {\n         match imm {\n-            Immediate::Scalar(Scalar::Int(scalar)) => self.wrap_scalar(scalar, ty),\n+            Immediate::Scalar(scalar) => self.wrap_scalar(scalar, ty),\n             _ => FlatSet::Top,\n         }\n     }\n \n-    fn wrap_immty(&self, val: ImmTy<'tcx>) -> FlatSet<Const<'tcx>> {\n+    fn wrap_immty(&self, val: ImmTy<'tcx>) -> FlatSet<ScalarTy<'tcx>> {\n         self.wrap_immediate(*val, val.layout.ty)\n     }\n }\n \n struct CollectAndPatch<'tcx, 'map> {\n     tcx: TyCtxt<'tcx>,\n     map: &'map Map,\n-    before_effect: FxHashMap<(Location, Place<'tcx>), Const<'tcx>>,\n-    assignments: FxHashMap<Location, Const<'tcx>>,\n+    before_effect: FxHashMap<(Location, Place<'tcx>), ScalarTy<'tcx>>,\n+    assignments: FxHashMap<Location, ScalarTy<'tcx>>,\n }\n \n impl<'tcx, 'map> CollectAndPatch<'tcx, 'map> {\n     fn new(tcx: TyCtxt<'tcx>, map: &'map Map) -> Self {\n         Self { tcx, map, before_effect: FxHashMap::default(), assignments: FxHashMap::default() }\n     }\n \n-    fn make_operand(&self, constant: Const<'tcx>) -> Operand<'tcx> {\n-        let Const::Scalar(scalar, ty) = constant;\n+    fn make_operand(&self, scalar: ScalarTy<'tcx>) -> Operand<'tcx> {\n         Operand::Constant(Box::new(Constant {\n             span: DUMMY_SP,\n             user_ty: None,\n-            literal: ConstantKind::Val(ConstValue::Scalar(scalar.into()), ty),\n+            literal: ConstantKind::Val(ConstValue::Scalar(scalar.0), scalar.1),\n         }))\n     }\n }\n \n impl<'mir, 'tcx, 'map> ResultsVisitor<'mir, 'tcx> for CollectAndPatch<'tcx, 'map> {\n-    type FlowState = State<FlatSet<Const<'tcx>>>;\n+    type FlowState = State<FlatSet<ScalarTy<'tcx>>>;\n \n     fn visit_statement_before_primary_effect(\n         &mut self,\n@@ -384,7 +371,7 @@ impl<'tcx, 'map> MutVisitor<'tcx> for CollectAndPatch<'tcx, 'map> {\n }\n \n struct OperandCollector<'tcx, 'map, 'a> {\n-    state: &'a State<FlatSet<Const<'tcx>>>,\n+    state: &'a State<FlatSet<ScalarTy<'tcx>>>,\n     visitor: &'a mut CollectAndPatch<'tcx, 'map>,\n }\n "}]}