{"sha": "a136cc0653d2b4133fb6387009cfdbaf3e2cf275", "node_id": "MDY6Q29tbWl0NzI0NzEyOmExMzZjYzA2NTNkMmI0MTMzZmI2Mzg3MDA5Y2ZkYmFmM2UyY2YyNzU=", "commit": {"author": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2019-10-30T09:27:54Z"}, "committer": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2019-10-30T09:27:54Z"}, "message": "introduce ra_hir_def", "tree": {"sha": "c7693867220abfefd90acb9965d91c6fe0023d38", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c7693867220abfefd90acb9965d91c6fe0023d38"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a136cc0653d2b4133fb6387009cfdbaf3e2cf275", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a136cc0653d2b4133fb6387009cfdbaf3e2cf275", "html_url": "https://github.com/rust-lang/rust/commit/a136cc0653d2b4133fb6387009cfdbaf3e2cf275", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a136cc0653d2b4133fb6387009cfdbaf3e2cf275/comments", "author": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "committer": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "56bc874f1d14922686b26afc8793b7e57a652990", "url": "https://api.github.com/repos/rust-lang/rust/commits/56bc874f1d14922686b26afc8793b7e57a652990", "html_url": "https://github.com/rust-lang/rust/commit/56bc874f1d14922686b26afc8793b7e57a652990"}], "stats": {"total": 239, "additions": 139, "deletions": 100}, "files": [{"sha": "a7643362095b89f5e51ba552e7c4faeadf809ded", "filename": "Cargo.lock", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/a136cc0653d2b4133fb6387009cfdbaf3e2cf275/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/a136cc0653d2b4133fb6387009cfdbaf3e2cf275/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=a136cc0653d2b4133fb6387009cfdbaf3e2cf275", "patch": "@@ -1003,6 +1003,7 @@ dependencies = [\n  \"ra_arena 0.1.0\",\n  \"ra_cfg 0.1.0\",\n  \"ra_db 0.1.0\",\n+ \"ra_hir_def 0.1.0\",\n  \"ra_hir_expand 0.1.0\",\n  \"ra_mbe 0.1.0\",\n  \"ra_prof 0.1.0\",\n@@ -1013,6 +1014,17 @@ dependencies = [\n  \"test_utils 0.1.0\",\n ]\n \n+[[package]]\n+name = \"ra_hir_def\"\n+version = \"0.1.0\"\n+dependencies = [\n+ \"log 0.4.8 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"ra_arena 0.1.0\",\n+ \"ra_db 0.1.0\",\n+ \"ra_prof 0.1.0\",\n+ \"ra_syntax 0.1.0\",\n+]\n+\n [[package]]\n name = \"ra_hir_expand\"\n version = \"0.1.0\""}, {"sha": "5df371bc0f97ee682ae5cb050d438b178ec185b2", "filename": "crates/ra_hir/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a136cc0653d2b4133fb6387009cfdbaf3e2cf275/crates%2Fra_hir%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/a136cc0653d2b4133fb6387009cfdbaf3e2cf275/crates%2Fra_hir%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2FCargo.toml?ref=a136cc0653d2b4133fb6387009cfdbaf3e2cf275", "patch": "@@ -20,6 +20,7 @@ ra_db = { path = \"../ra_db\" }\n mbe = { path = \"../ra_mbe\", package = \"ra_mbe\" }\n tt = { path = \"../ra_tt\", package = \"ra_tt\" }\n hir_expand = { path = \"../ra_hir_expand\", package = \"ra_hir_expand\" }\n+hir_def = { path = \"../ra_hir_def\", package = \"ra_hir_def\" }\n test_utils = { path = \"../test_utils\" }\n ra_prof = { path = \"../ra_prof\" }\n "}, {"sha": "3f1c36941d03f57d14ec6aa75ce3dd8760692a74", "filename": "crates/ra_hir/src/code_model.rs", "status": "modified", "additions": 41, "deletions": 36, "changes": 77, "blob_url": "https://github.com/rust-lang/rust/blob/a136cc0653d2b4133fb6387009cfdbaf3e2cf275/crates%2Fra_hir%2Fsrc%2Fcode_model.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a136cc0653d2b4133fb6387009cfdbaf3e2cf275/crates%2Fra_hir%2Fsrc%2Fcode_model.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fcode_model.rs?ref=a136cc0653d2b4133fb6387009cfdbaf3e2cf275", "patch": "@@ -5,6 +5,7 @@ pub(crate) mod docs;\n \n use std::sync::Arc;\n \n+use hir_def::{CrateModuleId, ModuleId};\n use ra_db::{CrateId, Edition, FileId};\n use ra_syntax::ast::{self, NameOwner, TypeAscriptionOwner};\n \n@@ -23,7 +24,7 @@ use crate::{\n         BOOL, CHAR, F32, F64, I128, I16, I32, I64, I8, ISIZE, SELF_TYPE, STR, U128, U16, U32, U64,\n         U8, USIZE,\n     },\n-    nameres::{CrateModuleId, ImportId, ModuleScope, Namespace},\n+    nameres::{ImportId, ModuleScope, Namespace},\n     resolve::{Resolver, Scope, TypeNs},\n     traits::TraitData,\n     ty::{\n@@ -67,8 +68,7 @@ impl Crate {\n \n     pub fn root_module(self, db: &impl DefDatabase) -> Option<Module> {\n         let module_id = db.crate_def_map(self).root();\n-        let module = Module { krate: self, module_id };\n-        Some(module)\n+        Some(Module::new(self, module_id))\n     }\n \n     pub fn edition(self, db: &impl DefDatabase) -> Edition {\n@@ -83,8 +83,7 @@ impl Crate {\n \n #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n pub struct Module {\n-    pub(crate) krate: Crate,\n-    pub(crate) module_id: CrateModuleId,\n+    pub(crate) id: ModuleId,\n }\n \n #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n@@ -175,12 +174,16 @@ impl ModuleSource {\n }\n \n impl Module {\n+    pub(crate) fn new(krate: Crate, crate_module_id: CrateModuleId) -> Module {\n+        Module { id: ModuleId { krate: krate.crate_id, module_id: crate_module_id } }\n+    }\n+\n     /// Name of this module.\n     pub fn name(self, db: &impl DefDatabase) -> Option<Name> {\n-        let def_map = db.crate_def_map(self.krate);\n-        let parent = def_map[self.module_id].parent?;\n+        let def_map = db.crate_def_map(self.krate());\n+        let parent = def_map[self.id.module_id].parent?;\n         def_map[parent].children.iter().find_map(|(name, module_id)| {\n-            if *module_id == self.module_id {\n+            if *module_id == self.id.module_id {\n                 Some(name.clone())\n             } else {\n                 None\n@@ -200,29 +203,29 @@ impl Module {\n     }\n \n     /// Returns the crate this module is part of.\n-    pub fn krate(self, _db: &impl DefDatabase) -> Option<Crate> {\n-        Some(self.krate)\n+    pub fn krate(self) -> Crate {\n+        Crate { crate_id: self.id.krate }\n     }\n \n     /// Topmost parent of this module. Every module has a `crate_root`, but some\n     /// might be missing `krate`. This can happen if a module's file is not included\n     /// in the module tree of any target in `Cargo.toml`.\n     pub fn crate_root(self, db: &impl DefDatabase) -> Module {\n-        let def_map = db.crate_def_map(self.krate);\n+        let def_map = db.crate_def_map(self.krate());\n         self.with_module_id(def_map.root())\n     }\n \n     /// Finds a child module with the specified name.\n     pub fn child(self, db: &impl HirDatabase, name: &Name) -> Option<Module> {\n-        let def_map = db.crate_def_map(self.krate);\n-        let child_id = def_map[self.module_id].children.get(name)?;\n+        let def_map = db.crate_def_map(self.krate());\n+        let child_id = def_map[self.id.module_id].children.get(name)?;\n         Some(self.with_module_id(*child_id))\n     }\n \n     /// Iterates over all child modules.\n     pub fn children(self, db: &impl DefDatabase) -> impl Iterator<Item = Module> {\n-        let def_map = db.crate_def_map(self.krate);\n-        let children = def_map[self.module_id]\n+        let def_map = db.crate_def_map(self.krate());\n+        let children = def_map[self.id.module_id]\n             .children\n             .iter()\n             .map(|(_, module_id)| self.with_module_id(*module_id))\n@@ -232,8 +235,8 @@ impl Module {\n \n     /// Finds a parent module.\n     pub fn parent(self, db: &impl DefDatabase) -> Option<Module> {\n-        let def_map = db.crate_def_map(self.krate);\n-        let parent_id = def_map[self.module_id].parent?;\n+        let def_map = db.crate_def_map(self.krate());\n+        let parent_id = def_map[self.id.module_id].parent?;\n         Some(self.with_module_id(parent_id))\n     }\n \n@@ -249,11 +252,11 @@ impl Module {\n \n     /// Returns a `ModuleScope`: a set of items, visible in this module.\n     pub fn scope(self, db: &impl HirDatabase) -> ModuleScope {\n-        db.crate_def_map(self.krate)[self.module_id].scope.clone()\n+        db.crate_def_map(self.krate())[self.id.module_id].scope.clone()\n     }\n \n     pub fn diagnostics(self, db: &impl HirDatabase, sink: &mut DiagnosticSink) {\n-        db.crate_def_map(self.krate).add_diagnostics(db, self.module_id, sink);\n+        db.crate_def_map(self.krate()).add_diagnostics(db, self.id.module_id, sink);\n         for decl in self.declarations(db) {\n             match decl {\n                 crate::ModuleDef::Function(f) => f.diagnostics(db, sink),\n@@ -277,13 +280,13 @@ impl Module {\n     }\n \n     pub(crate) fn resolver(self, db: &impl DefDatabase) -> Resolver {\n-        let def_map = db.crate_def_map(self.krate);\n-        Resolver::default().push_module_scope(def_map, self.module_id)\n+        let def_map = db.crate_def_map(self.krate());\n+        Resolver::default().push_module_scope(def_map, self.id.module_id)\n     }\n \n     pub fn declarations(self, db: &impl DefDatabase) -> Vec<ModuleDef> {\n-        let def_map = db.crate_def_map(self.krate);\n-        def_map[self.module_id]\n+        let def_map = db.crate_def_map(self.krate());\n+        def_map[self.id.module_id]\n             .scope\n             .entries()\n             .filter_map(|(_name, res)| if res.import.is_none() { Some(res.def) } else { None })\n@@ -303,7 +306,7 @@ impl Module {\n     }\n \n     fn with_module_id(self, module_id: CrateModuleId) -> Module {\n-        Module { module_id, krate: self.krate }\n+        Module::new(self.krate(), module_id)\n     }\n }\n \n@@ -344,7 +347,7 @@ impl Struct {\n     }\n \n     pub fn krate(self, db: &impl DefDatabase) -> Option<Crate> {\n-        self.module(db).krate(db)\n+        Some(self.module(db).krate())\n     }\n \n     pub fn name(self, db: &impl DefDatabase) -> Option<Name> {\n@@ -432,7 +435,7 @@ impl Enum {\n     }\n \n     pub fn krate(self, db: &impl DefDatabase) -> Option<Crate> {\n-        self.module(db).krate(db)\n+        Some(self.module(db).krate())\n     }\n \n     pub fn name(self, db: &impl DefDatabase) -> Option<Name> {\n@@ -523,12 +526,14 @@ impl Adt {\n     }\n \n     pub fn krate(self, db: &impl HirDatabase) -> Option<Crate> {\n-        match self {\n-            Adt::Struct(s) => s.module(db),\n-            Adt::Union(s) => s.module(db),\n-            Adt::Enum(e) => e.module(db),\n-        }\n-        .krate(db)\n+        Some(\n+            match self {\n+                Adt::Struct(s) => s.module(db),\n+                Adt::Union(s) => s.module(db),\n+                Adt::Enum(e) => e.module(db),\n+            }\n+            .krate(),\n+        )\n     }\n \n     pub(crate) fn resolver(self, db: &impl HirDatabase) -> Resolver {\n@@ -696,7 +701,7 @@ impl Function {\n     }\n \n     pub fn krate(self, db: &impl DefDatabase) -> Option<Crate> {\n-        self.module(db).krate(db)\n+        Some(self.module(db).krate())\n     }\n \n     pub fn name(self, db: &impl HirDatabase) -> Name {\n@@ -774,7 +779,7 @@ impl Const {\n     }\n \n     pub fn krate(self, db: &impl DefDatabase) -> Option<Crate> {\n-        self.module(db).krate(db)\n+        Some(self.module(db).krate())\n     }\n \n     pub fn data(self, db: &impl HirDatabase) -> Arc<ConstData> {\n@@ -871,7 +876,7 @@ impl Static {\n     }\n \n     pub fn krate(self, db: &impl DefDatabase) -> Option<Crate> {\n-        self.module(db).krate(db)\n+        Some(self.module(db).krate())\n     }\n \n     pub fn data(self, db: &impl HirDatabase) -> Arc<ConstData> {\n@@ -1002,7 +1007,7 @@ impl TypeAlias {\n     }\n \n     pub fn krate(self, db: &impl DefDatabase) -> Option<Crate> {\n-        self.module(db).krate(db)\n+        Some(self.module(db).krate())\n     }\n \n     /// The containing impl block, if this is a method."}, {"sha": "8b33f25f7af885727e8680c9b90878cdf08c1a66", "filename": "crates/ra_hir/src/code_model/src.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/a136cc0653d2b4133fb6387009cfdbaf3e2cf275/crates%2Fra_hir%2Fsrc%2Fcode_model%2Fsrc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a136cc0653d2b4133fb6387009cfdbaf3e2cf275/crates%2Fra_hir%2Fsrc%2Fcode_model%2Fsrc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fcode_model%2Fsrc.rs?ref=a136cc0653d2b4133fb6387009cfdbaf3e2cf275", "patch": "@@ -37,9 +37,9 @@ impl<T> Source<T> {\n impl Module {\n     /// Returns a node which defines this module. That is, a file or a `mod foo {}` with items.\n     pub fn definition_source(self, db: &(impl DefDatabase + AstDatabase)) -> Source<ModuleSource> {\n-        let def_map = db.crate_def_map(self.krate);\n-        let decl_id = def_map[self.module_id].declaration;\n-        let file_id = def_map[self.module_id].definition;\n+        let def_map = db.crate_def_map(self.krate());\n+        let decl_id = def_map[self.id.module_id].declaration;\n+        let file_id = def_map[self.id.module_id].definition;\n         let ast = ModuleSource::new(db, file_id, decl_id);\n         let file_id = file_id.map(HirFileId::from).unwrap_or_else(|| decl_id.unwrap().file_id());\n         Source { file_id, ast }\n@@ -51,8 +51,8 @@ impl Module {\n         self,\n         db: &(impl DefDatabase + AstDatabase),\n     ) -> Option<Source<ast::Module>> {\n-        let def_map = db.crate_def_map(self.krate);\n-        let decl = def_map[self.module_id].declaration?;\n+        let def_map = db.crate_def_map(self.krate());\n+        let decl = def_map[self.id.module_id].declaration?;\n         let ast = decl.to_node(db);\n         Some(Source { file_id: decl.file_id(), ast })\n     }"}, {"sha": "291f2a14ac0ee8107ccd9c3320232c64e8f8651b", "filename": "crates/ra_hir/src/from_source.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a136cc0653d2b4133fb6387009cfdbaf3e2cf275/crates%2Fra_hir%2Fsrc%2Ffrom_source.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a136cc0653d2b4133fb6387009cfdbaf3e2cf275/crates%2Fra_hir%2Fsrc%2Ffrom_source.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Ffrom_source.rs?ref=a136cc0653d2b4133fb6387009cfdbaf3e2cf275", "patch": "@@ -195,7 +195,7 @@ impl Module {\n             .find_map(|krate| {\n                 let def_map = db.crate_def_map(krate);\n                 let module_id = def_map.find_module_by_source(src.file_id, decl_id)?;\n-                Some(Module { krate, module_id })\n+                Some(Module::new(krate, module_id))\n             })\n     }\n }"}, {"sha": "fde47c264a634eceb718964a8f64902de6bdf10f", "filename": "crates/ra_hir/src/impl_block.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a136cc0653d2b4133fb6387009cfdbaf3e2cf275/crates%2Fra_hir%2Fsrc%2Fimpl_block.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a136cc0653d2b4133fb6387009cfdbaf3e2cf275/crates%2Fra_hir%2Fsrc%2Fimpl_block.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fimpl_block.rs?ref=a136cc0653d2b4133fb6387009cfdbaf3e2cf275", "patch": "@@ -182,7 +182,7 @@ impl ModuleImplBlocks {\n     ) -> (Arc<ModuleImplBlocks>, Arc<ImplSourceMap>) {\n         let mut source_map = ImplSourceMap::default();\n         let crate_graph = db.crate_graph();\n-        let cfg_options = crate_graph.cfg_options(module.krate.crate_id());\n+        let cfg_options = crate_graph.cfg_options(module.id.krate);\n \n         let result = ModuleImplBlocks::collect(db, cfg_options, module, &mut source_map);\n         (Arc::new(result), Arc::new(source_map))"}, {"sha": "e1780ed388f0b7f5a1739995055ac533924b1dca", "filename": "crates/ra_hir/src/lang_item.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/a136cc0653d2b4133fb6387009cfdbaf3e2cf275/crates%2Fra_hir%2Fsrc%2Flang_item.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a136cc0653d2b4133fb6387009cfdbaf3e2cf275/crates%2Fra_hir%2Fsrc%2Flang_item.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Flang_item.rs?ref=a136cc0653d2b4133fb6387009cfdbaf3e2cf275", "patch": "@@ -22,14 +22,14 @@ pub enum LangItemTarget {\n \n impl LangItemTarget {\n     pub(crate) fn krate(&self, db: &impl HirDatabase) -> Option<Crate> {\n-        match self {\n-            LangItemTarget::Enum(e) => e.module(db).krate(db),\n-            LangItemTarget::Function(f) => f.module(db).krate(db),\n-            LangItemTarget::ImplBlock(i) => i.module().krate(db),\n-            LangItemTarget::Static(s) => s.module(db).krate(db),\n-            LangItemTarget::Struct(s) => s.module(db).krate(db),\n-            LangItemTarget::Trait(t) => t.module(db).krate(db),\n-        }\n+        Some(match self {\n+            LangItemTarget::Enum(e) => e.module(db).krate(),\n+            LangItemTarget::Function(f) => f.module(db).krate(),\n+            LangItemTarget::ImplBlock(i) => i.module().krate(),\n+            LangItemTarget::Static(s) => s.module(db).krate(),\n+            LangItemTarget::Struct(s) => s.module(db).krate(),\n+            LangItemTarget::Trait(t) => t.module(db).krate(),\n+        })\n     }\n }\n "}, {"sha": "b325979f5b6d785b645b9a71eca6096bd9a2e9e9", "filename": "crates/ra_hir/src/nameres.rs", "status": "modified", "additions": 14, "deletions": 22, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/a136cc0653d2b4133fb6387009cfdbaf3e2cf275/crates%2Fra_hir%2Fsrc%2Fnameres.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a136cc0653d2b4133fb6387009cfdbaf3e2cf275/crates%2Fra_hir%2Fsrc%2Fnameres.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fnameres.rs?ref=a136cc0653d2b4133fb6387009cfdbaf3e2cf275", "patch": "@@ -56,8 +56,9 @@ mod tests;\n \n use std::sync::Arc;\n \n+use hir_def::CrateModuleId;\n use once_cell::sync::Lazy;\n-use ra_arena::{impl_arena_id, Arena, RawId};\n+use ra_arena::Arena;\n use ra_db::{Edition, FileId};\n use ra_prof::profile;\n use ra_syntax::ast;\n@@ -115,13 +116,8 @@ impl std::ops::Index<CrateModuleId> for CrateDefMap {\n     }\n }\n \n-/// An ID of a module, **local** to a specific crate\n-#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]\n-pub(crate) struct CrateModuleId(RawId);\n-impl_arena_id!(CrateModuleId);\n-\n #[derive(Default, Debug, PartialEq, Eq)]\n-pub(crate) struct ModuleData {\n+pub struct ModuleData {\n     pub(crate) parent: Option<CrateModuleId>,\n     pub(crate) children: FxHashMap<Name, CrateModuleId>,\n     pub(crate) scope: ModuleScope,\n@@ -335,7 +331,7 @@ impl CrateDefMap {\n             PathKind::DollarCrate(krate) => {\n                 if krate == self.krate {\n                     tested_by!(macro_dollar_crate_self);\n-                    PerNs::types(Module { krate: self.krate, module_id: self.root }.into())\n+                    PerNs::types(Module::new(self.krate, self.root).into())\n                 } else {\n                     match krate.root_module(db) {\n                         Some(module) => {\n@@ -346,12 +342,8 @@ impl CrateDefMap {\n                     }\n                 }\n             }\n-            PathKind::Crate => {\n-                PerNs::types(Module { krate: self.krate, module_id: self.root }.into())\n-            }\n-            PathKind::Self_ => {\n-                PerNs::types(Module { krate: self.krate, module_id: original_module }.into())\n-            }\n+            PathKind::Crate => PerNs::types(Module::new(self.krate, self.root).into()),\n+            PathKind::Self_ => PerNs::types(Module::new(self.krate, original_module).into()),\n             // plain import or absolute path in 2015: crate-relative with\n             // fallback to extern prelude (with the simplification in\n             // rust-lang/rust#57745)\n@@ -377,7 +369,7 @@ impl CrateDefMap {\n             }\n             PathKind::Super => {\n                 if let Some(p) = self.modules[original_module].parent {\n-                    PerNs::types(Module { krate: self.krate, module_id: p }.into())\n+                    PerNs::types(Module::new(self.krate, p).into())\n                 } else {\n                     log::debug!(\"super path in root module\");\n                     return ResolvePathResult::empty(ReachedFixedPoint::Yes);\n@@ -419,12 +411,12 @@ impl CrateDefMap {\n \n             curr_per_ns = match curr {\n                 ModuleDef::Module(module) => {\n-                    if module.krate != self.krate {\n+                    if module.krate() != self.krate {\n                         let path =\n                             Path { segments: path.segments[i..].to_vec(), kind: PathKind::Self_ };\n                         log::debug!(\"resolving {:?} in other crate\", path);\n-                        let defp_map = db.crate_def_map(module.krate);\n-                        let (def, s) = defp_map.resolve_path(db, module.module_id, &path);\n+                        let defp_map = db.crate_def_map(module.krate());\n+                        let (def, s) = defp_map.resolve_path(db, module.id.module_id, &path);\n                         return ResolvePathResult::with(\n                             def,\n                             ReachedFixedPoint::Yes,\n@@ -433,7 +425,7 @@ impl CrateDefMap {\n                     }\n \n                     // Since it is a qualified path here, it should not contains legacy macros\n-                    match self[module.module_id].scope.get(&segment.name) {\n+                    match self[module.id.module_id].scope.get(&segment.name) {\n                         Some(res) => res.def,\n                         _ => {\n                             log::debug!(\"path segment {:?} not found\", segment.name);\n@@ -511,14 +503,14 @@ impl CrateDefMap {\n     fn resolve_in_prelude(&self, db: &impl DefDatabase, name: &Name) -> PerNs {\n         if let Some(prelude) = self.prelude {\n             let keep;\n-            let def_map = if prelude.krate == self.krate {\n+            let def_map = if prelude.krate() == self.krate {\n                 self\n             } else {\n                 // Extend lifetime\n-                keep = db.crate_def_map(prelude.krate);\n+                keep = db.crate_def_map(prelude.krate());\n                 &keep\n             };\n-            def_map[prelude.module_id].scope.get(name).map_or_else(PerNs::none, |res| res.def)\n+            def_map[prelude.id.module_id].scope.get(name).map_or_else(PerNs::none, |res| res.def)\n         } else {\n             PerNs::none()\n         }"}, {"sha": "dd5f9d4ba1749a43d37168ed72b333b6475d3292", "filename": "crates/ra_hir/src/nameres/collector.rs", "status": "modified", "additions": 11, "deletions": 12, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/a136cc0653d2b4133fb6387009cfdbaf3e2cf275/crates%2Fra_hir%2Fsrc%2Fnameres%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a136cc0653d2b4133fb6387009cfdbaf3e2cf275/crates%2Fra_hir%2Fsrc%2Fnameres%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fnameres%2Fcollector.rs?ref=a136cc0653d2b4133fb6387009cfdbaf3e2cf275", "patch": "@@ -212,7 +212,7 @@ where\n \n         if let Some(ModuleDef::Module(m)) = res.take_types() {\n             tested_by!(macro_rules_from_other_crates_are_visible_with_macro_use);\n-            self.import_all_macros_exported(current_module_id, m.krate);\n+            self.import_all_macros_exported(current_module_id, m.krate());\n         }\n     }\n \n@@ -289,11 +289,11 @@ where\n                     if import.is_prelude {\n                         tested_by!(std_prelude);\n                         self.def_map.prelude = Some(m);\n-                    } else if m.krate != self.def_map.krate {\n+                    } else if m.krate() != self.def_map.krate {\n                         tested_by!(glob_across_crates);\n                         // glob import from other crate => we can just import everything once\n-                        let item_map = self.db.crate_def_map(m.krate);\n-                        let scope = &item_map[m.module_id].scope;\n+                        let item_map = self.db.crate_def_map(m.krate());\n+                        let scope = &item_map[m.id.module_id].scope;\n \n                         // Module scoped macros is included\n                         let items = scope\n@@ -307,7 +307,7 @@ where\n                         // glob import from same crate => we do an initial\n                         // import, and then need to propagate any further\n                         // additions\n-                        let scope = &self.def_map[m.module_id].scope;\n+                        let scope = &self.def_map[m.id.module_id].scope;\n \n                         // Module scoped macros is included\n                         let items = scope\n@@ -319,7 +319,7 @@ where\n                         self.update(module_id, Some(import_id), &items);\n                         // record the glob import in case we add further items\n                         self.glob_imports\n-                            .entry(m.module_id)\n+                            .entry(m.id.module_id)\n                             .or_default()\n                             .push((module_id, import_id));\n                     }\n@@ -523,9 +523,10 @@ where\n \n         // Prelude module is always considered to be `#[macro_use]`.\n         if let Some(prelude_module) = self.def_collector.def_map.prelude {\n-            if prelude_module.krate != self.def_collector.def_map.krate {\n+            if prelude_module.krate() != self.def_collector.def_map.krate {\n                 tested_by!(prelude_is_macro_use);\n-                self.def_collector.import_all_macros_exported(self.module_id, prelude_module.krate);\n+                self.def_collector\n+                    .import_all_macros_exported(self.module_id, prelude_module.krate());\n             }\n         }\n \n@@ -631,17 +632,15 @@ where\n         modules[res].scope.legacy_macros = modules[self.module_id].scope.legacy_macros.clone();\n         modules[self.module_id].children.insert(name.clone(), res);\n         let resolution = Resolution {\n-            def: PerNs::types(\n-                Module { krate: self.def_collector.def_map.krate, module_id: res }.into(),\n-            ),\n+            def: PerNs::types(Module::new(self.def_collector.def_map.krate, res).into()),\n             import: None,\n         };\n         self.def_collector.update(self.module_id, None, &[(name, resolution)]);\n         res\n     }\n \n     fn define_def(&mut self, def: &raw::DefData) {\n-        let module = Module { krate: self.def_collector.def_map.krate, module_id: self.module_id };\n+        let module = Module::new(self.def_collector.def_map.krate, self.module_id);\n         let ctx = LocationCtx::new(self.def_collector.db, module, self.file_id);\n \n         macro_rules! def {"}, {"sha": "8b62694075df07f7d83e426a28a7ef61bbbf326b", "filename": "crates/ra_hir/src/resolve.rs", "status": "modified", "additions": 10, "deletions": 7, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/a136cc0653d2b4133fb6387009cfdbaf3e2cf275/crates%2Fra_hir%2Fsrc%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a136cc0653d2b4133fb6387009cfdbaf3e2cf275/crates%2Fra_hir%2Fsrc%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fresolve.rs?ref=a136cc0653d2b4133fb6387009cfdbaf3e2cf275", "patch": "@@ -1,6 +1,7 @@\n //! Name resolution.\n use std::sync::Arc;\n \n+use hir_def::CrateModuleId;\n use rustc_hash::FxHashSet;\n \n use crate::{\n@@ -13,7 +14,7 @@ use crate::{\n     generics::GenericParams,\n     impl_block::ImplBlock,\n     name::{Name, SELF_PARAM, SELF_TYPE},\n-    nameres::{CrateDefMap, CrateModuleId, PerNs},\n+    nameres::{CrateDefMap, PerNs},\n     path::{Path, PathKind},\n     Adt, BuiltinType, Const, Enum, EnumVariant, Function, MacroDef, ModuleDef, Static, Struct,\n     Trait, TypeAlias,\n@@ -330,8 +331,8 @@ impl Resolver {\n         for scope in &self.scopes {\n             if let Scope::ModuleScope(m) = scope {\n                 if let Some(prelude) = m.crate_def_map.prelude() {\n-                    let prelude_def_map = db.crate_def_map(prelude.krate);\n-                    traits.extend(prelude_def_map[prelude.module_id].scope.traits());\n+                    let prelude_def_map = db.crate_def_map(prelude.krate());\n+                    traits.extend(prelude_def_map[prelude.id.module_id].scope.traits());\n                 }\n                 traits.extend(m.crate_def_map[m.module_id].scope.traits());\n             }\n@@ -444,10 +445,12 @@ impl Scope {\n                     f(name.clone(), ScopeDef::ModuleDef(*def));\n                 });\n                 if let Some(prelude) = m.crate_def_map.prelude() {\n-                    let prelude_def_map = db.crate_def_map(prelude.krate);\n-                    prelude_def_map[prelude.module_id].scope.entries().for_each(|(name, res)| {\n-                        f(name.clone(), res.def.into());\n-                    });\n+                    let prelude_def_map = db.crate_def_map(prelude.krate());\n+                    prelude_def_map[prelude.id.module_id].scope.entries().for_each(\n+                        |(name, res)| {\n+                            f(name.clone(), res.def.into());\n+                        },\n+                    );\n                 }\n             }\n             Scope::GenericParams(gp) => {"}, {"sha": "50583a1429e6781551fc2eef66e1337cebf317ff", "filename": "crates/ra_hir/src/ty/method_resolution.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/a136cc0653d2b4133fb6387009cfdbaf3e2cf275/crates%2Fra_hir%2Fsrc%2Fty%2Fmethod_resolution.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a136cc0653d2b4133fb6387009cfdbaf3e2cf275/crates%2Fra_hir%2Fsrc%2Fty%2Fmethod_resolution.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty%2Fmethod_resolution.rs?ref=a136cc0653d2b4133fb6387009cfdbaf3e2cf275", "patch": "@@ -5,13 +5,13 @@\n use std::sync::Arc;\n \n use arrayvec::ArrayVec;\n+use hir_def::CrateModuleId;\n use rustc_hash::FxHashMap;\n \n use super::{autoderef, lower, Canonical, InEnvironment, TraitEnvironment, TraitRef};\n use crate::{\n     db::HirDatabase,\n     impl_block::{ImplBlock, ImplId},\n-    nameres::CrateModuleId,\n     resolve::Resolver,\n     ty::primitive::{FloatBitness, UncertainFloatTy, UncertainIntTy},\n     ty::{Ty, TypeCtor},\n@@ -50,7 +50,7 @@ impl CrateImplBlocks {\n         let fingerprint = TyFingerprint::for_impl(ty);\n         fingerprint.and_then(|f| self.impls.get(&f)).into_iter().flat_map(|i| i.iter()).map(\n             move |(module_id, impl_id)| {\n-                let module = Module { krate: self.krate, module_id: *module_id };\n+                let module = Module::new(self.krate, *module_id);\n                 ImplBlock::from_id(module, *impl_id)\n             },\n         )\n@@ -62,7 +62,7 @@ impl CrateImplBlocks {\n     ) -> impl Iterator<Item = ImplBlock> + 'a {\n         self.impls_by_trait.get(&tr).into_iter().flat_map(|i| i.iter()).map(\n             move |(module_id, impl_id)| {\n-                let module = Module { krate: self.krate, module_id: *module_id };\n+                let module = Module::new(self.krate, *module_id);\n                 ImplBlock::from_id(module, *impl_id)\n             },\n         )\n@@ -71,7 +71,7 @@ impl CrateImplBlocks {\n     pub fn all_impls<'a>(&'a self) -> impl Iterator<Item = ImplBlock> + 'a {\n         self.impls.values().chain(self.impls_by_trait.values()).flat_map(|i| i.iter()).map(\n             move |(module_id, impl_id)| {\n-                let module = Module { krate: self.krate, module_id: *module_id };\n+                let module = Module::new(self.krate, *module_id);\n                 ImplBlock::from_id(module, *impl_id)\n             },\n         )\n@@ -90,14 +90,14 @@ impl CrateImplBlocks {\n                     self.impls_by_trait\n                         .entry(tr.trait_)\n                         .or_insert_with(Vec::new)\n-                        .push((module.module_id, impl_id));\n+                        .push((module.id.module_id, impl_id));\n                 }\n             } else {\n                 if let Some(target_ty_fp) = TyFingerprint::for_impl(&target_ty) {\n                     self.impls\n                         .entry(target_ty_fp)\n                         .or_insert_with(Vec::new)\n-                        .push((module.module_id, impl_id));\n+                        .push((module.id.module_id, impl_id));\n                 }\n             }\n         }"}, {"sha": "aec484feb23bc2a8053da6801b1a47db08512836", "filename": "crates/ra_hir/src/ty/traits/chalk.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a136cc0653d2b4133fb6387009cfdbaf3e2cf275/crates%2Fra_hir%2Fsrc%2Fty%2Ftraits%2Fchalk.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a136cc0653d2b4133fb6387009cfdbaf3e2cf275/crates%2Fra_hir%2Fsrc%2Fty%2Ftraits%2Fchalk.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty%2Ftraits%2Fchalk.rs?ref=a136cc0653d2b4133fb6387009cfdbaf3e2cf275", "patch": "@@ -537,7 +537,7 @@ pub(crate) fn trait_datum_query(\n     let trait_ref = trait_.trait_ref(db).subst(&bound_vars).to_chalk(db);\n     let flags = chalk_rust_ir::TraitFlags {\n         auto: trait_.is_auto(db),\n-        upstream: trait_.module(db).krate(db) != Some(krate),\n+        upstream: trait_.module(db).krate() != krate,\n         non_enumerable: true,\n         // FIXME set these flags correctly\n         marker: false,\n@@ -625,7 +625,7 @@ fn impl_block_datum(\n         .target_trait_ref(db)\n         .expect(\"FIXME handle unresolved impl block trait ref\")\n         .subst(&bound_vars);\n-    let impl_type = if impl_block.module().krate(db) == Some(krate) {\n+    let impl_type = if impl_block.module().krate() == krate {\n         chalk_rust_ir::ImplType::Local\n     } else {\n         chalk_rust_ir::ImplType::External"}, {"sha": "f22a678eb7971d60af4e18165811f2adf986c5b6", "filename": "crates/ra_hir_def/Cargo.toml", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/a136cc0653d2b4133fb6387009cfdbaf3e2cf275/crates%2Fra_hir_def%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/a136cc0653d2b4133fb6387009cfdbaf3e2cf275/crates%2Fra_hir_def%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2FCargo.toml?ref=a136cc0653d2b4133fb6387009cfdbaf3e2cf275", "patch": "@@ -0,0 +1,13 @@\n+[package]\n+edition = \"2018\"\n+name = \"ra_hir_def\"\n+version = \"0.1.0\"\n+authors = [\"rust-analyzer developers\"]\n+\n+[dependencies]\n+log = \"0.4.5\"\n+\n+ra_arena = { path = \"../ra_arena\" }\n+ra_db = { path = \"../ra_db\" }\n+ra_syntax = { path = \"../ra_syntax\" }\n+ra_prof = { path = \"../ra_prof\" }"}, {"sha": "f5dd2ae6fbd52b7e25136832c989a782f3e5d053", "filename": "crates/ra_hir_def/src/lib.rs", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/a136cc0653d2b4133fb6387009cfdbaf3e2cf275/crates%2Fra_hir_def%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a136cc0653d2b4133fb6387009cfdbaf3e2cf275/crates%2Fra_hir_def%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Flib.rs?ref=a136cc0653d2b4133fb6387009cfdbaf3e2cf275", "patch": "@@ -0,0 +1,14 @@\n+use ra_arena::{impl_arena_id, RawId};\n+use ra_db::CrateId;\n+\n+#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n+pub struct ModuleId {\n+    pub krate: CrateId,\n+    pub module_id: CrateModuleId,\n+}\n+\n+/// An ID of a module, **local** to a specific crate\n+// FIXME: rename to `LocalModuleId`.\n+#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]\n+pub struct CrateModuleId(RawId);\n+impl_arena_id!(CrateModuleId);"}]}