{"sha": "6e1f3cd8ff080b85f6ba71b3f90300aca194a434", "node_id": "C_kwDOAAsO6NoAKDZlMWYzY2Q4ZmYwODBiODVmNmJhNzFiM2Y5MDMwMGFjYTE5NGE0MzQ", "commit": {"author": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2022-04-03T20:12:52Z"}, "committer": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2022-04-05T15:11:53Z"}, "message": "adjust for MemoryExtra being merged into Machine", "tree": {"sha": "18e368e1bd482e9b5cb18837c542fb03db452316", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/18e368e1bd482e9b5cb18837c542fb03db452316"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6e1f3cd8ff080b85f6ba71b3f90300aca194a434", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6e1f3cd8ff080b85f6ba71b3f90300aca194a434", "html_url": "https://github.com/rust-lang/rust/commit/6e1f3cd8ff080b85f6ba71b3f90300aca194a434", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6e1f3cd8ff080b85f6ba71b3f90300aca194a434/comments", "author": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "committer": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "fc2165dd78fede662b0d6c3645895f2c576625c9", "url": "https://api.github.com/repos/rust-lang/rust/commits/fc2165dd78fede662b0d6c3645895f2c576625c9", "html_url": "https://github.com/rust-lang/rust/commit/fc2165dd78fede662b0d6c3645895f2c576625c9"}], "stats": {"total": 638, "additions": 310, "deletions": 328}, "files": [{"sha": "4a79d9e990479dc7d6144015b5dfb2360dd8f3bb", "filename": "src/data_race.rs", "status": "modified", "additions": 12, "deletions": 14, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/6e1f3cd8ff080b85f6ba71b3f90300aca194a434/src%2Fdata_race.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e1f3cd8ff080b85f6ba71b3f90300aca194a434/src%2Fdata_race.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdata_race.rs?ref=6e1f3cd8ff080b85f6ba71b3f90300aca194a434", "patch": "@@ -79,7 +79,6 @@ use crate::{\n };\n \n pub type AllocExtra = VClockAlloc;\n-pub type MemoryExtra = GlobalState;\n \n /// Valid atomic read-write operations, alias of atomic::Ordering (not non-exhaustive).\n #[derive(Copy, Clone, PartialEq, Eq, Debug)]\n@@ -596,9 +595,9 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: MiriEvalContextExt<'mir, 'tcx> {\n         let eq = this.binary_op(mir::BinOp::Eq, &old, expect_old)?;\n         // If the operation would succeed, but is \"weak\", fail some portion\n         // of the time, based on `rate`.\n-        let rate = this.memory.extra.cmpxchg_weak_failure_rate;\n+        let rate = this.machine.cmpxchg_weak_failure_rate;\n         let cmpxchg_success = eq.to_scalar()?.to_bool()?\n-            && (!can_fail_spuriously || this.memory.extra.rng.get_mut().gen::<f64>() < rate);\n+            && (!can_fail_spuriously || this.machine.rng.get_mut().gen::<f64>() < rate);\n         let res = Immediate::ScalarPair(\n             old.to_scalar_or_uninit(),\n             Scalar::from_bool(cmpxchg_success).into(),\n@@ -690,7 +689,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: MiriEvalContextExt<'mir, 'tcx> {\n     /// Update the data-race detector for an atomic fence on the current thread.\n     fn validate_atomic_fence(&mut self, atomic: AtomicFenceOp) -> InterpResult<'tcx> {\n         let this = self.eval_context_mut();\n-        if let Some(data_race) = &mut this.memory.extra.data_race {\n+        if let Some(data_race) = &mut this.machine.data_race {\n             data_race.maybe_perform_sync_operation(move |index, mut clocks| {\n                 log::trace!(\"Atomic fence on {:?} with ordering {:?}\", index, atomic);\n \n@@ -725,7 +724,7 @@ pub struct VClockAlloc {\n impl VClockAlloc {\n     /// Create a new data-race detector for newly allocated memory.\n     pub fn new_allocation(\n-        global: &MemoryExtra,\n+        global: &GlobalState,\n         len: Size,\n         kind: MemoryKind<MiriMemoryKind>,\n     ) -> VClockAlloc {\n@@ -796,7 +795,7 @@ impl VClockAlloc {\n     #[cold]\n     #[inline(never)]\n     fn report_data_race<'tcx>(\n-        global: &MemoryExtra,\n+        global: &GlobalState,\n         range: &MemoryCellClocks,\n         action: &str,\n         is_atomic: bool,\n@@ -950,13 +949,13 @@ trait EvalContextPrivExt<'mir, 'tcx: 'mir>: MiriEvalContextExt<'mir, 'tcx> {\n     #[inline]\n     fn allow_data_races_ref<R>(&self, op: impl FnOnce(&MiriEvalContext<'mir, 'tcx>) -> R) -> R {\n         let this = self.eval_context_ref();\n-        let old = if let Some(data_race) = &this.memory.extra.data_race {\n+        let old = if let Some(data_race) = &this.machine.data_race {\n             data_race.multi_threaded.replace(false)\n         } else {\n             false\n         };\n         let result = op(this);\n-        if let Some(data_race) = &this.memory.extra.data_race {\n+        if let Some(data_race) = &this.machine.data_race {\n             data_race.multi_threaded.set(old);\n         }\n         result\n@@ -971,13 +970,13 @@ trait EvalContextPrivExt<'mir, 'tcx: 'mir>: MiriEvalContextExt<'mir, 'tcx> {\n         op: impl FnOnce(&mut MiriEvalContext<'mir, 'tcx>) -> R,\n     ) -> R {\n         let this = self.eval_context_mut();\n-        let old = if let Some(data_race) = &this.memory.extra.data_race {\n+        let old = if let Some(data_race) = &this.machine.data_race {\n             data_race.multi_threaded.replace(false)\n         } else {\n             false\n         };\n         let result = op(this);\n-        if let Some(data_race) = &this.memory.extra.data_race {\n+        if let Some(data_race) = &this.machine.data_race {\n             data_race.multi_threaded.set(old);\n         }\n         result\n@@ -997,14 +996,13 @@ trait EvalContextPrivExt<'mir, 'tcx: 'mir>: MiriEvalContextExt<'mir, 'tcx> {\n         ) -> Result<(), DataRace>,\n     ) -> InterpResult<'tcx> {\n         let this = self.eval_context_ref();\n-        if let Some(data_race) = &this.memory.extra.data_race {\n+        if let Some(data_race) = &this.machine.data_race {\n             if data_race.multi_threaded.get() {\n                 let size = place.layout.size;\n-                let (alloc_id, base_offset, ptr) = this.memory.ptr_get_alloc(place.ptr)?;\n+                let (alloc_id, base_offset, ptr) = this.ptr_get_alloc_id(place.ptr)?;\n                 // Load and log the atomic operation.\n                 // Note that atomic loads are possible even from read-only allocations, so `get_alloc_extra_mut` is not an option.\n-                let alloc_meta =\n-                    &this.memory.get_alloc_extra(alloc_id)?.data_race.as_ref().unwrap();\n+                let alloc_meta = &this.get_alloc_extra(alloc_id)?.data_race.as_ref().unwrap();\n                 log::trace!(\n                     \"Atomic op({}) with ordering {:?} on {:?} (size={})\",\n                     description,"}, {"sha": "e1a2e3184ebfa1cd6762a5553755190ed30f0cfa", "filename": "src/diagnostics.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6e1f3cd8ff080b85f6ba71b3f90300aca194a434/src%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e1f3cd8ff080b85f6ba71b3f90300aca194a434/src%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdiagnostics.rs?ref=6e1f3cd8ff080b85f6ba71b3f90300aca194a434", "patch": "@@ -196,7 +196,7 @@ pub fn report_error<'tcx, 'mir>(\n                 Unsupported(_) =>\n                     vec![(None, format!(\"this is likely not a bug in the program; it indicates that the program performed an operation that the interpreter does not support\"))],\n                 UndefinedBehavior(UndefinedBehaviorInfo::AlignmentCheckFailed { .. })\n-                    if ecx.memory.extra.check_alignment == AlignmentCheck::Symbolic\n+                    if ecx.machine.check_alignment == AlignmentCheck::Symbolic\n                 =>\n                     vec![\n                         (None, format!(\"this usually indicates that your program performed an invalid operation and caused Undefined Behavior\")),\n@@ -251,7 +251,7 @@ pub fn report_error<'tcx, 'mir>(\n                 access.uninit_offset.bytes(),\n                 access.uninit_offset.bytes() + access.uninit_size.bytes(),\n             );\n-            eprintln!(\"{:?}\", ecx.memory.dump_alloc(*alloc_id));\n+            eprintln!(\"{:?}\", ecx.dump_alloc(*alloc_id));\n         }\n         _ => {}\n     }"}, {"sha": "4c006867e1772494c47310dfbef9deef94bddee7", "filename": "src/eval.rs", "status": "modified", "additions": 7, "deletions": 9, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/6e1f3cd8ff080b85f6ba71b3f90300aca194a434/src%2Feval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e1f3cd8ff080b85f6ba71b3f90300aca194a434/src%2Feval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Feval.rs?ref=6e1f3cd8ff080b85f6ba71b3f90300aca194a434", "patch": "@@ -153,20 +153,18 @@ pub fn create_ecx<'mir, 'tcx: 'mir>(\n     tcx: TyCtxt<'tcx>,\n     entry_id: DefId,\n     entry_type: EntryFnType,\n-    config: MiriConfig,\n+    config: &MiriConfig,\n ) -> InterpResult<'tcx, (InterpCx<'mir, 'tcx, Evaluator<'mir, 'tcx>>, MPlaceTy<'tcx, Tag>)> {\n     let param_env = ty::ParamEnv::reveal_all();\n     let layout_cx = LayoutCx { tcx, param_env };\n     let mut ecx = InterpCx::new(\n         tcx,\n         rustc_span::source_map::DUMMY_SP,\n         param_env,\n-        Evaluator::new(&config, layout_cx),\n-        MemoryExtra::new(&config),\n+        Evaluator::new(config, layout_cx),\n     );\n-    // Complete initialization.\n-    EnvVars::init(&mut ecx, config.excluded_env_vars, config.forwarded_env_vars)?;\n-    MemoryExtra::init_extern_statics(&mut ecx)?;\n+    // Some parts of initialization require a full `InterpCx`.\n+    Evaluator::late_init(&mut ecx, config)?;\n \n     // Make sure we have MIR. We check MIR for some stable monomorphic function in libcore.\n     let sentinel = ecx.resolve_path(&[\"core\", \"ascii\", \"escape_default\"]);\n@@ -260,7 +258,7 @@ pub fn create_ecx<'mir, 'tcx: 'mir>(\n             .unwrap()\n             .unwrap();\n \n-            let main_ptr = ecx.memory.create_fn_alloc(FnVal::Instance(entry_instance));\n+            let main_ptr = ecx.create_fn_alloc_ptr(FnVal::Instance(entry_instance));\n \n             ecx.call_function(\n                 start_instance,\n@@ -296,7 +294,7 @@ pub fn eval_entry<'tcx>(\n     // Copy setting before we move `config`.\n     let ignore_leaks = config.ignore_leaks;\n \n-    let (mut ecx, ret_place) = match create_ecx(tcx, entry_id, entry_type, config) {\n+    let (mut ecx, ret_place) = match create_ecx(tcx, entry_id, entry_type, &config) {\n         Ok(v) => v,\n         Err(err) => {\n             err.print_backtrace();\n@@ -354,7 +352,7 @@ pub fn eval_entry<'tcx>(\n                 }\n                 // Check for memory leaks.\n                 info!(\"Additonal static roots: {:?}\", ecx.machine.static_roots);\n-                let leaks = ecx.memory.leak_report(&ecx.machine.static_roots);\n+                let leaks = ecx.leak_report(&ecx.machine.static_roots);\n                 if leaks != 0 {\n                     tcx.sess.err(\"the evaluated program leaked memory\");\n                     tcx.sess.note_without_error(\"pass `-Zmiri-ignore-leaks` to disable this check\");"}, {"sha": "9e4527d592b3736125144cbe7c2f0d8ea7ac46eb", "filename": "src/helpers.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/6e1f3cd8ff080b85f6ba71b3f90300aca194a434/src%2Fhelpers.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e1f3cd8ff080b85f6ba71b3f90300aca194a434/src%2Fhelpers.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fhelpers.rs?ref=6e1f3cd8ff080b85f6ba71b3f90300aca194a434", "patch": "@@ -199,11 +199,11 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n             getrandom::getrandom(&mut data)\n                 .map_err(|err| err_unsup_format!(\"host getrandom failed: {}\", err))?;\n         } else {\n-            let rng = this.memory.extra.rng.get_mut();\n+            let rng = this.machine.rng.get_mut();\n             rng.fill_bytes(&mut data);\n         }\n \n-        this.memory.write_bytes(ptr, data.iter().copied())\n+        this.write_bytes_ptr(ptr, data.iter().copied())\n     }\n \n     /// Call a function: Push the stack frame and pass the arguments.\n@@ -645,7 +645,8 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         loop {\n             // FIXME: We are re-getting the allocation each time around the loop.\n             // Would be nice if we could somehow \"extend\" an existing AllocRange.\n-            let alloc = this.memory.get(ptr.offset(len, this)?.into(), size1, Align::ONE)?.unwrap(); // not a ZST, so we will get a result\n+            let alloc =\n+                this.get_ptr_alloc(ptr.offset(len, this)?.into(), size1, Align::ONE)?.unwrap(); // not a ZST, so we will get a result\n             let byte = alloc.read_scalar(alloc_range(Size::ZERO, size1))?.to_u8()?;\n             if byte == 0 {\n                 break;\n@@ -655,7 +656,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         }\n \n         // Step 2: get the bytes.\n-        this.memory.read_bytes(ptr.into(), len)\n+        this.read_bytes_ptr(ptr.into(), len)\n     }\n \n     fn read_wide_str(&self, mut ptr: Pointer<Option<Tag>>) -> InterpResult<'tcx, Vec<u16>> {\n@@ -667,7 +668,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         loop {\n             // FIXME: We are re-getting the allocation each time around the loop.\n             // Would be nice if we could somehow \"extend\" an existing AllocRange.\n-            let alloc = this.memory.get(ptr.into(), size2, align2)?.unwrap(); // not a ZST, so we will get a result\n+            let alloc = this.get_ptr_alloc(ptr.into(), size2, align2)?.unwrap(); // not a ZST, so we will get a result\n             let wchar = alloc.read_scalar(alloc_range(Size::ZERO, size2))?.to_u16()?;\n             if wchar == 0 {\n                 break;\n@@ -750,8 +751,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n     /// Mark a machine allocation that was just created as immutable.\n     fn mark_immutable(&mut self, mplace: &MemPlace<Tag>) {\n         let this = self.eval_context_mut();\n-        this.memory\n-            .mark_immutable(mplace.ptr.into_pointer_or_addr().unwrap().provenance.alloc_id)\n+        this.alloc_mark_immutable(mplace.ptr.into_pointer_or_addr().unwrap().provenance.alloc_id)\n             .unwrap();\n     }\n }"}, {"sha": "b1c96c7f1e7c5bfe85bbbbc2712d194949bb2570", "filename": "src/intptrcast.rs", "status": "modified", "additions": 24, "deletions": 32, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/6e1f3cd8ff080b85f6ba71b3f90300aca194a434/src%2Fintptrcast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e1f3cd8ff080b85f6ba71b3f90300aca194a434/src%2Fintptrcast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fintptrcast.rs?ref=6e1f3cd8ff080b85f6ba71b3f90300aca194a434", "patch": "@@ -9,10 +9,10 @@ use rustc_target::abi::{HasDataLayout, Size};\n \n use crate::*;\n \n-pub type MemoryExtra = RefCell<GlobalState>;\n+pub type GlobalState = RefCell<GlobalStateInner>;\n \n #[derive(Clone, Debug)]\n-pub struct GlobalState {\n+pub struct GlobalStateInner {\n     /// This is used as a map between the address of each allocation and its `AllocId`.\n     /// It is always sorted\n     int_to_ptr_map: Vec<(u64, AllocId)>,\n@@ -29,9 +29,9 @@ pub struct GlobalState {\n     strict_provenance: bool,\n }\n \n-impl GlobalState {\n+impl GlobalStateInner {\n     pub fn new(config: &MiriConfig) -> Self {\n-        GlobalState {\n+        GlobalStateInner {\n             int_to_ptr_map: Vec::default(),\n             base_addr: FxHashMap::default(),\n             next_base_addr: STACK_ADDR,\n@@ -40,13 +40,10 @@ impl GlobalState {\n     }\n }\n \n-impl<'mir, 'tcx> GlobalState {\n-    pub fn ptr_from_addr(\n-        addr: u64,\n-        memory: &Memory<'mir, 'tcx, Evaluator<'mir, 'tcx>>,\n-    ) -> Pointer<Option<Tag>> {\n+impl<'mir, 'tcx> GlobalStateInner {\n+    pub fn ptr_from_addr(addr: u64, ecx: &MiriEvalContext<'mir, 'tcx>) -> Pointer<Option<Tag>> {\n         trace!(\"Casting 0x{:x} to a pointer\", addr);\n-        let global_state = memory.extra.intptrcast.borrow();\n+        let global_state = ecx.machine.intptrcast.borrow();\n \n         if global_state.strict_provenance {\n             return Pointer::new(None, Size::from_bytes(addr));\n@@ -64,7 +61,11 @@ impl<'mir, 'tcx> GlobalState {\n                 let offset = addr - glb;\n                 // If the offset exceeds the size of the allocation, don't use this `alloc_id`.\n                 if offset\n-                    <= memory.get_size_and_align(alloc_id, AllocCheck::MaybeDead).unwrap().0.bytes()\n+                    <= ecx\n+                        .get_alloc_size_and_align(alloc_id, AllocCheck::MaybeDead)\n+                        .unwrap()\n+                        .0\n+                        .bytes()\n                 {\n                     Some(alloc_id)\n                 } else {\n@@ -79,11 +80,8 @@ impl<'mir, 'tcx> GlobalState {\n         )\n     }\n \n-    fn alloc_base_addr(\n-        memory: &Memory<'mir, 'tcx, Evaluator<'mir, 'tcx>>,\n-        alloc_id: AllocId,\n-    ) -> u64 {\n-        let mut global_state = memory.extra.intptrcast.borrow_mut();\n+    fn alloc_base_addr(ecx: &MiriEvalContext<'mir, 'tcx>, alloc_id: AllocId) -> u64 {\n+        let mut global_state = ecx.machine.intptrcast.borrow_mut();\n         let global_state = &mut *global_state;\n \n         match global_state.base_addr.entry(alloc_id) {\n@@ -92,12 +90,12 @@ impl<'mir, 'tcx> GlobalState {\n                 // There is nothing wrong with a raw pointer being cast to an integer only after\n                 // it became dangling.  Hence `MaybeDead`.\n                 let (size, align) =\n-                    memory.get_size_and_align(alloc_id, AllocCheck::MaybeDead).unwrap();\n+                    ecx.get_alloc_size_and_align(alloc_id, AllocCheck::MaybeDead).unwrap();\n \n                 // This allocation does not have a base address yet, pick one.\n                 // Leave some space to the previous allocation, to give it some chance to be less aligned.\n                 let slack = {\n-                    let mut rng = memory.extra.rng.borrow_mut();\n+                    let mut rng = ecx.machine.rng.borrow_mut();\n                     // This means that `(global_state.next_base_addr + slack) % 16` is uniformly distributed.\n                     rng.gen_range(0..16)\n                 };\n@@ -129,27 +127,21 @@ impl<'mir, 'tcx> GlobalState {\n     }\n \n     /// Convert a relative (tcx) pointer to an absolute address.\n-    pub fn rel_ptr_to_addr(\n-        memory: &Memory<'mir, 'tcx, Evaluator<'mir, 'tcx>>,\n-        ptr: Pointer<AllocId>,\n-    ) -> u64 {\n+    pub fn rel_ptr_to_addr(ecx: &MiriEvalContext<'mir, 'tcx>, ptr: Pointer<AllocId>) -> u64 {\n         let (alloc_id, offset) = ptr.into_parts(); // offset is relative\n-        let base_addr = GlobalState::alloc_base_addr(memory, alloc_id);\n+        let base_addr = GlobalStateInner::alloc_base_addr(ecx, alloc_id);\n \n         // Add offset with the right kind of pointer-overflowing arithmetic.\n-        let dl = memory.data_layout();\n+        let dl = ecx.data_layout();\n         dl.overflowing_offset(base_addr, offset.bytes()).0\n     }\n \n-    pub fn abs_ptr_to_rel(\n-        memory: &Memory<'mir, 'tcx, Evaluator<'mir, 'tcx>>,\n-        ptr: Pointer<Tag>,\n-    ) -> Size {\n+    pub fn abs_ptr_to_rel(ecx: &MiriEvalContext<'mir, 'tcx>, ptr: Pointer<Tag>) -> Size {\n         let (tag, addr) = ptr.into_parts(); // addr is absolute\n-        let base_addr = GlobalState::alloc_base_addr(memory, tag.alloc_id);\n+        let base_addr = GlobalStateInner::alloc_base_addr(ecx, tag.alloc_id);\n \n         // Wrapping \"addr - base_addr\"\n-        let dl = memory.data_layout();\n+        let dl = ecx.data_layout();\n         let neg_base_addr = (base_addr as i64).wrapping_neg();\n         Size::from_bytes(dl.overflowing_signed_offset(addr.bytes(), neg_base_addr).0)\n     }\n@@ -170,7 +162,7 @@ mod tests {\n \n     #[test]\n     fn test_align_addr() {\n-        assert_eq!(GlobalState::align_addr(37, 4), 40);\n-        assert_eq!(GlobalState::align_addr(44, 4), 44);\n+        assert_eq!(GlobalStateInner::align_addr(37, 4), 40);\n+        assert_eq!(GlobalStateInner::align_addr(44, 4), 44);\n     }\n }"}, {"sha": "f14120ae4ccc14416a10e43b38856ba83395bdf1", "filename": "src/lib.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6e1f3cd8ff080b85f6ba71b3f90300aca194a434/src%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e1f3cd8ff080b85f6ba71b3f90300aca194a434/src%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib.rs?ref=6e1f3cd8ff080b85f6ba71b3f90300aca194a434", "patch": "@@ -66,8 +66,8 @@ pub use crate::eval::{\n };\n pub use crate::helpers::EvalContextExt as HelpersEvalContextExt;\n pub use crate::machine::{\n-    AllocExtra, Evaluator, FrameData, MemoryExtra, MiriEvalContext, MiriEvalContextExt,\n-    MiriMemoryKind, Tag, NUM_CPUS, PAGE_SIZE, STACK_ADDR, STACK_SIZE,\n+    AllocExtra, Evaluator, FrameData, MiriEvalContext, MiriEvalContextExt, MiriMemoryKind, Tag,\n+    NUM_CPUS, PAGE_SIZE, STACK_ADDR, STACK_SIZE,\n };\n pub use crate::mono_hash_map::MonoHashMap;\n pub use crate::operator::EvalContextExt as OperatorEvalContextExt;"}, {"sha": "9108f4f1666312b76eb25b6662c3e248d63053ac", "filename": "src/machine.rs", "status": "modified", "additions": 139, "deletions": 145, "changes": 284, "blob_url": "https://github.com/rust-lang/rust/blob/6e1f3cd8ff080b85f6ba71b3f90300aca194a434/src%2Fmachine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e1f3cd8ff080b85f6ba71b3f90300aca194a434/src%2Fmachine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fmachine.rs?ref=6e1f3cd8ff080b85f6ba71b3f90300aca194a434", "patch": "@@ -163,103 +163,6 @@ pub struct AllocExtra {\n     pub data_race: Option<data_race::AllocExtra>,\n }\n \n-/// Extra global memory data\n-#[derive(Debug)]\n-pub struct MemoryExtra {\n-    pub stacked_borrows: Option<stacked_borrows::MemoryExtra>,\n-    pub data_race: Option<data_race::MemoryExtra>,\n-    pub intptrcast: intptrcast::MemoryExtra,\n-\n-    /// Mapping extern static names to their base pointer.\n-    extern_statics: FxHashMap<Symbol, Pointer<Tag>>,\n-\n-    /// The random number generator used for resolving non-determinism.\n-    /// Needs to be queried by ptr_to_int, hence needs interior mutability.\n-    pub(crate) rng: RefCell<StdRng>,\n-\n-    /// An allocation ID to report when it is being allocated\n-    /// (helps for debugging memory leaks and use after free bugs).\n-    tracked_alloc_id: Option<AllocId>,\n-\n-    /// Controls whether alignment of memory accesses is being checked.\n-    pub(crate) check_alignment: AlignmentCheck,\n-\n-    /// Failure rate of compare_exchange_weak, between 0.0 and 1.0\n-    pub(crate) cmpxchg_weak_failure_rate: f64,\n-}\n-\n-impl MemoryExtra {\n-    pub fn new(config: &MiriConfig) -> Self {\n-        let rng = StdRng::seed_from_u64(config.seed.unwrap_or(0));\n-        let stacked_borrows = if config.stacked_borrows {\n-            Some(RefCell::new(stacked_borrows::GlobalState::new(\n-                config.tracked_pointer_tag,\n-                config.tracked_call_id,\n-                config.tag_raw,\n-            )))\n-        } else {\n-            None\n-        };\n-        let data_race =\n-            if config.data_race_detector { Some(data_race::GlobalState::new()) } else { None };\n-        MemoryExtra {\n-            stacked_borrows,\n-            data_race,\n-            intptrcast: RefCell::new(intptrcast::GlobalState::new(config)),\n-            extern_statics: FxHashMap::default(),\n-            rng: RefCell::new(rng),\n-            tracked_alloc_id: config.tracked_alloc_id,\n-            check_alignment: config.check_alignment,\n-            cmpxchg_weak_failure_rate: config.cmpxchg_weak_failure_rate,\n-        }\n-    }\n-\n-    fn add_extern_static<'tcx, 'mir>(\n-        this: &mut MiriEvalContext<'mir, 'tcx>,\n-        name: &str,\n-        ptr: Pointer<Option<Tag>>,\n-    ) {\n-        let ptr = ptr.into_pointer_or_addr().unwrap();\n-        this.memory.extra.extern_statics.try_insert(Symbol::intern(name), ptr).unwrap();\n-    }\n-\n-    /// Sets up the \"extern statics\" for this machine.\n-    pub fn init_extern_statics<'tcx, 'mir>(\n-        this: &mut MiriEvalContext<'mir, 'tcx>,\n-    ) -> InterpResult<'tcx> {\n-        match this.tcx.sess.target.os.as_ref() {\n-            \"linux\" => {\n-                // \"environ\"\n-                Self::add_extern_static(\n-                    this,\n-                    \"environ\",\n-                    this.machine.env_vars.environ.unwrap().ptr,\n-                );\n-                // A couple zero-initialized pointer-sized extern statics.\n-                // Most of them are for weak symbols, which we all set to null (indicating that the\n-                // symbol is not supported, and triggering fallback code which ends up calling a\n-                // syscall that we do support).\n-                for name in &[\"__cxa_thread_atexit_impl\", \"getrandom\", \"statx\"] {\n-                    let layout = this.machine.layouts.usize;\n-                    let place = this.allocate(layout, MiriMemoryKind::ExternStatic.into())?;\n-                    this.write_scalar(Scalar::from_machine_usize(0, this), &place.into())?;\n-                    Self::add_extern_static(this, name, place.ptr);\n-                }\n-            }\n-            \"windows\" => {\n-                // \"_tls_used\"\n-                // This is some obscure hack that is part of the Windows TLS story. It's a `u8`.\n-                let layout = this.machine.layouts.u8;\n-                let place = this.allocate(layout, MiriMemoryKind::ExternStatic.into())?;\n-                this.write_scalar(Scalar::from_u8(0), &place.into())?;\n-                Self::add_extern_static(this, \"_tls_used\", place.ptr);\n-            }\n-            _ => {} // No \"extern statics\" supported on this target\n-        }\n-        Ok(())\n-    }\n-}\n-\n /// Precomputed layouts of primitive types\n pub struct PrimitiveLayouts<'tcx> {\n     pub unit: TyAndLayout<'tcx>,\n@@ -293,6 +196,10 @@ impl<'mir, 'tcx: 'mir> PrimitiveLayouts<'tcx> {\n \n /// The machine itself.\n pub struct Evaluator<'mir, 'tcx> {\n+    pub stacked_borrows: Option<stacked_borrows::GlobalState>,\n+    pub data_race: Option<data_race::GlobalState>,\n+    pub intptrcast: intptrcast::GlobalState,\n+\n     /// Environment variables set by `setenv`.\n     /// Miri does not expose env vars from the host to the emulated program.\n     pub(crate) env_vars: EnvVars<'tcx>,\n@@ -357,6 +264,23 @@ pub struct Evaluator<'mir, 'tcx> {\n \n     /// Crates which are considered local for the purposes of error reporting.\n     pub(crate) local_crates: Vec<CrateNum>,\n+\n+    /// Mapping extern static names to their base pointer.\n+    extern_statics: FxHashMap<Symbol, Pointer<Tag>>,\n+\n+    /// The random number generator used for resolving non-determinism.\n+    /// Needs to be queried by ptr_to_int, hence needs interior mutability.\n+    pub(crate) rng: RefCell<StdRng>,\n+\n+    /// An allocation ID to report when it is being allocated\n+    /// (helps for debugging memory leaks and use after free bugs).\n+    tracked_alloc_id: Option<AllocId>,\n+\n+    /// Controls whether alignment of memory accesses is being checked.\n+    pub(crate) check_alignment: AlignmentCheck,\n+\n+    /// Failure rate of compare_exchange_weak, between 0.0 and 1.0\n+    pub(crate) cmpxchg_weak_failure_rate: f64,\n }\n \n impl<'mir, 'tcx> Evaluator<'mir, 'tcx> {\n@@ -367,9 +291,23 @@ impl<'mir, 'tcx> Evaluator<'mir, 'tcx> {\n         let profiler = config.measureme_out.as_ref().map(|out| {\n             measureme::Profiler::new(out).expect(\"Couldn't create `measureme` profiler\")\n         });\n+        let rng = StdRng::seed_from_u64(config.seed.unwrap_or(0));\n+        let stacked_borrows = if config.stacked_borrows {\n+            Some(RefCell::new(stacked_borrows::GlobalStateInner::new(\n+                config.tracked_pointer_tag,\n+                config.tracked_call_id,\n+                config.tag_raw,\n+            )))\n+        } else {\n+            None\n+        };\n+        let data_race =\n+            if config.data_race_detector { Some(data_race::GlobalState::new()) } else { None };\n         Evaluator {\n-            // `env_vars` could be initialized properly here if `Memory` were available before\n-            // calling this method.\n+            stacked_borrows,\n+            data_race,\n+            intptrcast: RefCell::new(intptrcast::GlobalStateInner::new(config)),\n+            // `env_vars` depends on a full interpreter so we cannot properly initialize it yet.\n             env_vars: EnvVars::default(),\n             argc: None,\n             argv: None,\n@@ -391,7 +329,64 @@ impl<'mir, 'tcx> Evaluator<'mir, 'tcx> {\n             panic_on_unsupported: config.panic_on_unsupported,\n             backtrace_style: config.backtrace_style,\n             local_crates,\n+            extern_statics: FxHashMap::default(),\n+            rng: RefCell::new(rng),\n+            tracked_alloc_id: config.tracked_alloc_id,\n+            check_alignment: config.check_alignment,\n+            cmpxchg_weak_failure_rate: config.cmpxchg_weak_failure_rate,\n+        }\n+    }\n+\n+    pub(crate) fn late_init(\n+        this: &mut MiriEvalContext<'mir, 'tcx>,\n+        config: &MiriConfig,\n+    ) -> InterpResult<'tcx> {\n+        EnvVars::init(this, config)?;\n+        Evaluator::init_extern_statics(this)?;\n+        Ok(())\n+    }\n+\n+    fn add_extern_static(\n+        this: &mut MiriEvalContext<'mir, 'tcx>,\n+        name: &str,\n+        ptr: Pointer<Option<Tag>>,\n+    ) {\n+        let ptr = ptr.into_pointer_or_addr().unwrap();\n+        this.machine.extern_statics.try_insert(Symbol::intern(name), ptr).unwrap();\n+    }\n+\n+    /// Sets up the \"extern statics\" for this machine.\n+    fn init_extern_statics(this: &mut MiriEvalContext<'mir, 'tcx>) -> InterpResult<'tcx> {\n+        match this.tcx.sess.target.os.as_ref() {\n+            \"linux\" => {\n+                // \"environ\"\n+                Self::add_extern_static(\n+                    this,\n+                    \"environ\",\n+                    this.machine.env_vars.environ.unwrap().ptr,\n+                );\n+                // A couple zero-initialized pointer-sized extern statics.\n+                // Most of them are for weak symbols, which we all set to null (indicating that the\n+                // symbol is not supported, and triggering fallback code which ends up calling a\n+                // syscall that we do support).\n+                for name in &[\"__cxa_thread_atexit_impl\", \"getrandom\", \"statx\"] {\n+                    let layout = this.machine.layouts.usize;\n+                    let place = this.allocate(layout, MiriMemoryKind::ExternStatic.into())?;\n+                    this.write_scalar(Scalar::from_machine_usize(0, this), &place.into())?;\n+                    Self::add_extern_static(this, name, place.ptr);\n+                }\n+            }\n+            \"windows\" => {\n+                // \"_tls_used\"\n+                // This is some obscure hack that is part of the Windows TLS story. It's a `u8`.\n+                let layout = this.machine.layouts.u8;\n+                let place = this.allocate(layout, MiriMemoryKind::ExternStatic.into())?;\n+                this.write_scalar(Scalar::from_u8(0), &place.into())?;\n+                Self::add_extern_static(this, \"_tls_used\", place.ptr);\n+            }\n+            _ => {} // No \"extern statics\" supported on this target\n         }\n+        Ok(())\n     }\n \n     pub(crate) fn communicate(&self) -> bool {\n@@ -429,7 +424,6 @@ impl<'mir, 'tcx> Machine<'mir, 'tcx> for Evaluator<'mir, 'tcx> {\n     type MemoryKind = MiriMemoryKind;\n \n     type FrameExtra = FrameData<'tcx>;\n-    type MemoryExtra = MemoryExtra;\n     type AllocExtra = AllocExtra;\n     type PointerTag = Tag;\n     type ExtraFnVal = Dlsym;\n@@ -442,33 +436,33 @@ impl<'mir, 'tcx> Machine<'mir, 'tcx> for Evaluator<'mir, 'tcx> {\n     const PANIC_ON_ALLOC_FAIL: bool = false;\n \n     #[inline(always)]\n-    fn enforce_alignment(memory_extra: &MemoryExtra) -> bool {\n-        memory_extra.check_alignment != AlignmentCheck::None\n+    fn enforce_alignment(ecx: &MiriEvalContext<'mir, 'tcx>) -> bool {\n+        ecx.machine.check_alignment != AlignmentCheck::None\n     }\n \n     #[inline(always)]\n-    fn force_int_for_alignment_check(memory_extra: &Self::MemoryExtra) -> bool {\n-        memory_extra.check_alignment == AlignmentCheck::Int\n+    fn force_int_for_alignment_check(ecx: &MiriEvalContext<'mir, 'tcx>) -> bool {\n+        ecx.machine.check_alignment == AlignmentCheck::Int\n     }\n \n     #[inline(always)]\n-    fn enforce_validity(ecx: &InterpCx<'mir, 'tcx, Self>) -> bool {\n+    fn enforce_validity(ecx: &MiriEvalContext<'mir, 'tcx>) -> bool {\n         ecx.machine.validate\n     }\n \n     #[inline(always)]\n-    fn enforce_number_validity(ecx: &InterpCx<'mir, 'tcx, Self>) -> bool {\n+    fn enforce_number_validity(ecx: &MiriEvalContext<'mir, 'tcx>) -> bool {\n         ecx.machine.enforce_number_validity\n     }\n \n     #[inline(always)]\n-    fn enforce_abi(ecx: &InterpCx<'mir, 'tcx, Self>) -> bool {\n+    fn enforce_abi(ecx: &MiriEvalContext<'mir, 'tcx>) -> bool {\n         ecx.machine.enforce_abi\n     }\n \n     #[inline(always)]\n     fn find_mir_or_eval_fn(\n-        ecx: &mut InterpCx<'mir, 'tcx, Self>,\n+        ecx: &mut MiriEvalContext<'mir, 'tcx>,\n         instance: ty::Instance<'tcx>,\n         abi: Abi,\n         args: &[OpTy<'tcx, Tag>],\n@@ -480,7 +474,7 @@ impl<'mir, 'tcx> Machine<'mir, 'tcx> for Evaluator<'mir, 'tcx> {\n \n     #[inline(always)]\n     fn call_extra_fn(\n-        ecx: &mut InterpCx<'mir, 'tcx, Self>,\n+        ecx: &mut MiriEvalContext<'mir, 'tcx>,\n         fn_val: Dlsym,\n         abi: Abi,\n         args: &[OpTy<'tcx, Tag>],\n@@ -492,7 +486,7 @@ impl<'mir, 'tcx> Machine<'mir, 'tcx> for Evaluator<'mir, 'tcx> {\n \n     #[inline(always)]\n     fn call_intrinsic(\n-        ecx: &mut rustc_const_eval::interpret::InterpCx<'mir, 'tcx, Self>,\n+        ecx: &mut MiriEvalContext<'mir, 'tcx>,\n         instance: ty::Instance<'tcx>,\n         args: &[OpTy<'tcx, Tag>],\n         ret: Option<(&PlaceTy<'tcx, Tag>, mir::BasicBlock)>,\n@@ -503,21 +497,21 @@ impl<'mir, 'tcx> Machine<'mir, 'tcx> for Evaluator<'mir, 'tcx> {\n \n     #[inline(always)]\n     fn assert_panic(\n-        ecx: &mut InterpCx<'mir, 'tcx, Self>,\n+        ecx: &mut MiriEvalContext<'mir, 'tcx>,\n         msg: &mir::AssertMessage<'tcx>,\n         unwind: Option<mir::BasicBlock>,\n     ) -> InterpResult<'tcx> {\n         ecx.assert_panic(msg, unwind)\n     }\n \n     #[inline(always)]\n-    fn abort(_ecx: &mut InterpCx<'mir, 'tcx, Self>, msg: String) -> InterpResult<'tcx, !> {\n+    fn abort(_ecx: &mut MiriEvalContext<'mir, 'tcx>, msg: String) -> InterpResult<'tcx, !> {\n         throw_machine_stop!(TerminationInfo::Abort(msg))\n     }\n \n     #[inline(always)]\n     fn binary_ptr_op(\n-        ecx: &rustc_const_eval::interpret::InterpCx<'mir, 'tcx, Self>,\n+        ecx: &MiriEvalContext<'mir, 'tcx>,\n         bin_op: mir::BinOp,\n         left: &ImmTy<'tcx, Tag>,\n         right: &ImmTy<'tcx, Tag>,\n@@ -526,64 +520,64 @@ impl<'mir, 'tcx> Machine<'mir, 'tcx> for Evaluator<'mir, 'tcx> {\n     }\n \n     fn thread_local_static_base_pointer(\n-        ecx: &mut InterpCx<'mir, 'tcx, Self>,\n+        ecx: &mut MiriEvalContext<'mir, 'tcx>,\n         def_id: DefId,\n     ) -> InterpResult<'tcx, Pointer<Tag>> {\n         ecx.get_or_create_thread_local_alloc(def_id)\n     }\n \n     fn extern_static_base_pointer(\n-        memory: &Memory<'mir, 'tcx, Self>,\n+        ecx: &MiriEvalContext<'mir, 'tcx>,\n         def_id: DefId,\n     ) -> InterpResult<'tcx, Pointer<Tag>> {\n-        let attrs = memory.tcx.get_attrs(def_id);\n-        let link_name = match memory.tcx.sess.first_attr_value_str_by_name(&attrs, sym::link_name) {\n+        let attrs = ecx.tcx.get_attrs(def_id);\n+        let link_name = match ecx.tcx.sess.first_attr_value_str_by_name(&attrs, sym::link_name) {\n             Some(name) => name,\n-            None => memory.tcx.item_name(def_id),\n+            None => ecx.tcx.item_name(def_id),\n         };\n-        if let Some(&ptr) = memory.extra.extern_statics.get(&link_name) {\n+        if let Some(&ptr) = ecx.machine.extern_statics.get(&link_name) {\n             Ok(ptr)\n         } else {\n             throw_unsup_format!(\"`extern` static {:?} is not supported by Miri\", def_id)\n         }\n     }\n \n     fn init_allocation_extra<'b>(\n-        mem: &Memory<'mir, 'tcx, Self>,\n+        ecx: &MiriEvalContext<'mir, 'tcx>,\n         id: AllocId,\n         alloc: Cow<'b, Allocation>,\n         kind: Option<MemoryKind<Self::MemoryKind>>,\n     ) -> Cow<'b, Allocation<Self::PointerTag, Self::AllocExtra>> {\n-        if Some(id) == mem.extra.tracked_alloc_id {\n+        if Some(id) == ecx.machine.tracked_alloc_id {\n             register_diagnostic(NonHaltingDiagnostic::CreatedAlloc(id));\n         }\n \n         let kind = kind.expect(\"we set our STATIC_KIND so this cannot be None\");\n         let alloc = alloc.into_owned();\n-        let stacks = if let Some(stacked_borrows) = &mem.extra.stacked_borrows {\n+        let stacks = if let Some(stacked_borrows) = &ecx.machine.stacked_borrows {\n             Some(Stacks::new_allocation(id, alloc.size(), stacked_borrows, kind))\n         } else {\n             None\n         };\n-        let race_alloc = if let Some(data_race) = &mem.extra.data_race {\n+        let race_alloc = if let Some(data_race) = &ecx.machine.data_race {\n             Some(data_race::AllocExtra::new_allocation(&data_race, alloc.size(), kind))\n         } else {\n             None\n         };\n         let alloc: Allocation<Tag, Self::AllocExtra> = alloc.convert_tag_add_extra(\n-            &mem.tcx,\n+            &ecx.tcx,\n             AllocExtra { stacked_borrows: stacks, data_race: race_alloc },\n-            |ptr| Evaluator::tag_alloc_base_pointer(mem, ptr),\n+            |ptr| Evaluator::tag_alloc_base_pointer(ecx, ptr),\n         );\n         Cow::Owned(alloc)\n     }\n \n     fn tag_alloc_base_pointer(\n-        mem: &Memory<'mir, 'tcx, Self>,\n+        ecx: &MiriEvalContext<'mir, 'tcx>,\n         ptr: Pointer<AllocId>,\n     ) -> Pointer<Tag> {\n-        let absolute_addr = intptrcast::GlobalState::rel_ptr_to_addr(&mem, ptr);\n-        let sb_tag = if let Some(stacked_borrows) = &mem.extra.stacked_borrows {\n+        let absolute_addr = intptrcast::GlobalStateInner::rel_ptr_to_addr(ecx, ptr);\n+        let sb_tag = if let Some(stacked_borrows) = &ecx.machine.stacked_borrows {\n             stacked_borrows.borrow_mut().base_tag(ptr.provenance)\n         } else {\n             SbTag::Untagged\n@@ -593,38 +587,38 @@ impl<'mir, 'tcx> Machine<'mir, 'tcx> for Evaluator<'mir, 'tcx> {\n \n     #[inline(always)]\n     fn ptr_from_addr(\n-        mem: &Memory<'mir, 'tcx, Self>,\n+        ecx: &MiriEvalContext<'mir, 'tcx>,\n         addr: u64,\n     ) -> Pointer<Option<Self::PointerTag>> {\n-        intptrcast::GlobalState::ptr_from_addr(addr, mem)\n+        intptrcast::GlobalStateInner::ptr_from_addr(addr, ecx)\n     }\n \n     /// Convert a pointer with provenance into an allocation-offset pair,\n     /// or a `None` with an absolute address if that conversion is not possible.\n     fn ptr_get_alloc(\n-        mem: &Memory<'mir, 'tcx, Self>,\n+        ecx: &MiriEvalContext<'mir, 'tcx>,\n         ptr: Pointer<Self::PointerTag>,\n     ) -> (AllocId, Size) {\n-        let rel = intptrcast::GlobalState::abs_ptr_to_rel(mem, ptr);\n+        let rel = intptrcast::GlobalStateInner::abs_ptr_to_rel(ecx, ptr);\n         (ptr.provenance.alloc_id, rel)\n     }\n \n     #[inline(always)]\n     fn memory_read(\n-        memory_extra: &Self::MemoryExtra,\n+        machine: &Self,\n         alloc_extra: &AllocExtra,\n         tag: Tag,\n         range: AllocRange,\n     ) -> InterpResult<'tcx> {\n         if let Some(data_race) = &alloc_extra.data_race {\n-            data_race.read(tag.alloc_id, range, memory_extra.data_race.as_ref().unwrap())?;\n+            data_race.read(tag.alloc_id, range, machine.data_race.as_ref().unwrap())?;\n         }\n         if let Some(stacked_borrows) = &alloc_extra.stacked_borrows {\n             stacked_borrows.memory_read(\n                 tag.alloc_id,\n                 tag.sb,\n                 range,\n-                memory_extra.stacked_borrows.as_ref().unwrap(),\n+                machine.stacked_borrows.as_ref().unwrap(),\n             )\n         } else {\n             Ok(())\n@@ -633,20 +627,20 @@ impl<'mir, 'tcx> Machine<'mir, 'tcx> for Evaluator<'mir, 'tcx> {\n \n     #[inline(always)]\n     fn memory_written(\n-        memory_extra: &mut Self::MemoryExtra,\n+        machine: &mut Self,\n         alloc_extra: &mut AllocExtra,\n         tag: Tag,\n         range: AllocRange,\n     ) -> InterpResult<'tcx> {\n         if let Some(data_race) = &mut alloc_extra.data_race {\n-            data_race.write(tag.alloc_id, range, memory_extra.data_race.as_mut().unwrap())?;\n+            data_race.write(tag.alloc_id, range, machine.data_race.as_mut().unwrap())?;\n         }\n         if let Some(stacked_borrows) = &mut alloc_extra.stacked_borrows {\n             stacked_borrows.memory_written(\n                 tag.alloc_id,\n                 tag.sb,\n                 range,\n-                memory_extra.stacked_borrows.as_mut().unwrap(),\n+                machine.stacked_borrows.as_mut().unwrap(),\n             )\n         } else {\n             Ok(())\n@@ -655,23 +649,23 @@ impl<'mir, 'tcx> Machine<'mir, 'tcx> for Evaluator<'mir, 'tcx> {\n \n     #[inline(always)]\n     fn memory_deallocated(\n-        memory_extra: &mut Self::MemoryExtra,\n+        machine: &mut Self,\n         alloc_extra: &mut AllocExtra,\n         tag: Tag,\n         range: AllocRange,\n     ) -> InterpResult<'tcx> {\n-        if Some(tag.alloc_id) == memory_extra.tracked_alloc_id {\n+        if Some(tag.alloc_id) == machine.tracked_alloc_id {\n             register_diagnostic(NonHaltingDiagnostic::FreedAlloc(tag.alloc_id));\n         }\n         if let Some(data_race) = &mut alloc_extra.data_race {\n-            data_race.deallocate(tag.alloc_id, range, memory_extra.data_race.as_mut().unwrap())?;\n+            data_race.deallocate(tag.alloc_id, range, machine.data_race.as_mut().unwrap())?;\n         }\n         if let Some(stacked_borrows) = &mut alloc_extra.stacked_borrows {\n             stacked_borrows.memory_deallocated(\n                 tag.alloc_id,\n                 tag.sb,\n                 range,\n-                memory_extra.stacked_borrows.as_mut().unwrap(),\n+                machine.stacked_borrows.as_mut().unwrap(),\n             )\n         } else {\n             Ok(())\n@@ -684,7 +678,7 @@ impl<'mir, 'tcx> Machine<'mir, 'tcx> for Evaluator<'mir, 'tcx> {\n         kind: mir::RetagKind,\n         place: &PlaceTy<'tcx, Tag>,\n     ) -> InterpResult<'tcx> {\n-        if ecx.memory.extra.stacked_borrows.is_some() { ecx.retag(kind, place) } else { Ok(()) }\n+        if ecx.machine.stacked_borrows.is_some() { ecx.retag(kind, place) } else { Ok(()) }\n     }\n \n     #[inline(always)]\n@@ -707,7 +701,7 @@ impl<'mir, 'tcx> Machine<'mir, 'tcx> for Evaluator<'mir, 'tcx> {\n             None\n         };\n \n-        let stacked_borrows = ecx.memory.extra.stacked_borrows.as_ref();\n+        let stacked_borrows = ecx.machine.stacked_borrows.as_ref();\n         let call_id = stacked_borrows.map_or(NonZeroU64::new(1).unwrap(), |stacked_borrows| {\n             stacked_borrows.borrow_mut().new_call()\n         });\n@@ -730,7 +724,7 @@ impl<'mir, 'tcx> Machine<'mir, 'tcx> for Evaluator<'mir, 'tcx> {\n \n     #[inline(always)]\n     fn after_stack_push(ecx: &mut InterpCx<'mir, 'tcx, Self>) -> InterpResult<'tcx> {\n-        if ecx.memory.extra.stacked_borrows.is_some() { ecx.retag_return_place() } else { Ok(()) }\n+        if ecx.machine.stacked_borrows.is_some() { ecx.retag_return_place() } else { Ok(()) }\n     }\n \n     #[inline(always)]"}, {"sha": "32fbbffc63f8e3ed992423425c5e4506598b2f79", "filename": "src/shims/backtrace.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/6e1f3cd8ff080b85f6ba71b3f90300aca194a434/src%2Fshims%2Fbacktrace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e1f3cd8ff080b85f6ba71b3f90300aca194a434/src%2Fshims%2Fbacktrace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fshims%2Fbacktrace.rs?ref=6e1f3cd8ff080b85f6ba71b3f90300aca194a434", "patch": "@@ -64,7 +64,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n                 // to reconstruct the needed frame information in `handle_miri_resolve_frame`.\n                 // Note that we never actually read or write anything from/to this pointer -\n                 // all of the data is represented by the pointer value itself.\n-                let fn_ptr = this.memory.create_fn_alloc(FnVal::Instance(instance));\n+                let fn_ptr = this.create_fn_alloc_ptr(FnVal::Instance(instance));\n                 fn_ptr.wrapping_offset(Size::from_bytes(pos.0), this)\n             })\n             .collect();\n@@ -125,7 +125,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n \n         let ptr = this.read_pointer(ptr)?;\n         // Take apart the pointer, we need its pieces.\n-        let (alloc_id, offset, ptr) = this.memory.ptr_get_alloc(ptr)?;\n+        let (alloc_id, offset, ptr) = this.ptr_get_alloc_id(ptr)?;\n \n         let fn_instance =\n             if let Some(GlobalAlloc::Function(instance)) = this.tcx.get_global_alloc(alloc_id) {\n@@ -159,7 +159,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n \n         // Reconstruct the original function pointer,\n         // which we pass to user code.\n-        let fn_ptr = this.memory.create_fn_alloc(FnVal::Instance(fn_instance));\n+        let fn_ptr = this.create_fn_alloc_ptr(FnVal::Instance(fn_instance));\n \n         let num_fields = dest.layout.fields.count();\n \n@@ -244,8 +244,8 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n \n         let (_, _, name, filename) = this.resolve_frame_pointer(ptr)?;\n \n-        this.memory.write_bytes(this.read_pointer(name_ptr)?, name.bytes())?;\n-        this.memory.write_bytes(this.read_pointer(filename_ptr)?, filename.bytes())?;\n+        this.write_bytes_ptr(this.read_pointer(name_ptr)?, name.bytes())?;\n+        this.write_bytes_ptr(this.read_pointer(filename_ptr)?, filename.bytes())?;\n \n         Ok(())\n     }"}, {"sha": "7be26de45916a07cf4fd5bd3cc42e34d25014861", "filename": "src/shims/env.rs", "status": "modified", "additions": 15, "deletions": 13, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/6e1f3cd8ff080b85f6ba71b3f90300aca194a434/src%2Fshims%2Fenv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e1f3cd8ff080b85f6ba71b3f90300aca194a434/src%2Fshims%2Fenv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fshims%2Fenv.rs?ref=6e1f3cd8ff080b85f6ba71b3f90300aca194a434", "patch": "@@ -2,6 +2,7 @@ use std::convert::TryFrom;\n use std::env;\n use std::ffi::{OsStr, OsString};\n use std::io::ErrorKind;\n+use std::mem;\n \n use rustc_const_eval::interpret::Pointer;\n use rustc_data_structures::fx::FxHashMap;\n@@ -38,20 +39,20 @@ pub struct EnvVars<'tcx> {\n impl<'tcx> EnvVars<'tcx> {\n     pub(crate) fn init<'mir>(\n         ecx: &mut InterpCx<'mir, 'tcx, Evaluator<'mir, 'tcx>>,\n-        mut excluded_env_vars: Vec<String>,\n-        forwarded_env_vars: Vec<String>,\n+        config: &MiriConfig,\n     ) -> InterpResult<'tcx> {\n         let target_os = ecx.tcx.sess.target.os.as_ref();\n         // HACK: Exclude `TERM` var to avoid terminfo trying to open the termcap file.\n         // This is (a) very slow and (b) does not work on Windows.\n+        let mut excluded_env_vars = config.excluded_env_vars.clone();\n         excluded_env_vars.push(\"TERM\".to_owned());\n \n         // Skip the loop entirely if we don't want to forward anything.\n-        if ecx.machine.communicate() || !forwarded_env_vars.is_empty() {\n+        if ecx.machine.communicate() || !config.forwarded_env_vars.is_empty() {\n             for (name, value) in env::vars_os() {\n                 let forward = match ecx.machine.communicate() {\n                     true => !excluded_env_vars.iter().any(|v| v.as_str() == &name),\n-                    false => forwarded_env_vars.iter().any(|v| v.as_str() == &name),\n+                    false => config.forwarded_env_vars.iter().any(|v| v.as_str() == &name),\n                 };\n                 if forward {\n                     let var_ptr = match target_os {\n@@ -75,13 +76,14 @@ impl<'tcx> EnvVars<'tcx> {\n         ecx: &mut InterpCx<'mir, 'tcx, Evaluator<'mir, 'tcx>>,\n     ) -> InterpResult<'tcx> {\n         // Deallocate individual env vars.\n-        for (_name, ptr) in ecx.machine.env_vars.map.drain() {\n-            ecx.memory.deallocate(ptr, None, MiriMemoryKind::Runtime.into())?;\n+        let env_vars = mem::take(&mut ecx.machine.env_vars.map);\n+        for (_name, ptr) in env_vars {\n+            ecx.deallocate_ptr(ptr, None, MiriMemoryKind::Runtime.into())?;\n         }\n         // Deallocate environ var list.\n         let environ = ecx.machine.env_vars.environ.unwrap();\n         let old_vars_ptr = ecx.read_pointer(&environ.into())?;\n-        ecx.memory.deallocate(old_vars_ptr, None, MiriMemoryKind::Runtime.into())?;\n+        ecx.deallocate_ptr(old_vars_ptr, None, MiriMemoryKind::Runtime.into())?;\n         Ok(())\n     }\n }\n@@ -199,7 +201,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         this.assert_target_os(\"windows\", \"FreeEnvironmentStringsW\");\n \n         let env_block_ptr = this.read_pointer(env_block_op)?;\n-        let result = this.memory.deallocate(env_block_ptr, None, MiriMemoryKind::Runtime.into());\n+        let result = this.deallocate_ptr(env_block_ptr, None, MiriMemoryKind::Runtime.into());\n         // If the function succeeds, the return value is nonzero.\n         Ok(result.is_ok() as i32)\n     }\n@@ -230,7 +232,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         if let Some((name, value)) = new {\n             let var_ptr = alloc_env_var_as_c_str(&name, &value, &mut this)?;\n             if let Some(var) = this.machine.env_vars.map.insert(name, var_ptr) {\n-                this.memory.deallocate(var, None, MiriMemoryKind::Runtime.into())?;\n+                this.deallocate_ptr(var, None, MiriMemoryKind::Runtime.into())?;\n             }\n             this.update_environ()?;\n             Ok(0) // return zero on success\n@@ -267,15 +269,15 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         } else if this.ptr_is_null(value_ptr)? {\n             // Delete environment variable `{name}`\n             if let Some(var) = this.machine.env_vars.map.remove(&name) {\n-                this.memory.deallocate(var, None, MiriMemoryKind::Runtime.into())?;\n+                this.deallocate_ptr(var, None, MiriMemoryKind::Runtime.into())?;\n                 this.update_environ()?;\n             }\n             Ok(1) // return non-zero on success\n         } else {\n             let value = this.read_os_str_from_wide_str(value_ptr)?;\n             let var_ptr = alloc_env_var_as_wide_str(&name, &value, &mut this)?;\n             if let Some(var) = this.machine.env_vars.map.insert(name, var_ptr) {\n-                this.memory.deallocate(var, None, MiriMemoryKind::Runtime.into())?;\n+                this.deallocate_ptr(var, None, MiriMemoryKind::Runtime.into())?;\n             }\n             this.update_environ()?;\n             Ok(1) // return non-zero on success\n@@ -300,7 +302,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         }\n         if let Some(old) = success {\n             if let Some(var) = old {\n-                this.memory.deallocate(var, None, MiriMemoryKind::Runtime.into())?;\n+                this.deallocate_ptr(var, None, MiriMemoryKind::Runtime.into())?;\n             }\n             this.update_environ()?;\n             Ok(0)\n@@ -436,7 +438,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         // Deallocate the old environ list, if any.\n         if let Some(environ) = this.machine.env_vars.environ {\n             let old_vars_ptr = this.read_pointer(&environ.into())?;\n-            this.memory.deallocate(old_vars_ptr, None, MiriMemoryKind::Runtime.into())?;\n+            this.deallocate_ptr(old_vars_ptr, None, MiriMemoryKind::Runtime.into())?;\n         } else {\n             // No `environ` allocated yet, let's do that.\n             // This is memory backing an extern static, hence `ExternStatic`, not `Env`."}, {"sha": "77567e9bcae59903d1965a557364e64e7e75b4ae", "filename": "src/shims/foreign_items.rs", "status": "modified", "additions": 16, "deletions": 18, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/6e1f3cd8ff080b85f6ba71b3f90300aca194a434/src%2Fshims%2Fforeign_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e1f3cd8ff080b85f6ba71b3f90300aca194a434/src%2Fshims%2Fforeign_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fshims%2Fforeign_items.rs?ref=6e1f3cd8ff080b85f6ba71b3f90300aca194a434", "patch": "@@ -82,10 +82,10 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n             Ok(Pointer::null())\n         } else {\n             let align = this.min_align(size, kind);\n-            let ptr = this.memory.allocate(Size::from_bytes(size), align, kind.into())?;\n+            let ptr = this.allocate_ptr(Size::from_bytes(size), align, kind.into())?;\n             if zero_init {\n                 // We just allocated this, the access is definitely in-bounds.\n-                this.memory.write_bytes(ptr.into(), iter::repeat(0u8).take(size as usize)).unwrap();\n+                this.write_bytes_ptr(ptr.into(), iter::repeat(0u8).take(size as usize)).unwrap();\n             }\n             Ok(ptr.into())\n         }\n@@ -94,7 +94,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n     fn free(&mut self, ptr: Pointer<Option<Tag>>, kind: MiriMemoryKind) -> InterpResult<'tcx> {\n         let this = self.eval_context_mut();\n         if !this.ptr_is_null(ptr)? {\n-            this.memory.deallocate(ptr, None, kind.into())?;\n+            this.deallocate_ptr(ptr, None, kind.into())?;\n         }\n         Ok(())\n     }\n@@ -112,15 +112,15 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n                 Ok(Pointer::null())\n             } else {\n                 let new_ptr =\n-                    this.memory.allocate(Size::from_bytes(new_size), new_align, kind.into())?;\n+                    this.allocate_ptr(Size::from_bytes(new_size), new_align, kind.into())?;\n                 Ok(new_ptr.into())\n             }\n         } else {\n             if new_size == 0 {\n-                this.memory.deallocate(old_ptr, None, kind.into())?;\n+                this.deallocate_ptr(old_ptr, None, kind.into())?;\n                 Ok(Pointer::null())\n             } else {\n-                let new_ptr = this.memory.reallocate(\n+                let new_ptr = this.reallocate_ptr(\n                     old_ptr,\n                     None,\n                     Size::from_bytes(new_size),\n@@ -373,7 +373,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n             \"miri_static_root\" => {\n                 let &[ref ptr] = this.check_shim(abi, Abi::Rust, link_name, args)?;\n                 let ptr = this.read_pointer(ptr)?;\n-                let (alloc_id, offset, _) = this.memory.ptr_get_alloc(ptr)?;\n+                let (alloc_id, offset, _) = this.ptr_get_alloc_id(ptr)?;\n                 if offset != Size::ZERO {\n                     throw_unsup_format!(\"pointer passed to miri_static_root must point to beginning of an allocated block\");\n                 }\n@@ -440,7 +440,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n                 return this.emulate_allocator(Symbol::intern(\"__rg_alloc\"), |this| {\n                     Self::check_alloc_request(size, align)?;\n \n-                    let ptr = this.memory.allocate(\n+                    let ptr = this.allocate_ptr(\n                         Size::from_bytes(size),\n                         Align::from_bytes(align).unwrap(),\n                         MiriMemoryKind::Rust.into(),\n@@ -457,14 +457,14 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n                 return this.emulate_allocator(Symbol::intern(\"__rg_alloc_zeroed\"), |this| {\n                     Self::check_alloc_request(size, align)?;\n \n-                    let ptr = this.memory.allocate(\n+                    let ptr = this.allocate_ptr(\n                         Size::from_bytes(size),\n                         Align::from_bytes(align).unwrap(),\n                         MiriMemoryKind::Rust.into(),\n                     )?;\n \n                     // We just allocated this, the access is definitely in-bounds.\n-                    this.memory.write_bytes(ptr.into(), iter::repeat(0u8).take(usize::try_from(size).unwrap())).unwrap();\n+                    this.write_bytes_ptr(ptr.into(), iter::repeat(0u8).take(usize::try_from(size).unwrap())).unwrap();\n                     this.write_pointer(ptr, dest)\n                 });\n             }\n@@ -476,7 +476,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n \n                 return this.emulate_allocator(Symbol::intern(\"__rg_dealloc\"), |this| {\n                     // No need to check old_size/align; we anyway check that they match the allocation.\n-                    this.memory.deallocate(\n+                    this.deallocate_ptr(\n                         ptr,\n                         Some((Size::from_bytes(old_size), Align::from_bytes(align).unwrap())),\n                         MiriMemoryKind::Rust.into(),\n@@ -495,7 +495,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n                     Self::check_alloc_request(new_size, align)?;\n \n                     let align = Align::from_bytes(align).unwrap();\n-                    let new_ptr = this.memory.reallocate(\n+                    let new_ptr = this.reallocate_ptr(\n                         ptr,\n                         Some((Size::from_bytes(old_size), align)),\n                         Size::from_bytes(new_size),\n@@ -514,8 +514,8 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n                 let n = Size::from_bytes(this.read_scalar(n)?.to_machine_usize(this)?);\n \n                 let result = {\n-                    let left_bytes = this.memory.read_bytes(left, n)?;\n-                    let right_bytes = this.memory.read_bytes(right, n)?;\n+                    let left_bytes = this.read_bytes_ptr(left, n)?;\n+                    let right_bytes = this.read_bytes_ptr(right, n)?;\n \n                     use std::cmp::Ordering::*;\n                     match left_bytes.cmp(right_bytes) {\n@@ -533,8 +533,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n                 let val = this.read_scalar(val)?.to_i32()? as u8;\n                 let num = this.read_scalar(num)?.to_machine_usize(this)?;\n                 if let Some(idx) = this\n-                    .memory\n-                    .read_bytes(ptr, Size::from_bytes(num))?\n+                    .read_bytes_ptr(ptr, Size::from_bytes(num))?\n                     .iter()\n                     .rev()\n                     .position(|&c| c == val)\n@@ -551,8 +550,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n                 let val = this.read_scalar(val)?.to_i32()? as u8;\n                 let num = this.read_scalar(num)?.to_machine_usize(this)?;\n                 let idx = this\n-                    .memory\n-                    .read_bytes(ptr, Size::from_bytes(num))?\n+                    .read_bytes_ptr(ptr, Size::from_bytes(num))?\n                     .iter()\n                     .position(|&c| c == val);\n                 if let Some(idx) = idx {"}, {"sha": "9101cbcf05ff4e7887a3c88a52c3d66da21f227c", "filename": "src/shims/intrinsics.rs", "status": "modified", "additions": 9, "deletions": 7, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/6e1f3cd8ff080b85f6ba71b3f90300aca194a434/src%2Fshims%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e1f3cd8ff080b85f6ba71b3f90300aca194a434/src%2Fshims%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fshims%2Fintrinsics.rs?ref=6e1f3cd8ff080b85f6ba71b3f90300aca194a434", "patch": "@@ -88,8 +88,10 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n                 let byte_count = ty_layout.size.checked_mul(count, this).ok_or_else(|| {\n                     err_ub_format!(\"overflow computing total size of `{}`\", intrinsic_name)\n                 })?;\n-                this.memory\n-                    .write_bytes(ptr, iter::repeat(val_byte).take(byte_count.bytes() as usize))?;\n+                this.write_bytes_ptr(\n+                    ptr,\n+                    iter::repeat(val_byte).take(byte_count.bytes() as usize),\n+                )?;\n             }\n \n             // Floating-point operations\n@@ -1087,7 +1089,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         // even if the type they wrap would be less aligned (e.g. AtomicU64 on 32bit must\n         // be 8-aligned).\n         let align = Align::from_bytes(place.layout.size.bytes()).unwrap();\n-        this.memory.check_ptr_access_align(\n+        this.check_ptr_access_align(\n             place.ptr,\n             place.layout.size,\n             align,\n@@ -1113,7 +1115,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         // even if the type they wrap would be less aligned (e.g. AtomicU64 on 32bit must\n         // be 8-aligned).\n         let align = Align::from_bytes(place.layout.size.bytes()).unwrap();\n-        this.memory.check_ptr_access_align(\n+        this.check_ptr_access_align(\n             place.ptr,\n             place.layout.size,\n             align,\n@@ -1168,7 +1170,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         // even if the type they wrap would be less aligned (e.g. AtomicU64 on 32bit must\n         // be 8-aligned).\n         let align = Align::from_bytes(place.layout.size.bytes()).unwrap();\n-        this.memory.check_ptr_access_align(\n+        this.check_ptr_access_align(\n             place.ptr,\n             place.layout.size,\n             align,\n@@ -1210,7 +1212,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         // even if the type they wrap would be less aligned (e.g. AtomicU64 on 32bit must\n         // be 8-aligned).\n         let align = Align::from_bytes(place.layout.size.bytes()).unwrap();\n-        this.memory.check_ptr_access_align(\n+        this.check_ptr_access_align(\n             place.ptr,\n             place.layout.size,\n             align,\n@@ -1241,7 +1243,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         // even if the type they wrap would be less aligned (e.g. AtomicU64 on 32bit must\n         // be 8-aligned).\n         let align = Align::from_bytes(place.layout.size.bytes()).unwrap();\n-        this.memory.check_ptr_access_align(\n+        this.check_ptr_access_align(\n             place.ptr,\n             place.layout.size,\n             align,"}, {"sha": "83bc6b6ae1bab05d2a9e134fd1f2ff175c3337fd", "filename": "src/shims/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6e1f3cd8ff080b85f6ba71b3f90300aca194a434/src%2Fshims%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e1f3cd8ff080b85f6ba71b3f90300aca194a434/src%2Fshims%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fshims%2Fmod.rs?ref=6e1f3cd8ff080b85f6ba71b3f90300aca194a434", "patch": "@@ -69,7 +69,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         let this = self.eval_context_mut();\n         let (dest, ret) = ret.unwrap();\n \n-        if this.memory.extra.check_alignment != AlignmentCheck::Symbolic {\n+        if this.machine.check_alignment != AlignmentCheck::Symbolic {\n             // Just use actual implementation.\n             return Ok(false);\n         }\n@@ -86,7 +86,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         if let Ok(ptr) = ptr.into_pointer_or_addr() {\n             // Only do anything if we can identify the allocation this goes to.\n             let (_, cur_align) =\n-                this.memory.get_size_and_align(ptr.provenance.alloc_id, AllocCheck::MaybeDead)?;\n+                this.get_alloc_size_and_align(ptr.provenance.alloc_id, AllocCheck::MaybeDead)?;\n             if cur_align.bytes() >= req_align {\n                 // If the allocation alignment is at least the required alignment we use the\n                 // real implementation."}, {"sha": "c03f7ad79be7335bf808928fd1e02aeee62e1909", "filename": "src/shims/os_str.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/6e1f3cd8ff080b85f6ba71b3f90300aca194a434/src%2Fshims%2Fos_str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e1f3cd8ff080b85f6ba71b3f90300aca194a434/src%2Fshims%2Fos_str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fshims%2Fos_str.rs?ref=6e1f3cd8ff080b85f6ba71b3f90300aca194a434", "patch": "@@ -108,8 +108,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n             return Ok((false, string_length));\n         }\n         self.eval_context_mut()\n-            .memory\n-            .write_bytes(ptr, bytes.iter().copied().chain(iter::once(0u8)))?;\n+            .write_bytes_ptr(ptr, bytes.iter().copied().chain(iter::once(0u8)))?;\n         Ok((true, string_length))\n     }\n \n@@ -152,8 +151,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         let size2 = Size::from_bytes(2);\n         let this = self.eval_context_mut();\n         let mut alloc = this\n-            .memory\n-            .get_mut(ptr, size2 * string_length, Align::from_bytes(2).unwrap())?\n+            .get_ptr_alloc_mut(ptr, size2 * string_length, Align::from_bytes(2).unwrap())?\n             .unwrap(); // not a ZST, so we will get a result\n         for (offset, wchar) in u16_vec.into_iter().chain(iter::once(0x0000)).enumerate() {\n             let offset = u64::try_from(offset).unwrap();"}, {"sha": "4190cccae6d0c529769c2c26b4b232b00e53b78d", "filename": "src/shims/panic.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/6e1f3cd8ff080b85f6ba71b3f90300aca194a434/src%2Fshims%2Fpanic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e1f3cd8ff080b85f6ba71b3f90300aca194a434/src%2Fshims%2Fpanic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fshims%2Fpanic.rs?ref=6e1f3cd8ff080b85f6ba71b3f90300aca194a434", "patch": "@@ -89,7 +89,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         let catch_fn = this.read_scalar(catch_fn)?.check_init()?;\n \n         // Now we make a function call, and pass `data` as first and only argument.\n-        let f_instance = this.memory.get_fn(try_fn)?.as_instance()?;\n+        let f_instance = this.get_ptr_fn(try_fn)?.as_instance()?;\n         trace!(\"try_fn: {:?}\", f_instance);\n         let ret_place = MPlaceTy::dangling(this.machine.layouts.unit).into();\n         this.call_function(\n@@ -123,7 +123,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         let this = self.eval_context_mut();\n \n         trace!(\"handle_stack_pop(extra = {:?}, unwinding = {})\", extra, unwinding);\n-        if let Some(stacked_borrows) = &this.memory.extra.stacked_borrows {\n+        if let Some(stacked_borrows) = &this.machine.stacked_borrows {\n             stacked_borrows.borrow_mut().end_call(extra.call_id);\n         }\n \n@@ -146,7 +146,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n \n             // Push the `catch_fn` stackframe.\n             let f_instance =\n-                this.memory.get_fn(this.scalar_to_ptr(catch_unwind.catch_fn))?.as_instance()?;\n+                this.get_ptr_fn(this.scalar_to_ptr(catch_unwind.catch_fn))?.as_instance()?;\n             trace!(\"catch_fn: {:?}\", f_instance);\n             let ret_place = MPlaceTy::dangling(this.machine.layouts.unit).into();\n             this.call_function("}, {"sha": "4bf0bbc26212d64052e0e5cf4b8318cfaff0c0a2", "filename": "src/shims/posix/foreign_items.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/6e1f3cd8ff080b85f6ba71b3f90300aca194a434/src%2Fshims%2Fposix%2Fforeign_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e1f3cd8ff080b85f6ba71b3f90300aca194a434/src%2Fshims%2Fposix%2Fforeign_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fshims%2Fposix%2Fforeign_items.rs?ref=6e1f3cd8ff080b85f6ba71b3f90300aca194a434", "patch": "@@ -157,7 +157,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n                 if size == 0 {\n                     this.write_null(&ret.into())?;\n                 } else {\n-                    let ptr = this.memory.allocate(\n+                    let ptr = this.allocate_ptr(\n                         Size::from_bytes(size),\n                         Align::from_bytes(align).unwrap(),\n                         MiriMemoryKind::C.into(),\n@@ -174,7 +174,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n                 let symbol = this.read_pointer(symbol)?;\n                 let symbol_name = this.read_c_str(symbol)?;\n                 if let Some(dlsym) = Dlsym::from_str(symbol_name, &this.tcx.sess.target.os)? {\n-                    let ptr = this.memory.create_fn_alloc(FnVal::Other(dlsym));\n+                    let ptr = this.create_fn_alloc_ptr(FnVal::Other(dlsym));\n                     this.write_pointer(ptr, dest)?;\n                 } else {\n                     this.write_null(dest)?;\n@@ -214,7 +214,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n \n                 // Extract the function type out of the signature (that seems easier than constructing it ourselves).\n                 let dtor = if !this.ptr_is_null(dtor)? {\n-                    Some(this.memory.get_fn(dtor)?.as_instance()?)\n+                    Some(this.get_ptr_fn(dtor)?.as_instance()?)\n                 } else {\n                     None\n                 };"}, {"sha": "288935576e0ddf79ce5dcd22daff2b632a3991d1", "filename": "src/shims/posix/fs.rs", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/6e1f3cd8ff080b85f6ba71b3f90300aca194a434/src%2Fshims%2Fposix%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e1f3cd8ff080b85f6ba71b3f90300aca194a434/src%2Fshims%2Fposix%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fshims%2Fposix%2Ffs.rs?ref=6e1f3cd8ff080b85f6ba71b3f90300aca194a434", "patch": "@@ -34,7 +34,7 @@ trait FileDescriptor: std::fmt::Debug {\n         bytes: &mut [u8],\n     ) -> InterpResult<'tcx, io::Result<usize>>;\n     fn write<'tcx>(\n-        &mut self,\n+        &self,\n         communicate_allowed: bool,\n         bytes: &[u8],\n     ) -> InterpResult<'tcx, io::Result<usize>>;\n@@ -66,12 +66,12 @@ impl FileDescriptor for FileHandle {\n     }\n \n     fn write<'tcx>(\n-        &mut self,\n+        &self,\n         communicate_allowed: bool,\n         bytes: &[u8],\n     ) -> InterpResult<'tcx, io::Result<usize>> {\n         assert!(communicate_allowed, \"isolation should have prevented even opening a file\");\n-        Ok(self.file.write(bytes))\n+        Ok((&mut &self.file).write(bytes))\n     }\n \n     fn seek<'tcx>(\n@@ -133,7 +133,7 @@ impl FileDescriptor for io::Stdin {\n     }\n \n     fn write<'tcx>(\n-        &mut self,\n+        &self,\n         _communicate_allowed: bool,\n         _bytes: &[u8],\n     ) -> InterpResult<'tcx, io::Result<usize>> {\n@@ -174,12 +174,12 @@ impl FileDescriptor for io::Stdout {\n     }\n \n     fn write<'tcx>(\n-        &mut self,\n+        &self,\n         _communicate_allowed: bool,\n         bytes: &[u8],\n     ) -> InterpResult<'tcx, io::Result<usize>> {\n         // We allow writing to stderr even with isolation enabled.\n-        let result = Write::write(self, bytes);\n+        let result = Write::write(&mut { self }, bytes);\n         // Stdout is buffered, flush to make sure it appears on the\n         // screen.  This is the write() syscall of the interpreted\n         // program, we want it to correspond to a write() syscall on\n@@ -224,13 +224,13 @@ impl FileDescriptor for io::Stderr {\n     }\n \n     fn write<'tcx>(\n-        &mut self,\n+        &self,\n         _communicate_allowed: bool,\n         bytes: &[u8],\n     ) -> InterpResult<'tcx, io::Result<usize>> {\n         // We allow writing to stderr even with isolation enabled.\n         // No need to flush, stderr is not buffered.\n-        Ok(Write::write(self, bytes))\n+        Ok(Write::write(&mut { self }, bytes))\n     }\n \n     fn seek<'tcx>(\n@@ -681,7 +681,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         trace!(\"Reading from FD {}, size {}\", fd, count);\n \n         // Check that the *entire* buffer is actually valid memory.\n-        this.memory.check_ptr_access_align(\n+        this.check_ptr_access_align(\n             buf,\n             Size::from_bytes(count),\n             Align::ONE,\n@@ -707,7 +707,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n             match result {\n                 Ok(read_bytes) => {\n                     // If reading to `bytes` did not fail, we write those bytes to the buffer.\n-                    this.memory.write_bytes(buf, bytes)?;\n+                    this.write_bytes_ptr(buf, bytes)?;\n                     Ok(read_bytes)\n                 }\n                 Err(e) => {\n@@ -727,7 +727,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         // Isolation check is done via `FileDescriptor` trait.\n \n         // Check that the *entire* buffer is actually valid memory.\n-        this.memory.check_ptr_access_align(\n+        this.check_ptr_access_align(\n             buf,\n             Size::from_bytes(count),\n             Align::ONE,\n@@ -739,8 +739,8 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         let count = count.min(this.machine_isize_max() as u64).min(isize::MAX as u64);\n         let communicate = this.machine.communicate();\n \n-        if let Some(file_descriptor) = this.machine.file_handler.handles.get_mut(&fd) {\n-            let bytes = this.memory.read_bytes(buf, Size::from_bytes(count))?;\n+        if let Some(file_descriptor) = this.machine.file_handler.handles.get(&fd) {\n+            let bytes = this.read_bytes_ptr(buf, Size::from_bytes(count))?;\n             let result =\n                 file_descriptor.write(communicate, &bytes)?.map(|c| i64::try_from(c).unwrap());\n             this.try_unwrap_io_result(result)\n@@ -1288,7 +1288,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n                 )?;\n \n                 let name_ptr = entry.offset(Size::from_bytes(d_name_offset), this)?;\n-                this.memory.write_bytes(name_ptr, name_bytes.iter().copied())?;\n+                this.write_bytes_ptr(name_ptr, name_bytes.iter().copied())?;\n \n                 entry\n             }\n@@ -1597,7 +1597,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n                 }\n                 // 'readlink' truncates the resolved path if\n                 // the provided buffer is not large enough.\n-                this.memory.write_bytes(buf, path_bytes.iter().copied())?;\n+                this.write_bytes_ptr(buf, path_bytes.iter().copied())?;\n                 Ok(path_bytes.len().try_into().unwrap())\n             }\n             Err(e) => {"}, {"sha": "60c0c2d7c1016bf1fffa5cc239573e16f0533107", "filename": "src/shims/posix/linux/sync.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6e1f3cd8ff080b85f6ba71b3f90300aca194a434/src%2Fshims%2Fposix%2Flinux%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e1f3cd8ff080b85f6ba71b3f90300aca194a434/src%2Fshims%2Fposix%2Flinux%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fshims%2Fposix%2Flinux%2Fsync.rs?ref=6e1f3cd8ff080b85f6ba71b3f90300aca194a434", "patch": "@@ -79,7 +79,7 @@ pub fn futex<'tcx>(\n             // Check the pointer for alignment and validity.\n             // The API requires `addr` to be a 4-byte aligned pointer, and will\n             // use the 4 bytes at the given address as an (atomic) i32.\n-            this.memory.check_ptr_access_align(\n+            this.check_ptr_access_align(\n                 this.scalar_to_ptr(addr_scalar),\n                 Size::from_bytes(4),\n                 Align::from_bytes(4).unwrap(),"}, {"sha": "18646b70130e47b073071f07d966a5635118716e", "filename": "src/shims/posix/macos/foreign_items.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6e1f3cd8ff080b85f6ba71b3f90300aca194a434/src%2Fshims%2Fposix%2Fmacos%2Fforeign_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e1f3cd8ff080b85f6ba71b3f90300aca194a434/src%2Fshims%2Fposix%2Fmacos%2Fforeign_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fshims%2Fposix%2Fmacos%2Fforeign_items.rs?ref=6e1f3cd8ff080b85f6ba71b3f90300aca194a434", "patch": "@@ -121,7 +121,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n                 let &[ref dtor, ref data] =\n                     this.check_shim(abi, Abi::C { unwind: false }, link_name, args)?;\n                 let dtor = this.read_pointer(dtor)?;\n-                let dtor = this.memory.get_fn(dtor)?.as_instance()?;\n+                let dtor = this.get_ptr_fn(dtor)?.as_instance()?;\n                 let data = this.read_scalar(data)?.check_init()?;\n                 let active_thread = this.get_active_thread();\n                 this.machine.tls.set_macos_thread_dtor(active_thread, dtor, data)?;"}, {"sha": "58d48028f62cb14461da27d78f41ab838daedeaf", "filename": "src/shims/posix/thread.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6e1f3cd8ff080b85f6ba71b3f90300aca194a434/src%2Fshims%2Fposix%2Fthread.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e1f3cd8ff080b85f6ba71b3f90300aca194a434/src%2Fshims%2Fposix%2Fthread.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fshims%2Fposix%2Fthread.rs?ref=6e1f3cd8ff080b85f6ba71b3f90300aca194a434", "patch": "@@ -41,7 +41,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         let old_thread_id = this.set_active_thread(new_thread_id);\n \n         // Perform the function pointer load in the new thread frame.\n-        let instance = this.memory.get_fn(fn_ptr)?.as_instance()?;\n+        let instance = this.get_ptr_fn(fn_ptr)?.as_instance()?;\n \n         // Note: the returned value is currently ignored (see the FIXME in\n         // pthread_join below) because the Rust standard library does not use\n@@ -122,7 +122,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n             let mut name = this.get_active_thread_name().to_vec();\n             name.push(0u8);\n             assert!(name.len() <= 16);\n-            this.memory.write_bytes(address, name)?;\n+            this.write_bytes_ptr(address, name)?;\n         } else {\n             throw_unsup_format!(\"unsupported prctl option {}\", option);\n         }"}, {"sha": "297d0c1228a48d91f2294123afa54817845b3a7d", "filename": "src/shims/tls.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6e1f3cd8ff080b85f6ba71b3f90300aca194a434/src%2Fshims%2Ftls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e1f3cd8ff080b85f6ba71b3f90300aca194a434/src%2Fshims%2Ftls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fshims%2Ftls.rs?ref=6e1f3cd8ff080b85f6ba71b3f90300aca194a434", "patch": "@@ -249,7 +249,7 @@ trait EvalContextPrivExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n             \"p_thread_callback\",\n         ])?;\n         let thread_callback =\n-            this.memory.get_fn(this.scalar_to_ptr(thread_callback))?.as_instance()?;\n+            this.get_ptr_fn(this.scalar_to_ptr(thread_callback))?.as_instance()?;\n \n         // The signature of this function is `unsafe extern \"system\" fn(h: c::LPVOID, dwReason: c::DWORD, pv: c::LPVOID)`.\n         let reason = this.eval_path_scalar(&[\"std\", \"sys\", \"windows\", \"c\", \"DLL_THREAD_DETACH\"])?;"}, {"sha": "82ac5c5d75c43c87278bd7d2c84dd2bfef285876", "filename": "src/shims/windows/foreign_items.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/6e1f3cd8ff080b85f6ba71b3f90300aca194a434/src%2Fshims%2Fwindows%2Fforeign_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e1f3cd8ff080b85f6ba71b3f90300aca194a434/src%2Fshims%2Fwindows%2Fforeign_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fshims%2Fwindows%2Fforeign_items.rs?ref=6e1f3cd8ff080b85f6ba71b3f90300aca194a434", "patch": "@@ -87,7 +87,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n                     // stdout/stderr\n                     use std::io::{self, Write};\n \n-                    let buf_cont = this.memory.read_bytes(buf, Size::from_bytes(u64::from(n)))?;\n+                    let buf_cont = this.read_bytes_ptr(buf, Size::from_bytes(u64::from(n)))?;\n                     let res = if handle == -11 {\n                         io::stdout().write(buf_cont)\n                     } else {\n@@ -157,7 +157,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n                     this.check_shim(abi, Abi::System { unwind: false }, link_name, args)?;\n                 let system_info = this.deref_operand(system_info)?;\n                 // Initialize with `0`.\n-                this.memory.write_bytes(\n+                this.write_bytes_ptr(\n                     system_info.ptr,\n                     iter::repeat(0u8).take(system_info.layout.size.bytes() as usize),\n                 )?;\n@@ -269,7 +269,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n                 this.read_scalar(hModule)?.to_machine_isize(this)?;\n                 let name = this.read_c_str(this.read_pointer(lpProcName)?)?;\n                 if let Some(dlsym) = Dlsym::from_str(name, &this.tcx.sess.target.os)? {\n-                    let ptr = this.memory.create_fn_alloc(FnVal::Other(dlsym));\n+                    let ptr = this.create_fn_alloc_ptr(FnVal::Other(dlsym));\n                     this.write_pointer(ptr, dest)?;\n                 } else {\n                     this.write_null(dest)?;"}, {"sha": "a365d909981bf55a64d8c78c8787fc2e18b165ab", "filename": "src/stacked_borrows.rs", "status": "modified", "additions": 23, "deletions": 23, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/6e1f3cd8ff080b85f6ba71b3f90300aca194a434/src%2Fstacked_borrows.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e1f3cd8ff080b85f6ba71b3f90300aca194a434/src%2Fstacked_borrows.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fstacked_borrows.rs?ref=6e1f3cd8ff080b85f6ba71b3f90300aca194a434", "patch": "@@ -93,7 +93,7 @@ pub struct Stacks {\n \n /// Extra global state, available to the memory access hooks.\n #[derive(Debug)]\n-pub struct GlobalState {\n+pub struct GlobalStateInner {\n     /// Next unused pointer ID (tag).\n     next_ptr_id: PtrId,\n     /// Table storing the \"base\" tag for each allocation.\n@@ -111,8 +111,8 @@ pub struct GlobalState {\n     /// Whether to track raw pointers.\n     tag_raw: bool,\n }\n-/// Memory extra state gives us interior mutable access to the global state.\n-pub type MemoryExtra = RefCell<GlobalState>;\n+/// We need interior mutable access to the global state.\n+pub type GlobalState = RefCell<GlobalStateInner>;\n \n /// Indicates which kind of access is being performed.\n #[derive(Copy, Clone, Hash, PartialEq, Eq, Debug)]\n@@ -156,13 +156,13 @@ impl fmt::Display for RefKind {\n }\n \n /// Utilities for initialization and ID generation\n-impl GlobalState {\n+impl GlobalStateInner {\n     pub fn new(\n         tracked_pointer_tag: Option<PtrId>,\n         tracked_call_id: Option<CallId>,\n         tag_raw: bool,\n     ) -> Self {\n-        GlobalState {\n+        GlobalStateInner {\n             next_ptr_id: NonZeroU64::new(1).unwrap(),\n             base_ptr_ids: FxHashMap::default(),\n             next_call_id: NonZeroU64::new(1).unwrap(),\n@@ -308,7 +308,7 @@ impl<'tcx> Stack {\n     fn check_protector(\n         item: &Item,\n         provoking_access: Option<(SbTag, AccessKind)>,\n-        global: &GlobalState,\n+        global: &GlobalStateInner,\n     ) -> InterpResult<'tcx> {\n         if let SbTag::Tagged(id) = item.tag {\n             if Some(id) == global.tracked_pointer_tag {\n@@ -348,7 +348,7 @@ impl<'tcx> Stack {\n         access: AccessKind,\n         tag: SbTag,\n         (alloc_id, range, offset): (AllocId, AllocRange, Size), // just for debug printing and error messages\n-        global: &GlobalState,\n+        global: &GlobalStateInner,\n     ) -> InterpResult<'tcx> {\n         // Two main steps: Find granting item, remove incompatible items above.\n \n@@ -396,7 +396,7 @@ impl<'tcx> Stack {\n         &mut self,\n         tag: SbTag,\n         dbg_ptr: Pointer<AllocId>, // just for debug printing and error messages\n-        global: &GlobalState,\n+        global: &GlobalStateInner,\n     ) -> InterpResult<'tcx> {\n         // Step 1: Find granting item.\n         self.find_granting(AccessKind::Write, tag).ok_or_else(|| {\n@@ -425,7 +425,7 @@ impl<'tcx> Stack {\n         derived_from: SbTag,\n         new: Item,\n         (alloc_id, alloc_range, offset): (AllocId, AllocRange, Size), // just for debug printing and error messages\n-        global: &GlobalState,\n+        global: &GlobalStateInner,\n     ) -> InterpResult<'tcx> {\n         // Figure out which access `perm` corresponds to.\n         let access =\n@@ -584,10 +584,10 @@ impl Stacks {\n     pub fn new_allocation(\n         id: AllocId,\n         size: Size,\n-        extra: &MemoryExtra,\n+        state: &GlobalState,\n         kind: MemoryKind<MiriMemoryKind>,\n     ) -> Self {\n-        let mut extra = extra.borrow_mut();\n+        let mut extra = state.borrow_mut();\n         let (base_tag, perm) = match kind {\n             // New unique borrow. This tag is not accessible by the program,\n             // so it will only ever be used when using the local directly (i.e.,\n@@ -628,15 +628,15 @@ impl Stacks {\n         alloc_id: AllocId,\n         tag: SbTag,\n         range: AllocRange,\n-        extra: &MemoryExtra,\n+        state: &GlobalState,\n     ) -> InterpResult<'tcx> {\n         trace!(\n             \"read access with tag {:?}: {:?}, size {}\",\n             tag,\n             Pointer::new(alloc_id, range.start),\n             range.size.bytes()\n         );\n-        let global = &*extra.borrow();\n+        let global = &*state.borrow();\n         self.for_each(range, move |offset, stack| {\n             stack.access(AccessKind::Read, tag, (alloc_id, range, offset), global)\n         })\n@@ -648,15 +648,15 @@ impl Stacks {\n         alloc_id: AllocId,\n         tag: SbTag,\n         range: AllocRange,\n-        extra: &mut MemoryExtra,\n+        state: &mut GlobalState,\n     ) -> InterpResult<'tcx> {\n         trace!(\n             \"write access with tag {:?}: {:?}, size {}\",\n             tag,\n             Pointer::new(alloc_id, range.start),\n             range.size.bytes()\n         );\n-        let global = extra.get_mut();\n+        let global = state.get_mut();\n         self.for_each_mut(range, move |offset, stack| {\n             stack.access(AccessKind::Write, tag, (alloc_id, range, offset), global)\n         })\n@@ -668,10 +668,10 @@ impl Stacks {\n         alloc_id: AllocId,\n         tag: SbTag,\n         range: AllocRange,\n-        extra: &mut MemoryExtra,\n+        state: &mut GlobalState,\n     ) -> InterpResult<'tcx> {\n         trace!(\"deallocation with tag {:?}: {:?}, size {}\", tag, alloc_id, range.size.bytes());\n-        let global = extra.get_mut();\n+        let global = state.get_mut();\n         self.for_each_mut(range, move |offset, stack| {\n             stack.dealloc(tag, Pointer::new(alloc_id, offset), global)\n         })\n@@ -702,12 +702,12 @@ trait EvalContextPrivExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n             );\n             return Ok(());\n         }\n-        let (alloc_id, base_offset, ptr) = this.memory.ptr_get_alloc(place.ptr)?;\n+        let (alloc_id, base_offset, ptr) = this.ptr_get_alloc_id(place.ptr)?;\n         let orig_tag = ptr.provenance.sb;\n \n         // Ensure we bail out if the pointer goes out-of-bounds (see miri#1050).\n         let (alloc_size, _) =\n-            this.memory.get_size_and_align(alloc_id, AllocCheck::Dereferenceable)?;\n+            this.get_alloc_size_and_align(alloc_id, AllocCheck::Dereferenceable)?;\n         if base_offset + size > alloc_size {\n             throw_ub!(PointerOutOfBounds {\n                 alloc_id,\n@@ -750,10 +750,10 @@ trait EvalContextPrivExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n                 // We need a frozen-sensitive reborrow.\n                 // We have to use shared references to alloc/memory_extra here since\n                 // `visit_freeze_sensitive` needs to access the global state.\n-                let extra = this.memory.get_alloc_extra(alloc_id)?;\n+                let extra = this.get_alloc_extra(alloc_id)?;\n                 let stacked_borrows =\n                     extra.stacked_borrows.as_ref().expect(\"we should have Stacked Borrows data\");\n-                let global = this.memory.extra.stacked_borrows.as_ref().unwrap().borrow();\n+                let global = this.machine.stacked_borrows.as_ref().unwrap().borrow();\n                 this.visit_freeze_sensitive(place, size, |mut range, frozen| {\n                     // Adjust range.\n                     range.start += base_offset;\n@@ -774,7 +774,7 @@ trait EvalContextPrivExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         // Here we can avoid `borrow()` calls because we have mutable references.\n         // Note that this asserts that the allocation is mutable -- but since we are creating a\n         // mutable pointer, that seems reasonable.\n-        let (alloc_extra, memory_extra) = this.memory.get_alloc_extra_mut(alloc_id)?;\n+        let (alloc_extra, memory_extra) = this.get_alloc_extra_mut(alloc_id)?;\n         let stacked_borrows =\n             alloc_extra.stacked_borrows.as_mut().expect(\"we should have Stacked Borrows data\");\n         let global = memory_extra.stacked_borrows.as_mut().unwrap().get_mut();\n@@ -808,7 +808,7 @@ trait EvalContextPrivExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n \n         // Compute new borrow.\n         let new_tag = {\n-            let mem_extra = this.memory.extra.stacked_borrows.as_mut().unwrap().get_mut();\n+            let mem_extra = this.machine.stacked_borrows.as_mut().unwrap().get_mut();\n             match kind {\n                 // Give up tracking for raw pointers.\n                 RefKind::Raw { .. } if !mem_extra.tag_raw => SbTag::Untagged,"}, {"sha": "44ea18f4055daecf16821f3bb4c4bc4d21bb8e67", "filename": "src/sync.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/6e1f3cd8ff080b85f6ba71b3f90300aca194a434/src%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e1f3cd8ff080b85f6ba71b3f90300aca194a434/src%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fsync.rs?ref=6e1f3cd8ff080b85f6ba71b3f90300aca194a434", "patch": "@@ -242,7 +242,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n             mutex.owner = Some(thread);\n         }\n         mutex.lock_count = mutex.lock_count.checked_add(1).unwrap();\n-        if let Some(data_race) = &this.memory.extra.data_race {\n+        if let Some(data_race) = &this.machine.data_race {\n             data_race.validate_lock_acquire(&mutex.data_race, thread);\n         }\n     }\n@@ -268,7 +268,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n                 mutex.owner = None;\n                 // The mutex is completely unlocked. Try transfering ownership\n                 // to another thread.\n-                if let Some(data_race) = &this.memory.extra.data_race {\n+                if let Some(data_race) = &this.machine.data_race {\n                     data_race.validate_lock_release(&mut mutex.data_race, current_owner);\n                 }\n                 this.mutex_dequeue_and_lock(id);\n@@ -328,7 +328,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         let rwlock = &mut this.machine.threads.sync.rwlocks[id];\n         let count = rwlock.readers.entry(reader).or_insert(0);\n         *count = count.checked_add(1).expect(\"the reader counter overflowed\");\n-        if let Some(data_race) = &this.memory.extra.data_race {\n+        if let Some(data_race) = &this.machine.data_race {\n             data_race.validate_lock_acquire(&rwlock.data_race, reader);\n         }\n     }\n@@ -352,7 +352,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n             }\n             Entry::Vacant(_) => return false, // we did not even own this lock\n         }\n-        if let Some(data_race) = &this.memory.extra.data_race {\n+        if let Some(data_race) = &this.machine.data_race {\n             data_race.validate_lock_release_shared(&mut rwlock.data_race_reader, reader);\n         }\n \n@@ -385,7 +385,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         trace!(\"rwlock_writer_lock: {:?} now held by {:?}\", id, writer);\n         let rwlock = &mut this.machine.threads.sync.rwlocks[id];\n         rwlock.writer = Some(writer);\n-        if let Some(data_race) = &this.memory.extra.data_race {\n+        if let Some(data_race) = &this.machine.data_race {\n             data_race.validate_lock_acquire(&rwlock.data_race, writer);\n         }\n     }\n@@ -405,7 +405,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n             // Release memory to both reader and writer vector clocks\n             //  since this writer happens-before both the union of readers once they are finished\n             //  and the next writer\n-            if let Some(data_race) = &this.memory.extra.data_race {\n+            if let Some(data_race) = &this.machine.data_race {\n                 data_race.validate_lock_release(&mut rwlock.data_race, current_writer);\n                 data_race.validate_lock_release(&mut rwlock.data_race_reader, current_writer);\n             }\n@@ -465,7 +465,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         let this = self.eval_context_mut();\n         let current_thread = this.get_active_thread();\n         let condvar = &mut this.machine.threads.sync.condvars[id];\n-        let data_race = &this.memory.extra.data_race;\n+        let data_race = &this.machine.data_race;\n \n         // Each condvar signal happens-before the end of the condvar wake\n         if let Some(data_race) = data_race {\n@@ -498,7 +498,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         let this = self.eval_context_mut();\n         let current_thread = this.get_active_thread();\n         let futex = &mut this.machine.threads.sync.futexes.get_mut(&addr)?;\n-        let data_race = &this.memory.extra.data_race;\n+        let data_race = &this.machine.data_race;\n \n         // Each futex-wake happens-before the end of the futex wait\n         if let Some(data_race) = data_race {"}, {"sha": "2c5f6c2391f05f5f4d2ddbe884b5fa9c02115b1c", "filename": "src/thread.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/6e1f3cd8ff080b85f6ba71b3f90300aca194a434/src%2Fthread.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e1f3cd8ff080b85f6ba71b3f90300aca194a434/src%2Fthread.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fthread.rs?ref=6e1f3cd8ff080b85f6ba71b3f90300aca194a434", "patch": "@@ -574,7 +574,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n             let allocation = tcx.eval_static_initializer(def_id)?;\n             // Create a fresh allocation with this content.\n             let new_alloc =\n-                this.memory.allocate_with(allocation.inner().clone(), MiriMemoryKind::Tls.into());\n+                this.allocate_raw_ptr(allocation.inner().clone(), MiriMemoryKind::Tls.into());\n             this.machine.threads.set_thread_local_alloc(def_id, new_alloc);\n             Ok(new_alloc)\n         }\n@@ -584,7 +584,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n     fn create_thread(&mut self) -> ThreadId {\n         let this = self.eval_context_mut();\n         let id = this.machine.threads.create_thread();\n-        if let Some(data_race) = &mut this.memory.extra.data_race {\n+        if let Some(data_race) = &mut this.machine.data_race {\n             data_race.thread_created(id);\n         }\n         id\n@@ -599,14 +599,14 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n     #[inline]\n     fn join_thread(&mut self, joined_thread_id: ThreadId) -> InterpResult<'tcx> {\n         let this = self.eval_context_mut();\n-        this.machine.threads.join_thread(joined_thread_id, this.memory.extra.data_race.as_mut())?;\n+        this.machine.threads.join_thread(joined_thread_id, this.machine.data_race.as_mut())?;\n         Ok(())\n     }\n \n     #[inline]\n     fn set_active_thread(&mut self, thread_id: ThreadId) -> ThreadId {\n         let this = self.eval_context_mut();\n-        if let Some(data_race) = &this.memory.extra.data_race {\n+        if let Some(data_race) = &this.machine.data_race {\n             data_race.thread_set_active(thread_id);\n         }\n         this.machine.threads.set_active_thread_id(thread_id)\n@@ -669,7 +669,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n     #[inline]\n     fn set_active_thread_name(&mut self, new_thread_name: Vec<u8>) {\n         let this = self.eval_context_mut();\n-        if let Some(data_race) = &mut this.memory.extra.data_race {\n+        if let Some(data_race) = &mut this.machine.data_race {\n             if let Ok(string) = String::from_utf8(new_thread_name.clone()) {\n                 data_race.thread_set_name(this.machine.threads.active_thread, string);\n             }\n@@ -753,7 +753,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n     #[inline]\n     fn schedule(&mut self) -> InterpResult<'tcx, SchedulingAction> {\n         let this = self.eval_context_mut();\n-        let data_race = &this.memory.extra.data_race;\n+        let data_race = &this.machine.data_race;\n         this.machine.threads.schedule(data_race)\n     }\n \n@@ -764,8 +764,8 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n     #[inline]\n     fn thread_terminated(&mut self) -> InterpResult<'tcx> {\n         let this = self.eval_context_mut();\n-        for ptr in this.machine.threads.thread_terminated(this.memory.extra.data_race.as_mut()) {\n-            this.memory.deallocate(ptr.into(), None, MiriMemoryKind::Tls.into())?;\n+        for ptr in this.machine.threads.thread_terminated(this.machine.data_race.as_mut()) {\n+            this.deallocate_ptr(ptr.into(), None, MiriMemoryKind::Tls.into())?;\n         }\n         Ok(())\n     }"}]}