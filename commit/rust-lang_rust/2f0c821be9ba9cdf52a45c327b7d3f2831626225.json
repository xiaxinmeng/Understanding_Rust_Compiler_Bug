{"sha": "2f0c821be9ba9cdf52a45c327b7d3f2831626225", "node_id": "MDY6Q29tbWl0NzI0NzEyOjJmMGM4MjFiZTliYTljZGY1MmE0NWMzMjdiN2QzZjI4MzE2MjYyMjU=", "commit": {"author": {"name": "Ulrik Sverdrup", "email": "bluss@users.noreply.github.com", "date": "2018-12-19T19:58:20Z"}, "committer": {"name": "Oliver Scherer", "email": "github35764891676564198441@oli-obk.de", "date": "2019-10-11T08:43:54Z"}, "message": "Change untagged_unions to not allow union fields with drop\n\nUnion fields may now never have a type with attached destructor.\nThis for example allows unions to use arbitrary field types only by\nwrapping\nthem in ManuallyDrop.\n\nThe stable rule remains, that union fields must be Copy. We use the new\nrule for the `untagged_union` feature.\n\nSee RFC 2514.\n\nNote for ui tests:\nWe can't test move out through Box's deref-move since we can't\nhave a Box in a union anymore.", "tree": {"sha": "c3bbbab51b2b312f35c5fd60694b0e7b4336e4c3", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c3bbbab51b2b312f35c5fd60694b0e7b4336e4c3"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2f0c821be9ba9cdf52a45c327b7d3f2831626225", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2f0c821be9ba9cdf52a45c327b7d3f2831626225", "html_url": "https://github.com/rust-lang/rust/commit/2f0c821be9ba9cdf52a45c327b7d3f2831626225", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2f0c821be9ba9cdf52a45c327b7d3f2831626225/comments", "author": {"login": "bluss", "id": 3209739, "node_id": "MDQ6VXNlcjMyMDk3Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/3209739?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bluss", "html_url": "https://github.com/bluss", "followers_url": "https://api.github.com/users/bluss/followers", "following_url": "https://api.github.com/users/bluss/following{/other_user}", "gists_url": "https://api.github.com/users/bluss/gists{/gist_id}", "starred_url": "https://api.github.com/users/bluss/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bluss/subscriptions", "organizations_url": "https://api.github.com/users/bluss/orgs", "repos_url": "https://api.github.com/users/bluss/repos", "events_url": "https://api.github.com/users/bluss/events{/privacy}", "received_events_url": "https://api.github.com/users/bluss/received_events", "type": "User", "site_admin": false}, "committer": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "84ca0a1cb47f71a43ee16da2f6bc173577b35cb9", "url": "https://api.github.com/repos/rust-lang/rust/commits/84ca0a1cb47f71a43ee16da2f6bc173577b35cb9", "html_url": "https://github.com/rust-lang/rust/commit/84ca0a1cb47f71a43ee16da2f6bc173577b35cb9"}], "stats": {"total": 298, "additions": 222, "deletions": 76}, "files": [{"sha": "8f191961fdd041034bb8945a9ed80c889c4a5e89", "filename": "src/librustc/Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2f0c821be9ba9cdf52a45c327b7d3f2831626225/src%2Flibrustc%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/2f0c821be9ba9cdf52a45c327b7d3f2831626225/src%2Flibrustc%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2FCargo.toml?ref=2f0c821be9ba9cdf52a45c327b7d3f2831626225", "patch": "@@ -35,5 +35,5 @@ parking_lot = \"0.9\"\n byteorder = { version = \"1.3\" }\n chalk-engine = { version = \"0.9.0\", default-features=false }\n rustc_fs_util = { path = \"../librustc_fs_util\" }\n-smallvec = { version = \"0.6.7\", features = [\"union\", \"may_dangle\"] }\n+smallvec = { version = \"0.6.8\", features = [\"union\", \"may_dangle\"] }\n measureme = \"0.3\""}, {"sha": "bd0d5846d95855a24f81d8d17f7d6f83f660d355", "filename": "src/librustc/ty/util.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2f0c821be9ba9cdf52a45c327b7d3f2831626225/src%2Flibrustc%2Fty%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f0c821be9ba9cdf52a45c327b7d3f2831626225/src%2Flibrustc%2Fty%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Futil.rs?ref=2f0c821be9ba9cdf52a45c327b7d3f2831626225", "patch": "@@ -805,6 +805,8 @@ impl<'tcx> ty::TyS<'tcx> {\n     ///\n     /// (Note that this implies that if `ty` has a destructor attached,\n     /// then `needs_drop` will definitely return `true` for `ty`.)\n+    ///\n+    /// Note that this method is used to check eligible types in unions.\n     #[inline]\n     pub fn needs_drop(&'tcx self, tcx: TyCtxt<'tcx>, param_env: ty::ParamEnv<'tcx>) -> bool {\n         tcx.needs_drop_raw(param_env.and(self)).0"}, {"sha": "2f122e5edb1cb67389a3e4e4b220bde29edcca5c", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/2f0c821be9ba9cdf52a45c327b7d3f2831626225/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f0c821be9ba9cdf52a45c327b7d3f2831626225/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=2f0c821be9ba9cdf52a45c327b7d3f2831626225", "patch": "@@ -1387,9 +1387,38 @@ fn check_union(tcx: TyCtxt<'_>, id: hir::HirId, span: Span) {\n     def.destructor(tcx); // force the destructor to be evaluated\n     check_representable(tcx, span, def_id);\n     check_transparent(tcx, span, def_id);\n+    check_union_fields(tcx, span, def_id);\n     check_packed(tcx, span, def_id);\n }\n \n+fn check_union_fields<'tcx>(tcx: TyCtxt<'tcx>, _sp: Span, item_def_id: DefId) -> bool {\n+    // Without the feature we check Copy types only later\n+    if !tcx.features().untagged_unions {\n+        return true;\n+    }\n+    let t = tcx.type_of(item_def_id);\n+    if let ty::Adt(def, substs) = t.sty {\n+        if def.is_union() {\n+            let fields = &def.non_enum_variant().fields;\n+            for field in fields {\n+                let field_ty = field.ty(tcx, substs);\n+                // We are currently checking the type this field came from, so it must be local\n+                let field_span = tcx.hir().span_if_local(field.did).unwrap();\n+                let param_env = tcx.param_env(field.did);\n+                if field_ty.needs_drop(tcx, param_env) {\n+                    struct_span_err!(tcx.sess, field_span, E0740,\n+                                     \"unions may not contain fields that need dropping\")\n+                                .span_note(field_span,\n+                                           \"`std::mem::ManuallyDrop` can be used to wrap the type\")\n+                                .emit();\n+                    return false;\n+                }\n+            }\n+        }\n+    }\n+    return true;\n+}\n+\n /// Checks that an opaque type does not contain cycles and does not use `Self` or `T::Foo`\n /// projections that would result in \"inheriting lifetimes\".\n fn check_opaque<'tcx>("}, {"sha": "a92a2c960039137cb5bf9e15562ea253420e9b76", "filename": "src/librustc_typeck/error_codes.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2f0c821be9ba9cdf52a45c327b7d3f2831626225/src%2Flibrustc_typeck%2Ferror_codes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f0c821be9ba9cdf52a45c327b7d3f2831626225/src%2Flibrustc_typeck%2Ferror_codes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Ferror_codes.rs?ref=2f0c821be9ba9cdf52a45c327b7d3f2831626225", "patch": "@@ -4863,6 +4863,10 @@ assert_eq!(1, discriminant(&Enum::Struct{a: 7, b: 11}));\n ```\n \"##,\n \n+E0740: r##\"\n+A `union` can not have fields with destructors.\n+\"##,\n+\n E0733: r##\"\n Recursion in an `async fn` requires boxing. For example, this will not compile:\n "}, {"sha": "a43a5050865691e6bd7db60e2222feff00ecfc16", "filename": "src/test/run-pass/union/union-manuallydrop.rs", "status": "added", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/2f0c821be9ba9cdf52a45c327b7d3f2831626225/src%2Ftest%2Frun-pass%2Funion%2Funion-manuallydrop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f0c821be9ba9cdf52a45c327b7d3f2831626225/src%2Ftest%2Frun-pass%2Funion%2Funion-manuallydrop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Funion%2Funion-manuallydrop.rs?ref=2f0c821be9ba9cdf52a45c327b7d3f2831626225", "patch": "@@ -0,0 +1,42 @@\n+#![feature(untagged_unions)]\n+#![allow(dead_code)]\n+// run-pass\n+\n+use std::mem::needs_drop;\n+use std::mem::ManuallyDrop;\n+\n+struct NeedDrop;\n+\n+impl Drop for NeedDrop {\n+    fn drop(&mut self) {}\n+}\n+\n+union UnionOk1<T> {\n+    empty: (),\n+    value: ManuallyDrop<T>,\n+}\n+\n+union UnionOk2 {\n+    value: ManuallyDrop<NeedDrop>,\n+}\n+\n+#[allow(dead_code)]\n+union UnionOk3<T: Copy> {\n+    empty: (),\n+    value: T,\n+}\n+\n+trait Foo { }\n+\n+trait ImpliesCopy : Copy { }\n+\n+#[allow(dead_code)]\n+union UnionOk4<T: ImpliesCopy> {\n+    value: T,\n+}\n+\n+fn main() {\n+    // NeedDrop should not make needs_drop true\n+    assert!(!needs_drop::<UnionOk1<NeedDrop>>());\n+    assert!(!needs_drop::<UnionOk3<&dyn Foo>>());\n+}"}, {"sha": "0faa9090f4ebcfd898a632a1faf6d6dc6448d5be", "filename": "src/test/ui/feature-gates/feature-gate-associated_type_bounds.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/2f0c821be9ba9cdf52a45c327b7d3f2831626225/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-associated_type_bounds.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f0c821be9ba9cdf52a45c327b7d3f2831626225/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-associated_type_bounds.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-associated_type_bounds.rs?ref=2f0c821be9ba9cdf52a45c327b7d3f2831626225", "patch": "@@ -1,7 +1,7 @@\n #![feature(untagged_unions)]\n \n-trait Tr1 { type As1; }\n-trait Tr2 { type As2; }\n+trait Tr1 { type As1: Copy; }\n+trait Tr2 { type As2: Copy; }\n \n struct S1;\n #[derive(Copy, Clone)]\n@@ -32,7 +32,7 @@ enum _En1<T: Tr1<As1: Tr2>> {\n \n union _Un1<T: Tr1<As1: Tr2>> {\n //~^ ERROR associated type bounds are unstable\n-    outest: T,\n+    outest: std::mem::ManuallyDrop<T>,\n     outer: T::As1,\n     inner: <T::As1 as Tr2>::As2,\n }"}, {"sha": "8aa246e8bfeb35f312a6fd413bc7a9f36295a470", "filename": "src/test/ui/rfc-2093-infer-outlives/explicit-union.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2f0c821be9ba9cdf52a45c327b7d3f2831626225/src%2Ftest%2Fui%2Frfc-2093-infer-outlives%2Fexplicit-union.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2f0c821be9ba9cdf52a45c327b7d3f2831626225/src%2Ftest%2Fui%2Frfc-2093-infer-outlives%2Fexplicit-union.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc-2093-infer-outlives%2Fexplicit-union.stderr?ref=2f0c821be9ba9cdf52a45c327b7d3f2831626225", "patch": "@@ -1,7 +1,7 @@\n error: rustc_outlives\n-  --> $DIR/explicit-union.rs:6:1\n+  --> $DIR/explicit-union.rs:5:1\n    |\n-LL | / union Foo<'b, U> {\n+LL | / union Foo<'b, U: Copy> {\n LL | |     bar: Bar<'b, U>\n LL | | }\n    | |_^"}, {"sha": "a42285a56d0890cb39d809e5494b26bd8bb9336a", "filename": "src/test/ui/rfc-2093-infer-outlives/nested-union.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2f0c821be9ba9cdf52a45c327b7d3f2831626225/src%2Ftest%2Fui%2Frfc-2093-infer-outlives%2Fnested-union.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2f0c821be9ba9cdf52a45c327b7d3f2831626225/src%2Ftest%2Fui%2Frfc-2093-infer-outlives%2Fnested-union.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc-2093-infer-outlives%2Fnested-union.stderr?ref=2f0c821be9ba9cdf52a45c327b7d3f2831626225", "patch": "@@ -1,7 +1,7 @@\n error: rustc_outlives\n-  --> $DIR/nested-union.rs:6:1\n+  --> $DIR/nested-union.rs:5:1\n    |\n-LL | / union Foo<'a, T> {\n+LL | / union Foo<'a, T: Copy> {\n LL | |     field1: Bar<'a, T>\n LL | | }\n    | |_^"}, {"sha": "8ba155bafb0b95526c0e13fa4ca9f2bd072db98a", "filename": "src/test/ui/union/union-borrow-move-parent-sibling.stderr", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/2f0c821be9ba9cdf52a45c327b7d3f2831626225/src%2Ftest%2Fui%2Funion%2Funion-borrow-move-parent-sibling.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2f0c821be9ba9cdf52a45c327b7d3f2831626225/src%2Ftest%2Fui%2Funion%2Funion-borrow-move-parent-sibling.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Funion%2Funion-borrow-move-parent-sibling.stderr?ref=2f0c821be9ba9cdf52a45c327b7d3f2831626225", "patch": "@@ -1,5 +1,5 @@\n error[E0502]: cannot borrow `u` (via `u.y`) as immutable because it is also borrowed as mutable (via `u.x.0`)\n-  --> $DIR/union-borrow-move-parent-sibling.rs:54:13\n+  --> $DIR/union-borrow-move-parent-sibling.rs:53:13\n    |\n LL |     let a = &mut u.x.0;\n    |             ---------- mutable borrow occurs here (via `u.x.0`)\n@@ -11,7 +11,7 @@ LL |     use_borrow(a);\n    = note: `u.y` is a field of the union `U`, so it overlaps the field `u.x.0`\n \n error[E0382]: use of moved value: `u`\n-  --> $DIR/union-borrow-move-parent-sibling.rs:61:13\n+  --> $DIR/union-borrow-move-parent-sibling.rs:60:13\n    |\n LL |     let u = U { x: ((MockVec::new(), MockVec::new()), MockVec::new()) };\n    |         - move occurs because `u` has type `U`, which does not implement the `Copy` trait\n@@ -21,7 +21,7 @@ LL |     let b = u.y;\n    |             ^^^ value used here after move\n \n error[E0502]: cannot borrow `u` (via `u.y`) as immutable because it is also borrowed as mutable (via `u.x.0.0`)\n-  --> $DIR/union-borrow-move-parent-sibling.rs:67:13\n+  --> $DIR/union-borrow-move-parent-sibling.rs:66:13\n    |\n LL |     let a = &mut (u.x.0).0;\n    |             -------------- mutable borrow occurs here (via `u.x.0.0`)\n@@ -33,7 +33,7 @@ LL |     use_borrow(a);\n    = note: `u.y` is a field of the union `U`, so it overlaps the field `u.x.0.0`\n \n error[E0382]: use of moved value: `u`\n-  --> $DIR/union-borrow-move-parent-sibling.rs:74:13\n+  --> $DIR/union-borrow-move-parent-sibling.rs:73:13\n    |\n LL |     let u = U { x: ((MockVec::new(), MockVec::new()), MockVec::new()) };\n    |         - move occurs because `u` has type `U`, which does not implement the `Copy` trait\n@@ -43,7 +43,7 @@ LL |     let b = u.y;\n    |             ^^^ value used here after move\n \n error[E0502]: cannot borrow `u` (via `u.x`) as immutable because it is also borrowed as mutable (via `u.y`)\n-  --> $DIR/union-borrow-move-parent-sibling.rs:80:13\n+  --> $DIR/union-borrow-move-parent-sibling.rs:79:13\n    |\n LL |     let a = &mut *u.y;\n    |                   --- mutable borrow occurs here (via `u.y`)"}, {"sha": "60e280f53f52c8dc0caabf6f4aad068a4c312c73", "filename": "src/test/ui/union/union-derive-clone.rs", "status": "modified", "additions": 10, "deletions": 3, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/2f0c821be9ba9cdf52a45c327b7d3f2831626225/src%2Ftest%2Fui%2Funion%2Funion-derive-clone.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f0c821be9ba9cdf52a45c327b7d3f2831626225/src%2Ftest%2Fui%2Funion%2Funion-derive-clone.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Funion%2Funion-derive-clone.rs?ref=2f0c821be9ba9cdf52a45c327b7d3f2831626225", "patch": "@@ -1,5 +1,7 @@\n #![feature(untagged_unions)]\n \n+use std::mem::ManuallyDrop;\n+\n #[derive(Clone)] //~ ERROR the trait bound `U1: std::marker::Copy` is not satisfied\n union U1 {\n     a: u8,\n@@ -18,14 +20,19 @@ union U3 {\n }\n \n #[derive(Clone, Copy)]\n-union U4<T> {\n+union U4<T: Copy> {\n     a: T, // OK\n }\n \n+#[derive(Clone, Copy)]\n+union U5<T> {\n+    a: ManuallyDrop<T>, // OK\n+}\n+\n #[derive(Clone)]\n struct CloneNoCopy;\n \n fn main() {\n-    let u = U4 { a: CloneNoCopy };\n-    let w = u.clone(); //~ ERROR no method named `clone` found for type `U4<CloneNoCopy>`\n+    let u = U5 { a: ManuallyDrop::new(CloneNoCopy) };\n+    let w = u.clone(); //~ ERROR no method named `clone` found for type `U5<CloneNoCopy>`\n }"}, {"sha": "a6dcd556a1fee18bc3543d840a80ebc7917c09e3", "filename": "src/test/ui/union/union-derive-clone.stderr", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/2f0c821be9ba9cdf52a45c327b7d3f2831626225/src%2Ftest%2Fui%2Funion%2Funion-derive-clone.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2f0c821be9ba9cdf52a45c327b7d3f2831626225/src%2Ftest%2Fui%2Funion%2Funion-derive-clone.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Funion%2Funion-derive-clone.stderr?ref=2f0c821be9ba9cdf52a45c327b7d3f2831626225", "patch": "@@ -1,22 +1,22 @@\n error[E0277]: the trait bound `U1: std::marker::Copy` is not satisfied\n-  --> $DIR/union-derive-clone.rs:3:10\n+  --> $DIR/union-derive-clone.rs:5:10\n    |\n LL | #[derive(Clone)]\n    |          ^^^^^ the trait `std::marker::Copy` is not implemented for `U1`\n    |\n    = note: required by `std::clone::AssertParamIsCopy`\n \n-error[E0599]: no method named `clone` found for type `U4<CloneNoCopy>` in the current scope\n-  --> $DIR/union-derive-clone.rs:30:15\n+error[E0599]: no method named `clone` found for type `U5<CloneNoCopy>` in the current scope\n+  --> $DIR/union-derive-clone.rs:37:15\n    |\n-LL | union U4<T> {\n+LL | union U5<T> {\n    | ----------- method `clone` not found for this\n ...\n LL |     let w = u.clone();\n    |               ^^^^^ method not found in `U4<CloneNoCopy>`\n    |\n    = note: the method `clone` exists but the following trait bounds were not satisfied:\n-           `U4<CloneNoCopy> : std::clone::Clone`\n+           `U5<CloneNoCopy> : std::clone::Clone`\n    = help: items from traits can only be used if the trait is implemented and in scope\n    = note: the following trait defines an item `clone`, perhaps you need to implement it:\n            candidate #1: `std::clone::Clone`"}, {"sha": "8535cbd019ce87c6871f2dfbc8511df2e186c25a", "filename": "src/test/ui/union/union-unsafe.rs", "status": "modified", "additions": 22, "deletions": 12, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/2f0c821be9ba9cdf52a45c327b7d3f2831626225/src%2Ftest%2Fui%2Funion%2Funion-unsafe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f0c821be9ba9cdf52a45c327b7d3f2831626225/src%2Ftest%2Fui%2Funion%2Funion-unsafe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Funion%2Funion-unsafe.rs?ref=2f0c821be9ba9cdf52a45c327b7d3f2831626225", "patch": "@@ -1,29 +1,33 @@\n #![feature(untagged_unions)]\n+use std::mem::ManuallyDrop;\n \n union U1 {\n     a: u8\n }\n \n union U2 {\n-    a: String\n+    a: ManuallyDrop<String>\n }\n \n union U3<T> {\n-    a: T\n+    a: ManuallyDrop<T>\n }\n \n union U4<T: Copy> {\n     a: T\n }\n \n fn generic_noncopy<T: Default>() {\n-    let mut u3 = U3 { a: T::default() };\n-    u3.a = T::default(); //~ ERROR assignment to non-`Copy` union field is unsafe\n+    let mut u3 = U3 { a: ManuallyDrop::new(T::default()) };\n+    u3.a = ManuallyDrop::new(T::default()); //~ ERROR assignment to non-`Copy` union field is unsafe\n+    *u3.a = T::default(); //~ ERROR access to union field is unsafe\n }\n \n fn generic_copy<T: Copy + Default>() {\n-    let mut u3 = U3 { a: T::default() };\n-    u3.a = T::default(); // OK\n+    let mut u3 = U3 { a: ManuallyDrop::new(T::default()) };\n+    u3.a = ManuallyDrop::new(T::default()); // OK\n+    *u3.a = T::default(); //~ ERROR access to union field is unsafe\n+\n     let mut u4 = U4 { a: T::default() };\n     u4.a = T::default(); // OK\n }\n@@ -32,14 +36,20 @@ fn main() {\n     let mut u1 = U1 { a: 10 }; // OK\n     let a = u1.a; //~ ERROR access to union field is unsafe\n     u1.a = 11; // OK\n+\n     let U1 { a } = u1; //~ ERROR access to union field is unsafe\n     if let U1 { a: 12 } = u1 {} //~ ERROR access to union field is unsafe\n     // let U1 { .. } = u1; // OK\n \n-    let mut u2 = U2 { a: String::from(\"old\") }; // OK\n-    u2.a = String::from(\"new\"); //~ ERROR assignment to non-`Copy` union field is unsafe\n-    let mut u3 = U3 { a: 0 }; // OK\n-    u3.a = 1; // OK\n-    let mut u3 = U3 { a: String::from(\"old\") }; // OK\n-    u3.a = String::from(\"new\"); //~ ERROR assignment to non-`Copy` union field is unsafe\n+    let mut u2 = U2 { a: ManuallyDrop::new(String::from(\"old\")) }; // OK\n+    u2.a = ManuallyDrop::new(String::from(\"new\")); //~ ERROR assignment to non-`Copy` union\n+    *u2.a = String::from(\"new\"); //~ ERROR access to union field is unsafe\n+\n+    let mut u3 = U3 { a: ManuallyDrop::new(0) }; // OK\n+    u3.a = ManuallyDrop::new(1); // OK\n+    *u3.a = 1; //~ ERROR access to union field is unsafe\n+\n+    let mut u3 = U3 { a: ManuallyDrop::new(String::from(\"old\")) }; // OK\n+    u3.a = ManuallyDrop::new(String::from(\"new\")); //~ ERROR assignment to non-`Copy` union\n+    *u3.a = String::from(\"new\"); //~ ERROR access to union field is unsafe\n }"}, {"sha": "e020dab63f8f442d503b119caf1b59bcd2d53793", "filename": "src/test/ui/union/union-unsafe.stderr", "status": "modified", "additions": 53, "deletions": 13, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/2f0c821be9ba9cdf52a45c327b7d3f2831626225/src%2Ftest%2Fui%2Funion%2Funion-unsafe.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2f0c821be9ba9cdf52a45c327b7d3f2831626225/src%2Ftest%2Fui%2Funion%2Funion-unsafe.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Funion%2Funion-unsafe.stderr?ref=2f0c821be9ba9cdf52a45c327b7d3f2831626225", "patch": "@@ -1,51 +1,91 @@\n error[E0133]: assignment to non-`Copy` union field is unsafe and requires unsafe function or block\n-  --> $DIR/union-unsafe.rs:21:5\n+  --> $DIR/union-unsafe.rs:22:5\n    |\n-LL |     u3.a = T::default();\n-   |     ^^^^ assignment to non-`Copy` union field\n+LL |     u3.a = ManuallyDrop::new(T::default());\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ assignment to non-`Copy` union field\n    |\n    = note: the previous content of the field will be dropped, which causes undefined behavior if the field was not properly initialized\n \n error[E0133]: access to union field is unsafe and requires unsafe function or block\n-  --> $DIR/union-unsafe.rs:33:13\n+  --> $DIR/union-unsafe.rs:23:6\n+   |\n+LL |     *u3.a = T::default();\n+   |      ^^^^ access to union field\n+   |\n+   = note: the field may not be properly initialized: using uninitialized data will cause undefined behavior\n+\n+error[E0133]: access to union field is unsafe and requires unsafe function or block\n+  --> $DIR/union-unsafe.rs:29:6\n+   |\n+LL |     *u3.a = T::default();\n+   |      ^^^^ access to union field\n+   |\n+   = note: the field may not be properly initialized: using uninitialized data will cause undefined behavior\n+\n+error[E0133]: access to union field is unsafe and requires unsafe function or block\n+  --> $DIR/union-unsafe.rs:37:13\n    |\n LL |     let a = u1.a;\n    |             ^^^^ access to union field\n    |\n    = note: the field may not be properly initialized: using uninitialized data will cause undefined behavior\n \n error[E0133]: access to union field is unsafe and requires unsafe function or block\n-  --> $DIR/union-unsafe.rs:35:14\n+  --> $DIR/union-unsafe.rs:40:14\n    |\n LL |     let U1 { a } = u1;\n    |              ^ access to union field\n    |\n    = note: the field may not be properly initialized: using uninitialized data will cause undefined behavior\n \n error[E0133]: access to union field is unsafe and requires unsafe function or block\n-  --> $DIR/union-unsafe.rs:36:20\n+  --> $DIR/union-unsafe.rs:41:20\n    |\n LL |     if let U1 { a: 12 } = u1 {}\n    |                    ^^ access to union field\n    |\n    = note: the field may not be properly initialized: using uninitialized data will cause undefined behavior\n \n error[E0133]: assignment to non-`Copy` union field is unsafe and requires unsafe function or block\n-  --> $DIR/union-unsafe.rs:40:5\n+  --> $DIR/union-unsafe.rs:45:5\n    |\n-LL |     u2.a = String::from(\"new\");\n-   |     ^^^^ assignment to non-`Copy` union field\n+LL |     u2.a = ManuallyDrop::new(String::from(\"new\"));\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ assignment to non-`Copy` union field\n    |\n    = note: the previous content of the field will be dropped, which causes undefined behavior if the field was not properly initialized\n \n+error[E0133]: access to union field is unsafe and requires unsafe function or block\n+  --> $DIR/union-unsafe.rs:46:6\n+   |\n+LL |     *u2.a = String::from(\"new\");\n+   |      ^^^^ access to union field\n+   |\n+   = note: the field may not be properly initialized: using uninitialized data will cause undefined behavior\n+\n+error[E0133]: access to union field is unsafe and requires unsafe function or block\n+  --> $DIR/union-unsafe.rs:50:6\n+   |\n+LL |     *u3.a = 1;\n+   |      ^^^^ access to union field\n+   |\n+   = note: the field may not be properly initialized: using uninitialized data will cause undefined behavior\n+\n error[E0133]: assignment to non-`Copy` union field is unsafe and requires unsafe function or block\n-  --> $DIR/union-unsafe.rs:44:5\n+  --> $DIR/union-unsafe.rs:53:5\n    |\n-LL |     u3.a = String::from(\"new\");\n-   |     ^^^^ assignment to non-`Copy` union field\n+LL |     u3.a = ManuallyDrop::new(String::from(\"new\"));\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ assignment to non-`Copy` union field\n    |\n    = note: the previous content of the field will be dropped, which causes undefined behavior if the field was not properly initialized\n \n-error: aborting due to 6 previous errors\n+error[E0133]: access to union field is unsafe and requires unsafe function or block\n+  --> $DIR/union-unsafe.rs:54:6\n+   |\n+LL |     *u3.a = String::from(\"new\");\n+   |      ^^^^ access to union field\n+   |\n+   = note: the field may not be properly initialized: using uninitialized data will cause undefined behavior\n+\n+error: aborting due to 11 previous errors\n \n For more information about this error, try `rustc --explain E0133`."}, {"sha": "2f90f240d2e1947e05807f22bf49dbfa0dfdb4bb", "filename": "src/test/ui/union/union-with-drop-fields-lint.stderr", "status": "removed", "additions": 0, "deletions": 26, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/84ca0a1cb47f71a43ee16da2f6bc173577b35cb9/src%2Ftest%2Fui%2Funion%2Funion-with-drop-fields-lint.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/84ca0a1cb47f71a43ee16da2f6bc173577b35cb9/src%2Ftest%2Fui%2Funion%2Funion-with-drop-fields-lint.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Funion%2Funion-with-drop-fields-lint.stderr?ref=84ca0a1cb47f71a43ee16da2f6bc173577b35cb9", "patch": "@@ -1,26 +0,0 @@\n-error: union contains a field with possibly non-trivial drop code, drop code of union fields is ignored when dropping the union\n-  --> $DIR/union-with-drop-fields-lint.rs:10:5\n-   |\n-LL |     a: String,\n-   |     ^^^^^^^^^\n-   |\n-note: lint level defined here\n-  --> $DIR/union-with-drop-fields-lint.rs:3:9\n-   |\n-LL | #![deny(unions_with_drop_fields)]\n-   |         ^^^^^^^^^^^^^^^^^^^^^^^\n-\n-error: union contains a field with possibly non-trivial drop code, drop code of union fields is ignored when dropping the union\n-  --> $DIR/union-with-drop-fields-lint.rs:18:5\n-   |\n-LL |     a: S,\n-   |     ^^^^\n-\n-error: union contains a field with possibly non-trivial drop code, drop code of union fields is ignored when dropping the union\n-  --> $DIR/union-with-drop-fields-lint.rs:23:5\n-   |\n-LL |     a: T,\n-   |     ^^^^\n-\n-error: aborting due to 3 previous errors\n-"}, {"sha": "e3c63a6d5b5a2e7ad447a3ff7bb7a8d3e794e4fa", "filename": "src/test/ui/union/union-with-drop-fields.rs", "status": "renamed", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/2f0c821be9ba9cdf52a45c327b7d3f2831626225/src%2Ftest%2Fui%2Funion%2Funion-with-drop-fields.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f0c821be9ba9cdf52a45c327b7d3f2831626225/src%2Ftest%2Fui%2Funion%2Funion-with-drop-fields.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Funion%2Funion-with-drop-fields.rs?ref=2f0c821be9ba9cdf52a45c327b7d3f2831626225", "patch": "@@ -1,26 +1,25 @@\n #![feature(untagged_unions)]\n #![allow(dead_code)]\n-#![deny(unions_with_drop_fields)]\n \n union U {\n     a: u8, // OK\n }\n \n union W {\n-    a: String, //~ ERROR union contains a field with possibly non-trivial drop code\n+    a: String, //~ ERROR unions may not contain fields that need dropping\n     b: String, // OK, only one field is reported\n }\n \n struct S(String);\n \n // `S` doesn't implement `Drop` trait, but still has non-trivial destructor\n union Y {\n-    a: S, //~ ERROR union contains a field with possibly non-trivial drop code\n+    a: S, //~ ERROR unions may not contain fields that need dropping\n }\n \n // We don't know if `T` is trivially-destructable or not until trans\n union J<T> {\n-    a: T, //~ ERROR union contains a field with possibly non-trivial drop code\n+    a: T, //~ ERROR unions may not contain fields that need dropping\n }\n \n union H<T: Copy> {", "previous_filename": "src/test/ui/union/union-with-drop-fields-lint.rs"}, {"sha": "0e77279be616a7a1f71b2759a70e1b29a776dcfa", "filename": "src/test/ui/union/union-with-drop-fields.stderr", "status": "added", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/2f0c821be9ba9cdf52a45c327b7d3f2831626225/src%2Ftest%2Fui%2Funion%2Funion-with-drop-fields.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2f0c821be9ba9cdf52a45c327b7d3f2831626225/src%2Ftest%2Fui%2Funion%2Funion-with-drop-fields.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Funion%2Funion-with-drop-fields.stderr?ref=2f0c821be9ba9cdf52a45c327b7d3f2831626225", "patch": "@@ -0,0 +1,39 @@\n+error[E0740]: unions may not contain fields that need dropping\n+  --> $DIR/union-with-drop-fields.rs:9:5\n+   |\n+LL |     a: String,\n+   |     ^^^^^^^^^\n+   |\n+note: `std::mem::ManuallyDrop` can be used to wrap the type\n+  --> $DIR/union-with-drop-fields.rs:9:5\n+   |\n+LL |     a: String,\n+   |     ^^^^^^^^^\n+\n+error[E0740]: unions may not contain fields that need dropping\n+  --> $DIR/union-with-drop-fields.rs:17:5\n+   |\n+LL |     a: S,\n+   |     ^^^^\n+   |\n+note: `std::mem::ManuallyDrop` can be used to wrap the type\n+  --> $DIR/union-with-drop-fields.rs:17:5\n+   |\n+LL |     a: S,\n+   |     ^^^^\n+\n+error[E0740]: unions may not contain fields that need dropping\n+  --> $DIR/union-with-drop-fields.rs:22:5\n+   |\n+LL |     a: T,\n+   |     ^^^^\n+   |\n+note: `std::mem::ManuallyDrop` can be used to wrap the type\n+  --> $DIR/union-with-drop-fields.rs:22:5\n+   |\n+LL |     a: T,\n+   |     ^^^^\n+\n+error: aborting due to 3 previous errors\n+\n+For more information about this error, try `rustc --explain E0740`."}]}