{"sha": "daf432e8b6a830ae8a9ee120bec0113f85214a65", "node_id": "MDY6Q29tbWl0NzI0NzEyOmRhZjQzMmU4YjZhODMwYWU4YTllZTEyMGJlYzAxMTNmODUyMTRhNjU=", "commit": {"author": {"name": "nham", "email": "hamann.nick@gmail.com", "date": "2014-08-06T05:25:48Z"}, "committer": {"name": "nham", "email": "hamann.nick@gmail.com", "date": "2014-08-06T05:25:48Z"}, "message": "Use byte literals in libterm", "tree": {"sha": "4f517709f6ee219ccff0837c1e4bff135b128609", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4f517709f6ee219ccff0837c1e4bff135b128609"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/daf432e8b6a830ae8a9ee120bec0113f85214a65", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/daf432e8b6a830ae8a9ee120bec0113f85214a65", "html_url": "https://github.com/rust-lang/rust/commit/daf432e8b6a830ae8a9ee120bec0113f85214a65", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/daf432e8b6a830ae8a9ee120bec0113f85214a65/comments", "author": {"login": "nham", "id": 546409, "node_id": "MDQ6VXNlcjU0NjQwOQ==", "avatar_url": "https://avatars.githubusercontent.com/u/546409?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nham", "html_url": "https://github.com/nham", "followers_url": "https://api.github.com/users/nham/followers", "following_url": "https://api.github.com/users/nham/following{/other_user}", "gists_url": "https://api.github.com/users/nham/gists{/gist_id}", "starred_url": "https://api.github.com/users/nham/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nham/subscriptions", "organizations_url": "https://api.github.com/users/nham/orgs", "repos_url": "https://api.github.com/users/nham/repos", "events_url": "https://api.github.com/users/nham/events{/privacy}", "received_events_url": "https://api.github.com/users/nham/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nham", "id": 546409, "node_id": "MDQ6VXNlcjU0NjQwOQ==", "avatar_url": "https://avatars.githubusercontent.com/u/546409?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nham", "html_url": "https://github.com/nham", "followers_url": "https://api.github.com/users/nham/followers", "following_url": "https://api.github.com/users/nham/following{/other_user}", "gists_url": "https://api.github.com/users/nham/gists{/gist_id}", "starred_url": "https://api.github.com/users/nham/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nham/subscriptions", "organizations_url": "https://api.github.com/users/nham/orgs", "repos_url": "https://api.github.com/users/nham/repos", "events_url": "https://api.github.com/users/nham/events{/privacy}", "received_events_url": "https://api.github.com/users/nham/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "30cfce3d922b7c48d79e5c0f87eda9670ed09f6a", "url": "https://api.github.com/repos/rust-lang/rust/commits/30cfce3d922b7c48d79e5c0f87eda9670ed09f6a", "html_url": "https://github.com/rust-lang/rust/commit/30cfce3d922b7c48d79e5c0f87eda9670ed09f6a"}], "stats": {"total": 33, "additions": 16, "deletions": 17}, "files": [{"sha": "fdbe6eeadfd8a0fee4231f6a079d63b86597a35b", "filename": "src/libterm/terminfo/parm.rs", "status": "modified", "additions": 16, "deletions": 17, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/daf432e8b6a830ae8a9ee120bec0113f85214a65/src%2Flibterm%2Fterminfo%2Fparm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/daf432e8b6a830ae8a9ee120bec0113f85214a65/src%2Flibterm%2Fterminfo%2Fparm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibterm%2Fterminfo%2Fparm.rs?ref=daf432e8b6a830ae8a9ee120bec0113f85214a65", "patch": "@@ -301,12 +301,12 @@ pub fn expand(cap: &[u8], params: &[Param], vars: &mut Variables)\n             SetVar => {\n                 if cur >= 'A' && cur <= 'Z' {\n                     if stack.len() > 0 {\n-                        let idx = (cur as u8) - ('A' as u8);\n+                        let idx = (cur as u8) - b'A';\n                         vars.sta[idx as uint] = stack.pop().unwrap();\n                     } else { return Err(\"stack is empty\".to_string()) }\n                 } else if cur >= 'a' && cur <= 'z' {\n                     if stack.len() > 0 {\n-                        let idx = (cur as u8) - ('a' as u8);\n+                        let idx = (cur as u8) - b'a';\n                         vars.dyn[idx as uint] = stack.pop().unwrap();\n                     } else { return Err(\"stack is empty\".to_string()) }\n                 } else {\n@@ -315,10 +315,10 @@ pub fn expand(cap: &[u8], params: &[Param], vars: &mut Variables)\n             },\n             GetVar => {\n                 if cur >= 'A' && cur <= 'Z' {\n-                    let idx = (cur as u8) - ('A' as u8);\n+                    let idx = (cur as u8) - b'A';\n                     stack.push(vars.sta[idx as uint].clone());\n                 } else if cur >= 'a' && cur <= 'z' {\n-                    let idx = (cur as u8) - ('a' as u8);\n+                    let idx = (cur as u8) - b'a';\n                     stack.push(vars.dyn[idx as uint].clone());\n                 } else {\n                     return Err(\"bad variable name in %g\".to_string());\n@@ -505,26 +505,25 @@ fn format(val: Param, op: FormatOp, flags: Flags) -> Result<Vec<u8> ,String> {\n             if flags.precision > s.len() {\n                 let mut s_ = Vec::with_capacity(flags.precision);\n                 let n = flags.precision - s.len();\n-                s_.grow(n, &('0' as u8));\n+                s_.grow(n, &b'0');\n                 s_.push_all_move(s);\n                 s = s_;\n             }\n             assert!(!s.is_empty(), \"string conversion produced empty result\");\n             match op {\n                 FormatDigit => {\n-                    if flags.space && !(s[0] == '-' as u8 ||\n-                                        s[0] == '+' as u8) {\n-                        s.insert(0, ' ' as u8);\n+                    if flags.space && !(s[0] == b'-' || s[0] == b'+' ) {\n+                        s.insert(0, b' ');\n                     }\n                 }\n                 FormatOctal => {\n-                    if flags.alternate && s[0] != '0' as u8 {\n-                        s.insert(0, '0' as u8);\n+                    if flags.alternate && s[0] != b'0' {\n+                        s.insert(0, b'0');\n                     }\n                 }\n                 FormatHex => {\n                     if flags.alternate {\n-                        let s_ = replace(&mut s, vec!('0' as u8, 'x' as u8));\n+                        let s_ = replace(&mut s, vec!(b'0', b'x'));\n                         s.push_all_move(s_);\n                     }\n                 }\n@@ -536,7 +535,7 @@ fn format(val: Param, op: FormatOp, flags: Flags) -> Result<Vec<u8> ,String> {\n                          .move_iter()\n                          .collect();\n                     if flags.alternate {\n-                        let s_ = replace(&mut s, vec!('0' as u8, 'X' as u8));\n+                        let s_ = replace(&mut s, vec!(b'0', b'X'));\n                         s.push_all_move(s_);\n                     }\n                 }\n@@ -563,10 +562,10 @@ fn format(val: Param, op: FormatOp, flags: Flags) -> Result<Vec<u8> ,String> {\n     if flags.width > s.len() {\n         let n = flags.width - s.len();\n         if flags.left {\n-            s.grow(n, &(' ' as u8));\n+            s.grow(n, &b' ');\n         } else {\n             let mut s_ = Vec::with_capacity(flags.width);\n-            s_.grow(n, &(' ' as u8));\n+            s_.grow(n, &b' ');\n             s_.push_all_move(s);\n             s = s_;\n         }\n@@ -655,15 +654,15 @@ mod test {\n             let s = format!(\"%{{1}}%{{2}}%{}%d\", op);\n             let res = expand(s.as_bytes(), [], &mut Variables::new());\n             assert!(res.is_ok(), res.unwrap_err());\n-            assert_eq!(res.unwrap(), vec!('0' as u8 + bs[0]));\n+            assert_eq!(res.unwrap(), vec!(b'0' + bs[0]));\n             let s = format!(\"%{{1}}%{{1}}%{}%d\", op);\n             let res = expand(s.as_bytes(), [], &mut Variables::new());\n             assert!(res.is_ok(), res.unwrap_err());\n-            assert_eq!(res.unwrap(), vec!('0' as u8 + bs[1]));\n+            assert_eq!(res.unwrap(), vec!(b'0' + bs[1]));\n             let s = format!(\"%{{2}}%{{1}}%{}%d\", op);\n             let res = expand(s.as_bytes(), [], &mut Variables::new());\n             assert!(res.is_ok(), res.unwrap_err());\n-            assert_eq!(res.unwrap(), vec!('0' as u8 + bs[2]));\n+            assert_eq!(res.unwrap(), vec!(b'0' + bs[2]));\n         }\n     }\n "}]}