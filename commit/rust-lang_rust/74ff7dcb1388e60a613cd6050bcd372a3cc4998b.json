{"sha": "74ff7dcb1388e60a613cd6050bcd372a3cc4998b", "node_id": "MDY6Q29tbWl0NzI0NzEyOjc0ZmY3ZGNiMTM4OGU2MGE2MTNjZDYwNTBiY2QzNzJhM2NjNDk5OGI=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-10-19T09:29:48Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-10-19T09:29:48Z"}, "message": "Auto merge of #55194 - kennytm:rollup, r=kennytm\n\nRollup of 7 pull requests\n\nSuccessful merges:\n\n - #54300 (Updated RELEASES.md for 1.30.0)\n - #55013 ([NLL] Propagate bounds from generators)\n - #55071 (Fix ICE and report a human readable error)\n - #55144 (Cleanup resolve)\n - #55166 (Don't warn about parentheses on `match (return)`)\n - #55169 (Add a `copysign` function to f32 and f64)\n - #55178 (Stabilize slice::chunks_exact(), chunks_exact_mut(), rchunks(), rchunks_mut(), rchunks_exact(), rchunks_exact_mut())", "tree": {"sha": "4b035c9be0ee57066b2427b5d98794887b4f6e75", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4b035c9be0ee57066b2427b5d98794887b4f6e75"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/74ff7dcb1388e60a613cd6050bcd372a3cc4998b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/74ff7dcb1388e60a613cd6050bcd372a3cc4998b", "html_url": "https://github.com/rust-lang/rust/commit/74ff7dcb1388e60a613cd6050bcd372a3cc4998b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/74ff7dcb1388e60a613cd6050bcd372a3cc4998b/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "dbab381da1a46a18e46a04a61156aec40c59a4f6", "url": "https://api.github.com/repos/rust-lang/rust/commits/dbab381da1a46a18e46a04a61156aec40c59a4f6", "html_url": "https://github.com/rust-lang/rust/commit/dbab381da1a46a18e46a04a61156aec40c59a4f6"}, {"sha": "0724efd9a1aac9cf4620795786fb8e896fbb17b3", "url": "https://api.github.com/repos/rust-lang/rust/commits/0724efd9a1aac9cf4620795786fb8e896fbb17b3", "html_url": "https://github.com/rust-lang/rust/commit/0724efd9a1aac9cf4620795786fb8e896fbb17b3"}], "stats": {"total": 743, "additions": 504, "deletions": 239}, "files": [{"sha": "b40897a7509fa8e81a252589d0d5ff88398a8cc4", "filename": "RELEASES.md", "status": "modified", "additions": 126, "deletions": 0, "changes": 126, "blob_url": "https://github.com/rust-lang/rust/blob/74ff7dcb1388e60a613cd6050bcd372a3cc4998b/RELEASES.md", "raw_url": "https://github.com/rust-lang/rust/raw/74ff7dcb1388e60a613cd6050bcd372a3cc4998b/RELEASES.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/RELEASES.md?ref=74ff7dcb1388e60a613cd6050bcd372a3cc4998b", "patch": "@@ -1,3 +1,124 @@\n+Version 1.30.0 (2018-10-25)\n+==========================\n+\n+Language\n+--------\n+- [Procedural macros are now available.][52081] These kinds of macros allow for\n+  more powerful code generation, there is a [new chapter available][proc-macros]\n+  in Rust Programming Language book that goes further in depth.\n+- [You can now use keywords as identifiers using the raw identifiers\n+  syntax (`r#`).][53236] e.g. `let r#bool = true;`\n+- [Using anonymous parameters in traits is now deprecated with a warning and\n+  will be a hard error in the 2018 edition.][53272]\n+- [You can now use `crate` in paths.][54404] This allows you to refer to the\n+  crate root in the path. e.g. `use crate::foo;` refers to `foo` in `src/lib.rs`.\n+- [Using a external crate now no longer requires being prefixed with `::`.][54404]\n+  e.g. previously using a external crate in a module without a use statement\n+  required `let json = ::serde_json::from_str(foo);` can now be written\n+  as `let json = serde_json::from_str(foo);`.\n+- [You can now apply the `#[used]` attribute to static items to prevent the\n+  compiler from optimising them away even if they appear to be unused.][51363]\n+  e.g. `#[used] static FOO: u32 = 1;`\n+- [You can now import and reexport macros from other crates with the `use`\n+  syntax.][50911] Macros exported with `#[macro_export]` are now placed into\n+  the root module of the crate. If your macro relies on calling other local\n+  macros it is recommended to export with the\n+  `#[macro_export(local_inner_macros)]` attribute so that users won't have to\n+  import those macros.\n+- [`mod.rs` files are now optional.][54146] Previously if you had a `foo` module\n+  with a `bar` submodule, you would have `src/foo/mod.rs` and `src/foo/bar.rs`.\n+  Now you can have `src/foo.rs` and `src/foo/bar.rs` to achieve the same effect.\n+- [You can now catch visibility keywords (e.g. `pub`, `pub(crate)`) in macros\n+  using the `vis` specifier.][53370]\n+- [Non-macro attributes now allow all forms of literals not just\n+  strings.][53044] e.g. Previously you would write `#[attr(\"true\")]` you can now\n+  write `#[attr(true)]`.\n+- [You can now specify a function to handle a panic in the Rust runtime with the\n+  `#[panic_handler]` attribute.][51366]\n+\n+Compiler\n+--------\n+- [Added the `riscv32imc-unknown-none-elf` target.][53822]\n+- [Added the `aarch64-unknown-netbsd` target][53165]\n+\n+Libraries\n+---------\n+- [`ManuallyDrop` now allows the inner type to be unsized.][53033]\n+\n+Stabilized APIs\n+---------------\n+- [`Ipv4Addr::BROADCAST`]\n+- [`Ipv4Addr::LOCALHOST`]\n+- [`Ipv4Addr::UNSPECIFIED`]\n+- [`Ipv6Addr::LOCALHOST`]\n+- [`Ipv6Addr::UNSPECIFIED`]\n+- [`Iterator::find_map`]\n+\n+  The following methods are a replacement methods for `trim_left`, `trim_right`,\n+  `trim_left_matches`, and `trim_right_matches`. Which will be deprecated\n+  in 1.33.0.\n+- [`str::trim_end_matches`]\n+- [`str::trim_end`]\n+- [`str::trim_start_matches`]\n+- [`str::trim_start`]\n+\n+Cargo\n+----\n+- [`cargo run` doesn't require specifying a package in workspaces.][cargo/5877]\n+- [`cargo doc` now supports `--message-format=json`.][cargo/5878] This is\n+  equivalent to calling `rustdoc --error-format=json`.\n+- [You can specify which edition to create a project in cargo\n+  with `cargo new --edition`.][cargo/5984] Currently only `2015` is a\n+  valid option.\n+- [Cargo will now provide a progress bar for builds.][cargo/5995]\n+\n+Misc\n+----\n+- [`rustdoc` allows you to specify what edition to treat your code as with the\n+  `--edition` option.][54057]\n+- [`rustdoc` now has the `--color` (Specify whether to output color) and\n+  `--error-format` (Specify error format e.g. `json`) options.][53003]\n+- [We now distribute a `rust-gdbgui` script that invokes `gdbgui` with Rust\n+  debug symbols.][53774]\n+- [Attributes from Rust tools such as `rustfmt` or `clippy` are now\n+  available.][53459] e.g. `#[rustfmt::skip]` will skip formatting the next item.\n+\n+[50911]: https://github.com/rust-lang/rust/pull/50911/\n+[51363]: https://github.com/rust-lang/rust/pull/51363/\n+[51366]: https://github.com/rust-lang/rust/pull/51366/\n+[52081]: https://github.com/rust-lang/rust/pull/52081/\n+[53003]: https://github.com/rust-lang/rust/pull/53003/\n+[53033]: https://github.com/rust-lang/rust/pull/53033/\n+[53044]: https://github.com/rust-lang/rust/pull/53044/\n+[53165]: https://github.com/rust-lang/rust/pull/53165/\n+[53213]: https://github.com/rust-lang/rust/pull/53213/\n+[53236]: https://github.com/rust-lang/rust/pull/53236/\n+[53272]: https://github.com/rust-lang/rust/pull/53272/\n+[53370]: https://github.com/rust-lang/rust/pull/53370/\n+[53459]: https://github.com/rust-lang/rust/pull/53459/\n+[53774]: https://github.com/rust-lang/rust/pull/53774/\n+[53822]: https://github.com/rust-lang/rust/pull/53822/\n+[54057]: https://github.com/rust-lang/rust/pull/54057/\n+[54146]: https://github.com/rust-lang/rust/pull/54146/\n+[54404]: https://github.com/rust-lang/rust/pull/54404/\n+[cargo/5877]: https://github.com/rust-lang/cargo/pull/5877/\n+[cargo/5878]: https://github.com/rust-lang/cargo/pull/5878/\n+[cargo/5984]: https://github.com/rust-lang/cargo/pull/5984/\n+[cargo/5995]: https://github.com/rust-lang/cargo/pull/5995/\n+[proc-macros]: https://doc.rust-lang.org/book/2018-edition/ch19-06-macros.html\n+\n+[`Ipv4Addr::BROADCAST`]: https://doc.rust-lang.org/nightly/std/net/struct.Ipv4Addr.html#associatedconstant.BROADCAST\n+[`Ipv4Addr::LOCALHOST`]: https://doc.rust-lang.org/nightly/std/net/struct.Ipv4Addr.html#associatedconstant.LOCALHOST\n+[`Ipv4Addr::UNSPECIFIED`]: https://doc.rust-lang.org/nightly/std/net/struct.Ipv4Addr.html#associatedconstant.UNSPECIFIED\n+[`Ipv6Addr::LOCALHOST`]: https://doc.rust-lang.org/nightly/std/net/struct.Ipv6Addr.html#associatedconstant.LOCALHOST\n+[`Ipv6Addr::UNSPECIFIED`]: https://doc.rust-lang.org/nightly/std/net/struct.Ipv6Addr.html#associatedconstant.UNSPECIFIED\n+[`Iterator::find_map`]: https://doc.rust-lang.org/std/iter/trait.Iterator.html#method.find_map\n+[`str::trim_end_matches`]: https://doc.rust-lang.org/nightly/std/primitive.str.html#method.trim_end_matches\n+[`str::trim_end`]: https://doc.rust-lang.org/nightly/std/primitive.str.html#method.trim_end\n+[`str::trim_start_matches`]: https://doc.rust-lang.org/nightly/std/primitive.str.html#method.trim_start_matches\n+[`str::trim_start`]: https://doc.rust-lang.org/nightly/std/primitive.str.html#method.trim_start\n+\n+\n Version 1.29.2 (2018-10-11)\n ===========================\n \n@@ -6,6 +127,7 @@ Version 1.29.2 (2018-10-11)\n \n [54639]: https://github.com/rust-lang/rust/pull/54639\n \n+\n Version 1.29.1 (2018-09-25)\n ===========================\n \n@@ -19,6 +141,7 @@ Security Notes\n   Thank you to Scott McMurray for responsibily disclosing this vulnerability to\n   us.\n \n+\n Version 1.29.0 (2018-09-13)\n ==========================\n \n@@ -73,7 +196,10 @@ Compatibility Notes\n   Consider using the `home_dir` function from\n   https://crates.io/crates/dirs instead.\n - [`rustc` will no longer silently ignore invalid data in target spec.][52330]\n+- [`cfg` attributes and `--cfg` command line flags are now more\n+  strictly validated.][53893]\n \n+[53893]: https://github.com/rust-lang/rust/pull/53893/\n [52861]: https://github.com/rust-lang/rust/pull/52861/\n [52656]: https://github.com/rust-lang/rust/pull/52656/\n [52239]: https://github.com/rust-lang/rust/pull/52239/"}, {"sha": "84ca7c4fec9e5d4f154b4fe98a6aaea545887844", "filename": "src/liballoc/lib.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/74ff7dcb1388e60a613cd6050bcd372a3cc4998b/src%2Fliballoc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74ff7dcb1388e60a613cd6050bcd372a3cc4998b/src%2Fliballoc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Flib.rs?ref=74ff7dcb1388e60a613cd6050bcd372a3cc4998b", "patch": "@@ -115,12 +115,10 @@\n #![feature(unsize)]\n #![feature(allocator_internals)]\n #![feature(on_unimplemented)]\n-#![feature(chunks_exact)]\n #![feature(rustc_const_unstable)]\n #![feature(const_vec_new)]\n #![feature(slice_partition_dedup)]\n #![feature(maybe_uninit)]\n-#![feature(rchunks)]\n \n // Allow testing this library\n "}, {"sha": "1eaff7410ea6b2e5fda3e6871b144bfd34704479", "filename": "src/liballoc/slice.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/74ff7dcb1388e60a613cd6050bcd372a3cc4998b/src%2Fliballoc%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74ff7dcb1388e60a613cd6050bcd372a3cc4998b/src%2Fliballoc%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fslice.rs?ref=74ff7dcb1388e60a613cd6050bcd372a3cc4998b", "patch": "@@ -123,9 +123,9 @@ pub use core::slice::{from_raw_parts, from_raw_parts_mut};\n pub use core::slice::{from_ref, from_mut};\n #[stable(feature = \"slice_get_slice\", since = \"1.28.0\")]\n pub use core::slice::SliceIndex;\n-#[unstable(feature = \"chunks_exact\", issue = \"47115\")]\n+#[stable(feature = \"chunks_exact\", since = \"1.31.0\")]\n pub use core::slice::{ChunksExact, ChunksExactMut};\n-#[unstable(feature = \"rchunks\", issue = \"55177\")]\n+#[stable(feature = \"rchunks\", since = \"1.31.0\")]\n pub use core::slice::{RChunks, RChunksMut, RChunksExact, RChunksExactMut};\n \n ////////////////////////////////////////////////////////////////////////////////"}, {"sha": "6d1cfb10859d4bc4ee433c9247c66dbcbad1c088", "filename": "src/liballoc/tests/lib.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/74ff7dcb1388e60a613cd6050bcd372a3cc4998b/src%2Fliballoc%2Ftests%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74ff7dcb1388e60a613cd6050bcd372a3cc4998b/src%2Fliballoc%2Ftests%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Ftests%2Flib.rs?ref=74ff7dcb1388e60a613cd6050bcd372a3cc4998b", "patch": "@@ -19,8 +19,6 @@\n #![feature(str_escape)]\n #![feature(try_reserve)]\n #![feature(unboxed_closures)]\n-#![feature(chunks_exact)]\n-#![feature(rchunks)]\n #![feature(repeat_generic_slice)]\n \n extern crate alloc_system;"}, {"sha": "8a6b212020b4e4a0d74f661d675a604bafce40b1", "filename": "src/libcore/slice/mod.rs", "status": "modified", "additions": 49, "deletions": 61, "changes": 110, "blob_url": "https://github.com/rust-lang/rust/blob/74ff7dcb1388e60a613cd6050bcd372a3cc4998b/src%2Flibcore%2Fslice%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74ff7dcb1388e60a613cd6050bcd372a3cc4998b/src%2Flibcore%2Fslice%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fslice%2Fmod.rs?ref=74ff7dcb1388e60a613cd6050bcd372a3cc4998b", "patch": "@@ -713,8 +713,6 @@ impl<T> [T] {\n     /// # Examples\n     ///\n     /// ```\n-    /// #![feature(chunks_exact)]\n-    ///\n     /// let slice = ['l', 'o', 'r', 'e', 'm'];\n     /// let mut iter = slice.chunks_exact(2);\n     /// assert_eq!(iter.next().unwrap(), &['l', 'o']);\n@@ -725,7 +723,7 @@ impl<T> [T] {\n     ///\n     /// [`chunks`]: #method.chunks\n     /// [`rchunks_exact`]: #method.rchunks_exact\n-    #[unstable(feature = \"chunks_exact\", issue = \"47115\")]\n+    #[stable(feature = \"chunks_exact\", since = \"1.31.0\")]\n     #[inline]\n     pub fn chunks_exact(&self, chunk_size: usize) -> ChunksExact<T> {\n         assert!(chunk_size != 0);\n@@ -756,8 +754,6 @@ impl<T> [T] {\n     /// # Examples\n     ///\n     /// ```\n-    /// #![feature(chunks_exact)]\n-    ///\n     /// let v = &mut [0, 0, 0, 0, 0];\n     /// let mut count = 1;\n     ///\n@@ -772,7 +768,7 @@ impl<T> [T] {\n     ///\n     /// [`chunks_mut`]: #method.chunks_mut\n     /// [`rchunks_exact_mut`]: #method.rchunks_exact_mut\n-    #[unstable(feature = \"chunks_exact\", issue = \"47115\")]\n+    #[stable(feature = \"chunks_exact\", since = \"1.31.0\")]\n     #[inline]\n     pub fn chunks_exact_mut(&mut self, chunk_size: usize) -> ChunksExactMut<T> {\n         assert!(chunk_size != 0);\n@@ -799,8 +795,6 @@ impl<T> [T] {\n     /// # Examples\n     ///\n     /// ```\n-    /// #![feature(rchunks)]\n-    ///\n     /// let slice = ['l', 'o', 'r', 'e', 'm'];\n     /// let mut iter = slice.rchunks(2);\n     /// assert_eq!(iter.next().unwrap(), &['e', 'm']);\n@@ -811,7 +805,7 @@ impl<T> [T] {\n     ///\n     /// [`rchunks_exact`]: #method.rchunks_exact\n     /// [`chunks`]: #method.chunks\n-    #[unstable(feature = \"rchunks\", issue = \"55177\")]\n+    #[stable(feature = \"rchunks\", since = \"1.31.0\")]\n     #[inline]\n     pub fn rchunks(&self, chunk_size: usize) -> RChunks<T> {\n         assert!(chunk_size != 0);\n@@ -835,8 +829,6 @@ impl<T> [T] {\n     /// # Examples\n     ///\n     /// ```\n-    /// #![feature(rchunks)]\n-    ///\n     /// let v = &mut [0, 0, 0, 0, 0];\n     /// let mut count = 1;\n     ///\n@@ -851,7 +843,7 @@ impl<T> [T] {\n     ///\n     /// [`rchunks_exact_mut`]: #method.rchunks_exact_mut\n     /// [`chunks_mut`]: #method.chunks_mut\n-    #[unstable(feature = \"rchunks\", issue = \"55177\")]\n+    #[stable(feature = \"rchunks\", since = \"1.31.0\")]\n     #[inline]\n     pub fn rchunks_mut(&mut self, chunk_size: usize) -> RChunksMut<T> {\n         assert!(chunk_size != 0);\n@@ -879,8 +871,6 @@ impl<T> [T] {\n     /// # Examples\n     ///\n     /// ```\n-    /// #![feature(rchunks)]\n-    ///\n     /// let slice = ['l', 'o', 'r', 'e', 'm'];\n     /// let mut iter = slice.rchunks_exact(2);\n     /// assert_eq!(iter.next().unwrap(), &['e', 'm']);\n@@ -891,7 +881,7 @@ impl<T> [T] {\n     ///\n     /// [`rchunks`]: #method.rchunks\n     /// [`chunks_exact`]: #method.chunks_exact\n-    #[unstable(feature = \"rchunks\", issue = \"55177\")]\n+    #[stable(feature = \"rchunks\", since = \"1.31.0\")]\n     #[inline]\n     pub fn rchunks_exact(&self, chunk_size: usize) -> RChunksExact<T> {\n         assert!(chunk_size != 0);\n@@ -921,8 +911,6 @@ impl<T> [T] {\n     /// # Examples\n     ///\n     /// ```\n-    /// #![feature(rchunks)]\n-    ///\n     /// let v = &mut [0, 0, 0, 0, 0];\n     /// let mut count = 1;\n     ///\n@@ -937,7 +925,7 @@ impl<T> [T] {\n     ///\n     /// [`rchunks_mut`]: #method.rchunks_mut\n     /// [`chunks_exact_mut`]: #method.chunks_exact_mut\n-    #[unstable(feature = \"rchunks\", issue = \"55177\")]\n+    #[stable(feature = \"rchunks\", since = \"1.31.0\")]\n     #[inline]\n     pub fn rchunks_exact_mut(&mut self, chunk_size: usize) -> RChunksExactMut<T> {\n         assert!(chunk_size != 0);\n@@ -4022,25 +4010,25 @@ unsafe impl<'a, T> TrustedRandomAccess for ChunksMut<'a, T> {\n /// [`remainder`]: ../../std/slice/struct.ChunksExact.html#method.remainder\n /// [slices]: ../../std/primitive.slice.html\n #[derive(Debug)]\n-#[unstable(feature = \"chunks_exact\", issue = \"47115\")]\n+#[stable(feature = \"chunks_exact\", since = \"1.31.0\")]\n pub struct ChunksExact<'a, T:'a> {\n     v: &'a [T],\n     rem: &'a [T],\n     chunk_size: usize\n }\n \n-#[unstable(feature = \"chunks_exact\", issue = \"47115\")]\n impl<'a, T> ChunksExact<'a, T> {\n     /// Return the remainder of the original slice that is not going to be\n     /// returned by the iterator. The returned slice has at most `chunk_size-1`\n     /// elements.\n+    #[stable(feature = \"chunks_exact\", since = \"1.31.0\")]\n     pub fn remainder(&self) -> &'a [T] {\n         self.rem\n     }\n }\n \n // FIXME(#26925) Remove in favor of `#[derive(Clone)]`\n-#[unstable(feature = \"chunks_exact\", issue = \"47115\")]\n+#[stable(feature = \"chunks_exact\", since = \"1.31.0\")]\n impl<T> Clone for ChunksExact<'_, T> {\n     fn clone(&self) -> Self {\n         ChunksExact {\n@@ -4051,7 +4039,7 @@ impl<T> Clone for ChunksExact<'_, T> {\n     }\n }\n \n-#[unstable(feature = \"chunks_exact\", issue = \"47115\")]\n+#[stable(feature = \"chunks_exact\", since = \"1.31.0\")]\n impl<'a, T> Iterator for ChunksExact<'a, T> {\n     type Item = &'a [T];\n \n@@ -4096,7 +4084,7 @@ impl<'a, T> Iterator for ChunksExact<'a, T> {\n     }\n }\n \n-#[unstable(feature = \"chunks_exact\", issue = \"47115\")]\n+#[stable(feature = \"chunks_exact\", since = \"1.31.0\")]\n impl<'a, T> DoubleEndedIterator for ChunksExact<'a, T> {\n     #[inline]\n     fn next_back(&mut self) -> Option<&'a [T]> {\n@@ -4110,7 +4098,7 @@ impl<'a, T> DoubleEndedIterator for ChunksExact<'a, T> {\n     }\n }\n \n-#[unstable(feature = \"chunks_exact\", issue = \"47115\")]\n+#[stable(feature = \"chunks_exact\", since = \"1.31.0\")]\n impl<T> ExactSizeIterator for ChunksExact<'_, T> {\n     fn is_empty(&self) -> bool {\n         self.v.is_empty()\n@@ -4120,11 +4108,11 @@ impl<T> ExactSizeIterator for ChunksExact<'_, T> {\n #[unstable(feature = \"trusted_len\", issue = \"37572\")]\n unsafe impl<T> TrustedLen for ChunksExact<'_, T> {}\n \n-#[unstable(feature = \"chunks_exact\", issue = \"47115\")]\n+#[stable(feature = \"chunks_exact\", since = \"1.31.0\")]\n impl<T> FusedIterator for ChunksExact<'_, T> {}\n \n #[doc(hidden)]\n-#[unstable(feature = \"chunks_exact\", issue = \"47115\")]\n+#[stable(feature = \"chunks_exact\", since = \"1.31.0\")]\n unsafe impl<'a, T> TrustedRandomAccess for ChunksExact<'a, T> {\n     unsafe fn get_unchecked(&mut self, i: usize) -> &'a [T] {\n         let start = i * self.chunk_size;\n@@ -4146,24 +4134,24 @@ unsafe impl<'a, T> TrustedRandomAccess for ChunksExact<'a, T> {\n /// [`into_remainder`]: ../../std/slice/struct.ChunksExactMut.html#method.into_remainder\n /// [slices]: ../../std/primitive.slice.html\n #[derive(Debug)]\n-#[unstable(feature = \"chunks_exact\", issue = \"47115\")]\n+#[stable(feature = \"chunks_exact\", since = \"1.31.0\")]\n pub struct ChunksExactMut<'a, T:'a> {\n     v: &'a mut [T],\n     rem: &'a mut [T],\n     chunk_size: usize\n }\n \n-#[unstable(feature = \"chunks_exact\", issue = \"47115\")]\n impl<'a, T> ChunksExactMut<'a, T> {\n     /// Return the remainder of the original slice that is not going to be\n     /// returned by the iterator. The returned slice has at most `chunk_size-1`\n     /// elements.\n+    #[stable(feature = \"chunks_exact\", since = \"1.31.0\")]\n     pub fn into_remainder(self) -> &'a mut [T] {\n         self.rem\n     }\n }\n \n-#[unstable(feature = \"chunks_exact\", issue = \"47115\")]\n+#[stable(feature = \"chunks_exact\", since = \"1.31.0\")]\n impl<'a, T> Iterator for ChunksExactMut<'a, T> {\n     type Item = &'a mut [T];\n \n@@ -4210,7 +4198,7 @@ impl<'a, T> Iterator for ChunksExactMut<'a, T> {\n     }\n }\n \n-#[unstable(feature = \"chunks_exact\", issue = \"47115\")]\n+#[stable(feature = \"chunks_exact\", since = \"1.31.0\")]\n impl<'a, T> DoubleEndedIterator for ChunksExactMut<'a, T> {\n     #[inline]\n     fn next_back(&mut self) -> Option<&'a mut [T]> {\n@@ -4226,7 +4214,7 @@ impl<'a, T> DoubleEndedIterator for ChunksExactMut<'a, T> {\n     }\n }\n \n-#[unstable(feature = \"chunks_exact\", issue = \"47115\")]\n+#[stable(feature = \"chunks_exact\", since = \"1.31.0\")]\n impl<T> ExactSizeIterator for ChunksExactMut<'_, T> {\n     fn is_empty(&self) -> bool {\n         self.v.is_empty()\n@@ -4236,11 +4224,11 @@ impl<T> ExactSizeIterator for ChunksExactMut<'_, T> {\n #[unstable(feature = \"trusted_len\", issue = \"37572\")]\n unsafe impl<T> TrustedLen for ChunksExactMut<'_, T> {}\n \n-#[unstable(feature = \"chunks_exact\", issue = \"47115\")]\n+#[stable(feature = \"chunks_exact\", since = \"1.31.0\")]\n impl<T> FusedIterator for ChunksExactMut<'_, T> {}\n \n #[doc(hidden)]\n-#[unstable(feature = \"chunks_exact\", issue = \"47115\")]\n+#[stable(feature = \"chunks_exact\", since = \"1.31.0\")]\n unsafe impl<'a, T> TrustedRandomAccess for ChunksExactMut<'a, T> {\n     unsafe fn get_unchecked(&mut self, i: usize) -> &'a mut [T] {\n         let start = i * self.chunk_size;\n@@ -4260,14 +4248,14 @@ unsafe impl<'a, T> TrustedRandomAccess for ChunksExactMut<'a, T> {\n /// [`rchunks`]: ../../std/primitive.slice.html#method.rchunks\n /// [slices]: ../../std/primitive.slice.html\n #[derive(Debug)]\n-#[unstable(feature = \"rchunks\", issue = \"55177\")]\n+#[stable(feature = \"rchunks\", since = \"1.31.0\")]\n pub struct RChunks<'a, T:'a> {\n     v: &'a [T],\n     chunk_size: usize\n }\n \n // FIXME(#26925) Remove in favor of `#[derive(Clone)]`\n-#[unstable(feature = \"rchunks\", issue = \"55177\")]\n+#[stable(feature = \"rchunks\", since = \"1.31.0\")]\n impl<'a, T> Clone for RChunks<'a, T> {\n     fn clone(&self) -> RChunks<'a, T> {\n         RChunks {\n@@ -4277,7 +4265,7 @@ impl<'a, T> Clone for RChunks<'a, T> {\n     }\n }\n \n-#[unstable(feature = \"rchunks\", issue = \"55177\")]\n+#[stable(feature = \"rchunks\", since = \"1.31.0\")]\n impl<'a, T> Iterator for RChunks<'a, T> {\n     type Item = &'a [T];\n \n@@ -4341,7 +4329,7 @@ impl<'a, T> Iterator for RChunks<'a, T> {\n     }\n }\n \n-#[unstable(feature = \"rchunks\", issue = \"55177\")]\n+#[stable(feature = \"rchunks\", since = \"1.31.0\")]\n impl<'a, T> DoubleEndedIterator for RChunks<'a, T> {\n     #[inline]\n     fn next_back(&mut self) -> Option<&'a [T]> {\n@@ -4357,17 +4345,17 @@ impl<'a, T> DoubleEndedIterator for RChunks<'a, T> {\n     }\n }\n \n-#[unstable(feature = \"rchunks\", issue = \"55177\")]\n+#[stable(feature = \"rchunks\", since = \"1.31.0\")]\n impl<'a, T> ExactSizeIterator for RChunks<'a, T> {}\n \n #[unstable(feature = \"trusted_len\", issue = \"37572\")]\n unsafe impl<'a, T> TrustedLen for RChunks<'a, T> {}\n \n-#[unstable(feature = \"rchunks\", issue = \"55177\")]\n+#[stable(feature = \"rchunks\", since = \"1.31.0\")]\n impl<'a, T> FusedIterator for RChunks<'a, T> {}\n \n #[doc(hidden)]\n-#[unstable(feature = \"rchunks\", issue = \"55177\")]\n+#[stable(feature = \"rchunks\", since = \"1.31.0\")]\n unsafe impl<'a, T> TrustedRandomAccess for RChunks<'a, T> {\n     unsafe fn get_unchecked(&mut self, i: usize) -> &'a [T] {\n         let end = self.v.len() - i * self.chunk_size;\n@@ -4391,13 +4379,13 @@ unsafe impl<'a, T> TrustedRandomAccess for RChunks<'a, T> {\n /// [`rchunks_mut`]: ../../std/primitive.slice.html#method.rchunks_mut\n /// [slices]: ../../std/primitive.slice.html\n #[derive(Debug)]\n-#[unstable(feature = \"rchunks\", issue = \"55177\")]\n+#[stable(feature = \"rchunks\", since = \"1.31.0\")]\n pub struct RChunksMut<'a, T:'a> {\n     v: &'a mut [T],\n     chunk_size: usize\n }\n \n-#[unstable(feature = \"rchunks\", issue = \"55177\")]\n+#[stable(feature = \"rchunks\", since = \"1.31.0\")]\n impl<'a, T> Iterator for RChunksMut<'a, T> {\n     type Item = &'a mut [T];\n \n@@ -4465,7 +4453,7 @@ impl<'a, T> Iterator for RChunksMut<'a, T> {\n     }\n }\n \n-#[unstable(feature = \"rchunks\", issue = \"55177\")]\n+#[stable(feature = \"rchunks\", since = \"1.31.0\")]\n impl<'a, T> DoubleEndedIterator for RChunksMut<'a, T> {\n     #[inline]\n     fn next_back(&mut self) -> Option<&'a mut [T]> {\n@@ -4482,17 +4470,17 @@ impl<'a, T> DoubleEndedIterator for RChunksMut<'a, T> {\n     }\n }\n \n-#[unstable(feature = \"rchunks\", issue = \"55177\")]\n+#[stable(feature = \"rchunks\", since = \"1.31.0\")]\n impl<'a, T> ExactSizeIterator for RChunksMut<'a, T> {}\n \n #[unstable(feature = \"trusted_len\", issue = \"37572\")]\n unsafe impl<'a, T> TrustedLen for RChunksMut<'a, T> {}\n \n-#[unstable(feature = \"rchunks\", issue = \"55177\")]\n+#[stable(feature = \"rchunks\", since = \"1.31.0\")]\n impl<'a, T> FusedIterator for RChunksMut<'a, T> {}\n \n #[doc(hidden)]\n-#[unstable(feature = \"rchunks\", issue = \"55177\")]\n+#[stable(feature = \"rchunks\", since = \"1.31.0\")]\n unsafe impl<'a, T> TrustedRandomAccess for RChunksMut<'a, T> {\n     unsafe fn get_unchecked(&mut self, i: usize) -> &'a mut [T] {\n         let end = self.v.len() - i * self.chunk_size;\n@@ -4518,25 +4506,25 @@ unsafe impl<'a, T> TrustedRandomAccess for RChunksMut<'a, T> {\n /// [`remainder`]: ../../std/slice/struct.ChunksExact.html#method.remainder\n /// [slices]: ../../std/primitive.slice.html\n #[derive(Debug)]\n-#[unstable(feature = \"rchunks\", issue = \"55177\")]\n+#[stable(feature = \"rchunks\", since = \"1.31.0\")]\n pub struct RChunksExact<'a, T:'a> {\n     v: &'a [T],\n     rem: &'a [T],\n     chunk_size: usize\n }\n \n-#[unstable(feature = \"rchunks\", issue = \"55177\")]\n impl<'a, T> RChunksExact<'a, T> {\n     /// Return the remainder of the original slice that is not going to be\n     /// returned by the iterator. The returned slice has at most `chunk_size-1`\n     /// elements.\n+    #[stable(feature = \"rchunks\", since = \"1.31.0\")]\n     pub fn remainder(&self) -> &'a [T] {\n         self.rem\n     }\n }\n \n // FIXME(#26925) Remove in favor of `#[derive(Clone)]`\n-#[unstable(feature = \"rchunks\", issue = \"55177\")]\n+#[stable(feature = \"rchunks\", since = \"1.31.0\")]\n impl<'a, T> Clone for RChunksExact<'a, T> {\n     fn clone(&self) -> RChunksExact<'a, T> {\n         RChunksExact {\n@@ -4547,7 +4535,7 @@ impl<'a, T> Clone for RChunksExact<'a, T> {\n     }\n }\n \n-#[unstable(feature = \"rchunks\", issue = \"55177\")]\n+#[stable(feature = \"rchunks\", since = \"1.31.0\")]\n impl<'a, T> Iterator for RChunksExact<'a, T> {\n     type Item = &'a [T];\n \n@@ -4592,7 +4580,7 @@ impl<'a, T> Iterator for RChunksExact<'a, T> {\n     }\n }\n \n-#[unstable(feature = \"rchunks\", issue = \"55177\")]\n+#[stable(feature = \"rchunks\", since = \"1.31.0\")]\n impl<'a, T> DoubleEndedIterator for RChunksExact<'a, T> {\n     #[inline]\n     fn next_back(&mut self) -> Option<&'a [T]> {\n@@ -4606,7 +4594,7 @@ impl<'a, T> DoubleEndedIterator for RChunksExact<'a, T> {\n     }\n }\n \n-#[unstable(feature = \"rchunks\", issue = \"55177\")]\n+#[stable(feature = \"rchunks\", since = \"1.31.0\")]\n impl<'a, T> ExactSizeIterator for RChunksExact<'a, T> {\n     fn is_empty(&self) -> bool {\n         self.v.is_empty()\n@@ -4616,11 +4604,11 @@ impl<'a, T> ExactSizeIterator for RChunksExact<'a, T> {\n #[unstable(feature = \"trusted_len\", issue = \"37572\")]\n unsafe impl<'a, T> TrustedLen for RChunksExact<'a, T> {}\n \n-#[unstable(feature = \"rchunks\", issue = \"55177\")]\n+#[stable(feature = \"rchunks\", since = \"1.31.0\")]\n impl<'a, T> FusedIterator for RChunksExact<'a, T> {}\n \n #[doc(hidden)]\n-#[unstable(feature = \"rchunks\", issue = \"55177\")]\n+#[stable(feature = \"rchunks\", since = \"1.31.0\")]\n unsafe impl<'a, T> TrustedRandomAccess for RChunksExact<'a, T> {\n     unsafe fn get_unchecked(&mut self, i: usize) -> &'a [T] {\n         let end = self.v.len() - i * self.chunk_size;\n@@ -4643,24 +4631,24 @@ unsafe impl<'a, T> TrustedRandomAccess for RChunksExact<'a, T> {\n /// [`into_remainder`]: ../../std/slice/struct.ChunksExactMut.html#method.into_remainder\n /// [slices]: ../../std/primitive.slice.html\n #[derive(Debug)]\n-#[unstable(feature = \"rchunks\", issue = \"55177\")]\n+#[stable(feature = \"rchunks\", since = \"1.31.0\")]\n pub struct RChunksExactMut<'a, T:'a> {\n     v: &'a mut [T],\n     rem: &'a mut [T],\n     chunk_size: usize\n }\n \n-#[unstable(feature = \"rchunks\", issue = \"55177\")]\n impl<'a, T> RChunksExactMut<'a, T> {\n     /// Return the remainder of the original slice that is not going to be\n     /// returned by the iterator. The returned slice has at most `chunk_size-1`\n     /// elements.\n+    #[stable(feature = \"rchunks\", since = \"1.31.0\")]\n     pub fn into_remainder(self) -> &'a mut [T] {\n         self.rem\n     }\n }\n \n-#[unstable(feature = \"rchunks\", issue = \"55177\")]\n+#[stable(feature = \"rchunks\", since = \"1.31.0\")]\n impl<'a, T> Iterator for RChunksExactMut<'a, T> {\n     type Item = &'a mut [T];\n \n@@ -4709,7 +4697,7 @@ impl<'a, T> Iterator for RChunksExactMut<'a, T> {\n     }\n }\n \n-#[unstable(feature = \"rchunks\", issue = \"55177\")]\n+#[stable(feature = \"rchunks\", since = \"1.31.0\")]\n impl<'a, T> DoubleEndedIterator for RChunksExactMut<'a, T> {\n     #[inline]\n     fn next_back(&mut self) -> Option<&'a mut [T]> {\n@@ -4724,7 +4712,7 @@ impl<'a, T> DoubleEndedIterator for RChunksExactMut<'a, T> {\n     }\n }\n \n-#[unstable(feature = \"rchunks\", issue = \"55177\")]\n+#[stable(feature = \"rchunks\", since = \"1.31.0\")]\n impl<'a, T> ExactSizeIterator for RChunksExactMut<'a, T> {\n     fn is_empty(&self) -> bool {\n         self.v.is_empty()\n@@ -4734,11 +4722,11 @@ impl<'a, T> ExactSizeIterator for RChunksExactMut<'a, T> {\n #[unstable(feature = \"trusted_len\", issue = \"37572\")]\n unsafe impl<'a, T> TrustedLen for RChunksExactMut<'a, T> {}\n \n-#[unstable(feature = \"rchunks\", issue = \"55177\")]\n+#[stable(feature = \"rchunks\", since = \"1.31.0\")]\n impl<'a, T> FusedIterator for RChunksExactMut<'a, T> {}\n \n #[doc(hidden)]\n-#[unstable(feature = \"rchunks\", issue = \"55177\")]\n+#[stable(feature = \"rchunks\", since = \"1.31.0\")]\n unsafe impl<'a, T> TrustedRandomAccess for RChunksExactMut<'a, T> {\n     unsafe fn get_unchecked(&mut self, i: usize) -> &'a mut [T] {\n         let end = self.v.len() - i * self.chunk_size;"}, {"sha": "965bd545eed591665b90be854ec0fab7c0fe9c1b", "filename": "src/libcore/tests/lib.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/74ff7dcb1388e60a613cd6050bcd372a3cc4998b/src%2Flibcore%2Ftests%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74ff7dcb1388e60a613cd6050bcd372a3cc4998b/src%2Flibcore%2Ftests%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftests%2Flib.rs?ref=74ff7dcb1388e60a613cd6050bcd372a3cc4998b", "patch": "@@ -34,8 +34,6 @@\n #![feature(trusted_len)]\n #![feature(try_from)]\n #![feature(try_trait)]\n-#![feature(chunks_exact)]\n-#![feature(rchunks)]\n #![feature(align_offset)]\n #![feature(reverse_bits)]\n #![feature(inner_deref)]"}, {"sha": "ab82f28c8bff4d1b1c0a7ceb29a5706993a29da9", "filename": "src/librustc/ty/cast.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/74ff7dcb1388e60a613cd6050bcd372a3cc4998b/src%2Flibrustc%2Fty%2Fcast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74ff7dcb1388e60a613cd6050bcd372a3cc4998b/src%2Flibrustc%2Fty%2Fcast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fcast.rs?ref=74ff7dcb1388e60a613cd6050bcd372a3cc4998b", "patch": "@@ -58,6 +58,8 @@ pub enum CastKind {\n }\n \n impl<'tcx> CastTy<'tcx> {\n+    /// Returns `Some` for integral/pointer casts.\n+    /// casts like unsizing casts will return `None`\n     pub fn from_ty(t: Ty<'tcx>) -> Option<CastTy<'tcx>> {\n         match t.sty {\n             ty::Bool => Some(CastTy::Int(IntTy::Bool)),"}, {"sha": "4cf2072e792ca3ee6a50420f4df9c27177f71f67", "filename": "src/librustc_lint/unused.rs", "status": "modified", "additions": 8, "deletions": 5, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/74ff7dcb1388e60a613cd6050bcd372a3cc4998b/src%2Flibrustc_lint%2Funused.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74ff7dcb1388e60a613cd6050bcd372a3cc4998b/src%2Flibrustc_lint%2Funused.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Funused.rs?ref=74ff7dcb1388e60a613cd6050bcd372a3cc4998b", "patch": "@@ -276,10 +276,13 @@ impl UnusedParens {\n                                 cx: &EarlyContext,\n                                 value: &ast::Expr,\n                                 msg: &str,\n-                                struct_lit_needs_parens: bool) {\n+                                followed_by_block: bool) {\n         if let ast::ExprKind::Paren(ref inner) = value.node {\n-            let necessary = struct_lit_needs_parens &&\n-                            parser::contains_exterior_struct_lit(&inner);\n+            let necessary = followed_by_block && if let ast::ExprKind::Ret(_) = inner.node {\n+                true\n+            } else {\n+                parser::contains_exterior_struct_lit(&inner)\n+            };\n             if !necessary {\n                 let pattern = pprust::expr_to_string(value);\n                 Self::remove_outer_parens(cx, value.span, &pattern, msg);\n@@ -343,7 +346,7 @@ impl LintPass for UnusedParens {\n impl EarlyLintPass for UnusedParens {\n     fn check_expr(&mut self, cx: &EarlyContext, e: &ast::Expr) {\n         use syntax::ast::ExprKind::*;\n-        let (value, msg, struct_lit_needs_parens) = match e.node {\n+        let (value, msg, followed_by_block) = match e.node {\n             If(ref cond, ..) => (cond, \"`if` condition\", true),\n             While(ref cond, ..) => (cond, \"`while` condition\", true),\n             IfLet(_, ref cond, ..) => (cond, \"`if let` head expression\", true),\n@@ -380,7 +383,7 @@ impl EarlyLintPass for UnusedParens {\n                 return;\n             }\n         };\n-        self.check_unused_parens_expr(cx, &value, msg, struct_lit_needs_parens);\n+        self.check_unused_parens_expr(cx, &value, msg, followed_by_block);\n     }\n \n     fn check_pat(&mut self, cx: &EarlyContext, p: &ast::Pat) {"}, {"sha": "0fabcfe4564494e839a55d81ec78d72fb929d17f", "filename": "src/librustc_mir/borrow_check/nll/region_infer/mod.rs", "status": "modified", "additions": 4, "deletions": 8, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/74ff7dcb1388e60a613cd6050bcd372a3cc4998b/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74ff7dcb1388e60a613cd6050bcd372a3cc4998b/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fmod.rs?ref=74ff7dcb1388e60a613cd6050bcd372a3cc4998b", "patch": "@@ -1268,7 +1268,7 @@ pub trait ClosureRegionRequirementsExt<'gcx, 'tcx> {\n         tcx: TyCtxt<'_, 'gcx, 'tcx>,\n         location: Location,\n         closure_def_id: DefId,\n-        closure_substs: ty::ClosureSubsts<'tcx>,\n+        closure_substs: &'tcx ty::subst::Substs<'tcx>,\n     ) -> Vec<QueryRegionConstraint<'tcx>>;\n \n     fn subst_closure_mapping<T>(\n@@ -1299,23 +1299,19 @@ impl<'gcx, 'tcx> ClosureRegionRequirementsExt<'gcx, 'tcx> for ClosureRegionRequi\n         tcx: TyCtxt<'_, 'gcx, 'tcx>,\n         location: Location,\n         closure_def_id: DefId,\n-        closure_substs: ty::ClosureSubsts<'tcx>,\n+        closure_substs: &'tcx ty::subst::Substs<'tcx>,\n     ) -> Vec<QueryRegionConstraint<'tcx>> {\n         debug!(\n             \"apply_requirements(location={:?}, closure_def_id={:?}, closure_substs={:?})\",\n             location, closure_def_id, closure_substs\n         );\n \n-        // Get Tu.\n-        let user_closure_ty = tcx.mk_closure(closure_def_id, closure_substs);\n-        debug!(\"apply_requirements: user_closure_ty={:?}\", user_closure_ty);\n-\n-        // Extract the values of the free regions in `user_closure_ty`\n+        // Extract the values of the free regions in `closure_substs`\n         // into a vector.  These are the regions that we will be\n         // relating to one another.\n         let closure_mapping = &UniversalRegions::closure_mapping(\n             tcx,\n-            user_closure_ty,\n+            closure_substs,\n             self.num_external_vids,\n             tcx.closure_base_def_id(closure_def_id),\n         );"}, {"sha": "c5758cde9494d92aeb7202f17c2ac039c5058bd6", "filename": "src/librustc_mir/borrow_check/nll/type_check/mod.rs", "status": "modified", "additions": 6, "deletions": 9, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/74ff7dcb1388e60a613cd6050bcd372a3cc4998b/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74ff7dcb1388e60a613cd6050bcd372a3cc4998b/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fmod.rs?ref=74ff7dcb1388e60a613cd6050bcd372a3cc4998b", "patch": "@@ -42,7 +42,7 @@ use rustc::traits::query::type_op::custom::CustomTypeOp;\n use rustc::traits::query::{Fallible, NoSolution};\n use rustc::traits::{ObligationCause, PredicateObligations};\n use rustc::ty::fold::TypeFoldable;\n-use rustc::ty::subst::{Subst, UnpackedKind};\n+use rustc::ty::subst::{Subst, Substs, UnpackedKind};\n use rustc::ty::{self, RegionVid, ToPolyTraitRef, Ty, TyCtxt, TyKind};\n use std::rc::Rc;\n use std::{fmt, iter};\n@@ -2075,12 +2075,9 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n             // desugaring. A closure gets desugared to a struct, and\n             // these extra requirements are basically like where\n             // clauses on the struct.\n-            AggregateKind::Closure(def_id, substs) => {\n-                self.prove_closure_bounds(tcx, *def_id, *substs, location)\n-            }\n-\n-            AggregateKind::Generator(def_id, substs, _) => {\n-                tcx.predicates_of(*def_id).instantiate(tcx, substs.substs)\n+            AggregateKind::Closure(def_id, ty::ClosureSubsts { substs })\n+            | AggregateKind::Generator(def_id, ty::GeneratorSubsts { substs }, _) => {\n+                self.prove_closure_bounds(tcx, *def_id, substs, location)\n             }\n \n             AggregateKind::Array(_) | AggregateKind::Tuple => ty::InstantiatedPredicates::empty(),\n@@ -2096,7 +2093,7 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n         &mut self,\n         tcx: TyCtxt<'a, 'gcx, 'tcx>,\n         def_id: DefId,\n-        substs: ty::ClosureSubsts<'tcx>,\n+        substs: &'tcx Substs<'tcx>,\n         location: Location,\n     ) -> ty::InstantiatedPredicates<'tcx> {\n         if let Some(closure_region_requirements) =\n@@ -2155,7 +2152,7 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n             );\n         }\n \n-        tcx.predicates_of(def_id).instantiate(tcx, substs.substs)\n+        tcx.predicates_of(def_id).instantiate(tcx, substs)\n     }\n \n     fn prove_trait_ref("}, {"sha": "c54a4f96b7dcf12cbe9aa702cce8d7a3f5cae4c8", "filename": "src/librustc_mir/borrow_check/nll/universal_regions.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/74ff7dcb1388e60a613cd6050bcd372a3cc4998b/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Funiversal_regions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74ff7dcb1388e60a613cd6050bcd372a3cc4998b/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Funiversal_regions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Funiversal_regions.rs?ref=74ff7dcb1388e60a613cd6050bcd372a3cc4998b", "patch": "@@ -232,13 +232,13 @@ impl<'tcx> UniversalRegions<'tcx> {\n     /// `V[1]: V[2]`.\n     pub fn closure_mapping(\n         tcx: TyCtxt<'_, '_, 'tcx>,\n-        closure_ty: Ty<'tcx>,\n+        closure_substs: &'tcx Substs<'tcx>,\n         expected_num_vars: usize,\n         closure_base_def_id: DefId,\n     ) -> IndexVec<RegionVid, ty::Region<'tcx>> {\n         let mut region_mapping = IndexVec::with_capacity(expected_num_vars);\n         region_mapping.push(tcx.types.re_static);\n-        tcx.for_each_free_region(&closure_ty, |fr| {\n+        tcx.for_each_free_region(&closure_substs, |fr| {\n             region_mapping.push(fr);\n         });\n "}, {"sha": "52c557b83d5916979301d743b5f8aa2b4a6091bf", "filename": "src/librustc_mir/transform/qualify_min_const_fn.rs", "status": "modified", "additions": 16, "deletions": 3, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/74ff7dcb1388e60a613cd6050bcd372a3cc4998b/src%2Flibrustc_mir%2Ftransform%2Fqualify_min_const_fn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74ff7dcb1388e60a613cd6050bcd372a3cc4998b/src%2Flibrustc_mir%2Ftransform%2Fqualify_min_const_fn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fqualify_min_const_fn.rs?ref=74ff7dcb1388e60a613cd6050bcd372a3cc4998b", "patch": "@@ -148,7 +148,7 @@ fn check_rvalue(\n         Rvalue::Len(place) | Rvalue::Discriminant(place) | Rvalue::Ref(_, _, place) => {\n             check_place(tcx, mir, place, span, PlaceMode::Read)\n         }\n-        Rvalue::Cast(_, operand, cast_ty) => {\n+        Rvalue::Cast(CastKind::Misc, operand, cast_ty) => {\n             use rustc::ty::cast::CastTy;\n             let cast_in = CastTy::from_ty(operand.ty(mir, tcx)).expect(\"bad input type for cast\");\n             let cast_out = CastTy::from_ty(cast_ty).expect(\"bad output type for cast\");\n@@ -163,6 +163,16 @@ fn check_rvalue(\n                 _ => check_operand(tcx, mir, operand, span),\n             }\n         }\n+        Rvalue::Cast(CastKind::UnsafeFnPointer, _, _) |\n+        Rvalue::Cast(CastKind::ClosureFnPointer, _, _) |\n+        Rvalue::Cast(CastKind::ReifyFnPointer, _, _) => Err((\n+            span,\n+            \"function pointer casts are not allowed in const fn\".into(),\n+        )),\n+        Rvalue::Cast(CastKind::Unsize, _, _) => Err((\n+            span,\n+            \"unsizing casts are not allowed in const fn\".into(),\n+        )),\n         // binops are fine on integers\n         Rvalue::BinaryOp(_, lhs, rhs) | Rvalue::CheckedBinaryOp(_, lhs, rhs) => {\n             check_operand(tcx, mir, lhs, span)?;\n@@ -177,8 +187,11 @@ fn check_rvalue(\n                 ))\n             }\n         }\n-        // checked by regular const fn checks\n-        Rvalue::NullaryOp(..) => Ok(()),\n+        Rvalue::NullaryOp(NullOp::SizeOf, _) => Ok(()),\n+        Rvalue::NullaryOp(NullOp::Box, _) => Err((\n+            span,\n+            \"heap allocations are not allowed in const fn\".into(),\n+        )),\n         Rvalue::UnaryOp(_, operand) => {\n             let ty = operand.ty(mir, tcx);\n             if ty.is_integral() || ty.is_bool() {"}, {"sha": "e2f5829d14ff7ae3cab5698fdd7d8ede62a745b3", "filename": "src/librustc_resolve/build_reduced_graph.rs", "status": "modified", "additions": 4, "deletions": 7, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/74ff7dcb1388e60a613cd6050bcd372a3cc4998b/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74ff7dcb1388e60a613cd6050bcd372a3cc4998b/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs?ref=74ff7dcb1388e60a613cd6050bcd372a3cc4998b", "patch": "@@ -139,7 +139,7 @@ impl<'a, 'cl> Resolver<'a, 'cl> {\n \n         let prefix_iter = || parent_prefix.iter().cloned()\n             .chain(use_tree.prefix.segments.iter().map(|seg| seg.ident));\n-        let prefix_start = prefix_iter().nth(0);\n+        let prefix_start = prefix_iter().next();\n         let starts_with_non_keyword = prefix_start.map_or(false, |ident| {\n             !ident.is_path_segment_keyword()\n         });\n@@ -1048,13 +1048,10 @@ impl<'a, 'b, 'cl> Visitor<'a> for BuildReducedGraphVisitor<'a, 'b, 'cl> {\n \n     fn visit_token(&mut self, t: Token) {\n         if let Token::Interpolated(nt) = t {\n-            match nt.0 {\n-                token::NtExpr(ref expr) => {\n-                    if let ast::ExprKind::Mac(..) = expr.node {\n-                        self.visit_invoc(expr.id);\n-                    }\n+            if let token::NtExpr(ref expr) = nt.0 {\n+                if let ast::ExprKind::Mac(..) = expr.node {\n+                    self.visit_invoc(expr.id);\n                 }\n-                _ => {}\n             }\n         }\n     }"}, {"sha": "6f3135b37cf05746dd3e9d5b903d3972f1a10ae7", "filename": "src/librustc_resolve/check_unused.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/74ff7dcb1388e60a613cd6050bcd372a3cc4998b/src%2Flibrustc_resolve%2Fcheck_unused.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74ff7dcb1388e60a613cd6050bcd372a3cc4998b/src%2Flibrustc_resolve%2Fcheck_unused.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fcheck_unused.rs?ref=74ff7dcb1388e60a613cd6050bcd372a3cc4998b", "patch": "@@ -109,7 +109,7 @@ impl<'a, 'b, 'cl> Visitor<'a> for UnusedImportCheckVisitor<'a, 'b, 'cl> {\n                 self.item_span\n             };\n \n-            if items.len() == 0 {\n+            if items.is_empty() {\n                 self.unused_imports\n                     .entry(self.base_id)\n                     .or_default()\n@@ -170,7 +170,7 @@ pub fn check_crate(resolver: &mut Resolver, krate: &ast::Crate) {\n \n     for (id, spans) in &visitor.unused_imports {\n         let len = spans.len();\n-        let mut spans = spans.values().map(|s| *s).collect::<Vec<Span>>();\n+        let mut spans = spans.values().cloned().collect::<Vec<Span>>();\n         spans.sort();\n         let ms = MultiSpan::from_spans(spans.clone());\n         let mut span_snippets = spans.iter()\n@@ -183,7 +183,7 @@ pub fn check_crate(resolver: &mut Resolver, krate: &ast::Crate) {\n         span_snippets.sort();\n         let msg = format!(\"unused import{}{}\",\n                           if len > 1 { \"s\" } else { \"\" },\n-                          if span_snippets.len() > 0 {\n+                          if !span_snippets.is_empty() {\n                               format!(\": {}\", span_snippets.join(\", \"))\n                           } else {\n                               String::new()"}, {"sha": "bf3fbdc2c5ad5740fd26b52d371843f67f0edd05", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 33, "deletions": 50, "changes": 83, "blob_url": "https://github.com/rust-lang/rust/blob/74ff7dcb1388e60a613cd6050bcd372a3cc4998b/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74ff7dcb1388e60a613cd6050bcd372a3cc4998b/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=74ff7dcb1388e60a613cd6050bcd372a3cc4998b", "patch": "@@ -1633,19 +1633,17 @@ impl<'a, 'crateloader> Resolver<'a, 'crateloader> {\n                 *def = module.def().unwrap(),\n             PathResult::NonModule(path_res) if path_res.unresolved_segments() == 0 =>\n                 *def = path_res.base_def(),\n-            PathResult::NonModule(..) => match self.resolve_path(\n-                None,\n-                &path,\n-                None,\n-                true,\n-                span,\n-                CrateLint::No,\n-            ) {\n-                PathResult::Failed(span, msg, _) => {\n+            PathResult::NonModule(..) =>\n+                if let PathResult::Failed(span, msg, _) = self.resolve_path(\n+                    None,\n+                    &path,\n+                    None,\n+                    true,\n+                    span,\n+                    CrateLint::No,\n+                ) {\n                     error_callback(self, span, ResolutionError::FailedToResolve(&msg));\n-                }\n-                _ => {}\n-            },\n+                },\n             PathResult::Module(ModuleOrUniformRoot::UniformRoot(_)) |\n             PathResult::Indeterminate => unreachable!(),\n             PathResult::Failed(span, msg, _) => {\n@@ -2357,7 +2355,7 @@ impl<'a, 'crateloader: 'a> Resolver<'a, 'crateloader> {\n                     span: prefix.span.to(use_tree.prefix.span),\n                 };\n \n-                if items.len() == 0 {\n+                if items.is_empty() {\n                     // Resolve prefix of an import with empty braces (issue #28388).\n                     self.smart_resolve_path_with_crate_lint(\n                         id,\n@@ -2696,7 +2694,7 @@ impl<'a, 'crateloader: 'a> Resolver<'a, 'crateloader> {\n \n                 let map_j = self.binding_mode_map(&q);\n                 for (&key, &binding_i) in &map_i {\n-                    if map_j.len() == 0 {                   // Account for missing bindings when\n+                    if map_j.is_empty() {                   // Account for missing bindings when\n                         let binding_error = missing_vars    // map_j has none.\n                             .entry(key.name)\n                             .or_insert(BindingError {\n@@ -2757,9 +2755,8 @@ impl<'a, 'crateloader: 'a> Resolver<'a, 'crateloader> {\n         // This has to happen *after* we determine which pat_idents are variants\n         self.check_consistent_bindings(&arm.pats);\n \n-        match arm.guard {\n-            Some(ast::Guard::If(ref expr)) => self.visit_expr(expr),\n-            _ => {}\n+        if let Some(ast::Guard::If(ref expr)) = arm.guard {\n+            self.visit_expr(expr)\n         }\n         self.visit_expr(&arm.body);\n \n@@ -3000,14 +2997,14 @@ impl<'a, 'crateloader: 'a> Resolver<'a, 'crateloader> {\n             // Make the base error.\n             let expected = source.descr_expected();\n             let path_str = names_to_string(path);\n-            let item_str = path[path.len() - 1];\n+            let item_str = path.last().unwrap();\n             let code = source.error_code(def.is_some());\n             let (base_msg, fallback_label, base_span) = if let Some(def) = def {\n                 (format!(\"expected {}, found {} `{}`\", expected, def.kind_name(), path_str),\n                  format!(\"not a {}\", expected),\n                  span)\n             } else {\n-                let item_span = path[path.len() - 1].span;\n+                let item_span = path.last().unwrap().span;\n                 let (mod_prefix, mod_str) = if path.len() == 1 {\n                     (String::new(), \"this scope\".to_string())\n                 } else if path.len() == 2 && path[0].name == keywords::CrateRoot.name() {\n@@ -3030,10 +3027,7 @@ impl<'a, 'crateloader: 'a> Resolver<'a, 'crateloader> {\n             let mut err = this.session.struct_span_err_with_code(base_span, &base_msg, code);\n \n             // Emit help message for fake-self from other languages like `this`(javascript)\n-            let fake_self: Vec<Ident> = [\"this\", \"my\"].iter().map(\n-                |s| Ident::from_str(*s)\n-            ).collect();\n-            if fake_self.contains(&item_str)\n+            if [\"this\", \"my\"].contains(&&*item_str.as_str())\n                 && this.self_value_is_available(path[0].span, span) {\n                 err.span_suggestion_with_applicability(\n                     span,\n@@ -3374,7 +3368,7 @@ impl<'a, 'crateloader: 'a> Resolver<'a, 'crateloader> {\n                             );\n                         }\n                         break;\n-                    } else if snippet.trim().len() != 0  {\n+                    } else if !snippet.trim().is_empty() {\n                         debug!(\"tried to find type ascription `:` token, couldn't find it\");\n                         break;\n                     }\n@@ -3936,7 +3930,7 @@ impl<'a, 'crateloader: 'a> Resolver<'a, 'crateloader> {\n             }\n             _ => {}\n         }\n-        return def;\n+        def\n     }\n \n     fn lookup_assoc_candidate<FilterFn>(&mut self,\n@@ -4386,10 +4380,9 @@ impl<'a, 'crateloader: 'a> Resolver<'a, 'crateloader> {\n         where FilterFn: Fn(Def) -> bool\n     {\n         let mut candidates = Vec::new();\n-        let mut worklist = Vec::new();\n         let mut seen_modules = FxHashSet();\n         let not_local_module = crate_name != keywords::Crate.ident();\n-        worklist.push((start_module, Vec::<ast::PathSegment>::new(), not_local_module));\n+        let mut worklist = vec![(start_module, Vec::<ast::PathSegment>::new(), not_local_module)];\n \n         while let Some((in_module,\n                         path_segments,\n@@ -4476,33 +4469,24 @@ impl<'a, 'crateloader: 'a> Resolver<'a, 'crateloader> {\n                                           -> Vec<ImportSuggestion>\n         where FilterFn: Fn(Def) -> bool\n     {\n-        let mut suggestions = vec![];\n-\n-        suggestions.extend(\n-            self.lookup_import_candidates_from_module(\n-                lookup_name, namespace, self.graph_root, keywords::Crate.ident(), &filter_fn\n-            )\n-        );\n+        let mut suggestions = self.lookup_import_candidates_from_module(\n+            lookup_name, namespace, self.graph_root, keywords::Crate.ident(), &filter_fn);\n \n         if self.session.rust_2018() {\n             let extern_prelude_names = self.extern_prelude.clone();\n             for &name in extern_prelude_names.iter() {\n                 let ident = Ident::with_empty_ctxt(name);\n-                match self.crate_loader.maybe_process_path_extern(name, ident.span) {\n-                    Some(crate_id) => {\n-                        let crate_root = self.get_module(DefId {\n-                            krate: crate_id,\n-                            index: CRATE_DEF_INDEX,\n-                        });\n-                        self.populate_module_if_necessary(&crate_root);\n+                if let Some(crate_id) = self.crate_loader.maybe_process_path_extern(name,\n+                                                                                    ident.span)\n+                {\n+                    let crate_root = self.get_module(DefId {\n+                        krate: crate_id,\n+                        index: CRATE_DEF_INDEX,\n+                    });\n+                    self.populate_module_if_necessary(&crate_root);\n \n-                        suggestions.extend(\n-                            self.lookup_import_candidates_from_module(\n-                                lookup_name, namespace, crate_root, ident, &filter_fn\n-                            )\n-                        );\n-                    }\n-                    None => {}\n+                    suggestions.extend(self.lookup_import_candidates_from_module(\n+                        lookup_name, namespace, crate_root, ident, &filter_fn));\n                 }\n             }\n         }\n@@ -4515,9 +4499,8 @@ impl<'a, 'crateloader: 'a> Resolver<'a, 'crateloader> {\n                    -> Option<(Module<'a>, ImportSuggestion)>\n     {\n         let mut result = None;\n-        let mut worklist = Vec::new();\n         let mut seen_modules = FxHashSet();\n-        worklist.push((self.graph_root, Vec::new()));\n+        let mut worklist = vec![(self.graph_root, Vec::new())];\n \n         while let Some((in_module, path_segments)) = worklist.pop() {\n             // abort if the module is already found"}, {"sha": "28284a45bcdd5f03098cf665c25e79013840cb28", "filename": "src/librustc_resolve/macros.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/74ff7dcb1388e60a613cd6050bcd372a3cc4998b/src%2Flibrustc_resolve%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74ff7dcb1388e60a613cd6050bcd372a3cc4998b/src%2Flibrustc_resolve%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fmacros.rs?ref=74ff7dcb1388e60a613cd6050bcd372a3cc4998b", "patch": "@@ -203,9 +203,7 @@ impl<'a, 'crateloader: 'a> base::Resolver for Resolver<'a, 'crateloader> {\n         self.current_module = invocation.module.get();\n         self.current_module.unresolved_invocations.borrow_mut().remove(&mark);\n         self.current_module.unresolved_invocations.borrow_mut().extend(derives);\n-        for &derive in derives {\n-            self.invocations.insert(derive, invocation);\n-        }\n+        self.invocations.extend(derives.iter().map(|&derive| (derive, invocation)));\n         let mut visitor = BuildReducedGraphVisitor {\n             resolver: self,\n             current_legacy_scope: invocation.parent_legacy_scope.get(),\n@@ -277,11 +275,12 @@ impl<'a, 'crateloader: 'a> base::Resolver for Resolver<'a, 'crateloader> {\n                     if traits.is_empty() {\n                         attrs.remove(i);\n                     } else {\n-                        let mut tokens = Vec::new();\n+                        let mut tokens = Vec::with_capacity(traits.len() - 1);\n                         for (j, path) in traits.iter().enumerate() {\n                             if j > 0 {\n                                 tokens.push(TokenTree::Token(attrs[i].span, Token::Comma).into());\n                             }\n+                            tokens.reserve((path.segments.len() * 2).saturating_sub(1));\n                             for (k, segment) in path.segments.iter().enumerate() {\n                                 if k > 0 {\n                                     tokens.push(TokenTree::Token(path.span, Token::ModSep).into());"}, {"sha": "d5d772e13591475cb6293b496241755a697cb073", "filename": "src/librustc_resolve/resolve_imports.rs", "status": "modified", "additions": 73, "deletions": 79, "changes": 152, "blob_url": "https://github.com/rust-lang/rust/blob/74ff7dcb1388e60a613cd6050bcd372a3cc4998b/src%2Flibrustc_resolve%2Fresolve_imports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74ff7dcb1388e60a613cd6050bcd372a3cc4998b/src%2Flibrustc_resolve%2Fresolve_imports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fresolve_imports.rs?ref=74ff7dcb1388e60a613cd6050bcd372a3cc4998b", "patch": "@@ -672,7 +672,7 @@ impl<'a, 'b:'a, 'c: 'b> ImportResolver<'a, 'b, 'c> {\n                 };\n \n                 let has_explicit_self =\n-                    import.module_path.len() > 0 &&\n+                    !import.module_path.is_empty() &&\n                     import.module_path[0].name == keywords::SelfValue.name();\n \n                 self.per_ns(|_, ns| {\n@@ -703,9 +703,8 @@ impl<'a, 'b:'a, 'c: 'b> ImportResolver<'a, 'b, 'c> {\n                 if let SingleImport { source, ref result, .. } = import.subclass {\n                     if source.name == \"self\" {\n                         // Silence `unresolved import` error if E0429 is already emitted\n-                        match result.value_ns.get() {\n-                            Err(Determined) => continue,\n-                            _ => {},\n+                        if let Err(Determined) = result.value_ns.get() {\n+                            continue;\n                         }\n                     }\n                 }\n@@ -822,20 +821,19 @@ impl<'a, 'b:'a, 'c: 'b> ImportResolver<'a, 'b, 'c> {\n     fn throw_unresolved_import_error(&self, error_vec: Vec<(Span, String, String)>,\n                                      span: Option<MultiSpan>) {\n         let max_span_label_msg_count = 10;  // upper limit on number of span_label message.\n-        let (span,msg) = match error_vec.is_empty() {\n-            true => (span.unwrap(), \"unresolved import\".to_string()),\n-            false => {\n-                let span = MultiSpan::from_spans(error_vec.clone().into_iter()\n-                                    .map(|elem: (Span, String, String)| { elem.0 }\n-                                    ).collect());\n-                let path_vec: Vec<String> = error_vec.clone().into_iter()\n-                                .map(|elem: (Span, String, String)| { format!(\"`{}`\", elem.1) }\n-                                ).collect();\n-                let path = path_vec.join(\", \");\n-                let msg = format!(\"unresolved import{} {}\",\n-                                if path_vec.len() > 1 { \"s\" } else { \"\" },  path);\n-                (span, msg)\n-            }\n+        let (span, msg) = if error_vec.is_empty() {\n+            (span.unwrap(), \"unresolved import\".to_string())\n+        } else {\n+            let span = MultiSpan::from_spans(error_vec.clone().into_iter()\n+                .map(|elem: (Span, String, String)| { elem.0 })\n+                .collect());\n+            let path_vec: Vec<String> = error_vec.clone().into_iter()\n+                .map(|elem: (Span, String, String)| { format!(\"`{}`\", elem.1) })\n+                .collect();\n+            let path = path_vec.join(\", \");\n+            let msg = format!(\"unresolved import{} {}\",\n+                if path_vec.len() > 1 { \"s\" } else { \"\" }, path);\n+            (span, msg)\n         };\n         let mut err = struct_span_err!(self.resolver.session, span, E0432, \"{}\", &msg);\n         for span_error in error_vec.into_iter().take(max_span_label_msg_count) {\n@@ -1026,9 +1024,8 @@ impl<'a, 'b:'a, 'c: 'b> ImportResolver<'a, 'b, 'c> {\n         if all_ns_err {\n             let mut all_ns_failed = true;\n             self.per_ns(|this, ns| if !type_ns_only || ns == TypeNS {\n-                match this.resolve_ident_in_module(module, ident, ns, record_used, span) {\n-                    Ok(_) => all_ns_failed = false,\n-                    _ => {}\n+                if this.resolve_ident_in_module(module, ident, ns, record_used, span).is_ok() {\n+                    all_ns_failed = false;\n                 }\n             });\n \n@@ -1247,65 +1244,62 @@ impl<'a, 'b:'a, 'c: 'b> ImportResolver<'a, 'b, 'c> {\n                 }\n             }\n \n-            match binding.kind {\n-                NameBindingKind::Import { binding: orig_binding, directive, .. } => {\n-                    if ns == TypeNS && orig_binding.is_variant() &&\n-                        !orig_binding.vis.is_at_least(binding.vis, &*self) {\n-                            let msg = match directive.subclass {\n-                                ImportDirectiveSubclass::SingleImport { .. } => {\n-                                    format!(\"variant `{}` is private and cannot be re-exported\",\n-                                            ident)\n-                                },\n-                                ImportDirectiveSubclass::GlobImport { .. } => {\n-                                    let msg = \"enum is private and its variants \\\n-                                               cannot be re-exported\".to_owned();\n-                                    let error_id = (DiagnosticMessageId::ErrorId(0), // no code?!\n-                                                    Some(binding.span),\n-                                                    msg.clone());\n-                                    let fresh = self.session.one_time_diagnostics\n-                                        .borrow_mut().insert(error_id);\n-                                    if !fresh {\n-                                        continue;\n-                                    }\n-                                    msg\n-                                },\n-                                ref s @ _ => bug!(\"unexpected import subclass {:?}\", s)\n-                            };\n-                            let mut err = self.session.struct_span_err(binding.span, &msg);\n-\n-                            let imported_module = match directive.imported_module.get() {\n-                                Some(ModuleOrUniformRoot::Module(module)) => module,\n-                                _ => bug!(\"module should exist\"),\n-                            };\n-                            let resolutions = imported_module.parent.expect(\"parent should exist\")\n-                                .resolutions.borrow();\n-                            let enum_path_segment_index = directive.module_path.len() - 1;\n-                            let enum_ident = directive.module_path[enum_path_segment_index];\n-\n-                            let enum_resolution = resolutions.get(&(enum_ident, TypeNS))\n-                                .expect(\"resolution should exist\");\n-                            let enum_span = enum_resolution.borrow()\n-                                .binding.expect(\"binding should exist\")\n-                                .span;\n-                            let enum_def_span = self.session.source_map().def_span(enum_span);\n-                            let enum_def_snippet = self.session.source_map()\n-                                .span_to_snippet(enum_def_span).expect(\"snippet should exist\");\n-                            // potentially need to strip extant `crate`/`pub(path)` for suggestion\n-                            let after_vis_index = enum_def_snippet.find(\"enum\")\n-                                .expect(\"`enum` keyword should exist in snippet\");\n-                            let suggestion = format!(\"pub {}\",\n-                                                     &enum_def_snippet[after_vis_index..]);\n-\n-                            self.session\n-                                .diag_span_suggestion_once(&mut err,\n-                                                           DiagnosticMessageId::ErrorId(0),\n-                                                           enum_def_span,\n-                                                           \"consider making the enum public\",\n-                                                           suggestion);\n-                            err.emit();\n-                    }\n+            if let NameBindingKind::Import { binding: orig_binding, directive, .. } = binding.kind {\n+                if ns == TypeNS && orig_binding.is_variant() &&\n+                    !orig_binding.vis.is_at_least(binding.vis, &*self) {\n+                        let msg = match directive.subclass {\n+                            ImportDirectiveSubclass::SingleImport { .. } => {\n+                                format!(\"variant `{}` is private and cannot be re-exported\",\n+                                        ident)\n+                            },\n+                            ImportDirectiveSubclass::GlobImport { .. } => {\n+                                let msg = \"enum is private and its variants \\\n+                                           cannot be re-exported\".to_owned();\n+                                let error_id = (DiagnosticMessageId::ErrorId(0), // no code?!\n+                                                Some(binding.span),\n+                                                msg.clone());\n+                                let fresh = self.session.one_time_diagnostics\n+                                    .borrow_mut().insert(error_id);\n+                                if !fresh {\n+                                    continue;\n+                                }\n+                                msg\n+                            },\n+                            ref s @ _ => bug!(\"unexpected import subclass {:?}\", s)\n+                        };\n+                        let mut err = self.session.struct_span_err(binding.span, &msg);\n+\n+                        let imported_module = match directive.imported_module.get() {\n+                            Some(ModuleOrUniformRoot::Module(module)) => module,\n+                            _ => bug!(\"module should exist\"),\n+                        };\n+                        let resolutions = imported_module.parent.expect(\"parent should exist\")\n+                            .resolutions.borrow();\n+                        let enum_path_segment_index = directive.module_path.len() - 1;\n+                        let enum_ident = directive.module_path[enum_path_segment_index];\n+\n+                        let enum_resolution = resolutions.get(&(enum_ident, TypeNS))\n+                            .expect(\"resolution should exist\");\n+                        let enum_span = enum_resolution.borrow()\n+                            .binding.expect(\"binding should exist\")\n+                            .span;\n+                        let enum_def_span = self.session.source_map().def_span(enum_span);\n+                        let enum_def_snippet = self.session.source_map()\n+                            .span_to_snippet(enum_def_span).expect(\"snippet should exist\");\n+                        // potentially need to strip extant `crate`/`pub(path)` for suggestion\n+                        let after_vis_index = enum_def_snippet.find(\"enum\")\n+                            .expect(\"`enum` keyword should exist in snippet\");\n+                        let suggestion = format!(\"pub {}\",\n+                                                 &enum_def_snippet[after_vis_index..]);\n+\n+                        self.session\n+                            .diag_span_suggestion_once(&mut err,\n+                                                       DiagnosticMessageId::ErrorId(0),\n+                                                       enum_def_span,\n+                                                       \"consider making the enum public\",\n+                                                       suggestion);\n+                        err.emit();\n                 }\n-                _ => {}\n             }\n         }\n "}, {"sha": "c3f225d1eb0136e72070a1f1555082b7da6b941d", "filename": "src/libstd/f32.rs", "status": "modified", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/74ff7dcb1388e60a613cd6050bcd372a3cc4998b/src%2Flibstd%2Ff32.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74ff7dcb1388e60a613cd6050bcd372a3cc4998b/src%2Flibstd%2Ff32.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ff32.rs?ref=74ff7dcb1388e60a613cd6050bcd372a3cc4998b", "patch": "@@ -198,6 +198,35 @@ impl f32 {\n         }\n     }\n \n+    /// Returns a number composed of the magnitude of one number and the sign of\n+    /// another.\n+    ///\n+    /// Equal to `self` if the sign of `self` and `y` are the same, otherwise\n+    /// equal to `-y`. If `self` is a `NAN`, then a `NAN` with the sign of `y`\n+    /// is returned.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(copysign)]\n+    /// use std::f32;\n+    ///\n+    /// let f = 3.5_f32;\n+    ///\n+    /// assert_eq!(f.copysign(0.42), 3.5_f32);\n+    /// assert_eq!(f.copysign(-0.42), -3.5_f32);\n+    /// assert_eq!((-f).copysign(0.42), 3.5_f32);\n+    /// assert_eq!((-f).copysign(-0.42), -3.5_f32);\n+    ///\n+    /// assert!(f32::NAN.copysign(1.0).is_nan());\n+    /// ```\n+    #[inline]\n+    #[must_use]\n+    #[unstable(feature=\"copysign\", issue=\"55169\")]\n+    pub fn copysign(self, y: f32) -> f32 {\n+        unsafe { intrinsics::copysignf32(self, y) }\n+    }\n+\n     /// Fused multiply-add. Computes `(self * a) + b` with only one rounding\n     /// error, yielding a more accurate result than an unfused multiply-add.\n     ///"}, {"sha": "da062dda77a47a5496e76e671875545653f3d91a", "filename": "src/libstd/f64.rs", "status": "modified", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/74ff7dcb1388e60a613cd6050bcd372a3cc4998b/src%2Flibstd%2Ff64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74ff7dcb1388e60a613cd6050bcd372a3cc4998b/src%2Flibstd%2Ff64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ff64.rs?ref=74ff7dcb1388e60a613cd6050bcd372a3cc4998b", "patch": "@@ -176,6 +176,35 @@ impl f64 {\n         }\n     }\n \n+    /// Returns a number composed of the magnitude of one number and the sign of\n+    /// another.\n+    ///\n+    /// Equal to `self` if the sign of `self` and `y` are the same, otherwise\n+    /// equal to `-y`. If `self` is a `NAN`, then a `NAN` with the sign of `y`\n+    /// is returned.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(copysign)]\n+    /// use std::f64;\n+    ///\n+    /// let f = 3.5_f64;\n+    ///\n+    /// assert_eq!(f.copysign(0.42), 3.5_f64);\n+    /// assert_eq!(f.copysign(-0.42), -3.5_f64);\n+    /// assert_eq!((-f).copysign(0.42), 3.5_f64);\n+    /// assert_eq!((-f).copysign(-0.42), -3.5_f64);\n+    ///\n+    /// assert!(f64::NAN.copysign(1.0).is_nan());\n+    /// ```\n+    #[inline]\n+    #[must_use]\n+    #[unstable(feature=\"copysign\", issue=\"55169\")]\n+    pub fn copysign(self, y: f64) -> f64 {\n+        unsafe { intrinsics::copysignf64(self, y) }\n+    }\n+\n     /// Fused multiply-add. Computes `(self * a) + b` with only one rounding\n     /// error, yielding a more accurate result than an unfused multiply-add.\n     ///"}, {"sha": "3e42cb8c1b07480bb57ea6e5f5f854626b6c68b3", "filename": "src/test/ui/consts/min_const_fn/bad_const_fn_body_ice.rs", "status": "added", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/74ff7dcb1388e60a613cd6050bcd372a3cc4998b/src%2Ftest%2Fui%2Fconsts%2Fmin_const_fn%2Fbad_const_fn_body_ice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74ff7dcb1388e60a613cd6050bcd372a3cc4998b/src%2Ftest%2Fui%2Fconsts%2Fmin_const_fn%2Fbad_const_fn_body_ice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fmin_const_fn%2Fbad_const_fn_body_ice.rs?ref=74ff7dcb1388e60a613cd6050bcd372a3cc4998b", "patch": "@@ -0,0 +1,5 @@\n+const fn foo(a: i32) -> Vec<i32> {\n+    vec![1, 2, 3] //~ ERROR heap allocations are not allowed in const fn\n+}\n+\n+fn main() {}"}, {"sha": "f6b704370b6f239890fa5d0add31898aaff8e74d", "filename": "src/test/ui/consts/min_const_fn/bad_const_fn_body_ice.stderr", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/74ff7dcb1388e60a613cd6050bcd372a3cc4998b/src%2Ftest%2Fui%2Fconsts%2Fmin_const_fn%2Fbad_const_fn_body_ice.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/74ff7dcb1388e60a613cd6050bcd372a3cc4998b/src%2Ftest%2Fui%2Fconsts%2Fmin_const_fn%2Fbad_const_fn_body_ice.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fmin_const_fn%2Fbad_const_fn_body_ice.stderr?ref=74ff7dcb1388e60a613cd6050bcd372a3cc4998b", "patch": "@@ -0,0 +1,10 @@\n+error: heap allocations are not allowed in const fn\n+  --> $DIR/bad_const_fn_body_ice.rs:2:5\n+   |\n+LL |     vec![1, 2, 3] //~ ERROR heap allocations are not allowed in const fn\n+   |     ^^^^^^^^^^^^^\n+   |\n+   = note: this error originates in a macro outside of the current crate (in Nightly builds, run with -Z external-macro-backtrace for more info)\n+\n+error: aborting due to previous error\n+"}, {"sha": "8648cd35387cedd58e0a47bc5363379e02a2450f", "filename": "src/test/ui/consts/min_const_fn/cast_errors.rs", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/74ff7dcb1388e60a613cd6050bcd372a3cc4998b/src%2Ftest%2Fui%2Fconsts%2Fmin_const_fn%2Fcast_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74ff7dcb1388e60a613cd6050bcd372a3cc4998b/src%2Ftest%2Fui%2Fconsts%2Fmin_const_fn%2Fcast_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fmin_const_fn%2Fcast_errors.rs?ref=74ff7dcb1388e60a613cd6050bcd372a3cc4998b", "patch": "@@ -0,0 +1,14 @@\n+fn main() {}\n+\n+const fn unsize(x: &[u8; 3]) -> &[u8] { x }\n+//~^ ERROR unsizing casts are not allowed in const fn\n+const fn closure() -> fn() { || {} }\n+//~^ ERROR function pointers in const fn are unstable\n+const fn closure2() {\n+    (|| {}) as fn();\n+//~^ ERROR function pointers in const fn are unstable\n+}\n+const fn reify(f: fn()) -> unsafe fn() { f }\n+//~^ ERROR function pointers in const fn are unstable\n+const fn reify2() { main as unsafe fn(); }\n+//~^ ERROR function pointers in const fn are unstable"}, {"sha": "ba980b7aacb6c095689714be2b94a93622ee6468", "filename": "src/test/ui/consts/min_const_fn/cast_errors.stderr", "status": "added", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/74ff7dcb1388e60a613cd6050bcd372a3cc4998b/src%2Ftest%2Fui%2Fconsts%2Fmin_const_fn%2Fcast_errors.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/74ff7dcb1388e60a613cd6050bcd372a3cc4998b/src%2Ftest%2Fui%2Fconsts%2Fmin_const_fn%2Fcast_errors.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fmin_const_fn%2Fcast_errors.stderr?ref=74ff7dcb1388e60a613cd6050bcd372a3cc4998b", "patch": "@@ -0,0 +1,32 @@\n+error: unsizing casts are not allowed in const fn\n+  --> $DIR/cast_errors.rs:3:41\n+   |\n+LL | const fn unsize(x: &[u8; 3]) -> &[u8] { x }\n+   |                                         ^\n+\n+error: function pointers in const fn are unstable\n+  --> $DIR/cast_errors.rs:5:23\n+   |\n+LL | const fn closure() -> fn() { || {} }\n+   |                       ^^^^\n+\n+error: function pointers in const fn are unstable\n+  --> $DIR/cast_errors.rs:8:5\n+   |\n+LL |     (|| {}) as fn();\n+   |     ^^^^^^^^^^^^^^^\n+\n+error: function pointers in const fn are unstable\n+  --> $DIR/cast_errors.rs:11:28\n+   |\n+LL | const fn reify(f: fn()) -> unsafe fn() { f }\n+   |                            ^^^^^^^^^^^\n+\n+error: function pointers in const fn are unstable\n+  --> $DIR/cast_errors.rs:13:21\n+   |\n+LL | const fn reify2() { main as unsafe fn(); }\n+   |                     ^^^^^^^^^^^^^^^^^^^\n+\n+error: aborting due to 5 previous errors\n+"}, {"sha": "6a423aea7eceb24e6046d4106e9b38d89eb4aa35", "filename": "src/test/ui/generator/generator-region-requirements.ast.stderr", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/74ff7dcb1388e60a613cd6050bcd372a3cc4998b/src%2Ftest%2Fui%2Fgenerator%2Fgenerator-region-requirements.ast.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/74ff7dcb1388e60a613cd6050bcd372a3cc4998b/src%2Ftest%2Fui%2Fgenerator%2Fgenerator-region-requirements.ast.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fgenerator%2Fgenerator-region-requirements.ast.stderr?ref=74ff7dcb1388e60a613cd6050bcd372a3cc4998b", "patch": "@@ -0,0 +1,12 @@\n+error[E0621]: explicit lifetime required in the type of `x`\n+  --> $DIR/generator-region-requirements.rs:15:51\n+   |\n+LL | fn dangle(x: &mut i32) -> &'static mut i32 {\n+   |              -------- help: add explicit lifetime `'static` to the type of `x`: `&'static mut i32`\n+...\n+LL |             GeneratorState::Complete(c) => return c,\n+   |                                                   ^ lifetime `'static` required\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0621`."}, {"sha": "5d1050dc3526e490f52cb892a30541ee85ed4699", "filename": "src/test/ui/generator/generator-region-requirements.nll.stderr", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/74ff7dcb1388e60a613cd6050bcd372a3cc4998b/src%2Ftest%2Fui%2Fgenerator%2Fgenerator-region-requirements.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/74ff7dcb1388e60a613cd6050bcd372a3cc4998b/src%2Ftest%2Fui%2Fgenerator%2Fgenerator-region-requirements.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fgenerator%2Fgenerator-region-requirements.nll.stderr?ref=74ff7dcb1388e60a613cd6050bcd372a3cc4998b", "patch": "@@ -0,0 +1,12 @@\n+error[E0621]: explicit lifetime required in the type of `x`\n+  --> $DIR/generator-region-requirements.rs:11:9\n+   |\n+LL | fn dangle(x: &mut i32) -> &'static mut i32 {\n+   |              -------- help: add explicit lifetime `'static` to the type of `x`: `&'static mut i32`\n+...\n+LL |         x\n+   |         ^ lifetime `'static` required\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0621`."}, {"sha": "59e7841309c57750ce5c18b036c743758ada5995", "filename": "src/test/ui/generator/generator-region-requirements.rs", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/74ff7dcb1388e60a613cd6050bcd372a3cc4998b/src%2Ftest%2Fui%2Fgenerator%2Fgenerator-region-requirements.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74ff7dcb1388e60a613cd6050bcd372a3cc4998b/src%2Ftest%2Fui%2Fgenerator%2Fgenerator-region-requirements.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fgenerator%2Fgenerator-region-requirements.rs?ref=74ff7dcb1388e60a613cd6050bcd372a3cc4998b", "patch": "@@ -0,0 +1,21 @@\n+// revisions: ast nll\n+// ignore-compare-mode-nll\n+\n+#![feature(generators, generator_trait)]\n+#![cfg_attr(nll, feature(nll))]\n+use std::ops::{Generator, GeneratorState};\n+\n+fn dangle(x: &mut i32) -> &'static mut i32 {\n+    let mut g = || {\n+        yield;\n+        x\n+    };\n+    loop {\n+        match unsafe { g.resume() } {\n+            GeneratorState::Complete(c) => return c,\n+            GeneratorState::Yielded(_) => (),\n+        }\n+    }\n+}\n+\n+fn main() {}"}, {"sha": "37dc519a20401bb7a900f461cbc8a722ae3ba3d8", "filename": "src/test/ui/lint/no-unused-parens-return-block.rs", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/74ff7dcb1388e60a613cd6050bcd372a3cc4998b/src%2Ftest%2Fui%2Flint%2Fno-unused-parens-return-block.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74ff7dcb1388e60a613cd6050bcd372a3cc4998b/src%2Ftest%2Fui%2Flint%2Fno-unused-parens-return-block.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flint%2Fno-unused-parens-return-block.rs?ref=74ff7dcb1388e60a613cd6050bcd372a3cc4998b", "patch": "@@ -0,0 +1,9 @@\n+// run-pass\n+\n+#![deny(unused_parens)]\n+#![allow(unreachable_code)]\n+\n+fn main() {\n+    match (return) {} // ok\n+    if (return) {} // ok\n+}"}]}