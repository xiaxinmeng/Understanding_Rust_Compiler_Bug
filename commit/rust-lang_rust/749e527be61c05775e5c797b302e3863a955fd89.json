{"sha": "749e527be61c05775e5c797b302e3863a955fd89", "node_id": "MDY6Q29tbWl0NzI0NzEyOjc0OWU1MjdiZTYxYzA1Nzc1ZTVjNzk3YjMwMmUzODYzYTk1NWZkODk=", "commit": {"author": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2014-03-16T23:05:01Z"}, "committer": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2014-03-18T01:27:54Z"}, "message": "std: Improve docs for atomics. Fix two bugs\n\nThis adds lots of docs to the atomics module. Two of the examples\nare using the future atomics API and are ignored temporarily.\nI discovered a bug in the way AtomicBool's fetch_nand method is\nimplemented and fixed it by using the correct value for `true`.\nI also fixed the implementation of AcqRel fences (it was only doing\na release barrier), and made a \"relaxed\" fence a failure.", "tree": {"sha": "28093bba0ad9c241fbaa89094d34df30778d669c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/28093bba0ad9c241fbaa89094d34df30778d669c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/749e527be61c05775e5c797b302e3863a955fd89", "comment_count": 17, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/749e527be61c05775e5c797b302e3863a955fd89", "html_url": "https://github.com/rust-lang/rust/commit/749e527be61c05775e5c797b302e3863a955fd89", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/749e527be61c05775e5c797b302e3863a955fd89/comments", "author": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "committer": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "af9368452d8578af219713b34f7e3be4bd085186", "url": "https://api.github.com/repos/rust-lang/rust/commits/af9368452d8578af219713b34f7e3be4bd085186", "html_url": "https://github.com/rust-lang/rust/commit/af9368452d8578af219713b34f7e3be4bd085186"}], "stats": {"total": 461, "additions": 393, "deletions": 68}, "files": [{"sha": "500ae04869be2ca036d341aea0be9385c3380368", "filename": "src/libstd/sync/atomics.rs", "status": "modified", "additions": 393, "deletions": 68, "changes": 461, "blob_url": "https://github.com/rust-lang/rust/blob/749e527be61c05775e5c797b302e3863a955fd89/src%2Flibstd%2Fsync%2Fatomics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/749e527be61c05775e5c797b302e3863a955fd89/src%2Flibstd%2Fsync%2Fatomics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fatomics.rs?ref=749e527be61c05775e5c797b302e3863a955fd89", "patch": "@@ -8,16 +8,104 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-/*!\n- * Atomic types\n- *\n- * Basic atomic types supporting atomic operations. Each method takes an\n- * `Ordering` which represents the strength of the memory barrier for that\n- * operation. These orderings are the same as C++11 atomic orderings\n- * [http://gcc.gnu.org/wiki/Atomic/GCCMM/AtomicSync]\n- *\n- * All atomic types are a single word in size.\n- */\n+//! Atomic types\n+//!\n+//! Atomic types provide primitive shared-memory communication between\n+//! threads, and are the building blocks of other concurrent\n+//! types.\n+//!\n+//! This module defines atomic versions of a select number of primitive\n+//! types, including `AtomicBool`, `AtomicInt`, `AtomicUint`, and `AtomicOption`.\n+//! Atomic types present operations that, when used correctly, synchronize\n+//! updates between threads.\n+//!\n+//! Each method takes an `Ordering` which represents the strength of\n+//! the memory barrier for that operation. These orderings are the\n+//! same as [C++11 atomic orderings][1].\n+//!\n+//! [1]: http://gcc.gnu.org/wiki/Atomic/GCCMM/AtomicSync\n+//!\n+//! Atomic variables are safe to share between threads (they implement `Share`)\n+//! but they do not themselves provide the mechanism for sharing. The most\n+//! common way to share an atomic variable is to put it into an `Arc` (an\n+//! atomically-reference-counted shared pointer).\n+//!\n+//! Most atomic types may be stored in static variables, initialized using\n+//! the provided static initializers like `INIT_ATOMIC_BOOL`. Atomic statics\n+//! are often used for lazy global initialization.\n+//!\n+//!\n+//! # Examples\n+//!\n+//! A simple spinlock:\n+//!\n+//! ```ignore\n+//! # // FIXME: Needs PR #12430\n+//! extern crate sync;\n+//!\n+//! use sync::Arc;\n+//! use std::sync::atomics::{AtomicUint, SeqCst};\n+//! use std::task::deschedule;\n+//!\n+//! fn main() {\n+//!     let spinlock = Arc::new(AtomicUint::new(1));\n+//!\n+//!     let spinlock_clone = spinlock.clone();\n+//!     spawn(proc() {\n+//!         spinlock_clone.store(0, SeqCst);\n+//!     });\n+//!\n+//!     // Wait for the other task to release the lock\n+//!     while spinlock.load(SeqCst) != 0 {\n+//!         // Since tasks may not be preemptive (if they are green threads)\n+//!         // yield to the scheduler to let the other task run. Low level\n+//!         // concurrent code needs to take into account Rust's two threading\n+//!         // models.\n+//!         deschedule();\n+//!     }\n+//! }\n+//! ```\n+//!\n+//! Transferring a heap object with `AtomicOption`:\n+//!\n+//! ```ignore\n+//! # // FIXME: Needs PR #12430\n+//! extern crate sync;\n+//!\n+//! use sync::Arc;\n+//! use std::sync::atomics::{AtomicOption, SeqCst};\n+//!\n+//! fn main() {\n+//!     struct BigObject;\n+//!\n+//!     let shared_big_object = Arc::new(AtomicOption::empty());\n+//!\n+//!     let shared_big_object_clone = shared_big_object.clone();\n+//!     spawn(proc() {\n+//!         let unwrapped_big_object = shared_big_object_clone.take(SeqCst);\n+//!         if unwrapped_big_object.is_some() {\n+//!             println!(\"got a big object from another task\");\n+//!         } else {\n+//!             println!(\"other task hasn't sent big object yet\");\n+//!         }\n+//!     });\n+//!\n+//!     shared_big_object.swap(~BigObject, SeqCst);\n+//! }\n+//! ```\n+//!\n+//! Keep a global count of live tasks:\n+//!\n+//! ```\n+//! use std::sync::atomics::{AtomicUint, SeqCst, INIT_ATOMIC_UINT};\n+//!\n+//! static mut GLOBAL_TASK_COUNT: AtomicUint = INIT_ATOMIC_UINT;\n+//!\n+//! unsafe {\n+//!     let old_task_count = GLOBAL_TASK_COUNT.fetch_add(1, SeqCst);\n+//!     println!(\"live tasks: {}\", old_task_count + 1);\n+//! }\n+//! ```\n \n #[allow(missing_doc)];\n \n@@ -27,165 +115,353 @@ use std::kinds::marker;\n use option::{Option,Some,None};\n use ops::Drop;\n \n-/**\n- * An atomic boolean type.\n- */\n+/// An atomic boolean type.\n pub struct AtomicBool {\n     priv v: uint,\n     priv nopod: marker::NoPod\n }\n \n-/**\n- * A signed atomic integer type, supporting basic atomic arithmetic operations\n- */\n+/// A signed atomic integer type, supporting basic atomic arithmetic operations\n pub struct AtomicInt {\n     priv v: int,\n     priv nopod: marker::NoPod\n }\n \n-/**\n- * An unsigned atomic integer type, supporting basic atomic arithmetic operations\n- */\n+/// An unsigned atomic integer type, supporting basic atomic arithmetic operations\n pub struct AtomicUint {\n     priv v: uint,\n     priv nopod: marker::NoPod\n }\n \n-/**\n- * An unsigned atomic integer type that is forced to be 64-bits. This does not\n- * support all operations.\n- */\n+/// An unsigned atomic integer type that is forced to be 64-bits. This does not\n+/// support all operations.\n pub struct AtomicU64 {\n     priv v: u64,\n     priv nopod: marker::NoPod\n }\n \n-/**\n- * An unsafe atomic pointer. Only supports basic atomic operations\n- */\n+/// An unsafe atomic pointer. Only supports basic atomic operations\n pub struct AtomicPtr<T> {\n     priv p: uint,\n     priv nopod: marker::NoPod\n }\n \n-/**\n- * An owned atomic pointer. Ensures that only a single reference to the data is held at any time.\n- */\n+/// An atomic, nullable unique pointer\n+///\n+/// This can be used as the concurrency primitive for operations that transfer\n+/// owned heap objects across tasks.\n #[unsafe_no_drop_flag]\n pub struct AtomicOption<T> {\n     priv p: uint,\n }\n \n+/// Atomic memory orderings\n+///\n+/// Memory orderings limit the ways that both the compiler and CPU may reorder\n+/// instructions around atomic operations. At its most restrictive,\n+/// \"sequentially consistent\" atomics allow neither reads nor writes\n+/// to be moved either before or after the atomic operation; on the other end\n+/// \"relaxed\" atomics allow all reorderings.\n+///\n+/// Rust's memory orderings are the same as in C++[1].\n+///\n+/// [1]: http://gcc.gnu.org/wiki/Atomic/GCCMM/AtomicSync\n pub enum Ordering {\n+    /// No ordering constraints, only atomic operations\n     Relaxed,\n+    /// When coupled with a store, all previous writes become visible\n+    /// to another thread that performs a load with `Acquire` ordering\n+    /// on the same value\n     Release,\n+    /// When coupled with a load, all subsequent loads will see data\n+    /// written before a store with `Release` ordering on the same value\n+    /// in another thread\n     Acquire,\n+    /// When coupled with a load, uses `Acquire` ordering, and with a store\n+    /// `Release` ordering\n     AcqRel,\n+    /// Like `AcqRel` with the additional guarantee that all threads see all\n+    /// sequentially consistent operations in the same order.\n     SeqCst\n }\n \n+/// An `AtomicBool` initialized to `false`\n pub static INIT_ATOMIC_BOOL : AtomicBool = AtomicBool { v: 0, nopod: marker::NoPod };\n+/// An `AtomicInt` initialized to `0`\n pub static INIT_ATOMIC_INT  : AtomicInt  = AtomicInt  { v: 0, nopod: marker::NoPod };\n+/// An `AtomicUint` initialized to `0`\n pub static INIT_ATOMIC_UINT : AtomicUint = AtomicUint { v: 0, nopod: marker::NoPod };\n+/// An `AtomicU64` initialized to `0`\n pub static INIT_ATOMIC_U64 : AtomicU64 = AtomicU64 { v: 0, nopod: marker::NoPod };\n \n+\n+// NB: Needs to be -1 (0b11111111...) to make fetch_nand work correctly\n+static UINT_TRUE: uint = -1;\n+\n impl AtomicBool {\n+    /// Create a new `AtomicBool`\n     pub fn new(v: bool) -> AtomicBool {\n-        AtomicBool { v: if v { 1 } else { 0 }, nopod: marker::NoPod }\n+        AtomicBool { v: if v { UINT_TRUE } else { 0 }, nopod: marker::NoPod }\n     }\n \n+    /// Load the value\n     #[inline]\n     pub fn load(&self, order: Ordering) -> bool {\n         unsafe { atomic_load(&self.v, order) > 0 }\n     }\n \n+    /// Store the value\n     #[inline]\n     pub fn store(&mut self, val: bool, order: Ordering) {\n-        let val = if val { 1 } else { 0 };\n+        let val = if val { UINT_TRUE } else { 0 };\n \n         unsafe { atomic_store(&mut self.v, val, order); }\n     }\n \n+    /// Store a value, returning the old value\n     #[inline]\n     pub fn swap(&mut self, val: bool, order: Ordering) -> bool {\n-        let val = if val { 1 } else { 0 };\n+        let val = if val { UINT_TRUE } else { 0 };\n \n         unsafe { atomic_swap(&mut self.v, val, order) > 0 }\n     }\n \n+    /// If the current value is the same as expected, store a new value\n+    ///\n+    /// Compare the current value with `old`; if they are the same then\n+    /// replace the current value with `new`. Return the previous value.\n+    /// If the return value is equal to `old` then the value was updated.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```ignore\n+    /// # // FIXME: Needs PR #12430\n+    /// extern crate sync;\n+    ///\n+    /// use sync::Arc;\n+    /// use std::sync::atomics::{AtomicBool, SeqCst};\n+    ///\n+    /// fn main() {\n+    ///     let spinlock = Arc::new(AtomicBool::new(false));\n+    ///     let spinlock_clone = spin_lock.clone();\n+    ///\n+    ///     spawn(proc() {\n+    ///         with_lock(&spinlock, || println!(\"task 1 in lock\"));\n+    ///     });\n+    ///\n+    ///     spawn(proc() {\n+    ///         with_lock(&spinlock_clone, || println!(\"task 2 in lock\"));\n+    ///     });\n+    /// }\n+    ///\n+    /// fn with_lock(spinlock: &Arc<AtomicBool>, f: || -> ()) {\n+    ///     // CAS loop until we are able to replace `false` with `true`\n+    ///     while spinlock.compare_and_swap(false, true, SeqCst) == false {\n+    ///         // Since tasks may not be preemptive (if they are green threads)\n+    ///         // yield to the scheduler to let the other task run. Low level\n+    ///         // concurrent code needs to take into account Rust's two threading\n+    ///         // models.\n+    ///         deschedule();\n+    ///     }\n+    ///\n+    ///     // Now we have the spinlock\n+    ///     f();\n+    ///\n+    ///     // Release the lock\n+    ///     spinlock.store(false);\n+    /// }\n+    /// ```\n     #[inline]\n     pub fn compare_and_swap(&mut self, old: bool, new: bool, order: Ordering) -> bool {\n-        let old = if old { 1 } else { 0 };\n-        let new = if new { 1 } else { 0 };\n+        let old = if old { UINT_TRUE } else { 0 };\n+        let new = if new { UINT_TRUE } else { 0 };\n \n         unsafe { atomic_compare_and_swap(&mut self.v, old, new, order) > 0 }\n     }\n \n-    /// Returns the old value\n+    /// A logical \"and\" operation\n+    ///\n+    /// Performs a logical \"and\" operation on the current value and the\n+    /// argument `val`, and sets the new value to the result.\n+    /// Returns the previous value.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::sync::atomics::{AtomicBool, SeqCst};\n+    ///\n+    /// let mut foo = AtomicBool::new(true);\n+    /// assert_eq!(true, foo.fetch_and(false, SeqCst));\n+    /// assert_eq!(false, foo.load(SeqCst));\n+    ///\n+    /// let mut foo = AtomicBool::new(true);\n+    /// assert_eq!(true, foo.fetch_and(true, SeqCst));\n+    /// assert_eq!(true, foo.load(SeqCst));\n+    ///\n+    /// let mut foo = AtomicBool::new(false);\n+    /// assert_eq!(false, foo.fetch_and(false, SeqCst));\n+    /// assert_eq!(false, foo.load(SeqCst));\n+    /// ```\n     #[inline]\n     pub fn fetch_and(&mut self, val: bool, order: Ordering) -> bool {\n-        let val = if val { 1 } else { 0 };\n+        let val = if val { UINT_TRUE } else { 0 };\n \n         unsafe { atomic_and(&mut self.v, val, order) > 0 }\n     }\n \n-    /// Returns the old value\n+    /// A logical \"nand\" operation\n+    ///\n+    /// Performs a logical \"nand\" operation on the current value and the\n+    /// argument `val`, and sets the new value to the result.\n+    /// Returns the previous value.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::sync::atomics::{AtomicBool, SeqCst};\n+    ///\n+    /// let mut foo = AtomicBool::new(true);\n+    /// assert_eq!(true, foo.fetch_nand(false, SeqCst));\n+    /// assert_eq!(true, foo.load(SeqCst));\n+    ///\n+    /// let mut foo = AtomicBool::new(true);\n+    /// assert_eq!(true, foo.fetch_nand(true, SeqCst));\n+    /// assert_eq!(0, foo.load(SeqCst) as int);\n+    /// assert_eq!(false, foo.load(SeqCst));\n+    ///\n+    /// let mut foo = AtomicBool::new(false);\n+    /// assert_eq!(false, foo.fetch_nand(false, SeqCst));\n+    /// assert_eq!(true, foo.load(SeqCst));\n+    /// ```\n     #[inline]\n     pub fn fetch_nand(&mut self, val: bool, order: Ordering) -> bool {\n-        let val = if val { 1 } else { 0 };\n+        let val = if val { UINT_TRUE } else { 0 };\n \n         unsafe { atomic_nand(&mut self.v, val, order) > 0 }\n     }\n \n-    /// Returns the old value\n+    /// A logical \"or\" operation\n+    ///\n+    /// Performs a logical \"or\" operation on the current value and the\n+    /// argument `val`, and sets the new value to the result.\n+    /// Returns the previous value.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::sync::atomics::{AtomicBool, SeqCst};\n+    ///\n+    /// let mut foo = AtomicBool::new(true);\n+    /// assert_eq!(true, foo.fetch_or(false, SeqCst));\n+    /// assert_eq!(true, foo.load(SeqCst));\n+    ///\n+    /// let mut foo = AtomicBool::new(true);\n+    /// assert_eq!(true, foo.fetch_or(true, SeqCst));\n+    /// assert_eq!(true, foo.load(SeqCst));\n+    ///\n+    /// let mut foo = AtomicBool::new(false);\n+    /// assert_eq!(false, foo.fetch_or(false, SeqCst));\n+    /// assert_eq!(false, foo.load(SeqCst));\n+    /// ```\n     #[inline]\n     pub fn fetch_or(&mut self, val: bool, order: Ordering) -> bool {\n-        let val = if val { 1 } else { 0 };\n+        let val = if val { UINT_TRUE } else { 0 };\n \n         unsafe { atomic_or(&mut self.v, val, order) > 0 }\n     }\n \n-    /// Returns the old value\n+    /// A logical \"xor\" operation\n+    ///\n+    /// Performs a logical \"xor\" operation on the current value and the\n+    /// argument `val`, and sets the new value to the result.\n+    /// Returns the previous value.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::sync::atomics::{AtomicBool, SeqCst};\n+    ///\n+    /// let mut foo = AtomicBool::new(true);\n+    /// assert_eq!(true, foo.fetch_xor(false, SeqCst));\n+    /// assert_eq!(true, foo.load(SeqCst));\n+    ///\n+    /// let mut foo = AtomicBool::new(true);\n+    /// assert_eq!(true, foo.fetch_xor(true, SeqCst));\n+    /// assert_eq!(false, foo.load(SeqCst));\n+    ///\n+    /// let mut foo = AtomicBool::new(false);\n+    /// assert_eq!(false, foo.fetch_xor(false, SeqCst));\n+    /// assert_eq!(false, foo.load(SeqCst));\n+    /// ```\n     #[inline]\n     pub fn fetch_xor(&mut self, val: bool, order: Ordering) -> bool {\n-        let val = if val { 1 } else { 0 };\n+        let val = if val { UINT_TRUE } else { 0 };\n \n         unsafe { atomic_xor(&mut self.v, val, order) > 0 }\n     }\n }\n \n impl AtomicInt {\n+    /// Create a new `AtomicInt`\n     pub fn new(v: int) -> AtomicInt {\n         AtomicInt { v:v, nopod: marker::NoPod}\n     }\n \n+    /// Load the value\n     #[inline]\n     pub fn load(&self, order: Ordering) -> int {\n         unsafe { atomic_load(&self.v, order) }\n     }\n \n+    /// Store the value\n     #[inline]\n     pub fn store(&mut self, val: int, order: Ordering) {\n         unsafe { atomic_store(&mut self.v, val, order); }\n     }\n \n+    /// Store a value, returning the old value\n     #[inline]\n     pub fn swap(&mut self, val: int, order: Ordering) -> int {\n         unsafe { atomic_swap(&mut self.v, val, order) }\n     }\n \n+    /// If the current value is the same as expected, store a new value\n+    ///\n+    /// Compare the current value with `old`; if they are the same then\n+    /// replace the current value with `new`. Return the previous value.\n+    /// If the return value is equal to `old` then the value was updated.\n     #[inline]\n     pub fn compare_and_swap(&mut self, old: int, new: int, order: Ordering) -> int {\n         unsafe { atomic_compare_and_swap(&mut self.v, old, new, order) }\n     }\n \n-    /// Returns the old value (like __sync_fetch_and_add).\n+    /// Add to the current value, returning the previous\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::sync::atomics::{AtomicInt, SeqCst};\n+    ///\n+    /// let mut foo = AtomicInt::new(0);\n+    /// assert_eq!(0, foo.fetch_add(10, SeqCst));\n+    /// assert_eq!(10, foo.load(SeqCst));\n+    /// ```\n     #[inline]\n     pub fn fetch_add(&mut self, val: int, order: Ordering) -> int {\n         unsafe { atomic_add(&mut self.v, val, order) }\n     }\n \n-    /// Returns the old value (like __sync_fetch_and_sub).\n+    /// Subtract from the current value, returning the previous\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::sync::atomics::{AtomicInt, SeqCst};\n+    ///\n+    /// let mut foo = AtomicInt::new(0);\n+    /// assert_eq!(0, foo.fetch_sub(10, SeqCst));\n+    /// assert_eq!(-10, foo.load(SeqCst));\n+    /// ```\n     #[inline]\n     pub fn fetch_sub(&mut self, val: int, order: Ordering) -> int {\n         unsafe { atomic_sub(&mut self.v, val, order) }\n@@ -233,65 +509,103 @@ impl AtomicU64 {\n }\n \n impl AtomicUint {\n+    /// Create a new `AtomicUint`\n     pub fn new(v: uint) -> AtomicUint {\n         AtomicUint { v:v, nopod: marker::NoPod }\n     }\n \n+    /// Load the value\n     #[inline]\n     pub fn load(&self, order: Ordering) -> uint {\n         unsafe { atomic_load(&self.v, order) }\n     }\n \n+    /// Store the value\n     #[inline]\n     pub fn store(&mut self, val: uint, order: Ordering) {\n         unsafe { atomic_store(&mut self.v, val, order); }\n     }\n \n+    /// Store a value, returning the old value\n     #[inline]\n     pub fn swap(&mut self, val: uint, order: Ordering) -> uint {\n         unsafe { atomic_swap(&mut self.v, val, order) }\n     }\n \n+    /// If the current value is the same as expected, store a new value\n+    ///\n+    /// Compare the current value with `old`; if they are the same then\n+    /// replace the current value with `new`. Return the previous value.\n+    /// If the return value is equal to `old` then the value was updated.\n     #[inline]\n     pub fn compare_and_swap(&mut self, old: uint, new: uint, order: Ordering) -> uint {\n         unsafe { atomic_compare_and_swap(&mut self.v, old, new, order) }\n     }\n \n-    /// Returns the old value (like __sync_fetch_and_add).\n+    /// Add to the current value, returning the previous\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::sync::atomics::{AtomicUint, SeqCst};\n+    ///\n+    /// let mut foo = AtomicUint::new(0);\n+    /// assert_eq!(0, foo.fetch_add(10, SeqCst));\n+    /// assert_eq!(10, foo.load(SeqCst));\n+    /// ```\n     #[inline]\n     pub fn fetch_add(&mut self, val: uint, order: Ordering) -> uint {\n         unsafe { atomic_add(&mut self.v, val, order) }\n     }\n \n-    /// Returns the old value (like __sync_fetch_and_sub)..\n+    /// Subtract from the current value, returning the previous\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::sync::atomics::{AtomicUint, SeqCst};\n+    ///\n+    /// let mut foo = AtomicUint::new(10);\n+    /// assert_eq!(10, foo.fetch_sub(10, SeqCst));\n+    /// assert_eq!(0, foo.load(SeqCst));\n+    /// ```\n     #[inline]\n     pub fn fetch_sub(&mut self, val: uint, order: Ordering) -> uint {\n         unsafe { atomic_sub(&mut self.v, val, order) }\n     }\n }\n \n impl<T> AtomicPtr<T> {\n+    /// Create a new `AtomicPtr`\n     pub fn new(p: *mut T) -> AtomicPtr<T> {\n         AtomicPtr { p: p as uint, nopod: marker::NoPod }\n     }\n \n+    /// Load the value\n     #[inline]\n     pub fn load(&self, order: Ordering) -> *mut T {\n         unsafe {\n             atomic_load(&self.p, order) as *mut T\n         }\n     }\n \n+    /// Store the value\n     #[inline]\n     pub fn store(&mut self, ptr: *mut T, order: Ordering) {\n         unsafe { atomic_store(&mut self.p, ptr as uint, order); }\n     }\n \n+    /// Store a value, returning the old value\n     #[inline]\n     pub fn swap(&mut self, ptr: *mut T, order: Ordering) -> *mut T {\n         unsafe { atomic_swap(&mut self.p, ptr as uint, order) as *mut T }\n     }\n \n+    /// If the current value is the same as expected, store a new value\n+    ///\n+    /// Compare the current value with `old`; if they are the same then\n+    /// replace the current value with `new`. Return the previous value.\n+    /// If the return value is equal to `old` then the value was updated.\n     #[inline]\n     pub fn compare_and_swap(&mut self, old: *mut T, new: *mut T, order: Ordering) -> *mut T {\n         unsafe {\n@@ -302,12 +616,15 @@ impl<T> AtomicPtr<T> {\n }\n \n impl<T> AtomicOption<T> {\n+    /// Create a new `AtomicOption`\n     pub fn new(p: ~T) -> AtomicOption<T> {\n         unsafe { AtomicOption { p: cast::transmute(p) } }\n     }\n \n+    /// Create a new `AtomicOption` that doesn't contain a value\n     pub fn empty() -> AtomicOption<T> { AtomicOption { p: 0 } }\n \n+    /// Store a value, returning the old value\n     #[inline]\n     pub fn swap(&mut self, val: ~T, order: Ordering) -> Option<~T> {\n         unsafe {\n@@ -322,13 +639,16 @@ impl<T> AtomicOption<T> {\n         }\n     }\n \n+    /// Remove the value, leaving the `AtomicOption` empty.\n     #[inline]\n     pub fn take(&mut self, order: Ordering) -> Option<~T> {\n         unsafe { self.swap(cast::transmute(0), order) }\n     }\n \n-    /// A compare-and-swap. Succeeds if the option is 'None' and returns 'None'\n-    /// if so. If the option was already 'Some', returns 'Some' of the rejected\n+    /// Replace an empty value with a non-empty value.\n+    ///\n+    /// Succeeds if the option is `None` and returns `None` if so. If\n+    /// the option was already `Some`, returns `Some` of the rejected\n     /// value.\n     #[inline]\n     pub fn fill(&mut self, val: ~T, order: Ordering) -> Option<~T> {\n@@ -344,6 +664,8 @@ impl<T> AtomicOption<T> {\n         }\n     }\n \n+    /// Returns `true` if the `AtomicOption` is empty.\n+    ///\n     /// Be careful: The caller must have some external method of ensuring the\n     /// result does not get invalidated by another task after this returns.\n     #[inline]\n@@ -470,32 +792,35 @@ pub unsafe fn atomic_xor<T>(dst: &mut T, val: T, order: Ordering) -> T {\n }\n \n \n-/**\n- * An atomic fence.\n- *\n- * A fence 'A' which has `Release` ordering semantics, synchronizes with a\n- * fence 'B' with (at least) `Acquire` semantics, if and only if there exists\n- * atomic operations X and Y, both operating on some atomic object 'M' such\n- * that A is sequenced before X, Y is synchronized before B and Y observers\n- * the change to M. This provides a happens-before dependence between A and B.\n- *\n- * Atomic operations with `Release` or `Acquire` semantics can also synchronize\n- * with a fence.\n- *\n- * A fence with has `SeqCst` ordering, in addition to having both `Acquire` and\n- * `Release` semantics, participates in the global program order of the other\n- * `SeqCst` operations and/or fences.\n- *\n- * Accepts `Acquire`, `Release`, `AcqRel` and `SeqCst` orderings.\n- */\n+/// An atomic fence.\n+///\n+/// A fence 'A' which has `Release` ordering semantics, synchronizes with a\n+/// fence 'B' with (at least) `Acquire` semantics, if and only if there exists\n+/// atomic operations X and Y, both operating on some atomic object 'M' such\n+/// that A is sequenced before X, Y is synchronized before B and Y observers\n+/// the change to M. This provides a happens-before dependence between A and B.\n+///\n+/// Atomic operations with `Release` or `Acquire` semantics can also synchronize\n+/// with a fence.\n+///\n+/// A fence with has `SeqCst` ordering, in addition to having both `Acquire` and\n+/// `Release` semantics, participates in the global program order of the other\n+/// `SeqCst` operations and/or fences.\n+///\n+/// Accepts `Acquire`, `Release`, `AcqRel` and `SeqCst` orderings.\n+///\n+/// # Failure\n+///\n+/// Fails if `order` is `Relaxed`\n #[inline]\n pub fn fence(order: Ordering) {\n     unsafe {\n         match order {\n             Acquire => intrinsics::atomic_fence_acq(),\n             Release => intrinsics::atomic_fence_rel(),\n-            AcqRel  => intrinsics::atomic_fence_rel(),\n-            _       => intrinsics::atomic_fence(),\n+            AcqRel  => intrinsics::atomic_fence_acqrel(),\n+            SeqCst  => intrinsics::atomic_fence(),\n+            Relaxed => fail!(\"there is no such thing as a relaxed fence\")\n         }\n     }\n }"}]}