{"sha": "93f85f5a9d97fc49826d0063c9db0a71602d3283", "node_id": "C_kwDOAAsO6NoAKDkzZjg1ZjVhOWQ5N2ZjNDk4MjZkMDA2M2M5ZGIwYTcxNjAyZDMyODM", "commit": {"author": {"name": "Tomasz Mi\u0105sko", "email": "tomasz.miasko@gmail.com", "date": "2021-10-23T00:00:00Z"}, "committer": {"name": "Tomasz Mi\u0105sko", "email": "tomasz.miasko@gmail.com", "date": "2021-10-26T06:20:01Z"}, "message": "Consider indirect mutation during const qualification dataflow\n\nPreviously a local would be qualified if either one of two separate data\nflow computations indicated so. First determined if a local could\ncontain the qualif, but ignored any forms of indirect mutation. Second\ndetermined if a local could be mutably borrowed (and so indirectly\nmutated), but which in turn ignored the qualif.\n\nThe end result was incorrect because the effect of indirect mutation was\neffectivelly ignored in the all but the final stage of computation.\n\nIn the new implementation the indirect mutation is directly incorporated\ninto the qualif data flow. The local variable becomes immediately\nqualified once it is mutably borrowed and borrowed place type can\ncontain the qualif.\n\nIn general we will now reject additional programs, program that were\nprevously unintentionally accepted.\n\nThere are also some cases which are now accepted but were previously\nrejected, because previous implementation didn't consider whether\nborrowed place could have the qualif under the consideration.", "tree": {"sha": "10d4d0cd84517697d8566939f0ccc05689a095f2", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/10d4d0cd84517697d8566939f0ccc05689a095f2"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/93f85f5a9d97fc49826d0063c9db0a71602d3283", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/93f85f5a9d97fc49826d0063c9db0a71602d3283", "html_url": "https://github.com/rust-lang/rust/commit/93f85f5a9d97fc49826d0063c9db0a71602d3283", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/93f85f5a9d97fc49826d0063c9db0a71602d3283/comments", "author": {"login": "tmiasko", "id": 51362316, "node_id": "MDQ6VXNlcjUxMzYyMzE2", "avatar_url": "https://avatars.githubusercontent.com/u/51362316?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tmiasko", "html_url": "https://github.com/tmiasko", "followers_url": "https://api.github.com/users/tmiasko/followers", "following_url": "https://api.github.com/users/tmiasko/following{/other_user}", "gists_url": "https://api.github.com/users/tmiasko/gists{/gist_id}", "starred_url": "https://api.github.com/users/tmiasko/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tmiasko/subscriptions", "organizations_url": "https://api.github.com/users/tmiasko/orgs", "repos_url": "https://api.github.com/users/tmiasko/repos", "events_url": "https://api.github.com/users/tmiasko/events{/privacy}", "received_events_url": "https://api.github.com/users/tmiasko/received_events", "type": "User", "site_admin": false}, "committer": {"login": "tmiasko", "id": 51362316, "node_id": "MDQ6VXNlcjUxMzYyMzE2", "avatar_url": "https://avatars.githubusercontent.com/u/51362316?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tmiasko", "html_url": "https://github.com/tmiasko", "followers_url": "https://api.github.com/users/tmiasko/followers", "following_url": "https://api.github.com/users/tmiasko/following{/other_user}", "gists_url": "https://api.github.com/users/tmiasko/gists{/gist_id}", "starred_url": "https://api.github.com/users/tmiasko/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tmiasko/subscriptions", "organizations_url": "https://api.github.com/users/tmiasko/orgs", "repos_url": "https://api.github.com/users/tmiasko/repos", "events_url": "https://api.github.com/users/tmiasko/events{/privacy}", "received_events_url": "https://api.github.com/users/tmiasko/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "17e13b549f5f83cd9ffca9a540090754eb95115c", "url": "https://api.github.com/repos/rust-lang/rust/commits/17e13b549f5f83cd9ffca9a540090754eb95115c", "html_url": "https://github.com/rust-lang/rust/commit/17e13b549f5f83cd9ffca9a540090754eb95115c"}], "stats": {"total": 313, "additions": 250, "deletions": 63}, "files": [{"sha": "3cb4d415021e46d4bb04896a4fdf9ae0f3d9a03e", "filename": "compiler/rustc_const_eval/src/transform/check_consts/check.rs", "status": "modified", "additions": 4, "deletions": 38, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/93f85f5a9d97fc49826d0063c9db0a71602d3283/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fcheck_consts%2Fcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/93f85f5a9d97fc49826d0063c9db0a71602d3283/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fcheck_consts%2Fcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fcheck_consts%2Fcheck.rs?ref=93f85f5a9d97fc49826d0063c9db0a71602d3283", "patch": "@@ -12,7 +12,6 @@ use rustc_middle::ty::cast::CastTy;\n use rustc_middle::ty::subst::{GenericArgKind, InternalSubsts};\n use rustc_middle::ty::{self, adjustment::PointerCast, Instance, InstanceDef, Ty, TyCtxt};\n use rustc_middle::ty::{Binder, TraitPredicate, TraitRef};\n-use rustc_mir_dataflow::impls::MaybeMutBorrowedLocals;\n use rustc_mir_dataflow::{self, Analysis};\n use rustc_span::{sym, Span, Symbol};\n use rustc_trait_selection::traits::error_reporting::InferCtxtExt;\n@@ -27,12 +26,6 @@ use super::resolver::FlowSensitiveAnalysis;\n use super::{is_lang_panic_fn, is_lang_special_const_fn, ConstCx, Qualif};\n use crate::const_eval::is_unstable_const_fn;\n \n-// We are using `MaybeMutBorrowedLocals` as a proxy for whether an item may have been mutated\n-// through a pointer prior to the given point. This is okay even though `MaybeMutBorrowedLocals`\n-// kills locals upon `StorageDead` because a local will never be used after a `StorageDead`.\n-type IndirectlyMutableResults<'mir, 'tcx> =\n-    rustc_mir_dataflow::ResultsCursor<'mir, 'tcx, MaybeMutBorrowedLocals<'mir, 'tcx>>;\n-\n type QualifResults<'mir, 'tcx, Q> =\n     rustc_mir_dataflow::ResultsCursor<'mir, 'tcx, FlowSensitiveAnalysis<'mir, 'mir, 'tcx, Q>>;\n \n@@ -41,36 +34,9 @@ pub struct Qualifs<'mir, 'tcx> {\n     has_mut_interior: Option<QualifResults<'mir, 'tcx, HasMutInterior>>,\n     needs_drop: Option<QualifResults<'mir, 'tcx, NeedsDrop>>,\n     needs_non_const_drop: Option<QualifResults<'mir, 'tcx, NeedsNonConstDrop>>,\n-    indirectly_mutable: Option<IndirectlyMutableResults<'mir, 'tcx>>,\n }\n \n impl Qualifs<'mir, 'tcx> {\n-    pub fn indirectly_mutable(\n-        &mut self,\n-        ccx: &'mir ConstCx<'mir, 'tcx>,\n-        local: Local,\n-        location: Location,\n-    ) -> bool {\n-        let indirectly_mutable = self.indirectly_mutable.get_or_insert_with(|| {\n-            let ConstCx { tcx, body, param_env, .. } = *ccx;\n-\n-            // We can use `unsound_ignore_borrow_on_drop` here because custom drop impls are not\n-            // allowed in a const.\n-            //\n-            // FIXME(ecstaticmorse): Someday we want to allow custom drop impls. How do we do this\n-            // without breaking stable code?\n-            MaybeMutBorrowedLocals::mut_borrows_only(tcx, &body, param_env)\n-                .unsound_ignore_borrow_on_drop()\n-                .into_engine(tcx, &body)\n-                .pass_name(\"const_qualification\")\n-                .iterate_to_fixpoint()\n-                .into_results_cursor(&body)\n-        });\n-\n-        indirectly_mutable.seek_before_primary_effect(location);\n-        indirectly_mutable.get().contains(local)\n-    }\n-\n     /// Returns `true` if `local` is `NeedsDrop` at the given `Location`.\n     ///\n     /// Only updates the cursor if absolutely necessary\n@@ -95,7 +61,7 @@ impl Qualifs<'mir, 'tcx> {\n         });\n \n         needs_drop.seek_before_primary_effect(location);\n-        needs_drop.get().contains(local) || self.indirectly_mutable(ccx, local, location)\n+        needs_drop.get().contains(local)\n     }\n \n     /// Returns `true` if `local` is `NeedsNonConstDrop` at the given `Location`.\n@@ -122,7 +88,7 @@ impl Qualifs<'mir, 'tcx> {\n         });\n \n         needs_non_const_drop.seek_before_primary_effect(location);\n-        needs_non_const_drop.get().contains(local) || self.indirectly_mutable(ccx, local, location)\n+        needs_non_const_drop.get().contains(local)\n     }\n \n     /// Returns `true` if `local` is `HasMutInterior` at the given `Location`.\n@@ -149,7 +115,7 @@ impl Qualifs<'mir, 'tcx> {\n         });\n \n         has_mut_interior.seek_before_primary_effect(location);\n-        has_mut_interior.get().contains(local) || self.indirectly_mutable(ccx, local, location)\n+        has_mut_interior.get().contains(local)\n     }\n \n     fn in_return_place(\n@@ -195,7 +161,7 @@ impl Qualifs<'mir, 'tcx> {\n                     .into_results_cursor(&ccx.body);\n \n                 cursor.seek_after_primary_effect(return_loc);\n-                cursor.contains(RETURN_PLACE)\n+                cursor.get().contains(RETURN_PLACE)\n             }\n         };\n "}, {"sha": "ff2271fb396ada52323d7d6c762db85fd37b1b68", "filename": "compiler/rustc_const_eval/src/transform/check_consts/resolver.rs", "status": "modified", "additions": 153, "deletions": 25, "changes": 178, "blob_url": "https://github.com/rust-lang/rust/blob/93f85f5a9d97fc49826d0063c9db0a71602d3283/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fcheck_consts%2Fresolver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/93f85f5a9d97fc49826d0063c9db0a71602d3283/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fcheck_consts%2Fresolver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fcheck_consts%2Fresolver.rs?ref=93f85f5a9d97fc49826d0063c9db0a71602d3283", "patch": "@@ -5,39 +5,44 @@\n use rustc_index::bit_set::BitSet;\n use rustc_middle::mir::visit::Visitor;\n use rustc_middle::mir::{self, BasicBlock, Local, Location, Statement, StatementKind};\n+use rustc_mir_dataflow::fmt::DebugWithContext;\n+use rustc_mir_dataflow::JoinSemiLattice;\n+use rustc_span::DUMMY_SP;\n \n+use std::fmt;\n use std::marker::PhantomData;\n \n use super::{qualifs, ConstCx, Qualif};\n \n /// A `Visitor` that propagates qualifs between locals. This defines the transfer function of\n /// `FlowSensitiveAnalysis`.\n ///\n-/// This transfer does nothing when encountering an indirect assignment. Consumers should rely on\n-/// the `MaybeMutBorrowedLocals` dataflow pass to see if a `Local` may have become qualified via\n-/// an indirect assignment or function call.\n+/// To account for indirect assignments, data flow conservatively assumes that local becomes\n+/// qualified immediately after it is borrowed or its address escapes. The borrow must allow for\n+/// mutation, which includes shared borrows of places with interior mutability. The type of\n+/// borrowed place must contain the qualif.\n struct TransferFunction<'a, 'mir, 'tcx, Q> {\n     ccx: &'a ConstCx<'mir, 'tcx>,\n-    qualifs_per_local: &'a mut BitSet<Local>,\n-\n+    state: &'a mut State,\n     _qualif: PhantomData<Q>,\n }\n \n impl<Q> TransferFunction<'a, 'mir, 'tcx, Q>\n where\n     Q: Qualif,\n {\n-    fn new(ccx: &'a ConstCx<'mir, 'tcx>, qualifs_per_local: &'a mut BitSet<Local>) -> Self {\n-        TransferFunction { ccx, qualifs_per_local, _qualif: PhantomData }\n+    fn new(ccx: &'a ConstCx<'mir, 'tcx>, state: &'a mut State) -> Self {\n+        TransferFunction { ccx, state, _qualif: PhantomData }\n     }\n \n     fn initialize_state(&mut self) {\n-        self.qualifs_per_local.clear();\n+        self.state.qualif.clear();\n+        self.state.borrow.clear();\n \n         for arg in self.ccx.body.args_iter() {\n             let arg_ty = self.ccx.body.local_decls[arg].ty;\n             if Q::in_any_value_of_ty(self.ccx, arg_ty) {\n-                self.qualifs_per_local.insert(arg);\n+                self.state.qualif.insert(arg);\n             }\n         }\n     }\n@@ -47,15 +52,15 @@ where\n \n         match (value, place.as_ref()) {\n             (true, mir::PlaceRef { local, .. }) => {\n-                self.qualifs_per_local.insert(local);\n+                self.state.qualif.insert(local);\n             }\n \n             // For now, we do not clear the qualif if a local is overwritten in full by\n             // an unqualified rvalue (e.g. `y = 5`). This is to be consistent\n             // with aggregates where we overwrite all fields with assignments, which would not\n             // get this feature.\n             (false, mir::PlaceRef { local: _, projection: &[] }) => {\n-                // self.qualifs_per_local.remove(*local);\n+                // self.state.qualif.remove(*local);\n             }\n \n             _ => {}\n@@ -78,6 +83,29 @@ where\n             self.assign_qualif_direct(&return_place, qualif);\n         }\n     }\n+\n+    fn address_of_allows_mutation(&self, mt: mir::Mutability, place: mir::Place<'tcx>) -> bool {\n+        match mt {\n+            mir::Mutability::Mut => true,\n+            mir::Mutability::Not => self.shared_borrow_allows_mutation(place),\n+        }\n+    }\n+\n+    fn ref_allows_mutation(&self, kind: mir::BorrowKind, place: mir::Place<'tcx>) -> bool {\n+        match kind {\n+            mir::BorrowKind::Mut { .. } => true,\n+            mir::BorrowKind::Shared | mir::BorrowKind::Shallow | mir::BorrowKind::Unique => {\n+                self.shared_borrow_allows_mutation(place)\n+            }\n+        }\n+    }\n+\n+    fn shared_borrow_allows_mutation(&self, place: mir::Place<'tcx>) -> bool {\n+        !place\n+            .ty(self.ccx.body, self.ccx.tcx)\n+            .ty\n+            .is_freeze(self.ccx.tcx.at(DUMMY_SP), self.ccx.param_env)\n+    }\n }\n \n impl<Q> Visitor<'tcx> for TransferFunction<'_, '_, 'tcx, Q>\n@@ -95,7 +123,12 @@ where\n         // it no longer needs to be dropped.\n         if let mir::Operand::Move(place) = operand {\n             if let Some(local) = place.as_local() {\n-                self.qualifs_per_local.remove(local);\n+                // For backward compatibility with the MaybeMutBorrowedLocals used in an earlier\n+                // implementation we retain qualif if a local had been borrowed before. This might\n+                // not be strictly necessary since the local is no longer initialized.\n+                if !self.state.borrow.contains(local) {\n+                    self.state.qualif.remove(local);\n+                }\n             }\n         }\n     }\n@@ -106,11 +139,8 @@ where\n         rvalue: &mir::Rvalue<'tcx>,\n         location: Location,\n     ) {\n-        let qualif = qualifs::in_rvalue::<Q, _>(\n-            self.ccx,\n-            &mut |l| self.qualifs_per_local.contains(l),\n-            rvalue,\n-        );\n+        let qualif =\n+            qualifs::in_rvalue::<Q, _>(self.ccx, &mut |l| self.state.qualif.contains(l), rvalue);\n         if !place.is_indirect() {\n             self.assign_qualif_direct(place, qualif);\n         }\n@@ -120,10 +150,53 @@ where\n         self.super_assign(place, rvalue, location);\n     }\n \n+    fn visit_rvalue(&mut self, rvalue: &mir::Rvalue<'tcx>, location: Location) {\n+        self.super_rvalue(rvalue, location);\n+\n+        match rvalue {\n+            mir::Rvalue::AddressOf(mt, borrowed_place) => {\n+                if !borrowed_place.is_indirect()\n+                    && self.address_of_allows_mutation(*mt, *borrowed_place)\n+                {\n+                    let place_ty = borrowed_place.ty(self.ccx.body, self.ccx.tcx).ty;\n+                    if Q::in_any_value_of_ty(self.ccx, place_ty) {\n+                        self.state.qualif.insert(borrowed_place.local);\n+                        self.state.borrow.insert(borrowed_place.local);\n+                    }\n+                }\n+            }\n+\n+            mir::Rvalue::Ref(_, kind, borrowed_place) => {\n+                if !borrowed_place.is_indirect() && self.ref_allows_mutation(*kind, *borrowed_place)\n+                {\n+                    let place_ty = borrowed_place.ty(self.ccx.body, self.ccx.tcx).ty;\n+                    if Q::in_any_value_of_ty(self.ccx, place_ty) {\n+                        self.state.qualif.insert(borrowed_place.local);\n+                        self.state.borrow.insert(borrowed_place.local);\n+                    }\n+                }\n+            }\n+\n+            mir::Rvalue::Cast(..)\n+            | mir::Rvalue::ShallowInitBox(..)\n+            | mir::Rvalue::Use(..)\n+            | mir::Rvalue::ThreadLocalRef(..)\n+            | mir::Rvalue::Repeat(..)\n+            | mir::Rvalue::Len(..)\n+            | mir::Rvalue::BinaryOp(..)\n+            | mir::Rvalue::CheckedBinaryOp(..)\n+            | mir::Rvalue::NullaryOp(..)\n+            | mir::Rvalue::UnaryOp(..)\n+            | mir::Rvalue::Discriminant(..)\n+            | mir::Rvalue::Aggregate(..) => {}\n+        }\n+    }\n+\n     fn visit_statement(&mut self, statement: &Statement<'tcx>, location: Location) {\n         match statement.kind {\n             StatementKind::StorageDead(local) => {\n-                self.qualifs_per_local.remove(local);\n+                self.state.qualif.remove(local);\n+                self.state.borrow.remove(local);\n             }\n             _ => self.super_statement(statement, location),\n         }\n@@ -136,7 +209,7 @@ where\n         if let mir::TerminatorKind::DropAndReplace { value, place, .. } = &terminator.kind {\n             let qualif = qualifs::in_operand::<Q, _>(\n                 self.ccx,\n-                &mut |l| self.qualifs_per_local.contains(l),\n+                &mut |l| self.state.qualif.contains(l),\n                 value,\n             );\n \n@@ -145,6 +218,9 @@ where\n             }\n         }\n \n+        // We ignore borrow on drop because custom drop impls are not allowed in consts.\n+        // FIXME: Reconsider if accounting for borrows in drops is necessary for const drop.\n+\n         // We need to assign qualifs to the dropped location before visiting the operand that\n         // replaces it since qualifs can be cleared on move.\n         self.super_terminator(terminator, location);\n@@ -165,24 +241,76 @@ where\n         FlowSensitiveAnalysis { ccx, _qualif: PhantomData }\n     }\n \n-    fn transfer_function(\n-        &self,\n-        state: &'a mut BitSet<Local>,\n-    ) -> TransferFunction<'a, 'mir, 'tcx, Q> {\n+    fn transfer_function(&self, state: &'a mut State) -> TransferFunction<'a, 'mir, 'tcx, Q> {\n         TransferFunction::<Q>::new(self.ccx, state)\n     }\n }\n \n+#[derive(Clone, Debug, PartialEq, Eq)]\n+pub(super) struct State {\n+    /// Describes whether a local contains qualif.\n+    pub qualif: BitSet<Local>,\n+    /// Describes whether a local's address escaped and it might become qualified as a result an\n+    /// indirect mutation.\n+    pub borrow: BitSet<Local>,\n+}\n+\n+impl State {\n+    #[inline]\n+    pub(super) fn contains(&self, local: Local) -> bool {\n+        self.qualif.contains(local)\n+    }\n+}\n+\n+impl<C> DebugWithContext<C> for State {\n+    fn fmt_with(&self, ctxt: &C, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        f.write_str(\"qualif: \")?;\n+        self.qualif.fmt_with(ctxt, f)?;\n+        f.write_str(\" borrow: \")?;\n+        self.borrow.fmt_with(ctxt, f)?;\n+        Ok(())\n+    }\n+\n+    fn fmt_diff_with(&self, old: &Self, ctxt: &C, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        if self == old {\n+            return Ok(());\n+        }\n+\n+        if self.qualif != old.qualif {\n+            f.write_str(\"qualif: \")?;\n+            self.qualif.fmt_diff_with(&old.qualif, ctxt, f)?;\n+            f.write_str(\"\\n\")?;\n+        }\n+\n+        if self.borrow != old.borrow {\n+            f.write_str(\"borrow: \")?;\n+            self.qualif.fmt_diff_with(&old.borrow, ctxt, f)?;\n+            f.write_str(\"\\n\")?;\n+        }\n+\n+        Ok(())\n+    }\n+}\n+\n+impl JoinSemiLattice for State {\n+    fn join(&mut self, other: &Self) -> bool {\n+        self.qualif.join(&other.qualif) || self.borrow.join(&other.borrow)\n+    }\n+}\n+\n impl<Q> rustc_mir_dataflow::AnalysisDomain<'tcx> for FlowSensitiveAnalysis<'_, '_, 'tcx, Q>\n where\n     Q: Qualif,\n {\n-    type Domain = BitSet<Local>;\n+    type Domain = State;\n \n     const NAME: &'static str = Q::ANALYSIS_NAME;\n \n     fn bottom_value(&self, body: &mir::Body<'tcx>) -> Self::Domain {\n-        BitSet::new_empty(body.local_decls.len())\n+        State {\n+            qualif: BitSet::new_empty(body.local_decls.len()),\n+            borrow: BitSet::new_empty(body.local_decls.len()),\n+        }\n     }\n \n     fn initialize_start_block(&self, _body: &mir::Body<'tcx>, state: &mut Self::Domain) {"}, {"sha": "cedead00fec970e80fef71bf41e80ceebd3a7e01", "filename": "src/test/ui/consts/qualif-indirect-mutation-fail.rs", "status": "added", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/93f85f5a9d97fc49826d0063c9db0a71602d3283/src%2Ftest%2Fui%2Fconsts%2Fqualif-indirect-mutation-fail.rs", "raw_url": "https://github.com/rust-lang/rust/raw/93f85f5a9d97fc49826d0063c9db0a71602d3283/src%2Ftest%2Fui%2Fconsts%2Fqualif-indirect-mutation-fail.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fqualif-indirect-mutation-fail.rs?ref=93f85f5a9d97fc49826d0063c9db0a71602d3283", "patch": "@@ -0,0 +1,44 @@\n+// compile-flags: --crate-type=lib\n+#![feature(const_mut_refs)]\n+#![feature(const_precise_live_drops)]\n+#![feature(const_swap)]\n+\n+// Mutable borrow of a field with drop impl.\n+pub const fn f() {\n+    let mut a: (u32, Option<String>) = (0, None); //~ ERROR destructors cannot be evaluated\n+    let _ = &mut a.1;\n+}\n+\n+// Mutable borrow of a type with drop impl.\n+pub const A1: () = {\n+    let mut x = None; //~ ERROR destructors cannot be evaluated\n+    let mut y = Some(String::new());\n+    let a = &mut x;\n+    let b = &mut y;\n+    std::mem::swap(a, b);\n+    std::mem::forget(y);\n+};\n+\n+// Mutable borrow of a type with drop impl.\n+pub const A2: () = {\n+    let mut x = None;\n+    let mut y = Some(String::new());\n+    let a = &mut x;\n+    let b = &mut y;\n+    std::mem::swap(a, b);\n+    std::mem::forget(y);\n+    let _z = x; //~ ERROR destructors cannot be evaluated\n+};\n+\n+// Shared borrow of a type that might be !Freeze and Drop.\n+pub const fn g1<T>() {\n+    let x: Option<T> = None; //~ ERROR destructors cannot be evaluated\n+    let _ = x.is_some();\n+}\n+\n+// Shared borrow of a type that might be !Freeze and Drop.\n+pub const fn g2<T>() {\n+    let x: Option<T> = None;\n+    let _ = x.is_some();\n+    let _y = x; //~ ERROR destructors cannot be evaluated\n+}"}, {"sha": "aa6ed465594e33cf613aeb7afbda8e20ab971710", "filename": "src/test/ui/consts/qualif-indirect-mutation-fail.stderr", "status": "added", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/93f85f5a9d97fc49826d0063c9db0a71602d3283/src%2Ftest%2Fui%2Fconsts%2Fqualif-indirect-mutation-fail.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/93f85f5a9d97fc49826d0063c9db0a71602d3283/src%2Ftest%2Fui%2Fconsts%2Fqualif-indirect-mutation-fail.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fqualif-indirect-mutation-fail.stderr?ref=93f85f5a9d97fc49826d0063c9db0a71602d3283", "patch": "@@ -0,0 +1,33 @@\n+error[E0493]: destructors cannot be evaluated at compile-time\n+  --> $DIR/qualif-indirect-mutation-fail.rs:8:9\n+   |\n+LL |     let mut a: (u32, Option<String>) = (0, None);\n+   |         ^^^^^ constant functions cannot evaluate destructors\n+\n+error[E0493]: destructors cannot be evaluated at compile-time\n+  --> $DIR/qualif-indirect-mutation-fail.rs:14:9\n+   |\n+LL |     let mut x = None;\n+   |         ^^^^^ constants cannot evaluate destructors\n+\n+error[E0493]: destructors cannot be evaluated at compile-time\n+  --> $DIR/qualif-indirect-mutation-fail.rs:30:9\n+   |\n+LL |     let _z = x;\n+   |         ^^ constants cannot evaluate destructors\n+\n+error[E0493]: destructors cannot be evaluated at compile-time\n+  --> $DIR/qualif-indirect-mutation-fail.rs:35:9\n+   |\n+LL |     let x: Option<T> = None;\n+   |         ^ constant functions cannot evaluate destructors\n+\n+error[E0493]: destructors cannot be evaluated at compile-time\n+  --> $DIR/qualif-indirect-mutation-fail.rs:43:9\n+   |\n+LL |     let _y = x;\n+   |         ^^ constant functions cannot evaluate destructors\n+\n+error: aborting due to 5 previous errors\n+\n+For more information about this error, try `rustc --explain E0493`."}, {"sha": "35a9b70a5f6f1f9339b6d126d00e45db3b196de6", "filename": "src/test/ui/consts/qualif-indirect-mutation-pass.rs", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/93f85f5a9d97fc49826d0063c9db0a71602d3283/src%2Ftest%2Fui%2Fconsts%2Fqualif-indirect-mutation-pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/93f85f5a9d97fc49826d0063c9db0a71602d3283/src%2Ftest%2Fui%2Fconsts%2Fqualif-indirect-mutation-pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fqualif-indirect-mutation-pass.rs?ref=93f85f5a9d97fc49826d0063c9db0a71602d3283", "patch": "@@ -0,0 +1,16 @@\n+// compile-flags: --crate-type=lib\n+// check-pass\n+#![feature(const_mut_refs)]\n+#![feature(const_precise_live_drops)]\n+\n+pub const fn f() {\n+    let mut x: (Option<String>, u32) = (None, 0);\n+    let mut a = 10;\n+    *(&mut a) = 11;\n+    x.1 = a;\n+}\n+\n+pub const fn g() {\n+    let mut a: (u32, Option<String>) = (0, None);\n+    let _ = &mut a.0;\n+}"}]}