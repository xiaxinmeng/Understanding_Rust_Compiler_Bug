{"sha": "4f030d04f499f650e54ef947799fe6cef20fb380", "node_id": "MDY6Q29tbWl0NzI0NzEyOjRmMDMwZDA0ZjQ5OWY2NTBlNTRlZjk0Nzc5OWZlNmNlZjIwZmIzODA=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2017-07-10T21:10:30Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2017-07-12T10:56:54Z"}, "message": "integrate anon dep nodes into trait selection", "tree": {"sha": "9472646135e04ac73642f561c192ef2f235879c6", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9472646135e04ac73642f561c192ef2f235879c6"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4f030d04f499f650e54ef947799fe6cef20fb380", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4f030d04f499f650e54ef947799fe6cef20fb380", "html_url": "https://github.com/rust-lang/rust/commit/4f030d04f499f650e54ef947799fe6cef20fb380", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4f030d04f499f650e54ef947799fe6cef20fb380/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8ac29bdd110b7f09b6ca6c0a1917d81285d64b3a", "url": "https://api.github.com/repos/rust-lang/rust/commits/8ac29bdd110b7f09b6ca6c0a1917d81285d64b3a", "html_url": "https://github.com/rust-lang/rust/commit/8ac29bdd110b7f09b6ca6c0a1917d81285d64b3a"}], "stats": {"total": 203, "additions": 83, "deletions": 120}, "files": [{"sha": "8e2c44a427b7099da78d94f6db0ee79b221604c3", "filename": "src/librustc/dep_graph/dep_node.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4f030d04f499f650e54ef947799fe6cef20fb380/src%2Flibrustc%2Fdep_graph%2Fdep_node.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f030d04f499f650e54ef947799fe6cef20fb380/src%2Flibrustc%2Fdep_graph%2Fdep_node.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdep_graph%2Fdep_node.rs?ref=4f030d04f499f650e54ef947799fe6cef20fb380", "patch": "@@ -495,7 +495,7 @@ define_dep_nodes!( <'tcx>\n     // imprecision in our dep-graph tracking.  The important thing is\n     // that for any given trait-ref, we always map to the **same**\n     // trait-select node.\n-    [] TraitSelect { trait_def_id: DefId, input_def_id: DefId },\n+    [anon] TraitSelect,\n \n     // For proj. cache, we just keep a list of all def-ids, since it is\n     // not a hotspot."}, {"sha": "2d19b34c5040ef01124506fd282bbdfd9cf7d336", "filename": "src/librustc/dep_graph/dep_tracking_map.rs", "status": "modified", "additions": 9, "deletions": 31, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/4f030d04f499f650e54ef947799fe6cef20fb380/src%2Flibrustc%2Fdep_graph%2Fdep_tracking_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f030d04f499f650e54ef947799fe6cef20fb380/src%2Flibrustc%2Fdep_graph%2Fdep_tracking_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdep_graph%2Fdep_tracking_map.rs?ref=4f030d04f499f650e54ef947799fe6cef20fb380", "patch": "@@ -12,24 +12,23 @@ use rustc_data_structures::fx::FxHashMap;\n use std::cell::RefCell;\n use std::hash::Hash;\n use std::marker::PhantomData;\n-use ty::TyCtxt;\n use util::common::MemoizationMap;\n \n-use super::{DepNode, DepGraph};\n+use super::{DepKind, DepNodeIndex, DepGraph};\n \n /// A DepTrackingMap offers a subset of the `Map` API and ensures that\n /// we make calls to `read` and `write` as appropriate. We key the\n /// maps with a unique type for brevity.\n pub struct DepTrackingMap<M: DepTrackingMapConfig> {\n     phantom: PhantomData<M>,\n     graph: DepGraph,\n-    map: FxHashMap<M::Key, M::Value>,\n+    map: FxHashMap<M::Key, (M::Value, DepNodeIndex)>,\n }\n \n pub trait DepTrackingMapConfig {\n     type Key: Eq + Hash + Clone;\n     type Value: Clone;\n-    fn to_dep_node(tcx: TyCtxt, key: &Self::Key) -> DepNode;\n+    fn to_dep_kind() -> DepKind;\n }\n \n impl<M: DepTrackingMapConfig> DepTrackingMap<M> {\n@@ -40,27 +39,6 @@ impl<M: DepTrackingMapConfig> DepTrackingMap<M> {\n             map: FxHashMap(),\n         }\n     }\n-\n-    /// Registers a (synthetic) read from the key `k`. Usually this\n-    /// is invoked automatically by `get`.\n-    fn read(&self, tcx: TyCtxt, k: &M::Key) {\n-        let dep_node = M::to_dep_node(tcx, k);\n-        self.graph.read(dep_node);\n-    }\n-\n-    pub fn get(&self, tcx: TyCtxt, k: &M::Key) -> Option<&M::Value> {\n-        self.read(tcx, k);\n-        self.map.get(k)\n-    }\n-\n-    pub fn contains_key(&self, tcx: TyCtxt, k: &M::Key) -> bool {\n-        self.read(tcx, k);\n-        self.map.contains_key(k)\n-    }\n-\n-    pub fn keys(&self) -> Vec<M::Key> {\n-        self.map.keys().cloned().collect()\n-    }\n }\n \n impl<M: DepTrackingMapConfig> MemoizationMap for RefCell<DepTrackingMap<M>> {\n@@ -98,22 +76,22 @@ impl<M: DepTrackingMapConfig> MemoizationMap for RefCell<DepTrackingMap<M>> {\n     /// The key is the line marked `(*)`: the closure implicitly\n     /// accesses the body of the item `item`, so we register a read\n     /// from `Hir(item_def_id)`.\n-    fn memoize<OP>(&self, tcx: TyCtxt, key: M::Key, op: OP) -> M::Value\n+    fn memoize<OP>(&self, key: M::Key, op: OP) -> M::Value\n         where OP: FnOnce() -> M::Value\n     {\n         let graph;\n         {\n             let this = self.borrow();\n-            if let Some(result) = this.map.get(&key) {\n-                this.read(tcx, &key);\n+            if let Some(&(ref result, dep_node)) = this.map.get(&key) {\n+                this.graph.read_index(dep_node);\n                 return result.clone();\n             }\n             graph = this.graph.clone();\n         }\n \n-        let _task = graph.in_task(M::to_dep_node(tcx, &key));\n-        let result = op();\n-        self.borrow_mut().map.insert(key, result.clone());\n+        let (result, dep_node) = graph.with_anon_task(M::to_dep_kind(), op);\n+        self.borrow_mut().map.insert(key, (result.clone(), dep_node));\n+        graph.read_index(dep_node);\n         result\n     }\n }"}, {"sha": "c690bebed8c00f09404b1780fd688d53b62b6425", "filename": "src/librustc/traits/select.rs", "status": "modified", "additions": 64, "deletions": 24, "changes": 88, "blob_url": "https://github.com/rust-lang/rust/blob/4f030d04f499f650e54ef947799fe6cef20fb380/src%2Flibrustc%2Ftraits%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f030d04f499f650e54ef947799fe6cef20fb380/src%2Flibrustc%2Ftraits%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fselect.rs?ref=4f030d04f499f650e54ef947799fe6cef20fb380", "patch": "@@ -30,6 +30,7 @@ use super::{VtableImplData, VtableObjectData, VtableBuiltinData,\n             VtableClosureData, VtableDefaultImplData, VtableFnPointerData};\n use super::util;\n \n+use dep_graph::{DepNodeIndex, DepKind};\n use hir::def_id::DefId;\n use infer;\n use infer::{InferCtxt, InferOk, TypeFreshener};\n@@ -105,7 +106,7 @@ struct TraitObligationStack<'prev, 'tcx: 'prev> {\n #[derive(Clone)]\n pub struct SelectionCache<'tcx> {\n     hashmap: RefCell<FxHashMap<ty::TraitRef<'tcx>,\n-                               SelectionResult<'tcx, SelectionCandidate<'tcx>>>>,\n+                               WithDepNode<SelectionResult<'tcx, SelectionCandidate<'tcx>>>>>,\n }\n \n /// The selection process begins by considering all impls, where\n@@ -369,7 +370,7 @@ impl EvaluationResult {\n \n #[derive(Clone)]\n pub struct EvaluationCache<'tcx> {\n-    hashmap: RefCell<FxHashMap<ty::PolyTraitRef<'tcx>, EvaluationResult>>\n+    hashmap: RefCell<FxHashMap<ty::PolyTraitRef<'tcx>, WithDepNode<EvaluationResult>>>\n }\n \n impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n@@ -466,8 +467,6 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n         assert!(!obligation.predicate.has_escaping_regions());\n \n         let tcx = self.tcx();\n-        let dep_node = obligation.predicate.dep_node(tcx);\n-        let _task = tcx.dep_graph.in_task(dep_node);\n \n         let stack = self.push_stack(TraitObligationStackList::empty(), obligation);\n         let ret = match self.candidate_from_obligation(&stack)? {\n@@ -710,12 +709,12 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n             return result;\n         }\n \n-        let result = self.evaluate_stack(&stack);\n+        let (result, dep_node) = self.in_task(|this| this.evaluate_stack(&stack));\n \n         debug!(\"CACHE MISS: EVAL({:?})={:?}\",\n                fresh_trait_ref,\n                result);\n-        self.insert_evaluation_cache(obligation.param_env, fresh_trait_ref, result);\n+        self.insert_evaluation_cache(obligation.param_env, fresh_trait_ref, dep_node, result);\n \n         result\n     }\n@@ -870,22 +869,23 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n                               trait_ref: ty::PolyTraitRef<'tcx>)\n                               -> Option<EvaluationResult>\n     {\n+        let tcx = self.tcx();\n         if self.can_use_global_caches(param_env) {\n-            let cache = self.tcx().evaluation_cache.hashmap.borrow();\n+            let cache = tcx.evaluation_cache.hashmap.borrow();\n             if let Some(cached) = cache.get(&trait_ref) {\n-                let dep_node = trait_ref\n-                    .to_poly_trait_predicate()\n-                    .dep_node(self.tcx());\n-                self.tcx().hir.dep_graph.read(dep_node);\n-                return Some(cached.clone());\n+                return Some(cached.get(tcx));\n             }\n         }\n-        self.infcx.evaluation_cache.hashmap.borrow().get(&trait_ref).cloned()\n+        self.infcx.evaluation_cache.hashmap\n+                                   .borrow()\n+                                   .get(&trait_ref)\n+                                   .map(|v| v.get(tcx))\n     }\n \n     fn insert_evaluation_cache(&mut self,\n                                param_env: ty::ParamEnv<'tcx>,\n                                trait_ref: ty::PolyTraitRef<'tcx>,\n+                               dep_node: DepNodeIndex,\n                                result: EvaluationResult)\n     {\n         // Avoid caching results that depend on more than just the trait-ref:\n@@ -902,12 +902,14 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n         if self.can_use_global_caches(param_env) {\n             let mut cache = self.tcx().evaluation_cache.hashmap.borrow_mut();\n             if let Some(trait_ref) = self.tcx().lift_to_global(&trait_ref) {\n-                cache.insert(trait_ref, result);\n+                cache.insert(trait_ref, WithDepNode::new(dep_node, result));\n                 return;\n             }\n         }\n \n-        self.infcx.evaluation_cache.hashmap.borrow_mut().insert(trait_ref, result);\n+        self.infcx.evaluation_cache.hashmap\n+                                   .borrow_mut()\n+                                   .insert(trait_ref, WithDepNode::new(dep_node, result));\n     }\n \n     ///////////////////////////////////////////////////////////////////////////\n@@ -949,19 +951,32 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n         }\n \n         // If no match, compute result and insert into cache.\n-        let candidate = self.candidate_from_obligation_no_cache(stack);\n+        let (candidate, dep_node) = self.in_task(|this| {\n+            this.candidate_from_obligation_no_cache(stack)\n+        });\n \n         if self.should_update_candidate_cache(&cache_fresh_trait_pred, &candidate) {\n             debug!(\"CACHE MISS: SELECT({:?})={:?}\",\n                    cache_fresh_trait_pred, candidate);\n             self.insert_candidate_cache(stack.obligation.param_env,\n                                         cache_fresh_trait_pred,\n+                                        dep_node,\n                                         candidate.clone());\n         }\n \n         candidate\n     }\n \n+    fn in_task<OP, R>(&mut self, op: OP) -> (R, DepNodeIndex)\n+        where OP: FnOnce(&mut Self) -> R\n+    {\n+        let (result, dep_node) = self.tcx().dep_graph.with_anon_task(DepKind::TraitSelect, || {\n+            op(self)\n+        });\n+        self.tcx().dep_graph.read_index(dep_node);\n+        (result, dep_node)\n+    }\n+\n     // Treat negative impls as unimplemented\n     fn filter_negative_impls(&self, candidate: SelectionCandidate<'tcx>)\n                              -> SelectionResult<'tcx, SelectionCandidate<'tcx>> {\n@@ -1151,33 +1166,41 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n                              cache_fresh_trait_pred: &ty::PolyTraitPredicate<'tcx>)\n                              -> Option<SelectionResult<'tcx, SelectionCandidate<'tcx>>>\n     {\n+        let tcx = self.tcx();\n         let trait_ref = &cache_fresh_trait_pred.0.trait_ref;\n         if self.can_use_global_caches(param_env) {\n-            let cache = self.tcx().selection_cache.hashmap.borrow();\n+            let cache = tcx.selection_cache.hashmap.borrow();\n             if let Some(cached) = cache.get(&trait_ref) {\n-                return Some(cached.clone());\n+                return Some(cached.get(tcx));\n             }\n         }\n-        self.infcx.selection_cache.hashmap.borrow().get(trait_ref).cloned()\n+        self.infcx.selection_cache.hashmap\n+                                  .borrow()\n+                                  .get(trait_ref)\n+                                  .map(|v| v.get(tcx))\n     }\n \n     fn insert_candidate_cache(&mut self,\n                               param_env: ty::ParamEnv<'tcx>,\n                               cache_fresh_trait_pred: ty::PolyTraitPredicate<'tcx>,\n+                              dep_node: DepNodeIndex,\n                               candidate: SelectionResult<'tcx, SelectionCandidate<'tcx>>)\n     {\n+        let tcx = self.tcx();\n         let trait_ref = cache_fresh_trait_pred.0.trait_ref;\n         if self.can_use_global_caches(param_env) {\n-            let mut cache = self.tcx().selection_cache.hashmap.borrow_mut();\n-            if let Some(trait_ref) = self.tcx().lift_to_global(&trait_ref) {\n-                if let Some(candidate) = self.tcx().lift_to_global(&candidate) {\n-                    cache.insert(trait_ref, candidate);\n+            let mut cache = tcx.selection_cache.hashmap.borrow_mut();\n+            if let Some(trait_ref) = tcx.lift_to_global(&trait_ref) {\n+                if let Some(candidate) = tcx.lift_to_global(&candidate) {\n+                    cache.insert(trait_ref, WithDepNode::new(dep_node, candidate));\n                     return;\n                 }\n             }\n         }\n \n-        self.infcx.selection_cache.hashmap.borrow_mut().insert(trait_ref, candidate);\n+        self.infcx.selection_cache.hashmap\n+                                  .borrow_mut()\n+                                  .insert(trait_ref, WithDepNode::new(dep_node, candidate));\n     }\n \n     fn should_update_candidate_cache(&mut self,\n@@ -3138,3 +3161,20 @@ impl<'o,'tcx> fmt::Debug for TraitObligationStack<'o,'tcx> {\n         write!(f, \"TraitObligationStack({:?})\", self.obligation)\n     }\n }\n+\n+#[derive(Clone)]\n+pub struct WithDepNode<T> {\n+    dep_node: DepNodeIndex,\n+    cached_value: T\n+}\n+\n+impl<T: Clone> WithDepNode<T> {\n+    pub fn new(dep_node: DepNodeIndex, cached_value: T) -> Self {\n+        WithDepNode { dep_node, cached_value }\n+    }\n+\n+    pub fn get(&self, tcx: TyCtxt) -> T {\n+        tcx.dep_graph.read_index(self.dep_node);\n+        self.cached_value.clone()\n+    }\n+}"}, {"sha": "827a5092c00420e6a5c47355e2caad3b7d3fbd9d", "filename": "src/librustc/traits/trans/mod.rs", "status": "modified", "additions": 7, "deletions": 32, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/4f030d04f499f650e54ef947799fe6cef20fb380/src%2Flibrustc%2Ftraits%2Ftrans%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f030d04f499f650e54ef947799fe6cef20fb380/src%2Flibrustc%2Ftraits%2Ftrans%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Ftrans%2Fmod.rs?ref=4f030d04f499f650e54ef947799fe6cef20fb380", "patch": "@@ -13,9 +13,7 @@\n // seems likely that they should eventually be merged into more\n // general routines.\n \n-use dep_graph::{DepGraph, DepNode, DepTrackingMap, DepTrackingMapConfig,\n-                DepConstructor};\n-use hir::def_id::DefId;\n+use dep_graph::{DepGraph, DepKind, DepTrackingMap, DepTrackingMapConfig};\n use infer::TransNormalize;\n use std::cell::RefCell;\n use std::marker::PhantomData;\n@@ -41,7 +39,7 @@ impl<'a, 'tcx> TyCtxt<'a, 'tcx, 'tcx> {\n         // Remove any references to regions; this helps improve caching.\n         let trait_ref = self.erase_regions(&trait_ref);\n \n-        self.trans_trait_caches.trait_cache.memoize(self, trait_ref, || {\n+        self.trans_trait_caches.trait_cache.memoize(trait_ref, || {\n             debug!(\"trans::fulfill_obligation(trait_ref={:?}, def_id={:?})\",\n                    trait_ref, trait_ref.def_id());\n \n@@ -139,7 +137,7 @@ impl<'a, 'gcx> TypeFolder<'gcx, 'gcx> for AssociatedTypeNormalizer<'a, 'gcx> {\n         if !ty.has_projection_types() {\n             ty\n         } else {\n-            self.tcx.trans_trait_caches.project_cache.memoize(self.tcx, ty, || {\n+            self.tcx.trans_trait_caches.project_cache.memoize(ty, || {\n                 debug!(\"AssociatedTypeNormalizer: ty={:?}\", ty);\n                 self.tcx.normalize_associated_type(&ty)\n             })\n@@ -171,8 +169,8 @@ pub struct TraitSelectionCache<'tcx> {\n impl<'tcx> DepTrackingMapConfig for TraitSelectionCache<'tcx> {\n     type Key = ty::PolyTraitRef<'tcx>;\n     type Value = Vtable<'tcx, ()>;\n-    fn to_dep_node(tcx: TyCtxt, key: &ty::PolyTraitRef<'tcx>) -> DepNode {\n-        key.to_poly_trait_predicate().dep_node(tcx)\n+    fn to_dep_kind() -> DepKind {\n+        DepKind::TraitSelect\n     }\n }\n \n@@ -185,31 +183,8 @@ pub struct ProjectionCache<'gcx> {\n impl<'gcx> DepTrackingMapConfig for ProjectionCache<'gcx> {\n     type Key = Ty<'gcx>;\n     type Value = Ty<'gcx>;\n-    fn to_dep_node(tcx: TyCtxt, key: &Self::Key) -> DepNode {\n-        // Ideally, we'd just put `key` into the dep-node, but we\n-        // can't put full types in there. So just collect up all the\n-        // def-ids of structs/enums as well as any traits that we\n-        // project out of. It doesn't matter so much what we do here,\n-        // except that if we are too coarse, we'll create overly\n-        // coarse edges between impls and the trans. For example, if\n-        // we just used the def-id of things we are projecting out of,\n-        // then the key for `<Foo as SomeTrait>::T` and `<Bar as\n-        // SomeTrait>::T` would both share a dep-node\n-        // (`TraitSelect(SomeTrait)`), and hence the impls for both\n-        // `Foo` and `Bar` would be considered inputs. So a change to\n-        // `Bar` would affect things that just normalized `Foo`.\n-        // Anyway, this heuristic is not ideal, but better than\n-        // nothing.\n-        let def_ids: Vec<DefId> =\n-            key.walk()\n-               .filter_map(|t| match t.sty {\n-                    ty::TyAdt(adt_def, _) => Some(adt_def.did),\n-                    ty::TyProjection(ref proj) => Some(proj.item_def_id),\n-                    _ => None,\n-               })\n-               .collect();\n-\n-        DepNode::new(tcx, DepConstructor::ProjectionCache { def_ids: def_ids })\n+    fn to_dep_kind() -> DepKind {\n+        DepKind::TraitSelect\n     }\n }\n "}, {"sha": "5aaba526e265f8a40b5494f0a49cb7dc592de58d", "filename": "src/librustc/ty/mod.rs", "status": "modified", "additions": 0, "deletions": 28, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/4f030d04f499f650e54ef947799fe6cef20fb380/src%2Flibrustc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f030d04f499f650e54ef947799fe6cef20fb380/src%2Flibrustc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmod.rs?ref=4f030d04f499f650e54ef947799fe6cef20fb380", "patch": "@@ -15,7 +15,6 @@ pub use self::IntVarValue::*;\n pub use self::LvaluePreference::*;\n pub use self::fold::TypeFoldable;\n \n-use dep_graph::{DepNode, DepConstructor};\n use hir::{map as hir_map, FreevarMap, TraitMap};\n use hir::def::{Def, CtorKind, ExportMap};\n use hir::def_id::{CrateNum, DefId, DefIndex, CRATE_DEF_INDEX, LOCAL_CRATE};\n@@ -947,28 +946,6 @@ impl<'tcx> TraitPredicate<'tcx> {\n         self.trait_ref.def_id\n     }\n \n-    /// Creates the dep-node for selecting/evaluating this trait reference.\n-    fn dep_node(&self, tcx: TyCtxt) -> DepNode {\n-        // Extact the trait-def and first def-id from inputs.  See the\n-        // docs for `DepNode::TraitSelect` for more information.\n-        let trait_def_id = self.def_id();\n-        let input_def_id =\n-            self.input_types()\n-                .flat_map(|t| t.walk())\n-                .filter_map(|t| match t.sty {\n-                    ty::TyAdt(adt_def, ..) => Some(adt_def.did),\n-                    ty::TyClosure(def_id, ..) => Some(def_id),\n-                    ty::TyFnDef(def_id, ..) => Some(def_id),\n-                    _ => None\n-                })\n-                .next()\n-                .unwrap_or(trait_def_id);\n-        DepNode::new(tcx, DepConstructor::TraitSelect {\n-            trait_def_id,\n-            input_def_id,\n-        })\n-    }\n-\n     pub fn input_types<'a>(&'a self) -> impl DoubleEndedIterator<Item=Ty<'tcx>> + 'a {\n         self.trait_ref.input_types()\n     }\n@@ -983,11 +960,6 @@ impl<'tcx> PolyTraitPredicate<'tcx> {\n         // ok to skip binder since trait def-id does not care about regions\n         self.0.def_id()\n     }\n-\n-    pub fn dep_node(&self, tcx: TyCtxt) -> DepNode {\n-        // ok to skip binder since depnode does not care about regions\n-        self.0.dep_node(tcx)\n-    }\n }\n \n #[derive(Clone, Copy, PartialEq, Eq, Hash, Debug, RustcEncodable, RustcDecodable)]"}, {"sha": "17564671a1e364f45eed26442e33e6b9e8231b06", "filename": "src/librustc/util/common.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/4f030d04f499f650e54ef947799fe6cef20fb380/src%2Flibrustc%2Futil%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f030d04f499f650e54ef947799fe6cef20fb380/src%2Flibrustc%2Futil%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fcommon.rs?ref=4f030d04f499f650e54ef947799fe6cef20fb380", "patch": "@@ -19,8 +19,6 @@ use std::iter::repeat;\n use std::path::Path;\n use std::time::{Duration, Instant};\n \n-use ty::TyCtxt;\n-\n // The name of the associated type for `Fn` return types\n pub const FN_OUTPUT_NAME: &'static str = \"Output\";\n \n@@ -211,7 +209,7 @@ pub trait MemoizationMap {\n     /// needed in the `op` to ensure that the correct edges are\n     /// added into the dep graph. See the `DepTrackingMap` impl for\n     /// more details!\n-    fn memoize<OP>(&self, tcx: TyCtxt, key: Self::Key, op: OP) -> Self::Value\n+    fn memoize<OP>(&self, key: Self::Key, op: OP) -> Self::Value\n         where OP: FnOnce() -> Self::Value;\n }\n \n@@ -221,7 +219,7 @@ impl<K, V, S> MemoizationMap for RefCell<HashMap<K,V,S>>\n     type Key = K;\n     type Value = V;\n \n-    fn memoize<OP>(&self, _tcx: TyCtxt, key: K, op: OP) -> V\n+    fn memoize<OP>(&self, key: K, op: OP) -> V\n         where OP: FnOnce() -> V\n     {\n         let result = self.borrow().get(&key).cloned();"}]}