{"sha": "c8a69e2567c714b870bbb7b2135153a3017c990c", "node_id": "MDY6Q29tbWl0NzI0NzEyOmM4YTY5ZTI1NjdjNzE0Yjg3MGJiYjdiMjEzNTE1M2EzMDE3Yzk5MGM=", "commit": {"author": {"name": "Hristo Venev", "email": "hristo@venev.name", "date": "2019-08-26T13:14:30Z"}, "committer": {"name": "Hristo Venev", "email": "hristo@venev.name", "date": "2019-08-26T13:16:28Z"}, "message": "ty: use Align for ReprOptions pack and align.", "tree": {"sha": "1b464ffbeae5dbd6dc391b14fc7227910da3bb9b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1b464ffbeae5dbd6dc391b14fc7227910da3bb9b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c8a69e2567c714b870bbb7b2135153a3017c990c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c8a69e2567c714b870bbb7b2135153a3017c990c", "html_url": "https://github.com/rust-lang/rust/commit/c8a69e2567c714b870bbb7b2135153a3017c990c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c8a69e2567c714b870bbb7b2135153a3017c990c/comments", "author": {"login": "hvenev", "id": 1391845, "node_id": "MDQ6VXNlcjEzOTE4NDU=", "avatar_url": "https://avatars.githubusercontent.com/u/1391845?v=4", "gravatar_id": "", "url": "https://api.github.com/users/hvenev", "html_url": "https://github.com/hvenev", "followers_url": "https://api.github.com/users/hvenev/followers", "following_url": "https://api.github.com/users/hvenev/following{/other_user}", "gists_url": "https://api.github.com/users/hvenev/gists{/gist_id}", "starred_url": "https://api.github.com/users/hvenev/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/hvenev/subscriptions", "organizations_url": "https://api.github.com/users/hvenev/orgs", "repos_url": "https://api.github.com/users/hvenev/repos", "events_url": "https://api.github.com/users/hvenev/events{/privacy}", "received_events_url": "https://api.github.com/users/hvenev/received_events", "type": "User", "site_admin": false}, "committer": {"login": "hvenev", "id": 1391845, "node_id": "MDQ6VXNlcjEzOTE4NDU=", "avatar_url": "https://avatars.githubusercontent.com/u/1391845?v=4", "gravatar_id": "", "url": "https://api.github.com/users/hvenev", "html_url": "https://github.com/hvenev", "followers_url": "https://api.github.com/users/hvenev/followers", "following_url": "https://api.github.com/users/hvenev/following{/other_user}", "gists_url": "https://api.github.com/users/hvenev/gists{/gist_id}", "starred_url": "https://api.github.com/users/hvenev/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/hvenev/subscriptions", "organizations_url": "https://api.github.com/users/hvenev/orgs", "repos_url": "https://api.github.com/users/hvenev/repos", "events_url": "https://api.github.com/users/hvenev/events{/privacy}", "received_events_url": "https://api.github.com/users/hvenev/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "555d7a2fd6165b614cfc01136d8e3f5c465a1582", "url": "https://api.github.com/repos/rust-lang/rust/commits/555d7a2fd6165b614cfc01136d8e3f5c465a1582", "html_url": "https://github.com/rust-lang/rust/commit/555d7a2fd6165b614cfc01136d8e3f5c465a1582"}], "stats": {"total": 91, "additions": 45, "deletions": 46}, "files": [{"sha": "5ec4754c4535bc54019426bea5cef721428e9c52", "filename": "src/librustc/ty/layout.rs", "status": "modified", "additions": 19, "deletions": 30, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/c8a69e2567c714b870bbb7b2135153a3017c990c/src%2Flibrustc%2Fty%2Flayout.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8a69e2567c714b870bbb7b2135153a3017c990c/src%2Flibrustc%2Fty%2Flayout.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Flayout.rs?ref=c8a69e2567c714b870bbb7b2135153a3017c990c", "patch": "@@ -273,14 +273,12 @@ impl<'tcx> LayoutCx<'tcx, TyCtxt<'tcx>> {\n                              repr: &ReprOptions,\n                              kind: StructKind) -> Result<LayoutDetails, LayoutError<'tcx>> {\n         let dl = self.data_layout();\n-        let packed = repr.packed();\n-        if packed && repr.align > 0 {\n+        let pack = repr.pack;\n+        if pack.is_some() && repr.align.is_some() {\n             bug!(\"struct cannot be packed and aligned\");\n         }\n \n-        let pack = Align::from_bytes(repr.pack as u64).unwrap();\n-\n-        let mut align = if packed {\n+        let mut align = if pack.is_some() {\n             dl.i8_align\n         } else {\n             dl.aggregate_align\n@@ -303,7 +301,7 @@ impl<'tcx> LayoutCx<'tcx, TyCtxt<'tcx>> {\n             };\n             let optimizing = &mut inverse_memory_index[..end];\n             let field_align = |f: &TyLayout<'_>| {\n-                if packed { f.align.abi.min(pack) } else { f.align.abi }\n+                if let Some(pack) = pack { f.align.abi.min(pack) } else { f.align.abi }\n             };\n             match kind {\n                 StructKind::AlwaysSized |\n@@ -334,7 +332,7 @@ impl<'tcx> LayoutCx<'tcx, TyCtxt<'tcx>> {\n         let mut largest_niche_available = 0;\n \n         if let StructKind::Prefixed(prefix_size, prefix_align) = kind {\n-            let prefix_align = if packed {\n+            let prefix_align = if let Some(pack) = pack {\n                 prefix_align.min(pack)\n             } else {\n                 prefix_align\n@@ -355,7 +353,7 @@ impl<'tcx> LayoutCx<'tcx, TyCtxt<'tcx>> {\n             }\n \n             // Invariant: offset < dl.obj_size_bound() <= 1<<61\n-            let field_align = if packed {\n+            let field_align = if let Some(pack) = pack {\n                 field.align.min(AbiAndPrefAlign::new(pack))\n             } else {\n                 field.align\n@@ -379,10 +377,8 @@ impl<'tcx> LayoutCx<'tcx, TyCtxt<'tcx>> {\n                 .ok_or(LayoutError::SizeOverflow(ty))?;\n         }\n \n-        if repr.align > 0 {\n-            let repr_align = repr.align as u64;\n-            align = align.max(AbiAndPrefAlign::new(Align::from_bytes(repr_align).unwrap()));\n-            debug!(\"univariant repr_align: {:?}\", repr_align);\n+        if let Some(repr_align) = repr.align {\n+            align = align.max(AbiAndPrefAlign::new(repr_align));\n         }\n \n         debug!(\"univariant min_size: {:?}\", offset);\n@@ -730,23 +726,18 @@ impl<'tcx> LayoutCx<'tcx, TyCtxt<'tcx>> {\n                 }).collect::<Result<IndexVec<VariantIdx, _>, _>>()?;\n \n                 if def.is_union() {\n-                    let packed = def.repr.packed();\n-                    if packed && def.repr.align > 0 {\n-                        bug!(\"Union cannot be packed and aligned\");\n+                    if def.repr.pack.is_some() && def.repr.align.is_some() {\n+                        bug!(\"union cannot be packed and aligned\");\n                     }\n \n-                    let pack = Align::from_bytes(def.repr.pack as u64).unwrap();\n-\n-                    let mut align = if packed {\n+                    let mut align = if def.repr.pack.is_some() {\n                         dl.i8_align\n                     } else {\n                         dl.aggregate_align\n                     };\n \n-                    if def.repr.align > 0 {\n-                        let repr_align = def.repr.align as u64;\n-                        align = align.max(\n-                            AbiAndPrefAlign::new(Align::from_bytes(repr_align).unwrap()));\n+                    if let Some(repr_align) = def.repr.align {\n+                        align = align.max(AbiAndPrefAlign::new(repr_align));\n                     }\n \n                     let optimize = !def.repr.inhibit_union_abi_opt();\n@@ -755,13 +746,7 @@ impl<'tcx> LayoutCx<'tcx, TyCtxt<'tcx>> {\n                     let index = VariantIdx::new(0);\n                     for field in &variants[index] {\n                         assert!(!field.is_unsized());\n-\n-                        let field_align = if packed {\n-                            field.align.min(AbiAndPrefAlign::new(pack))\n-                        } else {\n-                            field.align\n-                        };\n-                        align = align.max(field_align);\n+                        align = align.max(field.align);\n \n                         // If all non-ZST fields have the same ABI, forward this ABI\n                         if optimize && !field.is_zst() {\n@@ -796,6 +781,10 @@ impl<'tcx> LayoutCx<'tcx, TyCtxt<'tcx>> {\n                         size = cmp::max(size, field.size);\n                     }\n \n+                    if let Some(pack) = def.repr.pack {\n+                        align = align.min(AbiAndPrefAlign::new(pack));\n+                    }\n+\n                     return Ok(tcx.intern_layout(LayoutDetails {\n                         variants: Variants::Single { index },\n                         fields: FieldPlacement::Union(variants[index].len()),\n@@ -1637,7 +1626,7 @@ impl<'tcx> LayoutCx<'tcx, TyCtxt<'tcx>> {\n         };\n \n         let adt_kind = adt_def.adt_kind();\n-        let adt_packed = adt_def.repr.packed();\n+        let adt_packed = adt_def.repr.pack.is_some();\n \n         let build_variant_info = |n: Option<Ident>,\n                                   flds: &[ast::Name],"}, {"sha": "bafd65673e613dea77ce7a99d86f4903f9e223d7", "filename": "src/librustc/ty/mod.rs", "status": "modified", "additions": 17, "deletions": 11, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/c8a69e2567c714b870bbb7b2135153a3017c990c/src%2Flibrustc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8a69e2567c714b870bbb7b2135153a3017c990c/src%2Flibrustc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmod.rs?ref=c8a69e2567c714b870bbb7b2135153a3017c990c", "patch": "@@ -33,6 +33,7 @@ use arena::SyncDroplessArena;\n use crate::session::DataTypeKind;\n \n use rustc_serialize::{self, Encodable, Encoder};\n+use rustc_target::abi::Align;\n use std::cell::RefCell;\n use std::cmp::{self, Ordering};\n use std::fmt;\n@@ -2057,8 +2058,8 @@ impl_stable_hash_for!(struct ReprFlags {\n #[derive(Copy, Clone, Debug, Eq, PartialEq, RustcEncodable, RustcDecodable, Default)]\n pub struct ReprOptions {\n     pub int: Option<attr::IntType>,\n-    pub align: u32,\n-    pub pack: u32,\n+    pub align: Option<Align>,\n+    pub pack: Option<Align>,\n     pub flags: ReprFlags,\n }\n \n@@ -2073,18 +2074,19 @@ impl ReprOptions {\n     pub fn new(tcx: TyCtxt<'_>, did: DefId) -> ReprOptions {\n         let mut flags = ReprFlags::empty();\n         let mut size = None;\n-        let mut max_align = 0;\n-        let mut min_pack = 0;\n+        let mut max_align: Option<Align> = None;\n+        let mut min_pack: Option<Align> = None;\n         for attr in tcx.get_attrs(did).iter() {\n             for r in attr::find_repr_attrs(&tcx.sess.parse_sess, attr) {\n                 flags.insert(match r {\n                     attr::ReprC => ReprFlags::IS_C,\n                     attr::ReprPacked(pack) => {\n-                        min_pack = if min_pack > 0 {\n-                            cmp::min(pack, min_pack)\n+                        let pack = Align::from_bytes(pack as u64).unwrap();\n+                        min_pack = Some(if let Some(min_pack) = min_pack {\n+                            min_pack.min(pack)\n                         } else {\n                             pack\n-                        };\n+                        });\n                         ReprFlags::empty()\n                     },\n                     attr::ReprTransparent => ReprFlags::IS_TRANSPARENT,\n@@ -2094,7 +2096,7 @@ impl ReprOptions {\n                         ReprFlags::empty()\n                     },\n                     attr::ReprAlign(align) => {\n-                        max_align = cmp::max(align, max_align);\n+                        max_align = max_align.max(Some(Align::from_bytes(align as u64).unwrap()));\n                         ReprFlags::empty()\n                     },\n                 });\n@@ -2113,7 +2115,7 @@ impl ReprOptions {\n     #[inline]\n     pub fn c(&self) -> bool { self.flags.contains(ReprFlags::IS_C) }\n     #[inline]\n-    pub fn packed(&self) -> bool { self.pack > 0 }\n+    pub fn packed(&self) -> bool { self.pack.is_some() }\n     #[inline]\n     pub fn transparent(&self) -> bool { self.flags.contains(ReprFlags::IS_TRANSPARENT) }\n     #[inline]\n@@ -2133,8 +2135,12 @@ impl ReprOptions {\n     /// Returns `true` if this `#[repr()]` should inhibit struct field reordering\n     /// optimizations, such as with `repr(C)`, `repr(packed(1))`, or `repr(<int>)`.\n     pub fn inhibit_struct_field_reordering_opt(&self) -> bool {\n-        self.flags.intersects(ReprFlags::IS_UNOPTIMISABLE) || self.pack == 1 ||\n-            self.int.is_some()\n+        if let Some(pack) = self.pack {\n+            if pack.bytes() == 1 {\n+                return true;\n+            }\n+        }\n+        self.flags.intersects(ReprFlags::IS_UNOPTIMISABLE) || self.int.is_some()\n     }\n \n     /// Returns `true` if this `#[repr()]` should inhibit union ABI optimisations."}, {"sha": "fa5414fc22b08775bc9b4c51e1e667f277f97498", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 9, "deletions": 5, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/c8a69e2567c714b870bbb7b2135153a3017c990c/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8a69e2567c714b870bbb7b2135153a3017c990c/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=c8a69e2567c714b870bbb7b2135153a3017c990c", "patch": "@@ -1859,14 +1859,18 @@ fn check_packed(tcx: TyCtxt<'_>, sp: Span, def_id: DefId) {\n         for attr in tcx.get_attrs(def_id).iter() {\n             for r in attr::find_repr_attrs(&tcx.sess.parse_sess, attr) {\n                 if let attr::ReprPacked(pack) = r {\n-                    if pack != repr.pack {\n-                        struct_span_err!(tcx.sess, sp, E0634,\n-                                         \"type has conflicting packed representation hints\").emit();\n+                    if let Some(repr_pack) = repr.pack {\n+                        if pack as u64 != repr_pack.bytes() {\n+                            struct_span_err!(\n+                                tcx.sess, sp, E0634,\n+                                \"type has conflicting packed representation hints\"\n+                            ).emit();\n+                        }\n                     }\n                 }\n             }\n         }\n-        if repr.align > 0 {\n+        if repr.align.is_some() {\n             struct_span_err!(tcx.sess, sp, E0587,\n                              \"type has conflicting packed and align representation hints\").emit();\n         }\n@@ -1885,7 +1889,7 @@ fn check_packed_inner(tcx: TyCtxt<'_>, def_id: DefId, stack: &mut Vec<DefId>) ->\n     }\n     if let ty::Adt(def, substs) = t.sty {\n         if def.is_struct() || def.is_union() {\n-            if tcx.adt_def(def.did).repr.align > 0 {\n+            if tcx.adt_def(def.did).repr.align.is_some() {\n                 return true;\n             }\n             // push struct def_id before checking fields"}]}