{"sha": "e4baeaa30da3736d9a85f24509319d7148c2feea", "node_id": "MDY6Q29tbWl0NzI0NzEyOmU0YmFlYWEzMGRhMzczNmQ5YTg1ZjI0NTA5MzE5ZDcxNDhjMmZlZWE=", "commit": {"author": {"name": "Jeffrey Seyfried", "email": "jeffrey.seyfried@gmail.com", "date": "2016-10-17T07:46:25Z"}, "committer": {"name": "Jeffrey Seyfried", "email": "jeffrey.seyfried@gmail.com", "date": "2016-10-24T00:43:12Z"}, "message": "Import macros in `resolve` instead of in `metadata::macro_import`.", "tree": {"sha": "1b17a11b3a47a93413e1578d76512e4fd73718df", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1b17a11b3a47a93413e1578d76512e4fd73718df"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e4baeaa30da3736d9a85f24509319d7148c2feea", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e4baeaa30da3736d9a85f24509319d7148c2feea", "html_url": "https://github.com/rust-lang/rust/commit/e4baeaa30da3736d9a85f24509319d7148c2feea", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e4baeaa30da3736d9a85f24509319d7148c2feea/comments", "author": {"login": "jseyfried", "id": 8652869, "node_id": "MDQ6VXNlcjg2NTI4Njk=", "avatar_url": "https://avatars.githubusercontent.com/u/8652869?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jseyfried", "html_url": "https://github.com/jseyfried", "followers_url": "https://api.github.com/users/jseyfried/followers", "following_url": "https://api.github.com/users/jseyfried/following{/other_user}", "gists_url": "https://api.github.com/users/jseyfried/gists{/gist_id}", "starred_url": "https://api.github.com/users/jseyfried/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jseyfried/subscriptions", "organizations_url": "https://api.github.com/users/jseyfried/orgs", "repos_url": "https://api.github.com/users/jseyfried/repos", "events_url": "https://api.github.com/users/jseyfried/events{/privacy}", "received_events_url": "https://api.github.com/users/jseyfried/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jseyfried", "id": 8652869, "node_id": "MDQ6VXNlcjg2NTI4Njk=", "avatar_url": "https://avatars.githubusercontent.com/u/8652869?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jseyfried", "html_url": "https://github.com/jseyfried", "followers_url": "https://api.github.com/users/jseyfried/followers", "following_url": "https://api.github.com/users/jseyfried/following{/other_user}", "gists_url": "https://api.github.com/users/jseyfried/gists{/gist_id}", "starred_url": "https://api.github.com/users/jseyfried/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jseyfried/subscriptions", "organizations_url": "https://api.github.com/users/jseyfried/orgs", "repos_url": "https://api.github.com/users/jseyfried/repos", "events_url": "https://api.github.com/users/jseyfried/events{/privacy}", "received_events_url": "https://api.github.com/users/jseyfried/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4845adde360c306624faa3305ea95f95cd11e2b4", "url": "https://api.github.com/repos/rust-lang/rust/commits/4845adde360c306624faa3305ea95f95cd11e2b4", "html_url": "https://github.com/rust-lang/rust/commit/4845adde360c306624faa3305ea95f95cd11e2b4"}], "stats": {"total": 901, "additions": 410, "deletions": 491}, "files": [{"sha": "4e0e561f661ccbc06ba70cdc6b7c1b1f6fb80db5", "filename": "src/librustc/middle/cstore.rs", "status": "modified", "additions": 5, "deletions": 10, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/e4baeaa30da3736d9a85f24509319d7148c2feea/src%2Flibrustc%2Fmiddle%2Fcstore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4baeaa30da3736d9a85f24509319d7148c2feea/src%2Flibrustc%2Fmiddle%2Fcstore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcstore.rs?ref=e4baeaa30da3736d9a85f24509319d7148c2feea", "patch": "@@ -37,7 +37,7 @@ use util::nodemap::{NodeSet, DefIdMap};\n use std::path::PathBuf;\n use syntax::ast;\n use syntax::attr;\n-use syntax::ext::base::MultiItemModifier;\n+use syntax::ext::base::SyntaxExtension;\n use syntax::ptr::P;\n use syntax::parse::token::InternedString;\n use syntax_pos::Span;\n@@ -417,18 +417,13 @@ impl<'tcx> CrateStore<'tcx> for DummyCrateStore {\n     fn metadata_encoding_version(&self) -> &[u8] { bug!(\"metadata_encoding_version\") }\n }\n \n-pub struct LoadedMacro {\n-    pub import_site: Span,\n-    pub kind: LoadedMacroKind,\n-}\n-\n-pub enum LoadedMacroKind {\n-    Def(ast::MacroDef),\n-    CustomDerive(String, Box<MultiItemModifier>),\n+pub enum LoadedMacros {\n+    MacroRules(Vec<ast::MacroDef>),\n+    ProcMacros(Vec<(ast::Name, SyntaxExtension)>),\n }\n \n pub trait CrateLoader {\n-    fn load_macros(&mut self, extern_crate: &ast::Item, allows_macros: bool) -> Vec<LoadedMacro>;\n+    fn load_macros(&mut self, extern_crate: &ast::Item) -> LoadedMacros;\n     fn process_item(&mut self, item: &ast::Item, defs: &Definitions);\n     fn postprocess(&mut self, krate: &ast::Crate);\n }"}, {"sha": "ad2a7afbc8b6a5472d9d941a8b653ff0a54450ad", "filename": "src/librustc_metadata/creader.rs", "status": "modified", "additions": 69, "deletions": 8, "changes": 77, "blob_url": "https://github.com/rust-lang/rust/blob/e4baeaa30da3736d9a85f24509319d7148c2feea/src%2Flibrustc_metadata%2Fcreader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4baeaa30da3736d9a85f24509319d7148c2feea/src%2Flibrustc_metadata%2Fcreader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fcreader.rs?ref=e4baeaa30da3736d9a85f24509319d7148c2feea", "patch": "@@ -12,12 +12,11 @@\n \n use cstore::{self, CStore, CrateSource, MetadataBlob};\n use locator::{self, CratePaths};\n-use macro_import;\n use schema::CrateRoot;\n \n use rustc::hir::def_id::{CrateNum, DefIndex};\n use rustc::hir::svh::Svh;\n-use rustc::middle::cstore::LoadedMacro;\n+use rustc::middle::cstore::LoadedMacros;\n use rustc::session::{config, Session};\n use rustc_back::PanicStrategy;\n use rustc::session::search_paths::PathKind;\n@@ -36,7 +35,8 @@ use syntax::ast;\n use syntax::abi::Abi;\n use syntax::parse;\n use syntax::attr;\n-use syntax::parse::token::InternedString;\n+use syntax::ext::base::SyntaxExtension;\n+use syntax::parse::token::{InternedString, intern};\n use syntax_pos::{self, Span, mk_sp};\n use log;\n \n@@ -591,15 +591,14 @@ impl<'a> CrateLoader<'a> {\n \n             ret.macro_rules.push(ast::MacroDef {\n                 ident: ast::Ident::with_empty_ctxt(def.name),\n-                attrs: def.attrs,\n                 id: ast::DUMMY_NODE_ID,\n                 span: local_span,\n                 imported_from: Some(item.ident),\n                 // overridden in plugin/load.rs\n                 export: false,\n                 use_locally: false,\n-                allow_internal_unstable: false,\n-\n+                allow_internal_unstable: attr::contains_name(&def.attrs, \"allow_internal_unstable\"),\n+                attrs: def.attrs,\n                 body: body,\n             });\n             self.sess.imported_macro_spans.borrow_mut()\n@@ -639,6 +638,58 @@ impl<'a> CrateLoader<'a> {\n         return ret\n     }\n \n+    /// Load custom derive macros.\n+    ///\n+    /// Note that this is intentionally similar to how we load plugins today,\n+    /// but also intentionally separate. Plugins are likely always going to be\n+    /// implemented as dynamic libraries, but we have a possible future where\n+    /// custom derive (and other macro-1.1 style features) are implemented via\n+    /// executables and custom IPC.\n+    fn load_derive_macros(&mut self, span: Span, macros: &Macros, index: DefIndex)\n+                          -> Vec<(ast::Name, SyntaxExtension)> {\n+        use std::{env, mem};\n+        use proc_macro::TokenStream;\n+        use proc_macro::__internal::Registry;\n+        use rustc_back::dynamic_lib::DynamicLibrary;\n+        use syntax_ext::deriving::custom::CustomDerive;\n+\n+        // Make sure the path contains a / or the linker will search for it.\n+        let path = macros.dylib.as_ref().unwrap();\n+        let path = env::current_dir().unwrap().join(path);\n+        let lib = match DynamicLibrary::open(Some(&path)) {\n+            Ok(lib) => lib,\n+            Err(err) => self.sess.span_fatal(span, &err),\n+        };\n+\n+        let sym = self.sess.generate_derive_registrar_symbol(&macros.svh, index);\n+        let registrar = unsafe {\n+            let sym = match lib.symbol(&sym) {\n+                Ok(f) => f,\n+                Err(err) => self.sess.span_fatal(span, &err),\n+            };\n+            mem::transmute::<*mut u8, fn(&mut Registry)>(sym)\n+        };\n+\n+        struct MyRegistrar(Vec<(ast::Name, SyntaxExtension)>);\n+\n+        impl Registry for MyRegistrar {\n+            fn register_custom_derive(&mut self,\n+                                      trait_name: &str,\n+                                      expand: fn(TokenStream) -> TokenStream) {\n+                let derive = SyntaxExtension::CustomDerive(Box::new(CustomDerive::new(expand)));\n+                self.0.push((intern(trait_name), derive));\n+            }\n+        }\n+\n+        let mut my_registrar = MyRegistrar(Vec::new());\n+        registrar(&mut my_registrar);\n+\n+        // Intentionally leak the dynamic library. We can't ever unload it\n+        // since the library can make things that will live arbitrarily long.\n+        mem::forget(lib);\n+        my_registrar.0\n+    }\n+\n     /// Look for a plugin registrar. Returns library path, crate\n     /// SVH and DefIndex of the registrar function.\n     pub fn find_plugin_registrar(&mut self, span: Span, name: &str)\n@@ -1030,7 +1081,17 @@ impl<'a> middle::cstore::CrateLoader for CrateLoader<'a> {\n         }\n     }\n \n-    fn load_macros(&mut self, extern_crate: &ast::Item, allows_macros: bool) -> Vec<LoadedMacro> {\n-        macro_import::load_macros(self, extern_crate, allows_macros)\n+    fn load_macros(&mut self, extern_crate: &ast::Item) -> LoadedMacros {\n+        let macros = self.read_macros(extern_crate);\n+\n+        if let Some(index) = macros.custom_derive_registrar {\n+            // custom derive crates currently should not have any macro_rules!\n+            // exported macros, enforced elsewhere\n+            assert_eq!(macros.macro_rules.len(), 0);\n+            let custom_derives = self.load_derive_macros(extern_crate.span, &macros, index);\n+            LoadedMacros::ProcMacros(custom_derives)\n+        } else {\n+            LoadedMacros::MacroRules(macros.macro_rules)\n+        }\n     }\n }"}, {"sha": "b2f4760727ae106f2e1e7313db3ad41c59d0a136", "filename": "src/librustc_metadata/diagnostics.rs", "status": "modified", "additions": 0, "deletions": 179, "changes": 179, "blob_url": "https://github.com/rust-lang/rust/blob/e4baeaa30da3736d9a85f24509319d7148c2feea/src%2Flibrustc_metadata%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4baeaa30da3736d9a85f24509319d7148c2feea/src%2Flibrustc_metadata%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fdiagnostics.rs?ref=e4baeaa30da3736d9a85f24509319d7148c2feea", "patch": "@@ -91,185 +91,6 @@ You need to link your code to the relevant crate in order to be able to use it\n well, and you link to them the same way.\n \"##,\n \n-E0466: r##\"\n-Macro import declarations were malformed.\n-\n-Erroneous code examples:\n-\n-```compile_fail,E0466\n-#[macro_use(a_macro(another_macro))] // error: invalid import declaration\n-extern crate core as some_crate;\n-\n-#[macro_use(i_want = \"some_macros\")] // error: invalid import declaration\n-extern crate core as another_crate;\n-```\n-\n-This is a syntax error at the level of attribute declarations. The proper\n-syntax for macro imports is the following:\n-\n-```ignore\n-// In some_crate:\n-#[macro_export]\n-macro_rules! get_tacos {\n-    ...\n-}\n-\n-#[macro_export]\n-macro_rules! get_pimientos {\n-    ...\n-}\n-\n-// In your crate:\n-#[macro_use(get_tacos, get_pimientos)] // It imports `get_tacos` and\n-extern crate some_crate;               // `get_pimientos` macros from some_crate\n-```\n-\n-If you would like to import all exported macros, write `macro_use` with no\n-arguments.\n-\"##,\n-\n-E0467: r##\"\n-Macro reexport declarations were empty or malformed.\n-\n-Erroneous code examples:\n-\n-```compile_fail,E0467\n-#[macro_reexport]                    // error: no macros listed for export\n-extern crate core as macros_for_good;\n-\n-#[macro_reexport(fun_macro = \"foo\")] // error: not a macro identifier\n-extern crate core as other_macros_for_good;\n-```\n-\n-This is a syntax error at the level of attribute declarations.\n-\n-Currently, `macro_reexport` requires at least one macro name to be listed.\n-Unlike `macro_use`, listing no names does not reexport all macros from the\n-given crate.\n-\n-Decide which macros you would like to export and list them properly.\n-\n-These are proper reexport declarations:\n-\n-```ignore\n-#[macro_reexport(some_macro, another_macro)]\n-extern crate macros_for_good;\n-```\n-\"##,\n-\n-E0468: r##\"\n-A non-root module attempts to import macros from another crate.\n-\n-Example of erroneous code:\n-\n-```compile_fail,E0468\n-mod foo {\n-    #[macro_use(helpful_macro)] // error: must be at crate root to import\n-    extern crate core;          //        macros from another crate\n-    helpful_macro!(...);\n-}\n-```\n-\n-Only `extern crate` imports at the crate root level are allowed to import\n-macros.\n-\n-Either move the macro import to crate root or do without the foreign macros.\n-This will work:\n-\n-```ignore\n-#[macro_use(helpful_macro)]\n-extern crate some_crate;\n-\n-mod foo {\n-    helpful_macro!(...)\n-}\n-```\n-\"##,\n-\n-E0469: r##\"\n-A macro listed for import was not found.\n-\n-Erroneous code example:\n-\n-```compile_fail,E0469\n-#[macro_use(drink, be_merry)] // error: imported macro not found\n-extern crate collections;\n-\n-fn main() {\n-    // ...\n-}\n-```\n-\n-Either the listed macro is not contained in the imported crate, or it is not\n-exported from the given crate.\n-\n-This could be caused by a typo. Did you misspell the macro's name?\n-\n-Double-check the names of the macros listed for import, and that the crate\n-in question exports them.\n-\n-A working version would be:\n-\n-```ignore\n-// In some_crate crate:\n-#[macro_export]\n-macro_rules! eat {\n-    ...\n-}\n-\n-#[macro_export]\n-macro_rules! drink {\n-    ...\n-}\n-\n-// In your crate:\n-#[macro_use(eat, drink)]\n-extern crate some_crate; //ok!\n-```\n-\"##,\n-\n-E0470: r##\"\n-A macro listed for reexport was not found.\n-\n-Erroneous code example:\n-\n-```compile_fail,E0470\n-#[macro_reexport(drink, be_merry)]\n-extern crate collections;\n-\n-fn main() {\n-    // ...\n-}\n-```\n-\n-Either the listed macro is not contained in the imported crate, or it is not\n-exported from the given crate.\n-\n-This could be caused by a typo. Did you misspell the macro's name?\n-\n-Double-check the names of the macros listed for reexport, and that the crate\n-in question exports them.\n-\n-A working version:\n-\n-```ignore\n-// In some_crate crate:\n-#[macro_export]\n-macro_rules! eat {\n-    ...\n-}\n-\n-#[macro_export]\n-macro_rules! drink {\n-    ...\n-}\n-\n-// In your_crate:\n-#[macro_reexport(eat, drink)]\n-extern crate some_crate;\n-```\n-\"##,\n-\n }\n \n register_diagnostics! {"}, {"sha": "300c5f0dec71d3f226625b4078683e26033180c5", "filename": "src/librustc_metadata/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/e4baeaa30da3736d9a85f24509319d7148c2feea/src%2Flibrustc_metadata%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4baeaa30da3736d9a85f24509319d7148c2feea/src%2Flibrustc_metadata%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Flib.rs?ref=e4baeaa30da3736d9a85f24509319d7148c2feea", "patch": "@@ -59,6 +59,5 @@ mod schema;\n pub mod creader;\n pub mod cstore;\n pub mod locator;\n-pub mod macro_import;\n \n __build_diagnostic_array! { librustc_metadata, DIAGNOSTICS }"}, {"sha": "ddc254a16d9f496a0a7e7b3fc5e07ee974eec468", "filename": "src/librustc_metadata/macro_import.rs", "status": "removed", "additions": 0, "deletions": 235, "changes": 235, "blob_url": "https://github.com/rust-lang/rust/blob/4845adde360c306624faa3305ea95f95cd11e2b4/src%2Flibrustc_metadata%2Fmacro_import.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4845adde360c306624faa3305ea95f95cd11e2b4/src%2Flibrustc_metadata%2Fmacro_import.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fmacro_import.rs?ref=4845adde360c306624faa3305ea95f95cd11e2b4", "patch": "@@ -1,235 +0,0 @@\n-// Copyright 2012-2015 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-//! Used by `rustc` when loading a crate with exported macros.\n-\n-use std::collections::HashSet;\n-use std::env;\n-use std::mem;\n-\n-use creader::{CrateLoader, Macros};\n-\n-use proc_macro::TokenStream;\n-use proc_macro::__internal::Registry;\n-use rustc::hir::def_id::DefIndex;\n-use rustc::middle::cstore::{LoadedMacro, LoadedMacroKind};\n-use rustc::session::Session;\n-use rustc::util::nodemap::FnvHashMap;\n-use rustc_back::dynamic_lib::DynamicLibrary;\n-use syntax::ast;\n-use syntax::attr;\n-use syntax::parse::token;\n-use syntax_ext::deriving::custom::CustomDerive;\n-use syntax_pos::{Span, DUMMY_SP};\n-\n-pub fn call_bad_macro_reexport(a: &Session, b: Span) {\n-    span_err!(a, b, E0467, \"bad macro reexport\");\n-}\n-\n-pub type MacroSelection = FnvHashMap<token::InternedString, Span>;\n-\n-enum ImportSelection {\n-    All(Span),\n-    Some(MacroSelection),\n-}\n-\n-pub fn load_macros(loader: &mut CrateLoader, extern_crate: &ast::Item, allows_macros: bool)\n-                   -> Vec<LoadedMacro> {\n-    loader.load_crate(extern_crate, allows_macros)\n-}\n-\n-impl<'a> CrateLoader<'a> {\n-    fn load_crate(&mut self,\n-                  extern_crate: &ast::Item,\n-                  allows_macros: bool) -> Vec<LoadedMacro> {\n-        // Parse the attributes relating to macros.\n-        let mut import = ImportSelection::Some(FnvHashMap());\n-        let mut reexport = FnvHashMap();\n-        let mut no_link = false;\n-\n-        for attr in &extern_crate.attrs {\n-            let mut used = true;\n-            match &attr.name()[..] {\n-                \"macro_use\" => {\n-                    let names = attr.meta_item_list();\n-                    if names.is_none() {\n-                        import = ImportSelection::All(attr.span);\n-                    } else if let ImportSelection::Some(ref mut sel) = import {\n-                        for attr in names.unwrap() {\n-                            if let Some(word) = attr.word() {\n-                                sel.insert(word.name().clone(), attr.span());\n-                            } else {\n-                                span_err!(self.sess, attr.span(), E0466, \"bad macro import\");\n-                            }\n-                        }\n-                    }\n-                }\n-                \"macro_reexport\" => {\n-                    let names = match attr.meta_item_list() {\n-                        Some(names) => names,\n-                        None => {\n-                            call_bad_macro_reexport(self.sess, attr.span);\n-                            continue;\n-                        }\n-                    };\n-\n-                    for attr in names {\n-                        if let Some(word) = attr.word() {\n-                            reexport.insert(word.name().clone(), attr.span());\n-                        } else {\n-                            call_bad_macro_reexport(self.sess, attr.span());\n-                        }\n-                    }\n-                }\n-                \"no_link\" => no_link = true,\n-                _ => used = false,\n-            }\n-            if used {\n-                attr::mark_used(attr);\n-            }\n-        }\n-\n-        self.load_macros(extern_crate, allows_macros, import, reexport, no_link)\n-    }\n-\n-    fn load_macros<'b>(&mut self,\n-                       vi: &ast::Item,\n-                       allows_macros: bool,\n-                       import: ImportSelection,\n-                       reexport: MacroSelection,\n-                       no_link: bool)\n-                       -> Vec<LoadedMacro> {\n-        if let ImportSelection::Some(ref sel) = import {\n-            if sel.is_empty() && reexport.is_empty() {\n-                // Make sure we can read macros from `#[no_link]` crates.\n-                if no_link {\n-                    self.read_macros(vi);\n-                }\n-                return Vec::new();\n-            }\n-        }\n-\n-        if !allows_macros {\n-            span_err!(self.sess, vi.span, E0468,\n-                      \"an `extern crate` loading macros must be at the crate root\");\n-            return Vec::new();\n-        }\n-\n-        let mut macros = self.read_macros(vi);\n-        let mut ret = Vec::new();\n-        let mut seen = HashSet::new();\n-\n-        for mut def in macros.macro_rules.drain(..) {\n-            let name = def.ident.name.as_str();\n-\n-            let import_site = match import {\n-                ImportSelection::All(span) => Some(span),\n-                ImportSelection::Some(ref sel) => sel.get(&name).cloned()\n-            };\n-            def.use_locally = import_site.is_some();\n-            def.export = reexport.contains_key(&name);\n-            def.allow_internal_unstable = attr::contains_name(&def.attrs,\n-                                                              \"allow_internal_unstable\");\n-            debug!(\"load_macros: loaded: {:?}\", def);\n-            ret.push(LoadedMacro {\n-                kind: LoadedMacroKind::Def(def),\n-                import_site: import_site.unwrap_or(DUMMY_SP),\n-            });\n-            seen.insert(name);\n-        }\n-\n-        if let Some(index) = macros.custom_derive_registrar {\n-            // custom derive crates currently should not have any macro_rules!\n-            // exported macros, enforced elsewhere\n-            assert_eq!(ret.len(), 0);\n-\n-            if let ImportSelection::Some(..) = import {\n-                self.sess.span_err(vi.span, \"`proc-macro` crates cannot be \\\n-                                             selectively imported from, must \\\n-                                             use `#[macro_use]`\");\n-            }\n-\n-            if reexport.len() > 0 {\n-                self.sess.span_err(vi.span, \"`proc-macro` crates cannot be \\\n-                                             reexported from\");\n-            }\n-\n-            self.load_derive_macros(vi.span, &macros, index, &mut ret);\n-        }\n-\n-        if let ImportSelection::Some(sel) = import {\n-            for (name, span) in sel {\n-                if !seen.contains(&name) {\n-                    span_err!(self.sess, span, E0469,\n-                              \"imported macro not found\");\n-                }\n-            }\n-        }\n-\n-        for (name, span) in &reexport {\n-            if !seen.contains(&name) {\n-                span_err!(self.sess, *span, E0470,\n-                          \"reexported macro not found\");\n-            }\n-        }\n-\n-        return ret\n-    }\n-\n-    /// Load the custom derive macros into the list of macros we're loading.\n-    ///\n-    /// Note that this is intentionally similar to how we load plugins today,\n-    /// but also intentionally separate. Plugins are likely always going to be\n-    /// implemented as dynamic libraries, but we have a possible future where\n-    /// custom derive (and other macro-1.1 style features) are implemented via\n-    /// executables and custom IPC.\n-    fn load_derive_macros(&mut self,\n-                          span: Span,\n-                          macros: &Macros,\n-                          index: DefIndex,\n-                          ret: &mut Vec<LoadedMacro>) {\n-        // Make sure the path contains a / or the linker will search for it.\n-        let path = macros.dylib.as_ref().unwrap();\n-        let path = env::current_dir().unwrap().join(path);\n-        let lib = match DynamicLibrary::open(Some(&path)) {\n-            Ok(lib) => lib,\n-            Err(err) => self.sess.span_fatal(span, &err),\n-        };\n-\n-        let sym = self.sess.generate_derive_registrar_symbol(&macros.svh, index);\n-        let registrar = unsafe {\n-            let sym = match lib.symbol(&sym) {\n-                Ok(f) => f,\n-                Err(err) => self.sess.span_fatal(span, &err),\n-            };\n-            mem::transmute::<*mut u8, fn(&mut Registry)>(sym)\n-        };\n-\n-        struct MyRegistrar<'a>(&'a mut Vec<LoadedMacro>, Span);\n-\n-        impl<'a> Registry for MyRegistrar<'a> {\n-            fn register_custom_derive(&mut self,\n-                                      trait_name: &str,\n-                                      expand: fn(TokenStream) -> TokenStream) {\n-                let derive = Box::new(CustomDerive::new(expand));\n-                self.0.push(LoadedMacro {\n-                    kind: LoadedMacroKind::CustomDerive(trait_name.to_string(), derive),\n-                    import_site: self.1,\n-                });\n-            }\n-        }\n-\n-        registrar(&mut MyRegistrar(ret, span));\n-\n-        // Intentionally leak the dynamic library. We can't ever unload it\n-        // since the library can make things that will live arbitrarily long.\n-        mem::forget(lib);\n-    }\n-}"}, {"sha": "69210b98e3ac8b4e6f6be67345b61d868cc1e769", "filename": "src/librustc_resolve/build_reduced_graph.rs", "status": "modified", "additions": 157, "deletions": 58, "changes": 215, "blob_url": "https://github.com/rust-lang/rust/blob/e4baeaa30da3736d9a85f24509319d7148c2feea/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4baeaa30da3736d9a85f24509319d7148c2feea/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs?ref=e4baeaa30da3736d9a85f24509319d7148c2feea", "patch": "@@ -21,10 +21,11 @@ use {NameBinding, NameBindingKind, ToNameBinding};\n use Resolver;\n use {resolve_error, resolve_struct_error, ResolutionError};\n \n-use rustc::middle::cstore::LoadedMacroKind;\n+use rustc::middle::cstore::LoadedMacros;\n use rustc::hir::def::*;\n use rustc::hir::def_id::{CRATE_DEF_INDEX, DefId};\n use rustc::ty;\n+use rustc::util::nodemap::FnvHashMap;\n \n use std::cell::Cell;\n use std::rc::Rc;\n@@ -58,6 +59,14 @@ impl<'a> ToNameBinding<'a> for (Def, Span, ty::Visibility) {\n     }\n }\n \n+#[derive(Default, PartialEq, Eq)]\n+struct LegacyMacroImports {\n+    import_all: Option<Span>,\n+    imports: Vec<(Name, Span)>,\n+    reexports: Vec<(Name, Span)>,\n+    no_link: bool,\n+}\n+\n impl<'b> Resolver<'b> {\n     /// Defines `name` in namespace `ns` of module `parent` to be `def` if it is not yet defined;\n     /// otherwise, reports an error.\n@@ -193,57 +202,28 @@ impl<'b> Resolver<'b> {\n             }\n \n             ItemKind::ExternCrate(_) => {\n-                // We need to error on `#[macro_use] extern crate` when it isn't at the\n-                // crate root, because `$crate` won't work properly.\n-                let is_crate_root = self.current_module.parent.is_none();\n-                let import_macro = |this: &mut Self, name, ext, span| {\n-                    let shadowing = this.builtin_macros.insert(name, Rc::new(ext)).is_some();\n-                    if shadowing && expansion != Mark::root() {\n-                        let msg = format!(\"`{}` is already in scope\", name);\n-                        this.session.struct_span_err(span, &msg)\n-                            .note(\"macro-expanded `#[macro_use]`s may not shadow \\\n-                                   existing macros (see RFC 1560)\")\n-                            .emit();\n-                    }\n-                };\n-\n-                let mut custom_derive_crate = false;\n-                // The mark of the expansion that generates the loaded macros.\n-                let mut opt_mark = None;\n-                for loaded_macro in self.crate_loader.load_macros(item, is_crate_root) {\n-                    let mark = opt_mark.unwrap_or_else(Mark::fresh);\n-                    opt_mark = Some(mark);\n-                    match loaded_macro.kind {\n-                        LoadedMacroKind::Def(mut def) => {\n-                            if def.use_locally {\n-                                self.macro_names.insert(def.ident.name);\n-                                def.body = mark_tts(&def.body, mark);\n-                                let ext = macro_rules::compile(&self.session.parse_sess, &def);\n-                                import_macro(self, def.ident.name, ext, loaded_macro.import_site);\n-                            }\n-                            if def.export {\n-                                def.id = self.next_node_id();\n-                                self.exported_macros.push(def);\n-                            }\n-                        }\n-                        LoadedMacroKind::CustomDerive(name, ext) => {\n-                            custom_derive_crate = true;\n-                            let ext = SyntaxExtension::CustomDerive(ext);\n-                            import_macro(self, token::intern(&name), ext, loaded_macro.import_site);\n-                        }\n+                let legacy_imports = self.legacy_macro_imports(&item.attrs);\n+                // `#[macro_use]` and `#[macro_reexport]` are only allowed at the crate root.\n+                if self.current_module.parent.is_some() && {\n+                    legacy_imports.import_all.is_some() || !legacy_imports.imports.is_empty() ||\n+                    !legacy_imports.reexports.is_empty()\n+                } {\n+                    if self.current_module.parent.is_some() {\n+                        span_err!(self.session, item.span, E0468,\n+                                  \"an `extern crate` loading macros must be at the crate root\");\n                     }\n                 }\n \n-                if custom_derive_crate && !self.session.features.borrow().proc_macro {\n-                    let issue = feature_gate::GateIssue::Language;\n-                    let msg = \"loading custom derive macro crates is experimentally supported\";\n-                    emit_feature_err(&self.session.parse_sess, \"proc_macro\", item.span, issue, msg);\n-                }\n+                let loaded_macros = if legacy_imports != LegacyMacroImports::default() {\n+                    Some(self.crate_loader.load_macros(item))\n+                } else {\n+                    None\n+                };\n \n                 self.crate_loader.process_item(item, &self.definitions);\n-\n                 // n.b. we don't need to look at the path option here, because cstore already did\n-                if let Some(crate_id) = self.session.cstore.extern_mod_stmt_cnum(item.id) {\n+                let crate_id = self.session.cstore.extern_mod_stmt_cnum(item.id);\n+                let module = if let Some(crate_id) = crate_id {\n                     let def_id = DefId {\n                         krate: crate_id,\n                         index: CRATE_DEF_INDEX,\n@@ -254,25 +234,21 @@ impl<'b> Resolver<'b> {\n                         ..ModuleS::new(Some(parent), ModuleKind::Def(Def::Mod(def_id), name))\n                     });\n                     self.define(parent, name, TypeNS, (module, sp, vis));\n-\n-                    if let Some(mark) = opt_mark {\n-                        let invocation = self.arenas.alloc_invocation_data(InvocationData {\n-                            module: Cell::new(module),\n-                            def_index: CRATE_DEF_INDEX,\n-                            const_integer: false,\n-                            legacy_scope: Cell::new(LegacyScope::Empty),\n-                            expansion: Cell::new(LegacyScope::Empty),\n-                        });\n-                        self.invocations.insert(mark, invocation);\n-                    }\n-\n                     self.populate_module_if_necessary(module);\n+                    module\n                 } else {\n                     // Define an empty module\n                     let def = Def::Mod(self.definitions.local_def_id(item.id));\n                     let module = ModuleS::new(Some(parent), ModuleKind::Def(def, name));\n                     let module = self.arenas.alloc_module(module);\n                     self.define(parent, name, TypeNS, (module, sp, vis));\n+                    module\n+                };\n+\n+                if let Some(loaded_macros) = loaded_macros {\n+                    self.import_extern_crate_macros(\n+                        item, module, loaded_macros, legacy_imports, expansion == Mark::root(),\n+                    );\n                 }\n             }\n \n@@ -516,6 +492,93 @@ impl<'b> Resolver<'b> {\n         module.populated.set(true)\n     }\n \n+    fn import_extern_crate_macros(&mut self,\n+                                  extern_crate: &Item,\n+                                  module: Module<'b>,\n+                                  loaded_macros: LoadedMacros,\n+                                  legacy_imports: LegacyMacroImports,\n+                                  allow_shadowing: bool) {\n+        let import_macro = |this: &mut Self, name, ext: Rc<_>, span| {\n+            if let SyntaxExtension::NormalTT(..) = *ext {\n+                this.macro_names.insert(name);\n+            }\n+            if this.builtin_macros.insert(name, ext).is_some() && !allow_shadowing {\n+                let msg = format!(\"`{}` is already in scope\", name);\n+                let note =\n+                    \"macro-expanded `#[macro_use]`s may not shadow existing macros (see RFC 1560)\";\n+                this.session.struct_span_err(span, &msg).note(note).emit();\n+            }\n+        };\n+\n+        match loaded_macros {\n+            LoadedMacros::MacroRules(macros) => {\n+                let mark = Mark::fresh();\n+                if !macros.is_empty() {\n+                    let invocation = self.arenas.alloc_invocation_data(InvocationData {\n+                        module: Cell::new(module),\n+                        def_index: CRATE_DEF_INDEX,\n+                        const_integer: false,\n+                        legacy_scope: Cell::new(LegacyScope::Empty),\n+                        expansion: Cell::new(LegacyScope::Empty),\n+                    });\n+                    self.invocations.insert(mark, invocation);\n+                }\n+\n+                let mut macros: FnvHashMap<_, _> = macros.into_iter().map(|mut def| {\n+                    def.body = mark_tts(&def.body, mark);\n+                    let ext = macro_rules::compile(&self.session.parse_sess, &def);\n+                    (def.ident.name, (def, Rc::new(ext)))\n+                }).collect();\n+\n+                if let Some(span) = legacy_imports.import_all {\n+                    for (&name, &(_, ref ext)) in macros.iter() {\n+                        import_macro(self, name, ext.clone(), span);\n+                    }\n+                } else {\n+                    for (name, span) in legacy_imports.imports {\n+                        if let Some(&(_, ref ext)) = macros.get(&name) {\n+                            import_macro(self, name, ext.clone(), span);\n+                        } else {\n+                            span_err!(self.session, span, E0469, \"imported macro not found\");\n+                        }\n+                    }\n+                }\n+                for (name, span) in legacy_imports.reexports {\n+                    if let Some((mut def, _)) = macros.remove(&name) {\n+                        def.id = self.next_node_id();\n+                        self.exported_macros.push(def);\n+                    } else {\n+                        span_err!(self.session, span, E0470, \"reexported macro not found\");\n+                    }\n+                }\n+            }\n+\n+            LoadedMacros::ProcMacros(macros) => {\n+                if !self.session.features.borrow().proc_macro {\n+                    let sess = &self.session.parse_sess;\n+                    let issue = feature_gate::GateIssue::Language;\n+                    let msg =\n+                        \"loading custom derive macro crates is experimentally supported\";\n+                    emit_feature_err(sess, \"proc_macro\", extern_crate.span, issue, msg);\n+                }\n+                if !legacy_imports.imports.is_empty() {\n+                    let msg = \"`proc-macro` crates cannot be selectively imported from, \\\n+                               must use `#[macro_use]`\";\n+                    self.session.span_err(extern_crate.span, msg);\n+                }\n+                if !legacy_imports.reexports.is_empty() {\n+                    let msg = \"`proc-macro` crates cannot be reexported from\";\n+                    self.session.span_err(extern_crate.span, msg);\n+                }\n+                if let Some(span) = legacy_imports.import_all {\n+                    for (name, ext) in macros {\n+                        import_macro(self, name, Rc::new(ext), span);\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n     // does this attribute list contain \"macro_use\"?\n     fn contains_macro_use(&mut self, attrs: &[ast::Attribute]) -> bool {\n         for attr in attrs {\n@@ -539,6 +602,42 @@ impl<'b> Resolver<'b> {\n \n         false\n     }\n+\n+    fn legacy_macro_imports(&mut self, attrs: &[ast::Attribute]) -> LegacyMacroImports {\n+        let mut imports = LegacyMacroImports::default();\n+        for attr in attrs {\n+            if attr.check_name(\"macro_use\") {\n+                match attr.meta_item_list() {\n+                    Some(names) => for attr in names {\n+                        if let Some(word) = attr.word() {\n+                            imports.imports.push((token::intern(&word.name()), attr.span()));\n+                        } else {\n+                            span_err!(self.session, attr.span(), E0466, \"bad macro import\");\n+                        }\n+                    },\n+                    None => imports.import_all = Some(attr.span),\n+                }\n+            } else if attr.check_name(\"macro_reexport\") {\n+                let bad_macro_reexport = |this: &mut Self, span| {\n+                    span_err!(this.session, span, E0467, \"bad macro reexport\");\n+                };\n+                if let Some(names) = attr.meta_item_list() {\n+                    for attr in names {\n+                        if let Some(word) = attr.word() {\n+                            imports.reexports.push((token::intern(&word.name()), attr.span()));\n+                        } else {\n+                            bad_macro_reexport(self, attr.span());\n+                        }\n+                    }\n+                } else {\n+                    bad_macro_reexport(self, attr.span());\n+                }\n+            } else if attr.check_name(\"no_link\") {\n+                imports.no_link = true;\n+            }\n+        }\n+        imports\n+    }\n }\n \n pub struct BuildReducedGraphVisitor<'a, 'b: 'a> {"}, {"sha": "f2a5aedbb3ab463cbe2f12d10ed7c3e360b8b537", "filename": "src/librustc_resolve/diagnostics.rs", "status": "modified", "additions": 179, "deletions": 0, "changes": 179, "blob_url": "https://github.com/rust-lang/rust/blob/e4baeaa30da3736d9a85f24509319d7148c2feea/src%2Flibrustc_resolve%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4baeaa30da3736d9a85f24509319d7148c2feea/src%2Flibrustc_resolve%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fdiagnostics.rs?ref=e4baeaa30da3736d9a85f24509319d7148c2feea", "patch": "@@ -1272,6 +1272,185 @@ impl Foo for i32 {}\n ```\n \"##,\n \n+E0466: r##\"\n+Macro import declarations were malformed.\n+\n+Erroneous code examples:\n+\n+```compile_fail,E0466\n+#[macro_use(a_macro(another_macro))] // error: invalid import declaration\n+extern crate core as some_crate;\n+\n+#[macro_use(i_want = \"some_macros\")] // error: invalid import declaration\n+extern crate core as another_crate;\n+```\n+\n+This is a syntax error at the level of attribute declarations. The proper\n+syntax for macro imports is the following:\n+\n+```ignore\n+// In some_crate:\n+#[macro_export]\n+macro_rules! get_tacos {\n+    ...\n+}\n+\n+#[macro_export]\n+macro_rules! get_pimientos {\n+    ...\n+}\n+\n+// In your crate:\n+#[macro_use(get_tacos, get_pimientos)] // It imports `get_tacos` and\n+extern crate some_crate;               // `get_pimientos` macros from some_crate\n+```\n+\n+If you would like to import all exported macros, write `macro_use` with no\n+arguments.\n+\"##,\n+\n+E0467: r##\"\n+Macro reexport declarations were empty or malformed.\n+\n+Erroneous code examples:\n+\n+```compile_fail,E0467\n+#[macro_reexport]                    // error: no macros listed for export\n+extern crate core as macros_for_good;\n+\n+#[macro_reexport(fun_macro = \"foo\")] // error: not a macro identifier\n+extern crate core as other_macros_for_good;\n+```\n+\n+This is a syntax error at the level of attribute declarations.\n+\n+Currently, `macro_reexport` requires at least one macro name to be listed.\n+Unlike `macro_use`, listing no names does not reexport all macros from the\n+given crate.\n+\n+Decide which macros you would like to export and list them properly.\n+\n+These are proper reexport declarations:\n+\n+```ignore\n+#[macro_reexport(some_macro, another_macro)]\n+extern crate macros_for_good;\n+```\n+\"##,\n+\n+E0468: r##\"\n+A non-root module attempts to import macros from another crate.\n+\n+Example of erroneous code:\n+\n+```compile_fail,E0468\n+mod foo {\n+    #[macro_use(helpful_macro)] // error: must be at crate root to import\n+    extern crate core;          //        macros from another crate\n+    helpful_macro!(...);\n+}\n+```\n+\n+Only `extern crate` imports at the crate root level are allowed to import\n+macros.\n+\n+Either move the macro import to crate root or do without the foreign macros.\n+This will work:\n+\n+```ignore\n+#[macro_use(helpful_macro)]\n+extern crate some_crate;\n+\n+mod foo {\n+    helpful_macro!(...)\n+}\n+```\n+\"##,\n+\n+E0469: r##\"\n+A macro listed for import was not found.\n+\n+Erroneous code example:\n+\n+```compile_fail,E0469\n+#[macro_use(drink, be_merry)] // error: imported macro not found\n+extern crate collections;\n+\n+fn main() {\n+    // ...\n+}\n+```\n+\n+Either the listed macro is not contained in the imported crate, or it is not\n+exported from the given crate.\n+\n+This could be caused by a typo. Did you misspell the macro's name?\n+\n+Double-check the names of the macros listed for import, and that the crate\n+in question exports them.\n+\n+A working version would be:\n+\n+```ignore\n+// In some_crate crate:\n+#[macro_export]\n+macro_rules! eat {\n+    ...\n+}\n+\n+#[macro_export]\n+macro_rules! drink {\n+    ...\n+}\n+\n+// In your crate:\n+#[macro_use(eat, drink)]\n+extern crate some_crate; //ok!\n+```\n+\"##,\n+\n+E0470: r##\"\n+A macro listed for reexport was not found.\n+\n+Erroneous code example:\n+\n+```compile_fail,E0470\n+#[macro_reexport(drink, be_merry)]\n+extern crate collections;\n+\n+fn main() {\n+    // ...\n+}\n+```\n+\n+Either the listed macro is not contained in the imported crate, or it is not\n+exported from the given crate.\n+\n+This could be caused by a typo. Did you misspell the macro's name?\n+\n+Double-check the names of the macros listed for reexport, and that the crate\n+in question exports them.\n+\n+A working version:\n+\n+```ignore\n+// In some_crate crate:\n+#[macro_export]\n+macro_rules! eat {\n+    ...\n+}\n+\n+#[macro_export]\n+macro_rules! drink {\n+    ...\n+}\n+\n+// In your_crate:\n+#[macro_reexport(eat, drink)]\n+extern crate some_crate;\n+```\n+\"##,\n+\n E0530: r##\"\n A binding shadowed something it shouldn't.\n "}]}