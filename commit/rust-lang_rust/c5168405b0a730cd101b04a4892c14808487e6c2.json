{"sha": "c5168405b0a730cd101b04a4892c14808487e6c2", "node_id": "MDY6Q29tbWl0NzI0NzEyOmM1MTY4NDA1YjBhNzMwY2QxMDFiMDRhNDg5MmMxNDgwODQ4N2U2YzI=", "commit": {"author": {"name": "Matthew McAllister", "email": "mattmcal@ocf.berkeley.edu", "date": "2017-10-21T05:09:45Z"}, "committer": {"name": "Seiichi Uchida", "email": "seuchida@gmail.com", "date": "2018-03-13T16:16:19Z"}, "message": "Format attributes on block expressions", "tree": {"sha": "e6db5ca904ff75b6af5892e7c5e27054eccf7c77", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e6db5ca904ff75b6af5892e7c5e27054eccf7c77"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c5168405b0a730cd101b04a4892c14808487e6c2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c5168405b0a730cd101b04a4892c14808487e6c2", "html_url": "https://github.com/rust-lang/rust/commit/c5168405b0a730cd101b04a4892c14808487e6c2", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c5168405b0a730cd101b04a4892c14808487e6c2/comments", "author": {"login": "matthew-mcallister", "id": 6722367, "node_id": "MDQ6VXNlcjY3MjIzNjc=", "avatar_url": "https://avatars.githubusercontent.com/u/6722367?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matthew-mcallister", "html_url": "https://github.com/matthew-mcallister", "followers_url": "https://api.github.com/users/matthew-mcallister/followers", "following_url": "https://api.github.com/users/matthew-mcallister/following{/other_user}", "gists_url": "https://api.github.com/users/matthew-mcallister/gists{/gist_id}", "starred_url": "https://api.github.com/users/matthew-mcallister/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matthew-mcallister/subscriptions", "organizations_url": "https://api.github.com/users/matthew-mcallister/orgs", "repos_url": "https://api.github.com/users/matthew-mcallister/repos", "events_url": "https://api.github.com/users/matthew-mcallister/events{/privacy}", "received_events_url": "https://api.github.com/users/matthew-mcallister/received_events", "type": "User", "site_admin": false}, "committer": {"login": "topecongiro", "id": 21980157, "node_id": "MDQ6VXNlcjIxOTgwMTU3", "avatar_url": "https://avatars.githubusercontent.com/u/21980157?v=4", "gravatar_id": "", "url": "https://api.github.com/users/topecongiro", "html_url": "https://github.com/topecongiro", "followers_url": "https://api.github.com/users/topecongiro/followers", "following_url": "https://api.github.com/users/topecongiro/following{/other_user}", "gists_url": "https://api.github.com/users/topecongiro/gists{/gist_id}", "starred_url": "https://api.github.com/users/topecongiro/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/topecongiro/subscriptions", "organizations_url": "https://api.github.com/users/topecongiro/orgs", "repos_url": "https://api.github.com/users/topecongiro/repos", "events_url": "https://api.github.com/users/topecongiro/events{/privacy}", "received_events_url": "https://api.github.com/users/topecongiro/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "314c912303119a43ed2889ef79bb1ad05bab6e84", "url": "https://api.github.com/repos/rust-lang/rust/commits/314c912303119a43ed2889ef79bb1ad05bab6e84", "html_url": "https://github.com/rust-lang/rust/commit/314c912303119a43ed2889ef79bb1ad05bab6e84"}], "stats": {"total": 224, "additions": 175, "deletions": 49}, "files": [{"sha": "65052d766ebbda1ed16b185c2636889a03cd9d72", "filename": "src/closures.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/c5168405b0a730cd101b04a4892c14808487e6c2/src%2Fclosures.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c5168405b0a730cd101b04a4892c14808487e6c2/src%2Fclosures.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fclosures.rs?ref=c5168405b0a730cd101b04a4892c14808487e6c2", "patch": "@@ -50,7 +50,8 @@ pub fn rewrite_closure(\n     if let ast::ExprKind::Block(ref block) = body.node {\n         // The body of the closure is an empty block.\n         if block.stmts.is_empty() && !block_contains_comment(block, context.codemap) {\n-            return Some(format!(\"{} {{}}\", prefix));\n+            return body.rewrite(context, shape)\n+                .map(|s| format!(\"{} {}\", prefix, s));\n         }\n \n         let result = match fn_decl.output {\n@@ -138,7 +139,7 @@ fn rewrite_closure_with_block(\n         span: body.span,\n         recovered: false,\n     };\n-    let block = ::expr::rewrite_block_with_visitor(context, \"\", &block, shape, false)?;\n+    let block = ::expr::rewrite_block_with_visitor(context, \"\", &block, None, shape, false)?;\n     Some(format!(\"{} {}\", prefix, block))\n }\n \n@@ -291,7 +292,8 @@ pub fn rewrite_last_closure(\n     if let ast::ExprKind::Closure(capture, movability, ref fn_decl, ref body, _) = expr.node {\n         let body = match body.node {\n             ast::ExprKind::Block(ref block)\n-                if !is_unsafe_block(block) && is_simple_block(block, context.codemap) =>\n+                if !is_unsafe_block(block)\n+                    && is_simple_block(block, Some(&body.attrs), context.codemap) =>\n             {\n                 stmt_expr(&block.stmts[0]).unwrap_or(body)\n             }"}, {"sha": "c959edd2fd72f945db58352e21461567b6908029", "filename": "src/expr.rs", "status": "modified", "additions": 93, "deletions": 38, "changes": 131, "blob_url": "https://github.com/rust-lang/rust/blob/c5168405b0a730cd101b04a4892c14808487e6c2/src%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c5168405b0a730cd101b04a4892c14808487e6c2/src%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fexpr.rs?ref=c5168405b0a730cd101b04a4892c14808487e6c2", "patch": "@@ -115,16 +115,25 @@ pub fn format_expr(\n             match expr_type {\n                 ExprType::Statement => {\n                     if is_unsafe_block(block) {\n-                        block.rewrite(context, shape)\n-                    } else if let rw @ Some(_) = rewrite_empty_block(context, block, shape) {\n+                        rewrite_block(block, Some(&expr.attrs), context, shape)\n+                    } else if let rw @ Some(_) =\n+                        rewrite_empty_block(context, block, Some(&expr.attrs), \"\", shape)\n+                    {\n                         // Rewrite block without trying to put it in a single line.\n                         rw\n                     } else {\n                         let prefix = block_prefix(context, block, shape)?;\n-                        rewrite_block_with_visitor(context, &prefix, block, shape, true)\n+                        rewrite_block_with_visitor(\n+                            context,\n+                            &prefix,\n+                            block,\n+                            Some(&expr.attrs),\n+                            shape,\n+                            true,\n+                        )\n                     }\n                 }\n-                ExprType::SubExpression => block.rewrite(context, shape),\n+                ExprType::SubExpression => rewrite_block(block, Some(&expr.attrs), context, shape),\n             }\n         }\n         ast::ExprKind::Match(ref cond, ref arms) => {\n@@ -290,15 +299,22 @@ pub fn format_expr(\n             Some(context.snippet(expr.span).to_owned())\n         }\n         ast::ExprKind::Catch(ref block) => {\n-            if let rw @ Some(_) = rewrite_single_line_block(context, \"do catch \", block, shape) {\n+            if let rw @ Some(_) =\n+                rewrite_single_line_block(context, \"do catch \", block, Some(&expr.attrs), shape)\n+            {\n                 rw\n             } else {\n                 // 9 = `do catch `\n                 let budget = shape.width.checked_sub(9).unwrap_or(0);\n                 Some(format!(\n                     \"{}{}\",\n                     \"do catch \",\n-                    block.rewrite(context, Shape::legacy(budget, shape.indent))?\n+                    rewrite_block(\n+                        block,\n+                        Some(&expr.attrs),\n+                        context,\n+                        Shape::legacy(budget, shape.indent)\n+                    )?\n                 ))\n             }\n         }\n@@ -347,7 +363,7 @@ where\n     let lhs_result = lhs.rewrite(context, lhs_shape)\n         .map(|lhs_str| format!(\"{}{}\", pp.prefix, lhs_str))?;\n \n-    // Try to the both lhs and rhs on the same line.\n+    // Try to put both lhs and rhs on the same line.\n     let rhs_orig_result = shape\n         .offset_left(last_line_width(&lhs_result) + pp.infix.len())\n         .and_then(|s| s.sub_width(pp.suffix.len()))\n@@ -564,11 +580,17 @@ fn nop_block_collapse(block_str: Option<String>, budget: usize) -> Option<String\n fn rewrite_empty_block(\n     context: &RewriteContext,\n     block: &ast::Block,\n+    attrs: Option<&[ast::Attribute]>,\n+    prefix: &str,\n     shape: Shape,\n ) -> Option<String> {\n+    if attrs.map_or(false, |a| !inner_attributes(a).is_empty()) {\n+        return None;\n+    }\n+\n     if block.stmts.is_empty() && !block_contains_comment(block, context.codemap) && shape.width >= 2\n     {\n-        return Some(\"{}\".to_owned());\n+        return Some(format!(\"{}{{}}\", prefix));\n     }\n \n     // If a block contains only a single-line comment, then leave it on one line.\n@@ -579,7 +601,7 @@ fn rewrite_empty_block(\n         if block.stmts.is_empty() && !comment_str.contains('\\n') && !comment_str.starts_with(\"//\")\n             && comment_str.len() + 4 <= shape.width\n         {\n-            return Some(format!(\"{{ {} }}\", comment_str));\n+            return Some(format!(\"{}{{ {} }}\", prefix, comment_str));\n         }\n     }\n \n@@ -618,9 +640,10 @@ fn rewrite_single_line_block(\n     context: &RewriteContext,\n     prefix: &str,\n     block: &ast::Block,\n+    attrs: Option<&[ast::Attribute]>,\n     shape: Shape,\n ) -> Option<String> {\n-    if is_simple_block(block, context.codemap) {\n+    if is_simple_block(block, attrs, context.codemap) {\n         let expr_shape = shape.offset_left(last_line_width(prefix))?;\n         let expr_str = block.stmts[0].rewrite(context, expr_shape)?;\n         let result = format!(\"{}{{ {} }}\", prefix, expr_str);\n@@ -635,10 +658,11 @@ pub fn rewrite_block_with_visitor(\n     context: &RewriteContext,\n     prefix: &str,\n     block: &ast::Block,\n+    attrs: Option<&[ast::Attribute]>,\n     shape: Shape,\n     has_braces: bool,\n ) -> Option<String> {\n-    if let rw @ Some(_) = rewrite_empty_block(context, block, shape) {\n+    if let rw @ Some(_) = rewrite_empty_block(context, block, attrs, prefix, shape) {\n         return rw;\n     }\n \n@@ -654,31 +678,41 @@ pub fn rewrite_block_with_visitor(\n         ast::BlockCheckMode::Default => visitor.last_pos = block.span.lo(),\n     }\n \n-    visitor.visit_block(block, None, has_braces);\n+    let inner_attrs = attrs.map(inner_attributes);\n+    visitor.visit_block(block, inner_attrs.as_ref().map(|a| &**a), has_braces);\n     Some(format!(\"{}{}\", prefix, visitor.buffer))\n }\n \n impl Rewrite for ast::Block {\n     fn rewrite(&self, context: &RewriteContext, shape: Shape) -> Option<String> {\n-        // shape.width is used only for the single line case: either the empty block `{}`,\n-        // or an unsafe expression `unsafe { e }`.\n-        if let rw @ Some(_) = rewrite_empty_block(context, self, shape) {\n-            return rw;\n-        }\n+        rewrite_block(self, None, context, shape)\n+    }\n+}\n \n-        let prefix = block_prefix(context, self, shape)?;\n+fn rewrite_block(\n+    block: &ast::Block,\n+    attrs: Option<&[ast::Attribute]>,\n+    context: &RewriteContext,\n+    shape: Shape,\n+) -> Option<String> {\n+    let prefix = block_prefix(context, block, shape)?;\n \n-        let result = rewrite_block_with_visitor(context, &prefix, self, shape, true);\n-        if let Some(ref result_str) = result {\n-            if result_str.lines().count() <= 3 {\n-                if let rw @ Some(_) = rewrite_single_line_block(context, &prefix, self, shape) {\n-                    return rw;\n-                }\n+    // shape.width is used only for the single line case: either the empty block `{}`,\n+    // or an unsafe expression `unsafe { e }`.\n+    if let rw @ Some(_) = rewrite_empty_block(context, block, attrs, &prefix, shape) {\n+        return rw;\n+    }\n+\n+    let result = rewrite_block_with_visitor(context, &prefix, block, attrs, shape, true);\n+    if let Some(ref result_str) = result {\n+        if result_str.lines().count() <= 3 {\n+            if let rw @ Some(_) = rewrite_single_line_block(context, &prefix, block, attrs, shape) {\n+                return rw;\n             }\n         }\n-\n-        result\n     }\n+\n+    result\n }\n \n impl Rewrite for ast::Stmt {\n@@ -889,8 +923,8 @@ impl<'a> ControlFlow<'a> {\n         let fixed_cost = self.keyword.len() + \"  {  } else {  }\".len();\n \n         if let ast::ExprKind::Block(ref else_node) = else_block.node {\n-            if !is_simple_block(self.block, context.codemap)\n-                || !is_simple_block(else_node, context.codemap)\n+            if !is_simple_block(self.block, None, context.codemap)\n+                || !is_simple_block(else_node, None, context.codemap)\n                 || pat_expr_str.contains('\\n')\n             {\n                 return None;\n@@ -1123,7 +1157,7 @@ impl<'a> Rewrite for ControlFlow<'a> {\n         let mut block_context = context.clone();\n         block_context.is_if_else_block = self.else_block.is_some();\n         let block_str =\n-            rewrite_block_with_visitor(&block_context, \"\", self.block, block_shape, true)?;\n+            rewrite_block_with_visitor(&block_context, \"\", self.block, None, block_shape, true)?;\n \n         let mut result = format!(\"{}{}\", cond_str, block_str);\n \n@@ -1234,22 +1268,39 @@ pub fn block_contains_comment(block: &ast::Block, codemap: &CodeMap) -> bool {\n     contains_comment(&snippet)\n }\n \n-// Checks that a block contains no statements, an expression and no comments.\n+// Checks that a block contains no statements, an expression and no comments or\n+// attributes.\n // FIXME: incorrectly returns false when comment is contained completely within\n // the expression.\n-pub fn is_simple_block(block: &ast::Block, codemap: &CodeMap) -> bool {\n+pub fn is_simple_block(\n+    block: &ast::Block,\n+    attrs: Option<&[ast::Attribute]>,\n+    codemap: &CodeMap,\n+) -> bool {\n     (block.stmts.len() == 1 && stmt_is_expr(&block.stmts[0])\n-        && !block_contains_comment(block, codemap))\n+        && !block_contains_comment(block, codemap) && attrs.map_or(true, |a| a.is_empty()))\n }\n \n-/// Checks whether a block contains at most one statement or expression, and no comments.\n-pub fn is_simple_block_stmt(block: &ast::Block, codemap: &CodeMap) -> bool {\n+/// Checks whether a block contains at most one statement or expression, and no\n+/// comments or attributes.\n+pub fn is_simple_block_stmt(\n+    block: &ast::Block,\n+    attrs: Option<&[ast::Attribute]>,\n+    codemap: &CodeMap,\n+) -> bool {\n     block.stmts.len() <= 1 && !block_contains_comment(block, codemap)\n+        && attrs.map_or(true, |a| a.is_empty())\n }\n \n-/// Checks whether a block contains no statements, expressions, or comments.\n-pub fn is_empty_block(block: &ast::Block, codemap: &CodeMap) -> bool {\n+/// Checks whether a block contains no statements, expressions, comments, or\n+/// inner attributes.\n+pub fn is_empty_block(\n+    block: &ast::Block,\n+    attrs: Option<&[ast::Attribute]>,\n+    codemap: &CodeMap,\n+) -> bool {\n     block.stmts.is_empty() && !block_contains_comment(block, codemap)\n+        && attrs.map_or(true, |a| inner_attributes(a).is_empty())\n }\n \n pub fn stmt_is_expr(stmt: &ast::Stmt) -> bool {\n@@ -1577,7 +1628,8 @@ fn rewrite_match_pattern(\n fn flatten_arm_body<'a>(context: &'a RewriteContext, body: &'a ast::Expr) -> (bool, &'a ast::Expr) {\n     match body.node {\n         ast::ExprKind::Block(ref block)\n-            if !is_unsafe_block(block) && is_simple_block(block, context.codemap) =>\n+            if !is_unsafe_block(block)\n+                && is_simple_block(block, Some(&body.attrs), context.codemap) =>\n         {\n             if let ast::StmtKind::Expr(ref expr) = block.stmts[0].node {\n                 (\n@@ -1605,7 +1657,10 @@ fn rewrite_match_body(\n ) -> Option<String> {\n     let (extend, body) = flatten_arm_body(context, body);\n     let (is_block, is_empty_block) = if let ast::ExprKind::Block(ref block) = body.node {\n-        (true, is_empty_block(block, context.codemap))\n+        (\n+            true,\n+            is_empty_block(block, Some(&body.attrs), context.codemap),\n+        )\n     } else {\n         (false, false)\n     };"}, {"sha": "6306767f00c25a9ea0c5dc75e126821cc62ec3ec", "filename": "src/items.rs", "status": "modified", "additions": 12, "deletions": 5, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/c5168405b0a730cd101b04a4892c14808487e6c2/src%2Fitems.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c5168405b0a730cd101b04a4892c14808487e6c2/src%2Fitems.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fitems.rs?ref=c5168405b0a730cd101b04a4892c14808487e6c2", "patch": "@@ -301,6 +301,7 @@ impl<'a> FmtVisitor<'a> {\n         fn_sig: &FnSig,\n         span: Span,\n         block: &ast::Block,\n+        inner_attrs: Option<&[ast::Attribute]>,\n     ) -> Option<String> {\n         let context = self.get_context();\n \n@@ -329,7 +330,8 @@ impl<'a> FmtVisitor<'a> {\n             result.push(' ');\n         }\n \n-        self.single_line_fn(&result, block).or_else(|| Some(result))\n+        self.single_line_fn(&result, block, inner_attrs)\n+            .or_else(|| Some(result))\n     }\n \n     pub fn rewrite_required_fn(\n@@ -360,20 +362,25 @@ impl<'a> FmtVisitor<'a> {\n         Some(result)\n     }\n \n-    fn single_line_fn(&self, fn_str: &str, block: &ast::Block) -> Option<String> {\n-        if fn_str.contains('\\n') {\n+    fn single_line_fn(\n+        &self,\n+        fn_str: &str,\n+        block: &ast::Block,\n+        inner_attrs: Option<&[ast::Attribute]>,\n+    ) -> Option<String> {\n+        if fn_str.contains('\\n') || inner_attrs.map_or(false, |a| !a.is_empty()) {\n             return None;\n         }\n \n         let codemap = self.get_context().codemap;\n \n-        if self.config.empty_item_single_line() && is_empty_block(block, codemap)\n+        if self.config.empty_item_single_line() && is_empty_block(block, None, codemap)\n             && self.block_indent.width() + fn_str.len() + 2 <= self.config.max_width()\n         {\n             return Some(format!(\"{}{{}}\", fn_str));\n         }\n \n-        if self.config.fn_single_line() && is_simple_block_stmt(block, codemap) {\n+        if self.config.fn_single_line() && is_simple_block_stmt(block, None, codemap) {\n             let rewrite = {\n                 if let Some(stmt) = block.stmts.first() {\n                     match stmt_expr(stmt) {"}, {"sha": "81f35d787ab84481d624993418b19012143a9762", "filename": "src/visitor.rs", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/c5168405b0a730cd101b04a4892c14808487e6c2/src%2Fvisitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c5168405b0a730cd101b04a4892c14808487e6c2/src%2Fvisitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fvisitor.rs?ref=c5168405b0a730cd101b04a4892c14808487e6c2", "patch": "@@ -268,6 +268,7 @@ impl<'b, 'a: 'b> FmtVisitor<'a> {\n                     &FnSig::from_fn_kind(&fk, generics, fd, defaultness),\n                     mk_sp(s.lo(), b.span.lo()),\n                     b,\n+                    inner_attrs,\n                 )\n             }\n             visit::FnKind::Closure(_) => unreachable!(),\n@@ -381,13 +382,14 @@ impl<'b, 'a: 'b> FmtVisitor<'a> {\n                 self.visit_static(&StaticParts::from_item(item));\n             }\n             ast::ItemKind::Fn(ref decl, unsafety, constness, abi, ref generics, ref body) => {\n+                let inner_attrs = inner_attributes(&item.attrs);\n                 self.visit_fn(\n                     visit::FnKind::ItemFn(item.ident, unsafety, constness, abi, &item.vis, body),\n                     generics,\n                     decl,\n                     item.span,\n                     ast::Defaultness::Final,\n-                    Some(&item.attrs),\n+                    Some(&inner_attrs),\n                 )\n             }\n             ast::ItemKind::Ty(ref ty, ref generics) => {\n@@ -438,13 +440,14 @@ impl<'b, 'a: 'b> FmtVisitor<'a> {\n                 self.push_rewrite(ti.span, rewrite);\n             }\n             ast::TraitItemKind::Method(ref sig, Some(ref body)) => {\n+                let inner_attrs = inner_attributes(&ti.attrs);\n                 self.visit_fn(\n                     visit::FnKind::Method(ti.ident, sig, None, body),\n                     &ti.generics,\n                     &sig.decl,\n                     ti.span,\n                     ast::Defaultness::Final,\n-                    Some(&ti.attrs),\n+                    Some(&inner_attrs),\n                 );\n             }\n             ast::TraitItemKind::Type(ref type_param_bounds, ref type_default) => {\n@@ -473,13 +476,14 @@ impl<'b, 'a: 'b> FmtVisitor<'a> {\n \n         match ii.node {\n             ast::ImplItemKind::Method(ref sig, ref body) => {\n+                let inner_attrs = inner_attributes(&ii.attrs);\n                 self.visit_fn(\n                     visit::FnKind::Method(ii.ident, sig, Some(&ii.vis), body),\n                     &ii.generics,\n                     &sig.decl,\n                     ii.span,\n                     ii.defaultness,\n-                    Some(&ii.attrs),\n+                    Some(&inner_attrs),\n                 );\n             }\n             ast::ImplItemKind::Const(..) => self.visit_static(&StaticParts::from_impl_item(ii)),"}, {"sha": "1e9557dc039edcdc4fc8b5d77930c51459ee9d2f", "filename": "tests/target/attrib-block-expr.rs", "status": "added", "additions": 58, "deletions": 0, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/c5168405b0a730cd101b04a4892c14808487e6c2/tests%2Ftarget%2Fattrib-block-expr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c5168405b0a730cd101b04a4892c14808487e6c2/tests%2Ftarget%2Fattrib-block-expr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ftarget%2Fattrib-block-expr.rs?ref=c5168405b0a730cd101b04a4892c14808487e6c2", "patch": "@@ -0,0 +1,58 @@\n+fn issue_2073() {\n+    let x = {\n+        #![my_attr]\n+        do_something()\n+    };\n+\n+    let x = #[my_attr]\n+    {\n+        do_something()\n+    };\n+\n+    let x = #[my_attr]\n+    {};\n+\n+    {\n+        #![just_an_attribute]\n+    };\n+\n+    let z = #[attr1]\n+    #[attr2]\n+    {\n+        body()\n+    };\n+\n+    x = |y| {\n+        #![inner]\n+    };\n+\n+    x = |y| #[outer]\n+    {};\n+\n+    x = |y| {\n+        //! ynot\n+    };\n+\n+    x = |y| #[outer]\n+    unsafe {};\n+\n+    let x = unsafe {\n+        #![my_attr]\n+        do_something()\n+    };\n+\n+    let x = #[my_attr]\n+    unsafe {\n+        do_something()\n+    };\n+\n+    // This is a dumb but possible case\n+    let x = #[my_attr]\n+    unsafe {};\n+\n+    x = |y| #[outer]\n+    #[outer2]\n+    unsafe {\n+        //! Comment\n+    };\n+}"}]}