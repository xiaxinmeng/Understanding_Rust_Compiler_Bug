{"sha": "3a075dce9af716a7512618bad6b37b00e559060d", "node_id": "MDY6Q29tbWl0NzI0NzEyOjNhMDc1ZGNlOWFmNzE2YTc1MTI2MThiYWQ2YjM3YjAwZTU1OTA2MGQ=", "commit": {"author": {"name": "Jorge Aparicio", "email": "japaricious@gmail.com", "date": "2014-11-02T03:36:30Z"}, "committer": {"name": "Jorge Aparicio", "email": "japaricious@gmail.com", "date": "2014-11-02T14:43:12Z"}, "message": "core: Replace secret formatting functions with UFCS versions", "tree": {"sha": "12085eca16a82bf1cbc3ffa46064cd1bcf2c6710", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/12085eca16a82bf1cbc3ffa46064cd1bcf2c6710"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3a075dce9af716a7512618bad6b37b00e559060d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3a075dce9af716a7512618bad6b37b00e559060d", "html_url": "https://github.com/rust-lang/rust/commit/3a075dce9af716a7512618bad6b37b00e559060d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3a075dce9af716a7512618bad6b37b00e559060d/comments", "author": null, "committer": null, "parents": [{"sha": "fc838ad0fd75fa294d3067e281105afd1a956f65", "url": "https://api.github.com/repos/rust-lang/rust/commits/fc838ad0fd75fa294d3067e281105afd1a956f65", "html_url": "https://github.com/rust-lang/rust/commit/fc838ad0fd75fa294d3067e281105afd1a956f65"}], "stats": {"total": 142, "additions": 138, "deletions": 4}, "files": [{"sha": "ddfbfa7850202ec28a3314c5dbcb3f342c1b47cd", "filename": "src/libcore/fmt/mod.rs", "status": "modified", "additions": 132, "deletions": 4, "changes": 136, "blob_url": "https://github.com/rust-lang/rust/blob/3a075dce9af716a7512618bad6b37b00e559060d/src%2Flibcore%2Ffmt%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3a075dce9af716a7512618bad6b37b00e559060d/src%2Flibcore%2Ffmt%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ffmt%2Fmod.rs?ref=3a075dce9af716a7512618bad6b37b00e559060d", "patch": "@@ -250,8 +250,8 @@ pub trait UpperExp for Sized? {\n     fn fmt(&self, &mut Formatter) -> Result;\n }\n \n-// FIXME #11938 - UFCS would make us able call the above methods\n-// directly Show::show(x, fmt).\n+// NOTE(stage0): Remove macro after next snapshot\n+#[cfg(stage0)]\n macro_rules! uniform_fn_call_workaround {\n     ($( $name: ident, $trait_: ident; )*) => {\n         $(\n@@ -262,6 +262,8 @@ macro_rules! uniform_fn_call_workaround {\n             )*\n     }\n }\n+// NOTE(stage0): Remove macro after next snapshot\n+#[cfg(stage0)]\n uniform_fn_call_workaround! {\n     secret_show, Show;\n     secret_bool, Bool;\n@@ -568,36 +570,65 @@ pub fn argument<'a, T>(f: extern \"Rust\" fn(&T, &mut Formatter) -> Result,\n \n /// When the compiler determines that the type of an argument *must* be a string\n /// (such as for select), then it invokes this method.\n+// NOTE(stage0): remove function after a snapshot\n+#[cfg(stage0)]\n #[doc(hidden)] #[inline]\n pub fn argumentstr<'a>(s: &'a &str) -> Argument<'a> {\n     argument(secret_string, s)\n }\n \n+/// When the compiler determines that the type of an argument *must* be a string\n+/// (such as for select), then it invokes this method.\n+#[cfg(not(stage0))]  // NOTE(stage0): remove cfg after a snapshot\n+#[doc(hidden)] #[inline]\n+pub fn argumentstr<'a>(s: &'a &str) -> Argument<'a> {\n+    argument(String::fmt, s)\n+}\n+\n /// When the compiler determines that the type of an argument *must* be a uint\n /// (such as for plural), then it invokes this method.\n+// NOTE(stage0): remove function after a snapshot\n+#[cfg(stage0)]\n #[doc(hidden)] #[inline]\n pub fn argumentuint<'a>(s: &'a uint) -> Argument<'a> {\n     argument(secret_unsigned, s)\n }\n \n+/// When the compiler determines that the type of an argument *must* be a uint\n+/// (such as for plural), then it invokes this method.\n+#[cfg(not(stage0))]  // NOTE(stage0): remove cfg after a snapshot\n+#[doc(hidden)] #[inline]\n+pub fn argumentuint<'a>(s: &'a uint) -> Argument<'a> {\n+    argument(Unsigned::fmt, s)\n+}\n+\n // Implementations of the core formatting traits\n \n impl<'a, Sized? T: Show> Show for &'a T {\n-    fn fmt(&self, f: &mut Formatter) -> Result { secret_show(*self, f) }\n+    fn fmt(&self, f: &mut Formatter) -> Result { (**self).fmt(f) }\n }\n impl<'a, Sized? T: Show> Show for &'a mut T {\n-    fn fmt(&self, f: &mut Formatter) -> Result { secret_show(&**self, f) }\n+    fn fmt(&self, f: &mut Formatter) -> Result { (**self).fmt(f) }\n }\n impl<'a> Show for &'a Show+'a {\n     fn fmt(&self, f: &mut Formatter) -> Result { (*self).fmt(f) }\n }\n \n+// NOTE(stage0): remove impl after a snapshot\n+#[cfg(stage0)]\n impl Bool for bool {\n     fn fmt(&self, f: &mut Formatter) -> Result {\n         secret_string(&(if *self {\"true\"} else {\"false\"}), f)\n     }\n }\n \n+#[cfg(not(stage0))]  // NOTE(stage0): remove cfg after a snapshot\n+impl Bool for bool {\n+    fn fmt(&self, f: &mut Formatter) -> Result {\n+        String::fmt(if *self { \"true\" } else { \"false\" }, f)\n+    }\n+}\n+\n impl<T: str::Str> String for T {\n     fn fmt(&self, f: &mut Formatter) -> Result {\n         f.pad(self.as_slice())\n@@ -610,6 +641,8 @@ impl String for str {\n     }\n }\n \n+// NOTE(stage0): remove impl after a snapshot\n+#[cfg(stage0)]\n impl Char for char {\n     fn fmt(&self, f: &mut Formatter) -> Result {\n         use char::Char;\n@@ -621,28 +654,80 @@ impl Char for char {\n     }\n }\n \n+#[cfg(not(stage0))]  // NOTE(stage0): remove cfg after a snapshot\n+impl Char for char {\n+    fn fmt(&self, f: &mut Formatter) -> Result {\n+        use char::Char;\n+\n+        let mut utf8 = [0u8, ..4];\n+        let amt = self.encode_utf8(utf8).unwrap_or(0);\n+        let s: &str = unsafe { mem::transmute(utf8[..amt]) };\n+        String::fmt(s, f)\n+    }\n+}\n+\n+// NOTE(stage0): remove impl after a snapshot\n+#[cfg(stage0)]\n impl<T> Pointer for *const T {\n     fn fmt(&self, f: &mut Formatter) -> Result {\n         f.flags |= 1 << (rt::FlagAlternate as uint);\n         secret_lower_hex::<uint>(&(*self as uint), f)\n     }\n }\n+\n+#[cfg(not(stage0))]  // NOTE(stage0): remove cfg after a snapshot\n+impl<T> Pointer for *const T {\n+    fn fmt(&self, f: &mut Formatter) -> Result {\n+        f.flags |= 1 << (rt::FlagAlternate as uint);\n+        LowerHex::fmt(&(*self as uint), f)\n+    }\n+}\n+\n+// NOTE(stage0): remove impl after a snapshot\n+#[cfg(stage0)]\n impl<T> Pointer for *mut T {\n     fn fmt(&self, f: &mut Formatter) -> Result {\n         secret_pointer::<*const T>(&(*self as *const T), f)\n     }\n }\n+\n+#[cfg(not(stage0))]  // NOTE(stage0): remove cfg after a snapshot\n+impl<T> Pointer for *mut T {\n+    fn fmt(&self, f: &mut Formatter) -> Result {\n+        Pointer::fmt(&(*self as *const T), f)\n+    }\n+}\n+\n+// NOTE(stage0): remove impl after a snapshot\n+#[cfg(stage0)]\n impl<'a, T> Pointer for &'a T {\n     fn fmt(&self, f: &mut Formatter) -> Result {\n         secret_pointer::<*const T>(&(&**self as *const T), f)\n     }\n }\n+\n+#[cfg(not(stage0))]  // NOTE(stage0): remove cfg after a snapshot\n+impl<'a, T> Pointer for &'a T {\n+    fn fmt(&self, f: &mut Formatter) -> Result {\n+        Pointer::fmt(&(*self as *const T), f)\n+    }\n+}\n+\n+// NOTE(stage0): remove impl after a snapshot\n+#[cfg(stage0)]\n impl<'a, T> Pointer for &'a mut T {\n     fn fmt(&self, f: &mut Formatter) -> Result {\n         secret_pointer::<*const T>(&(&**self as *const T), f)\n     }\n }\n \n+#[cfg(not(stage0))]  // NOTE(stage0): remove cfg after a snapshot\n+impl<'a, T> Pointer for &'a mut T {\n+    fn fmt(&self, f: &mut Formatter) -> Result {\n+        Pointer::fmt(&(&**self as *const T), f)\n+    }\n+}\n+\n macro_rules! floating(($ty:ident) => {\n     impl Float for $ty {\n         fn fmt(&self, fmt: &mut Formatter) -> Result {\n@@ -712,26 +797,69 @@ floating!(f64)\n \n // Implementation of Show for various core types\n \n+// NOTE(stage0): remove macro after a snapshot\n+#[cfg(stage0)]\n macro_rules! delegate(($ty:ty to $other:ident) => {\n     impl Show for $ty {\n         fn fmt(&self, f: &mut Formatter) -> Result {\n             (concat_idents!(secret_, $other)(self, f))\n         }\n     }\n })\n+\n+// NOTE(stage0): remove these macros after a snapshot\n+#[cfg(stage0)]\n delegate!(str to string)\n+#[cfg(stage0)]\n delegate!(bool to bool)\n+#[cfg(stage0)]\n delegate!(char to char)\n+#[cfg(stage0)]\n delegate!(f32 to float)\n+#[cfg(stage0)]\n delegate!(f64 to float)\n \n+#[cfg(not(stage0))]  // NOTE(stage0): remove cfg after a snapshot\n+macro_rules! delegate(($ty:ty to $other:ident) => {\n+    impl Show for $ty {\n+        fn fmt(&self, f: &mut Formatter) -> Result {\n+            $other::fmt(self, f)\n+        }\n+    }\n+})\n+#[cfg(not(stage0))]  // NOTE(stage0): remove cfg after a snapshot\n+delegate!(str to String)\n+#[cfg(not(stage0))]  // NOTE(stage0): remove cfg after a snapshot\n+delegate!(bool to Bool)\n+#[cfg(not(stage0))]  // NOTE(stage0): remove cfg after a snapshot\n+delegate!(char to Char)\n+#[cfg(not(stage0))]  // NOTE(stage0): remove cfg after a snapshot\n+delegate!(f32 to Float)\n+#[cfg(not(stage0))]  // NOTE(stage0): remove cfg after a snapshot\n+delegate!(f64 to Float)\n+\n+// NOTE(stage0): remove impl after a snapshot\n+#[cfg(stage0)]\n impl<T> Show for *const T {\n     fn fmt(&self, f: &mut Formatter) -> Result { secret_pointer(self, f) }\n }\n+\n+#[cfg(not(stage0))]  // NOTE(stage0): remove cfg after a snapshot\n+impl<T> Show for *const T {\n+    fn fmt(&self, f: &mut Formatter) -> Result { Pointer::fmt(self, f) }\n+}\n+\n+// NOTE(stage0): remove impl after a snapshot\n+#[cfg(stage0)]\n impl<T> Show for *mut T {\n     fn fmt(&self, f: &mut Formatter) -> Result { secret_pointer(self, f) }\n }\n \n+#[cfg(not(stage0))]  // NOTE(stage0): remove cfg after a snapshot\n+impl<T> Show for *mut T {\n+    fn fmt(&self, f: &mut Formatter) -> Result { Pointer::fmt(self, f) }\n+}\n+\n macro_rules! peel(($name:ident, $($other:ident,)*) => (tuple!($($other,)*)))\n \n macro_rules! tuple ("}, {"sha": "cb151dd9c0abfa6b16bde7228a84c054504ade54", "filename": "src/libstd/fmt.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/3a075dce9af716a7512618bad6b37b00e559060d/src%2Flibstd%2Ffmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3a075dce9af716a7512618bad6b37b00e559060d/src%2Flibstd%2Ffmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ffmt.rs?ref=3a075dce9af716a7512618bad6b37b00e559060d", "patch": "@@ -424,14 +424,20 @@ pub use core::fmt::{Argument, Arguments, write, radix, Radix, RadixFmt};\n \n #[doc(hidden)]\n pub use core::fmt::{argument, argumentstr, argumentuint};\n+// NOTE(stage0): remove these imports after a snapshot\n+#[cfg(stage0)]\n #[doc(hidden)]\n pub use core::fmt::{secret_show, secret_string, secret_unsigned};\n+#[cfg(stage0)]\n #[doc(hidden)]\n pub use core::fmt::{secret_signed, secret_lower_hex, secret_upper_hex};\n+#[cfg(stage0)]\n #[doc(hidden)]\n pub use core::fmt::{secret_bool, secret_char, secret_octal, secret_binary};\n+#[cfg(stage0)]\n #[doc(hidden)]\n pub use core::fmt::{secret_float, secret_upper_exp, secret_lower_exp};\n+#[cfg(stage0)]\n #[doc(hidden)]\n pub use core::fmt::{secret_pointer};\n "}]}