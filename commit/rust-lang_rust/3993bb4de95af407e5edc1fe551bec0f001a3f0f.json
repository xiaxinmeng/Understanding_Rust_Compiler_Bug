{"sha": "3993bb4de95af407e5edc1fe551bec0f001a3f0f", "node_id": "MDY6Q29tbWl0NzI0NzEyOjM5OTNiYjRkZTk1YWY0MDdlNWVkYzFmZTU1MWJlYzBmMDAxYTNmMGY=", "commit": {"author": {"name": "bors[bot]", "email": "bors[bot]@users.noreply.github.com", "date": "2018-09-15T21:11:25Z"}, "committer": {"name": "bors[bot]", "email": "bors[bot]@users.noreply.github.com", "date": "2018-09-15T21:11:25Z"}, "message": "Merge #67\n\n67: Salsa r=matklad a=matklad\n\nThe aim of this PR is to transition from rather ad-hock FileData and ModuleMap caching strategy to something resembling a general-purpose red-green engine. \r\n\r\nIdeally, we shouldn't recompute ModuleMap at all, unless the set of mod decls or files changes.\r\n\r\n\n\nCo-authored-by: Aleksey Kladov <aleksey.kladov@gmail.com>", "tree": {"sha": "31893552cd739187080048df24a629d416174305", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/31893552cd739187080048df24a629d416174305"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3993bb4de95af407e5edc1fe551bec0f001a3f0f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3993bb4de95af407e5edc1fe551bec0f001a3f0f", "html_url": "https://github.com/rust-lang/rust/commit/3993bb4de95af407e5edc1fe551bec0f001a3f0f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3993bb4de95af407e5edc1fe551bec0f001a3f0f/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "parents": [{"sha": "2a56b5c4f096736d6795eecb835cc2dc14b00107", "url": "https://api.github.com/repos/rust-lang/rust/commits/2a56b5c4f096736d6795eecb835cc2dc14b00107", "html_url": "https://github.com/rust-lang/rust/commit/2a56b5c4f096736d6795eecb835cc2dc14b00107"}, {"sha": "fcdf3a52b4b61a39474950486ea0edf5ebf33bea", "url": "https://api.github.com/repos/rust-lang/rust/commits/fcdf3a52b4b61a39474950486ea0edf5ebf33bea", "html_url": "https://github.com/rust-lang/rust/commit/fcdf3a52b4b61a39474950486ea0edf5ebf33bea"}], "stats": {"total": 1738, "additions": 1285, "deletions": 453}, "files": [{"sha": "88f29d7c869a0dfca36891dda7d2e7fe621e1b9b", "filename": "crates/libanalysis/Cargo.toml", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3993bb4de95af407e5edc1fe551bec0f001a3f0f/crates%2Flibanalysis%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/3993bb4de95af407e5edc1fe551bec0f001a3f0f/crates%2Flibanalysis%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Flibanalysis%2FCargo.toml?ref=3993bb4de95af407e5edc1fe551bec0f001a3f0f", "patch": "@@ -11,8 +11,10 @@ parking_lot = \"0.6.3\"\n once_cell = \"0.1.5\"\n rayon = \"1.0.2\"\n fst = \"0.3.1\"\n+im = \"12.0.0\"\n libsyntax2 = { path = \"../libsyntax2\" }\n libeditor = { path = \"../libeditor\" }\n+salsa = { path = \"../salsa\" }\n \n [dev-dependencies]\n test_utils = { path = \"../test_utils\" }"}, {"sha": "f26be104638a152ca18f204e2a5be6167199dfcb", "filename": "crates/libanalysis/src/db/imp.rs", "status": "added", "additions": 152, "deletions": 0, "changes": 152, "blob_url": "https://github.com/rust-lang/rust/blob/3993bb4de95af407e5edc1fe551bec0f001a3f0f/crates%2Flibanalysis%2Fsrc%2Fdb%2Fimp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3993bb4de95af407e5edc1fe551bec0f001a3f0f/crates%2Flibanalysis%2Fsrc%2Fdb%2Fimp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Flibanalysis%2Fsrc%2Fdb%2Fimp.rs?ref=3993bb4de95af407e5edc1fe551bec0f001a3f0f", "patch": "@@ -0,0 +1,152 @@\n+use std::{\n+    sync::Arc,\n+    any::Any,\n+    hash::{Hash, Hasher},\n+    collections::hash_map::{DefaultHasher, HashMap},\n+    iter,\n+};\n+use salsa;\n+use {FileId, imp::FileResolverImp};\n+use super::{State, Query, QueryCtx};\n+\n+pub(super) type Data = Arc<Any + Send + Sync + 'static>;\n+\n+#[derive(Debug)]\n+pub(super) struct Db {\n+    names: Arc<HashMap<salsa::QueryTypeId, &'static str>>,\n+    pub(super) imp: salsa::Db<State, Data>,\n+}\n+\n+impl Db {\n+    pub(super) fn new(mut reg: QueryRegistry) -> Db {\n+        let config = reg.config.take().unwrap();\n+        Db {\n+            names: Arc::new(reg.names),\n+            imp: salsa::Db::new(config, State::default())\n+        }\n+    }\n+    pub(crate) fn with_changes(&self, new_state: State, changed_files: &[FileId], resolver_changed: bool) -> Db {\n+        let names = self.names.clone();\n+        let mut invalidations = salsa::Invalidations::new();\n+        invalidations.invalidate(FILE_TEXT, changed_files.iter().map(hash).map(salsa::InputFingerprint));\n+        if resolver_changed {\n+            invalidations.invalidate(FILE_SET, iter::once(salsa::InputFingerprint(hash(&()))));\n+        } else {\n+            invalidations.invalidate(FILE_SET, iter::empty());\n+        }\n+        let imp = self.imp.with_ground_data(\n+            new_state,\n+            invalidations,\n+        );\n+        Db { names, imp }\n+    }\n+    pub(super) fn extract_trace(&self, ctx: &salsa::QueryCtx<State, Data>) -> Vec<&'static str> {\n+        ctx.trace().into_iter().map(|it| self.names[&it]).collect()\n+    }\n+}\n+\n+pub(crate) trait EvalQuery {\n+    type Params;\n+    type Output;\n+    fn query_type(&self) -> salsa::QueryTypeId;\n+    fn f(&self) -> salsa::QueryFn<State, Data>;\n+    fn get(&self, &QueryCtx, Self::Params) -> Arc<Self::Output>;\n+}\n+\n+impl<T, R> EvalQuery for Query<T, R>\n+where\n+    T: Hash + Send + Sync + 'static,\n+    R: Hash + Send + Sync + 'static,\n+{\n+    type Params = T;\n+    type Output = R;\n+    fn query_type(&self) -> salsa::QueryTypeId {\n+        salsa::QueryTypeId(self.0)\n+    }\n+    fn f(&self) -> salsa::QueryFn<State, Data> {\n+        let f = self.1;\n+        Box::new(move |ctx, data| {\n+            let ctx = QueryCtx { imp: ctx };\n+            let data: &T = data.downcast_ref().unwrap();\n+            let res = f(ctx, data);\n+            let h = hash(&res);\n+            (Arc::new(res), salsa::OutputFingerprint(h))\n+        })\n+    }\n+    fn get(&self, ctx: &QueryCtx, params: Self::Params) -> Arc<Self::Output> {\n+        let query_id = salsa::QueryId(\n+            self.query_type(),\n+            salsa::InputFingerprint(hash(&params)),\n+        );\n+        let res = ctx.imp.get(query_id, Arc::new(params));\n+        res.downcast().unwrap()\n+    }\n+}\n+\n+pub(super) struct QueryRegistry {\n+    config: Option<salsa::QueryConfig<State, Data>>,\n+    names: HashMap<salsa::QueryTypeId, &'static str>,\n+}\n+\n+impl QueryRegistry {\n+    pub(super) fn new() -> QueryRegistry {\n+        let mut config = salsa::QueryConfig::<State, Data>::new();\n+        config = config.with_ground_query(\n+            FILE_TEXT, Box::new(|state, params| {\n+                let file_id: &FileId = params.downcast_ref().unwrap();\n+                let res = state.file_map[file_id].clone();\n+                let fingerprint = salsa::OutputFingerprint(hash(&res));\n+                (res, fingerprint)\n+            })\n+        );\n+        config = config.with_ground_query(\n+            FILE_SET, Box::new(|state, _params| {\n+                let file_ids: Vec<FileId> = state.file_map.keys().cloned().collect();\n+                let hash = hash(&file_ids);\n+                let file_resolver = state.file_resolver.clone();\n+                let res = (file_ids, file_resolver);\n+                let fingerprint = salsa::OutputFingerprint(hash);\n+                (Arc::new(res), fingerprint)\n+            })\n+        );\n+        let mut names = HashMap::new();\n+        names.insert(FILE_TEXT, \"FILE_TEXT\");\n+        names.insert(FILE_SET, \"FILE_SET\");\n+        QueryRegistry { config: Some(config), names }\n+    }\n+    pub(super) fn add<Q: EvalQuery>(&mut self, q: Q, name: &'static str) {\n+        let id = q.query_type();\n+        let prev = self.names.insert(id, name);\n+        assert!(prev.is_none(), \"duplicate query: {:?}\", id);\n+        let config = self.config.take().unwrap();\n+        let config = config.with_query(id, q.f());\n+        self.config= Some(config);\n+    }\n+}\n+\n+fn hash<T: Hash>(x: &T) -> u64 {\n+    let mut hasher = DefaultHasher::new();\n+    x.hash(&mut hasher);\n+    hasher.finish()\n+}\n+\n+const FILE_TEXT: salsa::QueryTypeId = salsa::QueryTypeId(0);\n+pub(super) fn file_text(ctx: QueryCtx, file_id: FileId) -> Arc<String> {\n+    let query_id = salsa::QueryId(\n+        FILE_TEXT,\n+        salsa::InputFingerprint(hash(&file_id)),\n+    );\n+    let res = ctx.imp.get(query_id, Arc::new(file_id));\n+    res.downcast().unwrap()\n+}\n+\n+const FILE_SET: salsa::QueryTypeId = salsa::QueryTypeId(1);\n+pub(super) fn file_set(ctx: QueryCtx) -> Arc<(Vec<FileId>, FileResolverImp)> {\n+    let query_id = salsa::QueryId(\n+        FILE_SET,\n+        salsa::InputFingerprint(hash(&())),\n+    );\n+    let res = ctx.imp.get(query_id, Arc::new(()));\n+    res.downcast().unwrap()\n+}\n+"}, {"sha": "22769d1120e504452e51de960f93aed61a80b258", "filename": "crates/libanalysis/src/db/mod.rs", "status": "added", "additions": 85, "deletions": 0, "changes": 85, "blob_url": "https://github.com/rust-lang/rust/blob/3993bb4de95af407e5edc1fe551bec0f001a3f0f/crates%2Flibanalysis%2Fsrc%2Fdb%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3993bb4de95af407e5edc1fe551bec0f001a3f0f/crates%2Flibanalysis%2Fsrc%2Fdb%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Flibanalysis%2Fsrc%2Fdb%2Fmod.rs?ref=3993bb4de95af407e5edc1fe551bec0f001a3f0f", "patch": "@@ -0,0 +1,85 @@\n+mod imp;\n+\n+use std::{\n+    sync::Arc,\n+};\n+use im;\n+use salsa;\n+use {FileId, imp::FileResolverImp};\n+\n+#[derive(Debug, Default, Clone)]\n+pub(crate) struct State {\n+    pub(crate) file_map: im::HashMap<FileId, Arc<String>>,\n+    pub(crate) file_resolver: FileResolverImp\n+}\n+\n+#[derive(Debug)]\n+pub(crate) struct Db {\n+    imp: imp::Db,\n+}\n+\n+#[derive(Clone, Copy)]\n+pub(crate) struct QueryCtx<'a> {\n+    imp: &'a salsa::QueryCtx<State, imp::Data>,\n+}\n+\n+pub(crate) struct Query<T, R>(pub(crate) u16, pub(crate) fn(QueryCtx, &T) -> R);\n+\n+pub(crate) struct QueryRegistry {\n+    imp: imp::QueryRegistry,\n+}\n+\n+impl Default for Db {\n+    fn default() -> Db {\n+        Db::new()\n+    }\n+}\n+\n+impl Db {\n+    pub(crate) fn new() -> Db {\n+        let reg = QueryRegistry::new();\n+        Db { imp: imp::Db::new(reg.imp) }\n+    }\n+    pub(crate) fn state(&self) -> &State {\n+        self.imp.imp.ground_data()\n+    }\n+    pub(crate) fn with_changes(&self, new_state: State, changed_files: &[FileId], resolver_changed: bool) -> Db {\n+        Db { imp: self.imp.with_changes(new_state, changed_files, resolver_changed) }\n+    }\n+    pub(crate) fn make_query<F: FnOnce(QueryCtx) -> R, R>(&self, f: F) -> R {\n+        let ctx = QueryCtx { imp: &self.imp.imp.query_ctx() };\n+        f(ctx)\n+    }\n+    #[allow(unused)]\n+    pub(crate) fn trace_query<F: FnOnce(QueryCtx) -> R, R>(&self, f: F) -> (R, Vec<&'static str>) {\n+        let ctx = QueryCtx { imp: &self.imp.imp.query_ctx() };\n+        let res = f(ctx);\n+        let trace = self.imp.extract_trace(ctx.imp);\n+        (res, trace)\n+    }\n+}\n+\n+impl<'a> QueryCtx<'a> {\n+    pub(crate) fn get<Q: imp::EvalQuery>(&self, q: Q, params: Q::Params) -> Arc<Q::Output> {\n+        q.get(self, params)\n+    }\n+}\n+\n+pub(crate) fn file_text(ctx: QueryCtx, file_id: FileId) -> Arc<String> {\n+    imp::file_text(ctx, file_id)\n+}\n+\n+pub(crate) fn file_set(ctx: QueryCtx) -> Arc<(Vec<FileId>, FileResolverImp)> {\n+    imp::file_set(ctx)\n+}\n+impl QueryRegistry {\n+    fn new() -> QueryRegistry {\n+        let mut reg = QueryRegistry { imp: imp::QueryRegistry::new() };\n+        ::queries::register_queries(&mut reg);\n+        ::module_map::register_queries(&mut reg);\n+        reg\n+    }\n+    pub(crate) fn add<Q: imp::EvalQuery>(&mut self, q: Q, name: &'static str) {\n+        self.imp.add(q, name)\n+    }\n+}"}, {"sha": "93a4158e4412bb287369c2155e8550d736d96f99", "filename": "crates/libanalysis/src/descriptors.rs", "status": "added", "additions": 220, "deletions": 0, "changes": 220, "blob_url": "https://github.com/rust-lang/rust/blob/3993bb4de95af407e5edc1fe551bec0f001a3f0f/crates%2Flibanalysis%2Fsrc%2Fdescriptors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3993bb4de95af407e5edc1fe551bec0f001a3f0f/crates%2Flibanalysis%2Fsrc%2Fdescriptors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Flibanalysis%2Fsrc%2Fdescriptors.rs?ref=3993bb4de95af407e5edc1fe551bec0f001a3f0f", "patch": "@@ -0,0 +1,220 @@\n+use std::{\n+    collections::BTreeMap,\n+};\n+use relative_path::RelativePathBuf;\n+use libsyntax2::{\n+    SmolStr,\n+    ast::{self, NameOwner},\n+};\n+use {\n+    FileId,\n+    imp::FileResolverImp,\n+};\n+\n+#[derive(Debug, Hash)]\n+pub struct ModuleDescriptor {\n+    pub submodules: Vec<Submodule>\n+}\n+\n+impl ModuleDescriptor {\n+    pub fn new(root: ast::Root) -> ModuleDescriptor {\n+        let submodules = modules(root)\n+            .map(|(name, _)| Submodule { name })\n+            .collect();\n+\n+        ModuleDescriptor { submodules } }\n+}\n+\n+fn modules<'a>(root: ast::Root<'a>) -> impl Iterator<Item=(SmolStr, ast::Module<'a>)> {\n+    root\n+        .modules()\n+        .filter_map(|module| {\n+            let name = module.name()?.text();\n+            if !module.has_semi() {\n+                return None;\n+            }\n+            Some((name, module))\n+        })\n+}\n+\n+#[derive(Clone, Hash, PartialEq, Eq, Debug)]\n+pub struct Submodule {\n+    pub name: SmolStr,\n+}\n+\n+#[derive(Hash, Debug)]\n+pub(crate) struct ModuleTreeDescriptor {\n+    nodes: Vec<NodeData>,\n+    links: Vec<LinkData>,\n+    file_id2node: BTreeMap<FileId, Node>,\n+}\n+\n+#[derive(Clone, Copy, PartialEq, Eq, Hash, Debug)]\n+struct Node(usize);\n+#[derive(Hash, Debug)]\n+struct NodeData {\n+    file_id: FileId,\n+    links: Vec<Link>,\n+    parents: Vec<Link>\n+}\n+\n+#[derive(Clone, Copy, PartialEq, Eq, Hash, Debug)]\n+pub(crate) struct Link(usize);\n+#[derive(Hash, Debug)]\n+struct LinkData {\n+    owner: Node,\n+    name: SmolStr,\n+    points_to: Vec<Node>,\n+    problem: Option<Problem>,\n+}\n+\n+\n+#[derive(Clone, Debug, Hash)]\n+pub enum Problem {\n+    UnresolvedModule {\n+        candidate: RelativePathBuf,\n+    },\n+    NotDirOwner {\n+        move_to: RelativePathBuf,\n+        candidate: RelativePathBuf,\n+    }\n+}\n+\n+impl ModuleTreeDescriptor {\n+    pub(crate) fn new<'a>(\n+        files: impl Iterator<Item=(FileId, &'a ModuleDescriptor)> + Clone,\n+        file_resolver: &FileResolverImp,\n+    ) -> ModuleTreeDescriptor {\n+        let mut file_id2node = BTreeMap::new();\n+        let mut nodes: Vec<NodeData> = files.clone().enumerate()\n+            .map(|(idx, (file_id, _))| {\n+                file_id2node.insert(file_id, Node(idx));\n+                NodeData {\n+                    file_id,\n+                    links: Vec::new(),\n+                    parents: Vec::new(),\n+                }\n+            })\n+            .collect();\n+        let mut links = Vec::new();\n+\n+        for (idx, (file_id, descr)) in files.enumerate() {\n+            let owner = Node(idx);\n+            for sub in descr.submodules.iter() {\n+                let link = Link(links.len());\n+                nodes[owner.0].links.push(link);\n+                let (points_to, problem) = resolve_submodule(file_id, &sub.name, file_resolver);\n+                let points_to = points_to\n+                    .into_iter()\n+                    .map(|file_id| {\n+                        let node = file_id2node[&file_id];\n+                        nodes[node.0].parents.push(link);\n+                        node\n+                    })\n+                    .collect();\n+\n+                links.push(LinkData {\n+                    owner,\n+                    name: sub.name.clone(),\n+                    points_to,\n+                    problem,\n+                })\n+\n+            }\n+        }\n+\n+        ModuleTreeDescriptor {\n+            nodes, links, file_id2node\n+        }\n+    }\n+\n+    pub(crate) fn parent_modules(&self, file_id: FileId) -> Vec<Link> {\n+        let node = self.file_id2node[&file_id];\n+        self.node(node)\n+            .parents\n+            .clone()\n+    }\n+    pub(crate) fn child_module_by_name(&self, file_id: FileId, name: &str) -> Vec<FileId> {\n+        let node = self.file_id2node[&file_id];\n+        self.node(node)\n+            .links\n+            .iter()\n+            .filter(|it| it.name(self) == name)\n+            .flat_map(|link| link.points_to(self).iter().map(|&node| self.node(node).file_id))\n+            .collect()\n+    }\n+    pub(crate) fn problems<'a, 'b>(&'b self, file_id: FileId, root: ast::Root<'a>) -> Vec<(ast::Name<'a>, &'b Problem)> {\n+        let node = self.file_id2node[&file_id];\n+        self.node(node)\n+            .links\n+            .iter()\n+            .filter_map(|&link| {\n+                let problem = self.link(link).problem.as_ref()?;\n+                let name = link.bind_source(self, root).name()?;\n+                Some((name, problem))\n+            })\n+            .collect()\n+    }\n+\n+    fn node(&self, node: Node) -> &NodeData {\n+        &self.nodes[node.0]\n+    }\n+    fn link(&self, link: Link) -> &LinkData {\n+        &self.links[link.0]\n+    }\n+}\n+\n+impl Link {\n+    pub(crate) fn name(self, tree: &ModuleTreeDescriptor) -> SmolStr {\n+        tree.link(self).name.clone()\n+    }\n+    pub(crate) fn owner(self, tree: &ModuleTreeDescriptor) -> FileId {\n+        let owner = tree.link(self).owner;\n+        tree.node(owner).file_id\n+    }\n+    fn points_to(self, tree: &ModuleTreeDescriptor) -> &[Node] {\n+        &tree.link(self).points_to\n+    }\n+    pub(crate) fn bind_source<'a>(self, tree: &ModuleTreeDescriptor, root: ast::Root<'a>) -> ast::Module<'a> {\n+        modules(root)\n+            .filter(|(name, _)| name == &tree.link(self).name)\n+            .next()\n+            .unwrap()\n+            .1\n+    }\n+}\n+\n+\n+fn resolve_submodule(\n+    file_id: FileId,\n+    name: &SmolStr,\n+    file_resolver: &FileResolverImp\n+) -> (Vec<FileId>, Option<Problem>) {\n+    let mod_name = file_resolver.file_stem(file_id);\n+    let is_dir_owner =\n+        mod_name == \"mod\" || mod_name == \"lib\" || mod_name == \"main\";\n+\n+    let file_mod = RelativePathBuf::from(format!(\"../{}.rs\", name));\n+    let dir_mod = RelativePathBuf::from(format!(\"../{}/mod.rs\", name));\n+    let points_to: Vec<FileId>;\n+    let problem: Option<Problem>;\n+    if is_dir_owner {\n+        points_to = [&file_mod, &dir_mod].iter()\n+            .filter_map(|path| file_resolver.resolve(file_id, path))\n+            .collect();\n+        problem = if points_to.is_empty() {\n+            Some(Problem::UnresolvedModule {\n+                candidate: file_mod,\n+            })\n+        } else {\n+            None\n+        }\n+    } else {\n+        points_to = Vec::new();\n+        problem = Some(Problem::NotDirOwner {\n+            move_to: RelativePathBuf::from(format!(\"../{}/mod.rs\", mod_name)),\n+            candidate: file_mod,\n+        });\n+    }\n+    (points_to, problem)\n+}"}, {"sha": "6f3191fe7311f8ef4a7f729767d6609ec151bc2b", "filename": "crates/libanalysis/src/imp.rs", "status": "modified", "additions": 62, "deletions": 84, "changes": 146, "blob_url": "https://github.com/rust-lang/rust/blob/3993bb4de95af407e5edc1fe551bec0f001a3f0f/crates%2Flibanalysis%2Fsrc%2Fimp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3993bb4de95af407e5edc1fe551bec0f001a3f0f/crates%2Flibanalysis%2Fsrc%2Fimp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Flibanalysis%2Fsrc%2Fimp.rs?ref=3993bb4de95af407e5edc1fe551bec0f001a3f0f", "patch": "@@ -5,6 +5,7 @@ use std::{\n     },\n     fmt,\n     collections::{HashSet, VecDeque},\n+    iter,\n };\n \n use relative_path::RelativePath;\n@@ -18,8 +19,8 @@ use libsyntax2::{\n use {\n     FileId, FileResolver, Query, Diagnostic, SourceChange, SourceFileEdit, Position, FileSystemEdit,\n     JobToken, CrateGraph, CrateId,\n-    module_map::{ModuleMap, Problem},\n     roots::{SourceRoot, ReadonlySourceRoot, WritableSourceRoot},\n+    descriptors::{ModuleTreeDescriptor, Problem},\n };\n \n \n@@ -75,14 +76,12 @@ impl AnalysisHostImpl {\n     }\n     pub fn change_files(&mut self, changes: &mut dyn Iterator<Item=(FileId, Option<String>)>) {\n         let data = self.data_mut();\n-        for (file_id, text) in changes {\n-            data.root.update(file_id, text);\n-        }\n+        data.root = Arc::new(data.root.apply_changes(changes, None));\n     }\n     pub fn set_file_resolver(&mut self, resolver: FileResolverImp) {\n         let data = self.data_mut();\n         data.file_resolver = resolver.clone();\n-        data.root.set_file_resolver(resolver);\n+        data.root = Arc::new(data.root.apply_changes(&mut iter::empty(), Some(resolver)));\n     }\n     pub fn set_crate_graph(&mut self, graph: CrateGraph) {\n         let mut visited = HashSet::new();\n@@ -124,18 +123,17 @@ impl Clone for AnalysisImpl {\n impl AnalysisImpl {\n     fn root(&self, file_id: FileId) -> &SourceRoot {\n         if self.data.root.contains(file_id) {\n-            return &self.data.root;\n+            return &*self.data.root;\n         }\n         &**self.data.libs.iter().find(|it| it.contains(file_id)).unwrap()\n     }\n-    pub fn file_syntax(&self, file_id: FileId) -> &File {\n+    pub fn file_syntax(&self, file_id: FileId) -> File {\n         self.root(file_id).syntax(file_id)\n     }\n-    pub fn file_line_index(&self, file_id: FileId) -> &LineIndex {\n+    pub fn file_line_index(&self, file_id: FileId) -> Arc<LineIndex> {\n         self.root(file_id).lines(file_id)\n     }\n     pub fn world_symbols(&self, query: Query, token: &JobToken) -> Vec<(FileId, FileSymbol)> {\n-        self.reindex();\n         let mut buf = Vec::new();\n         if query.libs {\n             self.data.libs.iter()\n@@ -148,25 +146,24 @@ impl AnalysisImpl {\n     }\n     pub fn parent_module(&self, file_id: FileId) -> Vec<(FileId, FileSymbol)> {\n         let root = self.root(file_id);\n-        let module_map = root.module_map();\n-        let id = module_map.file2module(file_id);\n-        module_map\n-            .parent_modules(id, &|file_id| root.syntax(file_id))\n-            .into_iter()\n-            .map(|(id, name, node)| {\n-                let id = module_map.module2file(id);\n+        let module_tree = root.module_tree();\n+        module_tree.parent_modules(file_id)\n+            .iter()\n+            .map(|link| {\n+                let file_id = link.owner(&module_tree);\n+                let syntax = root.syntax(file_id);\n+                let decl = link.bind_source(&module_tree, syntax.ast());\n                 let sym = FileSymbol {\n-                    name,\n-                    node_range: node.range(),\n+                    name: link.name(&module_tree),\n+                    node_range: decl.syntax().range(),\n                     kind: MODULE,\n                 };\n-                (id, sym)\n+                (file_id, sym)\n             })\n             .collect()\n     }\n-\n     pub fn crate_for(&self, file_id: FileId) -> Vec<CrateId> {\n-        let module_map = self.root(file_id).module_map();\n+        let module_tree = self.root(file_id).module_tree();\n         let crate_graph = &self.data.crate_graph;\n         let mut res = Vec::new();\n         let mut work = VecDeque::new();\n@@ -177,11 +174,10 @@ impl AnalysisImpl {\n                 res.push(crate_id);\n                 continue;\n             }\n-            let mid = module_map.file2module(id);\n-            let parents = module_map\n-                .parent_module_ids(mid, &|file_id| self.file_syntax(file_id))\n+            let parents = module_tree\n+                .parent_modules(id)\n                 .into_iter()\n-                .map(|id| module_map.module2file(id))\n+                .map(|link| link.owner(&module_tree))\n                 .filter(|&id| visited.insert(id));\n             work.extend(parents);\n         }\n@@ -197,7 +193,7 @@ impl AnalysisImpl {\n         token: &JobToken,\n     ) -> Vec<(FileId, FileSymbol)> {\n         let root = self.root(file_id);\n-        let module_map = root.module_map();\n+        let module_tree = root.module_tree();\n         let file = root.syntax(file_id);\n         let syntax = file.syntax();\n         if let Some(name_ref) = find_node_at_offset::<ast::NameRef>(syntax, offset) {\n@@ -206,7 +202,7 @@ impl AnalysisImpl {\n         if let Some(name) = find_node_at_offset::<ast::Name>(syntax, offset) {\n             if let Some(module) = name.syntax().parent().and_then(ast::Module::cast) {\n                 if module.has_semi() {\n-                    let file_ids = self.resolve_module(module_map, file_id, module);\n+                    let file_ids = self.resolve_module(&*module_tree, file_id, module);\n \n                     let res = file_ids.into_iter().map(|id| {\n                         let name = module.name()\n@@ -229,55 +225,51 @@ impl AnalysisImpl {\n \n     pub fn diagnostics(&self, file_id: FileId) -> Vec<Diagnostic> {\n         let root = self.root(file_id);\n-        let module_map = root.module_map();\n+        let module_tree  = root.module_tree();\n         let syntax = root.syntax(file_id);\n \n         let mut res = libeditor::diagnostics(&syntax)\n             .into_iter()\n             .map(|d| Diagnostic { range: d.range, message: d.msg, fix: None })\n             .collect::<Vec<_>>();\n \n-        module_map.problems(\n-            file_id,\n-            &|file_id| self.file_syntax(file_id),\n-            |name_node, problem| {\n-                let diag = match problem {\n-                    Problem::UnresolvedModule { candidate } => {\n-                        let create_file = FileSystemEdit::CreateFile {\n-                            anchor: file_id,\n-                            path: candidate.clone(),\n-                        };\n-                        let fix = SourceChange {\n-                            label: \"create module\".to_string(),\n-                            source_file_edits: Vec::new(),\n-                            file_system_edits: vec![create_file],\n-                            cursor_position: None,\n-                        };\n-                        Diagnostic {\n-                            range: name_node.syntax().range(),\n-                            message: \"unresolved module\".to_string(),\n-                            fix: Some(fix),\n-                        }\n+        for (name_node, problem) in module_tree.problems(file_id, syntax.ast()) {\n+            let diag = match problem {\n+                Problem::UnresolvedModule { candidate } => {\n+                    let create_file = FileSystemEdit::CreateFile {\n+                        anchor: file_id,\n+                        path: candidate.clone(),\n+                    };\n+                    let fix = SourceChange {\n+                        label: \"create module\".to_string(),\n+                        source_file_edits: Vec::new(),\n+                        file_system_edits: vec![create_file],\n+                        cursor_position: None,\n+                    };\n+                    Diagnostic {\n+                        range: name_node.syntax().range(),\n+                        message: \"unresolved module\".to_string(),\n+                        fix: Some(fix),\n                     }\n-                    Problem::NotDirOwner { move_to, candidate } => {\n-                        let move_file = FileSystemEdit::MoveFile { file: file_id, path: move_to.clone() };\n-                        let create_file = FileSystemEdit::CreateFile { anchor: file_id, path: move_to.join(candidate) };\n-                        let fix = SourceChange {\n-                            label: \"move file and create module\".to_string(),\n-                            source_file_edits: Vec::new(),\n-                            file_system_edits: vec![move_file, create_file],\n-                            cursor_position: None,\n-                        };\n-                        Diagnostic {\n-                            range: name_node.syntax().range(),\n-                            message: \"can't declare module at this location\".to_string(),\n-                            fix: Some(fix),\n-                        }\n+                }\n+                Problem::NotDirOwner { move_to, candidate } => {\n+                    let move_file = FileSystemEdit::MoveFile { file: file_id, path: move_to.clone() };\n+                    let create_file = FileSystemEdit::CreateFile { anchor: file_id, path: move_to.join(candidate) };\n+                    let fix = SourceChange {\n+                        label: \"move file and create module\".to_string(),\n+                        source_file_edits: Vec::new(),\n+                        file_system_edits: vec![move_file, create_file],\n+                        cursor_position: None,\n+                    };\n+                    Diagnostic {\n+                        range: name_node.syntax().range(),\n+                        message: \"can't declare module at this location\".to_string(),\n+                        fix: Some(fix),\n                     }\n-                };\n-                res.push(diag)\n-            }\n-        );\n+                }\n+            };\n+            res.push(diag)\n+        }\n         res\n     }\n \n@@ -307,34 +299,20 @@ impl AnalysisImpl {\n         self.world_symbols(query, token)\n     }\n \n-    fn resolve_module(&self, module_map: &ModuleMap, file_id: FileId, module: ast::Module) -> Vec<FileId> {\n+    fn resolve_module(&self, module_tree: &ModuleTreeDescriptor, file_id: FileId, module: ast::Module) -> Vec<FileId> {\n         let name = match module.name() {\n             Some(name) => name.text(),\n             None => return Vec::new(),\n         };\n-        let id = module_map.file2module(file_id);\n-        module_map\n-            .child_module_by_name(\n-                id, name.as_str(),\n-                &|file_id| self.file_syntax(file_id),\n-            )\n-            .into_iter()\n-            .map(|id| module_map.module2file(id))\n-            .collect()\n-    }\n-\n-    fn reindex(&self) {\n-        if self.needs_reindex.compare_and_swap(true, false, SeqCst) {\n-            self.data.root.reindex();\n-        }\n+        module_tree.child_module_by_name(file_id, name.as_str())\n     }\n }\n \n #[derive(Default, Clone, Debug)]\n struct WorldData {\n     file_resolver: FileResolverImp,\n     crate_graph: CrateGraph,\n-    root: WritableSourceRoot,\n+    root: Arc<WritableSourceRoot>,\n     libs: Vec<Arc<ReadonlySourceRoot>>,\n }\n "}, {"sha": "b4b7a6a304e0b4c9bd7583e4b4702c65d3781518", "filename": "crates/libanalysis/src/lib.rs", "status": "modified", "additions": 14, "deletions": 9, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/3993bb4de95af407e5edc1fe551bec0f001a3f0f/crates%2Flibanalysis%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3993bb4de95af407e5edc1fe551bec0f001a3f0f/crates%2Flibanalysis%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Flibanalysis%2Fsrc%2Flib.rs?ref=3993bb4de95af407e5edc1fe551bec0f001a3f0f", "patch": "@@ -9,12 +9,17 @@ extern crate rayon;\n extern crate relative_path;\n #[macro_use]\n extern crate crossbeam_channel;\n+extern crate im;\n+extern crate salsa;\n \n mod symbol_index;\n mod module_map;\n mod imp;\n mod job;\n mod roots;\n+mod db;\n+mod queries;\n+mod descriptors;\n \n use std::{\n     sync::Arc,\n@@ -161,8 +166,8 @@ impl Analysis {\n     pub fn file_syntax(&self, file_id: FileId) -> File {\n         self.imp.file_syntax(file_id).clone()\n     }\n-    pub fn file_line_index(&self, file_id: FileId) -> LineIndex {\n-        self.imp.file_line_index(file_id).clone()\n+    pub fn file_line_index(&self, file_id: FileId) -> Arc<LineIndex> {\n+        self.imp.file_line_index(file_id)\n     }\n     pub fn extend_selection(&self, file: &File, range: TextRange) -> TextRange {\n         libeditor::extend_selection(file, range).unwrap_or(range)\n@@ -172,19 +177,19 @@ impl Analysis {\n     }\n     pub fn syntax_tree(&self, file_id: FileId) -> String {\n         let file = self.imp.file_syntax(file_id);\n-        libeditor::syntax_tree(file)\n+        libeditor::syntax_tree(&file)\n     }\n     pub fn join_lines(&self, file_id: FileId, range: TextRange) -> SourceChange {\n         let file = self.imp.file_syntax(file_id);\n-        SourceChange::from_local_edit(file_id, \"join lines\", libeditor::join_lines(file, range))\n+        SourceChange::from_local_edit(file_id, \"join lines\", libeditor::join_lines(&file, range))\n     }\n     pub fn on_eq_typed(&self, file_id: FileId, offset: TextUnit) -> Option<SourceChange> {\n         let file = self.imp.file_syntax(file_id);\n-        Some(SourceChange::from_local_edit(file_id, \"add semicolon\", libeditor::on_eq_typed(file, offset)?))\n+        Some(SourceChange::from_local_edit(file_id, \"add semicolon\", libeditor::on_eq_typed(&file, offset)?))\n     }\n     pub fn file_structure(&self, file_id: FileId) -> Vec<StructureNode> {\n         let file = self.imp.file_syntax(file_id);\n-        libeditor::file_structure(file)\n+        libeditor::file_structure(&file)\n     }\n     pub fn symbol_search(&self, query: Query, token: &JobToken) -> Vec<(FileId, FileSymbol)> {\n         self.imp.world_symbols(query, token)\n@@ -203,15 +208,15 @@ impl Analysis {\n     }\n     pub fn runnables(&self, file_id: FileId) -> Vec<Runnable> {\n         let file = self.imp.file_syntax(file_id);\n-        libeditor::runnables(file)\n+        libeditor::runnables(&file)\n     }\n     pub fn highlight(&self, file_id: FileId) -> Vec<HighlightedRange> {\n         let file = self.imp.file_syntax(file_id);\n-        libeditor::highlight(file)\n+        libeditor::highlight(&file)\n     }\n     pub fn completions(&self, file_id: FileId, offset: TextUnit) -> Option<Vec<CompletionItem>> {\n         let file = self.imp.file_syntax(file_id);\n-        libeditor::scope_completion(file, offset)\n+        libeditor::scope_completion(&file, offset)\n     }\n     pub fn assists(&self, file_id: FileId, range: TextRange) -> Vec<SourceChange> {\n         self.imp.assists(file_id, range)"}, {"sha": "a21f55fff1e6863c281aa989451a2c7b0c77dc39", "filename": "crates/libanalysis/src/module_map.rs", "status": "modified", "additions": 131, "deletions": 248, "changes": 379, "blob_url": "https://github.com/rust-lang/rust/blob/3993bb4de95af407e5edc1fe551bec0f001a3f0f/crates%2Flibanalysis%2Fsrc%2Fmodule_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3993bb4de95af407e5edc1fe551bec0f001a3f0f/crates%2Flibanalysis%2Fsrc%2Fmodule_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Flibanalysis%2Fsrc%2Fmodule_map.rs?ref=3993bb4de95af407e5edc1fe551bec0f001a3f0f", "patch": "@@ -1,274 +1,157 @@\n-use relative_path::RelativePathBuf;\n-use parking_lot::{RwLock, RwLockReadGuard, RwLockWriteGuard};\n-use libsyntax2::{\n-    File,\n-    ast::{self, AstNode, NameOwner},\n-    SyntaxNode, SmolStr,\n+use std::sync::Arc;\n+use {\n+    FileId,\n+    db::{\n+        Query, QueryRegistry, QueryCtx,\n+        file_set\n+    },\n+    queries::file_syntax,\n+    descriptors::{ModuleDescriptor, ModuleTreeDescriptor},\n };\n-use {FileId, imp::FileResolverImp};\n-\n-type SyntaxProvider<'a> = dyn Fn(FileId) -> &'a File + 'a;\n-\n-#[derive(Clone, Copy, PartialEq, Eq, Hash, Debug)]\n-pub struct ModuleId(FileId);\n \n-#[derive(Debug, Default)]\n-pub struct ModuleMap {\n-    state: RwLock<State>,\n+pub(crate) fn register_queries(reg: &mut QueryRegistry) {\n+    reg.add(MODULE_DESCR, \"MODULE_DESCR\");\n+    reg.add(MODULE_TREE, \"MODULE_TREE\");\n }\n \n-#[derive(Debug, Clone, Copy, PartialEq, Eq)]\n-pub enum ChangeKind {\n-    Delete, Insert, Update\n-}\n-\n-impl Clone for ModuleMap {\n-    fn clone(&self) -> ModuleMap {\n-        let state = self.state.read().clone();\n-        ModuleMap { state: RwLock::new(state) }\n-    }\n+pub(crate) fn module_tree(ctx: QueryCtx) -> Arc<ModuleTreeDescriptor> {\n+    ctx.get(MODULE_TREE, ())\n }\n \n-#[derive(Clone, Debug, Default)]\n-struct State {\n-    file_resolver: FileResolverImp,\n-    changes: Vec<(FileId, ChangeKind)>,\n-    links: Vec<Link>,\n-}\n-\n-#[derive(Clone, Debug)]\n-struct Link {\n-    owner: ModuleId,\n-    syntax: SyntaxNode,\n-    points_to: Vec<ModuleId>,\n-    problem: Option<Problem>,\n-}\n-\n-#[derive(Clone, Debug)]\n-pub enum Problem {\n-    UnresolvedModule {\n-        candidate: RelativePathBuf,\n-    },\n-    NotDirOwner {\n-        move_to: RelativePathBuf,\n-        candidate: RelativePathBuf,\n-    }\n-}\n-\n-impl ModuleMap {\n-    pub fn new() -> ModuleMap {\n-        Default::default()\n-    }\n-    pub fn update_file(&mut self, file_id: FileId, change_kind: ChangeKind) {\n-        self.state.get_mut().changes.push((file_id, change_kind));\n-    }\n-    pub(crate) fn set_file_resolver(&mut self, file_resolver: FileResolverImp) {\n-        self.state.get_mut().file_resolver = file_resolver;\n-    }\n-    pub fn module2file(&self, m: ModuleId) -> FileId {\n-        m.0\n-    }\n-    pub fn file2module(&self, file_id: FileId) -> ModuleId {\n-        ModuleId(file_id)\n-    }\n-    pub fn child_module_by_name<'a>(\n-        &self,\n-        parent_mod: ModuleId,\n-        child_mod: &str,\n-        syntax_provider: &SyntaxProvider,\n-    ) -> Vec<ModuleId> {\n-        self.links(syntax_provider)\n-            .links\n-            .iter()\n-            .filter(|link| link.owner == parent_mod)\n-            .filter(|link| link.name() == child_mod)\n-            .filter_map(|it| it.points_to.first())\n-            .map(|&it| it)\n-            .collect()\n-    }\n-\n-    pub fn parent_modules(\n-        &self,\n-        m: ModuleId,\n-        syntax_provider: &SyntaxProvider,\n-    ) -> Vec<(ModuleId, SmolStr, SyntaxNode)> {\n-        let mut res = Vec::new();\n-        self.for_each_parent_link(m, syntax_provider, |link| {\n-            res.push(\n-                (link.owner, link.name().clone(), link.syntax.clone())\n-            )\n-        });\n-        res\n-    }\n-\n-    pub fn parent_module_ids(\n-        &self,\n-        m: ModuleId,\n-        syntax_provider: &SyntaxProvider,\n-    ) -> Vec<ModuleId> {\n-        let mut res = Vec::new();\n-        self.for_each_parent_link(m, syntax_provider, |link| res.push(link.owner));\n-        res\n-    }\n-\n-    fn for_each_parent_link(\n-        &self,\n-        m: ModuleId,\n-        syntax_provider: &SyntaxProvider,\n-        f: impl FnMut(&Link)\n-    ) {\n-        self.links(syntax_provider)\n-            .links\n-            .iter()\n-            .filter(move |link| link.points_to.iter().any(|&it| it == m))\n-            .for_each(f)\n+const MODULE_DESCR: Query<FileId, ModuleDescriptor> = Query(30, |ctx, &file_id| {\n+    let file = file_syntax(ctx, file_id);\n+    ModuleDescriptor::new(file.ast())\n+});\n+\n+const MODULE_TREE: Query<(), ModuleTreeDescriptor> = Query(31, |ctx, _| {\n+    let file_set = file_set(ctx);\n+    let mut files = Vec::new();\n+    for &file_id in file_set.0.iter() {\n+        let module_descr = ctx.get(MODULE_DESCR, file_id);\n+        files.push((file_id, module_descr));\n+    }\n+    ModuleTreeDescriptor::new(files.iter().map(|(file_id, descr)| (*file_id, &**descr)), &file_set.1)\n+});\n+\n+#[cfg(test)]\n+mod tests {\n+    use std::collections::HashMap;\n+    use im;\n+    use relative_path::{RelativePath, RelativePathBuf};\n+    use {\n+        db::{Db},\n+        imp::FileResolverImp,\n+        FileId, FileResolver,\n+    };\n+    use super::*;\n+\n+    #[derive(Debug)]\n+    struct FileMap(im::HashMap<FileId, RelativePathBuf>);\n+\n+    impl FileResolver for FileMap {\n+        fn file_stem(&self, file_id: FileId) -> String {\n+            self.0[&file_id].file_stem().unwrap().to_string()\n+        }\n+        fn resolve(&self, file_id: FileId, rel: &RelativePath) -> Option<FileId> {\n+            let path = self.0[&file_id].join(rel).normalize();\n+            self.0.iter()\n+                .filter_map(|&(id, ref p)| Some(id).filter(|_| p == &path))\n+                .next()\n+        }\n     }\n \n-    pub fn problems(\n-        &self,\n-        file: FileId,\n-        syntax_provider: &SyntaxProvider,\n-        mut cb: impl FnMut(ast::Name, &Problem),\n-    ) {\n-        let module = self.file2module(file);\n-        let links = self.links(syntax_provider);\n-        links\n-            .links\n-            .iter()\n-            .filter(|link| link.owner == module)\n-            .filter_map(|link| {\n-                let problem = link.problem.as_ref()?;\n-                Some((link, problem))\n-            })\n-            .for_each(|(link, problem)| cb(link.name_node(), problem))\n+    struct Fixture {\n+        next_file_id: u32,\n+        fm: im::HashMap<FileId, RelativePathBuf>,\n+        db: Db,\n     }\n \n-    fn links(\n-        &self,\n-        syntax_provider: &SyntaxProvider,\n-    ) -> RwLockReadGuard<State> {\n-        {\n-            let guard = self.state.read();\n-            if guard.changes.is_empty() {\n-                return guard;\n+    impl Fixture {\n+        fn new() -> Fixture {\n+            Fixture {\n+                next_file_id: 1,\n+                fm: im::HashMap::new(),\n+                db: Db::new(),\n             }\n         }\n-        let mut guard = self.state.write();\n-        if !guard.changes.is_empty() {\n-            guard.apply_changes(syntax_provider);\n+        fn add_file(&mut self, path: &str, text: &str) -> FileId {\n+            assert!(path.starts_with(\"/\"));\n+            let file_id = FileId(self.next_file_id);\n+            self.next_file_id += 1;\n+            self.fm.insert(file_id, RelativePathBuf::from(&path[1..]));\n+            let mut new_state = self.db.state().clone();\n+            new_state.file_map.insert(file_id, Arc::new(text.to_string()));\n+            new_state.file_resolver = FileResolverImp::new(\n+                Arc::new(FileMap(self.fm.clone()))\n+            );\n+            self.db = self.db.with_changes(new_state, &[file_id], true);\n+            file_id\n         }\n-        assert!(guard.changes.is_empty());\n-        RwLockWriteGuard::downgrade(guard)\n-    }\n-}\n-\n-impl State {\n-    pub fn apply_changes(\n-        &mut self,\n-        syntax_provider: &SyntaxProvider,\n-    ) {\n-        let mut reresolve = false;\n-        for (file_id, kind) in self.changes.drain(..) {\n-            let mod_id = ModuleId(file_id);\n-            self.links.retain(|link| link.owner != mod_id);\n-            match kind {\n-                ChangeKind::Delete => {\n-                    for link in self.links.iter_mut() {\n-                        link.points_to.retain(|&x| x != mod_id);\n-                    }\n-                }\n-                ChangeKind::Insert => {\n-                    let file = syntax_provider(file_id);\n-                    self.links.extend(\n-                        file\n-                            .ast()\n-                            .modules()\n-                            .filter_map(|it| Link::new(mod_id, it))\n-                    );\n-                    reresolve = true;\n-                }\n-                ChangeKind::Update => {\n-                    let file = syntax_provider(file_id);\n-                    let resolver = &self.file_resolver;\n-                    self.links.extend(\n-                        file\n-                            .ast()\n-                            .modules()\n-                            .filter_map(|it| Link::new(mod_id, it))\n-                            .map(|mut link| {\n-                                link.resolve(resolver);\n-                                link\n-                            })\n-                    );\n-                }\n-            }\n+        fn remove_file(&mut self, file_id: FileId) {\n+            self.fm.remove(&file_id);\n+            let mut new_state = self.db.state().clone();\n+            new_state.file_map.remove(&file_id);\n+            new_state.file_resolver = FileResolverImp::new(\n+                Arc::new(FileMap(self.fm.clone()))\n+            );\n+            self.db = self.db.with_changes(new_state, &[file_id], true);\n         }\n-        if reresolve {\n-            for link in self.links.iter_mut() {\n-                link.resolve(&self.file_resolver)\n-            }\n+        fn change_file(&mut self, file_id: FileId, new_text: &str) {\n+            let mut new_state = self.db.state().clone();\n+            new_state.file_map.insert(file_id, Arc::new(new_text.to_string()));\n+            self.db = self.db.with_changes(new_state, &[file_id], false);\n         }\n-    }\n-}\n+        fn check_parent_modules(\n+            &self,\n+            file_id: FileId,\n+            expected: &[FileId],\n+            queries: &[(&'static str, u64)]\n+        ) {\n+            let (tree, events) = self.db.trace_query(|ctx| module_tree(ctx));\n+            let actual = tree.parent_modules(file_id)\n+                .into_iter()\n+                .map(|link| link.owner(&tree))\n+                .collect::<Vec<_>>();\n+            assert_eq!(actual.as_slice(), expected);\n+            let mut counts = HashMap::new();\n+            events.into_iter()\n+               .for_each(|event| *counts.entry(event).or_insert(0) += 1);\n+            for &(query_id, expected_count) in queries.iter() {\n+                let actual_count = *counts.get(&query_id).unwrap_or(&0);\n+                assert_eq!(\n+                    actual_count,\n+                    expected_count,\n+                    \"counts for {} differ\",\n+                    query_id,\n+                )\n+            }\n \n-impl Link {\n-    fn new(owner: ModuleId, module: ast::Module) -> Option<Link> {\n-        if module.name().is_none() {\n-            return None;\n         }\n-        let link = Link {\n-            owner,\n-            syntax: module.syntax().owned(),\n-            points_to: Vec::new(),\n-            problem: None,\n-        };\n-        Some(link)\n     }\n \n-    fn name(&self) -> SmolStr {\n-        self.name_node().text()\n-    }\n+    #[test]\n+    fn test_parent_module() {\n+        let mut f = Fixture::new();\n+        let foo = f.add_file(\"/foo.rs\", \"\");\n+        f.check_parent_modules(foo, &[], &[(\"MODULE_DESCR\", 1)]);\n \n-    fn name_node(&self) -> ast::Name {\n-        self.ast().name().unwrap()\n-    }\n+        let lib = f.add_file(\"/lib.rs\", \"mod foo;\");\n+        f.check_parent_modules(foo, &[lib], &[(\"MODULE_DESCR\", 1)]);\n+        f.check_parent_modules(foo, &[lib], &[(\"MODULE_DESCR\", 0)]);\n \n-    fn ast(&self) -> ast::Module {\n-        ast::Module::cast(self.syntax.borrowed())\n-            .unwrap()\n-    }\n+        f.change_file(lib, \"\");\n+        f.check_parent_modules(foo, &[], &[(\"MODULE_DESCR\", 1)]);\n \n-    fn resolve(&mut self, file_resolver: &FileResolverImp) {\n-        if !self.ast().has_semi() {\n-            self.problem = None;\n-            self.points_to = Vec::new();\n-            return;\n-        }\n+        f.change_file(lib, \"mod foo;\");\n+        f.check_parent_modules(foo, &[lib], &[(\"MODULE_DESCR\", 1)]);\n \n-        let mod_name = file_resolver.file_stem(self.owner.0);\n-        let is_dir_owner =\n-            mod_name == \"mod\" || mod_name == \"lib\" || mod_name == \"main\";\n+        f.change_file(lib, \"mod bar;\");\n+        f.check_parent_modules(foo, &[], &[(\"MODULE_DESCR\", 1)]);\n \n-        let file_mod = RelativePathBuf::from(format!(\"../{}.rs\", self.name()));\n-        let dir_mod = RelativePathBuf::from(format!(\"../{}/mod.rs\", self.name()));\n-        if is_dir_owner {\n-            self.points_to = [&file_mod, &dir_mod].iter()\n-                .filter_map(|path| file_resolver.resolve(self.owner.0, path))\n-                .map(ModuleId)\n-                .collect();\n-            self.problem = if self.points_to.is_empty() {\n-                Some(Problem::UnresolvedModule {\n-                    candidate: file_mod,\n-                })\n-            } else {\n-                None\n-            }\n-        } else {\n-            self.points_to = Vec::new();\n-            self.problem = Some(Problem::NotDirOwner {\n-                move_to: RelativePathBuf::from(format!(\"../{}/mod.rs\", mod_name)),\n-                candidate: file_mod,\n-            });\n-        }\n+        f.change_file(lib, \"mod foo;\");\n+        f.check_parent_modules(foo, &[lib], &[(\"MODULE_DESCR\", 1)]);\n+\n+        f.remove_file(lib);\n+        f.check_parent_modules(foo, &[], &[(\"MODULE_DESCR\", 0)]);\n     }\n }"}, {"sha": "0b60316e6044393d19158c8d29871d411832e9f6", "filename": "crates/libanalysis/src/queries.rs", "status": "added", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/3993bb4de95af407e5edc1fe551bec0f001a3f0f/crates%2Flibanalysis%2Fsrc%2Fqueries.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3993bb4de95af407e5edc1fe551bec0f001a3f0f/crates%2Flibanalysis%2Fsrc%2Fqueries.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Flibanalysis%2Fsrc%2Fqueries.rs?ref=3993bb4de95af407e5edc1fe551bec0f001a3f0f", "patch": "@@ -0,0 +1,39 @@\n+use std::sync::Arc;\n+use libsyntax2::File;\n+use libeditor::LineIndex;\n+use {\n+    FileId,\n+    db::{Query, QueryCtx, QueryRegistry},\n+    symbol_index::SymbolIndex,\n+};\n+\n+pub(crate) use db::{file_text, file_set};\n+\n+pub(crate) fn file_syntax(ctx: QueryCtx, file_id: FileId) -> File {\n+    (&*ctx.get(FILE_SYNTAX, file_id)).clone()\n+}\n+pub(crate) fn file_lines(ctx: QueryCtx, file_id: FileId) -> Arc<LineIndex> {\n+    ctx.get(FILE_LINES, file_id)\n+}\n+pub(crate) fn file_symbols(ctx: QueryCtx, file_id: FileId) -> Arc<SymbolIndex> {\n+    ctx.get(FILE_SYMBOLS, file_id)\n+}\n+\n+const FILE_SYNTAX: Query<FileId, File> = Query(16, |ctx, file_id: &FileId| {\n+    let text = file_text(ctx, *file_id);\n+    File::parse(&*text)\n+});\n+const FILE_LINES: Query<FileId, LineIndex> = Query(17, |ctx, file_id: &FileId| {\n+    let text = file_text(ctx, *file_id);\n+    LineIndex::new(&*text)\n+});\n+const FILE_SYMBOLS: Query<FileId, SymbolIndex> = Query(18, |ctx, file_id: &FileId| {\n+    let syntax = file_syntax(ctx, *file_id);\n+    SymbolIndex::for_file(*file_id, syntax)\n+});\n+\n+pub(crate) fn register_queries(reg: &mut QueryRegistry) {\n+    reg.add(FILE_SYNTAX, \"FILE_SYNTAX\");\n+    reg.add(FILE_LINES, \"FILE_LINES\");\n+    reg.add(FILE_SYMBOLS, \"FILE_SYMBOLS\");\n+}"}, {"sha": "191d0d821a3400647ead6529e4871e887de48598", "filename": "crates/libanalysis/src/roots.rs", "status": "modified", "additions": 77, "deletions": 89, "changes": 166, "blob_url": "https://github.com/rust-lang/rust/blob/3993bb4de95af407e5edc1fe551bec0f001a3f0f/crates%2Flibanalysis%2Fsrc%2Froots.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3993bb4de95af407e5edc1fe551bec0f001a3f0f/crates%2Flibanalysis%2Fsrc%2Froots.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Flibanalysis%2Fsrc%2Froots.rs?ref=3993bb4de95af407e5edc1fe551bec0f001a3f0f", "patch": "@@ -1,6 +1,5 @@\n use std::{\n     collections::HashMap,\n-    time::Instant,\n     sync::Arc,\n     panic,\n };\n@@ -13,94 +12,82 @@ use libsyntax2::File;\n use {\n     FileId,\n     imp::FileResolverImp,\n-    module_map::{ModuleMap, ChangeKind},\n     symbol_index::SymbolIndex,\n+    descriptors::{ModuleDescriptor, ModuleTreeDescriptor},\n+    db::Db,\n };\n \n pub(crate) trait SourceRoot {\n     fn contains(&self, file_id: FileId) -> bool;\n-    fn module_map(&self) -> &ModuleMap;\n-    fn lines(&self, file_id: FileId) -> &LineIndex;\n-    fn syntax(&self, file_id: FileId) -> &File;\n-    fn symbols<'a>(&'a self, acc: &mut Vec<&'a SymbolIndex>);\n+    fn module_tree(&self) -> Arc<ModuleTreeDescriptor>;\n+    fn lines(&self, file_id: FileId) -> Arc<LineIndex>;\n+    fn syntax(&self, file_id: FileId) -> File;\n+    fn symbols(&self, acc: &mut Vec<Arc<SymbolIndex>>);\n }\n \n-#[derive(Clone, Default, Debug)]\n+#[derive(Default, Debug)]\n pub(crate) struct WritableSourceRoot {\n-    file_map: HashMap<FileId, Arc<(FileData, OnceCell<SymbolIndex>)>>,\n-    module_map: ModuleMap,\n+    db: Db,\n }\n \n impl WritableSourceRoot {\n-    pub fn update(&mut self, file_id: FileId, text: Option<String>) {\n-        let change_kind = if self.file_map.remove(&file_id).is_some() {\n-            if text.is_some() {\n-                ChangeKind::Update\n-            } else {\n-                ChangeKind::Delete\n+    pub fn apply_changes(\n+        &self,\n+        changes: &mut dyn Iterator<Item=(FileId, Option<String>)>,\n+        file_resolver: Option<FileResolverImp>,\n+    ) -> WritableSourceRoot {\n+        let resolver_changed = file_resolver.is_some();\n+        let mut changed_files = Vec::new();\n+        let mut new_state = self.db.state().clone();\n+\n+        for (file_id, text) in changes {\n+            changed_files.push(file_id);\n+            match text {\n+                Some(text) => {\n+                    new_state.file_map.insert(file_id, Arc::new(text));\n+                },\n+                None => {\n+                    new_state.file_map.remove(&file_id);\n+                }\n             }\n-        } else {\n-            ChangeKind::Insert\n-        };\n-        self.module_map.update_file(file_id, change_kind);\n-        self.file_map.remove(&file_id);\n-        if let Some(text) = text {\n-            let file_data = FileData::new(text);\n-            self.file_map.insert(file_id, Arc::new((file_data, Default::default())));\n         }\n-    }\n-    pub fn set_file_resolver(&mut self, file_resolver: FileResolverImp) {\n-        self.module_map.set_file_resolver(file_resolver)\n-    }\n-    pub fn reindex(&self) {\n-        let now = Instant::now();\n-        self.file_map\n-            .par_iter()\n-            .for_each(|(&file_id, data)| {\n-                symbols(file_id, data);\n-            });\n-        info!(\"parallel indexing took {:?}\", now.elapsed());\n-\n-    }\n-    fn data(&self, file_id: FileId) -> &FileData {\n-        match self.file_map.get(&file_id) {\n-            Some(data) => &data.0,\n-            None => panic!(\"unknown file: {:?}\", file_id),\n+        if let Some(file_resolver) = file_resolver {\n+            new_state.file_resolver = file_resolver\n+        }\n+        WritableSourceRoot {\n+            db: self.db.with_changes(new_state, &changed_files, resolver_changed)\n         }\n     }\n }\n \n impl SourceRoot for WritableSourceRoot {\n-    fn contains(&self, file_id: FileId) -> bool {\n-        self.file_map.contains_key(&file_id)\n+    fn module_tree(&self) -> Arc<ModuleTreeDescriptor> {\n+        self.db.make_query(::module_map::module_tree)\n     }\n-    fn module_map(&self) -> &ModuleMap {\n-        &self.module_map\n+\n+    fn contains(&self, file_id: FileId) -> bool {\n+        self.db.state().file_map.contains_key(&file_id)\n     }\n-    fn lines(&self, file_id: FileId) -> &LineIndex {\n-        self.data(file_id).lines()\n+    fn lines(&self, file_id: FileId) -> Arc<LineIndex> {\n+        self.db.make_query(|ctx| ::queries::file_lines(ctx, file_id))\n     }\n-    fn syntax(&self, file_id: FileId) -> &File {\n-        self.data(file_id).syntax()\n+    fn syntax(&self, file_id: FileId) -> File {\n+        self.db.make_query(|ctx| ::queries::file_syntax(ctx, file_id))\n     }\n-    fn symbols<'a>(&'a self, acc: &mut Vec<&'a SymbolIndex>) {\n-        acc.extend(\n-            self.file_map\n-                .iter()\n-                .map(|(&file_id, data)| symbols(file_id, data))\n-        )\n+    fn symbols<'a>(&'a self, acc: &mut Vec<Arc<SymbolIndex>>) {\n+        self.db.make_query(|ctx| {\n+            let file_set = ::queries::file_set(ctx);\n+            let syms = file_set.0.iter()\n+                .map(|file_id| ::queries::file_symbols(ctx, *file_id));\n+            acc.extend(syms);\n+        });\n     }\n }\n \n-fn symbols(file_id: FileId, (data, symbols): &(FileData, OnceCell<SymbolIndex>)) -> &SymbolIndex {\n-    let syntax = data.syntax_transient();\n-    symbols.get_or_init(|| SymbolIndex::for_file(file_id, syntax))\n-}\n-\n #[derive(Debug)]\n struct FileData {\n     text: String,\n-    lines: OnceCell<LineIndex>,\n+    lines: OnceCell<Arc<LineIndex>>,\n     syntax: OnceCell<File>,\n }\n \n@@ -112,8 +99,8 @@ impl FileData {\n             lines: OnceCell::new(),\n         }\n     }\n-    fn lines(&self) -> &LineIndex {\n-        self.lines.get_or_init(|| LineIndex::new(&self.text))\n+    fn lines(&self) -> &Arc<LineIndex> {\n+        self.lines.get_or_init(|| Arc::new(LineIndex::new(&self.text)))\n     }\n     fn syntax(&self) -> &File {\n         let text = &self.text;\n@@ -126,40 +113,41 @@ impl FileData {\n             }\n         }\n     }\n-    fn syntax_transient(&self) -> File {\n-        self.syntax.get().map(|s| s.clone())\n-            .unwrap_or_else(|| File::parse(&self.text))\n-    }\n }\n \n #[derive(Debug)]\n pub(crate) struct ReadonlySourceRoot {\n-    symbol_index: SymbolIndex,\n+    symbol_index: Arc<SymbolIndex>,\n     file_map: HashMap<FileId, FileData>,\n-    module_map: ModuleMap,\n+    module_tree: Arc<ModuleTreeDescriptor>,\n }\n \n impl ReadonlySourceRoot {\n     pub(crate) fn new(files: Vec<(FileId, String)>, file_resolver: FileResolverImp) -> ReadonlySourceRoot {\n-        let mut module_map = ModuleMap::new();\n-        module_map.set_file_resolver(file_resolver);\n-        let symbol_index = SymbolIndex::for_files(\n-            files.par_iter().map(|(file_id, text)| {\n-                (*file_id, File::parse(text))\n+        let modules = files.par_iter()\n+            .map(|(file_id, text)| {\n+                let syntax = File::parse(text);\n+                let mod_descr = ModuleDescriptor::new(syntax.ast());\n+                (*file_id, syntax, mod_descr)\n             })\n+            .collect::<Vec<_>>();\n+        let module_tree = ModuleTreeDescriptor::new(\n+            modules.iter().map(|it| (it.0, &it.2)),\n+            &file_resolver,\n+        );\n+\n+        let symbol_index = SymbolIndex::for_files(\n+            modules.par_iter().map(|it| (it.0, it.1.clone()))\n         );\n         let file_map: HashMap<FileId, FileData> = files\n             .into_iter()\n-            .map(|(id, text)| {\n-                module_map.update_file(id, ChangeKind::Insert);\n-                (id, FileData::new(text))\n-            })\n+            .map(|(id, text)| (id, FileData::new(text)))\n             .collect();\n \n         ReadonlySourceRoot {\n-            symbol_index,\n+            symbol_index: Arc::new(symbol_index),\n             file_map,\n-            module_map,\n+            module_tree: Arc::new(module_tree),\n         }\n     }\n \n@@ -172,19 +160,19 @@ impl ReadonlySourceRoot {\n }\n \n impl SourceRoot for ReadonlySourceRoot {\n+    fn module_tree(&self) -> Arc<ModuleTreeDescriptor> {\n+        Arc::clone(&self.module_tree)\n+    }\n     fn contains(&self, file_id: FileId) -> bool {\n         self.file_map.contains_key(&file_id)\n     }\n-    fn module_map(&self) -> &ModuleMap {\n-        &self.module_map\n-    }\n-    fn lines(&self, file_id: FileId) -> &LineIndex {\n-        self.data(file_id).lines()\n+    fn lines(&self, file_id: FileId) -> Arc<LineIndex> {\n+        Arc::clone(self.data(file_id).lines())\n     }\n-    fn syntax(&self, file_id: FileId) -> &File {\n-        self.data(file_id).syntax()\n+    fn syntax(&self, file_id: FileId) -> File {\n+        self.data(file_id).syntax().clone()\n     }\n-    fn symbols<'a>(&'a self, acc: &mut Vec<&'a SymbolIndex>) {\n-        acc.push(&self.symbol_index)\n+    fn symbols(&self, acc: &mut Vec<Arc<SymbolIndex>>) {\n+        acc.push(Arc::clone(&self.symbol_index))\n     }\n }"}, {"sha": "d22187ac0b2294339313d6ef7fb569a69fa416e6", "filename": "crates/libanalysis/src/symbol_index.rs", "status": "modified", "additions": 11, "deletions": 1, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/3993bb4de95af407e5edc1fe551bec0f001a3f0f/crates%2Flibanalysis%2Fsrc%2Fsymbol_index.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3993bb4de95af407e5edc1fe551bec0f001a3f0f/crates%2Flibanalysis%2Fsrc%2Fsymbol_index.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Flibanalysis%2Fsrc%2Fsymbol_index.rs?ref=3993bb4de95af407e5edc1fe551bec0f001a3f0f", "patch": "@@ -1,3 +1,7 @@\n+use std::{\n+    sync::Arc,\n+    hash::{Hash, Hasher},\n+};\n use libeditor::{FileSymbol, file_symbols};\n use libsyntax2::{\n     File,\n@@ -13,6 +17,12 @@ pub(crate) struct SymbolIndex {\n     map: fst::Map,\n }\n \n+impl Hash for SymbolIndex {\n+    fn hash<H: Hasher>(&self, hasher: &mut H) {\n+        self.symbols.hash(hasher)\n+    }\n+}\n+\n impl SymbolIndex {\n     pub(crate) fn for_files(files: impl ParallelIterator<Item=(FileId, File)>) -> SymbolIndex {\n         let mut symbols = files\n@@ -43,7 +53,7 @@ impl SymbolIndex {\n impl Query {\n     pub(crate) fn search(\n         self,\n-        indices: &[&SymbolIndex],\n+        indices: &[Arc<SymbolIndex>],\n         token: &JobToken,\n     ) -> Vec<(FileId, FileSymbol)> {\n "}, {"sha": "547f85958ea7be406c86e820d5623d1753a0124c", "filename": "crates/libanalysis/tests/tests.rs", "status": "modified", "additions": 17, "deletions": 18, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/3993bb4de95af407e5edc1fe551bec0f001a3f0f/crates%2Flibanalysis%2Ftests%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3993bb4de95af407e5edc1fe551bec0f001a3f0f/crates%2Flibanalysis%2Ftests%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Flibanalysis%2Ftests%2Ftests.rs?ref=3993bb4de95af407e5edc1fe551bec0f001a3f0f", "patch": "@@ -14,24 +14,6 @@ use test_utils::assert_eq_dbg;\n #[derive(Debug)]\n struct FileMap(Vec<(FileId, RelativePathBuf)>);\n \n-fn analysis_host(files: &'static [(&'static str, &'static str)]) -> AnalysisHost {\n-    let mut host = AnalysisHost::new();\n-    let mut file_map = Vec::new();\n-    for (id, &(path, contents)) in files.iter().enumerate() {\n-        let file_id = FileId((id + 1) as u32);\n-        assert!(path.starts_with('/'));\n-        let path = RelativePathBuf::from_path(&path[1..]).unwrap();\n-        host.change_file(file_id, Some(contents.to_string()));\n-        file_map.push((file_id, path));\n-    }\n-    host.set_file_resolver(Arc::new(FileMap(file_map)));\n-    host\n-}\n-\n-fn analysis(files: &'static [(&'static str, &'static str)]) -> Analysis {\n-    analysis_host(files).analysis()\n-}\n-\n impl FileMap {\n     fn iter<'a>(&'a self) -> impl Iterator<Item=(FileId, &'a RelativePath)> + 'a {\n         self.0.iter().map(|(id, path)| (*id, path.as_relative_path()))\n@@ -56,6 +38,23 @@ impl FileResolver for FileMap {\n     }\n }\n \n+fn analysis_host(files: &'static [(&'static str, &'static str)]) -> AnalysisHost {\n+    let mut host = AnalysisHost::new();\n+    let mut file_map = Vec::new();\n+    for (id, &(path, contents)) in files.iter().enumerate() {\n+        let file_id = FileId((id + 1) as u32);\n+        assert!(path.starts_with('/'));\n+        let path = RelativePathBuf::from_path(&path[1..]).unwrap();\n+        host.change_file(file_id, Some(contents.to_string()));\n+        file_map.push((file_id, path));\n+    }\n+    host.set_file_resolver(Arc::new(FileMap(file_map)));\n+    host\n+}\n+\n+fn analysis(files: &'static [(&'static str, &'static str)]) -> Analysis {\n+    analysis_host(files).analysis()\n+}\n \n #[test]\n fn test_resolve_module() {"}, {"sha": "9cd8da3a893fbc2bc574a2108d31556f1f109181", "filename": "crates/libeditor/src/line_index.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3993bb4de95af407e5edc1fe551bec0f001a3f0f/crates%2Flibeditor%2Fsrc%2Fline_index.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3993bb4de95af407e5edc1fe551bec0f001a3f0f/crates%2Flibeditor%2Fsrc%2Fline_index.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Flibeditor%2Fsrc%2Fline_index.rs?ref=3993bb4de95af407e5edc1fe551bec0f001a3f0f", "patch": "@@ -1,7 +1,7 @@\n use superslice::Ext;\n use ::TextUnit;\n \n-#[derive(Clone, Debug)]\n+#[derive(Clone, Debug, Hash)]\n pub struct LineIndex {\n     newlines: Vec<TextUnit>,\n }"}, {"sha": "2f9cc9233657572e67fb0d08c061e256a2af176c", "filename": "crates/libeditor/src/symbols.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3993bb4de95af407e5edc1fe551bec0f001a3f0f/crates%2Flibeditor%2Fsrc%2Fsymbols.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3993bb4de95af407e5edc1fe551bec0f001a3f0f/crates%2Flibeditor%2Fsrc%2Fsymbols.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Flibeditor%2Fsrc%2Fsymbols.rs?ref=3993bb4de95af407e5edc1fe551bec0f001a3f0f", "patch": "@@ -17,7 +17,7 @@ pub struct StructureNode {\n     pub kind: SyntaxKind,\n }\n \n-#[derive(Debug, Clone)]\n+#[derive(Debug, Clone, Hash)]\n pub struct FileSymbol {\n     pub name: SmolStr,\n     pub node_range: TextRange,"}, {"sha": "eb271762e4a07368184ac941d2b776c4a1d337ad", "filename": "crates/libsyntax2/src/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3993bb4de95af407e5edc1fe551bec0f001a3f0f/crates%2Flibsyntax2%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3993bb4de95af407e5edc1fe551bec0f001a3f0f/crates%2Flibsyntax2%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Flibsyntax2%2Fsrc%2Flib.rs?ref=3993bb4de95af407e5edc1fe551bec0f001a3f0f", "patch": "@@ -61,7 +61,7 @@ use {\n     yellow::{GreenNode, SyntaxRoot},\n };\n \n-#[derive(Clone, Debug)]\n+#[derive(Clone, Debug, Hash)]\n pub struct File {\n     root: SyntaxNode\n }"}, {"sha": "9eb83234f0cbe92f802314002f4aaa198ccfd721", "filename": "crates/salsa/Cargo.toml", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/3993bb4de95af407e5edc1fe551bec0f001a3f0f/crates%2Fsalsa%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/3993bb4de95af407e5edc1fe551bec0f001a3f0f/crates%2Fsalsa%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fsalsa%2FCargo.toml?ref=3993bb4de95af407e5edc1fe551bec0f001a3f0f", "patch": "@@ -0,0 +1,8 @@\n+[package]\n+name = \"salsa\"\n+version = \"0.1.0\"\n+authors = [\"Aleksey Kladov <aleksey.kladov@gmail.com>\"]\n+\n+[dependencies]\n+parking_lot = \"0.6.3\"\n+im = \"12.0.0\""}, {"sha": "35deed37417c5ba2559669cd575f02589dfdcd7b", "filename": "crates/salsa/src/lib.rs", "status": "added", "additions": 293, "deletions": 0, "changes": 293, "blob_url": "https://github.com/rust-lang/rust/blob/3993bb4de95af407e5edc1fe551bec0f001a3f0f/crates%2Fsalsa%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3993bb4de95af407e5edc1fe551bec0f001a3f0f/crates%2Fsalsa%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fsalsa%2Fsrc%2Flib.rs?ref=3993bb4de95af407e5edc1fe551bec0f001a3f0f", "patch": "@@ -0,0 +1,293 @@\n+extern crate im;\n+extern crate parking_lot;\n+\n+use std::{\n+    sync::Arc,\n+    collections::{HashSet, HashMap},\n+    cell::RefCell,\n+};\n+use parking_lot::Mutex;\n+\n+pub type GroundQueryFn<T, D> = Box<Fn(&T, &D) -> (D, OutputFingerprint) + Send + Sync + 'static>;\n+pub type QueryFn<T, D> = Box<Fn(&QueryCtx<T, D>, &D) -> (D, OutputFingerprint) + Send + Sync + 'static>;\n+\n+#[derive(Debug)]\n+pub struct Db<T, D> {\n+    db: Arc<DbState<T, D>>,\n+    query_config: Arc<QueryConfig<T, D>>,\n+}\n+\n+pub struct QueryConfig<T, D> {\n+    ground_fn: HashMap<QueryTypeId, GroundQueryFn<T, D>>,\n+    query_fn: HashMap<QueryTypeId, QueryFn<T, D>>,\n+}\n+\n+impl<T, D> ::std::fmt::Debug for QueryConfig<T, D> {\n+    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {\n+        ::std::fmt::Display::fmt(\"QueryConfig { ... }\", f)\n+    }\n+}\n+\n+#[derive(Debug)]\n+struct DbState<T, D> {\n+    ground_data: T,\n+    gen: Gen,\n+    graph: Mutex<im::HashMap<QueryId, (Gen, Arc<QueryRecord<D>>)>>,\n+}\n+\n+#[derive(Debug)]\n+struct QueryRecord<D> {\n+    params: D,\n+    output: D,\n+    output_fingerprint: OutputFingerprint,\n+    deps: Vec<(QueryId, OutputFingerprint)>,\n+}\n+\n+impl<T, D> DbState<T, D> {\n+    fn record(\n+        &self,\n+        query_id: QueryId,\n+        params: D,\n+        output: D,\n+        output_fingerprint: OutputFingerprint,\n+        deps: Vec<(QueryId, OutputFingerprint)>,\n+    ) {\n+        let gen = self.gen;\n+        let record = QueryRecord {\n+            params,\n+            output,\n+            output_fingerprint,\n+            deps,\n+        };\n+        self.graph.lock().insert(query_id, (gen, Arc::new(record)));\n+    }\n+}\n+\n+impl<T, D> QueryConfig<T, D> {\n+    pub fn new() -> Self {\n+        QueryConfig {\n+            ground_fn: HashMap::new(),\n+            query_fn: HashMap::new(),\n+        }\n+    }\n+    pub fn with_ground_query(\n+        mut self,\n+        query_type: QueryTypeId,\n+        query_fn: GroundQueryFn<T, D>\n+    ) -> Self {\n+        let prev = self.ground_fn.insert(query_type, query_fn);\n+        assert!(prev.is_none());\n+        self\n+    }\n+    pub fn with_query(\n+        mut self,\n+        query_type: QueryTypeId,\n+        query_fn: QueryFn<T, D>,\n+    ) -> Self {\n+        let prev = self.query_fn.insert(query_type, query_fn);\n+        assert!(prev.is_none());\n+        self\n+    }\n+}\n+\n+pub struct QueryCtx<T, D> {\n+    db: Arc<DbState<T, D>>,\n+    query_config: Arc<QueryConfig<T, D>>,\n+    stack: RefCell<Vec<Vec<(QueryId, OutputFingerprint)>>>,\n+    executed: RefCell<Vec<QueryTypeId>>,\n+}\n+\n+impl<T, D> QueryCtx<T, D>\n+where\n+    D: Clone\n+{\n+    fn new(db: &Db<T, D>) -> QueryCtx<T, D> {\n+        QueryCtx {\n+            db: Arc::clone(&db.db),\n+            query_config: Arc::clone(&db.query_config),\n+            stack: RefCell::new(vec![Vec::new()]),\n+            executed: RefCell::new(Vec::new()),\n+        }\n+    }\n+    pub fn get(\n+        &self,\n+        query_id: QueryId,\n+        params: D,\n+    ) -> D {\n+        let (res, output_fingerprint) = self.get_inner(query_id, params);\n+        self.record_dep(query_id, output_fingerprint);\n+        res\n+    }\n+    pub fn trace(&self) -> Vec<QueryTypeId> {\n+        ::std::mem::replace(&mut *self.executed.borrow_mut(), Vec::new())\n+    }\n+\n+    fn get_inner(\n+        &self,\n+        query_id: QueryId,\n+        params: D,\n+    ) -> (D, OutputFingerprint) {\n+        let (gen, record) = {\n+            let guard = self.db.graph.lock();\n+            match guard.get(&query_id).map(|it| it.clone()){\n+                None => {\n+                    drop(guard);\n+                    return self.force(query_id, params);\n+                },\n+                Some(it) => it,\n+            }\n+        };\n+        if gen == self.db.gen {\n+            return (record.output.clone(), record.output_fingerprint)\n+        }\n+        if self.query_config.ground_fn.contains_key(&query_id.0) {\n+            let (invalidated, record) = {\n+                let guard = self.db.graph.lock();\n+                let (gen, ref record) = guard[&query_id];\n+                (gen == INVALIDATED, record.clone())\n+            };\n+            if invalidated {\n+                return self.force(query_id, params);\n+            } else {\n+                return (record.output.clone(), record.output_fingerprint);\n+            }\n+        }\n+        for (dep_query_id, prev_fingerprint) in record.deps.iter().cloned() {\n+            let dep_params: D = {\n+                let guard = self.db.graph.lock();\n+                guard[&dep_query_id]\n+                .1\n+                .params\n+                .clone()\n+            };\n+            if prev_fingerprint != self.get_inner(dep_query_id, dep_params).1 {\n+                return self.force(query_id, params)\n+            }\n+        }\n+        let gen = self.db.gen;\n+        {\n+            let mut guard = self.db.graph.lock();\n+            guard[&query_id].0 = gen;\n+        }\n+        (record.output.clone(), record.output_fingerprint)\n+    }\n+    fn force(\n+        &self,\n+        query_id: QueryId,\n+        params: D,\n+    ) -> (D, OutputFingerprint) {\n+        self.executed.borrow_mut().push(query_id.0);\n+        self.stack.borrow_mut().push(Vec::new());\n+\n+        let (res, output_fingerprint) = if let Some(f) = self.query_config.ground_fn.get(&query_id.0) {\n+            f(&self.db.ground_data, &params)\n+        } else if let Some(f) = self.query_config.query_fn.get(&query_id.0) {\n+            f(self, &params)\n+        } else {\n+            panic!(\"unknown query type: {:?}\", query_id.0);\n+        };\n+\n+        let res: D = res.into();\n+\n+        let deps = self.stack.borrow_mut().pop().unwrap();\n+        self.db.record(query_id, params, res.clone(), output_fingerprint, deps);\n+        (res, output_fingerprint)\n+    }\n+    fn record_dep(\n+        &self,\n+        query_id: QueryId,\n+        output_fingerprint: OutputFingerprint,\n+    ) -> () {\n+        let mut stack = self.stack.borrow_mut();\n+        let deps = stack.last_mut().unwrap();\n+        deps.push((query_id, output_fingerprint))\n+    }\n+}\n+\n+pub struct Invalidations {\n+    types: HashSet<QueryTypeId>,\n+    ids: Vec<QueryId>,\n+}\n+\n+impl Invalidations {\n+    pub fn new() -> Invalidations {\n+        Invalidations {\n+            types: HashSet::new(),\n+            ids: Vec::new(),\n+        }\n+    }\n+    pub fn invalidate(\n+        &mut self,\n+        query_type: QueryTypeId,\n+        params: impl Iterator<Item=InputFingerprint>,\n+    ) {\n+        self.types.insert(query_type);\n+        self.ids.extend(params.map(|it| QueryId(query_type, it)))\n+    }\n+}\n+\n+impl<T, D> Db<T, D>\n+where\n+    D: Clone\n+{\n+    pub fn new(query_config: QueryConfig<T, D>, ground_data: T) -> Db<T, D> {\n+        Db {\n+            db: Arc::new(DbState { ground_data, gen: Gen(0), graph: Default::default() }),\n+            query_config: Arc::new(query_config),\n+        }\n+    }\n+    pub fn ground_data(&self) -> &T {\n+        &self.db.ground_data\n+    }\n+    pub fn with_ground_data(\n+        &self,\n+        ground_data: T,\n+        invalidations: Invalidations,\n+    ) -> Db<T, D> {\n+        for id in self.query_config.ground_fn.keys() {\n+            assert!(\n+                invalidations.types.contains(id),\n+                \"all ground queries must be invalidated\"\n+            );\n+        }\n+\n+        let gen = Gen(self.db.gen.0 + 1);\n+        let mut graph = self.db.graph.lock().clone();\n+        for id in invalidations.ids {\n+            if let Some((gen, _)) = graph.get_mut(&id) {\n+                *gen = INVALIDATED;\n+            }\n+        }\n+        let graph = Mutex::new(graph);\n+        Db {\n+            db: Arc::new(DbState { ground_data, gen, graph }),\n+            query_config: Arc::clone(&self.query_config)\n+        }\n+    }\n+    pub fn query_ctx(&self) -> QueryCtx<T, D> {\n+        QueryCtx::new(self)\n+    }\n+    pub fn get(\n+        &self,\n+        query_id: QueryId,\n+        params: D,\n+    ) -> (D, Vec<QueryTypeId>) {\n+        let ctx = self.query_ctx();\n+        let res = ctx.get(query_id, params.into());\n+        let executed = ::std::mem::replace(&mut *ctx.executed.borrow_mut(), Vec::new());\n+        (res, executed)\n+    }\n+}\n+\n+#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]\n+struct Gen(u64);\n+const INVALIDATED: Gen = Gen(!0);\n+#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]\n+pub struct InputFingerprint(pub u64);\n+#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]\n+pub struct OutputFingerprint(pub u64);\n+#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]\n+pub struct QueryTypeId(pub u16);\n+#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]\n+pub struct QueryId(pub QueryTypeId, pub InputFingerprint);\n+"}, {"sha": "aed9219bee1fb5da5c0af202aff86240f3f11547", "filename": "crates/salsa/tests/integration.rs", "status": "added", "additions": 170, "deletions": 0, "changes": 170, "blob_url": "https://github.com/rust-lang/rust/blob/3993bb4de95af407e5edc1fe551bec0f001a3f0f/crates%2Fsalsa%2Ftests%2Fintegration.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3993bb4de95af407e5edc1fe551bec0f001a3f0f/crates%2Fsalsa%2Ftests%2Fintegration.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fsalsa%2Ftests%2Fintegration.rs?ref=3993bb4de95af407e5edc1fe551bec0f001a3f0f", "patch": "@@ -0,0 +1,170 @@\n+extern crate salsa;\n+use std::{\n+    iter::once,\n+    sync::Arc,\n+    collections::hash_map::{HashMap, DefaultHasher},\n+    any::Any,\n+    hash::{Hash, Hasher},\n+};\n+\n+type State = HashMap<u32, String>;\n+type Data = Arc<Any + Send + Sync + 'static>;\n+const GET_TEXT: salsa::QueryTypeId = salsa::QueryTypeId(1);\n+const GET_FILES: salsa::QueryTypeId = salsa::QueryTypeId(2);\n+const FILE_NEWLINES: salsa::QueryTypeId = salsa::QueryTypeId(3);\n+const TOTAL_NEWLINES: salsa::QueryTypeId = salsa::QueryTypeId(4);\n+\n+fn mk_ground_query<T, R>(\n+    state: &State,\n+    params: &Data,\n+    f: fn(&State, &T) -> R,\n+) -> (Data, salsa::OutputFingerprint)\n+where\n+    T: 'static,\n+    R: Hash + Send + Sync + 'static,\n+{\n+    let params = params.downcast_ref().unwrap();\n+    let result = f(state, params);\n+    let fingerprint = o_print(&result);\n+    (Arc::new(result), fingerprint)\n+}\n+\n+fn get<T, R>(db: &salsa::Db<State, Data>, query_type: salsa::QueryTypeId, param: T) -> (Arc<R>, Vec<salsa::QueryTypeId>)\n+where\n+    T: Hash + Send + Sync + 'static,\n+    R: Send + Sync + 'static,\n+{\n+    let i_print = i_print(&param);\n+    let param = Arc::new(param);\n+    let (res, trace) = db.get(salsa::QueryId(query_type, i_print), param);\n+    (res.downcast().unwrap(), trace)\n+}\n+\n+struct QueryCtx<'a>(&'a salsa::QueryCtx<State, Data>);\n+\n+impl<'a> QueryCtx<'a> {\n+    fn get_text(&self, id: u32) -> Arc<String> {\n+        let i_print = i_print(&id);\n+        let text = self.0.get(salsa::QueryId(GET_TEXT, i_print), Arc::new(id));\n+        text.downcast().unwrap()\n+    }\n+    fn get_files(&self) -> Arc<Vec<u32>> {\n+        let i_print = i_print(&());\n+        let files = self.0.get(salsa::QueryId(GET_FILES, i_print), Arc::new(()));\n+        let res = files.downcast().unwrap();\n+        res\n+    }\n+    fn get_n_lines(&self, id: u32) -> usize {\n+        let i_print = i_print(&id);\n+        let n_lines = self.0.get(salsa::QueryId(FILE_NEWLINES, i_print), Arc::new(id));\n+        *n_lines.downcast().unwrap()\n+    }\n+}\n+\n+fn mk_query<T, R>(\n+    query_ctx: &salsa::QueryCtx<State, Data>,\n+    params: &Data,\n+    f: fn(QueryCtx, &T) -> R,\n+) -> (Data, salsa::OutputFingerprint)\n+where\n+    T: 'static,\n+    R: Hash + Send + Sync + 'static,\n+{\n+    let params: &T = params.downcast_ref().unwrap();\n+    let query_ctx = QueryCtx(query_ctx);\n+    let result = f(query_ctx, params);\n+    let fingerprint = o_print(&result);\n+    (Arc::new(result), fingerprint)\n+}\n+\n+fn mk_queries() -> salsa::QueryConfig<State, Data> {\n+    salsa::QueryConfig::<State, Data>::new()\n+        .with_ground_query(GET_TEXT, Box::new(|state, id| {\n+            mk_ground_query::<u32, String>(state, id, |state, id| state[id].clone())\n+        }))\n+        .with_ground_query(GET_FILES, Box::new(|state, id| {\n+            mk_ground_query::<(), Vec<u32>>(state, id, |state, &()| state.keys().cloned().collect())\n+        }))\n+        .with_query(FILE_NEWLINES, Box::new(|query_ctx, id| {\n+            mk_query(query_ctx, id, |query_ctx, &id| {\n+                let text = query_ctx.get_text(id);\n+                text.lines().count()\n+            })\n+        }))\n+        .with_query(TOTAL_NEWLINES, Box::new(|query_ctx, id| {\n+            mk_query(query_ctx, id, |query_ctx, &()| {\n+                let mut total = 0;\n+                for &id in query_ctx.get_files().iter() {\n+                    total += query_ctx.get_n_lines(id)\n+                }\n+                total\n+            })\n+        }))\n+}\n+\n+#[test]\n+fn test_number_of_lines() {\n+    let mut state = State::new();\n+    let db = salsa::Db::new(mk_queries(), state.clone());\n+    let (newlines, trace) = get::<(), usize>(&db, TOTAL_NEWLINES, ());\n+    assert_eq!(*newlines, 0);\n+    assert_eq!(trace.len(), 2);\n+    let (newlines, trace) = get::<(), usize>(&db, TOTAL_NEWLINES, ());\n+    assert_eq!(*newlines, 0);\n+    assert_eq!(trace.len(), 0);\n+\n+    state.insert(1, \"hello\\nworld\".to_string());\n+    let mut inv = salsa::Invalidations::new();\n+    inv.invalidate(GET_TEXT, once(i_print(&1u32)));\n+    inv.invalidate(GET_FILES, once(i_print(&())));\n+    let db = db.with_ground_data(state.clone(), inv);\n+    let (newlines, trace) = get::<(), usize>(&db, TOTAL_NEWLINES, ());\n+    assert_eq!(*newlines, 2);\n+    assert_eq!(trace.len(), 4);\n+\n+    state.insert(2, \"spam\\neggs\".to_string());\n+    let mut inv = salsa::Invalidations::new();\n+    inv.invalidate(GET_TEXT, once(i_print(&2u32)));\n+    inv.invalidate(GET_FILES, once(i_print(&())));\n+    let db = db.with_ground_data(state.clone(), inv);\n+    let (newlines, trace) = get::<(), usize>(&db, TOTAL_NEWLINES, ());\n+    assert_eq!(*newlines, 4);\n+    assert_eq!(trace.len(), 4);\n+\n+    let mut invs = vec![];\n+    for i in 0..10 {\n+        let id = i + 10;\n+        invs.push(i_print(&id));\n+        state.insert(id, \"spam\".to_string());\n+    }\n+    let mut inv = salsa::Invalidations::new();\n+    inv.invalidate(GET_TEXT, invs.into_iter());\n+    inv.invalidate(GET_FILES, once(i_print(&())));\n+    let db = db.with_ground_data(state.clone(), inv);\n+    let (newlines, trace) = get::<(), usize>(&db, TOTAL_NEWLINES, ());\n+    assert_eq!(*newlines, 14);\n+    assert_eq!(trace.len(), 22);\n+\n+    state.insert(15, String::new());\n+    let mut inv = salsa::Invalidations::new();\n+    inv.invalidate(GET_TEXT, once(i_print(&15u32)));\n+    inv.invalidate(GET_FILES, once(i_print(&())));\n+    let db = db.with_ground_data(state.clone(), inv);\n+    let (newlines, trace) = get::<(), usize>(&db, TOTAL_NEWLINES, ());\n+    assert_eq!(*newlines, 13);\n+    assert_eq!(trace.len(), 4);\n+}\n+\n+fn o_print<T: Hash>(x: &T) -> salsa::OutputFingerprint {\n+    let mut hasher = DefaultHasher::new();\n+    x.hash(&mut hasher);\n+    let hash = hasher.finish();\n+    salsa::OutputFingerprint(hash)\n+}\n+\n+fn i_print<T: Hash>(x: &T) -> salsa::InputFingerprint {\n+    let mut hasher = DefaultHasher::new();\n+    x.hash(&mut hasher);\n+    let hash = hasher.finish();\n+    salsa::InputFingerprint(hash)\n+}"}, {"sha": "fc20730b88800d278194ca8be9424049ae361f03", "filename": "crates/server/Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3993bb4de95af407e5edc1fe551bec0f001a3f0f/crates%2Fserver%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/3993bb4de95af407e5edc1fe551bec0f001a3f0f/crates%2Fserver%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fserver%2FCargo.toml?ref=3993bb4de95af407e5edc1fe551bec0f001a3f0f", "patch": "@@ -17,7 +17,7 @@ log = \"0.4.3\"\n url_serde = \"0.2.0\"\n languageserver-types = \"0.49.0\"\n walkdir = \"2.2.0\"\n-im = { version = \"11.0.1\", features = [\"arc\"] }\n+im = \"12.0.0\"\n cargo_metadata = \"0.6.0\"\n text_unit = { version = \"0.1.2\", features = [\"serde\"] }\n smol_str = { version = \"0.1.5\", features = [\"serde\"] }"}]}