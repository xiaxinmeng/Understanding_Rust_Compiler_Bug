{"sha": "b6c29129fa7ab57cae4db1ee87a8d8e160e41dcd", "node_id": "C_kwDOAAsO6NoAKGI2YzI5MTI5ZmE3YWI1N2NhZTRkYjFlZTg3YThkOGUxNjBlNDFkY2Q", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2022-01-14T17:50:05Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2022-01-14T17:50:05Z"}, "message": "Merge #11286\n\n11286: internal: Clean up assoc item collection a bit r=jonas-schievink a=jonas-schievink\n\nIntroduce an `AssocItemCollector` instead of passing a lot of parameters around.\r\n\r\nbors r+\n\nCo-authored-by: Jonas Schievink <jonas.schievink@ferrous-systems.com>", "tree": {"sha": "ca7b2f362640c6a8912be0350c05ad9f1a2bfc81", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ca7b2f362640c6a8912be0350c05ad9f1a2bfc81"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b6c29129fa7ab57cae4db1ee87a8d8e160e41dcd", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJh4bfNCRBK7hj4Ov3rIwAAGSAIABlTT+kj0cXPKpNxl/LQJw/j\n50BGAWmT7URyC6VVinJy2SW4w6o4seb1DmmQH3hakuV+2VSTbiZXynUwcGQ5NmCo\nWS6rHikRAwmjhDFdQvlnFnkSgyPtKkuMn+mjk7C5VuOjJB9DpFDg60ft2WlCkQmP\nOare9G+AHUSc0EMEfzTyOC2TaMwjg749Xfe4PONYdBbW1T7SrqltOyB6/J5JXeSf\n/Ldgw80EumErPXCzvOxsNFhqYzq7Uhse+Vzt69UCik3iBq8Fap4KqIPfKH6Gm9eE\n6MZTkDnrs8xyiFFv8eWJLn9sxeO3nmV3ALSjDxZBd9fuBr2br+tT3XyplkUJ3AY=\n=eaUx\n-----END PGP SIGNATURE-----\n", "payload": "tree ca7b2f362640c6a8912be0350c05ad9f1a2bfc81\nparent 44ffae12ac94a493ab09560184c25608b5f5e1ef\nparent e52e1aaca1273b0f1375cc75035bbc1c9ba36e6e\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1642182605 +0000\ncommitter GitHub <noreply@github.com> 1642182605 +0000\n\nMerge #11286\n\n11286: internal: Clean up assoc item collection a bit r=jonas-schievink a=jonas-schievink\n\nIntroduce an `AssocItemCollector` instead of passing a lot of parameters around.\r\n\r\nbors r+\n\nCo-authored-by: Jonas Schievink <jonas.schievink@ferrous-systems.com>\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b6c29129fa7ab57cae4db1ee87a8d8e160e41dcd", "html_url": "https://github.com/rust-lang/rust/commit/b6c29129fa7ab57cae4db1ee87a8d8e160e41dcd", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b6c29129fa7ab57cae4db1ee87a8d8e160e41dcd/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "44ffae12ac94a493ab09560184c25608b5f5e1ef", "url": "https://api.github.com/repos/rust-lang/rust/commits/44ffae12ac94a493ab09560184c25608b5f5e1ef", "html_url": "https://github.com/rust-lang/rust/commit/44ffae12ac94a493ab09560184c25608b5f5e1ef"}, {"sha": "e52e1aaca1273b0f1375cc75035bbc1c9ba36e6e", "url": "https://api.github.com/repos/rust-lang/rust/commits/e52e1aaca1273b0f1375cc75035bbc1c9ba36e6e", "html_url": "https://github.com/rust-lang/rust/commit/e52e1aaca1273b0f1375cc75035bbc1c9ba36e6e"}], "stats": {"total": 246, "additions": 128, "deletions": 118}, "files": [{"sha": "3a39a65846b54267e596c2a76d0dd44e790b0396", "filename": "crates/hir_def/src/data.rs", "status": "modified", "additions": 128, "deletions": 118, "changes": 246, "blob_url": "https://github.com/rust-lang/rust/blob/b6c29129fa7ab57cae4db1ee87a8d8e160e41dcd/crates%2Fhir_def%2Fsrc%2Fdata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b6c29129fa7ab57cae4db1ee87a8d8e160e41dcd/crates%2Fhir_def%2Fsrc%2Fdata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_def%2Fsrc%2Fdata.rs?ref=b6c29129fa7ab57cae4db1ee87a8d8e160e41dcd", "patch": "@@ -1,17 +1,17 @@\n //! Contains basic data about various HIR declarations.\n \n-use std::sync::Arc;\n+use std::{mem, sync::Arc};\n \n-use hir_expand::{name::Name, AstId, ExpandResult, InFile, MacroCallId};\n+use hir_expand::{name::Name, AstId, ExpandResult, HirFileId, InFile, MacroCallId};\n use syntax::ast;\n \n use crate::{\n     attr::Attrs,\n     body::{Expander, Mark},\n     db::DefDatabase,\n     intern::Interned,\n-    item_tree::{self, AssocItem, FnFlags, ItemTreeId, ModItem, Param},\n-    nameres::attr_resolution::ResolvedAttr,\n+    item_tree::{self, AssocItem, FnFlags, ItemTreeId, ModItem, Param, TreeId},\n+    nameres::{attr_resolution::ResolvedAttr, DefMap},\n     type_ref::{TraitRef, TypeBound, TypeRef},\n     visibility::RawVisibility,\n     AssocItemId, AstIdWithPath, ConstId, ConstLoc, FunctionId, FunctionLoc, HasModule, ImplId,\n@@ -201,25 +201,28 @@ impl TraitData {\n         let is_auto = tr_def.is_auto;\n         let is_unsafe = tr_def.is_unsafe;\n         let module_id = tr_loc.container;\n-        let container = ItemContainerId::TraitId(tr);\n         let visibility = item_tree[tr_def.visibility].clone();\n-        let mut expander = Expander::new(db, tr_loc.id.file_id(), module_id);\n         let skip_array_during_method_dispatch = item_tree\n             .attrs(db, tr_loc.container.krate(), ModItem::from(tr_loc.id.value).into())\n             .by_key(\"rustc_skip_array_during_method_dispatch\")\n             .exists();\n \n-        let (items, attribute_calls) =\n-            do_collect(db, module_id, &mut expander, &tr_def.items, tr_loc.id.tree_id(), container);\n+        let mut collector = AssocItemCollector::new(\n+            db,\n+            module_id,\n+            tr_loc.id.file_id(),\n+            ItemContainerId::TraitId(tr),\n+        );\n+        collector.collect(tr_loc.id.tree_id(), &tr_def.items);\n \n         Arc::new(TraitData {\n             name,\n-            items,\n+            attribute_calls: collector.take_attr_calls(),\n+            items: collector.items,\n             is_auto,\n             is_unsafe,\n             visibility,\n             skip_array_during_method_dispatch,\n-            attribute_calls,\n         })\n     }\n \n@@ -270,18 +273,17 @@ impl ImplData {\n         let self_ty = impl_def.self_ty.clone();\n         let is_negative = impl_def.is_negative;\n         let module_id = impl_loc.container;\n-        let container = ItemContainerId::ImplId(id);\n-        let mut expander = Expander::new(db, impl_loc.id.file_id(), module_id);\n \n-        let (items, attribute_calls) = do_collect(\n+        let mut collector = AssocItemCollector::new(\n             db,\n             module_id,\n-            &mut expander,\n-            &impl_def.items,\n-            impl_loc.id.tree_id(),\n-            container,\n+            impl_loc.id.file_id(),\n+            ItemContainerId::ImplId(id),\n         );\n-        let items = items.into_iter().map(|(_, item)| item).collect();\n+        collector.collect(impl_loc.id.tree_id(), &impl_def.items);\n+\n+        let attribute_calls = collector.take_attr_calls();\n+        let items = collector.items.into_iter().map(|(_, item)| item).collect();\n \n         Arc::new(ImplData { target_trait, self_ty, items, is_negative, attribute_calls })\n     }\n@@ -338,120 +340,128 @@ impl StaticData {\n     }\n }\n \n-fn do_collect(\n-    db: &dyn DefDatabase,\n+struct AssocItemCollector<'a> {\n+    db: &'a dyn DefDatabase,\n     module_id: ModuleId,\n-    expander: &mut Expander,\n-    assoc_items: &[AssocItem],\n-    tree_id: item_tree::TreeId,\n+    def_map: Arc<DefMap>,\n     container: ItemContainerId,\n-) -> (Vec<(Name, AssocItemId)>, Option<Box<Vec<(AstId<ast::Item>, MacroCallId)>>>) {\n-    let mut items = Vec::new();\n-    let mut attribute_calls = Vec::new();\n-\n-    collect_items(\n-        db,\n-        &mut items,\n-        &mut attribute_calls,\n-        module_id,\n-        expander,\n-        assoc_items.iter().copied(),\n-        tree_id,\n-        container,\n-    );\n-\n-    let attribute_calls =\n-        if attribute_calls.is_empty() { None } else { Some(Box::new(attribute_calls)) };\n-    (items, attribute_calls)\n+    expander: Expander,\n+\n+    items: Vec<(Name, AssocItemId)>,\n+    attr_calls: Vec<(AstId<ast::Item>, MacroCallId)>,\n }\n \n-fn collect_items(\n-    db: &dyn DefDatabase,\n-    items: &mut Vec<(Name, AssocItemId)>,\n-    attr_calls: &mut Vec<(AstId<ast::Item>, MacroCallId)>,\n-    module: ModuleId,\n-    expander: &mut Expander,\n-    assoc_items: impl Iterator<Item = AssocItem>,\n-    tree_id: item_tree::TreeId,\n-    container: ItemContainerId,\n-) {\n-    let item_tree = tree_id.item_tree(db);\n-    let crate_graph = db.crate_graph();\n-    let cfg_options = &crate_graph[module.krate].cfg_options;\n-    let def_map = module.def_map(db);\n-\n-    'items: for item in assoc_items {\n-        let attrs = item_tree.attrs(db, module.krate, ModItem::from(item).into());\n-        if !attrs.is_cfg_enabled(cfg_options) {\n-            continue;\n+impl<'a> AssocItemCollector<'a> {\n+    fn new(\n+        db: &'a dyn DefDatabase,\n+        module_id: ModuleId,\n+        file_id: HirFileId,\n+        container: ItemContainerId,\n+    ) -> Self {\n+        Self {\n+            db,\n+            module_id,\n+            def_map: module_id.def_map(db),\n+            container,\n+            expander: Expander::new(db, file_id, module_id),\n+\n+            items: Vec::new(),\n+            attr_calls: Vec::new(),\n         }\n+    }\n \n-        for attr in &*attrs {\n-            let ast_id = AstId::new(expander.current_file_id(), item.ast_id(&item_tree).upcast());\n-            let ast_id_with_path = AstIdWithPath { path: (*attr.path).clone(), ast_id };\n-\n-            if let Ok(ResolvedAttr::Macro(call_id)) =\n-                def_map.resolve_attr_macro(db, module.local_id, ast_id_with_path, attr)\n-            {\n-                attr_calls.push((ast_id, call_id));\n-                let res = expander.enter_expand_id(db, call_id);\n-                collect_macro_items(db, items, attr_calls, module, expander, container, res);\n-                continue 'items;\n-            }\n+    fn take_attr_calls(&mut self) -> Option<Box<Vec<(AstId<ast::Item>, MacroCallId)>>> {\n+        let attribute_calls = mem::take(&mut self.attr_calls);\n+        if attribute_calls.is_empty() {\n+            None\n+        } else {\n+            Some(Box::new(attribute_calls))\n         }\n+    }\n \n-        match item {\n-            AssocItem::Function(id) => {\n-                let item = &item_tree[id];\n-                let def = FunctionLoc { container, id: ItemTreeId::new(tree_id, id) }.intern(db);\n-                items.push((item.name.clone(), def.into()));\n-            }\n-            AssocItem::Const(id) => {\n-                let item = &item_tree[id];\n-                let name = match item.name.clone() {\n-                    Some(name) => name,\n-                    None => continue,\n-                };\n-                let def = ConstLoc { container, id: ItemTreeId::new(tree_id, id) }.intern(db);\n-                items.push((name, def.into()));\n+    fn collect(&mut self, tree_id: TreeId, assoc_items: &[AssocItem]) {\n+        let item_tree = tree_id.item_tree(self.db);\n+\n+        'items: for &item in assoc_items {\n+            let attrs = item_tree.attrs(self.db, self.module_id.krate, ModItem::from(item).into());\n+            if !attrs.is_cfg_enabled(self.expander.cfg_options()) {\n+                continue;\n             }\n-            AssocItem::TypeAlias(id) => {\n-                let item = &item_tree[id];\n-                let def = TypeAliasLoc { container, id: ItemTreeId::new(tree_id, id) }.intern(db);\n-                items.push((item.name.clone(), def.into()));\n+\n+            for attr in &*attrs {\n+                let ast_id =\n+                    AstId::new(self.expander.current_file_id(), item.ast_id(&item_tree).upcast());\n+                let ast_id_with_path = AstIdWithPath { path: (*attr.path).clone(), ast_id };\n+\n+                if let Ok(ResolvedAttr::Macro(call_id)) = self.def_map.resolve_attr_macro(\n+                    self.db,\n+                    self.module_id.local_id,\n+                    ast_id_with_path,\n+                    attr,\n+                ) {\n+                    self.attr_calls.push((ast_id, call_id));\n+                    let res = self.expander.enter_expand_id(self.db, call_id);\n+                    self.collect_macro_items(res);\n+                    continue 'items;\n+                }\n             }\n-            AssocItem::MacroCall(call) => {\n-                let call = &item_tree[call];\n-                let ast_id_map = db.ast_id_map(tree_id.file_id());\n-                let root = db.parse_or_expand(tree_id.file_id()).unwrap();\n-                let call = ast_id_map.get(call.ast_id).to_node(&root);\n-                let _cx = stdx::panic_context::enter(format!(\"collect_items MacroCall: {}\", call));\n-                let res = expander.enter_expand(db, call);\n-\n-                if let Ok(res) = res {\n-                    collect_macro_items(db, items, attr_calls, module, expander, container, res);\n+\n+            match item {\n+                AssocItem::Function(id) => {\n+                    let item = &item_tree[id];\n+                    let def =\n+                        FunctionLoc { container: self.container, id: ItemTreeId::new(tree_id, id) }\n+                            .intern(self.db);\n+                    self.items.push((item.name.clone(), def.into()));\n+                }\n+                AssocItem::Const(id) => {\n+                    let item = &item_tree[id];\n+                    let name = match item.name.clone() {\n+                        Some(name) => name,\n+                        None => continue,\n+                    };\n+                    let def =\n+                        ConstLoc { container: self.container, id: ItemTreeId::new(tree_id, id) }\n+                            .intern(self.db);\n+                    self.items.push((name, def.into()));\n+                }\n+                AssocItem::TypeAlias(id) => {\n+                    let item = &item_tree[id];\n+                    let def = TypeAliasLoc {\n+                        container: self.container,\n+                        id: ItemTreeId::new(tree_id, id),\n+                    }\n+                    .intern(self.db);\n+                    self.items.push((item.name.clone(), def.into()));\n+                }\n+                AssocItem::MacroCall(call) => {\n+                    let call = &item_tree[call];\n+                    let ast_id_map = self.db.ast_id_map(self.expander.current_file_id());\n+                    let root = self.db.parse_or_expand(self.expander.current_file_id()).unwrap();\n+                    let call = ast_id_map.get(call.ast_id).to_node(&root);\n+                    let _cx =\n+                        stdx::panic_context::enter(format!(\"collect_items MacroCall: {}\", call));\n+                    let res = self.expander.enter_expand(self.db, call);\n+\n+                    if let Ok(res) = res {\n+                        self.collect_macro_items(res);\n+                    }\n                 }\n             }\n         }\n     }\n-}\n \n-fn collect_macro_items(\n-    db: &dyn DefDatabase,\n-    items: &mut Vec<(Name, AssocItemId)>,\n-    attr_calls: &mut Vec<(AstId<ast::Item>, MacroCallId)>,\n-    module: ModuleId,\n-    expander: &mut Expander,\n-    container: ItemContainerId,\n-    res: ExpandResult<Option<(Mark, ast::MacroItems)>>,\n-) {\n-    if let Some((mark, mac)) = res.value {\n-        let src: InFile<ast::MacroItems> = expander.to_source(mac);\n-        let tree_id = item_tree::TreeId::new(src.file_id, None);\n-        let item_tree = tree_id.item_tree(db);\n-        let iter = item_tree.top_level_items().iter().filter_map(ModItem::as_assoc_item);\n-        collect_items(db, items, attr_calls, module, expander, iter, tree_id, container);\n-\n-        expander.exit(db, mark);\n+    fn collect_macro_items(&mut self, res: ExpandResult<Option<(Mark, ast::MacroItems)>>) {\n+        if let Some((mark, mac)) = res.value {\n+            let src: InFile<ast::MacroItems> = self.expander.to_source(mac);\n+            let tree_id = item_tree::TreeId::new(src.file_id, None);\n+            let item_tree = tree_id.item_tree(self.db);\n+            let iter: Vec<_> =\n+                item_tree.top_level_items().iter().filter_map(ModItem::as_assoc_item).collect();\n+\n+            self.collect(tree_id, &iter);\n+\n+            self.expander.exit(self.db, mark);\n+        }\n     }\n }"}]}