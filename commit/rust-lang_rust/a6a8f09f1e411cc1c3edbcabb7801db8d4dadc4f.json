{"sha": "a6a8f09f1e411cc1c3edbcabb7801db8d4dadc4f", "node_id": "MDY6Q29tbWl0NzI0NzEyOmE2YThmMDlmMWU0MTFjYzFjM2VkYmNhYmI3ODAxZGI4ZDRkYWRjNGY=", "commit": {"author": {"name": "David Cook", "email": "divergentdave@gmail.com", "date": "2020-02-16T22:51:02Z"}, "committer": {"name": "David Cook", "email": "divergentdave@gmail.com", "date": "2020-02-18T04:24:33Z"}, "message": "Address review comments", "tree": {"sha": "709ddcd46f880ca4a48d34fa2786848c76095860", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/709ddcd46f880ca4a48d34fa2786848c76095860"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a6a8f09f1e411cc1c3edbcabb7801db8d4dadc4f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a6a8f09f1e411cc1c3edbcabb7801db8d4dadc4f", "html_url": "https://github.com/rust-lang/rust/commit/a6a8f09f1e411cc1c3edbcabb7801db8d4dadc4f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a6a8f09f1e411cc1c3edbcabb7801db8d4dadc4f/comments", "author": {"login": "divergentdave", "id": 181772, "node_id": "MDQ6VXNlcjE4MTc3Mg==", "avatar_url": "https://avatars.githubusercontent.com/u/181772?v=4", "gravatar_id": "", "url": "https://api.github.com/users/divergentdave", "html_url": "https://github.com/divergentdave", "followers_url": "https://api.github.com/users/divergentdave/followers", "following_url": "https://api.github.com/users/divergentdave/following{/other_user}", "gists_url": "https://api.github.com/users/divergentdave/gists{/gist_id}", "starred_url": "https://api.github.com/users/divergentdave/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/divergentdave/subscriptions", "organizations_url": "https://api.github.com/users/divergentdave/orgs", "repos_url": "https://api.github.com/users/divergentdave/repos", "events_url": "https://api.github.com/users/divergentdave/events{/privacy}", "received_events_url": "https://api.github.com/users/divergentdave/received_events", "type": "User", "site_admin": false}, "committer": {"login": "divergentdave", "id": 181772, "node_id": "MDQ6VXNlcjE4MTc3Mg==", "avatar_url": "https://avatars.githubusercontent.com/u/181772?v=4", "gravatar_id": "", "url": "https://api.github.com/users/divergentdave", "html_url": "https://github.com/divergentdave", "followers_url": "https://api.github.com/users/divergentdave/followers", "following_url": "https://api.github.com/users/divergentdave/following{/other_user}", "gists_url": "https://api.github.com/users/divergentdave/gists{/gist_id}", "starred_url": "https://api.github.com/users/divergentdave/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/divergentdave/subscriptions", "organizations_url": "https://api.github.com/users/divergentdave/orgs", "repos_url": "https://api.github.com/users/divergentdave/repos", "events_url": "https://api.github.com/users/divergentdave/events{/privacy}", "received_events_url": "https://api.github.com/users/divergentdave/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "962a7404265ff59c13e5f548da64b45609f3065f", "url": "https://api.github.com/repos/rust-lang/rust/commits/962a7404265ff59c13e5f548da64b45609f3065f", "html_url": "https://github.com/rust-lang/rust/commit/962a7404265ff59c13e5f548da64b45609f3065f"}], "stats": {"total": 17, "additions": 12, "deletions": 5}, "files": [{"sha": "85ee98aa3a123ee6dc87e080785314526b11b638", "filename": "src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a6a8f09f1e411cc1c3edbcabb7801db8d4dadc4f/src%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6a8f09f1e411cc1c3edbcabb7801db8d4dadc4f/src%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib.rs?ref=a6a8f09f1e411cc1c3edbcabb7801db8d4dadc4f", "patch": "@@ -1,5 +1,6 @@\n #![feature(rustc_private)]\n #![feature(option_expect_none, option_unwrap_none)]\n+#![feature(map_first_last)]\n #![warn(rust_2018_idioms)]\n #![allow(clippy::cast_lossless)]\n "}, {"sha": "a0df362bcee47560346c6af816183ebc15cad3ac", "filename": "src/shims/fs.rs", "status": "modified", "additions": 11, "deletions": 5, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/a6a8f09f1e411cc1c3edbcabb7801db8d4dadc4f/src%2Fshims%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6a8f09f1e411cc1c3edbcabb7801db8d4dadc4f/src%2Fshims%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fshims%2Ffs.rs?ref=a6a8f09f1e411cc1c3edbcabb7801db8d4dadc4f", "patch": "@@ -33,6 +33,11 @@ impl FileHandler {\n \n     fn insert_fd_with_min_fd(&mut self, file_handle: FileHandle, min_fd: i32) -> i32 {\n         let min_fd = std::cmp::max(min_fd, 3);\n+\n+        // Find the lowest unused FD, starting from min_fd. If the first such unused FD is in\n+        // between used FDs, the find_map combinator will return it. If the first such unused FD\n+        // is after all other used FDs, the find_map combinator will return None, and we will use\n+        // the FD following the greatest FD thus far.\n         let candidate_new_fd = self\n             .handles\n             .range(min_fd..)\n@@ -50,8 +55,9 @@ impl FileHandler {\n         let new_fd = candidate_new_fd.unwrap_or_else(|| {\n             // find_map ran out of BTreeMap entries before finding a free fd, use one plus the\n             // maximum fd in the map\n-            self.handles.keys().rev().next().map(|last_fd| last_fd + 1).unwrap_or(min_fd)\n+            self.handles.last_entry().map(|entry| entry.key() + 1).unwrap_or(min_fd)\n         });\n+\n         self.handles.insert(new_fd, file_handle).unwrap_none();\n         new_fd\n     }\n@@ -153,7 +159,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         &mut self,\n         fd_op: OpTy<'tcx, Tag>,\n         cmd_op: OpTy<'tcx, Tag>,\n-        arg_op: Option<OpTy<'tcx, Tag>>,\n+        start_op: Option<OpTy<'tcx, Tag>>,\n     ) -> InterpResult<'tcx, i32> {\n         let this = self.eval_context_mut();\n \n@@ -179,20 +185,20 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n             // because exec() isn't supported. The F_DUPFD and F_DUPFD_CLOEXEC commands only\n             // differ in whether the FD_CLOEXEC flag is pre-set on the new file descriptor,\n             // thus they can share the same implementation here.\n-            let arg_op = arg_op.ok_or_else(|| {\n+            let start_op = start_op.ok_or_else(|| {\n                 err_unsup_format!(\n                     \"fcntl with command F_DUPFD or F_DUPFD_CLOEXEC requires a third argument\"\n                 )\n             })?;\n-            let arg = this.read_scalar(arg_op)?.to_i32()?;\n+            let start = this.read_scalar(start_op)?.to_i32()?;\n             let fh = &mut this.machine.file_handler;\n             let (file_result, writable) = match fh.handles.get(&fd) {\n                 Some(FileHandle::File { file, writable }) => (file.try_clone(), *writable),\n                 Some(_) => throw_unsup_format!(\"Duplicating file descriptors for stdin, stdout, or stderr is not supported\"),\n                 None => return this.handle_not_found(),\n             };\n             let fd_result = file_result.map(|duplicated| {\n-                fh.insert_fd_with_min_fd(FileHandle::File { file: duplicated, writable }, arg)\n+                fh.insert_fd_with_min_fd(FileHandle::File { file: duplicated, writable }, start)\n             });\n             this.try_unwrap_io_result(fd_result)\n         } else {"}]}