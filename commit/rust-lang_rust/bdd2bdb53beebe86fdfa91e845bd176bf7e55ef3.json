{"sha": "bdd2bdb53beebe86fdfa91e845bd176bf7e55ef3", "node_id": "MDY6Q29tbWl0NzI0NzEyOmJkZDJiZGI1M2JlZWJlODZmZGZhOTFlODQ1YmQxNzZiZjdlNTVlZjM=", "commit": {"author": {"name": "Nadrieril", "email": "nadrieril+git@gmail.com", "date": "2020-11-28T22:07:15Z"}, "committer": {"name": "Nadrieril", "email": "nadrieril+git@gmail.com", "date": "2020-11-28T22:07:15Z"}, "message": "Don't store `ty` and `span` in `IntRange`\n\nWe prefer to grab `ty` and `span` from `pcx`. This makes it consistent\nwith other constructors.", "tree": {"sha": "d675152095eae5a8e136f7a8446d08ee92f61279", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d675152095eae5a8e136f7a8446d08ee92f61279"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/bdd2bdb53beebe86fdfa91e845bd176bf7e55ef3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/bdd2bdb53beebe86fdfa91e845bd176bf7e55ef3", "html_url": "https://github.com/rust-lang/rust/commit/bdd2bdb53beebe86fdfa91e845bd176bf7e55ef3", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/bdd2bdb53beebe86fdfa91e845bd176bf7e55ef3/comments", "author": {"login": "Nadrieril", "id": 6783654, "node_id": "MDQ6VXNlcjY3ODM2NTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/6783654?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Nadrieril", "html_url": "https://github.com/Nadrieril", "followers_url": "https://api.github.com/users/Nadrieril/followers", "following_url": "https://api.github.com/users/Nadrieril/following{/other_user}", "gists_url": "https://api.github.com/users/Nadrieril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Nadrieril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Nadrieril/subscriptions", "organizations_url": "https://api.github.com/users/Nadrieril/orgs", "repos_url": "https://api.github.com/users/Nadrieril/repos", "events_url": "https://api.github.com/users/Nadrieril/events{/privacy}", "received_events_url": "https://api.github.com/users/Nadrieril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Nadrieril", "id": 6783654, "node_id": "MDQ6VXNlcjY3ODM2NTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/6783654?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Nadrieril", "html_url": "https://github.com/Nadrieril", "followers_url": "https://api.github.com/users/Nadrieril/followers", "following_url": "https://api.github.com/users/Nadrieril/following{/other_user}", "gists_url": "https://api.github.com/users/Nadrieril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Nadrieril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Nadrieril/subscriptions", "organizations_url": "https://api.github.com/users/Nadrieril/orgs", "repos_url": "https://api.github.com/users/Nadrieril/repos", "events_url": "https://api.github.com/users/Nadrieril/events{/privacy}", "received_events_url": "https://api.github.com/users/Nadrieril/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d8983655c1735c302fd0d5784f3413fd9cab89e4", "url": "https://api.github.com/repos/rust-lang/rust/commits/d8983655c1735c302fd0d5784f3413fd9cab89e4", "html_url": "https://github.com/rust-lang/rust/commit/d8983655c1735c302fd0d5784f3413fd9cab89e4"}], "stats": {"total": 122, "additions": 56, "deletions": 66}, "files": [{"sha": "3b2eef5a905dd3ac63840bf19d0b6b45d02c8b1a", "filename": "compiler/rustc_mir_build/src/thir/pattern/deconstruct_pat.rs", "status": "modified", "additions": 46, "deletions": 64, "changes": 110, "blob_url": "https://github.com/rust-lang/rust/blob/bdd2bdb53beebe86fdfa91e845bd176bf7e55ef3/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fdeconstruct_pat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bdd2bdb53beebe86fdfa91e845bd176bf7e55ef3/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fdeconstruct_pat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fdeconstruct_pat.rs?ref=bdd2bdb53beebe86fdfa91e845bd176bf7e55ef3", "patch": "@@ -37,14 +37,12 @@ use std::ops::RangeInclusive;\n ///\n /// `IntRange` is never used to encode an empty range or a \"range\" that wraps\n /// around the (offset) space: i.e., `range.lo <= range.hi`.\n-#[derive(Clone, Debug)]\n-pub(super) struct IntRange<'tcx> {\n+#[derive(Clone, Debug, PartialEq, Eq)]\n+pub(super) struct IntRange {\n     range: RangeInclusive<u128>,\n-    ty: Ty<'tcx>,\n-    span: Span,\n }\n \n-impl<'tcx> IntRange<'tcx> {\n+impl IntRange {\n     #[inline]\n     fn is_integral(ty: Ty<'_>) -> bool {\n         matches!(ty.kind(), ty::Char | ty::Int(_) | ty::Uint(_) | ty::Bool)\n@@ -59,7 +57,7 @@ impl<'tcx> IntRange<'tcx> {\n     }\n \n     #[inline]\n-    fn integral_size_and_signed_bias(tcx: TyCtxt<'tcx>, ty: Ty<'_>) -> Option<(Size, u128)> {\n+    fn integral_size_and_signed_bias(tcx: TyCtxt<'_>, ty: Ty<'_>) -> Option<(Size, u128)> {\n         match *ty.kind() {\n             ty::Bool => Some((Size::from_bytes(1), 0)),\n             ty::Char => Some((Size::from_bytes(4), 0)),\n@@ -73,12 +71,11 @@ impl<'tcx> IntRange<'tcx> {\n     }\n \n     #[inline]\n-    fn from_const(\n+    fn from_const<'tcx>(\n         tcx: TyCtxt<'tcx>,\n         param_env: ty::ParamEnv<'tcx>,\n         value: &Const<'tcx>,\n-        span: Span,\n-    ) -> Option<IntRange<'tcx>> {\n+    ) -> Option<IntRange> {\n         if let Some((target_size, bias)) = Self::integral_size_and_signed_bias(tcx, value.ty) {\n             let ty = value.ty;\n             let val = (|| {\n@@ -95,21 +92,20 @@ impl<'tcx> IntRange<'tcx> {\n                 value.try_eval_bits(tcx, param_env, ty)\n             })()?;\n             let val = val ^ bias;\n-            Some(IntRange { range: val..=val, ty, span })\n+            Some(IntRange { range: val..=val })\n         } else {\n             None\n         }\n     }\n \n     #[inline]\n-    fn from_range(\n+    fn from_range<'tcx>(\n         tcx: TyCtxt<'tcx>,\n         lo: u128,\n         hi: u128,\n         ty: Ty<'tcx>,\n         end: &RangeEnd,\n-        span: Span,\n-    ) -> Option<IntRange<'tcx>> {\n+    ) -> Option<IntRange> {\n         if Self::is_integral(ty) {\n             // Perform a shift if the underlying types are signed,\n             // which makes the interval arithmetic simpler.\n@@ -120,14 +116,14 @@ impl<'tcx> IntRange<'tcx> {\n                 // This should have been caught earlier by E0030.\n                 bug!(\"malformed range pattern: {}..={}\", lo, (hi - offset));\n             }\n-            Some(IntRange { range: lo..=(hi - offset), ty, span })\n+            Some(IntRange { range: lo..=(hi - offset) })\n         } else {\n             None\n         }\n     }\n \n     // The return value of `signed_bias` should be XORed with an endpoint to encode/decode it.\n-    fn signed_bias(tcx: TyCtxt<'tcx>, ty: Ty<'tcx>) -> u128 {\n+    fn signed_bias(tcx: TyCtxt<'_>, ty: Ty<'_>) -> u128 {\n         match *ty.kind() {\n             ty::Int(ity) => {\n                 let bits = Integer::from_attr(&tcx, SignedInt(ity)).size().bits() as u128;\n@@ -142,12 +138,10 @@ impl<'tcx> IntRange<'tcx> {\n     }\n \n     fn intersection(&self, other: &Self) -> Option<Self> {\n-        let ty = self.ty;\n         let (lo, hi) = self.boundaries();\n         let (other_lo, other_hi) = other.boundaries();\n         if lo <= other_hi && other_lo <= hi {\n-            let span = other.span;\n-            Some(IntRange { range: max(lo, other_lo)..=min(hi, other_hi), ty, span })\n+            Some(IntRange { range: max(lo, other_lo)..=min(hi, other_hi) })\n         } else {\n             None\n         }\n@@ -170,24 +164,23 @@ impl<'tcx> IntRange<'tcx> {\n         lo == other_hi || hi == other_lo\n     }\n \n-    fn to_pat(&self, tcx: TyCtxt<'tcx>) -> Pat<'tcx> {\n+    fn to_pat<'tcx>(&self, tcx: TyCtxt<'tcx>, ty: Ty<'tcx>) -> Pat<'tcx> {\n         let (lo, hi) = self.boundaries();\n \n-        let bias = IntRange::signed_bias(tcx, self.ty);\n+        let bias = IntRange::signed_bias(tcx, ty);\n         let (lo, hi) = (lo ^ bias, hi ^ bias);\n \n-        let ty = ty::ParamEnv::empty().and(self.ty);\n-        let lo_const = ty::Const::from_bits(tcx, lo, ty);\n-        let hi_const = ty::Const::from_bits(tcx, hi, ty);\n+        let env = ty::ParamEnv::empty().and(ty);\n+        let lo_const = ty::Const::from_bits(tcx, lo, env);\n+        let hi_const = ty::Const::from_bits(tcx, hi, env);\n \n         let kind = if lo == hi {\n             PatKind::Constant { value: lo_const }\n         } else {\n             PatKind::Range(PatRange { lo: lo_const, hi: hi_const, end: RangeEnd::Included })\n         };\n \n-        // This is a brand new pattern, so we don't reuse `self.span`.\n-        Pat { ty: self.ty, span: DUMMY_SP, kind: Box::new(kind) }\n+        Pat { ty, span: DUMMY_SP, kind: Box::new(kind) }\n     }\n \n     /// For exhaustive integer matching, some constructors are grouped within other constructors\n@@ -222,13 +215,11 @@ impl<'tcx> IntRange<'tcx> {\n     /// boundaries for each interval range, sort them, then create constructors for each new interval\n     /// between every pair of boundary points. (This essentially sums up to performing the intuitive\n     /// merging operation depicted above.)\n-    fn split<'p>(\n+    fn split<'p, 'tcx>(\n         &self,\n         pcx: PatCtxt<'_, 'p, 'tcx>,\n         hir_id: Option<HirId>,\n     ) -> SmallVec<[Constructor<'tcx>; 1]> {\n-        let ty = pcx.ty;\n-\n         /// Represents a border between 2 integers. Because the intervals spanning borders\n         /// must be able to cover every integer, we need to be able to represent\n         /// 2^128 + 1 such borders.\n@@ -239,7 +230,7 @@ impl<'tcx> IntRange<'tcx> {\n         }\n \n         // A function for extracting the borders of an integer interval.\n-        fn range_borders(r: IntRange<'_>) -> impl Iterator<Item = Border> {\n+        fn range_borders(r: IntRange) -> impl Iterator<Item = Border> {\n             let (lo, hi) = r.range.into_inner();\n             let from = Border::JustBefore(lo);\n             let to = match hi.checked_add(1) {\n@@ -257,21 +248,23 @@ impl<'tcx> IntRange<'tcx> {\n         // class lies between 2 borders.\n         let row_borders = pcx\n             .matrix\n-            .head_ctors(pcx.cx)\n-            .filter_map(|ctor| ctor.as_int_range())\n-            .filter_map(|range| {\n+            .head_ctors_and_spans(pcx.cx)\n+            .filter_map(|(ctor, span)| Some((ctor.as_int_range()?, span)))\n+            .filter_map(|(range, span)| {\n                 let intersection = self.intersection(&range);\n                 let should_lint = self.suspicious_intersection(&range);\n                 if let (Some(range), 1, true) = (&intersection, row_len, should_lint) {\n                     // FIXME: for now, only check for overlapping ranges on simple range\n                     // patterns. Otherwise with the current logic the following is detected\n                     // as overlapping:\n-                    //   match (10u8, true) {\n-                    //    (0 ..= 125, false) => {}\n-                    //    (126 ..= 255, false) => {}\n-                    //    (0 ..= 255, true) => {}\n-                    //  }\n-                    overlaps.push(range.clone());\n+                    // ```\n+                    // match (0u8, true) {\n+                    //   (0 ..= 125, false) => {}\n+                    //   (125 ..= 255, true) => {}\n+                    //   _ => {}\n+                    // }\n+                    // ```\n+                    overlaps.push((range.clone(), span));\n                 }\n                 intersection\n             })\n@@ -280,7 +273,7 @@ impl<'tcx> IntRange<'tcx> {\n         let mut borders: Vec<_> = row_borders.chain(self_borders).collect();\n         borders.sort_unstable();\n \n-        self.lint_overlapping_patterns(pcx.cx.tcx, hir_id, ty, overlaps);\n+        self.lint_overlapping_patterns(pcx, hir_id, overlaps);\n \n         // We're going to iterate through every adjacent pair of borders, making sure that\n         // each represents an interval of nonnegative length, and convert each such\n@@ -298,33 +291,32 @@ impl<'tcx> IntRange<'tcx> {\n                 [Border::JustBefore(n), Border::AfterMax] => Some(n..=u128::MAX),\n                 [Border::AfterMax, _] => None,\n             })\n-            .map(|range| IntRange { range, ty, span: pcx.span })\n+            .map(|range| IntRange { range })\n             .map(IntRange)\n             .collect()\n     }\n \n     fn lint_overlapping_patterns(\n         &self,\n-        tcx: TyCtxt<'tcx>,\n+        pcx: PatCtxt<'_, '_, '_>,\n         hir_id: Option<HirId>,\n-        ty: Ty<'tcx>,\n-        overlaps: Vec<IntRange<'tcx>>,\n+        overlaps: Vec<(IntRange, Span)>,\n     ) {\n         if let (true, Some(hir_id)) = (!overlaps.is_empty(), hir_id) {\n-            tcx.struct_span_lint_hir(\n+            pcx.cx.tcx.struct_span_lint_hir(\n                 lint::builtin::OVERLAPPING_PATTERNS,\n                 hir_id,\n-                self.span,\n+                pcx.span,\n                 |lint| {\n                     let mut err = lint.build(\"multiple patterns covering the same range\");\n-                    err.span_label(self.span, \"overlapping patterns\");\n-                    for int_range in overlaps {\n+                    err.span_label(pcx.span, \"overlapping patterns\");\n+                    for (int_range, span) in overlaps {\n                         // Use the real type for user display of the ranges:\n                         err.span_label(\n-                            int_range.span,\n+                            span,\n                             &format!(\n                                 \"this range overlaps on `{}`\",\n-                                IntRange { range: int_range.range, ty, span: DUMMY_SP }.to_pat(tcx),\n+                                int_range.to_pat(pcx.cx.tcx, pcx.ty),\n                             ),\n                         );\n                     }\n@@ -347,13 +339,6 @@ impl<'tcx> IntRange<'tcx> {\n     }\n }\n \n-/// Ignore spans when comparing, they don't carry semantic information as they are only for lints.\n-impl<'tcx> std::cmp::PartialEq for IntRange<'tcx> {\n-    fn eq(&self, other: &Self) -> bool {\n-        self.range == other.range && self.ty == other.ty\n-    }\n-}\n-\n #[derive(Copy, Clone, Debug, PartialEq, Eq)]\n enum SliceKind {\n     /// Patterns of length `n` (`[x, y]`).\n@@ -547,7 +532,7 @@ pub(super) enum Constructor<'tcx> {\n     /// Enum variants.\n     Variant(DefId),\n     /// Ranges of integer literal values (`2`, `2..=5` or `2..5`).\n-    IntRange(IntRange<'tcx>),\n+    IntRange(IntRange),\n     /// Ranges of floating-point literal values (`2.0..=5.2`).\n     FloatRange(&'tcx ty::Const<'tcx>, &'tcx ty::Const<'tcx>, RangeEnd),\n     /// String literals. Strings are not quite the same as `&[u8]` so we treat them separately.\n@@ -570,7 +555,7 @@ impl<'tcx> Constructor<'tcx> {\n         matches!(self, Wildcard)\n     }\n \n-    fn as_int_range(&self) -> Option<&IntRange<'tcx>> {\n+    fn as_int_range(&self) -> Option<&IntRange> {\n         match self {\n             IntRange(range) => Some(range),\n             _ => None,\n@@ -605,8 +590,7 @@ impl<'tcx> Constructor<'tcx> {\n                 Variant(adt_def.variants[variant_index].def_id)\n             }\n             PatKind::Constant { value } => {\n-                if let Some(int_range) = IntRange::from_const(cx.tcx, cx.param_env, value, pat.span)\n-                {\n+                if let Some(int_range) = IntRange::from_const(cx.tcx, cx.param_env, value) {\n                     IntRange(int_range)\n                 } else {\n                     match pat.ty.kind() {\n@@ -630,7 +614,6 @@ impl<'tcx> Constructor<'tcx> {\n                     hi.eval_bits(cx.tcx, cx.param_env, hi.ty),\n                     ty,\n                     &end,\n-                    pat.span,\n                 ) {\n                     IntRange(int_range)\n                 } else {\n@@ -815,8 +798,7 @@ fn all_constructors<'p, 'tcx>(pcx: PatCtxt<'_, 'p, 'tcx>) -> Vec<Constructor<'tc\n     let make_range = |start, end| {\n         IntRange(\n             // `unwrap()` is ok because we know the type is an integer.\n-            IntRange::from_range(cx.tcx, start, end, pcx.ty, &RangeEnd::Included, pcx.span)\n-                .unwrap(),\n+            IntRange::from_range(cx.tcx, start, end, pcx.ty, &RangeEnd::Included).unwrap(),\n         )\n     };\n     match pcx.ty.kind() {\n@@ -1221,7 +1203,7 @@ impl<'p, 'tcx> Fields<'p, 'tcx> {\n             },\n             &Str(value) => PatKind::Constant { value },\n             &FloatRange(lo, hi, end) => PatKind::Range(PatRange { lo, hi, end }),\n-            IntRange(range) => return range.to_pat(pcx.cx.tcx),\n+            IntRange(range) => return range.to_pat(pcx.cx.tcx, pcx.ty),\n             NonExhaustive => PatKind::Wild,\n             Opaque => bug!(\"we should not try to apply an opaque constructor\"),\n             Wildcard => bug!("}, {"sha": "f3e1507b37ae1813cfe9e7ab49c8bc67caf06671", "filename": "compiler/rustc_mir_build/src/thir/pattern/usefulness.rs", "status": "modified", "additions": 10, "deletions": 2, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/bdd2bdb53beebe86fdfa91e845bd176bf7e55ef3/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fusefulness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bdd2bdb53beebe86fdfa91e845bd176bf7e55ef3/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fusefulness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fusefulness.rs?ref=bdd2bdb53beebe86fdfa91e845bd176bf7e55ef3", "patch": "@@ -535,14 +535,22 @@ impl<'p, 'tcx> Matrix<'p, 'tcx> {\n         self.patterns.iter().map(|r| r.head())\n     }\n \n-    /// Iterate over the first constructor of each row\n+    /// Iterate over the first constructor of each row.\n     pub(super) fn head_ctors<'a>(\n         &'a self,\n         cx: &'a MatchCheckCtxt<'p, 'tcx>,\n-    ) -> impl Iterator<Item = &'a Constructor<'tcx>> + Captures<'a> + Captures<'p> {\n+    ) -> impl Iterator<Item = &'a Constructor<'tcx>> + Captures<'p> {\n         self.patterns.iter().map(move |r| r.head_ctor(cx))\n     }\n \n+    /// Iterate over the first constructor and the corresponding span of each row.\n+    pub(super) fn head_ctors_and_spans<'a>(\n+        &'a self,\n+        cx: &'a MatchCheckCtxt<'p, 'tcx>,\n+    ) -> impl Iterator<Item = (&'a Constructor<'tcx>, Span)> + Captures<'p> {\n+        self.patterns.iter().map(move |r| (r.head_ctor(cx), r.head().span))\n+    }\n+\n     /// This computes `S(constructor, self)`. See top of the file for explanations.\n     fn specialize_constructor(\n         &self,"}]}