{"sha": "3ef8ff1f81107b42840a695725e1a0869c163355", "node_id": "MDY6Q29tbWl0NzI0NzEyOjNlZjhmZjFmODExMDdiNDI4NDBhNjk1NzI1ZTFhMDg2OWMxNjMzNTU=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-02-12T00:38:24Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-02-12T00:38:24Z"}, "message": "Auto merge of #22192 - alexcrichton:rollup, r=alexcrichton", "tree": {"sha": "c1593f6ab95c4585b27859f0946e9dbcb7da6f95", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c1593f6ab95c4585b27859f0946e9dbcb7da6f95"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3ef8ff1f81107b42840a695725e1a0869c163355", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3ef8ff1f81107b42840a695725e1a0869c163355", "html_url": "https://github.com/rust-lang/rust/commit/3ef8ff1f81107b42840a695725e1a0869c163355", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3ef8ff1f81107b42840a695725e1a0869c163355/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e29f42025513374f1a88404491d1b40386acf994", "url": "https://api.github.com/repos/rust-lang/rust/commits/e29f42025513374f1a88404491d1b40386acf994", "html_url": "https://github.com/rust-lang/rust/commit/e29f42025513374f1a88404491d1b40386acf994"}, {"sha": "fb1f4d11ec6c4cbb2e95cab192105950be98e01b", "url": "https://api.github.com/repos/rust-lang/rust/commits/fb1f4d11ec6c4cbb2e95cab192105950be98e01b", "html_url": "https://github.com/rust-lang/rust/commit/fb1f4d11ec6c4cbb2e95cab192105950be98e01b"}], "stats": {"total": 4582, "additions": 4076, "deletions": 506}, "files": [{"sha": "385f1b9e791545944c14914c5675c38bdf0de3da", "filename": "src/compiletest/compiletest.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3ef8ff1f81107b42840a695725e1a0869c163355/src%2Fcompiletest%2Fcompiletest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ef8ff1f81107b42840a695725e1a0869c163355/src%2Fcompiletest%2Fcompiletest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Fcompiletest.rs?ref=3ef8ff1f81107b42840a695725e1a0869c163355", "patch": "@@ -14,7 +14,6 @@\n #![feature(collections)]\n #![feature(int_uint)]\n #![feature(io)]\n-#![feature(os)]\n #![feature(path)]\n #![feature(rustc_private)]\n #![feature(slicing_syntax, unboxed_closures)]\n@@ -48,8 +47,7 @@ pub mod common;\n pub mod errors;\n \n pub fn main() {\n-    let args = env::args().map(|s| s.into_string().unwrap()).collect();;\n-    let config = parse_config(args);\n+    let config = parse_config(env::args().collect());\n \n     if config.valgrind_path.is_none() && config.force_valgrind {\n         panic!(\"Can't find Valgrind to run Valgrind tests\");"}, {"sha": "c046a89cba55ff52c6681c1861c59f4f36fc9f44", "filename": "src/compiletest/util.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3ef8ff1f81107b42840a695725e1a0869c163355/src%2Fcompiletest%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ef8ff1f81107b42840a695725e1a0869c163355/src%2Fcompiletest%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Futil.rs?ref=3ef8ff1f81107b42840a695725e1a0869c163355", "patch": "@@ -40,7 +40,7 @@ pub fn make_new_path(path: &str) -> String {\n \n     // Windows just uses PATH as the library search path, so we have to\n     // maintain the current value while adding our own\n-    match env::var_string(lib_path_env_var()) {\n+    match env::var(lib_path_env_var()) {\n       Ok(curr) => {\n         format!(\"{}{}{}\", path, path_div(), curr)\n       }"}, {"sha": "87106041c69d7f213e903aab58a791ca3a780bf1", "filename": "src/liballoc/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/3ef8ff1f81107b42840a695725e1a0869c163355/src%2Fliballoc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ef8ff1f81107b42840a695725e1a0869c163355/src%2Fliballoc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Flib.rs?ref=3ef8ff1f81107b42840a695725e1a0869c163355", "patch": "@@ -71,6 +71,7 @@\n #![feature(box_syntax)]\n #![feature(optin_builtin_traits)]\n #![feature(unboxed_closures)]\n+#![feature(unsafe_no_drop_flag)]\n #![feature(core)]\n #![feature(hash)]\n #![cfg_attr(all(not(feature = \"external_funcs\"), not(feature = \"external_crate\")),"}, {"sha": "107f6031c1156055ff6df9dbea95975e8e6659a3", "filename": "src/libcollections/bench.rs", "status": "modified", "additions": 105, "deletions": 93, "changes": 198, "blob_url": "https://github.com/rust-lang/rust/blob/3ef8ff1f81107b42840a695725e1a0869c163355/src%2Flibcollections%2Fbench.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ef8ff1f81107b42840a695725e1a0869c163355/src%2Flibcollections%2Fbench.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fbench.rs?ref=3ef8ff1f81107b42840a695725e1a0869c163355", "patch": "@@ -8,103 +8,115 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use prelude::*;\n-use std::rand;\n-use std::rand::Rng;\n-use test::{Bencher, black_box};\n-\n-pub fn insert_rand_n<M, I, R>(n: usize,\n-                              map: &mut M,\n-                              b: &mut Bencher,\n-                              mut insert: I,\n-                              mut remove: R) where\n-    I: FnMut(&mut M, usize),\n-    R: FnMut(&mut M, usize),\n-{\n-    // setup\n-    let mut rng = rand::weak_rng();\n-\n-    for _ in 0..n {\n-        insert(map, rng.gen::<usize>() % n);\n-    }\n-\n-    // measure\n-    b.iter(|| {\n-        let k = rng.gen::<usize>() % n;\n-        insert(map, k);\n-        remove(map, k);\n-    });\n-    black_box(map);\n+macro_rules! map_insert_rand_bench {\n+    ($name: ident, $n: expr, $map: ident) => (\n+        #[bench]\n+        pub fn $name(b: &mut ::test::Bencher) {\n+            use std::rand;\n+            use std::rand::Rng;\n+            use test::black_box;\n+\n+            let n: usize = $n;\n+            let mut map = $map::new();\n+            // setup\n+            let mut rng = rand::weak_rng();\n+\n+            for _ in 0..n {\n+                let i = rng.gen() % n;\n+                map.insert(i, i);\n+            }\n+\n+            // measure\n+            b.iter(|| {\n+                let k = rng.gen() % n;\n+                map.insert(k, k);\n+                map.remove(&k);\n+            });\n+            black_box(map);\n+        }\n+    )\n }\n \n-pub fn insert_seq_n<M, I, R>(n: usize,\n-                             map: &mut M,\n-                             b: &mut Bencher,\n-                             mut insert: I,\n-                             mut remove: R) where\n-    I: FnMut(&mut M, usize),\n-    R: FnMut(&mut M, usize),\n-{\n-    // setup\n-    for i in 0..n {\n-        insert(map, i * 2);\n-    }\n-\n-    // measure\n-    let mut i = 1;\n-    b.iter(|| {\n-        insert(map, i);\n-        remove(map, i);\n-        i = (i + 2) % n;\n-    });\n-    black_box(map);\n+macro_rules! map_insert_seq_bench {\n+    ($name: ident, $n: expr, $map: ident) => (\n+        #[bench]\n+        pub fn $name(b: &mut ::test::Bencher) {\n+            use test::black_box;\n+\n+            let mut map = $map::new();\n+            let n: usize = $n;\n+            // setup\n+            for i in 0..n {\n+                map.insert(i * 2, i * 2);\n+            }\n+\n+            // measure\n+            let mut i = 1;\n+            b.iter(|| {\n+                map.insert(i, i);\n+                map.remove(&i);\n+                i = (i + 2) % n;\n+            });\n+            black_box(map);\n+        }\n+    )\n }\n \n-pub fn find_rand_n<M, T, I, F>(n: usize,\n-                               map: &mut M,\n-                               b: &mut Bencher,\n-                               mut insert: I,\n-                               mut find: F) where\n-    I: FnMut(&mut M, usize),\n-    F: FnMut(&M, usize) -> T,\n-{\n-    // setup\n-    let mut rng = rand::weak_rng();\n-    let mut keys: Vec<_> = (0..n).map(|_| rng.gen::<usize>() % n).collect();\n-\n-    for k in &keys {\n-        insert(map, *k);\n-    }\n-\n-    rng.shuffle(&mut keys);\n-\n-    // measure\n-    let mut i = 0;\n-    b.iter(|| {\n-        let t = find(map, keys[i]);\n-        i = (i + 1) % n;\n-        black_box(t);\n-    })\n+macro_rules! map_find_rand_bench {\n+    ($name: ident, $n: expr, $map: ident) => (\n+        #[bench]\n+        pub fn $name(b: &mut ::test::Bencher) {\n+            use std::rand;\n+            use std::iter::IteratorExt;\n+            use std::rand::Rng;\n+            use test::black_box;\n+            use vec::Vec;\n+\n+            let mut map = $map::new();\n+            let n: usize = $n;\n+\n+            // setup\n+            let mut rng = rand::weak_rng();\n+            let mut keys: Vec<_> = (0..n).map(|_| rng.gen() % n).collect();\n+\n+            for &k in &keys {\n+                map.insert(k, k);\n+            }\n+\n+            rng.shuffle(&mut keys);\n+\n+            // measure\n+            let mut i = 0;\n+            b.iter(|| {\n+                let t = map.get(&keys[i]);\n+                i = (i + 1) % n;\n+                black_box(t);\n+            })\n+        }\n+    )\n }\n \n-pub fn find_seq_n<M, T, I, F>(n: usize,\n-                              map: &mut M,\n-                              b: &mut Bencher,\n-                              mut insert: I,\n-                              mut find: F) where\n-    I: FnMut(&mut M, usize),\n-    F: FnMut(&M, usize) -> T,\n-{\n-    // setup\n-    for i in 0..n {\n-        insert(map, i);\n-    }\n-\n-    // measure\n-    let mut i = 0;\n-    b.iter(|| {\n-        let x = find(map, i);\n-        i = (i + 1) % n;\n-        black_box(x);\n-    })\n+macro_rules! map_find_seq_bench {\n+    ($name: ident, $n: expr, $map: ident) => (\n+        #[bench]\n+        pub fn $name(b: &mut ::test::Bencher) {\n+            use test::black_box;\n+\n+            let mut map = $map::new();\n+            let n: usize = $n;\n+\n+            // setup\n+            for i in 0..n {\n+                map.insert(i, i);\n+            }\n+\n+            // measure\n+            let mut i = 0;\n+            b.iter(|| {\n+                let x = map.get(&i);\n+                i = (i + 1) % n;\n+                black_box(x);\n+            })\n+        }\n+    )\n }"}, {"sha": "0e4a4002d6a0991d2c21e0af1777cc16ba834a76", "filename": "src/libcollections/btree/map.rs", "status": "modified", "additions": 8, "deletions": 64, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/3ef8ff1f81107b42840a695725e1a0869c163355/src%2Flibcollections%2Fbtree%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ef8ff1f81107b42840a695725e1a0869c163355/src%2Flibcollections%2Fbtree%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fbtree%2Fmap.rs?ref=3ef8ff1f81107b42840a695725e1a0869c163355", "patch": "@@ -1843,74 +1843,18 @@ mod bench {\n     use test::{Bencher, black_box};\n \n     use super::BTreeMap;\n-    use bench::{insert_rand_n, insert_seq_n, find_rand_n, find_seq_n};\n \n-    #[bench]\n-    pub fn insert_rand_100(b: &mut Bencher) {\n-        let mut m = BTreeMap::new();\n-        insert_rand_n(100, &mut m, b,\n-                      |m, i| { m.insert(i, 1); },\n-                      |m, i| { m.remove(&i); });\n-    }\n-\n-    #[bench]\n-    pub fn insert_rand_10_000(b: &mut Bencher) {\n-        let mut m = BTreeMap::new();\n-        insert_rand_n(10_000, &mut m, b,\n-                      |m, i| { m.insert(i, 1); },\n-                      |m, i| { m.remove(&i); });\n-    }\n-\n-    // Insert seq\n-    #[bench]\n-    pub fn insert_seq_100(b: &mut Bencher) {\n-        let mut m = BTreeMap::new();\n-        insert_seq_n(100, &mut m, b,\n-                     |m, i| { m.insert(i, 1); },\n-                     |m, i| { m.remove(&i); });\n-    }\n-\n-    #[bench]\n-    pub fn insert_seq_10_000(b: &mut Bencher) {\n-        let mut m = BTreeMap::new();\n-        insert_seq_n(10_000, &mut m, b,\n-                     |m, i| { m.insert(i, 1); },\n-                     |m, i| { m.remove(&i); });\n-    }\n+    map_insert_rand_bench!{insert_rand_100,    100,    BTreeMap}\n+    map_insert_rand_bench!{insert_rand_10_000, 10_000, BTreeMap}\n \n-    // Find rand\n-    #[bench]\n-    pub fn find_rand_100(b: &mut Bencher) {\n-        let mut m = BTreeMap::new();\n-        find_rand_n(100, &mut m, b,\n-                    |m, i| { m.insert(i, 1); },\n-                    |m, i| { m.get(&i); });\n-    }\n-\n-    #[bench]\n-    pub fn find_rand_10_000(b: &mut Bencher) {\n-        let mut m = BTreeMap::new();\n-        find_rand_n(10_000, &mut m, b,\n-                    |m, i| { m.insert(i, 1); },\n-                    |m, i| { m.get(&i); });\n-    }\n+    map_insert_seq_bench!{insert_seq_100,    100,    BTreeMap}\n+    map_insert_seq_bench!{insert_seq_10_000, 10_000, BTreeMap}\n \n-    // Find seq\n-    #[bench]\n-    pub fn find_seq_100(b: &mut Bencher) {\n-        let mut m = BTreeMap::new();\n-        find_seq_n(100, &mut m, b,\n-                   |m, i| { m.insert(i, 1); },\n-                   |m, i| { m.get(&i); });\n-    }\n+    map_find_rand_bench!{find_rand_100,    100,    BTreeMap}\n+    map_find_rand_bench!{find_rand_10_000, 10_000, BTreeMap}\n \n-    #[bench]\n-    pub fn find_seq_10_000(b: &mut Bencher) {\n-        let mut m = BTreeMap::new();\n-        find_seq_n(10_000, &mut m, b,\n-                   |m, i| { m.insert(i, 1); },\n-                   |m, i| { m.get(&i); });\n-    }\n+    map_find_seq_bench!{find_seq_100,    100,    BTreeMap}\n+    map_find_seq_bench!{find_seq_10_000, 10_000, BTreeMap}\n \n     fn bench_iter(b: &mut Bencher, size: i32) {\n         let mut map = BTreeMap::<i32, i32>::new();"}, {"sha": "8f02f9fd580fafb2b7874a1fbb5f84e6361f7793", "filename": "src/libcollections/fmt.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3ef8ff1f81107b42840a695725e1a0869c163355/src%2Flibcollections%2Ffmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ef8ff1f81107b42840a695725e1a0869c163355/src%2Flibcollections%2Ffmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Ffmt.rs?ref=3ef8ff1f81107b42840a695725e1a0869c163355", "patch": "@@ -401,7 +401,7 @@\n //! them with the same character. For example, the `{` character is escaped with\n //! `{{` and the `}` character is escaped with `}}`.\n \n-#![unstable(feature = \"std_misc\")]\n+#![stable(feature = \"rust1\", since = \"1.0.0\")]\n \n pub use core::fmt::{Formatter, Result, Writer, rt};\n pub use core::fmt::{Show, String, Octal, Binary};"}, {"sha": "460c897b6ad36eb209b088369435a941dff84d67", "filename": "src/libcollections/lib.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/3ef8ff1f81107b42840a695725e1a0869c163355/src%2Flibcollections%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ef8ff1f81107b42840a695725e1a0869c163355/src%2Flibcollections%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Flib.rs?ref=3ef8ff1f81107b42840a695725e1a0869c163355", "patch": "@@ -27,10 +27,12 @@\n #![feature(box_patterns)]\n #![feature(core)]\n #![feature(hash)]\n+#![feature(slicing_syntax)]\n #![feature(staged_api)]\n #![feature(unboxed_closures)]\n #![feature(unicode)]\n-#![feature(unsafe_destructor, slicing_syntax)]\n+#![feature(unsafe_destructor)]\n+#![feature(unsafe_no_drop_flag)]\n #![cfg_attr(test, feature(rand, rustc_private, test))]\n #![cfg_attr(test, allow(deprecated))] // rand\n \n@@ -65,6 +67,8 @@ pub use alloc::boxed;\n #[macro_use]\n mod macros;\n \n+#[cfg(test)] #[macro_use] mod bench;\n+\n pub mod binary_heap;\n mod bit;\n mod btree;\n@@ -102,8 +106,6 @@ pub mod btree_set {\n }\n \n \n-#[cfg(test)] mod bench;\n-\n // FIXME(#14344) this shouldn't be necessary\n #[doc(hidden)]\n pub fn fixme_14344_be_sure_to_link_to_collections() {}"}, {"sha": "b3f398b9cdf498fa6809e171b3a53ec634df960a", "filename": "src/libcollections/slice.rs", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/3ef8ff1f81107b42840a695725e1a0869c163355/src%2Flibcollections%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ef8ff1f81107b42840a695725e1a0869c163355/src%2Flibcollections%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fslice.rs?ref=3ef8ff1f81107b42840a695725e1a0869c163355", "patch": "@@ -2508,6 +2508,18 @@ mod tests {\n         let wins: &[&[_]] = &[&[1,2,3], &[2,3,4]];\n         assert_eq!(v.windows(3).collect::<Vec<_>>(), wins);\n         assert!(v.windows(6).next().is_none());\n+\n+        let wins: &[&[_]] = &[&[3,4], &[2,3], &[1,2]];\n+        assert_eq!(v.windows(2).rev().collect::<Vec<&[_]>>(), wins);\n+        let mut it = v.windows(2);\n+        assert_eq!(it.indexable(), 3);\n+        let win: &[_] = &[1,2];\n+        assert_eq!(it.idx(0).unwrap(), win);\n+        let win: &[_] = &[2,3];\n+        assert_eq!(it.idx(1).unwrap(), win);\n+        let win: &[_] = &[3,4];\n+        assert_eq!(it.idx(2).unwrap(), win);\n+        assert_eq!(it.idx(3), None);\n     }\n \n     #[test]"}, {"sha": "ba358ada0adacaca2f7d3ff9609c16b230272f06", "filename": "src/libcollections/vec_map.rs", "status": "modified", "additions": 8, "deletions": 65, "changes": 73, "blob_url": "https://github.com/rust-lang/rust/blob/3ef8ff1f81107b42840a695725e1a0869c163355/src%2Flibcollections%2Fvec_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ef8ff1f81107b42840a695725e1a0869c163355/src%2Flibcollections%2Fvec_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fvec_map.rs?ref=3ef8ff1f81107b42840a695725e1a0869c163355", "patch": "@@ -1321,74 +1321,17 @@ mod test_map {\n \n #[cfg(test)]\n mod bench {\n-    use test::Bencher;\n     use super::VecMap;\n-    use bench::{insert_rand_n, insert_seq_n, find_rand_n, find_seq_n};\n \n-    #[bench]\n-    pub fn insert_rand_100(b: &mut Bencher) {\n-        let mut m = VecMap::new();\n-        insert_rand_n(100, &mut m, b,\n-                      |m, i| { m.insert(i, 1); },\n-                      |m, i| { m.remove(&i); });\n-    }\n-\n-    #[bench]\n-    pub fn insert_rand_10_000(b: &mut Bencher) {\n-        let mut m = VecMap::new();\n-        insert_rand_n(10_000, &mut m, b,\n-                      |m, i| { m.insert(i, 1); },\n-                      |m, i| { m.remove(&i); });\n-    }\n-\n-    // Insert seq\n-    #[bench]\n-    pub fn insert_seq_100(b: &mut Bencher) {\n-        let mut m = VecMap::new();\n-        insert_seq_n(100, &mut m, b,\n-                     |m, i| { m.insert(i, 1); },\n-                     |m, i| { m.remove(&i); });\n-    }\n-\n-    #[bench]\n-    pub fn insert_seq_10_000(b: &mut Bencher) {\n-        let mut m = VecMap::new();\n-        insert_seq_n(10_000, &mut m, b,\n-                     |m, i| { m.insert(i, 1); },\n-                     |m, i| { m.remove(&i); });\n-    }\n+    map_insert_rand_bench!{insert_rand_100,    100,    VecMap}\n+    map_insert_rand_bench!{insert_rand_10_000, 10_000, VecMap}\n \n-    // Find rand\n-    #[bench]\n-    pub fn find_rand_100(b: &mut Bencher) {\n-        let mut m = VecMap::new();\n-        find_rand_n(100, &mut m, b,\n-                    |m, i| { m.insert(i, 1); },\n-                    |m, i| { m.get(&i); });\n-    }\n-\n-    #[bench]\n-    pub fn find_rand_10_000(b: &mut Bencher) {\n-        let mut m = VecMap::new();\n-        find_rand_n(10_000, &mut m, b,\n-                    |m, i| { m.insert(i, 1); },\n-                    |m, i| { m.get(&i); });\n-    }\n+    map_insert_seq_bench!{insert_seq_100,    100,    VecMap}\n+    map_insert_seq_bench!{insert_seq_10_000, 10_000, VecMap}\n \n-    // Find seq\n-    #[bench]\n-    pub fn find_seq_100(b: &mut Bencher) {\n-        let mut m = VecMap::new();\n-        find_seq_n(100, &mut m, b,\n-                   |m, i| { m.insert(i, 1); },\n-                   |m, i| { m.get(&i); });\n-    }\n+    map_find_rand_bench!{find_rand_100,    100,    VecMap}\n+    map_find_rand_bench!{find_rand_10_000, 10_000, VecMap}\n \n-    #[bench]\n-    pub fn find_seq_10_000(b: &mut Bencher) {\n-        let mut m = VecMap::new();\n-        find_seq_n(10_000, &mut m, b,\n-                   |m, i| { m.insert(i, 1); },\n-                   |m, i| { m.get(&i); });\n-    }\n+    map_find_seq_bench!{find_seq_100,    100,    VecMap}\n+    map_find_seq_bench!{find_seq_10_000, 10_000, VecMap}\n }"}, {"sha": "f940300a26945cf84ed29536f217ec28a4f5fb9e", "filename": "src/libcore/fmt/mod.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3ef8ff1f81107b42840a695725e1a0869c163355/src%2Flibcore%2Ffmt%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ef8ff1f81107b42840a695725e1a0869c163355/src%2Flibcore%2Ffmt%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ffmt%2Fmod.rs?ref=3ef8ff1f81107b42840a695725e1a0869c163355", "patch": "@@ -268,6 +268,7 @@ pub trait Debug {\n     fn fmt(&self, &mut Formatter) -> Result;\n }\n \n+#[allow(deprecated)]\n impl<T: Show + ?Sized> Debug for T {\n     #[allow(deprecated)]\n     fn fmt(&self, f: &mut Formatter) -> Result { Show::fmt(self, f) }\n@@ -295,6 +296,7 @@ pub trait Display {\n     fn fmt(&self, &mut Formatter) -> Result;\n }\n \n+#[allow(deprecated)]\n impl<T: String + ?Sized> Display for T {\n     #[allow(deprecated)]\n     fn fmt(&self, f: &mut Formatter) -> Result { String::fmt(self, f) }"}, {"sha": "050c144b742994bf1d51dd8d57fc7286192b3f61", "filename": "src/libcore/intrinsics.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/3ef8ff1f81107b42840a695725e1a0869c163355/src%2Flibcore%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ef8ff1f81107b42840a695725e1a0869c163355/src%2Flibcore%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fintrinsics.rs?ref=3ef8ff1f81107b42840a695725e1a0869c163355", "patch": "@@ -262,11 +262,12 @@ extern \"rust-intrinsic\" {\n     ///\n     /// # Safety\n     ///\n-    /// Beyond requiring that both regions of memory be allocated, it is Undefined Behaviour\n-    /// for source and destination to overlap. Care must also be taken with the ownership of\n-    /// `src` and `dst`. This method semantically moves the values of `src` into `dst`.\n-    /// However it does not drop the contents of `dst`, or prevent the contents of `src`\n-    /// from being dropped or used.\n+    /// Beyond requiring that the program must be allowed to access both regions\n+    /// of memory, it is Undefined Behaviour for source and destination to\n+    /// overlap. Care must also be taken with the ownership of `src` and\n+    /// `dst`. This method semantically moves the values of `src` into `dst`.\n+    /// However it does not drop the contents of `dst`, or prevent the contents\n+    /// of `src` from being dropped or used.\n     ///\n     /// # Examples\n     ///"}, {"sha": "a46536e341edd1e1e3d98382de724deea96ff28b", "filename": "src/libcore/ops.rs", "status": "modified", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/3ef8ff1f81107b42840a695725e1a0869c163355/src%2Flibcore%2Fops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ef8ff1f81107b42840a695725e1a0869c163355/src%2Flibcore%2Fops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fops.rs?ref=3ef8ff1f81107b42840a695725e1a0869c163355", "patch": "@@ -1119,8 +1119,7 @@ impl<'a, T: ?Sized> DerefMut for &'a mut T {\n \n /// A version of the call operator that takes an immutable receiver.\n #[lang=\"fn\"]\n-#[unstable(feature = \"core\",\n-           reason = \"uncertain about variadic generics, input versus associated types\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[rustc_paren_sugar]\n pub trait Fn<Args> {\n     type Output;\n@@ -1131,8 +1130,7 @@ pub trait Fn<Args> {\n \n /// A version of the call operator that takes a mutable receiver.\n #[lang=\"fn_mut\"]\n-#[unstable(feature = \"core\",\n-           reason = \"uncertain about variadic generics, input versus associated types\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[rustc_paren_sugar]\n pub trait FnMut<Args> {\n     type Output;\n@@ -1143,8 +1141,7 @@ pub trait FnMut<Args> {\n \n /// A version of the call operator that takes a by-value receiver.\n #[lang=\"fn_once\"]\n-#[unstable(feature = \"core\",\n-           reason = \"uncertain about variadic generics, input versus associated types\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[rustc_paren_sugar]\n pub trait FnOnce<Args> {\n     type Output;"}, {"sha": "cf1df4ac423ca1215bc5c4a292979a036280ee56", "filename": "src/libcore/slice.rs", "status": "modified", "additions": 36, "deletions": 3, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/3ef8ff1f81107b42840a695725e1a0869c163355/src%2Flibcore%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ef8ff1f81107b42840a695725e1a0869c163355/src%2Flibcore%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fslice.rs?ref=3ef8ff1f81107b42840a695725e1a0869c163355", "patch": "@@ -41,7 +41,6 @@ use cmp::Ordering::{Less, Equal, Greater};\n use cmp;\n use default::Default;\n use iter::*;\n-use num::Int;\n use ops::{FnMut, self, Index};\n use ops::RangeFull;\n use option::Option;\n@@ -1179,8 +1178,42 @@ impl<'a, T> Iterator for Windows<'a, T> {\n         if self.size > self.v.len() {\n             (0, Some(0))\n         } else {\n-            let x = self.v.len() - self.size;\n-            (x.saturating_add(1), x.checked_add(1))\n+            let size = self.v.len() - self.size + 1;\n+            (size, Some(size))\n+        }\n+    }\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<'a, T> DoubleEndedIterator for Windows<'a, T> {\n+    #[inline]\n+    fn next_back(&mut self) -> Option<&'a [T]> {\n+        if self.size > self.v.len() {\n+            None\n+        } else {\n+            let ret = Some(&self.v[self.v.len()-self.size..]);\n+            self.v = &self.v[..self.v.len()-1];\n+            ret\n+        }\n+    }\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<'a, T> ExactSizeIterator for Windows<'a, T> {}\n+\n+#[unstable(feature = \"core\", reason = \"trait is experimental\")]\n+impl<'a, T> RandomAccessIterator for Windows<'a, T> {\n+    #[inline]\n+    fn indexable(&self) -> uint {\n+        self.size_hint().0\n+    }\n+\n+    #[inline]\n+    fn idx(&mut self, index: uint) -> Option<&'a [T]> {\n+        if index + self.size > self.v.len() {\n+            None\n+        } else {\n+            Some(&self.v[index .. index+self.size])\n         }\n     }\n }"}, {"sha": "747152a82449640483e0dd94ff53d703bf9b41a5", "filename": "src/libcore/str/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/3ef8ff1f81107b42840a695725e1a0869c163355/src%2Flibcore%2Fstr%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ef8ff1f81107b42840a695725e1a0869c163355/src%2Flibcore%2Fstr%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fstr%2Fmod.rs?ref=3ef8ff1f81107b42840a695725e1a0869c163355", "patch": "@@ -34,7 +34,7 @@ use ptr::PtrExt;\n use raw::{Repr, Slice};\n use result::Result::{self, Ok, Err};\n use slice::{self, SliceExt};\n-use uint;\n+use usize;\n \n macro_rules! delegate_iter {\n     (exact $te:ty : $ti:ty) => {\n@@ -783,7 +783,7 @@ impl TwoWaySearcher {\n                 byteset: byteset,\n \n                 position: 0,\n-                memory: uint::MAX // Dummy value to signify that the period is long\n+                memory: usize::MAX // Dummy value to signify that the period is long\n             }\n         }\n     }\n@@ -911,7 +911,7 @@ impl Searcher {\n             Naive(NaiveSearcher::new())\n         } else {\n             let searcher = TwoWaySearcher::new(needle);\n-            if searcher.memory == uint::MAX { // If the period is long\n+            if searcher.memory == usize::MAX { // If the period is long\n                 TwoWayLong(searcher)\n             } else {\n                 TwoWay(searcher)"}, {"sha": "1dec23059e51d715f7c6eb5d964dc567e11a2a96", "filename": "src/liblibc/lib.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/3ef8ff1f81107b42840a695725e1a0869c163355/src%2Fliblibc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ef8ff1f81107b42840a695725e1a0869c163355/src%2Fliblibc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliblibc%2Flib.rs?ref=3ef8ff1f81107b42840a695725e1a0869c163355", "patch": "@@ -2457,6 +2457,7 @@ pub mod consts {\n             pub const SHUT_RDWR: c_int = 2;\n         }\n         pub mod extra {\n+            use SOCKET;\n             use types::os::arch::c95::{c_int, c_long};\n             use types::os::arch::extra::{WORD, DWORD, BOOL, HANDLE};\n \n@@ -2663,7 +2664,7 @@ pub mod consts {\n \n             pub const MAX_PROTOCOL_CHAIN: DWORD = 7;\n             pub const WSAPROTOCOL_LEN: DWORD = 255;\n-            pub const INVALID_SOCKET: DWORD = !0;\n+            pub const INVALID_SOCKET: SOCKET = !0;\n \n             pub const DETACHED_PROCESS: DWORD = 0x00000008;\n             pub const CREATE_NEW_PROCESS_GROUP: DWORD = 0x00000200;"}, {"sha": "1fedf49738cdf1df2f066a3d316d3ca81b4176e7", "filename": "src/liblog/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3ef8ff1f81107b42840a695725e1a0869c163355/src%2Fliblog%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ef8ff1f81107b42840a695725e1a0869c163355/src%2Fliblog%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliblog%2Flib.rs?ref=3ef8ff1f81107b42840a695725e1a0869c163355", "patch": "@@ -397,7 +397,7 @@ fn enabled(level: u32,\n /// This is not threadsafe at all, so initialization is performed through a\n /// `Once` primitive (and this function is called from that primitive).\n fn init() {\n-    let (mut directives, filter) = match env::var_string(\"RUST_LOG\") {\n+    let (mut directives, filter) = match env::var(\"RUST_LOG\") {\n         Ok(spec) => directive::parse_logging_spec(&spec[]),\n         Err(..) => (Vec::new(), None),\n     };"}, {"sha": "20af4dadfcae97d052231e0d996724a9421e42b6", "filename": "src/librbml/lib.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/3ef8ff1f81107b42840a695725e1a0869c163355/src%2Flibrbml%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ef8ff1f81107b42840a695725e1a0869c163355/src%2Flibrbml%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrbml%2Flib.rs?ref=3ef8ff1f81107b42840a695725e1a0869c163355", "patch": "@@ -130,7 +130,7 @@ impl fmt::Display for Error {\n pub mod reader {\n     use std::char;\n \n-    use std::int;\n+    use std::isize;\n     use std::old_io::extensions::u64_from_be_bytes;\n     use std::mem::transmute;\n     use std::num::Int;\n@@ -440,7 +440,7 @@ pub mod reader {\n         fn read_u8 (&mut self) -> DecodeResult<u8 > { Ok(doc_as_u8 (try!(self.next_doc(EsU8 )))) }\n         fn read_uint(&mut self) -> DecodeResult<uint> {\n             let v = doc_as_u64(try!(self.next_doc(EsUint)));\n-            if v > (::std::uint::MAX as u64) {\n+            if v > (::std::usize::MAX as u64) {\n                 Err(IntTooBig(v as uint))\n             } else {\n                 Ok(v as uint)\n@@ -461,7 +461,7 @@ pub mod reader {\n         }\n         fn read_int(&mut self) -> DecodeResult<int> {\n             let v = doc_as_u64(try!(self.next_doc(EsInt))) as i64;\n-            if v > (int::MAX as i64) || v < (int::MIN as i64) {\n+            if v > (isize::MAX as i64) || v < (isize::MIN as i64) {\n                 debug!(\"FIXME \\\\#6122: Removing this makes this function miscompile\");\n                 Err(IntTooBig(v as uint))\n             } else {\n@@ -738,7 +738,6 @@ pub mod writer {\n         })\n     }\n \n-    // FIXME (#2741): Provide a function to write the standard rbml header.\n     impl<'a, W: Writer + Seek> Encoder<'a, W> {\n         pub fn new(w: &'a mut W) -> Encoder<'a, W> {\n             Encoder {"}, {"sha": "a415ff3ed7165cbe56d40a6318dc2f09720d438c", "filename": "src/librustc/lint/builtin.rs", "status": "modified", "additions": 39, "deletions": 3, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/3ef8ff1f81107b42840a695725e1a0869c163355/src%2Flibrustc%2Flint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ef8ff1f81107b42840a695725e1a0869c163355/src%2Flibrustc%2Flint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fbuiltin.rs?ref=3ef8ff1f81107b42840a695725e1a0869c163355", "patch": "@@ -1768,6 +1768,11 @@ impl LintPass for Stability {\n         stability::check_expr(cx.tcx, e,\n                               &mut |id, sp, stab| self.lint(cx, id, sp, stab));\n     }\n+\n+    fn check_path(&mut self, cx: &Context, path: &ast::Path, id: ast::NodeId) {\n+        stability::check_path(cx.tcx, path, id,\n+                              &mut |id, sp, stab| self.lint(cx, id, sp, stab));\n+    }\n }\n \n declare_lint! {\n@@ -2080,12 +2085,26 @@ declare_lint! {\n     \"functions marked #[no_mangle] should be exported\"\n }\n \n+declare_lint! {\n+    PRIVATE_NO_MANGLE_STATICS,\n+    Warn,\n+    \"statics marked #[no_mangle] should be exported\"\n+}\n+\n+declare_lint! {\n+    NO_MANGLE_CONST_ITEMS,\n+    Deny,\n+    \"const items will not have their symbols exported\"\n+}\n+\n #[derive(Copy)]\n-pub struct PrivateNoMangleFns;\n+pub struct InvalidNoMangleItems;\n \n-impl LintPass for PrivateNoMangleFns {\n+impl LintPass for InvalidNoMangleItems {\n     fn get_lints(&self) -> LintArray {\n-        lint_array!(PRIVATE_NO_MANGLE_FNS)\n+        lint_array!(PRIVATE_NO_MANGLE_FNS,\n+                    PRIVATE_NO_MANGLE_STATICS,\n+                    NO_MANGLE_CONST_ITEMS)\n     }\n \n     fn check_item(&mut self, cx: &Context, it: &ast::Item) {\n@@ -2098,6 +2117,23 @@ impl LintPass for PrivateNoMangleFns {\n                     cx.span_lint(PRIVATE_NO_MANGLE_FNS, it.span, &msg);\n                 }\n             },\n+            ast::ItemStatic(..) => {\n+                if attr::contains_name(it.attrs.as_slice(), \"no_mangle\") &&\n+                       !cx.exported_items.contains(&it.id) {\n+                    let msg = format!(\"static {} is marked #[no_mangle], but not exported\",\n+                                      it.ident);\n+                    cx.span_lint(PRIVATE_NO_MANGLE_STATICS, it.span, msg.as_slice());\n+                }\n+            },\n+            ast::ItemConst(..) => {\n+                if attr::contains_name(it.attrs.as_slice(), \"no_mangle\") {\n+                    // Const items do not refer to a particular location in memory, and therefore\n+                    // don't have anything to attach a symbol to\n+                    let msg = \"const items should never be #[no_mangle], consider instead using \\\n+                        `pub static`\";\n+                    cx.span_lint(NO_MANGLE_CONST_ITEMS, it.span, msg);\n+                }\n+            }\n             _ => {},\n         }\n     }"}, {"sha": "616af79326d9a5445633ee4d9372c7f564c4ff20", "filename": "src/librustc/lint/context.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3ef8ff1f81107b42840a695725e1a0869c163355/src%2Flibrustc%2Flint%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ef8ff1f81107b42840a695725e1a0869c163355/src%2Flibrustc%2Flint%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fcontext.rs?ref=3ef8ff1f81107b42840a695725e1a0869c163355", "patch": "@@ -213,7 +213,7 @@ impl LintStore {\n                      UnstableFeatures,\n                      Stability,\n                      UnconditionalRecursion,\n-                     PrivateNoMangleFns,\n+                     InvalidNoMangleItems,\n         );\n \n         add_builtin_with_new!(sess,"}, {"sha": "30d7ec8be639bb7df45e8e626cd97f79f0dc225d", "filename": "src/librustc/metadata/creader.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3ef8ff1f81107b42840a695725e1a0869c163355/src%2Flibrustc%2Fmetadata%2Fcreader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ef8ff1f81107b42840a695725e1a0869c163355/src%2Flibrustc%2Fmetadata%2Fcreader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fcreader.rs?ref=3ef8ff1f81107b42840a695725e1a0869c163355", "patch": "@@ -462,7 +462,7 @@ impl<'a> CrateReader<'a> {\n                      name: s.to_string(),\n                      ident: s.to_string(),\n                      id: ast::DUMMY_NODE_ID,\n-                     should_link: true,\n+                     should_link: false,\n                  }, sp)\n             }\n         };"}, {"sha": "3caa0f5b4db4c97a13722cabc0a5ba1b6d280c3a", "filename": "src/librustc/metadata/filesearch.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3ef8ff1f81107b42840a695725e1a0869c163355/src%2Flibrustc%2Fmetadata%2Ffilesearch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ef8ff1f81107b42840a695725e1a0869c163355/src%2Flibrustc%2Fmetadata%2Ffilesearch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Ffilesearch.rs?ref=3ef8ff1f81107b42840a695725e1a0869c163355", "patch": "@@ -207,7 +207,7 @@ static PATH_ENTRY_SEPARATOR: &'static str = \":\";\n \n /// Returns RUST_PATH as a string, without default paths added\n pub fn get_rust_path() -> Option<String> {\n-    env::var_string(\"RUST_PATH\").ok()\n+    env::var(\"RUST_PATH\").ok()\n }\n \n /// Returns the value of RUST_PATH, as a list"}, {"sha": "b792a44d4d89aad86e57da055cdd5ea1c81fe3d8", "filename": "src/librustc/middle/dataflow.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/3ef8ff1f81107b42840a695725e1a0869c163355/src%2Flibrustc%2Fmiddle%2Fdataflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ef8ff1f81107b42840a695725e1a0869c163355/src%2Flibrustc%2Fmiddle%2Fdataflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fdataflow.rs?ref=3ef8ff1f81107b42840a695725e1a0869c163355", "patch": "@@ -20,7 +20,7 @@ use middle::cfg;\n use middle::cfg::CFGIndex;\n use middle::ty;\n use std::old_io;\n-use std::uint;\n+use std::usize;\n use std::iter::repeat;\n use syntax::ast;\n use syntax::ast_util::IdRange;\n@@ -48,7 +48,7 @@ pub struct DataFlowContext<'a, 'tcx: 'a, O> {\n     bits_per_id: uint,\n \n     /// number of words we will use to store bits_per_id.\n-    /// equal to bits_per_id/uint::BITS rounded up.\n+    /// equal to bits_per_id/usize::BITS rounded up.\n     words_per_id: uint,\n \n     // mapping from node to cfg node index\n@@ -193,7 +193,7 @@ impl<'a, 'tcx, O:DataFlowOperator> DataFlowContext<'a, 'tcx, O> {\n                oper: O,\n                id_range: IdRange,\n                bits_per_id: uint) -> DataFlowContext<'a, 'tcx, O> {\n-        let words_per_id = (bits_per_id + uint::BITS - 1) / uint::BITS;\n+        let words_per_id = (bits_per_id + usize::BITS - 1) / usize::BITS;\n         let num_nodes = cfg.graph.all_nodes().len();\n \n         debug!(\"DataFlowContext::new(analysis_name: {}, id_range={:?}, \\\n@@ -202,7 +202,7 @@ impl<'a, 'tcx, O:DataFlowOperator> DataFlowContext<'a, 'tcx, O> {\n                analysis_name, id_range, bits_per_id, words_per_id,\n                num_nodes);\n \n-        let entry = if oper.initial_value() { uint::MAX } else {0};\n+        let entry = if oper.initial_value() { usize::MAX } else {0};\n \n         let gens: Vec<_> = repeat(0).take(num_nodes * words_per_id).collect();\n         let kills: Vec<_> = repeat(0).take(num_nodes * words_per_id).collect();\n@@ -351,13 +351,13 @@ impl<'a, 'tcx, O:DataFlowOperator> DataFlowContext<'a, 'tcx, O> {\n \n         for (word_index, &word) in words.iter().enumerate() {\n             if word != 0 {\n-                let base_index = word_index * uint::BITS;\n-                for offset in 0..uint::BITS {\n+                let base_index = word_index * usize::BITS;\n+                for offset in 0..usize::BITS {\n                     let bit = 1 << offset;\n                     if (word & bit) != 0 {\n                         // NB: we round up the total number of bits\n                         // that we store in any given bit set so that\n-                        // it is an even multiple of uint::BITS.  This\n+                        // it is an even multiple of usize::BITS.  This\n                         // means that there may be some stray bits at\n                         // the end that do not correspond to any\n                         // actual value.  So before we callback, check\n@@ -500,7 +500,7 @@ impl<'a, 'b, 'tcx, O:DataFlowOperator> PropagationContext<'a, 'b, 'tcx, O> {\n     }\n \n     fn reset(&mut self, bits: &mut [uint]) {\n-        let e = if self.dfcx.oper.initial_value() {uint::MAX} else {0};\n+        let e = if self.dfcx.oper.initial_value() {usize::MAX} else {0};\n         for b in bits {\n             *b = e;\n         }\n@@ -552,7 +552,7 @@ fn bits_to_string(words: &[uint]) -> String {\n \n     for &word in words {\n         let mut v = word;\n-        for _ in 0..uint::BYTES {\n+        for _ in 0..usize::BYTES {\n             result.push(sep);\n             result.push_str(&format!(\"{:02x}\", v & 0xFF)[]);\n             v >>= 8;\n@@ -581,8 +581,8 @@ fn bitwise<Op:BitwiseOperator>(out_vec: &mut [uint],\n fn set_bit(words: &mut [uint], bit: uint) -> bool {\n     debug!(\"set_bit: words={} bit={}\",\n            mut_bits_to_string(words), bit_str(bit));\n-    let word = bit / uint::BITS;\n-    let bit_in_word = bit % uint::BITS;\n+    let word = bit / usize::BITS;\n+    let bit_in_word = bit % usize::BITS;\n     let bit_mask = 1 << bit_in_word;\n     debug!(\"word={} bit_in_word={} bit_mask={}\", word, bit_in_word, word);\n     let oldv = words[word];"}, {"sha": "b2335f91ad9869641801490e62637710aee4fa86", "filename": "src/librustc/middle/dead.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3ef8ff1f81107b42840a695725e1a0869c163355/src%2Flibrustc%2Fmiddle%2Fdead.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ef8ff1f81107b42840a695725e1a0869c163355/src%2Flibrustc%2Fmiddle%2Fdead.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fdead.rs?ref=3ef8ff1f81107b42840a695725e1a0869c163355", "patch": "@@ -234,7 +234,7 @@ impl<'a, 'tcx> MarkSymbolVisitor<'a, 'tcx> {\n             ast_map::NodeImplItem(impl_item) => {\n                 match *impl_item {\n                     ast::MethodImplItem(ref method) => {\n-                        visit::walk_block(self, method.pe_body());\n+                        visit::walk_method_helper(self, method);\n                     }\n                     ast::TypeImplItem(_) => {}\n                 }"}, {"sha": "0ce9db1c80f3f21c4741083a46e983a4bb37ea23", "filename": "src/librustc/middle/entry.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/3ef8ff1f81107b42840a695725e1a0869c163355/src%2Flibrustc%2Fmiddle%2Fentry.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ef8ff1f81107b42840a695725e1a0869c163355/src%2Flibrustc%2Fmiddle%2Fentry.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fentry.rs?ref=3ef8ff1f81107b42840a695725e1a0869c163355", "patch": "@@ -50,10 +50,7 @@ pub fn find_entry_point(session: &Session, ast_map: &ast_map::Map) {\n     let any_exe = session.crate_types.borrow().iter().any(|ty| {\n         *ty == config::CrateTypeExecutable\n     });\n-    let emit_link = session.opts.output_types.iter().any(|ty| {\n-        *ty == config::OutputTypeExe\n-    });\n-    if !any_exe || !emit_link {\n+    if !any_exe {\n         // No need to find a main function\n         return\n     }"}, {"sha": "4dd7a4a226629bf4b338bcfdb1abc6ce6e613ff1", "filename": "src/librustc/middle/graph.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/3ef8ff1f81107b42840a695725e1a0869c163355/src%2Flibrustc%2Fmiddle%2Fgraph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ef8ff1f81107b42840a695725e1a0869c163355/src%2Flibrustc%2Fmiddle%2Fgraph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fgraph.rs?ref=3ef8ff1f81107b42840a695725e1a0869c163355", "patch": "@@ -33,7 +33,7 @@\n #![allow(dead_code)] // still WIP\n \n use std::fmt::{Formatter, Error, Debug};\n-use std::uint;\n+use std::usize;\n use std::collections::BitvSet;\n \n pub struct Graph<N,E> {\n@@ -64,12 +64,12 @@ impl<E: Debug> Debug for Edge<E> {\n #[derive(Clone, Copy, PartialEq, Debug)]\n pub struct NodeIndex(pub uint);\n #[allow(non_upper_case_globals)]\n-pub const InvalidNodeIndex: NodeIndex = NodeIndex(uint::MAX);\n+pub const InvalidNodeIndex: NodeIndex = NodeIndex(usize::MAX);\n \n #[derive(Copy, PartialEq, Debug)]\n pub struct EdgeIndex(pub uint);\n #[allow(non_upper_case_globals)]\n-pub const InvalidEdgeIndex: EdgeIndex = EdgeIndex(uint::MAX);\n+pub const InvalidEdgeIndex: EdgeIndex = EdgeIndex(usize::MAX);\n \n // Use a private field here to guarantee no more instances are created:\n #[derive(Copy, Debug)]"}, {"sha": "67875ae225224e030918f037980a9a72cac7e56a", "filename": "src/librustc/middle/infer/region_inference/graphviz.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3ef8ff1f81107b42840a695725e1a0869c163355/src%2Flibrustc%2Fmiddle%2Finfer%2Fregion_inference%2Fgraphviz.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ef8ff1f81107b42840a695725e1a0869c163355/src%2Flibrustc%2Fmiddle%2Finfer%2Fregion_inference%2Fgraphviz.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Fregion_inference%2Fgraphviz.rs?ref=3ef8ff1f81107b42840a695725e1a0869c163355", "patch": "@@ -61,13 +61,13 @@ pub fn maybe_print_constraints_for<'a, 'tcx>(region_vars: &RegionVarBindings<'a,\n     }\n \n     let requested_node : Option<ast::NodeId> =\n-        env::var_string(\"RUST_REGION_GRAPH_NODE\").ok().and_then(|s| s.parse().ok());\n+        env::var(\"RUST_REGION_GRAPH_NODE\").ok().and_then(|s| s.parse().ok());\n \n     if requested_node.is_some() && requested_node != Some(subject_node) {\n         return;\n     }\n \n-    let requested_output = env::var_string(\"RUST_REGION_GRAPH\").ok();\n+    let requested_output = env::var(\"RUST_REGION_GRAPH\").ok();\n     debug!(\"requested_output: {:?} requested_node: {:?}\",\n            requested_output, requested_node);\n "}, {"sha": "a086e91f4d9f26e40cf8dfe9f29a3aceeb52c1a5", "filename": "src/librustc/middle/stability.rs", "status": "modified", "additions": 23, "deletions": 20, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/3ef8ff1f81107b42840a695725e1a0869c163355/src%2Flibrustc%2Fmiddle%2Fstability.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ef8ff1f81107b42840a695725e1a0869c163355/src%2Flibrustc%2Fmiddle%2Fstability.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fstability.rs?ref=3ef8ff1f81107b42840a695725e1a0869c163355", "patch": "@@ -13,6 +13,7 @@\n \n use session::Session;\n use lint;\n+use middle::def;\n use middle::ty;\n use middle::privacy::PublicItems;\n use metadata::csearch;\n@@ -277,6 +278,11 @@ impl<'a, 'tcx> Checker<'a, 'tcx> {\n \n impl<'a, 'v, 'tcx> Visitor<'v> for Checker<'a, 'tcx> {\n     fn visit_item(&mut self, item: &ast::Item) {\n+        // When compiling with --test we don't enforce stability on the\n+        // compiler-generated test module, demarcated with `DUMMY_SP` plus the\n+        // name `__test`\n+        if item.span == DUMMY_SP && item.ident.as_str() == \"__test\" { return }\n+\n         check_item(self.tcx, item,\n                    &mut |id, sp, stab| self.check(id, sp, stab));\n         visit::walk_item(self, item);\n@@ -287,6 +293,12 @@ impl<'a, 'v, 'tcx> Visitor<'v> for Checker<'a, 'tcx> {\n                    &mut |id, sp, stab| self.check(id, sp, stab));\n         visit::walk_expr(self, ex);\n     }\n+\n+    fn visit_path(&mut self, path: &ast::Path, id: ast::NodeId) {\n+        check_path(self.tcx, path, id,\n+                   &mut |id, sp, stab| self.check(id, sp, stab));\n+        visit::walk_path(self, path)\n+    }\n }\n \n /// Helper for discovering nodes to check for stability\n@@ -304,18 +316,6 @@ pub fn check_item(tcx: &ty::ctxt, item: &ast::Item,\n             let id = ast::DefId { krate: cnum, node: ast::CRATE_NODE_ID };\n             maybe_do_stability_check(tcx, id, item.span, cb);\n         }\n-        ast::ItemTrait(_, _, ref supertraits, _) => {\n-            for t in &**supertraits {\n-                if let ast::TraitTyParamBound(ref t, _) = *t {\n-                    let id = ty::trait_ref_to_def_id(tcx, &t.trait_ref);\n-                    maybe_do_stability_check(tcx, id, t.trait_ref.path.span, cb);\n-                }\n-            }\n-        }\n-        ast::ItemImpl(_, _, _, Some(ref t), _, _) => {\n-            let id = ty::trait_ref_to_def_id(tcx, t);\n-            maybe_do_stability_check(tcx, id, t.path.span, cb);\n-        }\n         _ => (/* pass */)\n     }\n }\n@@ -325,15 +325,8 @@ pub fn check_expr(tcx: &ty::ctxt, e: &ast::Expr,\n                   cb: &mut FnMut(ast::DefId, Span, &Option<Stability>)) {\n     if is_internal(tcx, e.span) { return; }\n \n-    let mut span = e.span;\n-\n+    let span;\n     let id = match e.node {\n-        ast::ExprPath(..) | ast::ExprQPath(..) | ast::ExprStruct(..) => {\n-            match tcx.def_map.borrow().get(&e.id) {\n-                Some(&def) => def.def_id(),\n-                None => return\n-            }\n-        }\n         ast::ExprMethodCall(i, _, _) => {\n             span = i.span;\n             let method_call = ty::MethodCall::expr(e.id);\n@@ -369,6 +362,16 @@ pub fn check_expr(tcx: &ty::ctxt, e: &ast::Expr,\n     maybe_do_stability_check(tcx, id, span, cb);\n }\n \n+pub fn check_path(tcx: &ty::ctxt, path: &ast::Path, id: ast::NodeId,\n+                  cb: &mut FnMut(ast::DefId, Span, &Option<Stability>)) {\n+    let did = match tcx.def_map.borrow().get(&id) {\n+        Some(&def::DefPrimTy(..)) => return,\n+        Some(def) => def.def_id(),\n+        None => return\n+    };\n+    maybe_do_stability_check(tcx, did, path.span, cb)\n+}\n+\n fn maybe_do_stability_check(tcx: &ty::ctxt, id: ast::DefId, span: Span,\n                             cb: &mut FnMut(ast::DefId, Span, &Option<Stability>)) {\n     if !is_staged_api(tcx, id) { return  }"}, {"sha": "bddbb7c02baa77b827196d6b8ff4af702da8c939", "filename": "src/librustc/middle/traits/mod.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/3ef8ff1f81107b42840a695725e1a0869c163355/src%2Flibrustc%2Fmiddle%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ef8ff1f81107b42840a695725e1a0869c163355/src%2Flibrustc%2Fmiddle%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Fmod.rs?ref=3ef8ff1f81107b42840a695725e1a0869c163355", "patch": "@@ -63,7 +63,7 @@ mod util;\n /// either identifying an `impl` (e.g., `impl Eq for int`) that\n /// provides the required vtable, or else finding a bound that is in\n /// scope. The eventual result is usually a `Selection` (defined below).\n-#[derive(Clone)]\n+#[derive(Clone, PartialEq, Eq)]\n pub struct Obligation<'tcx, T> {\n     pub cause: ObligationCause<'tcx>,\n     pub recursion_depth: uint,\n@@ -74,7 +74,7 @@ pub type PredicateObligation<'tcx> = Obligation<'tcx, ty::Predicate<'tcx>>;\n pub type TraitObligation<'tcx> = Obligation<'tcx, ty::PolyTraitPredicate<'tcx>>;\n \n /// Why did we incur this obligation? Used for error reporting.\n-#[derive(Clone)]\n+#[derive(Clone, PartialEq, Eq)]\n pub struct ObligationCause<'tcx> {\n     pub span: Span,\n \n@@ -89,7 +89,7 @@ pub struct ObligationCause<'tcx> {\n     pub code: ObligationCauseCode<'tcx>\n }\n \n-#[derive(Clone)]\n+#[derive(Clone, PartialEq, Eq)]\n pub enum ObligationCauseCode<'tcx> {\n     /// Not well classified or should be obvious from span.\n     MiscObligation,\n@@ -129,7 +129,7 @@ pub enum ObligationCauseCode<'tcx> {\n     CompareImplMethodObligation,\n }\n \n-#[derive(Clone)]\n+#[derive(Clone, PartialEq, Eq)]\n pub struct DerivedObligationCause<'tcx> {\n     /// The trait reference of the parent obligation that led to the\n     /// current obligation. Note that only trait obligations lead to\n@@ -251,7 +251,7 @@ pub enum Vtable<'tcx, N> {\n /// is `Obligation`, as one might expect. During trans, however, this\n /// is `()`, because trans only requires a shallow resolution of an\n /// impl, and nested obligations are satisfied later.\n-#[derive(Clone)]\n+#[derive(Clone, PartialEq, Eq)]\n pub struct VtableImplData<'tcx, N> {\n     pub impl_def_id: ast::DefId,\n     pub substs: subst::Substs<'tcx>,"}, {"sha": "7d02adea1fa5ce245efde5236933919718ef7428", "filename": "src/librustc/middle/traits/project.rs", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/3ef8ff1f81107b42840a695725e1a0869c163355/src%2Flibrustc%2Fmiddle%2Ftraits%2Fproject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ef8ff1f81107b42840a695725e1a0869c163355/src%2Flibrustc%2Fmiddle%2Ftraits%2Fproject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Fproject.rs?ref=3ef8ff1f81107b42840a695725e1a0869c163355", "patch": "@@ -54,6 +54,7 @@ pub struct MismatchedProjectionTypes<'tcx> {\n     pub err: ty::type_err<'tcx>\n }\n \n+#[derive(PartialEq, Eq)]\n enum ProjectionTyCandidate<'tcx> {\n     ParamEnv(ty::PolyProjectionPredicate<'tcx>),\n     Impl(VtableImplData<'tcx, PredicateObligation<'tcx>>),\n@@ -481,6 +482,25 @@ fn project_type<'cx,'tcx>(\n \n     // We probably need some winnowing logic similar to select here.\n \n+    // Drop duplicates.\n+    //\n+    // Note: `candidates.vec` seems to be on the critical path of the\n+    // compiler. Replacing it with an hash set was also tried, which would\n+    // render the following dedup unnecessary. It led to cleaner code but\n+    // prolonged compiling time of `librustc` from 5m30s to 6m in one test, or\n+    // ~9% performance lost.\n+    if candidates.vec.len() > 1 {\n+        let mut i = 0;\n+        while i < candidates.vec.len() {\n+            let has_dup = (0..i).any(|j| candidates.vec[i] == candidates.vec[j]);\n+            if has_dup {\n+                candidates.vec.swap_remove(i);\n+            } else {\n+                i += 1;\n+            }\n+        }\n+    }\n+\n     if candidates.ambiguous || candidates.vec.len() > 1 {\n         return Err(ProjectionTyError::TooManyCandidates);\n     }"}, {"sha": "b46454bfdd04ef409d79137e3d0a3fdcc7de5218", "filename": "src/librustc/plugin/load.rs", "status": "modified", "additions": 41, "deletions": 26, "changes": 67, "blob_url": "https://github.com/rust-lang/rust/blob/3ef8ff1f81107b42840a695725e1a0869c163355/src%2Flibrustc%2Fplugin%2Fload.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ef8ff1f81107b42840a695725e1a0869c163355/src%2Flibrustc%2Fplugin%2Fload.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fplugin%2Fload.rs?ref=3ef8ff1f81107b42840a695725e1a0869c163355", "patch": "@@ -17,7 +17,7 @@ use plugin::registry::Registry;\n use std::mem;\n use std::env;\n use std::dynamic_lib::DynamicLibrary;\n-use std::collections::HashSet;\n+use std::collections::{HashSet, HashMap};\n use std::borrow::ToOwned;\n use syntax::ast;\n use syntax::attr;\n@@ -116,6 +116,8 @@ pub fn load_plugins(sess: &Session, krate: &ast::Crate,\n     return loader.plugins;\n }\n \n+pub type MacroSelection = HashMap<token::InternedString, Span>;\n+\n // note that macros aren't expanded yet, and therefore macros can't add plugins.\n impl<'a, 'v> Visitor<'v> for PluginLoader<'a> {\n     fn visit_item(&mut self, item: &ast::Item) {\n@@ -128,9 +130,9 @@ impl<'a, 'v> Visitor<'v> for PluginLoader<'a> {\n             }\n         }\n \n-        // Parse the attributes relating to macro / plugin loading.\n-        let mut macro_selection = Some(HashSet::new());  // None => load all\n-        let mut reexport = HashSet::new();\n+        // Parse the attributes relating to macro loading.\n+        let mut import = Some(HashMap::new());  // None => load all\n+        let mut reexport = HashMap::new();\n         for attr in &item.attrs {\n             let mut used = true;\n             match &attr.name()[] {\n@@ -147,14 +149,14 @@ impl<'a, 'v> Visitor<'v> for PluginLoader<'a> {\n                     let names = attr.meta_item_list();\n                     if names.is_none() {\n                         // no names => load all\n-                        macro_selection = None;\n+                        import = None;\n                     }\n-                    if let (Some(sel), Some(names)) = (macro_selection.as_mut(), names) {\n-                        for name in names {\n-                            if let ast::MetaWord(ref name) = name.node {\n-                                sel.insert(name.clone());\n+                    if let (Some(sel), Some(names)) = (import.as_mut(), names) {\n+                        for attr in names {\n+                            if let ast::MetaWord(ref name) = attr.node {\n+                                sel.insert(name.clone(), attr.span);\n                             } else {\n-                                self.sess.span_err(name.span, \"bad macro import\");\n+                                self.sess.span_err(attr.span, \"bad macro import\");\n                             }\n                         }\n                     }\n@@ -168,11 +170,11 @@ impl<'a, 'v> Visitor<'v> for PluginLoader<'a> {\n                         }\n                     };\n \n-                    for name in names {\n-                        if let ast::MetaWord(ref name) = name.node {\n-                            reexport.insert(name.clone());\n+                    for attr in names {\n+                        if let ast::MetaWord(ref name) = attr.node {\n+                            reexport.insert(name.clone(), attr.span);\n                         } else {\n-                            self.sess.span_err(name.span, \"bad macro reexport\");\n+                            self.sess.span_err(attr.span, \"bad macro reexport\");\n                         }\n                     }\n                 }\n@@ -183,7 +185,7 @@ impl<'a, 'v> Visitor<'v> for PluginLoader<'a> {\n             }\n         }\n \n-        self.load_macros(item, macro_selection, Some(reexport))\n+        self.load_macros(item, import, reexport)\n     }\n \n     fn visit_mac(&mut self, _: &ast::Mac) {\n@@ -195,10 +197,10 @@ impl<'a, 'v> Visitor<'v> for PluginLoader<'a> {\n impl<'a> PluginLoader<'a> {\n     pub fn load_macros<'b>(&mut self,\n                            vi: &ast::Item,\n-                           macro_selection: Option<HashSet<token::InternedString>>,\n-                           reexport: Option<HashSet<token::InternedString>>) {\n-        if let (Some(sel), Some(re)) = (macro_selection.as_ref(), reexport.as_ref()) {\n-            if sel.is_empty() && re.is_empty() {\n+                           import: Option<MacroSelection>,\n+                           reexport: MacroSelection) {\n+        if let Some(sel) = import.as_ref() {\n+            if sel.is_empty() && reexport.is_empty() {\n                 return;\n             }\n         }\n@@ -211,19 +213,32 @@ impl<'a> PluginLoader<'a> {\n \n         let pmd = self.reader.read_plugin_metadata(CrateOrString::Krate(vi));\n \n+        let mut seen = HashSet::new();\n         for mut def in pmd.exported_macros() {\n             let name = token::get_ident(def.ident);\n-            def.use_locally = match macro_selection.as_ref() {\n+            seen.insert(name.clone());\n+\n+            def.use_locally = match import.as_ref() {\n                 None => true,\n-                Some(sel) => sel.contains(&name),\n-            };\n-            def.export = if let Some(ref re) = reexport {\n-                re.contains(&name)\n-            } else {\n-                false // Don't reexport macros from crates loaded from the command line\n+                Some(sel) => sel.contains_key(&name),\n             };\n+            def.export = reexport.contains_key(&name);\n             self.plugins.macros.push(def);\n         }\n+\n+        if let Some(sel) = import.as_ref() {\n+            for (name, span) in sel.iter() {\n+                if !seen.contains(name) {\n+                    self.sess.span_err(*span, \"imported macro not found\");\n+                }\n+            }\n+        }\n+\n+        for (name, span) in reexport.iter() {\n+            if !seen.contains(name) {\n+                self.sess.span_err(*span, \"reexported macro not found\");\n+            }\n+        }\n     }\n \n     pub fn load_plugin<'b>(&mut self,"}, {"sha": "8340a49b92ae35ef419f4619c27cc5001d9e9b27", "filename": "src/librustc/session/config.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3ef8ff1f81107b42840a695725e1a0869c163355/src%2Flibrustc%2Fsession%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ef8ff1f81107b42840a695725e1a0869c163355/src%2Flibrustc%2Fsession%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fsession%2Fconfig.rs?ref=3ef8ff1f81107b42840a695725e1a0869c163355", "patch": "@@ -1052,7 +1052,7 @@ pub fn get_unstable_features_setting() -> UnstableFeatures {\n     // subverting the unstable features lints\n     let bootstrap_secret_key = option_env!(\"CFG_BOOTSTRAP_KEY\");\n     // The matching key to the above, only known by the build system\n-    let bootstrap_provided_key = env::var_string(\"RUSTC_BOOTSTRAP_KEY\").ok();\n+    let bootstrap_provided_key = env::var(\"RUSTC_BOOTSTRAP_KEY\").ok();\n     match (disable_unstable_features, bootstrap_secret_key, bootstrap_provided_key) {\n         (_, Some(ref s), Some(ref p)) if s == p => UnstableFeatures::Cheat,\n         (true, _, _) => UnstableFeatures::Disallow,"}, {"sha": "4d90c492fa2406f24bffcabb5d89f57909a5a48f", "filename": "src/librustc_back/target/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3ef8ff1f81107b42840a695725e1a0869c163355/src%2Flibrustc_back%2Ftarget%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ef8ff1f81107b42840a695725e1a0869c163355/src%2Flibrustc_back%2Ftarget%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ftarget%2Fmod.rs?ref=3ef8ff1f81107b42840a695725e1a0869c163355", "patch": "@@ -384,7 +384,7 @@ impl Target {\n             Path::new(target)\n         };\n \n-        let target_path = env::var(\"RUST_TARGET_PATH\")\n+        let target_path = env::var_os(\"RUST_TARGET_PATH\")\n                               .unwrap_or(OsString::from_str(\"\"));\n \n         // FIXME 16351: add a sane default search path?"}, {"sha": "9c5ddc06519b97208e523379170d84609ef430b4", "filename": "src/librustc_borrowck/borrowck/move_data.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/3ef8ff1f81107b42840a695725e1a0869c163355/src%2Flibrustc_borrowck%2Fborrowck%2Fmove_data.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ef8ff1f81107b42840a695725e1a0869c163355/src%2Flibrustc_borrowck%2Fborrowck%2Fmove_data.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fmove_data.rs?ref=3ef8ff1f81107b42840a695725e1a0869c163355", "patch": "@@ -24,7 +24,7 @@ use rustc::util::nodemap::{FnvHashMap, NodeSet};\n use rustc::util::ppaux::Repr;\n use std::cell::RefCell;\n use std::rc::Rc;\n-use std::uint;\n+use std::usize;\n use syntax::ast;\n use syntax::ast_util;\n use syntax::codemap::Span;\n@@ -92,7 +92,7 @@ impl Clone for MovePathIndex {\n \n #[allow(non_upper_case_globals)]\n static InvalidMovePathIndex: MovePathIndex =\n-    MovePathIndex(uint::MAX);\n+    MovePathIndex(usize::MAX);\n \n /// Index into `MoveData.moves`, used like a pointer\n #[derive(Copy, PartialEq)]\n@@ -106,7 +106,7 @@ impl MoveIndex {\n \n #[allow(non_upper_case_globals)]\n static InvalidMoveIndex: MoveIndex =\n-    MoveIndex(uint::MAX);\n+    MoveIndex(usize::MAX);\n \n pub struct MovePath<'tcx> {\n     /// Loan path corresponding to this move path"}, {"sha": "12f5041cad14f996bbc2a0c65e0971dc6b09ebc4", "filename": "src/librustc_driver/driver.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3ef8ff1f81107b42840a695725e1a0869c163355/src%2Flibrustc_driver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ef8ff1f81107b42840a695725e1a0869c163355/src%2Flibrustc_driver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Fdriver.rs?ref=3ef8ff1f81107b42840a695725e1a0869c163355", "patch": "@@ -464,7 +464,7 @@ pub fn phase_2_configure_and_expand(sess: &Session,\n             // compiler, not for the target.\n             let mut _old_path = OsString::from_str(\"\");\n             if cfg!(windows) {\n-                _old_path = env::var(\"PATH\").unwrap_or(_old_path);\n+                _old_path = env::var_os(\"PATH\").unwrap_or(_old_path);\n                 let mut new_path = sess.host_filesearch(PathKind::All).get_dylib_search_paths();\n                 new_path.extend(env::split_paths(&_old_path));\n                 env::set_var(\"PATH\", &env::join_paths(new_path.iter()).unwrap());\n@@ -737,7 +737,7 @@ pub fn phase_5_run_llvm_passes(sess: &Session,\n pub fn phase_6_link_output(sess: &Session,\n                            trans: &trans::CrateTranslation,\n                            outputs: &OutputFilenames) {\n-    let old_path = env::var(\"PATH\").unwrap_or(OsString::from_str(\"\"));\n+    let old_path = env::var_os(\"PATH\").unwrap_or(OsString::from_str(\"\"));\n     let mut new_path = sess.host_filesearch(PathKind::All).get_tools_search_paths();\n     new_path.extend(env::split_paths(&old_path));\n     env::set_var(\"PATH\", &env::join_paths(new_path.iter()).unwrap());"}, {"sha": "b087c0c2aa1c92e77e1db8ce3688b4debc985802", "filename": "src/librustc_driver/lib.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/3ef8ff1f81107b42840a695725e1a0869c163355/src%2Flibrustc_driver%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ef8ff1f81107b42840a695725e1a0869c163355/src%2Flibrustc_driver%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Flib.rs?ref=3ef8ff1f81107b42840a695725e1a0869c163355", "patch": "@@ -771,7 +771,7 @@ pub fn monitor<F:FnOnce()+Send>(f: F) {\n \n     // FIXME: Hacks on hacks. If the env is trying to override the stack size\n     // then *don't* set it explicitly.\n-    if env::var(\"RUST_MIN_STACK\").is_none() {\n+    if env::var_os(\"RUST_MIN_STACK\").is_none() {\n         cfg = cfg.stack_size(STACK_SIZE);\n     }\n \n@@ -835,8 +835,7 @@ pub fn diagnostics_registry() -> diagnostics::registry::Registry {\n }\n \n pub fn main() {\n-    let args = env::args().map(|s| s.into_string().unwrap());\n-    let result = run(args.collect());\n+    let result = run(env::args().collect());\n     std::env::set_exit_status(result as i32);\n }\n "}, {"sha": "dc1e91cd14bbd4e01bc642a77e54648d9eac609a", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/3ef8ff1f81107b42840a695725e1a0869c163355/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ef8ff1f81107b42840a695725e1a0869c163355/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=3ef8ff1f81107b42840a695725e1a0869c163355", "patch": "@@ -101,7 +101,7 @@ use std::cell::{Cell, RefCell};\n use std::fmt;\n use std::mem::replace;\n use std::rc::{Rc, Weak};\n-use std::uint;\n+use std::usize;\n \n // NB: This module needs to be declared first so diagnostics are\n // registered before they are used.\n@@ -4370,7 +4370,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n         for rib in this.value_ribs.iter().rev() {\n             for (&k, _) in &rib.bindings {\n                 maybes.push(token::get_name(k));\n-                values.push(uint::MAX);\n+                values.push(usize::MAX);\n             }\n         }\n \n@@ -4384,7 +4384,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n         }\n \n         if values.len() > 0 &&\n-            values[smallest] != uint::MAX &&\n+            values[smallest] != usize::MAX &&\n             values[smallest] < name.len() + 2 &&\n             values[smallest] <= max_distance &&\n             name != &maybes[smallest][] {"}, {"sha": "68f413eff85c691efbee33f8337d1f3d338a2bb7", "filename": "src/librustc_trans/back/write.rs", "status": "modified", "additions": 7, "deletions": 4, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/3ef8ff1f81107b42840a695725e1a0869c163355/src%2Flibrustc_trans%2Fback%2Fwrite.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ef8ff1f81107b42840a695725e1a0869c163355/src%2Flibrustc_trans%2Fback%2Fwrite.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fback%2Fwrite.rs?ref=3ef8ff1f81107b42840a695725e1a0869c163355", "patch": "@@ -658,14 +658,18 @@ pub fn run_passes(sess: &Session,\n     }\n \n     // Produce final compile outputs.\n+    let copy_gracefully = |from: &Path, to: &Path| {\n+        if let Err(e) = fs::copy(from, to) {\n+            sess.err(&format!(\"could not copy {:?} to {:?}: {}\", from, to, e));\n+        }\n+    };\n \n     let copy_if_one_unit = |ext: &str, output_type: config::OutputType, keep_numbered: bool| {\n         // Three cases:\n         if sess.opts.cg.codegen_units == 1 {\n             // 1) Only one codegen unit.  In this case it's no difficulty\n             //    to copy `foo.0.x` to `foo.x`.\n-            fs::copy(&crate_output.with_extension(ext),\n-                     &crate_output.path(output_type)).unwrap();\n+            copy_gracefully(&crate_output.with_extension(ext), &crate_output.path(output_type));\n             if !sess.opts.cg.save_temps && !keep_numbered {\n                 // The user just wants `foo.x`, not `foo.0.x`.\n                 remove(sess, &crate_output.with_extension(ext));\n@@ -687,8 +691,7 @@ pub fn run_passes(sess: &Session,\n     let link_obj = |output_path: &Path| {\n         // Running `ld -r` on a single input is kind of pointless.\n         if sess.opts.cg.codegen_units == 1 {\n-            fs::copy(&crate_output.with_extension(\"0.o\"),\n-                     output_path).unwrap();\n+            copy_gracefully(&crate_output.with_extension(\"0.o\"), output_path);\n             // Leave the .0.o file around, to mimic the behavior of the normal\n             // code path.\n             return;"}, {"sha": "cdcd917ee5eb408db88228e3e14ad9bc86428728", "filename": "src/librustc_trans/save/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3ef8ff1f81107b42840a695725e1a0869c163355/src%2Flibrustc_trans%2Fsave%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ef8ff1f81107b42840a695725e1a0869c163355/src%2Flibrustc_trans%2Fsave%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fsave%2Fmod.rs?ref=3ef8ff1f81107b42840a695725e1a0869c163355", "patch": "@@ -1551,7 +1551,7 @@ pub fn process_crate(sess: &Session,\n     info!(\"Dumping crate {}\", cratename);\n \n     // find a path to dump our data to\n-    let mut root_path = match env::var_string(\"DXR_RUST_TEMP_FOLDER\") {\n+    let mut root_path = match env::var(\"DXR_RUST_TEMP_FOLDER\") {\n         Ok(val) => Path::new(val),\n         Err(..) => match odir {\n             Some(val) => val.join(\"dxr\"),"}, {"sha": "5ad2dc2871c52b60ee3f4c611f6ae9d252cb75f1", "filename": "src/librustc_typeck/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/3ef8ff1f81107b42840a695725e1a0869c163355/src%2Flibrustc_typeck%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ef8ff1f81107b42840a695725e1a0869c163355/src%2Flibrustc_typeck%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Flib.rs?ref=3ef8ff1f81107b42840a695725e1a0869c163355", "patch": "@@ -79,6 +79,7 @@ This API is completely unstable and subject to change.\n #![feature(collections)]\n #![feature(core)]\n #![feature(int_uint)]\n+#![feature(std_misc)]\n #![feature(quote)]\n #![feature(rustc_diagnostic_macros)]\n #![feature(rustc_private)]"}, {"sha": "9d45caf76696a8b5e773fad863f798e02b337538", "filename": "src/librustdoc/lib.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/3ef8ff1f81107b42840a695725e1a0869c163355/src%2Flibrustdoc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ef8ff1f81107b42840a695725e1a0869c163355/src%2Flibrustdoc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Flib.rs?ref=3ef8ff1f81107b42840a695725e1a0869c163355", "patch": "@@ -122,10 +122,10 @@ struct Output {\n }\n \n pub fn main() {\n-    static STACK_SIZE: uint = 32000000; // 32MB\n+    const STACK_SIZE: usize = 32000000; // 32MB\n     let res = std::thread::Builder::new().stack_size(STACK_SIZE).scoped(move || {\n-        let s = env::args().map(|s| s.into_string().unwrap());\n-        main_args(&s.collect::<Vec<_>>())\n+        let s = env::args().collect::<Vec<_>>();\n+        main_args(&s)\n     }).join();\n     env::set_exit_status(res.ok().unwrap() as i32);\n }"}, {"sha": "abd73fcfb70289981213f7ef579fc4f657ab7268", "filename": "src/librustdoc/passes.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/3ef8ff1f81107b42840a695725e1a0869c163355/src%2Flibrustdoc%2Fpasses.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ef8ff1f81107b42840a695725e1a0869c163355/src%2Flibrustdoc%2Fpasses.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses.rs?ref=3ef8ff1f81107b42840a695725e1a0869c163355", "patch": "@@ -12,7 +12,7 @@ use std::collections::HashSet;\n use rustc::util::nodemap::NodeSet;\n use std::cmp;\n use std::string::String;\n-use std::uint;\n+use std::usize;\n use syntax::ast;\n use syntax::ast_util;\n \n@@ -310,7 +310,7 @@ pub fn unindent(s: &str) -> String {\n     let lines = s.lines_any().collect::<Vec<&str> >();\n     let mut saw_first_line = false;\n     let mut saw_second_line = false;\n-    let min_indent = lines.iter().fold(uint::MAX, |min_indent, line| {\n+    let min_indent = lines.iter().fold(usize::MAX, |min_indent, line| {\n \n         // After we see the first non-whitespace line, look at\n         // the line we have. If it is not whitespace, and therefore\n@@ -322,7 +322,7 @@ pub fn unindent(s: &str) -> String {\n             !line.chars().all(|c| c.is_whitespace());\n \n         let min_indent = if ignore_previous_indents {\n-            uint::MAX\n+            usize::MAX\n         } else {\n             min_indent\n         };"}, {"sha": "f81edca837198ade2545b56f86a1d8d1115d6b1d", "filename": "src/libserialize/collection_impls.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3ef8ff1f81107b42840a695725e1a0869c163355/src%2Flibserialize%2Fcollection_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ef8ff1f81107b42840a695725e1a0869c163355/src%2Flibserialize%2Fcollection_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibserialize%2Fcollection_impls.rs?ref=3ef8ff1f81107b42840a695725e1a0869c163355", "patch": "@@ -10,7 +10,7 @@\n \n //! Implementations of serialization for structures found in libcollections\n \n-use std::uint;\n+use std::usize;\n use std::default::Default;\n use std::hash::{Hash, Hasher};\n use std::collections::hash_state::HashState;\n@@ -148,7 +148,7 @@ impl<\n     fn decode<D: Decoder>(d: &mut D) -> Result<EnumSet<T>, D::Error> {\n         let bits = try!(d.read_uint());\n         let mut set = EnumSet::new();\n-        for bit in 0..uint::BITS {\n+        for bit in 0..usize::BITS {\n             if bits & (1 << bit) != 0 {\n                 set.insert(CLike::from_usize(1 << bit));\n             }"}, {"sha": "4579d1f19d3f0b3c1848aec9218023181d9d7e93", "filename": "src/libserialize/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/3ef8ff1f81107b42840a695725e1a0869c163355/src%2Flibserialize%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ef8ff1f81107b42840a695725e1a0869c163355/src%2Flibserialize%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibserialize%2Flib.rs?ref=3ef8ff1f81107b42840a695725e1a0869c163355", "patch": "@@ -31,6 +31,7 @@ Core encoding and decoding interfaces.\n #![feature(int_uint)]\n #![feature(io)]\n #![feature(path)]\n+#![feature(hash)]\n #![feature(rustc_private)]\n #![feature(slicing_syntax)]\n #![feature(staged_api)]"}, {"sha": "c5dd66630b4201d908aacf9159743dddd9f23a17", "filename": "src/libstd/dynamic_lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3ef8ff1f81107b42840a695725e1a0869c163355/src%2Flibstd%2Fdynamic_lib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ef8ff1f81107b42840a695725e1a0869c163355/src%2Flibstd%2Fdynamic_lib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fdynamic_lib.rs?ref=3ef8ff1f81107b42840a695725e1a0869c163355", "patch": "@@ -101,7 +101,7 @@ impl DynamicLibrary {\n     /// Returns the current search path for dynamic libraries being used by this\n     /// process\n     pub fn search_path() -> Vec<Path> {\n-        match env::var(DynamicLibrary::envvar()) {\n+        match env::var_os(DynamicLibrary::envvar()) {\n             Some(var) => env::split_paths(&var).collect(),\n             None => Vec::new(),\n         }"}, {"sha": "ea18838211f26b37b84f87ab94bc1695e57feda8", "filename": "src/libstd/env.rs", "status": "modified", "additions": 127, "deletions": 42, "changes": 169, "blob_url": "https://github.com/rust-lang/rust/blob/3ef8ff1f81107b42840a695725e1a0869c163355/src%2Flibstd%2Fenv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ef8ff1f81107b42840a695725e1a0869c163355/src%2Flibstd%2Fenv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fenv.rs?ref=3ef8ff1f81107b42840a695725e1a0869c163355", "patch": "@@ -71,17 +71,29 @@ static ENV_LOCK: StaticMutex = MUTEX_INIT;\n \n /// An iterator over a snapshot of the environment variables of this process.\n ///\n-/// This iterator is created through `std::env::vars()` and yields `(OsString,\n-/// OsString)` pairs.\n-pub struct Vars { inner: os_imp::Env }\n+/// This iterator is created through `std::env::vars()` and yields `(String,\n+/// String)` pairs.\n+pub struct Vars { inner: VarsOs }\n \n-/// Returns an iterator of (variable, value) pairs, for all the environment\n-/// variables of the current process.\n+/// An iterator over a snapshot of the environment variables of this process.\n+///\n+/// This iterator is created through `std::env::vars_os()` and yields\n+/// `(OsString, OsString)` pairs.\n+pub struct VarsOs { inner: os_imp::Env }\n+\n+/// Returns an iterator of (variable, value) pairs of strings, for all the\n+/// environment variables of the current process.\n ///\n /// The returned iterator contains a snapshot of the process's environment\n /// variables at the time of this invocation, modifications to environment\n /// variables afterwards will not be reflected in the returned iterator.\n ///\n+/// # Panics\n+///\n+/// While iterating, the returned iterator will panic if any key or value in the\n+/// environment is not valid unicode. If this is not desired, consider using the\n+/// `env::vars_os` function.\n+///\n /// # Example\n ///\n /// ```rust\n@@ -90,37 +102,50 @@ pub struct Vars { inner: os_imp::Env }\n /// // We will iterate through the references to the element returned by\n /// // env::vars();\n /// for (key, value) in env::vars() {\n-///     println!(\"{:?}: {:?}\", key, value);\n+///     println!(\"{}: {}\", key, value);\n /// }\n /// ```\n pub fn vars() -> Vars {\n-    let _g = ENV_LOCK.lock();\n-    Vars { inner: os_imp::env() }\n-}\n-\n-impl Iterator for Vars {\n-    type Item = (OsString, OsString);\n-    fn next(&mut self) -> Option<(OsString, OsString)> { self.inner.next() }\n-    fn size_hint(&self) -> (usize, Option<usize>) { self.inner.size_hint() }\n+    Vars { inner: vars_os() }\n }\n \n-/// Fetches the environment variable `key` from the current process, returning\n-/// None if the variable isn't set.\n+/// Returns an iterator of (variable, value) pairs of OS strings, for all the\n+/// environment variables of the current process.\n+///\n+/// The returned iterator contains a snapshot of the process's environment\n+/// variables at the time of this invocation, modifications to environment\n+/// variables afterwards will not be reflected in the returned iterator.\n ///\n /// # Example\n ///\n /// ```rust\n /// use std::env;\n ///\n-/// let key = \"HOME\";\n-/// match env::var(key) {\n-///     Some(val) => println!(\"{}: {:?}\", key, val),\n-///     None => println!(\"{} is not defined in the environment.\", key)\n+/// // We will iterate through the references to the element returned by\n+/// // env::vars_os();\n+/// for (key, value) in env::vars_os() {\n+///     println!(\"{:?}: {:?}\", key, value);\n /// }\n /// ```\n-pub fn var<K: ?Sized>(key: &K) -> Option<OsString> where K: AsOsStr {\n+pub fn vars_os() -> VarsOs {\n     let _g = ENV_LOCK.lock();\n-    os_imp::getenv(key.as_os_str())\n+    VarsOs { inner: os_imp::env() }\n+}\n+\n+impl Iterator for Vars {\n+    type Item = (String, String);\n+    fn next(&mut self) -> Option<(String, String)> {\n+        self.inner.next().map(|(a, b)| {\n+            (a.into_string().unwrap(), b.into_string().unwrap())\n+        })\n+    }\n+    fn size_hint(&self) -> (usize, Option<usize>) { self.inner.size_hint() }\n+}\n+\n+impl Iterator for VarsOs {\n+    type Item = (OsString, OsString);\n+    fn next(&mut self) -> Option<(OsString, OsString)> { self.inner.next() }\n+    fn size_hint(&self) -> (usize, Option<usize>) { self.inner.size_hint() }\n }\n \n /// Fetches the environment variable `key` from the current process.\n@@ -135,18 +160,37 @@ pub fn var<K: ?Sized>(key: &K) -> Option<OsString> where K: AsOsStr {\n /// use std::env;\n ///\n /// let key = \"HOME\";\n-/// match env::var_string(key) {\n+/// match env::var(key) {\n ///     Ok(val) => println!(\"{}: {:?}\", key, val),\n ///     Err(e) => println!(\"couldn't interpret {}: {}\", key, e),\n /// }\n /// ```\n-pub fn var_string<K: ?Sized>(key: &K) -> Result<String, VarError> where K: AsOsStr {\n-    match var(key) {\n+pub fn var<K: ?Sized>(key: &K) -> Result<String, VarError> where K: AsOsStr {\n+    match var_os(key) {\n         Some(s) => s.into_string().map_err(VarError::NotUnicode),\n         None => Err(VarError::NotPresent)\n     }\n }\n \n+/// Fetches the environment variable `key` from the current process, returning\n+/// None if the variable isn't set.\n+///\n+/// # Example\n+///\n+/// ```rust\n+/// use std::env;\n+///\n+/// let key = \"HOME\";\n+/// match env::var_os(key) {\n+///     Some(val) => println!(\"{}: {:?}\", key, val),\n+///     None => println!(\"{} is not defined in the environment.\", key)\n+/// }\n+/// ```\n+pub fn var_os<K: ?Sized>(key: &K) -> Option<OsString> where K: AsOsStr {\n+    let _g = ENV_LOCK.lock();\n+    os_imp::getenv(key.as_os_str())\n+}\n+\n /// Possible errors from the `env::var` method.\n #[derive(Debug, PartialEq, Eq, Clone)]\n pub enum VarError {\n@@ -190,7 +234,7 @@ impl Error for VarError {\n ///\n /// let key = \"KEY\";\n /// env::set_var(key, \"VALUE\");\n-/// assert_eq!(env::var_string(key), Ok(\"VALUE\".to_string()));\n+/// assert_eq!(env::var(key), Ok(\"VALUE\".to_string()));\n /// ```\n pub fn set_var<K: ?Sized, V: ?Sized>(k: &K, v: &V)\n     where K: AsOsStr, V: AsOsStr\n@@ -222,7 +266,7 @@ pub struct SplitPaths<'a> { inner: os_imp::SplitPaths<'a> }\n /// use std::env;\n ///\n /// let key = \"PATH\";\n-/// match env::var(key) {\n+/// match env::var_os(key) {\n ///     Some(paths) => {\n ///         for path in env::split_paths(&paths) {\n ///             println!(\"'{}'\", path.display());\n@@ -262,7 +306,7 @@ pub struct JoinPathsError {\n /// ```rust\n /// use std::env;\n ///\n-/// if let Some(path) = env::var(\"PATH\") {\n+/// if let Some(path) = env::var_os(\"PATH\") {\n ///     let mut paths = env::split_paths(&path).collect::<Vec<_>>();\n ///     paths.push(Path::new(\"/home/xyz/bin\"));\n ///     let new_path = env::join_paths(paths.iter()).unwrap();\n@@ -376,11 +420,17 @@ pub fn get_exit_status() -> i32 {\n     EXIT_STATUS.load(Ordering::SeqCst) as i32\n }\n \n-/// An iterator over the arguments of a process, yielding an `OsString` value\n+/// An iterator over the arguments of a process, yielding an `String` value\n /// for each argument.\n ///\n /// This structure is created through the `std::env::args` method.\n-pub struct Args { inner: os_imp::Args }\n+pub struct Args { inner: ArgsOs }\n+\n+/// An iterator over the arguments of a process, yielding an `OsString` value\n+/// for each argument.\n+///\n+/// This structure is created through the `std::env::args_os` method.\n+pub struct ArgsOs { inner: os_imp::Args }\n \n /// Returns the arguments which this program was started with (normally passed\n /// via the command line).\n@@ -389,21 +439,56 @@ pub struct Args { inner: os_imp::Args }\n /// set to arbitrary text, and it may not even exist, so this property should\n /// not be relied upon for security purposes.\n ///\n+/// # Panics\n+///\n+/// The returned iterator will panic during iteration if any argument to the\n+/// process is not valid unicode. If this is not desired it is recommended to\n+/// use the `args_os` function instead.\n+///\n /// # Example\n ///\n /// ```rust\n /// use std::env;\n ///\n /// // Prints each argument on a separate line\n /// for argument in env::args() {\n-///     println!(\"{:?}\", argument);\n+///     println!(\"{}\", argument);\n /// }\n /// ```\n pub fn args() -> Args {\n-    Args { inner: os_imp::args() }\n+    Args { inner: args_os() }\n+}\n+\n+/// Returns the arguments which this program was started with (normally passed\n+/// via the command line).\n+///\n+/// The first element is traditionally the path to the executable, but it can be\n+/// set to arbitrary text, and it may not even exist, so this property should\n+/// not be relied upon for security purposes.\n+///\n+/// # Example\n+///\n+/// ```rust\n+/// use std::env;\n+///\n+/// // Prints each argument on a separate line\n+/// for argument in env::args_os() {\n+///     println!(\"{:?}\", argument);\n+/// }\n+/// ```\n+pub fn args_os() -> ArgsOs {\n+    ArgsOs { inner: os_imp::args() }\n }\n \n impl Iterator for Args {\n+    type Item = String;\n+    fn next(&mut self) -> Option<String> {\n+        self.inner.next().map(|s| s.into_string().unwrap())\n+    }\n+    fn size_hint(&self) -> (usize, Option<usize>) { self.inner.size_hint() }\n+}\n+\n+impl Iterator for ArgsOs {\n     type Item = OsString;\n     fn next(&mut self) -> Option<OsString> { self.inner.next() }\n     fn size_hint(&self) -> (usize, Option<usize>) { self.inner.size_hint() }\n@@ -706,7 +791,7 @@ mod tests {\n         let n = format!(\"TEST{}\", rng.gen_ascii_chars().take(10)\n                                      .collect::<String>());\n         let n = OsString::from_string(n);\n-        assert!(var(&n).is_none());\n+        assert!(var_os(&n).is_none());\n         n\n     }\n \n@@ -718,25 +803,25 @@ mod tests {\n     fn test_set_var() {\n         let n = make_rand_name();\n         set_var(&n, \"VALUE\");\n-        eq(var(&n), Some(\"VALUE\"));\n+        eq(var_os(&n), Some(\"VALUE\"));\n     }\n \n     #[test]\n     fn test_remove_var() {\n         let n = make_rand_name();\n         set_var(&n, \"VALUE\");\n         remove_var(&n);\n-        eq(var(&n), None);\n+        eq(var_os(&n), None);\n     }\n \n     #[test]\n     fn test_set_var_overwrite() {\n         let n = make_rand_name();\n         set_var(&n, \"1\");\n         set_var(&n, \"2\");\n-        eq(var(&n), Some(\"2\"));\n+        eq(var_os(&n), Some(\"2\"));\n         set_var(&n, \"\");\n-        eq(var(&n), Some(\"\"));\n+        eq(var_os(&n), Some(\"\"));\n     }\n \n     #[test]\n@@ -749,7 +834,7 @@ mod tests {\n         }\n         let n = make_rand_name();\n         set_var(&n, s.as_slice());\n-        eq(var(&n), Some(s.as_slice()));\n+        eq(var_os(&n), Some(s.as_slice()));\n     }\n \n     #[test]\n@@ -767,22 +852,22 @@ mod tests {\n         let n = make_rand_name();\n         let s = repeat(\"x\").take(10000).collect::<String>();\n         set_var(&n, &s);\n-        eq(var(&n), Some(s.as_slice()));\n+        eq(var_os(&n), Some(s.as_slice()));\n         remove_var(&n);\n-        eq(var(&n), None);\n+        eq(var_os(&n), None);\n     }\n \n     #[test]\n     fn test_env_set_var() {\n         let n = make_rand_name();\n \n-        let mut e = vars();\n+        let mut e = vars_os();\n         set_var(&n, \"VALUE\");\n         assert!(!e.any(|(k, v)| {\n             &*k == &*n && &*v == \"VALUE\"\n         }));\n \n-        assert!(vars().any(|(k, v)| {\n+        assert!(vars_os().any(|(k, v)| {\n             &*k == &*n && &*v == \"VALUE\"\n         }));\n     }"}, {"sha": "83f0b7bc0e92bef74aca463f579f380e3eec417e", "filename": "src/libstd/lib.rs", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/3ef8ff1f81107b42840a695725e1a0869c163355/src%2Flibstd%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ef8ff1f81107b42840a695725e1a0869c163355/src%2Flibstd%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Flib.rs?ref=3ef8ff1f81107b42840a695725e1a0869c163355", "patch": "@@ -111,7 +111,7 @@\n #![feature(core)]\n #![feature(hash)]\n #![feature(int_uint)]\n-#![feature(lang_items, unsafe_destructor)]\n+#![feature(lang_items)]\n #![feature(libc)]\n #![feature(linkage, thread_local, asm)]\n #![feature(old_impl_check)]\n@@ -120,6 +120,8 @@\n #![feature(staged_api)]\n #![feature(unboxed_closures)]\n #![feature(unicode)]\n+#![feature(unsafe_destructor)]\n+#![feature(unsafe_no_drop_flag)]\n #![feature(macro_reexport)]\n #![cfg_attr(test, feature(test))]\n \n@@ -164,6 +166,7 @@ pub use core::cell;\n pub use core::clone;\n #[cfg(not(test))] pub use core::cmp;\n pub use core::default;\n+#[allow(deprecated)]\n pub use core::finally;\n pub use core::hash;\n pub use core::intrinsics;\n@@ -250,6 +253,7 @@ pub mod ffi;\n pub mod old_io;\n pub mod io;\n pub mod fs;\n+pub mod net;\n pub mod os;\n pub mod env;\n pub mod path;\n@@ -306,8 +310,8 @@ mod std {\n     pub use marker;  // used for tls!\n     pub use ops; // used for bitflags!\n \n-    // The test runner calls ::std::os::args() but really wants realstd\n-    #[cfg(test)] pub use realstd::os as os;\n+    // The test runner calls ::std::env::args() but really wants realstd\n+    #[cfg(test)] pub use realstd::env as env;\n     // The test runner requires std::slice::Vector, so re-export std::slice just for it.\n     //\n     // It is also used in vec![]"}, {"sha": "66d4d34f8eb54a56de61c0f7d14e6ec3ccd75f39", "filename": "src/libstd/net/addr.rs", "status": "added", "additions": 592, "deletions": 0, "changes": 592, "blob_url": "https://github.com/rust-lang/rust/blob/3ef8ff1f81107b42840a695725e1a0869c163355/src%2Flibstd%2Fnet%2Faddr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ef8ff1f81107b42840a695725e1a0869c163355/src%2Flibstd%2Fnet%2Faddr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnet%2Faddr.rs?ref=3ef8ff1f81107b42840a695725e1a0869c163355", "patch": "@@ -0,0 +1,592 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use prelude::v1::*;\n+\n+use fmt;\n+use hash;\n+use io;\n+use libc::{self, socklen_t, sa_family_t};\n+use mem;\n+use net::{IpAddr, lookup_host, ntoh, hton};\n+use option;\n+use sys_common::{FromInner, AsInner, IntoInner};\n+use vec;\n+\n+/// Representation of a socket address for networking applications\n+///\n+/// A socket address consists of at least an (ip, port) pair and may also\n+/// contain other information depending on the protocol.\n+#[derive(Copy, Clone, PartialEq, Eq, Hash)]\n+pub struct SocketAddr {\n+    repr: Repr,\n+}\n+\n+#[derive(Copy)]\n+enum Repr {\n+    V4(libc::sockaddr_in),\n+    V6(libc::sockaddr_in6),\n+}\n+\n+impl SocketAddr {\n+    /// Creates a new socket address from the (ip, port) pair.\n+    pub fn new(ip: IpAddr, port: u16) -> SocketAddr {\n+        let repr = match ip {\n+            IpAddr::V4(ref ip) => {\n+                Repr::V4(libc::sockaddr_in {\n+                    sin_family: libc::AF_INET as sa_family_t,\n+                    sin_port: hton(port),\n+                    sin_addr: *ip.as_inner(),\n+                    .. unsafe { mem::zeroed() }\n+                })\n+            }\n+            IpAddr::V6(ref ip) => {\n+                Repr::V6(libc::sockaddr_in6 {\n+                    sin6_family: libc::AF_INET6 as sa_family_t,\n+                    sin6_port: hton(port),\n+                    sin6_addr: *ip.as_inner(),\n+                    .. unsafe { mem::zeroed() }\n+                })\n+            }\n+        };\n+        SocketAddr { repr: repr }\n+    }\n+\n+    /// Gets the IP address associated with this socket address.\n+    pub fn ip(&self) -> IpAddr {\n+        match self.repr {\n+            Repr::V4(ref sa) => IpAddr::V4(FromInner::from_inner(sa.sin_addr)),\n+            Repr::V6(ref sa) => IpAddr::V6(FromInner::from_inner(sa.sin6_addr)),\n+        }\n+    }\n+\n+    /// Gets the port number associated with this socket address\n+    pub fn port(&self) -> u16 {\n+        match self.repr {\n+            Repr::V4(ref sa) => ntoh(sa.sin_port),\n+            Repr::V6(ref sa) => ntoh(sa.sin6_port),\n+        }\n+    }\n+\n+    fn set_port(&mut self, port: u16) {\n+        match self.repr {\n+            Repr::V4(ref mut sa) => sa.sin_port = hton(port),\n+            Repr::V6(ref mut sa) => sa.sin6_port = hton(port),\n+        }\n+    }\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl fmt::Display for SocketAddr {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        match self.repr {\n+            Repr::V4(_) => write!(f, \"{}:{}\", self.ip(), self.port()),\n+            Repr::V6(_) => write!(f, \"[{}]:{}\", self.ip(), self.port()),\n+        }\n+    }\n+}\n+\n+impl FromInner<libc::sockaddr_in> for SocketAddr {\n+    fn from_inner(addr: libc::sockaddr_in) -> SocketAddr {\n+        SocketAddr { repr: Repr::V4(addr) }\n+    }\n+}\n+\n+impl FromInner<libc::sockaddr_in6> for SocketAddr {\n+    fn from_inner(addr: libc::sockaddr_in6) -> SocketAddr {\n+        SocketAddr { repr: Repr::V6(addr) }\n+    }\n+}\n+\n+impl<'a> IntoInner<(*const libc::sockaddr, socklen_t)> for &'a SocketAddr {\n+    fn into_inner(self) -> (*const libc::sockaddr, socklen_t) {\n+        match self.repr {\n+            Repr::V4(ref a) => {\n+                (a as *const _ as *const _, mem::size_of_val(a) as socklen_t)\n+            }\n+            Repr::V6(ref a) => {\n+                (a as *const _ as *const _, mem::size_of_val(a) as socklen_t)\n+            }\n+        }\n+    }\n+}\n+\n+impl fmt::Debug for SocketAddr {\n+    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n+        fmt::Display::fmt(self, fmt)\n+    }\n+}\n+\n+impl Clone for Repr {\n+    fn clone(&self) -> Repr { *self }\n+}\n+\n+impl PartialEq for Repr {\n+    fn eq(&self, other: &Repr) -> bool {\n+        match (*self, *other) {\n+            (Repr::V4(ref a), Repr::V4(ref b)) => {\n+                a.sin_port == b.sin_port &&\n+                    a.sin_addr.s_addr == b.sin_addr.s_addr\n+            }\n+            (Repr::V6(ref a), Repr::V6(ref b)) => {\n+                a.sin6_port == b.sin6_port &&\n+                    a.sin6_addr.s6_addr == b.sin6_addr.s6_addr &&\n+                    a.sin6_flowinfo == b.sin6_flowinfo &&\n+                    a.sin6_scope_id == b.sin6_scope_id\n+            }\n+            _ => false,\n+        }\n+    }\n+}\n+impl Eq for Repr {}\n+\n+impl<S: hash::Hasher + hash::Writer> hash::Hash<S> for Repr {\n+    fn hash(&self, s: &mut S) {\n+        match *self {\n+            Repr::V4(ref a) => {\n+                (a.sin_family, a.sin_port, a.sin_addr.s_addr).hash(s)\n+            }\n+            Repr::V6(ref a) => {\n+                (a.sin6_family, a.sin6_port, &a.sin6_addr.s6_addr,\n+                 a.sin6_flowinfo, a.sin6_scope_id).hash(s)\n+            }\n+        }\n+    }\n+}\n+\n+/// A trait for objects which can be converted or resolved to one or more\n+/// `SocketAddr` values.\n+///\n+/// This trait is used for generic address resolution when constructing network\n+/// objects.  By default it is implemented for the following types:\n+///\n+///  * `SocketAddr` - `to_socket_addrs` is identity function.\n+///\n+///  * `(IpAddr, u16)` - `to_socket_addrs` constructs `SocketAddr` trivially.\n+///\n+///  * `(&str, u16)` - the string should be either a string representation of an\n+///    IP address expected by `FromStr` implementation for `IpAddr` or a host\n+///    name.\n+///\n+///  * `&str` - the string should be either a string representation of a\n+///    `SocketAddr` as expected by its `FromStr` implementation or a string like\n+///    `<host_name>:<port>` pair where `<port>` is a `u16` value.\n+///\n+/// This trait allows constructing network objects like `TcpStream` or\n+/// `UdpSocket` easily with values of various types for the bind/connection\n+/// address. It is needed because sometimes one type is more appropriate than\n+/// the other: for simple uses a string like `\"localhost:12345\"` is much nicer\n+/// than manual construction of the corresponding `SocketAddr`, but sometimes\n+/// `SocketAddr` value is *the* main source of the address, and converting it to\n+/// some other type (e.g. a string) just for it to be converted back to\n+/// `SocketAddr` in constructor methods is pointless.\n+///\n+/// Some examples:\n+///\n+/// ```no_run\n+/// use std::net::{IpAddr, SocketAddr, TcpStream, UdpSocket, TcpListener};\n+///\n+/// fn main() {\n+///     let ip = IpAddr::new_v4(127, 0, 0, 1);\n+///     let port = 12345;\n+///\n+///     // The following lines are equivalent modulo possible \"localhost\" name\n+///     // resolution differences\n+///     let tcp_s = TcpStream::connect(&SocketAddr::new(ip, port));\n+///     let tcp_s = TcpStream::connect(&(ip, port));\n+///     let tcp_s = TcpStream::connect(&(\"127.0.0.1\", port));\n+///     let tcp_s = TcpStream::connect(&(\"localhost\", port));\n+///     let tcp_s = TcpStream::connect(\"127.0.0.1:12345\");\n+///     let tcp_s = TcpStream::connect(\"localhost:12345\");\n+///\n+///     // TcpListener::bind(), UdpSocket::bind() and UdpSocket::send_to()\n+///     // behave similarly\n+///     let tcp_l = TcpListener::bind(\"localhost:12345\");\n+///\n+///     let mut udp_s = UdpSocket::bind(&(\"127.0.0.1\", port)).unwrap();\n+///     udp_s.send_to(&[7], &(ip, 23451));\n+/// }\n+/// ```\n+pub trait ToSocketAddrs {\n+    /// Returned iterator over socket addresses which this type may correspond\n+    /// to.\n+    type Iter: Iterator<Item=SocketAddr>;\n+\n+    /// Converts this object to an iterator of resolved `SocketAddr`s.\n+    ///\n+    /// The returned iterator may not actually yield any values depending on the\n+    /// outcome of any resolution performed.\n+    ///\n+    /// Note that this function may block the current thread while resolution is\n+    /// performed.\n+    ///\n+    /// # Errors\n+    ///\n+    /// Any errors encountered during resolution will be returned as an `Err`.\n+    fn to_socket_addrs(&self) -> io::Result<Self::Iter>;\n+}\n+\n+impl ToSocketAddrs for SocketAddr {\n+    type Iter = option::IntoIter<SocketAddr>;\n+    fn to_socket_addrs(&self) -> io::Result<option::IntoIter<SocketAddr>> {\n+        Ok(Some(*self).into_iter())\n+    }\n+}\n+\n+impl ToSocketAddrs for (IpAddr, u16) {\n+    type Iter = option::IntoIter<SocketAddr>;\n+    fn to_socket_addrs(&self) -> io::Result<option::IntoIter<SocketAddr>> {\n+        let (ip, port) = *self;\n+        Ok(Some(SocketAddr::new(ip, port)).into_iter())\n+    }\n+}\n+\n+fn resolve_socket_addr(s: &str, p: u16) -> io::Result<vec::IntoIter<SocketAddr>> {\n+    let ips = try!(lookup_host(s));\n+    let v: Vec<_> = try!(ips.map(|a| {\n+        a.map(|mut a| { a.set_port(p); a })\n+    }).collect());\n+    Ok(v.into_iter())\n+}\n+\n+impl<'a> ToSocketAddrs for (&'a str, u16) {\n+    type Iter = vec::IntoIter<SocketAddr>;\n+    fn to_socket_addrs(&self) -> io::Result<vec::IntoIter<SocketAddr>> {\n+        let (host, port) = *self;\n+\n+        // try to parse the host as a regular IpAddr first\n+        match host.parse().ok() {\n+            Some(addr) => return Ok(vec![SocketAddr::new(addr, port)].into_iter()),\n+            None => {}\n+        }\n+\n+        resolve_socket_addr(host, port)\n+    }\n+}\n+\n+// accepts strings like 'localhost:12345'\n+impl ToSocketAddrs for str {\n+    type Iter = vec::IntoIter<SocketAddr>;\n+    fn to_socket_addrs(&self) -> io::Result<vec::IntoIter<SocketAddr>> {\n+        // try to parse as a regular SocketAddr first\n+        match self.parse().ok() {\n+            Some(addr) => return Ok(vec![addr].into_iter()),\n+            None => {}\n+        }\n+\n+        macro_rules! try_opt {\n+            ($e:expr, $msg:expr) => (\n+                match $e {\n+                    Some(r) => r,\n+                    None => return Err(io::Error::new(io::ErrorKind::InvalidInput,\n+                                                      $msg, None)),\n+                }\n+            )\n+        }\n+\n+        // split the string by ':' and convert the second part to u16\n+        let mut parts_iter = self.rsplitn(2, ':');\n+        let port_str = try_opt!(parts_iter.next(), \"invalid socket address\");\n+        let host = try_opt!(parts_iter.next(), \"invalid socket address\");\n+        let port: u16 = try_opt!(port_str.parse().ok(), \"invalid port value\");\n+        resolve_socket_addr(host, port)\n+    }\n+}\n+\n+impl<'a, T: ToSocketAddrs + ?Sized> ToSocketAddrs for &'a T {\n+    type Iter = T::Iter;\n+    fn to_socket_addrs(&self) -> io::Result<T::Iter> {\n+        (**self).to_socket_addrs()\n+    }\n+}\n+\n+#[cfg(test)]\n+mod tests {\n+    use prelude::v1::*;\n+    use io;\n+    use net::*;\n+    use net::Ipv6MulticastScope::*;\n+\n+    #[test]\n+    fn test_from_str_ipv4() {\n+        assert_eq!(Ok(Ipv4Addr::new(127, 0, 0, 1)), \"127.0.0.1\".parse());\n+        assert_eq!(Ok(Ipv4Addr::new(255, 255, 255, 255)), \"255.255.255.255\".parse());\n+        assert_eq!(Ok(Ipv4Addr::new(0, 0, 0, 0)), \"0.0.0.0\".parse());\n+\n+        // out of range\n+        let none: Option<IpAddr> = \"256.0.0.1\".parse().ok();\n+        assert_eq!(None, none);\n+        // too short\n+        let none: Option<IpAddr> = \"255.0.0\".parse().ok();\n+        assert_eq!(None, none);\n+        // too long\n+        let none: Option<IpAddr> = \"255.0.0.1.2\".parse().ok();\n+        assert_eq!(None, none);\n+        // no number between dots\n+        let none: Option<IpAddr> = \"255.0..1\".parse().ok();\n+        assert_eq!(None, none);\n+    }\n+\n+    #[test]\n+    fn test_from_str_ipv6() {\n+        assert_eq!(Ok(Ipv6Addr::new(0, 0, 0, 0, 0, 0, 0, 0)), \"0:0:0:0:0:0:0:0\".parse());\n+        assert_eq!(Ok(Ipv6Addr::new(0, 0, 0, 0, 0, 0, 0, 1)), \"0:0:0:0:0:0:0:1\".parse());\n+\n+        assert_eq!(Ok(Ipv6Addr::new(0, 0, 0, 0, 0, 0, 0, 1)), \"::1\".parse());\n+        assert_eq!(Ok(Ipv6Addr::new(0, 0, 0, 0, 0, 0, 0, 0)), \"::\".parse());\n+\n+        assert_eq!(Ok(Ipv6Addr::new(0x2a02, 0x6b8, 0, 0, 0, 0, 0x11, 0x11)),\n+                \"2a02:6b8::11:11\".parse());\n+\n+        // too long group\n+        let none: Option<IpAddr> = \"::00000\".parse().ok();\n+        assert_eq!(None, none);\n+        // too short\n+        let none: Option<IpAddr> = \"1:2:3:4:5:6:7\".parse().ok();\n+        assert_eq!(None, none);\n+        // too long\n+        let none: Option<IpAddr> = \"1:2:3:4:5:6:7:8:9\".parse().ok();\n+        assert_eq!(None, none);\n+        // triple colon\n+        let none: Option<IpAddr> = \"1:2:::6:7:8\".parse().ok();\n+        assert_eq!(None, none);\n+        // two double colons\n+        let none: Option<IpAddr> = \"1:2::6::8\".parse().ok();\n+        assert_eq!(None, none);\n+    }\n+\n+    #[test]\n+    fn test_from_str_ipv4_in_ipv6() {\n+        assert_eq!(Ok(Ipv6Addr::new(0, 0, 0, 0, 0, 0, 49152, 545)),\n+                \"::192.0.2.33\".parse());\n+        assert_eq!(Ok(Ipv6Addr::new(0, 0, 0, 0, 0, 0xFFFF, 49152, 545)),\n+                \"::FFFF:192.0.2.33\".parse());\n+        assert_eq!(Ok(Ipv6Addr::new(0x64, 0xff9b, 0, 0, 0, 0, 49152, 545)),\n+                \"64:ff9b::192.0.2.33\".parse());\n+        assert_eq!(Ok(Ipv6Addr::new(0x2001, 0xdb8, 0x122, 0xc000, 0x2, 0x2100, 49152, 545)),\n+                \"2001:db8:122:c000:2:2100:192.0.2.33\".parse());\n+\n+        // colon after v4\n+        let none: Option<IpAddr> = \"::127.0.0.1:\".parse().ok();\n+        assert_eq!(None, none);\n+        // not enough groups\n+        let none: Option<IpAddr> = \"1.2.3.4.5:127.0.0.1\".parse().ok();\n+        assert_eq!(None, none);\n+        // too many groups\n+        let none: Option<IpAddr> = \"1.2.3.4.5:6:7:127.0.0.1\".parse().ok();\n+        assert_eq!(None, none);\n+    }\n+\n+    #[test]\n+    fn test_from_str_socket_addr() {\n+        assert_eq!(Ok(SocketAddr::new(IpAddr::new_v4(77, 88, 21, 11), 80)),\n+                \"77.88.21.11:80\".parse());\n+        assert_eq!(Ok(SocketAddr::new(IpAddr::new_v6(0x2a02, 0x6b8, 0, 1, 0, 0, 0, 1), 53)),\n+                \"[2a02:6b8:0:1::1]:53\".parse());\n+        assert_eq!(Ok(SocketAddr::new(IpAddr::new_v6(0, 0, 0, 0, 0, 0, 0x7F00, 1), 22)),\n+                \"[::127.0.0.1]:22\".parse());\n+\n+        // without port\n+        let none: Option<SocketAddr> = \"127.0.0.1\".parse().ok();\n+        assert_eq!(None, none);\n+        // without port\n+        let none: Option<SocketAddr> = \"127.0.0.1:\".parse().ok();\n+        assert_eq!(None, none);\n+        // wrong brackets around v4\n+        let none: Option<SocketAddr> = \"[127.0.0.1]:22\".parse().ok();\n+        assert_eq!(None, none);\n+        // port out of range\n+        let none: Option<SocketAddr> = \"127.0.0.1:123456\".parse().ok();\n+        assert_eq!(None, none);\n+    }\n+\n+    #[test]\n+    fn ipv6_addr_to_string() {\n+        // ipv4-mapped address\n+        let a1 = Ipv6Addr::new(0, 0, 0, 0, 0, 0xffff, 0xc000, 0x280);\n+        assert_eq!(a1.to_string(), \"::ffff:192.0.2.128\");\n+\n+        // ipv4-compatible address\n+        let a1 = Ipv6Addr::new(0, 0, 0, 0, 0, 0, 0xc000, 0x280);\n+        assert_eq!(a1.to_string(), \"::192.0.2.128\");\n+\n+        // v6 address with no zero segments\n+        assert_eq!(Ipv6Addr::new(8, 9, 10, 11, 12, 13, 14, 15).to_string(),\n+                   \"8:9:a:b:c:d:e:f\");\n+\n+        // reduce a single run of zeros\n+        assert_eq!(\"ae::ffff:102:304\",\n+                   Ipv6Addr::new(0xae, 0, 0, 0, 0, 0xffff, 0x0102, 0x0304).to_string());\n+\n+        // don't reduce just a single zero segment\n+        assert_eq!(\"1:2:3:4:5:6:0:8\",\n+                   Ipv6Addr::new(1, 2, 3, 4, 5, 6, 0, 8).to_string());\n+\n+        // 'any' address\n+        assert_eq!(\"::\", Ipv6Addr::new(0, 0, 0, 0, 0, 0, 0, 0).to_string());\n+\n+        // loopback address\n+        assert_eq!(\"::1\", Ipv6Addr::new(0, 0, 0, 0, 0, 0, 0, 1).to_string());\n+\n+        // ends in zeros\n+        assert_eq!(\"1::\", Ipv6Addr::new(1, 0, 0, 0, 0, 0, 0, 0).to_string());\n+\n+        // two runs of zeros, second one is longer\n+        assert_eq!(\"1:0:0:4::8\", Ipv6Addr::new(1, 0, 0, 4, 0, 0, 0, 8).to_string());\n+\n+        // two runs of zeros, equal length\n+        assert_eq!(\"1::4:5:0:0:8\", Ipv6Addr::new(1, 0, 0, 4, 5, 0, 0, 8).to_string());\n+    }\n+\n+    #[test]\n+    fn ipv4_to_ipv6() {\n+        assert_eq!(Ipv6Addr::new(0, 0, 0, 0, 0, 0xffff, 0x1234, 0x5678),\n+                   Ipv4Addr::new(0x12, 0x34, 0x56, 0x78).to_ipv6_mapped());\n+        assert_eq!(Ipv6Addr::new(0, 0, 0, 0, 0, 0, 0x1234, 0x5678),\n+                   Ipv4Addr::new(0x12, 0x34, 0x56, 0x78).to_ipv6_compatible());\n+    }\n+\n+    #[test]\n+    fn ipv6_to_ipv4() {\n+        assert_eq!(Ipv6Addr::new(0, 0, 0, 0, 0, 0xffff, 0x1234, 0x5678).to_ipv4(),\n+                   Some(Ipv4Addr::new(0x12, 0x34, 0x56, 0x78)));\n+        assert_eq!(Ipv6Addr::new(0, 0, 0, 0, 0, 0, 0x1234, 0x5678).to_ipv4(),\n+                   Some(Ipv4Addr::new(0x12, 0x34, 0x56, 0x78)));\n+        assert_eq!(Ipv6Addr::new(0, 0, 1, 0, 0, 0, 0x1234, 0x5678).to_ipv4(),\n+                   None);\n+    }\n+\n+    #[test]\n+    fn ipv4_properties() {\n+        fn check(octets: &[u8; 4], unspec: bool, loopback: bool,\n+                 private: bool, link_local: bool, global: bool,\n+                 multicast: bool) {\n+            let ip = Ipv4Addr::new(octets[0], octets[1], octets[2], octets[3]);\n+            assert_eq!(octets, &ip.octets());\n+\n+            assert_eq!(ip.is_unspecified(), unspec);\n+            assert_eq!(ip.is_loopback(), loopback);\n+            assert_eq!(ip.is_private(), private);\n+            assert_eq!(ip.is_link_local(), link_local);\n+            assert_eq!(ip.is_global(), global);\n+            assert_eq!(ip.is_multicast(), multicast);\n+        }\n+\n+        //    address                unspec loopbk privt  linloc global multicast\n+        check(&[0, 0, 0, 0],         true,  false, false, false, true,  false);\n+        check(&[0, 0, 0, 1],         false, false, false, false, true,  false);\n+        check(&[1, 0, 0, 0],         false, false, false, false, true,  false);\n+        check(&[10, 9, 8, 7],        false, false, true,  false, false, false);\n+        check(&[127, 1, 2, 3],       false, true,  false, false, false, false);\n+        check(&[172, 31, 254, 253],  false, false, true,  false, false,  false);\n+        check(&[169, 254, 253, 242], false, false, false, true,  false, false);\n+        check(&[192, 168, 254, 253], false, false, true,  false, false, false);\n+        check(&[224, 0, 0, 0],       false, false, false, false, true,  true);\n+        check(&[239, 255, 255, 255], false, false, false, false, true,  true);\n+        check(&[255, 255, 255, 255], false, false, false, false, true,  false);\n+    }\n+\n+    #[test]\n+    fn ipv6_properties() {\n+        fn check(str_addr: &str, unspec: bool, loopback: bool,\n+                 unique_local: bool, global: bool,\n+                 u_link_local: bool, u_site_local: bool, u_global: bool,\n+                 m_scope: Option<Ipv6MulticastScope>) {\n+            let ip: Ipv6Addr = str_addr.parse().ok().unwrap();\n+            assert_eq!(str_addr, ip.to_string());\n+\n+            assert_eq!(ip.is_unspecified(), unspec);\n+            assert_eq!(ip.is_loopback(), loopback);\n+            assert_eq!(ip.is_unique_local(), unique_local);\n+            assert_eq!(ip.is_global(), global);\n+            assert_eq!(ip.is_unicast_link_local(), u_link_local);\n+            assert_eq!(ip.is_unicast_site_local(), u_site_local);\n+            assert_eq!(ip.is_unicast_global(), u_global);\n+            assert_eq!(ip.multicast_scope(), m_scope);\n+            assert_eq!(ip.is_multicast(), m_scope.is_some());\n+        }\n+\n+        //    unspec loopbk uniqlo global unill  unisl  uniglo mscope\n+        check(\"::\",\n+              true,  false, false, true,  false, false, true,  None);\n+        check(\"::1\",\n+              false, true,  false, false, false, false, false, None);\n+        check(\"::0.0.0.2\",\n+              false, false, false, true,  false, false, true,  None);\n+        check(\"1::\",\n+              false, false, false, true,  false, false, true,  None);\n+        check(\"fc00::\",\n+              false, false, true,  false, false, false, false, None);\n+        check(\"fdff:ffff::\",\n+              false, false, true,  false, false, false, false, None);\n+        check(\"fe80:ffff::\",\n+              false, false, false, false, true,  false, false, None);\n+        check(\"febf:ffff::\",\n+              false, false, false, false, true,  false, false, None);\n+        check(\"fec0::\",\n+              false, false, false, false, false, true,  false, None);\n+        check(\"ff01::\",\n+              false, false, false, false, false, false, false, Some(InterfaceLocal));\n+        check(\"ff02::\",\n+              false, false, false, false, false, false, false, Some(LinkLocal));\n+        check(\"ff03::\",\n+              false, false, false, false, false, false, false, Some(RealmLocal));\n+        check(\"ff04::\",\n+              false, false, false, false, false, false, false, Some(AdminLocal));\n+        check(\"ff05::\",\n+              false, false, false, false, false, false, false, Some(SiteLocal));\n+        check(\"ff08::\",\n+              false, false, false, false, false, false, false, Some(OrganizationLocal));\n+        check(\"ff0e::\",\n+              false, false, false, true,  false, false, false, Some(Global));\n+    }\n+\n+    fn tsa<A: ToSocketAddrs>(a: A) -> io::Result<Vec<SocketAddr>> {\n+        Ok(try!(a.to_socket_addrs()).collect())\n+    }\n+\n+    #[test]\n+    fn to_socket_addr_socketaddr() {\n+        let a = SocketAddr::new(IpAddr::new_v4(77, 88, 21, 11), 12345);\n+        assert_eq!(Ok(vec![a]), tsa(a));\n+    }\n+\n+    #[test]\n+    fn to_socket_addr_ipaddr_u16() {\n+        let a = IpAddr::new_v4(77, 88, 21, 11);\n+        let p = 12345u16;\n+        let e = SocketAddr::new(a, p);\n+        assert_eq!(Ok(vec![e]), tsa((a, p)));\n+    }\n+\n+    #[test]\n+    fn to_socket_addr_str_u16() {\n+        let a = SocketAddr::new(IpAddr::new_v4(77, 88, 21, 11), 24352);\n+        assert_eq!(Ok(vec![a]), tsa((\"77.88.21.11\", 24352u16)));\n+\n+        let a = SocketAddr::new(IpAddr::new_v6(0x2a02, 0x6b8, 0, 1, 0, 0, 0, 1), 53);\n+        assert_eq!(Ok(vec![a]), tsa((\"2a02:6b8:0:1::1\", 53)));\n+\n+        let a = SocketAddr::new(IpAddr::new_v4(127, 0, 0, 1), 23924);\n+        assert!(tsa((\"localhost\", 23924u16)).unwrap().contains(&a));\n+    }\n+\n+    #[test]\n+    fn to_socket_addr_str() {\n+        let a = SocketAddr::new(IpAddr::new_v4(77, 88, 21, 11), 24352);\n+        assert_eq!(Ok(vec![a]), tsa(\"77.88.21.11:24352\"));\n+\n+        let a = SocketAddr::new(IpAddr::new_v6(0x2a02, 0x6b8, 0, 1, 0, 0, 0, 1), 53);\n+        assert_eq!(Ok(vec![a]), tsa(\"[2a02:6b8:0:1::1]:53\"));\n+\n+        let a = SocketAddr::new(IpAddr::new_v4(127, 0, 0, 1), 23924);\n+        assert!(tsa(\"localhost:23924\").unwrap().contains(&a));\n+    }\n+}"}, {"sha": "08f7a6e2e963663421229951fce8a63d80724db4", "filename": "src/libstd/net/ip.rs", "status": "added", "additions": 449, "deletions": 0, "changes": 449, "blob_url": "https://github.com/rust-lang/rust/blob/3ef8ff1f81107b42840a695725e1a0869c163355/src%2Flibstd%2Fnet%2Fip.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ef8ff1f81107b42840a695725e1a0869c163355/src%2Flibstd%2Fnet%2Fip.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnet%2Fip.rs?ref=3ef8ff1f81107b42840a695725e1a0869c163355", "patch": "@@ -0,0 +1,449 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use prelude::v1::*;\n+\n+use cmp::Ordering;\n+use hash;\n+use fmt;\n+use libc;\n+use sys_common::{AsInner, FromInner};\n+use net::{hton, ntoh};\n+\n+/// Representation of an IPv4 address.\n+#[derive(Copy)]\n+pub struct Ipv4Addr {\n+    inner: libc::in_addr,\n+}\n+\n+/// Representation of an IPv6 address.\n+#[derive(Copy)]\n+pub struct Ipv6Addr {\n+    inner: libc::in6_addr,\n+}\n+\n+#[allow(missing_docs)]\n+#[derive(Copy, PartialEq, Eq, Clone, Hash, Debug)]\n+pub enum Ipv6MulticastScope {\n+    InterfaceLocal,\n+    LinkLocal,\n+    RealmLocal,\n+    AdminLocal,\n+    SiteLocal,\n+    OrganizationLocal,\n+    Global\n+}\n+\n+/// Enumeration of possible IP addresses\n+#[derive(Copy, PartialEq, Eq, Clone, Hash, Debug)]\n+pub enum IpAddr {\n+    /// An IPv4 address.\n+    V4(Ipv4Addr),\n+    /// An IPv6 address.\n+    V6(Ipv6Addr)\n+}\n+\n+impl IpAddr {\n+    /// Create a new IpAddr that contains an IPv4 address.\n+    ///\n+    /// The result will represent the IP address a.b.c.d\n+    pub fn new_v4(a: u8, b: u8, c: u8, d: u8) -> IpAddr {\n+        IpAddr::V4(Ipv4Addr::new(a, b, c, d))\n+    }\n+\n+    /// Create a new IpAddr that contains an IPv6 address.\n+    ///\n+    /// The result will represent the IP address a:b:c:d:e:f\n+    pub fn new_v6(a: u16, b: u16, c: u16, d: u16, e: u16, f: u16, g: u16,\n+                  h: u16) -> IpAddr {\n+        IpAddr::V6(Ipv6Addr::new(a, b, c, d, e, f, g, h))\n+    }\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl fmt::Display for IpAddr {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        match *self {\n+            IpAddr::V4(v4) => v4.fmt(f),\n+            IpAddr::V6(v6) => v6.fmt(f)\n+        }\n+    }\n+}\n+\n+impl Ipv4Addr {\n+    /// Create a new IPv4 address from four eight-bit octets.\n+    ///\n+    /// The result will represent the IP address a.b.c.d\n+    pub fn new(a: u8, b: u8, c: u8, d: u8) -> Ipv4Addr {\n+        Ipv4Addr {\n+            inner: libc::in_addr {\n+                s_addr: hton(((a as u32) << 24) |\n+                             ((b as u32) << 16) |\n+                             ((c as u32) <<  8) |\n+                              (d as u32)),\n+            }\n+        }\n+    }\n+\n+    /// Returns the four eight-bit integers that make up this address\n+    pub fn octets(&self) -> [u8; 4] {\n+        let bits = ntoh(self.inner.s_addr);\n+        [(bits >> 24) as u8, (bits >> 16) as u8, (bits >> 8) as u8, bits as u8]\n+    }\n+\n+    /// Returns true for the special 'unspecified' address 0.0.0.0\n+    pub fn is_unspecified(&self) -> bool {\n+        self.inner.s_addr == 0\n+    }\n+\n+    /// Returns true if this is a loopback address (127.0.0.0/8)\n+    pub fn is_loopback(&self) -> bool {\n+        self.octets()[0] == 127\n+    }\n+\n+    /// Returns true if this is a private address.\n+    ///\n+    /// The private address ranges are defined in RFC1918 and include:\n+    ///\n+    ///  - 10.0.0.0/8\n+    ///  - 172.16.0.0/12\n+    ///  - 192.168.0.0/16\n+    pub fn is_private(&self) -> bool {\n+        match (self.octets()[0], self.octets()[1]) {\n+            (10, _) => true,\n+            (172, b) if b >= 16 && b <= 31 => true,\n+            (192, 168) => true,\n+            _ => false\n+        }\n+    }\n+\n+    /// Returns true if the address is link-local (169.254.0.0/16)\n+    pub fn is_link_local(&self) -> bool {\n+        self.octets()[0] == 169 && self.octets()[1] == 254\n+    }\n+\n+    /// Returns true if the address appears to be globally routable.\n+    ///\n+    /// Non-globally-routable networks include the private networks (10.0.0.0/8,\n+    /// 172.16.0.0/12 and 192.168.0.0/16), the loopback network (127.0.0.0/8),\n+    /// and the link-local network (169.254.0.0/16).\n+    pub fn is_global(&self) -> bool {\n+        !self.is_private() && !self.is_loopback() && !self.is_link_local()\n+    }\n+\n+    /// Returns true if this is a multicast address.\n+    ///\n+    /// Multicast addresses have a most significant octet between 224 and 239.\n+    pub fn is_multicast(&self) -> bool {\n+        self.octets()[0] >= 224 && self.octets()[0] <= 239\n+    }\n+\n+    /// Convert this address to an IPv4-compatible IPv6 address\n+    ///\n+    /// a.b.c.d becomes ::a.b.c.d\n+    pub fn to_ipv6_compatible(&self) -> Ipv6Addr {\n+        Ipv6Addr::new(0, 0, 0, 0, 0, 0,\n+                      ((self.octets()[0] as u16) << 8) | self.octets()[1] as u16,\n+                      ((self.octets()[2] as u16) << 8) | self.octets()[3] as u16)\n+    }\n+\n+    /// Convert this address to an IPv4-mapped IPv6 address\n+    ///\n+    /// a.b.c.d becomes ::ffff:a.b.c.d\n+    pub fn to_ipv6_mapped(&self) -> Ipv6Addr {\n+        Ipv6Addr::new(0, 0, 0, 0, 0, 0xffff,\n+                      ((self.octets()[0] as u16) << 8) | self.octets()[1] as u16,\n+                      ((self.octets()[2] as u16) << 8) | self.octets()[3] as u16)\n+    }\n+\n+}\n+\n+impl fmt::Display for Ipv4Addr {\n+    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n+        let octets = self.octets();\n+        write!(fmt, \"{}.{}.{}.{}\", octets[0], octets[1], octets[2], octets[3])\n+    }\n+}\n+\n+impl fmt::Debug for Ipv4Addr {\n+    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n+        fmt::Display::fmt(self, fmt)\n+    }\n+}\n+\n+impl Clone for Ipv4Addr {\n+    fn clone(&self) -> Ipv4Addr { *self }\n+}\n+\n+impl PartialEq for Ipv4Addr {\n+    fn eq(&self, other: &Ipv4Addr) -> bool {\n+        self.inner.s_addr == other.inner.s_addr\n+    }\n+}\n+impl Eq for Ipv4Addr {}\n+\n+impl<S: hash::Hasher + hash::Writer> hash::Hash<S> for Ipv4Addr {\n+    fn hash(&self, s: &mut S) {\n+        self.inner.s_addr.hash(s)\n+    }\n+}\n+\n+impl PartialOrd for Ipv4Addr {\n+    fn partial_cmp(&self, other: &Ipv4Addr) -> Option<Ordering> {\n+        Some(self.cmp(other))\n+    }\n+}\n+\n+impl Ord for Ipv4Addr {\n+    fn cmp(&self, other: &Ipv4Addr) -> Ordering {\n+        self.inner.s_addr.cmp(&other.inner.s_addr)\n+    }\n+}\n+\n+impl AsInner<libc::in_addr> for Ipv4Addr {\n+    fn as_inner(&self) -> &libc::in_addr { &self.inner }\n+}\n+impl FromInner<libc::in_addr> for Ipv4Addr {\n+    fn from_inner(addr: libc::in_addr) -> Ipv4Addr {\n+        Ipv4Addr { inner: addr }\n+    }\n+}\n+\n+impl Ipv6Addr {\n+    /// Create a new IPv6 address from eight 16-bit segments.\n+    ///\n+    /// The result will represent the IP address a:b:c:d:e:f\n+    pub fn new(a: u16, b: u16, c: u16, d: u16, e: u16, f: u16, g: u16,\n+               h: u16) -> Ipv6Addr {\n+        Ipv6Addr {\n+            inner: libc::in6_addr {\n+                s6_addr: [hton(a), hton(b), hton(c), hton(d),\n+                          hton(e), hton(f), hton(g), hton(h)]\n+            }\n+        }\n+    }\n+\n+    /// Return the eight 16-bit segments that make up this address\n+    pub fn segments(&self) -> [u16; 8] {\n+        [ntoh(self.inner.s6_addr[0]),\n+         ntoh(self.inner.s6_addr[1]),\n+         ntoh(self.inner.s6_addr[2]),\n+         ntoh(self.inner.s6_addr[3]),\n+         ntoh(self.inner.s6_addr[4]),\n+         ntoh(self.inner.s6_addr[5]),\n+         ntoh(self.inner.s6_addr[6]),\n+         ntoh(self.inner.s6_addr[7])]\n+    }\n+\n+    /// Returns true for the special 'unspecified' address ::\n+    pub fn is_unspecified(&self) -> bool {\n+        self.segments() == [0, 0, 0, 0, 0, 0, 0, 0]\n+    }\n+\n+    /// Returns true if this is a loopback address (::1)\n+    pub fn is_loopback(&self) -> bool {\n+        self.segments() == [0, 0, 0, 0, 0, 0, 0, 1]\n+    }\n+\n+    /// Returns true if the address appears to be globally routable.\n+    ///\n+    /// Non-globally-routable networks include the loopback address; the\n+    /// link-local, site-local, and unique local unicast addresses; and the\n+    /// interface-, link-, realm-, admin- and site-local multicast addresses.\n+    pub fn is_global(&self) -> bool {\n+        match self.multicast_scope() {\n+            Some(Ipv6MulticastScope::Global) => true,\n+            None => self.is_unicast_global(),\n+            _ => false\n+        }\n+    }\n+\n+    /// Returns true if this is a unique local address (IPv6)\n+    ///\n+    /// Unique local addresses are defined in RFC4193 and have the form fc00::/7\n+    pub fn is_unique_local(&self) -> bool {\n+        (self.segments()[0] & 0xfe00) == 0xfc00\n+    }\n+\n+    /// Returns true if the address is unicast and link-local (fe80::/10)\n+    pub fn is_unicast_link_local(&self) -> bool {\n+        (self.segments()[0] & 0xffc0) == 0xfe80\n+    }\n+\n+    /// Returns true if this is a deprecated unicast site-local address (IPv6\n+    /// fec0::/10)\n+    pub fn is_unicast_site_local(&self) -> bool {\n+        (self.segments()[0] & 0xffc0) == 0xfec0\n+    }\n+\n+    /// Returns true if the address is a globally routable unicast address\n+    ///\n+    /// Non-globally-routable unicast addresses include the loopback address,\n+    /// the link-local addresses, the deprecated site-local addresses and the\n+    /// unique local addresses.\n+    pub fn is_unicast_global(&self) -> bool {\n+        !self.is_multicast()\n+            && !self.is_loopback() && !self.is_unicast_link_local()\n+            && !self.is_unicast_site_local() && !self.is_unique_local()\n+    }\n+\n+    /// Returns the address's multicast scope if the address is multicast.\n+    pub fn multicast_scope(&self) -> Option<Ipv6MulticastScope> {\n+        if self.is_multicast() {\n+            match self.segments()[0] & 0x000f {\n+                1 => Some(Ipv6MulticastScope::InterfaceLocal),\n+                2 => Some(Ipv6MulticastScope::LinkLocal),\n+                3 => Some(Ipv6MulticastScope::RealmLocal),\n+                4 => Some(Ipv6MulticastScope::AdminLocal),\n+                5 => Some(Ipv6MulticastScope::SiteLocal),\n+                8 => Some(Ipv6MulticastScope::OrganizationLocal),\n+                14 => Some(Ipv6MulticastScope::Global),\n+                _ => None\n+            }\n+        } else {\n+            None\n+        }\n+    }\n+\n+    /// Returns true if this is a multicast address.\n+    ///\n+    /// Multicast addresses have the form ff00::/8.\n+    pub fn is_multicast(&self) -> bool {\n+        (self.segments()[0] & 0xff00) == 0xff00\n+    }\n+\n+    /// Convert this address to an IPv4 address. Returns None if this address is\n+    /// neither IPv4-compatible or IPv4-mapped.\n+    ///\n+    /// ::a.b.c.d and ::ffff:a.b.c.d become a.b.c.d\n+    pub fn to_ipv4(&self) -> Option<Ipv4Addr> {\n+        match self.segments() {\n+            [0, 0, 0, 0, 0, f, g, h] if f == 0 || f == 0xffff => {\n+                Some(Ipv4Addr::new((g >> 8) as u8, g as u8,\n+                                   (h >> 8) as u8, h as u8))\n+            },\n+            _ => None\n+        }\n+    }\n+}\n+\n+impl fmt::Display for Ipv6Addr {\n+    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n+        match self.segments() {\n+            // We need special cases for :: and ::1, otherwise they're formatted\n+            // as ::0.0.0.[01]\n+            [0, 0, 0, 0, 0, 0, 0, 0] => write!(fmt, \"::\"),\n+            [0, 0, 0, 0, 0, 0, 0, 1] => write!(fmt, \"::1\"),\n+            // Ipv4 Compatible address\n+            [0, 0, 0, 0, 0, 0, g, h] => {\n+                write!(fmt, \"::{}.{}.{}.{}\", (g >> 8) as u8, g as u8,\n+                       (h >> 8) as u8, h as u8)\n+            }\n+            // Ipv4-Mapped address\n+            [0, 0, 0, 0, 0, 0xffff, g, h] => {\n+                write!(fmt, \"::ffff:{}.{}.{}.{}\", (g >> 8) as u8, g as u8,\n+                       (h >> 8) as u8, h as u8)\n+            },\n+            _ => {\n+                fn find_zero_slice(segments: &[u16; 8]) -> (usize, usize) {\n+                    let mut longest_span_len = 0;\n+                    let mut longest_span_at = 0;\n+                    let mut cur_span_len = 0;\n+                    let mut cur_span_at = 0;\n+\n+                    for i in range(0, 8) {\n+                        if segments[i] == 0 {\n+                            if cur_span_len == 0 {\n+                                cur_span_at = i;\n+                            }\n+\n+                            cur_span_len += 1;\n+\n+                            if cur_span_len > longest_span_len {\n+                                longest_span_len = cur_span_len;\n+                                longest_span_at = cur_span_at;\n+                            }\n+                        } else {\n+                            cur_span_len = 0;\n+                            cur_span_at = 0;\n+                        }\n+                    }\n+\n+                    (longest_span_at, longest_span_len)\n+                }\n+\n+                let (zeros_at, zeros_len) = find_zero_slice(&self.segments());\n+\n+                if zeros_len > 1 {\n+                    fn fmt_subslice(segments: &[u16]) -> String {\n+                        segments\n+                            .iter()\n+                            .map(|&seg| format!(\"{:x}\", seg))\n+                            .collect::<Vec<String>>()\n+                            .as_slice()\n+                            .connect(\":\")\n+                    }\n+\n+                    write!(fmt, \"{}::{}\",\n+                           fmt_subslice(&self.segments()[..zeros_at]),\n+                           fmt_subslice(&self.segments()[zeros_at + zeros_len..]))\n+                } else {\n+                    let &[a, b, c, d, e, f, g, h] = &self.segments();\n+                    write!(fmt, \"{:x}:{:x}:{:x}:{:x}:{:x}:{:x}:{:x}:{:x}\",\n+                           a, b, c, d, e, f, g, h)\n+                }\n+            }\n+        }\n+    }\n+}\n+\n+impl fmt::Debug for Ipv6Addr {\n+    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n+        fmt::Display::fmt(self, fmt)\n+    }\n+}\n+\n+impl Clone for Ipv6Addr {\n+    fn clone(&self) -> Ipv6Addr { *self }\n+}\n+\n+impl PartialEq for Ipv6Addr {\n+    fn eq(&self, other: &Ipv6Addr) -> bool {\n+        self.inner.s6_addr == other.inner.s6_addr\n+    }\n+}\n+impl Eq for Ipv6Addr {}\n+\n+impl<S: hash::Hasher + hash::Writer> hash::Hash<S> for Ipv6Addr {\n+    fn hash(&self, s: &mut S) {\n+        self.inner.s6_addr.hash(s)\n+    }\n+}\n+\n+impl PartialOrd for Ipv6Addr {\n+    fn partial_cmp(&self, other: &Ipv6Addr) -> Option<Ordering> {\n+        Some(self.cmp(other))\n+    }\n+}\n+\n+impl Ord for Ipv6Addr {\n+    fn cmp(&self, other: &Ipv6Addr) -> Ordering {\n+        self.inner.s6_addr.cmp(&other.inner.s6_addr)\n+    }\n+}\n+\n+impl AsInner<libc::in6_addr> for Ipv6Addr {\n+    fn as_inner(&self) -> &libc::in6_addr { &self.inner }\n+}\n+impl FromInner<libc::in6_addr> for Ipv6Addr {\n+    fn from_inner(addr: libc::in6_addr) -> Ipv6Addr {\n+        Ipv6Addr { inner: addr }\n+    }\n+}"}, {"sha": "d73c06a2549e10970294d356aa07754ac8f73658", "filename": "src/libstd/net/mod.rs", "status": "added", "additions": 99, "deletions": 0, "changes": 99, "blob_url": "https://github.com/rust-lang/rust/blob/3ef8ff1f81107b42840a695725e1a0869c163355/src%2Flibstd%2Fnet%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ef8ff1f81107b42840a695725e1a0869c163355/src%2Flibstd%2Fnet%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnet%2Fmod.rs?ref=3ef8ff1f81107b42840a695725e1a0869c163355", "patch": "@@ -0,0 +1,99 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! Networking primitives for TCP/UDP communication\n+//!\n+//! > **NOTE**: This module is very much a work in progress and is under active\n+//! > development. At this time it is still recommended to use the `old_io`\n+//! > module while the details of this module shake out.\n+\n+#![unstable(feature = \"net\")]\n+\n+use prelude::v1::*;\n+\n+use io::{self, Error, ErrorKind};\n+use num::Int;\n+use sys_common::net2 as net_imp;\n+\n+pub use self::ip::{IpAddr, Ipv4Addr, Ipv6Addr, Ipv6MulticastScope};\n+pub use self::addr::{SocketAddr, ToSocketAddrs};\n+pub use self::tcp::{TcpStream, TcpListener};\n+pub use self::udp::UdpSocket;\n+\n+mod ip;\n+mod addr;\n+mod tcp;\n+mod udp;\n+mod parser;\n+#[cfg(test)] mod test;\n+\n+/// Possible values which can be passed to the `shutdown` method of `TcpStream`\n+/// and `UdpSocket`.\n+#[derive(Copy, Clone, PartialEq)]\n+pub enum Shutdown {\n+    /// Indicates that the reading portion of this stream/socket should be shut\n+    /// down. All currently blocked and future reads will return `Ok(0)`.\n+    Read,\n+    /// Indicates that the writing portion of this stream/socket should be shut\n+    /// down. All currently blocked and future writes will return an error.\n+    Write,\n+    /// Shut down both the reading and writing portions of this stream.\n+    ///\n+    /// See `Shutdown::Read` and `Shutdown::Write` for more information.\n+    Both\n+}\n+\n+fn hton<I: Int>(i: I) -> I { i.to_be() }\n+fn ntoh<I: Int>(i: I) -> I { Int::from_be(i) }\n+\n+fn each_addr<A: ToSocketAddrs + ?Sized, F, T>(addr: &A, mut f: F) -> io::Result<T>\n+    where F: FnMut(&SocketAddr) -> io::Result<T>\n+{\n+    let mut last_err = None;\n+    for addr in try!(addr.to_socket_addrs()) {\n+        match f(&addr) {\n+            Ok(l) => return Ok(l),\n+            Err(e) => last_err = Some(e),\n+        }\n+    }\n+    Err(last_err.unwrap_or_else(|| {\n+        Error::new(ErrorKind::InvalidInput,\n+                   \"could not resolve to any addresses\", None)\n+    }))\n+}\n+\n+/// An iterator over `SocketAddr` values returned from a host lookup operation.\n+pub struct LookupHost(net_imp::LookupHost);\n+\n+impl Iterator for LookupHost {\n+    type Item = io::Result<SocketAddr>;\n+    fn next(&mut self) -> Option<io::Result<SocketAddr>> { self.0.next() }\n+}\n+\n+/// Resolve the host specified by `host` as a number of `SocketAddr` instances.\n+///\n+/// This method may perform a DNS query to resolve `host` and may also inspect\n+/// system configuration to resolve the specified hostname.\n+///\n+/// # Example\n+///\n+/// ```no_run\n+/// use std::net;\n+///\n+/// # fn foo() -> std::io::Result<()> {\n+/// for host in try!(net::lookup_host(\"rust-lang.org\")) {\n+///     println!(\"found address: {}\", try!(host));\n+/// }\n+/// # Ok(())\n+/// # }\n+/// ```\n+pub fn lookup_host(host: &str) -> io::Result<LookupHost> {\n+    net_imp::lookup_host(host).map(LookupHost)\n+}"}, {"sha": "e82dc88cddd7b7036989232092f2e781f43a4617", "filename": "src/libstd/net/parser.rs", "status": "added", "additions": 330, "deletions": 0, "changes": 330, "blob_url": "https://github.com/rust-lang/rust/blob/3ef8ff1f81107b42840a695725e1a0869c163355/src%2Flibstd%2Fnet%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ef8ff1f81107b42840a695725e1a0869c163355/src%2Flibstd%2Fnet%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnet%2Fparser.rs?ref=3ef8ff1f81107b42840a695725e1a0869c163355", "patch": "@@ -0,0 +1,330 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! A private parser implementation of IPv4, IPv6, and socket addresses.\n+//!\n+//! This module is \"publicly exported\" through the `FromStr` implementations\n+//! below.\n+\n+use prelude::v1::*;\n+\n+use str::FromStr;\n+use net::{Ipv4Addr, Ipv6Addr, IpAddr, SocketAddr};\n+\n+struct Parser<'a> {\n+    // parsing as ASCII, so can use byte array\n+    s: &'a [u8],\n+    pos: usize,\n+}\n+\n+impl<'a> Parser<'a> {\n+    fn new(s: &'a str) -> Parser<'a> {\n+        Parser {\n+            s: s.as_bytes(),\n+            pos: 0,\n+        }\n+    }\n+\n+    fn is_eof(&self) -> bool {\n+        self.pos == self.s.len()\n+    }\n+\n+    // Commit only if parser returns Some\n+    fn read_atomically<T, F>(&mut self, cb: F) -> Option<T> where\n+        F: FnOnce(&mut Parser) -> Option<T>,\n+    {\n+        let pos = self.pos;\n+        let r = cb(self);\n+        if r.is_none() {\n+            self.pos = pos;\n+        }\n+        r\n+    }\n+\n+    // Commit only if parser read till EOF\n+    fn read_till_eof<T, F>(&mut self, cb: F) -> Option<T> where\n+        F: FnOnce(&mut Parser) -> Option<T>,\n+    {\n+        self.read_atomically(move |p| {\n+            match cb(p) {\n+                Some(x) => if p.is_eof() {Some(x)} else {None},\n+                None => None,\n+            }\n+        })\n+    }\n+\n+    // Return result of first successful parser\n+    fn read_or<T>(&mut self, parsers: &mut [Box<FnMut(&mut Parser) -> Option<T>>])\n+               -> Option<T> {\n+        for pf in parsers.iter_mut() {\n+            match self.read_atomically(|p: &mut Parser| pf(p)) {\n+                Some(r) => return Some(r),\n+                None => {}\n+            }\n+        }\n+        None\n+    }\n+\n+    // Apply 3 parsers sequentially\n+    fn read_seq_3<A, B, C, PA, PB, PC>(&mut self,\n+                                       pa: PA,\n+                                       pb: PB,\n+                                       pc: PC)\n+                                       -> Option<(A, B, C)> where\n+        PA: FnOnce(&mut Parser) -> Option<A>,\n+        PB: FnOnce(&mut Parser) -> Option<B>,\n+        PC: FnOnce(&mut Parser) -> Option<C>,\n+    {\n+        self.read_atomically(move |p| {\n+            let a = pa(p);\n+            let b = if a.is_some() { pb(p) } else { None };\n+            let c = if b.is_some() { pc(p) } else { None };\n+            match (a, b, c) {\n+                (Some(a), Some(b), Some(c)) => Some((a, b, c)),\n+                _ => None\n+            }\n+        })\n+    }\n+\n+    // Read next char\n+    fn read_char(&mut self) -> Option<char> {\n+        if self.is_eof() {\n+            None\n+        } else {\n+            let r = self.s[self.pos] as char;\n+            self.pos += 1;\n+            Some(r)\n+        }\n+    }\n+\n+    // Return char and advance iff next char is equal to requested\n+    fn read_given_char(&mut self, c: char) -> Option<char> {\n+        self.read_atomically(|p| {\n+            match p.read_char() {\n+                Some(next) if next == c => Some(next),\n+                _ => None,\n+            }\n+        })\n+    }\n+\n+    // Read digit\n+    fn read_digit(&mut self, radix: u8) -> Option<u8> {\n+        fn parse_digit(c: char, radix: u8) -> Option<u8> {\n+            let c = c as u8;\n+            // assuming radix is either 10 or 16\n+            if c >= b'0' && c <= b'9' {\n+                Some(c - b'0')\n+            } else if radix > 10 && c >= b'a' && c < b'a' + (radix - 10) {\n+                Some(c - b'a' + 10)\n+            } else if radix > 10 && c >= b'A' && c < b'A' + (radix - 10) {\n+                Some(c - b'A' + 10)\n+            } else {\n+                None\n+            }\n+        }\n+\n+        self.read_atomically(|p| {\n+            p.read_char().and_then(|c| parse_digit(c, radix))\n+        })\n+    }\n+\n+    fn read_number_impl(&mut self, radix: u8, max_digits: u32, upto: u32) -> Option<u32> {\n+        let mut r = 0u32;\n+        let mut digit_count = 0;\n+        loop {\n+            match self.read_digit(radix) {\n+                Some(d) => {\n+                    r = r * (radix as u32) + (d as u32);\n+                    digit_count += 1;\n+                    if digit_count > max_digits || r >= upto {\n+                        return None\n+                    }\n+                }\n+                None => {\n+                    if digit_count == 0 {\n+                        return None\n+                    } else {\n+                        return Some(r)\n+                    }\n+                }\n+            };\n+        }\n+    }\n+\n+    // Read number, failing if max_digits of number value exceeded\n+    fn read_number(&mut self, radix: u8, max_digits: u32, upto: u32) -> Option<u32> {\n+        self.read_atomically(|p| p.read_number_impl(radix, max_digits, upto))\n+    }\n+\n+    fn read_ipv4_addr_impl(&mut self) -> Option<Ipv4Addr> {\n+        let mut bs = [0u8; 4];\n+        let mut i = 0;\n+        while i < 4 {\n+            if i != 0 && self.read_given_char('.').is_none() {\n+                return None;\n+            }\n+\n+            let octet = self.read_number(10, 3, 0x100).map(|n| n as u8);\n+            match octet {\n+                Some(d) => bs[i] = d,\n+                None => return None,\n+            };\n+            i += 1;\n+        }\n+        Some(Ipv4Addr::new(bs[0], bs[1], bs[2], bs[3]))\n+    }\n+\n+    // Read IPv4 address\n+    fn read_ipv4_addr(&mut self) -> Option<Ipv4Addr> {\n+        self.read_atomically(|p| p.read_ipv4_addr_impl())\n+    }\n+\n+    fn read_ipv6_addr_impl(&mut self) -> Option<Ipv6Addr> {\n+        fn ipv6_addr_from_head_tail(head: &[u16], tail: &[u16]) -> Ipv6Addr {\n+            assert!(head.len() + tail.len() <= 8);\n+            let mut gs = [0u16; 8];\n+            gs.clone_from_slice(head);\n+            gs[(8 - tail.len()) .. 8].clone_from_slice(tail);\n+            Ipv6Addr::new(gs[0], gs[1], gs[2], gs[3], gs[4], gs[5], gs[6], gs[7])\n+        }\n+\n+        fn read_groups(p: &mut Parser, groups: &mut [u16; 8], limit: usize)\n+                       -> (usize, bool) {\n+            let mut i = 0;\n+            while i < limit {\n+                if i < limit - 1 {\n+                    let ipv4 = p.read_atomically(|p| {\n+                        if i == 0 || p.read_given_char(':').is_some() {\n+                            p.read_ipv4_addr()\n+                        } else {\n+                            None\n+                        }\n+                    });\n+                    if let Some(v4_addr) = ipv4 {\n+                        let octets = v4_addr.octets();\n+                        groups[i + 0] = ((octets[0] as u16) << 8) | (octets[1] as u16);\n+                        groups[i + 1] = ((octets[2] as u16) << 8) | (octets[3] as u16);\n+                        return (i + 2, true);\n+                    }\n+                }\n+\n+                let group = p.read_atomically(|p| {\n+                    if i == 0 || p.read_given_char(':').is_some() {\n+                        p.read_number(16, 4, 0x10000).map(|n| n as u16)\n+                    } else {\n+                        None\n+                    }\n+                });\n+                match group {\n+                    Some(g) => groups[i] = g,\n+                    None => return (i, false)\n+                }\n+                i += 1;\n+            }\n+            (i, false)\n+        }\n+\n+        let mut head = [0u16; 8];\n+        let (head_size, head_ipv4) = read_groups(self, &mut head, 8);\n+\n+        if head_size == 8 {\n+            return Some(Ipv6Addr::new(\n+                head[0], head[1], head[2], head[3],\n+                head[4], head[5], head[6], head[7]))\n+        }\n+\n+        // IPv4 part is not allowed before `::`\n+        if head_ipv4 {\n+            return None\n+        }\n+\n+        // read `::` if previous code parsed less than 8 groups\n+        if !self.read_given_char(':').is_some() || !self.read_given_char(':').is_some() {\n+            return None;\n+        }\n+\n+        let mut tail = [0u16; 8];\n+        let (tail_size, _) = read_groups(self, &mut tail, 8 - head_size);\n+        Some(ipv6_addr_from_head_tail(&head[..head_size], &tail[..tail_size]))\n+    }\n+\n+    fn read_ipv6_addr(&mut self) -> Option<Ipv6Addr> {\n+        self.read_atomically(|p| p.read_ipv6_addr_impl())\n+    }\n+\n+    fn read_ip_addr(&mut self) -> Option<IpAddr> {\n+        let ipv4_addr = |p: &mut Parser| p.read_ipv4_addr().map(|v4| IpAddr::V4(v4));\n+        let ipv6_addr = |p: &mut Parser| p.read_ipv6_addr().map(|v6| IpAddr::V6(v6));\n+        self.read_or(&mut [Box::new(ipv4_addr), Box::new(ipv6_addr)])\n+    }\n+\n+    fn read_socket_addr(&mut self) -> Option<SocketAddr> {\n+        let ip_addr = |p: &mut Parser| {\n+            let ipv4_p = |p: &mut Parser| p.read_ip_addr();\n+            let ipv6_p = |p: &mut Parser| {\n+                let open_br = |p: &mut Parser| p.read_given_char('[');\n+                let ip_addr = |p: &mut Parser| p.read_ipv6_addr();\n+                let clos_br = |p: &mut Parser| p.read_given_char(']');\n+                p.read_seq_3::<char, Ipv6Addr, char, _, _, _>(open_br, ip_addr, clos_br)\n+                        .map(|t| match t { (_, ip, _) => IpAddr::V6(ip) })\n+            };\n+            p.read_or(&mut [Box::new(ipv4_p), Box::new(ipv6_p)])\n+        };\n+        let colon = |p: &mut Parser| p.read_given_char(':');\n+        let port  = |p: &mut Parser| p.read_number(10, 5, 0x10000).map(|n| n as u16);\n+\n+        // host, colon, port\n+        self.read_seq_3::<IpAddr, char, u16, _, _, _>(ip_addr, colon, port)\n+                .map(|t| match t { (ip, _, port) => SocketAddr::new(ip, port) })\n+    }\n+}\n+\n+impl FromStr for IpAddr {\n+    type Err = ParseError;\n+    fn from_str(s: &str) -> Result<IpAddr, ParseError> {\n+        match Parser::new(s).read_till_eof(|p| p.read_ip_addr()) {\n+            Some(s) => Ok(s),\n+            None => Err(ParseError),\n+        }\n+    }\n+}\n+\n+impl FromStr for Ipv4Addr {\n+    type Err = ParseError;\n+    fn from_str(s: &str) -> Result<Ipv4Addr, ParseError> {\n+        match Parser::new(s).read_till_eof(|p| p.read_ipv4_addr()) {\n+            Some(s) => Ok(s),\n+            None => Err(ParseError)\n+        }\n+    }\n+}\n+\n+impl FromStr for Ipv6Addr {\n+    type Err = ParseError;\n+    fn from_str(s: &str) -> Result<Ipv6Addr, ParseError> {\n+        match Parser::new(s).read_till_eof(|p| p.read_ipv6_addr()) {\n+            Some(s) => Ok(s),\n+            None => Err(ParseError)\n+        }\n+    }\n+}\n+\n+impl FromStr for SocketAddr {\n+    type Err = ParseError;\n+    fn from_str(s: &str) -> Result<SocketAddr, ParseError> {\n+        match Parser::new(s).read_till_eof(|p| p.read_socket_addr()) {\n+            Some(s) => Ok(s),\n+            None => Err(ParseError),\n+        }\n+    }\n+}\n+\n+#[derive(Debug, Clone, PartialEq, Copy)]\n+pub struct ParseError;"}, {"sha": "50eafdfc5c2389677aa0cd6cb6c5dcf39fc4b98d", "filename": "src/libstd/net/tcp.rs", "status": "added", "additions": 792, "deletions": 0, "changes": 792, "blob_url": "https://github.com/rust-lang/rust/blob/3ef8ff1f81107b42840a695725e1a0869c163355/src%2Flibstd%2Fnet%2Ftcp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ef8ff1f81107b42840a695725e1a0869c163355/src%2Flibstd%2Fnet%2Ftcp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnet%2Ftcp.rs?ref=3ef8ff1f81107b42840a695725e1a0869c163355", "patch": "@@ -0,0 +1,792 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use prelude::v1::*;\n+use io::prelude::*;\n+\n+use io;\n+use net::{ToSocketAddrs, SocketAddr, Shutdown};\n+use sys_common::net2 as net_imp;\n+use sys_common::AsInner;\n+\n+/// A structure which represents a TCP stream between a local socket and a\n+/// remote socket.\n+///\n+/// The socket will be closed when the value is dropped.\n+///\n+/// # Example\n+///\n+/// ```no_run\n+/// use std::io::prelude::*;\n+/// use std::net::TcpStream;\n+///\n+/// {\n+///     let mut stream = TcpStream::connect(\"127.0.0.1:34254\").unwrap();\n+///\n+///     // ignore the Result\n+///     let _ = stream.write(&[1]);\n+///     let _ = stream.read(&mut [0; 128]); // ignore here too\n+/// } // the stream is closed here\n+/// ```\n+pub struct TcpStream(net_imp::TcpStream);\n+\n+/// A structure representing a socket server.\n+///\n+/// # Examples\n+///\n+/// ```no_run\n+/// use std::net::{TcpListener, TcpStream};\n+/// use std::thread::Thread;\n+///\n+/// let listener = TcpListener::bind(\"127.0.0.1:80\").unwrap();\n+///\n+/// fn handle_client(stream: TcpStream) {\n+///     // ...\n+/// }\n+///\n+/// // accept connections and process them, spawning a new thread for each one\n+/// for stream in listener.incoming() {\n+///     match stream {\n+///         Ok(stream) => {\n+///             Thread::spawn(move|| {\n+///                 // connection succeeded\n+///                 handle_client(stream)\n+///             });\n+///         }\n+///         Err(e) => { /* connection failed */ }\n+///     }\n+/// }\n+///\n+/// // close the socket server\n+/// drop(listener);\n+/// ```\n+pub struct TcpListener(net_imp::TcpListener);\n+\n+/// An infinite iterator over the connections from a `TcpListener`.\n+///\n+/// This iterator will infinitely yield `Some` of the accepted connections. It\n+/// is equivalent to calling `accept` in a loop.\n+pub struct Incoming<'a> { listener: &'a TcpListener }\n+\n+impl TcpStream {\n+    /// Open a TCP connection to a remote host.\n+    ///\n+    /// `addr` is an address of the remote host. Anything which implements\n+    /// `ToSocketAddrs` trait can be supplied for the address; see this trait\n+    /// documentation for concrete examples.\n+    pub fn connect<A: ToSocketAddrs + ?Sized>(addr: &A) -> io::Result<TcpStream> {\n+        super::each_addr(addr, net_imp::TcpStream::connect).map(TcpStream)\n+    }\n+\n+    /// Returns the socket address of the remote peer of this TCP connection.\n+    pub fn peer_addr(&self) -> io::Result<SocketAddr> {\n+        self.0.peer_addr()\n+    }\n+\n+    /// Returns the socket address of the local half of this TCP connection.\n+    pub fn socket_addr(&self) -> io::Result<SocketAddr> {\n+        self.0.socket_addr()\n+    }\n+\n+    /// Shut down the read, write, or both halves of this connection.\n+    ///\n+    /// This function will cause all pending and future I/O on the specified\n+    /// portions to return immediately with an appropriate value (see the\n+    /// documentation of `Shutdown`).\n+    pub fn shutdown(&self, how: Shutdown) -> io::Result<()> {\n+        self.0.shutdown(how)\n+    }\n+\n+    /// Create a new independently owned handle to the underlying socket.\n+    ///\n+    /// The returned `TcpStream` is a reference to the same stream that this\n+    /// object references. Both handles will read and write the same stream of\n+    /// data, and options set on one stream will be propagated to the other\n+    /// stream.\n+    pub fn try_clone(&self) -> io::Result<TcpStream> {\n+        self.0.duplicate().map(TcpStream)\n+    }\n+\n+    /// Sets the nodelay flag on this connection to the boolean specified\n+    pub fn set_nodelay(&self, nodelay: bool) -> io::Result<()> {\n+        self.0.set_nodelay(nodelay)\n+    }\n+\n+    /// Sets the keepalive timeout to the timeout specified.\n+    ///\n+    /// If the value specified is `None`, then the keepalive flag is cleared on\n+    /// this connection. Otherwise, the keepalive timeout will be set to the\n+    /// specified time, in seconds.\n+    pub fn set_keepalive(&self, seconds: Option<u32>) -> io::Result<()> {\n+        self.0.set_keepalive(seconds)\n+    }\n+}\n+\n+impl Read for TcpStream {\n+    fn read(&mut self, buf: &mut [u8]) -> io::Result<usize> { self.0.read(buf) }\n+}\n+impl Write for TcpStream {\n+    fn write(&mut self, buf: &[u8]) -> io::Result<usize> { self.0.write(buf) }\n+    fn flush(&mut self) -> io::Result<()> { Ok(()) }\n+}\n+impl<'a> Read for &'a TcpStream {\n+    fn read(&mut self, buf: &mut [u8]) -> io::Result<usize> { self.0.read(buf) }\n+}\n+impl<'a> Write for &'a TcpStream {\n+    fn write(&mut self, buf: &[u8]) -> io::Result<usize> { self.0.write(buf) }\n+    fn flush(&mut self) -> io::Result<()> { Ok(()) }\n+}\n+\n+impl AsInner<net_imp::TcpStream> for TcpStream {\n+    fn as_inner(&self) -> &net_imp::TcpStream { &self.0 }\n+}\n+\n+impl TcpListener {\n+    /// Creates a new `TcpListener` which will be bound to the specified\n+    /// address.\n+    ///\n+    /// The returned listener is ready for accepting connections.\n+    ///\n+    /// Binding with a port number of 0 will request that the OS assigns a port\n+    /// to this listener. The port allocated can be queried via the\n+    /// `socket_addr` function.\n+    ///\n+    /// The address type can be any implementer of `ToSocketAddrs` trait. See\n+    /// its documentation for concrete examples.\n+    pub fn bind<A: ToSocketAddrs + ?Sized>(addr: &A) -> io::Result<TcpListener> {\n+        super::each_addr(addr, net_imp::TcpListener::bind).map(TcpListener)\n+    }\n+\n+    /// Returns the local socket address of this listener.\n+    pub fn socket_addr(&self) -> io::Result<SocketAddr> {\n+        self.0.socket_addr()\n+    }\n+\n+    /// Create a new independently owned handle to the underlying socket.\n+    ///\n+    /// The returned `TcpListener` is a reference to the same socket that this\n+    /// object references. Both handles can be used to accept incoming\n+    /// connections and options set on one listener will affect the other.\n+    pub fn try_clone(&self) -> io::Result<TcpListener> {\n+        self.0.duplicate().map(TcpListener)\n+    }\n+\n+    /// Accept a new incoming connection from this listener.\n+    ///\n+    /// This function will block the calling thread until a new TCP connection\n+    /// is established. When established, the corresponding `TcpStream` and the\n+    /// remote peer's address will be returned.\n+    pub fn accept(&self) -> io::Result<(TcpStream, SocketAddr)> {\n+        self.0.accept().map(|(a, b)| (TcpStream(a), b))\n+    }\n+\n+    /// Returns an iterator over the connections being received on this\n+    /// listener.\n+    ///\n+    /// The returned iterator will never returned `None` and will also not yield\n+    /// the peer's `SocketAddr` structure.\n+    pub fn incoming(&self) -> Incoming {\n+        Incoming { listener: self }\n+    }\n+}\n+\n+impl<'a> Iterator for Incoming<'a> {\n+    type Item = io::Result<TcpStream>;\n+    fn next(&mut self) -> Option<io::Result<TcpStream>> {\n+        Some(self.listener.accept().map(|p| p.0))\n+    }\n+}\n+\n+impl AsInner<net_imp::TcpListener> for TcpListener {\n+    fn as_inner(&self) -> &net_imp::TcpListener { &self.0 }\n+}\n+\n+#[cfg(test)]\n+mod tests {\n+    use prelude::v1::*;\n+\n+    use io::ErrorKind;\n+    use io::prelude::*;\n+    use net::*;\n+    use net::test::{next_test_ip4, next_test_ip6};\n+    use sync::mpsc::channel;\n+    use thread::Thread;\n+\n+    fn each_ip(f: &mut FnMut(SocketAddr)) {\n+        f(next_test_ip4());\n+        f(next_test_ip6());\n+    }\n+\n+    macro_rules! t {\n+        ($e:expr) => {\n+            match $e {\n+                Ok(t) => t,\n+                Err(e) => panic!(\"received error for `{}`: {}\", stringify!($e), e),\n+            }\n+        }\n+    }\n+\n+    // FIXME #11530 this fails on android because tests are run as root\n+    #[cfg_attr(any(windows, target_os = \"android\"), ignore)]\n+    #[test]\n+    fn bind_error() {\n+        match TcpListener::bind(\"0.0.0.0:1\") {\n+            Ok(..) => panic!(),\n+            Err(e) => assert_eq!(e.kind(), ErrorKind::PermissionDenied),\n+        }\n+    }\n+\n+    #[test]\n+    fn connect_error() {\n+        match TcpStream::connect(\"0.0.0.0:1\") {\n+            Ok(..) => panic!(),\n+            Err(e) => assert_eq!(e.kind(), ErrorKind::ConnectionRefused),\n+        }\n+    }\n+\n+    #[test]\n+    fn listen_localhost() {\n+        let socket_addr = next_test_ip4();\n+        let listener = t!(TcpListener::bind(&socket_addr));\n+\n+        let _t = Thread::scoped(move || {\n+            let mut stream = t!(TcpStream::connect(&(\"localhost\",\n+                                                     socket_addr.port())));\n+            t!(stream.write(&[144]));\n+        });\n+\n+        let mut stream = t!(listener.accept()).0;\n+        let mut buf = [0];\n+        t!(stream.read(&mut buf));\n+        assert!(buf[0] == 144);\n+    }\n+\n+    #[test]\n+    fn connect_ip4_loopback() {\n+        let addr = next_test_ip4();\n+        let acceptor = t!(TcpListener::bind(&addr));\n+\n+        let _t = Thread::scoped(move|| {\n+            let mut stream = t!(TcpStream::connect(&(\"127.0.0.1\", addr.port())));\n+            t!(stream.write(&[44]));\n+        });\n+\n+        let mut stream = t!(acceptor.accept()).0;\n+        let mut buf = [0];\n+        t!(stream.read(&mut buf));\n+        assert!(buf[0] == 44);\n+    }\n+\n+    #[test]\n+    fn connect_ip6_loopback() {\n+        let addr = next_test_ip6();\n+        let acceptor = t!(TcpListener::bind(&addr));\n+\n+        let _t = Thread::scoped(move|| {\n+            let mut stream = t!(TcpStream::connect(&(\"::1\", addr.port())));\n+            t!(stream.write(&[66]));\n+        });\n+\n+        let mut stream = t!(acceptor.accept()).0;\n+        let mut buf = [0];\n+        t!(stream.read(&mut buf));\n+        assert!(buf[0] == 66);\n+    }\n+\n+    #[test]\n+    fn smoke_test_ip6() {\n+        each_ip(&mut |addr| {\n+            let acceptor = t!(TcpListener::bind(&addr));\n+\n+            let (tx, rx) = channel();\n+            let _t = Thread::scoped(move|| {\n+                let mut stream = t!(TcpStream::connect(&addr));\n+                t!(stream.write(&[99]));\n+                tx.send(t!(stream.socket_addr())).unwrap();\n+            });\n+\n+            let (mut stream, addr) = t!(acceptor.accept());\n+            let mut buf = [0];\n+            t!(stream.read(&mut buf));\n+            assert!(buf[0] == 99);\n+            assert_eq!(addr, t!(rx.recv()));\n+        })\n+    }\n+\n+    #[test]\n+    fn read_eof_ip4() {\n+        each_ip(&mut |addr| {\n+            let acceptor = t!(TcpListener::bind(&addr));\n+\n+            let _t = Thread::scoped(move|| {\n+                let _stream = t!(TcpStream::connect(&addr));\n+                // Close\n+            });\n+\n+            let mut stream = t!(acceptor.accept()).0;\n+            let mut buf = [0];\n+            let nread = t!(stream.read(&mut buf));\n+            assert_eq!(nread, 0);\n+            let nread = t!(stream.read(&mut buf));\n+            assert_eq!(nread, 0);\n+        })\n+    }\n+\n+    #[test]\n+    fn write_close() {\n+        each_ip(&mut |addr| {\n+            let acceptor = t!(TcpListener::bind(&addr));\n+\n+            let (tx, rx) = channel();\n+            let _t = Thread::scoped(move|| {\n+                drop(t!(TcpStream::connect(&addr)));\n+                tx.send(()).unwrap();\n+            });\n+\n+            let mut stream = t!(acceptor.accept()).0;\n+            rx.recv().unwrap();\n+            let buf = [0];\n+            match stream.write(&buf) {\n+                Ok(..) => {}\n+                Err(e) => {\n+                    assert!(e.kind() == ErrorKind::ConnectionReset ||\n+                            e.kind() == ErrorKind::BrokenPipe ||\n+                            e.kind() == ErrorKind::ConnectionAborted,\n+                            \"unknown error: {}\", e);\n+                }\n+            }\n+        })\n+    }\n+\n+    #[test]\n+    fn multiple_connect_serial_ip4() {\n+        each_ip(&mut |addr| {\n+            let max = 10;\n+            let acceptor = t!(TcpListener::bind(&addr));\n+\n+            let _t = Thread::scoped(move|| {\n+                for _ in 0..max {\n+                    let mut stream = t!(TcpStream::connect(&addr));\n+                    t!(stream.write(&[99]));\n+                }\n+            });\n+\n+            for stream in acceptor.incoming().take(max) {\n+                let mut stream = t!(stream);\n+                let mut buf = [0];\n+                t!(stream.read(&mut buf));\n+                assert_eq!(buf[0], 99);\n+            }\n+        })\n+    }\n+\n+    #[test]\n+    fn multiple_connect_interleaved_greedy_schedule() {\n+        static MAX: usize = 10;\n+        each_ip(&mut |addr| {\n+            let acceptor = t!(TcpListener::bind(&addr));\n+\n+            let _t = Thread::scoped(move|| {\n+                let acceptor = acceptor;\n+                for (i, stream) in acceptor.incoming().enumerate().take(MAX) {\n+                    // Start another task to handle the connection\n+                    let _t = Thread::scoped(move|| {\n+                        let mut stream = t!(stream);\n+                        let mut buf = [0];\n+                        t!(stream.read(&mut buf));\n+                        assert!(buf[0] == i as u8);\n+                    });\n+                }\n+            });\n+\n+            connect(0, addr);\n+        });\n+\n+        fn connect(i: usize, addr: SocketAddr) {\n+            if i == MAX { return }\n+\n+            let t = Thread::scoped(move|| {\n+                let mut stream = t!(TcpStream::connect(&addr));\n+                // Connect again before writing\n+                connect(i + 1, addr);\n+                t!(stream.write(&[i as u8]));\n+            });\n+            t.join().ok().unwrap();\n+        }\n+    }\n+\n+    #[test]\n+    fn multiple_connect_interleaved_lazy_schedule_ip4() {\n+        static MAX: usize = 10;\n+        each_ip(&mut |addr| {\n+            let acceptor = t!(TcpListener::bind(&addr));\n+\n+            let _t = Thread::scoped(move|| {\n+                for stream in acceptor.incoming().take(MAX) {\n+                    // Start another task to handle the connection\n+                    let _t = Thread::scoped(move|| {\n+                        let mut stream = t!(stream);\n+                        let mut buf = [0];\n+                        t!(stream.read(&mut buf));\n+                        assert!(buf[0] == 99);\n+                    });\n+                }\n+            });\n+\n+            connect(0, addr);\n+        });\n+\n+        fn connect(i: usize, addr: SocketAddr) {\n+            if i == MAX { return }\n+\n+            let t = Thread::scoped(move|| {\n+                let mut stream = t!(TcpStream::connect(&addr));\n+                connect(i + 1, addr);\n+                t!(stream.write(&[99]));\n+            });\n+            t.join().ok().unwrap();\n+        }\n+    }\n+\n+    pub fn socket_name(addr: SocketAddr) {\n+    }\n+\n+    pub fn peer_name(addr: SocketAddr) {\n+    }\n+\n+    #[test]\n+    fn socket_and_peer_name_ip4() {\n+        each_ip(&mut |addr| {\n+            let listener = t!(TcpListener::bind(&addr));\n+            let so_name = t!(listener.socket_addr());\n+            assert_eq!(addr, so_name);\n+            let _t = Thread::scoped(move|| {\n+                t!(listener.accept());\n+            });\n+\n+            let stream = t!(TcpStream::connect(&addr));\n+            assert_eq!(addr, t!(stream.peer_addr()));\n+        })\n+    }\n+\n+    #[test]\n+    fn partial_read() {\n+        each_ip(&mut |addr| {\n+            let (tx, rx) = channel();\n+            let srv = t!(TcpListener::bind(&addr));\n+            let _t = Thread::scoped(move|| {\n+                let mut cl = t!(srv.accept()).0;\n+                cl.write(&[10]).unwrap();\n+                let mut b = [0];\n+                t!(cl.read(&mut b));\n+                tx.send(()).unwrap();\n+            });\n+\n+            let mut c = t!(TcpStream::connect(&addr));\n+            let mut b = [0; 10];\n+            assert_eq!(c.read(&mut b), Ok(1));\n+            t!(c.write(&[1]));\n+            rx.recv().unwrap();\n+        })\n+    }\n+\n+    #[test]\n+    fn double_bind() {\n+        each_ip(&mut |addr| {\n+            let _listener = t!(TcpListener::bind(&addr));\n+            match TcpListener::bind(&addr) {\n+                Ok(..) => panic!(),\n+                Err(e) => {\n+                    assert!(e.kind() == ErrorKind::ConnectionRefused ||\n+                            e.kind() == ErrorKind::Other,\n+                            \"unknown error: {} {:?}\", e, e.kind());\n+                }\n+            }\n+        })\n+    }\n+\n+    #[test]\n+    fn fast_rebind() {\n+        each_ip(&mut |addr| {\n+            let acceptor = t!(TcpListener::bind(&addr));\n+\n+            let _t = Thread::scoped(move|| {\n+                t!(TcpStream::connect(&addr));\n+            });\n+\n+            t!(acceptor.accept());\n+            drop(acceptor);\n+            t!(TcpListener::bind(&addr));\n+        });\n+    }\n+\n+    #[test]\n+    fn tcp_clone_smoke() {\n+        each_ip(&mut |addr| {\n+            let acceptor = t!(TcpListener::bind(&addr));\n+\n+            let _t = Thread::scoped(move|| {\n+                let mut s = t!(TcpStream::connect(&addr));\n+                let mut buf = [0, 0];\n+                assert_eq!(s.read(&mut buf), Ok(1));\n+                assert_eq!(buf[0], 1);\n+                t!(s.write(&[2]));\n+            });\n+\n+            let mut s1 = t!(acceptor.accept()).0;\n+            let s2 = t!(s1.try_clone());\n+\n+            let (tx1, rx1) = channel();\n+            let (tx2, rx2) = channel();\n+            let _t = Thread::scoped(move|| {\n+                let mut s2 = s2;\n+                rx1.recv().unwrap();\n+                t!(s2.write(&[1]));\n+                tx2.send(()).unwrap();\n+            });\n+            tx1.send(()).unwrap();\n+            let mut buf = [0, 0];\n+            assert_eq!(s1.read(&mut buf), Ok(1));\n+            rx2.recv().unwrap();\n+        })\n+    }\n+\n+    #[test]\n+    fn tcp_clone_two_read() {\n+        each_ip(&mut |addr| {\n+            let acceptor = t!(TcpListener::bind(&addr));\n+            let (tx1, rx) = channel();\n+            let tx2 = tx1.clone();\n+\n+            let _t = Thread::scoped(move|| {\n+                let mut s = t!(TcpStream::connect(&addr));\n+                t!(s.write(&[1]));\n+                rx.recv().unwrap();\n+                t!(s.write(&[2]));\n+                rx.recv().unwrap();\n+            });\n+\n+            let mut s1 = t!(acceptor.accept()).0;\n+            let s2 = t!(s1.try_clone());\n+\n+            let (done, rx) = channel();\n+            let _t = Thread::scoped(move|| {\n+                let mut s2 = s2;\n+                let mut buf = [0, 0];\n+                t!(s2.read(&mut buf));\n+                tx2.send(()).unwrap();\n+                done.send(()).unwrap();\n+            });\n+            let mut buf = [0, 0];\n+            t!(s1.read(&mut buf));\n+            tx1.send(()).unwrap();\n+\n+            rx.recv().unwrap();\n+        })\n+    }\n+\n+    #[test]\n+    fn tcp_clone_two_write() {\n+        each_ip(&mut |addr| {\n+            let acceptor = t!(TcpListener::bind(&addr));\n+\n+            let _t = Thread::scoped(move|| {\n+                let mut s = t!(TcpStream::connect(&addr));\n+                let mut buf = [0, 1];\n+                t!(s.read(&mut buf));\n+                t!(s.read(&mut buf));\n+            });\n+\n+            let mut s1 = t!(acceptor.accept()).0;\n+            let s2 = t!(s1.try_clone());\n+\n+            let (done, rx) = channel();\n+            let _t = Thread::scoped(move|| {\n+                let mut s2 = s2;\n+                t!(s2.write(&[1]));\n+                done.send(()).unwrap();\n+            });\n+            t!(s1.write(&[2]));\n+\n+            rx.recv().unwrap();\n+        })\n+    }\n+\n+    #[test]\n+    fn shutdown_smoke() {\n+        each_ip(&mut |addr| {\n+            let a = t!(TcpListener::bind(&addr));\n+            let _t = Thread::scoped(move|| {\n+                let mut c = t!(a.accept()).0;\n+                let mut b = [0];\n+                assert_eq!(c.read(&mut b), Ok(0));\n+                t!(c.write(&[1]));\n+            });\n+\n+            let mut s = t!(TcpStream::connect(&addr));\n+            t!(s.shutdown(Shutdown::Write));\n+            assert!(s.write(&[1]).is_err());\n+            let mut b = [0, 0];\n+            assert_eq!(t!(s.read(&mut b)), 1);\n+            assert_eq!(b[0], 1);\n+        })\n+    }\n+\n+    #[test]\n+    fn close_readwrite_smoke() {\n+        each_ip(&mut |addr| {\n+            let a = t!(TcpListener::bind(&addr));\n+            let (tx, rx) = channel::<()>();\n+            let _t = Thread::scoped(move|| {\n+                let _s = t!(a.accept());\n+                let _ = rx.recv();\n+            });\n+\n+            let mut b = [0];\n+            let mut s = t!(TcpStream::connect(&addr));\n+            let mut s2 = t!(s.try_clone());\n+\n+            // closing should prevent reads/writes\n+            t!(s.shutdown(Shutdown::Write));\n+            assert!(s.write(&[0]).is_err());\n+            t!(s.shutdown(Shutdown::Read));\n+            assert_eq!(s.read(&mut b), Ok(0));\n+\n+            // closing should affect previous handles\n+            assert!(s2.write(&[0]).is_err());\n+            assert_eq!(s2.read(&mut b), Ok(0));\n+\n+            // closing should affect new handles\n+            let mut s3 = t!(s.try_clone());\n+            assert!(s3.write(&[0]).is_err());\n+            assert_eq!(s3.read(&mut b), Ok(0));\n+\n+            // make sure these don't die\n+            let _ = s2.shutdown(Shutdown::Read);\n+            let _ = s2.shutdown(Shutdown::Write);\n+            let _ = s3.shutdown(Shutdown::Read);\n+            let _ = s3.shutdown(Shutdown::Write);\n+            drop(tx);\n+        })\n+    }\n+\n+    #[test]\n+    fn close_read_wakes_up() {\n+        each_ip(&mut |addr| {\n+            let a = t!(TcpListener::bind(&addr));\n+            let (tx1, rx) = channel::<()>();\n+            let _t = Thread::scoped(move|| {\n+                let _s = t!(a.accept());\n+                let _ = rx.recv();\n+            });\n+\n+            let s = t!(TcpStream::connect(&addr));\n+            let s2 = t!(s.try_clone());\n+            let (tx, rx) = channel();\n+            let _t = Thread::scoped(move|| {\n+                let mut s2 = s2;\n+                assert_eq!(t!(s2.read(&mut [0])), 0);\n+                tx.send(()).unwrap();\n+            });\n+            // this should wake up the child task\n+            t!(s.shutdown(Shutdown::Read));\n+\n+            // this test will never finish if the child doesn't wake up\n+            rx.recv().unwrap();\n+            drop(tx1);\n+        })\n+    }\n+\n+    #[test]\n+    fn clone_while_reading() {\n+        each_ip(&mut |addr| {\n+            let accept = t!(TcpListener::bind(&addr));\n+\n+            // Enqueue a task to write to a socket\n+            let (tx, rx) = channel();\n+            let (txdone, rxdone) = channel();\n+            let txdone2 = txdone.clone();\n+            let _t = Thread::scoped(move|| {\n+                let mut tcp = t!(TcpStream::connect(&addr));\n+                rx.recv().unwrap();\n+                t!(tcp.write(&[0]));\n+                txdone2.send(()).unwrap();\n+            });\n+\n+            // Spawn off a reading clone\n+            let tcp = t!(accept.accept()).0;\n+            let tcp2 = t!(tcp.try_clone());\n+            let txdone3 = txdone.clone();\n+            let _t = Thread::scoped(move|| {\n+                let mut tcp2 = tcp2;\n+                t!(tcp2.read(&mut [0]));\n+                txdone3.send(()).unwrap();\n+            });\n+\n+            // Try to ensure that the reading clone is indeed reading\n+            for _ in 0..50 {\n+                Thread::yield_now();\n+            }\n+\n+            // clone the handle again while it's reading, then let it finish the\n+            // read.\n+            let _ = t!(tcp.try_clone());\n+            tx.send(()).unwrap();\n+            rxdone.recv().unwrap();\n+            rxdone.recv().unwrap();\n+        })\n+    }\n+\n+    #[test]\n+    fn clone_accept_smoke() {\n+        each_ip(&mut |addr| {\n+            let a = t!(TcpListener::bind(&addr));\n+            let a2 = t!(a.try_clone());\n+\n+            let _t = Thread::scoped(move|| {\n+                let _ = TcpStream::connect(&addr);\n+            });\n+            let _t = Thread::scoped(move|| {\n+                let _ = TcpStream::connect(&addr);\n+            });\n+\n+            t!(a.accept());\n+            t!(a2.accept());\n+        })\n+    }\n+\n+    #[test]\n+    fn clone_accept_concurrent() {\n+        each_ip(&mut |addr| {\n+            let a = t!(TcpListener::bind(&addr));\n+            let a2 = t!(a.try_clone());\n+\n+            let (tx, rx) = channel();\n+            let tx2 = tx.clone();\n+\n+            let _t = Thread::scoped(move|| {\n+                tx.send(t!(a.accept())).unwrap();\n+            });\n+            let _t = Thread::scoped(move|| {\n+                tx2.send(t!(a2.accept())).unwrap();\n+            });\n+\n+            let _t = Thread::scoped(move|| {\n+                let _ = TcpStream::connect(&addr);\n+            });\n+            let _t = Thread::scoped(move|| {\n+                let _ = TcpStream::connect(&addr);\n+            });\n+\n+            rx.recv().unwrap();\n+            rx.recv().unwrap();\n+        })\n+    }\n+}"}, {"sha": "971fb4b69c8ef5ee6df1cd5ef3700d2c248f2ebf", "filename": "src/libstd/net/test.rs", "status": "added", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/3ef8ff1f81107b42840a695725e1a0869c163355/src%2Flibstd%2Fnet%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ef8ff1f81107b42840a695725e1a0869c163355/src%2Flibstd%2Fnet%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnet%2Ftest.rs?ref=3ef8ff1f81107b42840a695725e1a0869c163355", "patch": "@@ -0,0 +1,39 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use prelude::v1::*;\n+\n+use env;\n+use net::{SocketAddr, IpAddr};\n+use sync::atomic::{AtomicUsize, ATOMIC_USIZE_INIT, Ordering};\n+\n+pub fn next_test_ip4() -> SocketAddr {\n+    static PORT: AtomicUsize = ATOMIC_USIZE_INIT;\n+    SocketAddr::new(IpAddr::new_v4(127, 0, 0, 1),\n+                    PORT.fetch_add(1, Ordering::SeqCst) as u16 + base_port())\n+}\n+\n+pub fn next_test_ip6() -> SocketAddr {\n+    static PORT: AtomicUsize = ATOMIC_USIZE_INIT;\n+    SocketAddr::new(IpAddr::new_v6(0, 0, 0, 0, 0, 0, 0, 1),\n+                    PORT.fetch_add(1, Ordering::SeqCst) as u16 + base_port())\n+}\n+\n+// The bots run multiple builds at the same time, and these builds\n+// all want to use ports. This function figures out which workspace\n+// it is running in and assigns a port range based on it.\n+fn base_port() -> u16 {\n+    let cwd = env::current_dir().unwrap();\n+    let dirs = [\"32-opt\", \"32-nopt\", \"64-opt\", \"64-nopt\", \"64-opt-vg\",\n+                \"all-opt\", \"snap3\", \"dist\"];\n+    dirs.iter().enumerate().find(|&(i, dir)| {\n+        cwd.as_str().unwrap().contains(dir)\n+    }).map(|p| p.0).unwrap_or(0) as u16 * 1000 + 19600\n+}"}, {"sha": "d162a29790ea16c77ea4e6463209b00f8f829554", "filename": "src/libstd/net/udp.rs", "status": "added", "additions": 291, "deletions": 0, "changes": 291, "blob_url": "https://github.com/rust-lang/rust/blob/3ef8ff1f81107b42840a695725e1a0869c163355/src%2Flibstd%2Fnet%2Fudp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ef8ff1f81107b42840a695725e1a0869c163355/src%2Flibstd%2Fnet%2Fudp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnet%2Fudp.rs?ref=3ef8ff1f81107b42840a695725e1a0869c163355", "patch": "@@ -0,0 +1,291 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use prelude::v1::*;\n+\n+use io::{self, Error, ErrorKind};\n+use net::{ToSocketAddrs, SocketAddr, IpAddr};\n+use sys_common::net2 as net_imp;\n+use sys_common::AsInner;\n+\n+/// A User Datagram Protocol socket.\n+///\n+/// This is an implementation of a bound UDP socket. This supports both IPv4 and\n+/// IPv6 addresses, and there is no corresponding notion of a server because UDP\n+/// is a datagram protocol.\n+///\n+/// # Example\n+///\n+/// ```no_run\n+/// use std::net::UdpSocket;\n+///\n+/// # fn foo() -> std::io::Result<()> {\n+/// let mut socket = try!(UdpSocket::bind(\"127.0.0.1:34254\"));\n+///\n+/// let mut buf = [0; 10];\n+/// let (amt, src) = try!(socket.recv_from(&mut buf));\n+///\n+/// // Send a reply to the socket we received data from\n+/// let buf = &mut buf[..amt];\n+/// buf.reverse();\n+/// try!(socket.send_to(buf, &src));\n+///\n+/// drop(socket); // close the socket\n+/// # Ok(())\n+/// # }\n+/// ```\n+pub struct UdpSocket(net_imp::UdpSocket);\n+\n+impl UdpSocket {\n+    /// Creates a UDP socket from the given address.\n+    ///\n+    /// Address type can be any implementor of `ToSocketAddr` trait. See its\n+    /// documentation for concrete examples.\n+    pub fn bind<A: ToSocketAddrs + ?Sized>(addr: &A) -> io::Result<UdpSocket> {\n+        super::each_addr(addr, net_imp::UdpSocket::bind).map(UdpSocket)\n+    }\n+\n+    /// Receives data from the socket. On success, returns the number of bytes\n+    /// read and the address from whence the data came.\n+    pub fn recv_from(&self, buf: &mut [u8]) -> io::Result<(usize, SocketAddr)> {\n+        self.0.recv_from(buf)\n+    }\n+\n+    /// Sends data on the socket to the given address. Returns nothing on\n+    /// success.\n+    ///\n+    /// Address type can be any implementor of `ToSocketAddrs` trait. See its\n+    /// documentation for concrete examples.\n+    pub fn send_to<A: ToSocketAddrs + ?Sized>(&self, buf: &[u8], addr: &A)\n+                                              -> io::Result<usize> {\n+        match try!(addr.to_socket_addrs()).next() {\n+            Some(addr) => self.0.send_to(buf, &addr),\n+            None => Err(Error::new(ErrorKind::InvalidInput,\n+                                   \"no addresses to send data to\", None)),\n+        }\n+    }\n+\n+    /// Returns the socket address that this socket was created from.\n+    pub fn socket_addr(&self) -> io::Result<SocketAddr> {\n+        self.0.socket_addr()\n+    }\n+\n+    /// Create a new independently owned handle to the underlying socket.\n+    ///\n+    /// The returned `UdpSocket` is a reference to the same socket that this\n+    /// object references. Both handles will read and write the same port, and\n+    /// options set on one socket will be propagated to the other.\n+    pub fn try_clone(&self) -> io::Result<UdpSocket> {\n+        self.0.duplicate().map(UdpSocket)\n+    }\n+\n+    /// Sets the broadcast flag on or off\n+    pub fn set_broadcast(&self, on: bool) -> io::Result<()> {\n+        self.0.set_broadcast(on)\n+    }\n+\n+    /// Set the multicast loop flag to the specified value\n+    ///\n+    /// This lets multicast packets loop back to local sockets (if enabled)\n+    pub fn set_multicast_loop(&self, on: bool) -> io::Result<()> {\n+        self.0.set_multicast_loop(on)\n+    }\n+\n+    /// Joins a multicast IP address (becomes a member of it)\n+    pub fn join_multicast(&self, multi: &IpAddr) -> io::Result<()> {\n+        self.0.join_multicast(multi)\n+    }\n+\n+    /// Leaves a multicast IP address (drops membership from it)\n+    pub fn leave_multicast(&self, multi: &IpAddr) -> io::Result<()> {\n+        self.0.leave_multicast(multi)\n+    }\n+\n+    /// Sets the multicast TTL\n+    pub fn set_multicast_time_to_live(&self, ttl: i32) -> io::Result<()> {\n+        self.0.multicast_time_to_live(ttl)\n+    }\n+\n+    /// Sets this socket's TTL\n+    pub fn set_time_to_live(&self, ttl: i32) -> io::Result<()> {\n+        self.0.time_to_live(ttl)\n+    }\n+}\n+\n+impl AsInner<net_imp::UdpSocket> for UdpSocket {\n+    fn as_inner(&self) -> &net_imp::UdpSocket { &self.0 }\n+}\n+\n+#[cfg(test)]\n+mod tests {\n+    use prelude::v1::*;\n+\n+    use io::ErrorKind;\n+    use net::*;\n+    use net::test::{next_test_ip4, next_test_ip6};\n+    use sync::mpsc::channel;\n+    use thread::Thread;\n+\n+    fn each_ip(f: &mut FnMut(SocketAddr, SocketAddr)) {\n+        f(next_test_ip4(), next_test_ip4());\n+        f(next_test_ip6(), next_test_ip6());\n+    }\n+\n+    macro_rules! t {\n+        ($e:expr) => {\n+            match $e {\n+                Ok(t) => t,\n+                Err(e) => panic!(\"received error for `{}`: {}\", stringify!($e), e),\n+            }\n+        }\n+    }\n+\n+    // FIXME #11530 this fails on android because tests are run as root\n+    #[cfg_attr(any(windows, target_os = \"android\"), ignore)]\n+    #[test]\n+    fn bind_error() {\n+        let addr = SocketAddr::new(IpAddr::new_v4(0, 0, 0, 0), 1);\n+        match UdpSocket::bind(&addr) {\n+            Ok(..) => panic!(),\n+            Err(e) => assert_eq!(e.kind(), ErrorKind::PermissionDenied),\n+        }\n+    }\n+\n+    #[test]\n+    fn socket_smoke_test_ip4() {\n+        each_ip(&mut |server_ip, client_ip| {\n+            let (tx1, rx1) = channel();\n+            let (tx2, rx2) = channel();\n+\n+            let _t = Thread::spawn(move|| {\n+                let client = t!(UdpSocket::bind(&client_ip));\n+                rx1.recv().unwrap();\n+                t!(client.send_to(&[99], &server_ip));\n+                tx2.send(()).unwrap();\n+            });\n+\n+            let server = t!(UdpSocket::bind(&server_ip));\n+            tx1.send(()).unwrap();\n+            let mut buf = [0];\n+            let (nread, src) = t!(server.recv_from(&mut buf));\n+            assert_eq!(nread, 1);\n+            assert_eq!(buf[0], 99);\n+            assert_eq!(src, client_ip);\n+            rx2.recv().unwrap();\n+        })\n+    }\n+\n+    #[test]\n+    fn socket_name_ip4() {\n+        each_ip(&mut |addr, _| {\n+            let server = t!(UdpSocket::bind(&addr));\n+            assert_eq!(addr, t!(server.socket_addr()));\n+        })\n+    }\n+\n+    #[test]\n+    fn udp_clone_smoke() {\n+        each_ip(&mut |addr1, addr2| {\n+            let sock1 = t!(UdpSocket::bind(&addr1));\n+            let sock2 = t!(UdpSocket::bind(&addr2));\n+\n+            let _t = Thread::spawn(move|| {\n+                let mut buf = [0, 0];\n+                assert_eq!(sock2.recv_from(&mut buf), Ok((1, addr1)));\n+                assert_eq!(buf[0], 1);\n+                t!(sock2.send_to(&[2], &addr1));\n+            });\n+\n+            let sock3 = t!(sock1.try_clone());\n+\n+            let (tx1, rx1) = channel();\n+            let (tx2, rx2) = channel();\n+            let _t = Thread::spawn(move|| {\n+                rx1.recv().unwrap();\n+                t!(sock3.send_to(&[1], &addr2));\n+                tx2.send(()).unwrap();\n+            });\n+            tx1.send(()).unwrap();\n+            let mut buf = [0, 0];\n+            assert_eq!(sock1.recv_from(&mut buf), Ok((1, addr2)));\n+            rx2.recv().unwrap();\n+        })\n+    }\n+\n+    #[test]\n+    fn udp_clone_two_read() {\n+        each_ip(&mut |addr1, addr2| {\n+            let sock1 = t!(UdpSocket::bind(&addr1));\n+            let sock2 = t!(UdpSocket::bind(&addr2));\n+            let (tx1, rx) = channel();\n+            let tx2 = tx1.clone();\n+\n+            let _t = Thread::spawn(move|| {\n+                t!(sock2.send_to(&[1], &addr1));\n+                rx.recv().unwrap();\n+                t!(sock2.send_to(&[2], &addr1));\n+                rx.recv().unwrap();\n+            });\n+\n+            let sock3 = t!(sock1.try_clone());\n+\n+            let (done, rx) = channel();\n+            let _t = Thread::spawn(move|| {\n+                let mut buf = [0, 0];\n+                t!(sock3.recv_from(&mut buf));\n+                tx2.send(()).unwrap();\n+                done.send(()).unwrap();\n+            });\n+            let mut buf = [0, 0];\n+            t!(sock1.recv_from(&mut buf));\n+            tx1.send(()).unwrap();\n+\n+            rx.recv().unwrap();\n+        })\n+    }\n+\n+    #[test]\n+    fn udp_clone_two_write() {\n+        each_ip(&mut |addr1, addr2| {\n+            let sock1 = t!(UdpSocket::bind(&addr1));\n+            let sock2 = t!(UdpSocket::bind(&addr2));\n+\n+            let (tx, rx) = channel();\n+            let (serv_tx, serv_rx) = channel();\n+\n+            let _t = Thread::spawn(move|| {\n+                let mut buf = [0, 1];\n+                rx.recv().unwrap();\n+                t!(sock2.recv_from(&mut buf));\n+                serv_tx.send(()).unwrap();\n+            });\n+\n+            let sock3 = t!(sock1.try_clone());\n+\n+            let (done, rx) = channel();\n+            let tx2 = tx.clone();\n+            let _t = Thread::spawn(move|| {\n+                match sock3.send_to(&[1], &addr2) {\n+                    Ok(..) => { let _ = tx2.send(()); }\n+                    Err(..) => {}\n+                }\n+                done.send(()).unwrap();\n+            });\n+            match sock1.send_to(&[2], &addr2) {\n+                Ok(..) => { let _ = tx.send(()); }\n+                Err(..) => {}\n+            }\n+            drop(tx);\n+\n+            rx.recv().unwrap();\n+            serv_rx.recv().unwrap();\n+        })\n+    }\n+}"}, {"sha": "0f4d9c8b4ea457836af8a72666d6b2117c49a5f1", "filename": "src/libstd/old_io/mem.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/3ef8ff1f81107b42840a695725e1a0869c163355/src%2Flibstd%2Fold_io%2Fmem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ef8ff1f81107b42840a695725e1a0869c163355/src%2Flibstd%2Fold_io%2Fmem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fold_io%2Fmem.rs?ref=3ef8ff1f81107b42840a695725e1a0869c163355", "patch": "@@ -66,6 +66,7 @@ impl Writer for Vec<u8> {\n #[deprecated(since = \"1.0.0\",\n              reason = \"use the Vec<u8> Writer implementation directly\")]\n #[derive(Clone)]\n+#[allow(deprecated)]\n pub struct MemWriter {\n     buf: Vec<u8>,\n }"}, {"sha": "94f4af8e558ade482e80a2872861178f9509cd9d", "filename": "src/libstd/old_io/mod.rs", "status": "modified", "additions": 19, "deletions": 19, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/3ef8ff1f81107b42840a695725e1a0869c163355/src%2Flibstd%2Fold_io%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ef8ff1f81107b42840a695725e1a0869c163355/src%2Flibstd%2Fold_io%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fold_io%2Fmod.rs?ref=3ef8ff1f81107b42840a695725e1a0869c163355", "patch": "@@ -250,7 +250,7 @@ use char::CharExt;\n use default::Default;\n use error::Error;\n use fmt;\n-use int;\n+use isize;\n use iter::{Iterator, IteratorExt};\n use marker::Sized;\n use mem::transmute;\n@@ -266,7 +266,7 @@ use slice::SliceExt;\n use str::StrExt;\n use str;\n use string::String;\n-use uint;\n+use usize;\n use unicode;\n use vec::Vec;\n \n@@ -712,28 +712,28 @@ pub trait Reader {\n     ///\n     /// The number of bytes returned is system-dependent.\n     fn read_le_uint(&mut self) -> IoResult<uint> {\n-        self.read_le_uint_n(uint::BYTES).map(|i| i as uint)\n+        self.read_le_uint_n(usize::BYTES).map(|i| i as uint)\n     }\n \n     /// Reads a little-endian integer.\n     ///\n     /// The number of bytes returned is system-dependent.\n     fn read_le_int(&mut self) -> IoResult<int> {\n-        self.read_le_int_n(int::BYTES).map(|i| i as int)\n+        self.read_le_int_n(isize::BYTES).map(|i| i as int)\n     }\n \n     /// Reads a big-endian unsigned integer.\n     ///\n     /// The number of bytes returned is system-dependent.\n     fn read_be_uint(&mut self) -> IoResult<uint> {\n-        self.read_be_uint_n(uint::BYTES).map(|i| i as uint)\n+        self.read_be_uint_n(usize::BYTES).map(|i| i as uint)\n     }\n \n     /// Reads a big-endian integer.\n     ///\n     /// The number of bytes returned is system-dependent.\n     fn read_be_int(&mut self) -> IoResult<int> {\n-        self.read_be_int_n(int::BYTES).map(|i| i as int)\n+        self.read_be_int_n(isize::BYTES).map(|i| i as int)\n     }\n \n     /// Reads a big-endian `u64`.\n@@ -1096,25 +1096,25 @@ pub trait Writer {\n     /// Write a little-endian uint (number of bytes depends on system).\n     #[inline]\n     fn write_le_uint(&mut self, n: uint) -> IoResult<()> {\n-        extensions::u64_to_le_bytes(n as u64, uint::BYTES, |v| self.write_all(v))\n+        extensions::u64_to_le_bytes(n as u64, usize::BYTES, |v| self.write_all(v))\n     }\n \n     /// Write a little-endian int (number of bytes depends on system).\n     #[inline]\n     fn write_le_int(&mut self, n: int) -> IoResult<()> {\n-        extensions::u64_to_le_bytes(n as u64, int::BYTES, |v| self.write_all(v))\n+        extensions::u64_to_le_bytes(n as u64, isize::BYTES, |v| self.write_all(v))\n     }\n \n     /// Write a big-endian uint (number of bytes depends on system).\n     #[inline]\n     fn write_be_uint(&mut self, n: uint) -> IoResult<()> {\n-        extensions::u64_to_be_bytes(n as u64, uint::BYTES, |v| self.write_all(v))\n+        extensions::u64_to_be_bytes(n as u64, usize::BYTES, |v| self.write_all(v))\n     }\n \n     /// Write a big-endian int (number of bytes depends on system).\n     #[inline]\n     fn write_be_int(&mut self, n: int) -> IoResult<()> {\n-        extensions::u64_to_be_bytes(n as u64, int::BYTES, |v| self.write_all(v))\n+        extensions::u64_to_be_bytes(n as u64, isize::BYTES, |v| self.write_all(v))\n     }\n \n     /// Write a big-endian u64 (8 bytes).\n@@ -1844,7 +1844,7 @@ mod tests {\n     use self::BadReaderBehavior::*;\n     use super::{IoResult, Reader, MemReader, NoProgress, InvalidInput, Writer};\n     use prelude::v1::{Ok, Vec, Buffer, SliceExt};\n-    use uint;\n+    use usize;\n \n     #[derive(Clone, PartialEq, Debug)]\n     enum BadReaderBehavior {\n@@ -1891,24 +1891,24 @@ mod tests {\n     #[test]\n     fn test_read_at_least() {\n         let mut r = BadReader::new(MemReader::new(b\"hello, world!\".to_vec()),\n-                                   vec![GoodBehavior(uint::MAX)]);\n+                                   vec![GoodBehavior(usize::MAX)]);\n         let buf = &mut [0u8; 5];\n         assert!(r.read_at_least(1, buf).unwrap() >= 1);\n         assert!(r.read_exact(5).unwrap().len() == 5); // read_exact uses read_at_least\n         assert!(r.read_at_least(0, buf).is_ok());\n \n         let mut r = BadReader::new(MemReader::new(b\"hello, world!\".to_vec()),\n-                                   vec![BadBehavior(50), GoodBehavior(uint::MAX)]);\n+                                   vec![BadBehavior(50), GoodBehavior(usize::MAX)]);\n         assert!(r.read_at_least(1, buf).unwrap() >= 1);\n \n         let mut r = BadReader::new(MemReader::new(b\"hello, world!\".to_vec()),\n                                    vec![BadBehavior(1), GoodBehavior(1),\n-                                        BadBehavior(50), GoodBehavior(uint::MAX)]);\n+                                        BadBehavior(50), GoodBehavior(usize::MAX)]);\n         assert!(r.read_at_least(1, buf).unwrap() >= 1);\n         assert!(r.read_at_least(1, buf).unwrap() >= 1);\n \n         let mut r = BadReader::new(MemReader::new(b\"hello, world!\".to_vec()),\n-                                   vec![BadBehavior(uint::MAX)]);\n+                                   vec![BadBehavior(usize::MAX)]);\n         assert_eq!(r.read_at_least(1, buf).unwrap_err().kind, NoProgress);\n \n         let mut r = MemReader::new(b\"hello, world!\".to_vec());\n@@ -1919,23 +1919,23 @@ mod tests {\n     #[test]\n     fn test_push_at_least() {\n         let mut r = BadReader::new(MemReader::new(b\"hello, world!\".to_vec()),\n-                                   vec![GoodBehavior(uint::MAX)]);\n+                                   vec![GoodBehavior(usize::MAX)]);\n         let mut buf = Vec::new();\n         assert!(r.push_at_least(1, 5, &mut buf).unwrap() >= 1);\n         assert!(r.push_at_least(0, 5, &mut buf).is_ok());\n \n         let mut r = BadReader::new(MemReader::new(b\"hello, world!\".to_vec()),\n-                                   vec![BadBehavior(50), GoodBehavior(uint::MAX)]);\n+                                   vec![BadBehavior(50), GoodBehavior(usize::MAX)]);\n         assert!(r.push_at_least(1, 5, &mut buf).unwrap() >= 1);\n \n         let mut r = BadReader::new(MemReader::new(b\"hello, world!\".to_vec()),\n                                    vec![BadBehavior(1), GoodBehavior(1),\n-                                        BadBehavior(50), GoodBehavior(uint::MAX)]);\n+                                        BadBehavior(50), GoodBehavior(usize::MAX)]);\n         assert!(r.push_at_least(1, 5, &mut buf).unwrap() >= 1);\n         assert!(r.push_at_least(1, 5, &mut buf).unwrap() >= 1);\n \n         let mut r = BadReader::new(MemReader::new(b\"hello, world!\".to_vec()),\n-                                   vec![BadBehavior(uint::MAX)]);\n+                                   vec![BadBehavior(usize::MAX)]);\n         assert_eq!(r.push_at_least(1, 5, &mut buf).unwrap_err().kind, NoProgress);\n \n         let mut r = MemReader::new(b\"hello, world!\".to_vec());"}, {"sha": "8e55251d285b5e23eb699dcd5b169a951847d590", "filename": "src/libstd/old_io/stdio.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/3ef8ff1f81107b42840a695725e1a0869c163355/src%2Flibstd%2Fold_io%2Fstdio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ef8ff1f81107b42840a695725e1a0869c163355/src%2Flibstd%2Fold_io%2Fstdio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fold_io%2Fstdio.rs?ref=3ef8ff1f81107b42840a695725e1a0869c163355", "patch": "@@ -48,7 +48,7 @@ use str::StrExt;\n use string::String;\n use sys::{fs, tty};\n use sync::{Arc, Mutex, MutexGuard, Once, ONCE_INIT};\n-use uint;\n+use usize;\n use vec::Vec;\n \n // And so begins the tale of acquiring a uv handle to a stdio stream on all\n@@ -384,12 +384,14 @@ pub fn println(s: &str) {\n \n /// Similar to `print`, but takes a `fmt::Arguments` structure to be compatible\n /// with the `format_args!` macro.\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub fn print_args(fmt: fmt::Arguments) {\n     with_task_stdout(|io| write!(io, \"{}\", fmt))\n }\n \n /// Similar to `println`, but takes a `fmt::Arguments` structure to be\n /// compatible with the `format_args!` macro.\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub fn println_args(fmt: fmt::Arguments) {\n     with_task_stdout(|io| writeln!(io, \"{}\", fmt))\n }\n@@ -511,7 +513,7 @@ impl Writer for StdWriter {\n         //\n         // [1]: https://tahoe-lafs.org/trac/tahoe-lafs/ticket/1232\n         // [2]: http://www.mail-archive.com/log4net-dev@logging.apache.org/msg00661.html\n-        let max_size = if cfg!(windows) {8192} else {uint::MAX};\n+        let max_size = if cfg!(windows) {8192} else {usize::MAX};\n         for chunk in buf.chunks(max_size) {\n             try!(match self.inner {\n                 TTY(ref mut tty) => tty.write(chunk),"}, {"sha": "2a0206d9ff08e20175034f9a63f24d5a5f2aa170", "filename": "src/libstd/os.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/3ef8ff1f81107b42840a695725e1a0869c163355/src%2Flibstd%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ef8ff1f81107b42840a695725e1a0869c163355/src%2Flibstd%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fos.rs?ref=3ef8ff1f81107b42840a695725e1a0869c163355", "patch": "@@ -125,7 +125,7 @@ pub fn getcwd() -> IoResult<Path> {\n #[deprecated(since = \"1.0.0\", reason = \"use env::vars instead\")]\n #[unstable(feature = \"os\")]\n pub fn env() -> Vec<(String,String)> {\n-    env::vars().map(|(k, v)| {\n+    env::vars_os().map(|(k, v)| {\n         (k.to_string_lossy().into_owned(), v.to_string_lossy().into_owned())\n     }).collect()\n }\n@@ -135,7 +135,7 @@ pub fn env() -> Vec<(String,String)> {\n #[deprecated(since = \"1.0.0\", reason = \"use env::vars instead\")]\n #[unstable(feature = \"os\")]\n pub fn env_as_bytes() -> Vec<(Vec<u8>, Vec<u8>)> {\n-    env::vars().map(|(k, v)| (byteify(k), byteify(v))).collect()\n+    env::vars_os().map(|(k, v)| (byteify(k), byteify(v))).collect()\n }\n \n /// Fetches the environment variable `n` from the current process, returning\n@@ -159,10 +159,10 @@ pub fn env_as_bytes() -> Vec<(Vec<u8>, Vec<u8>)> {\n ///     None => println!(\"{} is not defined in the environment.\", key)\n /// }\n /// ```\n-#[deprecated(since = \"1.0.0\", reason = \"use env::var or env::var_string instead\")]\n+#[deprecated(since = \"1.0.0\", reason = \"use env::var or env::var_os instead\")]\n #[unstable(feature = \"os\")]\n pub fn getenv(n: &str) -> Option<String> {\n-    env::var_string(n).ok()\n+    env::var(n).ok()\n }\n \n /// Fetches the environment variable `n` byte vector from the current process,\n@@ -174,7 +174,7 @@ pub fn getenv(n: &str) -> Option<String> {\n #[deprecated(since = \"1.0.0\", reason = \"use env::var instead\")]\n #[unstable(feature = \"os\")]\n pub fn getenv_as_bytes(n: &str) -> Option<Vec<u8>> {\n-    env::var(n).map(byteify)\n+    env::var_os(n).map(byteify)\n }\n \n #[cfg(unix)]\n@@ -317,6 +317,7 @@ pub unsafe fn pipe() -> IoResult<Pipe> {\n #[cfg(not(target_os=\"ios\"))]\n #[deprecated(since = \"1.0.0\", reason = \"this function will be removed, use the constants directly\")]\n #[unstable(feature = \"os\")]\n+#[allow(deprecated)]\n pub fn dll_filename(base: &str) -> String {\n     format!(\"{}{}{}\", consts::DLL_PREFIX, base, consts::DLL_SUFFIX)\n }"}, {"sha": "4984b4f9aba78dd31a9e1fd151a8d66403b86776", "filename": "src/libstd/path.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/3ef8ff1f81107b42840a695725e1a0869c163355/src%2Flibstd%2Fpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ef8ff1f81107b42840a695725e1a0869c163355/src%2Flibstd%2Fpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpath.rs?ref=3ef8ff1f81107b42840a695725e1a0869c163355", "patch": "@@ -878,7 +878,8 @@ impl PathBuf {\n \n     /// Truncate `self` to `self.parent()`.\n     ///\n-    /// Returns `None` and does nothing if `self.parent()` is `None`.\n+    /// Returns `false` and does nothing if `self.parent()` is `None`.\n+    /// Otherwise, returns `true`.\n     pub fn pop(&mut self) -> bool {\n         match self.parent().map(|p| p.as_u8_slice().len()) {\n             Some(len) => {"}, {"sha": "ced84d7551eef349989e897afd1598264288d366", "filename": "src/libstd/rt/backtrace.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3ef8ff1f81107b42840a695725e1a0869c163355/src%2Flibstd%2Frt%2Fbacktrace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ef8ff1f81107b42840a695725e1a0869c163355/src%2Flibstd%2Frt%2Fbacktrace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fbacktrace.rs?ref=3ef8ff1f81107b42840a695725e1a0869c163355", "patch": "@@ -29,7 +29,7 @@ pub fn log_enabled() -> bool {\n         _ => {}\n     }\n \n-    let val = match env::var(\"RUST_BACKTRACE\") {\n+    let val = match env::var_os(\"RUST_BACKTRACE\") {\n         Some(..) => 2,\n         None => 1,\n     };"}, {"sha": "659e787a9ff8f00e9a4e1731bc3668388316ca6e", "filename": "src/libstd/rt/unwind.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3ef8ff1f81107b42840a695725e1a0869c163355/src%2Flibstd%2Frt%2Funwind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ef8ff1f81107b42840a695725e1a0869c163355/src%2Flibstd%2Frt%2Funwind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Funwind.rs?ref=3ef8ff1f81107b42840a695725e1a0869c163355", "patch": "@@ -494,6 +494,7 @@ pub extern fn rust_begin_unwind(msg: fmt::Arguments,\n /// on (e.g.) the inlining of other functions as possible), by moving\n /// the actual formatting into this shared place.\n #[inline(never)] #[cold]\n+#[stable(since = \"1.0.0\", feature = \"rust1\")]\n pub fn begin_unwind_fmt(msg: fmt::Arguments, file_line: &(&'static str, uint)) -> ! {\n     use fmt::Writer;\n \n@@ -509,6 +510,7 @@ pub fn begin_unwind_fmt(msg: fmt::Arguments, file_line: &(&'static str, uint)) -\n \n /// This is the entry point of unwinding for panic!() and assert!().\n #[inline(never)] #[cold] // avoid code bloat at the call sites as much as possible\n+#[stable(since = \"1.0.0\", feature = \"rust1\")]\n pub fn begin_unwind<M: Any + Send>(msg: M, file_line: &(&'static str, uint)) -> ! {\n     // Note that this should be the only allocation performed in this code path.\n     // Currently this means that panic!() on OOM will invoke this code path,"}, {"sha": "bb57d19ed2666ae45d172b64edfd0fea9488e96b", "filename": "src/libstd/rt/util.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3ef8ff1f81107b42840a695725e1a0869c163355/src%2Flibstd%2Frt%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ef8ff1f81107b42840a695725e1a0869c163355/src%2Flibstd%2Frt%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Futil.rs?ref=3ef8ff1f81107b42840a695725e1a0869c163355", "patch": "@@ -52,7 +52,7 @@ pub fn min_stack() -> uint {\n         0 => {}\n         n => return n - 1,\n     }\n-    let amt = env::var_string(\"RUST_MIN_STACK\").ok().and_then(|s| s.parse().ok());\n+    let amt = env::var(\"RUST_MIN_STACK\").ok().and_then(|s| s.parse().ok());\n     let amt = amt.unwrap_or(2 * 1024 * 1024);\n     // 0 is our sentinel value, so ensure that we'll never see 0 after\n     // initialization has run\n@@ -63,7 +63,7 @@ pub fn min_stack() -> uint {\n /// Get's the number of scheduler threads requested by the environment\n /// either `RUST_THREADS` or `num_cpus`.\n pub fn default_sched_threads() -> uint {\n-    match env::var_string(\"RUST_THREADS\") {\n+    match env::var(\"RUST_THREADS\") {\n         Ok(nstr) => {\n             let opt_n: Option<uint> = nstr.parse().ok();\n             match opt_n {"}, {"sha": "babae93b2d44031387873d5a73ce31f4985c9946", "filename": "src/libstd/sync/mpsc/select.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/3ef8ff1f81107b42840a695725e1a0869c163355/src%2Flibstd%2Fsync%2Fmpsc%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ef8ff1f81107b42840a695725e1a0869c163355/src%2Flibstd%2Fsync%2Fmpsc%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fmpsc%2Fselect.rs?ref=3ef8ff1f81107b42840a695725e1a0869c163355", "patch": "@@ -61,7 +61,7 @@ use core::cell::Cell;\n use core::marker;\n use core::mem;\n use core::ptr;\n-use core::uint;\n+use core::usize;\n \n use sync::mpsc::{Receiver, RecvError};\n use sync::mpsc::blocking::{self, SignalToken};\n@@ -228,15 +228,15 @@ impl Select {\n             // A rewrite should focus on avoiding a yield loop, and for now this\n             // implementation is tying us over to a more efficient \"don't\n             // iterate over everything every time\" implementation.\n-            let mut ready_id = uint::MAX;\n+            let mut ready_id = usize::MAX;\n             for handle in self.iter() {\n                 if (*handle).packet.abort_selection() {\n                     ready_id = (*handle).id;\n                 }\n             }\n \n             // We must have found a ready receiver\n-            assert!(ready_id != uint::MAX);\n+            assert!(ready_id != usize::MAX);\n             return ready_id;\n         }\n     }"}, {"sha": "6c31fb925911edbbea453cdbcb57af7ab9b3ab26", "filename": "src/libstd/sync/mpsc/shared.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/3ef8ff1f81107b42840a695725e1a0869c163355/src%2Flibstd%2Fsync%2Fmpsc%2Fshared.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ef8ff1f81107b42840a695725e1a0869c163355/src%2Flibstd%2Fsync%2Fmpsc%2Fshared.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fmpsc%2Fshared.rs?ref=3ef8ff1f81107b42840a695725e1a0869c163355", "patch": "@@ -23,7 +23,7 @@ pub use self::Failure::*;\n use core::prelude::*;\n \n use core::cmp;\n-use core::int;\n+use core::isize;\n \n use sync::atomic::{AtomicUsize, AtomicIsize, AtomicBool, Ordering};\n use sync::mpsc::blocking::{self, SignalToken};\n@@ -33,17 +33,17 @@ use sync::mpsc::select::StartResult;\n use sync::{Mutex, MutexGuard};\n use thread::Thread;\n \n-const DISCONNECTED: int = int::MIN;\n-const FUDGE: int = 1024;\n+const DISCONNECTED: isize = isize::MIN;\n+const FUDGE: isize = 1024;\n #[cfg(test)]\n-const MAX_STEALS: int = 5;\n+const MAX_STEALS: isize = 5;\n #[cfg(not(test))]\n-const MAX_STEALS: int = 1 << 20;\n+const MAX_STEALS: isize = 1 << 20;\n \n pub struct Packet<T> {\n     queue: mpsc::Queue<T>,\n     cnt: AtomicIsize, // How many items are on this channel\n-    steals: int, // How many times has a port received without blocking?\n+    steals: isize, // How many times has a port received without blocking?\n     to_wake: AtomicUsize, // SignalToken for wake up\n \n     // The number of channels which are currently using this packet."}, {"sha": "ab9bd6b2ed7f6982a5c48273ea4548adb54a3d97", "filename": "src/libstd/sync/mpsc/stream.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/3ef8ff1f81107b42840a695725e1a0869c163355/src%2Flibstd%2Fsync%2Fmpsc%2Fstream.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ef8ff1f81107b42840a695725e1a0869c163355/src%2Flibstd%2Fsync%2Fmpsc%2Fstream.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fmpsc%2Fstream.rs?ref=3ef8ff1f81107b42840a695725e1a0869c163355", "patch": "@@ -25,19 +25,19 @@ use self::Message::*;\n use core::prelude::*;\n \n use core::cmp;\n-use core::int;\n+use core::isize;\n use thread::Thread;\n \n use sync::atomic::{AtomicIsize, AtomicUsize, Ordering, AtomicBool};\n use sync::mpsc::Receiver;\n use sync::mpsc::blocking::{self, SignalToken};\n use sync::mpsc::spsc_queue as spsc;\n \n-const DISCONNECTED: int = int::MIN;\n+const DISCONNECTED: isize = isize::MIN;\n #[cfg(test)]\n-const MAX_STEALS: int = 5;\n+const MAX_STEALS: isize = 5;\n #[cfg(not(test))]\n-const MAX_STEALS: int = 1 << 20;\n+const MAX_STEALS: isize = 1 << 20;\n \n pub struct Packet<T> {\n     queue: spsc::Queue<Message<T>>, // internal queue for all message"}, {"sha": "29c2051e5adc46f8b42cac7570f1c469dc03ca4d", "filename": "src/libstd/sync/once.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/3ef8ff1f81107b42840a695725e1a0869c163355/src%2Flibstd%2Fsync%2Fonce.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ef8ff1f81107b42840a695725e1a0869c163355/src%2Flibstd%2Fsync%2Fonce.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fonce.rs?ref=3ef8ff1f81107b42840a695725e1a0869c163355", "patch": "@@ -13,7 +13,7 @@\n //! This primitive is meant to be used to run one-time initialization. An\n //! example use case would be for initializing an FFI library.\n \n-use int;\n+use isize;\n use marker::Sync;\n use mem::drop;\n use ops::FnOnce;\n@@ -99,9 +99,9 @@ impl Once {\n \n         let prev = self.cnt.fetch_add(1, Ordering::SeqCst);\n         if prev < 0 {\n-            // Make sure we never overflow, we'll never have int::MIN\n+            // Make sure we never overflow, we'll never have isize::MIN\n             // simultaneous calls to `call_once` to make this value go back to 0\n-            self.cnt.store(int::MIN, Ordering::SeqCst);\n+            self.cnt.store(isize::MIN, Ordering::SeqCst);\n             return\n         }\n \n@@ -111,7 +111,7 @@ impl Once {\n         let guard = self.mutex.lock();\n         if self.cnt.load(Ordering::SeqCst) > 0 {\n             f();\n-            let prev = self.cnt.swap(int::MIN, Ordering::SeqCst);\n+            let prev = self.cnt.swap(isize::MIN, Ordering::SeqCst);\n             self.lock_cnt.store(prev, Ordering::SeqCst);\n         }\n         drop(guard);"}, {"sha": "5054f72ea98791d5931d66f917ccd2e87fd71604", "filename": "src/libstd/sys/common/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/3ef8ff1f81107b42840a695725e1a0869c163355/src%2Flibstd%2Fsys%2Fcommon%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ef8ff1f81107b42840a695725e1a0869c163355/src%2Flibstd%2Fsys%2Fcommon%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fcommon%2Fmod.rs?ref=3ef8ff1f81107b42840a695725e1a0869c163355", "patch": "@@ -24,6 +24,7 @@ pub mod condvar;\n pub mod helper_thread;\n pub mod mutex;\n pub mod net;\n+pub mod net2;\n pub mod rwlock;\n pub mod stack;\n pub mod thread;"}, {"sha": "5af59ec6d2b1473ae3b513bf420c0eff0400eb96", "filename": "src/libstd/sys/common/net2.rs", "status": "added", "additions": 393, "deletions": 0, "changes": 393, "blob_url": "https://github.com/rust-lang/rust/blob/3ef8ff1f81107b42840a695725e1a0869c163355/src%2Flibstd%2Fsys%2Fcommon%2Fnet2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ef8ff1f81107b42840a695725e1a0869c163355/src%2Flibstd%2Fsys%2Fcommon%2Fnet2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fcommon%2Fnet2.rs?ref=3ef8ff1f81107b42840a695725e1a0869c163355", "patch": "@@ -0,0 +1,393 @@\n+// Copyright 2013-2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use prelude::v1::*;\n+\n+use ffi::CString;\n+use io::{self, Error, ErrorKind};\n+use libc::{self, c_int, c_char, c_void, socklen_t};\n+use mem;\n+use net::{IpAddr, SocketAddr, Shutdown};\n+use num::Int;\n+use sys::c;\n+use sys::net::{cvt, cvt_r, cvt_gai, Socket, init, wrlen_t};\n+use sys_common::{AsInner, FromInner, IntoInner};\n+\n+////////////////////////////////////////////////////////////////////////////////\n+// sockaddr and misc bindings\n+////////////////////////////////////////////////////////////////////////////////\n+\n+fn hton<I: Int>(i: I) -> I { i.to_be() }\n+fn ntoh<I: Int>(i: I) -> I { Int::from_be(i) }\n+\n+fn setsockopt<T>(sock: &Socket, opt: c_int, val: c_int,\n+                     payload: T) -> io::Result<()> {\n+    unsafe {\n+        let payload = &payload as *const T as *const c_void;\n+        try!(cvt(libc::setsockopt(*sock.as_inner(), opt, val, payload,\n+                                  mem::size_of::<T>() as socklen_t)));\n+        Ok(())\n+    }\n+}\n+\n+#[allow(dead_code)]\n+fn getsockopt<T: Copy>(sock: &Socket, opt: c_int,\n+                           val: c_int) -> io::Result<T> {\n+    unsafe {\n+        let mut slot: T = mem::zeroed();\n+        let mut len = mem::size_of::<T>() as socklen_t;\n+        let ret = try!(cvt(c::getsockopt(*sock.as_inner(), opt, val,\n+                                         &mut slot as *mut _ as *mut _,\n+                                         &mut len)));\n+        assert_eq!(ret as usize, mem::size_of::<T>());\n+        Ok(slot)\n+    }\n+}\n+\n+fn sockname<F>(f: F) -> io::Result<SocketAddr>\n+    where F: FnOnce(*mut libc::sockaddr, *mut socklen_t) -> c_int\n+{\n+    unsafe {\n+        let mut storage: libc::sockaddr_storage = mem::zeroed();\n+        let mut len = mem::size_of_val(&storage) as socklen_t;\n+        try!(cvt(f(&mut storage as *mut _ as *mut _, &mut len)));\n+        sockaddr_to_addr(&storage, len as usize)\n+    }\n+}\n+\n+fn sockaddr_to_addr(storage: &libc::sockaddr_storage,\n+                    len: usize) -> io::Result<SocketAddr> {\n+    match storage.ss_family as libc::c_int {\n+        libc::AF_INET => {\n+            assert!(len as usize >= mem::size_of::<libc::sockaddr_in>());\n+            Ok(FromInner::from_inner(unsafe {\n+                *(storage as *const _ as *const libc::sockaddr_in)\n+            }))\n+        }\n+        libc::AF_INET6 => {\n+            assert!(len as usize >= mem::size_of::<libc::sockaddr_in6>());\n+            Ok(FromInner::from_inner(unsafe {\n+                *(storage as *const _ as *const libc::sockaddr_in6)\n+            }))\n+        }\n+        _ => {\n+            Err(Error::new(ErrorKind::InvalidInput, \"invalid argument\", None))\n+        }\n+    }\n+}\n+\n+////////////////////////////////////////////////////////////////////////////////\n+// get_host_addresses\n+////////////////////////////////////////////////////////////////////////////////\n+\n+extern \"system\" {\n+    fn getaddrinfo(node: *const c_char, service: *const c_char,\n+                   hints: *const libc::addrinfo,\n+                   res: *mut *mut libc::addrinfo) -> c_int;\n+    fn freeaddrinfo(res: *mut libc::addrinfo);\n+}\n+\n+pub struct LookupHost {\n+    original: *mut libc::addrinfo,\n+    cur: *mut libc::addrinfo,\n+}\n+\n+impl Iterator for LookupHost {\n+    type Item = io::Result<SocketAddr>;\n+    fn next(&mut self) -> Option<io::Result<SocketAddr>> {\n+        unsafe {\n+            if self.cur.is_null() { return None }\n+            let ret = sockaddr_to_addr(mem::transmute((*self.cur).ai_addr),\n+                                       (*self.cur).ai_addrlen as usize);\n+            self.cur = (*self.cur).ai_next as *mut libc::addrinfo;\n+            Some(ret)\n+        }\n+    }\n+}\n+\n+impl Drop for LookupHost {\n+    fn drop(&mut self) {\n+        unsafe { freeaddrinfo(self.original) }\n+    }\n+}\n+\n+pub fn lookup_host(host: &str) -> io::Result<LookupHost> {\n+    init();\n+\n+    let c_host = CString::from_slice(host.as_bytes());\n+    let mut res = 0 as *mut _;\n+    unsafe {\n+        try!(cvt_gai(getaddrinfo(c_host.as_ptr(), 0 as *const _, 0 as *const _,\n+                                 &mut res)));\n+        Ok(LookupHost { original: res, cur: res })\n+    }\n+}\n+\n+////////////////////////////////////////////////////////////////////////////////\n+// TCP streams\n+////////////////////////////////////////////////////////////////////////////////\n+\n+pub struct TcpStream {\n+    inner: Socket,\n+}\n+\n+impl TcpStream {\n+    pub fn connect(addr: &SocketAddr) -> io::Result<TcpStream> {\n+        init();\n+\n+        let sock = try!(Socket::new(addr, libc::SOCK_STREAM));\n+\n+        let (addrp, len) = addr.into_inner();\n+        try!(cvt_r(|| unsafe { libc::connect(*sock.as_inner(), addrp, len) }));\n+        Ok(TcpStream { inner: sock })\n+    }\n+\n+    pub fn socket(&self) -> &Socket { &self.inner }\n+\n+    pub fn set_nodelay(&self, nodelay: bool) -> io::Result<()> {\n+        setsockopt(&self.inner, libc::IPPROTO_TCP, libc::TCP_NODELAY,\n+                   nodelay as c_int)\n+    }\n+\n+    pub fn set_keepalive(&self, seconds: Option<u32>) -> io::Result<()> {\n+        let ret = setsockopt(&self.inner, libc::SOL_SOCKET, libc::SO_KEEPALIVE,\n+                             seconds.is_some() as c_int);\n+        match seconds {\n+            Some(n) => ret.and_then(|()| self.set_tcp_keepalive(n)),\n+            None => ret,\n+        }\n+    }\n+\n+    #[cfg(any(target_os = \"macos\", target_os = \"ios\"))]\n+    fn set_tcp_keepalive(&self, seconds: u32) -> io::Result<()> {\n+        setsockopt(&self.inner, libc::IPPROTO_TCP, libc::TCP_KEEPALIVE,\n+                   seconds as c_int)\n+    }\n+    #[cfg(any(target_os = \"freebsd\", target_os = \"dragonfly\"))]\n+    fn set_tcp_keepalive(&self, seconds: u32) -> io::Result<()> {\n+        setsockopt(&self.inner, libc::IPPROTO_TCP, libc::TCP_KEEPIDLE,\n+                   seconds as c_int)\n+    }\n+    #[cfg(not(any(target_os = \"macos\",\n+                  target_os = \"ios\",\n+                  target_os = \"freebsd\",\n+                  target_os = \"dragonfly\")))]\n+    fn set_tcp_keepalive(&self, _seconds: u32) -> io::Result<()> {\n+        Ok(())\n+    }\n+\n+    pub fn read(&self, buf: &mut [u8]) -> io::Result<usize> {\n+        self.inner.read(buf)\n+    }\n+\n+    pub fn write(&self, buf: &[u8]) -> io::Result<usize> {\n+        let ret = try!(cvt(unsafe {\n+            libc::send(*self.inner.as_inner(),\n+                       buf.as_ptr() as *const c_void,\n+                       buf.len() as wrlen_t,\n+                       0)\n+        }));\n+        Ok(ret as usize)\n+    }\n+\n+    pub fn peer_addr(&self) -> io::Result<SocketAddr> {\n+        sockname(|buf, len| unsafe {\n+            libc::getpeername(*self.inner.as_inner(), buf, len)\n+        })\n+    }\n+\n+    pub fn socket_addr(&self) -> io::Result<SocketAddr> {\n+        sockname(|buf, len| unsafe {\n+            libc::getsockname(*self.inner.as_inner(), buf, len)\n+        })\n+    }\n+\n+    pub fn shutdown(&self, how: Shutdown) -> io::Result<()> {\n+        use libc::consts::os::bsd44::SHUT_RDWR;\n+\n+        let how = match how {\n+            Shutdown::Write => libc::SHUT_WR,\n+            Shutdown::Read => libc::SHUT_RD,\n+            Shutdown::Both => SHUT_RDWR,\n+        };\n+        try!(cvt(unsafe { libc::shutdown(*self.inner.as_inner(), how) }));\n+        Ok(())\n+    }\n+\n+    pub fn duplicate(&self) -> io::Result<TcpStream> {\n+        self.inner.duplicate().map(|s| TcpStream { inner: s })\n+    }\n+}\n+\n+////////////////////////////////////////////////////////////////////////////////\n+// TCP listeners\n+////////////////////////////////////////////////////////////////////////////////\n+\n+pub struct TcpListener {\n+    inner: Socket,\n+}\n+\n+impl TcpListener {\n+    pub fn bind(addr: &SocketAddr) -> io::Result<TcpListener> {\n+        init();\n+\n+        let sock = try!(Socket::new(addr, libc::SOCK_STREAM));\n+\n+        // On platforms with Berkeley-derived sockets, this allows\n+        // to quickly rebind a socket, without needing to wait for\n+        // the OS to clean up the previous one.\n+        if !cfg!(windows) {\n+            try!(setsockopt(&sock, libc::SOL_SOCKET, libc::SO_REUSEADDR,\n+                            1 as c_int));\n+        }\n+\n+        // Bind our new socket\n+        let (addrp, len) = addr.into_inner();\n+        try!(cvt(unsafe { libc::bind(*sock.as_inner(), addrp, len) }));\n+\n+        // Start listening\n+        try!(cvt(unsafe { libc::listen(*sock.as_inner(), 128) }));\n+        Ok(TcpListener { inner: sock })\n+    }\n+\n+    pub fn socket(&self) -> &Socket { &self.inner }\n+\n+    pub fn socket_addr(&self) -> io::Result<SocketAddr> {\n+        sockname(|buf, len| unsafe {\n+            libc::getsockname(*self.inner.as_inner(), buf, len)\n+        })\n+    }\n+\n+    pub fn accept(&self) -> io::Result<(TcpStream, SocketAddr)> {\n+        let mut storage: libc::sockaddr_storage = unsafe { mem::zeroed() };\n+        let mut len = mem::size_of_val(&storage) as socklen_t;\n+        let sock = try!(self.inner.accept(&mut storage as *mut _ as *mut _,\n+                                          &mut len));\n+        let addr = try!(sockaddr_to_addr(&storage, len as usize));\n+        Ok((TcpStream { inner: sock, }, addr))\n+    }\n+\n+    pub fn duplicate(&self) -> io::Result<TcpListener> {\n+        self.inner.duplicate().map(|s| TcpListener { inner: s })\n+    }\n+}\n+\n+////////////////////////////////////////////////////////////////////////////////\n+// UDP\n+////////////////////////////////////////////////////////////////////////////////\n+\n+pub struct UdpSocket {\n+    inner: Socket,\n+}\n+\n+impl UdpSocket {\n+    pub fn bind(addr: &SocketAddr) -> io::Result<UdpSocket> {\n+        init();\n+\n+        let sock = try!(Socket::new(addr, libc::SOCK_DGRAM));\n+        let (addrp, len) = addr.into_inner();\n+        try!(cvt(unsafe { libc::bind(*sock.as_inner(), addrp, len) }));\n+        Ok(UdpSocket { inner: sock })\n+    }\n+\n+    pub fn socket(&self) -> &Socket { &self.inner }\n+\n+    pub fn socket_addr(&self) -> io::Result<SocketAddr> {\n+        sockname(|buf, len| unsafe {\n+            libc::getsockname(*self.inner.as_inner(), buf, len)\n+        })\n+    }\n+\n+    pub fn recv_from(&self, buf: &mut [u8]) -> io::Result<(usize, SocketAddr)> {\n+        let mut storage: libc::sockaddr_storage = unsafe { mem::zeroed() };\n+        let mut addrlen = mem::size_of_val(&storage) as socklen_t;\n+\n+        let n = try!(cvt(unsafe {\n+            libc::recvfrom(*self.inner.as_inner(),\n+                           buf.as_mut_ptr() as *mut c_void,\n+                           buf.len() as wrlen_t, 0,\n+                           &mut storage as *mut _ as *mut _, &mut addrlen)\n+        }));\n+        Ok((n as usize, try!(sockaddr_to_addr(&storage, addrlen as usize))))\n+    }\n+\n+    pub fn send_to(&self, buf: &[u8], dst: &SocketAddr) -> io::Result<usize> {\n+        let (dstp, dstlen) = dst.into_inner();\n+        let ret = try!(cvt(unsafe {\n+            libc::sendto(*self.inner.as_inner(),\n+                         buf.as_ptr() as *const c_void, buf.len() as wrlen_t,\n+                         0, dstp, dstlen)\n+        }));\n+        Ok(ret as usize)\n+    }\n+\n+    pub fn set_broadcast(&self, on: bool) -> io::Result<()> {\n+        setsockopt(&self.inner, libc::SOL_SOCKET, libc::SO_BROADCAST,\n+                   on as c_int)\n+    }\n+\n+    pub fn set_multicast_loop(&self, on: bool) -> io::Result<()> {\n+        setsockopt(&self.inner, libc::IPPROTO_IP,\n+                   libc::IP_MULTICAST_LOOP, on as c_int)\n+    }\n+\n+    pub fn join_multicast(&self, multi: &IpAddr) -> io::Result<()> {\n+        match *multi {\n+            IpAddr::V4(..) => {\n+                self.set_membership(multi, libc::IP_ADD_MEMBERSHIP)\n+            }\n+            IpAddr::V6(..) => {\n+                self.set_membership(multi, libc::IPV6_ADD_MEMBERSHIP)\n+            }\n+        }\n+    }\n+    pub fn leave_multicast(&self, multi: &IpAddr) -> io::Result<()> {\n+        match *multi {\n+            IpAddr::V4(..) => {\n+                self.set_membership(multi, libc::IP_DROP_MEMBERSHIP)\n+            }\n+            IpAddr::V6(..) => {\n+                self.set_membership(multi, libc::IPV6_DROP_MEMBERSHIP)\n+            }\n+        }\n+    }\n+    fn set_membership(&self, addr: &IpAddr, opt: c_int) -> io::Result<()> {\n+        match *addr {\n+            IpAddr::V4(ref addr) => {\n+                let mreq = libc::ip_mreq {\n+                    imr_multiaddr: *addr.as_inner(),\n+                    // interface == INADDR_ANY\n+                    imr_interface: libc::in_addr { s_addr: 0x0 },\n+                };\n+                setsockopt(&self.inner, libc::IPPROTO_IP, opt, mreq)\n+            }\n+            IpAddr::V6(ref addr) => {\n+                let mreq = libc::ip6_mreq {\n+                    ipv6mr_multiaddr: *addr.as_inner(),\n+                    ipv6mr_interface: 0,\n+                };\n+                setsockopt(&self.inner, libc::IPPROTO_IPV6, opt, mreq)\n+            }\n+        }\n+    }\n+\n+    pub fn multicast_time_to_live(&self, ttl: i32) -> io::Result<()> {\n+        setsockopt(&self.inner, libc::IPPROTO_IP, libc::IP_MULTICAST_TTL,\n+                   ttl as c_int)\n+    }\n+\n+    pub fn time_to_live(&self, ttl: i32) -> io::Result<()> {\n+        setsockopt(&self.inner, libc::IPPROTO_IP, libc::IP_TTL, ttl as c_int)\n+    }\n+\n+    pub fn duplicate(&self) -> io::Result<UdpSocket> {\n+        self.inner.duplicate().map(|s| UdpSocket { inner: s })\n+    }\n+}"}, {"sha": "b725b6c7e6e93f3dbb8960dbaf9b1464f0eafaba", "filename": "src/libstd/sys/common/thread.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3ef8ff1f81107b42840a695725e1a0869c163355/src%2Flibstd%2Fsys%2Fcommon%2Fthread.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ef8ff1f81107b42840a695725e1a0869c163355/src%2Flibstd%2Fsys%2Fcommon%2Fthread.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fcommon%2Fthread.rs?ref=3ef8ff1f81107b42840a695725e1a0869c163355", "patch": "@@ -12,7 +12,7 @@ use core::prelude::*;\n \n use boxed::Box;\n use mem;\n-use uint;\n+use usize;\n use libc;\n use thunk::Thunk;\n use sys_common::stack;\n@@ -25,7 +25,7 @@ use sys::{thread, stack_overflow};\n #[no_stack_check]\n pub fn start_thread(main: *mut libc::c_void) -> thread::rust_thread_return {\n     unsafe {\n-        stack::record_os_managed_stack_bounds(0, uint::MAX);\n+        stack::record_os_managed_stack_bounds(0, usize::MAX);\n         let handler = stack_overflow::Handler::new();\n         let f: Box<Thunk> = mem::transmute(main);\n         f.invoke(());"}, {"sha": "905fac07c5d5d76cc0d00cb729a43f59af0397a5", "filename": "src/libstd/sys/common/thread_local.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/3ef8ff1f81107b42840a695725e1a0869c163355/src%2Flibstd%2Fsys%2Fcommon%2Fthread_local.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ef8ff1f81107b42840a695725e1a0869c163355/src%2Flibstd%2Fsys%2Fcommon%2Fthread_local.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fcommon%2Fthread_local.rs?ref=3ef8ff1f81107b42840a695725e1a0869c163355", "patch": "@@ -84,14 +84,17 @@ use sys::thread_local as imp;\n ///     KEY.set(1 as *mut u8);\n /// }\n /// ```\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct StaticKey {\n     /// Inner static TLS key (internals), created with by `INIT_INNER` in this\n     /// module.\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub inner: StaticKeyInner,\n     /// Destructor for the TLS value.\n     ///\n     /// See `Key::new` for information about when the destructor runs and how\n     /// it runs.\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub dtor: Option<unsafe extern fn(*mut u8)>,\n }\n \n@@ -128,6 +131,7 @@ pub struct Key {\n /// Constant initialization value for static TLS keys.\n ///\n /// This value specifies no destructor by default.\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub const INIT: StaticKey = StaticKey {\n     inner: INIT_INNER,\n     dtor: None,\n@@ -136,6 +140,7 @@ pub const INIT: StaticKey = StaticKey {\n /// Constant initialization value for the inner part of static TLS keys.\n ///\n /// This value allows specific configuration of the destructor for a TLS key.\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub const INIT_INNER: StaticKeyInner = StaticKeyInner {\n     key: atomic::ATOMIC_USIZE_INIT,\n };"}, {"sha": "345808189a0ceaf2c2a1dfeb76f00eb2e75385b3", "filename": "src/libstd/sys/unix/c.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/3ef8ff1f81107b42840a695725e1a0869c163355/src%2Flibstd%2Fsys%2Funix%2Fc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ef8ff1f81107b42840a695725e1a0869c163355/src%2Flibstd%2Fsys%2Funix%2Fc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fc.rs?ref=3ef8ff1f81107b42840a695725e1a0869c163355", "patch": "@@ -157,6 +157,7 @@ extern {\n \n     pub fn utimes(filename: *const libc::c_char,\n                   times: *const libc::timeval) -> libc::c_int;\n+    pub fn gai_strerror(errcode: libc::c_int) -> *const libc::c_char;\n }\n \n #[cfg(any(target_os = \"macos\", target_os = \"ios\"))]\n@@ -179,20 +180,20 @@ mod select {\n           target_os = \"openbsd\",\n           target_os = \"linux\"))]\n mod select {\n-    use uint;\n+    use usize;\n     use libc;\n \n-    pub const FD_SETSIZE: uint = 1024;\n+    pub const FD_SETSIZE: usize = 1024;\n \n     #[repr(C)]\n     pub struct fd_set {\n         // FIXME: shouldn't this be a c_ulong?\n-        fds_bits: [libc::uintptr_t; (FD_SETSIZE / uint::BITS)]\n+        fds_bits: [libc::uintptr_t; (FD_SETSIZE / usize::BITS)]\n     }\n \n     pub fn fd_set(set: &mut fd_set, fd: i32) {\n         let fd = fd as uint;\n-        set.fds_bits[fd / uint::BITS] |= 1 << (fd % uint::BITS);\n+        set.fds_bits[fd / usize::BITS] |= 1 << (fd % usize::BITS);\n     }\n }\n "}, {"sha": "1d95f1cce7e1bd80fa8060f400ce127f72d3b8b7", "filename": "src/libstd/sys/unix/ext.rs", "status": "modified", "additions": 12, "deletions": 2, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/3ef8ff1f81107b42840a695725e1a0869c163355/src%2Flibstd%2Fsys%2Funix%2Fext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ef8ff1f81107b42840a695725e1a0869c163355/src%2Flibstd%2Fsys%2Funix%2Fext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fext.rs?ref=3ef8ff1f81107b42840a695725e1a0869c163355", "patch": "@@ -32,8 +32,8 @@\n #![unstable(feature = \"std_misc\")]\n \n use ffi::{OsStr, OsString};\n-use fs::{Permissions, OpenOptions};\n-use fs;\n+use fs::{self, Permissions, OpenOptions};\n+use net;\n use libc;\n use mem;\n use sys::os_str::Buf;\n@@ -111,6 +111,16 @@ impl AsRawFd for old_io::net::udp::UdpSocket {\n     }\n }\n \n+impl AsRawFd for net::TcpStream {\n+    fn as_raw_fd(&self) -> Fd { *self.as_inner().socket().as_inner() }\n+}\n+impl AsRawFd for net::TcpListener {\n+    fn as_raw_fd(&self) -> Fd { *self.as_inner().socket().as_inner() }\n+}\n+impl AsRawFd for net::UdpSocket {\n+    fn as_raw_fd(&self) -> Fd { *self.as_inner().socket().as_inner() }\n+}\n+\n // Unix-specific extensions to `OsString`.\n pub trait OsStringExt {\n     /// Create an `OsString` from a byte vector."}, {"sha": "327d117823ee37e1360164a678ad4a71fabb5b6b", "filename": "src/libstd/sys/unix/fd.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/3ef8ff1f81107b42840a695725e1a0869c163355/src%2Flibstd%2Fsys%2Funix%2Ffd.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ef8ff1f81107b42840a695725e1a0869c163355/src%2Flibstd%2Fsys%2Funix%2Ffd.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Ffd.rs?ref=3ef8ff1f81107b42840a695725e1a0869c163355", "patch": "@@ -15,8 +15,7 @@ use io;\n use libc::{self, c_int, size_t, c_void};\n use mem;\n use sys::cvt;\n-\n-pub type fd_t = c_int;\n+use sys_common::AsInner;\n \n pub struct FileDesc {\n     fd: c_int,\n@@ -55,6 +54,10 @@ impl FileDesc {\n     }\n }\n \n+impl AsInner<c_int> for FileDesc {\n+    fn as_inner(&self) -> &c_int { &self.fd }\n+}\n+\n impl Drop for FileDesc {\n     fn drop(&mut self) {\n         // closing stdio file handles makes no sense, so never do it. Also, note"}, {"sha": "77d5503b683674b8e89d6ed2e31abe51b18f7779", "filename": "src/libstd/sys/unix/fs2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3ef8ff1f81107b42840a695725e1a0869c163355/src%2Flibstd%2Fsys%2Funix%2Ffs2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ef8ff1f81107b42840a695725e1a0869c163355/src%2Flibstd%2Fsys%2Funix%2Ffs2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Ffs2.rs?ref=3ef8ff1f81107b42840a695725e1a0869c163355", "patch": "@@ -159,7 +159,7 @@ impl OpenOptions {\n             flags: 0,\n             read: false,\n             write: false,\n-            mode: libc::S_IRUSR | libc::S_IWUSR,\n+            mode: 0o666,\n         }\n     }\n "}, {"sha": "96a18a956c6a67d0a6f652f5758ada956dd2078c", "filename": "src/libstd/sys/unix/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3ef8ff1f81107b42840a695725e1a0869c163355/src%2Flibstd%2Fsys%2Funix%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ef8ff1f81107b42840a695725e1a0869c163355/src%2Flibstd%2Fsys%2Funix%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fmod.rs?ref=3ef8ff1f81107b42840a695725e1a0869c163355", "patch": "@@ -18,12 +18,11 @@\n use prelude::v1::*;\n \n use ffi;\n-use io::ErrorKind;\n+use io::{self, ErrorKind};\n use libc;\n use num::{Int, SignedInt};\n use num;\n use old_io::{self, IoResult, IoError};\n-use io;\n use str;\n use sys_common::mkerr_libc;\n \n@@ -47,6 +46,7 @@ pub mod fs;  // support for std::old_io\n pub mod fs2; // support for std::fs\n pub mod helper_signal;\n pub mod mutex;\n+pub mod net;\n pub mod os;\n pub mod os_str;\n pub mod pipe;"}, {"sha": "54aec7cf4b193a9b25cea06d4062969752ac5ebc", "filename": "src/libstd/sys/unix/net.rs", "status": "added", "additions": 74, "deletions": 0, "changes": 74, "blob_url": "https://github.com/rust-lang/rust/blob/3ef8ff1f81107b42840a695725e1a0869c163355/src%2Flibstd%2Fsys%2Funix%2Fnet.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ef8ff1f81107b42840a695725e1a0869c163355/src%2Flibstd%2Fsys%2Funix%2Fnet.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fnet.rs?ref=3ef8ff1f81107b42840a695725e1a0869c163355", "patch": "@@ -0,0 +1,74 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use prelude::v1::*;\n+\n+use ffi;\n+use io;\n+use libc::{self, c_int, size_t};\n+use str;\n+use sys::c;\n+use net::{SocketAddr, IpAddr};\n+use sys::fd::FileDesc;\n+use sys_common::AsInner;\n+\n+pub use sys::{cvt, cvt_r};\n+\n+pub type wrlen_t = size_t;\n+\n+pub struct Socket(FileDesc);\n+\n+pub fn init() {}\n+\n+pub fn cvt_gai(err: c_int) -> io::Result<()> {\n+    if err == 0 { return Ok(()) }\n+\n+    let detail = unsafe {\n+        str::from_utf8(ffi::c_str_to_bytes(&c::gai_strerror(err))).unwrap()\n+            .to_string()\n+    };\n+    Err(io::Error::new(io::ErrorKind::Other,\n+                       \"failed to lookup address information\", Some(detail)))\n+}\n+\n+impl Socket {\n+    pub fn new(addr: &SocketAddr, ty: c_int) -> io::Result<Socket> {\n+        let fam = match addr.ip() {\n+            IpAddr::V4(..) => libc::AF_INET,\n+            IpAddr::V6(..) => libc::AF_INET6,\n+        };\n+        unsafe {\n+            let fd = try!(cvt(libc::socket(fam, ty, 0)));\n+            Ok(Socket(FileDesc::new(fd)))\n+        }\n+    }\n+\n+    pub fn accept(&self, storage: *mut libc::sockaddr,\n+                  len: *mut libc::socklen_t) -> io::Result<Socket> {\n+        let fd = try!(cvt_r(|| unsafe {\n+            libc::accept(self.0.raw(), storage, len)\n+        }));\n+        Ok(Socket(FileDesc::new(fd)))\n+    }\n+\n+    pub fn duplicate(&self) -> io::Result<Socket> {\n+        cvt(unsafe { libc::dup(self.0.raw()) }).map(|fd| {\n+            Socket(FileDesc::new(fd))\n+        })\n+    }\n+\n+    pub fn read(&self, buf: &mut [u8]) -> io::Result<usize> {\n+        self.0.read(buf)\n+    }\n+}\n+\n+impl AsInner<c_int> for Socket {\n+    fn as_inner(&self) -> &c_int { self.0.as_inner() }\n+}"}, {"sha": "3a1b797eeb46107fe7108ef7c47f4f04328fea3b", "filename": "src/libstd/sys/windows/c.rs", "status": "modified", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/3ef8ff1f81107b42840a695725e1a0869c163355/src%2Flibstd%2Fsys%2Fwindows%2Fc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ef8ff1f81107b42840a695725e1a0869c163355/src%2Flibstd%2Fsys%2Fwindows%2Fc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fc.rs?ref=3ef8ff1f81107b42840a695725e1a0869c163355", "patch": "@@ -19,7 +19,9 @@ pub use self::FILE_INFO_BY_HANDLE_CLASS::*;\n pub use libc::consts::os::extra::{\n     FILE_ATTRIBUTE_READONLY,\n     FILE_ATTRIBUTE_DIRECTORY,\n+    WSAPROTOCOL_LEN,\n };\n+pub use libc::types::os::arch::extra::{GROUP, GUID, WSAPROTOCOLCHAIN};\n \n pub const WSADESCRIPTION_LEN: usize = 256;\n pub const WSASYS_STATUS_LEN: usize = 128;\n@@ -41,6 +43,7 @@ pub const WSA_INFINITE: libc::DWORD = libc::INFINITE;\n pub const WSA_WAIT_TIMEOUT: libc::DWORD = libc::consts::os::extra::WAIT_TIMEOUT;\n pub const WSA_WAIT_EVENT_0: libc::DWORD = libc::consts::os::extra::WAIT_OBJECT_0;\n pub const WSA_WAIT_FAILED: libc::DWORD = libc::consts::os::extra::WAIT_FAILED;\n+pub const WSAESHUTDOWN: libc::c_int = 10058;\n \n pub const ERROR_NO_MORE_FILES: libc::DWORD = 18;\n pub const TOKEN_READ: libc::DWORD = 0x20008;\n@@ -80,6 +83,33 @@ pub type LPWSANETWORKEVENTS = *mut WSANETWORKEVENTS;\n \n pub type WSAEVENT = libc::HANDLE;\n \n+#[repr(C)]\n+#[derive(Copy)]\n+pub struct WSAPROTOCOL_INFO {\n+    pub dwServiceFlags1: libc::DWORD,\n+    pub dwServiceFlags2: libc::DWORD,\n+    pub dwServiceFlags3: libc::DWORD,\n+    pub dwServiceFlags4: libc::DWORD,\n+    pub dwProviderFlags: libc::DWORD,\n+    pub ProviderId: GUID,\n+    pub dwCatalogEntryId: libc::DWORD,\n+    pub ProtocolChain: WSAPROTOCOLCHAIN,\n+    pub iVersion: libc::c_int,\n+    pub iAddressFamily: libc::c_int,\n+    pub iMaxSockAddr: libc::c_int,\n+    pub iMinSockAddr: libc::c_int,\n+    pub iSocketType: libc::c_int,\n+    pub iProtocol: libc::c_int,\n+    pub iProtocolMaxOffset: libc::c_int,\n+    pub iNetworkByteOrder: libc::c_int,\n+    pub iSecurityScheme: libc::c_int,\n+    pub dwMessageSize: libc::DWORD,\n+    pub dwProviderReserved: libc::DWORD,\n+    pub szProtocol: [u16; (WSAPROTOCOL_LEN as usize) + 1us],\n+}\n+\n+pub type LPWSAPROTOCOL_INFO = *mut WSAPROTOCOL_INFO;\n+\n #[repr(C)]\n pub struct fd_set {\n     fd_count: libc::c_uint,\n@@ -184,6 +214,7 @@ pub struct FILE_END_OF_FILE_INFO {\n extern \"system\" {\n     pub fn WSAStartup(wVersionRequested: libc::WORD,\n                       lpWSAData: LPWSADATA) -> libc::c_int;\n+    pub fn WSACleanup() -> libc::c_int;\n     pub fn WSAGetLastError() -> libc::c_int;\n     pub fn WSACloseEvent(hEvent: WSAEVENT) -> libc::BOOL;\n     pub fn WSACreateEvent() -> WSAEVENT;\n@@ -200,6 +231,17 @@ extern \"system\" {\n                                 hEventObject: WSAEVENT,\n                                 lpNetworkEvents: LPWSANETWORKEVENTS)\n                                 -> libc::c_int;\n+    pub fn WSADuplicateSocketW(s: libc::SOCKET,\n+                               dwProcessId: libc::DWORD,\n+                               lpProtocolInfo: LPWSAPROTOCOL_INFO)\n+                               -> libc::c_int;\n+    pub fn GetCurrentProcessId() -> libc::DWORD;\n+    pub fn WSASocketW(af: libc::c_int,\n+                      kind: libc::c_int,\n+                      protocol: libc::c_int,\n+                      lpProtocolInfo: LPWSAPROTOCOL_INFO,\n+                      g: GROUP,\n+                      dwFlags: libc::DWORD) -> libc::SOCKET;\n \n     pub fn ioctlsocket(s: libc::SOCKET, cmd: libc::c_long,\n                        argp: *mut libc::c_ulong) -> libc::c_int;"}, {"sha": "ac1006e653f09dc7c76c1e423e8c536f54d93a81", "filename": "src/libstd/sys/windows/ext.rs", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/3ef8ff1f81107b42840a695725e1a0869c163355/src%2Flibstd%2Fsys%2Fwindows%2Fext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ef8ff1f81107b42840a695725e1a0869c163355/src%2Flibstd%2Fsys%2Fwindows%2Fext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fext.rs?ref=3ef8ff1f81107b42840a695725e1a0869c163355", "patch": "@@ -21,6 +21,7 @@ pub use sys_common::wtf8::{Wtf8Buf, EncodeWide};\n use ffi::{OsStr, OsString};\n use fs::{self, OpenOptions};\n use libc;\n+use net;\n use sys::os_str::Buf;\n use sys_common::{AsInner, FromInner, AsInnerMut};\n \n@@ -103,6 +104,16 @@ impl AsRawSocket for old_io::net::udp::UdpSocket {\n     }\n }\n \n+impl AsRawSocket for net::TcpStream {\n+    fn as_raw_socket(&self) -> Socket { *self.as_inner().socket().as_inner() }\n+}\n+impl AsRawSocket for net::TcpListener {\n+    fn as_raw_socket(&self) -> Socket { *self.as_inner().socket().as_inner() }\n+}\n+impl AsRawSocket for net::UdpSocket {\n+    fn as_raw_socket(&self) -> Socket { *self.as_inner().socket().as_inner() }\n+}\n+\n // Windows-specific extensions to `OsString`.\n pub trait OsStringExt {\n     /// Create an `OsString` from a potentially ill-formed UTF-16 slice of 16-bit code units."}, {"sha": "0fa9aaf43235543818a8005108182723bd370297", "filename": "src/libstd/sys/windows/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/3ef8ff1f81107b42840a695725e1a0869c163355/src%2Flibstd%2Fsys%2Fwindows%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ef8ff1f81107b42840a695725e1a0869c163355/src%2Flibstd%2Fsys%2Fwindows%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fmod.rs?ref=3ef8ff1f81107b42840a695725e1a0869c163355", "patch": "@@ -43,6 +43,7 @@ pub mod fs2;\n pub mod handle;\n pub mod helper_signal;\n pub mod mutex;\n+pub mod net;\n pub mod os;\n pub mod os_str;\n pub mod pipe;"}, {"sha": "3451232f40ab89acb88de0fa53ce591dc2739cbd", "filename": "src/libstd/sys/windows/net.rs", "status": "added", "additions": 121, "deletions": 0, "changes": 121, "blob_url": "https://github.com/rust-lang/rust/blob/3ef8ff1f81107b42840a695725e1a0869c163355/src%2Flibstd%2Fsys%2Fwindows%2Fnet.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ef8ff1f81107b42840a695725e1a0869c163355/src%2Flibstd%2Fsys%2Fwindows%2Fnet.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fnet.rs?ref=3ef8ff1f81107b42840a695725e1a0869c163355", "patch": "@@ -0,0 +1,121 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use prelude::v1::*;\n+\n+use io;\n+use libc::consts::os::extra::INVALID_SOCKET;\n+use libc::{self, c_int, c_void};\n+use mem;\n+use net::{SocketAddr, IpAddr};\n+use num::{SignedInt, Int};\n+use rt;\n+use sync::{Once, ONCE_INIT};\n+use sys::c;\n+use sys_common::AsInner;\n+\n+pub type wrlen_t = i32;\n+\n+pub struct Socket(libc::SOCKET);\n+\n+pub fn init() {\n+    static START: Once = ONCE_INIT;\n+\n+    START.call_once(|| unsafe {\n+        let mut data: c::WSADATA = mem::zeroed();\n+        let ret = c::WSAStartup(0x202, // version 2.2\n+                                &mut data);\n+        assert_eq!(ret, 0);\n+\n+        rt::at_exit(|| { c::WSACleanup(); })\n+    });\n+}\n+\n+fn last_error() -> io::Error {\n+    io::Error::from_os_error(unsafe { c::WSAGetLastError() })\n+}\n+\n+pub fn cvt<T: SignedInt>(t: T) -> io::Result<T> {\n+    let one: T = Int::one();\n+    if t == -one {\n+        Err(last_error())\n+    } else {\n+        Ok(t)\n+    }\n+}\n+\n+pub fn cvt_gai(err: c_int) -> io::Result<()> {\n+    if err == 0 { return Ok(()) }\n+    cvt(err).map(|_| ())\n+}\n+\n+pub fn cvt_r<T: SignedInt, F>(mut f: F) -> io::Result<T> where F: FnMut() -> T {\n+    cvt(f())\n+}\n+\n+impl Socket {\n+    pub fn new(addr: &SocketAddr, ty: c_int) -> io::Result<Socket> {\n+        let fam = match addr.ip() {\n+            IpAddr::V4(..) => libc::AF_INET,\n+            IpAddr::V6(..) => libc::AF_INET6,\n+        };\n+        match unsafe { libc::socket(fam, ty, 0) } {\n+            INVALID_SOCKET => Err(last_error()),\n+            n => Ok(Socket(n)),\n+        }\n+    }\n+\n+    pub fn accept(&self, storage: *mut libc::sockaddr,\n+                  len: *mut libc::socklen_t) -> io::Result<Socket> {\n+        match unsafe { libc::accept(self.0, storage, len) } {\n+            INVALID_SOCKET => Err(last_error()),\n+            n => Ok(Socket(n)),\n+        }\n+    }\n+\n+    pub fn duplicate(&self) -> io::Result<Socket> {\n+        unsafe {\n+            let mut info: c::WSAPROTOCOL_INFO = mem::zeroed();\n+            try!(cvt(c::WSADuplicateSocketW(self.0,\n+                                            c::GetCurrentProcessId(),\n+                                            &mut info)));\n+            match c::WSASocketW(info.iAddressFamily,\n+                                info.iSocketType,\n+                                info.iProtocol,\n+                                &mut info, 0, 0) {\n+                INVALID_SOCKET => Err(last_error()),\n+                n => Ok(Socket(n)),\n+            }\n+        }\n+    }\n+\n+    pub fn read(&self, buf: &mut [u8]) -> io::Result<usize> {\n+        // On unix when a socket is shut down all further reads return 0, so we\n+        // do the same on windows to map a shut down socket to returning EOF.\n+        unsafe {\n+            match libc::recv(self.0, buf.as_mut_ptr() as *mut c_void,\n+                             buf.len() as i32, 0) {\n+                -1 if c::WSAGetLastError() == c::WSAESHUTDOWN => Ok(0),\n+                -1 => Err(last_error()),\n+                n => Ok(n as usize)\n+            }\n+        }\n+    }\n+}\n+\n+impl Drop for Socket {\n+    fn drop(&mut self) {\n+        unsafe { let _ = libc::closesocket(self.0); }\n+    }\n+}\n+\n+impl AsInner<libc::SOCKET> for Socket {\n+    fn as_inner(&self) -> &libc::SOCKET { &self.0 }\n+}"}, {"sha": "eab9cd84539edabde17d286b322ae743f4f2c5fe", "filename": "src/libstd/thread_local/mod.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/3ef8ff1f81107b42840a695725e1a0869c163355/src%2Flibstd%2Fthread_local%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ef8ff1f81107b42840a695725e1a0869c163355/src%2Flibstd%2Fthread_local%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fthread_local%2Fmod.rs?ref=3ef8ff1f81107b42840a695725e1a0869c163355", "patch": "@@ -335,18 +335,22 @@ mod imp {\n     use ptr;\n \n     #[doc(hidden)]\n+    #[stable(since = \"1.0.0\", feature = \"rust1\")]\n     pub struct Key<T> {\n         // Place the inner bits in an `UnsafeCell` to currently get around the\n         // \"only Sync statics\" restriction. This allows any type to be placed in\n         // the cell.\n         //\n         // Note that all access requires `T: 'static` so it can't be a type with\n         // any borrowed pointers still.\n+        #[stable(since = \"1.0.0\", feature = \"rust1\")]\n         pub inner: UnsafeCell<T>,\n \n         // Metadata to keep track of the state of the destructor. Remember that\n         // these variables are thread-local, not global.\n+        #[stable(since = \"1.0.0\", feature = \"rust1\")]\n         pub dtor_registered: UnsafeCell<bool>, // should be Cell\n+        #[stable(since = \"1.0.0\", feature = \"rust1\")]\n         pub dtor_running: UnsafeCell<bool>, // should be Cell\n     }\n \n@@ -448,6 +452,7 @@ mod imp {\n     }\n \n     #[doc(hidden)]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub unsafe extern fn destroy_value<T>(ptr: *mut u8) {\n         let ptr = ptr as *mut Key<T>;\n         // Right before we run the user destructor be sure to flag the\n@@ -468,12 +473,15 @@ mod imp {\n     use sys_common::thread_local::StaticKey as OsStaticKey;\n \n     #[doc(hidden)]\n+    #[stable(since = \"1.0.0\", feature = \"rust1\")]\n     pub struct Key<T> {\n         // Statically allocated initialization expression, using an `UnsafeCell`\n         // for the same reasons as above.\n+        #[stable(since = \"1.0.0\", feature = \"rust1\")]\n         pub inner: UnsafeCell<T>,\n \n         // OS-TLS key that we'll use to key off.\n+        #[stable(since = \"1.0.0\", feature = \"rust1\")]\n         pub os: OsStaticKey,\n     }\n \n@@ -516,6 +524,7 @@ mod imp {\n     }\n \n     #[doc(hidden)]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub unsafe extern fn destroy_value<T: 'static>(ptr: *mut u8) {\n         // The OS TLS ensures that this key contains a NULL value when this\n         // destructor starts to run. We set it back to a sentinel value of 1 to"}, {"sha": "01220e7bc1fe1d0baf0460af5dab84a342b94e4a", "filename": "src/libstd/thread_local/scoped.rs", "status": "modified", "additions": 22, "deletions": 4, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/3ef8ff1f81107b42840a695725e1a0869c163355/src%2Flibstd%2Fthread_local%2Fscoped.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ef8ff1f81107b42840a695725e1a0869c163355/src%2Flibstd%2Fthread_local%2Fscoped.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fthread_local%2Fscoped.rs?ref=3ef8ff1f81107b42840a695725e1a0869c163355", "patch": "@@ -81,6 +81,7 @@ macro_rules! __scoped_thread_local_inner {\n         #[cfg_attr(not(any(windows,\n                            target_os = \"android\",\n                            target_os = \"ios\",\n+                           target_os = \"openbsd\",\n                            target_arch = \"aarch64\")),\n                    thread_local)]\n         static $name: ::std::thread_local::scoped::Key<$t> =\n@@ -90,6 +91,7 @@ macro_rules! __scoped_thread_local_inner {\n         #[cfg_attr(not(any(windows,\n                            target_os = \"android\",\n                            target_os = \"ios\",\n+                           target_os = \"openbsd\",\n                            target_arch = \"aarch64\")),\n                    thread_local)]\n         pub static $name: ::std::thread_local::scoped::Key<$t> =\n@@ -98,14 +100,22 @@ macro_rules! __scoped_thread_local_inner {\n     ($t:ty) => ({\n         use std::thread_local::scoped::Key as __Key;\n \n-        #[cfg(not(any(windows, target_os = \"android\", target_os = \"ios\", target_arch = \"aarch64\")))]\n+        #[cfg(not(any(windows,\n+                      target_os = \"android\",\n+                      target_os = \"ios\",\n+                      target_os = \"openbsd\",\n+                      target_arch = \"aarch64\")))]\n         const _INIT: __Key<$t> = __Key {\n             inner: ::std::thread_local::scoped::__impl::KeyInner {\n                 inner: ::std::cell::UnsafeCell { value: 0 as *mut _ },\n             }\n         };\n \n-        #[cfg(any(windows, target_os = \"android\", target_os = \"ios\", target_arch = \"aarch64\"))]\n+        #[cfg(any(windows,\n+                  target_os = \"android\",\n+                  target_os = \"ios\",\n+                  target_os = \"openbsd\",\n+                  target_arch = \"aarch64\"))]\n         const _INIT: __Key<$t> = __Key {\n             inner: ::std::thread_local::scoped::__impl::KeyInner {\n                 inner: ::std::thread_local::scoped::__impl::OS_INIT,\n@@ -205,7 +215,11 @@ impl<T> Key<T> {\n     }\n }\n \n-#[cfg(not(any(windows, target_os = \"android\", target_os = \"ios\", target_arch = \"aarch64\")))]\n+#[cfg(not(any(windows,\n+              target_os = \"android\",\n+              target_os = \"ios\",\n+              target_os = \"openbsd\",\n+              target_arch = \"aarch64\")))]\n mod imp {\n     use std::cell::UnsafeCell;\n \n@@ -223,7 +237,11 @@ mod imp {\n     }\n }\n \n-#[cfg(any(windows, target_os = \"android\", target_os = \"ios\", target_arch = \"aarch64\"))]\n+#[cfg(any(windows,\n+          target_os = \"android\",\n+          target_os = \"ios\",\n+          target_os = \"openbsd\",\n+          target_arch = \"aarch64\"))]\n mod imp {\n     use marker;\n     use sys_common::thread_local::StaticKey as OsStaticKey;"}, {"sha": "5d56707c87a47b6c7b2bc9d55b3cb2ece4b5c6f6", "filename": "src/libsyntax/ext/env.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3ef8ff1f81107b42840a695725e1a0869c163355/src%2Flibsyntax%2Fext%2Fenv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ef8ff1f81107b42840a695725e1a0869c163355/src%2Flibsyntax%2Fext%2Fenv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fenv.rs?ref=3ef8ff1f81107b42840a695725e1a0869c163355", "patch": "@@ -30,7 +30,7 @@ pub fn expand_option_env<'cx>(cx: &'cx mut ExtCtxt, sp: Span, tts: &[ast::TokenT\n         Some(v) => v\n     };\n \n-    let e = match env::var_string(&var[]) {\n+    let e = match env::var(&var[]) {\n       Err(..) => {\n           cx.expr_path(cx.path_all(sp,\n                                    true,\n@@ -101,7 +101,7 @@ pub fn expand_env<'cx>(cx: &'cx mut ExtCtxt, sp: Span, tts: &[ast::TokenTree])\n         }\n     }\n \n-    let e = match env::var_string(&var[]) {\n+    let e = match env::var(&var[]) {\n         Err(_) => {\n             cx.span_err(sp, &msg);\n             cx.expr_usize(sp, 0)"}, {"sha": "ca7ae32f09ec9abd98d6af2d98852d53b23707d8", "filename": "src/libsyntax/feature_gate.rs", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/3ef8ff1f81107b42840a695725e1a0869c163355/src%2Flibsyntax%2Ffeature_gate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ef8ff1f81107b42840a695725e1a0869c163355/src%2Flibsyntax%2Ffeature_gate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffeature_gate.rs?ref=3ef8ff1f81107b42840a695725e1a0869c163355", "patch": "@@ -129,6 +129,10 @@ static KNOWN_FEATURES: &'static [(&'static str, &'static str, Status)] = &[\n \n     // Allows using `box` in patterns; RFC 469\n     (\"box_patterns\", \"1.0.0\", Active),\n+\n+    // Allows using the unsafe_no_drop_flag attribute (unlikely to\n+    // switch to Accepted; see RFC 320)\n+    (\"unsafe_no_drop_flag\", \"1.0.0\", Active),\n ];\n \n enum Status {\n@@ -477,6 +481,12 @@ impl<'a, 'v> Visitor<'v> for PostExpansionVisitor<'a> {\n             self.gate_feature(\"no_std\", attr.span,\n                               \"no_std is experimental\");\n         }\n+\n+        if attr.check_name(\"unsafe_no_drop_flag\") {\n+            self.gate_feature(\"unsafe_no_drop_flag\", attr.span,\n+                              \"unsafe_no_drop_flag has unstable semantics \\\n+                               and may be removed in the future\");\n+        }\n     }\n \n     fn visit_pat(&mut self, pattern: &ast::Pat) {"}, {"sha": "6511dffa6bf8bbc1d944785a5f54151205eba7c1", "filename": "src/libsyntax/test.rs", "status": "modified", "additions": 5, "deletions": 17, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/3ef8ff1f81107b42840a695725e1a0869c163355/src%2Flibsyntax%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ef8ff1f81107b42840a695725e1a0869c163355/src%2Flibsyntax%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ftest.rs?ref=3ef8ff1f81107b42840a695725e1a0869c163355", "patch": "@@ -436,40 +436,28 @@ fn mk_main(cx: &mut TestCtxt) -> P<ast::Item> {\n     let sp = ignored_span(cx, DUMMY_SP);\n     let ecx = &cx.ext_cx;\n \n-    // std::slice::AsSlice\n-    let as_slice_path = ecx.path(sp, vec![token::str_to_ident(\"std\"),\n-                                          token::str_to_ident(\"slice\"),\n-                                          token::str_to_ident(\"AsSlice\")]);\n     // test::test_main_static\n     let test_main_path = ecx.path(sp, vec![token::str_to_ident(\"test\"),\n                                            token::str_to_ident(\"test_main_static\")]);\n-    // ::std::os::args\n+    // ::std::env::args\n     let os_args_path = ecx.path_global(sp, vec![token::str_to_ident(\"std\"),\n-                                                token::str_to_ident(\"os\"),\n+                                                token::str_to_ident(\"env\"),\n                                                 token::str_to_ident(\"args\")]);\n-    // use std::slice::AsSlice\n-    let as_slice_path = P(nospan(ast::ViewPathSimple(token::str_to_ident(\"AsSlice\"),\n-                                                     as_slice_path)));\n-    let use_as_slice = ecx.item_use(sp, ast::Inherited, as_slice_path);\n-    let use_as_slice = ecx.stmt_item(sp, use_as_slice);\n-    // ::std::os::args()\n+    // ::std::env::args()\n     let os_args_path_expr = ecx.expr_path(os_args_path);\n     let call_os_args = ecx.expr_call(sp, os_args_path_expr, vec![]);\n-    // ::std::os::args().as_slice()\n-    let call_as_slice = ecx.expr_method_call(sp, call_os_args,\n-                                             token::str_to_ident(\"as_slice\"), vec![]);\n     // test::test_main_static(...)\n     let test_main_path_expr = ecx.expr_path(test_main_path);\n     let tests_ident_expr = ecx.expr_ident(sp, token::str_to_ident(\"TESTS\"));\n     let call_test_main = ecx.expr_call(sp, test_main_path_expr,\n-                                       vec![call_as_slice, tests_ident_expr]);\n+                                       vec![call_os_args, tests_ident_expr]);\n     let call_test_main = ecx.stmt_expr(call_test_main);\n     // #![main]\n     let main_meta = ecx.meta_word(sp, token::intern_and_get_ident(\"main\"));\n     let main_attr = ecx.attribute(sp, main_meta);\n     // pub fn main() { ... }\n     let main_ret_ty = ecx.ty(sp, ast::TyTup(vec![]));\n-    let main_body = ecx.block_all(sp, vec![use_as_slice, call_test_main], None);\n+    let main_body = ecx.block_all(sp, vec![call_test_main], None);\n     let main = ast::ItemFn(ecx.fn_decl(vec![], main_ret_ty),\n                            ast::Unsafety::Normal, ::abi::Rust, empty_generics(), main_body);\n     let main = P(ast::Item {"}, {"sha": "1bb038603c39cc3fa592d38ed2bffe50af5d15a4", "filename": "src/libterm/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/3ef8ff1f81107b42840a695725e1a0869c163355/src%2Flibterm%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ef8ff1f81107b42840a695725e1a0869c163355/src%2Flibterm%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibterm%2Flib.rs?ref=3ef8ff1f81107b42840a695725e1a0869c163355", "patch": "@@ -50,6 +50,7 @@\n        html_playground_url = \"http://play.rust-lang.org/\")]\n #![deny(missing_docs)]\n \n+#![feature(core)]\n #![feature(box_syntax)]\n #![feature(collections)]\n #![feature(int_uint)]"}, {"sha": "758191a6e1107e8566dfe16d205bfe7f32491504", "filename": "src/libterm/terminfo/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3ef8ff1f81107b42840a695725e1a0869c163355/src%2Flibterm%2Fterminfo%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ef8ff1f81107b42840a695725e1a0869c163355/src%2Flibterm%2Fterminfo%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibterm%2Fterminfo%2Fmod.rs?ref=3ef8ff1f81107b42840a695725e1a0869c163355", "patch": "@@ -172,7 +172,7 @@ impl<T: Writer+Send> TerminfoTerminal<T> {\n     /// Returns `None` whenever the terminal cannot be created for some\n     /// reason.\n     pub fn new(out: T) -> Option<Box<Terminal<T>+Send+'static>> {\n-        let term = match env::var_string(\"TERM\") {\n+        let term = match env::var(\"TERM\") {\n             Ok(t) => t,\n             Err(..) => {\n                 debug!(\"TERM environment variable not defined\");\n@@ -182,7 +182,7 @@ impl<T: Writer+Send> TerminfoTerminal<T> {\n \n         let entry = open(&term[]);\n         if entry.is_err() {\n-            if env::var_string(\"MSYSCON\").ok().map_or(false, |s| {\n+            if env::var(\"MSYSCON\").ok().map_or(false, |s| {\n                     \"mintty.exe\" == s\n                 }) {\n                 // msys terminal"}, {"sha": "fd6e6a843e1f3581586160c02ce402f8706ce781", "filename": "src/libterm/terminfo/searcher.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3ef8ff1f81107b42840a695725e1a0869c163355/src%2Flibterm%2Fterminfo%2Fsearcher.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ef8ff1f81107b42840a695725e1a0869c163355/src%2Flibterm%2Fterminfo%2Fsearcher.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibterm%2Fterminfo%2Fsearcher.rs?ref=3ef8ff1f81107b42840a695725e1a0869c163355", "patch": "@@ -28,14 +28,14 @@ pub fn get_dbpath_for_term(term: &str) -> Option<Box<Path>> {\n     let first_char = term.char_at(0);\n \n     // Find search directory\n-    match env::var_string(\"TERMINFO\") {\n+    match env::var(\"TERMINFO\") {\n         Ok(dir) => dirs_to_search.push(Path::new(dir)),\n         Err(..) => {\n             if homedir.is_some() {\n                 // ncurses compatibility;\n                 dirs_to_search.push(homedir.unwrap().join(\".terminfo\"))\n             }\n-            match env::var_string(\"TERMINFO_DIRS\") {\n+            match env::var(\"TERMINFO_DIRS\") {\n                 Ok(dirs) => for i in dirs.split(':') {\n                     if i == \"\" {\n                         dirs_to_search.push(Path::new(\"/usr/share/terminfo\"));"}, {"sha": "cc468df87f3834fdd70a9432b4f38397db151fd3", "filename": "src/libtest/lib.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/3ef8ff1f81107b42840a695725e1a0869c163355/src%2Flibtest%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ef8ff1f81107b42840a695725e1a0869c163355/src%2Flibtest%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibtest%2Flib.rs?ref=3ef8ff1f81107b42840a695725e1a0869c163355", "patch": "@@ -265,15 +265,16 @@ pub fn test_main(args: &[String], tests: Vec<TestDescAndFn> ) {\n // a ~[TestDescAndFn] is used in order to effect ownership-transfer\n // semantics into parallel test runners, which in turn requires a ~[]\n // rather than a &[].\n-pub fn test_main_static(args: &[String], tests: &[TestDescAndFn]) {\n+pub fn test_main_static(args: env::Args, tests: &[TestDescAndFn]) {\n+    let args = args.collect::<Vec<_>>();\n     let owned_tests = tests.iter().map(|t| {\n         match t.testfn {\n             StaticTestFn(f) => TestDescAndFn { testfn: StaticTestFn(f), desc: t.desc.clone() },\n             StaticBenchFn(f) => TestDescAndFn { testfn: StaticBenchFn(f), desc: t.desc.clone() },\n             _ => panic!(\"non-static tests passed to test::test_main_static\")\n         }\n     }).collect();\n-    test_main(args, owned_tests)\n+    test_main(&args, owned_tests)\n }\n \n #[derive(Copy)]\n@@ -385,7 +386,7 @@ pub fn parse_opts(args: &[String]) -> Option<OptRes> {\n \n     let mut nocapture = matches.opt_present(\"nocapture\");\n     if !nocapture {\n-        nocapture = env::var(\"RUST_TEST_NOCAPTURE\").is_some();\n+        nocapture = env::var(\"RUST_TEST_NOCAPTURE\").is_ok();\n     }\n \n     let color = match matches.opt_str(\"color\").as_ref().map(|s| &**s) {\n@@ -811,7 +812,7 @@ fn run_tests<F>(opts: &TestOpts,\n \n fn get_concurrency() -> uint {\n     use std::rt;\n-    match env::var_string(\"RUST_TEST_TASKS\") {\n+    match env::var(\"RUST_TEST_TASKS\") {\n         Ok(s) => {\n             let opt_n: Option<uint> = s.parse().ok();\n             match opt_n {"}, {"sha": "a21deb44fcc834e7023a866f042686fb1f40f40a", "filename": "src/test/auxiliary/issue-10028.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3ef8ff1f81107b42840a695725e1a0869c163355/src%2Ftest%2Fauxiliary%2Fissue-10028.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ef8ff1f81107b42840a695725e1a0869c163355/src%2Ftest%2Fauxiliary%2Fissue-10028.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fissue-10028.rs?ref=3ef8ff1f81107b42840a695725e1a0869c163355", "patch": "@@ -8,6 +8,8 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+#![feature(unsafe_no_drop_flag)]\n+\n #[unsafe_no_drop_flag]\n pub struct ZeroLengthThingWithDestructor;\n impl Drop for ZeroLengthThingWithDestructor {"}, {"sha": "9ee3fcee0235557da422bec01305fb010d843112", "filename": "src/test/compile-fail/feature-gate-simd-ffi.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3ef8ff1f81107b42840a695725e1a0869c163355/src%2Ftest%2Fcompile-fail%2Ffeature-gate-simd-ffi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ef8ff1f81107b42840a695725e1a0869c163355/src%2Ftest%2Fcompile-fail%2Ffeature-gate-simd-ffi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ffeature-gate-simd-ffi.rs?ref=3ef8ff1f81107b42840a695725e1a0869c163355", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#![feature(simd)]\n+#![feature(simd, core)]\n #![allow(dead_code)]\n \n use std::simd::f32x4;"}, {"sha": "5c187176fb2ae9c1654724b13432eedf6639ee89", "filename": "src/test/compile-fail/lint-stability.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3ef8ff1f81107b42840a695725e1a0869c163355/src%2Ftest%2Fcompile-fail%2Flint-stability.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ef8ff1f81107b42840a695725e1a0869c163355/src%2Ftest%2Fcompile-fail%2Flint-stability.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Flint-stability.rs?ref=3ef8ff1f81107b42840a695725e1a0869c163355", "patch": "@@ -98,12 +98,10 @@ mod cross_crate {\n         // Eventually, we will want to lint the contents of the\n         // macro in the module *defining* it. Also, stability levels\n         // on macros themselves are not yet linted.\n-        macro_test!();\n         macro_test_arg!(deprecated_text()); //~ ERROR use of deprecated item: text\n         macro_test_arg!(deprecated_unstable_text()); //~ ERROR use of deprecated item: text\n         //~^ WARNING use of unstable library feature\n         macro_test_arg!(macro_test_arg!(deprecated_text())); //~ ERROR use of deprecated item: text\n-        macro_test_arg_nested!(deprecated_text);\n     }\n \n     fn test_method_param<F: Trait>(foo: F) {\n@@ -139,7 +137,7 @@ mod cross_crate {\n \n mod inheritance {\n     extern crate inherited_stability; //~ WARNING: use of unstable library feature\n-    use self::inherited_stability::*;\n+    use self::inherited_stability::*; //~ WARNING: use of unstable library feature\n \n     fn test_inheritance() {\n         unstable(); //~ WARNING use of unstable library feature"}, {"sha": "d2ec00d649506605ba54d4f3995f6fccae39d2db", "filename": "src/test/compile-fail/lint-stability2.rs", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/3ef8ff1f81107b42840a695725e1a0869c163355/src%2Ftest%2Fcompile-fail%2Flint-stability2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ef8ff1f81107b42840a695725e1a0869c163355/src%2Ftest%2Fcompile-fail%2Flint-stability2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Flint-stability2.rs?ref=3ef8ff1f81107b42840a695725e1a0869c163355", "patch": "@@ -0,0 +1,23 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// aux-build:lint_stability.rs\n+// error-pattern: use of deprecated item\n+\n+#![deny(deprecated)]\n+\n+#[macro_use]\n+extern crate lint_stability;\n+\n+use lint_stability::*;\n+\n+fn main() {\n+    macro_test!();\n+}"}, {"sha": "88a93134b47c0f427b63e0bd39c5f2675c849521", "filename": "src/test/compile-fail/lint-stability3.rs", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/3ef8ff1f81107b42840a695725e1a0869c163355/src%2Ftest%2Fcompile-fail%2Flint-stability3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ef8ff1f81107b42840a695725e1a0869c163355/src%2Ftest%2Fcompile-fail%2Flint-stability3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Flint-stability3.rs?ref=3ef8ff1f81107b42840a695725e1a0869c163355", "patch": "@@ -0,0 +1,25 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// aux-build:lint_stability.rs\n+// error-pattern: use of deprecated item\n+\n+#![deny(deprecated)]\n+#![allow(warnings)]\n+\n+#[macro_use]\n+extern crate lint_stability;\n+\n+use lint_stability::*;\n+\n+fn main() {\n+    macro_test_arg_nested!(deprecated_text);\n+}\n+"}, {"sha": "216fcf9353578a594c00febb75c97bca216daee9", "filename": "src/test/compile-fail/lint-unexported-no-mangle.rs", "status": "modified", "additions": 16, "deletions": 1, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/3ef8ff1f81107b42840a695725e1a0869c163355/src%2Ftest%2Fcompile-fail%2Flint-unexported-no-mangle.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ef8ff1f81107b42840a695725e1a0869c163355/src%2Ftest%2Fcompile-fail%2Flint-unexported-no-mangle.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Flint-unexported-no-mangle.rs?ref=3ef8ff1f81107b42840a695725e1a0869c163355", "patch": "@@ -8,17 +8,32 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// compile-flags:-F private_no_mangle_fns\n+// compile-flags:-F private_no_mangle_fns -F no_mangle_const_items -F private_no_mangle_statics\n \n // FIXME(#19495) no_mangle'ing main ICE's.\n #[no_mangle]\n fn foo() { //~ ERROR function foo is marked #[no_mangle], but not exported\n }\n \n+#[allow(dead_code)]\n+#[no_mangle]\n+const FOO: u64 = 1; //~ ERROR const items should never be #[no_mangle]\n+\n+#[no_mangle]\n+pub const PUB_FOO: u64 = 1; //~ ERROR const items should never be #[no_mangle]\n+\n #[no_mangle]\n pub fn bar()  {\n }\n \n+#[no_mangle]\n+pub static BAR: u64 = 1;\n+\n+#[allow(dead_code)]\n+#[no_mangle]\n+static PRIVATE_BAR: u64 = 1; //~ ERROR static PRIVATE_BAR is marked #[no_mangle], but not exported\n+\n+\n fn main() {\n     foo();\n     bar();"}, {"sha": "e9b3ceff83de44814f138573876319998986093f", "filename": "src/test/compile-fail/macro-reexport-undef.rs", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/3ef8ff1f81107b42840a695725e1a0869c163355/src%2Ftest%2Fcompile-fail%2Fmacro-reexport-undef.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ef8ff1f81107b42840a695725e1a0869c163355/src%2Ftest%2Fcompile-fail%2Fmacro-reexport-undef.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmacro-reexport-undef.rs?ref=3ef8ff1f81107b42840a695725e1a0869c163355", "patch": "@@ -0,0 +1,20 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// aux-build:two_macros.rs\n+// ignore-stage1\n+\n+#[macro_use(macro_two)]\n+#[macro_reexport(no_way)] //~ ERROR reexported macro not found\n+extern crate two_macros;\n+\n+pub fn main() {\n+    macro_two!();\n+}"}, {"sha": "a5a350bd30e1ad7b256e21036a973a1168ef1bd6", "filename": "src/test/compile-fail/macro-use-undef.rs", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/3ef8ff1f81107b42840a695725e1a0869c163355/src%2Ftest%2Fcompile-fail%2Fmacro-use-undef.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ef8ff1f81107b42840a695725e1a0869c163355/src%2Ftest%2Fcompile-fail%2Fmacro-use-undef.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmacro-use-undef.rs?ref=3ef8ff1f81107b42840a695725e1a0869c163355", "patch": "@@ -0,0 +1,19 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// aux-build:two_macros.rs\n+// ignore-stage1\n+\n+#[macro_use(macro_two, no_way)] //~ ERROR imported macro not found\n+extern crate two_macros;\n+\n+pub fn main() {\n+    macro_two!();\n+}"}, {"sha": "f55a2cc3bb158758462e3131fbbf7e21ccc7e60e", "filename": "src/test/run-make/empty-file/Makefile", "status": "removed", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/e29f42025513374f1a88404491d1b40386acf994/src%2Ftest%2Frun-make%2Fempty-file%2FMakefile", "raw_url": "https://github.com/rust-lang/rust/raw/e29f42025513374f1a88404491d1b40386acf994/src%2Ftest%2Frun-make%2Fempty-file%2FMakefile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fempty-file%2FMakefile?ref=e29f42025513374f1a88404491d1b40386acf994", "patch": "@@ -1,5 +0,0 @@\n--include ../tools.mk\n-\n-all:\n-\t$(RUSTC) --emit=asm,llvm-bc,llvm-ir,obj,dep-info empty.rs\n-\t$(RUSTC) --emit=link --crate-type=rlib,dylib,staticlib empty.rs"}, {"sha": "e69de29bb2d1d6434b8b29ae775ad8c2e48c5391", "filename": "src/test/run-make/empty-file/empty.rs", "status": "removed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/e29f42025513374f1a88404491d1b40386acf994/src%2Ftest%2Frun-make%2Fempty-file%2Fempty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e29f42025513374f1a88404491d1b40386acf994/src%2Ftest%2Frun-make%2Fempty-file%2Fempty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fempty-file%2Fempty.rs?ref=e29f42025513374f1a88404491d1b40386acf994"}, {"sha": "bd799917842b124881ebc58b2c95fd5b1c66a5b9", "filename": "src/test/run-pass/attr-no-drop-flag-size.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/3ef8ff1f81107b42840a695725e1a0869c163355/src%2Ftest%2Frun-pass%2Fattr-no-drop-flag-size.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ef8ff1f81107b42840a695725e1a0869c163355/src%2Ftest%2Frun-pass%2Fattr-no-drop-flag-size.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fattr-no-drop-flag-size.rs?ref=3ef8ff1f81107b42840a695725e1a0869c163355", "patch": "@@ -9,6 +9,7 @@\n // except according to those terms.\n \n #![feature(unsafe_destructor)]\n+#![feature(unsafe_no_drop_flag)]\n \n use std::mem::size_of;\n "}, {"sha": "659e5b3a8c2f8a93a5e4c23c655d2a89bf67b893", "filename": "src/test/run-pass/env-vars.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3ef8ff1f81107b42840a695725e1a0869c163355/src%2Ftest%2Frun-pass%2Fenv-vars.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ef8ff1f81107b42840a695725e1a0869c163355/src%2Ftest%2Frun-pass%2Fenv-vars.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fenv-vars.rs?ref=3ef8ff1f81107b42840a695725e1a0869c163355", "patch": "@@ -11,8 +11,8 @@\n use std::env::*;\n \n fn main() {\n-    for (k, v) in vars() {\n-        let v2 = var(&k);\n+    for (k, v) in vars_os() {\n+        let v2 = var_os(&k);\n         // MingW seems to set some funky environment variables like\n         // \"=C:=C:\\MinGW\\msys\\1.0\\bin\" and \"!::=::\\\" that are returned\n         // from vars() but not visible from var()."}, {"sha": "a6af2327c9e8096f73cea2876aadb63e41742a2f", "filename": "src/test/run-pass/issue-10734.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3ef8ff1f81107b42840a695725e1a0869c163355/src%2Ftest%2Frun-pass%2Fissue-10734.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ef8ff1f81107b42840a695725e1a0869c163355/src%2Ftest%2Frun-pass%2Fissue-10734.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-10734.rs?ref=3ef8ff1f81107b42840a695725e1a0869c163355", "patch": "@@ -8,6 +8,8 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+#![feature(unsafe_no_drop_flag)]\n+\n static mut drop_count: uint = 0;\n \n #[unsafe_no_drop_flag]"}, {"sha": "79034a4a4a6d65590e8980a10fd2c16eda2a03a6", "filename": "src/test/run-pass/issue-20343.rs", "status": "added", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/3ef8ff1f81107b42840a695725e1a0869c163355/src%2Ftest%2Frun-pass%2Fissue-20343.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ef8ff1f81107b42840a695725e1a0869c163355/src%2Ftest%2Frun-pass%2Fissue-20343.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-20343.rs?ref=3ef8ff1f81107b42840a695725e1a0869c163355", "patch": "@@ -0,0 +1,38 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Regression test for Issue #20343.\n+\n+#![deny(dead_code)]\n+\n+struct B { b: u32 }\n+struct C;\n+struct D;\n+\n+trait T<A> {}\n+impl<A> T<A> for () {}\n+\n+impl B {\n+    // test for unused code in arguments\n+    fn foo(B { b }: B) -> u32 { b }\n+\n+    // test for unused code in return type\n+    fn bar() -> C { unsafe { ::std::mem::transmute(()) } }\n+\n+    // test for unused code in generics\n+    fn baz<A: T<D>>() {}\n+}\n+\n+pub fn main() {\n+    let b = B { b: 3 };\n+    B::foo(b);\n+    B::bar();\n+    B::baz::<()>();\n+}"}, {"sha": "c06a29c09f78eeda9eb6e5354c243976f48a03f3", "filename": "src/test/run-pass/issue-22036.rs", "status": "added", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/3ef8ff1f81107b42840a695725e1a0869c163355/src%2Ftest%2Frun-pass%2Fissue-22036.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ef8ff1f81107b42840a695725e1a0869c163355/src%2Ftest%2Frun-pass%2Fissue-22036.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-22036.rs?ref=3ef8ff1f81107b42840a695725e1a0869c163355", "patch": "@@ -0,0 +1,33 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+trait DigitCollection: Sized {\n+    type Iter: Iterator<Item = u8>;\n+    fn digit_iter(self) -> Self::Iter;\n+\n+    fn digit_sum(self) -> u32 {\n+        self.digit_iter()\n+            .map(|digit: u8| digit as u32)\n+            .fold(0, |sum, digit| sum + digit)\n+    }\n+}\n+\n+impl<I> DigitCollection for I where I: Iterator<Item=u8> {\n+    type Iter = I;\n+\n+    fn digit_iter(self) -> I {\n+        self\n+    }\n+}\n+\n+fn main() {\n+    let xs = vec![1u8, 2, 3, 4, 5];\n+    assert_eq!(xs.into_iter().digit_sum(), 15);\n+}"}, {"sha": "f4d03a5cda400aa603017f7d5d7b22daab2e97a2", "filename": "src/test/run-pass/zero-size-type-destructors.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3ef8ff1f81107b42840a695725e1a0869c163355/src%2Ftest%2Frun-pass%2Fzero-size-type-destructors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ef8ff1f81107b42840a695725e1a0869c163355/src%2Ftest%2Frun-pass%2Fzero-size-type-destructors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fzero-size-type-destructors.rs?ref=3ef8ff1f81107b42840a695725e1a0869c163355", "patch": "@@ -8,6 +8,8 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+#![feature(unsafe_no_drop_flag)]\n+\n static mut destructions : int = 3;\n \n pub fn foo() {"}]}