{"sha": "6a18b6865590704d42777fa7432436e55773d46b", "node_id": "C_kwDOAAsO6NoAKDZhMThiNjg2NTU5MDcwNGQ0Mjc3N2ZhNzQzMjQzNmU1NTc3M2Q0NmI", "commit": {"author": {"name": "Will Crichton", "email": "wcrichto@cs.stanford.edu", "date": "2022-04-12T18:05:07Z"}, "committer": {"name": "Will Crichton", "email": "wcrichto@cs.stanford.edu", "date": "2022-04-12T18:05:07Z"}, "message": "Add Rustdoc book link to scrape examples help. Remove remaining panic\nlocations in scrape examples.", "tree": {"sha": "2153ac5b6a1bcb7ecc5056bfb4732c08cd2573a5", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2153ac5b6a1bcb7ecc5056bfb4732c08cd2573a5"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6a18b6865590704d42777fa7432436e55773d46b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6a18b6865590704d42777fa7432436e55773d46b", "html_url": "https://github.com/rust-lang/rust/commit/6a18b6865590704d42777fa7432436e55773d46b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6a18b6865590704d42777fa7432436e55773d46b/comments", "author": {"login": "willcrichton", "id": 663326, "node_id": "MDQ6VXNlcjY2MzMyNg==", "avatar_url": "https://avatars.githubusercontent.com/u/663326?v=4", "gravatar_id": "", "url": "https://api.github.com/users/willcrichton", "html_url": "https://github.com/willcrichton", "followers_url": "https://api.github.com/users/willcrichton/followers", "following_url": "https://api.github.com/users/willcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/willcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/willcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/willcrichton/subscriptions", "organizations_url": "https://api.github.com/users/willcrichton/orgs", "repos_url": "https://api.github.com/users/willcrichton/repos", "events_url": "https://api.github.com/users/willcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/willcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "willcrichton", "id": 663326, "node_id": "MDQ6VXNlcjY2MzMyNg==", "avatar_url": "https://avatars.githubusercontent.com/u/663326?v=4", "gravatar_id": "", "url": "https://api.github.com/users/willcrichton", "html_url": "https://github.com/willcrichton", "followers_url": "https://api.github.com/users/willcrichton/followers", "following_url": "https://api.github.com/users/willcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/willcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/willcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/willcrichton/subscriptions", "organizations_url": "https://api.github.com/users/willcrichton/orgs", "repos_url": "https://api.github.com/users/willcrichton/repos", "events_url": "https://api.github.com/users/willcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/willcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b9ecdca0d5543cbb3c40042305ae315bf3454c60", "url": "https://api.github.com/repos/rust-lang/rust/commits/b9ecdca0d5543cbb3c40042305ae315bf3454c60", "html_url": "https://github.com/rust-lang/rust/commit/b9ecdca0d5543cbb3c40042305ae315bf3454c60"}], "stats": {"total": 73, "additions": 51, "deletions": 22}, "files": [{"sha": "4825ddc5a2034cf95f51458dfb797aae6f3f4937", "filename": "src/librustdoc/html/render/mod.rs", "status": "modified", "additions": 9, "deletions": 3, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/6a18b6865590704d42777fa7432436e55773d46b/src%2Flibrustdoc%2Fhtml%2Frender%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a18b6865590704d42777fa7432436e55773d46b/src%2Flibrustdoc%2Fhtml%2Frender%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender%2Fmod.rs?ref=6a18b6865590704d42777fa7432436e55773d46b", "patch": "@@ -79,6 +79,7 @@ use crate::html::sources;\n use crate::html::static_files::SCRAPE_EXAMPLES_HELP_MD;\n use crate::scrape_examples::{CallData, CallLocation};\n use crate::try_none;\n+use crate::DOC_RUST_LANG_ORG_CHANNEL;\n \n /// A pair of name and its optional document.\n crate type NameDoc = (String, Option<String>);\n@@ -463,17 +464,22 @@ fn settings(root_path: &str, suffix: &str, theme_names: Vec<String>) -> Result<S\n }\n \n fn scrape_examples_help(shared: &SharedContext<'_>) -> String {\n-    let content = SCRAPE_EXAMPLES_HELP_MD;\n+    let mut content = SCRAPE_EXAMPLES_HELP_MD.to_owned();\n+    content.push_str(&format!(\n+      \"## More information\\n\\n\\\n+      If you want more information about this feature, please read the [corresponding chapter in the Rustdoc book]({}/rustdoc/scraped-examples.html).\",\n+      DOC_RUST_LANG_ORG_CHANNEL));\n+\n     let mut ids = IdMap::default();\n     format!(\n-        \"<div class=\\\"main-heading\\\">\n+        \"<div class=\\\"main-heading\\\">\\\n             <h1 class=\\\"fqn\\\">\\\n                 <span class=\\\"in-band\\\">About scraped examples</span>\\\n             </h1>\\\n         </div>\\\n         <div>{}</div>\",\n         Markdown {\n-            content,\n+            content: &content,\n             links: &[],\n             ids: &mut ids,\n             error_codes: shared.codes,"}, {"sha": "0da490f3cd6c8a3b14b9662f09eacff2978c2395", "filename": "src/librustdoc/scrape_examples.rs", "status": "modified", "additions": 42, "deletions": 19, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/6a18b6865590704d42777fa7432436e55773d46b/src%2Flibrustdoc%2Fscrape_examples.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a18b6865590704d42777fa7432436e55773d46b/src%2Flibrustdoc%2Fscrape_examples.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fscrape_examples.rs?ref=6a18b6865590704d42777fa7432436e55773d46b", "patch": "@@ -71,14 +71,14 @@ crate struct SyntaxRange {\n }\n \n impl SyntaxRange {\n-    fn new(span: rustc_span::Span, file: &SourceFile) -> Self {\n+    fn new(span: rustc_span::Span, file: &SourceFile) -> Option<Self> {\n         let get_pos = |bytepos: BytePos| file.original_relative_byte_pos(bytepos).0;\n-        let get_line = |bytepos: BytePos| file.lookup_line(bytepos).unwrap();\n+        let get_line = |bytepos: BytePos| file.lookup_line(bytepos);\n \n-        SyntaxRange {\n+        Some(SyntaxRange {\n             byte_span: (get_pos(span.lo()), get_pos(span.hi())),\n-            line_span: (get_line(span.lo()), get_line(span.hi())),\n-        }\n+            line_span: (get_line(span.lo())?, get_line(span.hi())?),\n+        })\n     }\n }\n \n@@ -95,12 +95,12 @@ impl CallLocation {\n         ident_span: rustc_span::Span,\n         enclosing_item_span: rustc_span::Span,\n         source_file: &SourceFile,\n-    ) -> Self {\n-        CallLocation {\n-            call_expr: SyntaxRange::new(expr_span, source_file),\n-            call_ident: SyntaxRange::new(ident_span, source_file),\n-            enclosing_item: SyntaxRange::new(enclosing_item_span, source_file),\n-        }\n+    ) -> Option<Self> {\n+        Some(CallLocation {\n+            call_expr: SyntaxRange::new(expr_span, source_file)?,\n+            call_ident: SyntaxRange::new(ident_span, source_file)?,\n+            enclosing_item: SyntaxRange::new(enclosing_item_span, source_file)?,\n+        })\n     }\n }\n \n@@ -178,7 +178,7 @@ where\n         // If this span comes from a macro expansion, then the source code may not actually show\n         // a use of the given item, so it would be a poor example. Hence, we skip all uses in macros.\n         if call_span.from_expansion() {\n-            trace!(\"Rejecting expr from macro: {:?}\", call_span);\n+            trace!(\"Rejecting expr from macro: {call_span:?}\");\n             return;\n         }\n \n@@ -188,7 +188,7 @@ where\n             .hir()\n             .span_with_body(tcx.hir().local_def_id_to_hir_id(tcx.hir().get_parent_item(ex.hir_id)));\n         if enclosing_item_span.from_expansion() {\n-            trace!(\"Rejecting expr ({:?}) from macro item: {:?}\", call_span, enclosing_item_span);\n+            trace!(\"Rejecting expr ({call_span:?}) from macro item: {enclosing_item_span:?}\");\n             return;\n         }\n \n@@ -224,11 +224,27 @@ where\n             };\n \n             if let Some(file_path) = file_path {\n-                let abs_path = fs::canonicalize(file_path.clone()).unwrap();\n+                let abs_path = match fs::canonicalize(file_path.clone()) {\n+                    Ok(abs_path) => abs_path,\n+                    Err(_) => {\n+                        trace!(\"Could not canonicalize file path: {}\", file_path.display());\n+                        return;\n+                    }\n+                };\n+\n                 let cx = &self.cx;\n+                let clean_span = crate::clean::types::Span::new(call_span);\n+                let url = match cx.href_from_span(clean_span, false) {\n+                    Some(url) => url,\n+                    None => {\n+                        trace!(\n+                            \"Rejecting expr ({call_span:?}) whose clean span ({clean_span:?}) cannot be turned into a link\"\n+                        );\n+                        return;\n+                    }\n+                };\n+\n                 let mk_call_data = || {\n-                    let clean_span = crate::clean::types::Span::new(call_span);\n-                    let url = cx.href_from_span(clean_span, false).unwrap();\n                     let display_name = file_path.display().to_string();\n                     let edition = call_span.edition();\n                     CallData { locations: Vec::new(), url, display_name, edition }\n@@ -240,7 +256,14 @@ where\n                 trace!(\"Including expr: {:?}\", call_span);\n                 let enclosing_item_span =\n                     source_map.span_extend_to_prev_char(enclosing_item_span, '\\n', false);\n-                let location = CallLocation::new(call_span, ident_span, enclosing_item_span, &file);\n+                let location =\n+                    match CallLocation::new(call_span, ident_span, enclosing_item_span, &file) {\n+                        Some(location) => location,\n+                        None => {\n+                            trace!(\"Could not get serializable call location for {call_span:?}\");\n+                            return;\n+                        }\n+                    };\n                 fn_entries.entry(abs_path).or_insert_with(mk_call_data).locations.push(location);\n             }\n         }\n@@ -274,8 +297,8 @@ crate fn run(\n             .map(|(crate_num, _)| **crate_num)\n             .collect::<Vec<_>>();\n \n-        debug!(\"All crates in TyCtxt: {:?}\", all_crates);\n-        debug!(\"Scrape examples target_crates: {:?}\", target_crates);\n+        debug!(\"All crates in TyCtxt: {all_crates:?}\");\n+        debug!(\"Scrape examples target_crates: {target_crates:?}\");\n \n         // Run call-finder on all items\n         let mut calls = FxHashMap::default();"}]}