{"sha": "b97dc20784698730bd7bc1a20eabdcd32066d174", "node_id": "C_kwDOAAsO6NoAKGI5N2RjMjA3ODQ2OTg3MzBiZDdiYzFhMjBlYWJkY2QzMjA2NmQxNzQ", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-03-08T10:24:46Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-03-08T10:24:46Z"}, "message": "Auto merge of #94734 - matthiaskrgr:rollup-28shqhy, r=matthiaskrgr\n\nRollup of 8 pull requests\n\nSuccessful merges:\n\n - #91993 (Tweak output for non-exhaustive `match` expression)\n - #92385 (Add Result::{ok, err, and, or, unwrap_or} as const)\n - #94559 (Remove argument from closure in thread::Scope::spawn.)\n - #94580 (Emit `unused_attributes` if a level attr only has a reason)\n - #94586 (Generalize `get_nullable_type` to allow types where null is all-ones.)\n - #94708 (diagnostics: only talk about `Cargo.toml` if running under Cargo)\n - #94712 (promot debug_assert to assert)\n - #94726 (:arrow_up: rust-analyzer)\n\nFailed merges:\n\nr? `@ghost`\n`@rustbot` modify labels: rollup", "tree": {"sha": "411126fa7c5a4a0cd31761dcfadbfefa6fc6174a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/411126fa7c5a4a0cd31761dcfadbfefa6fc6174a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b97dc20784698730bd7bc1a20eabdcd32066d174", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b97dc20784698730bd7bc1a20eabdcd32066d174", "html_url": "https://github.com/rust-lang/rust/commit/b97dc20784698730bd7bc1a20eabdcd32066d174", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b97dc20784698730bd7bc1a20eabdcd32066d174/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d2710dbb305a4447b889f11918bc5df96084357c", "url": "https://api.github.com/repos/rust-lang/rust/commits/d2710dbb305a4447b889f11918bc5df96084357c", "html_url": "https://github.com/rust-lang/rust/commit/d2710dbb305a4447b889f11918bc5df96084357c"}, {"sha": "b879216f079eb5a9f47fab8d59b567859b51fd2c", "url": "https://api.github.com/repos/rust-lang/rust/commits/b879216f079eb5a9f47fab8d59b567859b51fd2c", "html_url": "https://github.com/rust-lang/rust/commit/b879216f079eb5a9f47fab8d59b567859b51fd2c"}], "stats": {"total": 3878, "additions": 2785, "deletions": 1093}, "files": [{"sha": "39ebd57b4b296decfddd85a1874c3efe8559b399", "filename": "compiler/rustc_errors/src/diagnostic.rs", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/b97dc20784698730bd7bc1a20eabdcd32066d174/compiler%2Frustc_errors%2Fsrc%2Fdiagnostic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b97dc20784698730bd7bc1a20eabdcd32066d174/compiler%2Frustc_errors%2Fsrc%2Fdiagnostic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_errors%2Fsrc%2Fdiagnostic.rs?ref=b97dc20784698730bd7bc1a20eabdcd32066d174", "patch": "@@ -7,6 +7,7 @@ use crate::SuggestionStyle;\n use crate::ToolMetadata;\n use rustc_lint_defs::Applicability;\n use rustc_serialize::json::Json;\n+use rustc_span::edition::LATEST_STABLE_EDITION;\n use rustc_span::{MultiSpan, Span, DUMMY_SP};\n use std::fmt;\n use std::hash::{Hash, Hasher};\n@@ -342,6 +343,18 @@ impl Diagnostic {\n         self\n     }\n \n+    /// Help the user upgrade to the latest edition.\n+    /// This is factored out to make sure it does the right thing with `Cargo.toml`.\n+    pub fn help_use_latest_edition(&mut self) -> &mut Self {\n+        if std::env::var_os(\"CARGO\").is_some() {\n+            self.help(&format!(\"set `edition = \\\"{}\\\"` in `Cargo.toml`\", LATEST_STABLE_EDITION));\n+        } else {\n+            self.help(&format!(\"pass `--edition {}` to `rustc`\", LATEST_STABLE_EDITION));\n+        }\n+        self.note(\"for more on editions, read https://doc.rust-lang.org/edition-guide\");\n+        self\n+    }\n+\n     /// Disallow attaching suggestions this diagnostic.\n     /// Any suggestions attached e.g. with the `span_suggestion_*` methods\n     /// (before and after the call to `disable_suggestions`) will be ignored."}, {"sha": "98b8b2a569edde1bfb6f4f5e1261cb3e2e99087b", "filename": "compiler/rustc_errors/src/diagnostic_builder.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/b97dc20784698730bd7bc1a20eabdcd32066d174/compiler%2Frustc_errors%2Fsrc%2Fdiagnostic_builder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b97dc20784698730bd7bc1a20eabdcd32066d174/compiler%2Frustc_errors%2Fsrc%2Fdiagnostic_builder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_errors%2Fsrc%2Fdiagnostic_builder.rs?ref=b97dc20784698730bd7bc1a20eabdcd32066d174", "patch": "@@ -409,6 +409,7 @@ impl<'a, G: EmissionGuarantee> DiagnosticBuilder<'a, G> {\n         sp: impl Into<MultiSpan>,\n         msg: &str,\n     ) -> &mut Self);\n+    forward!(pub fn help_use_latest_edition(&mut self,) -> &mut Self);\n     forward!(pub fn set_is_lint(&mut self,) -> &mut Self);\n \n     forward!(pub fn disable_suggestions(&mut self,) -> &mut Self);"}, {"sha": "bb51f880099a6da051c93216125f4cb7c50fc497", "filename": "compiler/rustc_feature/src/builtin_attrs.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b97dc20784698730bd7bc1a20eabdcd32066d174/compiler%2Frustc_feature%2Fsrc%2Fbuiltin_attrs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b97dc20784698730bd7bc1a20eabdcd32066d174/compiler%2Frustc_feature%2Fsrc%2Fbuiltin_attrs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_feature%2Fsrc%2Fbuiltin_attrs.rs?ref=b97dc20784698730bd7bc1a20eabdcd32066d174", "patch": "@@ -606,17 +606,17 @@ pub const BUILTIN_ATTRIBUTES: &[BuiltinAttribute] = &[\n     rustc_attr!(\n         rustc_layout_scalar_valid_range_start, Normal, template!(List: \"value\"), ErrorFollowing,\n         \"the `#[rustc_layout_scalar_valid_range_start]` attribute is just used to enable \\\n-        niche optimizations in libcore and will never be stable\",\n+        niche optimizations in libcore and libstd and will never be stable\",\n     ),\n     rustc_attr!(\n         rustc_layout_scalar_valid_range_end, Normal, template!(List: \"value\"), ErrorFollowing,\n         \"the `#[rustc_layout_scalar_valid_range_end]` attribute is just used to enable \\\n-        niche optimizations in libcore and will never be stable\",\n+        niche optimizations in libcore and libstd and will never be stable\",\n     ),\n     rustc_attr!(\n         rustc_nonnull_optimization_guaranteed, Normal, template!(Word), WarnFollowing,\n         \"the `#[rustc_nonnull_optimization_guaranteed]` attribute is just used to enable \\\n-        niche optimizations in libcore and will never be stable\",\n+        niche optimizations in libcore and libstd and will never be stable\",\n     ),\n \n     // =========================================================================="}, {"sha": "bbfbf61f4869abefe4f17b0b76755001ddad8324", "filename": "compiler/rustc_lint/src/levels.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b97dc20784698730bd7bc1a20eabdcd32066d174/compiler%2Frustc_lint%2Fsrc%2Flevels.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b97dc20784698730bd7bc1a20eabdcd32066d174/compiler%2Frustc_lint%2Fsrc%2Flevels.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Flevels.rs?ref=b97dc20784698730bd7bc1a20eabdcd32066d174", "patch": "@@ -258,7 +258,7 @@ impl<'s> LintLevelsBuilder<'s> {\n             };\n \n             if metas.is_empty() {\n-                // FIXME (#55112): issue unused-attributes lint for `#[level()]`\n+                // This emits the unused_attributes lint for `#[level()]`\n                 continue;\n             }\n \n@@ -271,8 +271,6 @@ impl<'s> LintLevelsBuilder<'s> {\n                     ast::MetaItemKind::Word => {} // actual lint names handled later\n                     ast::MetaItemKind::NameValue(ref name_value) => {\n                         if item.path == sym::reason {\n-                            // FIXME (#55112): issue unused-attributes lint if we thereby\n-                            // don't have any lint names (`#[level(reason = \"foo\")]`)\n                             if let ast::LitKind::Str(rationale, _) = name_value.kind {\n                                 if !self.sess.features_untracked().lint_reasons {\n                                     feature_err("}, {"sha": "d4dac640cc7e189d71de027375b15d318f2c8516", "filename": "compiler/rustc_lint/src/types.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b97dc20784698730bd7bc1a20eabdcd32066d174/compiler%2Frustc_lint%2Fsrc%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b97dc20784698730bd7bc1a20eabdcd32066d174/compiler%2Frustc_lint%2Fsrc%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Ftypes.rs?ref=b97dc20784698730bd7bc1a20eabdcd32066d174", "patch": "@@ -795,7 +795,9 @@ crate fn repr_nullable_ptr<'tcx>(\n         let field_ty_abi = &cx.layout_of(field_ty).unwrap().abi;\n         if let Abi::Scalar(field_ty_scalar) = field_ty_abi {\n             match (field_ty_scalar.valid_range.start, field_ty_scalar.valid_range.end) {\n-                (0, _) => unreachable!(\"Non-null optimisation extended to a non-zero value.\"),\n+                (0, x) if x == field_ty_scalar.value.size(&cx.tcx).unsigned_int_max() - 1 => {\n+                    return Some(get_nullable_type(cx, field_ty).unwrap());\n+                }\n                 (1, _) => {\n                     return Some(get_nullable_type(cx, field_ty).unwrap());\n                 }"}, {"sha": "b80d2e52ee709cabe32710b81b38ecbad2294d33", "filename": "compiler/rustc_mir_build/src/thir/pattern/check_match.rs", "status": "modified", "additions": 123, "deletions": 20, "changes": 143, "blob_url": "https://github.com/rust-lang/rust/blob/b97dc20784698730bd7bc1a20eabdcd32066d174/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fcheck_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b97dc20784698730bd7bc1a20eabdcd32066d174/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fcheck_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fcheck_match.rs?ref=b97dc20784698730bd7bc1a20eabdcd32066d174", "patch": "@@ -20,7 +20,7 @@ use rustc_session::lint::builtin::{\n };\n use rustc_session::Session;\n use rustc_span::source_map::Spanned;\n-use rustc_span::{DesugaringKind, ExpnKind, Span};\n+use rustc_span::{DesugaringKind, ExpnKind, MultiSpan, Span};\n \n crate fn check_match(tcx: TyCtxt<'_>, def_id: DefId) {\n     let body_id = match def_id.as_local() {\n@@ -64,7 +64,9 @@ impl<'tcx> Visitor<'tcx> for MatchVisitor<'_, '_, 'tcx> {\n     fn visit_expr(&mut self, ex: &'tcx hir::Expr<'tcx>) {\n         intravisit::walk_expr(self, ex);\n         match &ex.kind {\n-            hir::ExprKind::Match(scrut, arms, source) => self.check_match(scrut, arms, *source),\n+            hir::ExprKind::Match(scrut, arms, source) => {\n+                self.check_match(scrut, arms, *source, ex.span)\n+            }\n             hir::ExprKind::Let(hir::Let { pat, init, span, .. }) => {\n                 self.check_let(pat, init, *span)\n             }\n@@ -163,6 +165,7 @@ impl<'p, 'tcx> MatchVisitor<'_, 'p, 'tcx> {\n         scrut: &hir::Expr<'_>,\n         hir_arms: &'tcx [hir::Arm<'tcx>],\n         source: hir::MatchSource,\n+        expr_span: Span,\n     ) {\n         let mut cx = self.new_cx(scrut.hir_id);\n \n@@ -208,15 +211,14 @@ impl<'p, 'tcx> MatchVisitor<'_, 'p, 'tcx> {\n         }\n \n         // Check if the match is exhaustive.\n-        let is_empty_match = arms.is_empty();\n         let witnesses = report.non_exhaustiveness_witnesses;\n         if !witnesses.is_empty() {\n             if source == hir::MatchSource::ForLoopDesugar && hir_arms.len() == 2 {\n                 // the for loop pattern is not irrefutable\n                 let pat = hir_arms[1].pat.for_loop_some().unwrap();\n                 self.check_irrefutable(pat, \"`for` loop binding\", None);\n             } else {\n-                non_exhaustive_match(&cx, scrut_ty, scrut.span, witnesses, is_empty_match);\n+                non_exhaustive_match(&cx, scrut_ty, scrut.span, witnesses, hir_arms, expr_span);\n             }\n         }\n     }\n@@ -334,7 +336,7 @@ fn check_for_bindings_named_same_as_variants(\n                     let ty_path = cx.tcx.def_path_str(edef.did);\n                     let mut err = lint.build(&format!(\n                         \"pattern binding `{}` is named the same as one \\\n-                                        of the variants of the type `{}`\",\n+                         of the variants of the type `{}`\",\n                         ident, ty_path\n                     ));\n                     err.code(error_code!(E0170));\n@@ -494,21 +496,26 @@ fn non_exhaustive_match<'p, 'tcx>(\n     scrut_ty: Ty<'tcx>,\n     sp: Span,\n     witnesses: Vec<DeconstructedPat<'p, 'tcx>>,\n-    is_empty_match: bool,\n+    arms: &[hir::Arm<'tcx>],\n+    expr_span: Span,\n ) {\n+    let is_empty_match = arms.is_empty();\n     let non_empty_enum = match scrut_ty.kind() {\n         ty::Adt(def, _) => def.is_enum() && !def.variants.is_empty(),\n         _ => false,\n     };\n     // In the case of an empty match, replace the '`_` not covered' diagnostic with something more\n     // informative.\n     let mut err;\n+    let pattern;\n+    let mut patterns_len = 0;\n     if is_empty_match && !non_empty_enum {\n         err = create_e0004(\n             cx.tcx.sess,\n             sp,\n             format!(\"non-exhaustive patterns: type `{}` is non-empty\", scrut_ty),\n         );\n+        pattern = \"_\".to_string();\n     } else {\n         let joined_patterns = joined_uncovered_patterns(cx, &witnesses);\n         err = create_e0004(\n@@ -517,6 +524,16 @@ fn non_exhaustive_match<'p, 'tcx>(\n             format!(\"non-exhaustive patterns: {} not covered\", joined_patterns),\n         );\n         err.span_label(sp, pattern_not_covered_label(&witnesses, &joined_patterns));\n+        patterns_len = witnesses.len();\n+        pattern = if witnesses.len() < 4 {\n+            witnesses\n+                .iter()\n+                .map(|witness| witness.to_pat(cx).to_string())\n+                .collect::<Vec<String>>()\n+                .join(\" | \")\n+        } else {\n+            \"_\".to_string()\n+        };\n     };\n \n     let is_variant_list_non_exhaustive = match scrut_ty.kind() {\n@@ -525,10 +542,6 @@ fn non_exhaustive_match<'p, 'tcx>(\n     };\n \n     adt_defined_here(cx, &mut err, scrut_ty, &witnesses);\n-    err.help(\n-        \"ensure that all possible cases are being handled, \\\n-              possibly by adding wildcards or more match arms\",\n-    );\n     err.note(&format!(\n         \"the matched value is of type `{}`{}\",\n         scrut_ty,\n@@ -540,14 +553,14 @@ fn non_exhaustive_match<'p, 'tcx>(\n         && matches!(witnesses[0].ctor(), Constructor::NonExhaustive)\n     {\n         err.note(&format!(\n-            \"`{}` does not have a fixed maximum value, \\\n-                so a wildcard `_` is necessary to match exhaustively\",\n+            \"`{}` does not have a fixed maximum value, so a wildcard `_` is necessary to match \\\n+             exhaustively\",\n             scrut_ty,\n         ));\n         if cx.tcx.sess.is_nightly_build() {\n             err.help(&format!(\n-                \"add `#![feature(precise_pointer_size_matching)]` \\\n-                    to the crate attributes to enable precise `{}` matching\",\n+                \"add `#![feature(precise_pointer_size_matching)]` to the crate attributes to \\\n+                 enable precise `{}` matching\",\n                 scrut_ty,\n             ));\n         }\n@@ -557,6 +570,84 @@ fn non_exhaustive_match<'p, 'tcx>(\n             err.note(\"references are always considered inhabited\");\n         }\n     }\n+\n+    let mut suggestion = None;\n+    let sm = cx.tcx.sess.source_map();\n+    match arms {\n+        [] if sp.ctxt() == expr_span.ctxt() => {\n+            // Get the span for the empty match body `{}`.\n+            let (indentation, more) = if let Some(snippet) = sm.indentation_before(sp) {\n+                (format!(\"\\n{}\", snippet), \"    \")\n+            } else {\n+                (\" \".to_string(), \"\")\n+            };\n+            suggestion = Some((\n+                sp.shrink_to_hi().with_hi(expr_span.hi()),\n+                format!(\n+                    \" {{{indentation}{more}{pattern} => todo!(),{indentation}}}\",\n+                    indentation = indentation,\n+                    more = more,\n+                    pattern = pattern,\n+                ),\n+            ));\n+        }\n+        [only] => {\n+            let pre_indentation = if let (Some(snippet), true) = (\n+                sm.indentation_before(only.span),\n+                sm.is_multiline(sp.shrink_to_hi().with_hi(only.span.lo())),\n+            ) {\n+                format!(\"\\n{}\", snippet)\n+            } else {\n+                \" \".to_string()\n+            };\n+            let comma = if matches!(only.body.kind, hir::ExprKind::Block(..)) { \"\" } else { \",\" };\n+            suggestion = Some((\n+                only.span.shrink_to_hi(),\n+                format!(\"{}{}{} => todo!()\", comma, pre_indentation, pattern),\n+            ));\n+        }\n+        [.., prev, last] if prev.span.ctxt() == last.span.ctxt() => {\n+            if let Ok(snippet) = sm.span_to_snippet(prev.span.between(last.span)) {\n+                let comma =\n+                    if matches!(last.body.kind, hir::ExprKind::Block(..)) { \"\" } else { \",\" };\n+                suggestion = Some((\n+                    last.span.shrink_to_hi(),\n+                    format!(\n+                        \"{}{}{} => todo!()\",\n+                        comma,\n+                        snippet.strip_prefix(\",\").unwrap_or(&snippet),\n+                        pattern\n+                    ),\n+                ));\n+            }\n+        }\n+        _ => {}\n+    }\n+\n+    let msg = format!(\n+        \"ensure that all possible cases are being handled by adding a match arm with a wildcard \\\n+         pattern{}{}\",\n+        if patterns_len > 1 && patterns_len < 4 && suggestion.is_some() {\n+            \", a match arm with multiple or-patterns\"\n+        } else {\n+            // we are either not suggesting anything, or suggesting `_`\n+            \"\"\n+        },\n+        match patterns_len {\n+            // non-exhaustive enum case\n+            0 if suggestion.is_some() => \" as shown\",\n+            0 => \"\",\n+            1 if suggestion.is_some() => \" or an explicit pattern as shown\",\n+            1 => \" or an explicit pattern\",\n+            _ if suggestion.is_some() => \" as shown, or multiple match arms\",\n+            _ => \" or multiple match arms\",\n+        },\n+    );\n+    if let Some((span, sugg)) = suggestion {\n+        err.span_suggestion_verbose(span, &msg, sugg, Applicability::HasPlaceholders);\n+    } else {\n+        err.help(&msg);\n+    }\n     err.emit();\n }\n \n@@ -597,15 +688,27 @@ fn adt_defined_here<'p, 'tcx>(\n ) {\n     let ty = ty.peel_refs();\n     if let ty::Adt(def, _) = ty.kind() {\n-        if let Some(sp) = cx.tcx.hir().span_if_local(def.did) {\n-            err.span_label(sp, format!(\"`{}` defined here\", ty));\n-        }\n-\n-        if witnesses.len() < 4 {\n+        let mut spans = vec![];\n+        if witnesses.len() < 5 {\n             for sp in maybe_point_at_variant(cx, def, witnesses.iter()) {\n-                err.span_label(sp, \"not covered\");\n+                spans.push(sp);\n             }\n         }\n+        let def_span = cx\n+            .tcx\n+            .hir()\n+            .get_if_local(def.did)\n+            .and_then(|node| node.ident())\n+            .map(|ident| ident.span)\n+            .unwrap_or_else(|| cx.tcx.def_span(def.did));\n+        let mut span: MultiSpan =\n+            if spans.is_empty() { def_span.into() } else { spans.clone().into() };\n+\n+        span.push_span_label(def_span, String::new());\n+        for pat in spans {\n+            span.push_span_label(pat, \"not covered\".to_string());\n+        }\n+        err.span_note(span, &format!(\"`{}` defined here\", ty));\n     }\n }\n "}, {"sha": "b993d48c995b4748ec20c05d3a1b148215e8b108", "filename": "compiler/rustc_parse/src/parser/expr.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b97dc20784698730bd7bc1a20eabdcd32066d174/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b97dc20784698730bd7bc1a20eabdcd32066d174/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fexpr.rs?ref=b97dc20784698730bd7bc1a20eabdcd32066d174", "patch": "@@ -20,7 +20,6 @@ use rustc_ast_pretty::pprust;\n use rustc_errors::{Applicability, Diagnostic, DiagnosticBuilder, ErrorGuaranteed, PResult};\n use rustc_session::lint::builtin::BREAK_WITH_LABEL_AND_LOOP;\n use rustc_session::lint::BuiltinLintDiagnostics;\n-use rustc_span::edition::LATEST_STABLE_EDITION;\n use rustc_span::source_map::{self, Span, Spanned};\n use rustc_span::symbol::{kw, sym, Ident, Symbol};\n use rustc_span::{BytePos, Pos};\n@@ -2712,8 +2711,7 @@ impl<'a> Parser<'a> {\n         let mut async_block_err = |e: &mut Diagnostic, span: Span| {\n             recover_async = true;\n             e.span_label(span, \"`async` blocks are only allowed in Rust 2018 or later\");\n-            e.help(&format!(\"set `edition = \\\"{}\\\"` in `Cargo.toml`\", LATEST_STABLE_EDITION));\n-            e.note(\"for more on editions, read https://doc.rust-lang.org/edition-guide\");\n+            e.help_use_latest_edition();\n         };\n \n         while self.token != token::CloseDelim(close_delim) {"}, {"sha": "06460c7b1b31ddcc8e21ec89ff01fe4bdbfb2c00", "filename": "compiler/rustc_parse/src/parser/item.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/b97dc20784698730bd7bc1a20eabdcd32066d174/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fitem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b97dc20784698730bd7bc1a20eabdcd32066d174/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fitem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fitem.rs?ref=b97dc20784698730bd7bc1a20eabdcd32066d174", "patch": "@@ -14,7 +14,7 @@ use rustc_ast::{FnHeader, ForeignItem, Path, PathSegment, Visibility, Visibility\n use rustc_ast::{MacArgs, MacCall, MacDelimiter};\n use rustc_ast_pretty::pprust;\n use rustc_errors::{struct_span_err, Applicability, PResult, StashKey};\n-use rustc_span::edition::{Edition, LATEST_STABLE_EDITION};\n+use rustc_span::edition::Edition;\n use rustc_span::lev_distance::lev_distance;\n use rustc_span::source_map::{self, Span};\n use rustc_span::symbol::{kw, sym, Ident, Symbol};\n@@ -2102,8 +2102,7 @@ impl<'a> Parser<'a> {\n             let diag = self.diagnostic();\n             struct_span_err!(diag, span, E0670, \"`async fn` is not permitted in Rust 2015\")\n                 .span_label(span, \"to use `async fn`, switch to Rust 2018 or later\")\n-                .help(&format!(\"set `edition = \\\"{}\\\"` in `Cargo.toml`\", LATEST_STABLE_EDITION))\n-                .note(\"for more on editions, read https://doc.rust-lang.org/edition-guide\")\n+                .help_use_latest_edition()\n                 .emit();\n         }\n     }"}, {"sha": "2202001555084523b9afc39c584b15447409a7b8", "filename": "compiler/rustc_passes/src/check_attr.rs", "status": "modified", "additions": 51, "deletions": 29, "changes": 80, "blob_url": "https://github.com/rust-lang/rust/blob/b97dc20784698730bd7bc1a20eabdcd32066d174/compiler%2Frustc_passes%2Fsrc%2Fcheck_attr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b97dc20784698730bd7bc1a20eabdcd32066d174/compiler%2Frustc_passes%2Fsrc%2Fcheck_attr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_passes%2Fsrc%2Fcheck_attr.rs?ref=b97dc20784698730bd7bc1a20eabdcd32066d174", "patch": "@@ -4,7 +4,7 @@\n //! conflicts between multiple such attributes attached to the same\n //! item.\n \n-use rustc_ast::{ast, AttrStyle, Attribute, Lit, LitKind, NestedMetaItem};\n+use rustc_ast::{ast, AttrStyle, Attribute, Lit, LitKind, MetaItemKind, NestedMetaItem};\n use rustc_data_structures::fx::FxHashMap;\n use rustc_errors::{pluralize, struct_span_err, Applicability};\n use rustc_feature::{AttributeDuplicates, AttributeType, BuiltinAttribute, BUILTIN_ATTRIBUTE_MAP};\n@@ -178,34 +178,7 @@ impl CheckAttrVisitor<'_> {\n                 check_duplicates(self.tcx, attr, hir_id, *duplicates, &mut seen);\n             }\n \n-            // Warn on useless empty attributes.\n-            if matches!(\n-                attr.name_or_empty(),\n-                sym::macro_use\n-                    | sym::allow\n-                    | sym::warn\n-                    | sym::deny\n-                    | sym::forbid\n-                    | sym::feature\n-                    | sym::repr\n-                    | sym::target_feature\n-            ) && attr.meta_item_list().map_or(false, |list| list.is_empty())\n-            {\n-                self.tcx.struct_span_lint_hir(UNUSED_ATTRIBUTES, hir_id, attr.span, |lint| {\n-                    lint.build(\"unused attribute\")\n-                        .span_suggestion(\n-                            attr.span,\n-                            \"remove this attribute\",\n-                            String::new(),\n-                            Applicability::MachineApplicable,\n-                        )\n-                        .note(&format!(\n-                            \"attribute `{}` with an empty list has no effect\",\n-                            attr.name_or_empty()\n-                        ))\n-                        .emit();\n-                });\n-            }\n+            self.check_unused_attribute(hir_id, attr)\n         }\n \n         if !is_valid {\n@@ -1969,6 +1942,55 @@ impl CheckAttrVisitor<'_> {\n             });\n         }\n     }\n+\n+    fn check_unused_attribute(&self, hir_id: HirId, attr: &Attribute) {\n+        // Warn on useless empty attributes.\n+        let note = if matches!(\n+            attr.name_or_empty(),\n+            sym::macro_use\n+                | sym::allow\n+                | sym::expect\n+                | sym::warn\n+                | sym::deny\n+                | sym::forbid\n+                | sym::feature\n+                | sym::repr\n+                | sym::target_feature\n+        ) && attr.meta_item_list().map_or(false, |list| list.is_empty())\n+        {\n+            format!(\n+                \"attribute `{}` with an empty list has no effect\",\n+                attr.name_or_empty()\n+            )\n+        } else if matches!(\n+                attr.name_or_empty(),\n+                sym::allow | sym::warn | sym::deny | sym::forbid | sym::expect\n+            ) && let Some(meta) = attr.meta_item_list()\n+            && meta.len() == 1\n+            && let Some(item) = meta[0].meta_item()\n+            && let MetaItemKind::NameValue(_) = &item.kind\n+            && item.path == sym::reason\n+        {\n+            format!(\n+                \"attribute `{}` without any lints has no effect\",\n+                attr.name_or_empty()\n+            )\n+        } else {\n+            return;\n+        };\n+\n+        self.tcx.struct_span_lint_hir(UNUSED_ATTRIBUTES, hir_id, attr.span, |lint| {\n+            lint.build(\"unused attribute\")\n+                .span_suggestion(\n+                    attr.span,\n+                    \"remove this attribute\",\n+                    String::new(),\n+                    Applicability::MachineApplicable,\n+                )\n+                .note(&note)\n+                .emit();\n+        });\n+    }\n }\n \n impl<'tcx> Visitor<'tcx> for CheckAttrVisitor<'tcx> {"}, {"sha": "7e7104f62fdc67588d58a2b91cf844d982422644", "filename": "compiler/rustc_typeck/src/check/expr.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b97dc20784698730bd7bc1a20eabdcd32066d174/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b97dc20784698730bd7bc1a20eabdcd32066d174/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fexpr.rs?ref=b97dc20784698730bd7bc1a20eabdcd32066d174", "patch": "@@ -43,7 +43,6 @@ use rustc_middle::ty::error::TypeError::{FieldMisMatch, Sorts};\n use rustc_middle::ty::subst::SubstsRef;\n use rustc_middle::ty::{self, AdtKind, Ty, TypeFoldable};\n use rustc_session::parse::feature_err;\n-use rustc_span::edition::LATEST_STABLE_EDITION;\n use rustc_span::hygiene::DesugaringKind;\n use rustc_span::lev_distance::find_best_match_for_name;\n use rustc_span::source_map::Span;\n@@ -2010,8 +2009,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             // We know by construction that `<expr>.await` is either on Rust 2015\n             // or results in `ExprKind::Await`. Suggest switching the edition to 2018.\n             err.note(\"to `.await` a `Future`, switch to Rust 2018 or later\");\n-            err.help(&format!(\"set `edition = \\\"{}\\\"` in `Cargo.toml`\", LATEST_STABLE_EDITION));\n-            err.note(\"for more on editions, read https://doc.rust-lang.org/edition-guide\");\n+            err.help_use_latest_edition();\n         }\n \n         err.emit();"}, {"sha": "1827860a39045cba2b82b2db56fb5a3142bc8db3", "filename": "library/core/src/result.rs", "status": "modified", "additions": 45, "deletions": 10, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/b97dc20784698730bd7bc1a20eabdcd32066d174/library%2Fcore%2Fsrc%2Fresult.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b97dc20784698730bd7bc1a20eabdcd32066d174/library%2Fcore%2Fsrc%2Fresult.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fresult.rs?ref=b97dc20784698730bd7bc1a20eabdcd32066d174", "patch": "@@ -632,10 +632,16 @@ impl<T, E> Result<T, E> {\n     /// ```\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn ok(self) -> Option<T> {\n+    #[rustc_const_unstable(feature = \"const_result_drop\", issue = \"92384\")]\n+    pub const fn ok(self) -> Option<T>\n+    where\n+        E: ~const Drop,\n+    {\n         match self {\n             Ok(x) => Some(x),\n-            Err(_) => None,\n+            // FIXME: ~const Drop doesn't quite work right yet\n+            #[allow(unused_variables)]\n+            Err(x) => None,\n         }\n     }\n \n@@ -657,9 +663,15 @@ impl<T, E> Result<T, E> {\n     /// ```\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn err(self) -> Option<E> {\n+    #[rustc_const_unstable(feature = \"const_result_drop\", issue = \"92384\")]\n+    pub const fn err(self) -> Option<E>\n+    where\n+        T: ~const Drop,\n+    {\n         match self {\n-            Ok(_) => None,\n+            // FIXME: ~const Drop doesn't quite work right yet\n+            #[allow(unused_variables)]\n+            Ok(x) => None,\n             Err(x) => Some(x),\n         }\n     }\n@@ -1266,10 +1278,18 @@ impl<T, E> Result<T, E> {\n     /// assert_eq!(x.and(y), Ok(\"different result type\"));\n     /// ```\n     #[inline]\n+    #[rustc_const_unstable(feature = \"const_result_drop\", issue = \"92384\")]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn and<U>(self, res: Result<U, E>) -> Result<U, E> {\n+    pub const fn and<U>(self, res: Result<U, E>) -> Result<U, E>\n+    where\n+        T: ~const Drop,\n+        U: ~const Drop,\n+        E: ~const Drop,\n+    {\n         match self {\n-            Ok(_) => res,\n+            // FIXME: ~const Drop doesn't quite work right yet\n+            #[allow(unused_variables)]\n+            Ok(x) => res,\n             Err(e) => Err(e),\n         }\n     }\n@@ -1343,11 +1363,19 @@ impl<T, E> Result<T, E> {\n     /// assert_eq!(x.or(y), Ok(2));\n     /// ```\n     #[inline]\n+    #[rustc_const_unstable(feature = \"const_result_drop\", issue = \"92384\")]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn or<F>(self, res: Result<T, F>) -> Result<T, F> {\n+    pub const fn or<F>(self, res: Result<T, F>) -> Result<T, F>\n+    where\n+        T: ~const Drop,\n+        E: ~const Drop,\n+        F: ~const Drop,\n+    {\n         match self {\n             Ok(v) => Ok(v),\n-            Err(_) => res,\n+            // FIXME: ~const Drop doesn't quite work right yet\n+            #[allow(unused_variables)]\n+            Err(e) => res,\n         }\n     }\n \n@@ -1399,11 +1427,18 @@ impl<T, E> Result<T, E> {\n     /// assert_eq!(x.unwrap_or(default), default);\n     /// ```\n     #[inline]\n+    #[rustc_const_unstable(feature = \"const_result_drop\", issue = \"92384\")]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn unwrap_or(self, default: T) -> T {\n+    pub const fn unwrap_or(self, default: T) -> T\n+    where\n+        T: ~const Drop,\n+        E: ~const Drop,\n+    {\n         match self {\n             Ok(t) => t,\n-            Err(_) => default,\n+            // FIXME: ~const Drop doesn't quite work right yet\n+            #[allow(unused_variables)]\n+            Err(e) => default,\n         }\n     }\n "}, {"sha": "2da04ab2cea7d4d78d1f9e517cd35a821b3ab87e", "filename": "library/core/src/sync/atomic.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b97dc20784698730bd7bc1a20eabdcd32066d174/library%2Fcore%2Fsrc%2Fsync%2Fatomic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b97dc20784698730bd7bc1a20eabdcd32066d174/library%2Fcore%2Fsrc%2Fsync%2Fatomic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fsync%2Fatomic.rs?ref=b97dc20784698730bd7bc1a20eabdcd32066d174", "patch": "@@ -352,7 +352,7 @@ impl AtomicBool {\n     /// let a = &*AtomicBool::from_mut_slice(&mut some_bools);\n     /// std::thread::scope(|s| {\n     ///     for i in 0..a.len() {\n-    ///         s.spawn(move |_| a[i].store(true, Ordering::Relaxed));\n+    ///         s.spawn(move || a[i].store(true, Ordering::Relaxed));\n     ///     }\n     /// });\n     /// assert_eq!(some_bools, [true; 10]);\n@@ -984,7 +984,7 @@ impl<T> AtomicPtr<T> {\n     /// let a = &*AtomicPtr::from_mut_slice(&mut some_ptrs);\n     /// std::thread::scope(|s| {\n     ///     for i in 0..a.len() {\n-    ///         s.spawn(move |_| {\n+    ///         s.spawn(move || {\n     ///             let name = Box::new(format!(\"thread{i}\"));\n     ///             a[i].store(Box::into_raw(name), Ordering::Relaxed);\n     ///         });\n@@ -1533,7 +1533,7 @@ macro_rules! atomic_int {\n             #[doc = concat!(\"let a = &*\", stringify!($atomic_type), \"::from_mut_slice(&mut some_ints);\")]\n             /// std::thread::scope(|s| {\n             ///     for i in 0..a.len() {\n-            ///         s.spawn(move |_| a[i].store(i as _, Ordering::Relaxed));\n+            ///         s.spawn(move || a[i].store(i as _, Ordering::Relaxed));\n             ///     }\n             /// });\n             /// for (i, n) in some_ints.into_iter().enumerate() {"}, {"sha": "1318c5b8e3a6104d98607672b91339d62e223924", "filename": "library/std/src/sys/unix/rwlock.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b97dc20784698730bd7bc1a20eabdcd32066d174/library%2Fstd%2Fsrc%2Fsys%2Funix%2Frwlock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b97dc20784698730bd7bc1a20eabdcd32066d174/library%2Fstd%2Fsrc%2Fsys%2Funix%2Frwlock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Funix%2Frwlock.rs?ref=b97dc20784698730bd7bc1a20eabdcd32066d174", "patch": "@@ -48,9 +48,9 @@ impl RWLock {\n             }\n             panic!(\"rwlock read lock would result in deadlock\");\n         } else {\n-            // According to POSIX, for a properly initialized rwlock this can only\n-            // return EAGAIN or EDEADLK or 0. We rely on that.\n-            debug_assert_eq!(r, 0);\n+            // POSIX does not make guarantees about all the errors that may be returned.\n+            // See issue #94705 for more details.\n+            assert_eq!(r, 0, \"unexpected error during rwlock read lock: {:?}\", r);\n             self.num_readers.fetch_add(1, Ordering::Relaxed);\n         }\n     }"}, {"sha": "4af58f1a3807533b9ba4e143a63326122002a8ba", "filename": "library/std/src/thread/scoped.rs", "status": "modified", "additions": 23, "deletions": 21, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/b97dc20784698730bd7bc1a20eabdcd32066d174/library%2Fstd%2Fsrc%2Fthread%2Fscoped.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b97dc20784698730bd7bc1a20eabdcd32066d174/library%2Fstd%2Fsrc%2Fthread%2Fscoped.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fthread%2Fscoped.rs?ref=b97dc20784698730bd7bc1a20eabdcd32066d174", "patch": "@@ -9,23 +9,24 @@ use crate::sync::Arc;\n /// A scope to spawn scoped threads in.\n ///\n /// See [`scope`] for details.\n-pub struct Scope<'env> {\n+pub struct Scope<'scope, 'env: 'scope> {\n     data: ScopeData,\n-    /// Invariance over 'env, to make sure 'env cannot shrink,\n+    /// Invariance over 'scope, to make sure 'scope cannot shrink,\n     /// which is necessary for soundness.\n     ///\n     /// Without invariance, this would compile fine but be unsound:\n     ///\n-    /// ```compile_fail\n+    /// ```compile_fail,E0373\n     /// #![feature(scoped_threads)]\n     ///\n     /// std::thread::scope(|s| {\n-    ///     s.spawn(|s| {\n+    ///     s.spawn(|| {\n     ///         let a = String::from(\"abcd\");\n-    ///         s.spawn(|_| println!(\"{:?}\", a)); // might run after `a` is dropped\n+    ///         s.spawn(|| println!(\"{:?}\", a)); // might run after `a` is dropped\n     ///     });\n     /// });\n     /// ```\n+    scope: PhantomData<&'scope mut &'scope ()>,\n     env: PhantomData<&'env mut &'env ()>,\n }\n \n@@ -88,12 +89,12 @@ impl ScopeData {\n /// let mut x = 0;\n ///\n /// thread::scope(|s| {\n-///     s.spawn(|_| {\n+///     s.spawn(|| {\n ///         println!(\"hello from the first scoped thread\");\n ///         // We can borrow `a` here.\n ///         dbg!(&a);\n ///     });\n-///     s.spawn(|_| {\n+///     s.spawn(|| {\n ///         println!(\"hello from the second scoped thread\");\n ///         // We can even mutably borrow `x` here,\n ///         // because no other threads are using it.\n@@ -109,7 +110,7 @@ impl ScopeData {\n #[track_caller]\n pub fn scope<'env, F, T>(f: F) -> T\n where\n-    F: FnOnce(&Scope<'env>) -> T,\n+    F: for<'scope> FnOnce(&'scope Scope<'scope, 'env>) -> T,\n {\n     let scope = Scope {\n         data: ScopeData {\n@@ -118,6 +119,7 @@ where\n             a_thread_panicked: AtomicBool::new(false),\n         },\n         env: PhantomData,\n+        scope: PhantomData,\n     };\n \n     // Run `f`, but catch panics so we can make sure to wait for all the threads to join.\n@@ -138,7 +140,7 @@ where\n     }\n }\n \n-impl<'env> Scope<'env> {\n+impl<'scope, 'env> Scope<'scope, 'env> {\n     /// Spawns a new thread within a scope, returning a [`ScopedJoinHandle`] for it.\n     ///\n     /// Unlike non-scoped threads, threads spawned with this function may\n@@ -163,10 +165,10 @@ impl<'env> Scope<'env> {\n     /// to recover from such errors.\n     ///\n     /// [`join`]: ScopedJoinHandle::join\n-    pub fn spawn<'scope, F, T>(&'scope self, f: F) -> ScopedJoinHandle<'scope, T>\n+    pub fn spawn<F, T>(&'scope self, f: F) -> ScopedJoinHandle<'scope, T>\n     where\n-        F: FnOnce(&Scope<'env>) -> T + Send + 'env,\n-        T: Send + 'env,\n+        F: FnOnce() -> T + Send + 'scope,\n+        T: Send + 'scope,\n     {\n         Builder::new().spawn_scoped(self, f).expect(\"failed to spawn thread\")\n     }\n@@ -196,7 +198,7 @@ impl Builder {\n     /// thread::scope(|s| {\n     ///     thread::Builder::new()\n     ///         .name(\"first\".to_string())\n-    ///         .spawn_scoped(s, |_|\n+    ///         .spawn_scoped(s, ||\n     ///     {\n     ///         println!(\"hello from the {:?} scoped thread\", thread::current().name());\n     ///         // We can borrow `a` here.\n@@ -205,7 +207,7 @@ impl Builder {\n     ///     .unwrap();\n     ///     thread::Builder::new()\n     ///         .name(\"second\".to_string())\n-    ///         .spawn_scoped(s, |_|\n+    ///         .spawn_scoped(s, ||\n     ///     {\n     ///         println!(\"hello from the {:?} scoped thread\", thread::current().name());\n     ///         // We can even mutably borrow `x` here,\n@@ -222,14 +224,14 @@ impl Builder {\n     /// ```\n     pub fn spawn_scoped<'scope, 'env, F, T>(\n         self,\n-        scope: &'scope Scope<'env>,\n+        scope: &'scope Scope<'scope, 'env>,\n         f: F,\n     ) -> io::Result<ScopedJoinHandle<'scope, T>>\n     where\n-        F: FnOnce(&Scope<'env>) -> T + Send + 'env,\n-        T: Send + 'env,\n+        F: FnOnce() -> T + Send + 'scope,\n+        T: Send + 'scope,\n     {\n-        Ok(ScopedJoinHandle(unsafe { self.spawn_unchecked_(|| f(scope), Some(&scope.data)) }?))\n+        Ok(ScopedJoinHandle(unsafe { self.spawn_unchecked_(f, Some(&scope.data)) }?))\n     }\n }\n \n@@ -244,7 +246,7 @@ impl<'scope, T> ScopedJoinHandle<'scope, T> {\n     /// use std::thread;\n     ///\n     /// thread::scope(|s| {\n-    ///     let t = s.spawn(|_| {\n+    ///     let t = s.spawn(|| {\n     ///         println!(\"hello\");\n     ///     });\n     ///     println!(\"thread id: {:?}\", t.thread().id());\n@@ -277,7 +279,7 @@ impl<'scope, T> ScopedJoinHandle<'scope, T> {\n     /// use std::thread;\n     ///\n     /// thread::scope(|s| {\n-    ///     let t = s.spawn(|_| {\n+    ///     let t = s.spawn(|| {\n     ///         panic!(\"oh no\");\n     ///     });\n     ///     assert!(t.join().is_err());\n@@ -302,7 +304,7 @@ impl<'scope, T> ScopedJoinHandle<'scope, T> {\n     }\n }\n \n-impl<'env> fmt::Debug for Scope<'env> {\n+impl fmt::Debug for Scope<'_, '_> {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         f.debug_struct(\"Scope\")\n             .field(\"num_running_threads\", &self.data.num_running_threads.load(Ordering::Relaxed))"}, {"sha": "35f9c581c7b21b254a4add1f516668fa17c24229", "filename": "src/test/ui/async-await/edition-deny-async-fns-2015.stderr", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/b97dc20784698730bd7bc1a20eabdcd32066d174/src%2Ftest%2Fui%2Fasync-await%2Fedition-deny-async-fns-2015.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b97dc20784698730bd7bc1a20eabdcd32066d174/src%2Ftest%2Fui%2Fasync-await%2Fedition-deny-async-fns-2015.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fedition-deny-async-fns-2015.stderr?ref=b97dc20784698730bd7bc1a20eabdcd32066d174", "patch": "@@ -4,7 +4,7 @@ error[E0670]: `async fn` is not permitted in Rust 2015\n LL | async fn foo() {}\n    | ^^^^^ to use `async fn`, switch to Rust 2018 or later\n    |\n-   = help: set `edition = \"2021\"` in `Cargo.toml`\n+   = help: pass `--edition 2021` to `rustc`\n    = note: for more on editions, read https://doc.rust-lang.org/edition-guide\n \n error[E0670]: `async fn` is not permitted in Rust 2015\n@@ -13,7 +13,7 @@ error[E0670]: `async fn` is not permitted in Rust 2015\n LL | fn baz() { async fn foo() {} }\n    |            ^^^^^ to use `async fn`, switch to Rust 2018 or later\n    |\n-   = help: set `edition = \"2021\"` in `Cargo.toml`\n+   = help: pass `--edition 2021` to `rustc`\n    = note: for more on editions, read https://doc.rust-lang.org/edition-guide\n \n error[E0670]: `async fn` is not permitted in Rust 2015\n@@ -22,7 +22,7 @@ error[E0670]: `async fn` is not permitted in Rust 2015\n LL | async fn async_baz() {\n    | ^^^^^ to use `async fn`, switch to Rust 2018 or later\n    |\n-   = help: set `edition = \"2021\"` in `Cargo.toml`\n+   = help: pass `--edition 2021` to `rustc`\n    = note: for more on editions, read https://doc.rust-lang.org/edition-guide\n \n error[E0670]: `async fn` is not permitted in Rust 2015\n@@ -31,7 +31,7 @@ error[E0670]: `async fn` is not permitted in Rust 2015\n LL |     async fn bar() {}\n    |     ^^^^^ to use `async fn`, switch to Rust 2018 or later\n    |\n-   = help: set `edition = \"2021\"` in `Cargo.toml`\n+   = help: pass `--edition 2021` to `rustc`\n    = note: for more on editions, read https://doc.rust-lang.org/edition-guide\n \n error[E0670]: `async fn` is not permitted in Rust 2015\n@@ -40,7 +40,7 @@ error[E0670]: `async fn` is not permitted in Rust 2015\n LL |     async fn foo() {}\n    |     ^^^^^ to use `async fn`, switch to Rust 2018 or later\n    |\n-   = help: set `edition = \"2021\"` in `Cargo.toml`\n+   = help: pass `--edition 2021` to `rustc`\n    = note: for more on editions, read https://doc.rust-lang.org/edition-guide\n \n error[E0670]: `async fn` is not permitted in Rust 2015\n@@ -49,7 +49,7 @@ error[E0670]: `async fn` is not permitted in Rust 2015\n LL |     async fn foo() {}\n    |     ^^^^^ to use `async fn`, switch to Rust 2018 or later\n    |\n-   = help: set `edition = \"2021\"` in `Cargo.toml`\n+   = help: pass `--edition 2021` to `rustc`\n    = note: for more on editions, read https://doc.rust-lang.org/edition-guide\n \n error[E0670]: `async fn` is not permitted in Rust 2015\n@@ -58,7 +58,7 @@ error[E0670]: `async fn` is not permitted in Rust 2015\n LL |         async fn bar() {}\n    |         ^^^^^ to use `async fn`, switch to Rust 2018 or later\n    |\n-   = help: set `edition = \"2021\"` in `Cargo.toml`\n+   = help: pass `--edition 2021` to `rustc`\n    = note: for more on editions, read https://doc.rust-lang.org/edition-guide\n \n error[E0670]: `async fn` is not permitted in Rust 2015\n@@ -67,7 +67,7 @@ error[E0670]: `async fn` is not permitted in Rust 2015\n LL |         async fn foo() {}\n    |         ^^^^^ to use `async fn`, switch to Rust 2018 or later\n    |\n-   = help: set `edition = \"2021\"` in `Cargo.toml`\n+   = help: pass `--edition 2021` to `rustc`\n    = note: for more on editions, read https://doc.rust-lang.org/edition-guide\n \n error[E0670]: `async fn` is not permitted in Rust 2015\n@@ -76,7 +76,7 @@ error[E0670]: `async fn` is not permitted in Rust 2015\n LL |             async fn bar() {}\n    |             ^^^^^ to use `async fn`, switch to Rust 2018 or later\n    |\n-   = help: set `edition = \"2021\"` in `Cargo.toml`\n+   = help: pass `--edition 2021` to `rustc`\n    = note: for more on editions, read https://doc.rust-lang.org/edition-guide\n \n error[E0706]: functions in traits cannot be declared `async`"}, {"sha": "4919e0a051dcb411b601429bedc6be8b87a951a5", "filename": "src/test/ui/async-await/suggest-switching-edition-on-await-cargo.rs", "status": "added", "additions": 47, "deletions": 0, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/b97dc20784698730bd7bc1a20eabdcd32066d174/src%2Ftest%2Fui%2Fasync-await%2Fsuggest-switching-edition-on-await-cargo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b97dc20784698730bd7bc1a20eabdcd32066d174/src%2Ftest%2Fui%2Fasync-await%2Fsuggest-switching-edition-on-await-cargo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fsuggest-switching-edition-on-await-cargo.rs?ref=b97dc20784698730bd7bc1a20eabdcd32066d174", "patch": "@@ -0,0 +1,47 @@\n+// rustc-env:CARGO=/usr/bin/cargo\n+\n+use std::pin::Pin;\n+use std::future::Future;\n+\n+fn main() {}\n+\n+fn await_on_struct_missing() {\n+    struct S;\n+    let x = S;\n+    x.await;\n+    //~^ ERROR no field `await` on type\n+    //~| NOTE unknown field\n+    //~| NOTE to `.await` a `Future`, switch to Rust 2018\n+    //~| HELP set `edition = \"2021\"` in `Cargo.toml`\n+    //~| NOTE for more on editions, read https://doc.rust-lang.org/edition-guide\n+}\n+\n+fn await_on_struct_similar() {\n+    struct S {\n+        awai: u8,\n+    }\n+    let x = S { awai: 42 };\n+    x.await;\n+    //~^ ERROR no field `await` on type\n+    //~| HELP a field with a similar name exists\n+    //~| NOTE to `.await` a `Future`, switch to Rust 2018\n+    //~| HELP set `edition = \"2021\"` in `Cargo.toml`\n+    //~| NOTE for more on editions, read https://doc.rust-lang.org/edition-guide\n+}\n+\n+fn await_on_63533(x: Pin<&mut dyn Future<Output = ()>>) {\n+    x.await;\n+    //~^ ERROR no field `await` on type\n+    //~| NOTE unknown field\n+    //~| NOTE to `.await` a `Future`, switch to Rust 2018\n+    //~| HELP set `edition = \"2021\"` in `Cargo.toml`\n+    //~| NOTE for more on editions, read https://doc.rust-lang.org/edition-guide\n+}\n+\n+fn await_on_apit(x: impl Future<Output = ()>) {\n+    x.await;\n+    //~^ ERROR no field `await` on type\n+    //~| NOTE to `.await` a `Future`, switch to Rust 2018\n+    //~| HELP set `edition = \"2021\"` in `Cargo.toml`\n+    //~| NOTE for more on editions, read https://doc.rust-lang.org/edition-guide\n+}"}, {"sha": "409eb179e83a05f7263f9acef4bf951532bf0448", "filename": "src/test/ui/async-await/suggest-switching-edition-on-await-cargo.stderr", "status": "added", "additions": 43, "deletions": 0, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/b97dc20784698730bd7bc1a20eabdcd32066d174/src%2Ftest%2Fui%2Fasync-await%2Fsuggest-switching-edition-on-await-cargo.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b97dc20784698730bd7bc1a20eabdcd32066d174/src%2Ftest%2Fui%2Fasync-await%2Fsuggest-switching-edition-on-await-cargo.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fsuggest-switching-edition-on-await-cargo.stderr?ref=b97dc20784698730bd7bc1a20eabdcd32066d174", "patch": "@@ -0,0 +1,43 @@\n+error[E0609]: no field `await` on type `await_on_struct_missing::S`\n+  --> $DIR/suggest-switching-edition-on-await-cargo.rs:11:7\n+   |\n+LL |     x.await;\n+   |       ^^^^^ unknown field\n+   |\n+   = note: to `.await` a `Future`, switch to Rust 2018 or later\n+   = help: set `edition = \"2021\"` in `Cargo.toml`\n+   = note: for more on editions, read https://doc.rust-lang.org/edition-guide\n+\n+error[E0609]: no field `await` on type `await_on_struct_similar::S`\n+  --> $DIR/suggest-switching-edition-on-await-cargo.rs:24:7\n+   |\n+LL |     x.await;\n+   |       ^^^^^ help: a field with a similar name exists: `awai`\n+   |\n+   = note: to `.await` a `Future`, switch to Rust 2018 or later\n+   = help: set `edition = \"2021\"` in `Cargo.toml`\n+   = note: for more on editions, read https://doc.rust-lang.org/edition-guide\n+\n+error[E0609]: no field `await` on type `Pin<&mut dyn Future<Output = ()>>`\n+  --> $DIR/suggest-switching-edition-on-await-cargo.rs:33:7\n+   |\n+LL |     x.await;\n+   |       ^^^^^ unknown field\n+   |\n+   = note: to `.await` a `Future`, switch to Rust 2018 or later\n+   = help: set `edition = \"2021\"` in `Cargo.toml`\n+   = note: for more on editions, read https://doc.rust-lang.org/edition-guide\n+\n+error[E0609]: no field `await` on type `impl Future<Output = ()>`\n+  --> $DIR/suggest-switching-edition-on-await-cargo.rs:42:7\n+   |\n+LL |     x.await;\n+   |       ^^^^^\n+   |\n+   = note: to `.await` a `Future`, switch to Rust 2018 or later\n+   = help: set `edition = \"2021\"` in `Cargo.toml`\n+   = note: for more on editions, read https://doc.rust-lang.org/edition-guide\n+\n+error: aborting due to 4 previous errors\n+\n+For more information about this error, try `rustc --explain E0609`."}, {"sha": "9852e8fc918fe61e2647c48e25a747444c73bd35", "filename": "src/test/ui/async-await/suggest-switching-edition-on-await.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/b97dc20784698730bd7bc1a20eabdcd32066d174/src%2Ftest%2Fui%2Fasync-await%2Fsuggest-switching-edition-on-await.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b97dc20784698730bd7bc1a20eabdcd32066d174/src%2Ftest%2Fui%2Fasync-await%2Fsuggest-switching-edition-on-await.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fsuggest-switching-edition-on-await.rs?ref=b97dc20784698730bd7bc1a20eabdcd32066d174", "patch": "@@ -10,7 +10,7 @@ fn await_on_struct_missing() {\n     //~^ ERROR no field `await` on type\n     //~| NOTE unknown field\n     //~| NOTE to `.await` a `Future`, switch to Rust 2018\n-    //~| HELP set `edition = \"2021\"` in `Cargo.toml`\n+    //~| HELP pass `--edition 2021` to `rustc`\n     //~| NOTE for more on editions, read https://doc.rust-lang.org/edition-guide\n }\n \n@@ -23,7 +23,7 @@ fn await_on_struct_similar() {\n     //~^ ERROR no field `await` on type\n     //~| HELP a field with a similar name exists\n     //~| NOTE to `.await` a `Future`, switch to Rust 2018\n-    //~| HELP set `edition = \"2021\"` in `Cargo.toml`\n+    //~| HELP pass `--edition 2021` to `rustc`\n     //~| NOTE for more on editions, read https://doc.rust-lang.org/edition-guide\n }\n \n@@ -32,14 +32,14 @@ fn await_on_63533(x: Pin<&mut dyn Future<Output = ()>>) {\n     //~^ ERROR no field `await` on type\n     //~| NOTE unknown field\n     //~| NOTE to `.await` a `Future`, switch to Rust 2018\n-    //~| HELP set `edition = \"2021\"` in `Cargo.toml`\n+    //~| HELP pass `--edition 2021` to `rustc`\n     //~| NOTE for more on editions, read https://doc.rust-lang.org/edition-guide\n }\n \n fn await_on_apit(x: impl Future<Output = ()>) {\n     x.await;\n     //~^ ERROR no field `await` on type\n     //~| NOTE to `.await` a `Future`, switch to Rust 2018\n-    //~| HELP set `edition = \"2021\"` in `Cargo.toml`\n+    //~| HELP pass `--edition 2021` to `rustc`\n     //~| NOTE for more on editions, read https://doc.rust-lang.org/edition-guide\n }"}, {"sha": "ef3334381b71524e051480a56a2a212c854caa81", "filename": "src/test/ui/async-await/suggest-switching-edition-on-await.stderr", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/b97dc20784698730bd7bc1a20eabdcd32066d174/src%2Ftest%2Fui%2Fasync-await%2Fsuggest-switching-edition-on-await.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b97dc20784698730bd7bc1a20eabdcd32066d174/src%2Ftest%2Fui%2Fasync-await%2Fsuggest-switching-edition-on-await.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fsuggest-switching-edition-on-await.stderr?ref=b97dc20784698730bd7bc1a20eabdcd32066d174", "patch": "@@ -5,7 +5,7 @@ LL |     x.await;\n    |       ^^^^^ unknown field\n    |\n    = note: to `.await` a `Future`, switch to Rust 2018 or later\n-   = help: set `edition = \"2021\"` in `Cargo.toml`\n+   = help: pass `--edition 2021` to `rustc`\n    = note: for more on editions, read https://doc.rust-lang.org/edition-guide\n \n error[E0609]: no field `await` on type `await_on_struct_similar::S`\n@@ -15,7 +15,7 @@ LL |     x.await;\n    |       ^^^^^ help: a field with a similar name exists: `awai`\n    |\n    = note: to `.await` a `Future`, switch to Rust 2018 or later\n-   = help: set `edition = \"2021\"` in `Cargo.toml`\n+   = help: pass `--edition 2021` to `rustc`\n    = note: for more on editions, read https://doc.rust-lang.org/edition-guide\n \n error[E0609]: no field `await` on type `Pin<&mut dyn Future<Output = ()>>`\n@@ -25,7 +25,7 @@ LL |     x.await;\n    |       ^^^^^ unknown field\n    |\n    = note: to `.await` a `Future`, switch to Rust 2018 or later\n-   = help: set `edition = \"2021\"` in `Cargo.toml`\n+   = help: pass `--edition 2021` to `rustc`\n    = note: for more on editions, read https://doc.rust-lang.org/edition-guide\n \n error[E0609]: no field `await` on type `impl Future<Output = ()>`\n@@ -35,7 +35,7 @@ LL |     x.await;\n    |       ^^^^^\n    |\n    = note: to `.await` a `Future`, switch to Rust 2018 or later\n-   = help: set `edition = \"2021\"` in `Cargo.toml`\n+   = help: pass `--edition 2021` to `rustc`\n    = note: for more on editions, read https://doc.rust-lang.org/edition-guide\n \n error: aborting due to 4 previous errors"}, {"sha": "7e22defa98dd460e43b091b5b56af30f090b7981", "filename": "src/test/ui/closures/2229_closure_analysis/match/issue-88331.stderr", "status": "modified", "additions": 20, "deletions": 8, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/b97dc20784698730bd7bc1a20eabdcd32066d174/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fmatch%2Fissue-88331.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b97dc20784698730bd7bc1a20eabdcd32066d174/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fmatch%2Fissue-88331.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fmatch%2Fissue-88331.stderr?ref=b97dc20784698730bd7bc1a20eabdcd32066d174", "patch": "@@ -1,26 +1,38 @@\n error[E0004]: non-exhaustive patterns: `Opcode(0_u8)` and `Opcode(2_u8..=u8::MAX)` not covered\n   --> $DIR/issue-88331.rs:11:20\n    |\n-LL | pub struct Opcode(pub u8);\n-   | -------------------------- `Opcode` defined here\n-...\n LL |     move |i| match msg_type {\n    |                    ^^^^^^^^ patterns `Opcode(0_u8)` and `Opcode(2_u8..=u8::MAX)` not covered\n    |\n-   = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n+note: `Opcode` defined here\n+  --> $DIR/issue-88331.rs:4:12\n+   |\n+LL | pub struct Opcode(pub u8);\n+   |            ^^^^^^\n    = note: the matched value is of type `Opcode`\n+help: ensure that all possible cases are being handled by adding a match arm with a wildcard pattern, a match arm with multiple or-patterns as shown, or multiple match arms\n+   |\n+LL ~         Opcode::OP1 => unimplemented!(),\n+LL ~         Opcode(0_u8) | Opcode(2_u8..=u8::MAX) => todo!(),\n+   |\n \n error[E0004]: non-exhaustive patterns: `Opcode2(Opcode(0_u8))` and `Opcode2(Opcode(2_u8..=u8::MAX))` not covered\n   --> $DIR/issue-88331.rs:27:20\n    |\n-LL | pub struct Opcode2(Opcode);\n-   | --------------------------- `Opcode2` defined here\n-...\n LL |     move |i| match msg_type {\n    |                    ^^^^^^^^ patterns `Opcode2(Opcode(0_u8))` and `Opcode2(Opcode(2_u8..=u8::MAX))` not covered\n    |\n-   = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n+note: `Opcode2` defined here\n+  --> $DIR/issue-88331.rs:18:12\n+   |\n+LL | pub struct Opcode2(Opcode);\n+   |            ^^^^^^^\n    = note: the matched value is of type `Opcode2`\n+help: ensure that all possible cases are being handled by adding a match arm with a wildcard pattern, a match arm with multiple or-patterns as shown, or multiple match arms\n+   |\n+LL ~         Opcode2::OP2=> unimplemented!(),\n+LL ~         Opcode2(Opcode(0_u8)) | Opcode2(Opcode(2_u8..=u8::MAX)) => todo!(),\n+   |\n \n error: aborting due to 2 previous errors\n "}, {"sha": "32d36274ff6ef7aed9b85878e020c4f044814e21", "filename": "src/test/ui/closures/2229_closure_analysis/match/non-exhaustive-match.stderr", "status": "modified", "additions": 29, "deletions": 9, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/b97dc20784698730bd7bc1a20eabdcd32066d174/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fmatch%2Fnon-exhaustive-match.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b97dc20784698730bd7bc1a20eabdcd32066d174/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fmatch%2Fnon-exhaustive-match.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fmatch%2Fnon-exhaustive-match.stderr?ref=b97dc20784698730bd7bc1a20eabdcd32066d174", "patch": "@@ -1,35 +1,55 @@\n error[E0004]: non-exhaustive patterns: `B` not covered\n   --> $DIR/non-exhaustive-match.rs:26:25\n    |\n-LL | enum L1 { A, B }\n-   | ----------------\n-   | |            |\n-   | |            not covered\n-   | `L1` defined here\n-...\n LL |     let _b = || { match l1 { L1::A => () } };\n    |                         ^^ pattern `B` not covered\n    |\n-   = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n+note: `L1` defined here\n+  --> $DIR/non-exhaustive-match.rs:12:14\n+   |\n+LL | enum L1 { A, B }\n+   |      --      ^ not covered\n    = note: the matched value is of type `L1`\n+help: ensure that all possible cases are being handled by adding a match arm with a wildcard pattern or an explicit pattern as shown\n+   |\n+LL |     let _b = || { match l1 { L1::A => (), B => todo!() } };\n+   |                                         ++++++++++++++\n \n error[E0004]: non-exhaustive patterns: type `E1` is non-empty\n   --> $DIR/non-exhaustive-match.rs:37:25\n    |\n LL |     let _d = || { match e1 {} };\n    |                         ^^\n    |\n-   = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n+note: `E1` defined here\n+  --> $DIR/auxiliary/match_non_exhaustive_lib.rs:2:1\n+   |\n+LL | pub enum E1 {}\n+   | ^^^^^^^^^^^^^^\n    = note: the matched value is of type `E1`, which is marked as non-exhaustive\n+help: ensure that all possible cases are being handled by adding a match arm with a wildcard pattern as shown\n+   |\n+LL ~     let _d = || { match e1 {\n+LL +         _ => todo!(),\n+LL ~     } };\n+   |\n \n error[E0004]: non-exhaustive patterns: `_` not covered\n   --> $DIR/non-exhaustive-match.rs:39:25\n    |\n LL |     let _e = || { match e2 { E2::A => (), E2::B => () } };\n    |                         ^^ pattern `_` not covered\n    |\n-   = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n+note: `E2` defined here\n+  --> $DIR/auxiliary/match_non_exhaustive_lib.rs:5:1\n+   |\n+LL | pub enum E2 { A, B }\n+   | ^^^^^^^^^^^^^^^^^^^^\n    = note: the matched value is of type `E2`, which is marked as non-exhaustive\n+help: ensure that all possible cases are being handled by adding a match arm with a wildcard pattern or an explicit pattern as shown\n+   |\n+LL |     let _e = || { match e2 { E2::A => (), E2::B => (), _ => todo!() } };\n+   |                                                      ++++++++++++++\n \n error[E0505]: cannot move out of `e3` because it is borrowed\n   --> $DIR/non-exhaustive-match.rs:46:22"}, {"sha": "e55fb7ce4bbe9528a70b259251de935fda539d20", "filename": "src/test/ui/closures/2229_closure_analysis/match/pattern-matching-should-fail.stderr", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/b97dc20784698730bd7bc1a20eabdcd32066d174/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fmatch%2Fpattern-matching-should-fail.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b97dc20784698730bd7bc1a20eabdcd32066d174/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fmatch%2Fpattern-matching-should-fail.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fmatch%2Fpattern-matching-should-fail.stderr?ref=b97dc20784698730bd7bc1a20eabdcd32066d174", "patch": "@@ -4,8 +4,13 @@ error[E0004]: non-exhaustive patterns: type `u8` is non-empty\n LL |     let c1 = || match x { };\n    |                       ^\n    |\n-   = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n    = note: the matched value is of type `u8`\n+help: ensure that all possible cases are being handled by adding a match arm with a wildcard pattern as shown\n+   |\n+LL ~     let c1 = || match x {\n+LL +         _ => todo!(),\n+LL ~     };\n+   |\n \n error[E0381]: use of possibly-uninitialized variable: `x`\n   --> $DIR/pattern-matching-should-fail.rs:8:23"}, {"sha": "3daf4930c5b4b349f981f98c9f6c815318897d44", "filename": "src/test/ui/editions/async-block-2015.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b97dc20784698730bd7bc1a20eabdcd32066d174/src%2Ftest%2Fui%2Feditions%2Fasync-block-2015.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b97dc20784698730bd7bc1a20eabdcd32066d174/src%2Ftest%2Fui%2Feditions%2Fasync-block-2015.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Feditions%2Fasync-block-2015.rs?ref=b97dc20784698730bd7bc1a20eabdcd32066d174", "patch": "@@ -1,7 +1,7 @@\n async fn foo() {\n //~^ ERROR `async fn` is not permitted in Rust 2015\n //~| NOTE to use `async fn`, switch to Rust 2018 or later\n-//~| HELP set `edition = \"2021\"` in `Cargo.toml`\n+//~| HELP pass `--edition 2021` to `rustc`\n //~| NOTE for more on editions, read https://doc.rust-lang.org/edition-guide\n \n     let x = async {};\n@@ -11,15 +11,15 @@ async fn foo() {\n         let x = 42;\n         //~^ ERROR expected identifier, found keyword `let`\n         //~| NOTE expected identifier, found keyword\n-        //~| HELP set `edition = \"2021\"` in `Cargo.toml`\n+        //~| HELP pass `--edition 2021` to `rustc`\n         //~| NOTE for more on editions, read https://doc.rust-lang.org/edition-guide\n         42\n     };\n     let z = async { //~ NOTE `async` blocks are only allowed in Rust 2018 or later\n         42\n         //~^ ERROR expected identifier, found `42`\n         //~| NOTE expected identifier\n-        //~| HELP set `edition = \"2021\"` in `Cargo.toml`\n+        //~| HELP pass `--edition 2021` to `rustc`\n         //~| NOTE for more on editions, read https://doc.rust-lang.org/edition-guide\n     };\n     y.await;"}, {"sha": "b792b8c1e0dd84834e9b3353c851786df87a4022", "filename": "src/test/ui/editions/async-block-2015.stderr", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b97dc20784698730bd7bc1a20eabdcd32066d174/src%2Ftest%2Fui%2Feditions%2Fasync-block-2015.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b97dc20784698730bd7bc1a20eabdcd32066d174/src%2Ftest%2Fui%2Feditions%2Fasync-block-2015.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Feditions%2Fasync-block-2015.stderr?ref=b97dc20784698730bd7bc1a20eabdcd32066d174", "patch": "@@ -4,7 +4,7 @@ error[E0670]: `async fn` is not permitted in Rust 2015\n LL | async fn foo() {\n    | ^^^^^ to use `async fn`, switch to Rust 2018 or later\n    |\n-   = help: set `edition = \"2021\"` in `Cargo.toml`\n+   = help: pass `--edition 2021` to `rustc`\n    = note: for more on editions, read https://doc.rust-lang.org/edition-guide\n \n error: expected identifier, found keyword `let`\n@@ -15,7 +15,7 @@ LL |     let y = async {\n LL |         let x = 42;\n    |         ^^^ expected identifier, found keyword\n    |\n-   = help: set `edition = \"2021\"` in `Cargo.toml`\n+   = help: pass `--edition 2021` to `rustc`\n    = note: for more on editions, read https://doc.rust-lang.org/edition-guide\n \n error: expected identifier, found `42`\n@@ -26,7 +26,7 @@ LL |     let z = async {\n LL |         42\n    |         ^^ expected identifier\n    |\n-   = help: set `edition = \"2021\"` in `Cargo.toml`\n+   = help: pass `--edition 2021` to `rustc`\n    = note: for more on editions, read https://doc.rust-lang.org/edition-guide\n \n error[E0422]: cannot find struct, variant or union type `async` in this scope"}, {"sha": "d319227b217a73624e0a64aeb079d05a104306bb", "filename": "src/test/ui/empty/empty-attributes.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/b97dc20784698730bd7bc1a20eabdcd32066d174/src%2Ftest%2Fui%2Fempty%2Fempty-attributes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b97dc20784698730bd7bc1a20eabdcd32066d174/src%2Ftest%2Fui%2Fempty%2Fempty-attributes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fempty%2Fempty-attributes.rs?ref=b97dc20784698730bd7bc1a20eabdcd32066d174", "patch": "@@ -1,5 +1,8 @@\n+#![feature(lint_reasons)]\n+\n #![deny(unused_attributes)]\n #![allow()] //~ ERROR unused attribute\n+#![expect()] //~ ERROR unused attribute\n #![warn()] //~ ERROR unused attribute\n #![deny()] //~ ERROR unused attribute\n #![forbid()] //~ ERROR unused attribute"}, {"sha": "8653eaf5ccdf3e9f048541f859a19744745a59e8", "filename": "src/test/ui/empty/empty-attributes.stderr", "status": "modified", "additions": 17, "deletions": 9, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/b97dc20784698730bd7bc1a20eabdcd32066d174/src%2Ftest%2Fui%2Fempty%2Fempty-attributes.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b97dc20784698730bd7bc1a20eabdcd32066d174/src%2Ftest%2Fui%2Fempty%2Fempty-attributes.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fempty%2Fempty-attributes.stderr?ref=b97dc20784698730bd7bc1a20eabdcd32066d174", "patch": "@@ -1,63 +1,71 @@\n error: unused attribute\n-  --> $DIR/empty-attributes.rs:8:1\n+  --> $DIR/empty-attributes.rs:11:1\n    |\n LL | #[repr()]\n    | ^^^^^^^^^ help: remove this attribute\n    |\n note: the lint level is defined here\n-  --> $DIR/empty-attributes.rs:1:9\n+  --> $DIR/empty-attributes.rs:3:9\n    |\n LL | #![deny(unused_attributes)]\n    |         ^^^^^^^^^^^^^^^^^\n    = note: attribute `repr` with an empty list has no effect\n \n error: unused attribute\n-  --> $DIR/empty-attributes.rs:11:1\n+  --> $DIR/empty-attributes.rs:14:1\n    |\n LL | #[target_feature()]\n    | ^^^^^^^^^^^^^^^^^^^ help: remove this attribute\n    |\n    = note: attribute `target_feature` with an empty list has no effect\n \n error: unused attribute\n-  --> $DIR/empty-attributes.rs:2:1\n+  --> $DIR/empty-attributes.rs:4:1\n    |\n LL | #![allow()]\n    | ^^^^^^^^^^^ help: remove this attribute\n    |\n    = note: attribute `allow` with an empty list has no effect\n \n error: unused attribute\n-  --> $DIR/empty-attributes.rs:3:1\n+  --> $DIR/empty-attributes.rs:5:1\n+   |\n+LL | #![expect()]\n+   | ^^^^^^^^^^^^ help: remove this attribute\n+   |\n+   = note: attribute `expect` with an empty list has no effect\n+\n+error: unused attribute\n+  --> $DIR/empty-attributes.rs:6:1\n    |\n LL | #![warn()]\n    | ^^^^^^^^^^ help: remove this attribute\n    |\n    = note: attribute `warn` with an empty list has no effect\n \n error: unused attribute\n-  --> $DIR/empty-attributes.rs:4:1\n+  --> $DIR/empty-attributes.rs:7:1\n    |\n LL | #![deny()]\n    | ^^^^^^^^^^ help: remove this attribute\n    |\n    = note: attribute `deny` with an empty list has no effect\n \n error: unused attribute\n-  --> $DIR/empty-attributes.rs:5:1\n+  --> $DIR/empty-attributes.rs:8:1\n    |\n LL | #![forbid()]\n    | ^^^^^^^^^^^^ help: remove this attribute\n    |\n    = note: attribute `forbid` with an empty list has no effect\n \n error: unused attribute\n-  --> $DIR/empty-attributes.rs:6:1\n+  --> $DIR/empty-attributes.rs:9:1\n    |\n LL | #![feature()]\n    | ^^^^^^^^^^^^^ help: remove this attribute\n    |\n    = note: attribute `feature` with an empty list has no effect\n \n-error: aborting due to 7 previous errors\n+error: aborting due to 8 previous errors\n "}, {"sha": "8dd0f377533ce8c0dc0ce1a22e1252c4daf38da2", "filename": "src/test/ui/empty/empty-never-array.stderr", "status": "modified", "additions": 9, "deletions": 10, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/b97dc20784698730bd7bc1a20eabdcd32066d174/src%2Ftest%2Fui%2Fempty%2Fempty-never-array.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b97dc20784698730bd7bc1a20eabdcd32066d174/src%2Ftest%2Fui%2Fempty%2Fempty-never-array.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fempty%2Fempty-never-array.stderr?ref=b97dc20784698730bd7bc1a20eabdcd32066d174", "patch": "@@ -1,19 +1,18 @@\n error[E0005]: refutable pattern in local binding: `T(_, _)` not covered\n   --> $DIR/empty-never-array.rs:10:9\n    |\n-LL | / enum Helper<T, U> {\n-LL | |     T(T, [!; 0]),\n-   | |     - not covered\n-LL | |     #[allow(dead_code)]\n-LL | |     U(U),\n-LL | | }\n-   | |_- `Helper<T, U>` defined here\n-...\n-LL |       let Helper::U(u) = Helper::T(t, []);\n-   |           ^^^^^^^^^^^^ pattern `T(_, _)` not covered\n+LL |     let Helper::U(u) = Helper::T(t, []);\n+   |         ^^^^^^^^^^^^ pattern `T(_, _)` not covered\n    |\n    = note: `let` bindings require an \"irrefutable pattern\", like a `struct` or an `enum` with only one variant\n    = note: for more information, visit https://doc.rust-lang.org/book/ch18-02-refutability.html\n+note: `Helper<T, U>` defined here\n+  --> $DIR/empty-never-array.rs:4:5\n+   |\n+LL | enum Helper<T, U> {\n+   |      ------\n+LL |     T(T, [!; 0]),\n+   |     ^ not covered\n    = note: the matched value is of type `Helper<T, U>`\n help: you might want to use `if let` to ignore the variant that isn't matched\n    |"}, {"sha": "d4519af540859078b7587ba20c30a2ea998e9610", "filename": "src/test/ui/error-codes/E0004-2.stderr", "status": "modified", "additions": 19, "deletions": 8, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/b97dc20784698730bd7bc1a20eabdcd32066d174/src%2Ftest%2Fui%2Ferror-codes%2FE0004-2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b97dc20784698730bd7bc1a20eabdcd32066d174/src%2Ftest%2Fui%2Ferror-codes%2FE0004-2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ferror-codes%2FE0004-2.stderr?ref=b97dc20784698730bd7bc1a20eabdcd32066d174", "patch": "@@ -4,16 +4,27 @@ error[E0004]: non-exhaustive patterns: `None` and `Some(_)` not covered\n LL |     match x { }\n    |           ^ patterns `None` and `Some(_)` not covered\n    |\n-  ::: $SRC_DIR/core/src/option.rs:LL:COL\n+note: `Option<i32>` defined here\n+  --> $SRC_DIR/core/src/option.rs:LL:COL\n    |\n-LL |     None,\n-   |     ---- not covered\n-...\n-LL |     Some(#[stable(feature = \"rust1\", since = \"1.0.0\")] T),\n-   |     ---- not covered\n-   |\n-   = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n+LL | / pub enum Option<T> {\n+LL | |     /// No value.\n+LL | |     #[lang = \"None\"]\n+LL | |     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+LL | |     None,\n+   | |     ^^^^ not covered\n+...  |\n+LL | |     Some(#[stable(feature = \"rust1\", since = \"1.0.0\")] T),\n+   | |     ^^^^ not covered\n+LL | | }\n+   | |_-\n    = note: the matched value is of type `Option<i32>`\n+help: ensure that all possible cases are being handled by adding a match arm with a wildcard pattern, a match arm with multiple or-patterns as shown, or multiple match arms\n+   |\n+LL ~     match x {\n+LL +         None | Some(_) => todo!(),\n+LL ~     }\n+   |\n \n error: aborting due to previous error\n "}, {"sha": "8ba151d9e65fa483bd0b5dfb61fc6058ecfcdd6f", "filename": "src/test/ui/error-codes/E0004.stderr", "status": "modified", "additions": 14, "deletions": 10, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/b97dc20784698730bd7bc1a20eabdcd32066d174/src%2Ftest%2Fui%2Ferror-codes%2FE0004.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b97dc20784698730bd7bc1a20eabdcd32066d174/src%2Ftest%2Fui%2Ferror-codes%2FE0004.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ferror-codes%2FE0004.stderr?ref=b97dc20784698730bd7bc1a20eabdcd32066d174", "patch": "@@ -1,18 +1,22 @@\n error[E0004]: non-exhaustive patterns: `HastaLaVistaBaby` not covered\n   --> $DIR/E0004.rs:9:11\n    |\n-LL | / enum Terminator {\n-LL | |     HastaLaVistaBaby,\n-   | |     ---------------- not covered\n-LL | |     TalkToMyHand,\n-LL | | }\n-   | |_- `Terminator` defined here\n-...\n-LL |       match x {\n-   |             ^ pattern `HastaLaVistaBaby` not covered\n+LL |     match x {\n+   |           ^ pattern `HastaLaVistaBaby` not covered\n    |\n-   = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n+note: `Terminator` defined here\n+  --> $DIR/E0004.rs:2:5\n+   |\n+LL | enum Terminator {\n+   |      ----------\n+LL |     HastaLaVistaBaby,\n+   |     ^^^^^^^^^^^^^^^^ not covered\n    = note: the matched value is of type `Terminator`\n+help: ensure that all possible cases are being handled by adding a match arm with a wildcard pattern or an explicit pattern as shown\n+   |\n+LL ~         Terminator::TalkToMyHand => {}\n+LL +         HastaLaVistaBaby => todo!()\n+   |\n \n error: aborting due to previous error\n "}, {"sha": "208c625a53e959c7df055d372bc5c1324b2249f3", "filename": "src/test/ui/error-codes/E0005.stderr", "status": "modified", "additions": 13, "deletions": 5, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/b97dc20784698730bd7bc1a20eabdcd32066d174/src%2Ftest%2Fui%2Ferror-codes%2FE0005.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b97dc20784698730bd7bc1a20eabdcd32066d174/src%2Ftest%2Fui%2Ferror-codes%2FE0005.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ferror-codes%2FE0005.stderr?ref=b97dc20784698730bd7bc1a20eabdcd32066d174", "patch": "@@ -4,13 +4,21 @@ error[E0005]: refutable pattern in local binding: `None` not covered\n LL |     let Some(y) = x;\n    |         ^^^^^^^ pattern `None` not covered\n    |\n-  ::: $SRC_DIR/core/src/option.rs:LL:COL\n-   |\n-LL |     None,\n-   |     ---- not covered\n-   |\n    = note: `let` bindings require an \"irrefutable pattern\", like a `struct` or an `enum` with only one variant\n    = note: for more information, visit https://doc.rust-lang.org/book/ch18-02-refutability.html\n+note: `Option<i32>` defined here\n+  --> $SRC_DIR/core/src/option.rs:LL:COL\n+   |\n+LL | / pub enum Option<T> {\n+LL | |     /// No value.\n+LL | |     #[lang = \"None\"]\n+LL | |     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+LL | |     None,\n+   | |     ^^^^ not covered\n+...  |\n+LL | |     Some(#[stable(feature = \"rust1\", since = \"1.0.0\")] T),\n+LL | | }\n+   | |_-\n    = note: the matched value is of type `Option<i32>`\n help: you might want to use `if let` to ignore the variant that isn't matched\n    |"}, {"sha": "95d95003c616f60e5cf0e5bfd46673aad2afa656", "filename": "src/test/ui/error-codes/E0297.stderr", "status": "modified", "additions": 12, "deletions": 4, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/b97dc20784698730bd7bc1a20eabdcd32066d174/src%2Ftest%2Fui%2Ferror-codes%2FE0297.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b97dc20784698730bd7bc1a20eabdcd32066d174/src%2Ftest%2Fui%2Ferror-codes%2FE0297.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ferror-codes%2FE0297.stderr?ref=b97dc20784698730bd7bc1a20eabdcd32066d174", "patch": "@@ -4,11 +4,19 @@ error[E0005]: refutable pattern in `for` loop binding: `None` not covered\n LL |     for Some(x) in xs {}\n    |         ^^^^^^^ pattern `None` not covered\n    |\n-  ::: $SRC_DIR/core/src/option.rs:LL:COL\n-   |\n-LL |     None,\n-   |     ---- not covered\n+note: `Option<i32>` defined here\n+  --> $SRC_DIR/core/src/option.rs:LL:COL\n    |\n+LL | / pub enum Option<T> {\n+LL | |     /// No value.\n+LL | |     #[lang = \"None\"]\n+LL | |     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+LL | |     None,\n+   | |     ^^^^ not covered\n+...  |\n+LL | |     Some(#[stable(feature = \"rust1\", since = \"1.0.0\")] T),\n+LL | | }\n+   | |_-\n    = note: the matched value is of type `Option<i32>`\n \n error: aborting due to previous error"}, {"sha": "c2ffda6bb72d24e97dae7ce25fdcdfe0637b21d3", "filename": "src/test/ui/feature-gates/feature-gate-exhaustive-patterns.stderr", "status": "modified", "additions": 12, "deletions": 5, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/b97dc20784698730bd7bc1a20eabdcd32066d174/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-exhaustive-patterns.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b97dc20784698730bd7bc1a20eabdcd32066d174/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-exhaustive-patterns.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-exhaustive-patterns.stderr?ref=b97dc20784698730bd7bc1a20eabdcd32066d174", "patch": "@@ -4,13 +4,20 @@ error[E0005]: refutable pattern in local binding: `Err(_)` not covered\n LL |     let Ok(_x) = foo();\n    |         ^^^^^^ pattern `Err(_)` not covered\n    |\n-  ::: $SRC_DIR/core/src/result.rs:LL:COL\n-   |\n-LL |     Err(#[stable(feature = \"rust1\", since = \"1.0.0\")] E),\n-   |     --- not covered\n-   |\n    = note: `let` bindings require an \"irrefutable pattern\", like a `struct` or an `enum` with only one variant\n    = note: for more information, visit https://doc.rust-lang.org/book/ch18-02-refutability.html\n+note: `Result<u32, !>` defined here\n+  --> $SRC_DIR/core/src/result.rs:LL:COL\n+   |\n+LL | / pub enum Result<T, E> {\n+LL | |     /// Contains the success value\n+LL | |     #[lang = \"Ok\"]\n+LL | |     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+...  |\n+LL | |     Err(#[stable(feature = \"rust1\", since = \"1.0.0\")] E),\n+   | |     ^^^ not covered\n+LL | | }\n+   | |_-\n    = note: the matched value is of type `Result<u32, !>`\n help: you might want to use `if let` to ignore the variant that isn't matched\n    |"}, {"sha": "b5510683328f54097f884ca53d7c749371af823e", "filename": "src/test/ui/feature-gates/feature-gate-precise_pointer_size_matching.stderr", "status": "modified", "additions": 10, "deletions": 2, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/b97dc20784698730bd7bc1a20eabdcd32066d174/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-precise_pointer_size_matching.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b97dc20784698730bd7bc1a20eabdcd32066d174/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-precise_pointer_size_matching.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-precise_pointer_size_matching.stderr?ref=b97dc20784698730bd7bc1a20eabdcd32066d174", "patch": "@@ -4,21 +4,29 @@ error[E0004]: non-exhaustive patterns: `_` not covered\n LL |     match 0usize {\n    |           ^^^^^^ pattern `_` not covered\n    |\n-   = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n    = note: the matched value is of type `usize`\n    = note: `usize` does not have a fixed maximum value, so a wildcard `_` is necessary to match exhaustively\n    = help: add `#![feature(precise_pointer_size_matching)]` to the crate attributes to enable precise `usize` matching\n+help: ensure that all possible cases are being handled by adding a match arm with a wildcard pattern or an explicit pattern as shown\n+   |\n+LL ~         0..=usize::MAX => {}\n+LL +         _ => todo!()\n+   |\n \n error[E0004]: non-exhaustive patterns: `_` not covered\n   --> $DIR/feature-gate-precise_pointer_size_matching.rs:10:11\n    |\n LL |     match 0isize {\n    |           ^^^^^^ pattern `_` not covered\n    |\n-   = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n    = note: the matched value is of type `isize`\n    = note: `isize` does not have a fixed maximum value, so a wildcard `_` is necessary to match exhaustively\n    = help: add `#![feature(precise_pointer_size_matching)]` to the crate attributes to enable precise `isize` matching\n+help: ensure that all possible cases are being handled by adding a match arm with a wildcard pattern or an explicit pattern as shown\n+   |\n+LL ~         isize::MIN..=isize::MAX => {}\n+LL +         _ => todo!()\n+   |\n \n error: aborting due to 2 previous errors\n "}, {"sha": "667bc9f8ddf182905e5a8f9f725cc4f24f39f73c", "filename": "src/test/ui/feature-gates/feature-gate-rustc-attrs-1.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b97dc20784698730bd7bc1a20eabdcd32066d174/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-rustc-attrs-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b97dc20784698730bd7bc1a20eabdcd32066d174/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-rustc-attrs-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-rustc-attrs-1.rs?ref=b97dc20784698730bd7bc1a20eabdcd32066d174", "patch": "@@ -2,6 +2,6 @@\n \n #[rustc_variance] //~ ERROR the `#[rustc_variance]` attribute is just used for rustc unit tests and will never be stable\n #[rustc_error] //~ ERROR the `#[rustc_error]` attribute is just used for rustc unit tests and will never be stable\n-#[rustc_nonnull_optimization_guaranteed] //~ ERROR the `#[rustc_nonnull_optimization_guaranteed]` attribute is just used to enable niche optimizations in libcore and will never be stable\n+#[rustc_nonnull_optimization_guaranteed] //~ ERROR the `#[rustc_nonnull_optimization_guaranteed]` attribute is just used to enable niche optimizations in libcore and libstd and will never be stable\n \n fn main() {}"}, {"sha": "45a095903d2a7b59a39b9cabb9a0a2b6bee67558", "filename": "src/test/ui/feature-gates/feature-gate-rustc-attrs-1.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b97dc20784698730bd7bc1a20eabdcd32066d174/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-rustc-attrs-1.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b97dc20784698730bd7bc1a20eabdcd32066d174/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-rustc-attrs-1.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-rustc-attrs-1.stderr?ref=b97dc20784698730bd7bc1a20eabdcd32066d174", "patch": "@@ -14,7 +14,7 @@ LL | #[rustc_error]\n    |\n    = help: add `#![feature(rustc_attrs)]` to the crate attributes to enable\n \n-error[E0658]: the `#[rustc_nonnull_optimization_guaranteed]` attribute is just used to enable niche optimizations in libcore and will never be stable\n+error[E0658]: the `#[rustc_nonnull_optimization_guaranteed]` attribute is just used to enable niche optimizations in libcore and libstd and will never be stable\n   --> $DIR/feature-gate-rustc-attrs-1.rs:5:1\n    |\n LL | #[rustc_nonnull_optimization_guaranteed]"}, {"sha": "c2c77290c4374a59ce9c0bb157c4e2d48d6dec21", "filename": "src/test/ui/half-open-range-patterns/half-open-range-pats-exhaustive-fail.stderr", "status": "modified", "additions": 340, "deletions": 68, "changes": 408, "blob_url": "https://github.com/rust-lang/rust/blob/b97dc20784698730bd7bc1a20eabdcd32066d174/src%2Ftest%2Fui%2Fhalf-open-range-patterns%2Fhalf-open-range-pats-exhaustive-fail.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b97dc20784698730bd7bc1a20eabdcd32066d174/src%2Ftest%2Fui%2Fhalf-open-range-patterns%2Fhalf-open-range-pats-exhaustive-fail.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fhalf-open-range-patterns%2Fhalf-open-range-pats-exhaustive-fail.stderr?ref=b97dc20784698730bd7bc1a20eabdcd32066d174", "patch": "@@ -4,611 +4,883 @@ error[E0004]: non-exhaustive patterns: `_` not covered\n LL |     m!(0f32, f32::NEG_INFINITY..);\n    |        ^^^^ pattern `_` not covered\n    |\n-   = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n    = note: the matched value is of type `f32`\n+help: ensure that all possible cases are being handled by adding a match arm with a wildcard pattern or an explicit pattern as shown\n+   |\n+LL ~         match $s { $($t)+ => {}\n+LL ~         _ => todo!() }\n+   |\n \n error[E0004]: non-exhaustive patterns: `_` not covered\n   --> $DIR/half-open-range-pats-exhaustive-fail.rs:17:8\n    |\n LL |     m!(0f32, ..f32::INFINITY);\n    |        ^^^^ pattern `_` not covered\n    |\n-   = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n    = note: the matched value is of type `f32`\n+help: ensure that all possible cases are being handled by adding a match arm with a wildcard pattern or an explicit pattern as shown\n+   |\n+LL ~         match $s { $($t)+ => {}\n+LL ~         _ => todo!() }\n+   |\n \n error[E0004]: non-exhaustive patterns: `'\\u{10ffff}'` not covered\n   --> $DIR/half-open-range-pats-exhaustive-fail.rs:26:8\n    |\n LL |     m!('a', ..core::char::MAX);\n    |        ^^^ pattern `'\\u{10ffff}'` not covered\n    |\n-   = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n    = note: the matched value is of type `char`\n+help: ensure that all possible cases are being handled by adding a match arm with a wildcard pattern or an explicit pattern as shown\n+   |\n+LL ~         match $s { $($t)+ => {}\n+LL ~         '\\u{10ffff}' => todo!() }\n+   |\n \n error[E0004]: non-exhaustive patterns: `'\\u{10fffe}'..='\\u{10ffff}'` not covered\n   --> $DIR/half-open-range-pats-exhaustive-fail.rs:27:8\n    |\n LL |     m!('a', ..ALMOST_MAX);\n    |        ^^^ pattern `'\\u{10fffe}'..='\\u{10ffff}'` not covered\n    |\n-   = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n    = note: the matched value is of type `char`\n+help: ensure that all possible cases are being handled by adding a match arm with a wildcard pattern or an explicit pattern as shown\n+   |\n+LL ~         match $s { $($t)+ => {}\n+LL ~         '\\u{10fffe}'..='\\u{10ffff}' => todo!() }\n+   |\n \n error[E0004]: non-exhaustive patterns: `'\\u{0}'` not covered\n   --> $DIR/half-open-range-pats-exhaustive-fail.rs:28:8\n    |\n LL |     m!('a', ALMOST_MIN..);\n    |        ^^^ pattern `'\\u{0}'` not covered\n    |\n-   = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n    = note: the matched value is of type `char`\n+help: ensure that all possible cases are being handled by adding a match arm with a wildcard pattern or an explicit pattern as shown\n+   |\n+LL ~         match $s { $($t)+ => {}\n+LL ~         '\\u{0}' => todo!() }\n+   |\n \n error[E0004]: non-exhaustive patterns: `'\\u{10ffff}'` not covered\n   --> $DIR/half-open-range-pats-exhaustive-fail.rs:29:8\n    |\n LL |     m!('a', ..=ALMOST_MAX);\n    |        ^^^ pattern `'\\u{10ffff}'` not covered\n    |\n-   = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n    = note: the matched value is of type `char`\n+help: ensure that all possible cases are being handled by adding a match arm with a wildcard pattern or an explicit pattern as shown\n+   |\n+LL ~         match $s { $($t)+ => {}\n+LL ~         '\\u{10ffff}' => todo!() }\n+   |\n \n error[E0004]: non-exhaustive patterns: `'b'` not covered\n   --> $DIR/half-open-range-pats-exhaustive-fail.rs:30:8\n    |\n LL |     m!('a', ..=VAL | VAL_2..);\n    |        ^^^ pattern `'b'` not covered\n    |\n-   = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n    = note: the matched value is of type `char`\n+help: ensure that all possible cases are being handled by adding a match arm with a wildcard pattern or an explicit pattern as shown\n+   |\n+LL ~         match $s { $($t)+ => {}\n+LL ~         'b' => todo!() }\n+   |\n \n error[E0004]: non-exhaustive patterns: `'b'` not covered\n   --> $DIR/half-open-range-pats-exhaustive-fail.rs:31:8\n    |\n LL |     m!('a', ..VAL_1 | VAL_2..);\n    |        ^^^ pattern `'b'` not covered\n    |\n-   = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n    = note: the matched value is of type `char`\n+help: ensure that all possible cases are being handled by adding a match arm with a wildcard pattern or an explicit pattern as shown\n+   |\n+LL ~         match $s { $($t)+ => {}\n+LL ~         'b' => todo!() }\n+   |\n \n error[E0004]: non-exhaustive patterns: `u8::MAX` not covered\n   --> $DIR/half-open-range-pats-exhaustive-fail.rs:41:12\n    |\n LL |         m!(0, ..u8::MAX);\n    |            ^ pattern `u8::MAX` not covered\n    |\n-   = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n    = note: the matched value is of type `u8`\n+help: ensure that all possible cases are being handled by adding a match arm with a wildcard pattern or an explicit pattern as shown\n+   |\n+LL ~         match $s { $($t)+ => {}\n+LL ~         u8::MAX => todo!() }\n+   |\n \n error[E0004]: non-exhaustive patterns: `254_u8..=u8::MAX` not covered\n   --> $DIR/half-open-range-pats-exhaustive-fail.rs:42:12\n    |\n LL |         m!(0, ..ALMOST_MAX);\n    |            ^ pattern `254_u8..=u8::MAX` not covered\n    |\n-   = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n    = note: the matched value is of type `u8`\n+help: ensure that all possible cases are being handled by adding a match arm with a wildcard pattern or an explicit pattern as shown\n+   |\n+LL ~         match $s { $($t)+ => {}\n+LL ~         254_u8..=u8::MAX => todo!() }\n+   |\n \n error[E0004]: non-exhaustive patterns: `0_u8` not covered\n   --> $DIR/half-open-range-pats-exhaustive-fail.rs:43:12\n    |\n LL |         m!(0, ALMOST_MIN..);\n    |            ^ pattern `0_u8` not covered\n    |\n-   = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n    = note: the matched value is of type `u8`\n+help: ensure that all possible cases are being handled by adding a match arm with a wildcard pattern or an explicit pattern as shown\n+   |\n+LL ~         match $s { $($t)+ => {}\n+LL ~         0_u8 => todo!() }\n+   |\n \n error[E0004]: non-exhaustive patterns: `u8::MAX` not covered\n   --> $DIR/half-open-range-pats-exhaustive-fail.rs:44:12\n    |\n LL |         m!(0, ..=ALMOST_MAX);\n    |            ^ pattern `u8::MAX` not covered\n    |\n-   = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n    = note: the matched value is of type `u8`\n+help: ensure that all possible cases are being handled by adding a match arm with a wildcard pattern or an explicit pattern as shown\n+   |\n+LL ~         match $s { $($t)+ => {}\n+LL ~         u8::MAX => todo!() }\n+   |\n \n error[E0004]: non-exhaustive patterns: `43_u8` not covered\n   --> $DIR/half-open-range-pats-exhaustive-fail.rs:45:12\n    |\n LL |         m!(0, ..=VAL | VAL_2..);\n    |            ^ pattern `43_u8` not covered\n    |\n-   = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n    = note: the matched value is of type `u8`\n+help: ensure that all possible cases are being handled by adding a match arm with a wildcard pattern or an explicit pattern as shown\n+   |\n+LL ~         match $s { $($t)+ => {}\n+LL ~         43_u8 => todo!() }\n+   |\n \n error[E0004]: non-exhaustive patterns: `43_u8` not covered\n   --> $DIR/half-open-range-pats-exhaustive-fail.rs:46:12\n    |\n LL |         m!(0, ..VAL_1 | VAL_2..);\n    |            ^ pattern `43_u8` not covered\n    |\n-   = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n    = note: the matched value is of type `u8`\n+help: ensure that all possible cases are being handled by adding a match arm with a wildcard pattern or an explicit pattern as shown\n+   |\n+LL ~         match $s { $($t)+ => {}\n+LL ~         43_u8 => todo!() }\n+   |\n \n error[E0004]: non-exhaustive patterns: `u16::MAX` not covered\n   --> $DIR/half-open-range-pats-exhaustive-fail.rs:54:12\n    |\n LL |         m!(0, ..u16::MAX);\n    |            ^ pattern `u16::MAX` not covered\n    |\n-   = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n    = note: the matched value is of type `u16`\n+help: ensure that all possible cases are being handled by adding a match arm with a wildcard pattern or an explicit pattern as shown\n+   |\n+LL ~         match $s { $($t)+ => {}\n+LL ~         u16::MAX => todo!() }\n+   |\n \n error[E0004]: non-exhaustive patterns: `65534_u16..=u16::MAX` not covered\n   --> $DIR/half-open-range-pats-exhaustive-fail.rs:55:12\n    |\n LL |         m!(0, ..ALMOST_MAX);\n    |            ^ pattern `65534_u16..=u16::MAX` not covered\n    |\n-   = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n    = note: the matched value is of type `u16`\n+help: ensure that all possible cases are being handled by adding a match arm with a wildcard pattern or an explicit pattern as shown\n+   |\n+LL ~         match $s { $($t)+ => {}\n+LL ~         65534_u16..=u16::MAX => todo!() }\n+   |\n \n error[E0004]: non-exhaustive patterns: `0_u16` not covered\n   --> $DIR/half-open-range-pats-exhaustive-fail.rs:56:12\n    |\n LL |         m!(0, ALMOST_MIN..);\n    |            ^ pattern `0_u16` not covered\n    |\n-   = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n    = note: the matched value is of type `u16`\n+help: ensure that all possible cases are being handled by adding a match arm with a wildcard pattern or an explicit pattern as shown\n+   |\n+LL ~         match $s { $($t)+ => {}\n+LL ~         0_u16 => todo!() }\n+   |\n \n error[E0004]: non-exhaustive patterns: `u16::MAX` not covered\n   --> $DIR/half-open-range-pats-exhaustive-fail.rs:57:12\n    |\n LL |         m!(0, ..=ALMOST_MAX);\n    |            ^ pattern `u16::MAX` not covered\n    |\n-   = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n    = note: the matched value is of type `u16`\n+help: ensure that all possible cases are being handled by adding a match arm with a wildcard pattern or an explicit pattern as shown\n+   |\n+LL ~         match $s { $($t)+ => {}\n+LL ~         u16::MAX => todo!() }\n+   |\n \n error[E0004]: non-exhaustive patterns: `43_u16` not covered\n   --> $DIR/half-open-range-pats-exhaustive-fail.rs:58:12\n    |\n LL |         m!(0, ..=VAL | VAL_2..);\n    |            ^ pattern `43_u16` not covered\n    |\n-   = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n    = note: the matched value is of type `u16`\n+help: ensure that all possible cases are being handled by adding a match arm with a wildcard pattern or an explicit pattern as shown\n+   |\n+LL ~         match $s { $($t)+ => {}\n+LL ~         43_u16 => todo!() }\n+   |\n \n error[E0004]: non-exhaustive patterns: `43_u16` not covered\n   --> $DIR/half-open-range-pats-exhaustive-fail.rs:59:12\n    |\n LL |         m!(0, ..VAL_1 | VAL_2..);\n    |            ^ pattern `43_u16` not covered\n    |\n-   = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n    = note: the matched value is of type `u16`\n+help: ensure that all possible cases are being handled by adding a match arm with a wildcard pattern or an explicit pattern as shown\n+   |\n+LL ~         match $s { $($t)+ => {}\n+LL ~         43_u16 => todo!() }\n+   |\n \n error[E0004]: non-exhaustive patterns: `u32::MAX` not covered\n   --> $DIR/half-open-range-pats-exhaustive-fail.rs:67:12\n    |\n LL |         m!(0, ..u32::MAX);\n    |            ^ pattern `u32::MAX` not covered\n    |\n-   = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n    = note: the matched value is of type `u32`\n+help: ensure that all possible cases are being handled by adding a match arm with a wildcard pattern or an explicit pattern as shown\n+   |\n+LL ~         match $s { $($t)+ => {}\n+LL ~         u32::MAX => todo!() }\n+   |\n \n error[E0004]: non-exhaustive patterns: `4294967294_u32..=u32::MAX` not covered\n   --> $DIR/half-open-range-pats-exhaustive-fail.rs:68:12\n    |\n LL |         m!(0, ..ALMOST_MAX);\n    |            ^ pattern `4294967294_u32..=u32::MAX` not covered\n    |\n-   = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n    = note: the matched value is of type `u32`\n+help: ensure that all possible cases are being handled by adding a match arm with a wildcard pattern or an explicit pattern as shown\n+   |\n+LL ~         match $s { $($t)+ => {}\n+LL ~         4294967294_u32..=u32::MAX => todo!() }\n+   |\n \n error[E0004]: non-exhaustive patterns: `0_u32` not covered\n   --> $DIR/half-open-range-pats-exhaustive-fail.rs:69:12\n    |\n LL |         m!(0, ALMOST_MIN..);\n    |            ^ pattern `0_u32` not covered\n    |\n-   = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n    = note: the matched value is of type `u32`\n+help: ensure that all possible cases are being handled by adding a match arm with a wildcard pattern or an explicit pattern as shown\n+   |\n+LL ~         match $s { $($t)+ => {}\n+LL ~         0_u32 => todo!() }\n+   |\n \n error[E0004]: non-exhaustive patterns: `u32::MAX` not covered\n   --> $DIR/half-open-range-pats-exhaustive-fail.rs:70:12\n    |\n LL |         m!(0, ..=ALMOST_MAX);\n    |            ^ pattern `u32::MAX` not covered\n    |\n-   = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n    = note: the matched value is of type `u32`\n+help: ensure that all possible cases are being handled by adding a match arm with a wildcard pattern or an explicit pattern as shown\n+   |\n+LL ~         match $s { $($t)+ => {}\n+LL ~         u32::MAX => todo!() }\n+   |\n \n error[E0004]: non-exhaustive patterns: `43_u32` not covered\n   --> $DIR/half-open-range-pats-exhaustive-fail.rs:71:12\n    |\n LL |         m!(0, ..=VAL | VAL_2..);\n    |            ^ pattern `43_u32` not covered\n    |\n-   = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n    = note: the matched value is of type `u32`\n+help: ensure that all possible cases are being handled by adding a match arm with a wildcard pattern or an explicit pattern as shown\n+   |\n+LL ~         match $s { $($t)+ => {}\n+LL ~         43_u32 => todo!() }\n+   |\n \n error[E0004]: non-exhaustive patterns: `43_u32` not covered\n   --> $DIR/half-open-range-pats-exhaustive-fail.rs:72:12\n    |\n LL |         m!(0, ..VAL_1 | VAL_2..);\n    |            ^ pattern `43_u32` not covered\n    |\n-   = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n    = note: the matched value is of type `u32`\n+help: ensure that all possible cases are being handled by adding a match arm with a wildcard pattern or an explicit pattern as shown\n+   |\n+LL ~         match $s { $($t)+ => {}\n+LL ~         43_u32 => todo!() }\n+   |\n \n error[E0004]: non-exhaustive patterns: `u64::MAX` not covered\n   --> $DIR/half-open-range-pats-exhaustive-fail.rs:80:12\n    |\n LL |         m!(0, ..u64::MAX);\n    |            ^ pattern `u64::MAX` not covered\n    |\n-   = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n    = note: the matched value is of type `u64`\n+help: ensure that all possible cases are being handled by adding a match arm with a wildcard pattern or an explicit pattern as shown\n+   |\n+LL ~         match $s { $($t)+ => {}\n+LL ~         u64::MAX => todo!() }\n+   |\n \n error[E0004]: non-exhaustive patterns: `18446744073709551614_u64..=u64::MAX` not covered\n   --> $DIR/half-open-range-pats-exhaustive-fail.rs:81:12\n    |\n LL |         m!(0, ..ALMOST_MAX);\n    |            ^ pattern `18446744073709551614_u64..=u64::MAX` not covered\n    |\n-   = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n    = note: the matched value is of type `u64`\n+help: ensure that all possible cases are being handled by adding a match arm with a wildcard pattern or an explicit pattern as shown\n+   |\n+LL ~         match $s { $($t)+ => {}\n+LL ~         18446744073709551614_u64..=u64::MAX => todo!() }\n+   |\n \n error[E0004]: non-exhaustive patterns: `0_u64` not covered\n   --> $DIR/half-open-range-pats-exhaustive-fail.rs:82:12\n    |\n LL |         m!(0, ALMOST_MIN..);\n    |            ^ pattern `0_u64` not covered\n    |\n-   = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n    = note: the matched value is of type `u64`\n+help: ensure that all possible cases are being handled by adding a match arm with a wildcard pattern or an explicit pattern as shown\n+   |\n+LL ~         match $s { $($t)+ => {}\n+LL ~         0_u64 => todo!() }\n+   |\n \n error[E0004]: non-exhaustive patterns: `u64::MAX` not covered\n   --> $DIR/half-open-range-pats-exhaustive-fail.rs:83:12\n    |\n LL |         m!(0, ..=ALMOST_MAX);\n    |            ^ pattern `u64::MAX` not covered\n    |\n-   = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n    = note: the matched value is of type `u64`\n+help: ensure that all possible cases are being handled by adding a match arm with a wildcard pattern or an explicit pattern as shown\n+   |\n+LL ~         match $s { $($t)+ => {}\n+LL ~         u64::MAX => todo!() }\n+   |\n \n error[E0004]: non-exhaustive patterns: `43_u64` not covered\n   --> $DIR/half-open-range-pats-exhaustive-fail.rs:84:12\n    |\n LL |         m!(0, ..=VAL | VAL_2..);\n    |            ^ pattern `43_u64` not covered\n    |\n-   = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n    = note: the matched value is of type `u64`\n+help: ensure that all possible cases are being handled by adding a match arm with a wildcard pattern or an explicit pattern as shown\n+   |\n+LL ~         match $s { $($t)+ => {}\n+LL ~         43_u64 => todo!() }\n+   |\n \n error[E0004]: non-exhaustive patterns: `43_u64` not covered\n   --> $DIR/half-open-range-pats-exhaustive-fail.rs:85:12\n    |\n LL |         m!(0, ..VAL_1 | VAL_2..);\n    |            ^ pattern `43_u64` not covered\n    |\n-   = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n    = note: the matched value is of type `u64`\n+help: ensure that all possible cases are being handled by adding a match arm with a wildcard pattern or an explicit pattern as shown\n+   |\n+LL ~         match $s { $($t)+ => {}\n+LL ~         43_u64 => todo!() }\n+   |\n \n error[E0004]: non-exhaustive patterns: `u128::MAX` not covered\n   --> $DIR/half-open-range-pats-exhaustive-fail.rs:93:12\n    |\n LL |         m!(0, ..u128::MAX);\n    |            ^ pattern `u128::MAX` not covered\n    |\n-   = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n    = note: the matched value is of type `u128`\n+help: ensure that all possible cases are being handled by adding a match arm with a wildcard pattern or an explicit pattern as shown\n+   |\n+LL ~         match $s { $($t)+ => {}\n+LL ~         u128::MAX => todo!() }\n+   |\n \n error[E0004]: non-exhaustive patterns: `340282366920938463463374607431768211454_u128..=u128::MAX` not covered\n   --> $DIR/half-open-range-pats-exhaustive-fail.rs:94:12\n    |\n LL |         m!(0, ..ALMOST_MAX);\n    |            ^ pattern `340282366920938463463374607431768211454_u128..=u128::MAX` not covered\n    |\n-   = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n    = note: the matched value is of type `u128`\n+help: ensure that all possible cases are being handled by adding a match arm with a wildcard pattern or an explicit pattern as shown\n+   |\n+LL ~         match $s { $($t)+ => {}\n+LL ~         340282366920938463463374607431768211454_u128..=u128::MAX => todo!() }\n+   |\n \n error[E0004]: non-exhaustive patterns: `0_u128` not covered\n   --> $DIR/half-open-range-pats-exhaustive-fail.rs:95:12\n    |\n LL |         m!(0, ALMOST_MIN..);\n    |            ^ pattern `0_u128` not covered\n    |\n-   = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n    = note: the matched value is of type `u128`\n+help: ensure that all possible cases are being handled by adding a match arm with a wildcard pattern or an explicit pattern as shown\n+   |\n+LL ~         match $s { $($t)+ => {}\n+LL ~         0_u128 => todo!() }\n+   |\n \n error[E0004]: non-exhaustive patterns: `u128::MAX` not covered\n   --> $DIR/half-open-range-pats-exhaustive-fail.rs:96:12\n    |\n LL |         m!(0, ..=ALMOST_MAX);\n    |            ^ pattern `u128::MAX` not covered\n    |\n-   = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n    = note: the matched value is of type `u128`\n+help: ensure that all possible cases are being handled by adding a match arm with a wildcard pattern or an explicit pattern as shown\n+   |\n+LL ~         match $s { $($t)+ => {}\n+LL ~         u128::MAX => todo!() }\n+   |\n \n error[E0004]: non-exhaustive patterns: `43_u128` not covered\n   --> $DIR/half-open-range-pats-exhaustive-fail.rs:97:12\n    |\n LL |         m!(0, ..=VAL | VAL_2..);\n    |            ^ pattern `43_u128` not covered\n    |\n-   = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n    = note: the matched value is of type `u128`\n+help: ensure that all possible cases are being handled by adding a match arm with a wildcard pattern or an explicit pattern as shown\n+   |\n+LL ~         match $s { $($t)+ => {}\n+LL ~         43_u128 => todo!() }\n+   |\n \n error[E0004]: non-exhaustive patterns: `43_u128` not covered\n   --> $DIR/half-open-range-pats-exhaustive-fail.rs:98:12\n    |\n LL |         m!(0, ..VAL_1 | VAL_2..);\n    |            ^ pattern `43_u128` not covered\n    |\n-   = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n    = note: the matched value is of type `u128`\n+help: ensure that all possible cases are being handled by adding a match arm with a wildcard pattern or an explicit pattern as shown\n+   |\n+LL ~         match $s { $($t)+ => {}\n+LL ~         43_u128 => todo!() }\n+   |\n \n error[E0004]: non-exhaustive patterns: `i8::MAX` not covered\n   --> $DIR/half-open-range-pats-exhaustive-fail.rs:109:12\n    |\n LL |         m!(0, ..i8::MAX);\n    |            ^ pattern `i8::MAX` not covered\n    |\n-   = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n    = note: the matched value is of type `i8`\n+help: ensure that all possible cases are being handled by adding a match arm with a wildcard pattern or an explicit pattern as shown\n+   |\n+LL ~         match $s { $($t)+ => {}\n+LL ~         i8::MAX => todo!() }\n+   |\n \n error[E0004]: non-exhaustive patterns: `126_i8..=i8::MAX` not covered\n   --> $DIR/half-open-range-pats-exhaustive-fail.rs:110:12\n    |\n LL |         m!(0, ..ALMOST_MAX);\n    |            ^ pattern `126_i8..=i8::MAX` not covered\n    |\n-   = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n    = note: the matched value is of type `i8`\n+help: ensure that all possible cases are being handled by adding a match arm with a wildcard pattern or an explicit pattern as shown\n+   |\n+LL ~         match $s { $($t)+ => {}\n+LL ~         126_i8..=i8::MAX => todo!() }\n+   |\n \n error[E0004]: non-exhaustive patterns: `i8::MIN` not covered\n   --> $DIR/half-open-range-pats-exhaustive-fail.rs:111:12\n    |\n LL |         m!(0, ALMOST_MIN..);\n    |            ^ pattern `i8::MIN` not covered\n    |\n-   = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n    = note: the matched value is of type `i8`\n+help: ensure that all possible cases are being handled by adding a match arm with a wildcard pattern or an explicit pattern as shown\n+   |\n+LL ~         match $s { $($t)+ => {}\n+LL ~         i8::MIN => todo!() }\n+   |\n \n error[E0004]: non-exhaustive patterns: `i8::MAX` not covered\n   --> $DIR/half-open-range-pats-exhaustive-fail.rs:112:12\n    |\n LL |         m!(0, ..=ALMOST_MAX);\n    |            ^ pattern `i8::MAX` not covered\n    |\n-   = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n    = note: the matched value is of type `i8`\n+help: ensure that all possible cases are being handled by adding a match arm with a wildcard pattern or an explicit pattern as shown\n+   |\n+LL ~         match $s { $($t)+ => {}\n+LL ~         i8::MAX => todo!() }\n+   |\n \n error[E0004]: non-exhaustive patterns: `43_i8` not covered\n   --> $DIR/half-open-range-pats-exhaustive-fail.rs:113:12\n    |\n LL |         m!(0, ..=VAL | VAL_2..);\n    |            ^ pattern `43_i8` not covered\n    |\n-   = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n    = note: the matched value is of type `i8`\n+help: ensure that all possible cases are being handled by adding a match arm with a wildcard pattern or an explicit pattern as shown\n+   |\n+LL ~         match $s { $($t)+ => {}\n+LL ~         43_i8 => todo!() }\n+   |\n \n error[E0004]: non-exhaustive patterns: `43_i8` not covered\n   --> $DIR/half-open-range-pats-exhaustive-fail.rs:114:12\n    |\n LL |         m!(0, ..VAL_1 | VAL_2..);\n    |            ^ pattern `43_i8` not covered\n    |\n-   = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n    = note: the matched value is of type `i8`\n+help: ensure that all possible cases are being handled by adding a match arm with a wildcard pattern or an explicit pattern as shown\n+   |\n+LL ~         match $s { $($t)+ => {}\n+LL ~         43_i8 => todo!() }\n+   |\n \n error[E0004]: non-exhaustive patterns: `i16::MAX` not covered\n   --> $DIR/half-open-range-pats-exhaustive-fail.rs:122:12\n    |\n LL |         m!(0, ..i16::MAX);\n    |            ^ pattern `i16::MAX` not covered\n    |\n-   = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n    = note: the matched value is of type `i16`\n+help: ensure that all possible cases are being handled by adding a match arm with a wildcard pattern or an explicit pattern as shown\n+   |\n+LL ~         match $s { $($t)+ => {}\n+LL ~         i16::MAX => todo!() }\n+   |\n \n error[E0004]: non-exhaustive patterns: `32766_i16..=i16::MAX` not covered\n   --> $DIR/half-open-range-pats-exhaustive-fail.rs:123:12\n    |\n LL |         m!(0, ..ALMOST_MAX);\n    |            ^ pattern `32766_i16..=i16::MAX` not covered\n    |\n-   = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n    = note: the matched value is of type `i16`\n+help: ensure that all possible cases are being handled by adding a match arm with a wildcard pattern or an explicit pattern as shown\n+   |\n+LL ~         match $s { $($t)+ => {}\n+LL ~         32766_i16..=i16::MAX => todo!() }\n+   |\n \n error[E0004]: non-exhaustive patterns: `i16::MIN` not covered\n   --> $DIR/half-open-range-pats-exhaustive-fail.rs:124:12\n    |\n LL |         m!(0, ALMOST_MIN..);\n    |            ^ pattern `i16::MIN` not covered\n    |\n-   = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n    = note: the matched value is of type `i16`\n+help: ensure that all possible cases are being handled by adding a match arm with a wildcard pattern or an explicit pattern as shown\n+   |\n+LL ~         match $s { $($t)+ => {}\n+LL ~         i16::MIN => todo!() }\n+   |\n \n error[E0004]: non-exhaustive patterns: `i16::MAX` not covered\n   --> $DIR/half-open-range-pats-exhaustive-fail.rs:125:12\n    |\n LL |         m!(0, ..=ALMOST_MAX);\n    |            ^ pattern `i16::MAX` not covered\n    |\n-   = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n    = note: the matched value is of type `i16`\n+help: ensure that all possible cases are being handled by adding a match arm with a wildcard pattern or an explicit pattern as shown\n+   |\n+LL ~         match $s { $($t)+ => {}\n+LL ~         i16::MAX => todo!() }\n+   |\n \n error[E0004]: non-exhaustive patterns: `43_i16` not covered\n   --> $DIR/half-open-range-pats-exhaustive-fail.rs:126:12\n    |\n LL |         m!(0, ..=VAL | VAL_2..);\n    |            ^ pattern `43_i16` not covered\n    |\n-   = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n    = note: the matched value is of type `i16`\n+help: ensure that all possible cases are being handled by adding a match arm with a wildcard pattern or an explicit pattern as shown\n+   |\n+LL ~         match $s { $($t)+ => {}\n+LL ~         43_i16 => todo!() }\n+   |\n \n error[E0004]: non-exhaustive patterns: `43_i16` not covered\n   --> $DIR/half-open-range-pats-exhaustive-fail.rs:127:12\n    |\n LL |         m!(0, ..VAL_1 | VAL_2..);\n    |            ^ pattern `43_i16` not covered\n    |\n-   = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n    = note: the matched value is of type `i16`\n+help: ensure that all possible cases are being handled by adding a match arm with a wildcard pattern or an explicit pattern as shown\n+   |\n+LL ~         match $s { $($t)+ => {}\n+LL ~         43_i16 => todo!() }\n+   |\n \n error[E0004]: non-exhaustive patterns: `i32::MAX` not covered\n   --> $DIR/half-open-range-pats-exhaustive-fail.rs:135:12\n    |\n LL |         m!(0, ..i32::MAX);\n    |            ^ pattern `i32::MAX` not covered\n    |\n-   = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n    = note: the matched value is of type `i32`\n+help: ensure that all possible cases are being handled by adding a match arm with a wildcard pattern or an explicit pattern as shown\n+   |\n+LL ~         match $s { $($t)+ => {}\n+LL ~         i32::MAX => todo!() }\n+   |\n \n error[E0004]: non-exhaustive patterns: `2147483646_i32..=i32::MAX` not covered\n   --> $DIR/half-open-range-pats-exhaustive-fail.rs:136:12\n    |\n LL |         m!(0, ..ALMOST_MAX);\n    |            ^ pattern `2147483646_i32..=i32::MAX` not covered\n    |\n-   = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n    = note: the matched value is of type `i32`\n+help: ensure that all possible cases are being handled by adding a match arm with a wildcard pattern or an explicit pattern as shown\n+   |\n+LL ~         match $s { $($t)+ => {}\n+LL ~         2147483646_i32..=i32::MAX => todo!() }\n+   |\n \n error[E0004]: non-exhaustive patterns: `i32::MIN` not covered\n   --> $DIR/half-open-range-pats-exhaustive-fail.rs:137:12\n    |\n LL |         m!(0, ALMOST_MIN..);\n    |            ^ pattern `i32::MIN` not covered\n    |\n-   = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n    = note: the matched value is of type `i32`\n+help: ensure that all possible cases are being handled by adding a match arm with a wildcard pattern or an explicit pattern as shown\n+   |\n+LL ~         match $s { $($t)+ => {}\n+LL ~         i32::MIN => todo!() }\n+   |\n \n error[E0004]: non-exhaustive patterns: `i32::MAX` not covered\n   --> $DIR/half-open-range-pats-exhaustive-fail.rs:138:12\n    |\n LL |         m!(0, ..=ALMOST_MAX);\n    |            ^ pattern `i32::MAX` not covered\n    |\n-   = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n    = note: the matched value is of type `i32`\n+help: ensure that all possible cases are being handled by adding a match arm with a wildcard pattern or an explicit pattern as shown\n+   |\n+LL ~         match $s { $($t)+ => {}\n+LL ~         i32::MAX => todo!() }\n+   |\n \n error[E0004]: non-exhaustive patterns: `43_i32` not covered\n   --> $DIR/half-open-range-pats-exhaustive-fail.rs:139:12\n    |\n LL |         m!(0, ..=VAL | VAL_2..);\n    |            ^ pattern `43_i32` not covered\n    |\n-   = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n    = note: the matched value is of type `i32`\n+help: ensure that all possible cases are being handled by adding a match arm with a wildcard pattern or an explicit pattern as shown\n+   |\n+LL ~         match $s { $($t)+ => {}\n+LL ~         43_i32 => todo!() }\n+   |\n \n error[E0004]: non-exhaustive patterns: `43_i32` not covered\n   --> $DIR/half-open-range-pats-exhaustive-fail.rs:140:12\n    |\n LL |         m!(0, ..VAL_1 | VAL_2..);\n    |            ^ pattern `43_i32` not covered\n    |\n-   = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n    = note: the matched value is of type `i32`\n+help: ensure that all possible cases are being handled by adding a match arm with a wildcard pattern or an explicit pattern as shown\n+   |\n+LL ~         match $s { $($t)+ => {}\n+LL ~         43_i32 => todo!() }\n+   |\n \n error[E0004]: non-exhaustive patterns: `i64::MAX` not covered\n   --> $DIR/half-open-range-pats-exhaustive-fail.rs:148:12\n    |\n LL |         m!(0, ..i64::MAX);\n    |            ^ pattern `i64::MAX` not covered\n    |\n-   = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n    = note: the matched value is of type `i64`\n+help: ensure that all possible cases are being handled by adding a match arm with a wildcard pattern or an explicit pattern as shown\n+   |\n+LL ~         match $s { $($t)+ => {}\n+LL ~         i64::MAX => todo!() }\n+   |\n \n error[E0004]: non-exhaustive patterns: `9223372036854775806_i64..=i64::MAX` not covered\n   --> $DIR/half-open-range-pats-exhaustive-fail.rs:149:12\n    |\n LL |         m!(0, ..ALMOST_MAX);\n    |            ^ pattern `9223372036854775806_i64..=i64::MAX` not covered\n    |\n-   = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n    = note: the matched value is of type `i64`\n+help: ensure that all possible cases are being handled by adding a match arm with a wildcard pattern or an explicit pattern as shown\n+   |\n+LL ~         match $s { $($t)+ => {}\n+LL ~         9223372036854775806_i64..=i64::MAX => todo!() }\n+   |\n \n error[E0004]: non-exhaustive patterns: `i64::MIN` not covered\n   --> $DIR/half-open-range-pats-exhaustive-fail.rs:150:12\n    |\n LL |         m!(0, ALMOST_MIN..);\n    |            ^ pattern `i64::MIN` not covered\n    |\n-   = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n    = note: the matched value is of type `i64`\n+help: ensure that all possible cases are being handled by adding a match arm with a wildcard pattern or an explicit pattern as shown\n+   |\n+LL ~         match $s { $($t)+ => {}\n+LL ~         i64::MIN => todo!() }\n+   |\n \n error[E0004]: non-exhaustive patterns: `i64::MAX` not covered\n   --> $DIR/half-open-range-pats-exhaustive-fail.rs:151:12\n    |\n LL |         m!(0, ..=ALMOST_MAX);\n    |            ^ pattern `i64::MAX` not covered\n    |\n-   = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n    = note: the matched value is of type `i64`\n+help: ensure that all possible cases are being handled by adding a match arm with a wildcard pattern or an explicit pattern as shown\n+   |\n+LL ~         match $s { $($t)+ => {}\n+LL ~         i64::MAX => todo!() }\n+   |\n \n error[E0004]: non-exhaustive patterns: `43_i64` not covered\n   --> $DIR/half-open-range-pats-exhaustive-fail.rs:152:12\n    |\n LL |         m!(0, ..=VAL | VAL_2..);\n    |            ^ pattern `43_i64` not covered\n    |\n-   = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n    = note: the matched value is of type `i64`\n+help: ensure that all possible cases are being handled by adding a match arm with a wildcard pattern or an explicit pattern as shown\n+   |\n+LL ~         match $s { $($t)+ => {}\n+LL ~         43_i64 => todo!() }\n+   |\n \n error[E0004]: non-exhaustive patterns: `43_i64` not covered\n   --> $DIR/half-open-range-pats-exhaustive-fail.rs:153:12\n    |\n LL |         m!(0, ..VAL_1 | VAL_2..);\n    |            ^ pattern `43_i64` not covered\n    |\n-   = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n    = note: the matched value is of type `i64`\n+help: ensure that all possible cases are being handled by adding a match arm with a wildcard pattern or an explicit pattern as shown\n+   |\n+LL ~         match $s { $($t)+ => {}\n+LL ~         43_i64 => todo!() }\n+   |\n \n error[E0004]: non-exhaustive patterns: `i128::MAX` not covered\n   --> $DIR/half-open-range-pats-exhaustive-fail.rs:161:12\n    |\n LL |         m!(0, ..i128::MAX);\n    |            ^ pattern `i128::MAX` not covered\n    |\n-   = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n    = note: the matched value is of type `i128`\n+help: ensure that all possible cases are being handled by adding a match arm with a wildcard pattern or an explicit pattern as shown\n+   |\n+LL ~         match $s { $($t)+ => {}\n+LL ~         i128::MAX => todo!() }\n+   |\n \n error[E0004]: non-exhaustive patterns: `170141183460469231731687303715884105726_i128..=i128::MAX` not covered\n   --> $DIR/half-open-range-pats-exhaustive-fail.rs:162:12\n    |\n LL |         m!(0, ..ALMOST_MAX);\n    |            ^ pattern `170141183460469231731687303715884105726_i128..=i128::MAX` not covered\n    |\n-   = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n    = note: the matched value is of type `i128`\n+help: ensure that all possible cases are being handled by adding a match arm with a wildcard pattern or an explicit pattern as shown\n+   |\n+LL ~         match $s { $($t)+ => {}\n+LL ~         170141183460469231731687303715884105726_i128..=i128::MAX => todo!() }\n+   |\n \n error[E0004]: non-exhaustive patterns: `i128::MIN` not covered\n   --> $DIR/half-open-range-pats-exhaustive-fail.rs:163:12\n    |\n LL |         m!(0, ALMOST_MIN..);\n    |            ^ pattern `i128::MIN` not covered\n    |\n-   = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n    = note: the matched value is of type `i128`\n+help: ensure that all possible cases are being handled by adding a match arm with a wildcard pattern or an explicit pattern as shown\n+   |\n+LL ~         match $s { $($t)+ => {}\n+LL ~         i128::MIN => todo!() }\n+   |\n \n error[E0004]: non-exhaustive patterns: `i128::MAX` not covered\n   --> $DIR/half-open-range-pats-exhaustive-fail.rs:164:12\n    |\n LL |         m!(0, ..=ALMOST_MAX);\n    |            ^ pattern `i128::MAX` not covered\n    |\n-   = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n    = note: the matched value is of type `i128`\n+help: ensure that all possible cases are being handled by adding a match arm with a wildcard pattern or an explicit pattern as shown\n+   |\n+LL ~         match $s { $($t)+ => {}\n+LL ~         i128::MAX => todo!() }\n+   |\n \n error[E0004]: non-exhaustive patterns: `43_i128` not covered\n   --> $DIR/half-open-range-pats-exhaustive-fail.rs:165:12\n    |\n LL |         m!(0, ..=VAL | VAL_2..);\n    |            ^ pattern `43_i128` not covered\n    |\n-   = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n    = note: the matched value is of type `i128`\n+help: ensure that all possible cases are being handled by adding a match arm with a wildcard pattern or an explicit pattern as shown\n+   |\n+LL ~         match $s { $($t)+ => {}\n+LL ~         43_i128 => todo!() }\n+   |\n \n error[E0004]: non-exhaustive patterns: `43_i128` not covered\n   --> $DIR/half-open-range-pats-exhaustive-fail.rs:166:12\n    |\n LL |         m!(0, ..VAL_1 | VAL_2..);\n    |            ^ pattern `43_i128` not covered\n    |\n-   = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n    = note: the matched value is of type `i128`\n+help: ensure that all possible cases are being handled by adding a match arm with a wildcard pattern or an explicit pattern as shown\n+   |\n+LL ~         match $s { $($t)+ => {}\n+LL ~         43_i128 => todo!() }\n+   |\n \n error: aborting due to 68 previous errors\n "}, {"sha": "362c67dafd2c5e88c7d050ba45e0bdbcbdcfb7d3", "filename": "src/test/ui/impl-trait/issues/issue-79099.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b97dc20784698730bd7bc1a20eabdcd32066d174/src%2Ftest%2Fui%2Fimpl-trait%2Fissues%2Fissue-79099.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b97dc20784698730bd7bc1a20eabdcd32066d174/src%2Ftest%2Fui%2Fimpl-trait%2Fissues%2Fissue-79099.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fissues%2Fissue-79099.stderr?ref=b97dc20784698730bd7bc1a20eabdcd32066d174", "patch": "@@ -6,7 +6,7 @@ LL |         let f: impl core::future::Future<Output = u8> = async { 1 };\n    |                                                         |\n    |                                                         `async` blocks are only allowed in Rust 2018 or later\n    |\n-   = help: set `edition = \"2021\"` in `Cargo.toml`\n+   = help: pass `--edition 2021` to `rustc`\n    = note: for more on editions, read https://doc.rust-lang.org/edition-guide\n \n error[E0562]: `impl Trait` only allowed in function and inherent method return types, not in variable binding"}, {"sha": "bafdea96e08dfd474acd26bb0c39e96dd433b6c6", "filename": "src/test/ui/lint/rfc-2383-lint-reason/lint-attribute-only-with-reason.rs", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/b97dc20784698730bd7bc1a20eabdcd32066d174/src%2Ftest%2Fui%2Flint%2Frfc-2383-lint-reason%2Flint-attribute-only-with-reason.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b97dc20784698730bd7bc1a20eabdcd32066d174/src%2Ftest%2Fui%2Flint%2Frfc-2383-lint-reason%2Flint-attribute-only-with-reason.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flint%2Frfc-2383-lint-reason%2Flint-attribute-only-with-reason.rs?ref=b97dc20784698730bd7bc1a20eabdcd32066d174", "patch": "@@ -0,0 +1,14 @@\n+#![feature(lint_reasons)]\n+\n+#![deny(unused_attributes)]\n+\n+#[allow(reason = \"I want to allow something\")]//~ ERROR unused attribute\n+#[expect(reason = \"I don't know what I'm waiting for\")]//~ ERROR unused attribute\n+#[warn(reason = \"This should be warn by default\")]//~ ERROR unused attribute\n+#[deny(reason = \"All listed lints are denied\")]//~ ERROR unused attribute\n+#[forbid(reason = \"Just some reason\")]//~ ERROR unused attribute\n+\n+#[allow(clippy::box_collection, reason = \"This is still valid\")]\n+#[warn(dead_code, reason = \"This is also reasonable\")]\n+\n+fn main() {}"}, {"sha": "3bf8137dc6e40ca028b0032ba73b6b0c7a73c730", "filename": "src/test/ui/lint/rfc-2383-lint-reason/lint-attribute-only-with-reason.stderr", "status": "added", "additions": 47, "deletions": 0, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/b97dc20784698730bd7bc1a20eabdcd32066d174/src%2Ftest%2Fui%2Flint%2Frfc-2383-lint-reason%2Flint-attribute-only-with-reason.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b97dc20784698730bd7bc1a20eabdcd32066d174/src%2Ftest%2Fui%2Flint%2Frfc-2383-lint-reason%2Flint-attribute-only-with-reason.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flint%2Frfc-2383-lint-reason%2Flint-attribute-only-with-reason.stderr?ref=b97dc20784698730bd7bc1a20eabdcd32066d174", "patch": "@@ -0,0 +1,47 @@\n+error: unused attribute\n+  --> $DIR/lint-attribute-only-with-reason.rs:5:1\n+   |\n+LL | #[allow(reason = \"I want to allow something\")]\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: remove this attribute\n+   |\n+note: the lint level is defined here\n+  --> $DIR/lint-attribute-only-with-reason.rs:3:9\n+   |\n+LL | #![deny(unused_attributes)]\n+   |         ^^^^^^^^^^^^^^^^^\n+   = note: attribute `allow` without any lints has no effect\n+\n+error: unused attribute\n+  --> $DIR/lint-attribute-only-with-reason.rs:6:1\n+   |\n+LL | #[expect(reason = \"I don't know what I'm waiting for\")]\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: remove this attribute\n+   |\n+   = note: attribute `expect` without any lints has no effect\n+\n+error: unused attribute\n+  --> $DIR/lint-attribute-only-with-reason.rs:7:1\n+   |\n+LL | #[warn(reason = \"This should be warn by default\")]\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: remove this attribute\n+   |\n+   = note: attribute `warn` without any lints has no effect\n+\n+error: unused attribute\n+  --> $DIR/lint-attribute-only-with-reason.rs:8:1\n+   |\n+LL | #[deny(reason = \"All listed lints are denied\")]\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: remove this attribute\n+   |\n+   = note: attribute `deny` without any lints has no effect\n+\n+error: unused attribute\n+  --> $DIR/lint-attribute-only-with-reason.rs:9:1\n+   |\n+LL | #[forbid(reason = \"Just some reason\")]\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: remove this attribute\n+   |\n+   = note: attribute `forbid` without any lints has no effect\n+\n+error: aborting due to 5 previous errors\n+"}, {"sha": "6206dc85ea05f81c72ab6854ef03416a232cbcb5", "filename": "src/test/ui/match/match_non_exhaustive.stderr", "status": "modified", "additions": 29, "deletions": 9, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/b97dc20784698730bd7bc1a20eabdcd32066d174/src%2Ftest%2Fui%2Fmatch%2Fmatch_non_exhaustive.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b97dc20784698730bd7bc1a20eabdcd32066d174/src%2Ftest%2Fui%2Fmatch%2Fmatch_non_exhaustive.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmatch%2Fmatch_non_exhaustive.stderr?ref=b97dc20784698730bd7bc1a20eabdcd32066d174", "patch": "@@ -1,35 +1,55 @@\n error[E0004]: non-exhaustive patterns: `B` not covered\n   --> $DIR/match_non_exhaustive.rs:23:11\n    |\n-LL | enum L { A, B }\n-   | ---------------\n-   | |           |\n-   | |           not covered\n-   | `L` defined here\n-...\n LL |     match l { L::A => () };\n    |           ^ pattern `B` not covered\n    |\n-   = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n+note: `L` defined here\n+  --> $DIR/match_non_exhaustive.rs:10:13\n+   |\n+LL | enum L { A, B }\n+   |      -      ^ not covered\n    = note: the matched value is of type `L`\n+help: ensure that all possible cases are being handled by adding a match arm with a wildcard pattern or an explicit pattern as shown\n+   |\n+LL |     match l { L::A => (), B => todo!() };\n+   |                         ++++++++++++++\n \n error[E0004]: non-exhaustive patterns: type `E1` is non-empty\n   --> $DIR/match_non_exhaustive.rs:28:11\n    |\n LL |     match e1 {};\n    |           ^^\n    |\n-   = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n+note: `E1` defined here\n+  --> $DIR/auxiliary/match_non_exhaustive_lib.rs:2:1\n+   |\n+LL | pub enum E1 {}\n+   | ^^^^^^^^^^^^^^\n    = note: the matched value is of type `E1`, which is marked as non-exhaustive\n+help: ensure that all possible cases are being handled by adding a match arm with a wildcard pattern as shown\n+   |\n+LL ~     match e1 {\n+LL +         _ => todo!(),\n+LL ~     };\n+   |\n \n error[E0004]: non-exhaustive patterns: `_` not covered\n   --> $DIR/match_non_exhaustive.rs:30:11\n    |\n LL |     match e2 { E2::A => (), E2::B => () };\n    |           ^^ pattern `_` not covered\n    |\n-   = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n+note: `E2` defined here\n+  --> $DIR/auxiliary/match_non_exhaustive_lib.rs:5:1\n+   |\n+LL | pub enum E2 { A, B }\n+   | ^^^^^^^^^^^^^^^^^^^^\n    = note: the matched value is of type `E2`, which is marked as non-exhaustive\n+help: ensure that all possible cases are being handled by adding a match arm with a wildcard pattern or an explicit pattern as shown\n+   |\n+LL |     match e2 { E2::A => (), E2::B => (), _ => todo!() };\n+   |                                        ++++++++++++++\n \n error: aborting due to 3 previous errors\n "}, {"sha": "9aa808e6bc9a69db9b07d19d49e945961335ce92", "filename": "src/test/ui/or-patterns/exhaustiveness-non-exhaustive.stderr", "status": "modified", "additions": 15, "deletions": 3, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/b97dc20784698730bd7bc1a20eabdcd32066d174/src%2Ftest%2Fui%2For-patterns%2Fexhaustiveness-non-exhaustive.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b97dc20784698730bd7bc1a20eabdcd32066d174/src%2Ftest%2Fui%2For-patterns%2Fexhaustiveness-non-exhaustive.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2For-patterns%2Fexhaustiveness-non-exhaustive.stderr?ref=b97dc20784698730bd7bc1a20eabdcd32066d174", "patch": "@@ -4,26 +4,38 @@ error[E0004]: non-exhaustive patterns: `(2_u8..=u8::MAX, _)` not covered\n LL |     match (0u8, 0u8) {\n    |           ^^^^^^^^^^ pattern `(2_u8..=u8::MAX, _)` not covered\n    |\n-   = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n    = note: the matched value is of type `(u8, u8)`\n+help: ensure that all possible cases are being handled by adding a match arm with a wildcard pattern or an explicit pattern as shown\n+   |\n+LL ~         (0 | 1, 2 | 3) => {}\n+LL +         (2_u8..=u8::MAX, _) => todo!()\n+   |\n \n error[E0004]: non-exhaustive patterns: `((4_u8..=u8::MAX))` not covered\n   --> $DIR/exhaustiveness-non-exhaustive.rs:9:11\n    |\n LL |     match ((0u8,),) {\n    |           ^^^^^^^^^ pattern `((4_u8..=u8::MAX))` not covered\n    |\n-   = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n    = note: the matched value is of type `((u8,),)`\n+help: ensure that all possible cases are being handled by adding a match arm with a wildcard pattern or an explicit pattern as shown\n+   |\n+LL ~         ((0 | 1,) | (2 | 3,),) => {}\n+LL +         ((4_u8..=u8::MAX)) => todo!()\n+   |\n \n error[E0004]: non-exhaustive patterns: `(Some(2_u8..=u8::MAX))` not covered\n   --> $DIR/exhaustiveness-non-exhaustive.rs:13:11\n    |\n LL |     match (Some(0u8),) {\n    |           ^^^^^^^^^^^^ pattern `(Some(2_u8..=u8::MAX))` not covered\n    |\n-   = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n    = note: the matched value is of type `(Option<u8>,)`\n+help: ensure that all possible cases are being handled by adding a match arm with a wildcard pattern or an explicit pattern as shown\n+   |\n+LL ~         (None | Some(0 | 1),) => {}\n+LL +         (Some(2_u8..=u8::MAX)) => todo!()\n+   |\n \n error: aborting due to 3 previous errors\n "}, {"sha": "37a35700b36d5731ebc544d4e1de7a2ad5c43263", "filename": "src/test/ui/or-patterns/issue-69875-should-have-been-expanded-earlier-non-exhaustive.stderr", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b97dc20784698730bd7bc1a20eabdcd32066d174/src%2Ftest%2Fui%2For-patterns%2Fissue-69875-should-have-been-expanded-earlier-non-exhaustive.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b97dc20784698730bd7bc1a20eabdcd32066d174/src%2Ftest%2Fui%2For-patterns%2Fissue-69875-should-have-been-expanded-earlier-non-exhaustive.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2For-patterns%2Fissue-69875-should-have-been-expanded-earlier-non-exhaustive.stderr?ref=b97dc20784698730bd7bc1a20eabdcd32066d174", "patch": "@@ -18,8 +18,12 @@ error[E0004]: non-exhaustive patterns: `i32::MIN..=-1_i32` and `3_i32..=i32::MAX\n LL |     match 0 {\n    |           ^ patterns `i32::MIN..=-1_i32` and `3_i32..=i32::MAX` not covered\n    |\n-   = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n    = note: the matched value is of type `i32`\n+help: ensure that all possible cases are being handled by adding a match arm with a wildcard pattern, a match arm with multiple or-patterns as shown, or multiple match arms\n+   |\n+LL ~         0 | (1 | 2) => {}\n+LL +         i32::MIN..=-1_i32 | 3_i32..=i32::MAX => todo!()\n+   |\n \n error: aborting due to 2 previous errors\n "}, {"sha": "cd5c283f9fd93c75c4d551c900317d2b29ecfde0", "filename": "src/test/ui/pattern/usefulness/always-inhabited-union-ref.stderr", "status": "modified", "additions": 19, "deletions": 9, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/b97dc20784698730bd7bc1a20eabdcd32066d174/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Falways-inhabited-union-ref.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b97dc20784698730bd7bc1a20eabdcd32066d174/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Falways-inhabited-union-ref.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Falways-inhabited-union-ref.stderr?ref=b97dc20784698730bd7bc1a20eabdcd32066d174", "patch": "@@ -4,23 +4,33 @@ error[E0004]: non-exhaustive patterns: type `&!` is non-empty\n LL |     match uninhab_ref() {\n    |           ^^^^^^^^^^^^^\n    |\n-   = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n    = note: the matched value is of type `&!`\n    = note: references are always considered inhabited\n+help: ensure that all possible cases are being handled by adding a match arm with a wildcard pattern as shown\n+   |\n+LL ~     match uninhab_ref() {\n+LL +         _ => todo!(),\n+LL +     }\n+   |\n \n error[E0004]: non-exhaustive patterns: type `Foo` is non-empty\n   --> $DIR/always-inhabited-union-ref.rs:27:11\n    |\n-LL | / pub union Foo {\n-LL | |     foo: !,\n-LL | | }\n-   | |_- `Foo` defined here\n-...\n-LL |       match uninhab_union() {\n-   |             ^^^^^^^^^^^^^^^\n+LL |     match uninhab_union() {\n+   |           ^^^^^^^^^^^^^^^\n+   |\n+note: `Foo` defined here\n+  --> $DIR/always-inhabited-union-ref.rs:10:11\n    |\n-   = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n+LL | pub union Foo {\n+   |           ^^^\n    = note: the matched value is of type `Foo`\n+help: ensure that all possible cases are being handled by adding a match arm with a wildcard pattern as shown\n+   |\n+LL ~     match uninhab_union() {\n+LL +         _ => todo!(),\n+LL +     }\n+   |\n \n error: aborting due to 2 previous errors\n "}, {"sha": "7d0b71a497ec2f91f0fb290bf18f9f74a77cb900", "filename": "src/test/ui/pattern/usefulness/doc-hidden-non-exhaustive.stderr", "status": "modified", "additions": 61, "deletions": 16, "changes": 77, "blob_url": "https://github.com/rust-lang/rust/blob/b97dc20784698730bd7bc1a20eabdcd32066d174/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fdoc-hidden-non-exhaustive.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b97dc20784698730bd7bc1a20eabdcd32066d174/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fdoc-hidden-non-exhaustive.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fdoc-hidden-non-exhaustive.stderr?ref=b97dc20784698730bd7bc1a20eabdcd32066d174", "patch": "@@ -4,50 +4,95 @@ error[E0004]: non-exhaustive patterns: `_` not covered\n LL |     match Foo::A {\n    |           ^^^^^^ pattern `_` not covered\n    |\n-   = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n+note: `Foo` defined here\n+  --> $DIR/auxiliary/hidden.rs:1:1\n+   |\n+LL | / pub enum Foo {\n+LL | |     A,\n+LL | |     B,\n+LL | |     #[doc(hidden)]\n+LL | |     C,\n+LL | | }\n+   | |_^\n    = note: the matched value is of type `Foo`\n+help: ensure that all possible cases are being handled by adding a match arm with a wildcard pattern or an explicit pattern as shown\n+   |\n+LL ~         Foo::B => {}\n+LL +         _ => todo!()\n+   |\n \n error[E0004]: non-exhaustive patterns: `B` not covered\n   --> $DIR/doc-hidden-non-exhaustive.rs:14:11\n    |\n LL |     match Foo::A {\n    |           ^^^^^^ pattern `B` not covered\n    |\n-  ::: $DIR/auxiliary/hidden.rs:3:5\n+note: `Foo` defined here\n+  --> $DIR/auxiliary/hidden.rs:3:5\n    |\n-LL |     B,\n-   |     - not covered\n-   |\n-   = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n+LL | / pub enum Foo {\n+LL | |     A,\n+LL | |     B,\n+   | |     ^ not covered\n+LL | |     #[doc(hidden)]\n+LL | |     C,\n+LL | | }\n+   | |_-\n    = note: the matched value is of type `Foo`\n+help: ensure that all possible cases are being handled by adding a match arm with a wildcard pattern or an explicit pattern as shown\n+   |\n+LL ~         Foo::C => {}\n+LL +         B => todo!()\n+   |\n \n error[E0004]: non-exhaustive patterns: `B` and `_` not covered\n   --> $DIR/doc-hidden-non-exhaustive.rs:20:11\n    |\n LL |     match Foo::A {\n    |           ^^^^^^ patterns `B` and `_` not covered\n    |\n-  ::: $DIR/auxiliary/hidden.rs:3:5\n+note: `Foo` defined here\n+  --> $DIR/auxiliary/hidden.rs:3:5\n    |\n-LL |     B,\n-   |     - not covered\n-   |\n-   = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n+LL | / pub enum Foo {\n+LL | |     A,\n+LL | |     B,\n+   | |     ^ not covered\n+LL | |     #[doc(hidden)]\n+LL | |     C,\n+LL | | }\n+   | |_-\n    = note: the matched value is of type `Foo`\n+help: ensure that all possible cases are being handled by adding a match arm with a wildcard pattern, a match arm with multiple or-patterns as shown, or multiple match arms\n+   |\n+LL ~         Foo::A => {}\n+LL +         B | _ => todo!()\n+   |\n \n error[E0004]: non-exhaustive patterns: `Some(B)` and `Some(_)` not covered\n   --> $DIR/doc-hidden-non-exhaustive.rs:25:11\n    |\n LL |     match None {\n    |           ^^^^ patterns `Some(B)` and `Some(_)` not covered\n    |\n-  ::: $SRC_DIR/core/src/option.rs:LL:COL\n+note: `Option<Foo>` defined here\n+  --> $SRC_DIR/core/src/option.rs:LL:COL\n    |\n-LL |     Some(#[stable(feature = \"rust1\", since = \"1.0.0\")] T),\n-   |     ---- not covered\n-   |\n-   = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n+LL | / pub enum Option<T> {\n+LL | |     /// No value.\n+LL | |     #[lang = \"None\"]\n+LL | |     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+...  |\n+LL | |     Some(#[stable(feature = \"rust1\", since = \"1.0.0\")] T),\n+   | |     ^^^^ not covered\n+LL | | }\n+   | |_-\n    = note: the matched value is of type `Option<Foo>`\n+help: ensure that all possible cases are being handled by adding a match arm with a wildcard pattern, a match arm with multiple or-patterns as shown, or multiple match arms\n+   |\n+LL ~         Some(Foo::A) => {}\n+LL +         Some(B) | Some(_) => todo!()\n+   |\n \n error: aborting due to 4 previous errors\n "}, {"sha": "d31ee0dbd14e5a032c8327c20a244021f269b4a2", "filename": "src/test/ui/pattern/usefulness/empty-match.exhaustive_patterns.stderr", "status": "modified", "additions": 152, "deletions": 110, "changes": 262, "blob_url": "https://github.com/rust-lang/rust/blob/b97dc20784698730bd7bc1a20eabdcd32066d174/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fempty-match.exhaustive_patterns.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b97dc20784698730bd7bc1a20eabdcd32066d174/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fempty-match.exhaustive_patterns.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fempty-match.exhaustive_patterns.stderr?ref=b97dc20784698730bd7bc1a20eabdcd32066d174", "patch": "@@ -46,215 +46,257 @@ error[E0004]: non-exhaustive patterns: type `u8` is non-empty\n LL |     match_no_arms!(0u8);\n    |                    ^^^\n    |\n-   = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n    = note: the matched value is of type `u8`\n+   = help: ensure that all possible cases are being handled by adding a match arm with a wildcard pattern\n \n error[E0004]: non-exhaustive patterns: type `NonEmptyStruct1` is non-empty\n   --> $DIR/empty-match.rs:79:20\n    |\n-LL | struct NonEmptyStruct1;\n-   | ----------------------- `NonEmptyStruct1` defined here\n-...\n LL |     match_no_arms!(NonEmptyStruct1);\n    |                    ^^^^^^^^^^^^^^^\n    |\n-   = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n+note: `NonEmptyStruct1` defined here\n+  --> $DIR/empty-match.rs:14:8\n+   |\n+LL | struct NonEmptyStruct1;\n+   |        ^^^^^^^^^^^^^^^\n    = note: the matched value is of type `NonEmptyStruct1`\n+   = help: ensure that all possible cases are being handled by adding a match arm with a wildcard pattern\n \n error[E0004]: non-exhaustive patterns: type `NonEmptyStruct2` is non-empty\n   --> $DIR/empty-match.rs:80:20\n    |\n-LL | struct NonEmptyStruct2(bool);\n-   | ----------------------------- `NonEmptyStruct2` defined here\n-...\n LL |     match_no_arms!(NonEmptyStruct2(true));\n    |                    ^^^^^^^^^^^^^^^^^^^^^\n    |\n-   = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n+note: `NonEmptyStruct2` defined here\n+  --> $DIR/empty-match.rs:15:8\n+   |\n+LL | struct NonEmptyStruct2(bool);\n+   |        ^^^^^^^^^^^^^^^\n    = note: the matched value is of type `NonEmptyStruct2`\n+   = help: ensure that all possible cases are being handled by adding a match arm with a wildcard pattern\n \n error[E0004]: non-exhaustive patterns: type `NonEmptyUnion1` is non-empty\n   --> $DIR/empty-match.rs:81:20\n    |\n-LL | / union NonEmptyUnion1 {\n-LL | |     foo: (),\n-LL | | }\n-   | |_- `NonEmptyUnion1` defined here\n-...\n-LL |       match_no_arms!((NonEmptyUnion1 { foo: () }));\n-   |                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+LL |     match_no_arms!((NonEmptyUnion1 { foo: () }));\n+   |                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+note: `NonEmptyUnion1` defined here\n+  --> $DIR/empty-match.rs:16:7\n    |\n-   = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n+LL | union NonEmptyUnion1 {\n+   |       ^^^^^^^^^^^^^^\n    = note: the matched value is of type `NonEmptyUnion1`\n+   = help: ensure that all possible cases are being handled by adding a match arm with a wildcard pattern\n \n error[E0004]: non-exhaustive patterns: type `NonEmptyUnion2` is non-empty\n   --> $DIR/empty-match.rs:82:20\n    |\n-LL | / union NonEmptyUnion2 {\n-LL | |     foo: (),\n-LL | |     bar: (),\n-LL | | }\n-   | |_- `NonEmptyUnion2` defined here\n-...\n-LL |       match_no_arms!((NonEmptyUnion2 { foo: () }));\n-   |                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+LL |     match_no_arms!((NonEmptyUnion2 { foo: () }));\n+   |                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+note: `NonEmptyUnion2` defined here\n+  --> $DIR/empty-match.rs:19:7\n    |\n-   = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n+LL | union NonEmptyUnion2 {\n+   |       ^^^^^^^^^^^^^^\n    = note: the matched value is of type `NonEmptyUnion2`\n+   = help: ensure that all possible cases are being handled by adding a match arm with a wildcard pattern\n \n error[E0004]: non-exhaustive patterns: `Foo(_)` not covered\n   --> $DIR/empty-match.rs:83:20\n    |\n-LL | / enum NonEmptyEnum1 {\n-LL | |     Foo(bool),\n-   | |     --- not covered\n-LL | | }\n-   | |_- `NonEmptyEnum1` defined here\n-...\n-LL |       match_no_arms!(NonEmptyEnum1::Foo(true));\n-   |                      ^^^^^^^^^^^^^^^^^^^^^^^^ pattern `Foo(_)` not covered\n+LL |     match_no_arms!(NonEmptyEnum1::Foo(true));\n+   |                    ^^^^^^^^^^^^^^^^^^^^^^^^ pattern `Foo(_)` not covered\n    |\n-   = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n+note: `NonEmptyEnum1` defined here\n+  --> $DIR/empty-match.rs:24:5\n+   |\n+LL | enum NonEmptyEnum1 {\n+   |      -------------\n+LL |     Foo(bool),\n+   |     ^^^ not covered\n    = note: the matched value is of type `NonEmptyEnum1`\n+   = help: ensure that all possible cases are being handled by adding a match arm with a wildcard pattern or an explicit pattern\n \n error[E0004]: non-exhaustive patterns: `Foo(_)` and `Bar` not covered\n   --> $DIR/empty-match.rs:84:20\n    |\n-LL | / enum NonEmptyEnum2 {\n-LL | |     Foo(bool),\n-   | |     --- not covered\n-LL | |     Bar,\n-   | |     --- not covered\n-LL | | }\n-   | |_- `NonEmptyEnum2` defined here\n-...\n-LL |       match_no_arms!(NonEmptyEnum2::Foo(true));\n-   |                      ^^^^^^^^^^^^^^^^^^^^^^^^ patterns `Foo(_)` and `Bar` not covered\n-   |\n-   = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n+LL |     match_no_arms!(NonEmptyEnum2::Foo(true));\n+   |                    ^^^^^^^^^^^^^^^^^^^^^^^^ patterns `Foo(_)` and `Bar` not covered\n+   |\n+note: `NonEmptyEnum2` defined here\n+  --> $DIR/empty-match.rs:27:5\n+   |\n+LL | enum NonEmptyEnum2 {\n+   |      -------------\n+LL |     Foo(bool),\n+   |     ^^^ not covered\n+LL |     Bar,\n+   |     ^^^ not covered\n    = note: the matched value is of type `NonEmptyEnum2`\n+   = help: ensure that all possible cases are being handled by adding a match arm with a wildcard pattern or multiple match arms\n \n error[E0004]: non-exhaustive patterns: `V1`, `V2`, `V3` and 2 more not covered\n   --> $DIR/empty-match.rs:85:20\n    |\n-LL | / enum NonEmptyEnum5 {\n-LL | |     V1, V2, V3, V4, V5,\n-LL | | }\n-   | |_- `NonEmptyEnum5` defined here\n-...\n-LL |       match_no_arms!(NonEmptyEnum5::V1);\n-   |                      ^^^^^^^^^^^^^^^^^ patterns `V1`, `V2`, `V3` and 2 more not covered\n+LL |     match_no_arms!(NonEmptyEnum5::V1);\n+   |                    ^^^^^^^^^^^^^^^^^ patterns `V1`, `V2`, `V3` and 2 more not covered\n+   |\n+note: `NonEmptyEnum5` defined here\n+  --> $DIR/empty-match.rs:30:6\n    |\n-   = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n+LL | enum NonEmptyEnum5 {\n+   |      ^^^^^^^^^^^^^\n    = note: the matched value is of type `NonEmptyEnum5`\n+   = help: ensure that all possible cases are being handled by adding a match arm with a wildcard pattern or multiple match arms\n \n error[E0004]: non-exhaustive patterns: `_` not covered\n   --> $DIR/empty-match.rs:87:24\n    |\n LL |     match_guarded_arm!(0u8);\n    |                        ^^^ pattern `_` not covered\n    |\n-   = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n    = note: the matched value is of type `u8`\n+help: ensure that all possible cases are being handled by adding a match arm with a wildcard pattern or an explicit pattern as shown\n+   |\n+LL ~             _ if false => {}\n+LL +             _ => todo!()\n+   |\n \n error[E0004]: non-exhaustive patterns: `NonEmptyStruct1` not covered\n   --> $DIR/empty-match.rs:88:24\n    |\n-LL | struct NonEmptyStruct1;\n-   | ----------------------- `NonEmptyStruct1` defined here\n-...\n LL |     match_guarded_arm!(NonEmptyStruct1);\n    |                        ^^^^^^^^^^^^^^^ pattern `NonEmptyStruct1` not covered\n    |\n-   = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n+note: `NonEmptyStruct1` defined here\n+  --> $DIR/empty-match.rs:14:8\n+   |\n+LL | struct NonEmptyStruct1;\n+   |        ^^^^^^^^^^^^^^^\n    = note: the matched value is of type `NonEmptyStruct1`\n+help: ensure that all possible cases are being handled by adding a match arm with a wildcard pattern or an explicit pattern as shown\n+   |\n+LL ~             _ if false => {}\n+LL +             NonEmptyStruct1 => todo!()\n+   |\n \n error[E0004]: non-exhaustive patterns: `NonEmptyStruct2(_)` not covered\n   --> $DIR/empty-match.rs:89:24\n    |\n-LL | struct NonEmptyStruct2(bool);\n-   | ----------------------------- `NonEmptyStruct2` defined here\n-...\n LL |     match_guarded_arm!(NonEmptyStruct2(true));\n    |                        ^^^^^^^^^^^^^^^^^^^^^ pattern `NonEmptyStruct2(_)` not covered\n    |\n-   = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n+note: `NonEmptyStruct2` defined here\n+  --> $DIR/empty-match.rs:15:8\n+   |\n+LL | struct NonEmptyStruct2(bool);\n+   |        ^^^^^^^^^^^^^^^\n    = note: the matched value is of type `NonEmptyStruct2`\n+help: ensure that all possible cases are being handled by adding a match arm with a wildcard pattern or an explicit pattern as shown\n+   |\n+LL ~             _ if false => {}\n+LL +             NonEmptyStruct2(_) => todo!()\n+   |\n \n error[E0004]: non-exhaustive patterns: `NonEmptyUnion1 { .. }` not covered\n   --> $DIR/empty-match.rs:90:24\n    |\n-LL | / union NonEmptyUnion1 {\n-LL | |     foo: (),\n-LL | | }\n-   | |_- `NonEmptyUnion1` defined here\n-...\n-LL |       match_guarded_arm!((NonEmptyUnion1 { foo: () }));\n-   |                          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ pattern `NonEmptyUnion1 { .. }` not covered\n+LL |     match_guarded_arm!((NonEmptyUnion1 { foo: () }));\n+   |                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ pattern `NonEmptyUnion1 { .. }` not covered\n+   |\n+note: `NonEmptyUnion1` defined here\n+  --> $DIR/empty-match.rs:16:7\n    |\n-   = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n+LL | union NonEmptyUnion1 {\n+   |       ^^^^^^^^^^^^^^\n    = note: the matched value is of type `NonEmptyUnion1`\n+help: ensure that all possible cases are being handled by adding a match arm with a wildcard pattern or an explicit pattern as shown\n+   |\n+LL ~             _ if false => {}\n+LL +             NonEmptyUnion1 { .. } => todo!()\n+   |\n \n error[E0004]: non-exhaustive patterns: `NonEmptyUnion2 { .. }` not covered\n   --> $DIR/empty-match.rs:91:24\n    |\n-LL | / union NonEmptyUnion2 {\n-LL | |     foo: (),\n-LL | |     bar: (),\n-LL | | }\n-   | |_- `NonEmptyUnion2` defined here\n-...\n-LL |       match_guarded_arm!((NonEmptyUnion2 { foo: () }));\n-   |                          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ pattern `NonEmptyUnion2 { .. }` not covered\n+LL |     match_guarded_arm!((NonEmptyUnion2 { foo: () }));\n+   |                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ pattern `NonEmptyUnion2 { .. }` not covered\n+   |\n+note: `NonEmptyUnion2` defined here\n+  --> $DIR/empty-match.rs:19:7\n    |\n-   = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n+LL | union NonEmptyUnion2 {\n+   |       ^^^^^^^^^^^^^^\n    = note: the matched value is of type `NonEmptyUnion2`\n+help: ensure that all possible cases are being handled by adding a match arm with a wildcard pattern or an explicit pattern as shown\n+   |\n+LL ~             _ if false => {}\n+LL +             NonEmptyUnion2 { .. } => todo!()\n+   |\n \n error[E0004]: non-exhaustive patterns: `Foo(_)` not covered\n   --> $DIR/empty-match.rs:92:24\n    |\n-LL | / enum NonEmptyEnum1 {\n-LL | |     Foo(bool),\n-   | |     --- not covered\n-LL | | }\n-   | |_- `NonEmptyEnum1` defined here\n-...\n-LL |       match_guarded_arm!(NonEmptyEnum1::Foo(true));\n-   |                          ^^^^^^^^^^^^^^^^^^^^^^^^ pattern `Foo(_)` not covered\n+LL |     match_guarded_arm!(NonEmptyEnum1::Foo(true));\n+   |                        ^^^^^^^^^^^^^^^^^^^^^^^^ pattern `Foo(_)` not covered\n    |\n-   = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n+note: `NonEmptyEnum1` defined here\n+  --> $DIR/empty-match.rs:24:5\n+   |\n+LL | enum NonEmptyEnum1 {\n+   |      -------------\n+LL |     Foo(bool),\n+   |     ^^^ not covered\n    = note: the matched value is of type `NonEmptyEnum1`\n+help: ensure that all possible cases are being handled by adding a match arm with a wildcard pattern or an explicit pattern as shown\n+   |\n+LL ~             _ if false => {}\n+LL +             Foo(_) => todo!()\n+   |\n \n error[E0004]: non-exhaustive patterns: `Foo(_)` and `Bar` not covered\n   --> $DIR/empty-match.rs:93:24\n    |\n-LL | / enum NonEmptyEnum2 {\n-LL | |     Foo(bool),\n-   | |     --- not covered\n-LL | |     Bar,\n-   | |     --- not covered\n-LL | | }\n-   | |_- `NonEmptyEnum2` defined here\n-...\n-LL |       match_guarded_arm!(NonEmptyEnum2::Foo(true));\n-   |                          ^^^^^^^^^^^^^^^^^^^^^^^^ patterns `Foo(_)` and `Bar` not covered\n-   |\n-   = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n+LL |     match_guarded_arm!(NonEmptyEnum2::Foo(true));\n+   |                        ^^^^^^^^^^^^^^^^^^^^^^^^ patterns `Foo(_)` and `Bar` not covered\n+   |\n+note: `NonEmptyEnum2` defined here\n+  --> $DIR/empty-match.rs:27:5\n+   |\n+LL | enum NonEmptyEnum2 {\n+   |      -------------\n+LL |     Foo(bool),\n+   |     ^^^ not covered\n+LL |     Bar,\n+   |     ^^^ not covered\n    = note: the matched value is of type `NonEmptyEnum2`\n+help: ensure that all possible cases are being handled by adding a match arm with a wildcard pattern, a match arm with multiple or-patterns as shown, or multiple match arms\n+   |\n+LL ~             _ if false => {}\n+LL +             Foo(_) | Bar => todo!()\n+   |\n \n error[E0004]: non-exhaustive patterns: `V1`, `V2`, `V3` and 2 more not covered\n   --> $DIR/empty-match.rs:94:24\n    |\n-LL | / enum NonEmptyEnum5 {\n-LL | |     V1, V2, V3, V4, V5,\n-LL | | }\n-   | |_- `NonEmptyEnum5` defined here\n-...\n-LL |       match_guarded_arm!(NonEmptyEnum5::V1);\n-   |                          ^^^^^^^^^^^^^^^^^ patterns `V1`, `V2`, `V3` and 2 more not covered\n+LL |     match_guarded_arm!(NonEmptyEnum5::V1);\n+   |                        ^^^^^^^^^^^^^^^^^ patterns `V1`, `V2`, `V3` and 2 more not covered\n+   |\n+note: `NonEmptyEnum5` defined here\n+  --> $DIR/empty-match.rs:30:6\n    |\n-   = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n+LL | enum NonEmptyEnum5 {\n+   |      ^^^^^^^^^^^^^\n    = note: the matched value is of type `NonEmptyEnum5`\n+help: ensure that all possible cases are being handled by adding a match arm with a wildcard pattern as shown, or multiple match arms\n+   |\n+LL ~             _ if false => {}\n+LL +             _ => todo!()\n+   |\n \n error: aborting due to 22 previous errors\n "}, {"sha": "d31ee0dbd14e5a032c8327c20a244021f269b4a2", "filename": "src/test/ui/pattern/usefulness/empty-match.normal.stderr", "status": "modified", "additions": 152, "deletions": 110, "changes": 262, "blob_url": "https://github.com/rust-lang/rust/blob/b97dc20784698730bd7bc1a20eabdcd32066d174/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fempty-match.normal.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b97dc20784698730bd7bc1a20eabdcd32066d174/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fempty-match.normal.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fempty-match.normal.stderr?ref=b97dc20784698730bd7bc1a20eabdcd32066d174", "patch": "@@ -46,215 +46,257 @@ error[E0004]: non-exhaustive patterns: type `u8` is non-empty\n LL |     match_no_arms!(0u8);\n    |                    ^^^\n    |\n-   = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n    = note: the matched value is of type `u8`\n+   = help: ensure that all possible cases are being handled by adding a match arm with a wildcard pattern\n \n error[E0004]: non-exhaustive patterns: type `NonEmptyStruct1` is non-empty\n   --> $DIR/empty-match.rs:79:20\n    |\n-LL | struct NonEmptyStruct1;\n-   | ----------------------- `NonEmptyStruct1` defined here\n-...\n LL |     match_no_arms!(NonEmptyStruct1);\n    |                    ^^^^^^^^^^^^^^^\n    |\n-   = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n+note: `NonEmptyStruct1` defined here\n+  --> $DIR/empty-match.rs:14:8\n+   |\n+LL | struct NonEmptyStruct1;\n+   |        ^^^^^^^^^^^^^^^\n    = note: the matched value is of type `NonEmptyStruct1`\n+   = help: ensure that all possible cases are being handled by adding a match arm with a wildcard pattern\n \n error[E0004]: non-exhaustive patterns: type `NonEmptyStruct2` is non-empty\n   --> $DIR/empty-match.rs:80:20\n    |\n-LL | struct NonEmptyStruct2(bool);\n-   | ----------------------------- `NonEmptyStruct2` defined here\n-...\n LL |     match_no_arms!(NonEmptyStruct2(true));\n    |                    ^^^^^^^^^^^^^^^^^^^^^\n    |\n-   = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n+note: `NonEmptyStruct2` defined here\n+  --> $DIR/empty-match.rs:15:8\n+   |\n+LL | struct NonEmptyStruct2(bool);\n+   |        ^^^^^^^^^^^^^^^\n    = note: the matched value is of type `NonEmptyStruct2`\n+   = help: ensure that all possible cases are being handled by adding a match arm with a wildcard pattern\n \n error[E0004]: non-exhaustive patterns: type `NonEmptyUnion1` is non-empty\n   --> $DIR/empty-match.rs:81:20\n    |\n-LL | / union NonEmptyUnion1 {\n-LL | |     foo: (),\n-LL | | }\n-   | |_- `NonEmptyUnion1` defined here\n-...\n-LL |       match_no_arms!((NonEmptyUnion1 { foo: () }));\n-   |                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+LL |     match_no_arms!((NonEmptyUnion1 { foo: () }));\n+   |                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+note: `NonEmptyUnion1` defined here\n+  --> $DIR/empty-match.rs:16:7\n    |\n-   = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n+LL | union NonEmptyUnion1 {\n+   |       ^^^^^^^^^^^^^^\n    = note: the matched value is of type `NonEmptyUnion1`\n+   = help: ensure that all possible cases are being handled by adding a match arm with a wildcard pattern\n \n error[E0004]: non-exhaustive patterns: type `NonEmptyUnion2` is non-empty\n   --> $DIR/empty-match.rs:82:20\n    |\n-LL | / union NonEmptyUnion2 {\n-LL | |     foo: (),\n-LL | |     bar: (),\n-LL | | }\n-   | |_- `NonEmptyUnion2` defined here\n-...\n-LL |       match_no_arms!((NonEmptyUnion2 { foo: () }));\n-   |                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+LL |     match_no_arms!((NonEmptyUnion2 { foo: () }));\n+   |                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+note: `NonEmptyUnion2` defined here\n+  --> $DIR/empty-match.rs:19:7\n    |\n-   = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n+LL | union NonEmptyUnion2 {\n+   |       ^^^^^^^^^^^^^^\n    = note: the matched value is of type `NonEmptyUnion2`\n+   = help: ensure that all possible cases are being handled by adding a match arm with a wildcard pattern\n \n error[E0004]: non-exhaustive patterns: `Foo(_)` not covered\n   --> $DIR/empty-match.rs:83:20\n    |\n-LL | / enum NonEmptyEnum1 {\n-LL | |     Foo(bool),\n-   | |     --- not covered\n-LL | | }\n-   | |_- `NonEmptyEnum1` defined here\n-...\n-LL |       match_no_arms!(NonEmptyEnum1::Foo(true));\n-   |                      ^^^^^^^^^^^^^^^^^^^^^^^^ pattern `Foo(_)` not covered\n+LL |     match_no_arms!(NonEmptyEnum1::Foo(true));\n+   |                    ^^^^^^^^^^^^^^^^^^^^^^^^ pattern `Foo(_)` not covered\n    |\n-   = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n+note: `NonEmptyEnum1` defined here\n+  --> $DIR/empty-match.rs:24:5\n+   |\n+LL | enum NonEmptyEnum1 {\n+   |      -------------\n+LL |     Foo(bool),\n+   |     ^^^ not covered\n    = note: the matched value is of type `NonEmptyEnum1`\n+   = help: ensure that all possible cases are being handled by adding a match arm with a wildcard pattern or an explicit pattern\n \n error[E0004]: non-exhaustive patterns: `Foo(_)` and `Bar` not covered\n   --> $DIR/empty-match.rs:84:20\n    |\n-LL | / enum NonEmptyEnum2 {\n-LL | |     Foo(bool),\n-   | |     --- not covered\n-LL | |     Bar,\n-   | |     --- not covered\n-LL | | }\n-   | |_- `NonEmptyEnum2` defined here\n-...\n-LL |       match_no_arms!(NonEmptyEnum2::Foo(true));\n-   |                      ^^^^^^^^^^^^^^^^^^^^^^^^ patterns `Foo(_)` and `Bar` not covered\n-   |\n-   = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n+LL |     match_no_arms!(NonEmptyEnum2::Foo(true));\n+   |                    ^^^^^^^^^^^^^^^^^^^^^^^^ patterns `Foo(_)` and `Bar` not covered\n+   |\n+note: `NonEmptyEnum2` defined here\n+  --> $DIR/empty-match.rs:27:5\n+   |\n+LL | enum NonEmptyEnum2 {\n+   |      -------------\n+LL |     Foo(bool),\n+   |     ^^^ not covered\n+LL |     Bar,\n+   |     ^^^ not covered\n    = note: the matched value is of type `NonEmptyEnum2`\n+   = help: ensure that all possible cases are being handled by adding a match arm with a wildcard pattern or multiple match arms\n \n error[E0004]: non-exhaustive patterns: `V1`, `V2`, `V3` and 2 more not covered\n   --> $DIR/empty-match.rs:85:20\n    |\n-LL | / enum NonEmptyEnum5 {\n-LL | |     V1, V2, V3, V4, V5,\n-LL | | }\n-   | |_- `NonEmptyEnum5` defined here\n-...\n-LL |       match_no_arms!(NonEmptyEnum5::V1);\n-   |                      ^^^^^^^^^^^^^^^^^ patterns `V1`, `V2`, `V3` and 2 more not covered\n+LL |     match_no_arms!(NonEmptyEnum5::V1);\n+   |                    ^^^^^^^^^^^^^^^^^ patterns `V1`, `V2`, `V3` and 2 more not covered\n+   |\n+note: `NonEmptyEnum5` defined here\n+  --> $DIR/empty-match.rs:30:6\n    |\n-   = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n+LL | enum NonEmptyEnum5 {\n+   |      ^^^^^^^^^^^^^\n    = note: the matched value is of type `NonEmptyEnum5`\n+   = help: ensure that all possible cases are being handled by adding a match arm with a wildcard pattern or multiple match arms\n \n error[E0004]: non-exhaustive patterns: `_` not covered\n   --> $DIR/empty-match.rs:87:24\n    |\n LL |     match_guarded_arm!(0u8);\n    |                        ^^^ pattern `_` not covered\n    |\n-   = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n    = note: the matched value is of type `u8`\n+help: ensure that all possible cases are being handled by adding a match arm with a wildcard pattern or an explicit pattern as shown\n+   |\n+LL ~             _ if false => {}\n+LL +             _ => todo!()\n+   |\n \n error[E0004]: non-exhaustive patterns: `NonEmptyStruct1` not covered\n   --> $DIR/empty-match.rs:88:24\n    |\n-LL | struct NonEmptyStruct1;\n-   | ----------------------- `NonEmptyStruct1` defined here\n-...\n LL |     match_guarded_arm!(NonEmptyStruct1);\n    |                        ^^^^^^^^^^^^^^^ pattern `NonEmptyStruct1` not covered\n    |\n-   = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n+note: `NonEmptyStruct1` defined here\n+  --> $DIR/empty-match.rs:14:8\n+   |\n+LL | struct NonEmptyStruct1;\n+   |        ^^^^^^^^^^^^^^^\n    = note: the matched value is of type `NonEmptyStruct1`\n+help: ensure that all possible cases are being handled by adding a match arm with a wildcard pattern or an explicit pattern as shown\n+   |\n+LL ~             _ if false => {}\n+LL +             NonEmptyStruct1 => todo!()\n+   |\n \n error[E0004]: non-exhaustive patterns: `NonEmptyStruct2(_)` not covered\n   --> $DIR/empty-match.rs:89:24\n    |\n-LL | struct NonEmptyStruct2(bool);\n-   | ----------------------------- `NonEmptyStruct2` defined here\n-...\n LL |     match_guarded_arm!(NonEmptyStruct2(true));\n    |                        ^^^^^^^^^^^^^^^^^^^^^ pattern `NonEmptyStruct2(_)` not covered\n    |\n-   = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n+note: `NonEmptyStruct2` defined here\n+  --> $DIR/empty-match.rs:15:8\n+   |\n+LL | struct NonEmptyStruct2(bool);\n+   |        ^^^^^^^^^^^^^^^\n    = note: the matched value is of type `NonEmptyStruct2`\n+help: ensure that all possible cases are being handled by adding a match arm with a wildcard pattern or an explicit pattern as shown\n+   |\n+LL ~             _ if false => {}\n+LL +             NonEmptyStruct2(_) => todo!()\n+   |\n \n error[E0004]: non-exhaustive patterns: `NonEmptyUnion1 { .. }` not covered\n   --> $DIR/empty-match.rs:90:24\n    |\n-LL | / union NonEmptyUnion1 {\n-LL | |     foo: (),\n-LL | | }\n-   | |_- `NonEmptyUnion1` defined here\n-...\n-LL |       match_guarded_arm!((NonEmptyUnion1 { foo: () }));\n-   |                          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ pattern `NonEmptyUnion1 { .. }` not covered\n+LL |     match_guarded_arm!((NonEmptyUnion1 { foo: () }));\n+   |                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ pattern `NonEmptyUnion1 { .. }` not covered\n+   |\n+note: `NonEmptyUnion1` defined here\n+  --> $DIR/empty-match.rs:16:7\n    |\n-   = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n+LL | union NonEmptyUnion1 {\n+   |       ^^^^^^^^^^^^^^\n    = note: the matched value is of type `NonEmptyUnion1`\n+help: ensure that all possible cases are being handled by adding a match arm with a wildcard pattern or an explicit pattern as shown\n+   |\n+LL ~             _ if false => {}\n+LL +             NonEmptyUnion1 { .. } => todo!()\n+   |\n \n error[E0004]: non-exhaustive patterns: `NonEmptyUnion2 { .. }` not covered\n   --> $DIR/empty-match.rs:91:24\n    |\n-LL | / union NonEmptyUnion2 {\n-LL | |     foo: (),\n-LL | |     bar: (),\n-LL | | }\n-   | |_- `NonEmptyUnion2` defined here\n-...\n-LL |       match_guarded_arm!((NonEmptyUnion2 { foo: () }));\n-   |                          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ pattern `NonEmptyUnion2 { .. }` not covered\n+LL |     match_guarded_arm!((NonEmptyUnion2 { foo: () }));\n+   |                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ pattern `NonEmptyUnion2 { .. }` not covered\n+   |\n+note: `NonEmptyUnion2` defined here\n+  --> $DIR/empty-match.rs:19:7\n    |\n-   = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n+LL | union NonEmptyUnion2 {\n+   |       ^^^^^^^^^^^^^^\n    = note: the matched value is of type `NonEmptyUnion2`\n+help: ensure that all possible cases are being handled by adding a match arm with a wildcard pattern or an explicit pattern as shown\n+   |\n+LL ~             _ if false => {}\n+LL +             NonEmptyUnion2 { .. } => todo!()\n+   |\n \n error[E0004]: non-exhaustive patterns: `Foo(_)` not covered\n   --> $DIR/empty-match.rs:92:24\n    |\n-LL | / enum NonEmptyEnum1 {\n-LL | |     Foo(bool),\n-   | |     --- not covered\n-LL | | }\n-   | |_- `NonEmptyEnum1` defined here\n-...\n-LL |       match_guarded_arm!(NonEmptyEnum1::Foo(true));\n-   |                          ^^^^^^^^^^^^^^^^^^^^^^^^ pattern `Foo(_)` not covered\n+LL |     match_guarded_arm!(NonEmptyEnum1::Foo(true));\n+   |                        ^^^^^^^^^^^^^^^^^^^^^^^^ pattern `Foo(_)` not covered\n    |\n-   = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n+note: `NonEmptyEnum1` defined here\n+  --> $DIR/empty-match.rs:24:5\n+   |\n+LL | enum NonEmptyEnum1 {\n+   |      -------------\n+LL |     Foo(bool),\n+   |     ^^^ not covered\n    = note: the matched value is of type `NonEmptyEnum1`\n+help: ensure that all possible cases are being handled by adding a match arm with a wildcard pattern or an explicit pattern as shown\n+   |\n+LL ~             _ if false => {}\n+LL +             Foo(_) => todo!()\n+   |\n \n error[E0004]: non-exhaustive patterns: `Foo(_)` and `Bar` not covered\n   --> $DIR/empty-match.rs:93:24\n    |\n-LL | / enum NonEmptyEnum2 {\n-LL | |     Foo(bool),\n-   | |     --- not covered\n-LL | |     Bar,\n-   | |     --- not covered\n-LL | | }\n-   | |_- `NonEmptyEnum2` defined here\n-...\n-LL |       match_guarded_arm!(NonEmptyEnum2::Foo(true));\n-   |                          ^^^^^^^^^^^^^^^^^^^^^^^^ patterns `Foo(_)` and `Bar` not covered\n-   |\n-   = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n+LL |     match_guarded_arm!(NonEmptyEnum2::Foo(true));\n+   |                        ^^^^^^^^^^^^^^^^^^^^^^^^ patterns `Foo(_)` and `Bar` not covered\n+   |\n+note: `NonEmptyEnum2` defined here\n+  --> $DIR/empty-match.rs:27:5\n+   |\n+LL | enum NonEmptyEnum2 {\n+   |      -------------\n+LL |     Foo(bool),\n+   |     ^^^ not covered\n+LL |     Bar,\n+   |     ^^^ not covered\n    = note: the matched value is of type `NonEmptyEnum2`\n+help: ensure that all possible cases are being handled by adding a match arm with a wildcard pattern, a match arm with multiple or-patterns as shown, or multiple match arms\n+   |\n+LL ~             _ if false => {}\n+LL +             Foo(_) | Bar => todo!()\n+   |\n \n error[E0004]: non-exhaustive patterns: `V1`, `V2`, `V3` and 2 more not covered\n   --> $DIR/empty-match.rs:94:24\n    |\n-LL | / enum NonEmptyEnum5 {\n-LL | |     V1, V2, V3, V4, V5,\n-LL | | }\n-   | |_- `NonEmptyEnum5` defined here\n-...\n-LL |       match_guarded_arm!(NonEmptyEnum5::V1);\n-   |                          ^^^^^^^^^^^^^^^^^ patterns `V1`, `V2`, `V3` and 2 more not covered\n+LL |     match_guarded_arm!(NonEmptyEnum5::V1);\n+   |                        ^^^^^^^^^^^^^^^^^ patterns `V1`, `V2`, `V3` and 2 more not covered\n+   |\n+note: `NonEmptyEnum5` defined here\n+  --> $DIR/empty-match.rs:30:6\n    |\n-   = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n+LL | enum NonEmptyEnum5 {\n+   |      ^^^^^^^^^^^^^\n    = note: the matched value is of type `NonEmptyEnum5`\n+help: ensure that all possible cases are being handled by adding a match arm with a wildcard pattern as shown, or multiple match arms\n+   |\n+LL ~             _ if false => {}\n+LL +             _ => todo!()\n+   |\n \n error: aborting due to 22 previous errors\n "}, {"sha": "c926e50b3580bd58d0b003d833588687e0c05dd8", "filename": "src/test/ui/pattern/usefulness/floats.stderr", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b97dc20784698730bd7bc1a20eabdcd32066d174/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Ffloats.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b97dc20784698730bd7bc1a20eabdcd32066d174/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Ffloats.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Ffloats.stderr?ref=b97dc20784698730bd7bc1a20eabdcd32066d174", "patch": "@@ -4,8 +4,12 @@ error[E0004]: non-exhaustive patterns: `_` not covered\n LL |     match 0.0 {\n    |           ^^^ pattern `_` not covered\n    |\n-   = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n    = note: the matched value is of type `f64`\n+help: ensure that all possible cases are being handled by adding a match arm with a wildcard pattern or an explicit pattern as shown\n+   |\n+LL ~       0.0..=1.0 => {}\n+LL +       _ => todo!()\n+   |\n \n error: unreachable pattern\n   --> $DIR/floats.rs:16:7"}, {"sha": "0c1563c160c1c092928918ed492b2b5e358a468b", "filename": "src/test/ui/pattern/usefulness/guards.stderr", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b97dc20784698730bd7bc1a20eabdcd32066d174/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fguards.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b97dc20784698730bd7bc1a20eabdcd32066d174/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fguards.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fguards.stderr?ref=b97dc20784698730bd7bc1a20eabdcd32066d174", "patch": "@@ -4,8 +4,12 @@ error[E0004]: non-exhaustive patterns: `128_u8..=u8::MAX` not covered\n LL |     match 0u8 {\n    |           ^^^ pattern `128_u8..=u8::MAX` not covered\n    |\n-   = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n    = note: the matched value is of type `u8`\n+help: ensure that all possible cases are being handled by adding a match arm with a wildcard pattern or an explicit pattern as shown\n+   |\n+LL ~         128 ..= 255 if true => {}\n+LL +         128_u8..=u8::MAX => todo!()\n+   |\n \n error: aborting due to previous error\n "}, {"sha": "fec54e89d63cf091f175dd0ea06581584e6bced9", "filename": "src/test/ui/pattern/usefulness/integer-ranges/exhaustiveness.stderr", "status": "modified", "additions": 60, "deletions": 12, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/b97dc20784698730bd7bc1a20eabdcd32066d174/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Finteger-ranges%2Fexhaustiveness.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b97dc20784698730bd7bc1a20eabdcd32066d174/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Finteger-ranges%2Fexhaustiveness.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Finteger-ranges%2Fexhaustiveness.stderr?ref=b97dc20784698730bd7bc1a20eabdcd32066d174", "patch": "@@ -4,107 +4,155 @@ error[E0004]: non-exhaustive patterns: `u8::MAX` not covered\n LL |     m!(0u8, 0..255);\n    |        ^^^ pattern `u8::MAX` not covered\n    |\n-   = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n    = note: the matched value is of type `u8`\n+help: ensure that all possible cases are being handled by adding a match arm with a wildcard pattern or an explicit pattern as shown\n+   |\n+LL ~         match $s { $($t)+ => {}\n+LL ~         u8::MAX => todo!() }\n+   |\n \n error[E0004]: non-exhaustive patterns: `u8::MAX` not covered\n   --> $DIR/exhaustiveness.rs:48:8\n    |\n LL |     m!(0u8, 0..=254);\n    |        ^^^ pattern `u8::MAX` not covered\n    |\n-   = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n    = note: the matched value is of type `u8`\n+help: ensure that all possible cases are being handled by adding a match arm with a wildcard pattern or an explicit pattern as shown\n+   |\n+LL ~         match $s { $($t)+ => {}\n+LL ~         u8::MAX => todo!() }\n+   |\n \n error[E0004]: non-exhaustive patterns: `0_u8` not covered\n   --> $DIR/exhaustiveness.rs:49:8\n    |\n LL |     m!(0u8, 1..=255);\n    |        ^^^ pattern `0_u8` not covered\n    |\n-   = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n    = note: the matched value is of type `u8`\n+help: ensure that all possible cases are being handled by adding a match arm with a wildcard pattern or an explicit pattern as shown\n+   |\n+LL ~         match $s { $($t)+ => {}\n+LL ~         0_u8 => todo!() }\n+   |\n \n error[E0004]: non-exhaustive patterns: `42_u8` not covered\n   --> $DIR/exhaustiveness.rs:50:8\n    |\n LL |     m!(0u8, 0..42 | 43..=255);\n    |        ^^^ pattern `42_u8` not covered\n    |\n-   = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n    = note: the matched value is of type `u8`\n+help: ensure that all possible cases are being handled by adding a match arm with a wildcard pattern or an explicit pattern as shown\n+   |\n+LL ~         match $s { $($t)+ => {}\n+LL ~         42_u8 => todo!() }\n+   |\n \n error[E0004]: non-exhaustive patterns: `i8::MAX` not covered\n   --> $DIR/exhaustiveness.rs:51:8\n    |\n LL |     m!(0i8, -128..127);\n    |        ^^^ pattern `i8::MAX` not covered\n    |\n-   = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n    = note: the matched value is of type `i8`\n+help: ensure that all possible cases are being handled by adding a match arm with a wildcard pattern or an explicit pattern as shown\n+   |\n+LL ~         match $s { $($t)+ => {}\n+LL ~         i8::MAX => todo!() }\n+   |\n \n error[E0004]: non-exhaustive patterns: `i8::MAX` not covered\n   --> $DIR/exhaustiveness.rs:52:8\n    |\n LL |     m!(0i8, -128..=126);\n    |        ^^^ pattern `i8::MAX` not covered\n    |\n-   = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n    = note: the matched value is of type `i8`\n+help: ensure that all possible cases are being handled by adding a match arm with a wildcard pattern or an explicit pattern as shown\n+   |\n+LL ~         match $s { $($t)+ => {}\n+LL ~         i8::MAX => todo!() }\n+   |\n \n error[E0004]: non-exhaustive patterns: `i8::MIN` not covered\n   --> $DIR/exhaustiveness.rs:53:8\n    |\n LL |     m!(0i8, -127..=127);\n    |        ^^^ pattern `i8::MIN` not covered\n    |\n-   = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n    = note: the matched value is of type `i8`\n+help: ensure that all possible cases are being handled by adding a match arm with a wildcard pattern or an explicit pattern as shown\n+   |\n+LL ~         match $s { $($t)+ => {}\n+LL ~         i8::MIN => todo!() }\n+   |\n \n error[E0004]: non-exhaustive patterns: `0_i8` not covered\n   --> $DIR/exhaustiveness.rs:54:11\n    |\n LL |     match 0i8 {\n    |           ^^^ pattern `0_i8` not covered\n    |\n-   = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n    = note: the matched value is of type `i8`\n+help: ensure that all possible cases are being handled by adding a match arm with a wildcard pattern or an explicit pattern as shown\n+   |\n+LL ~         1 ..= i8::MAX => {}\n+LL +         0_i8 => todo!()\n+   |\n \n error[E0004]: non-exhaustive patterns: `u128::MAX` not covered\n   --> $DIR/exhaustiveness.rs:59:8\n    |\n LL |     m!(0u128, 0..=ALMOST_MAX);\n    |        ^^^^^ pattern `u128::MAX` not covered\n    |\n-   = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n    = note: the matched value is of type `u128`\n+help: ensure that all possible cases are being handled by adding a match arm with a wildcard pattern or an explicit pattern as shown\n+   |\n+LL ~         match $s { $($t)+ => {}\n+LL ~         u128::MAX => todo!() }\n+   |\n \n error[E0004]: non-exhaustive patterns: `5_u128..=u128::MAX` not covered\n   --> $DIR/exhaustiveness.rs:60:8\n    |\n LL |     m!(0u128, 0..=4);\n    |        ^^^^^ pattern `5_u128..=u128::MAX` not covered\n    |\n-   = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n    = note: the matched value is of type `u128`\n+help: ensure that all possible cases are being handled by adding a match arm with a wildcard pattern or an explicit pattern as shown\n+   |\n+LL ~         match $s { $($t)+ => {}\n+LL ~         5_u128..=u128::MAX => todo!() }\n+   |\n \n error[E0004]: non-exhaustive patterns: `0_u128` not covered\n   --> $DIR/exhaustiveness.rs:61:8\n    |\n LL |     m!(0u128, 1..=u128::MAX);\n    |        ^^^^^ pattern `0_u128` not covered\n    |\n-   = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n    = note: the matched value is of type `u128`\n+help: ensure that all possible cases are being handled by adding a match arm with a wildcard pattern or an explicit pattern as shown\n+   |\n+LL ~         match $s { $($t)+ => {}\n+LL ~         0_u128 => todo!() }\n+   |\n \n error[E0004]: non-exhaustive patterns: `(126_u8..=127_u8, false)` not covered\n   --> $DIR/exhaustiveness.rs:69:11\n    |\n LL |     match (0u8, true) {\n    |           ^^^^^^^^^^^ pattern `(126_u8..=127_u8, false)` not covered\n    |\n-   = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n    = note: the matched value is of type `(u8, bool)`\n+help: ensure that all possible cases are being handled by adding a match arm with a wildcard pattern or an explicit pattern as shown\n+   |\n+LL ~         (0 ..= 255, true) => {}\n+LL +         (126_u8..=127_u8, false) => todo!()\n+   |\n \n error: aborting due to 12 previous errors\n "}, {"sha": "9f277fa1e1800a1cf3da3cf816f2bd79b3419dd2", "filename": "src/test/ui/pattern/usefulness/integer-ranges/pointer-sized-int.allow.stderr", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/b97dc20784698730bd7bc1a20eabdcd32066d174/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Finteger-ranges%2Fpointer-sized-int.allow.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b97dc20784698730bd7bc1a20eabdcd32066d174/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Finteger-ranges%2Fpointer-sized-int.allow.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Finteger-ranges%2Fpointer-sized-int.allow.stderr?ref=b97dc20784698730bd7bc1a20eabdcd32066d174", "patch": "@@ -4,8 +4,13 @@ error[E0004]: non-exhaustive patterns: type `usize` is non-empty\n LL |     match 7usize {}\n    |           ^^^^^^\n    |\n-   = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n    = note: the matched value is of type `usize`\n+help: ensure that all possible cases are being handled by adding a match arm with a wildcard pattern as shown\n+   |\n+LL ~     match 7usize {\n+LL +         _ => todo!(),\n+LL +     }\n+   |\n \n error: aborting due to previous error\n "}, {"sha": "fa4146a7ad892268d13713830f79cabd45d42d95", "filename": "src/test/ui/pattern/usefulness/integer-ranges/pointer-sized-int.deny.stderr", "status": "modified", "additions": 61, "deletions": 12, "changes": 73, "blob_url": "https://github.com/rust-lang/rust/blob/b97dc20784698730bd7bc1a20eabdcd32066d174/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Finteger-ranges%2Fpointer-sized-int.deny.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b97dc20784698730bd7bc1a20eabdcd32066d174/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Finteger-ranges%2Fpointer-sized-int.deny.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Finteger-ranges%2Fpointer-sized-int.deny.stderr?ref=b97dc20784698730bd7bc1a20eabdcd32066d174", "patch": "@@ -4,125 +4,174 @@ error[E0004]: non-exhaustive patterns: `_` not covered\n LL |     match 0usize {\n    |           ^^^^^^ pattern `_` not covered\n    |\n-   = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n    = note: the matched value is of type `usize`\n    = note: `usize` does not have a fixed maximum value, so a wildcard `_` is necessary to match exhaustively\n    = help: add `#![feature(precise_pointer_size_matching)]` to the crate attributes to enable precise `usize` matching\n+help: ensure that all possible cases are being handled by adding a match arm with a wildcard pattern or an explicit pattern as shown\n+   |\n+LL ~         0 ..= usize::MAX => {}\n+LL +         _ => todo!()\n+   |\n \n error[E0004]: non-exhaustive patterns: `_` not covered\n   --> $DIR/pointer-sized-int.rs:17:11\n    |\n LL |     match 0isize {\n    |           ^^^^^^ pattern `_` not covered\n    |\n-   = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n    = note: the matched value is of type `isize`\n    = note: `isize` does not have a fixed maximum value, so a wildcard `_` is necessary to match exhaustively\n    = help: add `#![feature(precise_pointer_size_matching)]` to the crate attributes to enable precise `isize` matching\n+help: ensure that all possible cases are being handled by adding a match arm with a wildcard pattern or an explicit pattern as shown\n+   |\n+LL ~         isize::MIN ..= isize::MAX => {}\n+LL +         _ => todo!()\n+   |\n \n error[E0004]: non-exhaustive patterns: `_` not covered\n   --> $DIR/pointer-sized-int.rs:22:8\n    |\n LL |     m!(0usize, 0..=usize::MAX);\n    |        ^^^^^^ pattern `_` not covered\n    |\n-   = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n    = note: the matched value is of type `usize`\n    = note: `usize` does not have a fixed maximum value, so a wildcard `_` is necessary to match exhaustively\n    = help: add `#![feature(precise_pointer_size_matching)]` to the crate attributes to enable precise `usize` matching\n+help: ensure that all possible cases are being handled by adding a match arm with a wildcard pattern or an explicit pattern as shown\n+   |\n+LL ~         match $s { $($t)+ => {}\n+LL ~         _ => todo!() }\n+   |\n \n error[E0004]: non-exhaustive patterns: `_` not covered\n   --> $DIR/pointer-sized-int.rs:24:8\n    |\n LL |     m!(0usize, 0..5 | 5..=usize::MAX);\n    |        ^^^^^^ pattern `_` not covered\n    |\n-   = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n    = note: the matched value is of type `usize`\n    = note: `usize` does not have a fixed maximum value, so a wildcard `_` is necessary to match exhaustively\n    = help: add `#![feature(precise_pointer_size_matching)]` to the crate attributes to enable precise `usize` matching\n+help: ensure that all possible cases are being handled by adding a match arm with a wildcard pattern or an explicit pattern as shown\n+   |\n+LL ~         match $s { $($t)+ => {}\n+LL ~         _ => todo!() }\n+   |\n \n error[E0004]: non-exhaustive patterns: `_` not covered\n   --> $DIR/pointer-sized-int.rs:26:8\n    |\n LL |     m!(0usize, 0..usize::MAX | usize::MAX);\n    |        ^^^^^^ pattern `_` not covered\n    |\n-   = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n    = note: the matched value is of type `usize`\n    = note: `usize` does not have a fixed maximum value, so a wildcard `_` is necessary to match exhaustively\n    = help: add `#![feature(precise_pointer_size_matching)]` to the crate attributes to enable precise `usize` matching\n+help: ensure that all possible cases are being handled by adding a match arm with a wildcard pattern or an explicit pattern as shown\n+   |\n+LL ~         match $s { $($t)+ => {}\n+LL ~         _ => todo!() }\n+   |\n \n error[E0004]: non-exhaustive patterns: `(_, _)` not covered\n   --> $DIR/pointer-sized-int.rs:28:8\n    |\n LL |     m!((0usize, true), (0..5, true) | (5..=usize::MAX, true) | (0..=usize::MAX, false));\n    |        ^^^^^^^^^^^^^^ pattern `(_, _)` not covered\n    |\n-   = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n    = note: the matched value is of type `(usize, bool)`\n+help: ensure that all possible cases are being handled by adding a match arm with a wildcard pattern or an explicit pattern as shown\n+   |\n+LL ~         match $s { $($t)+ => {}\n+LL ~         (_, _) => todo!() }\n+   |\n \n error[E0004]: non-exhaustive patterns: `_` not covered\n   --> $DIR/pointer-sized-int.rs:31:8\n    |\n LL |     m!(0isize, isize::MIN..=isize::MAX);\n    |        ^^^^^^ pattern `_` not covered\n    |\n-   = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n    = note: the matched value is of type `isize`\n    = note: `isize` does not have a fixed maximum value, so a wildcard `_` is necessary to match exhaustively\n    = help: add `#![feature(precise_pointer_size_matching)]` to the crate attributes to enable precise `isize` matching\n+help: ensure that all possible cases are being handled by adding a match arm with a wildcard pattern or an explicit pattern as shown\n+   |\n+LL ~         match $s { $($t)+ => {}\n+LL ~         _ => todo!() }\n+   |\n \n error[E0004]: non-exhaustive patterns: `_` not covered\n   --> $DIR/pointer-sized-int.rs:33:8\n    |\n LL |     m!(0isize, isize::MIN..5 | 5..=isize::MAX);\n    |        ^^^^^^ pattern `_` not covered\n    |\n-   = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n    = note: the matched value is of type `isize`\n    = note: `isize` does not have a fixed maximum value, so a wildcard `_` is necessary to match exhaustively\n    = help: add `#![feature(precise_pointer_size_matching)]` to the crate attributes to enable precise `isize` matching\n+help: ensure that all possible cases are being handled by adding a match arm with a wildcard pattern or an explicit pattern as shown\n+   |\n+LL ~         match $s { $($t)+ => {}\n+LL ~         _ => todo!() }\n+   |\n \n error[E0004]: non-exhaustive patterns: `_` not covered\n   --> $DIR/pointer-sized-int.rs:35:8\n    |\n LL |     m!(0isize, isize::MIN..isize::MAX | isize::MAX);\n    |        ^^^^^^ pattern `_` not covered\n    |\n-   = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n    = note: the matched value is of type `isize`\n    = note: `isize` does not have a fixed maximum value, so a wildcard `_` is necessary to match exhaustively\n    = help: add `#![feature(precise_pointer_size_matching)]` to the crate attributes to enable precise `isize` matching\n+help: ensure that all possible cases are being handled by adding a match arm with a wildcard pattern or an explicit pattern as shown\n+   |\n+LL ~         match $s { $($t)+ => {}\n+LL ~         _ => todo!() }\n+   |\n \n error[E0004]: non-exhaustive patterns: `(_, _)` not covered\n   --> $DIR/pointer-sized-int.rs:37:8\n    |\n LL |     m!((0isize, true), (isize::MIN..5, true)\n    |        ^^^^^^^^^^^^^^ pattern `(_, _)` not covered\n    |\n-   = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n    = note: the matched value is of type `(isize, bool)`\n+help: ensure that all possible cases are being handled by adding a match arm with a wildcard pattern or an explicit pattern as shown\n+   |\n+LL ~         match $s { $($t)+ => {}\n+LL ~         (_, _) => todo!() }\n+   |\n \n error[E0004]: non-exhaustive patterns: `_` not covered\n   --> $DIR/pointer-sized-int.rs:41:11\n    |\n LL |     match 0isize {\n    |           ^^^^^^ pattern `_` not covered\n    |\n-   = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n    = note: the matched value is of type `isize`\n    = note: `isize` does not have a fixed maximum value, so a wildcard `_` is necessary to match exhaustively\n    = help: add `#![feature(precise_pointer_size_matching)]` to the crate attributes to enable precise `isize` matching\n+help: ensure that all possible cases are being handled by adding a match arm with a wildcard pattern or an explicit pattern as shown\n+   |\n+LL ~         1 ..= isize::MAX => {}\n+LL +         _ => todo!()\n+   |\n \n error[E0004]: non-exhaustive patterns: type `usize` is non-empty\n   --> $DIR/pointer-sized-int.rs:48:11\n    |\n LL |     match 7usize {}\n    |           ^^^^^^\n    |\n-   = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n    = note: the matched value is of type `usize`\n+help: ensure that all possible cases are being handled by adding a match arm with a wildcard pattern as shown\n+   |\n+LL ~     match 7usize {\n+LL +         _ => todo!(),\n+LL +     }\n+   |\n \n error: aborting due to 12 previous errors\n "}, {"sha": "30492c98206c90729923710f265f482976963a5c", "filename": "src/test/ui/pattern/usefulness/integer-ranges/precise_pointer_matching-message.stderr", "status": "modified", "additions": 10, "deletions": 2, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/b97dc20784698730bd7bc1a20eabdcd32066d174/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Finteger-ranges%2Fprecise_pointer_matching-message.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b97dc20784698730bd7bc1a20eabdcd32066d174/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Finteger-ranges%2Fprecise_pointer_matching-message.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Finteger-ranges%2Fprecise_pointer_matching-message.stderr?ref=b97dc20784698730bd7bc1a20eabdcd32066d174", "patch": "@@ -4,21 +4,29 @@ error[E0004]: non-exhaustive patterns: `_` not covered\n LL |     match 0usize {\n    |           ^^^^^^ pattern `_` not covered\n    |\n-   = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n    = note: the matched value is of type `usize`\n    = note: `usize` does not have a fixed maximum value, so a wildcard `_` is necessary to match exhaustively\n    = help: add `#![feature(precise_pointer_size_matching)]` to the crate attributes to enable precise `usize` matching\n+help: ensure that all possible cases are being handled by adding a match arm with a wildcard pattern or an explicit pattern as shown\n+   |\n+LL ~         0..=usize::MAX => {}\n+LL +         _ => todo!()\n+   |\n \n error[E0004]: non-exhaustive patterns: `_` not covered\n   --> $DIR/precise_pointer_matching-message.rs:11:11\n    |\n LL |     match 0isize {\n    |           ^^^^^^ pattern `_` not covered\n    |\n-   = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n    = note: the matched value is of type `isize`\n    = note: `isize` does not have a fixed maximum value, so a wildcard `_` is necessary to match exhaustively\n    = help: add `#![feature(precise_pointer_size_matching)]` to the crate attributes to enable precise `isize` matching\n+help: ensure that all possible cases are being handled by adding a match arm with a wildcard pattern or an explicit pattern as shown\n+   |\n+LL ~         isize::MIN..=isize::MAX => {}\n+LL +         _ => todo!()\n+   |\n \n error: aborting due to 2 previous errors\n "}, {"sha": "af60f3ff50bf37583622e13c2b3472b8e3155f91", "filename": "src/test/ui/pattern/usefulness/issue-15129.stderr", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b97dc20784698730bd7bc1a20eabdcd32066d174/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fissue-15129.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b97dc20784698730bd7bc1a20eabdcd32066d174/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fissue-15129.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fissue-15129.stderr?ref=b97dc20784698730bd7bc1a20eabdcd32066d174", "patch": "@@ -4,8 +4,12 @@ error[E0004]: non-exhaustive patterns: `(T1(()), V2(_))` and `(T2(()), V1(_))` n\n LL |     match (T::T1(()), V::V2(true)) {\n    |           ^^^^^^^^^^^^^^^^^^^^^^^^ patterns `(T1(()), V2(_))` and `(T2(()), V1(_))` not covered\n    |\n-   = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n    = note: the matched value is of type `(T, V)`\n+help: ensure that all possible cases are being handled by adding a match arm with a wildcard pattern, a match arm with multiple or-patterns as shown, or multiple match arms\n+   |\n+LL ~         (T::T2(()), V::V2(b)) => (),\n+LL ~         (T1(()), V2(_)) | (T2(()), V1(_)) => todo!(),\n+   |\n \n error: aborting due to previous error\n "}, {"sha": "01890b73cbdd8a77875e2f677b976717f880197c", "filename": "src/test/ui/pattern/usefulness/issue-2111.stderr", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b97dc20784698730bd7bc1a20eabdcd32066d174/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fissue-2111.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b97dc20784698730bd7bc1a20eabdcd32066d174/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fissue-2111.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fissue-2111.stderr?ref=b97dc20784698730bd7bc1a20eabdcd32066d174", "patch": "@@ -4,8 +4,12 @@ error[E0004]: non-exhaustive patterns: `(None, None)` and `(Some(_), Some(_))` n\n LL |     match (a, b) {\n    |           ^^^^^^ patterns `(None, None)` and `(Some(_), Some(_))` not covered\n    |\n-   = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n    = note: the matched value is of type `(Option<usize>, Option<usize>)`\n+help: ensure that all possible cases are being handled by adding a match arm with a wildcard pattern, a match arm with multiple or-patterns as shown, or multiple match arms\n+   |\n+LL ~         (Some(_), None) | (None, Some(_)) => {}\n+LL +         (None, None) | (Some(_), Some(_)) => todo!()\n+   |\n \n error: aborting due to previous error\n "}, {"sha": "759fdeafe4eb545202f947b8e7e78d3a7bf61f64", "filename": "src/test/ui/pattern/usefulness/issue-30240.stderr", "status": "modified", "additions": 10, "deletions": 2, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/b97dc20784698730bd7bc1a20eabdcd32066d174/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fissue-30240.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b97dc20784698730bd7bc1a20eabdcd32066d174/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fissue-30240.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fissue-30240.stderr?ref=b97dc20784698730bd7bc1a20eabdcd32066d174", "patch": "@@ -4,17 +4,25 @@ error[E0004]: non-exhaustive patterns: `&_` not covered\n LL |     match \"world\" {\n    |           ^^^^^^^ pattern `&_` not covered\n    |\n-   = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n    = note: the matched value is of type `&str`\n+help: ensure that all possible cases are being handled by adding a match arm with a wildcard pattern or an explicit pattern as shown\n+   |\n+LL ~         \"hello\" => {}\n+LL +         &_ => todo!()\n+   |\n \n error[E0004]: non-exhaustive patterns: `&_` not covered\n   --> $DIR/issue-30240.rs:6:11\n    |\n LL |     match \"world\" {\n    |           ^^^^^^^ pattern `&_` not covered\n    |\n-   = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n    = note: the matched value is of type `&str`\n+help: ensure that all possible cases are being handled by adding a match arm with a wildcard pattern or an explicit pattern as shown\n+   |\n+LL ~         \"hello\" => {}\n+LL +         &_ => todo!()\n+   |\n \n error: aborting due to 2 previous errors\n "}, {"sha": "d8884394f8e9619a0b501090c18a7ea865cc48a5", "filename": "src/test/ui/pattern/usefulness/issue-3096-1.stderr", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/b97dc20784698730bd7bc1a20eabdcd32066d174/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fissue-3096-1.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b97dc20784698730bd7bc1a20eabdcd32066d174/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fissue-3096-1.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fissue-3096-1.stderr?ref=b97dc20784698730bd7bc1a20eabdcd32066d174", "patch": "@@ -4,8 +4,13 @@ error[E0004]: non-exhaustive patterns: type `()` is non-empty\n LL |     match () { }\n    |           ^^\n    |\n-   = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n    = note: the matched value is of type `()`\n+help: ensure that all possible cases are being handled by adding a match arm with a wildcard pattern as shown\n+   |\n+LL ~     match () {\n+LL +         _ => todo!(),\n+LL ~     }\n+   |\n \n error: aborting due to previous error\n "}, {"sha": "2df8911badcda230b55b572dbd8f7355658bffe8", "filename": "src/test/ui/pattern/usefulness/issue-3096-2.stderr", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/b97dc20784698730bd7bc1a20eabdcd32066d174/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fissue-3096-2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b97dc20784698730bd7bc1a20eabdcd32066d174/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fissue-3096-2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fissue-3096-2.stderr?ref=b97dc20784698730bd7bc1a20eabdcd32066d174", "patch": "@@ -4,8 +4,13 @@ error[E0004]: non-exhaustive patterns: type `*const Bottom` is non-empty\n LL |     match x { }\n    |           ^\n    |\n-   = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n    = note: the matched value is of type `*const Bottom`\n+help: ensure that all possible cases are being handled by adding a match arm with a wildcard pattern as shown\n+   |\n+LL ~     match x {\n+LL +         _ => todo!(),\n+LL ~     }\n+   |\n \n error: aborting due to previous error\n "}, {"sha": "dffcfc016072f28d78c769ea47d0292ce2601ae6", "filename": "src/test/ui/pattern/usefulness/issue-31561.stderr", "status": "modified", "additions": 12, "deletions": 11, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/b97dc20784698730bd7bc1a20eabdcd32066d174/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fissue-31561.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b97dc20784698730bd7bc1a20eabdcd32066d174/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fissue-31561.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fissue-31561.stderr?ref=b97dc20784698730bd7bc1a20eabdcd32066d174", "patch": "@@ -1,20 +1,21 @@\n error[E0005]: refutable pattern in local binding: `Bar` and `Baz` not covered\n   --> $DIR/issue-31561.rs:8:9\n    |\n-LL | / enum Thing {\n-LL | |     Foo(u8),\n-LL | |     Bar,\n-   | |     --- not covered\n-LL | |     Baz\n-   | |     --- not covered\n-LL | | }\n-   | |_- `Thing` defined here\n-...\n-LL |       let Thing::Foo(y) = Thing::Foo(1);\n-   |           ^^^^^^^^^^^^^ patterns `Bar` and `Baz` not covered\n+LL |     let Thing::Foo(y) = Thing::Foo(1);\n+   |         ^^^^^^^^^^^^^ patterns `Bar` and `Baz` not covered\n    |\n    = note: `let` bindings require an \"irrefutable pattern\", like a `struct` or an `enum` with only one variant\n    = note: for more information, visit https://doc.rust-lang.org/book/ch18-02-refutability.html\n+note: `Thing` defined here\n+  --> $DIR/issue-31561.rs:3:5\n+   |\n+LL | enum Thing {\n+   |      -----\n+LL |     Foo(u8),\n+LL |     Bar,\n+   |     ^^^ not covered\n+LL |     Baz\n+   |     ^^^ not covered\n    = note: the matched value is of type `Thing`\n help: you might want to use `if let` to ignore the variant that isn't matched\n    |"}, {"sha": "717bb53c32750e0df2dfc527505bb4d3296b1494", "filename": "src/test/ui/pattern/usefulness/issue-35609.stderr", "status": "modified", "additions": 61, "deletions": 14, "changes": 75, "blob_url": "https://github.com/rust-lang/rust/blob/b97dc20784698730bd7bc1a20eabdcd32066d174/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fissue-35609.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b97dc20784698730bd7bc1a20eabdcd32066d174/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fissue-35609.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fissue-35609.stderr?ref=b97dc20784698730bd7bc1a20eabdcd32066d174", "patch": "@@ -4,77 +4,124 @@ error[E0004]: non-exhaustive patterns: `(B, _)`, `(C, _)`, `(D, _)` and 2 more n\n LL |     match (A, ()) {\n    |           ^^^^^^^ patterns `(B, _)`, `(C, _)`, `(D, _)` and 2 more not covered\n    |\n-   = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n    = note: the matched value is of type `(Enum, ())`\n+help: ensure that all possible cases are being handled by adding a match arm with a wildcard pattern as shown, or multiple match arms\n+   |\n+LL ~         (A, _) => {}\n+LL +         _ => todo!()\n+   |\n \n error[E0004]: non-exhaustive patterns: `(_, B)`, `(_, C)`, `(_, D)` and 2 more not covered\n   --> $DIR/issue-35609.rs:14:11\n    |\n LL |     match (A, A) {\n    |           ^^^^^^ patterns `(_, B)`, `(_, C)`, `(_, D)` and 2 more not covered\n    |\n-   = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n    = note: the matched value is of type `(Enum, Enum)`\n+help: ensure that all possible cases are being handled by adding a match arm with a wildcard pattern as shown, or multiple match arms\n+   |\n+LL ~         (_, A) => {}\n+LL +         _ => todo!()\n+   |\n \n error[E0004]: non-exhaustive patterns: `((B, _), _)`, `((C, _), _)`, `((D, _), _)` and 2 more not covered\n   --> $DIR/issue-35609.rs:18:11\n    |\n LL |     match ((A, ()), ()) {\n    |           ^^^^^^^^^^^^^ patterns `((B, _), _)`, `((C, _), _)`, `((D, _), _)` and 2 more not covered\n    |\n-   = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n    = note: the matched value is of type `((Enum, ()), ())`\n+help: ensure that all possible cases are being handled by adding a match arm with a wildcard pattern as shown, or multiple match arms\n+   |\n+LL ~         ((A, ()), _) => {}\n+LL +         _ => todo!()\n+   |\n \n error[E0004]: non-exhaustive patterns: `((B, _), _)`, `((C, _), _)`, `((D, _), _)` and 2 more not covered\n   --> $DIR/issue-35609.rs:22:11\n    |\n LL |     match ((A, ()), A) {\n    |           ^^^^^^^^^^^^ patterns `((B, _), _)`, `((C, _), _)`, `((D, _), _)` and 2 more not covered\n    |\n-   = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n    = note: the matched value is of type `((Enum, ()), Enum)`\n+help: ensure that all possible cases are being handled by adding a match arm with a wildcard pattern as shown, or multiple match arms\n+   |\n+LL ~         ((A, ()), _) => {}\n+LL +         _ => todo!()\n+   |\n \n error[E0004]: non-exhaustive patterns: `((B, _), _)`, `((C, _), _)`, `((D, _), _)` and 2 more not covered\n   --> $DIR/issue-35609.rs:26:11\n    |\n LL |     match ((A, ()), ()) {\n    |           ^^^^^^^^^^^^^ patterns `((B, _), _)`, `((C, _), _)`, `((D, _), _)` and 2 more not covered\n    |\n-   = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n    = note: the matched value is of type `((Enum, ()), ())`\n+help: ensure that all possible cases are being handled by adding a match arm with a wildcard pattern as shown, or multiple match arms\n+   |\n+LL ~         ((A, _), _) => {}\n+LL +         _ => todo!()\n+   |\n \n error[E0004]: non-exhaustive patterns: `S(B, _)`, `S(C, _)`, `S(D, _)` and 2 more not covered\n   --> $DIR/issue-35609.rs:31:11\n    |\n-LL | struct S(Enum, ());\n-   | ------------------- `S` defined here\n-...\n LL |     match S(A, ()) {\n    |           ^^^^^^^^ patterns `S(B, _)`, `S(C, _)`, `S(D, _)` and 2 more not covered\n    |\n-   = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n+note: `S` defined here\n+  --> $DIR/issue-35609.rs:6:8\n+   |\n+LL | struct S(Enum, ());\n+   |        ^\n    = note: the matched value is of type `S`\n+help: ensure that all possible cases are being handled by adding a match arm with a wildcard pattern as shown, or multiple match arms\n+   |\n+LL ~         S(A, _) => {}\n+LL +         _ => todo!()\n+   |\n \n error[E0004]: non-exhaustive patterns: `Sd { x: B, .. }`, `Sd { x: C, .. }`, `Sd { x: D, .. }` and 2 more not covered\n   --> $DIR/issue-35609.rs:35:11\n    |\n-LL | struct Sd { x: Enum, y: () }\n-   | ---------------------------- `Sd` defined here\n-...\n LL |     match (Sd { x: A, y: () }) {\n    |           ^^^^^^^^^^^^^^^^^^^^ patterns `Sd { x: B, .. }`, `Sd { x: C, .. }`, `Sd { x: D, .. }` and 2 more not covered\n    |\n-   = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n+note: `Sd` defined here\n+  --> $DIR/issue-35609.rs:7:8\n+   |\n+LL | struct Sd { x: Enum, y: () }\n+   |        ^^\n    = note: the matched value is of type `Sd`\n+help: ensure that all possible cases are being handled by adding a match arm with a wildcard pattern as shown, or multiple match arms\n+   |\n+LL ~         Sd { x: A, y: _ } => {}\n+LL +         _ => todo!()\n+   |\n \n error[E0004]: non-exhaustive patterns: `Some(B)`, `Some(C)`, `Some(D)` and 2 more not covered\n   --> $DIR/issue-35609.rs:39:11\n    |\n LL |     match Some(A) {\n    |           ^^^^^^^ patterns `Some(B)`, `Some(C)`, `Some(D)` and 2 more not covered\n    |\n-   = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n+note: `Option<Enum>` defined here\n+  --> $SRC_DIR/core/src/option.rs:LL:COL\n+   |\n+LL | / pub enum Option<T> {\n+LL | |     /// No value.\n+LL | |     #[lang = \"None\"]\n+LL | |     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+...  |\n+LL | |     Some(#[stable(feature = \"rust1\", since = \"1.0.0\")] T),\n+LL | | }\n+   | |_^\n    = note: the matched value is of type `Option<Enum>`\n+help: ensure that all possible cases are being handled by adding a match arm with a wildcard pattern as shown, or multiple match arms\n+   |\n+LL ~         None => (),\n+LL +         _ => todo!()\n+   |\n \n error: aborting due to 8 previous errors\n "}, {"sha": "4e0adcc1ba2a538af4aaa509610a9deb3ce432d0", "filename": "src/test/ui/pattern/usefulness/issue-3601.stderr", "status": "modified", "additions": 13, "deletions": 1, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/b97dc20784698730bd7bc1a20eabdcd32066d174/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fissue-3601.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b97dc20784698730bd7bc1a20eabdcd32066d174/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fissue-3601.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fissue-3601.stderr?ref=b97dc20784698730bd7bc1a20eabdcd32066d174", "patch": "@@ -4,8 +4,20 @@ error[E0004]: non-exhaustive patterns: `box _` not covered\n LL |         box NodeKind::Element(ed) => match ed.kind {\n    |                                            ^^^^^^^ pattern `box _` not covered\n    |\n-   = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n+note: `Box<ElementKind>` defined here\n+  --> $SRC_DIR/alloc/src/boxed.rs:LL:COL\n+   |\n+LL | / pub struct Box<\n+LL | |     T: ?Sized,\n+LL | |     #[unstable(feature = \"allocator_api\", issue = \"32838\")] A: Allocator = Global,\n+LL | | >(Unique<T>, A);\n+   | |________________^\n    = note: the matched value is of type `Box<ElementKind>`\n+help: ensure that all possible cases are being handled by adding a match arm with a wildcard pattern or an explicit pattern as shown\n+   |\n+LL ~             box ElementKind::HTMLImageElement(ref d) if d.image.is_some() => { true }\n+LL +             box _ => todo!()\n+   |\n \n error: aborting due to previous error\n "}, {"sha": "ca37af6fb809540f6e0e42f9f546332a72131154", "filename": "src/test/ui/pattern/usefulness/issue-39362.stderr", "status": "modified", "additions": 14, "deletions": 8, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/b97dc20784698730bd7bc1a20eabdcd32066d174/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fissue-39362.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b97dc20784698730bd7bc1a20eabdcd32066d174/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fissue-39362.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fissue-39362.stderr?ref=b97dc20784698730bd7bc1a20eabdcd32066d174", "patch": "@@ -1,16 +1,22 @@\n error[E0004]: non-exhaustive patterns: `Bar { bar: C, .. }`, `Bar { bar: D, .. }`, `Bar { bar: E, .. }` and 1 more not covered\n   --> $DIR/issue-39362.rs:10:11\n    |\n-LL | / enum Foo {\n-LL | |     Bar { bar: Bar, id: usize }\n-LL | | }\n-   | |_- `Foo` defined here\n-...\n-LL |       match f {\n-   |             ^ patterns `Bar { bar: C, .. }`, `Bar { bar: D, .. }`, `Bar { bar: E, .. }` and 1 more not covered\n+LL |     match f {\n+   |           ^ patterns `Bar { bar: C, .. }`, `Bar { bar: D, .. }`, `Bar { bar: E, .. }` and 1 more not covered\n    |\n-   = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n+note: `Foo` defined here\n+  --> $DIR/issue-39362.rs:2:5\n+   |\n+LL | enum Foo {\n+   |      ---\n+LL |     Bar { bar: Bar, id: usize }\n+   |     ^^^ not covered\n    = note: the matched value is of type `Foo`\n+help: ensure that all possible cases are being handled by adding a match arm with a wildcard pattern as shown, or multiple match arms\n+   |\n+LL ~         Foo::Bar { bar: Bar::B, .. } => (),\n+LL ~         _ => todo!(),\n+   |\n \n error: aborting due to previous error\n "}, {"sha": "c477e435335043274051e4ee041245a421b1ef44", "filename": "src/test/ui/pattern/usefulness/issue-40221.stderr", "status": "modified", "additions": 14, "deletions": 9, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/b97dc20784698730bd7bc1a20eabdcd32066d174/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fissue-40221.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b97dc20784698730bd7bc1a20eabdcd32066d174/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fissue-40221.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fissue-40221.stderr?ref=b97dc20784698730bd7bc1a20eabdcd32066d174", "patch": "@@ -1,17 +1,22 @@\n error[E0004]: non-exhaustive patterns: `C(QA)` not covered\n   --> $DIR/issue-40221.rs:11:11\n    |\n-LL | / enum P {\n-LL | |     C(PC),\n-   | |     - not covered\n-LL | | }\n-   | |_- `P` defined here\n-...\n-LL |       match proto {\n-   |             ^^^^^ pattern `C(QA)` not covered\n+LL |     match proto {\n+   |           ^^^^^ pattern `C(QA)` not covered\n    |\n-   = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n+note: `P` defined here\n+  --> $DIR/issue-40221.rs:2:5\n+   |\n+LL | enum P {\n+   |      -\n+LL |     C(PC),\n+   |     ^ not covered\n    = note: the matched value is of type `P`\n+help: ensure that all possible cases are being handled by adding a match arm with a wildcard pattern or an explicit pattern as shown\n+   |\n+LL ~         P::C(PC::Q) => (),\n+LL ~         C(QA) => todo!(),\n+   |\n \n error: aborting due to previous error\n "}, {"sha": "293273174101686bc4fd8e254d3009705eb56c9c", "filename": "src/test/ui/pattern/usefulness/issue-4321.stderr", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b97dc20784698730bd7bc1a20eabdcd32066d174/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fissue-4321.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b97dc20784698730bd7bc1a20eabdcd32066d174/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fissue-4321.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fissue-4321.stderr?ref=b97dc20784698730bd7bc1a20eabdcd32066d174", "patch": "@@ -4,8 +4,12 @@ error[E0004]: non-exhaustive patterns: `(true, false)` not covered\n LL |     println!(\"foo {:}\", match tup {\n    |                               ^^^ pattern `(true, false)` not covered\n    |\n-   = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n    = note: the matched value is of type `(bool, bool)`\n+help: ensure that all possible cases are being handled by adding a match arm with a wildcard pattern or an explicit pattern as shown\n+   |\n+LL ~         (true, true) => \"baz\",\n+LL +         (true, false) => todo!()\n+   |\n \n error: aborting due to previous error\n "}, {"sha": "2bdbecabbbea092375cf58da0bf79a7f3ae079ec", "filename": "src/test/ui/pattern/usefulness/issue-50900.stderr", "status": "modified", "additions": 10, "deletions": 4, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/b97dc20784698730bd7bc1a20eabdcd32066d174/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fissue-50900.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b97dc20784698730bd7bc1a20eabdcd32066d174/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fissue-50900.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fissue-50900.stderr?ref=b97dc20784698730bd7bc1a20eabdcd32066d174", "patch": "@@ -1,14 +1,20 @@\n error[E0004]: non-exhaustive patterns: `Tag(Exif, _)` not covered\n   --> $DIR/issue-50900.rs:15:11\n    |\n-LL | pub struct Tag(pub Context, pub u16);\n-   | ------------------------------------- `Tag` defined here\n-...\n LL |     match Tag::ExifIFDPointer {\n    |           ^^^^^^^^^^^^^^^^^^^ pattern `Tag(Exif, _)` not covered\n    |\n-   = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n+note: `Tag` defined here\n+  --> $DIR/issue-50900.rs:2:12\n+   |\n+LL | pub struct Tag(pub Context, pub u16);\n+   |            ^^^\n    = note: the matched value is of type `Tag`\n+help: ensure that all possible cases are being handled by adding a match arm with a wildcard pattern or an explicit pattern as shown\n+   |\n+LL ~         Tag::ExifIFDPointer => {}\n+LL +         Tag(Exif, _) => todo!()\n+   |\n \n error: aborting due to previous error\n "}, {"sha": "f6261001c5e0903f455ec3da533bff1cda3cc995", "filename": "src/test/ui/pattern/usefulness/issue-56379.stderr", "status": "modified", "additions": 18, "deletions": 13, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/b97dc20784698730bd7bc1a20eabdcd32066d174/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fissue-56379.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b97dc20784698730bd7bc1a20eabdcd32066d174/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fissue-56379.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fissue-56379.stderr?ref=b97dc20784698730bd7bc1a20eabdcd32066d174", "patch": "@@ -1,21 +1,26 @@\n error[E0004]: non-exhaustive patterns: `A(false)`, `B(false)` and `C(false)` not covered\n   --> $DIR/issue-56379.rs:8:11\n    |\n-LL | / enum Foo {\n-LL | |     A(bool),\n-   | |     - not covered\n-LL | |     B(bool),\n-   | |     - not covered\n-LL | |     C(bool),\n-   | |     - not covered\n-LL | | }\n-   | |_- `Foo` defined here\n-...\n-LL |       match Foo::A(true) {\n-   |             ^^^^^^^^^^^^ patterns `A(false)`, `B(false)` and `C(false)` not covered\n+LL |     match Foo::A(true) {\n+   |           ^^^^^^^^^^^^ patterns `A(false)`, `B(false)` and `C(false)` not covered\n    |\n-   = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n+note: `Foo` defined here\n+  --> $DIR/issue-56379.rs:2:5\n+   |\n+LL | enum Foo {\n+   |      ---\n+LL |     A(bool),\n+   |     ^ not covered\n+LL |     B(bool),\n+   |     ^ not covered\n+LL |     C(bool),\n+   |     ^ not covered\n    = note: the matched value is of type `Foo`\n+help: ensure that all possible cases are being handled by adding a match arm with a wildcard pattern, a match arm with multiple or-patterns as shown, or multiple match arms\n+   |\n+LL ~         Foo::C(true) => {}\n+LL +         A(false) | B(false) | C(false) => todo!()\n+   |\n \n error: aborting due to previous error\n "}, {"sha": "20f002dd3db15c66d276335c80d09ea60844c7a6", "filename": "src/test/ui/pattern/usefulness/issue-72377.stderr", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b97dc20784698730bd7bc1a20eabdcd32066d174/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fissue-72377.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b97dc20784698730bd7bc1a20eabdcd32066d174/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fissue-72377.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fissue-72377.stderr?ref=b97dc20784698730bd7bc1a20eabdcd32066d174", "patch": "@@ -4,8 +4,12 @@ error[E0004]: non-exhaustive patterns: `(A, Some(A))`, `(A, Some(B))`, `(B, Some\n LL |     match (x, y) {\n    |           ^^^^^^ patterns `(A, Some(A))`, `(A, Some(B))`, `(B, Some(B))` and 2 more not covered\n    |\n-   = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n    = note: the matched value is of type `(X, Option<X>)`\n+help: ensure that all possible cases are being handled by adding a match arm with a wildcard pattern as shown, or multiple match arms\n+   |\n+LL ~         (X::A, Some(X::C)) | (X::C, Some(X::A)) => false,\n+LL ~         _ => todo!(),\n+   |\n \n error: aborting due to previous error\n "}, {"sha": "cbfcf0eafd4901032ddf5b67f6825592d3b9ed70", "filename": "src/test/ui/pattern/usefulness/issue-78123-non-exhaustive-reference.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/b97dc20784698730bd7bc1a20eabdcd32066d174/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fissue-78123-non-exhaustive-reference.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b97dc20784698730bd7bc1a20eabdcd32066d174/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fissue-78123-non-exhaustive-reference.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fissue-78123-non-exhaustive-reference.rs?ref=b97dc20784698730bd7bc1a20eabdcd32066d174", "patch": "@@ -1,5 +1,6 @@\n enum A {}\n     //~^ NOTE `A` defined here\n+    //~| NOTE\n \n fn f(a: &A) {\n     match a {}"}, {"sha": "bf05d616d6ed1c2865ed46ccf21e3fa76c169e13", "filename": "src/test/ui/pattern/usefulness/issue-78123-non-exhaustive-reference.stderr", "status": "modified", "additions": 12, "deletions": 5, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/b97dc20784698730bd7bc1a20eabdcd32066d174/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fissue-78123-non-exhaustive-reference.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b97dc20784698730bd7bc1a20eabdcd32066d174/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fissue-78123-non-exhaustive-reference.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fissue-78123-non-exhaustive-reference.stderr?ref=b97dc20784698730bd7bc1a20eabdcd32066d174", "patch": "@@ -1,15 +1,22 @@\n error[E0004]: non-exhaustive patterns: type `&A` is non-empty\n-  --> $DIR/issue-78123-non-exhaustive-reference.rs:5:11\n+  --> $DIR/issue-78123-non-exhaustive-reference.rs:6:11\n    |\n-LL | enum A {}\n-   | --------- `A` defined here\n-...\n LL |     match a {}\n    |           ^\n    |\n-   = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n+note: `A` defined here\n+  --> $DIR/issue-78123-non-exhaustive-reference.rs:1:6\n+   |\n+LL | enum A {}\n+   |      ^\n    = note: the matched value is of type `&A`\n    = note: references are always considered inhabited\n+help: ensure that all possible cases are being handled by adding a match arm with a wildcard pattern as shown\n+   |\n+LL ~     match a {\n+LL +         _ => todo!(),\n+LL +     }\n+   |\n \n error: aborting due to previous error\n "}, {"sha": "3326e6b85a471734c11bd6e3930a368be393202c", "filename": "src/test/ui/pattern/usefulness/match-arm-statics-2.stderr", "status": "modified", "additions": 36, "deletions": 18, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/b97dc20784698730bd7bc1a20eabdcd32066d174/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fmatch-arm-statics-2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b97dc20784698730bd7bc1a20eabdcd32066d174/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fmatch-arm-statics-2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fmatch-arm-statics-2.stderr?ref=b97dc20784698730bd7bc1a20eabdcd32066d174", "patch": "@@ -4,40 +4,58 @@ error[E0004]: non-exhaustive patterns: `(true, false)` not covered\n LL |     match (true, false) {\n    |           ^^^^^^^^^^^^^ pattern `(true, false)` not covered\n    |\n-   = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n    = note: the matched value is of type `(bool, bool)`\n+help: ensure that all possible cases are being handled by adding a match arm with a wildcard pattern or an explicit pattern as shown\n+   |\n+LL ~         (false, true) => (),\n+LL +         (true, false) => todo!()\n+   |\n \n error[E0004]: non-exhaustive patterns: `Some(Some(West))` not covered\n   --> $DIR/match-arm-statics-2.rs:29:11\n    |\n LL |     match Some(Some(North)) {\n    |           ^^^^^^^^^^^^^^^^^ pattern `Some(Some(West))` not covered\n    |\n-  ::: $SRC_DIR/core/src/option.rs:LL:COL\n+note: `Option<Option<Direction>>` defined here\n+  --> $SRC_DIR/core/src/option.rs:LL:COL\n+   |\n+LL | / pub enum Option<T> {\n+LL | |     /// No value.\n+LL | |     #[lang = \"None\"]\n+LL | |     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+...  |\n+LL | |     Some(#[stable(feature = \"rust1\", since = \"1.0.0\")] T),\n+   | |     ^^^^\n+   | |     |\n+   | |     not covered\n+   | |     not covered\n+LL | | }\n+   | |_-\n+   = note: the matched value is of type `Option<Option<Direction>>`\n+help: ensure that all possible cases are being handled by adding a match arm with a wildcard pattern or an explicit pattern as shown\n    |\n-LL |     Some(#[stable(feature = \"rust1\", since = \"1.0.0\")] T),\n-   |     ----\n-   |     |\n-   |     not covered\n-   |     not covered\n+LL ~         None => (),\n+LL +         Some(Some(West)) => todo!()\n    |\n-   = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n-   = note: the matched value is of type `Option<Option<Direction>>`\n \n error[E0004]: non-exhaustive patterns: `Foo { bar: Some(North), baz: NewBool(true) }` not covered\n   --> $DIR/match-arm-statics-2.rs:48:11\n    |\n-LL | / struct Foo {\n-LL | |     bar: Option<Direction>,\n-LL | |     baz: NewBool\n-LL | | }\n-   | |_- `Foo` defined here\n-...\n-LL |       match (Foo { bar: Some(North), baz: NewBool(true) }) {\n-   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ pattern `Foo { bar: Some(North), baz: NewBool(true) }` not covered\n+LL |     match (Foo { bar: Some(North), baz: NewBool(true) }) {\n+   |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ pattern `Foo { bar: Some(North), baz: NewBool(true) }` not covered\n+   |\n+note: `Foo` defined here\n+  --> $DIR/match-arm-statics-2.rs:40:8\n    |\n-   = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n+LL | struct Foo {\n+   |        ^^^\n    = note: the matched value is of type `Foo`\n+help: ensure that all possible cases are being handled by adding a match arm with a wildcard pattern or an explicit pattern as shown\n+   |\n+LL ~         Foo { bar: Some(EAST), .. } => (),\n+LL +         Foo { bar: Some(North), baz: NewBool(true) } => todo!()\n+   |\n \n error: aborting due to 3 previous errors\n "}, {"sha": "a90f32f7aebf34e3bd99ba18d36dc5ded1077df7", "filename": "src/test/ui/pattern/usefulness/match-byte-array-patterns-2.stderr", "status": "modified", "additions": 10, "deletions": 2, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/b97dc20784698730bd7bc1a20eabdcd32066d174/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fmatch-byte-array-patterns-2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b97dc20784698730bd7bc1a20eabdcd32066d174/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fmatch-byte-array-patterns-2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fmatch-byte-array-patterns-2.stderr?ref=b97dc20784698730bd7bc1a20eabdcd32066d174", "patch": "@@ -4,17 +4,25 @@ error[E0004]: non-exhaustive patterns: `&[0_u8..=64_u8, _, _, _]` and `&[66_u8..\n LL |     match buf {\n    |           ^^^ patterns `&[0_u8..=64_u8, _, _, _]` and `&[66_u8..=u8::MAX, _, _, _]` not covered\n    |\n-   = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n    = note: the matched value is of type `&[u8; 4]`\n+help: ensure that all possible cases are being handled by adding a match arm with a wildcard pattern, a match arm with multiple or-patterns as shown, or multiple match arms\n+   |\n+LL ~         b\"AAAA\" => {}\n+LL +         &[0_u8..=64_u8, _, _, _] | &[66_u8..=u8::MAX, _, _, _] => todo!()\n+   |\n \n error[E0004]: non-exhaustive patterns: `&[]`, `&[_]`, `&[_, _]` and 2 more not covered\n   --> $DIR/match-byte-array-patterns-2.rs:10:11\n    |\n LL |     match buf {\n    |           ^^^ patterns `&[]`, `&[_]`, `&[_, _]` and 2 more not covered\n    |\n-   = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n    = note: the matched value is of type `&[u8]`\n+help: ensure that all possible cases are being handled by adding a match arm with a wildcard pattern as shown, or multiple match arms\n+   |\n+LL ~         b\"AAAA\" => {}\n+LL +         _ => todo!()\n+   |\n \n error: aborting due to 2 previous errors\n "}, {"sha": "08dde523a15fb524e3aaa7367452432fc642a6bf", "filename": "src/test/ui/pattern/usefulness/match-non-exhaustive.stderr", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/b97dc20784698730bd7bc1a20eabdcd32066d174/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fmatch-non-exhaustive.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b97dc20784698730bd7bc1a20eabdcd32066d174/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fmatch-non-exhaustive.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fmatch-non-exhaustive.stderr?ref=b97dc20784698730bd7bc1a20eabdcd32066d174", "patch": "@@ -4,17 +4,23 @@ error[E0004]: non-exhaustive patterns: `i32::MIN..=0_i32` and `2_i32..=i32::MAX`\n LL |     match 0 { 1 => () }\n    |           ^ patterns `i32::MIN..=0_i32` and `2_i32..=i32::MAX` not covered\n    |\n-   = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n    = note: the matched value is of type `i32`\n+help: ensure that all possible cases are being handled by adding a match arm with a wildcard pattern, a match arm with multiple or-patterns as shown, or multiple match arms\n+   |\n+LL |     match 0 { 1 => (), i32::MIN..=0_i32 | 2_i32..=i32::MAX => todo!() }\n+   |                      ++++++++++++++++++++++++++++++++++++++++++++++++\n \n error[E0004]: non-exhaustive patterns: `_` not covered\n   --> $DIR/match-non-exhaustive.rs:3:11\n    |\n LL |     match 0 { 0 if false => () }\n    |           ^ pattern `_` not covered\n    |\n-   = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n    = note: the matched value is of type `i32`\n+help: ensure that all possible cases are being handled by adding a match arm with a wildcard pattern or an explicit pattern as shown\n+   |\n+LL |     match 0 { 0 if false => (), _ => todo!() }\n+   |                               ++++++++++++++\n \n error: aborting due to 2 previous errors\n "}, {"sha": "88178d6429197eac5850ce0b9cc5c5d098ef3631", "filename": "src/test/ui/pattern/usefulness/match-privately-empty.stderr", "status": "modified", "additions": 16, "deletions": 5, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/b97dc20784698730bd7bc1a20eabdcd32066d174/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fmatch-privately-empty.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b97dc20784698730bd7bc1a20eabdcd32066d174/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fmatch-privately-empty.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fmatch-privately-empty.stderr?ref=b97dc20784698730bd7bc1a20eabdcd32066d174", "patch": "@@ -4,13 +4,24 @@ error[E0004]: non-exhaustive patterns: `Some(Private { misc: true, .. })` not co\n LL |     match private::DATA {\n    |           ^^^^^^^^^^^^^ pattern `Some(Private { misc: true, .. })` not covered\n    |\n-  ::: $SRC_DIR/core/src/option.rs:LL:COL\n+note: `Option<Private>` defined here\n+  --> $SRC_DIR/core/src/option.rs:LL:COL\n    |\n-LL |     Some(#[stable(feature = \"rust1\", since = \"1.0.0\")] T),\n-   |     ---- not covered\n-   |\n-   = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n+LL | / pub enum Option<T> {\n+LL | |     /// No value.\n+LL | |     #[lang = \"None\"]\n+LL | |     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+...  |\n+LL | |     Some(#[stable(feature = \"rust1\", since = \"1.0.0\")] T),\n+   | |     ^^^^ not covered\n+LL | | }\n+   | |_-\n    = note: the matched value is of type `Option<Private>`\n+help: ensure that all possible cases are being handled by adding a match arm with a wildcard pattern or an explicit pattern as shown\n+   |\n+LL ~         }) => {}\n+LL +         Some(Private { misc: true, .. }) => todo!()\n+   |\n \n error: aborting due to previous error\n "}, {"sha": "961dd5901196149b004bc627c8a01647beacf62d", "filename": "src/test/ui/pattern/usefulness/match-slice-patterns.stderr", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b97dc20784698730bd7bc1a20eabdcd32066d174/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fmatch-slice-patterns.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b97dc20784698730bd7bc1a20eabdcd32066d174/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fmatch-slice-patterns.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fmatch-slice-patterns.stderr?ref=b97dc20784698730bd7bc1a20eabdcd32066d174", "patch": "@@ -4,8 +4,12 @@ error[E0004]: non-exhaustive patterns: `&[_, Some(_), .., None, _]` not covered\n LL |     match list {\n    |           ^^^^ pattern `&[_, Some(_), .., None, _]` not covered\n    |\n-   = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n    = note: the matched value is of type `&[Option<()>]`\n+help: ensure that all possible cases are being handled by adding a match arm with a wildcard pattern or an explicit pattern as shown\n+   |\n+LL ~         &[.., Some(_), _] => {}\n+LL ~         &[_, Some(_), .., None, _] => todo!(),\n+   |\n \n error: aborting due to previous error\n "}, {"sha": "2e15bc2d2a5f534fbab024f30bcd94f0039345fa", "filename": "src/test/ui/pattern/usefulness/non-exhaustive-defined-here.rs", "status": "modified", "additions": 48, "deletions": 15, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/b97dc20784698730bd7bc1a20eabdcd32066d174/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fnon-exhaustive-defined-here.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b97dc20784698730bd7bc1a20eabdcd32066d174/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fnon-exhaustive-defined-here.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fnon-exhaustive-defined-here.rs?ref=b97dc20784698730bd7bc1a20eabdcd32066d174", "patch": "@@ -4,20 +4,26 @@\n \n #[derive(Clone)]\n enum E {\n-//~^ `E` defined here\n-//~| `E` defined here\n-//~| `E` defined here\n-//~| `E` defined here\n-//~| `E` defined here\n-//~| `E` defined here\n+    //~^ NOTE\n+    //~| NOTE\n+    //~| NOTE\n+    //~| NOTE\n+    //~| NOTE\n+    //~| NOTE\n     A,\n     B,\n-    //~^ not covered\n-    //~| not covered\n-    //~| not covered\n-    //~| not covered\n-    //~| not covered\n-    //~| not covered\n+    //~^ NOTE `E` defined here\n+    //~| NOTE `E` defined here\n+    //~| NOTE `E` defined here\n+    //~| NOTE `E` defined here\n+    //~| NOTE `E` defined here\n+    //~| NOTE `E` defined here\n+    //~| NOTE  not covered\n+    //~| NOTE  not covered\n+    //~| NOTE  not covered\n+    //~| NOTE  not covered\n+    //~| NOTE  not covered\n+    //~| NOTE  not covered\n     C\n     //~^ not covered\n     //~| not covered\n@@ -30,43 +36,70 @@ enum E {\n fn by_val(e: E) {\n     let e1 = e.clone();\n     match e1 { //~ ERROR non-exhaustive patterns: `B` and `C` not covered\n+        //~^ NOTE patterns `B` and `C` not covered\n+        //~| NOTE the matched value is of type `E`\n         E::A => {}\n     }\n \n     let E::A = e; //~ ERROR refutable pattern in local binding: `B` and `C` not covered\n+    //~^ NOTE patterns `B` and `C` not covered\n+    //~| NOTE `let` bindings require an \"irrefutable pattern\", like a `struct` or an `enum` with\n+    //~| NOTE for more information, visit https://doc.rust-lang.org/book/ch18-02-refutability.html\n+    //~| NOTE the matched value is of type `E`\n }\n \n fn by_ref_once(e: &E) {\n     match e { //~ ERROR non-exhaustive patterns: `&B` and `&C` not covered\n+    //~^ NOTE patterns `&B` and `&C` not covered\n+    //~| NOTE the matched value is of type `&E`\n         E::A => {}\n     }\n \n     let E::A = e; //~ ERROR refutable pattern in local binding: `&B` and `&C` not covered\n+    //~^ NOTE patterns `&B` and `&C` not covered\n+    //~| NOTE `let` bindings require an \"irrefutable pattern\", like a `struct` or an `enum` with\n+    //~| NOTE for more information, visit https://doc.rust-lang.org/book/ch18-02-refutability.html\n+    //~| NOTE the matched value is of type `&E`\n }\n \n fn by_ref_thrice(e: & &mut &E) {\n     match e { //~ ERROR non-exhaustive patterns: `&&mut &B` and `&&mut &C` not covered\n+    //~^ NOTE patterns `&&mut &B` and `&&mut &C` not covered\n+    //~| NOTE the matched value is of type `&&mut &E`\n         E::A => {}\n     }\n \n     let E::A = e;\n     //~^ ERROR refutable pattern in local binding: `&&mut &B` and `&&mut &C` not covered\n+    //~| NOTE patterns `&&mut &B` and `&&mut &C` not covered\n+    //~| NOTE `let` bindings require an \"irrefutable pattern\", like a `struct` or an `enum` with\n+    //~| NOTE for more information, visit https://doc.rust-lang.org/book/ch18-02-refutability.html\n+    //~| NOTE the matched value is of type `&&mut &E`\n }\n \n enum Opt {\n-//~^ `Opt` defined here\n-//~| `Opt` defined here\n+    //~^ NOTE\n+    //~| NOTE\n     Some(u8),\n     None,\n-    //~^ not covered\n+    //~^ NOTE `Opt` defined here\n+    //~| NOTE `Opt` defined here\n+    //~| NOTE not covered\n+    //~| NOTE not covered\n }\n \n fn ref_pat(e: Opt) {\n     match e {//~ ERROR non-exhaustive patterns: `None` not covered\n+        //~^ NOTE pattern `None` not covered\n+        //~| NOTE the matched value is of type `Opt`\n         Opt::Some(ref _x) => {}\n     }\n \n     let Opt::Some(ref _x) = e; //~ ERROR refutable pattern in local binding: `None` not covered\n+    //~^ NOTE the matched value is of type `Opt`\n+    //~| NOTE pattern `None` not covered\n+    //~| NOTE `let` bindings require an \"irrefutable pattern\", like a `struct` or an `enum` with\n+    //~| NOTE for more information, visit https://doc.rust-lang.org/book/ch18-02-refutability.html\n }\n \n fn main() {}"}, {"sha": "8f5adccea806db36ba27570cf92d19421e6e8502", "filename": "src/test/ui/pattern/usefulness/non-exhaustive-defined-here.stderr", "status": "modified", "additions": 133, "deletions": 145, "changes": 278, "blob_url": "https://github.com/rust-lang/rust/blob/b97dc20784698730bd7bc1a20eabdcd32066d174/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fnon-exhaustive-defined-here.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b97dc20784698730bd7bc1a20eabdcd32066d174/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fnon-exhaustive-defined-here.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fnon-exhaustive-defined-here.stderr?ref=b97dc20784698730bd7bc1a20eabdcd32066d174", "patch": "@@ -1,199 +1,187 @@\n error[E0004]: non-exhaustive patterns: `B` and `C` not covered\n-  --> $DIR/non-exhaustive-defined-here.rs:32:11\n-   |\n-LL | / enum E {\n-LL | |\n-LL | |\n-LL | |\n-...  |\n-LL | |     B,\n-   | |     - not covered\n-...  |\n-LL | |     C\n-   | |     - not covered\n-...  |\n-LL | |\n-LL | | }\n-   | |_- `E` defined here\n-...\n-LL |       match e1 {\n-   |             ^^ patterns `B` and `C` not covered\n+  --> $DIR/non-exhaustive-defined-here.rs:38:11\n+   |\n+LL |     match e1 {\n+   |           ^^ patterns `B` and `C` not covered\n+   |\n+note: `E` defined here\n+  --> $DIR/non-exhaustive-defined-here.rs:14:5\n    |\n-   = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n+LL | enum E {\n+   |      -\n+...\n+LL |     B,\n+   |     ^ not covered\n+...\n+LL |     C\n+   |     ^ not covered\n    = note: the matched value is of type `E`\n+help: ensure that all possible cases are being handled by adding a match arm with a wildcard pattern, a match arm with multiple or-patterns as shown, or multiple match arms\n+   |\n+LL ~         E::A => {}\n+LL +         B | C => todo!()\n+   |\n \n error[E0005]: refutable pattern in local binding: `B` and `C` not covered\n-  --> $DIR/non-exhaustive-defined-here.rs:36:9\n-   |\n-LL | / enum E {\n-LL | |\n-LL | |\n-LL | |\n-...  |\n-LL | |     B,\n-   | |     - not covered\n-...  |\n-LL | |     C\n-   | |     - not covered\n-...  |\n-LL | |\n-LL | | }\n-   | |_- `E` defined here\n-...\n-LL |       let E::A = e;\n-   |           ^^^^ patterns `B` and `C` not covered\n+  --> $DIR/non-exhaustive-defined-here.rs:44:9\n+   |\n+LL |     let E::A = e;\n+   |         ^^^^ patterns `B` and `C` not covered\n    |\n    = note: `let` bindings require an \"irrefutable pattern\", like a `struct` or an `enum` with only one variant\n    = note: for more information, visit https://doc.rust-lang.org/book/ch18-02-refutability.html\n+note: `E` defined here\n+  --> $DIR/non-exhaustive-defined-here.rs:14:5\n+   |\n+LL | enum E {\n+   |      -\n+...\n+LL |     B,\n+   |     ^ not covered\n+...\n+LL |     C\n+   |     ^ not covered\n    = note: the matched value is of type `E`\n help: you might want to use `if let` to ignore the variant that isn't matched\n    |\n LL |     if let E::A = e { /* */ }\n    |     ~~~~~~~~~~~~~~~~~~~~~~~~~\n \n error[E0004]: non-exhaustive patterns: `&B` and `&C` not covered\n-  --> $DIR/non-exhaustive-defined-here.rs:40:11\n-   |\n-LL | / enum E {\n-LL | |\n-LL | |\n-LL | |\n-...  |\n-LL | |     B,\n-   | |     - not covered\n-...  |\n-LL | |     C\n-   | |     - not covered\n-...  |\n-LL | |\n-LL | | }\n-   | |_- `E` defined here\n-...\n-LL |       match e {\n-   |             ^ patterns `&B` and `&C` not covered\n+  --> $DIR/non-exhaustive-defined-here.rs:52:11\n+   |\n+LL |     match e {\n+   |           ^ patterns `&B` and `&C` not covered\n    |\n-   = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n+note: `E` defined here\n+  --> $DIR/non-exhaustive-defined-here.rs:14:5\n+   |\n+LL | enum E {\n+   |      -\n+...\n+LL |     B,\n+   |     ^ not covered\n+...\n+LL |     C\n+   |     ^ not covered\n    = note: the matched value is of type `&E`\n+help: ensure that all possible cases are being handled by adding a match arm with a wildcard pattern, a match arm with multiple or-patterns as shown, or multiple match arms\n+   |\n+LL ~         E::A => {}\n+LL +         &B | &C => todo!()\n+   |\n \n error[E0005]: refutable pattern in local binding: `&B` and `&C` not covered\n-  --> $DIR/non-exhaustive-defined-here.rs:44:9\n+  --> $DIR/non-exhaustive-defined-here.rs:58:9\n    |\n-LL | / enum E {\n-LL | |\n-LL | |\n-LL | |\n-...  |\n-LL | |     B,\n-   | |     - not covered\n-...  |\n-LL | |     C\n-   | |     - not covered\n-...  |\n-LL | |\n-LL | | }\n-   | |_- `E` defined here\n-...\n-LL |       let E::A = e;\n-   |           ^^^^ patterns `&B` and `&C` not covered\n+LL |     let E::A = e;\n+   |         ^^^^ patterns `&B` and `&C` not covered\n    |\n    = note: `let` bindings require an \"irrefutable pattern\", like a `struct` or an `enum` with only one variant\n    = note: for more information, visit https://doc.rust-lang.org/book/ch18-02-refutability.html\n+note: `E` defined here\n+  --> $DIR/non-exhaustive-defined-here.rs:14:5\n+   |\n+LL | enum E {\n+   |      -\n+...\n+LL |     B,\n+   |     ^ not covered\n+...\n+LL |     C\n+   |     ^ not covered\n    = note: the matched value is of type `&E`\n help: you might want to use `if let` to ignore the variant that isn't matched\n    |\n LL |     if let E::A = e { /* */ }\n    |     ~~~~~~~~~~~~~~~~~~~~~~~~~\n \n error[E0004]: non-exhaustive patterns: `&&mut &B` and `&&mut &C` not covered\n-  --> $DIR/non-exhaustive-defined-here.rs:48:11\n-   |\n-LL | / enum E {\n-LL | |\n-LL | |\n-LL | |\n-...  |\n-LL | |     B,\n-   | |     - not covered\n-...  |\n-LL | |     C\n-   | |     - not covered\n-...  |\n-LL | |\n-LL | | }\n-   | |_- `E` defined here\n-...\n-LL |       match e {\n-   |             ^ patterns `&&mut &B` and `&&mut &C` not covered\n+  --> $DIR/non-exhaustive-defined-here.rs:66:11\n+   |\n+LL |     match e {\n+   |           ^ patterns `&&mut &B` and `&&mut &C` not covered\n    |\n-   = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n+note: `E` defined here\n+  --> $DIR/non-exhaustive-defined-here.rs:14:5\n+   |\n+LL | enum E {\n+   |      -\n+...\n+LL |     B,\n+   |     ^ not covered\n+...\n+LL |     C\n+   |     ^ not covered\n    = note: the matched value is of type `&&mut &E`\n+help: ensure that all possible cases are being handled by adding a match arm with a wildcard pattern, a match arm with multiple or-patterns as shown, or multiple match arms\n+   |\n+LL ~         E::A => {}\n+LL +         &&mut &B | &&mut &C => todo!()\n+   |\n \n error[E0005]: refutable pattern in local binding: `&&mut &B` and `&&mut &C` not covered\n-  --> $DIR/non-exhaustive-defined-here.rs:52:9\n-   |\n-LL | / enum E {\n-LL | |\n-LL | |\n-LL | |\n-...  |\n-LL | |     B,\n-   | |     - not covered\n-...  |\n-LL | |     C\n-   | |     - not covered\n-...  |\n-LL | |\n-LL | | }\n-   | |_- `E` defined here\n-...\n-LL |       let E::A = e;\n-   |           ^^^^ patterns `&&mut &B` and `&&mut &C` not covered\n+  --> $DIR/non-exhaustive-defined-here.rs:72:9\n+   |\n+LL |     let E::A = e;\n+   |         ^^^^ patterns `&&mut &B` and `&&mut &C` not covered\n    |\n    = note: `let` bindings require an \"irrefutable pattern\", like a `struct` or an `enum` with only one variant\n    = note: for more information, visit https://doc.rust-lang.org/book/ch18-02-refutability.html\n+note: `E` defined here\n+  --> $DIR/non-exhaustive-defined-here.rs:14:5\n+   |\n+LL | enum E {\n+   |      -\n+...\n+LL |     B,\n+   |     ^ not covered\n+...\n+LL |     C\n+   |     ^ not covered\n    = note: the matched value is of type `&&mut &E`\n help: you might want to use `if let` to ignore the variant that isn't matched\n    |\n LL |     if let E::A = e { /* */ }\n    |\n \n error[E0004]: non-exhaustive patterns: `None` not covered\n-  --> $DIR/non-exhaustive-defined-here.rs:65:11\n-   |\n-LL | / enum Opt {\n-LL | |\n-LL | |\n-LL | |     Some(u8),\n-LL | |     None,\n-   | |     ---- not covered\n-LL | |\n-LL | | }\n-   | |_- `Opt` defined here\n-...\n-LL |       match e {\n-   |             ^ pattern `None` not covered\n+  --> $DIR/non-exhaustive-defined-here.rs:92:11\n+   |\n+LL |     match e {\n+   |           ^ pattern `None` not covered\n    |\n-   = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n+note: `Opt` defined here\n+  --> $DIR/non-exhaustive-defined-here.rs:84:5\n+   |\n+LL | enum Opt {\n+   |      ---\n+...\n+LL |     None,\n+   |     ^^^^ not covered\n    = note: the matched value is of type `Opt`\n+help: ensure that all possible cases are being handled by adding a match arm with a wildcard pattern or an explicit pattern as shown\n+   |\n+LL ~         Opt::Some(ref _x) => {}\n+LL +         None => todo!()\n+   |\n \n error[E0005]: refutable pattern in local binding: `None` not covered\n-  --> $DIR/non-exhaustive-defined-here.rs:69:9\n-   |\n-LL | / enum Opt {\n-LL | |\n-LL | |\n-LL | |     Some(u8),\n-LL | |     None,\n-   | |     ---- not covered\n-LL | |\n-LL | | }\n-   | |_- `Opt` defined here\n-...\n-LL |       let Opt::Some(ref _x) = e;\n-   |           ^^^^^^^^^^^^^^^^^ pattern `None` not covered\n+  --> $DIR/non-exhaustive-defined-here.rs:98:9\n+   |\n+LL |     let Opt::Some(ref _x) = e;\n+   |         ^^^^^^^^^^^^^^^^^ pattern `None` not covered\n    |\n    = note: `let` bindings require an \"irrefutable pattern\", like a `struct` or an `enum` with only one variant\n    = note: for more information, visit https://doc.rust-lang.org/book/ch18-02-refutability.html\n+note: `Opt` defined here\n+  --> $DIR/non-exhaustive-defined-here.rs:84:5\n+   |\n+LL | enum Opt {\n+   |      ---\n+...\n+LL |     None,\n+   |     ^^^^ not covered\n    = note: the matched value is of type `Opt`\n help: you might want to use `if let` to ignore the variant that isn't matched\n    |"}, {"sha": "cbbd544f943ba1f0f3488868e0dbcfe68bbc5004", "filename": "src/test/ui/pattern/usefulness/non-exhaustive-match-nested.stderr", "status": "modified", "additions": 15, "deletions": 8, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/b97dc20784698730bd7bc1a20eabdcd32066d174/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fnon-exhaustive-match-nested.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b97dc20784698730bd7bc1a20eabdcd32066d174/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fnon-exhaustive-match-nested.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fnon-exhaustive-match-nested.stderr?ref=b97dc20784698730bd7bc1a20eabdcd32066d174", "patch": "@@ -4,23 +4,30 @@ error[E0004]: non-exhaustive patterns: `(Some(&[]), Err(_))` not covered\n LL |     match (l1, l2) {\n    |           ^^^^^^^^ pattern `(Some(&[]), Err(_))` not covered\n    |\n-   = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n    = note: the matched value is of type `(Option<&[T]>, Result<&[T], ()>)`\n+help: ensure that all possible cases are being handled by adding a match arm with a wildcard pattern or an explicit pattern as shown\n+   |\n+LL ~         (None, Ok(&[_, _, ..])) => \"None, Ok(at least two elements)\",\n+LL +         (Some(&[]), Err(_)) => todo!()\n+   |\n \n error[E0004]: non-exhaustive patterns: `A(C)` not covered\n   --> $DIR/non-exhaustive-match-nested.rs:15:11\n    |\n-LL | enum T { A(U), B }\n-   | ------------------\n-   | |        |\n-   | |        not covered\n-   | `T` defined here\n-...\n LL |     match x {\n    |           ^ pattern `A(C)` not covered\n    |\n-   = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n+note: `T` defined here\n+  --> $DIR/non-exhaustive-match-nested.rs:1:10\n+   |\n+LL | enum T { A(U), B }\n+   |      -   ^ not covered\n    = note: the matched value is of type `T`\n+help: ensure that all possible cases are being handled by adding a match arm with a wildcard pattern or an explicit pattern as shown\n+   |\n+LL ~         T::B => { panic!(\"goodbye\"); }\n+LL +         A(C) => todo!()\n+   |\n \n error: aborting due to 2 previous errors\n "}, {"sha": "e7fa6a7814f85358f8b7a7c59358eec5aac730a5", "filename": "src/test/ui/pattern/usefulness/non-exhaustive-match.stderr", "status": "modified", "additions": 60, "deletions": 24, "changes": 84, "blob_url": "https://github.com/rust-lang/rust/blob/b97dc20784698730bd7bc1a20eabdcd32066d174/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fnon-exhaustive-match.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b97dc20784698730bd7bc1a20eabdcd32066d174/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fnon-exhaustive-match.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fnon-exhaustive-match.stderr?ref=b97dc20784698730bd7bc1a20eabdcd32066d174", "patch": "@@ -1,91 +1,127 @@\n error[E0004]: non-exhaustive patterns: `A` not covered\n   --> $DIR/non-exhaustive-match.rs:7:11\n    |\n-LL | enum T { A, B }\n-   | ---------------\n-   | |        |\n-   | |        not covered\n-   | `T` defined here\n-...\n LL |     match x { T::B => { } }\n    |           ^ pattern `A` not covered\n    |\n-   = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n+note: `T` defined here\n+  --> $DIR/non-exhaustive-match.rs:3:10\n+   |\n+LL | enum T { A, B }\n+   |      -   ^ not covered\n    = note: the matched value is of type `T`\n+help: ensure that all possible cases are being handled by adding a match arm with a wildcard pattern or an explicit pattern as shown\n+   |\n+LL |     match x { T::B => { } A => todo!() }\n+   |                           ++++++++++++\n \n error[E0004]: non-exhaustive patterns: `false` not covered\n   --> $DIR/non-exhaustive-match.rs:8:11\n    |\n LL |     match true {\n    |           ^^^^ pattern `false` not covered\n    |\n-   = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n    = note: the matched value is of type `bool`\n+help: ensure that all possible cases are being handled by adding a match arm with a wildcard pattern or an explicit pattern as shown\n+   |\n+LL ~       true => {}\n+LL +       false => todo!()\n+   |\n \n error[E0004]: non-exhaustive patterns: `Some(_)` not covered\n   --> $DIR/non-exhaustive-match.rs:11:11\n    |\n LL |     match Some(10) {\n    |           ^^^^^^^^ pattern `Some(_)` not covered\n    |\n-  ::: $SRC_DIR/core/src/option.rs:LL:COL\n+note: `Option<i32>` defined here\n+  --> $SRC_DIR/core/src/option.rs:LL:COL\n+   |\n+LL | / pub enum Option<T> {\n+LL | |     /// No value.\n+LL | |     #[lang = \"None\"]\n+LL | |     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+...  |\n+LL | |     Some(#[stable(feature = \"rust1\", since = \"1.0.0\")] T),\n+   | |     ^^^^ not covered\n+LL | | }\n+   | |_-\n+   = note: the matched value is of type `Option<i32>`\n+help: ensure that all possible cases are being handled by adding a match arm with a wildcard pattern or an explicit pattern as shown\n    |\n-LL |     Some(#[stable(feature = \"rust1\", since = \"1.0.0\")] T),\n-   |     ---- not covered\n+LL ~       None => {}\n+LL +       Some(_) => todo!()\n    |\n-   = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n-   = note: the matched value is of type `Option<i32>`\n \n error[E0004]: non-exhaustive patterns: `(_, _, i32::MIN..=3_i32)` and `(_, _, 5_i32..=i32::MAX)` not covered\n   --> $DIR/non-exhaustive-match.rs:14:11\n    |\n LL |     match (2, 3, 4) {\n    |           ^^^^^^^^^ patterns `(_, _, i32::MIN..=3_i32)` and `(_, _, 5_i32..=i32::MAX)` not covered\n    |\n-   = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n    = note: the matched value is of type `(i32, i32, i32)`\n+help: ensure that all possible cases are being handled by adding a match arm with a wildcard pattern, a match arm with multiple or-patterns as shown, or multiple match arms\n+   |\n+LL ~       (_, _, 4) => {}\n+LL +       (_, _, i32::MIN..=3_i32) | (_, _, 5_i32..=i32::MAX) => todo!()\n+   |\n \n error[E0004]: non-exhaustive patterns: `(A, A)` and `(B, B)` not covered\n   --> $DIR/non-exhaustive-match.rs:18:11\n    |\n LL |     match (T::A, T::A) {\n    |           ^^^^^^^^^^^^ patterns `(A, A)` and `(B, B)` not covered\n    |\n-   = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n    = note: the matched value is of type `(T, T)`\n+help: ensure that all possible cases are being handled by adding a match arm with a wildcard pattern, a match arm with multiple or-patterns as shown, or multiple match arms\n+   |\n+LL ~       (T::B, T::A) => {}\n+LL +       (A, A) | (B, B) => todo!()\n+   |\n \n error[E0004]: non-exhaustive patterns: `B` not covered\n   --> $DIR/non-exhaustive-match.rs:22:11\n    |\n-LL | enum T { A, B }\n-   | ---------------\n-   | |           |\n-   | |           not covered\n-   | `T` defined here\n-...\n LL |     match T::A {\n    |           ^^^^ pattern `B` not covered\n    |\n-   = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n+note: `T` defined here\n+  --> $DIR/non-exhaustive-match.rs:3:13\n+   |\n+LL | enum T { A, B }\n+   |      -      ^ not covered\n    = note: the matched value is of type `T`\n+help: ensure that all possible cases are being handled by adding a match arm with a wildcard pattern or an explicit pattern as shown\n+   |\n+LL ~       T::A => {}\n+LL +       B => todo!()\n+   |\n \n error[E0004]: non-exhaustive patterns: `[]` not covered\n   --> $DIR/non-exhaustive-match.rs:33:11\n    |\n LL |     match *vec {\n    |           ^^^^ pattern `[]` not covered\n    |\n-   = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n    = note: the matched value is of type `[Option<isize>]`\n+help: ensure that all possible cases are being handled by adding a match arm with a wildcard pattern or an explicit pattern as shown\n+   |\n+LL ~         [None] => {}\n+LL +         [] => todo!()\n+   |\n \n error[E0004]: non-exhaustive patterns: `[_, _, _, _, ..]` not covered\n   --> $DIR/non-exhaustive-match.rs:46:11\n    |\n LL |     match *vec {\n    |           ^^^^ pattern `[_, _, _, _, ..]` not covered\n    |\n-   = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n    = note: the matched value is of type `[f32]`\n+help: ensure that all possible cases are being handled by adding a match arm with a wildcard pattern or an explicit pattern as shown\n+   |\n+LL ~         [] => (),\n+LL +         [_, _, _, _, ..] => todo!()\n+   |\n \n error: aborting due to 8 previous errors\n "}, {"sha": "b0cfd631fb07ebd28c493bafa38dd3722d1fee3c", "filename": "src/test/ui/pattern/usefulness/non-exhaustive-pattern-witness.stderr", "status": "modified", "additions": 80, "deletions": 53, "changes": 133, "blob_url": "https://github.com/rust-lang/rust/blob/b97dc20784698730bd7bc1a20eabdcd32066d174/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fnon-exhaustive-pattern-witness.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b97dc20784698730bd7bc1a20eabdcd32066d174/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fnon-exhaustive-pattern-witness.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fnon-exhaustive-pattern-witness.stderr?ref=b97dc20784698730bd7bc1a20eabdcd32066d174", "patch": "@@ -1,101 +1,128 @@\n error[E0004]: non-exhaustive patterns: `Foo { first: false, second: Some([_, _, _, _]) }` not covered\n   --> $DIR/non-exhaustive-pattern-witness.rs:7:11\n    |\n-LL | / struct Foo {\n-LL | |     first: bool,\n-LL | |     second: Option<[usize; 4]>\n-LL | | }\n-   | |_- `Foo` defined here\n-...\n-LL |       match (Foo { first: true, second: None }) {\n-   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ pattern `Foo { first: false, second: Some([_, _, _, _]) }` not covered\n+LL |     match (Foo { first: true, second: None }) {\n+   |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ pattern `Foo { first: false, second: Some([_, _, _, _]) }` not covered\n+   |\n+note: `Foo` defined here\n+  --> $DIR/non-exhaustive-pattern-witness.rs:1:8\n    |\n-   = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n+LL | struct Foo {\n+   |        ^^^\n    = note: the matched value is of type `Foo`\n+help: ensure that all possible cases are being handled by adding a match arm with a wildcard pattern or an explicit pattern as shown\n+   |\n+LL ~         Foo { first: false, second: Some([1, 2, 3, 4]) } => (),\n+LL +         Foo { first: false, second: Some([_, _, _, _]) } => todo!()\n+   |\n \n error[E0004]: non-exhaustive patterns: `Red` not covered\n   --> $DIR/non-exhaustive-pattern-witness.rs:23:11\n    |\n-LL | / enum Color {\n-LL | |     Red,\n-   | |     --- not covered\n-LL | |     Green,\n-LL | |     CustomRGBA { a: bool, r: u8, g: u8, b: u8 }\n-LL | | }\n-   | |_- `Color` defined here\n-...\n-LL |       match Color::Red {\n-   |             ^^^^^^^^^^ pattern `Red` not covered\n+LL |     match Color::Red {\n+   |           ^^^^^^^^^^ pattern `Red` not covered\n+   |\n+note: `Color` defined here\n+  --> $DIR/non-exhaustive-pattern-witness.rs:17:5\n    |\n-   = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n+LL | enum Color {\n+   |      -----\n+LL |     Red,\n+   |     ^^^ not covered\n    = note: the matched value is of type `Color`\n+help: ensure that all possible cases are being handled by adding a match arm with a wildcard pattern or an explicit pattern as shown\n+   |\n+LL ~         Color::Green => (),\n+LL +         Red => todo!()\n+   |\n \n error[E0004]: non-exhaustive patterns: `East`, `South` and `West` not covered\n   --> $DIR/non-exhaustive-pattern-witness.rs:35:11\n    |\n-LL | / enum Direction {\n-LL | |     North, East, South, West\n-   | |            ----  -----  ---- not covered\n-   | |            |     |\n-   | |            |     not covered\n-   | |            not covered\n-LL | | }\n-   | |_- `Direction` defined here\n-...\n-LL |       match Direction::North {\n-   |             ^^^^^^^^^^^^^^^^ patterns `East`, `South` and `West` not covered\n+LL |     match Direction::North {\n+   |           ^^^^^^^^^^^^^^^^ patterns `East`, `South` and `West` not covered\n+   |\n+note: `Direction` defined here\n+  --> $DIR/non-exhaustive-pattern-witness.rs:31:12\n    |\n-   = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n+LL | enum Direction {\n+   |      ---------\n+LL |     North, East, South, West\n+   |            ^^^^  ^^^^^  ^^^^ not covered\n+   |            |     |\n+   |            |     not covered\n+   |            not covered\n    = note: the matched value is of type `Direction`\n+help: ensure that all possible cases are being handled by adding a match arm with a wildcard pattern, a match arm with multiple or-patterns as shown, or multiple match arms\n+   |\n+LL ~         Direction::North => (),\n+LL +         East | South | West => todo!()\n+   |\n \n error[E0004]: non-exhaustive patterns: `Second`, `Third`, `Fourth` and 8 more not covered\n   --> $DIR/non-exhaustive-pattern-witness.rs:46:11\n    |\n-LL | / enum ExcessiveEnum {\n-LL | |     First, Second, Third, Fourth, Fifth, Sixth, Seventh, Eighth, Ninth, Tenth, Eleventh, Twelfth\n-LL | | }\n-   | |_- `ExcessiveEnum` defined here\n-...\n-LL |       match ExcessiveEnum::First {\n-   |             ^^^^^^^^^^^^^^^^^^^^ patterns `Second`, `Third`, `Fourth` and 8 more not covered\n+LL |     match ExcessiveEnum::First {\n+   |           ^^^^^^^^^^^^^^^^^^^^ patterns `Second`, `Third`, `Fourth` and 8 more not covered\n    |\n-   = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n+note: `ExcessiveEnum` defined here\n+  --> $DIR/non-exhaustive-pattern-witness.rs:41:6\n+   |\n+LL | enum ExcessiveEnum {\n+   |      ^^^^^^^^^^^^^\n    = note: the matched value is of type `ExcessiveEnum`\n+help: ensure that all possible cases are being handled by adding a match arm with a wildcard pattern as shown, or multiple match arms\n+   |\n+LL ~         ExcessiveEnum::First => (),\n+LL +         _ => todo!()\n+   |\n \n error[E0004]: non-exhaustive patterns: `CustomRGBA { a: true, .. }` not covered\n   --> $DIR/non-exhaustive-pattern-witness.rs:54:11\n    |\n-LL | / enum Color {\n-LL | |     Red,\n-LL | |     Green,\n-LL | |     CustomRGBA { a: bool, r: u8, g: u8, b: u8 }\n-   | |     ---------- not covered\n-LL | | }\n-   | |_- `Color` defined here\n-...\n-LL |       match Color::Red {\n-   |             ^^^^^^^^^^ pattern `CustomRGBA { a: true, .. }` not covered\n+LL |     match Color::Red {\n+   |           ^^^^^^^^^^ pattern `CustomRGBA { a: true, .. }` not covered\n+   |\n+note: `Color` defined here\n+  --> $DIR/non-exhaustive-pattern-witness.rs:19:5\n    |\n-   = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n+LL | enum Color {\n+   |      -----\n+...\n+LL |     CustomRGBA { a: bool, r: u8, g: u8, b: u8 }\n+   |     ^^^^^^^^^^ not covered\n    = note: the matched value is of type `Color`\n+help: ensure that all possible cases are being handled by adding a match arm with a wildcard pattern or an explicit pattern as shown\n+   |\n+LL ~         Color::CustomRGBA { a: false, r: _, g: _, b: _ } => (),\n+LL +         CustomRGBA { a: true, .. } => todo!()\n+   |\n \n error[E0004]: non-exhaustive patterns: `[Second(true), Second(false)]` not covered\n   --> $DIR/non-exhaustive-pattern-witness.rs:70:11\n    |\n LL |     match *x {\n    |           ^^ pattern `[Second(true), Second(false)]` not covered\n    |\n-   = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n    = note: the matched value is of type `[Enum]`\n+help: ensure that all possible cases are being handled by adding a match arm with a wildcard pattern or an explicit pattern as shown\n+   |\n+LL ~         [_, _, ref tail @ .., _] => (),\n+LL +         [Second(true), Second(false)] => todo!()\n+   |\n \n error[E0004]: non-exhaustive patterns: `((), false)` not covered\n   --> $DIR/non-exhaustive-pattern-witness.rs:83:11\n    |\n LL |     match ((), false) {\n    |           ^^^^^^^^^^^ pattern `((), false)` not covered\n    |\n-   = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n    = note: the matched value is of type `((), bool)`\n+help: ensure that all possible cases are being handled by adding a match arm with a wildcard pattern or an explicit pattern as shown\n+   |\n+LL ~         ((), true) => (),\n+LL +         ((), false) => todo!()\n+   |\n \n error: aborting due to 7 previous errors\n "}, {"sha": "5d1e170ae6c2b5739f4396f09cd1e09c2d55cb53", "filename": "src/test/ui/pattern/usefulness/slice-patterns-exhaustiveness.stderr", "status": "modified", "additions": 100, "deletions": 20, "changes": 120, "blob_url": "https://github.com/rust-lang/rust/blob/b97dc20784698730bd7bc1a20eabdcd32066d174/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fslice-patterns-exhaustiveness.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b97dc20784698730bd7bc1a20eabdcd32066d174/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fslice-patterns-exhaustiveness.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fslice-patterns-exhaustiveness.stderr?ref=b97dc20784698730bd7bc1a20eabdcd32066d174", "patch": "@@ -4,179 +4,259 @@ error[E0004]: non-exhaustive patterns: `&[false, _]` not covered\n LL |     match s2 {\n    |           ^^ pattern `&[false, _]` not covered\n    |\n-   = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n    = note: the matched value is of type `&[bool; 2]`\n+help: ensure that all possible cases are being handled by adding a match arm with a wildcard pattern or an explicit pattern as shown\n+   |\n+LL ~         [true, .., true] => {}\n+LL +         &[false, _] => todo!()\n+   |\n \n error[E0004]: non-exhaustive patterns: `&[false, ..]` not covered\n   --> $DIR/slice-patterns-exhaustiveness.rs:12:11\n    |\n LL |     match s3 {\n    |           ^^ pattern `&[false, ..]` not covered\n    |\n-   = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n    = note: the matched value is of type `&[bool; 3]`\n+help: ensure that all possible cases are being handled by adding a match arm with a wildcard pattern or an explicit pattern as shown\n+   |\n+LL ~         [true, .., true] => {}\n+LL +         &[false, ..] => todo!()\n+   |\n \n error[E0004]: non-exhaustive patterns: `&[false, ..]` not covered\n   --> $DIR/slice-patterns-exhaustiveness.rs:16:11\n    |\n LL |     match s10 {\n    |           ^^^ pattern `&[false, ..]` not covered\n    |\n-   = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n    = note: the matched value is of type `&[bool; 10]`\n+help: ensure that all possible cases are being handled by adding a match arm with a wildcard pattern or an explicit pattern as shown\n+   |\n+LL ~         [true, .., true] => {}\n+LL +         &[false, ..] => todo!()\n+   |\n \n error[E0004]: non-exhaustive patterns: `&[false, true]` not covered\n   --> $DIR/slice-patterns-exhaustiveness.rs:25:11\n    |\n LL |     match s2 {\n    |           ^^ pattern `&[false, true]` not covered\n    |\n-   = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n    = note: the matched value is of type `&[bool; 2]`\n+help: ensure that all possible cases are being handled by adding a match arm with a wildcard pattern or an explicit pattern as shown\n+   |\n+LL ~         [.., false] => {}\n+LL +         &[false, true] => todo!()\n+   |\n \n error[E0004]: non-exhaustive patterns: `&[false, .., true]` not covered\n   --> $DIR/slice-patterns-exhaustiveness.rs:30:11\n    |\n LL |     match s3 {\n    |           ^^ pattern `&[false, .., true]` not covered\n    |\n-   = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n    = note: the matched value is of type `&[bool; 3]`\n+help: ensure that all possible cases are being handled by adding a match arm with a wildcard pattern or an explicit pattern as shown\n+   |\n+LL ~         [.., false] => {}\n+LL +         &[false, .., true] => todo!()\n+   |\n \n error[E0004]: non-exhaustive patterns: `&[false, .., true]` not covered\n   --> $DIR/slice-patterns-exhaustiveness.rs:35:11\n    |\n LL |     match s {\n    |           ^ pattern `&[false, .., true]` not covered\n    |\n-   = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n    = note: the matched value is of type `&[bool]`\n+help: ensure that all possible cases are being handled by adding a match arm with a wildcard pattern or an explicit pattern as shown\n+   |\n+LL ~         [.., false] => {}\n+LL +         &[false, .., true] => todo!()\n+   |\n \n error[E0004]: non-exhaustive patterns: `&[_, ..]` not covered\n   --> $DIR/slice-patterns-exhaustiveness.rs:42:11\n    |\n LL |     match s {\n    |           ^ pattern `&[_, ..]` not covered\n    |\n-   = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n    = note: the matched value is of type `&[bool]`\n+help: ensure that all possible cases are being handled by adding a match arm with a wildcard pattern or an explicit pattern as shown\n+   |\n+LL ~         [] => {}\n+LL +         &[_, ..] => todo!()\n+   |\n \n error[E0004]: non-exhaustive patterns: `&[_, _, ..]` not covered\n   --> $DIR/slice-patterns-exhaustiveness.rs:46:11\n    |\n LL |     match s {\n    |           ^ pattern `&[_, _, ..]` not covered\n    |\n-   = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n    = note: the matched value is of type `&[bool]`\n+help: ensure that all possible cases are being handled by adding a match arm with a wildcard pattern or an explicit pattern as shown\n+   |\n+LL ~         [_] => {}\n+LL +         &[_, _, ..] => todo!()\n+   |\n \n error[E0004]: non-exhaustive patterns: `&[false, ..]` not covered\n   --> $DIR/slice-patterns-exhaustiveness.rs:51:11\n    |\n LL |     match s {\n    |           ^ pattern `&[false, ..]` not covered\n    |\n-   = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n    = note: the matched value is of type `&[bool]`\n+help: ensure that all possible cases are being handled by adding a match arm with a wildcard pattern or an explicit pattern as shown\n+   |\n+LL ~         [true, ..] => {}\n+LL +         &[false, ..] => todo!()\n+   |\n \n error[E0004]: non-exhaustive patterns: `&[false, _, ..]` not covered\n   --> $DIR/slice-patterns-exhaustiveness.rs:56:11\n    |\n LL |     match s {\n    |           ^ pattern `&[false, _, ..]` not covered\n    |\n-   = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n    = note: the matched value is of type `&[bool]`\n+help: ensure that all possible cases are being handled by adding a match arm with a wildcard pattern or an explicit pattern as shown\n+   |\n+LL ~         [true, ..] => {}\n+LL +         &[false, _, ..] => todo!()\n+   |\n \n error[E0004]: non-exhaustive patterns: `&[_, .., false]` not covered\n   --> $DIR/slice-patterns-exhaustiveness.rs:62:11\n    |\n LL |     match s {\n    |           ^ pattern `&[_, .., false]` not covered\n    |\n-   = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n    = note: the matched value is of type `&[bool]`\n+help: ensure that all possible cases are being handled by adding a match arm with a wildcard pattern or an explicit pattern as shown\n+   |\n+LL ~         [.., true] => {}\n+LL +         &[_, .., false] => todo!()\n+   |\n \n error[E0004]: non-exhaustive patterns: `&[_, _, .., true]` not covered\n   --> $DIR/slice-patterns-exhaustiveness.rs:69:11\n    |\n LL |     match s {\n    |           ^ pattern `&[_, _, .., true]` not covered\n    |\n-   = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n    = note: the matched value is of type `&[bool]`\n+help: ensure that all possible cases are being handled by adding a match arm with a wildcard pattern or an explicit pattern as shown\n+   |\n+LL ~         [.., false] => {}\n+LL +         &[_, _, .., true] => todo!()\n+   |\n \n error[E0004]: non-exhaustive patterns: `&[true, _, .., _]` not covered\n   --> $DIR/slice-patterns-exhaustiveness.rs:76:11\n    |\n LL |     match s {\n    |           ^ pattern `&[true, _, .., _]` not covered\n    |\n-   = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n    = note: the matched value is of type `&[bool]`\n+help: ensure that all possible cases are being handled by adding a match arm with a wildcard pattern or an explicit pattern as shown\n+   |\n+LL ~         [false, .., false] => {}\n+LL +         &[true, _, .., _] => todo!()\n+   |\n \n error[E0004]: non-exhaustive patterns: `&[]` and `&[_, _, ..]` not covered\n   --> $DIR/slice-patterns-exhaustiveness.rs:85:11\n    |\n LL |     match s {\n    |           ^ patterns `&[]` and `&[_, _, ..]` not covered\n    |\n-   = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n    = note: the matched value is of type `&[bool]`\n+help: ensure that all possible cases are being handled by adding a match arm with a wildcard pattern, a match arm with multiple or-patterns as shown, or multiple match arms\n+   |\n+LL ~         &[true] => {}\n+LL +         &[] | &[_, _, ..] => todo!()\n+   |\n \n error[E0004]: non-exhaustive patterns: `&[]` and `&[_, _, ..]` not covered\n   --> $DIR/slice-patterns-exhaustiveness.rs:89:11\n    |\n LL |     match s {\n    |           ^ patterns `&[]` and `&[_, _, ..]` not covered\n    |\n-   = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n    = note: the matched value is of type `&[bool]`\n+help: ensure that all possible cases are being handled by adding a match arm with a wildcard pattern, a match arm with multiple or-patterns as shown, or multiple match arms\n+   |\n+LL ~         CONST => {}\n+LL +         &[] | &[_, _, ..] => todo!()\n+   |\n \n error[E0004]: non-exhaustive patterns: `&[]` and `&[_, _, ..]` not covered\n   --> $DIR/slice-patterns-exhaustiveness.rs:93:11\n    |\n LL |     match s {\n    |           ^ patterns `&[]` and `&[_, _, ..]` not covered\n    |\n-   = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n    = note: the matched value is of type `&[bool]`\n+help: ensure that all possible cases are being handled by adding a match arm with a wildcard pattern, a match arm with multiple or-patterns as shown, or multiple match arms\n+   |\n+LL ~         &[false] => {}\n+LL +         &[] | &[_, _, ..] => todo!()\n+   |\n \n error[E0004]: non-exhaustive patterns: `&[]` and `&[_, _, ..]` not covered\n   --> $DIR/slice-patterns-exhaustiveness.rs:98:11\n    |\n LL |     match s {\n    |           ^ patterns `&[]` and `&[_, _, ..]` not covered\n    |\n-   = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n    = note: the matched value is of type `&[bool]`\n+help: ensure that all possible cases are being handled by adding a match arm with a wildcard pattern, a match arm with multiple or-patterns as shown, or multiple match arms\n+   |\n+LL ~         CONST => {}\n+LL +         &[] | &[_, _, ..] => todo!()\n+   |\n \n error[E0004]: non-exhaustive patterns: `&[_, _, ..]` not covered\n   --> $DIR/slice-patterns-exhaustiveness.rs:103:11\n    |\n LL |     match s {\n    |           ^ pattern `&[_, _, ..]` not covered\n    |\n-   = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n    = note: the matched value is of type `&[bool]`\n+help: ensure that all possible cases are being handled by adding a match arm with a wildcard pattern or an explicit pattern as shown\n+   |\n+LL ~         CONST => {}\n+LL +         &[_, _, ..] => todo!()\n+   |\n \n error[E0004]: non-exhaustive patterns: `&[false]` not covered\n   --> $DIR/slice-patterns-exhaustiveness.rs:108:11\n    |\n LL |     match s {\n    |           ^ pattern `&[false]` not covered\n    |\n-   = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n    = note: the matched value is of type `&[bool]`\n+help: ensure that all possible cases are being handled by adding a match arm with a wildcard pattern or an explicit pattern as shown\n+   |\n+LL ~         &[_, _, ..] => {}\n+LL +         &[false] => todo!()\n+   |\n \n error[E0004]: non-exhaustive patterns: `&[false]` not covered\n   --> $DIR/slice-patterns-exhaustiveness.rs:121:11\n    |\n LL |     match s1 {\n    |           ^^ pattern `&[false]` not covered\n    |\n-   = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n    = note: the matched value is of type `&[bool; 1]`\n+help: ensure that all possible cases are being handled by adding a match arm with a wildcard pattern or an explicit pattern as shown\n+   |\n+LL ~         CONST1 => {}\n+LL +         &[false] => todo!()\n+   |\n \n error: aborting due to 20 previous errors\n "}, {"sha": "696ef9d8de9362d2ef539a56217077ec87403782", "filename": "src/test/ui/pattern/usefulness/stable-gated-patterns.stderr", "status": "modified", "additions": 33, "deletions": 6, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/b97dc20784698730bd7bc1a20eabdcd32066d174/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fstable-gated-patterns.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b97dc20784698730bd7bc1a20eabdcd32066d174/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fstable-gated-patterns.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fstable-gated-patterns.stderr?ref=b97dc20784698730bd7bc1a20eabdcd32066d174", "patch": "@@ -4,22 +4,49 @@ error[E0004]: non-exhaustive patterns: `Stable2` and `_` not covered\n LL |     match Foo::Stable {\n    |           ^^^^^^^^^^^ patterns `Stable2` and `_` not covered\n    |\n-  ::: $DIR/auxiliary/unstable.rs:9:5\n+note: `Foo` defined here\n+  --> $DIR/auxiliary/unstable.rs:9:5\n    |\n-LL |     Stable2,\n-   |     ------- not covered\n-   |\n-   = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n+LL | / pub enum Foo {\n+LL | |     #[stable(feature = \"stable_test_feature\", since = \"1.0.0\")]\n+LL | |     Stable,\n+LL | |     #[stable(feature = \"stable_test_feature\", since = \"1.0.0\")]\n+LL | |     Stable2,\n+   | |     ^^^^^^^ not covered\n+LL | |     #[unstable(feature = \"unstable_test_feature\", issue = \"none\")]\n+LL | |     Unstable,\n+LL | | }\n+   | |_-\n    = note: the matched value is of type `Foo`\n+help: ensure that all possible cases are being handled by adding a match arm with a wildcard pattern, a match arm with multiple or-patterns as shown, or multiple match arms\n+   |\n+LL ~         Foo::Stable => {}\n+LL +         Stable2 | _ => todo!()\n+   |\n \n error[E0004]: non-exhaustive patterns: `_` not covered\n   --> $DIR/stable-gated-patterns.rs:13:11\n    |\n LL |     match Foo::Stable {\n    |           ^^^^^^^^^^^ pattern `_` not covered\n    |\n-   = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n+note: `Foo` defined here\n+  --> $DIR/auxiliary/unstable.rs:5:1\n+   |\n+LL | / pub enum Foo {\n+LL | |     #[stable(feature = \"stable_test_feature\", since = \"1.0.0\")]\n+LL | |     Stable,\n+LL | |     #[stable(feature = \"stable_test_feature\", since = \"1.0.0\")]\n+...  |\n+LL | |     Unstable,\n+LL | | }\n+   | |_^\n    = note: the matched value is of type `Foo`\n+help: ensure that all possible cases are being handled by adding a match arm with a wildcard pattern or an explicit pattern as shown\n+   |\n+LL ~         Foo::Stable2 => {}\n+LL +         _ => todo!()\n+   |\n \n error: aborting due to 2 previous errors\n "}, {"sha": "6127fad3f7d54410d144a5d218c6e100cf043366", "filename": "src/test/ui/pattern/usefulness/struct-like-enum-nonexhaustive.stderr", "status": "modified", "additions": 14, "deletions": 10, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/b97dc20784698730bd7bc1a20eabdcd32066d174/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fstruct-like-enum-nonexhaustive.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b97dc20784698730bd7bc1a20eabdcd32066d174/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fstruct-like-enum-nonexhaustive.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fstruct-like-enum-nonexhaustive.stderr?ref=b97dc20784698730bd7bc1a20eabdcd32066d174", "patch": "@@ -1,18 +1,22 @@\n error[E0004]: non-exhaustive patterns: `B { x: Some(_) }` not covered\n   --> $DIR/struct-like-enum-nonexhaustive.rs:8:11\n    |\n-LL | / enum A {\n-LL | |     B { x: Option<isize> },\n-   | |     - not covered\n-LL | |     C\n-LL | | }\n-   | |_- `A` defined here\n-...\n-LL |       match x {\n-   |             ^ pattern `B { x: Some(_) }` not covered\n+LL |     match x {\n+   |           ^ pattern `B { x: Some(_) }` not covered\n    |\n-   = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n+note: `A` defined here\n+  --> $DIR/struct-like-enum-nonexhaustive.rs:2:5\n+   |\n+LL | enum A {\n+   |      -\n+LL |     B { x: Option<isize> },\n+   |     ^ not covered\n    = note: the matched value is of type `A`\n+help: ensure that all possible cases are being handled by adding a match arm with a wildcard pattern or an explicit pattern as shown\n+   |\n+LL ~         A::B { x: None } => {}\n+LL +         B { x: Some(_) } => todo!()\n+   |\n \n error: aborting due to previous error\n "}, {"sha": "fc0430d06fa1c03354a6875b6040d6793548f9b2", "filename": "src/test/ui/pattern/usefulness/tuple-struct-nonexhaustive.stderr", "status": "modified", "additions": 10, "deletions": 4, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/b97dc20784698730bd7bc1a20eabdcd32066d174/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Ftuple-struct-nonexhaustive.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b97dc20784698730bd7bc1a20eabdcd32066d174/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Ftuple-struct-nonexhaustive.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Ftuple-struct-nonexhaustive.stderr?ref=b97dc20784698730bd7bc1a20eabdcd32066d174", "patch": "@@ -1,14 +1,20 @@\n error[E0004]: non-exhaustive patterns: `Foo(_, _)` not covered\n   --> $DIR/tuple-struct-nonexhaustive.rs:5:11\n    |\n-LL | struct Foo(isize, isize);\n-   | ------------------------- `Foo` defined here\n-...\n LL |     match x {\n    |           ^ pattern `Foo(_, _)` not covered\n    |\n-   = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n+note: `Foo` defined here\n+  --> $DIR/tuple-struct-nonexhaustive.rs:1:8\n+   |\n+LL | struct Foo(isize, isize);\n+   |        ^^^\n    = note: the matched value is of type `Foo`\n+help: ensure that all possible cases are being handled by adding a match arm with a wildcard pattern or an explicit pattern as shown\n+   |\n+LL ~         Foo(2, b) => println!(\"{}\", b)\n+LL +         Foo(_, _) => todo!()\n+   |\n \n error: aborting due to previous error\n "}, {"sha": "acae605dae3a870f60e58cb3ccbea349d8eb0441", "filename": "src/test/ui/pattern/usefulness/type_polymorphic_byte_str_literals.stderr", "status": "modified", "additions": 10, "deletions": 2, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/b97dc20784698730bd7bc1a20eabdcd32066d174/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Ftype_polymorphic_byte_str_literals.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b97dc20784698730bd7bc1a20eabdcd32066d174/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Ftype_polymorphic_byte_str_literals.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Ftype_polymorphic_byte_str_literals.stderr?ref=b97dc20784698730bd7bc1a20eabdcd32066d174", "patch": "@@ -4,17 +4,25 @@ error[E0004]: non-exhaustive patterns: `&[_, ..]` not covered\n LL |     match data {\n    |           ^^^^ pattern `&[_, ..]` not covered\n    |\n-   = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n    = note: the matched value is of type `&[u8]`\n+help: ensure that all possible cases are being handled by adding a match arm with a wildcard pattern or an explicit pattern as shown\n+   |\n+LL ~         b\"\" => 1,\n+LL ~         &[_, ..] => todo!(),\n+   |\n \n error[E0004]: non-exhaustive patterns: `&[]`, `&[_]`, `&[_, _]` and 1 more not covered\n   --> $DIR/type_polymorphic_byte_str_literals.rs:23:11\n    |\n LL |     match data {\n    |           ^^^^ patterns `&[]`, `&[_]`, `&[_, _]` and 1 more not covered\n    |\n-   = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n    = note: the matched value is of type `&[u8]`\n+help: ensure that all possible cases are being handled by adding a match arm with a wildcard pattern as shown, or multiple match arms\n+   |\n+LL ~         [_, _, _] => 1,\n+LL ~         _ => todo!(),\n+   |\n \n error: aborting due to 2 previous errors\n "}, {"sha": "8487c9725da8332f6935291b7ec28b33454786a0", "filename": "src/test/ui/pattern/usefulness/unstable-gated-patterns.stderr", "status": "modified", "additions": 16, "deletions": 5, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/b97dc20784698730bd7bc1a20eabdcd32066d174/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Funstable-gated-patterns.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b97dc20784698730bd7bc1a20eabdcd32066d174/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Funstable-gated-patterns.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Funstable-gated-patterns.stderr?ref=b97dc20784698730bd7bc1a20eabdcd32066d174", "patch": "@@ -4,13 +4,24 @@ error[E0004]: non-exhaustive patterns: `Unstable` not covered\n LL |     match Foo::Stable {\n    |           ^^^^^^^^^^^ pattern `Unstable` not covered\n    |\n-  ::: $DIR/auxiliary/unstable.rs:11:5\n+note: `Foo` defined here\n+  --> $DIR/auxiliary/unstable.rs:11:5\n    |\n-LL |     Unstable,\n-   |     -------- not covered\n-   |\n-   = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n+LL | / pub enum Foo {\n+LL | |     #[stable(feature = \"stable_test_feature\", since = \"1.0.0\")]\n+LL | |     Stable,\n+LL | |     #[stable(feature = \"stable_test_feature\", since = \"1.0.0\")]\n+...  |\n+LL | |     Unstable,\n+   | |     ^^^^^^^^ not covered\n+LL | | }\n+   | |_-\n    = note: the matched value is of type `Foo`\n+help: ensure that all possible cases are being handled by adding a match arm with a wildcard pattern or an explicit pattern as shown\n+   |\n+LL ~         Foo::Stable2 => {}\n+LL +         Unstable => todo!()\n+   |\n \n error: aborting due to previous error\n "}, {"sha": "ded3cf3ad1d44ab24ed3bd39afea4f634b965b7d", "filename": "src/test/ui/recursion/recursive-types-are-not-uninhabited.stderr", "status": "modified", "additions": 12, "deletions": 5, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/b97dc20784698730bd7bc1a20eabdcd32066d174/src%2Ftest%2Fui%2Frecursion%2Frecursive-types-are-not-uninhabited.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b97dc20784698730bd7bc1a20eabdcd32066d174/src%2Ftest%2Fui%2Frecursion%2Frecursive-types-are-not-uninhabited.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frecursion%2Frecursive-types-are-not-uninhabited.stderr?ref=b97dc20784698730bd7bc1a20eabdcd32066d174", "patch": "@@ -4,13 +4,20 @@ error[E0005]: refutable pattern in local binding: `Err(_)` not covered\n LL |     let Ok(x) = res;\n    |         ^^^^^ pattern `Err(_)` not covered\n    |\n-  ::: $SRC_DIR/core/src/result.rs:LL:COL\n-   |\n-LL |     Err(#[stable(feature = \"rust1\", since = \"1.0.0\")] E),\n-   |     --- not covered\n-   |\n    = note: `let` bindings require an \"irrefutable pattern\", like a `struct` or an `enum` with only one variant\n    = note: for more information, visit https://doc.rust-lang.org/book/ch18-02-refutability.html\n+note: `Result<u32, &R>` defined here\n+  --> $SRC_DIR/core/src/result.rs:LL:COL\n+   |\n+LL | / pub enum Result<T, E> {\n+LL | |     /// Contains the success value\n+LL | |     #[lang = \"Ok\"]\n+LL | |     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+...  |\n+LL | |     Err(#[stable(feature = \"rust1\", since = \"1.0.0\")] E),\n+   | |     ^^^ not covered\n+LL | | }\n+   | |_-\n    = note: the matched value is of type `Result<u32, &R>`\n help: you might want to use `if let` to ignore the variant that isn't matched\n    |"}, {"sha": "60c1f5420f62c29322de982b95fc63ad28cdf9d8", "filename": "src/test/ui/rfc-2005-default-binding-mode/slice.stderr", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b97dc20784698730bd7bc1a20eabdcd32066d174/src%2Ftest%2Fui%2Frfc-2005-default-binding-mode%2Fslice.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b97dc20784698730bd7bc1a20eabdcd32066d174/src%2Ftest%2Fui%2Frfc-2005-default-binding-mode%2Fslice.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc-2005-default-binding-mode%2Fslice.stderr?ref=b97dc20784698730bd7bc1a20eabdcd32066d174", "patch": "@@ -4,8 +4,12 @@ error[E0004]: non-exhaustive patterns: `&[]` not covered\n LL |     match sl {\n    |           ^^ pattern `&[]` not covered\n    |\n-   = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n    = note: the matched value is of type `&[u8]`\n+help: ensure that all possible cases are being handled by adding a match arm with a wildcard pattern or an explicit pattern as shown\n+   |\n+LL ~         [first, remainder @ ..] => {}\n+LL ~         &[] => todo!(),\n+   |\n \n error: aborting due to previous error\n "}, {"sha": "5ef078c20057df6faeb2dd592a53b16358fb7f21", "filename": "src/test/ui/rfc-2008-non-exhaustive/enum.stderr", "status": "modified", "additions": 40, "deletions": 3, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/b97dc20784698730bd7bc1a20eabdcd32066d174/src%2Ftest%2Fui%2Frfc-2008-non-exhaustive%2Fenum.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b97dc20784698730bd7bc1a20eabdcd32066d174/src%2Ftest%2Fui%2Frfc-2008-non-exhaustive%2Fenum.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc-2008-non-exhaustive%2Fenum.stderr?ref=b97dc20784698730bd7bc1a20eabdcd32066d174", "patch": "@@ -4,26 +4,63 @@ error[E0004]: non-exhaustive patterns: type `EmptyNonExhaustiveEnum` is non-empt\n LL |     match x {}\n    |           ^\n    |\n-   = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n+note: `EmptyNonExhaustiveEnum` defined here\n+  --> $DIR/auxiliary/enums.rs:18:1\n+   |\n+LL | pub enum EmptyNonExhaustiveEnum {}\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    = note: the matched value is of type `EmptyNonExhaustiveEnum`, which is marked as non-exhaustive\n+help: ensure that all possible cases are being handled by adding a match arm with a wildcard pattern as shown\n+   |\n+LL ~     match x {\n+LL +         _ => todo!(),\n+LL ~     }\n+   |\n \n error[E0004]: non-exhaustive patterns: `_` not covered\n   --> $DIR/enum.rs:16:11\n    |\n LL |     match enum_unit {\n    |           ^^^^^^^^^ pattern `_` not covered\n    |\n-   = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n+note: `NonExhaustiveEnum` defined here\n+  --> $DIR/auxiliary/enums.rs:4:1\n+   |\n+LL | / pub enum NonExhaustiveEnum {\n+LL | |     Unit,\n+LL | |     Tuple(u32),\n+LL | |     Struct { field: u32 },\n+LL | | }\n+   | |_^\n    = note: the matched value is of type `NonExhaustiveEnum`, which is marked as non-exhaustive\n+help: ensure that all possible cases are being handled by adding a match arm with a wildcard pattern or an explicit pattern as shown\n+   |\n+LL ~         NonExhaustiveEnum::Struct { .. } => \"third\",\n+LL +         _ => todo!()\n+   |\n \n error[E0004]: non-exhaustive patterns: `_` not covered\n   --> $DIR/enum.rs:23:11\n    |\n LL |     match enum_unit {};\n    |           ^^^^^^^^^ pattern `_` not covered\n    |\n-   = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n+note: `NonExhaustiveEnum` defined here\n+  --> $DIR/auxiliary/enums.rs:4:1\n+   |\n+LL | / pub enum NonExhaustiveEnum {\n+LL | |     Unit,\n+LL | |     Tuple(u32),\n+LL | |     Struct { field: u32 },\n+LL | | }\n+   | |_^\n    = note: the matched value is of type `NonExhaustiveEnum`, which is marked as non-exhaustive\n+help: ensure that all possible cases are being handled by adding a match arm with a wildcard pattern or an explicit pattern as shown\n+   |\n+LL ~     match enum_unit {\n+LL +         _ => todo!(),\n+LL ~     };\n+   |\n \n error: aborting due to 3 previous errors\n "}, {"sha": "1f20904483fe755649f29eec70edd5d371ce43ce", "filename": "src/test/ui/rfc-2008-non-exhaustive/enum_same_crate_empty_match.stderr", "status": "modified", "additions": 44, "deletions": 34, "changes": 78, "blob_url": "https://github.com/rust-lang/rust/blob/b97dc20784698730bd7bc1a20eabdcd32066d174/src%2Ftest%2Fui%2Frfc-2008-non-exhaustive%2Fenum_same_crate_empty_match.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b97dc20784698730bd7bc1a20eabdcd32066d174/src%2Ftest%2Fui%2Frfc-2008-non-exhaustive%2Fenum_same_crate_empty_match.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc-2008-non-exhaustive%2Fenum_same_crate_empty_match.stderr?ref=b97dc20784698730bd7bc1a20eabdcd32066d174", "patch": "@@ -13,46 +13,56 @@ LL | #![deny(unreachable_patterns)]\n error[E0004]: non-exhaustive patterns: `Unit`, `Tuple(_)` and `Struct { .. }` not covered\n   --> $DIR/enum_same_crate_empty_match.rs:33:11\n    |\n-LL | / pub enum NonExhaustiveEnum {\n-LL | |     Unit,\n-   | |     ---- not covered\n-LL | |\n-LL | |     Tuple(u32),\n-   | |     ----- not covered\n-LL | |\n-LL | |     Struct { field: u32 }\n-   | |     ------ not covered\n-LL | |\n-LL | | }\n-   | |_- `NonExhaustiveEnum` defined here\n-...\n-LL |       match NonExhaustiveEnum::Unit {}\n-   |             ^^^^^^^^^^^^^^^^^^^^^^^ patterns `Unit`, `Tuple(_)` and `Struct { .. }` not covered\n-   |\n-   = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n+LL |     match NonExhaustiveEnum::Unit {}\n+   |           ^^^^^^^^^^^^^^^^^^^^^^^ patterns `Unit`, `Tuple(_)` and `Struct { .. }` not covered\n+   |\n+note: `NonExhaustiveEnum` defined here\n+  --> $DIR/enum_same_crate_empty_match.rs:5:5\n+   |\n+LL | pub enum NonExhaustiveEnum {\n+   |          -----------------\n+LL |     Unit,\n+   |     ^^^^ not covered\n+LL |\n+LL |     Tuple(u32),\n+   |     ^^^^^ not covered\n+LL |\n+LL |     Struct { field: u32 }\n+   |     ^^^^^^ not covered\n    = note: the matched value is of type `NonExhaustiveEnum`\n+help: ensure that all possible cases are being handled by adding a match arm with a wildcard pattern, a match arm with multiple or-patterns as shown, or multiple match arms\n+   |\n+LL ~     match NonExhaustiveEnum::Unit {\n+LL +         Unit | Tuple(_) | Struct { .. } => todo!(),\n+LL +     }\n+   |\n \n error[E0004]: non-exhaustive patterns: `Unit`, `Tuple(_)` and `Struct { .. }` not covered\n   --> $DIR/enum_same_crate_empty_match.rs:35:11\n    |\n-LL | / pub enum NormalEnum {\n-LL | |     Unit,\n-   | |     ---- not covered\n-LL | |\n-LL | |     Tuple(u32),\n-   | |     ----- not covered\n-LL | |\n-LL | |     Struct { field: u32 }\n-   | |     ------ not covered\n-LL | |\n-LL | | }\n-   | |_- `NormalEnum` defined here\n-...\n-LL |       match NormalEnum::Unit {}\n-   |             ^^^^^^^^^^^^^^^^ patterns `Unit`, `Tuple(_)` and `Struct { .. }` not covered\n-   |\n-   = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n+LL |     match NormalEnum::Unit {}\n+   |           ^^^^^^^^^^^^^^^^ patterns `Unit`, `Tuple(_)` and `Struct { .. }` not covered\n+   |\n+note: `NormalEnum` defined here\n+  --> $DIR/enum_same_crate_empty_match.rs:14:5\n+   |\n+LL | pub enum NormalEnum {\n+   |          ----------\n+LL |     Unit,\n+   |     ^^^^ not covered\n+LL |\n+LL |     Tuple(u32),\n+   |     ^^^^^ not covered\n+LL |\n+LL |     Struct { field: u32 }\n+   |     ^^^^^^ not covered\n    = note: the matched value is of type `NormalEnum`\n+help: ensure that all possible cases are being handled by adding a match arm with a wildcard pattern, a match arm with multiple or-patterns as shown, or multiple match arms\n+   |\n+LL ~     match NormalEnum::Unit {\n+LL +         Unit | Tuple(_) | Struct { .. } => todo!(),\n+LL +     }\n+   |\n \n error: aborting due to 3 previous errors\n "}, {"sha": "2dc4eabb8630a141b551cc9cb65cae9e40e399f7", "filename": "src/test/ui/rfc-2008-non-exhaustive/uninhabited/indirect_match.stderr", "status": "modified", "additions": 44, "deletions": 4, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/b97dc20784698730bd7bc1a20eabdcd32066d174/src%2Ftest%2Fui%2Frfc-2008-non-exhaustive%2Funinhabited%2Findirect_match.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b97dc20784698730bd7bc1a20eabdcd32066d174/src%2Ftest%2Fui%2Frfc-2008-non-exhaustive%2Funinhabited%2Findirect_match.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc-2008-non-exhaustive%2Funinhabited%2Findirect_match.stderr?ref=b97dc20784698730bd7bc1a20eabdcd32066d174", "patch": "@@ -4,35 +4,75 @@ error[E0004]: non-exhaustive patterns: type `IndirectUninhabitedEnum` is non-emp\n LL |     match x {}\n    |           ^\n    |\n-   = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n+note: `IndirectUninhabitedEnum` defined here\n+  --> $DIR/auxiliary/uninhabited.rs:26:1\n+   |\n+LL | pub struct IndirectUninhabitedEnum(UninhabitedEnum);\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    = note: the matched value is of type `IndirectUninhabitedEnum`\n+help: ensure that all possible cases are being handled by adding a match arm with a wildcard pattern as shown\n+   |\n+LL ~     match x {\n+LL +         _ => todo!(),\n+LL ~     }\n+   |\n \n error[E0004]: non-exhaustive patterns: type `IndirectUninhabitedStruct` is non-empty\n   --> $DIR/indirect_match.rs:23:11\n    |\n LL |     match x {}\n    |           ^\n    |\n-   = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n+note: `IndirectUninhabitedStruct` defined here\n+  --> $DIR/auxiliary/uninhabited.rs:28:1\n+   |\n+LL | pub struct IndirectUninhabitedStruct(UninhabitedStruct);\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    = note: the matched value is of type `IndirectUninhabitedStruct`\n+help: ensure that all possible cases are being handled by adding a match arm with a wildcard pattern as shown\n+   |\n+LL ~     match x {\n+LL +         _ => todo!(),\n+LL ~     }\n+   |\n \n error[E0004]: non-exhaustive patterns: type `IndirectUninhabitedTupleStruct` is non-empty\n   --> $DIR/indirect_match.rs:27:11\n    |\n LL |     match x {}\n    |           ^\n    |\n-   = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n+note: `IndirectUninhabitedTupleStruct` defined here\n+  --> $DIR/auxiliary/uninhabited.rs:30:1\n+   |\n+LL | pub struct IndirectUninhabitedTupleStruct(UninhabitedTupleStruct);\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    = note: the matched value is of type `IndirectUninhabitedTupleStruct`\n+help: ensure that all possible cases are being handled by adding a match arm with a wildcard pattern as shown\n+   |\n+LL ~     match x {\n+LL +         _ => todo!(),\n+LL ~     }\n+   |\n \n error[E0004]: non-exhaustive patterns: type `IndirectUninhabitedVariants` is non-empty\n   --> $DIR/indirect_match.rs:33:11\n    |\n LL |     match x {}\n    |           ^\n    |\n-   = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n+note: `IndirectUninhabitedVariants` defined here\n+  --> $DIR/auxiliary/uninhabited.rs:32:1\n+   |\n+LL | pub struct IndirectUninhabitedVariants(UninhabitedVariants);\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    = note: the matched value is of type `IndirectUninhabitedVariants`\n+help: ensure that all possible cases are being handled by adding a match arm with a wildcard pattern as shown\n+   |\n+LL ~     match x {\n+LL +         _ => todo!(),\n+LL ~     }\n+   |\n \n error: aborting due to 4 previous errors\n "}, {"sha": "c1219054140353175cb8cc802b1ec64366ba3850", "filename": "src/test/ui/rfc-2008-non-exhaustive/uninhabited/indirect_match_same_crate.stderr", "status": "modified", "additions": 44, "deletions": 16, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/b97dc20784698730bd7bc1a20eabdcd32066d174/src%2Ftest%2Fui%2Frfc-2008-non-exhaustive%2Funinhabited%2Findirect_match_same_crate.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b97dc20784698730bd7bc1a20eabdcd32066d174/src%2Ftest%2Fui%2Frfc-2008-non-exhaustive%2Funinhabited%2Findirect_match_same_crate.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc-2008-non-exhaustive%2Funinhabited%2Findirect_match_same_crate.stderr?ref=b97dc20784698730bd7bc1a20eabdcd32066d174", "patch": "@@ -1,50 +1,78 @@\n error[E0004]: non-exhaustive patterns: type `IndirectUninhabitedEnum` is non-empty\n   --> $DIR/indirect_match_same_crate.rs:34:11\n    |\n-LL | pub struct IndirectUninhabitedEnum(UninhabitedEnum);\n-   | ---------------------------------------------------- `IndirectUninhabitedEnum` defined here\n-...\n LL |     match x {}\n    |           ^\n    |\n-   = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n+note: `IndirectUninhabitedEnum` defined here\n+  --> $DIR/indirect_match_same_crate.rs:20:12\n+   |\n+LL | pub struct IndirectUninhabitedEnum(UninhabitedEnum);\n+   |            ^^^^^^^^^^^^^^^^^^^^^^^\n    = note: the matched value is of type `IndirectUninhabitedEnum`\n+help: ensure that all possible cases are being handled by adding a match arm with a wildcard pattern as shown\n+   |\n+LL ~     match x {\n+LL +         _ => todo!(),\n+LL ~     }\n+   |\n \n error[E0004]: non-exhaustive patterns: type `IndirectUninhabitedStruct` is non-empty\n   --> $DIR/indirect_match_same_crate.rs:38:11\n    |\n-LL | pub struct IndirectUninhabitedStruct(UninhabitedStruct);\n-   | -------------------------------------------------------- `IndirectUninhabitedStruct` defined here\n-...\n LL |     match x {}\n    |           ^\n    |\n-   = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n+note: `IndirectUninhabitedStruct` defined here\n+  --> $DIR/indirect_match_same_crate.rs:22:12\n+   |\n+LL | pub struct IndirectUninhabitedStruct(UninhabitedStruct);\n+   |            ^^^^^^^^^^^^^^^^^^^^^^^^^\n    = note: the matched value is of type `IndirectUninhabitedStruct`\n+help: ensure that all possible cases are being handled by adding a match arm with a wildcard pattern as shown\n+   |\n+LL ~     match x {\n+LL +         _ => todo!(),\n+LL ~     }\n+   |\n \n error[E0004]: non-exhaustive patterns: type `IndirectUninhabitedTupleStruct` is non-empty\n   --> $DIR/indirect_match_same_crate.rs:42:11\n    |\n-LL | pub struct IndirectUninhabitedTupleStruct(UninhabitedTupleStruct);\n-   | ------------------------------------------------------------------ `IndirectUninhabitedTupleStruct` defined here\n-...\n LL |     match x {}\n    |           ^\n    |\n-   = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n+note: `IndirectUninhabitedTupleStruct` defined here\n+  --> $DIR/indirect_match_same_crate.rs:24:12\n+   |\n+LL | pub struct IndirectUninhabitedTupleStruct(UninhabitedTupleStruct);\n+   |            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    = note: the matched value is of type `IndirectUninhabitedTupleStruct`\n+help: ensure that all possible cases are being handled by adding a match arm with a wildcard pattern as shown\n+   |\n+LL ~     match x {\n+LL +         _ => todo!(),\n+LL ~     }\n+   |\n \n error[E0004]: non-exhaustive patterns: type `IndirectUninhabitedVariants` is non-empty\n   --> $DIR/indirect_match_same_crate.rs:48:11\n    |\n-LL | pub struct IndirectUninhabitedVariants(UninhabitedVariants);\n-   | ------------------------------------------------------------ `IndirectUninhabitedVariants` defined here\n-...\n LL |     match x {}\n    |           ^\n    |\n-   = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n+note: `IndirectUninhabitedVariants` defined here\n+  --> $DIR/indirect_match_same_crate.rs:26:12\n+   |\n+LL | pub struct IndirectUninhabitedVariants(UninhabitedVariants);\n+   |            ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    = note: the matched value is of type `IndirectUninhabitedVariants`\n+help: ensure that all possible cases are being handled by adding a match arm with a wildcard pattern as shown\n+   |\n+LL ~     match x {\n+LL +         _ => todo!(),\n+LL ~     }\n+   |\n \n error: aborting due to 4 previous errors\n "}, {"sha": "f0cb13de3f799b9043fd0aea3ba3afdfd46c1208", "filename": "src/test/ui/rfc-2008-non-exhaustive/uninhabited/indirect_match_with_exhaustive_patterns.stderr", "status": "modified", "additions": 44, "deletions": 4, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/b97dc20784698730bd7bc1a20eabdcd32066d174/src%2Ftest%2Fui%2Frfc-2008-non-exhaustive%2Funinhabited%2Findirect_match_with_exhaustive_patterns.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b97dc20784698730bd7bc1a20eabdcd32066d174/src%2Ftest%2Fui%2Frfc-2008-non-exhaustive%2Funinhabited%2Findirect_match_with_exhaustive_patterns.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc-2008-non-exhaustive%2Funinhabited%2Findirect_match_with_exhaustive_patterns.stderr?ref=b97dc20784698730bd7bc1a20eabdcd32066d174", "patch": "@@ -4,35 +4,75 @@ error[E0004]: non-exhaustive patterns: type `IndirectUninhabitedEnum` is non-emp\n LL |     match x {}\n    |           ^\n    |\n-   = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n+note: `IndirectUninhabitedEnum` defined here\n+  --> $DIR/auxiliary/uninhabited.rs:26:1\n+   |\n+LL | pub struct IndirectUninhabitedEnum(UninhabitedEnum);\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    = note: the matched value is of type `IndirectUninhabitedEnum`\n+help: ensure that all possible cases are being handled by adding a match arm with a wildcard pattern as shown\n+   |\n+LL ~     match x {\n+LL +         _ => todo!(),\n+LL ~     }\n+   |\n \n error[E0004]: non-exhaustive patterns: type `IndirectUninhabitedStruct` is non-empty\n   --> $DIR/indirect_match_with_exhaustive_patterns.rs:27:11\n    |\n LL |     match x {}\n    |           ^\n    |\n-   = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n+note: `IndirectUninhabitedStruct` defined here\n+  --> $DIR/auxiliary/uninhabited.rs:28:1\n+   |\n+LL | pub struct IndirectUninhabitedStruct(UninhabitedStruct);\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    = note: the matched value is of type `IndirectUninhabitedStruct`\n+help: ensure that all possible cases are being handled by adding a match arm with a wildcard pattern as shown\n+   |\n+LL ~     match x {\n+LL +         _ => todo!(),\n+LL ~     }\n+   |\n \n error[E0004]: non-exhaustive patterns: type `IndirectUninhabitedTupleStruct` is non-empty\n   --> $DIR/indirect_match_with_exhaustive_patterns.rs:31:11\n    |\n LL |     match x {}\n    |           ^\n    |\n-   = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n+note: `IndirectUninhabitedTupleStruct` defined here\n+  --> $DIR/auxiliary/uninhabited.rs:30:1\n+   |\n+LL | pub struct IndirectUninhabitedTupleStruct(UninhabitedTupleStruct);\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    = note: the matched value is of type `IndirectUninhabitedTupleStruct`\n+help: ensure that all possible cases are being handled by adding a match arm with a wildcard pattern as shown\n+   |\n+LL ~     match x {\n+LL +         _ => todo!(),\n+LL ~     }\n+   |\n \n error[E0004]: non-exhaustive patterns: type `IndirectUninhabitedVariants` is non-empty\n   --> $DIR/indirect_match_with_exhaustive_patterns.rs:37:11\n    |\n LL |     match x {}\n    |           ^\n    |\n-   = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n+note: `IndirectUninhabitedVariants` defined here\n+  --> $DIR/auxiliary/uninhabited.rs:32:1\n+   |\n+LL | pub struct IndirectUninhabitedVariants(UninhabitedVariants);\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    = note: the matched value is of type `IndirectUninhabitedVariants`\n+help: ensure that all possible cases are being handled by adding a match arm with a wildcard pattern as shown\n+   |\n+LL ~     match x {\n+LL +         _ => todo!(),\n+LL ~     }\n+   |\n \n error: aborting due to 4 previous errors\n "}, {"sha": "49febd9241dc6e9cceb1e5dd6511c8910b6afbae", "filename": "src/test/ui/rfc-2008-non-exhaustive/uninhabited/match.stderr", "status": "modified", "additions": 51, "deletions": 10, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/b97dc20784698730bd7bc1a20eabdcd32066d174/src%2Ftest%2Fui%2Frfc-2008-non-exhaustive%2Funinhabited%2Fmatch.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b97dc20784698730bd7bc1a20eabdcd32066d174/src%2Ftest%2Fui%2Frfc-2008-non-exhaustive%2Funinhabited%2Fmatch.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc-2008-non-exhaustive%2Funinhabited%2Fmatch.stderr?ref=b97dc20784698730bd7bc1a20eabdcd32066d174", "patch": "@@ -4,42 +4,83 @@ error[E0004]: non-exhaustive patterns: type `UninhabitedEnum` is non-empty\n LL |     match x {}\n    |           ^\n    |\n-   = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n+note: `UninhabitedEnum` defined here\n+  --> $DIR/auxiliary/uninhabited.rs:5:1\n+   |\n+LL | / pub enum UninhabitedEnum {\n+LL | | }\n+   | |_^\n    = note: the matched value is of type `UninhabitedEnum`, which is marked as non-exhaustive\n+help: ensure that all possible cases are being handled by adding a match arm with a wildcard pattern as shown\n+   |\n+LL ~     match x {\n+LL +         _ => todo!(),\n+LL ~     }\n+   |\n \n error[E0004]: non-exhaustive patterns: type `UninhabitedStruct` is non-empty\n   --> $DIR/match.rs:23:11\n    |\n LL |     match x {}\n    |           ^\n    |\n-   = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n+note: `UninhabitedStruct` defined here\n+  --> $DIR/auxiliary/uninhabited.rs:9:1\n+   |\n+LL | / pub struct UninhabitedStruct {\n+LL | |     _priv: !,\n+LL | | }\n+   | |_^\n    = note: the matched value is of type `UninhabitedStruct`\n+help: ensure that all possible cases are being handled by adding a match arm with a wildcard pattern as shown\n+   |\n+LL ~     match x {\n+LL +         _ => todo!(),\n+LL ~     }\n+   |\n \n error[E0004]: non-exhaustive patterns: type `UninhabitedTupleStruct` is non-empty\n   --> $DIR/match.rs:27:11\n    |\n LL |     match x {}\n    |           ^\n    |\n-   = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n+note: `UninhabitedTupleStruct` defined here\n+  --> $DIR/auxiliary/uninhabited.rs:14:1\n+   |\n+LL | pub struct UninhabitedTupleStruct(!);\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    = note: the matched value is of type `UninhabitedTupleStruct`\n+help: ensure that all possible cases are being handled by adding a match arm with a wildcard pattern as shown\n+   |\n+LL ~     match x {\n+LL +         _ => todo!(),\n+LL ~     }\n+   |\n \n error[E0004]: non-exhaustive patterns: `Tuple(_)` and `Struct { .. }` not covered\n   --> $DIR/match.rs:31:11\n    |\n LL |     match x {}\n    |           ^ patterns `Tuple(_)` and `Struct { .. }` not covered\n    |\n-  ::: $DIR/auxiliary/uninhabited.rs:17:23\n+note: `UninhabitedVariants` defined here\n+  --> $DIR/auxiliary/uninhabited.rs:17:23\n    |\n-LL |     #[non_exhaustive] Tuple(!),\n-   |                       ----- not covered\n-LL |     #[non_exhaustive] Struct { x: ! }\n-   |                       ------ not covered\n-   |\n-   = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n+LL | / pub enum UninhabitedVariants {\n+LL | |     #[non_exhaustive] Tuple(!),\n+   | |                       ^^^^^ not covered\n+LL | |     #[non_exhaustive] Struct { x: ! }\n+   | |                       ^^^^^^ not covered\n+LL | | }\n+   | |_-\n    = note: the matched value is of type `UninhabitedVariants`\n+help: ensure that all possible cases are being handled by adding a match arm with a wildcard pattern, a match arm with multiple or-patterns as shown, or multiple match arms\n+   |\n+LL ~     match x {\n+LL +         Tuple(_) | Struct { .. } => todo!(),\n+LL ~     }\n+   |\n \n error: aborting due to 4 previous errors\n "}, {"sha": "c89c70ae6cc1f9acc1272dff64396311eb669aba", "filename": "src/test/ui/rfc-2008-non-exhaustive/uninhabited/match_same_crate.stderr", "status": "modified", "additions": 43, "deletions": 25, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/b97dc20784698730bd7bc1a20eabdcd32066d174/src%2Ftest%2Fui%2Frfc-2008-non-exhaustive%2Funinhabited%2Fmatch_same_crate.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b97dc20784698730bd7bc1a20eabdcd32066d174/src%2Ftest%2Fui%2Frfc-2008-non-exhaustive%2Funinhabited%2Fmatch_same_crate.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc-2008-non-exhaustive%2Funinhabited%2Fmatch_same_crate.stderr?ref=b97dc20784698730bd7bc1a20eabdcd32066d174", "patch": "@@ -1,45 +1,63 @@\n error[E0004]: non-exhaustive patterns: type `UninhabitedStruct` is non-empty\n   --> $DIR/match_same_crate.rs:30:11\n    |\n-LL | / pub struct UninhabitedStruct {\n-LL | |     _priv: !,\n-LL | | }\n-   | |_- `UninhabitedStruct` defined here\n-...\n-LL |       match x {}\n-   |             ^\n-   |\n-   = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n+LL |     match x {}\n+   |           ^\n+   |\n+note: `UninhabitedStruct` defined here\n+  --> $DIR/match_same_crate.rs:8:12\n+   |\n+LL | pub struct UninhabitedStruct {\n+   |            ^^^^^^^^^^^^^^^^^\n    = note: the matched value is of type `UninhabitedStruct`\n+help: ensure that all possible cases are being handled by adding a match arm with a wildcard pattern as shown\n+   |\n+LL ~     match x {\n+LL +         _ => todo!(),\n+LL ~     }\n+   |\n \n error[E0004]: non-exhaustive patterns: type `UninhabitedTupleStruct` is non-empty\n   --> $DIR/match_same_crate.rs:34:11\n    |\n-LL | pub struct UninhabitedTupleStruct(!);\n-   | ------------------------------------- `UninhabitedTupleStruct` defined here\n-...\n LL |     match x {}\n    |           ^\n    |\n-   = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n+note: `UninhabitedTupleStruct` defined here\n+  --> $DIR/match_same_crate.rs:13:12\n+   |\n+LL | pub struct UninhabitedTupleStruct(!);\n+   |            ^^^^^^^^^^^^^^^^^^^^^^\n    = note: the matched value is of type `UninhabitedTupleStruct`\n+help: ensure that all possible cases are being handled by adding a match arm with a wildcard pattern as shown\n+   |\n+LL ~     match x {\n+LL +         _ => todo!(),\n+LL ~     }\n+   |\n \n error[E0004]: non-exhaustive patterns: `Tuple(_)` and `Struct { .. }` not covered\n   --> $DIR/match_same_crate.rs:38:11\n    |\n-LL | / pub enum UninhabitedVariants {\n-LL | |     #[non_exhaustive] Tuple(!),\n-   | |                       ----- not covered\n-LL | |     #[non_exhaustive] Struct { x: ! }\n-   | |                       ------ not covered\n-LL | | }\n-   | |_- `UninhabitedVariants` defined here\n-...\n-LL |       match x {}\n-   |             ^ patterns `Tuple(_)` and `Struct { .. }` not covered\n-   |\n-   = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n+LL |     match x {}\n+   |           ^ patterns `Tuple(_)` and `Struct { .. }` not covered\n+   |\n+note: `UninhabitedVariants` defined here\n+  --> $DIR/match_same_crate.rs:16:23\n+   |\n+LL | pub enum UninhabitedVariants {\n+   |          -------------------\n+LL |     #[non_exhaustive] Tuple(!),\n+   |                       ^^^^^ not covered\n+LL |     #[non_exhaustive] Struct { x: ! }\n+   |                       ^^^^^^ not covered\n    = note: the matched value is of type `UninhabitedVariants`\n+help: ensure that all possible cases are being handled by adding a match arm with a wildcard pattern, a match arm with multiple or-patterns as shown, or multiple match arms\n+   |\n+LL ~     match x {\n+LL +         Tuple(_) | Struct { .. } => todo!(),\n+LL ~     }\n+   |\n \n error: aborting due to 3 previous errors\n "}, {"sha": "e18c2678d323c2f4d60498067b71fc817171f02c", "filename": "src/test/ui/rfc-2008-non-exhaustive/uninhabited/match_with_exhaustive_patterns.stderr", "status": "modified", "additions": 51, "deletions": 10, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/b97dc20784698730bd7bc1a20eabdcd32066d174/src%2Ftest%2Fui%2Frfc-2008-non-exhaustive%2Funinhabited%2Fmatch_with_exhaustive_patterns.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b97dc20784698730bd7bc1a20eabdcd32066d174/src%2Ftest%2Fui%2Frfc-2008-non-exhaustive%2Funinhabited%2Fmatch_with_exhaustive_patterns.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc-2008-non-exhaustive%2Funinhabited%2Fmatch_with_exhaustive_patterns.stderr?ref=b97dc20784698730bd7bc1a20eabdcd32066d174", "patch": "@@ -4,42 +4,83 @@ error[E0004]: non-exhaustive patterns: type `UninhabitedEnum` is non-empty\n LL |     match x {}\n    |           ^\n    |\n-   = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n+note: `UninhabitedEnum` defined here\n+  --> $DIR/auxiliary/uninhabited.rs:5:1\n+   |\n+LL | / pub enum UninhabitedEnum {\n+LL | | }\n+   | |_^\n    = note: the matched value is of type `UninhabitedEnum`, which is marked as non-exhaustive\n+help: ensure that all possible cases are being handled by adding a match arm with a wildcard pattern as shown\n+   |\n+LL ~     match x {\n+LL +         _ => todo!(),\n+LL ~     }\n+   |\n \n error[E0004]: non-exhaustive patterns: type `UninhabitedStruct` is non-empty\n   --> $DIR/match_with_exhaustive_patterns.rs:26:11\n    |\n LL |     match x {}\n    |           ^\n    |\n-   = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n+note: `UninhabitedStruct` defined here\n+  --> $DIR/auxiliary/uninhabited.rs:9:1\n+   |\n+LL | / pub struct UninhabitedStruct {\n+LL | |     _priv: !,\n+LL | | }\n+   | |_^\n    = note: the matched value is of type `UninhabitedStruct`\n+help: ensure that all possible cases are being handled by adding a match arm with a wildcard pattern as shown\n+   |\n+LL ~     match x {\n+LL +         _ => todo!(),\n+LL ~     }\n+   |\n \n error[E0004]: non-exhaustive patterns: type `UninhabitedTupleStruct` is non-empty\n   --> $DIR/match_with_exhaustive_patterns.rs:30:11\n    |\n LL |     match x {}\n    |           ^\n    |\n-   = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n+note: `UninhabitedTupleStruct` defined here\n+  --> $DIR/auxiliary/uninhabited.rs:14:1\n+   |\n+LL | pub struct UninhabitedTupleStruct(!);\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    = note: the matched value is of type `UninhabitedTupleStruct`\n+help: ensure that all possible cases are being handled by adding a match arm with a wildcard pattern as shown\n+   |\n+LL ~     match x {\n+LL +         _ => todo!(),\n+LL ~     }\n+   |\n \n error[E0004]: non-exhaustive patterns: `Tuple(_)` and `Struct { .. }` not covered\n   --> $DIR/match_with_exhaustive_patterns.rs:34:11\n    |\n LL |     match x {}\n    |           ^ patterns `Tuple(_)` and `Struct { .. }` not covered\n    |\n-  ::: $DIR/auxiliary/uninhabited.rs:17:23\n+note: `UninhabitedVariants` defined here\n+  --> $DIR/auxiliary/uninhabited.rs:17:23\n    |\n-LL |     #[non_exhaustive] Tuple(!),\n-   |                       ----- not covered\n-LL |     #[non_exhaustive] Struct { x: ! }\n-   |                       ------ not covered\n-   |\n-   = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n+LL | / pub enum UninhabitedVariants {\n+LL | |     #[non_exhaustive] Tuple(!),\n+   | |                       ^^^^^ not covered\n+LL | |     #[non_exhaustive] Struct { x: ! }\n+   | |                       ^^^^^^ not covered\n+LL | | }\n+   | |_-\n    = note: the matched value is of type `UninhabitedVariants`\n+help: ensure that all possible cases are being handled by adding a match arm with a wildcard pattern, a match arm with multiple or-patterns as shown, or multiple match arms\n+   |\n+LL ~     match x {\n+LL +         Tuple(_) | Struct { .. } => todo!(),\n+LL ~     }\n+   |\n \n error: aborting due to 4 previous errors\n "}, {"sha": "ad19c34a40a110237acf2eba71de2aa30ea23c74", "filename": "src/test/ui/uninhabited/uninhabited-irrefutable.stderr", "status": "modified", "additions": 9, "deletions": 11, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/b97dc20784698730bd7bc1a20eabdcd32066d174/src%2Ftest%2Fui%2Funinhabited%2Funinhabited-irrefutable.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b97dc20784698730bd7bc1a20eabdcd32066d174/src%2Ftest%2Fui%2Funinhabited%2Funinhabited-irrefutable.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Funinhabited%2Funinhabited-irrefutable.stderr?ref=b97dc20784698730bd7bc1a20eabdcd32066d174", "patch": "@@ -1,20 +1,18 @@\n error[E0005]: refutable pattern in local binding: `A(_)` not covered\n   --> $DIR/uninhabited-irrefutable.rs:27:9\n    |\n-LL | / enum Foo {\n-LL | |     A(foo::SecretlyEmpty),\n-   | |     - not covered\n-LL | |     B(foo::NotSoSecretlyEmpty),\n-LL | |     C(NotSoSecretlyEmpty),\n-LL | |     D(u32),\n-LL | | }\n-   | |_- `Foo` defined here\n-...\n-LL |       let Foo::D(_y) = x;\n-   |           ^^^^^^^^^^ pattern `A(_)` not covered\n+LL |     let Foo::D(_y) = x;\n+   |         ^^^^^^^^^^ pattern `A(_)` not covered\n    |\n    = note: `let` bindings require an \"irrefutable pattern\", like a `struct` or an `enum` with only one variant\n    = note: for more information, visit https://doc.rust-lang.org/book/ch18-02-refutability.html\n+note: `Foo` defined here\n+  --> $DIR/uninhabited-irrefutable.rs:19:5\n+   |\n+LL | enum Foo {\n+   |      ---\n+LL |     A(foo::SecretlyEmpty),\n+   |     ^ not covered\n    = note: the matched value is of type `Foo`\n help: you might want to use `if let` to ignore the variant that isn't matched\n    |"}, {"sha": "d90075d82f47b37defdc1e6a6d67b240ece67c86", "filename": "src/test/ui/uninhabited/uninhabited-matches-feature-gated.stderr", "status": "modified", "additions": 72, "deletions": 22, "changes": 94, "blob_url": "https://github.com/rust-lang/rust/blob/b97dc20784698730bd7bc1a20eabdcd32066d174/src%2Ftest%2Fui%2Funinhabited%2Funinhabited-matches-feature-gated.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b97dc20784698730bd7bc1a20eabdcd32066d174/src%2Ftest%2Fui%2Funinhabited%2Funinhabited-matches-feature-gated.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Funinhabited%2Funinhabited-matches-feature-gated.stderr?ref=b97dc20784698730bd7bc1a20eabdcd32066d174", "patch": "@@ -4,81 +4,131 @@ error[E0004]: non-exhaustive patterns: `Err(_)` not covered\n LL |     let _ = match x {\n    |                   ^ pattern `Err(_)` not covered\n    |\n-  ::: $SRC_DIR/core/src/result.rs:LL:COL\n+note: `Result<u32, &Void>` defined here\n+  --> $SRC_DIR/core/src/result.rs:LL:COL\n+   |\n+LL | / pub enum Result<T, E> {\n+LL | |     /// Contains the success value\n+LL | |     #[lang = \"Ok\"]\n+LL | |     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+...  |\n+LL | |     Err(#[stable(feature = \"rust1\", since = \"1.0.0\")] E),\n+   | |     ^^^ not covered\n+LL | | }\n+   | |_-\n+   = note: the matched value is of type `Result<u32, &Void>`\n+help: ensure that all possible cases are being handled by adding a match arm with a wildcard pattern or an explicit pattern as shown\n    |\n-LL |     Err(#[stable(feature = \"rust1\", since = \"1.0.0\")] E),\n-   |     --- not covered\n+LL ~         Ok(n) => n,\n+LL ~         Err(_) => todo!(),\n    |\n-   = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n-   = note: the matched value is of type `Result<u32, &Void>`\n \n error[E0004]: non-exhaustive patterns: type `&Void` is non-empty\n   --> $DIR/uninhabited-matches-feature-gated.rs:15:19\n    |\n-LL | enum Void {}\n-   | ------------ `Void` defined here\n-...\n LL |     let _ = match x {};\n    |                   ^\n    |\n-   = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n+note: `Void` defined here\n+  --> $DIR/uninhabited-matches-feature-gated.rs:2:6\n+   |\n+LL | enum Void {}\n+   |      ^^^^\n    = note: the matched value is of type `&Void`\n    = note: references are always considered inhabited\n+help: ensure that all possible cases are being handled by adding a match arm with a wildcard pattern as shown\n+   |\n+LL ~     let _ = match x {\n+LL +         _ => todo!(),\n+LL ~     };\n+   |\n \n error[E0004]: non-exhaustive patterns: type `(Void,)` is non-empty\n   --> $DIR/uninhabited-matches-feature-gated.rs:18:19\n    |\n LL |     let _ = match x {};\n    |                   ^\n    |\n-   = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n    = note: the matched value is of type `(Void,)`\n+help: ensure that all possible cases are being handled by adding a match arm with a wildcard pattern as shown\n+   |\n+LL ~     let _ = match x {\n+LL +         _ => todo!(),\n+LL ~     };\n+   |\n \n error[E0004]: non-exhaustive patterns: type `[Void; 1]` is non-empty\n   --> $DIR/uninhabited-matches-feature-gated.rs:21:19\n    |\n LL |     let _ = match x {};\n    |                   ^\n    |\n-   = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n    = note: the matched value is of type `[Void; 1]`\n+help: ensure that all possible cases are being handled by adding a match arm with a wildcard pattern as shown\n+   |\n+LL ~     let _ = match x {\n+LL +         _ => todo!(),\n+LL ~     };\n+   |\n \n error[E0004]: non-exhaustive patterns: `&[_, ..]` not covered\n   --> $DIR/uninhabited-matches-feature-gated.rs:24:19\n    |\n LL |     let _ = match x {\n    |                   ^ pattern `&[_, ..]` not covered\n    |\n-   = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n    = note: the matched value is of type `&[Void]`\n+help: ensure that all possible cases are being handled by adding a match arm with a wildcard pattern or an explicit pattern as shown\n+   |\n+LL ~         &[] => (),\n+LL ~         &[_, ..] => todo!(),\n+   |\n \n error[E0004]: non-exhaustive patterns: `Err(_)` not covered\n   --> $DIR/uninhabited-matches-feature-gated.rs:32:19\n    |\n LL |     let _ = match x {\n    |                   ^ pattern `Err(_)` not covered\n    |\n-  ::: $SRC_DIR/core/src/result.rs:LL:COL\n+note: `Result<u32, Void>` defined here\n+  --> $SRC_DIR/core/src/result.rs:LL:COL\n+   |\n+LL | / pub enum Result<T, E> {\n+LL | |     /// Contains the success value\n+LL | |     #[lang = \"Ok\"]\n+LL | |     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+...  |\n+LL | |     Err(#[stable(feature = \"rust1\", since = \"1.0.0\")] E),\n+   | |     ^^^ not covered\n+LL | | }\n+   | |_-\n+   = note: the matched value is of type `Result<u32, Void>`\n+help: ensure that all possible cases are being handled by adding a match arm with a wildcard pattern or an explicit pattern as shown\n    |\n-LL |     Err(#[stable(feature = \"rust1\", since = \"1.0.0\")] E),\n-   |     --- not covered\n+LL ~         Ok(x) => x,\n+LL ~         Err(_) => todo!(),\n    |\n-   = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n-   = note: the matched value is of type `Result<u32, Void>`\n \n error[E0005]: refutable pattern in local binding: `Err(_)` not covered\n   --> $DIR/uninhabited-matches-feature-gated.rs:37:9\n    |\n LL |     let Ok(x) = x;\n    |         ^^^^^ pattern `Err(_)` not covered\n    |\n-  ::: $SRC_DIR/core/src/result.rs:LL:COL\n-   |\n-LL |     Err(#[stable(feature = \"rust1\", since = \"1.0.0\")] E),\n-   |     --- not covered\n-   |\n    = note: `let` bindings require an \"irrefutable pattern\", like a `struct` or an `enum` with only one variant\n    = note: for more information, visit https://doc.rust-lang.org/book/ch18-02-refutability.html\n+note: `Result<u32, Void>` defined here\n+  --> $SRC_DIR/core/src/result.rs:LL:COL\n+   |\n+LL | / pub enum Result<T, E> {\n+LL | |     /// Contains the success value\n+LL | |     #[lang = \"Ok\"]\n+LL | |     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+...  |\n+LL | |     Err(#[stable(feature = \"rust1\", since = \"1.0.0\")] E),\n+   | |     ^^^ not covered\n+LL | | }\n+   | |_-\n    = note: the matched value is of type `Result<u32, Void>`\n help: you might want to use `if let` to ignore the variant that isn't matched\n    |"}, {"sha": "5fae65dd28b450a437ebc800a410164c3af1d516", "filename": "src/tools/rust-analyzer", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": null, "raw_url": null, "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer?ref=b97dc20784698730bd7bc1a20eabdcd32066d174", "patch": "@@ -1 +1 @@\n-Subproject commit 4e72700e38421a12993fe5fa5c33d712652bc6c8\n+Subproject commit 5fae65dd28b450a437ebc800a410164c3af1d516"}]}