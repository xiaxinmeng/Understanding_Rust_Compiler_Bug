{"sha": "ce3cc46ce602990b39f76344a2132b2c2db122dd", "node_id": "MDY6Q29tbWl0NzI0NzEyOmNlM2NjNDZjZTYwMjk5MGIzOWY3NjM0NGEyMTMyYjJjMmRiMTIyZGQ=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2012-08-22T02:51:43Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2012-08-22T03:15:22Z"}, "message": "Fix generation of generic methods with explicit self\n\nThere used to be two distinct code paths.  Now there is one.", "tree": {"sha": "c62f4856a3e2054fc8719a8754245d4e321d53b9", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c62f4856a3e2054fc8719a8754245d4e321d53b9"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ce3cc46ce602990b39f76344a2132b2c2db122dd", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ce3cc46ce602990b39f76344a2132b2c2db122dd", "html_url": "https://github.com/rust-lang/rust/commit/ce3cc46ce602990b39f76344a2132b2c2db122dd", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ce3cc46ce602990b39f76344a2132b2c2db122dd/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b5411f765cdac796fc6798e49521c8da89a394cc", "url": "https://api.github.com/repos/rust-lang/rust/commits/b5411f765cdac796fc6798e49521c8da89a394cc", "html_url": "https://github.com/rust-lang/rust/commit/b5411f765cdac796fc6798e49521c8da89a394cc"}], "stats": {"total": 139, "additions": 105, "deletions": 34}, "files": [{"sha": "1def54d5ebf874a7de8c15994f1767716232b1f2", "filename": "src/rustc/middle/trans/base.rs", "status": "modified", "additions": 4, "deletions": 7, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/ce3cc46ce602990b39f76344a2132b2c2db122dd/src%2Frustc%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce3cc46ce602990b39f76344a2132b2c2db122dd/src%2Frustc%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fbase.rs?ref=ce3cc46ce602990b39f76344a2132b2c2db122dd", "patch": "@@ -2246,10 +2246,7 @@ fn monomorphic_fn(ccx: @crate_ctxt, fn_id: ast::def_id,\n       ast_map::node_method(mth, impl_def_id, _) => {\n         let d = mk_lldecl();\n         set_inline_hint_if_appr(mth.attrs, d);\n-        let selfty = ty::node_id_to_type(ccx.tcx, mth.self_id);\n-        let selfty = ty::subst_tps(ccx.tcx, substs, selfty);\n-        trans_fn(ccx, pt, mth.decl, mth.body, d,\n-                 impl_self(selfty), psubsts, fn_id.node);\n+        impl::trans_method(ccx, pt, mth, psubsts, d);\n         d\n       }\n       ast_map::node_ctor(nm, tps, ctor, parent_id, _) => {\n@@ -5321,13 +5318,13 @@ fn get_item_val(ccx: @crate_ctxt, id: ast::node_id) -> ValueRef {\n               }\n               ast::provided(m) => {\n                 exprt = true;\n-                trans_method(ccx, id, pth, m)\n+                register_method(ccx, id, pth, m)\n               }\n             }\n           }\n           ast_map::node_method(m, _, pth) => {\n             exprt = true;\n-            trans_method(ccx, id, pth, m)\n+            register_method(ccx, id, pth, m)\n           }\n           ast_map::node_foreign_item(ni, _, pth) => {\n             exprt = true;\n@@ -5397,7 +5394,7 @@ fn get_item_val(ccx: @crate_ctxt, id: ast::node_id) -> ValueRef {\n     }\n }\n \n-fn trans_method(ccx: @crate_ctxt, id: ast::node_id, pth: @ast_map::path,\n+fn register_method(ccx: @crate_ctxt, id: ast::node_id, pth: @ast_map::path,\n                 m: @ast::method) -> ValueRef {\n     let mty = ty::node_id_to_type(ccx.tcx, id);\n     let pth = vec::append(*pth, ~[path_name(@ccx.names(~\"meth\")),"}, {"sha": "e85cef79358dd3e0d8cf60f91e55510b268f37d8", "filename": "src/rustc/middle/trans/impl.rs", "status": "modified", "additions": 67, "deletions": 26, "changes": 93, "blob_url": "https://github.com/rust-lang/rust/blob/ce3cc46ce602990b39f76344a2132b2c2db122dd/src%2Frustc%2Fmiddle%2Ftrans%2Fimpl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce3cc46ce602990b39f76344a2132b2c2db122dd/src%2Frustc%2Fmiddle%2Ftrans%2Fimpl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fimpl.rs?ref=ce3cc46ce602990b39f76344a2132b2c2db122dd", "patch": "@@ -18,41 +18,82 @@ import util::ppaux::{ty_to_str, tys_to_str};\n \n import syntax::print::pprust::expr_to_str;\n \n+/**\n+The main \"translation\" pass for methods.  Generates code\n+for non-monomorphized methods only.  Other methods will\n+be generated once they are invoked with specific type parameters,\n+see `trans::base::lval_static_fn()` or `trans::base::monomorphic_fn()`.\n+*/\n fn trans_impl(ccx: @crate_ctxt, path: path, name: ast::ident,\n               methods: ~[@ast::method], tps: ~[ast::ty_param]) {\n     let _icx = ccx.insn_ctxt(\"impl::trans_impl\");\n     if tps.len() > 0u { return; }\n     let sub_path = vec::append_one(path, path_name(name));\n-    for vec::each(methods) |m| {\n-        if m.tps.len() == 0u {\n-            let llfn = get_item_val(ccx, m.id);\n-            let self_ty = ty::node_id_to_type(ccx.tcx, m.self_id);\n-            let self_arg = match m.self_ty.node {\n-              ast::sty_static => { no_self }\n-              ast::sty_box(_) => {\n-                impl_self(ty::mk_imm_box(ccx.tcx, self_ty))\n-              }\n-              ast::sty_uniq(_) => {\n-                impl_self(ty::mk_imm_uniq(ccx.tcx, self_ty))\n-              }\n-              ast::sty_region(*) => {\n-                impl_self(ty::mk_imm_ptr(ccx.tcx, self_ty))\n-              }\n-              ast::sty_value => {\n-                impl_owned_self(self_ty)\n-              }\n-              ast::sty_by_ref => { impl_self(self_ty) }\n-            };\n-\n-            trans_fn(ccx,\n-                     vec::append_one(sub_path, path_name(m.ident)),\n-                     m.decl, m.body,\n-                     llfn, self_arg,\n-                     none, m.id);\n+    for vec::each(methods) |method| {\n+        if method.tps.len() == 0u {\n+            let llfn = get_item_val(ccx, method.id);\n+            let path = vec::append_one(sub_path, path_name(method.ident));\n+            trans_method(ccx, path, method, none, llfn);\n         }\n     }\n }\n \n+/**\n+Translates a (possibly monomorphized) method body.\n+\n+# Parameters\n+\n+- `path`: the path to the method\n+- `method`: the AST node for the method\n+- `param_substs`: if this is a generic method, the current values for\n+  type parameters and so forth, else none\n+- `llfn`: the LLVM ValueRef for the method\n+*/\n+fn trans_method(ccx: @crate_ctxt,\n+                path: path,\n+                method: &ast::method,\n+                param_substs: option<param_substs>,\n+                llfn: ValueRef) {\n+    // determine the (monomorphized) type that `self` maps to for this method\n+    let self_ty = ty::node_id_to_type(ccx.tcx, method.self_id);\n+    let self_ty = match param_substs {\n+      none => self_ty,\n+      some({tys: ref tys, _}) => ty::subst_tps(ccx.tcx, *tys, self_ty)\n+    };\n+\n+    // apply any transformations from the explicit self declaration\n+    let self_arg = match method.self_ty.node {\n+      ast::sty_static => {\n+        no_self\n+      }\n+      ast::sty_box(_) => {\n+        impl_self(ty::mk_imm_box(ccx.tcx, self_ty))\n+      }\n+      ast::sty_uniq(_) => {\n+        impl_self(ty::mk_imm_uniq(ccx.tcx, self_ty))\n+      }\n+      ast::sty_region(*) => {\n+        impl_self(ty::mk_imm_ptr(ccx.tcx, self_ty))\n+      }\n+      ast::sty_value => {\n+        impl_owned_self(self_ty)\n+      }\n+      ast::sty_by_ref => {\n+        impl_self(self_ty)\n+      }\n+    };\n+\n+    // generate the actual code\n+    trans_fn(ccx,\n+             path,\n+             method.decl,\n+             method.body,\n+             llfn,\n+             self_arg,\n+             param_substs,\n+             method.id);\n+}\n+\n fn trans_self_arg(bcx: block, base: @ast::expr,\n                   mentry: typeck::method_map_entry) -> result {\n     let _icx = bcx.insn_ctxt(\"impl::trans_self_arg\");"}, {"sha": "b0f8746d1628089ff6fc320c395cf0489d51fc0c", "filename": "src/rustc/middle/ty.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ce3cc46ce602990b39f76344a2132b2c2db122dd/src%2Frustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce3cc46ce602990b39f76344a2132b2c2db122dd/src%2Frustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fty.rs?ref=ce3cc46ce602990b39f76344a2132b2c2db122dd", "patch": "@@ -1106,7 +1106,7 @@ fn fold_region(cx: ctxt, t0: t, fldop: fn(region, bool) -> region) -> t {\n }\n \n // Substitute *only* type parameters.  Used in trans where regions are erased.\n-fn subst_tps(cx: ctxt, tps: ~[t], typ: t) -> t {\n+fn subst_tps(cx: ctxt, tps: &[t], typ: t) -> t {\n     if tps.len() == 0u { return typ; }\n     let tb = ty::get(typ);\n     if !tbox_has_flag(tb, has_params) { return typ; }"}, {"sha": "5b6ed42e2288cd822f6c88852b885814f3d3b96e", "filename": "src/test/run-pass/explicit-self-generic.rs", "status": "added", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/ce3cc46ce602990b39f76344a2132b2c2db122dd/src%2Ftest%2Frun-pass%2Fexplicit-self-generic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce3cc46ce602990b39f76344a2132b2c2db122dd/src%2Ftest%2Frun-pass%2Fexplicit-self-generic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fexplicit-self-generic.rs?ref=ce3cc46ce602990b39f76344a2132b2c2db122dd", "patch": "@@ -0,0 +1,33 @@\n+use std;\n+\n+/**\n+ * A function that returns a hash of a value\n+ *\n+ * The hash should concentrate entropy in the lower bits.\n+ */\n+type HashFn<K> = pure fn~(K) -> uint;\n+type EqFn<K> = pure fn~(K, K) -> bool;\n+\n+enum LinearMap<K,V> {\n+    LinearMap_({\n+        resize_at: uint,\n+        size: uint})\n+}\n+\n+fn linear_map<K,V>() -> LinearMap<K,V> {\n+    LinearMap_({\n+        resize_at: 32,\n+        size: 0})\n+}\n+\n+impl<K,V> LinearMap<K,V> {\n+    fn len(&mut self) -> uint {\n+        self.size\n+    }\n+}\n+\n+fn main() {\n+    let mut m = ~linear_map::<(),()>();\n+    assert m.len() == 0;\n+}\n+"}]}