{"sha": "5ae6caa0f04c686f0cc8a330f54390131148f899", "node_id": "C_kwDOAAsO6NoAKDVhZTZjYWEwZjA0YzY4NmYwY2M4YTMzMGY1NDM5MDEzMTE0OGY4OTk", "commit": {"author": {"name": "Oli Scherer", "email": "git-spam-no-reply9815368754983@oli-obk.de", "date": "2023-03-06T16:48:22Z"}, "committer": {"name": "Oli Scherer", "email": "git-spam-no-reply9815368754983@oli-obk.de", "date": "2023-03-27T12:19:52Z"}, "message": "Use the FnPtr trait to avoid implementing common traits via macros", "tree": {"sha": "91f0a70a67df8a2a0cd4381d124d447a5bdbbdb9", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/91f0a70a67df8a2a0cd4381d124d447a5bdbbdb9"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5ae6caa0f04c686f0cc8a330f54390131148f899", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5ae6caa0f04c686f0cc8a330f54390131148f899", "html_url": "https://github.com/rust-lang/rust/commit/5ae6caa0f04c686f0cc8a330f54390131148f899", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5ae6caa0f04c686f0cc8a330f54390131148f899/comments", "author": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "committer": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9e27c6c133b6710510f1a2ff94a943cb61efbc52", "url": "https://api.github.com/repos/rust-lang/rust/commits/9e27c6c133b6710510f1a2ff94a943cb61efbc52", "html_url": "https://github.com/rust-lang/rust/commit/9e27c6c133b6710510f1a2ff94a943cb61efbc52"}], "stats": {"total": 289, "additions": 162, "deletions": 127}, "files": [{"sha": "74e9c55396d1f54691f2e578b1b8b6073869dc7b", "filename": "library/core/src/marker.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5ae6caa0f04c686f0cc8a330f54390131148f899/library%2Fcore%2Fsrc%2Fmarker.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5ae6caa0f04c686f0cc8a330f54390131148f899/library%2Fcore%2Fsrc%2Fmarker.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fmarker.rs?ref=5ae6caa0f04c686f0cc8a330f54390131148f899", "patch": "@@ -932,7 +932,7 @@ mod copy_impls {\n #[lang = \"fn_ptr_trait\"]\n #[cfg(not(bootstrap))]\n #[rustc_deny_explicit_impl]\n-pub trait FnPtr {\n+pub trait FnPtr: Copy + Clone {\n     /// Returns the address of the function pointer.\n     #[lang = \"fn_ptr_addr\"]\n     fn addr(self) -> *const ();"}, {"sha": "9cdfd2c21cc98d6bd3a0b58755d98d8f6df86ac3", "filename": "library/core/src/ptr/mod.rs", "status": "modified", "additions": 161, "deletions": 106, "changes": 267, "blob_url": "https://github.com/rust-lang/rust/blob/5ae6caa0f04c686f0cc8a330f54390131148f899/library%2Fcore%2Fsrc%2Fptr%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5ae6caa0f04c686f0cc8a330f54390131148f899/library%2Fcore%2Fsrc%2Fptr%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fptr%2Fmod.rs?ref=5ae6caa0f04c686f0cc8a330f54390131148f899", "patch": "@@ -1891,150 +1891,205 @@ pub fn hash<T: ?Sized, S: hash::Hasher>(hashee: *const T, into: &mut S) {\n     hashee.hash(into);\n }\n \n-// If this is a unary fn pointer, it adds a doc comment.\n-// Otherwise, it hides the docs entirely.\n-macro_rules! maybe_fnptr_doc {\n-    (@ #[$meta:meta] $item:item) => {\n-        #[doc(hidden)]\n-        #[$meta]\n-        $item\n-    };\n-    ($a:ident @ #[$meta:meta] $item:item) => {\n-        #[doc(fake_variadic)]\n-        #[doc = \"This trait is implemented for function pointers with up to twelve arguments.\"]\n-        #[$meta]\n-        $item\n-    };\n-    ($a:ident $($rest_a:ident)+ @ #[$meta:meta] $item:item) => {\n-        #[doc(hidden)]\n-        #[$meta]\n-        $item\n-    };\n-}\n+#[cfg(bootstrap)]\n+mod old_fn_ptr_impl {\n+    use super::*;\n+    // If this is a unary fn pointer, it adds a doc comment.\n+    // Otherwise, it hides the docs entirely.\n+    macro_rules! maybe_fnptr_doc {\n+        (@ #[$meta:meta] $item:item) => {\n+            #[doc(hidden)]\n+            #[$meta]\n+            $item\n+        };\n+        ($a:ident @ #[$meta:meta] $item:item) => {\n+            #[doc(fake_variadic)]\n+            #[doc = \"This trait is implemented for function pointers with up to twelve arguments.\"]\n+            #[$meta]\n+            $item\n+        };\n+        ($a:ident $($rest_a:ident)+ @ #[$meta:meta] $item:item) => {\n+            #[doc(hidden)]\n+            #[$meta]\n+            $item\n+        };\n+    }\n \n-// FIXME(strict_provenance_magic): function pointers have buggy codegen that\n-// necessitates casting to a usize to get the backend to do the right thing.\n-// for now I will break AVR to silence *a billion* lints. We should probably\n-// have a proper \"opaque function pointer type\" to handle this kind of thing.\n+    // FIXME(strict_provenance_magic): function pointers have buggy codegen that\n+    // necessitates casting to a usize to get the backend to do the right thing.\n+    // for now I will break AVR to silence *a billion* lints. We should probably\n+    // have a proper \"opaque function pointer type\" to handle this kind of thing.\n \n-// Impls for function pointers\n-macro_rules! fnptr_impls_safety_abi {\n-    ($FnTy: ty, $($Arg: ident),*) => {\n+    // Impls for function pointers\n+    macro_rules! fnptr_impls_safety_abi {\n+        ($FnTy: ty, $($Arg: ident),*) => {\n         fnptr_impls_safety_abi! { #[stable(feature = \"fnptr_impls\", since = \"1.4.0\")] $FnTy, $($Arg),* }\n     };\n     (@c_unwind $FnTy: ty, $($Arg: ident),*) => {\n         fnptr_impls_safety_abi! { #[unstable(feature = \"c_unwind\", issue = \"74990\")] $FnTy, $($Arg),* }\n     };\n     (#[$meta:meta] $FnTy: ty, $($Arg: ident),*) => {\n-        maybe_fnptr_doc! {\n-            $($Arg)* @\n-            #[$meta]\n-            impl<Ret, $($Arg),*> PartialEq for $FnTy {\n-                #[inline]\n-                fn eq(&self, other: &Self) -> bool {\n-                    *self as usize == *other as usize\n+            maybe_fnptr_doc! {\n+                $($Arg)* @\n+                #[$meta]\n+                impl<Ret, $($Arg),*> PartialEq for $FnTy {\n+                    #[inline]\n+                    fn eq(&self, other: &Self) -> bool {\n+                        *self as usize == *other as usize\n+                    }\n                 }\n             }\n-        }\n \n-        maybe_fnptr_doc! {\n-            $($Arg)* @\n-            #[$meta]\n-            impl<Ret, $($Arg),*> Eq for $FnTy {}\n-        }\n+            maybe_fnptr_doc! {\n+                $($Arg)* @\n+                #[$meta]\n+                impl<Ret, $($Arg),*> Eq for $FnTy {}\n+            }\n \n-        maybe_fnptr_doc! {\n-            $($Arg)* @\n-            #[$meta]\n-            impl<Ret, $($Arg),*> PartialOrd for $FnTy {\n-                #[inline]\n-                fn partial_cmp(&self, other: &Self) -> Option<Ordering> {\n-                    (*self as usize).partial_cmp(&(*other as usize))\n+            maybe_fnptr_doc! {\n+                $($Arg)* @\n+                #[$meta]\n+                impl<Ret, $($Arg),*> PartialOrd for $FnTy {\n+                    #[inline]\n+                    fn partial_cmp(&self, other: &Self) -> Option<Ordering> {\n+                        (*self as usize).partial_cmp(&(*other as usize))\n+                    }\n                 }\n             }\n-        }\n \n-        maybe_fnptr_doc! {\n-            $($Arg)* @\n-            #[$meta]\n-            impl<Ret, $($Arg),*> Ord for $FnTy {\n-                #[inline]\n-                fn cmp(&self, other: &Self) -> Ordering {\n-                    (*self as usize).cmp(&(*other as usize))\n+            maybe_fnptr_doc! {\n+                $($Arg)* @\n+                #[$meta]\n+                impl<Ret, $($Arg),*> Ord for $FnTy {\n+                    #[inline]\n+                    fn cmp(&self, other: &Self) -> Ordering {\n+                        (*self as usize).cmp(&(*other as usize))\n+                    }\n                 }\n             }\n-        }\n \n-        maybe_fnptr_doc! {\n-            $($Arg)* @\n-            #[$meta]\n-            impl<Ret, $($Arg),*> hash::Hash for $FnTy {\n-                fn hash<HH: hash::Hasher>(&self, state: &mut HH) {\n-                    state.write_usize(*self as usize)\n+            maybe_fnptr_doc! {\n+                $($Arg)* @\n+                #[$meta]\n+                impl<Ret, $($Arg),*> hash::Hash for $FnTy {\n+                    fn hash<HH: hash::Hasher>(&self, state: &mut HH) {\n+                        state.write_usize(*self as usize)\n+                    }\n                 }\n             }\n-        }\n \n-        maybe_fnptr_doc! {\n-            $($Arg)* @\n-            #[$meta]\n-            impl<Ret, $($Arg),*> fmt::Pointer for $FnTy {\n-                fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-                    fmt::pointer_fmt_inner(*self as usize, f)\n+            maybe_fnptr_doc! {\n+                $($Arg)* @\n+                #[$meta]\n+                impl<Ret, $($Arg),*> fmt::Pointer for $FnTy {\n+                    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+                        fmt::pointer_fmt_inner(*self as usize, f)\n+                    }\n                 }\n             }\n-        }\n \n-        maybe_fnptr_doc! {\n-            $($Arg)* @\n-            #[$meta]\n-            impl<Ret, $($Arg),*> fmt::Debug for $FnTy {\n-                fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-                    fmt::pointer_fmt_inner(*self as usize, f)\n+            maybe_fnptr_doc! {\n+                $($Arg)* @\n+                #[$meta]\n+                impl<Ret, $($Arg),*> fmt::Debug for $FnTy {\n+                    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+                        fmt::pointer_fmt_inner(*self as usize, f)\n+                    }\n                 }\n             }\n         }\n     }\n-}\n \n-macro_rules! fnptr_impls_args {\n-    ($($Arg: ident),+) => {\n-        fnptr_impls_safety_abi! { extern \"Rust\" fn($($Arg),+) -> Ret, $($Arg),+ }\n-        fnptr_impls_safety_abi! { extern \"C\" fn($($Arg),+) -> Ret, $($Arg),+ }\n-        fnptr_impls_safety_abi! { extern \"C\" fn($($Arg),+ , ...) -> Ret, $($Arg),+ }\n+    macro_rules! fnptr_impls_args {\n+        ($($Arg: ident),+) => {\n+            fnptr_impls_safety_abi! { extern \"Rust\" fn($($Arg),+) -> Ret, $($Arg),+ }\n+            fnptr_impls_safety_abi! { extern \"C\" fn($($Arg),+) -> Ret, $($Arg),+ }\n+            fnptr_impls_safety_abi! { extern \"C\" fn($($Arg),+ , ...) -> Ret, $($Arg),+ }\n         fnptr_impls_safety_abi! { @c_unwind extern \"C-unwind\" fn($($Arg),+) -> Ret, $($Arg),+ }\n         fnptr_impls_safety_abi! { @c_unwind extern \"C-unwind\" fn($($Arg),+ , ...) -> Ret, $($Arg),+ }\n-        fnptr_impls_safety_abi! { unsafe extern \"Rust\" fn($($Arg),+) -> Ret, $($Arg),+ }\n-        fnptr_impls_safety_abi! { unsafe extern \"C\" fn($($Arg),+) -> Ret, $($Arg),+ }\n-        fnptr_impls_safety_abi! { unsafe extern \"C\" fn($($Arg),+ , ...) -> Ret, $($Arg),+ }\n+            fnptr_impls_safety_abi! { unsafe extern \"Rust\" fn($($Arg),+) -> Ret, $($Arg),+ }\n+            fnptr_impls_safety_abi! { unsafe extern \"C\" fn($($Arg),+) -> Ret, $($Arg),+ }\n+            fnptr_impls_safety_abi! { unsafe extern \"C\" fn($($Arg),+ , ...) -> Ret, $($Arg),+ }\n         fnptr_impls_safety_abi! { @c_unwind unsafe extern \"C-unwind\" fn($($Arg),+) -> Ret, $($Arg),+ }\n         fnptr_impls_safety_abi! { @c_unwind unsafe extern \"C-unwind\" fn($($Arg),+ , ...) -> Ret, $($Arg),+ }\n-    };\n-    () => {\n-        // No variadic functions with 0 parameters\n-        fnptr_impls_safety_abi! { extern \"Rust\" fn() -> Ret, }\n-        fnptr_impls_safety_abi! { extern \"C\" fn() -> Ret, }\n+        };\n+        () => {\n+            // No variadic functions with 0 parameters\n+            fnptr_impls_safety_abi! { extern \"Rust\" fn() -> Ret, }\n+            fnptr_impls_safety_abi! { extern \"C\" fn() -> Ret, }\n         fnptr_impls_safety_abi! { @c_unwind extern \"C-unwind\" fn() -> Ret, }\n-        fnptr_impls_safety_abi! { unsafe extern \"Rust\" fn() -> Ret, }\n-        fnptr_impls_safety_abi! { unsafe extern \"C\" fn() -> Ret, }\n+            fnptr_impls_safety_abi! { unsafe extern \"Rust\" fn() -> Ret, }\n+            fnptr_impls_safety_abi! { unsafe extern \"C\" fn() -> Ret, }\n         fnptr_impls_safety_abi! { @c_unwind unsafe extern \"C-unwind\" fn() -> Ret, }\n-    };\n+        };\n+    }\n+\n+    fnptr_impls_args! {}\n+    fnptr_impls_args! { T }\n+    fnptr_impls_args! { A, B }\n+    fnptr_impls_args! { A, B, C }\n+    fnptr_impls_args! { A, B, C, D }\n+    fnptr_impls_args! { A, B, C, D, E }\n+    fnptr_impls_args! { A, B, C, D, E, F }\n+    fnptr_impls_args! { A, B, C, D, E, F, G }\n+    fnptr_impls_args! { A, B, C, D, E, F, G, H }\n+    fnptr_impls_args! { A, B, C, D, E, F, G, H, I }\n+    fnptr_impls_args! { A, B, C, D, E, F, G, H, I, J }\n+    fnptr_impls_args! { A, B, C, D, E, F, G, H, I, J, K }\n+    fnptr_impls_args! { A, B, C, D, E, F, G, H, I, J, K, L }\n }\n \n-fnptr_impls_args! {}\n-fnptr_impls_args! { T }\n-fnptr_impls_args! { A, B }\n-fnptr_impls_args! { A, B, C }\n-fnptr_impls_args! { A, B, C, D }\n-fnptr_impls_args! { A, B, C, D, E }\n-fnptr_impls_args! { A, B, C, D, E, F }\n-fnptr_impls_args! { A, B, C, D, E, F, G }\n-fnptr_impls_args! { A, B, C, D, E, F, G, H }\n-fnptr_impls_args! { A, B, C, D, E, F, G, H, I }\n-fnptr_impls_args! { A, B, C, D, E, F, G, H, I, J }\n-fnptr_impls_args! { A, B, C, D, E, F, G, H, I, J, K }\n-fnptr_impls_args! { A, B, C, D, E, F, G, H, I, J, K, L }\n+#[cfg(not(bootstrap))]\n+mod new_fn_ptr_impl {\n+    use super::*;\n+    use crate::marker::FnPtr;\n+\n+    #[stable(feature = \"fnptr_impls\", since = \"1.4.0\")]\n+    impl<F: FnPtr> PartialEq for F {\n+        #[inline]\n+        fn eq(&self, other: &Self) -> bool {\n+            self.addr() == other.addr()\n+        }\n+    }\n+    #[stable(feature = \"fnptr_impls\", since = \"1.4.0\")]\n+    impl<F: FnPtr> Eq for F {}\n+\n+    #[stable(feature = \"fnptr_impls\", since = \"1.4.0\")]\n+    impl<F: FnPtr> PartialOrd for F {\n+        #[inline]\n+        fn partial_cmp(&self, other: &Self) -> Option<Ordering> {\n+            self.addr().partial_cmp(&other.addr())\n+        }\n+    }\n+    #[stable(feature = \"fnptr_impls\", since = \"1.4.0\")]\n+    impl<F: FnPtr> Ord for F {\n+        #[inline]\n+        fn cmp(&self, other: &Self) -> Ordering {\n+            self.addr().cmp(&other.addr())\n+        }\n+    }\n+\n+    #[stable(feature = \"fnptr_impls\", since = \"1.4.0\")]\n+    impl<F: FnPtr> hash::Hash for F {\n+        fn hash<HH: hash::Hasher>(&self, state: &mut HH) {\n+            state.write_usize(self.addr() as _)\n+        }\n+    }\n+\n+    #[stable(feature = \"fnptr_impls\", since = \"1.4.0\")]\n+    impl<F: FnPtr> fmt::Pointer for F {\n+        fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+            fmt::pointer_fmt_inner(self.addr() as _, f)\n+        }\n+    }\n \n+    #[stable(feature = \"fnptr_impls\", since = \"1.4.0\")]\n+    impl<F: FnPtr> fmt::Debug for F {\n+        fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+            fmt::pointer_fmt_inner(self.addr() as _, f)\n+        }\n+    }\n+}\n /// Create a `const` raw pointer to a place, without creating an intermediate reference.\n ///\n /// Creating a reference with `&`/`&mut` is only allowed if the pointer is properly aligned"}, {"sha": "ac8862716c070e1276de636e5c91c2101ff815f5", "filename": "tests/ui/issues/issue-59488.stderr", "status": "modified", "additions": 0, "deletions": 20, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/5ae6caa0f04c686f0cc8a330f54390131148f899/tests%2Fui%2Fissues%2Fissue-59488.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/5ae6caa0f04c686f0cc8a330f54390131148f899/tests%2Fui%2Fissues%2Fissue-59488.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fissues%2Fissue-59488.stderr?ref=5ae6caa0f04c686f0cc8a330f54390131148f899", "patch": "@@ -90,16 +90,6 @@ LL |     assert_eq!(Foo::Bar, i);\n    |     ^^^^^^^^^^^^^^^^^^^^^^^ `fn(usize) -> Foo {Foo::Bar}` cannot be formatted using `{:?}` because it doesn't implement `Debug`\n    |\n    = help: the trait `Debug` is not implemented for fn item `fn(usize) -> Foo {Foo::Bar}`\n-   = help: the following other types implement trait `Debug`:\n-             extern \"C\" fn() -> Ret\n-             extern \"C\" fn(A, B) -> Ret\n-             extern \"C\" fn(A, B, ...) -> Ret\n-             extern \"C\" fn(A, B, C) -> Ret\n-             extern \"C\" fn(A, B, C, ...) -> Ret\n-             extern \"C\" fn(A, B, C, D) -> Ret\n-             extern \"C\" fn(A, B, C, D, ...) -> Ret\n-             extern \"C\" fn(A, B, C, D, E) -> Ret\n-           and 118 others\n    = note: this error originates in the macro `assert_eq` (in Nightly builds, run with -Z macro-backtrace for more info)\n \n error[E0277]: `fn(usize) -> Foo {Foo::Bar}` doesn't implement `Debug`\n@@ -109,16 +99,6 @@ LL |     assert_eq!(Foo::Bar, i);\n    |     ^^^^^^^^^^^^^^^^^^^^^^^ `fn(usize) -> Foo {Foo::Bar}` cannot be formatted using `{:?}` because it doesn't implement `Debug`\n    |\n    = help: the trait `Debug` is not implemented for fn item `fn(usize) -> Foo {Foo::Bar}`\n-   = help: the following other types implement trait `Debug`:\n-             extern \"C\" fn() -> Ret\n-             extern \"C\" fn(A, B) -> Ret\n-             extern \"C\" fn(A, B, ...) -> Ret\n-             extern \"C\" fn(A, B, C) -> Ret\n-             extern \"C\" fn(A, B, C, ...) -> Ret\n-             extern \"C\" fn(A, B, C, D) -> Ret\n-             extern \"C\" fn(A, B, C, D, ...) -> Ret\n-             extern \"C\" fn(A, B, C, D, E) -> Ret\n-           and 118 others\n    = note: this error originates in the macro `assert_eq` (in Nightly builds, run with -Z macro-backtrace for more info)\n \n error: aborting due to 10 previous errors"}]}