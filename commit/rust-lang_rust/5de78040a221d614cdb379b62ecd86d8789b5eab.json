{"sha": "5de78040a221d614cdb379b62ecd86d8789b5eab", "node_id": "MDY6Q29tbWl0NzI0NzEyOjVkZTc4MDQwYTIyMWQ2MTRjZGIzNzliNjJlY2Q4NmQ4Nzg5YjVlYWI=", "commit": {"author": {"name": "Tobias Bucher", "email": "tobiasbucher5991@gmail.com", "date": "2015-01-02T13:07:20Z"}, "committer": {"name": "Tobias Bucher", "email": "tobiasbucher5991@gmail.com", "date": "2015-01-03T22:19:14Z"}, "message": "Make all integers in the guide `i32`, implicitely\n\nThe guide still needs to talk about integer suffixes.", "tree": {"sha": "30a2ce8b31f6a9e68bfb7df82b5a74134dc2ab4e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/30a2ce8b31f6a9e68bfb7df82b5a74134dc2ab4e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5de78040a221d614cdb379b62ecd86d8789b5eab", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5de78040a221d614cdb379b62ecd86d8789b5eab", "html_url": "https://github.com/rust-lang/rust/commit/5de78040a221d614cdb379b62ecd86d8789b5eab", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5de78040a221d614cdb379b62ecd86d8789b5eab/comments", "author": {"login": "tbu-", "id": 6666593, "node_id": "MDQ6VXNlcjY2NjY1OTM=", "avatar_url": "https://avatars.githubusercontent.com/u/6666593?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tbu-", "html_url": "https://github.com/tbu-", "followers_url": "https://api.github.com/users/tbu-/followers", "following_url": "https://api.github.com/users/tbu-/following{/other_user}", "gists_url": "https://api.github.com/users/tbu-/gists{/gist_id}", "starred_url": "https://api.github.com/users/tbu-/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tbu-/subscriptions", "organizations_url": "https://api.github.com/users/tbu-/orgs", "repos_url": "https://api.github.com/users/tbu-/repos", "events_url": "https://api.github.com/users/tbu-/events{/privacy}", "received_events_url": "https://api.github.com/users/tbu-/received_events", "type": "User", "site_admin": false}, "committer": {"login": "tbu-", "id": 6666593, "node_id": "MDQ6VXNlcjY2NjY1OTM=", "avatar_url": "https://avatars.githubusercontent.com/u/6666593?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tbu-", "html_url": "https://github.com/tbu-", "followers_url": "https://api.github.com/users/tbu-/followers", "following_url": "https://api.github.com/users/tbu-/following{/other_user}", "gists_url": "https://api.github.com/users/tbu-/gists{/gist_id}", "starred_url": "https://api.github.com/users/tbu-/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tbu-/subscriptions", "organizations_url": "https://api.github.com/users/tbu-/orgs", "repos_url": "https://api.github.com/users/tbu-/repos", "events_url": "https://api.github.com/users/tbu-/events{/privacy}", "received_events_url": "https://api.github.com/users/tbu-/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "fe7e285d0cbae8e44c3853a6965caf2b575dcfcc", "url": "https://api.github.com/repos/rust-lang/rust/commits/fe7e285d0cbae8e44c3853a6965caf2b575dcfcc", "html_url": "https://github.com/rust-lang/rust/commit/fe7e285d0cbae8e44c3853a6965caf2b575dcfcc"}], "stats": {"total": 542, "additions": 270, "deletions": 272}, "files": [{"sha": "0ec45e77f7d5f1e379a4376c5343f926cbb0cc36", "filename": "src/doc/guide.md", "status": "modified", "additions": 270, "deletions": 272, "changes": 542, "blob_url": "https://github.com/rust-lang/rust/blob/5de78040a221d614cdb379b62ecd86d8789b5eab/src%2Fdoc%2Fguide.md", "raw_url": "https://github.com/rust-lang/rust/raw/5de78040a221d614cdb379b62ecd86d8789b5eab/src%2Fdoc%2Fguide.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fguide.md?ref=5de78040a221d614cdb379b62ecd86d8789b5eab", "patch": "@@ -384,7 +384,7 @@ The first thing we'll learn about are 'variable bindings.' They look like this:\n \n ```{rust}\n fn main() {\n-    let x = 5i;\n+    let x = 5;\n }\n ```\n \n@@ -399,15 +399,13 @@ hand side of a `let` expression is a full pattern, not just a variable name.\n This means we can do things like:\n \n ```{rust}\n-let (x, y) = (1i, 2i);\n+let (x, y) = (1, 2);\n ```\n \n After this expression is evaluated, `x` will be one, and `y` will be two.\n Patterns are really powerful, but this is about all we can do with them so far.\n So let's just keep this in the back of our minds as we go forward.\n \n-By the way, in these examples, `i` indicates that the number is an integer.\n-\n Rust is a statically typed language, which means that we specify our types up\n front. So why does our first example compile? Well, Rust has this thing called\n \"type inference.\" If it can figure out what the type of something is, Rust\n@@ -416,18 +414,18 @@ doesn't require you to actually type it out.\n We can add the type if we want to, though. Types come after a colon (`:`):\n \n ```{rust}\n-let x: int = 5;\n+let x: i32 = 5;\n ```\n \n If I asked you to read this out loud to the rest of the class, you'd say \"`x`\n-is a binding with the type `int` and the value `five`.\"\n+is a binding with the type `i32` and the value `five`.\"\n \n In future examples, we may annotate the type in a comment. The examples will\n look like this:\n \n ```{rust}\n fn main() {\n-    let x = 5i; // x: int\n+    let x = 5; // x: i32\n }\n ```\n \n@@ -438,23 +436,23 @@ include them to help you understand what the types that Rust infers are.\n By default, bindings are **immutable**. This code will not compile:\n \n ```{ignore}\n-let x = 5i;\n-x = 10i;\n+let x = 5;\n+x = 10;\n ```\n \n It will give you this error:\n \n ```text\n error: re-assignment of immutable variable `x`\n-     x = 10i;\n+     x = 10;\n      ^~~~~~~\n ```\n \n If you want a binding to be mutable, you can use `mut`:\n \n ```{rust}\n-let mut x = 5i; // mut x: int\n-x = 10i;\n+let mut x = 5; // mut x: i32\n+x = 10;\n ```\n \n There is no single reason that bindings are immutable by default, but we can\n@@ -488,14 +486,14 @@ src/main.rs:2     let x;\n Giving it a type will compile, though:\n \n ```{rust}\n-let x: int;\n+let x: i32;\n ```\n \n Let's try it out. Change your `src/main.rs` file to look like this:\n \n ```{rust}\n fn main() {\n-    let x: int;\n+    let x: i32;\n \n     println!(\"Hello world!\");\n }\n@@ -507,7 +505,7 @@ but it will still print \"Hello, world!\":\n ```text\n    Compiling hello_world v0.0.1 (file:///home/you/projects/hello_world)\n src/main.rs:2:9: 2:10 warning: unused variable: `x`, #[warn(unused_variable)] on by default\n-src/main.rs:2     let x: int;\n+src/main.rs:2     let x: i32;\n                       ^\n ```\n \n@@ -517,7 +515,7 @@ do that. Change your program to look like this:\n \n ```{rust,ignore}\n fn main() {\n-    let x: int;\n+    let x: i32;\n \n     println!(\"The value of x is: {}\", x);\n }\n@@ -568,9 +566,9 @@ multiple paths can be taken.\n In the case of `if`, there is one choice that leads down two paths:\n \n ```rust\n-let x = 5i;\n+let x = 5;\n \n-if x == 5i {\n+if x == 5 {\n     println!(\"x is five!\");\n }\n ```\n@@ -582,9 +580,9 @@ the block is executed. If it's `false`, then it is not.\n If you want something to happen in the `false` case, use an `else`:\n \n ```{rust}\n-let x = 5i;\n+let x = 5;\n \n-if x == 5i {\n+if x == 5 {\n     println!(\"x is five!\");\n } else {\n     println!(\"x is not five :(\");\n@@ -595,21 +593,21 @@ This is all pretty standard. However, you can also do this:\n \n \n ```{rust}\n-let x = 5i;\n+let x = 5;\n \n-let y = if x == 5i {\n-    10i\n+let y = if x == 5 {\n+    10\n } else {\n-    15i\n-}; // y: int\n+    15\n+}; // y: i32\n ```\n \n Which we can (and probably should) write like this:\n \n ```{rust}\n-let x = 5i;\n+let x = 5;\n \n-let y = if x == 5i { 10i } else { 15i }; // y: int\n+let y = if x == 5 { 10 } else { 15 }; // y: i32\n ```\n \n This reveals two interesting things about Rust: it is an expression-based\n@@ -641,15 +639,15 @@ In Rust, however, using `let` to introduce a binding is _not_ an expression. The\n following will produce a compile-time error:\n \n ```{ignore}\n-let x = (let y = 5i); // expected identifier, found keyword `let`\n+let x = (let y = 5); // expected identifier, found keyword `let`\n ```\n \n The compiler is telling us here that it was expecting to see the beginning of\n an expression, and a `let` can only begin a statement, not an expression.\n \n-Note that assigning to an already-bound variable (e.g. `y = 5i`) is still an\n+Note that assigning to an already-bound variable (e.g. `y = 5`) is still an\n expression, although its value is not particularly useful. Unlike C, where an\n-assignment evaluates to the assigned value (e.g. `5i` in the previous example),\n+assignment evaluates to the assigned value (e.g. `5` in the previous example),\n in Rust the value of an assignment is the unit type `()` (which we'll cover later).\n \n The second kind of statement in Rust is the **expression statement**. Its\n@@ -664,9 +662,9 @@ What is this exception that makes us say 'almost?' You saw it already, in this\n code:\n \n ```{rust}\n-let x = 5i;\n+let x = 5;\n \n-let y: int = if x == 5i { 10i } else { 15i };\n+let y: i32 = if x == 5 { 10 } else { 15 };\n ```\n \n Note that I've added the type annotation to `y`, to specify explicitly that I\n@@ -675,20 +673,20 @@ want `y` to be an integer.\n This is not the same as this, which won't compile:\n \n ```{ignore}\n-let x = 5i;\n+let x = 5;\n \n-let y: int = if x == 5i { 10i; } else { 15i; };\n+let y: i32 = if x == 5 { 10; } else { 15; };\n ```\n \n Note the semicolons after the 10 and 15. Rust will give us the following error:\n \n ```text\n-error: mismatched types: expected `int` but found `()` (expected int but found ())\n+error: mismatched types: expected `i32` but found `()` (expected i32 but found ())\n ```\n \n We expected an integer, but we got `()`. `()` is pronounced 'unit', and is a\n special type in Rust's type system. In Rust, `()` is _not_ a valid value for a\n-variable of type `int`. It's only a valid value for variables of the type `()`,\n+variable of type `i32`. It's only a valid value for variables of the type `()`,\n which aren't very useful. Remember how we said statements don't return a value?\n Well, that's the purpose of unit in this case. The semicolon turns any\n expression into a statement by throwing away its value and returning unit\n@@ -719,7 +717,7 @@ fn foo() {\n So, what about taking arguments? Here's a function that prints a number:\n \n ```{rust}\n-fn print_number(x: int) {\n+fn print_number(x: i32) {\n     println!(\"x is: {}\", x);\n }\n ```\n@@ -731,7 +729,7 @@ fn main() {\n     print_number(5);\n }\n \n-fn print_number(x: int) {\n+fn print_number(x: i32) {\n     println!(\"x is: {}\", x);\n }\n ```\n@@ -746,7 +744,7 @@ fn main() {\n     print_sum(5, 6);\n }\n \n-fn print_sum(x: int, y: int) {\n+fn print_sum(x: i32, y: i32) {\n     println!(\"sum is: {}\", x + y);\n }\n ```\n@@ -779,7 +777,7 @@ sweet spot between full inference and no inference.\n What about returning a value? Here's a function that adds one to an integer:\n \n ```{rust}\n-fn add_one(x: int) -> int {\n+fn add_one(x: i32) -> i32 {\n     x + 1\n }\n ```\n@@ -790,7 +788,7 @@ Rust functions return exactly one value, and you declare the type after an\n You'll note the lack of a semicolon here. If we added it in:\n \n ```{ignore}\n-fn add_one(x: int) -> int {\n+fn add_one(x: i32) -> i32 {\n     x + 1;\n }\n ```\n@@ -799,7 +797,7 @@ We would get an error:\n \n ```text\n error: not all control paths return a value\n-fn add_one(x: int) -> int {\n+fn add_one(x: i32) -> i32 {\n      x + 1;\n }\n \n@@ -809,7 +807,7 @@ help: consider removing this semicolon:\n ```\n \n Remember our earlier discussions about semicolons and `()`? Our function claims\n-to return an `int`, but with a semicolon, it would return `()` instead. Rust\n+to return an `i32`, but with a semicolon, it would return `()` instead. Rust\n realizes this probably isn't what we want, and suggests removing the semicolon.\n \n This is very much like our `if` statement before: the result of the block\n@@ -823,7 +821,7 @@ semicolon in a return position would cause a bug.\n But what about early returns? Rust does have a keyword for that, `return`:\n \n ```{rust}\n-fn foo(x: int) -> int {\n+fn foo(x: i32) -> i32 {\n     if x < 5 { return x; }\n \n     x + 1\n@@ -834,7 +832,7 @@ Using a `return` as the last line of a function works, but is considered poor\n style:\n \n ```{rust}\n-fn foo(x: int) -> int {\n+fn foo(x: i32) -> i32 {\n     if x < 5 { return x; }\n \n     return x + 1;\n@@ -857,7 +855,7 @@ and **doc comment**s.\n ```{rust}\n // Line comments are anything after '//' and extend to the end of the line.\n \n-let x = 5i; // this is also a line comment.\n+let x = 5; // this is also a line comment.\n \n // If you have a long explanation for something, you can put line comments next\n // to each other. Put a space between the // and your comment so that it's\n@@ -904,19 +902,19 @@ The first compound data type we're going to talk about are called **tuple**s.\n Tuples are an ordered list of a fixed size. Like this:\n \n ```rust\n-let x = (1i, \"hello\");\n+let x = (1, \"hello\");\n ```\n \n The parentheses and commas form this two-length tuple. Here's the same code, but\n with the type annotated:\n \n ```rust\n-let x: (int, &str) = (1, \"hello\");\n+let x: (i32, &str) = (1, \"hello\");\n ```\n \n As you can see, the type of a tuple looks just like the tuple, but with each\n position having a type name rather than the value. Careful readers will also\n-note that tuples are heterogeneous: we have an `int` and a `&str` in this tuple.\n+note that tuples are heterogeneous: we have an `i32` and a `&str` in this tuple.\n You haven't seen `&str` as a type before, and we'll discuss the details of\n strings later. In systems programming languages, strings are a bit more complex\n than in other languages. For now, just read `&str` as \"a string slice,\" and\n@@ -926,7 +924,7 @@ You can access the fields in a tuple through a **destructuring let**. Here's\n an example:\n \n ```rust\n-let (x, y, z) = (1i, 2i, 3i);\n+let (x, y, z) = (1, 2, 3);\n \n println!(\"x is {}\", x);\n ```\n@@ -944,8 +942,8 @@ destructuring. You can assign one tuple into another, if they have the same\n arity and contained types.\n \n ```rust\n-let mut x = (1i, 2i); // x: (int, int)\n-let y = (2i, 3i);     // y: (int, int)\n+let mut x = (1, 2); // x: (i32, i32)\n+let y = (2, 3);     // y: (i32, i32)\n \n x = y;\n ```\n@@ -954,8 +952,8 @@ You can also check for equality with `==`. Again, this will only compile if the\n tuples have the same type.\n \n ```rust\n-let x = (1i, 2i, 3i);\n-let y = (2i, 2i, 4i);\n+let x = (1, 2, 3);\n+let y = (2, 2, 4);\n \n if x == y {\n     println!(\"yes\");\n@@ -969,10 +967,10 @@ This will print `no`, because some of the values aren't equal.\n One other use of tuples is to return multiple values from a function:\n \n ```rust\n-fn next_two(x: int) -> (int, int) { (x + 1i, x + 2i) }\n+fn next_two(x: i32) -> (i32, i32) { (x + 1, x + 2) }\n \n fn main() {\n-    let (x, y) = next_two(5i);\n+    let (x, y) = next_two(5);\n     println!(\"x, y = {}, {}\", x, y);\n }\n ```\n@@ -992,12 +990,12 @@ difference: structs give each element that they contain a name, called a\n \n ```rust\n struct Point {\n-    x: int,\n-    y: int,\n+    x: i32,\n+    y: i32,\n }\n \n fn main() {\n-    let origin = Point { x: 0i, y: 0i }; // origin: Point\n+    let origin = Point { x: 0, y: 0 }; // origin: Point\n \n     println!(\"The origin is at ({}, {})\", origin.x, origin.y);\n }\n@@ -1019,12 +1017,12 @@ Use `mut` to make them mutable:\n \n ```{rust}\n struct Point {\n-    x: int,\n-    y: int,\n+    x: i32,\n+    y: i32,\n }\n \n fn main() {\n-    let mut point = Point { x: 0i, y: 0i };\n+    let mut point = Point { x: 0, y: 0 };\n \n     point.x = 5;\n \n@@ -1042,15 +1040,15 @@ don't:\n \n \n ```{rust}\n-struct Color(int, int, int);\n-struct Point(int, int, int);\n+struct Color(i32, i32, i32);\n+struct Point(i32, i32, i32);\n ```\n \n These two will not be equal, even if they have the same values:\n \n ```{rust}\n-# struct Color(int, int, int);\n-# struct Point(int, int, int);\n+# struct Color(i32, i32, i32);\n+# struct Point(i32, i32, i32);\n let black  = Color(0, 0, 0);\n let origin = Point(0, 0, 0);\n ```\n@@ -1060,15 +1058,15 @@ It is almost always better to use a struct than a tuple struct. We would write\n \n ```{rust}\n struct Color {\n-    red: int,\n-    blue: int,\n-    green: int,\n+    red: i32,\n+    blue: i32,\n+    green: i32,\n }\n \n struct Point {\n-    x: int,\n-    y: int,\n-    z: int,\n+    x: i32,\n+    y: i32,\n+    z: i32,\n }\n ```\n \n@@ -1080,7 +1078,7 @@ tuple struct with only one element. We call this a 'newtype,' because it lets\n you create a new type that's a synonym for another one:\n \n ```{rust}\n-struct Inches(int);\n+struct Inches(i32);\n \n let length = Inches(10);\n \n@@ -1117,15 +1115,15 @@ Here's an example of how to use `Ordering`:\n ```{rust}\n use std::cmp::Ordering;\n \n-fn cmp(a: int, b: int) -> Ordering {\n+fn cmp(a: i32, b: i32) -> Ordering {\n     if a < b { Ordering::Less }\n     else if a > b { Ordering::Greater }\n     else { Ordering::Equal }\n }\n \n fn main() {\n-    let x = 5i;\n-    let y = 10i;\n+    let x = 5;\n+    let y = 10;\n \n     let ordering = cmp(x, y); // ordering: Ordering\n \n@@ -1163,21 +1161,21 @@ This enum has two variants, one of which has a value:\n \n ```{rust}\n enum OptionalInt {\n-    Value(int),\n+    Value(i32),\n     Missing,\n }\n ```\n \n-This enum represents an `int` that we may or may not have. In the `Missing`\n+This enum represents an `i32` that we may or may not have. In the `Missing`\n case, we have no value, but in the `Value` case, we do. This enum is specific\n-to `int`s, though. We can make it usable by any type, but we haven't quite\n+to `i32`s, though. We can make it usable by any type, but we haven't quite\n gotten there yet!\n \n You can also have any number of values in an enum:\n \n ```{rust}\n enum OptionalColor {\n-    Color(int, int, int),\n+    Color(i32, i32, i32),\n     Missing,\n }\n ```\n@@ -1256,7 +1254,7 @@ Rust has a keyword, `match`, that allows you to replace complicated `if`/`else`\n groupings with something more powerful. Check it out:\n \n ```{rust}\n-let x = 5i;\n+let x = 5;\n \n match x {\n     1 => println!(\"one\"),\n@@ -1283,7 +1281,7 @@ error: non-exhaustive patterns: `_` not covered\n \n In other words, Rust is trying to tell us we forgot a value. Because `x` is an\n integer, Rust knows that it can have a number of different values \u2013 for example,\n-`6i`. Without the `_`, however, there is no arm that could match, and so Rust refuses\n+`6`. Without the `_`, however, there is no arm that could match, and so Rust refuses\n to compile. `_` acts like a 'catch-all arm'. If none of the other arms match,\n the arm with `_` will, and since we have this catch-all arm, we now have an arm\n for every possible value of `x`, and so our program will compile successfully.\n@@ -1294,15 +1292,15 @@ section on enums?\n ```{rust}\n use std::cmp::Ordering;\n \n-fn cmp(a: int, b: int) -> Ordering {\n+fn cmp(a: i32, b: i32) -> Ordering {\n     if a < b { Ordering::Less }\n     else if a > b { Ordering::Greater }\n     else { Ordering::Equal }\n }\n \n fn main() {\n-    let x = 5i;\n-    let y = 10i;\n+    let x = 5;\n+    let y = 10;\n \n     let ordering = cmp(x, y);\n \n@@ -1321,15 +1319,15 @@ We can re-write this as a `match`:\n ```{rust}\n use std::cmp::Ordering;\n \n-fn cmp(a: int, b: int) -> Ordering {\n+fn cmp(a: i32, b: i32) -> Ordering {\n     if a < b { Ordering::Less }\n     else if a > b { Ordering::Greater }\n     else { Ordering::Equal }\n }\n \n fn main() {\n-    let x = 5i;\n-    let y = 10i;\n+    let x = 5;\n+    let y = 10;\n \n     match cmp(x, y) {\n         Ordering::Less    => println!(\"less\"),\n@@ -1350,7 +1348,7 @@ make sure to cover all of our bases.\n \n ```{rust}\n enum OptionalInt {\n-    Value(int),\n+    Value(i32),\n     Missing,\n }\n \n@@ -1372,7 +1370,7 @@ fn main() {\n \n That is how you can get and use the values contained in `enum`s.\n It can also allow us to handle errors or unexpected computations; for example, a\n-function that is not guaranteed to be able to compute a result (an `int` here)\n+function that is not guaranteed to be able to compute a result (an `i32` here)\n could return an `OptionalInt`, and we would handle that value with a `match`.\n As you can see, `enum` and `match` used together are quite useful!\n \n@@ -1383,15 +1381,15 @@ also implement the previous line like this:\n ```{rust}\n use std::cmp::Ordering;\n \n-fn cmp(a: int, b: int) -> Ordering {\n+fn cmp(a: i32, b: i32) -> Ordering {\n     if a < b { Ordering::Less }\n     else if a > b { Ordering::Greater }\n     else { Ordering::Equal }\n }\n \n fn main() {\n-    let x = 5i;\n-    let y = 10i;\n+    let x = 5;\n+    let y = 10;\n \n     println!(\"{}\", match cmp(x, y) {\n         Ordering::Less    => \"less\",\n@@ -1423,8 +1421,8 @@ for (x = 0; x < 10; x++) {\n Instead, it looks like this:\n \n ```{rust}\n-for x in range(0i, 10i) {\n-    println!(\"{}\", x); // x: int\n+for x in range(0, 10) {\n+    println!(\"{}\", x); // x: i32\n }\n ```\n \n@@ -1528,7 +1526,7 @@ We now loop forever with `loop` and use `break` to break out early.\n iteration. This will only print the odd numbers:\n \n ```{rust}\n-for x in range(0i, 10i) {\n+for x in range(0, 10) {\n     if x % 2 == 0 { continue; }\n \n     println!(\"{}\", x);\n@@ -1624,15 +1622,15 @@ things. The most basic is the **array**, a fixed-size list of elements of the\n same type. By default, arrays are immutable.\n \n ```{rust}\n-let a = [1i, 2i, 3i];     // a: [int; 3]\n-let mut m = [1i, 2i, 3i]; // mut m: [int; 3]\n+let a = [1, 2, 3];     // a: [i32; 3]\n+let mut m = [1, 2, 3]; // mut m: [i32; 3]\n ```\n \n There's a shorthand for initializing each element of an array to the same\n-value. In this example, each element of `a` will be initialized to `0i`:\n+value. In this example, each element of `a` will be initialized to `0`:\n \n ```{rust}\n-let a = [0i; 20]; // a: [int; 20]\n+let a = [0; 20]; // a: [i32; 20]\n ```\n \n Arrays have type `[T; N]`. We'll talk about this `T` notation later, when we\n@@ -1643,7 +1641,7 @@ You can get the number of elements in an array `a` with `a.len()`, and use\n number in order:\n \n ```{rust}\n-let a = [1i, 2, 3]; // Only the first item needs a type suffix\n+let a = [1, 2, 3];\n \n println!(\"a has {} elements\", a.len());\n for e in a.iter() {\n@@ -1672,7 +1670,7 @@ later). Vectors are to arrays what `String` is to `&str`. You can create them\n with the `vec!` macro:\n \n ```{rust}\n-let v = vec![1i, 2, 3]; // v: Vec<int>\n+let v = vec![1, 2, 3]; // v: Vec<i32>\n ```\n \n (Notice that unlike the `println!` macro we've used in the past, we use square\n@@ -1683,7 +1681,7 @@ You can get the length of, iterate over, and subscript vectors just like\n arrays. In addition, (mutable) vectors can grow automatically:\n \n ```{rust}\n-let mut nums = vec![1i, 2, 3]; // mut nums: Vec<int>\n+let mut nums = vec![1, 2, 3]; // mut nums: Vec<i32>\n \n nums.push(4);\n \n@@ -1700,7 +1698,7 @@ Slices have a length, can be mutable or not, and in many ways behave like\n arrays:\n \n ```{rust}\n-let a = [0i, 1, 2, 3, 4];\n+let a = [0, 1, 2, 3, 4];\n let middle = a.slice(1, 4);     // A slice of a: just the elements [1,2,3]\n \n for e in middle.iter() {\n@@ -1792,7 +1790,7 @@ Do you remember this code?\n \n ```{rust}\n enum OptionalInt {\n-    Value(int),\n+    Value(i32),\n     Missing,\n }\n \n@@ -1824,7 +1822,7 @@ where there's no standard input. Because of this, `read_line` returns a type\n very similar to our `OptionalInt`: an `IoResult<T>`. We haven't talked about\n `IoResult<T>` yet because it is the **generic** form of our `OptionalInt`.\n Until then, you can think of it as being the same thing, just for any type \u2013\n-not just `int`s.\n+not just `i32`s.\n \n Rust provides a method on these `IoResult<T>`s called `ok()`, which does the\n same thing as our `match` statement but assumes that we have a valid value.\n@@ -2006,7 +2004,7 @@ use std::rand;\n fn main() {\n     println!(\"Guess the number!\");\n \n-    let secret_number = (rand::random() % 100i) + 1i; // secret_number: int\n+    let secret_number = (rand::random() % 100) + 1; // secret_number: i32\n \n     println!(\"The secret number is: {}\", secret_number);\n \n@@ -2038,7 +2036,7 @@ Let's try to compile this using `cargo build`:\n $ cargo build\n    Compiling guessing_game v0.0.1 (file:///home/you/projects/guessing_game)\n src/main.rs:7:26: 7:34 error: the type of this value must be known in this context\n-src/main.rs:7     let secret_number = (rand::random() % 100i) + 1i;\n+src/main.rs:7     let secret_number = (rand::random() % 100) + 1;\n                                        ^~~~~~~~\n error: aborting due to previous error\n ```\n@@ -2047,15 +2045,15 @@ It didn't work! Rust says \"the type of this value must be known in this\n context.\" What's up with that? Well, as it turns out, `rand::random()` can\n generate many kinds of random values, not just integers. And in this case, Rust\n isn't sure what kind of value `random()` should generate. So we have to help\n-it. With number literals, we just add an `i` onto the end to tell Rust they're\n+it. With number literals, we can just add an `i32` onto the end to tell Rust they're\n integers, but that does not work with functions. There's a different syntax,\n and it looks like this:\n \n ```{rust,ignore}\n-rand::random::<int>();\n+rand::random::<i32>();\n ```\n \n-This says \"please give me a random `int` value.\" We can change our code to use\n+This says \"please give me a random `i32` value.\" We can change our code to use\n this hint:\n \n ```{rust,no_run}\n@@ -2065,7 +2063,7 @@ use std::rand;\n fn main() {\n     println!(\"Guess the number!\");\n \n-    let secret_number = (rand::random::<int>() % 100i) + 1i;\n+    let secret_number = (rand::random::<i32>() % 100) + 1;\n \n     println!(\"The secret number is: {}\", secret_number);\n \n@@ -2182,7 +2180,7 @@ fn main() {\n     }\n }\n \n-fn cmp(a: int, b: int) -> Ordering {\n+fn cmp(a: i32, b: i32) -> Ordering {\n     if a < b { Ordering::Less }\n     else if a > b { Ordering::Greater }\n     else { Ordering::Equal }\n@@ -2194,10 +2192,10 @@ If we try to compile, we'll get some errors:\n ```bash\n $ cargo build\n    Compiling guessing_game v0.0.1 (file:///home/you/projects/guessing_game)\n-src/main.rs:20:15: 20:20 error: mismatched types: expected `int` but found `collections::string::String` (expected int but found struct collections::string::String)\n+src/main.rs:20:15: 20:20 error: mismatched types: expected `i32` but found `collections::string::String` (expected i32 but found struct collections::string::String)\n src/main.rs:20     match cmp(input, secret_number) {\n                              ^~~~~\n-src/main.rs:20:22: 20:35 error: mismatched types: expected `int` but found `uint` (expected int but found uint)\n+src/main.rs:20:22: 20:35 error: mismatched types: expected `i32` but found `uint` (expected i32 but found uint)\n src/main.rs:20     match cmp(input, secret_number) {\n                                     ^~~~~~~~~~~~~\n error: aborting due to 2 previous errors\n@@ -2906,7 +2904,7 @@ Here's a very basic test:\n ```{rust}\n #[test]\n fn is_one_equal_to_one() {\n-    assert_eq!(1i, 1i);\n+    assert_eq!(1, 1);\n }\n ```\n \n@@ -3207,9 +3205,9 @@ to look like this:\n ```{rust,ignore}\n #[test]\n fn math_checks_out() {\n-    let result = add_three_times_four(5i);\n+    let result = add_three_times_four(5);\n \n-    assert_eq!(32i, result);\n+    assert_eq!(32, result);\n }\n ```\n \n@@ -3219,7 +3217,7 @@ And try to run the test:\n $ cargo test\n    Compiling testing v0.0.1 (file:///home/you/projects/testing)\n /home/you/projects/testing/tests/lib.rs:3:18: 3:38 error: unresolved name `add_three_times_four`.\n-/home/you/projects/testing/tests/lib.rs:3     let result = add_three_times_four(5i);\n+/home/you/projects/testing/tests/lib.rs:3     let result = add_three_times_four(5);\n                                                            ^~~~~~~~~~~~~~~~~~~~\n error: aborting due to previous error\n Build failed, waiting for other jobs to finish...\n@@ -3240,7 +3238,7 @@ and put this in it:\n \n ```{rust}\n # fn main() {}\n-pub fn add_three_times_four(x: int) -> int {\n+pub fn add_three_times_four(x: i32) -> i32 {\n     (x + 3) * 4\n }\n ```\n@@ -3267,9 +3265,9 @@ use testing::add_three_times_four;\n \n #[test]\n fn math_checks_out() {\n-    let result = add_three_times_four(5i);\n+    let result = add_three_times_four(5);\n \n-    assert_eq!(32i, result);\n+    assert_eq!(32, result);\n }\n ```\n \n@@ -3313,13 +3311,13 @@ some unit tests to test those.\n Change your `src/lib.rs` to look like this:\n \n ```{rust,ignore}\n-pub fn add_three_times_four(x: int) -> int {\n+pub fn add_three_times_four(x: i32) -> i32 {\n     times_four(add_three(x))\n }\n \n-fn add_three(x: int) -> int { x + 3 }\n+fn add_three(x: i32) -> i32 { x + 3 }\n \n-fn times_four(x: int) -> int { x * 4 }\n+fn times_four(x: i32) -> i32 { x * 4 }\n ```\n \n If you run `cargo test`, you should get the same output:\n@@ -3363,16 +3361,16 @@ use testing::add_three;\n \n #[test]\n fn math_checks_out() {\n-    let result = add_three_times_four(5i);\n+    let result = add_three_times_four(5);\n \n-    assert_eq!(32i, result);\n+    assert_eq!(32, result);\n }\n \n #[test]\n fn test_add_three() {\n-    let result = add_three(5i);\n+    let result = add_three(5);\n \n-    assert_eq!(8i, result);\n+    assert_eq!(8, result);\n }\n ```\n \n@@ -3389,13 +3387,13 @@ Right. It's private. So external, integration tests won't work. We need a\n unit test. Open up your `src/lib.rs` and add this:\n \n ```{rust,ignore}\n-pub fn add_three_times_four(x: int) -> int {\n+pub fn add_three_times_four(x: i32) -> i32 {\n     times_four(add_three(x))\n }\n \n-fn add_three(x: int) -> int { x + 3 }\n+fn add_three(x: i32) -> i32 { x + 3 }\n \n-fn times_four(x: int) -> int { x * 4 }\n+fn times_four(x: i32) -> i32 { x * 4 }\n \n #[cfg(test)]\n mod test {\n@@ -3404,16 +3402,16 @@ mod test {\n \n     #[test]\n     fn test_add_three() {\n-        let result = add_three(5i);\n+        let result = add_three(5);\n \n-        assert_eq!(8i, result);\n+        assert_eq!(8, result);\n     }\n \n     #[test]\n     fn test_times_four() {\n-        let result = times_four(5i);\n+        let result = times_four(5);\n \n-        assert_eq!(20i, result);\n+        assert_eq!(20, result);\n     }\n }\n ```\n@@ -3495,26 +3493,26 @@ References are created using the ampersand (`&`). Here's a simple\n reference:\n \n ```{rust}\n-let x = 5i;\n+let x = 5;\n let y = &x;\n ```\n \n `y` is a reference to `x`. To dereference (get the value being referred to\n rather than the reference itself) `y`, we use the asterisk (`*`):\n \n ```{rust}\n-let x = 5i;\n+let x = 5;\n let y = &x;\n \n-assert_eq!(5i, *y);\n+assert_eq!(5, *y);\n ```\n \n Like any `let` binding, references are immutable by default.\n \n You can declare that functions take a reference:\n \n ```{rust}\n-fn add_one(x: &int) -> int { *x + 1 }\n+fn add_one(x: &i32) -> i32 { *x + 1 }\n \n fn main() {\n     assert_eq!(6, add_one(&5));\n@@ -3529,22 +3527,22 @@ Because references are immutable, you can have multiple references that\n **alias** (point to the same place):\n \n ```{rust}\n-let x = 5i;\n+let x = 5;\n let y = &x;\n let z = &x;\n ```\n \n We can make a mutable reference by using `&mut` instead of `&`:\n \n ```{rust}\n-let mut x = 5i;\n+let mut x = 5;\n let y = &mut x;\n ```\n \n Note that `x` must also be mutable. If it isn't, like this:\n \n ```{rust,ignore}\n-let x = 5i;\n+let x = 5;\n let y = &mut x;\n ```\n \n@@ -3570,7 +3568,7 @@ Rust will also prevent us from creating two mutable references that alias.\n This won't work:\n \n ```{rust,ignore}\n-let mut x = 5i;\n+let mut x = 5;\n let y = &mut x;\n let z = &mut x;\n ```\n@@ -3586,7 +3584,7 @@ note: previous borrow of `x` occurs here; the mutable borrow prevents subsequent\n                   ^\n note: previous borrow ends here\n  fn main() {\n-     let mut x = 5i;\n+     let mut x = 5;\n      let y = &mut x;\n      let z = &mut x;\n  }\n@@ -3667,19 +3665,19 @@ all of Rust. Let's see this syntax in action:\n \n ```{rust}\n {\n-    let x = 5i; // x is the owner of this integer, which is memory on the stack.\n+    let x = 5; // x is the owner of this integer, which is memory on the stack.\n \n     // other code here...\n \n } // privilege 1: when x goes out of scope, this memory is deallocated\n \n /// this function borrows an integer. It's given back automatically when the\n /// function returns.\n-fn foo(x: &int) -> &int { x }\n+fn foo(x: &i32) -> &i32 { x }\n \n {\n     // x is the owner of the integer, which is memory on the stack.\n-    let x = 5i;\n+    let x = 5;\n \n     // privilege 2: you may lend that resource to as many borrowers as you like\n     let y = &x;\n@@ -3692,7 +3690,7 @@ fn foo(x: &int) -> &int { x }\n \n {\n     // x is the owner of this integer, which is memory on the stack.\n-    let mut x = 5i;\n+    let mut x = 5;\n \n     // privilege 3: you may lend that resource to a single borrower, mutably\n     let y = &mut x;\n@@ -3718,7 +3716,7 @@ violation of the restrictions placed on owners who lend something out mutably.\n The code:\n \n ```{rust,ignore}\n-let mut x = 5i;\n+let mut x = 5;\n let y = &mut x;\n let z = &mut x;\n ```\n@@ -3734,7 +3732,7 @@ note: previous borrow of `x` occurs here; the mutable borrow prevents subsequent\n                   ^\n note: previous borrow ends here\n  fn main() {\n-     let mut x = 5i;\n+     let mut x = 5;\n      let y = &mut x;\n      let z = &mut x;\n  }\n@@ -3767,7 +3765,7 @@ we can't change `x` until the borrow is over.\n ```text\n note: previous borrow ends here\n  fn main() {\n-     let mut x = 5i;\n+     let mut x = 5;\n      let y = &mut x;\n      let z = &mut x;\n  }\n@@ -3828,7 +3826,7 @@ an integer `5` and makes `x` a pointer to it:\n \n ```{rust}\n {\n-    let x = box 5i;\n+    let x = box 5;\n     println!(\"{}\", *x);     // Prints 5\n }\n ```\n@@ -3844,7 +3842,7 @@ The Rust code above will do the same thing as the following C code:\n \n ```{c,ignore}\n {\n-    int *x = (int *)malloc(sizeof(int));\n+    i32 *x = (i32 *)malloc(sizeof(i32));\n     if (!x) abort();\n     *x = 5;\n     printf(\"%d\\n\", *x);\n@@ -3859,7 +3857,7 @@ Boxes are the sole owner of their contents, so you cannot take a mutable\n reference to them and then use the original box:\n \n ```{rust,ignore}\n-let mut x = box 5i;\n+let mut x = box 5;\n let y = &mut x;\n \n *x; // you might expect 5, but this is actually an error\n@@ -3880,7 +3878,7 @@ As long as `y` is borrowing the contents, we cannot use `x`. After `y` is\n done borrowing the value, we can use it again. This works fine:\n \n ```{rust}\n-let mut x = box 5i;\n+let mut x = box 5;\n \n {\n     let y = &mut x;\n@@ -3915,7 +3913,7 @@ To create an `Rc` value, use `Rc::new()`. To create a second owner, use the\n ```{rust}\n use std::rc::Rc;\n \n-let x = Rc::new(5i);\n+let x = Rc::new(5);\n let y = x.clone();\n \n println!(\"{} {}\", *x, *y);      // Prints 5 5\n@@ -3944,7 +3942,7 @@ A quick refresher: you can match against literals directly, and `_` acts as an\n 'any' case:\n \n ```{rust}\n-let x = 1i;\n+let x = 1;\n \n match x {\n     1 => println!(\"one\"),\n@@ -3957,7 +3955,7 @@ match x {\n You can match multiple patterns with `|`:\n \n ```{rust}\n-let x = 1i;\n+let x = 1;\n \n match x {\n     1 | 2 => println!(\"one or two\"),\n@@ -3969,7 +3967,7 @@ match x {\n You can match a range of values with `...`:\n \n ```{rust}\n-let x = 1i;\n+let x = 1;\n \n match x {\n     1 ... 5 => println!(\"one through five\"),\n@@ -3983,7 +3981,7 @@ If you're matching multiple things, via a `|` or a `...`, you can bind\n the value to a name with `@`:\n \n ```{rust}\n-let x = 1i;\n+let x = 1;\n \n match x {\n     e @ 1 ... 5 => println!(\"got a range element {}\", e),\n@@ -3996,14 +3994,14 @@ ignore the value and type in the variant:\n \n ```{rust}\n enum OptionalInt {\n-    Value(int),\n+    Value(i32),\n     Missing,\n }\n \n-let x = OptionalInt::Value(5i);\n+let x = OptionalInt::Value(5);\n \n match x {\n-    OptionalInt::Value(..) => println!(\"Got an int!\"),\n+    OptionalInt::Value(..) => println!(\"Got an i32!\"),\n     OptionalInt::Missing   => println!(\"No such luck.\"),\n }\n ```\n@@ -4012,15 +4010,15 @@ You can introduce **match guards** with `if`:\n \n ```{rust}\n enum OptionalInt {\n-    Value(int),\n+    Value(i32),\n     Missing,\n }\n \n-let x = OptionalInt::Value(5i);\n+let x = OptionalInt::Value(5);\n \n match x {\n-    OptionalInt::Value(i) if i > 5 => println!(\"Got an int bigger than five!\"),\n-    OptionalInt::Value(..) => println!(\"Got an int!\"),\n+    OptionalInt::Value(i) if i > 5 => println!(\"Got an i32 bigger than five!\"),\n+    OptionalInt::Value(..) => println!(\"Got an i32!\"),\n     OptionalInt::Missing   => println!(\"No such luck.\"),\n }\n ```\n@@ -4029,33 +4027,33 @@ If you're matching on a pointer, you can use the same syntax as you declared it\n with. First, `&`:\n \n ```{rust}\n-let x = &5i;\n+let x = &5;\n \n match x {\n     &val => println!(\"Got a value: {}\", val),\n }\n ```\n \n-Here, the `val` inside the `match` has type `int`. In other words, the left-hand\n-side of the pattern destructures the value. If we have `&5i`, then in `&val`, `val`\n-would be `5i`.\n+Here, the `val` inside the `match` has type `i32`. In other words, the left-hand\n+side of the pattern destructures the value. If we have `&5`, then in `&val`, `val`\n+would be `5`.\n \n If you want to get a reference, use the `ref` keyword:\n \n ```{rust}\n-let x = 5i;\n+let x = 5;\n \n match x {\n     ref r => println!(\"Got a reference to {}\", r),\n }\n ```\n \n-Here, the `r` inside the `match` has the type `&int`. In other words, the `ref`\n+Here, the `r` inside the `match` has the type `&i32`. In other words, the `ref`\n keyword _creates_ a reference, for use in the pattern. If you need a mutable\n reference, `ref mut` will work in the same way:\n \n ```{rust}\n-let mut x = 5i;\n+let mut x = 5;\n \n match x {\n     ref mut mr => println!(\"Got a mutable reference to {}\", mr),\n@@ -4067,11 +4065,11 @@ If you have a struct, you can destructure it inside of a pattern:\n ```{rust}\n # #![allow(non_shorthand_field_patterns)]\n struct Point {\n-    x: int,\n-    y: int,\n+    x: i32,\n+    y: i32,\n }\n \n-let origin = Point { x: 0i, y: 0i };\n+let origin = Point { x: 0, y: 0 };\n \n match origin {\n     Point { x: x, y: y } => println!(\"({},{})\", x, y),\n@@ -4083,11 +4081,11 @@ If we only care about some of the values, we don't have to give them all names:\n ```{rust}\n # #![allow(non_shorthand_field_patterns)]\n struct Point {\n-    x: int,\n-    y: int,\n+    x: i32,\n+    y: i32,\n }\n \n-let origin = Point { x: 0i, y: 0i };\n+let origin = Point { x: 0, y: 0 };\n \n match origin {\n     Point { x: x, .. } => println!(\"x is {}\", x),\n@@ -4099,11 +4097,11 @@ You can do this kind of match on any member, not just the first:\n ```{rust}\n # #![allow(non_shorthand_field_patterns)]\n struct Point {\n-    x: int,\n-    y: int,\n+    x: i32,\n+    y: i32,\n }\n \n-let origin = Point { x: 0i, y: 0i };\n+let origin = Point { x: 0, y: 0 };\n \n match origin {\n     Point { y: y, .. } => println!(\"y is {}\", y),\n@@ -4233,9 +4231,9 @@ arguments, really powerful things are possible.\n Let's make a closure:\n \n ```{rust}\n-let add_one = |x| { 1i + x };\n+let add_one = |x| { 1 + x };\n \n-println!(\"The sum of 5 plus 1 is {}.\", add_one(5i));\n+println!(\"The sum of 5 plus 1 is {}.\", add_one(5));\n ```\n \n We create a closure using the `|...| { ... }` syntax, and then we create a\n@@ -4245,8 +4243,8 @@ binding name and two parentheses, just like we would for a named function.\n Let's compare syntax. The two are pretty close:\n \n ```{rust}\n-let add_one = |x: int| -> int { 1i + x };\n-fn  add_one   (x: int) -> int { 1i + x }\n+let add_one = |x: i32| -> i32 { 1 + x };\n+fn  add_one   (x: i32) -> i32 { 1 + x }\n ```\n \n As you may have noticed, closures infer their argument and return types, so you\n@@ -4259,7 +4257,7 @@ this:\n \n ```{rust}\n fn main() {\n-    let x = 5i;\n+    let x = 5;\n \n     let printer = || { println!(\"x is: {}\", x); };\n \n@@ -4275,11 +4273,11 @@ defined. The closure borrows any variables it uses, so this will error:\n \n ```{rust,ignore}\n fn main() {\n-    let mut x = 5i;\n+    let mut x = 5;\n \n     let printer = || { println!(\"x is: {}\", x); };\n \n-    x = 6i; // error: cannot assign to `x` because it is borrowed\n+    x = 6; // error: cannot assign to `x` because it is borrowed\n }\n ```\n \n@@ -4299,67 +4297,67 @@ now. We'll talk about them more in the \"Threads\" section of the guide.\n Closures are most useful as an argument to another function. Here's an example:\n \n ```{rust}\n-fn twice(x: int, f: |int| -> int) -> int {\n+fn twice(x: i32, f: |i32| -> i32) -> i32 {\n     f(x) + f(x)\n }\n \n fn main() {\n-    let square = |x: int| { x * x };\n+    let square = |x: i32| { x * x };\n \n-    twice(5i, square); // evaluates to 50\n+    twice(5, square); // evaluates to 50\n }\n ```\n \n Let's break the example down, starting with `main`:\n \n ```{rust}\n-let square = |x: int| { x * x };\n+let square = |x: i32| { x * x };\n ```\n \n We've seen this before. We make a closure that takes an integer, and returns\n its square.\n \n ```{rust}\n-# fn twice(x: int, f: |int| -> int) -> int { f(x) + f(x) }\n-# let square = |x: int| { x * x };\n-twice(5i, square); // evaluates to 50\n+# fn twice(x: i32, f: |i32| -> i32) -> i32 { f(x) + f(x) }\n+# let square = |x: i32| { x * x };\n+twice(5, square); // evaluates to 50\n ```\n \n This line is more interesting. Here, we call our function, `twice`, and we pass\n it two arguments: an integer, `5`, and our closure, `square`. This is just like\n passing any other two variable bindings to a function, but if you've never\n worked with closures before, it can seem a little complex. Just think: \"I'm\n-passing two variables: one is an int, and one is a function.\"\n+passing two variables: one is an i32, and one is a function.\"\n \n Next, let's look at how `twice` is defined:\n \n ```{rust,ignore}\n-fn twice(x: int, f: |int| -> int) -> int {\n+fn twice(x: i32, f: |i32| -> i32) -> i32 {\n ```\n \n `twice` takes two arguments, `x` and `f`. That's why we called it with two\n-arguments. `x` is an `int`, we've done that a ton of times. `f` is a function,\n-though, and that function takes an `int` and returns an `int`. Notice\n-how the `|int| -> int` syntax looks a lot like our definition of `square`\n+arguments. `x` is an `i32`, we've done that a ton of times. `f` is a function,\n+though, and that function takes an `i32` and returns an `i32`. Notice\n+how the `|i32| -> i32` syntax looks a lot like our definition of `square`\n above, if we added the return type in:\n \n ```{rust}\n-let square = |x: int| -> int { x * x };\n-//           |int|    -> int\n+let square = |x: i32| -> i32 { x * x };\n+//           |i32|    -> i32\n ```\n \n-This function takes an `int` and returns an `int`.\n+This function takes an `i32` and returns an `i32`.\n \n This is the most complicated function signature we've seen yet! Give it a read\n a few times until you can see how it works. It takes a teeny bit of practice, and\n then it's easy.\n \n-Finally, `twice` returns an `int` as well.\n+Finally, `twice` returns an `i32` as well.\n \n Okay, let's look at the body of `twice`:\n \n ```{rust}\n-fn twice(x: int, f: |int| -> int) -> int {\n+fn twice(x: i32, f: |i32| -> i32) -> i32 {\n   f(x) + f(x)\n }\n ```\n@@ -4377,27 +4375,27 @@ If we didn't want to give `square` a name, we could just define it inline.\n This example is the same as the previous one:\n \n ```{rust}\n-fn twice(x: int, f: |int| -> int) -> int {\n+fn twice(x: i32, f: |i32| -> i32) -> i32 {\n     f(x) + f(x)\n }\n \n fn main() {\n-    twice(5i, |x: int| { x * x }); // evaluates to 50\n+    twice(5, |x: i32| { x * x }); // evaluates to 50\n }\n ```\n \n A named function's name can be used wherever you'd use a closure. Another\n way of writing the previous example:\n \n ```{rust}\n-fn twice(x: int, f: |int| -> int) -> int {\n+fn twice(x: i32, f: |i32| -> i32) -> i32 {\n     f(x) + f(x)\n }\n \n-fn square(x: int) -> int { x * x }\n+fn square(x: i32) -> i32 { x * x }\n \n fn main() {\n-    twice(5i, square); // evaluates to 50\n+    twice(5, square); // evaluates to 50\n }\n ```\n \n@@ -4415,7 +4413,7 @@ Let's talk about loops.\n Remember Rust's `for` loop? Here's an example:\n \n ```{rust}\n-for x in range(0i, 10i) {\n+for x in range(0, 10) {\n     println!(\"{}\", x);\n }\n ```\n@@ -4427,7 +4425,7 @@ call the `.next()` method on repeatedly, and it gives us a sequence of things.\n Like this:\n \n ```{rust}\n-let mut range = range(0i, 10i);\n+let mut range = range(0, 10);\n \n loop {\n     match range.next() {\n@@ -4442,8 +4440,8 @@ loop {\n We make a mutable binding to the return value of `range`, which is our iterator.\n We then `loop`, with an inner `match`. This `match` is used on the result of\n `range.next()`, which gives us a reference to the next value of the iterator.\n-`next` returns an `Option<int>`, in this case, which will be `Some(int)` when\n-we have a value and `None` once we run out. If we get `Some(int)`, we print it\n+`next` returns an `Option<i32>`, in this case, which will be `Some(i32)` when\n+we have a value and `None` once we run out. If we get `Some(i32)`, we print it\n out, and if we get `None`, we `break` out of the loop.\n \n This code sample is basically the same as our `for` loop version. The `for`\n@@ -4460,7 +4458,7 @@ primitive. For example, if you needed to iterate over the contents of\n a vector, you may be tempted to write this:\n \n ```{rust}\n-let nums = vec![1i, 2i, 3i];\n+let nums = vec![1, 2, 3];\n \n for i in range(0u, nums.len()) {\n     println!(\"{}\", nums[i]);\n@@ -4472,7 +4470,7 @@ vectors returns an iterator that iterates through a reference to each element\n of the vector in turn. So write this:\n \n ```{rust}\n-let nums = vec![1i, 2i, 3i];\n+let nums = vec![1, 2, 3];\n \n for num in nums.iter() {\n     println!(\"{}\", num);\n@@ -4489,12 +4487,12 @@ very common with iterators: we can ignore unnecessary bounds checks, but still\n know that we're safe.\n \n There's another detail here that's not 100% clear because of how `println!`\n-works. `num` is actually of type `&int`. That is, it's a reference to an `int`,\n-not an `int` itself. `println!` handles the dereferencing for us, so we don't\n+works. `num` is actually of type `&i32`. That is, it's a reference to an `i32`,\n+not an `i32` itself. `println!` handles the dereferencing for us, so we don't\n see it. This code works fine too:\n \n ```{rust}\n-let nums = vec![1i, 2i, 3i];\n+let nums = vec![1, 2, 3];\n \n for num in nums.iter() {\n     println!(\"{}\", *num);\n@@ -4528,7 +4526,7 @@ The most common consumer is `collect()`. This code doesn't quite compile,\n but it shows the intention:\n \n ```{rust,ignore}\n-let one_to_one_hundred = range(1i, 101i).collect();\n+let one_to_one_hundred = range(1, 101).collect();\n ```\n \n As you can see, we call `collect()` on our iterator. `collect()` takes\n@@ -4538,7 +4536,7 @@ type of things you want to collect, and so you need to let it know.\n Here's the version that does compile:\n \n ```{rust}\n-let one_to_one_hundred = range(1i, 101i).collect::<Vec<int>>();\n+let one_to_one_hundred = range(1, 101).collect::<Vec<i32>>();\n ```\n \n If you remember, the `::<>` syntax allows us to give a type hint,\n@@ -4548,7 +4546,7 @@ and so we tell it that we want a vector of integers.\n is one:\n \n ```{rust}\n-let greater_than_forty_two = range(0i, 100i)\n+let greater_than_forty_two = range(0, 100)\n                              .find(|x| *x > 42);\n \n match greater_than_forty_two {\n@@ -4565,8 +4563,8 @@ element, `find` returns an `Option` rather than the element itself.\n Another important consumer is `fold`. Here's what it looks like:\n \n ```{rust}\n-let sum = range(1i, 4i)\n-              .fold(0i, |sum, x| sum + x);\n+let sum = range(1, 4)\n+              .fold(0, |sum, x| sum + x);\n ```\n \n `fold()` is a consumer that looks like this:\n@@ -4582,24 +4580,24 @@ in this iterator:\n \n | base | accumulator | element | closure result |\n |------|-------------|---------|----------------|\n-| 0i   | 0i          | 1i      | 1i             |\n-| 0i   | 1i          | 2i      | 3i             |\n-| 0i   | 3i          | 3i      | 6i             |\n+| 0    | 0           | 1       | 1              |\n+| 0    | 1           | 2       | 3              |\n+| 0    | 3           | 3       | 6              |\n \n We called `fold()` with these arguments:\n \n ```{rust}\n-# range(1i, 4i)\n-.fold(0i, |sum, x| sum + x);\n+# range(1, 4)\n+.fold(0, |sum, x| sum + x);\n ```\n \n-So, `0i` is our base, `sum` is our accumulator, and `x` is our element.  On the\n-first iteration, we set `sum` to `0i`, and `x` is the first element of `nums`,\n-`1i`. We then add `sum` and `x`, which gives us `0i + 1i = 1i`. On the second\n+So, `0` is our base, `sum` is our accumulator, and `x` is our element.  On the\n+first iteration, we set `sum` to `0`, and `x` is the first element of `nums`,\n+`1`. We then add `sum` and `x`, which gives us `0 + 1 = 1`. On the second\n iteration, that value becomes our accumulator, `sum`, and the element is\n-the second element of the array, `2i`. `1i + 2i = 3i`, and so that becomes\n+the second element of the array, `2`. `1 + 2 = 3`, and so that becomes\n the value of the accumulator for the last iteration. On that iteration,\n-`x` is the last element, `3i`, and `3i + 3i = 6i`, which is our final\n+`x` is the last element, `3`, and `3 + 3 = 6`, which is our final\n result for our sum. `1 + 2 + 3 = 6`, and that's the result we got.\n \n Whew. `fold` can be a bit strange the first few times you see it, but once it\n@@ -4620,14 +4618,14 @@ This code, for example, does not actually generate the numbers\n `1-100`, and just creates a value that represents the sequence:\n \n ```{rust}\n-let nums = range(1i, 100i);\n+let nums = range(1, 100);\n ```\n \n Since we didn't do anything with the range, it didn't generate the sequence.\n Let's add the consumer:\n \n ```{rust}\n-let nums = range(1i, 100i).collect::<Vec<int>>();\n+let nums = range(1, 100).collect::<Vec<i32>>();\n ```\n \n Now, `collect()` will require that `range()` give it some numbers, and so\n@@ -4638,7 +4636,7 @@ which you've used before. `iter()` can turn a vector into a simple iterator\n that gives you each element in turn:\n \n ```{rust}\n-let nums = [1i, 2i, 3i];\n+let nums = [1, 2, 3];\n \n for num in nums.iter() {\n    println!(\"{}\", num);\n@@ -4649,12 +4647,12 @@ These two basic iterators should serve you well. There are some more\n advanced iterators, including ones that are infinite. Like `count`:\n \n ```{rust}\n-std::iter::count(1i, 5i);\n+std::iter::count(1, 5);\n ```\n \n This iterator counts up from one, adding five each time. It will give\n you a new integer every time, forever (well, technically, until it reaches the\n-maximum number representable by an `int`). But since iterators are lazy,\n+maximum number representable by an `i32`). But since iterators are lazy,\n that's okay! You probably don't want to use `collect()` on it, though...\n \n That's enough about iterators. Iterator adapters are the last concept\n@@ -4666,7 +4664,7 @@ we need to talk about with regards to iterators. Let's get to it!\n a new iterator. The simplest one is called `map`:\n \n ```{rust,ignore}\n-range(1i, 100i).map(|x| x + 1i);\n+range(1, 100).map(|x| x + 1);\n ```\n \n `map` is called upon another iterator, and produces a new iterator where each\n@@ -4677,15 +4675,15 @@ compile the example, you'll get a warning:\n ```text\n warning: unused result which must be used: iterator adaptors are lazy and\n          do nothing unless consumed, #[warn(unused_must_use)] on by default\n- range(1i, 100i).map(|x| x + 1i);\n+ range(1, 100).map(|x| x + 1);\n  ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n ```\n \n Laziness strikes again! That closure will never execute. This example\n doesn't print any numbers:\n \n ```{rust,ignore}\n-range(1i, 100i).map(|x| println!(\"{}\", x));\n+range(1, 100).map(|x| println!(\"{}\", x));\n ```\n \n If you are trying to execute a closure on an iterator for its side effects,\n@@ -4697,7 +4695,7 @@ has no side effect on the original iterator. Let's try it out with our infinite\n iterator from before, `count()`:\n \n ```{rust}\n-for i in std::iter::count(1i, 5i).take(5) {\n+for i in std::iter::count(1, 5).take(5) {\n     println!(\"{}\", i);\n }\n ```\n@@ -4717,7 +4715,7 @@ returns `true` or `false`. The new iterator `filter()` produces\n only the elements that that closure returns `true` for:\n \n ```{rust}\n-for i in range(1i, 100i).filter(|&x| x % 2 == 0) {\n+for i in range(1, 100).filter(|&x| x % 2 == 0) {\n     println!(\"{}\", i);\n }\n ```\n@@ -4732,11 +4730,11 @@ You can chain all three things together: start with an iterator, adapt it\n a few times, and then consume the result. Check it out:\n \n ```{rust}\n-range(1i, 1000i)\n+range(1, 1000)\n     .filter(|&x| x % 2 == 0)\n     .filter(|&x| x % 3 == 0)\n     .take(5)\n-    .collect::<Vec<int>>();\n+    .collect::<Vec<i32>>();\n ```\n \n This will give you a vector containing `6`, `12`, `18`, `24`, and `30`.\n@@ -4755,7 +4753,7 @@ multiple types of arguments. For example, remember our `OptionalInt` type?\n \n ```{rust}\n enum OptionalInt {\n-    Value(int),\n+    Value(i32),\n     Missing,\n }\n ```\n@@ -4788,30 +4786,30 @@ The `<T>` part, which you've seen a few times before, indicates that this is a\n generic data type. `T` is called a **type parameter**. When we create instances\n of `Option`, we need to provide a concrete type in place of the type\n parameter. For example, if we wanted something like our `OptionalInt`, we would\n-need to instantiate an `Option<int>`. Inside the declaration of our enum,\n+need to instantiate an `Option<i32>`. Inside the declaration of our enum,\n wherever we see a `T`, we replace it with the type specified (or inferred by the\n the compiler).\n \n ```{rust}\n-let x: Option<int> = Some(5i);\n+let x: Option<i32> = Some(5);\n ```\n \n-In this particular `Option`, `T` has the value of `int`. On the right-hand side\n-of the binding, we do make a `Some(T)`, where `T` is `5i`.  Since that's an\n-`int`, the two sides match, and Rust is happy. If they didn't match, we'd get an\n+In this particular `Option`, `T` has the value of `i32`. On the right-hand side\n+of the binding, we do make a `Some(T)`, where `T` is `5`.  Since that's an\n+`i32`, the two sides match, and Rust is happy. If they didn't match, we'd get an\n error:\n \n ```{rust,ignore}\n-let x: Option<f64> = Some(5i);\n+let x: Option<f64> = Some(5);\n // error: mismatched types: expected `core::option::Option<f64>`,\n-// found `core::option::Option<int>` (expected f64, found int)\n+// found `core::option::Option<i32>` (expected f64, found i32)\n ```\n \n That doesn't mean we can't make `Option<T>`s that hold an `f64`! They just have to\n match up:\n \n ```{rust}\n-let x: Option<int> = Some(5i);\n+let x: Option<i32> = Some(5);\n let y: Option<f64> = Some(5.0f64);\n ```\n \n@@ -5084,33 +5082,33 @@ As you can see, `print_area` is now generic, but also ensures that we\n have passed in the correct types. If we pass in an incorrect type:\n \n ```{rust,ignore}\n-print_area(5i);\n+print_area(5);\n ```\n \n We get a compile-time error:\n \n ```text\n-error: failed to find an implementation of trait main::HasArea for int\n+error: failed to find an implementation of trait main::HasArea for i32\n ```\n \n So far, we've only added trait implementations to structs, but you can\n implement a trait for any type. So technically, we _could_ implement\n-`HasArea` for `int`:\n+`HasArea` for `i32`:\n \n ```{rust}\n trait HasArea {\n     fn area(&self) -> f64;\n }\n \n-impl HasArea for int {\n+impl HasArea for i32 {\n     fn area(&self) -> f64 {\n         println!(\"this is silly\");\n \n         *self as f64\n     }\n }\n \n-5i.area();\n+5.area();\n ```\n \n It is considered poor style to implement methods on such primitive types, even\n@@ -5166,17 +5164,17 @@ fn main() {\n ```\n \n Requiring us to `use` traits whose methods we want means that even if someone\n-does something bad like add methods to `int`, it won't affect us, unless you\n+does something bad like add methods to `i32`, it won't affect us, unless you\n `use` that trait.\n \n The second condition allows us to `impl` built-in `trait`s for types we define,\n or allows us to `impl` our own `trait`s for built-in types, but restricts us\n from mixing and matching third party or built-in `impl`s with third party or\n built-in types.\n \n-We could `impl` the `HasArea` trait for `int`, because `HasArea` is in our\n+We could `impl` the `HasArea` trait for `i32`, because `HasArea` is in our\n crate. But if we tried to implement `Float`, a standard library `trait`, for\n-`int`, we could not, because neither the `trait` nor the `type` are in our\n+`i32`, we could not, because neither the `trait` nor the `type` are in our\n crate.\n \n ## Monomorphization\n@@ -5259,7 +5257,7 @@ touches.  This implies that those variables are not usable from the\n parent thread after the child thread is spawned:\n \n ```{rust,ignore}\n-let mut x = vec![1i, 2i, 3i];\n+let mut x = vec![1, 2, 3];\n \n spawn(move || {\n     println!(\"The value of x[0] is: {}\", x[0]);\n@@ -5333,7 +5331,7 @@ use std::sync::Future;\n let mut delayed_value = Future::spawn(move || {\n     // just return anything for examples' sake\n \n-    12345i\n+    12345\n });\n println!(\"value = {}\", delayed_value.get());\n ```\n@@ -5401,7 +5399,7 @@ a function, but it would be worse. Why? Well, what macros allow you to do\n is write code that generates more code. So when we call `println!` like this:\n \n ```{rust}\n-let x = 5i;\n+let x = 5;\n println!(\"x is: {}\", x);\n ```\n \n@@ -5421,7 +5419,7 @@ called `print.rs`:\n \n ```{rust}\n fn main() {\n-    let x = 5i;\n+    let x = 5;\n     println!(\"x is: {}\", x);\n }\n ```\n@@ -5439,7 +5437,7 @@ extern crate \"native\" as rt;\n #[prelude_import]\n use std::prelude::*;\n fn main() {\n-    let x = 5i;\n+    let x = 5;\n     match (&x,) {\n         (__arg0,) => {\n             #[inline]\n@@ -5457,7 +5455,7 @@ fn main() {\n }\n ```\n \n-Whew! This isn't too terrible. You can see that we still `let x = 5i`,\n+Whew! This isn't too terrible. You can see that we still `let x = 5`,\n but then things get a little bit hairy. Three more bindings get set: a\n static format string, an argument vector, and the arguments. We then\n invoke the `println_args` function with the generated arguments."}]}