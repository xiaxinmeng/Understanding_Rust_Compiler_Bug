{"sha": "06be5f7c44e255315a12f97b746307df82bb5390", "node_id": "MDY6Q29tbWl0NzI0NzEyOjA2YmU1ZjdjNDRlMjU1MzE1YTEyZjk3Yjc0NjMwN2RmODJiYjUzOTA=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-03-23T11:01:59Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-03-23T11:01:59Z"}, "message": "auto merge of #13092 : sfackler/rust/buffer-vec, r=thestinger\n\n`Vec` is now used for the internal buffer instead of `~[]`. Some module\r\nlevel documentation somehow ended up attached to `BufferedReader` so I\r\nfixed that as well.", "tree": {"sha": "bf2b3a50fc8d553e877774fc84b51974889307a2", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/bf2b3a50fc8d553e877774fc84b51974889307a2"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/06be5f7c44e255315a12f97b746307df82bb5390", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/06be5f7c44e255315a12f97b746307df82bb5390", "html_url": "https://github.com/rust-lang/rust/commit/06be5f7c44e255315a12f97b746307df82bb5390", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/06be5f7c44e255315a12f97b746307df82bb5390/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "11c6817e13cf568167b7bffe66e528f1e8204635", "url": "https://api.github.com/repos/rust-lang/rust/commits/11c6817e13cf568167b7bffe66e528f1e8204635", "html_url": "https://github.com/rust-lang/rust/commit/11c6817e13cf568167b7bffe66e528f1e8204635"}, {"sha": "56cf09c69c65172e22ac612ead6335d152ece604", "url": "https://api.github.com/repos/rust-lang/rust/commits/56cf09c69c65172e22ac612ead6335d152ece604", "html_url": "https://github.com/rust-lang/rust/commit/56cf09c69c65172e22ac612ead6335d152ece604"}], "stats": {"total": 39, "additions": 24, "deletions": 15}, "files": [{"sha": "052d5df5ff76129c61381d824ee46a5ff738cef3", "filename": "src/libstd/io/buffered.rs", "status": "modified", "additions": 24, "deletions": 15, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/06be5f7c44e255315a12f97b746307df82bb5390/src%2Flibstd%2Fio%2Fbuffered.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06be5f7c44e255315a12f97b746307df82bb5390/src%2Flibstd%2Fio%2Fbuffered.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fbuffered.rs?ref=06be5f7c44e255315a12f97b746307df82bb5390", "patch": "@@ -19,13 +19,14 @@ use option::{Some, None, Option};\n use result::{Ok, Err};\n use slice::{OwnedVector, ImmutableVector, MutableVector};\n use slice;\n+use vec::Vec;\n \n /// Wraps a Reader and buffers input from it\n ///\n-/// It can be excessively inefficient to work directly with a `Reader` or\n-/// `Writer`. Every call to `read` or `write` on `TcpStream` results in a\n-/// system call, for example. This module provides structures that wrap\n-/// `Readers`, `Writers`, and `Streams` and buffer input and output to them.\n+/// It can be excessively inefficient to work directly with a `Reader`. For\n+/// example, every call to `read` on `TcpStream` results in a system call. A\n+/// `BufferedReader` performs large, infrequent reads on the underlying\n+/// `Reader` and maintains an in-memory buffer of the results.\n ///\n /// # Example\n ///\n@@ -43,10 +44,9 @@ use slice;\n /// ```\n pub struct BufferedReader<R> {\n     priv inner: R,\n-    priv buf: ~[u8],\n+    priv buf: Vec<u8>,\n     priv pos: uint,\n     priv cap: uint,\n-    priv eof: bool,\n }\n \n impl<R: Reader> BufferedReader<R> {\n@@ -58,14 +58,13 @@ impl<R: Reader> BufferedReader<R> {\n         // everything up-front. This allows creation of BufferedReader instances\n         // to be very cheap (large mallocs are not nearly as expensive as large\n         // callocs).\n-        let mut buf = slice::with_capacity(cap);\n+        let mut buf = Vec::with_capacity(cap);\n         unsafe { buf.set_len(cap); }\n         BufferedReader {\n             inner: inner,\n             buf: buf,\n             pos: 0,\n             cap: 0,\n-            eof: false,\n         }\n     }\n \n@@ -80,7 +79,7 @@ impl<R: Reader> BufferedReader<R> {\n     /// underlying reader because that could possibly corrupt the buffer.\n     pub fn get_ref<'a>(&'a self) -> &'a R { &self.inner }\n \n-    /// Unwraps this buffer, returning the underlying reader.\n+    /// Unwraps this `BufferedReader`, returning the underlying reader.\n     ///\n     /// Note that any leftover data in the internal buffer is lost.\n     pub fn unwrap(self) -> R { self.inner }\n@@ -89,7 +88,7 @@ impl<R: Reader> BufferedReader<R> {\n impl<R: Reader> Buffer for BufferedReader<R> {\n     fn fill<'a>(&'a mut self) -> IoResult<&'a [u8]> {\n         if self.pos == self.cap {\n-            self.cap = try!(self.inner.read(self.buf));\n+            self.cap = try!(self.inner.read(self.buf.as_mut_slice()));\n             self.pos = 0;\n         }\n         Ok(self.buf.slice(self.pos, self.cap))\n@@ -116,6 +115,11 @@ impl<R: Reader> Reader for BufferedReader<R> {\n \n /// Wraps a Writer and buffers output to it\n ///\n+/// It can be excessively inefficient to work directly with a `Writer`. For\n+/// example, every call to `write` on `TcpStream` results in a system call. A\n+/// `BufferedWriter` keeps an in memory buffer of data and writes it to the\n+/// underlying `Writer` in large, infrequent batches.\n+///\n /// This writer will be flushed when it is dropped.\n ///\n /// # Example\n@@ -132,15 +136,15 @@ impl<R: Reader> Reader for BufferedReader<R> {\n /// ```\n pub struct BufferedWriter<W> {\n     priv inner: Option<W>,\n-    priv buf: ~[u8],\n+    priv buf: Vec<u8>,\n     priv pos: uint\n }\n \n impl<W: Writer> BufferedWriter<W> {\n     /// Creates a new `BufferedWriter` with the specified buffer capacity\n     pub fn with_capacity(cap: uint, inner: W) -> BufferedWriter<W> {\n         // See comments in BufferedReader for why this uses unsafe code.\n-        let mut buf = slice::with_capacity(cap);\n+        let mut buf = Vec::with_capacity(cap);\n         unsafe { buf.set_len(cap); }\n         BufferedWriter {\n             inner: Some(inner),\n@@ -170,7 +174,7 @@ impl<W: Writer> BufferedWriter<W> {\n     /// underlying reader because that could possibly corrupt the buffer.\n     pub fn get_ref<'a>(&'a self) -> &'a W { self.inner.get_ref() }\n \n-    /// Unwraps this buffer, returning the underlying writer.\n+    /// Unwraps this `BufferedWriter`, returning the underlying writer.\n     ///\n     /// The buffer is flushed before returning the writer.\n     pub fn unwrap(mut self) -> W {\n@@ -234,7 +238,7 @@ impl<W: Writer> LineBufferedWriter<W> {\n     /// underlying reader because that could possibly corrupt the buffer.\n     pub fn get_ref<'a>(&'a self) -> &'a W { self.inner.get_ref() }\n \n-    /// Unwraps this buffer, returning the underlying writer.\n+    /// Unwraps this `LineBufferedWriter`, returning the underlying writer.\n     ///\n     /// The internal buffer is flushed before returning the writer.\n     pub fn unwrap(self) -> W { self.inner.unwrap() }\n@@ -273,6 +277,11 @@ impl<W: Reader> Reader for InternalBufferedWriter<W> {\n \n /// Wraps a Stream and buffers input and output to and from it.\n ///\n+/// It can be excessively inefficient to work directly with a `Stream`. For\n+/// example, every call to `read` or `write` on `TcpStream` results in a system\n+/// call. A `BufferedStream` keeps in memory buffers of data, making large,\n+/// infrequent calls to `read` and `write` on the underlying `Stream`.\n+///\n /// The output half will be flushed when this stream is dropped.\n ///\n /// # Example\n@@ -325,7 +334,7 @@ impl<S: Stream> BufferedStream<S> {\n         w.get_ref()\n     }\n \n-    /// Unwraps this buffer, returning the underlying stream.\n+    /// Unwraps this `BufferedStream`, returning the underlying stream.\n     ///\n     /// The internal buffer is flushed before returning the stream. Any leftover\n     /// data in the read buffer is lost."}]}