{"sha": "3baf5f8d9a453767e349c2c080a907ee4100e8df", "node_id": "C_kwDOAAsO6NoAKDNiYWY1ZjhkOWE0NTM3NjdlMzQ5YzJjMDgwYTkwN2VlNDEwMGU4ZGY", "commit": {"author": {"name": "Matthias Kr\u00fcger", "email": "matthias.krueger@famsik.de", "date": "2022-09-24T05:38:53Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2022-09-24T05:38:53Z"}, "message": "Rollup merge of #102044 - ChrisDenton:BCrypt-system-rand, r=thomcc\n\nRemove `RtlGenRandom` (take two)\n\nFirst try to use the system preferred RNG but if that fails (e.g. due to a broken system configuration) then fallback to manually opening an algorithm handle.", "tree": {"sha": "87869e78b6e74040dd305562f381f62d0a08a0c9", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/87869e78b6e74040dd305562f381f62d0a08a0c9"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3baf5f8d9a453767e349c2c080a907ee4100e8df", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJjLpftCRBK7hj4Ov3rIwAAQHkIAFL/nea3fjtgYZOxrRHLpO3j\nW4sfqO6eXj+EsR/67sfnS6+Tavfa8HllggEeP6YVs87gdQlPqKZY4E1QYTsayyv9\ncMdviW/wr++YsUSNYFRhxUsxfFXqzNnd9jfC+ghqbcv1T1AUuo8uU/ZozOU4HQn0\nUEcNO/nZWQJPHXYF01wRMgD1CBY3lEsKHct7bBqPZLyK10nSEm39znpqSFzRqM8u\n7umMrQKtazwDnbffINW80UpmVC5vR3X35cZ1MquoZdYu0idxJA4dcvah+heo89z9\nu5zX/Am4EgIBUMMlcUE464os5sI59rmEIFCNMIKtcOmj970vJqHtF3Y6ZZ5IjZw=\n=UPVh\n-----END PGP SIGNATURE-----\n", "payload": "tree 87869e78b6e74040dd305562f381f62d0a08a0c9\nparent 6fff4d9cfd393c344e1e5ba023ffd241838cd26a\nparent 8ca6a272bdc12f0b2e1942d325cd1022117514f1\nauthor Matthias Kr\u00fcger <matthias.krueger@famsik.de> 1663997933 +0200\ncommitter GitHub <noreply@github.com> 1663997933 +0200\n\nRollup merge of #102044 - ChrisDenton:BCrypt-system-rand, r=thomcc\n\nRemove `RtlGenRandom` (take two)\n\nFirst try to use the system preferred RNG but if that fails (e.g. due to a broken system configuration) then fallback to manually opening an algorithm handle.\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3baf5f8d9a453767e349c2c080a907ee4100e8df", "html_url": "https://github.com/rust-lang/rust/commit/3baf5f8d9a453767e349c2c080a907ee4100e8df", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3baf5f8d9a453767e349c2c080a907ee4100e8df/comments", "author": {"login": "matthiaskrgr", "id": 476013, "node_id": "MDQ6VXNlcjQ3NjAxMw==", "avatar_url": "https://avatars.githubusercontent.com/u/476013?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matthiaskrgr", "html_url": "https://github.com/matthiaskrgr", "followers_url": "https://api.github.com/users/matthiaskrgr/followers", "following_url": "https://api.github.com/users/matthiaskrgr/following{/other_user}", "gists_url": "https://api.github.com/users/matthiaskrgr/gists{/gist_id}", "starred_url": "https://api.github.com/users/matthiaskrgr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matthiaskrgr/subscriptions", "organizations_url": "https://api.github.com/users/matthiaskrgr/orgs", "repos_url": "https://api.github.com/users/matthiaskrgr/repos", "events_url": "https://api.github.com/users/matthiaskrgr/events{/privacy}", "received_events_url": "https://api.github.com/users/matthiaskrgr/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6fff4d9cfd393c344e1e5ba023ffd241838cd26a", "url": "https://api.github.com/repos/rust-lang/rust/commits/6fff4d9cfd393c344e1e5ba023ffd241838cd26a", "html_url": "https://github.com/rust-lang/rust/commit/6fff4d9cfd393c344e1e5ba023ffd241838cd26a"}, {"sha": "8ca6a272bdc12f0b2e1942d325cd1022117514f1", "url": "https://api.github.com/repos/rust-lang/rust/commits/8ca6a272bdc12f0b2e1942d325cd1022117514f1", "html_url": "https://github.com/rust-lang/rust/commit/8ca6a272bdc12f0b2e1942d325cd1022117514f1"}], "stats": {"total": 82, "additions": 29, "deletions": 53}, "files": [{"sha": "c61a7e7d1e4abf38c21b00827000f810f8a2e633", "filename": "library/std/src/sys/windows/c.rs", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/3baf5f8d9a453767e349c2c080a907ee4100e8df/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3baf5f8d9a453767e349c2c080a907ee4100e8df/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fc.rs?ref=3baf5f8d9a453767e349c2c080a907ee4100e8df", "patch": "@@ -279,7 +279,6 @@ pub const STATUS_INVALID_PARAMETER: NTSTATUS = 0xc000000d_u32 as _;\n pub const STATUS_PENDING: NTSTATUS = 0x103 as _;\n pub const STATUS_END_OF_FILE: NTSTATUS = 0xC0000011_u32 as _;\n pub const STATUS_NOT_IMPLEMENTED: NTSTATUS = 0xC0000002_u32 as _;\n-pub const STATUS_NOT_SUPPORTED: NTSTATUS = 0xC00000BB_u32 as _;\n \n // Equivalent to the `NT_SUCCESS` C preprocessor macro.\n // See: https://docs.microsoft.com/en-us/windows-hardware/drivers/kernel/using-ntstatus-values\n@@ -289,6 +288,7 @@ pub fn nt_success(status: NTSTATUS) -> bool {\n \n // \"RNG\\0\"\n pub const BCRYPT_RNG_ALGORITHM: &[u16] = &[b'R' as u16, b'N' as u16, b'G' as u16, 0];\n+pub const BCRYPT_USE_SYSTEM_PREFERRED_RNG: DWORD = 0x00000002;\n \n #[repr(C)]\n pub struct UNICODE_STRING {\n@@ -817,10 +817,6 @@ if #[cfg(not(target_vendor = \"uwp\"))] {\n \n     #[link(name = \"advapi32\")]\n     extern \"system\" {\n-        // Forbidden when targeting UWP\n-        #[link_name = \"SystemFunction036\"]\n-        pub fn RtlGenRandom(RandomBuffer: *mut u8, RandomBufferLength: ULONG) -> BOOLEAN;\n-\n         // Allowed but unused by UWP\n         pub fn OpenProcessToken(\n             ProcessHandle: HANDLE,"}, {"sha": "b5a49489d3fb839cded5cb55d6c61524ba5b5d1c", "filename": "library/std/src/sys/windows/rand.rs", "status": "modified", "additions": 28, "deletions": 48, "changes": 76, "blob_url": "https://github.com/rust-lang/rust/blob/3baf5f8d9a453767e349c2c080a907ee4100e8df/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Frand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3baf5f8d9a453767e349c2c080a907ee4100e8df/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Frand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Frand.rs?ref=3baf5f8d9a453767e349c2c080a907ee4100e8df", "patch": "@@ -13,15 +13,12 @@\n //! but significant number of users to experience panics caused by a failure of\n //! this function. See [#94098].\n //!\n-//! The current version changes this to use the `BCRYPT_RNG_ALG_HANDLE`\n-//! [Pseudo-handle], which gets the default RNG algorithm without querying the\n-//! system preference thus hopefully avoiding the previous issue.\n-//! This is only supported on Windows 10+ so a fallback is used for older versions.\n+//! The current version falls back to using `BCryptOpenAlgorithmProvider` if\n+//! `BCRYPT_USE_SYSTEM_PREFERRED_RNG` fails for any reason.\n //!\n //! [#94098]: https://github.com/rust-lang/rust/issues/94098\n //! [`RtlGenRandom`]: https://docs.microsoft.com/en-us/windows/win32/api/ntsecapi/nf-ntsecapi-rtlgenrandom\n //! [`BCryptGenRandom`]: https://docs.microsoft.com/en-us/windows/win32/api/bcrypt/nf-bcrypt-bcryptgenrandom\n-//! [Pseudo-handle]: https://docs.microsoft.com/en-us/windows/win32/seccng/cng-algorithm-pseudo-handles\n use crate::mem;\n use crate::ptr;\n use crate::sys::c;\n@@ -33,37 +30,35 @@ use crate::sys::c;\n /// [`HashMap`]: crate::collections::HashMap\n /// [`RandomState`]: crate::collections::hash_map::RandomState\n pub fn hashmap_random_keys() -> (u64, u64) {\n-    Rng::open().and_then(|rng| rng.gen_random_keys()).unwrap_or_else(fallback_rng)\n+    Rng::SYSTEM.gen_random_keys().unwrap_or_else(fallback_rng)\n }\n \n-struct Rng(c::BCRYPT_ALG_HANDLE);\n+struct Rng {\n+    algorithm: c::BCRYPT_ALG_HANDLE,\n+    flags: u32,\n+}\n impl Rng {\n-    #[cfg(miri)]\n-    fn open() -> Result<Self, c::NTSTATUS> {\n-        const BCRYPT_RNG_ALG_HANDLE: c::BCRYPT_ALG_HANDLE = ptr::invalid_mut(0x81);\n-        let _ = (\n-            c::BCryptOpenAlgorithmProvider,\n-            c::BCryptCloseAlgorithmProvider,\n-            c::BCRYPT_RNG_ALGORITHM,\n-            c::STATUS_NOT_SUPPORTED,\n-        );\n-        Ok(Self(BCRYPT_RNG_ALG_HANDLE))\n+    const SYSTEM: Self = unsafe { Self::new(ptr::null_mut(), c::BCRYPT_USE_SYSTEM_PREFERRED_RNG) };\n+\n+    /// Create the RNG from an existing algorithm handle.\n+    ///\n+    /// # Safety\n+    ///\n+    /// The handle must either be null or a valid algorithm handle.\n+    const unsafe fn new(algorithm: c::BCRYPT_ALG_HANDLE, flags: u32) -> Self {\n+        Self { algorithm, flags }\n     }\n-    #[cfg(not(miri))]\n-    // Open a handle to the RNG algorithm.\n+\n+    /// Open a handle to the RNG algorithm.\n     fn open() -> Result<Self, c::NTSTATUS> {\n         use crate::sync::atomic::AtomicPtr;\n         use crate::sync::atomic::Ordering::{Acquire, Release};\n-        const ERROR_VALUE: c::LPVOID = ptr::invalid_mut(usize::MAX);\n \n         // An atomic is used so we don't need to reopen the handle every time.\n         static HANDLE: AtomicPtr<crate::ffi::c_void> = AtomicPtr::new(ptr::null_mut());\n \n         let mut handle = HANDLE.load(Acquire);\n-        // We use a sentinel value to designate an error occurred last time.\n-        if handle == ERROR_VALUE {\n-            Err(c::STATUS_NOT_SUPPORTED)\n-        } else if handle.is_null() {\n+        if handle.is_null() {\n             let status = unsafe {\n                 c::BCryptOpenAlgorithmProvider(\n                     &mut handle,\n@@ -80,47 +75,32 @@ impl Rng {\n                     unsafe { c::BCryptCloseAlgorithmProvider(handle, 0) };\n                     handle = previous_handle;\n                 }\n-                Ok(Self(handle))\n+                Ok(unsafe { Self::new(handle, 0) })\n             } else {\n-                HANDLE.store(ERROR_VALUE, Release);\n                 Err(status)\n             }\n         } else {\n-            Ok(Self(handle))\n+            Ok(unsafe { Self::new(handle, 0) })\n         }\n     }\n \n     fn gen_random_keys(self) -> Result<(u64, u64), c::NTSTATUS> {\n         let mut v = (0, 0);\n         let status = unsafe {\n             let size = mem::size_of_val(&v).try_into().unwrap();\n-            c::BCryptGenRandom(self.0, ptr::addr_of_mut!(v).cast(), size, 0)\n+            c::BCryptGenRandom(self.algorithm, ptr::addr_of_mut!(v).cast(), size, self.flags)\n         };\n         if c::nt_success(status) { Ok(v) } else { Err(status) }\n     }\n }\n \n-/// Generate random numbers using the fallback RNG function (RtlGenRandom)\n-#[cfg(not(target_vendor = \"uwp\"))]\n+/// Generate random numbers using the fallback RNG function\n #[inline(never)]\n fn fallback_rng(rng_status: c::NTSTATUS) -> (u64, u64) {\n-    let mut v = (0, 0);\n-    let ret =\n-        unsafe { c::RtlGenRandom(&mut v as *mut _ as *mut u8, mem::size_of_val(&v) as c::ULONG) };\n-\n-    if ret != 0 {\n-        v\n-    } else {\n-        panic!(\n-            \"RNG broken: {rng_status:#x}, fallback RNG broken: {}\",\n-            crate::io::Error::last_os_error()\n-        )\n+    match Rng::open().and_then(|rng| rng.gen_random_keys()) {\n+        Ok(keys) => keys,\n+        Err(status) => {\n+            panic!(\"RNG broken: {rng_status:#x}, fallback RNG broken: {status:#x}\")\n+        }\n     }\n }\n-\n-/// We can't use RtlGenRandom with UWP, so there is no fallback\n-#[cfg(target_vendor = \"uwp\")]\n-#[inline(never)]\n-fn fallback_rng(rng_status: c::NTSTATUS) -> (u64, u64) {\n-    panic!(\"RNG broken: {rng_status:#x} fallback RNG broken: RtlGenRandom() not supported on UWP\");\n-}"}]}