{"sha": "47f0e91689403c8472dc63e58e735f42251427ab", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQ3ZjBlOTE2ODk0MDNjODQ3MmRjNjNlNThlNzM1ZjQyMjUxNDI3YWI=", "commit": {"author": {"name": "Jeff Olson", "email": "olson.jeffery@gmail.com", "date": "2013-08-19T23:10:43Z"}, "committer": {"name": "Jeff Olson", "email": "olson.jeffery@gmail.com", "date": "2013-08-22T23:31:57Z"}, "message": "std: CRUD file io bindings in uvio, fs_open()/unlink() in IoFactory + test", "tree": {"sha": "b74707b170483a9684054586a336d3e130504bee", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b74707b170483a9684054586a336d3e130504bee"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/47f0e91689403c8472dc63e58e735f42251427ab", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/47f0e91689403c8472dc63e58e735f42251427ab", "html_url": "https://github.com/rust-lang/rust/commit/47f0e91689403c8472dc63e58e735f42251427ab", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/47f0e91689403c8472dc63e58e735f42251427ab/comments", "author": {"login": "olsonjeffery", "id": 10408, "node_id": "MDQ6VXNlcjEwNDA4", "avatar_url": "https://avatars.githubusercontent.com/u/10408?v=4", "gravatar_id": "", "url": "https://api.github.com/users/olsonjeffery", "html_url": "https://github.com/olsonjeffery", "followers_url": "https://api.github.com/users/olsonjeffery/followers", "following_url": "https://api.github.com/users/olsonjeffery/following{/other_user}", "gists_url": "https://api.github.com/users/olsonjeffery/gists{/gist_id}", "starred_url": "https://api.github.com/users/olsonjeffery/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/olsonjeffery/subscriptions", "organizations_url": "https://api.github.com/users/olsonjeffery/orgs", "repos_url": "https://api.github.com/users/olsonjeffery/repos", "events_url": "https://api.github.com/users/olsonjeffery/events{/privacy}", "received_events_url": "https://api.github.com/users/olsonjeffery/received_events", "type": "User", "site_admin": false}, "committer": {"login": "olsonjeffery", "id": 10408, "node_id": "MDQ6VXNlcjEwNDA4", "avatar_url": "https://avatars.githubusercontent.com/u/10408?v=4", "gravatar_id": "", "url": "https://api.github.com/users/olsonjeffery", "html_url": "https://github.com/olsonjeffery", "followers_url": "https://api.github.com/users/olsonjeffery/followers", "following_url": "https://api.github.com/users/olsonjeffery/following{/other_user}", "gists_url": "https://api.github.com/users/olsonjeffery/gists{/gist_id}", "starred_url": "https://api.github.com/users/olsonjeffery/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/olsonjeffery/subscriptions", "organizations_url": "https://api.github.com/users/olsonjeffery/orgs", "repos_url": "https://api.github.com/users/olsonjeffery/repos", "events_url": "https://api.github.com/users/olsonjeffery/events{/privacy}", "received_events_url": "https://api.github.com/users/olsonjeffery/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f60bd75f4d8b776cf1e777b59d2d2262d03818a7", "url": "https://api.github.com/repos/rust-lang/rust/commits/f60bd75f4d8b776cf1e777b59d2d2262d03818a7", "html_url": "https://github.com/rust-lang/rust/commit/f60bd75f4d8b776cf1e777b59d2d2262d03818a7"}], "stats": {"total": 190, "additions": 190, "deletions": 0}, "files": [{"sha": "1095104773d1d1679c1799d1e9ac31021ef4c365", "filename": "src/libstd/rt/rtio.rs", "status": "modified", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/47f0e91689403c8472dc63e58e735f42251427ab/src%2Flibstd%2Frt%2Frtio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/47f0e91689403c8472dc63e58e735f42251427ab/src%2Flibstd%2Frt%2Frtio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Frtio.rs?ref=47f0e91689403c8472dc63e58e735f42251427ab", "patch": "@@ -10,10 +10,12 @@\n \n use option::*;\n use result::*;\n+use libc::c_int;\n \n use rt::io::IoError;\n use super::io::net::ip::{IpAddr, SocketAddr};\n use rt::uv::uvio;\n+use path::Path;\n \n // XXX: ~object doesn't work currently so these are some placeholder\n // types to use instead\n@@ -46,11 +48,27 @@ pub trait RemoteCallback {\n     fn fire(&mut self);\n }\n \n+/// Data needed to make a successful open(2) call\n+/// Using unix flag conventions for now, which happens to also be what's supported\n+/// libuv (it does translation to windows under the hood).\n+pub struct FileOpenConfig {\n+    /// Path to file to be opened\n+    path: Path,\n+    /// Flags for file access mode (as per open(2))\n+    flags: int,\n+    /// File creation mode, ignored unless O_CREAT is passed as part of flags\n+    mode: int\n+}\n+\n pub trait IoFactory {\n     fn tcp_connect(&mut self, addr: SocketAddr) -> Result<~RtioTcpStreamObject, IoError>;\n     fn tcp_bind(&mut self, addr: SocketAddr) -> Result<~RtioTcpListenerObject, IoError>;\n     fn udp_bind(&mut self, addr: SocketAddr) -> Result<~RtioUdpSocketObject, IoError>;\n     fn timer_init(&mut self) -> Result<~RtioTimerObject, IoError>;\n+    fn fs_from_raw_fd(&mut self, fd: c_int, close_on_drop: bool) -> ~RtioFileDescriptor;\n+    fn fs_open(&mut self, path: Path, flags: int, mode:int)\n+        -> Result<~RtioFileDescriptor, IoError>;\n+    fn fs_unlink(&mut self, path: Path) -> Result<(), IoError>;\n }\n \n pub trait RtioTcpListener : RtioSocket {\n@@ -93,3 +111,8 @@ pub trait RtioUdpSocket : RtioSocket {\n pub trait RtioTimer {\n     fn sleep(&mut self, msecs: u64);\n }\n+\n+pub trait RtioFileDescriptor {\n+    fn read(&mut self, buf: &mut [u8], offset: i64) -> Result<int, IoError>;\n+    fn write(&mut self, buf: &[u8], offset: i64) -> Result<(), IoError>;\n+}"}, {"sha": "913b19ec38f99c52fa29860383ddc10aaedb8c47", "filename": "src/libstd/rt/uv/uvio.rs", "status": "modified", "additions": 167, "deletions": 0, "changes": 167, "blob_url": "https://github.com/rust-lang/rust/blob/47f0e91689403c8472dc63e58e735f42251427ab/src%2Flibstd%2Frt%2Fuv%2Fuvio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/47f0e91689403c8472dc63e58e735f42251427ab/src%2Flibstd%2Frt%2Fuv%2Fuvio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fuv%2Fuvio.rs?ref=47f0e91689403c8472dc63e58e735f42251427ab", "patch": "@@ -17,6 +17,8 @@ use libc::{c_int, c_uint, c_void};\n use ops::Drop;\n use option::*;\n use ptr;\n+use str;\n+use path::Path;\n use result::*;\n use rt::io::IoError;\n use rt::io::net::ip::{SocketAddr, IpAddr};\n@@ -455,6 +457,68 @@ impl IoFactory for UvIoFactory {\n         let home = get_handle_to_current_scheduler!();\n         Ok(~UvTimer::new(watcher, home))\n     }\n+\n+    fn fs_from_raw_fd(&mut self, fd: c_int, close_on_drop: bool) -> ~RtioFileDescriptor {\n+        ~UvFileDescriptor {\n+            loop_: Loop{handle:self.uv_loop().native_handle()},\n+            fd: file::FileDescriptor(fd),\n+            close_on_drop: close_on_drop\n+        } as ~RtioFileDescriptor\n+    }\n+\n+    fn fs_open(&mut self, path: Path, flags: int, mode: int)\n+        -> Result<~RtioFileDescriptor, IoError> {\n+        let loop_ = Loop {handle: self.uv_loop().native_handle()};\n+        let result_cell = Cell::new_empty();\n+        let result_cell_ptr: *Cell<Result<~RtioFileDescriptor, IoError>> = &result_cell;\n+        let path_cell = Cell::new(path);\n+        let scheduler = Local::take::<Scheduler>();\n+        do scheduler.deschedule_running_task_and_then |_, task| {\n+            let task_cell = Cell::new(task);\n+            let path = path_cell.take();\n+            do file::FileDescriptor::open(loop_, path, flags, mode) |req,err| {\n+                if err.is_none() {\n+                    let res = Ok(~UvFileDescriptor {\n+                        loop_: loop_,\n+                        fd: file::FileDescriptor(req.get_result()),\n+                        close_on_drop: true} as ~RtioFileDescriptor);\n+                    unsafe { (*result_cell_ptr).put_back(res); }\n+                    let scheduler = Local::take::<Scheduler>();\n+                    scheduler.resume_blocked_task_immediately(task_cell.take());\n+                } else {\n+                    let res = Err(uv_error_to_io_error(err.unwrap()));\n+                    unsafe { (*result_cell_ptr).put_back(res); }\n+                    let scheduler = Local::take::<Scheduler>();\n+                    scheduler.resume_blocked_task_immediately(task_cell.take());\n+                }\n+            };\n+        };\n+        assert!(!result_cell.is_empty());\n+        return result_cell.take();\n+    }\n+\n+    fn fs_unlink(&mut self, path: Path) -> Result<(), IoError> {\n+        let loop_ = Loop {handle: self.uv_loop().native_handle()};\n+        let result_cell = Cell::new_empty();\n+        let result_cell_ptr: *Cell<Result<(), IoError>> = &result_cell;\n+        let path_cell = Cell::new(path);\n+        let scheduler = Local::take::<Scheduler>();\n+        do scheduler.deschedule_running_task_and_then |_, task| {\n+            let task_cell = Cell::new(task);\n+            let path = path_cell.take();\n+            do file::FileDescriptor::unlink(loop_, path) |_, err| {\n+                let res = match err {\n+                    None => Ok(()),\n+                    Some(err) => Err(uv_error_to_io_error(err))\n+                };\n+                unsafe { (*result_cell_ptr).put_back(res); }\n+                let scheduler = Local::take::<Scheduler>();\n+                scheduler.resume_blocked_task_immediately(task_cell.take());\n+            };\n+        };\n+        assert!(!result_cell.is_empty());\n+        return result_cell.take();\n+    }\n }\n \n pub struct UvTcpListener {\n@@ -992,6 +1056,73 @@ impl RtioTimer for UvTimer {\n     }\n }\n \n+pub struct UvFileDescriptor {\n+    loop_: Loop,\n+    fd: file::FileDescriptor,\n+    close_on_drop: bool\n+}\n+\n+impl UvFileDescriptor {\n+}\n+\n+impl Drop for UvFileDescriptor {\n+    fn drop(&self) {\n+        if self.close_on_drop {\n+            let scheduler = Local::take::<Scheduler>();\n+            do scheduler.deschedule_running_task_and_then |_, task| {\n+                let task_cell = Cell::new(task);\n+                do self.fd.close(self.loop_) |_,_| {\n+                    let scheduler = Local::take::<Scheduler>();\n+                    scheduler.resume_blocked_task_immediately(task_cell.take());\n+                };\n+            };\n+        }\n+    }\n+}\n+\n+impl RtioFileDescriptor for UvFileDescriptor {\n+    fn read(&mut self, buf: &mut [u8], offset: i64) -> Result<int, IoError> {\n+        let scheduler = Local::take::<Scheduler>();\n+        let result_cell = Cell::new_empty();\n+        let result_cell_ptr: *Cell<Result<int, IoError>> = &result_cell;\n+        let buf_ptr: *&mut [u8] = &buf;\n+        do scheduler.deschedule_running_task_and_then |_, task| {\n+            let buf = unsafe { slice_to_uv_buf(*buf_ptr) };\n+            let task_cell = Cell::new(task);\n+            do self.fd.read(self.loop_, buf, offset) |req, uverr| {\n+                let res = match uverr  {\n+                    None => Ok(req.get_result() as int),\n+                    Some(err) => Err(uv_error_to_io_error(err))\n+                };\n+                unsafe { (*result_cell_ptr).put_back(res); }\n+                let scheduler = Local::take::<Scheduler>();\n+                scheduler.resume_blocked_task_immediately(task_cell.take());\n+            };\n+        };\n+        result_cell.take()\n+    }\n+    fn write(&mut self, buf: &[u8], offset: i64) -> Result<(), IoError> {\n+        let scheduler = Local::take::<Scheduler>();\n+        let result_cell = Cell::new_empty();\n+        let result_cell_ptr: *Cell<Result<(), IoError>> = &result_cell;\n+        let buf_ptr: *&[u8] = &buf;\n+        do scheduler.deschedule_running_task_and_then |_, task| {\n+            let buf = unsafe { slice_to_uv_buf(*buf_ptr) };\n+            let task_cell = Cell::new(task);\n+            do self.fd.write(self.loop_, buf, offset) |_, uverr| {\n+                let res = match uverr  {\n+                    None => Ok(()),\n+                    Some(err) => Err(uv_error_to_io_error(err))\n+                };\n+                unsafe { (*result_cell_ptr).put_back(res); }\n+                let scheduler = Local::take::<Scheduler>();\n+                scheduler.resume_blocked_task_immediately(task_cell.take());\n+            };\n+        };\n+        result_cell.take()\n+    }\n+}\n+\n #[test]\n fn test_simple_io_no_connect() {\n     do run_in_newsched_task {\n@@ -1498,3 +1629,39 @@ fn test_timer_sleep_simple() {\n         }\n     }\n }\n+\n+fn file_test_uvio_full_simple_impl() {\n+    use libc::{O_CREAT, O_RDWR, O_RDONLY,\n+               S_IWUSR, S_IRUSR};\n+    use str::StrSlice; // why does this have to be explicitly imported to work?\n+                       // compiler was complaining about no trait for str that\n+                       // does .as_bytes() ..\n+    unsafe {\n+        let io = Local::unsafe_borrow::<IoFactoryObject>();\n+        let create_flags = O_RDWR | O_CREAT;\n+        let ro_flags = O_RDONLY;\n+        let write_val = \"hello uvio!\";\n+        let mode = S_IWUSR | S_IRUSR;\n+        let path = \"./file_test_uvio_full.txt\";\n+        {\n+            let mut fd = (*io).fs_open(Path(path), create_flags as int, mode as int).unwrap();\n+            let write_buf = write_val.as_bytes();\n+            fd.write(write_buf, 0);\n+        }\n+        {\n+            let mut fd = (*io).fs_open(Path(path), ro_flags as int, mode as int).unwrap();\n+            let mut read_vec = [0, .. 1028];\n+            let nread = fd.read(read_vec, 0).unwrap();\n+            let read_val = str::from_bytes(read_vec.slice(0, nread as uint));\n+            assert!(read_val == write_val.to_owned());\n+        }\n+        (*io).fs_unlink(Path(path));\n+    }\n+}\n+\n+#[test]\n+fn file_test_uvio_full_simple() {\n+    do run_in_newsched_task {\n+        file_test_uvio_full_simple_impl();\n+    }\n+}"}]}