{"sha": "f7b03585737b18782c5697881e0a7cb04fe8e462", "node_id": "C_kwDOAAsO6NoAKGY3YjAzNTg1NzM3YjE4NzgyYzU2OTc4ODFlMGE3Y2IwNGZlOGU0NjI", "commit": {"author": {"name": "Jubilee Young", "email": "workingjubilee@gmail.com", "date": "2021-11-13T22:38:26Z"}, "committer": {"name": "Jubilee", "email": "46493976+workingjubilee@users.noreply.github.com", "date": "2021-11-14T20:11:35Z"}, "message": "Sprinkle the crate with #[must_use]", "tree": {"sha": "16817ea2cc31c22ab5e1778b120482071d86a528", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/16817ea2cc31c22ab5e1778b120482071d86a528"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f7b03585737b18782c5697881e0a7cb04fe8e462", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f7b03585737b18782c5697881e0a7cb04fe8e462", "html_url": "https://github.com/rust-lang/rust/commit/f7b03585737b18782c5697881e0a7cb04fe8e462", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f7b03585737b18782c5697881e0a7cb04fe8e462/comments", "author": {"login": "workingjubilee", "id": 46493976, "node_id": "MDQ6VXNlcjQ2NDkzOTc2", "avatar_url": "https://avatars.githubusercontent.com/u/46493976?v=4", "gravatar_id": "", "url": "https://api.github.com/users/workingjubilee", "html_url": "https://github.com/workingjubilee", "followers_url": "https://api.github.com/users/workingjubilee/followers", "following_url": "https://api.github.com/users/workingjubilee/following{/other_user}", "gists_url": "https://api.github.com/users/workingjubilee/gists{/gist_id}", "starred_url": "https://api.github.com/users/workingjubilee/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/workingjubilee/subscriptions", "organizations_url": "https://api.github.com/users/workingjubilee/orgs", "repos_url": "https://api.github.com/users/workingjubilee/repos", "events_url": "https://api.github.com/users/workingjubilee/events{/privacy}", "received_events_url": "https://api.github.com/users/workingjubilee/received_events", "type": "User", "site_admin": false}, "committer": {"login": "workingjubilee", "id": 46493976, "node_id": "MDQ6VXNlcjQ2NDkzOTc2", "avatar_url": "https://avatars.githubusercontent.com/u/46493976?v=4", "gravatar_id": "", "url": "https://api.github.com/users/workingjubilee", "html_url": "https://github.com/workingjubilee", "followers_url": "https://api.github.com/users/workingjubilee/followers", "following_url": "https://api.github.com/users/workingjubilee/following{/other_user}", "gists_url": "https://api.github.com/users/workingjubilee/gists{/gist_id}", "starred_url": "https://api.github.com/users/workingjubilee/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/workingjubilee/subscriptions", "organizations_url": "https://api.github.com/users/workingjubilee/orgs", "repos_url": "https://api.github.com/users/workingjubilee/repos", "events_url": "https://api.github.com/users/workingjubilee/events{/privacy}", "received_events_url": "https://api.github.com/users/workingjubilee/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "690184a5a4f2fdc059abda5c90270692498e6ff4", "url": "https://api.github.com/repos/rust-lang/rust/commits/690184a5a4f2fdc059abda5c90270692498e6ff4", "html_url": "https://github.com/rust-lang/rust/commit/690184a5a4f2fdc059abda5c90270692498e6ff4"}], "stats": {"total": 90, "additions": 90, "deletions": 0}, "files": [{"sha": "edef5af3687a27f4cd20099bdb6368ed4362d59d", "filename": "crates/core_simd/src/comparisons.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f7b03585737b18782c5697881e0a7cb04fe8e462/crates%2Fcore_simd%2Fsrc%2Fcomparisons.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f7b03585737b18782c5697881e0a7cb04fe8e462/crates%2Fcore_simd%2Fsrc%2Fcomparisons.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcore_simd%2Fsrc%2Fcomparisons.rs?ref=f7b03585737b18782c5697881e0a7cb04fe8e462", "patch": "@@ -8,12 +8,14 @@ where\n {\n     /// Test if each lane is equal to the corresponding lane in `other`.\n     #[inline]\n+    #[must_use = \"method returns a new mask and does not mutate the original value\"]\n     pub fn lanes_eq(self, other: Self) -> Mask<T::Mask, LANES> {\n         unsafe { Mask::from_int_unchecked(intrinsics::simd_eq(self, other)) }\n     }\n \n     /// Test if each lane is not equal to the corresponding lane in `other`.\n     #[inline]\n+    #[must_use = \"method returns a new mask and does not mutate the original value\"]\n     pub fn lanes_ne(self, other: Self) -> Mask<T::Mask, LANES> {\n         unsafe { Mask::from_int_unchecked(intrinsics::simd_ne(self, other)) }\n     }\n@@ -26,24 +28,28 @@ where\n {\n     /// Test if each lane is less than the corresponding lane in `other`.\n     #[inline]\n+    #[must_use = \"method returns a new mask and does not mutate the original value\"]\n     pub fn lanes_lt(self, other: Self) -> Mask<T::Mask, LANES> {\n         unsafe { Mask::from_int_unchecked(intrinsics::simd_lt(self, other)) }\n     }\n \n     /// Test if each lane is greater than the corresponding lane in `other`.\n     #[inline]\n+    #[must_use = \"method returns a new mask and does not mutate the original value\"]\n     pub fn lanes_gt(self, other: Self) -> Mask<T::Mask, LANES> {\n         unsafe { Mask::from_int_unchecked(intrinsics::simd_gt(self, other)) }\n     }\n \n     /// Test if each lane is less than or equal to the corresponding lane in `other`.\n     #[inline]\n+    #[must_use = \"method returns a new mask and does not mutate the original value\"]\n     pub fn lanes_le(self, other: Self) -> Mask<T::Mask, LANES> {\n         unsafe { Mask::from_int_unchecked(intrinsics::simd_le(self, other)) }\n     }\n \n     /// Test if each lane is greater than or equal to the corresponding lane in `other`.\n     #[inline]\n+    #[must_use = \"method returns a new mask and does not mutate the original value\"]\n     pub fn lanes_ge(self, other: Self) -> Mask<T::Mask, LANES> {\n         unsafe { Mask::from_int_unchecked(intrinsics::simd_ge(self, other)) }\n     }"}, {"sha": "191e96903133f2ad9fb164266cb1de6d56f29ec9", "filename": "crates/core_simd/src/masks.rs", "status": "modified", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/f7b03585737b18782c5697881e0a7cb04fe8e462/crates%2Fcore_simd%2Fsrc%2Fmasks.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f7b03585737b18782c5697881e0a7cb04fe8e462/crates%2Fcore_simd%2Fsrc%2Fmasks.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcore_simd%2Fsrc%2Fmasks.rs?ref=f7b03585737b18782c5697881e0a7cb04fe8e462", "patch": "@@ -129,6 +129,7 @@ where\n     /// # Safety\n     /// All lanes must be either 0 or -1.\n     #[inline]\n+    #[must_use = \"method returns a new mask and does not mutate the original value\"]\n     pub unsafe fn from_int_unchecked(value: Simd<T, LANES>) -> Self {\n         unsafe { Self(mask_impl::Mask::from_int_unchecked(value)) }\n     }\n@@ -139,6 +140,7 @@ where\n     /// # Panics\n     /// Panics if any lane is not 0 or -1.\n     #[inline]\n+    #[must_use = \"method returns a new mask and does not mutate the original value\"]\n     pub fn from_int(value: Simd<T, LANES>) -> Self {\n         assert!(T::valid(value), \"all values must be either 0 or -1\",);\n         unsafe { Self::from_int_unchecked(value) }\n@@ -147,6 +149,7 @@ where\n     /// Converts the mask to a vector of integers, where 0 represents `false` and -1\n     /// represents `true`.\n     #[inline]\n+    #[must_use = \"method returns a new vector and does not mutate the original value\"]\n     pub fn to_int(self) -> Simd<T, LANES> {\n         self.0.to_int()\n     }\n@@ -156,6 +159,7 @@ where\n     /// # Safety\n     /// `lane` must be less than `LANES`.\n     #[inline]\n+    #[must_use = \"method returns a new bool and does not mutate the original value\"]\n     pub unsafe fn test_unchecked(&self, lane: usize) -> bool {\n         unsafe { self.0.test_unchecked(lane) }\n     }\n@@ -165,6 +169,7 @@ where\n     /// # Panics\n     /// Panics if `lane` is greater than or equal to the number of lanes in the vector.\n     #[inline]\n+    #[must_use = \"method returns a new bool and does not mutate the original value\"]\n     pub fn test(&self, lane: usize) -> bool {\n         assert!(lane < LANES, \"lane index out of range\");\n         unsafe { self.test_unchecked(lane) }\n@@ -195,24 +200,30 @@ where\n \n     /// Convert this mask to a bitmask, with one bit set per lane.\n     #[cfg(feature = \"generic_const_exprs\")]\n+    #[inline]\n+    #[must_use = \"method returns a new array and does not mutate the original value\"]\n     pub fn to_bitmask(self) -> [u8; LaneCount::<LANES>::BITMASK_LEN] {\n         self.0.to_bitmask()\n     }\n \n     /// Convert a bitmask to a mask.\n     #[cfg(feature = \"generic_const_exprs\")]\n+    #[inline]\n+    #[must_use = \"method returns a new mask and does not mutate the original value\"]\n     pub fn from_bitmask(bitmask: [u8; LaneCount::<LANES>::BITMASK_LEN]) -> Self {\n         Self(mask_impl::Mask::from_bitmask(bitmask))\n     }\n \n     /// Returns true if any lane is set, or false otherwise.\n     #[inline]\n+    #[must_use = \"method returns a new bool and does not mutate the original value\"]\n     pub fn any(self) -> bool {\n         self.0.any()\n     }\n \n     /// Returns true if all lanes are set, or false otherwise.\n     #[inline]\n+    #[must_use = \"method returns a new bool and does not mutate the original value\"]\n     pub fn all(self) -> bool {\n         self.0.all()\n     }\n@@ -245,6 +256,7 @@ where\n     LaneCount<LANES>: SupportedLaneCount,\n {\n     #[inline]\n+    #[must_use = \"method returns a defaulted mask with all lanes set to false (0)\"]\n     fn default() -> Self {\n         Self::splat(false)\n     }\n@@ -256,6 +268,7 @@ where\n     LaneCount<LANES>: SupportedLaneCount,\n {\n     #[inline]\n+    #[must_use = \"method returns a new bool and does not mutate the original value\"]\n     fn eq(&self, other: &Self) -> bool {\n         self.0 == other.0\n     }\n@@ -267,6 +280,7 @@ where\n     LaneCount<LANES>: SupportedLaneCount,\n {\n     #[inline]\n+    #[must_use = \"method returns a new Ordering and does not mutate the original value\"]\n     fn partial_cmp(&self, other: &Self) -> Option<Ordering> {\n         self.0.partial_cmp(&other.0)\n     }\n@@ -291,6 +305,7 @@ where\n {\n     type Output = Self;\n     #[inline]\n+    #[must_use = \"method returns a new mask and does not mutate the original value\"]\n     fn bitand(self, rhs: Self) -> Self {\n         Self(self.0 & rhs.0)\n     }\n@@ -303,6 +318,7 @@ where\n {\n     type Output = Self;\n     #[inline]\n+    #[must_use = \"method returns a new mask and does not mutate the original value\"]\n     fn bitand(self, rhs: bool) -> Self {\n         self & Self::splat(rhs)\n     }\n@@ -315,6 +331,7 @@ where\n {\n     type Output = Mask<T, LANES>;\n     #[inline]\n+    #[must_use = \"method returns a new mask and does not mutate the original value\"]\n     fn bitand(self, rhs: Mask<T, LANES>) -> Mask<T, LANES> {\n         Mask::splat(self) & rhs\n     }\n@@ -327,6 +344,7 @@ where\n {\n     type Output = Self;\n     #[inline]\n+    #[must_use = \"method returns a new mask and does not mutate the original value\"]\n     fn bitor(self, rhs: Self) -> Self {\n         Self(self.0 | rhs.0)\n     }\n@@ -339,6 +357,7 @@ where\n {\n     type Output = Self;\n     #[inline]\n+    #[must_use = \"method returns a new mask and does not mutate the original value\"]\n     fn bitor(self, rhs: bool) -> Self {\n         self | Self::splat(rhs)\n     }\n@@ -351,6 +370,7 @@ where\n {\n     type Output = Mask<T, LANES>;\n     #[inline]\n+    #[must_use = \"method returns a new mask and does not mutate the original value\"]\n     fn bitor(self, rhs: Mask<T, LANES>) -> Mask<T, LANES> {\n         Mask::splat(self) | rhs\n     }\n@@ -363,6 +383,7 @@ where\n {\n     type Output = Self;\n     #[inline]\n+    #[must_use = \"method returns a new mask and does not mutate the original value\"]\n     fn bitxor(self, rhs: Self) -> Self::Output {\n         Self(self.0 ^ rhs.0)\n     }\n@@ -375,6 +396,7 @@ where\n {\n     type Output = Self;\n     #[inline]\n+    #[must_use = \"method returns a new mask and does not mutate the original value\"]\n     fn bitxor(self, rhs: bool) -> Self::Output {\n         self ^ Self::splat(rhs)\n     }\n@@ -387,6 +409,7 @@ where\n {\n     type Output = Mask<T, LANES>;\n     #[inline]\n+    #[must_use = \"method returns a new mask and does not mutate the original value\"]\n     fn bitxor(self, rhs: Mask<T, LANES>) -> Self::Output {\n         Mask::splat(self) ^ rhs\n     }\n@@ -399,6 +422,7 @@ where\n {\n     type Output = Mask<T, LANES>;\n     #[inline]\n+    #[must_use = \"method returns a new mask and does not mutate the original value\"]\n     fn not(self) -> Self::Output {\n         Self(!self.0)\n     }"}, {"sha": "4c964cb52e1963851689fc06ef70c39dc5fcdb9d", "filename": "crates/core_simd/src/masks/bitmask.rs", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/f7b03585737b18782c5697881e0a7cb04fe8e462/crates%2Fcore_simd%2Fsrc%2Fmasks%2Fbitmask.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f7b03585737b18782c5697881e0a7cb04fe8e462/crates%2Fcore_simd%2Fsrc%2Fmasks%2Fbitmask.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcore_simd%2Fsrc%2Fmasks%2Fbitmask.rs?ref=f7b03585737b18782c5697881e0a7cb04fe8e462", "patch": "@@ -74,6 +74,7 @@ where\n     LaneCount<LANES>: SupportedLaneCount,\n {\n     #[inline]\n+    #[must_use = \"method returns a new mask and does not mutate the original value\"]\n     pub fn splat(value: bool) -> Self {\n         let mut mask = <LaneCount<LANES> as SupportedLaneCount>::BitMask::default();\n         if value {\n@@ -88,6 +89,7 @@ where\n     }\n \n     #[inline]\n+    #[must_use = \"method returns a new bool and does not mutate the original value\"]\n     pub unsafe fn test_unchecked(&self, lane: usize) -> bool {\n         (self.0.as_ref()[lane / 8] >> (lane % 8)) & 0x1 > 0\n     }\n@@ -100,6 +102,7 @@ where\n     }\n \n     #[inline]\n+    #[must_use = \"method returns a new vector and does not mutate the original value\"]\n     pub fn to_int(self) -> Simd<T, LANES> {\n         unsafe {\n             crate::intrinsics::simd_select_bitmask(\n@@ -111,25 +114,29 @@ where\n     }\n \n     #[inline]\n+    #[must_use = \"method returns a new mask and does not mutate the original value\"]\n     pub unsafe fn from_int_unchecked(value: Simd<T, LANES>) -> Self {\n         unsafe { Self(crate::intrinsics::simd_bitmask(value), PhantomData) }\n     }\n \n     #[cfg(feature = \"generic_const_exprs\")]\n     #[inline]\n+    #[must_use = \"method returns a new array and does not mutate the original value\"]\n     pub fn to_bitmask(self) -> [u8; LaneCount::<LANES>::BITMASK_LEN] {\n         // Safety: these are the same type and we are laundering the generic\n         unsafe { core::mem::transmute_copy(&self.0) }\n     }\n \n     #[cfg(feature = \"generic_const_exprs\")]\n     #[inline]\n+    #[must_use = \"method returns a new mask and does not mutate the original value\"]\n     pub fn from_bitmask(bitmask: [u8; LaneCount::<LANES>::BITMASK_LEN]) -> Self {\n         // Safety: these are the same type and we are laundering the generic\n         Self(unsafe { core::mem::transmute_copy(&bitmask) }, PhantomData)\n     }\n \n     #[inline]\n+    #[must_use = \"method returns a new mask and does not mutate the original value\"]\n     pub fn convert<U>(self) -> Mask<U, LANES>\n     where\n         U: MaskElement,\n@@ -138,11 +145,13 @@ where\n     }\n \n     #[inline]\n+    #[must_use = \"method returns a new bool and does not mutate the original value\"]\n     pub fn any(self) -> bool {\n         self != Self::splat(false)\n     }\n \n     #[inline]\n+    #[must_use = \"method returns a new bool and does not mutate the original value\"]\n     pub fn all(self) -> bool {\n         self == Self::splat(true)\n     }\n@@ -156,6 +165,7 @@ where\n {\n     type Output = Self;\n     #[inline]\n+    #[must_use = \"method returns a new mask and does not mutate the original value\"]\n     fn bitand(mut self, rhs: Self) -> Self {\n         for (l, r) in self.0.as_mut().iter_mut().zip(rhs.0.as_ref().iter()) {\n             *l &= r;\n@@ -172,6 +182,7 @@ where\n {\n     type Output = Self;\n     #[inline]\n+    #[must_use = \"method returns a new mask and does not mutate the original value\"]\n     fn bitor(mut self, rhs: Self) -> Self {\n         for (l, r) in self.0.as_mut().iter_mut().zip(rhs.0.as_ref().iter()) {\n             *l |= r;\n@@ -187,6 +198,7 @@ where\n {\n     type Output = Self;\n     #[inline]\n+    #[must_use = \"method returns a new mask and does not mutate the original value\"]\n     fn bitxor(mut self, rhs: Self) -> Self::Output {\n         for (l, r) in self.0.as_mut().iter_mut().zip(rhs.0.as_ref().iter()) {\n             *l ^= r;\n@@ -202,6 +214,7 @@ where\n {\n     type Output = Self;\n     #[inline]\n+    #[must_use = \"method returns a new mask and does not mutate the original value\"]\n     fn not(mut self) -> Self::Output {\n         for x in self.0.as_mut() {\n             *x = !*x;"}, {"sha": "5421ccbe3d8f5ce9c5e3b7221609314990412fcf", "filename": "crates/core_simd/src/masks/full_masks.rs", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/f7b03585737b18782c5697881e0a7cb04fe8e462/crates%2Fcore_simd%2Fsrc%2Fmasks%2Ffull_masks.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f7b03585737b18782c5697881e0a7cb04fe8e462/crates%2Fcore_simd%2Fsrc%2Fmasks%2Ffull_masks.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcore_simd%2Fsrc%2Fmasks%2Ffull_masks.rs?ref=f7b03585737b18782c5697881e0a7cb04fe8e462", "patch": "@@ -23,6 +23,7 @@ where\n     LaneCount<LANES>: SupportedLaneCount,\n {\n     #[inline]\n+    #[must_use = \"method returns a new mask and does not mutate the original value\"]\n     fn clone(&self) -> Self {\n         *self\n     }\n@@ -70,11 +71,14 @@ where\n     T: MaskElement,\n     LaneCount<LANES>: SupportedLaneCount,\n {\n+    #[inline]\n+    #[must_use = \"method returns a new mask and does not mutate the original value\"]\n     pub fn splat(value: bool) -> Self {\n         Self(Simd::splat(if value { T::TRUE } else { T::FALSE }))\n     }\n \n     #[inline]\n+    #[must_use = \"method returns a new bool and does not mutate the original value\"]\n     pub unsafe fn test_unchecked(&self, lane: usize) -> bool {\n         T::eq(self.0[lane], T::TRUE)\n     }\n@@ -85,16 +89,19 @@ where\n     }\n \n     #[inline]\n+    #[must_use = \"method returns a new vector and does not mutate the original value\"]\n     pub fn to_int(self) -> Simd<T, LANES> {\n         self.0\n     }\n \n     #[inline]\n+    #[must_use = \"method returns a new mask and does not mutate the original value\"]\n     pub unsafe fn from_int_unchecked(value: Simd<T, LANES>) -> Self {\n         Self(value)\n     }\n \n     #[inline]\n+    #[must_use = \"method returns a new mask and does not mutate the original value\"]\n     pub fn convert<U>(self) -> Mask<U, LANES>\n     where\n         U: MaskElement,\n@@ -104,6 +111,7 @@ where\n \n     #[cfg(feature = \"generic_const_exprs\")]\n     #[inline]\n+    #[must_use = \"method returns a new array and does not mutate the original value\"]\n     pub fn to_bitmask(self) -> [u8; LaneCount::<LANES>::BITMASK_LEN] {\n         unsafe {\n             let mut bitmask: [u8; LaneCount::<LANES>::BITMASK_LEN] =\n@@ -124,6 +132,7 @@ where\n \n     #[cfg(feature = \"generic_const_exprs\")]\n     #[inline]\n+    #[must_use = \"method returns a new mask and does not mutate the original value\"]\n     pub fn from_bitmask(mut bitmask: [u8; LaneCount::<LANES>::BITMASK_LEN]) -> Self {\n         unsafe {\n             // There is a bug where LLVM appears to implement this operation with the wrong\n@@ -144,11 +153,13 @@ where\n     }\n \n     #[inline]\n+    #[must_use = \"method returns a new bool and does not mutate the original value\"]\n     pub fn any(self) -> bool {\n         unsafe { intrinsics::simd_reduce_any(self.to_int()) }\n     }\n \n     #[inline]\n+    #[must_use = \"method returns a new vector and does not mutate the original value\"]\n     pub fn all(self) -> bool {\n         unsafe { intrinsics::simd_reduce_all(self.to_int()) }\n     }\n@@ -171,6 +182,7 @@ where\n {\n     type Output = Self;\n     #[inline]\n+    #[must_use = \"method returns a new mask and does not mutate the original value\"]\n     fn bitand(self, rhs: Self) -> Self {\n         unsafe { Self(intrinsics::simd_and(self.0, rhs.0)) }\n     }\n@@ -183,6 +195,7 @@ where\n {\n     type Output = Self;\n     #[inline]\n+    #[must_use = \"method returns a new mask and does not mutate the original value\"]\n     fn bitor(self, rhs: Self) -> Self {\n         unsafe { Self(intrinsics::simd_or(self.0, rhs.0)) }\n     }\n@@ -195,6 +208,7 @@ where\n {\n     type Output = Self;\n     #[inline]\n+    #[must_use = \"method returns a new mask and does not mutate the original value\"]\n     fn bitxor(self, rhs: Self) -> Self {\n         unsafe { Self(intrinsics::simd_xor(self.0, rhs.0)) }\n     }\n@@ -207,6 +221,7 @@ where\n {\n     type Output = Self;\n     #[inline]\n+    #[must_use = \"method returns a new mask and does not mutate the original value\"]\n     fn not(self) -> Self::Output {\n         Self::splat(true) ^ self\n     }"}, {"sha": "5d696ebf76ec299bccb57673f6a13c869f8ad09f", "filename": "crates/core_simd/src/select.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/f7b03585737b18782c5697881e0a7cb04fe8e462/crates%2Fcore_simd%2Fsrc%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f7b03585737b18782c5697881e0a7cb04fe8e462/crates%2Fcore_simd%2Fsrc%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcore_simd%2Fsrc%2Fselect.rs?ref=f7b03585737b18782c5697881e0a7cb04fe8e462", "patch": "@@ -17,6 +17,7 @@ where\n     LaneCount<LANES>: SupportedLaneCount,\n {\n     #[inline]\n+    #[must_use = \"method returns a new vector and does not mutate the original inputs\"]\n     fn select(mask: Mask<T::Mask, LANES>, true_values: Self, false_values: Self) -> Self {\n         unsafe { intrinsics::simd_select(mask.to_int(), true_values, false_values) }\n     }\n@@ -35,6 +36,7 @@ where\n     LaneCount<LANES>: SupportedLaneCount,\n {\n     #[inline]\n+    #[must_use = \"method returns a new vector and does not mutate the original inputs\"]\n     fn select(mask: Self, true_values: Self, false_values: Self) -> Self {\n         mask & true_values | !mask & false_values\n     }\n@@ -80,6 +82,7 @@ where\n     /// assert_eq!(c.to_array(), [true, false, true, false]);\n     /// ```\n     #[inline]\n+    #[must_use = \"method returns a new vector and does not mutate the original inputs\"]\n     pub fn select<S: Select<Self>>(self, true_values: S, false_values: S) -> S {\n         S::select(self, true_values, false_values)\n     }"}, {"sha": "bdc489774a54a43e1293a31a754cfb9da72ecc3d", "filename": "crates/core_simd/src/swizzle.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/f7b03585737b18782c5697881e0a7cb04fe8e462/crates%2Fcore_simd%2Fsrc%2Fswizzle.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f7b03585737b18782c5697881e0a7cb04fe8e462/crates%2Fcore_simd%2Fsrc%2Fswizzle.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcore_simd%2Fsrc%2Fswizzle.rs?ref=f7b03585737b18782c5697881e0a7cb04fe8e462", "patch": "@@ -87,6 +87,8 @@ pub trait Swizzle<const INPUT_LANES: usize, const OUTPUT_LANES: usize> {\n     /// Create a new vector from the lanes of `vector`.\n     ///\n     /// Lane `i` of the output is `vector[Self::INDEX[i]]`.\n+    #[inline]\n+    #[must_use = \"method returns a new vector and does not mutate the original inputs\"]\n     fn swizzle<T>(vector: Simd<T, INPUT_LANES>) -> Simd<T, OUTPUT_LANES>\n     where\n         T: SimdElement,\n@@ -106,6 +108,8 @@ pub trait Swizzle2<const INPUT_LANES: usize, const OUTPUT_LANES: usize> {\n     ///\n     /// Lane `i` is `first[j]` when `Self::INDEX[i]` is `First(j)`, or `second[j]` when it is\n     /// `Second(j)`.\n+    #[inline]\n+    #[must_use = \"method returns a new vector and does not mutate the original inputs\"]\n     fn swizzle2<T>(\n         first: Simd<T, INPUT_LANES>,\n         second: Simd<T, INPUT_LANES>,\n@@ -182,6 +186,7 @@ where\n {\n     /// Reverse the order of the lanes in the vector.\n     #[inline]\n+    #[must_use = \"method returns a new vector and does not mutate the original inputs\"]\n     pub fn reverse(self) -> Self {\n         const fn reverse_index<const LANES: usize>() -> [usize; LANES] {\n             let mut index = [0; LANES];\n@@ -206,6 +211,7 @@ where\n     /// while the last `LANES - OFFSET` elements move to the front. After calling `rotate_lanes_left`,\n     /// the element previously in lane `OFFSET` will become the first element in the slice.\n     #[inline]\n+    #[must_use = \"method returns a new vector and does not mutate the original inputs\"]\n     pub fn rotate_lanes_left<const OFFSET: usize>(self) -> Self {\n         const fn rotate_index<const OFFSET: usize, const LANES: usize>() -> [usize; LANES] {\n             let offset = OFFSET % LANES;\n@@ -231,6 +237,7 @@ where\n     /// the end while the last `OFFSET` elements move to the front. After calling `rotate_lanes_right`,\n     /// the element previously at index `LANES - OFFSET` will become the first element in the slice.\n     #[inline]\n+    #[must_use = \"method returns a new vector and does not mutate the original inputs\"]\n     pub fn rotate_lanes_right<const OFFSET: usize>(self) -> Self {\n         const fn rotate_index<const OFFSET: usize, const LANES: usize>() -> [usize; LANES] {\n             let offset = LANES - OFFSET % LANES;\n@@ -273,6 +280,7 @@ where\n     /// assert_eq!(y.to_array(), [2, 6, 3, 7]);\n     /// ```\n     #[inline]\n+    #[must_use = \"method returns a new vector and does not mutate the original inputs\"]\n     pub fn interleave(self, other: Self) -> (Self, Self) {\n         const fn lo<const LANES: usize>() -> [Which; LANES] {\n             let mut idx = [Which::First(0); LANES];\n@@ -336,6 +344,7 @@ where\n     /// assert_eq!(y.to_array(), [4, 5, 6, 7]);\n     /// ```\n     #[inline]\n+    #[must_use = \"method returns a new vector and does not mutate the original inputs\"]\n     pub fn deinterleave(self, other: Self) -> (Self, Self) {\n         const fn even<const LANES: usize>() -> [Which; LANES] {\n             let mut idx = [Which::First(0); LANES];"}, {"sha": "4a4b23238c4ab3770d5357ffa962ae36d9afb999", "filename": "crates/core_simd/src/vector/float.rs", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/f7b03585737b18782c5697881e0a7cb04fe8e462/crates%2Fcore_simd%2Fsrc%2Fvector%2Ffloat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f7b03585737b18782c5697881e0a7cb04fe8e462/crates%2Fcore_simd%2Fsrc%2Fvector%2Ffloat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcore_simd%2Fsrc%2Fvector%2Ffloat.rs?ref=f7b03585737b18782c5697881e0a7cb04fe8e462", "patch": "@@ -15,6 +15,7 @@ macro_rules! impl_float_vector {\n             /// Raw transmutation to an unsigned integer vector type with the\n             /// same size and number of lanes.\n             #[inline]\n+            #[must_use = \"method returns a new vector and does not mutate the original value\"]\n             pub fn to_bits(self) -> Simd<$bits_ty, LANES> {\n                 assert_eq!(core::mem::size_of::<Self>(), core::mem::size_of::<Simd<$bits_ty, LANES>>());\n                 unsafe { core::mem::transmute_copy(&self) }\n@@ -23,6 +24,7 @@ macro_rules! impl_float_vector {\n             /// Raw transmutation from an unsigned integer vector type with the\n             /// same size and number of lanes.\n             #[inline]\n+            #[must_use = \"method returns a new vector and does not mutate the original value\"]\n             pub fn from_bits(bits: Simd<$bits_ty, LANES>) -> Self {\n                 assert_eq!(core::mem::size_of::<Self>(), core::mem::size_of::<Simd<$bits_ty, LANES>>());\n                 unsafe { core::mem::transmute_copy(&bits) }\n@@ -31,6 +33,7 @@ macro_rules! impl_float_vector {\n             /// Produces a vector where every lane has the absolute value of the\n             /// equivalently-indexed lane in `self`.\n             #[inline]\n+            #[must_use = \"method returns a new vector and does not mutate the original value\"]\n             pub fn abs(self) -> Self {\n                 unsafe { intrinsics::simd_fabs(self) }\n             }\n@@ -44,79 +47,91 @@ macro_rules! impl_float_vector {\n             /// hardware in mind.\n             #[cfg(feature = \"std\")]\n             #[inline]\n+            #[must_use = \"method returns a new vector and does not mutate the original value\"]\n             pub fn mul_add(self, a: Self, b: Self) -> Self {\n                 unsafe { intrinsics::simd_fma(self, a, b) }\n             }\n \n             /// Produces a vector where every lane has the square root value\n             /// of the equivalently-indexed lane in `self`\n             #[inline]\n+            #[must_use = \"method returns a new vector and does not mutate the original value\"]\n             #[cfg(feature = \"std\")]\n             pub fn sqrt(self) -> Self {\n                 unsafe { intrinsics::simd_fsqrt(self) }\n             }\n \n             /// Takes the reciprocal (inverse) of each lane, `1/x`.\n             #[inline]\n+            #[must_use = \"method returns a new vector and does not mutate the original value\"]\n             pub fn recip(self) -> Self {\n                 Self::splat(1.0) / self\n             }\n \n             /// Converts each lane from radians to degrees.\n             #[inline]\n+            #[must_use = \"method returns a new vector and does not mutate the original value\"]\n             pub fn to_degrees(self) -> Self {\n                 // to_degrees uses a special constant for better precision, so extract that constant\n                 self * Self::splat(<$type>::to_degrees(1.))\n             }\n \n             /// Converts each lane from degrees to radians.\n             #[inline]\n+            #[must_use = \"method returns a new vector and does not mutate the original value\"]\n             pub fn to_radians(self) -> Self {\n                 self * Self::splat(<$type>::to_radians(1.))\n             }\n \n             /// Returns true for each lane if it has a positive sign, including\n             /// `+0.0`, `NaN`s with positive sign bit and positive infinity.\n             #[inline]\n+            #[must_use = \"method returns a new mask and does not mutate the original value\"]\n             pub fn is_sign_positive(self) -> Mask<$mask_ty, LANES> {\n                 !self.is_sign_negative()\n             }\n \n             /// Returns true for each lane if it has a negative sign, including\n             /// `-0.0`, `NaN`s with negative sign bit and negative infinity.\n             #[inline]\n+            #[must_use = \"method returns a new mask and does not mutate the original value\"]\n             pub fn is_sign_negative(self) -> Mask<$mask_ty, LANES> {\n                 let sign_bits = self.to_bits() & Simd::splat((!0 >> 1) + 1);\n                 sign_bits.lanes_gt(Simd::splat(0))\n             }\n \n             /// Returns true for each lane if its value is `NaN`.\n             #[inline]\n+            #[must_use = \"method returns a new mask and does not mutate the original value\"]\n             pub fn is_nan(self) -> Mask<$mask_ty, LANES> {\n                 self.lanes_ne(self)\n             }\n \n             /// Returns true for each lane if its value is positive infinity or negative infinity.\n             #[inline]\n+            #[must_use = \"method returns a new mask and does not mutate the original value\"]\n             pub fn is_infinite(self) -> Mask<$mask_ty, LANES> {\n                 self.abs().lanes_eq(Self::splat(<$type>::INFINITY))\n             }\n \n             /// Returns true for each lane if its value is neither infinite nor `NaN`.\n             #[inline]\n+            #[must_use = \"method returns a new mask and does not mutate the original value\"]\n             pub fn is_finite(self) -> Mask<$mask_ty, LANES> {\n                 self.abs().lanes_lt(Self::splat(<$type>::INFINITY))\n             }\n \n             /// Returns true for each lane if its value is subnormal.\n             #[inline]\n+            #[must_use = \"method returns a new mask and does not mutate the original value\"]\n             pub fn is_subnormal(self) -> Mask<$mask_ty, LANES> {\n                 self.abs().lanes_ne(Self::splat(0.0)) & (self.to_bits() & Self::splat(<$type>::INFINITY).to_bits()).lanes_eq(Simd::splat(0))\n             }\n \n             /// Returns true for each lane if its value is neither neither zero, infinite,\n             /// subnormal, or `NaN`.\n             #[inline]\n+            #[must_use = \"method returns a new mask and does not mutate the original value\"]\n             pub fn is_normal(self) -> Mask<$mask_ty, LANES> {\n                 !(self.abs().lanes_eq(Self::splat(0.0)) | self.is_nan() | self.is_subnormal() | self.is_infinite())\n             }\n@@ -127,6 +142,7 @@ macro_rules! impl_float_vector {\n             /// * `-1.0` if the number is negative, `-0.0`, or `NEG_INFINITY`\n             /// * `NAN` if the number is `NAN`\n             #[inline]\n+            #[must_use = \"method returns a new vector and does not mutate the original value\"]\n             pub fn signum(self) -> Self {\n                 self.is_nan().select(Self::splat(<$type>::NAN), Self::splat(1.0).copysign(self))\n             }\n@@ -135,6 +151,7 @@ macro_rules! impl_float_vector {\n             ///\n             /// If any lane is a `NAN`, then a `NAN` with the sign of `sign` is returned.\n             #[inline]\n+            #[must_use = \"method returns a new vector and does not mutate the original value\"]\n             pub fn copysign(self, sign: Self) -> Self {\n                 let sign_bit = sign.to_bits() & Self::splat(-0.).to_bits();\n                 let magnitude = self.to_bits() & !Self::splat(-0.).to_bits();\n@@ -145,6 +162,7 @@ macro_rules! impl_float_vector {\n             ///\n             /// If one of the values is `NAN`, then the other value is returned.\n             #[inline]\n+            #[must_use = \"method returns a new vector and does not mutate the original value\"]\n             pub fn min(self, other: Self) -> Self {\n                 // TODO consider using an intrinsic\n                 self.is_nan().select(\n@@ -157,6 +175,7 @@ macro_rules! impl_float_vector {\n             ///\n             /// If one of the values is `NAN`, then the other value is returned.\n             #[inline]\n+            #[must_use = \"method returns a new vector and does not mutate the original value\"]\n             pub fn max(self, other: Self) -> Self {\n                 // TODO consider using an intrinsic\n                 self.is_nan().select(\n@@ -171,6 +190,7 @@ macro_rules! impl_float_vector {\n             /// greater than `max`, and the corresponding lane in `min` if the lane is less\n             /// than `min`.  Otherwise returns the lane in `self`.\n             #[inline]\n+            #[must_use = \"method returns a new vector and does not mutate the original value\"]\n             pub fn clamp(self, min: Self, max: Self) -> Self {\n                 assert!(\n                     min.lanes_le(max).all(),"}]}