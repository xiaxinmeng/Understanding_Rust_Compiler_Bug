{"sha": "fc70cf9458c5234decafdd52b9aced790ac43d7a", "node_id": "MDY6Q29tbWl0NzI0NzEyOmZjNzBjZjk0NThjNTIzNGRlY2FmZGQ1MmI5YWNlZDc5MGFjNDNkN2E=", "commit": {"author": {"name": "Benjamin Coenen", "email": "5719034+bnjjj@users.noreply.github.com", "date": "2020-04-09T16:32:02Z"}, "committer": {"name": "Benjamin Coenen", "email": "5719034+bnjjj@users.noreply.github.com", "date": "2020-04-09T16:32:02Z"}, "message": "feat: add support for feature attributes in struct literal\n\nSigned-off-by: Benjamin Coenen <5719034+bnjjj@users.noreply.github.com>", "tree": {"sha": "4e27e34d8fff2746731c4a1bce938c784b804661", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4e27e34d8fff2746731c4a1bce938c784b804661"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/fc70cf9458c5234decafdd52b9aced790ac43d7a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/fc70cf9458c5234decafdd52b9aced790ac43d7a", "html_url": "https://github.com/rust-lang/rust/commit/fc70cf9458c5234decafdd52b9aced790ac43d7a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/fc70cf9458c5234decafdd52b9aced790ac43d7a/comments", "author": {"login": "bnjjj", "id": 5719034, "node_id": "MDQ6VXNlcjU3MTkwMzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/5719034?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bnjjj", "html_url": "https://github.com/bnjjj", "followers_url": "https://api.github.com/users/bnjjj/followers", "following_url": "https://api.github.com/users/bnjjj/following{/other_user}", "gists_url": "https://api.github.com/users/bnjjj/gists{/gist_id}", "starred_url": "https://api.github.com/users/bnjjj/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bnjjj/subscriptions", "organizations_url": "https://api.github.com/users/bnjjj/orgs", "repos_url": "https://api.github.com/users/bnjjj/repos", "events_url": "https://api.github.com/users/bnjjj/events{/privacy}", "received_events_url": "https://api.github.com/users/bnjjj/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bnjjj", "id": 5719034, "node_id": "MDQ6VXNlcjU3MTkwMzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/5719034?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bnjjj", "html_url": "https://github.com/bnjjj", "followers_url": "https://api.github.com/users/bnjjj/followers", "following_url": "https://api.github.com/users/bnjjj/following{/other_user}", "gists_url": "https://api.github.com/users/bnjjj/gists{/gist_id}", "starred_url": "https://api.github.com/users/bnjjj/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bnjjj/subscriptions", "organizations_url": "https://api.github.com/users/bnjjj/orgs", "repos_url": "https://api.github.com/users/bnjjj/repos", "events_url": "https://api.github.com/users/bnjjj/events{/privacy}", "received_events_url": "https://api.github.com/users/bnjjj/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "85956932872481cf4813c5e7794d981a9edb4623", "url": "https://api.github.com/repos/rust-lang/rust/commits/85956932872481cf4813c5e7794d981a9edb4623", "html_url": "https://github.com/rust-lang/rust/commit/85956932872481cf4813c5e7794d981a9edb4623"}], "stats": {"total": 188, "additions": 143, "deletions": 45}, "files": [{"sha": "be4b0accb832bdf221bacae32f44331fba6cc6da", "filename": "crates/ra_hir_def/src/adt.rs", "status": "modified", "additions": 39, "deletions": 18, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/fc70cf9458c5234decafdd52b9aced790ac43d7a/crates%2Fra_hir_def%2Fsrc%2Fadt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc70cf9458c5234decafdd52b9aced790ac43d7a/crates%2Fra_hir_def%2Fsrc%2Fadt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Fadt.rs?ref=fc70cf9458c5234decafdd52b9aced790ac43d7a", "patch": "@@ -4,6 +4,7 @@ use std::sync::Arc;\n \n use either::Either;\n use hir_expand::{\n+    hygiene::Hygiene,\n     name::{AsName, Name},\n     InFile,\n };\n@@ -12,9 +13,9 @@ use ra_prof::profile;\n use ra_syntax::ast::{self, NameOwner, TypeAscriptionOwner, VisibilityOwner};\n \n use crate::{\n-    db::DefDatabase, src::HasChildSource, src::HasSource, trace::Trace, type_ref::TypeRef,\n-    visibility::RawVisibility, EnumId, LocalEnumVariantId, LocalStructFieldId, Lookup, StructId,\n-    UnionId, VariantId,\n+    attr::Attrs, db::DefDatabase, src::HasChildSource, src::HasSource, trace::Trace,\n+    type_ref::TypeRef, visibility::RawVisibility, EnumId, HasModule, LocalEnumVariantId,\n+    LocalStructFieldId, Lookup, ModuleId, StructId, UnionId, VariantId,\n };\n \n /// Note that we use `StructData` for unions as well!\n@@ -56,7 +57,8 @@ impl StructData {\n         let src = id.lookup(db).source(db);\n \n         let name = src.value.name().map_or_else(Name::missing, |n| n.as_name());\n-        let variant_data = VariantData::new(db, src.map(|s| s.kind()));\n+        let variant_data =\n+            VariantData::new(db, src.map(|s| s.kind()), id.lookup(db).container.module(db));\n         let variant_data = Arc::new(variant_data);\n         Arc::new(StructData { name, variant_data })\n     }\n@@ -70,6 +72,7 @@ impl StructData {\n                     .map(ast::StructKind::Record)\n                     .unwrap_or(ast::StructKind::Unit)\n             }),\n+            id.lookup(db).container.module(db),\n         );\n         let variant_data = Arc::new(variant_data);\n         Arc::new(StructData { name, variant_data })\n@@ -82,7 +85,7 @@ impl EnumData {\n         let src = e.lookup(db).source(db);\n         let name = src.value.name().map_or_else(Name::missing, |n| n.as_name());\n         let mut trace = Trace::new_for_arena();\n-        lower_enum(db, &mut trace, &src);\n+        lower_enum(db, &mut trace, &src, e.lookup(db).container.module(db));\n         Arc::new(EnumData { name, variants: trace.into_arena() })\n     }\n \n@@ -98,7 +101,7 @@ impl HasChildSource for EnumId {\n     fn child_source(&self, db: &dyn DefDatabase) -> InFile<ArenaMap<Self::ChildId, Self::Value>> {\n         let src = self.lookup(db).source(db);\n         let mut trace = Trace::new_for_map();\n-        lower_enum(db, &mut trace, &src);\n+        lower_enum(db, &mut trace, &src, self.lookup(db).container.module(db));\n         src.with_value(trace.into_map())\n     }\n }\n@@ -107,22 +110,23 @@ fn lower_enum(\n     db: &dyn DefDatabase,\n     trace: &mut Trace<EnumVariantData, ast::EnumVariant>,\n     ast: &InFile<ast::EnumDef>,\n+    module_id: ModuleId,\n ) {\n     for var in ast.value.variant_list().into_iter().flat_map(|it| it.variants()) {\n         trace.alloc(\n             || var.clone(),\n             || EnumVariantData {\n                 name: var.name().map_or_else(Name::missing, |it| it.as_name()),\n-                variant_data: Arc::new(VariantData::new(db, ast.with_value(var.kind()))),\n+                variant_data: Arc::new(VariantData::new(db, ast.with_value(var.kind()), module_id)),\n             },\n         );\n     }\n }\n \n impl VariantData {\n-    fn new(db: &dyn DefDatabase, flavor: InFile<ast::StructKind>) -> Self {\n+    fn new(db: &dyn DefDatabase, flavor: InFile<ast::StructKind>, module_id: ModuleId) -> Self {\n         let mut trace = Trace::new_for_arena();\n-        match lower_struct(db, &mut trace, &flavor) {\n+        match lower_struct(db, &mut trace, &flavor, module_id) {\n             StructKind::Tuple => VariantData::Tuple(trace.into_arena()),\n             StructKind::Record => VariantData::Record(trace.into_arena()),\n             StructKind::Unit => VariantData::Unit,\n@@ -155,22 +159,27 @@ impl HasChildSource for VariantId {\n     type Value = Either<ast::TupleFieldDef, ast::RecordFieldDef>;\n \n     fn child_source(&self, db: &dyn DefDatabase) -> InFile<ArenaMap<Self::ChildId, Self::Value>> {\n-        let src = match self {\n+        let (src, module_id) = match self {\n             VariantId::EnumVariantId(it) => {\n                 // I don't really like the fact that we call into parent source\n                 // here, this might add to more queries then necessary.\n                 let src = it.parent.child_source(db);\n-                src.map(|map| map[it.local_id].kind())\n+                (src.map(|map| map[it.local_id].kind()), it.parent.lookup(db).container.module(db))\n             }\n-            VariantId::StructId(it) => it.lookup(db).source(db).map(|it| it.kind()),\n-            VariantId::UnionId(it) => it.lookup(db).source(db).map(|it| {\n-                it.record_field_def_list()\n-                    .map(ast::StructKind::Record)\n-                    .unwrap_or(ast::StructKind::Unit)\n-            }),\n+            VariantId::StructId(it) => {\n+                (it.lookup(db).source(db).map(|it| it.kind()), it.lookup(db).container.module(db))\n+            }\n+            VariantId::UnionId(it) => (\n+                it.lookup(db).source(db).map(|it| {\n+                    it.record_field_def_list()\n+                        .map(ast::StructKind::Record)\n+                        .unwrap_or(ast::StructKind::Unit)\n+                }),\n+                it.lookup(db).container.module(db),\n+            ),\n         };\n         let mut trace = Trace::new_for_map();\n-        lower_struct(db, &mut trace, &src);\n+        lower_struct(db, &mut trace, &src, module_id);\n         src.with_value(trace.into_map())\n     }\n }\n@@ -186,10 +195,17 @@ fn lower_struct(\n     db: &dyn DefDatabase,\n     trace: &mut Trace<StructFieldData, Either<ast::TupleFieldDef, ast::RecordFieldDef>>,\n     ast: &InFile<ast::StructKind>,\n+    module_id: ModuleId,\n ) -> StructKind {\n+    let crate_graph = db.crate_graph();\n     match &ast.value {\n         ast::StructKind::Tuple(fl) => {\n             for (i, fd) in fl.fields().enumerate() {\n+                let attrs = Attrs::new(&fd, &Hygiene::new(db.upcast(), ast.file_id));\n+                if !attrs.is_cfg_enabled(&crate_graph[module_id.krate].cfg_options) {\n+                    continue;\n+                }\n+\n                 trace.alloc(\n                     || Either::Left(fd.clone()),\n                     || StructFieldData {\n@@ -203,6 +219,11 @@ fn lower_struct(\n         }\n         ast::StructKind::Record(fl) => {\n             for fd in fl.fields() {\n+                let attrs = Attrs::new(&fd, &Hygiene::new(db.upcast(), ast.file_id));\n+                if !attrs.is_cfg_enabled(&crate_graph[module_id.krate].cfg_options) {\n+                    continue;\n+                }\n+\n                 trace.alloc(\n                     || Either::Right(fd.clone()),\n                     || StructFieldData {"}, {"sha": "7b0c506b16b0f669629129d81895849014fd2bfd", "filename": "crates/ra_hir_def/src/attr.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/fc70cf9458c5234decafdd52b9aced790ac43d7a/crates%2Fra_hir_def%2Fsrc%2Fattr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc70cf9458c5234decafdd52b9aced790ac43d7a/crates%2Fra_hir_def%2Fsrc%2Fattr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Fattr.rs?ref=fc70cf9458c5234decafdd52b9aced790ac43d7a", "patch": "@@ -5,6 +5,7 @@ use std::{ops, sync::Arc};\n use either::Either;\n use hir_expand::{hygiene::Hygiene, AstId, InFile};\n use mbe::ast_to_token_tree;\n+use ra_cfg::CfgOptions;\n use ra_syntax::{\n     ast::{self, AstNode, AttrsOwner},\n     SmolStr,\n@@ -90,6 +91,10 @@ impl Attrs {\n     pub fn by_key(&self, key: &'static str) -> AttrQuery<'_> {\n         AttrQuery { attrs: self, key }\n     }\n+\n+    pub(crate) fn is_cfg_enabled(&self, cfg_options: &CfgOptions) -> bool {\n+        self.by_key(\"cfg\").tt_values().all(|tt| cfg_options.is_cfg_enabled(tt) != Some(false))\n+    }\n }\n \n #[derive(Debug, Clone, PartialEq, Eq)]"}, {"sha": "06145e92afc7f675be8e499c994faf3cfd1c51a7", "filename": "crates/ra_hir_def/src/body/lower.rs", "status": "modified", "additions": 33, "deletions": 18, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/fc70cf9458c5234decafdd52b9aced790ac43d7a/crates%2Fra_hir_def%2Fsrc%2Fbody%2Flower.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc70cf9458c5234decafdd52b9aced790ac43d7a/crates%2Fra_hir_def%2Fsrc%2Fbody%2Flower.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Fbody%2Flower.rs?ref=fc70cf9458c5234decafdd52b9aced790ac43d7a", "patch": "@@ -4,6 +4,7 @@\n use either::Either;\n \n use hir_expand::{\n+    hygiene::Hygiene,\n     name::{name, AsName, Name},\n     MacroDefId, MacroDefKind,\n };\n@@ -20,6 +21,7 @@ use test_utils::tested_by;\n use super::{ExprSource, PatSource};\n use crate::{\n     adt::StructKind,\n+    attr::Attrs,\n     body::{Body, BodySourceMap, Expander, PatPtr, SyntheticSyntax},\n     builtin_type::{BuiltinFloat, BuiltinInt},\n     db::DefDatabase,\n@@ -31,8 +33,8 @@ use crate::{\n     path::GenericArgs,\n     path::Path,\n     type_ref::{Mutability, TypeRef},\n-    AdtId, ConstLoc, ContainerId, DefWithBodyId, EnumLoc, FunctionLoc, Intern, ModuleDefId,\n-    StaticLoc, StructLoc, TraitLoc, TypeAliasLoc, UnionLoc,\n+    AdtId, ConstLoc, ContainerId, DefWithBodyId, EnumLoc, FunctionLoc, HasModule, Intern,\n+    ModuleDefId, StaticLoc, StructLoc, TraitLoc, TypeAliasLoc, UnionLoc,\n };\n \n pub(super) fn lower(\n@@ -298,28 +300,41 @@ impl ExprCollector<'_> {\n                 self.alloc_expr(Expr::Return { expr }, syntax_ptr)\n             }\n             ast::Expr::RecordLit(e) => {\n+                let crate_graph = self.db.crate_graph();\n                 let path = e.path().and_then(|path| self.expander.parse_path(path));\n                 let mut field_ptrs = Vec::new();\n                 let record_lit = if let Some(nfl) = e.record_field_list() {\n                     let fields = nfl\n                         .fields()\n                         .inspect(|field| field_ptrs.push(AstPtr::new(field)))\n-                        .map(|field| RecordLitField {\n-                            name: field\n-                                .name_ref()\n-                                .map(|nr| nr.as_name())\n-                                .unwrap_or_else(Name::missing),\n-                            expr: if let Some(e) = field.expr() {\n-                                self.collect_expr(e)\n-                            } else if let Some(nr) = field.name_ref() {\n-                                // field shorthand\n-                                self.alloc_expr_field_shorthand(\n-                                    Expr::Path(Path::from_name_ref(&nr)),\n-                                    AstPtr::new(&field),\n-                                )\n-                            } else {\n-                                self.missing_expr()\n-                            },\n+                        .filter_map(|field| {\n+                            let module_id = ContainerId::DefWithBodyId(self.def).module(self.db);\n+                            let attrs = Attrs::new(\n+                                &field,\n+                                &Hygiene::new(self.db.upcast(), self.expander.current_file_id),\n+                            );\n+\n+                            if !attrs.is_cfg_enabled(&crate_graph[module_id.krate].cfg_options) {\n+                                return None;\n+                            }\n+\n+                            Some(RecordLitField {\n+                                name: field\n+                                    .name_ref()\n+                                    .map(|nr| nr.as_name())\n+                                    .unwrap_or_else(Name::missing),\n+                                expr: if let Some(e) = field.expr() {\n+                                    self.collect_expr(e)\n+                                } else if let Some(nr) = field.name_ref() {\n+                                    // field shorthand\n+                                    self.alloc_expr_field_shorthand(\n+                                        Expr::Path(Path::from_name_ref(&nr)),\n+                                        AstPtr::new(&field),\n+                                    )\n+                                } else {\n+                                    self.missing_expr()\n+                                },\n+                            })\n                         })\n                         .collect();\n                     let spread = nfl.spread().map(|s| self.collect_expr(s));"}, {"sha": "e793ad8740209a02bec27f76145632ba671191b1", "filename": "crates/ra_hir_def/src/data.rs", "status": "modified", "additions": 5, "deletions": 9, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/fc70cf9458c5234decafdd52b9aced790ac43d7a/crates%2Fra_hir_def%2Fsrc%2Fdata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc70cf9458c5234decafdd52b9aced790ac43d7a/crates%2Fra_hir_def%2Fsrc%2Fdata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Fdata.rs?ref=fc70cf9458c5234decafdd52b9aced790ac43d7a", "patch": "@@ -7,7 +7,6 @@ use hir_expand::{\n     name::{name, AsName, Name},\n     AstId, InFile,\n };\n-use ra_cfg::CfgOptions;\n use ra_prof::profile;\n use ra_syntax::ast::{\n     self, AstNode, ImplItem, ModuleItemOwner, NameOwner, TypeAscriptionOwner, VisibilityOwner,\n@@ -318,10 +317,6 @@ fn collect_impl_items_in_macro(\n     }\n }\n \n-fn is_cfg_enabled(cfg_options: &CfgOptions, attrs: &Attrs) -> bool {\n-    attrs.by_key(\"cfg\").tt_values().all(|tt| cfg_options.is_cfg_enabled(tt) != Some(false))\n-}\n-\n fn collect_impl_items(\n     db: &dyn DefDatabase,\n     impl_items: impl Iterator<Item = ImplItem>,\n@@ -341,10 +336,11 @@ fn collect_impl_items(\n                 }\n                 .intern(db);\n \n-                if !is_cfg_enabled(\n-                    &crate_graph[module_id.krate].cfg_options,\n-                    &db.function_data(def).attrs,\n-                ) {\n+                if !db\n+                    .function_data(def)\n+                    .attrs\n+                    .is_cfg_enabled(&crate_graph[module_id.krate].cfg_options)\n+                {\n                     None\n                 } else {\n                     Some(def.into())"}, {"sha": "02f2e5de09fa9e5f01536df4c98466f5af95c274", "filename": "crates/ra_hir_ty/src/tests.rs", "status": "modified", "additions": 60, "deletions": 0, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/fc70cf9458c5234decafdd52b9aced790ac43d7a/crates%2Fra_hir_ty%2Fsrc%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc70cf9458c5234decafdd52b9aced790ac43d7a/crates%2Fra_hir_ty%2Fsrc%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Ftests.rs?ref=fc70cf9458c5234decafdd52b9aced790ac43d7a", "patch": "@@ -349,3 +349,63 @@ fn no_such_field_with_feature_flag_diagnostics() {\n \n     assert_snapshot!(diagnostics, @r###\"\"###);\n }\n+\n+#[test]\n+fn no_such_field_with_feature_flag_diagnostics_on_struct_lit() {\n+    let diagnostics = TestDB::with_files(\n+        r#\"\n+        //- /lib.rs crate:foo cfg:feature=foo\n+        struct S {\n+            #[cfg(feature = \"foo\")]\n+            foo: u32,\n+            #[cfg(not(feature = \"foo\"))]\n+            bar: u32,\n+        }\n+\n+        impl S {\n+            #[cfg(feature = \"foo\")]\n+            fn new(foo: u32) -> Self {\n+                Self { foo }\n+            }\n+            #[cfg(not(feature = \"foo\"))] \n+            fn new(bar: u32) -> Self {\n+                Self { bar }\n+            }\n+        }\n+        \"#,\n+    )\n+    .diagnostics()\n+    .0;\n+\n+    assert_snapshot!(diagnostics, @r###\"\"###);\n+}\n+\n+#[test]\n+fn no_such_field_with_feature_flag_diagnostics_on_struct_fields() {\n+    let diagnostics = TestDB::with_files(\n+        r#\"\n+        //- /lib.rs crate:foo cfg:feature=foo\n+        struct S {\n+            #[cfg(feature = \"foo\")]\n+            foo: u32,\n+            #[cfg(not(feature = \"foo\"))]\n+            bar: u32,\n+        }\n+\n+        impl S {\n+            fn new(val: u32) -> Self {\n+                Self {\n+                    #[cfg(feature = \"foo\")]\n+                    foo: val,\n+                    #[cfg(not(feature = \"foo\"))]\n+                    bar: val,\n+                }\n+            }\n+        }\n+        \"#,\n+    )\n+    .diagnostics()\n+    .0;\n+\n+    assert_snapshot!(diagnostics, @r###\"\"###);\n+}"}, {"sha": "d2b055b0ad4a7dc15bb05569e53e8a969edd387f", "filename": "crates/ra_syntax/src/ast/generated.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/fc70cf9458c5234decafdd52b9aced790ac43d7a/crates%2Fra_syntax%2Fsrc%2Fast%2Fgenerated.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc70cf9458c5234decafdd52b9aced790ac43d7a/crates%2Fra_syntax%2Fsrc%2Fast%2Fgenerated.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Fast%2Fgenerated.rs?ref=fc70cf9458c5234decafdd52b9aced790ac43d7a", "patch": "@@ -5216,6 +5216,7 @@ impl RecordFieldList {\n pub struct RecordField {\n     pub(crate) syntax: SyntaxNode,\n }\n+impl ast::AttrsOwner for RecordField {}\n impl std::fmt::Display for RecordField {\n     fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {\n         std::fmt::Display::fmt(self.syntax(), f)"}]}