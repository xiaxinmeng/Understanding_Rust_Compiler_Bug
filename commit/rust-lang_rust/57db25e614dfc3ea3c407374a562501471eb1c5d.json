{"sha": "57db25e614dfc3ea3c407374a562501471eb1c5d", "node_id": "MDY6Q29tbWl0NzI0NzEyOjU3ZGIyNWU2MTRkZmMzZWEzYzQwNzM3NGE1NjI1MDE0NzFlYjFjNWQ=", "commit": {"author": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2019-06-25T18:37:25Z"}, "committer": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2019-06-25T19:30:21Z"}, "message": "cleanup: rename name_from to symbol_from\n\nLexer uses Symbols for a lot of stuff, not only for identifiers, so\nthe \"name\" terminology is just confusing.", "tree": {"sha": "d2477455828a5ced73ea4214862faf35312db18c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d2477455828a5ced73ea4214862faf35312db18c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/57db25e614dfc3ea3c407374a562501471eb1c5d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/57db25e614dfc3ea3c407374a562501471eb1c5d", "html_url": "https://github.com/rust-lang/rust/commit/57db25e614dfc3ea3c407374a562501471eb1c5d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/57db25e614dfc3ea3c407374a562501471eb1c5d/comments", "author": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "committer": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b75021b31e43d59eb2b91fe45cfffcb7d25fb141", "url": "https://api.github.com/repos/rust-lang/rust/commits/b75021b31e43d59eb2b91fe45cfffcb7d25fb141", "html_url": "https://github.com/rust-lang/rust/commit/b75021b31e43d59eb2b91fe45cfffcb7d25fb141"}], "stats": {"total": 39, "additions": 19, "deletions": 20}, "files": [{"sha": "4e4fe4256c9b0a521834cbc283fcc956736e658b", "filename": "src/libsyntax/parse/lexer/mod.rs", "status": "modified", "additions": 19, "deletions": 20, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/57db25e614dfc3ea3c407374a562501471eb1c5d/src%2Flibsyntax%2Fparse%2Flexer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/57db25e614dfc3ea3c407374a562501471eb1c5d/src%2Flibsyntax%2Fparse%2Flexer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Flexer%2Fmod.rs?ref=57db25e614dfc3ea3c407374a562501471eb1c5d", "patch": "@@ -1,4 +1,3 @@\n-use crate::ast;\n use crate::parse::ParseSess;\n use crate::parse::token::{self, Token, TokenKind};\n use crate::symbol::{sym, Symbol};\n@@ -328,14 +327,14 @@ impl<'a> StringReader<'a> {\n         self.str_from_to(start, self.pos)\n     }\n \n-    /// Creates a Name from a given offset to the current offset.\n-    fn name_from(&self, start: BytePos) -> ast::Name {\n+    /// Creates a Symbol from a given offset to the current offset.\n+    fn symbol_from(&self, start: BytePos) -> Symbol {\n         debug!(\"taking an ident from {:?} to {:?}\", start, self.pos);\n         Symbol::intern(self.str_from(start))\n     }\n \n-    /// As name_from, with an explicit endpoint.\n-    fn name_from_to(&self, start: BytePos, end: BytePos) -> ast::Name {\n+    /// As symbol_from, with an explicit endpoint.\n+    fn symbol_from_to(&self, start: BytePos, end: BytePos) -> Symbol {\n         debug!(\"taking an ident from {:?} to {:?}\", start, end);\n         Symbol::intern(self.str_from_to(start, end))\n     }\n@@ -440,7 +439,7 @@ impl<'a> StringReader<'a> {\n     }\n \n     /// Eats <XID_start><XID_continue>*, if possible.\n-    fn scan_optional_raw_name(&mut self) -> Option<ast::Name> {\n+    fn scan_optional_raw_name(&mut self) -> Option<Symbol> {\n         if !ident_start(self.ch) {\n             return None;\n         }\n@@ -508,7 +507,7 @@ impl<'a> StringReader<'a> {\n                     }\n \n                     let kind = if doc_comment {\n-                        token::DocComment(self.name_from(start_bpos))\n+                        token::DocComment(self.symbol_from(start_bpos))\n                     } else {\n                         token::Comment\n                     };\n@@ -537,7 +536,7 @@ impl<'a> StringReader<'a> {\n                         self.bump();\n                     }\n                     return Some(Token::new(\n-                        token::Shebang(self.name_from(start)),\n+                        token::Shebang(self.symbol_from(start)),\n                         self.mk_sp(start, self.pos),\n                     ));\n                 }\n@@ -719,17 +718,17 @@ impl<'a> StringReader<'a> {\n             let pos = self.pos;\n             self.check_float_base(start_bpos, pos, base);\n \n-            (token::Float, self.name_from(start_bpos))\n+            (token::Float, self.symbol_from(start_bpos))\n         } else {\n             // it might be a float if it has an exponent\n             if self.ch_is('e') || self.ch_is('E') {\n                 self.scan_float_exponent();\n                 let pos = self.pos;\n                 self.check_float_base(start_bpos, pos, base);\n-                return (token::Float, self.name_from(start_bpos));\n+                return (token::Float, self.symbol_from(start_bpos));\n             }\n             // but we certainly have an integer!\n-            (token::Integer, self.name_from(start_bpos))\n+            (token::Integer, self.symbol_from(start_bpos))\n         }\n     }\n \n@@ -831,7 +830,7 @@ impl<'a> StringReader<'a> {\n                 }\n \n                 // FIXME: perform NFKC normalization here. (Issue #2253)\n-                let name = self.name_from(start);\n+                let name = self.symbol_from(start);\n                 if is_raw_ident {\n                     let span = self.mk_sp(raw_start, self.pos);\n                     if !name.can_be_raw() {\n@@ -1006,7 +1005,7 @@ impl<'a> StringReader<'a> {\n                     // lifetimes shouldn't end with a single quote\n                     // if we find one, then this is an invalid character literal\n                     if self.ch_is('\\'') {\n-                        let symbol = self.name_from(start);\n+                        let symbol = self.symbol_from(start);\n                         self.bump();\n                         self.validate_char_escape(start_with_quote);\n                         return Ok(TokenKind::lit(token::Char, symbol, None));\n@@ -1024,7 +1023,7 @@ impl<'a> StringReader<'a> {\n                     // Include the leading `'` in the real identifier, for macro\n                     // expansion purposes. See #12512 for the gory details of why\n                     // this is necessary.\n-                    return Ok(token::Lifetime(self.name_from(start_with_quote)));\n+                    return Ok(token::Lifetime(self.symbol_from(start_with_quote)));\n                 }\n                 let msg = \"unterminated character literal\";\n                 let symbol = self.scan_single_quoted_string(start_with_quote, msg);\n@@ -1052,7 +1051,7 @@ impl<'a> StringReader<'a> {\n                     },\n                     Some('r') => {\n                         let (start, end, hash_count) = self.scan_raw_string();\n-                        let symbol = self.name_from_to(start, end);\n+                        let symbol = self.symbol_from_to(start, end);\n                         self.validate_raw_byte_str_escape(start, end);\n \n                         (token::ByteStrRaw(hash_count), symbol)\n@@ -1073,7 +1072,7 @@ impl<'a> StringReader<'a> {\n             }\n             'r' => {\n                 let (start, end, hash_count) = self.scan_raw_string();\n-                let symbol = self.name_from_to(start, end);\n+                let symbol = self.symbol_from_to(start, end);\n                 self.validate_raw_str_escape(start, end);\n                 let suffix = self.scan_optional_raw_name();\n \n@@ -1174,7 +1173,7 @@ impl<'a> StringReader<'a> {\n \n     fn scan_single_quoted_string(&mut self,\n                                  start_with_quote: BytePos,\n-                                 unterminated_msg: &str) -> ast::Name {\n+                                 unterminated_msg: &str) -> Symbol {\n         // assumes that first `'` is consumed\n         let start = self.pos;\n         // lex `'''` as a single char, for recovery\n@@ -1206,12 +1205,12 @@ impl<'a> StringReader<'a> {\n             }\n         }\n \n-        let id = self.name_from(start);\n+        let id = self.symbol_from(start);\n         self.bump();\n         id\n     }\n \n-    fn scan_double_quoted_string(&mut self, unterminated_msg: &str) -> ast::Name {\n+    fn scan_double_quoted_string(&mut self, unterminated_msg: &str) -> Symbol {\n         debug_assert!(self.ch_is('\\\"'));\n         let start_with_quote = self.pos;\n         self.bump();\n@@ -1226,7 +1225,7 @@ impl<'a> StringReader<'a> {\n             }\n             self.bump();\n         }\n-        let id = self.name_from(start);\n+        let id = self.symbol_from(start);\n         self.bump();\n         id\n     }"}]}