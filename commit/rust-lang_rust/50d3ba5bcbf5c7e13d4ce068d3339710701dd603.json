{"sha": "50d3ba5bcbf5c7e13d4ce068d3339710701dd603", "node_id": "C_kwDOAAsO6NoAKDUwZDNiYTViY2JmNWM3ZTEzZDRjZTA2OGQzMzM5NzEwNzAxZGQ2MDM", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-02-04T21:07:10Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-02-04T21:07:10Z"}, "message": "Auto merge of #107672 - matthiaskrgr:rollup-7e6dbuk, r=matthiaskrgr\n\nRollup of 3 pull requests\n\nSuccessful merges:\n\n - #107116 (consolidate bootstrap docs)\n - #107646 (Provide structured suggestion for binding needing type on E0594)\n - #107661 (Remove Esteban from review queues for a while)\n\nFailed merges:\n\nr? `@ghost`\n`@rustbot` modify labels: rollup", "tree": {"sha": "932463b8bde694e38b6ed2bd27d772fc2ce0255f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/932463b8bde694e38b6ed2bd27d772fc2ce0255f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/50d3ba5bcbf5c7e13d4ce068d3339710701dd603", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/50d3ba5bcbf5c7e13d4ce068d3339710701dd603", "html_url": "https://github.com/rust-lang/rust/commit/50d3ba5bcbf5c7e13d4ce068d3339710701dd603", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/50d3ba5bcbf5c7e13d4ce068d3339710701dd603/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3de7d7fb22a579a3d59ddb1c959d1b3da224aafa", "url": "https://api.github.com/repos/rust-lang/rust/commits/3de7d7fb22a579a3d59ddb1c959d1b3da224aafa", "html_url": "https://github.com/rust-lang/rust/commit/3de7d7fb22a579a3d59ddb1c959d1b3da224aafa"}, {"sha": "47fc625a921aed430c08d6015246e65362256343", "url": "https://api.github.com/repos/rust-lang/rust/commits/47fc625a921aed430c08d6015246e65362256343", "html_url": "https://github.com/rust-lang/rust/commit/47fc625a921aed430c08d6015246e65362256343"}], "stats": {"total": 423, "additions": 139, "deletions": 284}, "files": [{"sha": "9f37b915b773a7e611f1aa6d0bc48bcd4a7a5d41", "filename": "compiler/rustc_borrowck/src/diagnostics/mutability_errors.rs", "status": "modified", "additions": 57, "deletions": 6, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/50d3ba5bcbf5c7e13d4ce068d3339710701dd603/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fmutability_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/50d3ba5bcbf5c7e13d4ce068d3339710701dd603/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fmutability_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fmutability_errors.rs?ref=50d3ba5bcbf5c7e13d4ce068d3339710701dd603", "patch": "@@ -606,12 +606,63 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n                                 }\n                             }\n                             Some((false, err_label_span, message)) => {\n-                                err.span_label(\n-                                    err_label_span,\n-                                    &format!(\n-                                        \"consider changing this binding's type to be: `{message}`\"\n-                                    ),\n-                                );\n+                                struct BindingFinder {\n+                                    span: Span,\n+                                    hir_id: Option<hir::HirId>,\n+                                }\n+\n+                                impl<'tcx> Visitor<'tcx> for BindingFinder {\n+                                    fn visit_stmt(&mut self, s: &'tcx hir::Stmt<'tcx>) {\n+                                        if let hir::StmtKind::Local(local) = s.kind {\n+                                            if local.pat.span == self.span {\n+                                                self.hir_id = Some(local.hir_id);\n+                                            }\n+                                        }\n+                                        hir::intravisit::walk_stmt(self, s);\n+                                    }\n+                                }\n+                                let hir_map = self.infcx.tcx.hir();\n+                                let def_id = self.body.source.def_id();\n+                                let hir_id = hir_map.local_def_id_to_hir_id(def_id.expect_local());\n+                                let node = hir_map.find(hir_id);\n+                                let hir_id = if let Some(hir::Node::Item(item)) = node\n+                                    && let hir::ItemKind::Fn(.., body_id) = item.kind\n+                                {\n+                                    let body = hir_map.body(body_id);\n+                                    let mut v = BindingFinder {\n+                                        span: err_label_span,\n+                                        hir_id: None,\n+                                    };\n+                                    v.visit_body(body);\n+                                    v.hir_id\n+                                } else {\n+                                    None\n+                                };\n+                                if let Some(hir_id) = hir_id\n+                                    && let Some(hir::Node::Local(local)) = hir_map.find(hir_id)\n+                                {\n+                                    let (changing, span, sugg) = match local.ty {\n+                                        Some(ty) => (\"changing\", ty.span, message),\n+                                        None => (\n+                                            \"specifying\",\n+                                            local.pat.span.shrink_to_hi(),\n+                                            format!(\": {message}\"),\n+                                        ),\n+                                    };\n+                                    err.span_suggestion_verbose(\n+                                        span,\n+                                        &format!(\"consider {changing} this binding's type\"),\n+                                        sugg,\n+                                        Applicability::HasPlaceholders,\n+                                    );\n+                                } else {\n+                                    err.span_label(\n+                                        err_label_span,\n+                                        &format!(\n+                                            \"consider changing this binding's type to be: `{message}`\"\n+                                        ),\n+                                    );\n+                                }\n                             }\n                             None => {}\n                         }"}, {"sha": "71eee8968e272e66593286e252455c53460c265c", "filename": "src/bootstrap/README.md", "status": "modified", "additions": 38, "deletions": 161, "changes": 199, "blob_url": "https://github.com/rust-lang/rust/blob/50d3ba5bcbf5c7e13d4ce068d3339710701dd603/src%2Fbootstrap%2FREADME.md", "raw_url": "https://github.com/rust-lang/rust/raw/50d3ba5bcbf5c7e13d4ce068d3339710701dd603/src%2Fbootstrap%2FREADME.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2FREADME.md?ref=50d3ba5bcbf5c7e13d4ce068d3339710701dd603", "patch": "@@ -4,105 +4,31 @@ This is an in-progress README which is targeted at helping to explain how Rust\n is bootstrapped and in general, some of the technical details of the build\n system.\n \n-## Using rustbuild\n+Note that this README only covers internal information, not how to use the tool.\n+Please check [bootstrapping dev guide][bootstrapping-dev-guide] for further information.\n \n-The rustbuild build system has a primary entry point, a top level `x.py` script:\n+[bootstrapping-dev-guide]: https://rustc-dev-guide.rust-lang.org/building/bootstrapping.html\n \n-```sh\n-$ python ./x.py build\n-```\n-\n-Note that if you're on Unix, you should be able to execute the script directly:\n-\n-```sh\n-$ ./x.py build\n-```\n-\n-The script accepts commands, flags, and arguments to determine what to do:\n-\n-* `build` - a general purpose command for compiling code. Alone, `build` will\n-  bootstrap the entire compiler, and otherwise, arguments passed indicate what to\n-  build. For example:\n-\n-  ```\n-  # build the whole compiler\n-  ./x.py build --stage 2\n-\n-  # build the stage1 compiler\n-  ./x.py build\n-\n-  # build stage0 libstd\n-  ./x.py build --stage 0 library/std\n-\n-  # build a particular crate in stage0\n-  ./x.py build --stage 0 library/test\n-  ```\n-\n-  If files that would normally be rebuilt from stage 0 are dirty, the rebuild can be\n-  overridden using `--keep-stage 0`. Using `--keep-stage n` will skip all steps\n-  that belong to stage n or earlier:\n-\n-  ```\n-  # build stage 1, keeping old build products for stage 0\n-  ./x.py build --keep-stage 0\n-  ```\n-\n-* `test` - a command for executing unit tests. Like the `build` command, this\n-  will execute the entire test suite by default, and otherwise, it can be used to\n-  select which test suite is run:\n-\n-  ```\n-  # run all unit tests\n-  ./x.py test\n-\n-  # execute tool tests\n-  ./x.py test tidy\n-\n-  # execute the UI test suite\n-  ./x.py test tests/ui\n-\n-  # execute only some tests in the UI test suite\n-  ./x.py test tests/ui --test-args substring-of-test-name\n-\n-  # execute tests in the standard library in stage0\n-  ./x.py test --stage 0 library/std\n-\n-  # execute tests in the core and standard library in stage0,\n-  # without running doc tests (thus avoid depending on building the compiler)\n-  ./x.py test --stage 0 --no-doc library/core library/std\n+## Introduction\n \n-  # execute all doc tests\n-  ./x.py test src/doc\n-  ```\n+The build system defers most of the complicated logic managing invocations\n+of rustc and rustdoc to Cargo itself. However, moving through various stages\n+and copying artifacts is still necessary for it to do. Each time rustbuild\n+is invoked, it will iterate through the list of predefined steps and execute\n+each serially in turn if it matches the paths passed or is a default rule.\n+For each step rustbuild relies on the step internally being incremental and\n+parallel. Note, though, that the `-j` parameter to rustbuild gets forwarded\n+to appropriate test harnesses and such.\n \n-* `doc` - a command for building documentation. Like above, can take arguments\n-  for what to document.\n-\n-## Configuring rustbuild\n-\n-rustbuild offers a TOML-based configuration system with a `config.toml`\n-file. An example of this configuration can be found at `config.toml.example`,\n-and the configuration file can also be passed as `--config path/to/config.toml`\n-if the build system is being invoked manually (via the python script).\n-\n-You can generate a config.toml using `./configure` options if you want to automate creating the file without having to edit it.\n-\n-Finally, rustbuild makes use of the [cc-rs crate] which has [its own\n-method][env-vars] of configuring C compilers and C flags via environment\n-variables.\n-\n-[cc-rs crate]: https://github.com/alexcrichton/cc-rs\n-[env-vars]: https://github.com/alexcrichton/cc-rs#external-configuration-via-environment-variables\n-\n-## Build stages\n+## Build phases\n \n The rustbuild build system goes through a few phases to actually build the\n compiler. What actually happens when you invoke rustbuild is:\n \n-1. The entry point script, `x.py` is run. This script is\n-   responsible for downloading the stage0 compiler/Cargo binaries, and it then\n-   compiles the build system itself (this folder). Finally, it then invokes the\n-   actual `bootstrap` binary build system.\n+1. The entry point script(`x` for unix like systems, `x.ps1` for windows systems,\n+   `x.py` cross-platform) is run. This script is responsible for downloading the stage0\n+   compiler/Cargo binaries, and it then compiles the build system itself (this folder).\n+   Finally, it then invokes the actual `bootstrap` binary build system.\n 2. In Rust, `bootstrap` will slurp up all configuration, perform a number of\n    sanity checks (whether compilers exist, for example), and then start building the\n    stage0 artifacts.\n@@ -115,24 +41,6 @@ compiler. What actually happens when you invoke rustbuild is:\n The goal of each stage is to (a) leverage Cargo as much as possible and failing\n that (b) leverage Rust as much as possible!\n \n-## Incremental builds\n-\n-You can configure rustbuild to use incremental compilation with the\n-`--incremental` flag:\n-\n-```sh\n-$ ./x.py build --incremental\n-```\n-\n-The `--incremental` flag will store incremental compilation artifacts\n-in `build/<host>/stage0-incremental`. Note that we only use incremental\n-compilation for the stage0 -> stage1 compilation -- this is because\n-the stage1 compiler is changing, and we don't try to cache and reuse\n-incremental artifacts across different versions of the compiler.\n-\n-You can always drop the `--incremental` to build as normal (but you\n-will still be using the local nightly as your bootstrap).\n-\n ## Directory Layout\n \n This build system houses all output under the `build` directory, which looks\n@@ -236,63 +144,31 @@ build/\n     # system will link (using hard links) output from stageN-{std,rustc} into\n     # each of these directories.\n     #\n-    # In theory, there is no extra build output in these directories.\n+    # In theory these are working rustc sysroot directories, meaning there is\n+    # no extra build output in these directories.\n     stage1/\n     stage2/\n     stage3/\n ```\n \n-## Cargo projects\n-\n-The current build is unfortunately not quite as simple as `cargo build` in a\n-directory, but rather the compiler is split into three different Cargo projects:\n-\n-* `library/std` - the standard library\n-* `library/test` - testing support, depends on libstd\n-* `compiler/rustc` - the actual compiler itself\n-\n-Each \"project\" has a corresponding Cargo.lock file with all dependencies, and\n-this means that building the compiler involves running Cargo three times. The\n-structure here serves two goals:\n-\n-1. Facilitating dependencies coming from crates.io. These dependencies don't\n-   depend on `std`, so libstd is a separate project compiled ahead of time\n-   before the actual compiler builds.\n-2. Splitting \"host artifacts\" from \"target artifacts\". That is, when building\n-   code for an arbitrary target, you don't need the entire compiler, but you'll\n-   end up needing libraries like libtest that depend on std but also want to use\n-   crates.io dependencies. Hence, libtest is split out as its own project that\n-   is sequenced after `std` but before `rustc`. This project is built for all\n-   targets.\n-\n-There is some loss in build parallelism here because libtest can be compiled in\n-parallel with a number of rustc artifacts, but in theory, the loss isn't too bad!\n-\n-## Build tools\n-\n-We've actually got quite a few tools that we use in the compiler's build system\n-and for testing. To organize these, each tool is a project in `src/tools` with a\n-corresponding `Cargo.toml`. All tools are compiled with Cargo (currently having\n-independent `Cargo.lock` files) and do not currently explicitly depend on the\n-compiler or standard library. Compiling each tool is sequenced after the\n-appropriate libstd/libtest/librustc compile above.\n-\n ## Extending rustbuild\n \n-So, you'd like to add a feature to the rustbuild build system or just fix a bug.\n-Great! One of the major motivational factors for moving away from `make` is that\n-Rust is in theory much easier to read, modify, and write. If you find anything\n-excessively confusing, please open an issue on this, and we'll try to get it\n-documented or simplified, pronto.\n+When you use the bootstrap system, you'll call it through the entry point script\n+(`x`, `x.ps1`, or `x.py`). However, most of the code lives in `src/bootstrap`.\n+`bootstrap` has a difficult problem: it is written in Rust, but yet it is run\n+before the Rust compiler is built! To work around this, there are two components\n+of bootstrap: the main one written in rust, and `bootstrap.py`. `bootstrap.py`\n+is what gets run by entry point script. It takes care of downloading the `stage0`\n+compiler, which will then build the bootstrap binary written in Rust.\n \n-First up, you'll probably want to read over the documentation above, as that'll\n-give you a high level overview of what rustbuild is doing. You also probably\n-want to play around a bit yourself by just getting it up and running before you\n-dive too much into the actual build system itself.\n+Because there are two separate codebases behind `x.py`, they need to\n+be kept in sync. In particular, both `bootstrap.py` and the bootstrap binary\n+parse `config.toml` and read the same command line arguments. `bootstrap.py`\n+keeps these in sync by setting various environment variables, and the\n+programs sometimes have to add arguments that are explicitly ignored, to be\n+read by the other.\n \n-After that, each module in rustbuild should have enough documentation to keep\n-you up and running. Some general areas that you may be interested in modifying\n-are:\n+Some general areas that you may be interested in modifying are:\n \n * Adding a new build tool? Take a look at `bootstrap/tool.rs` for examples of\n   other tools.\n@@ -320,8 +196,9 @@ A 'major change' includes\n Changes that do not affect contributors to the compiler or users\n building rustc from source don't need an update to `VERSION`.\n \n-If you have any questions, feel free to reach out on the `#t-infra` channel in\n-the [Rust Zulip server][rust-zulip] or ask on internals.rust-lang.org. When\n-you encounter bugs, please file issues on the rust-lang/rust issue tracker.\n+If you have any questions, feel free to reach out on the `#t-infra/bootstrap` channel\n+at [Rust Bootstrap Zulip server][rust-bootstrap-zulip]. When you encounter bugs,\n+please file issues on the [Rust issue tracker][rust-issue-tracker].\n \n-[rust-zulip]: https://rust-lang.zulipchat.com/#narrow/stream/242791-t-infra\n+[rust-bootstrap-zulip]: https://rust-lang.zulipchat.com/#narrow/stream/t-infra.2Fbootstrap\n+[rust-issue-tracker]: https://github.com/rust-lang/rust/issues"}, {"sha": "f4abdf1cc57589e51c8c8aec36e07e48dfdecac9", "filename": "src/bootstrap/lib.rs", "status": "modified", "additions": 0, "deletions": 87, "changes": 87, "blob_url": "https://github.com/rust-lang/rust/blob/50d3ba5bcbf5c7e13d4ce068d3339710701dd603/src%2Fbootstrap%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/50d3ba5bcbf5c7e13d4ce068d3339710701dd603/src%2Fbootstrap%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Flib.rs?ref=50d3ba5bcbf5c7e13d4ce068d3339710701dd603", "patch": "@@ -11,93 +11,6 @@\n //!   crates.io and Cargo.\n //! * A standard interface to build across all platforms, including MSVC\n //!\n-//! ## Architecture\n-//!\n-//! The build system defers most of the complicated logic managing invocations\n-//! of rustc and rustdoc to Cargo itself. However, moving through various stages\n-//! and copying artifacts is still necessary for it to do. Each time rustbuild\n-//! is invoked, it will iterate through the list of predefined steps and execute\n-//! each serially in turn if it matches the paths passed or is a default rule.\n-//! For each step rustbuild relies on the step internally being incremental and\n-//! parallel. Note, though, that the `-j` parameter to rustbuild gets forwarded\n-//! to appropriate test harnesses and such.\n-//!\n-//! Most of the \"meaty\" steps that matter are backed by Cargo, which does indeed\n-//! have its own parallelism and incremental management. Later steps, like\n-//! tests, aren't incremental and simply run the entire suite currently.\n-//! However, compiletest itself tries to avoid running tests when the artifacts\n-//! that are involved (mainly the compiler) haven't changed.\n-//!\n-//! When you execute `x.py build`, the steps executed are:\n-//!\n-//! * First, the python script is run. This will automatically download the\n-//!   stage0 rustc and cargo according to `src/stage0.json`, or use the cached\n-//!   versions if they're available. These are then used to compile rustbuild\n-//!   itself (using Cargo). Finally, control is then transferred to rustbuild.\n-//!\n-//! * Rustbuild takes over, performs sanity checks, probes the environment,\n-//!   reads configuration, and starts executing steps as it reads the command\n-//!   line arguments (paths) or going through the default rules.\n-//!\n-//!   The build output will be something like the following:\n-//!\n-//!   Building stage0 std artifacts\n-//!   Copying stage0 std\n-//!   Building stage0 test artifacts\n-//!   Copying stage0 test\n-//!   Building stage0 compiler artifacts\n-//!   Copying stage0 rustc\n-//!   Assembling stage1 compiler\n-//!   Building stage1 std artifacts\n-//!   Copying stage1 std\n-//!   Building stage1 test artifacts\n-//!   Copying stage1 test\n-//!   Building stage1 compiler artifacts\n-//!   Copying stage1 rustc\n-//!   Assembling stage2 compiler\n-//!   Uplifting stage1 std\n-//!   Uplifting stage1 test\n-//!   Uplifting stage1 rustc\n-//!\n-//! Let's disect that a little:\n-//!\n-//! ## Building stage0 {std,test,compiler} artifacts\n-//!\n-//! These steps use the provided (downloaded, usually) compiler to compile the\n-//! local Rust source into libraries we can use.\n-//!\n-//! ## Copying stage0 {std,test,rustc}\n-//!\n-//! This copies the build output from Cargo into\n-//! `build/$HOST/stage0-sysroot/lib/rustlib/$ARCH/lib`. FIXME: this step's\n-//! documentation should be expanded -- the information already here may be\n-//! incorrect.\n-//!\n-//! ## Assembling stage1 compiler\n-//!\n-//! This copies the libraries we built in \"building stage0 ... artifacts\" into\n-//! the stage1 compiler's lib directory. These are the host libraries that the\n-//! compiler itself uses to run. These aren't actually used by artifacts the new\n-//! compiler generates. This step also copies the rustc and rustdoc binaries we\n-//! generated into build/$HOST/stage/bin.\n-//!\n-//! The stage1/bin/rustc is a fully functional compiler, but it doesn't yet have\n-//! any libraries to link built binaries or libraries to. The next 3 steps will\n-//! provide those libraries for it; they are mostly equivalent to constructing\n-//! the stage1/bin compiler so we don't go through them individually.\n-//!\n-//! ## Uplifting stage1 {std,test,rustc}\n-//!\n-//! This step copies the libraries from the stage1 compiler sysroot into the\n-//! stage2 compiler. This is done to avoid rebuilding the compiler; libraries\n-//! we'd build in this step should be identical (in function, if not necessarily\n-//! identical on disk) so there's no need to recompile the compiler again. Note\n-//! that if you want to, you can enable the full-bootstrap option to change this\n-//! behavior.\n-//!\n-//! Each step is driven by a separate Cargo project and rustbuild orchestrates\n-//! copying files between steps and otherwise preparing for Cargo to run.\n-//!\n //! ## Further information\n //!\n //! More documentation can be found in each respective module below, and you can"}, {"sha": "dd0817ff2331368ac12daa488cafed47f33477ad", "filename": "tests/ui/borrowck/borrowck-borrow-mut-base-ptr-in-aliasable-loc.stderr", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/50d3ba5bcbf5c7e13d4ce068d3339710701dd603/tests%2Fui%2Fborrowck%2Fborrowck-borrow-mut-base-ptr-in-aliasable-loc.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/50d3ba5bcbf5c7e13d4ce068d3339710701dd603/tests%2Fui%2Fborrowck%2Fborrowck-borrow-mut-base-ptr-in-aliasable-loc.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fborrowck%2Fborrowck-borrow-mut-base-ptr-in-aliasable-loc.stderr?ref=50d3ba5bcbf5c7e13d4ce068d3339710701dd603", "patch": "@@ -1,11 +1,13 @@\n error[E0594]: cannot assign to `**t1`, which is behind a `&` reference\n   --> $DIR/borrowck-borrow-mut-base-ptr-in-aliasable-loc.rs:9:5\n    |\n-LL |     let t1 = t0;\n-   |         -- consider changing this binding's type to be: `&mut &mut isize`\n-LL |     let p: &isize = &**t0;\n LL |     **t1 = 22;\n    |     ^^^^^^^^^ `t1` is a `&` reference, so the data it refers to cannot be written\n+   |\n+help: consider specifying this binding's type\n+   |\n+LL |     let t1: &mut &mut isize = t0;\n+   |           +++++++++++++++++\n \n error[E0502]: cannot borrow `**t0` as immutable because it is also borrowed as mutable\n   --> $DIR/borrowck-borrow-mut-base-ptr-in-aliasable-loc.rs:14:21"}, {"sha": "76e0b517354168c32ec4b4462bf417e948c9c6f9", "filename": "tests/ui/borrowck/issue-85765.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/50d3ba5bcbf5c7e13d4ce068d3339710701dd603/tests%2Fui%2Fborrowck%2Fissue-85765.rs", "raw_url": "https://github.com/rust-lang/rust/raw/50d3ba5bcbf5c7e13d4ce068d3339710701dd603/tests%2Fui%2Fborrowck%2Fissue-85765.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fborrowck%2Fissue-85765.rs?ref=50d3ba5bcbf5c7e13d4ce068d3339710701dd603", "patch": "@@ -1,7 +1,7 @@\n fn main() {\n     let mut test = Vec::new();\n     let rofl: &Vec<Vec<i32>> = &mut test;\n-    //~^ NOTE consider changing this binding's type to be\n+    //~^ HELP consider changing this binding's type\n     rofl.push(Vec::new());\n     //~^ ERROR cannot borrow `*rofl` as mutable, as it is behind a `&` reference\n     //~| NOTE `rofl` is a `&` reference, so the data it refers to cannot be borrowed as mutable\n@@ -15,14 +15,14 @@ fn main() {\n \n     #[rustfmt::skip]\n     let x: &usize = &mut{0};\n-    //~^ NOTE consider changing this binding's type to be\n+    //~^ HELP consider changing this binding's type\n     *x = 1;\n     //~^ ERROR cannot assign to `*x`, which is behind a `&` reference\n     //~| NOTE `x` is a `&` reference, so the data it refers to cannot be written\n \n     #[rustfmt::skip]\n     let y: &usize = &mut(0);\n-    //~^ NOTE consider changing this binding's type to be\n+    //~^ HELP consider changing this binding's type\n     *y = 1;\n     //~^ ERROR cannot assign to `*y`, which is behind a `&` reference\n     //~| NOTE `y` is a `&` reference, so the data it refers to cannot be written"}, {"sha": "b4bb128cbb420ffc881ecf1cec67f3ec5366f8b4", "filename": "tests/ui/borrowck/issue-85765.stderr", "status": "modified", "additions": 15, "deletions": 9, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/50d3ba5bcbf5c7e13d4ce068d3339710701dd603/tests%2Fui%2Fborrowck%2Fissue-85765.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/50d3ba5bcbf5c7e13d4ce068d3339710701dd603/tests%2Fui%2Fborrowck%2Fissue-85765.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fborrowck%2Fissue-85765.stderr?ref=50d3ba5bcbf5c7e13d4ce068d3339710701dd603", "patch": "@@ -1,11 +1,13 @@\n error[E0596]: cannot borrow `*rofl` as mutable, as it is behind a `&` reference\n   --> $DIR/issue-85765.rs:5:5\n    |\n-LL |     let rofl: &Vec<Vec<i32>> = &mut test;\n-   |         ---- consider changing this binding's type to be: `&mut Vec<Vec<i32>>`\n-LL |\n LL |     rofl.push(Vec::new());\n    |     ^^^^^^^^^^^^^^^^^^^^^ `rofl` is a `&` reference, so the data it refers to cannot be borrowed as mutable\n+   |\n+help: consider changing this binding's type\n+   |\n+LL |     let rofl: &mut Vec<Vec<i32>> = &mut test;\n+   |               ~~~~~~~~~~~~~~~~~~\n \n error[E0594]: cannot assign to `*r`, which is behind a `&` reference\n   --> $DIR/issue-85765.rs:12:5\n@@ -21,20 +23,24 @@ LL |     let r = &mut mutvar;\n error[E0594]: cannot assign to `*x`, which is behind a `&` reference\n   --> $DIR/issue-85765.rs:19:5\n    |\n-LL |     let x: &usize = &mut{0};\n-   |         - consider changing this binding's type to be: `&mut usize`\n-LL |\n LL |     *x = 1;\n    |     ^^^^^^ `x` is a `&` reference, so the data it refers to cannot be written\n+   |\n+help: consider changing this binding's type\n+   |\n+LL |     let x: &mut usize = &mut{0};\n+   |            ~~~~~~~~~~\n \n error[E0594]: cannot assign to `*y`, which is behind a `&` reference\n   --> $DIR/issue-85765.rs:26:5\n    |\n-LL |     let y: &usize = &mut(0);\n-   |         - consider changing this binding's type to be: `&mut usize`\n-LL |\n LL |     *y = 1;\n    |     ^^^^^^ `y` is a `&` reference, so the data it refers to cannot be written\n+   |\n+help: consider changing this binding's type\n+   |\n+LL |     let y: &mut usize = &mut(0);\n+   |            ~~~~~~~~~~\n \n error: aborting due to 4 previous errors\n "}, {"sha": "e062a253767ded6ab491ae70d47ed53eb8fd10e4", "filename": "tests/ui/borrowck/issue-91206.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/50d3ba5bcbf5c7e13d4ce068d3339710701dd603/tests%2Fui%2Fborrowck%2Fissue-91206.rs", "raw_url": "https://github.com/rust-lang/rust/raw/50d3ba5bcbf5c7e13d4ce068d3339710701dd603/tests%2Fui%2Fborrowck%2Fissue-91206.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fborrowck%2Fissue-91206.rs?ref=50d3ba5bcbf5c7e13d4ce068d3339710701dd603", "patch": "@@ -9,7 +9,7 @@ impl TestClient {\n fn main() {\n     let client = TestClient;\n     let inner = client.get_inner_ref();\n-    //~^ NOTE consider changing this binding's type to be\n+    //~^ HELP consider specifying this binding's type\n     inner.clear();\n     //~^ ERROR cannot borrow `*inner` as mutable, as it is behind a `&` reference [E0596]\n     //~| NOTE `inner` is a `&` reference, so the data it refers to cannot be borrowed as mutable"}, {"sha": "6653d497873e79d058a20ac347d94d93d7520ea5", "filename": "tests/ui/borrowck/issue-91206.stderr", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/50d3ba5bcbf5c7e13d4ce068d3339710701dd603/tests%2Fui%2Fborrowck%2Fissue-91206.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/50d3ba5bcbf5c7e13d4ce068d3339710701dd603/tests%2Fui%2Fborrowck%2Fissue-91206.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fborrowck%2Fissue-91206.stderr?ref=50d3ba5bcbf5c7e13d4ce068d3339710701dd603", "patch": "@@ -1,11 +1,13 @@\n error[E0596]: cannot borrow `*inner` as mutable, as it is behind a `&` reference\n   --> $DIR/issue-91206.rs:13:5\n    |\n-LL |     let inner = client.get_inner_ref();\n-   |         ----- consider changing this binding's type to be: `&mut Vec<usize>`\n-LL |\n LL |     inner.clear();\n    |     ^^^^^^^^^^^^^ `inner` is a `&` reference, so the data it refers to cannot be borrowed as mutable\n+   |\n+help: consider specifying this binding's type\n+   |\n+LL |     let inner: &mut Vec<usize> = client.get_inner_ref();\n+   |              +++++++++++++++++\n \n error: aborting due to previous error\n "}, {"sha": "ea4f9abb87d9adeab8fafe633bc6a09591ee8197", "filename": "tests/ui/borrowck/issue-92015.stderr", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/50d3ba5bcbf5c7e13d4ce068d3339710701dd603/tests%2Fui%2Fborrowck%2Fissue-92015.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/50d3ba5bcbf5c7e13d4ce068d3339710701dd603/tests%2Fui%2Fborrowck%2Fissue-92015.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fborrowck%2Fissue-92015.stderr?ref=50d3ba5bcbf5c7e13d4ce068d3339710701dd603", "patch": "@@ -1,10 +1,13 @@\n error[E0594]: cannot assign to `*foo`, which is behind a `&` reference\n   --> $DIR/issue-92015.rs:6:5\n    |\n-LL |     let foo = Some(&0).unwrap();\n-   |         --- consider changing this binding's type to be: `&mut i32`\n LL |     *foo = 1;\n    |     ^^^^^^^^ `foo` is a `&` reference, so the data it refers to cannot be written\n+   |\n+help: consider specifying this binding's type\n+   |\n+LL |     let foo: &mut i32 = Some(&0).unwrap();\n+   |            ++++++++++\n \n error: aborting due to previous error\n "}, {"sha": "84e09afac0a2dca67beff200753c983da299d3b7", "filename": "tests/ui/issues/issue-51515.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/50d3ba5bcbf5c7e13d4ce068d3339710701dd603/tests%2Fui%2Fissues%2Fissue-51515.rs", "raw_url": "https://github.com/rust-lang/rust/raw/50d3ba5bcbf5c7e13d4ce068d3339710701dd603/tests%2Fui%2Fissues%2Fissue-51515.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fissues%2Fissue-51515.rs?ref=50d3ba5bcbf5c7e13d4ce068d3339710701dd603", "patch": "@@ -5,6 +5,7 @@ fn main() {\n     *foo = 32;\n     //~^ ERROR cannot assign to `*foo`, which is behind a `&` reference\n     let bar = foo;\n+    //~^ HELP consider specifying this binding's type\n     *bar = 64;\n     //~^ ERROR cannot assign to `*bar`, which is behind a `&` reference\n }"}, {"sha": "94e5c9f1b832a6e019e1c8273ba76f4c7c448c45", "filename": "tests/ui/issues/issue-51515.stderr", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/50d3ba5bcbf5c7e13d4ce068d3339710701dd603/tests%2Fui%2Fissues%2Fissue-51515.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/50d3ba5bcbf5c7e13d4ce068d3339710701dd603/tests%2Fui%2Fissues%2Fissue-51515.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fissues%2Fissue-51515.stderr?ref=50d3ba5bcbf5c7e13d4ce068d3339710701dd603", "patch": "@@ -10,12 +10,15 @@ LL |     let foo = &mut 16;\n    |               ~~~~~~~\n \n error[E0594]: cannot assign to `*bar`, which is behind a `&` reference\n-  --> $DIR/issue-51515.rs:8:5\n+  --> $DIR/issue-51515.rs:9:5\n    |\n-LL |     let bar = foo;\n-   |         --- consider changing this binding's type to be: `&mut i32`\n LL |     *bar = 64;\n    |     ^^^^^^^^^ `bar` is a `&` reference, so the data it refers to cannot be written\n+   |\n+help: consider specifying this binding's type\n+   |\n+LL |     let bar: &mut i32 = foo;\n+   |            ++++++++++\n \n error: aborting due to 2 previous errors\n "}, {"sha": "62a99b704388fc857d527e61f96b5cf407c43a24", "filename": "triagebot.toml", "status": "modified", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/50d3ba5bcbf5c7e13d4ce068d3339710701dd603/triagebot.toml", "raw_url": "https://github.com/rust-lang/rust/raw/50d3ba5bcbf5c7e13d4ce068d3339710701dd603/triagebot.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/triagebot.toml?ref=50d3ba5bcbf5c7e13d4ce068d3339710701dd603", "patch": "@@ -441,15 +441,15 @@ cc = [\"@oli-obk\", \"@RalfJung\", \"@JakobDegen\", \"@davidtwco\", \"@celinval\", \"@vakar\n \n [mentions.\"compiler/rustc_error_messages\"]\n message = \"`rustc_error_messages` was changed\"\n-cc = [\"@davidtwco\", \"@compiler-errors\", \"@JohnTitor\", \"@estebank\", \"@TaKO8Ki\"]\n+cc = [\"@davidtwco\", \"@compiler-errors\", \"@JohnTitor\", \"@TaKO8Ki\"]\n \n [mentions.\"compiler/rustc_errors/src/translation.rs\"]\n message = \"`rustc_errors::translation` was changed\"\n-cc = [\"@davidtwco\", \"@compiler-errors\", \"@JohnTitor\", \"@estebank\", \"@TaKO8Ki\"]\n+cc = [\"@davidtwco\", \"@compiler-errors\", \"@JohnTitor\", \"@TaKO8Ki\"]\n \n [mentions.\"compiler/rustc_macros/src/diagnostics\"]\n message = \"`rustc_macros::diagnostics` was changed\"\n-cc = [\"@davidtwco\", \"@compiler-errors\", \"@JohnTitor\", \"@estebank\", \"@TaKO8Ki\"]\n+cc = [\"@davidtwco\", \"@compiler-errors\", \"@JohnTitor\", \"@TaKO8Ki\"]\n \n [mentions.\"compiler/rustc_target/src/spec\"]\n message = \"\"\"\n@@ -475,7 +475,6 @@ contributing_url = \"https://rustc-dev-guide.rust-lang.org/contributing.html\"\n [assign.adhoc_groups]\n compiler-team = [\n     \"@cjgillot\",\n-    \"@estebank\",\n     \"@petrochenkov\",\n     \"@davidtwco\",\n     \"@oli-obk\",\n@@ -532,13 +531,11 @@ incremental = [\n diagnostics = [\n     \"@compiler-errors\",\n     \"@davidtwco\",\n-    \"@estebank\",\n     \"@oli-obk\",\n     \"@TaKO8Ki\",\n ]\n parser = [\n     \"@davidtwco\",\n-    \"@estebank\",\n     \"@nnethercote\",\n     \"@petrochenkov\",\n ]"}]}