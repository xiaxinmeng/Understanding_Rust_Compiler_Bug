{"sha": "bf81a052230b3587684be77b4b87a401e2de33a3", "node_id": "MDY6Q29tbWl0NzI0NzEyOmJmODFhMDUyMjMwYjM1ODc2ODRiZTc3YjRiODdhNDAxZTJkZTMzYTM=", "commit": {"author": {"name": "Lindsey Kuper", "email": "lkuper@mozilla.com", "date": "2011-08-10T23:46:10Z"}, "committer": {"name": "Lindsey Kuper", "email": "lkuper@mozilla.com", "date": "2011-08-10T23:53:32Z"}, "message": "Factor out creation of object body types.", "tree": {"sha": "faa422f54672780ce7d832fd3b461eb6e58b4873", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/faa422f54672780ce7d832fd3b461eb6e58b4873"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/bf81a052230b3587684be77b4b87a401e2de33a3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/bf81a052230b3587684be77b4b87a401e2de33a3", "html_url": "https://github.com/rust-lang/rust/commit/bf81a052230b3587684be77b4b87a401e2de33a3", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/bf81a052230b3587684be77b4b87a401e2de33a3/comments", "author": {"login": "lkuper", "id": 535218, "node_id": "MDQ6VXNlcjUzNTIxOA==", "avatar_url": "https://avatars.githubusercontent.com/u/535218?v=4", "gravatar_id": "", "url": "https://api.github.com/users/lkuper", "html_url": "https://github.com/lkuper", "followers_url": "https://api.github.com/users/lkuper/followers", "following_url": "https://api.github.com/users/lkuper/following{/other_user}", "gists_url": "https://api.github.com/users/lkuper/gists{/gist_id}", "starred_url": "https://api.github.com/users/lkuper/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/lkuper/subscriptions", "organizations_url": "https://api.github.com/users/lkuper/orgs", "repos_url": "https://api.github.com/users/lkuper/repos", "events_url": "https://api.github.com/users/lkuper/events{/privacy}", "received_events_url": "https://api.github.com/users/lkuper/received_events", "type": "User", "site_admin": false}, "committer": {"login": "lkuper", "id": 535218, "node_id": "MDQ6VXNlcjUzNTIxOA==", "avatar_url": "https://avatars.githubusercontent.com/u/535218?v=4", "gravatar_id": "", "url": "https://api.github.com/users/lkuper", "html_url": "https://github.com/lkuper", "followers_url": "https://api.github.com/users/lkuper/followers", "following_url": "https://api.github.com/users/lkuper/following{/other_user}", "gists_url": "https://api.github.com/users/lkuper/gists{/gist_id}", "starred_url": "https://api.github.com/users/lkuper/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/lkuper/subscriptions", "organizations_url": "https://api.github.com/users/lkuper/orgs", "repos_url": "https://api.github.com/users/lkuper/repos", "events_url": "https://api.github.com/users/lkuper/events{/privacy}", "received_events_url": "https://api.github.com/users/lkuper/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "bcc30cb4f638130f610b38a3095cc113a5ee3999", "url": "https://api.github.com/repos/rust-lang/rust/commits/bcc30cb4f638130f610b38a3095cc113a5ee3999", "html_url": "https://github.com/rust-lang/rust/commit/bcc30cb4f638130f610b38a3095cc113a5ee3999"}], "stats": {"total": 103, "additions": 48, "deletions": 55}, "files": [{"sha": "d79851813e158b6342e3c4f2ec0ec1d6f762060f", "filename": "src/comp/middle/trans_objects.rs", "status": "modified", "additions": 48, "deletions": 55, "changes": 103, "blob_url": "https://github.com/rust-lang/rust/blob/bf81a052230b3587684be77b4b87a401e2de33a3/src%2Fcomp%2Fmiddle%2Ftrans_objects.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bf81a052230b3587684be77b4b87a401e2de33a3/src%2Fcomp%2Fmiddle%2Ftrans_objects.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans_objects.rs?ref=bf81a052230b3587684be77b4b87a401e2de33a3", "patch": "@@ -103,28 +103,18 @@ fn trans_obj(cx: @local_ctxt, sp: &span, ob: &ast::_obj,\n         // Store null into pair, if no args or typarams.\n         bcx.build.Store(C_null(llbox_ty), pair_box);\n     } else {\n-        // Otherwise, we have to synthesize a big structural type for the\n-        // object body.\n         let obj_fields: [ty::t] = ~[];\n         for a: ty::arg  in arg_tys { obj_fields += ~[a.ty]; }\n \n-        // Tuple type for fields: [field, ...]\n-        let fields_ty: ty::t = ty::mk_imm_tup(ccx.tcx, obj_fields);\n-\n-        let tydesc_ty = ty::mk_type(ccx.tcx);\n         let tps: [ty::t] = ~[];\n+        let tydesc_ty = ty::mk_type(ccx.tcx);\n         for tp: ast::ty_param  in ty_params { tps += ~[tydesc_ty]; }\n \n-        // Tuple type for typarams: [typaram, ...]\n-        let typarams_ty: ty::t = ty::mk_imm_tup(ccx.tcx, tps);\n-\n-        // Tuple type for body:\n-        // [tydesc_ty, [typaram, ...], [field, ...]]\n-        let body_ty: ty::t =\n-            ty::mk_imm_tup(ccx.tcx, ~[tydesc_ty, typarams_ty, fields_ty]);\n-\n-        // Hand this type we've synthesized off to trans_malloc_boxed, which\n-        // allocates a box, including space for a refcount.\n+        // Synthesize an object body type and hand it off to\n+        // trans_malloc_boxed, which allocates a box, including space for a\n+        // refcount.\n+        let body_ty: ty::t = create_object_body_type(ccx.tcx, obj_fields, tps,\n+                                                     none);\n         let box = trans_malloc_boxed(bcx, body_ty);\n         bcx = box.bcx;\n         let body = box.body;\n@@ -161,6 +151,8 @@ fn trans_obj(cx: @local_ctxt, sp: &span, ob: &ast::_obj,\n             GEP_tup_like(bcx, body_ty, body,\n                          ~[0, abi::obj_body_elt_typarams]);\n         bcx = body_typarams.bcx;\n+        // TODO: can we just get typarams_ty out of body_ty instead?\n+        let typarams_ty: ty::t = ty::mk_imm_tup(ccx.tcx, tps);\n         let i: int = 0;\n         for tp: ast::ty_param  in ty_params {\n             let typaram = bcx.fcx.lltydescs.(i);\n@@ -181,6 +173,8 @@ fn trans_obj(cx: @local_ctxt, sp: &span, ob: &ast::_obj,\n             alt bcx.fcx.llargs.find(f.id) {\n               some(arg1) {\n                 let arg = load_if_immediate(bcx, arg1, arg_tys.(i).ty);\n+                // TODO: can we just get fields_ty out of body_ty instead?\n+                let fields_ty: ty::t = ty::mk_imm_tup(ccx.tcx, obj_fields);\n                 let field =\n                     GEP_tup_like(bcx, fields_ty, body_fields.val, ~[0, i]);\n                 bcx = field.bcx;\n@@ -303,30 +297,19 @@ fn trans_anon_obj(bcx: @block_ctxt, sp: &span, anon_obj: &ast::anon_obj,\n \n     if std::ivec::len[ast::anon_obj_field](additional_fields) == 0u &&\n            anon_obj.inner_obj == none {\n+\n         // If the object we're translating has no fields and no inner_obj,\n         // there's not much to do.\n         bcx.build.Store(C_null(llbox_ty), pair_box);\n-    } else {\n-\n-        // Synthesize a tuple type for fields: [field, ...]\n-        let fields_ty: ty::t = ty::mk_imm_tup(ccx.tcx, additional_field_tys);\n-\n-        // Type for tydescs.\n-        let tydesc_ty: ty::t = ty::mk_type(ccx.tcx);\n-\n-        // Placeholder for non-existent typarams, since anon objs don't have\n-        // them.\n-        let typarams_ty: ty::t = ty::mk_imm_tup(ccx.tcx, ~[]);\n \n-        // Tuple type for body:\n-        // [tydesc, [typaram, ...], [field, ...], inner_obj]\n-        let body_ty: ty::t =\n-            ty::mk_imm_tup(ccx.tcx,\n-                           ~[tydesc_ty, typarams_ty, fields_ty,\n-                             inner_obj_ty]);\n+    } else {\n \n-        // Hand this type we've synthesized off to trans_malloc_boxed, which\n-        // allocates a box, including space for a refcount.\n+        // Synthesize a type for the object body and hand it off to\n+        // trans_malloc_boxed, which allocates a box, including space for a\n+        // refcount.\n+        let body_ty: ty::t = create_object_body_type(ccx.tcx,\n+                                                     additional_field_tys,\n+                                                     ~[], some(inner_obj_ty));\n         let box = trans_malloc_boxed(bcx, body_ty);\n         bcx = box.bcx;\n         let body = box.body;\n@@ -364,7 +347,8 @@ fn trans_anon_obj(bcx: @block_ctxt, sp: &span, anon_obj: &ast::anon_obj,\n             // have additional field exprs in the AST.\n             load_if_immediate(bcx, additional_field_vals.(i).val,\n                               additional_field_tys.(i));\n-\n+            let fields_ty: ty::t = ty::mk_imm_tup(ccx.tcx,\n+                                                  additional_field_tys);\n             let field =\n                 GEP_tup_like(bcx, fields_ty, body_fields.val, ~[0, i]);\n             bcx = field.bcx;\n@@ -806,25 +790,9 @@ fn process_fwding_mthd(cx: @local_ctxt, sp: &span, m: @ty::method,\n \n     // Now, we need to figure out exactly what type the body is supposed to be\n     // cast to.\n-\n-    // NB: This next part is almost flat-out copypasta from trans_anon_obj.\n-    // It would be great to factor this out.\n-\n-    // Synthesize a tuple type for fields: [field, ...]\n-    let fields_ty: ty::t = ty::mk_imm_tup(cx.ccx.tcx, additional_field_tys);\n-\n-    // Type for tydescs.\n-    let tydesc_ty: ty::t = ty::mk_type(cx.ccx.tcx);\n-\n-    // Placeholder for non-existent typarams, since anon objs don't have them.\n-    let typarams_ty: ty::t = ty::mk_imm_tup(cx.ccx.tcx, ~[]);\n-\n-    // Tuple type for body: [tydesc, [typaram, ...], [field, ...], inner_obj]\n-\n-    let body_ty: ty::t =\n-        ty::mk_imm_tup(cx.ccx.tcx,\n-                       ~[tydesc_ty, typarams_ty, fields_ty, inner_obj_ty]);\n-\n+    let body_ty: ty::t = create_object_body_type(cx.ccx.tcx,\n+                                                 additional_field_tys, ~[],\n+                                                 some(inner_obj_ty));\n     // And cast to that type.\n     llself_obj_body =\n         bcx.build.PointerCast(llself_obj_body,\n@@ -920,6 +888,31 @@ fn process_fwding_mthd(cx: @local_ctxt, sp: &span, m: @ty::method,\n     ret llforwarding_fn;\n }\n \n+// create_object_body_type: Synthesize a big structural tuple type for an\n+// object body: [tydesc, [typaram, ...], [field, ...], inner_obj].\n+fn create_object_body_type(tcx: &ty::ctxt, fields_ty: &[ty::t],\n+                           typarams_ty: &[ty::t],\n+                           maybe_inner_obj_ty: option::t[ty::t]) -> ty::t {\n+\n+    let tydesc_ty: ty::t = ty::mk_type(tcx);\n+    let typarams_ty_tup: ty::t = ty::mk_imm_tup(tcx, typarams_ty);\n+    let fields_ty_tup: ty::t = ty::mk_imm_tup(tcx, fields_ty);\n+\n+    let body_ty: ty::t;\n+    alt maybe_inner_obj_ty {\n+      some(inner_obj_ty) {\n+        body_ty = ty::mk_imm_tup(tcx, ~[tydesc_ty, typarams_ty_tup,\n+                                        fields_ty_tup, inner_obj_ty]);\n+      }\n+      none {\n+        body_ty = ty::mk_imm_tup(tcx, ~[tydesc_ty, typarams_ty_tup,\n+                                        fields_ty_tup]);\n+      }\n+    }\n+\n+    ret body_ty;\n+}\n+\n // process_normal_mthd: Create the contents of a normal vtable slot.  A helper\n // function for create_vtbl.\n fn process_normal_mthd(cx: @local_ctxt, m: @ast::method, self_ty: ty::t,"}]}