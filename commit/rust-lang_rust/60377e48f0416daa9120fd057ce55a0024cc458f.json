{"sha": "60377e48f0416daa9120fd057ce55a0024cc458f", "node_id": "MDY6Q29tbWl0NzI0NzEyOjYwMzc3ZTQ4ZjA0MTZkYWE5MTIwZmQwNTdjZTU1YTAwMjRjYzQ1OGY=", "commit": {"author": {"name": "kennytm", "email": "kennytm@gmail.com", "date": "2017-08-12T15:48:24Z"}, "committer": {"name": "kennytm", "email": "kennytm@gmail.com", "date": "2017-08-14T10:14:49Z"}, "message": "save-analysis: Remove path span extraction methods from SpanUtils\n\nUse the `span` field in PathSegment and TyParam instead.\n\nFix #43796. Close #41478.", "tree": {"sha": "53575230cc2b86b9fd020679f52ec239fb2924ad", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/53575230cc2b86b9fd020679f52ec239fb2924ad"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/60377e48f0416daa9120fd057ce55a0024cc458f", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIcBAABCAAGBQJZkXgZAAoJEP72yAUdDgE8ecsQAJDGvy9wV+Stx7hibUeVnNyX\nnEN/8NHgbUbY+xPZnRXV8BWqiMI2yQhsYxkUPv5TG7dQYTKk+MX+3AvFJkw6kHrs\nmy9sBu7RwM5gXlLR/V0LlK5tRFjTp94fowNPeHzggx4rBRIzbGVqYOeD1T86MmKg\nOXbIaBe0VeA8kvvzhlC8tp0I9bh2Y+o4YWh6ItbUAStpGnnjcubKswxL2t4RMLT2\np8nmePtCauGN5GLbu9uYkyAwPciAvHB6zh2naywfKws75rRavrHwbESpnErYBInZ\n4eeIUICzW9Y4B7+x8/N8agd4AMqNczg9hH+bnEVF3YWG4hy5Gnpm/8WR9bO3CpV8\na3/RYbQr57yV291E4KhT6+ksABP7jxE/bneMfELZb6I2mREr5Yb3IGODcq2FUcoV\nmAsWGHDWB9ELLYMtWhcxkZXGe1jIZUhZt1Ypi/BP/eezZ4vZBcA2OaRkjfWc0JDm\nSO+TL1YfCMRGKrsh74gyz0namhA4niOkMLSxJlpZZ9nfvdzqX4oXxxlNSQtdrXeq\nCwTKky0EkNx6Wp9hiYm/qPw2fGu7tBCNCZy7qGPxkd7aJXj5eStjYhtyLumolRNE\nN0GB7Y+JfROtfiNI7SlVtRReclyq+VBv2sSzt6EnLD3ikfPUsSXZaMVKjmhO4p+P\nP0bWtHtBFkj5IUjvqiFz\n=wcYL\n-----END PGP SIGNATURE-----", "payload": "tree 53575230cc2b86b9fd020679f52ec239fb2924ad\nparent bae4fafdfb756690ee31ac939299380cc559c697\nauthor kennytm <kennytm@gmail.com> 1502552904 +0800\ncommitter kennytm <kennytm@gmail.com> 1502705689 +0800\n\nsave-analysis: Remove path span extraction methods from SpanUtils\n\nUse the `span` field in PathSegment and TyParam instead.\n\nFix #43796. Close #41478.\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/60377e48f0416daa9120fd057ce55a0024cc458f", "html_url": "https://github.com/rust-lang/rust/commit/60377e48f0416daa9120fd057ce55a0024cc458f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/60377e48f0416daa9120fd057ce55a0024cc458f/comments", "author": {"login": "kennytm", "id": 103023, "node_id": "MDQ6VXNlcjEwMzAyMw==", "avatar_url": "https://avatars.githubusercontent.com/u/103023?v=4", "gravatar_id": "", "url": "https://api.github.com/users/kennytm", "html_url": "https://github.com/kennytm", "followers_url": "https://api.github.com/users/kennytm/followers", "following_url": "https://api.github.com/users/kennytm/following{/other_user}", "gists_url": "https://api.github.com/users/kennytm/gists{/gist_id}", "starred_url": "https://api.github.com/users/kennytm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/kennytm/subscriptions", "organizations_url": "https://api.github.com/users/kennytm/orgs", "repos_url": "https://api.github.com/users/kennytm/repos", "events_url": "https://api.github.com/users/kennytm/events{/privacy}", "received_events_url": "https://api.github.com/users/kennytm/received_events", "type": "User", "site_admin": false}, "committer": {"login": "kennytm", "id": 103023, "node_id": "MDQ6VXNlcjEwMzAyMw==", "avatar_url": "https://avatars.githubusercontent.com/u/103023?v=4", "gravatar_id": "", "url": "https://api.github.com/users/kennytm", "html_url": "https://github.com/kennytm", "followers_url": "https://api.github.com/users/kennytm/followers", "following_url": "https://api.github.com/users/kennytm/following{/other_user}", "gists_url": "https://api.github.com/users/kennytm/gists{/gist_id}", "starred_url": "https://api.github.com/users/kennytm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/kennytm/subscriptions", "organizations_url": "https://api.github.com/users/kennytm/orgs", "repos_url": "https://api.github.com/users/kennytm/repos", "events_url": "https://api.github.com/users/kennytm/events{/privacy}", "received_events_url": "https://api.github.com/users/kennytm/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "bae4fafdfb756690ee31ac939299380cc559c697", "url": "https://api.github.com/repos/rust-lang/rust/commits/bae4fafdfb756690ee31ac939299380cc559c697", "html_url": "https://github.com/rust-lang/rust/commit/bae4fafdfb756690ee31ac939299380cc559c697"}], "stats": {"total": 156, "additions": 33, "deletions": 123}, "files": [{"sha": "a8b34e8682b99a35ea81eb5766f8e3e7ccb1e349", "filename": "src/librustc_save_analysis/dump_visitor.rs", "status": "modified", "additions": 6, "deletions": 38, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/60377e48f0416daa9120fd057ce55a0024cc458f/src%2Flibrustc_save_analysis%2Fdump_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60377e48f0416daa9120fd057ce55a0024cc458f/src%2Flibrustc_save_analysis%2Fdump_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_save_analysis%2Fdump_visitor.rs?ref=60377e48f0416daa9120fd057ce55a0024cc458f", "patch": "@@ -27,7 +27,6 @@\n use rustc::hir::def::Def as HirDef;\n use rustc::hir::def_id::DefId;\n use rustc::hir::map::Node;\n-use rustc::session::Session;\n use rustc::ty::{self, TyCtxt};\n use rustc_data_structures::fx::FxHashSet;\n \n@@ -62,7 +61,6 @@ macro_rules! down_cast_data {\n \n pub struct DumpVisitor<'l, 'tcx: 'l, 'll, O: DumpOutput + 'll> {\n     save_ctxt: SaveContext<'l, 'tcx>,\n-    sess: &'l Session,\n     tcx: TyCtxt<'l, 'tcx, 'tcx>,\n     dumper: &'ll mut JsonDumper<O>,\n \n@@ -84,7 +82,6 @@ impl<'l, 'tcx: 'l, 'll, O: DumpOutput + 'll> DumpVisitor<'l, 'tcx, 'll, O> {\n                -> DumpVisitor<'l, 'tcx, 'll, O> {\n         let span_utils = SpanUtils::new(&save_ctxt.tcx.sess);\n         DumpVisitor {\n-            sess: &save_ctxt.tcx.sess,\n             tcx: save_ctxt.tcx,\n             save_ctxt: save_ctxt,\n             dumper: dumper,\n@@ -147,47 +144,23 @@ impl<'l, 'tcx: 'l, 'll, O: DumpOutput + 'll> DumpVisitor<'l, 'tcx, 'll, O> {\n     // For each prefix, we return the span for the last segment in the prefix and\n     // a str representation of the entire prefix.\n     fn process_path_prefixes(&self, path: &ast::Path) -> Vec<(Span, String)> {\n-        let spans = self.span.spans_for_path_segments(path);\n         let segments = &path.segments[if path.is_global() { 1 } else { 0 }..];\n \n-        // Paths to enums seem to not match their spans - the span includes all the\n-        // variants too. But they seem to always be at the end, so I hope we can cope with\n-        // always using the first ones. So, only error out if we don't have enough spans.\n-        // What could go wrong...?\n-        if spans.len() < segments.len() {\n-            if generated_code(path.span) {\n-                return vec![];\n-            }\n-            error!(\"Mis-calculated spans for path '{}'. Found {} spans, expected {}. Found spans:\",\n-                   path_to_string(path),\n-                   spans.len(),\n-                   segments.len());\n-            for s in &spans {\n-                let loc = self.sess.codemap().lookup_char_pos(s.lo);\n-                error!(\"    '{}' in {}, line {}\",\n-                       self.span.snippet(*s),\n-                       loc.file.name,\n-                       loc.line);\n-            }\n-            error!(\"    master span: {:?}: `{}`\", path.span, self.span.snippet(path.span));\n-            return vec![];\n-        }\n-\n-        let mut result: Vec<(Span, String)> = vec![];\n+        let mut result = Vec::with_capacity(segments.len());\n \n         let mut segs = vec![];\n-        for (i, (seg, span)) in segments.iter().zip(&spans).enumerate() {\n+        for (i, seg) in segments.iter().enumerate() {\n             segs.push(seg.clone());\n             let sub_path = ast::Path {\n-                span: *span, // span for the last segment\n+                span: seg.span, // span for the last segment\n                 segments: segs,\n             };\n             let qualname = if i == 0 && path.is_global() {\n                 format!(\"::{}\", path_to_string(&sub_path))\n             } else {\n                 path_to_string(&sub_path)\n             };\n-            result.push((*span, qualname));\n+            result.push((seg.span, qualname));\n             segs = sub_path.segments;\n         }\n \n@@ -436,13 +409,8 @@ impl<'l, 'tcx: 'l, 'll, O: DumpOutput + 'll> DumpVisitor<'l, 'tcx, 'll, O> {\n                               full_span: Span,\n                               prefix: &str,\n                               id: NodeId) {\n-        // We can't only use visit_generics since we don't have spans for param\n-        // bindings, so we reparse the full_span to get those sub spans.\n-        // However full span is the entire enum/fn/struct block, so we only want\n-        // the first few to match the number of generics we're looking for.\n-        let param_sub_spans = self.span.spans_for_ty_params(full_span,\n-                                                            (generics.ty_params.len() as isize));\n-        for (param, param_ss) in generics.ty_params.iter().zip(param_sub_spans) {\n+        for param in &generics.ty_params {\n+            let param_ss = param.span;\n             let name = escape(self.span.snippet(param_ss));\n             // Append $id to name to make sure each one is unique\n             let qualname = format!(\"{}::{}${}\","}, {"sha": "631907b28f8b8d0a40736b5d1e6f8386aeeaac71", "filename": "src/librustc_save_analysis/span_utils.rs", "status": "modified", "additions": 0, "deletions": 85, "changes": 85, "blob_url": "https://github.com/rust-lang/rust/blob/60377e48f0416daa9120fd057ce55a0024cc458f/src%2Flibrustc_save_analysis%2Fspan_utils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60377e48f0416daa9120fd057ce55a0024cc458f/src%2Flibrustc_save_analysis%2Fspan_utils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_save_analysis%2Fspan_utils.rs?ref=60377e48f0416daa9120fd057ce55a0024cc458f", "patch": "@@ -16,7 +16,6 @@ use std::cell::Cell;\n use std::env;\n use std::path::Path;\n \n-use syntax::ast;\n use syntax::parse::lexer::{self, StringReader};\n use syntax::parse::token::{self, Token};\n use syntax::symbol::keywords;\n@@ -207,75 +206,6 @@ impl<'a> SpanUtils<'a> {\n         result\n     }\n \n-    // Reparse span and return an owned vector of sub spans of the first limit\n-    // identifier tokens in the given nesting level.\n-    // example with Foo<Bar<T,V>, Bar<T,V>>\n-    // Nesting = 0: all idents outside of angle brackets: [Foo]\n-    // Nesting = 1: idents within one level of angle brackets: [Bar, Bar]\n-    pub fn spans_with_brackets(&self, span: Span, nesting: isize, limit: isize) -> Vec<Span> {\n-        let mut result: Vec<Span> = vec![];\n-\n-        let mut toks = self.retokenise_span(span);\n-        // We keep track of how many brackets we're nested in\n-        let mut angle_count: isize = 0;\n-        let mut bracket_count: isize = 0;\n-        let mut found_ufcs_sep = false;\n-        loop {\n-            let ts = toks.real_token();\n-            if ts.tok == token::Eof {\n-                if angle_count != 0 || bracket_count != 0 {\n-                    if generated_code(span) {\n-                        return vec![];\n-                    }\n-                    let loc = self.sess.codemap().lookup_char_pos(span.lo);\n-                    span_bug!(span,\n-                              \"Mis-counted brackets when breaking path? \\\n-                               Parsing '{}' in {}, line {}\",\n-                              self.snippet(span),\n-                              loc.file.name,\n-                              loc.line);\n-                }\n-                return result\n-            }\n-            if (result.len() as isize) == limit {\n-                return result;\n-            }\n-            bracket_count += match ts.tok {\n-                token::OpenDelim(token::Bracket) => 1,\n-                token::CloseDelim(token::Bracket) => -1,\n-                _ => 0,\n-            };\n-            if bracket_count > 0 {\n-                continue;\n-            }\n-            angle_count += match ts.tok {\n-                token::Lt => 1,\n-                token::Gt => -1,\n-                token::BinOp(token::Shl) => 2,\n-                token::BinOp(token::Shr) => -2,\n-                _ => 0,\n-            };\n-\n-            // Ignore the `>::` in `<Type as Trait>::AssocTy`.\n-\n-            // The root cause of this hack is that the AST representation of\n-            // qpaths is horrible. It treats <A as B>::C as a path with two\n-            // segments, B and C and notes that there is also a self type A at\n-            // position 0. Because we don't have spans for individual idents,\n-            // only the whole path, we have to iterate over the tokens in the\n-            // path, trying to pull out the non-nested idents (e.g., avoiding 'a\n-            // in `<A as B<'a>>::C`). So we end up with a span for `B>::C` from\n-            // the start of the first ident to the end of the path.\n-            if !found_ufcs_sep && angle_count == -1 {\n-                found_ufcs_sep = true;\n-                angle_count += 1;\n-            }\n-            if ts.tok.is_ident() && angle_count == nesting {\n-                result.push(ts.sp);\n-            }\n-        }\n-    }\n-\n     pub fn sub_span_before_token(&self, span: Span, tok: Token) -> Option<Span> {\n         let mut toks = self.retokenise_span(span);\n         let mut prev = toks.real_token();\n@@ -330,21 +260,6 @@ impl<'a> SpanUtils<'a> {\n         }\n     }\n \n-\n-    // Returns a list of the spans of idents in a path.\n-    // E.g., For foo::bar<x,t>::baz, we return [foo, bar, baz] (well, their spans)\n-    pub fn spans_for_path_segments(&self, path: &ast::Path) -> Vec<Span> {\n-        self.spans_with_brackets(path.span, 0, -1)\n-    }\n-\n-    // Return an owned vector of the subspans of the param identifier\n-    // tokens found in span.\n-    pub fn spans_for_ty_params(&self, span: Span, number: isize) -> Vec<Span> {\n-        // Type params are nested within one level of brackets:\n-        // i.e. we want Vec<A, B> from Foo<A, B<T,U>>\n-        self.spans_with_brackets(span, 1, number)\n-    }\n-\n     // // Return the name for a macro definition (identifier after first `!`)\n     // pub fn span_for_macro_def_name(&self, span: Span) -> Option<Span> {\n     //     let mut toks = self.retokenise_span(span);"}, {"sha": "f9735253ab6824a86bccfb9a8ba3332cff8d444e", "filename": "src/test/run-make/issues-41478-43796/Makefile", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/60377e48f0416daa9120fd057ce55a0024cc458f/src%2Ftest%2Frun-make%2Fissues-41478-43796%2FMakefile", "raw_url": "https://github.com/rust-lang/rust/raw/60377e48f0416daa9120fd057ce55a0024cc458f/src%2Ftest%2Frun-make%2Fissues-41478-43796%2FMakefile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fissues-41478-43796%2FMakefile?ref=60377e48f0416daa9120fd057ce55a0024cc458f", "patch": "@@ -0,0 +1,8 @@\n+-include ../tools.mk\n+\n+all:\n+\t# Work in /tmp, because we need to create the `save-analysis-temp` folder.\n+\tcp a.rs $(TMPDIR)/\n+\tcd $(TMPDIR) && $(RUSTC) -Zsave-analysis $(TMPDIR)/a.rs 2> $(TMPDIR)/stderr.txt || ( cat $(TMPDIR)/stderr.txt && exit 1 )\n+\t[ ! -s $(TMPDIR)/stderr.txt ] || ( cat $(TMPDIR)/stderr.txt && exit 1 )\n+\t[ -f $(TMPDIR)/save-analysis/liba.json ] || ( ls -la $(TMPDIR) && exit 1 )"}, {"sha": "9d95f8b25852727dc4f81053e310b5d5e2f7cd36", "filename": "src/test/run-make/issues-41478-43796/a.rs", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/60377e48f0416daa9120fd057ce55a0024cc458f/src%2Ftest%2Frun-make%2Fissues-41478-43796%2Fa.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60377e48f0416daa9120fd057ce55a0024cc458f/src%2Ftest%2Frun-make%2Fissues-41478-43796%2Fa.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fissues-41478-43796%2Fa.rs?ref=60377e48f0416daa9120fd057ce55a0024cc458f", "patch": "@@ -0,0 +1,19 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![crate_type = \"lib\"]\n+pub struct V<S>(S);\n+pub trait An {\n+    type U;\n+}\n+pub trait F<A> {\n+}\n+impl<A: An> F<A> for V<<A as An>::U> {\n+}"}]}