{"sha": "89fdb30892dbe330730ad1a1c1fe45b9046c2973", "node_id": "MDY6Q29tbWl0NzI0NzEyOjg5ZmRiMzA4OTJkYmUzMzA3MzBhZDFhMWMxZmU0NWI5MDQ2YzI5NzM=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-10-24T16:12:01Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-10-24T16:12:01Z"}, "message": "Auto merge of #78319 - jonas-schievink:rollup-vzj8a6l, r=jonas-schievink\n\nRollup of 15 pull requests\n\nSuccessful merges:\n\n - #76649 (Add a spin loop hint for Arc::downgrade)\n - #77392 (add `insert` to `Option`)\n - #77716 (Revert \"Allow dynamic linking for iOS/tvOS targets.\")\n - #78109 (Check for exhaustion in RangeInclusive::contains and slicing)\n - #78198 (Simplify assert terminator only if condition evaluates to expected value)\n - #78243 (--test-args flag description)\n - #78249 (improve const infer error)\n - #78250 (Document inline-const)\n - #78264 (Add regression test for issue-77475)\n - #78274 (Update description of Empty Enum for accuracy)\n - #78278 (move `visit_predicate` into `TypeVisitor`)\n - #78292 (Loop instead of recursion)\n - #78293 (Always store Rustdoc theme when it's changed)\n - #78300 (Make codegen coverage_context optional, and check)\n - #78307 (Revert \"Set .llvmbc and .llvmcmd sections as allocatable\")\n\nFailed merges:\n\nr? `@ghost`", "tree": {"sha": "351f7a2136b66d2a5abfa16a94c969c33fadf24b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/351f7a2136b66d2a5abfa16a94c969c33fadf24b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/89fdb30892dbe330730ad1a1c1fe45b9046c2973", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/89fdb30892dbe330730ad1a1c1fe45b9046c2973", "html_url": "https://github.com/rust-lang/rust/commit/89fdb30892dbe330730ad1a1c1fe45b9046c2973", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/89fdb30892dbe330730ad1a1c1fe45b9046c2973/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2e8a54af60df63034e41359acfc923e5c5769a91", "url": "https://api.github.com/repos/rust-lang/rust/commits/2e8a54af60df63034e41359acfc923e5c5769a91", "html_url": "https://github.com/rust-lang/rust/commit/2e8a54af60df63034e41359acfc923e5c5769a91"}, {"sha": "1ac137be93feb476ab14b9d9924c880a53cc3b91", "url": "https://api.github.com/repos/rust-lang/rust/commits/1ac137be93feb476ab14b9d9924c880a53cc3b91", "html_url": "https://github.com/rust-lang/rust/commit/1ac137be93feb476ab14b9d9924c880a53cc3b91"}], "stats": {"total": 581, "additions": 386, "deletions": 195}, "files": [{"sha": "a1cbcde1f4291ca9acc5195668054a90853448af", "filename": "compiler/rustc_ast_lowering/src/pat.rs", "status": "modified", "additions": 79, "deletions": 71, "changes": 150, "blob_url": "https://github.com/rust-lang/rust/blob/89fdb30892dbe330730ad1a1c1fe45b9046c2973/compiler%2Frustc_ast_lowering%2Fsrc%2Fpat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89fdb30892dbe330730ad1a1c1fe45b9046c2973/compiler%2Frustc_ast_lowering%2Fsrc%2Fpat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_lowering%2Fsrc%2Fpat.rs?ref=89fdb30892dbe330730ad1a1c1fe45b9046c2973", "patch": "@@ -10,82 +10,90 @@ use rustc_span::symbol::Ident;\n use rustc_span::{source_map::Spanned, Span};\n \n impl<'a, 'hir> LoweringContext<'a, 'hir> {\n-    crate fn lower_pat(&mut self, p: &Pat) -> &'hir hir::Pat<'hir> {\n+    crate fn lower_pat(&mut self, mut pattern: &Pat) -> &'hir hir::Pat<'hir> {\n         ensure_sufficient_stack(|| {\n-            let node = match p.kind {\n-                PatKind::Wild => hir::PatKind::Wild,\n-                PatKind::Ident(ref binding_mode, ident, ref sub) => {\n-                    let lower_sub = |this: &mut Self| sub.as_ref().map(|s| this.lower_pat(&*s));\n-                    let node = self.lower_pat_ident(p, binding_mode, ident, lower_sub);\n-                    node\n-                }\n-                PatKind::Lit(ref e) => hir::PatKind::Lit(self.lower_expr(e)),\n-                PatKind::TupleStruct(ref path, ref pats) => {\n-                    let qpath = self.lower_qpath(\n-                        p.id,\n-                        &None,\n-                        path,\n-                        ParamMode::Optional,\n-                        ImplTraitContext::disallowed(),\n-                    );\n-                    let (pats, ddpos) = self.lower_pat_tuple(pats, \"tuple struct\");\n-                    hir::PatKind::TupleStruct(qpath, pats, ddpos)\n-                }\n-                PatKind::Or(ref pats) => hir::PatKind::Or(\n-                    self.arena.alloc_from_iter(pats.iter().map(|x| self.lower_pat(x))),\n-                ),\n-                PatKind::Path(ref qself, ref path) => {\n-                    let qpath = self.lower_qpath(\n-                        p.id,\n-                        qself,\n-                        path,\n-                        ParamMode::Optional,\n-                        ImplTraitContext::disallowed(),\n-                    );\n-                    hir::PatKind::Path(qpath)\n-                }\n-                PatKind::Struct(ref path, ref fields, etc) => {\n-                    let qpath = self.lower_qpath(\n-                        p.id,\n-                        &None,\n-                        path,\n-                        ParamMode::Optional,\n-                        ImplTraitContext::disallowed(),\n-                    );\n+            // loop here to avoid recursion\n+            let node = loop {\n+                match pattern.kind {\n+                    PatKind::Wild => break hir::PatKind::Wild,\n+                    PatKind::Ident(ref binding_mode, ident, ref sub) => {\n+                        let lower_sub = |this: &mut Self| sub.as_ref().map(|s| this.lower_pat(&*s));\n+                        break self.lower_pat_ident(pattern, binding_mode, ident, lower_sub);\n+                    }\n+                    PatKind::Lit(ref e) => break hir::PatKind::Lit(self.lower_expr(e)),\n+                    PatKind::TupleStruct(ref path, ref pats) => {\n+                        let qpath = self.lower_qpath(\n+                            pattern.id,\n+                            &None,\n+                            path,\n+                            ParamMode::Optional,\n+                            ImplTraitContext::disallowed(),\n+                        );\n+                        let (pats, ddpos) = self.lower_pat_tuple(pats, \"tuple struct\");\n+                        break hir::PatKind::TupleStruct(qpath, pats, ddpos);\n+                    }\n+                    PatKind::Or(ref pats) => {\n+                        break hir::PatKind::Or(\n+                            self.arena.alloc_from_iter(pats.iter().map(|x| self.lower_pat(x))),\n+                        );\n+                    }\n+                    PatKind::Path(ref qself, ref path) => {\n+                        let qpath = self.lower_qpath(\n+                            pattern.id,\n+                            qself,\n+                            path,\n+                            ParamMode::Optional,\n+                            ImplTraitContext::disallowed(),\n+                        );\n+                        break hir::PatKind::Path(qpath);\n+                    }\n+                    PatKind::Struct(ref path, ref fields, etc) => {\n+                        let qpath = self.lower_qpath(\n+                            pattern.id,\n+                            &None,\n+                            path,\n+                            ParamMode::Optional,\n+                            ImplTraitContext::disallowed(),\n+                        );\n \n-                    let fs = self.arena.alloc_from_iter(fields.iter().map(|f| hir::FieldPat {\n-                        hir_id: self.next_id(),\n-                        ident: f.ident,\n-                        pat: self.lower_pat(&f.pat),\n-                        is_shorthand: f.is_shorthand,\n-                        span: f.span,\n-                    }));\n-                    hir::PatKind::Struct(qpath, fs, etc)\n-                }\n-                PatKind::Tuple(ref pats) => {\n-                    let (pats, ddpos) = self.lower_pat_tuple(pats, \"tuple\");\n-                    hir::PatKind::Tuple(pats, ddpos)\n-                }\n-                PatKind::Box(ref inner) => hir::PatKind::Box(self.lower_pat(inner)),\n-                PatKind::Ref(ref inner, mutbl) => hir::PatKind::Ref(self.lower_pat(inner), mutbl),\n-                PatKind::Range(ref e1, ref e2, Spanned { node: ref end, .. }) => {\n-                    hir::PatKind::Range(\n-                        e1.as_deref().map(|e| self.lower_expr(e)),\n-                        e2.as_deref().map(|e| self.lower_expr(e)),\n-                        self.lower_range_end(end, e2.is_some()),\n-                    )\n-                }\n-                PatKind::Slice(ref pats) => self.lower_pat_slice(pats),\n-                PatKind::Rest => {\n-                    // If we reach here the `..` pattern is not semantically allowed.\n-                    self.ban_illegal_rest_pat(p.span)\n+                        let fs = self.arena.alloc_from_iter(fields.iter().map(|f| hir::FieldPat {\n+                            hir_id: self.next_id(),\n+                            ident: f.ident,\n+                            pat: self.lower_pat(&f.pat),\n+                            is_shorthand: f.is_shorthand,\n+                            span: f.span,\n+                        }));\n+                        break hir::PatKind::Struct(qpath, fs, etc);\n+                    }\n+                    PatKind::Tuple(ref pats) => {\n+                        let (pats, ddpos) = self.lower_pat_tuple(pats, \"tuple\");\n+                        break hir::PatKind::Tuple(pats, ddpos);\n+                    }\n+                    PatKind::Box(ref inner) => {\n+                        break hir::PatKind::Box(self.lower_pat(inner));\n+                    }\n+                    PatKind::Ref(ref inner, mutbl) => {\n+                        break hir::PatKind::Ref(self.lower_pat(inner), mutbl);\n+                    }\n+                    PatKind::Range(ref e1, ref e2, Spanned { node: ref end, .. }) => {\n+                        break hir::PatKind::Range(\n+                            e1.as_deref().map(|e| self.lower_expr(e)),\n+                            e2.as_deref().map(|e| self.lower_expr(e)),\n+                            self.lower_range_end(end, e2.is_some()),\n+                        );\n+                    }\n+                    PatKind::Slice(ref pats) => break self.lower_pat_slice(pats),\n+                    PatKind::Rest => {\n+                        // If we reach here the `..` pattern is not semantically allowed.\n+                        break self.ban_illegal_rest_pat(pattern.span);\n+                    }\n+                    // return inner to be processed in next loop\n+                    PatKind::Paren(ref inner) => pattern = inner,\n+                    PatKind::MacCall(_) => panic!(\"{:?} shouldn't exist here\", pattern.span),\n                 }\n-                // FIXME: consider not using recursion to lower this.\n-                PatKind::Paren(ref inner) => return self.lower_pat(inner),\n-                PatKind::MacCall(_) => panic!(\"{:?} shouldn't exist here\", p.span),\n             };\n \n-            self.pat_with_node_id_of(p, node)\n+            self.pat_with_node_id_of(pattern, node)\n         })\n     }\n "}, {"sha": "ea1a7cfa5d3b5325c88cced137a02431d9344ce8", "filename": "compiler/rustc_codegen_llvm/src/back/write.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/89fdb30892dbe330730ad1a1c1fe45b9046c2973/compiler%2Frustc_codegen_llvm%2Fsrc%2Fback%2Fwrite.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89fdb30892dbe330730ad1a1c1fe45b9046c2973/compiler%2Frustc_codegen_llvm%2Fsrc%2Fback%2Fwrite.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fback%2Fwrite.rs?ref=89fdb30892dbe330730ad1a1c1fe45b9046c2973", "patch": "@@ -936,8 +936,8 @@ unsafe fn embed_bitcode(\n         llvm::LLVMRustAppendModuleInlineAsm(llmod, asm.as_ptr().cast(), asm.len());\n     } else {\n         let asm = \"\n-            .section .llvmbc,\\\"a\\\"\n-            .section .llvmcmd,\\\"a\\\"\n+            .section .llvmbc,\\\"e\\\"\n+            .section .llvmcmd,\\\"e\\\"\n         \";\n         llvm::LLVMRustAppendModuleInlineAsm(llmod, asm.as_ptr().cast(), asm.len());\n     }"}, {"sha": "56ff580b43b5989ba293e3ab31381dd17d22a194", "filename": "compiler/rustc_codegen_llvm/src/context.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/89fdb30892dbe330730ad1a1c1fe45b9046c2973/compiler%2Frustc_codegen_llvm%2Fsrc%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89fdb30892dbe330730ad1a1c1fe45b9046c2973/compiler%2Frustc_codegen_llvm%2Fsrc%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fcontext.rs?ref=89fdb30892dbe330730ad1a1c1fe45b9046c2973", "patch": "@@ -324,8 +324,8 @@ impl<'ll, 'tcx> CodegenCx<'ll, 'tcx> {\n     }\n \n     #[inline]\n-    pub fn coverage_context(&'a self) -> &'a coverageinfo::CrateCoverageContext<'tcx> {\n-        self.coverage_cx.as_ref().unwrap()\n+    pub fn coverage_context(&'a self) -> Option<&'a coverageinfo::CrateCoverageContext<'tcx>> {\n+        self.coverage_cx.as_ref()\n     }\n }\n "}, {"sha": "c1163a871cf1f311047ad6ad61daf274592cf0c9", "filename": "compiler/rustc_codegen_llvm/src/coverageinfo/mapgen.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/89fdb30892dbe330730ad1a1c1fe45b9046c2973/compiler%2Frustc_codegen_llvm%2Fsrc%2Fcoverageinfo%2Fmapgen.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89fdb30892dbe330730ad1a1c1fe45b9046c2973/compiler%2Frustc_codegen_llvm%2Fsrc%2Fcoverageinfo%2Fmapgen.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fcoverageinfo%2Fmapgen.rs?ref=89fdb30892dbe330730ad1a1c1fe45b9046c2973", "patch": "@@ -26,7 +26,10 @@ use tracing::debug;\n /// undocumented details in Clang's implementation (that may or may not be important) were also\n /// replicated for Rust's Coverage Map.\n pub fn finalize<'ll, 'tcx>(cx: &CodegenCx<'ll, 'tcx>) {\n-    let function_coverage_map = cx.coverage_context().take_function_coverage_map();\n+    let function_coverage_map = match cx.coverage_context() {\n+        Some(ctx) => ctx.take_function_coverage_map(),\n+        None => return,\n+    };\n     if function_coverage_map.is_empty() {\n         // This module has no functions with coverage instrumentation\n         return;"}, {"sha": "7fdbe1a55128ae2f438b5afc5a1c03baa12ab559", "filename": "compiler/rustc_codegen_llvm/src/coverageinfo/mod.rs", "status": "modified", "additions": 47, "deletions": 32, "changes": 79, "blob_url": "https://github.com/rust-lang/rust/blob/89fdb30892dbe330730ad1a1c1fe45b9046c2973/compiler%2Frustc_codegen_llvm%2Fsrc%2Fcoverageinfo%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89fdb30892dbe330730ad1a1c1fe45b9046c2973/compiler%2Frustc_codegen_llvm%2Fsrc%2Fcoverageinfo%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fcoverageinfo%2Fmod.rs?ref=89fdb30892dbe330730ad1a1c1fe45b9046c2973", "patch": "@@ -64,17 +64,22 @@ impl CoverageInfoBuilderMethods<'tcx> for Builder<'a, 'll, 'tcx> {\n         function_source_hash: u64,\n         id: CounterValueReference,\n         region: CodeRegion,\n-    ) {\n-        debug!(\n-            \"adding counter to coverage_regions: instance={:?}, function_source_hash={}, id={:?}, \\\n-             at {:?}\",\n-            instance, function_source_hash, id, region,\n-        );\n-        let mut coverage_regions = self.coverage_context().function_coverage_map.borrow_mut();\n-        coverage_regions\n-            .entry(instance)\n-            .or_insert_with(|| FunctionCoverage::new(self.tcx, instance))\n-            .add_counter(function_source_hash, id, region);\n+    ) -> bool {\n+        if let Some(coverage_context) = self.coverage_context() {\n+            debug!(\n+                \"adding counter to coverage_regions: instance={:?}, function_source_hash={}, id={:?}, \\\n+                at {:?}\",\n+                instance, function_source_hash, id, region,\n+            );\n+            let mut coverage_regions = coverage_context.function_coverage_map.borrow_mut();\n+            coverage_regions\n+                .entry(instance)\n+                .or_insert_with(|| FunctionCoverage::new(self.tcx, instance))\n+                .add_counter(function_source_hash, id, region);\n+            true\n+        } else {\n+            false\n+        }\n     }\n \n     fn add_counter_expression_region(\n@@ -85,29 +90,39 @@ impl CoverageInfoBuilderMethods<'tcx> for Builder<'a, 'll, 'tcx> {\n         op: Op,\n         rhs: ExpressionOperandId,\n         region: CodeRegion,\n-    ) {\n-        debug!(\n-            \"adding counter expression to coverage_regions: instance={:?}, id={:?}, {:?} {:?} {:?}, \\\n-             at {:?}\",\n-            instance, id, lhs, op, rhs, region,\n-        );\n-        let mut coverage_regions = self.coverage_context().function_coverage_map.borrow_mut();\n-        coverage_regions\n-            .entry(instance)\n-            .or_insert_with(|| FunctionCoverage::new(self.tcx, instance))\n-            .add_counter_expression(id, lhs, op, rhs, region);\n+    ) -> bool {\n+        if let Some(coverage_context) = self.coverage_context() {\n+            debug!(\n+                \"adding counter expression to coverage_regions: instance={:?}, id={:?}, {:?} {:?} {:?}, \\\n+                at {:?}\",\n+                instance, id, lhs, op, rhs, region,\n+            );\n+            let mut coverage_regions = coverage_context.function_coverage_map.borrow_mut();\n+            coverage_regions\n+                .entry(instance)\n+                .or_insert_with(|| FunctionCoverage::new(self.tcx, instance))\n+                .add_counter_expression(id, lhs, op, rhs, region);\n+            true\n+        } else {\n+            false\n+        }\n     }\n \n-    fn add_unreachable_region(&mut self, instance: Instance<'tcx>, region: CodeRegion) {\n-        debug!(\n-            \"adding unreachable code to coverage_regions: instance={:?}, at {:?}\",\n-            instance, region,\n-        );\n-        let mut coverage_regions = self.coverage_context().function_coverage_map.borrow_mut();\n-        coverage_regions\n-            .entry(instance)\n-            .or_insert_with(|| FunctionCoverage::new(self.tcx, instance))\n-            .add_unreachable_region(region);\n+    fn add_unreachable_region(&mut self, instance: Instance<'tcx>, region: CodeRegion) -> bool {\n+        if let Some(coverage_context) = self.coverage_context() {\n+            debug!(\n+                \"adding unreachable code to coverage_regions: instance={:?}, at {:?}\",\n+                instance, region,\n+            );\n+            let mut coverage_regions = coverage_context.function_coverage_map.borrow_mut();\n+            coverage_regions\n+                .entry(instance)\n+                .or_insert_with(|| FunctionCoverage::new(self.tcx, instance))\n+                .add_unreachable_region(region);\n+            true\n+        } else {\n+            false\n+        }\n     }\n }\n "}, {"sha": "4811adea9ec060851466bddf3a9256c9d2958f42", "filename": "compiler/rustc_codegen_ssa/src/mir/coverageinfo.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/89fdb30892dbe330730ad1a1c1fe45b9046c2973/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fcoverageinfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89fdb30892dbe330730ad1a1c1fe45b9046c2973/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fcoverageinfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fcoverageinfo.rs?ref=89fdb30892dbe330730ad1a1c1fe45b9046c2973", "patch": "@@ -10,19 +10,19 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n         let Coverage { kind, code_region } = coverage;\n         match kind {\n             CoverageKind::Counter { function_source_hash, id } => {\n-                bx.add_counter_region(self.instance, function_source_hash, id, code_region);\n+                if bx.add_counter_region(self.instance, function_source_hash, id, code_region) {\n+                    let coverageinfo = bx.tcx().coverageinfo(self.instance.def_id());\n \n-                let coverageinfo = bx.tcx().coverageinfo(self.instance.def_id());\n-\n-                let fn_name = bx.create_pgo_func_name_var(self.instance);\n-                let hash = bx.const_u64(function_source_hash);\n-                let num_counters = bx.const_u32(coverageinfo.num_counters);\n-                let id = bx.const_u32(u32::from(id));\n-                debug!(\n-                    \"codegen intrinsic instrprof.increment(fn_name={:?}, hash={:?}, num_counters={:?}, index={:?})\",\n-                    fn_name, hash, num_counters, id,\n-                );\n-                bx.instrprof_increment(fn_name, hash, num_counters, id);\n+                    let fn_name = bx.create_pgo_func_name_var(self.instance);\n+                    let hash = bx.const_u64(function_source_hash);\n+                    let num_counters = bx.const_u32(coverageinfo.num_counters);\n+                    let id = bx.const_u32(u32::from(id));\n+                    debug!(\n+                        \"codegen intrinsic instrprof.increment(fn_name={:?}, hash={:?}, num_counters={:?}, index={:?})\",\n+                        fn_name, hash, num_counters, id,\n+                    );\n+                    bx.instrprof_increment(fn_name, hash, num_counters, id);\n+                }\n             }\n             CoverageKind::Expression { id, lhs, op, rhs } => {\n                 bx.add_counter_expression_region(self.instance, id, lhs, op, rhs, code_region);"}, {"sha": "3b1654f3ad4fc94681bc0eff9f5821538afc2d47", "filename": "compiler/rustc_codegen_ssa/src/traits/coverageinfo.rs", "status": "modified", "additions": 9, "deletions": 3, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/89fdb30892dbe330730ad1a1c1fe45b9046c2973/compiler%2Frustc_codegen_ssa%2Fsrc%2Ftraits%2Fcoverageinfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89fdb30892dbe330730ad1a1c1fe45b9046c2973/compiler%2Frustc_codegen_ssa%2Fsrc%2Ftraits%2Fcoverageinfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Ftraits%2Fcoverageinfo.rs?ref=89fdb30892dbe330730ad1a1c1fe45b9046c2973", "patch": "@@ -9,14 +9,18 @@ pub trait CoverageInfoMethods: BackendTypes {\n pub trait CoverageInfoBuilderMethods<'tcx>: BackendTypes {\n     fn create_pgo_func_name_var(&self, instance: Instance<'tcx>) -> Self::Value;\n \n+    /// Returns true if the counter was added to the coverage map; false if `-Z instrument-coverage`\n+    /// is not enabled (a coverage map is not being generated).\n     fn add_counter_region(\n         &mut self,\n         instance: Instance<'tcx>,\n         function_source_hash: u64,\n         id: CounterValueReference,\n         region: CodeRegion,\n-    );\n+    ) -> bool;\n \n+    /// Returns true if the expression was added to the coverage map; false if\n+    /// `-Z instrument-coverage` is not enabled (a coverage map is not being generated).\n     fn add_counter_expression_region(\n         &mut self,\n         instance: Instance<'tcx>,\n@@ -25,7 +29,9 @@ pub trait CoverageInfoBuilderMethods<'tcx>: BackendTypes {\n         op: Op,\n         rhs: ExpressionOperandId,\n         region: CodeRegion,\n-    );\n+    ) -> bool;\n \n-    fn add_unreachable_region(&mut self, instance: Instance<'tcx>, region: CodeRegion);\n+    /// Returns true if the region was added to the coverage map; false if `-Z instrument-coverage`\n+    /// is not enabled (a coverage map is not being generated).\n+    fn add_unreachable_region(&mut self, instance: Instance<'tcx>, region: CodeRegion) -> bool;\n }"}, {"sha": "16e9aafb25a54e6987ab1534ab6a024e3e037f7f", "filename": "compiler/rustc_middle/src/infer/unify_key.rs", "status": "modified", "additions": 8, "deletions": 17, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/89fdb30892dbe330730ad1a1c1fe45b9046c2973/compiler%2Frustc_middle%2Fsrc%2Finfer%2Funify_key.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89fdb30892dbe330730ad1a1c1fe45b9046c2973/compiler%2Frustc_middle%2Fsrc%2Finfer%2Funify_key.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Finfer%2Funify_key.rs?ref=89fdb30892dbe330730ad1a1c1fe45b9046c2973", "patch": "@@ -175,19 +175,15 @@ impl<'tcx> UnifyKey for ty::ConstVid<'tcx> {\n impl<'tcx> UnifyValue for ConstVarValue<'tcx> {\n     type Error = (&'tcx ty::Const<'tcx>, &'tcx ty::Const<'tcx>);\n \n-    fn unify_values(value1: &Self, value2: &Self) -> Result<Self, Self::Error> {\n-        let (val, span) = match (value1.val, value2.val) {\n+    fn unify_values(&value1: &Self, &value2: &Self) -> Result<Self, Self::Error> {\n+        Ok(match (value1.val, value2.val) {\n             (ConstVariableValue::Known { .. }, ConstVariableValue::Known { .. }) => {\n                 bug!(\"equating two const variables, both of which have known values\")\n             }\n \n             // If one side is known, prefer that one.\n-            (ConstVariableValue::Known { .. }, ConstVariableValue::Unknown { .. }) => {\n-                (value1.val, value1.origin.span)\n-            }\n-            (ConstVariableValue::Unknown { .. }, ConstVariableValue::Known { .. }) => {\n-                (value2.val, value2.origin.span)\n-            }\n+            (ConstVariableValue::Known { .. }, ConstVariableValue::Unknown { .. }) => value1,\n+            (ConstVariableValue::Unknown { .. }, ConstVariableValue::Known { .. }) => value2,\n \n             // If both sides are *unknown*, it hardly matters, does it?\n             (\n@@ -200,16 +196,11 @@ impl<'tcx> UnifyValue for ConstVarValue<'tcx> {\n                 // universe is the minimum of the two universes, because that is\n                 // the one which contains the fewest names in scope.\n                 let universe = cmp::min(universe1, universe2);\n-                (ConstVariableValue::Unknown { universe }, value1.origin.span)\n+                ConstVarValue {\n+                    val: ConstVariableValue::Unknown { universe },\n+                    origin: value1.origin,\n+                }\n             }\n-        };\n-\n-        Ok(ConstVarValue {\n-            origin: ConstVariableOrigin {\n-                kind: ConstVariableOriginKind::ConstInference,\n-                span: span,\n-            },\n-            val,\n         })\n     }\n }"}, {"sha": "0e5e22dcaae9f34134dfaf4250e51189a81e3534", "filename": "compiler/rustc_middle/src/ty/fold.rs", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/89fdb30892dbe330730ad1a1c1fe45b9046c2973/compiler%2Frustc_middle%2Fsrc%2Fty%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89fdb30892dbe330730ad1a1c1fe45b9046c2973/compiler%2Frustc_middle%2Fsrc%2Fty%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Ffold.rs?ref=89fdb30892dbe330730ad1a1c1fe45b9046c2973", "patch": "@@ -30,8 +30,6 @@\n //!\n //! These methods return true to indicate that the visitor has found what it is\n //! looking for, and does not need to visit anything else.\n-\n-use crate::ty::structural_impls::PredicateVisitor;\n use crate::ty::{self, flags::FlagComputation, Binder, Ty, TyCtxt, TypeFlags};\n use rustc_hir as hir;\n use rustc_hir::def_id::DefId;\n@@ -211,6 +209,10 @@ pub trait TypeVisitor<'tcx>: Sized {\n     fn visit_const(&mut self, c: &'tcx ty::Const<'tcx>) -> bool {\n         c.super_visit_with(self)\n     }\n+\n+    fn visit_predicate(&mut self, p: ty::Predicate<'tcx>) -> bool {\n+        p.super_visit_with(self)\n+    }\n }\n \n ///////////////////////////////////////////////////////////////////////////\n@@ -868,9 +870,7 @@ impl<'tcx> TypeVisitor<'tcx> for HasEscapingVarsVisitor {\n             _ => ct.super_visit_with(self),\n         }\n     }\n-}\n \n-impl<'tcx> PredicateVisitor<'tcx> for HasEscapingVarsVisitor {\n     fn visit_predicate(&mut self, predicate: ty::Predicate<'tcx>) -> bool {\n         predicate.inner.outer_exclusive_binder > self.outer_index\n     }\n@@ -903,9 +903,7 @@ impl<'tcx> TypeVisitor<'tcx> for HasTypeFlagsVisitor {\n         debug!(\"HasTypeFlagsVisitor: c={:?} c.flags={:?} self.flags={:?}\", c, flags, self.flags);\n         flags.intersects(self.flags)\n     }\n-}\n \n-impl<'tcx> PredicateVisitor<'tcx> for HasTypeFlagsVisitor {\n     fn visit_predicate(&mut self, predicate: ty::Predicate<'tcx>) -> bool {\n         debug!(\n             \"HasTypeFlagsVisitor: predicate={:?} predicate.flags={:?} self.flags={:?}\",\n@@ -914,6 +912,7 @@ impl<'tcx> PredicateVisitor<'tcx> for HasTypeFlagsVisitor {\n         predicate.inner.flags.intersects(self.flags)\n     }\n }\n+\n /// Collects all the late-bound regions at the innermost binding level\n /// into a hash set.\n struct LateBoundRegionsCollector {"}, {"sha": "53521d0e9f332021dc0df1933e8ee0a229a2b1b1", "filename": "compiler/rustc_middle/src/ty/structural_impls.rs", "status": "modified", "additions": 0, "deletions": 10, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/89fdb30892dbe330730ad1a1c1fe45b9046c2973/compiler%2Frustc_middle%2Fsrc%2Fty%2Fstructural_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89fdb30892dbe330730ad1a1c1fe45b9046c2973/compiler%2Frustc_middle%2Fsrc%2Fty%2Fstructural_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fstructural_impls.rs?ref=89fdb30892dbe330730ad1a1c1fe45b9046c2973", "patch": "@@ -1040,16 +1040,6 @@ impl<'tcx> TypeFoldable<'tcx> for ty::Predicate<'tcx> {\n     }\n }\n \n-pub(super) trait PredicateVisitor<'tcx>: TypeVisitor<'tcx> {\n-    fn visit_predicate(&mut self, predicate: ty::Predicate<'tcx>) -> bool;\n-}\n-\n-impl<T: TypeVisitor<'tcx>> PredicateVisitor<'tcx> for T {\n-    default fn visit_predicate(&mut self, predicate: ty::Predicate<'tcx>) -> bool {\n-        predicate.super_visit_with(self)\n-    }\n-}\n-\n impl<'tcx> TypeFoldable<'tcx> for &'tcx ty::List<ty::Predicate<'tcx>> {\n     fn super_fold_with<F: TypeFolder<'tcx>>(&self, folder: &mut F) -> Self {\n         fold_list(*self, folder, |tcx, v| tcx.intern_predicates(v))"}, {"sha": "a9a45e61a38cbf85c1189dd480bdcadfd43e7ddd", "filename": "compiler/rustc_mir/src/transform/simplify_branches.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/89fdb30892dbe330730ad1a1c1fe45b9046c2973/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fsimplify_branches.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89fdb30892dbe330730ad1a1c1fe45b9046c2973/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fsimplify_branches.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fsimplify_branches.rs?ref=89fdb30892dbe330730ad1a1c1fe45b9046c2973", "patch": "@@ -49,9 +49,10 @@ impl<'tcx> MirPass<'tcx> for SimplifyBranches {\n                 }\n                 TerminatorKind::Assert {\n                     target, cond: Operand::Constant(ref c), expected, ..\n-                } if (c.literal.try_eval_bool(tcx, param_env) == Some(true)) == expected => {\n-                    TerminatorKind::Goto { target }\n-                }\n+                } => match c.literal.try_eval_bool(tcx, param_env) {\n+                    Some(v) if v == expected => TerminatorKind::Goto { target },\n+                    _ => continue,\n+                },\n                 TerminatorKind::FalseEdge { real_target, .. } => {\n                     TerminatorKind::Goto { target: real_target }\n                 }"}, {"sha": "1b17c2c278f9abd9ff374f2daf85e6f0c730b53a", "filename": "compiler/rustc_target/src/spec/apple_sdk_base.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/89fdb30892dbe330730ad1a1c1fe45b9046c2973/compiler%2Frustc_target%2Fsrc%2Fspec%2Fapple_sdk_base.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89fdb30892dbe330730ad1a1c1fe45b9046c2973/compiler%2Frustc_target%2Fsrc%2Fspec%2Fapple_sdk_base.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_target%2Fsrc%2Fspec%2Fapple_sdk_base.rs?ref=89fdb30892dbe330730ad1a1c1fe45b9046c2973", "patch": "@@ -34,6 +34,7 @@ fn link_env_remove(arch: Arch) -> Vec<String> {\n pub fn opts(arch: Arch) -> TargetOptions {\n     TargetOptions {\n         cpu: target_cpu(arch),\n+        dynamic_linking: false,\n         executables: true,\n         link_env_remove: link_env_remove(arch),\n         has_elf_tls: false,"}, {"sha": "c039be8f67cda990b137d2bd0df4de94620b2b08", "filename": "library/alloc/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/89fdb30892dbe330730ad1a1c1fe45b9046c2973/library%2Falloc%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89fdb30892dbe330730ad1a1c1fe45b9046c2973/library%2Falloc%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Flib.rs?ref=89fdb30892dbe330730ad1a1c1fe45b9046c2973", "patch": "@@ -118,6 +118,7 @@\n #![feature(raw_ref_op)]\n #![feature(rustc_attrs)]\n #![feature(receiver_trait)]\n+#![feature(renamed_spin_loop)]\n #![feature(min_specialization)]\n #![feature(slice_ptr_get)]\n #![feature(slice_ptr_len)]"}, {"sha": "cd18535b0697d9df0767db1d65215ab1fa8a8d08", "filename": "library/alloc/src/sync.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/89fdb30892dbe330730ad1a1c1fe45b9046c2973/library%2Falloc%2Fsrc%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89fdb30892dbe330730ad1a1c1fe45b9046c2973/library%2Falloc%2Fsrc%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fsync.rs?ref=89fdb30892dbe330730ad1a1c1fe45b9046c2973", "patch": "@@ -10,6 +10,7 @@ use core::cmp::Ordering;\n use core::convert::{From, TryFrom};\n use core::fmt;\n use core::hash::{Hash, Hasher};\n+use core::hint;\n use core::intrinsics::abort;\n use core::iter;\n use core::marker::{PhantomData, Unpin, Unsize};\n@@ -764,6 +765,7 @@ impl<T: ?Sized> Arc<T> {\n         loop {\n             // check if the weak counter is currently \"locked\"; if so, spin.\n             if cur == usize::MAX {\n+                hint::spin_loop();\n                 cur = this.inner().weak.load(Relaxed);\n                 continue;\n             }"}, {"sha": "834dd4656ff76bdb171ef96c3329af15e6ff1e31", "filename": "library/alloc/tests/str.rs", "status": "modified", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/89fdb30892dbe330730ad1a1c1fe45b9046c2973/library%2Falloc%2Ftests%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89fdb30892dbe330730ad1a1c1fe45b9046c2973/library%2Falloc%2Ftests%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Ftests%2Fstr.rs?ref=89fdb30892dbe330730ad1a1c1fe45b9046c2973", "patch": "@@ -529,6 +529,13 @@ mod slice_index {\n             message: \"out of bounds\";\n         }\n \n+        in mod rangeinclusive_len {\n+            data: \"abcdef\";\n+            good: data[0..=5] == \"abcdef\";\n+            bad: data[0..=6];\n+            message: \"out of bounds\";\n+        }\n+\n         in mod range_len_len {\n             data: \"abcdef\";\n             good: data[6..6] == \"\";\n@@ -544,6 +551,28 @@ mod slice_index {\n         }\n     }\n \n+    panic_cases! {\n+        in mod rangeinclusive_exhausted {\n+            data: \"abcdef\";\n+\n+            good: data[0..=5] == \"abcdef\";\n+            good: data[{\n+                let mut iter = 0..=5;\n+                iter.by_ref().count(); // exhaust it\n+                iter\n+            }] == \"\";\n+\n+            // 0..=6 is out of bounds before exhaustion, so it\n+            // stands to reason that it still would be after.\n+            bad: data[{\n+                let mut iter = 0..=6;\n+                iter.by_ref().count(); // exhaust it\n+                iter\n+            }];\n+            message: \"out of bounds\";\n+        }\n+    }\n+\n     panic_cases! {\n         in mod range_neg_width {\n             data: \"abcdef\";"}, {"sha": "1d67e65e51f5f16effad651f589cd99b13a2163b", "filename": "library/core/src/ops/range.rs", "status": "modified", "additions": 31, "deletions": 1, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/89fdb30892dbe330730ad1a1c1fe45b9046c2973/library%2Fcore%2Fsrc%2Fops%2Frange.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89fdb30892dbe330730ad1a1c1fe45b9046c2973/library%2Fcore%2Fsrc%2Fops%2Frange.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fops%2Frange.rs?ref=89fdb30892dbe330730ad1a1c1fe45b9046c2973", "patch": "@@ -446,6 +446,20 @@ impl<Idx> RangeInclusive<Idx> {\n     }\n }\n \n+impl RangeInclusive<usize> {\n+    /// Converts to an exclusive `Range` for `SliceIndex` implementations.\n+    /// The caller is responsible for dealing with `end == usize::MAX`.\n+    #[inline]\n+    pub(crate) fn into_slice_range(self) -> Range<usize> {\n+        // If we're not exhausted, we want to simply slice `start..end + 1`.\n+        // If we are exhausted, then slicing with `end + 1..end + 1` gives us an\n+        // empty range that is still subject to bounds-checks for that endpoint.\n+        let exclusive_end = self.end + 1;\n+        let start = if self.exhausted { exclusive_end } else { self.start };\n+        start..exclusive_end\n+    }\n+}\n+\n #[stable(feature = \"inclusive_range\", since = \"1.26.0\")]\n impl<Idx: fmt::Debug> fmt::Debug for RangeInclusive<Idx> {\n     fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {\n@@ -479,6 +493,16 @@ impl<Idx: PartialOrd<Idx>> RangeInclusive<Idx> {\n     /// assert!(!(0.0..=f32::NAN).contains(&0.0));\n     /// assert!(!(f32::NAN..=1.0).contains(&1.0));\n     /// ```\n+    ///\n+    /// This method always returns `false` after iteration has finished:\n+    ///\n+    /// ```\n+    /// let mut r = 3..=5;\n+    /// assert!(r.contains(&3) && r.contains(&5));\n+    /// for _ in r.by_ref() {}\n+    /// // Precise field values are unspecified here\n+    /// assert!(!r.contains(&3) && !r.contains(&5));\n+    /// ```\n     #[stable(feature = \"range_contains\", since = \"1.35.0\")]\n     pub fn contains<U>(&self, item: &U) -> bool\n     where\n@@ -881,7 +905,13 @@ impl<T> RangeBounds<T> for RangeInclusive<T> {\n         Included(&self.start)\n     }\n     fn end_bound(&self) -> Bound<&T> {\n-        Included(&self.end)\n+        if self.exhausted {\n+            // When the iterator is exhausted, we usually have start == end,\n+            // but we want the range to appear empty, containing nothing.\n+            Excluded(&self.end)\n+        } else {\n+            Included(&self.end)\n+        }\n     }\n }\n "}, {"sha": "3daf26208b937b3336f3675661ae897e5070bc1b", "filename": "library/core/src/option.rs", "status": "modified", "additions": 37, "deletions": 7, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/89fdb30892dbe330730ad1a1c1fe45b9046c2973/library%2Fcore%2Fsrc%2Foption.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89fdb30892dbe330730ad1a1c1fe45b9046c2973/library%2Fcore%2Fsrc%2Foption.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Foption.rs?ref=89fdb30892dbe330730ad1a1c1fe45b9046c2973", "patch": "@@ -562,6 +562,36 @@ impl<T> Option<T> {\n         }\n     }\n \n+    /// Inserts `value` into the option then returns a mutable reference to it.\n+    ///\n+    /// If the option already contains a value, the old value is dropped.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// #![feature(option_insert)]\n+    ///\n+    /// let mut opt = None;\n+    /// let val = opt.insert(1);\n+    /// assert_eq!(*val, 1);\n+    /// assert_eq!(opt.unwrap(), 1);\n+    /// let val = opt.insert(2);\n+    /// assert_eq!(*val, 2);\n+    /// *val = 3;\n+    /// assert_eq!(opt.unwrap(), 3);\n+    /// ```\n+    #[inline]\n+    #[unstable(feature = \"option_insert\", reason = \"newly added\", issue = \"78271\")]\n+    pub fn insert(&mut self, value: T) -> &mut T {\n+        *self = Some(value);\n+\n+        match self {\n+            Some(v) => v,\n+            // SAFETY: the code above just filled the option\n+            None => unsafe { hint::unreachable_unchecked() },\n+        }\n+    }\n+\n     /////////////////////////////////////////////////////////////////////////\n     // Iterator constructors\n     /////////////////////////////////////////////////////////////////////////\n@@ -792,7 +822,7 @@ impl<T> Option<T> {\n     // Entry-like operations to insert if None and return a reference\n     /////////////////////////////////////////////////////////////////////////\n \n-    /// Inserts `v` into the option if it is [`None`], then\n+    /// Inserts `value` into the option if it is [`None`], then\n     /// returns a mutable reference to the contained value.\n     ///\n     /// # Examples\n@@ -811,12 +841,12 @@ impl<T> Option<T> {\n     /// ```\n     #[inline]\n     #[stable(feature = \"option_entry\", since = \"1.20.0\")]\n-    pub fn get_or_insert(&mut self, v: T) -> &mut T {\n-        self.get_or_insert_with(|| v)\n+    pub fn get_or_insert(&mut self, value: T) -> &mut T {\n+        self.get_or_insert_with(|| value)\n     }\n \n-    /// Inserts a value computed from `f` into the option if it is [`None`], then\n-    /// returns a mutable reference to the contained value.\n+    /// Inserts a value computed from `f` into the option if it is [`None`],\n+    /// then returns a mutable reference to the contained value.\n     ///\n     /// # Examples\n     ///\n@@ -839,8 +869,8 @@ impl<T> Option<T> {\n             *self = Some(f());\n         }\n \n-        match *self {\n-            Some(ref mut v) => v,\n+        match self {\n+            Some(v) => v,\n             // SAFETY: a `None` variant for `self` would have been replaced by a `Some`\n             // variant in the code above.\n             None => unsafe { hint::unreachable_unchecked() },"}, {"sha": "660c8a2da5da04ac3a8006d05ea6bd830e80cd93", "filename": "library/core/src/slice/index.rs", "status": "modified", "additions": 6, "deletions": 10, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/89fdb30892dbe330730ad1a1c1fe45b9046c2973/library%2Fcore%2Fsrc%2Fslice%2Findex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89fdb30892dbe330730ad1a1c1fe45b9046c2973/library%2Fcore%2Fsrc%2Fslice%2Findex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fslice%2Findex.rs?ref=89fdb30892dbe330730ad1a1c1fe45b9046c2973", "patch": "@@ -376,44 +376,40 @@ unsafe impl<T> SliceIndex<[T]> for ops::RangeInclusive<usize> {\n \n     #[inline]\n     fn get(self, slice: &[T]) -> Option<&[T]> {\n-        if *self.end() == usize::MAX { None } else { (*self.start()..self.end() + 1).get(slice) }\n+        if *self.end() == usize::MAX { None } else { self.into_slice_range().get(slice) }\n     }\n \n     #[inline]\n     fn get_mut(self, slice: &mut [T]) -> Option<&mut [T]> {\n-        if *self.end() == usize::MAX {\n-            None\n-        } else {\n-            (*self.start()..self.end() + 1).get_mut(slice)\n-        }\n+        if *self.end() == usize::MAX { None } else { self.into_slice_range().get_mut(slice) }\n     }\n \n     #[inline]\n     unsafe fn get_unchecked(self, slice: *const [T]) -> *const [T] {\n         // SAFETY: the caller has to uphold the safety contract for `get_unchecked`.\n-        unsafe { (*self.start()..self.end() + 1).get_unchecked(slice) }\n+        unsafe { self.into_slice_range().get_unchecked(slice) }\n     }\n \n     #[inline]\n     unsafe fn get_unchecked_mut(self, slice: *mut [T]) -> *mut [T] {\n         // SAFETY: the caller has to uphold the safety contract for `get_unchecked_mut`.\n-        unsafe { (*self.start()..self.end() + 1).get_unchecked_mut(slice) }\n+        unsafe { self.into_slice_range().get_unchecked_mut(slice) }\n     }\n \n     #[inline]\n     fn index(self, slice: &[T]) -> &[T] {\n         if *self.end() == usize::MAX {\n             slice_end_index_overflow_fail();\n         }\n-        (*self.start()..self.end() + 1).index(slice)\n+        self.into_slice_range().index(slice)\n     }\n \n     #[inline]\n     fn index_mut(self, slice: &mut [T]) -> &mut [T] {\n         if *self.end() == usize::MAX {\n             slice_end_index_overflow_fail();\n         }\n-        (*self.start()..self.end() + 1).index_mut(slice)\n+        self.into_slice_range().index_mut(slice)\n     }\n }\n "}, {"sha": "9cfb5a899877371ce156bb4860324faca2e85eae", "filename": "library/core/src/str/traits.rs", "status": "modified", "additions": 6, "deletions": 10, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/89fdb30892dbe330730ad1a1c1fe45b9046c2973/library%2Fcore%2Fsrc%2Fstr%2Ftraits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89fdb30892dbe330730ad1a1c1fe45b9046c2973/library%2Fcore%2Fsrc%2Fstr%2Ftraits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fstr%2Ftraits.rs?ref=89fdb30892dbe330730ad1a1c1fe45b9046c2973", "patch": "@@ -398,39 +398,35 @@ unsafe impl SliceIndex<str> for ops::RangeInclusive<usize> {\n     type Output = str;\n     #[inline]\n     fn get(self, slice: &str) -> Option<&Self::Output> {\n-        if *self.end() == usize::MAX { None } else { (*self.start()..self.end() + 1).get(slice) }\n+        if *self.end() == usize::MAX { None } else { self.into_slice_range().get(slice) }\n     }\n     #[inline]\n     fn get_mut(self, slice: &mut str) -> Option<&mut Self::Output> {\n-        if *self.end() == usize::MAX {\n-            None\n-        } else {\n-            (*self.start()..self.end() + 1).get_mut(slice)\n-        }\n+        if *self.end() == usize::MAX { None } else { self.into_slice_range().get_mut(slice) }\n     }\n     #[inline]\n     unsafe fn get_unchecked(self, slice: *const str) -> *const Self::Output {\n         // SAFETY: the caller must uphold the safety contract for `get_unchecked`.\n-        unsafe { (*self.start()..self.end() + 1).get_unchecked(slice) }\n+        unsafe { self.into_slice_range().get_unchecked(slice) }\n     }\n     #[inline]\n     unsafe fn get_unchecked_mut(self, slice: *mut str) -> *mut Self::Output {\n         // SAFETY: the caller must uphold the safety contract for `get_unchecked_mut`.\n-        unsafe { (*self.start()..self.end() + 1).get_unchecked_mut(slice) }\n+        unsafe { self.into_slice_range().get_unchecked_mut(slice) }\n     }\n     #[inline]\n     fn index(self, slice: &str) -> &Self::Output {\n         if *self.end() == usize::MAX {\n             str_index_overflow_fail();\n         }\n-        (*self.start()..self.end() + 1).index(slice)\n+        self.into_slice_range().index(slice)\n     }\n     #[inline]\n     fn index_mut(self, slice: &mut str) -> &mut Self::Output {\n         if *self.end() == usize::MAX {\n             str_index_overflow_fail();\n         }\n-        (*self.start()..self.end() + 1).index_mut(slice)\n+        self.into_slice_range().index_mut(slice)\n     }\n }\n "}, {"sha": "9ccc5a08dcbeab1e254f54f9a90fcbadb8bb786d", "filename": "library/core/tests/slice.rs", "status": "modified", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/89fdb30892dbe330730ad1a1c1fe45b9046c2973/library%2Fcore%2Ftests%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89fdb30892dbe330730ad1a1c1fe45b9046c2973/library%2Fcore%2Ftests%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Ftests%2Fslice.rs?ref=89fdb30892dbe330730ad1a1c1fe45b9046c2973", "patch": "@@ -1341,6 +1341,14 @@ mod slice_index {\n             message: \"out of range\";\n         }\n \n+        in mod rangeinclusive_len {\n+            data: [0, 1, 2, 3, 4, 5];\n+\n+            good: data[0..=5] == [0, 1, 2, 3, 4, 5];\n+            bad: data[0..=6];\n+            message: \"out of range\";\n+        }\n+\n         in mod range_len_len {\n             data: [0, 1, 2, 3, 4, 5];\n \n@@ -1358,6 +1366,28 @@ mod slice_index {\n         }\n     }\n \n+    panic_cases! {\n+        in mod rangeinclusive_exhausted {\n+            data: [0, 1, 2, 3, 4, 5];\n+\n+            good: data[0..=5] == [0, 1, 2, 3, 4, 5];\n+            good: data[{\n+                let mut iter = 0..=5;\n+                iter.by_ref().count(); // exhaust it\n+                iter\n+            }] == [];\n+\n+            // 0..=6 is out of range before exhaustion, so it\n+            // stands to reason that it still would be after.\n+            bad: data[{\n+                let mut iter = 0..=6;\n+                iter.by_ref().count(); // exhaust it\n+                iter\n+            }];\n+            message: \"out of range\";\n+        }\n+    }\n+\n     panic_cases! {\n         in mod range_neg_width {\n             data: [0, 1, 2, 3, 4, 5];"}, {"sha": "9b704ee9ecab2debb5908463fa576ddc0c0c6680", "filename": "library/std/src/keyword_docs.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/89fdb30892dbe330730ad1a1c1fe45b9046c2973/library%2Fstd%2Fsrc%2Fkeyword_docs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89fdb30892dbe330730ad1a1c1fe45b9046c2973/library%2Fstd%2Fsrc%2Fkeyword_docs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fkeyword_docs.rs?ref=89fdb30892dbe330730ad1a1c1fe45b9046c2973", "patch": "@@ -346,14 +346,15 @@ mod else_keyword {}\n /// When data follows along with a variant, such as with rust's built-in [`Option`] type, the data\n /// is added as the type describes, for example `Option::Some(123)`. The same follows with\n /// struct-like variants, with things looking like `ComplexEnum::LotsOfThings { usual_struct_stuff:\n-/// true, blah: \"hello!\".to_string(), }`. Empty Enums are similar to () in that they cannot be\n+/// true, blah: \"hello!\".to_string(), }`. Empty Enums are similar to [`!`] in that they cannot be\n /// instantiated at all, and are used mainly to mess with the type system in interesting ways.\n ///\n /// For more information, take a look at the [Rust Book] or the [Reference]\n ///\n /// [ADT]: https://en.wikipedia.org/wiki/Algebraic_data_type\n /// [Rust Book]: ../book/ch06-01-defining-an-enum.html\n /// [Reference]: ../reference/items/enumerations.html\n+/// [`!`]: primitive.never.html\n mod enum_keyword {}\n \n #[doc(keyword = \"extern\")]"}, {"sha": "3834e50e3fa117608902525001fd341776cac5e7", "filename": "src/bootstrap/flags.rs", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/89fdb30892dbe330730ad1a1c1fe45b9046c2973/src%2Fbootstrap%2Fflags.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89fdb30892dbe330730ad1a1c1fe45b9046c2973/src%2Fbootstrap%2Fflags.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fflags.rs?ref=89fdb30892dbe330730ad1a1c1fe45b9046c2973", "patch": "@@ -232,7 +232,13 @@ To learn more about a subcommand, run `./x.py <subcommand> -h`\",\n         match subcommand.as_str() {\n             \"test\" | \"t\" => {\n                 opts.optflag(\"\", \"no-fail-fast\", \"Run all tests regardless of failure\");\n-                opts.optmulti(\"\", \"test-args\", \"extra arguments\", \"ARGS\");\n+                opts.optmulti(\n+                    \"\",\n+                    \"test-args\",\n+                    \"extra arguments to be passed for the test tool being used \\\n+                        (e.g. libtest, compiletest or rustdoc)\",\n+                    \"ARGS\",\n+                );\n                 opts.optmulti(\n                     \"\",\n                     \"rustc-args\","}, {"sha": "00e1c79ca3ff39bf7de34f33a4d0f0e0f25215b3", "filename": "src/doc/unstable-book/src/language-features/inline-const.md", "status": "added", "additions": 45, "deletions": 0, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/89fdb30892dbe330730ad1a1c1fe45b9046c2973/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Finline-const.md", "raw_url": "https://github.com/rust-lang/rust/raw/89fdb30892dbe330730ad1a1c1fe45b9046c2973/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Finline-const.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Finline-const.md?ref=89fdb30892dbe330730ad1a1c1fe45b9046c2973", "patch": "@@ -0,0 +1,45 @@\n+# `inline_const`\n+\n+The tracking issue for this feature is: [#76001]\n+\n+------\n+\n+This feature allows you to use inline constant expressions. For example, you can\n+turn this code:\n+\n+```rust\n+# fn add_one(x: i32) -> i32 { x + 1 }\n+const MY_COMPUTATION: i32 = 1 + 2 * 3 / 4;\n+\n+fn main() {\n+    let x = add_one(MY_COMPUTATION);\n+}\n+```\n+\n+into this code:\n+\n+```rust\n+#![feature(inline_const)]\n+\n+# fn add_one(x: i32) -> i32 { x + 1 }\n+fn main() {\n+    let x = add_one(const { 1 + 2 * 3 / 4 });\n+}\n+```\n+\n+You can also use inline constant expressions in patterns:\n+\n+```rust\n+#![feature(inline_const)]\n+\n+const fn one() -> i32 { 1 }\n+\n+let some_int = 3;\n+match some_int {\n+    const { 1 + 2 } => println!(\"Matched 1 + 2\"),\n+    const { one() } => println!(\"Matched const fn returning 1\"),\n+    _ => println!(\"Didn't match anything :(\"),\n+}\n+```\n+\n+[#76001]: https://github.com/rust-lang/rust/issues/76001"}, {"sha": "ef734f260afd558ef83bde75dda9ae56285ed367", "filename": "src/librustdoc/html/static/storage.js", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/89fdb30892dbe330730ad1a1c1fe45b9046c2973/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fstorage.js", "raw_url": "https://github.com/rust-lang/rust/raw/89fdb30892dbe330730ad1a1c1fe45b9046c2973/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fstorage.js", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fstorage.js?ref=89fdb30892dbe330730ad1a1c1fe45b9046c2973", "patch": "@@ -94,6 +94,12 @@ function switchTheme(styleElem, mainStyleElem, newTheme, saveTheme) {\n     var fullNewTheme = newTheme + resourcesSuffix + \".css\";\n     var newHref = mainStyleElem.href.replace(fullBasicCss, fullNewTheme);\n \n+    // If this new value comes from a system setting or from the previously\n+    // saved theme, no need to save it.\n+    if (saveTheme === true) {\n+        updateLocalStorage(\"rustdoc-theme\", newTheme);\n+    }\n+\n     if (styleElem.href === newHref) {\n         return;\n     }\n@@ -112,11 +118,6 @@ function switchTheme(styleElem, mainStyleElem, newTheme, saveTheme) {\n     });\n     if (found === true) {\n         styleElem.href = newHref;\n-        // If this new value comes from a system setting or from the previously\n-        // saved theme, no need to save it.\n-        if (saveTheme === true) {\n-            updateLocalStorage(\"rustdoc-theme\", newTheme);\n-        }\n     }\n }\n "}, {"sha": "63facbf3b8c0f3f23106d0bedf5c569f3a065a01", "filename": "src/test/ui/const-generics/infer/issue-77092.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/89fdb30892dbe330730ad1a1c1fe45b9046c2973/src%2Ftest%2Fui%2Fconst-generics%2Finfer%2Fissue-77092.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/89fdb30892dbe330730ad1a1c1fe45b9046c2973/src%2Ftest%2Fui%2Fconst-generics%2Finfer%2Fissue-77092.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Finfer%2Fissue-77092.stderr?ref=89fdb30892dbe330730ad1a1c1fe45b9046c2973", "patch": "@@ -2,7 +2,7 @@ error[E0282]: type annotations needed\n   --> $DIR/issue-77092.rs:13:26\n    |\n LL |         println!(\"{:?}\", take_array_from_mut(&mut arr, i));\n-   |                          ^^^^^^^^^^^^^^^^^^^ cannot infer the value of the constant `{_: usize}`\n+   |                          ^^^^^^^^^^^^^^^^^^^ cannot infer the value of const parameter `N` declared on the function `take_array_from_mut`\n \n error: aborting due to previous error\n "}, {"sha": "7b32a33ea4f1786db36add68274c8a06360079c0", "filename": "src/test/ui/macros/issue-77475.rs", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/89fdb30892dbe330730ad1a1c1fe45b9046c2973/src%2Ftest%2Fui%2Fmacros%2Fissue-77475.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89fdb30892dbe330730ad1a1c1fe45b9046c2973/src%2Ftest%2Fui%2Fmacros%2Fissue-77475.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmacros%2Fissue-77475.rs?ref=89fdb30892dbe330730ad1a1c1fe45b9046c2973", "patch": "@@ -0,0 +1,10 @@\n+// check-pass\n+// Regression test of #77475, this used to be ICE.\n+\n+#![feature(decl_macro)]\n+\n+use crate as _;\n+\n+pub macro ice(){}\n+\n+fn main() {}"}]}