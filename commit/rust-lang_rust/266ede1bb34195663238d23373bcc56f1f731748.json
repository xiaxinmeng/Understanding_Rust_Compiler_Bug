{"sha": "266ede1bb34195663238d23373bcc56f1f731748", "node_id": "MDY6Q29tbWl0NzI0NzEyOjI2NmVkZTFiYjM0MTk1NjYzMjM4ZDIzMzczYmNjNTZmMWY3MzE3NDg=", "commit": {"author": {"name": "Camille GILLOT", "email": "gillot.camille@gmail.com", "date": "2019-11-24T14:59:22Z"}, "committer": {"name": "Camille GILLOT", "email": "gillot.camille@gmail.com", "date": "2019-11-24T22:21:43Z"}, "message": "Isolate compiler queries inside the Queries type.", "tree": {"sha": "fa848307133b8b62dab2df7e4efb9dcb91bbfd7d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/fa848307133b8b62dab2df7e4efb9dcb91bbfd7d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/266ede1bb34195663238d23373bcc56f1f731748", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/266ede1bb34195663238d23373bcc56f1f731748", "html_url": "https://github.com/rust-lang/rust/commit/266ede1bb34195663238d23373bcc56f1f731748", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/266ede1bb34195663238d23373bcc56f1f731748/comments", "author": {"login": "cjgillot", "id": 1822483, "node_id": "MDQ6VXNlcjE4MjI0ODM=", "avatar_url": "https://avatars.githubusercontent.com/u/1822483?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cjgillot", "html_url": "https://github.com/cjgillot", "followers_url": "https://api.github.com/users/cjgillot/followers", "following_url": "https://api.github.com/users/cjgillot/following{/other_user}", "gists_url": "https://api.github.com/users/cjgillot/gists{/gist_id}", "starred_url": "https://api.github.com/users/cjgillot/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cjgillot/subscriptions", "organizations_url": "https://api.github.com/users/cjgillot/orgs", "repos_url": "https://api.github.com/users/cjgillot/repos", "events_url": "https://api.github.com/users/cjgillot/events{/privacy}", "received_events_url": "https://api.github.com/users/cjgillot/received_events", "type": "User", "site_admin": false}, "committer": {"login": "cjgillot", "id": 1822483, "node_id": "MDQ6VXNlcjE4MjI0ODM=", "avatar_url": "https://avatars.githubusercontent.com/u/1822483?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cjgillot", "html_url": "https://github.com/cjgillot", "followers_url": "https://api.github.com/users/cjgillot/followers", "following_url": "https://api.github.com/users/cjgillot/following{/other_user}", "gists_url": "https://api.github.com/users/cjgillot/gists{/gist_id}", "starred_url": "https://api.github.com/users/cjgillot/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cjgillot/subscriptions", "organizations_url": "https://api.github.com/users/cjgillot/orgs", "repos_url": "https://api.github.com/users/cjgillot/repos", "events_url": "https://api.github.com/users/cjgillot/events{/privacy}", "received_events_url": "https://api.github.com/users/cjgillot/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "412f43ac5b4ae8c3599e71c6972112e9be4758fa", "url": "https://api.github.com/repos/rust-lang/rust/commits/412f43ac5b4ae8c3599e71c6972112e9be4758fa", "html_url": "https://github.com/rust-lang/rust/commit/412f43ac5b4ae8c3599e71c6972112e9be4758fa"}], "stats": {"total": 395, "additions": 219, "deletions": 176}, "files": [{"sha": "f28119fb66a3fd64181c6018ee0e9ad9bf7896e4", "filename": "src/librustc_driver/lib.rs", "status": "modified", "additions": 95, "deletions": 91, "changes": 186, "blob_url": "https://github.com/rust-lang/rust/blob/266ede1bb34195663238d23373bcc56f1f731748/src%2Flibrustc_driver%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/266ede1bb34195663238d23373bcc56f1f731748/src%2Flibrustc_driver%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Flib.rs?ref=266ede1bb34195663238d23373bcc56f1f731748", "patch": "@@ -283,120 +283,124 @@ pub fn run_compiler(\n             return sess.compile_status();\n         }\n \n-        compiler.parse()?;\n-\n-        if let Some(ppm) = &sess.opts.pretty {\n-            if ppm.needs_ast_map() {\n-                compiler.global_ctxt()?.peek_mut().enter(|tcx| {\n-                    let expanded_crate = compiler.expansion()?.take().0;\n-                    pretty::print_after_hir_lowering(\n-                        tcx,\n-                        compiler.input(),\n-                        &expanded_crate,\n+        compiler.enter(|queries| {\n+            queries.parse()?;\n+\n+            if let Some(ppm) = &sess.opts.pretty {\n+                if ppm.needs_ast_map() {\n+                    queries.global_ctxt()?.peek_mut().enter(|tcx| {\n+                        let expanded_crate = queries.expansion()?.take().0;\n+                        pretty::print_after_hir_lowering(\n+                            tcx,\n+                            compiler.input(),\n+                            &expanded_crate,\n+                            *ppm,\n+                            compiler.output_file().as_ref().map(|p| &**p),\n+                        );\n+                        Ok(())\n+                    })?;\n+                } else {\n+                    let krate = queries.parse()?.take();\n+                    pretty::print_after_parsing(\n+                        sess,\n+                        &compiler.input(),\n+                        &krate,\n                         *ppm,\n                         compiler.output_file().as_ref().map(|p| &**p),\n                     );\n-                    Ok(())\n-                })?;\n-            } else {\n-                let krate = compiler.parse()?.take();\n-                pretty::print_after_parsing(\n-                    sess,\n-                    &compiler.input(),\n-                    &krate,\n-                    *ppm,\n-                    compiler.output_file().as_ref().map(|p| &**p),\n-                );\n+                }\n+                return sess.compile_status();\n             }\n-            return sess.compile_status();\n-        }\n \n-        if callbacks.after_parsing(compiler) == Compilation::Stop {\n-            return sess.compile_status();\n-        }\n+            if callbacks.after_parsing(compiler) == Compilation::Stop {\n+                return sess.compile_status();\n+            }\n \n-        if sess.opts.debugging_opts.parse_only ||\n-           sess.opts.debugging_opts.show_span.is_some() ||\n-           sess.opts.debugging_opts.ast_json_noexpand {\n-            return sess.compile_status();\n-        }\n+            if sess.opts.debugging_opts.parse_only ||\n+               sess.opts.debugging_opts.show_span.is_some() ||\n+               sess.opts.debugging_opts.ast_json_noexpand {\n+                return sess.compile_status();\n+            }\n+\n+            {\n+                let (_, lint_store) = &*queries.register_plugins()?.peek();\n \n-        {\n-            let (_, lint_store) = &*compiler.register_plugins()?.peek();\n+                // Lint plugins are registered; now we can process command line flags.\n+                if sess.opts.describe_lints {\n+                    describe_lints(&sess, &lint_store, true);\n+                    return sess.compile_status();\n+                }\n+            }\n \n-            // Lint plugins are registered; now we can process command line flags.\n-            if sess.opts.describe_lints {\n-                describe_lints(&sess, &lint_store, true);\n+            queries.expansion()?;\n+            if callbacks.after_expansion(compiler) == Compilation::Stop {\n                 return sess.compile_status();\n             }\n-        }\n \n-        compiler.expansion()?;\n-        if callbacks.after_expansion(compiler) == Compilation::Stop {\n-            return sess.compile_status();\n-        }\n+            queries.prepare_outputs()?;\n+\n+            if sess.opts.output_types.contains_key(&OutputType::DepInfo)\n+                && sess.opts.output_types.len() == 1\n+            {\n+                return sess.compile_status();\n+            }\n \n-        compiler.prepare_outputs()?;\n+            queries.global_ctxt()?;\n \n-        if sess.opts.output_types.contains_key(&OutputType::DepInfo)\n-            && sess.opts.output_types.len() == 1\n-        {\n-            return sess.compile_status();\n-        }\n+            if sess.opts.debugging_opts.no_analysis ||\n+               sess.opts.debugging_opts.ast_json {\n+                return sess.compile_status();\n+            }\n \n-        compiler.global_ctxt()?;\n+            if sess.opts.debugging_opts.save_analysis {\n+                let expanded_crate = &queries.expansion()?.peek().0;\n+                let crate_name = queries.crate_name()?.peek().clone();\n+                queries.global_ctxt()?.peek_mut().enter(|tcx| {\n+                    let result = tcx.analysis(LOCAL_CRATE);\n+\n+                    time(sess, \"save analysis\", || {\n+                        save::process_crate(\n+                            tcx,\n+                            &expanded_crate,\n+                            &crate_name,\n+                            &compiler.input(),\n+                            None,\n+                            DumpHandler::new(compiler.output_dir().as_ref().map(|p| &**p), &crate_name)\n+                        )\n+                    });\n \n-        if sess.opts.debugging_opts.no_analysis ||\n-           sess.opts.debugging_opts.ast_json {\n-            return sess.compile_status();\n-        }\n+                    result\n+                    // AST will be dropped *after* the `after_analysis` callback\n+                    // (needed by the RLS)\n+                })?;\n+            } else {\n+                // Drop AST after creating GlobalCtxt to free memory\n+                mem::drop(queries.expansion()?.take());\n+            }\n \n-        if sess.opts.debugging_opts.save_analysis {\n-            let expanded_crate = &compiler.expansion()?.peek().0;\n-            let crate_name = compiler.crate_name()?.peek().clone();\n-            compiler.global_ctxt()?.peek_mut().enter(|tcx| {\n-                let result = tcx.analysis(LOCAL_CRATE);\n-\n-                time(sess, \"save analysis\", || {\n-                    save::process_crate(\n-                        tcx,\n-                        &expanded_crate,\n-                        &crate_name,\n-                        &compiler.input(),\n-                        None,\n-                        DumpHandler::new(compiler.output_dir().as_ref().map(|p| &**p), &crate_name)\n-                    )\n-                });\n-\n-                result\n-                // AST will be dropped *after* the `after_analysis` callback\n-                // (needed by the RLS)\n-            })?;\n-        } else {\n-            // Drop AST after creating GlobalCtxt to free memory\n-            mem::drop(compiler.expansion()?.take());\n-        }\n+            queries.global_ctxt()?.peek_mut().enter(|tcx| tcx.analysis(LOCAL_CRATE))?;\n \n-        compiler.global_ctxt()?.peek_mut().enter(|tcx| tcx.analysis(LOCAL_CRATE))?;\n+            if callbacks.after_analysis(compiler) == Compilation::Stop {\n+                return sess.compile_status();\n+            }\n \n-        if callbacks.after_analysis(compiler) == Compilation::Stop {\n-            return sess.compile_status();\n-        }\n+            if sess.opts.debugging_opts.save_analysis {\n+                mem::drop(queries.expansion()?.take());\n+            }\n \n-        if sess.opts.debugging_opts.save_analysis {\n-            mem::drop(compiler.expansion()?.take());\n-        }\n+            queries.ongoing_codegen()?;\n \n-        compiler.ongoing_codegen()?;\n+            // Drop GlobalCtxt after starting codegen to free memory\n+            mem::drop(queries.global_ctxt()?.take());\n \n-        // Drop GlobalCtxt after starting codegen to free memory\n-        mem::drop(compiler.global_ctxt()?.take());\n+            if sess.opts.debugging_opts.print_type_sizes {\n+                sess.code_stats.print_type_sizes();\n+            }\n \n-        if sess.opts.debugging_opts.print_type_sizes {\n-            sess.code_stats.print_type_sizes();\n-        }\n+            queries.link()?;\n \n-        compiler.link()?;\n+            Ok(())\n+        })?;\n \n         if sess.opts.debugging_opts.perf_stats {\n             sess.print_perf_stats();"}, {"sha": "beb2465bd4a1a2ac5182667b2c8bdd9520f39dde", "filename": "src/librustc_interface/interface.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/266ede1bb34195663238d23373bcc56f1f731748/src%2Flibrustc_interface%2Finterface.rs", "raw_url": "https://github.com/rust-lang/rust/raw/266ede1bb34195663238d23373bcc56f1f731748/src%2Flibrustc_interface%2Finterface.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_interface%2Finterface.rs?ref=266ede1bb34195663238d23373bcc56f1f731748", "patch": "@@ -1,4 +1,3 @@\n-use crate::queries::Queries;\n use crate::util;\n pub use crate::passes::BoxedResolver;\n \n@@ -36,7 +35,6 @@ pub struct Compiler {\n     pub(crate) input_path: Option<PathBuf>,\n     pub(crate) output_dir: Option<PathBuf>,\n     pub(crate) output_file: Option<PathBuf>,\n-    pub(crate) queries: Queries,\n     pub(crate) crate_name: Option<String>,\n     pub(crate) register_lints: Option<Box<dyn Fn(&Session, &mut lint::LintStore) + Send + Sync>>,\n     pub(crate) override_queries:\n@@ -169,7 +167,6 @@ pub fn run_compiler_in_existing_thread_pool<R>(\n         input_path: config.input_path,\n         output_dir: config.output_dir,\n         output_file: config.output_file,\n-        queries: Default::default(),\n         crate_name: config.crate_name,\n         register_lints: config.register_lints,\n         override_queries: config.override_queries,"}, {"sha": "85bdd341f52727052faa989d361f2d95970c070e", "filename": "src/librustc_interface/queries.rs", "status": "modified", "additions": 76, "deletions": 41, "changes": 117, "blob_url": "https://github.com/rust-lang/rust/blob/266ede1bb34195663238d23373bcc56f1f731748/src%2Flibrustc_interface%2Fqueries.rs", "raw_url": "https://github.com/rust-lang/rust/raw/266ede1bb34195663238d23373bcc56f1f731748/src%2Flibrustc_interface%2Fqueries.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_interface%2Fqueries.rs?ref=266ede1bb34195663238d23373bcc56f1f731748", "patch": "@@ -3,6 +3,7 @@ use crate::passes::{self, BoxedResolver, BoxedGlobalCtxt};\n \n use rustc_incremental::DepGraphFuture;\n use rustc_data_structures::sync::Lrc;\n+use rustc_codegen_utils::codegen_backend::CodegenBackend;\n use rustc::session::config::{OutputFilenames, OutputType};\n use rustc::util::common::{time, ErrorReported};\n use rustc::hir;\n@@ -44,13 +45,6 @@ impl<T> Query<T> {\n             .unwrap()\n     }\n \n-    /// Returns a stolen query result. Panics if there's already a result.\n-    pub fn give(&self, value: T) {\n-        let mut result = self.result.borrow_mut();\n-        assert!(result.is_none(), \"a result already exists\");\n-        *result = Some(Ok(value));\n-    }\n-\n     /// Borrows the query result using the RefCell. Panics if the result is stolen.\n     pub fn peek(&self) -> Ref<'_, T> {\n         Ref::map(self.result.borrow(), |r| {\n@@ -74,8 +68,9 @@ impl<T> Default for Query<T> {\n     }\n }\n \n-#[derive(Default)]\n-pub(crate) struct Queries {\n+pub struct Queries<'comp> {\n+    compiler: &'comp Compiler,\n+\n     dep_graph_future: Query<Option<DepGraphFuture>>,\n     parse: Query<ast::Crate>,\n     crate_name: Query<String>,\n@@ -89,9 +84,33 @@ pub(crate) struct Queries {\n     link: Query<()>,\n }\n \n-impl Compiler {\n+impl<'comp> Queries<'comp> {\n+    pub fn new(compiler: &'comp Compiler) -> Queries<'comp> {\n+        Queries {\n+            compiler,\n+            dep_graph_future: Default::default(),\n+            parse: Default::default(),\n+            crate_name: Default::default(),\n+            register_plugins: Default::default(),\n+            expansion: Default::default(),\n+            dep_graph: Default::default(),\n+            lower_to_hir: Default::default(),\n+            prepare_outputs: Default::default(),\n+            global_ctxt: Default::default(),\n+            ongoing_codegen: Default::default(),\n+            link: Default::default(),\n+        }\n+    }\n+\n+    fn session(&self) -> &Lrc<Session> {\n+        &self.compiler.sess\n+    }\n+    fn codegen_backend(&self) -> &Lrc<Box<dyn CodegenBackend>> {\n+        &self.compiler.codegen_backend()\n+    }\n+\n     pub fn dep_graph_future(&self) -> Result<&Query<Option<DepGraphFuture>>> {\n-        self.queries.dep_graph_future.compute(|| {\n+        self.dep_graph_future.compute(|| {\n             Ok(if self.session().opts.build_dep_graph() {\n                 Some(rustc_incremental::load_dep_graph(self.session()))\n             } else {\n@@ -101,8 +120,8 @@ impl Compiler {\n     }\n \n     pub fn parse(&self) -> Result<&Query<ast::Crate>> {\n-        self.queries.parse.compute(|| {\n-            passes::parse(self.session(), &self.input).map_err(\n+        self.parse.compute(|| {\n+            passes::parse(self.session(), &self.compiler.input).map_err(\n                 |mut parse_error| {\n                     parse_error.emit();\n                     ErrorReported\n@@ -112,15 +131,15 @@ impl Compiler {\n     }\n \n     pub fn register_plugins(&self) -> Result<&Query<(ast::Crate, Lrc<LintStore>)>> {\n-        self.queries.register_plugins.compute(|| {\n+        self.register_plugins.compute(|| {\n             let crate_name = self.crate_name()?.peek().clone();\n             let krate = self.parse()?.take();\n \n             let empty: &(dyn Fn(&Session, &mut lint::LintStore) + Sync + Send) = &|_, _| {};\n             let result = passes::register_plugins(\n                 self.session(),\n                 &*self.codegen_backend().metadata_loader(),\n-                self.register_lints\n+                self.compiler.register_lints\n                     .as_ref()\n                     .map(|p| &**p)\n                     .unwrap_or_else(|| empty),\n@@ -140,16 +159,16 @@ impl Compiler {\n     }\n \n     pub fn crate_name(&self) -> Result<&Query<String>> {\n-        self.queries.crate_name.compute(|| {\n-            Ok(match self.crate_name {\n+        self.crate_name.compute(|| {\n+            Ok(match self.compiler.crate_name {\n                 Some(ref crate_name) => crate_name.clone(),\n                 None => {\n                     let parse_result = self.parse()?;\n                     let krate = parse_result.peek();\n                     rustc_codegen_utils::link::find_crate_name(\n                         Some(self.session()),\n                         &krate.attrs,\n-                        &self.input\n+                        &self.compiler.input\n                     )\n                 }\n             })\n@@ -159,11 +178,11 @@ impl Compiler {\n     pub fn expansion(\n         &self\n     ) -> Result<&Query<(ast::Crate, Steal<Rc<RefCell<BoxedResolver>>>, Lrc<LintStore>)>> {\n-        self.queries.expansion.compute(|| {\n+        self.expansion.compute(|| {\n             let crate_name = self.crate_name()?.peek().clone();\n             let (krate, lint_store) = self.register_plugins()?.take();\n             passes::configure_and_expand(\n-                self.sess.clone(),\n+                self.session().clone(),\n                 lint_store.clone(),\n                 self.codegen_backend().metadata_loader(),\n                 krate,\n@@ -175,7 +194,7 @@ impl Compiler {\n     }\n \n     pub fn dep_graph(&self) -> Result<&Query<DepGraph>> {\n-        self.queries.dep_graph.compute(|| {\n+        self.dep_graph.compute(|| {\n             Ok(match self.dep_graph_future()?.take() {\n                 None => DepGraph::new_disabled(),\n                 Some(future) => {\n@@ -194,7 +213,7 @@ impl Compiler {\n     pub fn lower_to_hir(\n         &self,\n     ) -> Result<&Query<(Steal<hir::map::Forest>, Steal<ResolverOutputs>)>> {\n-        self.queries.lower_to_hir.compute(|| {\n+        self.lower_to_hir.compute(|| {\n             let expansion_result = self.expansion()?;\n             let peeked = expansion_result.peek();\n             let krate = &peeked.0;\n@@ -214,25 +233,25 @@ impl Compiler {\n     }\n \n     pub fn prepare_outputs(&self) -> Result<&Query<OutputFilenames>> {\n-        self.queries.prepare_outputs.compute(|| {\n+        self.prepare_outputs.compute(|| {\n             let expansion_result = self.expansion()?;\n             let (krate, boxed_resolver, _) = &*expansion_result.peek();\n             let crate_name = self.crate_name()?;\n             let crate_name = crate_name.peek();\n-            passes::prepare_outputs(self.session(), self, &krate, &boxed_resolver, &crate_name)\n+            passes::prepare_outputs(self.session(), self.compiler, &krate, &boxed_resolver, &crate_name)\n         })\n     }\n \n     pub fn global_ctxt(&self) -> Result<&Query<BoxedGlobalCtxt>> {\n-        self.queries.global_ctxt.compute(|| {\n+        self.global_ctxt.compute(|| {\n             let crate_name = self.crate_name()?.peek().clone();\n             let outputs = self.prepare_outputs()?.peek().clone();\n             let lint_store = self.expansion()?.peek().2.clone();\n             let hir = self.lower_to_hir()?;\n             let hir = hir.peek();\n             let (hir_forest, resolver_outputs) = &*hir;\n             Ok(passes::create_global_ctxt(\n-                self,\n+                self.compiler,\n                 lint_store,\n                 hir_forest.steal(),\n                 resolver_outputs.steal(),\n@@ -242,7 +261,7 @@ impl Compiler {\n     }\n \n     pub fn ongoing_codegen(&self) -> Result<&Query<Box<dyn Any>>> {\n-        self.queries.ongoing_codegen.compute(|| {\n+        self.ongoing_codegen.compute(|| {\n             let outputs = self.prepare_outputs()?;\n             self.global_ctxt()?.peek_mut().enter(|tcx| {\n                 tcx.analysis(LOCAL_CRATE).ok();\n@@ -260,7 +279,7 @@ impl Compiler {\n     }\n \n     pub fn link(&self) -> Result<&Query<()>> {\n-        self.queries.link.compute(|| {\n+        self.link.compute(|| {\n             let sess = self.session();\n \n             let ongoing_codegen = self.ongoing_codegen()?.take();\n@@ -275,31 +294,47 @@ impl Compiler {\n             Ok(())\n         })\n     }\n+}\n+\n+impl Compiler {\n+    // This method is different to all the other methods in `Compiler` because\n+    // it lacks a `Queries` entry. It's also not currently used. It does serve\n+    // as an example of how `Compiler` can be used, with additional steps added\n+    // between some passes. And see `rustc_driver::run_compiler` for a more\n+    // complex example.\n+    pub fn enter<'c, F, T>(&'c self, f: F) -> Result<T>\n+        where F: for<'q> FnOnce(&'q Queries<'c>) -> Result<T>\n+    {\n+        let queries = Queries::new(&self);\n+        f(&queries)\n+    }\n \n     // This method is different to all the other methods in `Compiler` because\n     // it lacks a `Queries` entry. It's also not currently used. It does serve\n     // as an example of how `Compiler` can be used, with additional steps added\n     // between some passes. And see `rustc_driver::run_compiler` for a more\n     // complex example.\n     pub fn compile(&self) -> Result<()> {\n-        self.prepare_outputs()?;\n+        self.enter(|queries| {\n+            queries.prepare_outputs()?;\n \n-        if self.session().opts.output_types.contains_key(&OutputType::DepInfo)\n-            && self.session().opts.output_types.len() == 1\n-        {\n-            return Ok(())\n-        }\n+            if self.session().opts.output_types.contains_key(&OutputType::DepInfo)\n+                && self.session().opts.output_types.len() == 1\n+            {\n+                return Ok(())\n+            }\n \n-        self.global_ctxt()?;\n+            queries.global_ctxt()?;\n \n-        // Drop AST after creating GlobalCtxt to free memory.\n-        mem::drop(self.expansion()?.take());\n+            // Drop AST after creating GlobalCtxt to free memory.\n+            mem::drop(queries.expansion()?.take());\n \n-        self.ongoing_codegen()?;\n+            queries.ongoing_codegen()?;\n \n-        // Drop GlobalCtxt after starting codegen to free memory.\n-        mem::drop(self.global_ctxt()?.take());\n+            // Drop GlobalCtxt after starting codegen to free memory.\n+            mem::drop(queries.global_ctxt()?.take());\n \n-        self.link().map(|_| ())\n+            queries.link().map(|_| ())\n+        })\n     }\n }"}, {"sha": "15904814ac46d3205b653f952fc4e893ddf78303", "filename": "src/librustdoc/core.rs", "status": "modified", "additions": 29, "deletions": 25, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/266ede1bb34195663238d23373bcc56f1f731748/src%2Flibrustdoc%2Fcore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/266ede1bb34195663238d23373bcc56f1f731748/src%2Flibrustdoc%2Fcore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fcore.rs?ref=266ede1bb34195663238d23373bcc56f1f731748", "patch": "@@ -346,34 +346,38 @@ pub fn run_core(options: RustdocOptions) -> (clean::Crate, RenderInfo, RenderOpt\n     interface::run_compiler_in_existing_thread_pool(config, |compiler| {\n         let sess = compiler.session();\n \n-        // We need to hold on to the complete resolver, so we cause everything to be\n-        // cloned for the analysis passes to use. Suboptimal, but necessary in the\n-        // current architecture.\n-        let resolver = {\n-            let parts = abort_on_err(compiler.expansion(), sess).peek();\n-            let resolver = parts.1.borrow();\n-\n-            // Before we actually clone it, let's force all the extern'd crates to\n-            // actually be loaded, just in case they're only referred to inside\n-            // intra-doc-links\n-            resolver.borrow_mut().access(|resolver| {\n-                for extern_name in &extern_names {\n-                    resolver.resolve_str_path_error(DUMMY_SP, extern_name, TypeNS, CRATE_NODE_ID)\n-                        .unwrap_or_else(\n-                            |()| panic!(\"Unable to resolve external crate {}\", extern_name)\n-                        );\n-                }\n-            });\n+        let (resolver, mut global_ctxt) = compiler.enter(|queries| {\n+            // We need to hold on to the complete resolver, so we cause everything to be\n+            // cloned for the analysis passes to use. Suboptimal, but necessary in the\n+            // current architecture.\n+            let resolver = {\n+                let parts = abort_on_err(queries.expansion(), sess).peek();\n+                let resolver = parts.1.borrow();\n+\n+                // Before we actually clone it, let's force all the extern'd crates to\n+                // actually be loaded, just in case they're only referred to inside\n+                // intra-doc-links\n+                resolver.borrow_mut().access(|resolver| {\n+                    for extern_name in &extern_names {\n+                        resolver.resolve_str_path_error(DUMMY_SP, extern_name, TypeNS, CRATE_NODE_ID)\n+                            .unwrap_or_else(\n+                                |()| panic!(\"Unable to resolve external crate {}\", extern_name)\n+                            );\n+                    }\n+                });\n \n-            // Now we're good to clone the resolver because everything should be loaded\n-            resolver.clone()\n-        };\n+                // Now we're good to clone the resolver because everything should be loaded\n+                resolver.clone()\n+            };\n \n-        if sess.has_errors() {\n-            sess.fatal(\"Compilation failed, aborting rustdoc\");\n-        }\n+            if sess.has_errors() {\n+                sess.fatal(\"Compilation failed, aborting rustdoc\");\n+            }\n+\n+            let global_ctxt = abort_on_err(queries.global_ctxt(), sess).take();\n \n-        let mut global_ctxt = abort_on_err(compiler.global_ctxt(), sess).take();\n+            Ok((resolver, global_ctxt))\n+        }).unwrap();\n \n         global_ctxt.enter(|tcx| {\n             tcx.analysis(LOCAL_CRATE).ok();"}, {"sha": "eca542ea6a37cd4b97f09cd0144632387883c7d0", "filename": "src/librustdoc/test.rs", "status": "modified", "additions": 19, "deletions": 16, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/266ede1bb34195663238d23373bcc56f1f731748/src%2Flibrustdoc%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/266ede1bb34195663238d23373bcc56f1f731748/src%2Flibrustdoc%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Ftest.rs?ref=266ede1bb34195663238d23373bcc56f1f731748", "patch": "@@ -86,22 +86,25 @@ pub fn run(options: Options) -> i32 {\n     let display_warnings = options.display_warnings;\n \n     let tests = interface::run_compiler(config, |compiler| -> Result<_, ErrorReported> {\n-        let lower_to_hir = compiler.lower_to_hir()?;\n-\n-        let mut opts = scrape_test_config(lower_to_hir.peek().0.borrow().krate());\n-        opts.display_warnings |= options.display_warnings;\n-        let enable_per_target_ignores = options.enable_per_target_ignores;\n-        let mut collector = Collector::new(\n-            compiler.crate_name()?.peek().to_string(),\n-            options,\n-            false,\n-            opts,\n-            Some(compiler.source_map().clone()),\n-            None,\n-            enable_per_target_ignores,\n-        );\n-\n-        let mut global_ctxt = compiler.global_ctxt()?.take();\n+        let (mut collector, mut global_ctxt) = compiler.enter(|queries| {\n+            let lower_to_hir = queries.lower_to_hir()?;\n+\n+            let mut opts = scrape_test_config(lower_to_hir.peek().0.borrow().krate());\n+            opts.display_warnings |= options.display_warnings;\n+            let enable_per_target_ignores = options.enable_per_target_ignores;\n+            let collector = Collector::new(\n+                queries.crate_name()?.peek().to_string(),\n+                options,\n+                false,\n+                opts,\n+                Some(compiler.source_map().clone()),\n+                None,\n+                enable_per_target_ignores,\n+            );\n+\n+            let global_ctxt = queries.global_ctxt()?.take();\n+            Ok((collector, global_ctxt))\n+        })?;\n         global_ctxt.enter(|tcx| {\n             let krate = tcx.hir().krate();\n             let mut hir_collector = HirCollector {"}]}