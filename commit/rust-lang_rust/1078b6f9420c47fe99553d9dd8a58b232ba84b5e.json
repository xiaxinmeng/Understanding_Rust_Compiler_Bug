{"sha": "1078b6f9420c47fe99553d9dd8a58b232ba84b5e", "node_id": "MDY6Q29tbWl0NzI0NzEyOjEwNzhiNmY5NDIwYzQ3ZmU5OTU1M2Q5ZGQ4YTU4YjIzMmJhODRiNWU=", "commit": {"author": {"name": "Josh Triplett", "email": "josh@joshtriplett.org", "date": "2020-06-15T06:33:55Z"}, "committer": {"name": "Josh Triplett", "email": "josh@joshtriplett.org", "date": "2020-06-15T19:35:27Z"}, "message": "asm: Allow multiple template strings; interpret them as newline-separated\n\nAllow the `asm!` macro to accept a series of template arguments, and\ninterpret them as if they were concatenated with a '\\n' between them.\nThis allows writing an `asm!` where each line of assembly appears in a\nseparate template string argument.\n\nThis syntax makes it possible for rustfmt to reliably format and indent\neach line of assembly, without risking changes to the inside of a\ntemplate string. It also avoids the complexity of having the user\ncarefully format and indent a multi-line string (including where to put\nthe surrounding quotes), and avoids the extra indentation and lines of a\ncall to `concat!`.\n\nFor example, rewriting the second example from the [blog post on the new\ninline assembly\nsyntax](https://blog.rust-lang.org/inside-rust/2020/06/08/new-inline-asm.html)\nusing multiple template strings:\n\n```rust\n\nfn main() {\n    let mut bits = [0u8; 64];\n    for value in 0..=1024u64 {\n        let popcnt;\n        unsafe {\n            asm!(\n                \"    popcnt {popcnt}, {v}\",\n                \"2:\",\n                \"    blsi rax, {v}\",\n                \"    jz 1f\",\n                \"    xor {v}, rax\",\n                \"    tzcnt rax, rax\",\n                \"    stosb\",\n                \"    jmp 2b\",\n                \"1:\",\n                v = inout(reg) value => _,\n                popcnt = out(reg) popcnt,\n                out(\"rax\") _, // scratch\n                inout(\"rdi\") bits.as_mut_ptr() => _,\n            );\n        }\n        println!(\"bits of {}: {:?}\", value, &bits[0..popcnt]);\n    }\n}\n```\n\nNote that all the template strings must appear before all other\narguments; you cannot, for instance, provide a series of template\nstrings intermixed with the corresponding operands.\n\nIn order to get srcloc mappings right for macros that generate\nmulti-line string literals, create one line_span for each\nline in the string literal, each pointing to the macro.\n\nMake `rustc_parse_format::Parser::curarg` `pub`, so that we can\npropagate it from one template string argument to the next.", "tree": {"sha": "b75a13fd2b953f6bff15c98973a44ab256261be1", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b75a13fd2b953f6bff15c98973a44ab256261be1"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1078b6f9420c47fe99553d9dd8a58b232ba84b5e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1078b6f9420c47fe99553d9dd8a58b232ba84b5e", "html_url": "https://github.com/rust-lang/rust/commit/1078b6f9420c47fe99553d9dd8a58b232ba84b5e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1078b6f9420c47fe99553d9dd8a58b232ba84b5e/comments", "author": {"login": "joshtriplett", "id": 162737, "node_id": "MDQ6VXNlcjE2MjczNw==", "avatar_url": "https://avatars.githubusercontent.com/u/162737?v=4", "gravatar_id": "", "url": "https://api.github.com/users/joshtriplett", "html_url": "https://github.com/joshtriplett", "followers_url": "https://api.github.com/users/joshtriplett/followers", "following_url": "https://api.github.com/users/joshtriplett/following{/other_user}", "gists_url": "https://api.github.com/users/joshtriplett/gists{/gist_id}", "starred_url": "https://api.github.com/users/joshtriplett/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/joshtriplett/subscriptions", "organizations_url": "https://api.github.com/users/joshtriplett/orgs", "repos_url": "https://api.github.com/users/joshtriplett/repos", "events_url": "https://api.github.com/users/joshtriplett/events{/privacy}", "received_events_url": "https://api.github.com/users/joshtriplett/received_events", "type": "User", "site_admin": false}, "committer": {"login": "joshtriplett", "id": 162737, "node_id": "MDQ6VXNlcjE2MjczNw==", "avatar_url": "https://avatars.githubusercontent.com/u/162737?v=4", "gravatar_id": "", "url": "https://api.github.com/users/joshtriplett", "html_url": "https://github.com/joshtriplett", "followers_url": "https://api.github.com/users/joshtriplett/followers", "following_url": "https://api.github.com/users/joshtriplett/following{/other_user}", "gists_url": "https://api.github.com/users/joshtriplett/gists{/gist_id}", "starred_url": "https://api.github.com/users/joshtriplett/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/joshtriplett/subscriptions", "organizations_url": "https://api.github.com/users/joshtriplett/orgs", "repos_url": "https://api.github.com/users/joshtriplett/repos", "events_url": "https://api.github.com/users/joshtriplett/events{/privacy}", "received_events_url": "https://api.github.com/users/joshtriplett/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "50d6d4de67d76f03f8a8b209881a924f2d69922f", "url": "https://api.github.com/repos/rust-lang/rust/commits/50d6d4de67d76f03f8a8b209881a924f2d69922f", "html_url": "https://github.com/rust-lang/rust/commit/50d6d4de67d76f03f8a8b209881a924f2d69922f"}], "stats": {"total": 684, "additions": 530, "deletions": 154}, "files": [{"sha": "29885679604647db049912609842e20d07d7de52", "filename": "src/librustc_builtin_macros/asm.rs", "status": "modified", "additions": 182, "deletions": 145, "changes": 327, "blob_url": "https://github.com/rust-lang/rust/blob/1078b6f9420c47fe99553d9dd8a58b232ba84b5e/src%2Flibrustc_builtin_macros%2Fasm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1078b6f9420c47fe99553d9dd8a58b232ba84b5e/src%2Flibrustc_builtin_macros%2Fasm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_builtin_macros%2Fasm.rs?ref=1078b6f9420c47fe99553d9dd8a58b232ba84b5e", "patch": "@@ -11,7 +11,7 @@ use rustc_span::symbol::{kw, sym, Symbol};\n use rustc_span::{InnerSpan, Span};\n \n struct AsmArgs {\n-    template: P<ast::Expr>,\n+    templates: Vec<P<ast::Expr>>,\n     operands: Vec<(ast::InlineAsmOperand, Span)>,\n     named_args: FxHashMap<Symbol, usize>,\n     reg_args: FxHashSet<usize>,\n@@ -52,21 +52,21 @@ fn parse_args<'a>(\n         return Err(err);\n     }\n \n-    let template = p.parse_expr()?;\n+    let first_template = p.parse_expr()?;\n     let mut args = AsmArgs {\n-        template,\n+        templates: vec![first_template],\n         operands: vec![],\n         named_args: FxHashMap::default(),\n         reg_args: FxHashSet::default(),\n         options: ast::InlineAsmOptions::empty(),\n         options_span: None,\n     };\n \n-    let mut first = true;\n+    let mut allow_templates = true;\n     while p.token != token::Eof {\n         if !p.eat(&token::Comma) {\n-            if first {\n-                // After `asm!(\"\"` we always expect *only* a comma...\n+            if allow_templates {\n+                // After a template string, we always expect *only* a comma...\n                 let mut err = ecx.struct_span_err(p.token.span, \"expected token: `,`\");\n                 err.span_label(p.token.span, \"expected `,`\");\n                 p.maybe_annotate_with_ascription(&mut err, false);\n@@ -76,14 +76,14 @@ fn parse_args<'a>(\n                 return Err(p.expect(&token::Comma).err().unwrap());\n             }\n         }\n-        first = false;\n         if p.token == token::Eof {\n             break;\n         } // accept trailing commas\n \n         // Parse options\n         if p.eat(&token::Ident(sym::options, false)) {\n             parse_options(&mut p, &mut args)?;\n+            allow_templates = false;\n             continue;\n         }\n \n@@ -94,6 +94,7 @@ fn parse_args<'a>(\n             let (ident, _) = p.token.ident().unwrap();\n             p.bump();\n             p.expect(&token::Eq)?;\n+            allow_templates = false;\n             Some(ident.name)\n         } else {\n             None\n@@ -146,10 +147,27 @@ fn parse_args<'a>(\n                 }\n             }\n             ast::InlineAsmOperand::Sym { expr }\n+        } else if allow_templates {\n+            let template = p.parse_expr()?;\n+            // If it can't possibly expand to a string, provide diagnostics here to include other\n+            // things it could have been.\n+            match template.kind {\n+                ast::ExprKind::Lit(ast::Lit { kind: ast::LitKind::Str(..), .. }) => {}\n+                ast::ExprKind::MacCall(..) => {}\n+                _ => {\n+                    let errstr = \"expected operand, options, or additional template string\";\n+                    let mut err = ecx.struct_span_err(template.span, errstr);\n+                    err.span_label(template.span, errstr);\n+                    return Err(err);\n+                }\n+            }\n+            args.templates.push(template);\n+            continue;\n         } else {\n             return Err(p.expect_one_of(&[], &[]).unwrap_err());\n         };\n \n+        allow_templates = false;\n         let span = span_start.to(p.prev_token.span);\n         let slot = args.operands.len();\n         args.operands.push((op, span));\n@@ -331,155 +349,180 @@ fn parse_reg<'a>(\n }\n \n fn expand_preparsed_asm(ecx: &mut ExtCtxt<'_>, sp: Span, args: AsmArgs) -> P<ast::Expr> {\n-    let msg = \"asm template must be a string literal\";\n-    let template_sp = args.template.span;\n-    let (template_str, template_style, template_span) =\n-        match expr_to_spanned_string(ecx, args.template, msg) {\n-            Ok(template) => template,\n-            Err(err) => {\n-                if let Some(mut err) = err {\n-                    err.emit();\n-                }\n-                return DummyResult::raw_expr(sp, true);\n-            }\n-        };\n-\n-    let str_style = match template_style {\n-        ast::StrStyle::Cooked => None,\n-        ast::StrStyle::Raw(raw) => Some(raw as usize),\n-    };\n-\n-    let template_str = &template_str.as_str();\n-    let template_snippet = ecx.source_map().span_to_snippet(template_sp).ok();\n-    let mut parser = parse::Parser::new(\n-        template_str,\n-        str_style,\n-        template_snippet,\n-        false,\n-        parse::ParseMode::InlineAsm,\n-    );\n-\n-    let mut unverified_pieces = Vec::new();\n-    while let Some(piece) = parser.next() {\n-        if !parser.errors.is_empty() {\n-            break;\n-        } else {\n-            unverified_pieces.push(piece);\n-        }\n-    }\n-\n-    if !parser.errors.is_empty() {\n-        let err = parser.errors.remove(0);\n-        let err_sp = template_span.from_inner(err.span);\n-        let mut e = ecx\n-            .struct_span_err(err_sp, &format!(\"invalid asm template string: {}\", err.description));\n-        e.span_label(err_sp, err.label + \" in asm template string\");\n-        if let Some(note) = err.note {\n-            e.note(&note);\n-        }\n-        if let Some((label, span)) = err.secondary_label {\n-            let err_sp = template_span.from_inner(span);\n-            e.span_label(err_sp, label);\n-        }\n-        e.emit();\n-        return DummyResult::raw_expr(sp, true);\n-    }\n-\n+    let mut template = vec![];\n     // Register operands are implicitly used since they are not allowed to be\n     // referenced in the template string.\n     let mut used = vec![false; args.operands.len()];\n     for pos in &args.reg_args {\n         used[*pos] = true;\n     }\n-\n     let named_pos: FxHashMap<usize, Symbol> =\n         args.named_args.iter().map(|(&sym, &idx)| (idx, sym)).collect();\n-    let mut arg_spans = parser.arg_places.iter().map(|span| template_span.from_inner(*span));\n-    let mut template = vec![];\n-    for piece in unverified_pieces {\n-        match piece {\n-            parse::Piece::String(s) => {\n-                template.push(ast::InlineAsmTemplatePiece::String(s.to_string()))\n+    let mut line_spans = Vec::with_capacity(args.templates.len());\n+    let mut curarg = 0;\n+\n+    for template_expr in args.templates.into_iter() {\n+        if !template.is_empty() {\n+            template.push(ast::InlineAsmTemplatePiece::String(\"\\n\".to_string()));\n+        }\n+\n+        let msg = \"asm template must be a string literal\";\n+        let template_sp = template_expr.span;\n+        let (template_str, template_style, template_span) =\n+            match expr_to_spanned_string(ecx, template_expr, msg) {\n+                Ok(template_part) => template_part,\n+                Err(err) => {\n+                    if let Some(mut err) = err {\n+                        err.emit();\n+                    }\n+                    return DummyResult::raw_expr(sp, true);\n+                }\n+            };\n+\n+        let str_style = match template_style {\n+            ast::StrStyle::Cooked => None,\n+            ast::StrStyle::Raw(raw) => Some(raw as usize),\n+        };\n+\n+        let template_str = &template_str.as_str();\n+        let template_snippet = ecx.source_map().span_to_snippet(template_sp).ok();\n+        let mut parser = parse::Parser::new(\n+            template_str,\n+            str_style,\n+            template_snippet,\n+            false,\n+            parse::ParseMode::InlineAsm,\n+        );\n+        parser.curarg = curarg;\n+\n+        let mut unverified_pieces = Vec::new();\n+        while let Some(piece) = parser.next() {\n+            if !parser.errors.is_empty() {\n+                break;\n+            } else {\n+                unverified_pieces.push(piece);\n+            }\n+        }\n+\n+        if !parser.errors.is_empty() {\n+            let err = parser.errors.remove(0);\n+            let err_sp = template_span.from_inner(err.span);\n+            let msg = &format!(\"invalid asm template string: {}\", err.description);\n+            let mut e = ecx.struct_span_err(err_sp, msg);\n+            e.span_label(err_sp, err.label + \" in asm template string\");\n+            if let Some(note) = err.note {\n+                e.note(&note);\n+            }\n+            if let Some((label, span)) = err.secondary_label {\n+                let err_sp = template_span.from_inner(span);\n+                e.span_label(err_sp, label);\n             }\n-            parse::Piece::NextArgument(arg) => {\n-                let span = arg_spans.next().unwrap_or(template_sp);\n-\n-                let operand_idx = match arg.position {\n-                    parse::ArgumentIs(idx) | parse::ArgumentImplicitlyIs(idx) => {\n-                        if idx >= args.operands.len()\n-                            || named_pos.contains_key(&idx)\n-                            || args.reg_args.contains(&idx)\n-                        {\n-                            let msg = format!(\"invalid reference to argument at index {}\", idx);\n-                            let mut err = ecx.struct_span_err(span, &msg);\n-                            err.span_label(span, \"from here\");\n-\n-                            let positional_args =\n-                                args.operands.len() - args.named_args.len() - args.reg_args.len();\n-                            let positional = if positional_args != args.operands.len() {\n-                                \"positional \"\n+            e.emit();\n+            return DummyResult::raw_expr(sp, true);\n+        }\n+\n+        curarg = parser.curarg;\n+\n+        let mut arg_spans = parser.arg_places.iter().map(|span| template_span.from_inner(*span));\n+        for piece in unverified_pieces {\n+            match piece {\n+                parse::Piece::String(s) => {\n+                    template.push(ast::InlineAsmTemplatePiece::String(s.to_string()))\n+                }\n+                parse::Piece::NextArgument(arg) => {\n+                    let span = arg_spans.next().unwrap_or(template_sp);\n+\n+                    let operand_idx = match arg.position {\n+                        parse::ArgumentIs(idx) | parse::ArgumentImplicitlyIs(idx) => {\n+                            if idx >= args.operands.len()\n+                                || named_pos.contains_key(&idx)\n+                                || args.reg_args.contains(&idx)\n+                            {\n+                                let msg = format!(\"invalid reference to argument at index {}\", idx);\n+                                let mut err = ecx.struct_span_err(span, &msg);\n+                                err.span_label(span, \"from here\");\n+\n+                                let positional_args = args.operands.len()\n+                                    - args.named_args.len()\n+                                    - args.reg_args.len();\n+                                let positional = if positional_args != args.operands.len() {\n+                                    \"positional \"\n+                                } else {\n+                                    \"\"\n+                                };\n+                                let msg = match positional_args {\n+                                    0 => format!(\"no {}arguments were given\", positional),\n+                                    1 => format!(\"there is 1 {}argument\", positional),\n+                                    x => format!(\"there are {} {}arguments\", x, positional),\n+                                };\n+                                err.note(&msg);\n+\n+                                if named_pos.contains_key(&idx) {\n+                                    err.span_label(args.operands[idx].1, \"named argument\");\n+                                    err.span_note(\n+                                        args.operands[idx].1,\n+                                        \"named arguments cannot be referenced by position\",\n+                                    );\n+                                } else if args.reg_args.contains(&idx) {\n+                                    err.span_label(\n+                                        args.operands[idx].1,\n+                                        \"explicit register argument\",\n+                                    );\n+                                    err.span_note(\n+                                        args.operands[idx].1,\n+                                        \"explicit register arguments cannot be used in the asm template\",\n+                                    );\n+                                }\n+                                err.emit();\n+                                None\n                             } else {\n-                                \"\"\n-                            };\n-                            let msg = match positional_args {\n-                                0 => format!(\"no {}arguments were given\", positional),\n-                                1 => format!(\"there is 1 {}argument\", positional),\n-                                x => format!(\"there are {} {}arguments\", x, positional),\n-                            };\n-                            err.note(&msg);\n-\n-                            if named_pos.contains_key(&idx) {\n-                                err.span_label(args.operands[idx].1, \"named argument\");\n-                                err.span_note(\n-                                    args.operands[idx].1,\n-                                    \"named arguments cannot be referenced by position\",\n-                                );\n-                            } else if args.reg_args.contains(&idx) {\n-                                err.span_label(args.operands[idx].1, \"explicit register argument\");\n-                                err.span_note(\n-                                    args.operands[idx].1,\n-                                    \"explicit register arguments cannot be used in the asm template\",\n-                                );\n+                                Some(idx)\n                             }\n-                            err.emit();\n-                            None\n-                        } else {\n-                            Some(idx)\n-                        }\n-                    }\n-                    parse::ArgumentNamed(name) => match args.named_args.get(&name) {\n-                        Some(&idx) => Some(idx),\n-                        None => {\n-                            let msg = format!(\"there is no argument named `{}`\", name);\n-                            ecx.struct_span_err(span, &msg[..]).emit();\n-                            None\n                         }\n-                    },\n-                };\n-\n-                let mut chars = arg.format.ty.chars();\n-                let mut modifier = chars.next();\n-                if chars.next().is_some() {\n-                    let span = arg\n-                        .format\n-                        .ty_span\n-                        .map(|sp| template_sp.from_inner(sp))\n-                        .unwrap_or(template_sp);\n-                    ecx.struct_span_err(span, \"asm template modifier must be a single character\")\n+                        parse::ArgumentNamed(name) => match args.named_args.get(&name) {\n+                            Some(&idx) => Some(idx),\n+                            None => {\n+                                let msg = format!(\"there is no argument named `{}`\", name);\n+                                ecx.struct_span_err(span, &msg[..]).emit();\n+                                None\n+                            }\n+                        },\n+                    };\n+\n+                    let mut chars = arg.format.ty.chars();\n+                    let mut modifier = chars.next();\n+                    if chars.next().is_some() {\n+                        let span = arg\n+                            .format\n+                            .ty_span\n+                            .map(|sp| template_sp.from_inner(sp))\n+                            .unwrap_or(template_sp);\n+                        ecx.struct_span_err(\n+                            span,\n+                            \"asm template modifier must be a single character\",\n+                        )\n                         .emit();\n-                    modifier = None;\n-                }\n+                        modifier = None;\n+                    }\n \n-                if let Some(operand_idx) = operand_idx {\n-                    used[operand_idx] = true;\n-                    template.push(ast::InlineAsmTemplatePiece::Placeholder {\n-                        operand_idx,\n-                        modifier,\n-                        span,\n-                    });\n+                    if let Some(operand_idx) = operand_idx {\n+                        used[operand_idx] = true;\n+                        template.push(ast::InlineAsmTemplatePiece::Placeholder {\n+                            operand_idx,\n+                            modifier,\n+                            span,\n+                        });\n+                    }\n                 }\n             }\n         }\n+\n+        if parser.line_spans.is_empty() {\n+            let template_num_lines = 1 + template_str.matches('\\n').count();\n+            line_spans.extend(std::iter::repeat(template_sp).take(template_num_lines));\n+        } else {\n+            line_spans.extend(parser.line_spans.iter().map(|span| template_span.from_inner(*span)));\n+        };\n     }\n \n     let mut unused_operands = vec![];\n@@ -526,12 +569,6 @@ fn expand_preparsed_asm(ecx: &mut ExtCtxt<'_>, sp: Span, args: AsmArgs) -> P<ast\n         }\n     }\n \n-    let line_spans = if parser.line_spans.is_empty() {\n-        vec![template_sp]\n-    } else {\n-        parser.line_spans.iter().map(|span| template_span.from_inner(*span)).collect()\n-    };\n-\n     let inline_asm =\n         ast::InlineAsm { template, operands: args.operands, options: args.options, line_spans };\n     P(ast::Expr {"}, {"sha": "a5b5a1090cbfd5052e0d6beb64b0b79581a87698", "filename": "src/librustc_parse_format/lib.rs", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/1078b6f9420c47fe99553d9dd8a58b232ba84b5e/src%2Flibrustc_parse_format%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1078b6f9420c47fe99553d9dd8a58b232ba84b5e/src%2Flibrustc_parse_format%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_parse_format%2Flib.rs?ref=1078b6f9420c47fe99553d9dd8a58b232ba84b5e", "patch": "@@ -178,7 +178,7 @@ pub struct Parser<'a> {\n     /// Error messages accumulated during parsing\n     pub errors: Vec<ParseError>,\n     /// Current position of implicit positional argument pointer\n-    curarg: usize,\n+    pub curarg: usize,\n     /// `Some(raw count)` when the string is \"raw\", used to position spans correctly\n     style: Option<usize>,\n     /// Start and end byte offset of every successfully parsed argument\n@@ -243,11 +243,13 @@ impl<'a> Iterator for Parser<'a> {\n                 _ => Some(String(self.string(pos))),\n             }\n         } else {\n-            if self.is_literal && self.cur_line_start != self.input.len() {\n+            if self.is_literal {\n                 let start = self.to_span_index(self.cur_line_start);\n                 let end = self.to_span_index(self.input.len());\n-                self.line_spans.push(start.to(end));\n-                self.cur_line_start = self.input.len();\n+                let span = start.to(end);\n+                if self.line_spans.last() != Some(&span) {\n+                    self.line_spans.push(span);\n+                }\n             }\n             None\n         }"}, {"sha": "b3d188dd708814cf50c3937d59eb7334ef73cb09", "filename": "src/test/pretty/asm.pp", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/1078b6f9420c47fe99553d9dd8a58b232ba84b5e/src%2Ftest%2Fpretty%2Fasm.pp", "raw_url": "https://github.com/rust-lang/rust/raw/1078b6f9420c47fe99553d9dd8a58b232ba84b5e/src%2Ftest%2Fpretty%2Fasm.pp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fpretty%2Fasm.pp?ref=1078b6f9420c47fe99553d9dd8a58b232ba84b5e", "patch": "@@ -22,5 +22,13 @@\n         asm!(\"{0}\", inout(reg) b);\n         asm!(\"{0} {1}\", out(reg) _, inlateout(reg) b => _);\n         asm!(\"\", out(\"al\") _, lateout(\"rbx\") _);\n+        asm!(\"inst1\\ninst2\");\n+        asm!(\"inst1 {0}, 42\\ninst2 {1}, 24\", in(reg) a, out(reg) b);\n+        asm!(\"inst2 {1}, 24\\ninst1 {0}, 42\", in(reg) a, out(reg) b);\n+        asm!(\"inst1 {0}, 42\\ninst2 {1}, 24\", in(reg) a, out(reg) b);\n+        asm!(\"inst1\\ninst2\");\n+        asm!(\"inst1\\ninst2\");\n+        asm!(\"inst1\\n\\tinst2\");\n+        asm!(\"inst1\\ninst2\\ninst3\\ninst4\");\n     }\n }"}, {"sha": "33f25e5216b4eafab08089c2f779fd22ba736544", "filename": "src/test/pretty/asm.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/1078b6f9420c47fe99553d9dd8a58b232ba84b5e/src%2Ftest%2Fpretty%2Fasm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1078b6f9420c47fe99553d9dd8a58b232ba84b5e/src%2Ftest%2Fpretty%2Fasm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fpretty%2Fasm.rs?ref=1078b6f9420c47fe99553d9dd8a58b232ba84b5e", "patch": "@@ -16,5 +16,14 @@ pub fn main() {\n         asm!(\"{name}\", name = inout(reg) b);\n         asm!(\"{} {}\", out(reg) _, inlateout(reg) b => _);\n         asm!(\"\", out(\"al\") _, lateout(\"rbx\") _);\n+        asm!(\"inst1\", \"inst2\");\n+        asm!(\"inst1 {}, 42\", \"inst2 {}, 24\", in(reg) a, out(reg) b);\n+        asm!(\"inst2 {1}, 24\", \"inst1 {0}, 42\", in(reg) a, out(reg) b);\n+        asm!(\"inst1 {}, 42\", \"inst2 {name}, 24\", in(reg) a, name = out(reg) b);\n+        asm!(\"inst1\n+inst2\");\n+        asm!(\"inst1\\ninst2\");\n+        asm!(\"inst1\\n\\tinst2\");\n+        asm!(\"inst1\\ninst2\", \"inst3\\ninst4\");\n     }\n }"}, {"sha": "fbf399d8b075c311b51cb36e3760789f7d604344", "filename": "src/test/ui/asm/parse-error.rs", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/1078b6f9420c47fe99553d9dd8a58b232ba84b5e/src%2Ftest%2Fui%2Fasm%2Fparse-error.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1078b6f9420c47fe99553d9dd8a58b232ba84b5e/src%2Ftest%2Fui%2Fasm%2Fparse-error.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasm%2Fparse-error.rs?ref=1078b6f9420c47fe99553d9dd8a58b232ba84b5e", "patch": "@@ -13,7 +13,7 @@ fn main() {\n         asm!(\"{}\" foo);\n         //~^ ERROR expected token: `,`\n         asm!(\"{}\", foo);\n-        //~^ ERROR expected one of\n+        //~^ ERROR expected operand, options, or additional template string\n         asm!(\"{}\", in foo);\n         //~^ ERROR expected `(`, found `foo`\n         asm!(\"{}\", in(reg foo));\n@@ -52,5 +52,13 @@ fn main() {\n         //~^ ERROR named arguments cannot follow explicit register arguments\n         asm!(\"{1}\", in(\"eax\") foo, const bar);\n         //~^ ERROR positional arguments cannot follow named arguments or explicit register arguments\n+        asm!(\"\", options(), \"\");\n+        //~^ ERROR expected one of\n+        asm!(\"{}\", in(reg) foo, \"{}\", out(reg) foo);\n+        //~^ ERROR expected one of\n+        asm!(format!(\"{{{}}}\", 0), in(reg) foo);\n+        //~^ ERROR asm template must be a string literal\n+        asm!(\"{1}\", format!(\"{{{}}}\", 0), in(reg) foo, out(reg) bar);\n+        //~^ ERROR asm template must be a string literal\n     }\n }"}, {"sha": "ba7e8f7a03ccad682165367ca555d91352895908", "filename": "src/test/ui/asm/parse-error.stderr", "status": "modified", "additions": 31, "deletions": 3, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/1078b6f9420c47fe99553d9dd8a58b232ba84b5e/src%2Ftest%2Fui%2Fasm%2Fparse-error.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/1078b6f9420c47fe99553d9dd8a58b232ba84b5e/src%2Ftest%2Fui%2Fasm%2Fparse-error.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasm%2Fparse-error.stderr?ref=1078b6f9420c47fe99553d9dd8a58b232ba84b5e", "patch": "@@ -16,11 +16,11 @@ error: expected token: `,`\n LL |         asm!(\"{}\" foo);\n    |                   ^^^ expected `,`\n \n-error: expected one of `const`, `in`, `inlateout`, `inout`, `lateout`, `options`, `out`, or `sym`, found `foo`\n+error: expected operand, options, or additional template string\n   --> $DIR/parse-error.rs:15:20\n    |\n LL |         asm!(\"{}\", foo);\n-   |                    ^^^ expected one of 8 possible tokens\n+   |                    ^^^ expected operand, options, or additional template string\n \n error: expected `(`, found `foo`\n   --> $DIR/parse-error.rs:17:23\n@@ -160,5 +160,33 @@ LL |         asm!(\"{1}\", in(\"eax\") foo, const bar);\n    |                     |\n    |                     explicit register argument\n \n-error: aborting due to 24 previous errors\n+error: expected one of `const`, `in`, `inlateout`, `inout`, `lateout`, `options`, `out`, or `sym`, found `\"\"`\n+  --> $DIR/parse-error.rs:55:29\n+   |\n+LL |         asm!(\"\", options(), \"\");\n+   |                             ^^ expected one of 8 possible tokens\n+\n+error: expected one of `const`, `in`, `inlateout`, `inout`, `lateout`, `options`, `out`, or `sym`, found `\"{}\"`\n+  --> $DIR/parse-error.rs:57:33\n+   |\n+LL |         asm!(\"{}\", in(reg) foo, \"{}\", out(reg) foo);\n+   |                                 ^^^^ expected one of 8 possible tokens\n+\n+error: asm template must be a string literal\n+  --> $DIR/parse-error.rs:59:14\n+   |\n+LL |         asm!(format!(\"{{{}}}\", 0), in(reg) foo);\n+   |              ^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: this error originates in a macro (in Nightly builds, run with -Z macro-backtrace for more info)\n+\n+error: asm template must be a string literal\n+  --> $DIR/parse-error.rs:61:21\n+   |\n+LL |         asm!(\"{1}\", format!(\"{{{}}}\", 0), in(reg) foo, out(reg) bar);\n+   |                     ^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: this error originates in a macro (in Nightly builds, run with -Z macro-backtrace for more info)\n+\n+error: aborting due to 28 previous errors\n "}, {"sha": "1477e3dd5665ce6230819888ed21c50c8c4824da", "filename": "src/test/ui/asm/srcloc.rs", "status": "modified", "additions": 80, "deletions": 0, "changes": 80, "blob_url": "https://github.com/rust-lang/rust/blob/1078b6f9420c47fe99553d9dd8a58b232ba84b5e/src%2Ftest%2Fui%2Fasm%2Fsrcloc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1078b6f9420c47fe99553d9dd8a58b232ba84b5e/src%2Ftest%2Fui%2Fasm%2Fsrcloc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasm%2Fsrcloc.rs?ref=1078b6f9420c47fe99553d9dd8a58b232ba84b5e", "patch": "@@ -40,5 +40,85 @@ fn main() {\n \n         asm!(\"movaps %xmm3, (%esi, 2)\", options(att_syntax));\n         //~^ WARN: scale factor without index register is ignored\n+\n+        asm!(\n+            \"invalid_instruction\",\n+        );\n+        //~^^ ERROR: invalid instruction mnemonic 'invalid_instruction'\n+\n+        asm!(\n+            \"mov eax, eax\",\n+            \"invalid_instruction\",\n+            \"mov eax, eax\",\n+        );\n+        //~^^^ ERROR: invalid instruction mnemonic 'invalid_instruction'\n+\n+        asm!(\n+            \"mov eax, eax\\n\",\n+            \"invalid_instruction\",\n+            \"mov eax, eax\",\n+        );\n+        //~^^^ ERROR: invalid instruction mnemonic 'invalid_instruction'\n+\n+        asm!(\n+            \"mov eax, eax\",\n+            concat!(\"invalid\", \"_\", \"instruction\"),\n+            \"mov eax, eax\",\n+        );\n+        //~^^^ ERROR: invalid instruction mnemonic 'invalid_instruction'\n+\n+        asm!(\n+            concat!(\"mov eax\", \", \", \"eax\"),\n+            concat!(\"invalid\", \"_\", \"instruction\"),\n+            concat!(\"mov eax\", \", \", \"eax\"),\n+        );\n+        //~^^^ ERROR: invalid instruction mnemonic 'invalid_instruction'\n+\n+        // Make sure template strings get separated\n+        asm!(\n+            \"invalid_instruction1\",\n+            \"invalid_instruction2\",\n+        );\n+        //~^^^ ERROR: invalid instruction mnemonic 'invalid_instruction1'\n+        //~^^^ ERROR: invalid instruction mnemonic 'invalid_instruction2'\n+\n+        asm!(\n+            concat!(\n+                \"invalid\", \"_\", \"instruction1\", \"\\n\",\n+                \"invalid\", \"_\", \"instruction2\",\n+            ),\n+        );\n+        //~^^^^^ ERROR: invalid instruction mnemonic 'invalid_instruction1'\n+        //~^^^^^^ ERROR: invalid instruction mnemonic 'invalid_instruction2'\n+\n+        asm!(\n+            concat!(\n+                \"invalid\", \"_\", \"instruction1\", \"\\n\",\n+                \"invalid\", \"_\", \"instruction2\",\n+            ),\n+            concat!(\n+                \"invalid\", \"_\", \"instruction3\", \"\\n\",\n+                \"invalid\", \"_\", \"instruction4\",\n+            ),\n+        );\n+        //~^^^^^^^^^ ERROR: invalid instruction mnemonic 'invalid_instruction1'\n+        //~^^^^^^^^^^ ERROR: invalid instruction mnemonic 'invalid_instruction2'\n+        //~^^^^^^^ ERROR: invalid instruction mnemonic 'invalid_instruction3'\n+        //~^^^^^^^^ ERROR: invalid instruction mnemonic 'invalid_instruction4'\n+\n+        asm!(\n+            concat!(\n+                \"invalid\", \"_\", \"instruction1\", \"\\n\",\n+                \"invalid\", \"_\", \"instruction2\", \"\\n\",\n+            ),\n+            concat!(\n+                \"invalid\", \"_\", \"instruction3\", \"\\n\",\n+                \"invalid\", \"_\", \"instruction4\", \"\\n\",\n+            ),\n+        );\n+        //~^^^^^^^^^ ERROR: invalid instruction mnemonic 'invalid_instruction1'\n+        //~^^^^^^^^^^ ERROR: invalid instruction mnemonic 'invalid_instruction2'\n+        //~^^^^^^^ ERROR: invalid instruction mnemonic 'invalid_instruction3'\n+        //~^^^^^^^^ ERROR: invalid instruction mnemonic 'invalid_instruction4'\n     }\n }"}, {"sha": "b62c8948289ddf1bf55575457bdc2e178c99d50c", "filename": "src/test/ui/asm/srcloc.stderr", "status": "modified", "additions": 205, "deletions": 1, "changes": 206, "blob_url": "https://github.com/rust-lang/rust/blob/1078b6f9420c47fe99553d9dd8a58b232ba84b5e/src%2Ftest%2Fui%2Fasm%2Fsrcloc.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/1078b6f9420c47fe99553d9dd8a58b232ba84b5e/src%2Ftest%2Fui%2Fasm%2Fsrcloc.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasm%2Fsrcloc.stderr?ref=1078b6f9420c47fe99553d9dd8a58b232ba84b5e", "patch": "@@ -82,5 +82,209 @@ note: instantiated into assembly here\n LL |     movaps %xmm3, (%esi, 2)\n    |                          ^\n \n-error: aborting due to 6 previous errors; 1 warning emitted\n+error: invalid instruction mnemonic 'invalid_instruction'\n+  --> $DIR/srcloc.rs:45:14\n+   |\n+LL |             \"invalid_instruction\",\n+   |              ^\n+   |\n+note: instantiated into assembly here\n+  --> <inline asm>:2:2\n+   |\n+LL |     invalid_instruction\n+   |     ^^^^^^^^^^^^^^^^^^^\n+\n+error: invalid instruction mnemonic 'invalid_instruction'\n+  --> $DIR/srcloc.rs:51:14\n+   |\n+LL |             \"invalid_instruction\",\n+   |              ^\n+   |\n+note: instantiated into assembly here\n+  --> <inline asm>:3:1\n+   |\n+LL | invalid_instruction\n+   | ^^^^^^^^^^^^^^^^^^^\n+\n+error: invalid instruction mnemonic 'invalid_instruction'\n+  --> $DIR/srcloc.rs:58:14\n+   |\n+LL |             \"invalid_instruction\",\n+   |              ^\n+   |\n+note: instantiated into assembly here\n+  --> <inline asm>:4:1\n+   |\n+LL | invalid_instruction\n+   | ^^^^^^^^^^^^^^^^^^^\n+\n+error: invalid instruction mnemonic 'invalid_instruction'\n+  --> $DIR/srcloc.rs:65:13\n+   |\n+LL |             concat!(\"invalid\", \"_\", \"instruction\"),\n+   |             ^\n+   |\n+note: instantiated into assembly here\n+  --> <inline asm>:3:1\n+   |\n+LL | invalid_instruction\n+   | ^^^^^^^^^^^^^^^^^^^\n+\n+error: invalid instruction mnemonic 'invalid_instruction'\n+  --> $DIR/srcloc.rs:72:13\n+   |\n+LL |             concat!(\"invalid\", \"_\", \"instruction\"),\n+   |             ^\n+   |\n+note: instantiated into assembly here\n+  --> <inline asm>:3:1\n+   |\n+LL | invalid_instruction\n+   | ^^^^^^^^^^^^^^^^^^^\n+\n+error: invalid instruction mnemonic 'invalid_instruction1'\n+  --> $DIR/srcloc.rs:79:14\n+   |\n+LL |             \"invalid_instruction1\",\n+   |              ^\n+   |\n+note: instantiated into assembly here\n+  --> <inline asm>:2:2\n+   |\n+LL |     invalid_instruction1\n+   |     ^^^^^^^^^^^^^^^^^^^^\n+\n+error: invalid instruction mnemonic 'invalid_instruction2'\n+  --> $DIR/srcloc.rs:80:14\n+   |\n+LL |             \"invalid_instruction2\",\n+   |              ^\n+   |\n+note: instantiated into assembly here\n+  --> <inline asm>:3:1\n+   |\n+LL | invalid_instruction2\n+   | ^^^^^^^^^^^^^^^^^^^^\n+\n+error: invalid instruction mnemonic 'invalid_instruction1'\n+  --> $DIR/srcloc.rs:86:13\n+   |\n+LL |             concat!(\n+   |             ^\n+   |\n+note: instantiated into assembly here\n+  --> <inline asm>:2:2\n+   |\n+LL |     invalid_instruction1\n+   |     ^^^^^^^^^^^^^^^^^^^^\n+\n+error: invalid instruction mnemonic 'invalid_instruction2'\n+  --> $DIR/srcloc.rs:86:13\n+   |\n+LL |             concat!(\n+   |             ^\n+   |\n+note: instantiated into assembly here\n+  --> <inline asm>:3:1\n+   |\n+LL | invalid_instruction2\n+   | ^^^^^^^^^^^^^^^^^^^^\n+\n+error: invalid instruction mnemonic 'invalid_instruction1'\n+  --> $DIR/srcloc.rs:95:13\n+   |\n+LL |             concat!(\n+   |             ^\n+   |\n+note: instantiated into assembly here\n+  --> <inline asm>:2:2\n+   |\n+LL |     invalid_instruction1\n+   |     ^^^^^^^^^^^^^^^^^^^^\n+\n+error: invalid instruction mnemonic 'invalid_instruction2'\n+  --> $DIR/srcloc.rs:95:13\n+   |\n+LL |             concat!(\n+   |             ^\n+   |\n+note: instantiated into assembly here\n+  --> <inline asm>:3:1\n+   |\n+LL | invalid_instruction2\n+   | ^^^^^^^^^^^^^^^^^^^^\n+\n+error: invalid instruction mnemonic 'invalid_instruction3'\n+  --> $DIR/srcloc.rs:99:13\n+   |\n+LL |             concat!(\n+   |             ^\n+   |\n+note: instantiated into assembly here\n+  --> <inline asm>:4:1\n+   |\n+LL | invalid_instruction3\n+   | ^^^^^^^^^^^^^^^^^^^^\n+\n+error: invalid instruction mnemonic 'invalid_instruction4'\n+  --> $DIR/srcloc.rs:99:13\n+   |\n+LL |             concat!(\n+   |             ^\n+   |\n+note: instantiated into assembly here\n+  --> <inline asm>:5:1\n+   |\n+LL | invalid_instruction4\n+   | ^^^^^^^^^^^^^^^^^^^^\n+\n+error: invalid instruction mnemonic 'invalid_instruction1'\n+  --> $DIR/srcloc.rs:110:13\n+   |\n+LL |             concat!(\n+   |             ^\n+   |\n+note: instantiated into assembly here\n+  --> <inline asm>:2:2\n+   |\n+LL |     invalid_instruction1\n+   |     ^^^^^^^^^^^^^^^^^^^^\n+\n+error: invalid instruction mnemonic 'invalid_instruction2'\n+  --> $DIR/srcloc.rs:110:13\n+   |\n+LL |             concat!(\n+   |             ^\n+   |\n+note: instantiated into assembly here\n+  --> <inline asm>:3:1\n+   |\n+LL | invalid_instruction2\n+   | ^^^^^^^^^^^^^^^^^^^^\n+\n+error: invalid instruction mnemonic 'invalid_instruction3'\n+  --> $DIR/srcloc.rs:114:13\n+   |\n+LL |             concat!(\n+   |             ^\n+   |\n+note: instantiated into assembly here\n+  --> <inline asm>:5:1\n+   |\n+LL | invalid_instruction3\n+   | ^^^^^^^^^^^^^^^^^^^^\n+\n+error: invalid instruction mnemonic 'invalid_instruction4'\n+  --> $DIR/srcloc.rs:114:13\n+   |\n+LL |             concat!(\n+   |             ^\n+   |\n+note: instantiated into assembly here\n+  --> <inline asm>:6:1\n+   |\n+LL | invalid_instruction4\n+   | ^^^^^^^^^^^^^^^^^^^^\n+\n+error: aborting due to 23 previous errors; 1 warning emitted\n "}]}