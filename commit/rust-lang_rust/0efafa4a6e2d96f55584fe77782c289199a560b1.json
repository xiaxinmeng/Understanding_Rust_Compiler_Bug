{"sha": "0efafa4a6e2d96f55584fe77782c289199a560b1", "node_id": "C_kwDOAAsO6NoAKDBlZmFmYTRhNmUyZDk2ZjU1NTg0ZmU3Nzc4MmMyODkxOTlhNTYwYjE", "commit": {"author": {"name": "Serial", "email": "69764315+Serial-ATA@users.noreply.github.com", "date": "2022-08-05T17:49:43Z"}, "committer": {"name": "Serial", "email": "69764315+Serial-ATA@users.noreply.github.com", "date": "2022-08-19T12:18:34Z"}, "message": "Better handle method/function calls", "tree": {"sha": "70faefbccfbced3a80b3b56ba678427f02c9be66", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/70faefbccfbced3a80b3b56ba678427f02c9be66"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0efafa4a6e2d96f55584fe77782c289199a560b1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0efafa4a6e2d96f55584fe77782c289199a560b1", "html_url": "https://github.com/rust-lang/rust/commit/0efafa4a6e2d96f55584fe77782c289199a560b1", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0efafa4a6e2d96f55584fe77782c289199a560b1/comments", "author": {"login": "Serial-ATA", "id": 69764315, "node_id": "MDQ6VXNlcjY5NzY0MzE1", "avatar_url": "https://avatars.githubusercontent.com/u/69764315?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Serial-ATA", "html_url": "https://github.com/Serial-ATA", "followers_url": "https://api.github.com/users/Serial-ATA/followers", "following_url": "https://api.github.com/users/Serial-ATA/following{/other_user}", "gists_url": "https://api.github.com/users/Serial-ATA/gists{/gist_id}", "starred_url": "https://api.github.com/users/Serial-ATA/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Serial-ATA/subscriptions", "organizations_url": "https://api.github.com/users/Serial-ATA/orgs", "repos_url": "https://api.github.com/users/Serial-ATA/repos", "events_url": "https://api.github.com/users/Serial-ATA/events{/privacy}", "received_events_url": "https://api.github.com/users/Serial-ATA/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Serial-ATA", "id": 69764315, "node_id": "MDQ6VXNlcjY5NzY0MzE1", "avatar_url": "https://avatars.githubusercontent.com/u/69764315?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Serial-ATA", "html_url": "https://github.com/Serial-ATA", "followers_url": "https://api.github.com/users/Serial-ATA/followers", "following_url": "https://api.github.com/users/Serial-ATA/following{/other_user}", "gists_url": "https://api.github.com/users/Serial-ATA/gists{/gist_id}", "starred_url": "https://api.github.com/users/Serial-ATA/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Serial-ATA/subscriptions", "organizations_url": "https://api.github.com/users/Serial-ATA/orgs", "repos_url": "https://api.github.com/users/Serial-ATA/repos", "events_url": "https://api.github.com/users/Serial-ATA/events{/privacy}", "received_events_url": "https://api.github.com/users/Serial-ATA/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2666c38acb8352b7fd5903f50ee5fd76e2441cff", "url": "https://api.github.com/repos/rust-lang/rust/commits/2666c38acb8352b7fd5903f50ee5fd76e2441cff", "html_url": "https://github.com/rust-lang/rust/commit/2666c38acb8352b7fd5903f50ee5fd76e2441cff"}], "stats": {"total": 152, "additions": 105, "deletions": 47}, "files": [{"sha": "369d4b4eed697ca0384764bce81b7e7bb783fb65", "filename": "clippy_lints/src/lib.register_suspicious.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0efafa4a6e2d96f55584fe77782c289199a560b1/clippy_lints%2Fsrc%2Flib.register_suspicious.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0efafa4a6e2d96f55584fe77782c289199a560b1/clippy_lints%2Fsrc%2Flib.register_suspicious.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flib.register_suspicious.rs?ref=0efafa4a6e2d96f55584fe77782c289199a560b1", "patch": "@@ -32,6 +32,6 @@ store.register_group(true, \"clippy::suspicious\", Some(\"clippy_suspicious\"), vec!\n     LintId::of(suspicious_trait_impl::SUSPICIOUS_ARITHMETIC_IMPL),\n     LintId::of(suspicious_trait_impl::SUSPICIOUS_OP_ASSIGN_IMPL),\n     LintId::of(swap_ptr_to_ref::SWAP_PTR_TO_REF),\n-    LintId::of(write::POSITIONAL_NAMED_FORMAT_PARAMETERS),\n     LintId::of(unused_peekable::UNUSED_PEEKABLE),\n+    LintId::of(write::POSITIONAL_NAMED_FORMAT_PARAMETERS),\n ])"}, {"sha": "2a0fb30131f7dc2f1eca859298b087e6a53f472f", "filename": "clippy_lints/src/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0efafa4a6e2d96f55584fe77782c289199a560b1/clippy_lints%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0efafa4a6e2d96f55584fe77782c289199a560b1/clippy_lints%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flib.rs?ref=0efafa4a6e2d96f55584fe77782c289199a560b1", "patch": "@@ -936,7 +936,7 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n     store.register_late_pass(|| Box::new(manual_instant_elapsed::ManualInstantElapsed));\n     store.register_late_pass(|| Box::new(partialeq_to_none::PartialeqToNone));\n     store.register_late_pass(|| Box::new(manual_empty_string_creations::ManualEmptyStringCreations));\n-    store.register_late_pass(|| Box::new(unused_peekable::UnusedPeekable::default()));\n+    store.register_late_pass(|| Box::new(unused_peekable::UnusedPeekable));\n     // add lints here, do not remove this comment, it's used in `new_lint`\n }\n "}, {"sha": "c060d767e2340fe7ad9b6e67aa4c626595e68634", "filename": "clippy_lints/src/unused_peekable.rs", "status": "modified", "additions": 60, "deletions": 43, "changes": 103, "blob_url": "https://github.com/rust-lang/rust/blob/0efafa4a6e2d96f55584fe77782c289199a560b1/clippy_lints%2Fsrc%2Funused_peekable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0efafa4a6e2d96f55584fe77782c289199a560b1/clippy_lints%2Fsrc%2Funused_peekable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Funused_peekable.rs?ref=0efafa4a6e2d96f55584fe77782c289199a560b1", "patch": "@@ -1,13 +1,13 @@\n use clippy_utils::diagnostics::span_lint_and_help;\n use clippy_utils::ty::{match_type, peel_mid_ty_refs_is_mutable};\n-use clippy_utils::{fn_def_id, path_to_local_id, paths, peel_ref_operators};\n+use clippy_utils::{fn_def_id, is_trait_method, path_to_local_id, paths, peel_ref_operators};\n use rustc_ast::Mutability;\n use rustc_hir::intravisit::{walk_expr, Visitor};\n use rustc_hir::lang_items::LangItem;\n use rustc_hir::{Block, Expr, ExprKind, HirId, Local, Node, PatKind, PathSegment, StmtKind};\n use rustc_lint::{LateContext, LateLintPass};\n-use rustc_middle::ty::Ty;\n-use rustc_session::{declare_tool_lint, impl_lint_pass};\n+use rustc_session::{declare_lint_pass, declare_tool_lint};\n+use rustc_span::sym;\n \n declare_clippy_lint! {\n     /// ### What it does\n@@ -42,12 +42,7 @@ declare_clippy_lint! {\n     \"creating a peekable iterator without using any of its methods\"\n }\n \n-#[derive(Default)]\n-pub struct UnusedPeekable {\n-    visited: Vec<HirId>,\n-}\n-\n-impl_lint_pass!(UnusedPeekable => [UNUSED_PEEKABLE]);\n+declare_lint_pass!(UnusedPeekable => [UNUSED_PEEKABLE]);\n \n impl<'tcx> LateLintPass<'tcx> for UnusedPeekable {\n     fn check_block(&mut self, cx: &LateContext<'tcx>, block: &Block<'tcx>) {\n@@ -62,15 +57,14 @@ impl<'tcx> LateLintPass<'tcx> for UnusedPeekable {\n         for (idx, stmt) in block.stmts.iter().enumerate() {\n             if !stmt.span.from_expansion()\n                 && let StmtKind::Local(local) = stmt.kind\n-                && !self.visited.contains(&local.pat.hir_id)\n-                && let PatKind::Binding(_, _, ident, _) = local.pat.kind\n+                && let PatKind::Binding(_, binding, ident, _) = local.pat.kind\n                 && let Some(init) = local.init\n                 && !init.span.from_expansion()\n                 && let Some(ty) = cx.typeck_results().expr_ty_opt(init)\n                 && let (ty, _, Mutability::Mut) = peel_mid_ty_refs_is_mutable(ty)\n                 && match_type(cx, ty, &paths::PEEKABLE)\n             {\n-                let mut vis = PeekableVisitor::new(cx, local.pat.hir_id);\n+                let mut vis = PeekableVisitor::new(cx, binding);\n \n                 if idx + 1 == block.stmts.len() && block.expr.is_none() {\n                     return;\n@@ -117,6 +111,10 @@ impl<'a, 'tcx> PeekableVisitor<'a, 'tcx> {\n \n impl<'tcx> Visitor<'_> for PeekableVisitor<'_, 'tcx> {\n     fn visit_expr(&mut self, ex: &'_ Expr<'_>) {\n+        if self.found_peek_call {\n+            return;\n+        }\n+\n         if path_to_local_id(ex, self.expected_hir_id) {\n             for (_, node) in self.cx.tcx.hir().parent_iter(ex.hir_id) {\n                 match node {\n@@ -138,50 +136,58 @@ impl<'tcx> Visitor<'_> for PeekableVisitor<'_, 'tcx> {\n                                     return;\n                                 }\n \n-                                for arg in args.iter().map(|arg| peel_ref_operators(self.cx, arg)) {\n-                                    if let ExprKind::Path(_) = arg.kind\n-                                        && let Some(ty) = self\n-                                            .cx\n-                                            .typeck_results()\n-                                            .expr_ty_opt(arg)\n-                                            .map(Ty::peel_refs)\n-                                        && match_type(self.cx, ty, &paths::PEEKABLE)\n-                                    {\n-                                        self.found_peek_call = true;\n-                                        return;\n-                                    }\n+                                if args.iter().any(|arg| {\n+                                    matches!(arg.kind, ExprKind::Path(_)) && arg_is_mut_peekable(self.cx, arg)\n+                                }) {\n+                                    self.found_peek_call = true;\n+                                    return;\n                                 }\n                             },\n-                            // Peekable::peek()\n-                            ExprKind::MethodCall(PathSegment { ident: method_name, .. }, [arg, ..], _) => {\n-                                let arg = peel_ref_operators(self.cx, arg);\n-                                let method_name = method_name.name.as_str();\n-\n-                                if (method_name == \"peek\"\n-                                    || method_name == \"peek_mut\"\n-                                    || method_name == \"next_if\"\n-                                    || method_name == \"next_if_eq\")\n-                                    && let ExprKind::Path(_) = arg.kind\n-                                    && let Some(ty) = self.cx.typeck_results().expr_ty_opt(arg).map(Ty::peel_refs)\n-                                    && match_type(self.cx, ty, &paths::PEEKABLE)\n+                            // Catch anything taking a Peekable mutably\n+                            ExprKind::MethodCall(\n+                                PathSegment {\n+                                    ident: method_name_ident,\n+                                    ..\n+                                },\n+                                [self_arg, remaining_args @ ..],\n+                                _,\n+                            ) => {\n+                                let method_name = method_name_ident.name.as_str();\n+\n+                                // `Peekable` methods\n+                                if matches!(method_name, \"peek\" | \"peek_mut\" | \"next_if\" | \"next_if_eq\")\n+                                    && arg_is_mut_peekable(self.cx, self_arg)\n+                                {\n+                                    self.found_peek_call = true;\n+                                    return;\n+                                }\n+\n+                                // foo.some_method() excluding Iterator methods\n+                                if remaining_args.iter().any(|arg| arg_is_mut_peekable(self.cx, arg))\n+                                    && !is_trait_method(self.cx, expr, sym::Iterator)\n                                 {\n                                     self.found_peek_call = true;\n                                     return;\n                                 }\n+\n+                                // foo.by_ref(), keep checking for `peek`\n+                                if method_name == \"by_ref\" {\n+                                    continue;\n+                                }\n+\n+                                return;\n+                            },\n+                            ExprKind::AddrOf(_, Mutability::Mut, _) | ExprKind::Unary(..) | ExprKind::DropTemps(_) => {\n                             },\n-                            // Don't bother if moved into a struct\n-                            ExprKind::Struct(..) => {\n+                            ExprKind::AddrOf(_, Mutability::Not, _) => return,\n+                            _ => {\n                                 self.found_peek_call = true;\n                                 return;\n                             },\n-                            _ => {},\n                         }\n                     },\n                     Node::Local(Local { init: Some(init), .. }) => {\n-                        if let Some(ty) = self.cx.typeck_results().expr_ty_opt(init)\n-                            && let (ty, _, Mutability::Mut) = peel_mid_ty_refs_is_mutable(ty)\n-                            && match_type(self.cx, ty, &paths::PEEKABLE)\n-                        {\n+                        if arg_is_mut_peekable(self.cx, init) {\n                             self.found_peek_call = true;\n                             return;\n                         }\n@@ -206,3 +212,14 @@ impl<'tcx> Visitor<'_> for PeekableVisitor<'_, 'tcx> {\n         walk_expr(self, ex);\n     }\n }\n+\n+fn arg_is_mut_peekable(cx: &LateContext<'_>, arg: &Expr<'_>) -> bool {\n+    if let Some(ty) = cx.typeck_results().expr_ty_opt(arg)\n+        && let (ty, _, Mutability::Mut) = peel_mid_ty_refs_is_mutable(ty)\n+        && match_type(cx, ty, &paths::PEEKABLE)\n+    {\n+        true\n+    } else {\n+        false\n+    }\n+}"}, {"sha": "153457e367165c6ce2fa6d3370a4c81a2645d265", "filename": "tests/ui/unused_peekable.rs", "status": "modified", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/0efafa4a6e2d96f55584fe77782c289199a560b1/tests%2Fui%2Funused_peekable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0efafa4a6e2d96f55584fe77782c289199a560b1/tests%2Fui%2Funused_peekable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Funused_peekable.rs?ref=0efafa4a6e2d96f55584fe77782c289199a560b1", "patch": "@@ -32,6 +32,15 @@ fn invalid() {\n     let mut peekable_using_iterator_method = std::iter::empty::<u32>().peekable();\n     peekable_using_iterator_method.next();\n \n+    // Passed by ref to another function\n+    fn takes_ref(_peek: &Peekable<Empty<u32>>) {}\n+    let passed_along_ref = std::iter::empty::<u32>().peekable();\n+    takes_ref(&passed_along_ref);\n+\n+    // `by_ref` without `peek`\n+    let mut by_ref_test = std::iter::empty::<u32>().peekable();\n+    let _by_ref = by_ref_test.by_ref();\n+\n     let mut peekable_in_for_loop = std::iter::empty::<u32>().peekable();\n     for x in peekable_in_for_loop {}\n }\n@@ -43,6 +52,18 @@ fn valid() {\n     let passed_along = std::iter::empty::<u32>().peekable();\n     takes_peekable(passed_along);\n \n+    // Passed to another method\n+    struct PeekableConsumer;\n+    impl PeekableConsumer {\n+        fn consume(&self, _: Peekable<Empty<u32>>) {}\n+        fn consume_mut_ref(&self, _: &mut Peekable<Empty<u32>>) {}\n+    }\n+\n+    let peekable_consumer = PeekableConsumer;\n+    let mut passed_along_to_method = std::iter::empty::<u32>().peekable();\n+    peekable_consumer.consume_mut_ref(&mut passed_along_to_method);\n+    peekable_consumer.consume(passed_along_to_method);\n+\n     // `peek` called in another block\n     let mut peekable_in_block = std::iter::empty::<u32>().peekable();\n     {\n@@ -111,6 +132,10 @@ fn valid() {\n     let struct_test = std::iter::empty::<u32>().peekable();\n     PeekableWrapper { f: struct_test };\n \n+    // `by_ref` before `peek`\n+    let mut by_ref_test = std::iter::empty::<u32>().peekable();\n+    let peeked_val = by_ref_test.by_ref().peek();\n+\n     // `peek` called in another block as the last expression\n     let mut peekable_last_expr = std::iter::empty::<u32>().peekable();\n     {"}, {"sha": "d557f54179dbaf680ccf899b14e9e3b242393935", "filename": "tests/ui/unused_peekable.stderr", "status": "modified", "additions": 18, "deletions": 2, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/0efafa4a6e2d96f55584fe77782c289199a560b1/tests%2Fui%2Funused_peekable.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/0efafa4a6e2d96f55584fe77782c289199a560b1/tests%2Fui%2Funused_peekable.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Funused_peekable.stderr?ref=0efafa4a6e2d96f55584fe77782c289199a560b1", "patch": "@@ -40,12 +40,28 @@ LL |     let mut peekable_using_iterator_method = std::iter::empty::<u32>().peek\n    = help: consider removing the call to `peekable`\n \n error: `peek` never called on `Peekable` iterator\n-  --> $DIR/unused_peekable.rs:35:13\n+  --> $DIR/unused_peekable.rs:37:9\n+   |\n+LL |     let passed_along_ref = std::iter::empty::<u32>().peekable();\n+   |         ^^^^^^^^^^^^^^^^\n+   |\n+   = help: consider removing the call to `peekable`\n+\n+error: `peek` never called on `Peekable` iterator\n+  --> $DIR/unused_peekable.rs:42:9\n+   |\n+LL |     let _by_ref = by_ref_test.by_ref();\n+   |         ^^^^^^^\n+   |\n+   = help: consider removing the call to `peekable`\n+\n+error: `peek` never called on `Peekable` iterator\n+  --> $DIR/unused_peekable.rs:44:13\n    |\n LL |     let mut peekable_in_for_loop = std::iter::empty::<u32>().peekable();\n    |             ^^^^^^^^^^^^^^^^^^^^\n    |\n    = help: consider removing the call to `peekable`\n \n-error: aborting due to 6 previous errors\n+error: aborting due to 8 previous errors\n "}]}