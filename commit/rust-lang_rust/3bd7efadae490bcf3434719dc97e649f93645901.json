{"sha": "3bd7efadae490bcf3434719dc97e649f93645901", "node_id": "MDY6Q29tbWl0NzI0NzEyOjNiZDdlZmFkYWU0OTBiY2YzNDM0NzE5ZGM5N2U2NDlmOTM2NDU5MDE=", "commit": {"author": {"name": "Irina Popa", "email": "irinagpopa@gmail.com", "date": "2017-12-28T17:07:02Z"}, "committer": {"name": "Irina Popa", "email": "irinagpopa@gmail.com", "date": "2018-04-26T13:50:27Z"}, "message": "rustc_target: move in type definitions from rustc_trans::abi.", "tree": {"sha": "bf8e4e08d0b3becf5008555da43e43d5b26b046a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/bf8e4e08d0b3becf5008555da43e43d5b26b046a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3bd7efadae490bcf3434719dc97e649f93645901", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3bd7efadae490bcf3434719dc97e649f93645901", "html_url": "https://github.com/rust-lang/rust/commit/3bd7efadae490bcf3434719dc97e649f93645901", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3bd7efadae490bcf3434719dc97e649f93645901/comments", "author": {"login": "irinagpopa", "id": 32459019, "node_id": "MDQ6VXNlcjMyNDU5MDE5", "avatar_url": "https://avatars.githubusercontent.com/u/32459019?v=4", "gravatar_id": "", "url": "https://api.github.com/users/irinagpopa", "html_url": "https://github.com/irinagpopa", "followers_url": "https://api.github.com/users/irinagpopa/followers", "following_url": "https://api.github.com/users/irinagpopa/following{/other_user}", "gists_url": "https://api.github.com/users/irinagpopa/gists{/gist_id}", "starred_url": "https://api.github.com/users/irinagpopa/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/irinagpopa/subscriptions", "organizations_url": "https://api.github.com/users/irinagpopa/orgs", "repos_url": "https://api.github.com/users/irinagpopa/repos", "events_url": "https://api.github.com/users/irinagpopa/events{/privacy}", "received_events_url": "https://api.github.com/users/irinagpopa/received_events", "type": "User", "site_admin": false}, "committer": {"login": "irinagpopa", "id": 32459019, "node_id": "MDQ6VXNlcjMyNDU5MDE5", "avatar_url": "https://avatars.githubusercontent.com/u/32459019?v=4", "gravatar_id": "", "url": "https://api.github.com/users/irinagpopa", "html_url": "https://github.com/irinagpopa", "followers_url": "https://api.github.com/users/irinagpopa/followers", "following_url": "https://api.github.com/users/irinagpopa/following{/other_user}", "gists_url": "https://api.github.com/users/irinagpopa/gists{/gist_id}", "starred_url": "https://api.github.com/users/irinagpopa/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/irinagpopa/subscriptions", "organizations_url": "https://api.github.com/users/irinagpopa/orgs", "repos_url": "https://api.github.com/users/irinagpopa/repos", "events_url": "https://api.github.com/users/irinagpopa/events{/privacy}", "received_events_url": "https://api.github.com/users/irinagpopa/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "bdcd08278a4b442bd156e3704065403d86728eda", "url": "https://api.github.com/repos/rust-lang/rust/commits/bdcd08278a4b442bd156e3704065403d86728eda", "html_url": "https://github.com/rust-lang/rust/commit/bdcd08278a4b442bd156e3704065403d86728eda"}], "stats": {"total": 454, "additions": 242, "deletions": 212}, "files": [{"sha": "878212d4ee4d3d6bbcd0937771c9a95a75ca91d6", "filename": "src/Cargo.lock", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/3bd7efadae490bcf3434719dc97e649f93645901/src%2FCargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/3bd7efadae490bcf3434719dc97e649f93645901/src%2FCargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2FCargo.lock?ref=3bd7efadae490bcf3434719dc97e649f93645901", "patch": "@@ -2115,8 +2115,8 @@ dependencies = [\n name = \"rustc_target\"\n version = \"0.0.0\"\n dependencies = [\n+ \"bitflags 1.0.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"log 0.4.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"rand 0.4.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"serialize 0.0.0\",\n  \"syntax 0.0.0\",\n ]\n@@ -2138,7 +2138,6 @@ dependencies = [\n name = \"rustc_trans\"\n version = \"0.0.0\"\n dependencies = [\n- \"bitflags 1.0.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"cc 1.0.10 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"env_logger 0.5.8 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"flate2 1.0.1 (registry+https://github.com/rust-lang/crates.io-index)\","}, {"sha": "4064cb17f01dfd66415827de4162459832a8ecc3", "filename": "src/librustc_target/Cargo.toml", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3bd7efadae490bcf3434719dc97e649f93645901/src%2Flibrustc_target%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/3bd7efadae490bcf3434719dc97e649f93645901/src%2Flibrustc_target%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_target%2FCargo.toml?ref=3bd7efadae490bcf3434719dc97e649f93645901", "patch": "@@ -9,10 +9,10 @@ path = \"lib.rs\"\n crate-type = [\"dylib\"]\n \n [dependencies]\n+bitflags = \"1.0\"\n+log = \"0.4\"\n syntax = { path = \"../libsyntax\" }\n serialize = { path = \"../libserialize\" }\n-log = \"0.4\"\n-rand = \"0.4\"\n \n [features]\n jemalloc = []"}, {"sha": "bea705b9ece2f5ae61de49936a2ff2c0d1091026", "filename": "src/librustc_target/abi/call.rs", "status": "added", "additions": 214, "deletions": 0, "changes": 214, "blob_url": "https://github.com/rust-lang/rust/blob/3bd7efadae490bcf3434719dc97e649f93645901/src%2Flibrustc_target%2Fabi%2Fcall.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3bd7efadae490bcf3434719dc97e649f93645901/src%2Flibrustc_target%2Fabi%2Fcall.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_target%2Fabi%2Fcall.rs?ref=3bd7efadae490bcf3434719dc97e649f93645901", "patch": "@@ -0,0 +1,214 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use abi::{Align, HasDataLayout, Size};\n+\n+#[derive(Clone, Copy, PartialEq, Eq, Debug)]\n+pub enum PassMode {\n+    /// Ignore the argument (useful for empty struct).\n+    Ignore,\n+    /// Pass the argument directly.\n+    Direct(ArgAttributes),\n+    /// Pass a pair's elements directly in two arguments.\n+    Pair(ArgAttributes, ArgAttributes),\n+    /// Pass the argument after casting it, to either\n+    /// a single uniform or a pair of registers.\n+    Cast(CastTarget),\n+    /// Pass the argument indirectly via a hidden pointer.\n+    Indirect(ArgAttributes),\n+}\n+\n+// Hack to disable non_upper_case_globals only for the bitflags! and not for the rest\n+// of this module\n+pub use self::attr_impl::ArgAttribute;\n+\n+#[allow(non_upper_case_globals)]\n+#[allow(unused)]\n+mod attr_impl {\n+    // The subset of llvm::Attribute needed for arguments, packed into a bitfield.\n+    bitflags! {\n+        #[derive(Default)]\n+        pub struct ArgAttribute: u16 {\n+            const ByVal     = 1 << 0;\n+            const NoAlias   = 1 << 1;\n+            const NoCapture = 1 << 2;\n+            const NonNull   = 1 << 3;\n+            const ReadOnly  = 1 << 4;\n+            const SExt      = 1 << 5;\n+            const StructRet = 1 << 6;\n+            const ZExt      = 1 << 7;\n+            const InReg     = 1 << 8;\n+        }\n+    }\n+}\n+\n+/// A compact representation of LLVM attributes (at least those relevant for this module)\n+/// that can be manipulated without interacting with LLVM's Attribute machinery.\n+#[derive(Copy, Clone, PartialEq, Eq, Debug)]\n+pub struct ArgAttributes {\n+    pub regular: ArgAttribute,\n+    pub pointee_size: Size,\n+    pub pointee_align: Option<Align>\n+}\n+\n+impl ArgAttributes {\n+    pub fn new() -> Self {\n+        ArgAttributes {\n+            regular: ArgAttribute::default(),\n+            pointee_size: Size::from_bytes(0),\n+            pointee_align: None,\n+        }\n+    }\n+\n+    pub fn set(&mut self, attr: ArgAttribute) -> &mut Self {\n+        self.regular = self.regular | attr;\n+        self\n+    }\n+\n+    pub fn contains(&self, attr: ArgAttribute) -> bool {\n+        self.regular.contains(attr)\n+    }\n+}\n+\n+#[derive(Copy, Clone, PartialEq, Eq, Debug)]\n+pub enum RegKind {\n+    Integer,\n+    Float,\n+    Vector\n+}\n+\n+#[derive(Copy, Clone, PartialEq, Eq, Debug)]\n+pub struct Reg {\n+    pub kind: RegKind,\n+    pub size: Size,\n+}\n+\n+macro_rules! reg_ctor {\n+    ($name:ident, $kind:ident, $bits:expr) => {\n+        pub fn $name() -> Reg {\n+            Reg {\n+                kind: RegKind::$kind,\n+                size: Size::from_bits($bits)\n+            }\n+        }\n+    }\n+}\n+\n+impl Reg {\n+    reg_ctor!(i8, Integer, 8);\n+    reg_ctor!(i16, Integer, 16);\n+    reg_ctor!(i32, Integer, 32);\n+    reg_ctor!(i64, Integer, 64);\n+\n+    reg_ctor!(f32, Float, 32);\n+    reg_ctor!(f64, Float, 64);\n+}\n+\n+impl Reg {\n+    pub fn align<C: HasDataLayout>(&self, cx: C) -> Align {\n+        let dl = cx.data_layout();\n+        match self.kind {\n+            RegKind::Integer => {\n+                match self.size.bits() {\n+                    1 => dl.i1_align,\n+                    2...8 => dl.i8_align,\n+                    9...16 => dl.i16_align,\n+                    17...32 => dl.i32_align,\n+                    33...64 => dl.i64_align,\n+                    65...128 => dl.i128_align,\n+                    _ => panic!(\"unsupported integer: {:?}\", self)\n+                }\n+            }\n+            RegKind::Float => {\n+                match self.size.bits() {\n+                    32 => dl.f32_align,\n+                    64 => dl.f64_align,\n+                    _ => panic!(\"unsupported float: {:?}\", self)\n+                }\n+            }\n+            RegKind::Vector => dl.vector_align(self.size)\n+        }\n+    }\n+}\n+\n+/// An argument passed entirely registers with the\n+/// same kind (e.g. HFA / HVA on PPC64 and AArch64).\n+#[derive(Clone, Copy, PartialEq, Eq, Debug)]\n+pub struct Uniform {\n+    pub unit: Reg,\n+\n+    /// The total size of the argument, which can be:\n+    /// * equal to `unit.size` (one scalar/vector)\n+    /// * a multiple of `unit.size` (an array of scalar/vectors)\n+    /// * if `unit.kind` is `Integer`, the last element\n+    ///   can be shorter, i.e. `{ i64, i64, i32 }` for\n+    ///   64-bit integers with a total size of 20 bytes\n+    pub total: Size,\n+}\n+\n+impl From<Reg> for Uniform {\n+    fn from(unit: Reg) -> Uniform {\n+        Uniform {\n+            unit,\n+            total: unit.size\n+        }\n+    }\n+}\n+\n+impl Uniform {\n+    pub fn align<C: HasDataLayout>(&self, cx: C) -> Align {\n+        self.unit.align(cx)\n+    }\n+}\n+\n+#[derive(Clone, Copy, PartialEq, Eq, Debug)]\n+pub struct CastTarget {\n+    pub prefix: [Option<RegKind>; 8],\n+    pub prefix_chunk: Size,\n+    pub rest: Uniform,\n+}\n+\n+impl From<Reg> for CastTarget {\n+    fn from(unit: Reg) -> CastTarget {\n+        CastTarget::from(Uniform::from(unit))\n+    }\n+}\n+\n+impl From<Uniform> for CastTarget {\n+    fn from(uniform: Uniform) -> CastTarget {\n+        CastTarget {\n+            prefix: [None; 8],\n+            prefix_chunk: Size::from_bytes(0),\n+            rest: uniform\n+        }\n+    }\n+}\n+\n+impl CastTarget {\n+    pub fn pair(a: Reg, b: Reg) -> CastTarget {\n+        CastTarget {\n+            prefix: [Some(a.kind), None, None, None, None, None, None, None],\n+            prefix_chunk: a.size,\n+            rest: Uniform::from(b)\n+        }\n+    }\n+\n+    pub fn size<C: HasDataLayout>(&self, cx: C) -> Size {\n+        (self.prefix_chunk * self.prefix.iter().filter(|x| x.is_some()).count() as u64)\n+             .abi_align(self.rest.align(cx)) + self.rest.total\n+    }\n+\n+    pub fn align<C: HasDataLayout>(&self, cx: C) -> Align {\n+        self.prefix.iter()\n+            .filter_map(|x| x.map(|kind| Reg { kind: kind, size: self.prefix_chunk }.align(cx)))\n+            .fold(cx.data_layout().aggregate_align.max(self.rest.align(cx)),\n+                |acc, align| acc.max(align))\n+    }\n+}\n\\ No newline at end of file"}, {"sha": "8cdc34db2df98399e45d9a05b8c846932beef076", "filename": "src/librustc_target/abi/mod.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3bd7efadae490bcf3434719dc97e649f93645901/src%2Flibrustc_target%2Fabi%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3bd7efadae490bcf3434719dc97e649f93645901/src%2Flibrustc_target%2Fabi%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_target%2Fabi%2Fmod.rs?ref=3bd7efadae490bcf3434719dc97e649f93645901", "patch": "@@ -16,6 +16,8 @@ use spec::Target;\n use std::cmp;\n use std::ops::{Add, Sub, Mul, AddAssign, RangeInclusive};\n \n+pub mod call;\n+\n /// Parsed [Data layout](http://llvm.org/docs/LangRef.html#data-layout)\n /// for a target, which contains everything needed to compute layouts.\n pub struct TargetDataLayout {"}, {"sha": "c2418a3b2a7097bb47c07a11f775d4575fed6884", "filename": "src/librustc_target/lib.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/3bd7efadae490bcf3434719dc97e649f93645901/src%2Flibrustc_target%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3bd7efadae490bcf3434719dc97e649f93645901/src%2Flibrustc_target%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_target%2Flib.rs?ref=3bd7efadae490bcf3434719dc97e649f93645901", "patch": "@@ -31,8 +31,9 @@\n #![feature(inclusive_range)]\n #![feature(slice_patterns)]\n \n+#[macro_use]\n+extern crate bitflags;\n extern crate syntax;\n-extern crate rand;\n extern crate serialize;\n #[macro_use] extern crate log;\n "}, {"sha": "32432d6cc835de89d17b6441fa935e3ac9795df2", "filename": "src/librustc_trans/Cargo.toml", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/3bd7efadae490bcf3434719dc97e649f93645901/src%2Flibrustc_trans%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/3bd7efadae490bcf3434719dc97e649f93645901/src%2Flibrustc_trans%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2FCargo.toml?ref=3bd7efadae490bcf3434719dc97e649f93645901", "patch": "@@ -10,7 +10,6 @@ crate-type = [\"dylib\"]\n test = false\n \n [dependencies]\n-bitflags = \"1.0\"\n cc = \"1.0.1\"\n flate2 = \"1.0\"\n jobserver = \"0.1.5\""}, {"sha": "f19fc0744168e71917ec52989cc2318ee55dd542", "filename": "src/librustc_trans/abi.rs", "status": "modified", "additions": 19, "deletions": 202, "changes": 221, "blob_url": "https://github.com/rust-lang/rust/blob/3bd7efadae490bcf3434719dc97e649f93645901/src%2Flibrustc_trans%2Fabi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3bd7efadae490bcf3434719dc97e649f93645901/src%2Flibrustc_trans%2Fabi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fabi.rs?ref=3bd7efadae490bcf3434719dc97e649f93645901", "patch": "@@ -37,95 +37,39 @@ use type_::Type;\n use type_of::{LayoutLlvmExt, PointerKind};\n \n use rustc::ty::{self, Ty};\n-use rustc::ty::layout::{self, Align, Size, TyLayout};\n-use rustc::ty::layout::{HasDataLayout, LayoutOf};\n+use rustc::ty::layout::{self, LayoutOf, Size, TyLayout};\n \n use libc::c_uint;\n use std::cmp;\n \n pub use syntax::abi::Abi;\n pub use rustc::ty::layout::{FAT_PTR_ADDR, FAT_PTR_EXTRA};\n-\n-#[derive(Clone, Copy, PartialEq, Eq, Debug)]\n-pub enum PassMode {\n-    /// Ignore the argument (useful for empty struct).\n-    Ignore,\n-    /// Pass the argument directly.\n-    Direct(ArgAttributes),\n-    /// Pass a pair's elements directly in two arguments.\n-    Pair(ArgAttributes, ArgAttributes),\n-    /// Pass the argument after casting it, to either\n-    /// a single uniform or a pair of registers.\n-    Cast(CastTarget),\n-    /// Pass the argument indirectly via a hidden pointer.\n-    Indirect(ArgAttributes),\n-}\n-\n-// Hack to disable non_upper_case_globals only for the bitflags! and not for the rest\n-// of this module\n-pub use self::attr_impl::ArgAttribute;\n-\n-#[allow(non_upper_case_globals)]\n-#[allow(unused)]\n-mod attr_impl {\n-    // The subset of llvm::Attribute needed for arguments, packed into a bitfield.\n-    bitflags! {\n-        #[derive(Default)]\n-        pub struct ArgAttribute: u16 {\n-            const ByVal     = 1 << 0;\n-            const NoAlias   = 1 << 1;\n-            const NoCapture = 1 << 2;\n-            const NonNull   = 1 << 3;\n-            const ReadOnly  = 1 << 4;\n-            const SExt      = 1 << 5;\n-            const StructRet = 1 << 6;\n-            const ZExt      = 1 << 7;\n-            const InReg     = 1 << 8;\n-        }\n-    }\n-}\n+pub use rustc_target::abi::call::*;\n \n macro_rules! for_each_kind {\n     ($flags: ident, $f: ident, $($kind: ident),+) => ({\n         $(if $flags.contains(ArgAttribute::$kind) { $f(llvm::Attribute::$kind) })+\n     })\n }\n \n-impl ArgAttribute {\n+trait ArgAttributeExt {\n+    fn for_each_kind<F>(&self, f: F) where F: FnMut(llvm::Attribute);\n+}\n+\n+impl ArgAttributeExt for ArgAttribute {\n     fn for_each_kind<F>(&self, mut f: F) where F: FnMut(llvm::Attribute) {\n         for_each_kind!(self, f,\n                        ByVal, NoAlias, NoCapture, NonNull, ReadOnly, SExt, StructRet, ZExt, InReg)\n     }\n }\n \n-/// A compact representation of LLVM attributes (at least those relevant for this module)\n-/// that can be manipulated without interacting with LLVM's Attribute machinery.\n-#[derive(Copy, Clone, PartialEq, Eq, Debug)]\n-pub struct ArgAttributes {\n-    regular: ArgAttribute,\n-    pointee_size: Size,\n-    pointee_align: Option<Align>\n+pub trait ArgAttributesExt {\n+    fn apply_llfn(&self, idx: AttributePlace, llfn: ValueRef);\n+    fn apply_callsite(&self, idx: AttributePlace, callsite: ValueRef);\n }\n \n-impl ArgAttributes {\n-    fn new() -> Self {\n-        ArgAttributes {\n-            regular: ArgAttribute::default(),\n-            pointee_size: Size::from_bytes(0),\n-            pointee_align: None,\n-        }\n-    }\n-\n-    pub fn set(&mut self, attr: ArgAttribute) -> &mut Self {\n-        self.regular = self.regular | attr;\n-        self\n-    }\n-\n-    pub fn contains(&self, attr: ArgAttribute) -> bool {\n-        self.regular.contains(attr)\n-    }\n-\n-    pub fn apply_llfn(&self, idx: AttributePlace, llfn: ValueRef) {\n+impl ArgAttributesExt for ArgAttributes {\n+    fn apply_llfn(&self, idx: AttributePlace, llfn: ValueRef) {\n         let mut regular = self.regular;\n         unsafe {\n             let deref = self.pointee_size.bytes();\n@@ -150,7 +94,7 @@ impl ArgAttributes {\n         }\n     }\n \n-    pub fn apply_callsite(&self, idx: AttributePlace, callsite: ValueRef) {\n+    fn apply_callsite(&self, idx: AttributePlace, callsite: ValueRef) {\n         let mut regular = self.regular;\n         unsafe {\n             let deref = self.pointee_size.bytes();\n@@ -175,67 +119,13 @@ impl ArgAttributes {\n         }\n     }\n }\n-#[derive(Copy, Clone, PartialEq, Eq, Debug)]\n-pub enum RegKind {\n-    Integer,\n-    Float,\n-    Vector\n-}\n \n-#[derive(Copy, Clone, PartialEq, Eq, Debug)]\n-pub struct Reg {\n-    pub kind: RegKind,\n-    pub size: Size,\n+pub trait LlvmType {\n+    fn llvm_type(&self, cx: &CodegenCx) -> Type;\n }\n \n-macro_rules! reg_ctor {\n-    ($name:ident, $kind:ident, $bits:expr) => {\n-        pub fn $name() -> Reg {\n-            Reg {\n-                kind: RegKind::$kind,\n-                size: Size::from_bits($bits)\n-            }\n-        }\n-    }\n-}\n-\n-impl Reg {\n-    reg_ctor!(i8, Integer, 8);\n-    reg_ctor!(i16, Integer, 16);\n-    reg_ctor!(i32, Integer, 32);\n-    reg_ctor!(i64, Integer, 64);\n-\n-    reg_ctor!(f32, Float, 32);\n-    reg_ctor!(f64, Float, 64);\n-}\n-\n-impl Reg {\n-    pub fn align(&self, cx: &CodegenCx) -> Align {\n-        let dl = cx.data_layout();\n-        match self.kind {\n-            RegKind::Integer => {\n-                match self.size.bits() {\n-                    1 => dl.i1_align,\n-                    2...8 => dl.i8_align,\n-                    9...16 => dl.i16_align,\n-                    17...32 => dl.i32_align,\n-                    33...64 => dl.i64_align,\n-                    65...128 => dl.i128_align,\n-                    _ => bug!(\"unsupported integer: {:?}\", self)\n-                }\n-            }\n-            RegKind::Float => {\n-                match self.size.bits() {\n-                    32 => dl.f32_align,\n-                    64 => dl.f64_align,\n-                    _ => bug!(\"unsupported float: {:?}\", self)\n-                }\n-            }\n-            RegKind::Vector => dl.vector_align(self.size)\n-        }\n-    }\n-\n-    pub fn llvm_type(&self, cx: &CodegenCx) -> Type {\n+impl LlvmType for Reg {\n+    fn llvm_type(&self, cx: &CodegenCx) -> Type {\n         match self.kind {\n             RegKind::Integer => Type::ix(cx, self.size.bits()),\n             RegKind::Float => {\n@@ -252,36 +142,6 @@ impl Reg {\n     }\n }\n \n-/// An argument passed entirely registers with the\n-/// same kind (e.g. HFA / HVA on PPC64 and AArch64).\n-#[derive(Clone, Copy, PartialEq, Eq, Debug)]\n-pub struct Uniform {\n-    pub unit: Reg,\n-\n-    /// The total size of the argument, which can be:\n-    /// * equal to `unit.size` (one scalar/vector)\n-    /// * a multiple of `unit.size` (an array of scalar/vectors)\n-    /// * if `unit.kind` is `Integer`, the last element\n-    ///   can be shorter, i.e. `{ i64, i64, i32 }` for\n-    ///   64-bit integers with a total size of 20 bytes\n-    pub total: Size,\n-}\n-\n-impl From<Reg> for Uniform {\n-    fn from(unit: Reg) -> Uniform {\n-        Uniform {\n-            unit,\n-            total: unit.size\n-        }\n-    }\n-}\n-\n-impl Uniform {\n-    pub fn align(&self, cx: &CodegenCx) -> Align {\n-        self.unit.align(cx)\n-    }\n-}\n-\n pub trait LayoutExt<'tcx> {\n     fn is_aggregate(&self) -> bool;\n     fn homogeneous_aggregate<'a>(&self, cx: &CodegenCx<'a, 'tcx>) -> Option<Reg>;\n@@ -381,51 +241,8 @@ impl<'tcx> LayoutExt<'tcx> for TyLayout<'tcx> {\n     }\n }\n \n-#[derive(Clone, Copy, PartialEq, Eq, Debug)]\n-pub struct CastTarget {\n-    pub prefix: [Option<RegKind>; 8],\n-    pub prefix_chunk: Size,\n-    pub rest: Uniform,\n-}\n-\n-impl From<Reg> for CastTarget {\n-    fn from(unit: Reg) -> CastTarget {\n-        CastTarget::from(Uniform::from(unit))\n-    }\n-}\n-\n-impl From<Uniform> for CastTarget {\n-    fn from(uniform: Uniform) -> CastTarget {\n-        CastTarget {\n-            prefix: [None; 8],\n-            prefix_chunk: Size::from_bytes(0),\n-            rest: uniform\n-        }\n-    }\n-}\n-\n-impl CastTarget {\n-    pub fn pair(a: Reg, b: Reg) -> CastTarget {\n-        CastTarget {\n-            prefix: [Some(a.kind), None, None, None, None, None, None, None],\n-            prefix_chunk: a.size,\n-            rest: Uniform::from(b)\n-        }\n-    }\n-\n-    pub fn size(&self, cx: &CodegenCx) -> Size {\n-        (self.prefix_chunk * self.prefix.iter().filter(|x| x.is_some()).count() as u64)\n-            .abi_align(self.rest.align(cx)) + self.rest.total\n-    }\n-\n-    pub fn align(&self, cx: &CodegenCx) -> Align {\n-        self.prefix.iter()\n-            .filter_map(|x| x.map(|kind| Reg { kind: kind, size: self.prefix_chunk }.align(cx)))\n-            .fold(cx.data_layout().aggregate_align.max(self.rest.align(cx)),\n-                |acc, align| acc.max(align))\n-    }\n-\n-    pub fn llvm_type(&self, cx: &CodegenCx) -> Type {\n+impl LlvmType for CastTarget {\n+    fn llvm_type(&self, cx: &CodegenCx) -> Type {\n         let rest_ll_unit = self.rest.unit.llvm_type(cx);\n         let rest_count = self.rest.total.bytes() / self.rest.unit.size.bytes();\n         let rem_bytes = self.rest.total.bytes() % self.rest.unit.size.bytes();"}, {"sha": "7594085488ff09c58fa59bb075f10c690a4f3d06", "filename": "src/librustc_trans/intrinsic.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3bd7efadae490bcf3434719dc97e649f93645901/src%2Flibrustc_trans%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3bd7efadae490bcf3434719dc97e649f93645901/src%2Flibrustc_trans%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fintrinsic.rs?ref=3bd7efadae490bcf3434719dc97e649f93645901", "patch": "@@ -13,7 +13,7 @@\n use intrinsics::{self, Intrinsic};\n use llvm;\n use llvm::{ValueRef};\n-use abi::{Abi, FnType, PassMode};\n+use abi::{Abi, FnType, LlvmType, PassMode};\n use mir::place::PlaceRef;\n use mir::operand::{OperandRef, OperandValue};\n use base::*;"}, {"sha": "2fa43e4440b4eb926ffd15cb9782e5f890a87629", "filename": "src/librustc_trans/lib.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3bd7efadae490bcf3434719dc97e649f93645901/src%2Flibrustc_trans%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3bd7efadae490bcf3434719dc97e649f93645901/src%2Flibrustc_trans%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Flib.rs?ref=3bd7efadae490bcf3434719dc97e649f93645901", "patch": "@@ -33,8 +33,6 @@\n use rustc::dep_graph::WorkProduct;\n use syntax_pos::symbol::Symbol;\n \n-#[macro_use]\n-extern crate bitflags;\n extern crate flate2;\n extern crate libc;\n #[macro_use] extern crate rustc;"}, {"sha": "973bd3d5baad6451c84a014154b082dcb1dd32c6", "filename": "src/librustc_trans/mir/block.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3bd7efadae490bcf3434719dc97e649f93645901/src%2Flibrustc_trans%2Fmir%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3bd7efadae490bcf3434719dc97e649f93645901/src%2Flibrustc_trans%2Fmir%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Fblock.rs?ref=3bd7efadae490bcf3434719dc97e649f93645901", "patch": "@@ -13,7 +13,7 @@ use rustc::middle::lang_items;\n use rustc::ty::{self, TypeFoldable};\n use rustc::ty::layout::{self, LayoutOf};\n use rustc::mir;\n-use abi::{Abi, FnType, ArgType, PassMode};\n+use abi::{Abi, FnType, ArgType, LlvmType, PassMode};\n use base;\n use callee;\n use builder::Builder;"}]}