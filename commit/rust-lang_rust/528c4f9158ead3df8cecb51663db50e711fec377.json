{"sha": "528c4f9158ead3df8cecb51663db50e711fec377", "node_id": "C_kwDOAAsO6NoAKDUyOGM0ZjkxNThlYWQzZGY4Y2VjYjUxNjYzZGI1MGU3MTFmZWMzNzc", "commit": {"author": {"name": "Amanieu d'Antras", "email": "amanieu@gmail.com", "date": "2021-12-18T23:43:46Z"}, "committer": {"name": "Amanieu d'Antras", "email": "amanieu@gmail.com", "date": "2022-01-17T00:39:28Z"}, "message": "Add PanicInfo::can_unwind which indicates whether a panic handler is\nallowed to trigger unwinding.", "tree": {"sha": "8a22999a5a1f57297f3d1e0d091b5cf91209dd94", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8a22999a5a1f57297f3d1e0d091b5cf91209dd94"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/528c4f9158ead3df8cecb51663db50e711fec377", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/528c4f9158ead3df8cecb51663db50e711fec377", "html_url": "https://github.com/rust-lang/rust/commit/528c4f9158ead3df8cecb51663db50e711fec377", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/528c4f9158ead3df8cecb51663db50e711fec377/comments", "author": {"login": "Amanieu", "id": 278509, "node_id": "MDQ6VXNlcjI3ODUwOQ==", "avatar_url": "https://avatars.githubusercontent.com/u/278509?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Amanieu", "html_url": "https://github.com/Amanieu", "followers_url": "https://api.github.com/users/Amanieu/followers", "following_url": "https://api.github.com/users/Amanieu/following{/other_user}", "gists_url": "https://api.github.com/users/Amanieu/gists{/gist_id}", "starred_url": "https://api.github.com/users/Amanieu/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Amanieu/subscriptions", "organizations_url": "https://api.github.com/users/Amanieu/orgs", "repos_url": "https://api.github.com/users/Amanieu/repos", "events_url": "https://api.github.com/users/Amanieu/events{/privacy}", "received_events_url": "https://api.github.com/users/Amanieu/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Amanieu", "id": 278509, "node_id": "MDQ6VXNlcjI3ODUwOQ==", "avatar_url": "https://avatars.githubusercontent.com/u/278509?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Amanieu", "html_url": "https://github.com/Amanieu", "followers_url": "https://api.github.com/users/Amanieu/followers", "following_url": "https://api.github.com/users/Amanieu/following{/other_user}", "gists_url": "https://api.github.com/users/Amanieu/gists{/gist_id}", "starred_url": "https://api.github.com/users/Amanieu/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Amanieu/subscriptions", "organizations_url": "https://api.github.com/users/Amanieu/orgs", "repos_url": "https://api.github.com/users/Amanieu/repos", "events_url": "https://api.github.com/users/Amanieu/events{/privacy}", "received_events_url": "https://api.github.com/users/Amanieu/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "bd3cb52565faab2755ff1bdb54d88bc91f47b4b9", "url": "https://api.github.com/repos/rust-lang/rust/commits/bd3cb52565faab2755ff1bdb54d88bc91f47b4b9", "html_url": "https://github.com/rust-lang/rust/commit/bd3cb52565faab2755ff1bdb54d88bc91f47b4b9"}], "stats": {"total": 41, "additions": 31, "deletions": 10}, "files": [{"sha": "405224f8fb0b095f03947a1f31020939c6ad9bd2", "filename": "library/core/src/panic/panic_info.rs", "status": "modified", "additions": 15, "deletions": 1, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/528c4f9158ead3df8cecb51663db50e711fec377/library%2Fcore%2Fsrc%2Fpanic%2Fpanic_info.rs", "raw_url": "https://github.com/rust-lang/rust/raw/528c4f9158ead3df8cecb51663db50e711fec377/library%2Fcore%2Fsrc%2Fpanic%2Fpanic_info.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fpanic%2Fpanic_info.rs?ref=528c4f9158ead3df8cecb51663db50e711fec377", "patch": "@@ -31,6 +31,7 @@ pub struct PanicInfo<'a> {\n     payload: &'a (dyn Any + Send),\n     message: Option<&'a fmt::Arguments<'a>>,\n     location: &'a Location<'a>,\n+    can_unwind: bool,\n }\n \n impl<'a> PanicInfo<'a> {\n@@ -44,9 +45,10 @@ impl<'a> PanicInfo<'a> {\n     pub fn internal_constructor(\n         message: Option<&'a fmt::Arguments<'a>>,\n         location: &'a Location<'a>,\n+        can_unwind: bool,\n     ) -> Self {\n         struct NoPayload;\n-        PanicInfo { location, message, payload: &NoPayload }\n+        PanicInfo { location, message, payload: &NoPayload, can_unwind }\n     }\n \n     #[unstable(\n@@ -127,6 +129,18 @@ impl<'a> PanicInfo<'a> {\n         // deal with that case in std::panicking::default_hook and core::panicking::panic_fmt.\n         Some(&self.location)\n     }\n+\n+    /// Returns whether the panic handler is allowed to unwind the stack from\n+    /// the point where the panic occurred.\n+    ///\n+    /// This is true for most kinds of panics with the exception of panics\n+    /// caused by trying to unwind out of a `Drop` implementation or a function\n+    /// whose ABI does not support unwinding.\n+    #[must_use]\n+    #[unstable(feature = \"panic_can_unwind\", issue = \"92988\")]\n+    pub fn can_unwind(&self) -> bool {\n+        self.can_unwind\n+    }\n }\n \n #[stable(feature = \"panic_hook_display\", since = \"1.26.0\")]"}, {"sha": "f260f19127b0b3cf8f9597ec91bb504f567f1ad3", "filename": "library/core/src/panicking.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/528c4f9158ead3df8cecb51663db50e711fec377/library%2Fcore%2Fsrc%2Fpanicking.rs", "raw_url": "https://github.com/rust-lang/rust/raw/528c4f9158ead3df8cecb51663db50e711fec377/library%2Fcore%2Fsrc%2Fpanicking.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fpanicking.rs?ref=528c4f9158ead3df8cecb51663db50e711fec377", "patch": "@@ -104,7 +104,7 @@ pub const fn panic_fmt(fmt: fmt::Arguments<'_>) -> ! {\n         fn panic_impl(pi: &PanicInfo<'_>) -> !;\n     }\n \n-    let pi = PanicInfo::internal_constructor(Some(&fmt), Location::caller());\n+    let pi = PanicInfo::internal_constructor(Some(&fmt), Location::caller(), true);\n \n     // SAFETY: `panic_impl` is defined in safe Rust code and thus is safe to call.\n     unsafe { panic_impl(&pi) }"}, {"sha": "0b2a864b7f746d673af6d5266b383b951f6077c4", "filename": "library/std/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/528c4f9158ead3df8cecb51663db50e711fec377/library%2Fstd%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/528c4f9158ead3df8cecb51663db50e711fec377/library%2Fstd%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Flib.rs?ref=528c4f9158ead3df8cecb51663db50e711fec377", "patch": "@@ -312,6 +312,7 @@\n #![feature(once_cell)]\n #![feature(panic_info_message)]\n #![feature(panic_internals)]\n+#![feature(panic_can_unwind)]\n #![feature(panic_unwind)]\n #![feature(pin_static_ref)]\n #![feature(portable_simd)]"}, {"sha": "c08d693f81a5f36989c1689bf430147c490d54b8", "filename": "library/std/src/panicking.rs", "status": "modified", "additions": 14, "deletions": 8, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/528c4f9158ead3df8cecb51663db50e711fec377/library%2Fstd%2Fsrc%2Fpanicking.rs", "raw_url": "https://github.com/rust-lang/rust/raw/528c4f9158ead3df8cecb51663db50e711fec377/library%2Fstd%2Fsrc%2Fpanicking.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fpanicking.rs?ref=528c4f9158ead3df8cecb51663db50e711fec377", "patch": "@@ -576,9 +576,14 @@ pub fn begin_panic_handler(info: &PanicInfo<'_>) -> ! {\n     let msg = info.message().unwrap(); // The current implementation always returns Some\n     crate::sys_common::backtrace::__rust_end_short_backtrace(move || {\n         if let Some(msg) = msg.as_str() {\n-            rust_panic_with_hook(&mut StrPanicPayload(msg), info.message(), loc);\n+            rust_panic_with_hook(&mut StrPanicPayload(msg), info.message(), loc, info.can_unwind());\n         } else {\n-            rust_panic_with_hook(&mut PanicPayload::new(msg), info.message(), loc);\n+            rust_panic_with_hook(\n+                &mut PanicPayload::new(msg),\n+                info.message(),\n+                loc,\n+                info.can_unwind(),\n+            );\n         }\n     })\n }\n@@ -602,7 +607,7 @@ pub const fn begin_panic<M: Any + Send>(msg: M) -> ! {\n \n     let loc = Location::caller();\n     return crate::sys_common::backtrace::__rust_end_short_backtrace(move || {\n-        rust_panic_with_hook(&mut PanicPayload::new(msg), None, loc)\n+        rust_panic_with_hook(&mut PanicPayload::new(msg), None, loc, true)\n     });\n \n     struct PanicPayload<A> {\n@@ -647,6 +652,7 @@ fn rust_panic_with_hook(\n     payload: &mut dyn BoxMeUp,\n     message: Option<&fmt::Arguments<'_>>,\n     location: &Location<'_>,\n+    can_unwind: bool,\n ) -> ! {\n     let (must_abort, panics) = panic_count::increase();\n \n@@ -663,14 +669,14 @@ fn rust_panic_with_hook(\n         } else {\n             // Unfortunately, this does not print a backtrace, because creating\n             // a `Backtrace` will allocate, which we must to avoid here.\n-            let panicinfo = PanicInfo::internal_constructor(message, location);\n+            let panicinfo = PanicInfo::internal_constructor(message, location, can_unwind);\n             rtprintpanic!(\"{}\\npanicked after panic::always_abort(), aborting.\\n\", panicinfo);\n         }\n-        intrinsics::abort()\n+        crate::sys::abort_internal();\n     }\n \n     unsafe {\n-        let mut info = PanicInfo::internal_constructor(message, location);\n+        let mut info = PanicInfo::internal_constructor(message, location, can_unwind);\n         let _guard = HOOK_LOCK.read();\n         match HOOK {\n             // Some platforms (like wasm) know that printing to stderr won't ever actually\n@@ -691,13 +697,13 @@ fn rust_panic_with_hook(\n         };\n     }\n \n-    if panics > 1 {\n+    if panics > 1 || !can_unwind {\n         // If a thread panics while it's already unwinding then we\n         // have limited options. Currently our preference is to\n         // just abort. In the future we may consider resuming\n         // unwinding or otherwise exiting the thread cleanly.\n         rtprintpanic!(\"thread panicked while panicking. aborting.\\n\");\n-        intrinsics::abort()\n+        crate::sys::abort_internal();\n     }\n \n     rust_panic(payload)"}]}