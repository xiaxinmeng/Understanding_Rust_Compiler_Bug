{"sha": "82b375b44d408e7ddd1e3b2c1e64b0bf0c4376d1", "node_id": "MDY6Q29tbWl0NzI0NzEyOjgyYjM3NWI0NGQ0MDhlN2RkZDFlM2IyYzFlNjRiMGJmMGM0Mzc2ZDE=", "commit": {"author": {"name": "Manish Goregaokar", "email": "manishsmail@gmail.com", "date": "2015-03-27T17:07:12Z"}, "committer": {"name": "Manish Goregaokar", "email": "manishsmail@gmail.com", "date": "2015-03-27T17:07:12Z"}, "message": "Rollup merge of #23738 - alexcrichton:snapshots, r=cmr", "tree": {"sha": "21a5333e58e0434e9310251d1bdbc9429ecfa7bf", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/21a5333e58e0434e9310251d1bdbc9429ecfa7bf"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/82b375b44d408e7ddd1e3b2c1e64b0bf0c4376d1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/82b375b44d408e7ddd1e3b2c1e64b0bf0c4376d1", "html_url": "https://github.com/rust-lang/rust/commit/82b375b44d408e7ddd1e3b2c1e64b0bf0c4376d1", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/82b375b44d408e7ddd1e3b2c1e64b0bf0c4376d1/comments", "author": {"login": "Manishearth", "id": 1617736, "node_id": "MDQ6VXNlcjE2MTc3MzY=", "avatar_url": "https://avatars.githubusercontent.com/u/1617736?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Manishearth", "html_url": "https://github.com/Manishearth", "followers_url": "https://api.github.com/users/Manishearth/followers", "following_url": "https://api.github.com/users/Manishearth/following{/other_user}", "gists_url": "https://api.github.com/users/Manishearth/gists{/gist_id}", "starred_url": "https://api.github.com/users/Manishearth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Manishearth/subscriptions", "organizations_url": "https://api.github.com/users/Manishearth/orgs", "repos_url": "https://api.github.com/users/Manishearth/repos", "events_url": "https://api.github.com/users/Manishearth/events{/privacy}", "received_events_url": "https://api.github.com/users/Manishearth/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Manishearth", "id": 1617736, "node_id": "MDQ6VXNlcjE2MTc3MzY=", "avatar_url": "https://avatars.githubusercontent.com/u/1617736?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Manishearth", "html_url": "https://github.com/Manishearth", "followers_url": "https://api.github.com/users/Manishearth/followers", "following_url": "https://api.github.com/users/Manishearth/following{/other_user}", "gists_url": "https://api.github.com/users/Manishearth/gists{/gist_id}", "starred_url": "https://api.github.com/users/Manishearth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Manishearth/subscriptions", "organizations_url": "https://api.github.com/users/Manishearth/orgs", "repos_url": "https://api.github.com/users/Manishearth/repos", "events_url": "https://api.github.com/users/Manishearth/events{/privacy}", "received_events_url": "https://api.github.com/users/Manishearth/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "242ed0b7c0f6a21096f2cc3e1ad1bdb176d02545", "url": "https://api.github.com/repos/rust-lang/rust/commits/242ed0b7c0f6a21096f2cc3e1ad1bdb176d02545", "html_url": "https://github.com/rust-lang/rust/commit/242ed0b7c0f6a21096f2cc3e1ad1bdb176d02545"}, {"sha": "36ef29abf7fa14dc9361d6b30ff7f8d18bfb4157", "url": "https://api.github.com/repos/rust-lang/rust/commits/36ef29abf7fa14dc9361d6b30ff7f8d18bfb4157", "html_url": "https://github.com/rust-lang/rust/commit/36ef29abf7fa14dc9361d6b30ff7f8d18bfb4157"}], "stats": {"total": 1191, "additions": 25, "deletions": 1166}, "files": [{"sha": "c5c58bb49ac361f34df30451b9badd02450acab9", "filename": "src/driver/driver.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/82b375b44d408e7ddd1e3b2c1e64b0bf0c4376d1/src%2Fdriver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/82b375b44d408e7ddd1e3b2c1e64b0bf0c4376d1/src%2Fdriver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdriver%2Fdriver.rs?ref=82b375b44d408e7ddd1e3b2c1e64b0bf0c4376d1", "patch": "@@ -12,9 +12,9 @@\n #![cfg_attr(rustdoc, feature(rustdoc))]\n \n #[cfg(rustdoc)]\n-extern crate \"rustdoc\" as this;\n+extern crate rustdoc as this;\n \n #[cfg(rustc)]\n-extern crate \"rustc_driver\" as this;\n+extern crate rustc_driver as this;\n \n fn main() { this::main() }"}, {"sha": "fcf8c8156944ca443c727d50c6a1aaa2e94ec64a", "filename": "src/libcollections/bit.rs", "status": "modified", "additions": 0, "deletions": 12, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/82b375b44d408e7ddd1e3b2c1e64b0bf0c4376d1/src%2Flibcollections%2Fbit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/82b375b44d408e7ddd1e3b2c1e64b0bf0c4376d1/src%2Flibcollections%2Fbit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fbit.rs?ref=82b375b44d408e7ddd1e3b2c1e64b0bf0c4376d1", "patch": "@@ -171,18 +171,6 @@ pub struct BitVec {\n impl Index<usize> for BitVec {\n     type Output = bool;\n \n-\n-    #[cfg(stage0)]\n-    #[inline]\n-    fn index(&self, i: &usize) -> &bool {\n-        if self.get(*i).expect(\"index out of bounds\") {\n-            &TRUE\n-        } else {\n-            &FALSE\n-        }\n-    }\n-\n-    #[cfg(not(stage0))]\n     #[inline]\n     fn index(&self, i: usize) -> &bool {\n         if self.get(i).expect(\"index out of bounds\") {"}, {"sha": "11407b5e496f68dffd9c57b870e18d3fce3e8b46", "filename": "src/libcollections/btree/map.rs", "status": "modified", "additions": 0, "deletions": 14, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/82b375b44d408e7ddd1e3b2c1e64b0bf0c4376d1/src%2Flibcollections%2Fbtree%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/82b375b44d408e7ddd1e3b2c1e64b0bf0c4376d1/src%2Flibcollections%2Fbtree%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fbtree%2Fmap.rs?ref=82b375b44d408e7ddd1e3b2c1e64b0bf0c4376d1", "patch": "@@ -915,20 +915,6 @@ impl<K: Debug, V: Debug> Debug for BTreeMap<K, V> {\n     }\n }\n \n-#[cfg(stage0)]\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<K: Ord, Q: ?Sized, V> Index<Q> for BTreeMap<K, V>\n-    where K: Borrow<Q>, Q: Ord\n-{\n-    type Output = V;\n-\n-    #[inline]\n-    fn index(&self, key: &Q) -> &V {\n-        self.get(key).expect(\"no entry found for key\")\n-    }\n-}\n-\n-#[cfg(not(stage0))]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, K: Ord, Q: ?Sized, V> Index<&'a Q> for BTreeMap<K, V>\n     where K: Borrow<Q>, Q: Ord"}, {"sha": "66f04d94ca131cf972c42e378968fe4cde5dd1f2", "filename": "src/libcollections/btree/node.rs", "status": "modified", "additions": 0, "deletions": 61, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/82b375b44d408e7ddd1e3b2c1e64b0bf0c4376d1/src%2Flibcollections%2Fbtree%2Fnode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/82b375b44d408e7ddd1e3b2c1e64b0bf0c4376d1/src%2Flibcollections%2Fbtree%2Fnode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fbtree%2Fnode.rs?ref=82b375b44d408e7ddd1e3b2c1e64b0bf0c4376d1", "patch": "@@ -1524,36 +1524,6 @@ macro_rules! node_slice_impl {\n             }\n \n             /// Returns a sub-slice with elements starting with `min_key`.\n-            #[cfg(stage0)]\n-            pub fn slice_from(self, min_key: &K) -> $NodeSlice<'a, K, V> {\n-                //  _______________\n-                // |_1_|_3_|_5_|_7_|\n-                // |   |   |   |   |\n-                // 0 0 1 1 2 2 3 3 4  index\n-                // |   |   |   |   |\n-                // \\___|___|___|___/  slice_from(&0); pos = 0\n-                //     \\___|___|___/  slice_from(&2); pos = 1\n-                //     |___|___|___/  slice_from(&3); pos = 1; result.head_is_edge = false\n-                //         \\___|___/  slice_from(&4); pos = 2\n-                //             \\___/  slice_from(&6); pos = 3\n-                //                \\|/ slice_from(&999); pos = 4\n-                let (pos, pos_is_kv) = self.search_linear(min_key);\n-                $NodeSlice {\n-                    has_edges: self.has_edges,\n-                    edges: if !self.has_edges {\n-                        self.edges\n-                    } else {\n-                        self.edges.$index(&(pos ..))\n-                    },\n-                    keys: &self.keys[pos ..],\n-                    vals: self.vals.$index(&(pos ..)),\n-                    head_is_edge: !pos_is_kv,\n-                    tail_is_edge: self.tail_is_edge,\n-                }\n-            }\n-\n-            /// Returns a sub-slice with elements starting with `min_key`.\n-            #[cfg(not(stage0))]\n             pub fn slice_from(self, min_key: &K) -> $NodeSlice<'a, K, V> {\n                 //  _______________\n                 // |_1_|_3_|_5_|_7_|\n@@ -1582,37 +1552,6 @@ macro_rules! node_slice_impl {\n             }\n \n             /// Returns a sub-slice with elements up to and including `max_key`.\n-            #[cfg(stage0)]\n-            pub fn slice_to(self, max_key: &K) -> $NodeSlice<'a, K, V> {\n-                //  _______________\n-                // |_1_|_3_|_5_|_7_|\n-                // |   |   |   |   |\n-                // 0 0 1 1 2 2 3 3 4  index\n-                // |   |   |   |   |\n-                //\\|/  |   |   |   |  slice_to(&0); pos = 0\n-                // \\___/   |   |   |  slice_to(&2); pos = 1\n-                // \\___|___|   |   |  slice_to(&3); pos = 1; result.tail_is_edge = false\n-                // \\___|___/   |   |  slice_to(&4); pos = 2\n-                // \\___|___|___/   |  slice_to(&6); pos = 3\n-                // \\___|___|___|___/  slice_to(&999); pos = 4\n-                let (pos, pos_is_kv) = self.search_linear(max_key);\n-                let pos = pos + if pos_is_kv { 1 } else { 0 };\n-                $NodeSlice {\n-                    has_edges: self.has_edges,\n-                    edges: if !self.has_edges {\n-                        self.edges\n-                    } else {\n-                        self.edges.$index(&(.. (pos + 1)))\n-                    },\n-                    keys: &self.keys[..pos],\n-                    vals: self.vals.$index(&(.. pos)),\n-                    head_is_edge: self.head_is_edge,\n-                    tail_is_edge: !pos_is_kv,\n-                }\n-            }\n-\n-            /// Returns a sub-slice with elements up to and including `max_key`.\n-            #[cfg(not(stage0))]\n             pub fn slice_to(self, max_key: &K) -> $NodeSlice<'a, K, V> {\n                 //  _______________\n                 // |_1_|_3_|_5_|_7_|"}, {"sha": "7131c1cd881b4ccf95ed043e792566279d95d388", "filename": "src/libcollections/string.rs", "status": "modified", "additions": 0, "deletions": 28, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/82b375b44d408e7ddd1e3b2c1e64b0bf0c4376d1/src%2Flibcollections%2Fstring.rs", "raw_url": "https://github.com/rust-lang/rust/raw/82b375b44d408e7ddd1e3b2c1e64b0bf0c4376d1/src%2Flibcollections%2Fstring.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fstring.rs?ref=82b375b44d408e7ddd1e3b2c1e64b0bf0c4376d1", "patch": "@@ -903,13 +903,6 @@ impl<'a> Add<&'a str> for String {\n impl ops::Index<ops::Range<usize>> for String {\n     type Output = str;\n \n-    #[cfg(stage0)]\n-    #[inline]\n-    fn index(&self, index: &ops::Range<usize>) -> &str {\n-        &self[..][*index]\n-    }\n-\n-    #[cfg(not(stage0))]\n     #[inline]\n     fn index(&self, index: ops::Range<usize>) -> &str {\n         &self[..][index]\n@@ -919,13 +912,6 @@ impl ops::Index<ops::Range<usize>> for String {\n impl ops::Index<ops::RangeTo<usize>> for String {\n     type Output = str;\n \n-    #[cfg(stage0)]\n-    #[inline]\n-    fn index(&self, index: &ops::RangeTo<usize>) -> &str {\n-        &self[..][*index]\n-    }\n-\n-    #[cfg(not(stage0))]\n     #[inline]\n     fn index(&self, index: ops::RangeTo<usize>) -> &str {\n         &self[..][index]\n@@ -935,13 +921,6 @@ impl ops::Index<ops::RangeTo<usize>> for String {\n impl ops::Index<ops::RangeFrom<usize>> for String {\n     type Output = str;\n \n-    #[cfg(stage0)]\n-    #[inline]\n-    fn index(&self, index: &ops::RangeFrom<usize>) -> &str {\n-        &self[..][*index]\n-    }\n-\n-    #[cfg(not(stage0))]\n     #[inline]\n     fn index(&self, index: ops::RangeFrom<usize>) -> &str {\n         &self[..][index]\n@@ -951,13 +930,6 @@ impl ops::Index<ops::RangeFrom<usize>> for String {\n impl ops::Index<ops::RangeFull> for String {\n     type Output = str;\n \n-    #[cfg(stage0)]\n-    #[inline]\n-    fn index(&self, _index: &ops::RangeFull) -> &str {\n-        unsafe { mem::transmute(&*self.vec) }\n-    }\n-\n-    #[cfg(not(stage0))]\n     #[inline]\n     fn index(&self, _index: ops::RangeFull) -> &str {\n         unsafe { mem::transmute(&*self.vec) }"}, {"sha": "ee528255ae7a5e931829b2865de1c3ecf1d97aff", "filename": "src/libcollections/vec.rs", "status": "modified", "additions": 0, "deletions": 74, "changes": 74, "blob_url": "https://github.com/rust-lang/rust/blob/82b375b44d408e7ddd1e3b2c1e64b0bf0c4376d1/src%2Flibcollections%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/82b375b44d408e7ddd1e3b2c1e64b0bf0c4376d1/src%2Flibcollections%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fvec.rs?ref=82b375b44d408e7ddd1e3b2c1e64b0bf0c4376d1", "patch": "@@ -1343,15 +1343,6 @@ impl<T: Hash> Hash for Vec<T> {\n impl<T> Index<usize> for Vec<T> {\n     type Output = T;\n \n-\n-    #[cfg(stage0)]\n-    #[inline]\n-    fn index(&self, index: &usize) -> &T {\n-        // NB built-in indexing via `&[T]`\n-        &(**self)[*index]\n-    }\n-\n-    #[cfg(not(stage0))]\n     #[inline]\n     fn index(&self, index: usize) -> &T {\n         // NB built-in indexing via `&[T]`\n@@ -1361,15 +1352,6 @@ impl<T> Index<usize> for Vec<T> {\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T> IndexMut<usize> for Vec<T> {\n-\n-    #[cfg(stage0)]\n-    #[inline]\n-    fn index_mut(&mut self, index: &usize) -> &mut T {\n-        // NB built-in indexing via `&mut [T]`\n-        &mut (**self)[*index]\n-    }\n-\n-    #[cfg(not(stage0))]\n     #[inline]\n     fn index_mut(&mut self, index: usize) -> &mut T {\n         // NB built-in indexing via `&mut [T]`\n@@ -1382,13 +1364,6 @@ impl<T> IndexMut<usize> for Vec<T> {\n impl<T> ops::Index<ops::Range<usize>> for Vec<T> {\n     type Output = [T];\n \n-    #[cfg(stage0)]\n-    #[inline]\n-    fn index(&self, index: &ops::Range<usize>) -> &[T] {\n-        Index::index(&**self, index)\n-    }\n-\n-    #[cfg(not(stage0))]\n     #[inline]\n     fn index(&self, index: ops::Range<usize>) -> &[T] {\n         Index::index(&**self, index)\n@@ -1398,13 +1373,6 @@ impl<T> ops::Index<ops::Range<usize>> for Vec<T> {\n impl<T> ops::Index<ops::RangeTo<usize>> for Vec<T> {\n     type Output = [T];\n \n-    #[cfg(stage0)]\n-    #[inline]\n-    fn index(&self, index: &ops::RangeTo<usize>) -> &[T] {\n-        Index::index(&**self, index)\n-    }\n-\n-    #[cfg(not(stage0))]\n     #[inline]\n     fn index(&self, index: ops::RangeTo<usize>) -> &[T] {\n         Index::index(&**self, index)\n@@ -1414,13 +1382,6 @@ impl<T> ops::Index<ops::RangeTo<usize>> for Vec<T> {\n impl<T> ops::Index<ops::RangeFrom<usize>> for Vec<T> {\n     type Output = [T];\n \n-    #[cfg(stage0)]\n-    #[inline]\n-    fn index(&self, index: &ops::RangeFrom<usize>) -> &[T] {\n-        Index::index(&**self, index)\n-    }\n-\n-    #[cfg(not(stage0))]\n     #[inline]\n     fn index(&self, index: ops::RangeFrom<usize>) -> &[T] {\n         Index::index(&**self, index)\n@@ -1430,13 +1391,6 @@ impl<T> ops::Index<ops::RangeFrom<usize>> for Vec<T> {\n impl<T> ops::Index<ops::RangeFull> for Vec<T> {\n     type Output = [T];\n \n-    #[cfg(stage0)]\n-    #[inline]\n-    fn index(&self, _index: &ops::RangeFull) -> &[T] {\n-        self\n-    }\n-\n-    #[cfg(not(stage0))]\n     #[inline]\n     fn index(&self, _index: ops::RangeFull) -> &[T] {\n         self\n@@ -1446,13 +1400,6 @@ impl<T> ops::Index<ops::RangeFull> for Vec<T> {\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T> ops::IndexMut<ops::Range<usize>> for Vec<T> {\n \n-    #[cfg(stage0)]\n-    #[inline]\n-    fn index_mut(&mut self, index: &ops::Range<usize>) -> &mut [T] {\n-        IndexMut::index_mut(&mut **self, index)\n-    }\n-\n-    #[cfg(not(stage0))]\n     #[inline]\n     fn index_mut(&mut self, index: ops::Range<usize>) -> &mut [T] {\n         IndexMut::index_mut(&mut **self, index)\n@@ -1461,13 +1408,6 @@ impl<T> ops::IndexMut<ops::Range<usize>> for Vec<T> {\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T> ops::IndexMut<ops::RangeTo<usize>> for Vec<T> {\n \n-    #[cfg(stage0)]\n-    #[inline]\n-    fn index_mut(&mut self, index: &ops::RangeTo<usize>) -> &mut [T] {\n-        IndexMut::index_mut(&mut **self, index)\n-    }\n-\n-    #[cfg(not(stage0))]\n     #[inline]\n     fn index_mut(&mut self, index: ops::RangeTo<usize>) -> &mut [T] {\n         IndexMut::index_mut(&mut **self, index)\n@@ -1476,13 +1416,6 @@ impl<T> ops::IndexMut<ops::RangeTo<usize>> for Vec<T> {\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T> ops::IndexMut<ops::RangeFrom<usize>> for Vec<T> {\n \n-    #[cfg(stage0)]\n-    #[inline]\n-    fn index_mut(&mut self, index: &ops::RangeFrom<usize>) -> &mut [T] {\n-        IndexMut::index_mut(&mut **self, index)\n-    }\n-\n-    #[cfg(not(stage0))]\n     #[inline]\n     fn index_mut(&mut self, index: ops::RangeFrom<usize>) -> &mut [T] {\n         IndexMut::index_mut(&mut **self, index)\n@@ -1491,13 +1424,6 @@ impl<T> ops::IndexMut<ops::RangeFrom<usize>> for Vec<T> {\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T> ops::IndexMut<ops::RangeFull> for Vec<T> {\n \n-    #[cfg(stage0)]\n-    #[inline]\n-    fn index_mut(&mut self, _index: &ops::RangeFull) -> &mut [T] {\n-        self.as_mut_slice()\n-    }\n-\n-    #[cfg(not(stage0))]\n     #[inline]\n     fn index_mut(&mut self, _index: ops::RangeFull) -> &mut [T] {\n         self.as_mut_slice()"}, {"sha": "f5702be2f4588ccb84220b80bf62cc439d764ce1", "filename": "src/libcollections/vec_deque.rs", "status": "modified", "additions": 0, "deletions": 14, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/82b375b44d408e7ddd1e3b2c1e64b0bf0c4376d1/src%2Flibcollections%2Fvec_deque.rs", "raw_url": "https://github.com/rust-lang/rust/raw/82b375b44d408e7ddd1e3b2c1e64b0bf0c4376d1/src%2Flibcollections%2Fvec_deque.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fvec_deque.rs?ref=82b375b44d408e7ddd1e3b2c1e64b0bf0c4376d1", "patch": "@@ -1705,13 +1705,6 @@ impl<A: Hash> Hash for VecDeque<A> {\n impl<A> Index<usize> for VecDeque<A> {\n     type Output = A;\n \n-    #[cfg(stage0)]\n-    #[inline]\n-    fn index(&self, i: &usize) -> &A {\n-        self.get(*i).expect(\"Out of bounds access\")\n-    }\n-\n-    #[cfg(not(stage0))]\n     #[inline]\n     fn index(&self, i: usize) -> &A {\n         self.get(i).expect(\"Out of bounds access\")\n@@ -1720,13 +1713,6 @@ impl<A> Index<usize> for VecDeque<A> {\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<A> IndexMut<usize> for VecDeque<A> {\n-    #[cfg(stage0)]\n-    #[inline]\n-    fn index_mut(&mut self, i: &usize) -> &mut A {\n-        self.get_mut(*i).expect(\"Out of bounds access\")\n-    }\n-\n-    #[cfg(not(stage0))]\n     #[inline]\n     fn index_mut(&mut self, i: usize) -> &mut A {\n         self.get_mut(i).expect(\"Out of bounds access\")"}, {"sha": "8900c7950458220f70c12816a5ea1d9995d15b60", "filename": "src/libcollections/vec_map.rs", "status": "modified", "additions": 0, "deletions": 23, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/82b375b44d408e7ddd1e3b2c1e64b0bf0c4376d1/src%2Flibcollections%2Fvec_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/82b375b44d408e7ddd1e3b2c1e64b0bf0c4376d1/src%2Flibcollections%2Fvec_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fvec_map.rs?ref=82b375b44d408e7ddd1e3b2c1e64b0bf0c4376d1", "patch": "@@ -836,17 +836,6 @@ impl<V> Extend<(usize, V)> for VecMap<V> {\n     }\n }\n \n-#[cfg(stage0)]\n-impl<V> Index<usize> for VecMap<V> {\n-    type Output = V;\n-\n-    #[inline]\n-    fn index<'a>(&'a self, i: &usize) -> &'a V {\n-        self.get(i).expect(\"key not present\")\n-    }\n-}\n-\n-#[cfg(not(stage0))]\n impl<V> Index<usize> for VecMap<V> {\n     type Output = V;\n \n@@ -856,7 +845,6 @@ impl<V> Index<usize> for VecMap<V> {\n     }\n }\n \n-#[cfg(not(stage0))]\n impl<'a,V> Index<&'a usize> for VecMap<V> {\n     type Output = V;\n \n@@ -866,16 +854,6 @@ impl<'a,V> Index<&'a usize> for VecMap<V> {\n     }\n }\n \n-#[cfg(stage0)]\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<V> IndexMut<usize> for VecMap<V> {\n-    #[inline]\n-    fn index_mut(&mut self, i: &usize) -> &mut V {\n-        self.get_mut(&i).expect(\"key not present\")\n-    }\n-}\n-\n-#[cfg(not(stage0))]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<V> IndexMut<usize> for VecMap<V> {\n     #[inline]\n@@ -884,7 +862,6 @@ impl<V> IndexMut<usize> for VecMap<V> {\n     }\n }\n \n-#[cfg(not(stage0))]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, V> IndexMut<&'a usize> for VecMap<V> {\n     #[inline]"}, {"sha": "211b0152c33cecbc37ead2b97c803ac2a1fdcda0", "filename": "src/libcore/intrinsics.rs", "status": "modified", "additions": 0, "deletions": 23, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/82b375b44d408e7ddd1e3b2c1e64b0bf0c4376d1/src%2Flibcore%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/82b375b44d408e7ddd1e3b2c1e64b0bf0c4376d1/src%2Flibcore%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fintrinsics.rs?ref=82b375b44d408e7ddd1e3b2c1e64b0bf0c4376d1", "patch": "@@ -44,10 +44,6 @@\n \n use marker::Sized;\n \n-#[cfg(stage0)] pub use self::copy_memory as copy;\n-#[cfg(stage0)] pub use self::set_memory as write_bytes;\n-#[cfg(stage0)] pub use self::copy_nonoverlapping_memory as copy_nonoverlapping;\n-\n extern \"rust-intrinsic\" {\n \n     // NB: These intrinsics take unsafe pointers because they mutate aliased\n@@ -183,7 +179,6 @@ extern \"rust-intrinsic\" {\n     pub fn pref_align_of<T>() -> usize;\n \n     /// Gets a static string slice containing the name of a type.\n-    #[cfg(not(stage0))]\n     pub fn type_name<T: ?Sized>() -> &'static str;\n \n     /// Gets an identifier which is globally unique to the specified type. This\n@@ -287,14 +282,8 @@ extern \"rust-intrinsic\" {\n     /// }\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    #[cfg(not(stage0))]\n     pub fn copy_nonoverlapping<T>(dst: *mut T, src: *const T, count: usize);\n \n-    /// dox\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    #[cfg(stage0)]\n-    pub fn copy_nonoverlapping_memory<T>(dst: *mut T, src: *const T, count: usize);\n-\n     /// Copies `count * size_of<T>` bytes from `src` to `dst`. The source\n     /// and destination may overlap.\n     ///\n@@ -323,26 +312,14 @@ extern \"rust-intrinsic\" {\n     /// }\n     /// ```\n     ///\n-    #[cfg(not(stage0))]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn copy<T>(dst: *mut T, src: *const T, count: usize);\n \n-    /// dox\n-    #[cfg(stage0)]\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn copy_memory<T>(dst: *mut T, src: *const T, count: usize);\n-\n     /// Invokes memset on the specified pointer, setting `count * size_of::<T>()`\n     /// bytes of memory starting at `dst` to `c`.\n-    #[cfg(not(stage0))]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn write_bytes<T>(dst: *mut T, val: u8, count: usize);\n \n-    /// dox\n-    #[cfg(stage0)]\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn set_memory<T>(dst: *mut T, val: u8, count: usize);\n-\n     /// Equivalent to the appropriate `llvm.memcpy.p0i8.0i8.*` intrinsic, with\n     /// a size of `count` * `size_of::<T>()` and an alignment of\n     /// `min_align_of::<T>()`"}, {"sha": "26deb80d8c51fb02e4f240193a145e5366301c1e", "filename": "src/libcore/ops.rs", "status": "modified", "additions": 0, "deletions": 62, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/82b375b44d408e7ddd1e3b2c1e64b0bf0c4376d1/src%2Flibcore%2Fops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/82b375b44d408e7ddd1e3b2c1e64b0bf0c4376d1/src%2Flibcore%2Fops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fops.rs?ref=82b375b44d408e7ddd1e3b2c1e64b0bf0c4376d1", "patch": "@@ -917,12 +917,6 @@ pub trait Index<Idx: ?Sized> {\n     type Output: ?Sized;\n \n     /// The method for the indexing (`Foo[Bar]`) operation\n-    #[cfg(stage0)]\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    fn index<'a>(&'a self, index: &Idx) -> &'a Self::Output;\n-\n-    /// The method for the indexing (`Foo[Bar]`) operation\n-    #[cfg(not(stage0))]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn index<'a>(&'a self, index: Idx) -> &'a Self::Output;\n }\n@@ -966,12 +960,6 @@ pub trait Index<Idx: ?Sized> {\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub trait IndexMut<Idx: ?Sized>: Index<Idx> {\n     /// The method for the indexing (`Foo[Bar]`) operation\n-    #[cfg(stage0)]\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    fn index_mut<'a>(&'a mut self, index: &Idx) -> &'a mut Self::Output;\n-\n-    /// The method for the indexing (`Foo[Bar]`) operation\n-    #[cfg(not(stage0))]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn index_mut<'a>(&'a mut self, index: Idx) -> &'a mut Self::Output;\n }\n@@ -1149,20 +1137,6 @@ impl<'a, T: ?Sized> DerefMut for &'a mut T {\n #[lang=\"fn\"]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[rustc_paren_sugar]\n-#[cfg(stage0)]\n-pub trait Fn<Args> {\n-    /// The returned type after the call operator is used.\n-    type Output;\n-\n-    /// This is called when the call operator is used.\n-    extern \"rust-call\" fn call(&self, args: Args) -> Self::Output;\n-}\n-\n-/// A version of the call operator that takes an immutable receiver.\n-#[lang=\"fn\"]\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-#[rustc_paren_sugar]\n-#[cfg(not(stage0))]\n pub trait Fn<Args> : FnMut<Args> {\n     /// This is called when the call operator is used.\n     extern \"rust-call\" fn call(&self, args: Args) -> Self::Output;\n@@ -1172,20 +1146,6 @@ pub trait Fn<Args> : FnMut<Args> {\n #[lang=\"fn_mut\"]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[rustc_paren_sugar]\n-#[cfg(stage0)]\n-pub trait FnMut<Args> {\n-    /// The returned type after the call operator is used.\n-    type Output;\n-\n-    /// This is called when the call operator is used.\n-    extern \"rust-call\" fn call_mut(&mut self, args: Args) -> Self::Output;\n-}\n-\n-/// A version of the call operator that takes a mutable receiver.\n-#[lang=\"fn_mut\"]\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-#[rustc_paren_sugar]\n-#[cfg(not(stage0))]\n pub trait FnMut<Args> : FnOnce<Args> {\n     /// This is called when the call operator is used.\n     extern \"rust-call\" fn call_mut(&mut self, args: Args) -> Self::Output;\n@@ -1202,25 +1162,3 @@ pub trait FnOnce<Args> {\n     /// This is called when the call operator is used.\n     extern \"rust-call\" fn call_once(self, args: Args) -> Self::Output;\n }\n-\n-#[cfg(stage0)]\n-impl<F: ?Sized, A> FnMut<A> for F\n-    where F : Fn<A>\n-{\n-    type Output = <F as Fn<A>>::Output;\n-\n-    extern \"rust-call\" fn call_mut(&mut self, args: A) -> <F as Fn<A>>::Output {\n-        self.call(args)\n-    }\n-}\n-\n-#[cfg(stage0)]\n-impl<F,A> FnOnce<A> for F\n-    where F : FnMut<A>\n-{\n-    type Output = <F as FnMut<A>>::Output;\n-\n-    extern \"rust-call\" fn call_once(mut self, args: A) -> <F as FnMut<A>>::Output {\n-        self.call_mut(args)\n-    }\n-}"}, {"sha": "d5e8b4ce81e5ceec9bc2a4238dbfe54c72f1454a", "filename": "src/libcore/slice.rs", "status": "modified", "additions": 0, "deletions": 185, "changes": 185, "blob_url": "https://github.com/rust-lang/rust/blob/82b375b44d408e7ddd1e3b2c1e64b0bf0c4376d1/src%2Flibcore%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/82b375b44d408e7ddd1e3b2c1e64b0bf0c4376d1/src%2Flibcore%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fslice.rs?ref=82b375b44d408e7ddd1e3b2c1e64b0bf0c4376d1", "patch": "@@ -263,18 +263,6 @@ impl<T> SliceExt for [T] {\n     #[inline]\n     fn as_mut_slice(&mut self) -> &mut [T] { self }\n \n-    #[cfg(stage0)]\n-    #[inline]\n-    fn split_at_mut(&mut self, mid: usize) -> (&mut [T], &mut [T]) {\n-        unsafe {\n-            let self2: &mut [T] = mem::transmute_copy(&self);\n-\n-            (ops::IndexMut::index_mut(self, &ops::RangeTo { end: mid } ),\n-             ops::IndexMut::index_mut(self2, &ops::RangeFrom { start: mid } ))\n-        }\n-    }\n-\n-    #[cfg(not(stage0))]\n     #[inline]\n     fn split_at_mut(&mut self, mid: usize) -> (&mut [T], &mut [T]) {\n         unsafe {\n@@ -507,14 +495,6 @@ impl<T> SliceExt for [T] {\n impl<T> ops::Index<usize> for [T] {\n     type Output = T;\n \n-    #[cfg(stage0)]\n-    fn index(&self, &index: &usize) -> &T {\n-        assert!(index < self.len());\n-\n-        unsafe { mem::transmute(self.repr().data.offset(index as isize)) }\n-    }\n-\n-    #[cfg(not(stage0))]\n     fn index(&self, index: usize) -> &T {\n         assert!(index < self.len());\n \n@@ -524,15 +504,6 @@ impl<T> ops::Index<usize> for [T] {\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T> ops::IndexMut<usize> for [T] {\n-    #[cfg(stage0)]\n-    #[inline]\n-    fn index_mut(&mut self, &index: &usize) -> &mut T {\n-        assert!(index < self.len());\n-\n-        unsafe { mem::transmute(self.repr().data.offset(index as isize)) }\n-    }\n-\n-    #[cfg(not(stage0))]\n     #[inline]\n     fn index_mut(&mut self, index: usize) -> &mut T {\n         assert!(index < self.len());\n@@ -545,20 +516,6 @@ impl<T> ops::IndexMut<usize> for [T] {\n impl<T> ops::Index<ops::Range<usize>> for [T] {\n     type Output = [T];\n \n-    #[cfg(stage0)]\n-    #[inline]\n-    fn index(&self, index: &ops::Range<usize>) -> &[T] {\n-        assert!(index.start <= index.end);\n-        assert!(index.end <= self.len());\n-        unsafe {\n-            from_raw_parts (\n-                self.as_ptr().offset(index.start as isize),\n-                index.end - index.start\n-            )\n-        }\n-    }\n-\n-    #[cfg(not(stage0))]\n     #[inline]\n     fn index(&self, index: ops::Range<usize>) -> &[T] {\n         assert!(index.start <= index.end);\n@@ -575,13 +532,6 @@ impl<T> ops::Index<ops::Range<usize>> for [T] {\n impl<T> ops::Index<ops::RangeTo<usize>> for [T] {\n     type Output = [T];\n \n-    #[cfg(stage0)]\n-    #[inline]\n-    fn index(&self, index: &ops::RangeTo<usize>) -> &[T] {\n-        self.index(&ops::Range{ start: 0, end: index.end })\n-    }\n-\n-    #[cfg(not(stage0))]\n     #[inline]\n     fn index(&self, index: ops::RangeTo<usize>) -> &[T] {\n         self.index(ops::Range{ start: 0, end: index.end })\n@@ -591,13 +541,6 @@ impl<T> ops::Index<ops::RangeTo<usize>> for [T] {\n impl<T> ops::Index<ops::RangeFrom<usize>> for [T] {\n     type Output = [T];\n \n-    #[cfg(stage0)]\n-    #[inline]\n-    fn index(&self, index: &ops::RangeFrom<usize>) -> &[T] {\n-        self.index(&ops::Range{ start: index.start, end: self.len() })\n-    }\n-\n-    #[cfg(not(stage0))]\n     #[inline]\n     fn index(&self, index: ops::RangeFrom<usize>) -> &[T] {\n         self.index(ops::Range{ start: index.start, end: self.len() })\n@@ -607,13 +550,6 @@ impl<T> ops::Index<ops::RangeFrom<usize>> for [T] {\n impl<T> ops::Index<RangeFull> for [T] {\n     type Output = [T];\n \n-    #[cfg(stage0)]\n-    #[inline]\n-    fn index(&self, _index: &RangeFull) -> &[T] {\n-        self\n-    }\n-\n-    #[cfg(not(stage0))]\n     #[inline]\n     fn index(&self, _index: RangeFull) -> &[T] {\n         self\n@@ -622,20 +558,6 @@ impl<T> ops::Index<RangeFull> for [T] {\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T> ops::IndexMut<ops::Range<usize>> for [T] {\n-    #[cfg(stage0)]\n-    #[inline]\n-    fn index_mut(&mut self, index: &ops::Range<usize>) -> &mut [T] {\n-        assert!(index.start <= index.end);\n-        assert!(index.end <= self.len());\n-        unsafe {\n-            from_raw_parts_mut(\n-                self.as_mut_ptr().offset(index.start as isize),\n-                index.end - index.start\n-            )\n-        }\n-    }\n-\n-    #[cfg(not(stage0))]\n     #[inline]\n     fn index_mut(&mut self, index: ops::Range<usize>) -> &mut [T] {\n         assert!(index.start <= index.end);\n@@ -650,28 +572,13 @@ impl<T> ops::IndexMut<ops::Range<usize>> for [T] {\n }\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T> ops::IndexMut<ops::RangeTo<usize>> for [T] {\n-    #[cfg(stage0)]\n-    #[inline]\n-    fn index_mut(&mut self, index: &ops::RangeTo<usize>) -> &mut [T] {\n-        self.index_mut(&ops::Range{ start: 0, end: index.end })\n-    }\n-\n-    #[cfg(not(stage0))]\n     #[inline]\n     fn index_mut(&mut self, index: ops::RangeTo<usize>) -> &mut [T] {\n         self.index_mut(ops::Range{ start: 0, end: index.end })\n     }\n }\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T> ops::IndexMut<ops::RangeFrom<usize>> for [T] {\n-    #[cfg(stage0)]\n-    #[inline]\n-    fn index_mut(&mut self, index: &ops::RangeFrom<usize>) -> &mut [T] {\n-        let len = self.len();\n-        self.index_mut(&ops::Range{ start: index.start, end: len })\n-    }\n-\n-    #[cfg(not(stage0))]\n     #[inline]\n     fn index_mut(&mut self, index: ops::RangeFrom<usize>) -> &mut [T] {\n         let len = self.len();\n@@ -680,14 +587,6 @@ impl<T> ops::IndexMut<ops::RangeFrom<usize>> for [T] {\n }\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T> ops::IndexMut<RangeFull> for [T] {\n-\n-    #[cfg(stage0)]\n-    #[inline]\n-    fn index_mut(&mut self, _index: &RangeFull) -> &mut [T] {\n-        self\n-    }\n-\n-    #[cfg(not(stage0))]\n     #[inline]\n     fn index_mut(&mut self, _index: RangeFull) -> &mut [T] {\n         self\n@@ -875,13 +774,6 @@ unsafe impl<'a, T: Sync> Send for Iter<'a, T> {}\n impl<'a, T> ops::Index<ops::Range<usize>> for Iter<'a, T> {\n     type Output = [T];\n \n-    #[cfg(stage0)]\n-    #[inline]\n-    fn index(&self, index: &ops::Range<usize>) -> &[T] {\n-        self.as_slice().index(index)\n-    }\n-\n-    #[cfg(not(stage0))]\n     #[inline]\n     fn index(&self, index: ops::Range<usize>) -> &[T] {\n         self.as_slice().index(index)\n@@ -892,13 +784,6 @@ impl<'a, T> ops::Index<ops::Range<usize>> for Iter<'a, T> {\n impl<'a, T> ops::Index<ops::RangeTo<usize>> for Iter<'a, T> {\n     type Output = [T];\n \n-    #[cfg(stage0)]\n-    #[inline]\n-    fn index(&self, index: &ops::RangeTo<usize>) -> &[T] {\n-        self.as_slice().index(index)\n-    }\n-\n-    #[cfg(not(stage0))]\n     #[inline]\n     fn index(&self, index: ops::RangeTo<usize>) -> &[T] {\n         self.as_slice().index(index)\n@@ -909,13 +794,6 @@ impl<'a, T> ops::Index<ops::RangeTo<usize>> for Iter<'a, T> {\n impl<'a, T> ops::Index<ops::RangeFrom<usize>> for Iter<'a, T> {\n     type Output = [T];\n \n-    #[cfg(stage0)]\n-    #[inline]\n-    fn index(&self, index: &ops::RangeFrom<usize>) -> &[T] {\n-        self.as_slice().index(index)\n-    }\n-\n-    #[cfg(not(stage0))]\n     #[inline]\n     fn index(&self, index: ops::RangeFrom<usize>) -> &[T] {\n         self.as_slice().index(index)\n@@ -926,13 +804,6 @@ impl<'a, T> ops::Index<ops::RangeFrom<usize>> for Iter<'a, T> {\n impl<'a, T> ops::Index<RangeFull> for Iter<'a, T> {\n     type Output = [T];\n \n-    #[cfg(stage0)]\n-    #[inline]\n-    fn index(&self, _index: &RangeFull) -> &[T] {\n-        self.as_slice()\n-    }\n-\n-    #[cfg(not(stage0))]\n     #[inline]\n     fn index(&self, _index: RangeFull) -> &[T] {\n         self.as_slice()\n@@ -1000,13 +871,6 @@ unsafe impl<'a, T: Send> Send for IterMut<'a, T> {}\n impl<'a, T> ops::Index<ops::Range<usize>> for IterMut<'a, T> {\n     type Output = [T];\n \n-    #[cfg(stage0)]\n-    #[inline]\n-    fn index(&self, index: &ops::Range<usize>) -> &[T] {\n-        self.index(&RangeFull).index(index)\n-    }\n-\n-    #[cfg(not(stage0))]\n     #[inline]\n     fn index(&self, index: ops::Range<usize>) -> &[T] {\n         self.index(RangeFull).index(index)\n@@ -1016,13 +880,6 @@ impl<'a, T> ops::Index<ops::Range<usize>> for IterMut<'a, T> {\n impl<'a, T> ops::Index<ops::RangeTo<usize>> for IterMut<'a, T> {\n     type Output = [T];\n \n-    #[cfg(stage0)]\n-    #[inline]\n-    fn index(&self, index: &ops::RangeTo<usize>) -> &[T] {\n-        self.index(&RangeFull).index(index)\n-    }\n-\n-    #[cfg(not(stage0))]\n     #[inline]\n     fn index(&self, index: ops::RangeTo<usize>) -> &[T] {\n         self.index(RangeFull).index(index)\n@@ -1032,13 +889,6 @@ impl<'a, T> ops::Index<ops::RangeTo<usize>> for IterMut<'a, T> {\n impl<'a, T> ops::Index<ops::RangeFrom<usize>> for IterMut<'a, T> {\n     type Output = [T];\n \n-    #[cfg(stage0)]\n-    #[inline]\n-    fn index(&self, index: &ops::RangeFrom<usize>) -> &[T] {\n-        self.index(&RangeFull).index(index)\n-    }\n-\n-    #[cfg(not(stage0))]\n     #[inline]\n     fn index(&self, index: ops::RangeFrom<usize>) -> &[T] {\n         self.index(RangeFull).index(index)\n@@ -1048,13 +898,6 @@ impl<'a, T> ops::Index<ops::RangeFrom<usize>> for IterMut<'a, T> {\n impl<'a, T> ops::Index<RangeFull> for IterMut<'a, T> {\n     type Output = [T];\n \n-    #[cfg(stage0)]\n-    #[inline]\n-    fn index(&self, _index: &RangeFull) -> &[T] {\n-        make_slice!(T => &[T]: self.ptr, self.end)\n-    }\n-\n-    #[cfg(not(stage0))]\n     #[inline]\n     fn index(&self, _index: RangeFull) -> &[T] {\n         make_slice!(T => &[T]: self.ptr, self.end)\n@@ -1063,13 +906,6 @@ impl<'a, T> ops::Index<RangeFull> for IterMut<'a, T> {\n \n #[unstable(feature = \"core\")]\n impl<'a, T> ops::IndexMut<ops::Range<usize>> for IterMut<'a, T> {\n-    #[cfg(stage0)]\n-    #[inline]\n-    fn index_mut(&mut self, index: &ops::Range<usize>) -> &mut [T] {\n-        self.index_mut(&RangeFull).index_mut(index)\n-    }\n-\n-    #[cfg(not(stage0))]\n     #[inline]\n     fn index_mut(&mut self, index: ops::Range<usize>) -> &mut [T] {\n         self.index_mut(RangeFull).index_mut(index)\n@@ -1078,13 +914,6 @@ impl<'a, T> ops::IndexMut<ops::Range<usize>> for IterMut<'a, T> {\n #[unstable(feature = \"core\")]\n impl<'a, T> ops::IndexMut<ops::RangeTo<usize>> for IterMut<'a, T> {\n \n-    #[cfg(stage0)]\n-    #[inline]\n-    fn index_mut(&mut self, index: &ops::RangeTo<usize>) -> &mut [T] {\n-        self.index_mut(&RangeFull).index_mut(index)\n-    }\n-\n-    #[cfg(not(stage0))]\n     #[inline]\n     fn index_mut(&mut self, index: ops::RangeTo<usize>) -> &mut [T] {\n         self.index_mut(RangeFull).index_mut(index)\n@@ -1093,13 +922,6 @@ impl<'a, T> ops::IndexMut<ops::RangeTo<usize>> for IterMut<'a, T> {\n #[unstable(feature = \"core\")]\n impl<'a, T> ops::IndexMut<ops::RangeFrom<usize>> for IterMut<'a, T> {\n \n-    #[cfg(stage0)]\n-    #[inline]\n-    fn index_mut(&mut self, index: &ops::RangeFrom<usize>) -> &mut [T] {\n-        self.index_mut(&RangeFull).index_mut(index)\n-    }\n-\n-    #[cfg(not(stage0))]\n     #[inline]\n     fn index_mut(&mut self, index: ops::RangeFrom<usize>) -> &mut [T] {\n         self.index_mut(RangeFull).index_mut(index)\n@@ -1108,13 +930,6 @@ impl<'a, T> ops::IndexMut<ops::RangeFrom<usize>> for IterMut<'a, T> {\n #[unstable(feature = \"core\")]\n impl<'a, T> ops::IndexMut<RangeFull> for IterMut<'a, T> {\n \n-    #[cfg(stage0)]\n-    #[inline]\n-    fn index_mut(&mut self, _index: &RangeFull) -> &mut [T] {\n-        make_mut_slice!(T => &mut [T]: self.ptr, self.end)\n-    }\n-\n-    #[cfg(not(stage0))]\n     #[inline]\n     fn index_mut(&mut self, _index: RangeFull) -> &mut [T] {\n         make_mut_slice!(T => &mut [T]: self.ptr, self.end)"}, {"sha": "7fe3758ed9554bac88f78a54b589531c841b3e77", "filename": "src/libcore/str/mod.rs", "status": "modified", "additions": 0, "deletions": 88, "changes": 88, "blob_url": "https://github.com/rust-lang/rust/blob/82b375b44d408e7ddd1e3b2c1e64b0bf0c4376d1/src%2Flibcore%2Fstr%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/82b375b44d408e7ddd1e3b2c1e64b0bf0c4376d1/src%2Flibcore%2Fstr%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fstr%2Fmod.rs?ref=82b375b44d408e7ddd1e3b2c1e64b0bf0c4376d1", "patch": "@@ -541,33 +541,20 @@ delegate_iter!{exact u8 : Bytes<'a>}\n #[derive(Copy, Clone)]\n struct BytesDeref;\n \n-#[cfg(stage0)]\n-impl<'a> Fn<(&'a u8,)> for BytesDeref {\n-    type Output = u8;\n-\n-    #[inline]\n-    extern \"rust-call\" fn call(&self, (ptr,): (&'a u8,)) -> u8 {\n-        *ptr\n-    }\n-}\n-\n-#[cfg(not(stage0))]\n impl<'a> Fn<(&'a u8,)> for BytesDeref {\n     #[inline]\n     extern \"rust-call\" fn call(&self, (ptr,): (&'a u8,)) -> u8 {\n         *ptr\n     }\n }\n \n-#[cfg(not(stage0))]\n impl<'a> FnMut<(&'a u8,)> for BytesDeref {\n     #[inline]\n     extern \"rust-call\" fn call_mut(&mut self, (ptr,): (&'a u8,)) -> u8 {\n         Fn::call(&*self, (ptr,))\n     }\n }\n \n-#[cfg(not(stage0))]\n impl<'a> FnOnce<(&'a u8,)> for BytesDeref {\n     type Output = u8;\n \n@@ -1319,50 +1306,6 @@ mod traits {\n     /// // byte 100 is outside the string\n     /// // &s[3 .. 100];\n     /// ```\n-    #[cfg(stage0)]\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    impl ops::Index<ops::Range<usize>> for str {\n-        type Output = str;\n-        #[inline]\n-        fn index(&self, index: &ops::Range<usize>) -> &str {\n-            // is_char_boundary checks that the index is in [0, .len()]\n-            if index.start <= index.end &&\n-               self.is_char_boundary(index.start) &&\n-               self.is_char_boundary(index.end) {\n-                unsafe { self.slice_unchecked(index.start, index.end) }\n-            } else {\n-                super::slice_error_fail(self, index.start, index.end)\n-            }\n-        }\n-    }\n-\n-    /// Returns a slice of the given string from the byte range\n-    /// [`begin`..`end`).\n-    ///\n-    /// This operation is `O(1)`.\n-    ///\n-    /// Panics when `begin` and `end` do not point to valid characters\n-    /// or point beyond the last character of the string.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// let s = \"L\u00f6we \u8001\u864e L\u00e9opard\";\n-    /// assert_eq!(&s[0 .. 1], \"L\");\n-    ///\n-    /// assert_eq!(&s[1 .. 9], \"\u00f6we \u8001\");\n-    ///\n-    /// // these will panic:\n-    /// // byte 2 lies within `\u00f6`:\n-    /// // &s[2 ..3];\n-    ///\n-    /// // byte 8 lies within `\u8001`\n-    /// // &s[1 .. 8];\n-    ///\n-    /// // byte 100 is outside the string\n-    /// // &s[3 .. 100];\n-    /// ```\n-    #[cfg(not(stage0))]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     impl ops::Index<ops::Range<usize>> for str {\n         type Output = str;\n@@ -1390,18 +1333,6 @@ mod traits {\n     impl ops::Index<ops::RangeTo<usize>> for str {\n         type Output = str;\n \n-        #[cfg(stage0)]\n-        #[inline]\n-        fn index(&self, index: &ops::RangeTo<usize>) -> &str {\n-            // is_char_boundary checks that the index is in [0, .len()]\n-            if self.is_char_boundary(index.end) {\n-                unsafe { self.slice_unchecked(0, index.end) }\n-            } else {\n-                super::slice_error_fail(self, 0, index.end)\n-            }\n-        }\n-\n-        #[cfg(not(stage0))]\n         #[inline]\n         fn index(&self, index: ops::RangeTo<usize>) -> &str {\n             // is_char_boundary checks that the index is in [0, .len()]\n@@ -1423,18 +1354,6 @@ mod traits {\n     impl ops::Index<ops::RangeFrom<usize>> for str {\n         type Output = str;\n \n-        #[cfg(stage0)]\n-        #[inline]\n-        fn index(&self, index: &ops::RangeFrom<usize>) -> &str {\n-            // is_char_boundary checks that the index is in [0, .len()]\n-            if self.is_char_boundary(index.start) {\n-                unsafe { self.slice_unchecked(index.start, self.len()) }\n-            } else {\n-                super::slice_error_fail(self, index.start, self.len())\n-            }\n-        }\n-\n-        #[cfg(not(stage0))]\n         #[inline]\n         fn index(&self, index: ops::RangeFrom<usize>) -> &str {\n             // is_char_boundary checks that the index is in [0, .len()]\n@@ -1450,13 +1369,6 @@ mod traits {\n     impl ops::Index<ops::RangeFull> for str {\n         type Output = str;\n \n-        #[cfg(stage0)]\n-        #[inline]\n-        fn index(&self, _index: &ops::RangeFull) -> &str {\n-            self\n-        }\n-\n-        #[cfg(not(stage0))]\n         #[inline]\n         fn index(&self, _index: ops::RangeFull) -> &str {\n             self"}, {"sha": "7174b2d2c29fed2016fef4f8f478e20b5fbb0971", "filename": "src/liblibc/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/82b375b44d408e7ddd1e3b2c1e64b0bf0c4376d1/src%2Fliblibc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/82b375b44d408e7ddd1e3b2c1e64b0bf0c4376d1/src%2Fliblibc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliblibc%2Flib.rs?ref=82b375b44d408e7ddd1e3b2c1e64b0bf0c4376d1", "patch": "@@ -76,7 +76,7 @@\n \n #![allow(bad_style, raw_pointer_derive)]\n #![cfg_attr(target_os = \"nacl\", allow(unused_imports))]\n-#[cfg(feature = \"cargo-build\")] extern crate \"std\" as core;\n+#[cfg(feature = \"cargo-build\")] extern crate std as core;\n #[cfg(not(feature = \"cargo-build\"))] extern crate core;\n \n #[cfg(test)] extern crate std;"}, {"sha": "90d9324b9090c54e147cf9bbeac985f2f23fedf8", "filename": "src/librustc/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/82b375b44d408e7ddd1e3b2c1e64b0bf0c4376d1/src%2Flibrustc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/82b375b44d408e7ddd1e3b2c1e64b0bf0c4376d1/src%2Flibrustc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flib.rs?ref=82b375b44d408e7ddd1e3b2c1e64b0bf0c4376d1", "patch": "@@ -65,7 +65,7 @@ extern crate collections;\n #[macro_use] extern crate syntax;\n #[macro_use] #[no_link] extern crate rustc_bitflags;\n \n-extern crate \"serialize\" as rustc_serialize; // used by deriving\n+extern crate serialize as rustc_serialize; // used by deriving\n \n #[cfg(test)]\n extern crate test;"}, {"sha": "99f19ad7110869b34056f0a59ae287944520c1bc", "filename": "src/librustc_borrowck/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/82b375b44d408e7ddd1e3b2c1e64b0bf0c4376d1/src%2Flibrustc_borrowck%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/82b375b44d408e7ddd1e3b2c1e64b0bf0c4376d1/src%2Flibrustc_borrowck%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Flib.rs?ref=82b375b44d408e7ddd1e3b2c1e64b0bf0c4376d1", "patch": "@@ -35,7 +35,7 @@\n \n // for \"clarity\", rename the graphviz crate to dot; graphviz within `borrowck`\n // refers to the borrowck-specific graphviz adapter traits.\n-extern crate \"graphviz\" as dot;\n+extern crate graphviz as dot;\n extern crate rustc;\n \n pub use borrowck::check_crate;"}, {"sha": "c433aed4ae94a053b8c01e3e87f81a2aa0c57d3c", "filename": "src/librustc_driver/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/82b375b44d408e7ddd1e3b2c1e64b0bf0c4376d1/src%2Flibrustc_driver%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/82b375b44d408e7ddd1e3b2c1e64b0bf0c4376d1/src%2Flibrustc_driver%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Flib.rs?ref=82b375b44d408e7ddd1e3b2c1e64b0bf0c4376d1", "patch": "@@ -55,7 +55,7 @@ extern crate rustc_resolve;\n extern crate rustc_trans;\n extern crate rustc_typeck;\n extern crate serialize;\n-extern crate \"rustc_llvm\" as llvm;\n+extern crate rustc_llvm as llvm;\n #[macro_use] extern crate log;\n #[macro_use] extern crate syntax;\n "}, {"sha": "83525dffaaeb7834ddd5a85ba30a819c7d99e0c3", "filename": "src/librustc_trans/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/82b375b44d408e7ddd1e3b2c1e64b0bf0c4376d1/src%2Flibrustc_trans%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/82b375b44d408e7ddd1e3b2c1e64b0bf0c4376d1/src%2Flibrustc_trans%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Flib.rs?ref=82b375b44d408e7ddd1e3b2c1e64b0bf0c4376d1", "patch": "@@ -54,7 +54,7 @@ extern crate libc;\n extern crate rustc;\n extern crate rustc_back;\n extern crate serialize;\n-extern crate \"rustc_llvm\" as llvm;\n+extern crate rustc_llvm as llvm;\n \n #[macro_use] extern crate log;\n #[macro_use] extern crate syntax;"}, {"sha": "12c71b1437ac4a898c008ee474b5a6119364e9f8", "filename": "src/librustdoc/lib.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/82b375b44d408e7ddd1e3b2c1e64b0bf0c4376d1/src%2Flibrustdoc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/82b375b44d408e7ddd1e3b2c1e64b0bf0c4376d1/src%2Flibrustdoc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Flib.rs?ref=82b375b44d408e7ddd1e3b2c1e64b0bf0c4376d1", "patch": "@@ -51,11 +51,11 @@ extern crate rustc_lint;\n extern crate rustc_back;\n extern crate serialize;\n extern crate syntax;\n-extern crate \"test\" as testing;\n+extern crate test as testing;\n extern crate unicode;\n #[macro_use] extern crate log;\n \n-extern crate \"serialize\" as rustc_serialize; // used by deriving\n+extern crate serialize as rustc_serialize; // used by deriving\n \n use std::cell::RefCell;\n use std::collections::HashMap;"}, {"sha": "d5f494d2ae98e3df45ab7d6809dc0bffb71089dc", "filename": "src/libserialize/json.rs", "status": "modified", "additions": 0, "deletions": 23, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/82b375b44d408e7ddd1e3b2c1e64b0bf0c4376d1/src%2Flibserialize%2Fjson.rs", "raw_url": "https://github.com/rust-lang/rust/raw/82b375b44d408e7ddd1e3b2c1e64b0bf0c4376d1/src%2Flibserialize%2Fjson.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibserialize%2Fjson.rs?ref=82b375b44d408e7ddd1e3b2c1e64b0bf0c4376d1", "patch": "@@ -1218,16 +1218,6 @@ impl Json {\n     }\n }\n \n-#[cfg(stage0)]\n-impl<'a> Index<&'a str>  for Json {\n-    type Output = Json;\n-\n-    fn index(&self, idx: & &str) -> &Json {\n-        self.find(*idx).unwrap()\n-    }\n-}\n-\n-#[cfg(not(stage0))]\n impl<'a> Index<&'a str>  for Json {\n     type Output = Json;\n \n@@ -1236,19 +1226,6 @@ impl<'a> Index<&'a str>  for Json {\n     }\n }\n \n-#[cfg(stage0)]\n-impl Index<uint> for Json {\n-    type Output = Json;\n-\n-    fn index<'a>(&'a self, idx: &uint) -> &'a Json {\n-        match self {\n-            &Json::Array(ref v) => &v[*idx],\n-            _ => panic!(\"can only index Json with uint if it is an array\")\n-        }\n-    }\n-}\n-\n-#[cfg(not(stage0))]\n impl Index<uint> for Json {\n     type Output = Json;\n "}, {"sha": "06d1e69fff051cd0800a0a3da6ca4fec4cf1c42a", "filename": "src/libstd/collections/hash/map.rs", "status": "modified", "additions": 0, "deletions": 16, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/82b375b44d408e7ddd1e3b2c1e64b0bf0c4376d1/src%2Flibstd%2Fcollections%2Fhash%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/82b375b44d408e7ddd1e3b2c1e64b0bf0c4376d1/src%2Flibstd%2Fcollections%2Fhash%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcollections%2Fhash%2Fmap.rs?ref=82b375b44d408e7ddd1e3b2c1e64b0bf0c4376d1", "patch": "@@ -1247,22 +1247,6 @@ impl<K, V, S> Default for HashMap<K, V, S>\n     }\n }\n \n-#[cfg(stage0)]\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<K, Q: ?Sized, V, S> Index<Q> for HashMap<K, V, S>\n-    where K: Eq + Hash + Borrow<Q>,\n-          Q: Eq + Hash,\n-          S: HashState,\n-{\n-    type Output = V;\n-\n-    #[inline]\n-    fn index<'a>(&'a self, index: &Q) -> &'a V {\n-        self.get(index).expect(\"no entry found for key\")\n-    }\n-}\n-\n-#[cfg(not(stage0))]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, K, Q: ?Sized, V, S> Index<&'a Q> for HashMap<K, V, S>\n     where K: Eq + Hash + Borrow<Q>,"}, {"sha": "99cbd26bcd1a86f8f8443110a74ba52151735373", "filename": "src/libstd/ffi/os_str.rs", "status": "modified", "additions": 0, "deletions": 12, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/82b375b44d408e7ddd1e3b2c1e64b0bf0c4376d1/src%2Flibstd%2Fffi%2Fos_str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/82b375b44d408e7ddd1e3b2c1e64b0bf0c4376d1/src%2Flibstd%2Fffi%2Fos_str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fffi%2Fos_str.rs?ref=82b375b44d408e7ddd1e3b2c1e64b0bf0c4376d1", "patch": "@@ -133,18 +133,6 @@ impl<'a> From<&'a OsStr> for OsString {\n     }\n }\n \n-#[cfg(stage0)]\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl ops::Index<ops::RangeFull> for OsString {\n-    type Output = OsStr;\n-\n-    #[inline]\n-    fn index(&self, _index: &ops::RangeFull) -> &OsStr {\n-        unsafe { mem::transmute(self.inner.as_slice()) }\n-    }\n-}\n-\n-#[cfg(not(stage0))]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl ops::Index<ops::RangeFull> for OsString {\n     type Output = OsStr;"}, {"sha": "7eb575a3a689b4ed9105a6aa0e57173e0d8ca5fa", "filename": "src/libstd/lib.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/82b375b44d408e7ddd1e3b2c1e64b0bf0c4376d1/src%2Flibstd%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/82b375b44d408e7ddd1e3b2c1e64b0bf0c4376d1/src%2Flibstd%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Flib.rs?ref=82b375b44d408e7ddd1e3b2c1e64b0bf0c4376d1", "patch": "@@ -149,17 +149,17 @@ extern crate core;\n \n #[macro_use]\n #[macro_reexport(vec, format)]\n-extern crate \"collections\" as core_collections;\n+extern crate collections as core_collections;\n \n-#[allow(deprecated)] extern crate \"rand\" as core_rand;\n+#[allow(deprecated)] extern crate rand as core_rand;\n extern crate alloc;\n extern crate unicode;\n extern crate libc;\n \n #[macro_use] #[no_link] extern crate rustc_bitflags;\n \n // Make std testable by not duplicating lang items. See #2912\n-#[cfg(test)] extern crate \"std\" as realstd;\n+#[cfg(test)] extern crate std as realstd;\n #[cfg(test)] pub use realstd::marker;\n #[cfg(test)] pub use realstd::ops;\n #[cfg(test)] pub use realstd::cmp;"}, {"sha": "298085806bdecb66b74ff2225c2f5a262022f196", "filename": "src/libstd/old_io/mem.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/82b375b44d408e7ddd1e3b2c1e64b0bf0c4376d1/src%2Flibstd%2Fold_io%2Fmem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/82b375b44d408e7ddd1e3b2c1e64b0bf0c4376d1/src%2Flibstd%2Fold_io%2Fmem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fold_io%2Fmem.rs?ref=82b375b44d408e7ddd1e3b2c1e64b0bf0c4376d1", "patch": "@@ -397,7 +397,7 @@ impl<'a> Buffer for BufReader<'a> {\n \n #[cfg(test)]\n mod test {\n-    extern crate \"test\" as test_crate;\n+    extern crate test as test_crate;\n     use old_io::{SeekSet, SeekCur, SeekEnd, Reader, Writer, Seek, Buffer};\n     use prelude::v1::{Ok, Err, Vec,  AsSlice};\n     use prelude::v1::IteratorExt;"}, {"sha": "0d83e4497f7e2145ff86cc3e5b83ee814a9b1931", "filename": "src/libstd/sys/common/wtf8.rs", "status": "modified", "additions": 0, "deletions": 79, "changes": 79, "blob_url": "https://github.com/rust-lang/rust/blob/82b375b44d408e7ddd1e3b2c1e64b0bf0c4376d1/src%2Flibstd%2Fsys%2Fcommon%2Fwtf8.rs", "raw_url": "https://github.com/rust-lang/rust/raw/82b375b44d408e7ddd1e3b2c1e64b0bf0c4376d1/src%2Flibstd%2Fsys%2Fcommon%2Fwtf8.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fcommon%2Fwtf8.rs?ref=82b375b44d408e7ddd1e3b2c1e64b0bf0c4376d1", "patch": "@@ -634,30 +634,6 @@ impl Wtf8 {\n ///\n /// Panics when `begin` and `end` do not point to code point boundaries,\n /// or point beyond the end of the string.\n-#[cfg(stage0)]\n-impl ops::Index<ops::Range<usize>> for Wtf8 {\n-    type Output = Wtf8;\n-\n-    #[inline]\n-    fn index(&self, range: &ops::Range<usize>) -> &Wtf8 {\n-        // is_code_point_boundary checks that the index is in [0, .len()]\n-        if range.start <= range.end &&\n-           is_code_point_boundary(self, range.start) &&\n-           is_code_point_boundary(self, range.end) {\n-            unsafe { slice_unchecked(self, range.start, range.end) }\n-        } else {\n-            slice_error_fail(self, range.start, range.end)\n-        }\n-    }\n-}\n-\n-/// Return a slice of the given string for the byte range [`begin`..`end`).\n-///\n-/// # Panics\n-///\n-/// Panics when `begin` and `end` do not point to code point boundaries,\n-/// or point beyond the end of the string.\n-#[cfg(not(stage0))]\n impl ops::Index<ops::Range<usize>> for Wtf8 {\n     type Output = Wtf8;\n \n@@ -680,28 +656,6 @@ impl ops::Index<ops::Range<usize>> for Wtf8 {\n ///\n /// Panics when `begin` is not at a code point boundary,\n /// or is beyond the end of the string.\n-#[cfg(stage0)]\n-impl ops::Index<ops::RangeFrom<usize>> for Wtf8 {\n-    type Output = Wtf8;\n-\n-    #[inline]\n-    fn index(&self, range: &ops::RangeFrom<usize>) -> &Wtf8 {\n-        // is_code_point_boundary checks that the index is in [0, .len()]\n-        if is_code_point_boundary(self, range.start) {\n-            unsafe { slice_unchecked(self, range.start, self.len()) }\n-        } else {\n-            slice_error_fail(self, range.start, self.len())\n-        }\n-    }\n-}\n-\n-/// Return a slice of the given string from byte `begin` to its end.\n-///\n-/// # Panics\n-///\n-/// Panics when `begin` is not at a code point boundary,\n-/// or is beyond the end of the string.\n-#[cfg(not(stage0))]\n impl ops::Index<ops::RangeFrom<usize>> for Wtf8 {\n     type Output = Wtf8;\n \n@@ -722,28 +676,6 @@ impl ops::Index<ops::RangeFrom<usize>> for Wtf8 {\n ///\n /// Panics when `end` is not at a code point boundary,\n /// or is beyond the end of the string.\n-#[cfg(stage0)]\n-impl ops::Index<ops::RangeTo<usize>> for Wtf8 {\n-    type Output = Wtf8;\n-\n-    #[inline]\n-    fn index(&self, range: &ops::RangeTo<usize>) -> &Wtf8 {\n-        // is_code_point_boundary checks that the index is in [0, .len()]\n-        if is_code_point_boundary(self, range.end) {\n-            unsafe { slice_unchecked(self, 0, range.end) }\n-        } else {\n-            slice_error_fail(self, 0, range.end)\n-        }\n-    }\n-}\n-\n-/// Return a slice of the given string from its beginning to byte `end`.\n-///\n-/// # Panics\n-///\n-/// Panics when `end` is not at a code point boundary,\n-/// or is beyond the end of the string.\n-#[cfg(not(stage0))]\n impl ops::Index<ops::RangeTo<usize>> for Wtf8 {\n     type Output = Wtf8;\n \n@@ -758,17 +690,6 @@ impl ops::Index<ops::RangeTo<usize>> for Wtf8 {\n     }\n }\n \n-#[cfg(stage0)]\n-impl ops::Index<ops::RangeFull> for Wtf8 {\n-    type Output = Wtf8;\n-\n-    #[inline]\n-    fn index(&self, _range: &ops::RangeFull) -> &Wtf8 {\n-        self\n-    }\n-}\n-\n-#[cfg(not(stage0))]\n impl ops::Index<ops::RangeFull> for Wtf8 {\n     type Output = Wtf8;\n "}, {"sha": "cf4594f514b1a15d3f7035f3c94f5ef5e54342dc", "filename": "src/libsyntax/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/82b375b44d408e7ddd1e3b2c1e64b0bf0c4376d1/src%2Flibsyntax%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/82b375b44d408e7ddd1e3b2c1e64b0bf0c4376d1/src%2Flibsyntax%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Flib.rs?ref=82b375b44d408e7ddd1e3b2c1e64b0bf0c4376d1", "patch": "@@ -49,7 +49,7 @@ extern crate libc;\n #[macro_use] extern crate log;\n #[macro_use] #[no_link] extern crate rustc_bitflags;\n \n-extern crate \"serialize\" as rustc_serialize; // used by deriving\n+extern crate serialize as rustc_serialize; // used by deriving\n \n pub mod util {\n     pub mod interner;"}, {"sha": "3e26a68d5909edb9796532e0f6b249c0ae181030", "filename": "src/libtest/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/82b375b44d408e7ddd1e3b2c1e64b0bf0c4376d1/src%2Flibtest%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/82b375b44d408e7ddd1e3b2c1e64b0bf0c4376d1/src%2Flibtest%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibtest%2Flib.rs?ref=82b375b44d408e7ddd1e3b2c1e64b0bf0c4376d1", "patch": "@@ -50,7 +50,7 @@\n \n extern crate getopts;\n extern crate serialize;\n-extern crate \"serialize\" as rustc_serialize;\n+extern crate serialize as rustc_serialize;\n extern crate term;\n extern crate libc;\n "}, {"sha": "2aeade5066fde0630cc7cfa2b0500dc0a74228ee", "filename": "src/libunicode/char.rs", "status": "modified", "additions": 0, "deletions": 424, "changes": 424, "blob_url": "https://github.com/rust-lang/rust/blob/82b375b44d408e7ddd1e3b2c1e64b0bf0c4376d1/src%2Flibunicode%2Fchar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/82b375b44d408e7ddd1e3b2c1e64b0bf0c4376d1/src%2Flibunicode%2Fchar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibunicode%2Fchar.rs?ref=82b375b44d408e7ddd1e3b2c1e64b0bf0c4376d1", "patch": "@@ -41,430 +41,6 @@ pub use normalize::{decompose_canonical, decompose_compatible, compose};\n pub use tables::normalization::canonical_combining_class;\n pub use tables::UNICODE_VERSION;\n \n-#[cfg(stage0)]\n-/// Functionality for manipulating `char`.\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub trait CharExt {\n-    /// Checks if a `char` parses as a numeric digit in the given radix.\n-    ///\n-    /// Compared to `is_numeric()`, this function only recognizes the characters\n-    /// `0-9`, `a-z` and `A-Z`.\n-    ///\n-    /// # Return value\n-    ///\n-    /// Returns `true` if `c` is a valid digit under `radix`, and `false`\n-    /// otherwise.\n-    ///\n-    /// # Panics\n-    ///\n-    /// Panics if given a radix > 36.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// let c = '1';\n-    ///\n-    /// assert!(c.is_digit(10));\n-    ///\n-    /// assert!('f'.is_digit(16));\n-    /// ```\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    fn is_digit(self, radix: u32) -> bool;\n-\n-    /// Converts a character to the corresponding digit.\n-    ///\n-    /// # Return value\n-    ///\n-    /// If `c` is between '0' and '9', the corresponding value between 0 and\n-    /// 9. If `c` is 'a' or 'A', 10. If `c` is 'b' or 'B', 11, etc. Returns\n-    /// none if the character does not refer to a digit in the given radix.\n-    ///\n-    /// # Panics\n-    ///\n-    /// Panics if given a radix outside the range [0..36].\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// let c = '1';\n-    ///\n-    /// assert_eq!(c.to_digit(10), Some(1));\n-    ///\n-    /// assert_eq!('f'.to_digit(16), Some(15));\n-    /// ```\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    fn to_digit(self, radix: u32) -> Option<u32>;\n-\n-    /// Returns an iterator that yields the hexadecimal Unicode escape of a\n-    /// character, as `char`s.\n-    ///\n-    /// All characters are escaped with Rust syntax of the form `\\\\u{NNNN}`\n-    /// where `NNNN` is the shortest hexadecimal representation of the code\n-    /// point.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// for i in '\u2764'.escape_unicode() {\n-    ///     println!(\"{}\", i);\n-    /// }\n-    /// ```\n-    ///\n-    /// This prints:\n-    ///\n-    /// ```text\n-    /// \\\n-    /// u\n-    /// {\n-    /// 2\n-    /// 7\n-    /// 6\n-    /// 4\n-    /// }\n-    /// ```\n-    ///\n-    /// Collecting into a `String`:\n-    ///\n-    /// ```\n-    /// let heart: String = '\u2764'.escape_unicode().collect();\n-    ///\n-    /// assert_eq!(heart, r\"\\u{2764}\");\n-    /// ```\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    fn escape_unicode(self) -> EscapeUnicode;\n-\n-    /// Returns an iterator that yields the 'default' ASCII and\n-    /// C++11-like literal escape of a character, as `char`s.\n-    ///\n-    /// The default is chosen with a bias toward producing literals that are\n-    /// legal in a variety of languages, including C++11 and similar C-family\n-    /// languages. The exact rules are:\n-    ///\n-    /// * Tab, CR and LF are escaped as '\\t', '\\r' and '\\n' respectively.\n-    /// * Single-quote, double-quote and backslash chars are backslash-\n-    ///   escaped.\n-    /// * Any other chars in the range [0x20,0x7e] are not escaped.\n-    /// * Any other chars are given hex Unicode escapes; see `escape_unicode`.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// for i in '\"'.escape_default() {\n-    ///     println!(\"{}\", i);\n-    /// }\n-    /// ```\n-    ///\n-    /// This prints:\n-    ///\n-    /// ```text\n-    /// \\\n-    /// \"\n-    /// ```\n-    ///\n-    /// Collecting into a `String`:\n-    ///\n-    /// ```\n-    /// let quote: String = '\"'.escape_default().collect();\n-    ///\n-    /// assert_eq!(quote, \"\\\\\\\"\");\n-    /// ```\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    fn escape_default(self) -> EscapeDefault;\n-\n-    /// Returns the number of bytes this character would need if encoded in\n-    /// UTF-8.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// let n = '\u00df'.len_utf8();\n-    ///\n-    /// assert_eq!(n, 2);\n-    /// ```\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    fn len_utf8(self) -> usize;\n-\n-    /// Returns the number of 16-bit code units this character would need if\n-    /// encoded in UTF-16.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// let n = '\u00df'.len_utf16();\n-    ///\n-    /// assert_eq!(n, 1);\n-    /// ```\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    fn len_utf16(self) -> usize;\n-\n-    /// Encodes this character as UTF-8 into the provided byte buffer, and then\n-    /// returns the number of bytes written.\n-    ///\n-    /// If the buffer is not large enough, nothing will be written into it and a\n-    /// `None` will be returned. A buffer of length four is large enough to\n-    /// encode any `char`.\n-    ///\n-    /// # Examples\n-    ///\n-    /// In both of these examples, '\u00df' takes two bytes to encode.\n-    ///\n-    /// ```\n-    /// # #![feature(unicode)]\n-    /// let mut b = [0; 2];\n-    ///\n-    /// let result = '\u00df'.encode_utf8(&mut b);\n-    ///\n-    /// assert_eq!(result, Some(2));\n-    /// ```\n-    ///\n-    /// A buffer that's too small:\n-    ///\n-    /// ```\n-    /// # #![feature(unicode)]\n-    /// let mut b = [0; 1];\n-    ///\n-    /// let result = '\u00df'.encode_utf8(&mut b);\n-    ///\n-    /// assert_eq!(result, None);\n-    /// ```\n-    #[unstable(feature = \"unicode\",\n-               reason = \"pending decision about Iterator/Writer/Reader\")]\n-    fn encode_utf8(self, dst: &mut [u8]) -> Option<usize>;\n-\n-    /// Encodes this character as UTF-16 into the provided `u16` buffer, and\n-    /// then returns the number of `u16`s written.\n-    ///\n-    /// If the buffer is not large enough, nothing will be written into it and a\n-    /// `None` will be returned. A buffer of length 2 is large enough to encode\n-    /// any `char`.\n-    ///\n-    /// # Examples\n-    ///\n-    /// In both of these examples, '\u00df' takes one `u16` to encode.\n-    ///\n-    /// ```\n-    /// # #![feature(unicode)]\n-    /// let mut b = [0; 1];\n-    ///\n-    /// let result = '\u00df'.encode_utf16(&mut b);\n-    ///\n-    /// assert_eq!(result, Some(1));\n-    /// ```\n-    ///\n-    /// A buffer that's too small:\n-    ///\n-    /// ```\n-    /// # #![feature(unicode)]\n-    /// let mut b = [0; 0];\n-    ///\n-    /// let result = '\u00df'.encode_utf8(&mut b);\n-    ///\n-    /// assert_eq!(result, None);\n-    /// ```\n-    #[unstable(feature = \"unicode\",\n-               reason = \"pending decision about Iterator/Writer/Reader\")]\n-    fn encode_utf16(self, dst: &mut [u16]) -> Option<usize>;\n-\n-    /// Returns whether the specified character is considered a Unicode\n-    /// alphabetic code point.\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    fn is_alphabetic(self) -> bool;\n-\n-    /// Returns whether the specified character satisfies the 'XID_Start'\n-    /// Unicode property.\n-    ///\n-    /// 'XID_Start' is a Unicode Derived Property specified in\n-    /// [UAX #31](http://unicode.org/reports/tr31/#NFKC_Modifications),\n-    /// mostly similar to ID_Start but modified for closure under NFKx.\n-    #[unstable(feature = \"unicode\",\n-               reason = \"mainly needed for compiler internals\")]\n-    fn is_xid_start(self) -> bool;\n-\n-    /// Returns whether the specified `char` satisfies the 'XID_Continue'\n-    /// Unicode property.\n-    ///\n-    /// 'XID_Continue' is a Unicode Derived Property specified in\n-    /// [UAX #31](http://unicode.org/reports/tr31/#NFKC_Modifications),\n-    /// mostly similar to 'ID_Continue' but modified for closure under NFKx.\n-    #[unstable(feature = \"unicode\",\n-               reason = \"mainly needed for compiler internals\")]\n-    fn is_xid_continue(self) -> bool;\n-\n-    /// Indicates whether a character is in lowercase.\n-    ///\n-    /// This is defined according to the terms of the Unicode Derived Core\n-    /// Property `Lowercase`.\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    fn is_lowercase(self) -> bool;\n-\n-    /// Indicates whether a character is in uppercase.\n-    ///\n-    /// This is defined according to the terms of the Unicode Derived Core\n-    /// Property `Uppercase`.\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    fn is_uppercase(self) -> bool;\n-\n-    /// Indicates whether a character is whitespace.\n-    ///\n-    /// Whitespace is defined in terms of the Unicode Property `White_Space`.\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    fn is_whitespace(self) -> bool;\n-\n-    /// Indicates whether a character is alphanumeric.\n-    ///\n-    /// Alphanumericness is defined in terms of the Unicode General Categories\n-    /// 'Nd', 'Nl', 'No' and the Derived Core Property 'Alphabetic'.\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    fn is_alphanumeric(self) -> bool;\n-\n-    /// Indicates whether a character is a control code point.\n-    ///\n-    /// Control code points are defined in terms of the Unicode General\n-    /// Category `Cc`.\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    fn is_control(self) -> bool;\n-\n-    /// Indicates whether the character is numeric (Nd, Nl, or No).\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    fn is_numeric(self) -> bool;\n-\n-    /// Converts a character to its lowercase equivalent.\n-    ///\n-    /// The case-folding performed is the common or simple mapping. See\n-    /// `to_uppercase()` for references and more information.\n-    ///\n-    /// # Return value\n-    ///\n-    /// Returns an iterator which yields the characters corresponding to the\n-    /// lowercase equivalent of the character. If no conversion is possible then\n-    /// the input character is returned.\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    fn to_lowercase(self) -> ToLowercase;\n-\n-    /// Converts a character to its uppercase equivalent.\n-    ///\n-    /// The case-folding performed is the common or simple mapping: it maps\n-    /// one Unicode codepoint to its uppercase equivalent according to the\n-    /// Unicode database [1]. The additional [`SpecialCasing.txt`] is not yet\n-    /// considered here, but the iterator returned will soon support this form\n-    /// of case folding.\n-    ///\n-    /// A full reference can be found here [2].\n-    ///\n-    /// # Return value\n-    ///\n-    /// Returns an iterator which yields the characters corresponding to the\n-    /// uppercase equivalent of the character. If no conversion is possible then\n-    /// the input character is returned.\n-    ///\n-    /// [1]: ftp://ftp.unicode.org/Public/UNIDATA/UnicodeData.txt\n-    ///\n-    /// [`SpecialCasing`.txt`]: ftp://ftp.unicode.org/Public/UNIDATA/SpecialCasing.txt\n-    ///\n-    /// [2]: http://www.unicode.org/versions/Unicode4.0.0/ch03.pdf#G33992\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    fn to_uppercase(self) -> ToUppercase;\n-\n-    /// Returns this character's displayed width in columns, or `None` if it is a\n-    /// control character other than `'\\x00'`.\n-    ///\n-    /// `is_cjk` determines behavior for characters in the Ambiguous category:\n-    /// if `is_cjk` is `true`, these are 2 columns wide; otherwise, they are 1.\n-    /// In CJK contexts, `is_cjk` should be `true`, else it should be `false`.\n-    /// [Unicode Standard Annex #11](http://www.unicode.org/reports/tr11/)\n-    /// recommends that these characters be treated as 1 column (i.e.,\n-    /// `is_cjk` = `false`) if the context cannot be reliably determined.\n-    #[unstable(feature = \"unicode\",\n-               reason = \"needs expert opinion. is_cjk flag stands out as ugly\")]\n-    fn width(self, is_cjk: bool) -> Option<usize>;\n-}\n-\n-#[cfg(stage0)]\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl CharExt for char {\n-    #[inline]\n-    fn is_digit(self, radix: u32) -> bool { C::is_digit(self, radix) }\n-    fn to_digit(self, radix: u32) -> Option<u32> { C::to_digit(self, radix) }\n-    fn escape_unicode(self) -> EscapeUnicode { C::escape_unicode(self) }\n-    fn escape_default(self) -> EscapeDefault { C::escape_default(self) }\n-    fn len_utf8(self) -> usize { C::len_utf8(self) }\n-    fn len_utf16(self) -> usize { C::len_utf16(self) }\n-    fn encode_utf8(self, dst: &mut [u8]) -> Option<usize> { C::encode_utf8(self, dst) }\n-    fn encode_utf16(self, dst: &mut [u16]) -> Option<usize> { C::encode_utf16(self, dst) }\n-\n-    #[inline]\n-    fn is_alphabetic(self) -> bool {\n-        match self {\n-            'a' ... 'z' | 'A' ... 'Z' => true,\n-            c if c > '\\x7f' => derived_property::Alphabetic(c),\n-            _ => false\n-        }\n-    }\n-\n-    #[inline]\n-    fn is_xid_start(self) -> bool { derived_property::XID_Start(self) }\n-\n-    #[inline]\n-    fn is_xid_continue(self) -> bool { derived_property::XID_Continue(self) }\n-\n-    #[inline]\n-    fn is_lowercase(self) -> bool {\n-        match self {\n-            'a' ... 'z' => true,\n-            c if c > '\\x7f' => derived_property::Lowercase(c),\n-            _ => false\n-        }\n-    }\n-\n-    #[inline]\n-    fn is_uppercase(self) -> bool {\n-        match self {\n-            'A' ... 'Z' => true,\n-            c if c > '\\x7f' => derived_property::Uppercase(c),\n-            _ => false\n-        }\n-    }\n-\n-    #[inline]\n-    fn is_whitespace(self) -> bool {\n-        match self {\n-            ' ' | '\\x09' ... '\\x0d' => true,\n-            c if c > '\\x7f' => property::White_Space(c),\n-            _ => false\n-        }\n-    }\n-\n-    #[inline]\n-    fn is_alphanumeric(self) -> bool {\n-        self.is_alphabetic() || self.is_numeric()\n-    }\n-\n-    #[inline]\n-    fn is_control(self) -> bool { general_category::Cc(self) }\n-\n-    #[inline]\n-    fn is_numeric(self) -> bool {\n-        match self {\n-            '0' ... '9' => true,\n-            c if c > '\\x7f' => general_category::N(c),\n-            _ => false\n-        }\n-    }\n-\n-    #[inline]\n-    fn to_lowercase(self) -> ToLowercase {\n-        ToLowercase(Some(conversions::to_lower(self)))\n-    }\n-\n-    #[inline]\n-    fn to_uppercase(self) -> ToUppercase {\n-        ToUppercase(Some(conversions::to_upper(self)))\n-    }\n-\n-    #[inline]\n-    fn width(self, is_cjk: bool) -> Option<usize> { charwidth::width(self, is_cjk) }\n-}\n-\n /// An iterator over the lowercase mapping of a given character, returned from\n /// the [`to_lowercase` method](../primitive.char.html#method.to_lowercase) on\n /// characters."}, {"sha": "8b05f7c895527887e68a2a8169c6d44e14110214", "filename": "src/snapshots.txt", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/82b375b44d408e7ddd1e3b2c1e64b0bf0c4376d1/src%2Fsnapshots.txt", "raw_url": "https://github.com/rust-lang/rust/raw/82b375b44d408e7ddd1e3b2c1e64b0bf0c4376d1/src%2Fsnapshots.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fsnapshots.txt?ref=82b375b44d408e7ddd1e3b2c1e64b0bf0c4376d1", "patch": "@@ -1,3 +1,13 @@\n+S 2015-03-25 a923278\n+  bitrig-x86_64 41de2c7a69a1ac648d3fa3b65e96a29bdc122163\n+  freebsd-x86_64 cd02c86a9218da73b2a45aff293787010d33bf3e\n+  linux-i386 da50141558eed6dabab97b79b2c6a7de4f2d2c5e\n+  linux-x86_64 bca03458d28d07506bad4b80e5770b2117286244\n+  macos-i386 522d59b23dd885a45e2c5b33e80e76240bb2d9af\n+  macos-x86_64 82df09d51d73d119a2f4e4d8041879615cb22081\n+  winnt-i386 5056e8def5ab4f4283b8f3aab160cc10231bb28d\n+  winnt-x86_64 3f6b35ac12625b4b4b42dfd5eee5f6cbf122794e\n+\n S 2015-03-17 c64d671\n   bitrig-x86_64 41de2c7a69a1ac648d3fa3b65e96a29bdc122163\n   freebsd-x86_64 14ced24e1339a4dd8baa9db69995daa52a948d54"}, {"sha": "b726c46d5d533c8681b8a4ad65bf94a9057f921a", "filename": "src/test/compile-fail/borrowck-overloaded-index-autoderef.rs", "status": "modified", "additions": 0, "deletions": 13, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/82b375b44d408e7ddd1e3b2c1e64b0bf0c4376d1/src%2Ftest%2Fcompile-fail%2Fborrowck-overloaded-index-autoderef.rs", "raw_url": "https://github.com/rust-lang/rust/raw/82b375b44d408e7ddd1e3b2c1e64b0bf0c4376d1/src%2Ftest%2Fcompile-fail%2Fborrowck-overloaded-index-autoderef.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-overloaded-index-autoderef.rs?ref=82b375b44d408e7ddd1e3b2c1e64b0bf0c4376d1", "patch": "@@ -18,19 +18,6 @@ struct Foo {\n     y: isize,\n }\n \n-#[cfg(stage0)]\n-impl Index<String> for Foo {\n-    type Output = isize;\n-\n-    fn index<'a>(&'a self, z: &String) -> &'a isize {\n-        if *z == \"x\" {\n-            &self.x\n-        } else {\n-            &self.y\n-        }\n-    }\n-}\n-\n impl<'a> Index<&'a String> for Foo {\n     type Output = isize;\n "}]}