{"sha": "d49e1a91912788b874bfb5cfc610bc8e3a845d7f", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQ0OWUxYTkxOTEyNzg4Yjg3NGJmYjVjZmM2MTBiYzhlM2E4NDVkN2Y=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2016-08-12T01:55:22Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2016-08-17T14:25:01Z"}, "message": "move rbml_w into the self struct", "tree": {"sha": "3bb878b6979ae4d2a1838008c7a13492e2906560", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3bb878b6979ae4d2a1838008c7a13492e2906560"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d49e1a91912788b874bfb5cfc610bc8e3a845d7f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d49e1a91912788b874bfb5cfc610bc8e3a845d7f", "html_url": "https://github.com/rust-lang/rust/commit/d49e1a91912788b874bfb5cfc610bc8e3a845d7f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d49e1a91912788b874bfb5cfc610bc8e3a845d7f/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "baccdc01ae608920602fda8411f1ff8f127ebef2", "url": "https://api.github.com/repos/rust-lang/rust/commits/baccdc01ae608920602fda8411f1ff8f127ebef2", "html_url": "https://github.com/rust-lang/rust/commit/baccdc01ae608920602fda8411f1ff8f127ebef2"}], "stats": {"total": 825, "additions": 400, "deletions": 425}, "files": [{"sha": "8b76dd62692fb3905a393c70c3733d706277b36d", "filename": "src/librustc_metadata/encoder.rs", "status": "modified", "additions": 379, "deletions": 409, "changes": 788, "blob_url": "https://github.com/rust-lang/rust/blob/d49e1a91912788b874bfb5cfc610bc8e3a845d7f/src%2Flibrustc_metadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d49e1a91912788b874bfb5cfc610bc8e3a845d7f/src%2Flibrustc_metadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fencoder.rs?ref=d49e1a91912788b874bfb5cfc610bc8e3a845d7f", "patch": "@@ -132,22 +132,19 @@ fn encode_item_variances(rbml_w: &mut Encoder,\n     rbml_w.end_tag();\n }\n \n-impl<'a, 'tcx> ItemContentBuilder<'a, 'tcx> {\n+impl<'a, 'tcx, 'encoder> ItemContentBuilder<'a, 'tcx, 'encoder> {\n     fn encode_bounds_and_type_for_item(&mut self,\n-                                       rbml_w: &mut Encoder,\n                                        id: NodeId) {\n         let ecx = self.ecx();\n-        self.encode_bounds_and_type(rbml_w,\n-                                    &ecx.tcx.lookup_item_type(ecx.tcx.map.local_def_id(id)),\n+        self.encode_bounds_and_type(&ecx.tcx.lookup_item_type(ecx.tcx.map.local_def_id(id)),\n                                     &ecx.tcx.lookup_predicates(ecx.tcx.map.local_def_id(id)));\n     }\n \n     fn encode_bounds_and_type(&mut self,\n-                              rbml_w: &mut Encoder,\n                               scheme: &ty::TypeScheme<'tcx>,\n                               predicates: &ty::GenericPredicates<'tcx>) {\n-        self.encode_generics(rbml_w, &scheme.generics, &predicates);\n-        self.encode_type(rbml_w, scheme.ty);\n+        self.encode_generics(&scheme.generics, &predicates);\n+        self.encode_type(scheme.ty);\n     }\n }\n \n@@ -164,47 +161,44 @@ fn write_closure_type<'a, 'tcx>(ecx: &EncodeContext<'a, 'tcx>,\n     rbml_w.mark_stable_position();\n }\n \n-impl<'a, 'tcx> ItemContentBuilder<'a, 'tcx> {\n+impl<'a, 'tcx, 'encoder> ItemContentBuilder<'a, 'tcx, 'encoder> {\n     fn encode_type(&mut self,\n-                   rbml_w: &mut Encoder,\n                    typ: Ty<'tcx>) {\n-        rbml_w.start_tag(tag_items_data_item_type);\n-        tyencode::enc_ty(rbml_w.writer, &self.ecx().ty_str_ctxt(), typ);\n-        rbml_w.mark_stable_position();\n-        rbml_w.end_tag();\n+        let ecx = self.ecx;\n+        self.rbml_w.start_tag(tag_items_data_item_type);\n+        tyencode::enc_ty(self.rbml_w.writer, &ecx.ty_str_ctxt(), typ);\n+        self.rbml_w.mark_stable_position();\n+        self.rbml_w.end_tag();\n     }\n \n     fn encode_disr_val(&mut self,\n-                       rbml_w: &mut Encoder,\n                        disr_val: ty::Disr) {\n         // convert to u64 so just the number is printed, without any type info\n-        rbml_w.wr_tagged_str(tag_disr_val, &disr_val.to_u64_unchecked().to_string());\n+        self.rbml_w.wr_tagged_str(tag_disr_val, &disr_val.to_u64_unchecked().to_string());\n     }\n \n-    fn encode_parent_item(&mut self, rbml_w: &mut Encoder, id: DefId) {\n-        rbml_w.wr_tagged_u64(tag_items_data_parent_item, def_to_u64(id));\n+    fn encode_parent_item(&mut self, id: DefId) {\n+        self.rbml_w.wr_tagged_u64(tag_items_data_parent_item, def_to_u64(id));\n     }\n \n     fn encode_struct_fields(&mut self,\n-                            rbml_w: &mut Encoder,\n                             variant: ty::VariantDef) {\n         for f in &variant.fields {\n             if variant.kind == ty::VariantKind::Tuple {\n-                rbml_w.start_tag(tag_item_unnamed_field);\n+                self.rbml_w.start_tag(tag_item_unnamed_field);\n             } else {\n-                rbml_w.start_tag(tag_item_field);\n-                encode_name(rbml_w, f.name);\n+                self.rbml_w.start_tag(tag_item_field);\n+                encode_name(self.rbml_w, f.name);\n             }\n-            self.encode_struct_field_family(rbml_w, f.vis);\n-            encode_def_id(rbml_w, f.did);\n-            rbml_w.end_tag();\n+            self.encode_struct_field_family(f.vis);\n+            encode_def_id(self.rbml_w, f.did);\n+            self.rbml_w.end_tag();\n         }\n     }\n }\n \n-impl<'a, 'tcx> IndexBuilder<'a, 'tcx> {\n+impl<'a, 'tcx, 'encoder> IndexBuilder<'a, 'tcx, 'encoder> {\n     fn encode_enum_variant_info(&mut self,\n-                                rbml_w: &mut Encoder,\n                                 did: DefId,\n                                 vis: &hir::Visibility) {\n         debug!(\"encode_enum_variant_info(did={:?})\", did);\n@@ -218,37 +212,37 @@ impl<'a, 'tcx> IndexBuilder<'a, 'tcx> {\n             let variant_node_id = ecx.local_id(vid);\n \n             for field in &variant.fields {\n-                self.encode_field(rbml_w, field);\n+                self.encode_field(field);\n             }\n \n-            self.record(vid, rbml_w, |this, rbml_w| {\n-                encode_def_id_and_key(ecx, rbml_w, vid);\n-                encode_family(rbml_w, match variant.kind {\n+            self.record(vid, |this| {\n+                encode_def_id_and_key(ecx, this.rbml_w, vid);\n+                encode_family(this.rbml_w, match variant.kind {\n                     ty::VariantKind::Struct => 'V',\n                     ty::VariantKind::Tuple => 'v',\n                     ty::VariantKind::Unit => 'w',\n                 });\n-                encode_name(rbml_w, variant.name);\n-                this.encode_parent_item(rbml_w, did);\n-                this.encode_visibility(rbml_w, vis);\n+                encode_name(this.rbml_w, variant.name);\n+                this.encode_parent_item(did);\n+                this.encode_visibility(vis);\n \n                 let attrs = ecx.tcx.get_attrs(vid);\n-                encode_attributes(rbml_w, &attrs);\n-                this.encode_repr_attrs(rbml_w, &attrs);\n+                encode_attributes(this.rbml_w, &attrs);\n+                this.encode_repr_attrs(&attrs);\n \n                 let stab = ecx.tcx.lookup_stability(vid);\n                 let depr = ecx.tcx.lookup_deprecation(vid);\n-                encode_stability(rbml_w, stab);\n-                encode_deprecation(rbml_w, depr);\n+                encode_stability(this.rbml_w, stab);\n+                encode_deprecation(this.rbml_w, depr);\n \n-                this.encode_struct_fields(rbml_w, variant);\n+                this.encode_struct_fields(variant);\n \n                 let specified_disr_val = variant.disr_val;\n                 if specified_disr_val != disr_val {\n-                    this.encode_disr_val(rbml_w, specified_disr_val);\n+                    this.encode_disr_val(specified_disr_val);\n                     disr_val = specified_disr_val;\n                 }\n-                this.encode_bounds_and_type_for_item(rbml_w, variant_node_id);\n+                this.encode_bounds_and_type_for_item(variant_node_id);\n             });\n \n             disr_val = disr_val.wrap_incr();\n@@ -302,57 +296,56 @@ fn encode_reexports(ecx: &EncodeContext,\n     }\n }\n \n-impl<'a, 'tcx> ItemContentBuilder<'a, 'tcx> {\n+impl<'a, 'tcx, 'encoder> ItemContentBuilder<'a, 'tcx, 'encoder> {\n     fn encode_info_for_mod(&mut self,\n-                           rbml_w: &mut Encoder,\n                            md: &hir::Mod,\n                            attrs: &[ast::Attribute],\n                            id: NodeId,\n                            name: Name,\n                            vis: &hir::Visibility) {\n         let ecx = self.ecx();\n \n-        encode_def_id_and_key(ecx, rbml_w, ecx.tcx.map.local_def_id(id));\n-        encode_family(rbml_w, 'm');\n-        encode_name(rbml_w, name);\n+        encode_def_id_and_key(ecx, self.rbml_w, ecx.tcx.map.local_def_id(id));\n+        encode_family(self.rbml_w, 'm');\n+        encode_name(self.rbml_w, name);\n         debug!(\"(encoding info for module) encoding info for module ID {}\", id);\n \n         // Encode info about all the module children.\n         for item_id in &md.item_ids {\n-            rbml_w.wr_tagged_u64(tag_mod_child,\n+            self.rbml_w.wr_tagged_u64(tag_mod_child,\n                                  def_to_u64(ecx.tcx.map.local_def_id(item_id.id)));\n \n             let item = ecx.tcx.map.expect_item(item_id.id);\n             each_auxiliary_node_id(item, |auxiliary_node_id| {\n-                rbml_w.wr_tagged_u64(tag_mod_child,\n+                self.rbml_w.wr_tagged_u64(tag_mod_child,\n                                      def_to_u64(ecx.tcx.map.local_def_id(auxiliary_node_id)));\n                 true\n             });\n         }\n \n-        self.encode_visibility(rbml_w, vis);\n+        self.encode_visibility(vis);\n \n         let stab = ecx.tcx.lookup_stability(ecx.tcx.map.local_def_id(id));\n         let depr = ecx.tcx.lookup_deprecation(ecx.tcx.map.local_def_id(id));\n-        encode_stability(rbml_w, stab);\n-        encode_deprecation(rbml_w, depr);\n+        encode_stability(self.rbml_w, stab);\n+        encode_deprecation(self.rbml_w, depr);\n \n         // Encode the reexports of this module, if this module is public.\n         if *vis == hir::Public {\n             debug!(\"(encoding info for module) encoding reexports for {}\", id);\n-            encode_reexports(ecx, rbml_w, id);\n+            encode_reexports(ecx, self.rbml_w, id);\n         }\n-        encode_attributes(rbml_w, attrs);\n+        encode_attributes(self.rbml_w, attrs);\n     }\n \n-    fn encode_struct_field_family(&mut self, rbml_w: &mut Encoder,\n+    fn encode_struct_field_family(&mut self,\n                                   visibility: ty::Visibility) {\n-        encode_family(rbml_w, if visibility.is_public() { 'g' } else { 'N' });\n+        encode_family(self.rbml_w, if visibility.is_public() { 'g' } else { 'N' });\n     }\n \n-    fn encode_visibility<T: HasVisibility>(&mut self, rbml_w: &mut Encoder, visibility: T) {\n+    fn encode_visibility<T: HasVisibility>(&mut self, visibility: T) {\n         let ch = if visibility.is_public() { 'y' } else { 'i' };\n-        rbml_w.wr_tagged_u8(tag_items_data_item_visibility, ch as u8);\n+        self.rbml_w.wr_tagged_u8(tag_items_data_item_visibility, ch as u8);\n     }\n }\n \n@@ -424,116 +417,110 @@ fn encode_item_sort(rbml_w: &mut Encoder, sort: char) {\n     rbml_w.wr_tagged_u8(tag_item_trait_item_sort, sort as u8);\n }\n \n-impl<'a, 'tcx> IndexBuilder<'a, 'tcx> {\n+impl<'a, 'tcx, 'encoder> IndexBuilder<'a, 'tcx, 'encoder> {\n     fn encode_field(&mut self,\n-                    rbml_w: &mut Encoder,\n                     field: ty::FieldDef<'tcx>) {\n         let ecx = self.ecx();\n \n         let nm = field.name;\n         let id = ecx.local_id(field.did);\n \n-        self.record(field.did, rbml_w, |this, rbml_w| {\n+        self.record(field.did, |this| {\n             debug!(\"encode_field: encoding {} {}\", nm, id);\n-            this.encode_struct_field_family(rbml_w, field.vis);\n-            encode_name(rbml_w, nm);\n-            this.encode_bounds_and_type_for_item(rbml_w, id);\n-            encode_def_id_and_key(ecx, rbml_w, field.did);\n+            this.encode_struct_field_family(field.vis);\n+            encode_name(this.rbml_w, nm);\n+            this.encode_bounds_and_type_for_item(id);\n+            encode_def_id_and_key(ecx, this.rbml_w, field.did);\n \n             let stab = ecx.tcx.lookup_stability(field.did);\n             let depr = ecx.tcx.lookup_deprecation(field.did);\n-            encode_stability(rbml_w, stab);\n-            encode_deprecation(rbml_w, depr);\n+            encode_stability(this.rbml_w, stab);\n+            encode_deprecation(this.rbml_w, depr);\n         });\n     }\n }\n \n-impl<'a, 'tcx> IndexBuilder<'a, 'tcx> {\n+impl<'a, 'tcx, 'encoder> IndexBuilder<'a, 'tcx, 'encoder> {\n     fn encode_info_for_struct_ctor(&mut self,\n-                                   rbml_w: &mut Encoder,\n                                    name: Name,\n                                    struct_def: &hir::VariantData,\n                                    struct_id: NodeId) {\n         let ecx = self.ecx();\n         let ctor_id = struct_def.id();\n         let ctor_def_id = ecx.tcx.map.local_def_id(ctor_id);\n \n-        self.record(ctor_def_id, rbml_w, |this, rbml_w| {\n-            encode_def_id_and_key(ecx, rbml_w, ctor_def_id);\n-            encode_family(rbml_w, match *struct_def {\n+        self.record(ctor_def_id, |this| {\n+            encode_def_id_and_key(ecx, this.rbml_w, ctor_def_id);\n+            encode_family(this.rbml_w, match *struct_def {\n                 hir::VariantData::Struct(..) => 'S',\n                 hir::VariantData::Tuple(..) => 's',\n                 hir::VariantData::Unit(..) => 'u',\n             });\n-            this.encode_bounds_and_type_for_item(rbml_w, ctor_id);\n-            encode_name(rbml_w, name);\n-            this.encode_parent_item(rbml_w, ecx.tcx.map.local_def_id(struct_id));\n+            this.encode_bounds_and_type_for_item(ctor_id);\n+            encode_name(this.rbml_w, name);\n+            this.encode_parent_item(ecx.tcx.map.local_def_id(struct_id));\n \n             let stab = ecx.tcx.lookup_stability(ecx.tcx.map.local_def_id(ctor_id));\n             let depr = ecx.tcx.lookup_deprecation(ecx.tcx.map.local_def_id(ctor_id));\n-            encode_stability(rbml_w, stab);\n-            encode_deprecation(rbml_w, depr);\n+            encode_stability(this.rbml_w, stab);\n+            encode_deprecation(this.rbml_w, depr);\n \n             // indicate that this is a tuple struct ctor, because\n             // downstream users will normally want the tuple struct\n             // definition, but without this there is no way for them\n             // to tell that they actually have a ctor rather than a\n             // normal function\n-            rbml_w.wr_tagged_bytes(tag_items_data_item_is_tuple_struct_ctor, &[]);\n+            this.rbml_w.wr_tagged_bytes(tag_items_data_item_is_tuple_struct_ctor, &[]);\n         });\n     }\n }\n \n-impl<'a, 'tcx> ItemContentBuilder<'a, 'tcx> {\n+impl<'a, 'tcx, 'encoder> ItemContentBuilder<'a, 'tcx, 'encoder> {\n     fn encode_generics(&mut self,\n-                       rbml_w: &mut Encoder,\n                        generics: &ty::Generics<'tcx>,\n                        predicates: &ty::GenericPredicates<'tcx>)\n     {\n         let ecx = self.ecx();\n-        rbml_w.start_tag(tag_item_generics);\n-        tyencode::enc_generics(rbml_w.writer, &ecx.ty_str_ctxt(), generics);\n-        rbml_w.mark_stable_position();\n-        rbml_w.end_tag();\n-        self.encode_predicates(rbml_w, predicates, tag_item_predicates);\n+        self.rbml_w.start_tag(tag_item_generics);\n+        tyencode::enc_generics(self.rbml_w.writer, &ecx.ty_str_ctxt(), generics);\n+        self.rbml_w.mark_stable_position();\n+        self.rbml_w.end_tag();\n+        self.encode_predicates(predicates, tag_item_predicates);\n     }\n \n     fn encode_predicates(&mut self,\n-                         rbml_w: &mut Encoder,\n                          predicates: &ty::GenericPredicates<'tcx>,\n                          tag: usize) {\n-        rbml_w.start_tag(tag);\n+        self.rbml_w.start_tag(tag);\n         if let Some(def_id) = predicates.parent {\n-            rbml_w.wr_tagged_u64(tag_items_data_parent_item, def_to_u64(def_id));\n+            self.rbml_w.wr_tagged_u64(tag_items_data_parent_item, def_to_u64(def_id));\n         }\n         for predicate in &predicates.predicates {\n-            rbml_w.wr_tagged_u32(tag_predicate,\n-                                 self.add_xref(XRef::Predicate(predicate.clone())));\n+            let xref = self.add_xref(XRef::Predicate(predicate.clone()));\n+            self.rbml_w.wr_tagged_u32(tag_predicate, xref);\n         }\n-        rbml_w.end_tag();\n+        self.rbml_w.end_tag();\n     }\n \n     fn encode_method_ty_fields(&mut self,\n-                               rbml_w: &mut Encoder,\n                                method_ty: &ty::Method<'tcx>) {\n         let ecx = self.ecx();\n-        encode_def_id_and_key(ecx, rbml_w, method_ty.def_id);\n-        encode_name(rbml_w, method_ty.name);\n-        self.encode_generics(rbml_w, &method_ty.generics, &method_ty.predicates);\n-        self.encode_visibility(rbml_w, method_ty.vis);\n-        encode_explicit_self(rbml_w, &method_ty.explicit_self);\n+        encode_def_id_and_key(ecx, self.rbml_w, method_ty.def_id);\n+        encode_name(self.rbml_w, method_ty.name);\n+        self.encode_generics(&method_ty.generics, &method_ty.predicates);\n+        self.encode_visibility(method_ty.vis);\n+        encode_explicit_self(self.rbml_w, &method_ty.explicit_self);\n         match method_ty.explicit_self {\n             ty::ExplicitSelfCategory::Static => {\n-                encode_family(rbml_w, STATIC_METHOD_FAMILY);\n+                encode_family(self.rbml_w, STATIC_METHOD_FAMILY);\n             }\n-            _ => encode_family(rbml_w, METHOD_FAMILY)\n+            _ => encode_family(self.rbml_w, METHOD_FAMILY)\n         }\n     }\n }\n \n-impl<'a, 'tcx> IndexBuilder<'a, 'tcx> {\n+impl<'a, 'tcx, 'encoder> IndexBuilder<'a, 'tcx, 'encoder> {\n     fn encode_info_for_associated_const(&mut self,\n-                                        rbml_w: &mut Encoder,\n                                         associated_const: &ty::AssociatedConst,\n                                         parent_id: NodeId,\n                                         impl_item_opt: Option<&hir::ImplItem>) {\n@@ -542,36 +529,35 @@ impl<'a, 'tcx> IndexBuilder<'a, 'tcx> {\n                associated_const.def_id,\n                associated_const.name);\n \n-        self.record(associated_const.def_id, rbml_w, |this, rbml_w| {\n-            encode_def_id_and_key(ecx, rbml_w, associated_const.def_id);\n-            encode_name(rbml_w, associated_const.name);\n-            this.encode_visibility(rbml_w, associated_const.vis);\n-            encode_family(rbml_w, 'C');\n+        self.record(associated_const.def_id, |this| {\n+            encode_def_id_and_key(ecx, this.rbml_w, associated_const.def_id);\n+            encode_name(this.rbml_w, associated_const.name);\n+            this.encode_visibility(associated_const.vis);\n+            encode_family(this.rbml_w, 'C');\n \n-            this.encode_parent_item(rbml_w, ecx.tcx.map.local_def_id(parent_id));\n-            encode_item_sort(rbml_w, 'C');\n+            this.encode_parent_item(ecx.tcx.map.local_def_id(parent_id));\n+            encode_item_sort(this.rbml_w, 'C');\n \n-            this.encode_bounds_and_type_for_item(rbml_w, ecx.local_id(associated_const.def_id));\n+            this.encode_bounds_and_type_for_item(ecx.local_id(associated_const.def_id));\n \n             let stab = ecx.tcx.lookup_stability(associated_const.def_id);\n             let depr = ecx.tcx.lookup_deprecation(associated_const.def_id);\n-            encode_stability(rbml_w, stab);\n-            encode_deprecation(rbml_w, depr);\n+            encode_stability(this.rbml_w, stab);\n+            encode_deprecation(this.rbml_w, depr);\n \n             if let Some(ii) = impl_item_opt {\n-                encode_attributes(rbml_w, &ii.attrs);\n-                encode_defaultness(rbml_w, ii.defaultness);\n+                encode_attributes(this.rbml_w, &ii.attrs);\n+                encode_defaultness(this.rbml_w, ii.defaultness);\n                 encode_inlined_item(ecx,\n-                                    rbml_w,\n+                                    this.rbml_w,\n                                     InlinedItemRef::ImplItem(ecx.tcx.map.local_def_id(parent_id),\n                                                              ii));\n-                this.encode_mir(rbml_w, ii.id);\n+                this.encode_mir(ii.id);\n             }\n         });\n     }\n \n     fn encode_info_for_method(&mut self,\n-                              rbml_w: &mut Encoder,\n                               m: &ty::Method<'tcx>,\n                               is_default_impl: bool,\n                               parent_id: NodeId,\n@@ -580,44 +566,43 @@ impl<'a, 'tcx> IndexBuilder<'a, 'tcx> {\n \n         debug!(\"encode_info_for_method: {:?} {:?}\", m.def_id,\n                m.name);\n-        self.record(m.def_id, rbml_w, |this, rbml_w| {\n-            this.encode_method_ty_fields(rbml_w, m);\n-            this.encode_parent_item(rbml_w, ecx.tcx.map.local_def_id(parent_id));\n-            encode_item_sort(rbml_w, 'r');\n+        self.record(m.def_id, |this| {\n+            this.encode_method_ty_fields(m);\n+            this.encode_parent_item(ecx.tcx.map.local_def_id(parent_id));\n+            encode_item_sort(this.rbml_w, 'r');\n \n             let stab = ecx.tcx.lookup_stability(m.def_id);\n             let depr = ecx.tcx.lookup_deprecation(m.def_id);\n-            encode_stability(rbml_w, stab);\n-            encode_deprecation(rbml_w, depr);\n+            encode_stability(this.rbml_w, stab);\n+            encode_deprecation(this.rbml_w, depr);\n \n             let m_node_id = ecx.local_id(m.def_id);\n-            this.encode_bounds_and_type_for_item(rbml_w, m_node_id);\n+            this.encode_bounds_and_type_for_item(m_node_id);\n \n             if let Some(impl_item) = impl_item_opt {\n                 if let hir::ImplItemKind::Method(ref sig, _) = impl_item.node {\n-                    encode_attributes(rbml_w, &impl_item.attrs);\n+                    encode_attributes(this.rbml_w, &impl_item.attrs);\n                     let generics = ecx.tcx.lookup_generics(m.def_id);\n                     let types = generics.parent_types as usize + generics.types.len();\n                     let needs_inline = types > 0 || is_default_impl ||\n                         attr::requests_inline(&impl_item.attrs);\n                     if needs_inline || sig.constness == hir::Constness::Const {\n                         encode_inlined_item(\n                             ecx,\n-                            rbml_w,\n+                            this.rbml_w,\n                             InlinedItemRef::ImplItem(ecx.tcx.map.local_def_id(parent_id),\n                                                      impl_item));\n-                        this.encode_mir(rbml_w, impl_item.id);\n+                        this.encode_mir(impl_item.id);\n                     }\n-                    encode_constness(rbml_w, sig.constness);\n-                    encode_defaultness(rbml_w, impl_item.defaultness);\n-                    this.encode_method_argument_names(rbml_w, &sig.decl);\n+                    encode_constness(this.rbml_w, sig.constness);\n+                    encode_defaultness(this.rbml_w, impl_item.defaultness);\n+                    this.encode_method_argument_names(&sig.decl);\n                 }\n             }\n         });\n     }\n \n     fn encode_info_for_associated_type(&mut self,\n-                                       rbml_w: &mut Encoder,\n                                        associated_type: &ty::AssociatedType<'tcx>,\n                                        parent_id: NodeId,\n                                        impl_item_opt: Option<&hir::ImplItem>) {\n@@ -626,78 +611,75 @@ impl<'a, 'tcx> IndexBuilder<'a, 'tcx> {\n                associated_type.def_id,\n                associated_type.name);\n \n-        self.record(associated_type.def_id, rbml_w, |this, rbml_w| {\n-            encode_def_id_and_key(ecx, rbml_w, associated_type.def_id);\n-            encode_name(rbml_w, associated_type.name);\n-            this.encode_visibility(rbml_w, associated_type.vis);\n-            encode_family(rbml_w, 'y');\n-            this.encode_parent_item(rbml_w, ecx.tcx.map.local_def_id(parent_id));\n-            encode_item_sort(rbml_w, 't');\n+        self.record(associated_type.def_id, |this| {\n+            encode_def_id_and_key(ecx, this.rbml_w, associated_type.def_id);\n+            encode_name(this.rbml_w, associated_type.name);\n+            this.encode_visibility(associated_type.vis);\n+            encode_family(this.rbml_w, 'y');\n+            this.encode_parent_item(ecx.tcx.map.local_def_id(parent_id));\n+            encode_item_sort(this.rbml_w, 't');\n \n             let stab = ecx.tcx.lookup_stability(associated_type.def_id);\n             let depr = ecx.tcx.lookup_deprecation(associated_type.def_id);\n-            encode_stability(rbml_w, stab);\n-            encode_deprecation(rbml_w, depr);\n+            encode_stability(this.rbml_w, stab);\n+            encode_deprecation(this.rbml_w, depr);\n \n             if let Some(ii) = impl_item_opt {\n-                encode_attributes(rbml_w, &ii.attrs);\n-                encode_defaultness(rbml_w, ii.defaultness);\n+                encode_attributes(this.rbml_w, &ii.attrs);\n+                encode_defaultness(this.rbml_w, ii.defaultness);\n             } else {\n                 // TODO this looks bogus and unnecessary\n-                this.encode_predicates(rbml_w,\n-                                       &ecx.tcx.lookup_predicates(associated_type.def_id),\n+                this.encode_predicates(&ecx.tcx.lookup_predicates(associated_type.def_id),\n                                        tag_item_generics);\n             }\n \n             if let Some(ty) = associated_type.ty {\n-                this.encode_type(rbml_w, ty);\n+                this.encode_type(ty);\n             }\n         });\n     }\n }\n \n-impl<'a, 'tcx> ItemContentBuilder<'a, 'tcx> {\n+impl<'a, 'tcx, 'encoder> ItemContentBuilder<'a, 'tcx, 'encoder> {\n     fn encode_method_argument_names(&mut self,\n-                                    rbml_w: &mut Encoder,\n                                     decl: &hir::FnDecl) {\n-        rbml_w.start_tag(tag_method_argument_names);\n+        self.rbml_w.start_tag(tag_method_argument_names);\n         for arg in &decl.inputs {\n             let tag = tag_method_argument_name;\n             if let PatKind::Binding(_, ref path1, _) = arg.pat.node {\n                 let name = path1.node.as_str();\n-                rbml_w.wr_tagged_bytes(tag, name.as_bytes());\n+                self.rbml_w.wr_tagged_bytes(tag, name.as_bytes());\n             } else {\n-                rbml_w.wr_tagged_bytes(tag, &[]);\n+                self.rbml_w.wr_tagged_bytes(tag, &[]);\n             }\n         }\n-        rbml_w.end_tag();\n+        self.rbml_w.end_tag();\n     }\n \n     fn encode_repr_attrs(&mut self,\n-                         rbml_w: &mut Encoder,\n                          attrs: &[ast::Attribute]) {\n         let ecx = self.ecx();\n         let mut repr_attrs = Vec::new();\n         for attr in attrs {\n             repr_attrs.extend(attr::find_repr_attrs(ecx.tcx.sess.diagnostic(),\n                                                     attr));\n         }\n-        rbml_w.start_tag(tag_items_data_item_repr);\n-        repr_attrs.encode(rbml_w);\n-        rbml_w.end_tag();\n+        self.rbml_w.start_tag(tag_items_data_item_repr);\n+        repr_attrs.encode(self.rbml_w);\n+        self.rbml_w.end_tag();\n     }\n \n-    fn encode_mir(&mut self, rbml_w: &mut Encoder, node_id: NodeId) {\n+    fn encode_mir(&mut self, node_id: NodeId) {\n         let ecx = self.ecx();\n         let def_id = ecx.tcx.map.local_def_id(node_id);\n         if let Some(mir) = ecx.mir_map.map.get(&def_id) {\n-            rbml_w.start_tag(tag_mir as usize);\n-            rbml_w.emit_opaque(|opaque_encoder| {\n+            self.rbml_w.start_tag(tag_mir as usize);\n+            self.rbml_w.emit_opaque(|opaque_encoder| {\n                 tls::enter_encoding_context(ecx, opaque_encoder, |_, opaque_encoder| {\n                     Encodable::encode(mir, opaque_encoder)\n                 })\n             }).unwrap();\n-            rbml_w.end_tag();\n+            self.rbml_w.end_tag();\n         }\n     }\n }\n@@ -766,9 +748,8 @@ fn encode_xrefs<'a, 'tcx>(ecx: &EncodeContext<'a, 'tcx>,\n     rbml_w.end_tag();\n }\n \n-impl<'a, 'tcx> IndexBuilder<'a, 'tcx> {\n+impl<'a, 'tcx, 'encoder> IndexBuilder<'a, 'tcx, 'encoder> {\n     fn encode_info_for_item(&mut self,\n-                            rbml_w: &mut Encoder,\n                             item: &hir::Item) {\n         let ecx = self.ecx();\n         let tcx = ecx.tcx;\n@@ -786,178 +767,175 @@ impl<'a, 'tcx> IndexBuilder<'a, 'tcx> {\n \n         match item.node {\n             hir::ItemStatic(_, m, _) => {\n-                self.record(def_id, rbml_w, |this, rbml_w| {\n-                    encode_def_id_and_key(ecx, rbml_w, def_id);\n+                self.record(def_id, |this| {\n+                    encode_def_id_and_key(ecx, this.rbml_w, def_id);\n                     if m == hir::MutMutable {\n-                        encode_family(rbml_w, 'b');\n+                        encode_family(this.rbml_w, 'b');\n                     } else {\n-                        encode_family(rbml_w, 'c');\n+                        encode_family(this.rbml_w, 'c');\n                     }\n-                    this.encode_bounds_and_type_for_item(rbml_w, item.id);\n-                    encode_name(rbml_w, item.name);\n-                    this.encode_visibility(rbml_w, vis);\n-                    encode_stability(rbml_w, stab);\n-                    encode_deprecation(rbml_w, depr);\n-                    encode_attributes(rbml_w, &item.attrs);\n+                    this.encode_bounds_and_type_for_item(item.id);\n+                    encode_name(this.rbml_w, item.name);\n+                    this.encode_visibility(vis);\n+                    encode_stability(this.rbml_w, stab);\n+                    encode_deprecation(this.rbml_w, depr);\n+                    encode_attributes(this.rbml_w, &item.attrs);\n                 });\n             }\n             hir::ItemConst(_, _) => {\n-                self.record(def_id, rbml_w, |this, rbml_w| {\n-                    encode_def_id_and_key(ecx, rbml_w, def_id);\n-                    encode_family(rbml_w, 'C');\n-                    this.encode_bounds_and_type_for_item(rbml_w, item.id);\n-                    encode_name(rbml_w, item.name);\n-                    encode_attributes(rbml_w, &item.attrs);\n-                    encode_inlined_item(ecx, rbml_w, InlinedItemRef::Item(def_id, item));\n-                    this.encode_mir(rbml_w, item.id);\n-                    this.encode_visibility(rbml_w, vis);\n-                    encode_stability(rbml_w, stab);\n-                    encode_deprecation(rbml_w, depr);\n+                self.record(def_id, |this| {\n+                    encode_def_id_and_key(ecx, this.rbml_w, def_id);\n+                    encode_family(this.rbml_w, 'C');\n+                    this.encode_bounds_and_type_for_item(item.id);\n+                    encode_name(this.rbml_w, item.name);\n+                    encode_attributes(this.rbml_w, &item.attrs);\n+                    encode_inlined_item(ecx, this.rbml_w, InlinedItemRef::Item(def_id, item));\n+                    this.encode_mir(item.id);\n+                    this.encode_visibility(vis);\n+                    encode_stability(this.rbml_w, stab);\n+                    encode_deprecation(this.rbml_w, depr);\n                 });\n             }\n             hir::ItemFn(ref decl, _, constness, _, ref generics, _) => {\n-                self.record(def_id, rbml_w, |this, rbml_w| {\n-                    encode_def_id_and_key(ecx, rbml_w, def_id);\n-                    encode_family(rbml_w, FN_FAMILY);\n+                self.record(def_id, |this| {\n+                    encode_def_id_and_key(ecx, this.rbml_w, def_id);\n+                    encode_family(this.rbml_w, FN_FAMILY);\n                     let tps_len = generics.ty_params.len();\n-                    this.encode_bounds_and_type_for_item(rbml_w, item.id);\n-                    encode_name(rbml_w, item.name);\n-                    encode_attributes(rbml_w, &item.attrs);\n+                    this.encode_bounds_and_type_for_item(item.id);\n+                    encode_name(this.rbml_w, item.name);\n+                    encode_attributes(this.rbml_w, &item.attrs);\n                     let needs_inline = tps_len > 0 || attr::requests_inline(&item.attrs);\n                     if needs_inline || constness == hir::Constness::Const {\n-                        encode_inlined_item(ecx, rbml_w, InlinedItemRef::Item(def_id, item));\n-                        this.encode_mir(rbml_w, item.id);\n+                        encode_inlined_item(ecx, this.rbml_w, InlinedItemRef::Item(def_id, item));\n+                        this.encode_mir(item.id);\n                     }\n-                    encode_constness(rbml_w, constness);\n-                    this.encode_visibility(rbml_w, vis);\n-                    encode_stability(rbml_w, stab);\n-                    encode_deprecation(rbml_w, depr);\n-                    this.encode_method_argument_names(rbml_w, &decl);\n+                    encode_constness(this.rbml_w, constness);\n+                    this.encode_visibility(vis);\n+                    encode_stability(this.rbml_w, stab);\n+                    encode_deprecation(this.rbml_w, depr);\n+                    this.encode_method_argument_names(&decl);\n                 });\n             }\n             hir::ItemMod(ref m) => {\n-                self.record(def_id, rbml_w, |this, rbml_w| {\n-                    this.encode_info_for_mod(rbml_w,\n-                                             m,\n+                self.record(def_id, |this| {\n+                    this.encode_info_for_mod(m,\n                                              &item.attrs,\n                                              item.id,\n                                              item.name,\n                                              &item.vis);\n                 });\n             }\n             hir::ItemForeignMod(ref fm) => {\n-                self.record(def_id, rbml_w, |this, rbml_w| {\n-                    encode_def_id_and_key(ecx, rbml_w, def_id);\n-                    encode_family(rbml_w, 'n');\n-                    encode_name(rbml_w, item.name);\n+                self.record(def_id, |this| {\n+                    encode_def_id_and_key(ecx, this.rbml_w, def_id);\n+                    encode_family(this.rbml_w, 'n');\n+                    encode_name(this.rbml_w, item.name);\n \n                     // Encode all the items in this module.\n                     for foreign_item in &fm.items {\n-                        rbml_w.wr_tagged_u64(tag_mod_child,\n+                        this.rbml_w.wr_tagged_u64(tag_mod_child,\n                                              def_to_u64(ecx.tcx.map.local_def_id(foreign_item.id)));\n                     }\n-                    this.encode_visibility(rbml_w, vis);\n-                    encode_stability(rbml_w, stab);\n-                    encode_deprecation(rbml_w, depr);\n+                    this.encode_visibility(vis);\n+                    encode_stability(this.rbml_w, stab);\n+                    encode_deprecation(this.rbml_w, depr);\n                 });\n             }\n             hir::ItemTy(..) => {\n-                self.record(def_id, rbml_w, |this, rbml_w| {\n-                    encode_def_id_and_key(ecx, rbml_w, def_id);\n-                    encode_family(rbml_w, 'y');\n-                    this.encode_bounds_and_type_for_item(rbml_w, item.id);\n-                    encode_name(rbml_w, item.name);\n-                    this.encode_visibility(rbml_w, vis);\n-                    encode_stability(rbml_w, stab);\n-                    encode_deprecation(rbml_w, depr);\n+                self.record(def_id, |this| {\n+                    encode_def_id_and_key(ecx, this.rbml_w, def_id);\n+                    encode_family(this.rbml_w, 'y');\n+                    this.encode_bounds_and_type_for_item(item.id);\n+                    encode_name(this.rbml_w, item.name);\n+                    this.encode_visibility(vis);\n+                    encode_stability(this.rbml_w, stab);\n+                    encode_deprecation(this.rbml_w, depr);\n                 });\n             }\n             hir::ItemEnum(ref enum_definition, _) => {\n-                self.record(def_id, rbml_w, |this, rbml_w| {\n-                    encode_def_id_and_key(ecx, rbml_w, def_id);\n-                    encode_family(rbml_w, 't');\n-                    encode_item_variances(rbml_w, ecx, item.id);\n-                    this.encode_bounds_and_type_for_item(rbml_w, item.id);\n-                    encode_name(rbml_w, item.name);\n-                    encode_attributes(rbml_w, &item.attrs);\n-                    this.encode_repr_attrs(rbml_w, &item.attrs);\n+                self.record(def_id, |this| {\n+                    encode_def_id_and_key(ecx, this.rbml_w, def_id);\n+                    encode_family(this.rbml_w, 't');\n+                    encode_item_variances(this.rbml_w, ecx, item.id);\n+                    this.encode_bounds_and_type_for_item(item.id);\n+                    encode_name(this.rbml_w, item.name);\n+                    encode_attributes(this.rbml_w, &item.attrs);\n+                    this.encode_repr_attrs(&item.attrs);\n                     for v in &enum_definition.variants {\n-                        encode_variant_id(rbml_w, ecx.tcx.map.local_def_id(v.node.data.id()));\n+                        encode_variant_id(this.rbml_w, ecx.tcx.map.local_def_id(v.node.data.id()));\n                     }\n-                    encode_inlined_item(ecx, rbml_w, InlinedItemRef::Item(def_id, item));\n-                    this.encode_mir(rbml_w, item.id);\n+                    encode_inlined_item(ecx, this.rbml_w, InlinedItemRef::Item(def_id, item));\n+                    this.encode_mir(item.id);\n \n                     // Encode inherent implementations for this enumeration.\n-                    encode_inherent_implementations(ecx, rbml_w, def_id);\n+                    encode_inherent_implementations(ecx, this.rbml_w, def_id);\n \n-                    this.encode_visibility(rbml_w, vis);\n-                    encode_stability(rbml_w, stab);\n-                    encode_deprecation(rbml_w, depr);\n+                    this.encode_visibility(vis);\n+                    encode_stability(this.rbml_w, stab);\n+                    encode_deprecation(this.rbml_w, depr);\n                 });\n \n-                self.encode_enum_variant_info(rbml_w,\n-                                              def_id,\n-                                              vis);\n+                self.encode_enum_variant_info(def_id, vis);\n             }\n             hir::ItemStruct(ref struct_def, _) => {\n                 /* Index the class*/\n                 let def = ecx.tcx.lookup_adt_def(def_id);\n                 let variant = def.struct_variant();\n \n-                self.record(def_id, rbml_w, |this, rbml_w| {\n+                self.record(def_id, |this| {\n                     /* Now, make an item for the class itself */\n-                    encode_def_id_and_key(ecx, rbml_w, def_id);\n-                    encode_family(rbml_w, match *struct_def {\n+                    encode_def_id_and_key(ecx, this.rbml_w, def_id);\n+                    encode_family(this.rbml_w, match *struct_def {\n                         hir::VariantData::Struct(..) => 'S',\n                         hir::VariantData::Tuple(..) => 's',\n                         hir::VariantData::Unit(..) => 'u',\n                     });\n-                    this.encode_bounds_and_type_for_item(rbml_w, item.id);\n+                    this.encode_bounds_and_type_for_item(item.id);\n \n-                    encode_item_variances(rbml_w, ecx, item.id);\n-                    encode_name(rbml_w, item.name);\n-                    encode_attributes(rbml_w, &item.attrs);\n-                    encode_stability(rbml_w, stab);\n-                    encode_deprecation(rbml_w, depr);\n-                    this.encode_visibility(rbml_w, vis);\n-                    this.encode_repr_attrs(rbml_w, &item.attrs);\n+                    encode_item_variances(this.rbml_w, ecx, item.id);\n+                    encode_name(this.rbml_w, item.name);\n+                    encode_attributes(this.rbml_w, &item.attrs);\n+                    encode_stability(this.rbml_w, stab);\n+                    encode_deprecation(this.rbml_w, depr);\n+                    this.encode_visibility(vis);\n+                    this.encode_repr_attrs(&item.attrs);\n \n                     /* Encode def_ids for each field and method\n                     for methods, write all the stuff get_trait_method\n                     needs to know*/\n-                    this.encode_struct_fields(rbml_w, variant);\n+                    this.encode_struct_fields(variant);\n \n-                    encode_inlined_item(ecx, rbml_w, InlinedItemRef::Item(def_id, item));\n-                    this.encode_mir(rbml_w, item.id);\n+                    encode_inlined_item(ecx, this.rbml_w, InlinedItemRef::Item(def_id, item));\n+                    this.encode_mir(item.id);\n \n                     // Encode inherent implementations for this structure.\n-                    encode_inherent_implementations(ecx, rbml_w, def_id);\n+                    encode_inherent_implementations(ecx, this.rbml_w, def_id);\n \n                     if !struct_def.is_struct() {\n                         let ctor_did = ecx.tcx.map.local_def_id(struct_def.id());\n-                        rbml_w.wr_tagged_u64(tag_items_data_item_struct_ctor,\n+                        this.rbml_w.wr_tagged_u64(tag_items_data_item_struct_ctor,\n                                              def_to_u64(ctor_did));\n                     }\n                 });\n \n                 for field in &variant.fields {\n-                    self.encode_field(rbml_w, field);\n+                    self.encode_field(field);\n                 }\n \n                 // If this is a tuple-like struct, encode the type of the constructor.\n                 if !struct_def.is_struct() {\n-                    self.encode_info_for_struct_ctor(rbml_w, item.name, struct_def, item.id);\n+                    self.encode_info_for_struct_ctor(item.name, struct_def, item.id);\n                 }\n             }\n             hir::ItemDefaultImpl(unsafety, _) => {\n-                self.record(def_id, rbml_w, |_this, rbml_w| {\n-                    encode_def_id_and_key(ecx, rbml_w, def_id);\n-                    encode_family(rbml_w, 'd');\n-                    encode_name(rbml_w, item.name);\n-                    encode_unsafety(rbml_w, unsafety);\n+                self.record(def_id, |this| {\n+                    encode_def_id_and_key(ecx, this.rbml_w, def_id);\n+                    encode_family(this.rbml_w, 'd');\n+                    encode_name(this.rbml_w, item.name);\n+                    encode_unsafety(this.rbml_w, unsafety);\n \n                     let trait_ref = tcx.impl_trait_ref(ecx.tcx.map.local_def_id(item.id)).unwrap();\n-                    encode_trait_ref(rbml_w, ecx, trait_ref, tag_item_trait_ref);\n+                    encode_trait_ref(this.rbml_w, ecx, trait_ref, tag_item_trait_ref);\n                 });\n             }\n             hir::ItemImpl(unsafety, polarity, _, _, _, ref ast_items) => {\n@@ -966,50 +944,50 @@ impl<'a, 'tcx> IndexBuilder<'a, 'tcx> {\n                 let impl_items = tcx.impl_items.borrow();\n                 let items = &impl_items[&def_id];\n \n-                self.record(def_id, rbml_w, |this, rbml_w| {\n-                    encode_def_id_and_key(ecx, rbml_w, def_id);\n-                    encode_family(rbml_w, 'i');\n-                    this.encode_bounds_and_type_for_item(rbml_w, item.id);\n-                    encode_name(rbml_w, item.name);\n-                    encode_attributes(rbml_w, &item.attrs);\n-                    encode_unsafety(rbml_w, unsafety);\n-                    encode_polarity(rbml_w, polarity);\n+                self.record(def_id, |this| {\n+                    encode_def_id_and_key(ecx, this.rbml_w, def_id);\n+                    encode_family(this.rbml_w, 'i');\n+                    this.encode_bounds_and_type_for_item(item.id);\n+                    encode_name(this.rbml_w, item.name);\n+                    encode_attributes(this.rbml_w, &item.attrs);\n+                    encode_unsafety(this.rbml_w, unsafety);\n+                    encode_polarity(this.rbml_w, polarity);\n \n                     match\n                         tcx.custom_coerce_unsized_kinds\n                            .borrow()\n                            .get(&ecx.tcx.map.local_def_id(item.id))\n                     {\n                         Some(&kind) => {\n-                            rbml_w.start_tag(tag_impl_coerce_unsized_kind);\n-                            kind.encode(rbml_w);\n-                            rbml_w.end_tag();\n+                            this.rbml_w.start_tag(tag_impl_coerce_unsized_kind);\n+                            kind.encode(this.rbml_w);\n+                            this.rbml_w.end_tag();\n                         }\n                         None => {}\n                     }\n \n                     for &item_def_id in items {\n-                        rbml_w.start_tag(tag_item_impl_item);\n+                        this.rbml_w.start_tag(tag_item_impl_item);\n                         match item_def_id {\n                             ty::ConstTraitItemId(item_def_id) => {\n-                                encode_def_id(rbml_w, item_def_id);\n-                                encode_item_sort(rbml_w, 'C');\n+                                encode_def_id(this.rbml_w, item_def_id);\n+                                encode_item_sort(this.rbml_w, 'C');\n                             }\n                             ty::MethodTraitItemId(item_def_id) => {\n-                                encode_def_id(rbml_w, item_def_id);\n-                                encode_item_sort(rbml_w, 'r');\n+                                encode_def_id(this.rbml_w, item_def_id);\n+                                encode_item_sort(this.rbml_w, 'r');\n                             }\n                             ty::TypeTraitItemId(item_def_id) => {\n-                                encode_def_id(rbml_w, item_def_id);\n-                                encode_item_sort(rbml_w, 't');\n+                                encode_def_id(this.rbml_w, item_def_id);\n+                                encode_item_sort(this.rbml_w, 't');\n                             }\n                         }\n-                        rbml_w.end_tag();\n+                        this.rbml_w.end_tag();\n                     }\n \n                     let did = ecx.tcx.map.local_def_id(item.id);\n                     if let Some(trait_ref) = tcx.impl_trait_ref(did) {\n-                        encode_trait_ref(rbml_w, ecx, trait_ref, tag_item_trait_ref);\n+                        encode_trait_ref(this.rbml_w, ecx, trait_ref, tag_item_trait_ref);\n \n                         let trait_def = tcx.lookup_trait_def(trait_ref.def_id);\n                         let parent = trait_def.ancestors(did)\n@@ -1020,10 +998,10 @@ impl<'a, 'tcx> IndexBuilder<'a, 'tcx> {\n                                                       Some(parent),\n                                                   _ => None,\n                                               });\n-                        encode_parent_impl(rbml_w, parent);\n+                        encode_parent_impl(this.rbml_w, parent);\n                     }\n-                    encode_stability(rbml_w, stab);\n-                    encode_deprecation(rbml_w, depr);\n+                    encode_stability(this.rbml_w, stab);\n+                    encode_deprecation(this.rbml_w, depr);\n                 });\n \n                 // Iterate down the trait items, emitting them. We rely on the\n@@ -1040,174 +1018,167 @@ impl<'a, 'tcx> IndexBuilder<'a, 'tcx> {\n \n                     match tcx.impl_or_trait_item(trait_item_def_id.def_id()) {\n                         ty::ConstTraitItem(ref associated_const) => {\n-                            self.encode_info_for_associated_const(rbml_w,\n-                                                             &associated_const,\n-                                                             item.id,\n-                                                             ast_item)\n+                            self.encode_info_for_associated_const(&associated_const,\n+                                                                  item.id,\n+                                                                  ast_item)\n                         }\n                         ty::MethodTraitItem(ref method_type) => {\n-                            self.encode_info_for_method(rbml_w,\n-                                                        &method_type,\n+                            self.encode_info_for_method(&method_type,\n                                                         false,\n                                                         item.id,\n                                                         ast_item)\n                         }\n                         ty::TypeTraitItem(ref associated_type) => {\n-                            self.encode_info_for_associated_type(rbml_w,\n-                                                                 &associated_type,\n+                            self.encode_info_for_associated_type(&associated_type,\n                                                                  item.id,\n                                                                  ast_item)\n                         }\n                     }\n                 }\n             }\n             hir::ItemTrait(_, _, _, ref ms) => {\n-                self.record(def_id, rbml_w, |this, rbml_w| {\n-                    encode_def_id_and_key(ecx, rbml_w, def_id);\n-                    encode_family(rbml_w, 'I');\n-                    encode_item_variances(rbml_w, ecx, item.id);\n+                self.record(def_id, |this| {\n+                    encode_def_id_and_key(ecx, this.rbml_w, def_id);\n+                    encode_family(this.rbml_w, 'I');\n+                    encode_item_variances(this.rbml_w, ecx, item.id);\n                     let trait_def = tcx.lookup_trait_def(def_id);\n                     let trait_predicates = tcx.lookup_predicates(def_id);\n-                    encode_unsafety(rbml_w, trait_def.unsafety);\n-                    encode_paren_sugar(rbml_w, trait_def.paren_sugar);\n-                    encode_defaulted(rbml_w, tcx.trait_has_default_impl(def_id));\n-                    encode_associated_type_names(rbml_w, &trait_def.associated_type_names);\n-                    this.encode_generics(rbml_w, &trait_def.generics, &trait_predicates);\n-                    this.encode_predicates(rbml_w,\n-                                           &tcx.lookup_super_predicates(def_id),\n+                    encode_unsafety(this.rbml_w, trait_def.unsafety);\n+                    encode_paren_sugar(this.rbml_w, trait_def.paren_sugar);\n+                    encode_defaulted(this.rbml_w, tcx.trait_has_default_impl(def_id));\n+                    encode_associated_type_names(this.rbml_w, &trait_def.associated_type_names);\n+                    this.encode_generics(&trait_def.generics, &trait_predicates);\n+                    this.encode_predicates(&tcx.lookup_super_predicates(def_id),\n                                            tag_item_super_predicates);\n-                    encode_trait_ref(rbml_w, ecx, trait_def.trait_ref, tag_item_trait_ref);\n-                    encode_name(rbml_w, item.name);\n-                    encode_attributes(rbml_w, &item.attrs);\n-                    this.encode_visibility(rbml_w, vis);\n-                    encode_stability(rbml_w, stab);\n-                    encode_deprecation(rbml_w, depr);\n+                    encode_trait_ref(this.rbml_w, ecx, trait_def.trait_ref, tag_item_trait_ref);\n+                    encode_name(this.rbml_w, item.name);\n+                    encode_attributes(this.rbml_w, &item.attrs);\n+                    this.encode_visibility(vis);\n+                    encode_stability(this.rbml_w, stab);\n+                    encode_deprecation(this.rbml_w, depr);\n                     for &method_def_id in tcx.trait_item_def_ids(def_id).iter() {\n-                        rbml_w.start_tag(tag_item_trait_item);\n+                        this.rbml_w.start_tag(tag_item_trait_item);\n                         match method_def_id {\n                             ty::ConstTraitItemId(const_def_id) => {\n-                                encode_def_id(rbml_w, const_def_id);\n-                                encode_item_sort(rbml_w, 'C');\n+                                encode_def_id(this.rbml_w, const_def_id);\n+                                encode_item_sort(this.rbml_w, 'C');\n                             }\n                             ty::MethodTraitItemId(method_def_id) => {\n-                                encode_def_id(rbml_w, method_def_id);\n-                                encode_item_sort(rbml_w, 'r');\n+                                encode_def_id(this.rbml_w, method_def_id);\n+                                encode_item_sort(this.rbml_w, 'r');\n                             }\n                             ty::TypeTraitItemId(type_def_id) => {\n-                                encode_def_id(rbml_w, type_def_id);\n-                                encode_item_sort(rbml_w, 't');\n+                                encode_def_id(this.rbml_w, type_def_id);\n+                                encode_item_sort(this.rbml_w, 't');\n                             }\n                         }\n-                        rbml_w.end_tag();\n+                        this.rbml_w.end_tag();\n \n-                        rbml_w.wr_tagged_u64(tag_mod_child,\n+                        this.rbml_w.wr_tagged_u64(tag_mod_child,\n                                              def_to_u64(method_def_id.def_id()));\n                     }\n \n                     // Encode inherent implementations for this trait.\n-                    encode_inherent_implementations(ecx, rbml_w, def_id);\n+                    encode_inherent_implementations(ecx, this.rbml_w, def_id);\n                 });\n \n                 // Now output the trait item info for each trait item.\n                 let r = tcx.trait_item_def_ids(def_id);\n                 for (i, &item_def_id) in r.iter().enumerate() {\n                     assert_eq!(item_def_id.def_id().krate, LOCAL_CRATE);\n \n-                    self.record(item_def_id.def_id(), rbml_w, |this, rbml_w| {\n-                        this.encode_parent_item(rbml_w, def_id);\n+                    self.record(item_def_id.def_id(), |this| {\n+                        this.encode_parent_item(def_id);\n \n                         let stab = tcx.lookup_stability(item_def_id.def_id());\n                         let depr = tcx.lookup_deprecation(item_def_id.def_id());\n-                        encode_stability(rbml_w, stab);\n-                        encode_deprecation(rbml_w, depr);\n+                        encode_stability(this.rbml_w, stab);\n+                        encode_deprecation(this.rbml_w, depr);\n \n                         let trait_item_type =\n                             tcx.impl_or_trait_item(item_def_id.def_id());\n                         let is_nonstatic_method;\n                         match trait_item_type {\n                             ty::ConstTraitItem(associated_const) => {\n-                                encode_name(rbml_w, associated_const.name);\n-                                encode_def_id_and_key(ecx, rbml_w, associated_const.def_id);\n-                                this.encode_visibility(rbml_w, associated_const.vis);\n+                                encode_name(this.rbml_w, associated_const.name);\n+                                encode_def_id_and_key(ecx, this.rbml_w, associated_const.def_id);\n+                                this.encode_visibility(associated_const.vis);\n \n-                                encode_family(rbml_w, 'C');\n+                                encode_family(this.rbml_w, 'C');\n \n                                 this.encode_bounds_and_type_for_item(\n-                                    rbml_w,\n                                     ecx.local_id(associated_const.def_id));\n \n                                 is_nonstatic_method = false;\n                             }\n                             ty::MethodTraitItem(method_ty) => {\n                                 let method_def_id = item_def_id.def_id();\n \n-                                this.encode_method_ty_fields(rbml_w, &method_ty);\n+                                this.encode_method_ty_fields(&method_ty);\n \n                                 match method_ty.explicit_self {\n                                     ty::ExplicitSelfCategory::Static => {\n-                                        encode_family(rbml_w,\n+                                        encode_family(this.rbml_w,\n                                                       STATIC_METHOD_FAMILY);\n                                     }\n                                     _ => {\n-                                        encode_family(rbml_w,\n+                                        encode_family(this.rbml_w,\n                                                       METHOD_FAMILY);\n                                     }\n                                 }\n-                                this.encode_bounds_and_type_for_item(rbml_w,\n-                                                                     ecx.local_id(method_def_id));\n+                                this.encode_bounds_and_type_for_item(ecx.local_id(method_def_id));\n \n                                 is_nonstatic_method = method_ty.explicit_self !=\n                                     ty::ExplicitSelfCategory::Static;\n                             }\n                             ty::TypeTraitItem(associated_type) => {\n-                                encode_name(rbml_w, associated_type.name);\n-                                encode_def_id_and_key(ecx, rbml_w, associated_type.def_id);\n-                                encode_item_sort(rbml_w, 't');\n-                                encode_family(rbml_w, 'y');\n+                                encode_name(this.rbml_w, associated_type.name);\n+                                encode_def_id_and_key(ecx, this.rbml_w, associated_type.def_id);\n+                                encode_item_sort(this.rbml_w, 't');\n+                                encode_family(this.rbml_w, 'y');\n \n                                 if let Some(ty) = associated_type.ty {\n-                                    this.encode_type(rbml_w, ty);\n+                                    this.encode_type(ty);\n                                 }\n \n                                 is_nonstatic_method = false;\n                             }\n                         }\n \n                         let trait_item = &ms[i];\n-                        encode_attributes(rbml_w, &trait_item.attrs);\n+                        encode_attributes(this.rbml_w, &trait_item.attrs);\n                         match trait_item.node {\n                             hir::ConstTraitItem(_, ref default) => {\n                                 if default.is_some() {\n-                                    encode_item_sort(rbml_w, 'C');\n+                                    encode_item_sort(this.rbml_w, 'C');\n                                 } else {\n-                                    encode_item_sort(rbml_w, 'c');\n+                                    encode_item_sort(this.rbml_w, 'c');\n                                 }\n \n-                                encode_inlined_item(ecx, rbml_w,\n+                                encode_inlined_item(ecx, this.rbml_w,\n                                                     InlinedItemRef::TraitItem(def_id, trait_item));\n-                                this.encode_mir(rbml_w, trait_item.id);\n+                                this.encode_mir(trait_item.id);\n                             }\n                             hir::MethodTraitItem(ref sig, ref body) => {\n                                 // If this is a static method, we've already\n                                 // encoded this.\n                                 if is_nonstatic_method {\n                                     this.encode_bounds_and_type_for_item(\n-                                        rbml_w,\n                                         ecx.local_id(item_def_id.def_id()));\n                                 }\n \n                                 if body.is_some() {\n-                                    encode_item_sort(rbml_w, 'p');\n+                                    encode_item_sort(this.rbml_w, 'p');\n                                     encode_inlined_item(ecx,\n-                                                        rbml_w,\n+                                                        this.rbml_w,\n                                                         InlinedItemRef::TraitItem(\n                                                             def_id,\n                                                             trait_item));\n-                                    this.encode_mir(rbml_w, trait_item.id);\n+                                    this.encode_mir(trait_item.id);\n                                 } else {\n-                                    encode_item_sort(rbml_w, 'r');\n+                                    encode_item_sort(this.rbml_w, 'r');\n                                 }\n-                                this.encode_method_argument_names(rbml_w, &sig.decl);\n+                                this.encode_method_argument_names(&sig.decl);\n                             }\n \n                             hir::TypeTraitItem(..) => {}\n@@ -1222,145 +1193,146 @@ impl<'a, 'tcx> IndexBuilder<'a, 'tcx> {\n     }\n \n     fn encode_info_for_foreign_item(&mut self,\n-                                    rbml_w: &mut Encoder,\n                                     nitem: &hir::ForeignItem) {\n         let ecx = self.ecx();\n \n         debug!(\"writing foreign item {}\", ecx.tcx.node_path_str(nitem.id));\n         let def_id = ecx.tcx.map.local_def_id(nitem.id);\n         let abi = ecx.tcx.map.get_foreign_abi(nitem.id);\n \n-        self.record(def_id, rbml_w, |this, rbml_w| {\n-            encode_def_id_and_key(ecx, rbml_w, def_id);\n+        self.record(def_id, |this| {\n+            encode_def_id_and_key(ecx, this.rbml_w, def_id);\n             let parent_id = ecx.tcx.map.get_parent(nitem.id);\n-            this.encode_parent_item(rbml_w, ecx.tcx.map.local_def_id(parent_id));\n-            this.encode_visibility(rbml_w, &nitem.vis);\n+            this.encode_parent_item(ecx.tcx.map.local_def_id(parent_id));\n+            this.encode_visibility(&nitem.vis);\n             match nitem.node {\n                 hir::ForeignItemFn(ref fndecl, _) => {\n-                    encode_family(rbml_w, FN_FAMILY);\n-                    this.encode_bounds_and_type_for_item(rbml_w, nitem.id);\n-                    encode_name(rbml_w, nitem.name);\n+                    encode_family(this.rbml_w, FN_FAMILY);\n+                    this.encode_bounds_and_type_for_item(nitem.id);\n+                    encode_name(this.rbml_w, nitem.name);\n                     if abi == Abi::RustIntrinsic || abi == Abi::PlatformIntrinsic {\n-                        encode_inlined_item(ecx, rbml_w, InlinedItemRef::Foreign(def_id, nitem));\n-                        this.encode_mir(rbml_w, nitem.id);\n+                        encode_inlined_item(ecx,\n+                                            this.rbml_w,\n+                                            InlinedItemRef::Foreign(def_id, nitem));\n+                        this.encode_mir(nitem.id);\n                     }\n-                    encode_attributes(rbml_w, &nitem.attrs);\n+                    encode_attributes(this.rbml_w, &nitem.attrs);\n                     let stab = ecx.tcx.lookup_stability(ecx.tcx.map.local_def_id(nitem.id));\n                     let depr = ecx.tcx.lookup_deprecation(ecx.tcx.map.local_def_id(nitem.id));\n-                    encode_stability(rbml_w, stab);\n-                    encode_deprecation(rbml_w, depr);\n-                    this.encode_method_argument_names(rbml_w, &fndecl);\n+                    encode_stability(this.rbml_w, stab);\n+                    encode_deprecation(this.rbml_w, depr);\n+                    this.encode_method_argument_names(&fndecl);\n                 }\n                 hir::ForeignItemStatic(_, mutbl) => {\n                     if mutbl {\n-                        encode_family(rbml_w, 'b');\n+                        encode_family(this.rbml_w, 'b');\n                     } else {\n-                        encode_family(rbml_w, 'c');\n+                        encode_family(this.rbml_w, 'c');\n                     }\n-                    this.encode_bounds_and_type_for_item(rbml_w, nitem.id);\n-                    encode_attributes(rbml_w, &nitem.attrs);\n+                    this.encode_bounds_and_type_for_item(nitem.id);\n+                    encode_attributes(this.rbml_w, &nitem.attrs);\n                     let stab = ecx.tcx.lookup_stability(ecx.tcx.map.local_def_id(nitem.id));\n                     let depr = ecx.tcx.lookup_deprecation(ecx.tcx.map.local_def_id(nitem.id));\n-                    encode_stability(rbml_w, stab);\n-                    encode_deprecation(rbml_w, depr);\n-                    encode_name(rbml_w, nitem.name);\n+                    encode_stability(this.rbml_w, stab);\n+                    encode_deprecation(this.rbml_w, depr);\n+                    encode_name(this.rbml_w, nitem.name);\n                 }\n             }\n         });\n     }\n }\n \n-struct EncodeVisitor<'a, 'data:'a, 'ecx: 'a, 'tcx: 'ecx> {\n-    rbml_w: &'a mut Encoder<'data>,\n-    index: &'a mut IndexBuilder<'ecx, 'tcx>,\n+struct EncodeVisitor<'a, 'ecx: 'a, 'tcx: 'ecx, 'encoder: 'ecx> {\n+    index: &'a mut IndexBuilder<'ecx, 'tcx, 'encoder>,\n }\n \n-impl<'a, 'data, 'ecx, 'tcx> Visitor<'tcx> for EncodeVisitor<'a, 'data, 'ecx, 'tcx> {\n+impl<'a, 'ecx, 'tcx, 'encoder> Visitor<'tcx> for EncodeVisitor<'a, 'ecx, 'tcx, 'encoder> {\n     fn visit_expr(&mut self, ex: &'tcx hir::Expr) {\n         intravisit::walk_expr(self, ex);\n-        self.index.encode_info_for_expr(ex, self.rbml_w);\n+        self.index.encode_info_for_expr(ex);\n     }\n     fn visit_item(&mut self, i: &'tcx hir::Item) {\n         intravisit::walk_item(self, i);\n-        self.index.encode_info_for_item(self.rbml_w, i);\n+        self.index.encode_info_for_item(i);\n     }\n     fn visit_foreign_item(&mut self, ni: &'tcx hir::ForeignItem) {\n         intravisit::walk_foreign_item(self, ni);\n-        self.index.encode_info_for_foreign_item(self.rbml_w, ni);\n+        self.index.encode_info_for_foreign_item(ni);\n     }\n     fn visit_ty(&mut self, ty: &'tcx hir::Ty) {\n         intravisit::walk_ty(self, ty);\n-        self.index.encode_info_for_ty(ty, self.rbml_w);\n+        self.index.encode_info_for_ty(ty);\n     }\n }\n \n-impl<'a, 'tcx> IndexBuilder<'a, 'tcx> {\n-    fn encode_info_for_ty(&mut self,\n-                          ty: &hir::Ty,\n-                          rbml_w: &mut Encoder) {\n+impl<'a, 'tcx, 'encoder> IndexBuilder<'a, 'tcx, 'encoder> {\n+    fn encode_info_for_ty(&mut self, ty: &hir::Ty) {\n         let ecx = self.ecx();\n         if let hir::TyImplTrait(_) = ty.node {\n             let def_id = ecx.tcx.map.local_def_id(ty.id);\n-            self.record(def_id, rbml_w, |this, rbml_w| {\n-                encode_def_id_and_key(ecx, rbml_w, def_id);\n-                encode_family(rbml_w, 'y');\n-                this.encode_bounds_and_type_for_item(rbml_w, ty.id);\n+            self.record(def_id, |this| {\n+                encode_def_id_and_key(ecx, this.rbml_w, def_id);\n+                encode_family(this.rbml_w, 'y');\n+                this.encode_bounds_and_type_for_item(ty.id);\n             });\n         }\n     }\n \n-    fn encode_info_for_expr(&mut self, expr: &hir::Expr, rbml_w: &mut Encoder) {\n+    fn encode_info_for_expr(&mut self, expr: &hir::Expr) {\n         let ecx = self.ecx();\n \n         match expr.node {\n             hir::ExprClosure(..) => {\n                 let def_id = ecx.tcx.map.local_def_id(expr.id);\n \n-                self.record(def_id, rbml_w, |this, rbml_w| {\n-                    encode_def_id_and_key(ecx, rbml_w, def_id);\n-                    encode_name(rbml_w, syntax::parse::token::intern(\"<closure>\"));\n+                self.record(def_id, |this| {\n+                    encode_def_id_and_key(ecx, this.rbml_w, def_id);\n+                    encode_name(this.rbml_w, syntax::parse::token::intern(\"<closure>\"));\n \n-                    rbml_w.start_tag(tag_items_closure_ty);\n-                    write_closure_type(ecx, rbml_w, &ecx.tcx.tables.borrow().closure_tys[&def_id]);\n-                    rbml_w.end_tag();\n+                    this.rbml_w.start_tag(tag_items_closure_ty);\n+                    write_closure_type(ecx,\n+                                       this.rbml_w,\n+                                       &ecx.tcx.tables.borrow().closure_tys[&def_id]);\n+                    this.rbml_w.end_tag();\n \n-                    rbml_w.start_tag(tag_items_closure_kind);\n-                    ecx.tcx.closure_kind(def_id).encode(rbml_w).unwrap();\n-                    rbml_w.end_tag();\n+                    this.rbml_w.start_tag(tag_items_closure_kind);\n+                    ecx.tcx.closure_kind(def_id).encode(this.rbml_w).unwrap();\n+                    this.rbml_w.end_tag();\n \n                     assert!(ecx.mir_map.map.contains_key(&def_id));\n-                    this.encode_mir(rbml_w, expr.id);\n+                    this.encode_mir(expr.id);\n                 });\n             }\n             _ => { }\n         }\n     }\n }\n \n-fn encode_info_for_items<'a, 'tcx>(ecx: &'a EncodeContext<'a, 'tcx>,\n+fn encode_info_for_items<'a, 'tcx>(ecx: &EncodeContext<'a, 'tcx>,\n                                    rbml_w: &mut Encoder)\n-                                   -> IndexBuilder<'a, 'tcx> {\n+                                   -> (IndexData, FnvHashMap<XRef<'tcx>, u32>) {\n     let krate = ecx.tcx.map.krate();\n \n-    let mut index = IndexBuilder::new(ecx);\n     rbml_w.start_tag(tag_items_data);\n \n-    index.record(DefId::local(CRATE_DEF_INDEX), rbml_w, |this, rbml_w| {\n-        this.encode_info_for_mod(rbml_w,\n-                                 &krate.module,\n-                                 &[],\n-                                 CRATE_NODE_ID,\n-                                 syntax::parse::token::intern(&ecx.link_meta.crate_name),\n-                                 &hir::Public);\n-    });\n-\n-    krate.visit_all_items(&mut EncodeVisitor {\n-        index: &mut index,\n-        rbml_w: &mut *rbml_w,\n-    });\n+    let fields = {\n+        let mut index = IndexBuilder::new(ecx, rbml_w);\n+        index.record(DefId::local(CRATE_DEF_INDEX), |this| {\n+            this.encode_info_for_mod(&krate.module,\n+                                     &[],\n+                                     CRATE_NODE_ID,\n+                                     syntax::parse::token::intern(&ecx.link_meta.crate_name),\n+                                     &hir::Public);\n+        });\n+        krate.visit_all_items(&mut EncodeVisitor {\n+            index: &mut index,\n+        });\n+        index.into_fields()\n+    };\n \n     rbml_w.end_tag();\n-    index\n+\n+    fields\n }\n \n fn encode_item_index(rbml_w: &mut Encoder, index: IndexData) {\n@@ -1880,12 +1852,10 @@ fn encode_metadata_inner(rbml_w: &mut Encoder,\n     // Encode and index the items.\n     rbml_w.start_tag(tag_items);\n     i = rbml_w.writer.seek(SeekFrom::Current(0)).unwrap();\n-    let index = encode_info_for_items(&ecx, rbml_w);\n+    let (items, xrefs) = encode_info_for_items(&ecx, rbml_w);\n     stats.item_bytes = rbml_w.writer.seek(SeekFrom::Current(0)).unwrap() - i;\n     rbml_w.end_tag();\n \n-    let (items, xrefs) = index.into_fields();\n-\n     i = rbml_w.writer.seek(SeekFrom::Current(0)).unwrap();\n     encode_item_index(rbml_w, items);\n     stats.index_bytes = rbml_w.writer.seek(SeekFrom::Current(0)).unwrap() - i;"}, {"sha": "b591e0a92688bb52539ca5b6952202856ec07980", "filename": "src/librustc_metadata/index_builder.rs", "status": "modified", "additions": 21, "deletions": 16, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/d49e1a91912788b874bfb5cfc610bc8e3a845d7f/src%2Flibrustc_metadata%2Findex_builder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d49e1a91912788b874bfb5cfc610bc8e3a845d7f/src%2Flibrustc_metadata%2Findex_builder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Findex_builder.rs?ref=d49e1a91912788b874bfb5cfc610bc8e3a845d7f", "patch": "@@ -20,29 +20,33 @@ use std::ops::{Deref, DerefMut};\n \n /// Builder that can encode new items, adding them into the index.\n /// Item encoding cannot be nested.\n-pub struct IndexBuilder<'a, 'tcx: 'a> {\n+pub struct IndexBuilder<'a, 'tcx: 'a, 'encoder: 'a> {\n     items: IndexData,\n-    builder: ItemContentBuilder<'a, 'tcx>,\n+    builder: ItemContentBuilder<'a, 'tcx, 'encoder>,\n }\n \n /// Builder that can encode the content of items, but can't start a\n /// new item itself. Most code is attached to here.\n-pub struct ItemContentBuilder<'a, 'tcx: 'a> {\n+pub struct ItemContentBuilder<'a, 'tcx: 'a, 'encoder: 'a> {\n     xrefs: FnvHashMap<XRef<'tcx>, u32>, // sequentially-assigned\n-    ecx: &'a EncodeContext<'a, 'tcx>,\n+    pub ecx: &'a EncodeContext<'a, 'tcx>,\n+    pub rbml_w: &'a mut Encoder<'encoder>,\n }\n \n /// \"interned\" entries referenced by id\n #[derive(PartialEq, Eq, Hash)]\n pub enum XRef<'tcx> { Predicate(ty::Predicate<'tcx>) }\n \n-impl<'a, 'tcx> IndexBuilder<'a, 'tcx> {\n-    pub fn new(ecx: &'a EncodeContext<'a, 'tcx>) -> Self {\n+impl<'a, 'tcx, 'encoder> IndexBuilder<'a, 'tcx, 'encoder> {\n+    pub fn new(ecx: &'a EncodeContext<'a, 'tcx>,\n+               rbml_w: &'a mut Encoder<'encoder>)\n+               -> Self {\n         IndexBuilder {\n             items: IndexData::new(ecx.tcx.map.num_local_def_ids()),\n             builder: ItemContentBuilder {\n                 ecx: ecx,\n                 xrefs: FnvHashMap(),\n+                rbml_w: rbml_w,\n             },\n         }\n     }\n@@ -53,37 +57,37 @@ impl<'a, 'tcx> IndexBuilder<'a, 'tcx> {\n     ///\n     /// Returns a dep-graph task that you should keep live as long as\n     /// the data for this item is being emitted.\n-    pub fn record<OP>(&mut self, id: DefId, rbml_w: &mut Encoder, op: OP)\n-        where OP: FnOnce(&mut ItemContentBuilder<'a, 'tcx>, &mut Encoder)\n+    pub fn record<OP>(&mut self, id: DefId, op: OP)\n+        where OP: FnOnce(&mut ItemContentBuilder<'a, 'tcx, 'encoder>)\n     {\n-        let position = rbml_w.mark_stable_position();\n+        let position = self.rbml_w.mark_stable_position();\n         self.items.record(id, position);\n         let _task = self.ecx.tcx.dep_graph.in_task(DepNode::MetaData(id));\n-        rbml_w.start_tag(tag_items_data_item).unwrap();\n-        op(self, rbml_w);\n-        rbml_w.end_tag().unwrap();\n+        self.rbml_w.start_tag(tag_items_data_item).unwrap();\n+        op(self);\n+        self.rbml_w.end_tag().unwrap();\n     }\n \n     pub fn into_fields(self) -> (IndexData, FnvHashMap<XRef<'tcx>, u32>) {\n         (self.items, self.builder.xrefs)\n     }\n }\n \n-impl<'a, 'tcx> Deref for IndexBuilder<'a, 'tcx> {\n-    type Target = ItemContentBuilder<'a, 'tcx>;\n+impl<'a, 'tcx, 'encoder> Deref for IndexBuilder<'a, 'tcx, 'encoder> {\n+    type Target = ItemContentBuilder<'a, 'tcx, 'encoder>;\n \n     fn deref(&self) -> &Self::Target {\n         &self.builder\n     }\n }\n \n-impl<'a, 'tcx> DerefMut for IndexBuilder<'a, 'tcx> {\n+impl<'a, 'tcx, 'encoder> DerefMut for IndexBuilder<'a, 'tcx, 'encoder> {\n     fn deref_mut(&mut self) -> &mut Self::Target {\n         &mut self.builder\n     }\n }\n \n-impl<'a, 'tcx> ItemContentBuilder<'a, 'tcx> {\n+impl<'a, 'tcx, 'encoder> ItemContentBuilder<'a, 'tcx, 'encoder> {\n     pub fn ecx(&self) -> &'a EncodeContext<'a, 'tcx> {\n         self.ecx\n     }\n@@ -93,3 +97,4 @@ impl<'a, 'tcx> ItemContentBuilder<'a, 'tcx> {\n         *self.xrefs.entry(xref).or_insert(old_len)\n     }\n }\n+"}]}