{"sha": "c2e99ba8265085bde0a80283a68b4010a4a3aa34", "node_id": "MDY6Q29tbWl0NzI0NzEyOmMyZTk5YmE4MjY1MDg1YmRlMGE4MDI4M2E2OGI0MDEwYTRhM2FhMzQ=", "commit": {"author": {"name": "Elliott Slaughter", "email": "eslaughter@mozilla.com", "date": "2012-08-06T17:53:38Z"}, "committer": {"name": "Elliott Slaughter", "email": "eslaughter@mozilla.com", "date": "2012-08-24T21:01:26Z"}, "message": "rustc: Root resources with addrspaces.", "tree": {"sha": "d70dc58d750726f2f51ab311c65626be281fccfe", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d70dc58d750726f2f51ab311c65626be281fccfe"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c2e99ba8265085bde0a80283a68b4010a4a3aa34", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c2e99ba8265085bde0a80283a68b4010a4a3aa34", "html_url": "https://github.com/rust-lang/rust/commit/c2e99ba8265085bde0a80283a68b4010a4a3aa34", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c2e99ba8265085bde0a80283a68b4010a4a3aa34/comments", "author": null, "committer": null, "parents": [{"sha": "c8daf2ac16b0f924011a0e1fc2be18abf020f5cd", "url": "https://api.github.com/repos/rust-lang/rust/commits/c8daf2ac16b0f924011a0e1fc2be18abf020f5cd", "html_url": "https://github.com/rust-lang/rust/commit/c8daf2ac16b0f924011a0e1fc2be18abf020f5cd"}], "stats": {"total": 144, "additions": 108, "deletions": 36}, "files": [{"sha": "af7c2dcb9ba7081ecfdb9f3a27caf95721c1f832", "filename": "src/rustc/middle/trans/alt.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c2e99ba8265085bde0a80283a68b4010a4a3aa34/src%2Frustc%2Fmiddle%2Ftrans%2Falt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c2e99ba8265085bde0a80283a68b4010a4a3aa34/src%2Frustc%2Fmiddle%2Ftrans%2Falt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Falt.rs?ref=c2e99ba8265085bde0a80283a68b4010a4a3aa34", "patch": "@@ -54,7 +54,7 @@ fn trans_opt(bcx: block, o: opt) -> opt_result {\n             let cell = empty_dest_cell();\n             bcx = tvec::trans_estr(bcx, s, some(ast::vstore_uniq),\n                                    by_val(cell));\n-            add_clean_temp(bcx, *cell, strty);\n+            add_clean_temp_immediate(bcx, *cell, strty);\n             return single_result(rslt(bcx, *cell));\n           }\n           _ => {"}, {"sha": "8aaf50dd52f76f31a1ac692ae816a21dc9a9404a", "filename": "src/rustc/middle/trans/base.rs", "status": "modified", "additions": 30, "deletions": 3, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/c2e99ba8265085bde0a80283a68b4010a4a3aa34/src%2Frustc%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c2e99ba8265085bde0a80283a68b4010a4a3aa34/src%2Frustc%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fbase.rs?ref=c2e99ba8265085bde0a80283a68b4010a4a3aa34", "patch": "@@ -486,6 +486,20 @@ fn note_unique_llvm_symbol(ccx: @crate_ctxt, sym: ~str) {\n     ccx.all_llvm_symbols.insert(sym, ());\n }\n \n+// Chooses the addrspace for newly declared types.\n+fn declare_tydesc_addrspace(ccx: @crate_ctxt, t: ty::t) -> addrspace {\n+    if !ty::type_needs_drop(ccx.tcx, t) {\n+        return default_addrspace;\n+    } else if ty::type_is_immediate(t) {\n+        // For immediate types, we don't actually need an addrspace, because\n+        // e.g. boxed types include pointers to their contents which are\n+        // already correctly tagged with addrspaces.\n+        return default_addrspace;\n+    } else {\n+        return ccx.next_addrspace();\n+    }\n+}\n+\n // Generates the declaration for (but doesn't emit) a type descriptor.\n fn declare_tydesc(ccx: @crate_ctxt, t: ty::t) -> @tydesc_info {\n     let _icx = ccx.insn_ctxt(\"declare_tydesc\");\n@@ -499,6 +513,7 @@ fn declare_tydesc(ccx: @crate_ctxt, t: ty::t) -> @tydesc_info {\n \n     let llsize = llsize_of(ccx, llty);\n     let llalign = llalign_of(ccx, llty);\n+    let addrspace = declare_tydesc_addrspace(ccx, t);\n     //XXX this triggers duplicate LLVM symbols\n     let name = if false /*ccx.sess.opts.debuginfo*/ {\n         mangle_internal_name_by_type_only(ccx, t, ~\"tydesc\")\n@@ -513,6 +528,7 @@ fn declare_tydesc(ccx: @crate_ctxt, t: ty::t) -> @tydesc_info {\n           tydesc: gvar,\n           size: llsize,\n           align: llalign,\n+          addrspace: addrspace,\n           mut take_glue: none,\n           mut drop_glue: none,\n           mut free_glue: none,\n@@ -1275,6 +1291,16 @@ fn drop_ty(cx: block, v: ValueRef, t: ty::t) -> block {\n     return cx;\n }\n \n+fn drop_ty_root(bcx: block, v: ValueRef, rooted: bool, t: ty::t) -> block {\n+    if rooted {\n+        // NB: v is a raw ptr to an addrspace'd ptr to the value.\n+        let v = PointerCast(bcx, Load(bcx, v), T_ptr(type_of(bcx.ccx(), t)));\n+        drop_ty(bcx, v, t)\n+    } else {\n+        drop_ty(bcx, v, t)\n+    }\n+}\n+\n fn drop_ty_immediate(bcx: block, v: ValueRef, t: ty::t) -> block {\n     let _icx = bcx.insn_ctxt(\"drop_ty_immediate\");\n     match ty::get(t).struct {\n@@ -2751,7 +2777,7 @@ fn trans_lval(cx: block, e: @ast::expr) -> lval_result {\n fn non_gc_box_cast(cx: block, val: ValueRef) -> ValueRef {\n     debug!(\"non_gc_box_cast\");\n     add_comment(cx, ~\"non_gc_box_cast\");\n-    assert(llvm::LLVMGetPointerAddressSpace(val_ty(val)) as uint == 1u);\n+    assert(llvm::LLVMGetPointerAddressSpace(val_ty(val)) == gc_box_addrspace);\n     let non_gc_t = T_ptr(llvm::LLVMGetElementType(val_ty(val)));\n     PointerCast(cx, val, non_gc_t)\n }\n@@ -3639,12 +3665,12 @@ fn trans_temp_lval(bcx: block, e: @ast::expr) -> lval_result {\n         } else if ty::type_is_immediate(ty) {\n             let cell = empty_dest_cell();\n             bcx = trans_expr(bcx, e, by_val(cell));\n-            add_clean_temp(bcx, *cell, ty);\n+            add_clean_temp_immediate(bcx, *cell, ty);\n             return {bcx: bcx, val: *cell, kind: lv_temporary};\n         } else {\n             let scratch = alloc_ty(bcx, ty);\n             let bcx = trans_expr_save_in(bcx, e, scratch);\n-            add_clean_temp(bcx, scratch, ty);\n+            add_clean_temp_mem(bcx, scratch, ty);\n             return {bcx: bcx, val: scratch, kind: lv_temporary};\n         }\n     }\n@@ -5815,6 +5841,7 @@ fn trans_crate(sess: session::session,\n           module_data: str_hash::<ValueRef>(),\n           lltypes: ty::new_ty_hash(),\n           names: new_namegen(sess.parse_sess.interner),\n+          next_addrspace: new_addrspace_gen(),\n           symbol_hasher: symbol_hasher,\n           type_hashcodes: ty::new_ty_hash(),\n           type_short_names: ty::new_ty_hash(),"}, {"sha": "e397dd5c113d757321676151dd3d53ab58c69b3e", "filename": "src/rustc/middle/trans/common.rs", "status": "modified", "additions": 69, "deletions": 32, "changes": 101, "blob_url": "https://github.com/rust-lang/rust/blob/c2e99ba8265085bde0a80283a68b4010a4a3aa34/src%2Frustc%2Fmiddle%2Ftrans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c2e99ba8265085bde0a80283a68b4010a4a3aa34/src%2Frustc%2Fmiddle%2Ftrans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fcommon.rs?ref=c2e99ba8265085bde0a80283a68b4010a4a3aa34", "patch": "@@ -30,11 +30,28 @@ fn new_namegen(intr: ident_interner) -> namegen {\n     };\n }\n \n+type addrspace = c_uint;\n+\n+// Address spaces communicate to LLVM which destructors need to run for\n+// specifc types.\n+//    0 is ignored by the GC, and is used for all non-GC'd pointers.\n+//    1 is for opaque GC'd boxes.\n+//    >= 2 are for specific types (e.g. resources).\n+const default_addrspace: addrspace = 0;\n+const gc_box_addrspace: addrspace = 1;\n+\n+type addrspace_gen = fn@() -> addrspace;\n+fn new_addrspace_gen() -> addrspace_gen {\n+    let i = @mut 1;\n+    return fn@() -> addrspace { *i += 1; *i };\n+}\n+\n type tydesc_info =\n     {ty: ty::t,\n      tydesc: ValueRef,\n      size: ValueRef,\n      align: ValueRef,\n+     addrspace: addrspace,\n      mut take_glue: option<ValueRef>,\n      mut drop_glue: option<ValueRef>,\n      mut free_glue: option<ValueRef>,\n@@ -118,6 +135,7 @@ type crate_ctxt = {\n      module_data: hashmap<~str, ValueRef>,\n      lltypes: hashmap<ty::t, TypeRef>,\n      names: namegen,\n+     next_addrspace: addrspace_gen,\n      symbol_hasher: @hash::State,\n      type_hashcodes: hashmap<ty::t, ~str>,\n      type_short_names: hashmap<ty::t, ~str>,\n@@ -254,47 +272,64 @@ fn cleanup_type(cx: ty::ctxt, ty: ty::t) -> cleantype {\n     }\n }\n \n-fn add_clean(cx: block, val: ValueRef, ty: ty::t) {\n-    if !ty::type_needs_drop(cx.tcx(), ty) { return; }\n+// This is not the same as base::root_value, which appears to be the vestigial\n+// remains of the previous GC regime. In the new GC, we can identify\n+// immediates on the stack without difficulty, but have trouble knowing where\n+// non-immediates are on the stack. For non-immediates, we must add an\n+// additional level of indirection, which allows us to alloca a pointer with\n+// the right addrspace.\n+fn root_for_cleanup(bcx: block, v: ValueRef, t: ty::t)\n+    -> {root: ValueRef, rooted: bool} {\n+    let ccx = bcx.ccx();\n+\n+    let addrspace = base::get_tydesc(ccx, t).addrspace;\n+    if addrspace > gc_box_addrspace {\n+        let llty = type_of::type_of_rooted(ccx, t);\n+        let root = base::alloca(bcx, llty);\n+        build::Store(bcx, build::PointerCast(bcx, v, llty), root);\n+        {root: root, rooted: true}\n+    } else {\n+        {root: v, rooted: false}\n+    }\n+}\n+\n+fn add_clean(bcx: block, val: ValueRef, t: ty::t) {\n+    if !ty::type_needs_drop(bcx.tcx(), t) { return; }\n     debug!(\"add_clean(%s, %s, %s)\",\n-           cx.to_str(), val_str(cx.ccx().tn, val),\n-           ty_to_str(cx.ccx().tcx, ty));\n-    let cleanup_type = cleanup_type(cx.tcx(), ty);\n-    do in_scope_cx(cx) |info| {\n-        vec::push(info.cleanups, clean(|a| base::drop_ty(a, val, ty),\n-                                cleanup_type));\n+           bcx.to_str(), val_str(bcx.ccx().tn, val),\n+           ty_to_str(bcx.ccx().tcx, t));\n+    let {root, rooted} = root_for_cleanup(bcx, val, t);\n+    let cleanup_type = cleanup_type(bcx.tcx(), t);\n+    do in_scope_cx(bcx) |info| {\n+        vec::push(info.cleanups,\n+                  clean(|a| base::drop_ty_root(a, root, rooted, t),\n+                        cleanup_type));\n         scope_clean_changed(info);\n     }\n }\n-fn add_clean_temp(cx: block, val: ValueRef, ty: ty::t) {\n+fn add_clean_temp_immediate(cx: block, val: ValueRef, ty: ty::t) {\n     if !ty::type_needs_drop(cx.tcx(), ty) { return; }\n-    debug!(\"add_clean_temp(%s, %s, %s)\",\n+    debug!(\"add_clean_temp_immediate(%s, %s, %s)\",\n            cx.to_str(), val_str(cx.ccx().tn, val),\n            ty_to_str(cx.ccx().tcx, ty));\n     let cleanup_type = cleanup_type(cx.tcx(), ty);\n-    fn do_drop(bcx: block, val: ValueRef, ty: ty::t) ->\n-       block {\n-        if ty::type_is_immediate(ty) {\n-            return base::drop_ty_immediate(bcx, val, ty);\n-        } else {\n-            return base::drop_ty(bcx, val, ty);\n-        }\n-    }\n     do in_scope_cx(cx) |info| {\n-        vec::push(info.cleanups, clean_temp(val, |a| do_drop(a, val, ty),\n-                                     cleanup_type));\n+        vec::push(info.cleanups,\n+                  clean_temp(val, |a| base::drop_ty_immediate(a, val, ty),\n+                             cleanup_type));\n         scope_clean_changed(info);\n     }\n }\n-fn add_clean_temp_mem(cx: block, val: ValueRef, ty: ty::t) {\n-    if !ty::type_needs_drop(cx.tcx(), ty) { return; }\n+fn add_clean_temp_mem(bcx: block, val: ValueRef, t: ty::t) {\n+    if !ty::type_needs_drop(bcx.tcx(), t) { return; }\n     debug!(\"add_clean_temp_mem(%s, %s, %s)\",\n-           cx.to_str(), val_str(cx.ccx().tn, val),\n-           ty_to_str(cx.ccx().tcx, ty));\n-    let cleanup_type = cleanup_type(cx.tcx(), ty);\n-    do in_scope_cx(cx) |info| {\n+           bcx.to_str(), val_str(bcx.ccx().tn, val),\n+           ty_to_str(bcx.ccx().tcx, t));\n+    let {root, rooted} = root_for_cleanup(bcx, val, t);\n+    let cleanup_type = cleanup_type(bcx.tcx(), t);\n+    do in_scope_cx(bcx) |info| {\n         vec::push(info.cleanups,\n-                  clean_temp(val, |a| base::drop_ty(a, val, ty),\n+                  clean_temp(val, |a| base::drop_ty_root(a, root, rooted, t),\n                              cleanup_type));\n         scope_clean_changed(info);\n     }\n@@ -607,7 +642,11 @@ fn T_fn_pair(cx: @crate_ctxt, tfn: TypeRef) -> TypeRef {\n }\n \n fn T_ptr(t: TypeRef) -> TypeRef {\n-    return llvm::LLVMPointerType(t, 0u as c_uint);\n+    return llvm::LLVMPointerType(t, default_addrspace);\n+}\n+\n+fn T_root(t: TypeRef, addrspace: addrspace) -> TypeRef {\n+    return llvm::LLVMPointerType(t, addrspace);\n }\n \n fn T_struct(elts: ~[TypeRef]) -> TypeRef unsafe {\n@@ -738,8 +777,7 @@ fn T_box(cx: @crate_ctxt, t: TypeRef) -> TypeRef {\n }\n \n fn T_box_ptr(t: TypeRef) -> TypeRef {\n-    const box_addrspace: uint = 1u;\n-    return llvm::LLVMPointerType(t, box_addrspace as c_uint);\n+    return llvm::LLVMPointerType(t, gc_box_addrspace);\n }\n \n fn T_opaque_box(cx: @crate_ctxt) -> TypeRef {\n@@ -755,8 +793,7 @@ fn T_unique(cx: @crate_ctxt, t: TypeRef) -> TypeRef {\n }\n \n fn T_unique_ptr(t: TypeRef) -> TypeRef {\n-    const unique_addrspace: uint = 1u;\n-    return llvm::LLVMPointerType(t, unique_addrspace as c_uint);\n+    return llvm::LLVMPointerType(t, gc_box_addrspace);\n }\n \n fn T_port(cx: @crate_ctxt, _t: TypeRef) -> TypeRef {"}, {"sha": "a7cde34fa4c100336020276dd9edd9b933e20b7a", "filename": "src/rustc/middle/trans/type_of.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/c2e99ba8265085bde0a80283a68b4010a4a3aa34/src%2Frustc%2Fmiddle%2Ftrans%2Ftype_of.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c2e99ba8265085bde0a80283a68b4010a4a3aa34/src%2Frustc%2Fmiddle%2Ftrans%2Ftype_of.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Ftype_of.rs?ref=c2e99ba8265085bde0a80283a68b4010a4a3aa34", "patch": "@@ -12,6 +12,7 @@ export type_of_fn_from_ty;\n export type_of_fn;\n export type_of_glue_fn;\n export type_of_non_gc_box;\n+export type_of_rooted;\n \n fn type_of_explicit_args(cx: @crate_ctxt,\n                          inputs: ~[ty::arg]) -> ~[TypeRef] {\n@@ -245,6 +246,13 @@ fn type_of_dtor(ccx: @crate_ctxt, self_ty: ty::t) -> TypeRef {\n          llvm::LLVMVoidType())\n }\n \n+fn type_of_rooted(ccx: @crate_ctxt, t: ty::t) -> TypeRef {\n+    let addrspace = base::get_tydesc(ccx, t).addrspace;\n+    debug!{\"type_of_rooted %s in addrspace %u\",\n+           ty_to_str(ccx.tcx, t), addrspace as uint};\n+    return T_root(type_of(ccx, t), addrspace);\n+}\n+\n fn type_of_glue_fn(ccx: @crate_ctxt, t: ty::t) -> TypeRef {\n     let tydescpp = T_ptr(T_ptr(ccx.tydesc_type));\n     let llty = T_ptr(type_of(ccx, t));"}]}