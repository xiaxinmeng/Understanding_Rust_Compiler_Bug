{"sha": "41f8cfa30edc92c3c42a08059d0737d5ee4b87ac", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQxZjhjZmEzMGVkYzkyYzNjNDJhMDgwNTlkMDczN2Q1ZWU0Yjg3YWM=", "commit": {"author": {"name": "Christian Poveda", "email": "christianpoveda@protonmail.com", "date": "2019-08-14T20:44:37Z"}, "committer": {"name": "Christian Poveda", "email": "christianpoveda@protonmail.com", "date": "2019-08-14T21:30:55Z"}, "message": "Move env shims to its own module", "tree": {"sha": "92a36324ad5ca6ed27db32b7c57a48de4b0b3428", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/92a36324ad5ca6ed27db32b7c57a48de4b0b3428"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/41f8cfa30edc92c3c42a08059d0737d5ee4b87ac", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/41f8cfa30edc92c3c42a08059d0737d5ee4b87ac", "html_url": "https://github.com/rust-lang/rust/commit/41f8cfa30edc92c3c42a08059d0737d5ee4b87ac", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/41f8cfa30edc92c3c42a08059d0737d5ee4b87ac/comments", "author": {"login": "pvdrz", "id": 31802960, "node_id": "MDQ6VXNlcjMxODAyOTYw", "avatar_url": "https://avatars.githubusercontent.com/u/31802960?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pvdrz", "html_url": "https://github.com/pvdrz", "followers_url": "https://api.github.com/users/pvdrz/followers", "following_url": "https://api.github.com/users/pvdrz/following{/other_user}", "gists_url": "https://api.github.com/users/pvdrz/gists{/gist_id}", "starred_url": "https://api.github.com/users/pvdrz/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pvdrz/subscriptions", "organizations_url": "https://api.github.com/users/pvdrz/orgs", "repos_url": "https://api.github.com/users/pvdrz/repos", "events_url": "https://api.github.com/users/pvdrz/events{/privacy}", "received_events_url": "https://api.github.com/users/pvdrz/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pvdrz", "id": 31802960, "node_id": "MDQ6VXNlcjMxODAyOTYw", "avatar_url": "https://avatars.githubusercontent.com/u/31802960?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pvdrz", "html_url": "https://github.com/pvdrz", "followers_url": "https://api.github.com/users/pvdrz/followers", "following_url": "https://api.github.com/users/pvdrz/following{/other_user}", "gists_url": "https://api.github.com/users/pvdrz/gists{/gist_id}", "starred_url": "https://api.github.com/users/pvdrz/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pvdrz/subscriptions", "organizations_url": "https://api.github.com/users/pvdrz/orgs", "repos_url": "https://api.github.com/users/pvdrz/repos", "events_url": "https://api.github.com/users/pvdrz/events{/privacy}", "received_events_url": "https://api.github.com/users/pvdrz/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1f504ea7be76c55bb3ba8d79599f161d65f5bb51", "url": "https://api.github.com/repos/rust-lang/rust/commits/1f504ea7be76c55bb3ba8d79599f161d65f5bb51", "html_url": "https://github.com/rust-lang/rust/commit/1f504ea7be76c55bb3ba8d79599f161d65f5bb51"}], "stats": {"total": 155, "additions": 83, "deletions": 72}, "files": [{"sha": "ae57bcf98b96fda9c6e0496443f3f0ab756ef147", "filename": "src/eval.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/41f8cfa30edc92c3c42a08059d0737d5ee4b87ac/src%2Feval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/41f8cfa30edc92c3c42a08059d0737d5ee4b87ac/src%2Feval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Feval.rs?ref=41f8cfa30edc92c3c42a08059d0737d5ee4b87ac", "patch": "@@ -39,7 +39,6 @@ pub fn create_ecx<'mir, 'tcx: 'mir>(\n         Evaluator::new(config.communicate),\n         MemoryExtra::new(StdRng::seed_from_u64(config.seed.unwrap_or(0)), config.validate),\n     );\n-\n     // Complete initialization.\n     EnvVars::init(&mut ecx, config.communicate);\n "}, {"sha": "cea99d86eaa8aca66cde48349b23c2660bf39337", "filename": "src/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/41f8cfa30edc92c3c42a08059d0737d5ee4b87ac/src%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/41f8cfa30edc92c3c42a08059d0737d5ee4b87ac/src%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib.rs?ref=41f8cfa30edc92c3c42a08059d0737d5ee4b87ac", "patch": "@@ -33,7 +33,7 @@ pub use crate::shims::foreign_items::EvalContextExt as ForeignItemsEvalContextEx\n pub use crate::shims::intrinsics::EvalContextExt as IntrinsicsEvalContextExt;\n pub use crate::shims::tls::{EvalContextExt as TlsEvalContextExt, TlsData};\n pub use crate::shims::dlsym::{Dlsym, EvalContextExt as DlsymEvalContextExt};\n-pub use crate::shims::env::EnvVars;\n+pub use crate::shims::env::{EnvVars, EvalContextExt as EnvEvalContextExt};\n pub use crate::operator::EvalContextExt as OperatorEvalContextExt;\n pub use crate::range_map::RangeMap;\n pub use crate::helpers::{EvalContextExt as HelpersEvalContextExt};"}, {"sha": "8362a02c7e80dbb7d6388b01efc95feb040f0a4e", "filename": "src/shims/env.rs", "status": "modified", "additions": 79, "deletions": 13, "changes": 92, "blob_url": "https://github.com/rust-lang/rust/blob/41f8cfa30edc92c3c42a08059d0737d5ee4b87ac/src%2Fshims%2Fenv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/41f8cfa30edc92c3c42a08059d0737d5ee4b87ac/src%2Fshims%2Fenv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fshims%2Fenv.rs?ref=41f8cfa30edc92c3c42a08059d0737d5ee4b87ac", "patch": "@@ -22,21 +22,9 @@ impl EnvVars {\n             }\n         }\n     }\n-\n-    pub(crate) fn get(&self, name: &[u8]) -> Option<&Pointer<Tag>> {\n-        self.map.get(name)\n-    }\n-\n-    pub(crate) fn unset(&mut self, name: &[u8]) -> Option<Pointer<Tag>> {\n-        self.map.remove(name)\n-    }\n-\n-    pub(crate) fn set(&mut self, name: Vec<u8>, ptr: Pointer<Tag>) -> Option<Pointer<Tag>>{\n-        self.map.insert(name, ptr)\n-    }\n }\n \n-pub(crate) fn alloc_env_value<'mir, 'tcx>(\n+fn alloc_env_value<'mir, 'tcx>(\n     bytes: &[u8],\n     memory: &mut Memory<'mir, 'tcx, Evaluator<'tcx>>,\n ) -> Pointer<Tag> {\n@@ -58,3 +46,81 @@ pub(crate) fn alloc_env_value<'mir, 'tcx>(\n     alloc.write_bytes(&tcx, trailing_zero_ptr, &[0]).unwrap();\n     ptr\n }\n+\n+impl<'mir, 'tcx> EvalContextExt<'mir, 'tcx> for crate::MiriEvalContext<'mir, 'tcx> {}\n+pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx> {\n+    fn getenv(\n+        &mut self,\n+        name_op: OpTy<'tcx, Tag>,\n+        dest: PlaceTy<'tcx, Tag>\n+    ) -> InterpResult<'tcx> {\n+        let this = self.eval_context_mut();\n+\n+        let result = {\n+            let name_ptr = this.read_scalar(name_op)?.not_undef()?;\n+            let name = this.memory().read_c_str(name_ptr)?;\n+            match this.machine.env_vars.map.get(name) {\n+                Some(&var) => Scalar::Ptr(var),\n+                None => Scalar::ptr_null(&*this.tcx),\n+            }\n+        };\n+        this.write_scalar(result, dest)?;\n+        Ok(())\n+    }\n+\n+    fn setenv(\n+        &mut self,\n+        name_op: OpTy<'tcx, Tag>,\n+        value_op: OpTy<'tcx, Tag>,\n+        dest: PlaceTy<'tcx, Tag>\n+    ) -> InterpResult<'tcx> {\n+        let this = self.eval_context_mut();\n+\n+        let mut new = None;\n+        let name_ptr = this.read_scalar(name_op)?.not_undef()?;\n+        let value_ptr = this.read_scalar(value_op)?.not_undef()?;\n+        let value = this.memory().read_c_str(value_ptr)?;\n+        if !this.is_null(name_ptr)? {\n+            let name = this.memory().read_c_str(name_ptr)?;\n+            if !name.is_empty() && !name.contains(&b'=') {\n+                new = Some((name.to_owned(), value.to_owned()));\n+            }\n+        }\n+        if let Some((name, value)) = new {\n+            let value_copy = alloc_env_value(&value, this.memory_mut());\n+            if let Some(var) = this.machine.env_vars.map.insert(name.to_owned(), value_copy) {\n+                this.memory_mut().deallocate(var, None, MiriMemoryKind::Env.into())?;\n+            }\n+            this.write_null(dest)?;\n+        } else {\n+            this.write_scalar(Scalar::from_int(-1, dest.layout.size), dest)?;\n+        }\n+        Ok(())\n+    }\n+\n+    fn unsetenv(\n+        &mut self,\n+        name_op: OpTy<'tcx, Tag>,\n+        dest: PlaceTy<'tcx, Tag>\n+    ) -> InterpResult<'tcx> {\n+        let this = self.eval_context_mut();\n+\n+        let mut success = None;\n+        let name_ptr = this.read_scalar(name_op)?.not_undef()?;\n+        if !this.is_null(name_ptr)? {\n+            let name = this.memory().read_c_str(name_ptr)?.to_owned();\n+            if !name.is_empty() && !name.contains(&b'=') {\n+                success = Some(this.machine.env_vars.map.remove(&name));\n+            }\n+        }\n+        if let Some(old) = success {\n+            if let Some(var) = old {\n+                this.memory_mut().deallocate(var, None, MiriMemoryKind::Env.into())?;\n+            }\n+            this.write_null(dest)?;\n+        } else {\n+            this.write_scalar(Scalar::from_int(-1, dest.layout.size), dest)?;\n+        }\n+        Ok(())\n+    }\n+}"}, {"sha": "34b54f3290244ea51a92bafb8fbb3b22017556b2", "filename": "src/shims/foreign_items.rs", "status": "modified", "additions": 3, "deletions": 57, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/41f8cfa30edc92c3c42a08059d0737d5ee4b87ac/src%2Fshims%2Fforeign_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/41f8cfa30edc92c3c42a08059d0737d5ee4b87ac/src%2Fshims%2Fforeign_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fshims%2Fforeign_items.rs?ref=41f8cfa30edc92c3c42a08059d0737d5ee4b87ac", "patch": "@@ -8,7 +8,6 @@ use syntax::attr;\n use syntax::symbol::sym;\n \n use crate::*;\n-use crate::shims::env::alloc_env_value;\n \n impl<'mir, 'tcx> EvalContextExt<'mir, 'tcx> for crate::MiriEvalContext<'mir, 'tcx> {}\n pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx> {\n@@ -422,62 +421,9 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n                 }\n             }\n \n-            \"getenv\" => {\n-                let result = {\n-                    let name_ptr = this.read_scalar(args[0])?.not_undef()?;\n-                    let name = this.memory().read_c_str(name_ptr)?;\n-                    match this.machine.env_vars.get(name) {\n-                        Some(&var) => Scalar::Ptr(var),\n-                        None => Scalar::ptr_null(&*this.tcx),\n-                    }\n-                };\n-                this.write_scalar(result, dest)?;\n-            }\n-\n-            \"unsetenv\" => {\n-                let mut success = None;\n-                {\n-                    let name_ptr = this.read_scalar(args[0])?.not_undef()?;\n-                    if !this.is_null(name_ptr)? {\n-                        let name = this.memory().read_c_str(name_ptr)?.to_owned();\n-                        if !name.is_empty() && !name.contains(&b'=') {\n-                            success = Some(this.machine.env_vars.unset(&name));\n-                        }\n-                    }\n-                }\n-                if let Some(old) = success {\n-                    if let Some(var) = old {\n-                        this.memory_mut().deallocate(var, None, MiriMemoryKind::Env.into())?;\n-                    }\n-                    this.write_null(dest)?;\n-                } else {\n-                    this.write_scalar(Scalar::from_int(-1, dest.layout.size), dest)?;\n-                }\n-            }\n-\n-            \"setenv\" => {\n-                let mut new = None;\n-                {\n-                    let name_ptr = this.read_scalar(args[0])?.not_undef()?;\n-                    let value_ptr = this.read_scalar(args[1])?.not_undef()?;\n-                    let value = this.memory().read_c_str(value_ptr)?;\n-                    if !this.is_null(name_ptr)? {\n-                        let name = this.memory().read_c_str(name_ptr)?;\n-                        if !name.is_empty() && !name.contains(&b'=') {\n-                            new = Some((name.to_owned(), value.to_owned()));\n-                        }\n-                    }\n-                }\n-                if let Some((name, value)) = new {\n-                    let value_copy = alloc_env_value(&value, this.memory_mut());\n-                    if let Some(var) = this.machine.env_vars.set(name.to_owned(), value_copy) {\n-                        this.memory_mut().deallocate(var, None, MiriMemoryKind::Env.into())?;\n-                    }\n-                    this.write_null(dest)?;\n-                } else {\n-                    this.write_scalar(Scalar::from_int(-1, dest.layout.size), dest)?;\n-                }\n-            }\n+            \"getenv\" => this.getenv(args[0], dest)?,\n+            \"unsetenv\" => this.unsetenv(args[0], dest)?,\n+            \"setenv\" => this.setenv(args[0], args[1], dest)?,\n \n             \"write\" => {\n                 let fd = this.read_scalar(args[0])?.to_i32()?;"}]}