{"sha": "4f3d14269e72f8a21c6f8b74e887faf42a665bc2", "node_id": "MDY6Q29tbWl0NzI0NzEyOjRmM2QxNDI2OWU3MmY4YTIxYzZmOGI3NGU4ODdmYWY0MmE2NjViYzI=", "commit": {"author": {"name": "llogiq", "email": "bogusandre@gmail.com", "date": "2016-06-09T22:26:30Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2016-06-09T22:26:30Z"}, "message": "Merge pull request #990 from Manishearth/rustfmt\n\nCleanup", "tree": {"sha": "7d23c394f4191411c23045f346e6d10ef1a79cb6", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7d23c394f4191411c23045f346e6d10ef1a79cb6"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4f3d14269e72f8a21c6f8b74e887faf42a665bc2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4f3d14269e72f8a21c6f8b74e887faf42a665bc2", "html_url": "https://github.com/rust-lang/rust/commit/4f3d14269e72f8a21c6f8b74e887faf42a665bc2", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4f3d14269e72f8a21c6f8b74e887faf42a665bc2/comments", "author": {"login": "llogiq", "id": 4200835, "node_id": "MDQ6VXNlcjQyMDA4MzU=", "avatar_url": "https://avatars.githubusercontent.com/u/4200835?v=4", "gravatar_id": "", "url": "https://api.github.com/users/llogiq", "html_url": "https://github.com/llogiq", "followers_url": "https://api.github.com/users/llogiq/followers", "following_url": "https://api.github.com/users/llogiq/following{/other_user}", "gists_url": "https://api.github.com/users/llogiq/gists{/gist_id}", "starred_url": "https://api.github.com/users/llogiq/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/llogiq/subscriptions", "organizations_url": "https://api.github.com/users/llogiq/orgs", "repos_url": "https://api.github.com/users/llogiq/repos", "events_url": "https://api.github.com/users/llogiq/events{/privacy}", "received_events_url": "https://api.github.com/users/llogiq/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e6832317fa879ab6391585949ae1b8023ed13cc5", "url": "https://api.github.com/repos/rust-lang/rust/commits/e6832317fa879ab6391585949ae1b8023ed13cc5", "html_url": "https://github.com/rust-lang/rust/commit/e6832317fa879ab6391585949ae1b8023ed13cc5"}, {"sha": "dd99a88289f12c00f95981f068c3177b3324b72c", "url": "https://api.github.com/repos/rust-lang/rust/commits/dd99a88289f12c00f95981f068c3177b3324b72c", "html_url": "https://github.com/rust-lang/rust/commit/dd99a88289f12c00f95981f068c3177b3324b72c"}], "stats": {"total": 920, "additions": 431, "deletions": 489}, "files": [{"sha": "12c74b653e34c271153082c4f080b79aad157d79", "filename": "Cargo.toml", "status": "modified", "additions": 1, "deletions": 6, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/4f3d14269e72f8a21c6f8b74e887faf42a665bc2/Cargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/4f3d14269e72f8a21c6f8b74e887faf42a665bc2/Cargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.toml?ref=4f3d14269e72f8a21c6f8b74e887faf42a665bc2", "patch": "@@ -23,21 +23,16 @@ name = \"cargo-clippy\"\n test = false\n \n [dependencies]\n-regex-syntax = \"0.3.0\"\n regex_macros = { version = \"0.1.33\", optional = true }\n-semver = \"0.2.1\"\n-toml = \"0.1\"\n-unicode-normalization = \"0.1\"\n-quine-mc_cluskey = \"0.2.2\"\n # begin automatic update\n clippy_lints = { version = \"0.0.75\", path = \"clippy_lints\" }\n # end automatic update\n-rustc-serialize = \"0.3\"\n \n [dev-dependencies]\n compiletest_rs = \"0.2.0\"\n lazy_static = \"0.1.15\"\n regex = \"0.1.56\"\n+rustc-serialize = \"0.3\"\n \n [features]\n debugging = []"}, {"sha": "4481ab403f84122c2ebf5c4be48a35f4e0d2065d", "filename": "clippy_lints/src/arithmetic.rs", "status": "modified", "additions": 14, "deletions": 26, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/4f3d14269e72f8a21c6f8b74e887faf42a665bc2/clippy_lints%2Fsrc%2Farithmetic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f3d14269e72f8a21c6f8b74e887faf42a665bc2/clippy_lints%2Fsrc%2Farithmetic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Farithmetic.rs?ref=4f3d14269e72f8a21c6f8b74e887faf42a665bc2", "patch": "@@ -38,7 +38,7 @@ declare_restriction_lint! {\n \n #[derive(Copy, Clone, Default)]\n pub struct Arithmetic {\n-    span: Option<Span>\n+    span: Option<Span>,\n }\n \n impl LintPass for Arithmetic {\n@@ -49,48 +49,36 @@ impl LintPass for Arithmetic {\n \n impl LateLintPass for Arithmetic {\n     fn check_expr(&mut self, cx: &LateContext, expr: &hir::Expr) {\n-        if let Some(_) = self.span { return; }\n+        if let Some(_) = self.span {\n+            return;\n+        }\n         match expr.node {\n             hir::ExprBinary(ref op, ref l, ref r) => {\n                 match op.node {\n-                    hir::BiAnd | hir::BiOr | hir::BiBitAnd |\n-                    hir::BiBitOr | hir::BiBitXor | hir::BiShl | hir::BiShr |\n-                    hir::BiEq | hir::BiLt | hir::BiLe | hir::BiNe | hir::BiGe |\n-                    hir::BiGt => return,\n-                    _ => ()\n+                    hir::BiAnd | hir::BiOr | hir::BiBitAnd | hir::BiBitOr | hir::BiBitXor | hir::BiShl |\n+                    hir::BiShr | hir::BiEq | hir::BiLt | hir::BiLe | hir::BiNe | hir::BiGe | hir::BiGt => return,\n+                    _ => (),\n                 }\n                 let (l_ty, r_ty) = (cx.tcx.expr_ty(l), cx.tcx.expr_ty(r));\n                 if l_ty.is_integral() && r_ty.is_integral() {\n-                    span_lint(cx,\n-                              INTEGER_ARITHMETIC,\n-                              expr.span,\n-                              \"integer arithmetic detected\");\n+                    span_lint(cx, INTEGER_ARITHMETIC, expr.span, \"integer arithmetic detected\");\n                     self.span = Some(expr.span);\n                 } else if l_ty.is_floating_point() && r_ty.is_floating_point() {\n-                    span_lint(cx,\n-                              FLOAT_ARITHMETIC,\n-                              expr.span,\n-                              \"floating-point arithmetic detected\");\n+                    span_lint(cx, FLOAT_ARITHMETIC, expr.span, \"floating-point arithmetic detected\");\n                     self.span = Some(expr.span);\n                 }\n-            },\n+            }\n             hir::ExprUnary(hir::UnOp::UnNeg, ref arg) => {\n                 let ty = cx.tcx.expr_ty(arg);\n                 if ty.is_integral() {\n-                    span_lint(cx,\n-                              INTEGER_ARITHMETIC,\n-                              expr.span,\n-                              \"integer arithmetic detected\");\n+                    span_lint(cx, INTEGER_ARITHMETIC, expr.span, \"integer arithmetic detected\");\n                     self.span = Some(expr.span);\n                 } else if ty.is_floating_point() {\n-                    span_lint(cx,\n-                              FLOAT_ARITHMETIC,\n-                              expr.span,\n-                              \"floating-point arithmetic detected\");\n+                    span_lint(cx, FLOAT_ARITHMETIC, expr.span, \"floating-point arithmetic detected\");\n                     self.span = Some(expr.span);\n                 }\n-            },\n-            _ => ()\n+            }\n+            _ => (),\n         }\n     }\n "}, {"sha": "f3b7297b2969326938e7ecf64e00b20f26fec603", "filename": "clippy_lints/src/array_indexing.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/4f3d14269e72f8a21c6f8b74e887faf42a665bc2/clippy_lints%2Fsrc%2Farray_indexing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f3d14269e72f8a21c6f8b74e887faf42a665bc2/clippy_lints%2Fsrc%2Farray_indexing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Farray_indexing.rs?ref=4f3d14269e72f8a21c6f8b74e887faf42a665bc2", "patch": "@@ -79,11 +79,11 @@ impl LateLintPass for ArrayIndexing {\n                 // Index is a constant range\n                 if let Some(range) = utils::unsugar_range(index) {\n                     let start = range.start\n-                                     .map(|start| eval_const_expr_partial(cx.tcx, start, ExprTypeChecked, None))\n-                                     .map(|v| v.ok());\n+                        .map(|start| eval_const_expr_partial(cx.tcx, start, ExprTypeChecked, None))\n+                        .map(|v| v.ok());\n                     let end = range.end\n-                                   .map(|end| eval_const_expr_partial(cx.tcx, end, ExprTypeChecked, None))\n-                                   .map(|v| v.ok());\n+                        .map(|end| eval_const_expr_partial(cx.tcx, end, ExprTypeChecked, None))\n+                        .map(|v| v.ok());\n \n                     if let Some((start, end)) = to_const_range(start, end, range.limits, size) {\n                         if start > size || end > size {"}, {"sha": "1a5ca16b9c574561bdfd7ca8413c94267eab44c6", "filename": "clippy_lints/src/assign_ops.rs", "status": "modified", "additions": 42, "deletions": 46, "changes": 88, "blob_url": "https://github.com/rust-lang/rust/blob/4f3d14269e72f8a21c6f8b74e887faf42a665bc2/clippy_lints%2Fsrc%2Fassign_ops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f3d14269e72f8a21c6f8b74e887faf42a665bc2/clippy_lints%2Fsrc%2Fassign_ops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fassign_ops.rs?ref=4f3d14269e72f8a21c6f8b74e887faf42a665bc2", "patch": "@@ -51,31 +51,24 @@ impl LateLintPass for AssignOps {\n         match expr.node {\n             hir::ExprAssignOp(op, ref lhs, ref rhs) => {\n                 if let (Some(l), Some(r)) = (snippet_opt(cx, lhs.span), snippet_opt(cx, rhs.span)) {\n-                    span_lint_and_then(cx,\n-                                       ASSIGN_OPS,\n-                                       expr.span,\n-                                       \"assign operation detected\",\n-                                       |db| {\n-                                           match rhs.node {\n-                                               hir::ExprBinary(op2, _, _) if op2 != op => {\n-                                                   db.span_suggestion(expr.span,\n-                                                                       \"replace it with\",\n-                                                                       format!(\"{} = {} {} ({})\", l, l, op.node.as_str(), r));\n-                                               },\n-                                               _ => {\n-                                                   db.span_suggestion(expr.span,\n-                                                                       \"replace it with\",\n-                                                                       format!(\"{} = {} {} {}\", l, l, op.node.as_str(), r));\n-                                               }\n-                                           }\n-                                       });\n+                    span_lint_and_then(cx, ASSIGN_OPS, expr.span, \"assign operation detected\", |db| {\n+                        match rhs.node {\n+                            hir::ExprBinary(op2, _, _) if op2 != op => {\n+                                db.span_suggestion(expr.span,\n+                                                   \"replace it with\",\n+                                                   format!(\"{} = {} {} ({})\", l, l, op.node.as_str(), r));\n+                            }\n+                            _ => {\n+                                db.span_suggestion(expr.span,\n+                                                   \"replace it with\",\n+                                                   format!(\"{} = {} {} {}\", l, l, op.node.as_str(), r));\n+                            }\n+                        }\n+                    });\n                 } else {\n-                    span_lint(cx,\n-                              ASSIGN_OPS,\n-                              expr.span,\n-                              \"assign operation detected\");\n+                    span_lint(cx, ASSIGN_OPS, expr.span, \"assign operation detected\");\n                 }\n-            },\n+            }\n             hir::ExprAssign(ref assignee, ref e) => {\n                 if let hir::ExprBinary(op, ref l, ref r) = e.node {\n                     let lint = |assignee: &hir::Expr, rhs: &hir::Expr| {\n@@ -104,28 +97,32 @@ impl LateLintPass for AssignOps {\n                                 }\n                             }\n                         }\n-                        if ops!(op.node, cx, ty, rty, Add:BiAdd,\n-                                                      Sub:BiSub,\n-                                                      Mul:BiMul,\n-                                                      Div:BiDiv,\n-                                                      Rem:BiRem,\n-                                                      And:BiAnd,\n-                                                      Or:BiOr,\n-                                                      BitAnd:BiBitAnd,\n-                                                      BitOr:BiBitOr,\n-                                                      BitXor:BiBitXor,\n-                                                      Shr:BiShr,\n-                                                      Shl:BiShl\n-                        ) {\n-                            if let (Some(snip_a), Some(snip_r)) = (snippet_opt(cx, assignee.span), snippet_opt(cx, rhs.span)) {\n+                        if ops!(op.node,\n+                                cx,\n+                                ty,\n+                                rty,\n+                                Add: BiAdd,\n+                                Sub: BiSub,\n+                                Mul: BiMul,\n+                                Div: BiDiv,\n+                                Rem: BiRem,\n+                                And: BiAnd,\n+                                Or: BiOr,\n+                                BitAnd: BiBitAnd,\n+                                BitOr: BiBitOr,\n+                                BitXor: BiBitXor,\n+                                Shr: BiShr,\n+                                Shl: BiShl) {\n+                            if let (Some(snip_a), Some(snip_r)) = (snippet_opt(cx, assignee.span),\n+                                                                   snippet_opt(cx, rhs.span)) {\n                                 span_lint_and_then(cx,\n                                                    ASSIGN_OP_PATTERN,\n                                                    expr.span,\n                                                    \"manual implementation of an assign operation\",\n                                                    |db| {\n                                                        db.span_suggestion(expr.span,\n-                                                                           \"replace it with\",\n-                                                                           format!(\"{} {}= {}\", snip_a, op.node.as_str(), snip_r));\n+                                                                          \"replace it with\",\n+                                                                          format!(\"{} {}= {}\", snip_a, op.node.as_str(), snip_r));\n                                                    });\n                             } else {\n                                 span_lint(cx,\n@@ -142,17 +139,16 @@ impl LateLintPass for AssignOps {\n                     // a = b commutative_op a\n                     if SpanlessEq::new(cx).ignore_fn().eq_expr(assignee, r) {\n                         match op.node {\n-                            hir::BiAdd | hir::BiMul |\n-                            hir::BiAnd | hir::BiOr |\n-                            hir::BiBitXor | hir::BiBitAnd | hir::BiBitOr => {\n+                            hir::BiAdd | hir::BiMul | hir::BiAnd | hir::BiOr | hir::BiBitXor | hir::BiBitAnd |\n+                            hir::BiBitOr => {\n                                 lint(assignee, l);\n-                            },\n-                            _ => {},\n+                            }\n+                            _ => {}\n                         }\n                     }\n                 }\n-            },\n-            _ => {},\n+            }\n+            _ => {}\n         }\n     }\n }"}, {"sha": "f1e427c5c61574631efb774d2d650fd9580cb44e", "filename": "clippy_lints/src/bit_mask.rs", "status": "modified", "additions": 5, "deletions": 10, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/4f3d14269e72f8a21c6f8b74e887faf42a665bc2/clippy_lints%2Fsrc%2Fbit_mask.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f3d14269e72f8a21c6f8b74e887faf42a665bc2/clippy_lints%2Fsrc%2Fbit_mask.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fbit_mask.rs?ref=4f3d14269e72f8a21c6f8b74e887faf42a665bc2", "patch": "@@ -91,16 +91,11 @@ impl LateLintPass for BitMask {\n     fn check_expr(&mut self, cx: &LateContext, e: &Expr) {\n         if let ExprBinary(ref cmp, ref left, ref right) = e.node {\n             if cmp.node.is_comparison() {\n-                fetch_int_literal(cx, right).map_or_else(|| {\n-                                                             fetch_int_literal(cx, left).map_or((), |cmp_val| {\n-                                                                 check_compare(cx,\n-                                                                               right,\n-                                                                               invert_cmp(cmp.node),\n-                                                                               cmp_val,\n-                                                                               &e.span)\n-                                                             })\n-                                                         },\n-                                                         |cmp_opt| check_compare(cx, left, cmp.node, cmp_opt, &e.span))\n+                if let Some(cmp_opt) = fetch_int_literal(cx, right) {\n+                    check_compare(cx, left, cmp.node, cmp_opt, &e.span)\n+                } else if let Some(cmp_val) = fetch_int_literal(cx, left) {\n+                    check_compare(cx, right, invert_cmp(cmp.node), cmp_val, &e.span)\n+                }\n             }\n         }\n     }"}, {"sha": "8b7952b3746d188e3a1c59af4d0d32f8aa1d54f1", "filename": "clippy_lints/src/booleans.rs", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/4f3d14269e72f8a21c6f8b74e887faf42a665bc2/clippy_lints%2Fsrc%2Fbooleans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f3d14269e72f8a21c6f8b74e887faf42a665bc2/clippy_lints%2Fsrc%2Fbooleans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fbooleans.rs?ref=4f3d14269e72f8a21c6f8b74e887faf42a665bc2", "patch": "@@ -322,7 +322,8 @@ impl<'a, 'tcx> NonminimalBoolVisitor<'a, 'tcx> {\n                 let simplified_stats = terminal_stats(suggestion);\n                 let mut improvement = false;\n                 for i in 0..32 {\n-                    // ignore any \"simplifications\" that end up requiring a terminal more often than in the original expression\n+                    // ignore any \"simplifications\" that end up requiring a terminal more often\n+                    // than in the original expression\n                     if stats.terminals[i] < simplified_stats.terminals[i] {\n                         continue 'simplified;\n                     }\n@@ -332,17 +333,18 @@ impl<'a, 'tcx> NonminimalBoolVisitor<'a, 'tcx> {\n                                            e.span,\n                                            \"this boolean expression contains a logic bug\",\n                                            |db| {\n-                                               db.span_help(h2q.terminals[i].span,\n-                                                            \"this expression can be optimized out by applying \\\n-                                                             boolean operations to the outer expression\");\n-                                               db.span_suggestion(e.span,\n-                                                                  \"it would look like the following\",\n-                                                                  suggest(self.0, suggestion, &h2q.terminals));\n-                                           });\n+                            db.span_help(h2q.terminals[i].span,\n+                                         \"this expression can be optimized out by applying boolean operations to the \\\n+                                          outer expression\");\n+                            db.span_suggestion(e.span,\n+                                               \"it would look like the following\",\n+                                               suggest(self.0, suggestion, &h2q.terminals));\n+                        });\n                         // don't also lint `NONMINIMAL_BOOL`\n                         return;\n                     }\n-                    // if the number of occurrences of a terminal decreases or any of the stats decreases while none increases\n+                    // if the number of occurrences of a terminal decreases or any of the stats\n+                    // decreases while none increases\n                     improvement |= (stats.terminals[i] > simplified_stats.terminals[i]) ||\n                                    (stats.negations > simplified_stats.negations &&\n                                     stats.ops == simplified_stats.ops) ||\n@@ -358,12 +360,10 @@ impl<'a, 'tcx> NonminimalBoolVisitor<'a, 'tcx> {\n                                    e.span,\n                                    \"this boolean expression can be simplified\",\n                                    |db| {\n-                                       for suggestion in &improvements {\n-                                           db.span_suggestion(e.span,\n-                                                              \"try\",\n-                                                              suggest(self.0, suggestion, &h2q.terminals));\n-                                       }\n-                                   });\n+                    for suggestion in &improvements {\n+                        db.span_suggestion(e.span, \"try\", suggest(self.0, suggestion, &h2q.terminals));\n+                    }\n+                });\n             }\n         }\n     }"}, {"sha": "038d888b0ae4a5cdbc218661f28c90bcafab0d69", "filename": "clippy_lints/src/cyclomatic_complexity.rs", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/4f3d14269e72f8a21c6f8b74e887faf42a665bc2/clippy_lints%2Fsrc%2Fcyclomatic_complexity.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f3d14269e72f8a21c6f8b74e887faf42a665bc2/clippy_lints%2Fsrc%2Fcyclomatic_complexity.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fcyclomatic_complexity.rs?ref=4f3d14269e72f8a21c6f8b74e887faf42a665bc2", "patch": "@@ -13,7 +13,8 @@ use utils::{in_macro, LimitStack, span_help_and_lint, paths, match_type};\n \n /// **What it does:** This lint checks for methods with high cyclomatic complexity\n ///\n-/// **Why is this bad?** Methods of high cyclomatic complexity tend to be badly readable. Also LLVM will usually optimize small methods better.\n+/// **Why is this bad?** Methods of high cyclomatic complexity tend to be badly readable. Also LLVM\n+/// will usually optimize small methods better.\n ///\n /// **Known problems:** Sometimes it's hard to find a way to reduce the complexity\n ///\n@@ -69,7 +70,7 @@ impl CyclomaticComplexity {\n             returns / 2\n         };\n \n-        if cc + divergence < match_arms + short_circuits  {\n+        if cc + divergence < match_arms + short_circuits {\n             report_cc_bug(cx, cc, match_arms, divergence, short_circuits, ret_adjust, span);\n         } else {\n             let mut rust_cc = cc + divergence - match_arms - short_circuits;\n@@ -117,7 +118,7 @@ impl LateLintPass for CyclomaticComplexity {\n     }\n }\n \n-struct CCHelper<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n+struct CCHelper<'a, 'gcx: 'a + 'tcx, 'tcx: 'a> {\n     match_arms: u64,\n     divergence: u64,\n     returns: u64,\n@@ -176,8 +177,9 @@ fn report_cc_bug(cx: &LateContext, cc: u64, narms: u64, div: u64, shorts: u64, r\n     if cx.current_level(CYCLOMATIC_COMPLEXITY) != Level::Allow {\n         cx.sess().span_note_without_error(span,\n                                           &format!(\"Clippy encountered a bug calculating cyclomatic complexity \\\n-                                                    (hide this message with `#[allow(cyclomatic_complexity)]`): cc \\\n-                                                    = {}, arms = {}, div = {}, shorts = {}, returns = {}. Please file a bug report.\",\n+                                                    (hide this message with `#[allow(cyclomatic_complexity)]`): \\\n+                                                    cc = {}, arms = {}, div = {}, shorts = {}, returns = {}. \\\n+                                                    Please file a bug report.\",\n                                                    cc,\n                                                    narms,\n                                                    div,"}, {"sha": "5d1eb26734384db954d98ae2a0207b4b9f0f5100", "filename": "clippy_lints/src/derive.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/4f3d14269e72f8a21c6f8b74e887faf42a665bc2/clippy_lints%2Fsrc%2Fderive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f3d14269e72f8a21c6f8b74e887faf42a665bc2/clippy_lints%2Fsrc%2Fderive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fderive.rs?ref=4f3d14269e72f8a21c6f8b74e887faf42a665bc2", "patch": "@@ -84,7 +84,8 @@ impl LateLintPass for Derive {\n }\n \n /// Implementation of the `DERIVE_HASH_XOR_EQ` lint.\n-fn check_hash_peq<'a, 'tcx: 'a>(cx: &LateContext<'a, 'tcx>, span: Span, trait_ref: &TraitRef, ty: ty::Ty<'tcx>, hash_is_automatically_derived: bool) {\n+fn check_hash_peq<'a, 'tcx: 'a>(cx: &LateContext<'a, 'tcx>, span: Span, trait_ref: &TraitRef, ty: ty::Ty<'tcx>,\n+                                hash_is_automatically_derived: bool) {\n     if_let_chain! {[\n         match_path(&trait_ref.path, &paths::HASH),\n         let Some(peq_trait_def_id) = cx.tcx.lang_items.eq_trait()\n@@ -137,7 +138,8 @@ fn check_copy_clone<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, item: &Item, trait_ref\n \n         // Some types are not Clone by default but could be cloned `by hand` if necessary\n         match ty.sty {\n-            TypeVariants::TyEnum(def, substs) | TypeVariants::TyStruct(def, substs) => {\n+            TypeVariants::TyEnum(def, substs) |\n+            TypeVariants::TyStruct(def, substs) => {\n                 for variant in &def.variants {\n                     for field in &variant.fields {\n                         match field.ty(cx.tcx, substs).sty {"}, {"sha": "fc9e95f94955dae118d9c46fa758d9009da1bec1", "filename": "clippy_lints/src/doc.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4f3d14269e72f8a21c6f8b74e887faf42a665bc2/clippy_lints%2Fsrc%2Fdoc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f3d14269e72f8a21c6f8b74e887faf42a665bc2/clippy_lints%2Fsrc%2Fdoc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fdoc.rs?ref=4f3d14269e72f8a21c6f8b74e887faf42a665bc2", "patch": "@@ -108,7 +108,7 @@ pub fn check_doc(cx: &EarlyContext, valid_idents: &[String], docs: &[(&str, Span\n         /// First byte of the current potential match\n         current_word_begin: usize,\n         /// List of lines and their associated span\n-        docs: &'a[(&'a str, Span)],\n+        docs: &'a [(&'a str, Span)],\n         /// Index of the current line we are parsing\n         line: usize,\n         /// Whether we are in a link"}, {"sha": "bc209fd4846e8b0e98725e60315fba65d7e9bfa2", "filename": "clippy_lints/src/entry.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/4f3d14269e72f8a21c6f8b74e887faf42a665bc2/clippy_lints%2Fsrc%2Fentry.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f3d14269e72f8a21c6f8b74e887faf42a665bc2/clippy_lints%2Fsrc%2Fentry.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fentry.rs?ref=4f3d14269e72f8a21c6f8b74e887faf42a665bc2", "patch": "@@ -120,7 +120,6 @@ impl<'a, 'tcx, 'v, 'b> Visitor<'v> for InsertVisitor<'a, 'tcx, 'b> {\n             get_item_name(self.cx, self.map) == get_item_name(self.cx, &*params[0]),\n             SpanlessEq::new(self.cx).eq_expr(self.key, &params[1])\n         ], {\n-\n             span_lint_and_then(self.cx, MAP_ENTRY, self.span,\n                                &format!(\"usage of `contains_key` followed by `insert` on `{}`\", self.ty), |db| {\n                 if self.sole_expr {"}, {"sha": "3d3423a47435f989776c2bb096e511f8384241f1", "filename": "clippy_lints/src/functions.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/4f3d14269e72f8a21c6f8b74e887faf42a665bc2/clippy_lints%2Fsrc%2Ffunctions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f3d14269e72f8a21c6f8b74e887faf42a665bc2/clippy_lints%2Fsrc%2Ffunctions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Ffunctions.rs?ref=4f3d14269e72f8a21c6f8b74e887faf42a665bc2", "patch": "@@ -42,7 +42,8 @@ impl LintPass for Functions {\n }\n \n impl LateLintPass for Functions {\n-    fn check_fn(&mut self, cx: &LateContext, _: intravisit::FnKind, decl: &hir::FnDecl, _: &hir::Block, span: Span, nodeid: ast::NodeId) {\n+    fn check_fn(&mut self, cx: &LateContext, _: intravisit::FnKind, decl: &hir::FnDecl, _: &hir::Block, span: Span,\n+                nodeid: ast::NodeId) {\n         use rustc::hir::map::Node::*;\n \n         if let Some(NodeItem(ref item)) = cx.tcx.map.find(cx.tcx.map.get_parent_node(nodeid)) {"}, {"sha": "ac6bee00ff5451ef2a4d9ab7da8a190563cc1dd4", "filename": "clippy_lints/src/let_if_seq.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4f3d14269e72f8a21c6f8b74e887faf42a665bc2/clippy_lints%2Fsrc%2Flet_if_seq.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f3d14269e72f8a21c6f8b74e887faf42a665bc2/clippy_lints%2Fsrc%2Flet_if_seq.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flet_if_seq.rs?ref=4f3d14269e72f8a21c6f8b74e887faf42a665bc2", "patch": "@@ -182,7 +182,7 @@ fn used_in_expr(cx: &LateContext, id: hir::def_id::DefId, expr: &hir::Expr) -> b\n     let mut v = UsedVisitor {\n         cx: cx,\n         id: id,\n-        used: false\n+        used: false,\n     };\n     hir::intravisit::walk_expr(&mut v, expr);\n     v.used"}, {"sha": "42a35e7009b5adf78336f8b574e5e10e8206ae4f", "filename": "clippy_lints/src/lib.rs", "status": "modified", "additions": 7, "deletions": 8, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/4f3d14269e72f8a21c6f8b74e887faf42a665bc2/clippy_lints%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f3d14269e72f8a21c6f8b74e887faf42a665bc2/clippy_lints%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flib.rs?ref=4f3d14269e72f8a21c6f8b74e887faf42a665bc2", "patch": "@@ -1,17 +1,16 @@\n // error-pattern:cargo-clippy\n \n-#![feature(type_macros)]\n-#![feature(plugin_registrar, box_syntax)]\n-#![feature(rustc_private, collections)]\n-#![feature(iter_arith)]\n+#![feature(box_syntax)]\n+#![feature(collections)]\n #![feature(custom_attribute)]\n-#![feature(slice_patterns)]\n+#![feature(iter_arith)]\n #![feature(question_mark)]\n+#![feature(rustc_private)]\n+#![feature(slice_patterns)]\n #![feature(stmt_expr_attributes)]\n-#![allow(indexing_slicing, shadow_reuse, unknown_lints)]\n+#![feature(type_macros)]\n \n-extern crate rustc_driver;\n-extern crate getopts;\n+#![allow(indexing_slicing, shadow_reuse, unknown_lints)]\n \n #[macro_use]\n extern crate syntax;"}, {"sha": "f3f10fae16e447f077fa21fbf7d0960ad473eead", "filename": "clippy_lints/src/loops.rs", "status": "modified", "additions": 26, "deletions": 28, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/4f3d14269e72f8a21c6f8b74e887faf42a665bc2/clippy_lints%2Fsrc%2Floops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f3d14269e72f8a21c6f8b74e887faf42a665bc2/clippy_lints%2Fsrc%2Floops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Floops.rs?ref=4f3d14269e72f8a21c6f8b74e887faf42a665bc2", "patch": "@@ -608,13 +608,13 @@ fn check_for_loop_over_map_kv(cx: &LateContext, pat: &Pat, arg: &Expr, body: &Ex\n                                    expr.span,\n                                    &format!(\"you seem to want to iterate on a map's {}\", kind),\n                                    |db| {\n-                                       db.span_suggestion(expr.span,\n-                                                          \"use the corresponding method\",\n-                                                          format!(\"for {} in {}.{}() {{ .. }}\",\n-                                                                  snippet(cx, *pat_span, \"..\"),\n-                                                                  snippet(cx, arg_span, \"..\"),\n-                                                                  kind));\n-                                   });\n+                    db.span_suggestion(expr.span,\n+                                       \"use the corresponding method\",\n+                                       format!(\"for {} in {}.{}() {{ .. }}\",\n+                                               snippet(cx, *pat_span, \"..\"),\n+                                               snippet(cx, arg_span, \"..\"),\n+                                               kind));\n+                });\n             }\n         }\n     }\n@@ -667,30 +667,28 @@ impl<'v, 't> Visitor<'v> for VarVisitor<'v, 't> {\n         if let ExprPath(None, ref path) = expr.node {\n             if path.segments.len() == 1 && path.segments[0].name == self.var {\n                 // we are referencing our variable! now check if it's as an index\n-                if_let_chain! {\n-                    [\n-                        let Some(parexpr) = get_parent_expr(self.cx, expr),\n-                        let ExprIndex(ref seqexpr, _) = parexpr.node,\n-                        let ExprPath(None, ref seqvar) = seqexpr.node,\n-                        seqvar.segments.len() == 1\n-                    ], {\n-                        let def_map = self.cx.tcx.def_map.borrow();\n-                        if let Some(def) = def_map.get(&seqexpr.id) {\n-                            match def.base_def {\n-                                Def::Local(..) | Def::Upvar(..) => {\n-                                    let extent = self.cx.tcx.region_maps.var_scope(def.base_def.var_id());\n-                                    self.indexed.insert(seqvar.segments[0].name, Some(extent));\n-                                    return;  // no need to walk further\n-                                }\n-                                Def::Static(..) | Def::Const(..) => {\n-                                    self.indexed.insert(seqvar.segments[0].name, None);\n-                                    return;  // no need to walk further\n-                                }\n-                                _ => (),\n+                if_let_chain! {[\n+                    let Some(parexpr) = get_parent_expr(self.cx, expr),\n+                    let ExprIndex(ref seqexpr, _) = parexpr.node,\n+                    let ExprPath(None, ref seqvar) = seqexpr.node,\n+                    seqvar.segments.len() == 1\n+                ], {\n+                    let def_map = self.cx.tcx.def_map.borrow();\n+                    if let Some(def) = def_map.get(&seqexpr.id) {\n+                        match def.base_def {\n+                            Def::Local(..) | Def::Upvar(..) => {\n+                                let extent = self.cx.tcx.region_maps.var_scope(def.base_def.var_id());\n+                                self.indexed.insert(seqvar.segments[0].name, Some(extent));\n+                                return;  // no need to walk further\n                             }\n+                            Def::Static(..) | Def::Const(..) => {\n+                                self.indexed.insert(seqvar.segments[0].name, None);\n+                                return;  // no need to walk further\n+                            }\n+                            _ => (),\n                         }\n                     }\n-                }\n+                }}\n                 // we are not indexing anything, record that\n                 self.nonindex = true;\n                 return;"}, {"sha": "168aade325deebf74e61261ee00d29f534bb5e6a", "filename": "clippy_lints/src/map_clone.rs", "status": "modified", "additions": 19, "deletions": 21, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/4f3d14269e72f8a21c6f8b74e887faf42a665bc2/clippy_lints%2Fsrc%2Fmap_clone.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f3d14269e72f8a21c6f8b74e887faf42a665bc2/clippy_lints%2Fsrc%2Fmap_clone.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmap_clone.rs?ref=4f3d14269e72f8a21c6f8b74e887faf42a665bc2", "patch": "@@ -27,8 +27,7 @@ impl LateLintPass for MapClonePass {\n             if name.node.as_str() == \"map\" && args.len() == 2 {\n                 match args[1].node {\n                     ExprClosure(_, ref decl, ref blk, _) => {\n-                        if_let_chain! {\n-                            [\n+                        if_let_chain! {[\n                             // just one expression in the closure\n                             blk.stmts.is_empty(),\n                             let Some(ref closure_expr) = blk.expr,\n@@ -37,32 +36,31 @@ impl LateLintPass for MapClonePass {\n                             let Some(arg_ident) = get_arg_name(&*decl.inputs[0].pat),\n                             // the method is being called on a known type (option or iterator)\n                             let Some(type_name) = get_type_name(cx, expr, &args[0])\n-                            ], {\n-                                // look for derefs, for .map(|x| *x)\n-                                if only_derefs(cx, &*closure_expr, arg_ident) &&\n-                                    // .cloned() only removes one level of indirection, don't lint on more\n-                                    walk_ptrs_ty_depth(cx.tcx.pat_ty(&*decl.inputs[0].pat)).1 == 1\n+                        ], {\n+                            // look for derefs, for .map(|x| *x)\n+                            if only_derefs(cx, &*closure_expr, arg_ident) &&\n+                                // .cloned() only removes one level of indirection, don't lint on more\n+                                walk_ptrs_ty_depth(cx.tcx.pat_ty(&*decl.inputs[0].pat)).1 == 1\n+                            {\n+                                span_help_and_lint(cx, MAP_CLONE, expr.span, &format!(\n+                                    \"you seem to be using .map() to clone the contents of an {}, consider \\\n+                                    using `.cloned()`\", type_name),\n+                                    &format!(\"try\\n{}.cloned()\", snippet(cx, args[0].span, \"..\")));\n+                            }\n+                            // explicit clone() calls ( .map(|x| x.clone()) )\n+                            else if let ExprMethodCall(clone_call, _, ref clone_args) = closure_expr.node {\n+                                if clone_call.node.as_str() == \"clone\" &&\n+                                    clone_args.len() == 1 &&\n+                                    match_trait_method(cx, closure_expr, &paths::CLONE_TRAIT) &&\n+                                    expr_eq_name(&clone_args[0], arg_ident)\n                                 {\n                                     span_help_and_lint(cx, MAP_CLONE, expr.span, &format!(\n                                         \"you seem to be using .map() to clone the contents of an {}, consider \\\n                                         using `.cloned()`\", type_name),\n                                         &format!(\"try\\n{}.cloned()\", snippet(cx, args[0].span, \"..\")));\n                                 }\n-                                // explicit clone() calls ( .map(|x| x.clone()) )\n-                                else if let ExprMethodCall(clone_call, _, ref clone_args) = closure_expr.node {\n-                                    if clone_call.node.as_str() == \"clone\" &&\n-                                        clone_args.len() == 1 &&\n-                                        match_trait_method(cx, closure_expr, &paths::CLONE_TRAIT) &&\n-                                        expr_eq_name(&clone_args[0], arg_ident)\n-                                    {\n-                                        span_help_and_lint(cx, MAP_CLONE, expr.span, &format!(\n-                                            \"you seem to be using .map() to clone the contents of an {}, consider \\\n-                                            using `.cloned()`\", type_name),\n-                                            &format!(\"try\\n{}.cloned()\", snippet(cx, args[0].span, \"..\")));\n-                                    }\n-                                }\n                             }\n-                        }\n+                        }}\n                     }\n                     ExprPath(_, ref path) => {\n                         if match_path(path, &paths::CLONE) {"}, {"sha": "fab15ac3238f75336ed4c19d98389d0ff9142b38", "filename": "clippy_lints/src/matches.rs", "status": "modified", "additions": 19, "deletions": 19, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/4f3d14269e72f8a21c6f8b74e887faf42a665bc2/clippy_lints%2Fsrc%2Fmatches.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f3d14269e72f8a21c6f8b74e887faf42a665bc2/clippy_lints%2Fsrc%2Fmatches.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmatches.rs?ref=4f3d14269e72f8a21c6f8b74e887faf42a665bc2", "patch": "@@ -171,14 +171,14 @@ fn check_single_match_single_pattern(cx: &LateContext, ex: &Expr, arms: &[Arm],\n                            \"you seem to be trying to use match for destructuring a single pattern. \\\n                            Consider using `if let`\",\n                            |db| {\n-                               db.span_suggestion(expr.span,\n-                                                  \"try this\",\n-                                                  format!(\"if let {} = {} {}{}\",\n-                                                          snippet(cx, arms[0].pats[0].span, \"..\"),\n-                                                          snippet(cx, ex.span, \"..\"),\n-                                                          expr_block(cx, &arms[0].body, None, \"..\"),\n-                                                          els_str));\n-                           });\n+            db.span_suggestion(expr.span,\n+                               \"try this\",\n+                               format!(\"if let {} = {} {}{}\",\n+                                       snippet(cx, arms[0].pats[0].span, \"..\"),\n+                                       snippet(cx, ex.span, \"..\"),\n+                                       expr_block(cx, &arms[0].body, None, \"..\"),\n+                                       els_str));\n+        });\n     }\n }\n \n@@ -219,14 +219,14 @@ fn check_single_match_opt_like(cx: &LateContext, ex: &Expr, arms: &[Arm], expr:\n                                \"you seem to be trying to use match for destructuring a single pattern. Consider \\\n                                 using `if let`\",\n                                |db| {\n-                                   db.span_suggestion(expr.span,\n-                                                      \"try this\",\n-                                                      format!(\"if let {} = {} {}{}\",\n-                                                              snippet(cx, arms[0].pats[0].span, \"..\"),\n-                                                              snippet(cx, ex.span, \"..\"),\n-                                                              expr_block(cx, &arms[0].body, None, \"..\"),\n-                                                              els_str));\n-                               });\n+                db.span_suggestion(expr.span,\n+                                   \"try this\",\n+                                   format!(\"if let {} = {} {}{}\",\n+                                           snippet(cx, arms[0].pats[0].span, \"..\"),\n+                                           snippet(cx, ex.span, \"..\"),\n+                                           expr_block(cx, &arms[0].body, None, \"..\"),\n+                                           els_str));\n+            });\n         }\n     }\n }\n@@ -339,15 +339,15 @@ fn all_ranges(cx: &LateContext, arms: &[Arm]) -> Vec<SpannedRange<ConstVal>> {\n                 Some(pats.iter().filter_map(|pat| {\n                     if_let_chain! {[\n                         let PatKind::Range(ref lhs, ref rhs) = pat.node,\n-                        let Ok(lhs) = eval_const_expr_partial(cx.tcx, &lhs, ExprTypeChecked, None),\n-                        let Ok(rhs) = eval_const_expr_partial(cx.tcx, &rhs, ExprTypeChecked, None)\n+                        let Ok(lhs) = eval_const_expr_partial(cx.tcx, lhs, ExprTypeChecked, None),\n+                        let Ok(rhs) = eval_const_expr_partial(cx.tcx, rhs, ExprTypeChecked, None)\n                     ], {\n                         return Some(SpannedRange { span: pat.span, node: (lhs, rhs) });\n                     }}\n \n                     if_let_chain! {[\n                         let PatKind::Lit(ref value) = pat.node,\n-                        let Ok(value) = eval_const_expr_partial(cx.tcx, &value, ExprTypeChecked, None)\n+                        let Ok(value) = eval_const_expr_partial(cx.tcx, value, ExprTypeChecked, None)\n                     ], {\n                         return Some(SpannedRange { span: pat.span, node: (value.clone(), value) });\n                     }}"}, {"sha": "4dfb0fe88e0b7fdeed58b72eadfffae2f13a4a63", "filename": "clippy_lints/src/mem_forget.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4f3d14269e72f8a21c6f8b74e887faf42a665bc2/clippy_lints%2Fsrc%2Fmem_forget.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f3d14269e72f8a21c6f8b74e887faf42a665bc2/clippy_lints%2Fsrc%2Fmem_forget.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmem_forget.rs?ref=4f3d14269e72f8a21c6f8b74e887faf42a665bc2", "patch": "@@ -33,7 +33,7 @@ impl LateLintPass for MemForget {\n \n                     if match forgot_ty.ty_adt_def() {\n                         Some(def) => def.has_dtor(),\n-                        _ => false\n+                        _ => false,\n                     } {\n                         span_lint(cx, MEM_FORGET, e.span, \"usage of mem::forget on Drop type\");\n                     }"}, {"sha": "9dcc8f9d016ee9067e3ac43d61105c70289824ba", "filename": "clippy_lints/src/methods.rs", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/4f3d14269e72f8a21c6f8b74e887faf42a665bc2/clippy_lints%2Fsrc%2Fmethods.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f3d14269e72f8a21c6f8b74e887faf42a665bc2/clippy_lints%2Fsrc%2Fmethods.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods.rs?ref=4f3d14269e72f8a21c6f8b74e887faf42a665bc2", "patch": "@@ -452,8 +452,8 @@ impl LateLintPass for MethodsPass {\n                                   explicit_self.span,\n                                   \"methods called `new` usually return `Self`\");\n                     }\n-                }\n-            }}\n+                }}\n+            }\n         }\n     }\n }\n@@ -1022,9 +1022,7 @@ impl OutType {\n             (&OutType::Unit, &hir::Return(ref ty)) if ty.node == hir::TyTup(vec![].into()) => true,\n             (&OutType::Bool, &hir::Return(ref ty)) if is_bool(ty) => true,\n             (&OutType::Any, &hir::Return(ref ty)) if ty.node != hir::TyTup(vec![].into()) => true,\n-            (&OutType::Ref, &hir::Return(ref ty)) => {\n-                matches!(ty.node, hir::TyRptr(_, _))\n-            }\n+            (&OutType::Ref, &hir::Return(ref ty)) => matches!(ty.node, hir::TyRptr(_, _)),\n             _ => false,\n         }\n     }"}, {"sha": "3d9795b0c38f142cd225de796d9843546e93deba", "filename": "clippy_lints/src/misc.rs", "status": "modified", "additions": 21, "deletions": 23, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/4f3d14269e72f8a21c6f8b74e887faf42a665bc2/clippy_lints%2Fsrc%2Fmisc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f3d14269e72f8a21c6f8b74e887faf42a665bc2/clippy_lints%2Fsrc%2Fmisc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmisc.rs?ref=4f3d14269e72f8a21c6f8b74e887faf42a665bc2", "patch": "@@ -55,33 +55,31 @@ impl LateLintPass for TopLevelRefPass {\n         }\n     }\n     fn check_stmt(&mut self, cx: &LateContext, s: &Stmt) {\n-        if_let_chain! {\n-            [\n+        if_let_chain! {[\n             let StmtDecl(ref d, _) = s.node,\n             let DeclLocal(ref l) = d.node,\n             let PatKind::Binding(BindByRef(_), i, None) = l.pat.node,\n             let Some(ref init) = l.init\n-            ], {\n-                let tyopt = if let Some(ref ty) = l.ty {\n-                    format!(\": {}\", snippet(cx, ty.span, \"_\"))\n-                } else {\n-                    \"\".to_owned()\n-                };\n-                span_lint_and_then(cx,\n-                    TOPLEVEL_REF_ARG,\n-                    l.pat.span,\n-                    \"`ref` on an entire `let` pattern is discouraged, take a reference with & instead\",\n-                    |db| {\n-                        db.span_suggestion(s.span,\n-                                           \"try\",\n-                                           format!(\"let {}{} = &{};\",\n-                                                   snippet(cx, i.span, \"_\"),\n-                                                   tyopt,\n-                                                   snippet(cx, init.span, \"_\")));\n-                    }\n-                );\n-            }\n-        };\n+        ], {\n+            let tyopt = if let Some(ref ty) = l.ty {\n+                format!(\": {}\", snippet(cx, ty.span, \"_\"))\n+            } else {\n+                \"\".to_owned()\n+            };\n+            span_lint_and_then(cx,\n+                TOPLEVEL_REF_ARG,\n+                l.pat.span,\n+                \"`ref` on an entire `let` pattern is discouraged, take a reference with & instead\",\n+                |db| {\n+                    db.span_suggestion(s.span,\n+                                       \"try\",\n+                                       format!(\"let {}{} = &{};\",\n+                                               snippet(cx, i.span, \"_\"),\n+                                               tyopt,\n+                                               snippet(cx, init.span, \"_\")));\n+                }\n+            );\n+        }}\n     }\n }\n "}, {"sha": "0bed45b0b5bbe387671ac07ecf7666449a577763", "filename": "clippy_lints/src/mut_mut.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/4f3d14269e72f8a21c6f8b74e887faf42a665bc2/clippy_lints%2Fsrc%2Fmut_mut.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f3d14269e72f8a21c6f8b74e887faf42a665bc2/clippy_lints%2Fsrc%2Fmut_mut.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmut_mut.rs?ref=4f3d14269e72f8a21c6f8b74e887faf42a665bc2", "patch": "@@ -34,10 +34,7 @@ impl LateLintPass for MutMut {\n \n         if let ExprAddrOf(MutMutable, ref e) = expr.node {\n             if let ExprAddrOf(MutMutable, _) = e.node {\n-                span_lint(cx,\n-                          MUT_MUT,\n-                          expr.span,\n-                          \"generally you want to avoid `&mut &mut _` if possible\");\n+                span_lint(cx, MUT_MUT, expr.span, \"generally you want to avoid `&mut &mut _` if possible\");\n             } else {\n                 if let TyRef(_, TypeAndMut { mutbl: MutMutable, .. }) = cx.tcx.expr_ty(e).sty {\n                     span_lint(cx,"}, {"sha": "356a46c28c32d8c18702037c22fabb63f2f9a645", "filename": "clippy_lints/src/needless_borrow.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/4f3d14269e72f8a21c6f8b74e887faf42a665bc2/clippy_lints%2Fsrc%2Fneedless_borrow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f3d14269e72f8a21c6f8b74e887faf42a665bc2/clippy_lints%2Fsrc%2Fneedless_borrow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fneedless_borrow.rs?ref=4f3d14269e72f8a21c6f8b74e887faf42a665bc2", "patch": "@@ -42,7 +42,8 @@ impl LateLintPass for NeedlessBorrow {\n                         span_lint(cx,\n                                   NEEDLESS_BORROW,\n                                   e.span,\n-                                  \"this expression borrows a reference that is immediately dereferenced by the compiler\");\n+                                  \"this expression borrows a reference that is immediately dereferenced by the \\\n+                                   compiler\");\n                     }\n                 }\n             }"}, {"sha": "407ba227674115180e7a5ab76604a9876bfb3eb3", "filename": "clippy_lints/src/neg_multiply.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4f3d14269e72f8a21c6f8b74e887faf42a665bc2/clippy_lints%2Fsrc%2Fneg_multiply.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f3d14269e72f8a21c6f8b74e887faf42a665bc2/clippy_lints%2Fsrc%2Fneg_multiply.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fneg_multiply.rs?ref=4f3d14269e72f8a21c6f8b74e887faf42a665bc2", "patch": "@@ -35,7 +35,7 @@ impl LateLintPass for NegMultiply {\n                 (&ExprUnary(..), &ExprUnary(..)) => (),\n                 (&ExprUnary(UnNeg, ref lit), _) => check_mul(cx, e.span, lit, r),\n                 (_, &ExprUnary(UnNeg, ref lit)) => check_mul(cx, e.span, lit, l),\n-                _ => ()\n+                _ => (),\n             }\n         }\n     }\n@@ -49,7 +49,7 @@ fn check_mul(cx: &LateContext, span: Span, lit: &Expr, exp: &Expr) {\n         val == 1,\n         cx.tcx.expr_ty(exp).is_integral()\n     ], {\n-        span_lint(cx, \n+        span_lint(cx,\n                   NEG_MULTIPLY,\n                   span,\n                   \"Negation by multiplying with -1\");"}, {"sha": "f400f1b66434337ae7b52bdff8c5c1bc77c55a4d", "filename": "clippy_lints/src/new_without_default.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/4f3d14269e72f8a21c6f8b74e887faf42a665bc2/clippy_lints%2Fsrc%2Fnew_without_default.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f3d14269e72f8a21c6f8b74e887faf42a665bc2/clippy_lints%2Fsrc%2Fnew_without_default.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fnew_without_default.rs?ref=4f3d14269e72f8a21c6f8b74e887faf42a665bc2", "patch": "@@ -100,10 +100,10 @@ impl LateLintPass for NewWithoutDefault {\n                 // can't be implemented by default\n                 return;\n             }\n-            if decl.inputs.is_empty() && name.as_str() == \"new\" &&\n-                    cx.access_levels.is_reachable(id) {\n-                let self_ty = cx.tcx.lookup_item_type(cx.tcx.map.local_def_id(\n-                    cx.tcx.map.get_parent(id))).ty;\n+            if decl.inputs.is_empty() && name.as_str() == \"new\" && cx.access_levels.is_reachable(id) {\n+                let self_ty = cx.tcx\n+                    .lookup_item_type(cx.tcx.map.local_def_id(cx.tcx.map.get_parent(id)))\n+                    .ty;\n                 if_let_chain!{[\n                     self_ty.walk_shallow().next().is_none(), // implements_trait does not work with generics\n                     let Some(ret_ty) = return_ty(cx, id),\n@@ -143,11 +143,11 @@ fn can_derive_default<'t, 'c>(ty: ty::Ty<'t>, cx: &LateContext<'c, 't>, default_\n             for field in adt_def.all_fields() {\n                 let f_ty = field.ty(cx.tcx, substs);\n                 if !implements_trait(cx, f_ty, default_trait_id, Vec::new()) {\n-                    return false\n+                    return false;\n                 }\n             }\n             true\n-        },\n-        _ => false\n+        }\n+        _ => false,\n     }\n }"}, {"sha": "a9ac0a248561e266110a9129e125e705f981a366", "filename": "clippy_lints/src/no_effect.rs", "status": "modified", "additions": 10, "deletions": 6, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/4f3d14269e72f8a21c6f8b74e887faf42a665bc2/clippy_lints%2Fsrc%2Fno_effect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f3d14269e72f8a21c6f8b74e887faf42a665bc2/clippy_lints%2Fsrc%2Fno_effect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fno_effect.rs?ref=4f3d14269e72f8a21c6f8b74e887faf42a665bc2", "patch": "@@ -130,7 +130,9 @@ fn reduce_expression<'a>(cx: &LateContext, expr: &'a Expr) -> Option<Vec<&'a Exp\n         Expr_::ExprTupField(ref inner, _) |\n         Expr_::ExprAddrOf(_, ref inner) |\n         Expr_::ExprBox(ref inner) => reduce_expression(cx, inner).or_else(|| Some(vec![inner])),\n-        Expr_::ExprStruct(_, ref fields, ref base) => Some(fields.iter().map(|f| &f.expr).chain(base).map(Deref::deref).collect()),\n+        Expr_::ExprStruct(_, ref fields, ref base) => {\n+            Some(fields.iter().map(|f| &f.expr).chain(base).map(Deref::deref).collect())\n+        }\n         Expr_::ExprCall(ref callee, ref args) => {\n             match cx.tcx.def_map.borrow().get(&callee.id).map(PathResolution::full_def) {\n                 Some(Def::Struct(..)) |\n@@ -140,11 +142,13 @@ fn reduce_expression<'a>(cx: &LateContext, expr: &'a Expr) -> Option<Vec<&'a Exp\n         }\n         Expr_::ExprBlock(ref block) => {\n             if block.stmts.is_empty() {\n-                block.expr.as_ref().and_then(|e| match block.rules {\n-                    BlockCheckMode::UnsafeBlock(UnsafeSource::UserProvided) => None,\n-                    BlockCheckMode::DefaultBlock => Some(vec![&**e]),\n-                    // in case of compiler-inserted signaling blocks\n-                    _ => reduce_expression(cx, e),\n+                block.expr.as_ref().and_then(|e| {\n+                    match block.rules {\n+                        BlockCheckMode::UnsafeBlock(UnsafeSource::UserProvided) => None,\n+                        BlockCheckMode::DefaultBlock => Some(vec![&**e]),\n+                        // in case of compiler-inserted signaling blocks\n+                        _ => reduce_expression(cx, e),\n+                    }\n                 })\n             } else {\n                 None"}, {"sha": "aa8608fb7bd0eb942d20e53884c2980efa84bd95", "filename": "clippy_lints/src/non_expressive_names.rs", "status": "modified", "additions": 12, "deletions": 10, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/4f3d14269e72f8a21c6f8b74e887faf42a665bc2/clippy_lints%2Fsrc%2Fnon_expressive_names.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f3d14269e72f8a21c6f8b74e887faf42a665bc2/clippy_lints%2Fsrc%2Fnon_expressive_names.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fnon_expressive_names.rs?ref=4f3d14269e72f8a21c6f8b74e887faf42a665bc2", "patch": "@@ -72,11 +72,13 @@ impl<'v, 'a, 'b, 'c> Visitor<'v> for SimilarNamesNameVisitor<'a, 'b, 'c> {\n     fn visit_pat(&mut self, pat: &'v Pat) {\n         match pat.node {\n             PatKind::Ident(_, id, _) => self.check_name(id.span, id.node.name),\n-            PatKind::Struct(_, ref fields, _) => for field in fields {\n-                if !field.node.is_shorthand {\n-                    self.visit_pat(&field.node.pat);\n+            PatKind::Struct(_, ref fields, _) => {\n+                for field in fields {\n+                    if !field.node.is_shorthand {\n+                        self.visit_pat(&field.node.pat);\n+                    }\n                 }\n-            },\n+            }\n             _ => walk_pat(self, pat),\n         }\n     }\n@@ -193,15 +195,15 @@ impl<'a, 'b, 'c> SimilarNamesNameVisitor<'a, 'b, 'c> {\n                                span,\n                                \"binding's name is too similar to existing binding\",\n                                |diag| {\n-                                   diag.span_note(existing_name.span, \"existing binding defined here\");\n-                                   if let Some(split) = split_at {\n-                                       diag.span_help(span,\n-                                                      &format!(\"separate the discriminating character by an \\\n+                diag.span_note(existing_name.span, \"existing binding defined here\");\n+                if let Some(split) = split_at {\n+                    diag.span_help(span,\n+                                   &format!(\"separate the discriminating character by an \\\n                                                                 underscore like: `{}_{}`\",\n                                                                &interned_name[..split],\n                                                                &interned_name[split..]));\n-                                   }\n-                               });\n+                }\n+            });\n             return;\n         }\n         self.0.names.push(ExistingName {"}, {"sha": "5e4386fb778b5ba0dded77ca6d64e17e1ae5b3f3", "filename": "clippy_lints/src/overflow_check_conditional.rs", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/4f3d14269e72f8a21c6f8b74e887faf42a665bc2/clippy_lints%2Fsrc%2Foverflow_check_conditional.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f3d14269e72f8a21c6f8b74e887faf42a665bc2/clippy_lints%2Fsrc%2Foverflow_check_conditional.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Foverflow_check_conditional.rs?ref=4f3d14269e72f8a21c6f8b74e887faf42a665bc2", "patch": "@@ -26,14 +26,14 @@ impl LateLintPass for OverflowCheckConditional {\n     // a + b < a, a > a + b, a < a - b, a - b > a\n     fn check_expr(&mut self, cx: &LateContext, expr: &Expr) {\n         if_let_chain! {[\n-        let Expr_::ExprBinary(ref op, ref first, ref second) = expr.node,\n-        let Expr_::ExprBinary(ref op2, ref ident1, ref ident2) = first.node,\n-        let Expr_::ExprPath(_,ref path1) = ident1.node,\n-        let Expr_::ExprPath(_, ref path2) = ident2.node,\n-        let Expr_::ExprPath(_, ref path3) = second.node,\n-        &path1.segments[0] == &path3.segments[0] || &path2.segments[0] == &path3.segments[0],\n-        cx.tcx.expr_ty(ident1).is_integral(),\n-        cx.tcx.expr_ty(ident2).is_integral()\n+            let Expr_::ExprBinary(ref op, ref first, ref second) = expr.node,\n+            let Expr_::ExprBinary(ref op2, ref ident1, ref ident2) = first.node,\n+            let Expr_::ExprPath(_,ref path1) = ident1.node,\n+            let Expr_::ExprPath(_, ref path2) = ident2.node,\n+            let Expr_::ExprPath(_, ref path3) = second.node,\n+            &path1.segments[0] == &path3.segments[0] || &path2.segments[0] == &path3.segments[0],\n+            cx.tcx.expr_ty(ident1).is_integral(),\n+            cx.tcx.expr_ty(ident2).is_integral()\n         ], {\n             if let BinOp_::BiLt = op.node {\n                 if let BinOp_::BiAdd = op2.node {\n@@ -48,14 +48,14 @@ impl LateLintPass for OverflowCheckConditional {\n         }}\n \n         if_let_chain! {[\n-        let Expr_::ExprBinary(ref op, ref first, ref second) = expr.node,\n-        let Expr_::ExprBinary(ref op2, ref ident1, ref ident2) = second.node,\n-        let Expr_::ExprPath(_,ref path1) = ident1.node,\n-        let Expr_::ExprPath(_, ref path2) = ident2.node,\n-        let Expr_::ExprPath(_, ref path3) = first.node,\n-        &path1.segments[0] == &path3.segments[0] || &path2.segments[0] == &path3.segments[0],\n-        cx.tcx.expr_ty(ident1).is_integral(),\n-        cx.tcx.expr_ty(ident2).is_integral()\n+            let Expr_::ExprBinary(ref op, ref first, ref second) = expr.node,\n+            let Expr_::ExprBinary(ref op2, ref ident1, ref ident2) = second.node,\n+            let Expr_::ExprPath(_,ref path1) = ident1.node,\n+            let Expr_::ExprPath(_, ref path2) = ident2.node,\n+            let Expr_::ExprPath(_, ref path3) = first.node,\n+            &path1.segments[0] == &path3.segments[0] || &path2.segments[0] == &path3.segments[0],\n+            cx.tcx.expr_ty(ident1).is_integral(),\n+            cx.tcx.expr_ty(ident2).is_integral()\n         ], {\n             if let BinOp_::BiGt = op.node {\n                 if let BinOp_::BiAdd = op2.node {"}, {"sha": "8eacbadf8df6c2da3aee162a6a966173938a7c66", "filename": "clippy_lints/src/ranges.rs", "status": "modified", "additions": 21, "deletions": 23, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/4f3d14269e72f8a21c6f8b74e887faf42a665bc2/clippy_lints%2Fsrc%2Franges.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f3d14269e72f8a21c6f8b74e887faf42a665bc2/clippy_lints%2Fsrc%2Franges.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Franges.rs?ref=4f3d14269e72f8a21c6f8b74e887faf42a665bc2", "patch": "@@ -49,29 +49,27 @@ impl LateLintPass for StepByZero {\n             } else if name.as_str() == \"zip\" && args.len() == 2 {\n                 let iter = &args[0].node;\n                 let zip_arg = &args[1];\n-                if_let_chain! {\n-                    [\n-                        // .iter() call\n-                        let ExprMethodCall( Spanned { node: ref iter_name, .. }, _, ref iter_args ) = *iter,\n-                        iter_name.as_str() == \"iter\",\n-                        // range expression in .zip() call: 0..x.len()\n-                        let Some(UnsugaredRange { start: Some(ref start), end: Some(ref end), .. }) = unsugar_range(zip_arg),\n-                        is_integer_literal(start, 0),\n-                        // .len() call\n-                        let ExprMethodCall(Spanned { node: ref len_name, .. }, _, ref len_args) = end.node,\n-                        len_name.as_str() == \"len\" && len_args.len() == 1,\n-                        // .iter() and .len() called on same Path\n-                        let ExprPath(_, Path { segments: ref iter_path, .. }) = iter_args[0].node,\n-                        let ExprPath(_, Path { segments: ref len_path, .. }) = len_args[0].node,\n-                        iter_path == len_path\n-                     ], {\n-                        span_lint(cx,\n-                                  RANGE_ZIP_WITH_LEN,\n-                                  expr.span,\n-                                  &format!(\"It is more idiomatic to use {}.iter().enumerate()\",\n-                                           snippet(cx, iter_args[0].span, \"_\")));\n-                    }\n-                }\n+                if_let_chain! {[\n+                    // .iter() call\n+                    let ExprMethodCall( Spanned { node: ref iter_name, .. }, _, ref iter_args ) = *iter,\n+                    iter_name.as_str() == \"iter\",\n+                    // range expression in .zip() call: 0..x.len()\n+                    let Some(UnsugaredRange { start: Some(ref start), end: Some(ref end), .. }) = unsugar_range(zip_arg),\n+                    is_integer_literal(start, 0),\n+                    // .len() call\n+                    let ExprMethodCall(Spanned { node: ref len_name, .. }, _, ref len_args) = end.node,\n+                    len_name.as_str() == \"len\" && len_args.len() == 1,\n+                    // .iter() and .len() called on same Path\n+                    let ExprPath(_, Path { segments: ref iter_path, .. }) = iter_args[0].node,\n+                    let ExprPath(_, Path { segments: ref len_path, .. }) = len_args[0].node,\n+                    iter_path == len_path\n+                 ], {\n+                    span_lint(cx,\n+                              RANGE_ZIP_WITH_LEN,\n+                              expr.span,\n+                              &format!(\"It is more idiomatic to use {}.iter().enumerate()\",\n+                                       snippet(cx, iter_args[0].span, \"_\")));\n+                }}\n             }\n         }\n     }"}, {"sha": "8b84f94fa8e06a3e4f036251e8687e039786ff36", "filename": "clippy_lints/src/regex.rs", "status": "modified", "additions": 11, "deletions": 9, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/4f3d14269e72f8a21c6f8b74e887faf42a665bc2/clippy_lints%2Fsrc%2Fregex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f3d14269e72f8a21c6f8b74e887faf42a665bc2/clippy_lints%2Fsrc%2Fregex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fregex.rs?ref=4f3d14269e72f8a21c6f8b74e887faf42a665bc2", "patch": "@@ -104,13 +104,11 @@ impl LateLintPass for RegexPass {\n             let Some(def) = cx.tcx.def_map.borrow().get(&fun.id),\n         ], {\n             let def_id = def.def_id();\n-            if match_def_path(cx, def_id, &paths::REGEX_NEW) {\n+            if match_def_path(cx, def_id, &paths::REGEX_NEW) ||\n+               match_def_path(cx, def_id, &paths::REGEX_BUILDER_NEW) {\n                 check_regex(cx, &args[0], true);\n-            } else if match_def_path(cx, def_id, &paths::REGEX_BYTES_NEW) {\n-                check_regex(cx, &args[0], false);\n-            } else if match_def_path(cx, def_id, &paths::REGEX_BUILDER_NEW) {\n-                check_regex(cx, &args[0], true);\n-            } else if match_def_path(cx, def_id, &paths::REGEX_BYTES_BUILDER_NEW) {\n+            } else if match_def_path(cx, def_id, &paths::REGEX_BYTES_NEW) ||\n+               match_def_path(cx, def_id, &paths::REGEX_BYTES_BUILDER_NEW) {\n                 check_regex(cx, &args[0], false);\n             } else if match_def_path(cx, def_id, &paths::REGEX_SET_NEW) {\n                 check_set(cx, &args[0], true);\n@@ -125,7 +123,7 @@ impl LateLintPass for RegexPass {\n fn str_span(base: Span, s: &str, c: usize) -> Span {\n     let mut si = s.char_indices().skip(c);\n \n-    match (si.next(), si.next())  {\n+    match (si.next(), si.next()) {\n         (Some((l, _)), Some((h, _))) => {\n             Span {\n                 lo: base.lo + BytePos(l as u32),\n@@ -193,7 +191,9 @@ fn check_regex(cx: &LateContext, expr: &Expr, utf8: bool) {\n             match builder.parse(r) {\n                 Ok(r) => {\n                     if let Some(repl) = is_trivial_regex(&r) {\n-                        span_help_and_lint(cx, TRIVIAL_REGEX, expr.span,\n+                        span_help_and_lint(cx,\n+                                           TRIVIAL_REGEX,\n+                                           expr.span,\n                                            \"trivial regex\",\n                                            &format!(\"consider using {}\", repl));\n                     }\n@@ -211,7 +211,9 @@ fn check_regex(cx: &LateContext, expr: &Expr, utf8: bool) {\n         match builder.parse(&r) {\n             Ok(r) => {\n                 if let Some(repl) = is_trivial_regex(&r) {\n-                    span_help_and_lint(cx, TRIVIAL_REGEX, expr.span,\n+                    span_help_and_lint(cx,\n+                                       TRIVIAL_REGEX,\n+                                       expr.span,\n                                        \"trivial regex\",\n                                        &format!(\"consider using {}\", repl));\n                 }"}, {"sha": "6beed822a81abf33687b18d459c1d3d851fe0434", "filename": "clippy_lints/src/returns.rs", "status": "modified", "additions": 12, "deletions": 15, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/4f3d14269e72f8a21c6f8b74e887faf42a665bc2/clippy_lints%2Fsrc%2Freturns.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f3d14269e72f8a21c6f8b74e887faf42a665bc2/clippy_lints%2Fsrc%2Freturns.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Freturns.rs?ref=4f3d14269e72f8a21c6f8b74e887faf42a665bc2", "patch": "@@ -89,28 +89,25 @@ impl ReturnPass {\n     // Check for \"let x = EXPR; x\"\n     fn check_let_return(&mut self, cx: &EarlyContext, block: &Block) {\n         // we need both a let-binding stmt and an expr\n-        if_let_chain! {\n-            [\n-                let Some(stmt) = block.stmts.last(),\n-                let Some(ref retexpr) = block.expr,\n-                let StmtKind::Decl(ref decl, _) = stmt.node,\n-                let DeclKind::Local(ref local) = decl.node,\n-                local.ty.is_none(),\n-                let Some(ref initexpr) = local.init,\n-                let PatKind::Ident(_, Spanned { node: id, .. }, _) = local.pat.node,\n-                let ExprKind::Path(_, ref path) = retexpr.node,\n-                match_path_ast(path, &[&id.name.as_str()]),\n-                !in_external_macro(cx, initexpr.span),\n-            ], {\n+        if_let_chain! {[\n+            let Some(stmt) = block.stmts.last(),\n+            let Some(ref retexpr) = block.expr,\n+            let StmtKind::Decl(ref decl, _) = stmt.node,\n+            let DeclKind::Local(ref local) = decl.node,\n+            let Some(ref initexpr) = local.init,\n+            let PatKind::Ident(_, Spanned { node: id, .. }, _) = local.pat.node,\n+            let ExprKind::Path(_, ref path) = retexpr.node,\n+            match_path_ast(path, &[&id.name.as_str()]),\n+            !in_external_macro(cx, initexpr.span),\n+        ], {\n                 span_note_and_lint(cx,\n                                    LET_AND_RETURN,\n                                    retexpr.span,\n                                    \"returning the result of a let binding from a block. \\\n                                    Consider returning the expression directly.\",\n                                    initexpr.span,\n                                    \"this expression can be directly returned\");\n-            }\n-        }\n+        }}\n     }\n }\n "}, {"sha": "8a1a13187b355e817448497e82319f3c0f6f945c", "filename": "clippy_lints/src/types.rs", "status": "modified", "additions": 15, "deletions": 18, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/4f3d14269e72f8a21c6f8b74e887faf42a665bc2/clippy_lints%2Fsrc%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f3d14269e72f8a21c6f8b74e887faf42a665bc2/clippy_lints%2Fsrc%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Ftypes.rs?ref=4f3d14269e72f8a21c6f8b74e887faf42a665bc2", "patch": "@@ -57,24 +57,21 @@ impl LateLintPass for TypePass {\n         if let Some(did) = cx.tcx.def_map.borrow().get(&ast_ty.id) {\n             if let def::Def::Struct(..) = did.full_def() {\n                 if Some(did.def_id()) == cx.tcx.lang_items.owned_box() {\n-                    if_let_chain! {\n-                        [\n-                            let TyPath(_, ref path) = ast_ty.node,\n-                            let Some(ref last) = path.segments.last(),\n-                            let PathParameters::AngleBracketedParameters(ref ag) = last.parameters,\n-                            let Some(ref vec) = ag.types.get(0),\n-                            let Some(did) = cx.tcx.def_map.borrow().get(&vec.id),\n-                            let def::Def::Struct(..) = did.full_def(),\n-                            match_def_path(cx, did.def_id(), &paths::VEC),\n-                        ],\n-                        {\n-                            span_help_and_lint(cx,\n-                                               BOX_VEC,\n-                                               ast_ty.span,\n-                                               \"you seem to be trying to use `Box<Vec<T>>`. Consider using just `Vec<T>`\",\n-                                               \"`Vec<T>` is already on the heap, `Box<Vec<T>>` makes an extra allocation.\");\n-                        }\n-                    }\n+                    if_let_chain! {[\n+                        let TyPath(_, ref path) = ast_ty.node,\n+                        let Some(ref last) = path.segments.last(),\n+                        let PathParameters::AngleBracketedParameters(ref ag) = last.parameters,\n+                        let Some(ref vec) = ag.types.get(0),\n+                        let Some(did) = cx.tcx.def_map.borrow().get(&vec.id),\n+                        let def::Def::Struct(..) = did.full_def(),\n+                        match_def_path(cx, did.def_id(), &paths::VEC),\n+                    ], {\n+                        span_help_and_lint(cx,\n+                                           BOX_VEC,\n+                                           ast_ty.span,\n+                                           \"you seem to be trying to use `Box<Vec<T>>`. Consider using just `Vec<T>`\",\n+                                           \"`Vec<T>` is already on the heap, `Box<Vec<T>>` makes an extra allocation.\");\n+                    }}\n                 } else if match_def_path(cx, did.def_id(), &paths::LINKED_LIST) {\n                     span_help_and_lint(cx,\n                                        LINKEDLIST,"}, {"sha": "116e1eb1bdc8349e098a3121c8fa1363f0dc5431", "filename": "clippy_lints/src/unsafe_removed_from_name.rs", "status": "modified", "additions": 6, "deletions": 7, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/4f3d14269e72f8a21c6f8b74e887faf42a665bc2/clippy_lints%2Fsrc%2Funsafe_removed_from_name.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f3d14269e72f8a21c6f8b74e887faf42a665bc2/clippy_lints%2Fsrc%2Funsafe_removed_from_name.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Funsafe_removed_from_name.rs?ref=4f3d14269e72f8a21c6f8b74e887faf42a665bc2", "patch": "@@ -45,15 +45,15 @@ impl LateLintPass for UnsafeNameRemoval {\n                         *name,\n                         cx, &item.span\n                         );\n-                },\n+                }\n                 ViewPath_::ViewPathList(_, ref path_list_items) => {\n                     for path_list_item in path_list_items.iter() {\n                         let plid = path_list_item.node;\n                         if let (Some(name), Some(rename)) = (plid.name(), plid.rename()) {\n                             unsafe_to_safe_check(name, rename, cx, &item.span);\n                         };\n                     }\n-                },\n+                }\n                 ViewPath_::ViewPathGlob(_) => {}\n             }\n         }\n@@ -64,11 +64,10 @@ fn unsafe_to_safe_check(old_name: Name, new_name: Name, cx: &LateContext, span:\n     let old_str = old_name.as_str();\n     let new_str = new_name.as_str();\n     if contains_unsafe(&old_str) && !contains_unsafe(&new_str) {\n-        span_lint(\n-            cx,\n-            UNSAFE_REMOVED_FROM_NAME,\n-            *span,\n-            &format!(\n+        span_lint(cx,\n+                  UNSAFE_REMOVED_FROM_NAME,\n+                  *span,\n+                  &format!(\n                 \"removed \\\"unsafe\\\" from the name of `{}` in use as `{}`\",\n                 old_str,\n                 new_str"}, {"sha": "a97b593095f293b6c2868239531f9eedd0d377ce", "filename": "clippy_lints/src/unused_label.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/4f3d14269e72f8a21c6f8b74e887faf42a665bc2/clippy_lints%2Fsrc%2Funused_label.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f3d14269e72f8a21c6f8b74e887faf42a665bc2/clippy_lints%2Fsrc%2Funused_label.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Funused_label.rs?ref=4f3d14269e72f8a21c6f8b74e887faf42a665bc2", "patch": "@@ -64,10 +64,12 @@ impl LateLintPass for UnusedLabel {\n impl<'v> Visitor<'v> for UnusedLabelVisitor {\n     fn visit_expr(&mut self, expr: &hir::Expr) {\n         match expr.node {\n-            hir::ExprBreak(Some(label)) | hir::ExprAgain(Some(label)) => {\n+            hir::ExprBreak(Some(label)) |\n+            hir::ExprAgain(Some(label)) => {\n                 self.labels.remove(&label.node.as_str());\n             }\n-            hir::ExprLoop(_, Some(label)) | hir::ExprWhile(_, _, Some(label)) => {\n+            hir::ExprLoop(_, Some(label)) |\n+            hir::ExprWhile(_, _, Some(label)) => {\n                 self.labels.insert(label.node.as_str(), expr.span);\n             }\n             _ => (),"}, {"sha": "f81fcbc38ab15fb107af3ce52cb182f9abc5d3bf", "filename": "clippy_lints/src/utils/cargo.rs", "status": "modified", "additions": 9, "deletions": 3, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/4f3d14269e72f8a21c6f8b74e887faf42a665bc2/clippy_lints%2Fsrc%2Futils%2Fcargo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f3d14269e72f8a21c6f8b74e887faf42a665bc2/clippy_lints%2Fsrc%2Futils%2Fcargo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Fcargo.rs?ref=4f3d14269e72f8a21c6f8b74e887faf42a665bc2", "patch": "@@ -50,13 +50,19 @@ pub enum Error {\n }\n \n impl From<io::Error> for Error {\n-    fn from(err: io::Error) -> Self { Error::Io(err) }\n+    fn from(err: io::Error) -> Self {\n+        Error::Io(err)\n+    }\n }\n impl From<Utf8Error> for Error {\n-    fn from(err: Utf8Error) -> Self { Error::Utf8(err) }\n+    fn from(err: Utf8Error) -> Self {\n+        Error::Utf8(err)\n+    }\n }\n impl From<json::DecoderError> for Error {\n-    fn from(err: json::DecoderError) -> Self { Error::Json(err) }\n+    fn from(err: json::DecoderError) -> Self {\n+        Error::Json(err)\n+    }\n }\n \n pub fn metadata() -> Result<Metadata, Error> {"}, {"sha": "88a9e03182ca2ef3cb45de22ec37e5c3b27590c3", "filename": "clippy_lints/src/utils/hir.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4f3d14269e72f8a21c6f8b74e887faf42a665bc2/clippy_lints%2Fsrc%2Futils%2Fhir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f3d14269e72f8a21c6f8b74e887faf42a665bc2/clippy_lints%2Fsrc%2Futils%2Fhir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Fhir.rs?ref=4f3d14269e72f8a21c6f8b74e887faf42a665bc2", "patch": "@@ -153,7 +153,9 @@ impl<'a, 'tcx: 'a> SpanlessEq<'a, 'tcx> {\n             (&PatKind::QPath(ref ls, ref lp), &PatKind::QPath(ref rs, ref rp)) => {\n                 self.eq_qself(ls, rs) && self.eq_path(lp, rp)\n             }\n-            (&PatKind::Tuple(ref l, ls), &PatKind::Tuple(ref r, rs)) => ls == rs && over(l, r, |l, r| self.eq_pat(l, r)),\n+            (&PatKind::Tuple(ref l, ls), &PatKind::Tuple(ref r, rs)) => {\n+                ls == rs && over(l, r, |l, r| self.eq_pat(l, r))\n+            }\n             (&PatKind::Range(ref ls, ref le), &PatKind::Range(ref rs, ref re)) => {\n                 self.eq_expr(ls, rs) && self.eq_expr(le, re)\n             }"}, {"sha": "a2b2ecfbcc00d691516942ca553ae6e37fbfbaaf", "filename": "clippy_lints/src/utils/mod.rs", "status": "modified", "additions": 33, "deletions": 40, "changes": 73, "blob_url": "https://github.com/rust-lang/rust/blob/4f3d14269e72f8a21c6f8b74e887faf42a665bc2/clippy_lints%2Fsrc%2Futils%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f3d14269e72f8a21c6f8b74e887faf42a665bc2/clippy_lints%2Fsrc%2Futils%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Fmod.rs?ref=4f3d14269e72f8a21c6f8b74e887faf42a665bc2", "patch": "@@ -30,16 +30,13 @@ pub type MethodArgs = HirVec<P<Expr>>;\n \n /// Produce a nested chain of if-lets and ifs from the patterns:\n ///\n-///     if_let_chain! {\n-///         [\n-///             let Some(y) = x,\n-///             y.len() == 2,\n-///             let Some(z) = y,\n-///         ],\n-///         {\n-///             block\n-///         }\n-///     }\n+///     if_let_chain! {[\n+///         let Some(y) = x,\n+///         y.len() == 2,\n+///         let Some(z) = y,\n+///     ], {\n+///         block\n+///     }}\n ///\n /// becomes\n ///\n@@ -143,9 +140,7 @@ pub fn match_def_path(cx: &LateContext, def_id: DefId, path: &[&str]) -> bool {\n         }\n     }\n \n-    let mut apb = AbsolutePathBuffer {\n-        names: vec![],\n-    };\n+    let mut apb = AbsolutePathBuffer { names: vec![] };\n \n     cx.tcx.push_item_path(&mut apb, def_id);\n \n@@ -325,14 +320,13 @@ pub fn get_item_name(cx: &LateContext, expr: &Expr) -> Option<Name> {\n \n /// Checks if a `let` decl is from a `for` loop desugaring.\n pub fn is_from_for_desugar(decl: &Decl) -> bool {\n-    if_let_chain! {\n-        [\n-            let DeclLocal(ref loc) = decl.node,\n-            let Some(ref expr) = loc.init,\n-            let ExprMatch(_, _, MatchSource::ForLoopDesugar) = expr.node\n-        ],\n-        { return true; }\n-    };\n+    if_let_chain! {[\n+        let DeclLocal(ref loc) = decl.node,\n+        let Some(ref expr) = loc.init,\n+        let ExprMatch(_, _, MatchSource::ForLoopDesugar) = expr.node\n+    ], {\n+        return true;\n+    }}\n     false\n }\n \n@@ -763,7 +757,8 @@ pub fn unsugar_range(expr: &Expr) -> Option<UnsugaredRange> {\n                     end: None,\n                     limits: RangeLimits::HalfOpen,\n                 })\n-            } else if match_path(path, &paths::RANGE_INCLUSIVE_NON_EMPTY_STD) || match_path(path, &paths::RANGE_INCLUSIVE_NON_EMPTY) {\n+            } else if match_path(path, &paths::RANGE_INCLUSIVE_NON_EMPTY_STD) ||\n+               match_path(path, &paths::RANGE_INCLUSIVE_NON_EMPTY) {\n                 Some(UnsugaredRange {\n                     start: get_field(\"start\", fields),\n                     end: get_field(\"end\", fields),\n@@ -822,23 +817,21 @@ pub fn same_tys<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, a: ty::Ty<'tcx>, b: ty::Ty\n /// Recover the essential nodes of a desugared for loop:\n /// `for pat in arg { body }` becomes `(pat, arg, body)`.\n pub fn recover_for_loop(expr: &Expr) -> Option<(&Pat, &Expr, &Expr)> {\n-    if_let_chain! {\n-        [\n-            let ExprMatch(ref iterexpr, ref arms, _) = expr.node,\n-            let ExprCall(_, ref iterargs) = iterexpr.node,\n-            iterargs.len() == 1 && arms.len() == 1 && arms[0].guard.is_none(),\n-            let ExprLoop(ref block, _) = arms[0].body.node,\n-            block.stmts.is_empty(),\n-            let Some(ref loopexpr) = block.expr,\n-            let ExprMatch(_, ref innerarms, MatchSource::ForLoopDesugar) = loopexpr.node,\n-            innerarms.len() == 2 && innerarms[0].pats.len() == 1,\n-            let PatKind::TupleStruct(_, ref somepats, _) = innerarms[0].pats[0].node,\n-            somepats.len() == 1\n-        ], {\n-            return Some((&somepats[0],\n-                         &iterargs[0],\n-                         &innerarms[0].body));\n-        }\n-    }\n+    if_let_chain! {[\n+        let ExprMatch(ref iterexpr, ref arms, _) = expr.node,\n+        let ExprCall(_, ref iterargs) = iterexpr.node,\n+        iterargs.len() == 1 && arms.len() == 1 && arms[0].guard.is_none(),\n+        let ExprLoop(ref block, _) = arms[0].body.node,\n+        block.stmts.is_empty(),\n+        let Some(ref loopexpr) = block.expr,\n+        let ExprMatch(_, ref innerarms, MatchSource::ForLoopDesugar) = loopexpr.node,\n+        innerarms.len() == 2 && innerarms[0].pats.len() == 1,\n+        let PatKind::TupleStruct(_, ref somepats, _) = innerarms[0].pats[0].node,\n+        somepats.len() == 1\n+    ], {\n+        return Some((&somepats[0],\n+                     &iterargs[0],\n+                     &innerarms[0].body));\n+    }}\n     None\n }"}, {"sha": "041ac94836cd21265155e0f953d6ec045a7d8452", "filename": "clippy_lints/src/zero_div_zero.rs", "status": "modified", "additions": 22, "deletions": 25, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/4f3d14269e72f8a21c6f8b74e887faf42a665bc2/clippy_lints%2Fsrc%2Fzero_div_zero.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f3d14269e72f8a21c6f8b74e887faf42a665bc2/clippy_lints%2Fsrc%2Fzero_div_zero.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fzero_div_zero.rs?ref=4f3d14269e72f8a21c6f8b74e887faf42a665bc2", "patch": "@@ -30,30 +30,27 @@ impl LintPass for ZeroDivZeroPass {\n impl LateLintPass for ZeroDivZeroPass {\n     fn check_expr(&mut self, cx: &LateContext, expr: &Expr) {\n         // check for instances of 0.0/0.0\n-        if_let_chain! {\n-            [\n-                let ExprBinary(ref op, ref left, ref right) = expr.node,\n-                let BinOp_::BiDiv = op.node,\n-                // TODO - constant_simple does not fold many operations involving floats.\n-                // That's probably fine for this lint - it's pretty unlikely that someone would\n-                // do something like 0.0/(2.0 - 2.0), but it would be nice to warn on that case too.\n-                let Some(Constant::Float(ref lhs_value, lhs_width)) = constant_simple(left),\n-                let Some(Constant::Float(ref rhs_value, rhs_width)) = constant_simple(right),\n-                let Some(0.0) = lhs_value.parse().ok(),\n-                let Some(0.0) = rhs_value.parse().ok()\n-            ],\n-            {\n-                // since we're about to suggest a use of std::f32::NaN or std::f64::NaN,\n-                // match the precision of the literals that are given.\n-                let float_type = match (lhs_width, rhs_width) {\n-                    (FloatWidth::F64, _)\n-                    | (_, FloatWidth::F64) => \"f64\",\n-                    _ => \"f32\"\n-                };\n-                span_help_and_lint(cx, ZERO_DIVIDED_BY_ZERO, expr.span,\n-                    \"constant division of 0.0 with 0.0 will always result in NaN\",\n-                    &format!(\"Consider using `std::{}::NAN` if you would like a constant representing NaN\", float_type));\n-            }\n-        }\n+        if_let_chain! {[\n+            let ExprBinary(ref op, ref left, ref right) = expr.node,\n+            let BinOp_::BiDiv = op.node,\n+            // TODO - constant_simple does not fold many operations involving floats.\n+            // That's probably fine for this lint - it's pretty unlikely that someone would\n+            // do something like 0.0/(2.0 - 2.0), but it would be nice to warn on that case too.\n+            let Some(Constant::Float(ref lhs_value, lhs_width)) = constant_simple(left),\n+            let Some(Constant::Float(ref rhs_value, rhs_width)) = constant_simple(right),\n+            let Some(0.0) = lhs_value.parse().ok(),\n+            let Some(0.0) = rhs_value.parse().ok()\n+        ], {\n+            // since we're about to suggest a use of std::f32::NaN or std::f64::NaN,\n+            // match the precision of the literals that are given.\n+            let float_type = match (lhs_width, rhs_width) {\n+                (FloatWidth::F64, _)\n+                | (_, FloatWidth::F64) => \"f64\",\n+                _ => \"f32\"\n+            };\n+            span_help_and_lint(cx, ZERO_DIVIDED_BY_ZERO, expr.span,\n+                \"constant division of 0.0 with 0.0 will always result in NaN\",\n+                &format!(\"Consider using `std::{}::NAN` if you would like a constant representing NaN\", float_type));\n+        }}\n     }\n }"}, {"sha": "f5229d3cb3915a63e99a51d341b3ec392ed02aa7", "filename": "src/lib.rs", "status": "modified", "additions": 3, "deletions": 43, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/4f3d14269e72f8a21c6f8b74e887faf42a665bc2/src%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f3d14269e72f8a21c6f8b74e887faf42a665bc2/src%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib.rs?ref=4f3d14269e72f8a21c6f8b74e887faf42a665bc2", "patch": "@@ -1,55 +1,15 @@\n // error-pattern:cargo-clippy\n-#![feature(type_macros)]\n-#![feature(plugin_registrar, box_syntax)]\n-#![feature(rustc_private, collections)]\n-#![feature(custom_attribute)]\n-#![feature(slice_patterns)]\n-#![feature(question_mark)]\n-#![feature(stmt_expr_attributes)]\n-#![allow(indexing_slicing, shadow_reuse, unknown_lints)]\n-\n-#[macro_use]\n-extern crate syntax;\n-#[macro_use]\n-extern crate rustc;\n-\n-extern crate toml;\n-\n-// Only for the compile time checking of paths\n-extern crate core;\n-extern crate collections;\n-\n-// for unicode nfc normalization\n-extern crate unicode_normalization;\n-\n-// for semver check in attrs.rs\n-extern crate semver;\n-\n-// for regex checking\n-extern crate regex_syntax;\n-\n-// for finding minimal boolean expressions\n-extern crate quine_mc_cluskey;\n+#![feature(plugin_registrar)]\n+#![feature(rustc_private)]\n+#![allow(unknown_lints)]\n \n extern crate rustc_plugin;\n-extern crate rustc_const_eval;\n-extern crate rustc_const_math;\n use rustc_plugin::Registry;\n \n extern crate clippy_lints;\n \n pub use clippy_lints::*;\n \n-macro_rules! declare_restriction_lint {\n-    { pub $name:tt, $description:tt } => {\n-        declare_lint! { pub $name, Allow, $description }\n-    };\n-}\n-\n-mod reexport {\n-    pub use syntax::ast::{Name, NodeId};\n-}\n-\n #[plugin_registrar]\n pub fn plugin_registrar(reg: &mut Registry) {\n     register_plugins(reg);"}, {"sha": "de3361d514f9c68df370f901db84f76dcd0b2499", "filename": "src/main.rs", "status": "modified", "additions": 23, "deletions": 14, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/4f3d14269e72f8a21c6f8b74e887faf42a665bc2/src%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f3d14269e72f8a21c6f8b74e887faf42a665bc2/src%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fmain.rs?ref=4f3d14269e72f8a21c6f8b74e887faf42a665bc2", "patch": "@@ -1,15 +1,13 @@\n // error-pattern:yummy\n #![feature(box_syntax)]\n #![feature(rustc_private)]\n-#![feature(slice_patterns)]\n \n extern crate rustc_driver;\n extern crate getopts;\n extern crate rustc;\n extern crate syntax;\n extern crate rustc_plugin;\n extern crate clippy_lints;\n-extern crate rustc_serialize;\n \n use rustc_driver::{driver, CompilerCalls, RustcDefaultCalls, Compilation};\n use rustc::session::{config, Session};\n@@ -71,7 +69,13 @@ impl<'a> CompilerCalls<'a> for ClippyCompilerCalls {\n                 registry.args_hidden = Some(Vec::new());\n                 clippy_lints::register_plugins(&mut registry);\n \n-                let rustc_plugin::registry::Registry { early_lint_passes, late_lint_passes, lint_groups, llvm_passes, attributes, mir_passes, .. } = registry;\n+                let rustc_plugin::registry::Registry { early_lint_passes,\n+                                                       late_lint_passes,\n+                                                       lint_groups,\n+                                                       llvm_passes,\n+                                                       attributes,\n+                                                       mir_passes,\n+                                                       .. } = registry;\n                 let sess = &state.session;\n                 let mut ls = sess.lint_store.borrow_mut();\n                 for pass in early_lint_passes {\n@@ -109,16 +113,19 @@ pub fn main() {\n \n     let home = option_env!(\"RUSTUP_HOME\").or(option_env!(\"MULTIRUST_HOME\"));\n     let toolchain = option_env!(\"RUSTUP_TOOLCHAIN\").or(option_env!(\"MULTIRUST_TOOLCHAIN\"));\n-    let sys_root = match (home, toolchain) {\n-        (Some(home), Some(toolchain)) => format!(\"{}/toolchains/{}\", home, toolchain),\n-        _ => option_env!(\"SYSROOT\").map(|s| s.to_owned())\n-                                   .or(Command::new(\"rustc\").arg(\"--print\")\n-                                                            .arg(\"sysroot\")\n-                                                            .output().ok()\n-                                                            .and_then(|out| String::from_utf8(out.stdout).ok())\n-                                                            .map(|s| s.trim().to_owned())\n-                                                            )\n-                .expect(\"need to specify SYSROOT env var during clippy compilation, or use rustup or multirust\"),\n+    let sys_root = if let (Some(home), Some(toolchain)) = (home, toolchain) {\n+        format!(\"{}/toolchains/{}\", home, toolchain)\n+    } else {\n+        option_env!(\"SYSROOT\")\n+            .map(|s| s.to_owned())\n+            .or(Command::new(\"rustc\")\n+                .arg(\"--print\")\n+                .arg(\"sysroot\")\n+                .output()\n+                .ok()\n+                .and_then(|out| String::from_utf8(out.stdout).ok())\n+                .map(|s| s.trim().to_owned()))\n+            .expect(\"need to specify SYSROOT env var during clippy compilation, or use rustup or multirust\")\n     };\n \n     if let Some(\"clippy\") = std::env::args().nth(1).as_ref().map(AsRef::as_ref) {\n@@ -160,7 +167,9 @@ pub fn main() {\n }\n \n fn process<P, I>(old_args: I, dep_path: P, sysroot: &str) -> Result<(), i32>\n-    where P: AsRef<Path>, I: Iterator<Item=String> {\n+    where P: AsRef<Path>,\n+          I: Iterator<Item = String>\n+{\n \n     let mut args = vec![\"rustc\".to_owned()];\n "}, {"sha": "df2579cab57579409f6595f61f5a9836fd1a6c29", "filename": "tests/cc_seme.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/4f3d14269e72f8a21c6f8b74e887faf42a665bc2/tests%2Fcc_seme.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f3d14269e72f8a21c6f8b74e887faf42a665bc2/tests%2Fcc_seme.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcc_seme.rs?ref=4f3d14269e72f8a21c6f8b74e887faf42a665bc2", "patch": "@@ -14,7 +14,10 @@ struct Test {\n \n fn main() {\n     use Baz::*;\n-    let x = Test { t: Some(0), b: One };\n+    let x = Test {\n+        t: Some(0),\n+        b: One,\n+    };\n \n     match x {\n         Test { t: Some(_), b: One } => unreachable!(),"}, {"sha": "2e50f7d92415a2aded7c4897f3ad3e27a5eefb5c", "filename": "tests/compile-test.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4f3d14269e72f8a21c6f8b74e887faf42a665bc2/tests%2Fcompile-test.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f3d14269e72f8a21c6f8b74e887faf42a665bc2/tests%2Fcompile-test.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-test.rs?ref=4f3d14269e72f8a21c6f8b74e887faf42a665bc2", "patch": "@@ -9,7 +9,7 @@ fn run_mode(dir: &'static str, mode: &'static str) {\n     let cfg_mode = mode.parse().ok().expect(\"Invalid mode\");\n     config.target_rustcflags = Some(\"-L target/debug/ -L target/debug/deps\".to_owned());\n     if let Ok(name) = var::<&str>(\"TESTNAME\") {\n-        let s : String = name.to_owned();\n+        let s: String = name.to_owned();\n         config.filter = Some(s)\n     }\n "}, {"sha": "81500f9d39344012eb22cfc1d3057916658ebe43", "filename": "tests/consts.rs", "status": "modified", "additions": 13, "deletions": 10, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/4f3d14269e72f8a21c6f8b74e887faf42a665bc2/tests%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f3d14269e72f8a21c6f8b74e887faf42a665bc2/tests%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fconsts.rs?ref=4f3d14269e72f8a21c6f8b74e887faf42a665bc2", "patch": "@@ -16,15 +16,18 @@ use syntax::parse::token::InternedString;\n use syntax::ptr::P;\n \n fn spanned<T>(t: T) -> Spanned<T> {\n-    Spanned{ node: t, span: COMMAND_LINE_SP }\n+    Spanned {\n+        node: t,\n+        span: COMMAND_LINE_SP,\n+    }\n }\n \n fn expr(n: Expr_) -> Expr {\n-    Expr{\n+    Expr {\n         id: 1,\n         node: n,\n         span: COMMAND_LINE_SP,\n-        attrs: None\n+        attrs: None,\n     }\n }\n \n@@ -40,19 +43,19 @@ fn check(expect: Constant, expr: &Expr) {\n     assert_eq!(Some(expect), constant_simple(expr))\n }\n \n-const TRUE : Constant = Constant::Bool(true);\n-const FALSE : Constant = Constant::Bool(false);\n-const ZERO : Constant = Constant::Int(ConstInt::Infer(0));\n-const ONE : Constant = Constant::Int(ConstInt::Infer(1));\n-const TWO : Constant = Constant::Int(ConstInt::Infer(2));\n+const TRUE: Constant = Constant::Bool(true);\n+const FALSE: Constant = Constant::Bool(false);\n+const ZERO: Constant = Constant::Int(ConstInt::Infer(0));\n+const ONE: Constant = Constant::Int(ConstInt::Infer(1));\n+const TWO: Constant = Constant::Int(ConstInt::Infer(2));\n \n #[test]\n fn test_lit() {\n     check(TRUE, &lit(LitKind::Bool(true)));\n     check(FALSE, &lit(LitKind::Bool(false)));\n     check(ZERO, &lit(LitKind::Int(0, LitIntType::Unsuffixed)));\n-    check(Constant::Str(\"cool!\".into(), StrStyle::Cooked), &lit(LitKind::Str(\n-        InternedString::new(\"cool!\"), StrStyle::Cooked)));\n+    check(Constant::Str(\"cool!\".into(), StrStyle::Cooked),\n+          &lit(LitKind::Str(InternedString::new(\"cool!\"), StrStyle::Cooked)));\n }\n \n #[test]"}, {"sha": "821279d909cfecdad7cbf88f3cfd52437b9e290e", "filename": "tests/dogfood.rs", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/4f3d14269e72f8a21c6f8b74e887faf42a665bc2/tests%2Fdogfood.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f3d14269e72f8a21c6f8b74e887faf42a665bc2/tests%2Fdogfood.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fdogfood.rs?ref=4f3d14269e72f8a21c6f8b74e887faf42a665bc2", "patch": "@@ -30,11 +30,7 @@ fn dogfood() {\n \n     config.mode = cfg_mode;\n \n-    let files = [\n-        \"src/main.rs\",\n-        \"src/lib.rs\",\n-        \"clippy_lints/src/lib.rs\",\n-    ];\n+    let files = [\"src/main.rs\", \"src/lib.rs\", \"clippy_lints/src/lib.rs\"];\n \n     for file in &files {\n         let paths = TestPaths {"}, {"sha": "76b0250ca0e160d34c1e7419f102546b4d0689a9", "filename": "tests/issue-825.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4f3d14269e72f8a21c6f8b74e887faf42a665bc2/tests%2Fissue-825.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f3d14269e72f8a21c6f8b74e887faf42a665bc2/tests%2Fissue-825.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fissue-825.rs?ref=4f3d14269e72f8a21c6f8b74e887faf42a665bc2", "patch": "@@ -22,4 +22,4 @@ fn rust_type_id(name: String) {\n     }\n }\n \n-fn main() {}\n\\ No newline at end of file\n+fn main() {}"}, {"sha": "74433fc1f565c685f32e2b198768071c3dcd2b51", "filename": "tests/matches.rs", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/4f3d14269e72f8a21c6f8b74e887faf42a665bc2/tests%2Fmatches.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f3d14269e72f8a21c6f8b74e887faf42a665bc2/tests%2Fmatches.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fmatches.rs?ref=4f3d14269e72f8a21c6f8b74e887faf42a665bc2", "patch": "@@ -9,7 +9,12 @@ fn test_overlapping() {\n     use clippy::matches::overlapping;\n     use syntax::codemap::DUMMY_SP;\n \n-    let sp = |s, e| clippy::matches::SpannedRange { span: DUMMY_SP, node: (s, e) };\n+    let sp = |s, e| {\n+        clippy::matches::SpannedRange {\n+            span: DUMMY_SP,\n+            node: (s, e),\n+        }\n+    };\n \n     assert_eq!(None, overlapping::<u8>(&[]));\n     assert_eq!(None, overlapping(&[sp(1, 4)]));"}, {"sha": "9cd44d44001260ea39ec2b1e29eb364f975da09d", "filename": "tests/used_underscore_binding_macro.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4f3d14269e72f8a21c6f8b74e887faf42a665bc2/tests%2Fused_underscore_binding_macro.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f3d14269e72f8a21c6f8b74e887faf42a665bc2/tests%2Fused_underscore_binding_macro.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fused_underscore_binding_macro.rs?ref=4f3d14269e72f8a21c6f8b74e887faf42a665bc2", "patch": "@@ -12,5 +12,5 @@ struct MacroAttributesTest {\n \n #[test]\n fn macro_attributes_test() {\n-    let _ = MacroAttributesTest{_foo: 0};\n+    let _ = MacroAttributesTest { _foo: 0 };\n }"}]}