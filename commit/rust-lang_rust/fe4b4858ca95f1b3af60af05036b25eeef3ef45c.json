{"sha": "fe4b4858ca95f1b3af60af05036b25eeef3ef45c", "node_id": "MDY6Q29tbWl0NzI0NzEyOmZlNGI0ODU4Y2E5NWYxYjNhZjYwYWYwNTAzNmIyNWVlZWYzZWY0NWM=", "commit": {"author": {"name": "Manish Goregaokar", "email": "manishsmail@gmail.com", "date": "2020-06-20T02:42:57Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2020-06-20T02:42:57Z"}, "message": "Rollup merge of #73359 - jonas-schievink:do-the-shimmy, r=matthewjasper\n\nshim.rs: avoid creating `Call` terminators calling `Self`\n\nAlso contains some cleanup and doc comment additions so I could make sense of the code.\n\nFixes https://github.com/rust-lang/rust/issues/73109\nCloses https://github.com/rust-lang/rust/pull/73175\n\nr? @matthewjasper", "tree": {"sha": "e3720e1de5b21f7add256db83c3cf185bed0e452", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e3720e1de5b21f7add256db83c3cf185bed0e452"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/fe4b4858ca95f1b3af60af05036b25eeef3ef45c", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJe7XexCRBK7hj4Ov3rIwAAdHIIAKB0R+qXuzt3bvRGI3M7vV7z\nnkfiJPZYOAAfaBnFBJe4GdN1iNYR2JBfTOMNHEnZi1QWKBAFo0n3F1/Z+BWbMOc2\nKpTHXUpn4jUrUVI4Vy1w+3UUvb7x/NiCFrrWrl0mJRedbOzDrWWqDLedjA7rwMx1\nnFJjE2QyqKVbU4aieM4hWKyeroS+bmca8AjCiRAhw0Uxc0SJYwGB2tawmVrl17NY\nRwe/W3XRVjXIjgs+TT8uDDcvE5noha5Rb/V0GPijkSF1dnoQz8wOVfIyuA21QIc8\nWQhXg90TnJpvJ6oIc7nDjjUcUD/NhjuGNcgCdwWkmnjW+oOJ3JjuDPy7qFefZTM=\n=IpT6\n-----END PGP SIGNATURE-----\n", "payload": "tree e3720e1de5b21f7add256db83c3cf185bed0e452\nparent 17b80d947dccb7d73efbffd8fe6e8ae28af759ee\nparent 4cb26ad7a3207ce48341d6a152b7212696bfdc0d\nauthor Manish Goregaokar <manishsmail@gmail.com> 1592620977 -0700\ncommitter GitHub <noreply@github.com> 1592620977 -0700\n\nRollup merge of #73359 - jonas-schievink:do-the-shimmy, r=matthewjasper\n\nshim.rs: avoid creating `Call` terminators calling `Self`\n\nAlso contains some cleanup and doc comment additions so I could make sense of the code.\n\nFixes https://github.com/rust-lang/rust/issues/73109\nCloses https://github.com/rust-lang/rust/pull/73175\n\nr? @matthewjasper\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/fe4b4858ca95f1b3af60af05036b25eeef3ef45c", "html_url": "https://github.com/rust-lang/rust/commit/fe4b4858ca95f1b3af60af05036b25eeef3ef45c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/fe4b4858ca95f1b3af60af05036b25eeef3ef45c/comments", "author": {"login": "Manishearth", "id": 1617736, "node_id": "MDQ6VXNlcjE2MTc3MzY=", "avatar_url": "https://avatars.githubusercontent.com/u/1617736?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Manishearth", "html_url": "https://github.com/Manishearth", "followers_url": "https://api.github.com/users/Manishearth/followers", "following_url": "https://api.github.com/users/Manishearth/following{/other_user}", "gists_url": "https://api.github.com/users/Manishearth/gists{/gist_id}", "starred_url": "https://api.github.com/users/Manishearth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Manishearth/subscriptions", "organizations_url": "https://api.github.com/users/Manishearth/orgs", "repos_url": "https://api.github.com/users/Manishearth/repos", "events_url": "https://api.github.com/users/Manishearth/events{/privacy}", "received_events_url": "https://api.github.com/users/Manishearth/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "17b80d947dccb7d73efbffd8fe6e8ae28af759ee", "url": "https://api.github.com/repos/rust-lang/rust/commits/17b80d947dccb7d73efbffd8fe6e8ae28af759ee", "html_url": "https://github.com/rust-lang/rust/commit/17b80d947dccb7d73efbffd8fe6e8ae28af759ee"}, {"sha": "4cb26ad7a3207ce48341d6a152b7212696bfdc0d", "url": "https://api.github.com/repos/rust-lang/rust/commits/4cb26ad7a3207ce48341d6a152b7212696bfdc0d", "html_url": "https://github.com/rust-lang/rust/commit/4cb26ad7a3207ce48341d6a152b7212696bfdc0d"}], "stats": {"total": 156, "additions": 123, "deletions": 33}, "files": [{"sha": "d628d6783d5b0d71f12ed4c9aaf900660dec040f", "filename": "src/librustc_middle/ty/instance.rs", "status": "modified", "additions": 41, "deletions": 11, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/fe4b4858ca95f1b3af60af05036b25eeef3ef45c/src%2Flibrustc_middle%2Fty%2Finstance.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe4b4858ca95f1b3af60af05036b25eeef3ef45c/src%2Flibrustc_middle%2Fty%2Finstance.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fty%2Finstance.rs?ref=fe4b4858ca95f1b3af60af05036b25eeef3ef45c", "patch": "@@ -9,6 +9,11 @@ use rustc_macros::HashStable;\n \n use std::fmt;\n \n+/// A monomorphized `InstanceDef`.\n+///\n+/// Monomorphization happens on-the-fly and no monomorphized MIR is ever created. Instead, this type\n+/// simply couples a potentially generic `InstanceDef` with some substs, and codegen and const eval\n+/// will do all required substitution as they run.\n #[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, RustcEncodable, RustcDecodable)]\n #[derive(HashStable, Lift)]\n pub struct Instance<'tcx> {\n@@ -18,10 +23,26 @@ pub struct Instance<'tcx> {\n \n #[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, RustcEncodable, RustcDecodable, HashStable)]\n pub enum InstanceDef<'tcx> {\n+    /// A user-defined callable item.\n+    ///\n+    /// This includes:\n+    /// - `fn` items\n+    /// - closures\n+    /// - generators\n     Item(DefId),\n+\n+    /// An intrinsic `fn` item (with `\"rust-intrinsic\"` or `\"platform-intrinsic\"` ABI).\n+    ///\n+    /// Alongside `Virtual`, this is the only `InstanceDef` that does not have its own callable MIR.\n+    /// Instead, codegen and const eval \"magically\" evaluate calls to intrinsics purely in the\n+    /// caller.\n     Intrinsic(DefId),\n \n-    /// `<T as Trait>::method` where `method` receives unsizeable `self: Self`.\n+    /// `<T as Trait>::method` where `method` receives unsizeable `self: Self` (part of the\n+    /// `unsized_locals` feature).\n+    ///\n+    /// The generated shim will take `Self` via `*mut Self` - conceptually this is `&owned Self` -\n+    /// and dereference the argument to call the original function.\n     VtableShim(DefId),\n \n     /// `fn()` pointer where the function itself cannot be turned into a pointer.\n@@ -37,27 +58,31 @@ pub enum InstanceDef<'tcx> {\n     /// (the definition of the function itself).\n     ReifyShim(DefId),\n \n-    /// `<fn() as FnTrait>::call_*`\n+    /// `<fn() as FnTrait>::call_*` (generated `FnTrait` implementation for `fn()` pointers).\n+    ///\n     /// `DefId` is `FnTrait::call_*`.\n     ///\n     /// NB: the (`fn` pointer) type must currently be monomorphic to avoid double substitution\n     /// problems with the MIR shim bodies. `Instance::resolve` enforces this.\n     // FIXME(#69925) support polymorphic MIR shim bodies properly instead.\n     FnPtrShim(DefId, Ty<'tcx>),\n \n-    /// `<dyn Trait as Trait>::fn`, \"direct calls\" of which are implicitly\n-    /// codegen'd as virtual calls.\n+    /// Dynamic dispatch to `<dyn Trait as Trait>::fn`.\n     ///\n-    /// NB: if this is reified to a `fn` pointer, a `ReifyShim` is used\n-    /// (see `ReifyShim` above for more details on that).\n+    /// This `InstanceDef` does not have callable MIR. Calls to `Virtual` instances must be\n+    /// codegen'd as virtual calls through the vtable.\n+    ///\n+    /// If this is reified to a `fn` pointer, a `ReifyShim` is used (see `ReifyShim` above for more\n+    /// details on that).\n     Virtual(DefId, usize),\n \n-    /// `<[mut closure] as FnOnce>::call_once`\n-    ClosureOnceShim {\n-        call_once: DefId,\n-    },\n+    /// `<[FnMut closure] as FnOnce>::call_once`.\n+    ///\n+    /// The `DefId` is the ID of the `call_once` method in `FnOnce`.\n+    ClosureOnceShim { call_once: DefId },\n \n     /// `core::ptr::drop_in_place::<T>`.\n+    ///\n     /// The `DefId` is for `core::ptr::drop_in_place`.\n     /// The `Option<Ty<'tcx>>` is either `Some(T)`, or `None` for empty drop\n     /// glue.\n@@ -67,7 +92,12 @@ pub enum InstanceDef<'tcx> {\n     // FIXME(#69925) support polymorphic MIR shim bodies properly instead.\n     DropGlue(DefId, Option<Ty<'tcx>>),\n \n-    ///`<T as Clone>::clone` shim.\n+    /// Compiler-generated `<T as Clone>::clone` implementation.\n+    ///\n+    /// For all types that automatically implement `Copy`, a trivial `Clone` impl is provided too.\n+    /// Additionally, arrays, tuples, and closures get a `Clone` shim even if they aren't `Copy`.\n+    ///\n+    /// The `DefId` is for `Clone::clone`, the `Ty` is the type `T` with the builtin `Clone` impl.\n     ///\n     /// NB: the type must currently be monomorphic to avoid double substitution\n     /// problems with the MIR shim bodies. `Instance::resolve` enforces this."}, {"sha": "15a2e9130a37e91a240c2bbefa4657adac890288", "filename": "src/librustc_mir/shim.rs", "status": "modified", "additions": 49, "deletions": 15, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/fe4b4858ca95f1b3af60af05036b25eeef3ef45c/src%2Flibrustc_mir%2Fshim.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe4b4858ca95f1b3af60af05036b25eeef3ef45c/src%2Flibrustc_mir%2Fshim.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fshim.rs?ref=fe4b4858ca95f1b3af60af05036b25eeef3ef45c", "patch": "@@ -32,13 +32,9 @@ fn make_shim<'tcx>(tcx: TyCtxt<'tcx>, instance: ty::InstanceDef<'tcx>) -> Body<'\n \n     let mut result = match instance {\n         ty::InstanceDef::Item(..) => bug!(\"item {:?} passed to make_shim\", instance),\n-        ty::InstanceDef::VtableShim(def_id) => build_call_shim(\n-            tcx,\n-            instance,\n-            Some(Adjustment::DerefMove),\n-            CallKind::Direct(def_id),\n-            None,\n-        ),\n+        ty::InstanceDef::VtableShim(def_id) => {\n+            build_call_shim(tcx, instance, Some(Adjustment::Deref), CallKind::Direct(def_id), None)\n+        }\n         ty::InstanceDef::FnPtrShim(def_id, ty) => {\n             // FIXME(eddyb) support generating shims for a \"shallow type\",\n             // e.g. `Foo<_>` or `[_]` instead of requiring a fully monomorphic\n@@ -60,7 +56,7 @@ fn make_shim<'tcx>(tcx: TyCtxt<'tcx>, instance: ty::InstanceDef<'tcx>) -> Body<'\n             let sig = tcx.erase_late_bound_regions(&ty.fn_sig(tcx));\n             let arg_tys = sig.inputs();\n \n-            build_call_shim(tcx, instance, Some(adjustment), CallKind::Indirect, Some(arg_tys))\n+            build_call_shim(tcx, instance, Some(adjustment), CallKind::Indirect(ty), Some(arg_tys))\n         }\n         // We are generating a call back to our def-id, which the\n         // codegen backend knows to turn to an actual call, be it\n@@ -134,15 +130,28 @@ fn make_shim<'tcx>(tcx: TyCtxt<'tcx>, instance: ty::InstanceDef<'tcx>) -> Body<'\n \n #[derive(Copy, Clone, Debug, PartialEq)]\n enum Adjustment {\n+    /// Pass the receiver as-is.\n     Identity,\n+\n+    /// We get passed `&[mut] self` and call the target with `*self`.\n+    ///\n+    /// This either copies `self` (if `Self: Copy`, eg. for function items), or moves out of it\n+    /// (for `VtableShim`, which effectively is passed `&own Self`).\n     Deref,\n-    DerefMove,\n+\n+    /// We get passed `self: Self` and call the target with `&mut self`.\n+    ///\n+    /// In this case we need to ensure that the `Self` is dropped after the call, as the callee\n+    /// won't do it for us.\n     RefMut,\n }\n \n #[derive(Copy, Clone, Debug, PartialEq)]\n-enum CallKind {\n-    Indirect,\n+enum CallKind<'tcx> {\n+    /// Call the `FnPtr` that was passed as the receiver.\n+    Indirect(Ty<'tcx>),\n+\n+    /// Call a known `FnDef`.\n     Direct(DefId),\n }\n \n@@ -662,7 +671,7 @@ fn build_call_shim<'tcx>(\n     tcx: TyCtxt<'tcx>,\n     instance: ty::InstanceDef<'tcx>,\n     rcvr_adjustment: Option<Adjustment>,\n-    call_kind: CallKind,\n+    call_kind: CallKind<'tcx>,\n     untuple_args: Option<&[Ty<'tcx>]>,\n ) -> Body<'tcx> {\n     debug!(\n@@ -675,6 +684,29 @@ fn build_call_shim<'tcx>(\n     let sig = tcx.fn_sig(def_id);\n     let mut sig = tcx.erase_late_bound_regions(&sig);\n \n+    if let CallKind::Indirect(fnty) = call_kind {\n+        // `sig` determines our local decls, and thus the callee type in the `Call` terminator. This\n+        // can only be an `FnDef` or `FnPtr`, but currently will be `Self` since the types come from\n+        // the implemented `FnX` trait.\n+\n+        // Apply the opposite adjustment to the MIR input.\n+        let mut inputs_and_output = sig.inputs_and_output.to_vec();\n+\n+        // Initial signature is `fn(&? Self, Args) -> Self::Output` where `Args` is a tuple of the\n+        // fn arguments. `Self` may be passed via (im)mutable reference or by-value.\n+        assert_eq!(inputs_and_output.len(), 3);\n+\n+        // `Self` is always the original fn type `ty`. The MIR call terminator is only defined for\n+        // `FnDef` and `FnPtr` callees, not the `Self` type param.\n+        let self_arg = &mut inputs_and_output[0];\n+        *self_arg = match rcvr_adjustment.unwrap() {\n+            Adjustment::Identity => fnty,\n+            Adjustment::Deref => tcx.mk_imm_ptr(fnty),\n+            Adjustment::RefMut => tcx.mk_mut_ptr(fnty),\n+        };\n+        sig.inputs_and_output = tcx.intern_type_list(&inputs_and_output);\n+    }\n+\n     // FIXME(eddyb) avoid having this snippet both here and in\n     // `Instance::fn_sig` (introduce `InstanceDef::fn_sig`?).\n     if let ty::InstanceDef::VtableShim(..) = instance {\n@@ -701,8 +733,7 @@ fn build_call_shim<'tcx>(\n \n     let rcvr = rcvr_adjustment.map(|rcvr_adjustment| match rcvr_adjustment {\n         Adjustment::Identity => Operand::Move(rcvr_place()),\n-        Adjustment::Deref => Operand::Move(tcx.mk_place_deref(rcvr_place())), // Can't copy `&mut`\n-        Adjustment::DerefMove => Operand::Move(tcx.mk_place_deref(rcvr_place())),\n+        Adjustment::Deref => Operand::Move(tcx.mk_place_deref(rcvr_place())),\n         Adjustment::RefMut => {\n             // let rcvr = &mut rcvr;\n             let ref_rcvr = local_decls.push(\n@@ -728,7 +759,10 @@ fn build_call_shim<'tcx>(\n     });\n \n     let (callee, mut args) = match call_kind {\n-        CallKind::Indirect => (rcvr.unwrap(), vec![]),\n+        // `FnPtr` call has no receiver. Args are untupled below.\n+        CallKind::Indirect(_) => (rcvr.unwrap(), vec![]),\n+\n+        // `FnDef` call with optional receiver.\n         CallKind::Direct(def_id) => {\n             let ty = tcx.type_of(def_id);\n             ("}, {"sha": "625f40cd79206313d3f696abb9f494542abc5c79", "filename": "src/librustc_mir/transform/validate.rs", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/fe4b4858ca95f1b3af60af05036b25eeef3ef45c/src%2Flibrustc_mir%2Ftransform%2Fvalidate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe4b4858ca95f1b3af60af05036b25eeef3ef45c/src%2Flibrustc_mir%2Ftransform%2Fvalidate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fvalidate.rs?ref=fe4b4858ca95f1b3af60af05036b25eeef3ef45c", "patch": "@@ -9,7 +9,6 @@ use rustc_middle::{\n     },\n     ty::{self, ParamEnv, TyCtxt},\n };\n-use rustc_span::def_id::DefId;\n \n #[derive(Copy, Clone, Debug)]\n enum EdgeKind {\n@@ -24,15 +23,14 @@ pub struct Validator {\n \n impl<'tcx> MirPass<'tcx> for Validator {\n     fn run_pass(&self, tcx: TyCtxt<'tcx>, source: MirSource<'tcx>, body: &mut Body<'tcx>) {\n-        let def_id = source.def_id();\n-        let param_env = tcx.param_env(def_id);\n-        TypeChecker { when: &self.when, def_id, body, tcx, param_env }.visit_body(body);\n+        let param_env = tcx.param_env(source.def_id());\n+        TypeChecker { when: &self.when, source, body, tcx, param_env }.visit_body(body);\n     }\n }\n \n struct TypeChecker<'a, 'tcx> {\n     when: &'a str,\n-    def_id: DefId,\n+    source: MirSource<'tcx>,\n     body: &'a Body<'tcx>,\n     tcx: TyCtxt<'tcx>,\n     param_env: ParamEnv<'tcx>,\n@@ -47,7 +45,7 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n             span,\n             &format!(\n                 \"broken MIR in {:?} ({}) at {:?}:\\n{}\",\n-                self.def_id,\n+                self.source.instance,\n                 self.when,\n                 location,\n                 msg.as_ref()"}, {"sha": "d3484b8af89fd54f9eb67e2f51350cc8e8dd0592", "filename": "src/librustc_trait_selection/traits/util.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fe4b4858ca95f1b3af60af05036b25eeef3ef45c/src%2Flibrustc_trait_selection%2Ftraits%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe4b4858ca95f1b3af60af05036b25eeef3ef45c/src%2Flibrustc_trait_selection%2Ftraits%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trait_selection%2Ftraits%2Futil.rs?ref=fe4b4858ca95f1b3af60af05036b25eeef3ef45c", "patch": "@@ -302,7 +302,7 @@ pub fn get_vtable_index_of_object_method<N>(\n ) -> usize {\n     // Count number of methods preceding the one we are selecting and\n     // add them to the total offset.\n-    // Skip over associated types and constants.\n+    // Skip over associated types and constants, as those aren't stored in the vtable.\n     let mut entries = object.vtable_base;\n     for trait_item in tcx.associated_items(object.upcast_trait_ref.def_id()).in_definition_order() {\n         if trait_item.def_id == method_def_id {"}, {"sha": "08413c9f6fceb6b43dcdb99dafea544b3520f769", "filename": "src/test/mir-opt/fn-ptr-shim.rs", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/fe4b4858ca95f1b3af60af05036b25eeef3ef45c/src%2Ftest%2Fmir-opt%2Ffn-ptr-shim.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe4b4858ca95f1b3af60af05036b25eeef3ef45c/src%2Ftest%2Fmir-opt%2Ffn-ptr-shim.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Ffn-ptr-shim.rs?ref=fe4b4858ca95f1b3af60af05036b25eeef3ef45c", "patch": "@@ -0,0 +1,15 @@\n+// compile-flags: -Zmir-opt-level=0 -Zvalidate-mir\n+\n+// Tests that the `<fn() as Fn>` shim does not create a `Call` terminator with a `Self` callee\n+// (as only `FnDef` and `FnPtr` callees are allowed in MIR).\n+\n+// EMIT_MIR rustc.ops-function-Fn-call.AddMovesForPackedDrops.before.mir\n+fn main() {\n+    call(noop as fn());\n+}\n+\n+fn noop() {}\n+\n+fn call<F: Fn()>(f: F) {\n+    f();\n+}"}, {"sha": "4ecc331afaeb975d4ed6fe5be34ecf79f95b0ae5", "filename": "src/test/mir-opt/fn-ptr-shim/rustc.ops-function-Fn-call.AddMovesForPackedDrops.before.mir", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/fe4b4858ca95f1b3af60af05036b25eeef3ef45c/src%2Ftest%2Fmir-opt%2Ffn-ptr-shim%2Frustc.ops-function-Fn-call.AddMovesForPackedDrops.before.mir", "raw_url": "https://github.com/rust-lang/rust/raw/fe4b4858ca95f1b3af60af05036b25eeef3ef45c/src%2Ftest%2Fmir-opt%2Ffn-ptr-shim%2Frustc.ops-function-Fn-call.AddMovesForPackedDrops.before.mir", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Ffn-ptr-shim%2Frustc.ops-function-Fn-call.AddMovesForPackedDrops.before.mir?ref=fe4b4858ca95f1b3af60af05036b25eeef3ef45c", "patch": "@@ -0,0 +1,13 @@\n+// MIR for `std::ops::Fn::call` before AddMovesForPackedDrops\n+\n+fn std::ops::Fn::call(_1: *const fn(), _2: Args) -> <Self as std::ops::FnOnce<Args>>::Output {\n+    let mut _0: <Self as std::ops::FnOnce<Args>>::Output; // return place in scope 0 at $SRC_DIR/libcore/ops/function.rs:LL:COL\n+\n+    bb0: {\n+        _0 = move (*_1)() -> bb1;        // scope 0 at $SRC_DIR/libcore/ops/function.rs:LL:COL\n+    }\n+\n+    bb1: {\n+        return;                          // scope 0 at $SRC_DIR/libcore/ops/function.rs:LL:COL\n+    }\n+}"}]}