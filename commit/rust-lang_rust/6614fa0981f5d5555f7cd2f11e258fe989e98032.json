{"sha": "6614fa0981f5d5555f7cd2f11e258fe989e98032", "node_id": "MDY6Q29tbWl0NzI0NzEyOjY2MTRmYTA5ODFmNWQ1NTU1ZjdjZDJmMTFlMjU4ZmU5ODllOTgwMzI=", "commit": {"author": {"name": "Mike Hommey", "email": "mh@glandium.org", "date": "2018-04-19T06:26:16Z"}, "committer": {"name": "Mike Hommey", "email": "mh@glandium.org", "date": "2018-04-20T00:43:52Z"}, "message": "Support an alternative form for box_free\n\nbox_free currently takes a pointer. With the prospect of the Box type\ndefinition changing in the future to include an allocator, box_free will\nalso need to be aware of this. In order to prepare for that future, we\nallow box_free to take a form where its argument are the fields of the\nBox.\n\ne.g. if Box is defined as `Box(A, B, C)`, then box_free signature\nbecomes `box_free(a: A, b: B, c: C)`.\n\nWe however still allow the current form (taking a pointer), so that the\nsame compiler can handle both forms, which helps with bootstrap.", "tree": {"sha": "9b48866d5f3ff114b8944ecf89d46e2a16411c93", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9b48866d5f3ff114b8944ecf89d46e2a16411c93"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6614fa0981f5d5555f7cd2f11e258fe989e98032", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6614fa0981f5d5555f7cd2f11e258fe989e98032", "html_url": "https://github.com/rust-lang/rust/commit/6614fa0981f5d5555f7cd2f11e258fe989e98032", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6614fa0981f5d5555f7cd2f11e258fe989e98032/comments", "author": {"login": "glandium", "id": 1038527, "node_id": "MDQ6VXNlcjEwMzg1Mjc=", "avatar_url": "https://avatars.githubusercontent.com/u/1038527?v=4", "gravatar_id": "", "url": "https://api.github.com/users/glandium", "html_url": "https://github.com/glandium", "followers_url": "https://api.github.com/users/glandium/followers", "following_url": "https://api.github.com/users/glandium/following{/other_user}", "gists_url": "https://api.github.com/users/glandium/gists{/gist_id}", "starred_url": "https://api.github.com/users/glandium/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/glandium/subscriptions", "organizations_url": "https://api.github.com/users/glandium/orgs", "repos_url": "https://api.github.com/users/glandium/repos", "events_url": "https://api.github.com/users/glandium/events{/privacy}", "received_events_url": "https://api.github.com/users/glandium/received_events", "type": "User", "site_admin": false}, "committer": {"login": "glandium", "id": 1038527, "node_id": "MDQ6VXNlcjEwMzg1Mjc=", "avatar_url": "https://avatars.githubusercontent.com/u/1038527?v=4", "gravatar_id": "", "url": "https://api.github.com/users/glandium", "html_url": "https://github.com/glandium", "followers_url": "https://api.github.com/users/glandium/followers", "following_url": "https://api.github.com/users/glandium/following{/other_user}", "gists_url": "https://api.github.com/users/glandium/gists{/gist_id}", "starred_url": "https://api.github.com/users/glandium/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/glandium/subscriptions", "organizations_url": "https://api.github.com/users/glandium/orgs", "repos_url": "https://api.github.com/users/glandium/repos", "events_url": "https://api.github.com/users/glandium/events{/privacy}", "received_events_url": "https://api.github.com/users/glandium/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "dfa611146c7acd692f760619d25bfabf7261eaf5", "url": "https://api.github.com/repos/rust-lang/rust/commits/dfa611146c7acd692f760619d25bfabf7261eaf5", "html_url": "https://github.com/rust-lang/rust/commit/dfa611146c7acd692f760619d25bfabf7261eaf5"}], "stats": {"total": 68, "additions": 44, "deletions": 24}, "files": [{"sha": "cc91bbf90619b0ee67b9e99001a1d918f09ef3f6", "filename": "src/librustc_mir/util/elaborate_drops.rs", "status": "modified", "additions": 44, "deletions": 24, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/6614fa0981f5d5555f7cd2f11e258fe989e98032/src%2Flibrustc_mir%2Futil%2Felaborate_drops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6614fa0981f5d5555f7cd2f11e258fe989e98032/src%2Flibrustc_mir%2Futil%2Felaborate_drops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Futil%2Felaborate_drops.rs?ref=6614fa0981f5d5555f7cd2f11e258fe989e98032", "patch": "@@ -337,18 +337,19 @@ impl<'l, 'b, 'tcx, D> DropCtxt<'l, 'b, 'tcx, D>\n         self.drop_ladder(fields, succ, unwind).0\n     }\n \n-    fn open_drop_for_box<'a>(&mut self, ty: Ty<'tcx>) -> BasicBlock\n+    fn open_drop_for_box<'a>(&mut self, adt: &'tcx ty::AdtDef, substs: &'tcx Substs<'tcx>)\n+                             -> BasicBlock\n     {\n-        debug!(\"open_drop_for_box({:?}, {:?})\", self, ty);\n+        debug!(\"open_drop_for_box({:?}, {:?}, {:?})\", self, adt, substs);\n \n         let interior = self.place.clone().deref();\n         let interior_path = self.elaborator.deref_subpath(self.path);\n \n         let succ = self.succ; // FIXME(#43234)\n         let unwind = self.unwind;\n-        let succ = self.box_free_block(ty, succ, unwind);\n+        let succ = self.box_free_block(adt, substs, succ, unwind);\n         let unwind_succ = self.unwind.map(|unwind| {\n-            self.box_free_block(ty, unwind, Unwind::InCleanup)\n+            self.box_free_block(adt, substs, unwind, Unwind::InCleanup)\n         });\n \n         self.drop_subpath(&interior, interior_path, succ, unwind_succ)\n@@ -791,11 +792,12 @@ impl<'l, 'b, 'tcx, D> DropCtxt<'l, 'b, 'tcx, D>\n             ty::TyTuple(tys) => {\n                 self.open_drop_for_tuple(tys)\n             }\n-            ty::TyAdt(def, _) if def.is_box() => {\n-                self.open_drop_for_box(ty.boxed_ty())\n-            }\n             ty::TyAdt(def, substs) => {\n-                self.open_drop_for_adt(def, substs)\n+                if def.is_box() {\n+                    self.open_drop_for_box(def, substs)\n+                } else {\n+                    self.open_drop_for_adt(def, substs)\n+                }\n             }\n             ty::TyDynamic(..) => {\n                 let unwind = self.unwind; // FIXME(#43234)\n@@ -858,34 +860,40 @@ impl<'l, 'b, 'tcx, D> DropCtxt<'l, 'b, 'tcx, D>\n \n     fn box_free_block<'a>(\n         &mut self,\n-        ty: Ty<'tcx>,\n+        adt: &'tcx ty::AdtDef,\n+        substs: &'tcx Substs<'tcx>,\n         target: BasicBlock,\n         unwind: Unwind,\n     ) -> BasicBlock {\n-        let block = self.unelaborated_free_block(ty, target, unwind);\n+        let block = self.unelaborated_free_block(adt, substs, target, unwind);\n         self.drop_flag_test_block(block, target, unwind)\n     }\n \n     fn unelaborated_free_block<'a>(\n         &mut self,\n-        ty: Ty<'tcx>,\n+        adt: &'tcx ty::AdtDef,\n+        substs: &'tcx Substs<'tcx>,\n         target: BasicBlock,\n         unwind: Unwind\n     ) -> BasicBlock {\n         let tcx = self.tcx();\n         let unit_temp = Place::Local(self.new_temp(tcx.mk_nil()));\n         let free_func = tcx.require_lang_item(lang_items::BoxFreeFnLangItem);\n-        let substs = tcx.mk_substs(iter::once(Kind::from(ty)));\n-        let ref_ty = tcx.mk_ref(tcx.types.re_erased, ty::TypeAndMut {\n-            ty: ty,\n-            mutbl: hir::Mutability::MutMutable\n-        });\n-        let ptr_ty = tcx.mk_mut_ptr(ty);\n-        let ref_tmp = Place::Local(self.new_temp(ref_ty));\n-        let ptr_tmp = Place::Local(self.new_temp(ptr_ty));\n-\n-        let free_block = BasicBlockData {\n-            statements: vec![\n+        let free_sig = tcx.fn_sig(free_func).skip_binder().clone();\n+        let free_inputs = free_sig.inputs();\n+        // If the box_free function takes a *mut T, transform the Box into\n+        // such a pointer before calling box_free. Otherwise, pass it all\n+        // the fields in the Box as individual arguments.\n+        let (stmts, args) = if free_inputs.len() == 1 && free_inputs[0].is_mutable_pointer() {\n+            let ty = substs.type_at(0);\n+            let ref_ty = tcx.mk_ref(tcx.types.re_erased, ty::TypeAndMut {\n+                ty: ty,\n+                mutbl: hir::Mutability::MutMutable\n+            });\n+            let ptr_ty = tcx.mk_mut_ptr(ty);\n+            let ref_tmp = Place::Local(self.new_temp(ref_ty));\n+            let ptr_tmp = Place::Local(self.new_temp(ptr_ty));\n+            let stmts = vec![\n                 self.assign(&ref_tmp, Rvalue::Ref(\n                     tcx.types.re_erased,\n                     BorrowKind::Mut { allow_two_phase_borrow: false },\n@@ -896,11 +904,23 @@ impl<'l, 'b, 'tcx, D> DropCtxt<'l, 'b, 'tcx, D>\n                     Operand::Move(ref_tmp),\n                     ptr_ty,\n                 )),\n-            ],\n+            ];\n+            (stmts, vec![Operand::Move(ptr_tmp)])\n+        } else {\n+            let args = adt.variants[0].fields.iter().enumerate().map(|(i, f)| {\n+                let field = Field::new(i);\n+                let field_ty = f.ty(self.tcx(), substs);\n+                Operand::Move(self.place.clone().field(field, field_ty))\n+            }).collect();\n+            (vec![], args)\n+        };\n+\n+        let free_block = BasicBlockData {\n+            statements: stmts,\n             terminator: Some(Terminator {\n                 kind: TerminatorKind::Call {\n                     func: Operand::function_handle(tcx, free_func, substs, self.source_info.span),\n-                    args: vec![Operand::Move(ptr_tmp)],\n+                    args: args,\n                     destination: Some((unit_temp, target)),\n                     cleanup: None\n                 }, // FIXME(#43234)"}]}