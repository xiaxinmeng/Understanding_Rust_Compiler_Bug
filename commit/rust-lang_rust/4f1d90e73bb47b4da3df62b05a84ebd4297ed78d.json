{"sha": "4f1d90e73bb47b4da3df62b05a84ebd4297ed78d", "node_id": "MDY6Q29tbWl0NzI0NzEyOjRmMWQ5MGU3M2JiNDdiNGRhM2RmNjJiMDVhODRlYmQ0Mjk3ZWQ3OGQ=", "commit": {"author": {"name": "adamrk", "email": "ark.email@gmail.com", "date": "2020-02-22T21:58:48Z"}, "committer": {"name": "adamrk", "email": "ark.email@gmail.com", "date": "2020-02-23T21:14:47Z"}, "message": "Handle trivia in strucural search and replace", "tree": {"sha": "4dd4fc4fd03b098abdfc44d3d21a3f0e296e0ca3", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4dd4fc4fd03b098abdfc44d3d21a3f0e296e0ca3"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4f1d90e73bb47b4da3df62b05a84ebd4297ed78d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4f1d90e73bb47b4da3df62b05a84ebd4297ed78d", "html_url": "https://github.com/rust-lang/rust/commit/4f1d90e73bb47b4da3df62b05a84ebd4297ed78d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4f1d90e73bb47b4da3df62b05a84ebd4297ed78d/comments", "author": {"login": "adamrk", "id": 16367467, "node_id": "MDQ6VXNlcjE2MzY3NDY3", "avatar_url": "https://avatars.githubusercontent.com/u/16367467?v=4", "gravatar_id": "", "url": "https://api.github.com/users/adamrk", "html_url": "https://github.com/adamrk", "followers_url": "https://api.github.com/users/adamrk/followers", "following_url": "https://api.github.com/users/adamrk/following{/other_user}", "gists_url": "https://api.github.com/users/adamrk/gists{/gist_id}", "starred_url": "https://api.github.com/users/adamrk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/adamrk/subscriptions", "organizations_url": "https://api.github.com/users/adamrk/orgs", "repos_url": "https://api.github.com/users/adamrk/repos", "events_url": "https://api.github.com/users/adamrk/events{/privacy}", "received_events_url": "https://api.github.com/users/adamrk/received_events", "type": "User", "site_admin": false}, "committer": {"login": "adamrk", "id": 16367467, "node_id": "MDQ6VXNlcjE2MzY3NDY3", "avatar_url": "https://avatars.githubusercontent.com/u/16367467?v=4", "gravatar_id": "", "url": "https://api.github.com/users/adamrk", "html_url": "https://github.com/adamrk", "followers_url": "https://api.github.com/users/adamrk/followers", "following_url": "https://api.github.com/users/adamrk/following{/other_user}", "gists_url": "https://api.github.com/users/adamrk/gists{/gist_id}", "starred_url": "https://api.github.com/users/adamrk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/adamrk/subscriptions", "organizations_url": "https://api.github.com/users/adamrk/orgs", "repos_url": "https://api.github.com/users/adamrk/repos", "events_url": "https://api.github.com/users/adamrk/events{/privacy}", "received_events_url": "https://api.github.com/users/adamrk/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "cd01e72a9eca909392caea7efa5744f0f5578a41", "url": "https://api.github.com/repos/rust-lang/rust/commits/cd01e72a9eca909392caea7efa5744f0f5578a41", "html_url": "https://github.com/rust-lang/rust/commit/cd01e72a9eca909392caea7efa5744f0f5578a41"}], "stats": {"total": 145, "additions": 118, "deletions": 27}, "files": [{"sha": "83c21249463d69cdf06abde01e3d32da789cdc32", "filename": "crates/ra_ide/src/ssr.rs", "status": "modified", "additions": 118, "deletions": 27, "changes": 145, "blob_url": "https://github.com/rust-lang/rust/blob/4f1d90e73bb47b4da3df62b05a84ebd4297ed78d/crates%2Fra_ide%2Fsrc%2Fssr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f1d90e73bb47b4da3df62b05a84ebd4297ed78d/crates%2Fra_ide%2Fsrc%2Fssr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Fssr.rs?ref=4f1d90e73bb47b4da3df62b05a84ebd4297ed78d", "patch": "@@ -3,9 +3,7 @@\n use crate::source_change::SourceFileEdit;\n use ra_ide_db::RootDatabase;\n use ra_syntax::ast::make::expr_from_text;\n-use ra_syntax::AstNode;\n-use ra_syntax::SyntaxElement;\n-use ra_syntax::SyntaxNode;\n+use ra_syntax::{AstNode, SyntaxElement, SyntaxKind, SyntaxNode, SyntaxToken};\n use ra_text_edit::{TextEdit, TextEditBuilder};\n use rustc_hash::FxHashMap;\n use std::collections::HashMap;\n@@ -72,6 +70,7 @@ type Binding = HashMap<Var, SyntaxNode>;\n struct Match {\n     place: SyntaxNode,\n     binding: Binding,\n+    ignored_comments: Vec<SyntaxToken>,\n }\n \n #[derive(Debug)]\n@@ -179,44 +178,64 @@ fn find(pattern: &SsrPattern, code: &SyntaxNode) -> SsrMatches {\n         pattern: &SyntaxElement,\n         code: &SyntaxElement,\n         placeholders: &[Var],\n-        match_: &mut Match,\n-    ) -> bool {\n+        mut match_: Match,\n+    ) -> Option<Match> {\n         match (pattern, code) {\n             (SyntaxElement::Token(ref pattern), SyntaxElement::Token(ref code)) => {\n-                pattern.text() == code.text()\n+                if pattern.text() == code.text() {\n+                    Some(match_)\n+                } else {\n+                    None\n+                }\n             }\n             (SyntaxElement::Node(ref pattern), SyntaxElement::Node(ref code)) => {\n                 if placeholders.iter().any(|n| n.0.as_str() == pattern.text()) {\n                     match_.binding.insert(Var(pattern.text().to_string()), code.clone());\n-                    true\n+                    Some(match_)\n                 } else {\n-                    pattern.green().children().count() == code.green().children().count()\n-                        && pattern\n-                            .children_with_tokens()\n-                            .zip(code.children_with_tokens())\n-                            .all(|(a, b)| check(&a, &b, placeholders, match_))\n+                    let mut pattern_children = pattern\n+                        .children_with_tokens()\n+                        .filter(|element| !element.kind().is_trivia());\n+                    let mut code_children =\n+                        code.children_with_tokens().filter(|element| !element.kind().is_trivia());\n+                    let new_ignored_comments = code.children_with_tokens().filter_map(|element| {\n+                        if let SyntaxElement::Token(token) = element {\n+                            if token.kind() == SyntaxKind::COMMENT {\n+                                return Some(token.clone());\n+                            }\n+                        }\n+                        None\n+                    });\n+                    match_.ignored_comments.extend(new_ignored_comments);\n+                    let match_from_children = pattern_children\n+                        .by_ref()\n+                        .zip(code_children.by_ref())\n+                        .fold(Some(match_), |accum, (a, b)| {\n+                            accum.and_then(|match_| check(&a, &b, placeholders, match_))\n+                        });\n+                    match_from_children.and_then(|match_| {\n+                        if pattern_children.count() == 0 && code_children.count() == 0 {\n+                            Some(match_)\n+                        } else {\n+                            None\n+                        }\n+                    })\n                 }\n             }\n-            _ => false,\n+            _ => None,\n         }\n     }\n     let kind = pattern.pattern.kind();\n     let matches = code\n         .descendants_with_tokens()\n         .filter(|n| n.kind() == kind)\n         .filter_map(|code| {\n-            let mut match_ =\n-                Match { place: code.as_node().unwrap().clone(), binding: HashMap::new() };\n-            if check(\n-                &SyntaxElement::from(pattern.pattern.clone()),\n-                &code,\n-                &pattern.vars,\n-                &mut match_,\n-            ) {\n-                Some(match_)\n-            } else {\n-                None\n-            }\n+            let match_ = Match {\n+                place: code.as_node().unwrap().clone(),\n+                binding: HashMap::new(),\n+                ignored_comments: vec![],\n+            };\n+            check(&SyntaxElement::from(pattern.pattern.clone()), &code, &pattern.vars, match_)\n         })\n         .collect();\n     SsrMatches { matches }\n@@ -225,18 +244,28 @@ fn find(pattern: &SsrPattern, code: &SyntaxNode) -> SsrMatches {\n fn replace(matches: &SsrMatches, template: &SsrTemplate) -> TextEdit {\n     let mut builder = TextEditBuilder::default();\n     for match_ in &matches.matches {\n-        builder.replace(match_.place.text_range(), render_replace(&match_.binding, template));\n+        builder.replace(\n+            match_.place.text_range(),\n+            render_replace(&match_.binding, &match_.ignored_comments, template),\n+        );\n     }\n     builder.finish()\n }\n \n-fn render_replace(binding: &Binding, template: &SsrTemplate) -> String {\n+fn render_replace(\n+    binding: &Binding,\n+    ignored_comments: &Vec<SyntaxToken>,\n+    template: &SsrTemplate,\n+) -> String {\n     let mut builder = TextEditBuilder::default();\n     for element in template.template.descendants() {\n         if let Some(var) = template.placeholders.get(&element) {\n             builder.replace(element.text_range(), binding[var].to_string())\n         }\n     }\n+    for comment in ignored_comments {\n+        builder.insert(template.template.text_range().end(), comment.to_string())\n+    }\n     builder.finish().apply(&template.template.text().to_string())\n }\n \n@@ -325,4 +354,66 @@ mod tests {\n         let edit = replace(&matches, &query.template);\n         assert_eq!(edit.apply(input), \"fn main() { bar(1+2); }\");\n     }\n+\n+    fn assert_ssr_transform(query: &str, input: &str, result: &str) {\n+        let query: SsrQuery = query.parse().unwrap();\n+        let code = SourceFile::parse(input).tree();\n+        let matches = find(&query.pattern, code.syntax());\n+        let edit = replace(&matches, &query.template);\n+        assert_eq!(edit.apply(input), result);\n+    }\n+\n+    #[test]\n+    fn ssr_function_to_method() {\n+        assert_ssr_transform(\n+            \"my_function($a:expr, $b:expr) ==>> ($a).my_method($b)\",\n+            \"loop { my_function( other_func(x, y), z + w) }\",\n+            \"loop { (other_func(x, y)).my_method(z + w) }\",\n+        )\n+    }\n+\n+    #[test]\n+    fn ssr_nested_function() {\n+        assert_ssr_transform(\n+            \"foo($a:expr, $b:expr, $c:expr) ==>> bar($c, baz($a, $b))\",\n+            \"fn main { foo  (x + value.method(b), x+y-z, true && false) }\",\n+            \"fn main { bar(true && false, baz(x + value.method(b), x+y-z)) }\",\n+        )\n+    }\n+\n+    #[test]\n+    fn ssr_expected_spacing() {\n+        assert_ssr_transform(\n+            \"foo($x:expr) + bar() ==>> bar($x)\",\n+            \"fn main() { foo(5) + bar() }\",\n+            \"fn main() { bar(5) }\",\n+        );\n+    }\n+\n+    #[test]\n+    fn ssr_with_extra_space() {\n+        assert_ssr_transform(\n+            \"foo($x:expr  ) +    bar() ==>> bar($x)\",\n+            \"fn main() { foo(  5 )  +bar(   ) }\",\n+            \"fn main() { bar(5) }\",\n+        );\n+    }\n+\n+    #[test]\n+    fn ssr_keeps_nested_comment() {\n+        assert_ssr_transform(\n+            \"foo($x:expr) ==>> bar($x)\",\n+            \"fn main() { foo(other(5 /* using 5 */)) }\",\n+            \"fn main() { bar(other(5 /* using 5 */)) }\",\n+        )\n+    }\n+\n+    #[test]\n+    fn ssr_keeps_comment() {\n+        assert_ssr_transform(\n+            \"foo($x:expr) ==>> bar($x)\",\n+            \"fn main() { foo(5 /* using 5 */) }\",\n+            \"fn main() { bar(5)/* using 5 */ }\",\n+        )\n+    }\n }"}]}