{"sha": "cfc127f52988cf4f95797cb355398e3af32632aa", "node_id": "MDY6Q29tbWl0NzI0NzEyOmNmYzEyN2Y1Mjk4OGNmNGY5NTc5N2NiMzU1Mzk4ZTNhZjMyNjMyYWE=", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2020-04-09T11:00:55Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2020-04-09T11:00:55Z"}, "message": "Merge #3911\n\n3911: Genrate token accessors r=matklad a=matklad\n\nbors r+\n\ud83e\udd16\n\nCo-authored-by: Luca Barbieri <luca@luca-barbieri.com>\nCo-authored-by: Aleksey Kladov <aleksey.kladov@gmail.com>", "tree": {"sha": "a974bfe4160a0cb0d49146b239d68cdb99a6566d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a974bfe4160a0cb0d49146b239d68cdb99a6566d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/cfc127f52988cf4f95797cb355398e3af32632aa", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJejwBnCRBK7hj4Ov3rIwAAdHIIAJ526O6Rf0hB94ZbdGJTa4UU\nGnm+hNEeZ4KZrCwOKspTlYeg7UGn/GhoJpoVsmpqEsUW8G6MBlHW4CUIaRdeY7Hk\nvFLpaLKEt2GbEVbfWCA69kkqm8QMXwCcoIH+HEPTH79ibXr/Oiin+ObqSjPBBUkd\nPIf9ZkOkUX09cDkB2YCat1VOFwl8K0RtCAXniCHNY+A1j/foInKq0JZ3mK54Jfzn\nh3L5NvjxNJzDxsHT+Jl4RtnHG+QsMn+XKH8h9SZKyQvsEIaeGtgOHd+osMHC2ZGI\ns3oF3FQJutFdh0E8siWti98fEaBgTMpeZAPb+8Uv8ngunXq70VdibYmdJ2yDNdQ=\n=vtxJ\n-----END PGP SIGNATURE-----\n", "payload": "tree a974bfe4160a0cb0d49146b239d68cdb99a6566d\nparent 85956932872481cf4813c5e7794d981a9edb4623\nparent 689661c95968cb438f8bd1f10ce0ee096287741b\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1586430055 +0000\ncommitter GitHub <noreply@github.com> 1586430055 +0000\n\nMerge #3911\n\n3911: Genrate token accessors r=matklad a=matklad\n\nbors r+\n\ud83e\udd16\n\nCo-authored-by: Luca Barbieri <luca@luca-barbieri.com>\nCo-authored-by: Aleksey Kladov <aleksey.kladov@gmail.com>\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/cfc127f52988cf4f95797cb355398e3af32632aa", "html_url": "https://github.com/rust-lang/rust/commit/cfc127f52988cf4f95797cb355398e3af32632aa", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/cfc127f52988cf4f95797cb355398e3af32632aa/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "85956932872481cf4813c5e7794d981a9edb4623", "url": "https://api.github.com/repos/rust-lang/rust/commits/85956932872481cf4813c5e7794d981a9edb4623", "html_url": "https://github.com/rust-lang/rust/commit/85956932872481cf4813c5e7794d981a9edb4623"}, {"sha": "689661c95968cb438f8bd1f10ce0ee096287741b", "url": "https://api.github.com/repos/rust-lang/rust/commits/689661c95968cb438f8bd1f10ce0ee096287741b", "html_url": "https://github.com/rust-lang/rust/commit/689661c95968cb438f8bd1f10ce0ee096287741b"}], "stats": {"total": 2812, "additions": 2413, "deletions": 399}, "files": [{"sha": "72a201b6d2e6a27f0368e15c975c2153b11f70a8", "filename": "crates/ra_assists/src/handlers/add_impl.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/cfc127f52988cf4f95797cb355398e3af32632aa/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fadd_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cfc127f52988cf4f95797cb355398e3af32632aa/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fadd_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fadd_impl.rs?ref=cfc127f52988cf4f95797cb355398e3af32632aa", "patch": "@@ -1,5 +1,5 @@\n use ra_syntax::{\n-    ast::{self, AstNode, NameOwner, TypeParamsOwner},\n+    ast::{self, AstNode, AstToken, NameOwner, TypeParamsOwner},\n     TextUnit,\n };\n use stdx::{format_to, SepBy};\n@@ -42,7 +42,7 @@ pub(crate) fn add_impl(ctx: AssistCtx) -> Option<Assist> {\n         if let Some(type_params) = type_params {\n             let lifetime_params = type_params\n                 .lifetime_params()\n-                .filter_map(|it| it.lifetime_token())\n+                .filter_map(|it| it.lifetime())\n                 .map(|it| it.text().clone());\n             let type_params =\n                 type_params.type_params().filter_map(|it| it.name()).map(|it| it.text().clone());"}, {"sha": "c10397249fd18b993c7df343c545498128c7cb8b", "filename": "crates/ra_assists/src/handlers/add_new.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/cfc127f52988cf4f95797cb355398e3af32632aa/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fadd_new.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cfc127f52988cf4f95797cb355398e3af32632aa/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fadd_new.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fadd_new.rs?ref=cfc127f52988cf4f95797cb355398e3af32632aa", "patch": "@@ -1,7 +1,8 @@\n use hir::Adt;\n use ra_syntax::{\n     ast::{\n-        self, AstNode, NameOwner, StructKind, TypeAscriptionOwner, TypeParamsOwner, VisibilityOwner,\n+        self, AstNode, AstToken, NameOwner, StructKind, TypeAscriptionOwner, TypeParamsOwner,\n+        VisibilityOwner,\n     },\n     TextUnit, T,\n };\n@@ -105,7 +106,7 @@ fn generate_impl_text(strukt: &ast::StructDef, code: &str) -> String {\n     if let Some(type_params) = type_params {\n         let lifetime_params = type_params\n             .lifetime_params()\n-            .filter_map(|it| it.lifetime_token())\n+            .filter_map(|it| it.lifetime())\n             .map(|it| it.text().clone());\n         let type_params =\n             type_params.type_params().filter_map(|it| it.name()).map(|it| it.text().clone());"}, {"sha": "8a02f1a32c5132ac1ed357fdbde4d3aa7146c88e", "filename": "crates/ra_assists/src/handlers/introduce_variable.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cfc127f52988cf4f95797cb355398e3af32632aa/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fintroduce_variable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cfc127f52988cf4f95797cb355398e3af32632aa/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fintroduce_variable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fintroduce_variable.rs?ref=cfc127f52988cf4f95797cb355398e3af32632aa", "patch": "@@ -124,7 +124,7 @@ fn anchor_stmt(expr: ast::Expr) -> Option<(SyntaxNode, bool)> {\n             }\n         }\n \n-        if ast::Stmt::cast(node.clone()).is_some() {\n+        if ast::Stmt::cast(node.clone().into()).is_some() {\n             return Some((node, false));\n         }\n "}, {"sha": "f8b3ddb4e18f3c50dbcb1bce073719ff1f8b7428", "filename": "crates/ra_assists/src/handlers/merge_imports.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/cfc127f52988cf4f95797cb355398e3af32632aa/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fmerge_imports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cfc127f52988cf4f95797cb355398e3af32632aa/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fmerge_imports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fmerge_imports.rs?ref=cfc127f52988cf4f95797cb355398e3af32632aa", "patch": "@@ -3,7 +3,7 @@ use std::iter::successors;\n use ra_syntax::{\n     algo::{neighbor, SyntaxRewriter},\n     ast::{self, edit::AstNodeEdit, make},\n-    AstNode, Direction, InsertPosition, SyntaxElement, T,\n+    AstNode, AstToken, Direction, InsertPosition, SyntaxElement, T,\n };\n \n use crate::{Assist, AssistCtx, AssistId};\n@@ -82,7 +82,7 @@ fn try_merge_trees(old: &ast::UseTree, new: &ast::UseTree) -> Option<ast::UseTre\n             .filter(|it| it.kind() != T!['{'] && it.kind() != T!['}']),\n     );\n     let use_tree_list = lhs.use_tree_list()?;\n-    let pos = InsertPosition::Before(use_tree_list.r_curly()?.into());\n+    let pos = InsertPosition::Before(use_tree_list.r_curly()?.syntax().clone().into());\n     let use_tree_list = use_tree_list.insert_children(pos, to_insert);\n     Some(lhs.with_use_tree_list(use_tree_list))\n }"}, {"sha": "0b4ba1bbe6541a05fddcf1418c34e4526287e4e2", "filename": "crates/ra_fmt/src/lib.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/cfc127f52988cf4f95797cb355398e3af32632aa/crates%2Fra_fmt%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cfc127f52988cf4f95797cb355398e3af32632aa/crates%2Fra_fmt%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_fmt%2Fsrc%2Flib.rs?ref=cfc127f52988cf4f95797cb355398e3af32632aa", "patch": "@@ -60,10 +60,10 @@ pub fn extract_trivial_expression(block: &ast::BlockExpr) -> Option<ast::Expr> {\n     } else {\n         // Unwrap `{ continue; }`\n         let (stmt,) = block.statements().next_tuple()?;\n-        if has_anything_else(stmt.syntax()) {\n-            return None;\n-        }\n         if let ast::Stmt::ExprStmt(expr_stmt) = stmt {\n+            if has_anything_else(expr_stmt.syntax()) {\n+                return None;\n+            }\n             let expr = expr_stmt.expr()?;\n             match expr.syntax().kind() {\n                 CONTINUE_EXPR | BREAK_EXPR | RETURN_EXPR => return Some(expr),"}, {"sha": "b02de5d67d01ccf7d7d213c1176bfe3556d6db22", "filename": "crates/ra_hir_def/src/body/lower.rs", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/cfc127f52988cf4f95797cb355398e3af32632aa/crates%2Fra_hir_def%2Fsrc%2Fbody%2Flower.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cfc127f52988cf4f95797cb355398e3af32632aa/crates%2Fra_hir_def%2Fsrc%2Fbody%2Flower.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Fbody%2Flower.rs?ref=cfc127f52988cf4f95797cb355398e3af32632aa", "patch": "@@ -482,14 +482,16 @@ impl ExprCollector<'_> {\n         self.collect_block_items(&block);\n         let statements = block\n             .statements()\n-            .map(|s| match s {\n+            .filter_map(|s| match s {\n                 ast::Stmt::LetStmt(stmt) => {\n                     let pat = self.collect_pat_opt(stmt.pat());\n                     let type_ref = stmt.ascribed_type().map(TypeRef::from_ast);\n                     let initializer = stmt.initializer().map(|e| self.collect_expr(e));\n-                    Statement::Let { pat, type_ref, initializer }\n+                    Some(Statement::Let { pat, type_ref, initializer })\n+                }\n+                ast::Stmt::ExprStmt(stmt) => {\n+                    Some(Statement::Expr(self.collect_expr_opt(stmt.expr())))\n                 }\n-                ast::Stmt::ExprStmt(stmt) => Statement::Expr(self.collect_expr_opt(stmt.expr())),\n             })\n             .collect();\n         let tail = block.expr().map(|e| self.collect_expr(e));\n@@ -541,6 +543,7 @@ impl ExprCollector<'_> {\n                     let ast_id = self.expander.ast_id(&def);\n                     (TraitLoc { container, ast_id }.intern(self.db).into(), def.name())\n                 }\n+                ast::ModuleItem::ExternBlock(_) => continue, // FIXME: collect from extern blocks\n                 ast::ModuleItem::ImplDef(_)\n                 | ast::ModuleItem::UseItem(_)\n                 | ast::ModuleItem::ExternCrateItem(_)"}, {"sha": "a9dff3a5d5a712d9b8e93fefcc76048c89882684", "filename": "crates/ra_hir_def/src/nameres/raw.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/cfc127f52988cf4f95797cb355398e3af32632aa/crates%2Fra_hir_def%2Fsrc%2Fnameres%2Fraw.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cfc127f52988cf4f95797cb355398e3af32632aa/crates%2Fra_hir_def%2Fsrc%2Fnameres%2Fraw.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Fnameres%2Fraw.rs?ref=cfc127f52988cf4f95797cb355398e3af32632aa", "patch": "@@ -266,6 +266,10 @@ impl RawItemsCollector {\n                 self.add_macro(current_module, it);\n                 return;\n             }\n+            ast::ModuleItem::ExternBlock(_) => {\n+                // FIXME: add extern block\n+                return;\n+            }\n         };\n         if let Some(name) = name {\n             let name = name.as_name();"}, {"sha": "3c13cb2c788162a649d2fb8f33a6ba4954eef0ee", "filename": "crates/ra_hir_def/src/path/lower.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cfc127f52988cf4f95797cb355398e3af32632aa/crates%2Fra_hir_def%2Fsrc%2Fpath%2Flower.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cfc127f52988cf4f95797cb355398e3af32632aa/crates%2Fra_hir_def%2Fsrc%2Fpath%2Flower.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Fpath%2Flower.rs?ref=cfc127f52988cf4f95797cb355398e3af32632aa", "patch": "@@ -28,7 +28,7 @@ pub(super) fn lower_path(mut path: ast::Path, hygiene: &Hygiene) -> Option<Path>\n     loop {\n         let segment = path.segment()?;\n \n-        if segment.has_colon_colon() {\n+        if segment.coloncolon().is_some() {\n             kind = PathKind::Abs;\n         }\n "}, {"sha": "6ec944228cf69951143e3b52f48f75363decf8f6", "filename": "crates/ra_hir_def/src/path/lower/lower_use.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cfc127f52988cf4f95797cb355398e3af32632aa/crates%2Fra_hir_def%2Fsrc%2Fpath%2Flower%2Flower_use.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cfc127f52988cf4f95797cb355398e3af32632aa/crates%2Fra_hir_def%2Fsrc%2Fpath%2Flower%2Flower_use.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Fpath%2Flower%2Flower_use.rs?ref=cfc127f52988cf4f95797cb355398e3af32632aa", "patch": "@@ -34,7 +34,7 @@ pub(crate) fn lower_use_tree(\n         let alias = tree.alias().map(|a| {\n             a.name().map(|it| it.as_name()).map_or(ImportAlias::Underscore, ImportAlias::Alias)\n         });\n-        let is_glob = tree.has_star();\n+        let is_glob = tree.star().is_some();\n         if let Some(ast_path) = tree.path() {\n             // Handle self in a path.\n             // E.g. `use something::{self, <...>}`"}, {"sha": "1482d3be04da0610288e2bd5932143b452223696", "filename": "crates/ra_hir_def/src/visibility.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/cfc127f52988cf4f95797cb355398e3af32632aa/crates%2Fra_hir_def%2Fsrc%2Fvisibility.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cfc127f52988cf4f95797cb355398e3af32632aa/crates%2Fra_hir_def%2Fsrc%2Fvisibility.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Fvisibility.rs?ref=cfc127f52988cf4f95797cb355398e3af32632aa", "patch": "@@ -84,6 +84,10 @@ impl RawVisibility {\n                 let path = ModPath { kind: PathKind::Super(1), segments: Vec::new() };\n                 RawVisibility::Module(path)\n             }\n+            ast::VisibilityKind::PubSelf => {\n+                let path = ModPath { kind: PathKind::Plain, segments: Vec::new() };\n+                RawVisibility::Module(path)\n+            }\n             ast::VisibilityKind::Pub => RawVisibility::Public,\n         }\n     }"}, {"sha": "ac096623682f812f92ce92b961ac2e1450889db4", "filename": "crates/ra_hir_ty/src/tests.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/cfc127f52988cf4f95797cb355398e3af32632aa/crates%2Fra_hir_ty%2Fsrc%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cfc127f52988cf4f95797cb355398e3af32632aa/crates%2Fra_hir_ty%2Fsrc%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Ftests.rs?ref=cfc127f52988cf4f95797cb355398e3af32632aa", "patch": "@@ -23,7 +23,7 @@ use insta::assert_snapshot;\n use ra_db::{fixture::WithFixture, salsa::Database, FilePosition, SourceDatabase};\n use ra_syntax::{\n     algo,\n-    ast::{self, AstNode},\n+    ast::{self, AstNode, AstToken},\n };\n use stdx::format_to;\n \n@@ -101,7 +101,7 @@ fn infer_with_mismatches(content: &str, include_mismatches: bool) -> String {\n             let node = src_ptr.value.to_node(&src_ptr.file_syntax(&db));\n \n             let (range, text) = if let Some(self_param) = ast::SelfParam::cast(node.clone()) {\n-                (self_param.self_kw_token().text_range(), \"self\".to_string())\n+                (self_param.self_kw().unwrap().syntax().text_range(), \"self\".to_string())\n             } else {\n                 (src_ptr.value.range(), node.text().to_string().replace(\"\\n\", \" \"))\n             };"}, {"sha": "004f4e564310a58f805008863b7f96e5e7cb118a", "filename": "crates/ra_parser/src/syntax_kind/generated.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/cfc127f52988cf4f95797cb355398e3af32632aa/crates%2Fra_parser%2Fsrc%2Fsyntax_kind%2Fgenerated.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cfc127f52988cf4f95797cb355398e3af32632aa/crates%2Fra_parser%2Fsrc%2Fsyntax_kind%2Fgenerated.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_parser%2Fsrc%2Fsyntax_kind%2Fgenerated.rs?ref=cfc127f52988cf4f95797cb355398e3af32632aa", "patch": "@@ -105,6 +105,7 @@ pub enum SyntaxKind {\n     DEFAULT_KW,\n     EXISTENTIAL_KW,\n     UNION_KW,\n+    RAW_KW,\n     INT_NUMBER,\n     FLOAT_NUMBER,\n     CHAR,\n@@ -258,7 +259,7 @@ impl SyntaxKind {\n             | IMPL_KW | IN_KW | LET_KW | LOOP_KW | MACRO_KW | MATCH_KW | MOD_KW | MOVE_KW\n             | MUT_KW | PUB_KW | REF_KW | RETURN_KW | SELF_KW | STATIC_KW | STRUCT_KW | SUPER_KW\n             | TRAIT_KW | TRUE_KW | TRY_KW | TYPE_KW | UNSAFE_KW | USE_KW | WHERE_KW | WHILE_KW\n-            | AUTO_KW | DEFAULT_KW | EXISTENTIAL_KW | UNION_KW => true,\n+            | AUTO_KW | DEFAULT_KW | EXISTENTIAL_KW | UNION_KW | RAW_KW => true,\n             _ => false,\n         }\n     }\n@@ -651,4 +652,7 @@ macro_rules! T {\n     ( union ) => {\n         $crate::SyntaxKind::UNION_KW\n     };\n+    ( raw ) => {\n+        $crate::SyntaxKind::RAW_KW\n+    };\n }"}, {"sha": "e1ebd5b92823dee6545fef7b8c0155e399744cbb", "filename": "crates/ra_syntax/src/ast.rs", "status": "modified", "additions": 17, "deletions": 1, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/cfc127f52988cf4f95797cb355398e3af32632aa/crates%2Fra_syntax%2Fsrc%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cfc127f52988cf4f95797cb355398e3af32632aa/crates%2Fra_syntax%2Fsrc%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Fast.rs?ref=cfc127f52988cf4f95797cb355398e3af32632aa", "patch": "@@ -64,6 +64,22 @@ pub trait AstToken {\n     }\n }\n \n+mod support {\n+    use super::{AstChildren, AstNode, AstToken, SyntaxNode};\n+\n+    pub(super) fn child<N: AstNode>(parent: &SyntaxNode) -> Option<N> {\n+        parent.children().find_map(N::cast)\n+    }\n+\n+    pub(super) fn children<N: AstNode>(parent: &SyntaxNode) -> AstChildren<N> {\n+        AstChildren::new(parent)\n+    }\n+\n+    pub(super) fn token<T: AstToken>(parent: &SyntaxNode) -> Option<T> {\n+        parent.children_with_tokens().filter_map(|it| it.into_token()).find_map(T::cast)\n+    }\n+}\n+\n /// An iterator over `SyntaxNode` children of a particular AST type.\n #[derive(Debug, Clone)]\n pub struct AstChildren<N> {\n@@ -271,7 +287,7 @@ where\n     let pred = predicates.next().unwrap();\n     let mut bounds = pred.type_bound_list().unwrap().bounds();\n \n-    assert_eq!(\"'a\", pred.lifetime_token().unwrap().text());\n+    assert_eq!(\"'a\", pred.lifetime().unwrap().text());\n \n     assert_bound(\"'b\", bounds.next());\n     assert_bound(\"'c\", bounds.next());"}, {"sha": "d7931099535bf181d042d50713b9f85316ed23df", "filename": "crates/ra_syntax/src/ast/edit.rs", "status": "modified", "additions": 11, "deletions": 15, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/cfc127f52988cf4f95797cb355398e3af32632aa/crates%2Fra_syntax%2Fsrc%2Fast%2Fedit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cfc127f52988cf4f95797cb355398e3af32632aa/crates%2Fra_syntax%2Fsrc%2Fast%2Fedit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Fast%2Fedit.rs?ref=cfc127f52988cf4f95797cb355398e3af32632aa", "patch": "@@ -99,7 +99,7 @@ impl ast::ItemList {\n             None => match self.l_curly() {\n                 Some(it) => (\n                     \"    \".to_string() + &leading_indent(self.syntax()).unwrap_or_default(),\n-                    InsertPosition::After(it),\n+                    InsertPosition::After(it.syntax().clone().into()),\n                 ),\n                 None => return self.clone(),\n             },\n@@ -109,10 +109,6 @@ impl ast::ItemList {\n             [ws.ws().into(), item.syntax().clone().into()].into();\n         self.insert_children(position, to_insert)\n     }\n-\n-    fn l_curly(&self) -> Option<SyntaxElement> {\n-        self.syntax().children_with_tokens().find(|it| it.kind() == T!['{'])\n-    }\n }\n \n impl ast::RecordFieldList {\n@@ -147,7 +143,7 @@ impl ast::RecordFieldList {\n         macro_rules! after_l_curly {\n             () => {{\n                 let anchor = match self.l_curly() {\n-                    Some(it) => it,\n+                    Some(it) => it.syntax().clone().into(),\n                     None => return self.clone(),\n                 };\n                 InsertPosition::After(anchor)\n@@ -189,24 +185,20 @@ impl ast::RecordFieldList {\n \n         self.insert_children(position, to_insert)\n     }\n-\n-    fn l_curly(&self) -> Option<SyntaxElement> {\n-        self.syntax().children_with_tokens().find(|it| it.kind() == T!['{'])\n-    }\n }\n \n impl ast::TypeParam {\n     #[must_use]\n     pub fn remove_bounds(&self) -> ast::TypeParam {\n-        let colon = match self.colon_token() {\n+        let colon = match self.colon() {\n             Some(it) => it,\n             None => return self.clone(),\n         };\n         let end = match self.type_bound_list() {\n             Some(it) => it.syntax().clone().into(),\n-            None => colon.clone().into(),\n+            None => colon.syntax().clone().into(),\n         };\n-        self.replace_children(colon.into()..=end, iter::empty())\n+        self.replace_children(colon.syntax().clone().into()..=end, iter::empty())\n     }\n }\n \n@@ -305,8 +297,12 @@ impl ast::UseTree {\n             Some(it) => it,\n             None => return self.clone(),\n         };\n-        let use_tree =\n-            make::use_tree(suffix.clone(), self.use_tree_list(), self.alias(), self.has_star());\n+        let use_tree = make::use_tree(\n+            suffix.clone(),\n+            self.use_tree_list(),\n+            self.alias(),\n+            self.star().is_some(),\n+        );\n         let nested = make::use_tree_list(iter::once(use_tree));\n         return make::use_tree(prefix.clone(), Some(nested), None, false);\n "}, {"sha": "40c8fca3be3fffb2ca87109ff7713c446f17e81b", "filename": "crates/ra_syntax/src/ast/expr_extensions.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/cfc127f52988cf4f95797cb355398e3af32632aa/crates%2Fra_syntax%2Fsrc%2Fast%2Fexpr_extensions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cfc127f52988cf4f95797cb355398e3af32632aa/crates%2Fra_syntax%2Fsrc%2Fast%2Fexpr_extensions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Fast%2Fexpr_extensions.rs?ref=cfc127f52988cf4f95797cb355398e3af32632aa", "patch": "@@ -52,6 +52,10 @@ impl ast::RefExpr {\n     pub fn is_mut(&self) -> bool {\n         self.syntax().children_with_tokens().any(|n| n.kind() == T![mut])\n     }\n+\n+    pub fn raw_token(&self) -> Option<SyntaxToken> {\n+        None // FIXME: implement &raw\n+    }\n }\n \n #[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]"}, {"sha": "33fe60762a34aa8b91eed4611801a5a6116e6f90", "filename": "crates/ra_syntax/src/ast/extensions.rs", "status": "modified", "additions": 75, "deletions": 72, "changes": 147, "blob_url": "https://github.com/rust-lang/rust/blob/cfc127f52988cf4f95797cb355398e3af32632aa/crates%2Fra_syntax%2Fsrc%2Fast%2Fextensions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cfc127f52988cf4f95797cb355398e3af32632aa/crates%2Fra_syntax%2Fsrc%2Fast%2Fextensions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Fast%2Fextensions.rs?ref=cfc127f52988cf4f95797cb355398e3af32632aa", "patch": "@@ -4,7 +4,9 @@\n use itertools::Itertools;\n \n use crate::{\n-    ast::{self, child_opt, children, AstNode, AttrInput, NameOwner, SyntaxNode},\n+    ast::{\n+        self, child_opt, children, support, AstNode, AstToken, AttrInput, NameOwner, SyntaxNode,\n+    },\n     SmolStr, SyntaxElement,\n     SyntaxKind::*,\n     SyntaxToken, T,\n@@ -130,13 +132,6 @@ impl ast::PathSegment {\n         };\n         Some(res)\n     }\n-\n-    pub fn has_colon_colon(&self) -> bool {\n-        match self.syntax.first_child_or_token().map(|s| s.kind()) {\n-            Some(T![::]) => true,\n-            _ => false,\n-        }\n-    }\n }\n \n impl ast::Path {\n@@ -154,33 +149,13 @@ impl ast::Module {\n     }\n }\n \n-impl ast::UseTree {\n-    pub fn has_star(&self) -> bool {\n-        self.syntax().children_with_tokens().any(|it| it.kind() == T![*])\n-    }\n-}\n-\n impl ast::UseTreeList {\n     pub fn parent_use_tree(&self) -> ast::UseTree {\n         self.syntax()\n             .parent()\n             .and_then(ast::UseTree::cast)\n             .expect(\"UseTreeLists are always nested in UseTrees\")\n     }\n-    pub fn l_curly(&self) -> Option<SyntaxToken> {\n-        self.token(T!['{'])\n-    }\n-\n-    pub fn r_curly(&self) -> Option<SyntaxToken> {\n-        self.token(T!['}'])\n-    }\n-\n-    fn token(&self, kind: SyntaxKind) -> Option<SyntaxToken> {\n-        self.syntax()\n-            .children_with_tokens()\n-            .filter_map(|it| it.into_token())\n-            .find(|it| it.kind() == kind)\n-    }\n }\n \n impl ast::ImplDef {\n@@ -387,24 +362,9 @@ pub enum SelfParamKind {\n }\n \n impl ast::SelfParam {\n-    pub fn self_kw_token(&self) -> SyntaxToken {\n-        self.syntax()\n-            .children_with_tokens()\n-            .filter_map(|it| it.into_token())\n-            .find(|it| it.kind() == T![self])\n-            .expect(\"invalid tree: self param must have self\")\n-    }\n-\n     pub fn kind(&self) -> SelfParamKind {\n-        let borrowed = self.syntax().children_with_tokens().any(|n| n.kind() == T![&]);\n-        if borrowed {\n-            // check for a `mut` coming after the & -- `mut &self` != `&mut self`\n-            if self\n-                .syntax()\n-                .children_with_tokens()\n-                .skip_while(|n| n.kind() != T![&])\n-                .any(|n| n.kind() == T![mut])\n-            {\n+        if self.amp().is_some() {\n+            if self.amp_mut_kw().is_some() {\n                 SelfParamKind::MutRef\n             } else {\n                 SelfParamKind::Ref\n@@ -413,32 +373,23 @@ impl ast::SelfParam {\n             SelfParamKind::Owned\n         }\n     }\n-}\n \n-impl ast::LifetimeParam {\n-    pub fn lifetime_token(&self) -> Option<SyntaxToken> {\n+    /// the \"mut\" in \"mut self\", not the one in \"&mut self\"\n+    pub fn mut_kw(&self) -> Option<ast::MutKw> {\n         self.syntax()\n             .children_with_tokens()\n             .filter_map(|it| it.into_token())\n-            .find(|it| it.kind() == LIFETIME)\n+            .take_while(|it| it.kind() != T![&])\n+            .find_map(ast::MutKw::cast)\n     }\n-}\n \n-impl ast::TypeParam {\n-    pub fn colon_token(&self) -> Option<SyntaxToken> {\n+    /// the \"mut\" in \"&mut self\", not the one in \"mut self\"\n+    pub fn amp_mut_kw(&self) -> Option<ast::MutKw> {\n         self.syntax()\n             .children_with_tokens()\n             .filter_map(|it| it.into_token())\n-            .find(|it| it.kind() == T![:])\n-    }\n-}\n-\n-impl ast::WherePred {\n-    pub fn lifetime_token(&self) -> Option<SyntaxToken> {\n-        self.syntax()\n-            .children_with_tokens()\n-            .filter_map(|it| it.into_token())\n-            .find(|it| it.kind() == LIFETIME)\n+            .skip_while(|it| it.kind() != T![&])\n+            .find_map(ast::MutKw::cast)\n     }\n }\n \n@@ -449,7 +400,7 @@ pub enum TypeBoundKind {\n     /// for<'a> ...\n     ForType(ast::ForType),\n     /// 'a\n-    Lifetime(ast::SyntaxToken),\n+    Lifetime(ast::Lifetime),\n }\n \n impl ast::TypeBound {\n@@ -465,21 +416,28 @@ impl ast::TypeBound {\n         }\n     }\n \n-    fn lifetime(&self) -> Option<SyntaxToken> {\n-        self.syntax()\n-            .children_with_tokens()\n-            .filter_map(|it| it.into_token())\n-            .find(|it| it.kind() == LIFETIME)\n+    pub fn has_question_mark(&self) -> bool {\n+        self.question().is_some()\n     }\n \n-    pub fn question_mark_token(&self) -> Option<SyntaxToken> {\n+    pub fn const_question(&self) -> Option<ast::Question> {\n         self.syntax()\n             .children_with_tokens()\n             .filter_map(|it| it.into_token())\n-            .find(|it| it.kind() == T![?])\n+            .take_while(|it| it.kind() != T![const])\n+            .find_map(ast::Question::cast)\n     }\n-    pub fn has_question_mark(&self) -> bool {\n-        self.question_mark_token().is_some()\n+\n+    pub fn question(&self) -> Option<ast::Question> {\n+        if self.const_kw().is_some() {\n+            self.syntax()\n+                .children_with_tokens()\n+                .filter_map(|it| it.into_token())\n+                .skip_while(|it| it.kind() != T![const])\n+                .find_map(ast::Question::cast)\n+        } else {\n+            support::token(&self.syntax)\n+        }\n     }\n }\n \n@@ -493,6 +451,7 @@ pub enum VisibilityKind {\n     In(ast::Path),\n     PubCrate,\n     PubSuper,\n+    PubSelf,\n     Pub,\n }\n \n@@ -504,6 +463,8 @@ impl ast::Visibility {\n             VisibilityKind::PubCrate\n         } else if self.is_pub_super() {\n             VisibilityKind::PubSuper\n+        } else if self.is_pub_self() {\n+            VisibilityKind::PubSuper\n         } else {\n             VisibilityKind::Pub\n         }\n@@ -516,6 +477,10 @@ impl ast::Visibility {\n     fn is_pub_super(&self) -> bool {\n         self.syntax().children_with_tokens().any(|it| it.kind() == T![super])\n     }\n+\n+    fn is_pub_self(&self) -> bool {\n+        self.syntax().children_with_tokens().any(|it| it.kind() == T![self])\n+    }\n }\n \n impl ast::MacroCall {\n@@ -528,3 +493,41 @@ impl ast::MacroCall {\n         }\n     }\n }\n+\n+impl ast::LifetimeParam {\n+    pub fn lifetime_bounds(&self) -> impl Iterator<Item = ast::Lifetime> {\n+        self.syntax()\n+            .children_with_tokens()\n+            .filter_map(|it| it.into_token())\n+            .skip_while(|x| x.kind() != T![:])\n+            .filter_map(ast::Lifetime::cast)\n+    }\n+}\n+\n+impl ast::RangePat {\n+    pub fn start(&self) -> Option<ast::Pat> {\n+        self.syntax()\n+            .children_with_tokens()\n+            .take_while(|it| !ast::RangeSeparator::can_cast(it.kind()))\n+            .filter_map(|it| it.into_node())\n+            .find_map(ast::Pat::cast)\n+    }\n+\n+    pub fn end(&self) -> Option<ast::Pat> {\n+        self.syntax()\n+            .children_with_tokens()\n+            .skip_while(|it| !ast::RangeSeparator::can_cast(it.kind()))\n+            .filter_map(|it| it.into_node())\n+            .find_map(ast::Pat::cast)\n+    }\n+}\n+\n+impl ast::TokenTree {\n+    pub fn left_delimiter(&self) -> Option<ast::LeftDelimiter> {\n+        self.syntax().first_child_or_token()?.into_token().and_then(ast::LeftDelimiter::cast)\n+    }\n+\n+    pub fn right_delimiter(&self) -> Option<ast::RightDelimiter> {\n+        self.syntax().last_child_or_token()?.into_token().and_then(ast::RightDelimiter::cast)\n+    }\n+}"}, {"sha": "bd92e9c8748b994a77dbb7f1eb7043929eb330ec", "filename": "crates/ra_syntax/src/ast/generated.rs", "status": "modified", "additions": 1921, "deletions": 172, "changes": 2093, "blob_url": "https://github.com/rust-lang/rust/blob/cfc127f52988cf4f95797cb355398e3af32632aa/crates%2Fra_syntax%2Fsrc%2Fast%2Fgenerated.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cfc127f52988cf4f95797cb355398e3af32632aa/crates%2Fra_syntax%2Fsrc%2Fast%2Fgenerated.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Fast%2Fgenerated.rs?ref=cfc127f52988cf4f95797cb355398e3af32632aa"}, {"sha": "870e838048ab548ddba224b8d56f46edddd4c4df", "filename": "crates/ra_syntax/src/ast/traits.rs", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/cfc127f52988cf4f95797cb355398e3af32632aa/crates%2Fra_syntax%2Fsrc%2Fast%2Ftraits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cfc127f52988cf4f95797cb355398e3af32632aa/crates%2Fra_syntax%2Fsrc%2Fast%2Ftraits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Fast%2Ftraits.rs?ref=cfc127f52988cf4f95797cb355398e3af32632aa", "patch": "@@ -5,7 +5,7 @@\n use itertools::Itertools;\n \n use crate::{\n-    ast::{self, child_opt, children, AstChildren, AstNode, AstToken},\n+    ast::{self, child_opt, children, support, AstChildren, AstNode, AstToken},\n     syntax_node::SyntaxElementChildren,\n };\n \n@@ -31,6 +31,10 @@ pub trait LoopBodyOwner: AstNode {\n     fn loop_body(&self) -> Option<ast::BlockExpr> {\n         child_opt(self)\n     }\n+\n+    fn label(&self) -> Option<ast::Label> {\n+        child_opt(self)\n+    }\n }\n \n pub trait ArgListOwner: AstNode {\n@@ -65,6 +69,10 @@ pub trait TypeBoundsOwner: AstNode {\n     fn type_bound_list(&self) -> Option<ast::TypeBoundList> {\n         child_opt(self)\n     }\n+\n+    fn colon(&self) -> Option<ast::Colon> {\n+        support::token(self.syntax())\n+    }\n }\n \n pub trait AttrsOwner: AstNode {"}, {"sha": "5fed777ace58266a3a50a6f2278d2c074691fc08", "filename": "xtask/src/ast_src.rs", "status": "modified", "additions": 284, "deletions": 91, "changes": 375, "blob_url": "https://github.com/rust-lang/rust/blob/cfc127f52988cf4f95797cb355398e3af32632aa/xtask%2Fsrc%2Fast_src.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cfc127f52988cf4f95797cb355398e3af32632aa/xtask%2Fsrc%2Fast_src.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/xtask%2Fsrc%2Fast_src.rs?ref=cfc127f52988cf4f95797cb355398e3af32632aa", "patch": "@@ -70,7 +70,7 @@ pub(crate) const KINDS_SRC: KindsSrc = KindsSrc {\n         \"match\", \"mod\", \"move\", \"mut\", \"pub\", \"ref\", \"return\", \"self\", \"static\", \"struct\", \"super\",\n         \"trait\", \"true\", \"try\", \"type\", \"unsafe\", \"use\", \"where\", \"while\",\n     ],\n-    contextual_keywords: &[\"auto\", \"default\", \"existential\", \"union\"],\n+    contextual_keywords: &[\"auto\", \"default\", \"existential\", \"union\", \"raw\"],\n     literals: &[\n         \"INT_NUMBER\",\n         \"FLOAT_NUMBER\",\n@@ -297,248 +297,355 @@ macro_rules! ast_enums {\n \n pub(crate) const AST_SRC: AstSrc = AstSrc {\n     nodes: &ast_nodes! {\n-        struct SourceFile: ModuleItemOwner, FnDefOwner {\n+        struct SourceFile: ModuleItemOwner, FnDefOwner, AttrsOwner {\n             modules: [Module],\n         }\n \n         struct FnDef: VisibilityOwner, NameOwner, TypeParamsOwner, DocCommentsOwner, AttrsOwner {\n+            Abi,\n+            ConstKw,\n+            DefaultKw,\n+            AsyncKw,\n+            UnsafeKw,\n+            FnKw,\n             ParamList,\n             RetType,\n             body: BlockExpr,\n+            Semi\n         }\n \n-        struct RetType { TypeRef }\n+        struct RetType { ThinArrow, TypeRef }\n \n         struct StructDef: VisibilityOwner, NameOwner, TypeParamsOwner, AttrsOwner, DocCommentsOwner {\n+            StructKw,\n+            FieldDefList,\n+            Semi\n         }\n \n         struct UnionDef: VisibilityOwner, NameOwner, TypeParamsOwner, AttrsOwner, DocCommentsOwner {\n+            UnionKw,\n             RecordFieldDefList,\n         }\n \n-        struct RecordFieldDefList { fields: [RecordFieldDef] }\n+        struct RecordFieldDefList { LCurly, fields: [RecordFieldDef], RCurly }\n         struct RecordFieldDef: VisibilityOwner, NameOwner, AttrsOwner, DocCommentsOwner, TypeAscriptionOwner { }\n \n-        struct TupleFieldDefList { fields: [TupleFieldDef] }\n+        struct TupleFieldDefList { LParen, fields: [TupleFieldDef], RParen }\n         struct TupleFieldDef: VisibilityOwner, AttrsOwner {\n             TypeRef,\n         }\n \n         struct EnumDef: VisibilityOwner, NameOwner, TypeParamsOwner, AttrsOwner, DocCommentsOwner {\n+            EnumKw,\n             variant_list: EnumVariantList,\n         }\n         struct EnumVariantList {\n+            LCurly,\n             variants: [EnumVariant],\n+            RCurly\n         }\n-        struct EnumVariant: NameOwner, DocCommentsOwner, AttrsOwner {\n+        struct EnumVariant: VisibilityOwner, NameOwner, DocCommentsOwner, AttrsOwner {\n+            FieldDefList,\n+            Eq,\n             Expr\n         }\n \n         struct TraitDef: VisibilityOwner, NameOwner, AttrsOwner, DocCommentsOwner, TypeParamsOwner, TypeBoundsOwner {\n+            UnsafeKw,\n+            AutoKw,\n+            TraitKw,\n             ItemList,\n         }\n \n         struct Module: VisibilityOwner, NameOwner, AttrsOwner, DocCommentsOwner {\n+            ModKw,\n             ItemList,\n+            Semi\n         }\n \n         struct ItemList: FnDefOwner, ModuleItemOwner {\n+            LCurly,\n             impl_items: [ImplItem],\n+            RCurly\n         }\n \n         struct ConstDef: VisibilityOwner, NameOwner, TypeParamsOwner, AttrsOwner, DocCommentsOwner, TypeAscriptionOwner {\n+            DefaultKw,\n+            ConstKw,\n+            Eq,\n             body: Expr,\n+            Semi\n         }\n \n         struct StaticDef: VisibilityOwner, NameOwner, TypeParamsOwner, AttrsOwner, DocCommentsOwner, TypeAscriptionOwner {\n+            StaticKw,\n+            MutKw,\n+            Eq,\n             body: Expr,\n+            Semi\n         }\n \n         struct TypeAliasDef: VisibilityOwner, NameOwner, TypeParamsOwner, AttrsOwner, DocCommentsOwner, TypeBoundsOwner {\n+            DefaultKw,\n+            TypeKw,\n+            Eq,\n             TypeRef,\n+            Semi\n         }\n \n         struct ImplDef: TypeParamsOwner, AttrsOwner {\n+            DefaultKw,\n+            ConstKw,\n+            UnsafeKw,\n+            ImplKw,\n+            Excl,\n+            ForKw,\n             ItemList,\n         }\n \n-        struct ParenType { TypeRef }\n-        struct TupleType { fields: [TypeRef] }\n-        struct NeverType { }\n+        struct ParenType { LParen, TypeRef, RParen }\n+        struct TupleType { LParen, fields: [TypeRef], RParen }\n+        struct NeverType { Excl }\n         struct PathType { Path }\n-        struct PointerType { TypeRef }\n-        struct ArrayType { TypeRef, Expr }\n-        struct SliceType { TypeRef }\n-        struct ReferenceType { TypeRef }\n-        struct PlaceholderType {  }\n-        struct FnPointerType { ParamList, RetType }\n-        struct ForType { TypeRef }\n-        struct ImplTraitType: TypeBoundsOwner {}\n-        struct DynTraitType: TypeBoundsOwner {}\n-\n-        struct TupleExpr { exprs: [Expr] }\n-        struct ArrayExpr { exprs: [Expr] }\n-        struct ParenExpr { Expr }\n+        struct PointerType { Star, ConstKw, TypeRef }\n+        struct ArrayType { LBrack, TypeRef, Semi, Expr, RBrack }\n+        struct SliceType { LBrack, TypeRef, RBrack }\n+        struct ReferenceType { Amp, Lifetime, MutKw, TypeRef }\n+        struct PlaceholderType { Underscore }\n+        struct FnPointerType { Abi, UnsafeKw, FnKw, ParamList, RetType }\n+        struct ForType { ForKw, TypeParamList, TypeRef }\n+        struct ImplTraitType: TypeBoundsOwner { ImplKw }\n+        struct DynTraitType: TypeBoundsOwner { DynKw }\n+\n+        struct TupleExpr: AttrsOwner { LParen, exprs: [Expr], RParen }\n+        struct ArrayExpr: AttrsOwner { LBrack, exprs: [Expr], Semi, RBrack }\n+        struct ParenExpr: AttrsOwner { LParen, Expr, RParen }\n         struct PathExpr  { Path }\n-        struct LambdaExpr {\n+        struct LambdaExpr: AttrsOwner {\n+            StaticKw,\n+            AsyncKw,\n+            MoveKw,\n             ParamList,\n             RetType,\n             body: Expr,\n         }\n-        struct IfExpr { Condition }\n-        struct LoopExpr: LoopBodyOwner { }\n-        struct TryBlockExpr { body: BlockExpr }\n-        struct ForExpr: LoopBodyOwner {\n+        struct IfExpr: AttrsOwner { IfKw, Condition }\n+        struct LoopExpr: AttrsOwner, LoopBodyOwner { LoopKw }\n+        struct TryBlockExpr: AttrsOwner { TryKw, body: BlockExpr }\n+        struct ForExpr: AttrsOwner, LoopBodyOwner {\n+            ForKw,\n             Pat,\n+            InKw,\n             iterable: Expr,\n         }\n-        struct WhileExpr: LoopBodyOwner { Condition }\n-        struct ContinueExpr {}\n-        struct BreakExpr { Expr }\n-        struct Label {}\n-        struct BlockExpr { Block  }\n-        struct ReturnExpr { Expr }\n+        struct WhileExpr: AttrsOwner, LoopBodyOwner { WhileKw, Condition }\n+        struct ContinueExpr: AttrsOwner { ContinueKw, Lifetime }\n+        struct BreakExpr: AttrsOwner { BreakKw, Lifetime, Expr }\n+        struct Label { Lifetime }\n+        struct BlockExpr: AttrsOwner { Label, UnsafeKw, Block  }\n+        struct ReturnExpr: AttrsOwner { Expr }\n         struct CallExpr: ArgListOwner { Expr }\n-        struct MethodCallExpr: ArgListOwner {\n-            Expr, NameRef, TypeArgList,\n-        }\n-        struct IndexExpr {}\n-        struct FieldExpr { Expr, NameRef }\n-        struct AwaitExpr { Expr }\n-        struct TryExpr { Expr }\n-        struct CastExpr { Expr, TypeRef }\n-        struct RefExpr { Expr }\n-        struct PrefixExpr { Expr }\n-        struct BoxExpr { Expr }\n-        struct RangeExpr {}\n-        struct BinExpr {}\n-        struct Literal {}\n-\n-        struct MatchExpr { Expr, MatchArmList }\n-        struct MatchArmList: AttrsOwner { arms: [MatchArm] }\n+        struct MethodCallExpr: AttrsOwner, ArgListOwner {\n+            Expr, Dot, NameRef, TypeArgList,\n+        }\n+        struct IndexExpr: AttrsOwner { LBrack, RBrack }\n+        struct FieldExpr: AttrsOwner { Expr, Dot, NameRef }\n+        struct AwaitExpr: AttrsOwner { Expr, Dot, AwaitKw }\n+        struct TryExpr: AttrsOwner { TryKw, Expr }\n+        struct CastExpr: AttrsOwner { Expr, AsKw, TypeRef }\n+        struct RefExpr: AttrsOwner { Amp, RawKw, MutKw, Expr }\n+        struct PrefixExpr: AttrsOwner { PrefixOp, Expr }\n+        struct BoxExpr: AttrsOwner { BoxKw, Expr }\n+        struct RangeExpr: AttrsOwner { RangeOp }\n+        struct BinExpr: AttrsOwner { BinOp }\n+        struct Literal { LiteralToken }\n+\n+        struct MatchExpr: AttrsOwner { MatchKw, Expr, MatchArmList }\n+        struct MatchArmList: AttrsOwner { LCurly, arms: [MatchArm], RCurly }\n         struct MatchArm: AttrsOwner {\n             pat: Pat,\n             guard: MatchGuard,\n+            FatArrow,\n             Expr,\n         }\n-        struct MatchGuard { Expr }\n+        struct MatchGuard { IfKw, Expr }\n \n-        struct RecordLit { Path, RecordFieldList }\n+        struct RecordLit { Path, RecordFieldList}\n         struct RecordFieldList {\n+            LCurly,\n             fields: [RecordField],\n+            Dotdot,\n             spread: Expr,\n+            RCurly\n         }\n-        struct RecordField { NameRef, Expr }\n+        struct RecordField: AttrsOwner { NameRef, Colon, Expr }\n \n         struct OrPat { pats: [Pat] }\n-        struct ParenPat { Pat }\n-        struct RefPat { Pat }\n-        struct BoxPat { Pat }\n-        struct BindPat: NameOwner { Pat }\n-        struct PlaceholderPat { }\n-        struct DotDotPat { }\n+        struct ParenPat { LParen, Pat, RParen }\n+        struct RefPat { Amp, MutKw, Pat }\n+        struct BoxPat { BoxKw, Pat }\n+        struct BindPat: AttrsOwner, NameOwner { RefKw, MutKw, Pat }\n+        struct PlaceholderPat { Underscore }\n+        struct DotDotPat { Dotdot }\n         struct PathPat { Path }\n-        struct SlicePat { args: [Pat] }\n-        struct RangePat {}\n+        struct SlicePat { LBrack, args: [Pat], RBrack }\n+        struct RangePat { RangeSeparator }\n         struct LiteralPat { Literal }\n         struct MacroPat { MacroCall }\n \n         struct RecordPat { RecordFieldPatList, Path }\n         struct RecordFieldPatList {\n+            LCurly,\n+            pats: [RecordInnerPat],\n             record_field_pats: [RecordFieldPat],\n             bind_pats: [BindPat],\n+            Dotdot,\n+            RCurly\n         }\n-        struct RecordFieldPat: NameOwner { Pat }\n+        struct RecordFieldPat: AttrsOwner, NameOwner { Colon, Pat }\n \n-        struct TupleStructPat { Path, args: [Pat] }\n-        struct TuplePat { args: [Pat] }\n+        struct TupleStructPat { Path, LParen, args: [Pat], RParen }\n+        struct TuplePat { LParen, args: [Pat], RParen }\n \n-        struct Visibility {}\n-        struct Name {}\n-        struct NameRef {}\n+        struct Visibility { PubKw, SuperKw, SelfKw, CrateKw }\n+        struct Name { Ident }\n+        struct NameRef { NameRefToken }\n \n         struct MacroCall: NameOwner, AttrsOwner,DocCommentsOwner {\n-            TokenTree, Path\n+            Path, Excl, TokenTree, Semi\n         }\n-        struct Attr { Path, input: AttrInput }\n+        struct Attr { Pound, Excl, LBrack, Path, Eq, input: AttrInput, RBrack }\n         struct TokenTree {}\n         struct TypeParamList {\n+            LAngle,\n+            generic_params: [GenericParam],\n             type_params: [TypeParam],\n             lifetime_params: [LifetimeParam],\n+            const_params: [ConstParam],\n+            RAngle\n         }\n         struct TypeParam: NameOwner, AttrsOwner, TypeBoundsOwner {\n+            Eq,\n             default_type: TypeRef,\n         }\n         struct ConstParam: NameOwner, AttrsOwner, TypeAscriptionOwner {\n+            Eq,\n             default_val: Expr,\n         }\n-        struct LifetimeParam: AttrsOwner { }\n-        struct TypeBound { TypeRef}\n+        struct LifetimeParam: AttrsOwner { Lifetime}\n+        struct TypeBound { Lifetime, /* Question,  */ ConstKw, /* Question,  */ TypeRef}\n         struct TypeBoundList { bounds: [TypeBound] }\n-        struct WherePred: TypeBoundsOwner { TypeRef }\n-        struct WhereClause { predicates: [WherePred] }\n-        struct ExprStmt { Expr }\n-        struct LetStmt: TypeAscriptionOwner {\n+        struct WherePred: TypeBoundsOwner { Lifetime, TypeRef }\n+        struct WhereClause { WhereKw, predicates: [WherePred] }\n+        struct Abi { String }\n+        struct ExprStmt: AttrsOwner { Expr, Semi }\n+        struct LetStmt: AttrsOwner, TypeAscriptionOwner {\n+            LetKw,\n             Pat,\n+            Eq,\n             initializer: Expr,\n         }\n-        struct Condition { Pat, Expr }\n+        struct Condition { LetKw, Pat, Eq, Expr }\n         struct Block: AttrsOwner, ModuleItemOwner {\n+            LCurly,\n             statements: [Stmt],\n             Expr,\n+            RCurly,\n         }\n         struct ParamList {\n+            LParen,\n             SelfParam,\n             params: [Param],\n+            RParen\n         }\n-        struct SelfParam: TypeAscriptionOwner, AttrsOwner { }\n+        struct SelfParam: TypeAscriptionOwner, AttrsOwner { Amp, Lifetime, SelfKw }\n         struct Param: TypeAscriptionOwner, AttrsOwner {\n             Pat,\n+            Dotdotdot\n         }\n         struct UseItem: AttrsOwner, VisibilityOwner {\n+            UseKw,\n             UseTree,\n         }\n         struct UseTree {\n-            Path, UseTreeList, Alias\n+            Path, Star, UseTreeList, Alias\n         }\n-        struct Alias: NameOwner { }\n-        struct UseTreeList { use_trees: [UseTree] }\n+        struct Alias: NameOwner { AsKw }\n+        struct UseTreeList { LCurly, use_trees: [UseTree], RCurly }\n         struct ExternCrateItem: AttrsOwner, VisibilityOwner {\n-            NameRef, Alias,\n+            ExternKw, CrateKw, NameRef, Alias,\n         }\n         struct ArgList {\n+            LParen,\n             args: [Expr],\n+            RParen\n         }\n         struct Path {\n             segment: PathSegment,\n             qualifier: Path,\n         }\n         struct PathSegment {\n-            NameRef, TypeArgList, ParamList, RetType, PathType,\n+            Coloncolon, LAngle, NameRef, TypeArgList, ParamList, RetType, PathType, RAngle\n         }\n         struct TypeArgList {\n+            Coloncolon,\n+            LAngle,\n+            generic_args: [GenericArg],\n             type_args: [TypeArg],\n             lifetime_args: [LifetimeArg],\n             assoc_type_args: [AssocTypeArg],\n-            const_arg: [ConstArg],\n+            const_args: [ConstArg],\n+            RAngle\n         }\n         struct TypeArg { TypeRef }\n-        struct AssocTypeArg { NameRef, TypeRef }\n-        struct LifetimeArg {}\n-        struct ConstArg { Literal, BlockExpr }\n+        struct AssocTypeArg : TypeBoundsOwner { NameRef, Eq, TypeRef }\n+        struct LifetimeArg { Lifetime }\n+        struct ConstArg { Literal, Eq, BlockExpr }\n \n         struct MacroItems: ModuleItemOwner, FnDefOwner { }\n \n         struct MacroStmts {\n             statements: [Stmt],\n             Expr,\n         }\n+\n+        struct ExternItemList: FnDefOwner, ModuleItemOwner {\n+            LCurly,\n+            extern_items: [ExternItem],\n+            RCurly\n+        }\n+\n+        struct ExternBlock {\n+            Abi,\n+            ExternItemList\n+        }\n+\n+        struct MetaItem {\n+            Path, Eq, AttrInput, nested_meta_items: [MetaItem]\n+        }\n+\n+        struct MacroDef {\n+            Name, TokenTree\n+        }\n     },\n     enums: &ast_enums! {\n         enum NominalDef: NameOwner, TypeParamsOwner, AttrsOwner {\n             StructDef, EnumDef, UnionDef,\n         }\n \n+        enum GenericParam {\n+            LifetimeParam,\n+            TypeParam,\n+            ConstParam\n+        }\n+\n+        enum GenericArg {\n+            LifetimeArg,\n+            TypeArg,\n+            ConstArg,\n+            AssocTypeArg\n+        }\n+\n         enum TypeRef {\n             ParenType,\n             TupleType,\n@@ -555,7 +662,7 @@ pub(crate) const AST_SRC: AstSrc = AstSrc {\n             DynTraitType,\n         }\n \n-        enum ModuleItem: AttrsOwner, VisibilityOwner {\n+        enum ModuleItem: NameOwner, AttrsOwner, VisibilityOwner {\n             StructDef,\n             UnionDef,\n             EnumDef,\n@@ -569,13 +676,20 @@ pub(crate) const AST_SRC: AstSrc = AstSrc {\n             StaticDef,\n             Module,\n             MacroCall,\n+            ExternBlock\n+        }\n+\n+        /* impl blocks can also contain MacroCall */\n+        enum ImplItem: NameOwner, AttrsOwner {\n+            FnDef, TypeAliasDef, ConstDef\n         }\n \n-        enum ImplItem: AttrsOwner {\n-            FnDef, TypeAliasDef, ConstDef,\n+        /* extern blocks can also contain MacroCall */\n+        enum ExternItem: NameOwner, AttrsOwner, VisibilityOwner {\n+            FnDef, StaticDef\n         }\n \n-        enum Expr {\n+        enum Expr: AttrsOwner {\n             TupleExpr,\n             ArrayExpr,\n             ParenExpr,\n@@ -627,7 +741,86 @@ pub(crate) const AST_SRC: AstSrc = AstSrc {\n             MacroPat,\n         }\n \n+        enum RecordInnerPat {\n+            RecordFieldPat,\n+            BindPat\n+        }\n+\n         enum AttrInput { Literal, TokenTree }\n-        enum Stmt { ExprStmt, LetStmt }\n+        enum Stmt {\n+            LetStmt,\n+            ExprStmt,\n+            // macro calls are parsed as expression statements */\n+        }\n+\n+        enum LeftDelimiter { LParen, LBrack, LCurly }\n+        enum RightDelimiter { RParen, RBrack, RCurly }\n+        enum RangeSeparator { Dotdot, Dotdotdot, Dotdoteq}\n+\n+        enum BinOp {\n+            Pipepipe,\n+            Ampamp,\n+            Eqeq,\n+            Neq,\n+            Lteq,\n+            Gteq,\n+            LAngle,\n+            RAngle,\n+            Plus,\n+            Star,\n+            Minus,\n+            Slash,\n+            Percent,\n+            Shl,\n+            Shr,\n+            Caret,\n+            Pipe,\n+            Amp,\n+            Eq,\n+            Pluseq,\n+            Slasheq,\n+            Stareq,\n+            Percenteq,\n+            Shreq,\n+            Shleq,\n+            Minuseq,\n+            Pipeeq,\n+            Ampeq,\n+            Careteq,\n+        }\n+\n+        enum PrefixOp {\n+            Minus,\n+            Excl,\n+            Star\n+        }\n+\n+        enum RangeOp {\n+            Dotdot,\n+            Dotdoteq\n+        }\n+\n+        enum LiteralToken {\n+            IntNumber,\n+            FloatNumber,\n+            String,\n+            RawString,\n+            TrueKw,\n+            FalseKw,\n+            ByteString,\n+            RawByteString,\n+            Char,\n+            Byte\n+        }\n+\n+        enum NameRefToken {\n+            Ident,\n+            IntNumber\n+        }\n+\n+        enum FieldDefList {\n+            RecordFieldDefList,\n+            TupleFieldDefList,\n+        }\n     },\n };"}, {"sha": "6dae93aa22064c8af8fdd2ccf42f9645493933ae", "filename": "xtask/src/codegen/gen_syntax.rs", "status": "modified", "additions": 58, "deletions": 29, "changes": 87, "blob_url": "https://github.com/rust-lang/rust/blob/cfc127f52988cf4f95797cb355398e3af32632aa/xtask%2Fsrc%2Fcodegen%2Fgen_syntax.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cfc127f52988cf4f95797cb355398e3af32632aa/xtask%2Fsrc%2Fcodegen%2Fgen_syntax.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/xtask%2Fsrc%2Fcodegen%2Fgen_syntax.rs?ref=cfc127f52988cf4f95797cb355398e3af32632aa", "patch": "@@ -146,14 +146,23 @@ fn generate_ast(kinds: KindsSrc<'_>, grammar: AstSrc<'_>) -> Result<String> {\n                 FieldSrc::Many(_) => {\n                     quote! {\n                         pub fn #method_name(&self) -> AstChildren<#ty> {\n-                            AstChildren::new(&self.syntax)\n+                            support::children(&self.syntax)\n                         }\n                     }\n                 }\n                 FieldSrc::Optional(_) | FieldSrc::Shorthand => {\n-                    quote! {\n-                        pub fn #method_name(&self) -> Option<#ty> {\n-                            AstChildren::new(&self.syntax).next()\n+                    let is_token = element_kinds_map[&ty.to_string()].has_tokens;\n+                    if is_token {\n+                        quote! {\n+                            pub fn #method_name(&self) -> Option<#ty> {\n+                                support::token(&self.syntax)\n+                            }\n+                        }\n+                    } else {\n+                        quote! {\n+                            pub fn #method_name(&self) -> Option<#ty> {\n+                                support::child(&self.syntax)\n+                            }\n                         }\n                     }\n                 }\n@@ -205,6 +214,48 @@ fn generate_ast(kinds: KindsSrc<'_>, grammar: AstSrc<'_>) -> Result<String> {\n             quote!(impl ast::#trait_name for #name {})\n         });\n \n+        let element_kinds = &element_kinds_map[&en.name.to_string()];\n+        assert!(\n+            element_kinds.has_nodes ^ element_kinds.has_tokens,\n+            \"{}: {:#?}\",\n+            name,\n+            element_kinds\n+        );\n+        let specific_ast_trait = {\n+            let (ast_trait, syntax_type) = if element_kinds.has_tokens {\n+                (quote!(AstToken), quote!(SyntaxToken))\n+            } else {\n+                (quote!(AstNode), quote!(SyntaxNode))\n+            };\n+\n+            quote! {\n+                impl #ast_trait for #name {\n+                    fn can_cast(kind: SyntaxKind) -> bool {\n+                        match kind {\n+                            #(#kinds)|* => true,\n+                            _ => false,\n+                        }\n+                    }\n+                    fn cast(syntax: #syntax_type) -> Option<Self> {\n+                        let res = match syntax.kind() {\n+                            #(\n+                            #kinds => #name::#variants(#variants { syntax }),\n+                            )*\n+                            _ => return None,\n+                        };\n+                        Some(res)\n+                    }\n+                    fn syntax(&self) -> &#syntax_type {\n+                        match self {\n+                            #(\n+                            #name::#variants(it) => &it.syntax,\n+                            )*\n+                        }\n+                    }\n+                }\n+            }\n+        };\n+\n         quote! {\n             #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n             pub enum #name {\n@@ -225,30 +276,8 @@ fn generate_ast(kinds: KindsSrc<'_>, grammar: AstSrc<'_>) -> Result<String> {\n                 }\n             }\n \n-            impl AstNode for #name {\n-                fn can_cast(kind: SyntaxKind) -> bool {\n-                    match kind {\n-                        #(#kinds)|* => true,\n-                        _ => false,\n-                    }\n-                }\n-                fn cast(syntax: SyntaxNode) -> Option<Self> {\n-                    let res = match syntax.kind() {\n-                        #(\n-                        #kinds => #name::#variants(#variants { syntax }),\n-                        )*\n-                        _ => return None,\n-                    };\n-                    Some(res)\n-                }\n-                fn syntax(&self) -> &SyntaxNode {\n-                    match self {\n-                        #(\n-                        #name::#variants(it) => &it.syntax,\n-                        )*\n-                    }\n-                }\n-            }\n+            #specific_ast_trait\n+\n             #(#traits)*\n         }\n     });\n@@ -268,7 +297,7 @@ fn generate_ast(kinds: KindsSrc<'_>, grammar: AstSrc<'_>) -> Result<String> {\n         #[allow(unused_imports)]\n         use crate::{\n             SyntaxNode, SyntaxToken, SyntaxElement, NodeOrToken, SyntaxKind::{self, *},\n-            ast::{self, AstNode, AstToken, AstChildren},\n+            ast::{self, AstNode, AstToken, AstChildren, support},\n         };\n \n         #(#tokens)*"}]}