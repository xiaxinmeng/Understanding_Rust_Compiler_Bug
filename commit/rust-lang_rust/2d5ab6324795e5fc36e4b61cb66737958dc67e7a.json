{"sha": "2d5ab6324795e5fc36e4b61cb66737958dc67e7a", "node_id": "MDY6Q29tbWl0NzI0NzEyOjJkNWFiNjMyNDc5NWU1ZmMzNmU0YjYxY2I2NjczNzk1OGRjNjdlN2E=", "commit": {"author": {"name": "Florian Diebold", "email": "flodiebold@gmail.com", "date": "2020-02-21T20:49:02Z"}, "committer": {"name": "Florian Diebold", "email": "flodiebold@gmail.com", "date": "2020-02-22T10:09:21Z"}, "message": "Add &dyn Trait -> &dyn SuperTrait coercion, and fix &T -> &dyn Trait", "tree": {"sha": "2027747769d99c7733ac4f4366ccffd4fcf4983f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2027747769d99c7733ac4f4366ccffd4fcf4983f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2d5ab6324795e5fc36e4b61cb66737958dc67e7a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2d5ab6324795e5fc36e4b61cb66737958dc67e7a", "html_url": "https://github.com/rust-lang/rust/commit/2d5ab6324795e5fc36e4b61cb66737958dc67e7a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2d5ab6324795e5fc36e4b61cb66737958dc67e7a/comments", "author": {"login": "flodiebold", "id": 906069, "node_id": "MDQ6VXNlcjkwNjA2OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/906069?v=4", "gravatar_id": "", "url": "https://api.github.com/users/flodiebold", "html_url": "https://github.com/flodiebold", "followers_url": "https://api.github.com/users/flodiebold/followers", "following_url": "https://api.github.com/users/flodiebold/following{/other_user}", "gists_url": "https://api.github.com/users/flodiebold/gists{/gist_id}", "starred_url": "https://api.github.com/users/flodiebold/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/flodiebold/subscriptions", "organizations_url": "https://api.github.com/users/flodiebold/orgs", "repos_url": "https://api.github.com/users/flodiebold/repos", "events_url": "https://api.github.com/users/flodiebold/events{/privacy}", "received_events_url": "https://api.github.com/users/flodiebold/received_events", "type": "User", "site_admin": false}, "committer": {"login": "flodiebold", "id": 906069, "node_id": "MDQ6VXNlcjkwNjA2OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/906069?v=4", "gravatar_id": "", "url": "https://api.github.com/users/flodiebold", "html_url": "https://github.com/flodiebold", "followers_url": "https://api.github.com/users/flodiebold/followers", "following_url": "https://api.github.com/users/flodiebold/following{/other_user}", "gists_url": "https://api.github.com/users/flodiebold/gists{/gist_id}", "starred_url": "https://api.github.com/users/flodiebold/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/flodiebold/subscriptions", "organizations_url": "https://api.github.com/users/flodiebold/orgs", "repos_url": "https://api.github.com/users/flodiebold/repos", "events_url": "https://api.github.com/users/flodiebold/events{/privacy}", "received_events_url": "https://api.github.com/users/flodiebold/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f126808b2ee79792631edc377bc8c2b0f329eebf", "url": "https://api.github.com/repos/rust-lang/rust/commits/f126808b2ee79792631edc377bc8c2b0f329eebf", "html_url": "https://github.com/rust-lang/rust/commit/f126808b2ee79792631edc377bc8c2b0f329eebf"}], "stats": {"total": 176, "additions": 132, "deletions": 44}, "files": [{"sha": "2f2d3080ec9067ed0558960249af5636f0c43b9a", "filename": "crates/ra_hir_ty/src/lib.rs", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/2d5ab6324795e5fc36e4b61cb66737958dc67e7a/crates%2Fra_hir_ty%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2d5ab6324795e5fc36e4b61cb66737958dc67e7a/crates%2Fra_hir_ty%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Flib.rs?ref=2d5ab6324795e5fc36e4b61cb66737958dc67e7a", "patch": "@@ -461,6 +461,12 @@ impl<T> Binders<T> {\n     }\n }\n \n+impl<T: Clone> Binders<&T> {\n+    pub fn cloned(&self) -> Binders<T> {\n+        Binders { num_binders: self.num_binders, value: self.value.clone() }\n+    }\n+}\n+\n impl<T: TypeWalk> Binders<T> {\n     /// Substitutes all variables.\n     pub fn subst(self, subst: &Substs) -> T {\n@@ -757,6 +763,20 @@ pub trait TypeWalk {\n     /// variable for the self type.\n     fn walk_mut_binders(&mut self, f: &mut impl FnMut(&mut Ty, usize), binders: usize);\n \n+    fn fold_binders(mut self, f: &mut impl FnMut(Ty, usize) -> Ty, binders: usize) -> Self\n+    where\n+        Self: Sized,\n+    {\n+        self.walk_mut_binders(\n+            &mut |ty_mut, binders| {\n+                let ty = mem::replace(ty_mut, Ty::Unknown);\n+                *ty_mut = f(ty, binders);\n+            },\n+            binders,\n+        );\n+        self\n+    }\n+\n     fn fold(mut self, f: &mut impl FnMut(Ty) -> Ty) -> Self\n     where\n         Self: Sized,"}, {"sha": "5594ed394f8246b7bb7d69c8acb461d52b07869e", "filename": "crates/ra_hir_ty/src/tests/coercion.rs", "status": "modified", "additions": 26, "deletions": 14, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/2d5ab6324795e5fc36e4b61cb66737958dc67e7a/crates%2Fra_hir_ty%2Fsrc%2Ftests%2Fcoercion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2d5ab6324795e5fc36e4b61cb66737958dc67e7a/crates%2Fra_hir_ty%2Fsrc%2Ftests%2Fcoercion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Ftests%2Fcoercion.rs?ref=2d5ab6324795e5fc36e4b61cb66737958dc67e7a", "patch": "@@ -587,25 +587,37 @@ pub trait CoerceUnsized<T> {}\n \n impl<T: Unsize<U>, U> CoerceUnsized<&U> for &T {}\n \n-trait Foo {}\n-trait Bar: Foo {}\n-struct S;\n-impl Foo for S {}\n-impl Bar for S {}\n+trait Foo<T, U> {}\n+trait Bar<U, T, X>: Foo<T, U> {}\n+trait Baz<T, X>: Bar<usize, T, X> {}\n+\n+struct S<T, X>;\n+impl<T, X> Foo<T, usize> for S<T, X> {}\n+impl<T, X> Bar<usize, T, X> for S<T, X> {}\n+impl<T, X> Baz<T, X> for S<T, X> {}\n \n fn test() {\n-    let obj: &dyn Bar = &S;\n-    let obj: &dyn Foo = obj;\n+    let obj: &dyn Baz<i8, i16> = &S;\n+    let obj: &dyn Bar<_, _, _> = obj;\n+    let obj: &dyn Foo<_, _> = obj;\n+    let obj2: &dyn Baz<i8, i16> = &S;\n+    let _: &dyn Foo<_, _> = obj2;\n }\n \"#, true),\n         @r###\"\n-    [240; 300) '{     ...obj; }': ()\n-    [250; 253) 'obj': &dyn Bar\n-    [266; 268) '&S': &S\n-    [267; 268) 'S': S\n-    [278; 281) 'obj': &dyn Foo\n-    [294; 297) 'obj': &dyn Bar\n-    [294; 297): expected &dyn Foo, got &dyn Bar\n+    [388; 573) '{     ...bj2; }': ()\n+    [398; 401) 'obj': &dyn Baz<i8, i16>\n+    [423; 425) '&S': &S<i8, i16>\n+    [424; 425) 'S': S<i8, i16>\n+    [435; 438) 'obj': &dyn Bar<usize, i8, i16>\n+    [460; 463) 'obj': &dyn Baz<i8, i16>\n+    [473; 476) 'obj': &dyn Foo<i8, usize>\n+    [495; 498) 'obj': &dyn Bar<usize, i8, i16>\n+    [508; 512) 'obj2': &dyn Baz<i8, i16>\n+    [534; 536) '&S': &S<i8, i16>\n+    [535; 536) 'S': S<i8, i16>\n+    [546; 547) '_': &dyn Foo<i8, usize>\n+    [566; 570) 'obj2': &dyn Baz<i8, i16>\n     \"###\n     );\n }"}, {"sha": "19e533cee14754435a4b61e3e41b0365b3f1fccd", "filename": "crates/ra_hir_ty/src/traits/builtin.rs", "status": "modified", "additions": 65, "deletions": 30, "changes": 95, "blob_url": "https://github.com/rust-lang/rust/blob/2d5ab6324795e5fc36e4b61cb66737958dc67e7a/crates%2Fra_hir_ty%2Fsrc%2Ftraits%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2d5ab6324795e5fc36e4b61cb66737958dc67e7a/crates%2Fra_hir_ty%2Fsrc%2Ftraits%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Ftraits%2Fbuiltin.rs?ref=2d5ab6324795e5fc36e4b61cb66737958dc67e7a", "patch": "@@ -8,7 +8,7 @@ use super::{AssocTyValue, Impl, UnsizeToSuperTraitObjectData};\n use crate::{\n     db::HirDatabase,\n     utils::{all_super_traits, generics},\n-    ApplicationTy, GenericPredicate, Substs, TraitRef, Ty, TypeCtor,\n+    ApplicationTy, Binders, GenericPredicate, Substs, TraitRef, Ty, TypeCtor,\n };\n \n pub(super) struct BuiltinImplData {\n@@ -72,20 +72,25 @@ fn get_builtin_unsize_impls(\n \n     if let Ty::Apply(ApplicationTy { ctor: TypeCtor::Array, .. }) = ty {\n         callback(Impl::UnsizeArray);\n+        return; // array is unsized, the rest of the impls shouldn't apply\n     }\n \n     if let Some(target_trait) = arg.as_ref().and_then(|t| t.dyn_trait_ref()) {\n+        // FIXME what about more complicated dyn tys with marker traits?\n         if let Some(trait_ref) = ty.dyn_trait_ref() {\n-            let super_traits = all_super_traits(db, trait_ref.trait_);\n-            if super_traits.contains(&target_trait.trait_) {\n-                // callback(Impl::UnsizeToSuperTraitObject(UnsizeToSuperTraitObjectData {\n-                //     trait_: trait_ref.trait_,\n-                //     super_trait: target_trait.trait_,\n-                // }));\n+            if trait_ref.trait_ != target_trait.trait_ {\n+                let super_traits = all_super_traits(db, trait_ref.trait_);\n+                if super_traits.contains(&target_trait.trait_) {\n+                    callback(Impl::UnsizeToSuperTraitObject(UnsizeToSuperTraitObjectData {\n+                        trait_: trait_ref.trait_,\n+                        super_trait: target_trait.trait_,\n+                    }));\n+                }\n             }\n+        } else {\n+            // FIXME only for sized types\n+            callback(Impl::UnsizeToTraitObject(target_trait.trait_));\n         }\n-\n-        callback(Impl::UnsizeToTraitObject(target_trait.trait_));\n     }\n }\n \n@@ -270,48 +275,78 @@ fn trait_object_unsize_impl_datum(\n \n     let self_ty = Ty::Bound(0);\n \n-    let substs = Substs::build_for_def(db, trait_)\n-        // this fits together nicely: $0 is our self type, and the rest are the type\n-        // args for the trait\n-        .fill_with_bound_vars(0)\n+    let target_substs = Substs::build_for_def(db, trait_)\n+        .push(Ty::Bound(0))\n+        // starting from ^2 because we want to start with ^1 outside of the\n+        // `dyn`, which is ^2 inside\n+        .fill_with_bound_vars(2)\n         .build();\n-    let trait_ref = TraitRef { trait_, substs };\n-    // This is both the bound for the `dyn` type, *and* the bound for the impl!\n-    // This works because the self type for `dyn` is always Ty::Bound(0), which\n-    // we've also made the parameter for our impl self type.\n-    let bounds = vec![GenericPredicate::Implemented(trait_ref)];\n+    let num_vars = target_substs.len();\n+    let target_trait_ref = TraitRef { trait_, substs: target_substs };\n+    let target_bounds = vec![GenericPredicate::Implemented(target_trait_ref)];\n \n-    let impl_substs = Substs::builder(2).push(self_ty).push(Ty::Dyn(bounds.clone().into())).build();\n+    let self_substs = Substs::build_for_def(db, trait_).fill_with_bound_vars(0).build();\n+    let self_trait_ref = TraitRef { trait_, substs: self_substs };\n+    let where_clauses = vec![GenericPredicate::Implemented(self_trait_ref)];\n+\n+    let impl_substs =\n+        Substs::builder(2).push(self_ty).push(Ty::Dyn(target_bounds.clone().into())).build();\n \n     let trait_ref = TraitRef { trait_: unsize_trait, substs: impl_substs };\n \n-    BuiltinImplData { num_vars: 1, trait_ref, where_clauses: bounds, assoc_ty_values: Vec::new() }\n+    BuiltinImplData { num_vars, trait_ref, where_clauses, assoc_ty_values: Vec::new() }\n }\n \n fn super_trait_object_unsize_impl_datum(\n     db: &impl HirDatabase,\n     krate: CrateId,\n-    _data: UnsizeToSuperTraitObjectData,\n+    data: UnsizeToSuperTraitObjectData,\n ) -> BuiltinImplData {\n-    // impl Unsize<dyn SuperTrait> for dyn Trait\n+    // impl<T1, ...> Unsize<dyn SuperTrait> for dyn Trait<T1, ...>\n \n     let unsize_trait = get_unsize_trait(db, krate) // get unsize trait\n         // the existence of the Unsize trait has been checked before\n         .expect(\"Unsize trait missing\");\n \n+    let self_substs = Substs::build_for_def(db, data.trait_).fill_with_bound_vars(0).build();\n+\n+    let num_vars = self_substs.len() - 1;\n+\n+    let self_trait_ref = TraitRef { trait_: data.trait_, substs: self_substs.clone() };\n+    let self_bounds = vec![GenericPredicate::Implemented(self_trait_ref.clone())];\n+\n+    // we need to go from our trait to the super trait, substituting type parameters\n+    let mut path = crate::utils::find_super_trait_path(db, data.super_trait, data.trait_);\n+    path.pop(); // the last one is our current trait, we don't need that\n+    path.reverse(); // we want to go from trait to super trait\n+\n+    let mut current_trait_ref = self_trait_ref;\n+    for t in path {\n+        let bounds = db.generic_predicates(current_trait_ref.trait_.into());\n+        let super_trait_ref = bounds\n+            .iter()\n+            .find_map(|b| match &b.value {\n+                GenericPredicate::Implemented(tr)\n+                    if tr.trait_ == t && tr.substs[0] == Ty::Bound(0) =>\n+                {\n+                    Some(Binders { value: tr, num_binders: b.num_binders })\n+                }\n+                _ => None,\n+            })\n+            .expect(\"trait bound for known super trait not found\");\n+        current_trait_ref = super_trait_ref.cloned().subst(&current_trait_ref.substs);\n+    }\n+\n+    let super_bounds = vec![GenericPredicate::Implemented(current_trait_ref)];\n+\n     let substs = Substs::builder(2)\n-        // .push(Ty::Dyn(todo!()))\n-        // .push(Ty::Dyn(todo!()))\n+        .push(Ty::Dyn(self_bounds.into()))\n+        .push(Ty::Dyn(super_bounds.into()))\n         .build();\n \n     let trait_ref = TraitRef { trait_: unsize_trait, substs };\n \n-    BuiltinImplData {\n-        num_vars: 1,\n-        trait_ref,\n-        where_clauses: Vec::new(),\n-        assoc_ty_values: Vec::new(),\n-    }\n+    BuiltinImplData { num_vars, trait_ref, where_clauses: Vec::new(), assoc_ty_values: Vec::new() }\n }\n \n fn get_fn_trait("}, {"sha": "0d1583c39deccf7e8647214791181e9ec8e9da08", "filename": "crates/ra_hir_ty/src/utils.rs", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/2d5ab6324795e5fc36e4b61cb66737958dc67e7a/crates%2Fra_hir_ty%2Fsrc%2Futils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2d5ab6324795e5fc36e4b61cb66737958dc67e7a/crates%2Fra_hir_ty%2Fsrc%2Futils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Futils.rs?ref=2d5ab6324795e5fc36e4b61cb66737958dc67e7a", "patch": "@@ -62,6 +62,27 @@ pub(super) fn all_super_traits(db: &impl DefDatabase, trait_: TraitId) -> Vec<Tr\n     result\n }\n \n+/// Finds a path from a trait to one of its descendant traits. Returns an empty\n+/// vector if there is no path.\n+pub(super) fn find_super_trait_path(\n+    db: &impl DefDatabase,\n+    super_trait: TraitId,\n+    trait_: TraitId,\n+) -> Vec<TraitId> {\n+    if trait_ == super_trait {\n+        return vec![trait_];\n+    }\n+\n+    for tt in direct_super_traits(db, trait_) {\n+        let mut path = find_super_trait_path(db, super_trait, tt);\n+        if !path.is_empty() {\n+            path.push(trait_);\n+            return path;\n+        }\n+    }\n+    Vec::new()\n+}\n+\n pub(super) fn associated_type_by_name_including_super_traits(\n     db: &impl DefDatabase,\n     trait_: TraitId,"}]}