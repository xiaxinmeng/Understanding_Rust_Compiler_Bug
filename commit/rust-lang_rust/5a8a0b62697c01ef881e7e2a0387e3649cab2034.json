{"sha": "5a8a0b62697c01ef881e7e2a0387e3649cab2034", "node_id": "MDY6Q29tbWl0NzI0NzEyOjVhOGEwYjYyNjk3YzAxZWY4ODFlN2UyYTAzODdlMzY0OWNhYjIwMzQ=", "commit": {"author": {"name": "Dawer", "email": "7803845+iDawer@users.noreply.github.com", "date": "2021-04-30T14:12:04Z"}, "committer": {"name": "Dawer", "email": "7803845+iDawer@users.noreply.github.com", "date": "2021-05-31T19:03:46Z"}, "message": "Check enum patterns", "tree": {"sha": "e534317fe74f4cc90e33c6c7fb66a5e5289e6459", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e534317fe74f4cc90e33c6c7fb66a5e5289e6459"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5a8a0b62697c01ef881e7e2a0387e3649cab2034", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5a8a0b62697c01ef881e7e2a0387e3649cab2034", "html_url": "https://github.com/rust-lang/rust/commit/5a8a0b62697c01ef881e7e2a0387e3649cab2034", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5a8a0b62697c01ef881e7e2a0387e3649cab2034/comments", "author": {"login": "iDawer", "id": 7803845, "node_id": "MDQ6VXNlcjc4MDM4NDU=", "avatar_url": "https://avatars.githubusercontent.com/u/7803845?v=4", "gravatar_id": "", "url": "https://api.github.com/users/iDawer", "html_url": "https://github.com/iDawer", "followers_url": "https://api.github.com/users/iDawer/followers", "following_url": "https://api.github.com/users/iDawer/following{/other_user}", "gists_url": "https://api.github.com/users/iDawer/gists{/gist_id}", "starred_url": "https://api.github.com/users/iDawer/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/iDawer/subscriptions", "organizations_url": "https://api.github.com/users/iDawer/orgs", "repos_url": "https://api.github.com/users/iDawer/repos", "events_url": "https://api.github.com/users/iDawer/events{/privacy}", "received_events_url": "https://api.github.com/users/iDawer/received_events", "type": "User", "site_admin": false}, "committer": {"login": "iDawer", "id": 7803845, "node_id": "MDQ6VXNlcjc4MDM4NDU=", "avatar_url": "https://avatars.githubusercontent.com/u/7803845?v=4", "gravatar_id": "", "url": "https://api.github.com/users/iDawer", "html_url": "https://github.com/iDawer", "followers_url": "https://api.github.com/users/iDawer/followers", "following_url": "https://api.github.com/users/iDawer/following{/other_user}", "gists_url": "https://api.github.com/users/iDawer/gists{/gist_id}", "starred_url": "https://api.github.com/users/iDawer/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/iDawer/subscriptions", "organizations_url": "https://api.github.com/users/iDawer/orgs", "repos_url": "https://api.github.com/users/iDawer/repos", "events_url": "https://api.github.com/users/iDawer/events{/privacy}", "received_events_url": "https://api.github.com/users/iDawer/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b4f41973326a684844ffe23c5816e17d485b4203", "url": "https://api.github.com/repos/rust-lang/rust/commits/b4f41973326a684844ffe23c5816e17d485b4203", "html_url": "https://github.com/rust-lang/rust/commit/b4f41973326a684844ffe23c5816e17d485b4203"}], "stats": {"total": 130, "additions": 124, "deletions": 6}, "files": [{"sha": "3e90461ccd38f68354badae394c5d39d62d6bdaa", "filename": "crates/hir_ty/src/diagnostics/pattern.rs", "status": "modified", "additions": 45, "deletions": 0, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/5a8a0b62697c01ef881e7e2a0387e3649cab2034/crates%2Fhir_ty%2Fsrc%2Fdiagnostics%2Fpattern.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a8a0b62697c01ef881e7e2a0387e3649cab2034/crates%2Fhir_ty%2Fsrc%2Fdiagnostics%2Fpattern.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Fdiagnostics%2Fpattern.rs?ref=5a8a0b62697c01ef881e7e2a0387e3649cab2034", "patch": "@@ -73,6 +73,51 @@ fn main(v: S) {\n     match v {                        }\n         //^ Missing match arm\n }\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn c_enum() {\n+        check_diagnostics(\n+            r#\"\n+enum E { A, B }\n+fn main(v: E) {\n+    match v { E::A | E::B => {} }\n+    match v { _           => {} }\n+    match v { E::A        => {} }\n+        //^ Missing match arm\n+    match v {                   }\n+        //^ Missing match arm\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn enum_() {\n+        check_diagnostics(\n+            r#\"\n+struct A; struct B;\n+enum E { Tuple(A, B), Struct{ a: A, b: B } }\n+fn main(v: E) {\n+    match v {\n+        E::Tuple(a, b)    => {}\n+        E::Struct{ a, b } => {}\n+    }\n+    match v {\n+        E::Tuple(_, _) => {}\n+        E::Struct{..}  => {}\n+    }\n+    match v {\n+        E::Tuple(..) => {}\n+        _ => {}\n+    }\n+    match v { E::Tuple(..) => {} }\n+        //^ Missing match arm\n+    match v { }\n+        //^ Missing match arm\n+}\n \"#,\n         );\n     }"}, {"sha": "3c1811f95ec7d3638769b4322efa5ffe8c2b8f07", "filename": "crates/hir_ty/src/diagnostics/pattern/deconstruct_pat.rs", "status": "modified", "additions": 59, "deletions": 5, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/5a8a0b62697c01ef881e7e2a0387e3649cab2034/crates%2Fhir_ty%2Fsrc%2Fdiagnostics%2Fpattern%2Fdeconstruct_pat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a8a0b62697c01ef881e7e2a0387e3649cab2034/crates%2Fhir_ty%2Fsrc%2Fdiagnostics%2Fpattern%2Fdeconstruct_pat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Fdiagnostics%2Fpattern%2Fdeconstruct_pat.rs?ref=5a8a0b62697c01ef881e7e2a0387e3649cab2034", "patch": "@@ -135,6 +135,7 @@ impl Constructor {\n             Pat::Bind { .. } | Pat::Wild => Wildcard,\n             Pat::Tuple { .. } | Pat::Ref { .. } | Pat::Box { .. } => Single,\n             Pat::Record { .. } | Pat::Path(_) | Pat::TupleStruct { .. } => {\n+                // TODO: path to const\n                 let variant_id =\n                     cx.infer.variant_resolution_for_pat(pat).unwrap_or_else(|| todo!());\n                 match variant_id {\n@@ -144,8 +145,8 @@ impl Constructor {\n             }\n \n             Pat::Or(..) => panic!(\"bug: Or-pattern should have been expanded earlier on.\"),\n+            Pat::Missing => todo!(\"Fail gracefully when there is an error in a pattern\"),\n             pat => todo!(\"Constructor::from_pat {:?}\", pat),\n-            // Pat::Missing => {}\n             // Pat::Range { start, end } => {}\n             // Pat::Slice { prefix, slice, suffix } => {}\n             // Pat::Lit(_) => {}\n@@ -280,7 +281,7 @@ pub(super) struct SplitWildcard {\n \n impl SplitWildcard {\n     pub(super) fn new(pcx: PatCtxt<'_>) -> Self {\n-        // let cx = pcx.cx;\n+        let cx = pcx.cx;\n         // let make_range = |start, end| IntRange(todo!());\n \n         // This determines the set of all possible constructors for the type `pcx.ty`. For numbers,\n@@ -292,9 +293,62 @@ impl SplitWildcard {\n         // Invariant: this is empty if and only if the type is uninhabited (as determined by\n         // `cx.is_uninhabited()`).\n         let all_ctors = match pcx.ty.kind(&Interner) {\n-            TyKind::Adt(AdtId(hir_def::AdtId::EnumId(_)), _) => todo!(),\n+            TyKind::Scalar(Scalar::Bool) => todo!(),\n+            // TyKind::Array(..) if ... => todo!(),\n+            TyKind::Array(..) | TyKind::Slice(..) => todo!(),\n+            &TyKind::Adt(AdtId(hir_def::AdtId::EnumId(enum_id)), ref _substs) => {\n+                let enum_data = cx.db.enum_data(enum_id);\n+\n+                // If the enum is declared as `#[non_exhaustive]`, we treat it as if it had an\n+                // additional \"unknown\" constructor.\n+                // There is no point in enumerating all possible variants, because the user can't\n+                // actually match against them all themselves. So we always return only the fictitious\n+                // constructor.\n+                // E.g., in an example like:\n+                //\n+                // ```\n+                //     let err: io::ErrorKind = ...;\n+                //     match err {\n+                //         io::ErrorKind::NotFound => {},\n+                //     }\n+                // ```\n+                //\n+                // we don't want to show every possible IO error, but instead have only `_` as the\n+                // witness.\n+                let is_declared_nonexhaustive = cx.is_foreign_non_exhaustive_enum(enum_id);\n+\n+                // If `exhaustive_patterns` is disabled and our scrutinee is an empty enum, we treat it\n+                // as though it had an \"unknown\" constructor to avoid exposing its emptiness. The\n+                // exception is if the pattern is at the top level, because we want empty matches to be\n+                // considered exhaustive.\n+                let is_secretly_empty = enum_data.variants.is_empty()\n+                    && !cx.feature_exhaustive_patterns()\n+                    && !pcx.is_top_level;\n+\n+                if is_secretly_empty || is_declared_nonexhaustive {\n+                    smallvec![NonExhaustive]\n+                } else if cx.feature_exhaustive_patterns() {\n+                    // If `exhaustive_patterns` is enabled, we exclude variants known to be\n+                    // uninhabited.\n+                    todo!()\n+                } else {\n+                    enum_data\n+                        .variants\n+                        .iter()\n+                        .map(|(local_id, ..)| Variant(EnumVariantId { parent: enum_id, local_id }))\n+                        .collect()\n+                }\n+            }\n+            TyKind::Scalar(Scalar::Char) => todo!(),\n+            TyKind::Scalar(Scalar::Int(..)) | TyKind::Scalar(Scalar::Uint(..)) => todo!(),\n+            TyKind::Never if !cx.feature_exhaustive_patterns() && !pcx.is_top_level => {\n+                smallvec![NonExhaustive]\n+            }\n+            TyKind::Never => SmallVec::new(),\n+            _ if cx.is_uninhabited(&pcx.ty) => SmallVec::new(),\n             TyKind::Adt(..) | TyKind::Tuple(..) | TyKind::Ref(..) => smallvec![Single],\n-            _ => todo!(),\n+            // This type is one for which we cannot list constructors, like `str` or `f64`.\n+            _ => smallvec![NonExhaustive],\n         };\n         SplitWildcard { matrix_ctors: Vec::new(), all_ctors }\n     }\n@@ -496,7 +550,7 @@ impl Fields {\n     pub(super) fn apply(self, pcx: PatCtxt<'_>, ctor: &Constructor) -> Pat {\n         let subpatterns_and_indices = self.patterns_and_indices();\n         let mut subpatterns = subpatterns_and_indices.iter().map(|&(_, p)| p);\n-        // TODO witnesses are not yet used \n+        // TODO witnesses are not yet used\n         const TODO: Pat = Pat::Wild;\n \n         match ctor {"}, {"sha": "2df87ccea1466c07730831a1ddfd189efc7026a2", "filename": "crates/hir_ty/src/diagnostics/pattern/usefulness.rs", "status": "modified", "additions": 20, "deletions": 1, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/5a8a0b62697c01ef881e7e2a0387e3649cab2034/crates%2Fhir_ty%2Fsrc%2Fdiagnostics%2Fpattern%2Fusefulness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a8a0b62697c01ef881e7e2a0387e3649cab2034/crates%2Fhir_ty%2Fsrc%2Fdiagnostics%2Fpattern%2Fusefulness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Fdiagnostics%2Fpattern%2Fusefulness.rs?ref=5a8a0b62697c01ef881e7e2a0387e3649cab2034", "patch": "@@ -3,7 +3,11 @@\n \n use std::{cell::RefCell, iter::FromIterator, ops::Index, sync::Arc};\n \n-use hir_def::{ModuleId, body::Body, expr::{ExprId, Pat, PatId}};\n+use hir_def::{\n+    body::Body,\n+    expr::{ExprId, Pat, PatId},\n+    HasModule, ModuleId,\n+};\n use la_arena::Arena;\n use once_cell::unsync::OnceCell;\n use rustc_hash::FxHashMap;\n@@ -36,6 +40,21 @@ impl<'a> MatchCheckCtx<'a> {\n         false\n     }\n \n+    /// Returns whether the given type is an enum from another crate declared `#[non_exhaustive]`.\n+    pub(super) fn is_foreign_non_exhaustive_enum(&self, enum_id: hir_def::EnumId) -> bool {\n+        let has_non_exhaustive_attr =\n+            self.db.attrs(enum_id.into()).by_key(\"non_exhaustive\").exists();\n+        let is_local =\n+            hir_def::AdtId::from(enum_id).module(self.db.upcast()).krate() == self.module.krate();\n+        has_non_exhaustive_attr && !is_local\n+    }\n+\n+    // Rust feature described as \"Allows exhaustive pattern matching on types that contain uninhabited types.\"\n+    pub(super) fn feature_exhaustive_patterns(&self) -> bool {\n+        // TODO\n+        false\n+    }\n+\n     pub(super) fn alloc_pat(&self, pat: Pat, ty: &Ty) -> PatId {\n         self.pattern_arena.borrow_mut().alloc(pat, ty)\n     }"}]}