{"sha": "093f99b809d377274e6626a24124caa741ce07f2", "node_id": "C_kwDOAAsO6NoAKDA5M2Y5OWI4MDlkMzc3Mjc0ZTY2MjZhMjQxMjRjYWE3NDFjZTA3ZjI", "commit": {"author": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2021-10-09T10:42:32Z"}, "committer": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2021-10-09T10:42:32Z"}, "message": "internal: start new macro test suite\n\nI don't like our macro tests -- they are brittle and don't inspire\nconfidence. I think the reason for that is that we try to unit-test\nthem, but that is at odds with reality, where macro expansion\nfundamentally depends on name resolution.", "tree": {"sha": "f78bf924264a44d7d44959d805cf486f21b251f8", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f78bf924264a44d7d44959d805cf486f21b251f8"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/093f99b809d377274e6626a24124caa741ce07f2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/093f99b809d377274e6626a24124caa741ce07f2", "html_url": "https://github.com/rust-lang/rust/commit/093f99b809d377274e6626a24124caa741ce07f2", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/093f99b809d377274e6626a24124caa741ce07f2/comments", "author": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "committer": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "545b068a7720374a13e04db24e0bef6237822f2a", "url": "https://api.github.com/repos/rust-lang/rust/commits/545b068a7720374a13e04db24e0bef6237822f2a", "html_url": "https://github.com/rust-lang/rust/commit/545b068a7720374a13e04db24e0bef6237822f2a"}], "stats": {"total": 152, "additions": 90, "deletions": 62}, "files": [{"sha": "7d5f63afd047260bd6677bff9a09d5af5773b57a", "filename": "crates/hir_def/src/lib.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/093f99b809d377274e6626a24124caa741ce07f2/crates%2Fhir_def%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/093f99b809d377274e6626a24124caa741ce07f2/crates%2Fhir_def%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_def%2Fsrc%2Flib.rs?ref=093f99b809d377274e6626a24124caa741ce07f2", "patch": "@@ -49,6 +49,8 @@ pub mod import_map;\n \n #[cfg(test)]\n mod test_db;\n+#[cfg(test)]\n+mod macro_expansion_tests;\n \n use std::{\n     hash::{Hash, Hasher},"}, {"sha": "861a059a14ccecdaf10f5b91cdf344c31fcde75b", "filename": "crates/hir_def/src/macro_expansion_tests.rs", "status": "added", "additions": 87, "deletions": 0, "changes": 87, "blob_url": "https://github.com/rust-lang/rust/blob/093f99b809d377274e6626a24124caa741ce07f2/crates%2Fhir_def%2Fsrc%2Fmacro_expansion_tests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/093f99b809d377274e6626a24124caa741ce07f2/crates%2Fhir_def%2Fsrc%2Fmacro_expansion_tests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_def%2Fsrc%2Fmacro_expansion_tests.rs?ref=093f99b809d377274e6626a24124caa741ce07f2", "patch": "@@ -0,0 +1,87 @@\n+//! This module contains tests for macro expansion. Effectively, it covers `tt`,\n+//! `mbe`, `proc_macro_api` and `hir_expand` crates. This might seem like a\n+//! wrong architecture at the first glance, but is intentional.\n+//!\n+//! Physically, macro expansion process is intertwined with name resolution. You\n+//! can not expand *just* the syntax. So, to be able to write integration tests\n+//! of the \"expand this code please\" form, we have to do it after name\n+//! resolution. That is, in this crate. We *could* fake some dependencies and\n+//! write unit-tests (in fact, we used to do that), but that makes tests brittle\n+//! and harder to understand.\n+\n+use std::ops::Range;\n+\n+use base_db::{fixture::WithFixture, SourceDatabase};\n+use expect_test::{expect, Expect};\n+use hir_expand::{db::AstDatabase, InFile, MacroFile};\n+use stdx::format_to;\n+use syntax::{ast, AstNode};\n+\n+use crate::{\n+    db::DefDatabase, nameres::ModuleSource, resolver::HasResolver, test_db::TestDB, AsMacroCall,\n+};\n+\n+fn check(ra_fixture: &str, expect: Expect) {\n+    let db = TestDB::with_files(ra_fixture);\n+    let krate = db.crate_graph().iter().next().unwrap();\n+    let def_map = db.crate_def_map(krate);\n+    let local_id = def_map.root();\n+    let module = def_map.module_id(local_id);\n+    let resolver = module.resolver(&db);\n+    let source = def_map[local_id].definition_source(&db);\n+    let source_file = match source.value {\n+        ModuleSource::SourceFile(it) => it,\n+        ModuleSource::Module(_) | ModuleSource::BlockExpr(_) => panic!(),\n+    };\n+\n+    let mut expansions = Vec::new();\n+    for macro_call in source_file.syntax().descendants().filter_map(ast::MacroCall::cast) {\n+        let macro_call = InFile::new(source.file_id, &macro_call);\n+        let macro_call_id = macro_call\n+            .as_call_id_with_errors(\n+                &db,\n+                krate,\n+                |path| resolver.resolve_path_as_macro(&db, &path),\n+                &mut |err| panic!(\"{}\", err),\n+            )\n+            .unwrap()\n+            .unwrap();\n+        let macro_file = MacroFile { macro_call_id };\n+        let expansion_result = db.parse_macro_expansion(macro_file);\n+        expansions.push((macro_call.value.clone(), expansion_result));\n+    }\n+\n+    let mut expanded_text = source_file.to_string();\n+    for (call, exp) in expansions.into_iter().rev() {\n+        let mut expn_text = String::new();\n+        if let Some(err) = exp.err {\n+            format_to!(expn_text, \"/* error: {} */\", err);\n+        }\n+        if let Some((parse, _token_map)) = exp.value {\n+            format_to!(expn_text, \"{}\", parse.syntax_node());\n+        }\n+        let range = call.syntax().text_range();\n+        let range: Range<usize> = range.into();\n+        expanded_text.replace_range(range, &expn_text)\n+    }\n+\n+    expect.assert_eq(&expanded_text);\n+}\n+\n+#[test]\n+fn test_expand_rule() {\n+    check(\n+        r#\"\n+macro_rules! m {\n+    ($($i:ident);*) => ($i)\n+}\n+m!{a}\n+\"#,\n+        expect![[r#\"\n+macro_rules! m {\n+    ($($i:ident);*) => ($i)\n+}\n+/* error: expected simple binding, found nested binding `i` */\n+\"#]],\n+    );\n+}"}, {"sha": "ba4ef8b70fe90fb8c627b6400a01076ecf2f3866", "filename": "crates/hir_expand/src/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/093f99b809d377274e6626a24124caa741ce07f2/crates%2Fhir_expand%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/093f99b809d377274e6626a24124caa741ce07f2/crates%2Fhir_expand%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_expand%2Fsrc%2Flib.rs?ref=093f99b809d377274e6626a24124caa741ce07f2", "patch": "@@ -204,7 +204,7 @@ impl HirFileId {\n \n #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n pub struct MacroFile {\n-    macro_call_id: MacroCallId,\n+    pub macro_call_id: MacroCallId,\n }\n \n /// `MacroCallId` identifies a particular macro invocation, like"}, {"sha": "7244d2116101c5dc8da6b60e339954f9f69aea21", "filename": "crates/mbe/src/expander.rs", "status": "modified", "additions": 0, "deletions": 61, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/093f99b809d377274e6626a24124caa741ce07f2/crates%2Fmbe%2Fsrc%2Fexpander.rs", "raw_url": "https://github.com/rust-lang/rust/raw/093f99b809d377274e6626a24124caa741ce07f2/crates%2Fmbe%2Fsrc%2Fexpander.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fmbe%2Fsrc%2Fexpander.rs?ref=093f99b809d377274e6626a24124caa741ce07f2", "patch": "@@ -114,64 +114,3 @@ enum Fragment {\n     /// like `$i * 2` where `$i = 1 + 1` work as expectd.\n     Ast(tt::TokenTree),\n }\n-\n-#[cfg(test)]\n-mod tests {\n-    use syntax::{ast, AstNode};\n-\n-    use super::*;\n-    use crate::syntax_node_to_token_tree;\n-\n-    #[test]\n-    fn test_expand_rule() {\n-        assert_err(\n-            \"($($i:ident);*) => ($i)\",\n-            \"foo!{a}\",\n-            ExpandError::BindingError(String::from(\n-                \"expected simple binding, found nested binding `i`\",\n-            )),\n-        );\n-\n-        // FIXME:\n-        // Add an err test case for ($($i:ident)) => ($())\n-    }\n-\n-    fn assert_err(macro_body: &str, invocation: &str, err: ExpandError) {\n-        assert_eq!(\n-            expand_first(&create_rules(&format_macro(macro_body)), invocation).err,\n-            Some(err)\n-        );\n-    }\n-\n-    fn format_macro(macro_body: &str) -> String {\n-        format!(\n-            \"\n-        macro_rules! foo {{\n-            {}\n-        }}\n-\",\n-            macro_body\n-        )\n-    }\n-\n-    fn create_rules(macro_definition: &str) -> crate::MacroRules {\n-        let source_file = ast::SourceFile::parse(macro_definition).ok().unwrap();\n-        let macro_definition =\n-            source_file.syntax().descendants().find_map(ast::MacroRules::cast).unwrap();\n-\n-        let (definition_tt, _) =\n-            syntax_node_to_token_tree(macro_definition.token_tree().unwrap().syntax());\n-        crate::MacroRules::parse(&definition_tt).unwrap()\n-    }\n-\n-    fn expand_first(rules: &crate::MacroRules, invocation: &str) -> ExpandResult<tt::Subtree> {\n-        let source_file = ast::SourceFile::parse(invocation).ok().unwrap();\n-        let macro_invocation =\n-            source_file.syntax().descendants().find_map(ast::MacroCall::cast).unwrap();\n-\n-        let (invocation_tt, _) =\n-            syntax_node_to_token_tree(macro_invocation.token_tree().unwrap().syntax());\n-\n-        expand_rules(&rules.rules, &invocation_tt)\n-    }\n-}"}]}