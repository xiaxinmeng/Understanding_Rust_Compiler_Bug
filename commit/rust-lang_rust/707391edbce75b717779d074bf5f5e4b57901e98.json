{"sha": "707391edbce75b717779d074bf5f5e4b57901e98", "node_id": "MDY6Q29tbWl0NzI0NzEyOjcwNzM5MWVkYmNlNzViNzE3Nzc5ZDA3NGJmNWY1ZTRiNTc5MDFlOTg=", "commit": {"author": {"name": "Jeff Olson", "email": "olson.jeffery@gmail.com", "date": "2012-04-20T16:08:02Z"}, "committer": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2012-04-20T22:23:23Z"}, "message": "std: add timer::recv_timeout() and whitespace cleanup", "tree": {"sha": "3fba98740ed8549cb1d165a5b5448e405d164e68", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3fba98740ed8549cb1d165a5b5448e405d164e68"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/707391edbce75b717779d074bf5f5e4b57901e98", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/707391edbce75b717779d074bf5f5e4b57901e98", "html_url": "https://github.com/rust-lang/rust/commit/707391edbce75b717779d074bf5f5e4b57901e98", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/707391edbce75b717779d074bf5f5e4b57901e98/comments", "author": {"login": "olsonjeffery", "id": 10408, "node_id": "MDQ6VXNlcjEwNDA4", "avatar_url": "https://avatars.githubusercontent.com/u/10408?v=4", "gravatar_id": "", "url": "https://api.github.com/users/olsonjeffery", "html_url": "https://github.com/olsonjeffery", "followers_url": "https://api.github.com/users/olsonjeffery/followers", "following_url": "https://api.github.com/users/olsonjeffery/following{/other_user}", "gists_url": "https://api.github.com/users/olsonjeffery/gists{/gist_id}", "starred_url": "https://api.github.com/users/olsonjeffery/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/olsonjeffery/subscriptions", "organizations_url": "https://api.github.com/users/olsonjeffery/orgs", "repos_url": "https://api.github.com/users/olsonjeffery/repos", "events_url": "https://api.github.com/users/olsonjeffery/events{/privacy}", "received_events_url": "https://api.github.com/users/olsonjeffery/received_events", "type": "User", "site_admin": false}, "committer": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7ac8c3081c5d4d7b1c79942e426770c1c3e1c0b3", "url": "https://api.github.com/repos/rust-lang/rust/commits/7ac8c3081c5d4d7b1c79942e426770c1c3e1c0b3", "html_url": "https://github.com/rust-lang/rust/commit/7ac8c3081c5d4d7b1c79942e426770c1c3e1c0b3"}], "stats": {"total": 82, "additions": 76, "deletions": 6}, "files": [{"sha": "b1d01424fe39b206a1779f3261d1c8773ff27b9b", "filename": "src/libstd/timer.rs", "status": "modified", "additions": 75, "deletions": 5, "changes": 80, "blob_url": "https://github.com/rust-lang/rust/blob/707391edbce75b717779d074bf5f5e4b57901e98/src%2Flibstd%2Ftimer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/707391edbce75b717779d074bf5f5e4b57901e98/src%2Flibstd%2Ftimer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftimer.rs?ref=707391edbce75b717779d074bf5f5e4b57901e98", "patch": "@@ -3,7 +3,7 @@ Utilities that leverage libuv's `uv_timer_*` API\n \"];\n \n import uv = uv;\n-export delayed_send, sleep;\n+export delayed_send, sleep, recv_timeout;\n \n #[doc = \"\n Wait for timeout period then send provided value over a channel\n@@ -16,9 +16,9 @@ for *at least* that period of time.\n \n # Arguments\n \n-msecs - a timeout period, in milliseconds, to wait\n-ch - a channel of type T to send a `val` on\n-val - a value of type T to send over the provided `ch`\n+* msecs - a timeout period, in milliseconds, to wait\n+* ch - a channel of type T to send a `val` on\n+* val - a value of type T to send over the provided `ch`\n \"]\n fn delayed_send<T: send>(msecs: uint, ch: comm::chan<T>, val: T) {\n     task::spawn() {||\n@@ -80,6 +80,39 @@ fn sleep(msecs: uint) {\n     comm::recv(exit_po);\n }\n \n+#[doc = \"\n+Receive on a port for (up to) a specified time, then return an `option<T>`\n+\n+This call will block to receive on the provided port for up to the specified\n+timeout. Depending on whether the provided port receives in that time period,\n+`recv_timeout` will return an `option<T>` representing the result.\n+\n+# Arguments\n+\n+* msecs - an mount of time, in milliseconds, to wait to receive\n+* wait_port - a `comm::port<T>` to receive on\n+\n+# Returns\n+\n+An `option<T>` representing the outcome of the call. If the call `recv`'d on\n+the provided port in the allotted timeout period, then the result will be a\n+`some(T)`. If not, then `none` will be returned.\n+\"]\n+fn recv_timeout<T: send>(msecs: uint, wait_po: comm::port<T>) -> option<T> {\n+    let timeout_po = comm::port::<()>();\n+    let timeout_ch = comm::chan(timeout_po);\n+    delayed_send(msecs, timeout_ch, ());\n+    either::either(\n+        {|left_val|\n+            log(debug, #fmt(\"recv_time .. left_val %?\",\n+                           left_val));\n+            none\n+        }, {|right_val|\n+            some(right_val)\n+        }, comm::select2(timeout_po, wait_po)\n+    )\n+}\n+\n // INTERNAL API\n crust fn delayed_send_cb(handle: *uv::ll::uv_timer_t,\n                                 status: libc::c_int) unsafe {\n@@ -108,6 +141,43 @@ crust fn delayed_send_close_cb(handle: *uv::ll::uv_timer_t) unsafe {\n mod test {\n     #[test]\n     fn test_timer_simple_sleep_test() {\n-        sleep(2000u);\n+        sleep(1u);\n+    }\n+\n+    #[test]\n+    fn test_timer_recv_timeout_before_time_passes() {\n+        let expected = rand::rng().gen_str(16u);\n+        let test_po = comm::port::<str>();\n+        let test_ch = comm::chan(test_po);\n+\n+        task::spawn() {||\n+            delayed_send(1u, test_ch, expected);\n+        };\n+\n+        let actual = alt recv_timeout(1000u, test_po) {\n+          some(val) { val }\n+          _ { fail \"test_timer_recv_timeout_before_time_passes:\"+\n+                    \" didn't receive result before timeout\"; }\n+        };\n+        assert actual == expected;\n+    }\n+\n+    #[test]\n+    fn test_timer_recv_timeout_after_time_passes() {\n+        let expected = rand::rng().gen_str(16u);\n+        let fail_msg = rand::rng().gen_str(16u);\n+        let test_po = comm::port::<str>();\n+        let test_ch = comm::chan(test_po);\n+\n+        task::spawn() {||\n+            delayed_send(1000u, test_ch, expected);\n+        };\n+\n+        let actual = alt recv_timeout(1u, test_po) {\n+          none { fail_msg }\n+          _ { fail \"test_timer_recv_timeout_before_time_passes:\"+\n+                    \" didn't receive result before timeout\"; }\n+        };\n+        assert actual == fail_msg;\n     }\n }"}, {"sha": "ff5c618cdffc717b0d785d039c7c1a24d19b1a6a", "filename": "src/libstd/uv_ll.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/707391edbce75b717779d074bf5f5e4b57901e98/src%2Flibstd%2Fuv_ll.rs", "raw_url": "https://github.com/rust-lang/rust/raw/707391edbce75b717779d074bf5f5e4b57901e98/src%2Flibstd%2Fuv_ll.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fuv_ll.rs?ref=707391edbce75b717779d074bf5f5e4b57901e98", "patch": "@@ -841,7 +841,7 @@ mod test {\n             // we have data\n             log(debug, #fmt(\"CLIENT read: data! nread: %d\", nread));\n             read_stop(stream);\n-            let client_data = \n+            let client_data =\n                 get_data_for_uv_handle(stream as *libc::c_void)\n                   as *request_wrapper;\n             let buf_base = get_base_from_buf(buf);"}]}