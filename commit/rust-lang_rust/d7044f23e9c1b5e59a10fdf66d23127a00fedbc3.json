{"sha": "d7044f23e9c1b5e59a10fdf66d23127a00fedbc3", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQ3MDQ0ZjIzZTljMWI1ZTU5YTEwZmRmNjZkMjMxMjdhMDBmZWRiYzM=", "commit": {"author": {"name": "Nadrieril", "email": "nadrieril+git@gmail.com", "date": "2019-11-05T12:04:37Z"}, "committer": {"name": "Nadrieril", "email": "nadrieril+git@gmail.com", "date": "2019-11-05T17:59:01Z"}, "message": "Store both prefix and suffix length in VarLenSlice", "tree": {"sha": "949d1e538e3313cbacf6b803ae311607bdf85b18", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/949d1e538e3313cbacf6b803ae311607bdf85b18"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d7044f23e9c1b5e59a10fdf66d23127a00fedbc3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d7044f23e9c1b5e59a10fdf66d23127a00fedbc3", "html_url": "https://github.com/rust-lang/rust/commit/d7044f23e9c1b5e59a10fdf66d23127a00fedbc3", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d7044f23e9c1b5e59a10fdf66d23127a00fedbc3/comments", "author": {"login": "Nadrieril", "id": 6783654, "node_id": "MDQ6VXNlcjY3ODM2NTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/6783654?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Nadrieril", "html_url": "https://github.com/Nadrieril", "followers_url": "https://api.github.com/users/Nadrieril/followers", "following_url": "https://api.github.com/users/Nadrieril/following{/other_user}", "gists_url": "https://api.github.com/users/Nadrieril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Nadrieril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Nadrieril/subscriptions", "organizations_url": "https://api.github.com/users/Nadrieril/orgs", "repos_url": "https://api.github.com/users/Nadrieril/repos", "events_url": "https://api.github.com/users/Nadrieril/events{/privacy}", "received_events_url": "https://api.github.com/users/Nadrieril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Nadrieril", "id": 6783654, "node_id": "MDQ6VXNlcjY3ODM2NTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/6783654?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Nadrieril", "html_url": "https://github.com/Nadrieril", "followers_url": "https://api.github.com/users/Nadrieril/followers", "following_url": "https://api.github.com/users/Nadrieril/following{/other_user}", "gists_url": "https://api.github.com/users/Nadrieril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Nadrieril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Nadrieril/subscriptions", "organizations_url": "https://api.github.com/users/Nadrieril/orgs", "repos_url": "https://api.github.com/users/Nadrieril/repos", "events_url": "https://api.github.com/users/Nadrieril/events{/privacy}", "received_events_url": "https://api.github.com/users/Nadrieril/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "58de9d9a137178856bca163aa16315bba01723bc", "url": "https://api.github.com/repos/rust-lang/rust/commits/58de9d9a137178856bca163aa16315bba01723bc", "html_url": "https://github.com/rust-lang/rust/commit/58de9d9a137178856bca163aa16315bba01723bc"}], "stats": {"total": 72, "additions": 45, "deletions": 27}, "files": [{"sha": "68486510b764bd93887db7989127a581d62c41ff", "filename": "src/librustc_mir/hair/pattern/_match.rs", "status": "modified", "additions": 45, "deletions": 27, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/d7044f23e9c1b5e59a10fdf66d23127a00fedbc3/src%2Flibrustc_mir%2Fhair%2Fpattern%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7044f23e9c1b5e59a10fdf66d23127a00fedbc3/src%2Flibrustc_mir%2Fhair%2Fpattern%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fpattern%2F_match.rs?ref=d7044f23e9c1b5e59a10fdf66d23127a00fedbc3", "patch": "@@ -588,8 +588,8 @@ enum Constructor<'tcx> {\n     ConstantRange(u128, u128, Ty<'tcx>, RangeEnd, Span),\n     /// Array patterns of length n.\n     FixedLenSlice(u64),\n-    /// Slice patterns. Stands for any array constructor of length >= n.\n-    VarLenSlice(u64),\n+    /// Slice patterns. Captures any array constructor of length >= i+j.\n+    VarLenSlice(u64, u64),\n }\n \n // Ignore spans when comparing, they don't carry semantic information as they are only for lints.\n@@ -604,7 +604,10 @@ impl<'tcx> std::cmp::PartialEq for Constructor<'tcx> {\n                 Constructor::ConstantRange(b_start, b_end, b_ty, b_range_end, _),\n             ) => a_start == b_start && a_end == b_end && a_ty == b_ty && a_range_end == b_range_end,\n             (Constructor::FixedLenSlice(a), Constructor::FixedLenSlice(b)) => a == b,\n-            (Constructor::VarLenSlice(a), Constructor::VarLenSlice(b)) => a == b,\n+            (\n+                Constructor::VarLenSlice(a_prefix, a_suffix),\n+                Constructor::VarLenSlice(b_prefix, b_suffix),\n+            ) => a_prefix == b_prefix && a_suffix == b_suffix,\n             _ => false,\n         }\n     }\n@@ -649,7 +652,7 @@ impl<'tcx> Constructor<'tcx> {\n                 )\n             }\n             Constructor::FixedLenSlice(val) => format!(\"[{}]\", val),\n-            Constructor::VarLenSlice(val) => format!(\"[{}, ..]\", val),\n+            Constructor::VarLenSlice(prefix, suffix) => format!(\"[{}, .., {}]\", prefix, suffix),\n             _ => bug!(\"bad constructor being displayed: `{:?}\", self),\n         }\n     }\n@@ -662,7 +665,7 @@ impl<'tcx> Constructor<'tcx> {\n         param_env: ty::ParamEnv<'tcx>,\n         other_ctors: &Vec<Constructor<'tcx>>,\n     ) -> Vec<Constructor<'tcx>> {\n-        match self {\n+        match *self {\n             // Those constructors can only match themselves.\n             Single | Variant(_) => {\n                 if other_ctors.iter().any(|c| c == self) {\n@@ -672,47 +675,58 @@ impl<'tcx> Constructor<'tcx> {\n                 }\n             }\n             FixedLenSlice(self_len) => {\n-                let overlaps = |c: &Constructor<'_>| match c {\n+                let overlaps = |c: &Constructor<'_>| match *c {\n                     FixedLenSlice(other_len) => other_len == self_len,\n-                    VarLenSlice(other_len) => other_len <= self_len,\n+                    VarLenSlice(prefix, suffix) => prefix + suffix <= self_len,\n                     _ => false,\n                 };\n                 if other_ctors.iter().any(overlaps) { vec![] } else { vec![self.clone()] }\n             }\n-            VarLenSlice(_) => {\n+            VarLenSlice(..) => {\n                 let mut remaining_ctors = vec![self.clone()];\n \n                 // For each used ctor, subtract from the current set of constructors.\n                 // Naming: we remove the \"neg\" constructors from the \"pos\" ones.\n-                // Remember, VarLenSlice(n) covers the union of FixedLenSlice from\n-                // n to infinity.\n+                // Remember, VarLenSlice(i, j) covers the union of FixedLenSlice from\n+                // i+j to infinity.\n                 for neg_ctor in other_ctors {\n                     remaining_ctors = remaining_ctors\n                         .into_iter()\n                         .flat_map(|pos_ctor| -> SmallVec<[Constructor<'tcx>; 1]> {\n                             // Compute pos_ctor \\ neg_ctor\n                             match (&pos_ctor, neg_ctor) {\n-                                (FixedLenSlice(pos_len), VarLenSlice(neg_len)) => {\n+                                (&FixedLenSlice(pos_len), &VarLenSlice(neg_prefix, neg_suffix)) => {\n+                                    let neg_len = neg_prefix + neg_suffix;\n                                     if neg_len <= pos_len {\n                                         smallvec![]\n                                     } else {\n                                         smallvec![pos_ctor]\n                                     }\n                                 }\n-                                (VarLenSlice(pos_len), VarLenSlice(neg_len)) => {\n+                                (\n+                                    &VarLenSlice(pos_prefix, pos_suffix),\n+                                    &VarLenSlice(neg_prefix, neg_suffix),\n+                                ) => {\n+                                    let neg_len = neg_prefix + neg_suffix;\n+                                    let pos_len = pos_prefix + pos_suffix;\n                                     if neg_len <= pos_len {\n                                         smallvec![]\n                                     } else {\n-                                        (*pos_len..*neg_len).map(FixedLenSlice).collect()\n+                                        (pos_len..neg_len).map(FixedLenSlice).collect()\n                                     }\n                                 }\n-                                (VarLenSlice(pos_len), FixedLenSlice(neg_len)) => {\n+                                (&VarLenSlice(pos_prefix, pos_suffix), &FixedLenSlice(neg_len)) => {\n+                                    let pos_len = pos_prefix + pos_suffix;\n                                     if neg_len < pos_len {\n                                         smallvec![pos_ctor]\n                                     } else {\n-                                        (*pos_len..*neg_len)\n+                                        (pos_len..neg_len)\n                                             .map(FixedLenSlice)\n-                                            .chain(Some(VarLenSlice(neg_len + 1)))\n+                                            // We know neg_len + 1 >= pos_len >= pos_suffix\n+                                            .chain(Some(VarLenSlice(\n+                                                neg_len + 1 - pos_suffix,\n+                                                pos_suffix,\n+                                            )))\n                                             .collect()\n                                     }\n                                 }\n@@ -784,7 +798,8 @@ impl<'tcx> Constructor<'tcx> {\n         match ty.kind {\n             ty::Tuple(ref fs) => fs.len() as u64,\n             ty::Slice(..) | ty::Array(..) => match *self {\n-                FixedLenSlice(length) | VarLenSlice(length) => length,\n+                FixedLenSlice(length) => length,\n+                VarLenSlice(prefix, suffix) => prefix + suffix,\n                 ConstantValue(..) => 0,\n                 _ => bug!(\"bad slice pattern {:?} {:?}\", self, ty),\n             },\n@@ -845,10 +860,11 @@ impl<'tcx> Constructor<'tcx> {\n                 FixedLenSlice(_) => {\n                     PatKind::Slice { prefix: subpatterns.collect(), slice: None, suffix: vec![] }\n                 }\n-                VarLenSlice(_) => {\n-                    let prefix = subpatterns.collect();\n+                VarLenSlice(prefix_len, _suffix_len) => {\n+                    let prefix = subpatterns.by_ref().take(*prefix_len as usize).collect();\n+                    let suffix = subpatterns.collect();\n                     let wild = Pat { ty, span: DUMMY_SP, kind: Box::new(PatKind::Wild) };\n-                    PatKind::Slice { prefix, slice: Some(wild), suffix: vec![] }\n+                    PatKind::Slice { prefix, slice: Some(wild), suffix }\n                 }\n                 _ => bug!(\"bad slice pattern {:?} {:?}\", self, ty),\n             },\n@@ -1072,7 +1088,7 @@ fn all_constructors<'a, 'tcx>(\n             if cx.is_uninhabited(sub_ty) {\n                 vec![FixedLenSlice(0)]\n             } else {\n-                vec![VarLenSlice(0)]\n+                vec![VarLenSlice(0, 0)]\n             }\n         }\n         ty::Adt(def, substs) if def.is_enum() => def\n@@ -1796,11 +1812,12 @@ fn pat_constructors<'tcx>(\n             _ => span_bug!(pat.span, \"bad ty {:?} for array pattern\", pcx.ty),\n         },\n         PatKind::Slice { ref prefix, ref slice, ref suffix } => {\n-            let pat_len = prefix.len() as u64 + suffix.len() as u64;\n+            let prefix = prefix.len() as u64;\n+            let suffix = suffix.len() as u64;\n             if slice.is_some() {\n-                Some(vec![VarLenSlice(pat_len)])\n+                Some(vec![VarLenSlice(prefix, suffix)])\n             } else {\n-                Some(vec![FixedLenSlice(pat_len)])\n+                Some(vec![FixedLenSlice(prefix + suffix)])\n             }\n         }\n         PatKind::Or { .. } => {\n@@ -1822,7 +1839,8 @@ fn constructor_sub_pattern_tys<'a, 'tcx>(\n     match ty.kind {\n         ty::Tuple(ref fs) => fs.into_iter().map(|t| t.expect_ty()).collect(),\n         ty::Slice(ty) | ty::Array(ty, _) => match *ctor {\n-            FixedLenSlice(length) | VarLenSlice(length) => (0..length).map(|_| ty).collect(),\n+            FixedLenSlice(length) => (0..length).map(|_| ty).collect(),\n+            VarLenSlice(prefix, suffix) => (0..prefix + suffix).map(|_| ty).collect(),\n             ConstantValue(..) => vec![],\n             _ => bug!(\"bad slice pattern {:?} {:?}\", ctor, ty),\n         },\n@@ -2078,8 +2096,8 @@ fn split_grouped_constructors<'p, 'tcx>(\n                     split_ctors.push(IntRange::range_to_ctor(tcx, ty, range, span));\n                 }\n             }\n-            VarLenSlice(len) => {\n-                split_ctors.extend((len..pcx.max_slice_length + 1).map(FixedLenSlice))\n+            VarLenSlice(prefix, suffix) => {\n+                split_ctors.extend((prefix + suffix..pcx.max_slice_length + 1).map(FixedLenSlice))\n             }\n             // Any other constructor can be used unchanged.\n             _ => split_ctors.push(ctor),"}]}