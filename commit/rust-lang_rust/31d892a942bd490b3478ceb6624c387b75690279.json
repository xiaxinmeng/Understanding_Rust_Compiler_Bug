{"sha": "31d892a942bd490b3478ceb6624c387b75690279", "node_id": "C_kwDOAAsO6NoAKDMxZDg5MmE5NDJiZDQ5MGIzNDc4Y2ViNjYyNGMzODdiNzU2OTAyNzk", "commit": {"author": {"name": "Tomasz Mi\u0105sko", "email": "tomasz.miasko@gmail.com", "date": "2022-08-01T00:00:00Z"}, "committer": {"name": "Tomasz Mi\u0105sko", "email": "tomasz.miasko@gmail.com", "date": "2022-08-25T05:12:16Z"}, "message": "Fix liveness analysis for yield terminators\n\nA resume place is evaluated and assigned to only after a yield\nterminator resumes. Ensure that locals used when evaluating the\nresume place are live across the yield.", "tree": {"sha": "0f208a9da68c5283cc5f5807996a000a6aaeae42", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0f208a9da68c5283cc5f5807996a000a6aaeae42"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/31d892a942bd490b3478ceb6624c387b75690279", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/31d892a942bd490b3478ceb6624c387b75690279", "html_url": "https://github.com/rust-lang/rust/commit/31d892a942bd490b3478ceb6624c387b75690279", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/31d892a942bd490b3478ceb6624c387b75690279/comments", "author": {"login": "tmiasko", "id": 51362316, "node_id": "MDQ6VXNlcjUxMzYyMzE2", "avatar_url": "https://avatars.githubusercontent.com/u/51362316?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tmiasko", "html_url": "https://github.com/tmiasko", "followers_url": "https://api.github.com/users/tmiasko/followers", "following_url": "https://api.github.com/users/tmiasko/following{/other_user}", "gists_url": "https://api.github.com/users/tmiasko/gists{/gist_id}", "starred_url": "https://api.github.com/users/tmiasko/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tmiasko/subscriptions", "organizations_url": "https://api.github.com/users/tmiasko/orgs", "repos_url": "https://api.github.com/users/tmiasko/repos", "events_url": "https://api.github.com/users/tmiasko/events{/privacy}", "received_events_url": "https://api.github.com/users/tmiasko/received_events", "type": "User", "site_admin": false}, "committer": {"login": "tmiasko", "id": 51362316, "node_id": "MDQ6VXNlcjUxMzYyMzE2", "avatar_url": "https://avatars.githubusercontent.com/u/51362316?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tmiasko", "html_url": "https://github.com/tmiasko", "followers_url": "https://api.github.com/users/tmiasko/followers", "following_url": "https://api.github.com/users/tmiasko/following{/other_user}", "gists_url": "https://api.github.com/users/tmiasko/gists{/gist_id}", "starred_url": "https://api.github.com/users/tmiasko/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tmiasko/subscriptions", "organizations_url": "https://api.github.com/users/tmiasko/orgs", "repos_url": "https://api.github.com/users/tmiasko/repos", "events_url": "https://api.github.com/users/tmiasko/events{/privacy}", "received_events_url": "https://api.github.com/users/tmiasko/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5462da52ba9edc77c2a7e4fc77aaf3b977d41ad1", "url": "https://api.github.com/repos/rust-lang/rust/commits/5462da52ba9edc77c2a7e4fc77aaf3b977d41ad1", "html_url": "https://github.com/rust-lang/rust/commit/5462da52ba9edc77c2a7e4fc77aaf3b977d41ad1"}], "stats": {"total": 93, "additions": 61, "deletions": 32}, "files": [{"sha": "8f81b71e3e20099821e07ed7a35e4f1a3b5d49d8", "filename": "compiler/rustc_mir_dataflow/src/impls/liveness.rs", "status": "modified", "additions": 61, "deletions": 32, "changes": 93, "blob_url": "https://github.com/rust-lang/rust/blob/31d892a942bd490b3478ceb6624c387b75690279/compiler%2Frustc_mir_dataflow%2Fsrc%2Fimpls%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31d892a942bd490b3478ceb6624c387b75690279/compiler%2Frustc_mir_dataflow%2Fsrc%2Fimpls%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_dataflow%2Fsrc%2Fimpls%2Fliveness.rs?ref=31d892a942bd490b3478ceb6624c387b75690279", "patch": "@@ -23,12 +23,6 @@ use crate::{Analysis, AnalysisDomain, Backward, CallReturnPlaces, GenKill, GenKi\n /// [liveness]: https://en.wikipedia.org/wiki/Live_variable_analysis\n pub struct MaybeLiveLocals;\n \n-impl MaybeLiveLocals {\n-    fn transfer_function<'a, T>(&self, trans: &'a mut T) -> TransferFunction<'a, T> {\n-        TransferFunction(trans)\n-    }\n-}\n-\n impl<'tcx> AnalysisDomain<'tcx> for MaybeLiveLocals {\n     type Domain = ChunkedBitSet<Local>;\n     type Direction = Backward;\n@@ -54,7 +48,7 @@ impl<'tcx> GenKillAnalysis<'tcx> for MaybeLiveLocals {\n         statement: &mir::Statement<'tcx>,\n         location: Location,\n     ) {\n-        self.transfer_function(trans).visit_statement(statement, location);\n+        TransferFunction(trans).visit_statement(statement, location);\n     }\n \n     fn terminator_effect(\n@@ -63,7 +57,7 @@ impl<'tcx> GenKillAnalysis<'tcx> for MaybeLiveLocals {\n         terminator: &mir::Terminator<'tcx>,\n         location: Location,\n     ) {\n-        self.transfer_function(trans).visit_terminator(terminator, location);\n+        TransferFunction(trans).visit_terminator(terminator, location);\n     }\n \n     fn call_return_effect(\n@@ -85,9 +79,11 @@ impl<'tcx> GenKillAnalysis<'tcx> for MaybeLiveLocals {\n         _resume_block: mir::BasicBlock,\n         resume_place: mir::Place<'tcx>,\n     ) {\n-        if let Some(local) = resume_place.as_local() {\n-            trans.kill(local);\n-        }\n+        YieldResumeEffect(trans).visit_place(\n+            &resume_place,\n+            PlaceContext::MutatingUse(MutatingUseContext::Yield),\n+            Location::START,\n+        )\n     }\n }\n \n@@ -98,23 +94,58 @@ where\n     T: GenKill<Local>,\n {\n     fn visit_place(&mut self, place: &mir::Place<'tcx>, context: PlaceContext, location: Location) {\n-        let local = place.local;\n+        if let PlaceContext::MutatingUse(MutatingUseContext::Yield) = context {\n+            // The resume place is evaluated and assigned to only after generator resumes, so its\n+            // effect is handled separately in `yield_resume_effect`.\n+            return;\n+        }\n+\n+        match DefUse::for_place(*place, context) {\n+            Some(DefUse::Def) => {\n+                if let PlaceContext::MutatingUse(\n+                    MutatingUseContext::Call | MutatingUseContext::AsmOutput,\n+                ) = context\n+                {\n+                    // For the associated terminators, this is only a `Def` when the terminator returns\n+                    // \"successfully.\" As such, we handle this case separately in `call_return_effect`\n+                    // above. However, if the place looks like `*_5`, this is still unconditionally a use of\n+                    // `_5`.\n+                } else {\n+                    self.0.kill(place.local);\n+                }\n+            }\n+            Some(DefUse::Use) => self.0.gen(place.local),\n+            None => {}\n+        }\n \n-        // We purposefully do not call `super_place` here to avoid calling `visit_local` for this\n-        // place with one of the `Projection` variants of `PlaceContext`.\n         self.visit_projection(place.as_ref(), context, location);\n+    }\n \n-        match DefUse::for_place(*place, context) {\n+    fn visit_local(&mut self, local: Local, context: PlaceContext, _: Location) {\n+        match DefUse::for_place(local.into(), context) {\n             Some(DefUse::Def) => self.0.kill(local),\n             Some(DefUse::Use) => self.0.gen(local),\n             None => {}\n         }\n     }\n+}\n+\n+struct YieldResumeEffect<'a, T>(&'a mut T);\n+\n+impl<'tcx, T> Visitor<'tcx> for YieldResumeEffect<'_, T>\n+where\n+    T: GenKill<Local>,\n+{\n+    fn visit_place(&mut self, place: &mir::Place<'tcx>, context: PlaceContext, location: Location) {\n+        match DefUse::for_place(*place, context) {\n+            Some(DefUse::Def) => self.0.kill(place.local),\n+            Some(DefUse::Use) => self.0.gen(place.local),\n+            None => {}\n+        }\n+        self.visit_projection(place.as_ref(), context, location);\n+    }\n \n     fn visit_local(&mut self, local: Local, context: PlaceContext, _: Location) {\n-        // Because we do not call `super_place` above, `visit_local` is only called for locals that\n-        // do not appear as part of  a `Place` in the MIR. This handles cases like the implicit use\n-        // of the return place in a `Return` terminator or the index in an `Index` projection.\n         match DefUse::for_place(local.into(), context) {\n             Some(DefUse::Def) => self.0.kill(local),\n             Some(DefUse::Use) => self.0.gen(local),\n@@ -134,7 +165,13 @@ impl DefUse {\n         match context {\n             PlaceContext::NonUse(_) => None,\n \n-            PlaceContext::MutatingUse(MutatingUseContext::Store | MutatingUseContext::Deinit) => {\n+            PlaceContext::MutatingUse(\n+                MutatingUseContext::Call\n+                | MutatingUseContext::Yield\n+                | MutatingUseContext::AsmOutput\n+                | MutatingUseContext::Store\n+                | MutatingUseContext::Deinit,\n+            ) => {\n                 if place.is_indirect() {\n                     // Treat derefs as a use of the base local. `*p = 4` is not a def of `p` but a\n                     // use.\n@@ -152,16 +189,6 @@ impl DefUse {\n                 place.is_indirect().then_some(DefUse::Use)\n             }\n \n-            // For the associated terminators, this is only a `Def` when the terminator returns\n-            // \"successfully.\" As such, we handle this case separately in `call_return_effect`\n-            // above. However, if the place looks like `*_5`, this is still unconditionally a use of\n-            // `_5`.\n-            PlaceContext::MutatingUse(\n-                MutatingUseContext::Call\n-                | MutatingUseContext::Yield\n-                | MutatingUseContext::AsmOutput,\n-            ) => place.is_indirect().then_some(DefUse::Use),\n-\n             // All other contexts are uses...\n             PlaceContext::MutatingUse(\n                 MutatingUseContext::AddressOf\n@@ -290,8 +317,10 @@ impl<'a, 'tcx> Analysis<'tcx> for MaybeTransitiveLiveLocals<'a> {\n         _resume_block: mir::BasicBlock,\n         resume_place: mir::Place<'tcx>,\n     ) {\n-        if let Some(local) = resume_place.as_local() {\n-            trans.remove(local);\n-        }\n+        YieldResumeEffect(trans).visit_place(\n+            &resume_place,\n+            PlaceContext::MutatingUse(MutatingUseContext::Yield),\n+            Location::START,\n+        )\n     }\n }"}]}