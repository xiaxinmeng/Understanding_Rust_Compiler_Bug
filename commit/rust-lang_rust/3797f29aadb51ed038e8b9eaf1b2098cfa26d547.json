{"sha": "3797f29aadb51ed038e8b9eaf1b2098cfa26d547", "node_id": "MDY6Q29tbWl0NzI0NzEyOjM3OTdmMjlhYWRiNTFlZDAzOGU4YjllYWYxYjIwOThjZmEyNmQ1NDc=", "commit": {"author": {"name": "Joshua Nelson", "email": "jyn514@gmail.com", "date": "2020-08-20T15:41:18Z"}, "committer": {"name": "Joshua Nelson", "email": "jyn514@gmail.com", "date": "2020-09-05T17:48:19Z"}, "message": "[WIP] give better errors for broken intra doc links", "tree": {"sha": "f7549d944a7f3ff729304250b312c856bb10d3c7", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f7549d944a7f3ff729304250b312c856bb10d3c7"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3797f29aadb51ed038e8b9eaf1b2098cfa26d547", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3797f29aadb51ed038e8b9eaf1b2098cfa26d547", "html_url": "https://github.com/rust-lang/rust/commit/3797f29aadb51ed038e8b9eaf1b2098cfa26d547", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3797f29aadb51ed038e8b9eaf1b2098cfa26d547/comments", "author": {"login": "jyn514", "id": 23638587, "node_id": "MDQ6VXNlcjIzNjM4NTg3", "avatar_url": "https://avatars.githubusercontent.com/u/23638587?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jyn514", "html_url": "https://github.com/jyn514", "followers_url": "https://api.github.com/users/jyn514/followers", "following_url": "https://api.github.com/users/jyn514/following{/other_user}", "gists_url": "https://api.github.com/users/jyn514/gists{/gist_id}", "starred_url": "https://api.github.com/users/jyn514/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jyn514/subscriptions", "organizations_url": "https://api.github.com/users/jyn514/orgs", "repos_url": "https://api.github.com/users/jyn514/repos", "events_url": "https://api.github.com/users/jyn514/events{/privacy}", "received_events_url": "https://api.github.com/users/jyn514/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jyn514", "id": 23638587, "node_id": "MDQ6VXNlcjIzNjM4NTg3", "avatar_url": "https://avatars.githubusercontent.com/u/23638587?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jyn514", "html_url": "https://github.com/jyn514", "followers_url": "https://api.github.com/users/jyn514/followers", "following_url": "https://api.github.com/users/jyn514/following{/other_user}", "gists_url": "https://api.github.com/users/jyn514/gists{/gist_id}", "starred_url": "https://api.github.com/users/jyn514/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jyn514/subscriptions", "organizations_url": "https://api.github.com/users/jyn514/orgs", "repos_url": "https://api.github.com/users/jyn514/repos", "events_url": "https://api.github.com/users/jyn514/events{/privacy}", "received_events_url": "https://api.github.com/users/jyn514/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7d289aeade481c03d42e7f6d31bc6b64a73cfa45", "url": "https://api.github.com/repos/rust-lang/rust/commits/7d289aeade481c03d42e7f6d31bc6b64a73cfa45", "html_url": "https://github.com/rust-lang/rust/commit/7d289aeade481c03d42e7f6d31bc6b64a73cfa45"}], "stats": {"total": 570, "additions": 476, "deletions": 94}, "files": [{"sha": "b019e518d0c5457b28c342d416663960dc05a23f", "filename": "compiler/rustc_hir/src/def.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/3797f29aadb51ed038e8b9eaf1b2098cfa26d547/compiler%2Frustc_hir%2Fsrc%2Fdef.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3797f29aadb51ed038e8b9eaf1b2098cfa26d547/compiler%2Frustc_hir%2Fsrc%2Fdef.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir%2Fsrc%2Fdef.rs?ref=3797f29aadb51ed038e8b9eaf1b2098cfa26d547", "patch": "@@ -6,6 +6,7 @@ use rustc_ast::NodeId;\n use rustc_macros::HashStable_Generic;\n use rustc_span::hygiene::MacroKind;\n \n+use std::array::IntoIter;\n use std::fmt::Debug;\n \n /// Encodes if a `DefKind::Ctor` is the constructor of an enum variant or a struct.\n@@ -291,6 +292,14 @@ impl<T> PerNS<T> {\n     pub fn map<U, F: FnMut(T) -> U>(self, mut f: F) -> PerNS<U> {\n         PerNS { value_ns: f(self.value_ns), type_ns: f(self.type_ns), macro_ns: f(self.macro_ns) }\n     }\n+\n+    pub fn into_iter(self) -> IntoIter<T, 3> {\n+        IntoIter::new([self.value_ns, self.type_ns, self.macro_ns])\n+    }\n+\n+    pub fn iter(&self) -> IntoIter<&T, 3> {\n+        IntoIter::new([&self.value_ns, &self.type_ns, &self.macro_ns])\n+    }\n }\n \n impl<T> ::std::ops::Index<Namespace> for PerNS<T> {"}, {"sha": "9d931b3a9e1e561cff533c98b91c0e6ca220c852", "filename": "compiler/rustc_hir/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/3797f29aadb51ed038e8b9eaf1b2098cfa26d547/compiler%2Frustc_hir%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3797f29aadb51ed038e8b9eaf1b2098cfa26d547/compiler%2Frustc_hir%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir%2Fsrc%2Flib.rs?ref=3797f29aadb51ed038e8b9eaf1b2098cfa26d547", "patch": "@@ -2,6 +2,7 @@\n //!\n //! [rustc dev guide]: https://rustc-dev-guide.rust-lang.org/hir.html\n \n+#![feature(array_value_iter)]\n #![feature(crate_visibility_modifier)]\n #![feature(const_fn)] // For the unsizing cast on `&[]`\n #![feature(const_panic)]"}, {"sha": "f6f01028ee2e22e0327ebbf90754f7bb19eeb601", "filename": "src/librustdoc/passes/collect_intra_doc_links.rs", "status": "modified", "additions": 290, "deletions": 71, "changes": 361, "blob_url": "https://github.com/rust-lang/rust/blob/3797f29aadb51ed038e8b9eaf1b2098cfa26d547/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3797f29aadb51ed038e8b9eaf1b2098cfa26d547/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs?ref=3797f29aadb51ed038e8b9eaf1b2098cfa26d547", "patch": "@@ -17,7 +17,7 @@ use rustc_span::hygiene::MacroKind;\n use rustc_span::symbol::Ident;\n use rustc_span::symbol::Symbol;\n use rustc_span::DUMMY_SP;\n-use smallvec::SmallVec;\n+use smallvec::{smallvec, SmallVec};\n \n use std::cell::Cell;\n use std::ops::Range;\n@@ -47,10 +47,53 @@ pub fn collect_intra_doc_links(krate: Crate, cx: &DocContext<'_>) -> Crate {\n }\n \n enum ErrorKind {\n-    ResolutionFailure,\n+    Resolve(ResolutionFailure),\n     AnchorFailure(AnchorFailure),\n }\n \n+#[derive(Debug)]\n+enum ResolutionFailure {\n+    /// This resolved, but with the wrong namespace.\n+    /// `Namespace` is the expected namespace (as opposed to the actual).\n+    WrongNamespace(Res, Namespace),\n+    /// `String` is the base name of the path (not necessarily the whole link)\n+    NotInScope(String),\n+    /// this is a primitive type without an impls (no associated methods)\n+    /// when will this actually happen?\n+    /// the `Res` is the primitive it resolved to\n+    NoPrimitiveImpl(Res, String),\n+    /// `[u8::not_found]`\n+    /// the `Res` is the primitive it resolved to\n+    NoPrimitiveAssocItem { res: Res, prim_name: String, assoc_item: String },\n+    /// `[S::not_found]`\n+    /// the `String` is the associated item that wasn't found\n+    NoAssocItem(Res, String),\n+    /// should not ever happen\n+    NoParentItem,\n+    /// the root of this path resolved, but it was not an enum.\n+    NotAnEnum(Res),\n+    /// this could be an enum variant, but the last path fragment wasn't resolved.\n+    /// the `String` is the variant that didn't exist\n+    NotAVariant(Res, String),\n+    /// used to communicate that this should be ignored, but shouldn't be reported to the user\n+    Dummy,\n+}\n+\n+impl ResolutionFailure {\n+    fn res(&self) -> Option<Res> {\n+        use ResolutionFailure::*;\n+        match self {\n+            NoPrimitiveAssocItem { res, .. }\n+            | NoAssocItem(res, _)\n+            | NoPrimitiveImpl(res, _)\n+            | NotAnEnum(res)\n+            | NotAVariant(res, _)\n+            | WrongNamespace(res, _) => Some(*res),\n+            NotInScope(_) | NoParentItem | Dummy => None,\n+        }\n+    }\n+}\n+\n enum AnchorFailure {\n     MultipleAnchors,\n     Primitive,\n@@ -85,10 +128,14 @@ impl<'a, 'tcx> LinkCollector<'a, 'tcx> {\n         let cx = self.cx;\n \n         let mut split = path_str.rsplitn(3, \"::\");\n-        let variant_field_name =\n-            split.next().map(|f| Symbol::intern(f)).ok_or(ErrorKind::ResolutionFailure)?;\n+        let variant_field_name = split\n+            .next()\n+            .map(|f| Symbol::intern(f))\n+            .expect(\"fold_item should ensure link is non-empty\");\n         let variant_name =\n-            split.next().map(|f| Symbol::intern(f)).ok_or(ErrorKind::ResolutionFailure)?;\n+            // we're not sure this is a variant at all, so use the full string\n+            split.next().map(|f| Symbol::intern(f)).ok_or(ErrorKind::Resolve(ResolutionFailure::NotInScope(path_str.to_string())))?;\n+        // TODO: this looks very wrong, why are we requiring 3 fields?\n         let path = split\n             .next()\n             .map(|f| {\n@@ -99,14 +146,15 @@ impl<'a, 'tcx> LinkCollector<'a, 'tcx> {\n                 }\n                 f.to_owned()\n             })\n-            .ok_or(ErrorKind::ResolutionFailure)?;\n+            // TODO: is this right?\n+            .ok_or(ErrorKind::Resolve(ResolutionFailure::NotInScope(variant_name.to_string())))?;\n         let (_, ty_res) = cx\n             .enter_resolver(|resolver| {\n                 resolver.resolve_str_path_error(DUMMY_SP, &path, TypeNS, module_id)\n             })\n-            .map_err(|_| ErrorKind::ResolutionFailure)?;\n+            .map_err(|_| ErrorKind::Resolve(ResolutionFailure::NotInScope(path.to_string())))?;\n         if let Res::Err = ty_res {\n-            return Err(ErrorKind::ResolutionFailure);\n+            return Err(ErrorKind::Resolve(ResolutionFailure::NotInScope(path.to_string())));\n         }\n         let ty_res = ty_res.map_id(|_| panic!(\"unexpected node_id\"));\n         match ty_res {\n@@ -118,7 +166,9 @@ impl<'a, 'tcx> LinkCollector<'a, 'tcx> {\n                     .flat_map(|imp| cx.tcx.associated_items(*imp).in_definition_order())\n                     .any(|item| item.ident.name == variant_name)\n                 {\n-                    return Err(ErrorKind::ResolutionFailure);\n+                    // This is just to let `fold_item` know that this shouldn't be considered;\n+                    // it's a bug for the error to make it to the user\n+                    return Err(ErrorKind::Resolve(ResolutionFailure::Dummy));\n                 }\n                 match cx.tcx.type_of(did).kind() {\n                     ty::Adt(def, _) if def.is_enum() => {\n@@ -131,18 +181,25 @@ impl<'a, 'tcx> LinkCollector<'a, 'tcx> {\n                                 )),\n                             ))\n                         } else {\n-                            Err(ErrorKind::ResolutionFailure)\n+                            Err(ErrorKind::Resolve(ResolutionFailure::NotAVariant(\n+                                ty_res,\n+                                variant_field_name.to_string(),\n+                            )))\n                         }\n                     }\n-                    _ => Err(ErrorKind::ResolutionFailure),\n+                    _ => unreachable!(),\n                 }\n             }\n-            _ => Err(ErrorKind::ResolutionFailure),\n+            _ => Err(ErrorKind::Resolve(ResolutionFailure::NotAnEnum(ty_res))),\n         }\n     }\n \n     /// Resolves a string as a macro.\n-    fn macro_resolve(&self, path_str: &str, parent_id: Option<DefId>) -> Option<Res> {\n+    fn macro_resolve(\n+        &self,\n+        path_str: &str,\n+        parent_id: Option<DefId>,\n+    ) -> Result<Res, ResolutionFailure> {\n         let cx = self.cx;\n         let path = ast::Path::from_ident(Ident::from_str(path_str));\n         cx.enter_resolver(|resolver| {\n@@ -154,11 +211,11 @@ impl<'a, 'tcx> LinkCollector<'a, 'tcx> {\n                 false,\n             ) {\n                 if let SyntaxExtensionKind::LegacyBang { .. } = ext.kind {\n-                    return Some(res.map_id(|_| panic!(\"unexpected id\")));\n+                    return Ok(res.map_id(|_| panic!(\"unexpected id\")));\n                 }\n             }\n             if let Some(res) = resolver.all_macros().get(&Symbol::intern(path_str)) {\n-                return Some(res.map_id(|_| panic!(\"unexpected id\")));\n+                return Ok(res.map_id(|_| panic!(\"unexpected id\")));\n             }\n             if let Some(module_id) = parent_id {\n                 debug!(\"resolving {} as a macro in the module {:?}\", path_str, module_id);\n@@ -168,13 +225,14 @@ impl<'a, 'tcx> LinkCollector<'a, 'tcx> {\n                     // don't resolve builtins like `#[derive]`\n                     if let Res::Def(..) = res {\n                         let res = res.map_id(|_| panic!(\"unexpected node_id\"));\n-                        return Some(res);\n+                        return Ok(res);\n                     }\n                 }\n             } else {\n                 debug!(\"attempting to resolve item without parent module: {}\", path_str);\n+                return Err(ResolutionFailure::NoParentItem);\n             }\n-            None\n+            return Err(ResolutionFailure::NotInScope(path_str.to_string()));\n         })\n     }\n     /// Resolves a string as a path within a particular namespace. Also returns an optional\n@@ -196,8 +254,8 @@ impl<'a, 'tcx> LinkCollector<'a, 'tcx> {\n             });\n             debug!(\"{} resolved to {:?} in namespace {:?}\", path_str, result, ns);\n             let result = match result {\n-                Ok((_, Res::Err)) => Err(ErrorKind::ResolutionFailure),\n-                _ => result.map_err(|_| ErrorKind::ResolutionFailure),\n+                Ok((_, Res::Err)) => Err(()),\n+                _ => result.map_err(|_| ()),\n             };\n \n             if let Ok((_, res)) = result {\n@@ -226,7 +284,7 @@ impl<'a, 'tcx> LinkCollector<'a, 'tcx> {\n                 };\n \n                 if value != (ns == ValueNS) {\n-                    return Err(ErrorKind::ResolutionFailure);\n+                    return Err(ErrorKind::Resolve(ResolutionFailure::WrongNamespace(res, ns)));\n                 }\n             } else if let Some((path, prim)) = is_primitive(path_str, ns) {\n                 if extra_fragment.is_some() {\n@@ -237,9 +295,9 @@ impl<'a, 'tcx> LinkCollector<'a, 'tcx> {\n \n             // Try looking for methods and associated items.\n             let mut split = path_str.rsplitn(2, \"::\");\n-            let item_name =\n-                split.next().map(|f| Symbol::intern(f)).ok_or(ErrorKind::ResolutionFailure)?;\n-            let path = split\n+            // this can be an `unwrap()` because we ensure the link is never empty\n+            let item_name = Symbol::intern(split.next().unwrap());\n+            let path_root = split\n                 .next()\n                 .map(|f| {\n                     if f == \"self\" || f == \"Self\" {\n@@ -249,10 +307,15 @@ impl<'a, 'tcx> LinkCollector<'a, 'tcx> {\n                     }\n                     f.to_owned()\n                 })\n-                .ok_or(ErrorKind::ResolutionFailure)?;\n-\n-            if let Some((path, prim)) = is_primitive(&path, TypeNS) {\n-                for &impl_ in primitive_impl(cx, &path).ok_or(ErrorKind::ResolutionFailure)? {\n+                // If there's no `::`, it's not an associated item.\n+                // So we can be sure that `rustc_resolve` was accurate when it said it wasn't resolved.\n+                .ok_or(ErrorKind::Resolve(ResolutionFailure::NotInScope(item_name.to_string())))?;\n+\n+            if let Some((path, prim)) = is_primitive(&path_root, ns) {\n+                let impls = primitive_impl(cx, &path).ok_or_else(|| {\n+                    ErrorKind::Resolve(ResolutionFailure::NoPrimitiveImpl(prim, path_root))\n+                })?;\n+                for &impl_ in impls {\n                     let link = cx\n                         .tcx\n                         .associated_items(impl_)\n@@ -272,19 +335,25 @@ impl<'a, 'tcx> LinkCollector<'a, 'tcx> {\n                         return Ok(link);\n                     }\n                 }\n-                return Err(ErrorKind::ResolutionFailure);\n+                return Err(ErrorKind::Resolve(ResolutionFailure::NoPrimitiveAssocItem {\n+                    res: prim,\n+                    prim_name: path.to_string(),\n+                    assoc_item: item_name.to_string(),\n+                }));\n             }\n \n             let (_, ty_res) = cx\n                 .enter_resolver(|resolver| {\n-                    resolver.resolve_str_path_error(DUMMY_SP, &path, TypeNS, module_id)\n+                    resolver.resolve_str_path_error(DUMMY_SP, &path_root, TypeNS, module_id)\n                 })\n-                .map_err(|_| ErrorKind::ResolutionFailure)?;\n+                .map_err(|_| {\n+                    ErrorKind::Resolve(ResolutionFailure::NotInScope(path_root.clone()))\n+                })?;\n             if let Res::Err = ty_res {\n                 return if ns == Namespace::ValueNS {\n                     self.variant_field(path_str, current_item, module_id)\n                 } else {\n-                    Err(ErrorKind::ResolutionFailure)\n+                    Err(ErrorKind::Resolve(ResolutionFailure::NotInScope(path_root)))\n                 };\n             }\n             let ty_res = ty_res.map_id(|_| panic!(\"unexpected node_id\"));\n@@ -380,7 +449,10 @@ impl<'a, 'tcx> LinkCollector<'a, 'tcx> {\n                         }\n                     } else {\n                         // We already know this isn't in ValueNS, so no need to check variant_field\n-                        return Err(ErrorKind::ResolutionFailure);\n+                        return Err(ErrorKind::Resolve(ResolutionFailure::NoAssocItem(\n+                            ty_res,\n+                            item_name.to_string(),\n+                        )));\n                     }\n                 }\n                 Res::Def(DefKind::Trait, did) => cx\n@@ -419,12 +491,16 @@ impl<'a, 'tcx> LinkCollector<'a, 'tcx> {\n                 if ns == Namespace::ValueNS {\n                     self.variant_field(path_str, current_item, module_id)\n                 } else {\n-                    Err(ErrorKind::ResolutionFailure)\n+                    Err(ErrorKind::Resolve(ResolutionFailure::NoAssocItem(\n+                        ty_res,\n+                        item_name.to_string(),\n+                    )))\n                 }\n             })\n         } else {\n             debug!(\"attempting to resolve item without parent module: {}\", path_str);\n-            Err(ErrorKind::ResolutionFailure)\n+            // TODO: maybe this should just be an ICE?\n+            Err(ErrorKind::Resolve(ResolutionFailure::NoParentItem))\n         }\n     }\n }\n@@ -562,10 +638,10 @@ fn traits_implemented_by(cx: &DocContext<'_>, type_: DefId, module: DefId) -> Fx\n /// Check for resolve collisions between a trait and its derive\n ///\n /// These are common and we should just resolve to the trait in that case\n-fn is_derive_trait_collision<T>(ns: &PerNS<Option<(Res, T)>>) -> bool {\n+fn is_derive_trait_collision<T>(ns: &PerNS<Result<(Res, T), ResolutionFailure>>) -> bool {\n     if let PerNS {\n-        type_ns: Some((Res::Def(DefKind::Trait, _), _)),\n-        macro_ns: Some((Res::Def(DefKind::Macro(MacroKind::Derive), _), _)),\n+        type_ns: Ok((Res::Def(DefKind::Trait, _), _)),\n+        macro_ns: Ok((Res::Def(DefKind::Macro(MacroKind::Derive), _), _)),\n         ..\n     } = *ns\n     {\n@@ -764,8 +840,15 @@ impl<'a, 'tcx> DocFolder for LinkCollector<'a, 'tcx> {\n                         match self.resolve(path_str, ns, &current_item, base_node, &extra_fragment)\n                         {\n                             Ok(res) => res,\n-                            Err(ErrorKind::ResolutionFailure) => {\n-                                resolution_failure(cx, &item, path_str, &dox, link_range);\n+                            Err(ErrorKind::Resolve(kind)) => {\n+                                resolution_failure(\n+                                    cx,\n+                                    &item,\n+                                    path_str,\n+                                    &dox,\n+                                    link_range,\n+                                    smallvec![kind],\n+                                );\n                                 // This could just be a normal link or a broken link\n                                 // we could potentially check if something is\n                                 // \"intra-doc-link-like\" and warn in that case.\n@@ -792,13 +875,13 @@ impl<'a, 'tcx> DocFolder for LinkCollector<'a, 'tcx> {\n                             ) {\n                                 Ok(res) => {\n                                     debug!(\"got res in TypeNS: {:?}\", res);\n-                                    Some(res)\n+                                    Ok(res)\n                                 }\n                                 Err(ErrorKind::AnchorFailure(msg)) => {\n                                     anchor_failure(cx, &item, &ori_link, &dox, link_range, msg);\n                                     continue;\n                                 }\n-                                Err(ErrorKind::ResolutionFailure) => None,\n+                                Err(ErrorKind::Resolve(kind)) => Err(kind),\n                             },\n                             value_ns: match self.resolve(\n                                 path_str,\n@@ -807,48 +890,62 @@ impl<'a, 'tcx> DocFolder for LinkCollector<'a, 'tcx> {\n                                 base_node,\n                                 &extra_fragment,\n                             ) {\n-                                Ok(res) => Some(res),\n+                                Ok(res) => Ok(res),\n                                 Err(ErrorKind::AnchorFailure(msg)) => {\n                                     anchor_failure(cx, &item, &ori_link, &dox, link_range, msg);\n                                     continue;\n                                 }\n-                                Err(ErrorKind::ResolutionFailure) => None,\n+                                Err(ErrorKind::Resolve(kind)) => Err(kind),\n                             }\n                             .and_then(|(res, fragment)| {\n                                 // Constructors are picked up in the type namespace.\n                                 match res {\n-                                    Res::Def(DefKind::Ctor(..), _) | Res::SelfCtor(..) => None,\n+                                    Res::Def(DefKind::Ctor(..), _) | Res::SelfCtor(..) => {\n+                                        Err(ResolutionFailure::WrongNamespace(res, TypeNS))\n+                                    }\n                                     _ => match (fragment, extra_fragment) {\n                                         (Some(fragment), Some(_)) => {\n                                             // Shouldn't happen but who knows?\n-                                            Some((res, Some(fragment)))\n-                                        }\n-                                        (fragment, None) | (None, fragment) => {\n-                                            Some((res, fragment))\n+                                            Ok((res, Some(fragment)))\n                                         }\n+                                        (fragment, None) | (None, fragment) => Ok((res, fragment)),\n                                     },\n                                 }\n                             }),\n                         };\n \n-                        if candidates.is_empty() {\n-                            resolution_failure(cx, &item, path_str, &dox, link_range);\n+                        let mut candidates_iter =\n+                            candidates.iter().filter_map(|res| res.as_ref().ok());\n+                        let len = candidates_iter.clone().count();\n+\n+                        if len == 0 {\n+                            drop(candidates_iter);\n+                            resolution_failure(\n+                                cx,\n+                                &item,\n+                                path_str,\n+                                &dox,\n+                                link_range,\n+                                candidates.into_iter().filter_map(|res| res.err()).collect(),\n+                            );\n                             // this could just be a normal link\n                             continue;\n                         }\n \n-                        let len = candidates.clone().present_items().count();\n-\n                         if len == 1 {\n-                            candidates.present_items().next().unwrap()\n+                            candidates_iter.next().unwrap().clone()\n                         } else if len == 2 && is_derive_trait_collision(&candidates) {\n+                            drop(candidates_iter);\n                             candidates.type_ns.unwrap()\n                         } else {\n+                            drop(candidates_iter);\n                             if is_derive_trait_collision(&candidates) {\n-                                candidates.macro_ns = None;\n+                                candidates.macro_ns =\n+                                    Err(ResolutionFailure::NotInScope(path_str.to_string()));\n                             }\n+                            // If we're reporting an ambiguity, don't mention the namespaces that failed\n                             let candidates =\n-                                candidates.map(|candidate| candidate.map(|(res, _)| res));\n+                                candidates.map(|candidate| candidate.ok().map(|(res, _)| res));\n                             ambiguity_error(\n                                 cx,\n                                 &item,\n@@ -861,11 +958,44 @@ impl<'a, 'tcx> DocFolder for LinkCollector<'a, 'tcx> {\n                         }\n                     }\n                     Some(MacroNS) => {\n-                        if let Some(res) = self.macro_resolve(path_str, base_node) {\n-                            (res, extra_fragment)\n-                        } else {\n-                            resolution_failure(cx, &item, path_str, &dox, link_range);\n-                            continue;\n+                        match self.macro_resolve(path_str, base_node) {\n+                            Ok(res) => (res, extra_fragment),\n+                            Err(mut kind) => {\n+                                // `macro_resolve` only looks in the macro namespace. Try to give a better error if possible.\n+                                for &ns in &[TypeNS, ValueNS] {\n+                                    match self.resolve(\n+                                        path_str,\n+                                        ns,\n+                                        &current_item,\n+                                        base_node,\n+                                        &extra_fragment,\n+                                    ) {\n+                                        Ok(res) => {\n+                                            kind = ResolutionFailure::WrongNamespace(res.0, MacroNS)\n+                                        }\n+                                        // This will show up in the other namespace, no need to handle it here\n+                                        Err(ErrorKind::Resolve(\n+                                            ResolutionFailure::WrongNamespace(..),\n+                                        )) => {}\n+                                        Err(ErrorKind::AnchorFailure(_)) => {}\n+                                        Err(ErrorKind::Resolve(inner_kind)) => {\n+                                            if let Some(res) = inner_kind.res() {\n+                                                kind =\n+                                                    ResolutionFailure::WrongNamespace(res, MacroNS);\n+                                            }\n+                                        }\n+                                    }\n+                                }\n+                                resolution_failure(\n+                                    cx,\n+                                    &item,\n+                                    path_str,\n+                                    &dox,\n+                                    link_range,\n+                                    smallvec![kind],\n+                                );\n+                                continue;\n+                            }\n                         }\n                     }\n                 }\n@@ -907,7 +1037,7 @@ impl<'a, 'tcx> DocFolder for LinkCollector<'a, 'tcx> {\n             let report_mismatch = |specified: Disambiguator, resolved: Disambiguator| {\n                 // The resolved item did not match the disambiguator; give a better error than 'not found'\n                 let msg = format!(\"incompatible link kind for `{}`\", path_str);\n-                report_diagnostic(cx, &msg, &item, &dox, link_range.clone(), |diag, sp| {\n+                report_diagnostic(cx, &msg, &item, &dox, &link_range, |diag, sp| {\n                     let note = format!(\n                         \"this link resolved to {} {}, which is not {} {}\",\n                         resolved.article(),\n@@ -1161,7 +1291,7 @@ fn report_diagnostic(\n     msg: &str,\n     item: &Item,\n     dox: &str,\n-    link_range: Option<Range<usize>>,\n+    link_range: &Option<Range<usize>>,\n     decorate: impl FnOnce(&mut DiagnosticBuilder<'_>, Option<rustc_span::Span>),\n ) {\n     let hir_id = match cx.as_local_hir_id(item.def_id) {\n@@ -1218,19 +1348,107 @@ fn resolution_failure(\n     path_str: &str,\n     dox: &str,\n     link_range: Option<Range<usize>>,\n+    kinds: SmallVec<[ResolutionFailure; 3]>,\n ) {\n     report_diagnostic(\n         cx,\n         &format!(\"unresolved link to `{}`\", path_str),\n         item,\n         dox,\n-        link_range,\n+        &link_range,\n         |diag, sp| {\n-            if let Some(sp) = sp {\n-                diag.span_label(sp, \"unresolved link\");\n+            let in_scope = kinds.iter().any(|kind| kind.res().is_some());\n+            let mut reported_not_in_scope = false;\n+            let item = |res: Res| {\n+                if let Some(id) = res.opt_def_id() {\n+                    (format!(\"the {} `{}`\", res.descr(), cx.tcx.item_name(id).to_string()), \",\")\n+                } else {\n+                    (format!(\"{} {}\", res.article(), res.descr()), \"\")\n+                }\n+            };\n+            for failure in kinds {\n+                match failure {\n+                    // already handled above\n+                    ResolutionFailure::NotInScope(base) => {\n+                        if in_scope || reported_not_in_scope {\n+                            continue;\n+                        }\n+                        reported_not_in_scope = true;\n+                        diag.note(&format!(\"no item named `{}` is in scope\", base));\n+                        diag.help(r#\"to escape `[` and `]` characters, add '\\' before them like `\\[` or `\\]`\"#);\n+                    }\n+                    ResolutionFailure::Dummy => continue,\n+                    ResolutionFailure::WrongNamespace(res, expected_ns) => {\n+                        let (item, comma) = item(res);\n+                        let note = format!(\n+                            \"this link resolves to {}{} which is not in the {} namespace\",\n+                            item,\n+                            comma,\n+                            expected_ns.descr()\n+                        );\n+                        diag.note(&note);\n+\n+                        if let Res::Def(kind, _) = res {\n+                            let disambiguator = Disambiguator::Kind(kind);\n+                            suggest_disambiguator(\n+                                disambiguator,\n+                                diag,\n+                                path_str,\n+                                dox,\n+                                sp,\n+                                &link_range,\n+                            )\n+                        }\n+                    }\n+                    ResolutionFailure::NoParentItem => {\n+                        panic!(\"all intra doc links should have a parent item\")\n+                    }\n+                    ResolutionFailure::NoPrimitiveImpl(res, _) => {\n+                        let (item, comma) = item(res);\n+                        let note = format!(\n+                            \"this link partially resolves to {}{} which does not have any associated items\",\n+                            item, comma,\n+                        );\n+                        diag.note(&note);\n+                    }\n+                    ResolutionFailure::NoPrimitiveAssocItem { prim_name, assoc_item, .. } => {\n+                        let note = format!(\n+                            \"the builtin type `{}` does not have an associated item named `{}`\",\n+                            prim_name, assoc_item\n+                        );\n+                        diag.note(&note);\n+                    }\n+                    ResolutionFailure::NoAssocItem(res, assoc_item) => {\n+                        let (item, _) = item(res);\n+                        diag.note(&format!(\"this link partially resolves to {}\", item));\n+                        // FIXME: when are items neither a primitive nor a Def?\n+                        if let Res::Def(_, def_id) = res {\n+                            let name = cx.tcx.item_name(def_id);\n+                            let note = format!(\n+                                \"`{}` has no field, variant, or associated item named `{}`\",\n+                                name, assoc_item\n+                            );\n+                            diag.note(&note);\n+                        }\n+                    }\n+                    // TODO: is there ever a case where this happens?\n+                    ResolutionFailure::NotAnEnum(res) => {\n+                        let (item, comma) = item(res);\n+                        let note =\n+                            format!(\"this link resolves to {}{} which is not an enum\", item, comma);\n+                        diag.note(&note);\n+                        diag.note(\"if this were an enum, it might have a variant which resolved\");\n+                    }\n+                    ResolutionFailure::NotAVariant(res, variant) => {\n+                        let note = format!(\n+                            \"this link partially resolves to {}, but there is no variant named {}\",\n+                            item(res).0,\n+                            variant\n+                        );\n+                        diag.note(&note);\n+                    }\n+                }\n             }\n-\n-            diag.help(r#\"to escape `[` and `]` characters, add '\\' before them like `\\[` or `\\]`\"#);\n         },\n     );\n }\n@@ -1269,7 +1487,7 @@ fn anchor_failure(\n         }\n     };\n \n-    report_diagnostic(cx, &msg, item, dox, link_range, |diag, sp| {\n+    report_diagnostic(cx, &msg, item, dox, &link_range, |diag, sp| {\n         if let Some(sp) = sp {\n             diag.span_label(sp, \"contains invalid anchor\");\n         }\n@@ -1308,7 +1526,7 @@ fn ambiguity_error(\n         }\n     }\n \n-    report_diagnostic(cx, &msg, item, dox, link_range.clone(), |diag, sp| {\n+    report_diagnostic(cx, &msg, item, dox, &link_range, |diag, sp| {\n         if let Some(sp) = sp {\n             diag.span_label(sp, \"ambiguous link\");\n         } else {\n@@ -1356,7 +1574,7 @@ fn privacy_error(\n     let msg =\n         format!(\"public documentation for `{}` links to private item `{}`\", item_name, path_str);\n \n-    report_diagnostic(cx, &msg, item, dox, link_range, |diag, sp| {\n+    report_diagnostic(cx, &msg, item, dox, &link_range, |diag, sp| {\n         if let Some(sp) = sp {\n             diag.span_label(sp, \"this item is private\");\n         }\n@@ -1384,7 +1602,8 @@ fn handle_variant(\n     let parent = if let Some(parent) = cx.tcx.parent(res.def_id()) {\n         parent\n     } else {\n-        return Err(ErrorKind::ResolutionFailure);\n+        // TODO: this should just be an unwrap, there should never be `Variant`s without a parent\n+        return Err(ErrorKind::Resolve(ResolutionFailure::NoParentItem));\n     };\n     let parent_def = Res::Def(DefKind::Enum, parent);\n     let variant = cx.tcx.expect_variant_res(res);"}, {"sha": "4ae53e83613e06603a6960862f1747aea47ac5c7", "filename": "src/test/rustdoc-ui/deny-intra-link-resolution-failure.stderr", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/3797f29aadb51ed038e8b9eaf1b2098cfa26d547/src%2Ftest%2Frustdoc-ui%2Fdeny-intra-link-resolution-failure.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/3797f29aadb51ed038e8b9eaf1b2098cfa26d547/src%2Ftest%2Frustdoc-ui%2Fdeny-intra-link-resolution-failure.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc-ui%2Fdeny-intra-link-resolution-failure.stderr?ref=3797f29aadb51ed038e8b9eaf1b2098cfa26d547", "patch": "@@ -2,13 +2,14 @@ error: unresolved link to `v2`\n   --> $DIR/deny-intra-link-resolution-failure.rs:3:6\n    |\n LL | /// [v2]\n-   |      ^^ unresolved link\n+   |      ^^\n    |\n note: the lint level is defined here\n   --> $DIR/deny-intra-link-resolution-failure.rs:1:9\n    |\n LL | #![deny(broken_intra_doc_links)]\n    |         ^^^^^^^^^^^^^^^^^^^^^^\n+   = note: no item named `v2` is in scope\n    = help: to escape `[` and `]` characters, add '\\' before them like `\\[` or `\\]`\n \n error: aborting due to previous error"}, {"sha": "f5eb3a15abcc730c331b846c71c15d167e289b15", "filename": "src/test/rustdoc-ui/intra-doc-alias-ice.stderr", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/3797f29aadb51ed038e8b9eaf1b2098cfa26d547/src%2Ftest%2Frustdoc-ui%2Fintra-doc-alias-ice.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/3797f29aadb51ed038e8b9eaf1b2098cfa26d547/src%2Ftest%2Frustdoc-ui%2Fintra-doc-alias-ice.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc-ui%2Fintra-doc-alias-ice.stderr?ref=3797f29aadb51ed038e8b9eaf1b2098cfa26d547", "patch": "@@ -2,14 +2,15 @@ error: unresolved link to `TypeAlias::hoge`\n   --> $DIR/intra-doc-alias-ice.rs:5:30\n    |\n LL | /// [broken cross-reference](TypeAlias::hoge)\n-   |                              ^^^^^^^^^^^^^^^ unresolved link\n+   |                              ^^^^^^^^^^^^^^^\n    |\n note: the lint level is defined here\n   --> $DIR/intra-doc-alias-ice.rs:1:9\n    |\n LL | #![deny(broken_intra_doc_links)]\n    |         ^^^^^^^^^^^^^^^^^^^^^^\n-   = help: to escape `[` and `]` characters, add '\\' before them like `\\[` or `\\]`\n+   = note: this link partially resolves to the type alias `TypeAlias`,\n+   = note: `TypeAlias` has no field, variant, or associated item named `hoge`\n \n error: aborting due to previous error\n "}, {"sha": "7a53a6f079334ad6f148de9fb3280e1b36d741f8", "filename": "src/test/rustdoc-ui/intra-link-errors.rs", "status": "added", "additions": 59, "deletions": 0, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/3797f29aadb51ed038e8b9eaf1b2098cfa26d547/src%2Ftest%2Frustdoc-ui%2Fintra-link-errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3797f29aadb51ed038e8b9eaf1b2098cfa26d547/src%2Ftest%2Frustdoc-ui%2Fintra-link-errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc-ui%2Fintra-link-errors.rs?ref=3797f29aadb51ed038e8b9eaf1b2098cfa26d547", "patch": "@@ -0,0 +1,59 @@\n+#![deny(broken_intra_doc_links)]\n+//~^ NOTE lint level is defined\n+\n+//! [std::io::oops]\n+//! [std::io::oops::not::here]\n+\n+// FIXME: this should say that it was skipped (maybe an allowed by default lint?)\n+/// [<invalid syntax>]\n+\n+// FIXME: this could say which path was the first to not be found (in this case, `path`)\n+/// [path::to::nonexistent::module]\n+//~^ ERROR unresolved link\n+//~| NOTE no item named `path::to::nonexistent` is in scope\n+//~| HELP to escape\n+\n+// TODO: why does this say `f` and not `f::A`??\n+/// [f::A]\n+//~^ ERROR unresolved link\n+//~| NOTE no item named `f` is in scope\n+//~| HELP to escape\n+\n+/// [S::A]\n+//~^ ERROR unresolved link\n+//~| NOTE this link partially resolves\n+//~| NOTE `S` has no field\n+\n+/// [S::fmt]\n+//~^ ERROR unresolved link\n+//~| NOTE this link partially resolves\n+//~| NOTE `S` has no field\n+\n+/// [E::D]\n+//~^ ERROR unresolved link\n+//~| NOTE this link partially resolves\n+//~| NOTE `E` has no field\n+\n+/// [u8::not_found]\n+//~^ ERROR unresolved link\n+//~| NOTE the builtin type `u8` does not have an associated item named `not_found`\n+\n+/// [S!]\n+//~^ ERROR unresolved link\n+//~| HELP to link to the unit struct, use its disambiguator\n+//~| NOTE this link resolves to the unit struct `S`\n+pub fn f() {}\n+#[derive(Debug)]\n+pub struct S;\n+\n+pub enum E { A, B, C }\n+\n+/// [type@S::h]\n+impl S {\n+    pub fn h() {}\n+}\n+\n+/// [type@T::g]\n+pub trait T {\n+    fn g() {}\n+}"}, {"sha": "249b27cd878945395780eeeeefc9d72bba6454c2", "filename": "src/test/rustdoc-ui/intra-link-errors.stderr", "status": "added", "additions": 68, "deletions": 0, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/3797f29aadb51ed038e8b9eaf1b2098cfa26d547/src%2Ftest%2Frustdoc-ui%2Fintra-link-errors.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/3797f29aadb51ed038e8b9eaf1b2098cfa26d547/src%2Ftest%2Frustdoc-ui%2Fintra-link-errors.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc-ui%2Fintra-link-errors.stderr?ref=3797f29aadb51ed038e8b9eaf1b2098cfa26d547", "patch": "@@ -0,0 +1,68 @@\n+error: unresolved link to `path::to::nonexistent::module`\n+  --> $DIR/intra-link-errors.rs:8:6\n+   |\n+LL | /// [path::to::nonexistent::module]\n+   |      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+note: the lint level is defined here\n+  --> $DIR/intra-link-errors.rs:1:9\n+   |\n+LL | #![deny(broken_intra_doc_links)]\n+   |         ^^^^^^^^^^^^^^^^^^^^^^\n+   = note: no item named `path::to::nonexistent` is in scope\n+   = help: to escape `[` and `]` characters, add '\\' before them like `\\[` or `\\]`\n+\n+error: unresolved link to `f::A`\n+  --> $DIR/intra-link-errors.rs:14:6\n+   |\n+LL | /// [f::A]\n+   |      ^^^^\n+   |\n+   = note: no item named `f` is in scope\n+   = help: to escape `[` and `]` characters, add '\\' before them like `\\[` or `\\]`\n+\n+error: unresolved link to `S::A`\n+  --> $DIR/intra-link-errors.rs:19:6\n+   |\n+LL | /// [S::A]\n+   |      ^^^^\n+   |\n+   = note: this link partially resolves to the struct `S`,\n+   = note: `S` has no field, variant, or associated item named `A`\n+\n+error: unresolved link to `S::fmt`\n+  --> $DIR/intra-link-errors.rs:24:6\n+   |\n+LL | /// [S::fmt]\n+   |      ^^^^^^\n+   |\n+   = note: this link partially resolves to the struct `S`,\n+   = note: `S` has no field, variant, or associated item named `fmt`\n+\n+error: unresolved link to `E::D`\n+  --> $DIR/intra-link-errors.rs:29:6\n+   |\n+LL | /// [E::D]\n+   |      ^^^^\n+   |\n+   = note: this link partially resolves to the enum `E`,\n+   = note: `E` has no field, variant, or associated item named `D`\n+\n+error: unresolved link to `u8::not_found`\n+  --> $DIR/intra-link-errors.rs:34:6\n+   |\n+LL | /// [u8::not_found]\n+   |      ^^^^^^^^^^^^^\n+   |\n+   = note: the builtin type `u8` does not have an associated item named `not_found`\n+\n+error: unresolved link to `S`\n+  --> $DIR/intra-link-errors.rs:38:6\n+   |\n+LL | /// [S!]\n+   |      ^^ help: to link to the unit struct, use its disambiguator: `value@S`\n+   |\n+   = note: this link resolves to the unit struct `S`, which is not in the value namespace\n+\n+error: aborting due to 7 previous errors\n+"}, {"sha": "47b6a08baf37d2f2c35b443732cec51fcb354053", "filename": "src/test/rustdoc-ui/intra-link-span-ice-55723.stderr", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/3797f29aadb51ed038e8b9eaf1b2098cfa26d547/src%2Ftest%2Frustdoc-ui%2Fintra-link-span-ice-55723.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/3797f29aadb51ed038e8b9eaf1b2098cfa26d547/src%2Ftest%2Frustdoc-ui%2Fintra-link-span-ice-55723.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc-ui%2Fintra-link-span-ice-55723.stderr?ref=3797f29aadb51ed038e8b9eaf1b2098cfa26d547", "patch": "@@ -2,13 +2,14 @@ error: unresolved link to `i`\n   --> $DIR/intra-link-span-ice-55723.rs:9:10\n    |\n LL | /// \uff08arr[i]\uff09\n-   |           ^ unresolved link\n+   |           ^\n    |\n note: the lint level is defined here\n   --> $DIR/intra-link-span-ice-55723.rs:1:9\n    |\n LL | #![deny(broken_intra_doc_links)]\n    |         ^^^^^^^^^^^^^^^^^^^^^^\n+   = note: no item named `i` is in scope\n    = help: to escape `[` and `]` characters, add '\\' before them like `\\[` or `\\]`\n \n error: aborting due to previous error"}, {"sha": "1da27b786180f8f538f3fe24cbef57fb1d43eab1", "filename": "src/test/rustdoc-ui/intra-links-warning-crlf.stderr", "status": "modified", "additions": 8, "deletions": 4, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/3797f29aadb51ed038e8b9eaf1b2098cfa26d547/src%2Ftest%2Frustdoc-ui%2Fintra-links-warning-crlf.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/3797f29aadb51ed038e8b9eaf1b2098cfa26d547/src%2Ftest%2Frustdoc-ui%2Fintra-links-warning-crlf.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc-ui%2Fintra-links-warning-crlf.stderr?ref=3797f29aadb51ed038e8b9eaf1b2098cfa26d547", "patch": "@@ -2,33 +2,37 @@ warning: unresolved link to `error`\n   --> $DIR/intra-links-warning-crlf.rs:7:6\n    |\n LL | /// [error]\n-   |      ^^^^^ unresolved link\n+   |      ^^^^^\n    |\n    = note: `#[warn(broken_intra_doc_links)]` on by default\n+   = note: no item named `error` is in scope\n    = help: to escape `[` and `]` characters, add '\\' before them like `\\[` or `\\]`\n \n warning: unresolved link to `error1`\n   --> $DIR/intra-links-warning-crlf.rs:12:11\n    |\n LL | /// docs [error1]\n-   |           ^^^^^^ unresolved link\n+   |           ^^^^^^\n    |\n+   = note: no item named `error1` is in scope\n    = help: to escape `[` and `]` characters, add '\\' before them like `\\[` or `\\]`\n \n warning: unresolved link to `error2`\n   --> $DIR/intra-links-warning-crlf.rs:15:11\n    |\n LL | /// docs [error2]\n-   |           ^^^^^^ unresolved link\n+   |           ^^^^^^\n    |\n+   = note: no item named `error2` is in scope\n    = help: to escape `[` and `]` characters, add '\\' before them like `\\[` or `\\]`\n \n warning: unresolved link to `error`\n   --> $DIR/intra-links-warning-crlf.rs:23:20\n    |\n LL |  * It also has an [error].\n-   |                    ^^^^^ unresolved link\n+   |                    ^^^^^\n    |\n+   = note: no item named `error` is in scope\n    = help: to escape `[` and `]` characters, add '\\' before them like `\\[` or `\\]`\n \n warning: 4 warnings emitted"}, {"sha": "f728d3919e670f3ea546af0caa3941abe2a2b95e", "filename": "src/test/rustdoc-ui/intra-links-warning.stderr", "status": "modified", "additions": 34, "deletions": 15, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/3797f29aadb51ed038e8b9eaf1b2098cfa26d547/src%2Ftest%2Frustdoc-ui%2Fintra-links-warning.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/3797f29aadb51ed038e8b9eaf1b2098cfa26d547/src%2Ftest%2Frustdoc-ui%2Fintra-links-warning.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc-ui%2Fintra-links-warning.stderr?ref=3797f29aadb51ed038e8b9eaf1b2098cfa26d547", "patch": "@@ -2,73 +2,82 @@ warning: unresolved link to `Foo::baz`\n   --> $DIR/intra-links-warning.rs:3:23\n    |\n LL |        //! Test with [Foo::baz], [Bar::foo], ...\n-   |                       ^^^^^^^^ unresolved link\n+   |                       ^^^^^^^^\n    |\n    = note: `#[warn(broken_intra_doc_links)]` on by default\n-   = help: to escape `[` and `]` characters, add '\\' before them like `\\[` or `\\]`\n+   = note: this link partially resolves to the struct `Foo`,\n+   = note: `Foo` has no field, variant, or associated item named `baz`\n \n warning: unresolved link to `Bar::foo`\n   --> $DIR/intra-links-warning.rs:3:35\n    |\n LL |        //! Test with [Foo::baz], [Bar::foo], ...\n-   |                                   ^^^^^^^^ unresolved link\n+   |                                   ^^^^^^^^\n    |\n+   = note: no item named `Bar` is in scope\n    = help: to escape `[` and `]` characters, add '\\' before them like `\\[` or `\\]`\n \n warning: unresolved link to `Uniooon::X`\n   --> $DIR/intra-links-warning.rs:6:13\n    |\n LL |      //! , [Uniooon::X] and [Qux::Z].\n-   |             ^^^^^^^^^^ unresolved link\n+   |             ^^^^^^^^^^\n    |\n+   = note: no item named `Uniooon` is in scope\n    = help: to escape `[` and `]` characters, add '\\' before them like `\\[` or `\\]`\n \n warning: unresolved link to `Qux::Z`\n   --> $DIR/intra-links-warning.rs:6:30\n    |\n LL |      //! , [Uniooon::X] and [Qux::Z].\n-   |                              ^^^^^^ unresolved link\n+   |                              ^^^^^^\n    |\n+   = note: no item named `Qux` is in scope\n    = help: to escape `[` and `]` characters, add '\\' before them like `\\[` or `\\]`\n \n warning: unresolved link to `Uniooon::X`\n   --> $DIR/intra-links-warning.rs:10:14\n    |\n LL |       //! , [Uniooon::X] and [Qux::Z].\n-   |              ^^^^^^^^^^ unresolved link\n+   |              ^^^^^^^^^^\n    |\n+   = note: no item named `Uniooon` is in scope\n    = help: to escape `[` and `]` characters, add '\\' before them like `\\[` or `\\]`\n \n warning: unresolved link to `Qux::Z`\n   --> $DIR/intra-links-warning.rs:10:31\n    |\n LL |       //! , [Uniooon::X] and [Qux::Z].\n-   |                               ^^^^^^ unresolved link\n+   |                               ^^^^^^\n    |\n+   = note: no item named `Qux` is in scope\n    = help: to escape `[` and `]` characters, add '\\' before them like `\\[` or `\\]`\n \n warning: unresolved link to `Qux:Y`\n   --> $DIR/intra-links-warning.rs:14:13\n    |\n LL |        /// [Qux:Y]\n-   |             ^^^^^ unresolved link\n+   |             ^^^^^\n    |\n+   = note: no item named `Qux:Y` is in scope\n    = help: to escape `[` and `]` characters, add '\\' before them like `\\[` or `\\]`\n \n warning: unresolved link to `error`\n   --> $DIR/intra-links-warning.rs:58:30\n    |\n LL |  * time to introduce a link [error]*/\n-   |                              ^^^^^ unresolved link\n+   |                              ^^^^^\n    |\n+   = note: no item named `error` is in scope\n    = help: to escape `[` and `]` characters, add '\\' before them like `\\[` or `\\]`\n \n warning: unresolved link to `error`\n   --> $DIR/intra-links-warning.rs:64:30\n    |\n LL |  * time to introduce a link [error]\n-   |                              ^^^^^ unresolved link\n+   |                              ^^^^^\n    |\n+   = note: no item named `error` is in scope\n    = help: to escape `[` and `]` characters, add '\\' before them like `\\[` or `\\]`\n \n warning: unresolved link to `error`\n@@ -81,6 +90,7 @@ LL | #[doc = \"single line [error]\"]\n            \n            single line [error]\n                         ^^^^^\n+   = note: no item named `error` is in scope\n    = help: to escape `[` and `]` characters, add '\\' before them like `\\[` or `\\]`\n \n warning: unresolved link to `error`\n@@ -93,6 +103,7 @@ LL | #[doc = \"single line with \\\"escaping\\\" [error]\"]\n            \n            single line with \"escaping\" [error]\n                                         ^^^^^\n+   = note: no item named `error` is in scope\n    = help: to escape `[` and `]` characters, add '\\' before them like `\\[` or `\\]`\n \n warning: unresolved link to `error`\n@@ -107,46 +118,52 @@ LL | | /// [error]\n            \n            [error]\n             ^^^^^\n+   = note: no item named `error` is in scope\n    = help: to escape `[` and `]` characters, add '\\' before them like `\\[` or `\\]`\n \n warning: unresolved link to `error1`\n   --> $DIR/intra-links-warning.rs:80:11\n    |\n LL | /// docs [error1]\n-   |           ^^^^^^ unresolved link\n+   |           ^^^^^^\n    |\n+   = note: no item named `error1` is in scope\n    = help: to escape `[` and `]` characters, add '\\' before them like `\\[` or `\\]`\n \n warning: unresolved link to `error2`\n   --> $DIR/intra-links-warning.rs:82:11\n    |\n LL | /// docs [error2]\n-   |           ^^^^^^ unresolved link\n+   |           ^^^^^^\n    |\n+   = note: no item named `error2` is in scope\n    = help: to escape `[` and `]` characters, add '\\' before them like `\\[` or `\\]`\n \n warning: unresolved link to `BarA`\n   --> $DIR/intra-links-warning.rs:21:10\n    |\n LL | /// bar [BarA] bar\n-   |          ^^^^ unresolved link\n+   |          ^^^^\n    |\n+   = note: no item named `BarA` is in scope\n    = help: to escape `[` and `]` characters, add '\\' before them like `\\[` or `\\]`\n \n warning: unresolved link to `BarB`\n   --> $DIR/intra-links-warning.rs:27:9\n    |\n LL |  * bar [BarB] bar\n-   |         ^^^^ unresolved link\n+   |         ^^^^\n    |\n+   = note: no item named `BarB` is in scope\n    = help: to escape `[` and `]` characters, add '\\' before them like `\\[` or `\\]`\n \n warning: unresolved link to `BarC`\n   --> $DIR/intra-links-warning.rs:34:6\n    |\n LL | bar [BarC] bar\n-   |      ^^^^ unresolved link\n+   |      ^^^^\n    |\n+   = note: no item named `BarC` is in scope\n    = help: to escape `[` and `]` characters, add '\\' before them like `\\[` or `\\]`\n \n warning: unresolved link to `BarD`\n@@ -159,6 +176,7 @@ LL | #[doc = \"Foo\\nbar [BarD] bar\\nbaz\"]\n            \n            bar [BarD] bar\n                 ^^^^\n+   = note: no item named `BarD` is in scope\n    = help: to escape `[` and `]` characters, add '\\' before them like `\\[` or `\\]`\n \n warning: unresolved link to `BarF`\n@@ -174,6 +192,7 @@ LL | f!(\"Foo\\nbar [BarF] bar\\nbaz\");\n            \n            bar [BarF] bar\n                 ^^^^\n+   = note: no item named `BarF` is in scope\n    = help: to escape `[` and `]` characters, add '\\' before them like `\\[` or `\\]`\n    = note: this warning originates in a macro (in Nightly builds, run with -Z macro-backtrace for more info)\n "}]}