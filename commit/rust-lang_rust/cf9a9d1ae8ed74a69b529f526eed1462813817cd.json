{"sha": "cf9a9d1ae8ed74a69b529f526eed1462813817cd", "node_id": "MDY6Q29tbWl0NzI0NzEyOmNmOWE5ZDFhZThlZDc0YTY5YjUyOWY1MjZlZWQxNDYyODEzODE3Y2Q=", "commit": {"author": {"name": "Tim Chevalier", "email": "chevalier@alum.wellesley.edu", "date": "2012-07-17T02:14:55Z"}, "committer": {"name": "Tim Chevalier", "email": "chevalier@alum.wellesley.edu", "date": "2012-07-17T19:40:58Z"}, "message": "Remove most of old resolve\n\nresolve has a few type definitions in it that are used, so I left\nthose and deleted everything else. Also, I switched rustdoc to use\nresolve3 instead of the old resolve.\n\nIn a future commit I'll remove the type definitions entirely, as they're\njust duplicates of types defined in resolve3.", "tree": {"sha": "e2422f7e1b53e18461875b83875c4bcc7f41d95b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e2422f7e1b53e18461875b83875c4bcc7f41d95b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/cf9a9d1ae8ed74a69b529f526eed1462813817cd", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/cf9a9d1ae8ed74a69b529f526eed1462813817cd", "html_url": "https://github.com/rust-lang/rust/commit/cf9a9d1ae8ed74a69b529f526eed1462813817cd", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/cf9a9d1ae8ed74a69b529f526eed1462813817cd/comments", "author": {"login": "catamorphism", "id": 427212, "node_id": "MDQ6VXNlcjQyNzIxMg==", "avatar_url": "https://avatars.githubusercontent.com/u/427212?v=4", "gravatar_id": "", "url": "https://api.github.com/users/catamorphism", "html_url": "https://github.com/catamorphism", "followers_url": "https://api.github.com/users/catamorphism/followers", "following_url": "https://api.github.com/users/catamorphism/following{/other_user}", "gists_url": "https://api.github.com/users/catamorphism/gists{/gist_id}", "starred_url": "https://api.github.com/users/catamorphism/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/catamorphism/subscriptions", "organizations_url": "https://api.github.com/users/catamorphism/orgs", "repos_url": "https://api.github.com/users/catamorphism/repos", "events_url": "https://api.github.com/users/catamorphism/events{/privacy}", "received_events_url": "https://api.github.com/users/catamorphism/received_events", "type": "User", "site_admin": false}, "committer": {"login": "catamorphism", "id": 427212, "node_id": "MDQ6VXNlcjQyNzIxMg==", "avatar_url": "https://avatars.githubusercontent.com/u/427212?v=4", "gravatar_id": "", "url": "https://api.github.com/users/catamorphism", "html_url": "https://github.com/catamorphism", "followers_url": "https://api.github.com/users/catamorphism/followers", "following_url": "https://api.github.com/users/catamorphism/following{/other_user}", "gists_url": "https://api.github.com/users/catamorphism/gists{/gist_id}", "starred_url": "https://api.github.com/users/catamorphism/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/catamorphism/subscriptions", "organizations_url": "https://api.github.com/users/catamorphism/orgs", "repos_url": "https://api.github.com/users/catamorphism/repos", "events_url": "https://api.github.com/users/catamorphism/events{/privacy}", "received_events_url": "https://api.github.com/users/catamorphism/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "bc87e66355e658cffb84396d1783364e23ddc6d2", "url": "https://api.github.com/repos/rust-lang/rust/commits/bc87e66355e658cffb84396d1783364e23ddc6d2", "html_url": "https://github.com/rust-lang/rust/commit/bc87e66355e658cffb84396d1783364e23ddc6d2"}], "stats": {"total": 2347, "additions": 11, "deletions": 2336}, "files": [{"sha": "251b0368910f760c8310647ac185bac59ea8385c", "filename": "src/rustc/middle/liveness.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cf9a9d1ae8ed74a69b529f526eed1462813817cd/src%2Frustc%2Fmiddle%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf9a9d1ae8ed74a69b529f526eed1462813817cd/src%2Frustc%2Fmiddle%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fliveness.rs?ref=cf9a9d1ae8ed74a69b529f526eed1462813817cd", "patch": "@@ -360,7 +360,7 @@ fn visit_fn(fk: visit::fn_kind, decl: fn_decl, body: blk,\n     visit::visit_fn(fk, decl, body, sp, id, fn_maps, v);\n \n     alt fk {\n-      visit::fk_ctor(_, _, _, class_did) {\n+      visit::fk_ctor(_, _, _, _, class_did) {\n         add_class_fields(fn_maps, class_did);\n       }\n       _ {}"}, {"sha": "a7ffc9cd26d82b78a602b706ac7b7bf74a852ac4", "filename": "src/rustc/middle/resolve.rs", "status": "modified", "additions": 2, "deletions": 2331, "changes": 2333, "blob_url": "https://github.com/rust-lang/rust/blob/cf9a9d1ae8ed74a69b529f526eed1462813817cd/src%2Frustc%2Fmiddle%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf9a9d1ae8ed74a69b529f526eed1462813817cd/src%2Frustc%2Fmiddle%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fresolve.rs?ref=cf9a9d1ae8ed74a69b529f526eed1462813817cd", "patch": "@@ -31,82 +31,6 @@ export _impl, iscopes, method_info;\n // locates all names (in expressions, types, and alt patterns) and resolves\n // them, storing the resulting def in the AST nodes.\n \n-enum scope {\n-    scope_toplevel,\n-    scope_crate,\n-    scope_item(@ast::item),\n-    scope_bare_fn(ast::fn_decl, node_id, ~[ast::ty_param]),\n-    scope_fn_expr(ast::fn_decl, node_id, ~[ast::ty_param]),\n-    scope_foreign_item(@ast::foreign_item),\n-    scope_loop(@ast::local), // there's only 1 decl per loop.\n-    scope_block(ast::blk, @mut uint, @mut uint),\n-    scope_arm(ast::arm),\n-    scope_method(node_id, ~[ast::ty_param]),\n-}\n-\n-type scopes = @list<scope>;\n-\n-fn top_scope() -> scopes {\n-    @cons(scope_crate, @cons(scope_toplevel, @nil))\n-}\n-\n-enum import_state {\n-    todo(ast::ident, @~[ast::ident], span, scopes),\n-    is_glob(@~[ast::ident], scopes, span),\n-    resolving(span),\n-    resolved(option<def>, /* value */\n-             option<def>, /* type */\n-             option<def>, /* module */\n-             @~[@_impl], /* impls */\n-             /* used for reporting unused import warning */\n-             ast::ident, span),\n-}\n-\n-enum glob_import_state {\n-    glob_resolving(span),\n-    glob_resolved(option<def>,  /* value */\n-                  option<def>,  /* type */\n-                  option<def>), /* module */\n-}\n-\n-type ext_hash = hashmap<{did: def_id, ident: ast::ident, ns: namespace}, def>;\n-\n-fn new_ext_hash() -> ext_hash {\n-    type key = {did: def_id, ident: ast::ident, ns: namespace};\n-    fn hash(v: key) -> uint {\n-        str::hash(*v.ident) + ast_util::hash_def(v.did) + v.ns as uint\n-    }\n-    fn eq(v1: key, v2: key) -> bool {\n-        ret ast_util::def_eq(v1.did, v2.did) &&\n-            str::eq(*v1.ident, *v2.ident) && v1.ns == v2.ns;\n-    }\n-    std::map::hashmap(hash, |a, b| a == b)\n-}\n-\n-enum mod_index_entry {\n-    mie_view_item(ident, node_id, span),\n-    mie_import_ident(node_id, span),\n-    mie_item(@ast::item),\n-    mie_foreign_item(@ast::foreign_item),\n-    mie_enum_variant(/* variant index */uint,\n-                     /*parts of enum item*/ ~[variant],\n-                    node_id, span),\n-}\n-\n-type mod_index = hashmap<ident, @list<mod_index_entry>>;\n-\n-// A tuple of an imported def and the view_path from its originating import\n-type glob_imp_def = {def: def, path: @ast::view_path};\n-\n-type indexed_mod = {\n-    m: option<ast::_mod>,\n-    index: mod_index,\n-    glob_imports: dvec<glob_imp_def>,\n-    mut globbed_exports: ~[ident],\n-    glob_imported_names: hashmap<ident, glob_import_state>,\n-    path: ~str\n-};\n-\n /* foreign modules can't contain enums, and we don't store their ASTs because\n    we only need to look at them to determine exports, which they can't\n    control.*/\n@@ -116,2047 +40,6 @@ type ext_map = hashmap<def_id, ~[ident]>;\n type impl_map = hashmap<node_id, iscopes>;\n type impl_cache = hashmap<def_id, option<@~[@_impl]>>;\n \n-type exp = {reexp: bool, id: def_id};\n-type exp_map = hashmap<node_id, ~[exp]>;\n-\n-type env =\n-    {cstore: cstore::cstore,\n-     def_map: def_map,\n-     ast_map: ast_map::map,\n-     imports: hashmap<node_id, import_state>,\n-     exp_map: exp_map,\n-     mod_map: hashmap<node_id, @indexed_mod>,\n-     block_map: hashmap<node_id, ~[glob_imp_def]>,\n-     ext_map: ext_map,\n-     impl_map: impl_map,\n-     impl_cache: impl_cache,\n-     ext_cache: ext_hash,\n-     used_imports: {mut track: bool,\n-                    mut data: ~[node_id]},\n-     reported: dvec<{ident: ast::ident, sc: scope}>,\n-     mut ignored_imports: ~[node_id],\n-     mut current_tp: option<uint>,\n-     mut resolve_unexported: bool,\n-     sess: session};\n-\n-\n-// Used to distinguish between lookups from outside and from inside modules,\n-// since export restrictions should only be applied for the former.\n-enum dir { inside, outside, }\n-\n-enum namespace { ns_val, ns_type, ns_module, }\n-\n-fn resolve_crate(sess: session, amap: ast_map::map, crate: @ast::crate) ->\n-   {def_map: def_map, exp_map: exp_map, impl_map: impl_map} {\n-    let e = create_env(sess, amap);\n-    map_crate(e, crate);\n-    resolve_imports(*e);\n-    check_exports(e);\n-    resolve_names(e, crate);\n-    resolve_impls(e, crate);\n-    // check_for_collisions must happen after resolve_names so we\n-    // don't complain if a pattern uses the same nullary enum twice\n-    check_for_collisions(e, *crate);\n-\n-    // FIXME: move this to the lint pass when rewriting resolve. (#1634)\n-    for sess.opts.lint_opts.each |pair| {\n-        let (lint,level) = pair;\n-        if lint == lint::unused_imports && level != lint::ignore {\n-            check_unused_imports(e, level);\n-            break;\n-        }\n-    }\n-\n-    ret {def_map: e.def_map, exp_map: e.exp_map, impl_map: e.impl_map};\n-}\n-\n-fn create_env(sess: session, amap: ast_map::map) -> @env {\n-    @{cstore: sess.cstore,\n-      def_map: int_hash(),\n-      ast_map: amap,\n-      imports: int_hash(),\n-      exp_map: int_hash(),\n-      mod_map: int_hash(),\n-      block_map: int_hash(),\n-      ext_map: new_def_hash(),\n-      impl_map: int_hash(),\n-      impl_cache: new_def_hash(),\n-      ext_cache: new_ext_hash(),\n-      used_imports: {mut track: false, mut data:  ~[]},\n-      reported: dvec(),\n-      mut ignored_imports: ~[],\n-      mut current_tp: none,\n-      mut resolve_unexported: false,\n-      sess: sess}\n-}\n-\n-fn iter_export_paths(vi: ast::view_item, f: fn(vp: @ast::view_path)) {\n-    alt vi.node {\n-      ast::view_item_export(vps) {\n-        for vps.each |vp| {\n-            f(vp);\n-        }\n-      }\n-      _ {}\n-    }\n-}\n-\n-fn iter_import_paths(vi: ast::view_item, f: fn(vp: @ast::view_path)) {\n-    alt vi.node {\n-      ast::view_item_import(vps) {\n-        for vps.each |vp| { f(vp);}\n-      }\n-      _ {}\n-    }\n-}\n-\n-fn iter_effective_import_paths(vi: ast::view_item,\n-                               f: fn(vp: @ast::view_path)) {\n-    iter_import_paths(vi, f);\n-    do iter_export_paths(vi) |vp| {\n-        alt vp.node {\n-          ast::view_path_simple(_, _, _) { }\n-          // FIXME (but also see #1893): support uniform ident-list exports\n-          // eventually; at the moment they have half a meaning as reaching\n-          // into tags.\n-          ast::view_path_list(_, _, _) {}\n-          ast::view_path_glob(_,_) {\n-            f(vp);\n-          }\n-        }\n-    }\n-}\n-\n-// Locate all modules and imports and index them, so that the next passes can\n-// resolve through them.\n-fn map_crate(e: @env, c: @ast::crate) {\n-\n-    fn index_vi(e: @env, i: @ast::view_item, &&sc: scopes, _v: vt<scopes>) {\n-        do iter_effective_import_paths(*i) |vp| {\n-            alt vp.node {\n-              ast::view_path_simple(name, path, id) {\n-                e.imports.insert(id, todo(name, @path.idents, vp.span,\n-                                          sc));\n-              }\n-              ast::view_path_glob(path, id) {\n-                e.imports.insert(id, is_glob(@path.idents, sc, vp.span));\n-              }\n-              ast::view_path_list(mod_path, idents, _) {\n-                for idents.each |ident| {\n-                    let t = todo(ident.node.name,\n-                                 @(vec::append_one(mod_path.idents,\n-                                                   ident.node.name)),\n-                                 ident.span, sc);\n-                    e.imports.insert(ident.node.id, t);\n-                }\n-              }\n-            }\n-        }\n-    }\n-\n-    fn path_from_scope(sc: scopes, n: ~str) -> ~str {\n-        let mut path = n + ~\"::\";\n-        do list::iter(sc) |s| {\n-            alt s {\n-              scope_item(i) { path = *i.ident + ~\"::\" + path; }\n-              _ {}\n-            }\n-        }\n-        path\n-    }\n-\n-    fn index_i(e: @env, i: @ast::item, &&sc: scopes, v: vt<scopes>) {\n-        visit_item_with_scope(e, i, sc, v);\n-        alt i.node {\n-          ast::item_mod(md) {\n-            e.mod_map.insert(i.id,\n-                             @{m: some(md),\n-                               index: index_mod(md),\n-                               glob_imports: dvec(),\n-                               mut globbed_exports: ~[],\n-                               glob_imported_names: box_str_hash(),\n-                               path: path_from_scope(sc, *i.ident)});\n-          }\n-          ast::item_foreign_mod(nmd) {\n-            e.mod_map.insert(i.id,\n-                             @{m: none::<ast::_mod>,\n-                               index: index_nmod(nmd),\n-                               glob_imports: dvec(),\n-                               mut globbed_exports: ~[],\n-                               glob_imported_names: box_str_hash(),\n-                               path: path_from_scope(sc, *i.ident)});\n-          }\n-          _ { }\n-        }\n-    }\n-\n-    // Note: a glob export works as an implicit import, along with a\n-    // re-export of anything that was exported at the glob-target location.\n-    // So we wind up reusing the glob-import machinery when looking at\n-    // glob exports. They just do re-exporting in a later step.\n-    fn link_glob(e: @env, vi: @ast::view_item, &&sc: scopes, _v: vt<scopes>) {\n-        do iter_effective_import_paths(*vi) |vp| {\n-            alt vp.node {\n-              ast::view_path_glob(path, _) {\n-                alt follow_import(*e, sc, path.idents, vp.span) {\n-                  some(imp) {\n-                    let glob = {def: imp, path: vp};\n-                    alt list::head(sc) {\n-                      scope_item(i) {\n-                        e.mod_map.get(i.id).glob_imports.push(glob);\n-                      }\n-                      scope_block(b, _, _) {\n-                        let globs = alt e.block_map.find(b.node.id) {\n-                          some(globs) { vec::append_one(globs, glob) }\n-                          none { ~[glob] }\n-                        };\n-                        e.block_map.insert(b.node.id, globs);\n-                      }\n-                      scope_crate {\n-                        e.mod_map.get(ast::crate_node_id).\n-                            glob_imports.push(glob);\n-                      }\n-                      _ { e.sess.span_bug(vi.span, ~\"unexpected scope in a \\\n-                                                    glob import\"); }\n-                    }\n-                  }\n-                  _ { }\n-                }\n-              }\n-              _ { }\n-            }\n-        }\n-    }\n-\n-    // First, find all the modules, and index the names that they contain\n-    let v_map_mod =\n-        @{visit_view_item: |a,b,c| index_vi(e, a, b, c),\n-          visit_item: |a,b,c| index_i(e, a, b, c),\n-          visit_block: visit_block_with_scope\n-          with *visit::default_visitor::<scopes>()};\n-    visit::visit_crate(*c, top_scope(), visit::mk_vt(v_map_mod));\n-\n-    // Register the top-level mod\n-    e.mod_map.insert(ast::crate_node_id,\n-                     @{m: some(c.node.module),\n-                       index: index_mod(c.node.module),\n-                       glob_imports: dvec(),\n-                       mut globbed_exports: ~[],\n-                       glob_imported_names: box_str_hash(),\n-                       path: ~\"\"});\n-\n-    // Next, assemble the links for globbed imports and exports.\n-    let v_link_glob =\n-        @{visit_view_item: |a,b,c| link_glob(e, a, b, c),\n-          visit_block: visit_block_with_scope,\n-          visit_item: |a,b,c| visit_item_with_scope(e, a, b, c)\n-          with *visit::default_visitor::<scopes>()};\n-    visit::visit_crate(*c, top_scope(), visit::mk_vt(v_link_glob));\n-\n-}\n-\n-fn resolve_imports(e: env) {\n-    e.used_imports.track = true;\n-    for e.imports.each |id, v| {\n-        alt check v {\n-          todo(name, path, span, scopes) {\n-            resolve_import(e, id, name, *path, span, scopes);\n-          }\n-          resolved(_, _, _, _, _, _) | is_glob(_, _, _) { }\n-        }\n-    }\n-    e.used_imports.track = false;\n-    e.sess.abort_if_errors();\n-}\n-\n-// FIXME (#1634): move this to the lint pass when rewriting resolve. It's\n-// using lint-specific control flags presently but resolve-specific data\n-// structures. Should use the general lint framework (with scopes, attrs).\n-fn check_unused_imports(e: @env, level: lint::level) {\n-    for e.imports.each |k, v| {\n-        alt v {\n-            resolved(_, _, _, _, name, sp) {\n-              if !vec::contains(e.used_imports.data, k) {\n-                  alt level {\n-                    lint::warn {\n-                      e.sess.span_warn(sp, ~\"unused import \" + *name);\n-                    }\n-                    lint::error {\n-                      e.sess.span_err(sp, ~\"unused import \" + *name);\n-                    }\n-                    lint::ignore {\n-                    }\n-                  }\n-              }\n-            }\n-            _ { }\n-        }\n-    };\n-}\n-\n-fn resolve_capture_item(e: @env, sc: scopes, cap_item: ast::capture_item) {\n-    let dcur = lookup_in_scope_strict(\n-        *e, sc, cap_item.span, cap_item.name, ns_val);\n-    maybe_insert(e, cap_item.id, dcur);\n-}\n-\n-fn maybe_insert(e: @env, id: node_id, def: option<def>) {\n-    alt def {\n-       some(df) { e.def_map.insert(id, df); }\n-       _ {}\n-    }\n-}\n-\n-fn resolve_trait_ref(p: @trait_ref, sc: scopes, e: @env) {\n-    maybe_insert(e, p.ref_id,\n-       lookup_path_strict(*e, sc, p.path.span, p.path, ns_type));\n-    maybe_insert(e, p.impl_id,\n-       lookup_path_strict(*e, sc, p.path.span, p.path, ns_type));\n-\n-}\n-\n-fn resolve_names(e: @env, c: @ast::crate) {\n-    e.used_imports.track = true;\n-    let v =\n-        @{visit_foreign_item: visit_foreign_item_with_scope,\n-          visit_item: |a,b,c| walk_item(e, a, b, c),\n-          visit_block: visit_block_with_scope,\n-          visit_decl: visit_decl_with_scope,\n-          visit_arm: visit_arm_with_scope,\n-          visit_local: |a,b,c| visit_local_with_scope(e, a, b, c),\n-          visit_pat: |a,b,c| walk_pat(e, a, b, c),\n-          visit_expr: |a,b,c| walk_expr(e, a, b ,c),\n-          visit_ty: |a,b,c| walk_ty(e, a, b, c),\n-          visit_ty_params: |a,b,c| walk_tps(e, a, b, c),\n-          visit_fn: |a,b,c,d,f,g,h| {\n-              visit_fn_with_scope(e, a, b, c, d, f, g, h)\n-          }\n-          with *visit::default_visitor()};\n-    visit::visit_crate(*c, top_scope(), visit::mk_vt(v));\n-    e.used_imports.track = false;\n-    e.sess.abort_if_errors();\n-\n-    fn walk_item(e: @env, i: @ast::item, &&sc: scopes, v: vt<scopes>) {\n-        visit_item_with_scope(e, i, sc, v);\n-        alt i.node {\n-          /* At this point, the code knows what traits the trait refs\n-             refer to, so it's possible to resolve them.\n-           */\n-          ast::item_impl(_, t, _, _) {\n-            t.iter(|p| resolve_trait_ref(p, sc, e));\n-          }\n-          ast::item_class(_, traits, _, _, _) {\n-            for traits.each |p| {\n-               resolve_trait_ref(p, sc, e);\n-            }\n-          }\n-          _ {}\n-        }\n-    }\n-\n-    fn walk_expr(e: @env, exp: @ast::expr, &&sc: scopes, v: vt<scopes>) {\n-        visit::visit_expr(exp, sc, v);\n-        alt exp.node {\n-          ast::expr_path(p) {\n-            maybe_insert(e, exp.id,\n-                         lookup_path_strict(*e, sc, exp.span, p, ns_val));\n-          }\n-          ast::expr_fn(_, _, _, cap_clause) |\n-          ast::expr_fn_block(_, _, cap_clause) {\n-            for (*cap_clause).each |ci| {\n-                resolve_capture_item(e, sc, ci);\n-            }\n-          }\n-          _ { }\n-        }\n-    }\n-    fn walk_ty(e: @env, t: @ast::ty, &&sc: scopes, v: vt<scopes>) {\n-        visit::visit_ty(t, sc, v);\n-        alt t.node {\n-          ast::ty_path(p, id) {\n-            maybe_insert(e, id,\n-                         lookup_path_strict(*e, sc, t.span, p, ns_type));\n-          }\n-          _ { }\n-        }\n-    }\n-    fn walk_tps(e: @env, tps: ~[ast::ty_param],\n-                &&sc: scopes, v: vt<scopes>) {\n-        let outer_current_tp = e.current_tp;\n-        let mut current = 0u;\n-        for tps.each |tp| {\n-            e.current_tp = some(current);\n-            for vec::each(*tp.bounds) |bound| {\n-                alt bound {\n-                  bound_trait(t) { v.visit_ty(t, sc, v); }\n-                  _ {}\n-                }\n-            }\n-            current += 1u;\n-        }\n-        e.current_tp = outer_current_tp;\n-    }\n-    fn walk_constr(e: @env, p: @ast::path, sp: span, id: node_id,\n-                   &&sc: scopes, _v: vt<scopes>) {\n-        maybe_insert(e, id, lookup_path_strict(*e, sc, sp, p, ns_val));\n-    }\n-    fn walk_pat(e: @env, pat: @ast::pat, &&sc: scopes, v: vt<scopes>) {\n-        visit::visit_pat(pat, sc, v);\n-        alt pat.node {\n-          ast::pat_enum(p, _) {\n-            alt lookup_path_strict(*e, sc, p.span, p, ns_val) {\n-              some(fnd@ast::def_variant(_,_)) {\n-                e.def_map.insert(pat.id, fnd);\n-              }\n-              _ {\n-                e.sess.span_err(p.span,\n-                                ~\"not an enum variant: \" +\n-                                    ast_util::path_name(p));\n-              }\n-            }\n-          }\n-          /* Here we determine whether a given pat_ident binds a new\n-           variable or refers to a nullary enum. */\n-          ast::pat_ident(p, none) {\n-              alt lookup_in_scope(*e, sc, p.span, path_to_ident(p),\n-                                  ns_val, false) {\n-                some(fnd@ast::def_variant(_,_)) {\n-                    e.def_map.insert(pat.id, fnd);\n-                }\n-                some(fnd@ast::def_const(_)) {\n-                    e.sess.span_err(p.span, ~\"pattern variable conflicts \\\n-                       with constant '\" + *path_to_ident(p) + ~\"'\");\n-                }\n-                // Binds a var -- nothing needs to be done\n-                _ {}\n-              }\n-          }\n-          _ { }\n-        }\n-    }\n-}\n-\n-\n-// Visit helper functions\n-/*\n-  This is used in more than one context, thus should only call generic\n-  visit methods. Called both from map_crate and resolve_names.\n- */\n-fn visit_item_with_scope(e: @env, i: @ast::item,\n-                         &&sc: scopes, v: vt<scopes>) {\n-    // Some magic here. Items with the !resolve_unexported attribute\n-    // cause us to consider every name to be exported when resolving their\n-    // contents. This is used to allow the test runner to run unexported\n-    // tests.\n-    let old_resolve_unexported = e.resolve_unexported;\n-    e.resolve_unexported |=\n-        attr::contains_name(attr::attr_metas(i.attrs),\n-                            ~\"!resolve_unexported\");\n-\n-    let sc = @cons(scope_item(i), sc);\n-    alt i.node {\n-      ast::item_impl(tps, ifce, sty, methods) {\n-        v.visit_ty_params(tps, sc, v);\n-        option::iter(ifce, |p| visit::visit_path(p.path, sc, v));\n-        v.visit_ty(sty, sc, v);\n-        for methods.each |m| {\n-            v.visit_ty_params(m.tps, sc, v);\n-            let msc = @cons(scope_method(m.self_id, vec::append(tps, m.tps)),\n-                            sc);\n-            v.visit_fn(visit::fk_method(m.ident, ~[], m),\n-                       m.decl, m.body, m.span, m.id, msc, v);\n-        }\n-      }\n-      ast::item_trait(tps, methods) {\n-        v.visit_ty_params(tps, sc, v);\n-        for methods.each |m| {\n-            visit_trait_method(m, i, tps, sc, v);\n-        }\n-      }\n-      ast::item_class(tps, traits, members, ctor, m_dtor) {\n-        v.visit_ty_params(tps, sc, v);\n-        let class_scope = @cons(scope_item(i), sc);\n-        /* visit the constructor... */\n-        let ctor_scope = @cons(scope_method(ctor.node.self_id, tps),\n-                               class_scope);\n-        /* visit the trait refs in the class scope */\n-        for traits.each |p| {\n-            visit::visit_path(p.path, class_scope, v);\n-        }\n-        visit_fn_with_scope(e, visit::fk_ctor(i.ident, tps, ctor.node.self_id,\n-                                             local_def(i.id)), ctor.node.dec,\n-                            ctor.node.body, ctor.span, ctor.node.id,\n-                            ctor_scope, v);\n-        do option::iter(m_dtor) |dtor| {\n-          let dtor_scope = @cons(scope_method(dtor.node.self_id, tps),\n-                                 class_scope);\n-\n-          visit_fn_with_scope(e, visit::fk_dtor(tps, dtor.node.self_id,\n-                                                local_def(i.id)),\n-                            ast_util::dtor_dec(),\n-                            dtor.node.body, dtor.span, dtor.node.id,\n-                            dtor_scope, v);\n-        };\n-        /* visit the items */\n-        for members.each |cm| {\n-            alt cm.node {\n-              class_method(m) {\n-                  let msc = @cons(scope_method(m.self_id,\n-                                               vec::append(tps, m.tps)),\n-                                  class_scope);\n-                  visit_fn_with_scope(e,\n-                     visit::fk_item_fn(m.ident, tps), m.decl, m.body,\n-                                 m.span, m.id, msc, v); }\n-              instance_var(_,t,_,_,_) { v.visit_ty(t, class_scope, v); }\n-            }\n-        }\n-      }\n-      _ { visit::visit_item(i, sc, v); }\n-    }\n-\n-    e.resolve_unexported = old_resolve_unexported;\n-}\n-\n-fn visit_trait_method(m: trait_method, i: @ast::item,\n-                      tps: ~[ast::ty_param], sc: scopes,\n-                      v: vt<scopes>) {\n-    alt m {\n-      required(ty_m) {\n-        let isc = @cons(scope_method(i.id, tps), sc);\n-        v.visit_ty_params(ty_m.tps, isc, v);\n-        let msc = @cons(scope_method(i.id, vec::append(tps, ty_m.tps)), sc);\n-        for ty_m.decl.inputs.each |a| { v.visit_ty(a.ty, msc, v); }\n-        v.visit_ty(ty_m.decl.output, msc, v);\n-      }\n-      provided(m) {\n-         v.visit_ty_params(m.tps, sc, v);\n-        let msc = @cons(scope_method(m.self_id, vec::append(tps, m.tps)),\n-                        sc);\n-        v.visit_fn(visit::fk_method(m.ident, ~[], m),\n-                   m.decl, m.body, m.span, m.id, msc, v);\n-      }\n-    }\n-}\n-\n-fn visit_foreign_item_with_scope(ni: @ast::foreign_item, &&sc: scopes,\n-                                v: vt<scopes>) {\n-    visit::visit_foreign_item(ni, @cons(scope_foreign_item(ni), sc), v);\n-}\n-\n-fn visit_fn_with_scope(e: @env, fk: visit::fn_kind, decl: ast::fn_decl,\n-                       body: ast::blk, sp: span,\n-                       id: node_id, &&sc: scopes, v: vt<scopes>) {\n-    // is this a main fn declaration?\n-    alt fk {\n-      visit::fk_item_fn(nm, _) {\n-        if is_main_name(~[ast_map::path_name(nm)]) &&\n-           !e.sess.building_library {\n-            // This is a main function -- set it in the session\n-            // as the main ID\n-            e.sess.main_fn = some((id, sp));\n-        }\n-      }\n-      _ { /* fallthrough */ }\n-    }\n-\n-    // here's where we need to set up the mapping\n-    // for f's constrs in the table.\n-    let scope = alt fk {\n-      visit::fk_item_fn(_, tps) | visit::fk_method(_, tps, _)\n-      | visit::fk_ctor(_, tps, _, _) | visit::fk_dtor(tps, _, _) {\n-        scope_bare_fn(decl, id, tps) }\n-      visit::fk_anon(ast::proto_bare, _) {\n-        scope_bare_fn(decl, id, ~[]) }\n-      visit::fk_anon(_, _) | visit::fk_fn_block(_) {\n-        scope_fn_expr(decl, id, ~[]) }\n-    };\n-\n-    visit::visit_fn(fk, decl, body, sp, id, @cons(scope, sc), v);\n-}\n-\n-fn visit_block_with_scope(b: ast::blk, &&sc: scopes, v: vt<scopes>) {\n-    let pos = @mut 0u, loc = @mut 0u;\n-    let block_sc = @cons(scope_block(b, pos, loc), sc);\n-    for b.node.view_items.each |vi| { v.visit_view_item(vi, block_sc, v); }\n-    for b.node.stmts.each |stmt| {\n-        v.visit_stmt(stmt, block_sc, v);;\n-        *pos += 1u;;\n-        *loc = 0u;\n-    }\n-    visit::visit_expr_opt(b.node.expr, block_sc, v);\n-}\n-\n-fn visit_decl_with_scope(d: @decl, &&sc: scopes, v: vt<scopes>) {\n-    let loc_pos = alt list::head(sc) {\n-      scope_block(_, _, pos) { pos }\n-      _ { @mut 0u }\n-    };\n-    alt d.node {\n-      decl_local(locs) {\n-        for locs.each |loc| { v.visit_local(loc, sc, v);; *loc_pos += 1u; }\n-      }\n-      decl_item(it) { v.visit_item(it, sc, v); }\n-    }\n-}\n-\n-fn visit_arm_with_scope(a: ast::arm, &&sc: scopes, v: vt<scopes>) {\n-    for a.pats.each |p| { v.visit_pat(p, sc, v); }\n-    let sc_inner = @cons(scope_arm(a), sc);\n-    visit::visit_expr_opt(a.guard, sc_inner, v);\n-    v.visit_block(a.body, sc_inner, v);\n-}\n-\n-// This is only for irrefutable patterns (e.g. ones that appear in a let)\n-// So if x occurs, and x is already known to be a enum, that's always an error\n-fn visit_local_with_scope(e: @env, loc: @local, &&sc: scopes, v:vt<scopes>) {\n-    // Check whether the given local has the same name as a enum that's in\n-    // scope. We disallow this, in order to make alt patterns consisting of a\n-    // single identifier unambiguous (does the pattern \"foo\" refer to enum\n-    // foo, or is it binding a new name foo?)\n-    do ast_util::walk_pat(loc.node.pat) |p| {\n-        alt p.node {\n-          pat_ident(path, _) {\n-            alt lookup_in_scope(*e, sc, loc.span, path_to_ident(path),\n-                                ns_val, false) {\n-              some(ast::def_variant(enum_id, variant_id)) {\n-                // Declaration shadows an enum that's in scope.\n-                // That's an error.\n-                e.sess.span_err(loc.span,\n-                                #fmt(\"declaration of `%s` shadows an \\\n-                                      enum that's in scope\",\n-                                     *path_to_ident(path)));\n-              }\n-              _ {}\n-            }\n-          }\n-          _ {}\n-        }\n-    }\n-    visit::visit_local(loc, sc, v);\n-}\n-\n-\n-fn follow_import(e: env, &&sc: scopes, path: ~[ident], sp: span) ->\n-   option<def> {\n-    let path_len = vec::len(path);\n-    let mut dcur = lookup_in_scope_strict(e, sc, sp, path[0], ns_module);\n-    let mut i = 1u;\n-    loop {\n-       alt copy dcur {\n-          some(dcur_def) {\n-            if i == path_len { break; }\n-            dcur =\n-                lookup_in_mod_strict(e, dcur_def, sp, path[i],\n-                                 ns_module, outside);\n-            i += 1u;\n-          }\n-          none { break; }\n-       }\n-    }\n-    if i == path_len {\n-       alt dcur {\n-          some(ast::def_mod(_)) | some(ast::def_foreign_mod(_)) { ret dcur; }\n-          _ {\n-            e.sess.span_err(sp, str::connect(path.map(|x|*x), ~\"::\") +\n-                            ~\" does not name a module.\");\n-            ret none;\n-          }\n-        }\n-    } else { ret none; }\n-}\n-\n-// Import resolution\n-fn resolve_import(e: env, n_id: node_id, name: ast::ident,\n-                  ids: ~[ast::ident], sp: codemap::span, &&sc: scopes) {\n-    fn register(e: env, id: node_id, cx: ctxt, sp: codemap::span,\n-                name: ast::ident, lookup: fn(namespace) -> option<def>,\n-                impls: ~[@_impl]) {\n-        let val = lookup(ns_val), typ = lookup(ns_type),\n-            md = lookup(ns_module);\n-        if is_none(val) && is_none(typ) && is_none(md) &&\n-           vec::len(impls) == 0u {\n-            unresolved_err(e, cx, sp, name, ~\"import\");\n-        } else {\n-            e.imports.insert(id, resolved(val, typ, md, @impls, name, sp));\n-        }\n-    }\n-    // Temporarily disable this import and the imports coming after during\n-    // resolution of this import.\n-    fn find_imports_after(e: env, id: node_id, &&sc: scopes) -> ~[node_id] {\n-        fn lst(my_id: node_id, vis: ~[@view_item]) -> ~[node_id] {\n-            let mut imports = ~[], found = false;\n-            for vis.each |vi| {\n-                do iter_effective_import_paths(*vi) |vp| {\n-                    alt vp.node {\n-                      view_path_simple(_, _, id)\n-                      | view_path_glob(_, id) {\n-                        if id == my_id { found = true; }\n-                        if found { vec::push(imports, id); }\n-                      }\n-                      view_path_list(_, ids, _) {\n-                        for ids.each |id| {\n-                            if id.node.id == my_id { found = true; }\n-                            if found { vec::push(imports, id.node.id); }\n-                        }\n-                      }\n-                    }\n-                }\n-            }\n-            imports\n-        }\n-        alt *sc {\n-          cons(scope_item(@{node: item_mod(m), _}), _) {\n-            lst(id, m.view_items)\n-          }\n-          cons(scope_item(@{node: item_foreign_mod(m), _}), _) {\n-            lst(id, m.view_items)\n-          }\n-          cons(scope_block(b, _, _), _) {\n-            lst(id, b.node.view_items)\n-          }\n-          cons(scope_crate, _) {\n-            lst(id,\n-                option::get(e.mod_map.get(ast::crate_node_id).m).view_items)\n-          }\n-          _ {\n-              e.sess.bug(~\"find_imports_after: nil or unexpected scope\");\n-          }\n-        }\n-    }\n-    // This function has cleanup code at the end. Do not return without going\n-    // through that.\n-    e.imports.insert(n_id, resolving(sp));\n-    let mut ignored = find_imports_after(e, n_id, sc);\n-    e.ignored_imports <-> ignored;\n-    let n_idents = vec::len(ids);\n-    let end_id = ids[n_idents - 1u];\n-    if n_idents == 1u {\n-        register(e, n_id, in_scope(sc), sp, name,\n-                 |ns| lookup_in_scope(e, sc, sp, end_id, ns, true), ~[]);\n-    } else {\n-        alt lookup_in_scope(e, sc, sp, ids[0], ns_module, true) {\n-          none {\n-            unresolved_err(e, in_scope(sc), sp, ids[0], ns_name(ns_module));\n-          }\n-          some(dcur_) {\n-            let mut dcur = dcur_, i = 1u;\n-            loop {\n-                if i == n_idents - 1u {\n-                    let mut impls = ~[];\n-                    find_impls_in_mod(e, dcur, impls, some(end_id));\n-                    register(e, n_id, in_mod(dcur), sp, name, |ns| {\n-                        lookup_in_mod(e, dcur, sp, end_id, ns, outside)\n-                    }, impls);\n-                    break;\n-                } else {\n-                    dcur = alt lookup_in_mod(e, dcur, sp, ids[i], ns_module,\n-                                             outside) {\n-                      some(dcur) { dcur }\n-                      none {\n-                        unresolved_err(e, in_mod(dcur), sp, ids[i],\n-                                       ns_name(ns_module));\n-                        break;\n-                      }\n-                    };\n-                    i += 1u;\n-                }\n-            }\n-          }\n-        }\n-    }\n-    e.ignored_imports <-> ignored;\n-    // If we couldn't resolve the import, don't leave it in a partially\n-    // resolved state, to avoid having it reported later as a cyclic\n-    // import\n-    alt e.imports.find(n_id) {\n-      some(resolving(sp)) {\n-        e.imports.insert(n_id, resolved(none, none, none, @~[], @~\"\", sp));\n-      }\n-      _ { }\n-    }\n-}\n-\n-\n-// Utilities\n-fn ns_name(ns: namespace) -> ~str {\n-    alt ns {\n-      ns_type { ~\"typename\" }\n-      ns_val { ~\"name\" }\n-      ns_module { ~\"modulename\" }\n-    }\n-}\n-\n-enum ctxt { in_mod(def), in_scope(scopes), }\n-\n-fn unresolved_err(e: env, cx: ctxt, sp: span, name: ident, kind: ~str) {\n-    fn find_fn_or_mod_scope(sc: scopes) -> option<scope> {\n-        for list::each(sc) |cur| {\n-            alt cur {\n-              scope_crate | scope_bare_fn(_, _, _) | scope_fn_expr(_, _, _) |\n-              scope_item(@{node: ast::item_mod(_), _}) {\n-                ret some(cur);\n-              }\n-              _ {}\n-            }\n-        }\n-        ret none;\n-    }\n-    let mut path = name;\n-    alt cx {\n-      in_scope(sc) {\n-        alt find_fn_or_mod_scope(sc) {\n-          some(err_scope) {\n-            for e.reported.each |rs| {\n-                if str::eq(*rs.ident, *name) && err_scope == rs.sc { ret; }\n-            }\n-            e.reported.push({ident: name, sc: err_scope});\n-          }\n-          _ {}\n-        }\n-      }\n-      in_mod(def) {\n-        let did = def_id_of_def(def);\n-        if did.crate == ast::local_crate {\n-            path = @(e.mod_map.get(did.node).path + *path);\n-        } else if did.node != ast::crate_node_id {\n-            let paths = e.ext_map.get(did);\n-            path = @str::connect(vec::append_one(paths, path).map(|x|*x),\n-                                 ~\"::\");\n-        }\n-      }\n-    }\n-    e.sess.span_err(sp, mk_unresolved_msg(path, kind));\n-}\n-\n-fn unresolved_fatal(e: env, sp: span, id: ident, kind: ~str) -> ! {\n-    e.sess.span_fatal(sp, mk_unresolved_msg(id, kind));\n-}\n-\n-fn mk_unresolved_msg(id: ident, kind: ~str) -> ~str {\n-    ret #fmt[\"unresolved %s: %s\", kind, *id];\n-}\n-\n-// Lookup helpers\n-fn lookup_path_strict(e: env, &&sc: scopes, sp: span, pth: @ast::path,\n-                      ns: namespace) -> option<def> {\n-    let n_idents = vec::len(pth.idents);\n-    let headns = if n_idents == 1u { ns } else { ns_module };\n-\n-    let first_scope = if pth.global { top_scope() } else { sc };\n-\n-    let dcur_ =\n-        lookup_in_scope_strict(e, first_scope, sp, pth.idents[0], headns);\n-\n-    alt dcur_ {\n-      none { ret none; }\n-      some(dcur__) {\n-         let mut i = 1u;\n-         let mut dcur = dcur__;\n-         while i < n_idents {\n-            let curns = if n_idents == i + 1u { ns } else { ns_module };\n-            alt lookup_in_mod_strict(e, dcur, sp, pth.idents[i],\n-                                 curns, outside) {\n-               none { break; }\n-               some(thing) { dcur = thing; }\n-            }\n-            i += 1u;\n-         }\n-         ret some(dcur);\n-      }\n-    }\n-}\n-\n-fn lookup_in_scope_strict(e: env, &&sc: scopes, sp: span, name: ident,\n-                          ns: namespace) -> option<def> {\n-    alt lookup_in_scope(e, sc, sp, name, ns, true) {\n-      none {\n-        unresolved_err(e, in_scope(sc), sp, name, ns_name(ns));\n-        ret none;\n-      }\n-      some(d) { ret some(d); }\n-    }\n-}\n-\n-fn scope_is_fn(sc: scope) -> bool {\n-    ret alt sc {\n-      scope_bare_fn(_, _, _) | scope_foreign_item(_) { true }\n-      _ { false }\n-    };\n-}\n-\n-// Returns:\n-//   none - does not close\n-//   some(node_id) - closes via the expr w/ node_id\n-fn scope_closes(sc: scope) -> option<node_id> {\n-    alt sc {\n-      scope_fn_expr(_, node_id, _) { some(node_id) }\n-      _ { none }\n-    }\n-}\n-\n-fn def_is_local(d: def) -> bool {\n-    alt d {\n-      ast::def_arg(_, _) | ast::def_local(_, _) | ast::def_binding(_) |\n-      ast::def_upvar(_, _, _) { true }\n-      _ { false }\n-    }\n-}\n-\n-fn def_is_self(d: def) -> bool {\n-    alt d {\n-      ast::def_self(_) { true }\n-      _ { false }\n-    }\n-}\n-\n-fn def_is_ty_arg(d: def) -> bool {\n-    ret alt d { ast::def_ty_param(_, _) { true } _ { false } };\n-}\n-\n-fn lookup_in_scope(e: env, &&sc: scopes, sp: span, name: ident, ns: namespace,\n-                   check_capture: bool) -> option<def> {\n-\n-    fn in_scope(e: env, sp: span, name: ident, s: scope, ns: namespace) ->\n-       option<def> {\n-        alt s {\n-          scope_toplevel {\n-            if ns == ns_type {\n-                ret some(ast::def_prim_ty(alt *name {\n-                  ~\"bool\" { ast::ty_bool }\n-                  ~\"int\" { ast::ty_int(ast::ty_i) }\n-                  ~\"uint\" { ast::ty_uint(ast::ty_u) }\n-                  ~\"float\" { ast::ty_float(ast::ty_f) }\n-                  ~\"str\" { ast::ty_str }\n-                  ~\"char\" { ast::ty_int(ast::ty_char) }\n-                  ~\"i8\" { ast::ty_int(ast::ty_i8) }\n-                  ~\"i16\" { ast::ty_int(ast::ty_i16) }\n-                  ~\"i32\" { ast::ty_int(ast::ty_i32) }\n-                  ~\"i64\" { ast::ty_int(ast::ty_i64) }\n-                  ~\"u8\" { ast::ty_uint(ast::ty_u8) }\n-                  ~\"u16\" { ast::ty_uint(ast::ty_u16) }\n-                  ~\"u32\" { ast::ty_uint(ast::ty_u32) }\n-                  ~\"u64\" { ast::ty_uint(ast::ty_u64) }\n-                  ~\"f32\" { ast::ty_float(ast::ty_f32) }\n-                  ~\"f64\" { ast::ty_float(ast::ty_f64) }\n-                  _ { ret none; }\n-                }));\n-            }\n-          }\n-          scope_crate {\n-            ret lookup_in_local_mod(e, ast::crate_node_id, sp,\n-                                    name, ns, inside);\n-          }\n-          scope_item(it) {\n-            alt it.node {\n-              ast::item_impl(tps, _, _, _) {\n-                if ns == ns_type { ret lookup_in_ty_params(e, name, tps); }\n-              }\n-              ast::item_enum(_, tps) | ast::item_ty(_, tps) {\n-                if ns == ns_type { ret lookup_in_ty_params(e, name, tps); }\n-              }\n-              ast::item_trait(tps, _) {\n-                if ns == ns_type {\n-                    if *name == ~\"self\" {\n-                        ret some(def_self(it.id));\n-                    }\n-                    ret lookup_in_ty_params(e, name, tps);\n-                }\n-              }\n-              ast::item_mod(_) {\n-                ret lookup_in_local_mod(e, it.id, sp, name, ns, inside);\n-              }\n-              ast::item_foreign_mod(m) {\n-                ret lookup_in_local_foreign_mod(e, it.id, sp, name, ns);\n-              }\n-              ast::item_class(tps, _, members, ctor, _) {\n-                  if ns == ns_type {\n-                      ret lookup_in_ty_params(e, name, tps);\n-                  }\n-                  if ns == ns_val && name == it.ident {\n-                      ret some(ast::def_fn(local_def(ctor.node.id),\n-                                           ast::impure_fn));\n-                  }\n-              }\n-              _ { }\n-            }\n-          }\n-          scope_method(id, tps) {\n-            if (*name == ~\"self\" && ns == ns_val) {\n-                ret some(ast::def_self(id));\n-            } else if ns == ns_type {\n-                ret lookup_in_ty_params(e, name, tps);\n-            }\n-          }\n-          scope_foreign_item(it) {\n-            alt check it.node {\n-              ast::foreign_item_fn(decl, ty_params) {\n-                ret lookup_in_fn(e, name, decl, ty_params, ns);\n-              }\n-            }\n-          }\n-          scope_bare_fn(decl, _, ty_params) |\n-          scope_fn_expr(decl, _, ty_params) {\n-            ret lookup_in_fn(e, name, decl, ty_params, ns);\n-          }\n-          scope_loop(local) {\n-            if ns == ns_val {\n-                alt lookup_in_pat(e, name, local.node.pat) {\n-                  some(nid) { ret some(ast::def_binding(nid)); }\n-                  _ { }\n-                }\n-            }\n-          }\n-          scope_block(b, pos, loc) {\n-            ret lookup_in_block(e, name, sp, b.node, *pos, *loc, ns);\n-          }\n-          scope_arm(a) {\n-            if ns == ns_val {\n-                alt lookup_in_pat(e, name, a.pats[0]) {\n-                  some(nid) { ret some(ast::def_binding(nid)); }\n-                  _ { ret none; }\n-                }\n-            }\n-          }\n-        }\n-        ret none;\n-    }\n-    let mut left_fn = false;\n-    let mut closing = ~[];\n-    // Used to determine whether self is in scope\n-    let mut left_fn_level2 = false;\n-    let mut sc = sc;\n-    loop {\n-        alt *sc {\n-          nil { ret none; }\n-          cons(hd, tl) {\n-              alt in_scope(e, sp, name, hd, ns) {\n-               some(df_) {\n-                 let mut df = df_;\n-                 let local = def_is_local(df), self_scope = def_is_self(df);\n-                 if check_capture &&\n-                     (left_fn && local || left_fn_level2 && self_scope\n-                      || scope_is_fn(hd) && left_fn && def_is_ty_arg(df)) {\n-                     let msg = if ns == ns_type {\n-                         ~\"attempt to use a type argument out of scope\"\n-                     } else {\n-                         ~\"attempted dynamic environment-capture\"\n-                     };\n-                     e.sess.span_fatal(sp, msg);\n-                } else if local || self_scope {\n-                    let mut i = vec::len(closing);\n-                    while i > 0u {\n-                        i -= 1u;\n-                        #debug[\"name=%s df=%?\", *name, df];\n-                        assert def_is_local(df) || def_is_self(df);\n-                        let df_id = def_id_of_def(df).node;\n-                        df = ast::def_upvar(df_id, @df, closing[i]);\n-                    }\n-                }\n-                ret some(df);\n-            }\n-            _ {}\n-        }\n-        if left_fn {\n-           left_fn_level2 = true;\n-        } else if ns != ns_module {\n-                left_fn = scope_is_fn(hd);\n-                alt scope_closes(hd) {\n-                  some(node_id) { vec::push(closing, node_id); }\n-                  _ { }\n-                }\n-            }\n-            sc = tl;\n-        }\n-      }\n-    };\n-}\n-\n-fn lookup_in_ty_params(e: env, name: ident, ty_params: ~[ast::ty_param])\n-    -> option<def> {\n-    let mut n = 0u;\n-    for ty_params.each |tp| {\n-        if str::eq(*tp.ident, *name) && alt e.current_tp {\n-            some(cur) { n < cur } none { true }\n-        } { ret some(ast::def_ty_param(local_def(tp.id), n)); }\n-        n += 1u;\n-    }\n-    ret none;\n-}\n-\n-fn lookup_in_pat(e: env, name: ident, pat: @ast::pat) -> option<node_id> {\n-    let mut found = none;\n-\n-    do pat_util::pat_bindings(e.def_map, pat) |p_id, _sp, n| {\n-        if str::eq(*path_to_ident(n), *name)\n-                    { found = some(p_id); }\n-    };\n-    ret found;\n-}\n-\n-fn lookup_in_fn(e: env, name: ident, decl: ast::fn_decl,\n-                ty_params: ~[ast::ty_param],\n-                ns: namespace) -> option<def> {\n-    alt ns {\n-      ns_val {\n-        for decl.inputs.each |a| {\n-            if str::eq(*a.ident, *name) {\n-                ret some(ast::def_arg(a.id, a.mode));\n-            }\n-        }\n-        ret none;\n-      }\n-      ns_type { ret lookup_in_ty_params(e, name, ty_params); }\n-      _ { ret none; }\n-    }\n-}\n-\n-fn lookup_in_block(e: env, name: ident, sp: span, b: ast::blk_, pos: uint,\n-                   loc_pos: uint, ns: namespace) -> option<def> {\n-\n-    let mut i = vec::len(b.stmts);\n-    while i > 0u {\n-        i -= 1u;\n-        let st = b.stmts[i];\n-        alt st.node {\n-          ast::stmt_decl(d, _) {\n-            alt d.node {\n-              ast::decl_local(locs) {\n-                if i <= pos {\n-                    let mut j = vec::len(locs);\n-                    while j > 0u {\n-                        j -= 1u;\n-                        let loc = locs[j];\n-                        if ns == ns_val && (i < pos || j < loc_pos) {\n-                            alt lookup_in_pat(e, name, loc.node.pat) {\n-                              some(nid) {\n-                                ret some(ast::def_local(nid,\n-                                                        loc.node.is_mutbl));\n-                              }\n-                              _ { }\n-                            }\n-                        }\n-                    }\n-                }\n-              }\n-              ast::decl_item(it) {\n-                alt it.node {\n-                  ast::item_enum(variants, _) {\n-                    if ns == ns_type {\n-                        if str::eq(*it.ident, *name) {\n-                            ret some(ast::def_ty(local_def(it.id)));\n-                        }\n-                    } else {\n-                        alt ns {\n-                           ns_val {\n-                             for variants.each |v| {\n-                                  if str::eq(*v.node.name, *name) {\n-                                     let i = v.node.id;\n-                                     ret some(ast::def_variant\n-                                        (local_def(it.id), local_def(i)));\n-                                  }\n-                               }\n-                          }\n-                           _ {}\n-                        }\n-                    }\n-                  }\n-                  _ {\n-                    if str::eq(*it.ident, *name) {\n-                        let found = found_def_item(it, ns);\n-                        if !is_none(found) {\n-                            ret found;\n-                        }\n-                    }\n-                  }\n-                }\n-              }\n-            }\n-          }\n-          _ { }\n-        }\n-    }\n-    for b.view_items.each |vi| {\n-        let mut is_import = false;\n-        alt vi.node {\n-          ast::view_item_import(_) { is_import = true; }\n-          _ {}\n-        }\n-\n-        alt vi.node {\n-\n-          ast::view_item_import(vps) | ast::view_item_export(vps) {\n-            for vps.each |vp| {\n-                alt vp.node {\n-                  ast::view_path_simple(ident, _, id) {\n-                    if is_import && name == ident {\n-                        ret lookup_import(e, id, ns);\n-                    }\n-                  }\n-\n-                  ast::view_path_list(path, idents, _) {\n-                    for idents.each |ident| {\n-                        if name == ident.node.name {\n-                            ret lookup_import(e, ident.node.id, ns);\n-                        }\n-                    }\n-                  }\n-\n-                  ast::view_path_glob(_, _) {\n-                    alt e.block_map.find(b.id) {\n-                      some(globs) {\n-                        let found = lookup_in_globs(e, globs, sp, name,\n-                                                    ns, inside);\n-                        if found != none {\n-                            ret found;\n-                        }\n-                      }\n-                      _ {}\n-                    }\n-                  }\n-                }\n-            }\n-          }\n-          _ { e.sess.span_bug(vi.span, ~\"unexpected view_item in block\"); }\n-        }\n-    }\n-    ret none;\n-}\n-\n-fn found_def_item(i: @ast::item, ns: namespace) -> option<def> {\n-    alt i.node {\n-      ast::item_const(*) {\n-        if ns == ns_val {\n-            ret some(ast::def_const(local_def(i.id)));\n-        }\n-      }\n-      ast::item_fn(decl, _, _) {\n-          if ns == ns_val {\n-            ret some(ast::def_fn(local_def(i.id), decl.purity));\n-           }\n-       }\n-      ast::item_mod(_) {\n-        if ns == ns_module { ret some(ast::def_mod(local_def(i.id))); }\n-      }\n-      ast::item_foreign_mod(_) {\n-        if ns == ns_module {\n-            ret some(ast::def_foreign_mod(local_def(i.id)));\n-        }\n-      }\n-      ast::item_ty(*) | item_trait(*) | item_enum(*) {\n-        if ns == ns_type { ret some(ast::def_ty(local_def(i.id))); }\n-      }\n-      ast::item_class(_, _, _members, ct, _) {\n-          alt ns {\n-             ns_type {\n-               ret some(ast::def_class(local_def(i.id)));\n-             }\n-             ns_val {\n-               ret some(ast::def_fn(local_def(ct.node.id),\n-                                    ast::impure_fn));\n-             }\n-             ns_module { }\n-          }\n-      }\n-      ast::item_impl(*) { /* ??? */ }\n-      ast::item_mac(*) { /* ???? */ }\n-    }\n-    ret none;\n-}\n-\n-fn lookup_in_mod_strict(e: env, m: def, sp: span, name: ident,\n-                        ns: namespace, dr: dir) -> option<def> {\n-    alt lookup_in_mod(e, m, sp, name, ns, dr) {\n-      none {\n-        unresolved_err(e, in_mod(m), sp, name, ns_name(ns));\n-        ret none;\n-      }\n-      some(d) { ret some(d); }\n-    }\n-}\n-\n-fn lookup_in_mod(e: env, m: def, sp: span, name: ident, ns: namespace,\n-                 dr: dir) -> option<def> {\n-    let defid = def_id_of_def(m);\n-    if defid.crate != ast::local_crate {\n-        // examining a module in an external crate\n-        let cached = e.ext_cache.find({did: defid, ident: name, ns: ns});\n-        if !is_none(cached) { ret cached; }\n-        let mut path = ~[name];\n-        if defid.node != ast::crate_node_id {\n-            path = vec::append(cstore::get_path(e.cstore, defid), path);\n-        }\n-        alt lookup_external(e, defid.crate, path, ns) {\n-           some(df) {\n-               e.ext_cache.insert({did: defid, ident: name, ns: ns}, df);\n-               ret some(df);\n-           }\n-           _ { ret none; }\n-        }\n-    }\n-    alt m {\n-      ast::def_mod(defid) {\n-        ret lookup_in_local_mod(e, defid.node, sp, name, ns, dr);\n-      }\n-      ast::def_foreign_mod(defid) {\n-        ret lookup_in_local_foreign_mod(e, defid.node, sp, name, ns);\n-      }\n-      _ {\n-          // Precondition\n-          e.sess.span_bug(sp, ~\"lookup_in_mod was passed a non-mod def\");\n-      }\n-    }\n-}\n-\n-fn found_view_item(e: env, id: node_id) -> option<def> {\n-    alt cstore::find_use_stmt_cnum(e.cstore, id) {\n-      some(cnum) {\n-        some(ast::def_mod({crate: cnum, node: ast::crate_node_id}))\n-      }\n-      none {\n-        // This can happen if we didn't load external crate info.\n-        // Rustdoc depends on this.\n-        none\n-      }\n-    }\n-}\n-\n-fn lookup_import(e: env, n_id: node_id, ns: namespace) -> option<def> {\n-    // Imports are simply ignored when resolving themselves.\n-    if vec::contains(e.ignored_imports, n_id) { ret none; }\n-    alt e.imports.get(n_id) {\n-      todo(name, path, span, scopes) {\n-        resolve_import(e, n_id, name, *path, span, scopes);\n-        ret lookup_import(e, n_id, ns);\n-      }\n-      resolving(sp) {\n-        e.sess.span_err(sp, ~\"cyclic import\");\n-        ret none;\n-      }\n-      resolved(val, typ, md, _, _, _) {\n-        if e.used_imports.track {\n-            vec::push(e.used_imports.data, n_id);\n-        }\n-        ret alt ns { ns_val { val } ns_type { typ } ns_module { md } };\n-      }\n-      is_glob(_,_,_) {\n-          e.sess.bug(~\"lookup_import: can't handle is_glob\");\n-      }\n-    }\n-}\n-\n-fn lookup_in_local_foreign_mod(e: env, node_id: node_id, sp: span, id: ident,\n-                              ns: namespace) -> option<def> {\n-    ret lookup_in_local_mod(e, node_id, sp, id, ns, inside);\n-}\n-\n-fn is_exported(e: env, i: ident, m: @indexed_mod) -> bool {\n-\n-    alt m.m {\n-      some(_m) {\n-        if ast_util::is_exported(i, _m) { ret true; }\n-      }\n-      _ {}\n-    }\n-\n-    ret vec::contains(m.globbed_exports, i)\n-        || e.resolve_unexported;\n-}\n-\n-// A list search function. Applies `f` to each element of `v`, starting from\n-// the first. When `f` returns `some(x)`, `list_search` returns `some(x)`. If\n-// `f` returns `none` for every element, `list_search` returns `none`.\n-fn list_search<T: copy, U: copy>(ls: @list<T>, f: fn(T) -> option<U>)\n-        -> option<U> {\n-    let mut ls = ls;\n-    loop {\n-        ls = alt *ls {\n-          cons(hd, tl) {\n-            let result = f(hd);\n-            if !is_none(result) { ret result; }\n-            tl\n-          }\n-          nil { ret none; }\n-        };\n-    }\n-}\n-\n-fn lookup_in_local_mod(e: env, node_id: node_id, sp: span, id: ident,\n-                       ns: namespace, dr: dir) -> option<def> {\n-    let inf = alt e.mod_map.find(node_id) {\n-            some(x) { x }\n-            none { e.sess.span_bug(sp, #fmt(\"lookup_in_local_mod: \\\n-                     module %d not in mod_map\", node_id)); }\n-    };\n-    if dr == outside && !is_exported(e, id, inf) {\n-        // if we're in a foreign mod, then dr==inside, so inf.m is some _mod\n-        ret none; // name is not visible\n-    }\n-    alt inf.index.find(id) {\n-      none { }\n-      some(lst) {\n-        let found = list_search(lst, |x| lookup_in_mie(e, x, ns));\n-        if !is_none(found) {\n-            ret found;\n-        }\n-      }\n-    }\n-    // not local or explicitly imported; try globs:\n-    ret lookup_glob_in_mod(e, inf, sp, id, ns, outside);\n-}\n-\n-fn lookup_in_globs(e: env, globs: ~[glob_imp_def], sp: span, id: ident,\n-                   ns: namespace, dr: dir) -> option<def> {\n-    fn lookup_in_mod_(e: env, def: glob_imp_def, sp: span, name: ident,\n-                      ns: namespace, dr: dir) -> option<glob_imp_def> {\n-        alt def.path.node {\n-\n-          ast::view_path_glob(_, id) {\n-            if vec::contains(e.ignored_imports, id) { ret none; }\n-          }\n-\n-          _ {\n-            e.sess.span_bug(sp, ~\"lookup_in_globs: not a glob\");\n-          }\n-        }\n-        alt lookup_in_mod(e, def.def, sp, name, ns, dr) {\n-          some(d) { option::some({def: d, path: def.path}) }\n-          none { none }\n-        }\n-    }\n-    let g = copy globs; // FIXME #2405\n-    let matches = vec::filter_map(g,\n-                                  |x| lookup_in_mod_(e, x, sp, id, ns, dr));\n-    if vec::len(matches) == 0u {\n-        ret none;\n-        }\n-    else if vec::len(matches) == 1u {\n-        ret some(matches[0].def);\n-    } else {\n-        for matches.each |match| {\n-            let sp = match.path.span;\n-            e.sess.span_note(sp, #fmt[\"'%s' is imported here\", *id]);\n-        }\n-        e.sess.span_fatal(sp, ~\"'\" + *id + ~\"' is glob-imported from\" +\n-                          ~\" multiple different modules.\");\n-    }\n-}\n-\n-fn lookup_glob_in_mod(e: env, info: @indexed_mod, sp: span, id: ident,\n-                      wanted_ns: namespace, dr: dir) -> option<def> {\n-    // since we don't know what names we have in advance,\n-    // absence takes the place of todo()\n-    if !info.glob_imported_names.contains_key(id) {\n-        info.glob_imported_names.insert(id, glob_resolving(sp));\n-        let globs = info.glob_imports.get();\n-        let val = lookup_in_globs(e, globs, sp, id, ns_val, dr);\n-        let typ = lookup_in_globs(e, globs, sp, id, ns_type, dr);\n-        let md = lookup_in_globs(e, globs, sp, id, ns_module, dr);\n-        info.glob_imported_names.insert(id, glob_resolved(val, typ, md));\n-    }\n-    alt info.glob_imported_names.get(id) {\n-      glob_resolving(sp) {\n-          ret none;\n-      }\n-      glob_resolved(val, typ, md) {\n-        ret alt wanted_ns {\n-          ns_val { val }\n-          ns_type { typ }\n-          ns_module { md }\n-        };\n-      }\n-    }\n-}\n-\n-fn lookup_in_mie(e: env, mie: mod_index_entry, ns: namespace) ->\n-   option<def> {\n-    alt mie {\n-      mie_view_item(_, id, _) {\n-         if ns == ns_module { ret found_view_item(e, id); }\n-      }\n-      mie_import_ident(id, _) { ret lookup_import(e, id, ns); }\n-      mie_item(item) { ret found_def_item(item, ns); }\n-      mie_enum_variant(variant_idx, variants, parent_id, parent_span) {\n-         alt ns {\n-            ns_val {\n-               let vid = variants[variant_idx].node.id;\n-               ret some(ast::def_variant(local_def(parent_id),\n-                                        local_def(vid)));\n-            }\n-            _ { ret none; }\n-         }\n-      }\n-      mie_foreign_item(foreign_item) {\n-        alt foreign_item.node {\n-          ast::foreign_item_fn(decl, _) {\n-            if ns == ns_val {\n-                ret some(ast::def_fn(local_def(foreign_item.id),\n-                                     decl.purity));\n-            }\n-          }\n-        }\n-      }\n-    }\n-    ret none;\n-}\n-\n-\n-// Module indexing\n-fn add_to_index(index: hashmap<ident, @list<mod_index_entry>>, id: ident,\n-                ent: mod_index_entry) {\n-    alt index.find(id) {\n-      none { index.insert(id, @cons(ent, @nil)); }\n-      some(prev) { index.insert(id, @cons(ent, prev)); }\n-    }\n-}\n-\n-fn index_view_items(view_items: ~[@ast::view_item],\n-                    index: hashmap<ident, @list<mod_index_entry>>) {\n-    for view_items.each |vi| {\n-        alt vi.node {\n-          ast::view_item_use(ident, _, id) {\n-           add_to_index(index, ident, mie_view_item(ident, id, vi.span));\n-          }\n-          _ {}\n-        }\n-\n-        do iter_effective_import_paths(*vi) |vp| {\n-            alt vp.node {\n-              ast::view_path_simple(ident, _, id) {\n-                add_to_index(index, ident, mie_import_ident(id, vp.span));\n-              }\n-              ast::view_path_list(_, idents, _) {\n-                for idents.each |ident| {\n-                    add_to_index(index, ident.node.name,\n-                                 mie_import_ident(ident.node.id,\n-                                                  ident.span));\n-                }\n-              }\n-\n-              // globbed imports have to be resolved lazily.\n-              ast::view_path_glob(_, _) {}\n-            }\n-        }\n-    }\n-}\n-\n-fn index_mod(md: ast::_mod) -> mod_index {\n-    let index = box_str_hash::<@list<mod_index_entry>>();\n-\n-    index_view_items(md.view_items, index);\n-\n-    for md.items.each |it| {\n-        alt it.node {\n-          ast::item_const(_, _) | ast::item_fn(_, _, _) | ast::item_mod(_) |\n-          ast::item_foreign_mod(_) | ast::item_ty(_, _) |\n-          ast::item_impl(*) | ast::item_trait(*) {\n-            add_to_index(index, it.ident, mie_item(it));\n-          }\n-          ast::item_enum(variants, _) {\n-            add_to_index(index, it.ident, mie_item(it));\n-            let mut variant_idx: uint = 0u;\n-            for variants.each |v| {\n-                add_to_index(index, v.node.name,\n-                             mie_enum_variant(variant_idx, variants,\n-                                             it.id, it.span));\n-                variant_idx += 1u;\n-            }\n-          }\n-          ast::item_class(tps, _, items, ctor, _) {\n-              // add the class name itself\n-              add_to_index(index, it.ident, mie_item(it));\n-          }\n-          ast::item_mac(*) {\n-            /* ??? */\n-          }\n-        }\n-    }\n-    ret index;\n-}\n-\n-\n-fn index_nmod(md: ast::foreign_mod) -> mod_index {\n-    let index = box_str_hash::<@list<mod_index_entry>>();\n-\n-    index_view_items(md.view_items, index);\n-\n-    for md.items.each |it| {\n-        add_to_index(index, it.ident, mie_foreign_item(it));\n-    }\n-    ret index;\n-}\n-\n-\n-// External lookups\n-fn ns_for_def(d: def) -> namespace {\n-    alt d {\n-      ast::def_variant(_, _) { ns_val }\n-      ast::def_fn(_, _) | ast::def_self(_) |\n-      ast::def_const(_) | ast::def_arg(_, _) | ast::def_local(_, _) |\n-      ast::def_upvar(_, _, _) { ns_val }\n-      ast::def_mod(_) | ast::def_foreign_mod(_) { ns_module }\n-      ast::def_ty(_) | ast::def_binding(_) | ast::def_use(_) |\n-      ast::def_ty_param(_, _) | ast::def_prim_ty(_) | ast::def_class(_)\n-      { ns_type }\n-      ast::def_region(_) { fail ~\"regions are not handled by this pass\" }\n-    }\n-}\n-\n-fn lookup_external(e: env, cnum: int, ids: ~[ident], ns: namespace) ->\n-   option<def> {\n-    let mut result = none;\n-    for csearch::lookup_defs(e.sess.cstore, cnum, ids).each |d| {\n-        e.ext_map.insert(def_id_of_def(d), ids);\n-        if ns == ns_for_def(d) { result = some(d); }\n-    }\n-    ret result;\n-}\n-\n-\n-// Collision detection\n-fn check_for_collisions(e: @env, c: ast::crate) {\n-    // Module indices make checking those relatively simple -- just check each\n-    // name for multiple entities in the same namespace.\n-    for e.mod_map.each_value |val| {\n-        for val.index.each |k, v| { check_mod_name(*e, k, v); };\n-    };\n-    // Other scopes have to be checked the hard way.\n-    let v =\n-        @{visit_item: |a,b,c| check_item(e, a, b, c),\n-          visit_block: |a,b,c| check_block(e, a, b, c),\n-          visit_arm: |a,b,c| check_arm(e, a, b, c),\n-          visit_expr: |a,b,c| check_expr(e, a, b, c),\n-          visit_ty: |a,b,c| check_ty(e, a, b, c)\n-          with *visit::default_visitor()};\n-    visit::visit_crate(c, (), visit::mk_vt(v));\n-}\n-\n-fn check_mod_name(e: env, name: ident, entries: @list<mod_index_entry>) {\n-    let mut saw_mod = false;\n-    let mut saw_type = false;\n-    let mut saw_value = false;\n-    let mut entries = entries;\n-    fn dup(e: env, sp: span, word: ~str, name: ident) {\n-        e.sess.span_fatal(sp, ~\"duplicate definition of \" + word + *name);\n-    }\n-    loop {\n-        alt *entries {\n-          cons(entry, rest) {\n-            if !is_none(lookup_in_mie(e, entry, ns_val)) {\n-                if saw_value {\n-                    dup(e, mie_span(entry), ~\"\", name);\n-                } else { saw_value = true; }\n-            }\n-            if !is_none(lookup_in_mie(e, entry, ns_type)) {\n-                if saw_type {\n-                    dup(e, mie_span(entry), ~\"type \", name);\n-                } else { saw_type = true; }\n-            }\n-            if !is_none(lookup_in_mie(e, entry, ns_module)) {\n-                if saw_mod {\n-                    dup(e, mie_span(entry), ~\"module \", name);\n-                } else { saw_mod = true; }\n-            }\n-            entries = rest;\n-          }\n-          nil { break; }\n-        }\n-    }\n-}\n-\n-fn mie_span(mie: mod_index_entry) -> span {\n-    ret alt mie {\n-          mie_view_item(_, _, span) { span }\n-          mie_import_ident(_, span) { span }\n-          mie_item(item) { item.span }\n-          mie_enum_variant(_, _, _, span) { span }\n-          mie_foreign_item(item) { item.span }\n-        };\n-}\n-\n-fn check_item(e: @env, i: @ast::item, &&x: (), v: vt<()>) {\n-    fn typaram_names(tps: ~[ast::ty_param]) -> ~[ident] {\n-        let mut x: ~[ast::ident] = ~[];\n-        for tps.each |tp| { vec::push(x, tp.ident); }\n-        ret x;\n-    }\n-    visit::visit_item(i, x, v);\n-    alt i.node {\n-      ast::item_fn(decl, ty_params, _) {\n-        check_fn(*e, i.span, decl);\n-        ensure_unique(*e, i.span, ty_params, |tp| tp.ident,\n-                      ~\"type parameter\");\n-      }\n-      ast::item_enum(_, ty_params) {\n-        ensure_unique(*e, i.span, ty_params, |tp| tp.ident,\n-                      ~\"type parameter\");\n-      }\n-      ast::item_trait(_, methods) {\n-        ensure_unique(*e, i.span, methods, |m| {\n-            alt m {\n-              required(ty_m) {\n-                ty_m.ident\n-              }\n-              provided(m) {\n-                m.ident\n-              }\n-            }\n-        },\n-                      ~\"method\");\n-      }\n-      ast::item_impl(_, _, _, methods) {\n-        ensure_unique(*e, i.span, methods, |m| m.ident,\n-                      ~\"method\");\n-      }\n-      _ { }\n-    }\n-}\n-\n-fn check_pat(e: @env, ch: checker, p: @ast::pat) {\n-    do pat_util::pat_bindings(e.def_map, p) |_i, p_sp, n| {\n-       add_name(ch, p_sp, path_to_ident(n));\n-    };\n-}\n-\n-fn check_arm(e: @env, a: ast::arm, &&x: (), v: vt<()>) {\n-    visit::visit_arm(a, x, v);\n-    let ch0 = checker(*e, ~\"binding\");\n-    check_pat(e, ch0, a.pats[0]);\n-    let seen0 = ch0.seen.get();\n-    let mut i = vec::len(a.pats);\n-    while i > 1u {\n-        i -= 1u;\n-        let ch = checker(*e, ~\"binding\");\n-        check_pat(e, ch, a.pats[i]);\n-\n-        // Ensure the bindings introduced in this pattern are the same as in\n-        // the first pattern.\n-        if ch.seen.len() != seen0.len() {\n-            e.sess.span_err(a.pats[i].span,\n-                            ~\"inconsistent number of bindings\");\n-        } else {\n-            for ch.seen.each |name| {\n-                if is_none(vec::find(seen0, |x| str::eq(*name, *x))) {\n-                    // Fight the alias checker\n-                    let name_ = name;\n-                    e.sess.span_err(a.pats[i].span,\n-                                    ~\"binding \" + *name_ +\n-                                        ~\" does not occur in first pattern\");\n-                }\n-            }\n-        }\n-    }\n-}\n-\n-fn check_block(e: @env, b: ast::blk, &&x: (), v: vt<()>) {\n-    visit::visit_block(b, x, v);\n-    let values = checker(*e, ~\"value\");\n-    let types = checker(*e, ~\"type\");\n-    let mods = checker(*e, ~\"module\");\n-    for b.node.stmts.each |st| {\n-        alt st.node {\n-          ast::stmt_decl(d, _) {\n-            alt d.node {\n-              ast::decl_local(locs) {\n-                let local_values = checker(*e, ~\"value\");\n-                for locs.each |loc| {\n-                     do pat_util::pat_bindings(e.def_map, loc.node.pat)\n-                         |_i, p_sp, n| {\n-                         let ident = path_to_ident(n);\n-                         add_name(local_values, p_sp, ident);\n-                         check_name(values, p_sp, ident);\n-                     };\n-                }\n-              }\n-              ast::decl_item(it) {\n-                alt it.node {\n-                  ast::item_enum(variants, _) {\n-                    add_name(types, it.span, it.ident);\n-                    for variants.each |v| {\n-                        add_name(values, v.span, v.node.name);\n-                    }\n-                  }\n-                  ast::item_mod(_) | ast::item_foreign_mod(_) {\n-                    add_name(mods, it.span, it.ident);\n-                  }\n-                  ast::item_const(_, _) | ast::item_fn(*) {\n-                    add_name(values, it.span, it.ident);\n-                  }\n-                  ast::item_ty(*) | ast::item_trait(*) {\n-                    add_name(types, it.span, it.ident);\n-                  }\n-                  _ { }\n-                }\n-              }\n-            }\n-          }\n-          _ { }\n-        }\n-    }\n-}\n-\n-fn check_fn(e: env, sp: span, decl: ast::fn_decl) {\n-    fn arg_name(a: ast::arg) -> ident { ret a.ident; }\n-    ensure_unique(e, sp, decl.inputs, arg_name, ~\"argument\");\n-}\n-\n-fn check_expr(e: @env, ex: @ast::expr, &&x: (), v: vt<()>) {\n-    alt ex.node {\n-      ast::expr_rec(fields, _) {\n-        fn field_name(f: ast::field) -> ident { ret f.node.ident; }\n-        ensure_unique(*e, ex.span, fields, field_name, ~\"field\");\n-      }\n-      _ { }\n-    }\n-    visit::visit_expr(ex, x, v);\n-}\n-\n-fn check_ty(e: @env, ty: @ast::ty, &&x: (), v: vt<()>) {\n-    alt ty.node {\n-      ast::ty_rec(fields) {\n-        fn field_name(f: ast::ty_field) -> ident { ret f.node.ident; }\n-        ensure_unique(*e, ty.span, fields, field_name, ~\"field\");\n-      }\n-      _ { }\n-    }\n-    visit::visit_ty(ty, x, v);\n-}\n-\n-type checker = @{seen: dvec<ident>, kind: ~str, sess: session};\n-\n-fn checker(e: env, kind: ~str) -> checker {\n-    ret @{seen: dvec(), kind: kind, sess: e.sess};\n-}\n-\n-fn check_name(ch: checker, sp: span, name: ident) {\n-    for ch.seen.each |s| {\n-        if str::eq(*s, *name) {\n-            ch.sess.span_fatal(\n-                sp, ~\"duplicate \" + ch.kind + ~\" name: \" + *name);\n-        }\n-    }\n-}\n-fn add_name(ch: checker, sp: span, name: ident) {\n-    check_name(ch, sp, name);\n-    ch.seen.push(name);\n-}\n-\n-fn ensure_unique<T>(e: env, sp: span, elts: ~[T], id: fn(T) -> ident,\n-                    kind: ~str) {\n-    let ch = checker(e, kind);\n-    for elts.each |elt| { add_name(ch, sp, id(elt)); }\n-}\n-\n-fn check_exports(e: @env) {\n-\n-    fn iter_mod(e: env, m: def, sp: span, _dr: dir,\n-                f: fn(ident: ident, def: def)) {\n-        let defid = def_id_of_def(m);\n-\n-        if defid.crate != ast::local_crate {\n-            // FIXME: ought to support external export-globs eventually. #2527\n-            e.sess.span_unimpl(sp, ~\"glob-export of items in external crate\");\n-        } else {\n-\n-            let mid = def_id_of_def(m);\n-            assert mid.crate == ast::local_crate;\n-            let ixm = e.mod_map.get(mid.node);\n-\n-            for ixm.index.each |ident, mies| {\n-                do list::iter(mies) |mie| {\n-                    alt mie {\n-                      mie_item(item) {\n-                        let defs =\n-                            ~[ found_def_item(item, ns_val),\n-                             found_def_item(item, ns_type),\n-                             found_def_item(item, ns_module) ];\n-                        for defs.each |d| {\n-                            alt d {\n-                              some(def) {\n-                                f(ident, def);\n-                              }\n-                              _ {}\n-                            }\n-                        }\n-                      }\n-                      _ {\n-                        let s = ~\"glob-export from mod with non-items\";\n-                        e.sess.span_unimpl(sp, s);\n-                      }\n-                    }\n-                }\n-            }\n-        }\n-    }\n-\n-\n-\n-    fn lookup_glob_any(e: @env, info: @indexed_mod, sp: span,\n-                       ident: ident, export_id: node_id) -> bool {\n-        let m = lookup_glob_in_mod(*e, info, sp, ident, ns_module, inside);\n-        let v = lookup_glob_in_mod(*e, info, sp, ident, ns_val, inside);\n-        let t = lookup_glob_in_mod(*e, info, sp, ident, ns_type, inside);\n-        maybe_add_reexport(e, export_id, m);\n-        maybe_add_reexport(e, export_id, v);\n-        maybe_add_reexport(e, export_id, t);\n-        is_some(m) || is_some(v) || is_some(t)\n-    }\n-\n-\n-    fn maybe_add_reexport(e: @env, export_id: node_id, def: option<def>) {\n-        do option::iter(def) |def| {\n-            add_export(e, export_id, def_id_of_def(def), true);\n-        }\n-    }\n-    fn add_export(e: @env, export_id: node_id, target_id: def_id,\n-                  reexp: bool) {\n-        let found = alt e.exp_map.find(export_id) {\n-          some(f) { f } none { ~[] }\n-        };\n-        e.exp_map.insert(export_id,\n-                         vec::append_one(found,\n-                                         {reexp: reexp, id: target_id}));\n-    }\n-\n-    fn check_export(e: @env, ident: ident, _mod: @indexed_mod,\n-                    export_id: node_id, vi: @view_item) {\n-        let mut found_something = false;\n-        if _mod.index.contains_key(ident) {\n-            found_something = true;\n-            let xs = _mod.index.get(ident);\n-            do list::iter(xs) |x| {\n-                alt x {\n-                  mie_import_ident(id, _) {\n-                    alt check e.imports.get(id) {\n-                      resolved(v, t, m, _, rid, _) {\n-                        maybe_add_reexport(e, export_id, v);\n-                        maybe_add_reexport(e, export_id, t);\n-                        maybe_add_reexport(e, export_id, m);\n-                      }\n-                      _ { e.sess.span_bug(vi.span, ~\"unresolved export\"); }\n-                    }\n-                  }\n-                  mie_item(@{id, _}) | mie_foreign_item(@{id, _}) |\n-                  mie_enum_variant(_, _, id, _) {\n-                    add_export(e, export_id, local_def(id), false);\n-                  }\n-                  _ { }\n-                }\n-            }\n-        }\n-        /*\n-          This code previously used bitwise or (|=) but that was wrong,\n-          because we need or to be lazy here. If something was already\n-          found, we don't want to call lookup_glob_any (see #2316 for\n-          what happens if we do)\n-         */\n-        found_something = found_something ||\n-           lookup_glob_any(e, _mod, vi.span, ident, export_id);\n-        if !found_something {\n-            e.sess.span_warn(vi.span,\n-                             #fmt(\"exported item %s is not defined\", *ident));\n-        }\n-    }\n-\n-    fn check_enum_ok(e: @env, sp:span, id: ident, _mod: @indexed_mod)\n-        -> node_id {\n-        alt _mod.index.find(id) {\n-          none {\n-            e.sess.span_fatal(sp, #fmt(\"undefined id %s in an export\", *id));\n-          }\n-          some(ms) {\n-            let maybe_id = do list_search(ms) |m| {\n-                alt m {\n-                  mie_item(@{node: item_enum(_, _), id, _}) { some(id) }\n-                  _ { none }\n-                }\n-            };\n-            alt maybe_id {\n-              some(an_id) { an_id }\n-              _ { e.sess.span_fatal(sp, #fmt(\"%s does not refer \\\n-                                              to an enumeration\", *id)); }\n-            }\n-          }\n-        }\n-    }\n-\n-    fn check_export_enum_list(e: @env, export_id: node_id, _mod: @indexed_mod,\n-                              span: codemap::span, id: ast::ident,\n-                              ids: ~[ast::path_list_ident]) {\n-        let parent_id = check_enum_ok(e, span, id, _mod);\n-        add_export(e, export_id, local_def(parent_id), false);\n-        for ids.each |variant_id| {\n-            let mut found = false;\n-            alt _mod.index.find(variant_id.node.name) {\n-              some(ms) {\n-                do list::iter(ms) |m| {\n-                    alt m {\n-                      mie_enum_variant(_, _, actual_parent_id, _) {\n-                        found = true;\n-                        if actual_parent_id != parent_id {\n-                            e.sess.span_err(\n-                                span, #fmt(\"variant %s doesn't belong to \\\n-                                            enum %s\",\n-                                           *variant_id.node.name, *id));\n-                        }\n-                      }\n-                      _ {}\n-                    }\n-                }\n-              }\n-              _ {}\n-            }\n-            if !found {\n-                e.sess.span_err(span, #fmt(\"%s is not a variant\",\n-                                           *variant_id.node.name));\n-            }\n-        }\n-    }\n-\n-    for e.mod_map.each_value |_mod| {\n-        alt _mod.m {\n-          some(m) {\n-            let glob_is_re_exported = int_hash();\n-\n-            for m.view_items.each |vi| {\n-                do iter_export_paths(*vi) |vp| {\n-                    alt vp.node {\n-                      ast::view_path_simple(ident, _, id) {\n-                        check_export(e, ident, _mod, id, vi);\n-                      }\n-                      ast::view_path_list(path, ids, node_id) {\n-                        let id = if vec::len(path.idents) == 1u {\n-                            path.idents[0]\n-                        } else {\n-                            e.sess.span_fatal(vp.span,\n-                                              ~\"bad export name-list\")\n-                        };\n-                        check_export_enum_list(e, node_id, _mod, vp.span, id,\n-                                               ids);\n-                      }\n-                      ast::view_path_glob(_, node_id) {\n-                        glob_is_re_exported.insert(node_id, ());\n-                      }\n-                    }\n-                }\n-            }\n-            // Now follow the export-glob links and fill in the\n-            // globbed_exports and exp_map lists.\n-            for _mod.glob_imports.each |glob| {\n-                let id = alt check glob.path.node {\n-                  ast::view_path_glob(_, node_id) { node_id }\n-                };\n-                if ! glob_is_re_exported.contains_key(id) { again; }\n-                do iter_mod(*e, glob.def,\n-                            glob.path.span, outside) |ident, def| {\n-                    vec::push(_mod.globbed_exports, ident);\n-                    maybe_add_reexport(e, id, some(def));\n-                }\n-            }\n-          }\n-          none { }\n-        }\n-    }\n-}\n \n // Impl resolution\n \n@@ -2172,220 +55,8 @@ type method_info = {did: def_id, n_tps: uint, ident: ast::ident};\n type _impl = {did: def_id, ident: ast::ident, methods: ~[@method_info]};\n type iscopes = @list<@~[@_impl]>;\n \n-fn resolve_impls(e: @env, c: @ast::crate) {\n-    visit::visit_crate(*c, @nil, visit::mk_vt(@{\n-        visit_block: |a,b,c| visit_block_with_impl_scope(e, a, b, c),\n-        visit_mod: |a,b,c,d,f| visit_mod_with_impl_scope(e, a, b, c, d, f),\n-        visit_expr: |a,b,c| resolve_impl_in_expr(e, a, b, c)\n-        with *visit::default_visitor()\n-    }));\n-}\n-\n-fn find_impls_in_view_item(e: env, vi: @ast::view_item,\n-                           &impls: ~[@_impl], sc: option<iscopes>) {\n-    fn lookup_imported_impls(e: env, id: node_id,\n-                             act: fn(@~[@_impl])) {\n-        alt e.imports.get(id) {\n-          resolved(_, _, _, is, _, _) { act(is); }\n-          todo(name, path, span, scopes) {\n-            resolve_import(e, id, name, *path, span, scopes);\n-            alt check e.imports.get(id) {\n-              resolved(_, _, _, is, _, _) { act(is); }\n-            }\n-          }\n-          _ {}\n-        }\n-    }\n-\n-    do iter_effective_import_paths(*vi) |vp| {\n-        alt vp.node {\n-          ast::view_path_simple(name, pt, id) {\n-            let mut found = ~[];\n-            if vec::len(pt.idents) == 1u {\n-                do option::iter(sc) |sc| {\n-                    do list::iter(sc) |level| {\n-                        if vec::len(found) == 0u {\n-                            for vec::each(*level) |imp| {\n-                                if imp.ident == pt.idents[0] {\n-                                    vec::push(found,\n-                                              @{ident: name with *imp});\n-                                }\n-                            }\n-                            if vec::len(found) > 0u {\n-                                vec::push_all(impls, found);\n-                            }\n-                        }\n-                    }\n-                }\n-            } else {\n-                do lookup_imported_impls(e, id) |is| {\n-                    for vec::each(*is) |i| {\n-                        vec::push(impls, @{ident: name with *i});\n-                    }\n-                }\n-            }\n-          }\n-\n-          ast::view_path_list(base, names, _) {\n-            for names.each |nm| {\n-                lookup_imported_impls(e, nm.node.id, |is| {\n-                    vec::push_all(impls, *is);\n-                })\n-            }\n-          }\n-\n-          ast::view_path_glob(ids, id) {\n-            alt check e.imports.get(id) {\n-              is_glob(path, sc, sp) {\n-                alt follow_import(e, sc, *path, sp) {\n-                  some(def) { find_impls_in_mod(e, def, impls, none); }\n-                  _ {}\n-                }\n-              }\n-            }\n-          }\n-        }\n-    }\n-}\n-\n-/*\n-  Given an item <i>, adds one record to the mutable vec\n-  <impls> if the item is an impl; zero or more records if the\n-  item is a class; and none otherwise. Each record describes\n-  one interface implemented by i.\n- */\n-fn find_impls_in_item(e: env, i: @ast::item, &impls: ~[@_impl],\n-                      name: option<ident>,\n-                      ck_exports: option<@indexed_mod>) {\n-    alt i.node {\n-      ast::item_impl(_, ifce, _, mthds) {\n-        if alt name { some(n) { n == i.ident } _ { true } } &&\n-           alt ck_exports {\n-             some(m) { is_exported(e, i.ident, m) }\n-             _ { true }\n-           } {\n-            vec::push(impls, @{did: local_def(i.id),\n-                        ident: i.ident,\n-                               methods: vec::map(mthds, |m| {\n-                            @{did: local_def(m.id),\n-                              n_tps: vec::len(m.tps),\n-                              ident: m.ident}\n-                        })});\n-        }\n-      }\n-      ast::item_class(tps, ifces, items, _, _) {\n-          let (_, mthds) = ast_util::split_class_items(items);\n-          let n_tps = tps.len();\n-        do vec::iter(ifces) |p| {\n-            // The def_id, in this case, identifies the combination of\n-            // class and trait\n-            vec::push(impls, @{did: local_def(p.impl_id),\n-                               ident: i.ident,\n-                               methods: vec::map(mthds, |m| {\n-                                   @{did: local_def(m.id),\n-                                     n_tps: n_tps + m.tps.len(),\n-                                     ident: m.ident}})});\n-          }\n-      }\n-      _ {}\n-    }\n-}\n-\n-fn find_impls_in_mod_by_id(e: env, defid: def_id, &impls: ~[@_impl],\n-                           name: option<ident>) {\n-    let mut cached;\n-    alt e.impl_cache.find(defid) {\n-      some(some(v)) { cached = v; }\n-      some(none) { ret; }\n-      none {\n-        e.impl_cache.insert(defid, none);\n-        cached = if defid.crate == ast::local_crate {\n-            let mut tmp = ~[];\n-            let mi = e.mod_map.get(defid.node);\n-            let md = option::get(mi.m);\n-            for md.view_items.each |vi| {\n-                find_impls_in_view_item(e, vi, tmp, none);\n-            }\n-            for md.items.each |i| {\n-                find_impls_in_item(e, i, tmp, none, none);\n-            }\n-            @vec::filter(tmp, |i| is_exported(e, i.ident, mi))\n-        } else {\n-            csearch::get_impls_for_mod(e.sess.cstore, defid, none)\n-        };\n-        e.impl_cache.insert(defid, some(cached));\n-      }\n-    }\n-    alt name {\n-      some(n) {\n-        for vec::each(*cached) |im| {\n-            if n == im.ident { vec::push(impls, im); }\n-        }\n-      }\n-      _ { vec::push_all(impls, *cached); }\n-    }\n-}\n-\n-fn find_impls_in_mod(e: env, m: def, &impls: ~[@_impl],\n-                     name: option<ident>) {\n-    alt m {\n-      ast::def_mod(defid) {\n-        find_impls_in_mod_by_id(e, defid, impls, name);\n-      }\n-      _ {}\n-    }\n-}\n-\n-fn visit_block_with_impl_scope(e: @env, b: ast::blk, &&sc: iscopes,\n-                               v: vt<iscopes>) {\n-    let mut impls = ~[];\n-    for b.node.view_items.each |vi| {\n-        find_impls_in_view_item(*e, vi, impls, some(sc));\n-    }\n-    for b.node.stmts.each |st| {\n-        alt st.node {\n-          ast::stmt_decl(@{node: ast::decl_item(i), _}, _) {\n-            find_impls_in_item(*e, i, impls, none, none);\n-          }\n-          _ {}\n-        }\n-    }\n-    let sc = if vec::len(impls) > 0u { @cons(@impls, sc) } else { sc };\n-    visit::visit_block(b, sc, v);\n-}\n-\n-fn visit_mod_with_impl_scope(e: @env, m: ast::_mod, s: span, id: node_id,\n-                             &&sc: iscopes, v: vt<iscopes>) {\n-    let mut impls = ~[];\n-    for m.view_items.each |vi| {\n-        find_impls_in_view_item(*e, vi, impls, some(sc));\n-    }\n-    for m.items.each |i| { find_impls_in_item(*e, i, impls, none, none); }\n-    let impls = @impls;\n-    visit::visit_mod(m, s, id, if vec::len(*impls) > 0u {\n-                                   @cons(impls, sc)\n-                               } else {\n-                                   sc\n-                               }, v);\n-    e.impl_map.insert(id, @cons(impls, @nil));\n-}\n-\n-fn resolve_impl_in_expr(e: @env, x: @ast::expr,\n-                        &&sc: iscopes, v: vt<iscopes>) {\n-    alt x.node {\n-      // Store the visible impls in all exprs that might need them\n-      ast::expr_field(_, _, _) | ast::expr_path(_) | ast::expr_cast(_, _) |\n-      ast::expr_binary(_, _, _) | ast::expr_unary(_, _) |\n-      ast::expr_assign_op(_, _, _) | ast::expr_index(_, _) {\n-        e.impl_map.insert(x.id, sc);\n-      }\n-      ast::expr_new(p, _, _) {\n-        e.impl_map.insert(p.id, sc);\n-      }\n-      _ {}\n-    }\n-    visit::visit_expr(x, sc, v);\n-}\n+type exp = {reexp: bool, id: def_id};\n+type exp_map = hashmap<node_id, ~[exp]>;\n \n // Local Variables:\n // mode: rust"}, {"sha": "9cf70d10429ad5edac02fa1d575ac60b9ce65d6a", "filename": "src/rustc/middle/trans/alt.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cf9a9d1ae8ed74a69b529f526eed1462813817cd/src%2Frustc%2Fmiddle%2Ftrans%2Falt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf9a9d1ae8ed74a69b529f526eed1462813817cd/src%2Frustc%2Fmiddle%2Ftrans%2Falt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Falt.rs?ref=cf9a9d1ae8ed74a69b529f526eed1462813817cd", "patch": "@@ -10,8 +10,8 @@ import syntax::ast_util::{dummy_sp, path_to_ident};\n import syntax::ast::def_id;\n import syntax::codemap::span;\n import syntax::print::pprust::pat_to_str;\n+import middle::resolve::def_map;\n import back::abi;\n-import resolve::def_map;\n import std::map::hashmap;\n import dvec::{dvec, extensions};\n "}, {"sha": "884ab33ee721e42e6a7d972770637e75c0a8917d", "filename": "src/rustdoc/astsrv.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/cf9a9d1ae8ed74a69b529f526eed1462813817cd/src%2Frustdoc%2Fastsrv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf9a9d1ae8ed74a69b529f526eed1462813817cd/src%2Frustdoc%2Fastsrv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustdoc%2Fastsrv.rs?ref=cf9a9d1ae8ed74a69b529f526eed1462813817cd", "patch": "@@ -21,6 +21,7 @@ import rustc::back::link;\n import rustc::metadata::filesearch;\n import rustc::front;\n import rustc::middle::resolve;\n+import rustc::middle::resolve3;\n \n export ctxt;\n export ctxt_handler;\n@@ -115,7 +116,7 @@ fn build_ctxt(sess: session,\n     let ast = front::test::modify_for_testing(sess, ast);\n     let ast_map = ast_map::map_crate(sess.diagnostic(), *ast);\n     *ignore_errors = true;\n-    let {exp_map, impl_map, _} = resolve::resolve_crate(sess, ast_map, ast);\n+    let {exp_map, impl_map, _} = resolve3::resolve_crate(sess, ast_map, ast);\n     *ignore_errors = false;\n \n     {"}, {"sha": "75f53b7ab0a8ebb0064d4050d1b5bfea2dbcda52", "filename": "src/rustdoc/reexport_pass.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/cf9a9d1ae8ed74a69b529f526eed1462813817cd/src%2Frustdoc%2Freexport_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf9a9d1ae8ed74a69b529f526eed1462813817cd/src%2Frustdoc%2Freexport_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustdoc%2Freexport_pass.rs?ref=cf9a9d1ae8ed74a69b529f526eed1462813817cd", "patch": "@@ -270,8 +270,8 @@ fn for_each_reexported_impl(\n         mod_id: ast::node_id\n     ) {\n         let all_impls = all_impls(m);\n-        alt check *ctxt.impl_map.get(mod_id) {\n-          list::cons(impls, @list::nil) {\n+        alt *ctxt.impl_map.get(mod_id) {\n+          list::cons(impls, _) {\n             for vec::each(*impls) |i| {\n                 // This impl is not an item in the current mod\n                 if !all_impls.contains_key(i.did) {\n@@ -283,6 +283,9 @@ fn for_each_reexported_impl(\n                 }\n             }\n           }\n+          list::nil {\n+            // Do nothing -- mod has no impls\n+          }\n         }\n     }\n }"}]}