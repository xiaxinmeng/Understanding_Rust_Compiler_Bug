{"sha": "3ae974f025d4376c720e3b2773ccd2c201f098dc", "node_id": "MDY6Q29tbWl0NzI0NzEyOjNhZTk3NGYwMjVkNDM3NmM3MjBlM2IyNzczY2NkMmMyMDFmMDk4ZGM=", "commit": {"author": {"name": "YI", "email": "uuuuuu@protonmail.com", "date": "2020-02-25T10:15:23Z"}, "committer": {"name": "YI", "email": "uuuuuu@protonmail.com", "date": "2020-04-08T03:52:29Z"}, "message": "fix misleading type annotation diagonstics\n\nThis solves the method call part of issue\nhttps://github.com/rust-lang/rust/issues/69455\nI added a `target_span` field so as to pin down the exact location of\nthe error. We need a dedicated field `found_exact_method_call` to\nprioritize situations like the test case `issue-69455.rs`. If we reuse\n`found_method_call`, `found_local_pattern` will show up first. We can\nnot move `found_method_call` up, it is undesirable in various\nsituations.", "tree": {"sha": "79b3145b4cc4942eac197ca3b4a9f72481112f95", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/79b3145b4cc4942eac197ca3b4a9f72481112f95"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3ae974f025d4376c720e3b2773ccd2c201f098dc", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3ae974f025d4376c720e3b2773ccd2c201f098dc", "html_url": "https://github.com/rust-lang/rust/commit/3ae974f025d4376c720e3b2773ccd2c201f098dc", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3ae974f025d4376c720e3b2773ccd2c201f098dc/comments", "author": {"login": "contrun", "id": 32609395, "node_id": "MDQ6VXNlcjMyNjA5Mzk1", "avatar_url": "https://avatars.githubusercontent.com/u/32609395?v=4", "gravatar_id": "", "url": "https://api.github.com/users/contrun", "html_url": "https://github.com/contrun", "followers_url": "https://api.github.com/users/contrun/followers", "following_url": "https://api.github.com/users/contrun/following{/other_user}", "gists_url": "https://api.github.com/users/contrun/gists{/gist_id}", "starred_url": "https://api.github.com/users/contrun/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/contrun/subscriptions", "organizations_url": "https://api.github.com/users/contrun/orgs", "repos_url": "https://api.github.com/users/contrun/repos", "events_url": "https://api.github.com/users/contrun/events{/privacy}", "received_events_url": "https://api.github.com/users/contrun/received_events", "type": "User", "site_admin": false}, "committer": {"login": "contrun", "id": 32609395, "node_id": "MDQ6VXNlcjMyNjA5Mzk1", "avatar_url": "https://avatars.githubusercontent.com/u/32609395?v=4", "gravatar_id": "", "url": "https://api.github.com/users/contrun", "html_url": "https://github.com/contrun", "followers_url": "https://api.github.com/users/contrun/followers", "following_url": "https://api.github.com/users/contrun/following{/other_user}", "gists_url": "https://api.github.com/users/contrun/gists{/gist_id}", "starred_url": "https://api.github.com/users/contrun/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/contrun/subscriptions", "organizations_url": "https://api.github.com/users/contrun/orgs", "repos_url": "https://api.github.com/users/contrun/repos", "events_url": "https://api.github.com/users/contrun/events{/privacy}", "received_events_url": "https://api.github.com/users/contrun/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "39b62533c7f9d0581a6ea9b9fc2cc51f21c3b5b0", "url": "https://api.github.com/repos/rust-lang/rust/commits/39b62533c7f9d0581a6ea9b9fc2cc51f21c3b5b0", "html_url": "https://github.com/rust-lang/rust/commit/39b62533c7f9d0581a6ea9b9fc2cc51f21c3b5b0"}], "stats": {"total": 105, "additions": 99, "deletions": 6}, "files": [{"sha": "53f52038ed0222676ab2e1f0642f368e05ebfc8c", "filename": "src/librustc_infer/infer/error_reporting/need_type_info.rs", "status": "modified", "additions": 52, "deletions": 6, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/3ae974f025d4376c720e3b2773ccd2c201f098dc/src%2Flibrustc_infer%2Finfer%2Ferror_reporting%2Fneed_type_info.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ae974f025d4376c720e3b2773ccd2c201f098dc/src%2Flibrustc_infer%2Finfer%2Ferror_reporting%2Fneed_type_info.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_infer%2Finfer%2Ferror_reporting%2Fneed_type_info.rs?ref=3ae974f025d4376c720e3b2773ccd2c201f098dc", "patch": "@@ -17,23 +17,27 @@ use std::borrow::Cow;\n struct FindHirNodeVisitor<'a, 'tcx> {\n     infcx: &'a InferCtxt<'a, 'tcx>,\n     target: GenericArg<'tcx>,\n+    target_span: Span,\n     found_node_ty: Option<Ty<'tcx>>,\n     found_local_pattern: Option<&'tcx Pat<'tcx>>,\n     found_arg_pattern: Option<&'tcx Pat<'tcx>>,\n     found_closure: Option<&'tcx Expr<'tcx>>,\n     found_method_call: Option<&'tcx Expr<'tcx>>,\n+    found_exact_method_call: Option<&'tcx Expr<'tcx>>,\n }\n \n impl<'a, 'tcx> FindHirNodeVisitor<'a, 'tcx> {\n-    fn new(infcx: &'a InferCtxt<'a, 'tcx>, target: GenericArg<'tcx>) -> Self {\n+    fn new(infcx: &'a InferCtxt<'a, 'tcx>, target: GenericArg<'tcx>, target_span: Span) -> Self {\n         Self {\n             infcx,\n             target,\n+            target_span,\n             found_node_ty: None,\n             found_local_pattern: None,\n             found_arg_pattern: None,\n             found_closure: None,\n             found_method_call: None,\n+            found_exact_method_call: None,\n         }\n     }\n \n@@ -103,6 +107,17 @@ impl<'a, 'tcx> Visitor<'tcx> for FindHirNodeVisitor<'a, 'tcx> {\n     }\n \n     fn visit_expr(&mut self, expr: &'tcx Expr<'tcx>) {\n+        if let ExprKind::MethodCall(_, call_span, exprs) = expr.kind {\n+            if call_span == self.target_span\n+                && Some(self.target)\n+                    == self.infcx.in_progress_tables.and_then(|tables| {\n+                        tables.borrow().node_type_opt(exprs.first().unwrap().hir_id).map(Into::into)\n+                    })\n+            {\n+                self.found_exact_method_call = Some(&expr);\n+                return;\n+            }\n+        }\n         if self.node_ty_contains_target(expr.hir_id).is_some() {\n             match expr.kind {\n                 ExprKind::Closure(..) => self.found_closure = Some(&expr),\n@@ -234,7 +249,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n         let ty = self.resolve_vars_if_possible(&ty);\n         let (name, name_sp, descr, parent_name, parent_descr) = self.extract_type_name(&ty, None);\n \n-        let mut local_visitor = FindHirNodeVisitor::new(&self, ty.into());\n+        let mut local_visitor = FindHirNodeVisitor::new(&self, ty.into(), span);\n         let ty_to_string = |ty: Ty<'tcx>| -> String {\n             let mut s = String::new();\n             let mut printer = ty::print::FmtPrinter::new(self.tcx, &mut s, Namespace::TypeNS);\n@@ -287,14 +302,15 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                 (!ty.is_impl_trait() || self.tcx.features().impl_trait_in_bindings)\n         };\n \n-        let ty_msg = match local_visitor.found_node_ty {\n-            Some(ty::TyS { kind: ty::Closure(_, substs), .. }) => {\n+        let ty_msg = match (local_visitor.found_node_ty, local_visitor.found_exact_method_call) {\n+            (_, Some(_)) => String::new(),\n+            (Some(ty::TyS { kind: ty::Closure(_, substs), .. }), _) => {\n                 let fn_sig = substs.as_closure().sig();\n                 let args = closure_args(&fn_sig);\n                 let ret = fn_sig.output().skip_binder().to_string();\n                 format!(\" for the closure `fn({}) -> {}`\", args, ret)\n             }\n-            Some(ty) if is_named_and_not_impl_trait(ty) => {\n+            (Some(ty), _) if is_named_and_not_impl_trait(ty) => {\n                 let ty = ty_to_string(ty);\n                 format!(\" for `{}`\", ty)\n             }\n@@ -370,7 +386,37 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n             _ => \"a type\".to_string(),\n         };\n \n-        if let Some(pattern) = local_visitor.found_arg_pattern {\n+        if let Some(e) = local_visitor.found_exact_method_call {\n+            if let ExprKind::MethodCall(segment, ..) = &e.kind {\n+                // Suggest specifying type params or point out the return type of the call:\n+                //\n+                // error[E0282]: type annotations needed\n+                //   --> $DIR/type-annotations-needed-expr.rs:2:39\n+                //    |\n+                // LL |     let _ = x.into_iter().sum() as f64;\n+                //    |                           ^^^\n+                //    |                           |\n+                //    |                           cannot infer type for `S`\n+                //    |                           help: consider specifying the type argument in\n+                //    |                           the method call: `sum::<S>`\n+                //    |\n+                //    = note: type must be known at this point\n+                //\n+                // or\n+                //\n+                // error[E0282]: type annotations needed\n+                //   --> $DIR/issue-65611.rs:59:20\n+                //    |\n+                // LL |     let x = buffer.last().unwrap().0.clone();\n+                //    |             -------^^^^--\n+                //    |             |      |\n+                //    |             |      cannot infer type for `T`\n+                //    |             this method call resolves to `std::option::Option<&T>`\n+                //    |\n+                //    = note: type must be known at this point\n+                self.annotate_method_call(segment, e, &mut err);\n+            }\n+        } else if let Some(pattern) = local_visitor.found_arg_pattern {\n             // We don't want to show the default label for closures.\n             //\n             // So, before clearing, the output would look something like this:"}, {"sha": "017654554be16086ee9ac3373b49673277e8a95b", "filename": "src/test/ui/issues/issue-69455.rs", "status": "added", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/3ae974f025d4376c720e3b2773ccd2c201f098dc/src%2Ftest%2Fui%2Fissues%2Fissue-69455.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ae974f025d4376c720e3b2773ccd2c201f098dc/src%2Ftest%2Fui%2Fissues%2Fissue-69455.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-69455.rs?ref=3ae974f025d4376c720e3b2773ccd2c201f098dc", "patch": "@@ -0,0 +1,30 @@\n+// Regression test for #69455: projection predicate was not satisfied.\n+// Compiler should indicate the correct location of the\n+// unsatisfied projection predicate\n+\n+pub trait Test<Rhs = Self> {\n+    type Output;\n+\n+    fn test(self, rhs: Rhs) -> Self::Output;\n+}\n+\n+impl Test<u32> for u64 {\n+    type Output = u64;\n+\n+    fn test(self, other: u32) -> u64 {\n+        self + (other as u64)\n+    }\n+}\n+\n+impl Test<u64> for u64 {\n+    type Output = u64;\n+\n+    fn test(self, other: u64) -> u64 {\n+        (self + other) as u64\n+    }\n+}\n+\n+fn main() {\n+    let xs: Vec<u64> = vec![1, 2, 3];\n+    println!(\"{}\", 23u64.test(xs.iter().sum())); //~ ERROR: type annotations needed [E0284]\n+}"}, {"sha": "4caa1aca9fd21535e7d8efebe6b74fb3698055f2", "filename": "src/test/ui/issues/issue-69455.stderr", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/3ae974f025d4376c720e3b2773ccd2c201f098dc/src%2Ftest%2Fui%2Fissues%2Fissue-69455.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/3ae974f025d4376c720e3b2773ccd2c201f098dc/src%2Ftest%2Fui%2Fissues%2Fissue-69455.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-69455.stderr?ref=3ae974f025d4376c720e3b2773ccd2c201f098dc", "patch": "@@ -0,0 +1,17 @@\n+error[E0284]: type annotations needed\n+  --> $DIR/issue-69455.rs:29:26\n+   |\n+LL |     type Output;\n+   |     ------------ `<Self as Test<Rhs>>::Output` defined here\n+...\n+LL |     println!(\"{}\", 23u64.test(xs.iter().sum()));\n+   |                    ------^^^^-----------------\n+   |                    |     |\n+   |                    |     cannot infer type for type `u64`\n+   |                    this method call resolves to `<Self as Test<Rhs>>::Output`\n+   |\n+   = note: cannot satisfy `<u64 as Test<_>>::Output == _`\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0284`."}]}