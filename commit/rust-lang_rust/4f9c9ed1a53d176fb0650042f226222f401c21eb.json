{"sha": "4f9c9ed1a53d176fb0650042f226222f401c21eb", "node_id": "MDY6Q29tbWl0NzI0NzEyOjRmOWM5ZWQxYTUzZDE3NmZiMDY1MDA0MmYyMjYyMjJmNDAxYzIxZWI=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-05-25T22:31:34Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-05-25T22:31:34Z"}, "message": "Auto merge of #40847 - jseyfried:decl_macro, r=nrc\n\nInitial implementation of declarative macros 2.0\n\nImplement declarative macros 2.0 (rust-lang/rfcs#1584) behind `#![feature(decl_macro)]`.\nDifferences from `macro_rules!` include:\n - new syntax: `macro m(..) { .. }` instead of `macro_rules! m { (..) => { .. } }`\n - declarative macros are items:\n```rust\n// crate A:\npub mod foo {\n    m!(); // use before definition; declaration order is irrelevant\n    pub macro m() {} // `pub`, `pub(super)`, etc. work\n}\nfn main() {\n    foo::m!(); // named like other items\n    { use foo::m as n; n!(); } // imported like other items\n}\npub use foo::m; // re-exported like other items\n\n// crate B:\nextern crate A; // no need for `#[macro_use]`\nA::foo::m!(); A::m!();\n```\n - Racket-like hygiene for items, imports, methods, fields, type parameters, privacy, etc.\n   - Intuitively, names in a macro definition are resolved in the macro definition's scope, not the scope in which the macro is used.\n   - This [explaination](http://beautifulracket.com/explainer/hygiene.html) of hygiene for Racket applies here (except for the \"Breaking Hygiene\" section). I wrote a similar [explanation](https://github.com/jseyfried/rfcs/blob/hygiene/text/0000-hygiene.md) for Rust.\n   - Generally speaking, if `fn f() { <body> }` resolves, `pub macro m() { <body> } ... m!()` also resolves, even if `m!()` is in a separate crate.\n   - `::foo::bar` in a `macro` behaves like `$crate::foo::bar` in a `macro_rules!`, except it can access everything visible from the `macro` (thus more permissive).\n   - See [`src/test/{run-pass, compile-fail}/hygiene`](https://github.com/rust-lang/rust/pull/40847/commits/afe7d89858fd72b983e24727d6f4058293153c19) for examples. Small example:\n```rust\nmod foo {\n    fn f() { println!(\"hello world\"); }\n    pub macro m() { f(); }\n}\nfn main() { foo::m!(); }\n```\n\nLimitations:\n - This does not address planned changes to matchers (`expr`,`ty`, etc.), c.f. #26361.\n - Lints (including stability and deprecation) and `unsafe` are not hygienic.\n   - adding hygiene here will be mostly or entirely backwards compatible\n - Nested macro definitions (a `macro` inside another `macro`) don't always work correctly when invoked from external crates.\n   - pending improvements in how we encode macro definitions in crate metadata\n - There is no way to \"escape\" hygiene without using a procedural macro.\n\nr? @nrc", "tree": {"sha": "4032674e5d87460e1483240a2471c3b031d9b0cc", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4032674e5d87460e1483240a2471c3b031d9b0cc"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4f9c9ed1a53d176fb0650042f226222f401c21eb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4f9c9ed1a53d176fb0650042f226222f401c21eb", "html_url": "https://github.com/rust-lang/rust/commit/4f9c9ed1a53d176fb0650042f226222f401c21eb", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4f9c9ed1a53d176fb0650042f226222f401c21eb/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5f39668642e445fedcf477493f206905dc51c2c8", "url": "https://api.github.com/repos/rust-lang/rust/commits/5f39668642e445fedcf477493f206905dc51c2c8", "html_url": "https://github.com/rust-lang/rust/commit/5f39668642e445fedcf477493f206905dc51c2c8"}, {"sha": "dc34ea092976ab9a87e68f1b255b4afbe31a9475", "url": "https://api.github.com/repos/rust-lang/rust/commits/dc34ea092976ab9a87e68f1b255b4afbe31a9475", "html_url": "https://github.com/rust-lang/rust/commit/dc34ea092976ab9a87e68f1b255b4afbe31a9475"}], "stats": {"total": 2053, "additions": 1574, "deletions": 479}, "files": [{"sha": "4700b252e2d1af63e4fee26986d127995cfc797b", "filename": "src/doc/unstable-book/src/language-features/decl-macro.md", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/4f9c9ed1a53d176fb0650042f226222f401c21eb/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fdecl-macro.md", "raw_url": "https://github.com/rust-lang/rust/raw/4f9c9ed1a53d176fb0650042f226222f401c21eb/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fdecl-macro.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fdecl-macro.md?ref=4f9c9ed1a53d176fb0650042f226222f401c21eb", "patch": "@@ -0,0 +1,10 @@\n+# `decl_macro`\n+\n+The tracking issue for this feature is: [#39412]\n+\n+[#39412]: https://github.com/rust-lang/rust/issues/39412\n+\n+------------------------\n+\n+\n+"}, {"sha": "feded417ce17fb7910d62a4e671c7ea0a48575be", "filename": "src/librustc/hir/def.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4f9c9ed1a53d176fb0650042f226222f401c21eb/src%2Flibrustc%2Fhir%2Fdef.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f9c9ed1a53d176fb0650042f226222f401c21eb/src%2Flibrustc%2Fhir%2Fdef.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fdef.rs?ref=4f9c9ed1a53d176fb0650042f226222f401c21eb", "patch": "@@ -117,7 +117,7 @@ pub type ExportMap = NodeMap<Vec<Export>>;\n \n #[derive(Copy, Clone, Debug, RustcEncodable, RustcDecodable)]\n pub struct Export {\n-    pub name: ast::Name, // The name of the target.\n+    pub ident: ast::Ident, // The name of the target.\n     pub def: Def, // The definition of the target.\n     pub span: Span, // The span of the target definition.\n }"}, {"sha": "91cfbc38aa0ece054207968b2844c7dfcd942885", "filename": "src/librustc/hir/lowering.rs", "status": "modified", "additions": 43, "deletions": 24, "changes": 67, "blob_url": "https://github.com/rust-lang/rust/blob/4f9c9ed1a53d176fb0650042f226222f401c21eb/src%2Flibrustc%2Fhir%2Flowering.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f9c9ed1a53d176fb0650042f226222f401c21eb/src%2Flibrustc%2Fhir%2Flowering.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Flowering.rs?ref=4f9c9ed1a53d176fb0650042f226222f401c21eb", "patch": "@@ -47,7 +47,7 @@ use hir::def_id::{DefIndex, DefId, CRATE_DEF_INDEX};\n use hir::def::{Def, PathResolution};\n use rustc_data_structures::indexed_vec::IndexVec;\n use session::Session;\n-use util::nodemap::{DefIdMap, NodeMap};\n+use util::nodemap::{DefIdMap, FxHashMap, NodeMap};\n \n use std::collections::BTreeMap;\n use std::fmt::Debug;\n@@ -77,6 +77,7 @@ pub struct LoweringContext<'a> {\n     // a definition, then we can properly create the def id.\n     parent_def: Option<DefIndex>,\n     resolver: &'a mut Resolver,\n+    name_map: FxHashMap<Ident, Name>,\n \n     /// The items being lowered are collected here.\n     items: BTreeMap<NodeId, hir::Item>,\n@@ -126,6 +127,7 @@ pub fn lower_crate(sess: &Session,\n         sess: sess,\n         parent_def: None,\n         resolver: resolver,\n+        name_map: FxHashMap(),\n         items: BTreeMap::new(),\n         trait_items: BTreeMap::new(),\n         impl_items: BTreeMap::new(),\n@@ -393,7 +395,7 @@ impl<'a> LoweringContext<'a> {\n     }\n \n     fn allow_internal_unstable(&self, reason: &'static str, mut span: Span) -> Span {\n-        let mark = Mark::fresh();\n+        let mark = Mark::fresh(Mark::root());\n         mark.set_expn_info(codemap::ExpnInfo {\n             call_site: span,\n             callee: codemap::NameAndSpan {\n@@ -495,6 +497,14 @@ impl<'a> LoweringContext<'a> {\n         }\n     }\n \n+    fn lower_ident(&mut self, ident: Ident) -> Name {\n+        let ident = ident.modern();\n+        if ident.ctxt == SyntaxContext::empty() {\n+            return ident.name;\n+        }\n+        *self.name_map.entry(ident).or_insert_with(|| Symbol::from_ident(ident))\n+    }\n+\n     fn lower_opt_sp_ident(&mut self, o_id: Option<Spanned<Ident>>) -> Option<Spanned<Name>> {\n         o_id.map(|sp_ident| respan(sp_ident.span, sp_ident.node.name))\n     }\n@@ -546,7 +556,7 @@ impl<'a> LoweringContext<'a> {\n     fn lower_ty_binding(&mut self, b: &TypeBinding) -> hir::TypeBinding {\n         hir::TypeBinding {\n             id: self.lower_node_id(b.id),\n-            name: b.ident.name,\n+            name: self.lower_ident(b.ident),\n             ty: self.lower_ty(&b.ty),\n             span: b.span,\n         }\n@@ -844,7 +854,7 @@ impl<'a> LoweringContext<'a> {\n         }\n \n         hir::PathSegment {\n-            name: segment.identifier.name,\n+            name: self.lower_ident(segment.identifier),\n             parameters: parameters,\n         }\n     }\n@@ -941,7 +951,7 @@ impl<'a> LoweringContext<'a> {\n     }\n \n     fn lower_ty_param(&mut self, tp: &TyParam, add_bounds: &[TyParamBound]) -> hir::TyParam {\n-        let mut name = tp.ident.name;\n+        let mut name = self.lower_ident(tp.ident);\n \n         // Don't expose `Self` (recovered \"keyword used as ident\" parse error).\n         // `rustc::ty` expects `Self` to be only used for a trait's `Self`.\n@@ -975,7 +985,7 @@ impl<'a> LoweringContext<'a> {\n     fn lower_lifetime(&mut self, l: &Lifetime) -> hir::Lifetime {\n         hir::Lifetime {\n             id: self.lower_node_id(l.id),\n-            name: l.name,\n+            name: self.lower_ident(l.ident),\n             span: l.span,\n         }\n     }\n@@ -1137,7 +1147,11 @@ impl<'a> LoweringContext<'a> {\n         hir::StructField {\n             span: f.span,\n             id: self.lower_node_id(f.id),\n-            name: f.ident.map(|ident| ident.name).unwrap_or(Symbol::intern(&index.to_string())),\n+            name: self.lower_ident(match f.ident {\n+                Some(ident) => ident,\n+                // FIXME(jseyfried) positional field hygiene\n+                None => Ident { name: Symbol::intern(&index.to_string()), ctxt: f.span.ctxt },\n+            }),\n             vis: self.lower_visibility(&f.vis, None),\n             ty: self.lower_ty(&f.ty),\n             attrs: self.lower_attrs(&f.attrs),\n@@ -1146,7 +1160,7 @@ impl<'a> LoweringContext<'a> {\n \n     fn lower_field(&mut self, f: &Field) -> hir::Field {\n         hir::Field {\n-            name: respan(f.ident.span, f.ident.node.name),\n+            name: respan(f.ident.span, self.lower_ident(f.ident.node)),\n             expr: P(self.lower_expr(&f.expr)),\n             span: f.span,\n             is_shorthand: f.is_shorthand,\n@@ -1371,7 +1385,7 @@ impl<'a> LoweringContext<'a> {\n         self.with_parent_def(i.id, |this| {\n             hir::TraitItem {\n                 id: this.lower_node_id(i.id),\n-                name: i.ident.name,\n+                name: this.lower_ident(i.ident),\n                 attrs: this.lower_attrs(&i.attrs),\n                 node: match i.node {\n                     TraitItemKind::Const(ref ty, ref default) => {\n@@ -1421,7 +1435,7 @@ impl<'a> LoweringContext<'a> {\n         };\n         hir::TraitItemRef {\n             id: hir::TraitItemId { node_id: i.id },\n-            name: i.ident.name,\n+            name: self.lower_ident(i.ident),\n             span: i.span,\n             defaultness: self.lower_defaultness(Defaultness::Default, has_default),\n             kind: kind,\n@@ -1432,7 +1446,7 @@ impl<'a> LoweringContext<'a> {\n         self.with_parent_def(i.id, |this| {\n             hir::ImplItem {\n                 id: this.lower_node_id(i.id),\n-                name: i.ident.name,\n+                name: this.lower_ident(i.ident),\n                 attrs: this.lower_attrs(&i.attrs),\n                 vis: this.lower_visibility(&i.vis, None),\n                 defaultness: this.lower_defaultness(i.defaultness, true /* [1] */),\n@@ -1461,7 +1475,7 @@ impl<'a> LoweringContext<'a> {\n     fn lower_impl_item_ref(&mut self, i: &ImplItem) -> hir::ImplItemRef {\n         hir::ImplItemRef {\n             id: hir::ImplItemId { node_id: i.id },\n-            name: i.ident.name,\n+            name: self.lower_ident(i.ident),\n             span: i.span,\n             vis: self.lower_visibility(&i.vis, Some(i.id)),\n             defaultness: self.lower_defaultness(i.defaultness, true /* [1] */),\n@@ -1501,17 +1515,23 @@ impl<'a> LoweringContext<'a> {\n \n     pub fn lower_item(&mut self, i: &Item) -> Option<hir::Item> {\n         let mut name = i.ident.name;\n+        let mut vis = self.lower_visibility(&i.vis, None);\n         let attrs = self.lower_attrs(&i.attrs);\n-        if let ItemKind::MacroDef(ref tts) = i.node {\n-            if i.attrs.iter().any(|attr| attr.path == \"macro_export\") {\n+        if let ItemKind::MacroDef(ref def) = i.node {\n+            if !def.legacy || i.attrs.iter().any(|attr| attr.path == \"macro_export\") {\n                 self.exported_macros.push(hir::MacroDef {\n-                    name: name, attrs: attrs, id: i.id, span: i.span, body: tts.clone().into(),\n+                    name: name,\n+                    vis: vis,\n+                    attrs: attrs,\n+                    id: i.id,\n+                    span: i.span,\n+                    body: def.stream(),\n+                    legacy: def.legacy,\n                 });\n             }\n             return None;\n         }\n \n-        let mut vis = self.lower_visibility(&i.vis, None);\n         let node = self.with_parent_def(i.id, |this| {\n             this.lower_item_kind(i.id, &mut name, &attrs, &mut vis, &i.node)\n         });\n@@ -1654,7 +1674,7 @@ impl<'a> LoweringContext<'a> {\n                                        Spanned {\n                                            span: f.span,\n                                            node: hir::FieldPat {\n-                                               name: f.node.ident.name,\n+                                               name: self.lower_ident(f.node.ident),\n                                                pat: self.lower_pat(&f.node.pat),\n                                                is_shorthand: f.node.is_shorthand,\n                                            },\n@@ -1824,7 +1844,7 @@ impl<'a> LoweringContext<'a> {\n             ExprKind::MethodCall(i, ref tps, ref args) => {\n                 let tps = tps.iter().map(|x| self.lower_ty(x)).collect();\n                 let args = args.iter().map(|x| self.lower_expr(x)).collect();\n-                hir::ExprMethodCall(respan(i.span, i.node.name), tps, args)\n+                hir::ExprMethodCall(respan(i.span, self.lower_ident(i.node)), tps, args)\n             }\n             ExprKind::Binary(binop, ref lhs, ref rhs) => {\n                 let binop = self.lower_binop(binop);\n@@ -1923,7 +1943,8 @@ impl<'a> LoweringContext<'a> {\n                                   P(self.lower_expr(er)))\n             }\n             ExprKind::Field(ref el, ident) => {\n-                hir::ExprField(P(self.lower_expr(el)), respan(ident.span, ident.node.name))\n+                hir::ExprField(P(self.lower_expr(el)),\n+                               respan(ident.span, self.lower_ident(ident.node)))\n             }\n             ExprKind::TupField(ref el, ident) => {\n                 hir::ExprTupField(P(self.lower_expr(el)), ident)\n@@ -2641,11 +2662,9 @@ impl<'a> LoweringContext<'a> {\n         let parent_def = self.parent_def.unwrap();\n         let def_id = {\n             let defs = self.resolver.definitions();\n-            let def_path_data = DefPathData::Binding(name.as_str());\n-            let def_index = defs.create_def_with_parent(parent_def,\n-                                                        id,\n-                                                        def_path_data,\n-                                                        REGULAR_SPACE);\n+            let def_path_data = DefPathData::Binding(Ident::with_empty_ctxt(name));\n+            let def_index = defs\n+                .create_def_with_parent(parent_def, id, def_path_data, REGULAR_SPACE, Mark::root());\n             DefId::local(def_index)\n         };\n "}, {"sha": "cb25b462b6e243e791514e80316b73e29d5647c2", "filename": "src/librustc/hir/map/def_collector.rs", "status": "modified", "additions": 25, "deletions": 24, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/4f9c9ed1a53d176fb0650042f226222f401c21eb/src%2Flibrustc%2Fhir%2Fmap%2Fdef_collector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f9c9ed1a53d176fb0650042f226222f401c21eb/src%2Flibrustc%2Fhir%2Fmap%2Fdef_collector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fdef_collector.rs?ref=4f9c9ed1a53d176fb0650042f226222f401c21eb", "patch": "@@ -14,14 +14,15 @@ use hir::def_id::{CRATE_DEF_INDEX, DefIndex, DefIndexAddressSpace};\n use syntax::ast::*;\n use syntax::ext::hygiene::Mark;\n use syntax::visit;\n-use syntax::symbol::{Symbol, keywords};\n+use syntax::symbol::keywords;\n \n use hir::map::{ITEM_LIKE_SPACE, REGULAR_SPACE};\n \n /// Creates def ids for nodes in the AST.\n pub struct DefCollector<'a> {\n     definitions: &'a mut Definitions,\n     parent_def: Option<DefIndex>,\n+    expansion: Mark,\n     pub visit_macro_invoc: Option<&'a mut FnMut(MacroInvocationData)>,\n }\n \n@@ -32,9 +33,10 @@ pub struct MacroInvocationData {\n }\n \n impl<'a> DefCollector<'a> {\n-    pub fn new(definitions: &'a mut Definitions) -> Self {\n+    pub fn new(definitions: &'a mut Definitions, expansion: Mark) -> Self {\n         DefCollector {\n             definitions: definitions,\n+            expansion: expansion,\n             parent_def: None,\n             visit_macro_invoc: None,\n         }\n@@ -54,7 +56,8 @@ impl<'a> DefCollector<'a> {\n                   -> DefIndex {\n         let parent_def = self.parent_def.unwrap();\n         debug!(\"create_def(node_id={:?}, data={:?}, parent_def={:?})\", node_id, data, parent_def);\n-        self.definitions.create_def_with_parent(parent_def, node_id, data, address_space)\n+        self.definitions\n+            .create_def_with_parent(parent_def, node_id, data, address_space, self.expansion)\n     }\n \n     pub fn with_parent<F: FnOnce(&mut Self)>(&mut self, parent_def: DefIndex, f: F) {\n@@ -100,14 +103,14 @@ impl<'a> visit::Visitor<'a> for DefCollector<'a> {\n                 DefPathData::Impl,\n             ItemKind::Enum(..) | ItemKind::Struct(..) | ItemKind::Union(..) | ItemKind::Trait(..) |\n             ItemKind::ExternCrate(..) | ItemKind::ForeignMod(..) | ItemKind::Ty(..) =>\n-                DefPathData::TypeNs(i.ident.name.as_str()),\n+                DefPathData::TypeNs(i.ident.modern()),\n             ItemKind::Mod(..) if i.ident == keywords::Invalid.ident() => {\n                 return visit::walk_item(self, i);\n             }\n-            ItemKind::Mod(..) => DefPathData::Module(i.ident.name.as_str()),\n+            ItemKind::Mod(..) => DefPathData::Module(i.ident.modern()),\n             ItemKind::Static(..) | ItemKind::Const(..) | ItemKind::Fn(..) =>\n-                DefPathData::ValueNs(i.ident.name.as_str()),\n-            ItemKind::MacroDef(..) => DefPathData::MacroDef(i.ident.name.as_str()),\n+                DefPathData::ValueNs(i.ident.modern()),\n+            ItemKind::MacroDef(..) => DefPathData::MacroDef(i.ident.modern()),\n             ItemKind::Mac(..) => return self.visit_macro_invoc(i.id, false),\n             ItemKind::GlobalAsm(..) => DefPathData::Misc,\n             ItemKind::Use(ref view_path) => {\n@@ -135,15 +138,13 @@ impl<'a> visit::Visitor<'a> for DefCollector<'a> {\n                     for v in &enum_definition.variants {\n                         let variant_def_index =\n                             this.create_def(v.node.data.id(),\n-                                            DefPathData::EnumVariant(v.node.name.name.as_str()),\n+                                            DefPathData::EnumVariant(v.node.name.modern()),\n                                             REGULAR_SPACE);\n                         this.with_parent(variant_def_index, |this| {\n                             for (index, field) in v.node.data.fields().iter().enumerate() {\n-                                let name = field.ident.map(|ident| ident.name)\n-                                    .unwrap_or_else(|| Symbol::intern(&index.to_string()));\n-                                this.create_def(field.id,\n-                                                DefPathData::Field(name.as_str()),\n-                                                REGULAR_SPACE);\n+                                let ident = field.ident.map(Ident::modern)\n+                                    .unwrap_or_else(|| Ident::from_str(&index.to_string()));\n+                                this.create_def(field.id, DefPathData::Field(ident), REGULAR_SPACE);\n                             }\n \n                             if let Some(ref expr) = v.node.disr_expr {\n@@ -161,9 +162,9 @@ impl<'a> visit::Visitor<'a> for DefCollector<'a> {\n                     }\n \n                     for (index, field) in struct_def.fields().iter().enumerate() {\n-                        let name = field.ident.map(|ident| ident.name.as_str())\n-                            .unwrap_or(Symbol::intern(&index.to_string()).as_str());\n-                        this.create_def(field.id, DefPathData::Field(name), REGULAR_SPACE);\n+                        let ident = field.ident.map(Ident::modern)\n+                            .unwrap_or_else(|| Ident::from_str(&index.to_string()));\n+                        this.create_def(field.id, DefPathData::Field(ident), REGULAR_SPACE);\n                     }\n                 }\n                 _ => {}\n@@ -174,7 +175,7 @@ impl<'a> visit::Visitor<'a> for DefCollector<'a> {\n \n     fn visit_foreign_item(&mut self, foreign_item: &'a ForeignItem) {\n         let def = self.create_def(foreign_item.id,\n-                                  DefPathData::ValueNs(foreign_item.ident.name.as_str()),\n+                                  DefPathData::ValueNs(foreign_item.ident.modern()),\n                                   REGULAR_SPACE);\n \n         self.with_parent(def, |this| {\n@@ -185,7 +186,7 @@ impl<'a> visit::Visitor<'a> for DefCollector<'a> {\n     fn visit_generics(&mut self, generics: &'a Generics) {\n         for ty_param in generics.ty_params.iter() {\n             self.create_def(ty_param.id,\n-                            DefPathData::TypeParam(ty_param.ident.name.as_str()),\n+                            DefPathData::TypeParam(ty_param.ident.modern()),\n                             REGULAR_SPACE);\n         }\n \n@@ -195,8 +196,8 @@ impl<'a> visit::Visitor<'a> for DefCollector<'a> {\n     fn visit_trait_item(&mut self, ti: &'a TraitItem) {\n         let def_data = match ti.node {\n             TraitItemKind::Method(..) | TraitItemKind::Const(..) =>\n-                DefPathData::ValueNs(ti.ident.name.as_str()),\n-            TraitItemKind::Type(..) => DefPathData::TypeNs(ti.ident.name.as_str()),\n+                DefPathData::ValueNs(ti.ident.modern()),\n+            TraitItemKind::Type(..) => DefPathData::TypeNs(ti.ident.modern()),\n             TraitItemKind::Macro(..) => return self.visit_macro_invoc(ti.id, false),\n         };\n \n@@ -213,8 +214,8 @@ impl<'a> visit::Visitor<'a> for DefCollector<'a> {\n     fn visit_impl_item(&mut self, ii: &'a ImplItem) {\n         let def_data = match ii.node {\n             ImplItemKind::Method(..) | ImplItemKind::Const(..) =>\n-                DefPathData::ValueNs(ii.ident.name.as_str()),\n-            ImplItemKind::Type(..) => DefPathData::TypeNs(ii.ident.name.as_str()),\n+                DefPathData::ValueNs(ii.ident.modern()),\n+            ImplItemKind::Type(..) => DefPathData::TypeNs(ii.ident.modern()),\n             ImplItemKind::Macro(..) => return self.visit_macro_invoc(ii.id, false),\n         };\n \n@@ -235,7 +236,7 @@ impl<'a> visit::Visitor<'a> for DefCollector<'a> {\n             PatKind::Mac(..) => return self.visit_macro_invoc(pat.id, false),\n             PatKind::Ident(_, id, _) => {\n                 let def = self.create_def(pat.id,\n-                                          DefPathData::Binding(id.node.name.as_str()),\n+                                          DefPathData::Binding(id.node.modern()),\n                                           REGULAR_SPACE);\n                 self.parent_def = Some(def);\n             }\n@@ -280,7 +281,7 @@ impl<'a> visit::Visitor<'a> for DefCollector<'a> {\n \n     fn visit_lifetime_def(&mut self, def: &'a LifetimeDef) {\n         self.create_def(def.lifetime.id,\n-                        DefPathData::LifetimeDef(def.lifetime.name.as_str()),\n+                        DefPathData::LifetimeDef(def.lifetime.ident.modern()),\n                         REGULAR_SPACE);\n     }\n "}, {"sha": "c86b140fbc61462d6723c5a61dbb140351c7b631", "filename": "src/librustc/hir/map/definitions.rs", "status": "modified", "additions": 81, "deletions": 32, "changes": 113, "blob_url": "https://github.com/rust-lang/rust/blob/4f9c9ed1a53d176fb0650042f226222f401c21eb/src%2Flibrustc%2Fhir%2Fmap%2Fdefinitions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f9c9ed1a53d176fb0650042f226222f401c21eb/src%2Flibrustc%2Fhir%2Fmap%2Fdefinitions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fdefinitions.rs?ref=4f9c9ed1a53d176fb0650042f226222f401c21eb", "patch": "@@ -23,7 +23,8 @@ use rustc_data_structures::stable_hasher::StableHasher;\n use serialize::{Encodable, Decodable, Encoder, Decoder};\n use std::fmt::Write;\n use std::hash::Hash;\n-use syntax::ast;\n+use syntax::ast::{self, Ident};\n+use syntax::ext::hygiene::{Mark, SyntaxContext};\n use syntax::symbol::{Symbol, InternedString};\n use ty::TyCtxt;\n use util::nodemap::NodeMap;\n@@ -180,6 +181,8 @@ pub struct Definitions {\n     node_to_def_index: NodeMap<DefIndex>,\n     def_index_to_node: [Vec<ast::NodeId>; 2],\n     pub(super) node_to_hir_id: IndexVec<ast::NodeId, hir::HirId>,\n+    macro_def_scopes: FxHashMap<Mark, DefId>,\n+    expansions: FxHashMap<DefIndex, Mark>,\n }\n \n // Unfortunately we have to provide a manual impl of Clone because of the\n@@ -194,6 +197,8 @@ impl Clone for Definitions {\n                 self.def_index_to_node[1].clone(),\n             ],\n             node_to_hir_id: self.node_to_hir_id.clone(),\n+            macro_def_scopes: self.macro_def_scopes.clone(),\n+            expansions: self.expansions.clone(),\n         }\n     }\n }\n@@ -322,7 +327,7 @@ impl DefPath {\n     }\n }\n \n-#[derive(Clone, Debug, PartialEq, Eq, Hash, RustcEncodable, RustcDecodable)]\n+#[derive(Clone, Debug, RustcEncodable, RustcDecodable)]\n pub enum DefPathData {\n     // Root: these should only be used for the root nodes, because\n     // they are treated specially by the `def_path` function.\n@@ -336,31 +341,31 @@ pub enum DefPathData {\n     /// An impl\n     Impl,\n     /// Something in the type NS\n-    TypeNs(InternedString),\n+    TypeNs(Ident),\n     /// Something in the value NS\n-    ValueNs(InternedString),\n+    ValueNs(Ident),\n     /// A module declaration\n-    Module(InternedString),\n+    Module(Ident),\n     /// A macro rule\n-    MacroDef(InternedString),\n+    MacroDef(Ident),\n     /// A closure expression\n     ClosureExpr,\n \n     // Subportions of items\n     /// A type parameter (generic parameter)\n-    TypeParam(InternedString),\n+    TypeParam(Ident),\n     /// A lifetime definition\n-    LifetimeDef(InternedString),\n+    LifetimeDef(Ident),\n     /// A variant of a enum\n-    EnumVariant(InternedString),\n+    EnumVariant(Ident),\n     /// A struct field\n-    Field(InternedString),\n+    Field(Ident),\n     /// Implicit ctor for a tuple-like struct\n     StructCtor,\n     /// Initializer for a const\n     Initializer,\n     /// Pattern binding\n-    Binding(InternedString),\n+    Binding(Ident),\n     /// An `impl Trait` type node.\n     ImplTrait,\n     /// A `typeof` type node.\n@@ -379,6 +384,8 @@ impl Definitions {\n             node_to_def_index: NodeMap(),\n             def_index_to_node: [vec![], vec![]],\n             node_to_hir_id: IndexVec::new(),\n+            macro_def_scopes: FxHashMap(),\n+            expansions: FxHashMap(),\n         }\n     }\n \n@@ -472,7 +479,8 @@ impl Definitions {\n                                   parent: DefIndex,\n                                   node_id: ast::NodeId,\n                                   data: DefPathData,\n-                                  address_space: DefIndexAddressSpace)\n+                                  address_space: DefIndexAddressSpace,\n+                                  expansion: Mark)\n                                   -> DefIndex {\n         debug!(\"create_def_with_parent(parent={:?}, node_id={:?}, data={:?})\",\n                parent, node_id, data);\n@@ -510,6 +518,9 @@ impl Definitions {\n         assert_eq!(index.as_array_index(),\n                    self.def_index_to_node[address_space.index()].len());\n         self.def_index_to_node[address_space.index()].push(node_id);\n+        if expansion.is_modern() {\n+            self.expansions.insert(index, expansion);\n+        }\n \n         debug!(\"create_def_with_parent: def_index_to_node[{:?} <-> {:?}\", index, node_id);\n         self.node_to_def_index.insert(node_id, index);\n@@ -525,21 +536,33 @@ impl Definitions {\n                 \"Trying initialize NodeId -> HirId mapping twice\");\n         self.node_to_hir_id = mapping;\n     }\n+\n+    pub fn expansion(&self, index: DefIndex) -> Mark {\n+        self.expansions.get(&index).cloned().unwrap_or(Mark::root())\n+    }\n+\n+    pub fn macro_def_scope(&self, mark: Mark) -> DefId {\n+        self.macro_def_scopes[&mark]\n+    }\n+\n+    pub fn add_macro_def_scope(&mut self, mark: Mark, scope: DefId) {\n+        self.macro_def_scopes.insert(mark, scope);\n+    }\n }\n \n impl DefPathData {\n-    pub fn get_opt_name(&self) -> Option<ast::Name> {\n+    pub fn get_opt_ident(&self) -> Option<Ident> {\n         use self::DefPathData::*;\n         match *self {\n-            TypeNs(ref name) |\n-            ValueNs(ref name) |\n-            Module(ref name) |\n-            MacroDef(ref name) |\n-            TypeParam(ref name) |\n-            LifetimeDef(ref name) |\n-            EnumVariant(ref name) |\n-            Binding(ref name) |\n-            Field(ref name) => Some(Symbol::intern(name)),\n+            TypeNs(ident) |\n+            ValueNs(ident) |\n+            Module(ident) |\n+            MacroDef(ident) |\n+            TypeParam(ident) |\n+            LifetimeDef(ident) |\n+            EnumVariant(ident) |\n+            Binding(ident) |\n+            Field(ident) => Some(ident),\n \n             Impl |\n             CrateRoot |\n@@ -552,19 +575,23 @@ impl DefPathData {\n         }\n     }\n \n+    pub fn get_opt_name(&self) -> Option<ast::Name> {\n+        self.get_opt_ident().map(|ident| ident.name)\n+    }\n+\n     pub fn as_interned_str(&self) -> InternedString {\n         use self::DefPathData::*;\n         let s = match *self {\n-            TypeNs(ref name) |\n-            ValueNs(ref name) |\n-            Module(ref name) |\n-            MacroDef(ref name) |\n-            TypeParam(ref name) |\n-            LifetimeDef(ref name) |\n-            EnumVariant(ref name) |\n-            Binding(ref name) |\n-            Field(ref name) => {\n-                return name.clone();\n+            TypeNs(ident) |\n+            ValueNs(ident) |\n+            Module(ident) |\n+            MacroDef(ident) |\n+            TypeParam(ident) |\n+            LifetimeDef(ident) |\n+            EnumVariant(ident) |\n+            Binding(ident) |\n+            Field(ident) => {\n+                return ident.name.as_str();\n             }\n \n             // note that this does not show up in user printouts\n@@ -586,3 +613,25 @@ impl DefPathData {\n         self.as_interned_str().to_string()\n     }\n }\n+\n+impl Eq for DefPathData {}\n+impl PartialEq for DefPathData {\n+    fn eq(&self, other: &DefPathData) -> bool {\n+        ::std::mem::discriminant(self) == ::std::mem::discriminant(other) &&\n+        self.get_opt_ident() == other.get_opt_ident()\n+    }\n+}\n+\n+impl ::std::hash::Hash for DefPathData {\n+    fn hash<H: ::std::hash::Hasher>(&self, hasher: &mut H) {\n+        ::std::mem::discriminant(self).hash(hasher);\n+        if let Some(ident) = self.get_opt_ident() {\n+            if ident.ctxt == SyntaxContext::empty() && ident.name == ident.name.interned() {\n+                ident.name.as_str().hash(hasher)\n+            } else {\n+                // FIXME(jseyfried) implement stable hashing for idents with macros 2.0 hygiene info\n+                ident.hash(hasher)\n+            }\n+        }\n+    }\n+}"}, {"sha": "09e9d7c5b2f7d81cd8355e0bfc1254cec19e4721", "filename": "src/librustc/hir/map/mod.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/4f9c9ed1a53d176fb0650042f226222f401c21eb/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f9c9ed1a53d176fb0650042f226222f401c21eb/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs?ref=4f9c9ed1a53d176fb0650042f226222f401c21eb", "patch": "@@ -637,14 +637,15 @@ impl<'hir> Map<'hir> {\n \n     /// Returns the NodeId of `id`'s nearest module parent, or `id` itself if no\n     /// module parent is in this map.\n-    pub fn get_module_parent(&self, id: NodeId) -> NodeId {\n-        match self.walk_parent_nodes(id, |node| match *node {\n+    pub fn get_module_parent(&self, id: NodeId) -> DefId {\n+        let id = match self.walk_parent_nodes(id, |node| match *node {\n             NodeItem(&Item { node: Item_::ItemMod(_), .. }) => true,\n             _ => false,\n         }) {\n             Ok(id) => id,\n             Err(id) => id,\n-        }\n+        };\n+        self.local_def_id(id)\n     }\n \n     /// Returns the nearest enclosing scope. A scope is an item or block."}, {"sha": "500e95a8a778ee46d99b7342eff8c77268fa0464", "filename": "src/librustc/hir/mod.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4f9c9ed1a53d176fb0650042f226222f401c21eb/src%2Flibrustc%2Fhir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f9c9ed1a53d176fb0650042f226222f401c21eb/src%2Flibrustc%2Fhir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmod.rs?ref=4f9c9ed1a53d176fb0650042f226222f401c21eb", "patch": "@@ -162,7 +162,7 @@ impl Lifetime {\n     }\n \n     pub fn is_static(&self) -> bool {\n-        self.name == keywords::StaticLifetime.name()\n+        self.name == \"'static\"\n     }\n }\n \n@@ -532,10 +532,12 @@ impl Crate {\n #[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n pub struct MacroDef {\n     pub name: Name,\n+    pub vis: Visibility,\n     pub attrs: HirVec<Attribute>,\n     pub id: NodeId,\n     pub span: Span,\n     pub body: TokenStream,\n+    pub legacy: bool,\n }\n \n #[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]"}, {"sha": "dbe91e2725deffec2a377df2602646edbb886d79", "filename": "src/librustc/ich/impls_hir.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4f9c9ed1a53d176fb0650042f226222f401c21eb/src%2Flibrustc%2Fich%2Fimpls_hir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f9c9ed1a53d176fb0650042f226222f401c21eb/src%2Flibrustc%2Fich%2Fimpls_hir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fimpls_hir.rs?ref=4f9c9ed1a53d176fb0650042f226222f401c21eb", "patch": "@@ -329,9 +329,11 @@ impl_stable_hash_for!(enum hir::QPath {\n \n impl_stable_hash_for!(struct hir::MacroDef {\n     name,\n+    vis,\n     attrs,\n     id,\n     span,\n+    legacy,\n     body\n });\n \n@@ -1116,7 +1118,7 @@ impl<'a, 'tcx> HashStable<StableHashingContext<'a, 'tcx>> for hir::def_id::DefIn\n }\n \n impl_stable_hash_for!(struct hir::def::Export {\n-    name,\n+    ident,\n     def,\n     span\n });"}, {"sha": "0bfe04dd25dca8b194d389cbc7c5387a2884cf0d", "filename": "src/librustc/ich/impls_syntax.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4f9c9ed1a53d176fb0650042f226222f401c21eb/src%2Flibrustc%2Fich%2Fimpls_syntax.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f9c9ed1a53d176fb0650042f226222f401c21eb/src%2Flibrustc%2Fich%2Fimpls_syntax.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fimpls_syntax.rs?ref=4f9c9ed1a53d176fb0650042f226222f401c21eb", "patch": "@@ -130,7 +130,7 @@ impl_stable_hash_for!(enum ::syntax::ast::FloatTy { F32, F64 });\n impl_stable_hash_for!(enum ::syntax::ast::Unsafety { Unsafe, Normal });\n impl_stable_hash_for!(enum ::syntax::ast::Constness { Const, NotConst });\n impl_stable_hash_for!(enum ::syntax::ast::Defaultness { Default, Final });\n-impl_stable_hash_for!(struct ::syntax::ast::Lifetime { id, span, name });\n+impl_stable_hash_for!(struct ::syntax::ast::Lifetime { id, span, ident });\n impl_stable_hash_for!(enum ::syntax::ast::StrStyle { Cooked, Raw(pounds) });\n impl_stable_hash_for!(enum ::syntax::ast::AttrStyle { Outer, Inner });\n "}, {"sha": "d1d9dd4853d7baa19ee5a43266f8d8321f1ec131", "filename": "src/librustc/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/4f9c9ed1a53d176fb0650042f226222f401c21eb/src%2Flibrustc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f9c9ed1a53d176fb0650042f226222f401c21eb/src%2Flibrustc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flib.rs?ref=4f9c9ed1a53d176fb0650042f226222f401c21eb", "patch": "@@ -28,6 +28,7 @@\n #![feature(conservative_impl_trait)]\n #![feature(const_fn)]\n #![feature(core_intrinsics)]\n+#![feature(discriminant_value)]\n #![feature(i128_type)]\n #![feature(libc)]\n #![feature(never_type)]"}, {"sha": "4c25a455f292d4a9d62033e833c0957b48c19246", "filename": "src/librustc/lint/context.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/4f9c9ed1a53d176fb0650042f226222f401c21eb/src%2Flibrustc%2Flint%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f9c9ed1a53d176fb0650042f226222f401c21eb/src%2Flibrustc%2Flint%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fcontext.rs?ref=4f9c9ed1a53d176fb0650042f226222f401c21eb", "patch": "@@ -50,7 +50,6 @@ use hir;\n use hir::def_id::LOCAL_CRATE;\n use hir::intravisit as hir_visit;\n use syntax::visit as ast_visit;\n-use syntax::tokenstream::ThinTokenStream;\n \n /// Information about the registered lints.\n ///\n@@ -1209,7 +1208,7 @@ impl<'a> ast_visit::Visitor<'a> for EarlyContext<'a> {\n         run_lints!(self, check_attribute, early_passes, attr);\n     }\n \n-    fn visit_mac_def(&mut self, _mac: &'a ThinTokenStream, id: ast::NodeId) {\n+    fn visit_mac_def(&mut self, _mac: &'a ast::MacroDef, id: ast::NodeId) {\n         let lints = self.sess.lints.borrow_mut().take(id);\n         for early_lint in lints {\n             self.early_lint(&early_lint);"}, {"sha": "1a07423bcbc0f88d44224be61db72b5b53a53d92", "filename": "src/librustc/middle/resolve_lifetime.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/4f9c9ed1a53d176fb0650042f226222f401c21eb/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f9c9ed1a53d176fb0650042f226222f401c21eb/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs?ref=4f9c9ed1a53d176fb0650042f226222f401c21eb", "patch": "@@ -26,7 +26,6 @@ use std::mem::replace;\n use syntax::ast;\n use syntax::attr;\n use syntax::ptr::P;\n-use syntax::symbol::keywords;\n use syntax_pos::Span;\n use errors::DiagnosticBuilder;\n use util::nodemap::{NodeMap, NodeSet, FxHashSet, FxHashMap, DefIdMap};\n@@ -746,7 +745,7 @@ fn object_lifetime_defaults_for_item(hir_map: &Map, generics: &hir::Generics)\n         match set {\n             Set1::Empty => Set1::Empty,\n             Set1::One(name) => {\n-                if name == keywords::StaticLifetime.name() {\n+                if name == \"'static\" {\n                     Set1::One(Region::Static)\n                 } else {\n                     generics.lifetimes.iter().enumerate().find(|&(_, def)| {"}, {"sha": "963ee9b7165e5c28acff4414b27755618f2c81ac", "filename": "src/librustc/ty/mod.rs", "status": "modified", "additions": 33, "deletions": 15, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/4f9c9ed1a53d176fb0650042f226222f401c21eb/src%2Flibrustc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f9c9ed1a53d176fb0650042f226222f401c21eb/src%2Flibrustc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmod.rs?ref=4f9c9ed1a53d176fb0650042f226222f401c21eb", "patch": "@@ -45,8 +45,9 @@ use std::rc::Rc;\n use std::slice;\n use std::vec::IntoIter;\n use std::mem;\n-use syntax::ast::{self, DUMMY_NODE_ID, Name, NodeId};\n+use syntax::ast::{self, DUMMY_NODE_ID, Name, Ident, NodeId};\n use syntax::attr;\n+use syntax::ext::hygiene::{Mark, SyntaxContext};\n use syntax::symbol::{Symbol, InternedString};\n use syntax_pos::{DUMMY_SP, Span};\n use rustc_const_math::ConstInt;\n@@ -268,7 +269,7 @@ impl Visibility {\n                 def => Visibility::Restricted(def.def_id()),\n             },\n             hir::Inherited => {\n-                Visibility::Restricted(tcx.hir.local_def_id(tcx.hir.get_module_parent(id)))\n+                Visibility::Restricted(tcx.hir.get_module_parent(id))\n             }\n         }\n     }\n@@ -1823,17 +1824,22 @@ impl<'a, 'gcx, 'tcx> AdtDef {\n \n impl<'a, 'gcx, 'tcx> VariantDef {\n     #[inline]\n-    pub fn find_field_named(&self,\n-                            name: ast::Name)\n-                            -> Option<&FieldDef> {\n-        self.fields.iter().find(|f| f.name == name)\n+    pub fn find_field_named(&self, name: ast::Name) -> Option<&FieldDef> {\n+        self.index_of_field_named(name).map(|index| &self.fields[index])\n     }\n \n-    #[inline]\n-    pub fn index_of_field_named(&self,\n-                                name: ast::Name)\n-                                -> Option<usize> {\n-        self.fields.iter().position(|f| f.name == name)\n+    pub fn index_of_field_named(&self, name: ast::Name) -> Option<usize> {\n+        if let Some(index) = self.fields.iter().position(|f| f.name == name) {\n+            return Some(index);\n+        }\n+        let mut ident = name.to_ident();\n+        while ident.ctxt != SyntaxContext::empty() {\n+            ident.ctxt.remove_mark();\n+            if let Some(field) = self.fields.iter().position(|f| f.name.to_ident() == ident) {\n+                return Some(field);\n+            }\n+        }\n+        None\n     }\n \n     #[inline]\n@@ -2257,10 +2263,6 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n         }\n     }\n \n-    pub fn vis_is_accessible_from(self, vis: Visibility, block: NodeId) -> bool {\n-        vis.is_accessible_from(self.hir.local_def_id(self.hir.get_module_parent(block)), self)\n-    }\n-\n     pub fn item_name(self, id: DefId) -> ast::Name {\n         if let Some(id) = self.hir.as_local_node_id(id) {\n             self.hir.name(id)\n@@ -2372,6 +2374,22 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n             Err(self.sess.cstore.crate_name(impl_did.krate))\n         }\n     }\n+\n+    pub fn adjust(self, name: Name, scope: DefId, block: NodeId) -> (Ident, DefId) {\n+        self.adjust_ident(name.to_ident(), scope, block)\n+    }\n+\n+    pub fn adjust_ident(self, mut ident: Ident, scope: DefId, block: NodeId) -> (Ident, DefId) {\n+        let expansion = match scope.krate {\n+            LOCAL_CRATE => self.hir.definitions().expansion(scope.index),\n+            _ => Mark::root(),\n+        };\n+        let scope = match ident.ctxt.adjust(expansion) {\n+            Some(macro_def) => self.hir.definitions().macro_def_scope(macro_def),\n+            None => self.hir.get_module_parent(block),\n+        };\n+        (ident, scope)\n+    }\n }\n \n impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {"}, {"sha": "b35b0865991659d29b461f44f441bc2991ab9d2d", "filename": "src/librustc_const_eval/check_match.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/4f9c9ed1a53d176fb0650042f226222f401c21eb/src%2Flibrustc_const_eval%2Fcheck_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f9c9ed1a53d176fb0650042f226222f401c21eb/src%2Flibrustc_const_eval%2Fcheck_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_const_eval%2Fcheck_match.rs?ref=4f9c9ed1a53d176fb0650042f226222f401c21eb", "patch": "@@ -154,7 +154,7 @@ impl<'a, 'tcx> MatchVisitor<'a, 'tcx> {\n             }\n         }\n \n-        let module = self.tcx.hir.local_def_id(self.tcx.hir.get_module_parent(scrut.id));\n+        let module = self.tcx.hir.get_module_parent(scrut.id);\n         MatchCheckCtxt::create_and_enter(self.tcx, module, |ref mut cx| {\n             let mut have_errors = false;\n \n@@ -182,7 +182,7 @@ impl<'a, 'tcx> MatchVisitor<'a, 'tcx> {\n             // Then, if the match has no arms, check whether the scrutinee\n             // is uninhabited.\n             let pat_ty = self.tables.node_id_to_type(scrut.id);\n-            let module = self.tcx.hir.local_def_id(self.tcx.hir.get_module_parent(scrut.id));\n+            let module = self.tcx.hir.get_module_parent(scrut.id);\n             if inlined_arms.is_empty() {\n                 let scrutinee_is_uninhabited = if self.tcx.sess.features.borrow().never_type {\n                     pat_ty.is_uninhabited_from(module, self.tcx)\n@@ -231,7 +231,7 @@ impl<'a, 'tcx> MatchVisitor<'a, 'tcx> {\n             \"local binding\"\n         };\n \n-        let module = self.tcx.hir.local_def_id(self.tcx.hir.get_module_parent(pat.id));\n+        let module = self.tcx.hir.get_module_parent(pat.id);\n         MatchCheckCtxt::create_and_enter(self.tcx, module, |ref mut cx| {\n             let mut patcx = PatternContext::new(self.tcx, self.tables);\n             let pattern = patcx.lower_pattern(pat);"}, {"sha": "9d098557367cd48311369dfc59557c7f5a1ee188", "filename": "src/librustc_metadata/cstore_impl.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/4f9c9ed1a53d176fb0650042f226222f401c21eb/src%2Flibrustc_metadata%2Fcstore_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f9c9ed1a53d176fb0650042f226222f401c21eb/src%2Flibrustc_metadata%2Fcstore_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fcstore_impl.rs?ref=4f9c9ed1a53d176fb0650042f226222f401c21eb", "patch": "@@ -386,7 +386,10 @@ impl CrateStore for cstore::CStore {\n             id: ast::DUMMY_NODE_ID,\n             span: local_span,\n             attrs: attrs.iter().cloned().collect(),\n-            node: ast::ItemKind::MacroDef(body.into()),\n+            node: ast::ItemKind::MacroDef(ast::MacroDef {\n+                tokens: body.into(),\n+                legacy: def.legacy,\n+            }),\n             vis: ast::Visibility::Inherited,\n         })\n     }"}, {"sha": "1db5821f31878e9ca1bf954e17ae9e69ff642a8f", "filename": "src/librustc_metadata/decoder.rs", "status": "modified", "additions": 8, "deletions": 6, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/4f9c9ed1a53d176fb0650042f226222f401c21eb/src%2Flibrustc_metadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f9c9ed1a53d176fb0650042f226222f401c21eb/src%2Flibrustc_metadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fdecoder.rs?ref=4f9c9ed1a53d176fb0650042f226222f401c21eb", "patch": "@@ -39,7 +39,7 @@ use std::u32;\n \n use rustc_serialize::{Decodable, Decoder, SpecializedDecoder, opaque};\n use syntax::attr;\n-use syntax::ast;\n+use syntax::ast::{self, Ident};\n use syntax::codemap;\n use syntax::ext::base::MacroKind;\n use syntax_pos::{self, Span, BytePos, Pos, DUMMY_SP, NO_EXPANSION};\n@@ -667,7 +667,8 @@ impl<'a, 'tcx> CrateMetadata {\n                         },\n                         ext.kind()\n                     );\n-                    callback(def::Export { name: name, def: def, span: DUMMY_SP });\n+                    let ident = Ident::with_empty_ctxt(name);\n+                    callback(def::Export { ident: ident, def: def, span: DUMMY_SP });\n                 }\n             }\n             return\n@@ -703,7 +704,7 @@ impl<'a, 'tcx> CrateMetadata {\n                             if let Some(def) = self.get_def(child_index) {\n                                 callback(def::Export {\n                                     def: def,\n-                                    name: self.item_name(child_index),\n+                                    ident: Ident::with_empty_ctxt(self.item_name(child_index)),\n                                     span: self.entry(child_index).span.decode(self),\n                                 });\n                             }\n@@ -720,23 +721,24 @@ impl<'a, 'tcx> CrateMetadata {\n                 let span = child.span.decode(self);\n                 if let (Some(def), Some(name)) =\n                     (self.get_def(child_index), def_key.disambiguated_data.data.get_opt_name()) {\n-                    callback(def::Export { def: def, name: name, span: span });\n+                    let ident = Ident::with_empty_ctxt(name);\n+                    callback(def::Export { def: def, ident: ident, span: span });\n                     // For non-reexport structs and variants add their constructors to children.\n                     // Reexport lists automatically contain constructors when necessary.\n                     match def {\n                         Def::Struct(..) => {\n                             if let Some(ctor_def_id) = self.get_struct_ctor_def_id(child_index) {\n                                 let ctor_kind = self.get_ctor_kind(child_index);\n                                 let ctor_def = Def::StructCtor(ctor_def_id, ctor_kind);\n-                                callback(def::Export { def: ctor_def, name: name, span: span });\n+                                callback(def::Export { def: ctor_def, ident: ident, span: span });\n                             }\n                         }\n                         Def::Variant(def_id) => {\n                             // Braced variants, unlike structs, generate unusable names in\n                             // value namespace, they are reserved for possible future use.\n                             let ctor_kind = self.get_ctor_kind(child_index);\n                             let ctor_def = Def::VariantCtor(def_id, ctor_kind);\n-                            callback(def::Export { def: ctor_def, name: name, span: span });\n+                            callback(def::Export { def: ctor_def, ident: ident, span: span });\n                         }\n                         _ => {}\n                     }"}, {"sha": "07c475949d4357555c41e90dc33776106bc121c1", "filename": "src/librustc_metadata/encoder.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/4f9c9ed1a53d176fb0650042f226222f401c21eb/src%2Flibrustc_metadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f9c9ed1a53d176fb0650042f226222f401c21eb/src%2Flibrustc_metadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fencoder.rs?ref=4f9c9ed1a53d176fb0650042f226222f401c21eb", "patch": "@@ -1104,6 +1104,7 @@ impl<'a, 'b: 'a, 'tcx: 'b> IsolatedEncoder<'a, 'b, 'tcx> {\n         Entry {\n             kind: EntryKind::MacroDef(self.lazy(&MacroDef {\n                 body: pprust::tts_to_string(&macro_def.body.trees().collect::<Vec<_>>()),\n+                legacy: macro_def.legacy,\n             })),\n             visibility: self.lazy(&ty::Visibility::Public),\n             span: self.lazy(&macro_def.span),"}, {"sha": "2ffe7cc02aaacec21feca4538057c9159a306b3b", "filename": "src/librustc_metadata/schema.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/4f9c9ed1a53d176fb0650042f226222f401c21eb/src%2Flibrustc_metadata%2Fschema.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f9c9ed1a53d176fb0650042f226222f401c21eb/src%2Flibrustc_metadata%2Fschema.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fschema.rs?ref=4f9c9ed1a53d176fb0650042f226222f401c21eb", "patch": "@@ -433,9 +433,10 @@ impl_stable_hash_for!(struct ModData { reexports });\n #[derive(RustcEncodable, RustcDecodable)]\n pub struct MacroDef {\n     pub body: String,\n+    pub legacy: bool,\n }\n \n-impl_stable_hash_for!(struct MacroDef { body });\n+impl_stable_hash_for!(struct MacroDef { body, legacy });\n \n #[derive(RustcEncodable, RustcDecodable)]\n pub struct FnData {"}, {"sha": "79d90210d47f78264425c5e59d828ff3b7cd7621", "filename": "src/librustc_passes/ast_validation.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4f9c9ed1a53d176fb0650042f226222f401c21eb/src%2Flibrustc_passes%2Fast_validation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f9c9ed1a53d176fb0650042f226222f401c21eb/src%2Flibrustc_passes%2Fast_validation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Fast_validation.rs?ref=4f9c9ed1a53d176fb0650042f226222f401c21eb", "patch": "@@ -103,11 +103,11 @@ impl<'a> AstValidator<'a> {\n \n impl<'a> Visitor<'a> for AstValidator<'a> {\n     fn visit_lifetime(&mut self, lt: &'a Lifetime) {\n-        if lt.name == \"'_\" {\n+        if lt.ident.name == \"'_\" {\n             self.session.add_lint(lint::builtin::LIFETIME_UNDERSCORE,\n                                   lt.id,\n                                   lt.span,\n-                                  format!(\"invalid lifetime name `{}`\", lt.name));\n+                                  format!(\"invalid lifetime name `{}`\", lt.ident));\n         }\n \n         visit::walk_lifetime(self, lt)"}, {"sha": "153da91db68f8a93de720b475fa9cf8cbdae5963", "filename": "src/librustc_privacy/lib.rs", "status": "modified", "additions": 38, "deletions": 7, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/4f9c9ed1a53d176fb0650042f226222f401c21eb/src%2Flibrustc_privacy%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f9c9ed1a53d176fb0650042f226222f401c21eb/src%2Flibrustc_privacy%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_privacy%2Flib.rs?ref=4f9c9ed1a53d176fb0650042f226222f401c21eb", "patch": "@@ -28,7 +28,7 @@ extern crate syntax_pos;\n \n use rustc::hir::{self, PatKind};\n use rustc::hir::def::Def;\n-use rustc::hir::def_id::{CRATE_DEF_INDEX, LOCAL_CRATE, CrateNum, DefId};\n+use rustc::hir::def_id::{LOCAL_CRATE, CrateNum, DefId};\n use rustc::hir::intravisit::{self, Visitor, NestedVisitorMap};\n use rustc::hir::itemlikevisit::DeepVisitor;\n use rustc::lint;\n@@ -37,7 +37,8 @@ use rustc::ty::{self, TyCtxt, Ty, TypeFoldable};\n use rustc::ty::fold::TypeVisitor;\n use rustc::ty::maps::Providers;\n use rustc::util::nodemap::NodeSet;\n-use syntax::ast;\n+use syntax::ast::{self, CRATE_NODE_ID, Ident};\n+use syntax::symbol::keywords;\n use syntax_pos::Span;\n \n use std::cmp;\n@@ -344,7 +345,35 @@ impl<'a, 'tcx> Visitor<'tcx> for EmbargoVisitor<'a, 'tcx> {\n     }\n \n     fn visit_macro_def(&mut self, md: &'tcx hir::MacroDef) {\n-        self.update(md.id, Some(AccessLevel::Public));\n+        if md.legacy {\n+            self.update(md.id, Some(AccessLevel::Public));\n+            return\n+        }\n+\n+        let module_did = ty::DefIdTree::parent(self.tcx, self.tcx.hir.local_def_id(md.id)).unwrap();\n+        let mut module_id = self.tcx.hir.as_local_node_id(module_did).unwrap();\n+        let level = if md.vis == hir::Public { self.get(module_id) } else { None };\n+        let level = self.update(md.id, level);\n+        if level.is_none() {\n+            return\n+        }\n+\n+        loop {\n+            let module = if module_id == ast::CRATE_NODE_ID {\n+                &self.tcx.hir.krate().module\n+            } else if let hir::ItemMod(ref module) = self.tcx.hir.expect_item(module_id).node {\n+                module\n+            } else {\n+                unreachable!()\n+            };\n+            for id in &module.item_ids {\n+                self.update(id.id, level);\n+            }\n+            if module_id == ast::CRATE_NODE_ID {\n+                break\n+            }\n+            module_id = self.tcx.hir.get_parent_node(module_id);\n+        }\n     }\n \n     fn visit_ty(&mut self, ty: &'tcx hir::Ty) {\n@@ -425,13 +454,15 @@ impl<'b, 'a, 'tcx> TypeVisitor<'tcx> for ReachEverythingInTheInterfaceVisitor<'b\n struct NamePrivacyVisitor<'a, 'tcx: 'a> {\n     tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     tables: &'a ty::TypeckTables<'tcx>,\n-    current_item: DefId,\n+    current_item: ast::NodeId,\n }\n \n impl<'a, 'tcx> NamePrivacyVisitor<'a, 'tcx> {\n     // Checks that a field is accessible.\n     fn check_field(&mut self, span: Span, def: &'tcx ty::AdtDef, field: &'tcx ty::FieldDef) {\n-        if !def.is_enum() && !field.vis.is_accessible_from(self.current_item, self.tcx) {\n+        let ident = Ident { ctxt: span.ctxt.modern(), ..keywords::Invalid.ident() };\n+        let def_id = self.tcx.adjust_ident(ident, def.did, self.current_item).1;\n+        if !def.is_enum() && !field.vis.is_accessible_from(def_id, self.tcx) {\n             struct_span_err!(self.tcx.sess, span, E0451, \"field `{}` of {} `{}` is private\",\n                              field.name, def.variant_descr(), self.tcx.item_path_str(def.did))\n                 .span_label(span, format!(\"field `{}` is private\", field.name))\n@@ -455,7 +486,7 @@ impl<'a, 'tcx> Visitor<'tcx> for NamePrivacyVisitor<'a, 'tcx> {\n     }\n \n     fn visit_item(&mut self, item: &'tcx hir::Item) {\n-        let orig_current_item = replace(&mut self.current_item, self.tcx.hir.local_def_id(item.id));\n+        let orig_current_item = replace(&mut self.current_item, item.id);\n         intravisit::walk_item(self, item);\n         self.current_item = orig_current_item;\n     }\n@@ -1182,7 +1213,7 @@ fn privacy_access_levels<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     let mut visitor = NamePrivacyVisitor {\n         tcx: tcx,\n         tables: &ty::TypeckTables::empty(),\n-        current_item: DefId::local(CRATE_DEF_INDEX),\n+        current_item: CRATE_NODE_ID,\n     };\n     intravisit::walk_crate(&mut visitor, krate);\n "}, {"sha": "597a62f86884b94092cd57cb40c1ced511eba780", "filename": "src/librustc_resolve/build_reduced_graph.rs", "status": "modified", "additions": 61, "deletions": 43, "changes": 104, "blob_url": "https://github.com/rust-lang/rust/blob/4f9c9ed1a53d176fb0650042f226222f401c21eb/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f9c9ed1a53d176fb0650042f226222f401c21eb/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs?ref=4f9c9ed1a53d176fb0650042f226222f401c21eb", "patch": "@@ -23,7 +23,7 @@ use {resolve_error, resolve_struct_error, ResolutionError};\n \n use rustc::middle::cstore::LoadedMacro;\n use rustc::hir::def::*;\n-use rustc::hir::def_id::{CrateNum, BUILTIN_MACROS_CRATE, CRATE_DEF_INDEX, DefId};\n+use rustc::hir::def_id::{BUILTIN_MACROS_CRATE, CRATE_DEF_INDEX, LOCAL_CRATE, DefId};\n use rustc::ty;\n \n use std::cell::Cell;\n@@ -77,7 +77,7 @@ struct LegacyMacroImports {\n impl<'a> Resolver<'a> {\n     /// Defines `name` in namespace `ns` of module `parent` to be `def` if it is not yet defined;\n     /// otherwise, reports an error.\n-    fn define<T>(&mut self, parent: Module<'a>, ident: Ident, ns: Namespace, def: T)\n+    pub fn define<T>(&mut self, parent: Module<'a>, ident: Ident, ns: Namespace, def: T)\n         where T: ToNameBinding<'a>,\n     {\n         let binding = def.to_name_binding(self.arenas);\n@@ -150,7 +150,7 @@ impl<'a> Resolver<'a> {\n                                           view_path.span,\n                                           ResolutionError::SelfImportsOnlyAllowedWithin);\n                         } else if source_name == \"$crate\" && full_path.segments.len() == 1 {\n-                            let crate_root = self.resolve_crate_var(source.ctxt, item.span);\n+                            let crate_root = self.resolve_crate_root(source.ctxt);\n                             let crate_name = match crate_root.kind {\n                                 ModuleKind::Def(_, name) => name,\n                                 ModuleKind::Block(..) => unreachable!(),\n@@ -247,7 +247,8 @@ impl<'a> Resolver<'a> {\n \n                 // n.b. we don't need to look at the path option here, because cstore already did\n                 let crate_id = self.session.cstore.extern_mod_stmt_cnum(item.id).unwrap();\n-                let module = self.get_extern_crate_root(crate_id, item.span);\n+                let module =\n+                    self.get_module(DefId { krate: crate_id, index: CRATE_DEF_INDEX });\n                 self.populate_module_if_necessary(module);\n                 let used = self.process_legacy_macro_imports(item, module, expansion);\n                 let binding =\n@@ -279,7 +280,7 @@ impl<'a> Resolver<'a> {\n                     no_implicit_prelude: parent.no_implicit_prelude || {\n                         attr::contains_name(&item.attrs, \"no_implicit_prelude\")\n                     },\n-                    ..ModuleData::new(Some(parent), module_kind, def_id, item.span)\n+                    ..ModuleData::new(Some(parent), module_kind, def_id, expansion, item.span)\n                 });\n                 self.define(parent, ident, TypeNS, (module, vis, sp, expansion));\n                 self.module_map.insert(def_id, module);\n@@ -317,6 +318,7 @@ impl<'a> Resolver<'a> {\n                 let module = self.new_module(parent,\n                                              module_kind,\n                                              parent.normal_ancestor_id,\n+                                             expansion,\n                                              item.span);\n                 self.define(parent, ident, TypeNS, (module, vis, sp, expansion));\n \n@@ -376,6 +378,7 @@ impl<'a> Resolver<'a> {\n                 let module = self.new_module(parent,\n                                              module_kind,\n                                              parent.normal_ancestor_id,\n+                                             expansion,\n                                              item.span);\n                 self.define(parent, ident, TypeNS, (module, vis, sp, expansion));\n                 self.current_module = module;\n@@ -421,12 +424,13 @@ impl<'a> Resolver<'a> {\n         self.define(parent, item.ident, ValueNS, (def, vis, item.span, expansion));\n     }\n \n-    fn build_reduced_graph_for_block(&mut self, block: &Block) {\n+    fn build_reduced_graph_for_block(&mut self, block: &Block, expansion: Mark) {\n         let parent = self.current_module;\n         if self.block_needs_anonymous_module(block) {\n             let module = self.new_module(parent,\n                                          ModuleKind::Block(block.id),\n                                          parent.normal_ancestor_id,\n+                                         expansion,\n                                          block.span);\n             self.block_map.insert(block.id, module);\n             self.current_module = module; // Descend into the block.\n@@ -435,28 +439,29 @@ impl<'a> Resolver<'a> {\n \n     /// Builds the reduced graph for a single item in an external crate.\n     fn build_reduced_graph_for_external_crate_def(&mut self, parent: Module<'a>, child: Export) {\n-        let ident = Ident::with_empty_ctxt(child.name);\n+        let ident = child.ident;\n         let def = child.def;\n         let def_id = def.def_id();\n         let vis = self.session.cstore.visibility(def_id);\n         let span = child.span;\n-\n+        let expansion = Mark::root(); // FIXME(jseyfried) intercrate hygiene\n         match def {\n             Def::Mod(..) | Def::Enum(..) => {\n                 let module = self.new_module(parent,\n                                              ModuleKind::Def(def, ident.name),\n                                              def_id,\n+                                             expansion,\n                                              span);\n-                self.define(parent, ident, TypeNS, (module, vis, DUMMY_SP, Mark::root()));\n+                self.define(parent, ident, TypeNS, (module, vis, DUMMY_SP, expansion));\n             }\n             Def::Variant(..) | Def::TyAlias(..) => {\n-                self.define(parent, ident, TypeNS, (def, vis, DUMMY_SP, Mark::root()));\n+                self.define(parent, ident, TypeNS, (def, vis, DUMMY_SP, expansion));\n             }\n             Def::Fn(..) | Def::Static(..) | Def::Const(..) | Def::VariantCtor(..) => {\n-                self.define(parent, ident, ValueNS, (def, vis, DUMMY_SP, Mark::root()));\n+                self.define(parent, ident, ValueNS, (def, vis, DUMMY_SP, expansion));\n             }\n             Def::StructCtor(..) => {\n-                self.define(parent, ident, ValueNS, (def, vis, DUMMY_SP, Mark::root()));\n+                self.define(parent, ident, ValueNS, (def, vis, DUMMY_SP, expansion));\n \n                 if let Some(struct_def_id) =\n                         self.session.cstore.def_key(def_id).parent\n@@ -469,47 +474,59 @@ impl<'a> Resolver<'a> {\n                 let module = self.new_module(parent,\n                                              module_kind,\n                                              parent.normal_ancestor_id,\n+                                             expansion,\n                                              span);\n-                self.define(parent, ident, TypeNS, (module, vis, DUMMY_SP, Mark::root()));\n+                self.define(parent, ident, TypeNS, (module, vis, DUMMY_SP, expansion));\n \n                 for child in self.session.cstore.item_children(def_id) {\n                     let ns = if let Def::AssociatedTy(..) = child.def { TypeNS } else { ValueNS };\n-                    let ident = Ident::with_empty_ctxt(child.name);\n-                    self.define(module, ident, ns, (child.def, ty::Visibility::Public,\n-                                                    DUMMY_SP, Mark::root()));\n+                    self.define(module, child.ident, ns,\n+                                (child.def, ty::Visibility::Public, DUMMY_SP, expansion));\n \n-                    let has_self = self.session.cstore.associated_item_cloned(child.def.def_id())\n-                                       .method_has_self_argument;\n-                    self.trait_item_map.insert((def_id, child.name, ns), (child.def, has_self));\n+                    if self.session.cstore.associated_item_cloned(child.def.def_id())\n+                           .method_has_self_argument {\n+                        self.has_self.insert(child.def.def_id());\n+                    }\n                 }\n                 module.populated.set(true);\n             }\n             Def::Struct(..) | Def::Union(..) => {\n-                self.define(parent, ident, TypeNS, (def, vis, DUMMY_SP, Mark::root()));\n+                self.define(parent, ident, TypeNS, (def, vis, DUMMY_SP, expansion));\n \n                 // Record field names for error reporting.\n                 let field_names = self.session.cstore.struct_field_names(def_id);\n                 self.insert_field_names(def_id, field_names);\n             }\n             Def::Macro(..) => {\n-                self.define(parent, ident, MacroNS, (def, vis, DUMMY_SP, Mark::root()));\n+                self.define(parent, ident, MacroNS, (def, vis, DUMMY_SP, expansion));\n             }\n             _ => bug!(\"unexpected definition: {:?}\", def)\n         }\n     }\n \n-    fn get_extern_crate_root(&mut self, cnum: CrateNum, span: Span) -> Module<'a> {\n-        let def_id = DefId { krate: cnum, index: CRATE_DEF_INDEX };\n-        let name = self.session.cstore.crate_name(cnum);\n-        let macros_only = self.session.cstore.dep_kind(cnum).macros_only();\n-        let module_kind = ModuleKind::Def(Def::Mod(def_id), name);\n-        let arenas = self.arenas;\n-        *self.extern_crate_roots.entry((cnum, macros_only)).or_insert_with(|| {\n-            arenas.alloc_module(ModuleData::new(None, module_kind, def_id, span))\n-        })\n+    pub fn get_module(&mut self, def_id: DefId) -> Module<'a> {\n+        if def_id.krate == LOCAL_CRATE {\n+            return self.module_map[&def_id]\n+        }\n+\n+        let macros_only = self.session.cstore.dep_kind(def_id.krate).macros_only();\n+        if let Some(&module) = self.extern_module_map.get(&(def_id, macros_only)) {\n+            return module;\n+        }\n+\n+        let (name, parent) = if def_id.index == CRATE_DEF_INDEX {\n+            (self.session.cstore.crate_name(def_id.krate), None)\n+        } else {\n+            let def_key = self.session.cstore.def_key(def_id);\n+            (def_key.disambiguated_data.data.get_opt_name().unwrap(),\n+             Some(self.get_module(DefId { index: def_key.parent.unwrap(), ..def_id })))\n+        };\n+\n+        let kind = ModuleKind::Def(Def::Mod(def_id), name);\n+        self.arenas.alloc_module(ModuleData::new(parent, kind, def_id, Mark::root(), DUMMY_SP))\n     }\n \n-    pub fn macro_def_scope(&mut self, expansion: Mark, span: Span) -> Module<'a> {\n+    pub fn macro_def_scope(&mut self, expansion: Mark) -> Module<'a> {\n         let def_id = self.macro_defs[&expansion];\n         if let Some(id) = self.definitions.as_local_node_id(def_id) {\n             self.local_macro_def_scopes[&id]\n@@ -518,7 +535,7 @@ impl<'a> Resolver<'a> {\n             self.graph_root\n         } else {\n             let module_def_id = ty::DefIdTree::parent(&*self, def_id).unwrap();\n-            self.get_extern_crate_root(module_def_id.krate, span)\n+            self.get_module(module_def_id)\n         }\n     }\n \n@@ -625,7 +642,7 @@ impl<'a> Resolver<'a> {\n             let ident = Ident::with_empty_ctxt(name);\n             let result = self.resolve_ident_in_module(module, ident, MacroNS, false, false, span);\n             if let Ok(binding) = result {\n-                self.macro_exports.push(Export { name: name, def: binding.def(), span: span });\n+                self.macro_exports.push(Export { ident: ident, def: binding.def(), span: span });\n             } else {\n                 span_err!(self.session, span, E0470, \"reexported macro not found\");\n             }\n@@ -730,7 +747,7 @@ impl<'a, 'b> Visitor<'a> for BuildReducedGraphVisitor<'a, 'b> {\n     fn visit_item(&mut self, item: &'a Item) {\n         let macro_use = match item.node {\n             ItemKind::MacroDef(..) => {\n-                self.resolver.define_macro(item, &mut self.legacy_scope);\n+                self.resolver.define_macro(item, self.expansion, &mut self.legacy_scope);\n                 return\n             }\n             ItemKind::Mac(..) => {\n@@ -765,15 +782,14 @@ impl<'a, 'b> Visitor<'a> for BuildReducedGraphVisitor<'a, 'b> {\n \n     fn visit_block(&mut self, block: &'a Block) {\n         let (parent, legacy_scope) = (self.resolver.current_module, self.legacy_scope);\n-        self.resolver.build_reduced_graph_for_block(block);\n+        self.resolver.build_reduced_graph_for_block(block, self.expansion);\n         visit::walk_block(self, block);\n         self.resolver.current_module = parent;\n         self.legacy_scope = legacy_scope;\n     }\n \n     fn visit_trait_item(&mut self, item: &'a TraitItem) {\n         let parent = self.resolver.current_module;\n-        let def_id = parent.def_id().unwrap();\n \n         if let TraitItemKind::Macro(_) = item.node {\n             self.visit_invoc(item.id);\n@@ -782,16 +798,18 @@ impl<'a, 'b> Visitor<'a> for BuildReducedGraphVisitor<'a, 'b> {\n \n         // Add the item to the trait info.\n         let item_def_id = self.resolver.definitions.local_def_id(item.id);\n-        let (def, ns, has_self) = match item.node {\n-            TraitItemKind::Const(..) => (Def::AssociatedConst(item_def_id), ValueNS, false),\n-            TraitItemKind::Method(ref sig, _) =>\n-                (Def::Method(item_def_id), ValueNS, sig.decl.has_self()),\n-            TraitItemKind::Type(..) => (Def::AssociatedTy(item_def_id), TypeNS, false),\n+        let (def, ns) = match item.node {\n+            TraitItemKind::Const(..) => (Def::AssociatedConst(item_def_id), ValueNS),\n+            TraitItemKind::Method(ref sig, _) => {\n+                if sig.decl.has_self() {\n+                    self.resolver.has_self.insert(item_def_id);\n+                }\n+                (Def::Method(item_def_id), ValueNS)\n+            }\n+            TraitItemKind::Type(..) => (Def::AssociatedTy(item_def_id), TypeNS),\n             TraitItemKind::Macro(_) => bug!(),  // handled above\n         };\n \n-        self.resolver.trait_item_map.insert((def_id, item.ident.name, ns), (def, has_self));\n-\n         let vis = ty::Visibility::Public;\n         self.resolver.define(parent, item.ident, ns, (def, vis, item.span, self.expansion));\n "}, {"sha": "f1be821d526e17151a3ffa1d452c0eea08278940", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 224, "deletions": 110, "changes": 334, "blob_url": "https://github.com/rust-lang/rust/blob/4f9c9ed1a53d176fb0650042f226222f401c21eb/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f9c9ed1a53d176fb0650042f226222f401c21eb/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=4f9c9ed1a53d176fb0650042f226222f401c21eb", "patch": "@@ -43,15 +43,15 @@ use rustc::middle::cstore::CrateLoader;\n use rustc::session::Session;\n use rustc::lint;\n use rustc::hir::def::*;\n-use rustc::hir::def_id::{CrateNum, CRATE_DEF_INDEX, LOCAL_CRATE, DefId};\n+use rustc::hir::def_id::{CRATE_DEF_INDEX, LOCAL_CRATE, DefId};\n use rustc::ty;\n use rustc::hir::{Freevar, FreevarMap, TraitCandidate, TraitMap, GlobMap};\n use rustc::util::nodemap::{NodeMap, NodeSet, FxHashMap, FxHashSet, DefIdMap};\n \n use syntax::ext::hygiene::{Mark, SyntaxContext};\n use syntax::ast::{self, Name, NodeId, Ident, SpannedIdent, FloatTy, IntTy, UintTy};\n use syntax::ext::base::SyntaxExtension;\n-use syntax::ext::base::Determinacy::{Determined, Undetermined};\n+use syntax::ext::base::Determinacy::{self, Determined, Undetermined};\n use syntax::ext::base::MacroKind;\n use syntax::symbol::{Symbol, keywords};\n use syntax::util::lev_distance::find_best_match_for_name;\n@@ -861,6 +861,8 @@ pub struct ModuleData<'a> {\n \n     /// Span of the module itself. Used for error reporting.\n     span: Span,\n+\n+    expansion: Mark,\n }\n \n pub type Module<'a> = &'a ModuleData<'a>;\n@@ -869,6 +871,7 @@ impl<'a> ModuleData<'a> {\n     fn new(parent: Option<Module<'a>>,\n            kind: ModuleKind,\n            normal_ancestor_id: DefId,\n+           expansion: Mark,\n            span: Span) -> Self {\n         ModuleData {\n             parent: parent,\n@@ -884,6 +887,7 @@ impl<'a> ModuleData<'a> {\n             traits: RefCell::new(None),\n             populated: Cell::new(normal_ancestor_id.is_local()),\n             span: span,\n+            expansion: expansion,\n         }\n     }\n \n@@ -1058,6 +1062,13 @@ impl<'a> NameBinding<'a> {\n             _ => true,\n         }\n     }\n+\n+    fn is_macro_def(&self) -> bool {\n+        match self.kind {\n+            NameBindingKind::Def(Def::Macro(..)) => true,\n+            _ => false,\n+        }\n+    }\n }\n \n /// Interns the names of the primitive types.\n@@ -1104,7 +1115,8 @@ pub struct Resolver<'a> {\n \n     prelude: Option<Module<'a>>,\n \n-    trait_item_map: FxHashMap<(DefId, Name, Namespace), (Def, bool /* has self */)>,\n+    // n.b. This is used only for better diagnostics, not name resolution itself.\n+    has_self: FxHashSet<DefId>,\n \n     // Names of fields of an item `DefId` accessible with dot syntax.\n     // Used for hints during error reporting.\n@@ -1127,7 +1139,7 @@ pub struct Resolver<'a> {\n     label_ribs: Vec<Rib<'a>>,\n \n     // The trait that the current context can refer to.\n-    current_trait_ref: Option<(DefId, TraitRef)>,\n+    current_trait_ref: Option<(Module<'a>, TraitRef)>,\n \n     // The current self type if inside an impl (used for better errors).\n     current_self_type: Option<Ty>,\n@@ -1157,7 +1169,7 @@ pub struct Resolver<'a> {\n     // entry block for `f`.\n     block_map: NodeMap<Module<'a>>,\n     module_map: FxHashMap<DefId, Module<'a>>,\n-    extern_crate_roots: FxHashMap<(CrateNum, bool /* MacrosOnly? */), Module<'a>>,\n+    extern_module_map: FxHashMap<(DefId, bool /* MacrosOnly? */), Module<'a>>,\n \n     pub make_glob_map: bool,\n     // Maps imports to the names of items actually imported (this actually maps\n@@ -1177,9 +1189,9 @@ pub struct Resolver<'a> {\n     use_extern_macros: bool, // true if `#![feature(use_extern_macros)]`\n \n     crate_loader: &'a mut CrateLoader,\n-    macro_names: FxHashSet<Name>,\n+    macro_names: FxHashSet<Ident>,\n     global_macros: FxHashMap<Name, &'a NameBinding<'a>>,\n-    lexical_macro_resolutions: Vec<(Name, &'a Cell<LegacyScope<'a>>)>,\n+    lexical_macro_resolutions: Vec<(Ident, &'a Cell<LegacyScope<'a>>)>,\n     macro_map: FxHashMap<DefId, Rc<SyntaxExtension>>,\n     macro_defs: FxHashMap<Mark, DefId>,\n     local_macro_def_scopes: FxHashMap<NodeId, Module<'a>>,\n@@ -1302,13 +1314,13 @@ impl<'a> Resolver<'a> {\n         let root_module_kind = ModuleKind::Def(Def::Mod(root_def_id), keywords::Invalid.name());\n         let graph_root = arenas.alloc_module(ModuleData {\n             no_implicit_prelude: attr::contains_name(&krate.attrs, \"no_implicit_prelude\"),\n-            ..ModuleData::new(None, root_module_kind, root_def_id, krate.span)\n+            ..ModuleData::new(None, root_module_kind, root_def_id, Mark::root(), krate.span)\n         });\n         let mut module_map = FxHashMap();\n         module_map.insert(DefId::local(CRATE_DEF_INDEX), graph_root);\n \n         let mut definitions = Definitions::new();\n-        DefCollector::new(&mut definitions)\n+        DefCollector::new(&mut definitions, Mark::root())\n             .collect_root(crate_name, &session.local_crate_disambiguator().as_str());\n \n         let mut invocations = FxHashMap();\n@@ -1330,7 +1342,7 @@ impl<'a> Resolver<'a> {\n             graph_root: graph_root,\n             prelude: None,\n \n-            trait_item_map: FxHashMap(),\n+            has_self: FxHashSet(),\n             field_names: FxHashMap(),\n \n             determined_imports: Vec::new(),\n@@ -1356,7 +1368,7 @@ impl<'a> Resolver<'a> {\n             trait_map: NodeMap(),\n             module_map: module_map,\n             block_map: NodeMap(),\n-            extern_crate_roots: FxHashMap(),\n+            extern_module_map: FxHashMap(),\n \n             make_glob_map: make_glob_map == MakeGlobMap::Yes,\n             glob_map: NodeMap(),\n@@ -1377,8 +1389,9 @@ impl<'a> Resolver<'a> {\n                 vis: ty::Visibility::Public,\n             }),\n \n-            // `#![feature(proc_macro)]` implies `#[feature(extern_macros)]`\n-            use_extern_macros: features.use_extern_macros || features.proc_macro,\n+            // The `proc_macro` and `decl_macro` features imply `use_extern_macros`\n+            use_extern_macros:\n+                features.use_extern_macros || features.proc_macro || features.decl_macro,\n \n             crate_loader: crate_loader,\n             macro_names: FxHashSet(),\n@@ -1440,9 +1453,11 @@ impl<'a> Resolver<'a> {\n         parent: Module<'a>,\n         kind: ModuleKind,\n         normal_ancestor_id: DefId,\n+        expansion: Mark,\n         span: Span,\n     ) -> Module<'a> {\n-        self.arenas.alloc_module(ModuleData::new(Some(parent), kind, normal_ancestor_id, span))\n+        let module = ModuleData::new(Some(parent), kind, normal_ancestor_id, expansion, span);\n+        self.arenas.alloc_module(module)\n     }\n \n     fn record_use(&mut self, ident: Ident, ns: Namespace, binding: &'a NameBinding<'a>, span: Span)\n@@ -1504,10 +1519,15 @@ impl<'a> Resolver<'a> {\n                                       path_span: Span)\n                                       -> Option<LexicalScopeBinding<'a>> {\n         if ns == TypeNS {\n-            ident = ident.unhygienize();\n+            ident.ctxt = if ident.name == keywords::SelfType.name() {\n+                SyntaxContext::empty() // FIXME(jseyfried) improve `Self` hygiene\n+            } else {\n+                ident.ctxt.modern()\n+            }\n         }\n \n         // Walk backwards up the ribs in scope.\n+        let mut module = self.graph_root;\n         for i in (0 .. self.ribs[ns].len()).rev() {\n             if let Some(def) = self.ribs[ns][i].bindings.get(&ident).cloned() {\n                 // The ident resolves to a type parameter or local variable.\n@@ -1516,45 +1536,120 @@ impl<'a> Resolver<'a> {\n                 ));\n             }\n \n-            if let ModuleRibKind(module) = self.ribs[ns][i].kind {\n-                let item = self.resolve_ident_in_module(module, ident, ns, false,\n-                                                        record_used, path_span);\n-                if let Ok(binding) = item {\n-                    // The ident resolves to an item.\n-                    return Some(LexicalScopeBinding::Item(binding));\n+            module = match self.ribs[ns][i].kind {\n+                ModuleRibKind(module) => module,\n+                MacroDefinition(def) if def == self.macro_defs[&ident.ctxt.outer()] => {\n+                    // If an invocation of this macro created `ident`, give up on `ident`\n+                    // and switch to `ident`'s source from the macro definition.\n+                    ident.ctxt.remove_mark();\n+                    continue\n                 }\n+                _ => continue,\n+            };\n \n-                if let ModuleKind::Block(..) = module.kind { // We can see through blocks\n-                } else if !module.no_implicit_prelude {\n-                    return self.prelude.and_then(|prelude| {\n-                        self.resolve_ident_in_module(prelude, ident, ns, false,\n-                                                     false, path_span).ok()\n-                    }).map(LexicalScopeBinding::Item)\n-                } else {\n-                    return None;\n-                }\n+            let item = self.resolve_ident_in_module_unadjusted(\n+                module, ident, ns, false, record_used, path_span,\n+            );\n+            if let Ok(binding) = item {\n+                // The ident resolves to an item.\n+                return Some(LexicalScopeBinding::Item(binding));\n             }\n \n-            if let MacroDefinition(def) = self.ribs[ns][i].kind {\n-                // If an invocation of this macro created `ident`, give up on `ident`\n-                // and switch to `ident`'s source from the macro definition.\n-                let ctxt_data = ident.ctxt.data();\n-                if def == self.macro_defs[&ctxt_data.outer_mark] {\n-                    ident.ctxt = ctxt_data.prev_ctxt;\n-                }\n+            match module.kind {\n+                ModuleKind::Block(..) => {}, // We can see through blocks\n+                _ => break,\n             }\n         }\n \n+        ident.ctxt = ident.ctxt.modern();\n+        loop {\n+            module = unwrap_or!(self.hygienic_lexical_parent(module, &mut ident.ctxt), break);\n+            let orig_current_module = self.current_module;\n+            self.current_module = module; // Lexical resolutions can never be a privacy error.\n+            let result = self.resolve_ident_in_module_unadjusted(\n+                module, ident, ns, false, record_used, path_span,\n+            );\n+            self.current_module = orig_current_module;\n+\n+            match result {\n+                Ok(binding) => return Some(LexicalScopeBinding::Item(binding)),\n+                Err(Undetermined) => return None,\n+                Err(Determined) => {}\n+            }\n+        }\n+\n+        match self.prelude {\n+            Some(prelude) if !module.no_implicit_prelude => {\n+                self.resolve_ident_in_module_unadjusted(prelude, ident, ns, false, false, path_span)\n+                    .ok().map(LexicalScopeBinding::Item)\n+            }\n+            _ => None,\n+        }\n+    }\n+\n+    fn hygienic_lexical_parent(&mut self, mut module: Module<'a>, ctxt: &mut SyntaxContext)\n+                               -> Option<Module<'a>> {\n+        if !module.expansion.is_descendant_of(ctxt.outer()) {\n+            return Some(self.macro_def_scope(ctxt.remove_mark()));\n+        }\n+\n+        if let ModuleKind::Block(..) = module.kind {\n+            return Some(module.parent.unwrap());\n+        }\n+\n+        let mut module_expansion = module.expansion.modern(); // for backward compatability\n+        while let Some(parent) = module.parent {\n+            let parent_expansion = parent.expansion.modern();\n+            if module_expansion.is_descendant_of(parent_expansion) &&\n+               parent_expansion != module_expansion {\n+                return if parent_expansion.is_descendant_of(ctxt.outer()) {\n+                    Some(parent)\n+                } else {\n+                    None\n+                };\n+            }\n+            module = parent;\n+            module_expansion = parent_expansion;\n+        }\n+\n         None\n     }\n \n-    fn resolve_crate_var(&mut self, crate_var_ctxt: SyntaxContext, span: Span) -> Module<'a> {\n-        let mut ctxt_data = crate_var_ctxt.data();\n-        while ctxt_data.prev_ctxt != SyntaxContext::empty() {\n-            ctxt_data = ctxt_data.prev_ctxt.data();\n+    fn resolve_ident_in_module(&mut self,\n+                               module: Module<'a>,\n+                               mut ident: Ident,\n+                               ns: Namespace,\n+                               ignore_unresolved_invocations: bool,\n+                               record_used: bool,\n+                               span: Span)\n+                               -> Result<&'a NameBinding<'a>, Determinacy> {\n+        ident.ctxt = ident.ctxt.modern();\n+        let orig_current_module = self.current_module;\n+        if let Some(def) = ident.ctxt.adjust(module.expansion) {\n+            self.current_module = self.macro_def_scope(def);\n+        }\n+        let result = self.resolve_ident_in_module_unadjusted(\n+            module, ident, ns, ignore_unresolved_invocations, record_used, span,\n+        );\n+        self.current_module = orig_current_module;\n+        result\n+    }\n+\n+    fn resolve_crate_root(&mut self, mut ctxt: SyntaxContext) -> Module<'a> {\n+        let module = match ctxt.adjust(Mark::root()) {\n+            Some(def) => self.macro_def_scope(def),\n+            None => return self.graph_root,\n+        };\n+        self.get_module(DefId { index: CRATE_DEF_INDEX, ..module.normal_ancestor_id })\n+    }\n+\n+    fn resolve_self(&mut self, ctxt: &mut SyntaxContext, module: Module<'a>) -> Module<'a> {\n+        let mut module = self.get_module(module.normal_ancestor_id);\n+        while module.span.ctxt.modern() != *ctxt {\n+            let parent = module.parent.unwrap_or_else(|| self.macro_def_scope(ctxt.remove_mark()));\n+            module = self.get_module(parent.normal_ancestor_id);\n         }\n-        let module = self.macro_def_scope(ctxt_data.outer_mark, span);\n-        if module.is_local() { self.graph_root } else { module }\n+        module\n     }\n \n     // AST resolution\n@@ -1602,15 +1697,12 @@ impl<'a> Resolver<'a> {\n     fn search_label(&self, mut ident: Ident) -> Option<Def> {\n         for rib in self.label_ribs.iter().rev() {\n             match rib.kind {\n-                NormalRibKind => {\n-                    // Continue\n-                }\n+                NormalRibKind => {}\n+                // If an invocation of this macro created `ident`, give up on `ident`\n+                // and switch to `ident`'s source from the macro definition.\n                 MacroDefinition(def) => {\n-                    // If an invocation of this macro created `ident`, give up on `ident`\n-                    // and switch to `ident`'s source from the macro definition.\n-                    let ctxt_data = ident.ctxt.data();\n-                    if def == self.macro_defs[&ctxt_data.outer_mark] {\n-                        ident.ctxt = ctxt_data.prev_ctxt;\n+                    if def == self.macro_defs[&ident.ctxt.outer()] {\n+                        ident.ctxt.remove_mark();\n                     }\n                 }\n                 _ => {\n@@ -1742,22 +1834,21 @@ impl<'a> Resolver<'a> {\n                 let mut function_type_rib = Rib::new(rib_kind);\n                 let mut seen_bindings = FxHashMap();\n                 for type_parameter in &generics.ty_params {\n-                    let name = type_parameter.ident.name;\n+                    let ident = type_parameter.ident.modern();\n                     debug!(\"with_type_parameter_rib: {}\", type_parameter.id);\n \n-                    if seen_bindings.contains_key(&name) {\n-                        let span = seen_bindings.get(&name).unwrap();\n-                        resolve_error(self,\n-                                      type_parameter.span,\n-                                      ResolutionError::NameAlreadyUsedInTypeParameterList(name,\n-                                                                                          span));\n+                    if seen_bindings.contains_key(&ident) {\n+                        let span = seen_bindings.get(&ident).unwrap();\n+                        let err =\n+                            ResolutionError::NameAlreadyUsedInTypeParameterList(ident.name, span);\n+                        resolve_error(self, type_parameter.span, err);\n                     }\n-                    seen_bindings.entry(name).or_insert(type_parameter.span);\n+                    seen_bindings.entry(ident).or_insert(type_parameter.span);\n \n                     // plain insert (no renaming)\n                     let def_id = self.definitions.local_def_id(type_parameter.id);\n                     let def = Def::TyParam(def_id);\n-                    function_type_rib.bindings.insert(Ident::with_empty_ctxt(name), def);\n+                    function_type_rib.bindings.insert(ident, def);\n                     self.record_def(type_parameter.id, PathResolution::new(def));\n                 }\n                 self.ribs[TypeNS].push(function_type_rib);\n@@ -1817,11 +1908,20 @@ impl<'a> Resolver<'a> {\n         let mut new_val = None;\n         let mut new_id = None;\n         if let Some(trait_ref) = opt_trait_ref {\n-            let def = self.smart_resolve_path(trait_ref.ref_id, None,\n-                                              &trait_ref.path, PathSource::Trait).base_def();\n+            let path: Vec<_> = trait_ref.path.segments.iter().map(|seg| seg.identifier).collect();\n+            let def = self.smart_resolve_path_fragment(trait_ref.ref_id,\n+                                                       None,\n+                                                       &path,\n+                                                       trait_ref.path.span,\n+                                                       trait_ref.path.segments.last().unwrap().span,\n+                                                       PathSource::Trait)\n+                .base_def();\n             if def != Def::Err {\n-                new_val = Some((def.def_id(), trait_ref.clone()));\n                 new_id = Some(def.def_id());\n+                let span = trait_ref.path.span;\n+                if let PathResult::Module(module) = self.resolve_path(&path, None, false, span) {\n+                    new_val = Some((module, trait_ref.clone()));\n+                }\n             }\n         }\n         let original_trait_ref = replace(&mut self.current_trait_ref, new_val);\n@@ -1872,7 +1972,7 @@ impl<'a> Resolver<'a> {\n                                     ImplItemKind::Const(..) => {\n                                         // If this is a trait impl, ensure the const\n                                         // exists in trait\n-                                        this.check_trait_item(impl_item.ident.name,\n+                                        this.check_trait_item(impl_item.ident,\n                                                             ValueNS,\n                                                             impl_item.span,\n                                             |n, s| ResolutionError::ConstNotMemberOfTrait(n, s));\n@@ -1881,7 +1981,7 @@ impl<'a> Resolver<'a> {\n                                     ImplItemKind::Method(ref sig, _) => {\n                                         // If this is a trait impl, ensure the method\n                                         // exists in trait\n-                                        this.check_trait_item(impl_item.ident.name,\n+                                        this.check_trait_item(impl_item.ident,\n                                                             ValueNS,\n                                                             impl_item.span,\n                                             |n, s| ResolutionError::MethodNotMemberOfTrait(n, s));\n@@ -1898,7 +1998,7 @@ impl<'a> Resolver<'a> {\n                                     ImplItemKind::Type(ref ty) => {\n                                         // If this is a trait impl, ensure the type\n                                         // exists in trait\n-                                        this.check_trait_item(impl_item.ident.name,\n+                                        this.check_trait_item(impl_item.ident,\n                                                             TypeNS,\n                                                             impl_item.span,\n                                             |n, s| ResolutionError::TypeNotMemberOfTrait(n, s));\n@@ -1916,15 +2016,15 @@ impl<'a> Resolver<'a> {\n         });\n     }\n \n-    fn check_trait_item<F>(&self, name: Name, ns: Namespace, span: Span, err: F)\n+    fn check_trait_item<F>(&mut self, ident: Ident, ns: Namespace, span: Span, err: F)\n         where F: FnOnce(Name, &str) -> ResolutionError\n     {\n         // If there is a TraitRef in scope for an impl, then the method must be in the\n         // trait.\n-        if let Some((did, ref trait_ref)) = self.current_trait_ref {\n-            if !self.trait_item_map.contains_key(&(did, name, ns)) {\n-                let path_str = path_names_to_string(&trait_ref.path);\n-                resolve_error(self, span, err(name, &path_str));\n+        if let Some((module, _)) = self.current_trait_ref {\n+            if self.resolve_ident_in_module(module, ident, ns, false, false, span).is_err() {\n+                let path = &self.current_trait_ref.as_ref().unwrap().1.path;\n+                resolve_error(self, span, err(ident.name, &path_names_to_string(path)));\n             }\n         }\n     }\n@@ -2294,15 +2394,16 @@ impl<'a> Resolver<'a> {\n             }\n \n             // Try to lookup the name in more relaxed fashion for better error reporting.\n-            let name = path.last().unwrap().name;\n-            let candidates = this.lookup_import_candidates(name, ns, is_expected);\n+            let ident = *path.last().unwrap();\n+            let candidates = this.lookup_import_candidates(ident.name, ns, is_expected);\n             if !candidates.is_empty() {\n                 let mut module_span = this.current_module.span;\n                 module_span.hi = module_span.lo;\n                 // Report import candidates as help and proceed searching for labels.\n                 show_candidates(&mut err, module_span, &candidates, def.is_some());\n             } else if is_expected(Def::Enum(DefId::local(CRATE_DEF_INDEX))) {\n-                let enum_candidates = this.lookup_import_candidates(name, ns, is_enum_variant);\n+                let enum_candidates =\n+                    this.lookup_import_candidates(ident.name, ns, is_enum_variant);\n                 let mut enum_candidates = enum_candidates.iter()\n                     .map(|suggestion| import_candidate_to_paths(&suggestion)).collect::<Vec<_>>();\n                 enum_candidates.sort();\n@@ -2318,7 +2419,7 @@ impl<'a> Resolver<'a> {\n                 }\n             }\n             if path.len() == 1 && this.self_type_is_available(span) {\n-                if let Some(candidate) = this.lookup_assoc_candidate(name, ns, is_expected) {\n+                if let Some(candidate) = this.lookup_assoc_candidate(ident, ns, is_expected) {\n                     let self_is_available = this.self_value_is_available(path[0].ctxt, span);\n                     match candidate {\n                         AssocSuggestion::Field => {\n@@ -2432,7 +2533,7 @@ impl<'a> Resolver<'a> {\n                 // or `<T>::A::B`. If `B` should be resolved in value namespace then\n                 // it needs to be added to the trait map.\n                 if ns == ValueNS {\n-                    let item_name = path.last().unwrap().name;\n+                    let item_name = *path.last().unwrap();\n                     let traits = self.get_traits_containing_item(item_name, ns);\n                     self.trait_map.insert(id, traits);\n                 }\n@@ -2486,7 +2587,7 @@ impl<'a> Resolver<'a> {\n         }\n         let is_global = self.global_macros.get(&path[0].name).cloned()\n             .map(|binding| binding.get_macro(self).kind() == MacroKind::Bang).unwrap_or(false);\n-        if primary_ns != MacroNS && (is_global || self.macro_names.contains(&path[0].name)) {\n+        if primary_ns != MacroNS && (is_global || self.macro_names.contains(&path[0].modern())) {\n             // Return some dummy definition, it's enough for error reporting.\n             return Some(\n                 PathResolution::new(Def::Macro(DefId::local(CRATE_DEF_INDEX), MacroKind::Bang))\n@@ -2595,13 +2696,17 @@ impl<'a> Resolver<'a> {\n             let ns = if is_last { opt_ns.unwrap_or(TypeNS) } else { TypeNS };\n \n             if i == 0 && ns == TypeNS && ident.name == keywords::SelfValue.name() {\n-                module = Some(self.module_map[&self.current_module.normal_ancestor_id]);\n+                let mut ctxt = ident.ctxt.modern();\n+                module = Some(self.resolve_self(&mut ctxt, self.current_module));\n                 continue\n             } else if allow_super && ns == TypeNS && ident.name == keywords::Super.name() {\n-                let current_module = if i == 0 { self.current_module } else { module.unwrap() };\n-                let self_module = self.module_map[&current_module.normal_ancestor_id];\n+                let mut ctxt = ident.ctxt.modern();\n+                let self_module = match i {\n+                    0 => self.resolve_self(&mut ctxt, self.current_module),\n+                    _ => module.unwrap(),\n+                };\n                 if let Some(parent) = self_module.parent {\n-                    module = Some(self.module_map[&parent.normal_ancestor_id]);\n+                    module = Some(self.resolve_self(&mut ctxt, parent));\n                     continue\n                 } else {\n                     let msg = \"There are too many initial `super`s.\".to_string();\n@@ -2611,10 +2716,10 @@ impl<'a> Resolver<'a> {\n             allow_super = false;\n \n             if i == 0 && ns == TypeNS && ident.name == keywords::CrateRoot.name() {\n-                module = Some(self.graph_root);\n+                module = Some(self.resolve_crate_root(ident.ctxt.modern()));\n                 continue\n             } else if i == 0 && ns == TypeNS && ident.name == \"$crate\" {\n-                module = Some(self.resolve_crate_var(ident.ctxt, path_span));\n+                module = Some(self.resolve_crate_root(ident.ctxt));\n                 continue\n             }\n \n@@ -2811,7 +2916,7 @@ impl<'a> Resolver<'a> {\n     }\n \n     fn lookup_assoc_candidate<FilterFn>(&mut self,\n-                                        name: Name,\n+                                        ident: Ident,\n                                         ns: Namespace,\n                                         filter_fn: FilterFn)\n                                         -> Option<AssocSuggestion>\n@@ -2837,7 +2942,7 @@ impl<'a> Resolver<'a> {\n                         Def::Struct(did) | Def::Union(did)\n                                 if resolution.unresolved_segments() == 0 => {\n                             if let Some(field_names) = self.field_names.get(&did) {\n-                                if field_names.iter().any(|&field_name| name == field_name) {\n+                                if field_names.iter().any(|&field_name| ident.name == field_name) {\n                                     return Some(AssocSuggestion::Field);\n                                 }\n                             }\n@@ -2849,10 +2954,12 @@ impl<'a> Resolver<'a> {\n         }\n \n         // Look for associated items in the current trait.\n-        if let Some((trait_did, _)) = self.current_trait_ref {\n-            if let Some(&(def, has_self)) = self.trait_item_map.get(&(trait_did, name, ns)) {\n+        if let Some((module, _)) = self.current_trait_ref {\n+            if let Ok(binding) =\n+                    self.resolve_ident_in_module(module, ident, ns, false, false, module.span) {\n+                let def = binding.def();\n                 if filter_fn(def) {\n-                    return Some(if has_self {\n+                    return Some(if self.has_self.contains(&def.def_id()) {\n                         AssocSuggestion::MethodWithSelf\n                     } else {\n                         AssocSuggestion::AssocItem\n@@ -3073,13 +3180,13 @@ impl<'a> Resolver<'a> {\n                 // field, we need to add any trait methods we find that match\n                 // the field name so that we can do some nice error reporting\n                 // later on in typeck.\n-                let traits = self.get_traits_containing_item(name.node.name, ValueNS);\n+                let traits = self.get_traits_containing_item(name.node, ValueNS);\n                 self.trait_map.insert(expr.id, traits);\n             }\n             ExprKind::MethodCall(name, ..) => {\n                 debug!(\"(recording candidate traits for expr) recording traits for {}\",\n                        expr.id);\n-                let traits = self.get_traits_containing_item(name.node.name, ValueNS);\n+                let traits = self.get_traits_containing_item(name.node, ValueNS);\n                 self.trait_map.insert(expr.id, traits);\n             }\n             _ => {\n@@ -3088,39 +3195,40 @@ impl<'a> Resolver<'a> {\n         }\n     }\n \n-    fn get_traits_containing_item(&mut self, name: Name, ns: Namespace) -> Vec<TraitCandidate> {\n-        debug!(\"(getting traits containing item) looking for '{}'\", name);\n+    fn get_traits_containing_item(&mut self, mut ident: Ident, ns: Namespace)\n+                                  -> Vec<TraitCandidate> {\n+        debug!(\"(getting traits containing item) looking for '{}'\", ident.name);\n \n         let mut found_traits = Vec::new();\n         // Look for the current trait.\n-        if let Some((trait_def_id, _)) = self.current_trait_ref {\n-            if self.trait_item_map.contains_key(&(trait_def_id, name, ns)) {\n-                found_traits.push(TraitCandidate { def_id: trait_def_id, import_id: None });\n+        if let Some((module, _)) = self.current_trait_ref {\n+            if self.resolve_ident_in_module(module, ident, ns, false, false, module.span).is_ok() {\n+                let def_id = module.def_id().unwrap();\n+                found_traits.push(TraitCandidate { def_id: def_id, import_id: None });\n             }\n         }\n \n+        ident.ctxt = ident.ctxt.modern();\n         let mut search_module = self.current_module;\n         loop {\n-            self.get_traits_in_module_containing_item(name, ns, search_module, &mut found_traits);\n-            match search_module.kind {\n-                ModuleKind::Block(..) => search_module = search_module.parent.unwrap(),\n-                _ => break,\n-            }\n+            self.get_traits_in_module_containing_item(ident, ns, search_module, &mut found_traits);\n+            search_module =\n+                unwrap_or!(self.hygienic_lexical_parent(search_module, &mut ident.ctxt), break);\n         }\n \n         if let Some(prelude) = self.prelude {\n             if !search_module.no_implicit_prelude {\n-                self.get_traits_in_module_containing_item(name, ns, prelude, &mut found_traits);\n+                self.get_traits_in_module_containing_item(ident, ns, prelude, &mut found_traits);\n             }\n         }\n \n         found_traits\n     }\n \n     fn get_traits_in_module_containing_item(&mut self,\n-                                            name: Name,\n+                                            ident: Ident,\n                                             ns: Namespace,\n-                                            module: Module,\n+                                            module: Module<'a>,\n                                             found_traits: &mut Vec<TraitCandidate>) {\n         let mut traits = module.traits.borrow_mut();\n         if traits.is_none() {\n@@ -3135,8 +3243,13 @@ impl<'a> Resolver<'a> {\n         }\n \n         for &(trait_name, binding) in traits.as_ref().unwrap().iter() {\n-            let trait_def_id = binding.def().def_id();\n-            if self.trait_item_map.contains_key(&(trait_def_id, name, ns)) {\n+            let module = binding.module().unwrap();\n+            let mut ident = ident;\n+            if ident.ctxt.glob_adjust(module.expansion, binding.span.ctxt.modern()).is_none() {\n+                continue\n+            }\n+            if self.resolve_ident_in_module_unadjusted(module, ident, ns, false, false, module.span)\n+                   .is_ok() {\n                 let import_id = match binding.kind {\n                     NameBindingKind::Import { directive, .. } => {\n                         self.maybe_unused_trait_imports.insert(directive.id);\n@@ -3145,6 +3258,7 @@ impl<'a> Resolver<'a> {\n                     }\n                     _ => None,\n                 };\n+                let trait_def_id = module.def_id().unwrap();\n                 found_traits.push(TraitCandidate { def_id: trait_def_id, import_id: import_id });\n             }\n         }\n@@ -3326,15 +3440,15 @@ impl<'a> Resolver<'a> {\n     }\n \n     fn report_shadowing_errors(&mut self) {\n-        for (name, scope) in replace(&mut self.lexical_macro_resolutions, Vec::new()) {\n-            self.resolve_legacy_scope(scope, name, true);\n+        for (ident, scope) in replace(&mut self.lexical_macro_resolutions, Vec::new()) {\n+            self.resolve_legacy_scope(scope, ident, true);\n         }\n \n         let mut reported_errors = FxHashSet();\n         for binding in replace(&mut self.disallowed_shadowing, Vec::new()) {\n-            if self.resolve_legacy_scope(&binding.parent, binding.name, false).is_some() &&\n-               reported_errors.insert((binding.name, binding.span)) {\n-                let msg = format!(\"`{}` is already in scope\", binding.name);\n+            if self.resolve_legacy_scope(&binding.parent, binding.ident, false).is_some() &&\n+               reported_errors.insert((binding.ident, binding.span)) {\n+                let msg = format!(\"`{}` is already in scope\", binding.ident);\n                 self.session.struct_span_err(binding.span, &msg)\n                     .note(\"macro-expanded `macro_rules!`s may not shadow \\\n                            existing macros (see RFC 1560)\")"}, {"sha": "9a37df762327979cca096ffeb6a45b50a9753f08", "filename": "src/librustc_resolve/macros.rs", "status": "modified", "additions": 59, "deletions": 32, "changes": 91, "blob_url": "https://github.com/rust-lang/rust/blob/4f9c9ed1a53d176fb0650042f226222f401c21eb/src%2Flibrustc_resolve%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f9c9ed1a53d176fb0650042f226222f401c21eb/src%2Flibrustc_resolve%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fmacros.rs?ref=4f9c9ed1a53d176fb0650042f226222f401c21eb", "patch": "@@ -76,7 +76,7 @@ pub enum LegacyScope<'a> {\n \n pub struct LegacyBinding<'a> {\n     pub parent: Cell<LegacyScope<'a>>,\n-    pub name: ast::Name,\n+    pub ident: Ident,\n     def_id: DefId,\n     pub span: Span,\n }\n@@ -110,7 +110,7 @@ impl<'a> base::Resolver for Resolver<'a> {\n     }\n \n     fn get_module_scope(&mut self, id: ast::NodeId) -> Mark {\n-        let mark = Mark::fresh();\n+        let mark = Mark::fresh(Mark::root());\n         let module = self.module_map[&self.definitions.local_def_id(id)];\n         self.invocations.insert(mark, self.arenas.alloc_invocation_data(InvocationData {\n             module: Cell::new(module),\n@@ -130,7 +130,7 @@ impl<'a> base::Resolver for Resolver<'a> {\n                 let ident = path.segments[0].identifier;\n                 if ident.name == \"$crate\" {\n                     path.segments[0].identifier.name = keywords::CrateRoot.name();\n-                    let module = self.0.resolve_crate_var(ident.ctxt, self.1);\n+                    let module = self.0.resolve_crate_root(ident.ctxt);\n                     if !module.is_local() {\n                         let span = path.segments[0].span;\n                         path.segments.insert(1, match module.kind {\n@@ -158,7 +158,7 @@ impl<'a> base::Resolver for Resolver<'a> {\n \n     fn visit_expansion(&mut self, mark: Mark, expansion: &Expansion, derives: &[Mark]) {\n         let invocation = self.invocations[&mark];\n-        self.collect_def_ids(invocation, expansion);\n+        self.collect_def_ids(mark, invocation, expansion);\n \n         self.current_module = invocation.module.get();\n         self.current_module.unresolved_invocations.borrow_mut().remove(&mark);\n@@ -290,9 +290,18 @@ impl<'a> base::Resolver for Resolver<'a> {\n                 Err(determinacy) => return Err(determinacy),\n             },\n         };\n+\n         self.macro_defs.insert(invoc.expansion_data.mark, def.def_id());\n+        let normal_module_def_id =\n+            self.macro_def_scope(invoc.expansion_data.mark).normal_ancestor_id;\n+        self.definitions.add_macro_def_scope(invoc.expansion_data.mark, normal_module_def_id);\n+\n         self.unused_macros.remove(&def.def_id());\n-        Ok(Some(self.get_macro(def)))\n+        let ext = self.get_macro(def);\n+        if ext.is_modern() {\n+            invoc.expansion_data.mark.set_modern();\n+        }\n+        Ok(Some(ext))\n     }\n \n     fn resolve_macro(&mut self, scope: Mark, path: &ast::Path, kind: MacroKind, force: bool)\n@@ -416,8 +425,7 @@ impl<'a> Resolver<'a> {\n             return def;\n         }\n \n-        let name = path[0].name;\n-        let legacy_resolution = self.resolve_legacy_scope(&invocation.legacy_scope, name, false);\n+        let legacy_resolution = self.resolve_legacy_scope(&invocation.legacy_scope, path[0], false);\n         let result = if let Some(MacroBinding::Legacy(binding)) = legacy_resolution {\n             Ok(Def::Macro(binding.def_id, MacroKind::Bang))\n         } else {\n@@ -439,26 +447,31 @@ impl<'a> Resolver<'a> {\n \n     // Resolve the initial segment of a non-global macro path (e.g. `foo` in `foo::bar!();`)\n     pub fn resolve_lexical_macro_path_segment(&mut self,\n-                                              ident: Ident,\n+                                              mut ident: Ident,\n                                               ns: Namespace,\n                                               record_used: bool,\n                                               path_span: Span)\n                                               -> Result<MacroBinding<'a>, Determinacy> {\n+        ident = ident.modern();\n         let mut module = Some(self.current_module);\n         let mut potential_illegal_shadower = Err(Determinacy::Determined);\n         let determinacy =\n             if record_used { Determinacy::Determined } else { Determinacy::Undetermined };\n         loop {\n+            let orig_current_module = self.current_module;\n             let result = if let Some(module) = module {\n+                self.current_module = module; // Lexical resolutions can never be a privacy error.\n                 // Since expanded macros may not shadow the lexical scope and\n                 // globs may not shadow global macros (both enforced below),\n                 // we resolve with restricted shadowing (indicated by the penultimate argument).\n-                self.resolve_ident_in_module(module, ident, ns, true, record_used, path_span)\n-                    .map(MacroBinding::Modern)\n+                self.resolve_ident_in_module_unadjusted(\n+                    module, ident, ns, true, record_used, path_span,\n+                ).map(MacroBinding::Modern)\n             } else {\n                 self.global_macros.get(&ident.name).cloned().ok_or(determinacy)\n                     .map(MacroBinding::Global)\n             };\n+            self.current_module = orig_current_module;\n \n             match result.map(MacroBinding::binding) {\n                 Ok(binding) => {\n@@ -491,20 +504,18 @@ impl<'a> Resolver<'a> {\n             }\n \n             module = match module {\n-                Some(module) => match module.kind {\n-                    ModuleKind::Block(..) => module.parent,\n-                    ModuleKind::Def(..) => None,\n-                },\n+                Some(module) => self.hygienic_lexical_parent(module, &mut ident.ctxt),\n                 None => return potential_illegal_shadower,\n             }\n         }\n     }\n \n     pub fn resolve_legacy_scope(&mut self,\n                                 mut scope: &'a Cell<LegacyScope<'a>>,\n-                                name: Name,\n+                                ident: Ident,\n                                 record_used: bool)\n                                 -> Option<MacroBinding<'a>> {\n+        let ident = ident.modern();\n         let mut possible_time_travel = None;\n         let mut relative_depth: u32 = 0;\n         let mut binding = None;\n@@ -531,7 +542,7 @@ impl<'a> Resolver<'a> {\n                     scope = &invocation.legacy_scope;\n                 }\n                 LegacyScope::Binding(potential_binding) => {\n-                    if potential_binding.name == name {\n+                    if potential_binding.ident == ident {\n                         if (!self.use_extern_macros || record_used) && relative_depth > 0 {\n                             self.disallowed_shadowing.push(potential_binding);\n                         }\n@@ -545,9 +556,9 @@ impl<'a> Resolver<'a> {\n \n         let binding = if let Some(binding) = binding {\n             MacroBinding::Legacy(binding)\n-        } else if let Some(binding) = self.global_macros.get(&name).cloned() {\n+        } else if let Some(binding) = self.global_macros.get(&ident.name).cloned() {\n             if !self.use_extern_macros {\n-                self.record_use(Ident::with_empty_ctxt(name), MacroNS, binding, DUMMY_SP);\n+                self.record_use(ident, MacroNS, binding, DUMMY_SP);\n             }\n             MacroBinding::Global(binding)\n         } else {\n@@ -557,7 +568,7 @@ impl<'a> Resolver<'a> {\n         if !self.use_extern_macros {\n             if let Some(scope) = possible_time_travel {\n                 // Check for disallowed shadowing later\n-                self.lexical_macro_resolutions.push((name, scope));\n+                self.lexical_macro_resolutions.push((ident, scope));\n             }\n         }\n \n@@ -578,7 +589,7 @@ impl<'a> Resolver<'a> {\n \n         for &(mark, ident, span, kind) in module.legacy_macro_resolutions.borrow().iter() {\n             let legacy_scope = &self.invocations[&mark].legacy_scope;\n-            let legacy_resolution = self.resolve_legacy_scope(legacy_scope, ident.name, true);\n+            let legacy_resolution = self.resolve_legacy_scope(legacy_scope, ident, true);\n             let resolution = self.resolve_lexical_macro_path_segment(ident, MacroNS, true, span);\n             match (legacy_resolution, resolution) {\n                 (Some(MacroBinding::Legacy(legacy_binding)), Ok(MacroBinding::Modern(binding))) => {\n@@ -615,7 +626,7 @@ impl<'a> Resolver<'a> {\n                           err: &mut DiagnosticBuilder<'a>, span: Span) {\n         // First check if this is a locally-defined bang macro.\n         let suggestion = if let MacroKind::Bang = kind {\n-            find_best_match_for_name(self.macro_names.iter(), name, None)\n+            find_best_match_for_name(self.macro_names.iter().map(|ident| &ident.name), name, None)\n         } else {\n             None\n         // Then check global macros.\n@@ -659,7 +670,10 @@ impl<'a> Resolver<'a> {\n         }\n     }\n \n-    fn collect_def_ids(&mut self, invocation: &'a InvocationData<'a>, expansion: &Expansion) {\n+    fn collect_def_ids(&mut self,\n+                       mark: Mark,\n+                       invocation: &'a InvocationData<'a>,\n+                       expansion: &Expansion) {\n         let Resolver { ref mut invocations, arenas, graph_root, .. } = *self;\n         let InvocationData { def_index, const_expr, .. } = *invocation;\n \n@@ -675,7 +689,7 @@ impl<'a> Resolver<'a> {\n             });\n         };\n \n-        let mut def_collector = DefCollector::new(&mut self.definitions);\n+        let mut def_collector = DefCollector::new(&mut self.definitions, mark);\n         def_collector.visit_macro_invoc = Some(visit_macro_invoc);\n         def_collector.with_parent(def_index, |def_collector| {\n             if const_expr {\n@@ -687,7 +701,10 @@ impl<'a> Resolver<'a> {\n         });\n     }\n \n-    pub fn define_macro(&mut self, item: &ast::Item, legacy_scope: &mut LegacyScope<'a>) {\n+    pub fn define_macro(&mut self,\n+                        item: &ast::Item,\n+                        expansion: Mark,\n+                        legacy_scope: &mut LegacyScope<'a>) {\n         self.local_macro_def_scopes.insert(item.id, self.current_module);\n         let ident = item.ident;\n         if ident.name == \"macro_rules\" {\n@@ -699,16 +716,26 @@ impl<'a> Resolver<'a> {\n                                                &self.session.features,\n                                                item));\n         self.macro_map.insert(def_id, ext);\n-        *legacy_scope = LegacyScope::Binding(self.arenas.alloc_legacy_binding(LegacyBinding {\n-            parent: Cell::new(*legacy_scope), name: ident.name, def_id: def_id, span: item.span,\n-        }));\n-        self.macro_names.insert(ident.name);\n \n-        if attr::contains_name(&item.attrs, \"macro_export\") {\n-            let def = Def::Macro(def_id, MacroKind::Bang);\n-            self.macro_exports.push(Export { name: ident.name, def: def, span: item.span });\n+        let def = match item.node { ast::ItemKind::MacroDef(ref def) => def, _ => unreachable!() };\n+        if def.legacy {\n+            let ident = ident.modern();\n+            self.macro_names.insert(ident);\n+            *legacy_scope = LegacyScope::Binding(self.arenas.alloc_legacy_binding(LegacyBinding {\n+                parent: Cell::new(*legacy_scope), ident: ident, def_id: def_id, span: item.span,\n+            }));\n+            if attr::contains_name(&item.attrs, \"macro_export\") {\n+                let def = Def::Macro(def_id, MacroKind::Bang);\n+                self.macro_exports\n+                    .push(Export { ident: ident.modern(), def: def, span: item.span });\n+            } else {\n+                self.unused_macros.insert(def_id);\n+            }\n         } else {\n-            self.unused_macros.insert(def_id);\n+            let module = self.current_module;\n+            let def = Def::Macro(def_id, MacroKind::Bang);\n+            let vis = self.resolve_visibility(&item.vis);\n+            self.define(module, ident, MacroNS, (def, vis, item.span, expansion));\n         }\n     }\n "}, {"sha": "c077f507932c62e6ac5eb235d3779689be9bb19a", "filename": "src/librustc_resolve/resolve_imports.rs", "status": "modified", "additions": 45, "deletions": 31, "changes": 76, "blob_url": "https://github.com/rust-lang/rust/blob/4f9c9ed1a53d176fb0650042f226222f401c21eb/src%2Flibrustc_resolve%2Fresolve_imports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f9c9ed1a53d176fb0650042f226222f401c21eb/src%2Flibrustc_resolve%2Fresolve_imports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fresolve_imports.rs?ref=4f9c9ed1a53d176fb0650042f226222f401c21eb", "patch": "@@ -134,21 +134,20 @@ impl<'a> NameResolution<'a> {\n impl<'a> Resolver<'a> {\n     fn resolution(&self, module: Module<'a>, ident: Ident, ns: Namespace)\n                   -> &'a RefCell<NameResolution<'a>> {\n-        let ident = ident.unhygienize();\n-        *module.resolutions.borrow_mut().entry((ident, ns))\n+        *module.resolutions.borrow_mut().entry((ident.modern(), ns))\n                .or_insert_with(|| self.arenas.alloc_name_resolution())\n     }\n \n     /// Attempts to resolve `ident` in namespaces `ns` of `module`.\n     /// Invariant: if `record_used` is `Some`, import resolution must be complete.\n-    pub fn resolve_ident_in_module(&mut self,\n-                                   module: Module<'a>,\n-                                   ident: Ident,\n-                                   ns: Namespace,\n-                                   restricted_shadowing: bool,\n-                                   record_used: bool,\n-                                   path_span: Span)\n-                                   -> Result<&'a NameBinding<'a>, Determinacy> {\n+    pub fn resolve_ident_in_module_unadjusted(&mut self,\n+                                              module: Module<'a>,\n+                                              ident: Ident,\n+                                              ns: Namespace,\n+                                              restricted_shadowing: bool,\n+                                              record_used: bool,\n+                                              path_span: Span)\n+                                              -> Result<&'a NameBinding<'a>, Determinacy> {\n         self.populate_module_if_necessary(module);\n \n         let resolution = self.resolution(module, ident, ns)\n@@ -233,20 +232,22 @@ impl<'a> Resolver<'a> {\n             return Err(Determined);\n         }\n         for directive in module.globs.borrow().iter() {\n-            if self.is_accessible(directive.vis.get()) {\n-                if let Some(module) = directive.imported_module.get() {\n-                    let result = self.resolve_ident_in_module(module,\n-                                                              ident,\n-                                                              ns,\n-                                                              false,\n-                                                              false,\n-                                                              path_span);\n-                    if let Err(Undetermined) = result {\n-                        return Err(Undetermined);\n-                    }\n-                } else {\n-                    return Err(Undetermined);\n-                }\n+            if !self.is_accessible(directive.vis.get()) {\n+                continue\n+            }\n+            let module = unwrap_or!(directive.imported_module.get(), return Err(Undetermined));\n+            let (orig_current_module, mut ident) = (self.current_module, ident.modern());\n+            match ident.ctxt.glob_adjust(module.expansion, directive.span.ctxt.modern()) {\n+                Some(Some(def)) => self.current_module = self.macro_def_scope(def),\n+                Some(None) => {}\n+                None => continue,\n+            };\n+            let result = self.resolve_ident_in_module_unadjusted(\n+                module, ident, ns, false, false, path_span,\n+            );\n+            self.current_module = orig_current_module;\n+            if let Err(Undetermined) = result {\n+                return Err(Undetermined);\n             }\n         }\n \n@@ -394,7 +395,14 @@ impl<'a> Resolver<'a> {\n \n         // Define `binding` in `module`s glob importers.\n         for directive in module.glob_importers.borrow_mut().iter() {\n-            if self.is_accessible_from(binding.vis, directive.parent) {\n+            let mut ident = ident.modern();\n+            let scope = match ident.ctxt.reverse_glob_adjust(module.expansion,\n+                                                             directive.span.ctxt.modern()) {\n+                Some(Some(def)) => self.macro_def_scope(def),\n+                Some(None) => directive.parent,\n+                None => continue,\n+            };\n+            if self.is_accessible_from(binding.vis, scope) {\n                 let imported_binding = self.import(binding, directive);\n                 let _ = self.try_define(directive.parent, ident, ns, imported_binding);\n             }\n@@ -767,8 +775,14 @@ impl<'a, 'b:'a> ImportResolver<'a, 'b> {\n         let bindings = module.resolutions.borrow().iter().filter_map(|(&ident, resolution)| {\n             resolution.borrow().binding().map(|binding| (ident, binding))\n         }).collect::<Vec<_>>();\n-        for ((ident, ns), binding) in bindings {\n-            if binding.pseudo_vis() == ty::Visibility::Public || self.is_accessible(binding.vis) {\n+        for ((mut ident, ns), binding) in bindings {\n+            let scope = match ident.ctxt.reverse_glob_adjust(module.expansion,\n+                                                             directive.span.ctxt.modern()) {\n+                Some(Some(def)) => self.macro_def_scope(def),\n+                Some(None) => self.current_module,\n+                None => continue,\n+            };\n+            if self.is_accessible_from(binding.pseudo_vis(), scope) {\n                 let imported_binding = self.import(binding, directive);\n                 let _ = self.try_define(directive.parent, ident, ns, imported_binding);\n             }\n@@ -789,7 +803,7 @@ impl<'a, 'b:'a> ImportResolver<'a, 'b> {\n         if module as *const _ == self.graph_root as *const _ {\n             let macro_exports = mem::replace(&mut self.macro_exports, Vec::new());\n             for export in macro_exports.into_iter().rev() {\n-                if exported_macro_names.insert(export.name, export.span).is_none() {\n+                if exported_macro_names.insert(export.ident.modern(), export.span).is_none() {\n                     reexports.push(export);\n                 }\n             }\n@@ -803,14 +817,14 @@ impl<'a, 'b:'a> ImportResolver<'a, 'b> {\n             };\n \n             if binding.vis == ty::Visibility::Public &&\n-               (binding.is_import() || binding.is_extern_crate()) {\n+               (binding.is_import() || binding.is_macro_def()) {\n                 let def = binding.def();\n                 if def != Def::Err {\n                     if !def.def_id().is_local() {\n                         self.session.cstore.export_macros(def.def_id().krate);\n                     }\n                     if let Def::Macro(..) = def {\n-                        if let Some(&span) = exported_macro_names.get(&ident.name) {\n+                        if let Some(&span) = exported_macro_names.get(&ident.modern()) {\n                             let msg =\n                                 format!(\"a macro named `{}` has already been exported\", ident);\n                             self.session.struct_span_err(span, &msg)\n@@ -819,7 +833,7 @@ impl<'a, 'b:'a> ImportResolver<'a, 'b> {\n                                 .emit();\n                         }\n                     }\n-                    reexports.push(Export { name: ident.name, def: def, span: binding.span });\n+                    reexports.push(Export { ident: ident.modern(), def: def, span: binding.span });\n                 }\n             }\n "}, {"sha": "d83740936d5d4dc6ceba451a7ce7add9b4a61fbf", "filename": "src/librustc_save_analysis/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4f9c9ed1a53d176fb0650042f226222f401c21eb/src%2Flibrustc_save_analysis%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f9c9ed1a53d176fb0650042f226222f401c21eb/src%2Flibrustc_save_analysis%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_save_analysis%2Flib.rs?ref=4f9c9ed1a53d176fb0650042f226222f401c21eb", "patch": "@@ -828,7 +828,7 @@ fn make_signature(decl: &ast::FnDecl, generics: &ast::Generics) -> String {\n     if !generics.lifetimes.is_empty() || !generics.ty_params.is_empty() {\n         sig.push('<');\n         sig.push_str(&generics.lifetimes.iter()\n-                              .map(|l| l.lifetime.name.to_string())\n+                              .map(|l| l.lifetime.ident.name.to_string())\n                               .collect::<Vec<_>>()\n                               .join(\", \"));\n         if !generics.lifetimes.is_empty() {"}, {"sha": "d1ff3ed4f490f291d1521acaf80803ed39c0eeb5", "filename": "src/librustc_typeck/astconv.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/4f9c9ed1a53d176fb0650042f226222f401c21eb/src%2Flibrustc_typeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f9c9ed1a53d176fb0650042f226222f401c21eb/src%2Flibrustc_typeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fastconv.rs?ref=4f9c9ed1a53d176fb0650042f226222f401c21eb", "patch": "@@ -891,7 +891,8 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n         let item = tcx.associated_items(trait_did).find(|i| i.name == assoc_name)\n                                                   .expect(\"missing associated type\");\n         let def = Def::AssociatedTy(item.def_id);\n-        if !tcx.vis_is_accessible_from(item.vis, ref_id) {\n+        let def_scope = tcx.adjust(assoc_name, item.container.id(), ref_id).1;\n+        if !item.vis.is_accessible_from(def_scope, tcx) {\n             let msg = format!(\"{} `{}` is private\", def.kind_name(), assoc_name);\n             tcx.sess.span_err(span, &msg);\n         }"}, {"sha": "43bf702935ac31e3d232821aa85bf28c150c99bb", "filename": "src/librustc_typeck/check/method/mod.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/4f9c9ed1a53d176fb0650042f226222f401c21eb/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f9c9ed1a53d176fb0650042f226222f401c21eb/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs?ref=4f9c9ed1a53d176fb0650042f226222f401c21eb", "patch": "@@ -338,6 +338,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n     /// and return it, or `None`, if no such item was defined there.\n     pub fn associated_item(&self, def_id: DefId, item_name: ast::Name)\n                            -> Option<ty::AssociatedItem> {\n-        self.tcx.associated_items(def_id).find(|item| item.name == item_name)\n+        let ident = self.tcx.adjust(item_name, def_id, self.body_id).0;\n+        self.tcx.associated_items(def_id).find(|item| item.name.to_ident() == ident)\n     }\n }"}, {"sha": "b32eb9ac5fbf6df24a04ca92753c816c369ea325", "filename": "src/librustc_typeck/check/method/probe.rs", "status": "modified", "additions": 14, "deletions": 2, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/4f9c9ed1a53d176fb0650042f226222f401c21eb/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f9c9ed1a53d176fb0650042f226222f401c21eb/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs?ref=4f9c9ed1a53d176fb0650042f226222f401c21eb", "patch": "@@ -371,7 +371,13 @@ impl<'a, 'gcx, 'tcx> ProbeContext<'a, 'gcx, 'tcx> {\n \n     fn push_inherent_candidate(&mut self, xform_self_ty: Ty<'tcx>, item: ty::AssociatedItem,\n                                kind: CandidateKind<'tcx>, import_id: Option<ast::NodeId>) {\n-        if self.tcx.vis_is_accessible_from(item.vis, self.body_id) {\n+        let is_accessible = if let LookingFor::MethodName(name) = self.looking_for {\n+            let def_scope = self.tcx.adjust(name, item.container.id(), self.body_id).1;\n+            item.vis.is_accessible_from(def_scope, self.tcx)\n+        } else {\n+            true\n+        };\n+        if is_accessible {\n             self.inherent_candidates.push(Candidate { xform_self_ty, item, kind, import_id });\n         } else if self.private_candidate.is_none() {\n             self.private_candidate = Some(item.def());\n@@ -380,7 +386,13 @@ impl<'a, 'gcx, 'tcx> ProbeContext<'a, 'gcx, 'tcx> {\n \n     fn push_extension_candidate(&mut self, xform_self_ty: Ty<'tcx>, item: ty::AssociatedItem,\n                                kind: CandidateKind<'tcx>, import_id: Option<ast::NodeId>) {\n-        if self.tcx.vis_is_accessible_from(item.vis, self.body_id) {\n+        let is_accessible = if let LookingFor::MethodName(name) = self.looking_for {\n+            let def_scope = self.tcx.adjust(name, item.container.id(), self.body_id).1;\n+            item.vis.is_accessible_from(def_scope, self.tcx)\n+        } else {\n+            true\n+        };\n+        if is_accessible {\n             self.extension_candidates.push(Candidate { xform_self_ty, item, kind, import_id });\n         } else if self.private_candidate.is_none() {\n             self.private_candidate = Some(item.def());"}, {"sha": "edaaa863ecc34f458357cb0ecfe1175c7874edc6", "filename": "src/librustc_typeck/check/method/suggest.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4f9c9ed1a53d176fb0650042f226222f401c21eb/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f9c9ed1a53d176fb0650042f226222f401c21eb/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs?ref=4f9c9ed1a53d176fb0650042f226222f401c21eb", "patch": "@@ -195,8 +195,8 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                                     };\n \n                                     let field_ty = field.ty(tcx, substs);\n-\n-                                    if tcx.vis_is_accessible_from(field.vis, self.body_id) {\n+                                    let scope = self.tcx.hir.get_module_parent(self.body_id);\n+                                    if field.vis.is_accessible_from(scope, self.tcx) {\n                                         if self.is_fn_ty(&field_ty, span) {\n                                             err.help(&format!(\"use `({0}.{1})(...)` if you \\\n                                                                meant to call the function \\"}, {"sha": "1ad3914854d342bff3b54aec232cb24103a1a463", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 22, "deletions": 9, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/4f9c9ed1a53d176fb0650042f226222f401c21eb/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f9c9ed1a53d176fb0650042f226222f401c21eb/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=4f9c9ed1a53d176fb0650042f226222f401c21eb", "patch": "@@ -2916,9 +2916,12 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             match base_t.sty {\n                 ty::TyAdt(base_def, substs) if !base_def.is_enum() => {\n                     debug!(\"struct named {:?}\",  base_t);\n-                    if let Some(field) = base_def.struct_variant().find_field_named(field.node) {\n+                    let (ident, def_scope) =\n+                        self.tcx.adjust(field.node, base_def.did, self.body_id);\n+                    let fields = &base_def.struct_variant().fields;\n+                    if let Some(field) = fields.iter().find(|f| f.name.to_ident() == ident) {\n                         let field_ty = self.field_ty(expr.span, field, substs);\n-                        if self.tcx.vis_is_accessible_from(field.vis, self.body_id) {\n+                        if field.vis.is_accessible_from(def_scope, self.tcx) {\n                             autoderef.finalize(lvalue_pref, base);\n                             self.apply_autoderef_adjustment(base.id, autoderefs, base_t);\n \n@@ -3024,16 +3027,25 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                     if !tuple_like { continue }\n \n                     debug!(\"tuple struct named {:?}\",  base_t);\n-                    base_def.struct_variant().fields.get(idx.node).and_then(|field| {\n+                    let ident = ast::Ident {\n+                        name: Symbol::intern(&idx.node.to_string()),\n+                        ctxt: idx.span.ctxt.modern(),\n+                    };\n+                    let (ident, def_scope) =\n+                        self.tcx.adjust_ident(ident, base_def.did, self.body_id);\n+                    let fields = &base_def.struct_variant().fields;\n+                    if let Some(field) = fields.iter().find(|f| f.name.to_ident() == ident) {\n                         let field_ty = self.field_ty(expr.span, field, substs);\n-                        private_candidate = Some((base_def.did, field_ty));\n-                        if self.tcx.vis_is_accessible_from(field.vis, self.body_id) {\n+                        if field.vis.is_accessible_from(def_scope, self.tcx) {\n                             self.tcx.check_stability(field.did, expr.id, expr.span);\n                             Some(field_ty)\n                         } else {\n+                            private_candidate = Some((base_def.did, field_ty));\n                             None\n                         }\n-                    })\n+                    } else {\n+                        None\n+                    }\n                 }\n                 ty::TyTuple(ref v, _) => {\n                     tuple_like = true;\n@@ -3142,7 +3154,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n \n         let mut remaining_fields = FxHashMap();\n         for field in &variant.fields {\n-            remaining_fields.insert(field.name, field);\n+            remaining_fields.insert(field.name.to_ident(), field);\n         }\n \n         let mut seen_fields = FxHashMap();\n@@ -3154,7 +3166,8 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             let final_field_type;\n             let field_type_hint;\n \n-            if let Some(v_field) = remaining_fields.remove(&field.name.node) {\n+            let ident = tcx.adjust(field.name.node, variant.did, self.body_id).0;\n+            if let Some(v_field) = remaining_fields.remove(&ident) {\n                 final_field_type = self.field_ty(field.span, v_field, substs);\n                 field_type_hint = self.field_ty(field.span, v_field, hint_substs);\n \n@@ -3205,7 +3218,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n \n             let mut displayable_field_names = remaining_fields\n                                               .keys()\n-                                              .map(|x| x.as_str())\n+                                              .map(|ident| ident.name.as_str())\n                                               .collect::<Vec<_>>();\n \n             displayable_field_names.sort();"}, {"sha": "5ea3eaa88d7726b6acea1174e48e53e77cb800d2", "filename": "src/librustdoc/clean/inline.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4f9c9ed1a53d176fb0650042f226222f401c21eb/src%2Flibrustdoc%2Fclean%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f9c9ed1a53d176fb0650042f226222f401c21eb/src%2Flibrustdoc%2Fclean%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Finline.rs?ref=4f9c9ed1a53d176fb0650042f226222f401c21eb", "patch": "@@ -447,7 +447,7 @@ fn build_module(cx: &DocContext, did: DefId) -> clean::Module {\n             let def_id = item.def.def_id();\n             if cx.tcx.sess.cstore.visibility(def_id) == ty::Visibility::Public {\n                 if !visited.insert(def_id) { continue }\n-                if let Some(i) = try_inline(cx, item.def, item.name) {\n+                if let Some(i) = try_inline(cx, item.def, item.ident.name) {\n                     items.extend(i)\n                 }\n             }"}, {"sha": "39ebe490d0eb28a064821bde1f20c3e37b638db2", "filename": "src/librustdoc/visit_ast.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/4f9c9ed1a53d176fb0650042f226222f401c21eb/src%2Flibrustdoc%2Fvisit_ast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f9c9ed1a53d176fb0650042f226222f401c21eb/src%2Flibrustdoc%2Fvisit_ast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fvisit_ast.rs?ref=4f9c9ed1a53d176fb0650042f226222f401c21eb", "patch": "@@ -16,7 +16,6 @@ use std::mem;\n use syntax::abi;\n use syntax::ast;\n use syntax::attr;\n-use syntax::tokenstream::TokenStream;\n use syntax_pos::Span;\n \n use rustc::hir::map as hir_map;\n@@ -214,8 +213,8 @@ impl<'a, 'tcx> RustdocVisitor<'a, 'tcx> {\n                         LoadedMacro::ProcMacro(..) => continue,\n                     };\n \n-                    let matchers = if let ast::ItemKind::MacroDef(ref tokens) = def.node {\n-                        let tts: Vec<_> = TokenStream::from(tokens.clone()).into_trees().collect();\n+                    let matchers = if let ast::ItemKind::MacroDef(ref def) = def.node {\n+                        let tts: Vec<_> = def.stream().into_trees().collect();\n                         tts.chunks(4).map(|arm| arm[0].span()).collect()\n                     } else {\n                         unreachable!()"}, {"sha": "2eb39bc26b5cb929b6223423c3067f58de39c8c9", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 14, "deletions": 2, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/4f9c9ed1a53d176fb0650042f226222f401c21eb/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f9c9ed1a53d176fb0650042f226222f401c21eb/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=4f9c9ed1a53d176fb0650042f226222f401c21eb", "patch": "@@ -37,7 +37,7 @@ use std::u32;\n pub struct Lifetime {\n     pub id: NodeId,\n     pub span: Span,\n-    pub name: Name\n+    pub ident: Ident,\n }\n \n impl fmt::Debug for Lifetime {\n@@ -1019,6 +1019,18 @@ impl Mac_ {\n     }\n }\n \n+#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n+pub struct MacroDef {\n+    pub tokens: ThinTokenStream,\n+    pub legacy: bool,\n+}\n+\n+impl MacroDef {\n+    pub fn stream(&self) -> TokenStream {\n+        self.tokens.clone().into()\n+    }\n+}\n+\n #[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug, Copy)]\n pub enum StrStyle {\n     /// A regular string, like `\"foo\"`\n@@ -1863,7 +1875,7 @@ pub enum ItemKind {\n     Mac(Mac),\n \n     /// A macro definition.\n-    MacroDef(ThinTokenStream),\n+    MacroDef(MacroDef),\n }\n \n impl ItemKind {"}, {"sha": "2a5de3c7382a334984d342b4e9cac5881eb45b88", "filename": "src/libsyntax/diagnostics/plugin.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4f9c9ed1a53d176fb0650042f226222f401c21eb/src%2Flibsyntax%2Fdiagnostics%2Fplugin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f9c9ed1a53d176fb0650042f226222f401c21eb/src%2Flibsyntax%2Fdiagnostics%2Fplugin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fdiagnostics%2Fplugin.rs?ref=4f9c9ed1a53d176fb0650042f226222f401c21eb", "patch": "@@ -206,7 +206,7 @@ pub fn expand_build_diagnostic_array<'cx>(ecx: &'cx mut ExtCtxt,\n             (descriptions.len(), ecx.expr_vec(span, descriptions))\n         });\n \n-    let static_ = ecx.lifetime(span, ecx.name_of(\"'static\"));\n+    let static_ = ecx.lifetime(span, Ident::from_str(\"'static\"));\n     let ty_str = ecx.ty_rptr(\n         span,\n         ecx.ty_ident(span, ecx.ident_of(\"str\")),"}, {"sha": "71dc81c37592322da76ee9bddf245d21577ec2ae", "filename": "src/libsyntax/ext/base.rs", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/4f9c9ed1a53d176fb0650042f226222f401c21eb/src%2Flibsyntax%2Fext%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f9c9ed1a53d176fb0650042f226222f401c21eb/src%2Flibsyntax%2Fext%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbase.rs?ref=4f9c9ed1a53d176fb0650042f226222f401c21eb", "patch": "@@ -550,12 +550,16 @@ pub enum SyntaxExtension {\n \n     /// An attribute-like procedural macro that derives a builtin trait.\n     BuiltinDerive(BuiltinDeriveFn),\n+\n+    /// A declarative macro, e.g. `macro m() {}`.\n+    DeclMacro(Box<TTMacroExpander>, Option<Span> /* definition site span */),\n }\n \n impl SyntaxExtension {\n     /// Return which kind of macro calls this syntax extension.\n     pub fn kind(&self) -> MacroKind {\n         match *self {\n+            SyntaxExtension::DeclMacro(..) |\n             SyntaxExtension::NormalTT(..) |\n             SyntaxExtension::IdentTT(..) |\n             SyntaxExtension::ProcMacro(..) =>\n@@ -569,6 +573,13 @@ impl SyntaxExtension {\n                 MacroKind::Derive,\n         }\n     }\n+\n+    pub fn is_modern(&self) -> bool {\n+        match *self {\n+            SyntaxExtension::DeclMacro(..) => true,\n+            _ => false,\n+        }\n+    }\n }\n \n pub type NamedSyntaxExtension = (Name, SyntaxExtension);"}, {"sha": "a4580ea3939fbb23803fffdb62e2a760c6e23c98", "filename": "src/libsyntax/ext/build.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/4f9c9ed1a53d176fb0650042f226222f401c21eb/src%2Flibsyntax%2Fext%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f9c9ed1a53d176fb0650042f226222f401c21eb/src%2Flibsyntax%2Fext%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbuild.rs?ref=4f9c9ed1a53d176fb0650042f226222f401c21eb", "patch": "@@ -76,10 +76,10 @@ pub trait AstBuilder {\n     fn trait_ref(&self, path: ast::Path) -> ast::TraitRef;\n     fn poly_trait_ref(&self, span: Span, path: ast::Path) -> ast::PolyTraitRef;\n     fn typarambound(&self, path: ast::Path) -> ast::TyParamBound;\n-    fn lifetime(&self, span: Span, ident: ast::Name) -> ast::Lifetime;\n+    fn lifetime(&self, span: Span, ident: ast::Ident) -> ast::Lifetime;\n     fn lifetime_def(&self,\n                     span: Span,\n-                    name: ast::Name,\n+                    ident: ast::Ident,\n                     attrs: Vec<ast::Attribute>,\n                     bounds: Vec<ast::Lifetime>)\n                     -> ast::LifetimeDef;\n@@ -478,19 +478,19 @@ impl<'a> AstBuilder for ExtCtxt<'a> {\n         ast::TraitTyParamBound(self.poly_trait_ref(path.span, path), ast::TraitBoundModifier::None)\n     }\n \n-    fn lifetime(&self, span: Span, name: ast::Name) -> ast::Lifetime {\n-        ast::Lifetime { id: ast::DUMMY_NODE_ID, span: span, name: name }\n+    fn lifetime(&self, span: Span, ident: ast::Ident) -> ast::Lifetime {\n+        ast::Lifetime { id: ast::DUMMY_NODE_ID, span: span, ident: ident }\n     }\n \n     fn lifetime_def(&self,\n                     span: Span,\n-                    name: ast::Name,\n+                    ident: ast::Ident,\n                     attrs: Vec<ast::Attribute>,\n                     bounds: Vec<ast::Lifetime>)\n                     -> ast::LifetimeDef {\n         ast::LifetimeDef {\n             attrs: attrs.into(),\n-            lifetime: self.lifetime(span, name),\n+            lifetime: self.lifetime(span, ident),\n             bounds: bounds\n         }\n     }"}, {"sha": "be077b481113f12c17fad392137df5465040e1b2", "filename": "src/libsyntax/ext/expand.rs", "status": "modified", "additions": 27, "deletions": 15, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/4f9c9ed1a53d176fb0650042f226222f401c21eb/src%2Flibsyntax%2Fext%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f9c9ed1a53d176fb0650042f226222f401c21eb/src%2Flibsyntax%2Fext%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fexpand.rs?ref=4f9c9ed1a53d176fb0650042f226222f401c21eb", "patch": "@@ -288,7 +288,7 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n                     let derives = derives.entry(invoc.expansion_data.mark).or_insert_with(Vec::new);\n \n                     for path in &traits {\n-                        let mark = Mark::fresh();\n+                        let mark = Mark::fresh(self.cx.current_expansion.mark);\n                         derives.push(mark);\n                         let item = match self.cx.resolver.resolve_macro(\n                                 Mark::root(), path, MacroKind::Derive, false) {\n@@ -455,25 +455,37 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n         let path = &mac.node.path;\n \n         let ident = ident.unwrap_or_else(|| keywords::Invalid.ident());\n+        let validate_and_set_expn_info = |def_site_span, allow_internal_unstable| {\n+            if ident.name != keywords::Invalid.name() {\n+                return Err(format!(\"macro {}! expects no ident argument, given '{}'\", path, ident));\n+            }\n+            mark.set_expn_info(ExpnInfo {\n+                call_site: span,\n+                callee: NameAndSpan {\n+                    format: MacroBang(Symbol::intern(&format!(\"{}\", path))),\n+                    span: def_site_span,\n+                    allow_internal_unstable: allow_internal_unstable,\n+                },\n+            });\n+            Ok(())\n+        };\n+\n         let marked_tts = noop_fold_tts(mac.node.stream(), &mut Marker(mark));\n         let opt_expanded = match *ext {\n-            NormalTT(ref expandfun, exp_span, allow_internal_unstable) => {\n-                if ident.name != keywords::Invalid.name() {\n-                    let msg =\n-                        format!(\"macro {}! expects no ident argument, given '{}'\", path, ident);\n+            SyntaxExtension::DeclMacro(ref expand, def_site_span) => {\n+                if let Err(msg) = validate_and_set_expn_info(def_site_span, false) {\n                     self.cx.span_err(path.span, &msg);\n                     return kind.dummy(span);\n                 }\n+                kind.make_from(expand.expand(self.cx, span, marked_tts))\n+            }\n \n-                invoc.expansion_data.mark.set_expn_info(ExpnInfo {\n-                    call_site: span,\n-                    callee: NameAndSpan {\n-                        format: MacroBang(Symbol::intern(&format!(\"{}\", path))),\n-                        span: exp_span.map(|(_, s)| s),\n-                        allow_internal_unstable: allow_internal_unstable,\n-                    },\n-                });\n-\n+            NormalTT(ref expandfun, def_info, allow_internal_unstable) => {\n+                if let Err(msg) = validate_and_set_expn_info(def_info.map(|(_, s)| s),\n+                                                             allow_internal_unstable) {\n+                    self.cx.span_err(path.span, &msg);\n+                    return kind.dummy(span);\n+                }\n                 kind.make_from(expandfun.expand(self.cx, span, marked_tts))\n             }\n \n@@ -687,7 +699,7 @@ macro_rules! fully_configure {\n \n impl<'a, 'b> InvocationCollector<'a, 'b> {\n     fn collect(&mut self, expansion_kind: ExpansionKind, kind: InvocationKind) -> Expansion {\n-        let mark = Mark::fresh();\n+        let mark = Mark::fresh(self.cx.current_expansion.mark);\n         self.invocations.push(Invocation {\n             kind: kind,\n             expansion_kind: expansion_kind,"}, {"sha": "a9252d0818e38039a1152589515cc821b1a156d3", "filename": "src/libsyntax/ext/tt/macro_rules.rs", "status": "modified", "additions": 14, "deletions": 10, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/4f9c9ed1a53d176fb0650042f226222f401c21eb/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f9c9ed1a53d176fb0650042f226222f401c21eb/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs?ref=4f9c9ed1a53d176fb0650042f226222f401c21eb", "patch": "@@ -162,6 +162,12 @@ pub fn compile(sess: &ParseSess, features: &RefCell<Features>, def: &ast::Item)\n     let lhs_nm = ast::Ident::with_empty_ctxt(Symbol::gensym(\"lhs\"));\n     let rhs_nm = ast::Ident::with_empty_ctxt(Symbol::gensym(\"rhs\"));\n \n+    // Parse the macro_rules! invocation\n+    let body = match def.node {\n+        ast::ItemKind::MacroDef(ref body) => body,\n+        _ => unreachable!(),\n+    };\n+\n     // The pattern that macro_rules matches.\n     // The grammar for macro_rules! is:\n     // $( $lhs:tt => $rhs:tt );+\n@@ -174,7 +180,7 @@ pub fn compile(sess: &ParseSess, features: &RefCell<Features>, def: &ast::Item)\n                 quoted::TokenTree::Token(DUMMY_SP, token::FatArrow),\n                 quoted::TokenTree::MetaVarDecl(DUMMY_SP, rhs_nm, ast::Ident::from_str(\"tt\")),\n             ],\n-            separator: Some(token::Semi),\n+            separator: Some(if body.legacy { token::Semi } else { token::Comma }),\n             op: quoted::KleeneOp::OneOrMore,\n             num_captures: 2,\n         })),\n@@ -187,12 +193,7 @@ pub fn compile(sess: &ParseSess, features: &RefCell<Features>, def: &ast::Item)\n         })),\n     ];\n \n-    // Parse the macro_rules! invocation\n-    let body = match def.node {\n-        ast::ItemKind::MacroDef(ref body) => body.clone().into(),\n-        _ => unreachable!(),\n-    };\n-    let argument_map = match parse(sess, body, &argument_gram, None, true) {\n+    let argument_map = match parse(sess, body.stream(), &argument_gram, None, true) {\n         Success(m) => m,\n         Failure(sp, tok) => {\n             let s = parse_failure_msg(tok);\n@@ -252,9 +253,12 @@ pub fn compile(sess: &ParseSess, features: &RefCell<Features>, def: &ast::Item)\n         valid: valid,\n     });\n \n-    NormalTT(exp,\n-             Some((def.id, def.span)),\n-             attr::contains_name(&def.attrs, \"allow_internal_unstable\"))\n+    if body.legacy {\n+        let allow_internal_unstable = attr::contains_name(&def.attrs, \"allow_internal_unstable\");\n+        NormalTT(exp, Some((def.id, def.span)), allow_internal_unstable)\n+    } else {\n+        SyntaxExtension::DeclMacro(exp, Some(def.span))\n+    }\n }\n \n fn check_lhs_nt_follows(sess: &ParseSess,"}, {"sha": "6ea8fab98aa2f225421d49eae32393637b5945d5", "filename": "src/libsyntax/feature_gate.rs", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/4f9c9ed1a53d176fb0650042f226222f401c21eb/src%2Flibsyntax%2Ffeature_gate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f9c9ed1a53d176fb0650042f226222f401c21eb/src%2Flibsyntax%2Ffeature_gate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffeature_gate.rs?ref=4f9c9ed1a53d176fb0650042f226222f401c21eb", "patch": "@@ -306,9 +306,12 @@ declare_features! (\n     // The `unadjusted` ABI. Perma unstable.\n     (active, abi_unadjusted, \"1.16.0\", None),\n \n-    // Macros 1.1\n+    // Procedural macros 2.0.\n     (active, proc_macro, \"1.16.0\", Some(38356)),\n \n+    // Declarative macros 2.0 (`macro`).\n+    (active, decl_macro, \"1.17.0\", Some(39412)),\n+\n     // Allows attributes on struct literal fields.\n     (active, struct_field_attributes, \"1.16.0\", Some(38814)),\n \n@@ -1225,6 +1228,11 @@ impl<'a> Visitor<'a> for PostExpansionVisitor<'a> {\n                 }\n             }\n \n+            ast::ItemKind::MacroDef(ast::MacroDef { legacy: false, .. }) => {\n+                let msg = \"`macro` is experimental\";\n+                gate_feature_post!(&self, decl_macro, i.span, msg);\n+            }\n+\n             _ => {}\n         }\n "}, {"sha": "4c6cf49a8db43d1b14981a263e2b4507f24672ac", "filename": "src/libsyntax/fold.rs", "status": "modified", "additions": 14, "deletions": 3, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/4f9c9ed1a53d176fb0650042f226222f401c21eb/src%2Flibsyntax%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f9c9ed1a53d176fb0650042f226222f401c21eb/src%2Flibsyntax%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffold.rs?ref=4f9c9ed1a53d176fb0650042f226222f401c21eb", "patch": "@@ -189,6 +189,10 @@ pub trait Folder : Sized {\n         // fold::noop_fold_mac(_mac, self)\n     }\n \n+    fn fold_macro_def(&mut self, def: MacroDef) -> MacroDef {\n+        noop_fold_macro_def(def, self)\n+    }\n+\n     fn fold_lifetime(&mut self, l: Lifetime) -> Lifetime {\n         noop_fold_lifetime(l, self)\n     }\n@@ -424,7 +428,7 @@ pub fn noop_fold_global_asm<T: Folder>(ga: P<GlobalAsm>,\n pub fn noop_fold_variant<T: Folder>(v: Variant, fld: &mut T) -> Variant {\n     Spanned {\n         node: Variant_ {\n-            name: v.node.name,\n+            name: fld.fold_ident(v.node.name),\n             attrs: fold_attrs(v.node.attrs, fld),\n             data: fld.fold_variant_data(v.node.data),\n             disr_expr: v.node.disr_expr.map(|e| fld.fold_expr(e)),\n@@ -515,6 +519,13 @@ pub fn noop_fold_mac<T: Folder>(Spanned {node, span}: Mac, fld: &mut T) -> Mac {\n     }\n }\n \n+pub fn noop_fold_macro_def<T: Folder>(def: MacroDef, fld: &mut T) -> MacroDef {\n+    MacroDef {\n+        tokens: fld.fold_tts(def.tokens.into()).into(),\n+        legacy: def.legacy,\n+    }\n+}\n+\n pub fn noop_fold_meta_list_item<T: Folder>(li: NestedMetaItem, fld: &mut T)\n     -> NestedMetaItem {\n     Spanned {\n@@ -683,7 +694,7 @@ pub fn noop_fold_ty_params<T: Folder>(tps: Vec<TyParam>, fld: &mut T) -> Vec<TyP\n pub fn noop_fold_lifetime<T: Folder>(l: Lifetime, fld: &mut T) -> Lifetime {\n     Lifetime {\n         id: fld.new_id(l.id),\n-        name: l.name,\n+        ident: fld.fold_ident(l.ident),\n         span: fld.new_span(l.span)\n     }\n }\n@@ -919,7 +930,7 @@ pub fn noop_fold_item_kind<T: Folder>(i: ItemKind, folder: &mut T) -> ItemKind {\n             items.move_flat_map(|item| folder.fold_trait_item(item)),\n         ),\n         ItemKind::Mac(m) => ItemKind::Mac(folder.fold_mac(m)),\n-        ItemKind::MacroDef(tts) => ItemKind::MacroDef(folder.fold_tts(tts.into()).into()),\n+        ItemKind::MacroDef(def) => ItemKind::MacroDef(folder.fold_macro_def(def)),\n     }\n }\n "}, {"sha": "8d7c8c5248bb9e69977a8184dc6a9e623aeb99c7", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 48, "deletions": 20, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/4f9c9ed1a53d176fb0650042f226222f401c21eb/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f9c9ed1a53d176fb0650042f226222f401c21eb/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=4f9c9ed1a53d176fb0650042f226222f401c21eb", "patch": "@@ -1958,7 +1958,7 @@ impl<'a> Parser<'a> {\n             token::Lifetime(ident) => {\n                 let ident_span = self.span;\n                 self.bump();\n-                Lifetime { name: ident.name, span: ident_span, id: ast::DUMMY_NODE_ID }\n+                Lifetime { ident: ident, span: ident_span, id: ast::DUMMY_NODE_ID }\n             }\n             _ => self.span_bug(self.span, \"not a lifetime\")\n         }\n@@ -3758,31 +3758,59 @@ impl<'a> Parser<'a> {\n     fn eat_macro_def(&mut self, attrs: &[Attribute], vis: &Visibility)\n                      -> PResult<'a, Option<P<Item>>> {\n         let lo = self.span;\n-        match self.token {\n-            token::Ident(ident) if ident.name == \"macro_rules\" => {\n-                if self.look_ahead(1, |t| *t == token::Not) {\n-                    let prev_span = self.prev_span;\n-                    self.complain_if_pub_macro(vis, prev_span);\n-                    self.bump();\n-                    self.bump();\n+        let (ident, def) = match self.token {\n+            token::Ident(ident) if ident.name == keywords::Macro.name() => {\n+                self.bump();\n+                let ident = self.parse_ident()?;\n+                let tokens = if self.check(&token::OpenDelim(token::Brace)) {\n+                    match self.parse_token_tree() {\n+                        TokenTree::Delimited(_, ref delimited) => delimited.stream(),\n+                        _ => unreachable!(),\n+                    }\n+                } else if self.check(&token::OpenDelim(token::Paren)) {\n+                    let args = self.parse_token_tree();\n+                    let body = if self.check(&token::OpenDelim(token::Brace)) {\n+                        self.parse_token_tree()\n+                    } else {\n+                        self.unexpected()?;\n+                        unreachable!()\n+                    };\n+                    TokenStream::concat(vec![\n+                        args.into(),\n+                        TokenTree::Token(lo.to(self.prev_span), token::FatArrow).into(),\n+                        body.into(),\n+                    ])\n+                } else {\n+                    self.unexpected()?;\n+                    unreachable!()\n+                };\n+\n+                (ident, ast::MacroDef { tokens: tokens.into(), legacy: false })\n+            }\n+            token::Ident(ident) if ident.name == \"macro_rules\" &&\n+                                   self.look_ahead(1, |t| *t == token::Not) => {\n+                let prev_span = self.prev_span;\n+                self.complain_if_pub_macro(vis, prev_span);\n+                self.bump();\n+                self.bump();\n+\n+                let ident = self.parse_ident()?;\n+                let (delim, tokens) = self.expect_delimited_token_tree()?;\n+                if delim != token::Brace {\n+                    if !self.eat(&token::Semi) {\n+                        let msg = \"macros that expand to items must either \\\n+                                   be surrounded with braces or followed by a semicolon\";\n+                        self.span_err(self.prev_span, msg);\n+                    }\n                 }\n+\n+                (ident, ast::MacroDef { tokens: tokens, legacy: true })\n             }\n             _ => return Ok(None),\n         };\n \n-        let id = self.parse_ident()?;\n-        let (delim, tts) = self.expect_delimited_token_tree()?;\n-        if delim != token::Brace {\n-            if !self.eat(&token::Semi) {\n-                let msg = \"macros that expand to items must either be surrounded with braces \\\n-                           or followed by a semicolon\";\n-                self.span_err(self.prev_span, msg);\n-            }\n-        }\n-\n         let span = lo.to(self.prev_span);\n-        let kind = ItemKind::MacroDef(tts);\n-        Ok(Some(self.mk_item(span, id, kind, Visibility::Inherited, attrs.to_owned())))\n+        Ok(Some(self.mk_item(span, ident, ItemKind::MacroDef(def), vis.clone(), attrs.to_vec())))\n     }\n \n     fn parse_stmt_without_recovery(&mut self,"}, {"sha": "073ededcb0ce777cdd388557f8fb463e4b8d8606", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4f9c9ed1a53d176fb0650042f226222f401c21eb/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f9c9ed1a53d176fb0650042f226222f401c21eb/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=4f9c9ed1a53d176fb0650042f226222f401c21eb", "patch": "@@ -1392,7 +1392,7 @@ impl<'a> State<'a> {\n                 self.print_ident(item.ident)?;\n                 self.cbox(INDENT_UNIT)?;\n                 self.popen()?;\n-                self.print_tts(tts.clone().into())?;\n+                self.print_tts(tts.stream())?;\n                 self.pclose()?;\n                 word(&mut self.s, \";\")?;\n                 self.end()?;\n@@ -2764,7 +2764,7 @@ impl<'a> State<'a> {\n                           lifetime: &ast::Lifetime)\n                           -> io::Result<()>\n     {\n-        self.print_name(lifetime.name)\n+        self.print_name(lifetime.ident.name)\n     }\n \n     pub fn print_lifetime_bounds(&mut self,"}, {"sha": "a8a9ae556f1084509a43ecd8c961ca7d3d93346e", "filename": "src/libsyntax/std_inject.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4f9c9ed1a53d176fb0650042f226222f401c21eb/src%2Flibsyntax%2Fstd_inject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f9c9ed1a53d176fb0650042f226222f401c21eb/src%2Flibsyntax%2Fstd_inject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fstd_inject.rs?ref=4f9c9ed1a53d176fb0650042f226222f401c21eb", "patch": "@@ -21,7 +21,7 @@ use tokenstream::TokenStream;\n /// call to codemap's `is_internal` check.\n /// The expanded code uses the unstable `#[prelude_import]` attribute.\n fn ignored_span(sp: Span) -> Span {\n-    let mark = Mark::fresh();\n+    let mark = Mark::fresh(Mark::root());\n     mark.set_expn_info(ExpnInfo {\n         call_site: DUMMY_SP,\n         callee: NameAndSpan {"}, {"sha": "837c3eb0100c60ed1859d706d6c387a0c0a78ab4", "filename": "src/libsyntax/test.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4f9c9ed1a53d176fb0650042f226222f401c21eb/src%2Flibsyntax%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f9c9ed1a53d176fb0650042f226222f401c21eb/src%2Flibsyntax%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ftest.rs?ref=4f9c9ed1a53d176fb0650042f226222f401c21eb", "patch": "@@ -276,7 +276,7 @@ fn generate_test_harness(sess: &ParseSess,\n     let mut cleaner = EntryPointCleaner { depth: 0 };\n     let krate = cleaner.fold_crate(krate);\n \n-    let mark = Mark::fresh();\n+    let mark = Mark::fresh(Mark::root());\n     let mut cx: TestCtxt = TestCtxt {\n         sess: sess,\n         span_diagnostic: sd,\n@@ -591,7 +591,7 @@ fn mk_tests(cx: &TestCtxt) -> P<ast::Item> {\n     let struct_type = ecx.ty_path(ecx.path(sp, vec![ecx.ident_of(\"self\"),\n                                                     ecx.ident_of(\"test\"),\n                                                     ecx.ident_of(\"TestDescAndFn\")]));\n-    let static_lt = ecx.lifetime(sp, keywords::StaticLifetime.name());\n+    let static_lt = ecx.lifetime(sp, keywords::StaticLifetime.ident());\n     // &'static [self::test::TestDescAndFn]\n     let static_type = ecx.ty_rptr(sp,\n                                   ecx.ty(sp, ast::TyKind::Slice(struct_type)),"}, {"sha": "18a0949af0eb136c5a25dabba2417dbc5840fe5e", "filename": "src/libsyntax/visit.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/4f9c9ed1a53d176fb0650042f226222f401c21eb/src%2Flibsyntax%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f9c9ed1a53d176fb0650042f226222f401c21eb/src%2Flibsyntax%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fvisit.rs?ref=4f9c9ed1a53d176fb0650042f226222f401c21eb", "patch": "@@ -27,7 +27,6 @@ use abi::Abi;\n use ast::*;\n use syntax_pos::Span;\n use codemap::Spanned;\n-use tokenstream::ThinTokenStream;\n \n #[derive(Copy, Clone, PartialEq, Eq)]\n pub enum FnKind<'a> {\n@@ -113,7 +112,7 @@ pub trait Visitor<'ast>: Sized {\n         // definition in your trait impl:\n         // visit::walk_mac(self, _mac)\n     }\n-    fn visit_mac_def(&mut self, _mac: &'ast ThinTokenStream, _id: NodeId) {\n+    fn visit_mac_def(&mut self, _mac: &'ast MacroDef, _id: NodeId) {\n         // Nothing to do\n     }\n     fn visit_path(&mut self, path: &'ast Path, _id: NodeId) {\n@@ -196,7 +195,7 @@ pub fn walk_local<'a, V: Visitor<'a>>(visitor: &mut V, local: &'a Local) {\n }\n \n pub fn walk_lifetime<'a, V: Visitor<'a>>(visitor: &mut V, lifetime: &'a Lifetime) {\n-    visitor.visit_name(lifetime.span, lifetime.name);\n+    visitor.visit_ident(lifetime.span, lifetime.ident);\n }\n \n pub fn walk_lifetime_def<'a, V: Visitor<'a>>(visitor: &mut V, lifetime_def: &'a LifetimeDef) {"}, {"sha": "9c89f99cbb5b3d6d652551d07499349bba8f4f0f", "filename": "src/libsyntax_ext/deriving/generic/ty.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/4f9c9ed1a53d176fb0650042f226222f401c21eb/src%2Flibsyntax_ext%2Fderiving%2Fgeneric%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f9c9ed1a53d176fb0650042f226222f401c21eb/src%2Flibsyntax_ext%2Fderiving%2Fgeneric%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fderiving%2Fgeneric%2Fty.rs?ref=4f9c9ed1a53d176fb0650042f226222f401c21eb", "patch": "@@ -118,14 +118,14 @@ pub fn nil_ty<'r>() -> Ty<'r> {\n \n fn mk_lifetime(cx: &ExtCtxt, span: Span, lt: &Option<&str>) -> Option<ast::Lifetime> {\n     match *lt {\n-        Some(ref s) => Some(cx.lifetime(span, cx.ident_of(*s).name)),\n+        Some(s) => Some(cx.lifetime(span, Ident::from_str(s))),\n         None => None,\n     }\n }\n \n fn mk_lifetimes(cx: &ExtCtxt, span: Span, lt: &Option<&str>) -> Vec<ast::Lifetime> {\n     match *lt {\n-        Some(ref s) => vec![cx.lifetime(span, cx.ident_of(*s).name)],\n+        Some(s) => vec![cx.lifetime(span, Ident::from_str(s))],\n         None => vec![],\n     }\n }\n@@ -243,11 +243,11 @@ impl<'a> LifetimeBounds<'a> {\n                        -> Generics {\n         let lifetimes = self.lifetimes\n             .iter()\n-            .map(|&(ref lt, ref bounds)| {\n+            .map(|&(lt, ref bounds)| {\n                 let bounds = bounds.iter()\n-                    .map(|b| cx.lifetime(span, cx.ident_of(*b).name))\n+                    .map(|b| cx.lifetime(span, Ident::from_str(b)))\n                     .collect();\n-                cx.lifetime_def(span, cx.ident_of(*lt).name, vec![], bounds)\n+                cx.lifetime_def(span, Ident::from_str(lt), vec![], bounds)\n             })\n             .collect();\n         let ty_params = self.bounds\n@@ -277,7 +277,7 @@ pub fn get_explicit_self(cx: &ExtCtxt,\n                 respan(span,\n                        match *ptr {\n                            Borrowed(ref lt, mutbl) => {\n-                               let lt = lt.map(|s| cx.lifetime(span, cx.ident_of(s).name));\n+                               let lt = lt.map(|s| cx.lifetime(span, Ident::from_str(s)));\n                                SelfKind::Region(lt, mutbl)\n                            }\n                            Raw(_) => {"}, {"sha": "00dcfc7a587069a2294d750d2a92a2a2ecba14ae", "filename": "src/libsyntax_ext/deriving/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4f9c9ed1a53d176fb0650042f226222f401c21eb/src%2Flibsyntax_ext%2Fderiving%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f9c9ed1a53d176fb0650042f226222f401c21eb/src%2Flibsyntax_ext%2Fderiving%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fderiving%2Fmod.rs?ref=4f9c9ed1a53d176fb0650042f226222f401c21eb", "patch": "@@ -162,7 +162,7 @@ fn call_intrinsic(cx: &ExtCtxt,\n     } else { // Avoid instability errors with user defined curstom derives, cc #36316\n         let mut info = cx.current_expansion.mark.expn_info().unwrap();\n         info.callee.allow_internal_unstable = true;\n-        let mark = Mark::fresh();\n+        let mark = Mark::fresh(Mark::root());\n         mark.set_expn_info(info);\n         span.ctxt = SyntaxContext::empty().apply_mark(mark);\n     }"}, {"sha": "affebbabbbda4d22398157c6513ea5d7bf933860", "filename": "src/libsyntax_ext/env.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/4f9c9ed1a53d176fb0650042f226222f401c21eb/src%2Flibsyntax_ext%2Fenv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f9c9ed1a53d176fb0650042f226222f401c21eb/src%2Flibsyntax_ext%2Fenv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fenv.rs?ref=4f9c9ed1a53d176fb0650042f226222f401c21eb", "patch": "@@ -13,7 +13,7 @@\n // interface.\n //\n \n-use syntax::ast;\n+use syntax::ast::{self, Ident};\n use syntax::ext::base::*;\n use syntax::ext::base;\n use syntax::ext::build::AstBuilder;\n@@ -39,10 +39,9 @@ pub fn expand_option_env<'cx>(cx: &'cx mut ExtCtxt,\n                                      cx.std_path(&[\"option\", \"Option\", \"None\"]),\n                                      Vec::new(),\n                                      vec![cx.ty_rptr(sp,\n-                                                     cx.ty_ident(sp, cx.ident_of(\"str\")),\n+                                                     cx.ty_ident(sp, Ident::from_str(\"str\")),\n                                                      Some(cx.lifetime(sp,\n-                                                                      cx.ident_of(\"'static\")\n-                                                                          .name)),\n+                                                                      Ident::from_str(\"'static\"))),\n                                                      ast::Mutability::Immutable)],\n                                      Vec::new()))\n         }"}, {"sha": "24c1dfe289b1ed15c6494b77f28fd286a12a64e8", "filename": "src/libsyntax_ext/format.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4f9c9ed1a53d176fb0650042f226222f401c21eb/src%2Flibsyntax_ext%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f9c9ed1a53d176fb0650042f226222f401c21eb/src%2Flibsyntax_ext%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fformat.rs?ref=4f9c9ed1a53d176fb0650042f226222f401c21eb", "patch": "@@ -508,7 +508,7 @@ impl<'a, 'b> Context<'a, 'b> {\n         let sp = piece_ty.span;\n         let ty = ecx.ty_rptr(sp,\n                              ecx.ty(sp, ast::TyKind::Slice(piece_ty)),\n-                             Some(ecx.lifetime(sp, keywords::StaticLifetime.name())),\n+                             Some(ecx.lifetime(sp, keywords::StaticLifetime.ident())),\n                              ast::Mutability::Immutable);\n         let slice = ecx.expr_vec_slice(sp, pieces);\n         // static instead of const to speed up codegen by not requiring this to be inlined\n@@ -536,7 +536,7 @@ impl<'a, 'b> Context<'a, 'b> {\n \n         // First, build up the static array which will become our precompiled\n         // format \"string\"\n-        let static_lifetime = self.ecx.lifetime(self.fmtsp, keywords::StaticLifetime.name());\n+        let static_lifetime = self.ecx.lifetime(self.fmtsp, keywords::StaticLifetime.ident());\n         let piece_ty = self.ecx.ty_rptr(self.fmtsp,\n                                         self.ecx.ty_ident(self.fmtsp, self.ecx.ident_of(\"str\")),\n                                         Some(static_lifetime),"}, {"sha": "ab6d73e5061a0a5252834ca345137a95c3b46dc2", "filename": "src/libsyntax_ext/proc_macro_registrar.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4f9c9ed1a53d176fb0650042f226222f401c21eb/src%2Flibsyntax_ext%2Fproc_macro_registrar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f9c9ed1a53d176fb0650042f226222f401c21eb/src%2Flibsyntax_ext%2Fproc_macro_registrar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fproc_macro_registrar.rs?ref=4f9c9ed1a53d176fb0650042f226222f401c21eb", "patch": "@@ -361,7 +361,7 @@ fn mk_registrar(cx: &mut ExtCtxt,\n                 custom_derives: &[ProcMacroDerive],\n                 custom_attrs: &[ProcMacroDef],\n                 custom_macros: &[ProcMacroDef]) -> P<ast::Item> {\n-    let mark = Mark::fresh();\n+    let mark = Mark::fresh(Mark::root());\n     mark.set_expn_info(ExpnInfo {\n         call_site: DUMMY_SP,\n         callee: NameAndSpan {"}, {"sha": "f2ccc3f051e9289eb3f3a14567b06ecf6415eb63", "filename": "src/libsyntax_pos/hygiene.rs", "status": "modified", "additions": 196, "deletions": 23, "changes": 219, "blob_url": "https://github.com/rust-lang/rust/blob/4f9c9ed1a53d176fb0650042f226222f401c21eb/src%2Flibsyntax_pos%2Fhygiene.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f9c9ed1a53d176fb0650042f226222f401c21eb/src%2Flibsyntax_pos%2Fhygiene.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_pos%2Fhygiene.rs?ref=4f9c9ed1a53d176fb0650042f226222f401c21eb", "patch": "@@ -16,31 +16,39 @@\n //! DOI=10.1017/S0956796812000093 http://dx.doi.org/10.1017/S0956796812000093\n \n use Span;\n-use symbol::Symbol;\n+use symbol::{Ident, Symbol};\n \n use serialize::{Encodable, Decodable, Encoder, Decoder};\n use std::cell::RefCell;\n use std::collections::HashMap;\n use std::fmt;\n \n /// A SyntaxContext represents a chain of macro expansions (represented by marks).\n-#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]\n+#[derive(Clone, Copy, PartialEq, Eq, Default, PartialOrd, Ord, Hash)]\n pub struct SyntaxContext(u32);\n \n-#[derive(Copy, Clone)]\n+#[derive(Copy, Clone, Default)]\n pub struct SyntaxContextData {\n     pub outer_mark: Mark,\n     pub prev_ctxt: SyntaxContext,\n+    pub modern: SyntaxContext,\n }\n \n /// A mark is a unique id associated with a macro expansion.\n #[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, Default, RustcEncodable, RustcDecodable)]\n pub struct Mark(u32);\n \n+#[derive(Default)]\n+struct MarkData {\n+    parent: Mark,\n+    modern: bool,\n+    expn_info: Option<ExpnInfo>,\n+}\n+\n impl Mark {\n-    pub fn fresh() -> Self {\n+    pub fn fresh(parent: Mark) -> Self {\n         HygieneData::with(|data| {\n-            data.marks.push(None);\n+            data.marks.push(MarkData { parent: parent, modern: false, expn_info: None });\n             Mark(data.marks.len() as u32 - 1)\n         })\n     }\n@@ -59,29 +67,59 @@ impl Mark {\n     }\n \n     pub fn expn_info(self) -> Option<ExpnInfo> {\n-        HygieneData::with(|data| data.marks[self.0 as usize].clone())\n+        HygieneData::with(|data| data.marks[self.0 as usize].expn_info.clone())\n     }\n \n     pub fn set_expn_info(self, info: ExpnInfo) {\n-        HygieneData::with(|data| data.marks[self.0 as usize] = Some(info))\n+        HygieneData::with(|data| data.marks[self.0 as usize].expn_info = Some(info))\n+    }\n+\n+    pub fn modern(mut self) -> Mark {\n+        HygieneData::with(|data| {\n+            loop {\n+                if self == Mark::root() || data.marks[self.0 as usize].modern {\n+                    return self;\n+                }\n+                self = data.marks[self.0 as usize].parent;\n+            }\n+        })\n+    }\n+\n+    pub fn is_modern(self) -> bool {\n+        HygieneData::with(|data| data.marks[self.0 as usize].modern)\n+    }\n+\n+    pub fn set_modern(self) {\n+        HygieneData::with(|data| data.marks[self.0 as usize].modern = true)\n+    }\n+\n+    pub fn is_descendant_of(mut self, ancestor: Mark) -> bool {\n+        HygieneData::with(|data| {\n+            while self != ancestor {\n+                if self == Mark::root() {\n+                    return false;\n+                }\n+                self = data.marks[self.0 as usize].parent;\n+            }\n+            true\n+        })\n     }\n }\n \n struct HygieneData {\n-    marks: Vec<Option<ExpnInfo>>,\n+    marks: Vec<MarkData>,\n     syntax_contexts: Vec<SyntaxContextData>,\n     markings: HashMap<(SyntaxContext, Mark), SyntaxContext>,\n+    gensym_to_ctxt: HashMap<Symbol, SyntaxContext>,\n }\n \n impl HygieneData {\n     fn new() -> Self {\n         HygieneData {\n-            marks: vec![None],\n-            syntax_contexts: vec![SyntaxContextData {\n-                outer_mark: Mark::root(),\n-                prev_ctxt: SyntaxContext::empty(),\n-            }],\n+            marks: vec![MarkData::default()],\n+            syntax_contexts: vec![SyntaxContextData::default()],\n             markings: HashMap::new(),\n+            gensym_to_ctxt: HashMap::new(),\n         }\n     }\n \n@@ -102,30 +140,146 @@ impl SyntaxContext {\n         SyntaxContext(0)\n     }\n \n-    pub fn data(self) -> SyntaxContextData {\n-        HygieneData::with(|data| data.syntax_contexts[self.0 as usize])\n-    }\n-\n     /// Extend a syntax context with a given mark\n     pub fn apply_mark(self, mark: Mark) -> SyntaxContext {\n-        // Applying the same mark twice is a no-op\n-        let ctxt_data = self.data();\n-        if mark == ctxt_data.outer_mark {\n-            return ctxt_data.prev_ctxt;\n-        }\n-\n         HygieneData::with(|data| {\n             let syntax_contexts = &mut data.syntax_contexts;\n+            let ctxt_data = syntax_contexts[self.0 as usize];\n+            if mark == ctxt_data.outer_mark {\n+                return ctxt_data.prev_ctxt;\n+            }\n+\n+            let modern = if data.marks[mark.0 as usize].modern {\n+                *data.markings.entry((ctxt_data.modern, mark)).or_insert_with(|| {\n+                    let modern = SyntaxContext(syntax_contexts.len() as u32);\n+                    syntax_contexts.push(SyntaxContextData {\n+                        outer_mark: mark,\n+                        prev_ctxt: ctxt_data.modern,\n+                        modern: modern,\n+                    });\n+                    modern\n+                })\n+            } else {\n+                ctxt_data.modern\n+            };\n+\n             *data.markings.entry((self, mark)).or_insert_with(|| {\n                 syntax_contexts.push(SyntaxContextData {\n                     outer_mark: mark,\n                     prev_ctxt: self,\n+                    modern: modern,\n                 });\n                 SyntaxContext(syntax_contexts.len() as u32 - 1)\n             })\n         })\n     }\n \n+    pub fn remove_mark(&mut self) -> Mark {\n+        HygieneData::with(|data| {\n+            let outer_mark = data.syntax_contexts[self.0 as usize].outer_mark;\n+            *self = data.syntax_contexts[self.0 as usize].prev_ctxt;\n+            outer_mark\n+        })\n+    }\n+\n+    /// Adjust this context for resolution in a scope created by the given expansion.\n+    /// For example, consider the following three resolutions of `f`:\n+    /// ```rust\n+    /// mod foo { pub fn f() {} } // `f`'s `SyntaxContext` is empty.\n+    /// m!(f);\n+    /// macro m($f:ident) {\n+    ///     mod bar {\n+    ///         pub fn f() {} // `f`'s `SyntaxContext` has a single `Mark` from `m`.\n+    ///         pub fn $f() {} // `$f`'s `SyntaxContext` is empty.\n+    ///     }\n+    ///     foo::f(); // `f`'s `SyntaxContext` has a single `Mark` from `m`\n+    ///     //^ Since `mod foo` is outside this expansion, `adjust` removes the mark from `f`,\n+    ///     //| and it resolves to `::foo::f`.\n+    ///     bar::f(); // `f`'s `SyntaxContext` has a single `Mark` from `m`\n+    ///     //^ Since `mod bar` not outside this expansion, `adjust` does not change `f`,\n+    ///     //| and it resolves to `::bar::f`.\n+    ///     bar::$f(); // `f`'s `SyntaxContext` is empty.\n+    ///     //^ Since `mod bar` is not outside this expansion, `adjust` does not change `$f`,\n+    ///     //| and it resolves to `::bar::$f`.\n+    /// }\n+    /// ```\n+    /// This returns the expansion whose definition scope we use to privacy check the resolution,\n+    /// or `None` if we privacy check as usual (i.e. not w.r.t. a macro definition scope).\n+    pub fn adjust(&mut self, expansion: Mark) -> Option<Mark> {\n+        let mut scope = None;\n+        while !expansion.is_descendant_of(self.outer()) {\n+            scope = Some(self.remove_mark());\n+        }\n+        scope\n+    }\n+\n+    /// Adjust this context for resolution in a scope created by the given expansion\n+    /// via a glob import with the given `SyntaxContext`.\n+    /// For example,\n+    /// ```rust\n+    /// m!(f);\n+    /// macro m($i:ident) {\n+    ///     mod foo {\n+    ///         pub fn f() {} // `f`'s `SyntaxContext` has a single `Mark` from `m`.\n+    ///         pub fn $i() {} // `$i`'s `SyntaxContext` is empty.\n+    ///     }\n+    ///     n(f);\n+    ///     macro n($j:ident) {\n+    ///         use foo::*;\n+    ///         f(); // `f`'s `SyntaxContext` has a mark from `m` and a mark from `n`\n+    ///         //^ `glob_adjust` removes the mark from `n`, so this resolves to `foo::f`.\n+    ///         $i(); // `$i`'s `SyntaxContext` has a mark from `n`\n+    ///         //^ `glob_adjust` removes the mark from `n`, so this resolves to `foo::$i`.\n+    ///         $j(); // `$j`'s `SyntaxContext` has a mark from `m`\n+    ///         //^ This cannot be glob-adjusted, so this is a resolution error.\n+    ///     }\n+    /// }\n+    /// ```\n+    /// This returns `None` if the context cannot be glob-adjusted.\n+    /// Otherwise, it returns the scope to use when privacy checking (see `adjust` for details).\n+    pub fn glob_adjust(&mut self, expansion: Mark, mut glob_ctxt: SyntaxContext)\n+                       -> Option<Option<Mark>> {\n+        let mut scope = None;\n+        while !expansion.is_descendant_of(glob_ctxt.outer()) {\n+            scope = Some(glob_ctxt.remove_mark());\n+            if self.remove_mark() != scope.unwrap() {\n+                return None;\n+            }\n+        }\n+        if self.adjust(expansion).is_some() {\n+            return None;\n+        }\n+        Some(scope)\n+    }\n+\n+    /// Undo `glob_adjust` if possible:\n+    /// ```rust\n+    /// if let Some(privacy_checking_scope) = self.reverse_glob_adjust(expansion, glob_ctxt) {\n+    ///     assert!(self.glob_adjust(expansion, glob_ctxt) == Some(privacy_checking_scope));\n+    /// }\n+    /// ```\n+    pub fn reverse_glob_adjust(&mut self, expansion: Mark, mut glob_ctxt: SyntaxContext)\n+                               -> Option<Option<Mark>> {\n+        if self.adjust(expansion).is_some() {\n+            return None;\n+        }\n+\n+        let mut marks = Vec::new();\n+        while !expansion.is_descendant_of(glob_ctxt.outer()) {\n+            marks.push(glob_ctxt.remove_mark());\n+        }\n+\n+        let scope = marks.last().cloned();\n+        while let Some(mark) = marks.pop() {\n+            *self = self.apply_mark(mark);\n+        }\n+        Some(scope)\n+    }\n+\n+    pub fn modern(self) -> SyntaxContext {\n+        HygieneData::with(|data| data.syntax_contexts[self.0 as usize].modern)\n+    }\n+\n     pub fn outer(self) -> Mark {\n         HygieneData::with(|data| data.syntax_contexts[self.0 as usize].outer_mark)\n     }\n@@ -200,3 +354,22 @@ impl Decodable for SyntaxContext {\n         Ok(SyntaxContext::empty()) // FIXME(jseyfried) intercrate hygiene\n     }\n }\n+\n+impl Symbol {\n+    pub fn from_ident(ident: Ident) -> Symbol {\n+        HygieneData::with(|data| {\n+            let gensym = ident.name.gensymed();\n+            data.gensym_to_ctxt.insert(gensym, ident.ctxt);\n+            gensym\n+        })\n+    }\n+\n+    pub fn to_ident(self) -> Ident {\n+        HygieneData::with(|data| {\n+            match data.gensym_to_ctxt.get(&self) {\n+                Some(&ctxt) => Ident { name: self.interned(), ctxt: ctxt },\n+                None => Ident::with_empty_ctxt(self),\n+            }\n+        })\n+    }\n+}"}, {"sha": "73c0256f2c1f50babdde07d8a7a5c8c6e0e8f196", "filename": "src/libsyntax_pos/symbol.rs", "status": "modified", "additions": 47, "deletions": 14, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/4f9c9ed1a53d176fb0650042f226222f401c21eb/src%2Flibsyntax_pos%2Fsymbol.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f9c9ed1a53d176fb0650042f226222f401c21eb/src%2Flibsyntax_pos%2Fsymbol.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_pos%2Fsymbol.rs?ref=4f9c9ed1a53d176fb0650042f226222f401c21eb", "patch": "@@ -35,8 +35,8 @@ impl Ident {\n         Ident::with_empty_ctxt(Symbol::intern(string))\n     }\n \n-    pub fn unhygienize(self) -> Ident {\n-        Ident { name: self.name, ctxt: SyntaxContext::empty() }\n+    pub fn modern(self) -> Ident {\n+        Ident { name: self.name, ctxt: self.ctxt.modern() }\n     }\n }\n \n@@ -54,13 +54,24 @@ impl fmt::Display for Ident {\n \n impl Encodable for Ident {\n     fn encode<S: Encoder>(&self, s: &mut S) -> Result<(), S::Error> {\n-        self.name.encode(s)\n+        if self.ctxt.modern() == SyntaxContext::empty() {\n+            s.emit_str(&self.name.as_str())\n+        } else { // FIXME(jseyfried) intercrate hygiene\n+            let mut string = \"#\".to_owned();\n+            string.push_str(&self.name.as_str());\n+            s.emit_str(&string)\n+        }\n     }\n }\n \n impl Decodable for Ident {\n     fn decode<D: Decoder>(d: &mut D) -> Result<Ident, D::Error> {\n-        Ok(Ident::with_empty_ctxt(Symbol::decode(d)?))\n+        let string = d.read_str()?;\n+        Ok(if !string.starts_with('#') {\n+            Ident::from_str(&string)\n+        } else { // FIXME(jseyfried) intercrate hygiene\n+            Ident::with_empty_ctxt(Symbol::gensym(&string[1..]))\n+        })\n     }\n }\n \n@@ -77,11 +88,19 @@ impl Symbol {\n         with_interner(|interner| interner.intern(string))\n     }\n \n+    pub fn interned(self) -> Self {\n+        with_interner(|interner| interner.interned(self))\n+    }\n+\n     /// gensym's a new usize, using the current interner.\n     pub fn gensym(string: &str) -> Self {\n         with_interner(|interner| interner.gensym(string))\n     }\n \n+    pub fn gensymed(self) -> Self {\n+        with_interner(|interner| interner.gensymed(self))\n+    }\n+\n     pub fn as_str(self) -> InternedString {\n         with_interner(|interner| unsafe {\n             InternedString {\n@@ -129,6 +148,7 @@ impl<T: ::std::ops::Deref<Target=str>> PartialEq<T> for Symbol {\n pub struct Interner {\n     names: HashMap<Box<str>, Symbol>,\n     strings: Vec<Box<str>>,\n+    gensyms: Vec<Symbol>,\n }\n \n impl Interner {\n@@ -156,15 +176,29 @@ impl Interner {\n         name\n     }\n \n+    pub fn interned(&self, symbol: Symbol) -> Symbol {\n+        if (symbol.0 as usize) < self.strings.len() {\n+            symbol\n+        } else {\n+            self.interned(self.gensyms[(!0 - symbol.0) as usize])\n+        }\n+    }\n+\n     fn gensym(&mut self, string: &str) -> Symbol {\n-        let gensym = Symbol(self.strings.len() as u32);\n-        // leave out of `names` to avoid colliding\n-        self.strings.push(string.to_string().into_boxed_str());\n-        gensym\n+        let symbol = self.intern(string);\n+        self.gensymed(symbol)\n     }\n \n-    pub fn get(&self, name: Symbol) -> &str {\n-        &self.strings[name.0 as usize]\n+    fn gensymed(&mut self, symbol: Symbol) -> Symbol {\n+        self.gensyms.push(symbol);\n+        Symbol(!0 - self.gensyms.len() as u32 + 1)\n+    }\n+\n+    pub fn get(&self, symbol: Symbol) -> &str {\n+        match self.strings.get(symbol.0 as usize) {\n+            Some(ref string) => string,\n+            None => self.get(self.gensyms[(!0 - symbol.0) as usize]),\n+        }\n     }\n }\n \n@@ -379,11 +413,10 @@ mod tests {\n         assert_eq!(i.intern(\"cat\"), Symbol(1));\n         // dog is still at zero\n         assert_eq!(i.intern(\"dog\"), Symbol(0));\n-        // gensym gets 3\n-        assert_eq!(i.gensym(\"zebra\"), Symbol(2));\n+        assert_eq!(i.gensym(\"zebra\"), Symbol(4294967295));\n         // gensym of same string gets new number :\n-        assert_eq!(i.gensym(\"zebra\"), Symbol(3));\n+        assert_eq!(i.gensym(\"zebra\"), Symbol(4294967294));\n         // gensym of *existing* string gets new number:\n-        assert_eq!(i.gensym(\"dog\"), Symbol(4));\n+        assert_eq!(i.gensym(\"dog\"), Symbol(4294967293));\n     }\n }"}, {"sha": "af7d5fec07199d4c125fa03fc0bebaa685273518", "filename": "src/test/compile-fail/feature-gate-decl_macro.rs", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/4f9c9ed1a53d176fb0650042f226222f401c21eb/src%2Ftest%2Fcompile-fail%2Ffeature-gate-decl_macro.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f9c9ed1a53d176fb0650042f226222f401c21eb/src%2Ftest%2Fcompile-fail%2Ffeature-gate-decl_macro.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ffeature-gate-decl_macro.rs?ref=4f9c9ed1a53d176fb0650042f226222f401c21eb", "patch": "@@ -0,0 +1,14 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+macro m() {} //~ ERROR `macro` is experimental (see issue #39412)\n+//~| HELP add #![feature(decl_macro)] to the crate attributes to enable\n+\n+fn main() {}"}, {"sha": "7ba217061c66ee986911556a844bc7a0a52b94a0", "filename": "src/test/compile-fail/hygiene/globs.rs", "status": "added", "additions": 68, "deletions": 0, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/4f9c9ed1a53d176fb0650042f226222f401c21eb/src%2Ftest%2Fcompile-fail%2Fhygiene%2Fglobs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f9c9ed1a53d176fb0650042f226222f401c21eb/src%2Ftest%2Fcompile-fail%2Fhygiene%2Fglobs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fhygiene%2Fglobs.rs?ref=4f9c9ed1a53d176fb0650042f226222f401c21eb", "patch": "@@ -0,0 +1,68 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(decl_macro)]\n+\n+mod foo {\n+    pub fn f() {}\n+}\n+\n+mod bar {\n+    pub fn g() {}\n+}\n+\n+macro m($($t:tt)*) {\n+    $($t)*\n+    use foo::*;\n+    f();\n+    g(); //~ ERROR cannot find function `g` in this scope\n+}\n+\n+fn main() {\n+    m! {\n+        use bar::*;\n+        g();\n+        f(); //~ ERROR cannot find function `f` in this scope\n+    }\n+}\n+\n+n!(f);\n+macro n($i:ident) {\n+    mod foo {\n+        pub fn $i() -> u32 { 0 }\n+        pub fn f() {}\n+\n+        mod test {\n+            use super::*;\n+            fn g() {\n+                let _: u32 = $i();\n+                let _: () = f();\n+            }\n+        }\n+\n+        macro n($j:ident) {\n+            mod test {\n+                use super::*;\n+                fn g() {\n+                    let _: u32 = $i();\n+                    let _: () = f();\n+                    $j();\n+                }\n+            }\n+        }\n+\n+        n!(f);\n+        mod test2 {\n+            super::n! {\n+                f //~ ERROR cannot find function `f` in this scope\n+            }\n+        }\n+    }\n+}"}, {"sha": "6612359649c194cd660655ff18126b038db90ebd", "filename": "src/test/compile-fail/hygiene/nested_macro_privacy.rs", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/4f9c9ed1a53d176fb0650042f226222f401c21eb/src%2Ftest%2Fcompile-fail%2Fhygiene%2Fnested_macro_privacy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f9c9ed1a53d176fb0650042f226222f401c21eb/src%2Ftest%2Fcompile-fail%2Fhygiene%2Fnested_macro_privacy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fhygiene%2Fnested_macro_privacy.rs?ref=4f9c9ed1a53d176fb0650042f226222f401c21eb", "patch": "@@ -0,0 +1,27 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(decl_macro)]\n+\n+macro n($foo:ident, $S:ident, $i:ident, $m:ident) {\n+    mod $foo {\n+        #[derive(Default)]\n+        pub struct $S { $i: u32 }\n+        pub macro $m($e:expr) { $e.$i }\n+    }\n+}\n+\n+n!(foo, S, i, m);\n+\n+fn main() {\n+    use foo::{S, m};\n+    S::default().i; //~ ERROR field `i` of struct `foo::S` is private\n+    m!(S::default()); // ok\n+}"}, {"sha": "c90c7b3093c9f0e5d04a15371b082d4cf05dbf38", "filename": "src/test/compile-fail/hygiene/no_implicit_prelude.rs", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/4f9c9ed1a53d176fb0650042f226222f401c21eb/src%2Ftest%2Fcompile-fail%2Fhygiene%2Fno_implicit_prelude.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f9c9ed1a53d176fb0650042f226222f401c21eb/src%2Ftest%2Fcompile-fail%2Fhygiene%2Fno_implicit_prelude.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fhygiene%2Fno_implicit_prelude.rs?ref=4f9c9ed1a53d176fb0650042f226222f401c21eb", "patch": "@@ -0,0 +1,25 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(decl_macro)]\n+\n+mod foo {\n+    pub macro m() { Vec::new(); ().clone() }\n+    fn f() { ::bar::m!(); }\n+}\n+\n+#[no_implicit_prelude]\n+mod bar {\n+    pub macro m() {\n+        Vec::new(); //~ ERROR failed to resolve\n+        ().clone() //~ ERROR no method named `clone` found\n+    }\n+    fn f() { ::foo::m!(); }\n+}"}, {"sha": "987cad187d428c7dcf719df625bc4ec736a3f755", "filename": "src/test/compile-fail/hygiene/privacy.rs", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/4f9c9ed1a53d176fb0650042f226222f401c21eb/src%2Ftest%2Fcompile-fail%2Fhygiene%2Fprivacy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f9c9ed1a53d176fb0650042f226222f401c21eb/src%2Ftest%2Fcompile-fail%2Fhygiene%2Fprivacy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fhygiene%2Fprivacy.rs?ref=4f9c9ed1a53d176fb0650042f226222f401c21eb", "patch": "@@ -0,0 +1,28 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(decl_macro)]\n+\n+mod foo {\n+    fn f() {}\n+\n+    pub macro m($e:expr) {\n+        f();\n+        self::f();\n+        ::foo::f();\n+        $e\n+    }\n+}\n+\n+fn main() {\n+    foo::m!(\n+        foo::f() //~ ERROR `f` is private\n+    );\n+}"}, {"sha": "3bd19cbc0ac67cbf48b4138d0118a906bc799d05", "filename": "src/test/compile-fail/hygiene/trait_items.rs", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/4f9c9ed1a53d176fb0650042f226222f401c21eb/src%2Ftest%2Fcompile-fail%2Fhygiene%2Ftrait_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f9c9ed1a53d176fb0650042f226222f401c21eb/src%2Ftest%2Fcompile-fail%2Fhygiene%2Ftrait_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fhygiene%2Ftrait_items.rs?ref=4f9c9ed1a53d176fb0650042f226222f401c21eb", "patch": "@@ -0,0 +1,31 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(decl_macro)]\n+\n+mod foo {\n+    pub trait T {\n+        fn f(&self) {}\n+    }\n+    impl T for () {}\n+}\n+\n+mod bar {\n+    use foo::*;\n+    pub macro m() { ().f() }\n+    fn f() { ::baz::m!(); }\n+}\n+\n+mod baz {\n+    pub macro m() { ().f() } //~ ERROR no method named `f` found for type `()` in the current scope\n+    fn f() { ::bar::m!(); }\n+}\n+\n+fn main() {}"}, {"sha": "5d9e1863847da1d868157837bbadee68e4541c35", "filename": "src/test/run-pass/hygiene/arguments.rs", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/4f9c9ed1a53d176fb0650042f226222f401c21eb/src%2Ftest%2Frun-pass%2Fhygiene%2Farguments.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f9c9ed1a53d176fb0650042f226222f401c21eb/src%2Ftest%2Frun-pass%2Fhygiene%2Farguments.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fhygiene%2Farguments.rs?ref=4f9c9ed1a53d176fb0650042f226222f401c21eb", "patch": "@@ -0,0 +1,27 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// ignore-pretty pretty-printing is unhygienic\n+\n+#![feature(decl_macro)]\n+\n+macro m($t:ty, $e:expr) {\n+    mod foo {\n+        #[allow(unused)]\n+        struct S;\n+        pub(super) fn f(_: $t) {}\n+    }\n+    foo::f($e);\n+}\n+\n+fn main() {\n+    struct S;\n+    m!(S, S);\n+}"}, {"sha": "aa67e5c5f4db7bcaf1d43feb2d228b63982cca6e", "filename": "src/test/run-pass/hygiene/auxiliary/intercrate.rs", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/4f9c9ed1a53d176fb0650042f226222f401c21eb/src%2Ftest%2Frun-pass%2Fhygiene%2Fauxiliary%2Fintercrate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f9c9ed1a53d176fb0650042f226222f401c21eb/src%2Ftest%2Frun-pass%2Fhygiene%2Fauxiliary%2Fintercrate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fhygiene%2Fauxiliary%2Fintercrate.rs?ref=4f9c9ed1a53d176fb0650042f226222f401c21eb", "patch": "@@ -0,0 +1,21 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(decl_macro)]\n+\n+pub mod foo {\n+    pub use self::bar::m;\n+    mod bar {\n+        fn f() -> u32 { 1 }\n+        pub macro m() {\n+            f();\n+        }\n+    }\n+}"}, {"sha": "d7f99ba2118e87f908f2d4a168f14cb67c724db0", "filename": "src/test/run-pass/hygiene/fields.rs", "status": "added", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/4f9c9ed1a53d176fb0650042f226222f401c21eb/src%2Ftest%2Frun-pass%2Fhygiene%2Ffields.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f9c9ed1a53d176fb0650042f226222f401c21eb/src%2Ftest%2Frun-pass%2Fhygiene%2Ffields.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fhygiene%2Ffields.rs?ref=4f9c9ed1a53d176fb0650042f226222f401c21eb", "patch": "@@ -0,0 +1,40 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// ignore-pretty pretty-printing is unhygienic\n+\n+#![feature(decl_macro)]\n+\n+mod foo {\n+    struct S { x: u32 }\n+    struct T(u32);\n+\n+    pub macro m($S:ident, $x:ident) {{\n+        struct $S {\n+            $x: u32,\n+            x: i32,\n+        }\n+\n+        let s = S { x: 0 };\n+        let _ = s.x;\n+\n+        let t = T(0);\n+        let _ = t.0;\n+\n+        let s = $S { $x: 0, x: 1 };\n+        assert_eq!((s.$x, s.x), (0, 1));\n+        s\n+    }}\n+}\n+\n+fn main() {\n+    let s = foo::m!(S, x);\n+    assert_eq!(s.x, 0);\n+}"}, {"sha": "a5780a573aba19961024821a6ade12a1bf532a2f", "filename": "src/test/run-pass/hygiene/impl_items.rs", "status": "added", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/4f9c9ed1a53d176fb0650042f226222f401c21eb/src%2Ftest%2Frun-pass%2Fhygiene%2Fimpl_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f9c9ed1a53d176fb0650042f226222f401c21eb/src%2Ftest%2Frun-pass%2Fhygiene%2Fimpl_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fhygiene%2Fimpl_items.rs?ref=4f9c9ed1a53d176fb0650042f226222f401c21eb", "patch": "@@ -0,0 +1,44 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// ignore-pretty pretty-printing is unhygienic\n+\n+#![feature(decl_macro)]\n+\n+mod foo {\n+    struct S;\n+    impl S {\n+        fn f(&self) {}\n+    }\n+\n+    pub macro m() {\n+        let _: () = S.f();\n+    }\n+}\n+\n+struct S;\n+\n+macro m($f:ident) {\n+    impl S {\n+        fn f(&self) -> u32 { 0 }\n+        fn $f(&self) -> i32 { 0 }\n+    }\n+    fn f() {\n+        let _: u32 = S.f();\n+        let _: i32 = S.$f();\n+    }\n+}\n+\n+m!(f);\n+\n+fn main() {\n+    let _: i32 = S.f();\n+    foo::m!();\n+}"}, {"sha": "3a75085f22e4e09cda3546e0e5e6daac98138326", "filename": "src/test/run-pass/hygiene/intercrate.rs", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/4f9c9ed1a53d176fb0650042f226222f401c21eb/src%2Ftest%2Frun-pass%2Fhygiene%2Fintercrate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f9c9ed1a53d176fb0650042f226222f401c21eb/src%2Ftest%2Frun-pass%2Fhygiene%2Fintercrate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fhygiene%2Fintercrate.rs?ref=4f9c9ed1a53d176fb0650042f226222f401c21eb", "patch": "@@ -0,0 +1,21 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// ignore-pretty pretty-printing is unhygienic\n+\n+// aux-build:intercrate.rs\n+\n+#![feature(decl_macro)]\n+\n+extern crate intercrate;\n+\n+fn main() {\n+    assert_eq!(intercrate::foo::m!(), 1);\n+}"}, {"sha": "121c341a124ce5620c8ee8ba15135c6a45ea100e", "filename": "src/test/run-pass/hygiene/items.rs", "status": "added", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/4f9c9ed1a53d176fb0650042f226222f401c21eb/src%2Ftest%2Frun-pass%2Fhygiene%2Fitems.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f9c9ed1a53d176fb0650042f226222f401c21eb/src%2Ftest%2Frun-pass%2Fhygiene%2Fitems.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fhygiene%2Fitems.rs?ref=4f9c9ed1a53d176fb0650042f226222f401c21eb", "patch": "@@ -0,0 +1,36 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// ignore-pretty pretty-printing is unhygienic\n+\n+#![feature(decl_macro)]\n+\n+pub macro m($foo:ident, $f:ident, $e:expr) {\n+    mod foo {\n+        pub fn f() -> u32 { 0 }\n+        pub fn $f() -> u64 { 0 }\n+    }\n+\n+    mod $foo {\n+        pub fn f() -> i32 { 0 }\n+        pub fn $f() -> i64 { 0  }\n+    }\n+\n+    let _: u32 = foo::f();\n+    let _: u64 = foo::$f();\n+    let _: i32 = $foo::f();\n+    let _: i64 = $foo::$f();\n+    let _: i64 = $e;\n+}\n+\n+fn main() {\n+    m!(foo, f, foo::f());\n+    let _: i64 = foo::f();\n+}"}, {"sha": "cb02a17fec38a00298c6664ff864019f7f4d1308", "filename": "src/test/run-pass/hygiene/lexical.rs", "status": "added", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/4f9c9ed1a53d176fb0650042f226222f401c21eb/src%2Ftest%2Frun-pass%2Fhygiene%2Flexical.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f9c9ed1a53d176fb0650042f226222f401c21eb/src%2Ftest%2Frun-pass%2Fhygiene%2Flexical.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fhygiene%2Flexical.rs?ref=4f9c9ed1a53d176fb0650042f226222f401c21eb", "patch": "@@ -0,0 +1,33 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// ignore-pretty pretty-printing is unhygienic\n+\n+#![feature(decl_macro)]\n+\n+mod bar {\n+    mod baz {\n+        pub fn f() {}\n+    }\n+\n+    pub macro m($f:ident) {\n+        baz::f();\n+        let _: i32 = $f();\n+        {\n+            fn $f() -> u32 { 0 }\n+            let _: u32 = $f();\n+        }\n+    }\n+}\n+\n+fn main() {\n+    fn f() -> i32 { 0 }\n+    bar::m!(f);\n+}"}, {"sha": "2344c97ce1b1c34fbe3733031487656bc0298157", "filename": "src/test/run-pass/hygiene/trait_items.rs", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/4f9c9ed1a53d176fb0650042f226222f401c21eb/src%2Ftest%2Frun-pass%2Fhygiene%2Ftrait_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f9c9ed1a53d176fb0650042f226222f401c21eb/src%2Ftest%2Frun-pass%2Fhygiene%2Ftrait_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fhygiene%2Ftrait_items.rs?ref=4f9c9ed1a53d176fb0650042f226222f401c21eb", "patch": "@@ -0,0 +1,29 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// ignore-pretty pretty-printing is unhygienic\n+\n+#![feature(decl_macro)]\n+\n+macro m($T:ident, $f:ident) {\n+    pub trait $T {\n+        fn f(&self) -> u32 { 0 }\n+        fn $f(&self) -> i32 { 0 }\n+    }\n+    impl $T for () {}\n+\n+    let _: u32 = ().f();\n+    let _: i32 = ().$f();\n+}\n+\n+fn main() {\n+    m!(T, f);\n+    let _: i32 = ().f();\n+}"}, {"sha": "510528ede40c5e668f3ec500e3879ac3b6f25c3a", "filename": "src/test/run-pass/hygiene/ty_params.rs", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/4f9c9ed1a53d176fb0650042f226222f401c21eb/src%2Ftest%2Frun-pass%2Fhygiene%2Fty_params.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f9c9ed1a53d176fb0650042f226222f401c21eb/src%2Ftest%2Frun-pass%2Fhygiene%2Fty_params.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fhygiene%2Fty_params.rs?ref=4f9c9ed1a53d176fb0650042f226222f401c21eb", "patch": "@@ -0,0 +1,23 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// ignore-pretty pretty-printing is unhygienic\n+\n+#![feature(decl_macro)]\n+\n+macro m($T:ident) {\n+    fn f<T, $T>(t: T, t2: $T) -> (T, $T) {\n+        (t, t2)\n+    }\n+}\n+\n+m!(T);\n+\n+fn main() {}"}]}