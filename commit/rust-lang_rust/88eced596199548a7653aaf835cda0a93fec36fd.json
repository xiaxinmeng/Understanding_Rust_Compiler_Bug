{"sha": "88eced596199548a7653aaf835cda0a93fec36fd", "node_id": "MDY6Q29tbWl0NzI0NzEyOjg4ZWNlZDU5NjE5OTU0OGE3NjUzYWFmODM1Y2RhMGE5M2ZlYzM2ZmQ=", "commit": {"author": {"name": "Eduard-Mihai Burtescu", "email": "edy.burt@gmail.com", "date": "2019-07-15T15:21:01Z"}, "committer": {"name": "Eduard-Mihai Burtescu", "email": "edy.burt@gmail.com", "date": "2019-07-15T15:41:24Z"}, "message": "rustc: precompute the largest Niche and store it in LayoutDetails.", "tree": {"sha": "3a7ea71f58682f1d16123e65ee7148f344c3b135", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3a7ea71f58682f1d16123e65ee7148f344c3b135"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/88eced596199548a7653aaf835cda0a93fec36fd", "comment_count": 3, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/88eced596199548a7653aaf835cda0a93fec36fd", "html_url": "https://github.com/rust-lang/rust/commit/88eced596199548a7653aaf835cda0a93fec36fd", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/88eced596199548a7653aaf835cda0a93fec36fd/comments", "author": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "committer": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "dfbf4646f74a120fe736599faa81643a78aaf029", "url": "https://api.github.com/repos/rust-lang/rust/commits/dfbf4646f74a120fe736599faa81643a78aaf029", "html_url": "https://github.com/rust-lang/rust/commit/dfbf4646f74a120fe736599faa81643a78aaf029"}], "stats": {"total": 210, "additions": 120, "deletions": 90}, "files": [{"sha": "3b4b814c92a90fff9d37846b58db408df5af67bc", "filename": "src/librustc/ty/layout.rs", "status": "modified", "additions": 100, "deletions": 90, "changes": 190, "blob_url": "https://github.com/rust-lang/rust/blob/88eced596199548a7653aaf835cda0a93fec36fd/src%2Flibrustc%2Fty%2Flayout.rs", "raw_url": "https://github.com/rust-lang/rust/raw/88eced596199548a7653aaf835cda0a93fec36fd/src%2Flibrustc%2Fty%2Flayout.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Flayout.rs?ref=88eced596199548a7653aaf835cda0a93fec36fd", "patch": "@@ -246,13 +246,22 @@ impl<'tcx> LayoutCx<'tcx, TyCtxt<'tcx>> {\n         let align = a.value.align(dl).max(b_align).max(dl.aggregate_align);\n         let b_offset = a.value.size(dl).align_to(b_align.abi);\n         let size = (b_offset + b.value.size(dl)).align_to(align.abi);\n+\n+        // HACK(nox): We iter on `b` and then `a` because `max_by_key`\n+        // returns the last maximum.\n+        let largest_niche = Niche::from_scalar(dl, b_offset, b.clone())\n+            .into_iter()\n+            .chain(Niche::from_scalar(dl, Size::ZERO, a.clone()))\n+            .max_by_key(|niche| niche.available(dl));\n+\n         LayoutDetails {\n             variants: Variants::Single { index: VariantIdx::new(0) },\n             fields: FieldPlacement::Arbitrary {\n                 offsets: vec![Size::ZERO, b_offset],\n                 memory_index: vec![0, 1]\n             },\n             abi: Abi::ScalarPair(a, b),\n+            largest_niche,\n             align,\n             size\n         }\n@@ -321,6 +330,8 @@ impl<'tcx> LayoutCx<'tcx, TyCtxt<'tcx>> {\n \n \n         let mut offset = Size::ZERO;\n+        let mut largest_niche = None;\n+        let mut largest_niche_available = 0;\n \n         if let StructKind::Prefixed(prefix_size, prefix_align) = kind {\n             let prefix_align = if packed {\n@@ -355,6 +366,15 @@ impl<'tcx> LayoutCx<'tcx, TyCtxt<'tcx>> {\n             debug!(\"univariant offset: {:?} field: {:#?}\", offset, field);\n             offsets[i as usize] = offset;\n \n+            if let Some(mut niche) = field.largest_niche.clone() {\n+                let available = niche.available(dl);\n+                if available > largest_niche_available {\n+                    largest_niche_available = available;\n+                    niche.offset += offset;\n+                    largest_niche = Some(niche);\n+                }\n+            }\n+\n             offset = offset.checked_add(field.size, dl)\n                 .ok_or(LayoutError::SizeOverflow(ty))?;\n         }\n@@ -466,6 +486,7 @@ impl<'tcx> LayoutCx<'tcx, TyCtxt<'tcx>> {\n                 memory_index\n             },\n             abi,\n+            largest_niche,\n             align,\n             size\n         })\n@@ -525,6 +546,7 @@ impl<'tcx> LayoutCx<'tcx, TyCtxt<'tcx>> {\n                     variants: Variants::Single { index: VariantIdx::new(0) },\n                     fields: FieldPlacement::Union(0),\n                     abi: Abi::Uninhabited,\n+                    largest_niche: None,\n                     align: dl.i8_align,\n                     size: Size::ZERO\n                 })\n@@ -583,13 +605,20 @@ impl<'tcx> LayoutCx<'tcx, TyCtxt<'tcx>> {\n                     Abi::Aggregate { sized: true }\n                 };\n \n+                let largest_niche = if count != 0 {\n+                    element.largest_niche.clone()\n+                } else {\n+                    None\n+                };\n+\n                 tcx.intern_layout(LayoutDetails {\n                     variants: Variants::Single { index: VariantIdx::new(0) },\n                     fields: FieldPlacement::Array {\n                         stride: element.size,\n                         count\n                     },\n                     abi,\n+                    largest_niche,\n                     align: element.align,\n                     size\n                 })\n@@ -603,6 +632,7 @@ impl<'tcx> LayoutCx<'tcx, TyCtxt<'tcx>> {\n                         count: 0\n                     },\n                     abi: Abi::Aggregate { sized: false },\n+                    largest_niche: None,\n                     align: element.align,\n                     size: Size::ZERO\n                 })\n@@ -615,6 +645,7 @@ impl<'tcx> LayoutCx<'tcx, TyCtxt<'tcx>> {\n                         count: 0\n                     },\n                     abi: Abi::Aggregate { sized: false },\n+                    largest_niche: None,\n                     align: dl.i8_align,\n                     size: Size::ZERO\n                 })\n@@ -683,6 +714,7 @@ impl<'tcx> LayoutCx<'tcx, TyCtxt<'tcx>> {\n                         element: scalar,\n                         count\n                     },\n+                    largest_niche: element.largest_niche.clone(),\n                     size,\n                     align,\n                 })\n@@ -768,6 +800,7 @@ impl<'tcx> LayoutCx<'tcx, TyCtxt<'tcx>> {\n                         variants: Variants::Single { index },\n                         fields: FieldPlacement::Union(variants[index].len()),\n                         abi,\n+                        largest_niche: None,\n                         align,\n                         size: size.align_to(align.abi)\n                     }));\n@@ -829,14 +862,38 @@ impl<'tcx> LayoutCx<'tcx, TyCtxt<'tcx>> {\n                             // `#[rustc_layout_scalar_valid_range(n)]`\n                             // attribute to widen the range of anything as that would probably\n                             // result in UB somewhere\n+                            // FIXME(eddyb) the asserts are probably not needed,\n+                            // as larger validity ranges would result in missed\n+                            // optimizations, *not* wrongly assuming the inner\n+                            // value is valid. e.g. unions enlarge validity ranges,\n+                            // because the values may be uninitialized.\n                             if let Bound::Included(start) = start {\n+                                // FIXME(eddyb) this might be incorrect - it doesn't\n+                                // account for wrap-around (end < start) ranges.\n                                 assert!(*scalar.valid_range.start() <= start);\n                                 scalar.valid_range = start..=*scalar.valid_range.end();\n                             }\n                             if let Bound::Included(end) = end {\n+                                // FIXME(eddyb) this might be incorrect - it doesn't\n+                                // account for wrap-around (end < start) ranges.\n                                 assert!(*scalar.valid_range.end() >= end);\n                                 scalar.valid_range = *scalar.valid_range.start()..=end;\n                             }\n+\n+                            // Update `largest_niche` if we have introduced a larger niche.\n+                            let niche = Niche::from_scalar(dl, Size::ZERO, scalar.clone());\n+                            if let Some(niche) = niche {\n+                                match &st.largest_niche {\n+                                    Some(largest_niche) => {\n+                                        // Replace the existing niche even if they're equal,\n+                                        // because this one is at a lower offset.\n+                                        if largest_niche.available(dl) <= niche.available(dl) {\n+                                            st.largest_niche = Some(niche);\n+                                        }\n+                                    }\n+                                    None => st.largest_niche = Some(niche),\n+                                }\n+                            }\n                         }\n                         _ => assert!(\n                             start == Bound::Unbounded && end == Bound::Unbounded,\n@@ -845,6 +902,7 @@ impl<'tcx> LayoutCx<'tcx, TyCtxt<'tcx>> {\n                             st,\n                         ),\n                     }\n+\n                     return Ok(tcx.intern_layout(st));\n                 }\n \n@@ -886,8 +944,10 @@ impl<'tcx> LayoutCx<'tcx, TyCtxt<'tcx>> {\n                         let count = (\n                             niche_variants.end().as_u32() - niche_variants.start().as_u32() + 1\n                         ) as u128;\n+                        // FIXME(#62691) use the largest niche across all fields,\n+                        // not just the first one.\n                         for (field_index, &field) in variants[i].iter().enumerate() {\n-                            let niche = match self.find_niche(field)? {\n+                            let niche = match &field.largest_niche {\n                                 Some(niche) => niche,\n                                 _ => continue,\n                             };\n@@ -937,6 +997,10 @@ impl<'tcx> LayoutCx<'tcx, TyCtxt<'tcx>> {\n                                 abi = Abi::Uninhabited;\n                             }\n \n+\n+                            let largest_niche =\n+                                Niche::from_scalar(dl, offset, niche_scalar.clone());\n+\n                             return Ok(tcx.intern_layout(LayoutDetails {\n                                 variants: Variants::Multiple {\n                                     discr: niche_scalar,\n@@ -953,6 +1017,7 @@ impl<'tcx> LayoutCx<'tcx, TyCtxt<'tcx>> {\n                                     memory_index: vec![0]\n                                 },\n                                 abi,\n+                                largest_niche,\n                                 size,\n                                 align,\n                             }));\n@@ -1164,6 +1229,8 @@ impl<'tcx> LayoutCx<'tcx, TyCtxt<'tcx>> {\n                     abi = Abi::Uninhabited;\n                 }\n \n+                let largest_niche = Niche::from_scalar(dl, Size::ZERO, tag.clone());\n+\n                 tcx.intern_layout(LayoutDetails {\n                     variants: Variants::Multiple {\n                         discr: tag,\n@@ -1175,6 +1242,7 @@ impl<'tcx> LayoutCx<'tcx, TyCtxt<'tcx>> {\n                         offsets: vec![Size::ZERO],\n                         memory_index: vec![0]\n                     },\n+                    largest_niche,\n                     abi,\n                     align,\n                     size\n@@ -1332,16 +1400,31 @@ impl<'tcx> LayoutCx<'tcx, TyCtxt<'tcx>> {\n         // locals as part of the prefix. We compute the layout of all of\n         // these fields at once to get optimal packing.\n         let discr_index = substs.prefix_tys(def_id, tcx).count();\n-        let promoted_tys =\n-            ineligible_locals.iter().map(|local| subst_field(info.field_tys[local]));\n-        let prefix_tys = substs.prefix_tys(def_id, tcx)\n-            .chain(iter::once(substs.discr_ty(tcx)))\n-            .chain(promoted_tys);\n-        let prefix = self.univariant_uninterned(\n+        // FIXME(eddyb) set the correct vaidity range for the discriminant.\n+        let discr_layout = self.layout_of(substs.discr_ty(tcx))?;\n+        let discr = match &discr_layout.abi {\n+            Abi::Scalar(s) => s.clone(),\n+            _ => bug!(),\n+        };\n+        // FIXME(eddyb) wrap each promoted type in `MaybeUninit` so that they\n+        // don't poison the `largest_niche` or `abi` fields of `prefix`.\n+        let promoted_layouts = ineligible_locals.iter()\n+            .map(|local| subst_field(info.field_tys[local]))\n+            .map(|ty| self.layout_of(ty));\n+        let prefix_layouts = substs.prefix_tys(def_id, tcx)\n+            .map(|ty| self.layout_of(ty))\n+            .chain(iter::once(Ok(discr_layout)))\n+            .chain(promoted_layouts)\n+            .collect::<Result<Vec<_>, _>>()?;\n+        let mut prefix = self.univariant_uninterned(\n             ty,\n-            &prefix_tys.map(|ty| self.layout_of(ty)).collect::<Result<Vec<_>, _>>()?,\n+            &prefix_layouts,\n             &ReprOptions::default(),\n-            StructKind::AlwaysSized)?;\n+            StructKind::AlwaysSized,\n+        )?;\n+        // FIXME(eddyb) need `MaybeUninit` around promoted types (see above).\n+        prefix.largest_niche = None;\n+\n         let (prefix_size, prefix_align) = (prefix.size, prefix.align);\n \n         // Split the prefix layout into the \"outer\" fields (upvars and\n@@ -1463,10 +1546,6 @@ impl<'tcx> LayoutCx<'tcx, TyCtxt<'tcx>> {\n         } else {\n             Abi::Aggregate { sized: true }\n         };\n-        let discr = match &self.layout_of(substs.discr_ty(tcx))?.abi {\n-            Abi::Scalar(s) => s.clone(),\n-            _ => bug!(),\n-        };\n \n         let layout = tcx.intern_layout(LayoutDetails {\n             variants: Variants::Multiple {\n@@ -1477,6 +1556,7 @@ impl<'tcx> LayoutCx<'tcx, TyCtxt<'tcx>> {\n             },\n             fields: outer_fields,\n             abi,\n+            largest_niche: prefix.largest_niche,\n             size,\n             align,\n         });\n@@ -1950,6 +2030,7 @@ where\n                     variants: Variants::Single { index: variant_index },\n                     fields: FieldPlacement::Union(fields),\n                     abi: Abi::Uninhabited,\n+                    largest_niche: None,\n                     align: tcx.data_layout.i8_align,\n                     size: Size::ZERO\n                 })\n@@ -2222,83 +2303,6 @@ where\n     }\n }\n \n-impl<'tcx> LayoutCx<'tcx, TyCtxt<'tcx>> {\n-    /// Find the offset of a niche leaf field, starting from\n-    /// the given type and recursing through aggregates.\n-    // FIXME(eddyb) traverse already optimized enums.\n-    fn find_niche(&self, layout: TyLayout<'tcx>) -> Result<Option<Niche>, LayoutError<'tcx>> {\n-        let scalar_niche = |scalar: &Scalar, offset| {\n-            let niche = Niche { offset, scalar: scalar.clone() };\n-            if niche.available(self) > 0 {\n-                Some(niche)\n-            } else {\n-                None\n-            }\n-        };\n-\n-        // Locals variables which live across yields are stored\n-        // in the generator type as fields. These may be uninitialized\n-        // so we don't look for niches there.\n-        if let ty::Generator(..) = layout.ty.sty {\n-            return Ok(None);\n-        }\n-\n-        match layout.abi {\n-            Abi::Scalar(ref scalar) => {\n-                return Ok(scalar_niche(scalar, Size::ZERO));\n-            }\n-            Abi::ScalarPair(ref a, ref b) => {\n-                // HACK(nox): We iter on `b` and then `a` because `max_by_key`\n-                // returns the last maximum.\n-                let niche = iter::once(\n-                    (b, a.value.size(self).align_to(b.value.align(self).abi))\n-                )\n-                    .chain(iter::once((a, Size::ZERO)))\n-                    .filter_map(|(scalar, offset)| scalar_niche(scalar, offset))\n-                    .max_by_key(|niche| niche.available(self));\n-                return Ok(niche);\n-            }\n-            Abi::Vector { ref element, .. } => {\n-                return Ok(scalar_niche(element, Size::ZERO));\n-            }\n-            _ => {}\n-        }\n-\n-        // Perhaps one of the fields is non-zero, let's recurse and find out.\n-        if let FieldPlacement::Union(_) = layout.fields {\n-            // Only Rust enums have safe-to-inspect fields\n-            // (a discriminant), other unions are unsafe.\n-            if let Variants::Single { .. } = layout.variants {\n-                return Ok(None);\n-            }\n-        }\n-        if let FieldPlacement::Array { count: original_64_bit_count, .. } = layout.fields {\n-            // rust-lang/rust#57038: avoid ICE within FieldPlacement::count when count too big\n-            if original_64_bit_count > usize::max_value() as u64 {\n-                return Err(LayoutError::SizeOverflow(layout.ty));\n-            }\n-            if layout.fields.count() > 0 {\n-                return self.find_niche(layout.field(self, 0)?);\n-            } else {\n-                return Ok(None);\n-            }\n-        }\n-        let mut niche = None;\n-        let mut available = 0;\n-        for i in 0..layout.fields.count() {\n-            if let Some(mut c) = self.find_niche(layout.field(self, i)?)? {\n-                let c_available = c.available(self);\n-                if c_available > available {\n-                    available = c_available;\n-                    c.offset += layout.fields.offset(i);\n-                    niche = Some(c);\n-                }\n-            }\n-        }\n-        Ok(niche)\n-    }\n-}\n-\n impl<'a> HashStable<StableHashingContext<'a>> for Variants {\n     fn hash_stable<W: StableHasherResult>(&self,\n                                           hcx: &mut StableHashingContext<'a>,\n@@ -2419,10 +2423,16 @@ impl<'a> HashStable<StableHashingContext<'a>> for Scalar {\n     }\n }\n \n+impl_stable_hash_for!(struct crate::ty::layout::Niche {\n+    offset,\n+    scalar\n+});\n+\n impl_stable_hash_for!(struct crate::ty::layout::LayoutDetails {\n     variants,\n     fields,\n     abi,\n+    largest_niche,\n     size,\n     align\n });"}, {"sha": "4a4c6799c005e0f5d35326aeea4b8b8c8ed800c2", "filename": "src/librustc_target/abi/mod.rs", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/88eced596199548a7653aaf835cda0a93fec36fd/src%2Flibrustc_target%2Fabi%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/88eced596199548a7653aaf835cda0a93fec36fd/src%2Flibrustc_target%2Fabi%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_target%2Fabi%2Fmod.rs?ref=88eced596199548a7653aaf835cda0a93fec36fd", "patch": "@@ -878,12 +878,25 @@ pub enum DiscriminantKind {\n     },\n }\n \n+#[derive(Clone, PartialEq, Eq, Hash, Debug)]\n pub struct Niche {\n     pub offset: Size,\n     pub scalar: Scalar,\n }\n \n impl Niche {\n+    pub fn from_scalar<C: HasDataLayout>(cx: &C, offset: Size, scalar: Scalar) -> Option<Self> {\n+        let niche = Niche {\n+            offset,\n+            scalar,\n+        };\n+        if niche.available(cx) > 0 {\n+            Some(niche)\n+        } else {\n+            None\n+        }\n+    }\n+\n     pub fn available<C: HasDataLayout>(&self, cx: &C) -> u128 {\n         let Scalar { value, valid_range: ref v } = self.scalar;\n         let bits = value.size(cx).bits();\n@@ -934,18 +947,25 @@ pub struct LayoutDetails {\n     pub variants: Variants,\n     pub fields: FieldPlacement,\n     pub abi: Abi,\n+\n+    /// The leaf scalar with the largest number of invalid values\n+    /// (i.e. outside of its `valid_range`), if it exists.\n+    pub largest_niche: Option<Niche>,\n+\n     pub align: AbiAndPrefAlign,\n     pub size: Size\n }\n \n impl LayoutDetails {\n     pub fn scalar<C: HasDataLayout>(cx: &C, scalar: Scalar) -> Self {\n+        let largest_niche = Niche::from_scalar(cx, Size::ZERO, scalar.clone());\n         let size = scalar.value.size(cx);\n         let align = scalar.value.align(cx);\n         LayoutDetails {\n             variants: Variants::Single { index: VariantIdx::new(0) },\n             fields: FieldPlacement::Union(0),\n             abi: Abi::Scalar(scalar),\n+            largest_niche,\n             size,\n             align,\n         }"}]}