{"sha": "688cf6406ab49a65b9b0e882ad4ed4c644145527", "node_id": "MDY6Q29tbWl0NzI0NzEyOjY4OGNmNjQwNmFiNDlhNjViOWIwZTg4MmFkNGVkNGM2NDQxNDU1Mjc=", "commit": {"author": {"name": "Bastian Kauschke", "email": "bastian_kauschke@hotmail.de", "date": "2021-01-23T10:47:38Z"}, "committer": {"name": "Bastian Kauschke", "email": "bastian_kauschke@hotmail.de", "date": "2021-01-23T10:47:38Z"}, "message": "replace RefCell with Cell in FnCtxt", "tree": {"sha": "3c31c68ee021393f77fc93ac571227f726fb6ad4", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3c31c68ee021393f77fc93ac571227f726fb6ad4"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/688cf6406ab49a65b9b0e882ad4ed4c644145527", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/688cf6406ab49a65b9b0e882ad4ed4c644145527", "html_url": "https://github.com/rust-lang/rust/commit/688cf6406ab49a65b9b0e882ad4ed4c644145527", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/688cf6406ab49a65b9b0e882ad4ed4c644145527/comments", "author": {"login": "lcnr", "id": 29864074, "node_id": "MDQ6VXNlcjI5ODY0MDc0", "avatar_url": "https://avatars.githubusercontent.com/u/29864074?v=4", "gravatar_id": "", "url": "https://api.github.com/users/lcnr", "html_url": "https://github.com/lcnr", "followers_url": "https://api.github.com/users/lcnr/followers", "following_url": "https://api.github.com/users/lcnr/following{/other_user}", "gists_url": "https://api.github.com/users/lcnr/gists{/gist_id}", "starred_url": "https://api.github.com/users/lcnr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/lcnr/subscriptions", "organizations_url": "https://api.github.com/users/lcnr/orgs", "repos_url": "https://api.github.com/users/lcnr/repos", "events_url": "https://api.github.com/users/lcnr/events{/privacy}", "received_events_url": "https://api.github.com/users/lcnr/received_events", "type": "User", "site_admin": false}, "committer": {"login": "lcnr", "id": 29864074, "node_id": "MDQ6VXNlcjI5ODY0MDc0", "avatar_url": "https://avatars.githubusercontent.com/u/29864074?v=4", "gravatar_id": "", "url": "https://api.github.com/users/lcnr", "html_url": "https://github.com/lcnr", "followers_url": "https://api.github.com/users/lcnr/followers", "following_url": "https://api.github.com/users/lcnr/following{/other_user}", "gists_url": "https://api.github.com/users/lcnr/gists{/gist_id}", "starred_url": "https://api.github.com/users/lcnr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/lcnr/subscriptions", "organizations_url": "https://api.github.com/users/lcnr/orgs", "repos_url": "https://api.github.com/users/lcnr/repos", "events_url": "https://api.github.com/users/lcnr/events{/privacy}", "received_events_url": "https://api.github.com/users/lcnr/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1986b58c646a9523d0a8a0fa8a0bd20492e7795d", "url": "https://api.github.com/repos/rust-lang/rust/commits/1986b58c646a9523d0a8a0fa8a0bd20492e7795d", "html_url": "https://github.com/rust-lang/rust/commit/1986b58c646a9523d0a8a0fa8a0bd20492e7795d"}], "stats": {"total": 41, "additions": 18, "deletions": 23}, "files": [{"sha": "ab3c26fac8338a03ba0c707780a64def2018f38d", "filename": "compiler/rustc_typeck/src/check/check.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/688cf6406ab49a65b9b0e882ad4ed4c644145527/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/688cf6406ab49a65b9b0e882ad4ed4c644145527/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcheck.rs?ref=688cf6406ab49a65b9b0e882ad4ed4c644145527", "patch": "@@ -66,7 +66,7 @@ pub(super) fn check_fn<'a, 'tcx>(\n     // Create the function context. This is either derived from scratch or,\n     // in the case of closures, based on the outer context.\n     let mut fcx = FnCtxt::new(inherited, param_env, body.value.hir_id);\n-    *fcx.ps.borrow_mut() = UnsafetyState::function(fn_sig.unsafety, fn_id);\n+    fcx.ps.set(UnsafetyState::function(fn_sig.unsafety, fn_id));\n \n     let tcx = fcx.tcx;\n     let sess = tcx.sess;"}, {"sha": "b2395b7bb2502d3da006cca7e8ab4c68b6e4a45c", "filename": "compiler/rustc_typeck/src/check/coercion.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/688cf6406ab49a65b9b0e882ad4ed4c644145527/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcoercion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/688cf6406ab49a65b9b0e882ad4ed4c644145527/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcoercion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcoercion.rs?ref=688cf6406ab49a65b9b0e882ad4ed4c644145527", "patch": "@@ -1472,22 +1472,22 @@ impl<'tcx, 'exprs, E: AsCoercionSite> CoerceMany<'tcx, 'exprs, E> {\n                 fn_output = Some(&fn_decl.output); // `impl Trait` return type\n             }\n         }\n-        if let (Some(sp), Some(fn_output)) = (fcx.ret_coercion_span.borrow().as_ref(), fn_output) {\n-            self.add_impl_trait_explanation(&mut err, cause, fcx, expected, *sp, fn_output);\n+        if let (Some(sp), Some(fn_output)) = (fcx.ret_coercion_span.get(), fn_output) {\n+            self.add_impl_trait_explanation(&mut err, cause, fcx, expected, sp, fn_output);\n         }\n \n-        if let Some(sp) = fcx.ret_coercion_span.borrow().as_ref() {\n+        if let Some(sp) = fcx.ret_coercion_span.get() {\n             // If the closure has an explicit return type annotation,\n             // then a type error may occur at the first return expression we\n             // see in the closure (if it conflicts with the declared\n             // return type). Skip adding a note in this case, since it\n             // would be incorrect.\n-            if !err.span.primary_spans().iter().any(|span| span == sp) {\n+            if !err.span.primary_spans().iter().any(|&span| span == sp) {\n                 let hir = fcx.tcx.hir();\n                 let body_owner = hir.body_owned_by(hir.enclosing_body_owner(fcx.body_id));\n                 if fcx.tcx.is_closure(hir.body_owner_def_id(body_owner).to_def_id()) {\n                     err.span_note(\n-                        *sp,\n+                        sp,\n                         &format!(\n                             \"return type inferred to be `{}` here\",\n                             fcx.resolve_vars_if_possible(expected)"}, {"sha": "e37b4ff742bc62ab715e60774a4180fc92f191dc", "filename": "compiler/rustc_typeck/src/check/expr.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/688cf6406ab49a65b9b0e882ad4ed4c644145527/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/688cf6406ab49a65b9b0e882ad4ed4c644145527/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fexpr.rs?ref=688cf6406ab49a65b9b0e882ad4ed4c644145527", "patch": "@@ -680,14 +680,14 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         if self.ret_coercion.is_none() {\n             self.tcx.sess.emit_err(ReturnStmtOutsideOfFnBody { span: expr.span });\n         } else if let Some(ref e) = expr_opt {\n-            if self.ret_coercion_span.borrow().is_none() {\n-                *self.ret_coercion_span.borrow_mut() = Some(e.span);\n+            if self.ret_coercion_span.get().is_none() {\n+                self.ret_coercion_span.set(Some(e.span));\n             }\n             self.check_return_expr(e);\n         } else {\n             let mut coercion = self.ret_coercion.as_ref().unwrap().borrow_mut();\n-            if self.ret_coercion_span.borrow().is_none() {\n-                *self.ret_coercion_span.borrow_mut() = Some(expr.span);\n+            if self.ret_coercion_span.get().is_none() {\n+                self.ret_coercion_span.set(Some(expr.span));\n             }\n             let cause = self.cause(expr.span, ObligationCauseCode::ReturnNoExpression);\n             if let Some((fn_decl, _)) = self.get_fn_decl(expr.hir_id) {"}, {"sha": "fb6f9c03352b43d83e69e9c99381d1be746d08a9", "filename": "compiler/rustc_typeck/src/check/fn_ctxt/checks.rs", "status": "modified", "additions": 2, "deletions": 7, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/688cf6406ab49a65b9b0e882ad4ed4c644145527/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2Fchecks.rs", "raw_url": "https://github.com/rust-lang/rust/raw/688cf6406ab49a65b9b0e882ad4ed4c644145527/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2Fchecks.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2Fchecks.rs?ref=688cf6406ab49a65b9b0e882ad4ed4c644145527", "patch": "@@ -23,7 +23,6 @@ use rustc_span::{self, MultiSpan, Span};\n use rustc_trait_selection::traits::{self, ObligationCauseCode, StatementAsExpression};\n \n use crate::structured_errors::StructuredDiagnostic;\n-use std::mem::replace;\n use std::slice;\n \n impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n@@ -589,11 +588,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         blk: &'tcx hir::Block<'tcx>,\n         expected: Expectation<'tcx>,\n     ) -> Ty<'tcx> {\n-        let prev = {\n-            let mut fcx_ps = self.ps.borrow_mut();\n-            let unsafety_state = fcx_ps.recurse(blk);\n-            replace(&mut *fcx_ps, unsafety_state)\n-        };\n+        let prev = self.ps.replace(self.ps.get().recurse(blk));\n \n         // In some cases, blocks have just one exit, but other blocks\n         // can be targeted by multiple breaks. This can happen both\n@@ -709,7 +704,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n         self.write_ty(blk.hir_id, ty);\n \n-        *self.ps.borrow_mut() = prev;\n+        self.ps.set(prev);\n         ty\n     }\n "}, {"sha": "e9223f700dcc722c0e78f0f943721940d69ef8f4", "filename": "compiler/rustc_typeck/src/check/fn_ctxt/mod.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/688cf6406ab49a65b9b0e882ad4ed4c644145527/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/688cf6406ab49a65b9b0e882ad4ed4c644145527/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2Fmod.rs?ref=688cf6406ab49a65b9b0e882ad4ed4c644145527", "patch": "@@ -66,11 +66,11 @@ pub struct FnCtxt<'a, 'tcx> {\n     pub(super) in_tail_expr: bool,\n \n     /// First span of a return site that we find. Used in error messages.\n-    pub(super) ret_coercion_span: RefCell<Option<Span>>,\n+    pub(super) ret_coercion_span: Cell<Option<Span>>,\n \n     pub(super) resume_yield_tys: Option<(Ty<'tcx>, Ty<'tcx>)>,\n \n-    pub(super) ps: RefCell<UnsafetyState>,\n+    pub(super) ps: Cell<UnsafetyState>,\n \n     /// Whether the last checked node generates a divergence (e.g.,\n     /// `return` will set this to `Always`). In general, when entering\n@@ -127,9 +127,9 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             ret_coercion_impl_trait: None,\n             ret_type_span: None,\n             in_tail_expr: false,\n-            ret_coercion_span: RefCell::new(None),\n+            ret_coercion_span: Cell::new(None),\n             resume_yield_tys: None,\n-            ps: RefCell::new(UnsafetyState::function(hir::Unsafety::Normal, hir::CRATE_HIR_ID)),\n+            ps: Cell::new(UnsafetyState::function(hir::Unsafety::Normal, hir::CRATE_HIR_ID)),\n             diverges: Cell::new(Diverges::Maybe),\n             has_errors: Cell::new(false),\n             enclosing_breakables: RefCell::new(EnclosingBreakables {"}, {"sha": "c8c6fa12fae08c58959c43edf9fac9fec8623ae9", "filename": "compiler/rustc_typeck/src/check/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/688cf6406ab49a65b9b0e882ad4ed4c644145527/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/688cf6406ab49a65b9b0e882ad4ed4c644145527/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmod.rs?ref=688cf6406ab49a65b9b0e882ad4ed4c644145527", "patch": "@@ -184,14 +184,14 @@ impl UnsafetyState {\n         UnsafetyState { def, unsafety, unsafe_push_count: 0, from_fn: true }\n     }\n \n-    pub fn recurse(&mut self, blk: &hir::Block<'_>) -> UnsafetyState {\n+    pub fn recurse(self, blk: &hir::Block<'_>) -> UnsafetyState {\n         use hir::BlockCheckMode;\n         match self.unsafety {\n             // If this unsafe, then if the outer function was already marked as\n             // unsafe we shouldn't attribute the unsafe'ness to the block. This\n             // way the block can be warned about instead of ignoring this\n             // extraneous block (functions are never warned about).\n-            hir::Unsafety::Unsafe if self.from_fn => *self,\n+            hir::Unsafety::Unsafe if self.from_fn => self,\n \n             unsafety => {\n                 let (unsafety, def, count) = match blk.rules {"}]}