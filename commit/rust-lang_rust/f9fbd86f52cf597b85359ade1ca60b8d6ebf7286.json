{"sha": "f9fbd86f52cf597b85359ade1ca60b8d6ebf7286", "node_id": "MDY6Q29tbWl0NzI0NzEyOmY5ZmJkODZmNTJjZjU5N2I4NTM1OWFkZTFjYTYwYjhkNmViZjcyODY=", "commit": {"author": {"name": "Marijn Haverbeke", "email": "marijnh@gmail.com", "date": "2011-10-06T10:26:12Z"}, "committer": {"name": "Marijn Haverbeke", "email": "marijnh@gmail.com", "date": "2011-10-07T07:09:50Z"}, "message": "Parse and typecheck by-value and by-ref arg specs\n\nAdd sprinkle && throughout the compiler to make it typecheck again.\n\nIssue #1008", "tree": {"sha": "d6f0cdd039642052f3ccb4ba8f3b9821bb7cbaaf", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d6f0cdd039642052f3ccb4ba8f3b9821bb7cbaaf"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f9fbd86f52cf597b85359ade1ca60b8d6ebf7286", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f9fbd86f52cf597b85359ade1ca60b8d6ebf7286", "html_url": "https://github.com/rust-lang/rust/commit/f9fbd86f52cf597b85359ade1ca60b8d6ebf7286", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f9fbd86f52cf597b85359ade1ca60b8d6ebf7286/comments", "author": {"login": "marijnh", "id": 144427, "node_id": "MDQ6VXNlcjE0NDQyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/144427?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marijnh", "html_url": "https://github.com/marijnh", "followers_url": "https://api.github.com/users/marijnh/followers", "following_url": "https://api.github.com/users/marijnh/following{/other_user}", "gists_url": "https://api.github.com/users/marijnh/gists{/gist_id}", "starred_url": "https://api.github.com/users/marijnh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marijnh/subscriptions", "organizations_url": "https://api.github.com/users/marijnh/orgs", "repos_url": "https://api.github.com/users/marijnh/repos", "events_url": "https://api.github.com/users/marijnh/events{/privacy}", "received_events_url": "https://api.github.com/users/marijnh/received_events", "type": "User", "site_admin": false}, "committer": {"login": "marijnh", "id": 144427, "node_id": "MDQ6VXNlcjE0NDQyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/144427?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marijnh", "html_url": "https://github.com/marijnh", "followers_url": "https://api.github.com/users/marijnh/followers", "following_url": "https://api.github.com/users/marijnh/following{/other_user}", "gists_url": "https://api.github.com/users/marijnh/gists{/gist_id}", "starred_url": "https://api.github.com/users/marijnh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marijnh/subscriptions", "organizations_url": "https://api.github.com/users/marijnh/orgs", "repos_url": "https://api.github.com/users/marijnh/repos", "events_url": "https://api.github.com/users/marijnh/events{/privacy}", "received_events_url": "https://api.github.com/users/marijnh/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4709038d641ad009b44ed2bf5980fa3a252d6927", "url": "https://api.github.com/repos/rust-lang/rust/commits/4709038d641ad009b44ed2bf5980fa3a252d6927", "html_url": "https://github.com/rust-lang/rust/commit/4709038d641ad009b44ed2bf5980fa3a252d6927"}], "stats": {"total": 427, "additions": 230, "deletions": 197}, "files": [{"sha": "62c6a0282ce87e78317c81440b617073bfe23ee9", "filename": "src/comp/front/attr.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f9fbd86f52cf597b85359ade1ca60b8d6ebf7286/src%2Fcomp%2Ffront%2Fattr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9fbd86f52cf597b85359ade1ca60b8d6ebf7286/src%2Fcomp%2Ffront%2Fattr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Ffront%2Fattr.rs?ref=f9fbd86f52cf597b85359ade1ca60b8d6ebf7286", "patch": "@@ -57,7 +57,7 @@ fn get_attr_name(attr: ast::attribute) -> ast::ident {\n fn find_meta_items_by_name(metas: [@ast::meta_item], name: ast::ident) ->\n    [@ast::meta_item] {\n     let filter =\n-        bind fn (m: @ast::meta_item, name: ast::ident) ->\n+        bind fn (&&m: @ast::meta_item, name: ast::ident) ->\n                 option::t<@ast::meta_item> {\n                  if get_meta_item_name(m) == name {\n                      option::some(m)\n@@ -134,7 +134,7 @@ fn contains_name(metas: [@ast::meta_item], name: ast::ident) -> bool {\n \n // FIXME: This needs to sort by meta_item variant in addition to the item name\n fn sort_meta_items(items: [@ast::meta_item]) -> [@ast::meta_item] {\n-    fn lteq(ma: @ast::meta_item, mb: @ast::meta_item) -> bool {\n+    fn lteq(&&ma: @ast::meta_item, &&mb: @ast::meta_item) -> bool {\n         fn key(m: @ast::meta_item) -> ast::ident {\n             alt m.node {\n               ast::meta_word(name) { name }\n@@ -160,7 +160,7 @@ fn remove_meta_items_by_name(items: [@ast::meta_item], name: str) ->\n    [@ast::meta_item] {\n \n     let filter =\n-        bind fn (item: @ast::meta_item, name: str) ->\n+        bind fn (&&item: @ast::meta_item, name: str) ->\n                 option::t<@ast::meta_item> {\n                  if get_meta_item_name(item) != name {\n                      option::some(item)"}, {"sha": "cc2b35d8d9ec7b9ec510ff2b5a4bcbfaf3f5045f", "filename": "src/comp/front/config.rs", "status": "modified", "additions": 21, "deletions": 22, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/f9fbd86f52cf597b85359ade1ca60b8d6ebf7286/src%2Fcomp%2Ffront%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9fbd86f52cf597b85359ade1ca60b8d6ebf7286/src%2Fcomp%2Ffront%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Ffront%2Fconfig.rs?ref=f9fbd86f52cf597b85359ade1ca60b8d6ebf7286", "patch": "@@ -20,7 +20,7 @@ fn strip_unconfigured_items(crate: @ast::crate) -> @ast::crate {\n     ret res;\n }\n \n-fn filter_item(cfg: ast::crate_cfg, item: @ast::item) ->\n+fn filter_item(cfg: ast::crate_cfg, &&item: @ast::item) ->\n    option::t<@ast::item> {\n     if item_in_cfg(cfg, item) { option::some(item) } else { option::none }\n }\n@@ -29,11 +29,11 @@ fn fold_mod(cfg: ast::crate_cfg, m: ast::_mod, fld: fold::ast_fold) ->\n    ast::_mod {\n     let filter = bind filter_item(cfg, _);\n     let filtered_items = vec::filter_map(filter, m.items);\n-    ret {view_items: vec::map(fld.fold_view_item, m.view_items),\n-         items: vec::map(fld.fold_item, filtered_items)};\n+    ret {view_items: vec::map_imm(fld.fold_view_item, m.view_items),\n+         items: vec::map_imm(fld.fold_item, filtered_items)};\n }\n \n-fn filter_native_item(cfg: ast::crate_cfg, item: @ast::native_item) ->\n+fn filter_native_item(cfg: ast::crate_cfg, &&item: @ast::native_item) ->\n    option::t<@ast::native_item> {\n     if native_item_in_cfg(cfg, item) {\n         option::some(item)\n@@ -46,11 +46,11 @@ fn fold_native_mod(cfg: ast::crate_cfg, nm: ast::native_mod,\n     let filtered_items = vec::filter_map(filter, nm.items);\n     ret {native_name: nm.native_name,\n          abi: nm.abi,\n-         view_items: vec::map(fld.fold_view_item, nm.view_items),\n+         view_items: vec::map_imm(fld.fold_view_item, nm.view_items),\n          items: filtered_items};\n }\n \n-fn filter_stmt(cfg: ast::crate_cfg, stmt: @ast::stmt) ->\n+fn filter_stmt(cfg: ast::crate_cfg, &&stmt: @ast::stmt) ->\n    option::t<@ast::stmt> {\n     alt stmt.node {\n       ast::stmt_decl(decl, _) {\n@@ -71,8 +71,8 @@ fn fold_block(cfg: ast::crate_cfg, b: ast::blk_, fld: fold::ast_fold) ->\n    ast::blk_ {\n     let filter = bind filter_stmt(cfg, _);\n     let filtered_stmts = vec::filter_map(filter, b.stmts);\n-    ret {stmts: vec::map(fld.fold_stmt, filtered_stmts),\n-         expr: option::map(fld.fold_expr, b.expr),\n+    ret {stmts: vec::map_imm(fld.fold_stmt, filtered_stmts),\n+         expr: option::map_imm(fld.fold_expr, b.expr),\n          id: b.id,\n          rules: b.rules};\n }\n@@ -97,21 +97,20 @@ fn in_cfg(cfg: ast::crate_cfg, attrs: [ast::attribute]) -> bool {\n     // Pull the inner meta_items from the #[cfg(meta_item, ...)]  attributes,\n     // so we can match against them. This is the list of configurations for\n     // which the item is valid\n-    let item_cfg_metas =\n-        {\n-            fn extract_metas(inner_items: [@ast::meta_item],\n-                             cfg_item: @ast::meta_item) -> [@ast::meta_item] {\n-                alt cfg_item.node {\n-                  ast::meta_list(name, items) {\n-                    assert (name == \"cfg\");\n-                    inner_items + items\n-                  }\n-                  _ { inner_items }\n-                }\n+    let item_cfg_metas = {\n+        fn extract_metas(inner_items: [@ast::meta_item],\n+                         &&cfg_item: @ast::meta_item) -> [@ast::meta_item] {\n+            alt cfg_item.node {\n+              ast::meta_list(name, items) {\n+                assert (name == \"cfg\");\n+                inner_items + items\n+              }\n+              _ { inner_items }\n             }\n-            let cfg_metas = attr::attr_metas(item_cfg_attrs);\n-            vec::foldl(extract_metas, [], cfg_metas)\n-        };\n+        }\n+        let cfg_metas = attr::attr_metas(item_cfg_attrs);\n+        vec::foldl(extract_metas, [], cfg_metas)\n+    };\n \n     for cfg_mi: @ast::meta_item in item_cfg_metas {\n         if attr::contains(cfg, cfg_mi) { ret true; }"}, {"sha": "030a4faf5f98207344a0e3e33f8ea0368b7eb7e9", "filename": "src/comp/front/test.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f9fbd86f52cf597b85359ade1ca60b8d6ebf7286/src%2Fcomp%2Ffront%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9fbd86f52cf597b85359ade1ca60b8d6ebf7286/src%2Fcomp%2Ffront%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Ffront%2Ftest.rs?ref=f9fbd86f52cf597b85359ade1ca60b8d6ebf7286", "patch": "@@ -56,7 +56,7 @@ fn fold_mod(_cx: test_ctxt, m: ast::_mod, fld: fold::ast_fold) -> ast::_mod {\n     // the one we're going to add.  FIXME: This is sloppy. Instead we should\n     // have some mechanism to indicate to the translation pass which function\n     // we want to be main.\n-    fn nomain(item: @ast::item) -> option::t<@ast::item> {\n+    fn nomain(&&item: @ast::item) -> option::t<@ast::item> {\n         alt item.node {\n           ast::item_fn(f, _) {\n             if item.ident == \"main\" {"}, {"sha": "c47f75135d7c17b579860c4e1b5eb97426d9159e", "filename": "src/comp/lib/llvm.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f9fbd86f52cf597b85359ade1ca60b8d6ebf7286/src%2Fcomp%2Flib%2Fllvm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9fbd86f52cf597b85359ade1ca60b8d6ebf7286/src%2Fcomp%2Flib%2Fllvm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Flib%2Fllvm.rs?ref=f9fbd86f52cf597b85359ade1ca60b8d6ebf7286", "patch": "@@ -909,9 +909,9 @@ obj type_names(type_names: std::map::hashmap<TypeRef, str>,\n fn mk_type_names() -> type_names {\n     let nt = std::map::new_str_hash::<TypeRef>();\n \n-    fn hash(t: TypeRef) -> uint { ret t as uint; }\n+    fn hash(&&t: TypeRef) -> uint { ret t as uint; }\n \n-    fn eq(a: TypeRef, b: TypeRef) -> bool { ret a as uint == b as uint; }\n+    fn eq(&&a: TypeRef, &&b: TypeRef) -> bool { ret a as uint == b as uint; }\n \n     let hasher: std::map::hashfn<TypeRef> = hash;\n     let eqer: std::map::eqfn<TypeRef> = eq;"}, {"sha": "134e43d62809d1f5c7a757732815d9fefe6f16d7", "filename": "src/comp/metadata/common.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f9fbd86f52cf597b85359ade1ca60b8d6ebf7286/src%2Fcomp%2Fmetadata%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9fbd86f52cf597b85359ade1ca60b8d6ebf7286/src%2Fcomp%2Fmetadata%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmetadata%2Fcommon.rs?ref=f9fbd86f52cf597b85359ade1ca60b8d6ebf7286", "patch": "@@ -65,7 +65,7 @@ const tag_crate_dep: uint = 0x26u;\n const tag_items_data_item_inlineness: uint = 0x27u;\n \n // djb's cdb hashes.\n-fn hash_node_id(node_id: int) -> uint { ret 177573u ^ (node_id as uint); }\n+fn hash_node_id(&&node_id: int) -> uint { ret 177573u ^ (node_id as uint); }\n \n fn hash_path(s: str) -> uint {\n     let h = 5381u;"}, {"sha": "f8145c306c862a2c207b77b7ad920e361befe907", "filename": "src/comp/metadata/encoder.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f9fbd86f52cf597b85359ade1ca60b8d6ebf7286/src%2Fcomp%2Fmetadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9fbd86f52cf597b85359ade1ca60b8d6ebf7286/src%2Fcomp%2Fmetadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmetadata%2Fencoder.rs?ref=f9fbd86f52cf597b85359ade1ca60b8d6ebf7286", "patch": "@@ -427,7 +427,7 @@ fn encode_index<T>(ebml_w: ebml::writer, buckets: [@[entry<T>]],\n \n fn write_str(writer: io::writer, s: str) { writer.write_str(s); }\n \n-fn write_int(writer: io::writer, n: int) {\n+fn write_int(writer: io::writer, &&n: int) {\n     writer.write_be_uint(n as uint, 4u);\n }\n "}, {"sha": "e1123c3b6232e7b72eba02dc6e023f88ecb1a4f3", "filename": "src/comp/metadata/tydecode.rs", "status": "modified", "additions": 7, "deletions": 8, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/f9fbd86f52cf597b85359ade1ca60b8d6ebf7286/src%2Fcomp%2Fmetadata%2Ftydecode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9fbd86f52cf597b85359ade1ca60b8d6ebf7286/src%2Fcomp%2Fmetadata%2Ftydecode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmetadata%2Ftydecode.rs?ref=f9fbd86f52cf597b85359ade1ca60b8d6ebf7286", "patch": "@@ -380,14 +380,13 @@ fn parse_ty_fn(st: @pstate, sd: str_def) ->\n     assert (next(st) as char == '[');\n     let inputs: [ty::arg] = [];\n     while peek(st) as char != ']' {\n-        let mode = ast::by_ref;\n-        if peek(st) as char == '&' {\n-            mode = ast::by_mut_ref;\n-            st.pos += 1u;\n-        } else if peek(st) as char == '-' {\n-            mode = ast::by_move;\n-            st.pos += 1u;\n-        }\n+        let mode = alt peek(st) as char {\n+          '&' { ast::by_mut_ref }\n+          '-' { ast::by_move }\n+          '=' { ast::by_ref }\n+          '+' { ast::by_val }\n+        };\n+        st.pos += 1u;\n         inputs += [{mode: mode, ty: parse_ty(st, sd)}];\n     }\n     st.pos += 1u; // eat the ']'"}, {"sha": "4867b80e125a5ba17675f5c823ae8f54873faeea", "filename": "src/comp/metadata/tyencode.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/f9fbd86f52cf597b85359ade1ca60b8d6ebf7286/src%2Fcomp%2Fmetadata%2Ftyencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9fbd86f52cf597b85359ade1ca60b8d6ebf7286/src%2Fcomp%2Fmetadata%2Ftyencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmetadata%2Ftyencode.rs?ref=f9fbd86f52cf597b85359ade1ca60b8d6ebf7286", "patch": "@@ -207,7 +207,8 @@ fn enc_ty_fn(w: io::writer, cx: @ctxt, args: [ty::arg], out: ty::t,\n         alt arg.mode {\n           by_mut_ref. { w.write_char('&'); }\n           by_move. { w.write_char('-'); }\n-          by_ref. { }\n+          by_ref. { w.write_char('='); }\n+          by_val. { w.write_char('+'); }\n         }\n         enc_ty(w, cx, arg.ty);\n     }"}, {"sha": "5d9d736f209701a7687abe5bf437f730be0ab70a", "filename": "src/comp/middle/alias.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f9fbd86f52cf597b85359ade1ca60b8d6ebf7286/src%2Fcomp%2Fmiddle%2Falias.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9fbd86f52cf597b85359ade1ca60b8d6ebf7286/src%2Fcomp%2Fmiddle%2Falias.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Falias.rs?ref=f9fbd86f52cf597b85359ade1ca60b8d6ebf7286", "patch": "@@ -251,10 +251,8 @@ fn check_call(cx: ctx, f: @ast::expr, args: [@ast::expr]) -> [binding] {\n                        mutable ok: valid,\n                        mutable copied: alt arg_t.mode {\n                          ast::by_move. { copied }\n-                         ast::by_ref. {\n-                           i + 1u == by_ref ? not_allowed : not_copied\n-                         }\n                          ast::by_mut_ref. { not_allowed }\n+                         _ { i + 1u == by_ref ? not_allowed : not_copied }\n                        }}];\n         i += 1u;\n     }"}, {"sha": "9b89ec6333149f1560879e1885d2c8d262e13fb0", "filename": "src/comp/middle/ast_map.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f9fbd86f52cf597b85359ade1ca60b8d6ebf7286/src%2Fcomp%2Fmiddle%2Fast_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9fbd86f52cf597b85359ade1ca60b8d6ebf7286/src%2Fcomp%2Fmiddle%2Fast_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fast_map.rs?ref=f9fbd86f52cf597b85359ade1ca60b8d6ebf7286", "patch": "@@ -76,7 +76,7 @@ fn map_expr(cx: ctx, ex: @expr) {\n }\n \n fn new_smallintmap_int_adapter<@V>() -> std::map::hashmap<int, V> {\n-    let key_idx = fn (key: int) -> uint { key as uint };\n+    let key_idx = fn (&&key: int) -> uint { key as uint };\n     let idx_key = fn (idx: uint) -> int { idx as int };\n     ret new_smallintmap_adapter(key_idx, idx_key);\n }"}, {"sha": "a3b58cf16001595cac14a885a1fea1c17b9841af", "filename": "src/comp/middle/check_alt.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f9fbd86f52cf597b85359ade1ca60b8d6ebf7286/src%2Fcomp%2Fmiddle%2Fcheck_alt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9fbd86f52cf597b85359ade1ca60b8d6ebf7286/src%2Fcomp%2Fmiddle%2Fcheck_alt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fcheck_alt.rs?ref=f9fbd86f52cf597b85359ade1ca60b8d6ebf7286", "patch": "@@ -11,7 +11,7 @@ fn check_crate(tcx: ty::ctxt, crate: @crate) {\n     tcx.sess.abort_if_errors();\n }\n \n-fn check_expr(tcx: ty::ctxt, ex: @expr, s: (), v: visit::vt<()>) {\n+fn check_expr(tcx: ty::ctxt, ex: @expr, &&s: (), v: visit::vt<()>) {\n     visit::visit_expr(ex, s, v);\n     alt ex.node { expr_alt(_, arms) { check_arms(tcx, arms); } _ { } }\n }\n@@ -123,7 +123,7 @@ fn pattern_supersedes(tcx: ty::ctxt, a: @pat, b: @pat) -> bool {\n     }\n }\n \n-fn check_local(tcx: ty::ctxt, loc: @local, s: (), v: visit::vt<()>) {\n+fn check_local(tcx: ty::ctxt, loc: @local, &&s: (), v: visit::vt<()>) {\n     visit::visit_local(loc, s, v);\n     if is_refutable(tcx, loc.node.pat) {\n         tcx.sess.span_err(loc.node.pat.span,"}, {"sha": "5a6ed3283e767b85f79f4b2cf09aec8514ae42a3", "filename": "src/comp/middle/freevars.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f9fbd86f52cf597b85359ade1ca60b8d6ebf7286/src%2Fcomp%2Fmiddle%2Ffreevars.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9fbd86f52cf597b85359ade1ca60b8d6ebf7286/src%2Fcomp%2Fmiddle%2Ffreevars.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ffreevars.rs?ref=f9fbd86f52cf597b85359ade1ca60b8d6ebf7286", "patch": "@@ -29,10 +29,10 @@ fn collect_freevars(def_map: resolve::def_map, walker: fn(visit::vt<int>)) ->\n     let seen = new_int_hash();\n     let refs = @mutable [];\n \n-    fn ignore_item(_i: @ast::item, _depth: int, _v: visit::vt<int>) { }\n+    fn ignore_item(_i: @ast::item, &&_depth: int, _v: visit::vt<int>) { }\n \n     let walk_expr =\n-        lambda (expr: @ast::expr, depth: int, v: visit::vt<int>) {\n+        lambda (expr: @ast::expr, &&depth: int, v: visit::vt<int>) {\n             alt expr.node {\n               ast::expr_fn(f) {\n                 if f.proto == ast::proto_block ||"}, {"sha": "836f6de87e3148c2feb23c17ec4ea5cecf2fdf10", "filename": "src/comp/middle/mut.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f9fbd86f52cf597b85359ade1ca60b8d6ebf7286/src%2Fcomp%2Fmiddle%2Fmut.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9fbd86f52cf597b85359ade1ca60b8d6ebf7286/src%2Fcomp%2Fmiddle%2Fmut.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fmut.rs?ref=f9fbd86f52cf597b85359ade1ca60b8d6ebf7286", "patch": "@@ -131,7 +131,7 @@ fn mk_err(cx: @ctx, span: syntax::codemap::span, msg: msg, name: str) {\n     });\n }\n \n-fn visit_decl(cx: @ctx, d: @decl, e: (), v: visit::vt<()>) {\n+fn visit_decl(cx: @ctx, d: @decl, &&e: (), v: visit::vt<()>) {\n     visit::visit_decl(d, e, v);\n     alt d.node {\n       decl_local(locs) {\n@@ -148,7 +148,7 @@ fn visit_decl(cx: @ctx, d: @decl, e: (), v: visit::vt<()>) {\n     }\n }\n \n-fn visit_expr(cx: @ctx, ex: @expr, e: (), v: visit::vt<()>) {\n+fn visit_expr(cx: @ctx, ex: @expr, &&e: (), v: visit::vt<()>) {\n     alt ex.node {\n       expr_call(f, args) { check_call(cx, f, args); }\n       expr_swap(lhs, rhs) {\n@@ -225,7 +225,7 @@ fn check_call(cx: @ctx, f: @expr, args: [@expr]) {\n         alt arg_t.mode {\n           by_mut_ref. { check_lval(cx, args[i], msg_mut_ref); }\n           by_move. { check_lval(cx, args[i], msg_move_out); }\n-          by_ref. {}\n+          _ {}\n         }\n         i += 1u;\n     }"}, {"sha": "fe95ecc0b852c9d319f969f88748b1fbc3f457bf", "filename": "src/comp/middle/resolve.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/f9fbd86f52cf597b85359ade1ca60b8d6ebf7286/src%2Fcomp%2Fmiddle%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9fbd86f52cf597b85359ade1ca60b8d6ebf7286/src%2Fcomp%2Fmiddle%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fresolve.rs?ref=f9fbd86f52cf597b85359ade1ca60b8d6ebf7286", "patch": "@@ -1239,7 +1239,7 @@ fn mie_span(mie: mod_index_entry) -> span {\n         };\n }\n \n-fn check_item(e: @env, i: @ast::item, x: (), v: vt<()>) {\n+fn check_item(e: @env, i: @ast::item, &&x: (), v: vt<()>) {\n     fn typaram_names(tps: [ast::ty_param]) -> [ident] {\n         let x: [ast::ident] = [];\n         for tp: ast::ty_param in tps { x += [tp.ident]; }\n@@ -1276,7 +1276,7 @@ fn check_pat(ch: checker, p: @ast::pat) {\n     }\n }\n \n-fn check_arm(e: @env, a: ast::arm, x: (), v: vt<()>) {\n+fn check_arm(e: @env, a: ast::arm, &&x: (), v: vt<()>) {\n     visit::visit_arm(a, x, v);\n     let ch0 = checker(*e, \"binding\");\n     check_pat(ch0, a.pats[0]);\n@@ -1306,7 +1306,7 @@ fn check_arm(e: @env, a: ast::arm, x: (), v: vt<()>) {\n     }\n }\n \n-fn check_block(e: @env, b: ast::blk, x: (), v: vt<()>) {\n+fn check_block(e: @env, b: ast::blk, &&x: (), v: vt<()>) {\n     visit::visit_block(b, x, v);\n     let values = checker(*e, \"value\");\n     let types = checker(*e, \"type\");\n@@ -1359,7 +1359,7 @@ fn check_fn(e: env, sp: span, f: ast::_fn) {\n     ensure_unique(e, sp, f.decl.inputs, arg_name, \"argument\");\n }\n \n-fn check_expr(e: @env, ex: @ast::expr, x: (), v: vt<()>) {\n+fn check_expr(e: @env, ex: @ast::expr, &&x: (), v: vt<()>) {\n     alt ex.node {\n       ast::expr_rec(fields, _) {\n         fn field_name(f: ast::field) -> ident { ret f.node.ident; }\n@@ -1370,7 +1370,7 @@ fn check_expr(e: @env, ex: @ast::expr, x: (), v: vt<()>) {\n     visit::visit_expr(ex, x, v);\n }\n \n-fn check_ty(e: @env, ty: @ast::ty, x: (), v: vt<()>) {\n+fn check_ty(e: @env, ty: @ast::ty, &&x: (), v: vt<()>) {\n     alt ty.node {\n       ast::ty_rec(fields) {\n         fn field_name(f: ast::ty_field) -> ident { ret f.node.ident; }"}, {"sha": "294c9dfd15e0a40084c938f04191b77ed549a8a8", "filename": "src/comp/middle/trans.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/f9fbd86f52cf597b85359ade1ca60b8d6ebf7286/src%2Fcomp%2Fmiddle%2Ftrans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9fbd86f52cf597b85359ade1ca60b8d6ebf7286/src%2Fcomp%2Fmiddle%2Ftrans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans.rs?ref=f9fbd86f52cf597b85359ade1ca60b8d6ebf7286", "patch": "@@ -3699,7 +3699,7 @@ fn trans_arg_expr(cx: @block_ctxt, arg: ty::arg, lldestty0: TypeRef,\n         // be inspected. It's important for the value\n         // to have type lldestty0 (the callee's expected type).\n         val = llvm::LLVMGetUndef(lldestty0);\n-    } else if arg.mode == ast::by_ref {\n+    } else if arg.mode == ast::by_ref || arg.mode == ast::by_val {\n         let copied = false;\n         if !lv.is_mem && type_is_immediate(ccx, e_ty) {\n             val = do_spill_noroot(bcx, val);\n@@ -4439,9 +4439,9 @@ fn lval_to_dps(bcx: @block_ctxt, e: @ast::expr, dest: dest) -> @block_ctxt {\n // latter group \"immediates\" and, in some circumstances when we know we have a\n // pointer (or need one), perform load/store operations based on the\n // immediate-ness of the type.\n+// FIXME simply call the version in ty.rs immediately\n fn type_is_immediate(ccx: @crate_ctxt, t: ty::t) -> bool {\n-    ret ty::type_is_scalar(ccx.tcx, t) || ty::type_is_boxed(ccx.tcx, t) ||\n-        ty::type_is_unique_box(ccx.tcx, t) || ty::type_is_native(ccx.tcx, t);\n+    ty::type_is_immediate(ccx.tcx, t)\n }\n \n fn do_spill(cx: @block_ctxt, v: ValueRef, t: ty::t) -> result {\n@@ -5144,7 +5144,11 @@ fn copy_args_to_allocas(fcx: @fn_ctxt, bcx: @block_ctxt, args: [ast::arg],\n     for aarg: ast::arg in args {\n         let arg_ty = arg_tys[arg_n].ty;\n         alt aarg.mode {\n-          ast::by_ref. {\n+          ast::by_move. {\n+            add_clean(bcx, fcx.llargs.get(aarg.id), arg_ty);\n+          }\n+          ast::by_mut_ref. { }\n+          _ {\n             let mutated =\n                 !ignore_mut && fcx.lcx.ccx.mut_map.contains_key(aarg.id);\n \n@@ -5160,10 +5164,6 @@ fn copy_args_to_allocas(fcx: @fn_ctxt, bcx: @block_ctxt, args: [ast::arg],\n                 add_clean(bcx, alloc, arg_ty);\n             }\n           }\n-          ast::by_move. {\n-            add_clean(bcx, fcx.llargs.get(aarg.id), arg_ty);\n-          }\n-          _ { }\n         }\n         arg_n += 1u;\n     }\n@@ -5790,7 +5790,7 @@ fn register_native_fn(ccx: @crate_ctxt, sp: span, path: [str], name: str,\n     }\n     fn convert_arg_to_i32(cx: @block_ctxt, v: ValueRef, t: ty::t,\n                           mode: ty::mode) -> ValueRef {\n-        if mode == ast::by_ref {\n+        if mode == ast::by_ref || mode == ast::by_val {\n             if ty::type_is_integral(bcx_tcx(cx), t) {\n                 // FIXME: would be nice to have a postcondition that says\n                 // if a type is integral, then it has static size (#586)\n@@ -5845,7 +5845,7 @@ fn register_native_fn(ccx: @crate_ctxt, sp: span, path: [str], name: str,\n     let i = arg_n;\n     for arg: ty::arg in args {\n         let llarg = llvm::LLVMGetParam(fcx.llfn, i);\n-        if arg.mode == ast::by_ref {\n+        if arg.mode == ast::by_ref || arg.mode == ast::by_val {\n             llarg = load_if_immediate(bcx, llarg, arg.ty);\n         }\n         assert (llarg as int != 0);"}, {"sha": "b9152d30ad2ec141fcd8b1e9308c2aa652c0701a", "filename": "src/comp/middle/trans_objects.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/f9fbd86f52cf597b85359ade1ca60b8d6ebf7286/src%2Fcomp%2Fmiddle%2Ftrans_objects.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9fbd86f52cf597b85359ade1ca60b8d6ebf7286/src%2Fcomp%2Fmiddle%2Ftrans_objects.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans_objects.rs?ref=f9fbd86f52cf597b85359ade1ca60b8d6ebf7286", "patch": "@@ -41,7 +41,8 @@ fn trans_obj(cx: @local_ctxt, sp: span, ob: ast::_obj, ctor_id: ast::node_id,\n     // we're creating.\n     let fn_args: [ast::arg] = [];\n     for f: ast::obj_field in ob.fields {\n-        fn_args += [{mode: ast::by_ref, ty: f.ty, ident: f.ident, id: f.id}];\n+        fn_args += [{mode: ast::by_ref, ty: f.ty, ident: f.ident,\n+                     id: f.id}];\n     }\n     let fcx = new_fn_ctxt(cx, sp, llctor_decl);\n \n@@ -397,7 +398,7 @@ tag vtbl_mthd {\n }\n \n // Alphabetize ast::methods by ident.  A helper for create_vtbl.\n-fn ast_mthd_lteq(a: @ast::method, b: @ast::method) -> bool {\n+fn ast_mthd_lteq(&&a: @ast::method, &&b: @ast::method) -> bool {\n     ret str::lteq(a.node.ident, b.node.ident);\n }\n "}, {"sha": "036cf8ab0cec0f7e54a07a0860a9600677b65fe0", "filename": "src/comp/middle/tstate/pre_post_conditions.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/f9fbd86f52cf597b85359ade1ca60b8d6ebf7286/src%2Fcomp%2Fmiddle%2Ftstate%2Fpre_post_conditions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9fbd86f52cf597b85359ade1ca60b8d6ebf7286/src%2Fcomp%2Fmiddle%2Ftstate%2Fpre_post_conditions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftstate%2Fpre_post_conditions.rs?ref=f9fbd86f52cf597b85359ade1ca60b8d6ebf7286", "patch": "@@ -99,10 +99,10 @@ fn find_pre_post_exprs(fcx: fn_ctxt, args: [@expr], id: node_id) {\n     fn get_pp(ccx: crate_ctxt, e: @expr) -> pre_and_post {\n         ret expr_pp(ccx, e);\n     }\n-    let pps = vec::map::<@expr, pre_and_post>(bind get_pp(fcx.ccx, _), args);\n+    let pps = vec::map_imm(bind get_pp(fcx.ccx, _), args);\n \n     set_pre_and_post(fcx.ccx, id, seq_preconds(fcx, pps),\n-                     seq_postconds(fcx, vec::map(get_post, pps)));\n+                     seq_postconds(fcx, vec::map_imm(get_post, pps)));\n }\n \n fn find_pre_post_loop(fcx: fn_ctxt, l: @local, index: @expr, body: blk,\n@@ -476,8 +476,8 @@ fn find_pre_post_expr(fcx: fn_ctxt, e: @expr) {\n         }\n         let alt_pps = [];\n         for a: arm in alts { alt_pps += [do_an_alt(fcx, a)]; }\n-        fn combine_pp(antec: pre_and_post, fcx: fn_ctxt, pp: pre_and_post,\n-                      next: pre_and_post) -> pre_and_post {\n+        fn combine_pp(antec: pre_and_post, fcx: fn_ctxt, &&pp: pre_and_post,\n+                      &&next: pre_and_post) -> pre_and_post {\n             union(pp.precondition, seq_preconds(fcx, [antec, next]));\n             intersect(pp.postcondition, next.postcondition);\n             ret pp;\n@@ -694,7 +694,7 @@ fn find_pre_post_block(fcx: fn_ctxt, b: blk) {\n         */\n     }\n     for s: @stmt in b.node.stmts { do_one_(fcx, s); }\n-    fn do_inner_(fcx: fn_ctxt, e: @expr) { find_pre_post_expr(fcx, e); }\n+    fn do_inner_(fcx: fn_ctxt, &&e: @expr) { find_pre_post_expr(fcx, e); }\n     let do_inner = bind do_inner_(fcx, _);\n     option::map::<@expr, ()>(do_inner, b.node.expr);\n "}, {"sha": "faf11cb691a4f4ec6775eee9fe1eb4f0fa9f16aa", "filename": "src/comp/middle/ty.rs", "status": "modified", "additions": 19, "deletions": 15, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/f9fbd86f52cf597b85359ade1ca60b8d6ebf7286/src%2Fcomp%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9fbd86f52cf597b85359ade1ca60b8d6ebf7286/src%2Fcomp%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fty.rs?ref=f9fbd86f52cf597b85359ade1ca60b8d6ebf7286", "patch": "@@ -160,6 +160,7 @@ export type_is_native;\n export type_is_nil;\n export type_is_pod;\n export type_is_scalar;\n+export type_is_immediate;\n export type_is_sequence;\n export type_is_signed;\n export type_is_structural;\n@@ -916,6 +917,12 @@ pure fn type_is_scalar(cx: ctxt, ty: t) -> bool {\n     }\n }\n \n+// FIXME maybe inline this for speed?\n+fn type_is_immediate(cx: ctxt, ty: t) -> bool {\n+    ret type_is_scalar(cx, ty) || type_is_boxed(cx, ty) ||\n+        type_is_unique_box(cx, ty) || type_is_native(cx, ty);\n+}\n+\n fn type_has_pointers(cx: ctxt, ty: t) -> bool {\n     alt cx.has_pointer_cache.find(ty) {\n       some(result) { ret result; }\n@@ -924,14 +931,8 @@ fn type_has_pointers(cx: ctxt, ty: t) -> bool {\n \n     let result = false;\n     alt struct(cx, ty) {\n-\n-\n-\n       // scalar types\n-      ty_nil. {\n-        /* no-op */\n-\n-      }\n+      ty_nil. {/* no-op */ }\n       ty_bot. {/* no-op */ }\n       ty_bool. {/* no-op */ }\n       ty_int. {/* no-op */ }\n@@ -1446,14 +1447,14 @@ fn hash_type_info(st: sty, cname_opt: option::t<str>) -> uint {\n     ret h;\n }\n \n-fn hash_raw_ty(rt: @raw_t) -> uint { ret rt.hash; }\n+fn hash_raw_ty(&&rt: @raw_t) -> uint { ret rt.hash; }\n \n-fn hash_ty(typ: t) -> uint { ret typ; }\n+fn hash_ty(&&typ: t) -> uint { ret typ; }\n \n \n // Type equality. This function is private to this module (and slow); external\n // users should use `eq_ty()` instead.\n-fn eq_int(x: uint, y: uint) -> bool { ret x == y; }\n+fn eq_int(&&x: uint, &&y: uint) -> bool { ret x == y; }\n \n fn arg_eq<T>(eq: fn(T, T) -> bool, a: @sp_constr_arg<T>, b: @sp_constr_arg<T>)\n    -> bool {\n@@ -1495,7 +1496,7 @@ fn constrs_eq(cs: [@constr], ds: [@constr]) -> bool {\n \n // An expensive type equality function. This function is private to this\n // module.\n-fn eq_raw_ty(a: @raw_t, b: @raw_t) -> bool {\n+fn eq_raw_ty(&&a: @raw_t, &&b: @raw_t) -> bool {\n     // Check hashes (fast path).\n \n     if a.hash != b.hash { ret false; }\n@@ -1518,7 +1519,7 @@ fn eq_raw_ty(a: @raw_t, b: @raw_t) -> bool {\n \n // This is the equality function the public should use. It works as long as\n // the types are interned.\n-fn eq_ty(a: t, b: t) -> bool { ret a == b; }\n+fn eq_ty(&&a: t, &&b: t) -> bool { ret a == b; }\n \n \n // Type lookups\n@@ -1954,12 +1955,15 @@ mod unify {\n             let actual_input = actual_inputs[i];\n             // Unify the result modes.\n \n-            let result_mode;\n-            if expected_input.mode != actual_input.mode {\n+            let result_mode = if expected_input.mode == ast::mode_infer {\n+                actual_input.mode\n+            } else if actual_input.mode == ast::mode_infer {\n+                expected_input.mode\n+            } else if expected_input.mode != actual_input.mode {\n                 ret fn_common_res_err\n                     (ures_err(terr_mode_mismatch(expected_input.mode,\n                                                  actual_input.mode)));\n-            } else { result_mode = expected_input.mode; }\n+            } else { expected_input.mode };\n             let result = unify_step(cx, expected_input.ty, actual_input.ty);\n             alt result {\n               ures_ok(rty) { result_ins += [{mode: result_mode, ty: rty}]; }"}, {"sha": "088e6eec6f56883c107994c243c04c9a05563bff", "filename": "src/comp/middle/typeck.rs", "status": "modified", "additions": 39, "deletions": 20, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/f9fbd86f52cf597b85359ade1ca60b8d6ebf7286/src%2Fcomp%2Fmiddle%2Ftypeck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9fbd86f52cf597b85359ade1ca60b8d6ebf7286/src%2Fcomp%2Fmiddle%2Ftypeck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftypeck.rs?ref=f9fbd86f52cf597b85359ade1ca60b8d6ebf7286", "patch": "@@ -224,7 +224,27 @@ fn type_is_scalar(fcx: @fn_ctxt, sp: span, typ: ty::t) -> bool {\n // Parses the programmer's textual representation of a type into our internal\n // notion of a type. `getter` is a function that returns the type\n // corresponding to a definition ID:\n+fn default_arg_mode_for_ty(tcx: ty::ctxt, m: ast::mode,\n+                           ty: ty::t) -> ast::mode {\n+    alt m {\n+      ast::mode_infer. {\n+        alt ty::struct(tcx, ty) {\n+            ty::ty_var(_) { ast::mode_infer }\n+            _ {\n+                if ty::type_is_immediate(tcx, ty) { ast::by_val }\n+                else { ast::by_ref }\n+            }\n+        }\n+      }\n+      _ { m }\n+    }\n+}\n fn ast_ty_to_ty(tcx: ty::ctxt, getter: ty_getter, ast_ty: @ast::ty) -> ty::t {\n+    fn ast_arg_to_arg(tcx: ty::ctxt, getter: ty_getter, arg: ast::ty_arg)\n+        -> {mode: ty::mode, ty: ty::t} {\n+        let ty = ast_ty_to_ty(tcx, getter, arg.node.ty);\n+        ret {mode: default_arg_mode_for_ty(tcx, arg.node.mode, ty), ty: ty};\n+    }\n     alt tcx.ast_ty_to_ty_cache.find(ast_ty) {\n       some(some(ty)) { ret ty; }\n       some(none.) {\n@@ -237,10 +257,6 @@ fn ast_ty_to_ty(tcx: ty::ctxt, getter: ty_getter, ast_ty: @ast::ty) -> ty::t {\n     } /* go on */\n \n     tcx.ast_ty_to_ty_cache.insert(ast_ty, none::<ty::t>);\n-    fn ast_arg_to_arg(tcx: ty::ctxt, getter: ty_getter, arg: ast::ty_arg) ->\n-       {mode: ty::mode, ty: ty::t} {\n-        ret {mode: arg.node.mode, ty: ast_ty_to_ty(tcx, getter, arg.node.ty)};\n-    }\n     fn ast_mt_to_mt(tcx: ty::ctxt, getter: ty_getter, mt: ast::mt) -> ty::mt {\n         ret {ty: ast_ty_to_ty(tcx, getter, mt.ty), mut: mt.mut};\n     }\n@@ -295,7 +311,7 @@ fn ast_ty_to_ty(tcx: ty::ctxt, getter: ty_getter, ast_ty: @ast::ty) -> ty::t {\n         typ = ty::mk_ptr(tcx, ast_mt_to_mt(tcx, getter, mt));\n       }\n       ast::ty_tup(fields) {\n-        let flds = vec::map(bind ast_ty_to_ty(tcx, getter, _), fields);\n+        let flds = vec::map_imm(bind ast_ty_to_ty(tcx, getter, _), fields);\n         typ = ty::mk_tup(tcx, flds);\n       }\n       ast::ty_rec(fields) {\n@@ -550,9 +566,8 @@ mod collect {\n         ret tpt;\n     }\n     fn ty_of_arg(cx: @ctxt, a: ast::arg) -> ty::arg {\n-        let f = bind getter(cx, _);\n-        let tt = ast_ty_to_ty(cx.tcx, f, a.ty);\n-        ret {mode: a.mode, ty: tt};\n+        let ty = ast_ty_to_ty(cx.tcx, bind getter(cx, _), a.ty);\n+        {mode: default_arg_mode_for_ty(cx.tcx, a.mode, ty), ty: ty}\n     }\n     fn ty_of_method(cx: @ctxt, m: @ast::method) -> ty::method {\n         let get = bind getter(cx, _);\n@@ -1216,15 +1231,15 @@ fn gather_locals(ccx: @crate_ctxt, f: ast::_fn, id: ast::node_id,\n \n     // Add explicitly-declared locals.\n     let visit_local =\n-        lambda (local: @ast::local, e: (), v: visit::vt<()>) {\n+        lambda (local: @ast::local, &&e: (), v: visit::vt<()>) {\n             let local_ty = ast_ty_to_ty_crate_infer(ccx, local.node.ty);\n             assign(local.node.id, ident_for_local(local), local_ty);\n             visit::visit_local(local, e, v);\n         };\n \n     // Add pattern bindings.\n     let visit_pat =\n-        lambda (p: @ast::pat, e: (), v: visit::vt<()>) {\n+        lambda (p: @ast::pat, &&e: (), v: visit::vt<()>) {\n             alt p.node {\n               ast::pat_bind(ident) { assign(p.id, ident, none); }\n               _ {/* no-op */ }\n@@ -2022,16 +2037,16 @@ fn check_expr_with_unifier(fcx: @fn_ctxt, expr: @ast::expr, unify: unifier,\n         write::ty_only_fixup(fcx, id, result_ty);\n       }\n       ast::expr_fn(f) {\n-        let cx = @{tcx: tcx};\n         let convert = bind ast_ty_to_ty_crate_tyvar(fcx, _);\n-        let ty_of_arg =\n-            lambda (a: ast::arg) -> ty::arg {\n-                let tt = ast_ty_to_ty_crate_tyvar(fcx, a.ty);\n-                ret {mode: a.mode, ty: tt};\n-            };\n-        let fty =\n-            collect::ty_of_fn_decl(cx, convert, ty_of_arg, f.decl, f.proto,\n-                                   [], none).ty;\n+        let ty_of_arg = lambda (a: ast::arg) -> ty::arg {\n+            let tt = ast_ty_to_ty_crate_tyvar(fcx, a.ty);\n+            ret {mode: default_arg_mode_for_ty(fcx.ccx.tcx, a.mode, tt),\n+                 ty: tt};\n+        };\n+        let cx = @{tcx: tcx};\n+        let fty = collect::ty_of_fn_decl(cx, convert, ty_of_arg, f.decl,\n+                                         f.proto, [], none).ty;\n+\n         write::ty_only_fixup(fcx, id, fty);\n \n         // Unify the type of the function with the expected type before we\n@@ -2041,6 +2056,9 @@ fn check_expr_with_unifier(fcx: @fn_ctxt, expr: @ast::expr, unify: unifier,\n         unify(fcx, expr.span, expected, fty);\n \n         check_fn(fcx.ccx, f, id, some(fcx));\n+        if f.proto == ast::proto_block {\n+            write::ty_only_fixup(fcx, id, expected);\n+        }\n       }\n       ast::expr_block(b) {\n         // If this is an unchecked block, turn off purity-checking\n@@ -2301,7 +2319,8 @@ fn check_expr_with_unifier(fcx: @fn_ctxt, expr: @ast::expr, unify: unifier,\n         // FIXME: These next three functions are largely ripped off from\n         // similar ones in collect::.  Is there a better way to do this?\n         fn ty_of_arg(ccx: @crate_ctxt, a: ast::arg) -> ty::arg {\n-            ret {mode: a.mode, ty: ast_ty_to_ty_crate(ccx, a.ty)};\n+            let ty = ast_ty_to_ty_crate(ccx, a.ty);\n+            ret {mode: default_arg_mode_for_ty(ccx.tcx, a.mode, ty), ty: ty};\n         }\n \n         fn ty_of_method(ccx: @crate_ctxt, m: @ast::method) -> ty::method {"}, {"sha": "1864af6de9e11a136a9f86d09b62b0910876eb25", "filename": "src/comp/syntax/ast.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f9fbd86f52cf597b85359ade1ca60b8d6ebf7286/src%2Fcomp%2Fsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9fbd86f52cf597b85359ade1ca60b8d6ebf7286/src%2Fcomp%2Fsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fast.rs?ref=f9fbd86f52cf597b85359ade1ca60b8d6ebf7286", "patch": "@@ -132,7 +132,7 @@ tag unop {\n     deref; not; neg;\n }\n \n-tag mode { by_ref; by_mut_ref; by_move; }\n+tag mode { by_ref; by_val; by_mut_ref; by_move; mode_infer; }\n \n type stmt = spanned<stmt_>;\n "}, {"sha": "d70b63dac67593bfa7774ed12ae0d51cd330ac4b", "filename": "src/comp/syntax/ast_util.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f9fbd86f52cf597b85359ade1ca60b8d6ebf7286/src%2Fcomp%2Fsyntax%2Fast_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9fbd86f52cf597b85359ade1ca60b8d6ebf7286/src%2Fcomp%2Fsyntax%2Fast_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fast_util.rs?ref=f9fbd86f52cf597b85359ade1ca60b8d6ebf7286", "patch": "@@ -180,9 +180,9 @@ fn is_constraint_arg(e: @expr) -> bool {\n     }\n }\n \n-fn eq_ty(a: @ty, b: @ty) -> bool { ret std::box::ptr_eq(a, b); }\n+fn eq_ty(&&a: @ty, &&b: @ty) -> bool { ret std::box::ptr_eq(a, b); }\n \n-fn hash_ty(t: @ty) -> uint { ret t.span.lo << 16u + t.span.hi; }\n+fn hash_ty(&&t: @ty) -> uint { ret t.span.lo << 16u + t.span.hi; }\n \n fn block_from_expr(e: @expr) -> blk {\n     let blk_ = checked_blk([], option::some::<@expr>(e), e.id);"}, {"sha": "5fafcdbb437cb2cd30859adc4ad9577e28a1e200", "filename": "src/comp/syntax/ext/simplext.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f9fbd86f52cf597b85359ade1ca60b8d6ebf7286/src%2Fcomp%2Fsyntax%2Fext%2Fsimplext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9fbd86f52cf597b85359ade1ca60b8d6ebf7286/src%2Fcomp%2Fsyntax%2Fext%2Fsimplext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fext%2Fsimplext.rs?ref=f9fbd86f52cf597b85359ade1ca60b8d6ebf7286", "patch": "@@ -266,7 +266,7 @@ fn transcribe_exprs(cx: ext_ctxt, b: bindings, idx_path: @mutable [uint],\n                     recur: fn(@expr) -> @expr, exprs: [@expr]) -> [@expr] {\n     alt elts_to_ell(cx, exprs) {\n       {pre: pre, rep: repeat_me_maybe, post: post} {\n-        let res = vec::map(recur, pre);\n+        let res = vec::map_imm(recur, pre);\n         alt repeat_me_maybe {\n           none. { }\n           some(repeat_me) {\n@@ -315,7 +315,7 @@ fn transcribe_exprs(cx: ext_ctxt, b: bindings, idx_path: @mutable [uint],\n             }\n           }\n         }\n-        res += vec::map(recur, post);\n+        res += vec::map_imm(recur, post);\n         ret res;\n       }\n     }"}, {"sha": "edee54fb808cd4dbfec15f28b3fb69a09d580de9", "filename": "src/comp/syntax/fold.rs", "status": "modified", "additions": 31, "deletions": 31, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/f9fbd86f52cf597b85359ade1ca60b8d6ebf7286/src%2Fcomp%2Fsyntax%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9fbd86f52cf597b85359ade1ca60b8d6ebf7286/src%2Fcomp%2Fsyntax%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Ffold.rs?ref=f9fbd86f52cf597b85359ade1ca60b8d6ebf7286", "patch": "@@ -110,7 +110,7 @@ fn fold_meta_item_(mi: @meta_item, fld: ast_fold) -> @meta_item {\n                 meta_word(id) { meta_word(fld.fold_ident(id)) }\n                 meta_list(id, mis) {\n                   let fold_meta_item = bind fold_meta_item_(_, fld);\n-                  meta_list(id, vec::map(fold_meta_item, mis))\n+                  meta_list(id, vec::map_imm(fold_meta_item, mis))\n                 }\n                 meta_name_value(id, s) {\n                   meta_name_value(fld.fold_ident(id), s)\n@@ -153,10 +153,10 @@ fn noop_fold_crate(c: crate_, fld: ast_fold) -> crate_ {\n     let fold_meta_item = bind fold_meta_item_(_, fld);\n     let fold_attribute = bind fold_attribute_(_, fold_meta_item);\n \n-    ret {directives: vec::map(fld.fold_crate_directive, c.directives),\n+    ret {directives: vec::map_imm(fld.fold_crate_directive, c.directives),\n          module: fld.fold_mod(c.module),\n          attrs: vec::map(fold_attribute, c.attrs),\n-         config: vec::map(fold_meta_item, c.config)};\n+         config: vec::map_imm(fold_meta_item, c.config)};\n }\n \n fn noop_fold_crate_directive(cd: crate_directive_, fld: ast_fold) ->\n@@ -167,7 +167,7 @@ fn noop_fold_crate_directive(cd: crate_directive_, fld: ast_fold) ->\n           }\n           cdir_dir_mod(id, fname, cds, attrs) {\n             cdir_dir_mod(fld.fold_ident(id), fname,\n-                         vec::map(fld.fold_crate_directive, cds), attrs)\n+                         vec::map_imm(fld.fold_crate_directive, cds), attrs)\n           }\n           cdir_view_item(vi) { cdir_view_item(fld.fold_view_item(vi)) }\n           cdir_syntax(_) { cd }\n@@ -198,8 +198,8 @@ fn noop_fold_native_item(ni: @native_item, fld: ast_fold) -> @native_item {\n                                   il: fdec.il,\n                                   cf: fdec.cf,\n                                   constraints:\n-                                      vec::map(fld.fold_constr,\n-                                               fdec.constraints)}, typms)\n+                                      vec::map_imm(fld.fold_constr,\n+                                                   fdec.constraints)}, typms)\n                 }\n               },\n           id: ni.id,\n@@ -237,8 +237,8 @@ fn noop_fold_item_underscore(i: item_, fld: ast_fold) -> item_ {\n           }\n           item_obj(o, typms, d) {\n             item_obj({fields: vec::map(fold_obj_field, o.fields),\n-                      methods: vec::map(fld.fold_method, o.methods)}, typms,\n-                     d)\n+                      methods: vec::map_imm(fld.fold_method, o.methods)},\n+                     typms, d)\n           }\n           item_res(dtor, did, typms, cid) {\n             item_res(fld.fold_fn(dtor), did, typms, cid)\n@@ -252,8 +252,8 @@ fn noop_fold_method(m: method_, fld: ast_fold) -> method_ {\n \n \n fn noop_fold_block(b: blk_, fld: ast_fold) -> blk_ {\n-    ret {stmts: vec::map(fld.fold_stmt, b.stmts),\n-         expr: option::map(fld.fold_expr, b.expr),\n+    ret {stmts: vec::map_imm(fld.fold_stmt, b.stmts),\n+         expr: option::map_imm(fld.fold_expr, b.expr),\n          id: b.id,\n          rules: b.rules};\n }\n@@ -269,8 +269,8 @@ fn noop_fold_stmt(s: stmt_, fld: ast_fold) -> stmt_ {\n }\n \n fn noop_fold_arm(a: arm, fld: ast_fold) -> arm {\n-    ret {pats: vec::map(fld.fold_pat, a.pats),\n-         guard: option::map(fld.fold_expr, a.guard),\n+    ret {pats: vec::map_imm(fld.fold_pat, a.pats),\n+         guard: option::map_imm(fld.fold_expr, a.guard),\n          body: fld.fold_block(a.body)};\n }\n \n@@ -280,7 +280,7 @@ fn noop_fold_pat(p: pat_, fld: ast_fold) -> pat_ {\n           pat_bind(ident) { pat_bind(fld.fold_ident(ident)) }\n           pat_lit(_) { p }\n           pat_tag(pth, pats) {\n-            pat_tag(fld.fold_path(pth), vec::map(fld.fold_pat, pats))\n+            pat_tag(fld.fold_path(pth), vec::map_imm(fld.fold_pat, pats))\n           }\n           pat_rec(fields, etc) {\n             let fs = [];\n@@ -289,7 +289,7 @@ fn noop_fold_pat(p: pat_, fld: ast_fold) -> pat_ {\n             }\n             pat_rec(fs, etc)\n           }\n-          pat_tup(elts) { pat_tup(vec::map(fld.fold_pat, elts)) }\n+          pat_tup(elts) { pat_tup(vec::map_imm(fld.fold_pat, elts)) }\n           pat_box(inner) { pat_box(fld.fold_pat(inner)) }\n           pat_uniq(inner) { pat_uniq(fld.fold_pat(inner)) }\n           pat_range(_, _) { p }\n@@ -334,8 +334,8 @@ fn noop_fold_expr(e: expr_, fld: ast_fold) -> expr_ {\n                      option::some(vec::map(fold_anon_obj_field, v))\n                    }\n                  },\n-             methods: vec::map(fld.fold_method, ao.methods),\n-             inner_obj: option::map(fld.fold_expr, ao.inner_obj)}\n+             methods: vec::map_imm(fld.fold_method, ao.methods),\n+             inner_obj: option::map_imm(fld.fold_expr, ao.inner_obj)}\n     }\n     let fold_anon_obj = bind fold_anon_obj_(_, fld);\n \n@@ -347,15 +347,15 @@ fn noop_fold_expr(e: expr_, fld: ast_fold) -> expr_ {\n           }\n           expr_rec(fields, maybe_expr) {\n             expr_rec(vec::map(fold_field, fields),\n-                     option::map(fld.fold_expr, maybe_expr))\n+                     option::map_imm(fld.fold_expr, maybe_expr))\n           }\n-          expr_tup(elts) { expr_tup(vec::map(fld.fold_expr, elts)) }\n+          expr_tup(elts) { expr_tup(vec::map_imm(fld.fold_expr, elts)) }\n           expr_call(f, args) {\n             expr_call(fld.fold_expr(f), fld.map_exprs(fld.fold_expr, args))\n           }\n           expr_self_method(id) { expr_self_method(fld.fold_ident(id)) }\n           expr_bind(f, args) {\n-            let opt_map_se = bind option::map(fld.fold_expr, _);\n+            let opt_map_se = bind option::map_imm(fld.fold_expr, _);\n             expr_bind(fld.fold_expr(f), vec::map(opt_map_se, args))\n           }\n           expr_binary(binop, lhs, rhs) {\n@@ -366,7 +366,7 @@ fn noop_fold_expr(e: expr_, fld: ast_fold) -> expr_ {\n           expr_cast(expr, ty) { expr_cast(fld.fold_expr(expr), ty) }\n           expr_if(cond, tr, fl) {\n             expr_if(fld.fold_expr(cond), fld.fold_block(tr),\n-                    option::map(fld.fold_expr, fl))\n+                    option::map_imm(fld.fold_expr, fl))\n           }\n           expr_ternary(cond, tr, fl) {\n             expr_ternary(fld.fold_expr(cond), fld.fold_expr(tr),\n@@ -411,18 +411,18 @@ fn noop_fold_expr(e: expr_, fld: ast_fold) -> expr_ {\n             expr_index(fld.fold_expr(el), fld.fold_expr(er))\n           }\n           expr_path(pth) { expr_path(fld.fold_path(pth)) }\n-          expr_fail(e) { expr_fail(option::map(fld.fold_expr, e)) }\n+          expr_fail(e) { expr_fail(option::map_imm(fld.fold_expr, e)) }\n           expr_break. { e }\n           expr_cont. { e }\n-          expr_ret(e) { expr_ret(option::map(fld.fold_expr, e)) }\n-          expr_put(e) { expr_put(option::map(fld.fold_expr, e)) }\n+          expr_ret(e) { expr_ret(option::map_imm(fld.fold_expr, e)) }\n+          expr_put(e) { expr_put(option::map_imm(fld.fold_expr, e)) }\n           expr_be(e) { expr_be(fld.fold_expr(e)) }\n           expr_log(lv, e) { expr_log(lv, fld.fold_expr(e)) }\n           expr_assert(e) { expr_assert(fld.fold_expr(e)) }\n           expr_check(m, e) { expr_check(m, fld.fold_expr(e)) }\n           expr_if_check(cond, tr, fl) {\n             expr_if_check(fld.fold_expr(cond), fld.fold_block(tr),\n-                          option::map(fld.fold_expr, fl))\n+                          option::map_imm(fld.fold_expr, fl))\n           }\n           expr_anon_obj(ao) { expr_anon_obj(fold_anon_obj(ao)) }\n           expr_mac(mac) { expr_mac(fold_mac(mac)) }\n@@ -448,22 +448,22 @@ fn noop_fold_fn(f: _fn, fld: ast_fold) -> _fn {\n               purity: f.decl.purity,\n               il: f.decl.il,\n               cf: f.decl.cf,\n-              constraints: vec::map(fld.fold_constr, f.decl.constraints)},\n+              constraints: vec::map_imm(fld.fold_constr, f.decl.constraints)},\n          proto: f.proto,\n          body: fld.fold_block(f.body)};\n }\n \n // ...nor do modules\n fn noop_fold_mod(m: _mod, fld: ast_fold) -> _mod {\n-    ret {view_items: vec::map(fld.fold_view_item, m.view_items),\n-         items: vec::map(fld.fold_item, m.items)};\n+    ret {view_items: vec::map_imm(fld.fold_view_item, m.view_items),\n+         items: vec::map_imm(fld.fold_item, m.items)};\n }\n \n fn noop_fold_native_mod(nm: native_mod, fld: ast_fold) -> native_mod {\n     ret {native_name: nm.native_name,\n          abi: nm.abi,\n-         view_items: vec::map(fld.fold_view_item, nm.view_items),\n-         items: vec::map(fld.fold_native_item, nm.items)}\n+         view_items: vec::map_imm(fld.fold_view_item, nm.view_items),\n+         items: vec::map_imm(fld.fold_native_item, nm.items)}\n }\n \n fn noop_fold_variant(v: variant_, fld: ast_fold) -> variant_ {\n@@ -479,7 +479,7 @@ fn noop_fold_ident(i: ident, _fld: ast_fold) -> ident { ret i; }\n fn noop_fold_path(p: path_, fld: ast_fold) -> path_ {\n     ret {global: p.global,\n          idents: vec::map(fld.fold_ident, p.idents),\n-         types: vec::map(fld.fold_ty, p.types)};\n+         types: vec::map_imm(fld.fold_ty, p.types)};\n }\n \n fn noop_fold_local(l: local_, fld: ast_fold) -> local_ {\n@@ -499,7 +499,7 @@ fn noop_fold_local(l: local_, fld: ast_fold) -> local_ {\n /* temporarily eta-expand because of a compiler bug with using `fn<T>` as a\n    value */\n fn noop_map_exprs(f: fn(@expr) -> @expr, es: [@expr]) -> [@expr] {\n-    ret vec::map(f, es);\n+    ret vec::map_imm(f, es);\n }\n \n fn noop_id(i: node_id) -> node_id { ret i; }"}, {"sha": "e220149f6f8168ef71c11259321d8818297e9725", "filename": "src/comp/syntax/parse/parser.rs", "status": "modified", "additions": 7, "deletions": 12, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/f9fbd86f52cf597b85359ade1ca60b8d6ebf7286/src%2Fcomp%2Fsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9fbd86f52cf597b85359ade1ca60b8d6ebf7286/src%2Fcomp%2Fsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fparse%2Fparser.rs?ref=f9fbd86f52cf597b85359ade1ca60b8d6ebf7286", "patch": "@@ -587,17 +587,11 @@ fn parse_ty(p: parser, colons_before_params: bool) -> @ast::ty {\n }\n \n fn parse_arg_mode(p: parser) -> ast::mode {\n-    if eat(p, token::BINOP(token::AND)) {\n-        ret ast::by_mut_ref;\n-    } else if eat(p, token::BINOP(token::MINUS)) {\n-        ret ast::by_move;\n-    } else {\n-        // FIXME Temporarily ignore these, to make it possible to implement\n-        // them without breaking the stage0 build.\n-        eat(p, token::ANDAND);\n-        eat(p, token::BINOP(token::PLUS));\n-        ret ast::by_ref;\n-    }\n+    if eat(p, token::BINOP(token::AND)) { ast::by_mut_ref }\n+    else if eat(p, token::BINOP(token::MINUS)) { ast::by_move }\n+    else if eat(p, token::ANDAND) { ast::by_ref }\n+    else if eat(p, token::BINOP(token::PLUS)) { ast::by_val }\n+    else { ast::mode_infer }\n }\n \n fn parse_arg(p: parser) -> ast::arg {\n@@ -1890,7 +1884,8 @@ fn parse_item_res(p: parser, attrs: [ast::attribute]) -> @ast::item {\n     let dtor = parse_block_no_value(p);\n     let decl =\n         {inputs:\n-             [{mode: ast::by_ref, ty: t, ident: arg_ident, id: p.get_id()}],\n+             [{mode: ast::by_ref, ty: t, ident: arg_ident,\n+               id: p.get_id()}],\n          output: @spanned(lo, lo, ast::ty_nil),\n          purity: ast::impure_fn,\n          il: ast::il_normal,"}, {"sha": "a24b4c9b98492fe1e3c7bc597ac5ea248d31b202", "filename": "src/comp/syntax/print/pprust.rs", "status": "modified", "additions": 16, "deletions": 14, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/f9fbd86f52cf597b85359ade1ca60b8d6ebf7286/src%2Fcomp%2Fsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9fbd86f52cf597b85359ade1ca60b8d6ebf7286/src%2Fcomp%2Fsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fprint%2Fpprust.rs?ref=f9fbd86f52cf597b85359ade1ca60b8d6ebf7286", "patch": "@@ -226,7 +226,7 @@ fn commasep_cmnt<IN>(s: ps, b: breaks, elts: [IN], op: fn(ps, IN),\n }\n \n fn commasep_exprs(s: ps, b: breaks, exprs: [@ast::expr]) {\n-    fn expr_span(expr: @ast::expr) -> codemap::span { ret expr.span; }\n+    fn expr_span(&&expr: @ast::expr) -> codemap::span { ret expr.span; }\n     commasep_cmnt(s, b, exprs, print_expr, expr_span);\n }\n \n@@ -246,7 +246,7 @@ fn print_native_mod(s: ps, nmod: ast::native_mod, attrs: [ast::attribute]) {\n     for item: @ast::native_item in nmod.items { print_native_item(s, item); }\n }\n \n-fn print_type(s: ps, ty: @ast::ty) {\n+fn print_type(s: ps, &&ty: @ast::ty) {\n     maybe_print_comment(s, ty.span.lo);\n     ibox(s, 0u);\n     alt ty.node {\n@@ -365,7 +365,7 @@ fn print_native_item(s: ps, item: @ast::native_item) {\n     }\n }\n \n-fn print_item(s: ps, item: @ast::item) {\n+fn print_item(s: ps, &&item: @ast::item) {\n     hardbreak_if_not_bol(s);\n     maybe_print_comment(s, item.span.lo);\n     print_outer_attributes(s, item.attrs);\n@@ -678,7 +678,7 @@ fn print_mac(s: ps, m: ast::mac) {\n     }\n }\n \n-fn print_expr(s: ps, expr: @ast::expr) {\n+fn print_expr(s: ps, &&expr: @ast::expr) {\n     maybe_print_comment(s, expr.span.lo);\n     ibox(s, indent_unit);\n     let ann_node = node_expr(s, expr);\n@@ -1080,7 +1080,7 @@ fn print_path(s: ps, path: ast::path, colons_before_params: bool) {\n     }\n }\n \n-fn print_pat(s: ps, pat: @ast::pat) {\n+fn print_pat(s: ps, &&pat: @ast::pat) {\n     maybe_print_comment(s, pat.span.lo);\n     let ann_node = node_pat(s, pat);\n     s.ann.pre(ann_node);\n@@ -1145,7 +1145,7 @@ fn print_fn_args_and_ret(s: ps, decl: ast::fn_decl, constrs: [@ast::constr]) {\n     popen(s);\n     fn print_arg(s: ps, x: ast::arg) {\n         ibox(s, indent_unit);\n-        print_alias(s, x.mode);\n+        print_arg_mode(s, x.mode);\n         word_space(s, x.ident + \":\");\n         print_type(s, x.ty);\n         end(s);\n@@ -1174,7 +1174,7 @@ fn print_fn_block_args(s: ps, decl: ast::fn_decl) {\n     word(s.s, \"|\");\n     fn print_arg(s: ps, x: ast::arg) {\n         ibox(s, indent_unit);\n-        print_alias(s, x.mode);\n+        print_arg_mode(s, x.mode);\n         word(s.s, x.ident);\n         end(s);\n     }\n@@ -1183,11 +1183,13 @@ fn print_fn_block_args(s: ps, decl: ast::fn_decl) {\n     maybe_print_comment(s, decl.output.span.lo);\n }\n \n-fn print_alias(s: ps, m: ast::mode) {\n+fn print_arg_mode(s: ps, m: ast::mode) {\n     alt m {\n       ast::by_mut_ref. { word(s.s, \"&\"); }\n       ast::by_move. { word(s.s, \"-\"); }\n-      ast::by_ref. { }\n+      ast::by_ref. { word(s.s, \"&&\"); }\n+      ast::by_val. { word(s.s, \"+\"); }\n+      ast::mode_infer. {}\n     }\n }\n \n@@ -1211,7 +1213,7 @@ fn print_type_params(s: ps, params: [ast::ty_param]) {\n     }\n }\n \n-fn print_meta_item(s: ps, item: @ast::meta_item) {\n+fn print_meta_item(s: ps, &&item: @ast::meta_item) {\n     ibox(s, indent_unit);\n     alt item.node {\n       ast::meta_word(name) { word(s.s, name); }\n@@ -1351,7 +1353,7 @@ fn print_ty_fn(s: ps, proto: ast::proto, id: option::t<ast::ident>,\n     zerobreak(s.s);\n     popen(s);\n     fn print_arg(s: ps, input: ast::ty_arg) {\n-        print_alias(s, input.node.mode);\n+        print_arg_mode(s, input.node.mode);\n         print_type(s, input.node.ty);\n     }\n     commasep(s, inconsistent, inputs, print_arg);\n@@ -1418,7 +1420,7 @@ fn in_cbox(s: ps) -> bool {\n     ret s.boxes[len - 1u] == pp::consistent;\n }\n \n-fn print_literal(s: ps, lit: @ast::lit) {\n+fn print_literal(s: ps, &&lit: @ast::lit) {\n     maybe_print_comment(s, lit.span.lo);\n     alt next_lit(s) {\n       some(lt) {\n@@ -1596,7 +1598,7 @@ fn constr_arg_to_str<T>(f: fn(T) -> str, c: ast::constr_arg_general_<T>) ->\n // needed b/c constr_args_to_str needs\n // something that takes an alias\n // (argh)\n-fn uint_to_str(i: uint) -> str { ret uint::str(i); }\n+fn uint_to_str(&&i: uint) -> str { ret uint::str(i); }\n \n fn ast_ty_fn_constr_to_str(c: @ast::constr) -> str {\n     ret path_to_str(c.node.path) +\n@@ -1614,7 +1616,7 @@ fn ast_ty_fn_constrs_str(constrs: [@ast::constr]) -> str {\n     ret s;\n }\n \n-fn fn_arg_idx_to_str(decl: ast::fn_decl, idx: uint) -> str {\n+fn fn_arg_idx_to_str(decl: ast::fn_decl, &&idx: uint) -> str {\n     decl.inputs[idx].ident\n }\n "}, {"sha": "f234c2fb221f6843ce13db3d7cb4e0777f9162c9", "filename": "src/comp/syntax/visit.rs", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/f9fbd86f52cf597b85359ade1ca60b8d6ebf7286/src%2Fcomp%2Fsyntax%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9fbd86f52cf597b85359ade1ca60b8d6ebf7286/src%2Fcomp%2Fsyntax%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fvisit.rs?ref=f9fbd86f52cf597b85359ade1ca60b8d6ebf7286", "patch": "@@ -377,62 +377,62 @@ fn default_simple_visitor() -> simple_visitor {\n }\n \n fn mk_simple_visitor(v: simple_visitor) -> vt<()> {\n-    fn v_mod(f: fn(_mod, span), m: _mod, sp: span, e: (), v: vt<()>) {\n+    fn v_mod(f: fn(_mod, span), m: _mod, sp: span, &&e: (), v: vt<()>) {\n         f(m, sp);\n         visit_mod(m, sp, e, v);\n     }\n-    fn v_view_item(f: fn(@view_item), vi: @view_item, e: (), v: vt<()>) {\n+    fn v_view_item(f: fn(@view_item), vi: @view_item, &&e: (), v: vt<()>) {\n         f(vi);\n         visit_view_item(vi, e, v);\n     }\n-    fn v_native_item(f: fn(@native_item), ni: @native_item, e: (),\n+    fn v_native_item(f: fn(@native_item), ni: @native_item, &&e: (),\n                      v: vt<()>) {\n         f(ni);\n         visit_native_item(ni, e, v);\n     }\n-    fn v_item(f: fn(@item), i: @item, e: (), v: vt<()>) {\n+    fn v_item(f: fn(@item), i: @item, &&e: (), v: vt<()>) {\n         f(i);\n         visit_item(i, e, v);\n     }\n-    fn v_local(f: fn(@local), l: @local, e: (), v: vt<()>) {\n+    fn v_local(f: fn(@local), l: @local, &&e: (), v: vt<()>) {\n         f(l);\n         visit_local(l, e, v);\n     }\n-    fn v_block(f: fn(ast::blk), bl: ast::blk, e: (), v: vt<()>) {\n+    fn v_block(f: fn(ast::blk), bl: ast::blk, &&e: (), v: vt<()>) {\n         f(bl);\n         visit_block(bl, e, v);\n     }\n-    fn v_stmt(f: fn(@stmt), st: @stmt, e: (), v: vt<()>) {\n+    fn v_stmt(f: fn(@stmt), st: @stmt, &&e: (), v: vt<()>) {\n         f(st);\n         visit_stmt(st, e, v);\n     }\n-    fn v_arm(f: fn(arm), a: arm, e: (), v: vt<()>) {\n+    fn v_arm(f: fn(arm), a: arm, &&e: (), v: vt<()>) {\n         f(a);\n         visit_arm(a, e, v);\n     }\n-    fn v_pat(f: fn(@pat), p: @pat, e: (), v: vt<()>) {\n+    fn v_pat(f: fn(@pat), p: @pat, &&e: (), v: vt<()>) {\n         f(p);\n         visit_pat(p, e, v);\n     }\n-    fn v_decl(f: fn(@decl), d: @decl, e: (), v: vt<()>) {\n+    fn v_decl(f: fn(@decl), d: @decl, &&e: (), v: vt<()>) {\n         f(d);\n         visit_decl(d, e, v);\n     }\n-    fn v_expr(f: fn(@expr), ex: @expr, e: (), v: vt<()>) {\n+    fn v_expr(f: fn(@expr), ex: @expr, &&e: (), v: vt<()>) {\n         f(ex);\n         visit_expr(ex, e, v);\n     }\n-    fn v_ty(f: fn(@ty), ty: @ty, e: (), v: vt<()>) {\n+    fn v_ty(f: fn(@ty), ty: @ty, &&e: (), v: vt<()>) {\n         f(ty);\n         visit_ty(ty, e, v);\n     }\n     fn v_constr(f: fn(path, span, node_id), pt: path, sp: span, id: node_id,\n-                e: (), v: vt<()>) {\n+                &&e: (), v: vt<()>) {\n         f(pt, sp, id);\n         visit_constr(pt, sp, id, e, v);\n     }\n     fn v_fn(f: fn(_fn, [ty_param], span, fn_ident, node_id), ff: _fn,\n-            tps: [ty_param], sp: span, ident: fn_ident, id: node_id, e: (),\n+            tps: [ty_param], sp: span, ident: fn_ident, id: node_id, &&e: (),\n             v: vt<()>) {\n         f(ff, tps, sp, ident, id);\n         visit_fn(ff, tps, sp, ident, id, e, v);"}, {"sha": "3502eb80a06e5bb4c1f7800e1c3f5431b4ec06e0", "filename": "src/comp/util/ppaux.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f9fbd86f52cf597b85359ade1ca60b8d6ebf7286/src%2Fcomp%2Futil%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9fbd86f52cf597b85359ade1ca60b8d6ebf7286/src%2Fcomp%2Futil%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Futil%2Fppaux.rs?ref=f9fbd86f52cf597b85359ade1ca60b8d6ebf7286", "patch": "@@ -13,9 +13,11 @@ import metadata::csearch;\n \n fn mode_str(m: ty::mode) -> str {\n     alt m {\n-      ast::by_ref. { \"\" }\n+      ast::by_ref. { \"&&\" }\n+      ast::by_val. { \"+\" }\n       ast::by_mut_ref. { \"&\" }\n       ast::by_move. { \"-\" }\n+      _ { \"\" }\n     }\n }\n "}, {"sha": "d8f7f36b24f6e831c9cea04cb5f99550ec60ebf4", "filename": "src/lib/io.rs", "status": "modified", "additions": 5, "deletions": 8, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/f9fbd86f52cf597b85359ade1ca60b8d6ebf7286/src%2Flib%2Fio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9fbd86f52cf597b85359ade1ca60b8d6ebf7286/src%2Flib%2Fio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Fio.rs?ref=f9fbd86f52cf597b85359ade1ca60b8d6ebf7286", "patch": "@@ -175,14 +175,11 @@ fn stdin() -> reader {\n }\n \n fn file_reader(path: str) -> reader {\n-    let f =\n-        str::as_buf(path,\n-                    {|pathbuf|\n-                        str::as_buf(\"r\",\n-                                    {|modebuf|\n-                                        os::libc::fopen(pathbuf, modebuf)\n-                                    })\n-                    });\n+    let f = str::as_buf(path, {|pathbuf|\n+        str::as_buf(\"r\", {|modebuf|\n+            os::libc::fopen(pathbuf, modebuf)\n+        })\n+    });\n     if f as uint == 0u { log_err \"error opening \" + path; fail; }\n     ret new_reader(FILE_buf_reader(f, option::some(@FILE_res(f))));\n }"}, {"sha": "58f976110d9ff47b3746c65093450633d8252065", "filename": "src/lib/list.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f9fbd86f52cf597b85359ade1ca60b8d6ebf7286/src%2Flib%2Flist.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9fbd86f52cf597b85359ade1ca60b8d6ebf7286/src%2Flib%2Flist.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Flist.rs?ref=f9fbd86f52cf597b85359ade1ca60b8d6ebf7286", "patch": "@@ -49,7 +49,7 @@ fn has<@T>(ls_: list<T>, elt: T) -> bool {\n }\n \n fn length<@T>(ls: list<T>) -> uint {\n-    fn count<T>(_t: T, u: uint) -> uint { ret u + 1u; }\n+    fn count<T>(_t: T, &&u: uint) -> uint { ret u + 1u; }\n     ret foldl(ls, 0u, count);\n }\n "}, {"sha": "c63183b18930a83cee4bd873f0872f656bdbd4f1", "filename": "src/lib/map.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/f9fbd86f52cf597b85359ade1ca60b8d6ebf7286/src%2Flib%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9fbd86f52cf597b85359ade1ca60b8d6ebf7286/src%2Flib%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Fmap.rs?ref=f9fbd86f52cf597b85359ade1ca60b8d6ebf7286", "patch": "@@ -199,14 +199,14 @@ fn new_str_hash<@V>() -> hashmap<str, V> {\n }\n \n fn new_int_hash<@V>() -> hashmap<int, V> {\n-    fn hash_int(x: int) -> uint { ret x as uint; }\n-    fn eq_int(a: int, b: int) -> bool { ret a == b; }\n+    fn hash_int(&&x: int) -> uint { ret x as uint; }\n+    fn eq_int(&&a: int, &&b: int) -> bool { ret a == b; }\n     ret mk_hashmap(hash_int, eq_int);\n }\n \n fn new_uint_hash<@V>() -> hashmap<uint, V> {\n-    fn hash_uint(x: uint) -> uint { ret x; }\n-    fn eq_uint(a: uint, b: uint) -> bool { ret a == b; }\n+    fn hash_uint(&&x: uint) -> uint { ret x; }\n+    fn eq_uint(&&a: uint, &&b: uint) -> bool { ret a == b; }\n     ret mk_hashmap(hash_uint, eq_uint);\n }\n "}, {"sha": "56b56b5f69f100280d699cb3d384a3f033fefdb5", "filename": "src/lib/option.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/f9fbd86f52cf597b85359ade1ca60b8d6ebf7286/src%2Flib%2Foption.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9fbd86f52cf597b85359ade1ca60b8d6ebf7286/src%2Flib%2Foption.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Foption.rs?ref=f9fbd86f52cf597b85359ade1ca60b8d6ebf7286", "patch": "@@ -9,6 +9,11 @@ fn get<@T>(opt: t<T>) -> &T {\n fn map<@T, @U>(f: block(T) -> U, opt: t<T>) -> t<U> {\n     alt opt { some(x) { some(f(x)) } none. { none } }\n }\n+// FIXME This is needed to make working with by-value functions a bit less\n+// painful. We should come up with a better solution.\n+fn map_imm<@T, @U>(f: block(+T) -> U, opt: t<T>) -> t<U> {\n+    alt opt { some(x) { some(f(x)) } none. { none } }\n+}\n \n fn is_none<@T>(opt: t<T>) -> bool {\n     alt opt { none. { true } some(_) { false } }"}, {"sha": "bc4334a06bcc56f6f14150c8622581aa413db7e6", "filename": "src/lib/vec.rs", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/f9fbd86f52cf597b85359ade1ca60b8d6ebf7286/src%2Flib%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9fbd86f52cf597b85359ade1ca60b8d6ebf7286/src%2Flib%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Fvec.rs?ref=f9fbd86f52cf597b85359ade1ca60b8d6ebf7286", "patch": "@@ -191,6 +191,17 @@ fn map<@T, @U>(f: block(T) -> U, v: [mutable? T]) -> [U] {\n     }\n     ret result;\n }\n+// FIXME This is needed to make working with by-value functions a bit less\n+// painful. We should come up with a better solution.\n+fn map_imm<@T, @U>(f: block(+T) -> U, v: [mutable? T]) -> [U] {\n+    let result = [];\n+    reserve(result, len(v));\n+    for elem: T in v {\n+        let elem2 = elem; // satisfies alias checker\n+        result += [f(elem2)];\n+    }\n+    ret result;\n+}\n \n fn map2<@T, @U, @V>(f: block(T, U) -> V, v0: [T], v1: [U]) -> [V] {\n     let v0_len = len::<T>(v0);"}]}