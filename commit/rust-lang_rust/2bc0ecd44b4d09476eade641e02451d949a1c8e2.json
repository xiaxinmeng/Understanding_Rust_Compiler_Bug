{"sha": "2bc0ecd44b4d09476eade641e02451d949a1c8e2", "node_id": "MDY6Q29tbWl0NzI0NzEyOjJiYzBlY2Q0NGI0ZDA5NDc2ZWFkZTY0MWUwMjQ1MWQ5NDlhMWM4ZTI=", "commit": {"author": {"name": "Tim Nielens", "email": "tim.nielens@gmail.com", "date": "2020-06-19T20:12:51Z"}, "committer": {"name": "Tim Nielens", "email": "tim.nielens@gmail.com", "date": "2020-08-09T13:10:00Z"}, "message": "should_implement_trait - add test cases for every checked trait method", "tree": {"sha": "2ddf37f8f6b3d509a0b8b4adca59539fc4cd1236", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2ddf37f8f6b3d509a0b8b4adca59539fc4cd1236"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2bc0ecd44b4d09476eade641e02451d949a1c8e2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2bc0ecd44b4d09476eade641e02451d949a1c8e2", "html_url": "https://github.com/rust-lang/rust/commit/2bc0ecd44b4d09476eade641e02451d949a1c8e2", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2bc0ecd44b4d09476eade641e02451d949a1c8e2/comments", "author": {"login": "tnielens", "id": 11885535, "node_id": "MDQ6VXNlcjExODg1NTM1", "avatar_url": "https://avatars.githubusercontent.com/u/11885535?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tnielens", "html_url": "https://github.com/tnielens", "followers_url": "https://api.github.com/users/tnielens/followers", "following_url": "https://api.github.com/users/tnielens/following{/other_user}", "gists_url": "https://api.github.com/users/tnielens/gists{/gist_id}", "starred_url": "https://api.github.com/users/tnielens/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tnielens/subscriptions", "organizations_url": "https://api.github.com/users/tnielens/orgs", "repos_url": "https://api.github.com/users/tnielens/repos", "events_url": "https://api.github.com/users/tnielens/events{/privacy}", "received_events_url": "https://api.github.com/users/tnielens/received_events", "type": "User", "site_admin": false}, "committer": {"login": "tnielens", "id": 11885535, "node_id": "MDQ6VXNlcjExODg1NTM1", "avatar_url": "https://avatars.githubusercontent.com/u/11885535?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tnielens", "html_url": "https://github.com/tnielens", "followers_url": "https://api.github.com/users/tnielens/followers", "following_url": "https://api.github.com/users/tnielens/following{/other_user}", "gists_url": "https://api.github.com/users/tnielens/gists{/gist_id}", "starred_url": "https://api.github.com/users/tnielens/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tnielens/subscriptions", "organizations_url": "https://api.github.com/users/tnielens/orgs", "repos_url": "https://api.github.com/users/tnielens/repos", "events_url": "https://api.github.com/users/tnielens/events{/privacy}", "received_events_url": "https://api.github.com/users/tnielens/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a77e881ec9f324cdc544150f897d8b34281f92e4", "url": "https://api.github.com/repos/rust-lang/rust/commits/a77e881ec9f324cdc544150f897d8b34281f92e4", "html_url": "https://github.com/rust-lang/rust/commit/a77e881ec9f324cdc544150f897d8b34281f92e4"}], "stats": {"total": 411, "additions": 386, "deletions": 25}, "files": [{"sha": "c225a3bd35971ad3d5eccc7da843f901d470ccef", "filename": "clippy_lints/src/methods/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/2bc0ecd44b4d09476eade641e02451d949a1c8e2/clippy_lints%2Fsrc%2Fmethods%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2bc0ecd44b4d09476eade641e02451d949a1c8e2/clippy_lints%2Fsrc%2Fmethods%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Fmod.rs?ref=2bc0ecd44b4d09476eade641e02451d949a1c8e2", "patch": "@@ -3424,6 +3424,7 @@ const TRAIT_METHODS: [(&str, usize, &hir::FnHeader, SelfKind, OutType, &str); 30\n     (\"borrow_mut\", 1, &FN_HEADER, SelfKind::RefMut, OutType::Ref, \"std::borrow::BorrowMut\"),\n     (\"clone\", 1, &FN_HEADER, SelfKind::Ref, OutType::Any, \"std::clone::Clone\"),\n     (\"cmp\", 2, &FN_HEADER, SelfKind::Ref, OutType::Any, \"std::cmp::Ord\"),\n+    // FIXME: default doesn't work\n     (\"default\", 0, &FN_HEADER, SelfKind::No, OutType::Any, \"std::default::Default\"),\n     (\"deref\", 1, &FN_HEADER, SelfKind::Ref, OutType::Ref, \"std::ops::Deref\"),\n     (\"deref_mut\", 1, &FN_HEADER, SelfKind::RefMut, OutType::Ref, \"std::ops::DerefMut\"),"}, {"sha": "adf81607440d1013507c63cca43b1bdfd0c176e2", "filename": "tests/ui/methods.rs", "status": "modified", "additions": 136, "deletions": 10, "changes": 146, "blob_url": "https://github.com/rust-lang/rust/blob/2bc0ecd44b4d09476eade641e02451d949a1c8e2/tests%2Fui%2Fmethods.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2bc0ecd44b4d09476eade641e02451d949a1c8e2/tests%2Fui%2Fmethods.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmethods.rs?ref=2bc0ecd44b4d09476eade641e02451d949a1c8e2", "patch": "@@ -37,9 +37,136 @@ use option_helpers::IteratorFalsePositives;\n pub struct T;\n \n impl T {\n+    // *******************************************\n+    // complete trait method list, should lint all\n+    // *******************************************\n     pub fn add(self, other: T) -> T {\n-        self\n+        unimplemented!()\n+    }\n+\n+    pub fn as_mut(&mut self) -> &mut T {\n+        unimplemented!()\n+    }\n+\n+    pub fn as_ref(&self) -> &T {\n+        unimplemented!()\n+    }\n+\n+    pub fn bitand(self, rhs: T) -> T {\n+        unimplemented!()\n+    }\n+\n+    pub fn bitor(self, rhs: Self) -> Self {\n+        unimplemented!()\n+    }\n+\n+    pub fn bitxor(self, rhs: Self) -> Self {\n+        unimplemented!()\n+    }\n+\n+    pub fn borrow(&self) -> &str {\n+        unimplemented!()\n+    }\n+\n+    pub fn borrow_mut(&mut self) -> &mut str {\n+        unimplemented!()\n+    }\n+\n+    pub fn clone(&self) -> Self {\n+        unimplemented!()\n+    }\n+\n+    pub fn cmp(&self, other: &Self) -> Self {\n+        unimplemented!()\n+    }\n+\n+    pub fn default() -> Self {\n+        unimplemented!()\n+    }\n+\n+    pub fn deref(&self) -> &Self {\n+        unimplemented!()\n+    }\n+\n+    pub fn deref_mut(&mut self) -> &mut Self {\n+        unimplemented!()\n+    }\n+\n+    pub fn div(self, rhs: Self) -> Self {\n+        unimplemented!()\n+    }\n+\n+    pub fn drop(&mut self) {\n+        unimplemented!()\n+    }\n+\n+    pub fn eq(&self, other: &Self) -> bool {\n+        unimplemented!()\n+    }\n+\n+    pub fn from_iter<T>(iter: T) -> Self {\n+        unimplemented!()\n+    }\n+\n+    pub fn from_str(s: &str) -> Result<Self, Self> {\n+        unimplemented!()\n+    }\n+\n+    pub fn hash(&self, state: &mut T) {\n+        unimplemented!()\n+    }\n+\n+    pub fn index(&self, index: usize) -> &Self {\n+        unimplemented!()\n+    }\n+\n+    pub fn index_mut(&mut self, index: usize) -> &mut Self {\n+        unimplemented!()\n+    }\n+\n+    pub fn into_iter(self) -> Self {\n+        unimplemented!()\n+    }\n+\n+    pub fn mul(self, rhs: Self) -> Self {\n+        unimplemented!()\n+    }\n+\n+    pub fn neg(self) -> Self {\n+        unimplemented!()\n+    }\n+\n+    pub fn next(&mut self) -> Option<Self> {\n+        unimplemented!()\n+    }\n+\n+    pub fn not(self) -> Self {\n+        unimplemented!()\n+    }\n+\n+    pub fn rem(self, rhs: Self) -> Self {\n+        unimplemented!()\n+    }\n+\n+    pub fn shl(self, rhs: Self) -> Self {\n+        unimplemented!()\n+    }\n+\n+    pub fn shr(self, rhs: Self) -> Self {\n+        unimplemented!()\n+    }\n+\n+    pub fn sub(self, rhs: Self) -> Self {\n+        unimplemented!()\n     }\n+    // *****************\n+    // complete list end\n+    // *****************\n+}\n+\n+pub struct T1;\n+impl T1 {\n+    // corner cases: should not lint\n \n     // no error, not public interface\n     pub(crate) fn drop(&mut self) {}\n@@ -50,22 +177,22 @@ impl T {\n     }\n \n     // no error, private function\n-    fn eq(&self, other: T) -> bool {\n+    fn eq(&self, other: Self) -> bool {\n         true\n     }\n \n     // No error; self is a ref.\n-    fn sub(&self, other: T) -> &T {\n+    fn sub(&self, other: Self) -> &Self {\n         self\n     }\n \n     // No error; different number of arguments.\n-    fn div(self) -> T {\n+    fn div(self) -> Self {\n         self\n     }\n \n     // No error; wrong return type.\n-    fn rem(self, other: T) {}\n+    fn rem(self, other: Self) {}\n \n     // Fine\n     fn into_u32(self) -> u32 {\n@@ -89,16 +216,15 @@ impl T {\n     }\n }\n \n-pub struct T1;\n-\n-impl T1 {\n+pub struct T2;\n+impl T2 {\n     // Shouldn't trigger lint as it is unsafe.\n-    pub unsafe fn add(self, rhs: T1) -> T1 {\n+    pub unsafe fn add(self, rhs: Self) -> Self {\n         self\n     }\n \n     // Should not trigger lint since this is an async function.\n-    pub async fn next(&mut self) -> Option<T1> {\n+    pub async fn next(&mut self) -> Option<Self> {\n         None\n     }\n }"}, {"sha": "5105fff8f5b8a0a55663e5d1ea91a4f24a6bb7c4", "filename": "tests/ui/methods.stderr", "status": "modified", "additions": 249, "deletions": 15, "changes": 264, "blob_url": "https://github.com/rust-lang/rust/blob/2bc0ecd44b4d09476eade641e02451d949a1c8e2/tests%2Fui%2Fmethods.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2bc0ecd44b4d09476eade641e02451d949a1c8e2/tests%2Fui%2Fmethods.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmethods.stderr?ref=2bc0ecd44b4d09476eade641e02451d949a1c8e2", "patch": "@@ -1,15 +1,249 @@\n error: defining a method called `add` on this type; consider implementing the `std::ops::Add` trait or choosing a less ambiguous name\n-  --> $DIR/methods.rs:40:5\n+  --> $DIR/methods.rs:43:5\n    |\n LL | /     pub fn add(self, other: T) -> T {\n-LL | |         self\n+LL | |         unimplemented!()\n LL | |     }\n    | |_____^\n    |\n    = note: `-D clippy::should-implement-trait` implied by `-D warnings`\n \n+error: defining a method called `as_mut` on this type; consider implementing the `std::convert::AsMut` trait or choosing a less ambiguous name\n+  --> $DIR/methods.rs:47:5\n+   |\n+LL | /     pub fn as_mut(&mut self) -> &mut T {\n+LL | |         unimplemented!()\n+LL | |     }\n+   | |_____^\n+\n+error: defining a method called `as_ref` on this type; consider implementing the `std::convert::AsRef` trait or choosing a less ambiguous name\n+  --> $DIR/methods.rs:51:5\n+   |\n+LL | /     pub fn as_ref(&self) -> &T {\n+LL | |         unimplemented!()\n+LL | |     }\n+   | |_____^\n+\n+error: defining a method called `bitand` on this type; consider implementing the `std::ops::BitAnd` trait or choosing a less ambiguous name\n+  --> $DIR/methods.rs:55:5\n+   |\n+LL | /     pub fn bitand(self, rhs: T) -> T {\n+LL | |         unimplemented!()\n+LL | |     }\n+   | |_____^\n+\n+error: defining a method called `bitor` on this type; consider implementing the `std::ops::BitOr` trait or choosing a less ambiguous name\n+  --> $DIR/methods.rs:59:5\n+   |\n+LL | /     pub fn bitor(self, rhs: Self) -> Self {\n+LL | |         unimplemented!()\n+LL | |     }\n+   | |_____^\n+\n+error: defining a method called `bitxor` on this type; consider implementing the `std::ops::BitXor` trait or choosing a less ambiguous name\n+  --> $DIR/methods.rs:63:5\n+   |\n+LL | /     pub fn bitxor(self, rhs: Self) -> Self {\n+LL | |         unimplemented!()\n+LL | |     }\n+   | |_____^\n+\n+error: defining a method called `borrow` on this type; consider implementing the `std::borrow::Borrow` trait or choosing a less ambiguous name\n+  --> $DIR/methods.rs:67:5\n+   |\n+LL | /     pub fn borrow(&self) -> &str {\n+LL | |         unimplemented!()\n+LL | |     }\n+   | |_____^\n+\n+error: defining a method called `borrow_mut` on this type; consider implementing the `std::borrow::BorrowMut` trait or choosing a less ambiguous name\n+  --> $DIR/methods.rs:71:5\n+   |\n+LL | /     pub fn borrow_mut(&mut self) -> &mut str {\n+LL | |         unimplemented!()\n+LL | |     }\n+   | |_____^\n+\n+error: defining a method called `clone` on this type; consider implementing the `std::clone::Clone` trait or choosing a less ambiguous name\n+  --> $DIR/methods.rs:75:5\n+   |\n+LL | /     pub fn clone(&self) -> Self {\n+LL | |         unimplemented!()\n+LL | |     }\n+   | |_____^\n+\n+error: defining a method called `cmp` on this type; consider implementing the `std::cmp::Ord` trait or choosing a less ambiguous name\n+  --> $DIR/methods.rs:79:5\n+   |\n+LL | /     pub fn cmp(&self, other: &Self) -> Self {\n+LL | |         unimplemented!()\n+LL | |     }\n+   | |_____^\n+\n+error: defining a method called `deref` on this type; consider implementing the `std::ops::Deref` trait or choosing a less ambiguous name\n+  --> $DIR/methods.rs:87:5\n+   |\n+LL | /     pub fn deref(&self) -> &Self {\n+LL | |         unimplemented!()\n+LL | |     }\n+   | |_____^\n+\n+error: defining a method called `deref_mut` on this type; consider implementing the `std::ops::DerefMut` trait or choosing a less ambiguous name\n+  --> $DIR/methods.rs:91:5\n+   |\n+LL | /     pub fn deref_mut(&mut self) -> &mut Self {\n+LL | |         unimplemented!()\n+LL | |     }\n+   | |_____^\n+\n+error: defining a method called `div` on this type; consider implementing the `std::ops::Div` trait or choosing a less ambiguous name\n+  --> $DIR/methods.rs:95:5\n+   |\n+LL | /     pub fn div(self, rhs: Self) -> Self {\n+LL | |         unimplemented!()\n+LL | |     }\n+   | |_____^\n+\n+error: defining a method called `drop` on this type; consider implementing the `std::ops::Drop` trait or choosing a less ambiguous name\n+  --> $DIR/methods.rs:99:5\n+   |\n+LL | /     pub fn drop(&mut self) {\n+LL | |         unimplemented!()\n+LL | |     }\n+   | |_____^\n+\n+error: defining a method called `eq` on this type; consider implementing the `std::cmp::PartialEq` trait or choosing a less ambiguous name\n+  --> $DIR/methods.rs:103:5\n+   |\n+LL | /     pub fn eq(&self, other: &Self) -> bool {\n+LL | |         unimplemented!()\n+LL | |     }\n+   | |_____^\n+\n+error: defining a method called `from_iter` on this type; consider implementing the `std::iter::FromIterator` trait or choosing a less ambiguous name\n+  --> $DIR/methods.rs:107:5\n+   |\n+LL | /     pub fn from_iter<T>(iter: T) -> Self {\n+LL | |         unimplemented!()\n+LL | |     }\n+   | |_____^\n+\n+error: defining a method called `from_str` on this type; consider implementing the `std::str::FromStr` trait or choosing a less ambiguous name\n+  --> $DIR/methods.rs:111:5\n+   |\n+LL | /     pub fn from_str(s: &str) -> Result<Self, Self> {\n+LL | |         unimplemented!()\n+LL | |     }\n+   | |_____^\n+\n+error: docs for function returning `Result` missing `# Errors` section\n+  --> $DIR/methods.rs:111:5\n+   |\n+LL | /     pub fn from_str(s: &str) -> Result<Self, Self> {\n+LL | |         unimplemented!()\n+LL | |     }\n+   | |_____^\n+   |\n+   = note: `-D clippy::missing-errors-doc` implied by `-D warnings`\n+\n+error: defining a method called `hash` on this type; consider implementing the `std::hash::Hash` trait or choosing a less ambiguous name\n+  --> $DIR/methods.rs:115:5\n+   |\n+LL | /     pub fn hash(&self, state: &mut T) {\n+LL | |         unimplemented!()\n+LL | |     }\n+   | |_____^\n+\n+error: defining a method called `index` on this type; consider implementing the `std::ops::Index` trait or choosing a less ambiguous name\n+  --> $DIR/methods.rs:119:5\n+   |\n+LL | /     pub fn index(&self, index: usize) -> &Self {\n+LL | |         unimplemented!()\n+LL | |     }\n+   | |_____^\n+\n+error: defining a method called `index_mut` on this type; consider implementing the `std::ops::IndexMut` trait or choosing a less ambiguous name\n+  --> $DIR/methods.rs:123:5\n+   |\n+LL | /     pub fn index_mut(&mut self, index: usize) -> &mut Self {\n+LL | |         unimplemented!()\n+LL | |     }\n+   | |_____^\n+\n+error: defining a method called `into_iter` on this type; consider implementing the `std::iter::IntoIterator` trait or choosing a less ambiguous name\n+  --> $DIR/methods.rs:127:5\n+   |\n+LL | /     pub fn into_iter(self) -> Self {\n+LL | |         unimplemented!()\n+LL | |     }\n+   | |_____^\n+\n+error: defining a method called `mul` on this type; consider implementing the `std::ops::Mul` trait or choosing a less ambiguous name\n+  --> $DIR/methods.rs:131:5\n+   |\n+LL | /     pub fn mul(self, rhs: Self) -> Self {\n+LL | |         unimplemented!()\n+LL | |     }\n+   | |_____^\n+\n+error: defining a method called `neg` on this type; consider implementing the `std::ops::Neg` trait or choosing a less ambiguous name\n+  --> $DIR/methods.rs:135:5\n+   |\n+LL | /     pub fn neg(self) -> Self {\n+LL | |         unimplemented!()\n+LL | |     }\n+   | |_____^\n+\n+error: defining a method called `next` on this type; consider implementing the `std::iter::Iterator` trait or choosing a less ambiguous name\n+  --> $DIR/methods.rs:139:5\n+   |\n+LL | /     pub fn next(&mut self) -> Option<Self> {\n+LL | |         unimplemented!()\n+LL | |     }\n+   | |_____^\n+\n+error: defining a method called `not` on this type; consider implementing the `std::ops::Not` trait or choosing a less ambiguous name\n+  --> $DIR/methods.rs:143:5\n+   |\n+LL | /     pub fn not(self) -> Self {\n+LL | |         unimplemented!()\n+LL | |     }\n+   | |_____^\n+\n+error: defining a method called `rem` on this type; consider implementing the `std::ops::Rem` trait or choosing a less ambiguous name\n+  --> $DIR/methods.rs:147:5\n+   |\n+LL | /     pub fn rem(self, rhs: Self) -> Self {\n+LL | |         unimplemented!()\n+LL | |     }\n+   | |_____^\n+\n+error: defining a method called `shl` on this type; consider implementing the `std::ops::Shl` trait or choosing a less ambiguous name\n+  --> $DIR/methods.rs:151:5\n+   |\n+LL | /     pub fn shl(self, rhs: Self) -> Self {\n+LL | |         unimplemented!()\n+LL | |     }\n+   | |_____^\n+\n+error: defining a method called `shr` on this type; consider implementing the `std::ops::Shr` trait or choosing a less ambiguous name\n+  --> $DIR/methods.rs:155:5\n+   |\n+LL | /     pub fn shr(self, rhs: Self) -> Self {\n+LL | |         unimplemented!()\n+LL | |     }\n+   | |_____^\n+\n+error: defining a method called `sub` on this type; consider implementing the `std::ops::Sub` trait or choosing a less ambiguous name\n+  --> $DIR/methods.rs:159:5\n+   |\n+LL | /     pub fn sub(self, rhs: Self) -> Self {\n+LL | |         unimplemented!()\n+LL | |     }\n+   | |_____^\n+\n error: methods called `new` usually return `Self`\n-  --> $DIR/methods.rs:174:5\n+  --> $DIR/methods.rs:300:5\n    |\n LL | /     fn new() -> i32 {\n LL | |         0\n@@ -19,7 +253,7 @@ LL | |     }\n    = note: `-D clippy::new-ret-no-self` implied by `-D warnings`\n \n error: called `filter(p).next()` on an `Iterator`. This is more succinctly expressed by calling `.find(p)` instead.\n-  --> $DIR/methods.rs:193:13\n+  --> $DIR/methods.rs:319:13\n    |\n LL |     let _ = v.iter().filter(|&x| *x < 0).next();\n    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n@@ -28,7 +262,7 @@ LL |     let _ = v.iter().filter(|&x| *x < 0).next();\n    = note: replace `filter(|&x| *x < 0).next()` with `find(|&x| *x < 0)`\n \n error: called `filter(p).next()` on an `Iterator`. This is more succinctly expressed by calling `.find(p)` instead.\n-  --> $DIR/methods.rs:196:13\n+  --> $DIR/methods.rs:322:13\n    |\n LL |       let _ = v.iter().filter(|&x| {\n    |  _____________^\n@@ -38,33 +272,33 @@ LL | |                    ).next();\n    | |___________________________^\n \n error: called `is_some()` after searching an `Iterator` with find. This is more succinctly expressed by calling `any()`.\n-  --> $DIR/methods.rs:213:22\n+  --> $DIR/methods.rs:339:22\n    |\n LL |     let _ = v.iter().find(|&x| *x < 0).is_some();\n    |                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try this: `any(|x| *x < 0)`\n    |\n    = note: `-D clippy::search-is-some` implied by `-D warnings`\n \n error: called `is_some()` after searching an `Iterator` with find. This is more succinctly expressed by calling `any()`.\n-  --> $DIR/methods.rs:214:20\n+  --> $DIR/methods.rs:340:20\n    |\n LL |     let _ = (0..1).find(|x| **y == *x).is_some(); // one dereference less\n    |                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try this: `any(|x| **y == x)`\n \n error: called `is_some()` after searching an `Iterator` with find. This is more succinctly expressed by calling `any()`.\n-  --> $DIR/methods.rs:215:20\n+  --> $DIR/methods.rs:341:20\n    |\n LL |     let _ = (0..1).find(|x| *x == 0).is_some();\n    |                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try this: `any(|x| x == 0)`\n \n error: called `is_some()` after searching an `Iterator` with find. This is more succinctly expressed by calling `any()`.\n-  --> $DIR/methods.rs:216:22\n+  --> $DIR/methods.rs:342:22\n    |\n LL |     let _ = v.iter().find(|x| **x == 0).is_some();\n    |                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try this: `any(|x| *x == 0)`\n \n error: called `is_some()` after searching an `Iterator` with find. This is more succinctly expressed by calling `any()`.\n-  --> $DIR/methods.rs:219:13\n+  --> $DIR/methods.rs:345:13\n    |\n LL |       let _ = v.iter().find(|&x| {\n    |  _____________^\n@@ -74,13 +308,13 @@ LL | |                    ).is_some();\n    | |______________________________^\n \n error: called `is_some()` after searching an `Iterator` with position. This is more succinctly expressed by calling `any()`.\n-  --> $DIR/methods.rs:225:22\n+  --> $DIR/methods.rs:351:22\n    |\n LL |     let _ = v.iter().position(|&x| x < 0).is_some();\n    |                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try this: `any(|&x| x < 0)`\n \n error: called `is_some()` after searching an `Iterator` with position. This is more succinctly expressed by calling `any()`.\n-  --> $DIR/methods.rs:228:13\n+  --> $DIR/methods.rs:354:13\n    |\n LL |       let _ = v.iter().position(|&x| {\n    |  _____________^\n@@ -90,13 +324,13 @@ LL | |                    ).is_some();\n    | |______________________________^\n \n error: called `is_some()` after searching an `Iterator` with rposition. This is more succinctly expressed by calling `any()`.\n-  --> $DIR/methods.rs:234:22\n+  --> $DIR/methods.rs:360:22\n    |\n LL |     let _ = v.iter().rposition(|&x| x < 0).is_some();\n    |                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try this: `any(|&x| x < 0)`\n \n error: called `is_some()` after searching an `Iterator` with rposition. This is more succinctly expressed by calling `any()`.\n-  --> $DIR/methods.rs:237:13\n+  --> $DIR/methods.rs:363:13\n    |\n LL |       let _ = v.iter().rposition(|&x| {\n    |  _____________^\n@@ -105,5 +339,5 @@ LL | |                                }\n LL | |                    ).is_some();\n    | |______________________________^\n \n-error: aborting due to 13 previous errors\n+error: aborting due to 42 previous errors\n "}]}