{"sha": "22f1eb01ee42c8dcfe5e7d7c981bba82aad1bbea", "node_id": "MDY6Q29tbWl0NzI0NzEyOjIyZjFlYjAxZWU0MmM4ZGNmZTVlN2Q3Yzk4MWJiYTgyYWFkMWJiZWE=", "commit": {"author": {"name": "Aaron Hill", "email": "aa1ronham@gmail.com", "date": "2019-12-03T02:15:58Z"}, "committer": {"name": "Aaron Hill", "email": "aa1ronham@gmail.com", "date": "2020-09-28T17:44:45Z"}, "message": "Add API for capturing backtrace\n\nThis PR adds two new Miri-defined extern functions:\n`miri_get_backtrace` and `miri_resolve_frame`, which are documented in\nthe README. Together, they allow obtaining a backtrace for the currently\nexecuting program.\n\nI've added a test showing how these APIs are used. I've also prepared a\ncompanion PR `backtrace-rs`, which will allow\n`backtrace::Backtrace::new()` to work automatically under Miri.\n\nOnce these two PRs are merged, we will be able to print backtraces from\nthe normal Rust panic hook (since libstd is now using backtrace-rs).\n\nA few notes:\n* Resolving the backtrace frames is *very* slow - you can actually see\n  each line being printed out one at a time. Some local testing showed\n  that this is not (primrary) caused by resolving a `Span` - it seems\n  to be just Miri being slow.\n* For the first time, we now interact directly with a user-defined\n  struct (instead of just executing the user-provided MIR that\n  manipulates the struct). To allow for future changes, I've added\n  a 'version' parameter (currently required to be 0). This should allow\n  us to change the `MiriFrame` struct should the need ever arise.\n* I used the approach suggested by @oli-obk - a returned backtrace\n  pointer consists of a base function allocation, with the 'offset'\n  used to encode the `Span.lo`. This allows losslessly reconstructing\n  the location information in `miri_resolve_frame`.\n* There are a few quirks on the `backtrace-rs` side:\n  * `backtrace-rs` calls `getcwd()` by default to try to simplify\n    the filename. This results in an isolation error by default,\n    which could be annoying when printing a backtrace from libstd.\n  * `backtrace-rs` tries to remove 'internal' frames (everything between\n     the call to `Backtrace::new()` and the internal API call made by\n     backtrace-rs) by comparing the returned frame pointer value to\n     a Rust function pointer. This doesn't work due to the way we\n     construct the frame pointers passed to the caller. We could\n     attempt to support this kind of comparison, or just add a\n    `#[cfg(miri)]` and ignore the frames ourselves.", "tree": {"sha": "26d042ae5a6bf5adb3e441c06037af3f66c1c29c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/26d042ae5a6bf5adb3e441c06037af3f66c1c29c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/22f1eb01ee42c8dcfe5e7d7c981bba82aad1bbea", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCAAdFiEE7J9Gc3TfBwj2K399tAh+UQ6YsWQFAl9yIQ0ACgkQtAh+UQ6Y\nsWRcAg/+NGNnfJRyhH0XOiXdfH8Q3kgSZhBZUUWQWGhvnfAb9Df65V1ftid15IDQ\nFjJi0hhk4d1qOzr6g8IcPEjRWX/REcwv7GxN7JuJdrwbheNBYyP646yxsogI5vPo\nSXEXwgmwgSiO5xOy/5/gdkKTQWT3+XQq9BDIK3LL4gD2ydo4ddBykxW8TtAENqFp\ngO2/83n49CljsGCcqAFsj793tUIyjYJ1z9HZmWrdKpWVezhF1Dz8ReKpnhlO6eZa\n4TTboeLQFxxbRFFu+AbuFtfQjtoiLkJZyqA+gs8J7t62vBvZk5WnbB8wtRbqZAnZ\nA0bIoz+Wnt6kWy39yjBi3ybjFC0nv1lUE4upVknUfwXcKWQ9wJp7DjUk8Mm4FJYz\nvnqzKDmN4JW5K2LVVWpN85dhPMJhHr4B3tyHR56vSY/zdaukGGNemss2XBX/rIYv\ngdYbAGYEakOpbmJMZm3bhxjci9KSgtnwfoL9rVqGCWtUeXDMIcIH3dvBmCsZB/df\nE2BaNkcrpYRbFy/rnOOH23EPoSqepSfr4aOdp/z003lq3GBv9NHZp0aJCwE0U0Oa\nshP4ygukFvy+2k4yNk2WXczKgi2vNDF2Xy0PHH594m0W/uRb6TleXghiRAOW0Ldu\nSnqltNAUBCkd4AmQrmzsabTeab3hvDpJpQJj1lzZaXubMlIoUIU=\n=9g10\n-----END PGP SIGNATURE-----", "payload": "tree 26d042ae5a6bf5adb3e441c06037af3f66c1c29c\nparent aa832c1133217a079ae5d9af65dd0b7ad96aca07\nauthor Aaron Hill <aa1ronham@gmail.com> 1575339358 -0500\ncommitter Aaron Hill <aa1ronham@gmail.com> 1601315085 -0400\n\nAdd API for capturing backtrace\n\nThis PR adds two new Miri-defined extern functions:\n`miri_get_backtrace` and `miri_resolve_frame`, which are documented in\nthe README. Together, they allow obtaining a backtrace for the currently\nexecuting program.\n\nI've added a test showing how these APIs are used. I've also prepared a\ncompanion PR `backtrace-rs`, which will allow\n`backtrace::Backtrace::new()` to work automatically under Miri.\n\nOnce these two PRs are merged, we will be able to print backtraces from\nthe normal Rust panic hook (since libstd is now using backtrace-rs).\n\nA few notes:\n* Resolving the backtrace frames is *very* slow - you can actually see\n  each line being printed out one at a time. Some local testing showed\n  that this is not (primrary) caused by resolving a `Span` - it seems\n  to be just Miri being slow.\n* For the first time, we now interact directly with a user-defined\n  struct (instead of just executing the user-provided MIR that\n  manipulates the struct). To allow for future changes, I've added\n  a 'version' parameter (currently required to be 0). This should allow\n  us to change the `MiriFrame` struct should the need ever arise.\n* I used the approach suggested by @oli-obk - a returned backtrace\n  pointer consists of a base function allocation, with the 'offset'\n  used to encode the `Span.lo`. This allows losslessly reconstructing\n  the location information in `miri_resolve_frame`.\n* There are a few quirks on the `backtrace-rs` side:\n  * `backtrace-rs` calls `getcwd()` by default to try to simplify\n    the filename. This results in an isolation error by default,\n    which could be annoying when printing a backtrace from libstd.\n  * `backtrace-rs` tries to remove 'internal' frames (everything between\n     the call to `Backtrace::new()` and the internal API call made by\n     backtrace-rs) by comparing the returned frame pointer value to\n     a Rust function pointer. This doesn't work due to the way we\n     construct the frame pointers passed to the caller. We could\n     attempt to support this kind of comparison, or just add a\n    `#[cfg(miri)]` and ignore the frames ourselves.\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/22f1eb01ee42c8dcfe5e7d7c981bba82aad1bbea", "html_url": "https://github.com/rust-lang/rust/commit/22f1eb01ee42c8dcfe5e7d7c981bba82aad1bbea", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/22f1eb01ee42c8dcfe5e7d7c981bba82aad1bbea/comments", "author": {"login": "Aaron1011", "id": 1408859, "node_id": "MDQ6VXNlcjE0MDg4NTk=", "avatar_url": "https://avatars.githubusercontent.com/u/1408859?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Aaron1011", "html_url": "https://github.com/Aaron1011", "followers_url": "https://api.github.com/users/Aaron1011/followers", "following_url": "https://api.github.com/users/Aaron1011/following{/other_user}", "gists_url": "https://api.github.com/users/Aaron1011/gists{/gist_id}", "starred_url": "https://api.github.com/users/Aaron1011/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Aaron1011/subscriptions", "organizations_url": "https://api.github.com/users/Aaron1011/orgs", "repos_url": "https://api.github.com/users/Aaron1011/repos", "events_url": "https://api.github.com/users/Aaron1011/events{/privacy}", "received_events_url": "https://api.github.com/users/Aaron1011/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Aaron1011", "id": 1408859, "node_id": "MDQ6VXNlcjE0MDg4NTk=", "avatar_url": "https://avatars.githubusercontent.com/u/1408859?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Aaron1011", "html_url": "https://github.com/Aaron1011", "followers_url": "https://api.github.com/users/Aaron1011/followers", "following_url": "https://api.github.com/users/Aaron1011/following{/other_user}", "gists_url": "https://api.github.com/users/Aaron1011/gists{/gist_id}", "starred_url": "https://api.github.com/users/Aaron1011/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Aaron1011/subscriptions", "organizations_url": "https://api.github.com/users/Aaron1011/orgs", "repos_url": "https://api.github.com/users/Aaron1011/repos", "events_url": "https://api.github.com/users/Aaron1011/events{/privacy}", "received_events_url": "https://api.github.com/users/Aaron1011/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "aa832c1133217a079ae5d9af65dd0b7ad96aca07", "url": "https://api.github.com/repos/rust-lang/rust/commits/aa832c1133217a079ae5d9af65dd0b7ad96aca07", "html_url": "https://github.com/rust-lang/rust/commit/aa832c1133217a079ae5d9af65dd0b7ad96aca07"}], "stats": {"total": 179, "additions": 178, "deletions": 1}, "files": [{"sha": "524c8e10cf3653d7b31b749de1509e946abc50bc", "filename": "README.md", "status": "modified", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/22f1eb01ee42c8dcfe5e7d7c981bba82aad1bbea/README.md", "raw_url": "https://github.com/rust-lang/rust/raw/22f1eb01ee42c8dcfe5e7d7c981bba82aad1bbea/README.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/README.md?ref=22f1eb01ee42c8dcfe5e7d7c981bba82aad1bbea", "patch": "@@ -266,6 +266,32 @@ extern \"Rust\" {\n     /// `ptr` has to point to the beginning of an allocated block.\n     fn miri_static_root(ptr: *const u8);\n \n+    /// Miri-provided extern function to obtain a backtrace of the current call stack.\n+    /// This returns a boxed slice of pointers - each pointer is an opaque value\n+    /// that is only useful when passed to `miri_resolve_frame`\n+    fn miri_get_backtrace() -> Box<[*mut ()]>;\n+\n+    /// Miri-provided extern function to resolve a frame pointer obtained\n+    /// from `miri_get_backtrace`. The `version` argument must be `0`,\n+    /// and `MiriFrame` should be declared as follows:\n+    ///\n+    /// ```rust\n+    /// struct MiriFrame {\n+    ///     // The name of the function being executed, encoded in UTF-8\n+    ///     name: Box<[u8]>,\n+    ///     // The filename of the function being executed, encoded in UTF-8\n+    ///     filename: Box<[u8]>,\n+    ///     // The line number currently being executed in `filename`, starting from '1'.\n+    ///     lineno: u32,\n+    ///     // The column number currently being executed in `filename`, starting from '1'.\n+    ///     colno: u32,\n+    /// }\n+    /// ```\n+    ///\n+    /// The fields must be declared in exactly the same order as they appear in `MiriFrame` above.\n+    /// This function can be called on any thread (not just the one which obtained `frame`)\n+    fn miri_resolve_frame(version: u8, frame: *mut ()) -> MiriFrame;\n+\n     /// Miri-provided extern function to begin unwinding with the given payload.\n     ///\n     /// This is internal and unstable and should not be used; we give it here"}, {"sha": "4d1ead8f0f82fda4a05fb70a5fc0e4a1055c699d", "filename": "src/shims/foreign_items.rs", "status": "modified", "additions": 87, "deletions": 1, "changes": 88, "blob_url": "https://github.com/rust-lang/rust/blob/22f1eb01ee42c8dcfe5e7d7c981bba82aad1bbea/src%2Fshims%2Fforeign_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/22f1eb01ee42c8dcfe5e7d7c981bba82aad1bbea/src%2Fshims%2Fforeign_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fshims%2Fforeign_items.rs?ref=22f1eb01ee42c8dcfe5e7d7c981bba82aad1bbea", "patch": "@@ -3,10 +3,13 @@ use std::{convert::{TryInto, TryFrom}, iter};\n use log::trace;\n \n use rustc_hir::def_id::DefId;\n-use rustc_middle::{mir, ty};\n+use rustc_middle::mir;\n use rustc_target::{abi::{Align, Size}, spec::PanicStrategy};\n+use rustc_middle::ty::{self, ParamEnv, TypeAndMut};\n+use rustc_ast::ast::Mutability;\n use rustc_apfloat::Float;\n use rustc_span::symbol::sym;\n+use rustc_span::BytePos;\n \n use crate::*;\n use helpers::check_arg_count;\n@@ -211,6 +214,89 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n                 this.machine.static_roots.push(ptr.alloc_id);\n             }\n \n+            // Obtains a Miri backtrace. See the README for details.\n+            \"miri_get_backtrace\" => {\n+                let tcx = this.tcx;\n+                let mut data = Vec::new();\n+                for frame in this.active_thread_stack().iter().rev() {\n+                    data.push((frame.instance, frame.current_span().lo()));\n+                }\n+\n+                let ptrs: Vec<_> = data.into_iter().map(|(instance, pos)| {\n+                    let mut fn_ptr = this.memory.create_fn_alloc(FnVal::Instance(instance));\n+                    fn_ptr.offset = Size::from_bytes(pos.0);\n+                    Scalar::Ptr(fn_ptr)\n+                }).collect();\n+\n+                let len = ptrs.len();\n+\n+                let ptr_ty = tcx.mk_ptr(TypeAndMut {\n+                    ty: tcx.types.unit,\n+                    mutbl: Mutability::Mut\n+                });\n+\n+                let array_ty = tcx.mk_array(ptr_ty, ptrs.len().try_into().unwrap());\n+                let array_ty_and_env = ParamEnv::empty().and(array_ty);\n+\n+                // Write pointers into array\n+                let alloc = this.allocate(tcx.layout_of(array_ty_and_env).unwrap(), MiriMemoryKind::Rust.into());\n+                for (i, ptr) in ptrs.into_iter().enumerate() {\n+                    let place = this.mplace_index(alloc, i as u64)?;\n+                    this.write_immediate_to_mplace(ptr.into(), place)?;\n+                }\n+\n+                this.write_immediate(Immediate::new_slice(alloc.ptr.into(), len.try_into().unwrap(), this), dest)?;\n+            }\n+\n+            // Resolves a Miri backtrace frame. See the README for details.\n+            \"miri_resolve_frame\" => {\n+                let tcx = this.tcx;\n+                let &[version, ptr] = check_arg_count(args)?;\n+\n+                let version = this.read_scalar(version)?.to_u8()?;\n+                if version != 0 {\n+                    throw_ub_format!(\"Unknown `miri_resolve_frame` version {}\", version);\n+                }\n+\n+                let ptr = match this.read_scalar(ptr)?.check_init()? {\n+                    Scalar::Ptr(ptr) => ptr,\n+                    Scalar::Raw { .. } => throw_ub_format!(\"Expected a pointer in `rust_miri_resolve_frame`, found {:?}\", ptr)\n+                };\n+\n+                let fn_instance = if let Some(GlobalAlloc::Function(instance)) = this.tcx.get_global_alloc(ptr.alloc_id) {\n+                    instance\n+                } else {\n+                    throw_ub_format!(\"Expect function pointer, found {:?}\", ptr);\n+                };\n+\n+                if dest.layout.layout.fields.count() != 4 {\n+                    throw_ub_format!(\"Bad declaration of miri_resolve_frame - should return a struct with 4 fields\");\n+                }\n+\n+                let pos = BytePos(ptr.offset.bytes().try_into().unwrap());\n+                let name = fn_instance.to_string();\n+\n+                let lo = tcx.sess.source_map().lookup_char_pos(pos);\n+\n+                let filename = lo.file.name.to_string();\n+                let lineno: u32 = lo.line as u32;\n+                // `lo.col` is 0-based - add 1 to make it 1-based for the caller.\n+                let colno: u32 = lo.col.0 as u32 + 1;\n+\n+                let name_alloc = this.allocate_str(&name, MiriMemoryKind::Rust.into());\n+                let filename_alloc = this.allocate_str(&filename, MiriMemoryKind::Rust.into());\n+                let lineno_alloc = Scalar::from_u32(lineno);\n+                let colno_alloc = Scalar::from_u32(colno);\n+\n+                let dest = this.force_allocation_maybe_sized(dest, MemPlaceMeta::None)?.0;\n+\n+                this.write_immediate(name_alloc.to_ref(), this.mplace_field(dest, 0)?.into())?;\n+                this.write_immediate(filename_alloc.to_ref(), this.mplace_field(dest, 1)?.into())?;\n+                this.write_scalar(lineno_alloc, this.mplace_field(dest, 2)?.into())?;\n+                this.write_scalar(colno_alloc, this.mplace_field(dest, 3)?.into())?;\n+            }\n+\n+\n             // Standard C allocation\n             \"malloc\" => {\n                 let &[size] = check_arg_count(args)?;"}, {"sha": "7c250fbbe3a4d330db8dab3ba6b71c586060908a", "filename": "tests/compile-fail/backtrace/bad-backtrace-decl.rs", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/22f1eb01ee42c8dcfe5e7d7c981bba82aad1bbea/tests%2Fcompile-fail%2Fbacktrace%2Fbad-backtrace-decl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/22f1eb01ee42c8dcfe5e7d7c981bba82aad1bbea/tests%2Fcompile-fail%2Fbacktrace%2Fbad-backtrace-decl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fbacktrace%2Fbad-backtrace-decl.rs?ref=22f1eb01ee42c8dcfe5e7d7c981bba82aad1bbea", "patch": "@@ -0,0 +1,13 @@\n+extern \"Rust\" {\n+    fn miri_get_backtrace() -> Box<[*mut ()]>;\n+    fn miri_resolve_frame(version: u8, ptr: *mut ());\n+}\n+\n+fn main() {\n+    let frames = unsafe { miri_get_backtrace() };\n+    for frame in frames.into_iter() {\n+        unsafe {\n+            miri_resolve_frame(0, *frame); //~ ERROR Undefined Behavior: Bad declaration of miri_resolve_frame - should return a struct with 4 fields\n+        }\n+    }\n+}"}, {"sha": "49b8ac88494dc8a964c2d340fbc57986a4493f48", "filename": "tests/compile-fail/backtrace/bad-backtrace-ptr.rs", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/22f1eb01ee42c8dcfe5e7d7c981bba82aad1bbea/tests%2Fcompile-fail%2Fbacktrace%2Fbad-backtrace-ptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/22f1eb01ee42c8dcfe5e7d7c981bba82aad1bbea/tests%2Fcompile-fail%2Fbacktrace%2Fbad-backtrace-ptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fbacktrace%2Fbad-backtrace-ptr.rs?ref=22f1eb01ee42c8dcfe5e7d7c981bba82aad1bbea", "patch": "@@ -0,0 +1,9 @@\n+extern \"Rust\" {\n+    fn miri_resolve_frame(version: u8, ptr: *mut ());\n+}\n+\n+fn main() {\n+    unsafe {\n+        miri_resolve_frame(0, 0 as *mut _); //~ ERROR Undefined Behavior: Expected a pointer\n+    }\n+}"}, {"sha": "b0183ca99e942f496c812fb0405d7ea5c216cf4c", "filename": "tests/compile-fail/backtrace/bad-backtrace-version.rs", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/22f1eb01ee42c8dcfe5e7d7c981bba82aad1bbea/tests%2Fcompile-fail%2Fbacktrace%2Fbad-backtrace-version.rs", "raw_url": "https://github.com/rust-lang/rust/raw/22f1eb01ee42c8dcfe5e7d7c981bba82aad1bbea/tests%2Fcompile-fail%2Fbacktrace%2Fbad-backtrace-version.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fbacktrace%2Fbad-backtrace-version.rs?ref=22f1eb01ee42c8dcfe5e7d7c981bba82aad1bbea", "patch": "@@ -0,0 +1,9 @@\n+extern \"Rust\" {\n+    fn miri_resolve_frame(version: u8, ptr: *mut ());\n+}\n+\n+fn main() {\n+    unsafe {\n+        miri_resolve_frame(1, 0 as *mut _); //~ ERROR  Undefined Behavior: Unknown `miri_resolve_frame` version 1\n+    }\n+}"}, {"sha": "fa86debf17d5ef303179166ec6385e0897219463", "filename": "tests/run-pass/backtrace-api.rs", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/22f1eb01ee42c8dcfe5e7d7c981bba82aad1bbea/tests%2Frun-pass%2Fbacktrace-api.rs", "raw_url": "https://github.com/rust-lang/rust/raw/22f1eb01ee42c8dcfe5e7d7c981bba82aad1bbea/tests%2Frun-pass%2Fbacktrace-api.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass%2Fbacktrace-api.rs?ref=22f1eb01ee42c8dcfe5e7d7c981bba82aad1bbea", "patch": "@@ -0,0 +1,24 @@\n+// normalize-stderr-test \".*rustlib\" -> \"RUSTLIB\"\n+\n+extern \"Rust\" {\n+    fn miri_get_backtrace() -> Box<[*mut ()]>;\n+    fn miri_resolve_frame(version: u8, ptr: *mut ()) -> MiriFrame;\n+}\n+\n+#[derive(Debug)]\n+struct MiriFrame {\n+    name: Box<[u8]>,\n+    filename: Box<[u8]>,\n+    lineno: u32,\n+    colno: u32\n+}\n+\n+fn main() {\n+    let frames = unsafe { miri_get_backtrace() };\n+    for frame in frames.into_iter() {\n+        let miri_frame = unsafe { miri_resolve_frame(0, *frame) };\n+        let name = String::from_utf8(miri_frame.name.into()).unwrap();\n+        let filename = String::from_utf8(miri_frame.filename.into()).unwrap();\n+        eprintln!(\"{}:{}:{} ({})\", filename, miri_frame.lineno, miri_frame.colno, name);\n+    }\n+}"}, {"sha": "91a99070eb647970d92345b96785d2e60de71abf", "filename": "tests/run-pass/backtrace-api.stderr", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/22f1eb01ee42c8dcfe5e7d7c981bba82aad1bbea/tests%2Frun-pass%2Fbacktrace-api.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/22f1eb01ee42c8dcfe5e7d7c981bba82aad1bbea/tests%2Frun-pass%2Fbacktrace-api.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass%2Fbacktrace-api.stderr?ref=22f1eb01ee42c8dcfe5e7d7c981bba82aad1bbea", "patch": "@@ -0,0 +1,10 @@\n+$DIR/backtrace-api.rs:17:27 (main)\n+RUSTLIB/src/rust/library/core/src/ops/function.rs:227:5 (<fn() as std::ops::FnOnce<()>>::call_once - shim(fn()))\n+RUSTLIB/src/rust/library/std/src/sys_common/backtrace.rs:137:18 (std::sys_common::backtrace::__rust_begin_short_backtrace::<fn(), ()>)\n+RUSTLIB/src/rust/library/std/src/rt.rs:66:18 (std::rt::lang_start::<()>::{{closure}}#0)\n+RUSTLIB/src/rust/library/core/src/ops/function.rs:259:13 (std::ops::function::impls::<impl std::ops::FnOnce<()> for &dyn std::ops::Fn() -> i32 + std::marker::Sync + std::panic::RefUnwindSafe>::call_once)\n+RUSTLIB/src/rust/library/std/src/panicking.rs:381:40 (std::panicking::r#try::do_call::<&dyn std::ops::Fn() -> i32 + std::marker::Sync + std::panic::RefUnwindSafe, i32>)\n+RUSTLIB/src/rust/library/std/src/panicking.rs:345:19 (std::panicking::r#try::<i32, &dyn std::ops::Fn() -> i32 + std::marker::Sync + std::panic::RefUnwindSafe>)\n+RUSTLIB/src/rust/library/std/src/panic.rs:382:14 (std::panic::catch_unwind::<&dyn std::ops::Fn() -> i32 + std::marker::Sync + std::panic::RefUnwindSafe, i32>)\n+RUSTLIB/src/rust/library/std/src/rt.rs:51:25 (std::rt::lang_start_internal)\n+RUSTLIB/src/rust/library/std/src/rt.rs:65:5 (std::rt::lang_start::<()>)"}]}