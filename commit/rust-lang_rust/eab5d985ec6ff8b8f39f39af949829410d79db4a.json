{"sha": "eab5d985ec6ff8b8f39f39af949829410d79db4a", "node_id": "MDY6Q29tbWl0NzI0NzEyOmVhYjVkOTg1ZWM2ZmY4YjhmMzlmMzlhZjk0OTgyOTQxMGQ3OWRiNGE=", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2021-07-09T14:07:23Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2021-07-09T14:07:23Z"}, "message": "Merge #9512\n\n9512: Record coercion adjustments r=Veykril a=Veykril\n\ncc https://github.com/rust-analyzer/rust-analyzer/issues/9475\n\nCo-authored-by: Lukas Wirth <lukastw97@gmail.com>", "tree": {"sha": "fc0b004530cfb60fd86e1871d5c1dde47bf59957", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/fc0b004530cfb60fd86e1871d5c1dde47bf59957"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/eab5d985ec6ff8b8f39f39af949829410d79db4a", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJg6FgbCRBK7hj4Ov3rIwAA1NoIAHkxUMkWXHo3MaQ41pjuZfmQ\nRNrCHO0q7sSDluH21UPB4bEuz7axjErYMVMTZPorzdCPJY1h6B1pkFFRAqlLNPMO\nznUMZnIJXzc8jOlPPloFUvzKQRBcsXPd9zPWdmSc0jhZJr7S4ljZyE+ea+QmJs3R\nszjEDKpd4Esh4uaqe5fec+slfcCD3fVXKoQjXktsjlQy+vX1nzxpB7DXFdHewld8\nXzapmvUZo+LFkMsgP8G9eVq6Yos7yDCvmmWAWrpz2IYiEhAZlvbK5vYKcbxIEPIh\nAjlnGNZmTUa4+vWAnNp+g4DNSc+0gTDJrMw6Zfj+D0lQpijCr56KWCKdQqDiSJI=\n=CMz+\n-----END PGP SIGNATURE-----\n", "payload": "tree fc0b004530cfb60fd86e1871d5c1dde47bf59957\nparent 80f193e3f86e38e1a683f5557900740af855b333\nparent 9272942b92c069df9421ce5a2073913711ec7a7c\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1625839643 +0000\ncommitter GitHub <noreply@github.com> 1625839643 +0000\n\nMerge #9512\n\n9512: Record coercion adjustments r=Veykril a=Veykril\n\ncc https://github.com/rust-analyzer/rust-analyzer/issues/9475\n\nCo-authored-by: Lukas Wirth <lukastw97@gmail.com>\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/eab5d985ec6ff8b8f39f39af949829410d79db4a", "html_url": "https://github.com/rust-lang/rust/commit/eab5d985ec6ff8b8f39f39af949829410d79db4a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/eab5d985ec6ff8b8f39f39af949829410d79db4a/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "80f193e3f86e38e1a683f5557900740af855b333", "url": "https://api.github.com/repos/rust-lang/rust/commits/80f193e3f86e38e1a683f5557900740af855b333", "html_url": "https://github.com/rust-lang/rust/commit/80f193e3f86e38e1a683f5557900740af855b333"}, {"sha": "9272942b92c069df9421ce5a2073913711ec7a7c", "url": "https://api.github.com/repos/rust-lang/rust/commits/9272942b92c069df9421ce5a2073913711ec7a7c", "html_url": "https://github.com/rust-lang/rust/commit/9272942b92c069df9421ce5a2073913711ec7a7c"}], "stats": {"total": 648, "additions": 479, "deletions": 169}, "files": [{"sha": "7838bbe5c1c8d234cc6ca03ef3c5024f6f340aa2", "filename": "crates/hir_ty/src/diagnostics/match_check.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/eab5d985ec6ff8b8f39f39af949829410d79db4a/crates%2Fhir_ty%2Fsrc%2Fdiagnostics%2Fmatch_check.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eab5d985ec6ff8b8f39f39af949829410d79db4a/crates%2Fhir_ty%2Fsrc%2Fdiagnostics%2Fmatch_check.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Fdiagnostics%2Fmatch_check.rs?ref=eab5d985ec6ff8b8f39f39af949829410d79db4a", "patch": "@@ -109,7 +109,7 @@ impl<'a> PatCtxt<'a> {\n         self.infer.pat_adjustments.get(&pat).map(|it| &**it).unwrap_or_default().iter().rev().fold(\n             unadjusted_pat,\n             |subpattern, ref_ty| Pat {\n-                ty: ref_ty.clone(),\n+                ty: ref_ty.target.clone(),\n                 kind: Box::new(PatKind::Deref { subpattern }),\n             },\n         )"}, {"sha": "b1c0432273de9c74bd1bee1007e7aa6025640a4f", "filename": "crates/hir_ty/src/infer.rs", "status": "modified", "additions": 123, "deletions": 8, "changes": 131, "blob_url": "https://github.com/rust-lang/rust/blob/eab5d985ec6ff8b8f39f39af949829410d79db4a/crates%2Fhir_ty%2Fsrc%2Finfer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eab5d985ec6ff8b8f39f39af949829410d79db4a/crates%2Fhir_ty%2Fsrc%2Finfer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Finfer.rs?ref=eab5d985ec6ff8b8f39f39af949829410d79db4a", "patch": "@@ -16,7 +16,7 @@\n use std::ops::Index;\n use std::sync::Arc;\n \n-use chalk_ir::{cast::Cast, DebruijnIndex, Mutability};\n+use chalk_ir::{cast::Cast, DebruijnIndex, Mutability, Safety};\n use hir_def::{\n     body::Body,\n     data::{ConstData, FunctionData, StaticData},\n@@ -34,10 +34,10 @@ use rustc_hash::FxHashMap;\n use stdx::impl_from;\n use syntax::SmolStr;\n \n-use super::{DomainGoal, InEnvironment, ProjectionTy, TraitEnvironment, TraitRef, Ty};\n use crate::{\n-    db::HirDatabase, fold_tys, lower::ImplTraitLoweringMode, to_assoc_type_id, AliasEq, AliasTy,\n-    Goal, Interner, Substitution, TyBuilder, TyExt, TyKind,\n+    db::HirDatabase, fold_tys, infer::coerce::CoerceMany, lower::ImplTraitLoweringMode,\n+    to_assoc_type_id, AliasEq, AliasTy, DomainGoal, Goal, InEnvironment, Interner, ProjectionTy,\n+    Substitution, TraitEnvironment, TraitRef, Ty, TyBuilder, TyExt, TyKind,\n };\n \n // This lint has a false positive here. See the link below for details.\n@@ -103,12 +103,20 @@ impl Default for BindingMode {\n }\n \n #[derive(Debug)]\n-pub(crate) struct InferOk {\n+pub(crate) struct InferOk<T> {\n+    value: T,\n     goals: Vec<InEnvironment<Goal>>,\n }\n+\n+impl<T> InferOk<T> {\n+    fn map<U>(self, f: impl FnOnce(T) -> U) -> InferOk<U> {\n+        InferOk { value: f(self.value), goals: self.goals }\n+    }\n+}\n+\n #[derive(Debug)]\n pub(crate) struct TypeError;\n-pub(crate) type InferResult = Result<InferOk, TypeError>;\n+pub(crate) type InferResult<T> = Result<InferOk<T>, TypeError>;\n \n #[derive(Debug, PartialEq, Eq, Clone)]\n pub enum InferenceDiagnostic {\n@@ -133,6 +141,108 @@ impl Default for InternedStandardTypes {\n         InternedStandardTypes { unknown: TyKind::Error.intern(&Interner) }\n     }\n }\n+/// Represents coercing a value to a different type of value.\n+///\n+/// We transform values by following a number of `Adjust` steps in order.\n+/// See the documentation on variants of `Adjust` for more details.\n+///\n+/// Here are some common scenarios:\n+///\n+/// 1. The simplest cases are where a pointer is not adjusted fat vs thin.\n+///    Here the pointer will be dereferenced N times (where a dereference can\n+///    happen to raw or borrowed pointers or any smart pointer which implements\n+///    Deref, including Box<_>). The types of dereferences is given by\n+///    `autoderefs`. It can then be auto-referenced zero or one times, indicated\n+///    by `autoref`, to either a raw or borrowed pointer. In these cases unsize is\n+///    `false`.\n+///\n+/// 2. A thin-to-fat coercion involves unsizing the underlying data. We start\n+///    with a thin pointer, deref a number of times, unsize the underlying data,\n+///    then autoref. The 'unsize' phase may change a fixed length array to a\n+///    dynamically sized one, a concrete object to a trait object, or statically\n+///    sized struct to a dynamically sized one. E.g., &[i32; 4] -> &[i32] is\n+///    represented by:\n+///\n+///    ```\n+///    Deref(None) -> [i32; 4],\n+///    Borrow(AutoBorrow::Ref) -> &[i32; 4],\n+///    Unsize -> &[i32],\n+///    ```\n+///\n+///    Note that for a struct, the 'deep' unsizing of the struct is not recorded.\n+///    E.g., `struct Foo<T> { x: T }` we can coerce &Foo<[i32; 4]> to &Foo<[i32]>\n+///    The autoderef and -ref are the same as in the above example, but the type\n+///    stored in `unsize` is `Foo<[i32]>`, we don't store any further detail about\n+///    the underlying conversions from `[i32; 4]` to `[i32]`.\n+///\n+/// 3. Coercing a `Box<T>` to `Box<dyn Trait>` is an interesting special case. In\n+///    that case, we have the pointer we need coming in, so there are no\n+///    autoderefs, and no autoref. Instead we just do the `Unsize` transformation.\n+///    At some point, of course, `Box` should move out of the compiler, in which\n+///    case this is analogous to transforming a struct. E.g., Box<[i32; 4]> ->\n+///    Box<[i32]> is an `Adjust::Unsize` with the target `Box<[i32]>`.\n+#[derive(Clone, Debug, PartialEq, Eq, Hash)]\n+pub struct Adjustment {\n+    pub kind: Adjust,\n+    pub target: Ty,\n+}\n+\n+#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]\n+pub enum Adjust {\n+    /// Go from ! to any type.\n+    NeverToAny,\n+    /// Dereference once, producing a place.\n+    Deref(Option<OverloadedDeref>),\n+    /// Take the address and produce either a `&` or `*` pointer.\n+    Borrow(AutoBorrow),\n+    Pointer(PointerCast),\n+}\n+\n+/// An overloaded autoderef step, representing a `Deref(Mut)::deref(_mut)`\n+/// call, with the signature `&'a T -> &'a U` or `&'a mut T -> &'a mut U`.\n+/// The target type is `U` in both cases, with the region and mutability\n+/// being those shared by both the receiver and the returned reference.\n+#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]\n+pub struct OverloadedDeref(Mutability);\n+\n+#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]\n+pub enum AutoBorrow {\n+    /// Converts from T to &T.\n+    Ref(Mutability),\n+    /// Converts from T to *T.\n+    RawPtr(Mutability),\n+}\n+\n+#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]\n+pub enum PointerCast {\n+    /// Go from a fn-item type to a fn-pointer type.\n+    ReifyFnPointer,\n+\n+    /// Go from a safe fn pointer to an unsafe fn pointer.\n+    UnsafeFnPointer,\n+\n+    /// Go from a non-capturing closure to an fn pointer or an unsafe fn pointer.\n+    /// It cannot convert a closure that requires unsafe.\n+    ClosureFnPointer(Safety),\n+\n+    /// Go from a mut raw pointer to a const raw pointer.\n+    MutToConstPointer,\n+\n+    /// Go from `*const [T; N]` to `*const T`\n+    ArrayToPointer,\n+\n+    /// Unsize a pointer/reference value, e.g., `&[T; n]` to\n+    /// `&[T]`. Note that the source could be a thin or fat pointer.\n+    /// This will do things like convert thin pointers to fat\n+    /// pointers, or convert structs containing thin pointers to\n+    /// structs containing fat pointers, or convert between fat\n+    /// pointers. We don't store the details of how the transform is\n+    /// done (in fact, we don't know that, because it might depend on\n+    /// the precise type parameters). We just store the target\n+    /// type. Codegen backends and miri figure out what has to be done\n+    /// based on the precise source/target type at hand.\n+    Unsize,\n+}\n \n /// The result of type inference: A mapping from expressions and patterns to types.\n #[derive(Clone, PartialEq, Eq, Debug, Default)]\n@@ -156,7 +266,8 @@ pub struct InferenceResult {\n     /// Interned Unknown to return references to.\n     standard_types: InternedStandardTypes,\n     /// Stores the types which were implicitly dereferenced in pattern binding modes.\n-    pub pat_adjustments: FxHashMap<PatId, Vec<Ty>>,\n+    pub pat_adjustments: FxHashMap<PatId, Vec<Adjustment>>,\n+    pub expr_adjustments: FxHashMap<ExprId, Vec<Adjustment>>,\n }\n \n impl InferenceResult {\n@@ -238,7 +349,7 @@ struct InferenceContext<'a> {\n #[derive(Clone, Debug)]\n struct BreakableContext {\n     may_break: bool,\n-    break_ty: Ty,\n+    coerce: CoerceMany,\n     label: Option<name::Name>,\n }\n \n@@ -303,6 +414,10 @@ impl<'a> InferenceContext<'a> {\n         self.result.type_of_expr.insert(expr, ty);\n     }\n \n+    fn write_expr_adj(&mut self, expr: ExprId, adjustments: Vec<Adjustment>) {\n+        self.result.expr_adjustments.insert(expr, adjustments);\n+    }\n+\n     fn write_method_resolution(&mut self, expr: ExprId, func: FunctionId, subst: Substitution) {\n         self.result.method_resolutions.insert(expr, (func, subst));\n     }"}, {"sha": "e4fcc56bc45bfb514cfa59f57bcc743cf1078941", "filename": "crates/hir_ty/src/infer/closure.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/eab5d985ec6ff8b8f39f39af949829410d79db4a/crates%2Fhir_ty%2Fsrc%2Finfer%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eab5d985ec6ff8b8f39f39af949829410d79db4a/crates%2Fhir_ty%2Fsrc%2Finfer%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Finfer%2Fclosure.rs?ref=eab5d985ec6ff8b8f39f39af949829410d79db4a", "patch": "@@ -1,7 +1,7 @@\n //! Inference of closure parameter types based on the closure's expected type.\n \n use chalk_ir::{cast::Cast, AliasTy, FnSubst, WhereClause};\n-use hir_def::HasModule;\n+use hir_def::{expr::ExprId, HasModule};\n use smallvec::SmallVec;\n \n use crate::{\n@@ -14,6 +14,7 @@ use super::{Expectation, InferenceContext};\n impl InferenceContext<'_> {\n     pub(super) fn deduce_closure_type_from_expectations(\n         &mut self,\n+        closure_expr: ExprId,\n         closure_ty: &Ty,\n         sig_ty: &Ty,\n         expectation: &Expectation,\n@@ -24,7 +25,7 @@ impl InferenceContext<'_> {\n         };\n \n         // Deduction from where-clauses in scope, as well as fn-pointer coercion are handled here.\n-        self.coerce(closure_ty, &expected_ty);\n+        let _ = self.coerce(Some(closure_expr), closure_ty, &expected_ty);\n \n         // Deduction based on the expected `dyn Fn` is done separately.\n         if let TyKind::Dyn(dyn_ty) = expected_ty.kind(&Interner) {"}, {"sha": "2599a8c6b1c118936d406d9bafcbb4d3c4935c8e", "filename": "crates/hir_ty/src/infer/coerce.rs", "status": "modified", "additions": 223, "deletions": 92, "changes": 315, "blob_url": "https://github.com/rust-lang/rust/blob/eab5d985ec6ff8b8f39f39af949829410d79db4a/crates%2Fhir_ty%2Fsrc%2Finfer%2Fcoerce.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eab5d985ec6ff8b8f39f39af949829410d79db4a/crates%2Fhir_ty%2Fsrc%2Finfer%2Fcoerce.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Finfer%2Fcoerce.rs?ref=eab5d985ec6ff8b8f39f39af949829410d79db4a", "patch": "@@ -5,32 +5,47 @@\n //! See <https://doc.rust-lang.org/nomicon/coercions.html> and\n //! `librustc_typeck/check/coercion.rs`.\n \n-use chalk_ir::{cast::Cast, Mutability, TyVariableKind};\n+use chalk_ir::{cast::Cast, Goal, Mutability, TyVariableKind};\n use hir_def::{expr::ExprId, lang_item::LangItemTarget};\n \n use crate::{\n-    autoderef, infer::TypeMismatch, static_lifetime, Canonical, DomainGoal, FnPointer, FnSig,\n-    Interner, Solution, Substitution, Ty, TyBuilder, TyExt, TyKind,\n+    autoderef,\n+    infer::{\n+        Adjust, Adjustment, AutoBorrow, InferOk, InferResult, InferenceContext, PointerCast,\n+        TypeError, TypeMismatch,\n+    },\n+    static_lifetime, Canonical, DomainGoal, FnPointer, FnSig, InEnvironment, Interner, Solution,\n+    Substitution, Ty, TyBuilder, TyExt, TyKind,\n };\n \n-use super::{InEnvironment, InferOk, InferResult, InferenceContext, TypeError};\n+pub(crate) type CoerceResult = Result<InferOk<(Vec<Adjustment>, Ty)>, TypeError>;\n \n-impl<'a> InferenceContext<'a> {\n-    /// Unify two types, but may coerce the first one to the second one\n-    /// using \"implicit coercion rules\" if needed.\n-    pub(super) fn coerce(&mut self, from_ty: &Ty, to_ty: &Ty) -> bool {\n-        let from_ty = self.resolve_ty_shallow(from_ty);\n-        let to_ty = self.resolve_ty_shallow(to_ty);\n-        match self.coerce_inner(from_ty, &to_ty) {\n-            Ok(result) => {\n-                self.table.register_infer_ok(result);\n-                true\n-            }\n-            Err(_) => {\n-                // FIXME deal with error\n-                false\n-            }\n-        }\n+/// Do not require any adjustments, i.e. coerce `x -> x`.\n+fn identity(_: Ty) -> Vec<Adjustment> {\n+    vec![]\n+}\n+\n+fn simple(kind: Adjust) -> impl FnOnce(Ty) -> Vec<Adjustment> {\n+    move |target| vec![Adjustment { kind, target }]\n+}\n+\n+/// This always returns `Ok(...)`.\n+fn success(\n+    adj: Vec<Adjustment>,\n+    target: Ty,\n+    goals: Vec<InEnvironment<Goal<Interner>>>,\n+) -> CoerceResult {\n+    Ok(InferOk { goals, value: (adj, target) })\n+}\n+\n+#[derive(Clone, Debug)]\n+pub(super) struct CoerceMany {\n+    expected_ty: Ty,\n+}\n+\n+impl CoerceMany {\n+    pub(super) fn new(expected: Ty) -> Self {\n+        CoerceMany { expected_ty: expected }\n     }\n \n     /// Merge two types from different branches, with possible coercion.\n@@ -40,54 +55,92 @@ impl<'a> InferenceContext<'a> {\n     ///    coerce both to function pointers;\n     ///  - if we were concerned with lifetime subtyping, we'd need to look for a\n     ///    least upper bound.\n-    pub(super) fn coerce_merge_branch(&mut self, id: Option<ExprId>, ty1: &Ty, ty2: &Ty) -> Ty {\n-        let ty1 = self.resolve_ty_shallow(ty1);\n-        let ty2 = self.resolve_ty_shallow(ty2);\n+    pub(super) fn coerce(\n+        &mut self,\n+        ctx: &mut InferenceContext<'_>,\n+        expr: Option<ExprId>,\n+        expr_ty: &Ty,\n+    ) {\n+        let expr_ty = ctx.resolve_ty_shallow(expr_ty);\n+        self.expected_ty = ctx.resolve_ty_shallow(&self.expected_ty);\n+\n         // Special case: two function types. Try to coerce both to\n         // pointers to have a chance at getting a match. See\n         // https://github.com/rust-lang/rust/blob/7b805396bf46dce972692a6846ce2ad8481c5f85/src/librustc_typeck/check/coercion.rs#L877-L916\n-        let sig = match (ty1.kind(&Interner), ty2.kind(&Interner)) {\n+        let sig = match (self.expected_ty.kind(&Interner), expr_ty.kind(&Interner)) {\n             (TyKind::FnDef(..) | TyKind::Closure(..), TyKind::FnDef(..) | TyKind::Closure(..)) => {\n                 // FIXME: we're ignoring safety here. To be more correct, if we have one FnDef and one Closure,\n                 // we should be coercing the closure to a fn pointer of the safety of the FnDef\n                 cov_mark::hit!(coerce_fn_reification);\n-                let sig = ty1.callable_sig(self.db).expect(\"FnDef without callable sig\");\n+                let sig =\n+                    self.expected_ty.callable_sig(ctx.db).expect(\"FnDef without callable sig\");\n                 Some(sig)\n             }\n             _ => None,\n         };\n         if let Some(sig) = sig {\n             let target_ty = TyKind::Function(sig.to_fn_ptr()).intern(&Interner);\n-            let result1 = self.coerce_inner(ty1.clone(), &target_ty);\n-            let result2 = self.coerce_inner(ty2.clone(), &target_ty);\n+            let result1 = ctx.coerce_inner(self.expected_ty.clone(), &target_ty);\n+            let result2 = ctx.coerce_inner(expr_ty.clone(), &target_ty);\n             if let (Ok(result1), Ok(result2)) = (result1, result2) {\n-                self.table.register_infer_ok(result1);\n-                self.table.register_infer_ok(result2);\n-                return target_ty;\n+                ctx.table.register_infer_ok(result1);\n+                ctx.table.register_infer_ok(result2);\n+                return self.expected_ty = target_ty;\n             }\n         }\n \n-        // It might not seem like it, but order is important here: ty1 is our\n-        // \"previous\" type, ty2 is the \"new\" one being added. If the previous\n+        // It might not seem like it, but order is important here: If the expected\n         // type is a type variable and the new one is `!`, trying it the other\n         // way around first would mean we make the type variable `!`, instead of\n         // just marking it as possibly diverging.\n-        if self.coerce(&ty2, &ty1) {\n-            ty1\n-        } else if self.coerce(&ty1, &ty2) {\n-            ty2\n+        if ctx.coerce(expr, &expr_ty, &self.expected_ty).is_ok() {\n+            /* self.expected_ty is already correct */\n+        } else if ctx.coerce(expr, &self.expected_ty, &expr_ty).is_ok() {\n+            self.expected_ty = expr_ty;\n         } else {\n-            if let Some(id) = id {\n-                self.result\n-                    .type_mismatches\n-                    .insert(id.into(), TypeMismatch { expected: ty1.clone(), actual: ty2 });\n+            if let Some(id) = expr {\n+                ctx.result.type_mismatches.insert(\n+                    id.into(),\n+                    TypeMismatch { expected: self.expected_ty.clone(), actual: expr_ty },\n+                );\n             }\n             cov_mark::hit!(coerce_merge_fail_fallback);\n-            ty1\n+            /* self.expected_ty is already correct */\n+        }\n+    }\n+\n+    pub(super) fn complete(self) -> Ty {\n+        self.expected_ty\n+    }\n+}\n+\n+impl<'a> InferenceContext<'a> {\n+    /// Unify two types, but may coerce the first one to the second one\n+    /// using \"implicit coercion rules\" if needed.\n+    pub(super) fn coerce(\n+        &mut self,\n+        expr: Option<ExprId>,\n+        from_ty: &Ty,\n+        to_ty: &Ty,\n+    ) -> InferResult<Ty> {\n+        let from_ty = self.resolve_ty_shallow(from_ty);\n+        let to_ty = self.resolve_ty_shallow(to_ty);\n+        match self.coerce_inner(from_ty, &to_ty) {\n+            Ok(InferOk { value: (adjustments, ty), goals }) => {\n+                if let Some(expr) = expr {\n+                    self.write_expr_adj(expr, adjustments);\n+                }\n+                self.table.register_infer_ok(InferOk { value: (), goals });\n+                Ok(InferOk { value: ty, goals: Vec::new() })\n+            }\n+            Err(e) => {\n+                // FIXME deal with error\n+                Err(e)\n+            }\n         }\n     }\n \n-    fn coerce_inner(&mut self, from_ty: Ty, to_ty: &Ty) -> InferResult {\n+    fn coerce_inner(&mut self, from_ty: Ty, to_ty: &Ty) -> CoerceResult {\n         if from_ty.is_never() {\n             // Subtle: If we are coercing from `!` to `?T`, where `?T` is an unbound\n             // type variable, we want `?T` to fallback to `!` if not\n@@ -96,13 +149,10 @@ impl<'a> InferenceContext<'a> {\n             //     let _: Option<?T> = Some({ return; });\n             //\n             // here, we would coerce from `!` to `?T`.\n-            match to_ty.kind(&Interner) {\n-                TyKind::InferenceVar(tv, TyVariableKind::General) => {\n-                    self.table.set_diverging(*tv, true);\n-                }\n-                _ => {}\n+            if let TyKind::InferenceVar(tv, TyVariableKind::General) = to_ty.kind(&Interner) {\n+                self.table.set_diverging(*tv, true);\n             }\n-            return Ok(InferOk { goals: Vec::new() });\n+            return success(simple(Adjust::NeverToAny)(to_ty.clone()), to_ty.clone(), vec![]);\n         }\n \n         // Consider coercing the subtype to a DST\n@@ -112,12 +162,8 @@ impl<'a> InferenceContext<'a> {\n \n         // Examine the supertype and consider auto-borrowing.\n         match to_ty.kind(&Interner) {\n-            TyKind::Raw(mt, _) => {\n-                return self.coerce_ptr(from_ty, to_ty, *mt);\n-            }\n-            TyKind::Ref(mt, _, _) => {\n-                return self.coerce_ref(from_ty, to_ty, *mt);\n-            }\n+            TyKind::Raw(mt, _) => return self.coerce_ptr(from_ty, to_ty, *mt),\n+            TyKind::Ref(mt, _, _) => return self.coerce_ref(from_ty, to_ty, *mt),\n             _ => {}\n         }\n \n@@ -143,35 +189,63 @@ impl<'a> InferenceContext<'a> {\n             }\n             _ => {\n                 // Otherwise, just use unification rules.\n-                self.table.try_unify(&from_ty, to_ty)\n+                self.unify_and(&from_ty, to_ty, identity)\n             }\n         }\n     }\n \n-    fn coerce_ptr(&mut self, from_ty: Ty, to_ty: &Ty, to_mt: Mutability) -> InferResult {\n-        let (_is_ref, from_mt, from_inner) = match from_ty.kind(&Interner) {\n+    /// Unify two types (using sub or lub) and produce a specific coercion.\n+    fn unify_and<F>(&mut self, t1: &Ty, t2: &Ty, f: F) -> CoerceResult\n+    where\n+        F: FnOnce(Ty) -> Vec<Adjustment>,\n+    {\n+        self.table\n+            .try_unify(t1, t2)\n+            .and_then(|InferOk { goals, .. }| success(f(t1.clone()), t1.clone(), goals))\n+    }\n+\n+    fn coerce_ptr(&mut self, from_ty: Ty, to_ty: &Ty, to_mt: Mutability) -> CoerceResult {\n+        let (is_ref, from_mt, from_inner) = match from_ty.kind(&Interner) {\n             TyKind::Ref(mt, _, ty) => (true, mt, ty),\n             TyKind::Raw(mt, ty) => (false, mt, ty),\n-            _ => return self.table.try_unify(&from_ty, to_ty),\n+            _ => return self.unify_and(&from_ty, to_ty, identity),\n         };\n \n         coerce_mutabilities(*from_mt, to_mt)?;\n \n         // Check that the types which they point at are compatible.\n         let from_raw = TyKind::Raw(to_mt, from_inner.clone()).intern(&Interner);\n-        // FIXME: behavior differs based on is_ref once we're computing adjustments\n-        self.table.try_unify(&from_raw, to_ty)\n+\n+        // Although references and unsafe ptrs have the same\n+        // representation, we still register an Adjust::DerefRef so that\n+        // regionck knows that the region for `a` must be valid here.\n+        if is_ref {\n+            self.unify_and(&from_raw, to_ty, |target| {\n+                vec![\n+                    Adjustment { kind: Adjust::Deref(None), target: from_inner.clone() },\n+                    Adjustment { kind: Adjust::Borrow(AutoBorrow::RawPtr(to_mt)), target },\n+                ]\n+            })\n+        } else if *from_mt != to_mt {\n+            self.unify_and(\n+                &from_raw,\n+                to_ty,\n+                simple(Adjust::Pointer(PointerCast::MutToConstPointer)),\n+            )\n+        } else {\n+            self.unify_and(&from_raw, to_ty, identity)\n+        }\n     }\n \n     /// Reborrows `&mut A` to `&mut B` and `&(mut) A` to `&B`.\n     /// To match `A` with `B`, autoderef will be performed,\n     /// calling `deref`/`deref_mut` where necessary.\n-    fn coerce_ref(&mut self, from_ty: Ty, to_ty: &Ty, to_mt: Mutability) -> InferResult {\n+    fn coerce_ref(&mut self, from_ty: Ty, to_ty: &Ty, to_mt: Mutability) -> CoerceResult {\n         match from_ty.kind(&Interner) {\n             TyKind::Ref(mt, _, _) => {\n                 coerce_mutabilities(*mt, to_mt)?;\n             }\n-            _ => return self.table.try_unify(&from_ty, to_ty),\n+            _ => return self.unify_and(&from_ty, to_ty, identity),\n         };\n \n         // NOTE: this code is mostly copied and adapted from rustc, and\n@@ -227,7 +301,7 @@ impl<'a> InferenceContext<'a> {\n             let derefd_from_ty = TyKind::Ref(to_mt, lt, referent_ty).intern(&Interner);\n             match self.table.try_unify(&derefd_from_ty, to_ty) {\n                 Ok(result) => {\n-                    found = Some(result);\n+                    found = Some(result.map(|()| derefd_from_ty));\n                     break;\n                 }\n                 Err(err) => {\n@@ -243,19 +317,23 @@ impl<'a> InferenceContext<'a> {\n         // (e.g., in example above, the failure from relating `Vec<T>`\n         // to the target type), since that should be the least\n         // confusing.\n-        let result = match found {\n+        let InferOk { value: ty, goals } = match found {\n             Some(d) => d,\n             None => {\n                 let err = first_error.expect(\"coerce_borrowed_pointer had no error\");\n                 return Err(err);\n             }\n         };\n-\n-        Ok(result)\n+        // FIXME: record overloaded deref adjustments\n+        success(\n+            vec![Adjustment { kind: Adjust::Borrow(AutoBorrow::Ref(to_mt)), target: ty.clone() }],\n+            ty,\n+            goals,\n+        )\n     }\n \n     /// Attempts to coerce from the type of a Rust function item into a function pointer.\n-    fn coerce_from_fn_item(&mut self, from_ty: Ty, to_ty: &Ty) -> InferResult {\n+    fn coerce_from_fn_item(&mut self, from_ty: Ty, to_ty: &Ty) -> CoerceResult {\n         match to_ty.kind(&Interner) {\n             TyKind::Function(_) => {\n                 let from_sig = from_ty.callable_sig(self.db).expect(\"FnDef had no sig\");\n@@ -267,11 +345,28 @@ impl<'a> InferenceContext<'a> {\n \n                 let from_sig = from_sig.to_fn_ptr();\n                 let from_fn_pointer = TyKind::Function(from_sig.clone()).intern(&Interner);\n-                let ok = self.coerce_from_safe_fn(from_fn_pointer, &from_sig, to_ty)?;\n+                let ok = self.coerce_from_safe_fn(\n+                    from_fn_pointer.clone(),\n+                    &from_sig,\n+                    to_ty,\n+                    |unsafe_ty| {\n+                        vec![\n+                            Adjustment {\n+                                kind: Adjust::Pointer(PointerCast::ReifyFnPointer),\n+                                target: from_fn_pointer,\n+                            },\n+                            Adjustment {\n+                                kind: Adjust::Pointer(PointerCast::UnsafeFnPointer),\n+                                target: unsafe_ty,\n+                            },\n+                        ]\n+                    },\n+                    simple(Adjust::Pointer(PointerCast::ReifyFnPointer)),\n+                )?;\n \n                 Ok(ok)\n             }\n-            _ => self.table.try_unify(&from_ty, to_ty),\n+            _ => self.unify_and(&from_ty, to_ty, identity),\n         }\n     }\n \n@@ -280,26 +375,38 @@ impl<'a> InferenceContext<'a> {\n         from_ty: Ty,\n         from_f: &FnPointer,\n         to_ty: &Ty,\n-    ) -> InferResult {\n-        self.coerce_from_safe_fn(from_ty, from_f, to_ty)\n+    ) -> CoerceResult {\n+        self.coerce_from_safe_fn(\n+            from_ty,\n+            from_f,\n+            to_ty,\n+            simple(Adjust::Pointer(PointerCast::UnsafeFnPointer)),\n+            identity,\n+        )\n     }\n \n-    fn coerce_from_safe_fn(\n+    fn coerce_from_safe_fn<F, G>(\n         &mut self,\n         from_ty: Ty,\n         from_fn_ptr: &FnPointer,\n         to_ty: &Ty,\n-    ) -> InferResult {\n+        to_unsafe: F,\n+        normal: G,\n+    ) -> CoerceResult\n+    where\n+        F: FnOnce(Ty) -> Vec<Adjustment>,\n+        G: FnOnce(Ty) -> Vec<Adjustment>,\n+    {\n         if let TyKind::Function(to_fn_ptr) = to_ty.kind(&Interner) {\n             if let (chalk_ir::Safety::Safe, chalk_ir::Safety::Unsafe) =\n                 (from_fn_ptr.sig.safety, to_fn_ptr.sig.safety)\n             {\n                 let from_unsafe =\n                     TyKind::Function(safe_to_unsafe_fn_ty(from_fn_ptr.clone())).intern(&Interner);\n-                return self.table.try_unify(&from_unsafe, to_ty);\n+                return self.unify_and(&from_unsafe, to_ty, to_unsafe);\n             }\n         }\n-        self.table.try_unify(&from_ty, to_ty)\n+        self.unify_and(&from_ty, to_ty, normal)\n     }\n \n     /// Attempts to coerce from the type of a non-capturing closure into a\n@@ -309,9 +416,10 @@ impl<'a> InferenceContext<'a> {\n         from_ty: Ty,\n         from_substs: &Substitution,\n         to_ty: &Ty,\n-    ) -> InferResult {\n+    ) -> CoerceResult {\n         match to_ty.kind(&Interner) {\n-            TyKind::Function(fn_ty) /* if from_substs is non-capturing (FIXME) */ => {\n+            // if from_substs is non-capturing (FIXME)\n+            TyKind::Function(fn_ty) => {\n                 // We coerce the closure, which has fn type\n                 //     `extern \"rust-call\" fn((arg0,arg1,...)) -> _`\n                 // to\n@@ -320,16 +428,20 @@ impl<'a> InferenceContext<'a> {\n                 //     `unsafe fn(arg0,arg1,...) -> _`\n                 let safety = fn_ty.sig.safety;\n                 let pointer_ty = coerce_closure_fn_ty(from_substs, safety);\n-                self.table.try_unify(&pointer_ty, to_ty)\n+                self.unify_and(\n+                    &pointer_ty,\n+                    to_ty,\n+                    simple(Adjust::Pointer(PointerCast::ClosureFnPointer(safety))),\n+                )\n             }\n-            _ => self.table.try_unify(&from_ty, to_ty),\n+            _ => self.unify_and(&from_ty, to_ty, identity),\n         }\n     }\n \n     /// Coerce a type using `from_ty: CoerceUnsized<ty_ty>`\n     ///\n     /// See: <https://doc.rust-lang.org/nightly/std/marker/trait.CoerceUnsized.html>\n-    fn try_coerce_unsized(&mut self, from_ty: &Ty, to_ty: &Ty) -> InferResult {\n+    fn try_coerce_unsized(&mut self, from_ty: &Ty, to_ty: &Ty) -> CoerceResult {\n         // These 'if' statements require some explanation.\n         // The `CoerceUnsized` trait is special - it is only\n         // possible to write `impl CoerceUnsized<B> for A` where\n@@ -341,7 +453,7 @@ impl<'a> InferenceContext<'a> {\n         //\n         // Both of these trigger a special `CoerceUnsized`-related error (E0376)\n         //\n-        // We can take advantage of this fact to avoid performing unecessary work.\n+        // We can take advantage of this fact to avoid performing unnecessary work.\n         // If either `source` or `target` is a type variable, then any applicable impl\n         // would need to be generic over the self-type (`impl<T> CoerceUnsized<SomeType> for T`)\n         // or generic over the `CoerceUnsized` type parameter (`impl<T> CoerceUnsized<T> for\n@@ -359,20 +471,34 @@ impl<'a> InferenceContext<'a> {\n         }\n \n         // Handle reborrows before trying to solve `Source: CoerceUnsized<Target>`.\n-        let coerce_from = match (from_ty.kind(&Interner), to_ty.kind(&Interner)) {\n-            (TyKind::Ref(from_mt, _, from_inner), TyKind::Ref(to_mt, _, _)) => {\n-                coerce_mutabilities(*from_mt, *to_mt)?;\n+        let reborrow = match (from_ty.kind(&Interner), to_ty.kind(&Interner)) {\n+            (TyKind::Ref(from_mt, _, from_inner), &TyKind::Ref(to_mt, _, _)) => {\n+                coerce_mutabilities(*from_mt, to_mt)?;\n \n                 let lt = static_lifetime();\n-                TyKind::Ref(*to_mt, lt, from_inner.clone()).intern(&Interner)\n+                Some((\n+                    Adjustment { kind: Adjust::Deref(None), target: from_inner.clone() },\n+                    Adjustment {\n+                        kind: Adjust::Borrow(AutoBorrow::Ref(to_mt)),\n+                        target: TyKind::Ref(to_mt, lt, from_inner.clone()).intern(&Interner),\n+                    },\n+                ))\n             }\n-            (TyKind::Ref(from_mt, _, from_inner), TyKind::Raw(to_mt, _)) => {\n-                coerce_mutabilities(*from_mt, *to_mt)?;\n-\n-                TyKind::Raw(*to_mt, from_inner.clone()).intern(&Interner)\n+            (TyKind::Ref(from_mt, _, from_inner), &TyKind::Raw(to_mt, _)) => {\n+                coerce_mutabilities(*from_mt, to_mt)?;\n+\n+                Some((\n+                    Adjustment { kind: Adjust::Deref(None), target: from_inner.clone() },\n+                    Adjustment {\n+                        kind: Adjust::Borrow(AutoBorrow::RawPtr(to_mt)),\n+                        target: TyKind::Raw(to_mt, from_inner.clone()).intern(&Interner),\n+                    },\n+                ))\n             }\n-            _ => from_ty.clone(),\n+            _ => None,\n         };\n+        let coerce_from =\n+            reborrow.as_ref().map_or_else(|| from_ty.clone(), |(_, adj)| adj.target.clone());\n \n         let krate = self.resolver.krate().unwrap();\n         let coerce_unsized_trait = match self.db.lang_item(krate, \"coerce_unsized\".into()) {\n@@ -417,8 +543,13 @@ impl<'a> InferenceContext<'a> {\n             // FIXME: should we accept ambiguous results here?\n             _ => return Err(TypeError),\n         };\n-\n-        Ok(InferOk { goals: Vec::new() })\n+        let unsize =\n+            Adjustment { kind: Adjust::Pointer(PointerCast::Unsize), target: to_ty.clone() };\n+        let adjustments = match reborrow {\n+            None => vec![unsize],\n+            Some((deref, autoref)) => vec![deref, autoref, unsize],\n+        };\n+        success(adjustments, to_ty.clone(), vec![])\n     }\n }\n "}, {"sha": "9904676096511c62c7d6f290e5b00e070eee0e16", "filename": "crates/hir_ty/src/infer/expr.rs", "status": "modified", "additions": 74, "deletions": 59, "changes": 133, "blob_url": "https://github.com/rust-lang/rust/blob/eab5d985ec6ff8b8f39f39af949829410d79db4a/crates%2Fhir_ty%2Fsrc%2Finfer%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eab5d985ec6ff8b8f39f39af949829410d79db4a/crates%2Fhir_ty%2Fsrc%2Finfer%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Finfer%2Fexpr.rs?ref=eab5d985ec6ff8b8f39f39af949829410d79db4a", "patch": "@@ -16,6 +16,7 @@ use syntax::ast::RangeOp;\n \n use crate::{\n     autoderef, consteval,\n+    infer::coerce::CoerceMany,\n     lower::lower_to_chalk_mutability,\n     mapping::from_chalk,\n     method_resolution, op,\n@@ -56,15 +57,16 @@ impl<'a> InferenceContext<'a> {\n     pub(super) fn infer_expr_coerce(&mut self, expr: ExprId, expected: &Expectation) -> Ty {\n         let ty = self.infer_expr_inner(expr, expected);\n         let ty = if let Some(target) = expected.only_has_type(&mut self.table) {\n-            if !self.coerce(&ty, &target) {\n-                self.result\n-                    .type_mismatches\n-                    .insert(expr.into(), TypeMismatch { expected: target, actual: ty.clone() });\n-                // Return actual type when type mismatch.\n-                // This is needed for diagnostic when return type mismatch.\n-                ty\n-            } else {\n-                target\n+            match self.coerce(Some(expr), &ty, &target) {\n+                Ok(res) => res.value,\n+                Err(_) => {\n+                    self.result\n+                        .type_mismatches\n+                        .insert(expr.into(), TypeMismatch { expected: target, actual: ty.clone() });\n+                    // Return actual type when type mismatch.\n+                    // This is needed for diagnostic when return type mismatch.\n+                    ty\n+                }\n             }\n         } else {\n             ty\n@@ -124,31 +126,32 @@ impl<'a> InferenceContext<'a> {\n         let body = Arc::clone(&self.body); // avoid borrow checker problem\n         let ty = match &body[tgt_expr] {\n             Expr::Missing => self.err_ty(),\n-            Expr::If { condition, then_branch, else_branch } => {\n+            &Expr::If { condition, then_branch, else_branch } => {\n                 // if let is desugared to match, so this is always simple if\n                 self.infer_expr(\n-                    *condition,\n+                    condition,\n                     &Expectation::has_type(TyKind::Scalar(Scalar::Bool).intern(&Interner)),\n                 );\n \n                 let condition_diverges = mem::replace(&mut self.diverges, Diverges::Maybe);\n                 let mut both_arms_diverge = Diverges::Always;\n \n-                let mut result_ty = self.table.new_type_var();\n-                let then_ty = self.infer_expr_inner(*then_branch, expected);\n+                let result_ty = self.table.new_type_var();\n+                let then_ty = self.infer_expr_inner(then_branch, expected);\n                 both_arms_diverge &= mem::replace(&mut self.diverges, Diverges::Maybe);\n-                result_ty = self.coerce_merge_branch(Some(*then_branch), &result_ty, &then_ty);\n+                let mut coerce = CoerceMany::new(result_ty);\n+                coerce.coerce(self, Some(then_branch), &then_ty);\n                 let else_ty = match else_branch {\n-                    Some(else_branch) => self.infer_expr_inner(*else_branch, expected),\n+                    Some(else_branch) => self.infer_expr_inner(else_branch, expected),\n                     None => TyBuilder::unit(),\n                 };\n                 both_arms_diverge &= self.diverges;\n                 // FIXME: create a synthetic `else {}` so we have something to refer to here instead of None?\n-                result_ty = self.coerce_merge_branch(*else_branch, &result_ty, &else_ty);\n+                coerce.coerce(self, else_branch, &else_ty);\n \n                 self.diverges = condition_diverges | both_arms_diverge;\n \n-                result_ty\n+                coerce.complete()\n             }\n             Expr::Block { statements, tail, label, id: _ } => {\n                 let old_resolver = mem::replace(\n@@ -160,19 +163,23 @@ impl<'a> InferenceContext<'a> {\n                         let break_ty = self.table.new_type_var();\n                         self.breakables.push(BreakableContext {\n                             may_break: false,\n-                            break_ty: break_ty.clone(),\n+                            coerce: CoerceMany::new(break_ty.clone()),\n                             label: label.map(|label| self.body[label].name.clone()),\n                         });\n-                        let ty =\n-                            self.infer_block(statements, *tail, &Expectation::has_type(break_ty));\n+                        let ty = self.infer_block(\n+                            tgt_expr,\n+                            statements,\n+                            *tail,\n+                            &Expectation::has_type(break_ty),\n+                        );\n                         let ctxt = self.breakables.pop().expect(\"breakable stack broken\");\n                         if ctxt.may_break {\n-                            ctxt.break_ty\n+                            ctxt.coerce.complete()\n                         } else {\n                             ty\n                         }\n                     }\n-                    None => self.infer_block(statements, *tail, expected),\n+                    None => self.infer_block(tgt_expr, statements, *tail, expected),\n                 };\n                 self.resolver = old_resolver;\n                 ty\n@@ -185,7 +192,7 @@ impl<'a> InferenceContext<'a> {\n             }\n             Expr::Async { body } => {\n                 // Use the first type parameter as the output type of future.\n-                // existenail type AsyncBlockImplTrait<InnerType>: Future<Output = InnerType>\n+                // existential type AsyncBlockImplTrait<InnerType>: Future<Output = InnerType>\n                 let inner_ty = self.infer_expr(*body, &Expectation::none());\n                 let impl_trait_id = crate::ImplTraitId::AsyncBlockTypeImplTrait(self.owner, *body);\n                 let opaque_ty_id = self.db.intern_impl_trait_id(impl_trait_id).into();\n@@ -195,26 +202,24 @@ impl<'a> InferenceContext<'a> {\n             Expr::Loop { body, label } => {\n                 self.breakables.push(BreakableContext {\n                     may_break: false,\n-                    break_ty: self.table.new_type_var(),\n+                    coerce: CoerceMany::new(self.table.new_type_var()),\n                     label: label.map(|label| self.body[label].name.clone()),\n                 });\n                 self.infer_expr(*body, &Expectation::has_type(TyBuilder::unit()));\n \n                 let ctxt = self.breakables.pop().expect(\"breakable stack broken\");\n-                if ctxt.may_break {\n-                    self.diverges = Diverges::Maybe;\n-                }\n \n                 if ctxt.may_break {\n-                    ctxt.break_ty\n+                    self.diverges = Diverges::Maybe;\n+                    ctxt.coerce.complete()\n                 } else {\n                     TyKind::Never.intern(&Interner)\n                 }\n             }\n             Expr::While { condition, body, label } => {\n                 self.breakables.push(BreakableContext {\n                     may_break: false,\n-                    break_ty: self.err_ty(),\n+                    coerce: CoerceMany::new(self.err_ty()),\n                     label: label.map(|label| self.body[label].name.clone()),\n                 });\n                 // while let is desugared to a match loop, so this is always simple while\n@@ -233,7 +238,7 @@ impl<'a> InferenceContext<'a> {\n \n                 self.breakables.push(BreakableContext {\n                     may_break: false,\n-                    break_ty: self.err_ty(),\n+                    coerce: CoerceMany::new(self.err_ty()),\n                     label: label.map(|label| self.body[label].name.clone()),\n                 });\n                 let pat_ty =\n@@ -284,7 +289,12 @@ impl<'a> InferenceContext<'a> {\n                 // Eagerly try to relate the closure type with the expected\n                 // type, otherwise we often won't have enough information to\n                 // infer the body.\n-                self.deduce_closure_type_from_expectations(&closure_ty, &sig_ty, expected);\n+                self.deduce_closure_type_from_expectations(\n+                    tgt_expr,\n+                    &closure_ty,\n+                    &sig_ty,\n+                    expected,\n+                );\n \n                 // Now go through the argument patterns\n                 for (arg_pat, arg_ty) in args.iter().zip(sig_tys) {\n@@ -331,14 +341,15 @@ impl<'a> InferenceContext<'a> {\n \n                 let expected = expected.adjust_for_branches(&mut self.table);\n \n-                let mut result_ty = if arms.is_empty() {\n+                let result_ty = if arms.is_empty() {\n                     TyKind::Never.intern(&Interner)\n                 } else {\n                     match &expected {\n                         Expectation::HasType(ty) => ty.clone(),\n                         _ => self.table.new_type_var(),\n                     }\n                 };\n+                let mut coerce = CoerceMany::new(result_ty);\n \n                 let matchee_diverges = self.diverges;\n                 let mut all_arms_diverge = Diverges::Always;\n@@ -355,12 +366,12 @@ impl<'a> InferenceContext<'a> {\n \n                     let arm_ty = self.infer_expr_inner(arm.expr, &expected);\n                     all_arms_diverge &= self.diverges;\n-                    result_ty = self.coerce_merge_branch(Some(arm.expr), &result_ty, &arm_ty);\n+                    coerce.coerce(self, Some(arm.expr), &arm_ty);\n                 }\n \n                 self.diverges = matchee_diverges | all_arms_diverge;\n \n-                result_ty\n+                coerce.complete()\n             }\n             Expr::Path(p) => {\n                 // FIXME this could be more efficient...\n@@ -369,38 +380,43 @@ impl<'a> InferenceContext<'a> {\n             }\n             Expr::Continue { .. } => TyKind::Never.intern(&Interner),\n             Expr::Break { expr, label } => {\n-                let last_ty =\n-                    if let Some(ctxt) = find_breakable(&mut self.breakables, label.as_ref()) {\n-                        ctxt.break_ty.clone()\n-                    } else {\n-                        self.err_ty()\n-                    };\n+                let mut coerce = match find_breakable(&mut self.breakables, label.as_ref()) {\n+                    Some(ctxt) => {\n+                        // avoiding the borrowck\n+                        mem::replace(\n+                            &mut ctxt.coerce,\n+                            CoerceMany::new(self.result.standard_types.unknown.clone()),\n+                        )\n+                    }\n+                    None => CoerceMany::new(self.result.standard_types.unknown.clone()),\n+                };\n \n-                let val_ty = if let Some(expr) = expr {\n-                    self.infer_expr(*expr, &Expectation::none())\n+                let val_ty = if let Some(expr) = *expr {\n+                    self.infer_expr(expr, &Expectation::none())\n                 } else {\n                     TyBuilder::unit()\n                 };\n \n                 // FIXME: create a synthetic `()` during lowering so we have something to refer to here?\n-                let merged_type = self.coerce_merge_branch(*expr, &last_ty, &val_ty);\n+                coerce.coerce(self, *expr, &val_ty);\n \n                 if let Some(ctxt) = find_breakable(&mut self.breakables, label.as_ref()) {\n-                    ctxt.break_ty = merged_type;\n+                    ctxt.coerce = coerce;\n                     ctxt.may_break = true;\n                 } else {\n                     self.push_diagnostic(InferenceDiagnostic::BreakOutsideOfLoop {\n                         expr: tgt_expr,\n                     });\n-                }\n+                };\n+\n                 TyKind::Never.intern(&Interner)\n             }\n             Expr::Return { expr } => {\n                 if let Some(expr) = expr {\n                     self.infer_expr_coerce(*expr, &Expectation::has_type(self.return_ty.clone()));\n                 } else {\n                     let unit = TyBuilder::unit();\n-                    self.coerce(&unit, &self.return_ty.clone());\n+                    let _ = self.coerce(Some(tgt_expr), &unit, &self.return_ty.clone());\n                 }\n                 TyKind::Never.intern(&Interner)\n             }\n@@ -729,39 +745,37 @@ impl<'a> InferenceContext<'a> {\n                 TyKind::Tuple(tys.len(), Substitution::from_iter(&Interner, tys)).intern(&Interner)\n             }\n             Expr::Array(array) => {\n-                let mut elem_ty =\n+                let elem_ty =\n                     match expected.to_option(&mut self.table).as_ref().map(|t| t.kind(&Interner)) {\n                         Some(TyKind::Array(st, _) | TyKind::Slice(st)) => st.clone(),\n                         _ => self.table.new_type_var(),\n                     };\n+                let mut coerce = CoerceMany::new(elem_ty.clone());\n \n                 let expected = Expectation::has_type(elem_ty.clone());\n                 let len = match array {\n                     Array::ElementList(items) => {\n-                        for expr in items.iter() {\n-                            let cur_elem_ty = self.infer_expr_inner(*expr, &expected);\n-                            elem_ty = self.coerce_merge_branch(Some(*expr), &elem_ty, &cur_elem_ty);\n+                        for &expr in items.iter() {\n+                            let cur_elem_ty = self.infer_expr_inner(expr, &expected);\n+                            coerce.coerce(self, Some(expr), &cur_elem_ty);\n                         }\n                         Some(items.len() as u64)\n                     }\n-                    Array::Repeat { initializer, repeat } => {\n-                        self.infer_expr_coerce(\n-                            *initializer,\n-                            &Expectation::has_type(elem_ty.clone()),\n-                        );\n+                    &Array::Repeat { initializer, repeat } => {\n+                        self.infer_expr_coerce(initializer, &Expectation::has_type(elem_ty));\n                         self.infer_expr(\n-                            *repeat,\n+                            repeat,\n                             &Expectation::has_type(\n                                 TyKind::Scalar(Scalar::Uint(UintTy::Usize)).intern(&Interner),\n                             ),\n                         );\n \n-                        let repeat_expr = &self.body.exprs[*repeat];\n+                        let repeat_expr = &self.body.exprs[repeat];\n                         consteval::eval_usize(repeat_expr)\n                     }\n                 };\n \n-                TyKind::Array(elem_ty, consteval::usize_const(len)).intern(&Interner)\n+                TyKind::Array(coerce.complete(), consteval::usize_const(len)).intern(&Interner)\n             }\n             Expr::Literal(lit) => match lit {\n                 Literal::Bool(..) => TyKind::Scalar(Scalar::Bool).intern(&Interner),\n@@ -810,6 +824,7 @@ impl<'a> InferenceContext<'a> {\n \n     fn infer_block(\n         &mut self,\n+        expr: ExprId,\n         statements: &[Statement],\n         tail: Option<ExprId>,\n         expected: &Expectation,\n@@ -856,7 +871,7 @@ impl<'a> InferenceContext<'a> {\n                 self.table.new_maybe_never_var()\n             } else {\n                 if let Some(t) = expected.only_has_type(&mut self.table) {\n-                    self.coerce(&TyBuilder::unit(), &t);\n+                    let _ = self.coerce(Some(expr), &TyBuilder::unit(), &t);\n                 }\n                 TyBuilder::unit()\n             }"}, {"sha": "86e2d1b8dfab307fa1820cef7829e37df8f1a42f", "filename": "crates/hir_ty/src/infer/pat.rs", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/eab5d985ec6ff8b8f39f39af949829410d79db4a/crates%2Fhir_ty%2Fsrc%2Finfer%2Fpat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eab5d985ec6ff8b8f39f39af949829410d79db4a/crates%2Fhir_ty%2Fsrc%2Finfer%2Fpat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Finfer%2Fpat.rs?ref=eab5d985ec6ff8b8f39f39af949829410d79db4a", "patch": "@@ -12,8 +12,9 @@ use hir_expand::name::Name;\n \n use super::{BindingMode, Expectation, InferenceContext, TypeMismatch};\n use crate::{\n-    lower::lower_to_chalk_mutability, static_lifetime, Interner, Substitution, Ty, TyBuilder,\n-    TyExt, TyKind,\n+    infer::{Adjust, Adjustment, AutoBorrow},\n+    lower::lower_to_chalk_mutability,\n+    static_lifetime, Interner, Substitution, Ty, TyBuilder, TyExt, TyKind,\n };\n \n impl<'a> InferenceContext<'a> {\n@@ -103,7 +104,10 @@ impl<'a> InferenceContext<'a> {\n         if is_non_ref_pat(&body, pat) {\n             let mut pat_adjustments = Vec::new();\n             while let Some((inner, _lifetime, mutability)) = expected.as_reference() {\n-                pat_adjustments.push(expected.clone());\n+                pat_adjustments.push(Adjustment {\n+                    target: expected.clone(),\n+                    kind: Adjust::Borrow(AutoBorrow::Ref(mutability)),\n+                });\n                 expected = self.resolve_ty_shallow(inner);\n                 default_bm = match default_bm {\n                     BindingMode::Move => BindingMode::Ref(mutability),"}, {"sha": "f9e4796c270aa9a289353ac57dfd713df1453c3e", "filename": "crates/hir_ty/src/infer/unify.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/eab5d985ec6ff8b8f39f39af949829410d79db4a/crates%2Fhir_ty%2Fsrc%2Finfer%2Funify.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eab5d985ec6ff8b8f39f39af949829410d79db4a/crates%2Fhir_ty%2Fsrc%2Finfer%2Funify.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Finfer%2Funify.rs?ref=eab5d985ec6ff8b8f39f39af949829410d79db4a", "patch": "@@ -315,7 +315,7 @@ impl<'a> InferenceTable<'a> {\n \n     /// Unify two types and return new trait goals arising from it, so the\n     /// caller needs to deal with them.\n-    pub(crate) fn try_unify<T: Zip<Interner>>(&mut self, t1: &T, t2: &T) -> InferResult {\n+    pub(crate) fn try_unify<T: Zip<Interner>>(&mut self, t1: &T, t2: &T) -> InferResult<()> {\n         match self.var_unification_table.relate(\n             &Interner,\n             &self.db,\n@@ -324,7 +324,7 @@ impl<'a> InferenceTable<'a> {\n             t1,\n             t2,\n         ) {\n-            Ok(result) => Ok(InferOk { goals: result.goals }),\n+            Ok(result) => Ok(InferOk { goals: result.goals, value: () }),\n             Err(chalk_ir::NoSolution) => Err(TypeError),\n         }\n     }\n@@ -347,7 +347,7 @@ impl<'a> InferenceTable<'a> {\n         }\n     }\n \n-    pub(crate) fn register_infer_ok(&mut self, infer_ok: InferOk) {\n+    pub(crate) fn register_infer_ok<T>(&mut self, infer_ok: InferOk<T>) {\n         infer_ok.goals.into_iter().for_each(|goal| self.register_obligation_in_env(goal));\n     }\n "}, {"sha": "af6e7732177df4bdfe885ee1711a9981260e2707", "filename": "crates/hir_ty/src/tests.rs", "status": "modified", "additions": 34, "deletions": 1, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/eab5d985ec6ff8b8f39f39af949829410d79db4a/crates%2Fhir_ty%2Fsrc%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eab5d985ec6ff8b8f39f39af949829410d79db4a/crates%2Fhir_ty%2Fsrc%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Ftests.rs?ref=eab5d985ec6ff8b8f39f39af949829410d79db4a", "patch": "@@ -33,7 +33,11 @@ use tracing_subscriber::{layer::SubscriberExt, EnvFilter, Registry};\n use tracing_tree::HierarchicalLayer;\n \n use crate::{\n-    db::HirDatabase, display::HirDisplay, infer::TypeMismatch, test_db::TestDB, InferenceResult, Ty,\n+    db::HirDatabase,\n+    display::HirDisplay,\n+    infer::{Adjustment, TypeMismatch},\n+    test_db::TestDB,\n+    InferenceResult, Ty,\n };\n \n // These tests compare the inference results for all expressions in a file\n@@ -79,6 +83,7 @@ fn check_impl(ra_fixture: &str, allow_none: bool, only_types: bool, display_sour\n     let mut had_annotations = false;\n     let mut mismatches = HashMap::new();\n     let mut types = HashMap::new();\n+    let mut adjustments = HashMap::<_, Vec<_>>::new();\n     for (file_id, annotations) in db.extract_annotations() {\n         for (range, expected) in annotations {\n             let file_range = FileRange { file_id, range };\n@@ -88,6 +93,15 @@ fn check_impl(ra_fixture: &str, allow_none: bool, only_types: bool, display_sour\n                 types.insert(file_range, expected.trim_start_matches(\"type: \").to_string());\n             } else if expected.starts_with(\"expected\") {\n                 mismatches.insert(file_range, expected);\n+            } else if expected.starts_with(\"adjustments: \") {\n+                adjustments.insert(\n+                    file_range,\n+                    expected\n+                        .trim_start_matches(\"adjustments: \")\n+                        .split(',')\n+                        .map(|it| it.trim().to_string())\n+                        .collect(),\n+                );\n             } else {\n                 panic!(\"unexpected annotation: {}\", expected);\n             }\n@@ -155,6 +169,19 @@ fn check_impl(ra_fixture: &str, allow_none: bool, only_types: bool, display_sour\n                 };\n                 assert_eq!(actual, expected);\n             }\n+            if let Some(expected) = adjustments.remove(&range) {\n+                if let Some(adjustments) = inference_result.expr_adjustments.get(&expr) {\n+                    assert_eq!(\n+                        expected,\n+                        adjustments\n+                            .iter()\n+                            .map(|Adjustment { kind, .. }| format!(\"{:?}\", kind))\n+                            .collect::<Vec<_>>()\n+                    );\n+                } else {\n+                    panic!(\"expected {:?} adjustments, found none\", expected);\n+                }\n+            }\n         }\n \n         for (pat, mismatch) in inference_result.pat_type_mismatches() {\n@@ -212,6 +239,12 @@ fn check_impl(ra_fixture: &str, allow_none: bool, only_types: bool, display_sour\n             format_to!(buf, \"{:?}: type {}\\n\", t.0.range, t.1);\n         }\n     }\n+    if !adjustments.is_empty() {\n+        format_to!(buf, \"Unchecked adjustments annotations:\\n\");\n+        for t in adjustments {\n+            format_to!(buf, \"{:?}: type {:?}\\n\", t.0.range, t.1);\n+        }\n+    }\n     assert!(buf.is_empty(), \"{}\", buf);\n }\n "}, {"sha": "cc5dc5ab65c5bf40c292de5ae3ea4001da54ccb1", "filename": "crates/hir_ty/src/tests/coercion.rs", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/eab5d985ec6ff8b8f39f39af949829410d79db4a/crates%2Fhir_ty%2Fsrc%2Ftests%2Fcoercion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eab5d985ec6ff8b8f39f39af949829410d79db4a/crates%2Fhir_ty%2Fsrc%2Ftests%2Fcoercion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Ftests%2Fcoercion.rs?ref=eab5d985ec6ff8b8f39f39af949829410d79db4a", "patch": "@@ -51,7 +51,9 @@ fn let_stmt_coerce() {\n //- minicore: coerce_unsized\n fn test() {\n     let x: &[isize] = &[1];\n+                   // ^^^^ adjustments: Deref(None), Borrow(Ref(Not)), Pointer(Unsize)\n     let x: *const [isize] = &[1];\n+                         // ^^^^ adjustments: Deref(None), Borrow(RawPtr(Not)), Pointer(Unsize)\n }\n \",\n     );\n@@ -96,6 +98,7 @@ fn foo<T>(x: &[T]) -> &[T] { x }\n fn test() {\n     let x = if true {\n         foo(&[1])\n+         // ^^^^ adjustments: Deref(None), Borrow(Ref(Not)), Pointer(Unsize)\n     } else {\n         &[1]\n     };\n@@ -130,6 +133,7 @@ fn foo<T>(x: &[T]) -> &[T] { x }\n fn test(i: i32) {\n     let x = match i {\n         2 => foo(&[2]),\n+              // ^^^^ adjustments: Deref(None), Borrow(Ref(Not)), Pointer(Unsize)\n         1 => &[1],\n         _ => &[3],\n     };\n@@ -144,6 +148,7 @@ fn match_second_coerce() {\n         r#\"\n //- minicore: coerce_unsized\n fn foo<T>(x: &[T]) -> &[T] { loop {} }\n+                          // ^^^^^^^ adjustments: NeverToAny\n fn test(i: i32) {\n     let x = match i {\n         1 => &[1],\n@@ -168,9 +173,12 @@ fn test() {\n         2 => t as &i32,\n            //^^^^^^^^^ expected *mut i32, got &i32\n         _ => t as *const i32,\n+          // ^^^^^^^^^^^^^^^ adjustments: Pointer(MutToConstPointer)\n+\n     };\n     x;\n   //^ type: *const i32\n+\n }\n         \",\n     );\n@@ -255,6 +263,9 @@ fn coerce_fn_item_to_fn_ptr() {\n fn foo(x: u32) -> isize { 1 }\n fn test() {\n     let f: fn(u32) -> isize = foo;\n+                           // ^^^ adjustments: Pointer(ReifyFnPointer)\n+    let f: unsafe fn(u32) -> isize = foo;\n+                                  // ^^^ adjustments: Pointer(ReifyFnPointer)\n }\",\n     );\n }"}]}