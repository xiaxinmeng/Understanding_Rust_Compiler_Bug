{"sha": "a2d9f7d7bb8710ce45c8f0f803a88f03ae5ba29b", "node_id": "MDY6Q29tbWl0NzI0NzEyOmEyZDlmN2Q3YmI4NzEwY2U0NWM4ZjBmODAzYTg4ZjAzYWU1YmEyOWI=", "commit": {"author": {"name": "Florian Diebold", "email": "flodiebold@gmail.com", "date": "2021-09-12T08:41:30Z"}, "committer": {"name": "Florian Diebold", "email": "flodiebold@gmail.com", "date": "2021-09-12T08:49:40Z"}, "message": "Avoid type inference panic on bitslice methods\n\nShould fix #10090, #10046, #10179.\nThis is only a workaround, but the proper fix requires some bigger\nrefactoring (also related to fixing #10058), and this at least prevents\nthe crash.", "tree": {"sha": "08e871adb54705da37999bc73a77857002e8b26e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/08e871adb54705da37999bc73a77857002e8b26e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a2d9f7d7bb8710ce45c8f0f803a88f03ae5ba29b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a2d9f7d7bb8710ce45c8f0f803a88f03ae5ba29b", "html_url": "https://github.com/rust-lang/rust/commit/a2d9f7d7bb8710ce45c8f0f803a88f03ae5ba29b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a2d9f7d7bb8710ce45c8f0f803a88f03ae5ba29b/comments", "author": {"login": "flodiebold", "id": 906069, "node_id": "MDQ6VXNlcjkwNjA2OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/906069?v=4", "gravatar_id": "", "url": "https://api.github.com/users/flodiebold", "html_url": "https://github.com/flodiebold", "followers_url": "https://api.github.com/users/flodiebold/followers", "following_url": "https://api.github.com/users/flodiebold/following{/other_user}", "gists_url": "https://api.github.com/users/flodiebold/gists{/gist_id}", "starred_url": "https://api.github.com/users/flodiebold/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/flodiebold/subscriptions", "organizations_url": "https://api.github.com/users/flodiebold/orgs", "repos_url": "https://api.github.com/users/flodiebold/repos", "events_url": "https://api.github.com/users/flodiebold/events{/privacy}", "received_events_url": "https://api.github.com/users/flodiebold/received_events", "type": "User", "site_admin": false}, "committer": {"login": "flodiebold", "id": 906069, "node_id": "MDQ6VXNlcjkwNjA2OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/906069?v=4", "gravatar_id": "", "url": "https://api.github.com/users/flodiebold", "html_url": "https://github.com/flodiebold", "followers_url": "https://api.github.com/users/flodiebold/followers", "following_url": "https://api.github.com/users/flodiebold/following{/other_user}", "gists_url": "https://api.github.com/users/flodiebold/gists{/gist_id}", "starred_url": "https://api.github.com/users/flodiebold/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/flodiebold/subscriptions", "organizations_url": "https://api.github.com/users/flodiebold/orgs", "repos_url": "https://api.github.com/users/flodiebold/repos", "events_url": "https://api.github.com/users/flodiebold/events{/privacy}", "received_events_url": "https://api.github.com/users/flodiebold/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "317059985a915bcbc6e7d568143a25b96c64c1ae", "url": "https://api.github.com/repos/rust-lang/rust/commits/317059985a915bcbc6e7d568143a25b96c64c1ae", "html_url": "https://github.com/rust-lang/rust/commit/317059985a915bcbc6e7d568143a25b96c64c1ae"}], "stats": {"total": 93, "additions": 66, "deletions": 27}, "files": [{"sha": "3b0c29e87e8e7145d3a37fde0341a214dfdc0961", "filename": "crates/hir/src/lib.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a2d9f7d7bb8710ce45c8f0f803a88f03ae5ba29b/crates%2Fhir%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2d9f7d7bb8710ce45c8f0f803a88f03ae5ba29b/crates%2Fhir%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir%2Fsrc%2Flib.rs?ref=a2d9f7d7bb8710ce45c8f0f803a88f03ae5ba29b", "patch": "@@ -2612,7 +2612,7 @@ impl Type {\n             None,\n             name,\n             method_resolution::LookupMode::MethodCall,\n-            callback,\n+            &mut |ty, id| callback(&ty.value, id),\n         );\n     }\n \n@@ -2664,7 +2664,7 @@ impl Type {\n             None,\n             name,\n             method_resolution::LookupMode::Path,\n-            callback,\n+            &mut |ty, id| callback(&ty.value, id),\n         );\n     }\n "}, {"sha": "4d7ac6fd85fc7fc1a220057936e2b85fa80adda0", "filename": "crates/hir_ty/src/infer/coerce.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a2d9f7d7bb8710ce45c8f0f803a88f03ae5ba29b/crates%2Fhir_ty%2Fsrc%2Finfer%2Fcoerce.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2d9f7d7bb8710ce45c8f0f803a88f03ae5ba29b/crates%2Fhir_ty%2Fsrc%2Finfer%2Fcoerce.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Finfer%2Fcoerce.rs?ref=a2d9f7d7bb8710ce45c8f0f803a88f03ae5ba29b", "patch": "@@ -277,7 +277,7 @@ impl<'a> InferenceContext<'a> {\n                 continue;\n             }\n \n-            let referent_ty = canonicalized.decanonicalize_ty(referent_ty.value);\n+            let referent_ty = canonicalized.decanonicalize_ty(&mut self.table, referent_ty);\n \n             // At this point, we have deref'd `a` to `referent_ty`.  So\n             // imagine we are coercing from `&'a mut Vec<T>` to `&'b mut [T]`."}, {"sha": "b0306d9148ae8c1f4e5a7793d0afe5d5134c1301", "filename": "crates/hir_ty/src/infer/expr.rs", "status": "modified", "additions": 14, "deletions": 12, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/a2d9f7d7bb8710ce45c8f0f803a88f03ae5ba29b/crates%2Fhir_ty%2Fsrc%2Finfer%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2d9f7d7bb8710ce45c8f0f803a88f03ae5ba29b/crates%2Fhir_ty%2Fsrc%2Finfer%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Finfer%2Fexpr.rs?ref=a2d9f7d7bb8710ce45c8f0f803a88f03ae5ba29b", "patch": "@@ -328,10 +328,8 @@ impl<'a> InferenceContext<'a> {\n                     },\n                 );\n                 let res = derefs.by_ref().find_map(|(callee_deref_ty, _)| {\n-                    self.callable_sig(\n-                        &canonicalized.decanonicalize_ty(callee_deref_ty.value),\n-                        args.len(),\n-                    )\n+                    let ty = &canonicalized.decanonicalize_ty(&mut self.table, callee_deref_ty);\n+                    self.callable_sig(ty, args.len())\n                 });\n                 let (param_tys, ret_ty): (Vec<Ty>, Ty) = match res {\n                     Some(res) => {\n@@ -510,17 +508,20 @@ impl<'a> InferenceContext<'a> {\n                     },\n                 );\n                 let ty = autoderef.by_ref().find_map(|(derefed_ty, _)| {\n-                    let def_db = self.db.upcast();\n                     let module = self.resolver.module();\n+                    let db = self.db;\n                     let is_visible = |field_id: &FieldId| {\n                         module\n                             .map(|mod_id| {\n-                                self.db.field_visibilities(field_id.parent)[field_id.local_id]\n-                                    .is_visible_from(def_db, mod_id)\n+                                db.field_visibilities(field_id.parent)[field_id.local_id]\n+                                    .is_visible_from(db.upcast(), mod_id)\n                             })\n                             .unwrap_or(true)\n                     };\n-                    match canonicalized.decanonicalize_ty(derefed_ty.value).kind(&Interner) {\n+                    match canonicalized\n+                        .decanonicalize_ty(&mut self.table, derefed_ty)\n+                        .kind(&Interner)\n+                    {\n                         TyKind::Tuple(_, substs) => name.as_tuple_index().and_then(|idx| {\n                             substs\n                                 .as_slice(&Interner)\n@@ -637,7 +638,7 @@ impl<'a> InferenceContext<'a> {\n                                 },\n                             ) {\n                                 Some(derefed_ty) => {\n-                                    canonicalized.decanonicalize_ty(derefed_ty.value)\n+                                    canonicalized.decanonicalize_ty(&mut self.table, derefed_ty)\n                                 }\n                                 None => self.err_ty(),\n                             }\n@@ -740,8 +741,9 @@ impl<'a> InferenceContext<'a> {\n                         krate,\n                         index_trait,\n                     );\n-                    let self_ty =\n-                        self_ty.map_or(self.err_ty(), |t| canonicalized.decanonicalize_ty(t.value));\n+                    let self_ty = self_ty.map_or(self.err_ty(), |t| {\n+                        canonicalized.decanonicalize_ty(&mut self.table, t)\n+                    });\n                     self.resolve_associated_type_with_params(\n                         self_ty,\n                         self.resolve_ops_index_output(),\n@@ -987,7 +989,7 @@ impl<'a> InferenceContext<'a> {\n         });\n         let (receiver_ty, method_ty, substs) = match resolved {\n             Some((ty, func)) => {\n-                let ty = canonicalized_receiver.decanonicalize_ty(ty);\n+                let ty = canonicalized_receiver.decanonicalize_ty(&mut self.table, ty);\n                 let generics = generics(self.db.upcast(), func.into());\n                 let substs = self.substs_for_method_call(generics, generic_args, &ty);\n                 self.write_method_resolution(tgt_expr, func, substs.clone());"}, {"sha": "4c1e758904ec62c5aa07c3f638683baa20ad3c42", "filename": "crates/hir_ty/src/infer/unify.rs", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/a2d9f7d7bb8710ce45c8f0f803a88f03ae5ba29b/crates%2Fhir_ty%2Fsrc%2Finfer%2Funify.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2d9f7d7bb8710ce45c8f0f803a88f03ae5ba29b/crates%2Fhir_ty%2Fsrc%2Finfer%2Funify.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Finfer%2Funify.rs?ref=a2d9f7d7bb8710ce45c8f0f803a88f03ae5ba29b", "patch": "@@ -41,8 +41,13 @@ where\n }\n \n impl<T: HasInterner<Interner = Interner>> Canonicalized<T> {\n-    pub(super) fn decanonicalize_ty(&self, ty: Ty) -> Ty {\n-        chalk_ir::Substitute::apply(&self.free_vars, ty, &Interner)\n+    /// this method is wrong and shouldn't exist\n+    pub(super) fn decanonicalize_ty(&self, table: &mut InferenceTable, ty: Canonical<Ty>) -> Ty {\n+        let mut vars = self.free_vars.clone();\n+        while ty.binders.len(&Interner) > vars.len() {\n+            vars.push(table.new_type_var().cast(&Interner));\n+        }\n+        chalk_ir::Substitute::apply(&vars, ty.value, &Interner)\n     }\n \n     pub(super) fn apply_solution("}, {"sha": "3533d2010c5aac724f8c50951d411bfaa860490b", "filename": "crates/hir_ty/src/method_resolution.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/a2d9f7d7bb8710ce45c8f0f803a88f03ae5ba29b/crates%2Fhir_ty%2Fsrc%2Fmethod_resolution.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2d9f7d7bb8710ce45c8f0f803a88f03ae5ba29b/crates%2Fhir_ty%2Fsrc%2Fmethod_resolution.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Fmethod_resolution.rs?ref=a2d9f7d7bb8710ce45c8f0f803a88f03ae5ba29b", "patch": "@@ -380,7 +380,7 @@ pub(crate) fn lookup_method(\n     traits_in_scope: &FxHashSet<TraitId>,\n     visible_from_module: Option<ModuleId>,\n     name: &Name,\n-) -> Option<(Ty, FunctionId)> {\n+) -> Option<(Canonical<Ty>, FunctionId)> {\n     iterate_method_candidates(\n         ty,\n         db,\n@@ -421,7 +421,7 @@ pub fn iterate_method_candidates<T>(\n     visible_from_module: Option<ModuleId>,\n     name: Option<&Name>,\n     mode: LookupMode,\n-    mut callback: impl FnMut(&Ty, AssocItemId) -> Option<T>,\n+    mut callback: impl FnMut(&Canonical<Ty>, AssocItemId) -> Option<T>,\n ) -> Option<T> {\n     let mut slot = None;\n     iterate_method_candidates_dyn(\n@@ -454,7 +454,7 @@ pub fn iterate_method_candidates_dyn(\n     visible_from_module: Option<ModuleId>,\n     name: Option<&Name>,\n     mode: LookupMode,\n-    callback: &mut dyn FnMut(&Ty, AssocItemId) -> ControlFlow<()>,\n+    callback: &mut dyn FnMut(&Canonical<Ty>, AssocItemId) -> ControlFlow<()>,\n ) -> ControlFlow<()> {\n     match mode {\n         LookupMode::MethodCall => {\n@@ -520,7 +520,7 @@ fn iterate_method_candidates_with_autoref(\n     traits_in_scope: &FxHashSet<TraitId>,\n     visible_from_module: Option<ModuleId>,\n     name: Option<&Name>,\n-    mut callback: &mut dyn FnMut(&Ty, AssocItemId) -> ControlFlow<()>,\n+    mut callback: &mut dyn FnMut(&Canonical<Ty>, AssocItemId) -> ControlFlow<()>,\n ) -> ControlFlow<()> {\n     iterate_method_candidates_by_receiver(\n         &deref_chain[0],\n@@ -580,7 +580,7 @@ fn iterate_method_candidates_by_receiver(\n     traits_in_scope: &FxHashSet<TraitId>,\n     visible_from_module: Option<ModuleId>,\n     name: Option<&Name>,\n-    mut callback: &mut dyn FnMut(&Ty, AssocItemId) -> ControlFlow<()>,\n+    mut callback: &mut dyn FnMut(&Canonical<Ty>, AssocItemId) -> ControlFlow<()>,\n ) -> ControlFlow<()> {\n     // We're looking for methods with *receiver* type receiver_ty. These could\n     // be found in any of the derefs of receiver_ty, so we have to go through\n@@ -622,7 +622,7 @@ fn iterate_method_candidates_for_self_ty(\n     traits_in_scope: &FxHashSet<TraitId>,\n     visible_from_module: Option<ModuleId>,\n     name: Option<&Name>,\n-    mut callback: &mut dyn FnMut(&Ty, AssocItemId) -> ControlFlow<()>,\n+    mut callback: &mut dyn FnMut(&Canonical<Ty>, AssocItemId) -> ControlFlow<()>,\n ) -> ControlFlow<()> {\n     iterate_inherent_methods(\n         self_ty,\n@@ -645,7 +645,7 @@ fn iterate_trait_method_candidates(\n     traits_in_scope: &FxHashSet<TraitId>,\n     name: Option<&Name>,\n     receiver_ty: Option<&Canonical<Ty>>,\n-    callback: &mut dyn FnMut(&Ty, AssocItemId) -> ControlFlow<()>,\n+    callback: &mut dyn FnMut(&Canonical<Ty>, AssocItemId) -> ControlFlow<()>,\n ) -> ControlFlow<()> {\n     let receiver_is_array = matches!(self_ty.value.kind(&Interner), chalk_ir::TyKind::Array(..));\n     // if ty is `dyn Trait`, the trait doesn't need to be in scope\n@@ -697,7 +697,7 @@ fn iterate_trait_method_candidates(\n             }\n             known_implemented = true;\n             // FIXME: we shouldn't be ignoring the binders here\n-            callback(&self_ty.value, *item)?\n+            callback(&self_ty, *item)?\n         }\n     }\n     ControlFlow::Continue(())\n@@ -738,7 +738,7 @@ fn iterate_inherent_methods(\n     receiver_ty: Option<&Canonical<Ty>>,\n     krate: CrateId,\n     visible_from_module: Option<ModuleId>,\n-    callback: &mut dyn FnMut(&Ty, AssocItemId) -> ControlFlow<()>,\n+    callback: &mut dyn FnMut(&Canonical<Ty>, AssocItemId) -> ControlFlow<()>,\n ) -> ControlFlow<()> {\n     let def_crates = match def_crates(db, &self_ty.value, krate) {\n         Some(k) => k,\n@@ -773,7 +773,7 @@ fn iterate_inherent_methods(\n                     cov_mark::hit!(impl_self_type_match_without_receiver);\n                     continue;\n                 }\n-                let receiver_ty = receiver_ty.map(|x| &x.value).unwrap_or(&self_ty.value);\n+                let receiver_ty = receiver_ty.unwrap_or(&self_ty);\n                 callback(receiver_ty, item)?;\n             }\n         }"}, {"sha": "618499fdc191ccc9b57da0783c57c9c34fd58da8", "filename": "crates/hir_ty/src/tests/regression.rs", "status": "modified", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/a2d9f7d7bb8710ce45c8f0f803a88f03ae5ba29b/crates%2Fhir_ty%2Fsrc%2Ftests%2Fregression.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2d9f7d7bb8710ce45c8f0f803a88f03ae5ba29b/crates%2Fhir_ty%2Fsrc%2Ftests%2Fregression.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Ftests%2Fregression.rs?ref=a2d9f7d7bb8710ce45c8f0f803a88f03ae5ba29b", "patch": "@@ -1145,3 +1145,35 @@ impl<'a, T, DB: TypeMetadata> Output<'a, T, DB> {\n         \"#,\n     );\n }\n+\n+#[test]\n+fn bitslice_panic() {\n+    check_no_mismatches(\n+        r#\"\n+//- minicore: option, deref\n+\n+pub trait BitView {\n+    type Store;\n+}\n+\n+pub struct Lsb0;\n+\n+pub struct BitArray<V: BitView> { }\n+\n+pub struct BitSlice<T> { }\n+\n+impl<V: BitView> core::ops::Deref for BitArray<V> {\n+    type Target = BitSlice<V::Store>;\n+}\n+\n+impl<T> BitSlice<T> {\n+    pub fn split_first(&self) -> Option<(T, &Self)> { loop {} }\n+}\n+\n+fn multiexp_inner() {\n+    let exp: &BitArray<Foo>;\n+    exp.split_first();\n+}\n+        \"#,\n+    );\n+}"}]}