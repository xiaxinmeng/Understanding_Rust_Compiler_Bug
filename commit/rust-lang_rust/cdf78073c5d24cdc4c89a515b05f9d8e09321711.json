{"sha": "cdf78073c5d24cdc4c89a515b05f9d8e09321711", "node_id": "C_kwDOAAsO6NoAKGNkZjc4MDczYzVkMjRjZGM0Yzg5YTUxNWIwNWY5ZDhlMDkzMjE3MTE", "commit": {"author": {"name": "Michael Goulet", "email": "michael@errs.io", "date": "2022-09-02T21:02:59Z"}, "committer": {"name": "Michael Goulet", "email": "michael@errs.io", "date": "2022-09-09T01:31:46Z"}, "message": "Deeply check that method signatures match, and allow for nested RPITITs", "tree": {"sha": "5615fba0e7b4a26d4bef7ad5d72e1f692c2b1b84", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5615fba0e7b4a26d4bef7ad5d72e1f692c2b1b84"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/cdf78073c5d24cdc4c89a515b05f9d8e09321711", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/cdf78073c5d24cdc4c89a515b05f9d8e09321711", "html_url": "https://github.com/rust-lang/rust/commit/cdf78073c5d24cdc4c89a515b05f9d8e09321711", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/cdf78073c5d24cdc4c89a515b05f9d8e09321711/comments", "author": {"login": "compiler-errors", "id": 3674314, "node_id": "MDQ6VXNlcjM2NzQzMTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/3674314?v=4", "gravatar_id": "", "url": "https://api.github.com/users/compiler-errors", "html_url": "https://github.com/compiler-errors", "followers_url": "https://api.github.com/users/compiler-errors/followers", "following_url": "https://api.github.com/users/compiler-errors/following{/other_user}", "gists_url": "https://api.github.com/users/compiler-errors/gists{/gist_id}", "starred_url": "https://api.github.com/users/compiler-errors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/compiler-errors/subscriptions", "organizations_url": "https://api.github.com/users/compiler-errors/orgs", "repos_url": "https://api.github.com/users/compiler-errors/repos", "events_url": "https://api.github.com/users/compiler-errors/events{/privacy}", "received_events_url": "https://api.github.com/users/compiler-errors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "compiler-errors", "id": 3674314, "node_id": "MDQ6VXNlcjM2NzQzMTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/3674314?v=4", "gravatar_id": "", "url": "https://api.github.com/users/compiler-errors", "html_url": "https://github.com/compiler-errors", "followers_url": "https://api.github.com/users/compiler-errors/followers", "following_url": "https://api.github.com/users/compiler-errors/following{/other_user}", "gists_url": "https://api.github.com/users/compiler-errors/gists{/gist_id}", "starred_url": "https://api.github.com/users/compiler-errors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/compiler-errors/subscriptions", "organizations_url": "https://api.github.com/users/compiler-errors/orgs", "repos_url": "https://api.github.com/users/compiler-errors/repos", "events_url": "https://api.github.com/users/compiler-errors/events{/privacy}", "received_events_url": "https://api.github.com/users/compiler-errors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1f03edeabe7a2ba1eed35cd7beb93c1bc0364bc5", "url": "https://api.github.com/repos/rust-lang/rust/commits/1f03edeabe7a2ba1eed35cd7beb93c1bc0364bc5", "html_url": "https://github.com/rust-lang/rust/commit/1f03edeabe7a2ba1eed35cd7beb93c1bc0364bc5"}], "stats": {"total": 283, "additions": 231, "deletions": 52}, "files": [{"sha": "eecf01c92fbd53c11e9c736a38061776d05c56ad", "filename": "compiler/rustc_ast_lowering/src/lib.rs", "status": "modified", "additions": 2, "deletions": 7, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/cdf78073c5d24cdc4c89a515b05f9d8e09321711/compiler%2Frustc_ast_lowering%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cdf78073c5d24cdc4c89a515b05f9d8e09321711/compiler%2Frustc_ast_lowering%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_lowering%2Fsrc%2Flib.rs?ref=cdf78073c5d24cdc4c89a515b05f9d8e09321711", "patch": "@@ -1358,10 +1358,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n                     }\n                     ImplTraitContext::InTrait => {\n                         self.lower_impl_trait_in_trait(span, def_node_id, |lctx| {\n-                            lctx.lower_param_bounds(\n-                                bounds,\n-                                ImplTraitContext::Disallowed(ImplTraitPosition::Trait),\n-                            )\n+                            lctx.lower_param_bounds(bounds, ImplTraitContext::InTrait)\n                         })\n                     }\n                     ImplTraitContext::Universal => {\n@@ -1559,8 +1556,6 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n     ) -> hir::TyKind<'hir> {\n         let opaque_ty_def_id = self.local_def_id(opaque_ty_node_id);\n         self.with_hir_id_owner(opaque_ty_node_id, |lctx| {\n-            // FIXME(RPITIT): This should be a more descriptive ImplTraitPosition, i.e. nested RPITIT\n-            // FIXME(RPITIT): We _also_ should support this eventually\n             let hir_bounds = lower_bounds(lctx);\n             let rpitit_placeholder = hir::ImplTraitPlaceholder { bounds: hir_bounds };\n             let rpitit_item = hir::Item {\n@@ -2073,7 +2068,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n             let bound = lctx.lower_async_fn_output_type_to_future_bound(\n                 output,\n                 output.span(),\n-                ImplTraitContext::Disallowed(ImplTraitPosition::TraitReturn),\n+                ImplTraitContext::InTrait,\n             );\n             arena_vec![lctx; bound]\n         });"}, {"sha": "9b1fedd0b533c404e0c51802426ea77f930ecddd", "filename": "compiler/rustc_middle/src/arena.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cdf78073c5d24cdc4c89a515b05f9d8e09321711/compiler%2Frustc_middle%2Fsrc%2Farena.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cdf78073c5d24cdc4c89a515b05f9d8e09321711/compiler%2Frustc_middle%2Fsrc%2Farena.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Farena.rs?ref=cdf78073c5d24cdc4c89a515b05f9d8e09321711", "patch": "@@ -101,6 +101,8 @@ macro_rules! arena_types {\n             [decode] impl_source: rustc_middle::traits::ImplSource<'tcx, ()>,\n \n             [] dep_kind: rustc_middle::dep_graph::DepKindStruct<'tcx>,\n+\n+            [] trait_impl_trait_tys: rustc_data_structures::fx::FxHashMap<rustc_hir::def_id::DefId, rustc_middle::ty::Ty<'tcx>>,\n         ]);\n     )\n }"}, {"sha": "adf479c423604afe7b456af3055c30e21d4d75f6", "filename": "compiler/rustc_middle/src/query/mod.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/cdf78073c5d24cdc4c89a515b05f9d8e09321711/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cdf78073c5d24cdc4c89a515b05f9d8e09321711/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs?ref=cdf78073c5d24cdc4c89a515b05f9d8e09321711", "patch": "@@ -161,6 +161,13 @@ rustc_queries! {\n         separate_provide_extern\n     }\n \n+    query compare_predicates_and_trait_impl_trait_tys(key: DefId)\n+        -> Result<&'tcx FxHashMap<DefId, Ty<'tcx>>, ErrorGuaranteed>\n+    {\n+        desc { \"better description please\" }\n+        separate_provide_extern\n+    }\n+\n     query analysis(key: ()) -> Result<(), ErrorGuaranteed> {\n         eval_always\n         desc { \"running analysis passes on this crate\" }"}, {"sha": "df72260597f9f5a5c63309a6a7268444098071b2", "filename": "compiler/rustc_middle/src/ty/mod.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/cdf78073c5d24cdc4c89a515b05f9d8e09321711/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cdf78073c5d24cdc4c89a515b05f9d8e09321711/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs?ref=cdf78073c5d24cdc4c89a515b05f9d8e09321711", "patch": "@@ -2484,6 +2484,14 @@ impl<'tcx> TyCtxt<'tcx> {\n     pub fn is_const_default_method(self, def_id: DefId) -> bool {\n         matches!(self.trait_of_item(def_id), Some(trait_id) if self.has_attr(trait_id, sym::const_trait))\n     }\n+\n+    pub fn impl_trait_in_trait_parent(self, mut def_id: DefId) -> DefId {\n+        while let def_kind = self.def_kind(def_id) && def_kind != DefKind::AssocFn {\n+            debug_assert_eq!(def_kind, DefKind::ImplTraitPlaceholder);\n+            def_id = self.parent(def_id);\n+        }\n+        def_id\n+    }\n }\n \n /// Yields the parent function's `LocalDefId` if `def_id` is an `impl Trait` definition."}, {"sha": "0c73ae54bc31af83084703c146ea490d889b2a75", "filename": "compiler/rustc_middle/src/ty/util.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/cdf78073c5d24cdc4c89a515b05f9d8e09321711/compiler%2Frustc_middle%2Fsrc%2Fty%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cdf78073c5d24cdc4c89a515b05f9d8e09321711/compiler%2Frustc_middle%2Fsrc%2Fty%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Futil.rs?ref=cdf78073c5d24cdc4c89a515b05f9d8e09321711", "patch": "@@ -651,6 +651,13 @@ impl<'tcx> TyCtxt<'tcx> {\n         ty::EarlyBinder(self.type_of(def_id))\n     }\n \n+    pub fn bound_trait_impl_trait_tys(\n+        self,\n+        def_id: DefId,\n+    ) -> ty::EarlyBinder<Result<&'tcx FxHashMap<DefId, Ty<'tcx>>, ErrorGuaranteed>> {\n+        ty::EarlyBinder(self.compare_predicates_and_trait_impl_trait_tys(def_id))\n+    }\n+\n     pub fn bound_fn_sig(self, def_id: DefId) -> ty::EarlyBinder<ty::PolyFnSig<'tcx>> {\n         ty::EarlyBinder(self.fn_sig(def_id))\n     }"}, {"sha": "7253ab21b3a09973a00e0fcb378266770b086a91", "filename": "compiler/rustc_trait_selection/src/traits/project.rs", "status": "modified", "additions": 6, "deletions": 7, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/cdf78073c5d24cdc4c89a515b05f9d8e09321711/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fproject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cdf78073c5d24cdc4c89a515b05f9d8e09321711/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fproject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fproject.rs?ref=cdf78073c5d24cdc4c89a515b05f9d8e09321711", "patch": "@@ -1318,7 +1318,7 @@ fn assemble_candidate_for_impl_trait_in_trait<'cx, 'tcx>(\n ) {\n     let tcx = selcx.tcx();\n     if tcx.def_kind(obligation.predicate.item_def_id) == DefKind::ImplTraitPlaceholder {\n-        let trait_fn_def_id = tcx.parent(obligation.predicate.item_def_id);\n+        let trait_fn_def_id = tcx.impl_trait_in_trait_parent(obligation.predicate.item_def_id);\n         let trait_def_id = tcx.parent(trait_fn_def_id);\n         let trait_substs =\n             obligation.predicate.substs.truncate_to(tcx, tcx.generics_of(trait_def_id));\n@@ -2176,11 +2176,6 @@ fn confirm_impl_trait_in_trait_candidate<'tcx>(\n     let impl_fn_def_id = leaf_def.item.def_id;\n     let impl_fn_substs = obligation.predicate.substs.rebase_onto(tcx, trait_fn_def_id, data.substs);\n \n-    let sig = tcx\n-        .bound_fn_sig(impl_fn_def_id)\n-        .map_bound(|fn_sig| tcx.liberate_late_bound_regions(impl_fn_def_id, fn_sig))\n-        .subst(tcx, impl_fn_substs);\n-\n     let cause = ObligationCause::new(\n         obligation.cause.span,\n         obligation.cause.body_id,\n@@ -2217,7 +2212,11 @@ fn confirm_impl_trait_in_trait_candidate<'tcx>(\n         selcx,\n         obligation.param_env,\n         cause.clone(),\n-        sig.output(),\n+        tcx.bound_trait_impl_trait_tys(impl_fn_def_id)\n+            .map_bound(|tys| {\n+                tys.map_or_else(|_| tcx.ty_error(), |tys| tys[&obligation.predicate.item_def_id])\n+            })\n+            .subst(tcx, impl_fn_substs),\n         &mut obligations,\n     );\n "}, {"sha": "da45469863e48cb31958f14dfae8d55c87e066ae", "filename": "compiler/rustc_typeck/src/check/compare_method.rs", "status": "modified", "additions": 110, "deletions": 37, "changes": 147, "blob_url": "https://github.com/rust-lang/rust/blob/cdf78073c5d24cdc4c89a515b05f9d8e09321711/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcompare_method.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cdf78073c5d24cdc4c89a515b05f9d8e09321711/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcompare_method.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcompare_method.rs?ref=cdf78073c5d24cdc4c89a515b05f9d8e09321711", "patch": "@@ -1,18 +1,22 @@\n use super::potentially_plural_count;\n use crate::errors::LifetimesOrBoundsMismatchOnTrait;\n-use rustc_data_structures::fx::FxHashSet;\n+use hir::def_id::DefId;\n+use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n use rustc_errors::{pluralize, struct_span_err, Applicability, DiagnosticId, ErrorGuaranteed};\n use rustc_hir as hir;\n use rustc_hir::def::{DefKind, Res};\n use rustc_hir::intravisit;\n use rustc_hir::{GenericParamKind, ImplItemKind, TraitItemKind};\n use rustc_infer::infer::outlives::env::OutlivesEnvironment;\n+use rustc_infer::infer::type_variable::{TypeVariableOrigin, TypeVariableOriginKind};\n use rustc_infer::infer::{self, TyCtxtInferExt};\n use rustc_infer::traits::util;\n use rustc_middle::ty::error::{ExpectedFound, TypeError};\n use rustc_middle::ty::subst::{InternalSubsts, Subst};\n use rustc_middle::ty::util::ExplicitSelf;\n-use rustc_middle::ty::{self, DefIdTree};\n+use rustc_middle::ty::{\n+    self, DefIdTree, Ty, TypeFoldable, TypeFolder, TypeSuperFoldable, TypeVisitable,\n+};\n use rustc_middle::ty::{GenericParamDefKind, ToPredicate, TyCtxt};\n use rustc_span::Span;\n use rustc_trait_selection::traits::error_reporting::InferCtxtExt;\n@@ -64,10 +68,7 @@ pub(crate) fn compare_impl_method<'tcx>(\n         return;\n     }\n \n-    if let Err(_) = compare_predicate_entailment(tcx, impl_m, impl_m_span, trait_m, impl_trait_ref)\n-    {\n-        return;\n-    }\n+    tcx.ensure().compare_predicates_and_trait_impl_trait_tys(impl_m.def_id);\n }\n \n /// This function is best explained by example. Consider a trait:\n@@ -136,13 +137,15 @@ pub(crate) fn compare_impl_method<'tcx>(\n ///\n /// Finally we register each of these predicates as an obligation and check that\n /// they hold.\n-fn compare_predicate_entailment<'tcx>(\n+pub(super) fn compare_predicates_and_trait_impl_trait_tys<'tcx>(\n     tcx: TyCtxt<'tcx>,\n-    impl_m: &ty::AssocItem,\n-    impl_m_span: Span,\n-    trait_m: &ty::AssocItem,\n-    impl_trait_ref: ty::TraitRef<'tcx>,\n-) -> Result<(), ErrorGuaranteed> {\n+    def_id: DefId,\n+) -> Result<&'tcx FxHashMap<DefId, Ty<'tcx>>, ErrorGuaranteed> {\n+    let impl_m = tcx.opt_associated_item(def_id).unwrap();\n+    let impl_m_span = tcx.def_span(def_id);\n+    let trait_m = tcx.opt_associated_item(impl_m.trait_item_def_id.unwrap()).unwrap();\n+    let impl_trait_ref = tcx.impl_trait_ref(impl_m.impl_container(tcx).unwrap()).unwrap();\n+\n     let trait_to_impl_substs = impl_trait_ref.substs;\n \n     // This node-id should be used for the `body_id` field on each\n@@ -161,6 +164,7 @@ fn compare_predicate_entailment<'tcx>(\n             kind: impl_m.kind,\n         },\n     );\n+    let return_span = tcx.hir().fn_decl_by_hir_id(impl_m_hir_id).unwrap().output.span();\n \n     // Create mapping from impl to placeholder.\n     let impl_to_placeholder_substs = InternalSubsts::identity_for_item(tcx, impl_m.def_id);\n@@ -266,6 +270,13 @@ fn compare_predicate_entailment<'tcx>(\n \n         let trait_sig = tcx.bound_fn_sig(trait_m.def_id).subst(tcx, trait_to_placeholder_substs);\n         let trait_sig = tcx.liberate_late_bound_regions(impl_m.def_id, trait_sig);\n+        let mut collector =\n+            ImplTraitInTraitCollector::new(&ocx, return_span, param_env, impl_m_hir_id);\n+        // FIXME(RPITIT): This should only be needed on the output type, but\n+        // RPITIT placeholders shouldn't show up anywhere except for there,\n+        // so I think this is fine.\n+        let trait_sig = trait_sig.fold_with(&mut collector);\n+\n         // Next, add all inputs and output as well-formed tys. Importantly,\n         // we have to do this before normalization, since the normalized ty may\n         // not contain the input parameters. See issue #87748.\n@@ -391,30 +402,6 @@ fn compare_predicate_entailment<'tcx>(\n             return Err(diag.emit());\n         }\n \n-        // Check that an impl's fn return satisfies the bounds of the\n-        // FIXME(RPITIT): Generalize this to nested impl traits\n-        if let ty::Projection(proj) = tcx.fn_sig(trait_m.def_id).skip_binder().output().kind()\n-            && tcx.def_kind(proj.item_def_id) == DefKind::ImplTraitPlaceholder\n-        {\n-            let return_span = tcx.hir().fn_decl_by_hir_id(impl_m_hir_id).unwrap().output.span();\n-\n-            for (predicate, span) in tcx\n-                .bound_explicit_item_bounds(proj.item_def_id)\n-                .transpose_iter()\n-                .map(|pred| pred.map_bound(|pred| *pred).subst(tcx, trait_to_placeholder_substs))\n-            {\n-                ocx.register_obligation(traits::Obligation::new(\n-                    traits::ObligationCause::new(\n-                        return_span,\n-                        impl_m_hir_id,\n-                        ObligationCauseCode::BindingObligation(proj.item_def_id, span),\n-                    ),\n-                    param_env,\n-                    predicate,\n-                ));\n-            }\n-        }\n-\n         // Check that all obligations are satisfied by the implementation's\n         // version.\n         let errors = ocx.select_all_or_error();\n@@ -435,10 +422,96 @@ fn compare_predicate_entailment<'tcx>(\n             &outlives_environment,\n         );\n \n-        Ok(())\n+        let mut collected_tys = FxHashMap::default();\n+        for (def_id, ty) in collector.types {\n+            match infcx.fully_resolve(ty) {\n+                Ok(ty) => {\n+                    collected_tys.insert(def_id, ty);\n+                }\n+                Err(err) => {\n+                    tcx.sess.delay_span_bug(\n+                        return_span,\n+                        format!(\"could not fully resolve: {ty} => {err:?}\"),\n+                    );\n+                    collected_tys.insert(def_id, tcx.ty_error());\n+                }\n+            }\n+        }\n+\n+        Ok(&*tcx.arena.alloc(collected_tys))\n     })\n }\n \n+struct ImplTraitInTraitCollector<'a, 'tcx> {\n+    ocx: &'a ObligationCtxt<'a, 'tcx>,\n+    types: FxHashMap<DefId, Ty<'tcx>>,\n+    span: Span,\n+    param_env: ty::ParamEnv<'tcx>,\n+    body_id: hir::HirId,\n+}\n+\n+impl<'a, 'tcx> ImplTraitInTraitCollector<'a, 'tcx> {\n+    fn new(\n+        ocx: &'a ObligationCtxt<'a, 'tcx>,\n+        span: Span,\n+        param_env: ty::ParamEnv<'tcx>,\n+        body_id: hir::HirId,\n+    ) -> Self {\n+        ImplTraitInTraitCollector { ocx, types: FxHashMap::default(), span, param_env, body_id }\n+    }\n+}\n+\n+impl<'tcx> TypeFolder<'tcx> for ImplTraitInTraitCollector<'_, 'tcx> {\n+    fn tcx<'a>(&'a self) -> TyCtxt<'tcx> {\n+        self.ocx.infcx.tcx\n+    }\n+\n+    fn fold_ty(&mut self, ty: Ty<'tcx>) -> Ty<'tcx> {\n+        if let ty::Projection(proj) = ty.kind()\n+            && self.tcx().def_kind(proj.item_def_id) == DefKind::ImplTraitPlaceholder\n+        {\n+            if let Some(ty) = self.types.get(&proj.item_def_id) {\n+                return *ty;\n+            }\n+            //FIXME(RPITIT): Deny nested RPITIT in substs too\n+            if proj.substs.has_escaping_bound_vars() {\n+                bug!(\"FIXME(RPITIT): error here\");\n+            }\n+            // Replace with infer var\n+            let infer_ty = self.ocx.infcx.next_ty_var(TypeVariableOrigin {\n+                span: self.span,\n+                kind: TypeVariableOriginKind::MiscVariable,\n+            });\n+            self.types.insert(proj.item_def_id, infer_ty);\n+            // Recurse into bounds\n+            for pred in self.tcx().bound_explicit_item_bounds(proj.item_def_id).transpose_iter() {\n+                let pred_span = pred.0.1;\n+\n+                let pred = pred.map_bound(|(pred, _)| *pred).subst(self.tcx(), proj.substs);\n+                let pred = pred.fold_with(self);\n+                let pred = self.ocx.normalize(\n+                    ObligationCause::misc(self.span, self.body_id),\n+                    self.param_env,\n+                    pred,\n+                );\n+\n+                self.ocx.register_obligation(traits::Obligation::new(\n+                    ObligationCause::new(\n+                        self.span,\n+                        self.body_id,\n+                        ObligationCauseCode::BindingObligation(proj.item_def_id, pred_span),\n+                    ),\n+                    self.param_env,\n+                    pred,\n+                ));\n+            }\n+            infer_ty\n+        } else {\n+            ty.super_fold_with(self)\n+        }\n+    }\n+}\n+\n fn check_region_bounds_on_impl_item<'tcx>(\n     tcx: TyCtxt<'tcx>,\n     impl_m: &ty::AssocItem,"}, {"sha": "8811b38fc555afb364efbaa12868cebbb67c9adf", "filename": "compiler/rustc_typeck/src/check/mod.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cdf78073c5d24cdc4c89a515b05f9d8e09321711/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cdf78073c5d24cdc4c89a515b05f9d8e09321711/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmod.rs?ref=cdf78073c5d24cdc4c89a515b05f9d8e09321711", "patch": "@@ -132,6 +132,7 @@ use crate::require_c_abi_if_c_variadic;\n use crate::util::common::indenter;\n \n use self::coercion::DynamicCoerceMany;\n+use self::compare_method::compare_predicates_and_trait_impl_trait_tys;\n use self::region::region_scope_tree;\n pub use self::Expectation::*;\n \n@@ -249,6 +250,7 @@ pub fn provide(providers: &mut Providers) {\n         used_trait_imports,\n         check_mod_item_types,\n         region_scope_tree,\n+        compare_predicates_and_trait_impl_trait_tys,\n         ..*providers\n     };\n }"}, {"sha": "e5e82a4ff6b01d3788af7d67e248c0a0a412843f", "filename": "compiler/rustc_typeck/src/collect.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/cdf78073c5d24cdc4c89a515b05f9d8e09321711/compiler%2Frustc_typeck%2Fsrc%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cdf78073c5d24cdc4c89a515b05f9d8e09321711/compiler%2Frustc_typeck%2Fsrc%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcollect.rs?ref=cdf78073c5d24cdc4c89a515b05f9d8e09321711", "patch": "@@ -1602,7 +1602,10 @@ fn generics_of(tcx: TyCtxt<'_>, def_id: DefId) -> ty::Generics {\n             }\n             ItemKind::ImplTraitPlaceholder(_) => {\n                 let parent_id = tcx.hir().get_parent_item(hir_id).to_def_id();\n-                assert_eq!(tcx.def_kind(parent_id), DefKind::AssocFn);\n+                assert!(matches!(\n+                    tcx.def_kind(parent_id),\n+                    DefKind::AssocFn | DefKind::ImplTraitPlaceholder\n+                ));\n                 Some(parent_id)\n             }\n             _ => None,"}, {"sha": "772da845ee1f79fb79bc063acbd6cbadf47f72fc", "filename": "src/test/ui/impl-trait/in-trait/deep-match-works.rs", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/cdf78073c5d24cdc4c89a515b05f9d8e09321711/src%2Ftest%2Fui%2Fimpl-trait%2Fin-trait%2Fdeep-match-works.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cdf78073c5d24cdc4c89a515b05f9d8e09321711/src%2Ftest%2Fui%2Fimpl-trait%2Fin-trait%2Fdeep-match-works.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fin-trait%2Fdeep-match-works.rs?ref=cdf78073c5d24cdc4c89a515b05f9d8e09321711", "patch": "@@ -0,0 +1,16 @@\n+// check-pass\n+\n+#![feature(return_position_impl_trait_in_trait)]\n+#![allow(incomplete_features)]\n+\n+struct Wrapper<T>(T);\n+\n+trait Foo {\n+    fn bar() -> Wrapper<impl Sized>;\n+}\n+\n+impl Foo for () {\n+    fn bar() -> Wrapper<i32> { Wrapper(0) }\n+}\n+\n+fn main() {}"}, {"sha": "5a220bc3f198a229b02c8961353b721185f9f135", "filename": "src/test/ui/impl-trait/in-trait/deep-match.rs", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/cdf78073c5d24cdc4c89a515b05f9d8e09321711/src%2Ftest%2Fui%2Fimpl-trait%2Fin-trait%2Fdeep-match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cdf78073c5d24cdc4c89a515b05f9d8e09321711/src%2Ftest%2Fui%2Fimpl-trait%2Fin-trait%2Fdeep-match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fin-trait%2Fdeep-match.rs?ref=cdf78073c5d24cdc4c89a515b05f9d8e09321711", "patch": "@@ -0,0 +1,15 @@\n+#![feature(return_position_impl_trait_in_trait)]\n+#![allow(incomplete_features)]\n+\n+struct Wrapper<T>(T);\n+\n+trait Foo {\n+    fn bar() -> Wrapper<impl Sized>;\n+}\n+\n+impl Foo for () {\n+    fn bar() -> i32 { 0 }\n+    //~^ ERROR method `bar` has an incompatible type for trait\n+}\n+\n+fn main() {}"}, {"sha": "af449869cb356eb2611ea2953a1108f8cdeaf22a", "filename": "src/test/ui/impl-trait/in-trait/deep-match.stderr", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/cdf78073c5d24cdc4c89a515b05f9d8e09321711/src%2Ftest%2Fui%2Fimpl-trait%2Fin-trait%2Fdeep-match.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/cdf78073c5d24cdc4c89a515b05f9d8e09321711/src%2Ftest%2Fui%2Fimpl-trait%2Fin-trait%2Fdeep-match.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fin-trait%2Fdeep-match.stderr?ref=cdf78073c5d24cdc4c89a515b05f9d8e09321711", "patch": "@@ -0,0 +1,20 @@\n+error[E0053]: method `bar` has an incompatible type for trait\n+  --> $DIR/deep-match.rs:11:17\n+   |\n+LL |     fn bar() -> i32 { 0 }\n+   |                 ^^^\n+   |                 |\n+   |                 expected struct `Wrapper`, found `i32`\n+   |                 help: change the output type to match the trait: `Wrapper<_>`\n+   |\n+note: type in trait\n+  --> $DIR/deep-match.rs:7:17\n+   |\n+LL |     fn bar() -> Wrapper<impl Sized>;\n+   |                 ^^^^^^^^^^^^^^^^^^^\n+   = note: expected fn pointer `fn() -> Wrapper<_>`\n+              found fn pointer `fn() -> i32`\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0053`."}, {"sha": "65285e3a3ccaf815e562754de0b0461d959ba95b", "filename": "src/test/ui/impl-trait/in-trait/nested-rpitit.rs", "status": "added", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/cdf78073c5d24cdc4c89a515b05f9d8e09321711/src%2Ftest%2Fui%2Fimpl-trait%2Fin-trait%2Fnested-rpitit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cdf78073c5d24cdc4c89a515b05f9d8e09321711/src%2Ftest%2Fui%2Fimpl-trait%2Fin-trait%2Fnested-rpitit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fin-trait%2Fnested-rpitit.rs?ref=cdf78073c5d24cdc4c89a515b05f9d8e09321711", "patch": "@@ -0,0 +1,32 @@\n+// check-pass\n+\n+#![feature(return_position_impl_trait_in_trait)]\n+#![allow(incomplete_features)]\n+\n+use std::fmt::Display;\n+use std::ops::Deref;\n+\n+trait Foo {\n+    fn bar(self) -> impl Deref<Target = impl Display + ?Sized>;\n+}\n+\n+struct A;\n+\n+impl Foo for A {\n+    fn bar(self) -> &'static str {\n+        \"Hello, world\"\n+    }\n+}\n+\n+struct B;\n+\n+impl Foo for B {\n+    fn bar(self) -> Box<i32> {\n+        Box::new(42)\n+    }\n+}\n+\n+fn main() {\n+    println!(\"Message for you: {:?}\", &*A.bar());\n+    println!(\"Another for you: {:?}\", &*B.bar());\n+}"}]}