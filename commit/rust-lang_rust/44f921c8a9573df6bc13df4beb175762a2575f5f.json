{"sha": "44f921c8a9573df6bc13df4beb175762a2575f5f", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQ0ZjkyMWM4YTk1NzNkZjZiYzEzZGY0YmViMTc1NzYyYTI1NzVmNWY=", "commit": {"author": {"name": "Marijn Haverbeke", "email": "marijnh@gmail.com", "date": "2011-12-22T13:52:30Z"}, "committer": {"name": "Marijn Haverbeke", "email": "marijnh@gmail.com", "date": "2011-12-22T14:05:38Z"}, "message": "Do not use == and != to compare ty::t values\n\nIssue #828", "tree": {"sha": "3c42790c9836c9d23094f215862d32f9c50bf738", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3c42790c9836c9d23094f215862d32f9c50bf738"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/44f921c8a9573df6bc13df4beb175762a2575f5f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/44f921c8a9573df6bc13df4beb175762a2575f5f", "html_url": "https://github.com/rust-lang/rust/commit/44f921c8a9573df6bc13df4beb175762a2575f5f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/44f921c8a9573df6bc13df4beb175762a2575f5f/comments", "author": {"login": "marijnh", "id": 144427, "node_id": "MDQ6VXNlcjE0NDQyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/144427?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marijnh", "html_url": "https://github.com/marijnh", "followers_url": "https://api.github.com/users/marijnh/followers", "following_url": "https://api.github.com/users/marijnh/following{/other_user}", "gists_url": "https://api.github.com/users/marijnh/gists{/gist_id}", "starred_url": "https://api.github.com/users/marijnh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marijnh/subscriptions", "organizations_url": "https://api.github.com/users/marijnh/orgs", "repos_url": "https://api.github.com/users/marijnh/repos", "events_url": "https://api.github.com/users/marijnh/events{/privacy}", "received_events_url": "https://api.github.com/users/marijnh/received_events", "type": "User", "site_admin": false}, "committer": {"login": "marijnh", "id": 144427, "node_id": "MDQ6VXNlcjE0NDQyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/144427?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marijnh", "html_url": "https://github.com/marijnh", "followers_url": "https://api.github.com/users/marijnh/followers", "following_url": "https://api.github.com/users/marijnh/following{/other_user}", "gists_url": "https://api.github.com/users/marijnh/gists{/gist_id}", "starred_url": "https://api.github.com/users/marijnh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marijnh/subscriptions", "organizations_url": "https://api.github.com/users/marijnh/orgs", "repos_url": "https://api.github.com/users/marijnh/repos", "events_url": "https://api.github.com/users/marijnh/events{/privacy}", "received_events_url": "https://api.github.com/users/marijnh/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3ee630bbee1e35933b6296e4749fcdd882a81f90", "url": "https://api.github.com/repos/rust-lang/rust/commits/3ee630bbee1e35933b6296e4749fcdd882a81f90", "html_url": "https://github.com/rust-lang/rust/commit/3ee630bbee1e35933b6296e4749fcdd882a81f90"}], "stats": {"total": 72, "additions": 45, "deletions": 27}, "files": [{"sha": "070123439adc9778c3959dc634b7b8cdeecc292d", "filename": "src/comp/middle/ty.rs", "status": "modified", "additions": 39, "deletions": 22, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/44f921c8a9573df6bc13df4beb175762a2575f5f/src%2Fcomp%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44f921c8a9573df6bc13df4beb175762a2575f5f/src%2Fcomp%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fty.rs?ref=44f921c8a9573df6bc13df4beb175762a2575f5f", "patch": "@@ -136,6 +136,7 @@ export ty_uint;\n export ty_uniq;\n export ty_var;\n export ty_named;\n+export same_type, same_method;\n export ty_var_id;\n export ty_param_substs_opt_and_ty_to_monotype;\n export ty_fn_args;\n@@ -1683,7 +1684,7 @@ mod unify {\n     type var_bindings =\n         {sets: ufind::ufind, types: smallintmap::smallintmap<t>};\n \n-    type ctxt = {vb: @var_bindings, tcx: ty_ctxt};\n+    type ctxt = {vb: option::t<@var_bindings>, tcx: ty_ctxt};\n \n     fn mk_var_bindings() -> @var_bindings {\n         ret @{sets: ufind::make(), types: smallintmap::mk::<t>()};\n@@ -1692,31 +1693,32 @@ mod unify {\n     // Unifies two sets.\n     fn union(cx: @ctxt, set_a: uint, set_b: uint,\n              variance: variance) -> union_result {\n-        ufind::grow(cx.vb.sets, float::max(set_a, set_b) + 1u);\n-        let root_a = ufind::find(cx.vb.sets, set_a);\n-        let root_b = ufind::find(cx.vb.sets, set_b);\n+        let vb = option::get(cx.vb);\n+        ufind::grow(vb.sets, float::max(set_a, set_b) + 1u);\n+        let root_a = ufind::find(vb.sets, set_a);\n+        let root_b = ufind::find(vb.sets, set_b);\n \n         let replace_type =\n-            bind fn (cx: @ctxt, t: t, set_a: uint, set_b: uint) {\n-                     ufind::union(cx.vb.sets, set_a, set_b);\n-                     let root_c: uint = ufind::find(cx.vb.sets, set_a);\n-                     smallintmap::insert::<t>(cx.vb.types, root_c, t);\n+            bind fn (vb: @var_bindings, t: t, set_a: uint, set_b: uint) {\n+                     ufind::union(vb.sets, set_a, set_b);\n+                     let root_c: uint = ufind::find(vb.sets, set_a);\n+                     smallintmap::insert::<t>(vb.types, root_c, t);\n                  }(_, _, set_a, set_b);\n \n \n-        alt smallintmap::find(cx.vb.types, root_a) {\n+        alt smallintmap::find(vb.types, root_a) {\n           none. {\n-            alt smallintmap::find(cx.vb.types, root_b) {\n-              none. { ufind::union(cx.vb.sets, set_a, set_b); ret unres_ok; }\n-              some(t_b) { replace_type(cx, t_b); ret unres_ok; }\n+            alt smallintmap::find(vb.types, root_b) {\n+              none. { ufind::union(vb.sets, set_a, set_b); ret unres_ok; }\n+              some(t_b) { replace_type(vb, t_b); ret unres_ok; }\n             }\n           }\n           some(t_a) {\n-            alt smallintmap::find(cx.vb.types, root_b) {\n-              none. { replace_type(cx, t_a); ret unres_ok; }\n+            alt smallintmap::find(vb.types, root_b) {\n+              none. { replace_type(vb, t_a); ret unres_ok; }\n               some(t_b) {\n                 alt unify_step(cx, t_a, t_b, variance) {\n-                  ures_ok(t_c) { replace_type(cx, t_c); ret unres_ok; }\n+                  ures_ok(t_c) { replace_type(vb, t_c); ret unres_ok; }\n                   ures_err(terr) { ret unres_err(terr); }\n                 }\n               }\n@@ -1741,10 +1743,11 @@ mod unify {\n     fn record_var_binding(\n         cx: @ctxt, key: int, typ: t, variance: variance) -> result {\n \n-        ufind::grow(cx.vb.sets, (key as uint) + 1u);\n-        let root = ufind::find(cx.vb.sets, key as uint);\n+        let vb = option::get(cx.vb);\n+        ufind::grow(vb.sets, (key as uint) + 1u);\n+        let root = ufind::find(vb.sets, key as uint);\n         let result_type = typ;\n-        alt smallintmap::find::<t>(cx.vb.types, root) {\n+        alt smallintmap::find(vb.types, root) {\n           some(old_type) {\n             alt unify_step(cx, old_type, typ, variance) {\n               ures_ok(unified_type) { result_type = unified_type; }\n@@ -1753,7 +1756,7 @@ mod unify {\n           }\n           none. {/* fall through */ }\n         }\n-        smallintmap::insert::<t>(cx.vb.types, root, result_type);\n+        smallintmap::insert::<t>(vb.types, root, result_type);\n         ret ures_ok(typ);\n     }\n \n@@ -2090,6 +2093,7 @@ mod unify {\n           // If the RHS is a variable type, then just do the\n           // appropriate binding.\n           ty::ty_var(actual_id) {\n+            assert option::is_some(cx.vb);\n             let actual_n = actual_id as uint;\n             alt struct(cx.tcx, expected) {\n               ty::ty_var(expected_id) {\n@@ -2114,8 +2118,8 @@ mod unify {\n         }\n         alt struct(cx.tcx, expected) {\n           ty::ty_var(expected_id) {\n+            assert option::is_some(cx.vb);\n             // Add a binding. (`actual` can't actually be a var here.)\n-\n             alt record_var_binding_for_expected(\n                 cx, expected_id, actual,\n                 variance) {\n@@ -2431,8 +2435,8 @@ mod unify {\n           }\n         }\n     }\n-    fn unify(expected: t, actual: t, vb: @var_bindings, tcx: ty_ctxt) ->\n-       result {\n+    fn unify(expected: t, actual: t, vb: option::t<@var_bindings>,\n+             tcx: ty_ctxt) -> result {\n         let cx = @{vb: vb, tcx: tcx};\n         ret unify_step(cx, expected, actual, covariant);\n     }\n@@ -2505,6 +2509,19 @@ mod unify {\n     }\n }\n \n+fn same_type(cx: ctxt, a: t, b: t) -> bool {\n+    alt unify::unify(a, b, none, cx) {\n+      unify::ures_ok(_) { true }\n+      _ { false }\n+    }\n+}\n+fn same_method(cx: ctxt, a: method, b: method) -> bool {\n+    a.proto == b.proto && a.ident == b.ident &&\n+    vec::all2(a.inputs, b.inputs,\n+              {|a, b| a.mode == b.mode && same_type(cx, a.ty, b.ty) }) &&\n+    same_type(cx, a.output, b.output) && a.cf == b.cf\n+}\n+\n fn type_err_to_str(err: ty::type_err) -> str {\n     alt err {\n       terr_mismatch. { ret \"types differ\"; }"}, {"sha": "400411fa68ab11f451ec2ea0366a9ad9ee33df07", "filename": "src/comp/middle/typeck.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/44f921c8a9573df6bc13df4beb175762a2575f5f/src%2Fcomp%2Fmiddle%2Ftypeck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44f921c8a9573df6bc13df4beb175762a2575f5f/src%2Fcomp%2Fmiddle%2Ftypeck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftypeck.rs?ref=44f921c8a9573df6bc13df4beb175762a2575f5f", "patch": "@@ -791,7 +791,8 @@ mod collect {\n mod unify {\n     fn unify(fcx: @fn_ctxt, expected: ty::t, actual: ty::t) ->\n        ty::unify::result {\n-        ret ty::unify::unify(expected, actual, fcx.var_bindings, fcx.ccx.tcx);\n+        ret ty::unify::unify(expected, actual, some(fcx.var_bindings),\n+                             fcx.ccx.tcx);\n     }\n }\n \n@@ -1106,7 +1107,7 @@ fn gather_locals(ccx: @crate_ctxt,\n             alt ty_opt {\n               none. {/* nothing to do */ }\n               some(typ) {\n-                ty::unify::unify(ty::mk_var(tcx, var_id), typ, vb, tcx);\n+                ty::unify::unify(ty::mk_var(tcx, var_id), typ, some(vb), tcx);\n               }\n             }\n         };\n@@ -1198,8 +1199,8 @@ fn check_pat(fcx: @fn_ctxt, map: ast_util::pat_id_map, pat: @ast::pat,\n         check_expr_with(fcx, end, expected);\n         let b_ty = resolve_type_vars_if_possible(fcx, expr_ty(fcx.ccx.tcx,\n                                                               begin));\n-        if b_ty != resolve_type_vars_if_possible(fcx, expr_ty(fcx.ccx.tcx,\n-                                                              end)) {\n+        if !ty::same_type(fcx.ccx.tcx, b_ty, resolve_type_vars_if_possible(\n+            fcx, expr_ty(fcx.ccx.tcx, end))) {\n             fcx.ccx.tcx.sess.span_err(pat.span, \"mismatched types in range\");\n         } else if !ty::type_is_numeric(fcx.ccx.tcx, b_ty) {\n             fcx.ccx.tcx.sess.span_err(pat.span,\n@@ -2324,7 +2325,7 @@ fn check_expr_with_unifier(fcx: @fn_ctxt, expr: @ast::expr, unify: unifier,\n                         // We'd better be overriding with one of the same\n                         // type.  Check to make sure.\n                         let new_type = ty_of_method(ccx.tcx, m_check, om);\n-                        if new_type != m {\n+                        if !ty::same_method(ccx.tcx, new_type, m) {\n                             ccx.tcx.sess.span_fatal\n                                 (om.span, \"attempted to override method \"\n                                  + m.ident + \" with one of a different type\");"}]}