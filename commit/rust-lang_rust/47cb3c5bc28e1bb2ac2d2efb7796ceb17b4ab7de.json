{"sha": "47cb3c5bc28e1bb2ac2d2efb7796ceb17b4ab7de", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQ3Y2IzYzViYzI4ZTFiYjJhYzJkMmVmYjc3OTZjZWIxN2I0YWI3ZGU=", "commit": {"author": {"name": "Bastien Orivel", "email": "eijebong@bananium.fr", "date": "2017-08-10T22:16:18Z"}, "committer": {"name": "Bastien Orivel", "email": "eijebong@bananium.fr", "date": "2017-08-10T22:16:18Z"}, "message": "Fix some typos", "tree": {"sha": "d322ab0b4256ce1b79dc63e2fab5e70a774c93c6", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d322ab0b4256ce1b79dc63e2fab5e70a774c93c6"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/47cb3c5bc28e1bb2ac2d2efb7796ceb17b4ab7de", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/47cb3c5bc28e1bb2ac2d2efb7796ceb17b4ab7de", "html_url": "https://github.com/rust-lang/rust/commit/47cb3c5bc28e1bb2ac2d2efb7796ceb17b4ab7de", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/47cb3c5bc28e1bb2ac2d2efb7796ceb17b4ab7de/comments", "author": {"login": "Eijebong", "id": 3650385, "node_id": "MDQ6VXNlcjM2NTAzODU=", "avatar_url": "https://avatars.githubusercontent.com/u/3650385?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Eijebong", "html_url": "https://github.com/Eijebong", "followers_url": "https://api.github.com/users/Eijebong/followers", "following_url": "https://api.github.com/users/Eijebong/following{/other_user}", "gists_url": "https://api.github.com/users/Eijebong/gists{/gist_id}", "starred_url": "https://api.github.com/users/Eijebong/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Eijebong/subscriptions", "organizations_url": "https://api.github.com/users/Eijebong/orgs", "repos_url": "https://api.github.com/users/Eijebong/repos", "events_url": "https://api.github.com/users/Eijebong/events{/privacy}", "received_events_url": "https://api.github.com/users/Eijebong/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Eijebong", "id": 3650385, "node_id": "MDQ6VXNlcjM2NTAzODU=", "avatar_url": "https://avatars.githubusercontent.com/u/3650385?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Eijebong", "html_url": "https://github.com/Eijebong", "followers_url": "https://api.github.com/users/Eijebong/followers", "following_url": "https://api.github.com/users/Eijebong/following{/other_user}", "gists_url": "https://api.github.com/users/Eijebong/gists{/gist_id}", "starred_url": "https://api.github.com/users/Eijebong/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Eijebong/subscriptions", "organizations_url": "https://api.github.com/users/Eijebong/orgs", "repos_url": "https://api.github.com/users/Eijebong/repos", "events_url": "https://api.github.com/users/Eijebong/events{/privacy}", "received_events_url": "https://api.github.com/users/Eijebong/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2ac5f7d249e29ee48737359e0e6dd9e59701a568", "url": "https://api.github.com/repos/rust-lang/rust/commits/2ac5f7d249e29ee48737359e0e6dd9e59701a568", "html_url": "https://github.com/rust-lang/rust/commit/2ac5f7d249e29ee48737359e0e6dd9e59701a568"}], "stats": {"total": 48, "additions": 24, "deletions": 24}, "files": [{"sha": "3ea7d349c9cd70476141efa3f2432e042ec03e52", "filename": "src/liballoc/allocator.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/47cb3c5bc28e1bb2ac2d2efb7796ceb17b4ab7de/src%2Fliballoc%2Fallocator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/47cb3c5bc28e1bb2ac2d2efb7796ceb17b4ab7de/src%2Fliballoc%2Fallocator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fallocator.rs?ref=47cb3c5bc28e1bb2ac2d2efb7796ceb17b4ab7de", "patch": "@@ -40,7 +40,7 @@ fn size_align<T>() -> (usize, usize) {\n ///\n /// (Note however that layouts are *not* required to have positive\n /// size, even though many allocators require that all memory\n-/// requeusts have positive size. A caller to the `Alloc::alloc`\n+/// requests have positive size. A caller to the `Alloc::alloc`\n /// method must either ensure that conditions like this are met, or\n /// use specific allocators with looser requirements.)\n #[derive(Clone, Debug, PartialEq, Eq)]"}, {"sha": "7fe33c20e4f23f83de4ebebd582e507fd455b56b", "filename": "src/liballoc/btree/node.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/47cb3c5bc28e1bb2ac2d2efb7796ceb17b4ab7de/src%2Fliballoc%2Fbtree%2Fnode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/47cb3c5bc28e1bb2ac2d2efb7796ceb17b4ab7de/src%2Fliballoc%2Fbtree%2Fnode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fbtree%2Fnode.rs?ref=47cb3c5bc28e1bb2ac2d2efb7796ceb17b4ab7de", "patch": "@@ -132,7 +132,7 @@ impl<K, V> InternalNode<K, V> {\n \n /// An owned pointer to a node. This basically is either `Box<LeafNode<K, V>>` or\n /// `Box<InternalNode<K, V>>`. However, it contains no information as to which of the two types\n-/// of nodes is acutally behind the box, and, partially due to this lack of information, has no\n+/// of nodes is actually behind the box, and, partially due to this lack of information, has no\n /// destructor.\n struct BoxedNode<K, V> {\n     ptr: Unique<LeafNode<K, V>>\n@@ -264,7 +264,7 @@ impl<K, V> Root<K, V> {\n // correct variance.\n /// A reference to a node.\n ///\n-/// This type has a number of paramaters that controls how it acts:\n+/// This type has a number of parameters that controls how it acts:\n /// - `BorrowType`: This can be `Immut<'a>` or `Mut<'a>` for some `'a` or `Owned`.\n ///    When this is `Immut<'a>`, the `NodeRef` acts roughly like `&'a Node`,\n ///    when this is `Mut<'a>`, the `NodeRef` acts roughly like `&'a mut Node`,"}, {"sha": "22b997a768e6d6f7d5543c2654b3a56601871c11", "filename": "src/libcore/iter/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/47cb3c5bc28e1bb2ac2d2efb7796ceb17b4ab7de/src%2Flibcore%2Fiter%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/47cb3c5bc28e1bb2ac2d2efb7796ceb17b4ab7de/src%2Flibcore%2Fiter%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter%2Fmod.rs?ref=47cb3c5bc28e1bb2ac2d2efb7796ceb17b4ab7de", "patch": "@@ -1035,7 +1035,7 @@ unsafe impl<A, B> TrustedLen for Zip<A, B>\n /// Now consider this twist where we add a call to `rev`. This version will\n /// print `('c', 1), ('b', 2), ('a', 3)`. Note that the letters are reversed,\n /// but the values of the counter still go in order. This is because `map()` is\n-/// still being called lazilly on each item, but we are popping items off the\n+/// still being called lazily on each item, but we are popping items off the\n /// back of the vector now, instead of shifting them from the front.\n ///\n /// ```rust"}, {"sha": "19098f036acd2c428308cc85cfddf32246978b96", "filename": "src/libcore/iter/traits.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/47cb3c5bc28e1bb2ac2d2efb7796ceb17b4ab7de/src%2Flibcore%2Fiter%2Ftraits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/47cb3c5bc28e1bb2ac2d2efb7796ceb17b4ab7de/src%2Flibcore%2Fiter%2Ftraits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter%2Ftraits.rs?ref=47cb3c5bc28e1bb2ac2d2efb7796ceb17b4ab7de", "patch": "@@ -345,7 +345,7 @@ pub trait Extend<A> {\n /// In a similar fashion to the [`Iterator`] protocol, once a\n /// `DoubleEndedIterator` returns `None` from a `next_back()`, calling it again\n /// may or may not ever return `Some` again. `next()` and `next_back()` are\n-/// interchangable for this purpose.\n+/// interchangeable for this purpose.\n ///\n /// [`Iterator`]: trait.Iterator.html\n ///"}, {"sha": "ccf3950c2ba396920c1500aa650af46aa40cf7e6", "filename": "src/libcore/num/dec2flt/algorithm.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/47cb3c5bc28e1bb2ac2d2efb7796ceb17b4ab7de/src%2Flibcore%2Fnum%2Fdec2flt%2Falgorithm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/47cb3c5bc28e1bb2ac2d2efb7796ceb17b4ab7de/src%2Flibcore%2Fnum%2Fdec2flt%2Falgorithm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fdec2flt%2Falgorithm.rs?ref=47cb3c5bc28e1bb2ac2d2efb7796ceb17b4ab7de", "patch": "@@ -336,7 +336,7 @@ pub fn algorithm_m<T: RawFloat>(f: &Big, e: i16) -> T {\n     round_by_remainder(v, rem, q, z)\n }\n \n-/// Skip over most AlgorithmM iterations by checking the bit length.\n+/// Skip over most Algorithm M iterations by checking the bit length.\n fn quick_start<T: RawFloat>(u: &mut Big, v: &mut Big, k: &mut i16) {\n     // The bit length is an estimate of the base two logarithm, and log(u / v) = log(u) - log(v).\n     // The estimate is off by at most 1, but always an under-estimate, so the error on log(u)"}, {"sha": "400d53ce51a08cfe2851120074502dc55867e084", "filename": "src/libcore/tests/num/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/47cb3c5bc28e1bb2ac2d2efb7796ceb17b4ab7de/src%2Flibcore%2Ftests%2Fnum%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/47cb3c5bc28e1bb2ac2d2efb7796ceb17b4ab7de/src%2Flibcore%2Ftests%2Fnum%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftests%2Fnum%2Fmod.rs?ref=47cb3c5bc28e1bb2ac2d2efb7796ceb17b4ab7de", "patch": "@@ -566,7 +566,7 @@ assume_usize_width! {\n     );\n }\n \n-/// Conversinos where neither the min nor the max of $source can be represented by\n+/// Conversions where neither the min nor the max of $source can be represented by\n /// $target, but max/min of the target can be represented by the source.\n macro_rules! test_impl_try_from_signed_to_unsigned_err {\n     ($fn_name:ident, $source:ty, $target:ty) => {"}, {"sha": "611137562a9062b464b05db5ca42bce7194d3c79", "filename": "src/librustc/traits/specialize/specialization_graph.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/47cb3c5bc28e1bb2ac2d2efb7796ceb17b4ab7de/src%2Flibrustc%2Ftraits%2Fspecialize%2Fspecialization_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/47cb3c5bc28e1bb2ac2d2efb7796ceb17b4ab7de/src%2Flibrustc%2Ftraits%2Fspecialize%2Fspecialization_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fspecialize%2Fspecialization_graph.rs?ref=47cb3c5bc28e1bb2ac2d2efb7796ceb17b4ab7de", "patch": "@@ -31,7 +31,7 @@ use util::nodemap::{DefIdMap, FxHashMap};\n ///\n /// - Parent extraction. In particular, the graph can give you the *immediate*\n ///   parents of a given specializing impl, which is needed for extracting\n-///   default items amongst other thigns. In the simple \"chain\" rule, every impl\n+///   default items amongst other things. In the simple \"chain\" rule, every impl\n ///   has at most one parent.\n pub struct Graph {\n     // all impls have a parent; the \"root\" impls have as their parent the def_id"}, {"sha": "51436660779551319fa781d039d62c8a105880cd", "filename": "src/librustc/ty/adjustment.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/47cb3c5bc28e1bb2ac2d2efb7796ceb17b4ab7de/src%2Flibrustc%2Fty%2Fadjustment.rs", "raw_url": "https://github.com/rust-lang/rust/raw/47cb3c5bc28e1bb2ac2d2efb7796ceb17b4ab7de/src%2Flibrustc%2Fty%2Fadjustment.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fadjustment.rs?ref=47cb3c5bc28e1bb2ac2d2efb7796ceb17b4ab7de", "patch": "@@ -29,7 +29,7 @@ use ty::subst::Substs;\n /// by `autoref`, to either a raw or borrowed pointer. In these cases unsize is\n /// `false`.\n ///\n-/// 2. A thin-to-fat coercon involves unsizing the underlying data. We start\n+/// 2. A thin-to-fat coercion involves unsizing the underlying data. We start\n /// with a thin pointer, deref a number of times, unsize the underlying data,\n /// then autoref. The 'unsize' phase may change a fixed length array to a\n /// dynamically sized one, a concrete object to a trait object, or statically\n@@ -52,7 +52,7 @@ use ty::subst::Substs;\n /// that case, we have the pointer we need coming in, so there are no\n /// autoderefs, and no autoref. Instead we just do the `Unsize` transformation.\n /// At some point, of course, `Box` should move out of the compiler, in which\n-/// case this is analogous to transformating a struct. E.g., Box<[i32; 4]> ->\n+/// case this is analogous to transforming a struct. E.g., Box<[i32; 4]> ->\n /// Box<[i32]> is an `Adjust::Unsize` with the target `Box<[i32]>`.\n #[derive(Clone, RustcEncodable, RustcDecodable)]\n pub struct Adjustment<'tcx> {"}, {"sha": "6801aa455e11e3eadab6fd754028f0c7b5b82b6e", "filename": "src/librustc_data_structures/stable_hasher.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/47cb3c5bc28e1bb2ac2d2efb7796ceb17b4ab7de/src%2Flibrustc_data_structures%2Fstable_hasher.rs", "raw_url": "https://github.com/rust-lang/rust/raw/47cb3c5bc28e1bb2ac2d2efb7796ceb17b4ab7de/src%2Flibrustc_data_structures%2Fstable_hasher.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Fstable_hasher.rs?ref=47cb3c5bc28e1bb2ac2d2efb7796ceb17b4ab7de", "patch": "@@ -193,7 +193,7 @@ impl<W> Hasher for StableHasher<W> {\n \n \n /// Something that implements `HashStable<CTX>` can be hashed in a way that is\n-/// stable across multiple compiliation sessions.\n+/// stable across multiple compilation sessions.\n pub trait HashStable<CTX> {\n     fn hash_stable<W: StableHasherResult>(&self,\n                                           hcx: &mut CTX,"}, {"sha": "e05a5a7341fdbb0b4de619e7761791a1603fde13", "filename": "src/librustc_mir/dataflow/impls/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/47cb3c5bc28e1bb2ac2d2efb7796ceb17b4ab7de/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/47cb3c5bc28e1bb2ac2d2efb7796ceb17b4ab7de/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fmod.rs?ref=47cb3c5bc28e1bb2ac2d2efb7796ceb17b4ab7de", "patch": "@@ -212,7 +212,7 @@ impl<'a, 'tcx: 'a> HasMoveData<'tcx> for DefinitelyInitializedLvals<'a, 'tcx> {\n /// you if an l-value *might* be uninitialized at a given point in the\n /// control flow. But `MovingOutStatements` also includes the added\n /// data of *which* particular statement causing the deinitialization\n-/// that the borrow checker's error meessage may need to report.\n+/// that the borrow checker's error message may need to report.\n #[allow(dead_code)]\n pub struct MovingOutStatements<'a, 'tcx: 'a> {\n     tcx: TyCtxt<'a, 'tcx, 'tcx>,"}, {"sha": "e32de6b9768a9d2a541677546bdb3041bb5750b0", "filename": "src/librustc_mir/hair/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/47cb3c5bc28e1bb2ac2d2efb7796ceb17b4ab7de/src%2Flibrustc_mir%2Fhair%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/47cb3c5bc28e1bb2ac2d2efb7796ceb17b4ab7de/src%2Flibrustc_mir%2Fhair%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fmod.rs?ref=47cb3c5bc28e1bb2ac2d2efb7796ceb17b4ab7de", "patch": "@@ -80,7 +80,7 @@ pub enum StmtKind<'tcx> {\n \n /// The Hair trait implementor translates their expressions (`&'tcx H::Expr`)\n /// into instances of this `Expr` enum. This translation can be done\n-/// basically as lazilly or as eagerly as desired: every recursive\n+/// basically as lazily or as eagerly as desired: every recursive\n /// reference to an expression in this enum is an `ExprRef<'tcx>`, which\n /// may in turn be another instance of this enum (boxed), or else an\n /// untranslated `&'tcx H::Expr`. Note that instances of `Expr` are very"}, {"sha": "3734e91d8c24ad6fbda3ca41f560a2245c6042d4", "filename": "src/librustc_trans/base.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/47cb3c5bc28e1bb2ac2d2efb7796ceb17b4ab7de/src%2Flibrustc_trans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/47cb3c5bc28e1bb2ac2d2efb7796ceb17b4ab7de/src%2Flibrustc_trans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fbase.rs?ref=47cb3c5bc28e1bb2ac2d2efb7796ceb17b4ab7de", "patch": "@@ -191,7 +191,7 @@ pub fn compare_simd_types<'a, 'tcx>(\n /// adjustment.\n ///\n /// The `old_info` argument is a bit funny. It is intended for use\n-/// in an upcast, where the new vtable for an object will be drived\n+/// in an upcast, where the new vtable for an object will be derived\n /// from the old one.\n pub fn unsized_info<'ccx, 'tcx>(ccx: &CrateContext<'ccx, 'tcx>,\n                                 source: Ty<'tcx>,"}, {"sha": "72ff9eb6f5b0d48ee3bdbc2abda3a9ad7057702f", "filename": "src/librustc_typeck/check/dropck.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/47cb3c5bc28e1bb2ac2d2efb7796ceb17b4ab7de/src%2Flibrustc_typeck%2Fcheck%2Fdropck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/47cb3c5bc28e1bb2ac2d2efb7796ceb17b4ab7de/src%2Flibrustc_typeck%2Fcheck%2Fdropck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fdropck.rs?ref=47cb3c5bc28e1bb2ac2d2efb7796ceb17b4ab7de", "patch": "@@ -22,7 +22,7 @@ use util::nodemap::FxHashSet;\n \n use syntax_pos::Span;\n \n-/// check_drop_impl confirms that the Drop implementation identfied by\n+/// check_drop_impl confirms that the Drop implementation identified by\n /// `drop_impl_did` is not any more specialized than the type it is\n /// attached to (Issue #8142).\n ///"}, {"sha": "37cb1f9280b61ea0c6858262c750092f1b77bffc", "filename": "src/librustc_typeck/constrained_type_params.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/47cb3c5bc28e1bb2ac2d2efb7796ceb17b4ab7de/src%2Flibrustc_typeck%2Fconstrained_type_params.rs", "raw_url": "https://github.com/rust-lang/rust/raw/47cb3c5bc28e1bb2ac2d2efb7796ceb17b4ab7de/src%2Flibrustc_typeck%2Fconstrained_type_params.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fconstrained_type_params.rs?ref=47cb3c5bc28e1bb2ac2d2efb7796ceb17b4ab7de", "patch": "@@ -98,7 +98,7 @@ pub fn identify_constrained_type_params<'tcx>(tcx: ty::TyCtxt,\n \n /// Order the predicates in `predicates` such that each parameter is\n /// constrained before it is used, if that is possible, and add the\n-/// paramaters so constrained to `input_parameters`. For example,\n+/// parameters so constrained to `input_parameters`. For example,\n /// imagine the following impl:\n ///\n ///     impl<T: Debug, U: Iterator<Item=T>> Trait for U"}, {"sha": "4b0db749964ca6946ab8d22db359d028f2d553fd", "filename": "src/librustc_typeck/variance/constraints.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/47cb3c5bc28e1bb2ac2d2efb7796ceb17b4ab7de/src%2Flibrustc_typeck%2Fvariance%2Fconstraints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/47cb3c5bc28e1bb2ac2d2efb7796ceb17b4ab7de/src%2Flibrustc_typeck%2Fvariance%2Fconstraints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fvariance%2Fconstraints.rs?ref=47cb3c5bc28e1bb2ac2d2efb7796ceb17b4ab7de", "patch": "@@ -51,7 +51,7 @@ pub struct Constraint<'a> {\n     pub variance: &'a VarianceTerm<'a>,\n }\n \n-/// To build constriants, we visit one item (type, trait) at a time\n+/// To build constraints, we visit one item (type, trait) at a time\n /// and look at its contents. So e.g. if we have\n ///\n ///     struct Foo<T> {"}, {"sha": "9b4c4e479d046e17813a291b5bc33139a57c060a", "filename": "src/librustdoc/clean/inline.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/47cb3c5bc28e1bb2ac2d2efb7796ceb17b4ab7de/src%2Flibrustdoc%2Fclean%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/47cb3c5bc28e1bb2ac2d2efb7796ceb17b4ab7de/src%2Flibrustdoc%2Fclean%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Finline.rs?ref=47cb3c5bc28e1bb2ac2d2efb7796ceb17b4ab7de", "patch": "@@ -495,7 +495,7 @@ fn build_static(cx: &DocContext, did: DefId, mutable: bool) -> clean::Static {\n \n /// A trait's generics clause actually contains all of the predicates for all of\n /// its associated types as well. We specifically move these clauses to the\n-/// associated types instead when displaying, so when we're genering the\n+/// associated types instead when displaying, so when we're generating the\n /// generics for the trait itself we need to be sure to remove them.\n /// We also need to remove the implied \"recursive\" Self: Trait bound.\n ///"}, {"sha": "10b3209257efe19eb7a205e23a3ff563c6443c96", "filename": "src/libstd/panic.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/47cb3c5bc28e1bb2ac2d2efb7796ceb17b4ab7de/src%2Flibstd%2Fpanic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/47cb3c5bc28e1bb2ac2d2efb7796ceb17b4ab7de/src%2Flibstd%2Fpanic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpanic.rs?ref=47cb3c5bc28e1bb2ac2d2efb7796ceb17b4ab7de", "patch": "@@ -37,7 +37,7 @@ pub use panicking::{take_hook, set_hook, PanicInfo, Location};\n /// In Rust a function can \"return\" early if it either panics or calls a\n /// function which transitively panics. This sort of control flow is not always\n /// anticipated, and has the possibility of causing subtle bugs through a\n-/// combination of two cricial components:\n+/// combination of two criticial components:\n ///\n /// 1. A data structure is in a temporarily invalid state when the thread\n ///    panics."}, {"sha": "9fc809eb821d8345e5b559151cea9fdc51380140", "filename": "src/libstd/sys/redox/syscall/call.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/47cb3c5bc28e1bb2ac2d2efb7796ceb17b4ab7de/src%2Flibstd%2Fsys%2Fredox%2Fsyscall%2Fcall.rs", "raw_url": "https://github.com/rust-lang/rust/raw/47cb3c5bc28e1bb2ac2d2efb7796ceb17b4ab7de/src%2Flibstd%2Fsys%2Fredox%2Fsyscall%2Fcall.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fredox%2Fsyscall%2Fcall.rs?ref=47cb3c5bc28e1bb2ac2d2efb7796ceb17b4ab7de", "patch": "@@ -40,7 +40,7 @@ pub unsafe fn brk(addr: usize) -> Result<usize> {\n ///\n /// * `EACCES` - permission is denied for one of the components of `path`, or `path`\n /// * `EFAULT` - `path` does not point to the process's addressible memory\n-/// * `EIO` - an I/O error occured\n+/// * `EIO` - an I/O error occurred\n /// * `ENOENT` - `path` does not exit\n /// * `ENOTDIR` - `path` is not a directory\n pub fn chdir(path: &str) -> Result<usize> {\n@@ -290,7 +290,7 @@ pub fn waitpid(pid: usize, status: &mut usize, options: usize) -> Result<usize>\n /// * `EAGAIN` - the file descriptor was opened with `O_NONBLOCK` and writing would block\n /// * `EBADF` - the file descriptor is not valid or is not open for writing\n /// * `EFAULT` - `buf` does not point to the process's addressible memory\n-/// * `EIO` - an I/O error occured\n+/// * `EIO` - an I/O error occurred\n /// * `ENOSPC` - the device containing the file descriptor has no room for data\n /// * `EPIPE` - the file descriptor refers to a pipe or socket whose reading end is closed\n pub fn write(fd: usize, buf: &[u8]) -> Result<usize> {"}, {"sha": "80eb8ba93f7544f4d72adc3d3af29644bd08fedc", "filename": "src/libstd/thread/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/47cb3c5bc28e1bb2ac2d2efb7796ceb17b4ab7de/src%2Flibstd%2Fthread%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/47cb3c5bc28e1bb2ac2d2efb7796ceb17b4ab7de/src%2Flibstd%2Fthread%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fthread%2Fmod.rs?ref=47cb3c5bc28e1bb2ac2d2efb7796ceb17b4ab7de", "patch": "@@ -531,7 +531,7 @@ pub fn current() -> Thread {\n ///\n /// However programmers will usually prefer to use, [`channel`]s, [`Condvar`]s,\n /// [`Mutex`]es or [`join`] for their synchronisation routines, as they avoid\n-/// thinking about thread schedulling.\n+/// thinking about thread scheduling.\n ///\n /// Note that [`channel`]s for example are implemented using this primitive.\n /// Indeed when you call `send` or `recv`, which are blocking, they will yield"}, {"sha": "d5caf458fd762a233451db6b523a844f38376c76", "filename": "src/libsyntax/attr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/47cb3c5bc28e1bb2ac2d2efb7796ceb17b4ab7de/src%2Flibsyntax%2Fattr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/47cb3c5bc28e1bb2ac2d2efb7796ceb17b4ab7de/src%2Flibsyntax%2Fattr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fattr.rs?ref=47cb3c5bc28e1bb2ac2d2efb7796ceb17b4ab7de", "patch": "@@ -435,7 +435,7 @@ pub fn mk_attr_inner(span: Span, id: AttrId, item: MetaItem) -> Attribute {\n     mk_spanned_attr_inner(span, id, item)\n }\n \n-/// Returns an innter attribute with the given value and span.\n+/// Returns an inner attribute with the given value and span.\n pub fn mk_spanned_attr_inner(sp: Span, id: AttrId, item: MetaItem) -> Attribute {\n     Attribute {\n         id: id,"}, {"sha": "957164bab79a708dcdb066371b4fb09c449ab082", "filename": "src/libsyntax/parse/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/47cb3c5bc28e1bb2ac2d2efb7796ceb17b4ab7de/src%2Flibsyntax%2Fparse%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/47cb3c5bc28e1bb2ac2d2efb7796ceb17b4ab7de/src%2Flibsyntax%2Fparse%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fmod.rs?ref=47cb3c5bc28e1bb2ac2d2efb7796ceb17b4ab7de", "patch": "@@ -124,7 +124,7 @@ pub fn parse_expr_from_source_str(name: String, source: String, sess: &ParseSess\n \n /// Parses an item.\n ///\n-/// Returns `Ok(Some(item))` when successful, `Ok(None)` when no item was found, and`Err`\n+/// Returns `Ok(Some(item))` when successful, `Ok(None)` when no item was found, and `Err`\n /// when a syntax error occurred.\n pub fn parse_item_from_source_str(name: String, source: String, sess: &ParseSess)\n                                       -> PResult<Option<P<ast::Item>>> {"}]}