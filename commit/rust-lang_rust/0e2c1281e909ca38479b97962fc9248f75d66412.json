{"sha": "0e2c1281e909ca38479b97962fc9248f75d66412", "node_id": "MDY6Q29tbWl0NzI0NzEyOjBlMmMxMjgxZTkwOWNhMzg0NzliOTc5NjJmYzkyNDhmNzVkNjY0MTI=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-09-07T21:29:43Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-09-07T21:29:43Z"}, "message": "Auto merge of #76044 - ecstatic-morse:dataflow-lattice, r=oli-obk\n\nSupport dataflow problems on arbitrary lattices\n\nThis PR implements last of the proposed extensions I mentioned in the design meeting for the original dataflow refactor. It extends the current dataflow framework to work with arbitrary lattices, not just `BitSet`s. This is a prerequisite for dataflow-enabled MIR const-propagation. Personally, I am skeptical of the usefulness of doing const-propagation pre-monomorphization, since many useful constants only become known after monomorphization (e.g. `size_of::<T>()`) and users have a natural tendency to hand-optimize the rest. It's probably worth exprimenting with, however, and others have shown interest cc `@rust-lang/wg-mir-opt.`\n\nThe `Idx` associated type is moved from `AnalysisDomain` to `GenKillAnalysis` and replaced with an associated `Domain` type that must implement `JoinSemiLattice`. Like before, each `Analysis` defines the \"bottom value\" for its domain, but can no longer override the dataflow join operator. Analyses that want to use set intersection must now use the `lattice::Dual` newtype. `GenKillAnalysis` impls have an additional requirement that `Self::Domain: BorrowMut<BitSet<Self::Idx>>`, which effectively means that they must use `BitSet<Self::Idx>` or `lattice::Dual<BitSet<Self::Idx>>` as their domain.\n\nMost of these changes were mechanical. However, because a `Domain` is no longer always a powerset of some index type, we can no longer use an `IndexVec<BasicBlock, GenKillSet<A::Idx>>>` to store cached block transfer functions. Instead, we use a boxed `dyn Fn` trait object. I discuss a few alternatives to the current approach in a commit message.\n\nThe majority of new lines of code are to preserve existing Graphviz diagrams for those unlucky enough to have to debug dataflow analyses. I find these diagrams incredibly useful when things are going wrong and considered regressing them unacceptable, especially the pretty-printing of `MovePathIndex`s, which are used in many dataflow analyses. This required a parallel `fmt` trait used only for printing dataflow domains, as well as a refactoring of the `graphviz` module now that we cannot expect the domain to be a `BitSet`. Some features did have to be removed, such as the gen/kill display mode (which I didn't use but existed to mirror the output of the old dataflow framework) and line wrapping. Since I had to rewrite much of it anyway, I took the opportunity to switch to a `Visitor` for printing dataflow state diffs instead of using cursors, which are error prone for code that must be generic over both forward and backward analyses. As a side-effect of this change, we no longer have quadratic behavior when writing graphviz diagrams for backward dataflow analyses.\n\nr? `@pnkfelix`", "tree": {"sha": "318f7be4b6d08cc367320e9ffb03a55c97079955", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/318f7be4b6d08cc367320e9ffb03a55c97079955"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0e2c1281e909ca38479b97962fc9248f75d66412", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0e2c1281e909ca38479b97962fc9248f75d66412", "html_url": "https://github.com/rust-lang/rust/commit/0e2c1281e909ca38479b97962fc9248f75d66412", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0e2c1281e909ca38479b97962fc9248f75d66412/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9fe551ae49289ce6f693ca0dabf4c9c15164f67d", "url": "https://api.github.com/repos/rust-lang/rust/commits/9fe551ae49289ce6f693ca0dabf4c9c15164f67d", "html_url": "https://github.com/rust-lang/rust/commit/9fe551ae49289ce6f693ca0dabf4c9c15164f67d"}, {"sha": "b015109ba9bce939beef2d3e4fa3597ea0db1f27", "url": "https://api.github.com/repos/rust-lang/rust/commits/b015109ba9bce939beef2d3e4fa3597ea0db1f27", "html_url": "https://github.com/rust-lang/rust/commit/b015109ba9bce939beef2d3e4fa3597ea0db1f27"}], "stats": {"total": 1625, "additions": 947, "deletions": 678}, "files": [{"sha": "4831da86ae13bfc6f579918f3e285821d6e9a272", "filename": "Cargo.lock", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0e2c1281e909ca38479b97962fc9248f75d66412/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/0e2c1281e909ca38479b97962fc9248f75d66412/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=0e2c1281e909ca38479b97962fc9248f75d66412", "patch": "@@ -3756,6 +3756,7 @@ dependencies = [\n  \"itertools 0.8.2\",\n  \"log_settings\",\n  \"polonius-engine\",\n+ \"regex\",\n  \"rustc_apfloat\",\n  \"rustc_ast\",\n  \"rustc_attr\","}, {"sha": "8e00e54650df0405269a9671bdd3572c22df64f2", "filename": "compiler/rustc_index/src/bit_set.rs", "status": "modified", "additions": 37, "deletions": 17, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/0e2c1281e909ca38479b97962fc9248f75d66412/compiler%2Frustc_index%2Fsrc%2Fbit_set.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e2c1281e909ca38479b97962fc9248f75d66412/compiler%2Frustc_index%2Fsrc%2Fbit_set.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_index%2Fsrc%2Fbit_set.rs?ref=0e2c1281e909ca38479b97962fc9248f75d66412", "patch": "@@ -28,13 +28,20 @@ pub const WORD_BITS: usize = WORD_BYTES * 8;\n /// will panic if the bitsets have differing domain sizes.\n ///\n /// [`GrowableBitSet`]: struct.GrowableBitSet.html\n-#[derive(Clone, Eq, PartialEq, Decodable, Encodable)]\n-pub struct BitSet<T: Idx> {\n+#[derive(Eq, PartialEq, Decodable, Encodable)]\n+pub struct BitSet<T> {\n     domain_size: usize,\n     words: Vec<Word>,\n     marker: PhantomData<T>,\n }\n \n+impl<T> BitSet<T> {\n+    /// Gets the domain size.\n+    pub fn domain_size(&self) -> usize {\n+        self.domain_size\n+    }\n+}\n+\n impl<T: Idx> BitSet<T> {\n     /// Creates a new, empty bitset with a given `domain_size`.\n     #[inline]\n@@ -52,11 +59,6 @@ impl<T: Idx> BitSet<T> {\n         result\n     }\n \n-    /// Gets the domain size.\n-    pub fn domain_size(&self) -> usize {\n-        self.domain_size\n-    }\n-\n     /// Clear all elements.\n     #[inline]\n     pub fn clear(&mut self) {\n@@ -75,12 +77,6 @@ impl<T: Idx> BitSet<T> {\n         }\n     }\n \n-    /// Efficiently overwrite `self` with `other`.\n-    pub fn overwrite(&mut self, other: &BitSet<T>) {\n-        assert!(self.domain_size == other.domain_size);\n-        self.words.clone_from_slice(&other.words);\n-    }\n-\n     /// Count the number of set bits in the set.\n     pub fn count(&self) -> usize {\n         self.words.iter().map(|e| e.count_ones() as usize).sum()\n@@ -243,6 +239,21 @@ impl<T: Idx> SubtractFromBitSet<T> for BitSet<T> {\n     }\n }\n \n+impl<T> Clone for BitSet<T> {\n+    fn clone(&self) -> Self {\n+        BitSet { domain_size: self.domain_size, words: self.words.clone(), marker: PhantomData }\n+    }\n+\n+    fn clone_from(&mut self, from: &Self) {\n+        if self.domain_size != from.domain_size {\n+            self.words.resize(from.domain_size, 0);\n+            self.domain_size = from.domain_size;\n+        }\n+\n+        self.words.copy_from_slice(&from.words);\n+    }\n+}\n+\n impl<T: Idx> fmt::Debug for BitSet<T> {\n     fn fmt(&self, w: &mut fmt::Formatter<'_>) -> fmt::Result {\n         w.debug_list().entries(self.iter()).finish()\n@@ -363,7 +374,7 @@ const SPARSE_MAX: usize = 8;\n ///\n /// This type is used by `HybridBitSet`; do not use directly.\n #[derive(Clone, Debug)]\n-pub struct SparseBitSet<T: Idx> {\n+pub struct SparseBitSet<T> {\n     domain_size: usize,\n     elems: ArrayVec<[T; SPARSE_MAX]>,\n }\n@@ -464,18 +475,27 @@ impl<T: Idx> SubtractFromBitSet<T> for SparseBitSet<T> {\n /// All operations that involve an element will panic if the element is equal\n /// to or greater than the domain size. All operations that involve two bitsets\n /// will panic if the bitsets have differing domain sizes.\n-#[derive(Clone, Debug)]\n-pub enum HybridBitSet<T: Idx> {\n+#[derive(Clone)]\n+pub enum HybridBitSet<T> {\n     Sparse(SparseBitSet<T>),\n     Dense(BitSet<T>),\n }\n \n+impl<T: Idx> fmt::Debug for HybridBitSet<T> {\n+    fn fmt(&self, w: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        match self {\n+            Self::Sparse(b) => b.fmt(w),\n+            Self::Dense(b) => b.fmt(w),\n+        }\n+    }\n+}\n+\n impl<T: Idx> HybridBitSet<T> {\n     pub fn new_empty(domain_size: usize) -> Self {\n         HybridBitSet::Sparse(SparseBitSet::new_empty(domain_size))\n     }\n \n-    fn domain_size(&self) -> usize {\n+    pub fn domain_size(&self) -> usize {\n         match self {\n             HybridBitSet::Sparse(sparse) => sparse.domain_size,\n             HybridBitSet::Dense(dense) => dense.domain_size,"}, {"sha": "0a22bc7d7628f058a2b7f2f81495e8461a480108", "filename": "compiler/rustc_mir/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0e2c1281e909ca38479b97962fc9248f75d66412/compiler%2Frustc_mir%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/0e2c1281e909ca38479b97962fc9248f75d66412/compiler%2Frustc_mir%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2FCargo.toml?ref=0e2c1281e909ca38479b97962fc9248f75d66412", "patch": "@@ -14,6 +14,7 @@ itertools = \"0.8\"\n tracing = \"0.1\"\n log_settings = \"0.1.1\"\n polonius-engine = \"0.12.0\"\n+regex = \"1\"\n rustc_middle = { path = \"../rustc_middle\" }\n rustc_attr = { path = \"../rustc_attr\" }\n rustc_data_structures = { path = \"../rustc_data_structures\" }"}, {"sha": "4942bed656cc6b251e756e71e1871cd1686db926", "filename": "compiler/rustc_mir/src/dataflow/framework/cursor.rs", "status": "modified", "additions": 25, "deletions": 16, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/0e2c1281e909ca38479b97962fc9248f75d66412/compiler%2Frustc_mir%2Fsrc%2Fdataflow%2Fframework%2Fcursor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e2c1281e909ca38479b97962fc9248f75d66412/compiler%2Frustc_mir%2Fsrc%2Fdataflow%2Fframework%2Fcursor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Fdataflow%2Fframework%2Fcursor.rs?ref=0e2c1281e909ca38479b97962fc9248f75d66412", "patch": "@@ -4,6 +4,7 @@ use std::borrow::Borrow;\n use std::cmp::Ordering;\n \n use rustc_index::bit_set::BitSet;\n+use rustc_index::vec::Idx;\n use rustc_middle::mir::{self, BasicBlock, Location};\n \n use super::{Analysis, Direction, Effect, EffectIndex, Results};\n@@ -26,7 +27,7 @@ where\n {\n     body: &'mir mir::Body<'tcx>,\n     results: R,\n-    state: BitSet<A::Idx>,\n+    state: A::Domain,\n \n     pos: CursorPosition,\n \n@@ -46,17 +47,16 @@ where\n {\n     /// Returns a new cursor that can inspect `results`.\n     pub fn new(body: &'mir mir::Body<'tcx>, results: R) -> Self {\n-        let bits_per_block = results.borrow().entry_set_for_block(mir::START_BLOCK).domain_size();\n-\n+        let bottom_value = results.borrow().analysis.bottom_value(body);\n         ResultsCursor {\n             body,\n             results,\n \n-            // Initialize to an empty `BitSet` and set `state_needs_reset` to tell the cursor that\n+            // Initialize to the `bottom_value` and set `state_needs_reset` to tell the cursor that\n             // it needs to reset to block entry before the first seek. The cursor position is\n             // immaterial.\n             state_needs_reset: true,\n-            state: BitSet::new_empty(bits_per_block),\n+            state: bottom_value,\n             pos: CursorPosition::block_entry(mir::START_BLOCK),\n \n             #[cfg(debug_assertions)]\n@@ -68,23 +68,21 @@ where\n         self.body\n     }\n \n-    /// Returns the `Analysis` used to generate the underlying results.\n+    /// Returns the underlying `Results`.\n+    pub fn results(&self) -> &Results<'tcx, A> {\n+        &self.results.borrow()\n+    }\n+\n+    /// Returns the `Analysis` used to generate the underlying `Results`.\n     pub fn analysis(&self) -> &A {\n         &self.results.borrow().analysis\n     }\n \n     /// Returns the dataflow state at the current location.\n-    pub fn get(&self) -> &BitSet<A::Idx> {\n+    pub fn get(&self) -> &A::Domain {\n         &self.state\n     }\n \n-    /// Returns `true` if the dataflow state at the current location contains the given element.\n-    ///\n-    /// Shorthand for `self.get().contains(elem)`\n-    pub fn contains(&self, elem: A::Idx) -> bool {\n-        self.state.contains(elem)\n-    }\n-\n     /// Resets the cursor to hold the entry set for the given basic block.\n     ///\n     /// For forward dataflow analyses, this is the dataflow state prior to the first statement.\n@@ -94,7 +92,7 @@ where\n         #[cfg(debug_assertions)]\n         assert!(self.reachable_blocks.contains(block));\n \n-        self.state.overwrite(&self.results.borrow().entry_set_for_block(block));\n+        self.state.clone_from(&self.results.borrow().entry_set_for_block(block));\n         self.pos = CursorPosition::block_entry(block);\n         self.state_needs_reset = false;\n     }\n@@ -202,12 +200,23 @@ where\n     ///\n     /// This can be used, e.g., to apply the call return effect directly to the cursor without\n     /// creating an extra copy of the dataflow state.\n-    pub fn apply_custom_effect(&mut self, f: impl FnOnce(&A, &mut BitSet<A::Idx>)) {\n+    pub fn apply_custom_effect(&mut self, f: impl FnOnce(&A, &mut A::Domain)) {\n         f(&self.results.borrow().analysis, &mut self.state);\n         self.state_needs_reset = true;\n     }\n }\n \n+impl<'mir, 'tcx, A, R, T> ResultsCursor<'mir, 'tcx, A, R>\n+where\n+    A: Analysis<'tcx, Domain = BitSet<T>>,\n+    T: Idx,\n+    R: Borrow<Results<'tcx, A>>,\n+{\n+    pub fn contains(&self, elem: T) -> bool {\n+        self.get().contains(elem)\n+    }\n+}\n+\n #[derive(Clone, Copy, Debug)]\n struct CursorPosition {\n     block: BasicBlock,"}, {"sha": "76c48100371ea1bb82fe9a830a3557ee346e4653", "filename": "compiler/rustc_mir/src/dataflow/framework/direction.rs", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/0e2c1281e909ca38479b97962fc9248f75d66412/compiler%2Frustc_mir%2Fsrc%2Fdataflow%2Fframework%2Fdirection.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e2c1281e909ca38479b97962fc9248f75d66412/compiler%2Frustc_mir%2Fsrc%2Fdataflow%2Fframework%2Fdirection.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Fdataflow%2Fframework%2Fdirection.rs?ref=0e2c1281e909ca38479b97962fc9248f75d66412", "patch": "@@ -18,7 +18,7 @@ pub trait Direction {\n     /// `effects.start()` must precede or equal `effects.end()` in this direction.\n     fn apply_effects_in_range<A>(\n         analysis: &A,\n-        state: &mut BitSet<A::Idx>,\n+        state: &mut A::Domain,\n         block: BasicBlock,\n         block_data: &mir::BasicBlockData<'tcx>,\n         effects: RangeInclusive<EffectIndex>,\n@@ -27,7 +27,7 @@ pub trait Direction {\n \n     fn apply_effects_in_block<A>(\n         analysis: &A,\n-        state: &mut BitSet<A::Idx>,\n+        state: &mut A::Domain,\n         block: BasicBlock,\n         block_data: &mir::BasicBlockData<'tcx>,\n     ) where\n@@ -55,9 +55,9 @@ pub trait Direction {\n         tcx: TyCtxt<'tcx>,\n         body: &mir::Body<'tcx>,\n         dead_unwinds: Option<&BitSet<BasicBlock>>,\n-        exit_state: &mut BitSet<A::Idx>,\n+        exit_state: &mut A::Domain,\n         block: (BasicBlock, &'_ mir::BasicBlockData<'tcx>),\n-        propagate: impl FnMut(BasicBlock, &BitSet<A::Idx>),\n+        propagate: impl FnMut(BasicBlock, &A::Domain),\n     ) where\n         A: Analysis<'tcx>;\n }\n@@ -72,7 +72,7 @@ impl Direction for Backward {\n \n     fn apply_effects_in_block<A>(\n         analysis: &A,\n-        state: &mut BitSet<A::Idx>,\n+        state: &mut A::Domain,\n         block: BasicBlock,\n         block_data: &mir::BasicBlockData<'tcx>,\n     ) where\n@@ -112,7 +112,7 @@ impl Direction for Backward {\n \n     fn apply_effects_in_range<A>(\n         analysis: &A,\n-        state: &mut BitSet<A::Idx>,\n+        state: &mut A::Domain,\n         block: BasicBlock,\n         block_data: &mir::BasicBlockData<'tcx>,\n         effects: RangeInclusive<EffectIndex>,\n@@ -224,9 +224,9 @@ impl Direction for Backward {\n         _tcx: TyCtxt<'tcx>,\n         body: &mir::Body<'tcx>,\n         dead_unwinds: Option<&BitSet<BasicBlock>>,\n-        exit_state: &mut BitSet<A::Idx>,\n+        exit_state: &mut A::Domain,\n         (bb, _bb_data): (BasicBlock, &'_ mir::BasicBlockData<'tcx>),\n-        mut propagate: impl FnMut(BasicBlock, &BitSet<A::Idx>),\n+        mut propagate: impl FnMut(BasicBlock, &A::Domain),\n     ) where\n         A: Analysis<'tcx>,\n     {\n@@ -281,7 +281,7 @@ impl Direction for Forward {\n \n     fn apply_effects_in_block<A>(\n         analysis: &A,\n-        state: &mut BitSet<A::Idx>,\n+        state: &mut A::Domain,\n         block: BasicBlock,\n         block_data: &mir::BasicBlockData<'tcx>,\n     ) where\n@@ -321,7 +321,7 @@ impl Direction for Forward {\n \n     fn apply_effects_in_range<A>(\n         analysis: &A,\n-        state: &mut BitSet<A::Idx>,\n+        state: &mut A::Domain,\n         block: BasicBlock,\n         block_data: &mir::BasicBlockData<'tcx>,\n         effects: RangeInclusive<EffectIndex>,\n@@ -428,9 +428,9 @@ impl Direction for Forward {\n         tcx: TyCtxt<'tcx>,\n         body: &mir::Body<'tcx>,\n         dead_unwinds: Option<&BitSet<BasicBlock>>,\n-        exit_state: &mut BitSet<A::Idx>,\n+        exit_state: &mut A::Domain,\n         (bb, bb_data): (BasicBlock, &'_ mir::BasicBlockData<'tcx>),\n-        mut propagate: impl FnMut(BasicBlock, &BitSet<A::Idx>),\n+        mut propagate: impl FnMut(BasicBlock, &A::Domain),\n     ) where\n         A: Analysis<'tcx>,\n     {\n@@ -499,7 +499,7 @@ impl Direction for Forward {\n                         // MIR building adds discriminants to the `values` array in the same order as they\n                         // are yielded by `AdtDef::discriminants`. We rely on this to match each\n                         // discriminant in `values` to its corresponding variant in linear time.\n-                        let mut tmp = BitSet::new_empty(exit_state.domain_size());\n+                        let mut tmp = analysis.bottom_value(body);\n                         let mut discriminants = enum_def.discriminants(tcx);\n                         for (value, target) in values.iter().zip(targets.iter().copied()) {\n                             let (variant_idx, _) =\n@@ -508,7 +508,7 @@ impl Direction for Forward {\n                                          from that of `SwitchInt::values`\",\n                                 );\n \n-                            tmp.overwrite(exit_state);\n+                            tmp.clone_from(exit_state);\n                             analysis.apply_discriminant_switch_effect(\n                                 &mut tmp,\n                                 bb,"}, {"sha": "d3ad42f6bbcce5b8563205b87e98d9858eee21eb", "filename": "compiler/rustc_mir/src/dataflow/framework/engine.rs", "status": "modified", "additions": 53, "deletions": 57, "changes": 110, "blob_url": "https://github.com/rust-lang/rust/blob/0e2c1281e909ca38479b97962fc9248f75d66412/compiler%2Frustc_mir%2Fsrc%2Fdataflow%2Fframework%2Fengine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e2c1281e909ca38479b97962fc9248f75d66412/compiler%2Frustc_mir%2Fsrc%2Fdataflow%2Fframework%2Fengine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Fdataflow%2Fframework%2Fengine.rs?ref=0e2c1281e909ca38479b97962fc9248f75d66412", "patch": "@@ -1,5 +1,6 @@\n //! A solver for dataflow problems.\n \n+use std::borrow::BorrowMut;\n use std::ffi::OsString;\n use std::fs;\n use std::path::PathBuf;\n@@ -9,14 +10,16 @@ use rustc_data_structures::work_queue::WorkQueue;\n use rustc_graphviz as dot;\n use rustc_hir::def_id::DefId;\n use rustc_index::bit_set::BitSet;\n-use rustc_index::vec::IndexVec;\n+use rustc_index::vec::{Idx, IndexVec};\n use rustc_middle::mir::{self, traversal, BasicBlock};\n use rustc_middle::ty::{self, TyCtxt};\n use rustc_span::symbol::{sym, Symbol};\n \n+use super::fmt::DebugWithContext;\n use super::graphviz;\n use super::{\n-    visit_results, Analysis, Direction, GenKillAnalysis, GenKillSet, ResultsCursor, ResultsVisitor,\n+    visit_results, Analysis, Direction, GenKill, GenKillAnalysis, GenKillSet, JoinSemiLattice,\n+    ResultsCursor, ResultsVisitor,\n };\n use crate::util::pretty::dump_enabled;\n \n@@ -26,7 +29,7 @@ where\n     A: Analysis<'tcx>,\n {\n     pub analysis: A,\n-    pub(super) entry_sets: IndexVec<BasicBlock, BitSet<A::Idx>>,\n+    pub(super) entry_sets: IndexVec<BasicBlock, A::Domain>,\n }\n \n impl<A> Results<'tcx, A>\n@@ -39,23 +42,23 @@ where\n     }\n \n     /// Gets the dataflow state for the given block.\n-    pub fn entry_set_for_block(&self, block: BasicBlock) -> &BitSet<A::Idx> {\n+    pub fn entry_set_for_block(&self, block: BasicBlock) -> &A::Domain {\n         &self.entry_sets[block]\n     }\n \n     pub fn visit_with(\n         &self,\n         body: &'mir mir::Body<'tcx>,\n         blocks: impl IntoIterator<Item = BasicBlock>,\n-        vis: &mut impl ResultsVisitor<'mir, 'tcx, FlowState = BitSet<A::Idx>>,\n+        vis: &mut impl ResultsVisitor<'mir, 'tcx, FlowState = A::Domain>,\n     ) {\n         visit_results(body, blocks, self, vis)\n     }\n \n     pub fn visit_reachable_with(\n         &self,\n         body: &'mir mir::Body<'tcx>,\n-        vis: &mut impl ResultsVisitor<'mir, 'tcx, FlowState = BitSet<A::Idx>>,\n+        vis: &mut impl ResultsVisitor<'mir, 'tcx, FlowState = A::Domain>,\n     ) {\n         let blocks = mir::traversal::reachable(body);\n         visit_results(body, blocks.map(|(bb, _)| bb), self, vis)\n@@ -64,7 +67,7 @@ where\n     pub fn visit_in_rpo_with(\n         &self,\n         body: &'mir mir::Body<'tcx>,\n-        vis: &mut impl ResultsVisitor<'mir, 'tcx, FlowState = BitSet<A::Idx>>,\n+        vis: &mut impl ResultsVisitor<'mir, 'tcx, FlowState = A::Domain>,\n     ) {\n         let blocks = mir::traversal::reverse_postorder(body);\n         visit_results(body, blocks.map(|(bb, _)| bb), self, vis)\n@@ -76,21 +79,27 @@ pub struct Engine<'a, 'tcx, A>\n where\n     A: Analysis<'tcx>,\n {\n-    bits_per_block: usize,\n     tcx: TyCtxt<'tcx>,\n     body: &'a mir::Body<'tcx>,\n     def_id: DefId,\n     dead_unwinds: Option<&'a BitSet<BasicBlock>>,\n-    entry_sets: IndexVec<BasicBlock, BitSet<A::Idx>>,\n+    entry_sets: IndexVec<BasicBlock, A::Domain>,\n     analysis: A,\n \n     /// Cached, cumulative transfer functions for each block.\n-    trans_for_block: Option<IndexVec<BasicBlock, GenKillSet<A::Idx>>>,\n+    //\n+    // FIXME(ecstaticmorse): This boxed `Fn` trait object is invoked inside a tight loop for\n+    // gen/kill problems on cyclic CFGs. This is not ideal, but it doesn't seem to degrade\n+    // performance in practice. I've tried a few ways to avoid this, but they have downsides. See\n+    // the message for the commit that added this FIXME for more information.\n+    apply_trans_for_block: Option<Box<dyn Fn(BasicBlock, &mut A::Domain)>>,\n }\n \n-impl<A> Engine<'a, 'tcx, A>\n+impl<A, D, T> Engine<'a, 'tcx, A>\n where\n-    A: GenKillAnalysis<'tcx>,\n+    A: GenKillAnalysis<'tcx, Idx = T, Domain = D>,\n+    D: Clone + JoinSemiLattice + GenKill<T> + BorrowMut<BitSet<T>>,\n+    T: Idx,\n {\n     /// Creates a new `Engine` to solve a gen-kill dataflow problem.\n     pub fn new_gen_kill(\n@@ -109,22 +118,26 @@ where\n \n         // Otherwise, compute and store the cumulative transfer function for each block.\n \n-        let bits_per_block = analysis.bits_per_block(body);\n-        let mut trans_for_block =\n-            IndexVec::from_elem(GenKillSet::identity(bits_per_block), body.basic_blocks());\n+        let identity = GenKillSet::identity(analysis.bottom_value(body).borrow().domain_size());\n+        let mut trans_for_block = IndexVec::from_elem(identity, body.basic_blocks());\n \n         for (block, block_data) in body.basic_blocks().iter_enumerated() {\n             let trans = &mut trans_for_block[block];\n             A::Direction::gen_kill_effects_in_block(&analysis, trans, block, block_data);\n         }\n \n-        Self::new(tcx, body, def_id, analysis, Some(trans_for_block))\n+        let apply_trans = Box::new(move |bb: BasicBlock, state: &mut A::Domain| {\n+            trans_for_block[bb].apply(state.borrow_mut());\n+        });\n+\n+        Self::new(tcx, body, def_id, analysis, Some(apply_trans as Box<_>))\n     }\n }\n \n-impl<A> Engine<'a, 'tcx, A>\n+impl<A, D> Engine<'a, 'tcx, A>\n where\n-    A: Analysis<'tcx>,\n+    A: Analysis<'tcx, Domain = D>,\n+    D: Clone + JoinSemiLattice,\n {\n     /// Creates a new `Engine` to solve a dataflow problem with an arbitrary transfer\n     /// function.\n@@ -145,32 +158,24 @@ where\n         body: &'a mir::Body<'tcx>,\n         def_id: DefId,\n         analysis: A,\n-        trans_for_block: Option<IndexVec<BasicBlock, GenKillSet<A::Idx>>>,\n+        apply_trans_for_block: Option<Box<dyn Fn(BasicBlock, &mut A::Domain)>>,\n     ) -> Self {\n-        let bits_per_block = analysis.bits_per_block(body);\n-\n-        let bottom_value_set = if A::BOTTOM_VALUE {\n-            BitSet::new_filled(bits_per_block)\n-        } else {\n-            BitSet::new_empty(bits_per_block)\n-        };\n-\n-        let mut entry_sets = IndexVec::from_elem(bottom_value_set.clone(), body.basic_blocks());\n+        let bottom_value = analysis.bottom_value(body);\n+        let mut entry_sets = IndexVec::from_elem(bottom_value.clone(), body.basic_blocks());\n         analysis.initialize_start_block(body, &mut entry_sets[mir::START_BLOCK]);\n \n-        if A::Direction::is_backward() && entry_sets[mir::START_BLOCK] != bottom_value_set {\n+        if A::Direction::is_backward() && entry_sets[mir::START_BLOCK] != bottom_value {\n             bug!(\"`initialize_start_block` is not yet supported for backward dataflow analyses\");\n         }\n \n         Engine {\n             analysis,\n-            bits_per_block,\n             tcx,\n             body,\n             def_id,\n             dead_unwinds: None,\n             entry_sets,\n-            trans_for_block,\n+            apply_trans_for_block,\n         }\n     }\n \n@@ -185,16 +190,18 @@ where\n     }\n \n     /// Computes the fixpoint for this dataflow problem and returns it.\n-    pub fn iterate_to_fixpoint(self) -> Results<'tcx, A> {\n+    pub fn iterate_to_fixpoint(self) -> Results<'tcx, A>\n+    where\n+        A::Domain: DebugWithContext<A>,\n+    {\n         let Engine {\n             analysis,\n-            bits_per_block,\n             body,\n             dead_unwinds,\n             def_id,\n             mut entry_sets,\n             tcx,\n-            trans_for_block,\n+            apply_trans_for_block,\n             ..\n         } = self;\n \n@@ -213,14 +220,14 @@ where\n             }\n         }\n \n-        let mut state = BitSet::new_empty(bits_per_block);\n+        let mut state = analysis.bottom_value(body);\n         while let Some(bb) = dirty_queue.pop() {\n             let bb_data = &body[bb];\n \n             // Apply the block transfer function, using the cached one if it exists.\n-            state.overwrite(&entry_sets[bb]);\n-            match &trans_for_block {\n-                Some(trans_for_block) => trans_for_block[bb].apply(&mut state),\n+            state.clone_from(&entry_sets[bb]);\n+            match &apply_trans_for_block {\n+                Some(apply) => apply(bb, &mut state),\n                 None => A::Direction::apply_effects_in_block(&analysis, &mut state, bb, bb_data),\n             }\n \n@@ -231,8 +238,8 @@ where\n                 dead_unwinds,\n                 &mut state,\n                 (bb, bb_data),\n-                |target: BasicBlock, state: &BitSet<A::Idx>| {\n-                    let set_changed = analysis.join(&mut entry_sets[target], state);\n+                |target: BasicBlock, state: &A::Domain| {\n+                    let set_changed = entry_sets[target].join(state);\n                     if set_changed {\n                         dirty_queue.insert(target);\n                     }\n@@ -242,7 +249,7 @@ where\n \n         let results = Results { analysis, entry_sets };\n \n-        let res = write_graphviz_results(tcx, def_id, &body, &results, trans_for_block);\n+        let res = write_graphviz_results(tcx, def_id, &body, &results);\n         if let Err(e) = res {\n             warn!(\"Failed to write graphviz dataflow results: {}\", e);\n         }\n@@ -260,10 +267,10 @@ fn write_graphviz_results<A>(\n     def_id: DefId,\n     body: &mir::Body<'tcx>,\n     results: &Results<'tcx, A>,\n-    block_transfer_functions: Option<IndexVec<BasicBlock, GenKillSet<A::Idx>>>,\n ) -> std::io::Result<()>\n where\n     A: Analysis<'tcx>,\n+    A::Domain: DebugWithContext<A>,\n {\n     let attrs = match RustcMirAttrs::parse(tcx, def_id) {\n         Ok(attrs) => attrs,\n@@ -290,26 +297,15 @@ where\n         None => return Ok(()),\n     };\n \n-    let bits_per_block = results.analysis.bits_per_block(body);\n-\n-    let mut formatter: Box<dyn graphviz::StateFormatter<'tcx, _>> = match attrs.formatter {\n-        Some(sym::two_phase) => Box::new(graphviz::TwoPhaseDiff::new(bits_per_block)),\n-        Some(sym::gen_kill) => {\n-            if let Some(trans_for_block) = block_transfer_functions {\n-                Box::new(graphviz::BlockTransferFunc::new(body, trans_for_block))\n-            } else {\n-                Box::new(graphviz::SimpleDiff::new(body, &results))\n-            }\n-        }\n-\n-        // Default to the `SimpleDiff` output style.\n-        _ => Box::new(graphviz::SimpleDiff::new(body, &results)),\n+    let style = match attrs.formatter {\n+        Some(sym::two_phase) => graphviz::OutputStyle::BeforeAndAfter,\n+        _ => graphviz::OutputStyle::AfterOnly,\n     };\n \n     debug!(\"printing dataflow results for {:?} to {}\", def_id, path.display());\n     let mut buf = Vec::new();\n \n-    let graphviz = graphviz::Formatter::new(body, def_id, results, &mut *formatter);\n+    let graphviz = graphviz::Formatter::new(body, def_id, results, style);\n     dot::render_opts(&graphviz, &mut buf, &[dot::RenderOption::Monospace])?;\n \n     if let Some(parent) = path.parent() {"}, {"sha": "0140a750544334f0053b097dfc193db55d1f65c8", "filename": "compiler/rustc_mir/src/dataflow/framework/fmt.rs", "status": "added", "additions": 172, "deletions": 0, "changes": 172, "blob_url": "https://github.com/rust-lang/rust/blob/0e2c1281e909ca38479b97962fc9248f75d66412/compiler%2Frustc_mir%2Fsrc%2Fdataflow%2Fframework%2Ffmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e2c1281e909ca38479b97962fc9248f75d66412/compiler%2Frustc_mir%2Fsrc%2Fdataflow%2Fframework%2Ffmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Fdataflow%2Fframework%2Ffmt.rs?ref=0e2c1281e909ca38479b97962fc9248f75d66412", "patch": "@@ -0,0 +1,172 @@\n+//! Custom formatting traits used when outputting Graphviz diagrams with the results of a dataflow\n+//! analysis.\n+\n+use rustc_index::bit_set::{BitSet, HybridBitSet};\n+use rustc_index::vec::Idx;\n+use std::fmt;\n+\n+/// An extension to `fmt::Debug` for data that can be better printed with some auxiliary data `C`.\n+pub trait DebugWithContext<C>: Eq + fmt::Debug {\n+    fn fmt_with(&self, _ctxt: &C, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        fmt::Debug::fmt(self, f)\n+    }\n+\n+    /// Print the difference between `self` and `old`.\n+    ///\n+    /// This should print nothing if `self == old`.\n+    ///\n+    /// `+` and `-` are typically used to indicate differences. However, these characters are\n+    /// fairly common and may be needed to print a types representation. If using them to indicate\n+    /// a diff, prefix them with the \"Unit Separator\"  control character (\u241f  U+001F).\n+    fn fmt_diff_with(&self, old: &Self, ctxt: &C, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        if self == old {\n+            return Ok(());\n+        }\n+\n+        write!(f, \"\\u{001f}+\")?;\n+        self.fmt_with(ctxt, f)?;\n+\n+        if f.alternate() {\n+            write!(f, \"\\n\")?;\n+        } else {\n+            write!(f, \"\\t\")?;\n+        }\n+\n+        write!(f, \"\\u{001f}-\")?;\n+        self.fmt_with(ctxt, f)\n+    }\n+}\n+\n+/// Implements `fmt::Debug` by deferring to `<T as DebugWithContext<C>>::fmt_with`.\n+pub struct DebugWithAdapter<'a, T, C> {\n+    pub this: T,\n+    pub ctxt: &'a C,\n+}\n+\n+impl<T, C> fmt::Debug for DebugWithAdapter<'_, T, C>\n+where\n+    T: DebugWithContext<C>,\n+{\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        self.this.fmt_with(self.ctxt, f)\n+    }\n+}\n+\n+/// Implements `fmt::Debug` by deferring to `<T as DebugWithContext<C>>::fmt_diff_with`.\n+pub struct DebugDiffWithAdapter<'a, T, C> {\n+    pub new: T,\n+    pub old: T,\n+    pub ctxt: &'a C,\n+}\n+\n+impl<T, C> fmt::Debug for DebugDiffWithAdapter<'_, T, C>\n+where\n+    T: DebugWithContext<C>,\n+{\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        self.new.fmt_diff_with(&self.old, self.ctxt, f)\n+    }\n+}\n+\n+// Impls\n+\n+impl<T, C> DebugWithContext<C> for BitSet<T>\n+where\n+    T: Idx + DebugWithContext<C>,\n+{\n+    fn fmt_with(&self, ctxt: &C, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        f.debug_set().entries(self.iter().map(|i| DebugWithAdapter { this: i, ctxt })).finish()\n+    }\n+\n+    fn fmt_diff_with(&self, old: &Self, ctxt: &C, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        let size = self.domain_size();\n+        assert_eq!(size, old.domain_size());\n+\n+        let mut set_in_self = HybridBitSet::new_empty(size);\n+        let mut cleared_in_self = HybridBitSet::new_empty(size);\n+\n+        for i in (0..size).map(T::new) {\n+            match (self.contains(i), old.contains(i)) {\n+                (true, false) => set_in_self.insert(i),\n+                (false, true) => cleared_in_self.insert(i),\n+                _ => continue,\n+            };\n+        }\n+\n+        let mut first = true;\n+        for idx in set_in_self.iter() {\n+            let delim = if first {\n+                \"\\u{001f}+\"\n+            } else if f.alternate() {\n+                \"\\n\\u{001f}+\"\n+            } else {\n+                \", \"\n+            };\n+\n+            write!(f, \"{}\", delim)?;\n+            idx.fmt_with(ctxt, f)?;\n+            first = false;\n+        }\n+\n+        if !f.alternate() {\n+            first = true;\n+            if !set_in_self.is_empty() && !cleared_in_self.is_empty() {\n+                write!(f, \"\\t\")?;\n+            }\n+        }\n+\n+        for idx in cleared_in_self.iter() {\n+            let delim = if first {\n+                \"\\u{001f}-\"\n+            } else if f.alternate() {\n+                \"\\n\\u{001f}-\"\n+            } else {\n+                \", \"\n+            };\n+\n+            write!(f, \"{}\", delim)?;\n+            idx.fmt_with(ctxt, f)?;\n+            first = false;\n+        }\n+\n+        Ok(())\n+    }\n+}\n+\n+impl<T, C> DebugWithContext<C> for &'_ T\n+where\n+    T: DebugWithContext<C>,\n+{\n+    fn fmt_with(&self, ctxt: &C, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        (*self).fmt_with(ctxt, f)\n+    }\n+\n+    fn fmt_diff_with(&self, old: &Self, ctxt: &C, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        (*self).fmt_diff_with(*old, ctxt, f)\n+    }\n+}\n+\n+impl<C> DebugWithContext<C> for rustc_middle::mir::Local {}\n+impl<C> DebugWithContext<C> for crate::dataflow::move_paths::InitIndex {}\n+\n+impl<'tcx, C> DebugWithContext<C> for crate::dataflow::move_paths::MovePathIndex\n+where\n+    C: crate::dataflow::move_paths::HasMoveData<'tcx>,\n+{\n+    fn fmt_with(&self, ctxt: &C, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        write!(f, \"{}\", ctxt.move_data().move_paths[*self])\n+    }\n+}\n+\n+impl<T, C> DebugWithContext<C> for crate::dataflow::lattice::Dual<T>\n+where\n+    T: DebugWithContext<C>,\n+{\n+    fn fmt_with(&self, ctxt: &C, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        (self.0).fmt_with(ctxt, f)\n+    }\n+\n+    fn fmt_diff_with(&self, old: &Self, ctxt: &C, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        (self.0).fmt_diff_with(&old.0, ctxt, f)\n+    }\n+}"}, {"sha": "179c471cf4829fadba91106390e3c9913100cdcf", "filename": "compiler/rustc_mir/src/dataflow/framework/graphviz.rs", "status": "modified", "additions": 229, "deletions": 326, "changes": 555, "blob_url": "https://github.com/rust-lang/rust/blob/0e2c1281e909ca38479b97962fc9248f75d66412/compiler%2Frustc_mir%2Fsrc%2Fdataflow%2Fframework%2Fgraphviz.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e2c1281e909ca38479b97962fc9248f75d66412/compiler%2Frustc_mir%2Fsrc%2Fdataflow%2Fframework%2Fgraphviz.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Fdataflow%2Fframework%2Fgraphviz.rs?ref=0e2c1281e909ca38479b97962fc9248f75d66412", "patch": "@@ -1,26 +1,40 @@\n //! A helpful diagram for debugging dataflow problems.\n \n-use std::cell::RefCell;\n+use std::borrow::Cow;\n use std::{io, ops, str};\n \n+use regex::Regex;\n use rustc_graphviz as dot;\n use rustc_hir::def_id::DefId;\n-use rustc_index::bit_set::{BitSet, HybridBitSet};\n-use rustc_index::vec::{Idx, IndexVec};\n use rustc_middle::mir::{self, BasicBlock, Body, Location};\n \n-use super::{Analysis, Direction, GenKillSet, Results, ResultsRefCursor};\n+use super::fmt::{DebugDiffWithAdapter, DebugWithAdapter, DebugWithContext};\n+use super::{Analysis, Direction, Results, ResultsRefCursor, ResultsVisitor};\n use crate::util::graphviz_safe_def_name;\n \n+#[derive(Clone, Copy, Debug, PartialEq, Eq)]\n+pub enum OutputStyle {\n+    AfterOnly,\n+    BeforeAndAfter,\n+}\n+\n+impl OutputStyle {\n+    fn num_state_columns(&self) -> usize {\n+        match self {\n+            Self::AfterOnly => 1,\n+            Self::BeforeAndAfter => 2,\n+        }\n+    }\n+}\n+\n pub struct Formatter<'a, 'tcx, A>\n where\n     A: Analysis<'tcx>,\n {\n     body: &'a Body<'tcx>,\n     def_id: DefId,\n-\n-    // This must be behind a `RefCell` because `dot::Labeller` takes `&self`.\n-    block_formatter: RefCell<BlockFormatter<'a, 'tcx, A>>,\n+    results: &'a Results<'tcx, A>,\n+    style: OutputStyle,\n }\n \n impl<A> Formatter<'a, 'tcx, A>\n@@ -31,15 +45,9 @@ where\n         body: &'a Body<'tcx>,\n         def_id: DefId,\n         results: &'a Results<'tcx, A>,\n-        state_formatter: &'a mut dyn StateFormatter<'tcx, A>,\n+        style: OutputStyle,\n     ) -> Self {\n-        let block_formatter = BlockFormatter {\n-            bg: Background::Light,\n-            results: ResultsRefCursor::new(body, results),\n-            state_formatter,\n-        };\n-\n-        Formatter { body, def_id, block_formatter: RefCell::new(block_formatter) }\n+        Formatter { body, def_id, results, style }\n     }\n }\n \n@@ -62,6 +70,7 @@ fn dataflow_successors(body: &Body<'tcx>, bb: BasicBlock) -> Vec<CfgEdge> {\n impl<A> dot::Labeller<'_> for Formatter<'a, 'tcx, A>\n where\n     A: Analysis<'tcx>,\n+    A::Domain: DebugWithContext<A>,\n {\n     type Node = BasicBlock;\n     type Edge = CfgEdge;\n@@ -77,7 +86,13 @@ where\n \n     fn node_label(&self, block: &Self::Node) -> dot::LabelText<'_> {\n         let mut label = Vec::new();\n-        self.block_formatter.borrow_mut().write_node_label(&mut label, self.body, *block).unwrap();\n+        let mut fmt = BlockFormatter {\n+            results: ResultsRefCursor::new(self.body, self.results),\n+            style: self.style,\n+            bg: Background::Light,\n+        };\n+\n+        fmt.write_node_label(&mut label, self.body, *block).unwrap();\n         dot::LabelText::html(String::from_utf8(label).unwrap())\n     }\n \n@@ -126,19 +141,16 @@ where\n {\n     results: ResultsRefCursor<'a, 'a, 'tcx, A>,\n     bg: Background,\n-    state_formatter: &'a mut dyn StateFormatter<'tcx, A>,\n+    style: OutputStyle,\n }\n \n impl<A> BlockFormatter<'a, 'tcx, A>\n where\n     A: Analysis<'tcx>,\n+    A::Domain: DebugWithContext<A>,\n {\n     const HEADER_COLOR: &'static str = \"#a0a0a0\";\n \n-    fn num_state_columns(&self) -> usize {\n-        std::cmp::max(1, self.state_formatter.column_names().len())\n-    }\n-\n     fn toggle_background(&mut self) -> Background {\n         let bg = self.bg;\n         self.bg = !bg;\n@@ -187,40 +199,30 @@ where\n         write!(w, r#\"<table{fmt}>\"#, fmt = table_fmt)?;\n \n         // A + B: Block header\n-        if self.state_formatter.column_names().is_empty() {\n-            self.write_block_header_simple(w, block)?;\n-        } else {\n-            self.write_block_header_with_state_columns(w, block)?;\n+        match self.style {\n+            OutputStyle::AfterOnly => self.write_block_header_simple(w, block)?,\n+            OutputStyle::BeforeAndAfter => {\n+                self.write_block_header_with_state_columns(w, block, &[\"BEFORE\", \"AFTER\"])?\n+            }\n         }\n \n         // C: State at start of block\n         self.bg = Background::Light;\n         self.results.seek_to_block_start(block);\n-        let block_entry_state = self.results.get().clone();\n-\n+        let block_start_state = self.results.get().clone();\n         self.write_row_with_full_state(w, \"\", \"(on start)\")?;\n \n-        // D: Statement transfer functions\n-        for (i, statement) in body[block].statements.iter().enumerate() {\n-            let location = Location { block, statement_index: i };\n-            let statement_str = format!(\"{:?}\", statement);\n-            self.write_row_for_location(w, &i.to_string(), &statement_str, location)?;\n-        }\n-\n-        // E: Terminator transfer function\n-        let terminator = body[block].terminator();\n-        let terminator_loc = body.terminator_loc(block);\n-        let mut terminator_str = String::new();\n-        terminator.kind.fmt_head(&mut terminator_str).unwrap();\n-\n-        self.write_row_for_location(w, \"T\", &terminator_str, terminator_loc)?;\n+        // D + E: Statement and terminator transfer functions\n+        self.write_statements_and_terminator(w, body, block)?;\n \n         // F: State at end of block\n \n+        let terminator = body[block].terminator();\n+\n         // Write the full dataflow state immediately after the terminator if it differs from the\n         // state at block entry.\n         self.results.seek_to_block_end(block);\n-        if self.results.get() != &block_entry_state || A::Direction::is_backward() {\n+        if self.results.get() != &block_start_state || A::Direction::is_backward() {\n             let after_terminator_name = match terminator.kind {\n                 mir::TerminatorKind::Call { destination: Some(_), .. } => \"(on unwind)\",\n                 _ => \"(on end)\",\n@@ -229,8 +231,11 @@ where\n             self.write_row_with_full_state(w, \"\", after_terminator_name)?;\n         }\n \n-        // Write any changes caused by terminator-specific effects\n-        let num_state_columns = self.num_state_columns();\n+        // Write any changes caused by terminator-specific effects.\n+        //\n+        // FIXME: These should really be printed as part of each outgoing edge rather than the node\n+        // for the basic block itself. That way, we could display terminator-specific effects for\n+        // backward dataflow analyses as well as effects for `SwitchInt` terminators.\n         match terminator.kind {\n             mir::TerminatorKind::Call {\n                 destination: Some((return_place, _)),\n@@ -239,44 +244,43 @@ where\n                 ..\n             } => {\n                 self.write_row(w, \"\", \"(on successful return)\", |this, w, fmt| {\n-                    write!(\n-                        w,\n-                        r#\"<td balign=\"left\" colspan=\"{colspan}\" {fmt} align=\"left\">\"#,\n-                        colspan = num_state_columns,\n-                        fmt = fmt,\n-                    )?;\n-\n                     let state_on_unwind = this.results.get().clone();\n                     this.results.apply_custom_effect(|analysis, state| {\n                         analysis.apply_call_return_effect(state, block, func, args, return_place);\n                     });\n \n-                    write_diff(w, this.results.analysis(), &state_on_unwind, this.results.get())?;\n-                    write!(w, \"</td>\")\n+                    write!(\n+                        w,\n+                        r#\"<td balign=\"left\" colspan=\"{colspan}\" {fmt} align=\"left\">{diff}</td>\"#,\n+                        colspan = this.style.num_state_columns(),\n+                        fmt = fmt,\n+                        diff = diff_pretty(\n+                            this.results.get(),\n+                            &state_on_unwind,\n+                            this.results.analysis()\n+                        ),\n+                    )\n                 })?;\n             }\n \n             mir::TerminatorKind::Yield { resume, resume_arg, .. } => {\n                 self.write_row(w, \"\", \"(on yield resume)\", |this, w, fmt| {\n-                    write!(\n-                        w,\n-                        r#\"<td balign=\"left\" colspan=\"{colspan}\" {fmt} align=\"left\">\"#,\n-                        colspan = num_state_columns,\n-                        fmt = fmt,\n-                    )?;\n-\n                     let state_on_generator_drop = this.results.get().clone();\n                     this.results.apply_custom_effect(|analysis, state| {\n                         analysis.apply_yield_resume_effect(state, resume, resume_arg);\n                     });\n \n-                    write_diff(\n+                    write!(\n                         w,\n-                        this.results.analysis(),\n-                        &state_on_generator_drop,\n-                        this.results.get(),\n-                    )?;\n-                    write!(w, \"</td>\")\n+                        r#\"<td balign=\"left\" colspan=\"{colspan}\" {fmt} align=\"left\">{diff}</td>\"#,\n+                        colspan = this.style.num_state_columns(),\n+                        fmt = fmt,\n+                        diff = diff_pretty(\n+                            this.results.get(),\n+                            &state_on_generator_drop,\n+                            this.results.analysis()\n+                        ),\n+                    )\n                 })?;\n             }\n \n@@ -322,6 +326,7 @@ where\n         &mut self,\n         w: &mut impl io::Write,\n         block: BasicBlock,\n+        state_column_names: &[&str],\n     ) -> io::Result<()> {\n         //   +------------------------------------+-------------+\n         // A |                bb4                 |    STATE    |\n@@ -330,8 +335,6 @@ where\n         //   +-+----------------------------------+------+------+\n         //   | |              ...                 |      |      |\n \n-        let state_column_names = self.state_formatter.column_names();\n-\n         // A\n         write!(\n             w,\n@@ -357,6 +360,56 @@ where\n         write!(w, \"</tr>\")\n     }\n \n+    fn write_statements_and_terminator(\n+        &mut self,\n+        w: &mut impl io::Write,\n+        body: &'a Body<'tcx>,\n+        block: BasicBlock,\n+    ) -> io::Result<()> {\n+        let diffs = StateDiffCollector::run(body, block, self.results.results(), self.style);\n+\n+        let mut befores = diffs.before.map(|v| v.into_iter());\n+        let mut afters = diffs.after.into_iter();\n+\n+        let next_in_dataflow_order = |it: &mut std::vec::IntoIter<_>| {\n+            if A::Direction::is_forward() { it.next().unwrap() } else { it.next_back().unwrap() }\n+        };\n+\n+        for (i, statement) in body[block].statements.iter().enumerate() {\n+            let statement_str = format!(\"{:?}\", statement);\n+            let index_str = format!(\"{}\", i);\n+\n+            let after = next_in_dataflow_order(&mut afters);\n+            let before = befores.as_mut().map(next_in_dataflow_order);\n+\n+            self.write_row(w, &index_str, &statement_str, |_this, w, fmt| {\n+                if let Some(before) = before {\n+                    write!(w, r#\"<td {fmt} align=\"left\">{diff}</td>\"#, fmt = fmt, diff = before)?;\n+                }\n+\n+                write!(w, r#\"<td {fmt} align=\"left\">{diff}</td>\"#, fmt = fmt, diff = after)\n+            })?;\n+        }\n+\n+        let after = next_in_dataflow_order(&mut afters);\n+        let before = befores.as_mut().map(next_in_dataflow_order);\n+\n+        assert!(afters.is_empty());\n+        assert!(befores.as_ref().map_or(true, ExactSizeIterator::is_empty));\n+\n+        let terminator = body[block].terminator();\n+        let mut terminator_str = String::new();\n+        terminator.kind.fmt_head(&mut terminator_str).unwrap();\n+\n+        self.write_row(w, \"T\", &terminator_str, |_this, w, fmt| {\n+            if let Some(before) = before {\n+                write!(w, r#\"<td {fmt} align=\"left\">{diff}</td>\"#, fmt = fmt, diff = before)?;\n+            }\n+\n+            write!(w, r#\"<td {fmt} align=\"left\">{diff}</td>\"#, fmt = fmt, diff = after)\n+        })\n+    }\n+\n     /// Write a row with the given index and MIR, using the function argument to fill in the\n     /// \"STATE\" column(s).\n     fn write_row<W: io::Write>(\n@@ -397,319 +450,169 @@ where\n             let state = this.results.get();\n             let analysis = this.results.analysis();\n \n+            // FIXME: The full state vector can be quite long. It would be nice to split on commas\n+            // and use some text wrapping algorithm.\n             write!(\n                 w,\n-                r#\"<td colspan=\"{colspan}\" {fmt} align=\"left\">{{\"#,\n-                colspan = this.num_state_columns(),\n+                r#\"<td colspan=\"{colspan}\" {fmt} align=\"left\">{state}</td>\"#,\n+                colspan = this.style.num_state_columns(),\n                 fmt = fmt,\n-            )?;\n-            pretty_print_state_elems(w, analysis, state.iter(), \", \", LIMIT_30_ALIGN_1)?;\n-            write!(w, \"}}</td>\")\n-        })\n-    }\n-\n-    fn write_row_for_location(\n-        &mut self,\n-        w: &mut impl io::Write,\n-        i: &str,\n-        mir: &str,\n-        location: Location,\n-    ) -> io::Result<()> {\n-        self.write_row(w, i, mir, |this, w, fmt| {\n-            this.state_formatter.write_state_for_location(w, fmt, &mut this.results, location)\n+                state = format!(\"{:?}\", DebugWithAdapter { this: state, ctxt: analysis }),\n+            )\n         })\n     }\n }\n \n-/// Controls what gets printed under the `STATE` header.\n-pub trait StateFormatter<'tcx, A>\n+struct StateDiffCollector<'a, 'tcx, A>\n where\n     A: Analysis<'tcx>,\n {\n-    /// The columns that will get printed under `STATE`.\n-    fn column_names(&self) -> &[&str];\n-\n-    fn write_state_for_location(\n-        &mut self,\n-        w: &mut dyn io::Write,\n-        fmt: &str,\n-        results: &mut ResultsRefCursor<'_, '_, 'tcx, A>,\n-        location: Location,\n-    ) -> io::Result<()>;\n+    analysis: &'a A,\n+    prev_state: A::Domain,\n+    before: Option<Vec<String>>,\n+    after: Vec<String>,\n }\n \n-/// Prints a single column containing the state vector immediately *after* each statement.\n-pub struct SimpleDiff<'a, 'tcx, A>\n+impl<A> StateDiffCollector<'a, 'tcx, A>\n where\n     A: Analysis<'tcx>,\n+    A::Domain: DebugWithContext<A>,\n {\n-    prev_state: ResultsRefCursor<'a, 'a, 'tcx, A>,\n-}\n+    fn run(\n+        body: &'a mir::Body<'tcx>,\n+        block: BasicBlock,\n+        results: &'a Results<'tcx, A>,\n+        style: OutputStyle,\n+    ) -> Self {\n+        let mut collector = StateDiffCollector {\n+            analysis: &results.analysis,\n+            prev_state: results.analysis.bottom_value(body),\n+            after: vec![],\n+            before: (style == OutputStyle::BeforeAndAfter).then_some(vec![]),\n+        };\n \n-impl<A> SimpleDiff<'a, 'tcx, A>\n-where\n-    A: Analysis<'tcx>,\n-{\n-    pub fn new(body: &'a Body<'tcx>, results: &'a Results<'tcx, A>) -> Self {\n-        SimpleDiff { prev_state: ResultsRefCursor::new(body, results) }\n+        results.visit_with(body, std::iter::once(block), &mut collector);\n+        collector\n     }\n }\n \n-impl<A> StateFormatter<'tcx, A> for SimpleDiff<'_, 'tcx, A>\n+impl<A> ResultsVisitor<'a, 'tcx> for StateDiffCollector<'a, 'tcx, A>\n where\n     A: Analysis<'tcx>,\n+    A::Domain: DebugWithContext<A>,\n {\n-    fn column_names(&self) -> &[&str] {\n-        &[]\n-    }\n+    type FlowState = A::Domain;\n \n-    fn write_state_for_location(\n+    fn visit_block_start(\n         &mut self,\n-        mut w: &mut dyn io::Write,\n-        fmt: &str,\n-        results: &mut ResultsRefCursor<'_, '_, 'tcx, A>,\n-        location: Location,\n-    ) -> io::Result<()> {\n+        state: &Self::FlowState,\n+        _block_data: &'mir mir::BasicBlockData<'tcx>,\n+        _block: BasicBlock,\n+    ) {\n         if A::Direction::is_forward() {\n-            if location.statement_index == 0 {\n-                self.prev_state.seek_to_block_start(location.block);\n-            } else {\n-                self.prev_state.seek_after_primary_effect(Location {\n-                    statement_index: location.statement_index - 1,\n-                    ..location\n-                });\n-            }\n-        } else {\n-            if location == results.body().terminator_loc(location.block) {\n-                self.prev_state.seek_to_block_end(location.block);\n-            } else {\n-                self.prev_state.seek_after_primary_effect(location.successor_within_block());\n-            }\n+            self.prev_state.clone_from(state);\n         }\n-\n-        write!(w, r#\"<td {fmt} balign=\"left\" align=\"left\">\"#, fmt = fmt)?;\n-        results.seek_after_primary_effect(location);\n-        let curr_state = results.get();\n-        write_diff(&mut w, results.analysis(), self.prev_state.get(), curr_state)?;\n-        write!(w, \"</td>\")\n     }\n-}\n \n-/// Prints two state columns, one containing only the \"before\" effect of each statement and one\n-/// containing the full effect.\n-pub struct TwoPhaseDiff<T: Idx> {\n-    prev_state: BitSet<T>,\n-    prev_loc: Location,\n-}\n+    fn visit_block_end(\n+        &mut self,\n+        state: &Self::FlowState,\n+        _block_data: &'mir mir::BasicBlockData<'tcx>,\n+        _block: BasicBlock,\n+    ) {\n+        if A::Direction::is_backward() {\n+            self.prev_state.clone_from(state);\n+        }\n+    }\n \n-impl<T: Idx> TwoPhaseDiff<T> {\n-    pub fn new(bits_per_block: usize) -> Self {\n-        TwoPhaseDiff { prev_state: BitSet::new_empty(bits_per_block), prev_loc: Location::START }\n+    fn visit_statement_before_primary_effect(\n+        &mut self,\n+        state: &Self::FlowState,\n+        _statement: &'mir mir::Statement<'tcx>,\n+        _location: Location,\n+    ) {\n+        if let Some(before) = self.before.as_mut() {\n+            before.push(diff_pretty(state, &self.prev_state, self.analysis));\n+            self.prev_state.clone_from(state)\n+        }\n     }\n-}\n \n-impl<A> StateFormatter<'tcx, A> for TwoPhaseDiff<A::Idx>\n-where\n-    A: Analysis<'tcx>,\n-{\n-    fn column_names(&self) -> &[&str] {\n-        &[\"BEFORE\", \" AFTER\"]\n+    fn visit_statement_after_primary_effect(\n+        &mut self,\n+        state: &Self::FlowState,\n+        _statement: &'mir mir::Statement<'tcx>,\n+        _location: Location,\n+    ) {\n+        self.after.push(diff_pretty(state, &self.prev_state, self.analysis));\n+        self.prev_state.clone_from(state)\n     }\n \n-    fn write_state_for_location(\n+    fn visit_terminator_before_primary_effect(\n         &mut self,\n-        mut w: &mut dyn io::Write,\n-        fmt: &str,\n-        results: &mut ResultsRefCursor<'_, '_, 'tcx, A>,\n-        location: Location,\n-    ) -> io::Result<()> {\n-        if location.statement_index == 0 {\n-            results.seek_to_block_entry(location.block);\n-            self.prev_state.overwrite(results.get());\n-        } else {\n-            // Ensure that we are visiting statements in order, so `prev_state` is correct.\n-            assert_eq!(self.prev_loc.successor_within_block(), location);\n+        state: &Self::FlowState,\n+        _terminator: &'mir mir::Terminator<'tcx>,\n+        _location: Location,\n+    ) {\n+        if let Some(before) = self.before.as_mut() {\n+            before.push(diff_pretty(state, &self.prev_state, self.analysis));\n+            self.prev_state.clone_from(state)\n         }\n-\n-        self.prev_loc = location;\n-\n-        // Before\n-\n-        write!(w, r#\"<td {fmt} align=\"left\">\"#, fmt = fmt)?;\n-        results.seek_before_primary_effect(location);\n-        let curr_state = results.get();\n-        write_diff(&mut w, results.analysis(), &self.prev_state, curr_state)?;\n-        self.prev_state.overwrite(curr_state);\n-        write!(w, \"</td>\")?;\n-\n-        // After\n-\n-        write!(w, r#\"<td {fmt} align=\"left\">\"#, fmt = fmt)?;\n-        results.seek_after_primary_effect(location);\n-        let curr_state = results.get();\n-        write_diff(&mut w, results.analysis(), &self.prev_state, curr_state)?;\n-        self.prev_state.overwrite(curr_state);\n-        write!(w, \"</td>\")\n     }\n-}\n-\n-/// Prints the gen/kill set for the entire block.\n-pub struct BlockTransferFunc<'a, 'tcx, T: Idx> {\n-    body: &'a mir::Body<'tcx>,\n-    trans_for_block: IndexVec<BasicBlock, GenKillSet<T>>,\n-}\n \n-impl<T: Idx> BlockTransferFunc<'mir, 'tcx, T> {\n-    pub fn new(\n-        body: &'mir mir::Body<'tcx>,\n-        trans_for_block: IndexVec<BasicBlock, GenKillSet<T>>,\n-    ) -> Self {\n-        BlockTransferFunc { body, trans_for_block }\n+    fn visit_terminator_after_primary_effect(\n+        &mut self,\n+        state: &Self::FlowState,\n+        _terminator: &'mir mir::Terminator<'tcx>,\n+        _location: Location,\n+    ) {\n+        self.after.push(diff_pretty(state, &self.prev_state, self.analysis));\n+        self.prev_state.clone_from(state)\n     }\n }\n \n-impl<A> StateFormatter<'tcx, A> for BlockTransferFunc<'mir, 'tcx, A::Idx>\n+fn diff_pretty<T, C>(new: T, old: T, ctxt: &C) -> String\n where\n-    A: Analysis<'tcx>,\n+    T: DebugWithContext<C>,\n {\n-    fn column_names(&self) -> &[&str] {\n-        &[\"GEN\", \"KILL\"]\n+    if new == old {\n+        return String::new();\n     }\n \n-    fn write_state_for_location(\n-        &mut self,\n-        mut w: &mut dyn io::Write,\n-        fmt: &str,\n-        results: &mut ResultsRefCursor<'_, '_, 'tcx, A>,\n-        location: Location,\n-    ) -> io::Result<()> {\n-        // Only print a single row.\n-        if location.statement_index != 0 {\n-            return Ok(());\n-        }\n+    let re = Regex::new(\"\\u{001f}([+-])\").unwrap();\n \n-        let block_trans = &self.trans_for_block[location.block];\n-        let rowspan = self.body.basic_blocks()[location.block].statements.len();\n+    let raw_diff = format!(\"{:#?}\", DebugDiffWithAdapter { new, old, ctxt });\n \n-        for set in &[&block_trans.gen, &block_trans.kill] {\n-            write!(\n-                w,\n-                r#\"<td {fmt} rowspan=\"{rowspan}\" balign=\"left\" align=\"left\">\"#,\n-                fmt = fmt,\n-                rowspan = rowspan\n-            )?;\n+    // Replace newlines in the `Debug` output with `<br/>`\n+    let raw_diff = raw_diff.replace('\\n', r#\"<br align=\"left\"/>\"#);\n \n-            pretty_print_state_elems(&mut w, results.analysis(), set.iter(), BR_LEFT, None)?;\n-            write!(w, \"</td>\")?;\n+    let mut inside_font_tag = false;\n+    let html_diff = re.replace_all(&raw_diff, |captures: &regex::Captures<'_>| {\n+        let mut ret = String::new();\n+        if inside_font_tag {\n+            ret.push_str(r#\"</font>\"#);\n         }\n \n-        Ok(())\n-    }\n-}\n-\n-/// Writes two lines, one containing the added bits and one the removed bits.\n-fn write_diff<A: Analysis<'tcx>>(\n-    w: &mut impl io::Write,\n-    analysis: &A,\n-    from: &BitSet<A::Idx>,\n-    to: &BitSet<A::Idx>,\n-) -> io::Result<()> {\n-    assert_eq!(from.domain_size(), to.domain_size());\n-    let len = from.domain_size();\n-\n-    let mut set = HybridBitSet::new_empty(len);\n-    let mut clear = HybridBitSet::new_empty(len);\n-\n-    // FIXME: Implement a lazy iterator over the symmetric difference of two bitsets.\n-    for i in (0..len).map(A::Idx::new) {\n-        match (from.contains(i), to.contains(i)) {\n-            (false, true) => set.insert(i),\n-            (true, false) => clear.insert(i),\n-            _ => continue,\n+        let tag = match &captures[1] {\n+            \"+\" => r#\"<font color=\"darkgreen\">+\"#,\n+            \"-\" => r#\"<font color=\"red\">-\"#,\n+            _ => unreachable!(),\n         };\n-    }\n-\n-    if !set.is_empty() {\n-        write!(w, r#\"<font color=\"darkgreen\">+\"#)?;\n-        pretty_print_state_elems(w, analysis, set.iter(), \", \", LIMIT_30_ALIGN_1)?;\n-        write!(w, r#\"</font>\"#)?;\n-    }\n-\n-    if !set.is_empty() && !clear.is_empty() {\n-        write!(w, \"{}\", BR_LEFT)?;\n-    }\n-\n-    if !clear.is_empty() {\n-        write!(w, r#\"<font color=\"red\">-\"#)?;\n-        pretty_print_state_elems(w, analysis, clear.iter(), \", \", LIMIT_30_ALIGN_1)?;\n-        write!(w, r#\"</font>\"#)?;\n-    }\n-\n-    Ok(())\n-}\n \n-const BR_LEFT: &str = r#\"<br align=\"left\"/>\"#;\n-const BR_LEFT_SPACE: &str = r#\"<br align=\"left\"/> \"#;\n+        inside_font_tag = true;\n+        ret.push_str(tag);\n+        ret\n+    });\n \n-/// Line break policy that breaks at 40 characters and starts the next line with a single space.\n-const LIMIT_30_ALIGN_1: Option<LineBreak> = Some(LineBreak { sequence: BR_LEFT_SPACE, limit: 30 });\n-\n-struct LineBreak {\n-    sequence: &'static str,\n-    limit: usize,\n-}\n-\n-/// Formats each `elem` using the pretty printer provided by `analysis` into a list with the given\n-/// separator (`sep`).\n-///\n-/// Optionally, it will break lines using the given character sequence (usually `<br/>`) and\n-/// character limit.\n-fn pretty_print_state_elems<A>(\n-    w: &mut impl io::Write,\n-    analysis: &A,\n-    elems: impl Iterator<Item = A::Idx>,\n-    sep: &str,\n-    line_break: Option<LineBreak>,\n-) -> io::Result<bool>\n-where\n-    A: Analysis<'tcx>,\n-{\n-    let sep_width = sep.chars().count();\n-\n-    let mut buf = Vec::new();\n-\n-    let mut first = true;\n-    let mut curr_line_width = 0;\n-    let mut line_break_inserted = false;\n-\n-    for idx in elems {\n-        buf.clear();\n-        analysis.pretty_print_idx(&mut buf, idx)?;\n-        let idx_str =\n-            str::from_utf8(&buf).expect(\"Output of `pretty_print_idx` must be valid UTF-8\");\n-        let escaped = dot::escape_html(idx_str);\n-        let escaped_width = escaped.chars().count();\n-\n-        if first {\n-            first = false;\n-        } else {\n-            write!(w, \"{}\", sep)?;\n-            curr_line_width += sep_width;\n-\n-            if let Some(line_break) = &line_break {\n-                if curr_line_width + sep_width + escaped_width > line_break.limit {\n-                    write!(w, \"{}\", line_break.sequence)?;\n-                    line_break_inserted = true;\n-                    curr_line_width = 0;\n-                }\n-            }\n-        }\n+    let mut html_diff = match html_diff {\n+        Cow::Borrowed(_) => return raw_diff,\n+        Cow::Owned(s) => s,\n+    };\n \n-        write!(w, \"{}\", escaped)?;\n-        curr_line_width += escaped_width;\n+    if inside_font_tag {\n+        html_diff.push_str(\"</font>\");\n     }\n \n-    Ok(line_break_inserted)\n+    html_diff\n }\n \n /// The background color used for zebra-striping the table."}, {"sha": "e7ef9267db5e5ed9e74a12f5ad849f86ae239a76", "filename": "compiler/rustc_mir/src/dataflow/framework/lattice.rs", "status": "added", "additions": 230, "deletions": 0, "changes": 230, "blob_url": "https://github.com/rust-lang/rust/blob/0e2c1281e909ca38479b97962fc9248f75d66412/compiler%2Frustc_mir%2Fsrc%2Fdataflow%2Fframework%2Flattice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e2c1281e909ca38479b97962fc9248f75d66412/compiler%2Frustc_mir%2Fsrc%2Fdataflow%2Fframework%2Flattice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Fdataflow%2Fframework%2Flattice.rs?ref=0e2c1281e909ca38479b97962fc9248f75d66412", "patch": "@@ -0,0 +1,230 @@\n+//! Traits used to represent [lattices] for use as the domain of a dataflow analysis.\n+//!\n+//! # Overview\n+//!\n+//! The most common lattice is a powerset of some set `S`, ordered by [set inclusion]. The [Hasse\n+//! diagram] for the powerset of a set with two elements (`X` and `Y`) is shown below. Note that\n+//! distinct elements at the same height in a Hasse diagram (e.g. `{X}` and `{Y}`) are\n+//! *incomparable*, not equal.\n+//!\n+//! ```text\n+//!      {X, Y}    <- top\n+//!       /  \\\n+//!    {X}    {Y}\n+//!       \\  /\n+//!        {}      <- bottom\n+//!\n+//! ```\n+//!\n+//! The defining characteristic of a lattice\u2014the one that differentiates it from a [partially\n+//! ordered set][poset]\u2014is the existence of a *unique* least upper and greatest lower bound for\n+//! every pair of elements. The lattice join operator (`\u2228`) returns the least upper bound, and the\n+//! lattice meet operator (`\u2227`) returns the greatest lower bound. Types that implement one operator\n+//! but not the other are known as semilattices. Dataflow analysis only uses the join operator and\n+//! will work with any join-semilattice, but both should be specified when possible.\n+//!\n+//! ## `PartialOrd`\n+//!\n+//! Given that they represent partially ordered sets, you may be surprised that [`JoinSemiLattice`]\n+//! and [`MeetSemiLattice`] do not have [`PartialOrd`][std::cmp::PartialOrd] as a supertrait. This\n+//! is because most standard library types use lexicographic ordering instead of set inclusion for\n+//! their `PartialOrd` impl. Since we do not actually need to compare lattice elements to run a\n+//! dataflow analysis, there's no need for a newtype wrapper with a custom `PartialOrd` impl. The\n+//! only benefit would be the ability to check that the least upper (or greatest lower) bound\n+//! returned by the lattice join (or meet) operator was in fact greater (or lower) than the inputs.\n+//!\n+//! [lattices]: https://en.wikipedia.org/wiki/Lattice_(order)\n+//! [set inclusion]: https://en.wikipedia.org/wiki/Subset\n+//! [Hasse diagram]: https://en.wikipedia.org/wiki/Hasse_diagram\n+//! [poset]: https://en.wikipedia.org/wiki/Partially_ordered_set\n+\n+use rustc_index::bit_set::BitSet;\n+use rustc_index::vec::{Idx, IndexVec};\n+\n+/// A [partially ordered set][poset] that has a [least upper bound][lub] for any pair of elements\n+/// in the set.\n+///\n+/// [lub]: https://en.wikipedia.org/wiki/Infimum_and_supremum\n+/// [poset]: https://en.wikipedia.org/wiki/Partially_ordered_set\n+pub trait JoinSemiLattice: Eq {\n+    /// Computes the least upper bound of two elements, storing the result in `self` and returning\n+    /// `true` if `self` has changed.\n+    ///\n+    /// The lattice join operator is abbreviated as `\u2228`.\n+    fn join(&mut self, other: &Self) -> bool;\n+}\n+\n+/// A [partially ordered set][poset] that has a [greatest lower bound][glb] for any pair of\n+/// elements in the set.\n+///\n+/// Dataflow analyses only require that their domains implement [`JoinSemiLattice`], not\n+/// `MeetSemiLattice`. However, types that will be used as dataflow domains should implement both\n+/// so that they can be used with [`Dual`].\n+///\n+/// [glb]: https://en.wikipedia.org/wiki/Infimum_and_supremum\n+/// [poset]: https://en.wikipedia.org/wiki/Partially_ordered_set\n+pub trait MeetSemiLattice: Eq {\n+    /// Computes the greatest lower bound of two elements, storing the result in `self` and\n+    /// returning `true` if `self` has changed.\n+    ///\n+    /// The lattice meet operator is abbreviated as `\u2227`.\n+    fn meet(&mut self, other: &Self) -> bool;\n+}\n+\n+/// A `bool` is a \"two-point\" lattice with `true` as the top element and `false` as the bottom:\n+///\n+/// ```text\n+///      true\n+///        |\n+///      false\n+/// ```\n+impl JoinSemiLattice for bool {\n+    fn join(&mut self, other: &Self) -> bool {\n+        if let (false, true) = (*self, *other) {\n+            *self = true;\n+            return true;\n+        }\n+\n+        false\n+    }\n+}\n+\n+impl MeetSemiLattice for bool {\n+    fn meet(&mut self, other: &Self) -> bool {\n+        if let (true, false) = (*self, *other) {\n+            *self = false;\n+            return true;\n+        }\n+\n+        false\n+    }\n+}\n+\n+/// A tuple (or list) of lattices is itself a lattice whose least upper bound is the concatenation\n+/// of the least upper bounds of each element of the tuple (or list).\n+///\n+/// In other words:\n+///     (A\u2080, A\u2081, ..., A\u2099) \u2228 (B\u2080, B\u2081, ..., B\u2099) = (A\u2080\u2228B\u2080, A\u2081\u2228B\u2081, ..., A\u2099\u2228B\u2099)\n+impl<I: Idx, T: JoinSemiLattice> JoinSemiLattice for IndexVec<I, T> {\n+    fn join(&mut self, other: &Self) -> bool {\n+        assert_eq!(self.len(), other.len());\n+\n+        let mut changed = false;\n+        for (a, b) in self.iter_mut().zip(other.iter()) {\n+            changed |= a.join(b);\n+        }\n+        changed\n+    }\n+}\n+\n+impl<I: Idx, T: MeetSemiLattice> MeetSemiLattice for IndexVec<I, T> {\n+    fn meet(&mut self, other: &Self) -> bool {\n+        assert_eq!(self.len(), other.len());\n+\n+        let mut changed = false;\n+        for (a, b) in self.iter_mut().zip(other.iter()) {\n+            changed |= a.meet(b);\n+        }\n+        changed\n+    }\n+}\n+\n+/// A `BitSet` represents the lattice formed by the powerset of all possible values of\n+/// the index type `T` ordered by inclusion. Equivalently, it is a tuple of \"two-point\" lattices,\n+/// one for each possible value of `T`.\n+impl<T: Idx> JoinSemiLattice for BitSet<T> {\n+    fn join(&mut self, other: &Self) -> bool {\n+        self.union(other)\n+    }\n+}\n+\n+impl<T: Idx> MeetSemiLattice for BitSet<T> {\n+    fn meet(&mut self, other: &Self) -> bool {\n+        self.intersect(other)\n+    }\n+}\n+\n+/// The counterpart of a given semilattice `T` using the [inverse order].\n+///\n+/// The dual of a join-semilattice is a meet-semilattice and vice versa. For example, the dual of a\n+/// powerset has the empty set as its top element and the full set as its bottom element and uses\n+/// set *intersection* as its join operator.\n+///\n+/// [inverse order]: https://en.wikipedia.org/wiki/Duality_(order_theory)\n+#[derive(Clone, Copy, Debug, PartialEq, Eq)]\n+pub struct Dual<T>(pub T);\n+\n+impl<T> std::borrow::Borrow<T> for Dual<T> {\n+    fn borrow(&self) -> &T {\n+        &self.0\n+    }\n+}\n+\n+impl<T> std::borrow::BorrowMut<T> for Dual<T> {\n+    fn borrow_mut(&mut self) -> &mut T {\n+        &mut self.0\n+    }\n+}\n+\n+impl<T: MeetSemiLattice> JoinSemiLattice for Dual<T> {\n+    fn join(&mut self, other: &Self) -> bool {\n+        self.0.meet(&other.0)\n+    }\n+}\n+\n+impl<T: JoinSemiLattice> MeetSemiLattice for Dual<T> {\n+    fn meet(&mut self, other: &Self) -> bool {\n+        self.0.join(&other.0)\n+    }\n+}\n+\n+/// Extends a type `T` with top and bottom elements to make it a partially ordered set in which no\n+/// value of `T` is comparable with any other. A flat set has the following [Hasse diagram]:\n+///\n+/// ```text\n+///         top\n+///       / /  \\ \\\n+/// all possible values of `T`\n+///       \\ \\  / /\n+///        bottom\n+/// ```\n+///\n+/// [Hasse diagram]: https://en.wikipedia.org/wiki/Hasse_diagram\n+#[derive(Clone, Copy, Debug, PartialEq, Eq)]\n+pub enum FlatSet<T> {\n+    Bottom,\n+    Elem(T),\n+    Top,\n+}\n+\n+impl<T: Clone + Eq> JoinSemiLattice for FlatSet<T> {\n+    fn join(&mut self, other: &Self) -> bool {\n+        let result = match (&*self, other) {\n+            (Self::Top, _) | (_, Self::Bottom) => return false,\n+            (Self::Elem(a), Self::Elem(b)) if a == b => return false,\n+\n+            (Self::Bottom, Self::Elem(x)) => Self::Elem(x.clone()),\n+\n+            _ => Self::Top,\n+        };\n+\n+        *self = result;\n+        true\n+    }\n+}\n+\n+impl<T: Clone + Eq> MeetSemiLattice for FlatSet<T> {\n+    fn meet(&mut self, other: &Self) -> bool {\n+        let result = match (&*self, other) {\n+            (Self::Bottom, _) | (_, Self::Top) => return false,\n+            (Self::Elem(ref a), Self::Elem(ref b)) if a == b => return false,\n+\n+            (Self::Top, Self::Elem(ref x)) => Self::Elem(x.clone()),\n+\n+            _ => Self::Bottom,\n+        };\n+\n+        *self = result;\n+        true\n+    }\n+}"}, {"sha": "eefa1395a621b10f888cf36a019b4912c1a34f89", "filename": "compiler/rustc_mir/src/dataflow/framework/mod.rs", "status": "modified", "additions": 57, "deletions": 78, "changes": 135, "blob_url": "https://github.com/rust-lang/rust/blob/0e2c1281e909ca38479b97962fc9248f75d66412/compiler%2Frustc_mir%2Fsrc%2Fdataflow%2Fframework%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e2c1281e909ca38479b97962fc9248f75d66412/compiler%2Frustc_mir%2Fsrc%2Fdataflow%2Fframework%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Fdataflow%2Fframework%2Fmod.rs?ref=0e2c1281e909ca38479b97962fc9248f75d66412", "patch": "@@ -30,8 +30,8 @@\n //!\n //! [gen-kill]: https://en.wikipedia.org/wiki/Data-flow_analysis#Bit_vector_problems\n \n+use std::borrow::BorrowMut;\n use std::cmp::Ordering;\n-use std::io;\n \n use rustc_hir::def_id::DefId;\n use rustc_index::bit_set::{BitSet, HybridBitSet};\n@@ -43,69 +43,27 @@ use rustc_target::abi::VariantIdx;\n mod cursor;\n mod direction;\n mod engine;\n+pub mod fmt;\n mod graphviz;\n+pub mod lattice;\n mod visitor;\n \n pub use self::cursor::{ResultsCursor, ResultsRefCursor};\n pub use self::direction::{Backward, Direction, Forward};\n pub use self::engine::{Engine, Results};\n+pub use self::lattice::{JoinSemiLattice, MeetSemiLattice};\n pub use self::visitor::{visit_results, ResultsVisitor};\n pub use self::visitor::{BorrowckFlowState, BorrowckResults};\n \n-/// Parameterization for the precise form of data flow that is used.\n-///\n-/// `BottomValue` determines whether the initial entry set for each basic block is empty or full.\n-/// This also determines the semantics of the lattice `join` operator used to merge dataflow\n-/// results, since dataflow works by starting at the bottom and moving monotonically to a fixed\n-/// point.\n-///\n-/// This means, for propagation across the graph, that you either want to start at all-zeroes and\n-/// then use Union as your merge when propagating, or you start at all-ones and then use Intersect\n-/// as your merge when propagating.\n-pub trait BottomValue {\n-    /// Specifies the initial value for each bit in the entry set for each basic block.\n-    const BOTTOM_VALUE: bool;\n-\n-    /// Merges `in_set` into `inout_set`, returning `true` if `inout_set` changed.\n-    ///\n-    /// It is almost certainly wrong to override this, since it automatically applies\n-    /// * `inout_set & in_set` if `BOTTOM_VALUE == true`\n-    /// * `inout_set | in_set` if `BOTTOM_VALUE == false`\n-    ///\n-    /// This means that if a bit is not `BOTTOM_VALUE`, it is propagated into all target blocks.\n-    /// For clarity, the above statement again from a different perspective:\n-    /// A bit in the block's entry set is `!BOTTOM_VALUE` if *any* predecessor block's bit value is\n-    /// `!BOTTOM_VALUE`.\n-    ///\n-    /// There are situations where you want the opposite behaviour: propagate only if *all*\n-    /// predecessor blocks's value is `!BOTTOM_VALUE`.\n-    /// E.g. if you want to know whether a bit is *definitely* set at a specific location. This\n-    /// means that all code paths leading to the location must have set the bit, instead of any\n-    /// code path leading there.\n-    ///\n-    /// If you want this kind of \"definitely set\" analysis, you need to\n-    /// 1. Invert `BOTTOM_VALUE`\n-    /// 2. Reset the `entry_set` in `start_block_effect` to `!BOTTOM_VALUE`\n-    /// 3. Override `join` to do the opposite from what it's doing now.\n-    #[inline]\n-    fn join<T: Idx>(&self, inout_set: &mut BitSet<T>, in_set: &BitSet<T>) -> bool {\n-        if !Self::BOTTOM_VALUE { inout_set.union(in_set) } else { inout_set.intersect(in_set) }\n-    }\n-}\n-\n /// Define the domain of a dataflow problem.\n ///\n-/// This trait specifies the lattice on which this analysis operates. For now, this must be a\n-/// powerset of values of type `Idx`. The elements of this lattice are represented with a `BitSet`\n-/// and referred to as the state vector.\n-///\n-/// This trait also defines the initial value for the dataflow state upon entry to the\n-/// `START_BLOCK`, as well as some names used to refer to this analysis when debugging.\n-pub trait AnalysisDomain<'tcx>: BottomValue {\n-    /// The type of the elements in the state vector.\n-    type Idx: Idx;\n+/// This trait specifies the lattice on which this analysis operates (the domain) as well as its\n+/// initial value at the entry point of each basic block.\n+pub trait AnalysisDomain<'tcx> {\n+    /// The type that holds the dataflow state at any given point in the program.\n+    type Domain: Clone + JoinSemiLattice;\n \n-    /// The direction of this analyis. Either `Forward` or `Backward`.\n+    /// The direction of this analysis. Either `Forward` or `Backward`.\n     type Direction: Direction = Forward;\n \n     /// A descriptive name for this analysis. Used only for debugging.\n@@ -114,32 +72,41 @@ pub trait AnalysisDomain<'tcx>: BottomValue {\n     /// suitable as part of a filename.\n     const NAME: &'static str;\n \n-    /// The size of the state vector.\n-    fn bits_per_block(&self, body: &mir::Body<'tcx>) -> usize;\n+    /// The initial value of the dataflow state upon entry to each basic block.\n+    fn bottom_value(&self, body: &mir::Body<'tcx>) -> Self::Domain;\n \n-    /// Mutates the entry set of the `START_BLOCK` to contain the initial state for dataflow\n-    /// analysis.\n+    /// Mutates the initial value of the dataflow state upon entry to the `START_BLOCK`.\n     ///\n     /// For backward analyses, initial state besides the bottom value is not yet supported. Trying\n     /// to mutate the initial state will result in a panic.\n     //\n     // FIXME: For backward dataflow analyses, the initial state should be applied to every basic\n     // block where control flow could exit the MIR body (e.g., those terminated with `return` or\n     // `resume`). It's not obvious how to handle `yield` points in generators, however.\n-    fn initialize_start_block(&self, body: &mir::Body<'tcx>, state: &mut BitSet<Self::Idx>);\n-\n-    /// Prints an element in the state vector for debugging.\n-    fn pretty_print_idx(&self, w: &mut impl io::Write, idx: Self::Idx) -> io::Result<()> {\n-        write!(w, \"{:?}\", idx)\n-    }\n+    fn initialize_start_block(&self, body: &mir::Body<'tcx>, state: &mut Self::Domain);\n }\n \n /// A dataflow problem with an arbitrarily complex transfer function.\n+///\n+/// # Convergence\n+///\n+/// When implementing this trait directly (not via [`GenKillAnalysis`]), it's possible to choose a\n+/// transfer function such that the analysis does not reach fixpoint. To guarantee convergence,\n+/// your transfer functions must maintain the following invariant:\n+///\n+/// > If the dataflow state **before** some point in the program changes to be greater\n+/// than the prior state **before** that point, the dataflow state **after** that point must\n+/// also change to be greater than the prior state **after** that point.\n+///\n+/// This invariant guarantees that the dataflow state at a given point in the program increases\n+/// monotonically until fixpoint is reached. Note that this monotonicity requirement only applies\n+/// to the same point in the program at different points in time. The dataflow state at a given\n+/// point in the program may or may not be greater than the state at any preceding point.\n pub trait Analysis<'tcx>: AnalysisDomain<'tcx> {\n     /// Updates the current dataflow state with the effect of evaluating a statement.\n     fn apply_statement_effect(\n         &self,\n-        state: &mut BitSet<Self::Idx>,\n+        state: &mut Self::Domain,\n         statement: &mir::Statement<'tcx>,\n         location: Location,\n     );\n@@ -152,7 +119,7 @@ pub trait Analysis<'tcx>: AnalysisDomain<'tcx> {\n     /// analyses should not implement this without implementing `apply_statement_effect`.\n     fn apply_before_statement_effect(\n         &self,\n-        _state: &mut BitSet<Self::Idx>,\n+        _state: &mut Self::Domain,\n         _statement: &mir::Statement<'tcx>,\n         _location: Location,\n     ) {\n@@ -166,7 +133,7 @@ pub trait Analysis<'tcx>: AnalysisDomain<'tcx> {\n     /// initialized here.\n     fn apply_terminator_effect(\n         &self,\n-        state: &mut BitSet<Self::Idx>,\n+        state: &mut Self::Domain,\n         terminator: &mir::Terminator<'tcx>,\n         location: Location,\n     );\n@@ -179,7 +146,7 @@ pub trait Analysis<'tcx>: AnalysisDomain<'tcx> {\n     /// analyses should not implement this without implementing `apply_terminator_effect`.\n     fn apply_before_terminator_effect(\n         &self,\n-        _state: &mut BitSet<Self::Idx>,\n+        _state: &mut Self::Domain,\n         _terminator: &mir::Terminator<'tcx>,\n         _location: Location,\n     ) {\n@@ -192,7 +159,7 @@ pub trait Analysis<'tcx>: AnalysisDomain<'tcx> {\n     /// edges.\n     fn apply_call_return_effect(\n         &self,\n-        state: &mut BitSet<Self::Idx>,\n+        state: &mut Self::Domain,\n         block: BasicBlock,\n         func: &mir::Operand<'tcx>,\n         args: &[mir::Operand<'tcx>],\n@@ -207,7 +174,7 @@ pub trait Analysis<'tcx>: AnalysisDomain<'tcx> {\n     /// By default, no effects happen.\n     fn apply_yield_resume_effect(\n         &self,\n-        _state: &mut BitSet<Self::Idx>,\n+        _state: &mut Self::Domain,\n         _resume_block: BasicBlock,\n         _resume_place: mir::Place<'tcx>,\n     ) {\n@@ -222,7 +189,7 @@ pub trait Analysis<'tcx>: AnalysisDomain<'tcx> {\n     /// FIXME: This class of effects is not supported for backward dataflow analyses.\n     fn apply_discriminant_switch_effect(\n         &self,\n-        _state: &mut BitSet<Self::Idx>,\n+        _state: &mut Self::Domain,\n         _block: BasicBlock,\n         _enum_place: mir::Place<'tcx>,\n         _adt: &ty::AdtDef,\n@@ -264,6 +231,8 @@ pub trait Analysis<'tcx>: AnalysisDomain<'tcx> {\n ///\n /// `Analysis` is automatically implemented for all implementers of `GenKillAnalysis`.\n pub trait GenKillAnalysis<'tcx>: Analysis<'tcx> {\n+    type Idx: Idx;\n+\n     /// See `Analysis::apply_statement_effect`.\n     fn statement_effect(\n         &self,\n@@ -332,10 +301,11 @@ pub trait GenKillAnalysis<'tcx>: Analysis<'tcx> {\n impl<A> Analysis<'tcx> for A\n where\n     A: GenKillAnalysis<'tcx>,\n+    A::Domain: GenKill<A::Idx> + BorrowMut<BitSet<A::Idx>>,\n {\n     fn apply_statement_effect(\n         &self,\n-        state: &mut BitSet<Self::Idx>,\n+        state: &mut A::Domain,\n         statement: &mir::Statement<'tcx>,\n         location: Location,\n     ) {\n@@ -344,7 +314,7 @@ where\n \n     fn apply_before_statement_effect(\n         &self,\n-        state: &mut BitSet<Self::Idx>,\n+        state: &mut A::Domain,\n         statement: &mir::Statement<'tcx>,\n         location: Location,\n     ) {\n@@ -353,7 +323,7 @@ where\n \n     fn apply_terminator_effect(\n         &self,\n-        state: &mut BitSet<Self::Idx>,\n+        state: &mut A::Domain,\n         terminator: &mir::Terminator<'tcx>,\n         location: Location,\n     ) {\n@@ -362,7 +332,7 @@ where\n \n     fn apply_before_terminator_effect(\n         &self,\n-        state: &mut BitSet<Self::Idx>,\n+        state: &mut A::Domain,\n         terminator: &mir::Terminator<'tcx>,\n         location: Location,\n     ) {\n@@ -371,7 +341,7 @@ where\n \n     fn apply_call_return_effect(\n         &self,\n-        state: &mut BitSet<Self::Idx>,\n+        state: &mut A::Domain,\n         block: BasicBlock,\n         func: &mir::Operand<'tcx>,\n         args: &[mir::Operand<'tcx>],\n@@ -382,7 +352,7 @@ where\n \n     fn apply_yield_resume_effect(\n         &self,\n-        state: &mut BitSet<Self::Idx>,\n+        state: &mut A::Domain,\n         resume_block: BasicBlock,\n         resume_place: mir::Place<'tcx>,\n     ) {\n@@ -391,7 +361,7 @@ where\n \n     fn apply_discriminant_switch_effect(\n         &self,\n-        state: &mut BitSet<Self::Idx>,\n+        state: &mut A::Domain,\n         block: BasicBlock,\n         enum_place: mir::Place<'tcx>,\n         adt: &ty::AdtDef,\n@@ -450,7 +420,7 @@ pub trait GenKill<T> {\n /// applied multiple times efficiently. When there are multiple calls to `gen` and/or `kill` for\n /// the same element, the most recent one takes precedence.\n #[derive(Clone)]\n-pub struct GenKillSet<T: Idx> {\n+pub struct GenKillSet<T> {\n     gen: HybridBitSet<T>,\n     kill: HybridBitSet<T>,\n }\n@@ -464,7 +434,6 @@ impl<T: Idx> GenKillSet<T> {\n         }\n     }\n \n-    /// Applies this transfer function to the given state vector.\n     pub fn apply(&self, state: &mut BitSet<T>) {\n         state.union(&self.gen);\n         state.subtract(&self.kill);\n@@ -493,6 +462,16 @@ impl<T: Idx> GenKill<T> for BitSet<T> {\n     }\n }\n \n+impl<T: Idx> GenKill<T> for lattice::Dual<BitSet<T>> {\n+    fn gen(&mut self, elem: T) {\n+        self.0.insert(elem);\n+    }\n+\n+    fn kill(&mut self, elem: T) {\n+        self.0.remove(elem);\n+    }\n+}\n+\n // NOTE: DO NOT CHANGE VARIANT ORDER. The derived `Ord` impls rely on the current order.\n #[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord)]\n pub enum Effect {"}, {"sha": "a5989121679c4fa8fb2014cd9910581e30520a48", "filename": "compiler/rustc_mir/src/dataflow/framework/tests.rs", "status": "modified", "additions": 12, "deletions": 17, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/0e2c1281e909ca38479b97962fc9248f75d66412/compiler%2Frustc_mir%2Fsrc%2Fdataflow%2Fframework%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e2c1281e909ca38479b97962fc9248f75d66412/compiler%2Frustc_mir%2Fsrc%2Fdataflow%2Fframework%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Fdataflow%2Fframework%2Ftests.rs?ref=0e2c1281e909ca38479b97962fc9248f75d66412", "patch": "@@ -9,7 +9,6 @@ use rustc_middle::ty;\n use rustc_span::DUMMY_SP;\n \n use super::*;\n-use crate::dataflow::BottomValue;\n \n /// Creates a `mir::Body` with a few disconnected basic blocks.\n ///\n@@ -92,13 +91,13 @@ impl<D: Direction> MockAnalysis<'tcx, D> {\n     /// The entry set for each `BasicBlock` is the ID of that block offset by a fixed amount to\n     /// avoid colliding with the statement/terminator effects.\n     fn mock_entry_set(&self, bb: BasicBlock) -> BitSet<usize> {\n-        let mut ret = BitSet::new_empty(self.bits_per_block(self.body));\n+        let mut ret = self.bottom_value(self.body);\n         ret.insert(Self::BASIC_BLOCK_OFFSET + bb.index());\n         ret\n     }\n \n     fn mock_entry_sets(&self) -> IndexVec<BasicBlock, BitSet<usize>> {\n-        let empty = BitSet::new_empty(self.bits_per_block(self.body));\n+        let empty = self.bottom_value(self.body);\n         let mut ret = IndexVec::from_elem(empty, &self.body.basic_blocks());\n \n         for (bb, _) in self.body.basic_blocks().iter_enumerated() {\n@@ -130,7 +129,7 @@ impl<D: Direction> MockAnalysis<'tcx, D> {\n     /// would be `[102, 0, 1, 2, 3, 4]`.\n     fn expected_state_at_target(&self, target: SeekTarget) -> BitSet<usize> {\n         let block = target.block();\n-        let mut ret = BitSet::new_empty(self.bits_per_block(self.body));\n+        let mut ret = self.bottom_value(self.body);\n         ret.insert(Self::BASIC_BLOCK_OFFSET + block.index());\n \n         let target = match target {\n@@ -161,29 +160,25 @@ impl<D: Direction> MockAnalysis<'tcx, D> {\n     }\n }\n \n-impl<D: Direction> BottomValue for MockAnalysis<'tcx, D> {\n-    const BOTTOM_VALUE: bool = false;\n-}\n-\n impl<D: Direction> AnalysisDomain<'tcx> for MockAnalysis<'tcx, D> {\n-    type Idx = usize;\n+    type Domain = BitSet<usize>;\n     type Direction = D;\n \n     const NAME: &'static str = \"mock\";\n \n-    fn bits_per_block(&self, body: &mir::Body<'tcx>) -> usize {\n-        Self::BASIC_BLOCK_OFFSET + body.basic_blocks().len()\n+    fn bottom_value(&self, body: &mir::Body<'tcx>) -> Self::Domain {\n+        BitSet::new_empty(Self::BASIC_BLOCK_OFFSET + body.basic_blocks().len())\n     }\n \n-    fn initialize_start_block(&self, _: &mir::Body<'tcx>, _: &mut BitSet<Self::Idx>) {\n+    fn initialize_start_block(&self, _: &mir::Body<'tcx>, _: &mut Self::Domain) {\n         unimplemented!(\"This is never called since `MockAnalysis` is never iterated to fixpoint\");\n     }\n }\n \n impl<D: Direction> Analysis<'tcx> for MockAnalysis<'tcx, D> {\n     fn apply_statement_effect(\n         &self,\n-        state: &mut BitSet<Self::Idx>,\n+        state: &mut Self::Domain,\n         _statement: &mir::Statement<'tcx>,\n         location: Location,\n     ) {\n@@ -193,7 +188,7 @@ impl<D: Direction> Analysis<'tcx> for MockAnalysis<'tcx, D> {\n \n     fn apply_before_statement_effect(\n         &self,\n-        state: &mut BitSet<Self::Idx>,\n+        state: &mut Self::Domain,\n         _statement: &mir::Statement<'tcx>,\n         location: Location,\n     ) {\n@@ -203,7 +198,7 @@ impl<D: Direction> Analysis<'tcx> for MockAnalysis<'tcx, D> {\n \n     fn apply_terminator_effect(\n         &self,\n-        state: &mut BitSet<Self::Idx>,\n+        state: &mut Self::Domain,\n         _terminator: &mir::Terminator<'tcx>,\n         location: Location,\n     ) {\n@@ -213,7 +208,7 @@ impl<D: Direction> Analysis<'tcx> for MockAnalysis<'tcx, D> {\n \n     fn apply_before_terminator_effect(\n         &self,\n-        state: &mut BitSet<Self::Idx>,\n+        state: &mut Self::Domain,\n         _terminator: &mir::Terminator<'tcx>,\n         location: Location,\n     ) {\n@@ -223,7 +218,7 @@ impl<D: Direction> Analysis<'tcx> for MockAnalysis<'tcx, D> {\n \n     fn apply_call_return_effect(\n         &self,\n-        _state: &mut BitSet<Self::Idx>,\n+        _state: &mut Self::Domain,\n         _block: BasicBlock,\n         _func: &mir::Operand<'tcx>,\n         _args: &[mir::Operand<'tcx>],"}, {"sha": "82eb734ed0699a2ae00f18635b59c9414cf552a3", "filename": "compiler/rustc_mir/src/dataflow/framework/visitor.rs", "status": "modified", "additions": 6, "deletions": 7, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/0e2c1281e909ca38479b97962fc9248f75d66412/compiler%2Frustc_mir%2Fsrc%2Fdataflow%2Fframework%2Fvisitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e2c1281e909ca38479b97962fc9248f75d66412/compiler%2Frustc_mir%2Fsrc%2Fdataflow%2Fframework%2Fvisitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Fdataflow%2Fframework%2Fvisitor.rs?ref=0e2c1281e909ca38479b97962fc9248f75d66412", "patch": "@@ -1,4 +1,3 @@\n-use rustc_index::bit_set::BitSet;\n use rustc_middle::mir::{self, BasicBlock, Location};\n \n use super::{Analysis, Direction, Results};\n@@ -139,16 +138,16 @@ impl<'tcx, A> ResultsVisitable<'tcx> for Results<'tcx, A>\n where\n     A: Analysis<'tcx>,\n {\n-    type FlowState = BitSet<A::Idx>;\n+    type FlowState = A::Domain;\n \n     type Direction = A::Direction;\n \n     fn new_flow_state(&self, body: &mir::Body<'tcx>) -> Self::FlowState {\n-        BitSet::new_empty(self.analysis.bits_per_block(body))\n+        self.analysis.bottom_value(body)\n     }\n \n     fn reset_to_block_entry(&self, state: &mut Self::FlowState, block: BasicBlock) {\n-        state.overwrite(&self.entry_set_for_block(block));\n+        state.clone_from(&self.entry_set_for_block(block));\n     }\n \n     fn reconstruct_before_statement_effect(\n@@ -217,11 +216,11 @@ macro_rules! impl_visitable {\n             $( $A: Analysis<'tcx, Direction = D>, )*\n         {\n             type Direction = D;\n-            type FlowState = $T<$( BitSet<$A::Idx> ),*>;\n+            type FlowState = $T<$( $A::Domain ),*>;\n \n             fn new_flow_state(&self, body: &mir::Body<'tcx>) -> Self::FlowState {\n                 $T {\n-                    $( $field: BitSet::new_empty(self.$field.analysis.bits_per_block(body)) ),*\n+                    $( $field: self.$field.analysis.bottom_value(body) ),*\n                 }\n             }\n \n@@ -230,7 +229,7 @@ macro_rules! impl_visitable {\n                 state: &mut Self::FlowState,\n                 block: BasicBlock,\n             ) {\n-                $( state.$field.overwrite(&self.$field.entry_set_for_block(block)); )*\n+                $( state.$field.clone_from(&self.$field.entry_set_for_block(block)); )*\n             }\n \n             fn reconstruct_before_statement_effect("}, {"sha": "65e04ed6831cc4499d32a04d535200ca78183bd0", "filename": "compiler/rustc_mir/src/dataflow/impls/borrowed_locals.rs", "status": "modified", "additions": 7, "deletions": 10, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/0e2c1281e909ca38479b97962fc9248f75d66412/compiler%2Frustc_mir%2Fsrc%2Fdataflow%2Fimpls%2Fborrowed_locals.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e2c1281e909ca38479b97962fc9248f75d66412/compiler%2Frustc_mir%2Fsrc%2Fdataflow%2Fimpls%2Fborrowed_locals.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Fdataflow%2Fimpls%2Fborrowed_locals.rs?ref=0e2c1281e909ca38479b97962fc9248f75d66412", "patch": "@@ -82,15 +82,15 @@ impl<K> AnalysisDomain<'tcx> for MaybeBorrowedLocals<K>\n where\n     K: BorrowAnalysisKind<'tcx>,\n {\n-    type Idx = Local;\n-\n+    type Domain = BitSet<Local>;\n     const NAME: &'static str = K::ANALYSIS_NAME;\n \n-    fn bits_per_block(&self, body: &mir::Body<'tcx>) -> usize {\n-        body.local_decls().len()\n+    fn bottom_value(&self, body: &mir::Body<'tcx>) -> Self::Domain {\n+        // bottom = unborrowed\n+        BitSet::new_empty(body.local_decls().len())\n     }\n \n-    fn initialize_start_block(&self, _: &mir::Body<'tcx>, _: &mut BitSet<Self::Idx>) {\n+    fn initialize_start_block(&self, _: &mir::Body<'tcx>, _: &mut Self::Domain) {\n         // No locals are aliased on function entry\n     }\n }\n@@ -99,6 +99,8 @@ impl<K> GenKillAnalysis<'tcx> for MaybeBorrowedLocals<K>\n where\n     K: BorrowAnalysisKind<'tcx>,\n {\n+    type Idx = Local;\n+\n     fn statement_effect(\n         &self,\n         trans: &mut impl GenKill<Self::Idx>,\n@@ -128,11 +130,6 @@ where\n     }\n }\n \n-impl<K> BottomValue for MaybeBorrowedLocals<K> {\n-    // bottom = unborrowed\n-    const BOTTOM_VALUE: bool = false;\n-}\n-\n /// A `Visitor` that defines the transfer function for `MaybeBorrowedLocals`.\n struct TransferFunction<'a, T, K> {\n     trans: &'a mut T,"}, {"sha": "0be13b6ba81daf48116dd366af6a7480c1614800", "filename": "compiler/rustc_mir/src/dataflow/impls/borrows.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/0e2c1281e909ca38479b97962fc9248f75d66412/compiler%2Frustc_mir%2Fsrc%2Fdataflow%2Fimpls%2Fborrows.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e2c1281e909ca38479b97962fc9248f75d66412/compiler%2Frustc_mir%2Fsrc%2Fdataflow%2Fimpls%2Fborrows.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Fdataflow%2Fimpls%2Fborrows.rs?ref=0e2c1281e909ca38479b97962fc9248f75d66412", "patch": "@@ -8,9 +8,9 @@ use rustc_index::bit_set::BitSet;\n use crate::borrow_check::{\n     places_conflict, BorrowSet, PlaceConflictBias, PlaceExt, RegionInferenceContext, ToRegionVid,\n };\n-use crate::dataflow::BottomValue;\n-use crate::dataflow::{self, GenKill};\n+use crate::dataflow::{self, fmt::DebugWithContext, GenKill};\n \n+use std::fmt;\n use std::rc::Rc;\n \n rustc_index::newtype_index! {\n@@ -227,25 +227,24 @@ impl<'a, 'tcx> Borrows<'a, 'tcx> {\n }\n \n impl<'tcx> dataflow::AnalysisDomain<'tcx> for Borrows<'_, 'tcx> {\n-    type Idx = BorrowIndex;\n+    type Domain = BitSet<BorrowIndex>;\n \n     const NAME: &'static str = \"borrows\";\n \n-    fn bits_per_block(&self, _: &mir::Body<'tcx>) -> usize {\n-        self.borrow_set.len() * 2\n+    fn bottom_value(&self, _: &mir::Body<'tcx>) -> Self::Domain {\n+        // bottom = nothing is reserved or activated yet;\n+        BitSet::new_empty(self.borrow_set.len() * 2)\n     }\n \n-    fn initialize_start_block(&self, _: &mir::Body<'tcx>, _: &mut BitSet<Self::Idx>) {\n+    fn initialize_start_block(&self, _: &mir::Body<'tcx>, _: &mut Self::Domain) {\n         // no borrows of code region_scopes have been taken prior to\n         // function execution, so this method has no effect.\n     }\n-\n-    fn pretty_print_idx(&self, w: &mut impl std::io::Write, idx: Self::Idx) -> std::io::Result<()> {\n-        write!(w, \"{:?}\", self.location(idx))\n-    }\n }\n \n impl<'tcx> dataflow::GenKillAnalysis<'tcx> for Borrows<'_, 'tcx> {\n+    type Idx = BorrowIndex;\n+\n     fn before_statement_effect(\n         &self,\n         trans: &mut impl GenKill<Self::Idx>,\n@@ -344,7 +343,8 @@ impl<'tcx> dataflow::GenKillAnalysis<'tcx> for Borrows<'_, 'tcx> {\n     }\n }\n \n-impl<'a, 'tcx> BottomValue for Borrows<'a, 'tcx> {\n-    /// bottom = nothing is reserved or activated yet;\n-    const BOTTOM_VALUE: bool = false;\n+impl DebugWithContext<Borrows<'_, '_>> for BorrowIndex {\n+    fn fmt_with(&self, ctxt: &Borrows<'_, '_>, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        write!(f, \"{:?}\", ctxt.location(*self))\n+    }\n }"}, {"sha": "5da302cd1fd4aae2f3d7612ce87ea3a274c0deff", "filename": "compiler/rustc_mir/src/dataflow/impls/init_locals.rs", "status": "modified", "additions": 8, "deletions": 10, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/0e2c1281e909ca38479b97962fc9248f75d66412/compiler%2Frustc_mir%2Fsrc%2Fdataflow%2Fimpls%2Finit_locals.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e2c1281e909ca38479b97962fc9248f75d66412/compiler%2Frustc_mir%2Fsrc%2Fdataflow%2Fimpls%2Finit_locals.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Fdataflow%2Fimpls%2Finit_locals.rs?ref=0e2c1281e909ca38479b97962fc9248f75d66412", "patch": "@@ -2,29 +2,25 @@\n //!\n //! A local will be maybe initialized if *any* projections of that local might be initialized.\n \n-use crate::dataflow::{self, BottomValue, GenKill};\n+use crate::dataflow::{self, GenKill};\n \n use rustc_index::bit_set::BitSet;\n use rustc_middle::mir::visit::{PlaceContext, Visitor};\n use rustc_middle::mir::{self, BasicBlock, Local, Location};\n \n pub struct MaybeInitializedLocals;\n \n-impl BottomValue for MaybeInitializedLocals {\n-    /// bottom = uninit\n-    const BOTTOM_VALUE: bool = false;\n-}\n-\n impl dataflow::AnalysisDomain<'tcx> for MaybeInitializedLocals {\n-    type Idx = Local;\n+    type Domain = BitSet<Local>;\n \n     const NAME: &'static str = \"maybe_init_locals\";\n \n-    fn bits_per_block(&self, body: &mir::Body<'tcx>) -> usize {\n-        body.local_decls.len()\n+    fn bottom_value(&self, body: &mir::Body<'tcx>) -> Self::Domain {\n+        // bottom = uninit\n+        BitSet::new_empty(body.local_decls.len())\n     }\n \n-    fn initialize_start_block(&self, body: &mir::Body<'tcx>, entry_set: &mut BitSet<Self::Idx>) {\n+    fn initialize_start_block(&self, body: &mir::Body<'tcx>, entry_set: &mut Self::Domain) {\n         // Function arguments are initialized to begin with.\n         for arg in body.args_iter() {\n             entry_set.insert(arg);\n@@ -33,6 +29,8 @@ impl dataflow::AnalysisDomain<'tcx> for MaybeInitializedLocals {\n }\n \n impl dataflow::GenKillAnalysis<'tcx> for MaybeInitializedLocals {\n+    type Idx = Local;\n+\n     fn statement_effect(\n         &self,\n         trans: &mut impl GenKill<Self::Idx>,"}, {"sha": "b0da28156d1a49e3e1fe4a53f18d37eb1c15dc10", "filename": "compiler/rustc_mir/src/dataflow/impls/liveness.rs", "status": "modified", "additions": 8, "deletions": 10, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/0e2c1281e909ca38479b97962fc9248f75d66412/compiler%2Frustc_mir%2Fsrc%2Fdataflow%2Fimpls%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e2c1281e909ca38479b97962fc9248f75d66412/compiler%2Frustc_mir%2Fsrc%2Fdataflow%2Fimpls%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Fdataflow%2Fimpls%2Fliveness.rs?ref=0e2c1281e909ca38479b97962fc9248f75d66412", "patch": "@@ -2,7 +2,7 @@ use rustc_index::bit_set::BitSet;\n use rustc_middle::mir::visit::{MutatingUseContext, NonMutatingUseContext, PlaceContext, Visitor};\n use rustc_middle::mir::{self, Local, Location};\n \n-use crate::dataflow::{AnalysisDomain, Backward, BottomValue, GenKill, GenKillAnalysis};\n+use crate::dataflow::{AnalysisDomain, Backward, GenKill, GenKillAnalysis};\n \n /// A [live-variable dataflow analysis][liveness].\n ///\n@@ -22,27 +22,25 @@ impl MaybeLiveLocals {\n     }\n }\n \n-impl BottomValue for MaybeLiveLocals {\n-    // bottom = not live\n-    const BOTTOM_VALUE: bool = false;\n-}\n-\n impl AnalysisDomain<'tcx> for MaybeLiveLocals {\n-    type Idx = Local;\n+    type Domain = BitSet<Local>;\n     type Direction = Backward;\n \n     const NAME: &'static str = \"liveness\";\n \n-    fn bits_per_block(&self, body: &mir::Body<'tcx>) -> usize {\n-        body.local_decls.len()\n+    fn bottom_value(&self, body: &mir::Body<'tcx>) -> Self::Domain {\n+        // bottom = not live\n+        BitSet::new_empty(body.local_decls.len())\n     }\n \n-    fn initialize_start_block(&self, _: &mir::Body<'tcx>, _: &mut BitSet<Self::Idx>) {\n+    fn initialize_start_block(&self, _: &mir::Body<'tcx>, _: &mut Self::Domain) {\n         // No variables are live until we observe a use\n     }\n }\n \n impl GenKillAnalysis<'tcx> for MaybeLiveLocals {\n+    type Idx = Local;\n+\n     fn statement_effect(\n         &self,\n         trans: &mut impl GenKill<Self::Idx>,"}, {"sha": "c42d58678565658fd5396c4c7bed84c693d8075d", "filename": "compiler/rustc_mir/src/dataflow/impls/mod.rs", "status": "modified", "additions": 32, "deletions": 53, "changes": 85, "blob_url": "https://github.com/rust-lang/rust/blob/0e2c1281e909ca38479b97962fc9248f75d66412/compiler%2Frustc_mir%2Fsrc%2Fdataflow%2Fimpls%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e2c1281e909ca38479b97962fc9248f75d66412/compiler%2Frustc_mir%2Fsrc%2Fdataflow%2Fimpls%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Fdataflow%2Fimpls%2Fmod.rs?ref=0e2c1281e909ca38479b97962fc9248f75d66412", "patch": "@@ -13,7 +13,7 @@ use super::MoveDataParamEnv;\n use crate::util::elaborate_drops::DropFlagState;\n \n use super::move_paths::{HasMoveData, InitIndex, InitKind, MoveData, MovePathIndex};\n-use super::{AnalysisDomain, BottomValue, GenKill, GenKillAnalysis};\n+use super::{lattice, AnalysisDomain, GenKill, GenKillAnalysis};\n \n use super::drop_flag_effects_for_function_entry;\n use super::drop_flag_effects_for_location;\n@@ -290,27 +290,25 @@ impl<'a, 'tcx> DefinitelyInitializedPlaces<'a, 'tcx> {\n }\n \n impl<'tcx> AnalysisDomain<'tcx> for MaybeInitializedPlaces<'_, 'tcx> {\n-    type Idx = MovePathIndex;\n-\n+    type Domain = BitSet<MovePathIndex>;\n     const NAME: &'static str = \"maybe_init\";\n \n-    fn bits_per_block(&self, _: &mir::Body<'tcx>) -> usize {\n-        self.move_data().move_paths.len()\n+    fn bottom_value(&self, _: &mir::Body<'tcx>) -> Self::Domain {\n+        // bottom = uninitialized\n+        BitSet::new_empty(self.move_data().move_paths.len())\n     }\n \n-    fn initialize_start_block(&self, _: &mir::Body<'tcx>, state: &mut BitSet<Self::Idx>) {\n+    fn initialize_start_block(&self, _: &mir::Body<'tcx>, state: &mut Self::Domain) {\n         drop_flag_effects_for_function_entry(self.tcx, self.body, self.mdpe, |path, s| {\n             assert!(s == DropFlagState::Present);\n             state.insert(path);\n         });\n     }\n-\n-    fn pretty_print_idx(&self, w: &mut impl std::io::Write, mpi: Self::Idx) -> std::io::Result<()> {\n-        write!(w, \"{}\", self.move_data().move_paths[mpi])\n-    }\n }\n \n impl<'tcx> GenKillAnalysis<'tcx> for MaybeInitializedPlaces<'_, 'tcx> {\n+    type Idx = MovePathIndex;\n+\n     fn statement_effect(\n         &self,\n         trans: &mut impl GenKill<Self::Idx>,\n@@ -376,32 +374,30 @@ impl<'tcx> GenKillAnalysis<'tcx> for MaybeInitializedPlaces<'_, 'tcx> {\n }\n \n impl<'tcx> AnalysisDomain<'tcx> for MaybeUninitializedPlaces<'_, 'tcx> {\n-    type Idx = MovePathIndex;\n+    type Domain = BitSet<MovePathIndex>;\n \n     const NAME: &'static str = \"maybe_uninit\";\n \n-    fn bits_per_block(&self, _: &mir::Body<'tcx>) -> usize {\n-        self.move_data().move_paths.len()\n+    fn bottom_value(&self, _: &mir::Body<'tcx>) -> Self::Domain {\n+        // bottom = initialized (start_block_effect counters this at outset)\n+        BitSet::new_empty(self.move_data().move_paths.len())\n     }\n \n     // sets on_entry bits for Arg places\n-    fn initialize_start_block(&self, body: &mir::Body<'tcx>, state: &mut BitSet<Self::Idx>) {\n+    fn initialize_start_block(&self, _: &mir::Body<'tcx>, state: &mut Self::Domain) {\n         // set all bits to 1 (uninit) before gathering counterevidence\n-        assert!(self.bits_per_block(body) == state.domain_size());\n         state.insert_all();\n \n         drop_flag_effects_for_function_entry(self.tcx, self.body, self.mdpe, |path, s| {\n             assert!(s == DropFlagState::Present);\n             state.remove(path);\n         });\n     }\n-\n-    fn pretty_print_idx(&self, w: &mut impl std::io::Write, mpi: Self::Idx) -> std::io::Result<()> {\n-        write!(w, \"{}\", self.move_data().move_paths[mpi])\n-    }\n }\n \n impl<'tcx> GenKillAnalysis<'tcx> for MaybeUninitializedPlaces<'_, 'tcx> {\n+    type Idx = MovePathIndex;\n+\n     fn statement_effect(\n         &self,\n         trans: &mut impl GenKill<Self::Idx>,\n@@ -471,30 +467,30 @@ impl<'tcx> GenKillAnalysis<'tcx> for MaybeUninitializedPlaces<'_, 'tcx> {\n }\n \n impl<'a, 'tcx> AnalysisDomain<'tcx> for DefinitelyInitializedPlaces<'a, 'tcx> {\n-    type Idx = MovePathIndex;\n+    /// Use set intersection as the join operator.\n+    type Domain = lattice::Dual<BitSet<MovePathIndex>>;\n \n     const NAME: &'static str = \"definite_init\";\n \n-    fn bits_per_block(&self, _: &mir::Body<'tcx>) -> usize {\n-        self.move_data().move_paths.len()\n+    fn bottom_value(&self, _: &mir::Body<'tcx>) -> Self::Domain {\n+        // bottom = initialized (start_block_effect counters this at outset)\n+        lattice::Dual(BitSet::new_filled(self.move_data().move_paths.len()))\n     }\n \n     // sets on_entry bits for Arg places\n-    fn initialize_start_block(&self, _: &mir::Body<'tcx>, state: &mut BitSet<Self::Idx>) {\n-        state.clear();\n+    fn initialize_start_block(&self, _: &mir::Body<'tcx>, state: &mut Self::Domain) {\n+        state.0.clear();\n \n         drop_flag_effects_for_function_entry(self.tcx, self.body, self.mdpe, |path, s| {\n             assert!(s == DropFlagState::Present);\n-            state.insert(path);\n+            state.0.insert(path);\n         });\n     }\n-\n-    fn pretty_print_idx(&self, w: &mut impl std::io::Write, mpi: Self::Idx) -> std::io::Result<()> {\n-        write!(w, \"{}\", self.move_data().move_paths[mpi])\n-    }\n }\n \n impl<'tcx> GenKillAnalysis<'tcx> for DefinitelyInitializedPlaces<'_, 'tcx> {\n+    type Idx = MovePathIndex;\n+\n     fn statement_effect(\n         &self,\n         trans: &mut impl GenKill<Self::Idx>,\n@@ -540,22 +536,25 @@ impl<'tcx> GenKillAnalysis<'tcx> for DefinitelyInitializedPlaces<'_, 'tcx> {\n }\n \n impl<'tcx> AnalysisDomain<'tcx> for EverInitializedPlaces<'_, 'tcx> {\n-    type Idx = InitIndex;\n+    type Domain = BitSet<InitIndex>;\n \n     const NAME: &'static str = \"ever_init\";\n \n-    fn bits_per_block(&self, _: &mir::Body<'tcx>) -> usize {\n-        self.move_data().inits.len()\n+    fn bottom_value(&self, _: &mir::Body<'tcx>) -> Self::Domain {\n+        // bottom = no initialized variables by default\n+        BitSet::new_empty(self.move_data().inits.len())\n     }\n \n-    fn initialize_start_block(&self, body: &mir::Body<'tcx>, state: &mut BitSet<Self::Idx>) {\n+    fn initialize_start_block(&self, body: &mir::Body<'tcx>, state: &mut Self::Domain) {\n         for arg_init in 0..body.arg_count {\n             state.insert(InitIndex::new(arg_init));\n         }\n     }\n }\n \n impl<'tcx> GenKillAnalysis<'tcx> for EverInitializedPlaces<'_, 'tcx> {\n+    type Idx = InitIndex;\n+\n     fn statement_effect(\n         &self,\n         trans: &mut impl GenKill<Self::Idx>,\n@@ -625,23 +624,3 @@ impl<'tcx> GenKillAnalysis<'tcx> for EverInitializedPlaces<'_, 'tcx> {\n         }\n     }\n }\n-\n-impl<'a, 'tcx> BottomValue for MaybeInitializedPlaces<'a, 'tcx> {\n-    /// bottom = uninitialized\n-    const BOTTOM_VALUE: bool = false;\n-}\n-\n-impl<'a, 'tcx> BottomValue for MaybeUninitializedPlaces<'a, 'tcx> {\n-    /// bottom = initialized (start_block_effect counters this at outset)\n-    const BOTTOM_VALUE: bool = false;\n-}\n-\n-impl<'a, 'tcx> BottomValue for DefinitelyInitializedPlaces<'a, 'tcx> {\n-    /// bottom = initialized (start_block_effect counters this at outset)\n-    const BOTTOM_VALUE: bool = true;\n-}\n-\n-impl<'a, 'tcx> BottomValue for EverInitializedPlaces<'a, 'tcx> {\n-    /// bottom = no initialized variables by default\n-    const BOTTOM_VALUE: bool = false;\n-}"}, {"sha": "9250cd408479aec0c0891fd16fc9125a1cecab7d", "filename": "compiler/rustc_mir/src/dataflow/impls/storage_liveness.rs", "status": "modified", "additions": 14, "deletions": 19, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/0e2c1281e909ca38479b97962fc9248f75d66412/compiler%2Frustc_mir%2Fsrc%2Fdataflow%2Fimpls%2Fstorage_liveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e2c1281e909ca38479b97962fc9248f75d66412/compiler%2Frustc_mir%2Fsrc%2Fdataflow%2Fimpls%2Fstorage_liveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Fdataflow%2Fimpls%2Fstorage_liveness.rs?ref=0e2c1281e909ca38479b97962fc9248f75d66412", "patch": "@@ -1,6 +1,5 @@\n pub use super::*;\n \n-use crate::dataflow::BottomValue;\n use crate::dataflow::{self, GenKill, Results, ResultsRefCursor};\n use crate::util::storage::AlwaysLiveLocals;\n use rustc_middle::mir::visit::{NonMutatingUseContext, PlaceContext, Visitor};\n@@ -19,15 +18,16 @@ impl MaybeStorageLive {\n }\n \n impl dataflow::AnalysisDomain<'tcx> for MaybeStorageLive {\n-    type Idx = Local;\n+    type Domain = BitSet<Local>;\n \n     const NAME: &'static str = \"maybe_storage_live\";\n \n-    fn bits_per_block(&self, body: &mir::Body<'tcx>) -> usize {\n-        body.local_decls.len()\n+    fn bottom_value(&self, body: &mir::Body<'tcx>) -> Self::Domain {\n+        // bottom = dead\n+        BitSet::new_empty(body.local_decls.len())\n     }\n \n-    fn initialize_start_block(&self, body: &mir::Body<'tcx>, on_entry: &mut BitSet<Self::Idx>) {\n+    fn initialize_start_block(&self, body: &mir::Body<'tcx>, on_entry: &mut Self::Domain) {\n         assert_eq!(body.local_decls.len(), self.always_live_locals.domain_size());\n         for local in self.always_live_locals.iter() {\n             on_entry.insert(local);\n@@ -40,6 +40,8 @@ impl dataflow::AnalysisDomain<'tcx> for MaybeStorageLive {\n }\n \n impl dataflow::GenKillAnalysis<'tcx> for MaybeStorageLive {\n+    type Idx = Local;\n+\n     fn statement_effect(\n         &self,\n         trans: &mut impl GenKill<Self::Idx>,\n@@ -74,11 +76,6 @@ impl dataflow::GenKillAnalysis<'tcx> for MaybeStorageLive {\n     }\n }\n \n-impl BottomValue for MaybeStorageLive {\n-    /// bottom = dead\n-    const BOTTOM_VALUE: bool = false;\n-}\n-\n type BorrowedLocalsResults<'a, 'tcx> = ResultsRefCursor<'a, 'a, 'tcx, MaybeBorrowedLocals>;\n \n /// Dataflow analysis that determines whether each local requires storage at a\n@@ -101,15 +98,16 @@ impl<'mir, 'tcx> MaybeRequiresStorage<'mir, 'tcx> {\n }\n \n impl<'mir, 'tcx> dataflow::AnalysisDomain<'tcx> for MaybeRequiresStorage<'mir, 'tcx> {\n-    type Idx = Local;\n+    type Domain = BitSet<Local>;\n \n     const NAME: &'static str = \"requires_storage\";\n \n-    fn bits_per_block(&self, body: &mir::Body<'tcx>) -> usize {\n-        body.local_decls.len()\n+    fn bottom_value(&self, body: &mir::Body<'tcx>) -> Self::Domain {\n+        // bottom = dead\n+        BitSet::new_empty(body.local_decls.len())\n     }\n \n-    fn initialize_start_block(&self, body: &mir::Body<'tcx>, on_entry: &mut BitSet<Self::Idx>) {\n+    fn initialize_start_block(&self, body: &mir::Body<'tcx>, on_entry: &mut Self::Domain) {\n         // The resume argument is live on function entry (we don't care about\n         // the `self` argument)\n         for arg in body.args_iter().skip(1) {\n@@ -119,6 +117,8 @@ impl<'mir, 'tcx> dataflow::AnalysisDomain<'tcx> for MaybeRequiresStorage<'mir, '\n }\n \n impl<'mir, 'tcx> dataflow::GenKillAnalysis<'tcx> for MaybeRequiresStorage<'mir, 'tcx> {\n+    type Idx = Local;\n+\n     fn before_statement_effect(\n         &self,\n         trans: &mut impl GenKill<Self::Idx>,\n@@ -285,11 +285,6 @@ impl<'mir, 'tcx> MaybeRequiresStorage<'mir, 'tcx> {\n     }\n }\n \n-impl<'mir, 'tcx> BottomValue for MaybeRequiresStorage<'mir, 'tcx> {\n-    /// bottom = dead\n-    const BOTTOM_VALUE: bool = false;\n-}\n-\n struct MoveVisitor<'a, 'mir, 'tcx, T> {\n     borrowed_locals: &'a RefCell<BorrowedLocalsResults<'mir, 'tcx>>,\n     trans: &'a mut T,"}, {"sha": "5575a97982fc4e34bebb5d9db48e1754b7f208bd", "filename": "compiler/rustc_mir/src/dataflow/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0e2c1281e909ca38479b97962fc9248f75d66412/compiler%2Frustc_mir%2Fsrc%2Fdataflow%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e2c1281e909ca38479b97962fc9248f75d66412/compiler%2Frustc_mir%2Fsrc%2Fdataflow%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Fdataflow%2Fmod.rs?ref=0e2c1281e909ca38479b97962fc9248f75d66412", "patch": "@@ -5,9 +5,9 @@ use rustc_span::symbol::{sym, Symbol};\n \n pub(crate) use self::drop_flag_effects::*;\n pub use self::framework::{\n-    visit_results, Analysis, AnalysisDomain, Backward, BorrowckFlowState, BorrowckResults,\n-    BottomValue, Engine, Forward, GenKill, GenKillAnalysis, Results, ResultsCursor,\n-    ResultsRefCursor, ResultsVisitor,\n+    fmt, lattice, visit_results, Analysis, AnalysisDomain, Backward, BorrowckFlowState,\n+    BorrowckResults, Engine, Forward, GenKill, GenKillAnalysis, JoinSemiLattice, Results,\n+    ResultsCursor, ResultsRefCursor, ResultsVisitor,\n };\n \n use self::move_paths::MoveData;"}, {"sha": "42717f273843aa4196ff0aaacd2cd18e901ecd22", "filename": "compiler/rustc_mir/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0e2c1281e909ca38479b97962fc9248f75d66412/compiler%2Frustc_mir%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e2c1281e909ca38479b97962fc9248f75d66412/compiler%2Frustc_mir%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Flib.rs?ref=0e2c1281e909ca38479b97962fc9248f75d66412", "patch": "@@ -14,6 +14,7 @@ Rust MIR: a lowered representation of Rust.\n #![feature(crate_visibility_modifier)]\n #![feature(decl_macro)]\n #![feature(drain_filter)]\n+#![feature(exact_size_is_empty)]\n #![feature(exhaustive_patterns)]\n #![feature(iter_order_by)]\n #![feature(never_type)]"}, {"sha": "a00301952b328fa9dfa946e80177a8bce1683381", "filename": "compiler/rustc_mir/src/transform/check_consts/resolver.rs", "status": "modified", "additions": 7, "deletions": 11, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/0e2c1281e909ca38479b97962fc9248f75d66412/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fcheck_consts%2Fresolver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e2c1281e909ca38479b97962fc9248f75d66412/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fcheck_consts%2Fresolver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fcheck_consts%2Fresolver.rs?ref=0e2c1281e909ca38479b97962fc9248f75d66412", "patch": "@@ -165,23 +165,19 @@ where\n     }\n }\n \n-impl<Q> dataflow::BottomValue for FlowSensitiveAnalysis<'_, '_, '_, Q> {\n-    const BOTTOM_VALUE: bool = false;\n-}\n-\n impl<Q> dataflow::AnalysisDomain<'tcx> for FlowSensitiveAnalysis<'_, '_, 'tcx, Q>\n where\n     Q: Qualif,\n {\n-    type Idx = Local;\n+    type Domain = BitSet<Local>;\n \n     const NAME: &'static str = Q::ANALYSIS_NAME;\n \n-    fn bits_per_block(&self, body: &mir::Body<'tcx>) -> usize {\n-        body.local_decls.len()\n+    fn bottom_value(&self, body: &mir::Body<'tcx>) -> Self::Domain {\n+        BitSet::new_empty(body.local_decls.len())\n     }\n \n-    fn initialize_start_block(&self, _body: &mir::Body<'tcx>, state: &mut BitSet<Self::Idx>) {\n+    fn initialize_start_block(&self, _body: &mir::Body<'tcx>, state: &mut Self::Domain) {\n         self.transfer_function(state).initialize_state();\n     }\n }\n@@ -192,7 +188,7 @@ where\n {\n     fn apply_statement_effect(\n         &self,\n-        state: &mut BitSet<Self::Idx>,\n+        state: &mut Self::Domain,\n         statement: &mir::Statement<'tcx>,\n         location: Location,\n     ) {\n@@ -201,7 +197,7 @@ where\n \n     fn apply_terminator_effect(\n         &self,\n-        state: &mut BitSet<Self::Idx>,\n+        state: &mut Self::Domain,\n         terminator: &mir::Terminator<'tcx>,\n         location: Location,\n     ) {\n@@ -210,7 +206,7 @@ where\n \n     fn apply_call_return_effect(\n         &self,\n-        state: &mut BitSet<Self::Idx>,\n+        state: &mut Self::Domain,\n         block: BasicBlock,\n         func: &mir::Operand<'tcx>,\n         args: &[mir::Operand<'tcx>],"}, {"sha": "015af44b80f6f2f6c3baceadddb3ffa81fe08193", "filename": "compiler/rustc_mir/src/transform/rustc_peek.rs", "status": "modified", "additions": 10, "deletions": 7, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/0e2c1281e909ca38479b97962fc9248f75d66412/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Frustc_peek.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e2c1281e909ca38479b97962fc9248f75d66412/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Frustc_peek.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Frustc_peek.rs?ref=0e2c1281e909ca38479b97962fc9248f75d66412", "patch": "@@ -1,4 +1,6 @@\n-use rustc_ast as ast;\n+use std::borrow::Borrow;\n+\n+use rustc_ast::ast;\n use rustc_span::symbol::sym;\n use rustc_span::Span;\n use rustc_target::spec::abi::Abi;\n@@ -16,7 +18,7 @@ use crate::dataflow::impls::{\n use crate::dataflow::move_paths::{HasMoveData, MoveData};\n use crate::dataflow::move_paths::{LookupResult, MovePathIndex};\n use crate::dataflow::MoveDataParamEnv;\n-use crate::dataflow::{Analysis, Results, ResultsCursor};\n+use crate::dataflow::{Analysis, JoinSemiLattice, Results, ResultsCursor};\n \n pub struct SanityCheck;\n \n@@ -248,25 +250,26 @@ pub trait RustcPeekAt<'tcx>: Analysis<'tcx> {\n         &self,\n         tcx: TyCtxt<'tcx>,\n         place: mir::Place<'tcx>,\n-        flow_state: &BitSet<Self::Idx>,\n+        flow_state: &Self::Domain,\n         call: PeekCall,\n     );\n }\n \n-impl<'tcx, A> RustcPeekAt<'tcx> for A\n+impl<'tcx, A, D> RustcPeekAt<'tcx> for A\n where\n-    A: Analysis<'tcx, Idx = MovePathIndex> + HasMoveData<'tcx>,\n+    A: Analysis<'tcx, Domain = D> + HasMoveData<'tcx>,\n+    D: JoinSemiLattice + Clone + Borrow<BitSet<MovePathIndex>>,\n {\n     fn peek_at(\n         &self,\n         tcx: TyCtxt<'tcx>,\n         place: mir::Place<'tcx>,\n-        flow_state: &BitSet<Self::Idx>,\n+        flow_state: &Self::Domain,\n         call: PeekCall,\n     ) {\n         match self.move_data().rev_lookup.find(place.as_ref()) {\n             LookupResult::Exact(peek_mpi) => {\n-                let bit_state = flow_state.contains(peek_mpi);\n+                let bit_state = flow_state.borrow().contains(peek_mpi);\n                 debug!(\"rustc_peek({:?} = &{:?}) bit_state: {}\", call.arg, place, bit_state);\n                 if !bit_state {\n                     tcx.sess.span_err(call.span, \"rustc_peek: bit not set\");"}, {"sha": "57a45e628db61497c3f605838e75f2e220a8a003", "filename": "src/tools/clippy/clippy_lints/src/redundant_clone.rs", "status": "modified", "additions": 7, "deletions": 10, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/0e2c1281e909ca38479b97962fc9248f75d66412/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fredundant_clone.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e2c1281e909ca38479b97962fc9248f75d66412/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fredundant_clone.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fredundant_clone.rs?ref=0e2c1281e909ca38479b97962fc9248f75d66412", "patch": "@@ -14,7 +14,6 @@ use rustc_middle::mir::{\n     visit::{MutatingUseContext, NonMutatingUseContext, PlaceContext, Visitor as _},\n };\n use rustc_middle::ty::{self, fold::TypeVisitor, Ty};\n-use rustc_mir::dataflow::BottomValue;\n use rustc_mir::dataflow::{Analysis, AnalysisDomain, GenKill, GenKillAnalysis, ResultsCursor};\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n use rustc_span::source_map::{BytePos, Span};\n@@ -411,21 +410,24 @@ impl<'tcx> mir::visit::Visitor<'tcx> for LocalUseVisitor {\n struct MaybeStorageLive;\n \n impl<'tcx> AnalysisDomain<'tcx> for MaybeStorageLive {\n-    type Idx = mir::Local;\n+    type Domain = BitSet<mir::Local>;\n     const NAME: &'static str = \"maybe_storage_live\";\n \n-    fn bits_per_block(&self, body: &mir::Body<'tcx>) -> usize {\n-        body.local_decls.len()\n+    fn bottom_value(&self, body: &mir::Body<'tcx>) -> Self::Domain {\n+        // bottom = dead\n+        BitSet::new_empty(body.local_decls.len())\n     }\n \n-    fn initialize_start_block(&self, body: &mir::Body<'tcx>, state: &mut BitSet<Self::Idx>) {\n+    fn initialize_start_block(&self, body: &mir::Body<'tcx>, state: &mut Self::Domain) {\n         for arg in body.args_iter() {\n             state.insert(arg);\n         }\n     }\n }\n \n impl<'tcx> GenKillAnalysis<'tcx> for MaybeStorageLive {\n+    type Idx = mir::Local;\n+\n     fn statement_effect(&self, trans: &mut impl GenKill<Self::Idx>, stmt: &mir::Statement<'tcx>, _: mir::Location) {\n         match stmt.kind {\n             mir::StatementKind::StorageLive(l) => trans.gen(l),\n@@ -454,11 +456,6 @@ impl<'tcx> GenKillAnalysis<'tcx> for MaybeStorageLive {\n     }\n }\n \n-impl BottomValue for MaybeStorageLive {\n-    /// bottom = dead\n-    const BOTTOM_VALUE: bool = false;\n-}\n-\n /// Collects the possible borrowers of each local.\n /// For example, `b = &a; c = &a;` will make `b` and (transitively) `c`\n /// possible borrowers of `a`."}]}