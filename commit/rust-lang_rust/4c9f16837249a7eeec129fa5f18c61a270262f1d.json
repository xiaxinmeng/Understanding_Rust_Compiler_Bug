{"sha": "4c9f16837249a7eeec129fa5f18c61a270262f1d", "node_id": "MDY6Q29tbWl0NzI0NzEyOjRjOWYxNjgzNzI0OWE3ZWVlYzEyOWZhNWYxOGM2MWEyNzAyNjJmMWQ=", "commit": {"author": {"name": "Ben Blum", "email": "bblum@andrew.cmu.edu", "date": "2012-08-10T02:31:05Z"}, "committer": {"name": "Ben Blum", "email": "bblum@andrew.cmu.edu", "date": "2012-08-10T03:23:17Z"}, "message": "Convert sync to the new struct syntax", "tree": {"sha": "e6f2665190e6f7718223d354d614aa20131e022c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e6f2665190e6f7718223d354d614aa20131e022c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4c9f16837249a7eeec129fa5f18c61a270262f1d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4c9f16837249a7eeec129fa5f18c61a270262f1d", "html_url": "https://github.com/rust-lang/rust/commit/4c9f16837249a7eeec129fa5f18c61a270262f1d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4c9f16837249a7eeec129fa5f18c61a270262f1d/comments", "author": {"login": "bblum", "id": 1820515, "node_id": "MDQ6VXNlcjE4MjA1MTU=", "avatar_url": "https://avatars.githubusercontent.com/u/1820515?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bblum", "html_url": "https://github.com/bblum", "followers_url": "https://api.github.com/users/bblum/followers", "following_url": "https://api.github.com/users/bblum/following{/other_user}", "gists_url": "https://api.github.com/users/bblum/gists{/gist_id}", "starred_url": "https://api.github.com/users/bblum/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bblum/subscriptions", "organizations_url": "https://api.github.com/users/bblum/orgs", "repos_url": "https://api.github.com/users/bblum/repos", "events_url": "https://api.github.com/users/bblum/events{/privacy}", "received_events_url": "https://api.github.com/users/bblum/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bblum", "id": 1820515, "node_id": "MDQ6VXNlcjE4MjA1MTU=", "avatar_url": "https://avatars.githubusercontent.com/u/1820515?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bblum", "html_url": "https://github.com/bblum", "followers_url": "https://api.github.com/users/bblum/followers", "following_url": "https://api.github.com/users/bblum/following{/other_user}", "gists_url": "https://api.github.com/users/bblum/gists{/gist_id}", "starred_url": "https://api.github.com/users/bblum/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bblum/subscriptions", "organizations_url": "https://api.github.com/users/bblum/orgs", "repos_url": "https://api.github.com/users/bblum/repos", "events_url": "https://api.github.com/users/bblum/events{/privacy}", "received_events_url": "https://api.github.com/users/bblum/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "770a21272b392aff2ad3468496c08ae983026298", "url": "https://api.github.com/repos/rust-lang/rust/commits/770a21272b392aff2ad3468496c08ae983026298", "html_url": "https://github.com/rust-lang/rust/commit/770a21272b392aff2ad3468496c08ae983026298"}], "stats": {"total": 101, "additions": 51, "deletions": 50}, "files": [{"sha": "744744831178b1a26fb2b4008e7afeb3045716be", "filename": "src/libcore/sync.rs", "status": "modified", "additions": 50, "deletions": 49, "changes": 99, "blob_url": "https://github.com/rust-lang/rust/blob/4c9f16837249a7eeec129fa5f18c61a270262f1d/src%2Flibcore%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c9f16837249a7eeec129fa5f18c61a270262f1d/src%2Flibcore%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fsync.rs?ref=4c9f16837249a7eeec129fa5f18c61a270262f1d", "patch": "@@ -5,10 +5,7 @@\n  * in std.\n  */\n \n-export condvar;\n-export semaphore, new_semaphore;\n-export mutex, new_mutex;\n-export rwlock;\n+export condvar, semaphore, mutex, rwlock;\n \n // FIXME (#3119) This shouldn't be a thing exported from core.\n import arc::exclusive;\n@@ -21,8 +18,8 @@ import arc::exclusive;\n type wait_end = pipes::port<()>;\n type signal_end = pipes::chan<()>;\n // A doubly-ended queue of waiting tasks.\n-type waitqueue = { head: pipes::port<signal_end>,\n-                   tail: pipes::chan<signal_end> };\n+struct waitqueue { head: pipes::port<signal_end>;\n+                   tail: pipes::chan<signal_end>; }\n \n // Signals one live task from the queue.\n fn signal_waitqueue(q: &waitqueue) -> bool {\n@@ -51,23 +48,25 @@ fn broadcast_waitqueue(q: &waitqueue) -> uint {\n }\n \n // The building-block used to make semaphores, mutexes, and rwlocks.\n-enum sem<Q: send> = exclusive<{\n-    mut count: int,\n-    waiters:   waitqueue,\n+struct sem_inner<Q> {\n+    mut count: int;\n+    waiters:   waitqueue;\n     // Can be either unit or another waitqueue. Some sems shouldn't come with\n     // a condition variable attached, others should.\n-    blocked:   Q,\n-}>;\n+    blocked:   Q;\n+}\n+enum sem<Q: send> = exclusive<sem_inner<Q>>;\n \n fn new_sem<Q: send>(count: int, +q: Q) -> sem<Q> {\n     let (wait_tail, wait_head)  = pipes::stream();\n-    sem(exclusive({ mut count: count,\n-                    waiters: { head: wait_head, tail: wait_tail },\n-                    blocked: q }))\n+    sem(exclusive(sem_inner {\n+        mut count: count,\n+        waiters: waitqueue { head: wait_head, tail: wait_tail },\n+        blocked: q }))\n }\n fn new_sem_and_signal(count: int) -> sem<waitqueue> {\n     let (block_tail, block_head) = pipes::stream();\n-    new_sem(count, { head: block_head, tail: block_tail })\n+    new_sem(count, waitqueue { head: block_head, tail: block_tail })\n }\n \n impl<Q: send> &sem<Q> {\n@@ -143,7 +142,7 @@ struct sem_and_signal_release {\n }\n \n /// A mechanism for atomic-unlock-and-deschedule blocking and signalling.\n-enum condvar = &sem<waitqueue>;\n+struct condvar { priv sem: &sem<waitqueue>; }\n \n impl condvar {\n     /// Atomically drop the associated lock, and block until a signal is sent.\n@@ -158,10 +157,10 @@ impl condvar {\n                 // killed before or after enqueueing. Deciding whether to\n                 // unkillably reacquire the lock needs to happen atomically\n                 // wrt enqueuing.\n-                reacquire = some(sem_and_signal_reacquire(*self));\n+                reacquire = some(sem_and_signal_reacquire(self.sem));\n \n                 // Release lock, 'atomically' enqueuing ourselves in so doing.\n-                do (***self).with |state| {\n+                do (**self.sem).with |state| {\n                     // Drop the lock.\n                     // FIXME(#3145) investigate why factoring doesn't compile.\n                     state.count += 1;\n@@ -196,7 +195,7 @@ impl condvar {\n     /// Wake up a blocked task. Returns false if there was no blocked task.\n     fn signal() -> bool {\n         unsafe {\n-            do (***self).with |state| {\n+            do (**self.sem).with |state| {\n                 signal_waitqueue(&state.blocked)\n             }\n         }\n@@ -205,7 +204,7 @@ impl condvar {\n     /// Wake up all blocked tasks. Returns the number of tasks woken.\n     fn broadcast() -> uint {\n         unsafe {\n-            do (***self).with |state| {\n+            do (**self.sem).with |state| {\n                 // FIXME(#3145) fix :broadcast_heavy\n                 broadcast_waitqueue(&state.blocked)\n             }\n@@ -215,7 +214,7 @@ impl condvar {\n \n impl &sem<waitqueue> {\n     fn access_cond<U>(blk: fn(condvar) -> U) -> U {\n-        do self.access { blk(condvar(self)) }\n+        do self.access { blk(condvar { sem: self }) }\n     }\n }\n \n@@ -224,30 +223,32 @@ impl &sem<waitqueue> {\n  ****************************************************************************/\n \n /// A counting, blocking, bounded-waiting semaphore.\n-enum semaphore = sem<()>;\n+struct semaphore { priv sem: sem<()>; }\n \n /// Create a new semaphore with the specified count.\n-fn new_semaphore(count: int) -> semaphore { semaphore(new_sem(count, ())) }\n+fn semaphore(count: int) -> semaphore {\n+    semaphore { sem: new_sem(count, ()) }\n+}\n \n impl &semaphore {\n     /// Create a new handle to the semaphore.\n-    fn clone() -> semaphore { semaphore(sem((***self).clone())) }\n+    fn clone() -> semaphore { semaphore { sem: sem((*self.sem).clone()) } }\n \n     /**\n      * Acquire a resource represented by the semaphore. Blocks if necessary\n      * until resource(s) become available.\n      */\n-    fn acquire() { (&**self).acquire() }\n+    fn acquire() { (&self.sem).acquire() }\n \n     /**\n      * Release a held resource represented by the semaphore. Wakes a blocked\n      * contending task, if any exist. Won't block the caller.\n      */\n-    fn release() { (&**self).release() }\n+    fn release() { (&self.sem).release() }\n \n     /// Run a function with ownership of one of the semaphore's resources.\n     // FIXME(#3145): figure out whether or not this should get exported.\n-    fn access<U>(blk: fn() -> U) -> U { (&**self).access(blk) }\n+    fn access<U>(blk: fn() -> U) -> U { (&self.sem).access(blk) }\n }\n \n /****************************************************************************\n@@ -259,21 +260,21 @@ impl &semaphore {\n  * FIFO condition variable.\n  * FIXME(#3145): document killability\n  */\n-enum mutex = sem<waitqueue>;\n+struct mutex { priv sem: sem<waitqueue>; }\n \n /// Create a new mutex.\n-fn new_mutex() -> mutex { mutex(new_sem_and_signal(1)) }\n+fn mutex() -> mutex { mutex { sem: new_sem_and_signal(1) } }\n \n impl &mutex {\n     /// Create a new handle to the mutex.\n-    fn clone() -> mutex { mutex(sem((***self).clone())) }\n+    fn clone() -> mutex { mutex { sem: sem((*self.sem).clone()) } }\n \n     /// Run a function with ownership of the mutex.\n-    fn lock<U>(blk: fn() -> U) -> U { (&**self).access(blk) }\n+    fn lock<U>(blk: fn() -> U) -> U { (&self.sem).access(blk) }\n \n     /// Run a function with ownership of the mutex and a handle to a condvar.\n     fn lock_cond<U>(blk: fn(condvar) -> U) -> U {\n-        (&**self).access_cond(blk)\n+        (&self.sem).access_cond(blk)\n     }\n }\n \n@@ -290,14 +291,14 @@ struct rwlock_inner {\n \n /// A blocking, no-starvation, reader-writer lock with an associated condvar.\n struct rwlock {\n-    order_lock:  semaphore;\n-    access_lock: sem<waitqueue>;\n-    state:       arc::exclusive<rwlock_inner>;\n+    /* priv */ order_lock:  semaphore;\n+    /* priv */ access_lock: sem<waitqueue>;\n+    /* priv */ state:       arc::exclusive<rwlock_inner>;\n }\n \n /// Create a new rwlock.\n fn rwlock() -> rwlock {\n-    rwlock { order_lock: new_semaphore(1), access_lock: new_sem_and_signal(1),\n+    rwlock { order_lock: semaphore(1), access_lock: new_sem_and_signal(1),\n              state: arc::exclusive(rwlock_inner { read_mode:  false,\n                                                   read_count: 0 }) }\n }\n@@ -399,19 +400,19 @@ mod tests {\n      ************************************************************************/\n     #[test]\n     fn test_sem_acquire_release() {\n-        let s = ~new_semaphore(1);\n+        let s = ~semaphore(1);\n         s.acquire();\n         s.release();\n         s.acquire();\n     }\n     #[test]\n     fn test_sem_basic() {\n-        let s = ~new_semaphore(1);\n+        let s = ~semaphore(1);\n         do s.access { }\n     }\n     #[test]\n     fn test_sem_as_mutex() {\n-        let s = ~new_semaphore(1);\n+        let s = ~semaphore(1);\n         let s2 = ~s.clone();\n         do task::spawn {\n             do s2.access {\n@@ -426,7 +427,7 @@ mod tests {\n     fn test_sem_as_cvar() {\n         /* Child waits and parent signals */\n         let (c,p) = pipes::stream();\n-        let s = ~new_semaphore(0);\n+        let s = ~semaphore(0);\n         let s2 = ~s.clone();\n         do task::spawn {\n             s2.acquire();\n@@ -438,7 +439,7 @@ mod tests {\n \n         /* Parent waits and child signals */\n         let (c,p) = pipes::stream();\n-        let s = ~new_semaphore(0);\n+        let s = ~semaphore(0);\n         let s2 = ~s.clone();\n         do task::spawn {\n             for 5.times { task::yield(); }\n@@ -452,7 +453,7 @@ mod tests {\n     fn test_sem_multi_resource() {\n         // Parent and child both get in the critical section at the same\n         // time, and shake hands.\n-        let s = ~new_semaphore(2);\n+        let s = ~semaphore(2);\n         let s2 = ~s.clone();\n         let (c1,p1) = pipes::stream();\n         let (c2,p2) = pipes::stream();\n@@ -472,7 +473,7 @@ mod tests {\n         // Force the runtime to schedule two threads on the same sched_loop.\n         // When one blocks, it should schedule the other one.\n         do task::spawn_sched(task::manual_threads(1)) {\n-            let s = ~new_semaphore(1);\n+            let s = ~semaphore(1);\n             let s2 = ~s.clone();\n             let (c,p) = pipes::stream();\n             let child_data = ~mut some((s2,c));\n@@ -497,7 +498,7 @@ mod tests {\n         // Unsafely achieve shared state, and do the textbook\n         // \"load tmp <- ptr; inc tmp; store ptr <- tmp\" dance.\n         let (c,p) = pipes::stream();\n-        let m = ~new_mutex();\n+        let m = ~mutex();\n         let m2 = ~m.clone();\n         let sharedstate = ~0;\n         let ptr = ptr::addr_of(*sharedstate);\n@@ -523,7 +524,7 @@ mod tests {\n     }\n     #[test]\n     fn test_mutex_cond_wait() {\n-        let m = ~new_mutex();\n+        let m = ~mutex();\n \n         // Child wakes up parent\n         do m.lock_cond |cond| {\n@@ -555,7 +556,7 @@ mod tests {\n     }\n     #[cfg(test)]\n     fn test_mutex_cond_broadcast_helper(num_waiters: uint) {\n-        let m = ~new_mutex();\n+        let m = ~mutex();\n         let mut ports = ~[];\n \n         for num_waiters.times {\n@@ -590,7 +591,7 @@ mod tests {\n     }\n     #[test]\n     fn test_mutex_cond_no_waiter() {\n-        let m = ~new_mutex();\n+        let m = ~mutex();\n         let m2 = ~m.clone();\n         do task::try {\n             do m.lock_cond |_x| { }\n@@ -602,7 +603,7 @@ mod tests {\n     #[test] #[ignore(cfg(windows))]\n     fn test_mutex_killed_simple() {\n         // Mutex must get automatically unlocked if failed/killed within.\n-        let m = ~new_mutex();\n+        let m = ~mutex();\n         let m2 = ~m.clone();\n \n         let result: result::result<(),()> = do task::try {\n@@ -618,7 +619,7 @@ mod tests {\n     fn test_mutex_killed_cond() {\n         // Getting killed during cond wait must not corrupt the mutex while\n         // unwinding (e.g. double unlock).\n-        let m = ~new_mutex();\n+        let m = ~mutex();\n         let m2 = ~m.clone();\n \n         let result: result::result<(),()> = do task::try {"}, {"sha": "c32a5bdf77b471a9428f6f3d3848840c99d67299", "filename": "src/test/compile-fail/sync-cond-shouldnt-escape.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4c9f16837249a7eeec129fa5f18c61a270262f1d/src%2Ftest%2Fcompile-fail%2Fsync-cond-shouldnt-escape.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c9f16837249a7eeec129fa5f18c61a270262f1d/src%2Ftest%2Fcompile-fail%2Fsync-cond-shouldnt-escape.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fsync-cond-shouldnt-escape.rs?ref=4c9f16837249a7eeec129fa5f18c61a270262f1d", "patch": "@@ -1,6 +1,6 @@\n // error-pattern: reference is not valid outside of its lifetime\n fn main() {\n-    let m = ~sync::new_mutex();\n+    let m = ~sync::mutex();\n     let mut cond = none;\n     do m.lock_cond |c| {\n         cond = some(c);"}]}