{"sha": "decfd28bd14b56befa17257694caacc57a090939", "node_id": "MDY6Q29tbWl0NzI0NzEyOmRlY2ZkMjhiZDE0YjU2YmVmYTE3MjU3Njk0Y2FhY2M1N2EwOTA5Mzk=", "commit": {"author": {"name": "Ekaterina Babshukova", "email": "ekaterina.babshukova@yandex.ru", "date": "2019-10-22T20:46:53Z"}, "committer": {"name": "Ekaterina Babshukova", "email": "ekaterina.babshukova@yandex.ru", "date": "2019-10-22T21:35:06Z"}, "message": "some fixes, add docs", "tree": {"sha": "cdf5a5b39600b41a9eee301b9760cde1282aeb33", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/cdf5a5b39600b41a9eee301b9760cde1282aeb33"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/decfd28bd14b56befa17257694caacc57a090939", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/decfd28bd14b56befa17257694caacc57a090939", "html_url": "https://github.com/rust-lang/rust/commit/decfd28bd14b56befa17257694caacc57a090939", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/decfd28bd14b56befa17257694caacc57a090939/comments", "author": {"login": "viorina", "id": 6714973, "node_id": "MDQ6VXNlcjY3MTQ5NzM=", "avatar_url": "https://avatars.githubusercontent.com/u/6714973?v=4", "gravatar_id": "", "url": "https://api.github.com/users/viorina", "html_url": "https://github.com/viorina", "followers_url": "https://api.github.com/users/viorina/followers", "following_url": "https://api.github.com/users/viorina/following{/other_user}", "gists_url": "https://api.github.com/users/viorina/gists{/gist_id}", "starred_url": "https://api.github.com/users/viorina/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/viorina/subscriptions", "organizations_url": "https://api.github.com/users/viorina/orgs", "repos_url": "https://api.github.com/users/viorina/repos", "events_url": "https://api.github.com/users/viorina/events{/privacy}", "received_events_url": "https://api.github.com/users/viorina/received_events", "type": "User", "site_admin": false}, "committer": {"login": "viorina", "id": 6714973, "node_id": "MDQ6VXNlcjY3MTQ5NzM=", "avatar_url": "https://avatars.githubusercontent.com/u/6714973?v=4", "gravatar_id": "", "url": "https://api.github.com/users/viorina", "html_url": "https://github.com/viorina", "followers_url": "https://api.github.com/users/viorina/followers", "following_url": "https://api.github.com/users/viorina/following{/other_user}", "gists_url": "https://api.github.com/users/viorina/gists{/gist_id}", "starred_url": "https://api.github.com/users/viorina/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/viorina/subscriptions", "organizations_url": "https://api.github.com/users/viorina/orgs", "repos_url": "https://api.github.com/users/viorina/repos", "events_url": "https://api.github.com/users/viorina/events{/privacy}", "received_events_url": "https://api.github.com/users/viorina/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b5a3ee93e24931c8bba628ddc7be4f098a19a326", "url": "https://api.github.com/repos/rust-lang/rust/commits/b5a3ee93e24931c8bba628ddc7be4f098a19a326", "html_url": "https://github.com/rust-lang/rust/commit/b5a3ee93e24931c8bba628ddc7be4f098a19a326"}], "stats": {"total": 145, "additions": 73, "deletions": 72}, "files": [{"sha": "1f3fa6c57becfad02ff35d142a2041f214bfd8f5", "filename": "crates/ra_ide_api/src/goto_definition.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/decfd28bd14b56befa17257694caacc57a090939/crates%2Fra_ide_api%2Fsrc%2Fgoto_definition.rs", "raw_url": "https://github.com/rust-lang/rust/raw/decfd28bd14b56befa17257694caacc57a090939/crates%2Fra_ide_api%2Fsrc%2Fgoto_definition.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_api%2Fsrc%2Fgoto_definition.rs?ref=decfd28bd14b56befa17257694caacc57a090939", "patch": "@@ -206,7 +206,7 @@ fn named_target(file_id: FileId, node: &SyntaxNode) -> Option<NavigationTarget>\n \n #[cfg(test)]\n mod tests {\n-    // use test_utils::covers;\n+    use test_utils::covers;\n \n     use crate::mock_analysis::analysis_and_position;\n \n@@ -274,7 +274,7 @@ mod tests {\n \n     #[test]\n     fn goto_definition_works_for_macros() {\n-        // covers!(goto_definition_works_for_macros);\n+        covers!(goto_definition_works_for_macros);\n         check_goto(\n             \"\n             //- /lib.rs\n@@ -294,7 +294,7 @@ mod tests {\n \n     #[test]\n     fn goto_definition_works_for_macros_from_other_crates() {\n-        // covers!(goto_definition_works_for_macros);\n+        covers!(goto_definition_works_for_macros);\n         check_goto(\n             \"\n             //- /lib.rs\n@@ -317,7 +317,7 @@ mod tests {\n \n     #[test]\n     fn goto_definition_works_for_methods() {\n-        // covers!(goto_definition_works_for_methods);\n+        covers!(goto_definition_works_for_methods);\n         check_goto(\n             \"\n             //- /lib.rs\n@@ -336,7 +336,7 @@ mod tests {\n \n     #[test]\n     fn goto_definition_works_for_fields() {\n-        // covers!(goto_definition_works_for_fields);\n+        covers!(goto_definition_works_for_fields);\n         check_goto(\n             \"\n             //- /lib.rs\n@@ -354,7 +354,7 @@ mod tests {\n \n     #[test]\n     fn goto_definition_works_for_record_fields() {\n-        // covers!(goto_definition_works_for_record_fields);\n+        covers!(goto_definition_works_for_record_fields);\n         check_goto(\n             \"\n             //- /lib.rs"}, {"sha": "f35d835acf1bcc6bed7bb197e0ca2313ba1d3965", "filename": "crates/ra_ide_api/src/references.rs", "status": "modified", "additions": 20, "deletions": 19, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/decfd28bd14b56befa17257694caacc57a090939/crates%2Fra_ide_api%2Fsrc%2Freferences.rs", "raw_url": "https://github.com/rust-lang/rust/raw/decfd28bd14b56befa17257694caacc57a090939/crates%2Fra_ide_api%2Fsrc%2Freferences.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_api%2Fsrc%2Freferences.rs?ref=decfd28bd14b56befa17257694caacc57a090939", "patch": "@@ -1,4 +1,13 @@\n-//! FIXME: write short doc here\n+//! This module implements a reference search.\n+//! First, the element at the cursor position must be either an `ast::Name`\n+//! or `ast::NameRef`. If it's a `ast::NameRef`, at the classification step we\n+//! try to resolve the direct tree parent of this element, otherwise we\n+//! already have a definition and just need to get its HIR together with\n+//! some information that is needed for futher steps of searching.\n+//! After that, we collect files that might contain references and look\n+//! for text occurrences of the identifier. If there's an `ast::NameRef`\n+//! at the index that the match starts at and its tree parent is\n+//! resolved to the search element definition, we get a reference.\n \n mod classify;\n mod name_definition;\n@@ -9,7 +18,7 @@ use once_cell::unsync::Lazy;\n use ra_db::{SourceDatabase, SourceDatabaseExt};\n use ra_syntax::{algo::find_node_at_offset, ast, AstNode, SourceFile, SyntaxNode, TextUnit};\n \n-use crate::{db::RootDatabase, FileId, FilePosition, FileRange, NavigationTarget, RangeInfo};\n+use crate::{db::RootDatabase, FilePosition, FileRange, NavigationTarget, RangeInfo};\n \n pub(crate) use self::{\n     classify::{classify_name, classify_name_ref},\n@@ -102,16 +111,7 @@ fn process_definition(db: &RootDatabase, def: NameDefinition, name: String) -> V\n     let scope = def.search_scope(db);\n     let mut refs = vec![];\n \n-    let is_match = |file_id: FileId, name_ref: &ast::NameRef| -> bool {\n-        let classified = classify_name_ref(db, file_id, &name_ref);\n-        if let Some(d) = classified {\n-            d == def\n-        } else {\n-            false\n-        }\n-    };\n-\n-    for (file_id, text_range) in scope {\n+    for (file_id, search_range) in scope {\n         let text = db.file_text(file_id);\n         let parse = Lazy::new(|| SourceFile::parse(&text));\n \n@@ -122,19 +122,20 @@ fn process_definition(db: &RootDatabase, def: NameDefinition, name: String) -> V\n                 find_node_at_offset::<ast::NameRef>(parse.tree().syntax(), offset)\n             {\n                 let range = name_ref.syntax().text_range();\n-\n-                if let Some(text_range) = text_range {\n-                    if range.is_subrange(&text_range) && is_match(file_id, &name_ref) {\n+                if let Some(search_range) = search_range {\n+                    if !range.is_subrange(&search_range) {\n+                        continue;\n+                    }\n+                }\n+                if let Some(d) = classify_name_ref(db, file_id, &name_ref) {\n+                    if d == def {\n                         refs.push(FileRange { file_id, range });\n                     }\n-                } else if is_match(file_id, &name_ref) {\n-                    refs.push(FileRange { file_id, range });\n                 }\n             }\n         }\n     }\n-\n-    return refs;\n+    refs\n }\n \n #[cfg(test)]"}, {"sha": "c8daff9b1bd91a45c71d29c0468495fd2e27f0a1", "filename": "crates/ra_ide_api/src/references/classify.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/decfd28bd14b56befa17257694caacc57a090939/crates%2Fra_ide_api%2Fsrc%2Freferences%2Fclassify.rs", "raw_url": "https://github.com/rust-lang/rust/raw/decfd28bd14b56befa17257694caacc57a090939/crates%2Fra_ide_api%2Fsrc%2Freferences%2Fclassify.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_api%2Fsrc%2Freferences%2Fclassify.rs?ref=decfd28bd14b56befa17257694caacc57a090939", "patch": "@@ -1,8 +1,9 @@\n-//! FIXME: write short doc here\n+//! Functions that are used to classify an element from its definition or reference.\n \n use hir::{Either, FromSource, Module, ModuleSource, Path, PathResolution, Source, SourceAnalyzer};\n use ra_db::FileId;\n use ra_syntax::{ast, match_ast, AstNode, AstPtr};\n+use test_utils::tested_by;\n \n use super::{\n     name_definition::{from_assoc_item, from_module_def, from_pat, from_struct_field},\n@@ -111,18 +112,21 @@ pub(crate) fn classify_name_ref(\n     let analyzer = SourceAnalyzer::new(db, file_id, name_ref.syntax(), None);\n \n     if let Some(method_call) = ast::MethodCallExpr::cast(parent.clone()) {\n+        tested_by!(goto_definition_works_for_methods);\n         if let Some(func) = analyzer.resolve_method_call(&method_call) {\n             return Some(from_assoc_item(db, func.into()));\n         }\n     }\n \n     if let Some(field_expr) = ast::FieldExpr::cast(parent.clone()) {\n+        tested_by!(goto_definition_works_for_fields);\n         if let Some(field) = analyzer.resolve_field(&field_expr) {\n             return Some(from_struct_field(db, field));\n         }\n     }\n \n     if let Some(record_field) = ast::RecordField::cast(parent.clone()) {\n+        tested_by!(goto_definition_works_for_record_fields);\n         if let Some(record_lit) = record_field.syntax().ancestors().find_map(ast::RecordLit::cast) {\n             let variant_def = analyzer.resolve_record_literal(&record_lit)?;\n             let hir_path = Path::from_name_ref(name_ref);\n@@ -139,6 +143,7 @@ pub(crate) fn classify_name_ref(\n     let visibility = None;\n \n     if let Some(macro_call) = parent.ancestors().find_map(ast::MacroCall::cast) {\n+        tested_by!(goto_definition_works_for_macros);\n         if let Some(macro_def) = analyzer.resolve_macro_call(db, &macro_call) {\n             let kind = NameKind::Macro(macro_def);\n             return Some(NameDefinition { kind, container, visibility });\n@@ -152,7 +157,6 @@ pub(crate) fn classify_name_ref(\n         AssocItem(item) => Some(from_assoc_item(db, item)),\n         LocalBinding(Either::A(pat)) => from_pat(db, file_id, pat),\n         LocalBinding(Either::B(par)) => {\n-            // Not really supported\n             let kind = NameKind::SelfParam(par);\n             Some(NameDefinition { kind, container, visibility })\n         }"}, {"sha": "4580bc789955da96c43839125d787956d46a4ca9", "filename": "crates/ra_ide_api/src/references/name_definition.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/decfd28bd14b56befa17257694caacc57a090939/crates%2Fra_ide_api%2Fsrc%2Freferences%2Fname_definition.rs", "raw_url": "https://github.com/rust-lang/rust/raw/decfd28bd14b56befa17257694caacc57a090939/crates%2Fra_ide_api%2Fsrc%2Freferences%2Fname_definition.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_api%2Fsrc%2Freferences%2Fname_definition.rs?ref=decfd28bd14b56befa17257694caacc57a090939", "patch": "@@ -1,4 +1,7 @@\n-//! FIXME: write short doc here\n+//! `NameDefinition` keeps information about the element we want to search references for.\n+//! The element is represented by `NameKind`. It's located inside some `container` and\n+//! has a `visibility`, which defines a search scope.\n+//! Note that the reference search is possible for not all of the classified items.\n \n use hir::{\n     db::AstDatabase, Adt, AssocItem, DefWithBody, FromSource, HasSource, HirFileId, MacroDef,"}, {"sha": "5cb69b8fcd12d98884d18a1059918c63f840d91d", "filename": "crates/ra_ide_api/src/references/search_scope.rs", "status": "modified", "additions": 37, "deletions": 44, "changes": 81, "blob_url": "https://github.com/rust-lang/rust/blob/decfd28bd14b56befa17257694caacc57a090939/crates%2Fra_ide_api%2Fsrc%2Freferences%2Fsearch_scope.rs", "raw_url": "https://github.com/rust-lang/rust/raw/decfd28bd14b56befa17257694caacc57a090939/crates%2Fra_ide_api%2Fsrc%2Freferences%2Fsearch_scope.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_api%2Fsrc%2Freferences%2Fsearch_scope.rs?ref=decfd28bd14b56befa17257694caacc57a090939", "patch": "@@ -1,99 +1,92 @@\n-//! FIXME: write short doc here\n-\n-use std::collections::HashSet;\n+//! Generally, `search_scope` returns files that might contain references for the element.\n+//! For `pub(crate)` things it's a crate, for `pub` things it's a crate and dependant crates.\n+//! In some cases, the location of the references is known to within a `TextRange`,\n+//! e.g. for things like local variables.\n \n use hir::{DefWithBody, HasSource, ModuleSource};\n use ra_db::{FileId, SourceDatabase, SourceDatabaseExt};\n use ra_syntax::{AstNode, TextRange};\n+use rustc_hash::FxHashSet;\n \n use crate::db::RootDatabase;\n \n use super::{NameDefinition, NameKind};\n \n impl NameDefinition {\n-    pub(crate) fn search_scope(&self, db: &RootDatabase) -> HashSet<(FileId, Option<TextRange>)> {\n+    pub(crate) fn search_scope(&self, db: &RootDatabase) -> FxHashSet<(FileId, Option<TextRange>)> {\n         let module_src = self.container.definition_source(db);\n         let file_id = module_src.file_id.original_file(db);\n \n         if let NameKind::Pat((def, _)) = self.kind {\n+            let mut res = FxHashSet::default();\n             let range = match def {\n                 DefWithBody::Function(f) => f.source(db).ast.syntax().text_range(),\n                 DefWithBody::Const(c) => c.source(db).ast.syntax().text_range(),\n                 DefWithBody::Static(s) => s.source(db).ast.syntax().text_range(),\n             };\n-            return [(file_id, Some(range))].iter().cloned().collect();\n+            res.insert((file_id, Some(range)));\n+            return res;\n         }\n \n-        if let Some(ref vis) = self.visibility {\n-            let vis = vis.syntax().to_string();\n-\n-            // FIXME: add \"pub(in path)\"\n-\n-            if vis.as_str() == \"pub(super)\" {\n-                if let Some(parent_module) = self.container.parent(db) {\n-                    let mut files = HashSet::new();\n+        let vis =\n+            self.visibility.as_ref().map(|v| v.syntax().to_string()).unwrap_or(\"\".to_string());\n \n-                    let parent_src = parent_module.definition_source(db);\n-                    let file_id = parent_src.file_id.original_file(db);\n+        if vis.as_str() == \"pub(super)\" {\n+            if let Some(parent_module) = self.container.parent(db) {\n+                let mut files = FxHashSet::default();\n+                let parent_src = parent_module.definition_source(db);\n+                let file_id = parent_src.file_id.original_file(db);\n \n-                    match parent_src.ast {\n-                        ModuleSource::Module(m) => {\n-                            let range = Some(m.syntax().text_range());\n-                            files.insert((file_id, range));\n-                        }\n-                        ModuleSource::SourceFile(_) => {\n-                            files.insert((file_id, None));\n-                            files.extend(\n-                                parent_module\n-                                    .children(db)\n-                                    .map(|m| {\n-                                        let src = m.definition_source(db);\n-                                        (src.file_id.original_file(db), None)\n-                                    })\n-                                    .collect::<HashSet<_>>(),\n-                            );\n-                        }\n+                match parent_src.ast {\n+                    ModuleSource::Module(m) => {\n+                        let range = Some(m.syntax().text_range());\n+                        files.insert((file_id, range));\n+                    }\n+                    ModuleSource::SourceFile(_) => {\n+                        files.insert((file_id, None));\n+                        files.extend(parent_module.children(db).map(|m| {\n+                            let src = m.definition_source(db);\n+                            (src.file_id.original_file(db), None)\n+                        }));\n                     }\n-                    return files;\n-                } else {\n-                    let range = match module_src.ast {\n-                        ModuleSource::Module(m) => Some(m.syntax().text_range()),\n-                        ModuleSource::SourceFile(_) => None,\n-                    };\n-                    return [(file_id, range)].iter().cloned().collect();\n                 }\n+                return files;\n             }\n+        }\n \n+        if vis.as_str() != \"\" {\n             let source_root_id = db.file_source_root(file_id);\n             let source_root = db.source_root(source_root_id);\n-            let mut files = source_root.walk().map(|id| (id.into(), None)).collect::<HashSet<_>>();\n+            let mut files =\n+                source_root.walk().map(|id| (id.into(), None)).collect::<FxHashSet<_>>();\n+\n+            // FIXME: add \"pub(in path)\"\n \n             if vis.as_str() == \"pub(crate)\" {\n                 return files;\n             }\n             if vis.as_str() == \"pub\" {\n                 let krate = self.container.krate(db).unwrap();\n                 let crate_graph = db.crate_graph();\n-\n                 for crate_id in crate_graph.iter() {\n                     let mut crate_deps = crate_graph.dependencies(crate_id);\n-\n                     if crate_deps.any(|dep| dep.crate_id() == krate.crate_id()) {\n                         let root_file = crate_graph.crate_root(crate_id);\n                         let source_root_id = db.file_source_root(root_file);\n                         let source_root = db.source_root(source_root_id);\n                         files.extend(source_root.walk().map(|id| (id.into(), None)));\n                     }\n                 }\n-\n                 return files;\n             }\n         }\n \n+        let mut res = FxHashSet::default();\n         let range = match module_src.ast {\n             ModuleSource::Module(m) => Some(m.syntax().text_range()),\n             ModuleSource::SourceFile(_) => None,\n         };\n-        [(file_id, range)].iter().cloned().collect()\n+        res.insert((file_id, range));\n+        res\n     }\n }"}]}