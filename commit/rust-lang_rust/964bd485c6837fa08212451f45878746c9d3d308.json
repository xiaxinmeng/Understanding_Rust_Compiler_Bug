{"sha": "964bd485c6837fa08212451f45878746c9d3d308", "node_id": "MDY6Q29tbWl0NzI0NzEyOjk2NGJkNDg1YzY4MzdmYTA4MjEyNDUxZjQ1ODc4NzQ2YzlkM2QzMDg=", "commit": {"author": {"name": "Marijn Haverbeke", "email": "marijnh@gmail.com", "date": "2012-01-30T10:36:18Z"}, "committer": {"name": "Marijn Haverbeke", "email": "marijnh@gmail.com", "date": "2012-01-30T10:37:52Z"}, "message": "Revert self types", "tree": {"sha": "b0c7848e98af74f15fce91804989f3d8d3e43ed7", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b0c7848e98af74f15fce91804989f3d8d3e43ed7"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/964bd485c6837fa08212451f45878746c9d3d308", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/964bd485c6837fa08212451f45878746c9d3d308", "html_url": "https://github.com/rust-lang/rust/commit/964bd485c6837fa08212451f45878746c9d3d308", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/964bd485c6837fa08212451f45878746c9d3d308/comments", "author": {"login": "marijnh", "id": 144427, "node_id": "MDQ6VXNlcjE0NDQyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/144427?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marijnh", "html_url": "https://github.com/marijnh", "followers_url": "https://api.github.com/users/marijnh/followers", "following_url": "https://api.github.com/users/marijnh/following{/other_user}", "gists_url": "https://api.github.com/users/marijnh/gists{/gist_id}", "starred_url": "https://api.github.com/users/marijnh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marijnh/subscriptions", "organizations_url": "https://api.github.com/users/marijnh/orgs", "repos_url": "https://api.github.com/users/marijnh/repos", "events_url": "https://api.github.com/users/marijnh/events{/privacy}", "received_events_url": "https://api.github.com/users/marijnh/received_events", "type": "User", "site_admin": false}, "committer": {"login": "marijnh", "id": 144427, "node_id": "MDQ6VXNlcjE0NDQyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/144427?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marijnh", "html_url": "https://github.com/marijnh", "followers_url": "https://api.github.com/users/marijnh/followers", "following_url": "https://api.github.com/users/marijnh/following{/other_user}", "gists_url": "https://api.github.com/users/marijnh/gists{/gist_id}", "starred_url": "https://api.github.com/users/marijnh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marijnh/subscriptions", "organizations_url": "https://api.github.com/users/marijnh/orgs", "repos_url": "https://api.github.com/users/marijnh/repos", "events_url": "https://api.github.com/users/marijnh/events{/privacy}", "received_events_url": "https://api.github.com/users/marijnh/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "98c3396ab68551156021b490cf0ffed9cf3a40e3", "url": "https://api.github.com/repos/rust-lang/rust/commits/98c3396ab68551156021b490cf0ffed9cf3a40e3", "html_url": "https://github.com/rust-lang/rust/commit/98c3396ab68551156021b490cf0ffed9cf3a40e3"}], "stats": {"total": 157, "additions": 60, "deletions": 97}, "files": [{"sha": "266167affd4333143ed78d0442c6a5c47f8f8887", "filename": "src/comp/metadata/decoder.rs", "status": "modified", "additions": 7, "deletions": 9, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/964bd485c6837fa08212451f45878746c9d3d308/src%2Fcomp%2Fmetadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/964bd485c6837fa08212451f45878746c9d3d308/src%2Fcomp%2Fmetadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmetadata%2Fdecoder.rs?ref=964bd485c6837fa08212451f45878746c9d3d308", "patch": "@@ -128,15 +128,14 @@ fn item_impl_iface(item: ebml::doc, tcx: ty::ctxt, cdata: cmd)\n     result\n }\n \n-fn item_ty_param_bounds(item: ebml::doc, tcx: ty::ctxt, cdata: cmd,\n-                        skip: bool) -> @[ty::param_bounds] {\n-    let bounds = [], skip = skip;\n+fn item_ty_param_bounds(item: ebml::doc, tcx: ty::ctxt, cdata: cmd)\n+    -> @[ty::param_bounds] {\n+    let bounds = [];\n     ebml::tagged_docs(item, tag_items_data_item_ty_param_bounds) {|p|\n         let bd = parse_bounds_data(p.data, p.start, cdata.cnum, tcx, {|did|\n             translate_def_id(cdata, did)\n         });\n-        if skip { skip = false; }\n-        else { bounds += [bd]; }\n+        bounds += [bd];\n     }\n     @bounds\n }\n@@ -216,9 +215,8 @@ fn get_type(cdata: cmd, id: ast::node_id, tcx: ty::ctxt)\n     -> ty::ty_param_bounds_and_ty {\n     let item = lookup_item(id, cdata.data);\n     let t = item_type(item, tcx, cdata);\n-    let family = item_family(item);\n-    let tp_bounds = if family_has_type_params(family) {\n-        item_ty_param_bounds(item, tcx, cdata, family == ('I' as u8))\n+    let tp_bounds = if family_has_type_params(item_family(item)) {\n+        item_ty_param_bounds(item, tcx, cdata)\n     } else { @[] };\n     ret {bounds: tp_bounds, ty: t};\n }\n@@ -301,7 +299,7 @@ fn get_iface_methods(cdata: cmd, id: ast::node_id, tcx: ty::ctxt)\n     let data = cdata.data;\n     let item = lookup_item(id, data), result = [];\n     ebml::tagged_docs(item, tag_item_method) {|mth|\n-        let bounds = item_ty_param_bounds(mth, tcx, cdata, false);\n+        let bounds = item_ty_param_bounds(mth, tcx, cdata);\n         let name = item_name(mth);\n         let ty = doc_type(mth, tcx, cdata);\n         let fty = alt ty::struct(tcx, ty) { ty::ty_fn(f) { f } };"}, {"sha": "20ceaf1a07850bd60a366b6d5e635ed9a25fb333", "filename": "src/comp/middle/resolve.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/964bd485c6837fa08212451f45878746c9d3d308/src%2Fcomp%2Fmiddle%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/964bd485c6837fa08212451f45878746c9d3d308/src%2Fcomp%2Fmiddle%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fresolve.rs?ref=964bd485c6837fa08212451f45878746c9d3d308", "patch": "@@ -999,7 +999,7 @@ fn lookup_in_ty_params(e: env, name: ident, ty_params: [ast::ty_param])\n         } { ret some(ast::def_ty_param(local_def(tp.id), n)); }\n         n += 1u;\n     }\n-    ret none;\n+    ret none::<def>;\n }\n \n fn lookup_in_pat(e: env, name: ident, pat: @ast::pat) -> option::t<def_id> {"}, {"sha": "541c9c72260c1f519c3cce6f6b916a4a3f9f6989", "filename": "src/comp/middle/trans/base.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/964bd485c6837fa08212451f45878746c9d3d308/src%2Fcomp%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/964bd485c6837fa08212451f45878746c9d3d308/src%2Fcomp%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans%2Fbase.rs?ref=964bd485c6837fa08212451f45878746c9d3d308", "patch": "@@ -881,7 +881,7 @@ fn linearize_ty_params(cx: @block_ctxt, t: ty::t) ->\n     }\n     let x = @{cx: cx, mutable vals: param_vals, mutable defs: param_defs};\n     let f = bind linearizer(x, _);\n-    ty::walk_ty(bcx_tcx(cx), t, f);\n+    ty::walk_ty(bcx_tcx(cx), f, t);\n     ret {params: x.defs, descs: x.vals};\n }\n "}, {"sha": "cfd66f5cb2a8b123dd78b8b0339dc82732987440", "filename": "src/comp/middle/ty.rs", "status": "modified", "additions": 18, "deletions": 13, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/964bd485c6837fa08212451f45878746c9d3d308/src%2Fcomp%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/964bd485c6837fa08212451f45878746c9d3d308/src%2Fcomp%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fty.rs?ref=964bd485c6837fa08212451f45878746c9d3d308", "patch": "@@ -664,33 +664,37 @@ pure fn ty_name(cx: ctxt, typ: t) -> option::t<@str> {\n     }\n }\n \n-fn walk_ty(cx: ctxt, ty: t, walker: fn(t)) {\n+\n+// Type folds\n+type ty_walk = fn@(t);\n+\n+fn walk_ty(cx: ctxt, walker: ty_walk, ty: t) {\n     alt struct(cx, ty) {\n       ty_nil | ty_bot | ty_bool | ty_int(_) | ty_uint(_) | ty_float(_) |\n       ty_str | ty_send_type | ty_type | ty_native(_) |\n       ty_opaque_closure_ptr(_) {\n         /* no-op */\n       }\n-      ty_box(tm) | ty_vec(tm) | ty_ptr(tm) { walk_ty(cx, tm.ty, walker); }\n+      ty_box(tm) | ty_vec(tm) | ty_ptr(tm) { walk_ty(cx, walker, tm.ty); }\n       ty_enum(_, subtys) | ty_iface(_, subtys) {\n-        for subty: t in subtys { walk_ty(cx, subty, walker); }\n+        for subty: t in subtys { walk_ty(cx, walker, subty); }\n       }\n       ty_rec(fields) {\n-        for fl: field in fields { walk_ty(cx, fl.mt.ty, walker); }\n+        for fl: field in fields { walk_ty(cx, walker, fl.mt.ty); }\n       }\n-      ty_tup(ts) { for tt in ts { walk_ty(cx, tt, walker); } }\n+      ty_tup(ts) { for tt in ts { walk_ty(cx, walker, tt); } }\n       ty_fn(f) {\n-        for a: arg in f.inputs { walk_ty(cx, a.ty, walker); }\n-        walk_ty(cx, f.output, walker);\n+        for a: arg in f.inputs { walk_ty(cx, walker, a.ty); }\n+        walk_ty(cx, walker, f.output);\n       }\n       ty_res(_, sub, tps) {\n-        walk_ty(cx, sub, walker);\n-        for tp: t in tps { walk_ty(cx, tp, walker); }\n+        walk_ty(cx, walker, sub);\n+        for tp: t in tps { walk_ty(cx, walker, tp); }\n       }\n-      ty_constr(sub, _) { walk_ty(cx, sub, walker); }\n+      ty_constr(sub, _) { walk_ty(cx, walker, sub); }\n       ty_var(_) {/* no-op */ }\n       ty_param(_, _) {/* no-op */ }\n-      ty_uniq(tm) { walk_ty(cx, tm.ty, walker); }\n+      ty_uniq(tm) { walk_ty(cx, walker, tm.ty); }\n     }\n     walker(ty);\n }\n@@ -1248,7 +1252,7 @@ fn vars_in_type(cx: ctxt, ty: t) -> [int] {\n         alt struct(cx, ty) { ty_var(v) { *vars += [v]; } _ { } }\n     }\n     let rslt: @mutable [int] = @mutable [];\n-    walk_ty(cx, ty) {|t| collect_var(cx, rslt, t)}\n+    walk_ty(cx, bind collect_var(cx, rslt, _), ty);\n     // Works because of a \"convenient\" bug that lets us\n     // return a mutable vec as if it's immutable\n     ret *rslt;\n@@ -1503,7 +1507,7 @@ fn count_ty_params(cx: ctxt, ty: t) -> uint {\n     }\n     let param_indices: @mutable [uint] = @mutable [];\n     let f = bind counter(cx, param_indices, _);\n-    walk_ty(cx, ty, f);\n+    walk_ty(cx, f, ty);\n     ret vec::len::<uint>(*param_indices);\n }\n \n@@ -2647,6 +2651,7 @@ fn lookup_item_type(cx: ctxt, did: ast::def_id) -> ty_param_bounds_and_ty {\n     if did.crate == ast::local_crate {\n         // The item is in this crate. The caller should have added it to the\n         // type cache already; we simply return it.\n+\n         ret cx.tcache.get(did);\n     }\n     alt cx.tcache.find(did) {"}, {"sha": "67f5a125234756077645d214d6ba18fe6afa80ec", "filename": "src/comp/middle/typeck.rs", "status": "modified", "additions": 30, "deletions": 66, "changes": 96, "blob_url": "https://github.com/rust-lang/rust/blob/964bd485c6837fa08212451f45878746c9d3d308/src%2Fcomp%2Fmiddle%2Ftypeck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/964bd485c6837fa08212451f45878746c9d3d308/src%2Fcomp%2Fmiddle%2Ftypeck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftypeck.rs?ref=964bd485c6837fa08212451f45878746c9d3d308", "patch": "@@ -412,15 +412,16 @@ fn ty_of_item(tcx: ty::ctxt, mode: mode, it: @ast::item)\n         ret tpt;\n       }\n       ast::item_iface(tps, ms) {\n-        let s_tp = vec::len(tps) - 1u;\n-        tcx.ty_param_bounds.insert(tps[s_tp].id, @[]);\n-        let {bounds, params} = mk_ty_params(tcx, vec::slice(tps, 0u, s_tp));\n-        let t = ty::mk_named(tcx, ty::mk_iface(tcx, local_def(it.id), params),\n+        let {bounds, params} = mk_ty_params(tcx, tps);\n+        let t = ty::mk_named(tcx, ty::mk_iface(tcx, local_def(it.id),\n+                                               params),\n                              @it.ident);\n         let tpt = {bounds: bounds, ty: t};\n         tcx.tcache.insert(local_def(it.id), tpt);\n         ret tpt;\n       }\n+      ast::item_impl(_, _, _, _) | ast::item_mod(_) |\n+      ast::item_native_mod(_) { fail; }\n     }\n }\n fn ty_of_native_item(tcx: ty::ctxt, mode: mode, it: @ast::native_item)\n@@ -604,22 +605,12 @@ fn mk_ty_params(tcx: ty::ctxt, atps: [ast::ty_param])\n }\n \n fn compare_impl_method(tcx: ty::ctxt, sp: span, impl_m: ty::method,\n-                       impl_tps: uint, if_m: ty::method, substs: [ty::t])\n-    -> ty::t {\n+                       impl_tps: uint, if_m: ty::method, substs: [ty::t]) {\n     if impl_m.tps != if_m.tps {\n         tcx.sess.span_err(sp, \"method `\" + if_m.ident +\n                           \"` has an incompatible set of type parameters\");\n-        ty::mk_fn(tcx, impl_m.fty)\n     } else {\n-        let auto_modes = vec::map2(impl_m.fty.inputs, if_m.fty.inputs, {|i, f|\n-            alt ty::struct(tcx, f.ty) {\n-              ty::ty_param(0u, _) if i.mode == ast::mode_infer {\n-                {mode: ast::by_ref with i}\n-              }\n-              _ { i }\n-            }\n-        });\n-        let impl_fty = ty::mk_fn(tcx, {inputs: auto_modes with impl_m.fty});\n+        let impl_fty = ty::mk_fn(tcx, impl_m.fty);\n         // Add dummy substs for the parameters of the impl method\n         let substs = substs + vec::init_fn(vec::len(*if_m.tps), {|i|\n             ty::mk_param(tcx, i + impl_tps, {crate: 0, node: 0})\n@@ -631,9 +622,8 @@ fn compare_impl_method(tcx: ty::ctxt, sp: span, impl_m: ty::method,\n             tcx.sess.span_err(sp, \"method `\" + if_m.ident +\n                               \"` has an incompatible type: \" +\n                               ty::type_err_to_str(err));\n-            impl_fty\n           }\n-          ty::unify::ures_ok(tp) { tp }\n+          _ {}\n         }\n     }\n }\n@@ -701,15 +691,15 @@ mod collect {\n             for m in ms {\n                 let bounds = ty_param_bounds(cx.tcx, m_collect, m.tps);\n                 let mty = ty_of_method(cx.tcx, m_collect, m);\n-                my_methods += [{mty: mty, id: m.id}];\n+                my_methods += [mty];\n                 let fty = ty::mk_fn(cx.tcx, mty.fty);\n                 cx.tcx.tcache.insert(local_def(m.id),\n                                      {bounds: @(*i_bounds + *bounds),\n                                       ty: fty});\n                 write::ty_only(cx.tcx, m.id, fty);\n             }\n-            let selfty = ast_ty_to_ty(cx.tcx, m_collect, selfty);\n-            write::ty_only(cx.tcx, it.id, selfty);\n+            write::ty_only(cx.tcx, it.id, ast_ty_to_ty(cx.tcx, m_collect,\n+                                                       selfty));\n             alt ifce {\n               some(t) {\n                 let iface_ty = ast_ty_to_ty(cx.tcx, m_collect, t);\n@@ -719,18 +709,10 @@ mod collect {\n                   ty::ty_iface(did, tys) {\n                     for if_m in *ty::iface_methods(cx.tcx, did) {\n                         alt vec::find(my_methods,\n-                                      {|m| if_m.ident == m.mty.ident}) {\n-                          some({mty: m, id}) {\n-                            let mt = compare_impl_method(\n-                                cx.tcx, t.span, m, vec::len(tps), if_m,\n-                                tys + [selfty]);\n-                            let old = cx.tcx.tcache.get(local_def(id));\n-                            if old.ty != mt {\n-                                cx.tcx.tcache.insert(local_def(id),\n-                                                     {bounds: old.bounds,\n-                                                      ty: mt});\n-                                write::ty_only(cx.tcx, id, mt);\n-                            }\n+                                      {|m| if_m.ident == m.ident}) {\n+                          some(m) {\n+                            compare_impl_method(cx.tcx, t.span, m,\n+                                                vec::len(tps), if_m, tys);\n                           }\n                           none {\n                             cx.tcx.sess.span_err(t.span, \"missing method `\" +\n@@ -1518,7 +1500,7 @@ fn lookup_method(fcx: @fn_ctxt, isc: resolve::iscopes,\n                     let m = ifce_methods[pos];\n                     ret some({method_ty: ty::mk_fn(tcx, m.fty),\n                               n_tps: vec::len(*m.tps),\n-                              substs: tps + [ty],\n+                              substs: tps,\n                               origin: method_param(iid, pos, n, bound_n)});\n                   }\n                   _ {}\n@@ -1536,7 +1518,7 @@ fn lookup_method(fcx: @fn_ctxt, isc: resolve::iscopes,\n             if m.ident == name {\n                 ret some({method_ty: ty::mk_fn(tcx, m.fty),\n                           n_tps: vec::len(*m.tps),\n-                          substs: tps + [ty::mk_int(tcx)],\n+                          substs: tps,\n                           origin: method_iface(i)});\n             }\n             i += 1u;\n@@ -1545,6 +1527,17 @@ fn lookup_method(fcx: @fn_ctxt, isc: resolve::iscopes,\n       _ {}\n     }\n \n+    fn ty_from_did(tcx: ty::ctxt, did: ast::def_id) -> ty::t {\n+        if did.crate == ast::local_crate {\n+            alt tcx.items.get(did.node) {\n+              ast_map::node_method(m) {\n+                let mt = ty_of_method(tcx, m_check, m);\n+                ty::mk_fn(tcx, mt.fty)\n+              }\n+            }\n+        } else { csearch::get_type(tcx, did).ty }\n+    }\n+\n     let result = none;\n     std::list::iter(isc) {|impls|\n         if option::is_some(result) { ret; }\n@@ -1563,7 +1556,7 @@ fn lookup_method(fcx: @fn_ctxt, isc: resolve::iscopes,\n                             sp, \"multiple applicable methods in scope\");\n                     } else {\n                         result = some({\n-                            method_ty: ty::lookup_item_type(tcx, m.did).ty,\n+                            method_ty: ty_from_did(tcx, m.did),\n                             n_tps: m.n_tps,\n                             substs: vars,\n                             origin: method_static(m.did)\n@@ -2963,38 +2956,9 @@ mod dict {\n             }\n           }\n           ast::expr_cast(src, _) {\n-            // Ifaces that refer to a self type can not be cast to -- callers\n-            // wouldn't know what self refers to.\n-            fn type_refers_to_self(tcx: ty::ctxt, t: ty::t, s_param: uint)\n-                -> bool {\n-                let found = false;\n-                if ty::type_contains_params(tcx, t) {\n-                    ty::walk_ty(tcx, t) {|t|\n-                        alt ty::struct(tcx, t) {\n-                          ty::ty_param(n, _) if n == s_param { found = true; }\n-                          _ {}\n-                        }\n-                    }\n-                }\n-                found\n-            }\n-            fn method_refers_to_self(tcx: ty::ctxt, m: ty::method,\n-                                     s_param: uint) -> bool {\n-                vec::any(m.fty.inputs, {|in|\n-                    type_refers_to_self(tcx, in.ty, s_param)\n-                }) || type_refers_to_self(tcx, m.fty.output, s_param)\n-            }\n             let target_ty = expr_ty(cx.tcx, ex);\n             alt ty::struct(cx.tcx, target_ty) {\n-              ty::ty_iface(id, tps) {\n-                for m in *ty::iface_methods(cx.tcx, id) {\n-                    if method_refers_to_self(cx.tcx, m, vec::len(tps)) {\n-                        cx.tcx.sess.span_err(\n-                            ex.span, \"can not cast to an iface type that \\\n-                                      refers to `self` \" + m.ident);\n-                        break;\n-                    }\n-                }\n+              ty::ty_iface(_, _) {\n                 let impls = cx.impl_map.get(ex.id);\n                 let dict = lookup_dict(fcx, impls, ex.span,\n                                        expr_ty(cx.tcx, src), target_ty);"}, {"sha": "e6b278d51683b29a7697fb4f5546a2c7c668aa23", "filename": "src/comp/syntax/parse/parser.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/964bd485c6837fa08212451f45878746c9d3d308/src%2Fcomp%2Fsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/964bd485c6837fa08212451f45878746c9d3d308/src%2Fcomp%2Fsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fparse%2Fparser.rs?ref=964bd485c6837fa08212451f45878746c9d3d308", "patch": "@@ -1850,10 +1850,9 @@ fn parse_method(p: parser) -> @ast::method {\n \n fn parse_item_iface(p: parser, attrs: [ast::attribute]) -> @ast::item {\n     let lo = p.last_span.lo, ident = parse_ident(p),\n-        tps = parse_ty_params(p), meths = parse_ty_methods(p),\n-        self_tp = {ident: \"self\", id: p.get_id(), bounds: @[]};\n+        tps = parse_ty_params(p), meths = parse_ty_methods(p);\n     ret mk_item(p, lo, p.last_span.hi, ident,\n-                ast::item_iface(tps + [self_tp], meths), attrs);\n+                ast::item_iface(tps, meths), attrs);\n }\n \n // Parses three variants (with the initial params always optional):"}, {"sha": "5b62cef2d3b413113863bdad75c0e7e3935d82d7", "filename": "src/comp/syntax/print/pprust.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/964bd485c6837fa08212451f45878746c9d3d308/src%2Fcomp%2Fsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/964bd485c6837fa08212451f45878746c9d3d308/src%2Fcomp%2Fsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fprint%2Fpprust.rs?ref=964bd485c6837fa08212451f45878746c9d3d308", "patch": "@@ -519,8 +519,7 @@ fn print_item(s: ps, &&item: @ast::item) {\n       ast::item_iface(tps, methods) {\n         head(s, \"iface\");\n         word(s.s, item.ident);\n-        print_type_params(s, vec::slice(tps, 0u, vec::len(tps) - 1u));\n-        nbsp(s);\n+        print_type_params(s, tps);\n         bopen(s);\n         for meth in methods { print_ty_method(s, meth); }\n         bclose(s, item.span);"}, {"sha": "c37dc989f389b8b057bcf931cf49752c0072e7cf", "filename": "src/test/run-pass/iface-generic.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/964bd485c6837fa08212451f45878746c9d3d308/src%2Ftest%2Frun-pass%2Fiface-generic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/964bd485c6837fa08212451f45878746c9d3d308/src%2Ftest%2Frun-pass%2Fiface-generic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fiface-generic.rs?ref=964bd485c6837fa08212451f45878746c9d3d308", "patch": "@@ -12,11 +12,9 @@ impl of to_str for () {\n }\n \n iface map<T> {\n-    fn iter(fn(T));\n     fn map<U>(f: fn(T) -> U) -> [U];\n }\n impl <T> of map<T> for [T] {\n-    fn iter(_f: fn(T)) {}\n     fn map<U>(f: fn(T) -> U) -> [U] {\n         let r = [];\n         for x in self { r += [f(x)]; }"}]}