{"sha": "ee86f96ba176f598d64dc9f3bb7e074d5b8b86b6", "node_id": "MDY6Q29tbWl0NzI0NzEyOmVlODZmOTZiYTE3NmY1OThkNjRkYzlmM2JiN2UwNzRkNWI4Yjg2YjY=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-07-09T09:16:27Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-07-09T09:16:27Z"}, "message": "Auto merge of #85828 - scottmcm:raw-eq, r=oli-obk\n\nStop generating `alloca`s & `memcmp` for simple short array equality\n\nExample:\n```rust\npub fn demo(x: [u16; 6], y: [u16; 6]) -> bool { x == y }\n```\n\nBefore:\n```llvm\ndefine zeroext i1 `@_ZN10playground4demo17h48537f7eac23948fE(i96` %0, i96 %1) unnamed_addr #0 {\nstart:\n  %y = alloca [6 x i16], align 8\n  %x = alloca [6 x i16], align 8\n  %.0..sroa_cast = bitcast [6 x i16]* %x to i96*\n  store i96 %0, i96* %.0..sroa_cast, align 8\n  %.0..sroa_cast3 = bitcast [6 x i16]* %y to i96*\n  store i96 %1, i96* %.0..sroa_cast3, align 8\n  %_11.i.i.i = bitcast [6 x i16]* %x to i8*\n  %_14.i.i.i = bitcast [6 x i16]* %y to i8*\n  %bcmp.i.i.i = call i32 `@bcmp(i8*` nonnull dereferenceable(12) %_11.i.i.i, i8* nonnull dereferenceable(12) %_14.i.i.i, i64 12) #2, !alias.scope !2\n  %2 = icmp eq i32 %bcmp.i.i.i, 0\n  ret i1 %2\n}\n```\n```x86\nplayground::demo: # `@playground::demo`\n\tsub\trsp, 32\n\tmov\tqword ptr [rsp], rdi\n\tmov\tdword ptr [rsp + 8], esi\n\tmov\tqword ptr [rsp + 16], rdx\n\tmov\tdword ptr [rsp + 24], ecx\n\txor\trdi, rdx\n\txor\tesi, ecx\n\tor\trsi, rdi\n\tsete\tal\n\tadd\trsp, 32\n\tret\n```\n\nAfter:\n```llvm\ndefine zeroext i1 `@_ZN4mini4demo17h7a8994aaa314c981E(i96` %0, i96 %1) unnamed_addr #0 {\nstart:\n  %2 = icmp eq i96 %0, %1\n  ret i1 %2\n}\n```\n```x86\n_ZN4mini4demo17h7a8994aaa314c981E:\n\txor\trcx, r8\n\txor\tedx, r9d\n\tor\trdx, rcx\n\tsete\tal\n\tret\n```", "tree": {"sha": "31e632ae31b54ae25e9323bb51fe507e31d140ed", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/31e632ae31b54ae25e9323bb51fe507e31d140ed"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ee86f96ba176f598d64dc9f3bb7e074d5b8b86b6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ee86f96ba176f598d64dc9f3bb7e074d5b8b86b6", "html_url": "https://github.com/rust-lang/rust/commit/ee86f96ba176f598d64dc9f3bb7e074d5b8b86b6", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ee86f96ba176f598d64dc9f3bb7e074d5b8b86b6/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "95fb1315217976ff4c268bb03c9b4132f0dfa9fd", "url": "https://api.github.com/repos/rust-lang/rust/commits/95fb1315217976ff4c268bb03c9b4132f0dfa9fd", "html_url": "https://github.com/rust-lang/rust/commit/95fb1315217976ff4c268bb03c9b4132f0dfa9fd"}, {"sha": "d0644947a3b093bfc09452ecd14291cea5dd8f14", "url": "https://api.github.com/repos/rust-lang/rust/commits/d0644947a3b093bfc09452ecd14291cea5dd8f14", "html_url": "https://github.com/rust-lang/rust/commit/d0644947a3b093bfc09452ecd14291cea5dd8f14"}], "stats": {"total": 524, "additions": 410, "deletions": 114}, "files": [{"sha": "3979886e10cfc17997d1a30362860cdb85adf6c1", "filename": "compiler/rustc_codegen_cranelift/src/intrinsics/mod.rs", "status": "modified", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/ee86f96ba176f598d64dc9f3bb7e074d5b8b86b6/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fintrinsics%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ee86f96ba176f598d64dc9f3bb7e074d5b8b86b6/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fintrinsics%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fintrinsics%2Fmod.rs?ref=ee86f96ba176f598d64dc9f3bb7e074d5b8b86b6", "patch": "@@ -1115,6 +1115,40 @@ pub(crate) fn codegen_intrinsic_call<'tcx>(\n             );\n             ret.write_cvalue(fx, CValue::by_val(res, ret.layout()));\n         };\n+\n+        raw_eq, <T>(v lhs_ref, v rhs_ref) {\n+            fn type_by_size(size: Size) -> Option<Type> {\n+                Type::int(size.bits().try_into().ok()?)\n+            }\n+\n+            let size = fx.layout_of(T).layout.size;\n+            let is_eq_value =\n+                if size == Size::ZERO {\n+                    // No bytes means they're trivially equal\n+                    fx.bcx.ins().iconst(types::I8, 1)\n+                } else if let Some(clty) = type_by_size(size) {\n+                    // Can't use `trusted` for these loads; they could be unaligned.\n+                    let mut flags = MemFlags::new();\n+                    flags.set_notrap();\n+                    let lhs_val = fx.bcx.ins().load(clty, flags, lhs_ref, 0);\n+                    let rhs_val = fx.bcx.ins().load(clty, flags, rhs_ref, 0);\n+                    let eq = fx.bcx.ins().icmp(IntCC::Equal, lhs_val, rhs_val);\n+                    fx.bcx.ins().bint(types::I8, eq)\n+                } else {\n+                    // Just call `memcmp` (like slices do in core) when the\n+                    // size is too large or it's not a power-of-two.\n+                    let ptr_ty = pointer_ty(fx.tcx);\n+                    let signed_bytes = i64::try_from(size.bytes()).unwrap();\n+                    let bytes_val = fx.bcx.ins().iconst(ptr_ty, signed_bytes);\n+                    let params = vec![AbiParam::new(ptr_ty); 3];\n+                    let returns = vec![AbiParam::new(types::I32)];\n+                    let args = &[lhs_ref, rhs_ref, bytes_val];\n+                    let cmp = fx.lib_call(\"memcmp\", params, returns, args)[0];\n+                    let eq = fx.bcx.ins().icmp_imm(IntCC::Equal, cmp, 0);\n+                    fx.bcx.ins().bint(types::I8, eq)\n+                };\n+            ret.write_cvalue(fx, CValue::by_val(is_eq_value, ret.layout()));\n+        };\n     }\n \n     if let Some((_, dest)) = destination {"}, {"sha": "ae8ccc626b47089e09a8f75672c9893659ef21fa", "filename": "compiler/rustc_codegen_cranelift/src/value_and_place.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ee86f96ba176f598d64dc9f3bb7e074d5b8b86b6/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fvalue_and_place.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ee86f96ba176f598d64dc9f3bb7e074d5b8b86b6/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fvalue_and_place.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fvalue_and_place.rs?ref=ee86f96ba176f598d64dc9f3bb7e074d5b8b86b6", "patch": "@@ -453,6 +453,10 @@ impl<'tcx> CPlace<'tcx> {\n                     ptr.store(fx, data, MemFlags::trusted());\n                     ptr.load(fx, dst_ty, MemFlags::trusted())\n                 }\n+\n+                // `CValue`s should never contain SSA-only types, so if you ended\n+                // up here having seen an error like `B1 -> I8`, then before\n+                // calling `write_cvalue` you need to add a `bint` instruction.\n                 _ => unreachable!(\"write_cvalue_transmute: {:?} -> {:?}\", src_ty, dst_ty),\n             };\n             //fx.bcx.set_val_label(data, cranelift_codegen::ir::ValueLabel::new(var.index()));"}, {"sha": "d1aecd32e2f2d00cddfc0d24b6329dd7e2b90f28", "filename": "compiler/rustc_codegen_llvm/src/context.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/ee86f96ba176f598d64dc9f3bb7e074d5b8b86b6/compiler%2Frustc_codegen_llvm%2Fsrc%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ee86f96ba176f598d64dc9f3bb7e074d5b8b86b6/compiler%2Frustc_codegen_llvm%2Fsrc%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fcontext.rs?ref=ee86f96ba176f598d64dc9f3bb7e074d5b8b86b6", "patch": "@@ -500,6 +500,7 @@ impl CodegenCx<'b, 'tcx> {\n         let t_i32 = self.type_i32();\n         let t_i64 = self.type_i64();\n         let t_i128 = self.type_i128();\n+        let t_isize = self.type_isize();\n         let t_f32 = self.type_f32();\n         let t_f64 = self.type_f64();\n \n@@ -712,6 +713,10 @@ impl CodegenCx<'b, 'tcx> {\n         ifn!(\"llvm.assume\", fn(i1) -> void);\n         ifn!(\"llvm.prefetch\", fn(i8p, t_i32, t_i32, t_i32) -> void);\n \n+        // This isn't an \"LLVM intrinsic\", but LLVM's optimization passes\n+        // recognize it like one and we assume it exists in `core::slice::cmp`\n+        ifn!(\"memcmp\", fn(i8p, i8p, t_isize) -> t_i32);\n+\n         // variadic intrinsics\n         ifn!(\"llvm.va_start\", fn(i8p) -> void);\n         ifn!(\"llvm.va_end\", fn(i8p) -> void);"}, {"sha": "9a968659e2fe8d6ee439c380511c36e798f4ee09", "filename": "compiler/rustc_codegen_llvm/src/intrinsic.rs", "status": "modified", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/ee86f96ba176f598d64dc9f3bb7e074d5b8b86b6/compiler%2Frustc_codegen_llvm%2Fsrc%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ee86f96ba176f598d64dc9f3bb7e074d5b8b86b6/compiler%2Frustc_codegen_llvm%2Fsrc%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fintrinsic.rs?ref=ee86f96ba176f598d64dc9f3bb7e074d5b8b86b6", "patch": "@@ -296,6 +296,44 @@ impl IntrinsicCallMethods<'tcx> for Builder<'a, 'll, 'tcx> {\n                 }\n             }\n \n+            sym::raw_eq => {\n+                use abi::Abi::*;\n+                let tp_ty = substs.type_at(0);\n+                let layout = self.layout_of(tp_ty).layout;\n+                let use_integer_compare = match layout.abi {\n+                    Scalar(_) | ScalarPair(_, _) => true,\n+                    Uninhabited | Vector { .. } => false,\n+                    Aggregate { .. } => {\n+                        // For rusty ABIs, small aggregates are actually passed\n+                        // as `RegKind::Integer` (see `FnAbi::adjust_for_abi`),\n+                        // so we re-use that same threshold here.\n+                        layout.size <= self.data_layout().pointer_size * 2\n+                    }\n+                };\n+\n+                let a = args[0].immediate();\n+                let b = args[1].immediate();\n+                if layout.size.bytes() == 0 {\n+                    self.const_bool(true)\n+                } else if use_integer_compare {\n+                    let integer_ty = self.type_ix(layout.size.bits());\n+                    let ptr_ty = self.type_ptr_to(integer_ty);\n+                    let a_ptr = self.bitcast(a, ptr_ty);\n+                    let a_val = self.load(a_ptr, layout.align.abi);\n+                    let b_ptr = self.bitcast(b, ptr_ty);\n+                    let b_val = self.load(b_ptr, layout.align.abi);\n+                    self.icmp(IntPredicate::IntEQ, a_val, b_val)\n+                } else {\n+                    let i8p_ty = self.type_i8p();\n+                    let a_ptr = self.bitcast(a, i8p_ty);\n+                    let b_ptr = self.bitcast(b, i8p_ty);\n+                    let n = self.const_usize(layout.size.bytes());\n+                    let llfn = self.get_intrinsic(\"memcmp\");\n+                    let cmp = self.call(llfn, &[a_ptr, b_ptr, n], None);\n+                    self.icmp(IntPredicate::IntEQ, cmp, self.const_i32(0))\n+                }\n+            }\n+\n             _ if name_str.starts_with(\"simd_\") => {\n                 match generic_simd_intrinsic(self, name, callee_ty, args, ret_ty, llret_ty, span) {\n                     Ok(llval) => llval,"}, {"sha": "ad9cf3e7d2fe9b39ff56da6088261455cf60753c", "filename": "compiler/rustc_mir/src/interpret/intrinsics.rs", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/ee86f96ba176f598d64dc9f3bb7e074d5b8b86b6/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ee86f96ba176f598d64dc9f3bb7e074d5b8b86b6/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Fintrinsics.rs?ref=ee86f96ba176f598d64dc9f3bb7e074d5b8b86b6", "patch": "@@ -472,6 +472,10 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                     throw_ub_format!(\"`assume` intrinsic called with `false`\");\n                 }\n             }\n+            sym::raw_eq => {\n+                let result = self.raw_eq_intrinsic(&args[0], &args[1])?;\n+                self.write_scalar(result, dest)?;\n+            }\n             _ => return Ok(false),\n         }\n \n@@ -559,4 +563,19 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n \n         self.memory.copy(src, align, dst, align, size, nonoverlapping)\n     }\n+\n+    pub(crate) fn raw_eq_intrinsic(\n+        &mut self,\n+        lhs: &OpTy<'tcx, <M as Machine<'mir, 'tcx>>::PointerTag>,\n+        rhs: &OpTy<'tcx, <M as Machine<'mir, 'tcx>>::PointerTag>,\n+    ) -> InterpResult<'tcx, Scalar<M::PointerTag>> {\n+        let layout = self.layout_of(lhs.layout.ty.builtin_deref(true).unwrap().ty)?;\n+        assert!(!layout.is_unsized());\n+\n+        let lhs = self.read_scalar(lhs)?.check_init()?;\n+        let rhs = self.read_scalar(rhs)?.check_init()?;\n+        let lhs_bytes = self.memory.read_bytes(lhs, layout.size)?;\n+        let rhs_bytes = self.memory.read_bytes(rhs, layout.size)?;\n+        Ok(Scalar::from_bool(lhs_bytes == rhs_bytes))\n+    }\n }"}, {"sha": "9051c9d69b5c1e7b98dc5000ff5bd993f341b85b", "filename": "compiler/rustc_span/src/symbol.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/ee86f96ba176f598d64dc9f3bb7e074d5b8b86b6/compiler%2Frustc_span%2Fsrc%2Fsymbol.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ee86f96ba176f598d64dc9f3bb7e074d5b8b86b6/compiler%2Frustc_span%2Fsrc%2Fsymbol.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_span%2Fsrc%2Fsymbol.rs?ref=ee86f96ba176f598d64dc9f3bb7e074d5b8b86b6", "patch": "@@ -934,6 +934,7 @@ symbols! {\n         quote,\n         range_inclusive_new,\n         raw_dylib,\n+        raw_eq,\n         raw_identifiers,\n         raw_ref_op,\n         re_rebalance_coherence,"}, {"sha": "6661df21ed952cef4b2748a90e4748d75a6fd491", "filename": "compiler/rustc_typeck/src/check/intrinsic.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/ee86f96ba176f598d64dc9f3bb7e074d5b8b86b6/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ee86f96ba176f598d64dc9f3bb7e074d5b8b86b6/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fintrinsic.rs?ref=ee86f96ba176f598d64dc9f3bb7e074d5b8b86b6", "patch": "@@ -380,6 +380,13 @@ pub fn check_intrinsic_type(tcx: TyCtxt<'_>, it: &hir::ForeignItem<'_>) {\n \n             sym::nontemporal_store => (1, vec![tcx.mk_mut_ptr(param(0)), param(0)], tcx.mk_unit()),\n \n+            sym::raw_eq => {\n+                let br = ty::BoundRegion { var: ty::BoundVar::from_u32(0), kind: ty::BrAnon(0) };\n+                let param_ty =\n+                    tcx.mk_imm_ref(tcx.mk_region(ty::ReLateBound(ty::INNERMOST, br)), param(0));\n+                (1, vec![param_ty; 2], tcx.types.bool)\n+            }\n+\n             other => {\n                 tcx.sess.emit_err(UnrecognizedIntrinsicFunction { span: it.span, name: other });\n                 return;"}, {"sha": "6d66b9e2f27807b44423dda566c9631d2110f2eb", "filename": "library/core/src/array/equality.rs", "status": "added", "additions": 160, "deletions": 0, "changes": 160, "blob_url": "https://github.com/rust-lang/rust/blob/ee86f96ba176f598d64dc9f3bb7e074d5b8b86b6/library%2Fcore%2Fsrc%2Farray%2Fequality.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ee86f96ba176f598d64dc9f3bb7e074d5b8b86b6/library%2Fcore%2Fsrc%2Farray%2Fequality.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Farray%2Fequality.rs?ref=ee86f96ba176f598d64dc9f3bb7e074d5b8b86b6", "patch": "@@ -0,0 +1,160 @@\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<A, B, const N: usize> PartialEq<[B; N]> for [A; N]\n+where\n+    A: PartialEq<B>,\n+{\n+    #[inline]\n+    fn eq(&self, other: &[B; N]) -> bool {\n+        SpecArrayEq::spec_eq(self, other)\n+    }\n+    #[inline]\n+    fn ne(&self, other: &[B; N]) -> bool {\n+        SpecArrayEq::spec_ne(self, other)\n+    }\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<A, B, const N: usize> PartialEq<[B]> for [A; N]\n+where\n+    A: PartialEq<B>,\n+{\n+    #[inline]\n+    fn eq(&self, other: &[B]) -> bool {\n+        self[..] == other[..]\n+    }\n+    #[inline]\n+    fn ne(&self, other: &[B]) -> bool {\n+        self[..] != other[..]\n+    }\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<A, B, const N: usize> PartialEq<[A; N]> for [B]\n+where\n+    B: PartialEq<A>,\n+{\n+    #[inline]\n+    fn eq(&self, other: &[A; N]) -> bool {\n+        self[..] == other[..]\n+    }\n+    #[inline]\n+    fn ne(&self, other: &[A; N]) -> bool {\n+        self[..] != other[..]\n+    }\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<A, B, const N: usize> PartialEq<&[B]> for [A; N]\n+where\n+    A: PartialEq<B>,\n+{\n+    #[inline]\n+    fn eq(&self, other: &&[B]) -> bool {\n+        self[..] == other[..]\n+    }\n+    #[inline]\n+    fn ne(&self, other: &&[B]) -> bool {\n+        self[..] != other[..]\n+    }\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<A, B, const N: usize> PartialEq<[A; N]> for &[B]\n+where\n+    B: PartialEq<A>,\n+{\n+    #[inline]\n+    fn eq(&self, other: &[A; N]) -> bool {\n+        self[..] == other[..]\n+    }\n+    #[inline]\n+    fn ne(&self, other: &[A; N]) -> bool {\n+        self[..] != other[..]\n+    }\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<A, B, const N: usize> PartialEq<&mut [B]> for [A; N]\n+where\n+    A: PartialEq<B>,\n+{\n+    #[inline]\n+    fn eq(&self, other: &&mut [B]) -> bool {\n+        self[..] == other[..]\n+    }\n+    #[inline]\n+    fn ne(&self, other: &&mut [B]) -> bool {\n+        self[..] != other[..]\n+    }\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<A, B, const N: usize> PartialEq<[A; N]> for &mut [B]\n+where\n+    B: PartialEq<A>,\n+{\n+    #[inline]\n+    fn eq(&self, other: &[A; N]) -> bool {\n+        self[..] == other[..]\n+    }\n+    #[inline]\n+    fn ne(&self, other: &[A; N]) -> bool {\n+        self[..] != other[..]\n+    }\n+}\n+\n+// NOTE: some less important impls are omitted to reduce code bloat\n+// __impl_slice_eq2! { [A; $N], &'b [B; $N] }\n+// __impl_slice_eq2! { [A; $N], &'b mut [B; $N] }\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<T: Eq, const N: usize> Eq for [T; N] {}\n+\n+trait SpecArrayEq<Other, const N: usize>: Sized {\n+    fn spec_eq(a: &[Self; N], b: &[Other; N]) -> bool;\n+    fn spec_ne(a: &[Self; N], b: &[Other; N]) -> bool;\n+}\n+\n+impl<T: PartialEq<Other>, Other, const N: usize> SpecArrayEq<Other, N> for T {\n+    default fn spec_eq(a: &[Self; N], b: &[Other; N]) -> bool {\n+        a[..] == b[..]\n+    }\n+    default fn spec_ne(a: &[Self; N], b: &[Other; N]) -> bool {\n+        a[..] != b[..]\n+    }\n+}\n+\n+impl<T: PartialEq<U> + IsRawEqComparable<U>, U, const N: usize> SpecArrayEq<U, N> for T {\n+    #[cfg(bootstrap)]\n+    fn spec_eq(a: &[T; N], b: &[U; N]) -> bool {\n+        a[..] == b[..]\n+    }\n+    #[cfg(not(bootstrap))]\n+    fn spec_eq(a: &[T; N], b: &[U; N]) -> bool {\n+        // SAFETY: This is why `IsRawEqComparable` is an `unsafe trait`.\n+        unsafe {\n+            let b = &*b.as_ptr().cast::<[T; N]>();\n+            crate::intrinsics::raw_eq(a, b)\n+        }\n+    }\n+    fn spec_ne(a: &[T; N], b: &[U; N]) -> bool {\n+        !Self::spec_eq(a, b)\n+    }\n+}\n+\n+/// `U` exists on here mostly because `min_specialization` didn't let me\n+/// repeat the `T` type parameter in the above specialization, so instead\n+/// the `T == U` constraint comes from the impls on this.\n+/// # Safety\n+/// - Neither `Self` nor `U` has any padding.\n+/// - `Self` and `U` have the same layout.\n+/// - `Self: PartialEq<U>` is byte-wise (this means no floats, among other things)\n+#[rustc_specialization_trait]\n+unsafe trait IsRawEqComparable<U> {}\n+\n+macro_rules! is_raw_comparable {\n+    ($($t:ty),+) => {$(\n+        unsafe impl IsRawEqComparable<$t> for $t {}\n+    )+};\n+}\n+is_raw_comparable!(bool, char, u8, u16, u32, u64, u128, usize, i8, i16, i32, i64, i128, isize);"}, {"sha": "32d344010aafd3dea55d6f85f06144e0df384cc6", "filename": "library/core/src/array/mod.rs", "status": "modified", "additions": 1, "deletions": 112, "changes": 113, "blob_url": "https://github.com/rust-lang/rust/blob/ee86f96ba176f598d64dc9f3bb7e074d5b8b86b6/library%2Fcore%2Fsrc%2Farray%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ee86f96ba176f598d64dc9f3bb7e074d5b8b86b6/library%2Fcore%2Fsrc%2Farray%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Farray%2Fmod.rs?ref=ee86f96ba176f598d64dc9f3bb7e074d5b8b86b6", "patch": "@@ -14,6 +14,7 @@ use crate::mem::{self, MaybeUninit};\n use crate::ops::{Index, IndexMut};\n use crate::slice::{Iter, IterMut};\n \n+mod equality;\n mod iter;\n \n #[stable(feature = \"array_value_iter\", since = \"1.51.0\")]\n@@ -230,118 +231,6 @@ where\n     }\n }\n \n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<A, B, const N: usize> PartialEq<[B; N]> for [A; N]\n-where\n-    A: PartialEq<B>,\n-{\n-    #[inline]\n-    fn eq(&self, other: &[B; N]) -> bool {\n-        self[..] == other[..]\n-    }\n-    #[inline]\n-    fn ne(&self, other: &[B; N]) -> bool {\n-        self[..] != other[..]\n-    }\n-}\n-\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<A, B, const N: usize> PartialEq<[B]> for [A; N]\n-where\n-    A: PartialEq<B>,\n-{\n-    #[inline]\n-    fn eq(&self, other: &[B]) -> bool {\n-        self[..] == other[..]\n-    }\n-    #[inline]\n-    fn ne(&self, other: &[B]) -> bool {\n-        self[..] != other[..]\n-    }\n-}\n-\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<A, B, const N: usize> PartialEq<[A; N]> for [B]\n-where\n-    B: PartialEq<A>,\n-{\n-    #[inline]\n-    fn eq(&self, other: &[A; N]) -> bool {\n-        self[..] == other[..]\n-    }\n-    #[inline]\n-    fn ne(&self, other: &[A; N]) -> bool {\n-        self[..] != other[..]\n-    }\n-}\n-\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<A, B, const N: usize> PartialEq<&[B]> for [A; N]\n-where\n-    A: PartialEq<B>,\n-{\n-    #[inline]\n-    fn eq(&self, other: &&[B]) -> bool {\n-        self[..] == other[..]\n-    }\n-    #[inline]\n-    fn ne(&self, other: &&[B]) -> bool {\n-        self[..] != other[..]\n-    }\n-}\n-\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<A, B, const N: usize> PartialEq<[A; N]> for &[B]\n-where\n-    B: PartialEq<A>,\n-{\n-    #[inline]\n-    fn eq(&self, other: &[A; N]) -> bool {\n-        self[..] == other[..]\n-    }\n-    #[inline]\n-    fn ne(&self, other: &[A; N]) -> bool {\n-        self[..] != other[..]\n-    }\n-}\n-\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<A, B, const N: usize> PartialEq<&mut [B]> for [A; N]\n-where\n-    A: PartialEq<B>,\n-{\n-    #[inline]\n-    fn eq(&self, other: &&mut [B]) -> bool {\n-        self[..] == other[..]\n-    }\n-    #[inline]\n-    fn ne(&self, other: &&mut [B]) -> bool {\n-        self[..] != other[..]\n-    }\n-}\n-\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<A, B, const N: usize> PartialEq<[A; N]> for &mut [B]\n-where\n-    B: PartialEq<A>,\n-{\n-    #[inline]\n-    fn eq(&self, other: &[A; N]) -> bool {\n-        self[..] == other[..]\n-    }\n-    #[inline]\n-    fn ne(&self, other: &[A; N]) -> bool {\n-        self[..] != other[..]\n-    }\n-}\n-\n-// NOTE: some less important impls are omitted to reduce code bloat\n-// __impl_slice_eq2! { [A; $N], &'b [B; $N] }\n-// __impl_slice_eq2! { [A; $N], &'b mut [B; $N] }\n-\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<T: Eq, const N: usize> Eq for [T; N] {}\n-\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T: PartialOrd, const N: usize> PartialOrd for [T; N] {\n     #[inline]"}, {"sha": "238f00e41b3afae97c1b765cd753f197958b0dd5", "filename": "library/core/src/intrinsics.rs", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/ee86f96ba176f598d64dc9f3bb7e074d5b8b86b6/library%2Fcore%2Fsrc%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ee86f96ba176f598d64dc9f3bb7e074d5b8b86b6/library%2Fcore%2Fsrc%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fintrinsics.rs?ref=ee86f96ba176f598d64dc9f3bb7e074d5b8b86b6", "patch": "@@ -1913,6 +1913,26 @@ extern \"rust-intrinsic\" {\n     /// Allocate at compile time. Should not be called at runtime.\n     #[rustc_const_unstable(feature = \"const_heap\", issue = \"79597\")]\n     pub fn const_allocate(size: usize, align: usize) -> *mut u8;\n+\n+    /// Determines whether the raw bytes of the two values are equal.\n+    ///\n+    /// The is particularly handy for arrays, since it allows things like just\n+    /// comparing `i96`s instead of forcing `alloca`s for `[6 x i16]`.\n+    ///\n+    /// Above some backend-decided threshold this will emit calls to `memcmp`,\n+    /// like slice equality does, instead of causing massive code size.\n+    ///\n+    /// # Safety\n+    ///\n+    /// It's UB to call this if any of the *bytes* in `*a` or `*b` are uninitialized.\n+    /// Note that this is a stricter criterion than just the *values* being\n+    /// fully-initialized: if `T` has padding, it's UB to call this intrinsic.\n+    ///\n+    /// (The implementation is allowed to branch on the results of comparisons,\n+    /// which is UB if any of their inputs are `undef`.)\n+    #[cfg(not(bootstrap))]\n+    #[rustc_const_unstable(feature = \"const_intrinsic_raw_eq\", issue = \"none\")]\n+    pub fn raw_eq<T>(a: &T, b: &T) -> bool;\n }\n \n // Some functions are defined here because they accidentally got made"}, {"sha": "4b60fa4b0bffa40d68a2c692903090ac66338601", "filename": "src/test/codegen/array-equality.rs", "status": "added", "additions": 57, "deletions": 0, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/ee86f96ba176f598d64dc9f3bb7e074d5b8b86b6/src%2Ftest%2Fcodegen%2Farray-equality.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ee86f96ba176f598d64dc9f3bb7e074d5b8b86b6/src%2Ftest%2Fcodegen%2Farray-equality.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen%2Farray-equality.rs?ref=ee86f96ba176f598d64dc9f3bb7e074d5b8b86b6", "patch": "@@ -0,0 +1,57 @@\n+// compile-flags: -O\n+// only-x86_64\n+\n+#![crate_type = \"lib\"]\n+\n+// CHECK-LABEL: @array_eq_value\n+#[no_mangle]\n+pub fn array_eq_value(a: [u16; 6], b: [u16; 6]) -> bool {\n+    // CHECK-NEXT: start:\n+    // CHECK-NEXT: %2 = icmp eq i96 %0, %1\n+    // CHECK-NEXT: ret i1 %2\n+    a == b\n+}\n+\n+// CHECK-LABEL: @array_eq_ref\n+#[no_mangle]\n+pub fn array_eq_ref(a: &[u16; 6], b: &[u16; 6]) -> bool {\n+    // CHECK: start:\n+    // CHECK: load i96, i96* %{{.+}}, align 2\n+    // CHECK: load i96, i96* %{{.+}}, align 2\n+    // CHECK: icmp eq i96\n+    // CHECK-NEXT: ret\n+    a == b\n+}\n+\n+// CHECK-LABEL: @array_eq_value_still_passed_by_pointer\n+#[no_mangle]\n+pub fn array_eq_value_still_passed_by_pointer(a: [u16; 9], b: [u16; 9]) -> bool {\n+    // CHECK-NEXT: start:\n+    // CHECK-NEXT: bitcast\n+    // CHECK-NEXT: bitcast\n+    // CHECK-NEXT: %[[CMP:.+]] = tail call i32 @{{bcmp|memcmp}}(i8* nonnull dereferenceable(18) %{{.+}}, i8* nonnull dereferenceable(18) %{{.+}}, i64 18)\n+    // CHECK-NEXT: %[[EQ:.+]] = icmp eq i32 %[[CMP]], 0\n+    // CHECK-NEXT: ret i1 %[[EQ]]\n+    a == b\n+}\n+\n+// CHECK-LABEL: @array_eq_long\n+#[no_mangle]\n+pub fn array_eq_long(a: &[u16; 1234], b: &[u16; 1234]) -> bool {\n+    // CHECK-NEXT: start:\n+    // CHECK-NEXT: bitcast\n+    // CHECK-NEXT: bitcast\n+    // CHECK-NEXT: %[[CMP:.+]] = tail call i32 @{{bcmp|memcmp}}(i8* nonnull dereferenceable(2468) %{{.+}}, i8* nonnull dereferenceable(2468) %{{.+}}, i64 2468)\n+    // CHECK-NEXT: %[[EQ:.+]] = icmp eq i32 %[[CMP]], 0\n+    // CHECK-NEXT: ret i1 %[[EQ]]\n+    a == b\n+}\n+\n+// CHECK-LABEL: @array_eq_zero(i128 %0)\n+#[no_mangle]\n+pub fn array_eq_zero(x: [u16; 8]) -> bool {\n+    // CHECK-NEXT: start:\n+    // CHECK-NEXT: %[[EQ:.+]] = icmp eq i128 %0, 0\n+    // CHECK-NEXT: ret i1 %[[EQ]]\n+    x == [0; 8]\n+}"}, {"sha": "1f99ac7342b39c5c77779a6a3080c783edc09a5f", "filename": "src/test/codegen/slice-ref-equality.rs", "status": "modified", "additions": 17, "deletions": 2, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/ee86f96ba176f598d64dc9f3bb7e074d5b8b86b6/src%2Ftest%2Fcodegen%2Fslice-ref-equality.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ee86f96ba176f598d64dc9f3bb7e074d5b8b86b6/src%2Ftest%2Fcodegen%2Fslice-ref-equality.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen%2Fslice-ref-equality.rs?ref=ee86f96ba176f598d64dc9f3bb7e074d5b8b86b6", "patch": "@@ -2,15 +2,30 @@\n \n #![crate_type = \"lib\"]\n \n-// #71602: check that slice equality just generates a single bcmp\n+// #71602 reported a simple array comparison just generating a loop.\n+// This was originally fixed by ensuring it generates a single bcmp,\n+// but we now generate it as a load instead. `is_zero_slice` was\n+// tweaked to still test the case of comparison against a slice,\n+// and `is_zero_array` tests the new array-specific behaviour.\n \n // CHECK-LABEL: @is_zero_slice\n #[no_mangle]\n pub fn is_zero_slice(data: &[u8; 4]) -> bool {\n-    // CHECK: start:\n+    // CHECK: :\n     // CHECK-NEXT: %{{.+}} = getelementptr {{.+}}\n     // CHECK-NEXT: %[[BCMP:.+]] = tail call i32 @{{bcmp|memcmp}}({{.+}})\n     // CHECK-NEXT: %[[EQ:.+]] = icmp eq i32 %[[BCMP]], 0\n     // CHECK-NEXT: ret i1 %[[EQ]]\n+    &data[..] == [0; 4]\n+}\n+\n+// CHECK-LABEL: @is_zero_array\n+#[no_mangle]\n+pub fn is_zero_array(data: &[u8; 4]) -> bool {\n+    // CHECK: start:\n+    // CHECK-NEXT: %[[PTR:.+]] = bitcast [4 x i8]* {{.+}} to i32*\n+    // CHECK-NEXT: %[[LOAD:.+]] = load i32, i32* %[[PTR]], align 1\n+    // CHECK-NEXT: %[[EQ:.+]] = icmp eq i32 %[[LOAD]], 0\n+    // CHECK-NEXT: ret i1 %[[EQ]]\n     *data == [0; 4]\n }"}, {"sha": "a205a8730a0b8c0ce52b7eb5138164c6bcc15fb7", "filename": "src/test/ui/intrinsics/intrinsic-raw_eq-const-padding.rs", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/ee86f96ba176f598d64dc9f3bb7e074d5b8b86b6/src%2Ftest%2Fui%2Fintrinsics%2Fintrinsic-raw_eq-const-padding.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ee86f96ba176f598d64dc9f3bb7e074d5b8b86b6/src%2Ftest%2Fui%2Fintrinsics%2Fintrinsic-raw_eq-const-padding.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fintrinsics%2Fintrinsic-raw_eq-const-padding.rs?ref=ee86f96ba176f598d64dc9f3bb7e074d5b8b86b6", "patch": "@@ -0,0 +1,11 @@\n+#![feature(core_intrinsics)]\n+#![feature(const_intrinsic_raw_eq)]\n+#![deny(const_err)]\n+\n+const BAD_RAW_EQ_CALL: bool = unsafe {\n+    std::intrinsics::raw_eq(&(1_u8, 2_u16), &(1_u8, 2_u16))\n+//~^ ERROR evaluation of constant value failed\n+};\n+\n+pub fn main() {\n+}"}, {"sha": "3a1b090012770b17b86e84f9f59dc5a3e1f0c400", "filename": "src/test/ui/intrinsics/intrinsic-raw_eq-const-padding.stderr", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/ee86f96ba176f598d64dc9f3bb7e074d5b8b86b6/src%2Ftest%2Fui%2Fintrinsics%2Fintrinsic-raw_eq-const-padding.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ee86f96ba176f598d64dc9f3bb7e074d5b8b86b6/src%2Ftest%2Fui%2Fintrinsics%2Fintrinsic-raw_eq-const-padding.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fintrinsics%2Fintrinsic-raw_eq-const-padding.stderr?ref=ee86f96ba176f598d64dc9f3bb7e074d5b8b86b6", "patch": "@@ -0,0 +1,9 @@\n+error[E0080]: evaluation of constant value failed\n+  --> $DIR/intrinsic-raw_eq-const-padding.rs:6:5\n+   |\n+LL |     std::intrinsics::raw_eq(&(1_u8, 2_u16), &(1_u8, 2_u16))\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ reading 4 bytes of memory starting at alloc2, but 1 byte is uninitialized starting at alloc2+0x1, and this operation requires initialized memory\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0080`."}, {"sha": "8ea954673020e12aa51b7b898086a2b3631baf02", "filename": "src/test/ui/intrinsics/intrinsic-raw_eq-const.rs", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/ee86f96ba176f598d64dc9f3bb7e074d5b8b86b6/src%2Ftest%2Fui%2Fintrinsics%2Fintrinsic-raw_eq-const.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ee86f96ba176f598d64dc9f3bb7e074d5b8b86b6/src%2Ftest%2Fui%2Fintrinsics%2Fintrinsic-raw_eq-const.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fintrinsics%2Fintrinsic-raw_eq-const.rs?ref=ee86f96ba176f598d64dc9f3bb7e074d5b8b86b6", "patch": "@@ -0,0 +1,27 @@\n+// run-pass\n+\n+#![feature(core_intrinsics)]\n+#![feature(const_intrinsic_raw_eq)]\n+#![deny(const_err)]\n+\n+pub fn main() {\n+    use std::intrinsics::raw_eq;\n+\n+    const RAW_EQ_I32_TRUE: bool = unsafe { raw_eq(&42_i32, &42) };\n+    assert!(RAW_EQ_I32_TRUE);\n+\n+    const RAW_EQ_I32_FALSE: bool = unsafe { raw_eq(&4_i32, &2) };\n+    assert!(!RAW_EQ_I32_FALSE);\n+\n+    const RAW_EQ_CHAR_TRUE: bool = unsafe { raw_eq(&'a', &'a') };\n+    assert!(RAW_EQ_CHAR_TRUE);\n+\n+    const RAW_EQ_CHAR_FALSE: bool = unsafe { raw_eq(&'a', &'A') };\n+    assert!(!RAW_EQ_CHAR_FALSE);\n+\n+    const RAW_EQ_ARRAY_TRUE: bool = unsafe { raw_eq(&[13_u8, 42], &[13, 42]) };\n+    assert!(RAW_EQ_ARRAY_TRUE);\n+\n+    const RAW_EQ_ARRAY_FALSE: bool = unsafe { raw_eq(&[13_u8, 42], &[42, 13]) };\n+    assert!(!RAW_EQ_ARRAY_FALSE);\n+}"}]}