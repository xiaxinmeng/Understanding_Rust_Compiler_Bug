{"sha": "dbc4a4b53b91e687429db622626a6eb221252b04", "node_id": "MDY6Q29tbWl0NzI0NzEyOmRiYzRhNGI1M2I5MWU2ODc0MjlkYjYyMjYyNmE2ZWIyMjEyNTJiMDQ=", "commit": {"author": {"name": "Jakub Wieczorek", "email": "jakub@jakub.cc", "date": "2014-10-14T18:41:50Z"}, "committer": {"name": "Jakub Wieczorek", "email": "jakub@jakub.cc", "date": "2014-10-15T09:02:50Z"}, "message": "Make memoize!() a function instead", "tree": {"sha": "391137100207e6d806f557b171c0bb63096f8efe", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/391137100207e6d806f557b171c0bb63096f8efe"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/dbc4a4b53b91e687429db622626a6eb221252b04", "comment_count": 5, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/dbc4a4b53b91e687429db622626a6eb221252b04", "html_url": "https://github.com/rust-lang/rust/commit/dbc4a4b53b91e687429db622626a6eb221252b04", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/dbc4a4b53b91e687429db622626a6eb221252b04/comments", "author": null, "committer": null, "parents": [{"sha": "c2e8f3b481fd41f801c3e79d43861e8e86cd1a44", "url": "https://api.github.com/repos/rust-lang/rust/commits/c2e8f3b481fd41f801c3e79d43861e8e86cd1a44", "html_url": "https://github.com/rust-lang/rust/commit/c2e8f3b481fd41f801c3e79d43861e8e86cd1a44"}], "stats": {"total": 404, "additions": 192, "deletions": 212}, "files": [{"sha": "6d5cd6061cfae9940e744eb9b63661b768129645", "filename": "src/librustc/lib.rs", "status": "modified", "additions": 2, "deletions": 6, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/dbc4a4b53b91e687429db622626a6eb221252b04/src%2Flibrustc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dbc4a4b53b91e687429db622626a6eb221252b04/src%2Flibrustc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flib.rs?ref=dbc4a4b53b91e687429db622626a6eb221252b04", "patch": "@@ -29,12 +29,9 @@ This API is completely unstable and subject to change.\n       html_root_url = \"http://doc.rust-lang.org/nightly/\")]\n \n #![allow(deprecated)]\n-#![allow(unknown_features)]\n-#![feature(macro_rules, globs, struct_variant, quote)]\n-#![feature(default_type_params, phase, unsafe_destructor, slicing_syntax)]\n-\n+#![feature(default_type_params, globs, if_let, import_shadowing, macro_rules, phase, quote)]\n+#![feature(slicing_syntax, struct_variant, unsafe_destructor)]\n #![feature(rustc_diagnostic_macros)]\n-#![feature(import_shadowing)]\n \n extern crate arena;\n extern crate debug;\n@@ -97,7 +94,6 @@ pub mod middle {\n     pub mod intrinsicck;\n     pub mod lang_items;\n     pub mod liveness;\n-    pub mod macros;\n     pub mod mem_categorization;\n     pub mod pat_util;\n     pub mod privacy;"}, {"sha": "3d38e0fd5ed979d6d5efd7b19afc4330b34b169a", "filename": "src/librustc/middle/macros.rs", "status": "removed", "additions": 0, "deletions": 71, "changes": 71, "blob_url": "https://github.com/rust-lang/rust/blob/c2e8f3b481fd41f801c3e79d43861e8e86cd1a44/src%2Flibrustc%2Fmiddle%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c2e8f3b481fd41f801c3e79d43861e8e86cd1a44/src%2Flibrustc%2Fmiddle%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fmacros.rs?ref=c2e8f3b481fd41f801c3e79d43861e8e86cd1a44", "patch": "@@ -1,71 +0,0 @@\n-// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-#![macro_escape]\n-\n-macro_rules! memoize_expand_block(\n-    ($cache_map:expr, $cache_key:expr, $($param_name:ident: $param_ty:ty),*) => { {\n-        match ($cache_map).borrow().find(&$cache_key) {\n-            Some(ref result) => return (*result).clone(),\n-            None => {}\n-        }\n-        let result = inner($($param_name), *);\n-        ($cache_map).borrow_mut().insert($cache_key, result.clone());\n-        result\n-    } }\n-)\n-\n-/// Memoizes a function using a cache that is available by evaluating the\n-/// `$cache_map` exression in the context of the function's arguments.\n-/// `$cache_key` is the expression that will be used to compute the cache key\n-/// for each function invocation.\n-///\n-/// The macro assumes the cache to be a RefCell containing a HashMap,\n-/// which is in practice how most caching in rustc is currently carried out.\n-///\n-/// # Example\n-///\n-/// ```\n-/// struct Context {\n-///     fibonacci_cache: RefCell<HashMap<uint, uint>>\n-/// }\n-///\n-/// memoize!(context.fibonacci_cache, n,\n-/// fn fibonacci(context: &Context, n: uint) -> uint {\n-///     match n {\n-///         0 | 1 => n,\n-///         _ => fibonacci(n - 2) + fibonacci(n - 1)\n-///     }\n-/// }\n-/// )\n-/// ```\n-macro_rules! memoize(\n-    ($cache_map:expr, $cache_key:expr,\n-        fn $name:ident(\n-            $($param_name:ident: $param_ty:ty),*\n-        ) -> $output_ty:ty $block:block\n-    ) => {\n-        fn $name($($param_name: $param_ty), *) -> $output_ty {\n-            fn inner($($param_name: $param_ty), *) -> $output_ty $block\n-            memoize_expand_block!($cache_map, $cache_key, $($param_name: $param_ty), *)\n-        }\n-    };\n-\n-    ($cache_map:expr, $cache_key:expr,\n-        pub fn $name:ident(\n-            $($param_name:ident: $param_ty:ty),*\n-        ) -> $output_ty:ty $block:block\n-    ) => {\n-        pub fn $name($($param_name: $param_ty), *) -> $output_ty {\n-            fn inner($($param_name: $param_ty), *) -> $output_ty $block\n-            memoize_expand_block!($cache_map, $cache_key, $($param_name: $param_ty), *)\n-        }\n-    }\n-)"}, {"sha": "06d3623006813e227f58263a1457ba839eafa173", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 134, "deletions": 133, "changes": 267, "blob_url": "https://github.com/rust-lang/rust/blob/dbc4a4b53b91e687429db622626a6eb221252b04/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dbc4a4b53b91e687429db622626a6eb221252b04/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=dbc4a4b53b91e687429db622626a6eb221252b04", "patch": "@@ -33,7 +33,7 @@ use middle;\n use util::ppaux::{note_and_explain_region, bound_region_ptr_to_string};\n use util::ppaux::{trait_store_to_string, ty_to_string};\n use util::ppaux::{Repr, UserString};\n-use util::common::{indenter};\n+use util::common::{indenter, memoized, memoized_with_key};\n use util::nodemap::{NodeMap, NodeSet, DefIdMap, DefIdSet, FnvHashMap};\n \n use std::cell::{Cell, RefCell};\n@@ -2117,37 +2117,37 @@ pub fn type_needs_drop(cx: &ctxt, ty: t) -> bool {\n // task can free them all at once later. Currently only things\n // that only contain scalars and shared boxes can avoid unwind\n // cleanups.\n-memoize!(cx.needs_unwind_cleanup_cache, ty,\n-fn type_needs_unwind_cleanup_(cx: &ctxt, ty: t, tycache: &mut HashSet<t>) -> bool {\n-    // Prevent infinite recursion\n-    if !tycache.insert(ty) {\n-        return false;\n-    }\n-\n-    let mut needs_unwind_cleanup = false;\n-    maybe_walk_ty(ty, |ty| {\n-        needs_unwind_cleanup |= match get(ty).sty {\n-            ty_nil | ty_bot | ty_bool | ty_int(_) | ty_uint(_) |\n-            ty_float(_) | ty_tup(_) | ty_ptr(_) => false,\n-\n-            ty_enum(did, ref substs) =>\n-                enum_variants(cx, did).iter().any(|v|\n-                    v.args.iter().any(|aty| {\n-                        let t = aty.subst(cx, substs);\n-                        type_needs_unwind_cleanup_(cx, t, tycache)\n-                    })\n-                ),\n-\n-            _ => true\n-        };\n-        !needs_unwind_cleanup\n+pub fn type_needs_unwind_cleanup(cx: &ctxt, ty: t) -> bool {\n+    return memoized(&cx.needs_unwind_cleanup_cache, ty, |ty| {\n+        type_needs_unwind_cleanup_(cx, ty, &mut HashSet::new())\n     });\n-    needs_unwind_cleanup\n-}\n-)\n \n-pub fn type_needs_unwind_cleanup(cx: &ctxt, ty: t) -> bool {\n-    type_needs_unwind_cleanup_(cx, ty, &mut HashSet::new())\n+    fn type_needs_unwind_cleanup_(cx: &ctxt, ty: t, tycache: &mut HashSet<t>) -> bool {\n+        // Prevent infinite recursion\n+        if !tycache.insert(ty) {\n+            return false;\n+        }\n+\n+        let mut needs_unwind_cleanup = false;\n+        maybe_walk_ty(ty, |ty| {\n+            needs_unwind_cleanup |= match get(ty).sty {\n+                ty_nil | ty_bot | ty_bool | ty_int(_) | ty_uint(_) |\n+                ty_float(_) | ty_tup(_) | ty_ptr(_) => false,\n+\n+                ty_enum(did, ref substs) =>\n+                    enum_variants(cx, did).iter().any(|v|\n+                        v.args.iter().any(|aty| {\n+                            let t = aty.subst(cx, substs);\n+                            type_needs_unwind_cleanup_(cx, t, tycache)\n+                        })\n+                    ),\n+\n+                _ => true\n+            };\n+            !needs_unwind_cleanup\n+        });\n+        needs_unwind_cleanup\n+    }\n }\n \n /**\n@@ -2342,9 +2342,10 @@ pub fn type_interior_is_unsafe(cx: &ctxt, t: ty::t) -> bool {\n     type_contents(cx, t).interior_unsafe()\n }\n \n-memoize!(cx.tc_cache, type_id(ty),\n pub fn type_contents(cx: &ctxt, ty: t) -> TypeContents {\n-    return tc_ty(cx, ty, &mut HashMap::new());\n+    return memoized_with_key(&cx.tc_cache, ty, |ty| {\n+        tc_ty(cx, ty, &mut HashMap::new())\n+    }, |&ty| type_id(ty));\n \n     fn tc_ty(cx: &ctxt,\n              ty: t,\n@@ -2659,7 +2660,6 @@ pub fn type_contents(cx: &ctxt, ty: t) -> TypeContents {\n         }\n     }\n }\n-)\n \n pub fn type_moves_by_default(cx: &ctxt, ty: t) -> bool {\n     type_contents(cx, ty).moves_by_default(cx)\n@@ -4008,23 +4008,23 @@ pub fn impl_or_trait_item(cx: &ctxt, id: ast::DefId) -> ImplOrTraitItem {\n \n /// Returns true if the given ID refers to an associated type and false if it\n /// refers to anything else.\n-memoize!(cx.associated_types, id,\n pub fn is_associated_type(cx: &ctxt, id: ast::DefId) -> bool {\n-    if id.krate == ast::LOCAL_CRATE {\n-        match cx.impl_or_trait_items.borrow().find(&id) {\n-            Some(ref item) => {\n-                match **item {\n-                    TypeTraitItem(_) => true,\n-                    MethodTraitItem(_) => false,\n+    memoized(&cx.associated_types, id, |id: ast::DefId| {\n+        if id.krate == ast::LOCAL_CRATE {\n+            match cx.impl_or_trait_items.borrow().find(&id) {\n+                Some(ref item) => {\n+                    match **item {\n+                        TypeTraitItem(_) => true,\n+                        MethodTraitItem(_) => false,\n+                    }\n                 }\n+                None => false,\n             }\n-            None => false,\n+        } else {\n+            csearch::is_associated_type(&cx.sess.cstore, id)\n         }\n-    } else {\n-        csearch::is_associated_type(&cx.sess.cstore, id)\n-    }\n+    })\n }\n-)\n \n /// Returns the parameter index that the given associated type corresponds to.\n pub fn associated_type_parameter_index(cx: &ctxt,\n@@ -4080,31 +4080,31 @@ pub fn trait_item_def_ids(cx: &ctxt, id: ast::DefId)\n     })\n }\n \n-memoize!(cx.impl_trait_cache, id,\n pub fn impl_trait_ref(cx: &ctxt, id: ast::DefId) -> Option<Rc<TraitRef>> {\n-    if id.krate == ast::LOCAL_CRATE {\n-        debug!(\"(impl_trait_ref) searching for trait impl {:?}\", id);\n-        match cx.map.find(id.node) {\n-            Some(ast_map::NodeItem(item)) => {\n-                match item.node {\n-                    ast::ItemImpl(_, ref opt_trait, _, _) => {\n-                        match opt_trait {\n-                            &Some(ref t) => {\n-                                Some(ty::node_id_to_trait_ref(cx, t.ref_id))\n+    memoized(&cx.impl_trait_cache, id, |id: ast::DefId| {\n+        if id.krate == ast::LOCAL_CRATE {\n+            debug!(\"(impl_trait_ref) searching for trait impl {:?}\", id);\n+            match cx.map.find(id.node) {\n+                Some(ast_map::NodeItem(item)) => {\n+                    match item.node {\n+                        ast::ItemImpl(_, ref opt_trait, _, _) => {\n+                            match opt_trait {\n+                                &Some(ref t) => {\n+                                    Some(ty::node_id_to_trait_ref(cx, t.ref_id))\n+                                }\n+                                &None => None\n                             }\n-                            &None => None\n                         }\n+                        _ => None\n                     }\n-                    _ => None\n                 }\n+                _ => None\n             }\n-            _ => None\n+        } else {\n+            csearch::get_impl_trait(cx, id)\n         }\n-    } else {\n-        csearch::get_impl_trait(cx, id)\n-    }\n+    })\n }\n-)\n \n pub fn trait_ref_to_def_id(tcx: &ctxt, tr: &ast::TraitRef) -> ast::DefId {\n     let def = *tcx.def_map.borrow()\n@@ -4288,66 +4288,67 @@ pub fn type_is_empty(cx: &ctxt, t: t) -> bool {\n      }\n }\n \n-memoize!(cx.enum_var_cache, id,\n pub fn enum_variants(cx: &ctxt, id: ast::DefId) -> Rc<Vec<Rc<VariantInfo>>> {\n-    if ast::LOCAL_CRATE != id.krate {\n-        Rc::new(csearch::get_enum_variants(cx, id))\n-    } else {\n-        /*\n-          Although both this code and check_enum_variants in typeck/check\n-          call eval_const_expr, it should never get called twice for the same\n-          expr, since check_enum_variants also updates the enum_var_cache\n-         */\n-        match cx.map.get(id.node) {\n-            ast_map::NodeItem(ref item) => {\n-                match item.node {\n-                    ast::ItemEnum(ref enum_definition, _) => {\n-                        let mut last_discriminant: Option<Disr> = None;\n-                        Rc::new(enum_definition.variants.iter().map(|variant| {\n-\n-                            let mut discriminant = match last_discriminant {\n-                                Some(val) => val + 1,\n-                                None => INITIAL_DISCRIMINANT_VALUE\n-                            };\n-\n-                            match variant.node.disr_expr {\n-                                Some(ref e) => match const_eval::eval_const_expr_partial(cx, &**e) {\n-                                    Ok(const_eval::const_int(val)) => {\n-                                        discriminant = val as Disr\n-                                    }\n-                                    Ok(const_eval::const_uint(val)) => {\n-                                        discriminant = val as Disr\n-                                    }\n-                                    Ok(_) => {\n-                                        cx.sess\n-                                          .span_err(e.span,\n-                                                    \"expected signed integer constant\");\n-                                    }\n-                                    Err(ref err) => {\n-                                        cx.sess\n-                                          .span_err(e.span,\n-                                                    format!(\"expected constant: {}\",\n-                                                            *err).as_slice());\n-                                    }\n-                                },\n-                                None => {}\n-                            };\n-\n-                            last_discriminant = Some(discriminant);\n-                            Rc::new(VariantInfo::from_ast_variant(cx, &**variant,\n-                                                                  discriminant))\n-                        }).collect())\n-                    }\n-                    _ => {\n-                        cx.sess.bug(\"enum_variants: id not bound to an enum\")\n+    memoized(&cx.enum_var_cache, id, |id: ast::DefId| {\n+        if ast::LOCAL_CRATE != id.krate {\n+            Rc::new(csearch::get_enum_variants(cx, id))\n+        } else {\n+            /*\n+              Although both this code and check_enum_variants in typeck/check\n+              call eval_const_expr, it should never get called twice for the same\n+              expr, since check_enum_variants also updates the enum_var_cache\n+             */\n+            match cx.map.get(id.node) {\n+                ast_map::NodeItem(ref item) => {\n+                    match item.node {\n+                        ast::ItemEnum(ref enum_definition, _) => {\n+                            let mut last_discriminant: Option<Disr> = None;\n+                            Rc::new(enum_definition.variants.iter().map(|variant| {\n+\n+                                let mut discriminant = match last_discriminant {\n+                                    Some(val) => val + 1,\n+                                    None => INITIAL_DISCRIMINANT_VALUE\n+                                };\n+\n+                                match variant.node.disr_expr {\n+                                    Some(ref e) =>\n+                                        match const_eval::eval_const_expr_partial(cx, &**e) {\n+                                            Ok(const_eval::const_int(val)) => {\n+                                                discriminant = val as Disr\n+                                            }\n+                                            Ok(const_eval::const_uint(val)) => {\n+                                                discriminant = val as Disr\n+                                            }\n+                                            Ok(_) => {\n+                                                cx.sess\n+                                                  .span_err(e.span,\n+                                                            \"expected signed integer constant\");\n+                                            }\n+                                            Err(ref err) => {\n+                                                cx.sess\n+                                                  .span_err(e.span,\n+                                                            format!(\"expected constant: {}\",\n+                                                                    *err).as_slice());\n+                                            }\n+                                        },\n+                                    None => {}\n+                                };\n+\n+                                last_discriminant = Some(discriminant);\n+                                Rc::new(VariantInfo::from_ast_variant(cx, &**variant,\n+                                                                      discriminant))\n+                            }).collect())\n+                        }\n+                        _ => {\n+                            cx.sess.bug(\"enum_variants: id not bound to an enum\")\n+                        }\n                     }\n                 }\n+                _ => cx.sess.bug(\"enum_variants: id not bound to an enum\")\n             }\n-            _ => cx.sess.bug(\"enum_variants: id not bound to an enum\")\n         }\n-    }\n+    })\n }\n-)\n \n // Returns information about the enum variant with the given ID:\n pub fn enum_variant_with_id(cx: &ctxt,\n@@ -4372,12 +4373,12 @@ pub fn lookup_item_type(cx: &ctxt,\n }\n \n /// Given the did of a trait, returns its canonical trait ref.\n-memoize!(cx.trait_defs, did,\n-pub fn lookup_trait_def(cx: &ctxt, did: ast::DefId) -> Rc<ty::TraitDef> {\n-    assert!(did.krate != ast::LOCAL_CRATE);\n-    Rc::new(csearch::get_trait_def(cx, did))\n+pub fn lookup_trait_def(cx: &ctxt, did: DefId) -> Rc<ty::TraitDef> {\n+    memoized(&cx.trait_defs, did, |did: DefId| {\n+        assert!(did.krate != ast::LOCAL_CRATE);\n+        Rc::new(csearch::get_trait_def(cx, did))\n+    })\n }\n-)\n \n /// Given a reference to a trait, returns the bounds declared on the\n /// trait, with appropriate substitutions applied.\n@@ -4436,21 +4437,21 @@ pub fn lookup_simd(tcx: &ctxt, did: DefId) -> bool {\n }\n \n /// Obtain the representation annotation for a struct definition.\n-memoize!(tcx.repr_hint_cache, did,\n pub fn lookup_repr_hints(tcx: &ctxt, did: DefId) -> Rc<Vec<attr::ReprAttr>> {\n-    Rc::new(if did.krate == LOCAL_CRATE {\n-        let mut acc = Vec::new();\n-        ty::each_attr(tcx, did, |meta| {\n-            acc.extend(attr::find_repr_attrs(tcx.sess.diagnostic(),\n-                                             meta).into_iter());\n-            true\n-        });\n-        acc\n-    } else {\n-        csearch::get_repr_attrs(&tcx.sess.cstore, did)\n+    memoized(&tcx.repr_hint_cache, did, |did: DefId| {\n+        Rc::new(if did.krate == LOCAL_CRATE {\n+            let mut acc = Vec::new();\n+            ty::each_attr(tcx, did, |meta| {\n+                acc.extend(attr::find_repr_attrs(tcx.sess.diagnostic(),\n+                                                 meta).into_iter());\n+                true\n+            });\n+            acc\n+        } else {\n+            csearch::get_repr_attrs(&tcx.sess.cstore, did)\n+        })\n     })\n }\n-)\n \n // Look up a field ID, whether or not it's local\n // Takes a list of type substs in case the struct is generic"}, {"sha": "8ea9015c05d97d4d96ce5c44bad5cc05bc9e9c82", "filename": "src/librustc/util/common.rs", "status": "modified", "additions": 56, "deletions": 2, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/dbc4a4b53b91e687429db622626a6eb221252b04/src%2Flibrustc%2Futil%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dbc4a4b53b91e687429db622626a6eb221252b04/src%2Flibrustc%2Futil%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fcommon.rs?ref=dbc4a4b53b91e687429db622626a6eb221252b04", "patch": "@@ -1,4 +1,4 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n+// Copyright 2012-2014 The Rust Project Developers. See the COPYRIGHT\n // file at the top-level directory of this distribution and at\n // http://rust-lang.org/COPYRIGHT.\n //\n@@ -10,8 +10,9 @@\n \n #![allow(non_camel_case_types)]\n \n-use std::hash::{Hash, Hasher};\n+use std::cell::RefCell;\n use std::collections::HashMap;\n+use std::hash::{Hash, Hasher};\n use syntax::ast;\n use syntax::visit;\n use syntax::visit::Visitor;\n@@ -155,3 +156,56 @@ pub fn can_reach<S,H:Hasher<S>,T:Eq+Clone+Hash<S>>(\n     }\n     return false;\n }\n+\n+/// Memoizes a one-argument closure using the given RefCell containing\n+/// a type implementing MutableMap to serve as a cache.\n+///\n+/// In the future the signature of this function is expected to be:\n+/// ```\n+/// pub fn memoized<T: Clone, U: Clone, M: MutableMap<T, U>>(\n+///    cache: &RefCell<M>,\n+///    f: &|&: T| -> U\n+/// ) -> impl |&: T| -> U {\n+/// ```\n+/// but currently it is not possible.\n+///\n+/// # Example\n+/// ```\n+/// struct Context {\n+///    cache: RefCell<HashMap<uint, uint>>\n+/// }\n+///\n+/// fn factorial(ctxt: &Context, n: uint) -> uint {\n+///     memoized(&ctxt.cache, n, |n| match n {\n+///         0 | 1 => n,\n+///         _ => factorial(ctxt, n - 2) + factorial(ctxt, n - 1)\n+///     })\n+/// }\n+/// ```\n+#[inline(always)]\n+pub fn memoized<T: Clone, U: Clone, M: MutableMap<T, U>>(\n+    cache: &RefCell<M>,\n+    arg: T,\n+    f: |T| -> U\n+) -> U {\n+    memoized_with_key(cache, arg, f, |arg| arg.clone())\n+}\n+\n+#[inline(always)]\n+pub fn memoized_with_key<T, K, U: Clone, M: MutableMap<K, U>>(\n+    cache: &RefCell<M>,\n+    arg: T,\n+    f: |T| -> U,\n+    k: |&T| -> K\n+) -> U {\n+    let key = k(&arg);\n+    let result = cache.borrow().find(&key).map(|result| result.clone());\n+    match result {\n+        Some(result) => result,\n+        None => {\n+            let result = f(arg);\n+            cache.borrow_mut().insert(key, result.clone());\n+            result\n+        }\n+    }\n+}"}]}