{"sha": "5654387e775d267a1d51976a022ce25df9d70a9e", "node_id": "MDY6Q29tbWl0NzI0NzEyOjU2NTQzODdlNzc1ZDI2N2ExZDUxOTc2YTAyMmNlMjVkZjlkNzBhOWU=", "commit": {"author": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2020-01-13T16:15:50Z"}, "committer": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2020-01-13T18:00:42Z"}, "message": "Don't panic if chalk panics", "tree": {"sha": "8caa433c9c2f84e182cdc29abba3c034b4353db6", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8caa433c9c2f84e182cdc29abba3c034b4353db6"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5654387e775d267a1d51976a022ce25df9d70a9e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5654387e775d267a1d51976a022ce25df9d70a9e", "html_url": "https://github.com/rust-lang/rust/commit/5654387e775d267a1d51976a022ce25df9d70a9e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5654387e775d267a1d51976a022ce25df9d70a9e/comments", "author": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "committer": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7ea7de338f1c8ad1e89600e04570f03c2688c0c0", "url": "https://api.github.com/repos/rust-lang/rust/commits/7ea7de338f1c8ad1e89600e04570f03c2688c0c0", "html_url": "https://github.com/rust-lang/rust/commit/7ea7de338f1c8ad1e89600e04570f03c2688c0c0"}], "stats": {"total": 44, "additions": 35, "deletions": 9}, "files": [{"sha": "4aabd66dc6e7b10261f49b913780e0b6083cdd2a", "filename": "crates/ra_hir_ty/src/traits.rs", "status": "modified", "additions": 35, "deletions": 9, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/5654387e775d267a1d51976a022ce25df9d70a9e/crates%2Fra_hir_ty%2Fsrc%2Ftraits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5654387e775d267a1d51976a022ce25df9d70a9e/crates%2Fra_hir_ty%2Fsrc%2Ftraits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Ftraits.rs?ref=5654387e775d267a1d51976a022ce25df9d70a9e", "patch": "@@ -1,10 +1,12 @@\n //! Trait solving using Chalk.\n-use std::sync::{Arc, Mutex};\n+use std::{\n+    panic,\n+    sync::{Arc, Mutex},\n+};\n \n use chalk_ir::cast::Cast;\n use hir_def::{expr::ExprId, DefWithBodyId, ImplId, TraitId, TypeAliasId};\n-use log::debug;\n-use ra_db::{impl_intern_key, salsa, CrateId};\n+use ra_db::{impl_intern_key, salsa, Canceled, CrateId};\n use ra_prof::profile;\n use rustc_hash::FxHashSet;\n \n@@ -39,16 +41,36 @@ impl TraitSolver {\n         goal: &chalk_ir::UCanonical<chalk_ir::InEnvironment<chalk_ir::Goal<TypeFamily>>>,\n     ) -> Option<chalk_solve::Solution<TypeFamily>> {\n         let context = ChalkContext { db, krate: self.krate };\n-        debug!(\"solve goal: {:?}\", goal);\n+        log::debug!(\"solve goal: {:?}\", goal);\n         let mut solver = match self.inner.lock() {\n             Ok(it) => it,\n             // Our cancellation works via unwinding, but, as chalk is not\n             // panic-safe, we need to make sure to propagate the cancellation.\n             // Ideally, we should also make chalk panic-safe.\n             Err(_) => ra_db::Canceled::throw(),\n         };\n-        let solution = solver.solve(&context, goal);\n-        debug!(\"solve({:?}) => {:?}\", goal, solution);\n+\n+        let solution = panic::catch_unwind({\n+            let solver = panic::AssertUnwindSafe(&mut solver);\n+            let context = panic::AssertUnwindSafe(&context);\n+            move || solver.0.solve(context.0, goal)\n+        });\n+\n+        let solution = match solution {\n+            Ok(it) => it,\n+            Err(err) => {\n+                if err.downcast_ref::<Canceled>().is_some() {\n+                    panic::resume_unwind(err)\n+                } else {\n+                    log::error!(\"chalk panicked :-(\");\n+                    // Reset the solver, as it is not panic-safe.\n+                    *solver = create_chalk_solver();\n+                    None\n+                }\n+            }\n+        };\n+\n+        log::debug!(\"solve({:?}) => {:?}\", goal, solution);\n         solution\n     }\n }\n@@ -70,9 +92,13 @@ pub(crate) fn trait_solver_query(\n ) -> TraitSolver {\n     db.salsa_runtime().report_untracked_read();\n     // krate parameter is just so we cache a unique solver per crate\n+    log::debug!(\"Creating new solver for crate {:?}\", krate);\n+    TraitSolver { krate, inner: Arc::new(Mutex::new(create_chalk_solver())) }\n+}\n+\n+fn create_chalk_solver() -> chalk_solve::Solver<TypeFamily> {\n     let solver_choice = chalk_solve::SolverChoice::SLG { max_size: CHALK_SOLVER_MAX_SIZE };\n-    debug!(\"Creating new solver for crate {:?}\", krate);\n-    TraitSolver { krate, inner: Arc::new(Mutex::new(solver_choice.into_solver())) }\n+    solver_choice.into_solver()\n }\n \n /// Collects impls for the given trait in the whole dependency tree of `krate`.\n@@ -181,7 +207,7 @@ pub(crate) fn trait_solve_query(\n     goal: Canonical<InEnvironment<Obligation>>,\n ) -> Option<Solution> {\n     let _p = profile(\"trait_solve_query\");\n-    debug!(\"trait_solve_query({})\", goal.value.value.display(db));\n+    log::debug!(\"trait_solve_query({})\", goal.value.value.display(db));\n \n     if let Obligation::Projection(pred) = &goal.value.value {\n         if let Ty::Bound(_) = &pred.projection_ty.parameters[0] {"}]}